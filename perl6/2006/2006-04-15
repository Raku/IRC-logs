[00:01] *** justatheory joined
[00:14] <dduncan> a clean rebuild had no affect ... but not surprising, as I did that several times for various reasons lately

[00:14] <dduncan> will try explicitly setting the heap size ...

[00:18] <audreyt> it might be parser became too slow after the recent tweaks in comment syntax

[00:18] <audreyt> I'll check that

[00:28] <svnbot6> r9946 | audreyt++ | * Net::IRC - update syntax to use the long dot.

[00:30] <dduncan> audreyt, I'm not sure its strictly that, as I've seen this slowness for a few weeks now, long before that discussion

[00:30] <dduncan> I'm also beginning to wonder if it is specific to 'make test' or the test/smoke ... or to loading modules

[00:31] <dduncan> but you could be right about it being parsing related, since the precompiled prelude opens quickly

[00:31] <dduncan> that is, the prelude loads in about 4 seconds

[00:32] <audreyt> I think it's parsing related

[00:32] <dduncan> does the problem affect you too?

[00:33] <audreyt> yup

[00:33] <dduncan> eg, ext/Test make test takes 200 seconds

[00:34] <dduncan> well, in the mean time I probably won't test or compile my new perl 6 code, but write it by eye so its mostly right

[00:36] *** evalbot_9946 joined
[00:36] <audreyt> ok. I'll let you know when I've got that fixed

[00:39] <audreyt> I think the straightforward fix is to take off all the "try"

[00:39] <audreyt> in the parser

[00:39] <audreyt> and see which things break

[00:39] <audreyt> and fix them ;)

[00:39] <audreyt> TimToady++ for observing it

[00:40] <audreyt> ("try" is the evil "I may backtrack from here anytime" thing in parsec)

[00:40] <lichtkind> ?eval (2|8) == (2|3|5|7);

[00:40] <evalbot_9946> bool::false

[00:40] <lichtkind> ?eval any(2|8) == (2|3|5|7);

[00:41] <evalbot_9946> bool::false

[00:41] <audreyt> ?eval any(2,8) == any(2,3,5,7)

[00:41] <TimToady> do, or do not.  there is no try.

[00:41] <evalbot_9946> bool::false

[00:41] <audreyt> ugh, don't tell me that junctions are suddenly broken

[00:41] <audreyt> ?eval any(1,2) == 1

[00:41] <evalbot_9946> bool::false

[00:42] <TimToady> oopsie

[00:42] <audreyt> ?eval any(1,2) != 1

[00:42] <evalbot_9946> bool::false

[00:42] <TimToady> ?eval any(1,2) > 1

[00:42] <evalbot_9946> bool::false

[00:43] <TimToady> consistent, I'll give it that...

[00:43] <lichtkind> :)

[00:43] <TimToady> ?eval all(1) == 1

[00:43] <evalbot_9946> bool::true

[00:43] <TimToady> ?eval all(1,2,3) == 1

[00:44] <evalbot_9946> bool::false

[00:44] <TimToady> ?eval all(1,2,3) != 4

[00:44] <evalbot_9946> bool::true

[00:44] <TimToady> ?eval one(1,2,3) == 1

[00:44] <evalbot_9946> bool::false

[00:45] <TimToady> that's also broke

[00:46] <TimToady> audreyt: what do you think of rxen default to backtrack, rules don't?

[00:48] <audreyt> true ((1|2)==(2|3))

[00:49] <Juerd> ?eval any(1,2)

[00:49] <audreyt> ?eval true ((1|2)==(2|3))

[00:49] <evalbot_9946> 1

[00:49] <audreyt> TimToady: I think it makes perfect sense

[00:49] <evalbot_9946> bool::true

[00:50] <audreyt> ?eval (1|2)==(2|3)

[00:50] <evalbot_9946> bool::false

[00:50] <audreyt> ?eval true((1|2)==(2|3))

[00:50] <Juerd> I thought longest-match was implemented via backtracking. How is it really?

[00:51] <evalbot_9946> bool::true

[00:51] <Juerd> It occurred to me that backtracking makes no sense for that

[00:51] <TimToady> backtracking almost never makes sense in a parser.

[00:51] <Juerd> (It would be pre-emptive backtracking :P)

[00:52] <Juerd> Agreed

[00:52] <audreyt> so junctions work actually

[00:52] <audreyt> it's just evalbot printing out

[00:52] <audreyt> (bool::false | bool::true)

[00:52] <audreyt> as bool::false

[00:52] <audreyt> for some reason

[00:52] <audreyt> probably bad reason

[00:52] <Juerd> ?eval any(42,15)  # same reason?

[00:52] <Juerd> (42)

[00:52] <evalbot_9946> 15

[00:52] <audreyt> aye

[00:52] <TimToady> if $result == bool::false { say bool::false }

[00:52] <Juerd> Oh, 15

[00:52] <Juerd> It .picks automatically?

[00:53] <audreyt> no

[00:53] <audreyt> 15 sorts first

[00:53] <Juerd> Oh

[00:53] <audreyt> same reason as false

[00:53] <lichtkind> TimToady can i say any @number == ... ?

[00:53] <audreyt> it's internally an ordered set

[00:53] <Juerd> I see

[00:53] <Juerd> So when stringifying, it just takes the first?

[00:54] <Juerd> lichtkind: You should be able to. Though use parens around @number, or it'll not be what you meant. </guess>

[00:55] <lichtkind> Juerd yes becaus that would make much fun and sense to me

[00:55] <TimToady> yes, any(@number) makes a junction.

[00:55] <lichtkind> thanks

[00:55] <TimToady> but it's a list operator, so Juerd is right, you need the parens.

[00:55] <TimToady> or @number.any == ...

[00:56] <lichtkind> i see

[00:56] <lichtkind> i begin to like perl6 :)

[00:56] <lichtkind> √§hm love

[00:56] <lichtkind> :)

[00:57] <Juerd> √§hm looks funny :)

[00:57] <audreyt> hm,

[00:57] <audreyt> parsec thinks that

[00:58] <audreyt> say 1;

[00:58] <audreyt> requires backtracking

[00:58] <audreyt> because it's not

[00:58] <audreyt> say => 1

[00:58] <audreyt> and hence must backtrack from the => rule

[00:58] <audreyt> TimToady: reasonable?

[00:58] <TimToady> that one's probably okay, though in p6 rules it'd be better handled with a lookahead on an ident.

[00:59] <lichtkind> Juerd √§hm ist the german standart phrase for stuttering

[00:59] <audreyt> after an ident, that is

[00:59] <TimToady> yes.

[00:59] <Juerd> lichtkind: I guessed that :)

[00:59] <audreyt> but does it commit after the => ?

[01:00] <TimToady> well, it still has to return both the "ident" and the => tokens somehow, I presume...

[01:00] <TimToady> but yes, the p5 lexer would certainly commit at that point.

[01:02] <audreyt> ok, I'll do it with a lookAhead then

[01:03] <TimToady> and for P6 we've said that => absolutely quotes any bare ident on its left.

[01:03] <TimToady> even if it's a keyword.

[01:04] * audreyt sees a dramatic speed gain in parsing sanity tests immeidately

[01:04] <audreyt> TimToady++

[01:04] *** Khisanth joined
[01:05] <TimToady> so it was basically taking a continuation on every identifier before...

[01:05] <audreyt> aye

[01:07] <audreyt> ok, it's dying on

[01:07] <audreyt> my sub ...

[01:07] <audreyt> complaining that it must backtrack over treating "sub" as a type name

[01:07] <audreyt> as in "my Sub $x"

[01:08] <TimToady> we aren't allowed to have types unless they're already declared, so how can it be deciding that sub is a type?

[01:09] <audreyt> ack. suppose we have sub as a type?

[01:09] <TimToady> then we still recognize sub as a declarator first...

[01:10] <TimToady> gotta have a few reserved words...

[01:10] <TimToady> and surely declarators are about as reserved as they come.

[01:10] <theorbtwo> You think naming a type sub should be illegal?

[01:11] <theorbtwo> Or, for that matter, a sub my?

[01:11] <TimToady> No, but expecting it to work in "my sub" should be without saying "my ::sub".

[01:12] <theorbtwo> Hm, I think I can deal with that.

[01:12] <Juerd> my my my my $foo;

[01:12] <TimToady> I have no problem with making people go through sigilish contortions if they want to declare things that are the same name as declarators.

[01:12] <Juerd> # mine!

[01:12] <TimToady> ?eval my my $foo;

[01:13] <theorbtwo> my own $previous

[01:13] <evalbot_9946> undef

[01:13] <TimToady> ?eval my my my my $foo = 1;  $foo;

[01:13] <audreyt> (currently the concept of "known type" only applies to bareword literals)

[01:13] <evalbot_9946> Error:  unexpected "m" expecting "#", variable name or "("

[01:15] <audreyt> hm

[01:15] <audreyt> () is a token that means "an empty list"

[01:16] <TimToady> in list context, at least

[01:16] <audreyt> in scalar context it still means that...

[01:16] <audreyt> my $x = ();

[01:16] <audreyt> it's just an object

[01:16] <Juerd> A list in non-list context is HARD for my brain

[01:16] <audreyt> in any case, currently for the parser it is not a "parenthesized nothing"

[01:16] <audreyt> as we said parenthesized anything is itself

[01:17] <audreyt> but () is an exception

[01:17] <lichtkind> juerd sorry still having problems with installing

[01:17] <lichtkind> ?eval my $wahr; $wahr ?^= 1;

[01:17] <Juerd> Why would () be legal outside list context?

[01:17] <evalbot_9946> Error: No such sub: "&infix:?^"

[01:17] <audreyt> so parsec is complaining that it must "backtrack"

[01:17] <Juerd> Does it have any use?

[01:17] <audreyt> between these two interpretations

[01:17] <TimToady> (1+2)*3

[01:17] <Juerd> TimToady: I meant empty ()

[01:18] <Juerd> I assume it just means "undef" in non-list context, and I think it's much wiser to spell "undef" if that's what you mean.

[01:18] <TimToady> return; is essentially return ();

[01:19] <audreyt> Juerd: I think otherwise...

[01:19] <Juerd> audreyt: What exactly do you think, then?

[01:19] <audreyt> my $x = ();

[01:19] <TimToady> there are probably lots of places where you can't tell whether () is going to be in list/scalar context till you bind

[01:19] <audreyt> the class of $x ought to be List, or Tuple, or something

[01:19] <Juerd> In your opinion, that's better than my $x = undef?

[01:19] <Juerd> A List class is also too hard for me.

[01:20] <Juerd> TimToady: That makes sense

[01:20] <audreyt> ok, I mean

[01:20] <audreyt> $x = (); and $x = (,)

[01:20] <audreyt> should probably mean the same thing

[01:20] <Juerd> I think (,) is prefix comma, which doesn't exist?

[01:20] <Juerd> Or term comma, same thing

[01:21] <audreyt> true. how else am I to write an empty list other than () then :)

[01:21] <TimToady> p5 calls it a syntax error

[01:21] <audreyt> $x = (1,2); # $x.elems == 2

[01:21] <audreyt> $x = (1,); # $x.elems == 1

[01:21] <Juerd> Well, in list context, it's perfectly normal to have a list, and I'm not arguing that () should be illegal in list context.

[01:21] <audreyt> $x = (); # $x.elems == 0

[01:22] <theorbtwo> An anime smile with crossed eyes and a broken nose?

[01:22] <Juerd> I just think that as soon as it can be determined that () isn't in list context, a warning may be useful.

[01:22] <lichtkind> is ?^= illegal or not implemented?

[01:22] <theorbtwo> audreyt: What's wrong with $x=[] for that?

[01:22] <audreyt> theorbtwo: that makes $x.push(3) legal

[01:22] <Juerd> audreyt: What's $x then? And why any List class, when we have Arrays?

[01:23] <theorbtwo> Hm.

[01:23] <audreyt> Juerd: because, well, Arrays are mutable?

[01:23] <audreyt> and it might be easier (and lighter weight) to pass around lists instead of array containers?

[01:23] <Juerd> Sure, but lists historically couldn't be named. I liked that.

[01:24] <Juerd> I think there is a huge gap in my 5-to-6 knowledge, and I can't explain where it came from. To me, a world without references, and with exposed lists, just doesn't work yet, because I know none of the semantics.

[01:24] <TimToady> For most scalar purposes, a null list stuffed into a scalar will eventually get you your warning anyway.

[01:25] <Juerd> TimToady: But how is it a *list* without being in list context?

[01:25] <Juerd> () isn't a list constructor, I thought.

[01:25] <Juerd> Or is empty () special, in that it is?

[01:26] <audreyt> that was what I was asking (and proposing that it is)

[01:26] <lichtkind> godnight

[01:26] <audreyt> infix list-assoc comma is definitely list constructor.

[01:26] <Juerd> lichtkind: Schlaf gut

[01:26] <lichtkind> juerd danke

[01:26] <audreyt> but (,) is illegal

[01:26] <TimToady> schlop shoen

[01:26] <audreyt> so there should be something in its place, and () is natural

[01:27] <Juerd> audreyt: Can you describe List a bit more for me? Is there anything else, besides being immutable, that differentiates it from Array?

[01:27] <TimToady> I think it's okay for () to be a null list.  At worst, what you end up with a funny way to write "0 or undef"

[01:28] <audreyt> Juerd: okay. a List is implemented as a Tuple

[01:28] <audreyt> which has fixed number of items, all fully evaluated

[01:28] <audreyt> or a Range, which is evaluated lazily

[01:29] <audreyt> or some other mixture subclasses.

[01:29] <Juerd> Do Lists have anything to do with list context?

[01:29] <audreyt> a List object flattens under list context.

[01:29] <Juerd> i.e. is the RHS of "my @foo = ..." a List?

[01:29] <audreyt> yes. the RHS is evaluated under list contexts

[01:30] <audreyt> and concated into a single List object

[01:30] <Juerd> So everything that is in list context, is in a List object, but you can also have List objects without list context.

[01:30] <audreyt> or rather

[01:30] <audreyt> my @foo = 5;

[01:30] <audreyt> this evaluated 5 in list context

[01:30] <audreyt> effectively casting Int to List

[01:31] <audreyt> which uses the default singleton cast

[01:31] <audreyt> i.e. 5 becomes (5,)

[01:31] <audreyt> which is then stored into @foo

[01:31] <Juerd> Can an @-sigiled variable be a List instead of an Array?

[01:31] <audreyt> yes. sigil has nothing to do with what it may be bound

[01:31] <audreyt> only what it is bound by default

[01:31] <audreyt> @x := (1,2,3); @x.push(4); # fails

[01:31] <Juerd> Does that mean @foo could be a scalar?

[01:32] <audreyt> @x := [1,2,3]; @x.push(4); # works

[01:32] <audreyt> @x := 5; @x.push(6); # fails, but only because Int doesn't implement push

[01:32] <Juerd> Hmm

[01:33] <audreyt> Juerd: I really don't see why not; sigils are context hinters

[01:33] <audreyt> it may make sense to restrict it in the compiler

[01:33] <audreyt> but conceptually I don't see much difference underneath.

[01:33] <Juerd> Does a List in $foo flatten in list context, or does the $ sigil prevent that?

[01:34] <TimToady> $ prevents it

[01:34] <audreyt> the flattening is controled statically, and where a hinter is visible, you use that hinter

[01:34] <audreyt> the List in $foo is runtime knowledge

[01:34] <Juerd> I see

[01:34] <audreyt> so $ wins

[01:34] <Juerd> It's starting to make sense

[01:34] <TimToady> things which have both scalar and list natures have to use the hints

[01:35] <TimToady> consistently

[01:35] <Juerd> And then indeed () would have to mean empty list, because (,) is ugly and would otherwise also be special.

[01:35] <TimToady> $foo always means scalar nature even if the insides are plural

[01:35] <TimToady> yes

[01:36] <Juerd> Okay. Lots of syntax is flowing through my mind now, and I can notice that I'm (not entirely consciously) testing this new knowledge against what I knew already.

[01:36] <Juerd> This is probably a good moment for me to go to bed

[01:37] <TimToady> my smoke took 152 minutes.

[01:37] <TimToady> when you settle down the parser again, I can run another and see what the diff is

[01:38] <Juerd> What were the reasons again for not making (...) a list constructor?

[01:38] <audreyt> because (1+2)+3 is too common

[01:38] <audreyt> I mean (1+2)*3

[01:39] <audreyt> and trailing comma makes singleton lists simple

[01:39] <Juerd> But couldn't a List evaluate to its only element if it has only one?

[01:39] <TimToady> on the other hand, one could claim that a singleton list always promotes to its single value in scalar context

[01:39] <audreyt> it could, but what of method calls?

[01:39] <audreyt> (1+2).moose

[01:39] <audreyt> is it calling a list method or a int method?

[01:40] <audreyt> so, probably not a good idea to mix both forms.

[01:40] <Juerd> Well, in the old world, objects were always references, and references were scalars, so the LHS of . would be forced into scalar context.

[01:40] <TimToady> the left side of dot is always scalar.

[01:40] <TimToady> even in @foo.sort

[01:40] <Juerd> But I don't know what that story looks like in current thinking...

[01:40] <audreyt> well, but that means

[01:40] <audreyt> (1+2,).sqrt

[01:40] <audreyt> would be calling Int.sqrt

[01:40] <audreyt> (1,).elems

[01:40] <audreyt> would becalling Int.elems

[01:41] <audreyt> probably a bad idea, really.

[01:41] <audreyt> I'd much rather (1).elems calls Int.elems and (1,).elems calls List.elems.

[01:42] <TimToady> I'm okay with continuing to overload (...) that way

[01:42] <Juerd> It's a shame () has three meanings.

[01:42] <audreyt> and really it's only the bare () literal is overloaded

[01:42] <Juerd> We have "hash { }" and "sub { }". Would "array [ ]" and "list [ ]" make any sense?

[01:42] <TimToady> ASCII just doesn't have enough brackets...  I've noticed this before...

[01:42] <audreyt> since otherwise it's the infix , taking control

[01:42] <audreyt> an alternative would be allowing (,) but I think it's ugly :)

[01:43] <Juerd> (,) is harder to explain too.

[01:43] <TimToady> Actually, we changed it to hash() at some point or other.

[01:43] <Juerd> hash(*@)?

[01:43] <TimToady> yes, basically

[01:43] <Juerd> Hm

[01:44] <Juerd> That feels very notperlish.

[01:44] <clkao> *yawn*

[01:44] <TimToady> could MMD to hash(&) I suppose

[01:44] <Juerd> 'cause I'd prefix "hash" to disambiguate an existing {} when I realise it could be ambiguous

[01:45] <audreyt> (I've tripped over this for countless times too)

[01:45] <Juerd> Hmmm

[01:46] <Juerd> Now that we no longer have references, we no longer have dereferencing. Doesn't that enable us to use more sigils, by re-using existing ones?

[01:46] <Juerd> i.e. $$, @@, %%

[01:46] <audreyt> well, $$x still means castng the value of $x into Scalar

[01:46] <TimToady> We still have dereferencing, just no references.  It's like the radio without the cat

[01:47] <Juerd> Okay. I'll ask about that later, and go to bed first :)

[01:47] <audreyt> it's just the value of $x may be another Scalar object now

[01:47] <audreyt> or a Capture, I mean Arguments, I mean Match

[01:47] <audreyt> (or all of the above)

[01:47] <Juerd> I was thinking maybe $$, @@ and %% could mean immutable scalar, array, hash. Where immutable array happens to be list.

[01:47] <TimToady> pm's problem with unifying Capture with Match was that Match wants more info, like where the match starts and stops...

[01:47] <Juerd> But that probably won't work if $$ is still taken :)

[01:48] <TimToady> we left it at Match maybe being derived from Capture...

[01:48] <Juerd> Good night!

[01:48] <Juerd> And thanks for explaining this List thing.

[01:48] <TimToady> sleep hard

[01:48] <audreyt> TimToady: but do we get to rename Arguments into Capture?

[01:48] <audreyt> Juerd: thanks for prodding :)

[01:48] <TimToady> Oh, sure, nobody has much qualms about that, unless we want something more *cough* typeglobby *cough* in meaning.

[01:49] <ingy> hi audreyt

[01:49] <audreyt> just rename it to Blog

[01:49] <audreyt> and parallel argument lists into Blogosphere

[01:49] <audreyt> ingy: hi!

[01:49] <TimToady> parallel doesn't work well on spheres

[01:50] <ingy> audreyt: did you do anything with yaml perl ref tags yet?

[01:50] <audreyt> no I did not, I thought you'll come up with test cases

[01:50] <ingy> I owe you a formalish proposal I think

[01:50] <ingy> or test cases :)

[01:50] <audreyt> I just want failing tests

[01:50] <audreyt> ;)

[01:50] <audreyt> test-for-oil

[01:51] <ingy> audreyt: I think !perl/scalar makes not so much sense now

[01:51] <ingy> how do you do `\ [1,2]`

[01:52] <ingy> I think !perl/ref makes more sense

[01:52] <ingy> I'll make the tests

[01:52] <audreyt> \[1,2]

[01:52] <audreyt> would be

[01:53] <audreyt> !perl/scalar/array

[01:53] <audreyt> - 1

[01:53] <audreyt> - 2

[01:53] <audreyt> but if you want to call it ref, sure, call it ref :)

[01:53] <ingy> no way

[01:53] <TimToady> I wonder whether a Match might just be a Capture with mixed in extra props on an as-needed basis.

[01:53] <ingy> how do you anchor the array?

[01:54] <ingy> it would be:

[01:54] <ingy> !perl/ref

[01:54] <ingy>   =: [1, 2]

[01:55] <ingy> or:

[01:55] <ingy> !perl/ref &1

[01:55] <ingy>   =: &2 [1, 2]

[01:55] <ingy> there are two nodes

[01:55] <ingy> you can't collapse them into one

[01:56] <TimToady> Another political take on the whole ref/nonref thing is that, yes, we still have refs, but they just became, um, interestingly complicated refs.

[01:57] <TimToady> so maybe Captures are really Referee objects. :)

[01:57] <audreyt> TimToady: but surely, my $x = @y;

[01:57] <audreyt> doesn't @y into an Referee :)

[01:58] * ingy throws a yelow flag at TimToady 

[01:58] <audreyt> parsec complains:

[01:58] <audreyt> say infix:<+>

[01:58] <audreyt> and

[01:58] <TimToady> Sure, and @$x is appealing to the ref.  :)

[01:59] <audreyt> say infix:;

[01:59] <audreyt> parses differently

[01:59] <audreyt> and it must backtrack over the "tokenish" interpretation of infix:

[02:00] <audreyt> versus a call to &infix in the invocant position.

[02:00] <audreyt> as in

[02:00] <TimToady> another ident lookahead for :<  or :{ maybe?  Hmm..

[02:00] <audreyt> say Moose:;

[02:01] <TimToady> basically infix:<+> is a supertoken, where "standard" p6 parser would drop down to a subparse but look like a single thing to the op prec parser.

[02:02] <TimToady> the lower level of the 3-layer parser mode.

[02:02] <TimToady> *model

[02:02] <audreyt> yup

[02:02] <audreyt> so I'll do a tryLookAhead over oneOf "<{"

[02:02] <audreyt> after fixities:

[02:02] <TimToady> that should do it

[02:03] <TimToady> maybe we limit that to known syntactic categories?  (or maybe not)

[02:03] * audreyt is amazed by the sheer amount of shift/reduce erros swept overthe backtracking carpet

[02:03] <audreyt> we currently do that, yes

[02:04] <TimToady> of course, we'll want to let grammar writers add their own categories, but we don't need to worry about that yet.

[02:05] <audreyt> actually we can also do that

[02:05] <audreyt> anything:<anything>

[02:05] <audreyt> making it a special form

[02:05] <audreyt> just like

[02:05] <audreyt> anything=>anything

[02:05] <audreyt> so each ident has too potential lookAheads

[02:05] <audreyt> one for :< and :{, one for =>

[02:05] <TimToady> good enough for now

[02:05] <audreyt> or rather whitespace=>

[02:06] <TimToady> could limit the => rule to \h* if unlimited lookahead is problematic

[02:06] <audreyt> is

[02:06] <audreyt> prefix:say

[02:07] <audreyt> legal?

[02:07] <audreyt> or does it always have to be written prefix:<say>

[02:07] <TimToady> the latter

[02:07] <audreyt> is

[02:07] <audreyt> infix:{1+2}

[02:07] <audreyt> legal?

[02:08] <TimToady> the :< :{ forms were intentionally unlikely to occur elsewise

[02:08] <audreyt> or better, infix:{rand}

[02:08] <TimToady> yes, but you get what you get

[02:08] <audreyt> at parse time, no less

[02:08] <audreyt> so another implicit BEGIN place

[02:08] <TimToady> yup

[02:08] <audreyt> there are currently 13 unsafeEvalExp

[02:08] <audreyt> in Parser.hs

[02:08] <audreyt> each denotes a parse-time evaluation

[02:08] <audreyt> how appropriate the number :)

[02:09] <TimToady> for a good enough purpose one can of course limit one's own freedom--as long as you predeclare it...

[02:12] * audreyt continues to go thru the sanity tests...

[02:12] <TimToady> would be so much simpler if there were also insanity tests...

[02:13] <Kattana> why cant there be, plenty of canditates to write them.

[02:13] <TimToady> if a question is not imminent, maybe now would be a good moment for me to commute home (~10 minutes)

[02:14] <audreyt> TimToady: sure

[02:14] <audreyt> I'll get Test.pm running meanwhile

[02:14] <audreyt> and then commit... and break all our tests ;)

[02:14] <TimToady> kewl, dude(tte).

[02:14] <TimToady> bbiab&

[02:15] * audreyt Captures the "tte" 

[02:20] *** frederico joined
[02:21] <audreyt> hm

[02:21] <audreyt> 1 if 2;

[02:21] <audreyt> er

[02:21] <audreyt> say if 1;

[02:21] <audreyt> vs

[02:22] <clkao> audreyt: grammar for data::alias ?

[02:22] <clkao> :P

[02:22] <audreyt> say if::x 1;

[02:22] <audreyt> clkao: Perl6::Binding :)

[02:22] <clkao> ya, steal from it

[02:25] <audreyt> (bbiab)

[02:33] <TimToady> degone

[02:36] <TimToady> foo::bar always "autoquote" foo as well, so probably just another lexerish dwim

[02:38] <TimToady> tokens with superpowers shouldn't be discriminated against--see X men et al.

[02:39] <TimToady> statement modifiers are also sufficiently powerful reserved words to be recognized whether a term or operator is expected.

[02:39] <TimToady> say if 1; is in the same category as say 1,2,3, if 1;

[02:47] <audreyt> hm

[02:47] <audreyt> ok.

[02:48] <audreyt> remind me again how to handle

[02:48] <audreyt> if foo {1}

[02:48] <audreyt> ?

[02:48] <audreyt> pmichaud has

[02:48] <audreyt> ([if|unless]) <expression> <block>

[02:49] *** DesreveR joined
[02:49] <audreyt> but I seem to remember that "if foo{1}" and "if foo {1}" are to be handled differently

[02:50] <TimToady> foo{1} would be in postfix position.  foo {1} has whitespace before it.

[02:50] <audreyt> but ordinarily

[02:50] <TimToady> only question really is whether to force it on expecting term as well as operator

[02:50] <audreyt> say {1};

[02:51] <audreyt> would work treating it as a term

[02:51] <audreyt> as argument to say

[02:51] <audreyt> it's only in

[02:51] <audreyt> if say {1}

[02:51] <audreyt> that it becomes argument to if

[02:51] <TimToady> just a sec...

[02:53] <audreyt> luqui iirc introduced a weird workaround in Pugs.Parser

[02:53] <audreyt> based on the emptiness of the block

[02:53] <audreyt> which is obviously wrong

[02:53] <audreyt> but I wonder what the correct way is

[02:54] <TimToady> I think the correct way is to require people to say "say() {1}" probably.

[02:54] <TimToady> it's a good spot to remember that you could have decided differently so you can give a good error message though.

[02:54] <audreyt> er you mean

[02:55] <audreyt> if say() {1}

[02:55] <audreyt> ?

[02:55] <TimToady> but I think we have too many things like sort {} that have to eat the block as part of the operator

[02:55] <audreyt> right.

[02:55] <audreyt> if map {3} {4} {5}

[02:56] <TimToady> on the other hand, we could do it the other way, and require people to write

[02:56] <TimToady> if (sort {}, 1,2,3) {1} in that case

[02:56] <TimToady> but that feels uncleaner

[02:56] <audreyt> previously we allow people to write both

[02:56] *** KingDiamond joined
[02:57] <audreyt> relying on costly parsefail backtrack to disambiguate

[02:57] <TimToady> through the wonders of backtracking...

[02:57] *** weinig is now known as weinig|out

[02:57] <audreyt> which is quite dwimmy but obviously wrong :)

[02:58] <audreyt> if sort { moose(); }, say { "this is the real loop body!" }

[02:58] <TimToady> I think eating a block accidentally is very likely to give a parsefail rather than do the wrong thing, so I think we eat the block and blow up politely when that's wrong.

[02:59] <audreyt> which mean the above line works

[02:59] <TimToady> on top of which, we're trying to train people into using .say rather than say()

[02:59] <audreyt> and prints "this is the real loop body" ?

[03:00] <audreyt> or that it doesn't work

[03:00] <audreyt> because say eats the block?

[03:00] <TimToady> I think say should expect a term, and {...} sure does look like a term...

[03:01] <audreyt> if -e { print "file exists" }

[03:01] <audreyt> so that is gone too

[03:01] <audreyt> have to write

[03:01] <audreyt> if (-e) { print "file exists" }

[03:01] <TimToady> we *could* exempt 0-arg list operators that just happen to be followed by a block, but as I say that wipes out sort and map

[03:01] <audreyt> -e is optional unary, not listop, yet suffers from the same problem

[03:01] <pmichaud> good evening

[03:02] <audreyt> pmichaud: greetings

[03:02] <audreyt> trying to get "if" parsed :)

[03:02] <audreyt> pmichaud: btw, would you mind if I port all the 01-sanity to languages/perl6/ ?

[03:03] <TimToady> I wonder if we need to set up a separate P6 validation location that is pugs/parrot-independent.

[03:03] <audreyt> I wouldn't mind that, except that svk smerge is quite powerful nowadays

[03:04] <audreyt> so cross-repo bidi incremental merging isn't really a problem

[03:04] <TimToady> I just wish shebang lines could pay attention to ENV vars...

[03:04] <audreyt> we can always do #!perl6

[03:05] <audreyt> anyway, back to

[03:05] <audreyt> if -e { say "hi" }

[03:06] <audreyt> another thought is to restrict the conditional part

[03:06] <audreyt> such that the argument list stops eating blocks, and you need parens to get back block-eating behaviour

[03:06] <pmichaud> audreyt: I'd be very pleased if you would port any tests you wish to languages/perl6 :-)

[03:07] <audreyt> cool... currently only 01-sanity though

[03:07] <audreyt> once pge-perl6 can run Test.pm

[03:07] <audreyt> we can port the rest of tests over

[03:07] <TimToady> so basically the <space>{ is special at the top level, and () blocks that.

[03:07] <TimToady> I think I like that because it will usually be what people expect

[03:08] <audreyt> er, not space

[03:08] <audreyt> terms

[03:08] <TimToady> and the foo {} listops tend to be listy anyway, so can use () around visually

[03:08] <audreyt> er, not space

[03:08] <audreyt> if foo{3}

[03:08] <audreyt> this is not really postfix

[03:08] <audreyt> $foo{3} would be

[03:08] <audreyt> but foo{3} would treat {3} as a term

[03:08] <audreyt> and hence also blocked, and 3 goes to if

[03:09] <audreyt> or was I mistaken?

[03:09] <TimToady> that can't ever be a term

[03:09] *** fglock joined
[03:09] <TimToady> has to be postfix .{}

[03:09] <pmichaud> pge has foo{3} as foo.{3}

[03:09] <TimToady> \yes

[03:09] <audreyt> so moose[3] is calling [3] on the result of the moose call?

[03:09] <TimToady> always

[03:10] <pmichaud> that's the way I read it :-)

[03:10] <audreyt> ok. in that case, indeed, term-position {} can be blocked in condition part

[03:11] <TimToady> yes, and that fixes if -e { say "there" }

[03:11] <TimToady> and if there are additional terms, we'll have plenty of opportunity to detect useless use of...

[03:11] <audreyt> are you in the mood of updating L<S04/Conditional statements> ? :)

[03:12] <TimToady> if not just notice that the if didn't end right...

[03:12] <TimToady> actually, I'm being called to supper right now... :)

[03:12] <pmichaud> what change is being proposed?  I only briefly skimmed the lastlog

[03:12] <audreyt> I'll ghost-write :)

[03:12] <TimToady> but maybe later.

[03:12] <audreyt> oh, I'll not ghost-write then :D

[03:12] <TimToady> okay

[03:12] * audreyt goes back implementing that instead

[03:12] <audreyt> pmichaud: the change that

[03:12] <audreyt> if -e { 3 }

[03:12] <audreyt> means

[03:13] <audreyt> if (-e) { 3 }

[03:13] <audreyt> rather than a parsefail.

[03:13] <fglock> hi!

[03:13] <pmichaud> to be detected by backtracking, or...?

[03:13] <audreyt> or, more interestingly

[03:13] <audreyt> if -e { 3 } { 4 }

[03:13] <audreyt> means

[03:13] <TimToady> but if (sort {}, 1,2,3) {block} requires parens

[03:13] <audreyt> if (-e) { 3 }; { 4 }

[03:13] <audreyt> instead of

[03:14] <audreyt> if (-e { 3 }) { 4 }

[03:14] <audreyt> fglock: hi!

[03:14] <audreyt> pmichaud: no, no backtracking needed

[03:14] <TimToady> that's the point, we're trying to get rid of all the bting

[03:14] <audreyt> the idea is that we suppress the bare-closure-term rule inside a "if"'s conditional.

[03:14] <TimToady> biab&

[03:14] <pmichaud> ouch, okay

[03:15] <audreyt> pmichaud: TimToady had this wonderful idea that Pugs's Parsec parser should take out all its "try"

[03:15] <audreyt> essentially making it nonbacktracking

[03:15] <audreyt> I did that, and it revealed dozens of shift/reduce problems

[03:15] <audreyt> we were working out each one

[03:15] <audreyt> one by one... not sure how many to come :)

[03:16] <pmichaud> unfortunately, pge's op-precedence parser currently doesn't make it easy to suppress bare-closure term

[03:16] <fglock> audreyt: so it will be pure bottom-up?

[03:16] <audreyt> fglock: we found out that it can't be ;)

[03:16] <audreyt> moose=>1

[03:16] <audreyt> moose:<elk>

[03:16] <audreyt> moose:{antler()}

[03:16] <ingy> elk

[03:16] <audreyt> are three backtracks over the "moose" identifier

[03:16] <audreyt> so there still must be backtracking

[03:17] <audreyt> it's just we are doing away with the others if possible

[03:17] <audreyt> (and convert implicit backtracks into explicit lookAheads if possible.)

[03:17] <fglock> these one can be fixed by the tokenizer/lexer, no?

[03:17] <TimToady> the bottom-up parse has to parameterizable for terminators.  <expectop>{ is just the terminator

[03:18] <audreyt> <expectterm> surely?

[03:18] <TimToady> I mean <space>{

[03:18] <pmichaud> oh, I can do it that way, yes

[03:18] <pmichaud> okay, no problem

[03:19] <pmichaud> you're right that bottom-up needs to be parameterizable for terminators -- I just hadn't added that particular feature yet :-)

[03:20] <pmichaud> I'm glad I combined it into a multi-state parser now, though, since  <space>{ will occur when expecting a term (where we normally terminate when expecting an op)

[03:22] <audreyt> nice

[03:23] <pmichaud> sigh, there just aren't enough workable hours in the day :-(

[03:23] <audreyt> but interestingly

[03:23] <audreyt> if BEGIN { 3 } { 4 }

[03:24] <audreyt> means

[03:24] <audreyt> if (BEGIN()) { 3 } { 4 }

[03:24] <audreyt> as a macro expecting a term literal is no different from a sub expecting one

[03:24] <pmichaud> I think I'd live with that particular one for now :-)

[03:25] <pmichaud> well, unfortunately I have to go; I'll check /lastlog a little later or tomorrow

[03:25] <audreyt> cool

[03:25] <audreyt> have fun!

[03:25] <pmichaud> you too

[03:25] <audreyt> always =)

[03:32] <svnbot6> r9947 | fglock++ | Pugs-Grammar-Perl6-Lib - placeholder for prototypes and prelude

[03:47] <svnbot6> r9948 | fglock++ | PG-P6: yada-yada-yada

[03:49] <audreyt> pmichaud: I commited all the sanity tests into your tree

[03:49] <audreyt> fglock: how close is PG-P6 from running 01-sanity? :)

[03:50] <fglock> it is just a parser - there is just a small emitter written by pmurias

[03:51] <fglock> I'll take a look...

[03:51] <audreyt> 01-sanity doesn't require much emission though

[03:51] <audreyt> it's designed for the -CPIR

[03:53] <fglock> it doesn't look too difficult - PG-P6 already has most tables in place - it just needs to be filled in - maybe a couple of days :)

[03:54] <audreyt> woot :)

[03:56] <fglock> the grammar is quite simple actually - I'm not sure if it needs much more - it needs macros, and be able to execute BEGIN blocks (but you said they will no longer exist)

[03:58] <fglock> currently a program is a list ( statement-control | expression )*

[03:58] *** FurnaceBoy_ joined
[04:01] *** qu1j0t3 joined
[04:01] <fglock> I'm not sure what is it missing, but this seems to fit a lot of the grammar

[04:02] <audreyt> currently pugs has

[04:02] <audreyt> statement-control, macro-declarators (those are the BEGIN parts I referred to)

[04:03] <audreyt> POD blocks

[04:03] <audreyt> and expressions

[04:03] <audreyt> so I think the only thing missing is POD

[04:04] <audreyt> i.e. column-1-assersions

[04:04] <audreyt> =foo

[04:04] <audreyt> #line 1

[04:04] <audreyt> etc

[04:04] <audreyt> also you need to parse, or taleas fake-parse, "use v6" :)

[04:04] <fglock> isn't POD whitespace?

[04:04] <audreyt> (and use v6-foo)

[04:04] *** _mjk_ joined
[04:05] *** Khisanth joined
[04:05] <audreyt> no, pod is only whitespace at statement position

[04:05] <audreyt> also, it is actually a pseudostatement

[04:05] <audreyt> that populates %=POD etc

[04:05] <audreyt> at parse time

[04:06] <fglock> cool - I'll implement that then :)

[04:06] <audreyt> :)

[04:07] <fglock> actually, I think it is better to extract it and leave the parsing to a mini language - like Rule does

[04:10] <audreyt> I agree.

[04:10] <fglock> so we have a thin main parser and some mini languages:

[04:10] <fglock> rules, expressions, pod, interpolated strings

[04:10] <audreyt> signatures, arguments

[04:13] <fglock> I'm calling minilanguages like subrules: <Pugs::Grammar::Perl6::Str.parse>, <P::G::P6::Expression.parse> and so on

[04:13] <_mjk_> ƒ˙∫√Ã∆∑Ô,Œ“÷™µ¿ƒ˙ «pugsµƒø™∑¢’ﬂ,Œ“”√perl◊ˆŒ™msvcµƒ«∂»Î”Ô—‘ø™∑¢»Ìº˛,µ´ «Œ“œÎœÚƒ˙«ÎΩÃ:pythonµƒΩ¯’π∫‹øÏ,µ´ «perl6Œ™∫Œ≥Ÿ≥Ÿ√ª”–◊Ó–¬µƒ«– µΩ¯’π,–ª–ª

[04:15] <audreyt> _mjk_: ƒ˙∫√, ø¥µ√µΩŒ“¥Ú◊÷Ü·?

[04:15] <_mjk_> ø¥µ√µΩ

[04:16] <audreyt> _mjk_: Perl 5.9 µƒﬂM’π“≤∫‹øÏ; »Áπ˚ƒ˙ «“™∫Õ Python 2.x œ‡±»µƒ‘í

[04:16] <audreyt> Â•ß Perl6 ÊéÄÔúÄ Python3000 ËÖîÁ≠≥Ê°ØÁåÅËæ¶Âó£Ë≥∏ :)

[04:17] <_mjk_> ◊Ó∫Û“ª–– «¬“¬Î

[04:17] <audreyt> Â•ß Perl6 ÊéÄÔúÄ Python3000 ËÖîËºõÊ°ØÁåÅËæ¶Âó£Ë≥∏ :)

[04:17] <_mjk_> ªπ «¬“¬Î

[04:18] <_mjk_> Œ“”¢Œƒ≤ª∫√

[04:18] <audreyt> ÈÅúÂ≤ÜËß¥Èé¢?

[04:20] <audreyt> _mjk_: »Áπ˚ƒ˙ «“™∫Õ Python 2.x œ‡±»µƒª∞, Perl 5.9 µƒΩ¯’π“≤∫‹øÏ; ∂¯ Perl6 ±»∆ Python3000 µƒΩ¯’π“™øÏ∂‡¡À :)

[04:20] <_mjk_> ±»À∂ºÀµperlµƒø…∂¡–‘≤ª∫√(∂‘±»python), µ´ «Œ“”…”⁄Ω”¥•perlΩœ‘Á,À˘“‘≤ªœÎ‘Ÿ—ßœ∞python,∂¯«“perlµƒø‚“≤º´Œ™∑·∏ª,∂‘÷–Œƒµƒ÷ß≥÷“≤±»python∫√

[04:20] <svnbot6> r9949 | fglock++ | PG-P6 - P::G::Pod.pm stub

[04:21] <_mjk_> ø…“‘ø¥µΩ¡À,–ª–ª

[04:21] <_mjk_> ’‚√¥Àµperl6µƒπ¶ƒ‹“™±»python«ø¥Ûµƒ∂‡¡À

[04:21] <Khisanth> that is a lot of gibberish ...

[04:22] <audreyt>  «, Perl 6 ∂‘”⁄ π”√÷–Œƒ ˝æ›, , “‘º∞ π”√ CPAN ƒ£øÈ, ∂º «÷ß≥÷µƒ

[04:22] <fglock> what is the synopsis for Pod?

[04:22] <audreyt> _mjk_: Œ“√«“∆µΩ #perlchina Ã∏∞…?

[04:23] <_mjk_> ¥Û‘ºªπ”–∂‡≥§ ±º‰perl6ø…“‘ Õ≥ˆ∞°?

[04:23] <audreyt> (as this is primarily not a GB2312 channel)

[04:23] <_mjk_> ∫√µƒ,–ª–ª

[04:24] <audreyt> fglock: supposedly, docs/Perl6/Spec/Documentation.pod

[04:25] <audreyt> fglock: but realistically, "man perlpodspec"

[04:26] <fglock> you said "whitespace at statement position" - is it a term at term position?

[04:26] <TimToady> except, assume that =cut is probably going away.

[04:31] <TimToady> just be careful with the minilanguages not to make the same mistake as Perl 5.  Calling out to subrules is fine.  Finding the end and reparsing is not so fine.

[04:32] <fglock> I mean mainly calling out a 'main rule' of another grammar

[04:32] <TimToady> Also, I'm viewing the line boundaries as something more like handover points between coroutines, so it's not necessary that a pod parser act completely inside each pod chunk, or Perl chunk inside each pod chunk.

[04:34] <TimToady> but the line transition conventions are agreed to by the two parsers so that you can, for instance, ignore the pod, or the pod can ignore the program.

[04:35] <TimToady> calling out to a main rule is fine for now.

[04:35] *** kanru joined
[04:35] <fglock> so the rules are: =begin///=end or =anything/paragraph/blank-line ?

[04:36] <TimToady> basically, but I don't know if they've updated Doc.pod to reflect what we talked about in Tokyo.

[04:37] <TimToady> if there's still =pod and =cut in there, assume that's all simplified to =begin/=end with =use for a general "use" mechanism just as with Perl.

[04:38] <TimToady> anyway, Ingy and Damian are still working it out, last I knew.

[04:38] <audreyt> and we are still puzzling how python is to parse =use :)

[04:39] <fglock> ok - I'm just implementing placeholder syntax right now - just a bit of each category to see how things fit together

[04:40] <TimToady> and I care about python because...  :)

[04:40] <audreyt> ...because POD is currently under nonperl contexts? :)

[04:40] <TimToady> placeholder is fine for now, and will probably continue to be fine as long as the line transition rules remain simple.

[04:41] <TimToady> how does python parse =foo in general?

[04:41] <audreyt> I mean, parsing POD as a document

[04:41] <audreyt> without the capability of running perl6

[04:41] *** justatheory joined
[04:41] <audreyt> but I think it's solidly abandoned :)

[04:41] <audreyt> i.e. "only perl parses pod"

[04:41] <audreyt> or some such.

[04:42] <audreyt> (it also means backporting the perl6 pod documents back to perl5 rendered is going to be fun -- we need to sync everything that can be "use"d)

[04:42] <TimToady> python can just put it all into """ =use """ blocks I guess...

[04:43] <audreyt> XML avoids this problem as its transformers and schema (the equivalent of "use" things) are also XML

[04:43] <TimToady> =use is just an interface--I don't think it has to know much about implementation language

[04:43] <audreyt> though there is also DTD

[04:43] <audreyt> but DTD is quite a bit simpler than perl

[04:44] <TimToady> maybe it's all just parrot byte code.  :)

[04:44] <audreyt> TimToady: true... the underlying implementation just has to implement the 3-part versioning etc :)

[04:44] <audreyt> (and somehow guarantee sane behaviour on the unbounded pragmas one can =use)

[04:44] <audreyt> (but I'm actually comfortable with this :))

[04:45] <audreyt> but I need to run back to my parents' for my birthday party...

[04:46] <audreyt> be back in a few hours

[04:46] <TimToady> are you going to be able to do r10000 on your birthday?

[04:46] <audreyt> very likely

[04:46] <audreyt> as it's still 3days away

[04:46] <TimToady> let me know if I have to patch faster or slower. :)

[04:47] <TimToady> have a good party.

[04:47] <audreyt> faster :)

[04:47] <audreyt> thanks :)

[04:49] <ingy> audreyt: I can't seem to login to openfoundry

[04:50] <ingy> or commit to pugs

[04:50] <ingy> oh hi TimToady

[04:51] <audreyt> ingy: you lost your passwd?

[04:51] <audreyt> reset it from the web form?

[04:51] <ingy> well I guess so yes

[04:51] <ingy> I can't :p

[04:51] <ingy> http://rt.openfoundry.org/Foundry/Home/Guest/Reminder.html

[04:51] <ingy> broken

[04:52] <ingy> TimToady: I was just going over S26

[04:52] <ingy> are you around for a bit more?

[04:53] <ingy> I have some questions

[04:53] <svnbot6> r9950 | fglock++ | PG-P6 - added "Pod" and tests

[04:54] <TimToady> sure

[04:55] <ingy> Well basically my use (npi) case is, as audreyt says, Python needs to be able to parse Pod docs

[04:55] <ingy> but...

[04:56] <ingy> as long as `=use foo` implies a set of well understood semantics, I think it's ok

[04:57] <TimToady> Python's an interesting case for pod, since pod is sort of anti-whitespace sensitive, or differently sensitive.

[04:57] <ingy> I like `=use`, I just don't take it to mean it loads a module called 'foo' necessarily

[04:58] <ingy> I'm not talking about using Pod in Python

[04:58] <ingy> at all

[04:58] <TimToady> no, it loads something poddish called "foo".  Unlikely to be foo.pm

[04:59] <ingy> or it doesn't load anything...

[04:59] <TimToady> okay, parse pod using python, gotcha

[04:59] <ingy> right

[04:59] <ingy> There are a lot of good tools written in non-perl

[04:59] <ingy> that us perl folk like to use

[05:00] <ingy> A documentation authoring tool perhaps

[05:00] <ingy> anyway, next thingy

[05:00] <TimToady> all I really care about is that =use be there as an interface for specifying that you want the language to change somehow, instead of being implicit in whatever postprocessor you happen to run.

[05:00] <ingy> cool!

[05:01] <TimToady> =use nroff

[05:01] <TimToady> is certainly possible even.

[05:01] <ingy> my next BIG issue is that Perldoc syntax is really only useful for POD :p

[05:01] <ingy> I want to do this:

[05:02] <ingy> =kwid some:options per:haps

[05:02] <ingy> #| = Heading

[05:02] <ingy> sub foo { ... }

[05:03] <ingy> ie I want different containment

[05:03] <TimToady> you can do anything you like as long as you say =use whatingywantstodo first, and can figure out how to hook the line transition interface to do it.

[05:04] *** elmex joined
[05:04] <ingy> yep, I figured you'd say that

[05:04] <ingy> so good...

[05:05] <TimToady> basically =use tells <ws> what to do on a \n boundary.

[05:05] <ingy> Damian seems to have not included *lists* in the model

[05:06] <ingy> He only has items

[05:06] <ingy> I don't like this.

[05:06] <ingy> I'll write something up...

[05:07] <ingy> +1 on =use thought

[05:07] <TimToady> gee, I was hoping for a +1.2 at least...

[05:07] <ingy> sorry, I'm mortal

[05:07] <ingy> 100% is my best

[05:07] <ingy> at least today

[05:08] <TimToady> but you're also so improbable

[05:08] * ingy saves immortality for special occasions

[05:08] <ingy> as are you TimToady

[05:09] <gaal> morning

[05:09] <TimToady> nite

[05:09] <ingy> I think of =use as along the same lines as =encoding

[05:09] <ingy> a mode switching declarator

[05:10] <ingy> or somesuch

[05:10] <TimToady> yeah, we just need to not fall into the source-filtering trap

[05:10] * ingy chants "somesuch" and waves his hands about

[05:10] <ingy> TimToady: explain...

[05:11] <TimToady> different =use invocations might set different hooks, scoped differently

[05:11] <ingy> hmm

[05:11] <TimToady> source filters are too crude of an ax.

[05:11] <TimToady> so =use probably needs to be able to work at the "macro" level too.

[05:12] <TimToady> define individual =foo thingies, for instance.

[05:12] <TimToady> or whatever.

[05:12] <ingy> I would think of =use as a stream level thingy like =encoding

[05:12] * TimToady chants "whatever" and waves his hands about

[05:13] <ingy> if you give =use Perl lexical scope then we've really just blown the Python case out of the water

[05:13] <TimToady> the source-filter lesson is that stream-level thingies often don't stack very well.

[05:13] <ingy> noted.

[05:13] <TimToady> no, not Perl lexical scope.  =begin/=end lexical scope.

[05:14] <TimToady> or =foo name scope

[05:14] <TimToady> of Z<> thingie scope

[05:14] <TimToady> *or

[05:14] <TimToady> or whatever the proper scope of the "macro" is.

[05:15] <TimToady> then you only have to worry about the interactions if people actually use them overlappingly.

[05:15] <ingy> =begin is a /pod/ directive, not a Perldoc directive, methinks

[05:15] <TimToady> it's just another form of encapsulatoin

[05:15] <TimToady> =use can certainly switch to something too stupid to have its own scopes.

[05:16] <TimToady> P6 is all about providing proper scopes of every kind so that encapsulation is always natural, but not everyone has to program in P6.

[05:16] <ingy> well I would like to have at least one line of orthoganality here

[05:16] <TimToady> nor in the P6 flavor of pod

[05:17] <TimToady> takes two lines to be orthogonal. :)

[05:17] <ingy> I would say Perldoc is Orthogal to P6, (pleeeease)

[05:17] <TimToady> it is.

[05:18] <ingy> phew

[05:18] <ingy> he says knowing he is about to be decapitated

[05:18] * gaal threads backlogging and reading the current discussion

[05:18] <TimToady> the only thing they happen to have in common is that they both require something like use to bend the rules.

[05:18] <TimToady> and that they have to agree on who gets control at the line boundaries.

[05:19] <gaal> a piece of pod should have affinity to the bunch of code it is commenting on, right? so for example you could write docs for one multi and have it pertain to all locally visible variants

[05:19] *** Aankhen`` joined
[05:19] <gaal> that sounds like it is somewhat coupled to the language

[05:19] <gaal> s/pod/Perldoc/

[05:19] <ingy> TimToady: I'm "impressed" that you like line boundaries for scoping

[05:20] <ingy> seems to concrete for you ;)

[05:20] <TimToady> I expect most coupling to related documentation will be either by convention (located nearby) or by name.

[05:20] <ingy> gaal: I think that is perhaps at a different level than what we are discussing, but sure

[05:21] <gaal> okay. /me pops back to backlogging -- you've been busy while I was sleeping

[05:21] <TimToady> but mostly that goes through the PDOM filter.

[05:21] <TimToady> we're mostly discussion syntactic interactions right now.

[05:22] <TimToady> s/ion/ing/

[05:22] <TimToady> or lack thereof, hopefully.

[05:23] <ingy> so... I would think that =foo could be defined such that a subsequent =bar is:

[05:23] <TimToady> yes, the whole pod notion is built on the idea that line boundaries are a very natural place to encapsulate/excapsulate different languages interleaved with each other.

[05:23] <ingy> 1) considered a foo syntax

[05:23] <ingy> 2) delegated to bar and its rules

[05:23] <ingy> 3) Something stoopid and unthought of

[05:24] <TimToady> sure.  =use is just one kind of special =foo, after all.

[05:24] <ingy> gah sorry

[05:24] <ingy> `=use foo` and `=use bar` I meant

[05:25] <TimToady> it all depends on what kind of engine we want to put under the interface.

[05:26] <ingy> engines :p

[05:26] <TimToady> I tend to prefer infinitely extensible engines, and other people prefer to nail down what is possible.

[05:26] <TimToady> I prefer to give people the option of nailing down what is possible as one of the infinitely possible things. :)

[05:27] <ingy> I prefer hacking...

[05:27] <ingy> ok, I am going to rip S26 to shreds now

[05:27] <ingy> should have enough to go on

[05:27] * ingy checks notes...

[05:27] <TimToady> hope this hurts.  er, helps...

[05:27] <audreyt> <TimToady> "The reasonable man adapts himself to the world; the unreasonable one persists in trying to adapt the world to himself. Therefore all progress depends on the unreasonable man."

[05:27] <audreyt> <TimToady> The only problem with this quote is that it's false. A lot of progress comes from unreasonable women.

[05:28] <TimToady> audreyt += 42

[05:28] <qu1j0t3> hehe

[05:29] <ingy> audreyt += 3.1415926 (*2)

[05:29] <TimToady> on the other hand, I'm sure a lot of people would agree that a woman makes a rather unreasonable man.

[05:30] <gaal> audreyt: "The only problem with this sentence is that it's false."

[05:30] <ingy> TimToady: =cut and =doc are yesterday's news

[05:30] <audreyt> gaal: gobby-p?

[05:30] <ingy> wake up and smell the fish

[05:30] <ingy> mmm gobby

[05:31] <ingy> I have linux laptop now

[05:31] <ingy> I was going to grab someone like gaal to hack S26

[05:31] <gaal> audreyt: sike.forum2.org

[05:31] <gaal> 26 is...? docs?

[05:32] <gaal> too bad the weekend ends a day sooner here

[05:32] <gaal> oh is gobby a sort of fish? I didn't know that

[05:32] <audreyt> TimToady: is there a syntactic way of denoting the slurpy block in an arglist?

[05:33] <gaal> or, audreyt, if you already have something started then start a session of your own and I'll connect

[05:33] <audreyt> \($inv : $pos, name=> $name : {block}) perhaps?

[05:33] <audreyt> gaal: no

[05:33] <TimToady> Is :{} still free?

[05:33] <audreyt> aye

[05:33] <gaal> the kiss quote

[05:34] <gaal> favorite smiley-pair:

[05:34] <audreyt> in .map:{moose} it's currently hard-coded^Wspecced to go into the .map

[05:34] <gaal> :-{}    # user wears lipstick

[05:34] <gaal> :{})  # user got kissed on the nose by lipstick-wearing user

[05:34] <TimToady> currently that's specced as .map: {moose} where the : turns .map into a list operator like $ does in Haskell.

[05:35] <gaal> how does one extract @invs from a Capture?

[05:36] <audreyt> right. and {moose} comes into play by the last pos of slurpy *& in .map's sig

[05:36] <audreyt> gaal: there can be only one @inv

[05:36] <audreyt> I mean $inv

[05:36] <gaal> huh? mmd

[05:36] <TimToady> positionals

[05:37] <audreyt> gaal: mmd governs sigs

[05:37] <audreyt> not args

[05:37] <audreyt> not arsee the App form

[05:37] <gaal> (Maybe Var)

[05:37] <gaal> Val

[05:37] <audreyt> yeah

[05:37] <audreyt> ok, can you load yesterday's doc at the gobby session?

[05:37] <audreyt> (other people are also welcome to join the gobby session)

[05:37] <gaal> it's loaded

[05:37] <gaal> that FAQ?

[05:37] <audreyt> k

[05:37] <audreyt> yup

[05:38] <audreyt> let's dive in :)

[05:38] <TimToady> anyway, maybe you can just decorate any {} to force it not to be the statement level block.

[05:38] <gaal> all: join gobby sike.forum2.org

[05:38] <TimToady> I'm gonna go to bed now, actually...

[05:38] <qu1j0t3> nite

[05:38] <gaal> good night

[05:38] <TimToady> zzz &

[05:47] <ingy> TimToady: come back good buddy

[05:47] <ingy> grr, /me just realized that he's been duped

[05:47] * ingy attempts to dedup himself

[05:48] <ingy> TimToady: `use kwid` and `use Table` are two totally different animals

[05:49] <gaal> ingy | sort | uniq

[05:49] <ingy> :p

[05:49] <ingy> wait!

[05:49] <ingy> /usr/bin/ingy

[05:49] <ingy> hmmmm....

[05:49] * qu1j0t3 waits

[05:49] <qu1j0t3> Segmentation fault.

[05:50] <ingy> TimToady: `use kwid` is a Perldoc directive

[05:50] <gaal> btw check out the cool new Pipe.pm module by szabgab

[05:50] <ingy> TimToady: `use Table` is a Pod directive

[05:51] <ingy> I'm going to push for the former to be `=doc kwid`

[05:51] <ingy> TimToady: I'm going to push for the former to be `=doc kwid`

[05:51] <ingy> sorry...

[05:52] <ingy> TimToady: oops, s/use/=use/g

[05:56] *** FurnaceBoy joined
[05:56] <svnbot6> r9951 | fglock++ | PG-P6 - arbitrarily nested statements/expressions

[05:58] *** KingDiamond joined
[06:02] <svnbot6> r9952 | fglock++ | PG-P6 - TODO update

[06:02] *** fglock left
[06:31] <audreyt> ?eval (1,2,3)[][][][][][][]

[06:31] <evalbot_9946> (1, 2, 3)

[06:40] *** drrho joined
[07:09] *** dduncan left
[07:26] *** _bernhard joined
[07:29] <audreyt> help wanted

[07:30] <audreyt> to podify docs/Perl6/FAQ/Capture.pod

[07:30] <svnbot6> r9953 | audreyt++ | * 0th draft of Perl6::FAQ::Capture - help on PODification welcome!

[07:46] *** ghenry joined
[07:55] *** xinming joined
[07:59] <_bernhard> exit

[08:27] *** pmurias joined
[08:32] * ingy needs to make a full system backup of his ibook to an external drive

[08:32] <ingy> any advice?

[08:34] <audreyt> dd

[08:35] *** pmurias joined
[08:35] *** larsen joined
[08:36] <ingy> audreyt: seriously, that will work for mac?

[08:42] *** larsen joined
[08:46] *** nothingmuch joined
[08:48] *** kattana_ joined
[08:48] <audreyt> ingy: I think so, yes

[08:49] <integral> Disk Utility can also copy disks, but that appears to be exactly the same as a dd

[08:49] <audreyt> right, but you get a better UI

[08:49] <integral> FSVO "better"

[08:49] <audreyt> even for CLI, dd's UI is... weird

[08:50] <integral> it's not very good because after copying the dest has the same label, so you can't actually tell which text box references which disk

[08:50] <audreyt> even fancier gratis UI:

[08:50] <audreyt> http://www.shirt-pocket.com/SuperDuper/SuperDuperDescription.html

[08:53] *** nnunley_ is now known as nnunley

[09:25] <svnbot6> r9954 | pmurias++ | basic expression emitting

[09:25] <svnbot6> r9954 | pmurias++ | still expression nodes need to be hand inserted into the ast

[09:39] *** chris2 joined
[09:56] *** bsb joined
[10:02] *** b00t joined
[10:10] <ruz> morning, I look at http://www.pugscode.org/images/simple-compilation.png and wonder how compiler differs from code generators?

[10:11] <ruz> and what is PIR?

[10:13] <ingy> thanks audreyt and integral

[10:14] <ingy> ruz PIR == PUGS INFERENCE RUMINATOR

[10:14] <ingy> or something like that ;)

[10:14] *** david_ joined
[10:15] <ruz> :)

[10:15] <ingy> PRETTY INTERESTING RUSE?

[10:15] <ingy> PARROT INTERMEDIATE RUNTIME

[10:16] <ruz> understood, it's test for newbie :)

[10:16] <ruz> a) b) or c) what would you choose? :)

[10:16] <ingy> actually I don't even know any more

[10:17] <ingy> might not be any of those

[10:17] <ruz> d) other ________ (fill in)

[10:19] <ingy> I'm reading cryptomonicon

[10:19] <ingy> there's this part where someone guesses the INRI next to a crucifix means Initiate Nail Removal Immediately

[10:20] <LeTo> ruz: (in parrot tree): $ perldoc docs/glossary.pod

[10:21] <ingy> LeTo: url?

[10:22] <LeTo> http://svn.perl.org/parrot/trunk/docs/glossary.pod

[10:23] <ingy> EOFFBYONE

[10:25] <ruz> LeTo: thanks

[10:34] <gaal> rehi

[10:41] <ruz> if PIR is a medium-level assembly language then what is low-level? PBC?

[10:43] <LeTo> PASM

[10:44] <LeTo> PBC is the binary parrot 'byte' code

[10:44] <ruz> oh

[10:45] * ruz 's reading further

[10:58] <ruz> "Vtable: A table of operations attached to some data types, such as PMCs and strings" is confusing a little, isn't string a PMC? or is this sentence about some specific strings?

[11:00] <LeTo> the STRING* data type isn't a PMC

[11:04] *** larsen joined
[11:09] *** BennyAgra joined
[11:12] <BennyAgra> Camel $700 LLAMA $600. Special! order soon! http://bennyagra.in/ See my TV ad! http://bennyagra.in/commercial.html

[11:23] *** autark joined
[11:26] *** jserv-- joined
[11:27] <gaal> audreyt: $x = \@y; @$x is an error or just wrong (because $x contains no positionals)?

[11:27] <gaal> if it isn't an error, is this just an empty list?

[11:28] <gaal> does this mean that in some cases, @$cap, %$cap, and &$cap are errors?

[11:37] <svnbot6> r9955 | gaal++ |  r9995@sike:  roo | 2006-04-15 14:34:32 +0300

[11:37] <svnbot6> r9955 | gaal++ |  * Capture.pod - minor edits and a new question about ref-to-ref

[11:50] <gaal> doesn't INRI stand for I Need Ritalin Immediately?

[11:54] <gaal> incessantly

[12:04] *** BennyAgra is now known as Wassercrats

[12:12] *** Wassercrats left
[12:19] <audreyt> gaal: it is empty list

[12:20] <audreyt> gaal: $$cap may just be undef

[12:20] <audreyt> they are prolly never really errors

[12:20] <audreyt> (bbiab)

[12:24] *** frederico joined
[12:56] <audreyt> gaal: ping

[12:59] *** SamB joined
[13:04] <svnbot6> r9956 | fglock++ | PG-P6 - Pugs::Grammar::Perl6.pm !

[13:04] <svnbot6> r9957 | audreyt++ | * Capture.pod: de-handwave the \\\ref question

[13:17] <audreyt> TimToady: I'll go ahead and change Arguments to Capture.

[13:18] *** colares joined
[13:25] <svnbot6> r9958 | audreyt++ | * Perl6::FAQ::Capture - PODification.

[13:28] <pmurias> i get an "Out of memory!" while working on the emitter for PG::P6, is there a way to make perl print more info?

[13:29] <audreyt> -DPERL_EMERGENCY_SBRK?

[13:29] <audreyt> (in perlvar $^M)

[13:29] <audreyt> or gdb

[13:31] <pmurias> does perl refuse to use swap in some circumstances? i got 500M it in reserve and i didn't hear it working

[13:32] <pmurias> everything happens in 0.4s by the way

[13:35] <audreyt> mm not sure. "perldiag" under "Out of memory" has a few suggestions.

[13:36] *** turrepurre joined
[13:46] *** uzair joined
[13:50] <bsb> "Capture" is much better

[13:51] <audreyt> TimToady++ # good idea

[14:02] *** bsb left
[14:08] *** uzair left
[14:09] <pmurias> turned on -w and it found the source of my problems: pseudohashes

[14:10] <audreyt> oh no

[14:10] <audreyt> the dreaded jenga block

[14:10] <audreyt> gaal: see my answer on MMD

[14:14] <avar> does -w equal use warnings unline p5 or is it like $^W ?

[14:16] *** iblechbot joined
[14:17] <pmurias> -w equals use warnings in p5, in p6 propably too

[14:18] <pmurias> although warnings are probaly on by default in p6

[14:18] *** weinig|out is now known as weinig

[14:27] *** nothingmuch joined
[14:27] <avar> pmichaud: no, -w equals BEGIN{$^W = 1} at the start of the program, which does not equal use warnings

[14:27] <avar> (in Perl 5)

[14:27] <avar> I was wondering if that was the case in p6

[14:31] <audreyt> s/pmichaud/pmurias/ :)

[14:31] <nothingmuch> does anybody know where the moose svn?

[14:31] *** KingDiamond joined
[14:32] <pmurias> hi nothingmuch

[14:32] <nothingmuch> hola

[14:32] <avar> audreyt: grr

[14:33] <pmurias> i could, i would take part in SoC and choose pmichaud as my mentor, imagine the confusion :)

[14:34] <avar> Always two there are..

[14:36] <pmurias> nothingmuch: the moose svn where they wish

[14:41] <pmurias> s/i could/if i could/

[14:44] <pmurias> nothingmuch: what is your timezone

[14:44] <pmurias> ?

[14:47] *** KingDiamond joined
[14:50] <nothingmuch> pmurias: IDT right now

[14:50] <nothingmuch> Israel

[15:01] <nothingmuch> TimToady++

[15:01] <nothingmuch> audreyt++

[15:01] <nothingmuch> the capture faq is lovely

[15:02] <audreyt> woot

[15:02] <audreyt> gaal++ # really

[15:02] <nothingmuch> gaal++

[15:02] <audreyt> I hope it makes perfect sense to you

[15:02] <nothingmuch> it does

[15:03] *** nnunley joined
[15:04] * nothingmuch wonders how a system as ugly as finance could have grown organically

[15:05] <nnunley> Death by degrees.

[15:05] <audreyt> fractal ugliness can't be designed

[15:08] <svnbot6> r9959 | audreyt++ | * Capture.pod - more typo fixes

[15:08] <audreyt> can someone reformat docs/quickref/fears into docs/Perl6/FAQ/Fears.pod ?

[15:08] <audreyt> or Fear.pod

[15:09] <audreyt> I think that's one of the most important FAQs so far

[15:33] *** _bernhard joined
[15:35] <svnbot6> r9960 | audreyt++ | * more clarficiation of binding a non-Scalar object into $var,

[15:35] <svnbot6> r9960 | audreyt++ |   as requested by an anonymous commenter on the journal.

[15:36] <gaal> what Snn is Fears.pod? :-)

[15:36] * gaal is back

[15:37] <audreyt> gaal: the entire idea of Perl6::Doc tree is to do without nn in S :)

[15:37] <audreyt> also, ::FAQ doesn't follow the S numbering anyway.

[15:38] <gaal> audreyt: how do I desc the last cahnge to a file with svk?

[15:39] <gaal> after I'd pulled in the change

[15:39] <gaal> whoa, Capture.pod is on the blog!

[15:39] <audreyt> svk DESC head

[15:39] <audreyt> er

[15:40] <audreyt> svk desc HEAD

[15:40] <gaal> and svk desc HEAD file also?

[15:40] <audreyt> prolly not

[15:40] <audreyt> patches... welcome

[15:41] <gaal> heh

[15:41] <pmurias> nothingmuch: regarding the design deal to you have time today?

[15:41] <audreyt> oh wait

[15:41] <audreyt> svk diff -r -1 file

[15:41] <gaal> I'll add some motivation Qs to the faq, which are probably useful too.

[15:41] <audreyt> that's the ticket

[15:41] <gaal> -1 is so clever :)

[15:42] <audreyt> clkao: you are so clever, according to gaal (which I agree)

[15:43] <clkao> what have i done?

[15:43] <audreyt> gaal: it's not only on the blog it's also on p6l :)

[15:43] <audreyt> clkao: svk diff -r -1

[15:44] <gaal> clkao: you are so clever

[15:45] <nothingmuch> pmurias: yes

[15:46] * clkao giggles

[15:51] <gaal> audreyt: can you gobby up for a bit? some motivational stuff + match results that can use some input

[15:51] <audreyt> gaal: let me finish the journal entry

[15:51] <audreyt> (longish)

[15:51] <gaal> sure

[15:51] <audreyt> can you commit to Capture.pod first?

[15:52] <gaal> take yer antler

[15:52] <gaal> of course.

[15:55] <nothingmuch> i would like Perl 6 to have a bareword quoting operator that works rightwards

[15:55] <nothingmuch> foo => bar => gorch => "baz" always annoyed me

[15:55] <nothingmuch> the "baz" should be allowed to be unquoted in some syntax

[15:55] <nothingmuch> any ideas?

[15:56] <wolverian> nothingmuch, <foo bar gorch baz>

[15:56] <gaal> <foo  bar gorch baz>

[15:56] <gaal> heh

[15:56] <wolverian> (not exactly the same, as => constructs Pairs)

[15:56] <nothingmuch> err

[15:56] <nothingmuch> not quite

[15:56] <nothingmuch> there are other constructs

[15:56] <gaal> [=>] <foo bar gorch baz>

[15:56] <wolverian> that should do it :)

[15:57] <nothingmuch> heh

[15:57] <gaal> []++

[15:58] <wolverian> so, what do I have to do to get perl to call mysub(1,2,3) instead of (1,2,3).reduce(&mysub) for [mysub] 1,2,3?

[15:58] <wolverian> i.e. binary to listfix

[15:59] <wolverian> I guess that's in the AES somewhere

[15:59] * wolverian finds

[16:00] <gaal> yeah it got elegant treatment

[16:01] <gaal> 'svk ci' is pretty slow in finding the modified files. Is there something I can do to speed it up? (short of specifying which files to ci on the command line)

[16:03] <avar> svn st

[16:03] <avar> or maybe that's equally slow

[16:04] <audreyt> gaal: svk ci docs

[16:04] <audreyt> TimToady: *prod* on S04 update of condition parsing rules :)

[16:06] <svnbot6> r9961 | gaal++ |  r10003@sike:  roo | 2006-04-15 19:02:21 +0300

[16:06] <svnbot6> r9961 | gaal++ |  * FAQ::Capture - added a section on motivation, and

[16:06] <svnbot6> r9961 | gaal++ |    [minor] reflowed long lines.

[16:12] <gaal> audreyt: the HTML rendition on your blog seems to eat long lines. not sure there's much to do about that.

[16:13] <gaal> e.g. the board_ark code

[16:13] <audreyt> borkd_aar

[16:13] *** FurnaceBoy joined
[16:13] <gaal> 0rked bark

[16:21] <audreyt> gaal: I reflowed the long lines

[16:22] <audreyt> can you reflect that in the .pod

[16:22] <audreyt> ?

[16:22] <audreyt> 3rd journal entry of the day up -- I think I really need to sleep

[16:22] <audreyt> please feel free to add more stuff in Capture.pod and I'll see if we can gobby up tomorrow

[16:22] <gaal> reflect the fact you reflowed the long lines?

[16:22] <audreyt> or I'll just commit the answers if you are not around

[16:22] <audreyt> yeah

[16:22] <gaal> tomorrow I have to $work :(

[16:22] <audreyt> aw :(

[16:23] <gaal> sure, i'll commit soon

[16:23] <wolverian> audreyt, s/each up/eat up/

[16:23] <wolverian> ("This will each up all the /a+/...")

[16:24] <audreyt> fixed

[16:25] <wolverian> thanks :)

[16:25] <audreyt> thank _you_ :)

[16:25] * audreyt waves &

[16:25] <gaal> night audreyt

[16:26] <wolverian> cheers

[16:51] *** weinig is now known as weinig|away

[16:59] *** vytautas joined
[17:00] *** larsen joined
[17:02] * nothingmuch posts a 5 beer reward for Inline::GHC ;-)

[17:02] *** Khisanth joined
[17:46] *** PerlJam joined
[17:56] <pmurias> nothingmuch: when will you have time today?

[17:57] *** david_ joined
[17:58] *** larsen_ joined
[18:03] *** colares joined
[18:04] *** nothingmuch joined
[18:09] * PerlJam slowly wends his way through the Capture faq

[18:14] * pmurias hates references, and is glad they will die out

[18:19] *** KingDiamond joined
[18:25] <avar> will they?

[18:26] <avar> ?eval for [] -> $i { say $i}

[18:26] <PerlJam> well they've changed name at least

[18:26] <evalbot_9946> OUTPUT[ ] undef

[18:26] <TimToady> Captures can be viewed as "fat references" when it's politically expedient.

[18:26] * xinming wants to knwo what it will be called instead of "reference" :-P

[18:27] <avar> I suggest "goobeeboo"

[18:27] <avar> Or "Phillip", "Phillip" is a nice name..

[18:27] <TimToady> which "it" are you itting?

[18:27] <avar> ;)

[18:28] <TimToady> Fred would be shorter.

[18:28] <xinming> hmm, I mean the reference. :-/

[18:28] <TimToady> what reference?  the result of []?

[18:28] <avar> TimToady: Won't we need Wilma for consistancy then?

[18:28] <avar> *wouldn't

[18:28] * TimToady goes BamBam on avar's head.

[18:28] <xinming> TimToady: yes, I really don't understand about what audreyt means about make "reference"s die out.

[18:29] <PerlJam> isn't that bammbamm

[18:29] <TimToady> [] is just an empty array in Audrey-speak

[18:29] <TimToady> the term "array" already implies that there's a hidden reference somewhere.

[18:30] <wolverian> just call it "object" :)

[18:30] * xinming needs recheck audreyt's blog... new material is comming. :-)

[18:30] <TimToady> every container has a hidden reference somewhere

[18:30] <TimToady> or you couldn't store them in the symbol table.

[18:30] <wolverian> (albeit the sigils make it a bit different from ruby)

[18:31] <TimToady> and of course the GC still runs on references.  But that's all implicit now.

[18:31] <PerlJam> I just don't understand the answer to "What about multimethod dispatch..."

[18:31] <wolverian> TimToady, is that required? 'course I don't know anything about GCs

[18:32] <TimToady> the whole point of a GC is that you can clean up when something isn't "referred to" any more.

[18:32] <xinming> PerlJam: In my understanding, multimethod dispatch is something the same as the sub declared as "multi"

[18:33] * xinming isn't for sure about that though.

[18:33] <TimToady> this is more about the calling end, not the declarative end, is what it's trying to say.

[18:33] *** FurnaceBoy is now known as FB|afk

[18:33] <TimToady> when you say $a.($b), you get an invocant and one positional.

[18:33] <TimToady> $a.foo($b) rather

[18:34] <TimToady> when you say foo($a,$b), you get two positionals, and no invocant.

[18:34] <wolverian> for a second I thought $a.($b) calls $a($a: $b)

[18:35] <xinming> TimToady: I understand what invocant do, but I really don't find the word invocant mean. :-/

[18:35] <TimToady> when SMD fails over to MMD, the Capture probably has to be rewritten to delete the invocant and unshift it on the front of positionals, at least logically.

[18:35] <TimToady> that's because we made up the word for Perl 5's Camel Book.

[18:36] <TimToady> it's the object on whose behalf the method is being invoked.

[18:36] <TimToady> most of the other words in English either commit you to being the active subject or the passive object, and we didn't want to commit, so we made up a word.

[18:36] *** justatheory joined
[18:36] <xinming> a language creater... :-) no matter the language we say or the programming...

[18:37] <TimToady> well, Tolkien would say that being a subcreator is what we were created to be...

[18:38] <TimToady> It's sort of a fallacy of the Modern Age's idea of specialization that you aren't allowed to be creative outside of your speciality...

[18:39] <TimToady> well, if I don't go and work on my taxes, my wife will think up some creative way to make me regret it.  :)

[18:39] <TimToady> or if I put it off longer, Uncle Same will come up with a noncreative way...

[18:39] <TimToady> *Sam

[18:40] <TimToady> so bbialb &  # bit : long bit :: dot : long dot

[18:47] *** takesako joined
[19:00] *** justatheory joined
[19:04] *** cmarcelo joined
[19:07] *** Limbic_Region joined
[19:13] *** cmarcelo left
[19:17] *** FB|afk is now known as FurnaceBoy

[19:45] *** dvtoo joined
[19:51] <lumi> What's the procedure for typos and suches in the doc patches sent to p6l?

[19:51] <Limbic_Region> probably just reply to the email with the typo correction?

[19:51] <TimToady> or mention them here. :)

[19:51] <TimToady> but if they're extensive, a patch would be nice

[19:53] <TimToady> but LR is right that a reply to p6l is perfectly acceptable.

[19:53] <lumi> Okay

[19:53] <TimToady> or to whoever installed the typos.

[19:53] <TimToady> or wangle a commit bit and fix 'em yourself like Audrey did.  :)

[19:54] <Limbic_Region> speaking of which TimToady

[19:55] <Limbic_Region> there are about 2 or 3 draft Synopses in the Pugs repo

[19:55] <Limbic_Region> have they been reviewed at all by @larry?

[19:55] <Limbic_Region> they are not linked to from dev.perl.org/perl6

[19:55] <TimToady> some of 'em have been revised by $Larry :)

[19:56] <Limbic_Region> ok - so does that mean with your stamp of approval they will go up or are they staying put or what?

[19:56] <TimToady> there are S's that are more core to the language def, and those tend to be on perl.org.  The ones that are basically records of negotiating between designers and implementors tend to be in pugs for now.

[19:57] <Limbic_Region> ok

[19:58] <TimToady> mostly I want things that are trying to stay stable to be on perl.org, and things that are still trying to evolve out where anyone with a pugs commit bit can modify 'em.

[19:58] <TimToady> eventually they'll all move over, but I'm in no rush.

[19:58] <Limbic_Region> Rod is still actively working on S29 though

[19:58] <Limbic_Region> ?

[19:59] <TimToady> it just seems like a useful distinction.  not trying to fuel any turf battles either way...

[19:59] <Limbic_Region> hrm - guess not

[19:59] <TimToady> I don't think he's worked on it in the last year that I've noticed.

[19:59] <Limbic_Region> no updates since March of 2005

[19:59] <TimToady> most of the recent stuff is me.

[19:59] <Limbic_Region> yes, I know

[19:59] <Limbic_Region> TimToady++

[19:59] <TimToady> but there's still a lot missing ,which is why it's "blessed" but still under pugs

[20:03] <gaal> audreyt: the color in make_car's signature is optional because later the call doesn't mention color. either let the ? be left in or add a color arg in the call; or else remove this parameter. IMHO the ? should be left in to point out that the full power of arguments is available here.

[20:04] <gaal> (mentioning this because we've ping-ponged this fix)

[20:10] <gaal> and, different issue: subs don't have an invocant, so how come the pass-through example works? if this is the first positional, shouldn't the signature be

[20:10] <gaal> passthough (Capture $args)

[20:10] <gaal> ?

[20:11] <gaal> else, \ in a signature needs to be explained when the sigil is not $

[20:23] *** kanru joined
[20:23] <LeTo> TimToady: re official S*.pod - I don't see any summary of P6 data types. S09 has some info, but seems to go immediately 'hard core' towards multi-dim arrays and PDL, but has nothing about a plain 'Int' or 'Num' .... Other info is scattered around S02 and S06, but that's suboptimal IMHO.

[20:27] <gaal> audreyt: re: parsing post, this may be interesting to you as it promises linear time parsing for supported languages. I haven't read it yet so I don't know if Perl could be one.

[20:27] <gaal> # http://pdos.csail.mit.edu/~baford/packrat/

[20:30] <LeTo> TimToady: this is about te same .pod problem as reading through p5 docs: 'perldoc perlre' seems to be the first .pod that is explaining p5 string escape chars ;)

[20:55] *** frederico joined
[21:07] *** elmex joined
[21:11] *** PolettiX is now known as froh-doh

[21:12] <pmurias> sleep&

[21:29] *** weinig|away is now known as weinig

[21:33] <ruz> where can I read differences of the Hash and Pair objects?

[21:37] <arcady> a pair is a pair, and a hash contains a bunch of pairs

[21:40] <ruz> why pair is not a hash with one pair? And also they have different declarations syntax.

[21:46] *** stclare left
[21:58] *** nnunley joined
[22:00] *** Khisanth joined
[22:07] *** rashakil joined
[22:10] *** justatheory joined
[22:15] *** larsen joined
[22:30] *** justatheory joined
[22:39] *** _mjk_ joined
[22:47] *** dvtoo joined
[23:01] <spinclad> audreyt: S06.pod, r8698: "Capture that correspond to named parameters are evaluated in scalar": 'Capture' should still be "Arguments".

[23:13] *** larsen joined
[23:27] *** drbean joined
