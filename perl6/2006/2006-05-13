[00:00] <TimToady> I've not had bad luck lately with parrot installs.

[00:00] <TimToady> in fact, I always install parrot.

[00:01] <PerlJam> I used to do that until things broke

[00:01] <TimToady> this is the first time I've been burned by pugs install though...

[00:01] <TimToady> like I say, my parrot install hasn't broken for a couple months.

[00:02] <TimToady> but maybe that's because I have my PARROT_PATH set right

[00:03] <TimToady> actually, as I recall, the problem used to be that pugs was believing the installed parrot over the PARROT_PATH parrot.

[00:04] <svnbot6> r10312 | gaal++ | * Touch Test.pm and Prelude.pm so they will be regenerated to

[00:04] <svnbot6> r10312 | gaal++ |   fit with the recent CompUnit change. The good news is that

[00:04] <svnbot6> r10312 | gaal++ |   next time when things change the error message can be much better.

[00:05] <gaal> in fact the next time, the error will be intercepted and the stale file regenned on the fly. Or that's the plan.

[00:06] <gaal> putter++ # bugging me about versioned bytecode months ago

[00:06] <gaal> gaal-- # not putting in versioned bytecode months ago

[00:07] <particle_> when !~ matches, what does $/ contain?

[00:07] <svnbot6> r10313 | Darren_Duncan++ | ext/Relation/ : added new Relation.pm methods restrict() and delete() ; added method aliases [where, grep, delete_where, select, select_all_but] ; added return types to method sig docs

[00:07] <gaal> eep it'll be dawn in a couple of hours, I should sleep &

[00:08] <TimToady> particle_: same thing as when ~~ matches.  !~ only changes the boolean sense

[00:09] <particle_> okay.

[00:09] <TimToady> just means the Match object shows up in the else instead of the then...

[00:15] <audreyt> TimToady: ping

[00:18] <audreyt> TimToady: re f(x=>1) named and f('x'=>1) pair, I like that even more

[00:18] <audreyt> it follows that f(1=>2) also not named.

[00:18] <audreyt> TimToady: also, there is a student in SoC who wants to hack MAD->p6, are you willing to mentor him (i.e. evaluate his progress and provide feedback)?

[00:19] <audreyt> if yes, signup is at http://code.google.com/soc/mentor_home.html

[00:19] *** justatheory joined
[00:20] <audreyt> (it is currently the highest ranked mentorless proposal)

[00:23] <TimToady> hmm, I'm a lousy mentor...

[00:23] <TimToady> but maybe I could do that.

[00:24] <TimToady> I always read SoC as Southern California...

[00:25] <TimToady> I don't have a google account...

[00:26] <particle_> invite on its way

[00:26] <audreyt> also, google allocs slots by number of distinct mentors

[00:27] <audreyt> (i.e. mentors that volunteered for proposals)

[00:27] *** feng123 joined
[00:28] *** garth joined
[00:28] <audreyt> so it'd be nice to expand the mentor base a bit :)

[00:28] <svnbot6> r10314 | fglock++ | PCR - added :ratchet to the benchmark (3.7x faster than plain PCR); t/09-ratchet.t passes 18/23 tests

[00:30] <audreyt> TimToady: also, the "magical special" flavour of autoquoting works quite well as the indicator of "magical special" named-arg

[00:36] *** SubStack joined
[00:36] <TimToady> okay, I get the feeling you like it. :)

[00:36] <TimToady> I do too.  :)

[00:37] <TimToady> I take it you're still trying to get used to [,]...

[00:37] <audreyt> nope, that's fine

[00:37] <audreyt> it has to be treated specially

[00:37] <audreyt> just like * did

[00:37] <audreyt> because of arglist delaying

[00:38] <TimToady> the one lossage is that [,] can't really trigger a $capture

[00:38] <audreyt> so I'll just take it as a differently spelled *

[00:38] <TimToady> but I'm thinking =$capture works maybe

[00:38] <audreyt> you mean ([,]$capture)

[00:38] <audreyt> wouldn't work?

[00:39] <TimToady> if it's just a list, $capture doesn't interpolate.

[00:39] <audreyt> [,]%hash fails too, right?

[00:39] <audreyt> (instead of interp'ing to named, it'd take pairs)

[00:39] <TimToady> Well, %hash makes pairs...

[00:39] <audreyt> but *%hash worked because it's unary

[00:39] <audreyt> [,] is listop

[00:39] <TimToady> right.

[00:39] <audreyt> and so can't tell %hash apart from $pair

[00:40] <audreyt> whilst a unary op can.

[00:40] <TimToady> could just force it.

[00:40] <audreyt> [,]%hash1, %hash2

[00:41] <audreyt> you mean, force all pairs back into named?

[00:41] <audreyt> or force as in using MMD?

[00:41] <TimToady> one level's worth, just like * did

[00:41] <audreyt> so you mean, if you give [,] one arg

[00:41] <audreyt> then it behaves like old *

[00:41] <audreyt> if you give it two

[00:42] <audreyt> does it propagate?

[00:42] <audreyt> [,] %h1, %h2

[00:42] <audreyt> does that make both into nameds?

[00:42] <TimToady> it's not really a force for %hash1, %hash2 because a reduction is defined syntactically.

[00:42] <TimToady> yes, to do just one is [,](%h1), %h2

[00:42] <audreyt> but not [,] (%h1), %h2

[00:43] <TimToady> so each pair is "comma separated" at the top level.

[00:43] <TimToady> which makes it named

[00:43] <TimToady> presumably not.

[00:43] <audreyt> we had *$hash and *%hash do the same thing

[00:43] <TimToady> as I say, it's just $capture that doesn't naturally continue to work.

[00:43] <audreyt> persumably we'd need to write [,] %$hash now?

[00:43] *** FurnaceBoy joined
[00:43] <TimToady> presumably.

[00:44] <TimToady> and =$capture, perhaps

[00:44] <TimToady> or @$capture, to just get the @ etc.

[00:44] <audreyt> I'm fine w/ that

[00:44] <TimToady> [,] $$capture, @$capture, %$capture;

[00:45] <audreyt> I'm tempted to write *$capture to stand for "whatever caster"" ;)

[00:45] <TimToady> anyway, it really was seeming more and more like we needed to de-borrow * from Ruby.

[00:45] <audreyt> but nah. it's a term.

[00:45] <audreyt> sure

[00:46] <audreyt> hm.

[00:46] <TimToady> the deref meme was just wrong for *.  now we're consistently globby with it.

[00:46] <audreyt> my $capture = \( [,] want() );

[00:47] <audreyt> my @a := =$capture;

[00:47] <audreyt> my $b := =$capture;

[00:47] <TimToady> shades of typeglobs...

[00:47] <audreyt> surely want() is not evaluated twice?

[00:48] <audreyt> trying to avoid typeglob shades :)

[00:48] <TimToady> I would hope it would only evaluate once.

[00:48] <audreyt> but more importantly, in capture construction, does want() just get the current context even when it's not part of binding?

[00:49] <TimToady> it's still logically flattened, whether it's lazy or not.

[00:50] <TimToady> hmm.  that's why my --> Dog: conjecture said it's probably better to return an object that decides.

[00:52] <audreyt> I agree, but that is an argument against builtins that checks want() and do different things

[00:52] <audreyt> currently:

[00:52] <TimToady> yes, want is a weird inside out delayed dispatch, or something.

[00:53] <audreyt> reverse('1', '2'); # '21' on scalar context, ('2', '1') on list

[00:53] <TimToady> a parallel gather/take like thing

[00:53] <audreyt> slurp('/etc/passwd'); # whole file on scalar, list of lines on list

[00:53] <TimToady> if we had a language without side effects, it wouldn't be a problem.

[00:53] <audreyt> readdir('/etc'); # one entry on scalar, all entries on list

[00:53] <audreyt> readline(); # ditto

[00:54] <audreyt> splice(@x, 0, 4); # all spliced on list, but _last_ item on scalar

[00:54] <audreyt> $str ~~ rx/.../; # positional captures on list, Match object on scalar

[00:54] <audreyt> that's all, I think

[00:54] <TimToady> I think want has to be an "observation" in the Copenhagen interpetion

[00:55] <audreyt> reverse() doesn't involve side effect

[00:55] <TimToady> interpretation, even

[00:55] <audreyt> all others does

[00:55] <audreyt> and hence can't be delayed

[00:55] <audreyt> splice's side effect is always the same regardless of context

[00:56] <audreyt> so is poetntially safe

[00:56] <audreyt> all others are unsafe.

[00:56] <audreyt> (well, it can be argued that slurp()'s is also the same)

[00:56] <TimToady> can want know whether to collapse the wavefunction or not?

[00:57] <audreyt> it can know if it's not-yet-bound

[00:57] <audreyt> by passing in a Whatever context

[00:57] <audreyt> but that doesn't help readline() and readdir()

[00:57] <audreyt> which needs to do different things

[00:57] <audreyt> and has to do it now

[00:57] <TimToady> It's like there needs to be a negotiotion.

[00:58] <TimToady> how lazy do you want me vs how lazy can I be

[00:58] <audreyt> right

[00:58] <TimToady> gee, sounds a lot like type inferencing...

[00:58] <audreyt> it is a special kind of inferencing

[00:58] <audreyt> return-type inferencing

[00:58] <audreyt> but I'm wondering if we need all that mechanism, for readdir() and readline()

[00:59] <audreyt> instead of just saying that List context is just casting whatever returned into a List

[00:59] <audreyt> and vice versa

[00:59] <audreyt> which precludes them doing different things

[01:00] <audreyt> but that only affects <reverse readdir readline splice>

[01:00] <TimToady> as far as I'm concerned, it could all just fall under the rule "if we don't know, it's list context".

[01:02] <audreyt> I wonder if

[01:02] <audreyt> reverse('x', 'y')

[01:02] <audreyt> can _always_ reverse the list

[01:02] <audreyt> regarddless of context

[01:02] <audreyt> and reverse('xy') would always just reverse the string

[01:02] <audreyt> as it's just "xy".reverse

[01:03] <TimToady> interesting fallout from the 1-arg rule...

[01:03] <audreyt> i.e. have it decided by arguments, not by context

[01:03] <TimToady> reverse(@onearg)

[01:04] <audreyt> @onearg is an Array

[01:04] <audreyt> goes to Array.reverse

[01:04] <audreyt> performs list reverse

[01:04] <TimToady> so we only get into trouble with reverse([,] @onearg)

[01:05] <audreyt> it's... not troublesome, I think

[01:05] <TimToady> I don't plan to lose much sleep over it...

[01:05] <audreyt> and also even that can be made to work.

[01:05] <audreyt> because [,] puts it to pos, not inv

[01:05] <audreyt> it is still a list.

[01:05] <audreyt> so still list-reversed.

[01:06] <audreyt> ?eval ~(reverse 1,2,3)

[01:06] *** evalbot_10311 is now known as evalbot_10314

[01:06] <TimToady> because foo($x) really means foo([,] $(\$x))

[01:06] <evalbot_10314> "3 2 1"

[01:06] <audreyt> yes.

[01:07] <audreyt> foo($x :), to use another notation

[01:08] <TimToady> what's your opinion of the triangulation metaoperator?

[01:08] <audreyt> it's... cute

[01:08] <TimToady> er...

[01:09] <audreyt> [[+]] 1,2,3

[01:09] <audreyt> I wonder if that looks better

[01:09] <TimToady> I had that first.

[01:10] <audreyt> ok, how about [(+)]

[01:10] <TimToady> but...there's something to be said for cute...

[01:10] <audreyt> just trying to reuse list-producer metaphor instead of backslash-metaphor

[01:10] <TimToady> looks too much like a reduce on the (+) operator

[01:10] <audreyt> but it is

[01:10] <audreyt> a reduce on the (+) operator

[01:10] <audreyt> just a "special" scan reduce ;)

[01:11] <TimToady> is (+) a set operator?

[01:11] <audreyt> oh no...

[01:11] <audreyt> ([+]) 1, 2, 3

[01:11] <audreyt> can be made to work, but too yucky

[01:11] <audreyt> [/+\]

[01:11] <audreyt> I guess I'll livewith [\+].

[01:11] <TimToady> also tried [+]\ and [+\

[01:12] <audreyt> if you have a infix:<\+>, well, too bad

[01:12] <TimToady> also played with |\ briefly.

[01:12] <TimToady> I like that [\ is assymetrical

[01:12] <audreyt> nod.

[01:12] <TimToady> [/+\] would have to start in the middle. :)

[01:13] <TimToady> yes, but at least I doctored it so that [\+] gives you the normal

[01:13] <svnbot6> r10315 | audreyt++ | * Prim.List: [+] 1,2,3 is again fold, not scan.

[01:13] <TimToady> reduce rather than the scan

[01:14] <audreyt> so, in sigs

[01:14] <audreyt> is (*@x) still slurpy?

[01:14] <audreyt> the syntax only changes on the calling end?

[01:14] <TimToady> correct.

[01:14] <TimToady> slurpy is a manifestation of the globby meme

[01:15] <TimToady> "pattern match a bunch of things here".

[01:16] <TimToady> and can't be confused with GLOBAL:: because we never declare globals in sigs.

[01:29] *** Khisanth joined
[01:34] *** justatheory joined
[01:37] <svnbot6> r10316 | audreyt++ | * reverse() is now context-insensitive.  one-arg form, if the

[01:37] <svnbot6> r10316 | audreyt++ |   arg is not listish, coerces to string and reverse it; otherwise

[01:37] <svnbot6> r10316 | audreyt++ |   it's always a list reverse.

[01:40] *** justatheory joined
[01:41] <audreyt> TimToady: S06 still has

[01:41] <audreyt>     doit *$pair,1,2,3;  # always a named arg

[01:41] <audreyt>     doit *%pairs,1,2,3; # always named args

[01:41] <audreyt> I take it's now

[01:41] <audreyt> [,]%$pair

[01:41] <audreyt> [,]%pairs

[01:41] <audreyt> right?

[01:42] <TimToady> yes

[01:43] <audreyt>     doit [,](%$pair),1,2,3;             # always a named arg

[01:43] <audreyt>     doit [,]('when' => 'now'),1,2,3;    # always a named arg

[01:43] <audreyt>     doit [,](%(get_pair)),1,2,3;        # always a named arg

[01:43] <audreyt> so that's the correct way

[01:44] <audreyt> not sure how the second line works.

[01:44] <audreyt> if it works at all

[01:44] <TimToady> though in the particular case of 1,2,3 it doesn't matter whether they're in or out

[01:44] <audreyt> shouldn't it also need a

[01:44] <ludan> good night

[01:44] <audreyt> %('when'=>'now')

[01:44] <audreyt> ?

[01:44] <audreyt> ludan: g'nite

[01:45] <TimToady> I don't expect a %() would hurt there.

[01:45] <audreyt> but without %(), I can't see it working

[01:45] <TimToady> =$pair possibly.

[01:45] <audreyt> 'when'=>'now' is not different from $pair

[01:45] <audreyt>     doit [,] %$pair,1,2,3;              # always a named arg

[01:45] <audreyt>     doit [,] %(get_pair()),1,2,3;       # always a named arg

[01:45] <audreyt>     doit [,] %('when' => 'now'),1,2,3;  # always a named arg

[01:45] <audreyt> well, eventually [,]= becomes the next *

[01:46] <TimToady> is that an assignment operator?

[01:46] <audreyt> heh ;)

[01:47] <audreyt> oh. did you see my question about

[01:47] <audreyt> $+PATH = 'x'

[01:47] <TimToady> there's a nice consistency to the % there.

[01:47] <audreyt> @+PATH = (1,2,3) ?

[01:48] <TimToady> It seems like a good plan, except for the fact that different listy env vars are going to use different delimiters...

[01:48] *** Ymmv joined
[01:48] <audreyt> which is why maybe it's not neccessarily a good plan...

[01:49] <audreyt> (also, mutable $+PATH in general is unspecced)

[01:49] <audreyt> but I guess it better be mutable

[01:49] <audreyt> also, not sure what %+PATH even means :)

[01:49] <audreyt> maybe the ENV hash only declares $+PATH, and @+PATH is a lookup failure.

[01:50] <TimToady> env @PATH is delim<:> := $+PATH

[01:50] <TimToady> I dunno.

[01:51] <TimToady> this reminds me a bit of @array ~~ /pattern/

[01:51] <TimToady> $+PATH is parsed ...

[01:52] <audreyt>     dies_ok { f7($bar => 42) },

[01:52] <audreyt>         "variables cannot be keys of syntactical pairs (1)";

[01:52] <audreyt> Juerd: implicitly computed keys are now dead, yay

[01:53] <TimToady> wouldn't that just be a pair argument?

[01:53] <audreyt> yup

[01:53] <audreyt> but f7 was declared as

[01:53] <TimToady> or does it die because of f7?

[01:53] <TimToady> got it.

[01:53] <audreyt> sub f7 (:$bar!)

[01:54] <audreyt> bbiab

[01:54] <svnbot6> r10317 | audreyt++ | * implicitly computed keys in named arguments are now dead:

[01:54] <svnbot6> r10317 | audreyt++ |     f(a=>42);   # named

[01:54] <svnbot6> r10317 | audreyt++ |     f('a'=>42); # positional

[01:54] <TimToady> commuting home &

[01:56] *** DaGo joined
[02:00] *** neoesque joined
[02:12] <TimToady> degone

[02:14] <audreyt> back

[02:15] <audreyt> so a [,](...) within a capture introduces a "zone"

[02:15] <audreyt> within which things are parsed differently

[02:15] <audreyt> using autoconcat rules

[02:16] <TimToady> by autoconcat you mean A x B x C x D...?

[02:16] <TimToady> that is, the syntactic rewriting of [x]?

[02:17] <audreyt> I mean

[02:17] <audreyt> [,](%a, %b, %c, @d)

[02:17] <audreyt> explodes the elements one level

[02:18] <audreyt> and concat them together asif they were written out in toplevel

[02:18] <TimToady> which is what a reduce is supposed to do...

[02:18] <TimToady> by syntactic metaphor

[02:18] <audreyt> yes, but in the case of [,] and [;]

[02:18] <audreyt> that means more like "reparse"

[02:19] <audreyt> btw, why doesn't [=] work?

[02:19] <audreyt> [=] $a, 3;

[02:19] <TimToady> I don't see why it wouldn't.

[02:20] <audreyt> I'll add it to S03 then. I dopn't see why it wouldn't, either.

[02:20] <audreyt> what is the negation of ===?

[02:20] <audreyt> not ($a === $b) ?

[02:20] <TimToady> not( $a === $b )

[02:21] <audreyt> is [=]() nonsensical of undef?

[02:21] <audreyt> (same goes for [:=])

[02:21] <TimToady> I suppose.

[02:22] <audreyt> [+=] $a, $b, $c; # sane, then

[02:23] <TimToady> Then theres [\+=] $a, $b, $c

[02:23] <audreyt> ok. thanks for getting this normalizationg ([,] [=] [;]) in

[02:24] <audreyt> before au[frank|dreyt] burned too much time on the */** form...

[02:24] <audreyt> it's quite a bit easier to explain, the current way.

[02:24] <TimToady> It just suddenly hit me that we already had * staring us in the face.

[02:24] <audreyt> easiest to miss when it's too close...

[02:24] <TimToady> I think so.  Damian likes it.

[02:24] <audreyt> I like it as long as we use [,] %() consistently :)

[02:25] <audreyt> this actually means [,] cannot introduce new invocants

[02:25] <audreyt> can't tell between [,] $$x  and [,] $x

[02:25] <audreyt> for some reason, this still doesn't bother me, if we keep =$x.

[02:26] <audreyt> =$cap, that is

[02:26] <audreyt> that is, we treat = as almost a sigil

[02:26] <audreyt> for the special purpose of the [,] zone

[02:26] <audreyt> it feels a bit icky

[02:27] <TimToady> 'course it was the pain of rewriting all the *@foo to make * "almost a sigil" that drove me over the edge to whacking it...

[02:27] <audreyt> $$cap.call([,] @$cap, %$cap);

[02:27] <audreyt> what do you feel about imposing this on users?

[02:28] <audreyt> call([,] =$cap) # because this takes a special-case of prefix:<=>

[02:28] <TimToady> as long as there's a way to do it, we can look at slicker ways to do it later.

[02:28] <audreyt> however, we can workaround it by saying any function calls in [,] zone

[02:28] <audreyt> gets all its full Capture-return exploded

[02:29] <audreyt> sub func {return(1: 2, x=>3)}; \([,] func());

[02:29] <TimToady> yes.

[02:29] <audreyt> and then it falls out from that

[02:29] <audreyt> ok, that feels much clearner :)

[02:29] <TimToady> do extra invocants turn into positionals or blow up?

[02:30] <audreyt> yes.

[02:30] <audreyt> (but I prefer the latter)

[02:30] <audreyt> but well hm

[02:30] <TimToady> clearner++

[02:30] <audreyt> the latter can't work, can it

[02:30] <audreyt> has to be the former

[02:30] <audreyt> the former, then.

[02:30] <audreyt> extra invs become positionals

[02:30] <audreyt> and we can use your Capture layout

[02:31] <TimToady> kinda goes back to the idea that the invocant is the honorary head of the positionals...

[02:31] <audreyt> where the inv is just a bit

[02:31] <audreyt> RAID again...

[02:31] <TimToady> yeah.

[02:31] <audreyt> ok. can you document those two points?

[02:31] <audreyt> I feel together they can make [,] fly stably

[02:32] <audreyt> (capture-explosion and inv-turns-into-pos-under-explosion)

[02:32] <TimToady> I've been thinking of invocants in Captures as kind of a search strategy, where different types from the type bag

[02:32] <TimToady> are more specific.

[02:32] <TimToady> and the head of @ is just the most generic place to look for an invocant.

[02:32] <audreyt> surprisingly, I parsed that line with no difficulty and even agree with it :)

[02:33] <TimToady> it took me a while to compose it...

[02:33] *** DaGo joined
[02:33] <TimToady> I'm being called to dinner, but I'll whack on it later.

[02:33] <audreyt> so it was worth that while, I suppose...

[02:33] <audreyt> yay

[02:33] <audreyt> TimToady++

[02:33] *** dduncan joined
[02:34] <TimToady> biab &

[02:34] * audreyt goes to find some lunch

[02:35] <dduncan> audreyt, when you come back, can you give an idea when the earliest possible date/time is that the cut-off for what goes/doesn't into 6.2.12 is?

[02:36] <dduncan> I'd like to know how much time I have to work with to get certain things in

[02:36] <dduncan> eg, will it be before or on next tuesday/wednesday?

[02:37] <audreyt> well, we know it has to happen after parrot release

[02:37] <audreyt> preferably right-after

[02:38] <audreyt> which means next wednesday is likely

[02:38] <audreyt> or thursday

[02:38] <audreyt> or at latest next weekend

[02:38] <dduncan> for parrot or pugs or both?

[02:38] <audreyt> both

[02:38] <audreyt> parrot 0.4.4 will be relenged this weekend

[02:38] <audreyt> and released, usually a few days after

[02:39] <audreyt> bbiab...

[02:39] <dduncan> thank you

[02:40] <audreyt> np :)

[02:40] *** dduncan left
[02:49] *** FurnaceBoy joined
[02:55] *** multic joined
[02:59] *** multic left
[03:02] *** nothingmuch joined
[03:13] *** KingDiamond joined
[03:24] <meppl> gute nacht

[03:25] *** DaGo joined
[03:44] *** aufrank joined
[03:44] *** Ymmv joined
[03:45] <aufrank> hello!

[03:45] <FurnaceBoy> ola

[03:46] <aufrank> is gaal around?

[04:02] <aufrank> stevan++

[04:02] <aufrank> will perl 6 cherry pick the role additions from the newest Moose?

[04:02] <svnbot6> r10318 | lwall++ | More long dot tests.

[04:02] <aufrank> calc

[04:07] *** FurnaceBoy_ joined
[04:12] <aufrank> sorry, that was supposed to be M-x calc =\

[04:24] *** FurnaceBoy joined
[04:38] <stevan> aufrank: I hope Perl 6 will consider some of the role additions I have made

[04:38] <aufrank> I think excludes sounds really useful

[04:38] <aufrank> that said, I've never programmed with roles at all, so it's just gut feeling at this point

[04:38] <stevan> yeah me too, stole that from Fortress :)

[04:38] <aufrank> I haven't really done the heavy lifting of thinking up use cases ;)

[04:39] <stevan> well one of the main issues with role composition is that easy things are easy

[04:39] <stevan> but complex things can get really hairy really fast

[04:40] <stevan> Moose still hasn't worked out the full details of how attributes and roles interact

[04:40] <stevan> when i mentioned to the guys who wrote the original Traits paper that we were experimenting with that

[04:40] <stevan> they said "good luck, let us know how it works out" :)

[04:41] <stevan> its a potentially very thorny feature

[04:41] <aufrank> attributes are traits?

[04:42] <aufrank> sub foo is fancy does dance_moves { ... }

[04:42] <aufrank> fancy is the attribute, dance_moves is a role?

[04:42] <stevan> aufrank: no, class-attributes/instance-slots

[04:42] <aufrank> oh oh

[04:43] <stevan> role Foo { has $.bar; } role Bar { has $.bar; } role FooBar { does Bar; does Foo; }

[04:43] <stevan> what should happen there

[04:43] <stevan> conflict is the most obvious

[04:43] <aufrank> role foo { has $.a } role bar { has $.a } sub foo does foo does bar { say $.a }

[04:44] <stevan> right now in Moose, any attr name conflict blows up right away

[04:44] <stevan> however, this is only because we closely associate instance slot names and attribute names

[04:44] <stevan> if we decoupled that, it would not be an issue

[04:44] <aufrank> can you be explicit with $::foo<a> or something>

[04:44] <aufrank> ?

[04:44] <stevan> exactly

[04:45] <aufrank> (was I close on syntax?)

[04:45] <stevan> but it gets messy the more details you add to the use case

[04:45] <stevan> fairly close I think,.. I have been outta the loop myself :)

[04:45] <aufrank> S12 is one of the one's that I'm not sure I've ever been all the way through...

[04:46] <stevan> :)

[04:46] <stevan> it's a dense one thats for sure

[04:49] <aufrank> stevan: are instance slot names and attribute names separated in ruby?

[04:49] <aufrank> one of the two is @@, I think

[04:49] <PerlJam> stevan: I'm not sure if I got this from perl6 or from the traits paper or what, but isn't part of the compositional nature of roles that once composed, they lose their identity as separate entities?

[04:50] <PerlJam> (ergo, the "right" thing to do in conflict is to blow up)

[04:53] <stevan> aufrank: my ruby-fu is fairly weak these days :)

[04:53] <stevan> aufrank: IIRC, @foo is an instance variable, and @@foo is a class variable

[04:53] <aufrank> mine too, or I wouldn't be asking ;)

[04:53] <aufrank> I'm just trying to get a sense of what that decoupling would bring with it

[04:54] <aufrank> is it just losing some of the $.a and $!b sugar in class declarations?

[04:54] <stevan> PerlJam: once roles are combined, they become basically just an anon-role which is simply a composite of the roles with all mixing rules and conflict stuff applied

[04:55] <stevan> aufrank: decoupling attr names from how they are stored just allows the meta-level to get more funky :)

[04:55] <stevan> I am not sure if there is any true value though

[04:56] <aufrank> maybe I'll wait til you draw a picture ;)

[04:56] <PerlJam> Why do I get the feeling that pelr6 needs another special block for composition-time actions?  I don't know what you'd call it though, BEGIN, INIT, CHECK, and ... COMP?  COMPOSE?  hmm

[04:57] <PerlJam> I guess it would be a special kind of FIRST though

[04:58] <stevan> aufrank: :)

[04:58] <PerlJam> yeah, stevan++ for drawing good pictures :)

[04:59] <stevan> PerlJam: one of the "experiments" in Moose is that of not trying to do everything at compile time

[04:59] * stevan knew those years at Art School didn't go to waste :)

[04:59] <PerlJam> so moose has lazy conflict resolution?

[05:00] <stevan> PerlJam: Moose is very lazy

[05:01] <PerlJam> one of these days I'll have to find time to play with moose.  I saw your journal entry just a few minutes ago, but it only percolated up to a musing "neat" and not quite all the way to "I should play with this now"

[05:05] <svnbot6> r10319 | aufrank++ | added todo items for [,] and recent clarifications in S06

[05:07] <aufrank> alright, sleep time

[05:07] <aufrank> see you folks around

[05:15] <audreyt> g'nite

[05:15] <audreyt> I'll be back in 3~4 hrs

[05:15] <PerlJam> have a good sleep audreyt

[05:17] <audreyt> s/sleep/shopping/ actually...

[05:17] <audreyt> (that g'nite was to aufrank)

[05:17] <audreyt> &

[05:23] <PerlJam> oh, well, have a good ... um, down time?  rest from hacking?  whatever it is that shopping does for you :)

[05:24] <Juerd> shopping time.

[05:25] <Juerd> That's the safest way to say it :)

[05:52] *** DaGo joined
[05:56] *** Ymmv joined
[06:07] *** masak joined
[06:11] <gaal> aufrank: you moosed?

[06:11] *** Ymmv joined
[06:11] <gaal> 04:13 < TimToady> reduce rather than the scan

[06:11] *** Aankhen`` joined
[06:12] <gaal> I'm not sure I agree with that

[06:12] <gaal> reduce is more general than fold or scan

[06:12] <gaal> morning

[06:29] <azuroth> I have safari :D

[06:39] <svnbot6> r10320 | spinclad++ | - JudyHS: doc: added second, alternative, iterator interface

[07:08] *** ghenry joined
[07:09] *** ghenry left
[07:13] *** macroron joined
[07:20] *** iblechbot joined
[07:41] *** r0nny joined
[08:06] *** Ymmv joined
[08:19] *** bb3 joined
[08:22] *** elmex joined
[08:26] *** DaGo joined
[08:33] <svnbot6> r10321 | spinclad++ | - JudyHS: add new calls to Judy.h

[08:37] <gaal> stevan: re: recent Moose post: In Haskell you can define either == or /= and either other one will be derived if it isn't defined. Maybe Moose should do that?

[08:37] *** bernhard joined
[08:40] <audreyt> rehi

[08:41] <audreyt> hm, the named-arg caused 100% increase in failed subtests

[08:42] * audreyt triages

[08:47] *** AtomicStack joined
[09:01] <svnbot6> r10322 | spinclad++ | - JudyHS: typo fixes

[09:15] *** m joined
[09:17] *** m joined
[09:59] *** KingDiamond joined
[10:03] *** larsen joined
[10:13] *** nnunley joined
[10:21] <ingy> hi nnunley

[10:21] *** neoesque joined
[10:23] *** DaGo joined
[10:25] *** Kournikoza joined
[10:26] <Kournikoza> hello, when i changed the timezone on my system, and my perl program is in a loop (and uses localtime()).. how can i know that the timezone has changed, so localtime() can work with it instead of the old timezone?

[10:30] *** trampel joined
[10:47] *** DaGo joined
[10:51] *** chris2 joined
[10:53] <Kournikoza> help, how can I get the current time in "seconds with %6d microseconds" with strftime?

[10:54] *** ludan joined
[10:59] <Juerd> You can't

[11:00] <Kournikoza> help, how can I get the current time in "seconds with %6d microseconds" with strftime?

[11:03] *** mykhal joined
[11:14] *** bernhard joined
[11:15] <Kournikoza> help, gettimeofday returns the current time, but if i change the timezone, gettimeofday doesnt adapt to the timezone, but the date command shows the change.. what must i do?

[11:18] *** elmex joined
[11:36] <azuroth> is it a perl6 program, Kournikoza?

[11:44] *** garth joined
[11:56] *** AtomicStack joined
[11:56] *** iblechbot joined
[11:56] <Kournikoza> azuroth yes

[11:57] <azuroth> excellent, I didn't know time stuff was implemented

[12:00] <Kournikoza> please, i needto know how i get the time in $seconds,$microseconds linked with the curernt time zone.. how can i do that? i tried several things with gmtime etc.. but i don't get the seconds and ms..

[12:01] *** pmurias joined
[12:01] <pmurias> hi

[12:02] <audreyt> hi

[12:03] <pmurias> are there any plans for a rule syntax which wouldn't require named rules to be surrounded by <>

[12:03] *** Ymmv joined
[12:03] <pmurias> ?

[12:03] <pmurias> >

[12:04] <pmurias> eq. /named_rule1 named_rule2/ instead of /<named_rule1> <named_rul2>/

[12:08] <audreyt> how do you diff that from literals?

[12:21] *** neoesque joined
[12:22] *** TimToady joined
[12:25] <pmurias> require them to be quoted(some rules have very little of them eq. Signature.pg or Capture.pg)

[12:27] <pmurias> or use the perl5 'no strict' style behaviour rules which are not defined return their name

[12:29] <pmurias> the <> less syntax would require an :modifier

[12:36] <pmurias> the APL,pheme,and the {Signature,Capture}.pg don't use literals, so it would be a (big) win for those

[12:44] <audreyt> *nod*

[12:46] <pmurias> how should be the modifier named than?

[12:48] *** weinig joined
[12:49] <audreyt> not sure

[12:49] <pmurias> :bare?

[12:55] *** DaGo joined
[12:59] <audreyt> I wonder if we can use standard combinator for them, even...

[12:59] <audreyt> rule foo { <f1> <f2> }

[13:00] <audreyt> becomes

[13:00] <audreyt> sub foo { ; f1; f2; }

[13:00] <audreyt> probably just an idle thought.

[13:00] <audreyt> (but I do agree that <>-less syntax is attractive)

[13:01] <audreyt> <'literal'> just becomes 'literal'

[13:07] * audreyt praises vim8

[13:08] <pmurias> what does '...' do in standard rules?

[13:08] <audreyt> it means two anychar

[13:08] <audreyt> I mean three

[13:08] *** marmic joined
[13:10] <pmurias> :) the ... were just place holders

[13:10] <pmurias> i want to know what do '' mean

[13:11] <Gothmog_> audreyt: You mean vim7?

[13:11] <audreyt> yes.

[13:11] <Gothmog_> Or did I miss something?

[13:11] <Gothmog_> k. :-)

[13:11] <audreyt> I compensated for that in the "two anychar" below

[13:12] <audreyt> pmurias: they mean literal ' I think

[13:22] <pmichaud> right now ' means literal '

[13:23] <audreyt> token program { ^ statement_list ?ws [ $ | ?syntax_error ] }

[13:23] <audreyt> token statement_list { statement [ ?statement_end statement ]* ?statement_end? }

[13:23] <audreyt> it does look a bit less cluttered

[13:25] <pmichaud> how do we differentiate ? (non-capture) from ? (**{0..1})?  Require that all quantifiers abut the thing the quantify?

[13:25] <pmichaud> s:2nd/the/they/

[13:26] <audreyt> prefix vs postfix?

[13:26] <audreyt> and yes.

[13:27] <pmichaud> rule { subrule1?subrule2 }

[13:27] <pmichaud> hmmmm

[13:27] <audreyt> not sure if it's going to be a win overall

[13:28] * audreyt recites the "different things should look different" mantra

[13:28] <pmichaud> I guess one would disambiguate with [...]:   rule { [subrule?]subrule2 }   or rule { subrule[?subrule2] }

[13:28] <pmurias> IMHO something else should be used for non-capture instead of ? in the <> less mode

[13:28] <garth> rule { subrule1 subrule2 } vs. token { abc } vs. regex { abc } -- one more way to differentiate rules from tokens etc.

[13:28] <pmichaud> except I would think that token should be like rule and less like regex

[13:29] <audreyt> what pmichaud said.

[13:29] <pmichaud> i.e.,  rule { subrule1 subrule2 }, token { subrule1 subrule2 }   vs regex { abc }

[13:29] <pmichaud> pmurias:  at one point we had <<...>> as capturing subrule and <...> as non-capturing

[13:30] <pmichaud> another way to do a non-capturing rule is + ...    <subrule> captures,  <+subrule> doesn't

[13:31] <pmichaud> (but that seems to give an odd interpretation to '+')

[13:31] <pmurias> why is ? more easily explained?

[13:32] <audreyt> my &f; say f();

[13:32] <audreyt> I wonder if this should die.

[13:32] <audreyt> i.e. is Code more like Array/Hash or is it more like Scalar.

[13:33] <pmichaud> I've been thinking of it like scalar

[13:33] <pmichaud> but hadn't thought about it deeply

[13:34] <audreyt> I think it has something to do whether assigning into &f should work in general

[13:34] <audreyt> if you can say

[13:34] <audreyt> &*say = ...

[13:34] <audreyt> then it should init to undef, sure

[13:35] <audreyt> but maybe &*say is bound to that name, not assigned into it in the first place

[13:36] <audreyt> question is, is the default "my &f" a Code, or a Scalar with Code constraint.

[13:37] <audreyt> Pugs currently has the latter

[13:37] <pmurias> pmichaud: the same problem occures with + as with ?

[13:38] <pmichaud> pmurias: I don't disagree; I don't have another answer.  :-)

[13:39] <audreyt> I guess doing it the way perl5 people would expect is probably best

[13:40] <audreyt> i.e. it is mutable by default, and it should die

[13:40] <audreyt> when called in uninitialized mode

[13:40] *** ruoso joined
[13:41] <audreyt> ?eval my &plus = {$^x+$^y}; &plus .= assuming(x=>1); plus(2)

[13:41] *** evalbot_10314 is now known as evalbot_10322

[13:41] <evalbot_10322> 3

[13:56] <audreyt> pmichaud: ping

[13:57] <pmichaud> poing

[13:57] <audreyt> pmichaud: did you sign up as SoC mentor?

[13:57] <pmichaud> yes

[13:57] <audreyt> have you taken any mentorship slots yet?

[13:57] <pmichaud> at least I said I'd be one, I don't know that I "signed up" anywhere

[13:57] <audreyt> oh. you need to do that, like, today

[13:57] <pmichaud> afaik I don't have any mentorship slots yet

[13:58] <audreyt> http://code.google.com/soc/mentor_home.html

[13:58] <audreyt> if you had not

[13:58] <pmichaud> I didn't know there was a "signup"

[13:58] <audreyt> there was

[13:58] <audreyt> and if you didn't, then you can't take up mentorship at all

[13:58] <audreyt> so please sign up :)

[13:58] <audreyt> (because I'm trying to get aufrank's application pushed to your plate :))

[13:59] <audreyt> (and scw's if you feel that you have extra time, but aufrank's definitely)

[13:59] <pmichaud> I'm now signed up

[13:59] <pmichaud> and yes, I have time, or will find the time

[14:00] <audreyt> yay

[14:00] <pmichaud> I'd be glad to be working with aufrank and scw

[14:00] <audreyt> so you have access to the "mentor home" project listing?

[14:00] <audreyt> or are you "pending approval" from perl.org?

[14:00] <pmichaud> "pending approval"

[14:01] <audreyt> particle_: are you the admin, or should I ping Robrt?

[14:01] *** jsiracusa joined
[14:03] <audreyt> nvm. pinged robrt

[14:04] *** Khisanth joined
[14:04] <scw> :)

[14:08] <aufrank> hi folks

[14:08] <audreyt> yo

[14:09] <aufrank> my ears were burning ;)

[14:10] <audreyt> :)

[14:13] * audreyt is trying to avoid the undesirable ituation of mentoring ~10 people

[14:13] <svnbot6> r10323 | audreyt++ | * Uninitialized VCode is now (conceptually) undef, so this

[14:13] <svnbot6> r10323 | audreyt++ |   is no longer a parsefail, but a runtime failure:

[14:13] <svnbot6> r10323 | audreyt++ |     my &f; f 1;

[14:13] <audreyt> so far quite successful; more than half is delegated away :)

[14:16] <svnbot6> r10324 | audreyt++ | * Regen AST.Internals instances to capitalize error messages.

[14:19] <svnbot6> r10325 | audreyt++ | * Eval.hs: "yield" should preserve the calling context correctly now.

[14:22] <svnbot6> r10326 | audreyt++ | * Pugs.Parser.Operator: uninitialized functions are not

[14:22] <svnbot6> r10326 | audreyt++ |   relevant to parsing:

[14:22] <svnbot6> r10326 | audreyt++ |     my &f := -> $x {...}; f 1, 2, 3; # this is still listop

[14:25] <svnbot6> r10327 | audreyt++ | * unTODO various passing tests, and take the quotes out of

[14:25] <svnbot6> r10327 | audreyt++ |   f('x'=>1) now that it has to be written f(x=>1).

[14:25] <clkao> does pil2js backend work now?

[14:27] *** iblechbot joined
[14:27] <audreyt> havn't checked recently

[14:27] <audreyt> will get it to work before release

[14:33] *** DaGo joined
[14:38] *** Limbic_Region joined
[14:39] *** justatheory joined
[14:40] <aufrank> I'm going to be afk for most of the weekend, I think

[14:40] <aufrank> heading home to cleveland to watch a basketball game

[14:40] <pmichaud> have fun

[14:40] <aufrank> I'll see you folks sunday night or some time monday :)

[14:40] <aufrank> bye! &

[14:55] *** jserv-- joined
[14:56] *** justatheory joined
[14:58] <pmurias> ` could be used for non capturing rules

[15:04] <svnbot6> r10328 | scw++ | Rule::Perl5::Ratchet: fix emitter to make lexical unnamed subrule works.

[15:08] *** FurnaceBoy joined
[15:35] *** mago joined
[15:37] *** mago joined
[15:45] <gaal> there are two mentions of &?SUB in S06. Is this correct, or should those be &?ROUTINE ?

[15:52] <TimToady> gaal: fixed, thanks

[15:52] <ingy> audreyt: ping

[15:54] <audreyt> pong

[15:54] * ingy was interviewing someone a couple days ago for a programming position, who didn't really know Perl so much. At the end of the interview he said, "You Perl guys are pretty cool. I was always scared away by those crazy people like ESR and Larry"

[15:54] <audreyt> but I need to sleep, like, now

[15:54] <gaal> TimToady: thank you. I'm rereading S06 and things are making sense again :)

[15:54] <ingy> hi audreyt

[15:55] <ingy> I have a url for you

[15:55] <audreyt> ok

[15:55] <ingy> yaml type tags...

[15:55] <audreyt> as long as it's not http://localhost/

[15:55] <audreyt> I've already got that one

[15:55] <ingy> http://pyyaml.org/wiki/PerlTagScheme

[15:55] <gaal> and you can use it whereever you go!

[15:55] <ingy> funny place for it I know...

[15:56] <ingy> anyway I promised you a proposal

[15:56] <audreyt> ok, I got it.

[15:56] <audreyt> I remember I said "tests"

[15:56] <audreyt> but a spec is fine

[15:56] <audreyt> it makes sense only when both YAML.pm and YAML::Syck can support it

[15:56] <ingy> its not a spec

[15:56] <audreyt> preferably in the same release

[15:56] <Juerd> What is "couple days"? Short for "couple of days"?

[15:57] <audreyt> Juerd: probably

[15:57] <ingy> it's a draft proposal for you to comment on at this point

[15:57] <audreyt> why !! not !?

[15:57] <ingy> it's a trac so just comment on the page

[15:58] <ingy> !! is more official

[15:58] <audreyt> got it

[15:58] <audreyt> ok

[15:58] <ingy> ! can be anything

[15:58] <ingy> I don't really care what it is in practice, as long as we are in parity

[15:58] <audreyt> "http://pyyaml.org/wiki/PerlTagScheme"

[15:58] <audreyt> er

[15:59] <audreyt> "determined by"

[15:59] <audreyt> how does Foo::Bar signify its desired layout?

[15:59] <ingy> and I'm trying to get in parity with the python folks and ruby folks too

[15:59] <audreyt> probe ->new's layout?

[16:00] <audreyt> otherwise I think it's sane

[16:00] <audreyt> you have an idea of when you'll have cycles to put together a draft impl in YAML.pm?

[16:00] <ingy> using  !perl/Foo.Bar implies there is a Foo::Bar class with a from_yaml method

[16:01] <ingy> or somesuch

[16:01] <audreyt> not too sure about that

[16:01] <audreyt> why can't we just bless it?

[16:01] <ingy> then use !perl/:Foo.Bar

[16:02] <ingy> or !perl/hash:Foo.Bar

[16:02] <ingy> which are synonyms

[16:02] <audreyt> and hash:Foo::Bar is also synonym

[16:02] <audreyt> I'm not too sure about :: vs . synonymship

[16:02] <audreyt> either we all normalize to .

[16:03] <audreyt> or we only normalize to . on the object-handling sigilless way

[16:03] <audreyt> and preserve :: otherwise

[16:03] <ingy> Well, for !perl/ tags I don't care...

[16:03] <audreyt> ok then

[16:03] <ingy> for !!object:Foo.Bar

[16:03] <audreyt> in that case, :: is probably better to !perl

[16:03] <audreyt> too confusing otherwise

[16:03] <audreyt> !!object I agree.

[16:03] <ingy> I was just throwing out options

[16:03] <audreyt> I understand

[16:04] <audreyt> and I was just about to fall asleep prior to that :)

[16:04] <ingy> do you like the sigils or long forms for Perl?

[16:04] <ingy> I don't really want to support both

[16:05] <ingy> the long forms are nice because the blessing is just an extension

[16:05] <ingy> of the unblessed forms

[16:05] <ingy> I think the sigils are too cute

[16:05] <audreyt> I dislike the sigils

[16:05] <ingy> cool. gone

[16:05] <audreyt> the new form should be as distinct as possible

[16:05] <audreyt> from the old form

[16:05] <audreyt> we are breaking all compat

[16:06] <audreyt> so we might as well do it in a more regular and clearner way

[16:06] <ingy> sigh...

[16:06] <ingy> yeah

[16:06] <audreyt> the tone of your "sigh" and "or somesuch" reminds me of TimToady...

[16:06] <ingy> yes

[16:06] <ingy> borrowed from him

[16:07] <audreyt> as we all do :)

[16:07] <ingy> well not sigh but somesuch and handwaving

[16:07] <audreyt> ok, I think the current proposal will fly

[16:07] <audreyt> will take a closer look tomorrow

[16:07] * ingy handwaves audreyt goodnight

[16:07] * audreyt handwaves back

[16:07] <audreyt> &

[16:11] *** cdpruden joined
[16:11] <scw> hi, there are some inconsistent in S05, the first and last appearance of 'ratchet' described totally opposite behaviors of :ratchet and ':'

[16:15] <TimToady> fixed, thanks.

[16:15] <TimToady> afk &

[16:20] <nothingmuch> can we have a commit bot svn.perl.org too?

[16:21] * nothingmuch tries to remember who runs svnbot6 

[16:24] <ingy> hola nadamucho

[16:34] *** saorge joined
[16:41] <nothingmuch> hola ingu-san

[16:41] * nothingmuch freezes

[16:42] <nothingmuch> i ran out of hot water in the middle of the shower, just after i finished putting on the shampoo

[16:42] <nothingmuch> worst possible timing

[16:44] *** sri__ joined
[16:45] *** sri__ joined
[16:49] *** larsen joined
[16:53] <svnbot6> r10329 | scw++ | Pugs::Compiler::Rule: more tests on alternation for ratchet

[16:53] *** justatheory joined
[16:58] *** trampel left
[16:59] *** ruoso joined
[17:25] *** justatheory joined
[17:26] *** geoffb joined
[17:55] *** Mahmoud joined
[17:55] *** Mahmoud left
[17:56] *** davidfetter joined
[18:05] *** r0nny joined
[18:21] *** ruz joined
[18:24] *** FurnaceBoy is now known as FB|afk

[18:24] *** elmex joined
[18:36] <stevan> gaal: I would love for Moose to support a Haskell style Eq, I just need to figure out the details of a requires_either '==' | '!='

[18:37] <stevan> for that matter a haskell style Ord would be cool too :)

[18:38] <davidfetter> hello

[18:38] <davidfetter> any postgres fans in the house?

[18:38] <davidfetter> er, any other ones? ;)

[18:40] * ruoso seriously consider reimplementing latex2html with P::C::R

[18:40] <davidfetter> i'm looking for ppl who can help me figure out whether it makes sense to see about making a PL/Parrot

[18:41] <ruoso> davidfetter, it would be at least impressive

[18:42] <davidfetter> ruoso, i'm pretty much of a n00b as far as VMs and language bindings go. does it even make sense to talk about such a thing?

[18:43] <ruoso> sure it does...

[18:43] <ruoso> parrot is currently embedable in perl 5

[18:44] * ruoso wonders if "embedable" is a valid word....

[18:44] <davidfetter> so what's a 50,000-foot view of how such a thing might work?

[18:44] <davidfetter> i.e. would parrot have some kind of extension for calling SPI?

[18:45] <ruoso> link to libparrot and call parrot bytecode...

[18:45] <davidfetter> would it be some kind of off-to-the-side VM like PL/J ?

[18:45] <davidfetter> does parrot have a "safe mode" the way perl does?

[18:45] <davidfetter> as in "can't open files or pipes?"

[18:45] <ruoso> if not, it certainly should...

[18:46] <leo> davidfetter: not yet

[18:46] <davidfetter> ok, so PL/ParrotU 1st, then

[18:50] <davidfetter> ruoso, when you say "link to libparrot," what do you mean?

[18:51] <ruoso> davidfetter, the same as link to libperl

[18:51] <davidfetter> hrm.

[18:51] <ruoso> libparrot provides an interface to the vm

[18:51] * davidfetter goes off to dig into just how PL/Perl(U) is done

[18:51] <ruoso> where you can execute code...

[19:07] *** dduncan joined
[19:29] <ingy> audreyt: I rewrote http://pyyaml.org/wiki/PerlTagScheme (please review and comment there)

[19:43] *** pmurias joined
[19:43] <pmurias> hi ruoso!

[19:43] <ruoso> hi

[19:44] *** elmex joined
[19:45] * ruoso fighting with latex2html

[19:53] <davidfetter> how about going through pdf 1st?

[19:54] <ruoso> davidfetter, it messes with footnotes

[19:55] <ruoso> and semantic information

[19:55] <ruoso> but I finally understood how to extend latex2html to support a new document syle

[19:55] <ruoso> s/syle/style/

[19:56] <ruoso> it's still not exactly as I wanted, but it's acceptable already...

[20:01] *** Quell joined
[20:02] <pmurias> davidfetter: any problems with the parrot part of the embbeding?

[20:03] *** ruoso joined
[20:03] * ruoso hates when he hits ctrl+alt+backspace by accident...

[20:07] <pmurias> i hit mostly caps-lock by accident

[20:08] <ruoso> the problem is that ctrl+alt+arrows switches desktops

[20:08] <ruoso> so if I press backspace too quickly after switching desktops I end killing the X server

[20:10] *** FB|afk is now known as FurnaceBoy

[20:12] <davidfetter> pmurias, i'm just not qulified to do any of it :/

[20:13] <davidfetter> pmurias, so i'm trolling for ppl who are at least qualified to figure out whether it's possible :)

[20:13] *** r0nny joined
[20:18] <Khisanth> ruoso: you could just disable that

[20:18] <pmurias> i'm not sure about the sql part, but the parrot embbeding part is not a big hassle

[20:19] <pmurias> what i failed to do for Parrot::Inline was to write the nessary typemaps

[20:24] <ruoso> Khisanth, I know... but eventually I need it...

[20:24] <pmurias> good night

[20:32] *** elmex joined
[20:41] *** amv joined
[20:47] *** obra_work is now known as obra

[21:08] <PerlJam> Wow.  I asked one year ago if the DBDI list was still alive and the answer was "yes, and we'll start producing something soonish" but there hasn't been any traffic since.

[21:10] <PerlJam> and when I asked it had been silent for about a year already.

[21:10] *** ajs_home joined
[21:11] *** shachaf joined
[21:13] *** elmex joined
[21:32] *** frederico joined
[21:32] <svnbot6> r10330 | Darren_Duncan++ | ext/Relation/ : added new Relation.pm methods extend() and map() ; other small changes

[21:36] *** weinig is now known as weinig|away

[22:19] *** larsen joined
[22:31] *** macroron joined
[22:51] *** avar joined
[22:57] *** chris2 joined
[23:11] <svnbot6> r10331 | Darren_Duncan++ | ext/Relation/ : removed method delete() and its alias delete_where() ; added new methods union(), exclusion(), intersection(), difference() and their aliases plus(), disjoint_union(), d_union(), symmetric_difference(), intersect(), minus(), except()

[23:25] *** shachaf joined
[23:32] *** Odin-LAP joined
[23:41] *** shachaf_ joined
[23:42] *** elmex joined
[23:46] *** SamB joined
