[00:03] <nothingmuch> hmm

[00:03] <nothingmuch> http://search.cpan.org/~ni-s/Tk-804.027/pod/X11Font.pod

[00:03] <lambdabot> Title: Tk::Font - a class for finding X Fonts - search.cpan.org, http://tinyurl.com/s5ags

[00:09] *** dj_goku joined
[00:22] *** vel joined
[00:25] <TimToady> audreyt, TreyHarris: I don't think any of those are an adequate looks_like_number.  What you've got is more like looks_like_number_in_canonical_form.

[00:25] <audreyt> true.

[00:26] *** sri__ joined
[00:30] <TimToady> if malformed numbers return undef but Num, (+$x).defined could be looks_like_number

[00:30] *** SubStack joined
[00:33] <audreyt> how is undef but Num different from ::Num

[00:33] <audreyt> can't seem to see a difference

[00:33] <audreyt> unless it's "fail"...

[00:33] <audreyt> but that seems to be overstrict

[00:33] *** jferrero joined
[00:34] <TimToady> I mean, if you have "123foo", you get Error("malformed number") but 123 or some such as an unthrown exception.

[00:34] <TimToady> and by the unification of errors and warnings we could make it continue working as Perl 5 does.

[00:36] <audreyt> so it's unthrown exception that can be handled

[00:36] <audreyt> but if you ignore it doesn't die

[00:36] <audreyt> but instead warns by printing to stderr

[00:36] <audreyt> is that it?

[00:36] <audreyt> (it makes a lot of sense, just making sure)

[00:36] <TimToady> it's an "unthrown warning", as it were.

[00:36] <audreyt> and warning is a kind of exception

[00:36] <audreyt> k

[00:38] <TimToady> main problem from a p6-on-p5 perspective is that it requires that you either have real continuations or at least run all your exception handlers before unwinding, neither of which is native to p5.

[00:40] <audreyt> though $SIG{__WARN__} comes close

[00:40] <audreyt> but yeah.

[00:40] <nothingmuch> what about that paper?

[00:40] <audreyt> (bbiab, $job)

[00:40] <audreyt> that paper is real continuations

[00:40] <audreyt> but userland level

[00:40] <audreyt> not kernel

[00:40] <nothingmuch> ah

[00:40] <nothingmuch> how does it do it, in 2 words?

[00:41] <audreyt> CPS reification.

[00:41] <Limbic_Region> . o O (scary magic)

[00:41] <obra> . o O  { Heavy Drugs }

[00:41] <audreyt> wrapping things in eval {} and convey all cont calls with die($cxt)

[00:41] <nothingmuch> *nod*

[00:41] <audreyt> s/things/each and every intermediate point/

[00:42] <audreyt> suppose that eval{} has zero overhead

[00:42] *** mako132_ joined
[00:42] <TimToady> hah

[00:42] <audreyt> then it's pay only if you use

[00:42] <audreyt> if it's constant overhead then it's constant slowdown

[00:42] <audreyt> if eval{eval{}} is more than 2x overhead than eval{}

[00:42] <nothingmuch> can the eval's be optimized away in certain situations?

[00:42] <audreyt> then the scheme is not useful

[00:43] <TimToady> the speed of light is a rather large constant...

[00:43] <audreyt> nothingmuch: sure, if all the subexps can't nvoke callcc

[00:43] <audreyt> then you can take away them

[00:43] <audreyt> TimToady++

[00:44] <TimToady> ...even when it's 1

[00:44] * nothingmuch prays that freetype will work this time

[00:44] <lumi> So you only need to keep the eval around anywhere that has callcc?

[00:44] <TimToady> like any warning?

[00:44] <TimToady> or potential warning?

[00:44] <lumi> Right, ow

[00:45] <nothingmuch> what about a lightweight version of eval via some hacky core API?

[00:48] <TimToady> you'd have to override longjmp somehow, or avoid calling it in all the places it's hardwired into perl.

[00:49] <nothingmuch> not setjmp?

[00:50] <TimToady> well, you'd want to avoid that on the other end too, but that part's easier.

[00:50] <TimToady> just don't use eval {...}

[00:50] * nothingmuch is out of his league and best stfu

[00:50] * nothingmuch also gives up on Imager and goes to sleep

[00:53] <Limbic_Region> sleep well

[00:53] <nothingmuch> ta

[00:54] <TimToady> --> zzz

[01:05] <TreyHarris> TimToady: yes, i was thinking about that and couldn't think how to resolve it.  i guess you do like perl 5 and hook the actual numification rather than trying to intuit what happened later.

[01:07] <TimToady> using the built-in routine is the safest approach.

[01:07] <TimToady> I learned not to try to second-guess the run-time in Perl 4...

[01:08] <TreyHarris> yes... but oh, wait... Scalar::Util::looks_like_number uses regexes.  how odd, i coulda sworn it wrapped the SV* -> I32 one in the perl guts...

[01:09] <TreyHarris> though... we *are* supposed to be doing TDD now, right?  so one could argue that this approach is more valid than the "go with whatever the implementation says it is" approach

[01:10] <TreyHarris> more portable between implementations, anyway

[01:10] <TimToady> depends on what it's for, I suppose

[01:12] <TreyHarris> right.  I supposed whatever it is, it should start "return 1 if $x.does(Num)"...

[01:14] <TreyHarris> er... "return Bool::True..."?  i've seen both in ext/ and t/, i don't know which if either is official style

[01:18] <TimToady> just "return True" should be adequate.  imported enums don't have to be qualified unless there's a collision.

[01:19] <TreyHarris> and if you use Political <:truth> and expect that to play well with boolean truth, you're asking for it anyway...

[01:19] <TimToady> on the other hand, 1 knows what to do in a boolean context.  :)

[01:20] <TimToady> the only real difference is what happens in string context.

[01:22] <TimToady> and that raises the question of how we convert "False" to Bool::False

[01:22] <TimToady> looks_like_boolean()  :)

[01:22] <TreyHarris> heh

[01:23] <TimToady> so does Bool($string) return a different value than ?$string does?

[01:23] <TreyHarris> "False" converts?  i missed that

[01:23] <TimToady> ?"False" would be true

[01:23] <lambdabot> Unknown command, try @list

[01:24] <TimToady> at least according to p5 semantics

[01:24] <TreyHarris> oh, i see, you're saying the Bool constructor might take words, but the coercer would not (or rather every word would be true)

[01:26] <TimToady> I guess we really haven't thought about the generic problem of converting the string names of enums back to enum values.

[01:26] <TimToady> eval "

[01:26] <TimToady> seems like overkill

[01:28] <TreyHarris> i honestly surprised that that even was in the cards.  conversion from strings, i mean.  maybe because enums haven't been in perl so i never considered how perlish enums would behave... i've never seen conversion in any other language that didn't have all values as strings

[01:28] <TimToady> but after declaring your DayOfWeek enum you'd like to be able to say DayOfWeek("Friday")

[01:28] <TreyHarris> *nod*

[01:29] <TimToady> or maybe it's a hash, so you can install abbreviations.

[01:29] <TreyHarris> *nod* seems vaguely like the problem of short/long CLI args

[01:29] <TimToady> actually, DayOfWeek:: is already a hash of names

[01:30] <TimToady> so it's just DayOfWeek::{$d} to get back at least to the subset type

[01:31] <TimToady> and I suppose the type numorstringifies to the appropriate value.

[01:32] <TreyHarris> yes.  but would sub next (DayOfWeek $d)... take next("Wednesday") as well as next(DayOfWeek("Wednesday"))?  is that what you mean by conversion?

[01:33] <TimToady> could autocoerce for numeric enums, but that doesn't work for stringy enums.

[01:33] <TimToady> since both values are strings.

[01:34] <TimToady> I just meant there needs to be an explicit way to convert

[01:34] <TreyHarris> eh?  seems backwards.  both values' containers are strings.  but one's a Str and one's a DayOfWeek

[01:34] <TimToady> when you know you have the external form rather than the internal

[01:35] <TimToady> true 'nuff, MMD would probably sort it out

[01:36] <TimToady> I am being assailed with dinner. &

[01:46] <beppu_> kill -9 $$

[01:59] *** markstos joined
[02:01] *** weinig|bbl is now known as weinig

[02:11] *** Aankhen`` joined
[02:16] *** frankg joined
[02:19] *** justatheory joined
[02:25] <svnbot6> r13575 | markstos++ | [misc/pX/README]

[02:25] <svnbot6> r13575 | markstos++ | provide a pointer to another useful README file to read.

[02:33] *** weinig is now known as weinig|bbl

[02:48] *** putter joined
[02:48] <svnbot6> r13576 | lanny++ | [ext/Math-Random-Kiss/.../Kiss.pm]

[02:48] <svnbot6> r13576 | lanny++ | - remove now extraneous code from when class did Iter

[02:48] <svnbot6> r13576 | lanny++ | [ext/Math-Random-Kiss/t/rand.t]

[02:48] <svnbot6> r13576 | lanny++ | - have plan agree with number of tests

[02:52] <putter> fglock: re out of sync :(   re will be nice :)

[02:57] *** frankg joined
[03:07] *** frederico joined
[03:27] <svnbot6> r13577 | malon++ | t/packages/scope.t - test temporization of variables from external packages

[03:38] *** ruz joined
[04:00] *** evalbot_r13572 is now known as evalbot_r13577

[04:37] *** jdv79 joined
[04:37] *** norageek joined
[04:40] <svnbot6> r13578 | putter++ | pX/README - Fleshed out a bit.  "Once upon a time...".

[04:47] *** mozzz joined
[04:55] <svnbot6> r13579 | putter++ | Moved content from pX/README to pX/Common/README, so everything is now in one place.  And updated it.

[05:04] <svnbot6> r13580 | putter++ | Common/design_space_sketch_Feb_11 moved Aside by author.

[05:04] <svnbot6> r13580 | putter++ | Why?  It's old.  Mainly of historical interest now.

[05:15] *** BooK joined
[05:15] <svnbot6> r13581 | putter++ | Common/parrot_pge_tests/ created.  It contains a copy of the parrot pge test suite.  It would be nice to plug this into ours with minimal changes, so we can piggy back on the parrot work.  Added this task to Common/Tasks.

[05:18] <audreyt> @tell putter why not simply update t/p6regex/ ?

[05:18] <lambdabot> Consider it noted.

[05:28] *** evalbot_r13577 is now known as evalbot_r13581

[05:33] *** putter joined
[05:33] <putter> hi audreyt

[05:33] <lambdabot> putter: You have 1 new message. '/msg lambdabot @messages' to read it.

[05:33] <svnbot6> r13582 | putter++ | backtrack_api.pl now resembles a minimalist backtracking api.

[05:33] <svnbot6> r13582 | putter++ | The next step is to explore PCR's Emitter and Runtime needs, and see whether/how this code might fit into them.

[05:33] <svnbot6> r13582 | putter++ | Perhaps it might also be worth making into a module.  Maybe.

[05:34] <audreyt> heya putter

[05:34] <audreyt> I've just been hacking GHC-head so it can compile Pugs again

[05:34] <audreyt> (ghci was broken yesterday)

[05:35] <audreyt> just fixed it, whew :)

[05:35] <putter> :)

[05:35] <putter> err, what is t/p6regex?  and why isn't it in t/rules?

[05:36] <audreyt> because rules is just one kind of regex

[05:36] <audreyt> :ratchet :sigspace

[05:36] <audreyt> the proper name is now p6re

[05:36] <audreyt> as in perl 6 regex

[05:37] <putter> hmm...

[05:37] <audreyt> "token" is just shorthand for ":ratchet regex"

[05:37] <audreyt> and "rule" is just shorthand for ":ratchet :sigspace regex"

[05:37] <audreyt> when you say

[05:37] <audreyt> 1 ~~ /1/

[05:37] <audreyt> you are matching against a Regex not a Rule

[05:37] <audreyt> in fact, there may not be a rule class anymore.

[05:38] * putter thinks it's finally time for him to sync with all this newfangled :) regexp stuff.

[05:38] <putter> let's see...

[05:38] <putter> sigspace?

[05:38] <gaal> you know you've been reading lots of haskell papers when... earlier someone says "(bbiab, $job)" and you try mentally to run :t on that

[05:38] <putter> lol

[05:39] <gaal> lanny: hey, maybe you can port the DIEHARD tests, the original is clunky c and possibly the result will look real good

[05:39] <gaal> (though run a bit slow...!)

[05:39] * putter reads about sigspace in Snn

[05:39] <gaal> audreyt: you hacked ghc to fix pugs? eep

[05:40] <audreyt> gaal: yeah, FC just landed

[05:40] <gaal> FissionatroomtemperatureCandidate?

[05:40] <audreyt> type-indexed types and closed classes and ML functors and all sort of cool things

[05:40] <audreyt> no, System F with Coersion

[05:40] <audreyt> the newAST of GHC that's been in the works for a year now

[05:41] <audreyt> obsoletes the previous "newtype" and GADT treatments

[05:41] <gaal> "You're an Int, admit it!"

[05:41] <audreyt> unified into a Cast node

[05:41] <audreyt> exactly

[05:41] <audreyt> but ghci's bytecode generator havn't caught up so I hacked it into place

[05:42] <audreyt> it's really ~ the same thing as pugs :)

[05:42] <gaal> isn't it a bit late to introduce things into ghci now that the release candidate is out?

[05:42] <gaal> s/i//

[05:42] <audreyt> oh, this is -head

[05:42] <audreyt> 6.6 branched a while ago

[05:42] <gaal> oh, 6.7 to be?

[05:42] <audreyt> 6.6 won't have FC stuff.

[05:42] <audreyt> not sure, maybe 6.6.1

[05:42] <gaal> *nod

[05:43] <gaal> well it'll be 6.7 before 6.6.1? :)

[05:43] <audreyt> or maybe 6.7 :)

[05:43] <audreyt> hah

[05:43] <putter> sigspace, fine, it's a separate topic.  token, whatever.  ratchet...

[05:44] <putter> so, big picture.  where do we stand on the old concept of rule/regexp unification with methods?

[05:45] <audreyt> regexes are just specially-constructed Code that can match stuff

[05:45] <audreyt> if you give it a name then it can be installed into grammar as methods

[05:45] <putter> how can one give it a name?

[05:46] <audreyt> regex name { ... }

[05:47] <audreyt> however, it's not currently clear whether by virtue of having a name it suddenly became methods

[05:47] <audreyt> or if it's actually all subs and grammar use mixin rather than inheritance.

[05:47] <putter> ah...

[05:47] <gaal> what's the invocant?

[05:48] <putter> so what was  rule foo {...}  was simple renamed regexp foo {...}, and the current rule foo is simply regexp foo :blah :blah {...}?

[05:48] <audreyt> gaal: either the class itself, or nothing at all.

[05:48] <audreyt> pmichaud and allisn was discussing this in the context of PGE

[05:49] <audreyt> but the current encoding in parrot, namely that  Match inherits from Grammar

[05:49] <audreyt> er sorry

[05:49] <audreyt> Grammar inherits from Match

[05:49] <putter> (which always seemed quite odd)

[05:50] <audreyt> just so that they can be used as invocant, didn't quite make sense to me

[05:50] <audreyt> I think I'd prefer a strict sub/mixin model, honestly

[05:50] <audreyt> as is currently adopted by PCR

[05:51] <audreyt> (S05 is silent on the concrete encoding)

[05:52] <putter> so the old  rule foo {}  still exists, simply renamed to  regexp foo {} ?  yes?

[05:53] <audreyt> no

[05:53] <audreyt> regex foo {}

[05:53] <audreyt> means a named regex foo

[05:53] <audreyt> rule foo {}

[05:53] <audreyt> means simply

[05:53] <audreyt> regex foo :sigspace {... }

[05:53] <audreyt> token foo {}

[05:53] <audreyt> means simply

[05:53] <audreyt> regex foo :ratchet {...}

[05:53] <audreyt> oops, sorry, rule means

[05:54] <audreyt> :sigspace :ratchet

[05:54] <audreyt> to recap: Regex is the base form

[05:54] <audreyt> rule is just shorthand for :sigspace :ratchet

[05:54] <audreyt> token is just shorthand for :ratchet

[05:54] <putter> so the old, pre-ratchet rule foo {} is now  regexp foo :sigspace {} ?  yes?

[05:55] <audreyt> no.

[05:55] <audreyt> it's "regex" not "regexp"

[05:55] <putter> sigh

[05:55] <putter> oh, that's fine

[05:55] <putter> so the old, pre-ratchet rule foo {} is now  regex foo :sigspace {} ?  yes?

[05:55] <audreyt> correct.

[05:56] * putter exhales a sigh of relief

[05:56] <audreyt> glad to be of help

[05:56] <putter> :)

[05:56] <putter> my thanks

[05:56] <putter> was afraid backtrack-phobia was taking over the world ;)

[05:57] <audreyt> :D

[05:57] <audreyt> food, bbiab

[05:57] <putter> later

[05:58] <putter> re encoding, as long as one can ask regexs for their pattern, encoding, grammar and lexical context, I'm all set.

[05:59] <putter> hmm.... does p6 *have* first class lexical contexts?  can one get a handle to a pad, and pass it around?

[06:00] <putter> s/pattern, encoding/pattern, modifiers/

[06:01] <audreyt> ::MY may or may not be first class.

[06:01] <audreyt> again, unspecced

[06:01] <putter> k

[06:02] <putter> hmm, so  t/rules/ should be renamed t/regex/, and t/p6regex/ moved into it, no?

[06:02] <audreyt> yes

[06:02] <putter> k

[06:02] <audreyt> the p6regex name was preserved

[06:02] <audreyt> because on parrot side it's called that

[06:03] <audreyt> which also has a p5regex/

[06:03] * putter wc's t/p6regex/regex_tests and wonders where the other 400 tests went...

[06:03] <audreyt> it's an old copy...

[06:03] <putter> ahh.... thus your earlier suggestion

[06:03] <putter> (ahh was re parrot origin)

[06:05] <TimToady> MY is as first class as any other package, but is considered immutable once its scope is compiled.

[06:07] <putter> :)

[06:07] * putter tries to figure out where the pugs-side version of re_tests (transliterated into p6) went to...

[06:12] <putter> ah, deleted 26 Aug 2006, under the name t/rules/rules.t

[06:21] <audreyt> TimToady: the thing is whether you can pass it out

[06:21] <audreyt> f(MY)

[06:21] <audreyt> and expect it to continue to refer to the pad

[06:21] <TimToady> the package name is really MY::

[06:21] <audreyt> on the caller's site

[06:21] <audreyt> MY:: then.

[06:21] <TimToady> why not?

[06:22] <audreyt> there's no reason not to :)

[06:22] <audreyt> so the full name is ::MY::

[06:22] <TimToady> seems to me that's part of why we flattened the namespaces to not have here-to-end scopes for the lexicals, among other things.

[06:22] <audreyt> agreed.

[06:22] <TimToady> You don't really need an initial :: if there's one elsewhere in the name in most places.

[06:23] <audreyt> nodnod

[06:23] <TimToady> on the other hand, I've been struggling to keep :: free as a postfix so we can have $proto.:: and get the corresponding package for the prototype

[06:24] <TimToady> that's also why we require GLOBAL::<$foo> and not just GLOBAL<$foo>

[06:24] <TimToady> the latter would be trying to subscript the type rather than the package.

[06:24] <audreyt> well the spec still says .:: can fallback to ::()

[06:25] <TimToady> no it doesn't, I don't think.  it has to be .'::'

[06:25] <audreyt> though as Juerd points out it's rather dangerous a device to rely on

[06:25] <audreyt> you fixed the spec?

[06:25] <TimToady> I fixed that already.

[06:25] <TimToady> several days ago

[06:25] <audreyt> then S02:2303

[06:25] <audreyt> needs updating as well

[06:27] <TimToady> done

[06:27] <audreyt> danke

[06:29] <gaal> audreyt: shouldn't ValNative hold unboxed haskell types?

[06:29] <gaal> type NativeUint     = Word# etc.?

[06:29] <audreyt> gaal: no, just put !strict annotation

[06:29] <audreyt> and -funboxed-stirct-fields will take care of that.

[06:29] <gaal> ah

[06:29] *** redear joined
[06:29] <TimToady> the most interesting part of that fix is that it now allows ."foo$bar" kinds of method calls.

[06:30] <TimToady> and a way to disambiguate .+ things from .'+' things and the like.

[06:30] <audreyt> should .prefix:<moose> always succeed

[06:30] <TimToady> .+foo vs .'+foo'

[06:30] <audreyt> whenever .moose succeed?

[06:31] <TimToady> that's kind of ambiguous with .prefix: <moose>

[06:31] <audreyt> try again... should &prefix:<moose> resolve to the same thing as &moose?

[06:31] <TimToady> unless the syntactic categories have special keywordish status in that location.

[06:32] <TimToady> I think so.

[06:32] <audreyt> but it's a fallthru, right?

[06:32] <audreyt> sub moose ($x, $y) {}

[06:32] <audreyt> doesn't grant moose a prefixop status

[06:32] <audreyt> it's listop

[06:32] <audreyt> but wait, prefix:<moose> can be listop as well, nvm.

[06:32] <TimToady> I don't think listop is a grammatical category

[06:33] <audreyt> can a sym, say prefix:<`> be listop?

[06:33] <audreyt> sub prefix:<`> (*@) {}; ` 1, 2, 3;

[06:33] <TimToady> yes, though the official listops are supposed to have a space after them--not sure exactly what decides to enforce that.

[06:34] <TimToady> probably an equiv to an existing listop.

[06:34] <TimToady> or maybe the *@ implies that, I dunno.

[06:35] *** iblechbot joined
[06:41] <TimToady> okay, the *@ now forces listop precedence by default.

[06:41] <audreyt> cool!

[06:46] <svnbot6> r13583 | putter++ | Common/parrot_pge_tests/README - clarified the task.

[06:46] <svnbot6> r13583 | putter++ | Namely, changing our p6regex/regex_tests from hand edited to easily synced.

[06:46] <svnbot6> r13583 | putter++ | And importing one or two of the other compatible test files.  Volunteers?

[06:46] <svnbot6> r13583 | putter++ | audreyt++

[06:47] <redear> am i going to be labelled a troll if i ask "are we there yet?" in this channel?

[06:47] <TimToady> no, you'll be asked if you would like a commit bit.

[06:48] <TimToady> would you like a commit bit?

[06:48] <redear> is perl6 still in development?

[06:48] <TimToady> we're still having fun with it.

[06:48] <redear> cool

[06:48] <redear> can't wait man

[06:48] <TimToady> impatience is a virtue...

[06:50] <TimToady> pugs is a lot of fun if you'd like to play with it.  we're about to put out a new release in the next few days.

[06:50] <svnbot6> r13584 | putter++ | t/rules renamed t/regex in accordance with current spec nomenclature.

[06:53] <svnbot6> r13585 | putter++ | t/p6regex/README - Created a README.

[06:55] <putter> 3am.  end of day.

[06:55] <svnbot6> r13586 | putter++ | t/p6regex moved to t/regex/p6regex

[07:02] <putter> g'night &

[07:02] <TimToady> night!

[07:15] *** baest joined
[07:16] *** mdiep_ joined
[07:38] * TreyHarris does the *very* happy dance

[07:39] <TreyHarris> audreyt: 10 minutes to make from scratch, <14 to smoke!!

[07:39] <audreyt> excellent!

[07:39] <audreyt> with parallel2?

[07:40] <TreyHarris> much better than 2 hours to make and 4.5 to smoke

[07:40] <TreyHarris> parallel2?

[07:40] <TreyHarris> smoke_concurrent: 3

[07:40] <TreyHarris> what's parallel2?

[07:41] <TreyHarris> your 20060608 intel build worked like a dream, btw :-)

[07:46] <audreyt> I mean concurrent2

[07:46] <audreyt> TimToady: this seems bogus

[07:46] <audreyt>     my @args = \@foo, @bar;

[07:46] <audreyt>     push |@args;

[07:46] <audreyt> spec says it's same as

[07:46] <audreyt> push(scalar @foo, @bar)

[07:47] <audreyt> and says it's same as

[07:47] <audreyt>     push [,] @args;

[07:47] <audreyt> however, with Pugs's newAST, the latter is

[07:47] <audreyt> push [,] @args

[07:47] <audreyt> ===>

[07:48] <audreyt> push [,] \(@foo :), \(: @bar)

[07:48] <audreyt> ===>

[07:48] <audreyt> push @foo: @bar;

[07:48] <TreyHarris> audreyt: i don't know about concurrent2...

[07:48] <audreyt> ===>

[07:48] <audreyt> @foo.push(@bar)

[07:48] <lambdabot> Unknown command, try @list

[07:48] <audreyt> TreyHarris: smoke_concurrent: 2

[07:48] <audreyt> whilst the former is

[07:48] <audreyt> push | @args;

[07:48] <audreyt> ===>

[07:49] <audreyt> # oops, persume that @bar contains one value 'bar'

[07:49] <TreyHarris> audreyt: ah... yes, i have it at 3, but was about to svn up so i'll see if 2 works better or not

[07:49] <audreyt> # and replace the @bar on the [,] cases above with 'bar'

[07:49] <audreyt> push |( [\(@foo :), \(: 'bar')] );

[07:50] <audreyt> ===>

[07:50] <audreyt> er, sorry, the last line is

[07:50] <audreyt> push |(  [\(@foo :), 'bar'] )

[07:50] <audreyt> ===>

[07:50] <audreyt> push(\@foo, 'bar')

[07:50] <audreyt> i.e. both ends up becoming positional

[07:51] <audreyt> as contrary to [,] which takes and concats multiple captures

[07:51] <audreyt> I guess my presumption was that

[07:51] <audreyt> |@foo # always yields only positionals

[07:51] <audreyt> |%bar # always yields only anmeds

[07:51] <audreyt> instead of flattening them first

[07:51] <audreyt> is that incorrect?

[07:51] <audreyt> basically, I'd like

[07:51] <audreyt> $x = @foo;

[07:52] <audreyt> f(|$x)

[07:52] <audreyt> f(|@foo)

[07:52] <audreyt> behave the same

[07:52] <audreyt> instead of exploding @foo one more time to find out individual element's captureness

[07:52] <audreyt> but not do the same with $x

[07:53] <TimToady> sounds sane, to the extent that I can detect sanity at this time of night...

[07:55] <audreyt> k

[07:55] <audreyt> basically

[07:55] <audreyt> [,]@foo

[07:55] <audreyt> first flattens and then takes elements as captures

[07:55] <audreyt> but

[07:55] <audreyt> |@foo

[07:55] <audreyt> dircetly exposes elements into positionals

[07:55] <audreyt> as consistent with usual listop vs unary semantics

[07:55] <TimToady> feel free to whack on the syn

[07:56] <audreyt> k :) sleep well

[07:56] <TimToady> zzz &

[08:05] <audreyt> done as r12346

[08:09] *** ofer0 joined
[08:54] <gaal> audreyt: remember the unsafeCoerce crash to which the fix was to coerce via a W# constructor?

[08:54] <gaal> how does that sit with the automatic unboxing?

[08:54] <gaal> ah, we didn't have the optimization flag turned on

[09:09] <nothingmuch> *yawn*

[09:09] <nothingmuch> sorry, overslept

[09:09] <nothingmuch> well, technically not, i only got 6 hrs

[09:09] <nothingmuch> but... =P

[09:09] <nothingmuch> overstayeduplastnight

[09:09] <nothingmuch> anyway, /me gets to that refactoring, and then I have like 2 hrs of work

[09:09] <nothingmuch> and then i have to go

[09:09] <gaal> I like one-word oxymorons. "oversleep"'s my favorite.

[09:10] <nothingmuch> why is that an oxymoron?

[09:10] <gaal> how can you sleep too much?

[09:10] <nothingmuch> most people i know will feel terrible after more than 8-9 hours of sleep

[09:10] <gaal> nothing a nap can't fix

[09:10] <nothingmuch> heh

[09:11] <nothingmuch> audreyt: does that schedule sound good?

[09:14] * Juerd often overslept, and now uses an alarmclock

[09:14] <Juerd> Indeed you can sleep too much. I feel much better now that I sleep less.

[09:14] * nothingmuch 's alarm clock died and consequently he has not been oversleeping anymore

[09:15] <nothingmuch> before I used to set it to a high volume and the right amount of sleep

[09:15] <nothingmuch> and then whenever it'd go off my body would go into an extra deep sleep for another hour or so

[09:15] <gaal> whoa the typechecker is weirding me out

[09:16] <gaal> Pugs.Val:63, castVal

[09:16] <gaal> I want it to also work with ValNatives and ValUndefs

[09:16] <gaal> but it wont.

[09:17] <TreyHarris> is svn.openfoundry.org down?

[09:17] <gaal> looks it

[09:18] <ayrnieu> isindown.org can also answer such questions.

[09:18] <ayrnieu> sorry: isitdown.org

[09:19] <TreyHarris> ayrnieu: it appears to be down as well :-)

[09:20] <gaal> bbiab&

[09:29] *** ludan joined
[09:35] <nothingmuch> audreyt: okay, i'm ready

[09:36] *** zeriod joined
[09:36] *** zeriod left
[09:36] *** zeriod joined
[09:42] <nothingmuch> audreyt: ping when ready

[09:44] <nothingmuch> brb

[09:52] *** chris2 joined
[09:56] *** marmic joined
[09:56] *** krunen joined
[09:59] *** marmic joined
[10:18] *** rodi joined
[10:25] <nothingmuch> audreyt: i have to leave shortly

[10:26] <nothingmuch> == ~ 1 hr

[10:58] *** buetow joined
[11:03] *** foo\ joined
[11:13] *** awwaiid_ joined
[11:16] <ruz> I think 'say "woot" if -r !-f -e "/tmp"' or 'say "woot" if -r -!f -e "/tmp"' sounds like good idea

[11:19] <TreyHarris> ruz: eh?  you should be able to do the first

[11:19] <TreyHarris> not yet

[11:19] <TreyHarris> but eventually

[11:19] <ruz> yep, not yet

[11:20] <TreyHarris> assuming ! flips the boolean rather than returning its opposite

[11:20] <TreyHarris> otherwise you'd be -r'ing Bool::True or Bool::False, which would be problematic

[11:22] <ruz> as I understand from syns -X returns boolean with stats buf, ! should touch only boolean part and leave stats there

[11:23] <ruz> S03 should be updated :)

[11:23] <TreyHarris> in other words, sub prefix:<!> (Bool $p) needs to be defined { $p ?? $p but False !! $p but True }, not { $p ?? False !! True }

[11:28] <ruz> "$p but False" what's that?

[11:31] <ayrnieu> ?eval "hello" if (1 but False)

[11:31] *** evalbot_r13581 is now known as evalbot_r13586

[11:31] <evalbot_r13586> Error: Cannot cast from VBool False to Pugs.AST.Internals.VCode (VCode)

[11:31] <ayrnieu> ?eval "hello" if (0 but True)

[11:31] <evalbot_r13586> Error: Cannot cast from VBool True to Pugs.AST.Internals.VCode (VCode)

[11:31] <ayrnieu> there you go!

[11:34] <TreyHarris> but enum isn't working yet

[11:34] <TreyHarris> but mixes in to its LHS some behavior from its RHS at runtime

[11:35] <nothingmuch> @tell audreyt i'm off hiking, but i spent this time writing MO::Overview

[11:35] <lambdabot> Consider it noted.

[11:35] * TreyHarris sleeps &

[11:36] <nothingmuch> cia

[11:36] <nothingmuch> o

[11:36] <nothingmuch> sleep well =)

[11:39] *** xinming joined
[11:42] <ruz> ?eval "abc" ~< 1

[11:42] <evalbot_r13586> "ÃÃÃ"

[11:48] *** elmex joined
[12:00] *** iblechbot joined
[12:05] <audreyt> nothingmuch: hihi

[12:05] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:05] <audreyt> lambdabot: @messages

[12:05] <lambdabot> nothingmuch said 30m 2s ago: i'm off hiking, but i spent this time writing MO::Overview

[12:06] <audreyt> oy. I overslept and missed nothingmuch

[12:06] * audreyt sleeps some more to compensate

[12:22] <gaal> @tell audreyt today's existential dilemma: how to complete castVal for ValUndef and ValNative?

[12:22] <lambdabot> Consider it noted.

[12:49] *** DaGo joined
[12:53] <lumi> Hi gaal

[13:02] *** kanru joined
[13:11] <audreyt> gaal:

[13:11] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:11] <audreyt> castVal (VUndef v)  = fromTypeable v

[13:11] <audreyt> castVal (VNative v) = fromTypeable v

[13:12] <audreyt> lambdabot: @message

[13:12] <lambdabot> Maybe you meant: messages messages?

[13:12] <audreyt> lambdabot: @messages

[13:12] <lambdabot> gaal said 49m 15s ago: today's existential dilemma: how to complete castVal for ValUndef and ValNative?

[13:13] * SamB is glad lambdabot doesn't just assume you meant @messages because that is closer

[13:14] <ayrnieu> aye, or one day you'll want to roll some dice and it will instead send ninjas after you.

[13:14] <SamB> hah

[13:21] *** integral_ joined
[13:22] *** integral_ is now known as integral

[13:26] *** crem joined
[13:38] *** kisu joined
[13:45] *** kanru joined
[13:46] *** ron__ joined
[13:46] *** prism joined
[14:01] * kolibrie is frustrated that his wireless card is acting up and he can't get a connection long enough to get an IP

[14:05] <kolibrie> @tell fglock I'm having problems getting my laptop on wireless, but I can check in on another computer from time to time

[14:05] <lambdabot> Consider it noted.

[14:08] <kolibrie> I'm not sure why the [ <!before <?presenter> > . ]* is necessary in http://sial.org/pbot/19887, but it is

[14:08] <lambdabot> Title: Paste #19887 from "fglock" at 200.17.89.34

[14:08] <kolibrie> can anyone enlighten me?

[14:14] *** mako132_ joined
[14:18] *** jferrero joined
[14:24] <gaal> lambdabot: massages!

[14:25] <kolibrie> gaal: rescue me!

[14:25] <gaal> moose?

[14:26] <kolibrie> I'm in Pittsburgh and my wifi isn't working and I'm speaking an 4 1/2 hours and I don't have my slides finished

[14:26] <gaal> how can I help?

[14:26] <kolibrie> who knows

[14:26] <audreyt> what are you going to speak about?

[14:27] <kolibrie> http://feather.perl6.nl/~kolibrie/extraction.xul

[14:27] <lambdabot> http://tinyurl.com/rxtmp

[14:28] <kolibrie> fglock pasted me this: http://sial.org/pbot/19887, but I do not understand why the [ <!before <?presenter> > . ]* is necessary

[14:30] <audreyt> because without which :c couldn't work

[14:30] <audreyt> and you need to :g instead

[14:30] <kolibrie> oh, and :g is not yet implemented

[14:30] *** Limbic_Region joined
[14:30] <kolibrie> I think

[14:31] <gaal> kolibrie: if you have a screenshot of the schedule, it's worth throwing in

[14:31] <audreyt> :g is not?

[14:31] <gaal> before showing either the extraction code or the data you extracted

[14:31] <audreyt> me surprised

[14:31] <audreyt> ?eval "xxx" ~~ m:g/(.)/

[14:31] <evalbot_r13586> 3

[14:32] <audreyt> ?eval list("xxx" ~~ m:g/(.)/)

[14:32] <evalbot_r13586> (Match.new(   ok => Bool::True,    from => 0,    to => 1,    str => "x",    sub_pos => (),    sub_named => {} ), Match.new(   ok => Bool::True,    from => 0,    to => 1,    str => "x",    sub_pos => (),    sub_named => {} ), Match.new(   ok => Bool::True,    from => 0,    to => 1,    str => "x",    sub_pos => (),    sub_named => {} ))

[14:32] <audreyt> looks like it's implemented just fine

[14:32] <gaal> audreyt: that works, but I don't understand why generics code is required

[14:32] <audreyt> it was broken on the first days of PCR integration

[14:32] <audreyt> but I fixed it a couple days ago

[14:32] <audreyt> gaal: generic code?

[14:32] *** penk joined
[14:32] <gaal> fromTypeable

[14:33] <audreyt> you mean you should be able to gmap it?

[14:33] <gaal> kolibrie: probably easier than a real screenshot, have another browser window with the schedule in it

[14:33] <gaal> kolibrie: that way people "see" your topic instantly

[14:33] <kolibrie> gaal: if I can get on the internet...

[14:33] <gaal> audreyt: I don't understand why the simple patmatch doesn't work

[14:34] <gaal> kolibrie: I'll try to fetch it for you

[14:34] <audreyt> what were the simple patmatch?

[14:34] <gaal> kolibrie: (how are you on irc?)

[14:34] <gaal> --castVal (VUndef v)  = return v

[14:34] <kolibrie> audreyt: when I switch the :c to :g in that paste, it says 'got: brian' repeatedly

[14:35] <audreyt> gaal: how can ValUndef be a ?

[14:35] <audreyt> be of type a

[14:35] <audreyt> kolibrie: maybe you want for not while

[14:35] <audreyt> for $content ~~ m:g/<talk>/ { say $$_ }

[14:35] <audreyt> for I hope obvious reasons :)

[14:36] <gaal> kolibrie: can I nopaste the html?

[14:37] <kolibrie> audreyt: I only get one brian with for $content ~~ m:g/<talk>/ { say $$_ }

[14:37] <audreyt> grammar Workshop;

[14:37] <gaal> kolibrie: or should I email?

[14:38] <obra> has anyone ever done a pseudo-bnf for p5?

[14:38] <gaal> audreyt: I don't see why ValNative can't be type a (under Typeable typeclass even)

[14:38] <kolibrie> gaal: I have the source, and on this computer (someone elses) I have internet, but on my laptop I have no wifi working

[14:38] <gaal> too bad I can't send you a cross cable :(

[14:39] <audreyt> gaal: you didn't Typeable.cast it

[14:39] <audreyt> how can it be of type a?

[14:39] <kolibrie> gaal: we just need a really long one

[14:39] <audreyt> "of type a " means "can be of any time"

[14:39] <audreyt> *type

[14:39] <audreyt> kolibrie: are you runnign with pugs or v6.pm?

[14:39] <gaal> audreyt: *why* does it need to be T.casted? it's a simple field

[14:39] <gaal> data Val = VUndef  !ValUndef   | funky stuff

[14:39] <audreyt> castVal :: (Monad m, Typeable a) => Val -> m a

[14:40] *** kanru joined
[14:40] <gaal> well?

[14:40] <kolibrie> audreyt: v6.pm at the moment

[14:40] <audreyt> and say you have castVal :: Val -> Maybe ()

[14:40] <audreyt> which patmatch into

[14:40] <audreyt> something :: ValUndef -> Maybe ()

[14:40] <audreyt> and you are saying

[14:40] <audreyt> something x = return x

[14:40] <audreyt> would work

[14:40] <audreyt> but it patently cannot

[14:41] <audreyt> as it'd be ValUndef -> Maybe ValUndef

[14:41] <audreyt> but here we want ValUndef -> Maybe ()

[14:41] <kolibrie> audreyt: pugs actually gives me *** Cannot parse regex: <talk>

[14:41] <audreyt> kolibrie: I saw that. fixing

[14:42] * kolibrie hopes he can pull sometime

[14:42] <audreyt> well at least svn is back

[14:43] <gaal> audreyt: I still don't understand. :(

[14:43] * clkao wonders if we should setup something to use commitbit to host pugs 

[14:43] <audreyt> clkao: on svn.perl.org

[14:43] <clkao> ;)

[14:43] <audreyt> yes, please

[14:43] <audreyt> gaal: ok... what we want is

[14:44] <audreyt> castVal :: (Monad m, Typeable a) => Val -> m a

[14:44] <gaal> in the othe cases, say VPure, we're returning some Pure

[14:44] <gaal> yup

[14:44] <audreyt> we are not; we are Typeable.cast'ing something Pure

[14:44] <audreyt> the "m a" there means whatever m and a we choose

[14:44] <kolibrie> audreyt: gaal: what is the best way to turn the output into the yaml structure on slide 22?

[14:44] <audreyt> this function needs to work

[14:44] <gaal> which means we can result in anything we like, as long as it's in some monad and the held type is Typeable

[14:44] <audreyt> that is not so

[14:45] <audreyt> you described existential

[14:45] <audreyt> but this is universal

[14:45] <audreyt> it means

[14:45] <audreyt> "we must result in anything the caller likes"

[14:45] <audreyt> as long as it's in some monad and the held type is Typeable

[14:45] <audreyt> look at the full sig

[14:45] <gaal> kolibrie: it's yaml already, but a list of pairs not a map

[14:45] <audreyt> castVal:: forall m a. Monad m, Typeable a => Val -> m a

[14:45] <audreyt> the "forall" is on the left

[14:46] <audreyt> which means it must work whatever the caller choose to instantiate with

[14:46] *** awwaiid joined
[14:46] <kolibrie> fglock added a yaml method to v6, but I need to extract just the pieces from the match that I want

[14:46] *** mako132_ joined
[14:47] <gaal> kolibrie: sorry, which structure? if you have a list of pairs, .yaml

[14:47] <audreyt> gaal: the way you described is more like

[14:48] <audreyt> castVal :: Val -> (exists m a. Monad m, Typeable a => m a)

[14:48] <audreyt> but that is not the case here

[14:48] <kolibrie> gaal: I have a match object, and I want a structure I can turn into yaml

[14:48] <audreyt> so you can't simply return anything tyepable

[14:48] <gaal> ?eval [{name=>"moose", talk =>"lalala"}, {name =>"elk", talk=> "whee"}].yaml

[14:48] <evalbot_r13586> "--- \n- \n  ? name\n  : moose\n\n  ? talk\n  : lalala\n\n- \n  ? name\n  : elk\n\n  ? talk\n  : whee\n\n"

[14:48] <audreyt> you must return something that can satisfy all typeable

[14:49] <gaal> kolibrie: this dump is in a weird yaml form, but it is equivalent to what you want.

[14:49] <gaal> audreyt: oof, I still don't understand higher-rank polymorphism. :(

[14:49] <kolibrie> gaal: I may be able to { return $rulename => $<rulename>() }

[14:50] <kolibrie> gaal: a presenter is part of a talk, because I need to add other items too, like title and time

[14:50] <gaal> hm, castVal are unsafe right? (p :: Pure) <- castVal $ val $ VMut ... will die horribly

[14:51] <audreyt> p :: PureInt?

[14:51] <gaal> yeah

[14:51] <audreyt> well, it's not unsafe

[14:51] <gaal> at runtime

[14:51] <audreyt> that's the "m" part

[14:51] <audreyt> it will invoke the monadic fail

[14:51] <gaal> oh

[14:51] <audreyt> this is the MaybeToMonad pattern

[14:52] <audreyt> instead of returning (Maybe a)

[14:52] <audreyt> make it workable in any Monad m => m a

[14:52] <gaal> ah, because we don't have fromJust in fromTypeable

[14:53] <gaal> kolibrie: okay, what does your data look like in p6?

[14:53] <gaal> I'm not actually very familiar with Rules!

[14:54] <gaal> audreyt: okay, thanks. that makes castVal look a little funny though

[14:54] <Limbic_Region> salutations all

[14:54] <gaal> since all its rhs are the same.

[14:54] <gaal> making me think of _'ing the constructor!

[14:54] <audreyt> that's what gmap do.

[14:55] <gaal> which prolly doesn't work

[14:55] <gaal> ooh, right

[14:55] <audreyt> castVal = gmap fromTyepable

[14:55] <audreyt> would work if we derive data

[14:55] <kolibrie> gaal: my $structure = ( talk => { presenter => 'brian', title => '...' })

[14:55] <gaal> kolibrie: okay, and doesn't .yaml that dwim?

[14:56] <kolibrie> gaal: yes.  the problem is getting that datastructure from the match

[14:59] <kolibrie> gaal: and when I try to use a { return } block in my token, it doesn't seem to affect what is returned from the match

[14:59] <kolibrie> so I think I'm doing something wrong there, because I'm pretty sure that works

[15:00] <gaal> audreyt: which gmap variant is needed? neither gmapT nor gmapM work

[15:00] <gaal> @hoogle gmap

[15:00] <lambdabot> Data.Graph.Inductive.Graph.gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d

[15:00] <lambdabot> Data.Generics.Basics.gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a

[15:00] <lambdabot> Data.Generics.Basics.gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a

[15:03] <audreyt> gmapQi 0

[15:03] <audreyt> or something like that

[15:05] <gaal> oi. No instance for (Data Val).... 6.6 needed IIRC :(

[15:06] <Limbic_Region> Win32 is approaching 96% success on make smoke

[15:14] *** nox_ghost joined
[15:14] *** nox_ghost is now known as ofer1

[15:16] <kolibrie> gaal: I got it!  I just needed to add {} around my return value: { return { talk => $<presenter } }

[15:16] <gaal> yay

[15:16] <kolibrie> though if I have other things I am matching, like 'title' how does that work?

[15:19] *** mako132_ joined
[15:19] <gaal> each rule returns a more and more comlete object

[15:20] <gaal> the talk rule icludes the title rule, right?

[15:21] <gaal> so rule talk { ......<title>.... {return { talk => {$<presenter>, $<title>} } }

[15:22] *** mako132_ joined
[15:22] <kolibrie> gaal: ah, yes, thank you for helping me see clearly

[15:22] <kolibrie> unless the extra {} are going to do something weird

[15:23] <gaal> heh, I hope it actually works, I suspect at this point I get parsec better than rules

[15:23] <audreyt> talk => {:$<presenter>, :$<table>}

[15:23] <audreyt> talk => {:$<presenter>, :$<title>}

[15:23] <audreyt> is morelikeit

[15:23] <kolibrie> audreyt: what is the :

[15:23] <audreyt> :$x means

[15:23] <audreyt> x => $x

[15:23] <audreyt> :$<x> means

[15:23] <audreyt> x => $<x>

[15:24] <audreyt> magick shorthand

[15:24] <gaal> golf!

[15:24] <kolibrie> I was adding the token name in each tokens return block

[15:25] <kolibrie> { return { presenter => $$/ } }

[15:25] <gaal> brb

[15:25] <kolibrie> { return { talk => $<presenter>() } }

[15:26] <audreyt> also I'm not sure what

[15:26] <audreyt> $<presenter>()

[15:26] <audreyt> does

[15:26] <audreyt> it sholud be

[15:26] <audreyt> $$<presenter>

[15:26] <audreyt> (it was croaking in pugs because of the .())

[15:27] <kolibrie> audreyt: $$<presenter> croaks in v6

[15:27] <audreyt> that's sad...

[15:27] <audreyt> @tell fglock can we make $$<foo> work in {} block? $<foo>() is really nonspec nowadays...

[15:27] <lambdabot> Consider it noted.

[15:28] <kolibrie> he maybe got it from: $() is a shorthand for $($/)

[15:28] <kolibrie> audreyt: so I should change my slides to use $$<foo>?

[15:29] <audreyt> yes, I think so

[15:29] <audreyt> no, it was $/() in israel I think

[15:29] <audreyt> but by tokyo it's $$/

[15:30] <audreyt> and the Great Capture Unification follows from that

[15:32] <kolibrie> audreyt: and is it better practice to keep the name with the the token in the return (token presenter { { return { presenter => $$/ } } } ), or from above (token talk { <presenter> { return :$<presenter> } } )

[15:33] <audreyt> I think latter works better but it's largely style

[15:33] <audreyt> however I still don't know why you are returning things this way

[15:33] <audreyt> I mean

[15:33] <audreyt> token talk { <presenter> <title>

[15:33] <audreyt> }

[15:33] <audreyt> should be sufficient, no?

[15:33] <audreyt> you can use them exactly the same way

[15:34] <kolibrie> I want to be able to generate a structure that I can turn into XML, YAML, $some_other_format

[15:34] <kolibrie> I'm not sure the best place to do that

[15:34] <audreyt> you want a plain hash not a match

[15:34] <audreyt> is that so?

[15:35] <kolibrie> yes

[15:35] <kolibrie> but I don't mind getting a match first and generating a hash, if that is better

[15:35] <audreyt> I think it's a bit easier...

[15:35] <kolibrie> sample syntax?

[15:36] * kolibrie really wants to keep the grammar unpoluted

[15:37] <audreyt> hash($match.kv.map(-> $k, $v { $k => ~$v }))

[15:38] <audreyt> which only retians the string value for each of the keys

[15:38] <audreyt> however I'm not sure v6 supports that yet

[15:38] <audreyt> but you get the idea.

[15:39] <kolibrie> audreyt: does that recurse into the structure, or just one level deep?

[15:39] <audreyt> (bbl...)

[15:39] <audreyt> just one level deep

[15:39] <audreyt> ~$v gets the string representation

[15:39] <audreyt> that's all you need

[15:40] <kolibrie> audreyt: thanks

[16:04] *** Psyche^ joined
[16:05] *** mauke_ joined
[16:06] <kolibrie> lunch &

[16:14] *** mako132_ joined
[16:20] *** mauke_ is now known as mauke

[16:20] *** Psyche^ is now known as Patterner

[16:23] *** weinig|bbl is now known as weinig

[16:34] *** LimbicRegion joined
[16:40] *** ofer1 is now known as ofer0

[16:41] * nothingmuch grazes

[16:41] <nothingmuch> audreyt: still about?

[16:48] <audreyt> sadly really need to sleep

[16:48] <audreyt> 1am here

[16:48] <audreyt> can hack as soon as wakeup

[16:49] <audreyt> I don't see an Overviewi n your repo tho

[16:49] <audreyt> forgot to add?

[16:49] <audreyt> anyway, bbl *thunk*

[16:49] <nothingmuch> yeah, i didn't commit

[16:49] <nothingmuch> i was going to

[16:49] <nothingmuch> but then my friend called me a told me she was ready

[16:49] <nothingmuch> i'll finish it now

[16:49] <nothingmuch> and commit

[16:49] *** LimbicRegion is now known as Limbic_Region

[16:54] *** lisppaste3 joined
[16:59] *** Psyche^ joined
[17:06] *** justatheory joined
[17:15] *** Psyche^ is now known as Patterner

[17:16] *** weinig joined
[17:27] <nothingmuch> http://nothingmuch.woobling.org/MO/lib/MO/Overview.pod

[17:27] <nothingmuch> please review

[17:27] <lambdabot> http://tinyurl.com/law9f

[17:52] *** mdiep joined
[18:02] <kolibrie> if { talk => $$<presenter } gives me the data structure I want, but now I want to add in $$<title>, similar to { talk => { $$<presenter>, $$<title> } }

[18:02] <kolibrie> but I need to remove the extra hash wrapping around $$<presenter> and $$<title>

[18:03] <kolibrie> what is the syntax I need?

[18:16] *** mdiep joined
[18:18] *** frankg joined
[18:18] *** prism joined
[18:24] <nothingmuch> @seen putter

[18:24] <lambdabot> I saw putter leaving #perl6 11h 22m 20s ago, and .

[18:24] <nothingmuch> @tell putter http://nothingmuch.woobling.org/MO/lib/MO/Overview.pod

[18:24] <lambdabot> Consider it noted.

[18:26] *** Nextgens_ joined
[18:26] *** mako132_ joined
[18:27] *** renormalist joined
[18:33] *** SubStack joined
[18:34] *** Dr_Pi joined
[18:44] *** bernhard joined
[18:45] * wolverian boggles at nextgens

[18:54] *** SamB joined
[18:54] *** ajs_home joined
[18:55] <ajs_home> I'm sad to say that I fell for nextgens' little stunt... sigh

[18:55] <mauke> get a better irc client

[18:56] <ajs_home> xchat does what I need it to... I'm not a big fan of IRC to start

[18:56] <mauke> how did it display the message?

[18:57] <ajs_home> --- Received a CTCP SOMEBODY has sent you a message, to read it type: /server read 1 from Nextgens_ (to #perl6)

[18:57] <mauke> heh, a bit misleading

[18:57] <mauke> irssi shows it as: Nextgens_ [i=xterm@gateway/tor/x-a9ff32413fc71714] requested unknown CTCP SOMEBODY from #perl6: has sent you a message, to read it type: /server read 1

[18:58] <buu> That's because irssi is morally superior

[18:59] <ajs_home> morels? Where do I get these morels? I'm hungry!

[19:00] <buu> You eat morels?!

[19:00] <ajs_home> Morels are the best... I make a mean morel risotto

[19:01] <buu> Mmm, food.

[19:09] *** Aankhen`` joined
[19:39] *** markstos joined
[20:11] *** avarab joined
[20:14] <Dr_Pi> I've messed up svn; when I try to do a svn cleanup, I'm getting "svn: 'perl5/Pugs-Compiler-Rule/t/12-plain_regex.t' is not under version control"

[20:16] *** fglock joined
[20:20] <markstos> Dr_PI: cp 12-plain_regex.t modified.t; svn update 12-plain_regex.t; cp modified.t 12-plain_regex.t

[20:20] <lambdabot> markstos: You have 2 new messages. '/msg lambdabot @messages' to read them.

[20:21] <markstos> But I'm just guessing... I'm no svn expert.

[20:29] *** avarab is now known as avar

[20:33] *** Aankhen`` joined
[20:37] <nothingmuch> @summon ninjas

[20:37] <lambdabot> Unknown command, try @list

[20:37] <nothingmuch> .oO

[20:37] <nothingmuch> ( use Engrish; $INPUT_LECORD_SEPALATION = "\n" );

[20:45] *** b_jonas joined
[20:56] *** prism joined
[21:04] *** lanny joined
[21:04] <lanny> @tell gaal On porting DIEHARD.  Um... no.  :)

[21:04] <lambdabot> Consider it noted.

[21:23] *** _bernhard joined
[22:03] *** prism joined
[22:05] *** Limbic_Region joined
[22:07] *** Aankh|Clone joined
[22:23] *** justatheory joined
[22:24] *** awwaiid joined
[22:45] *** awwaiid joined
[22:45] *** weinig is now known as weinig|food

[23:02] *** ofer0 joined
[23:14] *** weinig|food is now known as weinig

[23:36] *** awwaiid joined
[23:40] *** Odin-LAP joined
[23:58] *** awwaiid joined
