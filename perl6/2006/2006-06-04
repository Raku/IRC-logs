[00:11] <svnbot6> r10527 | lwall++ | Last array_cap test can't match C in $0; @bases only contains G, A, and T

[00:12] <TimToady> audreyt: speaking of which, I'm failing the last five tests of that file with an imcc error using embedded parrot.

[00:13] <TimToady> which is why my smokes have five more failures than yours...

[00:29] *** elmex joined
[00:42] *** rashakil__ joined
[00:42] *** Quellism joined
[00:53] *** Ymmv joined
[00:55] *** ludan joined
[00:56] *** mako132_ joined
[01:05] *** rashakil joined
[01:37] <TimToady> audreyt: I'm beginning to think we've defaulted lvalues wrong in assignment parsing, and that only "obviously scalar" lvalues should default to scalar assignment parsing.

[01:39] <TimToady> $a, @foo[1], @foo[$a], @foo[+expr] are fairly obviously scalar.

[01:39] *** Ymmv joined
[01:39] <audreyt> well

[01:40] <audreyt> that goes back to

[01:40] <audreyt> @foo[+func()] and %bar{~func()}

[01:40] <lambdabot> Unknown command, try @list

[01:40] <audreyt> and it must cascade, so @foo[@bar[1]] is scalar too

[01:41] <TimToady> but in general the harm of accidentally guessing list is just a misparse in the presence of commas.

[01:41] <audreyt> yes.

[01:41] <TimToady> and $a = 1, $b = 2 is about as complicated as it gets.

[01:41] <audreyt> well, and also flattening.

[01:42] <audreyt> @foo[func()] = %blah;

[01:42] <lambdabot> Unknown command, try @list

[01:42] <audreyt> but I gree it seems saner than ($foo[1])=

[01:42] <TimToady> well, sure, but I'd say that's obviously intended to be list.

[01:42] <audreyt> I'd agree.

[01:43] <TimToady> I keep wondering how often we'd have to explain why exactly lvalue subscripts default differently than rvalue.

[01:43] <audreyt> so, fix the S* yet again? it helps that this new default is easier to implement.

[01:43] <audreyt> right, because it agrees with rvalue.

[01:43] <TimToady> So I'd even be inclined to say that nothing more complicated than $x gets scalar by default.

[01:44] <audreyt> @foo[1] = func();

[01:44] <lambdabot> Unknown command, try @list

[01:44] <audreyt> I think 1 is as good as +1

[01:45] <audreyt> and +1 needs to be scalar

[01:45] *** sri__ joined
[01:45] <audreyt> forcing [+1] instead of [1] is, like, bad

[01:45] <TimToady> yeah...

[01:46] <TimToady> so basically we need a category "obviously scalar".  I can argue the recursion either way.

[01:47] <TimToady> problem with recursion is @foo[@reallylongvariablename[$x]] tends to hide the scalaraness.

[01:47] <TimToady> the 2nd @ makes it look like a slice

[01:49] <TimToady> I think a very short list of scalars would be best, and no recursion.

[01:49] *** shachaf joined
[01:49] <audreyt> otoh, @ary[%foo{$this}] is quite obviously scalar to me...

[01:50] <audreyt> @ary[+%foo{$this}] is a bit weird

[01:50] <lambdabot> Unknown command, try @list

[01:50] <TimToady> yeah, and a lot of indirection in numeric programming... :/

[01:50] <audreyt> nod.

[01:50] <audreyt> I think recursion is a good idea for this..

[01:51] <TimToady> and @foo[+@bar[$x]] makes it look like you're asking for the len until you see the subscript

[01:51] <audreyt> indeed

[01:52] <TimToady> okay, then yes on recursion, but still a very short list.

[01:52] <audreyt> but no peeking at return type of protos for funcalls.

[01:52] <TimToady> right.

[01:52] <audreyt> k.

[01:53] <audreyt> in that sense, + and ~ becomes metasyntactic

[01:53] <audreyt> [+...] and {~...} that is

[01:53] <TimToady> [+...]

[01:53] <TimToady> *nod*

[01:53] <TimToady> reminds me of {|a|...} from Ruby.

[01:54] <audreyt> *nod*

[01:54] <TimToady> 'course, it's not really, since [+$a and $b]

[01:54] <audreyt> ok. I think I can get that into 6.2.12 if it's specced in time :)

[01:55] <TimToady> did you see my carpage about array_cap.t?

[01:55] <audreyt> yes.

[01:55] <TimToady> anything else you want last-minute speccage on?

[01:55] <audreyt> couldn't get embedparrot going here

[01:55] <audreyt> so will look a bit later and/or switch to the old laptop

[01:56] <audreyt> well, nothing I can think of right now

[01:56] <TimToady> btw has $x is just a lexically scoped alias for $!x, much like "our"

[01:57] <TimToady> so not visible in reopened class.

[01:57] <audreyt> oh hm.

[01:57] <audreyt> class { has $!x; method m { $x } }

[01:57] <audreyt> kosher?

[01:57] <TimToady> I don't think so.

[01:58] <TimToady> on the "our" principle

[01:58] <audreyt> S12 line365 says otherwise

[01:58] <TimToady> means you can force yourself to say $!x everywhere, which is arguably good

[01:59] <TimToady> yeah, hadn't thought of the our connection back then.

[01:59] <audreyt> ok. aslong as there's away to force $x disambig

[01:59] <audreyt> and "has $.x" doesn;t' allow bare $x

[01:59] <audreyt> and neither does "has $!x"

[01:59] <TimToady> right.

[01:59] <audreyt> I think the "has $x" sugar is survivable

[02:06] <cmarcelo> audreyt: when you have time, look at my messages when you were idle (I paste it if you need)..

[02:09] <audreyt> TimToady: btw, a syntactic question

[02:09] <audreyt> cmarcelo: yes, I'm adding atomically{} to Pugs

[02:09] <audreyt> give me 5 mins, almost there

[02:10] <audreyt> TimToady: consider

[02:10] <audreyt> sub foo {

[02:10] <audreyt>     is rw;

[02:10] <audreyt> }

[02:10] <audreyt> is this the same as "sub foo is rw" ?

[02:10] <audreyt> and if yes, I have another unification in mind :)

[02:11] <cmarcelo> "atomically {}" as in STM? pugs interpreter already support atomic blocks?

[02:11] <audreyt> yes.

[02:12] <cmarcelo> ps: prelude is working just fine here now...

[02:12] <audreyt> yay

[02:12] <TimToady> what unification do you have in mind?

[02:13] <audreyt> namely, have the

[02:13] <audreyt> class { ... }

[02:13] <audreyt> form return something that is a genuine Code

[02:14] <audreyt> and unify the bareword-as-class detection by having

[02:14] <audreyt> class Foo { ... }

[02:14] <audreyt> install a &Foo that is the closure

[02:14] <audreyt> to be used as the coercer/constructor

[02:14] <audreyt> and have the "class Foo {...}" form return that thing as well

[02:14] <audreyt> this means Foo is always &Foo

[02:15] <audreyt> which returns ::Foo when called with null-dimension args

[02:15] <audreyt> and all "is ..." traits hang to the closest closure

[02:15] <audreyt> end of probably-insane idea.

[02:15] <audreyt> this is so that

[02:15] <audreyt> sub foo is atomic {...}

[02:15] <audreyt> and

[02:15] <audreyt> { is atomic; ... }

[02:15] <audreyt> falls out automagically

[02:16] <TimToady> have to think about it some.  defined(Foo) and such

[02:17] <audreyt> *nod*

[02:18] <TimToady> can probably unify the syntax, just not sure about the semantics

[02:19] <TimToady> { is sig\(...); ...  } for you Ruby lovers.

[02:19] <TimToady> well, that's really from Smalltalk

[02:20] <merlyn> speaking of smalltalk, I'm reviewing Kent Beck "Smalltalk Best Practice Patterns" for use in an OOP talk, and I am reminded of just how darn *good* it is.  Everything in that book should be easy to do in Perl6. And I mean that in both directions. :)

[02:21] *** rashakil_ joined
[02:31] *** justatheory joined
[02:41] <audreyt> gaal++ # comp unit version field for bytecode

[02:41] <audreyt> blib6/lib/*.yml is now obsolete again... please remove before making pugs (but the err msg this time aroudn is netter now)

[02:41] <audreyt> s/netter/better/

[02:48] <TimToady> okay, assignment is respecced.  was it soon enough to get into .12? :)

[02:49] <audreyt> yes :)

[02:49] <audreyt> TimToady++

[02:49] <TimToady> of course, I glossed over the question of "what is a literal?"

[02:51] <audreyt> there's some pun involving "due respec" here but I can't quite see it...

[02:51] <audreyt> oh btw

[02:52] <audreyt> [-1] should be fine too

[02:52] <audreyt> as is [-func()]

[02:52] <TimToady> right

[02:52] <TimToady> I was also wondering about ? and !, but left them out

[02:53] <audreyt> interestingly, that forces +int

[02:53] <audreyt> though arguably int is more arrayish than +.

[02:53] <audreyt> but oh well.

[02:53] <TimToady> yes

[02:54] <TimToady> Hmm.  @foo[+$i++] is a bit ugly.

[02:54] <merlyn> or even @foo[+++$i]

[02:54] <TimToady> that wouldn't even parse right

[02:54] <merlyn> @foo[+ ++$i] ?

[02:54] <TimToady> maybe we should define it in terms of precedence

[02:54] <lambdabot> Unknown command, try @list

[02:55] <TimToady> that's what it'd have to be right now

[02:58] <audreyt> I like the prec idea.

[02:58] <TimToady> defining by precedence wouldn't be terribly clean either, since there are lots of tight operators that imply listiness, such as unary @

[02:58] <audreyt> in the symunary prec, we handpick "scalarish" things

[02:59] <audreyt> anything tighter than it is considered literal-scalarish

[02:59] <audreyt> then the nestedness follows from that as .[] is tighter

[03:00] <audreyt> though that doesn't quite apply to .(). oy.

[03:00] *** rdice joined
[03:00] <TimToady> could drive it as low as additive, if we hand-unpick xx

[03:02] <TimToady> could also say in the range from autoincrement to additive (with exceptions)

[03:02] <TimToady> but a little strange to disallow @foo[.chars]

[03:04] <TimToady> but we really can't allow general methods there if we don't allow general subs.

[03:05] <TimToady> so maybe we just fudge and say "scalar math and string operators".

[03:06] <TimToady> and maybe just unaries.

[03:12] <audreyt> yeah.

[03:12] *** glasser joined
[03:13] <glasser> i am told that the lambdacamels know the secret of ghc under darwinports on osx intel

[03:13] <audreyt> there is no secret...

[03:13] <audreyt> http://pugs.blogs.com/pugs/2006/05/ghcmacintel_por.html

[03:13] <glasser> in fact, i am told that you know the incantation, audrey :)

[03:14] <audreyt> well I've made a bindist :)

[03:14] * clkao grins

[03:14] <glasser> merci

[03:14] <audreyt> np :)

[03:15] <glasser> hmm, one could make a portfile that builds out of cvs head...

[03:15] <glasser> (like emacs-devel)

[03:16] *** coumbes joined
[03:16] <audreyt> but you need a bindist to bootstrap, unless you are willing to wait 5hr for unregisterised stage1

[03:16] <glasser> ah good point. (i think i was actually doing that on mac ppc)

[03:17] * clkao so looking forward to hackathons

[03:17] <glasser> oh, so once this is installed i'll be able to install it again via dp or something?

[03:17] <glasser> clkao: i'm on for tuesday

[03:17] <clkao> yay

[03:17] <glasser> svk on afs it is

[03:17] <glasser> (though i think i just missed ghudson today :) )

[03:18] <clkao> i managed to say hi before he fled

[03:18] <clkao> i think he stayed for less than 30min

[03:22] <audreyt> glasser: once it's installed you can easily make form any ghc trunk checkout, yes

[03:27] <audreyt> yay, it's done... bbiab

[03:27] <svnbot6> r10528 | audreyt++ | * Expose Software Transactional Memory to the userland.

[03:27] <svnbot6> r10528 | audreyt++ | * Provisional (unspecced) syntax:

[03:27] <svnbot6> r10528 | audreyt++ |     my ($x, $y);

[03:27] <svnbot6> r10528 | audreyt++ |     async {

[03:27] <svnbot6> r10528 | audreyt++ |         atomically {

[03:27] <svnbot6> r10528 | audreyt++ |             $x = $y + 1;

[03:27] <svnbot6> r10528 | audreyt++ |             $y = $x + 1;

[03:27] <svnbot6> r10528 | audreyt++ |         }

[03:27] <svnbot6> r10528 | audreyt++ |     } for 1..5;

[03:27] <svnbot6> r10528 | audreyt++ |     say "($x, $y)" # Guaranteed to be (9, 10)

[03:27] <svnbot6> r10528 | audreyt++ | * Bump CompUnit version to 2; existing .yml in blib6/lib and other

[03:27] <svnbot6> r10528 | audreyt++ |   places need to be removed.

[03:31] <obra> hi gang

[03:31] <clkao> lo

[03:33] <TimToady> howdy

[03:38] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = ({ atomically { $x = $y + 1; $y = $x + 1; } }) xx 5; @foo>>.(); say "($x, $y)";

[03:38] *** evalbot_10525 is now known as evalbot_10528

[03:38] <evalbot_10528> Error:  unexpected ">" expecting "::", term postfix, comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[03:38] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = ({ atomically { $x = $y + 1; $y = $x + 1; } }) xx 5; @foo.>>.(); say "($x, $y)";

[03:38] <evalbot_10528> Error:  unexpected ">" expecting ".", subroutine name, array subscript, hash subscript or code subscript

[03:39] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = ({ atomically { $x = $y + 1; $y = $x + 1; } }) xx 5; @foo.».(); say "($x, $y)";

[03:39] <evalbot_10528> Error:  unexpected "\\" expecting ".", subroutine name, array subscript, hash subscript or code subscript

[03:39] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = ({ atomically { $x = $y + 1; $y = $x + 1; } }) xx 5; @foo».(); say "($x, $y)";

[03:39] <evalbot_10528> Error: Cannot cast from VList [VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subEnv = Just (MkEnv {envContext = CxtItem (mkType "Any"), envLValue = False, envLexical = MkPad (padToList [("$?1",[(<ref>,<ref>)]),("$_",[(<ref>,<ref>)]),("$__evalbot_print",[(<ref>,<ref>)]),("$code",[(<ref>,<ref>)]),("$lang",[(<ref>,<ref>)]),("$x",[(<ref>,<ref>)]),("$y",[(<ref>,<ref>)]),("&?BLOCK_EXIT",[(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref>)

[03:40] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = ({ atomically { $x = $y + 1; $y = $x + 1; } },) xx 5; @foo».(); say "($x, $y)";

[03:40] <evalbot_10528> Error: Cannot cast from VList [VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subEnv = Just (MkEnv {envContext = CxtSlurpy (mkType "Any"), envLValue = False, envLexical = MkPad (padToList [("$?1",[(<ref>,<ref>)]),("$_",[(<ref>,<ref>)]),("$__evalbot_print",[(<ref>,<ref>)]),("$code",[(<ref>,<ref>)]),("$lang",[(<ref>,<ref>)]),("$x",[(<ref>,<ref>)]),("$y",[(<ref>,<ref>)]),("&?BLOCK_EXIT",[(<ref>,<ref>),(<ref>,<ref>),(<ref>,<ref

[03:41] <TimToady> ?eval my $x = 0; my $y = 0; my @foo = (sub () { atomically { $x = $y + 1; $y = $x + 1; } },) xx 5; @foo».(); say "($x, $y)";

[03:41] <evalbot_10528> Error: Cannot cast from VList [VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubRoutine, subEnv = Just (MkEnv {envContext = CxtSlurpy (mkType "Any"), envLValue = False, envLexical = MkPad (padToList [("$?1",[(<ref>,<ref>)]),("$_",[(<ref>,<ref>)]),("$__evalbot_print",[(<ref>,<ref>)]),("$code",[(<ref>,<ref>)]),("$lang",[(<ref>,<ref>)]),("$x",[(<ref>,<ref>)]),("$y",[(<ref>,<ref>)]),("&?BLOCK_EXIT",[(<ref>,<ref>),(<ref>,<ref>),(<ref>,<r

[03:41] <TimToady> aah well, I'll stop wasting bandwidth.

[03:46] <QtPlatypus> ?eval my $a = Bool::True | Bool::False; $a

[03:46] <evalbot_10528> \(Bool::False | Bool::True)

[03:47] <QtPlatypus> ?eval my $a = Bool::True | Bool::False; my $b = $a && not $a; $b

[03:47] <evalbot_10528> \Bool::False

[03:48] <TimToady> eek

[03:48] <TimToady> Building Pugs-6.2.11...

[03:48] <TimToady> unknown RTS option: -N2

[03:49] <TimToady> Build failed: 256 at util/build_pugs.pl line 96.

[03:49] <TimToady> make: *** [pugs] Error 2

[03:50] <TimToady> that's after realclean...

[03:56] <glasser> audreyt: durr, I'm dumb today... how do I actually install your bindist?

[03:59] <TimToady> also getting some: Unrecognised flags: -p when I reconfigure

[04:00] * TimToady wanders off to find some dinner. &

[04:04] *** Captain_Fourier joined
[04:04] <Captain_Fourier> hello

[04:08] <audreyt> glasser: sh configure make make install etc

[04:08] <audreyt> TimToady: fixed

[04:09] <Captain_Fourier> hmm is perl6 out yet

[04:09] <Captain_Fourier> or should i just play with pugs

[04:09] <svnbot6> r10529 | audreyt++ | * oops, left debug flags in

[04:10] <audreyt> Captain_Fourier: you can also play with parrot if you are interested in VMs

[04:10] <svnbot6> r10530 | audreyt++ | * older Cabals doesn't have -p.

[04:14] <glasser> oh i see

[04:18] <glasser> bah, it installs, but it does not run, because i don't have libreadline where it wants it

[04:18] <glasser> maybe i should have given some args to configure

[04:21] <audreyt> mm

[04:21] <audreyt> install libreadline5 via ports first

[04:22] <Captain_Fourier> is there a good tutorial on pugs

[04:22] <audreyt> Captain_Fourier: http://svn.openfoundry.org/pugs/docs/articles/tpr.pod

[04:22] <Captain_Fourier> thanks

[04:23] <audreyt> np :)

[04:24] <Captain_Fourier> i read that using perldoc right?

[04:24] <audreyt> yes

[04:24] <audreyt> or pod2html

[04:26] <Captain_Fourier> yum

[04:28] *** mako132_ joined
[04:41] <svnbot6> r10531 | audreyt++ | * Pugs.Prim.Numeric: remove a defaulting warning.

[04:47] * audreyt goes back looking at HsJudy

[04:47] *** glasser joined
[04:50] <svnbot6> r10532 | audreyt++ | * Restore object finalization outside STM blocks.

[04:50] <svnbot6> r10532 | audreyt++ | * Relax Thread.yield() to be usable in atomic blocks.

[04:54] <glasser> Oh wow, we've got STM in perl 6 now?

[04:55] <cmarcelo> audreyt: =)

[04:55] <glasser> What sorts of things can you put in an atomic block?

[04:57] <audreyt> "safe" things

[04:57] <audreyt> things that you can put into evalbot

[04:57] <audreyt> conceptually, things that only affects the memory, and can be cancelled.

[04:59] <svnbot6> r10533 | audreyt++ | * restore object destruction outside STM for real

[05:00] <audreyt> no "eval" currently as it conceptually invokes compiler

[05:01] <audreyt> may be relaxed later

[05:01] <audreyt> try{} is fine though

[05:09] <spinclad> audreyt, cmarcelo: sorry i've been away, and sorry for poor testing.

[05:10] <cmarcelo> spinclad: np.. did you see the test program I commited?

[05:10] <spinclad> not yet, will svn up first

[05:11] <spinclad> can take a quick look tonight and give more time to it tomorrow

[05:11] <audreyt> spinclad: no prob, don't need to be sorry :)

[05:12] <cmarcelo> spinclad: ok.. tks =)

[05:17] <audreyt> cmarcelo: ok. so for GHC, the two "10" are different heap objects

[05:18] <audreyt> for both StablePtr and StableName purposes

[05:20] <audreyt> it seems that a general "Set" has to be implemented as JudyHS with StablePtr as value

[05:20] <audreyt> the BitSet itself is probbly only good for things that are isomorphic to Int32

[05:23] *** khisanth_ joined
[05:24] *** khisanth_ is now known as Khisanth

[05:27] <cmarcelo> audreyt: so, with only StablePtr and StableName isn't possible to use Haskell values as indexes... or even worse, as the two 10's aren't the same heap obj, using them as index AND "guarding" them from the GC wouldn't be easy...

[05:28] <spinclad> i presume two refs to the same 10 will count as the same...

[05:29] <cmarcelo> audreyt: general "Set" => but using what to index.. didnt get it..

[05:30] <audreyt> cmarcelo: use Storable image, or a custom-defined class

[05:30] <svnbot6> r10534 | szabgab++ | examples/perldoc.p6 - naive perldoc reader

[05:30] <svnbot6> r10534 | szabgab++ | -This line, and those below, will be ignored--

[05:30] <svnbot6> r10534 | szabgab++ | AM   perldoc.p6

[05:30] <audreyt> give me a sec

[05:32] *** stevan__ is now known as stevan

[05:32] <cmarcelo> spinclad: i think so, but sometimes he creates two "different" 10's then. in my test i explicit create a 10, and [1..10] creates another.

[05:39] <spinclad>  

[05:39] <spinclad> (oop)

[05:40] <spinclad> and each time you run that same [1..10], it's another

[05:41] <spinclad> or could be (thinking of maclisp smallnums and bignums)

[05:41] <cmarcelo> audreyt: i'm reading Storable docs now.. Is it derivable? or the programmer must instance explicitly for each new type?

[05:42] <cmarcelo> spinclad: what do you mean?

[05:45] <audreyt> cmarcelo: DrIFT and SerTH are possible directions

[05:45] <svnbot6> r10535 | audreyt++ | * one possible way to encode haskell value into Value with Hashable

[05:45] <audreyt> cmarcelo: Hashable is one possibility (just checked in)

[05:48] <spinclad> smallnums XX fixnums up to some size fit in a pointer, so pointer identity was identity for them; larger fixnums and bignums could have multiple copies of the same value.

[05:51] *** knewt joined
[05:57] <audreyt> cmarcelo: also cf. http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Prelude.html#t%3AUniqueHash

[05:57] <audreyt> we can reuse that definition

[05:58] <audreyt> so that toList is only possible on BitSet for ReversibleHash instances

[05:58] <audreyt> and generally you can only use get/set on them

[05:59] <audreyt> makes (some) sense?

[06:00] <cmarcelo> audreyt: yes (i'm digesting all the info)... but,

[06:00] <cmarcelo> (if "digesting" sounded odd, ignore hehe)... String isn't UniqueHashable, for example right?

[06:01] *** ayrnieu joined
[06:02] <cmarcelo> or arbitrary integer.. in your instance for Hashable Integer, it "may" happen a collision? or i'm missing something?

[06:05] <audreyt> that would be correct, yes

[06:06] <audreyt> actually, the classes in http://www.eecs.tufts.edu/~rdocki01/docs/edison/index.html

[06:06] <audreyt> is a very good API design guide

[06:07] <cmarcelo> audreyt: actually, thinking about it now, using StablePtr as Indexes forces the existence of Indexes objects in memory, and this isn't always necessary...

[06:07] <audreyt> StableName has no such problem

[06:08] <audreyt> also, if using StablePtr

[06:08] <audreyt> you can hook a Finalizer

[06:08] <audreyt> so that it's freed when the judy itself is freed

[06:09] <audreyt> BitSet roughly corresponds to http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Coll-EnumSet.html

[06:09] <audreyt> I think we can safely demand Enum on a

[06:09] <audreyt> that solves the bijection problem

[06:10] <audreyt> unlike EnumSet, we are in IO, so maybe it's okay to allow IO too on to/from Enum conversions

[06:12] *** shachaf joined
[06:12] <audreyt> class EnumIO a where

[06:12] <audreyt>     

[06:13] <audreyt>    toEnumIO :: Int -> IO a

[06:13] <audreyt>     fromEnum :: a -> IO Int

[06:13] <audreyt> instance Enum a => EnumIO a where

[06:13] <audreyt>   toEnumIO = return . toEnum

[06:13] <audreyt>     fromEnumIO = return . fromEnum

[06:14] <audreyt> that's one possibility.

[06:14] <audreyt> (s/fromEnum ::/fromEnumIO ::/)

[06:15] <audreyt> and then BitSet will demand EnumIO a

[06:15] <cmarcelo> nice! well, I'll try to come up with a better BitSet2 (unifying it back to BitSet) using this classes. but this demands (Enum a), won't restrict BitSet scope too much?

[06:15] <audreyt> and you can either derive Enum

[06:15] <audreyt> or write your own toEnumIO / fromEnumIO instances

[06:15] <audreyt> well, but that's all we can promise really

[06:15] <audreyt> we can go one step further and stub this definition of toEnumIO

[06:16] <audreyt>     toEnumIO = fail "This is one-way hash, sorry" -- default implementation in EnumIO

[06:16] <audreyt> so that Integer can supply fromEnumIO as irreversible hash

[06:16] <audreyt> but toEnumIO and fromEnumIO are bad names.

[06:17] <audreyt> maybe hashIO and unhashIO separated to two classes

[06:17] <audreyt> and toList will demand the stronger class ReversibleHash

[06:17] <audreyt> which is a subclass of Hash

[06:17] <audreyt> anyway... you got the idea already.  improvise :)

[06:17] <audreyt> maybe HashIO and ReversibleHashIO...

[06:18] <cmarcelo> ok =)..

[06:18] <audreyt> cmarcelo++

[06:20] <audreyt> brb

[06:21] <spinclad> cmarcelo: yes, that looks strangely familiar :)

[06:22] <spinclad> but /me has timed out for tonight... will debug tomorrow

[06:22] <spinclad> &

[06:22] <cmarcelo> spinclad: bye! =)

[06:22] * audreyt goes fixing the remaining 4 fails

[06:23] <audreyt> sleep(3) well, spinclad

[06:23] <cmarcelo> @localtime audreyt

[06:23] <lambdabot> Local time for audreyt is Sun Jun  4 08:23:27 2006

[06:23] <spinclad> .oO{ thanks ... ooh, look, shiny }

[06:23] <audreyt> it's 2:23pm here

[06:23] <cmarcelo> audreyt: is this correct?

[06:23] <spinclad> @localtime cmarcelo

[06:23] <lambdabot> Local time for cmarcelo is Sun Jun  4 03:23:58

[06:23] <audreyt> no; I'm using feather.perl6.nl

[06:25] <spinclad> .oO{ 03:25... brazil? }

[06:25] <cmarcelo> audreyt: i'm going to sleep now, will try to get something commited before your next "wake cycle"...

[06:25] <audreyt> cool

[06:25] <audreyt> cmarcelo++

[06:25] <cmarcelo> spinclad: yes =)

[06:25] <cmarcelo> fglock is brazilian too, right?

[06:25] <spinclad> ys

[06:26] <spinclad> s//e/

[06:26] <audreyt> cmarcelo: once we got this working, I'll convert Pugs.Prim to use that instead of IntSet

[06:26] <spinclad> also ruoso i seem to recall

[06:27] <audreyt> since it's conceptually the same thign as a StateT IntSet

[06:27] <audreyt> but I suspect much faster. we'll see if the FFI overhead is too high

[06:27] <cmarcelo> YAPC::Brasil happened few weeks before I discover #perl6 I think... =P

[06:27] <spinclad> .oO{ & }

[06:29] <cmarcelo> audreyt: Pugs.Prim conversion => cool.

[06:29] <cmarcelo> well. bye

[06:29] <cmarcelo> &

[06:29] *** cmarcelo left
[06:29] <audreyt> spinclad: shut the computer down; it helps

[06:30] *** iblechbot joined
[06:36] *** Aankhen`` joined
[06:37] <audreyt> bbiab

[06:55] *** Captain_Fourier left
[06:57] *** chihchun joined
[08:01] *** penk joined
[08:04] <svnbot6> r10536 | audreyt++ | * shift-from-function-array-arg.t - mark as TODO; pending capturizing.

[08:04] <svnbot6> r10537 | audreyt++ | * slow-parse-fail.t: this is now 1)fast 2)passing

[08:10] <svnbot6> r10538 | audreyt++ | * pair_boolean.t: revive this test; Pair objects are always true.

[08:14] <svnbot6> r10539 | audreyt++ | * empty_list_in_map.t: fix plan

[08:14] <svnbot6> r10538 | audreyt++ | * pair_boolean.t: revive this test; Pair objects are always true.

[08:14] *** chihchun joined
[08:16] <svnbot6> r10540 | audreyt++ | * "sub f (@x) {}" now causes the argument of f(...) to be evaluted

[08:16] <svnbot6> r10540 | audreyt++ |   in item, not slurpy, context.  This means f([1,2,3]) now works

[08:16] <svnbot6> r10540 | audreyt++ |   as specced.

[08:16] *** chihchun joined
[08:34] *** andara joined
[08:46] *** Odin- joined
[08:51] *** Odin-LAP joined
[09:16] *** evalbot_10528 is now known as evalbot_10540

[09:26] <svnbot6> r10541 | audreyt++ | * hash.t: Now that defaulting works the other way around, hashes

[09:26] <svnbot6> r10541 | audreyt++ |   resume the bias-to-the-right behaviour, consistent with Perl 5:

[09:26] <svnbot6> r10541 | audreyt++ |     my %hash = (x => 1, x => 2);

[09:26] <svnbot6> r10541 | audreyt++ |     %hash<x>; # 2

[09:32] <svnbot6> r10542 | audreyt++ | * want.t: fix context expectation

[09:35] *** andara joined
[09:47] <svnbot6> r10543 | audreyt++ | * f(()) should pass &f an empty list, not "undef".

[09:48] *** elmex joined
[09:48] <svnbot6> r10544 | audreyt++ | * subroutine.t: unTODO passing tests.

[09:51] *** iblechbot joined
[09:51] <svnbot6> r10545 | audreyt++ | * splice.t: fix context expectations

[09:54] <svnbot6> r10546 | audreyt++ | * HTML::Entities - unTODO passing tests and chase for context changes

[09:54] <svnbot6> r10547 | audreyt++ | * Perl6::Container::Array: adjust test TODOness

[10:01] *** vytautas joined
[10:02] *** kanru joined
[10:10] <svnbot6> r10548 | audreyt++ | * unicode.t: "\xABCD" is unicode literals, not UTF8 codepoints!

[10:10] <svnbot6> r10549 | audreyt++ | * hyperop.t: fix test count

[10:10] <svnbot6> r10550 | audreyt++ | * use_perl_6.t: fix test count

[10:10] <svnbot6> r10551 | audreyt++ | * arith.t: fix test plan

[10:11] *** chris2 joined
[10:13] <svnbot6> r10552 | audreyt++ | * unTODO, fix test plan, etc.

[10:13] *** ludan joined
[10:32] *** nperez joined
[10:42] <svnbot6> r10553 | audreyt++ | * ext/Perl6-Grammar/: Makefile.PL.

[10:42] <svnbot6> r10553 | audreyt++ | * This module is somewhat duplicated with lrep's grammars,

[10:42] <svnbot6> r10553 | audreyt++ |   the .pg grammars in src/Pugs/Parser/, and Parrot/Perl6's grammars.

[10:42] <svnbot6> r10553 | audreyt++ |   Not sure what to do with it, but it passes tests, so it's still in.

[10:42] <svnbot6> r10554 | audreyt++ | * yaml_harness: hand-adjust the first child to run 2/3 of

[10:42] <svnbot6> r10554 | audreyt++ |   other children, to balance against the fact that ext/

[10:42] <svnbot6> r10554 | audreyt++ |   is more time-consuming.

[10:44] *** szbalint joined
[10:51] <svnbot6> r10555 | audreyt++ | * Set::Infinite: Fix inconsistent use of $.set and @.set.

[10:52] <andara> ?eval my $g=($x){return $x+1};my $f=sub ($n_,$f_) { return $f_($n_+1)} };say $f($n,$g);

[10:52] <svnbot6> r10556 | audreyt++ | * Pugs.Eval: %.foo is now consitently a hash and never an array or otherwise.

[10:52] <svnbot6> r10556 | audreyt++ |   Ditto for @.foo.

[10:53] *** evalbot_10540 is now known as evalbot_10554

[10:53] <evalbot_10554> user error (incompatible version number for compilation unit) Error:  unexpected "}" expecting comment, operator, ";" or end of input

[10:53] <andara> ?eval my $g=($x){return $x+1};my $f=sub ($n_,$f_) { return $f_($n_+1)} ;say $f($n,$g);

[10:53] *** evalbot_10554 is now known as evalbot_10555

[10:53] <evalbot_10555> Error: Undeclared variable: "$x"

[10:53] <andara> ?eval my $g=($x){return $x+1};my $f=sub ($n_,$f_) { return $f_($n_+1)} };say $f(5,$g);

[10:53] <svnbot6> r10557 | audreyt++ | * reverse.t: unTODO passing test.

[10:53] <evalbot_10555> Error:  unexpected "}" expecting comment, operator, ";" or end of input

[10:54] <andara> ?eval my $g=($x){return $x+1};my $f=sub ($n_,$f_) { return $f_($n_+1)} ;say $f(5,$g);

[10:54] <evalbot_10555> Error: Undeclared variable: "$x"

[10:54] <audreyt> you want "sub ($x)"

[10:54] <audreyt> or "$x->"

[10:54] <andara> thanks!

[10:55] <audreyt> er I mean "->$x"

[10:55] <andara> ?eval my $g=sub ($x){return $x+1};my $f=sub ($n_,$f_) { return $f_($n_+1)} ;say $f(5,$g);

[10:55] <evalbot_10555> OUTPUT[7 ] Bool::True

[10:56] <andara> ?eval my $n=5;my $f=sub ($n_,$f_) { if($n_<2) { return 1} else {return $n_*$f_($n_-1)} };say $f($n,$f);

[10:56] <evalbot_10555> Error: Undeclared variable: "$f_"

[10:56] <audreyt> ?eval y $g = {$^x+1}; my $f = { $^f($^a_+1)};  $f(5,$g);

[10:56] <evalbot_10555> Error: No such method in class Any: "&y"

[10:56] <audreyt> ?eval my $g = {$^x+1}; my $f = { $^f($^a_+1)};  $f(5,$g);

[10:56] <evalbot_10555> 7

[10:56] <andara> Does perl6 have recursive lambdas?

[10:56] <audreyt> sure do

[10:57] <andara> what's wrong with my code then?

[10:57] <audreyt> ?Eval { $_ ?? $_ * &?BLOCK($_-1) !! 1 }.(10)

[10:57] <audreyt> ?eval { $_ ?? $_ * &?BLOCK($_-1) !! 1 }.(10)

[10:57] <evalbot_10555> 3628800

[10:59] <audreyt> ?eval my $n=5;my $f=sub ($n_, $f_) { if ($n_<2) { 1} else { $n_*$f_($n_-1, $f_)} }; say $f($n,$f);

[10:59] <evalbot_10555> OUTPUT[120 ] Bool::True

[10:59] <audreyt> andara: you didn't give the $f_() invocation its fixpoint

[10:59] <audreyt> so on the second time around $f_ wasn't bound

[10:59] <audreyt> $_f($n_-1, $f_), instead of $_f($n_-1)

[10:59] <andara> stupid of me. thanks audrey

[10:59] <audreyt> you can curry the $f_ using $f.assuming(f_ => $f_)

[11:00] <audreyt> also can ben written as $f.assuming(:$f_)

[11:00] <andara> ?eval for 5 -> $n { for (sub ($n_,$f_) { if($n_<2) { return 1} else {return $n_*$f_($n_-1,$f_)} }) -> $f { say $f($n,$f) }};

[11:00] *** evalbot_10555 is now known as evalbot_10557

[11:00] <evalbot_10557> Error:  unexpected "$" expecting comment, operator or ")"

[11:04] <nperez> heh, spam on parrot rt

[11:05] *** TimToady joined
[11:08] <audreyt> yay, all tests passed for me.

[11:08] * audreyt dinner &

[11:09] <andara> ?eval for 5 -> $n { for sub ($n_,$f_) { if($n_<2) { return 1} else {return $n_*$f_($n_-1,$f_)} } -> $f { say $f($n,$f) }}

[11:09] <evalbot_10557> Error:  unexpected "$" expecting comment, operator or ")"

[11:11] <audreyt> andara: to play with \calculus, try this

[11:11] <audreyt> ?eval (-> $n { -> $f { say $f($n,$f) }.( sub ($n_,$f_) { if($n_<2) { return 1} else {return $n_*$f_($n_-1,$f_)} }) }).(5)

[11:11] <evalbot_10557> OUTPUT[120 ] Bool::True

[11:12] <audreyt> or, with lexical shadowing

[11:12] <audreyt> ?eval (-> $n { -> $f { $f($n,$f) }.( -> $n, $f { $n<2 ?? 1 !! $n*$f($n-1,$f) }) }).(5)

[11:12] <andara> so you use .() to pass the argument values, not for ()

[11:12] <evalbot_10557> 120

[11:12] <audreyt> yeah. for is iterator

[11:13] <andara> yes, but shouldn't it work on 1-elt lists like for 5-> ?

[11:14] <audreyt> ?eval for 5 -> $n { -> $f { $f($n,$f) }.( -> $n, $f { $n<2 ?? 1 !! $n*$f($n-1,$f) }) }

[11:14] <evalbot_10557> undef

[11:14] <audreyt> ?eval for 5 -> $n { -> $f { say $f($n,$f) }.( -> $n, $f { $n<2 ?? 1 !! $n*$f($n-1,$f) }) }

[11:14] <evalbot_10557> OUTPUT[120 ] undef

[11:15] <audreyt> it's a parsebug, I think

[11:16] <andara> np. I like the .() notation fine, it's closer to \calc

[11:16] <audreyt> ?eval for 5 -> $n { for (-> $n, $f { $n < 2 ?? 1 !! $n*$f($n-1,$f) }) -> $f { say $f($n, $f) } }

[11:16] <evalbot_10557> OUTPUT[120 ] undef

[11:16] <audreyt> actually it works

[11:17] <audreyt> you need the explicit () after the "for"

[11:17] <audreyt> otherwise

[11:17] <audreyt> for ... {}

[11:17] <audreyt> is always interpreted such that the {} is the loop body

[11:18] <andara> couldn't have worked that out for myself. thanks a lot!

[11:18] <audreyt> no prob :) it helps to have an installed version of pugs that tells you which column offset the parsefail occurs

[11:18] <audreyt> :)

[11:21] <andara> cheers

[11:43] *** rindolf joined
[11:49] <beppu> ?eval my $string = "hello"; $string =~ s:/hello/goodbye/; $string;

[11:49] <evalbot_10557> Error:  unexpected end of input expecting "\\", "$/", "$!" or ":"

[11:49] <beppu> ?eval my $string = "hello";

[11:49] <evalbot_10557> \"hello"

[11:50] <QtPlatypus> ?eval my $string = "hello"; $string =~ s/hello/goodbye/; $string;

[11:50] <evalbot_10557> \"<Subst>"

[11:51] <prefiks> ?eval my $string = "hello"; $string ~~ s/hello/goodbye/; $string

[11:51] <evalbot_10557> \"goodbye"

[11:51] <beppu> prefiks: thank you!!!

[11:51] <QtPlatypus> Can anyone explain what I did?

[11:52] <prefiks> $a =~ $b == $a = $a ~ $b

[11:52] *** neoesque joined
[11:52] <beppu> what does the ~ operator do nowadays?

[11:53] <prefiks> string concatenation

[11:53] *** rashakil joined
[11:53] * beppu feels like such a noob.

[11:53] <ayrnieu> ?eval [~] <a b c>

[11:53] <evalbot_10557> "abc"

[11:53] <beppu> i see....

[11:53] <nperez> the whole angle brackets for literals throws me everytime i see it

[11:54] *** iblechbot joined
[11:54] <beppu> I was too embarassed to ask how to do these basic things.  ;)

[11:54] <QtPlatypus> I thouth that $a ~= $b == $a = $a ~ $b

[11:54] <QtPlatypus> ?eval my $a =1; $a += 2;$a

[11:54] <nperez> ?eval $a ~= $b == $a = $a ~ $b

[11:54] <evalbot_10557> \3

[11:54] <evalbot_10557> Error: Undeclared variable: "$a"

[11:55] <prefiks> hm... then =~ will assign + stringifaction ;)

[11:55] <QtPlatypus> ?eval my $a =1; $a =+ 2;$a

[11:55] <evalbot_10557> \2

[11:55] <QtPlatypus> Now I understand

[11:55] <wolverian> ?eval ~1

[11:55] <evalbot_10557> "1"

[11:55] <beppu> QtPlatypus: I think you can think of perl 6's ~= as perl 5's .= .

[11:55] <nperez> ?eval my $a =1; $a =~ 1; say $a;

[11:55] <evalbot_10557> OUTPUT[1 ] Bool::True

[11:56] <wolverian> prefiks, prefix:<~> is a generic stringification operator. =~ just means = ~

[11:56] <QtPlatypus> I thouth that $a =~ $b is $a = ~ $b

[11:56] <wolverian> QtPlatypus, it is.

[11:56] <QtPlatypus> Now thingss make sence to me.

[11:57] <beppu> ?eval [~] "hello", ", ", "world"

[11:57] <evalbot_10557> "hello, world"

[11:57] <prefiks> ?eval [\~] "hello", ", ", "world"

[11:57] <evalbot_10557> ("hello", "hello, ", "hello, world")

[11:58] <beppu> that \ was magical -- does it have a name?

[11:58] <wolverian> triangulation? :) it is equivalent to 'scan' in functional languages.

[11:58] <ayrnieu> [~|+] <0 1 2>  # guess.

[11:58] <ayrnieu> ?eval [~|+] <0 1 2>  # guess.

[11:58] <wolverian> > scan (+) [1,2,3]

[11:58] <evalbot_10557> Error:  unexpected "[" or "|" expecting program

[11:58] <lambdabot>  Not in scope: `scan'

[11:58] <wolverian> oops

[11:58] <wolverian> > scanl1 (+) [1,2,3]

[11:58] <lambdabot>  [1,3,6]

[11:58] <QtPlatypus> ?eval [~~] "All","All","All"

[11:58] <evalbot_10557> Bool::True

[11:58] <wolverian> ?eval [\+] 1,2,3

[11:59] <evalbot_10557> (1, 3, 6)

[11:59] <wolverian> see :)

[11:59] <beppu> that's powerful...

[11:59] <beppu> all these new ways to loop...

[12:02] <QtPlatypus> ?eval [\,] (0..4)

[12:02] <evalbot_10557> Error: No such method in class List: "&prefix:[\\,]"

[12:02] *** nperez joined
[12:04] <beppu> ?eval [,] 0..4

[12:05] <evalbot_10557> (0, 1, 2, 3, 4)

[12:05] <beppu> I wonder why \, doesn't work.

[12:07] *** frodo72 joined
[12:07] <prefiks> say &prefix:<,>

[12:07] <prefiks> ?eval say &prefix:<,>

[12:07] <evalbot_10557> Error: Undeclared variable: "&prefix:,"

[12:08] <prefiks> ?eval say &prefix:<+>

[12:08] <evalbot_10557> OUTPUT[<SubPrim(+)> ] Bool::True

[12:08] <wolverian> seems to be a special case

[12:10] <QtPlatypus> Prefix , doesn't exist.

[12:10] <QtPlatypus> ?eval +0

[12:11] <evalbot_10557> 0

[12:11] <QtPlatypus> ?eval ,0

[12:11] <evalbot_10557> Error:  unexpected "," expecting program

[12:11] <prefiks> ?eval say &infix:<+>

[12:11] <evalbot_10557> OUTPUT[<SubPrim(+)> ] Bool::True

[12:11] <prefiks> ?eval say &infix:<,>

[12:11] <evalbot_10557> Error: Undeclared variable: "&infix:,"

[12:13] <wolverian> oh, right

[12:13] <wolverian> [\,] 1,2,3 is ,1,2...

[12:14] <prefiks> it uses infix op i think...

[12:14] <QtPlatypus> ?eval [,]

[12:14] <prefiks> ?eval [\*] 1,2,3

[12:14] <evalbot_10557> ()

[12:14] <evalbot_10557> (1, 2, 6)

[12:14] <prefiks> ?eval *1*2*3

[12:14] <evalbot_10557> 6.0

[12:14] *** frodo72 is now known as PolettiX

[12:14] <QtPlatypus> It doesn't use the perfix ,

[12:15] *** PolettiX is now known as frodo72

[12:16] <prefiks> example with < should be better choice ;)

[12:17] *** frodo72 is now known as froh-doh

[12:17] *** frodo72 joined
[12:30] *** elmex joined
[12:43] *** justatheory joined
[12:43] *** Ymmv joined
[12:54] *** avar joined
[12:59] *** gaal joined
[13:00] *** lisppaste3 joined
[13:25] <pasteling> "masak" at 130.238.83.176 pasted "can't make pugs. something with DrIFT.Perl5. here's what it says" (16 lines, 968B) at http://sial.org/pbot/17569

[13:26] <masak> anyone encountered this before?

[13:27] <audreyt> sec

[13:28] <audreyt> kill all .hi and .o files recursively

[13:28] <audreyt> " perl Makefile.PL ; make realclean" should do this if you don't mind wasting a bit time

[13:28] <masak> i'll try

[13:28] <masak> brb

[13:28] <audreyt> otherwise just rm dist/build/src/DrIFT

[13:28] <audreyt> .*

[13:28] <audreyt> and continue make'ing

[13:29] *** oylenshpeegul joined
[13:31] <masak> seems to be working after make'ing realclean. thx

[13:38] *** nothingmuch joined
[13:48] *** oylenshpeegul left
[13:48] *** oozy joined
[13:54] *** apple-gunkies joined
[13:57] *** bjoern_ joined
[14:09] <audreyt> can someone help writing a test for S03?

[14:09] <audreyt> http://www.nntp.perl.org/group/perl.perl6.language/25464

[14:09] <audreyt> in order for it to be implemented in time for release

[14:09] <audreyt> the various "simple" lvalue-carrying-context forms need to be tested

[14:12] *** weinig is now known as weinig|work

[14:26] *** dolmans joined
[14:36] <audreyt> journal up; g'nite *wave8 7

[14:37] <audreyt> journal up; g'nite *wave* &

[15:03] *** Ymmv joined
[15:16] *** rashakil_ joined
[15:18] *** jsiracusa joined
[15:29] *** KingDiamond joined
[15:41] *** lichtkind joined
[15:53] *** weinig|work is now known as weinig

[15:57] <gaal> ouch, gmane doing s/@/[at]/g is painful in code

[15:59] *** iblechbot joined
[16:02] <rindolf> Hi gaal

[16:02] <rindolf> gaal: how was the beach party?

[16:02] <rindolf> gaal: nntp.perl.org does that too.

[16:02] <rindolf> gaal: you can try using NNTP.

[16:04] <gaal> hi rindolf. was great, but I was still a little under the weather. apparently it did me good, because I'm better now.

[16:04] *** weinig is now known as weinig|work

[16:04] <rindolf> gaal: great.

[16:04] <gaal> anyway, that was re: a link I followed. I subscribe to lists I'm interested in, generally speaking

[16:04] <gaal> but this is not important. :)

[16:07] *** amnesiac joined
[16:30] *** cmarcelo joined
[16:35] *** cmarcelo left
[17:02] *** cmarcelo joined
[17:03] *** sri_ joined
[17:32] *** Limbic_Region joined
[17:35] *** elmex_ joined
[17:40] *** elmex joined
[17:41] *** elmex joined
[18:02] *** prefiks joined
[18:18] *** ludan joined
[18:22] *** penk joined
[18:26] *** penk joined
[18:51] *** prefiks joined
[18:55] *** mako132_ joined
[18:57] *** trym joined
[19:00] *** weinig|work_ joined
[19:09] *** trym_ joined
[19:09] *** penk joined
[19:30] *** cognominal joined
[19:47] *** chris2 joined
[19:47] *** weinig|work_ is now known as weinig|work

[19:50] *** macroron joined
[20:03] *** SamB joined
[20:20] *** penk joined
[20:26] *** Captain_Fourier joined
[20:26] <Captain_Fourier> what languages does parrot work with

[20:33] <elmex> :) nice question

[20:34] <Captain_Fourier> no i have a project i want to use it for

[20:34] <elmex> i guess ask the mailing list

[20:34] <Captain_Fourier> but it would be using parrot to turn ocaml into javascript

[20:34] <integral> (there's #parrot on irc.perl.org, that might be more awake, but the ML is good)

[20:34] <integral> Captain_Fourier: umm, that's not what parrot does

[20:35] <integral> parrot's a VM itself, so it can run bytecode produced by compilers.  it's not designed for translating between languages

[20:35] <integral> so you could run ocaml *alongside* javascript if both compiled to parrot bytecode.

[20:36] <Captain_Fourier> oh i thought there was a reversal process where parrot bytecode can be transformed back into the language

[20:36] <cognominal> part of parrot is a parser called pge that impements most of the synopsis 12.  If you want to parse stuff and generate stuff from it, that can be a good bet.

[20:36] <Captain_Fourier> ok

[20:37] <cognominal> In a sense pge is very high level, on the other hand, I am not sure you cam yet use it without knowing the parrot assembler

[20:38] <cognominal> see ./compiler/pge in the parrot distribution

[20:38] <Captain_Fourier> ok

[20:39] <cognominal> anyway you are on the wrong channel. go to #parrot on irc.perl.org

[20:39] *** prefiks joined
[20:39] <Captain_Fourier> ok

[20:41] <cognominal> see http://dev.perl.org/perl6/doc/design/syn/S05.html about the specification of the parser (in the Perl6 realm)

[20:41] <cognominal> it is S05 and not S12. silly me

[20:44] <Captain_Fourier> hmm

[20:44] <cognominal> parrot is moving fast so the tests are often more up to date than the doc

[20:44] <cognominal> so be sure to see ./t/compilers/pge

[20:45] <cognominal> anyway go to #parrot

[20:49] <Captain_Fourier> ok

[21:04] *** weinig|work is now known as weinig

[21:14] <szbalint> TimToady: typo in S03: s/argumetns/arguments/

[21:19] <stevan> audreyt: ping

[21:21] *** elmex joined
[21:27] <Captain_Fourier> ?eval "Hello Channel".split(" ")[0]

[21:27] <evalbot_10557> \"Hello"

[21:37] *** mako132_ joined
[21:49] <beppu> Captain_Fourier: Coincidentally, that line is valid ruby, too.

[21:49] <Captain_Fourier> yeah im wondering which is faster

[21:49] <Captain_Fourier> ruby or perl6

[21:52] <TimToady> audreyt: the following segfaults my pugs: regex Y { [x]? <x>} /a/

[21:53] <TimToady> It seems to be space sensitive.  If I delete the space just inside the {, it doesn't segv.

[21:53] *** mako132_ joined
[21:54] <TimToady> if I change the first x to a . it says

[21:54] <TimToady> error:imcc:syntax error, unexpected '\n', expecting '('

[21:54] <TimToady> in file 'EVAL_1' line 58

[21:54] <TimToady> anyway, this  is the cut-down version of what is coredumping my ext/Perl6-Grammar/t/basic.t test.

[21:57] <TimToady> I haven't cut down the array_cap.t failure, but it gets this error message:

[21:57] <TimToady> error:imcc:syntax error, unexpected ']'

[21:57] <TimToady> in file 'EVAL_22' line 79

[21:57] <TimToady> hth &

[21:59] *** weinig joined
[22:26] *** unobe______ joined
[22:26] *** unobe______ is now known as unobe

[22:33] *** fhork joined
[22:44] *** avar joined
[22:47] *** weinig is now known as weinig|away

[22:47] *** weinig|away is now known as weinig

[22:48] *** weinig is now known as weinig|away

[23:01] <prefiks> ?eval my @a=(1,2,3); @a>>++

[23:01] <evalbot_10557> Error: Can't modify constant item: VInt 1

[23:02] <prefiks> ?eval sub postfix:<!>($arg){ [*] ^$arg};my @a=(1,2,3); @a>>!

[23:02] <evalbot_10557> (0.0, 0.0, 0.0)

[23:02] <prefiks> ?eval sub postfix:<!>($arg){ [*] ^$arg}; 5!

[23:02] <evalbot_10557> 0.0

[23:02] <prefiks> ?eval sub postfix:<!>($arg){ [*] 1..$arg}; 5!

[23:02] <evalbot_10557> 120

[23:02] <prefiks> ?eval sub postfix:<!>($arg){ [*] 1..$arg};my @a=(1,2,3); @a>>!

[23:02] <evalbot_10557> (1, 2, 6)

[23:09] <Captain_Fourier> ?eval sub prefix:<#>($arg) { [++] 'a'..$arg; #'a'

[23:09] <evalbot_10557> Error:  unexpected "p" expecting comment, subroutine parameters, trait or block

[23:10] <Captain_Fourier> ?eval sub prefix:<!>($arg) { [++] 'a'..$arg; !'a'

[23:10] <evalbot_10557> Error:  unexpected "[" expecting comment, ";", statements or "}"

[23:10] <audreyt> ++ is not infix

[23:11] <Juerd> Captain_Fourier: What did you think [++] would mean?

[23:12] <Juerd> Maybe we can suggest an alternative operator that does what you want.

[23:12] <Captain_Fourier> string concatanation

[23:12] <Juerd> Captain_Fourier: That's ~

[23:12] <prefiks> ~

[23:12] <Juerd> So, in list reduction form: [~]

[23:12] <Captain_Fourier> ?eval sub prefix:<!>($arg) { [~] 'a'..$arg; !'a'

[23:12] <evalbot_10557> Error:  unexpected end of input expecting term postfix, comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or "}"

[23:12] <Captain_Fourier> ?eval sub prefix:<!>($arg) { [~] 'a'..$arg; !'g'

[23:12] <Juerd> Now I do wonder where you got ++ for strings from :)

[23:12] <evalbot_10557> Error:  unexpected end of input expecting term postfix, comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or "}"

[23:12] <audreyt> ?eval sub prefix:<!>($arg) { [~] 'a'..$arg }; !'g'

[23:12] <Juerd> Captain_Fourier: That probably doesn't work, for two reasons.

[23:12] <Captain_Fourier> ?eval sub prefix:<!>($arg) { [~] 'a'..$arg;} !'g'

[23:12] <evalbot_10557> "abcdefg"

[23:12] <Juerd> You're missing the closing }

[23:12] <evalbot_10557> "abcdefg"

[23:13] <Juerd> And you probably can't use an operator WHILE defining it, but I'm not sure about that.

[23:13] <Captain_Fourier> recrusive operators!

[23:15] <Juerd> ?eval sub postfix:<!>($n) { $n == 1 ?? 1 :: $n * ($n - 1)! } 4!

[23:15] <evalbot_10557> Error:  unexpected ":" expecting comment, operator or "!!"

[23:15] <Juerd> Heh

[23:15] <Juerd> Nice that it explicitly mentions !! in the error message :)

[23:15] <Juerd> ?eval sub postfix:<!>($n) { $n == 1 ?? 1 !! $n * ($n - 1)! } 4!

[23:15] <evalbot_10557> Error:  unexpected "!" expecting term postfix, comment, operator, ">>+&<<", ">>+<<<", ">>+><<", ">>xx<<", ">>~&<<", ">>~<<<", ">>~><<", ">>%<<", ">>*<<", ">>/<<", ">>x<<", "\187+&\171", "\187+<\171", "\187+>\171", "\187xx\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187%\171", "\187*\171", "\187/\171", "\187x\171", "+&", "+<", "+>", "xx", "~&", "~<", "~>", "%", "*", "/", "x", "??", postfix conditional, postfix loop, postfix iteration, ";" or "

[23:15] *** bjoern_h joined
[23:16] <Juerd> Not nice that it mentions almost the entire language now ;)

[23:16] <Juerd> ?eval sub postfix:<!>($n) { $n == 1 ?? 1 !! $n * ($n - 1)! }; 4!

[23:16] <evalbot_10557> Error:  unexpected "!" expecting term postfix, comment, operator, ">>+&<<", ">>+<<<", ">>+><<", ">>xx<<", ">>~&<<", ">>~<<<", ">>~><<", ">>%<<", ">>*<<", ">>/<<", ">>x<<", "\187+&\171", "\187+<\171", "\187+>\171", "\187xx\171", "\187~&\171", "\187~<\171", "\187~>\171", "\187%\171", "\187*\171", "\187/\171", "\187x\171", "+&", "+<", "+>", "xx", "~&", "~<", "~>", "%", "*", "/", "x", "??", postfix conditional, postfix loop, postfix iteration, ";" or "

[23:16] <audreyt> fixing that ;)

[23:16] <Juerd> And wow, >>x<< are all different ops :)

[23:16] <audreyt> write a test? actually

[23:16] <Captain_Fourier> recursively defined operators would be interesting

[23:17] <audreyt> Captain_Fourier: write a test for that?

[23:17] <Juerd> Captain_Fourier: Certainly, but I wonder how they could be parsed :)

[23:17] <Captain_Fourier> ok

[23:17] <Captain_Fourier> is there a guide for writing a test

[23:17] <audreyt> and do you have a commit bit yet? if not, may I hve your email plase

[23:17] <Juerd> That means you need to install the parsing bit immediately when the signature is known :)

[23:17] <Juerd> Captain_Fourier: Just look at the other tests

[23:17] <Captain_Fourier> commit bit?

[23:18] <Juerd> Captain_Fourier: In general, you write: ok(test, "it works"), where test is a boolean expression, and "it works" is a somewhat better description than "it works".

[23:18] <audreyt> Captain_Fourier: the username/passwd for checking in into http://svn.openfoundry.org/pugs/

[23:18] <Juerd> Captain_Fourier: A commit bit means you get to commit the test into pugs yourself.

[23:18] <Captain_Fourier> yeah i dont have that

[23:19] <Juerd> Captain_Fourier: Which means you don't have to waste audreyt's time by sending a patch, that she than has to apply: you're getting write access to pugs so you can do it yourself :)

[23:19] <audreyt> I can send you one. which email addr should I send it to?

[23:19] <Juerd> Captain_Fourier: You'll get one :)

[23:19] <Captain_Fourier> [email@hidden.address]
[23:19] <Captain_Fourier> i think i just guarenteed spam from that email

[23:20] * Juerd was, a year or so ago, very surprised about the commit bit policy surrounding pugs, but nowadays thinks it's weird that so few projects work like this :)

[23:20] <Juerd> Captain_Fourier: Indeed :)

[23:20] <Juerd> But no worries - you'd get spam sooner or later anyway

[23:20] <Captain_Fourier> ok

[23:20] <Juerd> At least now you have something to blame for it

[23:21] <Captain_Fourier> yeah

[23:22] *** cognominal joined
[23:22] <audreyt> Captain_Fourier: do you already have a svn checkout of pugs?

[23:22] <Captain_Fourier> i have a darcs checkout

[23:22] <audreyt> oh ok. sadly darcs is readonly

[23:22] <audreyt> I kept meaning to improve that with svk's tailor.py support

[23:23] <audreyt> (or remedying the lack of)

[23:23] <obra> audreyt: that might make a good hackathon target

[23:23] <Captain_Fourier> tailor is great svn->darcs

[23:23] <audreyt> but for the time being, please do a svn checkout too

[23:23] <Captain_Fourier> not the other way

[23:23] <Captain_Fourier> ok

[23:23] <audreyt> obra: not without clkao present

[23:23] <clkao> need a python/perl bilingual to do darcs

[23:23] <obra> audreyt: conveniently, that won't be a problem

[23:23] <clkao> audreyt: i will be in boston after yapc

[23:23] <clkao> ;)

[23:23] <obra> We'll have him until 9 july

[23:23] <audreyt> ooooh!

[23:24] <obra> Thanks to Best Practical

[23:24] <obra> "Now it's a corporate priority to have him here for hackathons"

[23:24] * audreyt blames, er, annotates, er, praises Best Practical

[23:24] <obra> clkao: should we tell #perl6 about the thing we need to announce on monday?

[23:25] <Juerd> audreyt: I was wondering why darcs is still used for pugs

[23:25] <audreyt> Juerd: so we can get a constant influx of committers that uses ++ for string concat

[23:25] <Juerd> audreyt: They'd probably have used svn or svk if darcs wasn't there

[23:26] <audreyt> I doubt that, really :)

[23:26] <Captain_Fourier> im sorry i like darcs

[23:27] <audreyt> Captain_Fourier: no need to be sorry, lotsa people here prefer darcs to svn

[23:27] <audreyt> me included

[23:27] <Captain_Fourier> plus i probably wouldnt have tried pugs if i didnt have ghci installed

[23:27] <audreyt> *nod*

[23:27] <audreyt> Captain_Fourier: btw, commit bit sent, check your email; try adding yourself to AUTHORS and commit it

[23:28] <audreyt> welcome aboard :)

[23:28] <Juerd> Yay, committers++

[23:28] <Juerd> (Both in the karma and in the +=1 sense)

[23:30] <audreyt> Captain_Fourier: so maybe write a t/operators/recursive_definition.t

[23:30] <audreyt> look at other tests in the same dir for how

[23:32] <Captain_Fourier> ok

[23:33] *** cognominal joined
[23:36] <Captain_Fourier> so my test would go into that file

[23:38] <audreyt> yup

[23:39] <Captain_Fourier> ok cool will do

[23:39] <audreyt> Captain_Fourier++

[23:44] <audreyt> I need to run for a bit... be back in ~6 hours, hopefully with lots of offline commits :)

