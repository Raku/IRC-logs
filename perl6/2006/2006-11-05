[00:09] <buu> Hello Limbic_Region !

[00:14] <Limbic_Region> salutations buu

[00:36] *** mbradley|afk joined
[00:37] <pasteling> "audreyt" at 200.150.229.66 pasted "patch for cmarcelo" (229 lines, 9.6K) at http://sial.org/pbot/20896

[00:37] *** jferrero joined
[00:39] <audreyt> @tell cmarcelo http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

[00:39] <lambdabot> Consider it noted.

[00:51] <audreyt> C3 MOH bootstrapped :)

[00:51] <svnbot6> r14621 | lwall++ | \x and \o were incorrect

[00:51] <audreyt> almost ready to be included back to pugs/src/

[00:52] <Limbic_Region> wow

[00:52] <Limbic_Region> audreyt++

[00:52] <audreyt> so we can have RealClasses

[00:52] <audreyt> it's actually mostly cmarcelo's work :)

[00:52] <audreyt> well, based on nothingmuch's.

[01:02] <Limbic_Region> cmarcelo++ nothingmuch++

[01:20] *** dmq joined
[01:28] *** whatitsnot joined
[01:29] *** whatitsnot left
[01:36] <jrockway> what mailing list should i send patches to? (regarding openbsd support)

[01:36] <TimToady> patches to what?

[01:46] <anatolyv> TimToady: yet another parsing question to aid my imperfect understanding of S02, if I may :) What, in terms of grammatical categories are declarators such as "my" and "sub"?

[01:46] <TimToady> scope_declarator

[01:47] <anatolyv> TimToady: oh. But I thought scope_declarators, like "has $x", cannot appear arbitrarily inside expressions, but only at about the same place as control structures? (that's why I had them pegged as prefix:<> instead)

[01:47] <anatolyv> TimToady: or should I be able to say "3 + has $x" ?

[01:48] <TimToady> in theory you can do that.

[01:48] <TimToady> but don't...

[01:48] <TimToady> more often you see "my" in the middle of an expression.

[01:48] <TimToady> but "state" also has its uses.

[01:48] <TimToady> as does "constant"

[01:49] <anatolyv> is there a difference then between prefix: and scope_declarator:, in terms of places where one can be expected but not the other?

[01:50] <TimToady> not really any difference that I can think of.  Just like to keep the declarational macros separated out from the ordinary functions is all.

[01:50] <ingy> hi all

[01:50] <TimToady> ingy!

[01:51] <ingy> hi TimToady

[01:51] *** loumz joined
[01:51] <anatolyv> great, thanks for clearing that up.

[01:52] <TimToady> basically things in prefix: should be ordinary operator precedence stuff.

[01:52] * ingy just got back from running the Dublin Marathon

[01:52] <ingy> soo glad that traveling is over for a while

[01:52] <TimToady> whereas in "state $x = 2" it's eating up the = as a macro

[01:53] <anatolyv> it is? but can't it just be stopped from eating the = based on its precedence, and then = applied normally after the macro did its thing?

[01:54] <TimToady> the = has to run at a different time than ordinary =

[01:54] <TimToady> for "state" it happens at "FIRST" time.

[01:54] <TimToady> for "has" it happens at "BUILD" time.

[01:54] <TimToady> for "constant" it happens at "BEGIN" time

[01:55] <TimToady> in fact, "my" is about the only one that coincides with normal assignment time.

[01:55] <TimToady> well, "our" too.

[01:56] <audreyt> jrockway: please simply commit

[01:56] <audreyt> jrockway: I'm pretty sure you have a commit bit :)

[01:56] <TimToady> does

[01:56] <anatolyv> but = could also be := and ::=, right? the macro just has to eat all the variants?

[01:56] <TimToady> I was just trying to ascertain it was inside pugs/

[01:56] <audreyt> I think it only eats =

[01:58] <TimToady> well, by definition ::= gets eaten immediately at compile time...

[01:58] <TimToady> but perhaps not by the macro

[01:59] <audreyt> in pugs, currently infix:<=> macro checks lhs to see if it's a state decl

[02:00] <audreyt> which seems cheaper and more cheerful as it does not involve custom parsing

[02:01] <TimToady> ?eval 1 + state $x = 42

[02:01] <evalbot_r14621> Error: Can't modify constant item: VInt 1

[02:01] <anatolyv> so it's a macro specifically for this purpose, but for other things it acts as a normal op?

[02:01] <anatolyv> actually i guess it has to check for the simple_lvalues things too

[02:01] <audreyt> TimToady: prec

[02:02] <TimToady> my point

[02:02] <audreyt> $ perl -e '1 + my $x = 42'

[02:02] <audreyt> Can't modify addition (+) in scalar assignment at -e line 1, at EOF

[02:02] <audreyt> anatolyv: = is never a normal op :)

[02:02] <TimToady> let's not get all theological here. :)

[02:03] <TimToady> ?eval 1 + state ($x) = 42

[02:03] <evalbot_r14621> Error: Can't modify constant item: VNum 2.0

[02:04] <TimToady> ?eval 1 + print 42

[02:04] <evalbot_r14621> OUTPUT[42] 2.0

[02:04] <anatolyv> audreyt: hmm, yeah, silly me

[02:05] <audreyt> hm, I just discovered that 1)the p6 talk is tomorrow 9am not 1pm and 2)daylight saving begins tomorrow which may reduce 1 hour of sleep and 3)it's midnight here

[02:05] <TimToady> ?eval 1 + state ($x, $y, $z) = 1,2,3;

[02:05] <evalbot_r14621> Error: Can't modify constant item: VNum 4.0

[02:05] <audreyt> TimToady: infix:<=> was consistently seeing a infix:<+> at lhs, not state, so it does nothing

[02:06] <audreyt> and so it became simply 1+($,$,$) which is 1+3

[02:06] <TimToady> this is inconsistent with other list operators...

[02:06] <TimToady> and arguably state($$$)= is a listop

[02:06] <audreyt> but 1+ binds tighter, no?

[02:06] <TimToady> ?eval 1 + print 1,2,3

[02:06] <evalbot_r14621> OUTPUT[123] 2.0

[02:06] <audreyt> than =

[02:07] <TimToady> ?eval my $x ~~ s[foo] = 42

[02:07] <evalbot_r14621> Bool::False

[02:08] <audreyt> right. so your idea is that state($$$)= is diferent from my($$$)=

[02:08] <audreyt> and it functions as a s[]=

[02:08] <TimToady> I based the argument for that partly on the assumption that state()= ate the =

[02:08] <audreyt> but I think state($$$)= is a bit too magical

[02:08] <TimToady> the consistent pattern is that declarator($$$)= is different. except "my" and "our" happen to work out the same.

[02:09] <audreyt> uhm.

[02:09] <audreyt> so you mean

[02:09] <audreyt> 1 + my($$$) = ...

[02:09] <audreyt> parses as

[02:09] <audreyt> 1 + (my($$$) = ...)

[02:09] <audreyt> but

[02:09] <audreyt> 1 + ($$$) = ...

[02:09] <audreyt> parses as

[02:09] <audreyt> (1 + ($$$)) = ...

[02:09] <audreyt> ?

[02:09] <TimToady> yes

[02:10] <audreyt> that departs from perl5 :)

[02:10] <TimToady> declarators have an optional = argument

[02:10] <TimToady> what is this perl5 thing you keep mentioning?

[02:10] <audreyt> S03:1337 wants a revamp then

[02:10] <TimToady> well, some declarator have =

[02:10] <audreyt> I'm fine as long as my() and state() parses the same way

[02:11] <audreyt> i.e.

[02:11] <audreyt> 1 + my($$$) = ...

[02:11] <audreyt> 1 + state($$$) = ...

[02:11] <audreyt> should not parse differently

[02:11] <TimToady> and "has" and "constant"

[02:11] <anatolyv> TimToady: so all declarators are listops and bind tighter than everything else to the left?

[02:11] <TimToady> not quite

[02:11] <audreyt> anatolyv: no; more think declarator and = having a ?? !! relationship.

[02:12] <audreyt> i.e. = is not parsed in infix but as part of decl term

[02:12] <audreyt> I'd be happy to implement it if it's specced that way :)

[02:12] <TimToady> and "my $x = 1" still parses = like scalar assign, not list assign.

[02:12] <audreyt> but

[02:12] <audreyt> 1 + my $x = 1

[02:12] <audreyt> is now 2, not error

[02:12] <audreyt> which makes sense.

[02:13] <svnbot6> r14622 | jrockway++ | change p5embed to not use __init symbol on OpenBSD (conflict with standard C library)

[02:14] * ingy attempts to install ghc again

[02:15] <jrockway> the real question is, what other OSes also choke on __init

[02:16] <ingy> jrockway: that's not a real question...

[02:16] <ingy> it needs a question mark

[02:16] <jrockway> heh :)

[02:17] <jrockway> s/the real question/what i'm wondering out loud about/

[02:17] <gnuvince> speaking of question marks, will Perl 6 support question marks in function names?

[02:17] <jrockway> ah, as per lisp?

[02:17] <gnuvince> s/support/allow/

[02:17] <jrockway> that would be nice, actually

[02:17] <gnuvince> jrockway: yeah

[02:18] <TimToady> not unless you redefine <ident>

[02:18] <anatolyv> TimToady: what's <ident> like currently (and is it specced)?

[02:18] *** fab_ joined
[02:19] <TimToady> or define postfix:<?>

[02:19] <TimToady> which is probably more what you want

[02:19] <ingy> my @answers = what_other_OSes_also_choke_on___init?();

[02:20] <gnuvince> TimToady: I was thinking: $banker.jump_of($bridge) if $banker.broke?

[02:20] <gnuvince> s/of/off

[02:21] <anatolyv> if function names can be in whatever languages, why not also ? and whatever non-whitespace characters in general?

[02:21] <svnbot6> r14623 | audreyt++ | * fix broken svk:merge point.

[02:21] <ingy> compiling ghc makes my laptop noisy

[02:21] <jrockway> i think the ? is more of an identifier than an operator in this case

[02:21] <TimToady> ?eval sub postfix:<?> ($x) { Bool($x) }; if 42? { say "The Answer" }

[02:21] <evalbot_r14622> Error: No compatible subroutine found: "&Bool"

[02:22] <TimToady> ?eval sub postfix:<?> ($x) { ?($x) }; if 42? { say "The Answer" }

[02:22] <evalbot_r14622> OUTPUT[The Answer‚ê§] Bool::True

[02:22] <jrockway> i think he wants something like:

[02:22] <svnbot6> r14624 | audreyt++ | * Pugs.Parser.Types: insertIntoPosition now takes a String, not Char,

[02:22] <svnbot6> r14624 | audreyt++ |   so we can more freely conjure snippets that user had not written

[02:22] <svnbot6> r14624 | audreyt++ |    from thin air.

[02:22] <jrockway> sub false?($x) { return !$x; }

[02:23] <jrockway> if false?(0) { say "false" }

[02:23] <jrockway> that ends up looking prettier in scheme, though :)

[02:23] <audreyt> that's trivial

[02:23] <audreyt> ?eval sub prefix:<false?> ($x) { !$x }; false? 0

[02:23] <evalbot_r14622> Bool::True

[02:23] <audreyt> the nontrivial part is to make it into method name

[02:24] <TimToady> ?eval self.'what?'

[02:24] <evalbot_r14622> Error: ‚ê§Unexpected "'"‚ê§expecting ".", "\187", ">>", "=", operator name, qualified identifier, variable name, "...", "--", "++", array subscript, hash subscript or code subscript

[02:24] <audreyt> unimplemented.

[02:24] <audreyt> but yes, that's trivial solution :) ugly though

[02:25] <jrockway> the syntax also implies something like sub foo { return "something" } is related to foo? such that sub foo? { return Bool(foo()) }

[02:25] <audreyt> though you can do something like

[02:25] <audreyt> macro term:<what?> { "'what?'" }

[02:25] <audreyt> er I mean

[02:25] <audreyt> macro postfix:<.what?}

[02:26] <audreyt> macro postfix:<.what?> ($lhs) { "$lhs.'what?'" }

[02:27] <TimToady> I think it's a little silly to advertise "I am a boolean" in a language where anything can be a boolean.

[02:28] <jrockway> true

[02:28] <avar> ?eval sub circumfix:<is true?> ($x) { Bool($X) }; is 42 false?

[02:28] <evalbot_r14624> Error: ‚ê§Unexpected "false"‚ê§expecting operator, ":" or ","

[02:28] <TimToady> we also didn't borrow Ruby's mutator syntax.

[02:28] <avar> ?eval sub circumfix:<moo true?> ($x) { Bool($X) }; moo 42 false?

[02:28] <evalbot_r14624> Error: ‚ê§Unexpected "false"‚ê§expecting operator, ":" or ","

[02:28] <avar> meh:)

[02:28] <audreyt> you defined true and you expect false to work

[02:28] <audreyt> how does that add up :)

[02:28] <gnuvince> TimToady: mutators?

[02:29] <jrockway> DWIM :)

[02:29] * avar likes ruby's mutators:)

[02:29] <TimToady> are spelled @array.=sort

[02:29] <anatolyv> DWIMHM

[02:29] <TimToady> not @array.sort!

[02:29] <gnuvince> ah

[02:30] <audreyt> actually .= does double dispatch

[02:30] <audreyt> first to self:<sort>

[02:30] <audreyt> then slowly fallback to normal assignment

[02:30] <avar> i.e. .= is cool too:)

[02:30] <gnuvince> Yeah

[02:30] <TimToady> ever so slowly...like leaves falling...

[02:30] <gnuvince> More general than x.foo!

[02:30] <TimToady> my Dog $x .= new;

[02:31] *** hexmode joined
[02:31] <avar> just as long as you can get an automagic in-place or with-a-copy version of every function I'm all for it (not that anyone's asking:)

[02:31] <svnbot6> r14625 | audreyt++ | * Pugs.Parser: Adjust for the insertIntoPosition change.

[02:31] <audreyt> TimToady: though with the ::Dog() construction syntax, this is easier:

[02:31] <audreyt> my Dog $x .= ();

[02:32] <TimToady> heh

[02:32] <audreyt> my Point $pt .= (x => 1, y => 2);

[02:32] <audreyt> that's almost pretty

[02:32] <audreyt> and even Just Works

[02:32] <TimToady> I take your Point

[02:33] <TimToady> it's also why chomp changed to return the chomped string.

[02:33] * audreyt updates her slides to take out all the "new"

[02:33] <TimToady> to chomp in place is now $str.=chomp

[02:34] <TimToady> my Array $a .= [Int]

[02:35] <anatolyv> audreyt: how's .= work with declarators - the way you described = as working? is .= a special macro just for that or  infix_postfix_meta_operator:<=> is doing the job?

[02:38] <audreyt> anatolyv: well I described TimToady's latest vision that I wasn't aware of until just an hour ago :)

[02:38] <svnbot6> r14626 | audreyt++ | * Pugs.Parser: The previous commit also support rule-as-methods:

[02:38] <svnbot6> r14626 | audreyt++ |     grammar G {

[02:38] <svnbot6> r14626 | audreyt++ |         rule r { ... }

[02:38] <svnbot6> r14626 | audreyt++ |     }

[02:38] <svnbot6> r14626 | audreyt++ |     G.r('text'); # same as 'text' ~~ /<G::r>/.

[02:39] <audreyt> but according to that vision then declarator must pretty much eat all assigment forms

[02:39] <audreyt> my $x += 3

[02:39] <audreyt> my $x .= moose

[02:39] <audreyt> etc etc, are all parsed tighter than usual

[02:39] <TimToady> still thinking about whether macroized = eating is going to make any practical difference.

[02:40] <TimToady> state Moose $m .= () probably want to happen at "first" time

[02:42] <TimToady> on the other hand most other mutators don't make much sense on undefs

[02:44] <TimToady> and arguably "state $x += 2" is probably intended to start at 0/undef and incinc every time

[02:44] <TimToady> but it's hard to make an exception for .= and not for other assignops

[02:44] <TimToady> (as in hard to teach)

[02:45] *** brent[] left
[02:45] <TimToady> so maybe we don't make an exception, and you have to use = to get "state Moose $m = Moose()"

[02:47] <TimToady> or we go the other way, and require people to write (state $x) += 2 to force run-time eval.

[02:48] <TimToady> then we get "state Moose ($m, $n) >>.=<< ()

[02:49] <TimToady> and all the .= happen at first time

[02:50] <TimToady> or "state Moose ($m,$n)>>.=() in postfix form

[02:50] <TimToady> except that's not really an assignment at all now, syntactically...

[02:50] <audreyt> I think specialize only on = makes sense

[02:51] <audreyt> because = is already maximally magical

[02:51] <TimToady> but we decided the other way on s[\d+] += 2

[02:51] <audreyt> and localizing magic makes it easier to reason about things

[02:51] <audreyt> but s[] does not have a base form

[02:51] <audreyt> while people may reasonably expect

[02:51] <audreyt> ... my($x) ...

[02:51] <audreyt> parse similarily to

[02:51] <audreyt>  ... $x ...

[02:52] <audreyt> s[] has no such problem because nobody will expect

[02:52] <audreyt> ... s[foo] ...

[02:52] <audreyt> parse the same as

[02:52] <audreyt> ... foo ...

[02:52] <audreyt> in that sense s[] is not circumfix

[02:52] <audreyt> and state() is

[02:53] <TimToady> well, let's leave it the way it is for now.

[02:53] <audreyt> *purr*

[02:53] * audreyt rests in peace having learned state($world) havn't changed parsing yet

[02:54] <TimToady> that does, however, imply that infix:<=> has to somehow know about all declarators...

[02:54] <TimToady> and the natural place to add the weirdity is in the declarator macro

[02:54] <audreyt> not so

[02:55] <audreyt> the AST carries a scope_declarator:<>

[02:55] <audreyt> and whatever inside :<> does not matter

[02:55] <audreyt> they'll always be constructed by a call to s_d:<something>

[02:55] <audreyt> and i:<=> acts on that

[02:55] <TimToady> okay, I guess that works

[02:55] <audreyt> yay

[02:57] <audreyt> we can even spec that s_d if multi on 2arg then i:<=> call it with 2nd being rhs and let it handle otherwise assume normal =

[02:57] <audreyt> </incoherent_rant>

[02:57] <audreyt> *wave* &

[03:08] *** Excedrin joined
[04:55] *** shobadobs joined
[04:59] *** Limbic_Region joined
[05:14] *** bennymack joined
[05:30] <Limbic_Region> TimToady ping

[05:34] <Limbic_Region> @tell TimToady I know you backlog and the @tell is likely not necessary but please feel free to update examples/algorithms/fibonacci_memoization.pl

[05:34] <lambdabot> Consider it noted.

[05:45] *** Psyche^ joined
[05:45] *** eggzeck joined
[05:52] <gaal> @tell fglock if shopping for an editor, try FTE - it's a powerful non-unixy moose (I used to run it on OS/2...). has many languages and does ctags etc.

[05:52] <lambdabot> Consider it noted.

[05:53] *** Psyche^ is now known as Patterner

[05:57] <svnbot6> r14627 | lwall++ | A little honing of fib().

[06:10] <svnbot6> r14628 | lanny++ | * fibonacci_tail_call to match fibonacci_memo

[06:15] *** BooK_ joined
[06:28] <svnbot6> r14629 | lanny++ | * Have fibonacci examples return the fibonacci sequence instead of sequence [ fib(n) | n=2.. ]

[06:40] <avar> ?eval [ 1 .. 10 ]

[06:40] <evalbot_r14629> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

[06:40] <avar> ?eval [ 1 .. 10:by(2) ]

[06:40] <evalbot_r14629> Error: ‚ê§Unexpected "["‚ê§expecting program

[06:41] <avar> ?eval [ (1 .. 10):by(2) ]

[06:41] <evalbot_r14629> Error: ‚ê§Unexpected "["‚ê§expecting program

[06:42] <avar> for 1 .. 10 :by(2) -> $i { say $i }

[06:42] <avar> ?eval for 1 .. 10 :by(2) -> $i { say $i }

[06:42] <evalbot_r14629> Error: ‚ê§Unexpected ":by"‚ê§expecting operator or block construct

[06:42] <TimToady> :by is not implemented

[06:42] <lambdabot> TimToady: You have 1 new message. '/msg lambdabot @messages' to read it.

[06:53] <TimToady> ?eval sub fib (Int $n) { (state @seen = 0,1,1).[$n] //= fib($n-1) + fib($n-2); } fib(10)

[06:53] <evalbot_r14629> \55

[06:55] <TimToady> audreyt: the preceding fib does not seem to memoize correctly.

[06:56] *** esstone joined
[06:58] <TimToady> ?eval sub fib (Int $n) { state @seen = 0,1,1; @seen[$n] //= fib($n-1) + fib($n-2); } fib(10)

[06:59] <evalbot_r14629> \55

[06:59] <TimToady> that doesn't memoize either.

[07:01] <TimToady> it's always setting @seen back to 3 elements.

[07:10] <svnbot6> r14630 | lwall++ | fib with UInt guard and memo state initialization

[07:11] <TimToady> @tell audreyt aforementioned bug now infests examples/algorithms/fibonacci_memoization.pl

[07:11] <lambdabot> Consider it noted.

[07:18] *** elmex joined
[07:29] *** norageek joined
[07:31] *** Southen joined
[07:42] *** penk joined
[07:51] *** SubStack joined
[08:13] *** iblechbot joined
[08:13] *** Excedrin joined
[08:24] *** crem joined
[08:54] *** larsen_ joined
[09:19] *** ruz joined
[09:59] *** penk joined
[10:02] *** Excedrin joined
[10:17] *** buetow joined
[10:33] *** ludan joined
[10:43] *** Excedrin joined
[10:43] <svnbot6> r14631 | rnhainsworth++ | test for modifying a scalar inside a v5 block

[10:43] <svnbot6> r14630 | lwall++ | fib with UInt guard and memo state initialization

[11:00] *** ezraburgh joined
[11:07] *** ruoso joined
[11:10] *** kanru joined
[11:14] *** xinming_ joined
[11:19] *** turrepurre joined
[11:21] *** Excedrin joined
[11:33] *** elmex joined
[11:34] *** Psyche^ joined
[11:36] *** turrepurre joined
[11:37] *** kanru joined
[11:46] *** Psyche^ is now known as Patterner

[12:15] *** kanru joined
[12:47] *** rodi joined
[12:51] *** kanru joined
[12:54] *** diakopter joined
[12:58] *** Psyche^ joined
[13:12] *** Psyche^ is now known as Patterner

[13:27] *** BooK joined
[14:05] *** Excedrin joined
[14:10] *** autark_ joined
[14:14] *** Limbic_Region joined
[14:27] *** anatolyv joined
[14:28] *** xinming_ is now known as xinming

[14:35] *** stevan_ joined
[14:37] *** fglock joined
[14:38] *** cmarcelo joined
[14:46] <cmarcelo> @tell audreyt I pushed mi.t equivalent for MOH. Now Roles are on the way. I'll leave Sao Paulo tonight around 9-10pm, so if afternoon you have time i'll be happy to see how/where this will get into pugs

[14:46] <lambdabot> Consider it noted.

[14:48] *** diakopter joined
[14:49] *** FOAD joined
[14:50] <FOAD> Hey, so is autovivication of rvalues going away in Perl 6 pretty please?

[14:50] <Cugel> You could always write a patch.

[14:51] <FOAD> Um, right.

[14:52] <FOAD> I'm just a user, man.

[14:55] <audreyt> right

[14:55] <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.

[14:55] <audreyt> FOAD: autovivification in Perl 6 in ravlue position is gone.

[14:56] <FOAD> That's good to hear.  Thank you.

[14:56] <audreyt> ?eval my %x; 1+%x{'does not vivify'}; %x.keys

[14:56] <evalbot_r14631> ()

[14:57] <audreyt> FOAD: please see http://perlcabal.org/syn/S09.html#Autovivification

[14:57] <lambdabot> Title: S09, http://tinyurl.com/y8gwf8

[14:58] <audreyt> cmarcelo: ok, let's hack after lightning talks

[14:59] <FOAD> Most interesting, thanks again.

[15:00] <audreyt> actually, we don't yet have tests in autovivification.t that covers all the rvalue nonvivify cases

[15:00] <audreyt> would be be interested in writing them? if so give me your email address and I'll send you a commit bit :)

[15:01] <cmarcelo> audreyt: nice. tks :)

[15:01] <lambdabot> cmarcelo: You have 2 new messages. '/msg lambdabot @messages' to read them.

[15:01] <cmarcelo> @moosages

[15:01] <lambdabot> audreyt said 18h 23m 5s ago: we are in the lobby and I'm rsync'ing my entire /Applications/ to fglock. come join us!

[15:01] <lambdabot> audreyt said 14h 22m 17s ago: http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

[15:01] <audreyt> cmarcelo: try to get at least some of the Role stuff sketched :)

[15:01] <audreyt> so we'll have a Compelling Use Case

[15:01] <audreyt> and more t/oo/ can pass :)

[15:02] <cmarcelo> okie dokie

[15:02] <FOAD> I'm sorry, I probably lack the necessary skills.

[15:02] <audreyt> anyone who has the vocabulary of "rvalue" and "autovivifi has such skillscation"

[15:03] <audreyt> it involves: read http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Hack.pod and edit one file and commit it back :)

[15:03] <lambdabot> Title: Pugs::Doc::Hack - How to hack on Pugs - search.cpan.org, http://tinyurl.com/yjq4uw

[15:03] <audreyt> the file in question is

[15:03] <audreyt> the file in question is http://svn.openfoundry.org/pugs/t/var/autovivification.t

[15:03] <lambdabot> http://tinyurl.com/ye7o2w

[15:03] <audreyt> see if it makes some sense to you?

[15:04] <FOAD> Okay..

[15:04] * FOAD reaqds.

[15:04] *** stevan__ joined
[15:04] <audreyt> hm, the IRC control characters was eaten. I meant to say "anyone who has the vocabulary of 'rvalue' and 'autovivification' has the neccessary skills :)"

[15:04] <Limbic_Region> FOAD - and you can commit something incredibly trivial and it can take on a life of its own

[15:04] * Limbic_Region was suprised to see the number of commits against fibonacci

[15:05] <FOAD> Okay, I'll give it a try.

[15:07] <audreyt> woot! what's your email addr?

[15:08] *** fglock joined
[15:08] <FOAD> I can't message you, apparently.

[15:08] <audreyt> try scramble it somehow.

[15:08] <audreyt> foo at bar dot org etc

[15:08] <audreyt> freenode requires nickserv registation to /msg

[15:08] <FOAD> dok at xs4all dot nl

[15:08] <FOAD> Yeah I noticed.

[15:08] <audreyt> welcome aboard! please edit to AUTHORS file

[15:08] <audreyt> and then commit it as your first commit

[15:09] <audreyt> to test that svn works

[15:10] <fglock> audreyt: what is the url to send commit bits?

[15:10] <lambdabot> fglock: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:10] <FOAD> Cool.

[15:10] <Limbic_Region> fglock - you aren't an admin yet?

[15:11] <Limbic_Region> if audreyt hasn't already done so - I will change your status now

[15:11] <fglock> Limbic_Region: I am, there is a new shortcut to send invitations

[15:12] <audreyt> fglock: http://commitbit.pugscode.org/

[15:12] <audreyt> I've done so :) (that's what "welcome aboard" means)

[15:12] <audreyt> oh, you mean flag fglock

[15:12] <audreyt> sorry lost context

[15:13] <fglock> thanks

[15:13] <Limbic_Region> no worries

[15:13] <Limbic_Region> I was confused as to the question anyway

[15:13] <audreyt> fglock: so all LT speakers will use one computer?

[15:13] <audreyt> I'll bring my USB key downstairs in a bit. preferably I can play it as .mov

[15:14] <Limbic_Region> fglock - do you know mk?

[15:14] <fglock> audreyt: ok

[15:14] <fglock> Limbic_region: yes

[15:15] <nothingmuch> mer

[15:15] <Limbic_Region> I didn't realize you guys had such a large contingent (or legion) of perl hackers down there

[15:15] <Limbic_Region> or rather - that you were all connected

[15:16] <fglock> we have Brasil-PM, and then a bunch of local groups

[15:16] <Limbic_Region> merlyn has mentioned how nice things are as well

[15:17] <fglock> thanks!

[15:17] <audreyt> merlyn wants to move here :)

[15:17] <audreyt> I will, if I speak Portuguese

[15:18] * fglock <-- Brasil-PM leader :)

[15:18] <Limbic_Region> fglock++

[15:18] <audreyt> I can learn, but then that'll distract me from Perl6... although TimToady says learning Japanese kept him sane so he can conitnue with Perl6

[15:18] <Limbic_Region> I think I will make it down there in the next year or two then

[15:18] <fglock> Limbic_Region: that would be nice

[15:21] <fglock> audreyt: see you in ~10min?

[15:21] <audreyt> 5min.

[15:21] <fglock> k

[15:21] * audreyt can't find her blush powder anywher eand finally gives up

[15:21] * Limbic_Region doesn't think he would have a hard time learning the language but might have a hard time convincing his family to move

[15:22] <Limbic_Region> audreyt - women who think they need makeup to look pretty haven't found the right SO (IMO)

[15:24] <audreyt> Limbic_Region: it's not looking pretty, it's about the mental focus inherent in the medidative process

[15:25] <audreyt> lightning talk, bbiab &

[15:25] <Limbic_Region> good luck

[15:25] <cmarcelo> nothingmuch: ping

[15:26] <nothingmuch> cmarcelo: pong

[15:28] <anatolyv> hey nothingmuch

[15:28] <anatolyv> or rather, yo

[15:28] <nothingmuch> yo homie

[15:29] <nothingmuch> werd to yo mama

[15:29] * nothingmuch looks at cmarcelo 

[15:30] <Limbic_Region> y tu madre tambien?

[15:34] *** rodi joined
[15:34] *** Limbic_Region left
[15:42] *** fglock joined
[15:48] <svnbot6> r14632 | lanny++ | UInt guard on fibonacci_tail_call

[15:52] <ingy> hola

[16:03] <svnbot6> r14633 | lwall++ | make params consistently UInt

[16:14] *** prism joined
[16:18] *** idiotmax joined
[16:21] <svnbot6> r14634 | foad++ | Added author.

[16:22] <FOAD> Whee.

[16:22] *** mbradley|afk is now known as mbradley

[16:30] *** idiotmax joined
[16:35] *** FOAD_ joined
[16:35] *** lizr joined
[16:35] <lizr> Hi

[16:36] <diakopter> Hi lizr

[16:36] <lizr> I have a problem with pugs, maybe someone can help me.

[16:36] <lizr> At least I think I have a problem

[16:37] <lizr> I'm trying some perl6 examples from http://www.programmersheaven.com/2/Perl6-FAQ

[16:37] <lambdabot> Title: Perl6-FAQ at Programmers Heaven

[16:38] <lizr> Yeah, but the examples I tried don't really work

[16:38] <lizr> E.g. the "let" code example

[16:38] <lizr> And the 'for @array Y @array -> [$a,$b]' syntax doesn't even compile

[16:39] <lizr> Any ideas what I'm doing wrong here? Or is pugs just broken/incomplete?

[16:44] *** uzair joined
[16:44] *** uzair is now known as chhupa

[16:52] <lizr> No ideas?

[16:53] <FOAD_> Maybe it'll help people if you show exactly what happens and how it differs from what you expected.

[16:54] <lizr> Uhm

[16:54] <lizr> Well, in the "let" example the output should be "sad\nhappy\happy\n", but it's "sad\nsad\nsad\n" instead.

[16:54] <lizr> In the Y example pugs just prints a syntax error

[16:56] <audreyt> takesako: hi

[16:57] <audreyt> @tell takesako ppencode conquered latin america as well; one more continent for you :)

[16:57] <lambdabot> Consider it noted.

[16:57] *** FOAD_ is now known as FOAD

[16:58] <audreyt> lizr: hi there

[16:58] <lizr> Hi audreyt

[16:58] <audreyt> yes, we're working on array unpacking this very week :)

[16:58] <audreyt> currently you can say

[16:59] <audreyt> for each(@array ; @array) -> $a, $b { ... }

[16:59] <audreyt> and that will fork, because that will interleave two arrays instead of packing them into pairs

[16:59] <lizr> Ah, so it's not my fault? :)

[16:59] <audreyt> s/fork/work/

[17:00] <audreyt> this also works:

[17:00] <audreyt> for ([1,2,3] Y [4, 5, 6]) { say .[0], ' -> ', .[1] }

[17:00] <audreyt> so it's just array unpacking not working; everything else works :)

[17:01] <lizr> What about the "let" thing?

[17:02] <audreyt> let me look...

[17:02] *** cmarcelo joined
[17:04] <audreyt> well first you need "our $state" to occur before the sub

[17:04] <audreyt> otherwise it doesn't see it in scope

[17:05] <lizr> Ah, so the example is wrong?

[17:05] <audreyt> just has that one small glitch

[17:06] <audreyt> also change "fail" to "return" will also work

[17:06] <lizr> Ok, I put the "our $state" before the sub, but still prints 3x "sad"

[17:06] <audreyt> oh wait. "let" is not implemented... I'll do it now.

[17:07] <lizr> Hrhr

[17:07] <lizr> Thanks

[17:07] <audreyt> for the time being try

[17:07] <audreyt> our $state = 'sad';

[17:07] <audreyt> sub feed($food) {  # hypothetically, I will be happy after being fed  temp $state = 'happy'; KEEP { $state = 'happy' };

[17:07] <audreyt> er, I mean

[17:07] <audreyt> our $state = 'sad';

[17:07] <audreyt> sub feed($food) {

[17:07] <audreyt>     # hypothetically, I will be happy after being fed

[17:07] <audreyt>     temp $state = 'happy'; KEEP { $state = 'happy' };

[17:07] <audreyt> and keep everything else

[17:07] *** boo joined
[17:07] <audreyt> (because that's what "let" will mean)

[17:07] <audreyt> and it should work

[17:08] <audreyt> also change "fail;" to "return;"

[17:08] <gnuvince> audreyt: the array unpacking thing, does this mean that for((1,2) Y (3,4)) -> $a, $b { ... } will put 1 and 3 in $a and $b on the first iteration and 2 and 4 on the second?

[17:09] <audreyt> no.

[17:09] <audreyt> it will put [1,3] in $a and [2,4] in $b

[17:09] <audreyt> for the first iteration

[17:09] *** fglock joined
[17:09] <audreyt> and there will be only one iteration

[17:10] <audreyt> because Y, that is zip(), works differently from each()

[17:10] <audreyt> zip((1,2);(3,4)) is [1,3],[2,4]

[17:10] <audreyt> but each((1,2);(3,4)) is (1,3,2,4)

[17:10] <gnuvince> ah!

[17:10] <gnuvince> Thanks for the clarification

[17:11] <audreyt> np :)

[17:11] <fglock> audreyt: done with the talk

[17:11] <lizr> Btw, what das 'fail' actually do?

[17:11] <lizr> s/das/does/

[17:12] <audreyt> lizr: it's fully specced in http://perlcabal.org/syn/S04.html#Exceptions

[17:12] <lambdabot> Title: S04

[17:12] <audreyt> it's a bit complicated to explain; indeed although I wrote that paragraph, I still havn't found time to implement it in pugs :)

[17:13] <audreyt> btw, "let" works now. checking it in after running some tests.

[17:13] <lizr> Hehe

[17:13] <lizr> Wow, that was fast :)

[17:16] *** cmarcelo joined
[17:19] <FOAD> Okay; trying to make pugs but it all dies sadly with the following:

[17:19] <FOAD> Compiling Pugs.Prim.FileTest ( src/Pugs/Prim/FileTest.hs, dist/build/Pugs/Prim/FileTest.o )

[17:19] <FOAD> src/Pugs/Prim/FileTest.hs:49:20:

[17:19] <FOAD>     Overlapping instances for (:>:) Pugs.Types.Var [Char]

[17:19] <FOAD>       arising from use of `cast' at src/Pugs/Prim/FileTest.hs:49:20-23

[17:19] <FOAD>     Matching instances:

[17:19] <FOAD>       Imported from Pugs.Internals: instance ((:<:) b a) => (:>:) a b

[17:19] <FOAD>       Imported from Pugs.Types: instance (:>:) Pugs.Types.Var String

[17:19] <FOAD>     In the second argument of `($)', namely `cast "$*BASETIME"'

[17:19] <FOAD>     In the first argument of `(>>=)', namely `(readVar $ (cast "$*BASETIME"))'

[17:19] *** chhupa left
[17:19] <FOAD>     In a 'do' expression: b <- (readVar $ (cast "$*BASETIME")) >>= fromVal

[17:20] <FOAD> Build failed: 256 at util/build_pugs.pl line 359.

[17:20] <FOAD> make: *** [pugs] Error 2

[17:22] <audreyt> FOAD: fixing

[17:23] <FOAD> Awesome.

[17:23] <nothingmuch> cmarcelo: ah, you're back

[17:23] <audreyt> fixed.

[17:24] *** ludan joined
[17:24] <svnbot6> r14635 | audreyt++ | * Pugs.Prim.FileTest: Repair compilation on GHC 6.4.

[17:26] <FOAD> Okes, let's try again.

[17:27] <nothingmuch> headdesk

[17:28] * eviltwin_b sighs

[17:29] <audreyt> ok, "let" is in.

[17:30] <audreyt> lizr: did you already have a commit bit? if not, what's your email addr so I can send you one?

[17:30] <svnbot6> r14636 | audreyt++ | * Pugs.Prim: "fail" should throw out a Failure thunk.

[17:32] <eviltwin_b> oh, compiler magic I'd not have a clue about.  I feel slightly better

[17:32] <svnbot6> r14637 | audreyt++ | * Pugs.Eval: Support for "let" directives that works with

[17:32] <svnbot6> r14637 | audreyt++ |   "fail", so the example in ProgrammersHeaven FAQ now actually

[17:32] <svnbot6> r14637 | audreyt++ |   works (if you move "our $state" to the top of the file).

[17:32] <svnbot6> r14637 | audreyt++ |   Suggested by: lizr++

[17:32] <nothingmuch> we should have a commitbitbot

[17:33] <nothingmuch> like a spambot

[17:33] <nothingmuch> it can either have an addressing-optional mode, whereby anything that looks like an email is mailed a commit bit

[17:33] <nothingmuch> or an addressing mandatory mode, wherein it will only mail them when asked =)

[17:33] <audreyt> that's a bit too impersonal...

[17:34] <eviltwin_b> bah, just look up the username of anyone who pops in for more than 5 minutes and send 'em email :)

[17:34] <audreyt> @tell takesako http://pugs.blogs.com/talks/conisli-ppencode-pt.pdf ((translation courtesy of cmarcelo++, fglock++)

[17:34] <lambdabot> Consider it noted.

[17:35] *** fglock joined
[17:35] <svnbot6> r14638 | fglock++ | MP6 - fixed Token emitter

[17:35] <fglock> audreyt: try t/03-token.t :)

[17:35] *** mayweed joined
[17:36] <fglock> hmm - small bug

[17:36] <audreyt> what you got it working? :)

[17:36] <fglock>  .perl shows '$VAR1' :)

[17:37] <nothingmuch> hmmm

[17:37] <fglock> it needs $x.meth; $x.meth2;  - instead of $x.meth.meth2

[17:37] * nothingmuch ponders generic inferencing

[17:37] <fglock> so the emitter can analize the intermediate result

[17:37] <nothingmuch> decorator nodes attach to AST nodes

[17:37] <nothingmuch> and their class describes to an inferrencing engine how they transfer

[17:38] <nothingmuch> useful for lazily boxed objects

[17:38] <nothingmuch> which are only boxed when they exit the scope

[17:38] <nothingmuch> and stack allocated variables

[17:38] <nothingmuch> (C stack, that is)

[17:38] <nothingmuch> (actually it doesn't matter... any stack)

[17:38] <nothingmuch> audreyt: is there any prior research?

[17:39] <audreyt> hm, I should fetch cmarcelo and hack

[17:39] <fglock> audreyt: we are at the booth

[17:39] <nothingmuch> fglock: please ask him what he pang me about

[17:40] <audreyt> ok, coming to the booth after this commit gets thru

[17:40] <fglock> nothingmuch: he thinks he has fixed the problem

[17:41] <nothingmuch> fglock: cmarcelo: OK... i'm having dinner and I'll be virtually present for your mini hack afterwords

[17:41] * nothingmuch is refactoring Method::Constructor and Method::Accessor

[17:43] <FOAD> Hrm.  "make" does work now (and I did sudo cpan Task::Smoke etc) but "make smoke" ends on the following depressing note:

[17:43] <FOAD> *** Successfully built!  Type 'make install' to install.

[17:43] <FOAD>     (You may need to do that as the 'root' user.)

[17:43] <FOAD> /usr/bin/perl -Iinc util/run-smoke.pl . smoke.html

[17:43] <FOAD> YAML - missing dependency

[17:43] <FOAD> You don't seem to have the required modules installed.

[17:43] <FOAD> Please install them from the CPAN and try again.

[17:43] <FOAD> This can be accomplished in one go by running:

[17:43] <FOAD>   cpan Task::Smoke

[17:43] <FOAD> make: *** [smoke-pugs] Error 255

[17:43] <FOAD> (Doing "make smoke" again doesn't change anything.)

[17:44] <audreyt> doyou'll have to install YAML.pm from CPAN as instructed...

[17:44] <eviltwin_b> I didn't have that problem with the smoke test but some of the modules throw errors which result in every test being recorded as FAILED even though all the individual tests succceed

[17:44] <audreyt> yay, every single tests in t/var/let.t passed.

[17:44] <FOAD> Ah, silly me.  I was just following the instructions on the http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Hack.pod page.

[17:44] <lambdabot> Title: Pugs::Doc::Hack - How to hack on Pugs - search.cpan.org, http://tinyurl.com/yjq4uw

[17:45] <FOAD> (Or, eh, where was I instructed thusly?)

[17:45] *** bonesss joined
[17:46] <eviltwin_b> <FOAD> YAML - missing dependency

[17:46] <eviltwin_b> <FOAD> You don't seem to have the required modules installed.

[17:46] <eviltwin_b> <FOAD> Please install them from the CPAN and try again.

[17:46] <FOAD> Dur.

[17:46] <FOAD> Cheers.

[17:47] <bonesss> hi

[17:47] <bonesss> hi monks

[17:47] <svnbot6> r14639 | audreyt++ | * t/var/let.t: All tests passed, 0 TODOs.

[17:49] <FOAD> But I'd like to point out that the output claimed that the module would be installed by running "cpan Task::Smoke".

[17:49] <FOAD> Which was a big ole lie.

[17:50] <eviltwin_b> it should havebeen.  then again, I had some oddness that required multiple install attempts as well.

[17:50] <FOAD> Well, just saying, someone may want to change things one way or the other.

[17:51] <eviltwin_b> (then again, CPAN and darwinports aren't on speaking terms, so darwinports updates have an annoying tendency to mess up CPAN-installed modules)

[17:52] * eviltwin_b should probably reinstall perl5 + modules not from dports, so he has a clean setup.  meh.

[17:52] <svnbot6> r14640 | audreyt++ | * Pugs.Parser.Operator: Generalize decl+assign hack so we

[17:52] <svnbot6> r14640 | audreyt++ |   can deal with "constant=" in a similar way later.

[17:59] *** phiker joined
[17:59] <phiker> hi

[17:59] <phiker> so... how is development going on?

[18:04] <nothingmuch> audreyt: did you find cmarcelo?

[18:04] <nothingmuch> phiker: DOES NOT COMPUTE

[18:04] <nothingmuch> phiker: a more specific question is perhaps in order =)

[18:05] <phiker> hmm... I just want a _rough_ date when perl6 will be "ready" ;)

[18:05] <[particle]> ENOXMAS

[18:06] <nothingmuch> [particle]++

[18:07] <[particle]> phiker: probably alpha next year

[18:11] <xinming> phiker: probably bootstraped this year.

[18:12] <xinming> phiker: BTW, If you wish it comes early, please join us and write tests. :-)

[18:12] <xinming> phiker: If there is fail tests, audreyt++ would fix them really soon.

[18:13] <xinming> because most people working on the different part, But the progress is going fast.

[18:13] * xinming goes to sleep,

[18:13] <xinming> bye all

[18:14] <nothingmuch> ciao xinming

[18:14] <nothingmuch> .oO( xiao )

[18:20] *** awwaiid joined
[18:21] <eviltwin_b> hmmmm

[18:21] <eviltwin_b> is there some particular version of Test::TAP::Model I should be using?

[18:22] <eviltwin_b> the one I just got from CPAN, analyze_fh() returns a hash reference, the test scripts apparently expect a flat list back (foo = { $t->analyze_fh(...) }) and blow up with odd number of hash elements, leading to an error cascade

[18:23] <eviltwin_b> in short, all tests fail because they all seem to be assuming a different API than is actually in use

[18:23] <eviltwin_b> (and so does the rest of the smoke test framework)

[18:25] <FOAD> I get oodles of messages where the "expected" value disagrees with the "actual" one.  Is this how it's "supposed" to be?

[18:25] <gaal> will this work? @fibs = 0, 1, @fibs >>+<< tail @fibs

[18:25] <lambdabot> gaal: You have 1 new message. '/msg lambdabot @messages' to read it.

[18:26] <gaal> @moosages

[18:26] <lambdabot> nothingmuch said 3d 2h 11m 38s ago: moose!

[18:26] <gaal> @tell nothingmuch damn straight

[18:26] <lambdabot> Consider it noted.

[18:27] <gaal> FOAD: means the test doesn't pass. but it could be TODOed.

[18:27] <gaal> if you're running 'make smoke', lood at your resulting tests.yml file

[18:27] <gaal> (or has it been renamed to smoke.yml?)

[18:27] <gaal> *look

[18:28] <FOAD> Aight.

[18:28] <FOAD> Just being a noob.

[18:29] <gaal> no worries :)

[18:29] <FOAD> :)

[18:32] <nothingmuch> @moosages

[18:32] <lambdabot> gaal said 5m 52s ago: damn straight

[18:35] <nothingmuch> http://thread.gmane.org/gmane.comp.lang.perl.perl6.internals/9958/focus=9958

[18:35] <nothingmuch> can somebody please summarize that?

[18:35] <lambdabot> Title: Gmane Loom, http://tinyurl.com/yype52

[18:35] <nothingmuch> it's tolo parrot-technical

[18:36] <lizr> Bye

[18:36] *** lizr left
[18:37] *** fglock joined
[18:39] * eviltwin_b is now upgrading all his perl modules, to be followed by a forcible reinstall of all if things are still broken

[18:40] <nothingmuch> fglock: are you guys working?

[18:46] *** crem joined
[18:46] <phiker> hmm

[18:47] <phiker> is there something like a introduction to the new perl syntax?

[18:47] <eviltwin_b> http://spec.pugscode.org read the synopses

[18:47] <lambdabot> Title: Official Perl 6 Documentation

[18:48] <fglock> nothingmuch: yes - audreyt and cmarcelo are working on MOH

[18:48] <fglock> I'm on MiniPerl6

[18:49] *** Limbic_Region joined
[18:50] <nothingmuch> fglock: prod audreyt and cmarcelo to get me involved please

[18:55] *** mauke joined
[18:56] *** autark joined
[18:57] <fglock> nothingmuch: I'm not in touch with them right now, maybe they are offline

[18:57] <nothingmuch> ah

[19:12] *** TSa joined
[19:14] *** eggzeck joined
[20:01] *** eggzeck joined
[20:02] <TSa> HaloO, anybody out there?

[20:02] *** lambdabot joined
[20:02] *** eviltwin_b joined
[20:02] *** Eimi joined
[20:05] *** pmurias joined
[20:05] <pmurias> TSa: hi

[20:06] <pmurias> what brings you here? :)

[20:07] <TSa> interest in Perl 6, what else

[20:07] <TSa> I wonder what all these people do in the channel

[20:07] *** Aankhen`` joined
[20:09] <pmurias> lots of diffrent things

[20:09] <diakopter> many are otherwise-occupied at the moment.

[20:10] <diakopter> I, for one, merely lurk.

[20:10] <TSa> but logged into the channel

[20:10] <TSa> isn't that odd

[20:10] <diakopter> there is a perl conference going on in Brazil.

[20:10] <TSa> I know

[20:12] <pmurias> probably some people have their irc clients under screen

[20:12] <pmurias> and have them active for logging

[20:12] <pmurias> s/active/on/

[20:12] <TSa> screen is a irc logger?

[20:13] <pmurias> a terminal multiplexer

[20:13] <pmurias> it allows you to have multiple shells in one terminal at once

[20:14] <pmurias> if you are a command line user i would highly recomend it

[20:16] <TSa> are you on p6l as well?

[20:17] <pmurias> yes, but i check it once in a while

[20:17] <pmurias> why do you ask?

[20:18] <TSa> just curious

[20:18] <TSa> I regularly write there

[20:23] <pmurias> i have yet do write my first post to p6l ;(

[20:23] <pmurias> although i have too i should

[20:24] <pmurias> is it possible to unmix roles at runtime?

[20:24] *** scsibug_ joined
[20:26] <TSa> I don't know how the syntax would look like

[20:28] <pmurias> something like $cat but none(Hungry)

[20:29] <pmurias> s/too/two/

[20:29] <pmurias> the other one was about unimporting things

[20:30] <pmurias> i could probably try to write something at school tommorow

[20:30] <TSa> what are the use-cases for role unmixing?

[20:32] <clkao> whos is speaking about perl6 in ukuug spring conference?

[20:32] *** esstone joined
[20:34] <pmurias> TSa: for example in modeling an rpg

[20:35] <pmurias> if you use roles to represent sets of abliltys

[20:35] <pmurias> you could want to take away some of them

[20:36] <pmurias> a part of the proposal would  be to be able to define self excluding roles

[20:37] <pmurias> tame excludes wild, hungry excludes saturated

[20:37] <eviltwin_b> 'satiated'?

[20:38] * eviltwin_b sighs

[20:39] <eviltwin_b> Test::TAP::Model is well and truly hosed on this machine

[20:39] <TSa> I'm not sure if roles are the right thing to model rpg

[20:39] <TSa> looks to me that roles are a bit to heavyweight for the purpose

[20:41] <pmurias> that wasn't really a well-though example

[20:41] <pmurias> are roles that heavy-weight?

[20:43] <pmurias> eviltwin_b: yes

[20:43] <eviltwin_b> http://www.ece.cmu.edu/~allbery/Test-TAP-Model.errors --- any suggestions?

[20:43] <lambdabot> http://tinyurl.com/yxmqp6

[20:46] <pmurias> TSa: thanks with pointing out the performance concerns

[20:46] <pmurias> sleep&

[20:46] *** pmurias left
[20:46] <TSa> did I say sometghing about performance?

[21:00] *** mauke joined
[21:01] *** chris2 joined
[21:05] *** fglock joined
[21:05] <svnbot6> r14641 | fglock++ | MOH - added mo-bootstrap-plan by audrey++t

[21:05] <svnbot6> r14641 | fglock++ | v6.pm - fixed .perl

[21:16] <nothingmuch> audreyt: darcs pull MO please

[21:16] <audreyt> nothingmuch: ok. I think we have everything working :) except for the Slot abstraction which is bogus.

[21:17] <nothingmuch> huh?

[21:17] <nothingmuch> it's not bogus at all

[21:17] <audreyt> and why is it bogus? because it assumes everything can be done in a initialize+set_value sequence

[21:17] <audreyt> but some layouts does not work that way

[21:17] <nothingmuch> explain?

[21:19] <nothingmuch> audreyt: ?

[21:20] * nothingmuch frowns

[21:23] <audreyt> sorry the net was lost

[21:23] <audreyt> consider value objects

[21:23] *** tewk joined
[21:23] <audreyt> class C { has $!x is Int }

[21:23] <audreyt> note "is Int" not "is Scalar of Int"

[21:23] <audreyt> it means it can only be filled in in layout init time

[21:23] <audreyt> not one-slot-at-a-time

[21:24] <audreyt> i.e. consider the concrete instance layout of

[21:24] <audreyt> Map ID Int

[21:24] <audreyt> where ID is "x"

[21:24] <audreyt> or just (Int)

[21:24] <audreyt> another example:

[21:24] <elmex> can anyone tell me whether there is code of the 'official' perl6 implementation? i've seen the languages/perl6 directory in the parrot tree... but i wonder: is there already code of the future perl6 compiler and system?

[21:24] <audreyt> class C { has $!x is Int, has $!y is Moose }

[21:24] <audreyt> consider the layout: (Int, Moose)

[21:24] <audreyt> you can't allocate it, get it back, and then fill in values

[21:24] <audreyt> it only works with

[21:24] <audreyt> (Scalar, Scalar)

[21:24] <audreyt> type layouts

[21:25] <audreyt> elmex: the official perl6 is anything that passes 100% of pugs t/

[21:25] <audreyt> elmex: fglock++ and I believe that we are starting to do that in v6/

[21:25] *** fglock joined
[21:25] <nothingmuch> audreyt: if it's is int then the layout is responsible for packing it

[21:25] <nothingmuch> unboxed

[21:25] <audreyt> but src/ will still be part of it for the forseeable future

[21:25] <elmex> audreyt: also a perl5 script that uses regex&string matching to pass those tests?

[21:25] *** justatheory joined
[21:25] <audreyt> elmex: yes. it's surprisingly hard

[21:25] <nothingmuch> the slot is simply a wrapper for the closure that edits in right offset in the packed structure

[21:26] <elmex> audreyt: ah, ok

[21:26] <audreyt> elmex: if you can write such a script that consistently pass t/, you'll have implemented perl6.

[21:26] <nothingmuch> that is the entire point of this abstraction

[21:26] <nothingmuch> theinitialize hook could be noop

[21:26] <clkao> hello audreyt

[21:26] <clkao> audreyt: seen my mail to p5p ?

[21:26] <nothingmuch> or it could store a packed bit vector

[21:27] <nothingmuch> with inited flags for the packed values

[21:27] <nothingmuch> the 'construct' hook is there to clear values

[21:27] <audreyt> nothingmuch: it's bogus because:

[21:27] <nothingmuch> and unless completely transparent (as in perl hashes of scalars) all allocation is done by Lyaout->construct_instance

[21:27] <audreyt>                         my $object = $layout->create_instance_structure;

[21:27] <nothingmuch> ...

[21:28] <audreyt> # no access to @params

[21:28] <audreyt>                         $_->initialize_instance( $boxed, @params ) for @initializers;

[21:28] <nothingmuch> aye

[21:28] <audreyt> # too late to modify $boxed

[21:28] <nothingmuch> err

[21:28] <nothingmuch> that's just one impl of a constructor

[21:28] <audreyt> if $boxed is (Int, Moose)

[21:28] <nothingmuch> if the layout must know of the initial values then you filter @params through the initializers

[21:28] <audreyt> yes, and you conveniently refactored into C::M::Consturctor

[21:28] <audreyt> so it now is swappable

[21:28] <audreyt> but just a few minutes ago it wasn't like that :

[21:28] <nothingmuch> *nod*

[21:28] <audreyt> :)

[21:28] <nothingmuch> aye

[21:28] <nothingmuch> there's some crap like that =/

[21:29] *** mosca joined
[21:29] <nothingmuch> things that are done in my head

[21:29] <nothingmuch> but still too smushed in the code

[21:29] <nothingmuch> sorry =(

[21:29] <audreyt> anyway, roles, accessors, attributes, inheritance, c3 etc all seems to be working

[21:29] <audreyt> in MOH

[21:29] <nothingmuch> awesometown

[21:29] <audreyt> I'll attempt integration into pugs this week

[21:30] <nothingmuch> *cheer*

[21:30] <nothingmuch> next step: produce static HS from moh

[21:30] <nothingmuch> ^_^

[21:30] <audreyt> nothingmuch++ # very nice design, _very_ occasionally crappy fillin code

[21:30] <audreyt> I have an encoding for that I believe

[21:30] <audreyt> using libGHC

[21:30] <nothingmuch> i mean more like .hs files

[21:30] <audreyt> but we only gain speed with that with native types

[21:31] <audreyt> otherwise an (Array Val) layout isn't much slower than a record of Val fields

[21:31] <audreyt> probably not slower at all

[21:31] <nothingmuch> *nod*

[21:31] <audreyt> it only shines when MP6->Hs happens

[21:31] <nothingmuch> that actually doesn't conern me that much

[21:31] <audreyt> i.e. native codegen

[21:31] <audreyt> _then_ it can simply use the record field accessors

[21:31] <nothingmuch> Record Val is prolly good

[21:31] <audreyt> and that will be very, very fast.

[21:31] <nothingmuch> *nod*

[21:33] <nothingmuch> oh, fwiw

[21:34] <nothingmuch> layout with @params is under the assumption that if it's oging to be packed the types were predeclared

[21:34] <audreyt> I understand

[21:35] <nothingmuch> in perl land neither really matters

[21:35] <nothingmuch> maybe Inline::C based accessors for Moose in the future

[21:38] <audreyt> maybe unpack"" is sufficient

[21:38] <nothingmuch> for saving memory or runtime speed?

[21:38] <audreyt> saving memory

[21:38] <nothingmuch> ah

[21:39] <nothingmuch> *nod*

[21:40] <elmex> elmex++

[21:40] <perlbot> What kind of idiot karmas himself?  Your kind of idiot!

[21:42] <nothingmuch> audreyt: should i hunt you or cmarcelo for followup changes?

[21:42] <elmex> perlbot--

[21:42] <audreyt> nothingmuch: any architectural rethinks? we've modeled constructor

[21:43] <nothingmuch> the todo list is refactoring Class into a bunch of roles, maybe

[21:43] <nothingmuch> so that it's not so overloaded

[21:43] <nothingmuch> especially the interface composition

[21:43] <nothingmuch> (e.g. private outside of public RI multiplexing... maybe)

[21:44] <nothingmuch> i'm considering also reworking that bit

[21:44] <nothingmuch> i'm not sure i like the wrapper approachthat much

[21:44] <nothingmuch> i mean, it's opaque

[21:44] <nothingmuch> and it's nice at runtime

[21:44] <nothingmuch> so it doesn't matter if it changes

[21:44] <nothingmuch> but when constructing the RIs it's a bit of a hassle

[21:47] *** cmarcelo joined
[21:47] <nothingmuch> hola cmarcelo

[21:47] <cmarcelo> ola

[21:51] <audreyt> nothingmuch: this test, it's weird

[21:51] <nothingmuch> which one?

[21:51] <audreyt>         my @methods = $with_conflict->all_instance_methods;

[21:51] <audreyt>         is( @methods, 2, "two methods" );

[21:51] <audreyt> in MOH it dies immediately

[21:51] <audreyt> saying composition failure

[21:52] <nothingmuch> roles can have conflicts

[21:52] <audreyt> hm

[21:52] <nothingmuch> wait

[21:52] <nothingmuch> in Moose

[21:52] <nothingmuch> i may have taken that needlessly

[21:52] <nothingmuch> the assumption i was working with was that a conflict can be resolved later

[21:52] <nothingmuch> since roles don't generate responder interfaces themselves they don't need to be totally finished

[21:53] <nothingmuch> but perhaps that's unwise

[21:53] <audreyt> nvm, I'll conform for now...

[21:53] <nothingmuch> i think i will

[21:53] <nothingmuch> i'll just die $conflict_object

[21:54] <nothingmuch> and make it stringify nicely

[21:54] <nothingmuch> no, i'll decide later

[21:54] <nothingmuch> either way it's not vital

[21:54] <nothingmuch> it depends on which is more useful from the standpoint of a compiler/interpreter implementor, something that throws errors, or that creates a more complete/rich structure which has to be checked for errors

[21:55] <audreyt> had same train of thought, decided that delay made sense, agreed to conform, implemented, test now pass.

[21:55] <audreyt> (in MOH)

[21:57] <nothingmuch> okay

[21:57] <nothingmuch> feel free to change and ask me to change

[21:57] <nothingmuch> i don't feel strongly

[22:00] <nothingmuch> i think i've solved my multiple-vim-windows issue

[22:00] <cmarcelo> what issue?

[22:00] <nothingmuch> the vim-7 tabbed editing is quirky but works

[22:00] * audreyt stil prefers minitabexpl

[22:00] <nothingmuch> typicallly i'd have about 30 instance of macgvim

[22:00] <nothingmuch> i tried it

[22:00] <nothingmuch> it didn't work well for me

[22:01] <audreyt> k

[22:01] <nothingmuch> i just assumed it was not compatible with vim 7

[22:01] <nothingmuch> and not brought up to date because it was superseded

[22:01] <nothingmuch> but it did seem like it could be nicer

[22:01] <audreyt> cmarcelo: I'll rename unshift to withInvocant

[22:02] <cmarcelo> ok

[22:02] <nothingmuch> oh btw

[22:02] <nothingmuch> how do you do codegen for the accessors?

[22:02] <nothingmuch> etc

[22:04] <audreyt> for the static .hs?

[22:04] <audreyt> it's just record lookup

[22:04] <svnbot6> r14642 | fglock++ | MP6 - added more tests to Regex parser, shows error in hash-dispatch

[22:04] <audreyt> my layout is never mutable for statically known fields

[22:04] <audreyt> even

[22:04] <audreyt> class C { has $.x is rw; has $.y is rw }

[22:04] <audreyt> is still using

[22:05] <nothingmuch> i meant mostly int erms of no incest

[22:05] <nothingmuch> between accessors and responder wrapping

[22:05] <nothingmuch> it's not yet an issue

[22:05] <audreyt> uhm, where in MO.pm is that incest?

[22:05] <nothingmuch> my plan is thbat Compiled::* are then emitted

[22:06] <nothingmuch> to some target

[22:06] <nothingmuch> and the emitter has macros like box, unbox etc

[22:06] <nothingmuch> wait, we talked about this

[22:06] <nothingmuch> deja vu

[22:06] <nothingmuch> ditto goes for method_call, etc

[22:07] <audreyt> yes, I believe we talked about this ;)

[22:08] <nothingmuch> how do you handle boxing, in fact?

[22:08] <nothingmuch> a pair of (instance_structure, responder_interface) ?

[22:08] <nothingmuch> btw, if allInstanceMethods is nicer than all_instance_methods also feel free to change

[22:09] <audreyt> sorry lost context. boxing as in autoboxing?

[22:09] <audreyt> autoboxing is simple

[22:09] <nothingmuch> no

[22:09] <nothingmuch> err

[22:09] <nothingmuch> not necessarily

[22:10] <nothingmuch> associating the instance structure value with the class that acts on it

[22:10] <audreyt> so we have an invocant payload instance struct

[22:10] <audreyt> it's opaque

[22:10] <audreyt> all we know is it's Show a , Typeable a

[22:10] <nothingmuch> please rephrase

[22:11] <nothingmuch> invocant payload instance struct failed to parse

[22:11] *** iblechbot joined
[22:11] <audreyt> invocant has a payload, that is an instance structure

[22:11] <nothingmuch> ah

[22:11] <nothingmuch> yes

[22:11] <audreyt> determined by create_instance

[22:11] <audreyt> 's choice of layout

[22:11] <nothingmuch> that assumes invocant is the only format for invocanting =)

[22:12] <nothingmuch> the perl 5 runtime will wrap the instance structure in a scalar ref and bless that

[22:12] <audreyt> data Invocant

[22:12] <audreyt>     = forall a b. (ResponderInterface a, Show b) => MkInvocant

[22:12] <audreyt>         { ivInvocant           :: b

[22:12] <audreyt>         , ivResponderInterface :: a

[22:12] <audreyt>         }

[22:12] <audreyt> type Object = Invocant

[22:12] <nothingmuch> or no wrapping, if no localized casting is necessary

[22:12] <audreyt> actually, add Typeable b to it

[22:12] <audreyt> but you get the idea. all objects are invocants.

[22:13] <nothingmuch> *nod*

[22:13] <audreyt> and ivResponderInterface is inherent in the creation process

[22:13] <nothingmuch> i meant that Invocant itself is prolly swappable

[22:13] <nothingmuch> for interoperability reasons

[22:13] <audreyt> you mean the "b" slot

[22:13] <audreyt> it's existentially quantified

[22:13] <nothingmuch> no

[22:13] <nothingmuch> the Invocant itself

[22:13] <audreyt> which means it's thoroughly swappable

[22:13] <audreyt> oh.

[22:13] <nothingmuch> the record that has ivInvocant and ivResponderInterfac

[22:13] <nothingmuch> e

[22:13] <audreyt> you mean it can go without ivResponderInterface?

[22:14] <audreyt> what other structure can it have?

[22:14] * audreyt is puzzled

[22:14] <nothingmuch> e.g. perl5 bridge

[22:14] <nothingmuch> perhaps it's not really necessary

[22:14] <audreyt> but p5bridge can have a perfectly fine ivResponderInterface

[22:14] <audreyt> that simply calls to p5

[22:14] <nothingmuch> aye

[22:14] <audreyt> so I think you're bdufing

[22:14] <nothingmuch> bduf?

[22:14] <audreyt> big-design-upfront

[22:14] <nothingmuch> big design up front?

[22:14] <nothingmuch> ah

[22:15] <nothingmuch> actually for once no =)

[22:15] <nothingmuch> in the perl 5 runtime it's a little mroe messy

[22:15] <nothingmuch> because the built in types can't be polymorphized

[22:15] <nothingmuch> but i have to support them for interop

[22:15] <nothingmuch> so forget i said everything, in the hs runtime it's a nonissue =)

[22:16] <audreyt> thank you :)

[22:17] <nothingmuch> moo

[22:17] <nothingmuch> cmarcelo++

[22:17] <nothingmuch> audreyt++

[22:17] <nothingmuch> for 1 ...

[22:17] <audreyt> it's 1..* nowadays

[22:17] <nothingmuch> meh =)

[22:21] <elmex> perlbot: audrey karma

[22:21] <elmex> perlbot: audrey

[22:21] *** aufrank joined
[22:24] <gnuvince> what is 1..4.5 supposed to return?  In Perl 5, the 4.5 is truncated, but it appears that in Pugs 4.5 is rounded up to 5.  What is the correct behavior for Perl 6?

[22:41] *** AzureBOT joined
[22:45] *** fglock joined
[22:53] <aufrank> ?eval my @tmp; push @tmp, :foo{ 1/2 }; say @foo[0]<foo>;

[22:53] <evalbot_r14642> *** not a well-formed named arg: Syn "=>" [Val (VStr "foo"),Ann (Pos (MkPos "<eval>" 1 32 1 32)) (Syn "sub" [Val (VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subEnv = Just (MkEnv {envContext = CxtItem (mkType "Any"), envLValue = True, envLexical = MkPad (padToList [("$_",[(<ref:0xb61abc30>,<ref:0xb61abc28>)]),("$?1",[(<ref:0xb61ab06c>,<ref:0xb61ab064>)]),("$__evalbot_print",[(<ref:0xb7a6f13c>,<ref:0xb7a6f134>)]),("@tmp"

[22:54] <aufrank> ?eval my @tmp; push @tmp, 'foo' => { 1/2 }; say @foo[0]<foo>;

[22:54] <evalbot_r14642> OUTPUT[‚ê§] Bool::True

[22:54] <audreyt> yay bug.

[22:54] <audreyt> which test?

[22:54] <aufrank> where should a test live?

[22:56] <aufrank> ?eval my @tmp; my ($one, $two) = (1, 2); push @tmp, 'foo' => { $one/$two }; say @tmp[0]<foo>;

[22:56] <evalbot_r14642> OUTPUT[<SubBlock(<anon>)>‚ê§] Bool::True

[22:56] <aufrank> also, is there a way to execute that anon block

[22:57] <audreyt> do {}

[22:57] <aufrank> ?eval my @tmp; my ($one, $two) = (1, 2); push @tmp, 'foo' => { $one/$two }; do { @tmp[0]<foo> };

[22:57] <evalbot_r14642> \{Syn "block" {App &infix:/ (: Var "$one", Var "$two")}}

[22:58] <audreyt> er sorry

[22:58] <audreyt> @tmp[0]<foo>()

[22:58] <lambdabot> Unknown command, try @list

[22:58] <audreyt> I thought you meant foo => do {...}

[22:58] <audreyt> a test should live where named args live

[23:01] <aufrank> (congrats on the invited talk!  that's a great accomplishment!!)

[23:02] <audreyt> a great accomplishment would be delivering the talk successfully :)

[23:02] <audreyt> but thanks :)

[23:02] <audreyt> conferences are just my excuse to make hackathons work...

[23:02] <aufrank> a great acknowledgement, then ;)

[23:03] <audreyt> (that is, have other people pay for my airline ticket so I can hack with key local people)

[23:03] <aufrank> and opportunity

[23:03] <aufrank> who do you reckon will make it to nice?

[23:03] <audreyt> in this case rgs.

[23:03] <audreyt> rgs: can you spend _both_ weekends with me, or just one of them? :) if latter, the second week (after POPL) will be better 

[23:03] <audreyt> aufrank: Unified Perl Runtime hackathon :)

[23:04] <audreyt> where I get to learn some C, I hope.

[23:04] <aufrank> :)

[23:05] <rgs> audreyt: only one, and probably only the 2nd

[23:05] <audreyt> aufrank: fixed, anyway

[23:05] <audreyt> rgs: ok, cheers, that's just as well

[23:05] <rgs> :)

[23:05] <audreyt> I'm usually unfathomably nervous before a talk anyway :)

[23:07] <aufrank> audreyt: is there an adverbial form that forces evaluation on the value of a pair?

[23:07] <aufrank> :foo{ $bar/$baz}() or something?

[23:07] <audreyt> I'm not sure what you are talking about :)

[23:07] <audreyt> oh. heh that's just

[23:07] <audreyt> :foo($bar/$baz)

[23:08] <aufrank> ah, thanks

[23:08] <audreyt> fglock is back, going to do more MP6 hackathon'ing. bbiab :)

[23:08] <aufrank> have fun!

[23:08] <svnbot6> r14643 | audreyt++ | * Pugs.Bind: Non-bound named arguments shouldn't cause strange "not a well-formed"

[23:08] <svnbot6> r14643 | audreyt++ |   errors, as spotted by aufrank++.

[23:08] <svnbot6> r14643 | audreyt++ | * Also fix minore grammar nit in errmsg.

[23:26] <svnbot6> r14644 | audreyt++ | * Pugs::Emitter::Rule::Perl5::Ratchet: <%foo> will no longer try to

[23:26] <svnbot6> r14644 | audreyt++ |   look %foo from peek_my; instead it assumes it's available within the "our"

[23:26] <svnbot6> r14644 | audreyt++ |   scope.  Maybe bring a knob to use it if you really need it?

[23:26] <svnbot6> r14644 | audreyt++ |   (In any case this needs to be reflected in the docs.)

[23:29] <svnbot6> r14645 | audreyt++ | * v6::MiniPerl6 - 03-token now parses $1 correctly with <%variables>,

[23:29] <svnbot6> r14645 | audreyt++ |   so we can go ahead implementing the rest of emitting methods for

[23:29] <svnbot6> r14645 | audreyt++ |   e.g. Scalars.

[23:49] *** rodi joined
