[00:05] <szbalint> hehe

[00:15] *** larsen joined
[00:15] *** TMTOWTDIt left
[00:32] *** azuroth joined
[00:51] <putter> back.

[00:52] <putter> Shillo: no email, I've just started scribbling.  well, it's been a few minutes now.  I'll paste what I have so far...

[00:53] <putter> hmm, do we have a backup paste server?  sial is erroring...

[01:10] *** theorb joined
[01:22] *** stennie_ joined
[01:53] <putter> anyone around?

[01:53] <obra>      not very

[01:53] <putter> ;)

[01:54] <putter> can I quickly run an idea buy you?  (drat, I should really paste it.  wonder where there's a working paste...)

[01:54] <obra> paste.husk.org

[01:56] <putter> hmm.  doesnt look like it has p6...  oh, paste.lisp.org has it

[01:56] <lisppaste3> putter pasted "pX strawman" at http://paste.lisp.org/display/16673

[01:57] <putter> so, I'm wondering what you think of the  misc/pX/  with Common/  and  obra/  and attempting collaborative coding.

[01:58] <putter> or any other thoughts/questions/observations/comments you might have too

[02:07] *** feng joined
[02:08] <obra> ok back now

[02:08] <putter> :)

[02:08] <obra> So, the "draw a line in a sand" implementation is a feature of all the current plans ;)

[02:09] <obra> but actually drawing that line is useful

[02:10] <putter> "line" apropos changing spec?  hmm, yes.  pX would be a complete uncertainty waveform collapser. :)

[02:11] *** justatheory joined
[02:11] <obra> yes

[02:11] <putter> not vis p6 of course.  but it would establish an anchor point somewhere between p5 and p6.

[02:12] <putter> even if modules/roles/classes vanish or mutate into something else, most all of the code could be reused.

[02:13] <putter> and that's a rather extreme senario.  i think.

[02:14] <putter> obra: any thoughts on the whole misc/pX/Common/ idea?

[02:14] <putter> or questions?

[02:15] <obra> still parsing

[02:15] <putter> ;)

[02:17] <obra> I don't understand the point of not just having a common codebase

[02:18] <putter> Basic objectives are to have very low overhead contribution, and permit tiny bitsized contribution, and permit collaboration, while simultaneously retaining the ability for people to pursue... (a question! :)

[02:18] <putter> common codebase as in monolithic?  single Array.pm ?

[02:19] <putter> universally applied set of design choices?

[02:19] <obra> I think it'll make more work and promote duplication of work

[02:19] <putter> oh, not having private playpens?

[02:19] <putter> or the whole ownership concept itself?

[02:21] <putter> Basic objectives are to have very low overhead contribution, and permit tiny bitsized contribution, and permit collaboration, while simultaneously retaining the ability for people to pursue incompatible visions, and avoid the "committee needs to reach consensus - which is way costly" problem.

[02:24] <putter> Basically, I hypothesize people will converge if given the chance, but mechanisms to force "early" convergence will just raise barriers to entry.  eg, "single copy means you care about it's quality which means you have to be careful about changing it which means if your a newby you dont want to do anything and if experienced the cost of a partial fork to 

[02:24] <putter> try something better is high".

[02:27] <putter> eg, arguing about which of two things is the "right thing" can often take longer than just coding both and finding out later who was right.  and often the right thing ends up being "a bit of both".

[02:29] <putter> the private directories are just there because... sometimes you just want to fiddle, and we get more synergy if that happens in the common tree where people can see it rather than at home; some folks have reluctance to do "public coding" and i thought private-control-but-visible might help.

[02:30] <putter> if everything ended up untagged in Common, that would be great.  I just don't want the p6 namespace or components to be a proxy for zones of editorial control.

[02:33] *** scook0 joined
[02:35] <putter> hopefully the visibility (eg, "what do you mean you didn't see luqui's draft regexp engine core in ext/Perl6/something/mumble/frotz?") and folks' disinclination to duplicate work would keep waste down.

[02:35] <putter> obra: sound plausible?

[02:39] <putter> One possible problem is I'm not sure how well it deals with folks who approach complexity by creating hierarchies of little files.  When things are in flux, I tend to suck everything whose edges are unclear into a few large files.  I don't have a clear idea how messy or (un?)usable a Common might become.

[02:40] <putter> obra: was that the kind of think you had in mind as creating more work, and duplication of work?

[02:57] <obra> backish

[02:58] <obra> I think that an official policy of collective code ownership will help deal with the issues

[03:00] <obra> Anyone can always create a personal branch

[03:00] <obra> but continuous integration is a win

[03:07] <putter> agreed

[03:08] <putter> what would you do differently?  do all development in ext/?

[03:09] <obra> I'd argue for collaboration to be the default. All dev goes in ext/Px.

[03:10] <putter> what is in ext/Px?  a lib/ and a usual Foo/Bar/Hee.pm tree?

[03:11] * putter was just about to hit return on committing a strawman misc/pX/... :)

[03:12] <obra> dunno.

[03:12] <putter> k

[03:12] <putter> hmm...

[03:12] <obra>  i bet you should start by just committing enough code to eval say 'hello';

[03:14] <putter> err... huh?

[03:14] * putter wonders if he has been just soooo completely unclear...

[03:15] <putter> the current pX senario has nothing running until the very end.  (that's an oversimplification, but sortof)

[03:17] <putter> write a p6 spec as text which just happens to be phrased in p6.  "only" when it's done does it get massaged and magiced and start running.

[03:17] <obra> oh god

[03:17] <putter> *lol*  loudly

[03:17] <obra> I think that's a scary concept

[03:18] <obra> no validation until the end

[03:18] <putter> yes

[03:18] <obra> people need to be able to see results in order to contribute

[03:18] <putter> good, someone to share the fear with. ;)

[03:18] <putter> "results" consists of converting fuzzy Snn to concrete code?

[03:19] <putter> no?

[03:20] <obra> runnable tests

[03:22] <putter> dont think people with feel they contributed if they dont see runnable tests?  or think without running tests it will be impossible to maintain quality control?  or both?

[03:23] <obra> the latter certainly

[03:27] <putter> yeah... it would certainly require some... oversight...

[03:31] <putter> but that's the pX idea.  sacrifice having running tests for being able to use full p6 (in which it is soooo much easier to write p6 than in the currently implemented subdialects) and not having to keep an implementation working along the way.  use the thus lower barrier to entry to get more people, and that and the effort freed up

[03:31] <putter> to be more disciplined about code reviews and such.

[03:34] *** grayson joined
[03:44] <putter> obra/anyone: other thoughts?

[03:45] <putter> I think I'm going to just re paste an edited strawman, incorporating that last bit of our conversation, and wait until tomorrow (now+12ish hrs) to see whether to commit a strawman misc/pX/.

[03:46] <obra> I'd just start writing code.

[03:46] <obra> show people how easy and rewarding it is

[03:46] <obra> rather than look for consensus, lead with code

[03:48] <putter> hmm... ok...

[03:48] *** stennie joined
[03:50] <putter> too late tonight for me to do much code, but I'll commit the strawman misc/pX/ .   it can always be mv'ed or rm-rf'ed if in the light of day it doesnt seem like the right thing.

[04:24] * Steve_p blinks

[04:41] <svnbot6> r8960 | putter++ | Strawman misc/pX/ created.  Mostly just to illustrate/explore the concept.  Note that the concept of a pX project, and of a misc/pX/ directory/development-style, are distinct concepts.

[04:42] <putter> audreyt: well, it's nowhere near to being "a problem statement; a requirement statement; an overview of the spike's architecture (i.e. plan of attack)", but here are some scribbles, pasted:

[04:44] <lisppaste3> putter pasted "some pX notes" at http://paste.lisp.org/display/16677

[04:44] <audreyt> I second obra's idea; waiting for consensus never works without code

[04:44] <obra> audrey! good morning!

[04:44] <putter> audreyt: shouldn't you be, like, sound asleep?

[04:44] <audreyt> and even with running code, rough consensus is better than full consensus

[04:44] <audreyt> putter: no, it's 1pm for me

[04:45] * putter is sooo confused.

[04:45] <audreyt> I slept for 5.5 hours, woke up and went to do the laser operation thing, and just went back home

[04:46] <obra> audreyt: alex and I would greatly like to do some perf work on Jifty. Do you have sage words of wisdom for dealing with DProf's craziness?

[04:46] <audreyt> obra: don't use it?

[04:46] * putter confused the state of an unrefreshed irc log with world time.  go figure.

[04:46] <audreyt> (Devel::Profiler)

[04:46] <obra> Devel::Profiler seems to give...less than accurate results

[04:47] <audreyt> hrmph

[04:47] <obra>  yeah

[04:47] <obra> "no, jifty is not spending all its time in App::CLI"

[04:47] <audreyt> Devel::Profile?

[04:48] <obra> That was what I was just trying, but it seems to break standalone entirely

[04:48] <audreyt> or, more esoterically, Devel::OpProf? 

[04:48] <obra> heh

[04:48] <audreyt> havn't used that myself though

[04:49] <audreyt> Devel::SmallProf may be promising

[04:49] <audreyt> I mean Devel::FastProf

[04:49] <obra> Oh. I think Devel::Profile may break STDOUT

[04:50] <audreyt> FastProf is perline

[04:50] <audreyt> and as such may work better

[04:50] <obra> I haven't tried FastProf. I'll have a look

[04:50] <audreyt> another thought is to disable M::Refresh

[04:50] <audreyt> "bootstrap early, bootstrap often"

[04:50] <obra> Apparently, the issue is the dispatcher

[04:50] <obra> with "last" exiting a sub

[04:51] <Khisanth> putter: you thought time stopped because of IRC? :P

[04:51] <audreyt> obra: ahh, I'm guilty of that

[04:51] <obra> :P

[04:51] <audreyt> obra: you can convert it to CPS, or just use exceptions

[04:51] <audreyt> exceptions may be easier

[04:51] <obra> *nod*

[04:51] <audreyt> though CPS has the advantage of not confusing the $@ state

[04:51] <obra> was hoping not to have to recode

[04:51] <audreyt> use die/eval{} then

[04:51] <audreyt> should be a three-line change

[04:52] <obra> *nod*

[04:53] <audreyt> putter: the "wait no TDD" answer is weak

[04:53] <audreyt> putter: pugs's t/* _is_ the TDD

[04:53] <audreyt> putter: and it's not unimaginable to have part of the components running and hook it to pugs core

[04:53] <audreyt> putter: like your &rx_ thing

[04:53] <putter> audreyt: yeah (# re concensus #).  but running code mostly happens only at the end in the pX senario. :/  Anyway, there is are some pX notes, apparently rather opaque, just pasted.  also a copy in a strawman misc/pX/ .  comments on either (from anyone - hint hint) most welcome.  almost end of day for me.

[04:53] <audreyt> putter: then we can test that with t/

[04:53] <audreyt> putter: I think it's a valid approach

[04:54] <audreyt> part of the good thing about pugs is that it's very bridge happy

[04:54] <audreyt> thanks to FFI-enabled embedded interpreters -- we can also shuffle RPC via YAML if needed

[04:55] <audreyt> putter: so i'd argue it is in general plausible

[04:56] <putter> re being able to use t/ before bootstrap... yeah.  I'm just not sure how much of the pX implementation one will be able to do that with.  or how much massage it would take.  it seems more like the potential for reality checks, rather than TDD... no?

[04:57] <audreyt> true.

[04:57] <audreyt> I'd call the project p6p6.

[04:58] <audreyt> easier to type than pX

[04:58] <audreyt> and is clear about what it does

[04:59] <putter> p6p6??  err... clear... no doubt I'm missing something obvious... but, huh?

[04:59] <obra> putter: see pypy

[04:59] <putter> ahhhhh

[04:59] <putter> :)

[04:59] <audreyt> or maybe p6boot.

[05:00] <audreyt> I think p6p6 is cuter

[05:01] <obra> sixonsix

[05:01] <audreyt> 6on6

[05:01] <audreyt> p46656

[05:01] <putter> lim -> 6.. lim6

[05:02] <audreyt> p6+i

[05:02] <audreyt> or just p6i

[05:02] <audreyt> but that conflicts with the mailing list

[05:03] <audreyt> so maybe still p6p6 :)

[05:03] <putter> lol

[05:03] <audreyt> in any case... I'm excited :)

[05:04] <audreyt> two more days until I'm free to hack on this

[05:04] <audreyt> putter++

[05:04] <audreyt> now I need to go back and finish translating Luna

[05:04] <audreyt> deadline is in 48 hours :)

[05:04] <obra>        good luck

[05:05] <audreyt> *wave* &

[05:05] <putter> the "pX" got introduced when it was clear the objective of the project was not to produce a runninng p6, which is as yet undefined, but rather some p6-like language, which could eventually evolve into p6.  it seems somewhat odder to say, yes mumble is in the p6 spec, but were not doing it in p6p6, but it will be done after p6p6 is done, and can then evolve towards p6.  eep 

[05:06] <putter> s/was clear/proved unclear/

[05:06] <Kattana> p69 ..booting itself

[05:06] <putter> *wave*

[05:06] <putter> midnight here

[05:08] <putter> Kattana: re irc... yeah, rather than figuring out everyone's timezones, I sometimes just fall back on irc log deltas.  so the log says N, and audreyt was going to sleep at M, and N-M is small, so...

[05:08] <audreyt> putter: pypy doesn't implement the full python spec in the first either *shrug*

[05:08] <putter> which sort of breaks if the log freezes at N

[05:08] <audreyt> s/in/at/

[05:09] <audreyt> putter: as long as p6p6 is not actively breaking the spec in deliberately incompatible ways

[05:09] <audreyt> calling it p6 is justified, imho

[05:09] <putter> true.  I guess I was thinking in terms of naming the project, which goes away, rather than the artifact created, which contines.

[05:10] <audreyt> if I learned anything... your project goes away far later than you'd hoped

[05:10] <putter> *lol*

[05:10] <audreyt> so a name that sticks is important :)

[05:10] <audreyt> as an aside, in their paper SPJ calls p6 a "ferociously difficult to implement" language

[05:10] <putter> true.  and more than a little frightening.

[05:11] <audreyt> coming from the renowned wizard language implementor, that was also a bit frightening  :)

[05:12] <Kattana> but think of the fame and fortune to be gained taming the beast.

[05:12] <putter> awww.  that's mostly just because the state of parsers is still a 1970's-ish unmitigated disgrace.

[05:12] <audreyt> putter: actually... I don't think so

[05:12] <putter> otherwise we could have been bootstrapped on say CL years ago.

[05:12] <putter> no?

[05:12] *** drbean joined
[05:12] <audreyt> mixing lazy and eager evaluation, static and dynamic typechecks, as well as prototypes vs interfaces

[05:13] <audreyt> are all active research problems which has no clear solution

[05:13] <audreyt> (or indeed prior arts that works)

[05:13] <putter> true.  tunnel vision - I was just thinking about the initial bootstrap.  in which a lot of that needn't work, and nothing need be fast.

[05:13] <audreyt> GHC pioneered type-based compilation by using Fw as its internal calculus; p6's semantics has no easy mappign to existing calculus

[05:14] <putter> long road ahead...

[05:14] <audreyt> yeah. which is why choosing only the dynamic part of it -- the ruby-compatible part, so to speak -- makes sense

[05:15] <audreyt> to write p6p6 with

[05:15] <putter> it's taking time for that to sink in... SPJ calls p6 a "ferociously difficult to implement" language... oh my, what have we done? ;)

[05:15] <audreyt> one of the main drawback of writing a compiler in dynamic language is that you lose compiler validation

[05:16] <audreyt> but for p6p6, that drawback is inherent

[05:16] <putter> right

[05:16] <audreyt> since we don't have a compiler that can validate 6.2831 p6 anyway

[05:16] <audreyt> so it makes perfect sense

[05:17] *** penk joined
[05:17] <putter> you had to go, so feel free...   re p6p6,

[05:17] <audreyt> anyway... you should sleep and I should work :)

[05:17] <audreyt> ttyl tomorrow

[05:17] <putter> ah, ok.

[05:18] <putter> quick point is just that one could do a p6p6 like thing, without taking the "detach from testing to use full p6" approach.  one could instead try to leverage of pugs into a pil2js or ruby impl.

[05:19] <putter> s/of pugs/off of pugs/

[05:19] <putter> eg, teach pil2js to parse.

[05:21] <putter> so agreed targeting a dynamic platform is a good idea.  it's less obviously clear whether being non-incremental is the best way to do it.  that part of the argument hinges on social issues as much as technical ones.

[05:23] <audreyt> I have an epiphany

[05:23] <audreyt> a voice tells me that the project's right name is p6p5

[05:24] <putter> anyone who wants to svn up and look at what's currently called misc/pX/, or just look at http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/browse/misc/pX/Common/ ,  (putter pauses for epiphany)

[05:24] <audreyt> I can explain, but the holistic realisation nuked my verbal cortex

[05:24] <putter> *lol*

[05:25] <obra> audreyt: wasn't p6p5 better known as p6c?

[05:25] <audreyt> obra: this is a perl 6 compiler that compilers perl 6 code to perl 5 written in perl 6

[05:25] <putter> sounds like fun.  but perhaps not the best thing to happen when headed out to $work ;-)

[05:25] <audreyt> obra: not a perl 6 compiler that compielrs perl 6code to parrot written in perl 5

[05:26] *** vborja joined
[05:26] * putter rubs his eyes and tries those sentences again...

[05:26] <obra> nor a p6 compiler written in perl5

[05:26] <audreyt> yup

[05:26] <audreyt> it's the same idea as putter's

[05:26] <audreyt> just replacing the "easy target language" from ruby to p5

[05:26] <audreyt> and "temporary transcoded language" from $anything to p5

[05:27] <audreyt> targetting perl 5 (with Class::MOP and other runtime parts in perl5/) has practical values, namely letting perl6 code that uses perl5:DBI work seamlessly

[05:28] <audreyt> plus, the p6p5 compile is free to use CPAN modules for glue parts instead of logic parts

[05:28] <audreyt> the idea is to not write any of the compiler in p5, but free to use existing p5 modules

[05:29] <audreyt> which is how I envision any reasonably sized p6 application to work in real world anyway

[05:29] <Daveman> hooary! freedom :P

[05:29] <putter> intriguing...

[05:30] <obra>  I did say this yesterday, putter ;)

[05:30] <audreyt> this path was forbidden largely because previously "p5 as a p6 vm" hadn't been thought of or specified

[05:30] <obra> but not as convincingly

[05:30] <audreyt> but our perl5/ and related modules is now at a stage that's mature enough

[05:31] <audreyt> so much that I was originally planning to write -CPerl5 for Pugs's Haskell CodeGen in israel

[05:31] <audreyt> but writing the same thing in p6 is much more fun

[05:31] <audreyt> to me personally and I think to other people as well

[05:31] <audreyt> not the least because using perl5 modules from haskell via Antibuddha is painful

[05:31] <audreyt> but using perl5 modules from p6 via use perl5:Foo is fun.

[05:31] <audreyt> end of epiphany

[05:33] * putter ...

[05:33] <audreyt> (plus, it doesn't inhibit the eventual run-this-real-thing via transcoding to p6-as-supported-by-pugs, as pugs has p5embed support as well.)

[05:35] * putter really needs to think about this when closed eyes dont become head on table.  sounds very neat.  I have to think it though, but that's not going to happen just now. :/

[05:35] <audreyt> sure. sleep on it :)

[05:35] <putter> nifty epiphany.

[05:36] <putter> will do.  thanks, fun.

[05:36] *** penk left
[05:36] <scook0> audreyt: `in their paper SPJ calls p6 a "ferociously difficult to implement" language` -- what paper is that?

[05:36] * audreyt gets excited thinking that she can reuse her hundreds of CPAN modules for writing the p6p5 compiler with

[05:37] <audreyt> scook0: "Haskell: The dream that stuff is made of", a 20-year-retrospective overview of haskell's story

[05:37] <audreyt> scook0: private copy, to be published later this year

[05:38] <scook0> audreyt: oh, ok -- thanks anyway

[05:38] <Daveman> whee

[05:40] <audreyt> putter: we should work on your perl6-announce article more when you wake up tomorrow

[05:40] <Khisanth> audreyt: you sound like a mad scientist from one of those actions movies "ah ha! I finally have a use for all these weird stuff I have been inventing over the years!" :)

[05:41] <audreyt> Khisanth: which... is exactly what it is :)

[05:42] <audreyt> <- came from the CPANfolks people, not p6folks people, contrary to chromatic's impression in his previous #perl6 rant

[05:42] <Daveman> Khisanth :P

[05:43] * Daveman runs away

[05:43] <audreyt> Apr 1st sounds like a good target date.

[05:44] <audreyt> but I really need to run to get Luna translated :)

[05:44] <audreyt> bbl &

[05:44] <Khisanth> wow ... this has to be one of the dumbest behavior in an app I have encountered so far...

[05:44] <Daveman> Khisanth, some how, in three lines of code, I broke all telnet clients - hahaha

[05:44] <Daveman> worst... client app... ever...

[05:45] <Daveman> ahahah it comes on, and all the other connected telnet clients get broken heehee

[05:45] <Khisanth> been spitting out warnings for days except instead of printing them and forgetting about them, it buffers several days worth of message

[05:45] <Daveman> Khisanth, yikes

[05:46] <Khisanth> well at least not as bad some one in #gtk-perl, one of his program created several gigs of error messages :P

[05:47] *** penk joined
[05:47] <svnbot6> r8961 | Darren_Duncan++ |  r2393@darren-duncans-power-mac-g4:  darrenduncan | 2006-02-10 21:45:35 -0800

[05:47] <svnbot6> r8961 | Darren_Duncan++ |  /ext/Rosetta : removed some SEE ALSO items

[05:52] <Daveman> Khisanth, bahahahahah

[05:53] <Daveman> awesome

[05:53] *** br4in joined
[05:55] <Khisanth> I think he kept deleting all the while finding he had no space...

[05:56] *** pasteling joined
[05:58] <Daveman> haha

[05:59] <Daveman> poor guy

[05:59] <Daveman> when will noobs every learn :P

[05:59] <Daveman> speaking of which... you ready for this weekend Khisanth? :P

[06:00] *** stennie_ joined
[06:05] *** drbean left
[06:09] <Khisanth> Daveman: sure

[06:12] <Daveman> heh, alright :)

[06:49] *** pdcawley_ joined
[06:57] *** stennie joined
[07:31] *** putter joined
[07:31] <putter> a couple of thoughts from putter's sleeping mind...

[07:31] <putter> I haven't / am not going to yet  backlogged, but re p6a,

[07:33] *** drbean joined
[07:34] <putter> re p6a, so no.  because 1- I can't commmit to being project lead on this, 2- it's quite unclear which "this" this is ;)  and 3- for several values of "this" one wants a ramp up preriod to shake down before having to deal with a large influx of people...  so premature I think, no? 

[07:34] <putter> ok, thoughts...

[07:35] <putter> main thought - we really need to step back and look at the project design space (ie, how to organize going forward).  just what are the key constraints, the options for addressing them, their adds/disadds.

[07:39] <putter> re p6p5... something is not quite right there.  pX is a "hail mary" pass.  a "abandon running code" because while running, it's unusable.  but if p5 makes a good target because of lots of p6 support... then that the whole premise of pX becomes questionable.  if p5's p6 stuff is usable, we should be building there, no?

[07:42] <putter> the kind of question we need to look at is: why isn't <foo> the running foundation on which to build.  for a foo of pil2js, it's support for many things is(was?) better than pugs.  and it has a working object system internally.  but it's never be able to do non-hardwired objects.  why not?  that information isnt in pil.  so, how could it get it? 

[07:44] <putter> well, a bit kludgy, but it could preparse p6 code with regexps and pull out class info before handing code to pugs to parse.  the approach has limitations, and was considered way back when, but was put on hold pending pil getting class info.  (how hard would it be, etc)  ok, what other approaches?  well, pil start containing class info (how hard would it be, etc).

[07:46] <putter> what others?  if -CParse-YAML has class info, one might use that instead of preparsing to augment existing pil.  or given a parse tree, just how hard is it to do pil creation?  say written in p6, and handed to pil2js?

[07:48] *** elmex joined
[07:48] <putter> and so on.  p5 side, what stands between current state an "use v6;" working for some value of working?  do we need a P::RD p6 grammar?  extend P::RD in some way?  reimplement the "plan to throw one away" code of perl5/Perl6::Value and Container on the now solid? p6 like class systems available in p5?

[07:51] <putter> pugs side, what really stands between current state and being able to write a compiler for p6 to something in p6?  pge has dramatically improved.  I tried once to write a Perl6::Compiler set of ast nodes, hit issues, but perhaps gave up to easily.  with some haskell side debugging support, perhaps pugs object and rules supprot is just about good enough?

[07:52] *** kanru2 joined
[07:52] <putter> not only is the implementation state complex, and the implementation opportunity space, but I'm also unclear on the dependencies between milestones.

[07:55] <putter> take a parser.  there's a range from hardwired p6-standard but you cant add stuff, through somewhat tweakable, through full p6 spec.  pugs is in the middle there.  we dont have another parser.  a pge on grammar solution will likely be towards the static end of things for a while.  which parts do we really need now, and for what?

[07:57] <putter> PIL^N addresses a bunch of stuff.  bootstrap object system on simple core.  simple core to simplify backends. more?  which of these free up what dependencies that we need to accomplish what?

[07:59] *** vborja left
[08:00] <putter> bottom line: I think we need to sketch the big hairy graph of the milestones we want, the pieces we have, the capability dependencies of our problem space, and our senarios for getting through it.  and then, when that's non-fuzzy, plot a path through it.

[08:00] <xinming> there is a question comes up to my mind. If we use a perl 5 module within perl 6, will the speed slow down?

[08:01] <xinming> Or, It will run as fast as we write it in perl 6. :-/

[08:02] * xinming is out for something to eat.

[08:06] <putter> so one possibility (come morning for me) is to pull out large sheets of drawing paper, and try to graph what's going on.  an attempt which will undoubtably generate a great number of questions, about what various things we have can and cant do.  and... well, that's for another day (for me - feel free;).

[08:07] <putter> 'night &

[08:08] <putter> opportunity rich environment is good...

[08:18] *** iblechbot joined
[08:42] *** elmex joined
[09:24] *** pdcawley_ joined
[09:28] *** grayson` joined
[09:42] *** Medvekoma joined
[09:43] *** G2 joined
[09:46] *** kanru2 is now known as kanru

[10:15] *** r0nny joined
[10:44] *** chris2 joined
[10:57] *** larsen joined
[10:59] *** larsen joined
[11:11] *** iblechbot joined
[11:52] *** bsb joined
[11:57] *** drbean joined
[12:27] *** iblechbot joined
[12:32] *** elmex joined
[12:32] *** stevan joined
[12:47] <wolverian> does http://pugscode.org work for anyone?

[13:01] <bsb> not me

[13:05] <spinclad> nor me.  failed for me on thursday morning too.

[13:29] <audreyt> fixing.

[13:29] <audreyt> (maybe I should move it to feather? hmm.)

[13:33] *** ilogger2 joined
[13:47] <audreyt> ok... it should get propagated within an hour or so

[13:47] <audreyt> thanks for the reminder :)

[13:49] <clkao> greetings audreyt.

[13:50] <audreyt> yo

[13:53] <clkao> leaving lovely taiwan tomorrow morning

[13:53] <audreyt> you?

[13:53] <audreyt> nice, I leave the day after

[13:55] <audreyt> bbl :) &

[14:16] *** SamB joined
[14:19] <Juerd> audreyt: Feel free to move it to feather

[14:19] <Juerd> audreyt: If you do, let me know, as from that point forward, I'll have to make sure the box is backed up automatically :)

[14:28] *** chris2 joined
[14:48] *** binary42 joined
[15:00] *** joepurl joined
[15:44] *** GeJ joined
[16:09] *** integral joined
[16:50] *** putter joined
[16:50] <putter> good morning folks

[16:50] <putter> of course, usually the right thing is to work backwards from one's objectives.

[16:50] <putter> often much simpler

[16:51] <putter> I'm about to start scribbling.  new note shortly

[17:00] <tewk> So the new p6 compiler will be written in a reduced set of p6 running on p5 as the vm, did I get that right?

[17:10] *** grayson joined
[17:37] <stevan> we decided on p5 for the vm?

[17:38] <tewk> Well that is audreyt last great thought, backlog to about midnight last night

[17:40] * stevan suddenly realizes there is a gap in his local backlog :)

[17:40] <stevan> I must have lost network for a bit

[17:43] <integral> tewk: what language for the reduced p6 to p5 compiler?  p5 itself?

[17:44] <stevan> Eak! SPJ calls p6 a "ferociously difficult to implement" language

[17:44] * stevan is suddenly filled with dread instead of hope ;) 

[17:45] <tewk> integral: from what I can gather. a full p6 compiler written in reduced p6 running on a p5 vm, get it

[17:46] <wolverian> stevan, where?

[17:46] <integral> hmm, interesting idea then, and sounds rather hard due to a lack of tools in p5 :-/

[17:47] <stevan> wolverian: in (which I believe is) an unpublished papaer which (i think) audreyt is reviewing for him

[17:47] <stevan> wolverian: see the backlog (http://colabti.de/irclogger/irclogger_log/perl6?date=2006-02-11,Sat&sel=118#l189)

[17:48] <stevan> a perl 6 compiler that compilers perl 6 code to perl 5 written in perl 6

[17:49] <stevan> :)

[17:49] <wolverian> augh my brain melted

[17:50] <stevan> my dog tries to chase his tail all the time.. he hardly ever gets it,.. and when he does it is not quite what he expected ;)

[17:50] <stevan> that said,.. i think this might be the best approach

[17:50] <stevan> it is certainly the most hackable by the largest group of people

[17:51] *** mtdms joined
[17:52] *** mtdms joined
[17:53] <mtdms> im novice in perl programming language, how good is it? 

[17:56] <tewk> integral: Reduced set of p6 being defined as the portion of p6 that pugs currently supports.

[17:57] <tewk> So OO will end up being bootstraped on the p5 vm using Class::MOP ?

[18:01] <stevan> tewk: I am not sure Class::MOP is what audreyt thinks it is

[18:01] <stevan> it might serve as a good p5-p6 compatability layer though

[18:02] <stevan> or at the very least a plaform to re-write the metamodel on

[18:03] <stevan> putter: we should meet in real-life,.. for a day and hack this out,.. maybe with obra too

[18:04] * stevan has to run and do errands,.. but will remain in #perl6 in spirit :)

[18:05] *** justatheory joined
[18:10] *** cm joined
[18:20] <rafl> Stepping a word forward, b is backward, t swaps the last two words

[18:21] <putter> oo, backlog :)  paste going up.

[18:26] <lisppaste3> putter pasted "strawman walk through design space" at http://paste.lisp.org/display/16692

[18:26] <putter> fiddle, fiddle

[18:27] <putter> stevan: re dog, lol

[18:28] <putter> stevan: re meeting, that would be neat.  real whiteboard, yay.

[18:29] <putter> first meeting of the US NorthEast Perl6 Mongers? ;)

[18:31] <putter> given the (recurring) interest in a p5-based p6, it would be worth looking at it's design space more closely.

[18:32] <putter> I think we understand enough to sketch out exactly what would have to be done to create a pugs-equivalent in p5.

[18:34] <putter> retrospectively, my impression is Perl6::Rules was abandoned because the p5 regex engine was not recursive.  though maybe also because it's been unstable.  and perhaps P6::R complexity.

[18:35] <putter> If P6::R had worked, I suspect p6 on p5 would have been an already working no-brainer.

[18:35] <putter> but it didn't, so it isn't.

[18:36] * putter tries to remember if pcre is reentrant... goes to check...

[18:39] <putter> well, it's thread safe, so in this context that likely means reentrant.

[18:40] *** robkinyon joined
[18:40] <putter> No pcre module on cpan.  Sigh.

[18:42] <putter> I'd mention http://www.geocities.jp/kosako3/oniguruma/ (ruby 1.9's new engine) but no callbacks as yet. :(

[18:43] * putter idly wishes someone would write a PCRE cpan module, just for the heck of it.

[18:43] <putter> for the "now p5 regexs can be reentrant" heck of it.

[18:44] <Kattana> a pcre like p6 regex implementation would be nice..

[18:46] <putter> you mean pcre implemented in p6?  yes.  not too hard to do on full working p6.  rather harder when objects aren't quite working.  absence of hypothetical vars adds cruft, but can be worked around.  i think.

[18:49] <Kattana> I mean a working library of apocalypse 5, it does not matter what language it is written in, it would be usefull.

[18:49] <putter> but the question is then, where do you run it?  on pugs, pge or Text.Rule would be faster.  though a p6 version might be easier to extend into a parser.  compiled to p5 or js, just how slow are you willing to go?

[18:50] <putter> isn't that what libparrot/pge is? ;)

[18:51] <Kattana> is it? you would know more about it than me.

[18:53] <putter> that's basically how we're using pge for rules.  I don't know if pge has callback hooks yet, so more a oniguruma than a pcre.  ie, doing a Snn flexible parser, with longest token matching and operator precedence parser nodes, can't (currently) easily be done?

[18:55] <putter> oh, the other big downside of a non-p6 rules engine, is if that's your parser, it gets more hairy to do dynamism.  eg, a lexically scoped "oh, here's a new type of statement, and some more tokens and operators... end of scope, now they're gone".

[18:55] <putter> but with callbacks and reentrancy it can be done.

[18:56] <putter> oh, wait.  maybe I decided it couldn't be, not really.  hmm...

[18:56] *** larsen joined
[18:56] <putter> the engine has to be able to fail back into the callback.

[18:57] <putter> so a callback which, say, implements a+ , can try matching one less a.

[19:02] <putter> pcre "callouts" don't. :(

[19:06] *** Amnesiac joined
[19:07] <putter> not only does one need such a general node, but the regex optimizer has to recognize it, and... not optimize.  because anything-in-the-universe may change going through that node.   so yes, for Snn level flexibility, a p6 implementation would be nice. ;)

[19:10] <putter> for pugs(current)-level flexibility... well, we already have pugs.  I'm not sure if it is "known to be buggy" or "known to work just great, with flexibility room to spare".  I believe it would take some, perhaps non-trivial, work to get pge to do pugs-level flexibility.  but maybe not.  pge certainly might be capable of a less flexible parse.

[19:10] <putter> though that hasn't been tested.

[19:13] *** larsen joined
[19:13] *** dduncan joined
[19:14] <putter> once upon a time my thought was "create Rul objects this afternoon, to remember the regex pattern and provide a place to hang pattern ast's, and and a type for multi sub rule engines.  Then tomorrow I'll do the ast, and start bootstrapping a regex parser.  Then I'll write a simple alternate recursive decent engine, and we'll see where to go from there".

[19:17] *** larsen joined
[19:18] <putter> Rul creating got unnegotiably stopped by type inferencer issues.  Things changed, but Rul is still blocked (t/pugsbugs/smartmatch_rx_obstacle.t).  If that were fixed, i'm not sure whether the ast would be straightforward or not.  my one attempt at a big ast tree on pugs p6 didn't work, but I didn't really try hard, let alone attempting targeted pugs hs-side fixes.

[19:20] <putter> but for the short term, getting objects working... somewhere... the parser is not an issue.  as long as -CParse-YAML can be used.

[19:21] <putter> for objects, it seems basically:

[19:21] <putter>   pugs parser -> pugs compiler -> PIL(extended) -> PIL backend

[19:22] <putter>  pugs parser -> -CParser-YAML -> backend compiler

[19:22] <putter>  pugs parser -> pugs compiler(changed?) -> pugs runtime(extended)

[19:24] <putter> also

[19:24] <putter>   pugs parser -> -CParser-YAML -> backend class handling

[19:24] <putter>                      -> pugs compiler -> PIL(as is, no classes) -> backend PIL handling

[19:26] <putter> key quetions:

[19:27] <putter>  how difficult would it be to do a minimum modification of the existing PIL so that it was non-lossy with respect to class info?  with that, pil2js could be extended to pugs-level capability, and prelude-written-in-p6 version of a p5 backend could be done.

[19:28] <putter>  (or alternately, how difficult to do a -CParser-YAML "second channel" to get the class info)

[19:29] <putter> that would get us uncontrained by the pugs runcore, but not from the pugs parser or compiler.

[19:30] <putter> sufficient to do a pugs-equivalent (likely, yes?), but not necessarily to easily develop from there.

[19:31] <putter> you then need to improve or replace the compiler and parser, perhaps in that order.

[19:33] <integral> putter: have a look in src/Pugs/CodeGen/YAML.hs,  you just need to make sure the data structure you want is YAML dumpable by DRiFT and add a line to dump it

[19:33] <putter> Though there is an element of "just choose a path, any plausible path, and get people motivated, and we'll get there".  vs not moving.  The old "any decision is better than no decision" argument.

[19:34] <putter> integral: looking... but what context?

[19:34] <integral> context?

[19:35] <putter> why am I looking at this? :)

[19:35] <integral> you said "how difficult to do a -CParser-YAML "second channel""

[19:35] <integral> and this is how difficult :)

[19:36] <putter> :)

[19:38] <putter> so... ./pugs -CParse-YAML -e 'class A{has $.b}'  currently reports on A, but not on $.b.  ($.b does show up, in a way, on -CPIL.  but not A;).   so can -CParser-YAML be extended to mention $.b?

[19:38] <integral> if the data is somewhere, sure :)

[19:39] <integral> hmm, actually let's see if my local mod does it

[19:40] <integral> nope

[19:40] <putter> :/

[19:41] <putter> any idea how easy/hard it would be?  bascially, there are two motivations,

[19:42] <putter> you want to write backends using a p6 prelude, which obviously requires class info which has been lacking.

[19:42] <integral> if you know where pugs stores the data, it's easy if you know do you hook up drift, since it's then a one line change to that YAML.hs

[19:42] <putter> and then, but perhaps secondarily, it would be nice if users could write classes (which work on the backends;)

[19:43] <putter> integral: hmm.  should I take that as a "maybe"? ;)

[19:43] <integral> yep

[19:44] <putter> ok,

[19:47] <putter> basically with a yaml tree with class/attribute info, my next step would be to cry "stevan!  how goes the p5-based p6 class-like things.  can I easily drive it from a class attribute tree?"  then given a object system skeleton, then if yaml had a full parse, I might contemplate trying a simple compiler, and if not, back to -Cpil.

[19:48] * putter wonders if he has drift installed... maybe not...?

[19:49] <integral> hmm, if drift is a command 'drift' it's not on feather

[19:50] * putter doesn't remember... checks makefile...

[19:51] <putter> util/drift.pl and a hugs library (an optional one I thing, but not sure)

[19:55] <putter> so, big picture, this is a "get objects working on a p5 backend" path.  a p6 prelude poured though -CPIL and/or -CParser-YAML.  tree walked into Class::something-or-other and Class::MmbleMethods calls, and p5 code.

[19:56] *** elmex joined
[20:07] *** pdcawley_ joined
[20:14] *** putter joined
[20:16] * putter waits to see if his irc client syncs...

[20:16] <putter> guess not.

[20:17] <putter> I'm just going to cut and paste.

[20:17] <putter> rather than rephrase.  sorry.

[20:17] <putter> Parts are p6 prelude (some bits written, could be written now, not being so perhaps mostly because it's not fun to write stuff that doesnt run (hmm, but some could run on pugs??)); CParser-YAML, needs extension as currently discussed.  perhaps minor extension to get class info, more extensive to get full parse.

[20:17] <putter> tree walks, been there, done that, can do it again.

[20:17] <putter> Class::mumbles, well, they're on CPAN, so of course they work, no? ;)

[20:17] <putter> oh, so could be doing a PIL walker now.  basically a cleaned up / rewritten PIL-Run.  hmm, I actually have the beginnings of one of those around here someplace...

[20:17] <putter> (got bogged down in trying to fake class parsing and such, I think)

[20:18] <putter> maybe

[20:18] <putter> big point is, we've done this before (PIL-based backend, even on p5).  the non-prelude portion of it is a task measured in days, or at most a couple of weeks.  and with the cpan modules, we're now in an even better place to do it than we were previously.  so if we can use -CParser-YAML to get around the "-CPIL just doesnt tell

[20:18] <putter> us what we need to know", then  this whole development path get's unstuck.

[20:18] <putter> assuming a working class substrate, the prelude portion of the task is also just not a very big deal.  especially if you can actually see the code run. ;)

[20:18] <putter> ***putter goes to dig up his old pil-run rewrite...

[20:18] <putter> hmm.  though -CPIL doesn't quite get you to pugs-equivalence.  you can look at a smoke of pil2js.  maybe an older one, my very fuzzy impression is it's been slipping.  some test files just dont -CPIL'ify.

[20:18] <putter> END.  sorry again.

[20:38] <putter> misc/pilrun2-leftovers/ is in.

[20:38] <svnbot6> r8962 | putter++ | Created misc/pilrun2-leftovers/.  It contains some leftovers from an old effort to clean up PIL-Run.  It's an non-running development snapshot, provided as junkyard scavenging material.  Since it looks like a p5 backend may again be pursued, with -CParser-YAML to work around -CPIL limitations, and improved CPAN-based class and multi-method handling.  Some of it is of little interest.  pil.pl might be useful.

[20:38] <putter> for whatever it's worth

[20:41] <putter> the prelude stuff from pilrun2 is in a less scavengable state.  but I'll pop it in leftovers if anyone asks.  if we go down this path, we can combine it with the stuff in src/PIL/misc/, Prelude.pm, etc.

[20:50] <putter> if someone get's -CParser-YAML to report class and role attributes and inheritance (is and does), I'll endeavor to plug it into stevan's Class:: module on p5.  and if that works, I'll likely dust off "pilrun2", aiming for "objects as working as the pugs compiler permits".  A "two channel" -CParser-YAML plus -CPIL front end, and a pure p6 prelude with a p6 backend-specific overlay.

[20:52] <putter> I'm afraid, for me, the drift part would quite non -Ofun.  So I'll leave that for someone else.

[20:53] <putter> integral: sound plausible?

[20:54] <putter>  

[20:55] <putter> anyone have any comments on the "where do we go from here? - walk through design space" paste?

[20:55] <putter>  

[20:56] <putter> anyone here?

[20:56] <putter> ;-/

[20:56] * putter goes to look at stevan's CPAN modules.  and luqui's...

[21:00] <putter> Class::Role, Class::Roles, Perl6::Roles... weee

[21:01] <obra> Role::Role

[21:03] *** GeJ_ joined
[21:03] <putter> oo, missed that one ;)

[21:04] <putter> err, on cpan?

[21:05] <putter> obra: don't see it on search.cpan... ?

[21:06] <putter> there is Role and Pugs::Role in misc/Perl-MetaModel/lib/

[21:06] <obra> Sorry. Being useless.

[21:06] * obra needs a "bad attempt at humor" flag for irc

[21:07] <putter> ah, np.  nice to hear someone else's voice.  felt like I was talking to myself for a while...  for the backloging, but still...

[21:08] <putter> src/PIL/Native/Bootstrap/Roles/ and Role.pil

[21:08] <putter> maze of twisty little passages

[21:10] <obra> :)

[21:14] <putter> audreyt: is adding class/role attribute/is/does info to -CParser-YAML something you could knock of in a few minutes?  ideally module and package declarations too (ie, just module_declared: name)

[21:14] * tewk has been following along.

[21:15] <putter> :)

[21:15] <putter> tnx

[21:16] <putter> s/knock of/knock off/

[21:23] <putter> does p5/cpan have a backtracking parser??  (P::RD doesn't backtrack)

[21:26] <putter> http://search.cpan.org/~lpalmer/Parse-Earley-0.15/Earley.pm  looks nice, but no backtrack.

[21:36] <putter> http://search.cpan.org/~gslondon/Parse-Native-0.02/ is kind of neat, even if "prerelease, doesnt do anything".

[21:39] *** DesreveR joined
[21:44] *** GeJ_ is now known as GeJ

[21:48] <gaal> FYI: there's a bug in Syck, it doesn't quote ":" and "," scalars, so that when we emit e.g. Syn , the data doesn't roundtrip

[21:48] <gaal> Hadn't the tuits to fix it myself, but I did send in a report to Why.

[21:49] <gaal> FYI II: precompiling Prelude.pm with YAML takes about nine times as long on my machine as -CPugs, but the output is only two-thirds as long.

[21:50] <gaal> FYI III: I tried s/type VStr String/type VStr FastString/ and following the inferencer errors from there, but punted when I reached the parser. Maybe when Audrey arrives. :-)

[21:51] <gaal> fixing #3 will make #2 much better, I'm sure.

[21:52] <gaal> and #1 can be workarounded with a simple fixup in gen_prelude

[21:53] <gaal> but then there's still the question of how expensive loading the YAML is; will it have to be done on every pugs instance load?

[21:54] <gaal> zZ&

[21:54] <putter> good night gaal.  thanks for the fyis :)

[22:03] *** bsb joined
[22:06] <putter> ok, I want the following cpan module(s).  a purely descriptive grammar ast.  nodes for literals, regexs, alternation, etc.  named rule with arguments.  then I'd like a function api to construct these trees.  eg, seq(lit("a"),lit("b")) .  ideally a sub which builds a tree from a p5 or p6 regex string.  though I can build that if i need to.  then,

[22:08] <putter> I want a module which crawls that tree, and gives me the eval'able source for a backtracking, recursive decent parser, made out of subs which take a single continuation (another sub) argument.  having been given textual templates for lit/re match, and pre/post-success/post-fail recursion.  I can then

[22:10] <putter> set up a local() match/search object, and call one of these subs, to get a nice parser.  or wire them together dynamically with  $f1->(sub{$f2->(noop)}).

[22:10] <putter> I think you could also compile them together.

[22:12] <putter> not only do you have a nifty little parser, in which arbitrary perl code can participate fully, but you've both accidentally written a p6 rules engine, and most of a p6 parser.

[22:13] <putter> subs returning undef on failure might be fastest.  I suspect the relay costs (return undef if not $ret) are less than the cost of throwing exceptions.

[22:14] <putter> especially if "run after recursion failure" code appears a lot.

[22:17] <putter> local() gives you p6 temp().  let()... hypothetical variables require some work.  but you could add a let node and constructor to the tree, which handles the messiness.

[22:17] *** drbean joined
[22:18] <putter> you would think someone over the years would have gotten around to the first part, but my searches at least havent turned it up on cpan...

[22:19] <putter> then again, nothing I do ends up on cpan, so if that's typical, then it may have been reimplemented n times already, and just hasnt made it yet. ;)

[22:22] <stevan> putter!!!!!!!!!!!!

[22:22] <stevan> putter is on a roll

[22:22] <putter> http://search.cpan.org/~pinyan/YAPE-Regex-3.02/Regex.pm

[22:23] <putter> hey stevan :)

[22:23] <stevan> putter: all current Roles implementations are incorrect

[22:23] <stevan> Class::Role(s) are based on old specs

[22:23] <stevan> Perl6::Role is fairly close (written by my co-worker with some of my tests)

[22:24] <stevan> and the Perl6-MetaModel and PIL^N ones are wrong too

[22:24] <stevan> Class::Trait is actually got the closest to correct model right now

[22:26] <stevan> as far as working metamodels, Perl6-MetaModel is not bad but needs updating, and the Perl6-ObjectSpace is too specific to the objectspace backend right now to be useful for us (unless we use that as the base VM)

[22:27] <stevan> the biggest problem with all the metamodels has been metacircular issues (as I am sure you recall, the "infinitily recursive recursion" stuff)

[22:28] <stevan> however, I have been testing Class::MOP with Class::C3 (which DBIx::Class actually uses right now with (suprisingly to me) great sucess)

[22:28] <stevan> and the two work fine together ,.. so maybe that is a route

[22:29] * putter pops up from exploring the wonderful world of cpan modules which manipulate re's...

[22:29] <stevan> it should not have the same metacircular issues and actually runs pretty fast cause there is no AUTOLOAD usage

[22:29] <stevan> but alas,.. I really need to run,.. going to dinner with the inlaws

[22:29] <Kattana> putter: find anything like what you want?

[22:30] <stevan> putter: I will try and get some time online tonight and we can talk some details,.. 

[22:30] <stevan> although the ideal is to engineer free time when audreyt will be in .il

[22:30] * stevan vanishes in a *ppof*

[22:30] <putter> stevan: ah well.  enjoy dinner.  we'll touch base at some point.  and plan a get together too.

[22:30] <stevan> yes, definitely

[22:30] <putter> a "*ppof" ?

[22:30] <putter> lol

[22:31] <putter> :)

[22:31] <putter> cheers &

[22:32] <putter> Kattana: YAPE-Regex looks like it did the "generic tree".  I haven't looked at it closely yet.  Does do parse p5 re. :)  doesn't look like it does dsl (but I guess I can live without that).

[22:33] <putter> currently am grovling through the various optimizers, though they seem to be close world so far.

[22:35] <Kattana> dsl?

[22:35] <integral> domain specific language

[22:35] <integral> fwiw, japhy can very occasionally be sighted in #perl on this network

[22:36] <integral> (and japhy wrote YAPE)

[22:47] <putter> http://search.cpan.org/~jdutton/Parse-RandGen-0.202/

[22:47] <putter> integral: ah, thanks.  and perhaps here?  the nick looked familiar...

[22:48] <putter> Kattana: the seq(lit(),lit()) thing.

[22:49] <putter> RandGen has a data based one, eg,  prod=>[ cond=>"token", cond=>"'/'", ]

[22:49] <integral> oh, probably :)

[22:49] <putter> looks like the ast has collapsed a lot of nodes.  but i havent looked at internals yet.

[22:49] <putter> :)

[22:51] <bsb> putter, do you have HOP?  It had parsers and a partial regex iirc

[22:51] <bsb> partial regex engine

[22:52] <integral> there is HOP::Parser on CPAN

[22:54] <putter> bsb,integral: do I, do I, nope.  looknig at cpan...

[22:58] <putter> after seeing "Elsevier", why am I not surprised to see two screens of license text.  blech.  but continuing...

[23:01] <putter> bsb,integral: thanks

[23:01] <integral> np

[23:03] <bsb> welcome

[23:09] <putter> ok, hop uses subs taking a single argument, input.  no tree - the alt() etc return bare subs.  no continuations or general backtracking unfortunately.

[23:11] <putter> so current state is YAPE and RandGen provide trees, but I haven't yet see anyone providing a backtracking recursive decent core w continuations.

[23:11] <putter> continuing to explore cpan...

[23:11] <integral> I actually have a parser.  It's not on CPAN though

[23:11] <integral> it's quite fast, but it's unfinished, but it can backtrack

[23:14] <putter> continuation based?  ie,

[23:14] <integral> no, not as such, but it can save arbitrary state over backtracking

[23:15] <putter> composable?

[23:16] <integral> sorry, I don't understand how to apply composability to continuations in a parser

[23:16] <putter> ie,

[23:16] <putter> thing_matching_a + thing_matching_b -> thing_matching_ab

[23:17] <integral> sure, you'd just construct the program "BRANCH ( A ) ( B )"

[23:17] <putter> i suppose if you're passing along the arbitrary state that'd be no problem.  ah

[23:17] <integral> it's got a rudimentary rules like frontend on it

[23:18] <putter> at choice points you  deep copy the state?

[23:18] <integral> some of the state

[23:18] <putter> like before trying each branch of ... ah

[23:18] <integral> it's got all the different types :)  state that doesn't get saved over backtrack, so branches can remember which to try next,  and state that does

[23:19] <integral> anyway, fwiw, http://integral.ig3.net/svn/mirror/parse/trunk/nge/ is the code

[23:19] <putter> ah, neat.  will look.

[23:19] <integral> I did develop it while looking at perl6 so it should cover all the stuff rules have to do

[23:20] <putter> re things, can thing_b fail back into thing_a, so thing_a can shorten or lengthen its match?

[23:20] <putter> looking at code...

[23:20] <integral> yep, it's got two call opcodes implemented, one that backtracks over the call, and one that doesn't

[23:20] *** oylenshpeegul joined
[23:22] <integral> actually, it *is* basically continuation based :)  It's "activation records" are just call frames, and they form singled linked lists

[23:22] <putter> Like stage 20 ;)

[23:23] <integral> ooh, wow, I included memoised calls, so it remembers how a subrule matches at a given point. (eg. the grammar: "<a> <b> <c> | <a> <c>" only needs to execute <a> once)

[23:29] <putter> lol :)

[23:30] <integral> ah, doc/mkgrammar.pl has the grammar for it's own language, that's neat. self-hosting is always a good sign I guess

[23:31] <putter> gather it's been a while since you looked at this? :)

[23:31] *** oylenshpeegul left
[23:32] <integral> last checkin was march last year :)   I wrote it just soon after pugs started in the general perl6 malaise that filled that period

[23:32] <putter> (aside: http://search.cpan.org/~sadahiro/Unicode-Regex-Set-0.02/Set.pm looks potentially useful - some set ops on unicode charsets)

[23:33] <putter> ah, yes :)

[23:35] <putter> any thoughts on how to easily get one of these critters working?  did you consider a (simpler?) "assemble subs" or (less simpler) "assemble source code for subs" and discard it for performance reasons?

[23:36] <putter> or....?

[23:36] <integral> putter: I'd written another thing that used code generation to build parsers, and I thought it sucked because of our lack of quasiquoting

[23:37] <integral> So I started with the basic idea of opcodes chained together doubly, built the loop for that,  optimised the hell out of it, and uh, ended up with that :-/

[23:37] <integral> the concession to readability is the "microcode", all those little subs inside the StdOps

[23:37] <putter> :)

[23:38] <integral> oh, actually that was another reason:    too difficult to generate code for backtracking

[23:39] <integral> (at least without using the perl call stack)

[23:40] <putter> right.  why not call stack?

[23:40] <integral> overflow, the annoying recursion too deep warning

[23:40] <integral> I mean, if you're matching a very backtracking regexp against a 1k string...

[23:41] <integral> (like you are when parsing source code)

[23:42] *** rantanplan_ joined
[23:42] <putter> i've been hit by "recursion too deep warning", but don't have a feel for it.  can it be turned off?

[23:42] <integral> it can

[23:42] <integral> but some operating systems do still have limited stacks

[23:42] <putter> i fuzzily recal pil2js being decorated by "dont warn about recursion" pragmas.  maybe.

[23:43] <integral> (hint, I've got -Mre=debugcolor style tracing when you turn NGE_DEBUG on,  it's scarily complex to debug this stuff :-/)

[23:43] <putter> how thick is p5 sub call?

[23:43] <integral> can be quite big I think

[23:43] <integral> I just decided to be more resilient,  and it gives you a continuation system too with your own frames

[23:43] <integral> it's easy to implement FENCE ( that's (?>) in p5re) for example

[23:44] <putter> sigh.  is this a show stopper for a call stack based parser, or just a "we know we are going to suffer from/be limited by this"?

[23:45] <integral> hmm, it really depends what the call stack equates to

[23:45] <integral> in Parse::RecDescent it's the nesting of rules calling each other, so probably not

[23:45] * putter is trying for simplicity... adopting a scarily complex to debug vm seems not so much in that spirit...;)

[23:45] <integral> In a regexp engine, very possibly if depth equates to backtracking

[23:46] <putter> frotz.

[23:46] <integral> But in a grammar for perl6 where backtracking is quickly resolved (or so I thought the design goals said...)

[23:47] <putter> worse, in a continuation base... oh, no, p5 has tailcalls.  so as long as you dont need success/failure code run, that wont contribute to stack use.  though trying to avoid success/failure code complicates other things. :/

[23:54] <integral> ooh, I wrote an interactive debugger for it.  anyway, I need to sleep now :)   Good luck with thinking of ideas to get the perl5 impl going

[23:54] <putter> hmm, so 1GB virtual gave me 1.5M deep recursion with a very simple sub.  hmm...

[23:55] <putter> integral: ok, thanks for your help.  'night &

[23:55] *** elmex joined
[23:57] <putter> anyone know if p5 does/doesnt optimize away  my $doesntescape = sub {...}   subs?

