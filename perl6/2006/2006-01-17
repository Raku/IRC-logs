[00:01] <pasteling> "aufrank" at 65.37.87.113 pasted "YAML bug during compilation of Pugs.AST.Internals" (25 lines, 1.7K) at http://sial.org/pbot/15472

[00:07] *** penk joined
[00:09] *** mjl69 joined
[00:13] <aufrank> audreyt: ping

[00:13] <aufrank> gaal: ping

[00:14] <aufrank> ingy: ping

[00:18] <tewk> ll

[00:21] *** Cryptic_K joined
[00:37] *** knewt_ joined
[00:54] *** stevan_ joined
[01:06] *** dolmans joined
[01:15] *** dec joined
[01:16] <dec> perlbot: tutorial

[01:16] <perlbot> http://perlmonks.org/index.pl?node=Tutorials | http://perl.com/cs/user/query/q/6?id_topic=74 | http://learn.perl.org/ | http://books.perl.org/onlinebooks | http://perl-begin.berlios.de/tutorials/ | http://learn.perl.org/library/beginning_perl/

[01:16] <dec> perlbot: perl6 tutorial

[01:16] <dec> damnit.

[01:21] *** scook0 joined
[01:23] *** penk left
[01:23] <scook0> dec: looking for anything in particular?

[01:24] <dec> Not really. I want to get started with perl6 :)

[01:24] <dec> the language mostly, not development of pugs.

[01:25] <scook0> I don't know how much 'tutorial'-type material there is...

[01:25] *** jiing_mIRC joined
[01:25] <scook0> have you looked at the Synopses?

[01:25] <scook0> there's also http://svn.openfoundry.org/pugs/docs/quickref/

[01:25] <dec> The synopses will be a good start.

[01:25] <dec> I'll go check them out.

[01:25] <dec> Thanks :)

[01:26] <scook0> dec: try to get recent ones though, as I've heard some sites only have older versions

[01:27] <dec> I was looking at http://dev.perl.org/perl6/doc/synopsis.html

[01:28] <dec> I know this is a pretty ambiguous question..... but how "stable" is perl6 under pugs?

[01:29] <theorbtwo> Depends what you mean by stable.  It will pretty reliably, I think, do the same thing when you do the same thing multiple times.

[01:29] <theorbtwo> Things that are working tend to stay working across upgrades to pugs.

[01:30] <theorbtwo> OTOH, there are large swaths of functionality that is specced but not there...

[01:30] <theorbtwo> ...and the spec itself changes fairly often.

[01:31] <dec> hehe.. okay, thanks

[01:34] *** oylenshpeegul joined
[01:35] *** Cryptic_K joined
[01:37] *** penk joined
[01:45] *** putter joined
[01:46] <putter> theorbtwo: two thoughts in the category of random brainstorming about p6 editing aids:

[01:47] <theorbtwo> nopaste?

[01:47] <theorbtwo> Er, nevermind, is in topic.

[01:48] *** oylenshpeegul left
[01:48] <putter> it would be nice to have an "explain" function which took a section of source (aka "line noise"), and explained wtf it all means.  I imaging if one had a thousandth cent for each time it was used by new p6 users, one would quickly be rich.

[01:48] * putter was thinking, hmm, nopaste _could_ be an interesting editing aid !;)

[01:49] <pasteling> "theorbtwo" at 212.225.34.71 pasted "#!/usr/bin/perl use warnings;" (170 lines, 4.6K) at http://sial.org/pbot/15473

[01:50] <theorbtwo> Hm, "WTF it all means" is /way/ too open to interpretation.

[01:50] <theorbtwo> Anyway, to use that, do something along the lines of ./pugs -CParse-YAML whatever.pl | perl colorize.pl | less, and look for the Handled: bit.

[01:51] <putter> hmm... which raises the question, do any of the AES mention docstrings, or otherwise the mechanically accessible documentation of code?  one could have a macro which doc "ffooo"  which also grabbed $?SUB, $?LINE, etc.  Perhaps even grab and set-to-empty-string the preceeding $=POD?

[01:51] <theorbtwo> Also, if the last line is not "Got them all!", there's a bug.

[01:51] <putter> looking....

[01:51] <theorbtwo> It is, quite obviously, not done yet.

[01:57] <putter> in p6 it will get easier, eg, you can replace the big if with multis.  multi handle_it(pugs::Var $x) {...}

[01:57] <theorbtwo> I could probably do a lot of visual clean-up now.

[01:58] <theorbtwo> For example, instead of a big if on the class of $it in handle_it, I could inject a method into the handled classes.

[01:58] <putter> multi methods, aka, instant injection :)

[01:59] <putter> I wonder if yaml has a way to do a tree walk.  so one doesnt need to do the @yaml_lines thing.

[02:01] <putter> na, never mind.

[02:01] <theorbtwo> I wanted to do it before YAML parsing, though -- until I switched to YAML::Syck, I needed to set up the class mapping.

[02:05] <dec> damnit, i'm in over my head already and i'm only up to the 2nd Perl6 spec. :P

[02:05] <putter> oh, before I forget, the other editing random idea was to have an "expand", which converts say <<{+@a}>> into say quote_with_interpolation(closure_in_quote(array_length(@a))).  which is reversible.

[02:10] <putter> dec: the learning curve on p6 is going to be major issue.  it will be like p5 - everyone uses a dialect, with just a subset of the language's features.  unlike with p5, it may be critical to establish a "common dialect kernel".  a "default to doing it one way".  or the CPAN experience of "I see the code.  I have no idea what it means" may become common.

[02:11] <dec> Mmmm. The code I understand, it is the literal english specifications of the code that I don't.

[02:13] <theorbtwo> Anyway, putter, one of the major issues with that code seems to be that I'm still not getting as much in the way of location information as I'd like.

[02:14] <putter> you might want to start with docs/other/porting_howto and looking through the examples/ .  just to start with the experience of "yes, this is perl, i still have a feel for this, even if I'm not yet clear on all the details".  the synopses are like a language reference spec, chopped up, pasted on index cards, and tossed up into the air and onto a desk (well, maybe not quite that bad).  you have to get a feel for the big picture first.

[02:15] <putter> dec: ah, neat, just as I anticipated. :) :)

[02:17] <dec> Yes, I'm reading the porting howto's at the moment. They've made the most sense so far. :)

[02:17] <dec> I like the 'for @baz -> $foo { ... }' syntax. it's sexy. :)

[02:18] <robkinyon> seen stevan

[02:18] <jabbot> robkinyon: stevan was seen 7 hours 38 minutes 32 seconds ago

[02:18] <robkinyon> seen stevan_

[02:18] <jabbot> robkinyon: stevan_ was seen 7 hours 44 minutes 40 seconds ago

[02:18] <putter> theorbtwo: there used to be a _lot_ more pos'es.  they were making things visually cluttered and obscure for backend development, so the number dropped dramatically.  I'm not sure how to handle that.  -C is somewhat a small peep-hole to make complex requests.  -C Parser-YAML-LotsOfPos  ;)

[02:19] <theorbtwo> dec: Also, very general, which is very very good.

[02:20] <dec> theorbtwo - yes, indeed

[02:20] <dec> I just wish I knew _why_ these things had been changed and what the significance of it is.

[02:20] <dec> But to learn that, I'd have to read through the specs - which I don't understand.

[02:20] <dec> :P

[02:22] <putter> There is a wiki http://pugs.kwiki.org/ .  Perhaps we should start a page GettingStartedAdvice?  Then as you think "oh, it thought it was foo, but it turned out to be bar", or "hee was very useful to clarify qux", we could collect that.  so the next person has a leg-up.  it's hard for folks who already know something to put 

[02:22] *** luqui joined
[02:22] <putter> themselves back in the mental space of not knowing, to well judge what's useful/needed.

[02:23] <dec> I'll try and keep some notes as I learn :)

[02:23] <scook0> putter: I think the wiki is now deprecated in favour of putting reusable docs straight in svn

[02:23] <putter> dec: actually, the _why_, the design rationale, is mostly only available on the p6l mailing list.  there's another book for someone to help write.

[02:24] <dec> Oh ok.

[02:24] *** penk left
[02:24] <dec> Maybe I should subscribe to the mailing list then :)

[02:26] <putter> scook0: true.  but for something like this... most newbies wont have a commit bit during the time of interest.  even pugs isnt doing "hi, I heard about p6, and wanted to kno [interrupt - "here, have a commit bit"]".  close, but not quite ;)

[02:26] * theorbtwo wonders if his metacommitter bit is still active.

[02:27] <putter> http://www.nntp.perl.org/group/perl.perl6.compiler http://aspn.activestate.com/ASPN/Mail/Browse/Threaded/perl6-language

[02:27] <putter> from the wiki ;).  there really needs to be a way to do two-way wiki-svn integration.

[02:28] <putter> like a mailing-list<->newgroup gateway.

[02:29] *** Amnesiac joined
[02:32] * putter wonders is test-driven development is quite the right thing.  adding tests for unimplemented language features is a wonderful Right Thing.  but spending time on :16<3a> alternate-base number representation, instead of on say piln, seems suboptimal.

[02:32] * putter goes off to add parsing for :16<3a>...

[02:34] <SamB> well, you have to write the low-hanging tests

[02:35] <putter> no question.  but maybe they should go in as / be quickly changed to  :todo<feature>.

[02:35] <dolmans> i am now reading the Synopses, there are reduction operators [*] @array, dose there still a normal `reduce' operator, i think sometimes i prefer use english word

[02:35] <putter> dont even have to be low-hanging.  it would be useful for someone to do a systematic walk through the synopses, generating missing tests.

[02:36] <luqui> dolmans, yes, "reduce" still exists

[02:36] <dolmans> luqui: thx

[02:38] <luqui> dolmans, yeah, english is nice, but reduce is especially necessary for reductions that aren't over a predefined infix operator...

[02:39] <SamB> luqui: what? you people still need infix ops *predefined*?

[02:39] <SamB> how primitive!

[02:40] <luqui> yeah... haskell's simple syntax is nice for not having to predefine operators

[02:40] <luqui> unfortunately, perl 6's syntax is about as far from simple as it gets

[02:40] <theorbtwo> Writing any operator as prefix is easy, but AFAIK, there's no simple way to infixify a prefix op.

[02:41] <luqui> ?

[02:41] <luqui> I don't follow theorbtwo 

[02:42] <luqui> are you talking about, eg. haskell's `op` syntax?

[02:42] <theorbtwo> Yeah.

[02:42] <theorbtwo> There's no p6 equiv to it.

[02:42] <luqui> say $foo;  $foo.say

[02:42] <luqui> (though that's not in general equivalent)

[02:43] <dolmans> i heard ruby even can 1.print;  am i right?

[02:43] <luqui> but that's because print is actually a method on numerals

[02:43] *** vel__ joined
[02:43] <putter> macro prepostcircumfix:<` `>($lhs,$op,$rhs) { "$op($lhs,$rhs)" }  ?  or something like that.

[02:44] * luqui doubts the correctness of the now-ubiquitous $foo.say

[02:44] <luqui> putter, incircumfix:<` `> ?

[02:44] <putter> could be.  I remembered postcircumfix, and extrapolated ;)

[02:45] <theorbtwo> That's prefix:<$op>($lhs, $rhs), though.

[02:45] <theorbtwo> Other then that, IWFM, assuming `` isn't gramatically ambigious there.

[02:45] <putter> there's a table in one of the AES

[02:45] <luqui> `` isn't in the language yet IIRC

[02:46] <luqui> it's the character that everybody will use for their custom operators....

[02:46] <luqui> because it's the only one on the keyboard that doesn't already have a meaning!

[02:46] <\xe6var> can I define a "n-fix"? i.e. a n-ary operator nary<? :> ($x, $y, $z) ... nary:<x y z> ($x, $y, $z, $a) ...

[02:46] <putter> "macro's... your only one line away from having anything you want in the language" (not really of course)

[02:47] <putter> luqui: lol

[02:47] <luqui> \xe6var, well, not currently

[02:47] <SamB> luqui: isn't that outfix?

[02:47] <\xe6var> luqui: I mean in perl 6-foo

[02:48] <putter> "and battle was joined over the precious "only character on the keyboard that doesnt (yet) already have a meaning""

[02:48] <luqui> \xe6var, right, and as currently specced, there's no *easy* way to do that

[02:48] <luqui> but I'm trying to get the OPP general enough to handle such arbitrary definitions

[02:48] <SamB> putter: this is probably why p6 does that unicode thing

[02:48] <\xe6var> luqui: woo;)

[02:49] <luqui> but it may be that I'm trying to solve the LALR parsing problem

[02:49] <putter> and, where's that link, the keyboard where each keyface has a led display... and keyboards are getting wizzier.

[02:49] <luqui> which isn't dynamically modifiable

[02:50] * theorbtwo likes the key on his keyboard that means pretty much anything.

[02:50] <theorbtwo> compose++

[02:50] * putter wants a full unicode keyboard.  fiddle with say the num pad, and all the main keys walk over code space.

[02:50] * SamB wishes he had one of those

[02:50] <luqui> ack, pugs is not building!

[02:50] <theorbtwo> putter: It's just some fake photos and advertising copy.

[02:51] * luqui investigates

[02:51] <putter> bummer.  eventually...

[02:51] <theorbtwo> I'm using europan keyboards with an en_US layout, which leaves the key just to the right of shift open to be a compose key.

[02:52] <SamB> I should be using a Windows key as that...

[02:53] *** vel__ left
[02:53] <putter> \xe6var: that would be great.  make the smalltalkers feel at home.  cant quite do it yet.

[02:55] <theorbtwo> I would, but I'm using an old IBM type M without a win key on my desktop.

[02:57] * putter really just wants to have 36 version of macro prefix:<:16>($n) {...}.  but :16 is a little to weird a name for the parser at present.  and the prelude doesnt need more cruft.  sigh.  "piln, piln, ra!"

[02:59] <putter> http://slate.tunes.org/  Slate is a nice modern smalltalk-family language.  use Languages::Slate::OnPerl6; ... ;)

[03:08] <svnbot6> r8713 | luqui++ | "fixed" the build by removing envImplicit from the YAMLization.  Clearly

[03:08] <svnbot6> r8713 | luqui++ | this is wrong, but it's important to have our software building.

[03:10] *** hcarty joined
[03:11] <putter> ok, I'm going to punt on :8<15>.  what I'd like to do is refactor possiblyApplyMacro to get a... ruleApplyMacroFoo?  something which fails if the given name is not a macro.  then pairAdverb can try :mumble as a macro before doing the usual.  is that plausible?

[03:12] <putter> anyway, experience suggests that flavor of parser mod can have an unfortunate impact on parse speed.  so something to do after release, when there is time to detect and address.

[03:12] <putter> luqui++

[03:20] <audreyt> luqui: how did P.A.Internals fail envImplicit for you? it worksforme

[03:20] <audreyt> (not that you should revert the change; I'd just like to know the error msg)

[03:20] <audreyt> I just woke up -- going to find food and shop around for a bit; be back in ~4 hours

[03:22] <luqui> no instance for YAML ()

[03:26] <audreyt> fixing

[03:27] <audreyt> aha, you have parrotembed.

[03:27] <putter> ?eval 3

[03:28] <audreyt> s/parrotembed/perlembed/

[03:29] <audreyt> ok, fixed, but I don't have time to test/commit now

[03:30] <audreyt> bbl

[03:34] <putter> imaginary irc log: <audreyt> I have to leave now.  <lambdacamel> problem mumble... <audreyt> well, I debugged it leaving the kitchen, wrote a fix walking through the living room, but now I've hit the front door and will have to test/commit later.  <lambdacamel> ok, thanks.  just another day at pugs.

[03:35] <putter> hey, a real bug!  is {("a" => 42),}.ref supposed to be ::Block?

[03:36] <putter> doesnt like the ",", even with a second pair present.

[03:54] *** hcarty left
[03:57] <luqui> putter, you know, it might just be a ::Block

[03:57] <luqui> {} dwimmery is supposed to be stupid

[03:58] <luqui> i.e. { a => 42 } is a hash but { (a => 42) } might be a block

[04:03] *** brentp left
[04:09] <putter> luqui: maybe.  but {("a" => 2),("b" => 3)} has to be a hash, no?  a list of two pairs wrapped with {}?

[04:10] <luqui> why?

[04:10] <luqui> { "a" => 2, "b" => 3 } is equivalent

[04:10] <luqui> I'd say that (a => 2), (b => 3) is not a list of two pairs; it's a list of two expressions

[04:10] <luqui> we're doing syntactic dwimmery, which is tough to think about

[04:10] <luqui> it might be best to ignore parentheses

[04:10] <putter> the parser is currently handling hashes by parsing them as blocks, and then groveling over the ast asking "does this look like a misparsed hash?". ;)  inherently fragile.  so I'm exploring whether the grovel missed a node.

[04:11] <luqui> putter, it's a very well-defined "does this look like a misparsed hash?"

[04:11] <luqui> S04 IIRC

[04:11] <putter> {("a" => 2)} parses as a hash...

[04:11] <luqui> if the thing in the block is "either a pair or a list whose first element is a pair"

[04:11] <luqui> putter, then that might be wrong

[04:11] <luqui> (or a hash)

[04:12] <luqui> it's a question of interpretation

[04:12] <luqui> is (a => 2) a pair or not?

[04:12] <luqui> because:  sub foo() { a => 2 }  { foo() }   is not a hash

[04:12] <luqui> by spec

[04:13] * luqui wonders if we should kill {} as a hash constructor, and simultaneously ducks

[04:13] <luqui> i.e. maybe we should do what we're doing with sets

[04:13] <luqui> and allow lists to double as hashes

[04:13] <luqui> but that's being very radical

[04:14] <luqui> and probably "enemy of the perl people"

[04:23] <putter> back

[04:25] <putter> I believe there was an Ann'otation node where the groveler wasnt expecting one.  but adding that case completely breaks things, so I'm not understanding something.

[04:27] <putter> luqui: the other ideas I'm afraid I have insufficient brain for just now.  mindlessly emulating a tree walk is (maybe) just within reach.  then its end of day

[04:33] <putter> can one pattern match against one field of a mumble?  exp@MkCode { subBody = bod } ?

[04:36] <putter> luqui: i suspect what happens is that in sub foo() {} context, the block to hash conversion is not attemped.

[04:37] <luqui> putter, yes you can match against one field

[04:37] <luqui> putter, I meant that:  sub foo() { blah blah; a => 2 } { foo() } is not a hash

[04:37] <luqui> because foo() is not a pair

[04:37] <luqui> even though it will eventually return a pair

[04:38] <luqui> it is not one *syntactically*, and the hash/code dwimmery is a syntactic dwimmery

[04:39] * luqui will be in and out for a while...

[04:40] <Khisanth> meh why not just leave it as sub { }

[04:40] <putter> luqui: oh, yes.

[04:40] <putter> Khisanth: huh?

[04:41] <Khisanth> as opposed to overloading {}

[04:43] <putter> oh, the problem is {("a" => 3)} is parsing as a hash (correctly according to the tests), but {("a" => 3),} is not.  nor {("a" => 3),("b" => 4)}.

[04:43] *** jiing_mIRC joined
[04:44] <Khisanth> heh I guess somethings just don't change

[04:45] <putter> they show up as Blocks.  the parser works by parsing both as blocks, and then goes back and pattern matches the tree to see if it should be a hash instead.  my working hypothesis is that pattern match doesnt quite handle the current ast.

[04:45] <putter> s/both/blocks and hashes/

[04:55] <putter> anyone know if Parser.hs file state ends up somewhere else?  I'm in the odd state where svn diff is null, but when ./pugs is recreated, it's different than it was before I fiddled with Parser.hs.  :(

[04:55] *** dolmans left
[05:12] *** stevan__ joined
[05:29] *** justatheory joined
[05:31] <putter> Anyone know why this

[05:32] <putter> Stmts (Syn "\\{}" [Syn "," [Ann (Pos (MkPos "<interactive>" 1 4 1 12)) (App (Var "&infix:=>") Nothing [Ann (Cxt (CxtItem (mkType "Str"))) (Val (VStr "a")),Val (VInt 3)])]]) Noop

[05:32] <putter> would be undef?

[05:32] <putter> s/be/evaluate to/

[05:40] *** justatheory joined
[05:41] <pasteling> "putter" at 66.30.119.55 pasted "unfinished Parser.hs patch to address a hash misparse and t/builtins/perl.t failure" (33 lines, 1.3K) at http://sial.org/pbot/15478

[05:42] <putter> end of day for me.  paste has what seems to be an "almost but not quite" fix for the hash misparse.

[05:42] <putter> good luck, and good night &

[05:43] *** justatheory joined
[05:53] *** mjl69 joined
[05:55] *** elmex joined
[05:57] *** Medvekoma joined
[06:03] *** blm joined
[06:37] *** GeJ joined
[06:58] *** phredmoyer joined
[06:58] *** phredmoyer left
[07:11] *** stevan_ joined
[07:14] *** tsume joined
[07:14] *** tsume left
[07:15] *** Cryptic_K left
[07:16] *** gilby joined
[07:32] *** iblechbot joined
[07:44] *** brianski joined
[08:03] *** __Ace__ joined
[08:04] <__Ace__> so, its possible to dl perl6 for testing?

[08:05] <luqui> __Ace__, yep

[08:05] <__Ace__> ok, from where? :)

[08:05] <luqui> __Ace__, well, what platform are you on?

[08:05] <__Ace__> Windows

[08:05] <luqui> hmmm, so you probably need a binary

[08:06] <__Ace__> would prefer that yes :)

[08:06] <luqui> there is a binary distro, but I don't quite remember what it's called.  I'm looking.

[08:06] <tewk> __Ace__: perl6 is a long ways from being finished, but you can definately start playing with pugs.

[08:06] <gaal> pxperl

[08:06] <tewk> PXPerl

[08:07] <luqui> gaal, tewk, thanks

[08:07] <gaal> I wonder how well-updated it is

[08:07] <luqui> 6.2.9

[08:08] <tewk> Last I checked, it wasn't :(

[08:08] <tewk> yep

[08:08] <luqui> we're currently at 6.2.10... so, barring the amazing dev speed of pugs, it doesn't seem *too* out-of-date

[08:08] <gaal> there were over 1000 commits since the last release :)

[08:08] <luqui> but I don't really follow the release cycle

[08:09] <luqui> ahh.  well, it'll give you a feel in any case

[08:09] <__Ace__> so, pugs is Perl6 alpha?

[08:09] <tewk> Yeah, but .11 is coming soon and a lot has been changing

[08:09] <tewk> __Ace__: Yes.  It really is a Perl6 interpreter at this point.

[08:09] <luqui> __Ace__, yes, maybe even pre-alpha

[08:10] <luqui> it's a bootstrap... maybe, depending on how things go

[08:10] <tewk> luqui is right, while very functional and fun to play with, it certainly isn't feature complete.

[08:11] <tewk> But then again I don't think all the features have even been defined yet :)

[08:11] <__Ace__> so, what is the eta for perl6 to be done anyway?

[08:11] <luqui> tewk, it's pretty close.  We're missing some details of the module system, and we're missing parametric roles and a type system, but other than that it's okay

[08:11] <luqui> __Ace__, by christmas

[08:11] <luqui> :-)

[08:12] <__Ace__> :)

[08:12] <luqui> (not committing to which christmas, of course)

[08:13] <__Ace__> hey, no Win32:: in PXPerl! :)

[08:14] *** pdcawley joined
[08:51] *** G2 joined
[08:57] *** kane_ joined
[09:06] *** dec_ joined
[09:08] *** nnunley joined
[09:48] *** Cryptic_K joined
[09:54] <audreyt> rehi!

[09:57] * audreyt goes back relenging

[10:08] *** scw_ joined
[10:14] <svnbot6> r8714 | audreyt++ | * The deriving error has nothing to do with envImplicit

[10:14] <svnbot6> r8714 | audreyt++ |   (and everything to do with PerlSV had a duplicate YAML

[10:14] <svnbot6> r8714 | audreyt++ |   instance) -- fix it correctly.

[10:17] <svnbot6> r8715 | audreyt++ | * update symbolic_deref.t on CALLER with the recent env change.

[10:17] <svnbot6> r8716 | audreyt++ | * fix syck's warnings about missing prototypes.

[10:29] <svnbot6> r8717 | audreyt++ | * repair t/syntax/parsing/sub_calls.t regression:

[10:29] <svnbot6> r8717 | audreyt++ |     Foo .(1)

[10:29] <svnbot6> r8717 | audreyt++ |   is calling &Foo, not ::Foo.

[10:35] <svnbot6> r8718 | audreyt++ | * Eliminate both C and Haskell warnings from Data.Yaml.Syck.

[10:35] <svnbot6> r8719 | audreyt++ | * Ditto for DrIFT.YAML.

[10:38] <svnbot6> r8720 | audreyt++ | * Remove not (yet) used modules from Pugs.cabal: FPS, DrIFT.Binary.

[10:38] <svnbot6> r8721 | audreyt++ | * further suprress hsc warnings in D.Y.Syck.

[10:42] *** joepurl joined
[10:44] *** elmex joined
[10:55] <luqui> audreyt, ping

[10:56] <audreyt> pong.

[10:56] <luqui> I've been thinking about an object model based on virtual classes

[10:56] <luqui> and I wanted to bounce it off you before I go and write about it

[10:56] <audreyt> go ahead, I'll take your brain dump

[10:56] * audreyt is still relenging, so will reply slower

[10:56] * luqui isn't sure what relenging means...

[10:57] <svnbot6> r8722 | audreyt++ | * numbers.t: all underscore-related subtests now pass.

[10:57] <luqui> we kill the concept of a parameterized type.

[10:57] <luqui> or, rather, parameterized class I suppose.  Keep types out of it for the moment.

[10:58] <luqui> instead, we use the neat concept of a virtual class to provide all parameterization

[10:58] <luqui> consider: class List { class of {};  method fetch (Int --> of) {...} }

[10:59] <luqui> then a 'List of Int' is an anonymous subclass of List where "of" has been overriden to be int.

[10:59] <theorbtwo> Morning, all.

[10:59] <audreyt> theorbtwo: yo

[11:00] <luqui> you could also sugar up other Foo[Bar] parameterizations to do a similar thing to named class members

[11:00] <audreyt> you can override inner classes when you subclass stuff?

[11:01] <integral> that would imply that classes are looked up via inheritance like methods!

[11:01] <audreyt> that is weird.

[11:01] <integral> it's a bit like perl5...

[11:01] <audreyt> prior art?

[11:01] <luqui> A12?

[11:01] <audreyt> integral: not inner classes, no

[11:01] <luqui> I think it talks about it a little bit.

[11:01] <audreyt> A12 talks about everything a little bit.

[11:01] <audreyt> it's not in S12 ;)

[11:01] <luqui> :-p

[11:02] <luqui> anyway, suppose you can

[11:02] *** chris2 joined
[11:02] <audreyt> so innerc classes are just like methods

[11:02] <audreyt> okay, go ahead... this is starting to sound voodoo

[11:02] <luqui> I'm trying to go somewhere pretty nonconventional...

[11:02] <luqui> anyway, a generic sub:

[11:03] <audreyt> it's fine as long as you can write down its semantic :)

[11:03] <luqui> sub foo (SomeParametricRole ::R $x) { my R::of $y;  ... }

[11:03] <luqui> so it's kinda like a compile-time method

[11:04] <luqui> okay, bringing types back into the picture:

[11:04] <luqui> a member class is not *exactly* like a method

[11:05] <luqui> because its usage imposes subtyping constraints on the class in which it is used

[11:06] <luqui> If it is used covariantly (return) within its outer class, then you must override it with a subclass of itself to maintain proper subtyping

[11:06] <svnbot6> r8723 | audreyt++ | * new backend: -CParse-Pretty, to show a pretty parse tree.

[11:06] <luqui> and vice versa for contravariant (you must override it with a superclass of itself)

[11:06] <luqui> this pretty much requires that anything that has a member class is closed

[11:07] <luqui> however--it's possible to override it with things that don't satisfy these constraints

[11:07] <audreyt> so you're talking about encoding generic types using overrided subclassing

[11:07] <luqui> yep

[11:07] <audreyt> it sounds like exactly what GJ does

[11:07] <luqui> GJ?

[11:07] <audreyt> so before you reinvent their proven alrogithm:

[11:07] <audreyt> algorithm, even

[11:07] <audreyt> http://homepages.inf.ed.ac.uk/wadler/gj/Documents/

[11:08] <audreyt> it's now part of Java 1.5

[11:08] * luqui wonders how audreyt knows so many things about so many languages

[11:08] <audreyt> (also see Scala's encoding in vObj.)

[11:08] <luqui> okay, let me dump a few more lines, then I'll read

[11:08] <audreyt> cool :)

[11:09] <luqui> so, you can override a "generic" class with something that doesn't satisfy the aforementioned subtyping constrants

[11:09] <luqui> and that's okay, but you don't get a subtype back

[11:09] <luqui> so we're really talking about something more general than subclassing

[11:09] <luqui> it's more like "role composition" on a module level

[11:09] <luqui> something that does a role is not necessarily a subtype of that role

[11:09] <luqui> in fact, a role may not define a conventional type at all

[11:09] <luqui> but more like a typeclass predicate

[11:10] <luqui> and that's where you get generic modules

[11:10] <luqui> which is where this whole line of reasoning started

[11:10] * luqui thinks </dump>

[11:11] <audreyt> I think you really want both the GJ paper and the vObj paper :)

[11:11] <audreyt> I think the generics encoding is sane.

[11:11] *** ohsix joined
[11:12] <luqui> cool

[11:12] * luqui reads

[11:12] <audreyt> though if we have dependent typing (type-operators-taking-value-parameters), the encoding of generics is far easier

[11:12] <luqui> but type inference is pretty much dead...

[11:12] <audreyt> not so; we'd require annotations

[11:12] <audreyt> but p6 always require annotations for staticness

[11:12] <audreyt> so we are on safe ground.

[11:12] <luqui> hmm.. perhaps

[11:13] <audreyt> i.e. it's late binding if you omit all type annotations by default

[11:13] <audreyt> (cf. "two-level lambda calculus")

[11:13] <audreyt> which discusses the early/late binding stuff. also the "Inlining as staged computation" paper linked from my blog -- but definitely GJ/vObj first

[11:14] <luqui> thanks

[11:14] <audreyt> s/also/the dynamic-and-static binding regime is also discussed in/

[11:14] <audreyt> np :)

[11:15] * luqui is definitely going to brainstorm his masters thesis with audreyt to make sure he doesn't do something that someone else has done

[11:15] <luqui> if audreyt can't think of anybody who's done it, then it definitely hasn't been done! :-)

[11:16] <audreyt> nah. ;)

[11:16] <audreyt> I've just been spending way too much time on PL papers.

[11:16] <audreyt> <- knows nothing about math, which is luqui's major

[11:16] <luqui> but my focus is theoretical computer science

[11:16] <audreyt> *nod*

[11:17] * luqui reads... for real

[11:17] *** dec joined
[11:20] <luqui> audreyt, do you know about pizza?

[11:20] <audreyt> yup

[11:20] <luqui> "in pizza the type of an expression may depend on the type expected by its context"

[11:20] <luqui> sounds like perl...

[11:21] <audreyt> yeah, GJ grew out from Pizza

[11:21] <luqui> so I just read :-)

[11:21] <audreyt> well, it's not really like perl ;) the context is static

[11:21] <luqui> so perl has more of an MMD context...

[11:21] <audreyt> it's more like early bound multis decided by return types

[11:21] <luqui> oh right, I meant to argue with you about your context conclusions

[11:22] <audreyt> sure, go ahead :)

[11:22] <audreyt> (with code, if possible)

[11:22] <audreyt> (I mean demo code, not haskell prototype)

[11:22] <luqui> so you claim that the "parametric" context model doesn't require the multiple inheritance restriction

[11:23] <luqui> in order for "want" to be well-defined

[11:23] <luqui> before I argue this, I'll define what I mean for want to be well-defined

[11:23] <luqui> that is, if want A and want B are both true, then A <: B or B <: A

[11:24] <luqui> that means that you can write a switch on want and be sure that you can pick an alternative unambiguously

[11:24] <luqui> but that definition itself seems to contradict the fact that you can have multiple inheritance

[11:25] <audreyt> my claim is simply:

[11:26] <audreyt> if you MI on parametric contexts, you don't get a unambiguous switch.

[11:26] <audreyt> and we can detect and warn for that.

[11:26] <audreyt> and if users want a MI ambiguous context, they should get it.

[11:26] <audreyt> end of claim.

[11:26] <audreyt> (cf. -fallow-undecided-instances in GHC)

[11:26] <luqui> but you can't guarantee that modularly

[11:26] <audreyt> undecidable-instances, even

[11:27] <audreyt> why not? context, like everything else, is per compilation uint.

[11:27] <audreyt> unit

[11:27] <luqui> if MI is allowed, then there is no unambiguous switch that you can ever write

[11:27] <audreyt> huh.

[11:27] <luqui> i.e., let's say your switch is:  given { want A { ... } want B { ... } }

[11:27] <luqui> I can just say:  class C is A is B { }

[11:27] <luqui> and your switch is ambiguous

[11:28] <audreyt> how is it different from any other switch?

[11:28] <luqui> what do you mean?

[11:28] <audreyt> i.e. not on want, but on objects that may have MI

[11:28] <audreyt> given $obj { when A {...} when B {...} }

[11:28] <audreyt> class C is A is B; $obj := C.new

[11:29] * audreyt is implementing x[1,2,3]

[11:29] <luqui> hmmm... I remember reasoning about this when I proved the no MI thing

[11:29] <luqui> but, I don't seem to recall what I concluded ;-)

[11:30] <luqui> it had something to do with the fact that the context was a type, whereas the parameters were objects

[11:31] <audreyt> implemented

[11:31] <leo_> audreyt: what should happen with this code: sub f ($x) { sub g () { print $x };  } f(10);  g(); 

[11:31] <audreyt> context has a static meaning as a type

[11:31] <audreyt> and a dynamic meaning as an object

[11:31] <luqui> audreyt, what kind of object is it?

[11:32] <luqui> it's certainly not the same kind of object as the parameters

[11:32] <luqui> "I'm expecting a 1"

[11:32] <audreyt> luqui: a Cxt, I think

[11:32] <audreyt> it's implemented as such currently

[11:32] <luqui> ahh, but Cxt is a thing like "Int"

[11:32] <luqui> which is a type

[11:32] <luqui> it's an object, but its meaning is at the type level

[11:33] <audreyt> ...so?

[11:33] <audreyt> Int is also an object.

[11:33] <luqui> so my conclusion had something to do with that :-p

[11:33] <audreyt> my $obj = Int;

[11:33] <audreyt> and you can also given/when on $obj.

[11:33] <audreyt> leo_: 10.

[11:33] <audreyt> leo_: larry's ruling

[11:33] <luqui> let me try to rereason my way through this

[11:34] *** nnunley joined
[11:34] <audreyt> leo_: I think it's intuitive, or at least easy to explain.

[11:34] <audreyt> certainly much more so than "will not stay shared"

[11:34] <luqui> audreyt, what about:  sub f ($x) { sub g() { print $x } }  f(10);  f(20); g();

[11:34] <audreyt> luqui: 20, surely

[11:35] <luqui> that's kind of nightmarish for concurrency

[11:35] <audreyt> not so under STM.

[11:35] <luqui> but I guess it's not that different from a shared var.

[11:35] * audreyt invites luqui to forget locking

[11:35] <audreyt> indeed

[11:35] <leo_> audreyt: yes, the difference to the p6l post is though, that g() isn't called inside f(), therefore it's a bit tricky to create the closure 

[11:35] <luqui> it just seems wrong to allow that

[11:36] <luqui> sub f ($x) { sub g() { print $x } }  g();

[11:36] <audreyt> leo_: but your :outer is already generated

[11:36] <audreyt> leo_: since we have the invariant that the outer has to be allocated before inner

[11:36] <theorbtwo> It seems wrong to /do/ that.  I'm not so sure about /allowing/ it.

[11:36] <audreyt> leo_: so surely you can ignore the call chain and perform tne closing at compile (LexInfo composition) time?

[11:36] <luqui> sub f ($x, $i) { sub g() { print $x }  f($x+1, $i-1) if $i }  f(0, 5);  g();

[11:37] <luqui> try that one on for size!

[11:37] <leo_> f doesn't know anything about that it'll be closed over later

[11:37] <audreyt> leo_: f has a lexpad; isn't that sufficient?

[11:37] <leo_> but no persisten context

[11:38] <audreyt> luqui: subroutine calls are just bindings via Sigs/Args.

[11:38] <audreyt> luqui: and bindings are just method calls on Sigs.

[11:38] <luqui> audreyt, but which pad does g() refer to?

[11:38] <audreyt> luqui: so that is perfectly isomorphic to { my ($x, $i); sub g {... }; ($x, $i) := (...) }

[11:38] <luqui> it's recursive, so there's not a single pad

[11:39] <audreyt> luqui: you end up with a lexical scope dominated by dynamic scoping 

[11:39] <audreyt> luqui: which is, again, not something perl5 cannot do

[11:39] <luqui> s/cannot/can/?

[11:39] <audreyt> perl5 can do that happily

[11:39] <luqui> oh...

[11:39] <audreyt> *f = sub { *g = sub { ... } }

[11:40] <audreyt> does that for you

[11:40] <luqui> audreyt, so the order of the sub def matters!?

[11:40] <audreyt> luqui: sure, if one is inner of another

[11:40] <audreyt> luqui: that is pretty much inescapable

[11:40] <luqui> I suppose it is if we allow this behavior

[11:40] <theorbtwo> I've been operating on the assumption that every time sub x {...} is executed, you redefine the existing sub x.

[11:40] <theorbtwo> That seems to follow the behavior being specced, no?

[11:41] <luqui> theorbtwo, but sub x() { } is compile time!

[11:41] <audreyt> theorbtwo: yes and yes.

[11:41] <audreyt> luqui: it is _also_ runtime.

[11:41] <luqui> audreyt, but:

[11:41] <audreyt> perl subs has long have this dual nature

[11:41] <luqui> if 0 { sub foo() { 42 } }  foo()

[11:41] <audreyt> it's closed once at compile time

[11:41] <luqui> hmm, okay

[11:41] <audreyt> and the closed as neccessary at runtime

[11:41] <audreyt> s/the/then/

[11:42] <luqui> that just gives me the shivers

[11:42] <luqui> but maybe it's a ideological issue

[11:42] <audreyt> I actually like this :)

[11:42] <theorbtwo> luqui: Um, so don't use it?

[11:42] <audreyt> and note that python and ruby closes _only_ at runtime

[11:42] <audreyt> which ought to give you more shivers.

[11:42] <luqui> theorbtwo, I'm a language designer, it's my job to try to argue about things that give me the shivers

[11:42] <luqui> because it will probably give others the shivers too

[11:42] <luqui> but I'm used to losing arguments :-)

[11:43] <luqui> audreyt, yes, I'm aware of ruby's runtime-onlyness, which is very shiverifying

[11:43] <audreyt> 12:37 < leo_> but no persisten context

[11:43] <audreyt> leo_: elaborate?

[11:43] <audreyt> leo_: you mean the regs are not allocated yet?

[11:44] *** DaGo joined
[11:44] <leo_> if f(10) is called, it just returns and destroys the context

[11:44] <audreyt> leo_: yes, and it should rebind g's context, no?

[11:44] <leo_> it doesn't know about sub g :outer(f)

[11:45] <luqui> audreyt, time for some serious argument multitasking

[11:45] <luqui> audreyt, what does "want" mean?

[11:45] <luqui> if you're in Scalar context, should want Num return true?

[11:45] <leo_> it's different to the example posted on p6l

[11:45] <luqui> if you're in Int context, should want Num return true?

[11:45] <audreyt> leo_: yup, I see that... I'd like to know the feasibility of ignoring the call chain

[11:46] <leo_> I can it make working if needed

[11:46] <leo_> the p6l thingy already works, printing 20, 110

[11:47] <audreyt> I think larry's (and my) preference is to make it work, if it doesn't harm performance much

[11:47] <audreyt> but if outer has to belong in caller chian, then we still need a way to encode

[11:47] <audreyt> {my $x; sub g {}}

[11:47] <audreyt> which should always work

[11:47] <audreyt> but yet violates the outer-in-caller criteria

[11:47] <audreyt> so ignoring the call chain altogether is preferred

[11:48] <leo_> ok, I'll give it a try

[11:48] <audreyt> luqui: surely not

[11:48] <luqui> audreyt, in either case?

[11:48] <luqui> (I'm assuming that Int <: Num <: Scalar)

[11:49] <audreyt> luqui: nod... I think want Num should return true on Int context, but not on Scalar context.

[11:50] <luqui> want Foo asks if Cxt ~~ Foo

[11:50] <audreyt> "do you want something that can fit into a Num?"

[11:50] <audreyt> although I can argue bothways

[11:50] <luqui> I think that a Num would fit into a Scalar

[11:50] <audreyt> "do you want something that returning a Num would do?"

[11:51] <theorbtwo> "If I returned a Num, would that satisfy you" is surely the more interesting question?

[11:51] <luqui> oh wait, your language is unambiguous

[11:51] <luqui> theorbtwo, but it's not

[11:52] * luqui tries to find a wording for the reason

[11:52] <audreyt> theorbtwo: I think too that it's the more interesting question. however, that question is answered by the regular typechecker, so it may make sense for "want" to work the other way.

[11:52] <audreyt> i.e.

[11:53] <audreyt> use Want; if (want('BOOL')) { ... }

[11:53] <luqui> surely if you asked "am I in Numeric context" then an Int context should say that you are

[11:53] <audreyt> the ... probably should not be run when the caller is expecting Any.

[11:53] <luqui> Well, I think "if want" is a dubious construct anyway

[11:53] <luqui> want is more of an MMD concept

[11:53] <audreyt> (the purpose of "want" is to reverse the variance.)

[11:53] <audreyt> luqui: that was P5.

[11:54] <audreyt> (Want.pm)

[11:54] * luqui knows

[11:54] <luqui> I've been saying "want switch", but I think thinking of it in terms of MMD will be more productive

[11:54] <luqui> and maybe "want" isn't a predicate but its own switch-like construct

[11:54] <luqui> because subtyping happens within it

[11:55] <luqui> and Java-like exception catching ordering deps suck

[11:55] <audreyt> $ ./pugs -e 'say "\d[65,66,67,]"'

[11:55] <audreyt> ABC

[11:55] <luqui> but anyway, if we go with theorbtwo and say that "will it fit" is the more interesting question

[11:55] <theorbtwo> It seems to me like the simplest thing to do is to make want just return the context, and you can put it on whichever side of ~~ you want.

[11:56] <luqui> theorbtwo, *we*'re having trouble thinking about which way is right

[11:56] <audreyt> theorbtwo: actually, S06 agrees with you.

[11:56] <audreyt> theorbtwo: though the default "given want" places it at LHS of ~~

[11:56] <luqui> so want Num returns false in Int context?

[11:56] <audreyt> given want { when Num { ... } }

[11:56] <audreyt> and want is Int

[11:56] <audreyt> hurray, passes.

[11:57] <audreyt> because Int~~Num is true.

[11:57] <audreyt> it's all very consistent.

[11:57] <svnbot6> r8724 | audreyt++ | * implemented \x[1,2,3,].

[11:57] <luqui> yes, but confusing

[11:57] <audreyt> not to me, but well. :)

[11:57] <luqui> "do you want a Num" is an ambiguous question

[11:57] <luqui> so a function that answers it is not going to DWIM all the time

[11:58] <luqui> and unless you understand the distinction between "want ~~ Foo" and "want Foo" (which I argue is hard to grasp)

[11:58] <luqui> then something bad (I couldn't think of a way to end that conditional ;-)

[11:59] <audreyt> note that according to S06, want is nullary.

[11:59] <audreyt> i'd like to keep it that way. :)

[11:59] <luqui> really?

[11:59] <audreyt> yes.

[11:59] <luqui> oh, weird

[11:59] <luqui> I mean good

[11:59] <luqui> then it's not answering an ambiguous question anymore

[11:59] * theorbtwo grins.

[11:59] <audreyt> ;)

[12:00] <luqui> but you still have to grok "want ~~ Foo" and "Foo ~~ want"

[12:00] <audreyt> which is fine

[12:00] <audreyt> because people using wantarray should know what they are doing even in p5

[12:00] <luqui> except my mind gets tangled around it really easily unless i step back and think really slowly and clearly

[12:00] <luqui> because its sortof contravariant but sortof not

[12:01] <luqui> audreyt, okay I buy the "know what they are doing" argument...

[12:01] <luqui> however! there is still the problem of return-type MMD

[12:02] <luqui> which one does it use?

[12:02] <audreyt> myFunction :: forall a. IsContext a => SomeParamType -> a

[12:02] <audreyt> myFunction = let want = typeOf (undefined :: a) in ...

[12:02] <audreyt> is my model implemented in hs

[12:02] <luqui> huh, hs does not match perl in that respect though

[12:02] <audreyt> you can case over "want" just as easily.

[12:03] <audreyt> how so?

[12:03] <luqui> there is no return-type subtyping in hs

[12:03] <luqui> i.e.  foo :: SomeClass a => a

[12:03] <luqui> means that I can return *any* a

[12:03] <audreyt> actually it does

[12:03] <luqui> no matter what type you want, I can give you it, as long as it is a SomeClass

[12:04] <audreyt> no, that's not what it means

[12:04] <audreyt> er wait

[12:04] <luqui> maybe I'm thinking foggily, missing a level of indirection or something

[12:04] <audreyt> your sentence can be read bothways :)

[12:04] <audreyt> so, replace IsContext with Typeable

[12:04] <luqui> forget the "I can return *any* a"

[12:04] <audreyt> (which is pretty much a given for any type)

[12:04] <audreyt> myFunction :: a

[12:04] <luqui> foo :: Typeable a => a;  foo = 42

[12:04] <luqui> error!

[12:05] <audreyt> oh, you mean Int is subtype to Typeable

[12:05] <audreyt> I see your argument

[12:05] <audreyt> I don't agree though :)

[12:06] <luqui> basically, with subtyping, the context is telling you something different than in haskell

[12:06] <luqui> haskell's context says "give me a Foo", and the well-typedness of your function guarantees that you can return a Foo

[12:07] <luqui> but in Perl, in Int context, you should be okay returning a Num, no?

[12:07] <luqui> (hmm, that last one is arguable)

[12:07] <luqui> let's see, how can I put this

[12:07] <theorbtwo> You should be OK with anything that does Int.

[12:07] <luqui> ahh, if you're switching between Scalar and List context

[12:07] <theorbtwo> I think you're thinking of the wrong higherchy entirely...

[12:07] <audreyt> luqui: wait, Haskell also has subtyping

[12:07] <luqui> surely an Int context should choose the Scalar switch, not throw an error

[12:08] <luqui> audreyt, not on return types...

[12:08] <luqui> it's only contravariance that supports subtyping

[12:08] <luqui> I'm talking about haskell 98, not ghc

[12:08] <audreyt> I'm talking about h98 too

[12:08] <luqui> explain

[12:08] <brianski> y'all sound like you must have paid attention in your compiler classes.

[12:08] <brianski> simple question - what's the approx. ETA for perl6?

[12:09] <audreyt> luqui: type Circle w = Shape (CircleDelta w)

[12:09] <audreyt> brianski: define perl6

[12:09] <luqui> brianski, the official position is that there is no official position

[12:09] <brianski> audreyt - uh. perl 6.0 ?

[12:09] <audreyt> luqui: data Shape w = MkShape {...}

[12:09] <audreyt> luqui: Circle w is subtype of Shape w. agree?

[12:09] <brianski> luqui - so it's done when it's done kind of thing, yes?

[12:09] * theorbtwo wonders if he's an element of y'all.

[12:09] <luqui> brianski, yes, mostly because it is open source

[12:10] <luqui> audreyt, I don't quite follow

[12:10] <luqui> give me a minute to look that over

[12:10] <brianski> well, plenty of open source projects have release schedules (altho i certainly don't claim that's a good thing) - was just wondering if there was a feeling for how long, within a factor of 10. 2 weeks? 2 months? 2 years? 2 decades?

[12:11] <audreyt> luqui: Maybe (Maybe a) is a subtype to Maybe a

[12:11] <luqui> brianski, not the first one

[12:11] <luqui> :-)

[12:11] <luqui> audreyt, ahh, compatible

[12:11] <brianski> heh, ok

[12:11] <audreyt> brianski: http://www.perlmonks.org/?node_id=485426

[12:11] <audreyt> brianski: in particular http://www.perlmonks.org/?node_id=489243

[12:11] <luqui> audreyt, okay, that's compile-time subtyping

[12:11] <luqui> hmm, that's not the right axis to make the distinction

[12:12] <audreyt> luqui: and with Typeable, you can turn it into runtime reified stuff

[12:12] <audreyt> luqui: by applying a typeOf

[12:12] <audreyt> to the runtime expected monomorphic return type

[12:12] <audreyt> it's all still h98.

[12:12] <audreyt> luqui: I argue it is exactly isomorphic :)

[12:12] <luqui> audreyt, write a function that declares that it will return a Num, and currently returns an Int, but can be changed later without changing the sig

[12:13] <brianski> audreyt - thx

[12:13] <luqui> that's pretty much the prototypical example of subtyping, is it not?

[12:13] <luqui> use whatever polymorphic typeclassish sig you like

[12:14] <audreyt> luqui: except the "can be changed later" bit

[12:14] <audreyt> luqui: write that in p6 first and I'll translate.

[12:14] <luqui> sub foo (--> Num) { 42 }

[12:14] <audreyt> and "later"?

[12:14] <luqui> sub foo (--> Num) { 42.5 }

[12:14] <luqui> it's important that the former returned something of different type than the latter

[12:15] <luqui> but both are subtypes of Num

[12:16] <audreyt> (sec)

[12:16] * luqui tries to trace back why this is being argued... he's apparently kind of out-of-it

[12:17] <luqui> ahh, right, dealing with contexts with subtyping

[12:18] <luqui> ambiguity of "want" asking and whatnot, choose Scalar when in Int context

[12:18] *** Whiz joined
[12:22] <leo_> audreyt: parrot r11221, please check the last 6 tests in t/op/lexicals.t if you find some time

[12:22] * audreyt handles dinner a bit -- be back in ~5min

[12:22] <audreyt> leo_: cool

[12:24] <audreyt> luqui: oh btw

[12:24] <audreyt> data IsNum = forall a. Num a => MkNum a

[12:24] <audreyt> f :: IsNum

[12:24] <audreyt> f = MkNum (1 :: Int)

[12:24] <luqui> audreyt, oops, you're not in haskell 98 anymore

[12:24] <audreyt> g :: IsNum

[12:24] <audreyt> g = MkNum (1.5 :: Float)

[12:25] <audreyt> heh

[12:25] <audreyt> it's simple to encode to h98

[12:26] <luqui> it is?

[12:26] <audreyt> yeah, if you are oleg

[12:26] <luqui> heh

[12:26] <audreyt> (who had encoded GADTs to h98)

[12:26] <wolverian> maths lectures are so slow :(

[12:26] <luqui> I'm not sure how...

[12:26] <luqui> wolverian, you need to get a better maths lecturer

[12:27] <audreyt> class Term g where

[12:27] <wolverian> perhaps. it's just logic 1 though, I don't know if you can make this not slow :)

[12:27] <audreyt>     lit     :: F f Int int => Int -> g f int

[12:27] * luqui also finds that to make maths lectures interesting, you can be a smartass like him and have a conversation with the teacher while correcting him

[12:27] <audreyt> etc (standard church encoding iirc)

[12:27] <audreyt> luqui: but we can drop this silly h98 thing and back to your point please

[12:28] <luqui> basically, should Int context choose the Scalar branch of a context switch?

[12:28] <luqui> or should it be an error?

[12:28] <audreyt> my position is that there is no Int context; there is only Item[Int] context

[12:29] <audreyt> and Item[Int] can override ~~ so it ~~Int

[12:29] <luqui> okay: should Int context choose the Item[Num] branch of a context switch?

[12:29] <audreyt> but doesn't mean that it .sa Int.

[12:29] <audreyt> there is, again, no Int contxt.

[12:29] <audreyt> there is only an Item[Int] context ;)

[12:29] <luqui> right

[12:29] <luqui> do that sub and answer then :-)

[12:30] <luqui> suppose we are choosing between Num and Str

[12:30] <luqui> should Item[Int] give an error?

[12:30] <audreyt> (again, Item[Num] and Item[Str])

[12:30] * luqui is abbreviating

[12:30] <audreyt> Item[Num] ~~ Num is true

[12:30] <audreyt> but not because of subtyping

[12:30] <audreyt> because MMD on ~~

[12:30] <luqui> the "smart" part of "smart match"

[12:30] <audreyt> Item[Num].isa(Num) is probably false.

[12:30] <audreyt> yes.

[12:31] <luqui> do whatever transformations you will, the problem is still there

[12:31] <luqui> given want { when Num { thing1 }  when Str { thing2 } }

[12:31] <luqui> s/want/Item[Int]/

[12:31] <audreyt> then you enter thing1 branch

[12:32] <audreyt> happily

[12:32] <luqui> okay, and:  given Item[Num] { when Int { thing1 } when Str { thing2 } }

[12:32] <audreyt> you fall off without doing anything.

[12:32] <luqui> so clearly that's not the MMD way

[12:33] <audreyt> why is it not?

[12:33] <luqui> multi foo(--> Int) { 42 }  multi foo(--> Str) { "hello" }

[12:33] <luqui> surely a Num context should choose foo()

[12:33] <audreyt> you mean MMD does "when (Int ~~ $_)"

[12:33] <audreyt> given want { when (Int ~~ $_) { ... } }

[12:33] <luqui> aye

[12:33] <audreyt> sure

[12:34] <audreyt> then have MMD do that

[12:34] <audreyt> I still don't see a  problem

[12:34] <luqui> and:  multi foo(--> Num) { 42 }   multi foo(--> Str) { "hello" }

[12:34] <luqui> that should croak on Int context?

[12:34] <luqui> even though there is the possibility that 42 will be an Int?

[12:34] *** Whiz left
[12:34] <audreyt> I'd definitely argue that.

[12:34] <luqui> (*this* was the thing about context being a type)

[12:34] <audreyt> because --> carries a static monotype promise

[12:35] <audreyt> and we honour that at compile time

[12:35] <audreyt> I think, anyway.

[12:35] <audreyt> (you can always coerce.)

[12:35] <luqui> and so you can't use MMD to switch between numeric and String

[12:35] <luqui> that's outside of MMD's capability

[12:36] * luqui thinks about what the proto would be for foo

[12:36] <audreyt> you can switch between a floating number and a string.

[12:36] <luqui> it would have to return bottom...

[12:36] <audreyt> yup

[12:37] <luqui> audreyt, you can't use MMD to choose between scalar and list?

[12:37] <audreyt> luqui: they are monotypes :)

[12:38] * luqui doesn't follow

[12:38] <luqui> yes, you can't be both at once by definition

[12:38] <luqui> but how does that help you switch between them?

[12:38] <audreyt> multi foo (--> Single[Any]) {...}; multi foo (--> Plural[Any]) { ... };

[12:39] <luqui> and Single[Any] ~~ Num is true?

[12:39] <audreyt> the Any (bottom) here works bothways

[12:39] <audreyt> Single[Any] ~~ Single[Num] is true

[12:39] <audreyt> so is Single[Num] ~~ Single[Any]

[12:39] <audreyt> hm, that becomes undecidable.

[12:39] *** iblechbot joined
[12:40] <audreyt> though still may be okay.

[12:40] * luqui saw the temptation to look for A <: B or B <: A, and his maxwellian beauty razor cut it off

[12:40] <luqui> but that's really all I'm going on right now.  But I feel like I could come up with a logical reason that's not okay

[12:41] <audreyt> then please do

[12:41] <luqui> (we could coin this "fuzzy argumentation" akin to "fuzzy logic")

[12:41] <audreyt> I'd still like to code it up ;)

[12:41] * audreyt thinks English is a terrible implementation language

[12:41] * luqui retreats into his lair to finish the GJ paper and come up with said example

[12:42] <luqui> oh--audreyt--one last thing... is Single[Any] a type?

[12:42] * audreyt meanwhile fixed even more tests.

[12:43] <audreyt> luqui: it is

[12:43] <luqui> so it seems like you've sidestepped the problem into the very same problem

[12:43] <luqui> strip the Single and you get right back to my flawed scheme

[12:43] <svnbot6> r8725 | audreyt++ | * TODOize and correct some more tests.

[12:44] * luqui & for a little while

[12:44] <audreyt> luqui: not sure what you mean; why should I strip away the Single?

[12:44] <audreyt> luqui: to strip it away is saying "replace 'class' with 'data' in your code"

[12:45] <audreyt> (my proposal is built on separate treatment of parameterized role types)

[12:45] <audreyt> which is part of S12 already

[12:45] <luqui> you really think it's a good idea for ~~ to mean subtype with certain types, but not with all types?

[12:46] <audreyt> luqui: it's already specified as such

[12:46] <luqui> example?

[12:46] <audreyt> it dispatches to .does() and .isa() based on RHS

[12:46] <audreyt> and doesn't do .isa when LHS is a role

[12:47] <audreyt> and .does/.isa means different things

[12:47] <luqui> that's such a cop-out! :-)

[12:47] <luqui> they both mean subtype, that's for sure

[12:47] <audreyt> it's part of the spec ;)

[12:47] <audreyt> they mean it differently though.

[12:48] <luqui> audreyt, so disregarding the spec, do you think it's a good idea?

[12:48] <audreyt> Maybe (Maybe a) is subtype of (Maybe a); Ord is subtype of Eq.

[12:48] <luqui> i mean for ~~ not to mean subtype when both of its arguments are types?

[12:48] <audreyt> luqui: I think it's a good idea.

[12:49] <audreyt> or at least, sensible.

[12:49] <luqui> hmmm... okay, well, I need to come up with some more concrete and shocking examples then

[12:49] <audreyt> it'd mean "compatible type"

[12:49] <audreyt> go ahead :)

[12:49] <luqui> my maxwellian arguments aren't working :-)

[12:49] <luqui> audreyt, how much longer are you going to be here?

[12:49] <audreyt> luqui: for another ~3hr?

[12:50] * luqui isn't usually up at 6am

[12:50] <audreyt> I'd like to get all tests triaged

[12:50] <luqui> okay, so I can leave

[12:50] <audreyt> which I've been massively distracted from :)

[12:50] <audreyt> g'nite

[12:50] <luqui> not g'nite

[12:50] <luqui> g'reading and coming back in an hour or so

[12:50] <luqui> I'm distracting myself

[12:50] <luqui> (and you)

[12:50] *** BigBear joined
[12:50] <luqui> adios

[12:56] <audreyt> hm

[12:56] <audreyt> pugs currently does

[12:56] <audreyt> pugs foo.p6 --help

[12:56] <audreyt> # shows pugs --help

[12:56] <audreyt> pugs foo.p6 -- --help

[12:56] <audreyt> # passes --help to foo.p6

[12:56] <audreyt> that seems counterintuitive.

[12:57] <audreyt> does anyone think the current behaviour is desirable?

[12:58] <gaal> rehi

[12:59] <masak> audreyt: well, it seems that after the -- argument, pugs ought to treat everything as files

[12:59] <masak> including --help, imho

[12:59] <audreyt> masak: say... what?

[12:59] <audreyt> you mean as @ARGS, right?

[13:00] <masak> audreyt: maybe i don't understand the problem correctly

[13:00] <masak> "--" means "treat things as input files, even though they may look like options", right?

[13:01] <masak> so, i read "pugs foo.p6 -- --help" as "run foo.p6 on pugs, passing the input file '--help' to it (foo.p6)"

[13:02] <audreyt> yes.

[13:02] <masak> so, I guess I mean as @ARGS, yes :)

[13:02] <audreyt> the problem case is

[13:02] <audreyt> pugs foo.p6 --help

[13:02] <audreyt> currently it runs asif you have typed "pugs --help"

[13:03] <audreyt> I think that behaviour should go away

[13:03] <masak> yeah. seems like you would only want to do either one at a time

[13:03] <audreyt> indeed

[13:04] <audreyt> but

[13:04] <audreyt> pugs -e "foo" --help

[13:04] <audreyt> shows help

[13:04] <audreyt> which I have no problem with

[13:04] <audreyt> does that sound sane?

[13:04] *** DaGo joined
[13:04] <masak> audreyt: it does

[13:05] <audreyt> good then

[13:05] * audreyt commiteth

[13:05] *** DaGo joined
[13:06] <audreyt> opera++ # multiline tooltips for the title="" attr

[13:07] <audreyt> perfect for viewing smoke.html

[13:07] * audreyt mumbles something about firefox and its 5-years-unfixed-bug of tooltip truncation

[13:07] <masak> :)

[13:07] * masak goes studying cell biology

[13:10] <wolverian> audreyt, that's one of the reasons I migrated to epiphany, too.

[13:10] <wolverian> too bad it only runs on gnome (afaik)

[13:10] <svnbot6> r8726 | audreyt++ | * Pugs.Run.Args: When the arg list parser encounters the script

[13:10] <svnbot6> r8726 | audreyt++ |   file name, treat everything after it (even -options) as arguments.

[13:10] <svnbot6> r8726 | audreyt++ |   So these two forms are now identical:

[13:10] <svnbot6> r8726 | audreyt++ |     pugs foo.p6 --help

[13:10] <svnbot6> r8726 | audreyt++ |     pugs foo.p6 -- --help

[13:10] <svnbot6> r8726 | audreyt++ |   (t/pugsrun/12-script-args.t now passes because of this.)

[13:10] <wolverian> s,on gnome,on a system with gnome,

[13:12] <audreyt> epiphany does multiline tooltips!?

[13:12] <audreyt> I thought it's gecko?

[13:13] * audreyt goes installing epiphany

[13:15] <audreyt> $ perl -e 'print 1+' -e '2' -l

[13:15] <audreyt> 3

[13:15] <wolverian> audreyt, yes, it's gecko. yes, it does multiline tooltips

[13:15] <audreyt> hm, surprising.

[13:15] <wolverian> (at least on my system)

[13:15] * audreyt goes emulating that behaviour

[13:17] *** scw_ is now known as scw

[13:17] <masak> audreyt: pugs seems to already do that

[13:17] <masak> pugs -e 'say 1+' -e '2'

[13:17] <masak> 3

[13:18] *** luqui joined
[13:18] <luqui> audreyt, the vObj paper is pretty much exactly what I had in mind

[13:19] <luqui> heh, "pretty much exactly"

[13:25] <audreyt> wolverian++ # epiphany does work

[13:25] <audreyt> masak: yes, I used a bad example

[13:25] <audreyt> $ perl -e 'print 1+' -l -e '2'

[13:25] <audreyt> is what I'm doing

[13:25] <audreyt> already done, about to commit

[13:25] *** kolibrie joined
[13:26] <audreyt> luqui: good.

[13:26] <audreyt> luqui: because my plan is to use vObj encoding as the base of 6.2818 calculus

[13:26] <luqui> really?  I'd better look at the calculus more closely then...

[13:27] <luqui> how do we handle its undecidability?

[13:27] <audreyt> we don't.

[13:27] <luqui> so... how do we handle it?

[13:27] <luqui> :-)

[13:27] <audreyt> currently I'm investigating more closely on two-level lambda cube (with partial eval) and vObj

[13:28] <luqui> ?

[13:28] <audreyt> luqui: if it's not decidable, the user has to supply enough info to tiebreak, otherwise it's compile time error

[13:28] <luqui> undecidable doesn't mean uninferrable IIRC

[13:29] <luqui> undecidable means uncheckable. no?

[13:29] <audreyt> well, "cannot be checked with confidence"

[13:29] <luqui> so what kind of info could the user possibly provide?

[13:30] <audreyt> the user would have to either say, "this part can raise dynamic type error" (which would be the default)

[13:30] <audreyt> or supply type annotations that does not lead to undecidable types

[13:30] <luqui> hm.

[13:31] <wolverian> hm, I want an editor that shows "This expression's type is undecidable" 

[13:31] <luqui> wolverian, have you ever, er, heard of the halting problem? :-)

[13:31] <audreyt> there are heuristics ;)

[13:31] <luqui> true, true

[13:31] <audreyt> so an editor that shows that for many types is fine

[13:32] <wolverian> I was assuming Eclipse would have solved the halting problem by now ..

[13:32] <audreyt> an editor that can show that for all undecidable types is not fine :)

[13:32] <audreyt> wolverian: well, you mean it always crashes (halts)?

[13:32] <wolverian> heh.

[13:32] <audreyt> my experience with Eclipse shows it's a bit more reliable than that :)

[13:32] <wolverian> (it doesn't, weird enough)

[13:33] <luqui> well, audreyt, keep me posted.  (might be a bit difficult as I start school today)

[13:33] <audreyt> luqui: sure :)

[13:33] <audreyt> luqui: but it's all just background thinking

[13:33] <audreyt> not until we get obj and rules done

[13:33] <audreyt> and deliver a fine dynamic language first

[13:33] <luqui> I'll come up with a perly vObjish encoding.

[13:33] <audreyt> _then_ we can go back to visit the staticness :)

[13:34] <audreyt> luqui: cool

[13:34] <audreyt> until 6.2813.0, I expect type errors to be raised at runtime, at a performance penalty

[13:35] <audreyt> i.e. totally punishing people using types.

[13:35] <luqui> in terms of runspeed

[13:35] <luqui> not necessarily punishing "totally"

[13:35] <luqui> some people who have recently started to love haskell think that types help developer speed

[13:36] <luqui> *cough*

[13:36] <audreyt> without static typechecking... I think it's a bit contentious

[13:36] <audreyt> but we'll see :)

[13:36] <luqui> it's a cognitive thing, too

[13:36] <luqui> "how do I use that function again?"

[13:36] <luqui> hooglish documentation

[13:37] <audreyt> qq.foo bar 1.

[13:37] *** pmccann joined
[13:37] <audreyt> luqui: how does it parse?

[13:37] <luqui> audreyt, what's the problem with it?

[13:37] <audreyt> or, rather

[13:37] <audreyt> qq.foo:1.

[13:37] <audreyt> which shows the problem a bit more clearly

[13:38] <audreyt> luqui: "qq.foo" can mean an invocation

[13:38] <luqui> oh.

[13:38] <luqui> it definitely parses as a quoter

[13:38] <audreyt> ok

[13:38] <scook0> longest-token and all...

[13:38] <luqui> not really longest-token.  more like keyword.

[13:39] <luqui> pretty much the same question as:  if(foo)  # function call or if statement?

[13:39] * audreyt adjusts the precedence table

[13:39] <wolverian> isn't if a function? :)

[13:39] *** rantanplan_ joined
[13:39] <luqui> (barring the fact that they're the same in perl 6)

[13:39] *** iblechbot joined
[13:39] <luqui> wolverian, but they're not entirely the same, so the question is valid

[13:39] <wolverian> true enough

[13:40] <luqui> if is not a function; its implementation is a function

[13:40] <luqui> if is a statement:<if>

[13:40] <wolverian> hmm, should we have 'statement if { ... }' instead of 'sub statement:<if> { ... }'? 

[13:40] <luqui> wolverian, probably not

[13:41] *** fxn joined
[13:41] <scook0> statement:<if> is consistent with the rest of the op:<foo> names

[13:41] <wolverian> probably. 

[13:41] <scook0> defining your own statement forms is probably "people who know what they're doing" territory

[13:41] <luqui> though by that logic:

[13:41] <luqui> sub macro:<foo> { }

[13:42] <luqui> it *does* affect parsing, after all

[13:42] <audreyt> wait

[13:42] <audreyt> macro postfix:<!> {...}

[13:42] <audreyt> how do you do that then

[13:42] <luqui> aa soo

[13:42] <luqui> looking down the wrong axis

[13:42] <luqui> looks like they are orthogonal from that perspective

[13:42] <wolverian> yeah. infix statement? :)

[13:43] <audreyt> wolverian: "infix" statement sounds like an oxymoron

[13:43] <luqui> though an infix statement is not entirely out...

[13:43] <wolverian> it was a joke. 

[13:43] <luqui> statement infix:<+> {...}    (3+4) * 5   # illegal: must be 3+4;

[13:43] <luqui> still, that's getting pretty esoteric

[13:44] <wolverian> luqui++ # weirdness factor

[13:45] * luqui can get karma for weirdness?!

[13:45] <luqui> I'm in heaven!

[13:45] <audreyt> luqui++ # may I pay you in karma to stop thinking along this line further?

[13:45] <luqui> haha

[13:46] <scook0> audreyt: don't; that'll just encourage him to do it again later :)

[13:46] <luqui> he can always steal from me if I try to do it again

[13:47] <luqui> s/he/she/

[13:48] <luqui> sorry.  I'm not programmed to switch genders after I know people.  Somehow that wasn't evolutionarily necessary until this century :-/

[13:49] <gaal> oy. we can't rebind subs after the'd been exported, since we export values?

[13:49] <svnbot6> r8727 | scook0++ | * Beginnings of docs/getting_started; inspired by the lack of any

[13:49] <svnbot6> r8727 | scook0++ | document to point newbies at.  It's mostly just a skeleton at the

[13:49] <svnbot6> r8727 | scook0++ | moment, so feel free to help.

[13:49] <gaal> huh? wait no, Test::Pil isn't even exporting anything. it's a mixin

[13:50] <audreyt> luqui: I think it'd be easier after we meet again in realspace :)

[13:50] * luqui thinks so too

[13:55] <svnbot6> r8728 | audreyt++ | * qq.method:1.  # always parses as quoter, never method

[13:55] *** integral joined
[13:57] <gaal> uh, santiy check:

[13:57] <svnbot6> r8729 | audreyt++ | * t/pugsrun/01-multiple-e.t now happily passes.

[13:57] <gaal> &somesub := {;};

[13:57] <gaal> should turn a sub that's already declared to a nop, at runtime

[13:57] <gaal> right?

[13:57] <luqui> what do you mean by "already declared"?

[13:58] <gaal> luqui: I mean there was already a sub somesub {}

[13:58] <gaal> already defined, sorry

[13:58] <audreyt> sub foo { ... }; &foo := {...};

[13:58] <luqui> gaal, oh, right.

[13:58] <luqui> I read "turn" as "return"

[13:58] <audreyt> gaal: the answer is yes, surely

[13:58] <gaal> yes. except it doesn't look like it works :(

[13:58] <audreyt> $ ./pugs -e 'sub x { 3 }; &x := {4}; say x()'

[13:58] <audreyt> 4

[13:59] <pasteling> "gaal" at 192.115.25.249 pasted "put this in your Test/lib/Test/Pil.pm - *** No such sub: "&pil_is_eq" at runtime" (55 lines, 1.3K) at http://sial.org/pbot/15479

[14:00] *** Southen joined
[14:01] <gaal> ""; was me making sure this wasn't being parsed as an anonyhash

[14:01] <gaal> though {;} oughta be enough

[14:03] <svnbot6> r8730 | scook0++ | * Some meat for docs/getting_started

[14:03] <audreyt> gaal: sorry, I'm still in scope.t -- will look in a bit

[14:04] <gaal> no worries, are you going up or down the smokes?

[14:04] <audreyt> going up

[14:05] <gaal> the oreder of smokes on the smokeserver is confusing

[14:05] <gaal> k, i'll go down

[14:05] <audreyt> woot

[14:09] <audreyt> hm, lexical export really uncovered much assumptions.

[14:11] <gaal> why are some Prims defined as say List::foo instead of foo? this bites when you want them to work on a listref

[14:12] <gaal> what do I stand to break if I change that?

[14:14] <audreyt> hm, mmd should dispatch listrefs to them

[14:15] *** Limbic_Region joined
[14:15] <audreyt> examples?

[14:16] <gaal> ?eval my @x = [ 1 .. 5 ]; @x[0].elems

[14:16] <gaal> where's evalbot :(

[14:16] <audreyt> luqui: summon evalbot

[14:16] <luqui> he's broken because of lexical export

[14:16] <audreyt> gaal: that... shouldn't work

[14:16] <luqui> I tried to fix him for about an hour one day and was unsuccessful

[14:17] <luqui> audreyt, yes it should

[14:17] <gaal> audreyt: sorry sorry

[14:17] <luqui> rephrasing:  my @x = ([1..5]);  @x[0].elems

[14:17] <gaal> @x.push [1..5]

[14:17] <gaal> that breaks too

[14:17] <audreyt> oh, duh, sorry, I parsed :=

[14:17] <audreyt> gaal: indeed. lift them off List?

[14:17] <gaal> sure

[14:17] <audreyt> (and smoke to see what breaks, and we can see why)

[14:18] <gaal> OK

[14:18] * audreyt wonders why := is more natural than = at this point

[14:18] <gaal> heh

[14:18] <audreyt> to my brain that is

[14:19] <gaal> \\n   Int       pre     List::elems   safe   (Array)\

[14:19] <gaal> so will it have to be both straight elems and Any?

[14:19] <gaal> fwiw, reverse has both List and rw!Any

[14:20] <audreyt> elems and List, I think.

[14:20] <audreyt> hm, wait

[14:20] <audreyt> that'd make elems(1,2,3) work

[14:20] <audreyt> try elems and Array

[14:20] <audreyt> it should work

[14:20] <gaal> where's the mmdispatcher implemented btw? I was looking for it a few days back

[14:21] <luqui> findsub

[14:21] <gaal> luqui: thanks

[14:21] *** sahadev joined
[14:22] * luqui has all too much experience with that horridly ugly and complicated function

[14:23] <audreyt> thankfully it's going to die.

[14:23] <audreyt> luqui: it was quite simple... the current shape is due to blindly following S02~06 changes without refactoring ;)

[14:23] <gaal> woot! just changing the signature of the prim fixed the function :)

[14:24] <gaal> *the test

[14:24] <gaal> but this makes me wonder if all the List::* etc. prims oughtn't get the same treatment?

[14:24] <audreyt> probably should

[14:24] <audreyt> go ahead

[14:25] <gaal> oh, but arrays/elems.t broke now. looking.

[14:26] <gaal> yeah, now .elems "works" on arbitrary scalars

[14:26] <gaal> (whoever wrote that defensive test)++

[14:28] <gaal> looks like a dispatcher issue, not the prim's fault really

[14:28] <gaal> unless the signature should be elems   safe   (List)\ and not Array?

[14:28] <gaal> trying.

[14:30] <gaal> no, with List it breaks .elems totally :(

[14:30] *** fabpot joined
[14:31] <audreyt> nod.

[14:31] *** fabpot left
[14:31] *** Debolaz joined
[14:35] <gaal> okay, but weighing List::elems against elems, the latter is better because it fixes a crash in legitimate usage, even if it does permit incorrect usage.

[14:35] <svnbot6> r8731 | audreyt++ | * Pugs.Parser: parse (but no implementation) for scoped packages.

[14:35] <gaal> imho.

[14:35] <audreyt> sure.

[14:35] <audreyt> go ahead :)

[14:35] <rafl> clkao: ping

[14:36] <audreyt> whew, scope.t finally done

[14:36] <svnbot6> r8732 | audreyt++ | * Prelude: trivial error message fix.

[14:36] <svnbot6> r8733 | audreyt++ | * Fix t/packages/scope.t to work with lexical imports.

[14:37] *** chris2 joined
[14:39] <svnbot6> r8734 | gaal++ | * .elems: work correcly on listrefs, making t/builtins/arrays/push.t pass

[14:39] <svnbot6> r8734 | gaal++ |   (at the cost of breaking two tests in arrays/elems.t)

[14:44] <gaal> weren't there fixes to NaN? it still fails two tests

[14:44] <svnbot6> r8735 | gaal++ | * make splice.t not crash (passes all tests but one)

[14:44] <audreyt> gaal: which two?

[14:45] <audreyt> (brb, shower)

[14:45] <gaal> 0**0 and Inf**0

[14:45] <theorbtwo> What, you don't take your laptop into the shower with you anymore?

[14:45] <audreyt> both should be 1?

[14:45] <gaal> oh, the 0**0 expected is wrong

[14:45] <audreyt> theorbtwo: no, I actually have a life now

[14:46] <theorbtwo> Wow!

[14:46] <gaal> I don't know what Inf**0 should be, NaN sounds right

[14:46] <gaal> as for what they give in fact, both give 1.

[14:46] <audreyt> I even went to see two movies, "Memoir of a Geisha" and "The Last Trappper", during this whole relenging week ;)

[14:46] <obra> audreyt: how were they?

[14:47] <audreyt> obra: the first one is quite nice. the second one pales in comparison with eg. "The Whale Rider"

[14:47] <audreyt> but is okay if you are into northern landscape and northern lights, I guess

[14:47] <obra> nod

[14:47] <gaal> luqui, as the resident math moose. what should Inf**0 evaluate to?

[14:48] <audreyt> 0**0, Inf**0, 1**Inf

[14:48] <audreyt> are the three indeterminate frms

[14:48] <audreyt> involving **

[14:49] <audreyt> (the others were 0/0, 0*Inf, Inf/Inf, Inf-Inf)

[14:49] <gaal> oh, darn

[14:49] <gaal> mathworld says that yes

[14:49] <gaal> but wikipedia disagrees

[14:49] <audreyt> one way is to rule them all as NaNs; one way is relying on the underlying stuff

[14:49] <audreyt> s/stuff/C library/

[14:49] <audreyt> one way is to spec them.

[14:49] <gaal> wikipedia asserts that 0**0 _as a value_ should be 1.

[14:50] <gaal> citing e.g. Knuth

[14:50] <audreyt> 1**Inf is 1, 0**0 is 1, Inf**0 is 1?

[14:50] <theorbtwo> I think relying on the libc's interp. is the /worst/ way to go.

[14:50] <gaal> no idea about all the others.

[14:50] <gaal> theorbtwo: I agree, if the alternatives aren't crazy expensive.

[14:51] <audreyt> but we throw exception on 0/0

[14:51] <audreyt> instead of returning NaN

[14:51] <theorbtwo> I think my preference is to make them all NaN and punt to p6l.

[14:51] <audreyt> which is itself inconsistent.

[14:51] <audreyt> NaN for all seven forms?

[14:51] <theorbtwo> Yes.

[14:52] *** crypt_ex joined
[14:52] <gaal> :todo<mathupyourmind>

[14:52] *** crypt_ex left
[14:52] *** crypt_ex joined
[14:53] *** nothingmuch joined
[14:53] <theorbtwo> Hm, that leaves us with exception on 1/0 and NaN on 0/0, which isn't very consistant either.

[14:54] <theorbtwo> OTOH, NaN on 1/0 would just be plain annoying.

[14:54] <Limbic_Region> the exception makes more sense to me than NaN

[14:54] <Limbic_Region> across the board

[14:54] <Limbic_Region> I can then trap it and do something sane

[14:54] <gaal> no way we'll get agreement on this, guys. people from different backgrounds will want different things

[14:55] <Limbic_Region> gaal - and how does throwing an exception not satisfy everyone?

[14:55] <theorbtwo> But can you?  I'd be really nice if an exception handler could decide what the value of the expression that died should be, but we don't have that.

[14:56] <gaal> Limbic_Region: see the wikipedia article

[14:56] <Limbic_Region> theorbtwo - huh?  The exception handler needs to be user defined not omnicient

[14:56] <Limbic_Region> gaal - basically what I am saying is that in those cases we do not define the behavior but punt and let the individual coding decide

[14:57] <gaal> Limbic_Region: and that is going to annoy math folks that run into 0**0 a lot and want it to just evaluate to 1 like they expect.

[14:58] *** vel__ joined
[14:58] <theorbtwo> Say the user wished that 0**0 was just 1, without having to put trys all over the place.

[14:58] <gaal> a pragma is the best way to expose this in terms of the user, if it can be made inexpensive.

[14:58] <audreyt> 0/0 is nan in parrot

[14:58] <theorbtwo> How do you get that behavior?

[14:58] * audreyt ponders

[14:59] <gaal> t/builtins/my.t is another tough one...

[14:59] * Limbic_Region ponders as well

[14:59] <Limbic_Region> gaal - what would such a pragma look like?

[15:00] <Limbic_Region> use fringe_math '0/0' => 1;

[15:00] <theorbtwo> $*WIERDMATH{'0**0'} = 42; say 0**0

[15:00] <gaal> use Math::Indeterminate <NaN 1 fatal>.pick?

[15:00] <audreyt> multi *infix:</> (0, 0) { 1 }

[15:00] <audreyt> there you go

[15:00] <audreyt> ;)

[15:01] * theorbtwo thinks audreyt wins.

[15:01] <gaal> except you need to weave that in and out lexically

[15:01] <audreyt> you can do that with an lexical import

[15:01] <theorbtwo> OK, so make all the ind. forms die, and anybody who cares can override that as they see fit.

[15:02] <audreyt> I was thinking "make all the ind. forms use native implementation for speed"

[15:02] <audreyt> and anybody who cares can override

[15:02] <theorbtwo> Oh, that works too -- I was thinking it wouldn't be that much of a speed issue.

[15:03] <gaal> i would; there's some code involved on every entry to the op

[15:03] <gaal> s/i/it/

[15:04] <theorbtwo> Is multi dispatch >= O(N)?

[15:05] *** putter joined
[15:05] <audreyt> theorbtwo: not sure what you mean

[15:05] <gaal> the O isn't what hurts, I think.

[15:05] <gaal> people do arithmetic in tight loops.

[15:06] <gaal> the fact that you have to do runtime matching against args at all means expense

[15:06] <putter> use Math::IEEE_754_1985; ... use Math::IEEE_754_2007; ... etc (taxonomy of "etc" is non-obvious and interesting;)

[15:06] <gaal> yo putter 

[15:06] <putter> hi gaal

[15:06] <theorbtwo> Right, but we already do, so how much does adding more cases hurt?

[15:07] <theorbtwo> Or is it a matter of caring about the values whereas before we only cared about the types?

[15:08] <audreyt> yup

[15:08] <gaal> actually, I don't know enough of this that I should keep talking. But it seems to me that my @x of int; my @y of int; @x >>/<< @y should be able to generate fast code.

[15:08] *** eric256 joined
[15:08] <audreyt> if at compile time it can't be proven to be 0, then it desugars to a comparison

[15:08] <audreyt> which is costly

[15:10] <theorbtwo> OK, I grok.

[15:11] <theorbtwo> So default to whatever the machine feels like, allow the user to define a multi.  That @x >>/<< @y can be fast, if it can know the types of all elements of @x and @y in advance, then it can check when it begins to execute for the right multi, and pull that out, then do the division in a tight loop...

[15:11] <theorbtwo> ...unless there is a choice that it can't resolve with just knowing the types, in which case it has to choose between them on every division.

[15:11] <audreyt> yes.

[15:11] *** eric256 left
[15:12] <audreyt> though that means having 0/0 to not throw exception. hm.

[15:14] *** stevan_ is now known as stevan

[15:14] * audreyt decides to punt to p6l.

[15:14] * stevan thinks luqui should read AMOP and a good book on ML (the module system chapter in particular)

[15:15] *** Eimi joined
[15:15] <audreyt> gaal: span.t hangs here

[15:16] <gaal> here too. looking

[15:17] <gaal> no, it's just slow

[15:17] <gaal> passes 2 and crashes.

[15:17] <gaal> you mean ext/Span/t/span-code.t, yes?

[15:17] <gaal> oh span.t

[15:18] *** iblechbot_ joined
[15:19] <putter> if the compiler did partial evaluation, infix:</> multis could be specialized on their internal CALLER::<$indeterminacy_policy>...  ?

[15:20] <gaal> span's stringify hangs. skipping all these calls.

[15:20] <putter> re docs/,

[15:22] *** benpol joined
[15:25] <putter> as a complement to getting_started, it could be useful to have something at the opposite extreme - comments_for_CS_researchers.  In a CS context, I was trying to explain why p6 was *interesting*, but my grasp on its theoretical aspects was too fuzzy.

[15:25] <gaal> ugh, there are plenty of hangs in Span. 

[15:25] <gaal> stringify, clone, start... I think I'll skip_rest for now :/

[15:26] <gaal> audreyt: I wasn't even looking at ext/ yet, under the assumption that t/ takes precedence.

[15:26] <audreyt> k

[15:26] <audreyt> yup

[15:26] <putter> The "p6 closes onces at compile time, and again as necessary at runtime.  For comparison, ruby and python only close at runtime, and ... close only at compiletime."  is just the kind of thing that is easily understood and repeated once said, but rather harder to derive yourself.

[15:27] <audreyt> :)

[15:27] <svnbot6> r8736 | audreyt++ | * 1**Inf, 0**0 and Inf**0 is regularted to 1 in this release.

[15:27] <svnbot6> r8736 | audreyt++ |   Pending p6l.

[15:28] <robkinyon> audreyt: Those are good math rules. :-)

[15:28] <gaal> should .perl give newlines on e.g. %h.perl?

[15:28] <robkinyon> Do they work for -Inf as well?

[15:28] <audreyt> gaal: it's optional

[15:28] <putter> The "why is it *interesting*?" came up in a context of "why should I fund it?", and so is not "merely" of curiousity value. ;)

[15:28] <audreyt> robkinyon: yes.

[15:28] <robkinyon> cool

[15:28] <robkinyon> ?eval 0**Inf

[15:28] <audreyt> putter: "interesting"?

[15:29] <audreyt> evalbot is bitrotted by gaal

[15:29] <robkinyon> gah

[15:29] <audreyt> fixes welcome

[15:29] <gaal> lol

[15:29] <robkinyon> audreyt?eval 0**Inf

[15:29] <robkinyon> :-)

[15:29] <gaal> audreyt: newlines optional in .perl: what should the tests expect? what pugs gives now? :)

[15:30] <audreyt> gaal: yes.

[15:30] <audreyt> gaal: or normalize it... I don't quite care :)

[15:30] <gaal> k

[15:30] <audreyt> mm, SPJ proposed something that can dramatically speed up pugs.

[15:30] <audreyt> # http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/ticket/76

[15:31] <putter> audreyt: say you sat down with a copy of yourself, similar CS capabilities (perhaps not as yet identical reading lists), but who had never hear of perl or p6.  how would you describe p6?  what about it is not just "another been there and done that" language?  what is its "related work" connection to the rest of the field?

[15:32] <putter> I'd love to read a transcript of that conversation.

[15:32] * robkinyon signs up for a copy at the front desk

[15:32] <putter> What is interesting about the challenges it faces, or how it is facing them?

[15:33] <putter> :)

[15:33] <nothingmuch> hola robkinyon 

[15:33] <robkinyon> nothingmuch: :-)

[15:33] * nothingmuch wonders if he should keep working on keeping robkinyon in perl land

[15:33] <nothingmuch> it's pretty challenging

[15:33] <nothingmuch> i'm thinking of UNIVERSAL::RubyIntrospection

[15:34] <nothingmuch> and a Spiffy like filter for Catalyst ;-)

[15:34] *** hexmode joined
[15:34] <robkinyon> Actually, I'm very heavily in Perl-land

[15:34] <nothingmuch> and a filter that does 's/def/sub' ;-)

[15:34] <nothingmuch> your feature ideas have helped make some pretty cool catalyst plugins though

[15:34] <audreyt> putter: that makes a wonderful journal subject.

[15:34] <robkinyon> Not mine. :-)

[15:34] <audreyt> putter: I'll think about it.

[15:34] <nothingmuch> robkinyon: you are my gateway to the other side =)

[15:35] <gaal> the report is so terse! spj's proposal comes with a patch to it that's... tiny

[15:35] <robkinyon> You will come to the Dark Side, Luuuuke!

[15:35] <audreyt> gaal: I wish synopsis is like that ;)

[15:35] <nothingmuch> robkinyon: when I have time, yes

[15:36] <audreyt> though it took them 10+ years... why should p6 be different.

[15:36] <gaal> the synopses are hardly wordy! it's a huge language

[15:37] *** DaGo joined
[15:39] <putter> The most common one-liner mental model folks have of Haskell is "interesting difficult functional language I really should look at sometime".  For perl\d, it's "scripting-kind-of-language, said to be ugly".  The number of people on the planet who hearing Perl6, would think "type theory/system innovation", or even believe such

[15:39] <audreyt> putter: actually... I did think about it when I wrote my cufp paper

[15:39] <audreyt> but I'd put it a bit differently now

[15:39] <audreyt> so it might be good to rethink this question

[15:39] <audreyt> s/cufp/rejected haskell-workshop/

[15:40] <putter> a characterization without explanation, is, well, the first is probably order-10-ish people on the planet.  at most low-to-mid-order-100.  It could be nice to change that, but that requires something actually written.

[15:42] <audreyt> I think p6 is mostly about reconciling irreconcillable gaps. prototype vs class-based; multi dispatch vs constrained types; inheritance vs interface; typesafety vs ducktyping; early vs late binding; etc

[15:42] <audreyt> some of them are socially irreconcillable, some of them provably irreconcillable.

[15:42] <audreyt> but p6 reconciles them anyway.

[15:44] <audreyt> should probably work out a more canonical list of gaps that p6 is trying to reconcile.

[15:44] <putter> Right.  The "related work" section of a CS paper on p6 has a lot of the flavor I'm thinking of.  /me aborts sentence, whips out "notebook" to capture previous paragraph...

[15:44] <putter> ;)

[15:45] <putter> That's the kind of comment I'm not sure anyone but you can say at the moment.  I'd love to have a little collection of them.

[15:46] <audreyt> I'll... try, I think.

[15:46] *** vel__ left
[15:46] <audreyt> but I'd like to get the release done first :)

[15:46] <putter> awesome.  yes.  :)

[15:46] <audreyt> otoh, it's wonderful to have you back here to raise interesting questions :)

[15:47] * putter blushes

[15:47] * audreyt curtsies :)

[15:49] <clkao> robkinyon: ?

[15:49] <robkinyon> clkao: ??

[15:49] <SamB> do you guys have a @quote equivalent?

[15:49] <putter> I so want to put that "What is p6 about?"  quote somewhere...  perlmonks?  pugs/QUOTES?  ...?

[15:49] <audreyt> ok, I think I want to nap a bit before continuing :)

[15:50] <audreyt> putter: er, well, I'll put it in my journal now.

[15:50] <putter> :)

[15:50] <gaal> so, where's ~(a hash) defined? because it provides newlines while (that hash).perl doesn't

[15:50] * audreyt watches the release schedule slip again ;)

[15:50] * putter is happy :)

[15:51] <putter> err, not about the slip. ;)

[15:51] <gaal> wait no, neither do; so how come the *test* is expecting newlines?

[15:51] <audreyt> gaal: "In order to interpolate an entire hash" S02

[15:52] <gaal> audreyt: I don't see how the test knows it's to expect the newlines :) it compares ~s and .perls

[15:52] <putter> but, the release is more of a hackathon.  a lot of the "bugs" are new features we are simply using the release motivate the implementation of.  no?

[15:53] <gaal> putter: there are loads of regressions we could have noticed earlier but didn't

[15:53] <audreyt> gaal: actually, many of them are not regressions either :)

[15:53] <gaal> so the release is motivating cleanup of refactoring

[15:53] <clkao> robkinyon: sorry, mis-complete

[15:53] <audreyt> (regressions typically happen at middle of subtests)

[15:53] <clkao> rafl: ppong

[15:53] <robkinyon> ahhh. :-)

[15:55] <putter> gaal: did you check the type of "this hash" (in your example)?  I've the very fuzzy recollection of looking at it and it thinking it was an Array.  Array of pairs wouldnt have newlines...

[15:57] *** kimji joined
[15:58] <kimji> hi, is anybody interested in putting a live perl6 repl online for all to try?

[15:58] <integral> we used to have an evalbot here that evaluated arbitrary safe perl6 code

[15:59] <kimji> there is a bunch of those things for Lisp and Scheme

[15:59] <gaal> putter: hmm there is a failing test showing expected Hash got Array

[15:59] <kimji> and they make things easier for me (selfish quest here)

[15:59] <gaal> so that may be a good lead, thanks

[16:00] <putter> np

[16:03] <audreyt> kimji: we used to have an evalbot here

[16:03] <putter> kimji: we normally have one here, invoked by  ?eval <expression>  .

[16:03] <putter> lol ;)

[16:03] <kimji> ?eval 1+1;

[16:03] <putter> But it's been broken for some days, as some features added have left things unstable.

[16:04] <kimji> yeah, I am downloading pugs anyway, thanks :-)

[16:04] <putter> The current release process, expected to last at most another few days, will leave things stable.

[16:05] <putter> So the evalbot will again be back.

[16:05] * putter isnt sure why we just don't run an old working version of the evalbot, until the "always reflect HEAD version of evalbot" is working again.

[16:06] <audreyt> that makes sense.

[16:07] <putter> seen evalbot

[16:07] <jabbot> putter: I havn't seen evalbot, putter

[16:07] <putter> hmm

[16:09] *** masak_ joined
[16:11] *** fxn joined
[16:13] *** imperator_ joined
[16:13] <audreyt> I think I fixed the bug triggering evalbot misbehaviour.

[16:14] <audreyt> confirming

[16:14] <putter> gaal: in case {("a" => 3),} still misparses as a block, I wanted to make sure you saw http://sial.org/pbot/15478 .  I think it's an "almost but not quite" fix.  You are more likely to get to it first than I.

[16:15] *** bsb joined
[16:18] <ingy> nothingmuch: ping

[16:18] <svnbot6> r8737 | audreyt++ | * attempt to solve export-scope problem by not reclosing subEnv

[16:18] <svnbot6> r8737 | audreyt++ |   when exporting to caller's module.  May or may not unbreak evalbot.

[16:18] <svnbot6> r8737 | audreyt++ |   Before this change, the case below was broken:

[16:18] <svnbot6> r8737 | audreyt++ |     module test;

[16:18] <svnbot6> r8737 | audreyt++ |     sub foo is export { bar() }

[16:18] <svnbot6> r8737 | audreyt++ |     sub bar { 3 }

[16:18] <svnbot6> r8737 | audreyt++ |     $ ./pugs -Mtest -e 'say foo()'

[16:19] <ingy> svnbot6: use nopaste!

[16:19] <integral> heh

[16:20] * nothingmuch hugs ingy 

[16:20] <robkinyon> ingy: Where do you use the "alias a symbol to avoid strict" trick in your modules?

[16:21] <robkinyon> diotalevi thought you used it when he answered a question of mine

[16:21] <gaal> putter: thanks

[16:21] <gaal> i need more coffee

[16:22] <ingy> robkinyon: doesn't ring a bell

[16:23] <ingy> I alias symbols, but don't know how that avoids strict

[16:23] <robkinyon> ingy: Ok. Just curious.

[16:23] <ingy> can you explain this?

[16:24] <robkinyon> well, if you do *{ "${pkg}::self" } = \$Class::self; in an import, you can now use $self within $pkg

[16:24] <gaal> ooh, spj introduces lexically scoped type variables. if only I understood what that meant

[16:24] * nothingmuch kicks ingy 

[16:24] <nothingmuch> you pang

[16:25] <audreyt> gaal: it's very easy.

[16:25] <audreyt> gaal: see Pugs.AST.Internals.castFail

[16:26] <audreyt> the ::b bit

[16:28] *** cdpruden joined
[16:28] <gaal> I'm looking but not seeing

[16:28] <gaal> doesn't error have type a?

[16:28] <gaal> well, a -> String

[16:28] <audreyt> errType (undefined :: b)

[16:28] <gaal> eh

[16:29] <audreyt> the "b" is lexically scoped

[16:29] <gaal> about that coffee...

[16:29] <audreyt> note that it's exactly what "want" is :)

[16:29] <audreyt> (type reification of the expected return type)

[16:30] <gaal> is that like the safe cast in the generics papers?

[16:30] <gaal> syb

[16:30] <ingy> nothingmuch: are you to the age of consent?

[16:30] <audreyt> gaal: it's the same mechanism syb uses.

[16:32] <gaal> hmm, I just noticed the implementation of cast isn't given in syb

[16:33] <gaal> or else I didn't get to it yet

[16:33] <audreyt> gaal: 

[16:33] <audreyt> *Main> (intOrStr :: Int, intOrStr :: String)

[16:33] <audreyt> (42,"Hello, world")

[16:33] *** DaGo left
[16:33] <audreyt> something I just wrote. cute? :)

[16:34] <audreyt> *Main> intOrStr :: Double

[16:34] <audreyt> *** Exception: invalid context: Double

[16:34] <gaal> whee!

[16:34] <gaal> so how does that look?

[16:35] <audreyt> http://perlcabal.org/~autrijus/tmp/want.hs

[16:35] <rafl> clkao: Any idea what's the problem here? Retrieving log information from 1525 to 8712

[16:35] <rafl> Oh no, no more exceptions!  add_file() failed. at /usr/share/perl5/SVN/Mirror/Ra.pm line 1219.

[16:35] <rafl> clkao: I'm trying to mirror the openmpi repository.

[16:35] <gaal> can Typeable be implemented in pure Hs?

[16:36] <audreyt> gaal: the answer is yes. there's a paper somewhere

[16:36] <audreyt> but unsafeCoerce# cannot.

[16:36] <gaal> that's a -> b, right?

[16:36] <audreyt> yup

[16:36] <audreyt> turns haskell into a weakly typed language

[16:36] <audreyt> wonderful stuff

[16:36] <putter> lol

[16:36] <gaal> "a -> b" is haskell golf for "evil"

[16:37] <gaal> Cale even told me how to do it, but I successfully forgot :)

[16:37] <geoffb> audreyt, WRT the Num semantics:  Is there a good reason not to do whatever the IEEE floating point standard recommends?

[16:37] <geoffb> My understanding is that a great deal of thought was put into it ....

[16:38] <audreyt> geoffb: indeed, though having 0/0 return an NaN is somewhat controversial

[16:38] <audreyt> geoffb: also, not all platform implement the same revision of IEEEfp

[16:38] <geoffb> Is that the only controversial one?

[16:38] <geoffb> Are the revision differences important to this case?

[16:38] <gaal> so, audreyt, the stuff spj committed does that typing... related to the calling lexical scope?

[16:39] <geoffb> IANAFPE (I am not a floating point expert)  :-)

[16:39] <audreyt> geoffb: neither am I

[16:39] <audreyt> gaal: no, it merely makes "a" visible to where

[16:39] <audreyt> s/where/"where"/

[16:39] <audreyt> previously it was not

[16:39] <putter> {0,NaN,Inf}**0 may perhaps also see a change in 754:200X.

[16:39] <geoffb> I just remember one of my math professors in college was on the IEEE FP committee, and that man is the most edge-case anal guy I've ever met.

[16:40] <audreyt> *nod*

[16:40] <geoffb> putter, do you happen to know why?

[16:40] <putter> it's currently not so much multiple revisions of the standard, but a dearth of fully conforming implementations ;)

[16:40] <geoffb> putter, heh

[16:41] <geoffb> Is the x86 processor line still in compliance?

[16:43] *** lisppaste3 joined
[16:43] <putter> geoffb: I'm bouncing along/over the edge of my understanding here.  My fuzzy recollection is 0**0==1 is strongly desired, and NaN/Inf get pulled along by a "should be true for any x" argument.  Maybe.  Let me see if I bookmarked it...

[16:43] <putter> re x86, no idea.

[16:44] <geoffb> Said professor claimed to have done about as well correctness-wise as he could with the transistor count available in the original x87

[16:45] <putter> re wizzy math professions, I strongly agree.  This is one of those domains where only a few people have a solid understanding of what's really going on, but it seems accessible, so lots of people weigh in with opinions.  Quantum physics is also like that. ;)

[16:45] <geoffb> heh

[16:46] <putter> (for a somewhat different set of people thinking it accessible)

[16:46] <geoffb> nodnod

[16:47] <geoffb> My brother-in-law is/was a high-energy physicist, whereas I only did lower-division physics in college.  I am *so* not planning to weigh in on QP stuff, despite finding it fascinating.  :-)

[16:47] <putter> geoffb: sorry, I didn't tag the paper.

[16:48] * putter wants a browser with a complete history (and search across it of course).

[16:48] <geoffb> putter, np, I'm fine with just knowing that there are certain relevant things still being argued over.

[16:48] <gaal> putter: ask the nsa, they log your access anyway no?

[16:49] <putter> no, I went to their web page and put myself on their "do not log" list.

[16:49] <gaal> too bad, I say make good use of paranoia.

[16:50] <geoffb> Still, I think we could do fairly well with the policy "We will track the current recommendation of the IEEE FP committee", because the only people that will likely care how we handle the edge cases can be expected to at least be providing that input to the committee, if not sitting on it.

[16:50] <geoffb> Or I should say,

[16:50] <geoffb> people likely to care that we change an edge case somewhere down the line, from whatever is the current standard

[16:50] * putter , seeing joke fall flat, adds cultural context.  The US is seeing state and federal "do not call lists" for phone numbers, which are supposed to tell (some) telemarketers not to call you.

[16:51] <putter> (or maybe it just want funny;)

[16:51] <gaal> putter: I grak that, I was just in the other window looking at your nopast again :)

[16:52] <geoffb> Following current international standard seems to me sufficient justification for breaking edge-case compatibility, as long as we tell people we changed it (and of course, it does't even matter until 2*PI is released)

[16:53] <geoffb> OK, enough random wanker input from me, AFK again

[16:53] <lisppaste3> The extended lisppaste outage was caused by a server move this weekend. paste.lisp.org is now on a significantly faster server, and should be available as soon as your DNS catches up. Thanks for your patience!

[16:53] <putter> geoffb: the advantage of having it pragma/use()able, is people who need stable behavior can have it.  people who want particular behavior can get it.  for example, to match another language's spec when transliterating to p6.  and who knows, to go with unicode characters, p6 may become a numericists' platform.  subsume the vast and crufty set a domain specific math languages out there.

[16:54] <geoffb> I can understand having it pragma'able, I was merely referring to the default base semantics

[16:55] <geoffb> And as for becoming a numericists platform, I'd say only if we can make it FAST, which implies people will use num instead of Num anyway.

[16:55] <svnbot6> r8738 | audreyt++ | * remove the redundant "--" in multiarg options.

[16:55] <geoffb> As my math professor said "The Fast drives out The Slow, even if The Fast is wrong."

[16:56] <putter> re fast, that's what audreyt's nifty type theory and haskell are for. :)

[16:56] <putter> And there is always Inline::C to fall back on. ;)

[16:56] *** sub_chick joined
[16:56] <geoffb> Numericist fast, and dynamic language fast, are in different orders of magnitude.  :-)

[16:56] <geoffb> And Fortran is still around because it's hard to make C go that fast.

[16:57] <geoffb> And, of course, oodles of hand-tuned Fortran libraries

[16:57] <putter> Inline::Fortran?

[16:57] <geoffb> OK, really, must AFK

[16:57] <putter> bye

[16:58] <Limbic_Region> how close to 6.2.11 are we?

[16:58] *** marmic joined
[16:58] <integral> (Numerical Recipes in Fortran 95)++ # very scary code

[16:58] * putter observes ocaml can produce quite fast code.  though doesnt have anywhere near the tuning effort invested as a good F library.

[16:59] *** DaGo joined
[16:59] <audreyt> Limbic_Region: this weekend.

[17:00] <putter> (Numerical Recipes in *)-- # often "clearly not written by expert" code (so I have been told)

[17:00] <integral> I think fortran is meant to win on vector processors due to it's do loop which can be optimised easily.  (Compared to something like a C for loop where you've got to spot common patterns and hope the programmer uses them)

[17:00] <integral> (Numerical Recipes in *)-- # expensive licencing fees

[17:00] <Limbic_Region> oh, I thought it was this past weekend

[17:00] <bsb> Hi all, is this Israel hackathon a more the merrier type thing?

[17:00] <Limbic_Region> how many $work days you got this week audreyt?

[17:01] <audreyt> hm

[17:01] <audreyt> should I start evalbot loop on feature

[17:01] <audreyt> or should I wait for luqui?

[17:01] <audreyt> (it's now fixed.)

[17:01] <audreyt> bsb: I think so -- talk to OSDC.il people (eg gaal) :)

[17:01] <gaal> hi bsb

[17:01] <bsb> hi

[17:02] <gaal> yes, but if you want to come please tell us very soon :)

[17:02] <theorbtwo> audreyt: Start it up with a non-default name?

[17:02] <gaal> it'll cost about $40/day

[17:02] <audreyt> Limbic_Region: it was; I got distracted. 3 as usual. (it's all on my journal. :))

[17:02] <gaal> but we need to close on a venue in soon, like this week.

[17:03] <bsb> That's fine.  I'll start looking at ticket to .il

[17:03] <gaal> whee

[17:03] *** justatheory joined
[17:03] <putter> re vector processors, http://bc.tech.coop/blog/060111.html   Concurrent/Parallel Programming - The Next Generation

[17:03] <gaal> bsb: are you also coming to the conf?

[17:03] <audreyt> Limbic_Region: it was last weekend. then I got this unfortunate allergic incident with hair colorant -- long story.

[17:04] <bsb> Yes, if I'm there.

[17:04] <Limbic_Region> oh right, you glossed over that

[17:04] <Limbic_Region> tell me you were going red

[17:04] * Limbic_Region has a thing for red heads

[17:04] <audreyt> nah, dark purple. I like it

[17:04] <audreyt> although a bit reddish also. but not bright red.

[17:05] <bsb> gaal: I'm still yet to register of course

[17:05] <Limbic_Region> well - I should say more auburn then anything

[17:05] *** evalbot_8738 joined
[17:05] <gaal> bsb: okay, please do as soon as you can

[17:05] <gaal> ?eval "hello, #perl6!"

[17:05] <evalbot_8738> "hello, #perl6!" 

[17:05] <putter> luqui: ping?

[17:06] <Limbic_Region> ?eval say 'hello, #perl6!'

[17:06] <evalbot_8738> OUTPUT[hello, #perl6! ] bool::true 

[17:06] <putter> luqui: never mind. ;)

[17:07] <Limbic_Region> what - no translation for the "\n"

[17:07] <putter> ?eval {("a" => 3),}

[17:07] <evalbot_8738> (("a" => 3),) 

[17:07] <Limbic_Region> ?eval for 1... { last if $_ == 3 }

[17:07] <evalbot_8738> pugs: out of memory (requested 1048576 bytes) 

[17:07] <Limbic_Region> that's still b0rk huh

[17:08] <putter> ?eval {("a" => 3),}.ref

[17:08] <evalbot_8738> ::Block 

[17:08] <audreyt> if luqui wants to takeover, just kill the process on feather

[17:08] <audreyt> I'll test its renick 

[17:09] <putter> audreyt: sucked away from nap?

[17:09] <audreyt> evalbot is to critical :)

[17:10] <svnbot6> r8739 | audreyt++ | * remove a trailing newline from README.

[17:11] *** bernhard joined
[17:11] <gaal> the 2nd-to-last split test fails:

[17:11] <gaal> ?eval "".split(':')

[17:11] <evalbot_8738> ("",) 

[17:11] <gaal> the test expects ()

[17:11] <gaal> but there's a comment that this isn't specced!

[17:11] *** _SamB_ joined
[17:11] <gaal> what to do then?

[17:12] <putter> audreyt: :)

[17:12] <gaal> (sorry, I've punted from the parser things, I'm out of the zone today)

[17:12] *** _SamB_ is now known as SamB

[17:13] <nnunley> gaal:  That's perl's behavior.

[17:13] <nnunley> perl5's that is.

[17:14] <gaal> nnunley: true. the comment implies it shoudn't be p6's

[17:15] <gaal> so I want to know which needs fixing, the test or pugs :)

[17:15] <theorbtwo> I think the current behavior is correct, but I'm !~ @larry.

[17:16] <theorbtwo> Skip the test and post to p6l?

[17:17] <audreyt> ?eval "version up?"

[17:17] *** evalbot_8738 is now known as evalbot_8739

[17:17] <evalbot_8739> pugs: user error (*** Can't modify constant item: VUndef     at <prelude> line 124, column 5-72)  

[17:17] <gaal> yeah. we need better TZ-spread of @Larry.

[17:18] <audreyt> wow.

[17:20] *** evalbot_8739 joined
[17:20] <svnbot6> r8740 | audreyt++ | * remove the %*INC<fatal> hack from Prelude.pm because

[17:20] <svnbot6> r8740 | audreyt++ |   1) it breaks evalbot under precompile_prelude=false

[17:20] <svnbot6> r8740 | audreyt++ |   2) it doesn't work anyway with the new lexical import system.

[17:20] <audreyt> ?eval "prelude still borken?"

[17:20] <evalbot_8739> "prelude still borken?" 

[17:21] <audreyt> better.

[17:21] <audreyt> luqui: feel free to takeover and kill feather process #15602 #18431

[17:21] <gaal> audreyt: speaking of %INC hacks, precomp Test is currently useless because %INC<Test> isn't defined :/

[17:21] <theorbtwo> Why did the stuff from 8740 fix evalbot_8739?

[17:22] <audreyt> gaal: yup

[17:22] <gaal> ?eval $?PUGS_VERSION

[17:22] <evalbot_8739> \"Perl6 User\'s Golfing System, version 6.2.10, October 10, 2005 (r8739)" 

[17:22] <audreyt> theorbtwo: because I fixed it on feather first, runs evalbot, and then committed

[17:22] <theorbtwo> OK.

[17:22] <audreyt> this is not the time traveling you are looking for :)

[17:23] <gaal> :D

[17:23] * gaal wonders what it is that's making his mind mushy today

[17:23] <audreyt> magick mushyrooms?

[17:24] <putter> gaal: that's not excuse for such a security slip!

[17:24] <audreyt> now evalbot is fixed, I can happily sleep :)

[17:24] * audreyt waves

[17:24] <putter> bye audreyt &

[17:24] <masak_> audreyt: g'nite

[17:24] <gaal> putter: let me slip into something more secure?

[17:25] <gaal> night audrey

[17:25] <gaal> that's more or less the opposite of the line I prefer,

[17:26] <audreyt> ?eval "make sure that versioning up works"

[17:26] <gaal> "let me slip into something more temporary"

[17:26] *** evalbot_8739 is now known as evalbot_8740

[17:26] <evalbot_8740> "make sure that versioning up works" 

[17:26] <putter> why p6?  number 423: #p6 has worse jokes than #hs ;)

[17:26] <gaal> lol

[17:26] <putter> s/number/reason number/

[17:27] <audreyt> &

[17:54] *** petdance joined
[17:57] *** petdance left
[17:57] <putter> audreyt: re ./pugs foo.p6 --help, my impression is this is gnu standard, but posix terminates arguments on the first non-argument.  gnu permits ./pugs *.p6 -o foo.pil  for example.  and mode-ed command lines ./pugs -O3 f1.p6 f2.p6 -O1 f3.p6.  looks like ghc is gnu, non-mode-ed, without order restrictions.  like your help example.

[17:58] *** Qiang joined
[17:59] <putter> perl, with -A and -C, is beyond gnu ;), but has order restrictions.  non-moded.

[17:59] <putter> -- in posix merely permits odd filenames.  -- in gnu, means end of option processing.

[18:04] <putter> actually, calling p5 non-moded, when you would and can use -e or -M to do modes, doesnt quite fit.  and ghc, while not permitting  -O3 f1.p6 f2.p6 -O1 f3.p6, does have +RTS ... -RTS.

[18:06] <putter> there's no reason to back out the change, the more restrictive posix being upwardly compatible.  but if we retain the single monolithic powerful ./pugs program, then we'll sooner or later need something more powerful, like ghc's.

[18:07] *** vel__ joined
[18:08] <putter> p5's "beyond gnu" means some options occur even after the "--".  and not in a princpled turn-on/off files section way either.  eep.

[18:09] *** nnunley joined
[18:16] <putter> ooo, though a different model would be ./pugs has basically a single command line option, -M.  Eg, ./pugs -M Parser-Pretty -- --indent 3 foo.p6.  Most everything done by some p6 module, eg Pugs/Parser-Pretty.pm.  random bizarre thought.

[18:19] <putter> the p6 code would basically call back to fiddle with the hs ./pugs... ok that's not workable - too much environment would have to be set up.  unless p6 had a simple restricted bootstrap dialect to top the file...  I'll stop now.

[18:21] <putter> later &

[18:21] *** Limbic_Region joined
[18:24] *** feng joined
[18:28] *** putter joined
[18:29] <gaal> bsb: ping

[18:30] <putter> oh, one other nice concept - a "command line syntax" version number.  eg, ./pugs -v0 ... .   when things are in flux, that allows easily and incompatibly changing the default command line arguments without breaking automated use.  good when a prototype is in flux, you want the result to be optimized without out concern

[18:32] <putter> for development history, but you have "users" that you cant afford to keep updating.  implementation is easy enough, as long a N doesnt get too silly.  and one can do the usual depreciation thing.

[18:32] <putter> &

[18:35] <bsb> gaal: pong

[18:36] <gaal> can I /msg you? (are you registered)

[18:36] <bsb> I think so, else bsb at bereft.net

[18:37] <theorbtwo> Whois tells you.

[18:37] <gaal> heh, that was part of what I wanted to ask :)

[18:38] *** hcarty joined
[18:54] *** pdcawley1 joined
[18:55] <robkinyon> ?eval 0**Inf

[18:55] <robkinyon> Did I just crash evalbot?

[19:25] *** benpol left
[19:26] *** hexmode joined
[19:34] *** hcarty left
[19:46] *** fxn joined
[19:47] *** fxn left
[20:12] *** rodi joined
[20:14] *** Lartuv joined
[20:14] <Limbic_Region> summon evalbot

[20:20] *** wilx joined
[20:29] *** iblechbot joined
[20:29] <rodi> wow, it's craaaaa-a-a-a-a-a-aaazy in here.

[20:31] *** dduncan joined
[20:31] <dduncan> greetingsw

[20:32] <dduncan> I had a power outage last night, else I would have done another commit then

[20:32] <dduncan> but one should come in under an hour

[20:32] *** aminorex joined
[20:32] <aminorex> the tang haskell tutorial looks good, but it's cryptic without auxilliary text.  is this written more fully elsewhere?

[21:03] *** rlp joined
[21:06] *** Ovid joined
[21:08] <Limbic_Region> salutations Ovid

[21:08] <Ovid> Hi there.

[21:29] *** marmic joined
[21:39] *** Ovid joined
[21:45] *** pmccann joined
[22:04] *** kcwu joined
[22:09] *** r0nny joined
[22:12] *** kcwu_ joined
[22:22] *** vel__ left
[22:39] *** rlp left
[22:43] *** christo joined
[22:44] *** sub_chick left
[22:49] *** christo left
[22:55] <svnbot6> r8741 | Darren_Duncan++ |  r2052@Darren-Duncans-Computer:  darrenduncan | 2006-01-17 14:45:06 -0800

[22:55] <svnbot6> r8741 | Darren_Duncan++ |  /ext/Rosetta[|-Engine-Native] : changed the license of the Rosetta framework, mainly the nature of my GPL linking exception; edited pod in Rosetta.pm, Copying.pod, Native.pm, Native/L/en.pm

[22:58] *** Maddingue joined
[23:29] *** nicbrown joined
[23:34] <tewk> dist/build/libHSPugs-6.2.10.a(Syck.o): In function `s6Ei_3_alt':ghc1896.hc:(.text+0x1d36): undefined reference to `DataziYamlziSyck_d5Qn'

[23:35] <tewk> Can I rebuild something to fix that without rebuilding clean

[23:35] <SamB> tewk: thats a linker error.

[23:35] <SamB> tewk: you need an additional -package flag

[23:35] <SamB> for the package that includes Data.Yaml.Syck, I think...

[23:36] <tewk> SamB: well whenever I make clean it goes away until a new svn update breaks it

[23:36] <SamB> tewk: you get the same error a lot?

[23:36] <tewk> Not with every update, but yes

[23:37] <SamB> with approximately the same symbol, even?

[23:37] <tewk> :ghc1896.hc:(.text+0x1dae): undefined reference to `DataziYamlziSyck_d5Qo':ghc1896.hc:(.text+0x1e26): undefined reference to `DataziYamlziSyck_d5Qp':ghc1896.hc:(.text+0x1e9e): undefined reference to `DataziYamlziSyck_d5Qq'

[23:37] <tewk> yeah

[23:38] <tewk> /usr/bin/ar: creating dist/build/libHSPugs-6.2.10.a*** Found more than one 'Syck_stub.o' -- using the first one. *** Found more than one 'Perl5_stub.o' -- using the first one. *** Found more than one 'Parrot_stub.o' -- using the first one. 

[23:38] <SamB> tewk: okay, maybe you don't need a package...

[23:39] <SamB> hmm... Syck.o...

[23:39] <SamB> I'd suggest deleting Syck.o and Syck_stub.o and trying again?

[23:41] *** nicbrown joined
[23:42] <SamB> its probably one of those Makefile.PL omissions...

[23:43] <tewk> rm dist/build/src/Data/Yaml/Syck*.o did the trick

[23:44] * SamB hasn't pulled in a while, mostly answers Haskell questions and talks about nonsense

[23:45] *** Debolaz joined
[23:45] * SamB doesn't even remember that the command is "svn up" and not "svn pull"

[23:47] <tewk> SamB Sounds like a darcs user, to me.  I think you might have answered a questions for me on #haskell once upon a time, or maybe it was here.

[23:50] <rafl> SamB: Use svk and svk pull ;-)

[23:51] <SamB> rafl: doesn't seem to much like dialup

[23:53] *** mncharity joined
[23:53] *** mncharity is now known as putter

[23:59] *** hcarty joined
