[00:11] *** TMTOWTDIt left
[00:37] *** frederico_ joined
[01:23] *** joepurl joined
[01:48] *** pankaj_ joined
[02:16] *** vel joined
[02:29] *** Supaplex_ joined
[02:45] *** samuel joined
[02:49] *** Bit-Man joined
[03:03] *** Khisanth joined
[03:09] *** samuel joined
[03:12] *** samuel joined
[03:14] *** samuel joined
[03:15] *** samuel joined
[03:18] *** samuel joined
[03:19] *** hcarty joined
[03:19] *** hcarty left
[03:20] *** samuel joined
[03:23] *** samuel joined
[03:27] *** samuel joined
[03:34] *** samuel joined
[03:38] *** samuel joined
[03:44] *** samuel joined
[03:48] *** samuel joined
[03:51] *** samuel joined
[03:53] *** samuel joined
[03:56] *** joepurl joined
[03:58] *** samuel joined
[04:04] *** samuel joined
[04:06] *** samuel joined
[04:09] *** samuel joined
[04:12] *** samuel joined
[04:13] *** amnesiac joined
[04:14] *** samuel joined
[04:21] <ayrnieu> sigh, I'm lame.

[04:21] * ayrnieu forgets his feather password.

[04:33] <Khisanth> samuel: are you planning on staying or what?

[04:36] *** mako132_ joined
[04:37] *** samuel joined
[04:39] *** samuel joined
[04:41] *** samuel joined
[04:44] *** samuel joined
[04:45] *** stevan joined
[04:47] *** samuel joined
[04:49] *** samuel joined
[04:51] *** samuel joined
[04:54] *** samuel joined
[04:57] *** samuel joined
[04:59] *** justatheory joined
[05:00] *** samuel joined
[05:02] *** samuel joined
[05:05] *** samuel joined
[05:06] *** samuel joined
[05:07] *** mauke joined
[05:10] *** samuel joined
[05:12] *** samuel joined
[05:12] *** drrho joined
[05:15] *** K joined
[05:17] *** samuel joined
[05:21] *** samuel joined
[05:25] *** jisom joined
[05:26] *** samuel joined
[05:31] *** samuel joined
[05:33] *** samuel joined
[05:36] *** samuel joined
[05:38] *** samuel joined
[05:41] *** samuel joined
[05:43] <TimToady> putter: it would be relatively easy to make a patch to disable interpolation (except for \\) on regexen.  Would that help?

[05:44] *** samuel joined
[05:49] *** samuel joined
[05:52] *** samuel joined
[05:53] <gaal> bsb, lumi: ping

[05:53] *** samuel joined
[05:54] <gaal> pizza saturday, my place

[05:54] *** xinming joined
[05:56] *** samuel joined
[06:01] *** samuel joined
[06:06] *** samuel joined
[06:09] <jisom> is there currently any intention of allowing inlined pir/pasm in perl 6?

[06:09] *** samuel joined
[06:12] *** samuel joined
[06:17] *** samuel joined
[06:18] *** draconit_ joined
[06:19] *** samuel joined
[06:23] *** iblechbot joined
[06:23] *** samuel joined
[06:27] *** beppu_ joined
[06:27] *** jisom left
[06:27] *** samuel joined
[06:28] *** jisom joined
[06:29] *** samuel joined
[06:31] *** draconit_ left
[06:32] *** samuel joined
[06:32] *** draconit_ joined
[06:35] <gaal> jisom: eval $pir, :lang<parrot> should work

[06:35] <gaal> $work &

[06:36] <jisom> right now I think compiling ghc stalled the computer building ghc...might have to force it to restart....should also say that the memory requirements for building ghc are excessive instead of just "it's slow"

[06:38] *** samuel joined
[06:40] *** samuel joined
[06:42] *** samuel joined
[06:44] *** samuel joined
[06:48] <GeJ> morning folks

[06:48] <draconit_> boker

[06:48] <draconit_> morning

[06:53] *** samuel joined
[06:57] <dduncan> I think that effing multiple commit is going to happen again ...

[06:57] <svnbot6> r9230 | Darren_Duncan++ |  r2625@darren-duncans-power-mac-g4:  darrenduncan | 2006-02-23 16:48:45 -0800

[06:57] <svnbot6> r9230 | Darren_Duncan++ |  ext/Rosetta/ : small changes to resync with new 0.721.0 CPAN release

[06:57] <dduncan> yep, there it is

[06:58] *** samuel joined
[06:58] <dduncan> god, and I don't think that's the only one, either

[06:58] <svnbot6> r9231 | Darren_Duncan++ |  r2646@darren-duncans-power-mac-g4:  darrenduncan | 2006-02-24 01:11:26 -0800

[06:58] <svnbot6> r9231 | Darren_Duncan++ |  ext/Rosetta/ : incremented main module versions following CPAN release, fixed format bugs in Language.pod

[06:58] <dduncan> f*ck

[06:59] <dduncan> stupid svk

[06:59] <dduncan> yet another ...

[07:01] <svnbot6> r9232 | Darren_Duncan++ |  r2671@darren-duncans-power-mac-g4:  darrenduncan | 2006-02-25 01:39:44 -0800

[07:01] <svnbot6> r9232 | Darren_Duncan++ |  ext/Rosetta/ : added new module Rosetta::Shell, an interactive command shell over Rosetta, to make casual use/try-outs/dev/testing easier

[07:01] <svnbot6> r9233 | Darren_Duncan++ |  r2730@darren-duncans-power-mac-g4:  darrenduncan | 2006-03-01 22:54:27 -0800

[07:01] <svnbot6> r9233 | Darren_Duncan++ |  ext/Rosetta/ : added new file examples/shell.p6, updated Shell.pm and Model.pm

[07:02] <dduncan> okay, actually that one was correct

[07:02] <dduncan> r9233 is correct, 32 and 31 are dups

[07:03] <dduncan> and 30 is a dup

[07:03] *** samuel joined
[07:08] *** samuel joined
[07:13] *** f joined
[07:13] *** samuel joined
[07:15] *** samuel joined
[07:17] *** samuel joined
[07:20] *** samuel joined
[07:22] *** samuel joined
[07:22] <xinming> flooding?

[07:24] *** samuel joined
[07:26] <buu> So

[07:27] *** samuel joined
[07:27] <buu> How are roles different from multiple inheritance?

[07:29] *** samuel joined
[07:32] *** samuel joined
[07:34] *** samuel joined
[07:37] *** samuel joined
[07:37] <audreyt> greetings

[07:38] <audreyt> <- about to take taxi to German Perl Workshop

[07:38] <Kattana> Hallo o/

[07:38] <audreyt> the airline (Austrian/Lufthansa) lost all baggage

[07:38] <audreyt> they are still trying to 1)find it and 2)send it to hotel

[07:38] <audreyt> hence I'm without most of my stuff :/

[07:38] <audreyt> buu: roles are flattened, so you don't ever have to call super()

[07:39] <audreyt> buu: also, if two roles provides the same methods to a class that mixes them in, that's a compile time error rather than runtime breakage

[07:39] <buu> So what happens if one role provides a method another role does?

[07:39] <buu> heh

[07:39] <audreyt> conflict

[07:39] <audreyt> ;)

[07:39] *** samuel joined
[07:40] <audreyt> okay, bbl in ~30min if the workshop has wireless

[07:40] <audreyt> &

[07:42] *** samuel joined
[07:44] *** samuel joined
[07:47] *** samuel joined
[07:49] *** mj41__ joined
[07:49] *** wilx`` joined
[07:52] *** samuel joined
[07:55] *** samuel joined
[07:56] <ayrnieu> irssi: /ignore samuel JOINS PARTS

[07:56] *** samuel joined
[07:58] *** meppl joined
[07:59] <gaal> audreyt!

[08:00] *** samuel joined
[08:10] *** Bit-Man joined
[08:25] *** ghenry joined
[08:27] *** jisom_ joined
[08:31] *** pankaj_ is now known as spo0nman

[08:31] *** jisom_ joined
[08:33] *** ghenry_ joined
[08:39] *** marmic joined
[08:59] *** nothingmuch joined
[09:01] <nothingmuch> hola

[09:01] <gaal> hey nothingmuch 

[09:05] * nothingmuch read the first SYB paper

[09:05] <nothingmuch> how does it replace the threading of inherited/synthesized attrs in AGs?

[09:05] <nothingmuch> it's like having just synthesized ones

[09:06] <nothingmuch> and while impressive, it's completely orthogonal =)

[09:07] * azuroth curses UML

[09:09] <gaal> I've no idea--am not familiar with AGs--where did you see it claimed that it did?

[09:10] <nothingmuch> everyone said that SYB is >= AGs

[09:24] <nothingmuch> mooseness

[09:29] <ayrnieu> ?eval { my $bal = 0; sub deposit { $bal += @_[0]; $bal } sub withdraw { if ($bal - @_[0] < 0) { "Sorry, you only have a balance of \\$bal" } else { $bal -= @_[0]; $bal } } } [deposit(250), withdraw(5), withdraw(5), withdraw(100), withdraw(200)]

[09:29] <evalbot_9233> [undef, undef, undef, undef, sub {...}] 

[09:31] <azuroth> dare I question that?

[09:31] <ayrnieu> ah, oops.

[09:32] <ayrnieu> ?eval { my $bal = 0; sub deposit { $bal += @_[0]; $bal } sub withdraw { if ($bal - @_[0] < 0) { "Sorry, you only have a balance of \$bal" } else { $bal -= @_[0]; $bal } } }; [deposit(250), withdraw(5), withdraw(5), withdraw(100), withdraw(200)]

[09:32] <evalbot_9233> [250, 245, 240, 140, "Sorry, you only have a balance of \$bal"] 

[09:32] <ayrnieu> oops again :-)  azuroth - sure, why not?

[09:32] <azuroth> ohh, it was.. trying to subscript the scope..?

[09:33] <azuroth> for fear of being laughed at ;-)

[09:36] <ayrnieu> if you're already afraid of being laughed at, and in no danger of contracting this fear through trauma...

[09:37] <ayrnieu> would you mind rewriting what I just wrote where $bal is an object with .deposit and .withdraw methods? :-)

[09:37] <azuroth> I can try...

[09:39] <azuroth> ?eval class Account { has $:bal; method deposit(Int $amt) { $:bal += $amt }; method withdraw(Int $amt) { if ($bal - $amt < 0) {"Sorry, $bal"} else {$bal -= $amt} } }

[09:39] <evalbot_9233> Error:  unexpected ":" expecting "$!" 

[09:43] *** Draconit joined
[09:43] <azuroth> nah, I've no idea

[09:46] <ayrnieu> ah well, someone who has one will surely come along.

[09:46] <ayrnieu> curiously, though, why did you say Int $amt ?

[09:47] <azuroth> good point; s/Int/Num/

[09:48] <azuroth> or did you mean why prototype at all?

[09:49] <ayrnieu> no, just why the Int

[10:02] * rafl searches for an easy but practical example of rules.

[10:03] <rafl> I'd like to mention them in my Perl 6 talk on GPW, but I think I would need 40 minutes only to explain them.

[10:03] <rafl> Unfortunately the whole talk needs to fit into 40 minutes.

[10:04] *** rantanplan_ joined
[10:12] *** mako132_ joined
[10:14] <ayrnieu> ?eval class Account { has $.bal; method deposit (Num $amt) { $.bal += $amt; $?SELF }; method withdraw (Num $amt) { $.bal < $amt and return "Sorry, you've only \$$.bal"; $.bal -= $amt; $?SELF } }; my $act = ::Account.new.deposit(250); [map { $act.withdraw($_); $act.bal } <5 5 100 200>]

[10:14] <evalbot_9233> [245.0, 240.0, 140.0, 140.0] 

[10:15] <ayrnieu> bias towards returning $self^W$?SELF , meet wall.

[10:15] <ayrnieu> ?eval class Account { has $.bal; method deposit (Num $amt) { $.bal += $amt }; method withdraw (Num $amt) { $.bal < $amt and return "Sorry, you've only \$$.bal"; $.bal -= $amt } }; my $act = ::Account.new.deposit(250); [map { $act.withdraw($_) } <5 5 100 200>]

[10:15] <evalbot_9233> Error: No such method in class Int: "&withdraw" 

[10:16] *** iblechbot joined
[10:16] <ayrnieu> ?eval class Account { has $.bal; method deposit (Num $amt) { $.bal += $amt }; method withdraw (Num $amt) { $.bal < $amt and return "Sorry, you've only \$$.bal"; $.bal -= $amt } }; my $act = ::Account.new; $act.deposit(250); [map { $act.withdraw($_) } <5 5 100 200>]  # :-(

[10:16] <evalbot_9233> [245.0, 240.0, 140.0, "Sorry, you\'ve only \$140"] 

[10:17] <jp-autark> can you defined your own "Num" type, say to be all numbers >= 0?

[10:18] <jp-autark> define

[10:19] * ayrnieu doesn't know.

[10:19] <azuroth> I think so - somehow

[10:19] <ayrnieu> class Num { has $.bal = 1_000_000 }; 5.bal

[10:19] <ayrnieu> ?eval class Num { has $.bal = 1_000_000 }; 5.bal

[10:20] <evalbot_9233> Error:  unexpected "=" expecting trait, "handles", ";" or "}" 

[10:22] *** clkao joined
[10:24] <lypanov> hey clkao

[10:25] <ayrnieu> ?eval class Num { has $.bal is rw }; my $n = ::Num.new; [$n, $n.foo = 10, $n.foo, $n.foo = 5, $n.foo]

[10:25] <evalbot_9233> Error: No such method in class Num: "&foo" 

[10:25] <ayrnieu> ?eval class Num { has $.foo is rw }; my $n = ::Num.new; [$n, $n.foo = 10, $n.foo, $n.foo = 5, $n.foo]

[10:25] <evalbot_9233> [Num.new(("foo" => 5),), 10, 10, 5, 5] 

[10:28] <azuroth> ?eval my subset PosNum of Num where {$^x >= 0}; my PosNum $a = 5;

[10:29] <evalbot_9233> Error:  unexpected "P" expecting variable name or "(" 

[10:29] <azuroth> ?eval my subset PosNum of Num where {$^x >= 0}; my $a = PosNum.new(5);

[10:29] <evalbot_9233> Error:  unexpected "P" expecting variable name or "(" 

[10:29] <azuroth> ?eval my subset PosNum of Num where {$^x >= 0}; my $a = ::PosNum.new(5);

[10:29] <evalbot_9233> Error:  unexpected "P" expecting variable name or "(" 

[10:30] <azuroth> ?eval my Num subset PosNum where {$^x >= 0}; my $a = ::PosNum.new(5);

[10:30] <evalbot_9233> Error:  unexpected "s" expecting variable name or "(" 

[10:30] <azuroth> oh well

[10:34] <ayrnieu> there are no subtype tests in Pugs, currently.  Want to write a test?

[10:36] <ayrnieu> oops, they are in data_types/

[10:36] <ayrnieu> somehow, my grepping failed me.

[10:37] <ayrnieu> actually, Perl6::Bible's S12.pod just seems out of date.  The tests indicate that it's called 'subtype', now.

[10:38] <azuroth> hmm. I'd be inclined to go with the synopses rather than the tests? :x

[10:38] <ayrnieu> (still not implemented)

[10:39] *** chris2 joined
[10:40] <ayrnieu> (I mean, the not-implementedness of subtype continues the perceived likely not-implementedness of subset.)

[10:41] <azuroth> true

[10:44] <ayrnieu> but, yes, it looks like I could just use a lexical subtype for ::Account :-)

[10:45] <ayrnieu> where I could make type errors out of <=0

[10:47] <azuroth> interesting indeed

[10:48] <azuroth> I'm learning about derivatives of graphs. I really wish I'd done some proper maths

[10:55] <ayrnieu> ?eval multi rev () {}; multi rev (*$a, *@r) { (rev(@r), $a) }; rev 1..5

[10:55] <evalbot_9233> (\5, \4, \3, \2, \1) 

[10:55] <ayrnieu> ?eval, (5,4)

[10:55] <evalbot_9233> Error:  unexpected "," expecting program 

[10:56] <ayrnieu> ?eval (5,4)

[10:56] <evalbot_9233> (5, 4) 

[11:06] <svnbot6> r9234 | juerd++ | Committing my Perl 6 Myths talk

[11:16] <rafl> audreyt: Nice talk

[11:18] *** ntgrl joined
[11:22] <nothingmuch> jabbot: seen audreyt?

[11:22] <jabbot> nothingmuch: audreyt was seen 3 hours 41 minutes 51 seconds ago

[11:22] <nothingmuch> arf

[11:22] <nothingmuch> just missed her then =)

[11:22] <nothingmuch> =(

[11:22] <lypanov> 01:57 < audreyt> [00:40] okay, bbl in ~30min if the workshop has wireless

[11:23] <lypanov> now == 04:22

[11:23] <lypanov> so at a guess, workshop didn't have wireless

[11:23] <nothingmuch> lypanov: Juerd seemed to have access

[11:24] <Juerd> Audrey can't get the vpn to work

[11:24] <nothingmuch> i just got retro-spam

[11:24] <nothingmuch> spam dated for 2005

[11:24] <nothingmuch> oh

[11:25] <Juerd> We exchange my lightening talk on a usb stick :)

[11:28] *** K joined
[11:35] *** Draconit left
[11:35] <nothingmuch> מוס!

[11:35] *** Draconit joined
[11:36] <nothingmuch> Juerd: send my regards to balas if she's at the workshop

[11:37] <Juerd> I haven't seen balas

[11:37] <svnbot6> r9235 | juerd++ | Audrey's changes: present tense, blank lines, a new slide, a better "Perl 6 is not Perl" slide

[11:38] <lypanov> umm

[11:38] <nothingmuch> In that case, please don't try to greet her under any circumstance

[11:38] <lypanov> that reminds me. stupid question... but

[11:38] <nothingmuch> there's no point in trying to do it if she's not there!

[11:38] <lypanov> why did perl6 keep $/%/@ ?

[11:38] <ntgrl> lypanov++

[11:39] <Juerd> lypanov: Because they're useful. 

[11:39] <nothingmuch> lypanov: they help disambiguate things

[11:39] <nothingmuch> for example &sub is the value

[11:39] <nothingmuch> but sub is a call

[11:39] <nothingmuch> this allows us to not need to say sub() all the time

[11:40] <lypanov> & understand 

[11:40] <lypanov> but $ % and @?

[11:40] <nothingmuch> it also helps reading

[11:40] <lypanov> & makes perfect sense, i'm a ruby oldie and have to agree

[11:40] <nothingmuch> they're not *really* necessary

[11:40] <lypanov> is it still possible to use a % instead of a $ and make the code just /not work/?

[11:40] <nothingmuch> but:a

[11:40] <Juerd> lypanov: Of course.

[11:40] <nothingmuch> a. it doesn't really fudge

[11:41] <nothingmuch> i mean, it's not a hindrance of any sort

[11:41] <lumi> nothingmuch: ping

[11:41] <nothingmuch> b. it helps readability

[11:41] <lumi> Well, not ping

[11:41] <nothingmuch> c. it is perlish

[11:41] <lypanov> but it requires you to think about it while you are coding more...

[11:41] <nothingmuch> lumi: gnip?

[11:41] <lypanov> its the reason i don't use perl...

[11:41] <Juerd> lypanov: They're *ugly*, but ugly isn't a reason to have or not have something.

[11:41] <nothingmuch> i like having to think while i code

[11:41] <lypanov> this is kind of sad :(

[11:41] <Juerd> lypanov: They're useful and make many things easier.

[11:41] <nothingmuch> ;-)

[11:41] <lypanov> nothingmuch: i don't

[11:41] <lypanov> nothingmuch: my test cases do my thinking

[11:41] <nothingmuch> actually i sort of agree

[11:41] <nothingmuch> eek

[11:41] <nothingmuch> that's not a good enough approahc

[11:42] <nothingmuch> thinking is required

[11:42] <Juerd> lypanov: Every feature, every character, everything, in programming, requires thinking. If you are unable to think, or don't like to think, programming is not for you.

[11:42] <nothingmuch> at least at some level

[11:42] <lypanov> nothingmuch: somedays i'm tired

[11:42] <nothingmuch> thinking about *language tax* is not

[11:42] <ntgrl> you could also ask why we have % and @, instead of just having all containers as objects in $ vars

[11:42] <nothingmuch> but

[11:42] <nothingmuch> sigils help when reading

[11:42] <lypanov> ntgrl: exactly

[11:42] <nothingmuch> lack of sigils help with writing

[11:42] <Juerd> ntgrl: You can have that if you want.

[11:42] <ntgrl> it's easy to think that functions are special to warrant a sigil

[11:42] <lypanov> sigils just confuse...

[11:42] <ntgrl> Juerd: yeah, you just have to become world president first to force everyone else to do it too =)

[11:43] <Juerd> ntgrl: Forcing people has never been Perlish.

[11:43] <ntgrl> Juerd: okay, how do I write perl code *without* being forced to use sigils? :-P

[11:43] <lypanov> okay. lets put it another way

[11:44] <lypanov> is slice syntax still utterly fucked or does it Just Work these days?

[11:44] <ntgrl> it was utterly fucked?   (for something other than hash references...)

[11:44] <lypanov> ntgrl: i mean for hash refs

[11:44] <lypanov> sorry should have said that

[11:45] <nothingmuch> perl 6 slicing for hashes is OK now

[11:45] <nothingmuch> i think

[11:45] <lypanov> does perl6 still have this weird concept of refs vs non refs?

[11:45] <nothingmuch> that's a weird concept?

[11:45] <ntgrl> my question is: why separate sigils for hashes and arrays?  why not just: my @array is vector; my @array is hash; my @array is btree; ?

[11:45] <ntgrl> lypanov: curiously I wouldn't have said that was weird :-/

[11:46] <nothingmuch> ntgrl: again, it's a cultural issue more than anything

[11:46] <nothingmuch> perl programmers are more important to Perl 6's design than ruby programmers

[11:46] <nothingmuch> in terms of "feeling at home"

[11:46] <lypanov> i can code both, well

[11:46] <ntgrl> maybe, but I can understand that you can slice an @ or a %, but you can't slice a $, so there's *two* categories there, not the three

[11:47] <lypanov> doesn't remove the fact that it is very difficult to change perl code when compared to changing ruby code

[11:47] <nothingmuch> the main diff is that arrays are ordered, hashes aren't 

[11:47] <nothingmuch> and that implies that some things make sense with one thing implicitly

[11:47] <nothingmuch> but have to be explicit otherwise

[11:47] <ntgrl> like?

[11:47] <lypanov> umm *thinks*

[11:48] <wolverian> refs can't be sliced? 

[11:48] <nothingmuch> (iteration, splicing, poping, pushing)

[11:48] <nothingmuch> refs can be sliced today

[11:48] <ntgrl> we cope with "key", "values" and "each" already

[11:48] <ntgrl> wolverian: well you're slicing the container pointed at by the ref...  but I'm needlessly pedantic

[11:48] <nothingmuch> ntgrl: it DWIMs in perl 6

[11:48] <lypanov> nothingmuch: okay. maybe the main reason for my hate is the difficult with finding a variables type, and added to that the insane syntax that is needed in many cases

[11:48] <nothingmuch> $array_ref[...];

[11:49] <lypanov> but it sure sounds like the syntax has been fixed

[11:49] <nothingmuch> define finding a variable's type

[11:49] <nothingmuch> the value class?

[11:49] <ntgrl> but it's still slicing the pointed at thing, not the scalar

[11:49] <nothingmuch> or the container implementation?

[11:50] <nothingmuch> ntgrl: true, sigils are not as neeeded in perl 6 as they were in perl 5

[11:50] <nothingmuch> due to more "automatic" behavior WRT reference

[11:50] <nothingmuch> auto dereferencing

[11:50] <nothingmuch> auto enreferencing

[11:50] <ntgrl> sure, but that doesn't change what's being sliced!

[11:50] <nothingmuch> but we still distinguish between list and scalar context

[11:50] <nothingmuch> and listy things are @ish

[11:51] <nothingmuch> and @ish things behave in a listy way

[11:51] <nothingmuch> like automatically concatenating

[11:51] <nothingmuch> etc

[11:51] <nothingmuch> again, this is more of a cultural issue

[11:51] <lypanov> i'll have to just try it, its all about feel

[11:51] <lypanov> if i dislike it i'll try and come up with tests and point out how it can be improved

[11:51] <nothingmuch> you can probably hack a weird glue layer over the grammar that makes any term an rvlaue

[11:51] <nothingmuch> not just sigiled stuff

[11:51] <nothingmuch> sure

[11:51] <nothingmuch> that's always welcome

[11:51] <lypanov> nothingmuch: i think its stupid so say "this is cultural issue"

[11:52] <lypanov> s/so/to/

[11:52] <nothingmuch> but since Perl 5 programmers feel at home with this, i doubt it's going to change a lot

[11:52] <lypanov> nothingmuch: you can surely make it less of a cultural issue and improve it for others

[11:52] <nothingmuch> well, show me how it isn't

[11:52] <nothingmuch> most of Perl 6's target audience irrationally thinks that sigils are important

[11:52] <lypanov> print Dumper in perl5 doesn't work generically

[11:52] <lypanov> nor does ref(blah) always work

[11:52] <nothingmuch> (just read all the crap P6 has been getting for changing -> to .

[11:53] <nothingmuch> the first should be fixable in perl 6

[11:53] <nothingmuch> the second will not

[11:53] <nothingmuch> because not everything is a ref

[11:53] <lypanov> there is thusly in some (read, many) cases when its simply impossible to find out how you are meant to use a methods returned value

[11:53] <lypanov> without good documentation (*cough*)

[11:53] <lypanov> or reading the entire damn source

[11:53] <nothingmuch> okay

[11:53] <lypanov> this is fixed somehow?

[11:53] <nothingmuch> you mean returning an array ref instead of a list for "performance" reasons?

[11:53] <lypanov> for example, yes

[11:53] <nothingmuch> okay

[11:54] <nothingmuch> that behaves better now

[11:54] <nothingmuch> because things coerce more nicely

[11:54] <nothingmuch> but frankly, i couldn't care less

[11:54] <nothingmuch> this is a low level issue

[11:54] <nothingmuch> the reason I want Perl 6 is because of high level things

[11:54] <nothingmuch> for example, all the idiots that diss python for using significant whitespace are just white noise to me

[11:55] <nothingmuch> it's just syntax

[11:55] <nothingmuch> if the semantics are good enough, than who cares

[11:55] <nothingmuch> (i like haskell, and it parses almost like python, but i wasn't very impressed with python... guess why?)

[11:55] <ntgrl> lack of overriding the whitespace convention?

[11:56] <nothingmuch> ?

[11:56] <nothingmuch> Perl 6's approach to this is: here's a default, the underlyingg API lets you change that

[11:56] <ntgrl> you can do: do { f; g } in haskell, so whitespace convention is entirely optional

[11:56] <nothingmuch> if you want 'use Syntax::Ruby' i don't think it'll mind

[11:56] <nothingmuch> not just for do

[11:56] <nothingmuch> also for where

[11:56] <nothingmuch> and let

[11:56] <nothingmuch> they have significant whitespace

[11:57] <azuroth> why weren't you impressed though, nm?

[11:57] <nothingmuch> and nobody uses do { f; g }, that's ugly ;-)

[11:57] <nothingmuch> because python has this sort of uninspiredness about it

[11:57] <ntgrl> sure, that's because it's defined as a single way to convert {;} <-> whitespace

[11:57] <nothingmuch> it is as simple as it can  ever be, and getting simpler

[11:57] <nothingmuch> read: dumber

[11:57] <azuroth> hmm. I think I feel the same way about PHP

[11:57] <azuroth> a similar way, at least

[11:57] <nothingmuch> there is lots of stuff to sto pthe user from being inspired

[11:57] <nothingmuch> php is an attrocity

[11:58] <nothingmuch> the only think i liked about php was that open returns a file handle, instead of accepting an uninitialized one as a param

[11:58] <nothingmuch> but now we have lexically scoped handles in perl 5 so it doesn't matter

[11:59] <nothingmuch> anyway, this discussion is really going nowhere

[11:59] <nothingmuch> bottom line is:

[11:59] <nothingmuch> sigils won't go

[11:59] <nothingmuch> it's not my fault

[12:00] <lypanov> not saying it is

[12:00] <gaal> I am! of course it's nothingmuch's fault

[12:00] <lypanov> just feel its very short sighted to not attempt to address these issues while "you" still can

[12:00] <lypanov> its audreyt's fault. as always ;)

[12:00] * lypanov no longer likes the direction ruby is heading in

[12:00] * lypanov is most impressed by perl6 and pypy

[12:00] * lypanov hates python

[12:01] <lypanov> so what is my option? ;)

[12:01] <lypanov> "fix" perl6...

[12:01] <nothingmuch> why don't you like it?

[12:01] <lypanov> perl6 or the direction of ruby?

[12:01] <nothingmuch> (ruby)

[12:01] <lypanov> ah

[12:01] <lypanov> there are a number of syntax changes that i dislike heavily, feel they are huge regressions

[12:01] <nothingmuch> like?

[12:02] <lypanov> nothingmuch: can't think of specifics, its a feeling

[12:02] <nothingmuch> syntax can be anything as long as it isn't taxing

[12:02] <nothingmuch> Perl 5's syntax for OO and FP is hard

[12:02] <lypanov> syntax effects me a lot, if it doesn't look pretty then i really don't want to work with it :)

[12:02] <nothingmuch> because it's easier to misbehave than to do the right thing

[12:02] <nothingmuch> okay

[12:02] <nothingmuch> let's try a few things in ext

[12:02] <lypanov> and python made me just want to cry

[12:02] <nothingmuch> i feel that most of the code i've written in Perl 6 is very beauutiful compared to what I can dish out in Perl 5

[12:03] <lypanov> (first time i had an indentation related bug i ran screaming)

[12:03] <nothingmuch> http://svn.openfoundry.org/pugs/ext/

[12:03] <lypanov> most of the code i've written in perl6 is cute

[12:03] <lypanov> s/writ/seen &/

[12:03] <nothingmuch> write some then =)

[12:03] <lypanov> waiting on the arrival of a new machine

[12:04] <nothingmuch> something that really made me happy was Class::Event

[12:04] <nothingmuch> and another thing that was very fun was Getopt::Process

[12:04] <nothingmuch> Perl 5 really lacked the umph to make these feel dense and meaningful

[12:05] <wolverian> Class::Event?

[12:05] <nothingmuch> oh! collect_arguments should be lexical to parse_arguments

[12:05] <nothingmuch> wolverian: yes

[12:05] <nothingmuch> it's not in ext

[12:06] <wolverian> ah.

[12:06] <nothingmuch> because it makes very very heavy use of roles and mmds

[12:06] <wolverian> is the module name in Getopt::Process a typo btw?

[12:06] <wolverian> (module Getopt::Proccesor)

[12:06] * wolverian imagines it could be a namespace clash too 

[12:06] <nothingmuch> yes, i think it is ;-)

[12:06] <nothingmuch> Migo wanted to rename it anyway

[12:06] <nothingmuch> to Getopt::Engine

[12:07] <svnbot6> r9236 | gaal++ |  r9257@sike:  roo | 2006-03-02 14:01:55 +0200

[12:07] <svnbot6> r9236 | gaal++ |  Minor edits to Peek talk. Online version updated.

[12:07] <nothingmuch> http://svn.openfoundry.org/pugs/ext/

[12:07] <nothingmuch> sorry

[12:07] <nothingmuch> damn clipboard

[12:07] <nothingmuch> http://svn.openfoundry.org/pugs/misc/Class-Events/lib/Class/Events.pm

[12:09] <wolverian> those are long lines

[12:09] <anatoly> ugh, I don't know :(

[12:09] <anatoly> looks too javaish to my taste

[12:09] <nothingmuch> anatoly: interfaces?

[12:09] <gaal> yo tolymoose

[12:09] <anatoly> interfaces and the general verbosity

[12:10] <anatoly> method get_subscriptions (Class::Events::Publisher $publisher, Class::Publisher::Event $event)

[12:10] <anatoly> this is not a line I will enjoy writing out

[12:10] <anatoly> perl5 almost never has lines I don't enjoy writing out

[12:10] <anatoly> yo gaal

[12:10] <anatoly> gaal: what time at your place saturday?

[12:10] <lumi> Yo gaal

[12:10] <nothingmuch> anatoly: err, you don't need to =)

[12:10] <nothingmuch> get_subscriptions( $thing, $event );

[12:11] <nothingmuch> but that's internal, isn't it?

[12:11] <nothingmuch> and interfaces suck

[12:11] <nothingmuch> roles are nice because they can actually contain behavior

[12:11] <anatoly> nothingmuch: what do you mean I don't need to? When I use the role? Sure, not the point though.

[12:12] <nothingmuch> oh, yhou mean how iwrote it?

[12:12] <nothingmuch> you can shorten the class names

[12:12] <nothingmuch> and you can not annotate the types if you don't want to

[12:12] <nothingmuch> but i have the über power of completion on my side

[12:12] <anatoly> by the way, if I'm in A::B::C::D, why do I have to write A::B::C::E and not some kind of ::..E or whatever?

[12:12] <nothingmuch> yes, there's something like that

[12:12] <nothingmuch> i just don't remember how to write that

[12:12] <anatoly> ah, ok :)

[12:13] <nothingmuch> also, please look at the code within

[12:13] <lumi> Package names are globally scoped, right?

[12:13] <nothingmuch> the idea of Class::Event's numerous roles is that you can milk performance but also get flexibility

[12:13] <lumi> Like Java and not like Python

[12:13] <nothingmuch> lumi: not necessarily

[12:13] <nothingmuch> you can have lexical ones too

[12:13] <nothingmuch> they default to global though

[12:14] <gaal> anatoly: not sure about time yet

[12:14] <gaal> there may be a jazz gig i want to go to afterwards :)

[12:15] <nothingmuch> gaal: which one?

[12:15] <gaal> Third World Love

[12:16] <anatoly> gaal: well moose me or something, I'm in Rishon over weekend.

[12:16] <gaal> great, will do

[12:16] <nothingmuch> when is it?

[12:17] <gaal> trying to check

[12:18] <gaal> hmm, 21:30 but it's w/o daniel friedman who I really like

[12:19] <nothingmuch> what date?

[12:19] <nothingmuch> saturday?

[12:19] <gaal> yeah. next thu, 9/3, he will be there.

[12:19] <gaal> http://www.hagada.org.il/hagada/html/modules.php?name=Content&pa=showpage&pid=7

[12:23] <nothingmuch> whatever happenned to luqui =(

[12:39] *** sisi joined
[12:50] <sisi> what else is new? :)

[12:52] *** Aragone is now known as Arathorn

[12:53] <sisi> . o O

[12:53] *** sisi left
[12:59] *** elmex joined
[13:00] <Arathorn> everything old is new again.

[13:07] * elmex is stitting on the GPW

[13:08] *** Draconi1 joined
[13:10] *** Draconi1 left
[13:10] *** Draconi1 joined
[13:10] *** nothingmuch joined
[13:10] <Juerd> ntgrl: Write your own grammar, that is sigilless. 

[13:11] <nothingmuch> no, just derive a grammar

[13:11] <nothingmuch> == less repeating yourself

[13:11] *** Draconi1 left
[13:11] *** sisi joined
[13:11] <integral> except that sigils are stored in the pads, so I have to magic them out of somewhere...

[13:11] <Juerd> ntgrl: This is a matter of changing the syntax for "my", and alike declaration keywords, and having them install lvalue subs.

[13:11] <Juerd> nothingmuch: Same difference.

[13:11] <nothingmuch> integral: what ntgrl wants is to have just scalars

[13:11] <sisi> Ah..."everything changed"

[13:11] <Juerd> sisi: No

[13:12] <integral> nothingmuch: sort of, More like bound values like in haskell really

[13:12] <integral> but maybe not *sigh* 

[13:12] <sisi> Juerd: oh? :)

[13:12] <integral> ntgrl ::= integral

[13:12] <Juerd> integral: Hey, don't fool us into thinking you're some kind of newbie ;)

[13:13] *** Draconit joined
[13:14] <elmex> is there a syntax freeze in perl6 ?

[13:14] <Juerd> No

[13:14] <sisi> "No means no"?

[13:14] *** fglock joined
[13:15] * Juerd sees audreyt read and edit a talk. Impressive, that speed of reading and typing.

[13:15] <elmex> when is a syntax freeze going to happen? when is the final perl6 interpreter going to be written?

[13:15] <Juerd> elmex: Probably not even then. Why do you ask?

[13:15] <nothingmuch> elmex: christmas

[13:15] <Juerd> elmex: Do you want a freeze?

[13:15] <lypanov> Juerd: have to admit i'd love to be there just to see that :)

[13:15] <Juerd> Someone's whistling here. Very annoying during a talk.

[13:16] <Juerd> lypanov: Why? Don't you think that if something isn't perfect, and someone has something *better*, we should use the better thing?

[13:16] <Juerd> lypanov: Don't you think that if ambiguous cases are found, clashing syntax is found, we should be able to fix the problem?

[13:16] <Juerd> I think a syntax freeze before the release is a bad idea.

[13:16] <Juerd> Eh, s/before/long before/

[13:17] <Juerd> rafl: Don't forget to diff the usb stick against your local old copy.

[13:17] <elmex> ok, then, when will there be a release of the final perl6 compiler (which targets parrot)?

[13:17] <lypanov> Juerd: sorry. "Juerd sees audreyt read and edit a talk. Impressive, that speed of reading and typing."

[13:17] <Juerd> elmex: Christmas

[13:17] <Juerd> lypanov: Ahhh, okay.

[13:17] <Juerd> lypanov: Sorry for my misinterpretation.

[13:17] <lypanov> i don't believe there is ever any such thing as  a "final interpreter"

[13:17] <lypanov> and nor do i believe in syntax freezes

[13:17] <lypanov> ;)

[13:18] <rafl> Juerd: I won't.

[13:18] <Juerd> elmex: Perl 5 has known a syntax freeze for very long; it hasn't benefitted from that.

[13:18] <Juerd> elmex: In fact, it pushed innovations like // far, far away.

[13:18] <Juerd> We still don't have it, while the feature itself has been wished for for over a decade.

[13:18] <Juerd> (Originally it was written "??", hookhook.)

[13:18] <lypanov> rationals or comments?

[13:19] <lypanov> oh. i have no idea then? :)

[13:19] <lypanov> i like the ?? !! syntax btw

[13:19] <Juerd> So do I.

[13:19] <elmex> ah, ok, so there will be finally the real perl6 interpreter.... why took it so long? :)

[13:19] <lypanov> elmex: its Hard (tm)

[13:19] <Juerd> elmex: It's hard to create something that hasn't existed ever before.

[13:20] <fglock> audreyt: re packing iterator_engine to CPAN: how about "Perl6::Grammar", and reuse Parse::RecDescent API?

[13:20] <elmex> yes, it is, i agree. but that doesn't explain why the interpreter hasn't been started earlier 

[13:20] <Juerd> elmex: There is no programming language that has all these new features

[13:20] <elmex> Juerd: perl5 has at least a part of it

[13:21] <Juerd> elmex: Yes, but we're not trying to re-create Perl 5. Perl 5 already exists, it doesn't need to be created.

[13:22] <lypanov> and its not possible to easily add to perl5

[13:22] <Juerd> elmex: Perl 5 has many neat features, but Perl 6 has more. They cannot be integrated into Perl 5, because Perl 5 is very hard to maintain because (lack of) its internal structure.

[13:22] <elmex> yes... Perl6 isn't Perl anymore

[13:22] <rgs> and backward compatibility constraints

[13:23] <Juerd> Also, for a better Perl, we need *fundamental* changes in syntax.

[13:23] <lypanov> perl sucks. yay for perl6! :P

[13:23] <elmex> yes, maybe

[13:23] <Juerd> elmex: It depends on your definition of Perl. It still looks and feels like Perl.

[13:23] <Juerd> elmex: Do you think that Larry Wall's view on the definition of Perl isn't authoritive?

[13:23] <elmex> Juerd: yes, but it is not the successor of Perl5

[13:23] <rgs> some would say it even smells like perl.

[13:23] <Juerd> He thinks the definition *includes* Perl 6.

[13:23] <elmex> Juerd: no, i don't think that larrys view is the end of all wisdom

[13:23] <Juerd> rgs: Mind if I quote you on that in my lightening talk? :)

[13:23] <rgs> heh

[13:24] <nothingmuch> elmex: look at my compiling perl 6 ttalk

[13:24] <Juerd> elmex: But he created both Perl 5 and 6. 

[13:24] <rgs> and the previous ones too.

[13:24] <lypanov> and patch!

[13:24] <elmex> Juerd: Perl6 was created by the comunity

[13:24] <lypanov> elmex: perl6 was defined by larry

[13:24] <nothingmuch> http://nothingmuch.woobling.org/perl6_comp/slides/start.html

[13:24] <nothingmuch> note that images willl load very slowly

[13:24] <lypanov> and implemented / refined by the community

[13:24] <nothingmuch> and only then will S5 kick in

[13:24] <Juerd> elmex: Nah, the community will *write* it :)

[13:24] <elmex> lypanov: there were RFC's

[13:24] <Juerd> elmex: Larry is this ship's captain

[13:25] <elmex> Juerd: the ship is traveling very long now....

[13:25] <svnbot6> r9237 | fglock++ | iterator_engine - added a talk sketch

[13:25] <nothingmuch> elmex: don't take it as "larry is not open to suggestions"

[13:25] <Juerd> elmex: Indeed.

[13:25] <nothingmuch> in fact, i wasted about 4-5 hours of larry's time just in the OSDC/Hackathon

[13:26] <nothingmuch> he is a very good listener

[13:26] <lypanov> elmex: /win 5

[13:26] <elmex> thats great

[13:26] <Juerd> elmex: However, I think it's good to wait and get something that resembles perfection, instead of rushing things and getting something as horrible as the unreadable as Perl 5's source.

[13:26] <lypanov> doh

[13:26] * lypanov kicks irssi

[13:26] <lypanov> elmex: sorry. ignore that :)

[13:26] <lypanov> Juerd: i disagree for what its worth

[13:26] <Juerd> elmex: It has taken years, and perhaps it will take a few more.

[13:27] <nothingmuch> lypanov: you can use esc/meta

[13:27] * sisi thinks: marriages don't break up on account of infidelity. *^.^*

[13:27] <Juerd> elmex: In the meantime, we have Perl 5.

[13:27] <Juerd> lypanov: Elaborate 

[13:27] <lypanov> nothingmuch: oh. esc-1 etc is a wonderful idea

[13:27] <elmex> Juerd: i've been waiting since 2002, and there is no real spec yet. the synopsis are imho very incomplete and many things are only documented on the mailing list

[13:27] <lypanov> nothingmuch: thanks :)

[13:27] *** sisi left
[13:27] <lypanov> elmex: the spec == the test cases

[13:27] <elmex> Juerd: yes, but Perl6 does block improvements in Perl5 imho

[13:27] <Juerd> elmex: Audrey et all are working on that. Don't expect things to change extremely quickly.

[13:28] <nothingmuch> elmex: well, we're not going to scrap it

[13:28] <elmex> lypanov: great, so i have to crawl through thousand lines of test-code to learn perl6 ?

[13:28] <nothingmuch> this is a volunteer thing

[13:28] <Juerd> elmex: Different people work on Pelr 5.

[13:28] <nothingmuch> nobody tells anyone to work on this and not that

[13:28] <nothingmuch> or vice versa

[13:28] <lypanov> elmex: you learn from a spec?!

[13:28] <Juerd> elmex: Perl 6 doesn't block Perl 5 development, it actually improves it at times.

[13:28] <rgs> right !

[13:28] <Juerd> Perl 5 learns from Perl 6, and gets some of its features.

[13:28] <rgs> like //, switch, ~~, say

[13:28] <elmex> lypanov: yes, partially. i learn mainly from having an interpreter and then i look at the spec and try out

[13:28] <lypanov> elmex: pugs runs now

[13:29] <nothingmuch> // is lovely

[13:29] <elmex> ok

[13:29] <lypanov> ?eval 5

[13:29] <evalbot_9236> 5 

[13:29] <lypanov> elmex: ^^ see? :P

[13:30] <elmex> perl -e 'print 5'

[13:30] <elmex> # 5

[13:30] <elmex> lypanov: see? :)

[13:30] <lypanov> no... not really

[13:30] <elmex> lypanov: yes, me too

[13:30] <lypanov> elmex: pugs (one impl of perl6), runs now

[13:30] <lypanov> elmex: and there is a partial constantly updating spec. and testcases

[13:31] <lypanov> i also have to admit i'd like a more compact version of the spec

[13:31] <lypanov> is one available?

[13:31] <nothingmuch> test cases, interpreter, and spec are all complements to each other

[13:31] <nothingmuch> none can be good without the other

[13:31] <lypanov> the current stuff is verrrry verbose

[13:31] * lypanov doesn't really like reading

[13:31] <nothingmuch> lypanov: there's a quick ref

[13:31] <lypanov> nothingmuch: ah. neat. uri?

[13:31] <azuroth> am I horribly mistaken in thinking fixity is somehow a synonym for associativity?

[13:31] <lypanov> or in docs/ ?

[13:31] <nothingmuch> lypanov: in docs or something

[13:32] <lypanov> nothingmuch: thx. shall check it out

[13:32] <nothingmuch> azuroth: fixity is how manny, where

[13:32] <nothingmuch> like, postfix is 'after'

[13:32] <nothingmuch> it's always after "one thing"

[13:32] <nothingmuch> as with prefix

[13:32] <azuroth> ahh, right

[13:32] <nothingmuch> circumfix is around any number

[13:32] <nothingmuch> infix is between two things

[13:32] <nothingmuch> postcircumfix is after, and then around some more stuff

[13:32] <lypanov> fixity == arity + associativity?

[13:32] <azuroth> damn. is there a short word for assoc?

[13:32] <nothingmuch> like [ ] is after @array and around the slice

[13:33] <nothingmuch> lypanov: you could say that, yes

[13:33] <lypanov> azuroth: assoc? :P

[13:33] <nothingmuch> ass

[13:33] <azuroth> uglyyy :-P

[13:33] <lypanov> hehe

[13:33] <lypanov> ummmm ass

[13:35] *** Nouk joined
[13:35] <elmex> it's just scary that Perl5 grow from a evolutionary process out of perl1 to perl4 and was mainly done by Larry. Perl6 seems to throw away most things from Perl5 and introduce very many new untested concepts in a very short time and throws away the old codebase

[13:36] <rgs> nope, it doesn't

[13:36] <Juerd> rgs: How does one pronounce your name?

[13:36] <lypanov> elmex: its not a bad thing go occasionally throw away the codebase...

[13:36] <rgs> translators will happen !

[13:36] <rgs> Juerd: I don't know. Spanishish ?

[13:37] <Arathorn> elmex: sounds exciting rather than scary to me :)

[13:37] <Juerd> rgs: I can't guess the last part, Suarez

[13:37] <rgs> Juerd: "aar - gee - ess" ?

[13:37] <Juerd> Does that sound like swahres?

[13:37] <rgs> Juerd: soo a ress

[13:37] <Juerd> Ah, thank you

[13:37] <rgs> yes

[13:38] <azuroth> spanishish... sounds an interesting - oil of spaniards?

[13:38] *** kolibrie joined
[13:38] <Juerd> elmex: What do you mean "untested"?

[13:38] <rgs> even *I* pronounce my name differently depending on contexts

[13:38] <elmex> imho the perl5 people should improve  the old perl5 interpreter a little bit more and just bump the version to perl6

[13:38] <Juerd> elmex: Larry *is* actively improving (refactoring) Perl 5!

[13:38] <Juerd> elmex: Nicholas Clark will integrate his changes back into the main Perl 5.

[13:39] <Juerd> elmex: This all helps migration to Perl 6.

[13:39] <elmex> Juerd: many concepts were invented before there was Pugs and some concepts aren't implemented yet

[13:39] <Juerd> elmex: Indeed.

[13:39] <Juerd> elmex: Your point, please?

[13:39] <elmex> Juerd: good question

[13:39] <Juerd> Also, isn't every invention at first untested?

[13:39] <rgs> aren't the specs written before the implementation ? :)

[13:39] <lypanov> Juerd: i think the point is depth vs breadth wise implementation

[13:40] <Juerd> Like, ehm, pseudohashes? Restricted hashes? Formats? All those other things we don't use, but are implemented in Perl 5?

[13:40] <lypanov> Juerd: and afaic there is slightly too much depth in perl6

[13:40] <lypanov> s/ic/ics/

[13:40] <elmex> yes, but wouldn't it be better if all these new concepts were integrated in perl5 from the beginning? then they could've been tested when they came up

[13:40] <Juerd> elmex: It's hard for me to understand what you want. A few moments ago, you complained that there was no complete specification, but now you say things should be tested first.

[13:40] <rgs> no, because perl 5 needs to be mostly backwards compatible

[13:40] <Juerd> elmex: Can you explain how these go together?

[13:41] <lypanov> elmex: perl5 is very difficult to extend

[13:41] <Juerd> lypanov: There might be. The Plan is to do it Right.

[13:41] <lypanov> elmex: if what you did was the case, it would take /even longer/

[13:41] <lypanov> s/did/said/

[13:41] <Juerd> (See how the uppercase words make things really cute in English, while they just don't even look weird in German? :))

[13:41] <lypanov> Juerd: hehe

[13:42] <elmex> lypanov: i don't think it would have taken 6 years to have // in perl5 or a 'class' keyword...

[13:42] <lypanov> elmex: the perl6 spec is a lot more than jusrt that

[13:42] <lypanov> s/rt/t/

[13:42] <rgs>  // is in perl 5 right now

[13:42] <Juerd> Because they capitalize every Noun, you cannot use uppercase Letters to indicate something that is cutely official.

[13:42] <elmex> lypanov: yes, the perl6 spec is a big blob

[13:42] <Juerd> elmex: You don't NEED those in Perl 5.

[13:43] <elmex> rgs: yes, after 6 years

[13:43] <lypanov> when did pugs start?

[13:43] * lypanov is sure it wasn't six years ago

[13:43] <rgs> one year ago

[13:43] <Juerd> elmex: Why write "class Foo { }" instead of "{ package Foo; }" if they mean exactly the same thing?

[13:43] <Juerd> The point is that it does something *different* in Perl 6.

[13:43] * lypanov doesn't really care about parrot all that much as he deems it doomed

[13:43] <Juerd> lypanov: One year and one month ago.

[13:43] <lypanov> right

[13:44] <lypanov> its come very far

[13:44] * rgs jumps off the troll train

[13:44] <lypanov> good idea

[13:44] <lypanov> bbl

[13:44] <elmex> maybe the only thing that bugs me is that Perl6 is not Perl5+1

[13:45] <lypanov> everyone hates change, but its pretty much inevitable

[13:45] * lypanov personally hates lack of change

[13:45] <azuroth> parrot is doomed?

[13:45] <lypanov> azuroth: yeah

[13:45] <elmex> i don't hate change. perl6 has many great features.

[13:45] <nothingmuch> parrot has had lots of management issues

[13:45] <nothingmuch> and I think parrot has been prematurely optimized in ways that are not generally useful enough

[13:45] <azuroth> hmm, ok

[13:45] <nothingmuch> but that doesn't mean it's doomed

[13:46] <nothingmuch> people are still participating and helping

[13:46] * nothingmuch is not so quick to mark it off as a dead thing

[13:46] <rgs> it's merely resting !!

[13:46] <lypanov> nothingmuch: its slow. and pretty much pointless

[13:46] <azuroth> :-)

[13:47] <nothingmuch> rgs: when *I* made that joke i was beaten up

[13:47] *** haggai_e joined
[13:47] * rgs runs and hides

[13:47] <lypanov> ;)

[13:47] <nothingmuch> rgs: you're supposed to give lypanov a voucher for your brother's fish store instead

[13:48] <nothingmuch> and instead of running off and hiding, running off to become a lumberjack

[13:48] <lumi> Pet store, surely?

[13:48] *** haggai_e left
[13:48] *** haggai_e joined
[13:48] <nothingmuch> i thiink it was more specialized but can't remember.... googling

[13:48] <lypanov> que? :P

[13:48] <lumi> His brother's pet store in Bolton

[13:49] <nothingmuch> ah

[13:49] <nothingmuch> lypanov: http://www.mtholyoke.edu/~ebarnes/python/dead-parrot.htm

[13:49] <lypanov> ummm

[13:49] * lypanov sucks at quotes

[13:49] <gaal> lypanov: I wouldn't say it's slow:

[13:49] <gaal> # http://www.nntp.perl.org/group/perl.perl6.internals/32958

[13:49] <lypanov> lumi: second you said "bolton" i knew something was going on ;)

[13:50] <lypanov> gaal: ackermans makes no difference in the real world

[13:50] <lypanov> gaal: real world optimisations == high level things such as malloc coaslescing

[13:50] <lypanov> gaal: sorry but parrot is just bullshit

[13:51] <lypanov> i agree entirely with nothingmuch in "in ways that are not generally useful enough"

[13:51] <lypanov> and yes. its true, i can not spell coacleslssing

[13:51] <Juerd> Hm, would it be safe to mention that I put my talk in the Pugs repository? ;)

[13:51] * lypanov flames Juerd

[13:51] <Juerd> (It might be construed as "If you really don't like my talk, go ahead, and change it")

[13:51] <nothingmuch> lypanov: did yyou see the perl 6 compilation talk?

[13:51] <Juerd> Ah well. We'll see.

[13:52] <nothingmuch> i'm very very concerned with Perl 6 being fast

[13:52] <nothingmuch> and most of the ways I want to make sure it's fast have nothing to do with parrot

[13:52] <lypanov> nothingmuch: no. any urls?

[13:52] <nothingmuch> http://nothingmuch.woobling.org/perl6_comp/slides/start.html

[13:52] <nothingmuch> images will load slowly

[13:52] * lypanov reads

[13:52] <nothingmuch> but when they're done S5 will kick in

[13:52] <lypanov> k

[13:53] <lypanov> ummmfunkycheese

[13:53] <elmex> yaho, audrey is having her talk now

[13:54] <Juerd> Visual Basic Rocks.

[13:54] <elmex> yes

[13:54] <azuroth> for real?

[13:54] <Juerd> gwbasic++

[13:54] <Juerd> :)

[13:54] <lypanov> lol

[13:54] <Juerd> # Audrey

[13:54] <Juerd> # Larry

[13:54] <Juerd> # me

[13:55] <rafl> # me

[13:55] <Juerd> gwbasic++ then

[13:55] <elmex> elmex--

[13:55] <Juerd> # toothpaste

[13:55] <lypanov> Juerd: how come? ;)

[13:55] <anatoly> gwbasic doesn't really ++

[13:55] <lypanov> s5 kicked in! yay!

[13:55] <anatoly> but audrey's talk is cute

[13:56] <elmex> VB was one of my first languages too

[13:56] <nothingmuch> anatoly: but it seems that vb 9 *does* rock ;-)

[13:57] <anatoly> nothingmuch: in a funny way, yes

[13:57] * Arathorn wonders if audrey's trying to get hired by M$ ;)

[13:58] <anatoly> vb is one of those languages which either "no one uses" or "everyone uses" depending on your perspective

[13:58] <Juerd> She already is

[13:58] <Juerd> ;)

[13:58] <Arathorn> ah, that makes more sense, then :)

[13:58] <Juerd> Not really

[13:58] <Juerd> But there is another Audrey Tang who is.

[13:58] <anatoly> but then again, so is perl, so we shouldn't be snobbish about vb, I guess.

[13:59] <Juerd> http://pugs.blogs.com/audrey/2005/12/the_other_audre.html

[13:59] <lypanov> umm

[13:59] <lypanov> nothingmuch: s5 is lame

[13:59] <nothingmuch> lypanov: i can generate plain spork

[13:59] <nothingmuch> i just like working with it better since it's one file instead of N per slide

[14:00] <nothingmuch> ughhhhhhhhhhhhhhhhhhhhh

[14:00] <Juerd> audreyt++  # Good speaker

[14:00] <nothingmuch> there's a "python rocks, perl sucks, you shouldn't make perl 6 it hurts perl 5" thread on the OSDC list

[14:01] <nothingmuch> why do people go that way so easily?

[14:01] <nothingmuch> what point are they fucking trying to prove?

[14:01] <nothingmuch> it's so pathetic

[14:01] <webmind> nothingmuch, url? :)

[14:01] <nothingmuch> webmind: for what?

[14:01] <webmind> of the archive?

[14:01] <nothingmuch> ah

[14:01] <nothingmuch> err

[14:01] <nothingmuch> it's not worth it

[14:01] <elmex> elmex--

[14:01] <nothingmuch> you can google if you like

[14:01] <webmind> ok 

[14:01] <nothingmuch> osdc-discuss is the list

[14:01] <lumi> elmex: Keep that up, there'll be nothing left of you

[14:02] <nothingmuch> the thread is a subthread of "feedbacks from the conference"

[14:02] <webmind> ok, thanks :)

[14:02] <anatoly> nothingmuch: i can't believe you put ninjas and pirates in your talk

[14:02] <nothingmuch> starting with a reply by Roman Yakovenko to Dov Levenglick

[14:02] <nothingmuch> anatoly: =D

[14:02] <webmind> something to fight the boredom ;)

[14:02] <anatoly> nothingmuch: you're a psycho! but ++ :)

[14:03] <lypanov> nothingmuch: anything but this. is it xul or something?

[14:03] <svnbot6> r9238 | juerd++ | Some more slides

[14:03] <nothingmuch> lypanov: javascript + css

[14:04] <nothingmuch> i'll make it plain html

[14:04] <lypanov> nothingmuch: either firefox or s5 is damn lame

[14:04] <lypanov> nothingmuch: it keeps on reverting to unstyled when i open a new tab

[14:04] <nothingmuch> uh

[14:04] <nothingmuch> odd

[14:04] <nothingmuch> complain to eric s. raymond, he wrote the damn thing

[14:04] <lypanov> lol

[14:04] <lypanov> i just pressed a link

[14:04] <anatoly> haha

[14:04] <nothingmuch> i must admit i don't optimize for portability when doing that stuff

[14:04] <lypanov> and ... dum dum dum. firefox crashed

[14:04] <anatoly> that explains a few things

[14:05] <anatoly> what's the thing that audreyt uses for her talks? use that :) it's also one file

[14:05] <gaal> anatoly: nothingmuch is a DrMcNinja really

[14:05] <lypanov> anatoly: only works on firefox. also lame

[14:05] <nothingmuch> anatoly: takahashi xul

[14:05] <anatoly> lypanov: is not lame

[14:06] <lypanov> anatoly: if it runs only on firefox its lame

[14:06] <lypanov> nothingmuch: yeah... i could really do with the html version

[14:06] <lypanov> nothingmuch: ff just died again

[14:06] <anatoly> lypanov: anything that lets you write the talk as one text file so easily and fast rocks. bah about firefox, it's for displaying at the conference, who cares.

[14:06] <lypanov> anatoly: then don't public the damn things on a public site...

[14:06] <nothingmuch> haha

[14:07] <lypanov> and why not use powerpoint?

[14:07] <lypanov> its /more/ accesible than this shit

[14:07] <nothingmuch> i don't have ppt

[14:07] <lypanov> sorry. but meh

[14:07] <nothingmuch> and s5 is accessible for *me*

[14:07] <anatoly> lypanov: because powerpoint blows

[14:07] <nothingmuch> again, i was not optimizing for portability

[14:07] <nothingmuch> but i *can*

[14:07] <nothingmuch> give me 2 mins

[14:07] <anatoly> lypanov: powerpoint eats your brain

[14:07] <lypanov> nothingmuch: was just bitching at anatoly not you, sorry

[14:08] <lypanov> anatoly: then buy a mac and use keynote :)

[14:08] <anatoly> lypanov: you have ff already. it crashes at nm's spork but won't at audreyt's takahashi, so what's your problem? :)

[14:08] <lypanov> anatoly: i don't have ff on my osx box

[14:08] <nothingmuch> lypanov: actually, not spork

[14:08] <nothingmuch> s5

[14:08] <nothingmuch> spork is just kwid -> slides

[14:08] <nothingmuch> and it defaults to plain html

[14:08] <nothingmuch> well, kwiki

[14:09] <nothingmuch> but we use spork::formatter::kwid nowadays

[14:09] <lypanov> so many funny cute names!

[14:09] <nothingmuch> okay

[14:09] <nothingmuch> yeah, that's ingy for you

[14:09] <nothingmuch> http://nothingmuch.woobling.org/perl6_comp/slides/

[14:09] <nothingmuch> reload that

[14:09] <nothingmuch> it's in hotpink

[14:09] <nothingmuch> because that's the default

[14:09] <nothingmuch> ;-)

[14:09] <lypanov> yay hot pink!

[14:10] <nothingmuch> gaal has a nice scheme for plain spork, but i don't know it

[14:10] <gaal> quite simple really

[14:10] <nothingmuch> also, wrt ff/s5 borkedage - it's known

[14:10] <nothingmuch> that's why my darcs talk sucked

[14:10] <nothingmuch> because i had to use ff unexpectedly

[14:10] <nothingmuch> but it didn't crash, it was just very slow

[14:10] <lypanov> same thing :)

[14:11] <lypanov> when i can read 10x faster than my computer can display. i begin to worry ;)

[14:11] <nothingmuch> the old html is in s5.html

[14:11] <gaal> for reference:

[14:11] <nothingmuch> hehe

[14:11] <gaal> banner_bgcolor: lightblue

[14:11] <nothingmuch> i use it in safari and it works very well

[14:11] <lypanov> okay

[14:11] <nothingmuch> so there

[14:11] <nothingmuch> =)

[14:11] <lypanov> *opens his mac up*

[14:11] <nothingmuch> no need

[14:11] <nothingmuch> s5 is no longer the default for that URL

[14:12] <lypanov> i just got s5 again, maybe cached

[14:12] <nothingmuch>  think i'll delete index.html

[14:12] <nothingmuch> there is start.html which is plain spork

[14:12] <nothingmuch> and s5.html which is s5

[14:12] <lypanov> nothingmuch: thx. works absolutely perfectly in safari

[14:13] <nothingmuch> =)

[14:13] <nothingmuch> again, i'm optimizing for my comfort as I give the talk

[14:13] <nothingmuch> and write it

[14:13] * lypanov nods

[14:13] <azuroth> nothingmuch++ # like the slides

[14:13] <nothingmuch> if we could have Spork::Keynote i'd be even happier

[14:13] <nothingmuch> because Keynote has mad-presenter-skill-toolz

[14:13] <nothingmuch> like a timer, and the next slide, and whatnot

[14:13] <nothingmuch> but i don't work well with graphical tools for this stuff

[14:14] <nothingmuch> just for real graphics

[14:14] *** haggai_e left
[14:14] *** feng123 joined
[14:17] <fglock> can I use 'return' inside a BEGIN block?

[14:17] <nothingmuch> fglock: you should be able to, yes

[14:18] <nothingmuch> when a begin block is used in rvalue context then it's return value is serialized and reused as a constant

[14:18] <nothingmuch> e.g. 'print BEGIN { localtime }'

[14:18] <nothingmuch> although, wait

[14:18] <nothingmuch> return might not work

[14:18] <nothingmuch> because BEGIN isn't a sub

[14:18] <nothingmuch> but i guess that ought to be fixed?

[14:18] <fglock> nothingmuch: I read it is a sub

[14:18] <nothingmuch> since there is no other possible use for return at begin time, not in a macro?

[14:19] <fglock> nothingmuch: I need to eval a string that has a BEGIN block, and I don't want BEGIN to be executed twice

[14:19] <nothingmuch> oh wait, is this perl 5 or perl 6?

[14:20] *** Draconit joined
[14:20] <fglock> it's p6 compiled to p5, so it's p5

[14:20] *** Draconit left
[14:20] <nothingmuch> ah

[14:20] <fglock> I need to evaluate a BEGIN block during parse, and then again when executing

[14:20] <nothingmuch> in that case I don't think that's specccced

[14:22] <fglock> nothingmuch: it works:

[14:22] <fglock> perl -e ' BEGIN { print "begin\n"; return; print "not\n"; } '

[14:22] <nothingmuch> yay!

[14:23] *** Draconit joined
[14:23] * Juerd just had his lightening talk

[14:24] <Juerd> And I invited people to come here (just in case there's a big stampede... ;))

[14:24] <nothingmuch> yay

[14:24] <nothingmuch> we need to have a lightning talk about TTH btw

[14:25] <nothingmuch> welcome back, Draconit 

[14:25] <Juerd> What exactly is TTH?

[14:25] <integral> that'd be why it needs a lightning talk :-P

[14:25] <Juerd> :)

[14:26] <Juerd> So what is it?

[14:26] <Juerd> Heh, rafl just asked me "What's TTH" :)

[14:26] <Juerd> So now two people want to know :)

[14:27] <nothingmuch> Test::TAP::Harness

[14:27] <Juerd> Ah

[14:27] <nothingmuch> basically say:

[14:27] <nothingmuch> hi, i'm X

[14:27] <Juerd> Different from T::H?

[14:27] <nothingmuch> at pugs we have many many unit tests

[14:27] <nothingmuch> sorry

[14:27] <nothingmuch> Test::TAP::HTMLMatrix

[14:27] <Juerd> Ahh

[14:27] <nothingmuch> i always confuse the name

[14:27] <nothingmuch> find t/

[14:27] <nothingmuch> find t/ | wc -l

[14:27] <Juerd> Right.

[14:27] <nothingmuch> then say:

[14:27] <nothingmuch> so we wrote an HTML visualizer

[14:27] <nothingmuch> show the lovely output

[14:28] <Juerd> I actually did a count yesterday, 35000+ (see my lightening talk, p6myths2.html)

[14:28] <nothingmuch> and have another 2 mins about how to actually run it

[14:28] <Juerd> Right

[14:28] *** wilx`` is now known as wilx

[14:28] <Juerd> Get over here, and have it :)

[14:29] *** samuel joined
[14:33] <gaal> nothingmuch: I think TimToady just mentioned BEGIN was, in fact, a sub on p6-l just the other day

[14:33] <gaal> or here, or somewhere

[14:34] <Draconit> הי לא חשבתי שמישהו בכלל הבחין שנכנסתי לפה

[14:35] <nothingmuch> yay

[14:35] <Draconit> sorry dont know how to say that in english

[14:35] <nothingmuch> Draconit: well, we are very sensitive people

[14:35] <nothingmuch> and we get a little line saying 'Draconit ..... has joined #perl6' whenever you joined

[14:35] <gaal> Juerd: there are another 8-odd k in ext/

[14:35] <Draconit> yes, and clorfall too!

[14:36] <Draconit> sorry for my spelling..

[14:41] *** nnunley joined
[14:45] *** fglock left
[14:46] <kolibrie> I did not see TimToady in AUTHORS.  Who is he?

[14:47] <integral> you've never met him on perlmonks?

[14:47] <gaal> he's someone who puts moose in his talks. gotta love him!

[14:47] * kolibrie has never been to perlmonks

[14:48] <azuroth> I've heard he can write an IRC client in less than ten characters

[14:48] <gaal> kolibrie: look at all his replies here: http://perlmonks.org/?node=perl+oddities&go_button=Search

[14:49] <GeJ> cat /dev/urandom | perl  <-- more than 10 characters

[14:50] <gaal> useless use of cat!

[14:51] <Juerd> rafl: Hm

[14:51] <GeJ> yes... realized that just after typing <Enter>

[14:53] <kolibrie> gaal: I still haven't solved the riddle

[14:54] * Arathorn blames CPM

[14:54] <Arathorn> where you had to TYPE FOO.DOC | MORE to paginate it

[14:54] <Arathorn> iirc

[14:54] <Arathorn> hence not useless abuse of s/cat/type/

[14:54] * Arathorn mumbles

[14:55] <Arathorn> kolibrie: if you want the riddle spoilt: http://pugs.blogs.com/pugs/2006/02/hackathonil_12_.html

[14:55] <kolibrie> gaal: by the way, I got a little 'hello world' parsec parser working, but don't think I quite understand the AST definition syntax

[14:56] <kolibrie> Arathorn: thanks

[14:57] * kolibrie almost wanted to guess that, but knowledge generally serves me better than my guesses

[14:57] <gaal> kolibrie: ooh I need to thank you again BTW because a lot of what we talked about made it into my talk

[14:58] <kolibrie> gaal: you're welcome - it was mutually beneficial

[14:59] *** Draconi1 joined
[14:59] <kolibrie> gaal: do you have time a little later today to help me comprehend a little more?

[14:59] <gaal> ignoring what AST means for a moment, look at: http://perlcabal.org/~gaal/peek/slide17b.html#end

[14:59] <gaal> how about now? :)

[14:59] <gaal> and http://perlcabal.org/~gaal/peek/slide19.html

[15:00] <kolibrie> gaal: have a half hour meeting starting seconds ago

[15:00] <kolibrie> but after that is fine

[15:00] <gaal> ok

[15:02] *** Draconit_ joined
[15:03] <Draconit_> i hate gaim

[15:03] <Draconit_> it is evil

[15:03] <Draconit_> when u r not a geek

[15:04] <anatoly> don't use gaim for irc

[15:04] <anatoly> it's ok for im i think

[15:04] <azuroth> I don't particularly mind it for IRC..

[15:04] <lypanov> colloquy!!!!

[15:04] <Draconit_> it has mood swings

[15:05] <lumi> Sadly, there's no Colloquy or Adium for [wl]in

[15:05] <Draconit_> whats colloquy?

[15:06] <azuroth> not for win or lin? what is it on, then?

[15:06] <lumi> Mac OS X

[15:06] <lumi> Which is a BSD, of course

[15:06] <azuroth> oh, heh, whoops

[15:06] <integral> irssi is pretty standard for *nix

[15:06] * lypanov admits to being in irssi right now

[15:07] <lumi> aol

[15:08] <integral> gaal: you've got a missing return on slide23a before the Syn

[15:09] <gaal> integral: nope, look at the soource

[15:10] <gaal> oh wait no

[15:10] <gaal> you're right

[15:10] <gaal> nice catch :)

[15:10] <integral> np

[15:11] <gaal> that's what I get for rhetorical simplifications (it uses a trivial helper retSyn in the real source)

[15:12] <integral> I wish the source wouldn't use things like retSyn sometimes.  With return $ Syn, everybody knows what return does

[15:12] <gaal> it is kind of a trivial function, yes

[15:14] <gaal> anyone know what might start making vim look for X all the time? it used to work fine, but now I always need to vim -X to avoid sloooow loads

[15:14] <gaal> fixed

[15:15] <svnbot6> r9239 | gaal++ |  r9261@sike:  roo | 2006-03-02 17:11:16 +0200

[15:15] <svnbot6> r9239 | gaal++ |  * fix a missing `return`. Reported by integral++.

[15:15] <Juerd> rafl: http://jitcrunch.cafepress.com/jitcrunch.aspx?bG9hZD1ibGFuayxibGFuazoxNTJfRi5qcGd8bG9hZD1MMCxodHRwOi8vem9vbS5jYWZlcHJlc3MuY29tLzgvOTU5NjcwOF96b29tLnBuZ3x8c2NhbGU9TDAsMTgwLDM2LFRyYW5zcGFyZW50fGxvYWQ9dG0tTDAsYmxhbms6MTUyX0ZfdG1hc2suanBnfGNvbXBvc2U9TDAsdG0tTDAsVGV4dHVyZU1hc2ssLTE1MSwtMTA1fGNvbXBvc2U9YmxhbmssTDAsQWxwaGFCbGVuZCwxNTEsMTA1fGNwPXJlc3VsdCxibGFua3xzY2FsZT1yZXN1bHQsMCw0ODAsV2hpdGV8bG9hZD1zYW1wbGUsaHR0cDovL3d3dy5jYWZlcHJlc3MuY29tL2NvbnRlbnQvZ2xvYm

[15:15] <gaal> yikes

[15:15] <Juerd> ;)

[15:15] <Juerd> http://xrl.us/j9rm

[15:16] <rafl> Juerd: It incomplete

[15:16] <Juerd> Your sentence also incomplete, it verbless.

[15:27] <Juerd> (Hi, Leo :P)

[15:28] <Juerd> :)

[15:28] <LeTo> *g*

[15:30] <Juerd> rafl: gather { ...; take $something; ... }

[15:30] <Juerd> Where $something is in list context

[15:30] <azuroth> gee. he does seem to have broken english. I'd never really noticed, or it's just worse than usual

[15:31] <Juerd> @foo = gather { for @numbers { take $_ + rand() } };

[15:31] <Juerd> azuroth: Who be he?

[15:31] <azuroth> err, doesn't matter :-)

[15:32] <Juerd> I'm sure it doesn't, but I want to know ;)

[15:34] <azuroth> when you said "hi, leo" up there I thought you were referring to leopold, so I backlogged #parrot and noticed he was talking noticably foreign-english

[15:34] <svnbot6> r9240 | bsmith++ | Factored out the localisation of the environment from ruleBlockBody.

[15:34] <Odin-> Juerd: You want to end like the cat?

[15:34] *** bd_ joined
[15:36] <Juerd> Odin-: ...cat? :)

[15:36] <Juerd> azuroth: I see :)

[15:37] <Odin-> Juerd: Yeah, the one that got killed by curiousity. :)

[15:37] *** justatheory joined
[15:37] <rafl> Juerd: That was caused by the us_intl layout.

[15:37] <Juerd> Odin-: I'm not curious, I just want to know everything.

[15:37] <Juerd> rafl: You and your silly umlauts

[15:37] <Juerd> Sorry, *U*mlauts.

[15:37] <Odin-> Juerd: I think one is the definition of the other... :p

[15:37] <Juerd> Odin-: Nahhh

[15:37] <Odin-> ümläüts! :p

[15:38] <Juerd> ?ml??ts?

[15:38] <rafl> Juerd: They are nice to have in german presentations.

[15:38] <Juerd> ümläs

[15:38] <Juerd> Hm

[15:38] <Juerd> rafl: Disagreed.

[15:38] <kolibrie> gaal: so, the 'data' block is very concise.  Can we go over that line-by-line

[15:39] <integral> argh, why does the pod parser need to call ruleStatementList?!

[15:40] <Juerd> Why is anything that has to do with perl called xxxxXxxxxxxxxXxxxx?

[15:40] <kolibrie> Juerd++

[15:41] <gaal> kolibrie: sure

[15:42] * kolibrie listens

[15:42] <gaal> look at both those slides... Exp is the name for the entire data type, each variant is one of the possible types in an actual box

[15:43] <gaal> it's a *little* like inheritance, but not really

[15:43] <kolibrie> so the AST Syn 'if' matches the line: Syntax String [Exp]

[15:43] <gaal> when you're talking in general, an AST is a tree of Exps

[15:44] <gaal> but each Exp needs to be of a particular variant

[15:44] <gaal> you can have functions that demand one variant, or you can have functions that are more general

[15:45] <gaal> the slide with the long names is just for pedagogical purposes :)

[15:45] * kolibrie wants to see how the data definition yields a tree, but does not see it

[15:45] <gaal> the real code defines Syn String [Exp] as one variant

[15:46] <gaal> and "Syn" is called a "constructor" because it's one of the various ways to construct an Exp

[15:46] <gaal> :t Syn

[15:46] <gaal> Syn :: String -> [Exp] -> Exp

[15:46] <gaal> this means, that in your code you can have Syn "for" [body]

[15:47] <gaal> and that returns an Exp (that is of the Syn variant), whose String element is "for"

[15:47] <kolibrie> what are :: and -> ?

[15:47] <gaal> that's haskell typing syntax

[15:48] <gaal> :: reads "has the type"

[15:48] <kolibrie> so Syn has the type String

[15:48] <gaal> the type String -> [Exp] -> Exp

[15:48] <Juerd> Does that mean it turns a string into a list of exp, and that into an exp?

[15:49] <gaal> which means that if you give it a String and an array of Exp, you get an Exp

[15:49] <Juerd> Oh, almost

[15:49] <kolibrie> why do they both use an -> then?

[15:49] <gaal> when coming from a non-functional point of view, read type signatures this way:

[15:49] <gaal> a -> b -> c -> d -> e

[15:50] <gaal> function taking a b c d and yielding e

[15:50] <gaal> but of course there's a trick:

[15:50] <Juerd> Hm

[15:50] <Juerd> Multiple arguments?

[15:50] <gaal> if you call this function with fewer args than it "needs", it doesn't blow up

[15:51] <Juerd> Why not a, b, c, d -> e or something like that?

[15:51] <gaal> it returns a function waiting on the rest of the arguments!

[15:51] <gaal> this is called autocurrying

[15:51] <gaal> so for example:

[15:51] <gaal> (+) 1 5

[15:51] <gaal> "add 1 and five"

[15:51] <gaal> (+) :: Int -> Int -> Int

[15:51] <lumi> Read it: a -> (b -> (c -> (d -> e)))

[15:52] <gaal> but if I say

[15:52] <gaal> (+) 1

[15:52] <gaal> I get back a function

[15:52] * azuroth is impressed. looks like I have a parser that supports variable associativity and precedence in 40 lines

[15:52] <gaal> its type is Int -> Int

[15:52] <gaal> and I can apply that function to an int, and get.. another int, one higher.

[15:53] <gaal> (+) 1 is "the function that adds one to its argument"

[15:53] <kolibrie> so any number you pass it will have one added to it and be returned

[15:53] <gaal> this is also known as partial application, or sometimes, a section.

[15:53] <gaal> you can give this function a name, too:

[15:53] <gaal> let inc = (+) 1

[15:53] <gaal> you can also write this

[15:53] <gaal> let inc = (+1)

[15:54] <lumi> gaal: section is the name for the (+ 1) syntax, I think

[15:54] <kolibrie> do all haskell functions autocurry?

[15:54] <gaal> lumi: I think you're right.

[15:54] *** vel joined
[15:54] <gaal> kolibrie: yes.

[15:54] <kolibrie> ok

[15:54] <gaal> in fact, all functions in haskell only take one arguemnt!

[15:54] <gaal> so when you see "f 1 2 3 4"

[15:54] <azuroth> and sections can let you curry the second arg, instead of the first

[15:55] <gaal> it's like saying

[15:55] <gaal> ((((f 1) 2) 3) 4)

[15:56] <gaal> (well, they all take one argument except for those that take one.)

[15:56] <lumi> Like (** 2) is raise-to-the-power-of-two, and (2 **) is raise-two-to-the-nth-power

[15:56] <gaal> so how is Exp a tree? look at the slide with the graphic again

[15:56] * kolibrie looks

[15:56] <gaal> the node for Syn, for example, had a name to it, and also an array of Exps

[15:57] <gaal> so for example the "if" node has two or three children

[15:57] <gaal> Syn "if" [condition, truecase, elsecase]

[15:57] <kolibrie> ok

[15:58] <gaal> The node for function application is defined as

[15:58] *** TMTOWTDIt joined
[15:58] <gaal> App Exp (Maybe Exp) [Exp]

[15:58] <gaal> that means it has (1) an Exp representing the function to be called

[15:59] <kolibrie> so condition = 42, truecase = { say "hello" }, elsecase = { say "oh no!" }

[15:59] <gaal> (2) an optional invocant, defined only in method calls

[15:59] <gaal> (3) an argument list

[15:59] <gaal> exactly

[15:59] <gaal> more precisely, condition == Val (VInt 42)

[16:00] <gaal> because the condition must be an Exp also, not a haskell native type

[16:00] <gaal> you can see that in the graphic:

[16:00] <gaal> under the if there's an extra Val box, not immediately 42

[16:00] <gaal> and note that Val is one of the variants of Exp

[16:00] <kolibrie> and so the condition, being an Int, uses line: Value Val

[16:01] <gaal> yeah. of course, it could have been a much more complex condition

[16:01] <gaal> for example, an equality test

[16:01] <gaal> 42 == 42

[16:01] <gaal> which in Perl really means &infix:<==>(42, 42)

[16:02] <gaal> that is, a function application

[16:02] <gaal> in that case, the condition would be replaced by a subtree which was a little more complex:

[16:03] <gaal> App (Val (VStr "&infix:<==>")) Nothing [Val (VInt 42), Val (VInt 42)]

[16:03] <gaal> see if you can mentally parse that

[16:03] * kolibrie concentrates really hard

[16:04] <gaal> you know that App A B C

[16:05] <gaal> start by distinguishing A, B, and C

[16:05] <kolibrie> A = (Val (VStr "&infix:<==>"))

[16:05] <kolibrie> B = Nothing

[16:05] <kolibrie> C = [Val (VInt 42), Val (VInt 42)]

[16:05] <gaal> exactly

[16:06] <kolibrie> but I forgot what A B and C are

[16:06] <kolibrie> B is invocant?

[16:06] <gaal> then look at the data definition again

[16:06] <gaal> oh, in terms of what they mean

[16:06] <gaal> yes

[16:06] <gaal> that can use a little commenting :-)

[16:07] <gaal> A == Exp evaluating to whatever function we're invocing

[16:07] <gaal> B == invocant, maybe

[16:08] <gaal> C == argument list

[16:08] <gaal> *invoking

[16:08] <gaal> now, it may be the case that the expression resulting in the condition is even more complex

[16:09] <kolibrie> wait

[16:09] <gaal> if 42 == get_answer() { say "..." }

[16:09] <kolibrie> so for that line, the function we call is (Val (VStr "&infix:<==>"))

[16:09] <kolibrie> there is no invocant

[16:09] <gaal> yes

[16:09] <gaal> right

[16:09] <kolibrie> and we have been given two arguments

[16:10] <kolibrie> or a list with two elements as our argument

[16:10] <gaal> yeah. it's somebody else's job to check that == really wants two args.

[16:10] <gaal> yes

[16:10] <kolibrie> ok, /me is ready to continue

[16:11] <gaal> cool. have a pugs handy?

[16:11] <kolibrie> yes

[16:11] <gaal> run it with nothing on the command line

[16:11] <kolibrie> ready

[16:11] <gaal> and write ":d 42 == 42"

[16:11] <gaal> then ":D 42 == 42"

[16:12] <gaal> the first one is a little abbreviated

[16:12] <gaal> the second is actual runnable haskell code

[16:12] <kolibrie> nifty

[16:12] <gaal> (which also contains annotations, like in the slide after the graphic we've been looking at)

[16:13] <kolibrie> so, I see the stuff we were just talking about at the end of the second one

[16:13] <kolibrie> but a lot of stuff at the front I don't understand

[16:13] <gaal> there are other representations for this AST, I think we saw the YAML one together last time we talked, no?

[16:14] <kolibrie> yes

[16:14] <gaal> yeah, that stuff is Ann nodes, which add more info about parts of the tree

[16:14] <gaal> mainly position

[16:14] <gaal> so that if there's an error message, it knows to tell the user where the error was

[16:14] <gaal> MkPos "<interactive>" 1 2 1 8

[16:15] <gaal> that means "in the interactive pugs, from line 1 col 2 to line 1 column 8"

[16:15] <kolibrie> ok

[16:16] <gaal> it also happens to be parsed as a bunch of statements, and there's a spurious Noop in there, but you can ignore that

[16:16] <kolibrie> on some of those lines in the data definition, there a more pieces, and some have less

[16:17] <gaal> yes; but haskell doesn't get confused because for each type there is a precise number of pieces.

[16:17] <kolibrie> and those types are all defined somewhere else

[16:18] <gaal> yes, learning to find them quickly takes a bit of getting used to

[16:18] <gaal> if you know the general data type name (like Exp), you can grep around for /^data Exp/

[16:19] <kolibrie> and before this parser is run, strings have already been converted into tokens by something else

[16:19] <gaal> but if you didn't know that Syn belonged to Exp, you may have had a little harder time finding that

[16:19] <gaal> I don't have a great solution to that

[16:19] <gaal> but when you see this kind of thing, start from the beginning

[16:20] <gaal> in this case, you see Stmts Noop (...)

[16:20] <gaal> we happen to know that Stmts is a constructor in Exp

[16:20] <gaal> Stmts :: Exp -> Exp -> Exp

[16:20] <gaal> that is:

[16:21] <gaal> it takes Noop and another (long!) Exp, and together they are one Exp of variant Stmts

[16:21] <gaal> if you have a Perl block with some stuff:

[16:21] <gaal> { A; B; C; }

[16:22] <gaal> then the statements inside the block can be arranged to look like Stmts A (Stmts B (Stmts C Noop))

[16:22] <kolibrie> Stmts has the type Exp -> Exp -> Exp (or, it takes two Exps and returns an Exp)

[16:22] <gaal> yes.

[16:23] <integral> do I need to do anything to add a new .hs file to the build?

[16:23] <gaal> this isn't really important, except that it provides us with a way to talk aobut a bunch of statements together.

[16:23] <gaal> integral: add it to Pugs.cabal.in

[16:23] <integral> ah!

[16:23] <gaal> and to the clean directive in Makefile.PL

[16:24] <gaal> the second bit may not be needed

[16:24] <integral> ack!  why?   Makefile.PL already uses glob to *search* for .hs files automatically

[16:25] <gaal> integral: why what, why can't this only be defined in one place? I don't know the good answer to it, but I do see why cabal wants to know about files

[16:26] <integral> well it's actually wanted to know module names, so I guess it's slightly different :-/

[16:26] <integral> *wanting

[16:26] <gaal> we can probably engineer things so as this is more automatic, but that'd add some more complexity to our glorious build system

[16:27] <gaal> commits welcome, in other words :)

[16:27] <integral> I hope that "glorious" was sarcastic ;-)

[16:27] <gaal> kolibrie: so, have things started to sink in?

[16:28] <gaal> integral: sarcastic? well, we do use Haskell during build...

[16:29] <kolibrie> gaal: somewhat.  I'm going to paste an example

[16:30] <pasteling> "kolibrie" at 66.239.158.2 pasted "gaal: this tokenizes, but how do I define what a sentence must contain" (47 lines, 1K) at http://sial.org/pbot/16114

[16:31] <kolibrie> I got that from an example, and don't really understand parseToken

[16:33] *** Draconit_ joined
[16:33] <mauke> do you know choice?

[16:33] <gaal> let me rewrite it in hopefully more readable form

[16:34] <kolibrie> choice is like alternation, I think

[16:34] *** kulp joined
[16:34] <mauke> yeah, choice [a, b, c] is a <|> b <|> c

[16:34] <mauke> do you know >>=?

[16:34] <kolibrie> no

[16:35] <mauke> ah, that's the problem

[16:35] <azuroth> not quite related, but how does <- work? it seems like magic

[16:35] <integral> mauke: no, it's mzero <|> a <|> b <|> c, it foldls with mzero, not foldl1

[16:35] <mauke> d'oh

[16:36] <mauke> azuroth: you mean in do blocks?

[16:36] <azuroth> yeah

[16:36] <mauke> m >>= \x -> y is the same as do { x <- m; y }

[16:36] <mauke> <- is syntactic sugar for >>=

[16:37] <kolibrie> ok, that almost makes sense

[16:37] * kolibrie let's it sink in

[16:37] <azuroth> ohh! I thought the ; was, for some reason

[16:38] <mauke> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b

[16:38] <gaal> don't worry about that monadic stuff yet :)

[16:39] <kolibrie> hmm, don't know => either

[16:39] <mauke> => is special syntax in type declarations

[16:40] <mauke> the things before it are class constraints

[16:40] <mauke> in this case it says m must be an instance of class Monad

[16:41] <mauke> in our example it's like (>>=) :: Parser a -> (a -> Parser b) -> Parser b

[16:41] <gaal> that's probably a mouthful right now

[16:41] <kolibrie> so it could also read: (>>=) :: m a -> (a -> m b) -> m b

[16:41] <mauke> p >>= f runs the parser p, calls f with the result, then runs the resulting parser

[16:42] <gaal> consider parseToken to mean something like

[16:42] <gaal> parseToken = choice [ A, B, C, D, E ]

[16:42] *** kulp left
[16:42] <gaal> where the return value of each of these is what's on the right of the >> or >>=

[16:43] <gaal> this example is a little golfy.

[16:43] <kolibrie> so parseToken defines which subparsers to run on the input

[16:43] <kolibrie> and each subparser tokenizes what it can

[16:43] <gaal> kolibrie: they are tried in order, and the parses backtracks when one fails

[16:43] <gaal> in Pugs style, that would have been

[16:44] <gaal> parseToken = choice [ ruleSpaces, ruleEnding, ruleName, ruleWord, ruleChar ]

[16:44] <mauke> huhu, fmap ((: []) . TokenEnding) ending

[16:44] <azuroth> what does { e <- getInt; f <- getInt; return (e - f)} monadify to? {getInt >>= \e -> (getInt >>= \f -> return (e - f))} or something similarly crazy?

[16:44] <mauke> azuroth: no { }

[16:44] <gaal> and ruleSpaces woudl be

[16:45] *** Nouk joined
[16:45] <azuroth> and no return?

[16:45] <mauke> return stays, it's just a function

[16:45] <gaal> ruleSpaces = do

[16:45] <gaal>     many1 space

[16:45] <gaal>     return []

[16:45] <mauke> getInt >>= \e -> getInt >>= \f -> return (e - f)  -- works

[16:45] <gaal> ruleEnding = do

[16:45] <gaal>     s <- ending

[16:45] <gaal>     return [TokenEnding s]

[16:46] <gaal> ruleComma = do

[16:46] <gaal>     char ','

[16:46] <gaal>     return [TokenComma]

[16:46] <gaal> that's hopefully clearer

[16:46] <gaal> take ruleComma

[16:47] <gaal> the line char ',' is a sort of an assertion

[16:47] <gaal> if it fails, so does ruleComma

[16:47] <gaal> that behaves like throwing an exception

[16:47] <azuroth> cool, thanks mauke! it makes much more sense now

[16:47] <kolibrie> gaal: so I could replace me parseToken with those definitions

[16:48] <gaal> yes

[16:48] <svnbot6> r9241 | bsmith++ | Factored out inline documentation from Pugs.Parser to Pugs.Parser.Doc.

[16:48] <svnbot6> r9241 | bsmith++ |   Had to leave ruleDocBlock in Pugs.Parser for the moment.

[16:48] <gaal> ooh integral++

[16:48] <mauke> a >> b = a >>= \_ -> b

[16:48] <integral> gaal: that was the easy part,  now to figure out ruleDocBlock and why it needs to parse statement lists :)

[16:49] <kolibrie> and then to make the parser fail if a sentence is not correct, do I change the definition of the new parseToken?

[16:51] <gaal> kolibrie: what does a parser do now if a sentence is incorrect?

[16:51] <integral> *argh* I see why it's so annoying.  it's the silly recursive way ruleStatementList works :-/

[16:52] <kolibrie> gaal: right now it tokenizes anything that matches a subparser

[16:52] <kolibrie> I want it to fail if no ending punctuation, for instance

[16:53] <gaal> oops, I have a "ride" home

[16:53] <gaal> kolibrie: add assertions

[16:54] <gaal> in this case, it looks like you want choice [ ruleEndOfInput, ruleEndOfSentence ]

[16:54] <gaal> but i gotta go :)

[16:54] <kolibrie> gaal: thanks so much!

[16:54] <gaal> integral: worst case pass ruleStatement as an implicit param.

[16:55] <gaal> or an explicit one :)

[16:55] <gaal> &

[16:55] <integral> best case: rewrite ruleStatementList to use these higher-order functions we keep talking about :-P

[16:56] *** fglock joined
[16:56] <svnbot6> r9242 | fglock++ | - iterator_engine_p6grammar.pl - precompiled Prelude!

[16:56] <svnbot6> r9242 | fglock++ |   loads in less than 1 second

[16:59] <integral> *sigh* it's so nice how emptyExp and Noop are the same thing, but it can be confusing to read

[17:02] <svnbot6> r9243 | fglock++ | - iterator_engine_p6prelude.p6 - this is the Prelude file

[17:03] <azuroth> night, all

[17:04] <fglock> iterator_engine now has dynamic grammar - iterator_engine_p6prelude.p6 defines pod, and then immediately uses pod for documentation

[17:04] <svnbot6> r9244 | fglock++ | iterator_engine - cosmetic fix

[17:07] <svnbot6> r9245 | fglock++ | - iterator_engine_p6grammar.pl promoted to p6compiler.pl

[17:14] <Juerd> rafl: When could you re-enable the automatic installation of Pugs on feather?

[17:14] <Juerd> rafl: beep

[17:22] <rafl> Juerd: Will do so.

[17:31] *** chris2 joined
[17:37] <svnbot6> r9246 | fglock++ | - iterator_engine - p6compiler can be invoked with:

[17:37] <svnbot6> r9246 | fglock++ |   perl iterator_engine_p6compiler.pl iterator_engine_p6sample.p6

[17:42] *** putter joined
[17:42] *** Shabble joined
[17:43] <putter> audreyt, gaal: so is it time, and still the plan, to move functionality from Prim.hs to Prelude.pm, now that its compile-duration issues have been fixed?

[17:43] <putter> fglock: ping?

[17:44] *** szabgab left
[17:45] *** macli joined
[17:46] <putter> TimToady: re would a patch help, I don't think so.  I'm at this moment trying to work out the design constraint space - more in a bit.

[17:54] <gaal> putter: we can definitely start, but there's a small matter of packaging to perform before pulling the switch

[17:55] <gaal> precompilation works but is not engineered yet

[17:55] <gaal> that is to say, it has a good design but that isn't implemented yet

[17:57] *** calanya joined
[17:59] <wolverian> typo on peek slide37, missing }

[17:59] <wolverian> in case that's still relevant :) 

[17:59] <gaal> sure, thanks :)

[18:01] <gaal> putter: right now, pugs looks only at src/Pugs/PreludePC.yml and ./Test.pm.yml[.gz]

[18:01] <gaal> we need the per-user cache folder

[18:01] <integral> does Test.pm.yml get created at the same time as PreludePC by the build?

[18:01] <gaal> integral: no, only on "make smoke" or "make test"

[18:02] *** rantanplan_ joined
[18:02] <gaal> this means incidentally that "make install" suckifies ./pugs :)

[18:03] <gaal> If I'm lucky I'll fix it over the weekend, but possibly not as there's some pizza and a family dinner both waiting to happen

[18:03] <fglock> putter: pong

[18:06] <gaal> fixed.

[18:06] <gaal> err, I mean the slides. :)

[18:07] <svnbot6> r9247 | gaal++ |  r9268@sike:  roo | 2006-03-02 20:02:42 +0200

[18:07] <svnbot6> r9247 | gaal++ |  * fix missing closing brace. Reported by wolverian++.

[18:11] <gaal> nothingmuch: ping

[18:13] <svnbot6> r9248 | gaal++ |  r9275@sike:  roo | 2006-03-02 20:08:53 +0200

[18:13] <svnbot6> r9248 | gaal++ |  * perl6.vim: hilight `rule` the same way as `method`

[18:17] <fglock> is there a way to set the filename/line in an eval(), for warnings to behave properly ?

[18:21] <fglock> meeting &

[18:29] <gaal> fglock: #line?

[18:30] <gaal> ?eval eval "say 'mmm'; \n#line 44324\nwarn 42"

[18:30] <evalbot_9248> OUTPUT[mmm ] undef 

[18:30] <gaal> ?eval eval "say 'mmm'; \n#line 44324\nsay Carp::longmess"

[18:30] <evalbot_9248> OUTPUT[mmm ] undef 

[18:30] <gaal> oof unsafe

[18:31] *** Draconit joined
[18:33] <gaal> but that oughta work

[18:33] <gaal> i have to go now... &

[18:47] *** OuLouFu joined
[18:48] *** axs221 joined
[18:51] <axs221> I've been trying to decide on learning either perl or python. With Perl6 coming out, will learning Perl5 still be useful, or will 6 be too different so that I'd have to relearn most of what I would learn?

[18:52] <mauke> learn all three of them

[18:53] <axs221> eventually i might, but i'm wanting to just learn by book right now, i bought a python book

[18:56] <axs221> i'm thinking about taking the python book back and getting a perl book, mostly because of the greater demand in the market for Perl, atleast in job search sites, although from what I know Python sounds easier to learn for someone relatively new to programming like me

[18:58] <mauke> yes, probably

[19:02] *** Nouk joined
[19:02] *** mauke joined
[19:03] *** dduncan joined
[19:12] *** vborja joined
[19:17] *** beppu joined
[19:21] *** vborja is now known as handon

[19:22] *** nothingmuch joined
[19:23] *** ruz joined
[19:23] *** Draconit joined
[19:24] <putter> gaal: I don't quite understand.  are you saying src/Prelude.pm still has constraints on size (maybe on install??), and thus shouldnt be non-trivially enlarged at the moment?  or that it can be?

[19:25] <putter> fglock: #line N "filename"     which I think the next line is considered N, but I'm not sure.

[19:25] <putter> yes, now sure. ;)

[19:26] <putter> (used in the "I really should put a copy in common" somewhat cleaned up spike backtracking regexp engine thing - makes syntax errors in evals much clearer. )

[19:27] <svnbot6> r9249 | bsmith++ | * Rewrote the looping logic in ruleStatementList so that the recursion is

[19:27] <svnbot6> r9249 | bsmith++ |   factored out into a higher-order function.

[19:27] <svnbot6> r9249 | bsmith++ | * The above allows ruleDocBlock to be moved from Pugs.Parser to its proper

[19:27] <svnbot6> r9249 | bsmith++ |   place in Pugs.Parser.Doc.

[19:28] <putter> axs221: if you dont have experience coding in other languages, learning python is more likely to start you off with good habits than learning perl.

[19:28] <integral> *sigh* only 50 lines smaller though

[19:29] <putter> ;)

[19:30] <putter> were expecting a greater code shrinkage?

[19:30] <integral> just wishing that it'd suddenly turn into one when I commited ;-)

[19:30] <putter> lol

[19:31] <nothingmuch> hola

[19:31] <putter> hola, como estas?

[19:31] <nothingmuch> estas beseder

[19:31] * putter goes to google language tools...

[19:31] <nothingmuch> a friend of mine always asks me como estas

[19:32] <nothingmuch> she knows some spanish/portugise phrases from TV soaps

[19:32] <nothingmuch> i always try to spoil her fun

[19:32] *** handon left
[19:33] *** Draconit joined
[19:33] <putter> :)  google translates to "to beseder".  had to check OneLook to make sure that was a googlism, and not a nifty word which is similar in both spanish and english :)

[19:34] <putter> hmm, so I still dont know what it means.

[19:34] <nothingmuch> beseder is hebrew for "OK"

[19:34] <nothingmuch> i don't know what "estas" means

[19:34] <nothingmuch> she would always laugh at me and say "enough nonsense" or something of the sort

[19:34] *** Draconit joined
[19:34] <nothingmuch> anyway, my sister's birthday party was a big success

[19:35] <nothingmuch> and now I'm off to visit a friend

[19:35] <putter> aaahhh.  como=how estas=are you    esta=i am  etc

[19:35] <fglock> nothingmuch: I speak portuguese in case you need :)

[19:35] <nothingmuch> i hope i'll survive, i haven't seen her in weeks and she is touch about that kind of stuff =)'

[19:35] <putter> yay.  was surprise?

[19:35] <nothingmuch> fglock: ah, good thing

[19:35] <nothingmuch> putter: yes

[19:35] <nothingmuch> we made her a Moomin cake house

[19:35] <putter> win

[19:35] <nothingmuch> thanks to elaine ashton

[19:35] <nothingmuch> and we bought her an ipod

[19:36] <nothingmuch> and she is delighted

[19:36] <putter> Moomin... putter goes back to google... later...

[19:36] <nothingmuch> http://en.wikipedia.org/wiki/Moomins

[19:36] <fglock> hi putter - bye putter

[19:36] <putter> ah, it's great when a plan comes together :)

[19:36] <nothingmuch> http://www.axis-of-aevil.net/archives/2005/12/eating_moomins.html

[19:36] <putter> hi fglock, bye? fglock

[19:36] <putter> fglock quick question

[19:37] <putter> ping?

[19:37] <fglock> pong

[19:37] <putter> are you doing any <expr> expression/operator parsing stuff?

[19:37] <fglock> (I said bye because you said later...)

[19:37] <putter> oooohh.

[19:38] * putter goes to look at moomins :)

[19:38] <fglock> mm - yes, more or less

[19:38] <nothingmuch> putter: it's a series of children's books for adults

[19:38] <fglock> I didn't implement operator precedence yet, but it does espressions

[19:38] <fglock> s/expressions/

[19:39] <fglock> see: iterator_engine_p6sample.p6

[19:39] <putter> ah, http://en.wikipedia.org/wiki/Moomins

[19:39] *** vborja joined
[19:39] <nothingmuch> ciao guys

[19:40] <nothingmuch> putter: yes, just like i linked you =)

[19:40] <fglock> putter: it compiles: '1' infix:<*> '1' infix:<+> '1';

[19:41] <putter> oh, duh.  saw the first link, explored, ...

[19:41] <fglock> if you try 'print' on that it might work

[19:42] <putter> which there was more description of... content?  perspective?  ie, not cast and geography, but what they do/believe/etc.

[19:45] <putter> fglock: err, so where is precedence handled?

[19:47] <fglock> putter: there is no precedence yet - first come, first compiled. 

[19:47] <putter> got it.

[19:47] <fglock> first priority was bootstrapping, which is mostly done

[19:48] <fglock> now there are many possibilities - adding precedence is one of them

[19:48] <fglock> I'm not sure what to do next - would like to hear some opinions

[19:48] <fglock> performance is quite good

[19:49] <fglock> there is the object system work, 

[19:49] <fglock> completing the rule syntax,

[19:49] <putter> ok, so is a correct one-liner  "interator is like the regexp/parser spike, but bootstrapped to self hosting, and using p6 rather than p5 syntax regexps"?  other key differences?

[19:49] <fglock> packaging to CPAN,

[19:50] <fglock> the whole syntax is defined in p6

[19:50] <fglock> see: iterator_engine_p6prelude.p6

[19:51] <fglock> I could move the compiler to p6 now :)

[19:52] <putter> right.  parser_spike.pl cheats a bit to get parser_spike_target.p6 working.

[19:52] <putter> :)

[19:53] <putter> hmm... what to do next...

[19:54] <fglock> there is some cheating going on in making { return } blocks work before bootstrapping - but after boorstrapping it can go away - it uses a source filter

[19:55] <putter> I'm afraid I haven't even looked yet at the new -CParser-YAML (or somesuch) output.  is it something you could derive from your parse tree, so there is a cross check?  maybe a cross check.  the trees may be too tied to parsing strategy to compare easily.

[19:56] <fglock> I could generate YAML if I knew the nodes, but I'm afraid it is too complex for now -  it can be left for later

[19:56] <fglock> being able to read YAML would be nice, you could reuse compiled things from pugs to i_e

[19:57] <fglock> i_e nneds a name, maybe a directory :)

[19:57] <fglock> s/nneds/needs/

[19:58] <putter> you could start pouring Parser.hs into p6 rules...

[19:58] <putter> start working through the sanity tests, eyeballing for reasonable parses...

[19:59] <putter> misc/IteratorEngine ? ;)

[20:00] <putter> easy enough to rename.  svn++

[20:00] <fglock> Puggie - Pugs little brother/syster

[20:00] <putter> *shudder*

[20:00] <putter> :)

[20:02] <putter> PerlParserPrototypingPlatform

[20:02] <fglock> I'd like to have more opinions on the subproject, before working too hard on it

[20:02] <putter> lol

[20:03] <fglock> it was very successful as an experiment

[20:03] <putter> ooo, PerlParserPrototypingPlatformProject

[20:03] <fglock> that's java-ish

[20:05] <putter> makes sense.  audreyt said something about attempting a pass over the t/ and ext/ code using... something.  a new parser?  implementing the "sandwich" parser concept to proof it?

[20:05] <putter> re very successful, indeed.  congrats. :)

[20:05] *** larsen joined
[20:08] <putter> I seem to have backburnered my backtracking engine (still mostly p5 syntax - next step was to be an operator parser), when the spec for one of my "solid places to stand touchstones", Match, started fluxing.  Think I may fork a Natch class, that I can keep stable and do whatever the engine needs for now, without worrying about spec.

[20:11] <putter> Hmm, and perhaps more importantly, the operator precedence parsing turned out to be a messier proposition than I anticipated.

[20:12] <putter> In retrospect, I should have / should now hack something, to get back to a parser running, and some semblance of p6, so we could have two implementations chasing each other.  maybe.  or maybe that would simply be a waste.

[20:13] <fglock> putter: operator precedence is easy - it just take a while to optimize (if needed)

[20:13] <fglock> :) not a waste, but we could have a common API such that we can interchange engines

[20:13] <putter> not in the presence of pre-, post-, and especially circum- fix.

[20:13] <putter> re simple.

[20:14] <fglock> putter: that's a grammar problem (solved) - all we need is to present options to the grammar in the proper order. it should be about 50 lines of code

[20:15] <putter> I hypothesize pge is not quite doing the right thing re close tokens on cirumfix ops.  and there are assorted "make for extra work" bits like operators having a "no whitespace allowed before me" flag.  assorted cruft.

[20:17] <fglock> bbiab

[20:19] <putter> so your parser, given  ... * ,,,   with * rule defined early, looks ahead through the input to match *, with two unprocessed strings ... and ,,, , and then recurses on them?

[20:19] <putter>  

[20:21] <putter> Regarding using an alternate regexp engine in perl5, I did a design space grovel - it would take something like four pages to write up - isn't going to happen unless someone _rteally_ wants it.

[20:23] <putter> Most important point is most of the difficulties lie in trying to swap engines in a way which is _transparent_ for _humans_ coding _perl5_.

[20:24] <putter> for p6 _on_ p5, rather than _in_ p5, with a compiler emitting arbitrary p5 code, the only(?) residual issue is exporting qr//'s to native modules.

[20:25] <putter> So in a p6 context, I don't think the exercise is worth the pain.  Questions about "what pain?" entirely welcome. :)

[20:25] <putter> My key uncertainties/questions are:

[20:25] <fglock> re: ... * ,,, - yes, and it backtracks if fail

[20:26] <fglock> re: "no whitespace allowed before me"

[20:26] <fglock> it can be specified in the grammar, I believe

[20:27] *** calanya left
[20:28] <fglock> re: qr// - I could write an emitter for that, so we can choose between rule or regex (besides, we can use regex instead of rule when possible, which is faster)

[20:28] <putter>   Can XS somehow set $1 to a non-string (an object)?  Is there some way to create an arbitrary variable which gets scoped just like $1 does?  Regards reentrancy - is it strictly capture which is broken?  does everything not dependent on captures still work?  I think those are my big fuzzies.

[20:29] <fglock> re: $1 - it's good to have TimToady around :)

[20:29] <putter> :)  and japhy.

[20:29] <putter> and bsb

[20:29] <putter> and ... :)

[20:33] <fglock> bbiab

[20:34] <putter> Oh, and the tech for playing with regexp's that I know about is, well, source filters of course, bsb's "regexp which calls matcher, gets capture offsets, and correctly sets up capture vars", the  use re 'debug'-ish  regcompp and regexecp hooks, and... I dont know of any other tools to get leverage around here, short of playing with opcodes (p5, and regex) or patch p5.

[20:34] <putter> If anyone knows of any other candidates, I would be most interested.

[20:36] <buu> Um, Regexp::Parser?

[20:37] <putter> I should mention the hooks are basically providing a way to fake up regexp struct's, both as an api into the perl matchvar machinery, and as a way to do qr// which _is_ reentrant (the hooks are reentrant, its just the engine which isnt - thus the one downside of bsb's device).

[20:39] <putter> buu: Yes, a good thing to mention.   Thanks.  (and there is a copy with some bug fixes in misc/pX/Common/Regexp-Parser, also with some additional tests, some failing...)

[20:39] *** SamB joined
[20:41] <PerlJam> I know it's been a while since I've paid attention to pugs when I look at #perl6 and I haven't the foggiest idea what's being discussed  :-)

[20:42] <putter> This is the p5p perl5-porters sidebar on #perl6. ;)

[20:42] <PerlJam> Oh.  I haven't read p5p in *years*, so that makes sense.

[20:43] <fglock> PerlJam: we are porting p6 to p5 (kind of)

[20:43] <buu> Yay!

[20:43] <PerlJam> fglock: good luck!  I'm of the uninformed opinion that it's Too Hard  :-)

[20:44] <fglock> PerlJam: no it's not :)

[20:44] <putter> Somewhat off topic.  You dont need it for pugs.  Nor for a pugs backend running on p5.  Nor for a completely independent p6 parse-compile-emit implementation on p5.  You only need these silly time-absorbing games if you attempt to give human p5 programmers p6-ish regexs they can use transparently on p5.  eh.

[20:44] <fglock> it's just that there are _too_ many ways to do it

[20:45] <fglock> putter: right

[20:45] <putter> though to be fair, some of the stuff turned up could end up being useful for the p6 on p5 stuff interoperating with native p5 modules.

[20:46] <PerlJam> putter: twould be easyish if PGE were a library you could embed.

[20:46] <fglock> putter: I'll translate i_e to p6 anyway

[20:48] <putter> I'm basically puttering.  Could be working on moving Prim.hs to Prelude.pm, but it's not clear it time for that.  Could getting the somewhat cleaned up bactracking stuff at least checked in, or continue work on operator parsing, but with fglock making progress, the presure is off, and it's just not -Ofun.  So I've spent 10-ish hours being random.

[20:51] <putter> fglock: re _too_ many ways, no.  the number of possible tools certainly makes analysis harder.  but I believe the real problem, at least for a full bore "use EverythingRegexyNowLooksLikeP6; ...", is that you simply cant do it.

[20:53] * fglock goes read Prim.hs

[20:53] <putter> PerlJam: re PGE, the engine is actually the easy part :).  sort of.  or at least the part we've sort of kind of already done.  the long-term as-yet-unresolved puzzle is the pragmatics of integrating it with unpatched perl.

[20:54] <fglock> putter: OT - do you know of an example of using '&' in a rule? (conjunction)

[20:54] <PerlJam> Hmm.  unpatched perl?  How incestuous must the engine be?

[20:54] <putter> though there are some low hanging fruit, like a reentrant p5 regexp engine with rules.  that one could do now as an  XS module for cpan.  but that's a bit off-perl6-topic.

[20:55] <putter> fglock: an example?  any example?

[20:55] <putter> abc&\w**{3}  ;)

[20:55] <fglock> putter: what is it useful for?

[20:55] <putter> ooooohh

[20:56] <PerlJam> fglock: Are you asking what & is generally useful for?

[20:56] <putter> one sec

[20:57] <fglock> PerlJam: in the context of p6 rules

[20:57] <PerlJam> The things I can think of all involve increased specificity.

[20:57] <putter> PerlJam: the regexp engine and the perl compiler/runtime unfortunately know each other quite well.

[20:58] <putter> And p5's extensibility has never extended to permitting the user to, for example, create a Qr class which emulates qr//, overloading =~.

[20:59] <putter> And there are no hooks, even at the C level, for creating the $1,etc suite. 

[20:59] <PerlJam> putter: sounds like the goal should be to get those patches in before the next release of perl5  :-)

[21:01] <putter> One of the key values of the hooks, and their ability to create "struct regexp"'s, is you finally have a way to twiddle some of those internals.  But I'm afraid it may not go as far as "please, can my $1 be an SV?". :(

[21:04] <putter> PerlJam: doing p5 guts modifications to better support p6-like stuff...  is something which could be added to perltodo. ;)  volunteers welcome.  making the regexp engine reentrant is listed there.  in the "hard" section (though I'm not clear on why it's hard exactly.  but I dont see perlguts hacking in my future).

[21:04] <putter> Oh my, scary last words.

[21:05] <putter> man perltodo   (i only discovered it the other day:)

[21:05] <putter> fglock: re conjunction,

[21:06] <fglock> putter: other option - help me doing the i_e thing :P

[21:08] <putter> you know how you sometimes use lookahead to assert some property on the following characters, in addition to the regex which actually matches them?  the one gotcha is you cant assure the lookahead matches exactly... (well, you can, but it takes, oh wait, I'm not sure you can) anyway, that it matches exactly what you intended.

[21:10] <putter> <hiaku>&[<line>+]

[21:10] <putter> hmm, the grouping [] was unnecessary

[21:11] <fglock> putter: thanks

[21:12] <putter> [<mail_header>&.*?^^From: (\N+).*] $<body>:=(.*)

[21:16] <putter> PerlJam: what's an increased specificity example?  both of mine were assert-spec&unpack pairs.

[21:18] <fglock> putter: .* would make it fail, isn't it?

[21:19] <putter> you mean the .* after the (\N+) ?

[21:19] <fglock> yes

[21:20] <PerlJam> putter: yes, mine are similar, just that the "unpack" part isn't necessary:    [<mail_header>&^^<'From:'>] && do_something_only_with_from_lines;

[21:20] <putter> I don't believe so.  I would expect the & to force the * to backtrack.

[21:20] <PerlJam> putter: btw, beware the cut-colon!  :-)  (unless I'm mistaken that you meant for the : to be matched)

[21:20] <putter> lol

[21:20] <putter> right

[21:21] <putter> god, both my p5 and p6 are going to be so buggy.  colons and brackets and sigh, oh my.

[21:22] <putter> when writing p5 regex's i now do a double-take each time I use {, "wait, that's... no, it's p5, that's ok". ;)

[21:24] <PerlJam> The conceptual and syntactic overlap is annoying if you have to do both.

[21:24] <PerlJam> (ergo, I've sworn off writing perl6 for a while)

[21:25] <putter> I don't think that last & example actually works...

[21:25] <putter> ah

[21:27] <putter> <mail_header> would have to match exactly the 5 chars "From:".

[21:28] * putter wonders what the big-picture status and critical path of pugs currently are.

[21:28] * putter goes to check audreyt's blog ;)

[21:35] *** DesreveR joined
[21:36] <PerlJam> putter: Are you *sure* it would have to be that way?  Must they both match the exact same characters completely?  Granted, if it didn't I have no idea what state it would leave the current byte/char position pointer in.

[21:36] <fglock> PerlJam: it must match exactly the same substring

[21:37] <putter> has anyone groveled over Parser.hs and created a p6 grammar?  either a direct translation, or one using <statement> and <expr> modifying constructs like  statement_control:<if> and infix:<+>, etc?

[21:37] <PerlJam> Seems like you'd have to worry about end points then rather than just "matches at this position"

[21:38] <PerlJam> "foobar" ~~ /<'foo'>&<'foobar'>/   # What happens?  Does the match fail?

[21:39] <putter> PerlJam: just doing zero-length lookahead assertions (?=...) and <before ...> satisfies the "they both start here, and I dont care where they end" need.  & exists entirely to provide the "i do care where they end".

[21:39] <putter> yes, that match fails

[21:39] <PerlJam> putter: that seems entirely reasonable.

[21:39] <fglock> putter: re: grammar - I'll start doing that soon

[21:40] <PerlJam> (Well, that seems reasonable as along as it's adequately documented :-)

[21:40] <putter> translation or self-modifying (what's a better name for that?)

[21:40] <putter> :)

[21:41] <fglock> putter: I can write a grammar to parse Haskell, and use it as-is

[21:41] <putter> "foobar" ~~ /<before <'foobar'>><'foo'>/ succeeds

[21:42] <putter> any ideas on what to call a grammar which uses non-local definition of <statement> and <expr> ?

[21:42] <fglock> putter: non-local?

[21:43] <putter> ok, that was either you suggesting "non-local" was an ok name, or you being confused about what i meant by "non-local", thus eliminating as an option.  i'm not sure which...

[21:44] <putter> :)

[21:44] <fglock> what do you mean by non-local?

[21:44] <putter> ah, eliminated as an option.  meant

[21:45] <putter> something which, instead of an explicit  rule statement {  subrule1 | subrule2 | ... },

[21:46] <PerlJam> putter: a fully qualified rule name?

[21:46] <fglock> putter: that's <@subrule> in i_e

[21:47] <putter> one uses  multi statement_control:<if> (...){...}  multi statement_control:<while> (...){...} etc to fill it in.

[21:47] <fglock> putter: you mean, statement_control is represented by an array? (or namespace thing)

[21:48] *** pdcawley joined
[21:48] <putter> fglock: yeah, but there are some issues... like how do  (pause)

[21:49] <PerlJam> must not have been enough svk talk here ;-)

[21:49] <fglock> putter: please not that it is an array of rule - it is very flexible

[21:49] <putter> statement_control is a grammatical category.  it defines one of the <statement> subrules.

[21:50] <putter> (my yeah, was directed at <@subrule>, not represented by an array ;)

[21:53] <putter> fglock: yes but.  when writing a grammar, in a first match wins engine (like | is), you carefully craft the order of the subrule list.  when subrules get added by statement_control defs, someone other than the human has to do the crafting.  either the statement_control infrastructure assures the @array has a nice order, or <statement> can't use <@array>.

[21:54] <fglock> putter: you can opt to use longest-match instead of ordered-match

[21:54] <putter> yes

[21:55] <fglock> that would be <%statement_control>

[21:55] <putter> and the real parser can play games like trying to massage the @array into a trie, so it doesnt have to repeatedly reparse the same stuff the same way.

[21:56] <fglock> putter: it is cached

[21:57] *** Arathorn is now known as Aragone

[21:58] <putter> re statement_control, http://dev.perl.org/perl6/doc/design/syn/S04.html has a little bit in Statement parsing.

[21:59] <fglock> putter: nice

[22:00] *** ruz joined
[22:01] *** Limbic_Region joined
[22:01] <Limbic_Region> is there a known problem with Feather and https ATM? 

[22:01] <fglock> why is 'if' a macro? (S04)

[22:02] *** chris2 joined
[22:03] *** pmurias joined
[22:04] <putter> re hash, "An interpolated hash matches the longest possible key of the hash as a literal, or fails if no key matches.", which doesnt help you distinguish between  /if <expr> <block> [else <block>]?/ and /if <expr> <block> [else <block>]? [wrap_around_both_branches <mumble>]?/.   comparing "if" and "if" isnt going to help.

[22:05] <pmurias> Does any one think that useing Smart::Comments in iterator_engine.pl would be a good idea?

[22:06] <fglock> pmurias: I like Smart::Comments, but I'd like to keep it simple (that is, no unnecessary dependencies)

[22:06] <putter> (there shouldn't have been a ? on the <mumble> clause)

[22:06] <pmurias> It would be a dependency only for debugging :)

[22:06] <pmurias> And casual users don't do that often :)

[22:07] <pmurias> at least they shouldn't have to :)

[22:07] <fglock> pmurias: I'll check that (you mean, disable 'use Smart::Comments' when not in use?)

[22:08] <pmurias> the use line should be comment out by default

[22:08] <fglock> putter: re /if.../ - I don't understand the mumble part, what would it be?

[22:08] <pmurias> and if the debuging messages are needed you just delete the #

[22:09] <putter> re if macro, well, you need to add a regex to <statement> so you can parse it.  and we can currently hang regexs off of, well, rule, and macros     macro statement_control:<if> (...) is parsed(/heres the regex/) {...}

[22:09] <pmurias> i'll commit it tommorow if youd don't mind

[22:09] <fglock> pmurias: sounds good - I'll check the pod again

[22:09] <pmurias> i have to sleep now, will be back tomorrow, bye

[22:12] <fglock> putter: ok. so the macro is just a simplification of the rule thing I'm using

[22:12] <putter> re mumble, oh, maybe a block/closure which is handed the block/closure which if would normally execute itself, but it gets to do some stuff, then maybe call it, then do other stuff.  but it was just a strawman to point out that with random cruft being added to the parser, some of which will conflict with existing rules, an alt-like parse is insuffient.

[22:13] * putter goes to look again at what fglock is using... and then has to remember to search.cpan Smart::Comments...

[22:14] <fglock> putter: I think there must exist just one 'if' - if you need something more complex, you define it inside the if-macro or define it with a rule, which gives you full flexibility. but there is only one entry in the statement tabl

[22:15] <fglock> putter: re using: only rules, no macros

[22:15] <fglock> s/tabl/table/

[22:16] <fglock> unlike multis, which are defined in another category

[22:17] <putter> yes - the push'es, and on to what, are implied by the grammatical category stuff.  statement_control, infix, term, etc.

[22:17] <fglock> putter: yes - that would be handled by macros, if we had them

[22:18] * fglock thinks about adding macros - it goes to the TODO list

[22:18] <putter> well, the whole issue of what's a macro/rule/method/sub is still a bit unspeced (or such is my recollection)

[22:23] *** DesreveR is now known as r0nny

[22:26] <putter> perhaps in this case, a macro (would have to be a string macro, yes?) could match and rewrite the input.  a  rule statement_control:<if> {...}  could do whatever ruleish things the rest of the p6 grammar rules are doing, perhaps to build an ast.  (caveat, I'm not sure I've seen a spec example of a "rule statement_control").

[22:28] <svnbot6> r9250 | fglock++ | iterator_engine - updated TODO list - putter++

[22:31] <fglock> putter: a macro is just like a source filter; macro statement_control:<if> {...} is probably setting an element in the hash %statement_control in the p6 compiler namespace

[22:32] <fglock> %statement_control:<if> actually 

[22:33] <fglock> it will look like: %statement_control:<if> = rule { ... }

[22:34] <putter> it has to be a is_parsed and string-returning (not code-returning) macro, yes?

[22:35] <fglock> in i_e, it is supposed to return AST. but a macro can return either string or AST (no code)

[22:37] <fglock> macros that return string will be more portable - I don't think there will be an official AST for all compilers

[22:37] <fglock> so AST is for internal use only

[22:40] <putter> ah.  have to go.  enjoy.

[22:40] <putter> &

[22:40] <fglock> &

[22:42] *** fglock left
[22:42] <svnbot6> r9251 | fglock++ | iterator_engine - pasted some comments 

[23:03] *** nothingmuch joined
[23:04] <nothingmuch> moose

[23:04] <nothingmuch> audreyt: ping

[23:11] <beppu> stupid question perhaps, but will perl6 allow us to use chars like '!' and '?' in subroutine names?

[23:14] <mauke> probably yes, because perl5 does it

[23:16] <integral> yes, but perl5 allows "\0" in subroutine names.

[23:23] *** frederico joined
[23:29] *** TMTOWTDIt left
[23:31] <beppu> mauke, how does perl5 allow it?  I didn't think it did.

[23:31] <beppu> can you post an example?

[23:32] <mauke> *{"!"} = sub {"y helo thar"};

[23:32] <beppu> how do you call it afterwards?

[23:32] <mauke> *{"!"}->()

[23:33] <beppu> I see...  what I really wanted to be able to do was say things like:  if ($block->is_filled?) { ... }

[23:33] <beppu> with the ? being part of the method name./

[23:34] <beppu> I didn't want to have to use typeglobs for this.

[23:34] <mauke> heh, scheme style

[23:34] <beppu> yeah.  :)

[23:35] <mauke> wouldn't that clash with operators?

[23:35] <beppu> I think it would, but I figured it wouldn't hurt to ask.

[23:37] <mauke> hmm, it shouldn't be too hard to write a lisp skin for perl 6

[23:37] <mauke> or perl 5, for that matter

[23:39] <beppu> no source filters for me.

[23:39] *** azuroth joined
[23:39] *** Southen joined
[23:39] <avar> integral: perl is pretty liberal about the names of everything

[23:40] <avar> ${'Woo, variable with spaces!'} = 5;

[23:43] <beppu> but you have to turn strict refs off, right?

[23:45] <avar> no

[23:45] <mauke> yes

[23:45] <mauke> er, wait

[23:45] <avar> bleh, yes

[23:48] <beppu> ;)

[23:49] <beppu> we should steal back from ruby and allow '?' and '!' at the end of method names.

[23:50] <beppu> PS: has anyone noticed the similarity between `perl -h` and `ruby -h`.  I think that's cool.

[23:53] <obra> beppu: or just go hardcore and use _p (predicate) instead of ?

[23:54] <beppu> that's not as cool.  ;)

[23:54] <beppu> perl and sigils belong together.

[23:57] *** samuel joined
[23:57] <avar> I like ! a lot

[23:57] <avar> .chomp! str

[23:57] <avar> eh

[23:57] <avar> str.chomp!

[23:58] <avar> what does ? do again?

[23:58] <mauke> returns a bool

[23:58] <avar> perl 6 has that

[23:58] <avar> if (?foo) ..

[23:58] <avar> IIRC

[23:59] <avar> along with ~ for a scalar cast..

