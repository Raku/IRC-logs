[00:00] *** dduncan joined
[00:12] <geoffb> Is there a way to convince pugs to do inlining?  "is inline" seems to be ignored, but I may just be doing something wrong ....

[00:24] <fglock> geoffb: it depends on the backend - I think it is just ignored in all of them

[00:24] <geoffb> blurfle

[00:25] <arcady> I think it's kind of premature optimization at this point

[00:33] <geoffb> arcady, it's not so much about getting it optimized now, but rather getting the kinks out of the implementation, so that it will work later.

[00:33] <geoffb> methinks inlining is not as trivial a beast as it may at first seem

[00:35] <arcady> it's some kind of macro, isn't it?

[00:36] <buu> Hrm. Anyone know which op is executed at the end of a loop? It looks like the redo one would be..

[00:49] <geoffb> arcady, I suppose, in a sense.  But if the inlined function body actually creates and uses new variables (rather than restricting itself to its parameters), there's some magic that must happen.

[00:53] <svnbot6> r9969 | fglock++ | PG-P6 - added num, int, method-call

[00:53] <fglock> a simple parser doesn't know enough about the variables to make inlining - it requires to know the variable types at compile time

[00:54] <fglock> but the optimizer can do that

[00:56] *** frederico joined
[01:00] *** fglock joined
[01:07] *** justatheory joined
[01:22] <stevan> audreyt ingy - ping

[01:24] <audreyt> pong.

[01:24] <stevan> audreyt: any more details on the yapc::na hackathon?

[01:25] *** oylenshpeegul joined
[01:25] <audreyt> stevan: er, no, I'm afraid

[01:25] <audreyt> we need a non-ADD person to be organizer

[01:26] <stevan> audreyt:  :)

[01:26] * stevan wonders where we might find one of those,.. 

[01:26] <audreyt> I'll call for one in today's journal :p

[01:26] <stevan> I put together a tentative attendee list on the YAPC Wiki

[01:26] <audreyt> I saw that

[01:27] <stevan> I figured you were a safe bet for attending ;)

[01:28] <audreyt> that would be correct

[01:28] <audreyt> why don't you just write out your available dates

[01:28] <audreyt> on the wiki

[01:28] <audreyt> and I'lldo the same

[01:28] <stevan> I am pretty much available anytime surrounding YAPC::NA actually

[01:29] <audreyt> then write that

[01:29] <audreyt> :)

[01:29] <stevan> k

[01:29] <obra> audreyt: I've been working with josh to figure hackathoon stuff out

[01:29] <obra> assuming the 3 days after the conf as discussed in .jp

[01:29] <obra> sounds like most of @larry will be there

[01:30] <stevan> obra: nice :)

[01:30] <obra> Josh cced ingy on the most recent stuff, but i haven't seen anything back

[01:31] <obra> stevan: who's on your attendee list?

[01:31] <stevan> http://yapcchicago.org/wiki/index.cgi?HackAThon

[01:31] <stevan> just a rough list of people I know are planning on attending

[01:32] <obra> (also, was this the pre-hackathon or the post-hackathon?)

[01:32] <obra> I heard rumors that a pre-hackathon was also happening

[01:33] <stevan> obra: my list was post, as that was what audreyt told me was most likely

[01:33] <obra> ok

[01:34] <stevan> obra: maybe once you hear back from ingy we should send out a mail to those on that list

[01:35] <stevan> and an announcement on p6(lang|internals|compiler)

[01:35] <obra> nod. I'm also waiting to hear from josh about possible venue size

[01:35] <audreyt> previously we used p6l/p6c for coordination

[01:35] <stevan> that seemed to work well in Toronto

[01:35] <obra> It's my assumption that hte hackathon will NOT provide crashspace by default

[01:35] * stevan pictures an arena size hackathon,.. with laser light show and everything

[01:35] <audreyt> heh

[01:36] <audreyt> obra: not sure how sizable ingy's place is

[01:36] <obra> audreyt: josh suggested that ingy's place was far out of town

[01:36] <obra> and it sounded like @larry folks were talking about just extending their hotel stays.

[01:37] <audreyt> that worksforme also.

[01:37] <stevan> I wonder if the dorm rooms are available post-conference?

[01:37] <audreyt> if ingy's space isn't as roomy as dankogai's

[01:37] <audreyt> then staying near the dorm is definitely better plan.

[01:38] <obra> audreyt: I think this will be a larger hackathon

[01:38] <audreyt> understood

[01:38] <audreyt> I may be able to arrive pre conference

[01:38] <audreyt> but that depends on the details of Redmond hackathon

[01:39] <audreyt> which we are also still working out detail of

[01:39] <obra> nod

[01:39] <obra> when do you need to have left boston by?

[01:39] <stevan> and are you guys still planning an east coast/boston one as well?

[01:39] <obra> I've got an office to offer

[01:39] <obra> also, some crash space

[01:39] <svnbot6> r9970 | fglock++ | PG-P6 - parses 14 files out of 19 in t/01-sanity

[01:40] <audreyt> stevan: yes, was planning for a back-to-back hackathon during that weekend

[01:40] <stevan> obra: I got some peeps in boston too

[01:40] <fglock> hi

[01:40] <stevan> hey fglock

[01:40] <audreyt> for 2-3 days probably

[01:40] <obra> in my ideal world, it'd start in boston on 6 July

[01:40] <audreyt> 6-8 worksforme

[01:40] <audreyt> then I will need a ^C

[01:40] <obra> (Kaia leaves for nyc on or about 5 july

[01:41] <audreyt> obra: I'll still stay at Boston after 8th

[01:41] <obra> audreyt: 6-8 in boston would give you a couple days of rest between hackathons

[01:41] <stevan> I could probably do 6-8 too

[01:41] <obra> audreyt: excellent. I'll have lots of cycles since ENOKAIA

[01:41] <audreyt> but probably will do something nonpugs-related for a few days

[01:41] * obra has ideas ;)

[01:41] <audreyt> like Reality :)

[01:42] * obra grins

[01:42] <audreyt> or jifty ;) but that can spotaneously happen ;)

[01:42] <obra> "jifty based reality framework"

[01:42] <audreyt> "another reality framework?"

[01:42] <obra> "Reality 2.0"

[01:42] <stevan> kind like Web 2.0, only better?

[01:43] <audreyt> more real

[01:43] <obra> also, boston is a good place to be for 4 july, if you're into that

[01:43] <obra> good fireworks. lots of jingoistic nationalism

[01:43] <audreyt> er I've seen my share of fireworks.

[01:43] *** hexmode joined
[01:43] <audreyt> and nationalism totally kills me.

[01:43] <audreyt> so no thanks :)

[01:43] <obra> aw

[01:43] * stevan pushes tea into the harbor and runs away

[01:44] <obra> that might have done good stuff to the harbor back in the day.

[01:44] <audreyt> runHarbor :: HarborT (m a) -> m a

[01:47] *** oylenshpeegul left
[01:50] *** mjk joined
[01:50] <fglock> audreyt: I moved most of the parser to Parse::Yapp - only the tokenizer uses PCR

[01:51] <audreyt> k

[01:52] *** FurnaceBoy_ is now known as FurnaceBoy

[01:53] <fglock> there is only a few difficult things left to implement

[02:01] <TimToady> audreyt: I don't mind turning the singular into the only invocant, but if we're gonna do that, I think it's time to rethink all the terms.  I don't like "tie-breakers" either.

[02:02] *** justatheory joined
[02:02] <TimToady> self/others or one/many or some such

[02:02] <TimToady> who/what/how

[02:02] <TimToady> just brainstorming here...

[02:03] <TimToady> needs to sit a while longer rattling around in my brain.

[02:04] <TimToady> sultan/wives/harem  :)

[02:05] <TimToady> bigcheese/assistants/lackeys :)

[02:05] <svnbot6> r9971 | fglock++ | PG-P6 - parses 07-simple-multisubs.t

[02:07] <TimToady> I'm also thinking about whether turning off backtracking in rules means .* doesn't backtrack or is illegal, and you have to say .*: or .*+ or .*?

[02:08] <audreyt> .*: is almost always useless

[02:09] <TimToady> s/\./\\d/ or whatever

[02:09] <TimToady> I'm not talking about .

[02:09] <TimToady> I'm talking about whether * should default to not backtrack or be illegal in rules

[02:10] <TimToady> \d+ is how people are used to writing things, but they're also used to that notation backtracking.

[02:10] <TimToady> having it backtrack in rx and not backtrack in rules is a problem.

[02:10] <audreyt> oh. in that case, having \d+ mean \d+: may be nonintuitive

[02:10] <TimToady> so I'm wondering if rules just want to outlaw the * form by default.

[02:10] <audreyt> and it might be nice to have quantifier always subquantify

[02:10] <TimToady> or the + form or the ? form

[02:10] <audreyt> or explicitly use an adverb

[02:11] <audreyt> rule:commit{ \d+ }

[02:11] <TimToady> I think adverbs are a Haskell "try" waiting to happen.

[02:11] <audreyt> it is exactly the same, actually.

[02:11] <audreyt> (so, prolly bad idea)

[02:11] <audreyt> but we do need some sort of "try" in an backtrack-by-default world

[02:12] <TimToady> I think we need to disable backtracking on some large scope, grammar or rule or lexical scope, and then reenable it on the smallest *+ or ++ or ?+ scope

[02:12] <audreyt> but what if I have

[02:12] <audreyt> \d+\w+

[02:12] <TimToady> or [a|b|c] scope

[02:13] <audreyt> and I want to backtrack over that as a whole?

[02:13] <audreyt> [\d++ \w++ :]

[02:13] <TimToady> \d++\w++ works

[02:13] <audreyt> nod.

[02:13] <TimToady> but I'm also starting to worry with reusing all the *+? characters to mean something entirely different in the second spot.

[02:14] <TimToady> maybe it's okay.

[02:14] <audreyt> mm.

[02:14] <audreyt> what does \d++ mean again?

[02:14] <TimToady> but we now have ?? **{} and ++

[02:15] <TimToady> and in each case the second means something entirely else than the first

[02:15] <TimToady> \d++ means do what \d+ would do normally if we hadn't disabled backtracking.

[02:15] <TimToady> likewise **{}+ would mean backtrack the **{}

[02:16] <TimToady> also it's notationally wrong to say [a|b|c]+ to mean that, so it'd

[02:16] <TimToady> have to be [...]:+ or some such.

[02:17] <TimToady> and then I wonder if the force backtracking is really :? :+ for minimal/greedy

[02:17] <TimToady> and *+ is really short for *:+

[02:17] <TimToady> and *: is just the form that doesn't happen to turn backtracking back on

[02:17] <TimToady> because not followed by ? or +

[02:18] <TimToady> then [...]:+ and [...]:? fall out naturally, though the latter would presumably mean match the alternatives in reverse!

[02:18] <TimToady> another thing rattling around in my head is that everywhere else in the language now, | means unordered and || means ordered.

[02:19] <TimToady> except in [a|b|c]

[02:19] <TimToady> so maybe we don't need the [...]:+ form for backtracking if | vs || means that.

[02:19] <TimToady> but that's probably confusing ordering with backtracking.

[02:20] <TimToady> one thing I've currently got in my version of S05 is that

[02:20] <TimToady> <%h1|%h2|%h3> does longest token across all three hashes.

[02:21] <TimToady> but ties are resolved in favor of earlier hash.

[02:21] <audreyt> that sounds sane.

[02:21] *** cmarcelo left
[02:21] <TimToady> currently S05 has keys of <%h1> being rules, but I think that's insane.

[02:22] <TimToady> I think if you have a rule that's partly fixed prefix and partly rule, the fixed part goes in the key and the rest goes in the value.

[02:22] <audreyt> sure

[02:22] <TimToady> rather than trying to rely on the rx optimizer to pull out the fixed prefix for us, and then what to you do with ties?

[02:23] <TimToady> but I think I like the <%a|%b|%c> notation rather than trying to define a magical <%magichash> that does that.

[02:23] <TimToady> and then <%statement_control|%prefix|%term> and such just fall out naturally.

[02:24] <audreyt> yup

[02:25] <TimToady> so I'd check that part in except I'm still wondering whether bare * ever means "don't backtrack" by default.

[02:25] <TimToady> pm says he doesn't mind writing the colons, so maybe we just force *: most of the time.

[02:26] <TimToady> I guess that means forcing [a|b|c]: too though.

[02:27] <TimToady> and [a|b|c]:+ explicitly allows backtracking in to the next alternative.

[02:29] <TimToady> but then maybe the proper place for disabling backtracking is not in rule but in grammar.

[02:30] <TimToady> I dunno.

[02:30] * audreyt decides to think abnout it more and go to $job in the meanwhile

[02:30] <svnbot6> r9972 | fglock++ | PG-P6 - parses 07-try.t

[02:30] <TimToady> I see we might have a lot of singleton rules mixed into a grammar, and they probably want to be restricted too.

[02:30] *** FurnaceBoy_ joined
[02:31] <TimToady> no problem.  I'm just mulling it over myself.

[02:31] <TimToady> I may just check in my mullings with some conjectural markings.

[02:32] <fglock> 16 pass out of 19 in t/01-sanity

[02:32] <audreyt> fglock!

[02:32] <audreyt> wow!

[02:32] <TimToady> fglock: we'll have to do something about that... :)

[02:32] <audreyt> how do I run the sanity test with PGP6 again?

[02:33] <fglock> perl -Ilib perl6.pl ..\..\..\..\t\01-sanity\filename.t

[02:33] <TimToady> off to scrounge supper... &

[02:34] <dduncan> audreyt, regarding a backlog to 1 hour ago, did I read that right to say that you *will* be in YAPC::NA Boston?

[02:34] <dduncan> or is this hackathon in Canada nearby?

[02:35] <obra>   Boston and YAPC::NA are only loosely coupled

[02:36] <dduncan> In any event, I just recalled that audreyt wasn't going to visit the US anymore due to poor treatment at the borders

[02:36] <fglock> YAPC::Brasil starts in 3 days

[02:36] <dduncan> will recheck url ...

[02:36] <obra> She's visiting the US

[02:36] <fglock> YAPC::SouthAmerica will be in november

[02:36] <audreyt> dduncan: yeah, but stevan didn't make it to Tokyo

[02:36] <dduncan> so you're making an exception?

[02:37] <dduncan> in any event ...

[02:37] <audreyt> dduncan: so the need for hacking with stevan overruled the uncomfortableness

[02:37] <dduncan> I was wondering if there might be an opportunity for us to meet without my having to leave NA to do it

[02:37] *** oylenshpeegul joined
[02:38] <dduncan> though this summer is probably too soon for me to venture to the eastern continent ... who knows

[02:38] <dduncan> anyway, that's all I wanted to know for now

[02:38] <fglock> audreyt: did you manage to run the sanity test?

[02:46] <audreyt> fglock:

[02:46] <audreyt> Deep recursion on subroutine "Pugs::Runtime::Match::scalar" at /home/autrijus/work/pugs/misc/pX/Common/Pugs-Grammar-Perl6/../Pugs-Compiler-Rule/lib/Pugs/Runtime/Match.pm line 72.

[02:47] <audreyt> nvm, my fault

[02:47] <svnbot6> r9973 | audreyt++ | * v6.pm - jump to .pmc when possible.

[02:48] <audreyt> fglock:

[02:48] <audreyt> Can't locate Pugs/Grammar/Postcircumfix.pm in @INC

[02:48] <svnbot6> r9974 | audreyt++ | * perl6.pl: use FindBin to relocate lib.

[02:48] <audreyt> you forgot to add it?

[02:48] <fglock> adding...

[02:49] *** DesreveR joined
[02:51] <svnbot6> r9975 | fglock++ | PG-P6 - add Postcircumfix.pm

[02:51] <audreyt> I see a parse tree

[02:51] <audreyt> how do I run it?

[02:52] <fglock> that's all of it

[02:52] <fglock> PG-P6 is just the grammar

[02:52] <audreyt> oh, emitter isn't hooked yet

[02:52] <audreyt> gotcha.

[02:53] <fglock> this forces modularity :)

[02:53] <audreyt> very true.

[02:53] <audreyt> fglock++

[02:53] <fglock> I'd like the AST to be a separate module - not sure how to do this yet

[02:54] <audreyt> we also need to talk/gobby about AST sometime this weekend

[02:54] <audreyt> I think I have a fairly complete picture now.

[02:54] <audreyt> esp. now that what := means is clear, and BEGIN desugaring is explicit

[02:54] <fglock> sure

[02:55] <audreyt> ooh, summer of code is coming again

[02:55] <audreyt> fglock: submit a SoC? :) you are actually eligible...

[02:55] <fglock> btw, I sent the P6 project to TPF

[02:56] <audreyt> it's $4500 though

[02:56] <audreyt> nod, cool

[02:57] *** beppu_ joined
[02:57] <fglock> I'll take a look :)

[02:58] <buu> Hrm, is there a warn or print function I can call from inside the sourc.e.

[02:58] <buu> Oh, hrm. Wrong channel.

[02:58] <buu> Actually,t hey won't know either

[02:58] <buu> Oh well.

[03:00] <audreyt> from inside the source?

[03:01] <beppu_> does perl6 have the equivalent of ruby's .method method?  (It tells you what all an objects methods are.)

[03:01] <ayrnieu> beppu - perl6 has .meta

[03:02] <audreyt> it's called .meta.methods

[03:02] <beppu_> ah..

[03:02] <audreyt> but somehow it's spelled .meta.getmethods in S12

[03:02] <audreyt> in any case, no matter the API name, yes. :)

[03:03] * beppu_ bought more ram so his computer so that he could finally compile pugs.

[03:03] <beppu_> s/so/for/

[03:03] <audreyt> :)

[03:03] <audreyt> (bbl...)&

[03:07] *** fglock left
[03:10] <geoffb> beppu_, a few months ago, that was the very reason for buying an entirely new machine.  (The old one didn't support big enough RAM sticks so that I could add enough RAM for Pugs :-)

[03:12] *** coumbes joined
[03:16] *** FurnaceBoy joined
[03:27] *** hlen_ joined
[03:47] *** oylenshpeegul left
[03:51] <beppu_> geoffb, :)

[03:58] *** macroron joined
[04:26] *** weinig is now known as weinig|sleep

[04:40] *** nirgle joined
[04:59] <gaal> stevan &co. - even if nothing else is known, by all means let's get the dates set so that people can plan their trip

[05:00] <gaal> also it could be nice it we booked at the same hotel during the conf...

[05:15] *** nirgle left
[05:18] <gaal> I prefer it to be, well, as long as possible for our hosts :)

[05:31] <svnbot6> r9976 | gaal++ |  r10025@sike:  roo | 2006-04-17 08:27:16 +0300

[05:31] <svnbot6> r9976 | gaal++ |  * FAQ::Capture - copyediting. TODO: make consistent the use

[05:31] <svnbot6> r9976 | gaal++ |    of "fail" vs. "error", in all our docs and not just here.

[05:49] <svnbot6> r9977 | Darren_Duncan++ | ext/Relation/ : added initial 2 Relation.pm class attributes, initial constructor submethod and full-export method, and pod on all of those plus on what a Relation object represents ... not yet tested

[05:51] <dduncan> so if that compiles and executes properly, it constitutes the bare minimum of a Relation implementation in Perl 6 ...

[05:52] <dduncan> the next task is to add methods for relational algebra, including some that loosely resemble SQL operators

[05:52] <dduncan> and anything applicable from the Set class

[05:54] <dduncan> I would probably like to reimplement the attribute that stores the member tuples with a multi-dimensional hash, keyed on all the attributes, but I have to figure out the details first; meanwhile, it is an array of hashes

[05:55] <dduncan> also, the number of dimensions and their types would vary for each Relation object, so I can't pre-declare those in the class

[05:55] <dduncan> that's all for me today

[06:00] <gaal> ruz: and now?

[07:18] <buu> Blah blah blha.

[07:29] *** dduncan left
[07:44] *** Aankhen`` joined
[07:45] *** lidden joined
[07:53] *** elmex joined
[07:55] *** tcliou joined
[07:56] *** iblechbot joined
[08:18] *** drrho joined
[08:34] *** ardder joined
[08:38] *** kakos joined
[09:06] *** KingDiamond joined
[09:16] *** larsen joined
[09:21] *** marmic joined
[09:39] *** pmurias joined
[09:40] *** premshree_ joined
[09:44] *** iblechbot joined
[10:05] <pasteling> "ruz" at 213.251.192.51 pasted "error in the latest audrey's blog entry" (4 lines, 109B) at http://sial.org/pbot/16769

[10:09] *** KingDiamond joined
[10:17] <gaal> ruz: already fixed in svn

[10:17] <gaal> did the invite reach you?

[10:24] *** bsb joined
[10:27] <spinclad> audreyt, TimToady: i would suggest "discriminant parameters" to replace "invocant parameters" (over "tiebreaking")

[10:28] <spinclad> and "multi-level discrimination"

[10:28] <spinclad> as we are discriminating which multi gets the call (and i would think of "tiebreaking" as what happens after the easy discrimination is done)

[10:28] <spinclad> but maybe this is too latinate...

[10:35] <gaal> spinclad: shibboleth parameters is semitic.

[10:35] <ruz> gaal: only note that I was added to the members of the project, I have login on openfoundry allready, but password reminder doesn't work :(

[10:36] <gaal> ruz: ugh, need a metametacommitter to fix that

[10:36] <gaal> gugod: ping

[10:37] <gaal> (/me notes with amusement that he'd pronounce that word differently from what its English spelling suggests, it its original language.)

[10:38] <gaal> (the final consonant is a [t], not a either [th] sound)

[10:40] <spinclad> gaal: hm.. shibboleth might work, for one-way discriminations, like (match err die)

[10:42] <spinclad> (/me thought that [t] was a modern pronunciation, and without a dot it would have been pronounced as a fricative)

[10:42] <spinclad> (thus yiddish [s])

[10:44] <spinclad> s/thus/developing into/

[10:45] <gaal> spinclad: yiddish pronunciation is, well, just that; the two /tav/ variants in biblical pronunciation -- for all we know -- is much closer to traditional yemenite speech

[10:46] <gaal> or even modern spoken israeli hebrew.

[10:46] <spinclad> how do they work in yemenite speech?

[10:48] <gaal> [t] and soft [th]

[10:50] <spinclad> not sure what 'soft' would mean here -- is it something conveyable in text?

[10:51] <spinclad> i presume still unvoiced, like english 'thing' (as opposed to voiced [dh] in english 'the')

[10:51] <gaal> sure, th like in "thin" vs "hard" th like in "this"

[10:51] <gaal> yes.

[10:53] <gaal> actually, come to think of it I'm not sure scholars agree yemenite pronunciation is in fact the closest one to whatever was spoken here in biblical time.

[10:55] <gaal> not sure if any group of current speakers has a clear "better" claim, but it's almost certainly not the European, Ashkenazi, version

[10:56] <gaal> ("dialect" is too broad here, since the lexicon perhaps isn't that different)

[10:59] <spinclad> [soft = unvoiced, and fricative] ok... that matches what i've learned, for what it's worth

[11:01] <lumi> I thought the Yemenite sound was an aspirated T?

[11:02] <spinclad> likely the scholarship of reconstructing biblical pronunciation was aware and relied on yemeni pronunciation

[11:04] <spinclad> aspirated, like in Indic languages?  th = aspirated stop, like mea_th_ead (roughly)?

[11:05] <lumi> Not that strongly, but yeah

[11:05] <lumi> I might be way off base

[11:06] <lumi> Actually, in RP I think the T stop is usually aspirated

[11:06] <lumi> Although I might be talking crazy

[11:07] <spinclad> [usually aspirated] true, as you can hear comparing with romance pronunciation

[11:08] <spinclad> french and spanish stops, at least, are unaspirated compared to english

[11:09] <lumi> Hebrew ones as well, for most speakers

[11:11] <spinclad> [note to topic police: all this relates to "invocant parameters", and how to pronounce them]

[11:11] <spinclad> [so it's ok]

[11:12] <lumi> So now we know the T in "invocant" is aspirated!

[11:12] <spinclad> no, that's a final t, so it's implosive (as well as nasalized)

[11:13] <lumi> Oh, right

[11:16] <spinclad> anyway, thanks, gaal, lumi -- breakfast calls &

[11:25] *** cm joined
[11:25] *** yvesf joined
[11:27] <gaal> is that a single or multi egg call?

[11:40] *** Mago joined
[11:57] <gugod> gaal: hi there

[12:00] *** _bernhard joined
[12:02] <gaal> gugod: hello, ruz reports that the "password reminder" feature on OpenFoundry doesn't work; could you reset his password please?

[12:03] <gugod> gaal: whoot, ok, I will check it out

[12:04] <gaal> thanks! :)

[12:06] *** lichtkind joined
[12:13] <svnbot6> r9978 | fglock++ | PG-P6 - parses all files in t/01-sanity; doesn't parse Test.pm yet

[12:17] *** kolibrie joined
[12:19] *** nothingmuch joined
[12:21] *** weinig|sleep is now known as weinig

[12:25] *** Limbic_Region joined
[12:31] *** jserv-- joined
[12:46] <spinclad> single or multi egg call: multi, distributing to two singles: we had one each.

[12:54] *** beppu_ joined
[12:55] <audreyt> spinclad: wha?

[12:55] <svnbot6> r9979 | audreyt++ | * Perl6::FAQ::FUD - the "fears" FAQ

[13:01] <gaal> "Questions end in exclamation points"!

[13:02] <gaal> re: the first question, the first sentences in the first two paragraphs seem to be at odds:

[13:02] <gaal> 1. Perl 6 has a few more operators than Perl 5

[13:03] <gaal> 2. The number of operators has greatly increased

[13:03] <gaal> will whoever added that response please moderate :)

[13:03] *** bsb joined
[13:06] <audreyt> done :)

[13:06] <svnbot6> r9980 | audreyt++ | * FUD.pod: moderation is good, in moderation.

[13:06] <svnbot6> r9980 | audreyt++ |     (gaal noted inconsistency in the first answer about

[13:06] <svnbot6> r9980 | audreyt++ |      whether Perl 6 has many more operators than Perl 5 or not.)

[13:06] <svnbot6> r9979 | audreyt++ | * Perl6::FAQ::FUD - the "fears" FAQ

[13:07] <gaal> is immoderation good in immoderation?

[13:07] <audreyt> I s'pose so

[13:08] <audreyt> gaal: I can't parse your Capture.pod Q

[13:08] <audreyt> my $cap = \(); (sub ($x = 2) { $x }).(*$cap);

[13:08] <audreyt> $cap is immutable, and $x gets 2.

[13:08] <audreyt> what is inconsistent (or strange) here?

[13:09] <gaal> you mean about optional args? that's geoffb's Q

[13:09] <gaal> the question is:

[13:09] <gaal> sub f ($aaa, $bbb? = 42);

[13:09] <gaal> my $cap = \(aaa => 54);

[13:10] <gaal> of course $cap does not contain bbb, how could it know of it?

[13:10] <audreyt> the answer is it doesn't

[13:10] <audreyt> ($aaa, $bbb? = 42) := (aaa => 54);

[13:10] <gaal> alright, then the question is more elaborately,

[13:10] <audreyt> the LHS Signature knows of $bbb

[13:10] <audreyt> the RHS Capture does not

[13:11] <audreyt> the Signature inquires Capture of a named bbb or a positional

[13:11] <audreyt> it offers neither

[13:11] <audreyt> so it gets the default

[13:11] <audreyt> mutability doesn't enter the picture

[13:11] <gaal> if I want to write code from outside &f that'll predict what &f's actual args will be, what do I need to do?

[13:11] <audreyt> predict? :)

[13:12] <audreyt> you mean something like

[13:12] <gaal> audreyt: ACK on mutability, I think I was confusing geoffb by insisting that the make_car example contain an optional color arg

[13:13] <gaal> yes, I can imagine a highly introspective environment that wants to know e.g. what lexicals will be in some scope

[13:14] <audreyt> &f.assuming(aaa=>54).bound.<bbb>;

[13:14] <audreyt> or some such?

[13:14] <audreyt> I don't think we have APIfor that

[13:14] <gaal> one way to do that is to write generic delegators like the example in the FAQ, but that doesn't know about default values

[13:15] <gaal> s/like/that produce things like/

[13:15] <gaal> it's okay if we don't have API for it *yet* :)

[13:16] <audreyt> cool :)

[13:16] <stevan> morning ladies,.. gentlemen

[13:16] <audreyt> gaal: it is also possible to think

[13:16] <bsb> audreyt: did $capture ~~ $signature fly?

[13:16] <audreyt> &f.signature.bind(aaa=>54).<bbb>

[13:16] <stevan> gaal: I am staying in the dorms@YAPC::NA, just FYI

[13:17] <audreyt> will simply return 42.

[13:17] <audreyt> bsb: I don't see why not

[13:17] <cognominal> audreyt, last years I propose a pmc called siva that had at once hash, scalar and arrays capabilities. I was thinking it was a starting place to implement AST nodes or XML nodes. I am not sure how capture are implemented in parrot, but I think that something like the siva pmc would be nice.

[13:17] <audreyt> TimToady: can we get

[13:17] <bsb> Or are there bigger plans for signatures and rules?

[13:18] <cognominal> I can try to revive that code that Leo did not integrate to parrot.

[13:18] <audreyt> $sig ~~ $cap # match if $sig.bind($cap)

[13:18] <Limbic_Region> audreyt - does Pugs currently support binding to a stream/array as outlined in S05 ?

[13:18] <audreyt> cognominal: woooot

[13:18] <audreyt> Limbic_Region: Pugs currently doesn't support any of the newer binding semantics

[13:18] <cognominal> probably the pmc layout has changed in the mean time

[13:18] <audreyt> I'll see to it :)

[13:19] <Limbic_Region> adureyt - note the confused look on my face

[13:19] <Limbic_Region> err audreyt even

[13:19] <gaal> dorms? oh, I wasn't aware those were available. /me looks

[13:19] *** hexmode joined
[13:19] * stevan thought Limbic_Region just was having gas

[13:19] <Limbic_Region> binding to a stream has been part of p6 since the beginning AFAIK - even if the semantics weren't worked out?

[13:19] <audreyt> Limbic_Region: oh you don't mean binding

[13:19] <audreyt>  $stream ~~ m/pattern/

[13:19] <audreyt> you mean smart matching

[13:19] <audreyt> the answer is that we don't support

[13:19] <audreyt>  my $stream is from($fh);

[13:20] <audreyt> so you can't get a stream

[13:20] <Limbic_Region> I mean the section in S05 entitled Matching against non-strings

[13:20] <Limbic_Region> ok

[13:20] <cognominal> shorten http://groups.google.com/group/perl.perl6.internals/browse_thread/thread/aa4affe6c09558c3/679d42dee8ab722f?_done=%2Fgroup%2Fperl.perl6.internals%2Fthreads%3Fstart%3D30%26&_doneTitle=Back&&d

[13:20] <Limbic_Region> perlbot help

[13:20] <perlbot> (fact)::tell (who) about (what)::(what) > (who)::learn (what) as (info)::relearn (fact) as (info)::phone (phone number)::shorten (url)::shorten it::search (module)::docs (module)::perldoc -f (function)::jargon (term)::math::fortune::flip::host (type) (record)::rot13::roll (die)::tempconv (temp)::scramble (foo)::8ball::slap::diss::what time is it::top/bottom (number) karma::geoip (ip)

[13:20] <Limbic_Region> cognomial - prefix what you just said with perlbot and it will work

[13:20] <audreyt> Limbic_Region: the from('file') form is never specified anyway

[13:21] <bsb> Limbic_Region: I don't think that section of S05 is very clear yet

[13:21] <audreyt> I have no idea what it means

[13:21] <Limbic_Region> bsb - I agree which is why I asked

[13:21] <cognominal> perlbot shorten http://groups.google.com/group/perl.perl6.internals/browse_thread/thread/aa4affe6c09558c3/679d42dee8ab722f?_done=%2Fgroup%2Fperl.perl6.internals%2Fthreads%3Fstart%3D30%26&_doneTitle=Back&&d

[13:21] <perlbot> Shortened URL: http://xrl.us/kvo7

[13:22] <Limbic_Region> this all started with a conversation I had on #perl a few days ago with "What does awk do better than Perl"

[13:22] <Limbic_Region> I got a bunch of "blasphemy" replies as apparently no one had read perlvar closely enough (see $/ for explanation)

[13:22] <Limbic_Region> I said - this of course is fixed in p6

[13:22] <Limbic_Region> and then I went to find the docs that said so

[13:22] <Limbic_Region> and went - hrmmm

[13:23] <spinclad> audreyt: [re wha?:] see above, 1 1/2 hour before...

[13:23] *** Qiang joined
[13:24] <Limbic_Region> and since pugs is so good at fleshing out stuff - I was wondering

[13:25] <bsb> It seems like backtracking + streams is a nasty combination

[13:25] <theorbtwo> bsb: It just requires buffering from where you were at the beginning of the parse until the parse finishes.

[13:25] <bsb> A regex that can be converted to a DFA might be better

[13:25] <audreyt> bsb: parsec does that all the time :)

[13:26] <bsb> and default greedy, one .* and you've read the whole stream/file

[13:27] *** fglock joined
[13:28] <pmurias> hi fglock

[13:28] <fglock> pmurias: hi!

[13:28] <bsb> audreyt: is Parsec equivalent to regexen in that regard?

[13:29] <audreyt> bsb: sure

[13:29] <bsb> (maybe the user just need to be careful writing the regex)

[13:29] <audreyt> many anyToken

[13:29] <audreyt> # always slurps anything

[13:30] <audreyt> (or "many anyChar" under CharParser)

[13:30] <pmurias> fglock: have you seen my realy ugly emitter

[13:30] <pmurias> ?

[13:31] <fglock> yes - nice!

[13:31] <Limbic_Region> bsb - if you are interested, there are several nodes at the Monastery discussing this (as well as some implementations) in p5

[13:31] <bsb> Limbic_Region: sure

[13:31] <Limbic_Region> ok - will dig them up

[13:32] <audreyt> pmurias: how do I run sanity tests against the emitter?

[13:33] <pmurias> the current problem is that the emitter needs hand modified ast

[13:33] <Limbic_Region> bsb - [id://225083] [id://298436] [id://298971]

[13:34] <pmurias> i could either write a connector with the parser, or some initial ast design must be made

[13:34] <Limbic_Region> bart was apparently very vocal on the topic back in the RFC days of p6 but his idea was rejected

[13:34] <audreyt> pmurias: care to elaborate a bit (and point me to the code to look)?

[13:34] <audreyt> pmurias: connector-with-parser sounds sane

[13:35] <Limbic_Region> his idea being a flag that could force a failure under certain circumstances

[13:36] <gaal> ah, speaking of parsers, that packrat tech is unfortunately probably not applicable for us

[13:37] <gaal> because it doesn't do well in cases where the parser is very stateful

[13:38] <audreyt> indeed

[13:38] <audreyt> (I've looked at SDF2 and packrat before)

[13:38] <audreyt> SDF2 is very interesting by itself, though

[13:39] <gaal> does anyone have a taxonomy of parsers somewhere? that would be so nice

[13:42] <bsb> gaal: Chomsky had one laying around

[13:42] <pmurias> http://nopaste.snit.ch:8001/6959 - ilustrates the problem with the current AST

[13:43] *** Aankhen`` joined
[13:43] <gaal> heh heh heh, "a taxonomy of parsers" in fact sounds like a proper mass nount

[13:43] <gaal> s/t$//

[13:43] <kolibrie> stevan: re YAPC::NA, which dorms are you in, MSV or SSV?

[13:44] <gaal> http://search.cpan.org/src/TBONE/Parse-RecDescent-FAQ-5.00/code/grammar-classes.tt

[13:45] <pmurias> fglock: the basic insconsistency with the ast is that it both takes {exp1=>1,exp2=>2,op1=>'+'} and {if=>{exp=>...,block=>...}} forms

[13:46] <fglock> should it be exp1=>'if' instead?

[13:47] <fglock> I mean op1=>'if'

[13:48] <pmurias> what does the 1 after op mean?

[13:48] <fglock> op2=>'else', exp1=>block..., exp2=>block...

[13:48] <fglock> some ops have 2 names (circumfix, postcircumfix)

[13:49] <pmurias> could you explain more?

[13:50] <fglock> like, parenthesis are parsed to { op1=>'(', op2=>')', exp1=>block... }

[13:51] <pmurias> i see

[13:52] <pmurias> it would be much better

[13:53] <fglock> this could be processed into op=>'circumfix:<( )>', but I'm not sure if it should do that

[13:54] <pmurias> i wanted to suggest the same thing :)

[13:55] <pmurias> it could be separeted to a post-processor, IMHO the simpler and more consistent the AST the emitter gets the better

[13:55] <svnbot6> r9981 | fglock++ | PG-P6 - parses cpan-barewords like Test-0.0.6

[13:56] <fglock> yes, we need to make an AST spec

[14:00] <pmurias> fglock: do you have any ideas for the AST?

[14:00] <svnbot6> r9982 | gaal++ |  r10033@sike:  roo | 2006-04-17 16:59:04 +0300

[14:00] <svnbot6> r9982 | gaal++ |  * FAQ::FUD - English tweaks

[14:00] <svnbot6> r9981 | fglock++ | PG-P6 - parses cpan-barewords like Test-0.0.6

[14:02] <fglock> pmurias: not really - I would like to reach a consensus with audreyt and pmichaud if possible, so that the ASTs are portable between compilers

[14:03] <fglock> at least at some low level, before semantic analysis and optimizations

[14:05] <audreyt> fglock: ok... let's gobby about it now?

[14:05] <fglock> ok!

[14:06] <audreyt> fglock: can you host? I'm again behind NAT

[14:06] <pmurias> can i join :)

[14:07] <fglock> sorry, I'm on NAT too is it possible to use feather?

[14:07] <fglock> pmurias: sure

[14:08] <bsb> Will there be an AST -> perl6 function like Deparse?

[14:08] <audreyt> there better be :)

[14:09] <bsb> then can perl6 be used b/w systems and asts be internal only?

[14:09] <pmurias> just implement audreys rulesas-templates proposal

[14:09] <kattana_> can I spectate :p we need some "live streaming video of perl6 development :O"

[14:10] *** justatheory joined
[14:11] <audreyt> it goes without saying all can spectate :)

[14:11] <pmurias> when will the gobby session start?

[14:11] <audreyt> like, now

[14:11] *** frederico joined
[14:11] <audreyt> try connect to perlcabal.org

[14:12] <gaal> does gobby come with a headless host?

[14:12] <audreyt> not sure

[14:13] <gaal> so you're pulling a display?

[14:13] <audreyt> yeah

[14:13] <audreyt> well no

[14:13] <audreyt> ssh -R

[14:13] <audreyt> + tcpxd

[14:13] <audreyt> pmurias: can you type something?

[14:14] <stevan> kolibrie: SSV, and you?

[14:14] <audreyt> fglock: ?

[14:14] <fglock> one sec...

[14:41] <Limbic_Region> -40 degrees is the only point that is the same in both F and C scales.  Anyone want to take a wager on the intersection of the number of commits of Pugs and Parrot?

[14:42] <rw-rw-r--> 0? :P

[14:43] <Limbic_Region> rw-rw-r-- for the purposes of the wager, they must be at the same rev level at the same time (otherwise they would intersect at all points just as C and F would)

[14:43] <kolibrie> stevan: haven't signed up yet, working out details with $work

[14:48] <stevan> kolibrie: cool, are you going to come to the hackathon?

[14:49] <kolibrie> stevan: depends a little bit on where and when it is

[14:49] <kolibrie> right now it's not looking too promising

[14:51] * kolibrie wonders if he can convince the $powers_that_be to let him stay an extra day

[15:03] *** elmex joined
[15:06] *** lichtkind joined
[15:12] <lichtkind> ?eval hex 11

[15:12] *** evalbot_9966 is now known as evalbot_9982

[15:12] <evalbot_9982> Error: No such method in class Int: "&hex"

[15:13] <lichtkind> no hex commend?

[15:14] <theorbtwo> It's a method.  What would the hex method on integers do, and why do you think there would be one?

[15:21] *** enantiodrome joined
[15:21] <lichtkind> so i heve to clarify that this is a hex number? i mena perl5 has a hex method to convert hex into dec

[15:22] <gaal> ?eval 0x11

[15:22] <evalbot_9982> 17

[15:24] <lichtkind> yeah this is also possible in perl5 but thy did we has a hex function?

[15:24] <lichtkind> sorry had

[15:24] *** saorge joined
[15:25] <gaal> ?eval my $x = "11"; :16($x)

[15:25] <evalbot_9982> 17

[15:25] <gaal> hex and oct are obsoleted by general :n() syntax

[15:26] <gaal> ?eval :42(11)

[15:26] <evalbot_9982> 43

[15:27] <lichtkind> now i understand :) all your base belong to us

[15:28] <lichtkind> thanks

[15:28] <xinming> perl 6 rocks.

[15:28] <gaal> exactly :)

[15:29] <gaal> lichtkind++

[15:29] <lichtkind> ..yeah thats why im writing this

[15:29] <lichtkind> thank one question left florian offered me pugs committer bits but i always thought everybody can contribut?

[15:30] <xinming> lichtkind: If you wish to contribute, you can do that. :-)

[15:30] <gaal> everyone is offered a committer bit. :)

[15:33] <lichtkind> im not even willing to lern haskell but jeah but maybe as english hacker :) but still not know enough about perl6

[15:34] <xinming> read synopsis... It's a good tutorial if you know a little about perl 5.

[15:35] <pmurias> lichtkind: there's a perl5 subproject

[15:36] <pmurias> under misc/pX/Common, feel free to commit at will

[15:36] <lichtkind> thanks pmurias but i have my own open source perl project wich is huge enough for me, my primary interest is no writing this perl6 tutorial but i am willing to help with the bible and similiar things

[15:38] <lichtkind> maybe alias would kill me if he see me here :)

[15:38] <pmurias> why?

[15:39] * audreyt purrs

[15:39] <audreyt> gobby++ # fun

[15:40] *** bsb left
[15:40] <lichtkind> because his tpc grant i hangin on something i should do 2 weeks ago, but you know finding a name is very hard

[15:40] <audreyt> so, if google Summer of Code has a Pugs category

[15:41] <svnbot6> r9983 | audreyt++ | * docs/notes/p6ast_draft - gobby log on P6AST joint design session.

[15:41] <audreyt> is there anyone here who'd be interested (and eligible as a student)?

[15:41] <audreyt> (I know that fglock is)

[15:42] <TimToady> audreyt: I've always thought ~~ should work between sig and cap.

[15:42] <TimToady> well, as long as it was possible to think that...

[15:42] <audreyt> cognominal: would you mind if I simply commit siva.pmc as the Capture pmc?

[15:42] <audreyt> TimToady: cool!

[15:43] <cognominal> feel free to do it

[15:43] <cognominal> but I think that Capture would probably be derived from it (if possible)

[15:44] <cognominal> But I see potential for P6AST.

[15:44] <audreyt> oh wait

[15:45] <cognominal> I will try to see if I can create a subset of e4x as an extension of the Parrot perl6 compiler

[15:45] <audreyt> the hash part and array part are related?

[15:45] <audreyt> or does the array mean children

[15:45] <audreyt> and hash means atts?

[15:45] <cognominal> yes!

[15:45] <cognominal> you got the idea

[15:45] <audreyt> oh, so it's like twig.

[15:45] <audreyt> I love twig.

[15:46] <cognominal> and you can multiplex a string, a float and int as != scalar

[15:46] <cognominal> the string would be the name of the node.

[15:46] <audreyt> that's very moose.

[15:46] <gaal> }:)

[15:46] <cognominal> thx for the compliment

[15:46] <cognominal> I could not dream better compliment

[15:47] <cognominal> and I suppose that with Perl6 we could multiplex enum to the siva int

[15:47] <TimToady> so basically it's a bag of things discriminated by type?

[15:47] <cognominal> exactly

[15:48] <cognominal> it should foster concise PIR code

[15:49] <cognominal> Perl is all about context, why PIR should be any different

[15:49] <geoffb> audreyt, re: the unanswered Capture.pod question ... from what you said abaove, I think my question, and the line 'say "The color is $car_cap[1]"; # black' could just be stricken -- or maybe add a note explaining that said line won't work.

[15:49] <audreyt> \('body': :bgcolor<black, \('h1': "moose", \('a': :href<#x>, 'antler') ) )

[15:50] <audreyt> I mean :bgcolor<black>.

[15:50] <svnbot6> r9984 | audreyt++ | * 17:49 < geoffb> audreyt, re: the unanswered Capture.pod question ... from what

[15:50] <svnbot6> r9984 | audreyt++ |         you said abaove, I think my question, and the line 'say "The

[15:50] <svnbot6> r9984 | audreyt++ |         color is $car_cap[1]"; # black' could just be stricken -- or

[15:50] <svnbot6> r9984 | audreyt++ |         maybe add a note explaining that said line won't work.

[15:51] <gaal> <strike>geoffb: I think you're right, please commit</stirke>

[15:51] <gaal> somebody's in hypermode

[15:51] <geoffb> Wow, I expected the first answer to come on-channel, but I didn't expect it would be svnbot answering me.  :-)

[15:51] <audreyt> :)

[15:52] <gaal> do we have some sort of provision for ordered pairs in captures?

[15:53] <audreyt> TimToady: I went ahead and added Capture~~Signature to S04.

[15:53] <audreyt> bsb++

[15:53] <audreyt> gaal: elaborate?

[15:53] <TimToady> you naughty girl

[15:53] <lichtkind> pmurias thanks but i really have to find a name first

[15:53] * audreyt grins a mischievously, chershire grin.

[15:53] <audreyt> cheshire, even.

[15:54] <gaal> audreyt: think of xml <doc><e>1</e><e>2</e><e>3</e></doc>

[15:55] <cognominal> audreyt, I don't know Twig, but coming from mirod it can only be good

[15:55] <pmurias> lichtkind: cheshire would be a nice name for pretty much anything

[15:55] <audreyt> gaal: I really don't know

[15:55] <pmurias> unless you write funeral software eq. cofine lid drivers

[15:55] <audreyt> \('doc': \('e':1;2;3)) # maybe

[15:56] <audreyt> not sure at all.

[15:56] <lichtkind> pmurias not for an text editor :) :) :)

[15:56] <audreyt> TimToady: can a MultiCapture contain several invocants?

[15:56] <audreyt> zip(1: 2; 3:4);

[15:56] <audreyt> TimToady: somehow I think even for MultiCapture, there should just be one or zero invocant

[15:56] <audreyt> as in $foo.bar(1;2;3)

[15:57] <audreyt> but not bar($foo:1; $boo:2; $blah:3)

[15:57] <audreyt> that will allow the

[15:57] <audreyt> bar($foo: 1;2;3)

[15:57] <audreyt> notation.

[15:57] <TimToady> at the moment I think it's just multiple ordered lists

[15:57] <pmurias> lichtking: better than emacs *and* you get a nice logo

[15:58] <TimToady> but we did talk once about allowing sublists to have named

[15:58] <TimToady> and if we allow named, I suppose we have to allow anything

[15:58] <audreyt> not so; I think allow pos+named makes more sense

[15:58] <audreyt> than pos+named+inv

[15:58] <audreyt> i.e.

[15:59] <audreyt> $obj.meth(1, 2, x=>42 ; 3, 4, y => 51);

[15:59] <lichtkind> pmurias true but you know im a bit spiritual interested (thats becaus alias is scared of my name proposals) it ahs to do something with the idea i reach for

[15:59] <audreyt> otherwise the dispatcher will have a very hard time

[15:59] <TimToady> there are ways in which it would be better to say that the invocant is just the first positional.

[15:59] <audreyt> TimToady: but then

[15:59] <audreyt> meth(1, 2, 3; $obj: 4, 5, 6)

[15:59] <pmurias> lichtkind: what does your editor specialize in?

[15:59] <audreyt> or even

[16:00] <audreyt> meth(name => 42; $x, $y, $z)

[16:00] <audreyt> you'd note like $x to magically become invocant

[16:00] <audreyt> s/note/not/

[16:00] <audreyt> and I think the $obj:4,5,6 form above should be illegal, as otherwise dispatch is very hard.

[16:00] <lichtkind> pmurias its still early but hes is spezialed in being perlish :)

[16:00] <TimToady> I think the Invocant type is a boolean.

[16:00] <TimToady> saying that the first positional was attached via : rather than ,

[16:01] <TimToady> maybe

[16:01] <lichtkind> pmurias Timtoday and easy things ..you know the gosdpel

[16:01] <audreyt> sure, those are isomorphic :)

[16:01] <TimToady> so failover doesn't have to unshift, just falsify the bit.

[16:01] <audreyt> or ignore the bit.

[16:01] <lichtkind> pmurias and its more graphics oriented than emacs or vi

[16:01] <audreyt> (even easier)

[16:01] <TimToady> and it frees up the scalar slot for other things maybe...

[16:02] <audreyt> so you think @$cap should return the inv?

[16:02] <pmurias> walk&

[16:02] <audreyt> I think it's fine to have it internally as a boolean

[16:02] <audreyt> (very clean)

[16:03] <TimToady> maybe ?$cap returns whether $cap[0] is invocant.  But then what about Match boolean?  maybe it works anyway...

[16:03] <audreyt> but $(\4) would better still work as 4

[16:03] <audreyt> the match boolean would work anyway that way.

[16:04] <audreyt> (always it has an invocant of the result object which may be a simple substring)

[16:04] <TimToady> right

[16:04] <audreyt> but we don't call that $cap[0].

[16:04] <audreyt> if we do, we are back to $1 $2 counting.

[16:04] <audreyt> which may not be a bad thing ;)

[16:04] <TimToady> urg

[16:05] <audreyt> $0 becomes essentially perl5 $&

[16:05] <audreyt> I know certain people who would actually welcome that change :)

[16:05] <TimToady> it kinda clobbers ($a,$b) = // though from a P5 viewpoint

[16:05] <PerlJam> audreyt: screw those people!  They don't know what they're talking about ;)

[16:06] *** FurnaceBoy joined
[16:06] <audreyt> PerlJam: you don't have problem adjusting to $0 $1? :)

[16:06] <PerlJam> audreyt: as long as I know which adjustment I'm making, I don't have a problem with it :)

[16:06] <TimToady> lemme think about it in the shower...

[16:06] <audreyt> TimToady: if so, then maybe @$cap still doesn't return the invocant :)

[16:06] <PerlJam> (Though I have to admit, $0 as p5 $& does have some allure)

[16:08] <audreyt> (that is what pcre does)

[16:08] <TimToady> the invocant is special anyway because it is *not* discriminated by type within the type bag.  It could be anything

[16:08] <audreyt> no doubt to maintain perl5, er, compatibility

[16:08] <TimToady> really &

[16:11] <fglock> back

[16:13] <clkao> audreyt: happy birthday!

[16:13] <fglock> is there a tree-editing cpan lib that could be used for p6-ast semantic analysis?

[16:14] <fglock> happy birthday!

[16:14] <audreyt> clkao: thanks! :)

[16:14] <audreyt> fglock: XML::Twig XD

[16:14] <audreyt> but seriously...

[16:14] <audreyt> there is Language::AttributeGrammar

[16:14] <audreyt> which would make allison happy (as the code may be shared with TGE later)

[16:15] <fglock> looking...

[16:15] <audreyt> TimToady:

[16:16] <pasteling> "audreyt" at 220.135.90.73 pasted "S06 patch for TimToady to review :)" (45 lines, 1.6K) at http://sial.org/pbot/16771

[16:16] <audreyt> TimToady: this merely makes that

[16:16] <audreyt>     method foo (*@;slices)

[16:16] <audreyt> work

[16:16] <audreyt> instead of having the invocant only present on the first slice

[16:16] <audreyt> or all slices

[16:16] <audreyt> or something equally silly

[16:24] <audreyt> PerlJam: k :)

[16:25] <PerlJam> audreyt: so what things make sense in $$foo?  That will do something meaningful if $foo is a Capture or Match object or what else?

[16:25] <audreyt> PerlJam: I think anything that can present a mutable scalar interface can make use of it

[16:26] <fglock> is there something written about disambiguating '<' from '<str>' and '/' from '/rule/' ?

[16:26] <audreyt> ${open('/etc/passwd')} = 'woot'; # bad example

[16:26] <cognominal> audreyt: I don't care about the siva name even if I think it is short and mnemonic but I see it as base classe more than anything.

[16:26] <audreyt> cognominal: gotcha.

[16:26] <pmichaud> fglock:   <str> is term position,   '<' is operator position

[16:26] <pmichaud> fglock:  same with rule

[16:27] <fglock> but %hash<str> is operator-like

[16:27] <pmichaud> that's postfix position :-)

[16:27] <audreyt> postcirfumfix :)

[16:27] <pmichaud> okay, postcircumfix :)

[16:27] <audreyt> that wasn't a correction -- I didn't see your line :)

[16:27] <pmichaud> (I call it postfix position, since other postfix ops can go there)

[16:27] <audreyt> right.

[16:28] <pmichaud> hmm.  "postfeefifofumfix"

[16:28] <audreyt> lol

[16:28] <audreyt> PerlJam: in any case, this is just rationalizing the perl5 deref

[16:28] <fglock> ok - currently I just send a stream of op/term to the precedence parser - I don't check what it 'wants'

[16:28] <audreyt> PerlJam: instead of overload '${}', one has now just to declare .as(Scalar)

[16:28] <pmichaud> fglock:  yeah, one has to keep track of what is expected

[16:29] <audreyt> PerlJam: far easier, and agrees with other casters like +$x and ~$x and *$x.

[16:29] <pmichaud> audreyt: I much prefer prefix:$, prefix:@, etc.  Very nice.

[16:30] <pmichaud> fglock:  PGE's opp originally had two states -- expect_term and expect_oper.  I've since generalized it into a multi-state parser -- there can be a superposition of things expected (in order to be able to handle listops and other oddities)

[16:31] <audreyt> oh cool, OPTable.pir handles listassoc now

[16:31] <audreyt> I had to patch the Hs port by hand to get that parsed :)

[16:31] <fglock> I'll check if I can get 'expect' info from Parse::Yapp

[16:31] <audreyt> pmichaud: chainassoc is a bit tricky

[16:31] <pmichaud> audreyt: yes, it does.  And did you see languages/perl6/lib/grammar_optok.pge ?

[16:32] <pmichaud> audreyt: I'm currently parsing chainassoc as infix and fixing it up in the match->ast step

[16:32] <audreyt> pmichaud: but

[16:32] <audreyt> 1 == (2 == 3)

[16:32] <audreyt> ne

[16:32] <audreyt> 1 == 2 == 3

[16:32] <pmichaud> oh, wait, I'm currently fixing it up in the pir code step

[16:32] <audreyt> and if you don't have a paren form, you are going to fail that

[16:32] <pmichaud> not at all

[16:33] <audreyt> mm, "not at all"?

[16:33] <pmichaud> okay, it didn't work -- lemme check into it :-)

[16:33] <pmichaud> circumfix:( ) is used to disambiguate there (at least it's supposed to be)

[16:33] <audreyt> aye

[16:33] <pmichaud> oh wait, it did work

[16:34] <audreyt> that's the "paren form"

[16:34] <pmichaud> p6> say 1 == 2 == 3

[16:34] <pmichaud> 0

[16:34] <pmichaud> p6> say 1 == (2 == 2)

[16:34] <pmichaud> 1

[16:34] <audreyt> woot

[16:34] <audreyt> pmichaud++

[16:34] <pmichaud> p6> say 0 == ( 1 == 2 )

[16:34] <pmichaud> 1

[16:34] <pmichaud> p6> say 0 == 1 == 2

[16:34] <pmichaud> 0

[16:34] <pmichaud> i.e., it handles it.  :-)

[16:35] <pmichaud> I think that was Friday's fun for me.  The days begin to blur together

[16:35] <audreyt> it's fortunate that all builtin chainassoc are in one preclevel :)

[16:36] <audreyt> I still don't know what happens when you mix it with infix in the same level

[16:36] <audreyt> maybe it's just forbidden ;)

[16:36] <pmichaud> I think that's forbidden in S03

[16:36] <pmichaud> er, S06

[16:36] <pmichaud> Note that operators "equiv" to relationals are automatically considered chaining operators. When creating a new precedence level, the chaining is determined by the presence or absence of "is assoc('chaining')", and other operators defined at that level are required to be the same.

[16:36] <audreyt> right.

[16:39] <svnbot6> r9985 | masak++ | fixed various typos in Capture.pod

[16:42] *** SamB joined
[16:43] <fglock> cool - Parse::Yapp can return the 'expect' list

[16:52] <ingy> hi audreyt

[16:55] <audreyt> ingy: hi

[17:13] <xinming> audreyt: isn't &?ROUTINE still not exist?

[17:13] <obra> hey ingy

[17:14] <xinming> s/is/does/ :-)

[17:15] *** vanjuggler joined
[17:16] <audreyt> xinming: yes, but pugs currently spells it as &?SUB

[17:16] *** zgh joined
[17:16] <vanjuggler> Hey folks!  I just watched the YAPC::Tokyo pugs presentation!  It's awesome!  Great work!

[17:16] <audreyt> thanks :)

[17:17] * audreyt curtsies

[17:17] <vanjuggler> The slides look gorgeous too!

[17:17] <audreyt> is this luke closs? :)

[17:17] <vanjuggler> It sure is!

[17:17] <theorbtwo> xinming: It's still a double-negitive.  I think you want "Is &?ROUTINE still nonexistant?", or "Does &?ROUTINE still not exist?".

[17:17] <audreyt> a commit bit is on your way.

[17:18] <vanjuggler> heh

[17:18] <vanjuggler> I'm just co'ing pugs as we speak

[17:18] <audreyt> good, you can ci shortly after

[17:18] <vanjuggler> I wanna try Module::Compile and write some perl6!

[17:18] * audreyt is getting better at this preemptive-committer-bit thing

[17:18] <vanjuggler> heh

[17:18] <PerlJam> audreyt++

[17:19] <audreyt> vanjuggler: excellent :) too bad I'd need to sleep soon

[17:19] <audreyt> but I'll be around tomorrow :)

[17:19] <vanjuggler> I really think you guys are doing a tremendous job.  All the hackathons and blog posting is great!

[17:19] <vanjuggler> You guys are like rock stars. :)

[17:19] <xinming> theorbtwo: thanks. Sorry for me poor English. :-/

[17:20] <theorbtwo> No problem.

[17:20] <xinming> audreyt: can't we call it self in pugs currently?

[17:20] <xinming> hmm, using &?SUB

[17:20] <vanjuggler> Does the Module::Comple perl6 -> perl5 compiler module exist on CPAN yet?

[17:21] <fglock> vanjuggler: no, it is being rewritten

[17:21] <xinming> hmm, eg... sub mine { &?SUB }; mine();

[17:21] *** ghenry joined
[17:21] <xinming> I know it is a infinite loop. :-)

[17:21] <vanjuggler> Is there anything I can try in the pugs svn?

[17:22] <theorbtwo> xinming: No, it's mine() == \&mine

[17:22] <theorbtwo> sub mine { &?SUB.() } would inf-loop

[17:22] <vanjuggler> I just got a driver perl driver written for Selenium Remote Control, I'd like to also make a perl6 version... :)

[17:22] <xinming> theorbtwo: thanks

[17:23] <theorbtwo> ...I think.  Don't take my word as gospel.

[17:24] <fglock> vanjuggler: the current version of P6->P5 is in misc/pX/Common/Pugs-Grammar-Perl6 - but it currently emits just the syntax tree - no P5 code yet. The old version is in misc/pX/Common/lrep-compiler

[17:25] <vanjuggler> fglock: thanks!

[17:29] <gaal> theorbtwo: yes, if by "==" you mean "evaluates to".

[17:29] *** izut joined
[17:30] <gaal> (typically denoted by fancy => in func-p texts)

[17:30] <theorbtwo> Er, what I meant was that the expression mine() == \&mine is true.

[17:30] <Limbic_Region> hrm - if I wanted to overide the way Makefile.PL did something (force USE_ZLIB to 0) but wanted to do it permanently so updates to Makefile.PL wouldn't overwrite my fix - what should I do

[17:31] * Limbic_Region doesn't like any of the ideas he has thought of so far

[17:31] <gaal> theorbtwo: yes. a tautology probably, in some mathy sense :)

[17:32] <gaal> Limbic_Region: if you think this is something other people might need, add it to the config.yml scheme

[17:32] <Limbic_Region> no - it is just me on 1 box

[17:32] <Limbic_Region> home works fine - work doesn't

[17:33] * Limbic_Region currently can only get Pugs to compile at work if he links with cygwin

[17:34] <gaal> well, if you aren't afraid of accidentally committing, just throw in an override at the appropriate place. worse that could happen is a conflict.

[17:35] <Limbic_Region> gaal - I was thinking along the lines of having command line options to overide the "probing" defaults

[17:36] <Limbic_Region> for instance perl Makefile.PL USE_ZLIB=0 would force it to 0 even if the probe said it was available

[17:37] <gaal> Limbic_Region: or even skip the probe. not a bad idea actually

[17:37] <gaal> please commmit :)

[17:39] <Limbic_Region> gaal - let me first confirm that my hardcoded approach even succeeds in doing what I hope it does

[17:39] *** vel joined
[17:39] <svnbot6> r9986 | fglock++ | PG-P6 - the tokenizer rules are called from within the precedence

[17:39] <svnbot6> r9986 | fglock++ | parser, so that they can change depending on the current state

[17:39] <Limbic_Region> this could take a while

[17:43] *** elmex joined
[17:44] <ingy> hi obra

[17:44] * gaal needs a reminder. In math, what's the friend concept to a "range" of a function, on the side of the results?

[17:44] *** siosiosios joined
[17:44] <audreyt> domain?

[17:45] <gaal> ah yes, thanks :)

[17:45] <audreyt> np :)

[17:45] <audreyt> glad to be your DNS

[17:45] *** siosiosios is now known as DaGo

[17:47] <gaal> f :: Range -> Domain

[17:47] <xinming> long time no commit. :-)

[17:48] <fglock> audreyt: be around for #10000 !

[17:48] <svnbot6> r9987 | fglock++ | PG-P6 - AST includes 'pos'

[17:48] <svnbot6> r9986 | fglock++ | PG-P6 - the tokenizer rules are called from within the precedence

[17:48] <svnbot6> r9986 | fglock++ | parser, so that they can change depending on the current state

[17:48] <xinming> oops...

[17:48] <audreyt> fglock: heh sure :)

[17:48] * xinming thinks he should wait for 9999 commits, and get the 10000  :-P

[17:48] <Limbic_Region> actually - I can't compile on Win32 for a different reason ATM

[17:48] <gaal> heh, nice birthday gift

[17:49] <Limbic_Region> cd .. is blowing up

[17:49] <Limbic_Region> oh yeah, happy bday audreyt

[17:49] <svnbot6> r9988 | yiyihu++ | s/&\?SUB/&\?ROUTINE/g in Prim.hs and Monads.hs, So that &?ROUTINE()

[17:49] <svnbot6> r9988 | yiyihu++ | works.

[17:49] <svnbot6> r9988 | yiyihu++ | And initial import for misc/S29_round.pl. :-)

[17:49] <xinming> audreyt: your birthday?

[17:49] <gaal> xinming: somehow I see rs 10000, 10001, 10002, through 10042 coming in quick succession :-)

[17:50] <audreyt> xinming: yeah, Apr 18

[17:50] <xinming> happy birthday...

[17:50] <audreyt> xinming: oh, please fix all ?SUB in examples and t

[17:50] <audreyt> or someone else fix that :)

[17:51] * xinming is hungered for fixing... and watching the revision number...  O_O

[17:52] *** arcady joined
[17:52] * Limbic_Region is extremely confused

[17:52] <svnbot6> r9989 | audreyt++ | * Perl6::Spec - update to upstream r9741

[17:53] *** ruz joined
[17:54] <Limbic_Region> is there any reason why "ext\Algorithm-TokenBucket"; "nmake -f Makefile all -nologo"; "cd .." should be failing on the cd .. on Win32?

[17:54] <xinming> audreyt: do I need to fix the files for which extension is pil?

[17:58] * Limbic_Region gies up and heads to a meeting but asks that if anyone else is succesfully building clean on Win32 to please raise their hand

[18:00] * xinming swing his arm as tired of typing... ;-)

[18:00] * avar gives xinming his powerball

[18:01] <gaal> Limbic_Region: ugh, I seem to rememer somebody bringing up that "..", but I don't remember who or when, sorry

[18:01] <gaal> something like two months ago I think? it may have even hit p6-c

[18:11] <svnbot6> r9990 | yiyihu++ | Replaced &?SUB to &?ROUTINE in t and examples dir.

[18:11] <svnbot6> r9990 | yiyihu++ | Except for files which extension is .pil.

[18:12] <audreyt> xinming: no

[18:13] * xinming feels lucky about keeping ".pil" files away

[18:15] *** wilx joined
[18:17] <xinming> anyone here would tell me what round-alternate do?

[18:21] <theorbtwo> Switch between round-half-up and round-half-down every-other round operation, I'm guessing, but that's only a guess.

[18:23] <xinming> http://www.pldesignline.com/howto/showArticle.jhtml?articleID=175801189

[18:23] <xinming> here it talks about round-alternate

[18:26] <theorbtwo> Ah, it's either round-half-even or round-half-odd.

[18:28] <xinming> theorbtwo: do you mean it use round-half-even and round-half-odd randomly?

[18:28] <theorbtwo> No, pick one in your implementation.

[18:28] <theorbtwo> The author doesn't bother to give them different names, apparently.

[18:28] <xinming> or, the sequence is `round-half-even -(next call)-> round-half-odd -(next call)-> round-half-even ... ... `?

[18:29] <theorbtwo> That was my guess, but after reading, I don't think that's what he meant.

[18:31] <xinming> the more words, the more money ... :-)

[18:33] <kolibrie> stevan: looks like I might be able to be in Chicago starting Sat 24 June and departing Fri 30 June

[18:34] *** elmex joined
[18:45] <stevan> kolibrie: very cool

[18:45] <kolibrie> stevan: so is the hackathon at IIT?

[18:46] <kolibrie> or, for how long should I book in the dorms?

[18:47] <fglock> telling %ENV<1> from %ENV<1 requires backtracking, right?

[18:48] <fglock> or is %ENV<1 an error?

[18:48] <audreyt> an error.

[18:48] <audreyt> you commit on %ENV<

[18:49] <stevan> kolibrie: the location of the hackathon is still undetermined

[18:49] <audreyt> same for moo<1

[18:49] <audreyt> you have to use whitespace for infix <.

[18:49] <fglock> always?

[18:49] <stevan> kolibrie: however, I will be going, and my room/floor is always open to you :)

[18:50] <audreyt> fglock: currently pugs accepts 1<1

[18:50] <audreyt> but I'm sure TimToady would say it's an error.

[18:51] <fglock> ok - thanks!

[18:51] <kolibrie> stevan: so I should book through Wednesday night, and then hang out in your general proximity

[18:53] *** bsb joined
[18:56] * PerlJam wonders if someone had O'Reilly send him "Time Management for System Administrators" anonymously

[18:58] <stevan> kolibrie: sure

[19:00] * kolibrie loads up yapcchicago.org

[19:00] <stevan> kolibrie: if you wanna coordinate more, send me an email, its easier for me to keep track of that way :)

[19:01] <kolibrie> stevan: sure

[19:03] *** DesreveR is now known as r0nny

[19:08] <svnbot6> r9991 | audreyt++ | * Perl6::Overview::Control - Control Structure

[19:08] <svnbot6> r9991 | audreyt++ |   (Begining of quickref->Overview move.)

[19:08] <svnbot6> r9992 | audreyt++ | * Perl6::Overview::Data - Data Types

[19:08] <svnbot6> r9992 | audreyt++ |   (This may want to be refactored into Array/Hash/etc)

[19:08] <svnbot6> r9993 | audreyt++ | * Perl6::Overview::Operator - Operators overview

[19:08] <svnbot6> r9994 | audreyt++ | * Perl6::Overview::Variable - Magical variables

[19:09] <gaal> w00t

[19:14] <svnbot6> r9995 | audreyt++ | * Perl6::Overview::Reduce - Reduce metaoperator

[19:26] <svnbot6> r9996 | audreyt++ | * Perl6::Overview::File - File and Filesystem operations

[19:26] <svnbot6> r9997 | audreyt++ | * Perl6::Overview::Object - Object-oriented Programming

[19:26] <svnbot6> r9998 | audreyt++ | * Perl6::Overview::Rule - Grammar Rules

[19:26] <svnbot6> r9999 | audreyt++ | * Perl6::Overview::Subroutine - Subroutines

[19:26] <svnbot6> r10000 | audreyt++ | * Perl6::Overview::Smartmatch - Smart Matching

[19:26] <svnbot6> r10000 | audreyt++ |   (Happy Birthday, Audrey. :-))

[19:27] <theorbtwo> 10,000!

[19:27] <audreyt> woot :)

[19:27] <fglock> congrats!

[19:27] * audreyt hopes to release P6Doc on CPAN this weekend

[19:29] <xinming> ...

[19:29] <xinming> oops...

[19:29] <xinming> :-(

[19:30] <audreyt> xinming: you can have the 10001th :)

[19:30] <audreyt> (that was the last one in the batch to modernize+podify quickrefs)

[19:33] <izut> fglock: are you there?

[19:33] <fglock> izut: here!

[19:33] <izut> :)

[19:33] <izut> fglock: I tried to talk to you in private.

[19:33] <izut> Please join #perl.br :)

[19:34] <izut> I'll talk to you soon, I'll get a coffee :)

[19:35] <xinming> #10001 is mine...

[19:35] <svnbot6> r10001 | yiyihu++ | Perl 6 version of round_ceiling, round_floor, round_toward_zero, round_away_from_zero finished.

[19:35] <xinming> there are 3 remaining... :-)

[19:35] <fglock> izut: sorry, can't join #perl.br from cgi-irc

[19:35] <audreyt> so it is :)

[19:37] <xinming> and also, there are 2 functions which I don't know what It really means. :-P

[19:37] <xinming> I'll ask these the other day

[19:40] <izut> fglock: Ok... Mago was trying to talk to you. Oh, Randal is alone tonite, I think it is nice if somebody would get some food with him. I also contacted Galvao for this. He is at Comfort Hotel Centro Administrativo.

[19:40] <gaal> hee: "Because Stevan can't make it to Tokyo last month" - of course not, his time machine is b0rked

[19:41] <theorbtwo> gaal++

[19:42] <gaal> is there a conf in Brazil right now?

[19:42] <izut> gaal: yes.

[19:42] <gaal> cool! have a great conf :)

[19:42] <izut> Well, it will start this wednesday (19/Apr)

[19:43] <izut> :) YAPC::Brazil

[19:43] <izut> brb

[19:43] *** hlen_ joined
[19:48] <fglock> izut: ok - I'll try to contact him!

[19:50] *** lichtkind joined
[19:58] *** justatheory joined
[20:00] *** KingDiamond joined
[20:00] <svnbot6> r10002 | fglock++ | PG-P6 - the lexer knows about '1 < 2', '%EXP<str>', and '@a = <str>'

[20:03] <pmurias> audreyt: Happy Birthday

[20:03] <audreyt> *smile*

[20:03] <audreyt> now, it's 4am.

[20:03] <audreyt> I should probably sleep :)

[20:04] <fglock> pmurias: I started changing the AST

[20:05] <fglock> but it will need a lot of post-processing to get all semantics right

[20:05] *** justatheory joined
[20:06] <pmurias> fglock: is the ast speced enough?

[20:06] <fglock> not really - but now we can fill in the spaces

[20:06] *** defcon8 joined
[20:07] <defcon8> when is perl6 planned to be released?

[20:07] <pmurias> defcon8: christmas

[20:07] <fglock> I just rewrote the lexer - now it has more info about the state of the parsing, and takes less memory

[20:08] <pmurias> i'll look

[20:10] <fglock> it will need some refactoring later - I'm just trying to make it parse Test.pm

[20:10] <fglock> so that we can run pugs test suite :)

[20:11] *** Mago joined
[20:12] <fglock> but don't try it yet - it may enter an infinte loop

[20:12] <fglock> Mago: hi!

[20:12] <Mago> hi!

[20:13] <fglock> Mago: are you in Porto Alegre?

[20:15] <Mago> no, I will arrive at 19 07:00

[20:19] <svnbot6> r10003 | yiyihu++ | Perl 6 version of round_random, round_up, round_down implemented.

[20:19] <svnbot6> r10003 | yiyihu++ | Now, Math::Basic rounding suite according to

[20:19] <svnbot6> r10003 | yiyihu++ | http://www.pldesignline.com/howto/showArticle.jhtml?articleID=175801189

[20:19] <svnbot6> r10003 | yiyihu++ | almost finished.

[20:19] <pmurias> fglock: you don't like YAML.pm?\

[20:20] <audreyt> YAML::Syck! </knee-jerk-response>

[20:20] <fglock> pmurias: I need to look at the internal perl structure for debugging

[20:21] <xinming> if you know perl 6, You'll never want perl 5. :-)

[20:23] <pmurias> fglock: i agree that YAML, makes some things more difficult to see, but i find it clearer nevertheless, can i make it an option?

[20:23] <svnbot6> r10004 | fglock++ | PG-P6 - small fix in 'angle' parsing

[20:24] <fglock> pmurias: sure

[20:26] <fglock> audreyt: the rules for parsing angles and slash are not accessible to the user, right? since they are defined in the lexer

[20:26] *** Blicero_ joined
[20:27] <fglock> at least in PG-P6

[20:27] <rgs> wow, another pynchon addict in sight ?

[20:27] <Blicero_> yes

[20:27] <fglock> rgs: pynchon?

[20:28] *** hlen joined
[20:28] *** KingDiamond joined
[20:28] <rgs> fglock: a writer that might be popular among perl people -- several mongers I know love him

[20:29] <fglock> :)

[20:30] <Juerd> pynchon looks suspiciously like python

[20:31] *** PolettiX joined
[20:32] <pmurias> fglock: i'll bring in p6dump.pl and interface.pl from lrep

[20:32] *** PolettiX is now known as froh-doh

[20:33] <pmurias> how should they be named?

[20:35] <fglock> how about p6parse.pl ? rename the current perl6.pl to something more internal like test.pl

[20:37] <lichtkind> i thought again about that variable base in perl6 how do display 33:22323120 ?

[20:38] <fglock> pmurias: I've got ubuntu running again - this should reduce the line-ending problems :)

[20:39] <pmurias> p6dump is a dumping utility library, interface handles command line option (Getopt::Long)

[20:42] <pmurias> fglock: have fun with ubuntu

[20:43] <pmurias> would lib/Util/Dump.pm and lib/Util/Interface.pm be good names?

[20:43] <svnbot6> r10005 | fglock++ | PG-P6 - TODO, doc updates

[20:45] <fglock> pmurias: how about Pugs::Util::* ?

[20:46] <pmurias> should the have a seperate directory under Common

[20:46] <pmurias> ?

[20:46] <fglock> if these are generic modules (not PG-P6 specific), they should go in Common/Pugs-Util/

[20:46] *** rhett joined
[20:48] <pmurias> then i'll clean the up a bit and commit them, should Getopt::Long be used?

[20:48] <fglock> yes

[20:49] <fglock> please include Pugs-Util in the 'use lib'

[20:50] *** larsen joined
[20:51] <TimToady> audreyt: your S06 snippet is fine.  I'm wondering if the generic Capture.as(Scalar) somehow returns the most generic scalar, so prefers Any > Object > String > Num > Int or some such, rather like a P5 scalar can have multiple cached values but one of them is the "real" value.

[20:51] <TimToady> audreyt: sweet dreams and happy birthday while we're at it.

[20:54] <fglock> TimToady: is the lexer the right place to make the '<'/'<a>' distinction? (it is not user-modifyable)

[20:55] *** hlen joined
[20:57] <stevan> obra: ping

[20:57] <lichtkind> audrey has birthday?

[20:57] <obra> pong

[20:58] <stevan> obra: am I correctly assuming from audreyt's recent blogpost that the dorms will be available post-conference as well?

[20:58] <obra> huh. I know nothing.

[20:58] <obra> josh hasn't talked to me yet

[20:58] <stevan> obra: ok

[20:58] <stevan> just checking :)

[21:03] <TimToady> fglock: that depends on what you count as part of the lexer.  The bottom-up parser knows when it's looking for a <%infix> vs <%prefix> vs <%postfix>, so only those tokens are active that would be valid at that spot.

[21:03] <TimToady> (I oversimplify the hash stuff slightly there.)

[21:04] <TimToady> It's more like:

[21:04] <TimToady> <%infix> vs <%prefix|%term|%circumfix> vs <%postfix|%postcircumfix>

[21:05] <TimToady> assuming we adopt the new <%a|%b|%c> notation to combine longest-token processing of multiple hashes.

[21:06] *** theorbtwo joined
[21:06] <svnbot6> r10006 | pmurias++ | Pugs::Utils provide utils for the Pugs::* modules

[21:06] <svnbot6> r10006 | pmurias++ | The provide:

[21:06] <svnbot6> r10006 | pmurias++ |  - data dumping

[21:06] <svnbot6> r10006 | pmurias++ |  - option parsing

[21:08] <pmurias> good night

[21:08] <pmurias> sleep&

[21:08] <fglock> the bottom-up parser can implement the '|' part, so no problem I think

[21:09] *** KingDiamond joined
[21:13] <TimToady> fglock: for speed one could cache all the hash keys for all the hashes in a trie or some similar structure.  Just have to be careful that longest key wins regardless of hash, and in case of tie first hash wins.

[21:13] <TimToady> 'course you have to recalculate if any of the hashes is modified...

[21:14] <fglock> yep

[21:16] <TimToady> can probably treat alphanumeric sub names specially so that you don't have to recalculate on every sub declaration.

[21:17] <TimToady> if you assume that no "foo" prefix operator or term can match if the next char is alphanumeric.

[21:18] *** meppl joined
[21:18] <TimToady> maybe just run the prescanned identifier down a different trie than the non-alpha ops.

[21:19] <TimToady> actually, if you know the length then the ident one doesn't need a tree.  Just a hash would work.

[21:19] <TimToady> since you know its length already.

[21:19] *** FurnaceBoy_ joined
[21:19] *** izut_ joined
[21:21] *** ruz joined
[21:26] <fglock> TimToady: what if both postcircumfix and infix are expected? then the op is chosen based on if there is whitespace or not?

[21:29] <fglock> like in %ENV<x> vs. %ENV <...

[21:31] <TimToady> <%postcircumfix|%infix> is what you look for before whitespace, and <%infix> after.

[21:31] <TimToady> that's why we completely outlawed whitespace before postfix.

[21:32] <TimToady> hmm, that doesn't quite work.

[21:32] <TimToady> I think at postfix location you actually look for <%postfix|%postcircumfix>|<%infix> becuase

[21:33] <TimToady> you don't want the %infix participating in longest token there.

[21:33] <TimToady> $x<=2 is an error, but $x <= 2 is okay.

[21:35] <TimToady> or looking at it in terms of whitespace, if you don't get any match on a postfix, then you can pretend there was whitespace even if there wasn't, and try %infix.

[21:36] <meppl> gute nacht

[21:36] <fglock> I think I'll need to do some tests ... - how about /rule/ vs. division? is it just that rule is a term and division is an op?

[21:37] <TimToady> yeah, that's just simple term vs op expectation.

[21:37] <TimToady> just as in P5.

[21:37] <fglock> nice

[21:37] <TimToady> It's really only the postfix category that's new to P6

[21:38] <TimToady> well, plus a few other things.. :)

[21:44] <theorbtwo> TT: So you can use spaceless infix if it doesn't conflict with a postfix?

[21:44] <theorbtwo> That's something, at least.

[21:45] <theorbtwo> I'd really like it if C<< if ($x<5) {...} >> could DTRT.

[21:45] <fglock> but it can even conflict with a postfix in another package, since the precedence table is global (or so I think)

[21:45] <theorbtwo> ...but being able to $x+1 is at least something...

[21:47] <TimToady> yes, it's not a big problem with most operators, but anything in the postcircumfix category really has to be pretty strict about that.

[21:48] <TimToady> Otherwise you end up with the very problem Pugs is currently having of backtracking an arbitrary amount.

[21:48] <TimToady> And to be fair, this is something we recognized going in to the great bracket shift.

[21:48] *** theorbtwo joined
[21:48] <TimToady> so we knew that $a<$b was going to be a casualty.

[21:48] <Juerd> I'm afraid I can no longer convince myself that Perl 6 is still Perl.

[21:49] <Juerd> Because of the reference->Capture thing.

[21:49] <Juerd> I like the change, don't get me wrong.

[21:49] <TimToady> Just think of a Capture as a really FAT reference.

[21:50] <Juerd> I do, but it's so much more complex that it just isn't Perl anymore. Perl isn't complex in every aspect. Its complexity comes from combining simple building blocks.

[21:50] <Juerd> Perl 6, however, is complex by itself.

[21:50] <TimToady> It's just a reference that can refer not only to an individual thing but also to the relationships of several things.

[21:50] <webmind> sounds complex.

[21:50] <TimToady> today your day to panic?  :-)

[21:51] <Juerd> I like both, but this has made me realise the most important difference between Perl 5 and 6. It's not about syntax, it's not about what the language can be used for, it's not about features... To me, Perl is Perl because of how it handles complexity.

[21:51] <TimToady> most of the time people will use Perl 6 exactly like they use Perl 5.

[21:51] <Juerd> TimToady: Most of the time, people use all programming languages exactly alike.

[21:52] <Juerd> In that respect there's little difference between moving from PHP to Perl, or from Perl 5 to Perl 6, or from C to Perl.

[21:52] <TimToady> As with closures, a capture is something that we can hide from newbies till they're ready for it.

[21:52] <Juerd> So that, to me, isn't where a language gets its identity from.

[21:52] <Juerd> I appreciate that.

[21:53] <Juerd> And I don't *mind* that Perl 6 isn't Perl. I just don't think I can defend that Perl 6 stays Perl, anymore.

[21:53] <theorbtwo> Ah, but I think one of the great beuties of Perl is that it's all out there in the open.  We don't hide closures or references away in perl5, really.

[21:53] <theorbtwo> Or, for that matter, symbol tables.

[21:54] <TimToady> Depends on what you mean by "Perl" of course.  I think Perl 6 is *more* Perl than Perl 5, but I'm thinking of how it works, not any particular surface manifestation.

[21:54] <Juerd> I could easily do so a few years ago, and it got harder over time, to the point that during the German Perl Workshop all I could say is "Well, Larry decides" instead of something related to both languages...

[21:54] <wolverian> on that note, is there a reason why we can't reformulate 'want' with return type mmd? i.e. get rid of the idea of context altogether.. although maybe that would make flattening impossible. not sure

[21:54] <Juerd> But the Capture objects have made me realise WHY I have trouble following the mantra.

[21:55] <Juerd> TimToady: Yes, and apparently I define what's Perl by the location of complexity.

[21:55] *** reezer joined
[21:55] <Juerd> And that's probably why I think Ruby feels Perlish, while Python and PHP do not.

[21:56] <Juerd> Still, though, for any random project, I prefer the Perl 6 way.

[21:57] <TimToady> I can kind of see that.  Python and PHP both have a "one size fits all" mentality.

[21:57] <TimToady> Ruby and Perl don't.

[21:57] <TimToady> I would argue that Perl 6 still doesn't have a one-size-fits all mentality.

[21:57] <Juerd> But I fear that Perl 6 will be, even more than Perl 1..5 have ever been, a language for experts

[21:57] <TimToady> but in trying to find the right general structures underneath, it can certainly look that way.

[21:58] <spinclad> audreyt: Many Happy Returns of the 10000!

[21:58] <Juerd> Though "fear" is inappropriate, because I kind of like the elitist touch.

[21:58] <spinclad> This March Up-country has taken 1 yr 2 mo 17 days (more or less) to reach 5 figures.

[21:58] <fglock> later &

[21:58] <svnbot6> r10007 | fglock++ | PG-P6 - added assorted fixes to TODO list

[21:59] *** fglock left
[21:59] <TimToady> One might almost say that Perl 6 is an experiment in trying to keep both elitists and hoi polloi happy simultaneously.

[21:59] <TimToady> Remains to be seen how successful that is...

[22:00] <theorbtwo> The problem is that we seem to keep finding new layers and exposing them.

[22:01] <theorbtwo> In p5, there's a pretty clear deliniation in the layers.  These are visible, these you use B to mess with at your own peril.

[22:01] <TimToady> We're trying to nail down a precise semantics.  Just because we're exposing those layers to ourselves here doesn't mean that ordinary people will ever have to think about them.

[22:01] <webmind> Juerd, a langauge for experts sounds like it'll haver a different audience ? like perl5 now is used by a lot of admins.. who don't do much more then script.. althouh sometimes the 'scripting' gets caried away

[22:02] <Juerd> TimToady: That's a dangerous misconception, I think. When it exists and is exposed by default, it will be used, and people will have to understand it in order to read/maintain code.

[22:02] <masak> happy birthday, audreyt

[22:03] <masak> &

[22:03] <TimToady> yes, that is the one problem of P5 we can't fix with this approach.

[22:03] *** iblechbot joined
[22:03] <TimToady> on the other hand, if the machine actually understands the semantics,

[22:03] <TimToady> it has a much better chance of being able to explain what's going on

[22:04] <TimToady> when the naive user waves his mouse over the unfamiliar construct.

[22:04] <Juerd> TimToady: My experience with helping people learn IRC is that literally no-one learns first, and then starts doing things with other people's code.

[22:04] *** Limbic_Region_ joined
[22:04] <Juerd> TimToady: It's something we can't fix, but we are making it worse. Whether that is a problem, does indeed remain to be seen.

[22:05] *** Limbic_Region_ is now known as Limbic_Region

[22:05] <TimToady> you at least have to give us credit for huffmanizing the complicated things longer, unlike in Haskell, where the completely abstruse things are the shortest.

[22:05] <Juerd> And I do

[22:05] <TimToady> That's why Capture and Signature have such long names.  :)

[22:06] <TimToady> And you'll notice our metasyntactic categories are much longer than things like quote: or prefix:

[22:06] <Juerd> But at the same time, I think huffmanization severely failed regarding the .+ and .* operators, to name one example.

[22:07] <TimToady> possibly.  remains to be seen whether those are useful in some newer "next method" paradigm.

[22:07] <TimToady> but I don't regret trying to move away from "super" semantics.

[22:08] <Juerd> Oh, another thing - now that we do not have references anymore, and a $foo holding an Array is practically the same as @foo being an array, what's the function of a sigil?

[22:08] <Juerd> Is what it returns in list context a side effect, or the primary function?

[22:08] <Juerd> ($ => one item, @ => all elements (possibly ordered), % => pairs)

[22:08] <TimToady> It says whether you are *thinking* of it in the singular or plural.

[22:09] <Juerd> That works for $ versus @, but not %

[22:10] <TimToady> the @ vs % distinction is whether you're thinking about it as ordered or unordered.

[22:10] <Juerd> So a set would get %?

[22:10] *** FurnaceBoy joined
[22:10] <Juerd> And % has nothing to do with pairs, per se?

[22:10] <TimToady> the keys of a % can function as a set.

[22:10] <Juerd> Yes, but that's not what I mean

[22:10] <Juerd> I'm not sure I can better express what I meant, though :)

[22:11] <TimToady> more like the keys of @ are implicitly numbers.

[22:11] <azuroth> priow

[22:11] <wolverian> it feels to me like we have a rubyish type system under the perl5 container system, or something

[22:12] <Juerd> I don't think %foo.push(15) makes sense or feels natural

[22:12] <buu> Juerd: What would that do?

[22:12] <Juerd> That's why I think % has to do with kv pairs, while @ does not. The most apparent way this is exposed, though, is how things behave in list context

[22:12] <Juerd> buu: That I don't know. :)

[22:12] <Juerd> buu: Which is my point

[22:13] <buu> Juerd: Heh, fair enough. I would think something like %foo.push( key => value ); would make a mild amount of sense..

[22:13] <FurnaceBoy> right. the first is just a value without a key?

[22:13] <Juerd> buu: No, not at all; it only makes me want to ask lots of questions.

[22:13] <Juerd> buu: Like: what happens if $key already exists?

[22:13] <Juerd> buu: And, is %foo ordered?

[22:14] <Juerd> buu: And... is %foo really a PHP array hiding in Perl space?

[22:14] <Juerd> So I wouldn't *want* push on a %foo, because I associate it with a whole different set of semantics

[22:15] <Juerd> But that association may be wrong. I'm trying to find that out.

[22:15] <buu> Juerd: Well, no, I don't really weant a push either

[22:15] <theorbtwo> Indeed.  AFACS, the sigil is more or less meaningless these days.

[22:15] <buu> I was just suggesting a possible interpretation of .push on an array.

[22:15] <Juerd> (Also, note that "push @foo, $bar" feels INCREDIBLY unnatural to me these days)

[22:15] <azuroth> maybe on a multi...hash...

[22:16] <Juerd> theorbtwo: So it could be useful to explain it using list context. $foo and @foo's only real difference is list context behaviour.

[22:16] <Juerd> (AFAICT)

[22:16] <Juerd> -- If both are an Array.

[22:16] <theorbtwo> But I don't think that's a difference between $foo and @foo, but...

[22:16] <theorbtwo> Is it?

[22:16] <Juerd> Well, @foo flattens in list context (evaluates to a list of its elements), while $foo stays the Array object.

[22:16] <theorbtwo> I thought if you did my Array $foo vs my Array @foo, they did the same thing in list context.

[22:17] <Juerd> No.

[22:17] <Juerd> $-sigilled things are always one thing, even in list context.

[22:18] <Juerd> And that's incredibly useful

[22:18] <Juerd> Because otherwise you could never have a list of arrays.

[22:18] <Juerd> Hm.

[22:18] <Juerd> List of arrays @foo and @bar ... how does that work nowadays?

[22:18] <Juerd> Used to be @two_elements = (\@foo, \@bar);

[22:18] <Juerd> Still sane?

[22:19] *** Khisanth joined
[22:19] <Juerd> Or do we think of that as @two_elements = ($@foo, $@bar); now?

[22:19] <Juerd> Where "$" could be explained as "don't flatten", like the "@" in @$foo means "flatten"

[22:19] *** Khisanth joined
[22:20] <Juerd> (Then I'd also expect @%foo to mean %foo.values, and %$foo to mean $foo.kv)

[22:21] <Juerd> TimToady: What is the list-of-arrays construction syntax now, given named arrays @foo and @bar?

[22:22] <TimToady> (\@foo,\@bar) still works fine.

[22:23] <Juerd> Okay

[22:24] <Juerd> But then you have a Capture, not an Array, in positions 0 and 1

[22:24] <Juerd> So it'd be different from my $foo = @foo; my $bar = @bar; my @two_elemens = ($foo, $bar)

[22:24] <TimToady> A Capture that contains only a P6 array is pretty much indistinguishable from a P5 Array reference.

[22:25] <theorbtwo> TT: my @foo = (1, 2); $x=\@foo; @foo.push(3)

[22:25] <theorbtwo> What's $x?  Is it still \(1,2), or is it \(1,2,3)?

[22:26] <TimToady> the assignment just copies the values 1 and 2 into the array, just like in P5.

[22:26] <theorbtwo> Read the rest of the question?

[22:26] <Juerd> TimToady: Yes, but how would you express the array itself in list context, so that you'd have a list of array objects, not a list of capture objects?

[22:26] <TimToady> the push does exactly the same as P5 push.

[22:27] <theorbtwo> But does it effect the Capture?

[22:27] <theorbtwo> Is that still really a reference, or is it a copy?

[22:27] <Juerd> TimToady: I think theorbtwo's question is if \@foo captures @foo or its elemens.

[22:29] <TimToady> I think it captures the array, not the elements.

[22:29] <TimToady> But any list captures the array rather than the elements until you bind it.

[22:29] <TimToady> when you say

[22:30] <TimToady> foo(@bar, @baz)

[22:30] <TimToady> you don't know yet whether @bar and @baz will be bound to scalars or slurpies.

[22:30] <TimToady> the Capture list just as @bar and @baz in it as unbound arrays.

[22:31] *** ruz joined
[22:31] <TimToady> if you bind to (@x, *@y), you keep the identity of @bar and lose the identity of @baz

[22:31] <TimToady> but that's a function of the binding, not of the Capture.

[22:32] <theorbtwo> That's a very good thing, in this case.

[22:32] <theorbtwo> I'm not so sure about the case where you're actually calling a function, but it's probably a slight win there too.

[22:32] <TimToady> A Capture is all about "here's what I want to talk about" without committing to how you want to talk about them.

[22:33] <TimToady> they really are references in some kind of profound linguistic sense,.

[22:33] <TimToady> (too profound for me to understand entirely. :)

[22:34] <theorbtwo> Hm, I could do with less profound and more simple.

[22:34] <theorbtwo> References in perl5 are nice and simple.

[22:34] <theorbtwo> Perl6 seems like an incredibly complex language.

[22:35] <TimToady> I'm reminded of the English sentence: "That man is a woman".

[22:35] <theorbtwo> There's a reason that we've decided that trying to program in English is stupid.

[22:36] <TimToady> indeed.  and Perl 6 ain't English.

[22:37] <theorbtwo> That's true, but it's certianly orders of magnitude more complex then perl5.

[22:37] <TimToady> don't think so.

[22:37] <azuroth> are Captures really that much more confusing than p5-refs?

[22:37] <theorbtwo> Yes.

[22:38] <TimToady> the complexities are there in Perl 5, but they're kind of brittle.

[22:39] <spinclad> my impression is that the existing complexities have been much rationalized and simplified;

[22:39] <TimToady> fact is, P5 already has \($a, $b, $c), but it doesn't name the result, and tends to obscure the relationships as a mere list.

[22:40] <theorbtwo> I never use p5's \($a, $b, $c).

[22:40] <spinclad> OTOH there's plenty of new combinations of them to fill in the complexity field...

[22:40] <TimToady> yes, we're trying to trade the unnecessary complexities for some necessary (or at least desirable) complexities.

[22:40] <azuroth> you don't need to use p6's \($a, $b) either then ;-)

[22:40] <avar> \($a, $b, $c) = [$a, $b, $c] right?

[22:41] <theorbtwo> avar: No.

[22:41] <spinclad> {away &)

[22:41] <theorbtwo> \($a, $b, $c) is documented as being (\$a, \$b, \$c).

[22:41] <theorbtwo> ...but apparently Larry is saying it isn't.

[22:42] <TimToady> I'm saying that (\$a, \$b, \$c) is a poor man's way of writing a Capture.

[22:42] <theorbtwo> And I'm saying that we have arrays and references, I don't see why we need a special array of references.

[22:43] <theorbtwo> Even worse, an arrayrefhashrefmonser.

[22:43] <theorbtwo> We seem to be building simple things from complex things instead of the other way around.

[22:43] <Juerd> theorbtwo: Captures are symbolic references in the most pure form, and that makes them nice again.

[22:44] <theorbtwo> So we only have symbolic references now?

[22:44] <Juerd> Though I don't think I can explain exactly what I mean by that, that's how I think of them, and it makes me happy.

[22:44] <theorbtwo> We've returned to perl4?

[22:44] <Juerd> theorbtwo: Symbolic though evaluated back to the point of definition, at a later point in time.

[22:44] <TimToady> no.

[22:45] <Juerd> Maybe: symbolic references the way they would perhaps have been if closures had existed when symrefs were invented :P

[22:45] <TimToady> it's symbolic in the sense that "I want to mean exactly what @foo meant at this point".

[22:45] <theorbtwo> That sounds deeply, deeply evil.

[22:45] <TimToady> that's precisely what a hard ref is doing.

[22:45] <TimToady> hard refs are deeply deeply evil. :)

[22:46] <Juerd> theorbtwo: No, deeply, deeply theoretically correct and practically useful :)

[22:46] <TimToady> but our hard refs now capture the syntactic context of how @foo was being used at that point.

[22:46] <theorbtwo> Except instead of going back in time and looking at what the name meant then, you figure out what the name means when you evaluate it the first time, and squirel away its meaning, not it's name.

[22:46] <TimToady> so we can know if @foo was being used as the invocant, for instanc.e

[22:47] <Juerd> theorbtwo: If you have, in Perl 5, the closure sub { return @bar }, you can still decide on the context of @bar later, but the @bar at the time of the closure construction is used.

[22:47] <theorbtwo> Juerd: Right.

[22:47] <Juerd> theorbtwo: That's more or less what captures do, only without the closure.

[22:47] <Juerd> And you can decide binding, instead of just context.

[22:47] <TimToady> "...only without the cat."

[22:47] <Juerd> TimToady: yea

[22:47] <Juerd> That's what I was thinking

[22:49] <Juerd> We need to come up with a good way of explaining this. We need comparisons to references, to pointers, to symrefs, to closures.

[22:49] <Juerd> It's a bit of all of them.

[22:49] <Juerd> Maybe not pointers.

[22:50] <Juerd> Though references are of course just carefully encapsulated pointers.

[22:50] <theorbtwo> And perl6 is just carefully papered-over transistors.

[22:51] <TimToady> the paper is rather colorful though, kinda like the old Dutch money...

[22:51] <Juerd> Ahh, how I miss the designs of our old paper money...

[22:51] <TimToady> more like plastic, actually...

[22:51] <TimToady> but yes.

[22:52] <theorbtwo> It seems like Captures are a terribly complex thing.  Every capture has 42 different sorts of bits in it, and is it an array as an invocant, or as a bunch of arguments...

[22:52] <Juerd> Plastic?

[22:52] <theorbtwo> In any case, the vast majority of captures only have one piece used.

[22:52] <Juerd> It may be expensive and canvas like paper, but it's not plastic :)

[22:52] <TreyHarris> i've read the Capture.pod a couple times, and it's starting to make sense to me, but perhaps not entirely.  if I were implementing a linked list, would I use Capture objects to point my nodes at next and prev, or something else?

[22:52] <Juerd> TreyHarris: A linked list?

[22:53] * theorbtwo sighs.

[22:53] <Juerd> Really, have you ever cared about doing that in Perl, or any other programmer friendly dynamic language?

[22:53] <Juerd> I find it hard to think in these terms even :)

[22:53] <Juerd> TreyHarris: You could indeed use captures. Easily.

[22:53] <TreyHarris> Juerd: I'm not suggesting it because I'd actually want to do it, I'm just trying to decompose the thing to first principles.

[22:53] <theorbtwo> I'm not sure at this point if you can actually use anything /other/ then captures.

[22:54] <theorbtwo> Is there anything else left?

[22:54] <Juerd> Maybe captures can be explained as closures without code.

[22:54] <Juerd> So closures that just refer to variables, not to code that's executed.

[22:54] <theorbtwo> Does that make things easier to explain, or harder?

[22:54] <Juerd> In terms of reference counting, a variable that's closed over is a reference.

[22:55] <Juerd> It's just not an explicit reference. It's the same kind of reference a capture would have, I think.

[22:55] <TreyHarris> theorbtwo: well, a Node object could have a prev and next Node attributes.  but without creating a Node object, I think you're right.

[22:55] * Limbic_Region reads who is going to be at the YAPC::NA hackathon and he really really wants to go

[22:55] <theorbtwo> Sigh.

[22:56] <theorbtwo> I'm going to go to bed and watch an episode of West Wing.  I'll be back in around 50 minutes, probably.

[22:56] <Juerd> theorbtwo: Depends on the recipient. I think that the harder you try to understand it, the more magic you try to think of, and the harder it gets anyway. I let it alone for a weekend and today realised what it must be like. This means that our current documentation is not suitable for Perl 5 coders yet.

[22:56] <Juerd> Because realisation should come at the moment of reading

[22:57] <Juerd> Though postponed realisation is quite appropriate when it comes to captures :)

[22:57] <Limbic_Region> heh

[22:57] <Limbic_Region> ;-)

[22:58] <Juerd> It's like string eval in a closure, but without the closure and without the string eval.

[22:58] <Juerd> Darn, this can be explained in so many ways that do not involve any cat.

[22:59] <bsb> P5 has globs, they're Capture like in complexity (backlogging)

[22:59] <Juerd> I disagree.

[22:59] <TimToady> it's the deferred interpretation of an utterance till you know how it's going to be used.

[22:59] <Juerd> They're capturelike in complexity of use, but not in complexity of understanding :)

[22:59] <Juerd> (I think)

[23:00] <Limbic_Region> TimToady - so they're Schrodingerish

[23:01] <TimToady> only without the cat

[23:01] <Juerd> New word: catlessness

[23:01] <TimToady> just the smile.

[23:01] <theorbtwo> Juerd: Thank you for the string eval of closure idea.

[23:01] <Limbic_Region> no matter how we try to get quantum mechanics out of p6 (superpositions to junctions) we just can't avoid

[23:01] <Juerd> theorbtwo: Did it help?

[23:01] <theorbtwo> I now understand how they're better then references.

[23:01] <Juerd> theorbtwo: Or just make you smile? :P

[23:02] <theorbtwo> (And how to fix the problem I had earlier in the day -- where I need a string eval with a closure, or perhaps vice-versa.)

[23:02] <theorbtwo> (Converting zcode's version of symbolic references to perl5.)

[23:02] <TimToady> "Smile when you say that." --the Virginian

[23:02] <Juerd> Okay, that's good to know.

[23:02] <Juerd> Then I have one explanation that works, at least for you.

[23:02] <bsb> The resonance between Captures, Signatures, param passing and the $/ also help to understand, just need bootstrapping

[23:03] <Juerd> That's very Perl 6 minded, "just need bootstrapping".

[23:03] <TimToady> most people will just cargo cult it.

[23:03] <TimToady> and that's fine to begin with

[23:03] <Juerd> In other communities, people hide when they read "bootstrap". Here, it's considered normal and possible.

[23:04] <theorbtwo> Juerd: They still seem unneccessarly complex.

[23:04] <bsb> Bootstrapping understanding would probably be via param passing analogies "X is just a Y"

[23:04] <bsb> a la P5's OO

[23:04] <theorbtwo> Just slightly better, and that problem with p5 references can be fixed without reinventing globs.

[23:04] <TimToady> A Capture is just a bag of roles that...

[23:04] <Juerd> theorbtwo: They are complex. But it's knowledge you learn ONCE, and can then use for binding, subroutine arguments, and the things you've always used references for.

[23:04] <theorbtwo> Really going up now, popcurn finished.

[23:04] <Juerd> TimToady: Only without the bag? ;)

[23:05] <theorbtwo> But references aren't like subroutine processing.

[23:05] <bsb> A capture is just $/ looking at your arguments...

[23:05] <TimToady> no, the bag is without the popcorn, the popcorn is within the bag

[23:05] <theorbtwo> You can always unify two difficult concepts by making a new concept that is more difficult then either of them.

[23:05] <Juerd> theorbtwo: Because references are so limited. If all you have is references, then every problem looks like a nail. Or something like that.

[23:06] <theorbtwo> Bah, now I've lost my DVD!

[23:06] <FurnaceBoy> me too

[23:06] <TimToady> just sit down and eat the popcorn.  The DVD will eventually become self-evident.

[23:07] <Juerd> theorbtwo: This concept isn't more difficult. It's the same thing, only wrapped in a closure-like thing so that it can be used independently of syntax.

[23:07] <bsb> TimToady: Captures/Sigs are going to be used for object matching Rules right?  Filling in the missing bits eventually

[23:07] <Juerd> And independent of the point in runtime.

[23:08] <Juerd> And --ooh, nice-- serializable. Perhaps.

[23:08] <TimToady> bsb: sigs can match objects, and a capture is just one kind of object.

[23:09] <Juerd> theorbtwo: Indeed it's complex. "too" or not depends on the person. To the average PHP-minded programmer, they will be far too complex. But they don't maintain code, they copy/paste it without understanding.

[23:09] <TimToady> probably closely related to whatever kind of object you get out if you try to reverse the procedure.

[23:09] <Juerd> ayk

[23:09] <Juerd> afk

[23:09] <Juerd> s/ayk//

[23:11] <bsb> night all

[23:11] <FurnaceBoy> n8

[23:29] *** justatheory joined
