[00:11] *** glasser joined
[00:37] *** systems`` joined
[00:47] *** vel joined
[00:47] *** systems`` left
[01:01] <audreyt> xinming: your .close change somehow broke 200+ tests...

[01:01] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[01:01] <audreyt> I'll take a look after nap

[01:01] <audreyt> @messages

[01:01] <lambdabot> lanny said 2h 54m 50s ago: You'll want to check the smokes for Win32. r14463 (just before GHC threading turned on) has 2 failures and after 231 (including having to kill pugs by hand on 2 test to

[01:01] <lambdabot> continue).

[01:02] <audreyt> @tell lanny it's not me, it's xinming...

[01:02] <lambdabot> Consider it noted.

[01:05] *** ferreira left
[01:09] <Limbic_Region> audreyt - what's your next timezone anyway?

[01:09] <audreyt> brazil

[01:10] <Limbic_Region> perlbot .bz

[01:10] <perlbot> .bz is Belize

[01:10] <eviltwin_b> .br :)

[01:10] <Limbic_Region> ah

[01:23] *** justatheory joined
[01:27] <audreyt> repaired

[01:27] <svnbot6> r14480 | audreyt++ | * Pugs.Types: IO::Dir is not a subtype of IO, really...

[01:27] <svnbot6> r14480 | audreyt++ | * Pugs.Prim: Socket::close and IO::close should be two different things.

[01:27] <audreyt> @tell xinming never mind, fixed

[01:27] <lambdabot> Consider it noted.

[01:29] <eviltwin_b> don't think you @tell-ed him to start with; only a snark to lanny

[01:32] <audreyt> that's correct.

[01:32] <audreyt> @tell lanny never mind; fixed :)

[01:32] <lambdabot> Consider it noted.

[01:33] <audreyt> sorry for the snarky tone; intense sleep deprivation does that for a person...

[01:34] <eviltwin_b> enh.  actually I think I was being snarky there (but same comment; was up until 3am yesterday then got up earlyish today.  mmm, weather futzing with my head)

[01:36] <xinming> audreyt: sorry for my rudeness about introducing that bug... >_<

[01:36] <lambdabot> xinming: You have 1 new message. '/msg lambdabot @messages' to read it.

[01:36] <xinming> @messages

[01:36] <lambdabot> audreyt said 9m ago: never mind, fixed

[01:36] <audreyt> xinming: no, it's actually not your bug; it's that IO::Dir was incorrectly considered a subclass of IO

[01:37] <audreyt> but that's wrong because $dir.say doesn't do anything meaningful

[01:37] <audreyt> your change is fine :)

[01:37] <xinming> en, thanks.

[01:37] <audreyt> (it just revealed an existing bug)

[01:37] <xinming> BTW

[01:38] <xinming> while we pass the variable to perl 5, is $a sames as \$a while we pass it to perl 5 please?

[01:38] <xinming> hmm, I mean from Pugs

[01:39] <xinming> The bugfix you fixed yesterday for me seems treat  $a and \$a are the same

[01:40] <xinming> my $a; $t.process("hello", $v, $a); which would act as $t.process("hello", $v, \$a);

[01:40] <audreyt> well it depends on what the other side wants

[01:40] <audreyt> if it wants something it can write back (as is the case for .process)

[01:40] <audreyt> then it's rw

[01:41] <audreyt> in which case $a will work too

[01:41] <audreyt> I think, anyway

[01:43] *** prism joined
[01:44] * xinming is confused about this small difference...

[01:45] <xinming> so, you mean, $a is just an alias passing to the perl 5 program, right?

[01:45] <audreyt> right

[01:45] <xinming> and by default, it's ro, But we need to write to it,

[01:45] <xinming> so, It's an rw alias.

[01:46] <xinming> hmm, not sure about this. >_<

[01:46] <audreyt> basically in perl5 land, when we have a pugs value

[01:46] <audreyt> if you teat it as a scalar ref

[01:46] <audreyt> then it behaves as a lvalue, that is you can assign to it

[01:47] <audreyt> and because in Pugs, $x=1 and $$x=1 and $$$x=1 and $$$$x=1 means the same thing

[01:47] <audreyt> (if $x is a simple uninitialized scalar variable)

[01:47] <audreyt> the extra \ got canceled away

[01:48] <audreyt> but my mind isn't working really right now; I should probably sleep instead of offering potentially misleading/bogus explanation :)

[01:51] *** lanny joined
[01:51] <xinming> audreyt: Just go and sleep. :-)

[01:51] <lanny> Hiya.  Sorry to point at your stuff first, audreyt.  I had reviewed xinming's changes and they seemd trivial so...

[01:51] <lambdabot> lanny: You have 2 new messages. '/msg lambdabot @messages' to read them.

[01:52] <lanny> Thanks for the every-so-quick-fix.  You are gonna burn yourself out at this pace.  :)

[01:52] *** SubStack joined
[01:52] <lanny> @messages

[01:52] <lambdabot> audreyt said 50m 5s ago: it's not me, it's xinming...

[01:52] <lambdabot> audreyt said 19m 31s ago: never mind; fixed :)

[01:52] <audreyt> lanny: not likely :) been like this for 1.5+ years now :)

[01:53] <lanny> Let me just say then that I'm glad you are using your powers for good instead of ebil.

[01:54] *** LimbicRegion joined
[01:54] <audreyt> I'm using it for fun, actually, but thanks :)

[01:54] * audreyt fades into sleepland &

[01:54] *** LimbicRegion is now known as Limbic_Region

[02:15] *** thepler joined
[02:25] *** thepler joined
[02:57] *** weinig is now known as weinig|sleep

[03:07] *** avarab joined
[03:09] *** avarab is now known as avar

[03:19] *** avarab joined
[03:19] *** avarab is now known as avar

[03:30] *** avarab joined
[03:42] *** avarab_ joined
[03:51] *** avar joined
[04:02] *** Eidolos joined
[04:02] *** avarab joined
[04:04] <svnbot6> r14481 | lanny++ | * t/regex/p6regex/p6regex.t -- stab at un-todo of unexpected passed tests

[04:58] *** root4o joined
[05:00] <root4o> hi,   { ... } is not implemented yet , right ?

[05:01] <eviltwin_b> L<S06|The &?BLOCK object> contains a code snippet using ?? :: (instead of ?? ||)

[05:01] <eviltwin_b> ?eval sub x {...}; x()

[05:01] <evalbot_r14481> *** ... - not yet implemented␤    at <eval> line 1, column 8-11

[05:01] <eviltwin_b> looks that way

[05:02] *** MacVince joined
[05:02] <eviltwin_b> hm, actually that looks like it DTRT:  {...} means "this sub is not yet implemented"

[05:03] <eviltwin_b> ?eval sub x {!!!}; x()

[05:03] <evalbot_r14481> Error: !!! - not yet implemented

[05:03] <eviltwin_b> ?eval sub x {???}; x()

[05:03] <evalbot_r14481> Error: Cannot cast from VUndef to Handle (VHandle)

[05:03] <eviltwin_b> whoops, that wan't what I meant

[05:04] <MacVince> Hi all!

[05:04] <root4o> 10x

[05:04] <eviltwin_b> huh, yes it was, but {???} apparently isn't implemented

[05:05] <eviltwin_b> ?eval ...

[05:05] <evalbot_r14481> *** ... - not yet implemented␤    at <eval> line 1, column 1 - line 2, column 1

[05:06] <root4o> this also doesnt seems to work ? right...

[05:06] <root4o>  my $args1 = \(1,2,3);

[05:06] <eviltwin_b> huh?

[05:06] <root4o> foo(|$args1)

[05:06] <eviltwin_b> the point is that {...} *means* "not yet implemented"

[05:07] <root4o> i'm getting

[05:07] <eviltwin_b> oh, you're on to something else

[05:07] <root4o> pugs: don't know how to toVV': VList [VInt 1,VInt 2,VInt 3]

[05:07] <root4o> but

[05:07] <root4o> $args1 = \{ x => 5 };

[05:08] <root4o> works

[05:15] <eviltwin_b> ?eval my $x = \(1,2,3); sub x ($a, $b, $c) {say "Hi!"}; x(|$x)

[05:15] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:15] *** BooK joined
[05:16] * eviltwin_b wonders if he's too tired to be trying to figure this out

[05:17] <root4o> ?eval my $x = \(1,2,3); sub x ($a, $b, $c) {say "Hi!"}; x(|$x)

[05:17] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:17] <root4o> eval my $x = \(1,2,3); our sub x ($a, $b, $c) {say "Hi!"}; x(|$x)

[05:17] *** nothingmuch joined
[05:17] <root4o> ?eval my $x = \(1,2,3); sub x ($a, $b, $c) {say "Hi!"}; x(|$x)

[05:17] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:17] <eviltwin_b> you need the leading ?

[05:17] <root4o> yes i got that :)

[05:18] <eviltwin_b> yeh, I'm slow :)

[05:18] <root4o> ?eval my $x = \(1,2,3); our sub x ($a, $b, $c) {say "Hi!"}; x(|$x)

[05:18] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:18] <root4o> ?eval my $x = \{a => 5}; sub x ($a) {say "Hi!"}; x(|$x)

[05:18] <evalbot_r14481> OUTPUT[Hi!␤] Bool::True

[05:18] <root4o> eval my $x = \{a => 5}; sub x ($a) {say "Hi!"}; x(|$x)

[05:18] <root4o> this works

[05:19] <root4o> pairs also doesnt seems to work

[05:19] <eviltwin_b> ?eval my @x = \(1,2,3); sub x ($a, $b, $c) {say "Hi!"}; x(|@x)

[05:19] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:20] <root4o> when I type '?' does ppl on the irc see it ?

[05:20] <eviltwin_b> yes

[05:20] <root4o> good

[05:20] <root4o> :)

[05:21] <root4o> i'm tring to find a thing to write test, for... but it is more harder to find something than to write the test ;)

[05:21] <eviltwin_b> ?eval my $x = \(1,2,3); say $x.perl

[05:21] <evalbot_r14481> OUTPUT[\CaptSub {c_feeds = [MkFeed {f_positionals = [VPure (IFinite 1),VPure (IFinite 2),VPure (IFinite 3)], f_nameds = fromList []}]}␤] Bool::True

[05:22] <eviltwin_b> ?eval my $x = \(1,2,3); say $x

[05:22] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:22] <root4o> and then when something dont work ;)

[05:22] <eviltwin_b> ?eval my @x = \(1,2,3); sub x {say "Hi!"}; x(|@x)

[05:22] <root4o> yes it has to be Capture ,right ?

[05:22] <evalbot_r14481> OUTPUT[Hi!␤] Bool::True

[05:22] <root4o> hmm :)

[05:22] <eviltwin_b> yes, it needs to be a Capture

[05:23] <root4o> so @ instead of $

[05:23] <eviltwin_b> ?eval my $x = \(1,2,3); say $x

[05:23] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:24] <root4o> ?eval my @x = \(1,2,3); sub x (@a){say "Hi!"}; x(|@x)

[05:24] <evalbot_r14481> OUTPUT[Hi!␤] Bool::True

[05:24] <eviltwin_b> ?eval my $x = \(1,2,3); sub x (Int $a, Int $b, Int $c) {say "Hi!"}; x(|$x)

[05:24] <evalbot_r14481> Error: No compatible subroutine found: "&x"

[05:24] <root4o> ?eval my @x = \(1,2,3); sub x (@a){say @a}; x(|@x)

[05:24] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:24] <eviltwin_b> that still seems wrong, the point of unary | is that it's supposed to unwrap the array

[05:25] <root4o> yes

[05:25] <eviltwin_b> ?eval my $x = \(1,2,3); sub foo (Int $a, Int $b, Int $c) {say "Hi!"}; foo(|$x)

[05:25] <evalbot_r14481> Error: No compatible subroutine found: "&foo"

[05:25] <root4o> it gets capture

[05:25] *** avarab is now known as avar

[05:25] <root4o> but seems it can not unwrap it !

[05:26] <root4o> ?eval |(1,2,3)

[05:26] <evalbot_r14481> (1, 2, 3)

[05:26] <eviltwin_b> ?eval my $x = \(1,2,3); sub foo (Int $a, Int $b, Int $c) {say "Hi!"}; foo(*$x)

[05:26] <evalbot_r14481> Error: ␤Unexpected "x"␤expecting term postfix, operator, ":" or ")"

[05:27] <eviltwin_b> ?eval my $x = \(1,2,3); sub foo (Int $a, Int $b, Int $c) {say "Hi!"}; foo(|($x))

[05:27] <evalbot_r14481> Error: No compatible subroutine found: "&foo"

[05:27] <root4o> ?eval $x = \(1,2,3); say *$x

[05:27] <evalbot_r14481> Error: ␤Unexpected "x"␤expecting term postfix, operator, ":" or ","

[05:27] <eviltwin_b> no, that was me thinking wrong

[05:28] <root4o> ?eval $x = \(1,2,3); say |$x

[05:28] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:28] <root4o> ?eval $x = \(1,2,3); say *|$x

[05:28] <evalbot_r14481> OUTPUT[any(VNum Infinity,VV (VPure (CaptSub {c_feeds = [MkFeed {f_positionals = [VPure (IFinite 1),VPure (IFinite 2),VPure (IFinite 3)], f_nameds = fromList []}]})))␤] Bool::True

[05:30] <root4o> ?eval $x = \(1,2,3); say $x.yaml

[05:30] <evalbot_r14481> OUTPUT[--- !hs/IScalar ␤- !hs/VV ␤  - !hs/Pugs.Val.Val ~␤␤] Bool::True

[05:30] <eviltwin_b> ?eval my $x = \(1,2,3); say |$x

[05:30] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:31] <eviltwin_b> ?eval my $x = \(1,2,3); say |($x)

[05:31] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:31] <eviltwin_b> ?eval my $x = \(1,2,3); say(|($x))

[05:31] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:31] <root4o> ?eval $x = \([1,2,3]); say |$x

[05:31] <eviltwin_b> hrm, that looks not good

[05:31] <evalbot_r14481> pugs: don't know how to toVV': VRef <Array:0xb7b805f0>

[05:32] <root4o> what is 'toVV' mean ?

[05:32] <eviltwin_b> dunno but it sounds internal

[05:32] <root4o> ?eval $x = \(a => 1); say |$x

[05:32] * eviltwin_b is still working his way throuhg the Synopses

[05:32] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:33] <eviltwin_b> see, I thought unary | "unwrapped" the cpature but that looks like not

[05:33] <root4o> ?eval $x = \(a => 1); sub x($a) { $a }; say x($x)

[05:33] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:34] <root4o> ?eval $x = \(a => 1); sub x($a) { $a }; say x(|$x)

[05:34] <evalbot_r14481> OUTPUT[<capt>␤] Bool::True

[05:34] <root4o> ?eval $x = \(a => 1); sub x($a) { $a }; say x(*|$x)

[05:34] <root4o> (22:35:03) evalbot_r14481: OUTPUT[<capt>␤] Bool::True

[05:34] <evalbot_r14481> OUTPUT[any(VNum Infinity,VV (VPure (CaptSub {c_feeds = [MkFeed {f_positionals = [], f_nameds = fromList [("a",[VPure (IFinite 1)])]}]})))␤] Bool::True

[05:36] <eviltwin_b> I don't think we need the "say" there

[05:37] *** shobadobs joined
[05:37] <root4o> ha

[05:37] <root4o> aha

[05:41] <eviltwin_b> ?eval my $x = \(1,2,3); |$x

[05:41] <evalbot_r14481> \CaptSub {c_feeds = [MkFeed {f_positionals = [VPure (IFinite 1),VPure (IFinite 2),VPure (IFinite 3)], f_nameds = fromList []}]}

[05:41] <eviltwin_b> ?eval my $x = \(1,2,3); |(|$x)

[05:41] <evalbot_r14481> \CaptSub {c_feeds = [MkFeed {f_positionals = [VPure (IFinite 1),VPure (IFinite 2),VPure (IFinite 3)], f_nameds = fromList []}]}

[05:44] <root4o> ?eval $x =\{a => 5}; |$x

[05:44] <evalbot_r14481> {("a" => 5),}

[05:45] <root4o> ?eval $x =\(1,2); |{$x}

[05:45] <evalbot_r14481> {Syn "block" {Var "$x"}}

[05:45] <root4o> ?eval $x =\(1,2); {|$x}

[05:45] <evalbot_r14481> \CaptSub {c_feeds = [MkFeed {f_positionals = [VPure (IFinite 1),VPure (IFinite 2)], f_nameds = fromList []}]}

[05:46] <root4o> ?eval $x =\{(1,2)}; |$x

[05:46] <evalbot_r14481> \{Syn "block" {Syn "," {1;␤                       2}}}

[06:11] *** root4o left
[06:28] *** marmic joined
[06:39] *** seano joined
[06:46] *** DHGE joined
[06:53] *** nothingmuch joined
[07:54] *** lumi joined
[08:03] *** AzureStone joined
[08:06] *** foo\ joined
[08:31] *** SubStack joined
[08:40] *** SCalimlim joined
[08:52] *** iblechbot joined
[09:00] *** pjcj joined
[09:05] *** kanru joined
[09:10] *** ditto joined
[09:13] *** DHGE left
[09:22] *** larsen_ joined
[09:28] *** dduncan left
[09:29] *** nothingmuch joined
[09:33] *** qmole joined
[09:40] *** Tzoa joined
[09:41] *** larsen__ joined
[09:45] *** Tzoa left
[10:31] *** yodo joined
[10:34] *** frankg joined
[10:39] *** stennie joined
[10:56] *** lumi joined
[10:56] *** marmic joined
[10:56] *** andres joined
[10:56] *** Steve_p joined
[10:56] *** f0rth joined
[10:56] *** TimToady joined
[10:56] *** ingy joined
[10:56] *** fridim joined
[10:56] *** ajs joined
[10:56] *** awwaiid joined
[10:56] *** holoway joined
[10:56] *** chip joined
[10:56] *** sri_ joined
[10:56] *** dvorak joined
[10:56] *** orafu joined
[10:56] *** revdiablo joined
[10:56] *** perlbot joined
[10:56] *** rafl_ joined
[10:56] *** hcchien joined
[10:56] *** cj joined
[10:56] *** kolibrie joined
[10:56] *** jferrero joined
[10:56] *** frankg joined
[10:56] *** qmole joined
[10:56] *** nothingmuch joined
[10:56] *** kanru joined
[10:56] *** iblechbot joined
[10:56] *** SCalimlim joined
[10:56] *** SubStack joined
[10:56] *** foo\ joined
[10:56] *** shobadobs joined
[10:56] *** MacVince joined
[10:56] *** weinig|sleep joined
[10:56] *** buubot joined
[10:56] *** Odin- joined
[10:56] *** bennymack joined
[10:56] *** lollan joined
[10:56] *** jabbot joined
[10:56] *** araujo joined
[10:56] *** cnrocks joined
[10:56] *** wilx joined
[10:56] *** plural joined
[10:56] *** bcorn joined
[10:56] *** audreyt joined
[10:56] *** Juerd joined
[10:56] *** webmind joined
[10:56] *** PerlJam joined
[10:56] *** leo joined
[10:56] *** pmichaud joined
[10:56] *** wolverian joined
[10:56] *** yuval joined
[10:56] *** statico2 joined
[10:56] *** mdiep_ joined
[10:56] *** spoop joined
[10:56] *** Narcisse joined
[10:56] *** stevan joined
[10:56] *** meppl joined
[10:56] *** takesako joined
[10:56] *** takanori_ joined
[10:56] *** autark joined
[10:56] *** buu joined
[10:56] *** nine joined
[10:56] *** jdv79 joined
[10:56] *** rafl joined
[10:56] *** Ikarus joined
[10:56] *** svnbot6 joined
[10:56] *** nipotaway joined
[10:56] *** gnuvince joined
[10:56] *** jojo joined
[10:56] *** spinclad joined
[10:56] *** Shabble joined
[10:56] *** jiing joined
[10:56] *** masak joined
[10:56] *** osfameron joined
[10:56] *** beppu joined
[10:56] *** cognominal joined
[10:56] *** Yappo joined
[10:56] *** eviltwin_b joined
[10:56] *** baest joined
[10:56] *** ajs_home joined
[10:56] *** kcwu joined
[10:56] *** norageek joined
[10:56] *** kalven joined
[10:56] *** woremacx joined
[10:56] *** mako132 joined
[10:56] *** kane-xs_ joined
[10:56] *** ruz joined
[10:56] *** xinming joined
[11:01] *** weinig|sleep is now known as weinig

[11:03] *** buetow joined
[11:23] *** chris2 joined
[11:33] *** AzureStone joined
[11:38] *** Psyche^ joined
[11:38] *** pjcj joined
[11:50] *** Psyche^ is now known as Patterner

[11:50] *** elmex joined
[12:13] *** ditto joined
[12:37] *** andres_ joined
[12:40] <svnbot6> r14482 | kudra++ | Summaries for this week

[13:48] <meppl> "require" doesnt work inside a class?

[13:49] <audreyt> nopaste? or commit a test?

[13:56] *** stevan_ joined
[14:10] <pasteling> "meppl" at 89.54.90.94 pasted "require does not work here?" (10 lines, 114B) at http://sial.org/pbot/20597

[14:10] <meppl> k

[14:10] <meppl> audreyt, so, in this paste require does not work

[14:10] *** weinig is now known as weinig|bbl

[14:11] <meppl> the error-message is:

[14:11] <meppl> *** No compatible subroutine found: "&Fest::Foo"

[14:11] <meppl>     at ./Fest.pm line 7, column 9-33

[14:11] <meppl> it does not work, when i use "require" in a class, which is in a extra file

[14:11] <xinming> BTW, may I ask what does "nopaste" mean please? Every time I saw nopaste, I know I would paste somewhere in trained reflex... :-P

[14:12] <meppl> "require" works in a "class{}"

[14:12] <meppl>  

[14:13] <meppl> xinming, paste code into here ;)    http://sial.org/pbot/paste

[14:13] <audreyt> meppl: well try ::Fest::Foo

[14:13] <audreyt> xinming: nopaste is the older paste service http://nopaste.snit.ch/

[14:13] <meppl> xinming, "nopaste" ---> not paste it direct in the channel

[14:13] <audreyt> meppl: problem is that require does not yet introduce a class literal

[14:13] <audreyt> not exactly sure if it should

[14:13] <audreyt> maybe yes

[14:13] <meppl> hm

[14:14] <meppl> no, that doesnt work, too

[14:14] <meppl> whatever

[14:15] <meppl> i can also use "use"

[14:15] <meppl> momentaneous

[14:15] <meppl> ;)

[14:15] <meppl> thx

[14:15] <audreyt> ::Fest::Foo.new ?

[14:15] <audreyt> that doesn't work?

[14:15] <meppl> oh

[14:15] <meppl> audreyt, that works

[14:15] <meppl> yes

[14:16] <meppl> thank you very much audrey

[14:16] <audreyt> ok. the problem is that

[14:16] <audreyt> require Foo::Bar

[14:16] <audreyt> can't tell if F::B is a class (in which case Foo::Bar should be registered as literal)

[14:16] <audreyt> or if it's a package (in which case it should not. Or should it?)

[14:16] <audreyt> so in writing ::Fest::Foo you delay the resolution to runtime

[14:17] <meppl> ah, okay

[14:18] <audreyt> principle of least surprise tells us that maybe registering a literal regardless of class/moduleness is sane

[14:19] * audreyt ponders about it some more

[14:36] <meppl> what about that?       require "/home/non/Sense.pm";

[14:37] <meppl> require $foo;

[14:37] <meppl> my $bar = ::$foo.new();

[14:37] <meppl> does not work ;)

[14:38] <meppl> if $foo were edited to   home::non::Sense

[14:38] <audreyt> yup

[14:39] <audreyt> ::($foo) will work

[14:40] <meppl> thx

[14:49] <nothingmuch> audreyt: got a few spare minutes for a brain dump?

[14:49] <nothingmuch> wrt MO::Emit

[14:52] <eviltwin_b> dumb question about capture objects?

[14:53] <audreyt> eviltwin_b: there's only dumb answers...

[14:53] <eviltwin_b> ?eval my $x = \(1,2,3); sub foo (Int $a, Int $b, Int $c) {say "Hi!"}; foo(|$x)

[14:53] <audreyt> nothingmuch: wait me for ~20min?

[14:53] <evalbot_r14482> Error: No compatible subroutine found: "&foo"

[14:53] <audreyt> need to finish breakfast

[14:53] <eviltwin_b> shouldn't that be interpolating?

[14:53] <audreyt> nothingmuch: of course you can braindump ahead

[14:53] <eviltwin_b> a couple of us were tossing that around last night (~8 hours ago)

[14:54] <nothingmuch> audreyt: i'll wait

[14:54] <nothingmuch> thanks =)

[14:54] <nothingmuch> }:)

[14:54] <eviltwin_b> 9 hours ago :)

[14:54] <audreyt> eviltwin_b: weird... seems interpolation is like completely broken :)

[14:55] <audreyt> I'll check. a sec...

[14:55] <eviltwin_b> we were wondering if it was implemented yet.  further exploration made it look like the Capture object was passed through unchanged

[14:55] <audreyt> that is the case though it shouldn't

[14:55] <nothingmuch> audreyt: i'll hop to the post office

[14:55] <eviltwin_b> (i.e.. declare with a single untyped argument, that argument is rvealed to be a Capture)

[14:55] <nothingmuch> ~30 mins

[14:55] <nothingmuch> sounds good?

[14:55] <audreyt> compare $x = [1,2,3]

[14:55] <audreyt> nothingmuch: sure

[14:55] <audreyt> which does interpolate correctly

[15:28] *** vel joined
[15:33] *** [particle] joined
[15:46] <audreyt> eviltwin_b: there you go

[15:46] <audreyt> thanks for prodding

[15:46] <svnbot6> r14483 | audreyt++ | * Interpolation of Capture objects via prefix:<|> implemented,

[15:46] <svnbot6> r14483 | audreyt++ |   suggested by eviltwin_b++:

[15:46] <svnbot6> r14483 | audreyt++ |     sub f ($x, $y) { ... }

[15:46] <svnbot6> r14483 | audreyt++ |     my $capt = \(1,2);

[15:46] <svnbot6> r14483 | audreyt++ |     f(|$capt); # now works

[15:46] <svnbot6> r14483 | audreyt++ |   Previously only Array, Hash, Scalar and Pair were intepolated.

[15:46] <svnbot6> r14482 | kudra++ | Summaries for this week

[15:47] <audreyt> nothingmuch: hmm it's ben nearly an hour...

[15:48] <audreyt> nothingmuch: I had to nap a bit. please braindump ahead when you're back but obra will abduct me to some coffee tasting soon

[15:48] <gaal> audreyt: in a few weeks i'll prolly have some more time - and can start moosing over more stuff to newland in the parser

[15:48] <audreyt> gaal: good, mostly it's just the Sub signature producer

[15:48] <audreyt> once it's there we can implement sub Main

[15:48] <audreyt> which is a nice standalone task

[15:48] <gaal> well, and then everything else!

[15:49] * audreyt really looks forward to sub Main

[15:49] <gaal> eg oldcode, pads(!), lexical pragmas

[15:49] <audreyt> I mean sub MAIN.

[15:49] <audreyt> nodnod

[15:49] *** Khisanth joined
[15:49] <nothingmuch> audreyt: back

[15:49] <audreyt> oy, there goes my napping

[15:50] <gaal> I'd like to be / under the sea / in an octopuses garden / in sub MAIN

[15:50] <nothingmuch> heh =)

[15:50] <gaal> er, wrong song

[15:50] <nothingmuch> you can nap if you prefer

[15:50] <audreyt> I'll nap _and_ IRC at the same time

[15:50] <audreyt> so dump ahead

[15:50] <nothingmuch> heh

[15:50] <nothingmuch> it's supposed to be bidi ;-)

[15:51] <nothingmuch> but okay

[15:51] <nothingmuch> i'm trying to figure out MO::Emit

[15:51] <nothingmuch> been doing so for the past 2-3 days

[15:51] <nothingmuch> i am trying to design it so that it's portable

[15:51] <nothingmuch> to some extent

[15:51] <nothingmuch> the mandatory incest we require:

[15:52] <nothingmuch> the emitter has an undefined output, but a well defined input (responder interfaces)

[15:52] <nothingmuch> sometimes the output can be responder interface, if it's a dynamic runtime

[15:52] <nothingmuch> (or partly)

[15:52] <audreyt> (all runtimes are dynamic)

[15:52] <nothingmuch> e.g. in the case of the p5 emitter the output is packages

[15:52] <nothingmuch> all our runtimes are dynamic

[15:52] <audreyt> correct.

[15:52] <nothingmuch> however, MO, by design, can also do static systems

[15:53] <nothingmuch> anymoose

[15:53] <audreyt> yes, but a compelling use case does not yet exist to generalize that so bduf yagni et

[15:53] <audreyt> cetera

[15:53] <nothingmuch> yes, i'm ignoring the cases i don't care about in terms of implementation

[15:53] <nothingmuch> i'm just  being accurate in my descriptions ;-)

[15:54] <nothingmuch> however

[15:54] <nothingmuch> for my purposes the p5 emitter is not dynamic per se

[15:54] <nothingmuch> in that the target runtime doesn't twiddle MO objects all over the place

[15:54] <nothingmuch> so dynamic -> foreign dynamic is the same as dynamic -> static as far as the emitter is concerened

[15:54] <nothingmuch> (set aside the fact that the second is a lot more work ;-)

[15:55] <nothingmuch> i need two runtimes for p5:

[15:55] <nothingmuch> one is the interpreted one, in which there are actually calls to $ri->dispatch( $invocation, $responder );

[15:55] <nothingmuch> and the "compiled" one, in which $ri's are flattenned into packages

[15:55] <nothingmuch> and $invocation must be ::Method

[15:55] <nothingmuch> and $responder must be invocant

[15:55] <nothingmuch> the flattenning into packages is incest #1 that the emitter must do

[15:56] <audreyt> define incest

[15:56] <nothingmuch> (e.g. take apart a private interface, layer it over, and codegen methods that are actually dynamic with if ( caller == ... ) { $body_one->() })

[15:56] <nothingmuch> incest == related objects that know a lot about eachother

[15:56] *** stevan_ joined
[15:56] <audreyt> oh. tight coupling

[15:56] <audreyt> ok

[15:56] <nothingmuch> that is, you can't just toss any old object into the emitter

[15:56] <nothingmuch> the polymorphism only takes you so far

[15:57] <nothingmuch> tight coupling sounds like a good thing sometimes ;-)

[15:57] <nothingmuch> anymoose

[15:57] <nothingmuch> the second type of incest we need to take care of is method body <-> emitter

[15:57] <nothingmuch> the problem is that to write generic accessors

[15:58] <nothingmuch> that don't care what the emitter's output is

[15:58] <audreyt> ...is impossible

[15:58] <nothingmuch> i need some sort of abstracting out of calling conventions, etc

[15:58] <nothingmuch> well, it si possible, for very simple accessors

[15:58] <audreyt> you need another layer

[15:58] <nothingmuch> what I need is macros

[15:58] <audreyt> yes.

[15:58] <nothingmuch> e.g. method_call( $inv_ast, $method )

[15:58] <nothingmuch> but perl 5 doesn't have these

[15:59] <audreyt> write one for it then

[15:59] <nothingmuch> i can kludge them as simply runtime calls

[15:59] <nothingmuch> (fugly..., sub method_call { ... })

[15:59] <nothingmuch> or i can codegen some perl using Code::Perl (not very transformable)

[15:59] <nothingmuch> or I can finish Perl::Generate (too long)

[15:59] <audreyt> what transormatino you going to do?

[16:00] <audreyt> I think Code::Perl makes a lot of sense

[16:00] <nothingmuch> e.g. the method call macro

[16:00] <nothingmuch> it does

[16:00] <audreyt> as a proof of concept

[16:00] <nothingmuch> but it's holder objects aren't powerful enough

[16:00] <nothingmuch> it's nice as an emitter AST

[16:00] <nothingmuch> but not as a highlevel AST

[16:00] <audreyt> my pt is that HL AST is not needed for the specific case of ->pkg p5 emit

[16:01] <nothingmuch> indeed

[16:01] <nothingmuch> but Code::Perl is not enough for fake method call vs. real method call going into the same AST node

[16:01] <nothingmuch> which means i have  to rewrite subtrees

[16:01] <nothingmuch> which means pain

[16:01] <nothingmuch> also, it doesn't have a walking API

[16:01] <audreyt> it's localized limited pain though

[16:01] <nothingmuch> my plan B is to go 100% macro

[16:01] <audreyt> walking api is trivial

[16:01] <audreyt> just reify the calls

[16:02] <audreyt> wrap them with all same-named functions

[16:02] <nothingmuch> since i'm only emitting very specific code, i write macros for all these "things" (a method call, a return, etc)a

[16:02] <nothingmuch> nd the emitter has a class for macros

[16:02] <nothingmuch> which does the relevant Code::Perl calls

[16:02] <audreyt> that reifies them into data structure that represents suspented call

[16:02] <audreyt> presto, walkability

[16:02] <audreyt> yes, it's similar to the macros you just described

[16:02] <nothingmuch> yep

[16:02] <nothingmuch> any other ideas?

[16:03] <nothingmuch> err,nevermoose, it won't get any better than this

[16:04] <nothingmuch> okay, the second thing is how should the input params to the emitter be designed?

[16:04] <nothingmuch> i'm thinking there should be low level emitter that deals with responder interfaces

[16:04] <nothingmuch> and an  "assistant" that futzes the meta classes

[16:05] <audreyt> define futz

[16:05] <nothingmuch> well, the problem is that responder interfaces <-> perl 5 packages are not a 1:1 fit

[16:05] <nothingmuch> to support SUPER:: etc natively we decompile the responder interfaces into actual classes by first emitting the superclasses

[16:06] <nothingmuch> if the MRO and perl's MRO disagree

[16:06] <nothingmuch> we kludge by masking the superclass

[16:06] <nothingmuch> hence the unit being emitted is a collection of classes, typically

[16:07] <nothingmuch> but that is problematic, because classes are not the one true way of creating responder interfaces

[16:09] <audreyt> why is that prblmtc?

[16:09] <audreyt> you only mro-kldg on cls clstr

[16:09] <nothingmuch> that's for the "

[16:09] <nothingmuch> compiling" perl 5 emitter

[16:09] <nothingmuch> the non compiling emitter will simply fmap the input objects

[16:09] <audreyt> yeah so say you have a nonclass rspd if

[16:09] <nothingmuch> recursively replacing method defs with code refs

[16:09] <audreyt> yes yes

[16:10] <audreyt> a non class rspdif will not participate in c3

[16:10] <audreyt> it will handle mro some other way

[16:10] <audreyt> afaics

[16:10] <nothingmuch> yes

[16:10] <audreyt> so why is that problmtc?

[16:10] <nothingmuch> mm... i suppose the input to the emitter is just responder interfaces... =P

[16:11] <audreyt> I thougt you said that yourself.

[16:11] <audreyt> 17:52 < nothingmuch> the emitter has an undefined output, but a well defined input (responder interfaces)

[16:11] <nothingmuch> i guess i'm searching for something a bit more like a compilable unit

[16:11] <nothingmuch> heh

[16:11] <nothingmuch> oops =)

[16:11] <nothingmuch> well, that was a slip then

[16:11] <audreyt> I think it's orthogonal

[16:11] <audreyt> compunit means your analysis has a bound

[16:12] <audreyt> but for MO whenever you hit "emit" that's a compunit

[16:12] <audreyt> by definition

[16:12] <audreyt> so don't worry about that

[16:12] <nothingmuch> hmm

[16:12] <nothingmuch> fairynuff

[16:12] <audreyt> sepcomp will just trigger MO once for each compu

[16:12] <audreyt> (sorry for abbrs I'm napping so suspending laptop with my palms )

[16:12] <nothingmuch> ... and it'll be the emitter's problem i guess, to also glean data from the already compiled units

[16:13] <audreyt> or it calls into a nonlocal analyzer

[16:13] <nothingmuch> okay, i'll let you nap for real and stop talking nonesense ;-)

[16:13] <audreyt> without storing state itself

[16:13] <nothingmuch> polymorphic ;-)

[16:13] <audreyt> what, I talk nonsesne?

[16:13] <audreyt> :)

[16:13] <nothingmuch> i'll let you $unit, and stop talking nonesense

[16:13] <nothingmuch> not i'll let you $unit

[16:13] <nothingmuch> where 4unit == ( $subunit, and stop talking nonesnese )

[16:13] <nothingmuch> ;-)

[16:14] <nothingmuch> if that was the case, i'd i wouldn't use "and stop", because that's bad english

[16:14] <audreyt> well it makes a lot of non nonsense

[16:14] * nothingmuch is having coders block

[16:14] <audreyt> which represents a thunk of sense

[16:14] <nothingmuch> hence undecisiveness

[16:14] <audreyt> (cf. Haskell is Not Not ML)

[16:15] *** stef_ joined
[16:15] <audreyt> oh. then write some more component tests

[16:15] <audreyt> I hear that's good for you

[16:15] <nothingmuch> i've been doing Crypt::Util when my brain would freeze

[16:15] <audreyt> gravedigging module?

[16:15] <nothingmuch> =)

[16:15] *** stef_ joined
[16:16] <audreyt> "This module provides an easy, intuitive and forgiving API for wielding crypto-fu."

[16:16] <nothingmuch> use Shovel; open my $fh, $crypt; while( my $goodies = <$fh> ) { } =)

[16:16] <audreyt> :D

[16:16] <audreyt> cool, that part of PlRPC I liked

[16:16] <audreyt> so abstracting it out into a ::Util makes sense

[16:16] <nothingmuch> oi! i didn't know

[16:17] <nothingmuch> i'll go through PlRPC and extract goodies

[16:17] <eviltwin_b> "suggested"?

[16:17] <eviltwin_b> S06

[16:17] <nothingmuch> huh?

[16:17] <audreyt> Obviously you still haven't quite memorized all the synopses (of all CPAN modules)... :-)

[16:17] <nothingmuch> that was perl 5

[16:17] <audreyt> eviltwin_b: "suggested to implement"

[16:17] <nothingmuch> wait wait wait

[16:17] <nothingmuch> oh, i thought that was you

[16:17] <eviltwin_b> ah, was not clear that it wasn't implemented yet

[16:17] <nothingmuch> my nickcoloring script died, sorry =(

[16:18] <audreyt> eviltwin_b: I forgot to implement it during the releng frenzy is all

[16:18] <eviltwin_b> ah

[16:19] <audreyt> because it's not tested!

[16:19] <audreyt> (or was it)

[16:19] *** andres__ joined
[16:20] <audreyt> eviltwin_b: can you add the relevant tests to t/data_types/capture.t ?

[16:20] <audreyt> in additon to &foo.call($c) it should also test foo(|$c)

[16:20] <eviltwin_b> not at the moment

[16:20] <audreyt> someone else then? :)

[16:20] <audreyt> I'll nap for real...

[16:21] *** ferreira joined
[16:21] <eviltwin_b> I have a nonfunctional setup at the moment, found out last night my dports is thoroughly horked so I'm doing a full reinstall

[16:21] <eviltwin_b> hence most stuff (including svn and dependencies) is currently nonfnctioning

[16:21] <audreyt> eviltwin_b: mail juerd at convolution.nl with your real name and preferred login name

[16:22] <audreyt> to get a feather.perl6.nl / perlcabal.org account

[16:22] <audreyt> which is handy for things like webirc and pugshacking

[16:23] <audreyt> afk... &

[16:24] *** Limbic_Region joined
[16:26] *** lisppaste3 joined
[16:40] *** DHGE joined
[16:47] *** prism joined
[16:47] *** TimToady joined
[16:54] *** weinig|bbl is now known as weinig

[16:56] *** bernhard joined
[16:56] *** justatheory joined
[17:07] <nothingmuch> @seen cmarcelo

[17:07] <lambdabot> I saw cmarcelo leaving #perl6 3d 12h 20m 38s ago, and .

[17:08] *** thepler joined
[17:08] *** chris2 joined
[17:18] *** penk joined
[17:20] *** offby1 joined
[17:21] *** aufrank joined
[17:21] <offby1> here's a dumb question: what's the perl6 equivalent of the Camel Book?

[17:21] <offby1> I.e., the one place I can go to find out how to actually write perl6 code?

[17:21] <nothingmuch> the synopses are the closest thing we have

[17:21] <offby1> *sigh*

[17:21] <offby1> well, maybe that's not as bad as I'd thought.

[17:22] <nothingmuch> there's also a plethora of tutorials

[17:22] <offby1> they are kept up to date with pugs, yes?

[17:22] <nothingmuch> it's more the other way around

[17:22] <offby1> see, I don't want a plethora, because then I have to decide which to pick.

[17:22] <nothingmuch> pugs tries to keep up to date with them

[17:22] <offby1> I want just one canonical authoritative site.

[17:22] <nothingmuch> right, that's why i assumed you'd prefer the synopses =)

[17:22] <offby1> OK, I'll see if my pugs checkout includes them

[17:23] <nothingmuch> it doesn't

[17:23] <nothingmuch> http://dev.perl.org/perl6/doc/synopsis.html

[17:23] <lambdabot> Title: Synopses - perl6

[17:23] <offby1> oh :-|

[17:23] <offby1> thanks

[17:23] <nothingmuch> also in svn.perl.org

[17:23] <nothingmuch> and Perl6::Bible

[17:24] <offby1> to be honest, I can never remember if it's the Synopses, Apolocyptamundo, or the Ex-Weegeeans that I want to consult.

[17:24] <aufrank> I thought pugs/docs/Perl6/Spec/ was equivalent to the syns these days

[17:24] <nothingmuch> oh

[17:24] * offby1 isn't the only one confused, apparently

[17:24] * nothingmuch didn't know

[17:24] <nothingmuch> perhaps /me is out of date

[17:24] <nothingmuch> spec.pugscode.org is a good way to see how pugs <-> syns interact

[17:25] <nothingmuch> that said, synopsis describe and specify perl 6

[17:25] <nothingmuch> apocalypses are earlier (so now out of date)

[17:25] <nothingmuch> and explain more of the why behind some things, or what some things should be

[17:25] <nothingmuch> and plural(exegesis) were supposed to help explain apocalypses using a practical code sample

[17:26] <aufrank> exegeses

[17:26] <nothingmuch> ta =)

[17:27] *** nelhage joined
[17:28] <offby1> thanks

[17:28] <offby1> Not much; you? :-)

[17:29] <nothingmuch> ta =)

[17:29] <nothingmuch> bah

[17:29] <nothingmuch> this is not a terminal

[17:29] <offby1> Ici n'est pas un pipe.

[17:30] <offby1> Are the synopses kept under revision control somewhere?  I prefer reading things locall via my editor, than on the web ...

[17:30] <offby1> *whine whine*

[17:32] <nothingmuch> http://svn.perl.org/perl6/doc

[17:32] <lambdabot> Title: Revision 13276: /doc

[17:38] <offby1> thanks!!

[17:39] * offby1 smacks forehead

[17:39] <offby1> I already had a checkout of that.  Yeesh.

[17:39] <nothingmuch> heh

[17:39] <offby1> I bet I asked for the URL here back then, too :-|

[17:39] <offby1> I need to be _forced_ to use Perl6 for a few months, rather than dabbling in it.  That way I'll remember this stuff.

[17:40] *** bonsai joined
[17:43] * offby1 happily reads S02

[17:49] *** mako132_ joined
[17:58] *** Aankhen`` joined
[17:58] *** TimToady joined
[17:59] *** zdeqb joined
[18:01] *** zdeqb left
[18:20] <offby1> OK, my first real question.  I want a hash whose values are anonymous list references.  In Perl5, I'd add a new element to one of those lists by saying push ``@{%dict_hash{$key}}, $value'', but with pugs, I get an error: ``Unexpected "{%" expecting "@" or "::"''.  What's the syntax that I'm looking for?

[18:20] <offby1> actually I guess in Perl5 I'd really say ``push @{$dict_hash{$key}}, $value''

[18:20] <offby1> but you get the idea

[18:21] <wolverian> you don't need to deref explicitly in perl6.

[18:22] <offby1> go on.

[18:22] <wolverian> %hash{$key}.push($value);

[18:22] <offby1> oho!  I'll try that.

[18:23] <offby1> hmm, now I must show you what I'm _actually_ doing, rather than the simplified version :-)

[18:23] <offby1> %dict_hash{&bag($chopped)}.push ($chopped);

[18:23] <offby1> that yields

[18:23] <offby1> Unexpected "($"    expecting comment, operator, statement modifier, ";" or "}"

[18:24] <offby1> so -- I want to call the "bag" function on $chopped, and use that as my hash key ...

[18:24] <wolverian> you can't use whitespace so freely.

[18:24] <offby1> ah

[18:24] <wolverian> otherwise it looks fine, except the & is not required.

[18:24] <offby1> superstition :-)

[18:24] <wolverian> it shouldn't be used in perl5 either.

[18:25] <wolverian> (except when you need it. which is probably never. :)

[18:25] <offby1> fabulous!

[18:25] <offby1> thanks, mr wolverian !

[18:26] <wolverian> you're welcome :)

[18:29] *** cjeris joined
[18:30] <offby1> OK, next: how do I open a file, and tell Perl (or Pugs) "This file is encoded in Latin-1, so please don't whine about "decodeUTF8: bad data '\243'" ??

[18:30] <offby1> I bet it's just an extra arg to "open"

[18:30] <offby1> alas, I can't remember where "open" is documented

[18:32] <eviltwin_b> S16?

[18:32] <offby1> lemme look

[18:33] <offby1> http://dev.perl.org/perl6/doc/synopsis.html doesn't mention an s16

[18:33] <lambdabot> Title: Synopses - perl6

[18:33] <eviltwin_b> hm, it's a draft

[18:33] <offby1> nor do I find one in /usr/local/src/langs/perl6-doc/

[18:33] <eviltwin_b> I'm at http://perlcabal.org/syn/? (the ? is part of the url)

[18:33] <lambdabot> Title: Official Perl 6 Documentation

[18:34] <eviltwin_b> redirected from spec.pugscode.org

[18:34] <offby1> yikes, there really _is_ no one place to find the perl6 equivalent of the Camel Book ... :-(

[18:34] *** Limbic_Region joined
[18:35] <eviltwin_b> I think perl6 is still a bit too young for that

[18:35] <offby1> guess so

[18:35] <eviltwin_b> not to mention pugs vs. parrot vs. other implementations

[18:35] <offby1> well, I'd assume all those implementations would hew to the same spec.

[18:35] <offby1> s/assume/hope/

[18:35] <eviltwin_b> heh

[18:36] <eviltwin_b> perl evolves by mutation, as always, the spec just documents the successful mutations :)

[18:36] <offby1> hmm

[18:36] <wolverian> the idea is, actually, that the implementation adhere to the spec.

[18:36] <offby1> well, S16 didn't answer the question anyway.

[18:37] <wolverian> in any case, I don't think pugs has IO layers yet.

[18:37] <offby1> Any idea how to tell perl that my file is Latin-1 ?

[18:37] <offby1> oh

[18:37] <wolverian> you could always look at the source :)

[18:39] <ingy> seen TimToady

[18:39] <jabbot> ingy: TimToady was seen 1 days 13 hours 7 minutes 49 seconds ago

[18:49] *** aufrank joined
[18:52] *** glasser joined
[18:57] <offby1> so ... Ints and Strings are different types, in that ``3.perl'' and ``"3".perl'' yield different strings ... but it appears that if I use an Int as a hash key, it gets coerced to a string.  Am I understanding correctly?

[18:57] <eviltwin_b> as I understand it, that's the default.  you can declare  hash using general objects (Any) or other types as keys

[18:58] <offby1> aha

[18:58] <offby1> that coercion indeed mimics perl5's behavior.

[18:58] <offby1> (except Perl6 is better because I can use _big_ ints as keys.  yay)

[19:00] <offby1> hm.  How _would_ I write that declaration?  ``my Int %h'' doesn't sound right -- I'd expect that to declare that the _values_ are Ints, not the keys.

[19:01] <wolverian> that's defined in the data structures synopsis

[19:01] <offby1> aha, I'm looking in the wrong place, then.

[19:02] <wolverian> http://perlcabal.org/syn/S09.html#Hashes

[19:02] <lambdabot> Title: S09

[19:03] <offby1> hmm, isn't doing what I'd expect:

[19:03] <offby1> my Any %h{Int}

[19:03] <offby1> %h{3} = "Three"

[19:03] <offby1> %h{"4"} = "Four"

[19:04] <offby1> %h

[19:04] <offby1> (("3", "Three"), ("4", "Four"))

[19:04] <wolverian> pugs doesn't necessarily implement that yet.

[19:04] <offby1> ah

[19:05] <offby1> but it looks like I'm doing the right thing then?  If so I'll just write it that way and ignore that pugs doesn't yet do it.

[19:06] <wolverian> yup

[19:07] <offby1> thanks.

[19:22] <nelhage> "You should write a test" :)

[19:22] <wolverian> that, too. :)

[19:23] <nelhage> OK. I've built and installed pugs from svn; How do I run stuff in the examples/ dir? neither perl examples/foo.pl nor pugs examples/foo.pl is working

[19:24] <offby1> I dunno, but I'll be curious to hear the answer too.

[19:24] <offby1> in the meantime, my next q:

[19:24] <offby1> my $cache_file_name = "dict.cache"

[19:24] <offby1> my $cache = open ($cache_file_name, :w)

[19:24] <offby1> --- That yields

[19:24] <offby1> *** dict.cache w	1: openFile: does not exist (No such file or directory)

[19:25] <offby1> that's puzzling, since I think I'm telling it to create a new file

[19:25] <offby1> pugs/t/builtins/io/open.t seems to imply I'm doing it right...

[19:26] <wolverian> you don't want the whitespace there, anyway.

[19:26] <offby1> *smack*

[19:26] <offby1> gotta figure out how whitespace works

[19:27] <eviltwin_b> GNU style conventions are not valid Pugs (and suck anyway IMO :)

[19:27] <offby1> just habit

[19:27] <wolverian> http://perlcabal.org/syn/S02.html#Whitespace_and_Comments

[19:27] <lambdabot> Title: S02, http://tinyurl.com/y89dt4

[19:27] <offby1> yeah, I read it, but it hasn't sunk in yet

[19:28] <wolverian> the relevant bit here is that whitespace before a postfix operator is invalid (unless escaped)

[19:28] * offby1 stares blankly 

[19:28] <eviltwin_b> look for "long dot"

[19:29] <wolverian> yeah.

[19:29] * nelhage looks for the postfix operator in offby1's code fragment, but fails to find it.

[19:29] <eviltwin_b> <( )>

[19:29] <wolverian> nelhage, ()

[19:29] <eviltwin_b> (that is, the parens are a postfix_circumfix operator

[19:30] <nelhage> hmm, ok. I guess that makes sense

[19:30] <eviltwin_b> a postfix operator which takes an argument in circumfix

[19:30] <nelhage> (*very* new to p6 here)

[19:30] *** MacVince joined
[19:30] * eviltwin_b is still quite new to it as well but is working through the Synopses and seems to be retaining *something* at least

[19:31] <offby1> I think my rule will be: never use any whitespace anywhere :-|

[19:31] <eviltwin_b> that won't help, there are cases where it's mandatory :>

[19:31] <offby1> *smack*

[19:31] <offby1> I think my rule will be: add and delete whitespace at random until it compiles :-|

[19:31] <eviltwin_b> hey, it could be Python...

[19:31] <offby1> anyway.

[19:32] <offby1> so: what's the inverse of "say $foo.perl" -- in other words, what's the perl6 equivalent of "do $filename" ?

[19:33] <wolverian> use a module :)

[19:34] <offby1> huh?

[19:34] <offby1> I don't understand how that answers my question.

[19:34] <offby1> maybe I wasn't clear.

[19:35] <wolverian> generally you want to use Foo; instead of do "foo.pl"

[19:35] <wolverian> so. anyway. good night!

[19:35] <offby1> "say $foo.perl" is a delightfully easy way to get an unparsed string that, when re-parsed by perl, creates a value that is just like $foo.  So it's a handy way to write perl data to files.  Now, if I do this, I am eventually going to want to read that data back, and turn it back into a perl value.  How do I do this second step?

[19:36] <wolverian> eval()

[19:36] <offby1> eval what?

[19:36] <offby1> the string?

[19:36] <offby1> oh, of course.

[19:36] * offby1 tries

[19:37] <eviltwin_b> you want that anyway, really, IMO --- forces you to at least think about validation etc.

[19:37] <offby1> wolverian: seems to work; thanks.

[19:37] <offby1> eviltwin_b: say again?

[19:38] <eviltwin_b> if you just slurp data in with "do" (even in perl5) you're being lazy and potentially very insecure

[19:38] <offby1> because the "data" might contain Evil Code.  Sure.

[19:38] <eviltwin_b> making it harder to do that is therefore a Good Thing IMO

[19:38] <offby1> uh

[19:38] <offby1> not if I already know beforehand that the stuff is safe, it isn't.

[19:39] <offby1> anyway, calling "eval" doesn't seem noticeably safer.

[19:39] * eviltwin_b is a professional paranoid and thinks that "already know beforehand" is a road paved with good intentions

[19:40] <offby1> good point, I'll grant you.

[19:40] <eviltwin_b> it's not, but by breaking it up it should aty least suggest putting checks between the read and the eval

[19:40] <offby1> aaahhh

[19:40] <offby1> gotcha

[19:40] <offby1> although ...

[19:40] <offby1> ugh.

[19:40] <offby1> any such checks would require me to do my _own_ parsing, wouldn't they?

[19:41] <offby1> surely there's a safe, standard way to serialize and unserialize data?  YAML, perhaps?

[19:41] <eviltwin_b> I think there is (or is intended to be) but haven't seen it yet

[19:42] <eviltwin_b> oh, if you're intent on being lazy I get the impression open($file).slurp.eval is supposed to work

[19:42] <offby1> sounds good.

[19:43] <offby1> works indeed.

[19:45] <eviltwin_b> as to parsing, that's not too horrible an idea --- go take a look at grammrs

[19:45] <eviltwin_b> er.  Grammars

[19:46] * eviltwin_b is impressed --- has been noodling that concept for a while

[19:47] <offby1> I refuse to do that sort of parsing.  It's unthinkable that perl6 won't eventually provide a safe way to do this.

[19:48] <eviltwin_b> worse come to worst you could fall back to perl5 YAML :>

[19:50] <eviltwin_b> oh look, S29 mentions an evalfile().  (now if there were an indication of any of these things are actually implemented...)

[19:51] <offby1> I notice that there's already a .yaml method for generating the output, so I wouldn't be surprised if there were a corresponding method for reading it back in

[19:58] <offby1> ooh, look how a file handle stringifies:

[19:58] <offby1> <VHandle ({handle: dict.cache}>

[19:58] <offby1> that's odd

[19:58] <offby1> unbalanced left paren.

[19:58] <offby1> I know that isn't meant to be parsed, but it still looks funny ...

[20:03] <SamB> indeed it does...

[20:03] <SamB> I bet it was a mistake

[20:05] *** MacVince joined
[20:17] <gaal> offby1: also check out .yaml

[20:17] *** ferreira joined
[20:18] <gaal> ?eval { moose => 'elk', 42 => "lala" }.yaml

[20:18] <evalbot_r14483> "--- !hs/IScalar \n- !hs/VUndef VUndef\n"

[20:18] <gaal> ugh.

[20:18] <eviltwin_b> ...or then again,maybe not:>

[20:18] <gaal> ?eval my %x = ( moose => 'elk', 42 => "lala" ); %x.yaml

[20:18] <evalbot_r14483> "--- \n? 42\n: lala\n\n? moose\n: elk\n\n"

[20:19] *** trym joined
[20:19] <gaal> the other direction is eval $str :lang<yaml>

[20:23] <offby1> let's try that.

[20:25] <gaal> ?eval { why => 'did that happen earlier' }.perl

[20:25] <evalbot_r14483> "\\undef"

[20:25] <offby1> cool

[20:25] <gaal> interesting.

[20:25] <gaal> very not cool :(

[20:25] <offby1> I meant "cool" because one can read yaml natively

[20:25] <gaal> weirdly, it's newVal undef.

[20:25] <gaal> yes. it roundtrips objects too :)

[20:25] <nelhage> ?eval my $x = {whats => "up"}; $x.perl

[20:25] <evalbot_r14483> "\{(\"whats\" => \"up\"),}"

[20:26] <gaal> nelhage: yes, I suspect it's parsed as a thunk, which may be correct, but then showing it as an undef is incorrect.

[20:27] <gaal> ?eval { "this is an anonyblock" }.perl

[20:27] <evalbot_r14483> "\\undef"

[20:27] <gaal> yeah.

[20:28] <gaal> should stringify as CODE0xdeadbeef or something.

[20:28] <offby1> indeed

[20:28] <offby1> although a disassembler would be cool too :-)

[20:28] <gaal> "something" being perhaps 'CODE:{ "this is an anonyblock }'

[20:28] <gaal> yeah :)

[20:29] <gaal> newVal will make this not-so-difficult

[20:30] <gaal> though I need for audreyt to jiggle my memory about how we capture original layout/comments etc. now that newAST doesn't have annotations

[20:32] <offby1> *gasp*

[20:32] <offby1> there's actually a plan for saving comments and so on in parsed code?

[20:32] <gaal> of course. how else would we do refactoring IDEs? :)

[20:32] <offby1> ga-roovy

[20:33] <nelhage> gaal: by abusing horrible hacks, of course.

[20:33] <offby1> sure

[20:33] <offby1> that technique was good enough for my granddaddy

[20:34] <gaal> nelhage: you mean writing a Z80A backend to pugs, writing the optimizing refactoring engine + AI that infers the comments that went with it on the output, and prettyprinting the result back to Perl 6?

[20:34] <gaal> ok, I'd like to see that

[20:35] <nelhage> Huh. That would be pretty awesome.

[20:35] <nelhage> I was thinking more along the lines of jesse's http://fsck.com/~jesse/extract

[20:36] <nelhage> (Warning: this code has been known to traumatize small children)

[20:40] <gaal> that's... intereting

[20:41] *** jferrero joined
[21:02] *** scsibug joined
[21:07] *** putter joined
[21:08] <putter> openfoundry down?

[21:11] <putter> ah well.  bbl &

[21:19] *** mauke joined
[21:31] <eviltwin_b> hm, I'm having sporadic network problems in general

[21:34] <nothingmuch> night

[21:43] *** ferreira left
[21:45] *** shobadobs joined
[21:52] <obra> gaal: it _works_

[21:53] <obra> it's scary, but works

[21:56] *** larsen_ joined
[21:58] <audreyt> openfoundry worksforme

[21:59] <clkao> audreyt: what was the moving to commitbit plan?

[22:03] *** [particle] joined
[22:12] *** putter joined
[22:12] <putter> re openfoundry, /  svn: REPORT request failed on '/pugs/!svn/vcc/default'  /  svn: REPORT of '/pugs/!svn/vcc/default': Could not read status line: connection was closed by server. (http://svn.openfoundry.org)

[22:13] <eviltwin_b> 502 Proxy error

[22:13] <eviltwin_b> cute

[22:15] *** weinig is now known as weinig|bbl

[22:20] <Patterner> for interesting values of cute

[22:20] <offby1> I got that too, and hour or two ago

[22:20] <offby1> s/and/an/

[22:20] <audreyt> just for commits?

[22:21] <audreyt> pulling seems to be fine

[22:21] <audreyt> working now to get us a new svnhost.

[22:21] <Patterner> "svn up" fails

[22:22] <eviltwin_b> s/interesting/ironic/ :)

[22:23] <offby1> works OK nwo.

[22:23] <offby1> now.

[22:24] <audreyt> read worksforme and write is borked.

[22:24] <audreyt> hopefully will get a new .perl.org host for pugs soon

[22:24] <audreyt> (I don't have openfoundry shell anymore so can't fix it at the moment :/)

[22:24] * offby1 idly wonders if Google could be talked into hosting it

[22:25] <audreyt> there's already a google pugs host.

[22:25] <offby1> there you go, then!  problem solved :-)

[22:25] <audreyt> they lifted quota limit for us

[22:25] <audreyt> well, problem is all committers need to get gmail accounts...

[22:25] <audreyt> and @perl.org with commitbit support doesn't have that restriction

[22:26] <audreyt> but yes, googlecode will be our rw fallback

[22:26] <offby1> audreyt: I must say, your work on pugs leaves me in awe.  It's the only free software project that I am genuinely excited about, _and_ believe has a prayer of actually being completed.

[22:26] <audreyt> but @perl.org should be main

[22:26] <Patterner> I think i have 100 invites to gmail left :)

[22:26] <audreyt> Patterner: yeah but the good nicknames have run out

[22:26] <clkao> audreyt: luckily there's openid support planned

[22:26] <audreyt> e.g. I had to be audreyt.org instead of audreyt

[22:26] <audreyt> and I'd like to maintain some sort of continuity in nicknames

[22:26] * offby1 nods

[22:27] * offby1 hates it when he finds he's not the first "offby1" in some namespace :-|

[22:27] <Patterner> you don't like [email@hidden.address]
[22:27] <eviltwin_b> suid audrey? :)

[22:28] <clkao>    

[22:32] * SamB has "naesten", should have grabbed SamB if it was still there though...

[22:32] * offby1 bellows belligerently: there's only room enough in this community for _one_ "offby1"!

[22:34] <audreyt> offby1: re genuine excitement, I'm very very happy to hear that :)

[22:35] <offby1> I imagine I'm one of many, but

[22:35] <audreyt> re completed, sure it will :)

[22:35] <audreyt> but we first need to fix the most nonfun part, which is a nonfunctional svn master... working on it now

[22:35] <audreyt> (fortunately clkao has a completely nointerrupted-by-skip svk mirror of the repo)

[22:35] <audreyt> clkao: can you do the svndumpfilter into huge file now?

[22:36] <clkao> sure

[22:36] <offby1> audreyt: if I donate to the Perl Foundation, does that support y'all?

[22:37] <clkao> i think buying her shiny cloth

[22:37] <clkao>  

[22:37] <clkao> cloths would help ;)

[22:38] <audreyt> offby1: donating money for keeping the new pugsmachine running would be nice

[22:38] * offby1 investigates

[22:39] <offby1> I'm far too lazy to contribute code, but money I can handle.

[22:40] <audreyt> clkao: I've got a large enough deposit on Issey retailers that will buy me another year's clothes or so...

[22:40] <offby1> hmm, the dropdown only lists "Perl Development Fund", and three other less-likely-looking things

[22:40] <audreyt> obra: which fund would this be?

[22:41] <obra> i don't know for sure. offby1: for large donations, all kinds of magic can happen.

[22:41] <obra> but I know that's hard to pull off sometimes.

[22:41] <offby1> obra: ain't gonna be large, unless your idea of "large" is much smaller than mine :-)

[22:41] <obra> understood

[22:41] <obra> I've been trying to get pugs-donation stuff streamined. but i'm not tied in enough.

[22:43] <offby1> ka-ching

[22:43] <offby1> well, the perl foundation donation stuff was easy enough to do that I've just done it.

[22:43] <offby1> hope they throw it at y'all.

[22:44] <audreyt> eventually, indirectly, some of them will...

[22:46] <offby1> sounds like getting your paycheck after tax and social security has been deducted ... :-(

[22:48] <SamB> maybe canned food?

[22:48] *** SubStack joined
[22:55] <audreyt> mmm spam

[22:56] * Limbic_Region raises his hands above his head in triumph

[22:56] <Limbic_Region> NP complete -> O(1) in < 8 hours

[22:56] <offby1> ?

[22:57] <audreyt> Limbic_Region: yay!

[22:58] <Limbic_Region> of course, uploading the db so I can show it off it going to take > 10 hours

[22:58] <Limbic_Region> (slow upload)--

[23:00] *** trym joined
[23:03] *** Aankhen`` joined
[23:05] *** jferrero is now known as JoaquinFerrero

[23:13] *** bsb joined
[23:19] *** root4o joined
[23:20] *** jferrero joined
[23:20] *** jferrero is now known as JoaquinFerrero

[23:29] <putter> svn up, svn ci still down.

[23:30] *** fridim left
[23:30] <putter> are there "using svk with pugs" instructions somewhere?

[23:31] <putter> (switching to svk is nominally on putter's todo list for this next week)

[23:31] *** offby1 left
[23:31] <putter> but for now, have fun all. &

[23:37] *** SubStack joined
[23:39] *** diakopter joined
[23:44] *** [particle] joined
[23:51] *** diakopter left
