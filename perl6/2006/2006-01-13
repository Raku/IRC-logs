[00:13] *** putter joined
[00:13] <putter> ping?  anyone about?

[00:14] *** cdpruden joined
[00:15] * scrottie raises an eyebrow

[00:20] <putter> :)   If we define both multi f(Num $n){$n+1} and multi f(Num $n){$n+2} in the same file, f(10) will call the first one defined.  But if they are defined in separate files and use()ed, the same one gets picked regardless of use() order.  I'd very much like a way to get the order-dependence with separate files.  Thoughts?

[00:21] <rent> is now known as _brentp

[00:23] <putter> Basically, between S29, PIL2JS, PILn etal, Prelude.pm, Prim.hs, and some PILRun, we have most of the pieces to create a unified p6 defined mostly in p6, with backend specific bits.

[00:23] <putter> But to pull it together, one needs to be able to override multis.

[00:23] <scrottie> Subclass?

[00:24] <scrottie> Interesting. I should have you tell me about S29, PIL2JS, PILn etal, Preclude.pm, Prim.hs, and PILRun.

[00:26] <putter> good thought, but since the objective is to make, say, Array::splice be something specific, the best we could do with subclasses is to have an "upside-down" tree of implementation choices above Array, and then use a single point macro switch to choose between say ArrayOnJS and ArrayOnHs.

[00:28] <scrottie> I haven't been following Pugs. Guess I should go back and read the blog, so "RTFM" is a valid reply. Granting that, what's PILRun?

[00:28] <putter> or even just  JS.pm:  macro Array () { "ArrayOnJS" }  .  hmm... there's something to be said for that... but one really wants selective import with renaming...

[00:30] <scrottie> I personally like to live by the rule that if two things should be interchangable, they should present the same interface and inherit from the same abstract root class.

[00:31] <scrottie> If you can take shortcuts to achieve that, great. Otherwise, do it the long way. What might start as a lot of reptition gives flexibility in the future as the implemenations diverge.

[00:34] <putter> S29 is docs/AES/S29draft.pod which has signatures and some code.  PIL2JS is the JavaScript backend, which has perl5/PIL2JS/lib6/Prelude/JS/ , PILn is src/PIL/Native/Bootstrap/ and some of the other stuff stevan and audreyt have been doing, PILRun is the currently inactive P5 backend, for which

[00:34] <putter> I have some p6 code which got posted and discussed, but I don't think ever got checked in.

[00:36] * scrottie nods

[00:36] <scrottie> thank you. intersting.

[00:42] <putter> You know, a class/role-based system might just work.  On say the JS backend, Foo is FooOnJS (eg, Array is ArrayOnJS).  ArrayOnJS is ArrayGeneric, ArrayJSMods;  With roles, the role body would need a bunch of method stubs pointing to Mods, as roles are less tolerant of conflicts than classes.  But that should be fine...

[00:46] <putter> The rationale for ArrayOnJS, rather than simply calling it Array on the JS backend, is... hmm... the thought was it would be more easy to do mutant implementations, eg, JS backend prime, Array is ArrayOnJSprime; ArrayOnJSprime is ArrayOnJS { prime mods... }.  This argument is weakened by having a good mop, but...

[00:50] *** cdpruden joined
[00:50] <putter> But no, one would just want a set of rules, sucked in to classes.  Unfortunately, to have use a role with method m_variant1 and m_variant2, and the class says  multi m() { m_variant2() }, you would also need a companion "blocker" role, with stubs for m_variant1/2, for the sole purpose of

[00:51] <putter> creating a conflict so m_variant1/2 are _not_ inherited into the class.  I don't think we currently have a mechanism of otherwise blocking inheritance.  Do able, but a bit ugly.

[00:52] *** daja77_ joined
[00:53] <scrottie> It's fine to create subclasses that implement operations as a no-op. It doesn't hold up to OO modeling to willy nilly add or remove methods (unless you get the P6/SmallTalk behavior of black-holing unknown methods without raising an error). 

[00:54] <putter> And it doesnt work so well when you want to touch multiple classes with a single decision.  Eg,  role do_things_way_1 { class A { m_variant1 } class B { m_variant1 } }    It would be *really* nice to have a set algebra over methods, but we currently dont...

[00:58] <scrottie> Planning implementation is NP-complete. Do it badly then improve the implementation steadily. Refactor. Get to work.

[00:59] <putter> re no-op, the challenge is one wants to select and merge sets of methods across multiple classes.   currently it seems one can't do that (?).  if overriding stayed order dependent in use(), then packages/modules could be used as the "sets".   The algebra would be a bit weak, but I think we could live with

[01:00] *** scook0 joined
[01:01] <putter> that, at least for now.  Oh, not so weak if use() permitted selective import().

[01:02] <putter> so   use ArrayGeneric;  use ArrayOnJS :limited-memory-version;  use ArrayRandomTweaks;

[01:02] <putter> each one overriding some of the methods defined by the previous.

[01:04] <putter> oh, better  use ContainersGeneric; use ContainersOnJS :limited-memory; use ContainerTweaks13;

[01:04] <scrottie> Eh? Select and merge sets of methods? That's an inheritance tree. If you have two JavaScript backends, put the common logic in one class, then subclass it twice, each subclass containing the specifics of the particular JavaScript backend.

[01:04] <putter> while one might manage the Array version with subclassing, the container version would seem to require mondo hoop jumpage.

[01:05] <scrottie> putter: here's a really good book you might enjoy: _Object Oriented Design Heuristics_

[01:05] <stevan> putter: I am having trouble following what you mean

[01:06] <stevan> do you want to have a p6 Array, which can have multiple "backends"?

[01:06] <stevan> one for JS, for p5, etc etc etc

[01:06] * putter peers blearily at the screen, trying to marshal thoughts...  brain.yaml |> grep...

[01:06] <stevan> Array should be a role

[01:06] <stevan> which will define the implementation as completely as possible

[01:06] <stevan> if need be in a circular way

[01:07] <stevan> then the runtime will implement the ^Array class and install it into the global scope/package 

[01:07] <stevan> but 9/10th off what is Array can be defined in the Array role

[01:08] <stevan> every runtime will end up having a slightly tweaked version of the post Metamodel bootstrap

[01:08] <stevan> to address each models particular issues/concerns

[01:09] <stevan> however, we /might/ be able to put all this into PIL^N, in which case this is all a moot point since the runtime will only need to implement PIL^N and everything else Just Works

[01:09] <stevan> thats the whole point behind using the DSL, is that it increases portability by decreasing the amount of duplicated code needed

[01:10] <putter> ok.  so role rArray does rArrayGeneric, rArrayOnJS, rArrayTweaks {};  rArrayGeneric defines most everything, so most everything in the other roles generate conflicts, which have to be explicity resolved in rArray.  I suppose a macro could help.  So...

[01:10] <stevan> this was the leason learned from yours and flgocks effort with PILRun and iblech's PILJS

[01:11] <stevan> no

[01:11] <stevan> putter: role Array {}

[01:11] <stevan> it does nothing

[01:11] <stevan> (maybe List, but I am not sure)

[01:11] <putter> re piln, hmm...

[01:11] *** oylenshpeegul joined
[01:11] <stevan> in the JS runtime, the missing bits of the Array role are implemented in the Array class itself

[01:12] <theorbtwo> DSL?

[01:12] <stevan> but again, ideally this all lives in PIL^N and JS runtime need never know about it cause the JS implements PIL^N

[01:12] <theorbtwo> We need a dictionary, or a bot.

[01:12] <stevan> Domain Specific Language :)

[01:13] <stevan> putter: my guess is that Array can be completely defined in PIL^N

[01:13] <stevan> maybe not as efficiently as we would like

[01:14] <putter> re "does nothing", huh?   role rAx { multi pop{...defined assuming splice...} multi splice {...defined assuming pop...}, role rAJS { multi splice {...defined using inline_js...} }.   How do rArray and Array get defined?

[01:14] <stevan> but then the next step would be to move the implementation down to the PIL^N runtime

[01:14] <stevan> putter: in the bootstrap

[01:14] <stevan> lets take a simpler example

[01:16] <stevan> role Eq { method infix:<==> (Eq $left, Eq $right) { !($left != $right) } method infix:<!=> (Eq $left, Eq $right) { !($left == $right) } }

[01:16] <stevan> so == is obviously the inverse of != and vice versa

[01:16] <putter> I don't by "Array can be completely defined in PIL^N".  I'm using Array as a strawman proxy for the entire Prelude.  So that sentence becomes "the entire Prelude could be completely defined in PIL'N".  so... yes, but that would be nuts. ;)

[01:16] <stevan> this is a complete role, albeit one you should never "just use" since it will loop infinitly

[01:17] <stevan> putter: why can't Array be done in PIL^N? have you looked at the code ?

[01:17] <stevan> it is about 60-70% complete, although it currently is waiting on some p6l information

[01:18] <stevan> putter:  my point is that with a circular prelude, you need only fill in the peices needed to prevent the infinite meta-circular spiral of death 

[01:18] <putter> yes, but take a look at perl5/PIL2JS/lib6/Prelude/JS/Array.pm... do you really want to write all of that by hand in PIL'N?

[01:19] <stevan> putter: have you looked at the PIL^N version of Arrary?

[01:19] <putter> yes

[01:19] <putter> err, src/PIL/Native/Bootstrap/Container/Array.pil, yes?

[01:19] <stevan> yes

[01:20] <stevan> ok, so a good portion of Array is implemented, but not all

[01:20] * putter wonders if we are having a "violent agreement"

[01:20] <stevan> so in the Perl 6 prelude, you do this:

[01:20] <stevan> ^Array.meta.add_method('missing-method', method { ... });

[01:20] <stevan> and fill in the parts we are missing

[01:21] <stevan> putter: we may be,... however we are speaking different languages/dialects so hard to tell :)

[01:22] <putter> I agree the objective is a "circular prelude", though that term doesnt quite capture it.  The question is how to manage the mixin-ing.  If method overriding under use() was order sensitive, I'd be all set, and already writing it, sucking bits in from the previously mentioned sources.  It wouldnt be ideal, but it would be fine for now.

[01:23] <stevan> putter: thinks less of multis, and more about classes/roles

[01:23] <putter> But it isnt order sensitive, so I dont know how to cleanly manage the assembly of conflicting sets of bits into a Prelude-de-jure.

[01:24] <theorbtwo> ...by making it order-sensitive?

[01:24] <putter> :) yeah...

[01:24] <stevan> putter: the old prelude was a collection of multi subs, which would have this problem

[01:24] <stevan> it you move many of those "built-ins" into classes and roles, the problem becomes much smaller if not elimnated entierly

[01:26] <stevan> putter: also understand that with the MOP, we don't have to "finish" the class, it is not a one-shot-all-or-nothing thing

[01:26] <putter> how eliminated?  conflicts in roles have to be explicitly resolved.  thus the "role rAx { multi pop{...defined assuming splice...} multi splice {...defined assuming pop...}, role rAJS { multi splice {...defined using inline_js...} }." example.  Perhaps I dont understand your response of "no does, instead done by bootstrap"

[01:26] <stevan> it can be built incrementally 

[01:27] <stevan> where is this rAJS coming from?

[01:27] <putter> They are both part of the great P6 on everything common code base.

[01:28] <stevan> there should be no AJS, it should be either written in PIL^N or Perl6

[01:28] <stevan> the JS runtime will just run the compiled PIL^N

[01:29] <stevan> Perl6 compiles to PIL2, then PIL2 is compiled to PIL^N, then PIL^N is run on the VM

[01:29] <stevan> (or possibly PIL^N is compiled to PIR and run on Parrot)

[01:30] <stevan> of if someone writes the equivelent of all the PIL^N code in PIR, then PIL2 can be compiled to PIR directly

[01:30] <stevan> role Array { method pop { ... slice ... } method slice { ... pop ... }} can be defined in PIL^N

[01:31] <stevan> or Perl 6

[01:31] <stevan> then create the Array class in PIL^N, and then tie the knot (implement pop or slice)

[01:31] <putter> the "only p6 or piln", ok, I don't currently buy that, so let me figure out why...

[01:32] * stevan writes a larger example,.. it is hard to communicate these ideas over IRC

[01:35] <putter> basically you're saying the p6 would should be allowed to talk directly to the backend.  anything they might ever want to talk about should be pushed into piln.  That seems a recipe for a bloated piln... and unlikely to work.  no?

[01:35] <putter> s//not be allowed/

[01:36] <stevan> putter: why does that bloat PILN?

[01:38] <theorbtwo> The idea is that PIL^N is an unbloating filter.  P6 is a big scary langauage.  PIL^N should be a small simple language, easy to write an interpreter for or a compiler from.

[01:38] <stevan> theorbtwo: exactly

[01:38] <theorbtwo> Now, from the sample of pil^n I've seen I rather wonder if that's the case, but that's another question.

[01:40] <putter> How about this... on backend 1, you want to use technique 1, on backend 2, tech 2.  say preextending arrays is essential on 1, but contraindicated on 2.  how do you deal?

[01:41] <putter> no inline_foo vs piln issue.  but you want above-piln p6 algo 1 on backend 1, and 2 on 2.

[01:41] <stevan> putter: I dont understand

[01:42] <stevan> this is a problem for the PIL^N interpreter

[01:42] <pasteling> "stevan" at 67.186.136.119 pasted "PIL^N & Perl 6" (30 lines, 814B) at http://sial.org/pbot/15402

[01:42] <putter> one possible argument is 1-that's very unlikely, so 2-use mop if/when it comes up.

[01:42] <stevan> putter please look at this paste

[01:43] <putter> looking...

[01:43] <stevan> the role defintion is circular  since &wave_hands uses pop :)

[01:43] <stevan> the Array class then does the role Array

[01:43] <stevan> and defines the bit to break the cycle

[01:44] <stevan> it defines it using the PIL^N method `splice()

[01:44] <stevan> cycle broken

[01:44] <stevan> if it is faster in your PIL^N runtime to implement `pop than `splice

[01:44] <stevan> then do that and break the cycle there

[01:44] <stevan> then in Perl 6, we can add other methods as we like

[01:45] <stevan> make sense?

[01:45] <putter> can one do   if $variant == 1 { ...add_method... } else { ...add_method... } ?

[01:45] <stevan> why?

[01:45] <stevan> in which language?

[01:45] <putter> the language of your paste

[01:46] <stevan> there are two languages there,.. PIL^N and Perl 6

[01:46] <putter> either

[01:46] <stevan> why?

[01:46] <stevan> where is the win?

[01:46] <putter> lol

[01:46] <stevan> what defines $variant

[01:47] <stevan> I understand the idea of a better algo in runtimeA so better to implement &pop there,..

[01:47] <stevan> but why should that be in the same file for runtimeB where it is faster to implement &splice

[01:47] *** jroc joined
[01:48] <stevan> each runtime might need a runtime specific bootstrap file

[01:48] <stevan> which does this kind of stuff

[01:48] *** luqui joined
[01:48] <stevan> but it makes no sense to mix that all in one,.. you will very quickly get a lot of spaghetti

[01:48] <putter> hmm... maybe this is the conceptual divergence:  if everything was a simple cycle, and one just needed to define a little tidbit to break the cycle, then things would be simple.  if the "simple cycle" model is too simple, and one really needs more general mixins, then... one needs richer control over how methods get defined.

[01:48] <stevan> putter: everything in that paste can be spread out over multiple files if you want

[01:49] <luqui> paste?

[01:49] <stevan> http://sial.org/pbot/paste

[01:49] <putter> is there a .replace_method  to go with the .add_method?

[01:49] <luqui> no, I mean the one you are talking about

[01:49] <putter> or .remove_method?

[01:49] <stevan> putter: no, just add_method again

[01:49] <stevan> yes

[01:50] <stevan> remove_method exists

[01:50] <stevan> luqui: sorry http://sial.org/pbot/15402

[01:50] <putter> ok, that will do it.

[01:50] <stevan> luqui: we are discussing the circular prelude idea

[01:50] <stevan> putter: is that all you needed :)

[01:50] <luqui> ahh...

[01:51] <putter> wish there was a way to just write it in p6 multi f(Num $x) :replace { $x + 13 }.  but maybe the mop cruft can be macro'ed away.

[01:51] <stevan> luqui: note that wave_hands uses pop,.. so it is cicular,.. I should have put that in the paste

[01:51] <luqui> okay

[01:51] <stevan> putter: the multi approach gets really messy after a while

[01:52] <stevan> better to organize into classes and roles first,..anda bare multis as a last resort

[01:52] <luqui> Haskell does this with typeclasses

[01:52] <theorbtwo> I'm worried by how complex pil^n seems to be.

[01:52] <luqui> many times the methods in the class are defined in terms of each other

[01:52] <stevan> luqui: exactly,.. 

[01:52] <luqui> I've been caught off guard by that sometimes; it would be nice if it would tell me that there's still a circular definition

[01:52] <stevan> theorbtwo: why do you think PILN is complex?

[01:52] <stevan> luqui: yes, that can be tricky I think

[01:53] <luqui> it's undecidable in general :-(

[01:53] <luqui> you'd have to have some way to declare it

[01:54] <theorbtwo> http://svn.openfoundry.org/pugs/src/PIL/Native/Bootstrap/Container/Array.pil does not make it look like a terribly simple language.

[01:54] <theorbtwo> I was expecting something closer to an assembley language.

[01:54] <luqui> theorbtwo, it's very close to lambda calculus, not assembly

[01:54] <putter> so basically what using the mop buys you is that when you use() two files, the expressions in the first file are run before the second, whereas the multi definitions in the second (or the first) may preempt the other, independently of use() order.

[01:55] <putter> what a zoo.

[01:55] <stevan> theorbtwo: it is a very simple language,. thats why things look so complex :)

[01:56] <stevan> putter: there is no need to bring use() into this

[01:56] <stevan> it is not relevant in this case

[01:56] <stevan> the MOP has nothing to do with the order of files loaded either

[01:56] <theorbtwo> stevan: How do you put together the generic prelude with the specific bits for your runtime, then?

[01:57] <stevan> theorbtwo: right now we have #include in PIL^N, its nothing fancy, but it works

[01:57] <stevan> putter:  you need to get away from the multi defintion thing I think

[01:58] <putter> the concrete motivation for this discussion is that a good task for this evening is to pour PIL2JS's and S29's and Prelude.pm, and other's p6 "Prelude" code into one big pile, grouped by pure-p6, p6-on-js-specific, etc.  further partitioned by say different strategies for structuring the pure-p6.

[01:58] <putter> and then use magic mixin method foo to pull backends, or at least their preludes, out of it.

[01:59] <stevan> putter: the old PIL runtimes were hampered by the old PIL design, I saw you frustrated by it many times 

[02:00] <stevan> I think some of that code is useful, but I am not sure all of it will be

[02:00] <luqui> putter, see my recent blog on use.perl.  It is not unrelated...

[02:00] <stevan> but you are welcome to figure this out,.. I dont want to stop you on this

[02:00] <stevan> it will be useful i think

[02:00] <putter> stevan points out "with piln, from the prelude's stand point, there is only one backend - the piln vm".  I wonder if one will still need a way for p6 and underlying backend to chat, and more generally, whether a one-size fits all p6 prelude will actually fly.  will one need per-underlying-backend prelude mods.

[02:01] <stevan> putter: if perl 6 has a need to talk to the backend,.. the PILN/PIL2 design is broken

[02:01] <putter> if so, will need some mod mixin mechanism.  how much it gets used in part determines how (in)convenient we can get away with it being.

[02:01] <luqui> stevan, it will for optimization purposes at least

[02:01] * putter resyncs with stream, backlogging...

[02:02] <luqui> it's a good idea to allow communication between different modules

[02:02] <stevan> luqui: well that is the compiler problem (theoretically of course)

[02:02] <luqui> even when they're supposed to be independent

[02:02] <luqui> yep, theoretically

[02:02] <stevan> remember,.. the plan is to first compile Perl 6 to PIL2

[02:02] <luqui> oh, before I go further, what is pil^n's role?

[02:03] <stevan> at which point there is no more perl 6,.. only PIL2

[02:03] <stevan> then PIL2 gets compiled to PIL^N, at which point there is no more PIL2, only PIL^N

[02:03] <stevan> then the VM runs the PIL^N

[02:03] <stevan> clean seperation

[02:03] <luqui> ahh right

[02:03] <stevan> ideal world,.. sure it is

[02:03] <luqui> misunderstanding things

[02:03] <putter> p6->pil2->piln.  piln is a vm.

[02:03] <stevan> but this is all for -Ofun

[02:03] <luqui> what is the difference between PIL2 and PIL^n?

[02:04] <stevan> PIL^N is the language of the VM

[02:04] <luqui> putter, pil^n is still a repr language

[02:04] <luqui> you could have multiple different VMs that all run pil^n

[02:04] <stevan> luqui: PIL2 has all the stuff Perl 6 needs that PIL^N does not provide ;)

[02:04] <luqui> stevan, i.e. nothing

[02:04] <luqui> pil^n is lambda calculus, which is turing complete

[02:04] <putter> pil2 is desugared p6.  the "p6" compiler proper then chews on the pil2, emitting piln.  i believe.

[02:04] <luqui> as a repr language, it suffices for anything

[02:05] *** revdiablo joined
[02:05] <stevan> luqui: I really dunno,.. I havent seen PIL2 yet 

[02:05] <luqui> putter, okay, that seems to work for me

[02:05] <luqui> it's just another intermediate language to make things easier

[02:05] <stevan> luqui: also PIL^N can be compiled down further

[02:06] <putter> i wasnt around when the pil2/piln distinction came into existence, so I'm not entirely clear on motivation.  one posiblity is that pil2 looks to be more flexibly tied to "what the compiler feels like dealing with today", whereas piln will get less flexible as n vm implementations get created.

[02:07] <stevan> putter: you need to talk to audreyt for details on PIL2

[02:07] <stevan> past what I have already said that is

[02:07] <luqui> To me it seems like:  perl6 -> pil2 -> piln.  pil2 is there to make the arrows simple

[02:07] <luqui> because a perl6 -> piln transformer would be complicated

[02:07] <stevan> PIL^N should be complete at this point

[02:08] <stevan> luqui: exactly

[02:08] <luqui> so suppose that I'm feeling crazy and hubristic and want to write a C backend to PIL^n

[02:08] <luqui> where would I start?

[02:09] <stevan> the Haskell source ;)

[02:09] <luqui> for example, where is the AST stored?

[02:09] <stevan> luqui: what does <: mean in your use.perl post?

[02:09] <luqui> subtype

[02:09] <stevan> luqui: it is all in src/PIL/Native/*

[02:09] <luqui> Dog <: Animal

[02:10] <stevan> although the Repr types for the new objects are in PIL/Repr/* but we are not using those pending a response on p6l

[02:11] <luqui> and what would you use instead?

[02:11] * luqui saw the p6l message, and wasn't quite sure how to respond

[02:12] <luqui> or even what kind of answer you would be looking for

[02:12] <stevan> luqui: what is the $repr argument to CREATE for?

[02:12] <stevan> that is the crux of the question

[02:12] <luqui> oh, about the use.perl post, most of the details were not related to the above discussion

[02:12] <luqui> just the "composable modules" bit

[02:12] <stevan> is it for alternate implementation of an opaque type, all which do the same thing

[02:13] <luqui> I expect that most of that is up to you guys

[02:13] <luqui> er, us guys

[02:13] <stevan> luqui: and gals :P

[02:14] <luqui> I'm using the default masculine

[02:14] <putter> stevan: so, just to cross-check my understanding. your model is there are conceptually just two files, Prelude.piln, and Prelude.p6, plus a couple of piln-vm-on-platform-x backends, and that's what p6 is made of.

[02:14] <luqui> which, as far as I know, is still in English (despite fights to the contrary)

[02:14] <stevan> luqui: your offending my feminine side :P

[02:14] <luqui> putter, for a proper definition of "file", it seems so

[02:15] <luqui> yeah, females like to get offended by that one in the US

[02:15] <stevan> putter: yeah, for the most part

[02:15] <luqui> for some reason it doesn't bother spanish females

[02:15] * stevan slaps luqui with his purse

[02:15] <luqui> hey, no fair having keys in your purse!  Those hurt!

[02:16] <stevan> :P

[02:16] <stevan> putter: as I have stated many times before,.. this *might* work, it *might not* work

[02:17] <putter> ok, well that's simple.  finish yanking the code from S29, add in code from PIL2JS et al, create big Prelude.p6.  Bits of which can be commented out as they get/are defined by "Prelude.piln".

[02:17] <stevan> it feels sane in my head,.. but thats not saying much :P

[02:17] <putter> ;)

[02:17] <luqui> putter, barring modularization

[02:17] <stevan> putter: yes, as I said,.. it is a worthwhile pursuit :)

[02:17] <luqui> which Larry says he wants (hooray).

[02:17] * putter wonders if there is a "church of the simple"

[02:17] <luqui> that is, you have modules of related functions, a certain set of which are imported by default

[02:18] <putter> stevan: it's simple, and thus the Right Thing absent clear argument to the contrary.

[02:18] <luqui> occam's razor?

[02:20] <stevan> luqui: so, re: $repr,... if you cant answer, then I need Larry too :)

[02:20] <stevan> I dont think it is for us guys/girls to decide

[02:21] <luqui> why?

[02:21] <putter> hmm... especially if you have an Aristotelian model of software... "our task is to search out the perfect form of program x.  that is naturally the simplest possible form.  thus we apply occam..."

[02:21] <luqui> to me, that seems like API design rather than language design

[02:21] <stevan> luqui: let me explain the issue

[02:21] <luqui> and for API design, we make it and double check its sanity with Larry, not ask Larry how to do it

[02:21] <luqui> stevan, explain away.  maybe I don't understand fully

[02:22] <stevan> if $repr is meant to be an storage type for the opaque object type

[02:22] <stevan> then a class which uses p6array will act the same, and be totally compatible with one which uses p6hash

[02:22] <stevan> the differences will be hidden by the opauqe type

[02:22] <stevan> BUT

[02:23] <stevan> if $repr is meant to provide something more akin to blessing different reference types in p5

[02:23] <stevan> then we have issues

[02:23] <luqui> by more akin?

[02:24] * luqui goes over stevan's p6l message again

[02:24] <stevan> package MyObjectArray; sub new { bless [] => $class } sub head { pop(@{shift}) 

[02:24] <stevan> package MyObjectHash; use base 'MyObjectArray'; sub new { bless {} => $class }

[02:24] <stevan> that wont work

[02:24] <stevan> cause they are incompatible repr types

[02:25] <luqui> ah right

[02:25] <stevan> :)

[02:25] <luqui> back in a moment

[02:26] * stevan dances the opaque repr dance around luqui, every so often smacking him in the head with a lambda

[02:26] *** robkinyon joined
[02:26] <stevan> hey robkinyon 

[02:26] <robkinyon> heyla, stevan

[02:26] * luqui doesn't think that's a very cheerful dance

[02:27] * stevan stops dancing and gives the lambda to luqui so he can dance it this time

[02:30] *** Cryptic_K joined
[02:30] <svnbot6> r8643 | putter++ | S29draft.pod: typo correction

[02:43] <luqui> stevan, I'm stumpted on the $repr issue

[02:44] <stevan> luqui: me too :)

[02:44] <luqui> I don't think Larry has any idea what he's talking about there (he probably has some specific capability in his head, and tried to document a way to carry that out without telling us what the capability was... he does that)

[02:44] <stevan> hence my asking p6l :P

[02:44] <stevan> luqui: thats what I figured too,.. and why I asked

[02:45] <stevan> I can only read and re-read s12 so many times before I hit myself over the head with lambdas

[02:46] <luqui> hit yourself in the monads with a lambda

[02:47] <robkinyon> is the issue just "How do I know the repr in order to interact with it?"

[02:47] * stevan has decided Perl is a waste of time and is switching to LISP

[02:47] * robkinyon seconds that notion and wonders if $CLIENT will go for it

[02:47] <dduncan> took you long enough

[02:47] * robkinyon starts to read up on mod_lisp

[02:47] <stevan> robkinyon: no, we can know the $repr, the issue is "is that what we want to do"

[02:48] <robkinyon> huh?

[02:48] <stevan> [21:23] 	stevan	package MyObjectArray; sub new { bless [] => $class } sub head { pop(@{shift}) 

[02:48] <stevan> [21:23] 	stevan	package MyObjectHash; use base 'MyObjectArray'; sub new { bless {} => $class }

[02:49] <robkinyon> isn't that just promoting the same problem from p5 into p6?

[02:49] <stevan> so the question is, are different $repr types in CREATE just alternate storage? or more like the p5 example above

[02:50] <robkinyon> more importantly, doesn't YAGNI apply?

[02:50] <stevan> robkinyon: yes, but I can't figure out what larry wants exactly,.. so I am stuck

[02:50] <stevan> S12 is not clear enough :)

[02:50] * luqui thinks the specific thing Larry had in mind might be interacting with p5 classes

[02:51] <robkinyon> more specifically, you mean the interacting with a hashref that happens to be blessed as a hashref and not an object?

[02:51] <stevan> luqui: yes, I think that too,.. which means we have alternate storage with the same low level access API

[02:52] * robkinyon has been thinking about releasing Ruby-style interfaces to Array and Hash by doing just that

[02:53] <luqui> what are Ruby-style interfaces?

[02:53] <luqui> and how do they differ from Java-style interfaces, or how do they differ from mixins?

[02:53] <stevan> interfaces in the style of Ruby :P

[02:53] <robkinyon> no

[02:53] <stevan> I think he means API,. 

[02:53] <robkinyon> my $array = Array->new;

[02:53] <robkinyon> $array->[3]

[02:53] <robkinyon> $array->flatten;

[02:54] <luqui> yeah, what about that?

[02:54] <robkinyon> the ruby API is damn useful

[02:54] <luqui> you mean the methods that arrays provide by default?

[02:54] <robkinyon> yeah

[02:55] <luqui> okay, now I'm not sure what you mean by "releasing"

[02:55] <robkinyon> of course, Perl won't let me do syntactically-sugared blocks like Ruby

[02:55] <robkinyon> release to CPAN

[02:55] <robkinyon> Ruby::Array

[02:55] <robkinyon> Ruby::Hash

[02:55] <robkinyon> Ruby::File

[02:55] <luqui> oh oh oh!

[02:55] <luqui> got it

[02:55] <robkinyon> it's an object AND an array and you're supposed to treat it as such

[02:55] <luqui> you're talking about perl 5

[02:55] <robkinyon> yeah

[02:55] <luqui> now it makes sense

[02:56] <robkinyon> but, i think the idea bears on this discussion

[02:56] <stevan> *cough* this is #perl6 :P

[02:56] <luqui> uh... not really

[02:56] <robkinyon> because it's something that I think may be causing Larry to want alternate $repr

[02:56] <luqui> probably not

[02:56] <robkinyon> maybe not that specifically, but ...

[02:56] <luqui> in perl 6, arrays already have methods

[02:56] <robkinyon> yes

[02:56] <luqui> everything can have methods

[02:56] <robkinyon> because P6 arrays are self-aware

[02:56] <stevan> luqui: and what is their $repr :)

[02:57] <luqui> opaque

[02:57] <luqui> they're just things

[02:57] <stevan> p6opaque?

[02:57] <robkinyon> but, one of the methods they have is []

[02:57] <robkinyon> right?

[02:57] * stevan ducks to avoid luqui's wildly waving hands

[02:58] <luqui> okay, it seems that I'm arguing that $repr doesn't make sense from an interface POV

[02:58] *** vel__ joined
[02:58] <luqui> it doesn't have any impact whatsoever

[02:58] <robkinyon> i'm curious - does this mean that, in P6, I can define a class that implements both [] and {}?

[02:58] <luqui> it's all just methods.  That's what I meant by "opaque" and "just things"

[02:58] <luqui> robkinyon, you mean like Match? :-)

[02:58] <robkinyon> Fair nuff

[02:58] <luqui> robkinyon, you can in Perl 5 too

[02:59] <stevan> luqui: right, that is ideal,.. but then why does it need to be in the perl6 level? isnt that an implementation detail? 

[02:59] <robkinyon> Contextual::Return, yes

[02:59] <luqui> or more simply, "overload"

[02:59] <robkinyon> The point is, luqui, that why does any $repr exist other than p6opaque?

[02:59] <robkinyon> If, as you say, everything is "just methods"

[02:59] <luqui> I think we're trying to figure out what $repr is, rather than why multiple can exist

[03:00] <robkinyon> it's a black box

[03:00] <stevan> I think the questions are related

[03:00] <luqui> stevan, and yes, I think it's kind of an implementation detail

[03:00] <stevan> I can see the reason for multiple ones

[03:00] <luqui> I think it's an API question

[03:00] <stevan> but its an imple detail :)

[03:00] <luqui> which is why I think it's still up to us to decide what it means

[03:00] <robkinyon> one sec - i'm confused

[03:00] <robkinyon> Can I create a P5 hash that has no OO semantics in P6?

[03:00] <stevan> luqui: how is it an API question,.. please expand

[03:01] <luqui> robkinyon, by "OO semantics" you mean?

[03:01] <stevan> he cant call methods on it

[03:01] <robkinyon> Or, does the very act of creating a hash in P6 automatically mean that I can call methods on it?

[03:01] <luqui> stevan, it's one of those things that is not fundamental about how the language works, but not entirely hidden from the language user's view

[03:01] <robkinyon> If EVERY SINGLE hash in p6 has methods, then there is only the p6opaque $repr

[03:01] <luqui> kind of a hook into however it is OO is implemented

[03:02] <luqui> robkinyon, I don't understand the reasoning for that conditional

[03:02] <luqui> $repr isn't about whether you can call methods on something

[03:02] <robkinyon> no, it is

[03:02] <luqui> I think it's about what the methods do inside themselves

[03:02] <stevan> luqui: yes :)

[03:02] <luqui> i.e. it doesn't matter in perl 5 whether something is a blessed hash or a blessed array

[03:03] <luqui> you can call methods on them both in the same way

[03:03] <robkinyon> luqui: Where do I get the hashref for the alternate $repr?

[03:03] <luqui> it's about how those methods interact with the innards of the object where $repr matters

[03:03] <luqui> robkinyon, I think I see what you're saying

[03:03] <luqui> but that means that all reprs are "built on" some p6opaque

[03:04] <luqui> see, I'm unclear on what exactly a repr is and how it differs from some other kind of object

[03:04] <luqui> (I think that's one of the big issues.  The other big issue is everything else.)

[03:04] <stevan>  luqu: see doc/notes/something-with-repr-in-the-filename.pod

[03:04] <svnbot6> r8644 | putter++ | src/PIL/misc/S29code.pl - Created.

[03:04] <svnbot6> r8644 | putter++ | Extraction/definition of p6 code from/for S29draft.pod.

[03:04] <svnbot6> r8644 | putter++ | Some may be useful for fleshing out the new PILn backend.

[03:04] <svnbot6> r8644 | putter++ | perl5/PIL2JS/lib6/Prelude/JS/ is another such resource.

[03:04] <svnbot6> r8644 | putter++ | To contribute, just scroll down until pod lines start appearing, then continue the conversion to p6 code.

[03:04] <svnbot6> r8643 | putter++ | S29draft.pod: typo correction

[03:04] <luqui> hmm..... it's not CREATE's decision

[03:05] <luqui> if you're using an array as a repr, the compiler better know that so it can translate $.foo into appropriate accesses into that array

[03:05] <stevan> luqui: no, you tell CREATE which one you want,.. CREATE defaults to p6opaque

[03:05] <robkinyon> That's why I've been babbling about the P5 Array impl.

[03:05] <luqui> stevan, I know, but I don't think it should be

[03:05] <robkinyon> because it all comes down to where the non-p6opaque thingies come from

[03:05] <robkinyon> because, it doesn't make any sense to bless an object into another class

[03:05] <luqui> robkinyon, bootstrapping.  you have to start somewhere.

[03:06] <luqui> robkinyon, it doesn't?

[03:06] <stevan> ah,.. i see what robkinyon is saying

[03:06] <luqui> explain

[03:06] <stevan> if Array is an object,.. why use it as a $repr for opaque

[03:06] <stevan> p6array

[03:06] <stevan> it is already an object

[03:07] <luqui> yeah, I gathered that

[03:07] <stevan> which itself is a p6opaque

[03:07] <luqui> and it's a bootstrapping issue

[03:07] * stevan spins around a few times to make the point

[03:07] <luqui> what's Array's repr?

[03:07] <robkinyon> p6opaque

[03:07] <stevan> you said p6opaque

[03:07] <robkinyon> that's the bootstrap

[03:07] <robkinyon> so, why am i using an object as the repr for another object?

[03:07] <luqui> hmm.. right

[03:07] * stevan spins some more,.. it makes more sense when you are dizzy

[03:08] <robkinyon> LOL

[03:08] <luqui> robkinyon, maybe for alternate metaclass stuffs

[03:08] <robkinyon> no

[03:08] <stevan> luqui: no, alternate metaclass is handled in the MOP

[03:08] <robkinyon> there is no reason because it comes down to "Why am I using an object to represent my object?"

[03:08] <stevan> not releated

[03:09] <luqui> robkinyon, because it's useful to do that sometimes?

[03:09] <robkinyon> YAGNI

[03:09] <luqui> I'm just thinking about the metaclass stuff

[03:09] <robkinyon> YAGNI

[03:09] * putter contemplates the potential for an Eliza program to participate in #perl6 oo discussions... ;)

[03:09] <luqui> maybe I'm using the wrong word

[03:09] <luqui> robkinyon, stop saying that!

[03:09] <robkinyon> LOL

[03:09] <robkinyon> stevan tells me that on a daily basis

[03:09] <stevan> luqui: metaclass stuff is just subclassing ^Class

[03:10] <robkinyon> luqui: The point is that if you cannot come up with a counterexample, then YAGNI applies

[03:10] <stevan> luqui: best thing is to yell YAGNI back at him,.. but other than that there is no cure

[03:10] <robkinyon> it's put into the MAYBE_LATER section

[03:10] <luqui> robkinyon, but as language designers, we must take a lot of time to try to come up with a counterexample

[03:10] <robkinyon> Absolutely

[03:10] <robkinyon> i'm not saying that the idea has no merit

[03:10] <stevan> YAGNI!

[03:10] <luqui> and by yelling YAGNI, you're not really allowing that time

[03:10] <luqui> :-)

[03:11] <robkinyon> No, I'm allowing that time to not interfere with moving forward

[03:11] <luqui> robkinyon, but it's specced!

[03:11] <luqui> YAGNI doesn't apply unless we get Larry to agree

[03:11] * stevan squints hard at the spec,.. but its still fuzzy

[03:11] <robkinyon> and three very intelligent people talking for almost 30min cannot come up with a reason for the spec

[03:11] <luqui> we're interpreting the spec, like christians interpreting the bible, or supreme court justices interpreting the constitution

[03:11] * stevan wonders where those people are,.. and why they arent talking to us

[03:12] <robkinyon> Unless the four very intelligent people that constitute @Larry can give us a reason, those of us implementing the spec have to say "Provide a failing testcase"

[03:12] <stevan> luqui: and that kind of stuff has never ever ever caused trouble :P

[03:12] <robkinyon> and move on

[03:12] <luqui> robkinyon, but the discussion is not going in circles!

[03:12] <robkinyon> really?

[03:12] <luqui> It was moving along nicely until you interrupted it

[03:12] <luqui> I even had an insight that I was about to say

[03:12] <robkinyon> we have all agreed that, fundamentally, everything is implemented in terms of p6opaque

[03:12] <luqui> robkinyon, "agreed"?

[03:13] <luqui> no, I said I see your point

[03:13] <robkinyon> robkinyon: so, why am i using an object as the repr for another object?

[03:13] <robkinyon> luqui: hmm.. right3.

[03:13] <luqui> robkinyon, are you asking yourself?

[03:13] <robkinyon> no - i'm quoting

[03:13] <luqui> okay, I guess it's a limitation of IRC

[03:13] <luqui> it wasn't a, "oh you're right"

[03:13] <luqui> it was a "hmm, good point"

[03:14] <luqui> in any case, that doesn't matter

[03:14] <luqui> I see your point, but I don't necessarily agree

[03:14] * stevan wants to hear luqui's insight

[03:14] <luqui> so let's say hypothetically that you want to build an object on top of an Array

[03:14] <robkinyon> since all the reasons to use an alternate representation are moot in P6 given p6opaque and []/{} being methods, I fail to see what benefit there is

[03:14] <robkinyon> You would build an object having an array

[03:15] <luqui> robkinyon, no, I mean translating member accesses to array lookups

[03:15] <robkinyon> ok

[03:15] <robkinyon> translate member access into accessing the array that you contain as your sole memeber

[03:15] <luqui> that is, I want the user to write:  class Foo { has $.bar;  method baz() { return $.bar } }

[03:15] <luqui> and I want to translate that internally into array accesses

[03:15] <luqui> internally is the key word

[03:16] <luqui> you have to think like a module writer for a second

[03:16] <robkinyon> unless you're going to mix this in somehow due to some random serialization requirement, I can't see what the benefit is

[03:16] <luqui> robkinyon, let's say it's interfacing with a C program

[03:16] <robkinyon> or, you need to implement as an array in order to have sequential memory locations to do some sort of shared mem

[03:16] <robkinyon> that's fine

[03:16] <luqui> which has memory layout requirements

[03:16] <robkinyon> are you using the boxed or unboxed array?

[03:16] <luqui> boxed

[03:16] <stevan> Array

[03:17] <stevan> uppercase is boxed,.. lower is unboxed

[03:17] <robkinyon> that doesn't conform to the memory layout requirements

[03:17] <luqui> shut up

[03:17] <luqui> i'm just trying to get the point across

[03:17] <luqui> forget that I said Array

[03:17] <luqui> pretend I said CStruct

[03:17] <robkinyon> ok ... is that implemented in terms of p6opaque?

[03:17] <luqui> the point is, I have a great idea that has to do with laying out objects differently than perl 6 does by default

[03:17] <luqui> and yes, it is implemented in terms of p6opaque

[03:18] <luqui> but that does *not* mean that it is identical to p6opaque

[03:18] <robkinyon> you want to have direct control over how your memory is laid out

[03:18] <robkinyon> now, i can see a benefit

[03:18] <robkinyon> i apologize if I pissed you off.

[03:19] <luqui> it's okay... I just felt like you were getting too detailed when I was posing a thought experiment

[03:19] <luqui> anyway...

[03:19] <robkinyon> well, it's kinda like the "rebuttal of relational theory" Ovid posted to Perlmonks a few weeks ago

[03:19] <luqui> what I was thinking eariler is that the compiler has to know what layout you're using

[03:20] <justatheory> robkinyon: Actually, Ovid is in favor of relational theory. That post was about the fact that SQL is not relational.

[03:20] *** [Keith] joined
[03:20] <luqui> either that or member accesses have to be certain kinds of method calls (an idea that I am not entirely opposed to :-)

[03:20] <stevan> luqui: so you are saying that on the p6 level it makes no diff, but on the compiled level it does

[03:20] <robkinyon> justatheory: My response was "Pick an example that's actually normalized"

[03:20] <luqui> stevan, not exactly

[03:20] <justatheory> robkinyon: My response is; Reate Date.

[03:21] <luqui> If I want to implement this new object on top of CStruct, I'd like to do that all from perl

[03:21] <luqui> that is, it doesn't have anything to do with the writer of the class or the user of the class

[03:21] <luqui> but the implementor of the metaclass or something like that

[03:21] * stevan ducks the waving hands again

[03:22] <robkinyon> luqui: May I try?

[03:22] <stevan> metaclasses dont handle attribute access

[03:22] <luqui> well you seem to have a pretty strong notion of what a metaclass is

[03:22] <stevan> in intstances

[03:22] <luqui> and apparently mine differs from yours in there

[03:22] <luqui> thus "or something like that"

[03:22] <stevan> luqui: a metaclass is an instace of ^Class

[03:22] <luqui> I thought that's what a class was

[03:22] <stevan> luqui: it is what ^Class is an instance of

[03:22] <robkinyon> luqui: what you're saying is that you want to be able to define a CStruct within the framework of class { ... } and have the compiler and the interpreter both grok you

[03:22] <stevan> the "meta

[03:22] <stevan> the "meta" part is really optional

[03:22] <luqui> metaclass is the class of ^Class

[03:23] <luqui> robkinyon, as long as I tell them how to grok me

[03:23] <stevan> luqui: and turtles all the way down

[03:23] *** [Keith] left
[03:23] <stevan> luqui: until you stop it and make something an instance of itself

[03:23] <robkinyon> Or, going further, you want to be able to hand something a C header file and it create a usable $repr for you

[03:23] <luqui> stevan, what is an instance of itself in this metamodel?

[03:23] <robkinyon> luqui: Don't even go there

[03:24] <luqui> robkinyon, why not?

[03:24] <robkinyon> it's not needed for you to understand the turtles! :-)

[03:24] <stevan> luqui: ^Class is an instance of ^Class

[03:24] * stevan thinks robkinyon had a bad turtle experince as a child

[03:24] <luqui> okay, so we're ruling out alternate representations

[03:24] <luqui> by the current model

[03:24] <robkinyon> there is much blowing of brain gaskets when you get stevan talking about how ^Object is an instance of ^Class

[03:24] <robkinyon> no ... you have a good reason for why alternate representations are useful

[03:24] <stevan> and ^Class is an instance of ^Class too :)

[03:25] <luqui> but in any case, if my ramblings are anywhere near correct, it's an API issue, a language hacking issue, not a language issue

[03:25] <robkinyon> no ... i think it's a language issue

[03:25] <luqui> robkinyon, how come?

[03:25] <robkinyon> in part because you need your CStruct representation to not be so free-flowing in its memory usage

[03:25] <robkinyon> at some point, it needs to point to the same contiguous section of RAM

[03:25] <luqui> I think it's important to *be able* to do it; it's not very important how it's done

[03:25] <stevan> robkinyon: thats an implementation issue I think

[03:26] <robkinyon> well ... it's a language issue

[03:26] <luqui> it's one of those points where easiness doesn't matter anymore

[03:26] <luqui> and that's what I consider an API issue

[03:26] <robkinyon> because where do you define, in Perl, the layout of your CStruct?

[03:26] <luqui> robkinyon, in somebody's library that knows about CStructs

[03:26] <stevan> luqui: we have decided what make sense.. but I am still not confident that is what $Larry meant

[03:26] <robkinyon> given that the entire language can be redefined given enough libraries, that's fair

[03:26] <stevan> hence the p6l question :)

[03:27] <luqui> stevan, but he hasn't responded

[03:27] <stevan> luqui: yes, he is busy at $work,.. dont you read you own notes :P

[03:27] <luqui> well, I was about to give two alternatives, one of which was that one, so yes

[03:27] <stevan> :)

[03:28] <luqui> it's also probably the case that you gave him something to think about

[03:29] <luqui> unfortunately, Larry doesn't think by talking like we do

[03:29] <luqui> so it's easy to get Warnockedf

[03:29] <luqui> s/f$//

[03:29] <stevan> oh well,.. 

[03:30] <stevan> ok, time for me to get off the computer

[03:31] <stevan> luqui++ robkinyon++ # productive converstations

[03:31] <stevan> putter++  too

[03:31] <stevan> ok, night all &

[03:38] <putter> good night stevan &

[03:43] *** vel__ left
[03:48] *** oylenshpeegul left
[03:50] *** broquaint joined
[03:59] *** jiing_mIRC joined
[04:31] <brent> is now known as brentp

[04:35] *** webmind joined
[04:39] *** Amnesiac joined
[04:42] *** PerlJam joined
[04:44] *** broquaint joined
[04:50] *** chip joined
[04:57] *** broquaint joined
[05:01] *** chip joined
[05:06] *** webmind joined
[05:18] *** broquaint joined
[05:18] *** chip joined
[05:24] *** webmind joined
[05:31] *** dduncan left
[05:31] *** dduncan joined
[05:31] <dduncan> oops

[05:39] *** elmex joined
[05:40] *** justatheory joined
[05:49] *** justatheory joined
[06:35] *** kakos joined
[06:36] <GeJ> greetings all

[06:44] *** penk joined
[06:45] *** PJF left
[07:07] <Supaplex> elo GeJ 

[07:12] *** Alias_ joined
[07:12] <Alias_> seen audreyt 

[07:12] <jabbot> Alias_: audreyt was seen 13 hours 35 minutes 19 seconds ago

[07:28] *** iblechbot joined
[07:30] *** lisppaste3 joined
[07:34] <gaal> $morning

[07:37] <dduncan> greet ings

[07:37] <Alias_> $response

[07:37] <dduncan> $response_to_response_or_next_comment

[07:39] *** kanru joined
[07:41] *** Aankhen`` joined
[07:55] <gaal> putter: a few questions on S29code:

[07:55] <gaal> why "package Math::Trig {}" etc.?

[07:56] <gaal> how did you choose the precision of constants?

[07:56] <gaal> any thoughts on plugging this module into the tests?

[07:58] <gaal> and, I wonder if there isn't a way to avoid the macro use for trig_func.

[08:50] *** luqui joined
[08:55] <gaal> hey luqui. I'm still not sure about how IMPORT is supposed to go.

[08:56] <luqui> by "supposed to go" you mean?

[08:56] * luqui thought it worked just like in perl 5

[08:56] <gaal> p6 provides a default mechanism for (a) exporting symbols and (b) configuring modules

[08:56] <luqui> or do you mean the "standard" export mechanisms

[08:57] <Alias_> is use Foo; finally going to mean use Foo (); ?

[08:57] <gaal> if somebody defines an &IMPORT (or, if it's just like perl 5, &import) sub, does the standard one not get called?

[08:57] <luqui> Alias_, I doubt it...

[08:57] <Alias_> crap

[08:58] <luqui> yeah, that's a little annoying inconsistency

[08:58] <luqui> gaal, probably something like inheritance

[08:58] <gaal> luqui: I want to refactor around line 855 of Parser.hs, it's getting a little insane

[08:58] * luqui looks

[08:58] <gaal> but I don't know what it's supposed to do

[08:59] * luqui thinks that whenever you say "line 855", refactor is implied

[08:59] <gaal> what goes on is:

[08:59] <gaal> (now i mean_

[08:59] <gaal> )

[08:59] <gaal> 836: if use Foo (), nothing.

[09:00] <gaal> 838: if there's an &import or &unimport as appropriate, call them.

[09:00] <gaal> 846 onwards: symbol export.

[09:00] <gaal> (of course 846 on needs to be much more finely grained; that's not my immediate concern)

[09:01] <gaal> what I don't understand is, what is the responsibility of the implementor of &import?

[09:01] <gaal> does &import need to cause symbols to be exported?

[09:02] <scook0> gaal: "it's getting a little insane/but I don't know what it's supposed to do" -- I've had that feeling about parts of Parser.hs more than a few times :)

[09:02] <gaal> can it prevent the default exporter from happening?

[09:02] <gaal> scook0: the problem isn't with parsing now, it's with p6 semantics not being clear yet.

[09:02] <luqui> meaning...

[09:02] <luqui> should the implementor of IMPORT export symbols himself?

[09:02] * luqui thinks it probably should be able to

[09:03] <luqui> the thing is... it's not well specced AFAIK

[09:03] <gaal> luqui: in that case they need a way to supress the default exporter

[09:03] <gaal> luqui: I know :)

[09:03] <luqui> maybe the default exporter works like Export.pm

[09:03] <luqui> except with a nicer interface

[09:04] <gaal> like I keep saying, the problem starts with two different things being conflated

[09:04] <gaal> symbol export control and module configuration.

[09:05] <gaal> why not separate them?

[09:05] <gaal> &IMPORT and &LOAD

[09:05] <gaal> &UNIMPORT and &UNLOAD

[09:05] <luqui> Shouldn't we separate them from the "use" interface, too, then?

[09:05] <scook0> one is an import-time hook, and the other is a full exportation override?

[09:05] * luqui actually thinks that would be a splendid idea

[09:05] <gaal> I think we should, but I don't know how that should look

[09:06] <luqui> if it weren't for those damned sigils...

[09:06] <gaal> scook0: init-time hook, I guess

[09:06] <luqui> you could use named arguments for imports and positionals for config

[09:06] <luqui> but that probably wasn't a great idea in the first place

[09:07] <scook0> luqui: I was going to suggest the other way around (named/pos)

[09:07] <luqui> ahh, but named makes sense for imports because they're already unordered... but those damn sigils

[09:07] <scook0> since positionals in general tend to represent the 'real data', whereas named/adverbs specify how it is to be used

[09:08] <luqui> I think we probably need to go haskellish (again)

[09:08] <gaal> luqui: I'm not seeing why sigils are a problem here?

[09:08] <luqui> have some sensible defaults "import default, import nothing"

[09:08] <luqui> and then provide keywords (eg. "qualified") for finer-grained control

[09:08] <luqui> maybe not keywords though

[09:08] <gaal> qualified+aliases is a whole different moose

[09:08] <luqui> sigils are a problem because you can't say:  use Foo :@bar

[09:09] <luqui> well, you can, but it means something different

[09:09] <scook0> you can if &use is a macro

[09:09] <luqui> scook0, yeah, but that's not very pretty

[09:09] <luqui> anyway, I think configuration should have the full power of perl 6 call syntax

[09:10] <gaal> :'@bar'   :-(

[09:10] <luqui> I'm tempted to say "use" and "import"

[09:10] <luqui> import Foo <@bar $baz>

[09:11] <luqui> use Foo <vars>   # config

[09:11] <gaal> in what order do you need to say these, and when do they happen?

[09:11] <luqui> but that might be too fine a distinction for the common man

[09:11] <scook0> use Foo("config") <@bar $baz>

[09:11] <gaal> then need to happen at compile time

[09:11] <gaal> and config prolly has to happen before import.

[09:12] <luqui> oh, I was talking about two separate ways to use a module

[09:12] <gaal> ah.

[09:12] <gaal> hmm.

[09:13] <luqui> it kinda seems like they should be in the same place

[09:13] <luqui> because some modules would do both at once...

[09:13] <gaal> Larry thinks there needs to be alot of control over imported scope

[09:13] * luqui thinks so too

[09:13] <gaal> so the import syntax needs to be more complex anyway

[09:14] <gaal> as noted in S11 now

[09:14] <luqui> that is a very terse description though

[09:15] <gaal> luqui: I understand it though, if it doesn't need to deal at all with config.

[09:15] <gaal> There is a hack we could use

[09:15] <gaal> parrot GHC's command line +RTS ... -RTS

[09:15] <gaal> that's ugly though :)

[09:15] <luqui> ...... use/import is looking better and better

[09:16] <luqui> what's RTS?

[09:16] <gaal> luqui: only in the cases you only need one.

[09:16] <luqui> not necessarily

[09:16] <luqui> you can think of import like roles and use like traits

[09:16] <gaal> luqui: there are several "namespaces" of arguments in the GHC command line.

[09:16] <luqui> import is for modules that are completely well-behaved, use is for modules that do funny business

[09:16] <gaal> you can tell the runtime system things, but also some other subsystem

[09:16] <gaal> GHC avoids clashes by letting you say

[09:17] <gaal> ghc --make +RTS -M400 -RTS +Someothermodule -M48284 -Someothermodule

[09:17] <gaal> and the -Mx args mean different things.

[09:17] <luqui> ahh, I see

[09:17] <luqui> that is ugly

[09:17] <gaal> well, it solves a difficult problem.

[09:18] <Alias_> ugh... the pain from the techie kicking a plug out the wall continues...

[09:18] <gaal> luqui: I don't buy "use is for modules that do funny business"... you want to init a module tersely sometimes

[09:18] <Alias_> Had to derack my dev server AGAIN after the NIC was intermittently failing

[09:18] <Alias_> So that's a primary IDE controller and a NIC.

[09:19] <Alias_> Crossing fingers nothing else goes

[09:19] <luqui> we could kill the use Foo () syntax though

[09:19] <luqui> replacing it with import Foo;

[09:19] <Alias_> Server Room Protocol: Look twice, step once!

[09:19] <luqui> use Foo # import default stuff, do normal stuff

[09:19] <gaal> luqui: how do you say "import defaults from Foo" then?

[09:19] <gaal> heh

[09:19] <luqui> import Foo  # like use Foo (), but accepts import configs

[09:20] <luqui> enough people use "use Foo ()" that it might be worth it

[09:20] <luqui> it'll take some more mulling though

[09:20] <luqui> and probably more arguing

[09:21] <luqui> argue away if you have more :-)

[09:21] <gaal> I think there oughta only be one keyword for compiletime module loading

[09:21] <gaal> I don't mind if it's renamed to "load" :)

[09:21] <luqui> huh?  what's wrong with "use"?

[09:21] <gaal> nothing :)

[09:22] <gaal> just saying, there has to be one

[09:22] *** Alias_ left
[09:22] <luqui> is there a reason you only want one keyword

[09:22] <luqui> ?

[09:22] <gaal> don't forget there's also "require"

[09:22] <luqui> which is runtime...

[09:22] <scook0> luqui: cargo-cult reasons?

[09:22] <gaal> it's going to be very confusing

[09:22] <gaal> sure it's runtime

[09:22] *** kane_ joined
[09:22] <luqui> as if use Foo () isn't confusing enough already

[09:23] <gaal> you're going to want to use the runtime version occasionally, and want it to feel like the compiletime variant

[09:23] <luqui> we get rid of that inconsistency and replace it with a different kind of inconsistency...

[09:23] <luqui> you're suggesting that require should call IMPORT?

[09:23] <gaal> nono

[09:23] <gaal> sec phone sorry

[09:27] <gaal> back. I'm fine with require MyModule; MyModule.IMPORT(x);

[09:28] <luqui> I'm not sure what you mean by "feel like the compiletime variant" then

[09:28] <gaal> it'd be great if "x" could be the same as what it would have been had I said "use MyModule x"

[09:28] <gaal> that's what I mean.

[09:28] <luqui> yeah... I'm not sure that has anything to do with my side of the argument

[09:29] <luqui> import Foo x;    require MyModule;  MyModule.IMPORT(x)

[09:29] <luqui> use Foo x;   require MyModule;  MyModule.USE(x)

[09:29] <luqui> er, s/Foo/MyModule/g

[09:29] <gaal> (also, I still think the return value of use/require should be a callable Module object, so (require MyModule).IMPORT(x)

[09:29] <gaal> but I think we already agreed on that one

[09:29] <gaal> )

[09:29] <luqui> that might be nice

[09:30] <gaal> my gripe with your idea is that sometimes you want both USE and IMPORT

[09:30] <luqui> and then importing that module would take two lines?

[09:30] <luqui> which is ugly and painful?

[09:31] <luqui> fair enough

[09:31] <gaal> yeah, not only because order matters with these lines.

[09:31] * luqui isn't sure how order would matter except in the most bizarre of circumstances

[09:31] <luqui> i.e. the use handler populating what is to be exported  (/me realizes that's not all that bizarre)

[09:32] <gaal> any module that does things at compile time would want its config data known early

[09:32] <luqui> depending on what those things are

[09:32] <gaal> there's an incidental objection that people coming from mainstream languages would be used to saying "import Foo" early up.

[09:32] <gaal> though that's not a very strong argument :)

[09:33] <luqui> my biggest gripe against my argument is that we now have two operations that do almost the same thing

[09:33] <luqui> and subtle distinctions are bad for beginners

[09:34] <luqui> maybe some special syntax...

[09:34] <luqui> use Foo config, args importing import, args

[09:34] <gaal> well, the unclever approach is to say, importation is symbol table stuff, quote it anyway

[09:34] <luqui> 'course, use Foo importing <bar>  is a little verbose

[09:35] <gaal> actually I like special syntax, if you can come up with a golfy one.

[09:35] <luqui> gaal, I'm not quite sure what you mean

[09:35] <luqui> I don't see how quoting it helps

[09:35] <gaal> luqui: make all importation explicit stringy args, then you only have to reserve the args for importation

[09:35] <luqui> gaal, example?

[09:36] <gaal> use Foo :velocity<500> :imports<&takeoff &land>

[09:36] <luqui> I assume s:2nd/importation/configuration/

[09:36] <gaal> subsume importation under configuration (like in p5)

[09:36] <luqui> gaal, but you're really losing on the power of importation there

[09:36] <scook0> I suppose `use Foo <&takeoff>` could be short for `use Foo :imports<&takeoff>`

[09:37] <gaal> maybe Foo's USE function can have a trait declaring if it takes responsibility for importation?

[09:37] <luqui> scook0, and require all args to be named otherwise, like .new?

[09:37] <gaal> luqui: yes, that's why I don't like it

[09:38] <luqui> a powerful importation mechanism kills all "namespace collision" antihuffmanism

[09:38] <luqui> having to worry about namespace collisions should be a programmer's last concern

[09:39] <luqui> we do have siglists

[09:39] <gaal> siglists?

[09:39] <scook0> luqui: what do you mean by "namespace collision" -- which namespace(s)?

[09:39] <luqui> use Foo :imports:( :my($foo) :our($bar) );

[09:39] <luqui> gaal, signature objects, :(...)

[09:40] <luqui> scook0, er, name collision

[09:40] <luqui> making names long so that there's a better chance they'll be unique

[09:40] <gaal> luqui: where's that specced? interesting

[09:40] <luqui> S06 IIRC

[09:40] <scook0> luqui: i.e. two modules exporting the same short name?

[09:40] <luqui> scook0, aye

[09:41] <luqui> here's the one I'm working on now:  two different methods named the same thing

[09:41] <luqui> that's the hardest one

[09:41] <luqui> at least with Perl's world-view it's hard.  With Haskell's (and C++'s, but they didn't take advantage of it), it's easy

[09:42] <luqui> gaal, btw, :() is actually \()

[09:43] <gaal> luqui: in "Closure paramaters"? wow, that doesn't really advertise the feature very loudly :)

[09:43] <luqui> :() is how it's declared

[09:43] <luqui> use Foo :imports\( :my<$foo> :our<$bar> )

[09:43] <luqui> geez that's a lot of special syntax for a simple thing

[09:45] <gaal> use Foo :velocity<500> importing :my<$foo> :our<$bar>;

[09:45] <luqui> but that may be another good way to go:  require use to take only named or only positional parameters

[09:45] <luqui> in the positional case, just pass it as the sig to :imports\()

[09:45] <luqui> gaal, you like the namey syntax?

[09:45] <luqui> I agree it's not bad

[09:45] <luqui> except for the common case

[09:45] <scook0> the problem is that it needs to be (a) simple in the simple cases, (b) not too complex in the complex cases, and (c) decent scaling between a & b

[09:45] <luqui> use List::Util <reduce>

[09:46] <luqui> shouldn't be:  use List::Util importing <reduce>

[09:46] <gaal> well, what's more common? export control or config control?

[09:46] <luqui> I'd say exports

[09:46] <luqui> but I can't back that up

[09:46] <gaal> I agree SOMETHING needs to win the short form :)

[09:47] <scook0> it matters less if you make the not-quite-so-short form still pretty short

[09:48] <scook0> (assuming you can)

[09:48] <luqui> also, what about module aliasing

[09:48] <gaal> use List::Util importing nothing; # <- Alias won't like that...

[09:48] <scook0> I just wish there wasn't conflict between config-adverbs and scope-adverbs

[09:48] <luqui> i.e.  use Data.Map as Map

[09:48] <luqui> s/use/import/

[09:49] <gaal> luqui: that's the whole other moose :)

[09:49] * luqui is beginning to think that, once again, Haskell got it right

[09:49] *** dada joined
[09:49] <luqui> have a very small minilanguage for exports

[09:49] <luqui> that supports aliasing and fine-grained import control

[09:49] <gaal> luqui: but then, they have no config control at all

[09:49] <luqui> gaal, that's not true

[09:49] <gaal> and no control over scoping of symbols

[09:50] <gaal> luqui: how do you config a module in haskell?

[09:50] <luqui> not Haskell exactly!

[09:50] <luqui> haskell's philosophy

[09:50] <luqui> which is essentially: use Foo::Bar::Baz config importing <baz quuz> as Baz

[09:50] <luqui> a little englishish minilanguage

[09:51] <luqui> (except "as" means something different, and it's too short to be put at the end like that)

[09:51] <gaal> that works for me except people who want the simple case (not realizing there were a few different ones) would hate it

[09:51] *** nnunley joined
[09:51] <luqui> gaal, but we have to piss off those people if we're diverging from perl5 at all

[09:52] <luqui> if there is any distinction between config and exports, those folks will yell

[09:52] <luqui> because one's going to be longer

[09:52] <gaal> there is one say to avoid it...

[09:52] * luqui ponders use/imp to keep them quiet :-p

[09:52] <luqui> gaal, what say is that?

[09:52] <luqui> :-)

[09:52] <gaal> let the module author provide the default one with precedence :)

[09:53] <luqui> yeah, uh.... no

[09:53] <luqui> you want to make people feel like they're in control

[09:53] <scook0> luqui: (one's going to be longer) that's why I liked `use Foo <$symbol>` `use Foo :option`

[09:53] * luqui thinks that's one of the most important things to do

[09:53] <scook0> but it interferes with export control

[09:53] <luqui> scook0, how come?

[09:54] <luqui> you mean powerful export control...

[09:54] <luqui> okay

[09:54] <scook0> luqui: yes, :my() and the like

[09:54] <gaal> yeah, quoting the symbol means no powerful excontrol

[09:54] <luqui> no, we still have to quote symbols

[09:54] <scook0> unless you can put the excontrol inside the <>

[09:54] <gaal> so I think we all agree no relegation to strings, yes?

[09:55] <gaal> oh

[09:55] <gaal> hmm

[09:55] <gaal> we're going around in circles

[09:55] <scook0> i.e. use Foo < :my($symbol) >  # ugly though

[09:55] <luqui> scook0, especially from an implementation perspective

[09:55] <gaal> scook0: and fragile too :(

[09:56] <gaal> (export a "<" symbol...)

[09:56] <luqui> gaal, oh my god!

[09:56] <luqui> operators!

[09:56] <gaal> or an op

[09:56] <gaal> yeah

[09:57] <luqui> maybe that's just:  use Foo < infix:<+++> >

[09:57] <luqui> (IIRC <> does balancing)

[09:57] <gaal> how does that work? oh, I forgot < > is teh smart

[09:57] <scook0> clever <>

[09:57] <gaal> foresight++

[09:57] <luqui> not quite:

[09:57] <scook0> (I can see that causing pain in obscure cases though :)

[09:58] <luqui> use Foo < circumfix:<[: :]> >  # uh oh

[09:58] <gaal> yeah, that helps against the common case, and if someone really wants to overload '<', let them sweat

[09:58] <gaal> hmm, why doesn't that work?

[09:58] <scook0> use Foo 'circumfix:<[: :]>'

[09:59] <luqui> scook0, yeah...  if people are importing circumfix operators, presumably they know what they're doing enough to use those quotes

[09:59] <scook0> use Foo < circumfix:«[: :]» >

[09:59] <luqui> scook0, same problem

[09:59] <luqui> the problem isn't balancing, it's word splitting

[09:59] <gaal> ah, right.

[09:59] <scook0> (I just realised that myself)

[10:00] <gaal> use Foo q#circumfix:<[: :]>#     :(

[10:00] <luqui> but this does bring up an interesting point

[10:00] <luqui> you are allowed to write operators infix:{'+'}

[10:00] <luqui> or in many various ways

[10:00] <luqui> should we really be quoting these symbols?

[10:00] <scook0> it seems to me that qw<> isn't really what we want

[10:00] <scook0> we really want a quote-identifier construct

[10:00] <gaal> can you do crazy stuff like infix:$op ?

[10:01] <luqui> ?eval my $op;  BEGIN { $op = "+" };  say infix:{$op}(3,4)

[10:01] <luqui> evalbot!!!

[10:02] <gaal> my $op = <- + / *>.pick; infix:$op := { ... }

[10:02] <gaal> luqui: oh yeah, I was wondering what happened to it a few days ago

[10:02] <gaal> I gotta go out and do some stuff before the stores close, bbiab

[10:03] <gaal> I hope you guys will still be here in ~40 min?

[10:03] <luqui> gaal, and for yours, $op needs to be chosen at compile time

[10:03] <luqui> no, I'm going to bed

[10:03] <gaal> luqui: right

[10:03] <luqui> will continue to think about this though

[10:03] <azuroth> does anybody in here know latin?

[10:03] * luqui isn't even sure how to say "no" in latin

[10:03] <gaal> luqui: ok. I was hoping to make export a little saner for the release

[10:04] <gaal> but oh well, at least I'll have $larry cornered on Feb :-)

[10:04] <luqui> is there a hackathon?

[10:04] <azuroth> I'll tell you how to say yes: sic

[10:04] <luqui> that's helpful.  so then when somebody asks if I know latin, I can say "sic"

[10:04] <luqui> and be lying...

[10:04] <gaal> azuroth: port your text to perl, then use Lingua::Perligata or whateverthemoose it is

[10:04] <gaal> luqui: osdc.org.il

[10:05] <gaal> azuroth: "sic" isn't yes, it's "thus"

[10:05] <gaal> luqui: wanna come? :)

[10:05] <luqui> definitely

[10:05] <gaal> audrey will be there too.

[10:05] <luqui> but alas, I cannot

[10:05] <luqui> $$ && $school

[10:05] <luqui> :-(

[10:05] <azuroth> wow, so it is

[10:06] <gaal> azuroth: sic transit gloria mundi

[10:06] * gaal &

[10:06] <azuroth> thus it travels the glorious world...?

[10:06] <azuroth> s/it/he/

[10:07] <luqui> geez, pugs is huge

[10:07] <luqui> took forever to check out

[10:07] <luqui> evalbot should be on in about 20 minutes

[10:07] <luqui> it has to build from scratch

[10:08] * luqui &

[10:10] <gaal> >> showstoppers for release afaik: 1. PGE/parrot integration is broken 2. multisub exports are broken

[10:10] <gaal> azuroth: "thus passes the glory of the world", but look it up, it has interesting cultural moose

[10:11] <gaal> &  <- for real

[10:11] <azuroth> ahh, okay

[10:11] <azuroth> you'll be back

[10:15] *** r0nny joined
[10:16] *** r0nny joined
[10:24] <gaal> that took less than expected :-)

[10:28] <gaal> I hope Aankhen`` comes back soon, I want to hear what artists talk about when they get together :)

[10:29] <azuroth> gaal: "why did you tell the story, girl?" is "cur fabulam narrabas, puella?", correct?

[10:30] <gaal> azuroth: haven't the foggiest :)

[10:30] <gaal> I do know puella is girl though!

[10:31] <azuroth> oh. you tricked me! :-)

[10:33] <gaal> what's the infinitive of narrabas?

[10:34] <azuroth> narrare

[10:34] <azuroth> to tell

[10:34] * gaal knows latin like he knew haskell last march

[10:34] <gaal> oh, so it is 1st conj.

[10:34] <azuroth> heheh. I'm just learning both

[10:35] <gaal> so apparently this is indicative active 2nd person sing.

[10:35] <gaal> imperfect

[10:36] <gaal> and fabulam is accusative

[10:36] <azuroth> yeah, so probably more like "why were you telling". but I don't know (plu?)perfect or anything yet

[10:37] <gaal> i've no idea what pluperfect means :) "why have you been telling"?

[10:37] <gaal> http://www.math.ohio-state.edu/~econrad/lang/latin.html # latin cheat sheets, err, docs/quickref/

[10:37] *** penk joined
[10:37] *** G2 joined
[10:38] * gaal just noticed the domain name for that site, ha.

[10:38] <azuroth> I think pluperfect is when something was done and finished a while ago. and perfect is just when something's been finished?

[10:39] <gaal> why have you told?

[10:39] <gaal> okay

[10:39] <gaal> this gets harder than monads when you reach the 3rd declension :)

[10:41] <svnbot6> r8645 | Darren_Duncan++ |  r1927@Darren-Duncans-Computer:  darrenduncan | 2006-01-13 02:40:06 -0800

[10:41] <svnbot6> r8645 | Darren_Duncan++ |  [/ext/Rosetta|/ext/Rosetta-Engine-Native|/misc/Rosetta-Incubator] : incremented versions of all modules that have a pre-rewrite equivalent on CPAN, so these post-rewrite versions are kept higher than a new CPAN retroactive release due tomorrow that uses the pre-rewrite versions

[10:42] <dduncan> and with that, there's probably nothing else I need to commit before 6.2.11 is packaged up

[10:46] <azuroth> I'm up to page twelve of the first book. 5% of my way to learning latin!

[11:31] *** iblechbot joined
[11:31] *** bsb joined
[11:32] * theorbtwo backlogged.

[11:47] *** pdcawley joined
[11:50] *** EdLin joined
[11:56] *** elmex joined
[12:16] *** ilogger2 joined
[12:28] <ingy> seen audreyt 

[12:28] <jabbot> ingy: audreyt was seen 18 hours 50 minutes 24 seconds ago

[12:48] *** Stoffe left
[12:48] *** putter joined
[12:48] <putter> hi gaal, let's see...

[12:49] <putter> re S29code, 

[12:49] * daja77_ pokes rafl 

[12:50] <putter> re ' why "package Math::Trig {}" etc.?', because it's speced as a package, rather than say as a module.  inserting things directly (multi Math::Trig::mumblefrotz (...) {...}) is fine, but at some point you have to say its a package.

[12:50] *** _ori joined
[12:51] *** _ori left
[12:53] <putter> re ' how did you choose the precision of constants?' - I cut and pasted the first line of the example section of their OEIS database entry. ;)  Something more principled will be needed at some point.  

[12:53] * rafl pokes back

[12:53] <rafl> daja77_: What's up?

[12:54] <daja77_> why is your jabber timing out

[12:54] *** calanya joined
[12:54] <rafl> daja77_: I'm online and talking to someone.

[12:55] <putter> re ' any thoughts on plugging this module into the tests? ', not quite yet.  this is still mostly just a grabbag to help with the "now the piln backend passes sanity, what about the rest of the tests?" Prim.hs port phase.

[12:56] <gaal> putter: I meant, why not "package Math::Trig { multi mumblefrotz }"?

[12:56] <gaal> putter: re precision, the danger is with infectuous overprecision

[12:57] <gaal> BigFloats are costly etc.

[12:58] <daja77_> rafl: can you read me there?

[12:58] <putter> My current impression of the Right Thing is to take a finished S29code (half of it is still unmodified pod), things from Prim.hs which can be easily p6-ified, and blobs of PIL2JS/lib6, and generate a big mostly complete p6 "prelude", to complement the small piln prelude.

[12:59] * gaal nods

[12:59] <putter> second batch of questions in a sec...

[13:00] <gaal> Is the exporter properly part of Prim or of Parser?

[13:00] <gaal> it doesn't parse things itself; but it does return bits of AST.

[13:01] <gaal> hmm, maybe neither? Pugs.Exporter?

[13:02] <gaal> then again, it only exports (ha) one function, which should probably only be called from Parser...

[13:03] <putter> re ' and, I wonder if there isn't a way to avoid the macro use for trig_func.' - sure... you can compute them at runtime (or BEGIN{} compile time... using something like foreach <sin cos ...> -> $op { M::T::$op ::= -> (Num $n --> Num) { ... Primitive::$op... }}.   or you can expand them, generating a much less maintainable blob of 10x bigger code.  what's wrong with macros? ;)

[13:04] *** chris2 joined
[13:04] <gaal> :-)

[13:05] <gaal> "Syntax hilighting doesn't work with them!"

[13:06] <putter> second batch: re why not putting them in brackets (M::T { multi mumble }), the spec has fully qualified names  (multi M::T::mumble), with adjacent lines going into different packages/classes.  and S29code mirrors S29draft.pod as closely as possible.

[13:07] <putter> re overprecision... hmm... how do you keep both 64bit long double folks and 32bit double folks both happy?  perhaps we need a precision pragma?

[13:08] <putter> re 'Is the exporter properly part of Prim or of Parser? it doesn't parse things itself; but it does return bits of AST.'... well, it sounds like an AST-flavor _macro_ to me! ;)

[13:09] <gaal> :D

[13:11] <putter> re syntax highlighting... having anything but p6 generate the text map info looks basically a lost cause.  the usual regexp approach... for p6!?!;)

[13:12] <gaal> putter: util/perl6.vim works nicely most of the time. Of course it isn't perfect.

[13:15] *** kolibrie joined
[13:16] <putter> ah, but that's only because I don't yet have control (complete control! lexically scoped!  oh, I sooo can't wait:) over the p6 parser rules, nor AST-based macros.  perl6.vim?!  Ha! ;)

[13:17] <gaal> well, when you have THAT control you obviously will use the perl-enabled version of vim to load alternate syntax files. :)

[13:17] <putter> hmm... re exporter... it won't in time for next release, but once we have pil2/piln, we can have pil2/piln modifying macros!  Which would actually be the Right Way to implement the pure-p6 version of the exporter.

[13:18] <theorbtwo> The thing to do is to get pugs to produce some sort of dump with full position information, and get perl6.vim to parse that.

[13:18] <theorbtwo> Viola, always-correct coloration information.

[13:18] <gaal> theorbtwo: we're not THAT far from that, actually.

[13:19] <theorbtwo> I know.

[13:19] <putter> theorbtwo++ # re position dump - agreed

[13:20] <gaal> too bad you can't do this:

[13:20] <gaal> # echo ':D say "hi" if 4==4' | ./pugs -

[13:21] <theorbtwo> The problem, BTW, with the plan I just layed out is that it won't do anything vaugely useful for things that simply don't compile.

[13:21] <gaal> indeed.

[13:22] <gaal> how do clever IDEs like Eclipse's JDT do it?

[13:22] <putter> actually, I'd like to see a refactoring engine rather than just a dumper.  so emacs/vim can say "extract the code between lines n and m into a helper function", and Perl6::CodeEngine does the right thing, and sends back the new text and highlighting.  IDEish var docs and completing.  what else...?

[13:22] <gaal> backtrack a lot I suppose...

[13:22] <gaal> yes, that is a holy grail of sorts.

[13:23] <putter> s//Perl6::CodeEngine::Server/

[13:26] <putter> re 'things that dont compile', hmm... maybe picky grammars should come with a companion lax grammar for highlighting??  or...?

[13:27] *** avar joined
[13:28] <putter> I suppose one could fall back to the wizzy grammar-based equivalent of the current "bag of simple heuristics which somewhat match user expectation" approach.

[13:29] <theorbtwo> Some of the time, it's perfectly reasonable to put up a warning somewhere onscreen and keep using the highlight from the last time it did compile.

[13:31] <putter> re IDEs, tolerant parsers and bags of pattern matchers.   tend to be happy with very macroy code like emacs/gnu C files (I actually dont know how well Eclipse currently deals).

[13:32] <putter> s/happy/un$&/

[13:33] <putter> re holy grail, hmm, since p6 will embed ruby and python and..., there is a chance to define the standard way to play this game.

[13:34] * gaal doesn't have a recent CDT to check

[13:38] *** bsb joined
[13:39] <putter> since there is so much in common between refactorers for different languages, and given p6's needs and the perl communities' unusual attitude of "ooo, another language!  yes!  let's bring it in!  new CPAN module!"  (rather than the usual, "we can do that better.  no?  well, why would you want to do it anyway."),...  one might create *the* refactoring engine... ;)

[13:39] * putter daydreams happily...

[13:40] <gaal> putter: maybe looking at eclipse is worthwhile, since they did want to be a metaide.

[13:41] <putter> indeed.

[13:44] <putter> gaal: a question: ok, say once oo and rules are working, folks pump out say javascript, ruby, python, and scheme backends.  so suddenly there are new implementations p6ruby, p6python, etc.  what are the resulting community social dynamics?  the scheme folks have so many implementations the probably wont care.  though #perl6 may see some

[13:45] <gaal> resulting community social dynamics? I don't know, world peace maybe?

[13:47] <putter> well, condescending remarks about syntactic complexity etc (I have particular people in mind;).  the ruby folks will be happy as long as it's a really conforming implementation.  what about the python folks?  "we're not perl" has been their mantra for a decade.  I don't have a feel for how that will play out.  or more importantly, what we can

[13:47] <putter> do to help it play out nicely.

[13:49] <putter> re world piece, err, peas, err, peace.  I'd be ecstatic if we can just start writing "interesting" software systems.  what we've got now is still soo mid-1970's.

[13:50] <gaal> I honestly don't know. In any case it's not like the code generated to high-level languages is very readable; this looks to be useful in programmatic slurpage of code, where original language is sorta hidden away anyway

[13:51] <putter> err, huh?

[13:52] <gaal> hmm, you mean consuming code from cpan in other languages?

[13:52] <gaal> sorry my brain is being drained by it being cold and my not having eaten lunch

[13:53] <gaal> I'll probably make more sense after I take a break :)

[13:54] <putter> oh, no.  use Language::JavaScript::OnPerl6; ...  eg, misc/JavaScript-FrontEnd/ .   actually, I'd like pugs to eventually do file suffixes, so  pugs foo.py  does the right thing.

[13:55] <putter> is it a python implementation?  is it p6?  if you're a pythonista, do you care?

[13:56] <putter> pugs -MLanguages::AutoFileHandling foo.js bar.py hee.rb -e 'say "wow"'

[13:57] <gaal> how do objects get bridged among languages?

[13:58] * robkinyon starts waving his hands a lot in gaal's direction

[13:58] <gaal> fwiw there are a number of python implementations available

[13:58] *** Limbic_Region joined
[13:59] * gaal dodges and decides this is a good time for that break

[13:59] <robkinyon> gaal: Actually, there was a discussion last night between stevan and luqui about that topic

[13:59] <robkinyon> well, a closely-related one, at any rate

[13:59] <gaal> bbiab :)   &

[14:02] <theorbtwo> Gah.

[14:02] <theorbtwo> Building pugs is taking approx 3 years on my system.

[14:02] <theorbtwo> ...and it's not that weak a system, either.

[14:03] <Limbic_Region> theorbtwo - how much free memory does it have?

[14:03] <putter> gaal: adapter methods?  even in a pure p6 context, I'd like to be able to say "in this lexical scope, .nth($n) on Foo should result in a call to the underlying .nth with $n+1 ("baaaad silly 1-based indexing CPAN module").  or ".foo means .bar", etc.

[14:03] <theorbtwo> Woo, done!

[14:03] * putter wants complete control of his namespace.  the ability to correct for CPAN modules with brain-dead apis.

[14:03] <integral> ghc still seems to need >500MB on AST.Internals and the precomp prelude

[14:04] <theorbtwo> Around half a gig.

[14:04] <theorbtwo> 449,948 kB of real mem free, says free.

[14:04] <putter> non-trivial.

[14:05] <putter> later &

[14:06] <theorbtwo> http://dresden-ocl.sourceforge.net/aboutproject.html

[14:13] <theorbtwo> Hm, ./pugs -CPIL2-Perl5 -e 'say "this is a test"' gives only one PPos, but -CPIL2 (with no dash) has two MkPos.

[14:16] *** SamB joined
[14:37] *** peacock joined
[14:39] *** calanya joined
[14:53] *** hcarty joined
[14:58] *** iblechbot joined
[15:05] *** gantrixx joined
[15:26] *** justatheory joined
[15:30] *** Eimi joined
[15:30] *** lisppaste3 joined
[15:38] *** rantanplan_ joined
[15:50] <gantrixx> do any of you guys ever talk to Larry Wall?

[15:52] <theorbtwo> @Larry, also known as the Cabal, has a weekly conference call, and $Larry posts to the mailing lists fairly often.

[15:53] <gantrixx> As a linguist, I was wondering if he thought english was the best language to base a programming language off of

[15:54] <gantrixx> I wonder if we will ever have a hindi or mandrin based programming language

[15:54] <gantrixx> or perhaps it should be esperanto based

[15:54] <theorbtwo> (1) I think it's more based on human languages in general then on English in specific.

[15:54] <theorbtwo> (2) Ruby?

[15:55] <gantrixx> Ruby is none english?

[15:55] <theorbtwo> Ruby's primary author is Japanese.

[15:55] <gantrixx> Take Perl for example, all the key words are english based

[15:55] <theorbtwo> Oh.

[15:55] <gantrixx> if, print, has, return

[15:55] <theorbtwo> That's not so much a matter of it being "based on english".

[15:57] <theorbtwo> It's a matter of convience.

[15:57] <gantrixx> the key words are based on english

[15:57] <GeJ> considering that 99% of all the programmers in the world speak more or less english, english seems a defacto language for syntax keywords in programming languages.

[15:57] <theorbtwo> sh does it less -- it's if...fi, case...esac.  That's horrid.

[15:57] <wolverian> GeJ, where did you get that figure?

[15:57] <gantrixx> and yes, even the grammars are based in english

[15:57] <theorbtwo> There used to be localized versions of visual basic.  They were horrible.

[15:57] <theorbtwo> Some microsoftie did a great blog entry on that.

[15:58] <gantrixx> that is chicken and the egg though

[15:58] <theorbtwo> Documentation would have to be even more translated.  Communities would be even more fragmented.

[15:58] <gantrixx> most programmers speak english because they have to

[15:58] <gantrixx> because the majority of the programming technology is based in english

[15:58] <theorbtwo> A hardly-insignificant number speak English because it's the most common language in the world.

[15:59] <GeJ> wolverian: inhouse statistics... we have polish, slovak, french, german, chili(an?), american and autrian people here, and all of them grok PBP. :)

[15:59] <gantrixx> english is the most spoken language in the world, but it is not the most widely spoken native language

[15:59] <gantrixx> english is the new latin

[15:59] <gantrixx> you used to have to know latin to study any of the sciences

[15:59] <gantrixx> now you need english

[16:00] <theorbtwo> You hardly have to speak English at a native level to be able to undertand if a=1 then print "Ja" else print "Nein"

[16:00] <gantrixx> the language du jour basially depends on who the current world power is

[16:01] <gantrixx> si a == 1 entonces escribe "Ja"

[16:01] <gantrixx> and you hardly have to speak spanish to understand that

[16:01] <wolverian> Lingua::Perligata :)

[16:01] <theorbtwo> And, indeed, I can follow it just fine, even though I hardly speak Spanish.

[16:01] <wolverian> er, s/::/::Romana::/

[16:02] <gantrixx> it's completely arbitrary. the question is if you wanted to make it a non-arbitrary design decision would you base it upon multiple languages, the dominant language, or a common language

[16:02] <gantrixx> if the s in s/this/that/  is based in english (substitute)

[16:03] <theorbtwo> gantrixx: It's worth noting that Ruby was written with English keywords, even though it was written in Japan by a Japanese man.

[16:03] <theorbtwo> What does the y in y/-/_/ stand for?

[16:03] <gantrixx> I don't know y

[16:03] <gantrixx> I don't think I've ever used y

[16:04] <wolverian> it stands for tr ;)

[16:04] <theorbtwo> Everybody uses tr///, because y/// doesn't stand for anything.

[16:04] <theorbtwo> (Except when you're golfing -- trying to do a task in as few keystrokes as possible.)

[16:05] <theorbtwo> What does the x in " " x $indent stand for?

[16:05] <gantrixx> do it that many times

[16:05] <theorbtwo> Eh?

[16:05] <gantrixx> print $indent number of spaces

[16:05] <theorbtwo> Yes, but what does the "x" stand for?

[16:05] <gantrixx> times

[16:06] <theorbtwo> Exactly.

[16:06] *** eric256_ joined
[16:06] <gantrixx> x is commonly recognized in mathematics as times

[16:06] <theorbtwo> It's not the language that they come from that's important, it's that the symbols are as fimilar as possible to the target audience.

[16:06] <theorbtwo> Most of the time, when writing a new programming language, that audience is programmers.

[16:07] <gantrixx> or the fact that we write our code from left to right reflects western languages

[16:07] <theorbtwo> ...who are already fimilar with "if", even if they aren't English.

[16:07] <gantrixx> perhaps if the arabs had a programming language it would be right to left

[16:07] <gantrixx> or the chineese top to bottom

[16:07] <Limbic_Region> gantrixx - your original question doesn't appear to be the one you are actually asking though

[16:08] <Limbic_Region> the programming language is not modeled from a single spoken/written language

[16:08] <theorbtwo> Except left-to-right isn't as clear as you think it is.

[16:08] <gantrixx> my original question was, in essense, is english the best language for basing a programming language off of

[16:08] <theorbtwo> In sin(exp(2)), the sin is evaluated /last/.

[16:08] <Limbic_Region> right - but keywords and syntax are two completely different things

[16:08] <Limbic_Region> you appear to be concerned with keywords and not syntax

[16:09] <theorbtwo> ...and in perl you can write for (1..$_) {print "foo"} or print "foo" for 1..$_.

[16:09] <integral> ((constant 2) >>> exp >>> sin) `app` _|_

[16:09] <theorbtwo> I'm not aware of any human languages that read bottom to top.

[16:10] <theorbtwo> integral: ==> became >>>?

[16:10] <gantrixx> in Perl I also write "my $a;" and not "$a mi"

[16:10] <integral> theorbtwo: haskell, but yeah, s/>>>/==>/ and you get perl6 mostly, but you can then drop the lift and the apply

[16:10] <gantrixx> so it is based off the english grammar that posessive pronouns come before the noun

[16:11] <gantrixx> although Perl does allow some flexibility with some of it's grammar, it is still based on english grammar and english key words

[16:11] <theorbtwo> Yes, it is.

[16:11] *** penk left
[16:11] <theorbtwo> I think that's for the best, given the current state of the world.

[16:11] <theorbtwo> Not only that, but it's a "best" with /huge/ inertia.

[16:11] <theorbtwo> Hm, on second thought, it's a state.

[16:11] *** elmex joined
[16:12] <gantrixx> you sound like you work for Microsoft

[16:12] <gantrixx> "we are the best, because we are the biggest"

[16:12] <theorbtwo> In some cases, it's true.

[16:12] <eric256_> isn't english generaly the chosen langauge of science in general?  (/me could be 100% wrong there but i thought i read that somehwere)

[16:12] <gantrixx> OK, so IE is the best because more people use it than Firefox

[16:13] <gantrixx> English is the language choosen because there are the most jobs in english

[16:13] <eric256_> gantrixx if you want to talk to the most people and the most people speak one langauge, then you speak that language. thats simple logic

[16:13] <theorbtwo> If I were writing a language specificly to be taught to 4th graders in Mexico, then I would possibly spec it in spanish, and use spanish grammar and keywords.

[16:13] <theorbtwo> If I'm writing a language to be used by programmers, I'll do it in English.

[16:13] <eric256_> you are mixing uses of best.    enlglish might be the 'best' because its most common, not becuase its best suited.

[16:13] <gantrixx> exaclty, so why don't we program in language based off mandrin chineese?

[16:14] <gantrixx> certainly there are more native mandrin speakers than english speakers

[16:14] <theorbtwo> It might be.  OTOH, I doubt you'll find a language better suited -- none of them are purticularly well suited, I'm going to guess.

[16:14] <stevan> gantrixx: cause it's hard to get a keyboard with mandrin characters here in the US :)

[16:14] <eric256_> are there more native mandrin programmers though?

[16:14] <gantrixx> so my question is, should the language be based off who ever is economically dominant at the time, or should science (and computer science) have a universal language

[16:15] <gantrixx> should we all give up our native language and speak one universal science language

[16:15] <theorbtwo> It does, to a large extent.

[16:15] <gantrixx> ?

[16:15] <theorbtwo> That language is C.

[16:15] <eric256_> science and programming do have a universal language, it just happens to be the most economically dominant currently ;)

[16:15] <gantrixx> and C isn't based off of english?

[16:15] <theorbtwo> Not terribly much.

[16:15] <theorbtwo> A few keywords.

[16:16] <theorbtwo> But that it is is independent.

[16:16] <gantrixx> key words, and grammar too

[16:16] <eric256_> and many of those keywords don't mean the same thing to english speakers as they do to programmers ;)

[16:16] <theorbtwo> It's not English that's the standard, it's C.

[16:16] <gantrixx> and all the computer technologies all have english names as well

[16:16] <rantanplan_> Hehehe, but you can program Perl in Latin ;)

[16:16] <theorbtwo> ...and you overestimate how much C is like English.

[16:17] <theorbtwo> For example, English-speakers commonly put if clauses at the end of the senence.

[16:17] <theorbtwo> That's completely illegal in C.

[16:17] <gantrixx> I agree there is more mathematical "language" in most programming languages and mathematics tends to be a universal science language

[16:17] <gantrixx> but you can't deny the fact that most programming languages were written by westerners and based off english

[16:18] <theorbtwo> If I have seen further then others, it is by standing on the shoulders of giants.

[16:18] <eric256_> why would we deny it? and why is that a bad thing?

[16:18] <eric256_> you seem to have a beef not a question

[16:19] <gantrixx> no, it's not a beef, it was a question

[16:19] <gantrixx> I was wondering what a linguist such as Larry Wall thought

[16:19] <theorbtwo> I think if you want to completely change all known syntax and keywords, go ahead -- perl 6 will make it easy.

[16:19] <theorbtwo> But nobody will use it.

[16:19] *** vel__ joined
[16:19] <gantrixx> but others wanted to discount the fact that programming languages are based off english, so I just defended my assertion

[16:20] <theorbtwo> Programmers think in terms of function(arguments), because they've used other programming languages, and because they've used math.

[16:20] <gantrixx> I don't want to.  My native language is english

[16:20] <theorbtwo> Is it better then (arguments)function?  Not really.  Is it worse?  Nope.

[16:20] <wolverian> first_argument.function(more_arguments) # :)

[16:21] <eric256_> (@arguements) ==> function;

[16:22] <gantrixx> and most comments tend to be in english in source code

[16:22] <wolverian> put function applied to @arguments to @results; # yay!

[16:22] <eric256_> i would disagree on that, i've found plenty of code with what i assume was german commenting

[16:22] <theorbtwo> gantrixx: That hasn't purticularly been my experince.

[16:22] <eric256_> and some with spanish variable names, now that can be fun to decipher ;)

[16:23] <gantrixx> perhaps you guys work with different code bases than I

[16:24] <gantrixx> I have seen several HOW-TOs in german, but rarely do I see source code comments in anything but english

[16:25] <gantrixx> how many people here are non-native english speakers?

[16:25] <wolverian> I am.

[16:26] <gantrixx> what is your native language?

[16:26] <theorbtwo> Audrey isn't here at the moment, but she is.

[16:26] <wolverian> gantrixx, Finnish.

[16:32] *** avar joined
[16:55] <ingy> seen audreyt 

[16:55] <jabbot> ingy: audreyt was seen 23 hours 17 minutes 21 seconds ago

[16:57] *** Southen_ joined
[17:04] <eric256_> seen eric256

[17:04] <jabbot> eric256_: eric256 was seen 3 days 22 hours 48 minutes 33 seconds ago

[17:04] <eric256_> seen eric256_

[17:04] <jabbot> eric256_: eric256_ was seen 5 seconds ago

[17:04] * eric256_ wonders how he alawys ends up with that darn _

[17:12] <Limbic_Region> eric256 - likely your client automatically reconnects (or you do) quickly

[17:13] <Limbic_Region> if you have lost connection but the IRC server doesn't know it and you reconnect, your client automatically appends the _ as eric256 is still logged in as far as the server is concerned

[17:13] <eric256_> stupid computers ;)

[17:14] <Supaplex> artifical inteligence has a funny aftertaste don't it? :)

[17:15] <pdcawley_> Mmm... I spy some hard reading ahead, TaPL just arrived...

[17:22] <Limbic_Region> . o O ( TaPL ? )

[17:22] <Limbic_Region> Types and Programming Languages

[17:24] * pdcawley_ grins, bingo!

[17:25] <eric256_> is that a book then?

[17:26] <pdcawley_> Yes.

[17:28] <GeJ> a painful one...

[17:28] <GeJ> not only it is big, but reading it hurts.

[17:28] <GeJ> Well, in my case.

[17:29] <eric256_> hey, since p6 supports lazy lists.. could you then define a list as the function that produces it?

[17:29] <eric256_> my @fib = iterator { $_[-2] + $_[-1] };

[17:30] <eric256_> well with better fibonacii code than that (more specificaly code that works. ;))

[17:32] <Limbic_Region> eric256_ - my guess is that is not something that will (or should) be supported in the core language

[17:33] <Limbic_Region> there is just way to many things to have a sane DYMism

[17:33] <Limbic_Region> OTOH, I think the core language should allow subclassing of the array class easily enough for you to roll your own and make your own DWYM

[17:34] <Limbic_Region> eric256_ - have you read my tutorial/article on iterators?

[17:34] <eric256_> no

[17:34] <eric256_> in the pugs tree?

[17:39] <eric256_> i know i've seen code on perlmonks for lazy lists in p5...they had to be treated special....arg

[17:42] <clkao> 8/win 28

[17:48] *** nothingmuch joined
[17:53] *** G2 joined
[17:54] <Limbic_Region> sorry - work

[17:54] <Limbic_Region> eric256_ see http://www.perl.com/pub/a/2005/06/16/iterators.html

[17:55] <Limbic_Region> fwiw - you can change your nick by typing /nick <new handle>

[17:57] <ric256> is now known as eric256

[17:58] <eric256> work is evil ;)

[17:58] *** Lartuv joined
[18:01] *** broquaint left
[18:11] <tewk> Is there a recommended REPL shell for Perl5?

[18:15] <theorbtwo> perl -de1

[18:30] <kane_> seen audreyt

[18:30] <jabbot> kane_: audreyt was seen 1 days 52 minutes 22 seconds ago

[18:30] *** Ovid joined
[18:30] <Limbic_Region> From a reply to Guido Van Rossum's blog "Can a language be functional, declarative, procedural, OO, statically typed, late binding, uncle tom cobley and all and remain easily accessible or shall we admit that there is not one ring to bind them all"

[18:31] <Limbic_Region> is it possible that not everyone has heard of Perl6 yet?

[18:34] <integral> Sounds like he has...

[18:49] *** elmex joined
[18:54] *** Qiang joined
[18:59] *** G2 joined
[19:16] *** hexmode joined
[19:19] *** ycheng_ joined
[19:46] <gantrixx> Actually, I don't think that many people know about Perl6

[19:47] <gantrixx> it would be cool if /. or LugRadio started covering it

[20:03] <Khisanth> no it wouldn't!

[20:04] *** putter joined
[20:04] <putter> Does anyone know off hand if invocants are automatically rw?  I'm trying to reconcile Prim.hs and S29draft.pod:

[20:05] <putter> \\n   List      pre     pairs   safe   (rw!Array)\

[20:05] <putter> multi Array::pairs  (@array : MatchTest *@indextests --> Int|(List of Pair) )

[20:08] <Khisanth> would a rw invocant mean that calling a method could actually alter the invocant? as in $foo.bar(); # $foo is now a different object from before the call to bar()

[20:08] <putter> ?

[20:09] <wolverian> that's how I would read it. what else can it mean?

[20:09] <putter> looks like PIL2JS lacks a rw for other methods (exists delete) Prim has as rw!Array.  I'll leave it off and leave a comment.

[20:10] * putter is assembling a composite Array.pm from assorted sources.

[20:16] <Khisanth> wolverian: but that would be EXTREMELY suprising behavior

[20:17] <Khisanth> althought potentially "useful" in the right situation

[20:23] <Khisanth> is there an AES for roles?

[20:23] <wolverian> S12?

[20:25] <svnbot6> r8646 | putter++ | docs/AES/S29draft.pod - corrected typos - adverbs missing their colon.

[20:25] <svnbot6> r8645 | Darren_Duncan++ |  r1927@Darren-Duncans-Computer:  darrenduncan | 2006-01-13 02:40:06 -0800

[20:25] <svnbot6> r8645 | Darren_Duncan++ |  [/ext/Rosetta|/ext/Rosetta-Engine-Native|/misc/Rosetta-Incubator] : incremented versions of all modules that have a pre-rewrite equivalent on CPAN, so these post-rewrite versions are kept higher than a new CPAN retroactive release due tomorrow that uses the pre-rewrite versions

[20:27] <putter> err, what does this mean?   &Array::pop<Array> := &Array::splice<Array>.assuming(...   what's the <Array> thing?

[20:31] <putter> S29drarft.pod, but pugs doesn't like it.  alternate implentation coming up...

[20:35] <gaal> rehi

[20:40] *** eric256 left
[20:41] *** Qiang joined
[20:42] <putter> hi gaal

[20:45] <gaal> heya

[20:45] * gaal battles indent levels

[20:47] * putter puzzles over Array.pm code

[20:48] <putter> .[] should be postcircumfix, no?  PIL2JS has it as prefix.  puzzlement.

[20:49] <gaal> putter: maybe it's comutative, like in c :-)

[20:51] <putter> oh I need to borrow a clue.  ok, my understanding is  postcircumfix:<[ ]> is array indexing.  Prim.hs defines .[] as array indexing (note the ".").  PIL2JS defines a prefix:<[.[]]> as array indexing.  whaaaa?!?

[20:52] <putter> gaal: :)

[20:53] <gaal> putter: I think that's so you can chain lookups, as in

[20:54] <gaal> $x = { a => b => c => d => 42 }; say [.{}] $x <a b c d e>

[20:56] <putter> is it just a short form for say [postcircumfix:<{ }>] ..., or is the associativity actually different?

[20:57] <gaal> dunno

[20:58] <ingy> has guido submitted any patches?

[20:58] *** dduncan joined
[20:58] <gaal> ingy: to pugs? I think he declined the invite.

[20:58] <ingy> really?

[20:58] <putter> bah.  mission creep.  I do not need to understand, merely cut, paste, and comment.  thanks gaal ;)

[20:58] <ingy> bummer

[20:58] <putter> maybe once pugs is running python...

[21:00] <gaal> putter: what primary benefit do you see for non-p6 frontends to pugs? (as opposed to, say, parrot)

[21:00] <gaal> (not contesting of course; it's just that I hadn't actually considered this clearly till today)

[21:03] <putter> the world is full of code.  I want to be able to run it without caring what language it is written in.  I wish to escape the maze of twisty little passages which is software engineering, where when you need n components, there are always pointless constraints which 

[21:04] <putter> prevent you from getting more than m of them at a time.  where m is always strictly less than n.  and discovering the constraints requires a backtracking crawl through design space.

[21:04] * putter pauses for a deep breath ;)

[21:05] <putter> I want our field to not be so profoundly throughly broken.

[21:05] <putter> That's all. ;)

[21:07] <gaal> putter: okay, but there's some overlap between this and parrot's goals

[21:10] <putter> yes

[21:10] <gaal> so specifically why do it in the pugs level?

[21:11] <putter> though with a rather lower-level feel to it.  custom coding language parsers in "assembly", rather than building wizzy Arrow based grammar mutators and parser tools.

[21:12] *** elmex joined
[21:13] <gaal> ah, if you want arrows pugs is the place to find them :-)

[21:15] <putter> grammar Language::JavaScript::Grammar::FireFox is Language::JavaScript::Grammar::ECMA3;  GAP (algebra system) "yet another language" grammar is speced in BNF variant number three hundred fourty two.  and can be converted to rules by BNF::Frobnicate. ...

[21:16] <gaal> ahhh you want it higher up than arrows, you want it in perl 6!

[21:16] *** luqui joined
[21:17] <gaal> that's too high up for me atm but I get glimpses of the appeal

[21:17] <gaal> morning luqui 

[21:17] <luqui> mornin'

[21:17] <putter> use Perl6::PILN::Transformation::CPSConvert; ... 

[21:18] * putter ok, I'll stop then... :)

[21:18] * gaal slinks off to some well charted haskell :-)

[21:18] <putter> ooo, don't slink!

[21:19] * luqui dislikes the Cont monad

[21:19] * gaal unslinks

[21:19] <putter> any annoyance in my tone is just years of frustration at a broken field.  at being a shoemaker's child with broken crippled torn bloody gangrenous shoeless feet.

[21:21] <gaal> putter: oh, I'm not scared off by the tone (or by the purpose)! just.. too wide for my brain,57 things at a time

[21:22] <putter> thank you for the opportunity to vent.  and the reminder that it's "not completely obvious" what's needed.  the old "my thesis now written seems obvious, so why finish it?" ;)

[21:22] <luqui> what the heck are you guys talking about?

[21:22] <luqui> theses, shoemakers, 57 things...

[21:23] <putter> why run python on pugs, rather than simply on parrot.

[21:23] <luqui> because it's easier to compile to pil than it is to pasm?

[21:24] <putter> yes :)  and manage the compilers as well.

[21:25] <luqui> also because python on JS would be cool...

[21:25] <svnbot6> r8647 | Darren_Duncan++ |  r1931@Darren-Duncans-Computer:  darrenduncan | 2006-01-13 13:24:05 -0800

[21:25] <svnbot6> r8647 | Darren_Duncan++ |  deleted /misc/Rosetta-Incubator, since the remnants it contains (SQLBuilder, SQLParser, Eng/Gen, Emu/DBI) have dubious value

[21:25] <svnbot6> r8646 | putter++ | docs/AES/S29draft.pod - corrected typos - adverbs missing their colon.

[21:26] * luqui ponders writing a JS compiler to pil; then we could run JS on JS!

[21:27] <gaal> luqui: I think putter is working on that :)

[21:27] <luqui> oh, seriously?

[21:28] * luqui reads over S29, never having done so before

[21:28] <putter> misc/JavaScript-FrontEnd/ !  the grammar is as yet untested (only root level rules currently work in pugs).  one could flatten it and test!  the runtime and compiler is largely an automated transform on the spec.  I havent been keeping the checkedin copy in sync.  interested?!

[21:29] <putter> ;)

[21:29] <luqui> wow

[21:29] <luqui> not really.

[21:29] <luqui> but wow, cool

[21:30] <luqui> In addition, the list of functions imported into C<::*> will be

[21:30] <luqui> subject to change with each release of Perl.

[21:30] <luqui> is that a blessed policy?

[21:30] <putter> ah well.  the general observation is just that its very easy to do language implementations when your target environment capabilities are a strict superset of the language being implemented.

[21:32] <putter> it would be neat if one could do   use Perl3.02; ... ;)

[21:32] * stevan tosses some LISP into the room and runs out the door

[21:32] <stevan> http://sial.org/pbot/15425

[21:32] <luqui> yeah, "neat"

[21:33] * stevan really needs a new hobby 

[21:33] <putter> lol

[21:34] * gaal notices it's been a while since stevan made a movie

[21:35] * stevan wonders how got a hold of those video tapes? I thought I hid them better 

[21:35] <putter> fun code.  I'd actually really like to have CL front and backends.

[21:35] <stevan> I am really digging CL right now

[21:35] <luqui> I expect that those would not be that hard to implement

[21:35] <luqui> at least the frontend

[21:36] <stevan> luqui: it would probably be really easy to make PIL^N VM in it too

[21:38] <putter> I have most of a R5RS scheme on p5 I occasionally putter on.  "SchemeOn".  tiny p5 kernel and a scheme->p5 transliterator written in scheme.  and everything else.  biggest challenge was gathering together clean scheme-written-in-scheme code fragments.  it was quite a zoo.

[21:38] <putter> CL might be better.  hopefully much better.  todo list item is to check out SBCL's code base more closely.

[21:39] * stevan suspects putter might need another hobby even moreso than stevan :)

[21:40] <putter> let's do it!  well, we need piln for it to run.  but the gathering CL code can be done ahead of time.

[21:40] * putter is engaging in job search avoidance.

[21:40] <putter> :(

[21:41] <clkao> smoke still broken

[21:41] <clkao> pugs: *** Can't locate Test.pm in @*INC (@*INC contains: blib6/lib /usr/local/lib/perl6/mach /usr/local/lib/perl6 /usr/local/lib/perl6/site_perl/mach /usr/local/lib/perl6/site_perl /usr/local/lib/perl6/auto/pugs/perl6/lib /usr/local/lib/perl6/site_perl/auto/pugs/perl6/lib .). everywhere

[21:41] * stevan is off to parts-unknown &

[21:41] <putter> bye stevan &

[21:41] <gaal> clkao: multi subs still not exported

[21:41] <gaal> but that error shouldn't happen

[21:42] <clkao> why isn't test.pm in lib6

[21:42] <gaal> blib6/lib

[21:42] <gaal> should be

[21:42] <clkao> there's only blib6/lib/Test

[21:43] <gaal> worksforme...

[21:43] <gaal> blib6/lib/Test.pm you mean? that's ok

[21:43] <gaal> or do you have blib6/lib/Test/lib ?

[21:44] <gaal> blib6/lib/Test/ is for Test::Builder, not what you need

[21:44] <gaal> you ought to have a Test.pm in blib6/lib

[21:44] <clkao> no i don't

[21:44] <gaal> du -s blib6

[21:45] <gaal> I have ~4.6M

[21:45] <clkao> it's mostly empty. only .exist

[21:46] <clkao> but there is some hierarchy

[21:46] <gaal> clkao: what OS are you on?

[21:46] <clkao> freebsd. same on darwin iirc. er, there's about 3M

[21:47] <clkao> but no Test.pm under blib6/lib

[21:47] <gaal> anyway to solve your immediate problem so you can smoke, please export PERL6LIB=ext/Test/lib

[21:47] *** brentp joined
[21:47] <gaal> if you have time, look for errors in make, or try a really really clean copy, etc.

[21:48] <gaal> find blib6 | wc -l    => 545  here

[21:50] <clkao> too late, made realclean

[21:50] <clkao> i should sleep and leave it running

[21:50] <clkao> it seems to do it. make now copies Test.pm

[21:50] <clkao> how stupid is it

[21:51] <clkao> anyway, thanks gaal

[21:52] <clkao> zzz &

[21:52] <gaal> night :)

[21:58] <putter> does map work on an array's values, or its indexes (regardless of whether they .exist or not)?

[21:58] <luqui> good question

[21:59] <luqui> given that there's no way to test existence within the body of map, I'd say its values

[21:59] <luqui> but it's tricky

[21:59] <gaal> when does an array's index not .exist?

[21:59] <gaal> only when it's out of bounds, but then the map doesn't reach it. no?

[21:59] <svnbot6> r8648 | Darren_Duncan++ |  r1935@Darren-Duncans-Computer:  darrenduncan | 2006-01-13 13:57:10 -0800

[21:59] <svnbot6> r8648 | Darren_Duncan++ |  /ext/Rosetta : updated Copying.pod to demote 4 packages out of the defined framework core; only 4 remain

[21:59] <luqui> I think it's a bad idea to keep that distinction...

[22:00] <luqui> perl -le 'my @a = (1,2,3); delete $a[1];  print exists $a[1]'

[22:00] <putter> gaal: when one .delete($idx)s?  I've no idea.

[22:01] <Khisanth> but that should still exists

[22:02] <gaal> Khisanth: unless it was the last element, IIRC

[22:02] <Khisanth> yes 

[22:02] *** kanru joined
[22:02] <Khisanth> so you are modifying the array as you iterate over it?

[22:03] <gaal> it makes some sense to me, but I'm perlverted.

[22:05] *** f3l joined
[22:05] <putter> ha! S29 has an implementation I overlooked (woops).  and the verdict is...

[22:06] <luqui> nobody possibly could have thought of this issue before

[22:06] <luqui> plus, for a description of the crazy inter-array existence semantics, see perl 5 (my example)

[22:07] <putter> whatever *@array yields...

[22:07] <putter> sigh

[22:08] <putter> the delete $a[1] example?  why is that odd? ;)

[22:09] <luqui> because $a[0] exists, $a[2] exists, but $a[1] doesn't

[22:09] <luqui> I know you know putter, I was responding to gaal and Khisanth 

[22:11] <gaal> well, it surprised me but I'm not surprised to be surprised. like I said, perlverted.

[22:14] <svnbot6> r8649 | luqui++ | Minor editing on S29.

[22:17] *** wilx joined
[22:18] <putter> ooo, a S29 edit.  putter goes to see...

[22:21] <leo_> luqui: is above array.delete semantic also confirmed for p6? It looks weird to me - I thought it's like splice (no holes)

[22:22] <luqui> I sure hope not, it looks very weird to me too

[22:23] <luqui> but I think it hasn't been confirmed or denie

[22:23] <luqui> d

[22:24] <leo_> it's absolutely senseless in combination of native types - there isn't a 'no int' - it's kust maybe zero

[22:24] <leo_> just 0 even

[22:24] <luqui> Maybe 0, Just 0, but maybe it's Nothing...

[22:25] <luqui> hmm... Maybe 0... the type of things that might have type 0

[22:25] * luqui smacks himself in the monads with a lambda (and is getting rather accustomed to doing that)

[22:26] <leo_> well, native types don't have anything like nothing 

[22:26] * luqui knows

[22:26] * luqui was just being silly...

[22:26] <luqui> I'll fire off a message to p6l about array holes

[22:26] <luqui> not that we can hope to get a response from $Larry because he's busy

[22:28] <leo_> thanks

[22:28] * putter thought he had just finished with Array.  luqui++ just changed the signatures.  :)  such is life.

[22:29] <luqui> just cosmetic stuff though, like CALLER<$_> to $+_

[22:29] <gaal> (enviroment vars)++

[22:29] <luqui> ditto

[22:33] <putter> luqui: what's wrong with the Array::pairs etc signatures?

[22:33] <luqui> the reason I said XXX wrong is because we're not sure what's right yet

[22:34] <luqui> but it has to do with contextual multi dispatch

[22:34] <luqui> those probably suffice for descriptive purposes, but certainly not for implementation purposed

[22:35] <luqui> s/sed/ses/

[22:35] <putter> ok.  do they run?  never mind.  I'll have to check the whole file.  another day.

[22:45] *** sproingie joined
[22:46] *** Limbic_Region joined
[22:48] <svnbot6> r8650 | putter++ | src/PIL/misc/prelude/Array.pm - Created.  The beginnings of a p6 Prelude for piln.  Combines code from PIL2JS, Prim.hs, S29draft, etc.  Intended to help bootstrap piln.

[22:48] <svnbot6> r8650 | putter++ | Todo: Finish up Array.pm coverage.  Then test it, and write alternate implementations for anything pugs currently chokes on.  Then on to List, et al.  Err, "Help!". ;)

[22:53] <putter> luqui - S29 doesnt actually say whether keys, kv, etc return List or Array.  List?

[22:54] <putter> no, I have that wrong.

[22:54] <putter> I guess I was just confused.  tnx.

[22:55] <gaal> I think it's Juerd that likes to point out that you can't return Arrays in Perl, just items or lists.

[22:55] <gaal> s/that/who/

[22:57] *** Supaplex joined
[22:59] <putter> ah.  though with auto-refifying, it sure looks like you do.  ;)

[22:59] <svnbot6> r8651 | putter++ | misc/prelude/Array.pm - fix some return types.

[22:59] <gaal> putter: indeed

[23:00] <gaal> good thing at least that we no longer call it "scalar" context!

[23:02] <putter> <chuckle>  indeed

[23:08] *** beppu joined
[23:14] *** binary42 joined
[23:15] *** bpalmer joined
[23:19] *** dduncan left
[23:24] <putter> loqui: along the lines of your removing the <Array>'s, should &join<> := &join<Str>.assuming:delimiter(' '); be &join := &join.assuming:delimiter(' '); ?

[23:27] <putter> loqui: and is there a reason map and reduce use different conventions for their Code arguments?

[23:29] <putter> duh.  sorry.

[23:30] <putter> luqui: two questions above, misidentified loqui.  end of a long week.

[23:30] *** lisppaste3 joined
[23:34] <luqui> re map and reduce: looks like an oversight to me.  they should both be like reduce

[23:34] <luqui> putter, re <Array>s, the &foo<Bar> syntax is no longer correct; it is &foo:(Bar)

[23:35] <luqui> I think...

[23:35] <luqui> in any case, you shouldn't be currying the variant but the operation as a whole

[23:35] <svnbot6> r8652 | gaal++ | * Pugs.Prim.Yaml - very minor golfage

[23:35] <luqui> and IMO, things like join, map, etc. shouldn't be multis in the first place

[23:35] <luqui> but that's something I have to argue with @Larry about

[23:37] <putter> thanks!  And I assume  multi Lists::zip  should be multi List::zip (singular)?

[23:38] <svnbot6> r8653 | gaal++ | Pugs.Parser -

[23:38] <svnbot6> r8653 | gaal++ |  * Introduce Pugs.Parser.Export, because 3 is better than 7 when it comes

[23:38] <svnbot6> r8653 | gaal++ |    to indent levels.

[23:39] <gaal> hmm, *2* is better than 7 even.

[23:40] <gaal> since I can't count, perhaps I should go to sleep.

[23:41] <putter> lol :)

[23:42] <gaal> btw this still segfaults for me:

[23:42] <gaal> ?eval say "mmm" if "a" ~~ /a/

[23:43] <gaal> (evalbot's dead?)

[23:43] <putter> embedded or external parrot?

[23:43] <gaal> anymoose, it's late. see you tomorrow in releng!

[23:43] <gaal> zzZ &

[23:43] <putter> good night gaal &

[23:51] <svnbot6> r8654 | putter++ | AES/S29draft.pod - additional tweaks.

[23:52] <putter> luqui: should

[23:52] <putter> multi Array::grep (@values,   MatchTest $test   --> Lazy )

[23:52] <putter> instead be

[23:52] <putter> multi Array::grep (@values:   MatchTest $test   --> Lazy )

[23:52] <putter> ?

[23:59] *** scook0 joined
