[00:24] <bx420> Pope Advised Hawking Not to Study Origin of Universe

[00:31] *** hikozaemon joined
[00:41] *** lollan joined
[01:00] <QtPlatypus> bx420: Why is that news?

[01:00] <bx420> wrong windows sry

[01:00] <QtPlatypus> Ok

[01:02] <dduncan> seen audreyt

[01:02] <jabbot> dduncan: audreyt was seen 9 hours 29 minutes 11 seconds ago

[01:16] *** weinig|zzz__ is now known as weinig

[01:27] *** christopher joined
[01:41] <svnbot6> r10711 | Darren_Duncan++ | updated the README file about the 'Rosetta' Perl 6 library extension so to clarify that its otherwise-GPL license permits linking with software of other free licenses without 'infecting' the latter

[01:57] *** lisppaste3 joined
[02:32] *** kanru joined
[03:03] *** justatheory joined
[03:10] *** lambdabot joined
[04:11] *** mako132_ joined
[04:11] *** Southen_ joined
[04:11] *** kanru joined
[04:24] *** justatheory joined
[04:26] *** _SamB_ joined
[04:47] *** _SamB_ is now known as SamB

[05:03] *** kanru joined
[05:06] *** Khisanth joined
[05:22] *** christopher joined
[05:26] *** kattana_ joined
[05:29] *** hikozaem_ joined
[05:30] *** TimToady joined
[05:30] *** jiing joined
[05:30] *** xern joined
[06:24] *** Perl|z joined
[06:24] *** Perl|z left
[06:58] *** SM_ax joined
[07:07] *** kanru joined
[07:32] *** Aankhen`` joined
[07:58] *** drrho joined
[08:11] *** lisppaste3 joined
[08:18] <gaal> audreyt: ping

[08:18] *** Ymmv joined
[08:18] <audreyt> gaal: pong

[08:19] <gaal> hey. I'm fixing emit_yaml, but it's resisting treatment :)

[08:19] <audreyt> patch?

[08:19] <gaal> I've refactored the prim-filtering from GodeGen

[08:19] <gaal> patch coming up, sec

[08:20] <Alias_> aha!

[08:22] <audreyt> !aha

[08:22] <svnbot6> r10712 | audreyt++ | * Some more chglogging...

[08:22] <Alias_> audreyt: Can I borrow 30 seconds?

[08:22] <gaal> http://perlcabal.org/~gaal/tmp/emit_yaml.0.patch

[08:22] <Alias_> ---> #alias

[08:23] <gaal> test case: ./pugs -e 'say Pugs::Internals::emit_yaml(42)'

[08:23] <svnbot6> r10713 | audreyt++ | * Makefile.PL: don't bother rm Data/Yaml before a make,

[08:23] <svnbot6> r10713 | audreyt++ |   now that it's part of HsSyck

[08:23] <gaal> yay for r10713 :) about time

[08:25] <audreyt> heh :)

[08:26] <svnbot6> r10714 | audreyt++ | * Perl6::FAQ::FUD - slight stylistic cleanup.

[08:27] <gaal> so, how come filterPrim doesn't weed out $*OUT, $*IN, $*ERR in the Prim.hs case but does in GodeGen?

[08:27] <svnbot6> r10715 | audreyt++ | * $?SUBNAME is no more (not since tokyo hackathon); use

[08:27] <svnbot6> r10715 | audreyt++ |   &?ROUTINE.name instead.  Also &?SUB is now &?ROUTINE

[08:27] <svnbot6> r10715 | audreyt++ |   since it works in methods too.

[08:28] <audreyt> I... honestly don't remember

[08:28] <audreyt> I'll check after this talk

[08:29] <gaal> oh! any('good luck', 'enjoy the talk')

[08:30] <theorbtwo> "Have fun!" covers it, I think.

[08:31] <gaal> ever the polymorphic golfer, eh theorbtwo?

[08:31] * theorbtwo grins.

[08:32] * gaal goes wandering for a while &

[08:34] *** lisppaste3 joined
[08:49] <audreyt> takesako: I'm going to give ppencode talk today in NPW :)

[08:49] <audreyt> L10N'ing it to English

[08:50] *** chris2 joined
[08:59] *** YetAnotherEric joined
[09:01] *** YetAnotherEric left
[09:09] *** bjoern_ joined
[09:09] *** marmic joined
[09:14] *** kanru joined
[09:23] *** lambdabot joined
[09:24] *** dduncan left
[09:35] *** lambdabot joined
[09:43] *** f0rth joined
[09:50] *** f0rth joined
[10:03] *** buetow joined
[10:15] *** lumi joined
[10:25] *** nine joined
[10:39] *** szbalint joined
[11:04] *** ludan joined
[11:04] <ludan> hi

[11:32] *** ruoso joined
[11:52] *** jsiracusa joined
[11:59] *** weinig is now known as weinig|work

[12:11] *** bjoern_ joined
[12:17] *** datasieve joined
[12:22] *** cookys joined
[12:53] *** frederico joined
[12:54] <sahadev> hello, what's a good unicode font to see the rt.openfoundry.org pages properly? I am using Firefox 1.5.0.4 on Debian unstable. I did configure Firefox to display unicode chars (I can see devnagari and other indic characters), but i think i am missing some fonts.

[12:54] <sahadev> (sorry for asking a non-perl6 question)

[12:54] <audreyt> arphic fonts?

[12:55] <audreyt> or change pref to english...

[12:55] <audreyt> arphic-ttf

[12:55] <sahadev> ok. thanks. i'll try those.

[12:56] <audreyt> np :)

[12:57] <sahadev> hmm. changing language pref to English doesn't seem to help. at least on http://rt.openfoundry.org/Foundry/Trove/

[12:57] <lambdabot> The title of that page is "Project Directory -- OpenFoundry"

[12:57] <sahadev> i'll try installing the arphic font later.

[12:58] <audreyt> yeah, those projects are genuinely chinese-named...

[12:58] <sahadev> oh, i see :)

[12:58] <sahadev> http://whoswho.openfoundry.org/ too, it looks like

[12:58] <lambdabot> The title of that page is "自由軟體人才資料庫"

[12:59] <sahadev> even though i won't be able to read chinese characters, seeing them displayed properly (instead of boxes of hex codes) would make me feel better.

[13:01] <audreyt> first cut at the upcoming lightning talk (ported from takesako-san's yapc-asia talk): http://pugs.blogs.com/talks/npw06-ppencode.pdf

[13:01] <audreyt> going to be on air in ~1.5hr. feedback welcome :)

[13:05] <sahadev> i'll try not to bother you again on such trivial matters :)

[13:05] <sahadev> sorry wrong window

[13:06] <audreyt> nah, it's fine

[13:06] *** chris2 joined
[13:20] *** vel joined
[13:20] *** elmex joined
[13:21] *** christopher joined
[13:26] <Juerd> audreyt: I don't think punctuation has a plural

[13:32] *** vel6608 joined
[13:33] *** m4rkl4r joined
[13:39] *** fglock joined
[13:39] <kolibrie> audreyt: I got kind of lost without audio, but it looks humorous and fun

[13:40] <theorbtwo> Puncuation is a class; "a piece of puncuation" or "several pieces of puncuation" is probably what you want.

[13:41] *** m4rkl4r left
[13:42] <kolibrie> but with the 't': punctuation

[13:42] <theorbtwo> Yeah.  I can do grammar.  Spelling is quite another matter.

[13:46] <audreyt> ok.

[13:47] <audreyt> reuploading

[13:47] <audreyt> kolibrie: yeah, this is a 5-min no-content-at-all talk :)

[13:47] *** amnesiac joined
[13:48] <theorbtwo> Yeah, I should probably read the talk before making random grammar points.

[13:48] <audreyt> reuploaded

[13:53] <fglock> audreyt: the same things that I've been implementing with p5, could be implemented in p6 (lazy lists, rules) - but is it worth it, since this things are going to exist in Parrot?

[13:53] <fglock> is anyone implementing lazy lists in parrot?

[13:55] <audreyt> not afaics

[13:55] <audreyt> eventually having them in p6 = useful

[13:56] <audreyt> meantime, p5 runtime is more strategically important imho

[13:58] *** lollan joined
[14:08] *** rzoz joined
[14:08] <sahadev> audreyt: slide 14 shows up empty in my pdf reader (xpdf). is it intentional?

[14:09] <audreyt> it's a bug in keynote's export I think

[14:09] <fglock> is there any cpan module that permits to override or tie perl5 slicing? (I want to make lazy slices)

[14:09] <audreyt> ok, the talk is coming :)

[14:09] <audreyt> bbiab

[14:10] <xerox> Any audio/video stream? (;

[14:19] *** hexmode joined
[14:25] <kolibrie> any ideas about this?

[14:25] <kolibrie> Invoking Parrot to generate runtime/parrot/include/config.fpmc --cross your fingers

[14:25] <kolibrie> ./miniparrot config_lib.pasm > runtime/parrot/include/config.fpmc

[14:25] <kolibrie> /bin/sh: line 1: 30125 Segmentation fault      ./miniparrot config_lib.pasm >runtime/parrot/include/config.fpmc

[14:25] <kolibrie> make: *** [runtime/parrot/include/config.fpmc] Error 139

[14:26] <kolibrie> it's been months since I last compiled parrot

[14:32] *** Aankh|Clone joined
[14:34] *** lambdabot joined
[14:47] <kolibrie> hmm, this is weird, too: ./miniparrot -V says this is parrot version 0.4.4-devel (r12952), but the runtime is revision 11552, as well as the Configure.pl

[14:48] <kolibrie> I did an svn update

[14:48] <kolibrie> something else I should try?

[14:52] *** penk joined
[14:53] <fglock> kolibrie: maybe try the cpan version. also, 'make clean'

[14:54] <kolibrie> fglock: I did 'make realclean' before 'svn update'.

[14:54] <kolibrie> I'll try re-checking out in a different directory

[15:02] <fglock> kolibrie: no errors here, miniparrot says 0.4.4

[15:03] <kolibrie> hmm, same problems with my new checkout from https://svn.perl.org/parrot/trunk

[15:04] <kolibrie> fglock: are you using the subversion copy, or CPAN?

[15:06] <audreyt> takesako: the talk was very well received (again). thanks you :)

[15:08] *** iblechbot joined
[15:08] <fglock> kolibrie: svn version, Ubuntu 6.06

[15:09] <audreyt> takesako: in addition of the .pdf, here's .ppt for you: http://pugs.blogs.com/talks/npw06-ppencode.ppt

[15:09] <theorbtwo> So how'd the talk go?

[15:10] <audreyt> well, people seems to be happy and laughing a lot

[15:10] <theorbtwo> Cool.

[15:10] <leo> kolibrie: do you have some installed copy of parrot about?

[15:11] <kolibrie> leo: looks like I have one in /usr/local/bin

[15:12] <leo> ok - pleaese rm -rf the installed parrot and try again, it's likely the reason for the failure

[15:12] <kolibrie> oh, it's just a symlink to my build dir

[15:13] <kolibrie> leo: should I still remove it?

[15:13] <leo> yes

[15:13] <leo> also check for installed headers please

[15:14] <kolibrie> whereabouts?  /usr/local/lib?

[15:14] <leo> likely, yep

[15:14] <leo> include

[15:15] <kolibrie> libparrot.so.0.4.1

[15:15] <leo> locate parrot.h

[15:15] <leo> yeah - that could interfer

[15:16] <kolibrie> ok, wiped out parrot in lib and include

[15:17] <kolibrie> do I need to make clean before making again?

[15:17] <leo> yes please

[15:18] * kolibrie crossed fingers

[15:21] <kolibrie> yipee, no errors

[15:21] <kolibrie> thank you leo, fglock

[15:21] <leo> welcome

[15:27] <fglock> leo: is there an example for writing a pmc using parrot?

[15:28] <fglock> I'm considering porting lazy arrays

[15:29] <leo> these should better be written in .c but you can implement almost all in .pir too

[15:31] <fglock> maybe it could be a plain object instead of a pmc? I'm reading the other pmc source files

[15:31] *** bernhard joined
[15:31] <fglock> is there much speed difference?

[15:32] <leo> [example] pge's Match object implements a lot of functionality

[15:33] <leo> compilers/pge/PGE/Match.pir

[15:34] <leo> see vtable methods e.g. __get_bool or __get_string and keyed access like __get_pmc_keyed_int

[15:36] <fglock> will look - thanks!

[15:36] <leo> fglock: see also lazy.tgz on feather in my home dir ~lt

[15:37] <fglock> ok

[15:37] *** _bernhard joined
[15:37] <leo> # some old experiments w a Lazy thingy

[15:39] <fglock> bbiab &

[15:39] *** buetow joined
[15:42] *** Eimi joined
[15:45] <sahadev> src/Pugs/Monads.hs:275:12: parse error (possibly incorrect indentation)

[15:45] <sahadev> Fix:

[15:45] <sahadev> -                [ genSym "&?ROUTINE" (codeRef (orig sub))

[15:45] <sahadev> +                [ genSym "&?ROUTINE" (codeRef (orig sub)) ]

[15:46] <sahadev> is that the right fix? i have zero haskell knowledge

[15:46] <xerox> Possibly. The paren closes the list.

[15:46] <sahadev> it does compile :)

[15:50] <sahadev> also:  src/Pugs/Parser.hs:635:8:

[15:50] <sahadev>     The last statement in a 'do' construct must be an expression

[15:51] *** meppl joined
[15:59] *** justatheory joined
[16:11] <xerox> sahadev: how does the code look like there?

[16:13] <sahadev>    631  rulePerlVersion = rule "perl version" $ do

[16:13] <sahadev>    632      optional (string "v" <|> string "Perl-")

[16:13] <sahadev>    633      version <- many1 (choice [ digit, char '.' ])

[16:13] <sahadev>    634      optional $ do

[16:13] <sahadev>    635          variant <- ruleAuthorPart

[16:13] <sahadev>    636          {-

[16:13] <sahadev>    637          when (map toLower variant /= "pugs") $ do

[16:13] <sahadev>    638              pos <- getPosition

[16:13] <sahadev>    639              error $ "Perl implementation " ++ tail variant ++ " required--this is only Pugs v" ++ versnum ++ ", stopped at " ++ (show pos)

[16:13] <sahadev>    640          -}

[16:13] <sahadev>    641      return version

[16:13] <sahadev> error is on line 635

[16:14] <xerox> indent the `return version' as `variant' is.

[16:14] <xerox> Hmm no.

[16:14] <xerox> Move the {- up two lines.

[16:14] <xerox> (So that it is between `version..' and `optional..'

[16:15] <xerox> )

[16:15] <TimToady> according to svn diff, that chunk replaced a line which read "optional ruleAuthorPart

[16:15] <TimToady> maybe we should just revert it for now

[16:16] <xerox> I do not know the semantics, the fact is that `variant' isn't used this way.

[16:18] <TimToady> svn blames audreyt, so I think we can let her deal with it later.  I'll check in a fix.

[16:23] <audreyt> moose.

[16:23] <audreyt> sorry about that

[16:24] <svnbot6> r10716 | lwall++ | Hacking around some build-breakers.

[16:25] <TimToady> hi audreyt, I'm back from indiana...

[16:25] <audreyt> hi!

[16:25] <audreyt> and I'm done with NPW

[16:25] <audreyt> so I'm good to release pugs tomorrow :D

[16:25] <TimToady> by the way, my ($a) = x() should apply list context to x().

[16:25] <audreyt> yes. but should

[16:25] <audreyt> ($a) = x()

[16:25] <audreyt> ?

[16:26] <TimToady> yes

[16:26] <audreyt> so no ($a,) kluges? hm

[16:26] <TimToady> circumfix:<( )> is not in the list of simple ops

[16:26] <audreyt> ok. :)

[16:26] <TimToady> or we just special-case the outer ones

[16:26] <audreyt> otoh, I was imagining circ() to be a macro

[16:26] <audreyt> that returns identity

[16:26] <audreyt> but perhaps not

[16:27] <audreyt> ok, please fix the test again

[16:27] <svnbot6> r10717 | audreyt++ | * Fix syntax error.  Moral: _always_ test and commit

[16:27] <svnbot6> r10717 | audreyt++ |   from sleep, instead of waiting until the morning to commit it

[16:27] <svnbot6> r10717 | audreyt++ |   without testing.

[16:27] <audreyt> I'll see how to make it pass

[16:27] <audreyt> btw, I think the (1.3 % 1) == 0.3 behaviour is really worth keeping

[16:27] <audreyt> bc and ruby both has it at 0.3

[16:27] <audreyt> python has it at 0.30000000000004

[16:27] <TimToady> make mod the integer version?

[16:28] <audreyt> yes

[16:28] <TimToady> and rem the other thing

[16:28] <audreyt> and div the integer version if you want

[16:28] <audreyt> yeah

[16:28] <TimToady> shades of Ada

[16:28] <audreyt> rem echo "Hello from .bat world"

[16:28] <audreyt> indeed, Hs also does it that way

[16:28] <audreyt> I've been reading at the new Ada spec

[16:28] <audreyt> they've also adopted dot

[16:28] <audreyt> it amazes me how much of Perl6 is from Ada :)

[16:29] <TimToady> shh

[16:29] <audreyt> almost as much as how Ruby is repackaged Smalltalk

[16:29] <audreyt> :D

[16:29] <TimToady> It all started with =>

[16:31] <audreyt> nod

[16:31] <audreyt> people seems to like Moose

[16:33] <TimToady> I think your fix might have collided with my fix...

[16:33] <audreyt> indeed...

[16:33] <audreyt> so much for smart merging

[16:34] <audreyt> we really need Smalltalk-caliber semantic mergers

[16:34] <svnbot6> r10718 | audreyt++ | * uncollide

[16:35] <TimToady> possibly also src/Pugs/Parser.hs

[16:38] <audreyt> done

[16:38] <svnbot6> r10719 | audreyt++ | * uncollide even more.

[16:38] <svnbot6> r10720 | audreyt++ | * Test.pm: Switch to &?ROUTINE.name instead of $?SUBNAME.

[16:38] <Juerd> Ooh, nice change

[16:38] <Juerd> I like .name

[16:39] <TimToady> also getting:

[16:39] <TimToady> make[1]: Entering directory `/home/larry/pugs/ext/Perl6-Grammar'

[16:39] <TimToady> make[1]: *** No rule to make target `lib/pugs', needed by `pm_to_blib'.  Stop.

[16:39] <svnbot6> r10721 | audreyt++ | * more s/&?SUB/&?ROUTINE/.

[16:39] <TimToady> don't know if it's related

[16:39] *** Limbic_Region joined
[16:40] <Juerd> So do we write "routine foo { ... }" instead of "sub foo { ... }" now?

[16:40] <Juerd> ;)

[16:41] <audreyt> Juerd: no, but I wonder if &?SUB and &?METHOD gives you more specific foo.

[16:41] <TimToady> no, we write "mud"

[16:41] <audreyt> much like &?BLOCK and &?ROUTINE can be the same thing.

[16:41] <TimToady> I guess it'd be "mub"

[16:41] <Juerd> audreyt: Shouldn't it all be CLOSURE? :)

[16:41] <Juerd> or CODE

[16:41] <Juerd> :)

[16:42] <audreyt> it's &?BLOCK for usercode

[16:42] <audreyt> very hard to write a &?CODE literal without a scopee

[16:42] <audreyt> s/scopee/scope/

[16:43] <audreyt> (btw, rm blib6/lib/Test.pm.yml after r10721)

[16:43] <audreyt> TimToady: I can't dup the lib/pugs bug here, weird

[16:43] <audreyt> bbiab...

[16:45] <svnbot6> r10722 | lwall++ | ($x) = should imply list context

[16:47] <audreyt> TimToady: so foo(1) doesn't trigger circumfix() right?

[16:47] <TimToady> right

[16:47] <TimToady> but we should probably allow inner (2 + 3) * 4 parens.

[16:48] <TimToady> my theory on my error is that I had a symlink pugs down in that directory. realclean etc. now

[16:50] <TimToady> so outer () implies list under the theory that they would have no other reason for putting the parens there (other than cargo culting)

[16:51] <TimToady> and given that it's a frequent idiom in P5, I think we should keep it.

[16:51] <TimToady> will patch S3

[16:51] <audreyt> agreed

[16:51] <audreyt> TimToady++

[16:56] <TimToady> okay, fixed.  Just an added line in the SIMPLE list, basically.

[17:04] <TimToady> smoking now.  it was the symlink, plus the fact that I run with . at the end of PATH.

[17:04] <TimToady> maybe things that add to PATH should do so before any .

[17:04] <audreyt> ah. that explains

[17:04] <TimToady> or just strip it

[17:05] <TimToady> where are you in the world now?

[17:05] <audreyt> Oslo

[17:05] <TimToady> so you don't know whether you're coming or going by now, I imagine, jet-lag wize

[17:06] <TimToady> wise, even

[17:07] <audreyt> well tomorrow I'll fly back to taiwan

[17:07] <audreyt> sleep in the airport hotel for 7hr

[17:07] <audreyt> then fly to Seattl

[17:07] <audreyt> e

[17:08] <TimToady> there should be a unicode symbol for jetlag.

[17:10] <audreyt> heh :)

[17:10] <TimToady> well, off to the shower for me...

[17:11] <TimToady> &

[17:28] <audreyt> dinner, be back in ~2hr maybe

[17:28] <audreyt> &

[17:55] *** vytautas joined
[18:22] <Juerd> Concert: Perl is becoming a lot like Dutch, with language rules being bullet pointed lists forming groups and exception groups.

[18:22] <Juerd> s/Concert/Concern/

[18:23] <Juerd> Dutch is a very hard language to learn because of this. I'm not very happy with the "simple"ness things, because while obviously many things are considered simple, it makes the language exactly the opposite: complex.

[18:23] <Juerd> Is there perhaps a simpler description? A philosophy rather than a bullet point list of examples?

[18:25] <ingy> Juerd: Perl is simply complex

[18:26] <ingy> TimToady: are you heading to yapc?

[18:27] <ingy> and audreyt: when do you land here in Seattle? I could pick you up from the airport if you'd like...

[18:29] *** fglock joined
[18:32] <audreyt> ingy: purr

[18:33] <audreyt> I'm @ dinner

[18:34] <audreyt> ingy: 19jun  7:20p

[18:34] <audreyt> pickup would be appreciated... I wonder if MS will send people to pickup

[18:34] <audreyt> but probably not

[18:35] *** bpederse joined
[18:36] <Juerd> ingy: Complex is okay, but not too much.

[18:36] <Juerd> This feels like a little too much complexity, from which we don't gain much.

[18:38] <TimToady> Juerd: yes, the philosophy of the "simple" stuff is that it dwims based only on the knowledge of standard Perl operators, and most of the time it doesn't matter anyway, since the simple things would produce a scalar value in list context anyway.

[18:38] <TimToady> we're just trying to document what people would normally expect to be sure of.

[18:38] <TimToady> if you're unsure, you should say ()= or

[18:39] <audreyt> TimToady: the change I had to do to Net::IRC is kinda sad

[18:39] <TimToady> $x[+...] anywa

[18:39] <audreyt>         %channels{normalize($chan)}<topic> = $topic;

[18:39] <TimToady> *anyway

[18:39] <audreyt> it's a slice

[18:39] <audreyt> and 1-elem slice can't be derefed as a hash for <topic>

[18:39] <TimToady> normalize is list sensitive?

[18:40] <audreyt> no, it returns one thing

[18:40] <audreyt> but it's still a one-slice

[18:40] <audreyt> a List

[18:40] <audreyt> consider %channels{normalize($chan)}[0]

[18:40] <audreyt> if it's a slice it should return the first thing

[18:40] <audreyt> if it's not a slice then it derefs it as an array

[18:40] <audreyt> semantically very different

[18:40] <audreyt> basd on the slice/item info alone

[18:40] <audreyt> (not saying it should change, just pointing out a potential case of confusion)

[18:41] <TimToady> does it carp at compile time?

[18:42] <audreyt> no

[18:42] <audreyt> for the .<topic> case probably yes

[18:42] <audreyt> but for the .[0] case

[18:42] <audreyt> @foo[func()][0]

[18:42] <lambdabot> Unknown command, try @list

[18:43] <audreyt> it's almost always a mistake

[18:43] <audreyt> but sometime it's not

[18:43] <audreyt> sometime func() returns 3 things instead of 1

[18:43] <audreyt> and you really want the slice

[18:43] <audreyt> that's the place where it worries me

[18:43] <audreyt> we can (and should) get parsetime warnings going on the slice-deref-as-hash case.

[18:43] <audreyt> but slice-deref-as-array is normal and should be allowed...

[18:44] <audreyt> thoughts? :)

[18:45] <gaal> hey, can we have a divMod in Perl 6? it's really useful and very often cheap in the runcore

[18:46] <gaal> @t divMod

[18:46] <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v

[18:46] <gaal> @type divMod

[18:46] <lambdabot> forall a. (Integral a) => a -> a -> (a, a)

[18:46] <gaal> returns a tuple of the division results, whole and remainder.

[18:46] <audreyt> ruby and python has it too.

[18:46] <audreyt> same named

[18:46] *** lisppaste3 joined
[18:47] <Juerd> TimToady: The difference could use some more explanation. I'm seeing a list that makes the definition, where I think it would be more useful to let that list be a list of *examples* of how a definition in English works out.

[18:47] <svnbot6> r10723 | audreyt++ | * Prim.hs: Use "length" instead of "last" to force evaluation

[18:47] <svnbot6> r10723 | audreyt++ |   for the entire list, otherwise we get a "Prelude: List.last"

[18:47] <svnbot6> r10723 | audreyt++ |   error on the case of slurping in an empty file in list context.

[18:48] <gaal> oh, did you get a chance to look at emit_yaml?

[18:48] <Juerd> TimToady: And the way to disambiguate (to force a certain interpretation) should be mentioned in that section too, I think

[18:48] <TimToady> Juerd: the specs aren't intended to be tutorials.

[18:48] <Juerd> TimToady: Granted, but the specs are intended to be understood and feel solid, I hope?

[18:49] <audreyt> gaal: no, sadly, my talk turned out to e the lst one in the conf

[18:49] <audreyt> and after that we went to dinner

[18:49] <audreyt> I'm still at (the head of) dinner table

[18:49] <audreyt> typing madly for other people's entertainment

[18:49] <audreyt> will definitely look at it tomorrow. :/

[18:49] <audreyt> (or when I get back to hotel tonight if it's not too late)

[18:50] <ingy> audreyt!!

[18:51] <Juerd> TimToady: I strongly believe in  "if you can't explain it in a simple way, the design probably sucks" and "the best definition is a short definition" and "every extra word you type is another chance to screw up"

[18:51] <audreyt> ingy: yo

[18:52] <Juerd> TimToady: Even though I realise that those can clash heavily :)

[18:52] <ingy> audreyt: I'll grab you. email your itinerary

[18:52] <audreyt> ingy: it's quite convoluted

[18:53] <audreyt> I'll fwd you my arrival-to-seattle itinerary

[18:53] <ingy> that's what I mean

[18:53] <audreyt> and omit the seattle->portland->seattle->chicago->boston->seattle->portland->seattle part

[18:53] <ingy> I just want the flight number in my email

[18:53] <audreyt> done.

[18:54] <audreyt> they apparently forgot my salad whilst they serve everyone else

[18:54] <audreyt> so I'm still here typing...

[18:54] <ingy> hmm, what are you doing in Portland?

[18:54] <audreyt> speaking to .pm

[18:54] <audreyt> and also to Galois

[18:54] <audreyt> one each day of Fri and Sat

[18:54] <audreyt> and then fly back to Sea on Sun morning

[18:54] <ingy> huh, so how long in the sea/pdx/sea stay

[18:54] <audreyt> and then fly to Chicago immediately

[18:55] <audreyt> see above

[18:55] <audreyt> I got a fullflex for Sea<->Por

[18:55] <audreyt> so it's flex

[18:55] <TimToady> I wonder if we could scrap the dwim and steal a special slice form.

[18:55] <audreyt> but also full.

[18:55] <audreyt> TimToady: that'd fix it.

[18:55] <TimToady> %hash(SLICE) or @array(SLICE)

[18:55] <audreyt> nod.

[18:55] <audreyt> it'd be happy. I think.

[18:55] <TimToady> would preclude calling a func on such an object, except as .()

[18:55] <audreyt> not entirely sure

[18:55] <TimToady> maybe

[18:55] <audreyt> er

[18:56] <audreyt> it _is_ calling a func on such an object

[18:56] <audreyt> Hash and Array would do Code role by filing in slice as default impl.

[18:56] <ingy> audreyt: I have a big house to myself these days

[18:56] <audreyt> ooh.

[18:56] <ingy> so max the flex

[18:56] <audreyt> food here, bbiab

[18:56] <audreyt> :)

[18:56] <TimToady> happy herring

[19:04] <gaal> audreyt: no problem :) I just think we need to fix it before the release

[19:04] <gaal> Galois is the company that has all those .hs programmers, right?

[19:05] *** cdpruden joined
[19:09] *** Aankh|Clone is now known as Aankhen``

[19:11] *** Kattana joined
[19:11] * gaal lols at "pair management"

[19:12] <audreyt> gaal: we will

[19:12] <audreyt> yes

[19:13] <gaal> are those two characters really pronounced "otori tan"? that's hightly compressed!

[19:15] <audreyt> yeah :)

[19:15] <audreyt> and those two chars are in fact my chinese name.

[19:15] <TimToady> 囮              おとり          otori           lure; decoy

[19:15] <TimToady> ?

[19:15] <audreyt> and -tan means... cute little girl

[19:15] <audreyt> (in japanese)

[19:15] <gaal> otori is phoenix, isn't it?

[19:15] <TimToady> oh, using non-Hepburn notation

[19:15] <audreyt> so it's pretty good trilingual coincidential interlocking translation

[19:15] <audreyt> yes.

[19:16] <gaal> i'm just surprised that a glyph can have so many syllables

[19:17] <TimToady> Japanese maps kanji to both chinese monosyllables (usually) as well as native polysyllables.

[19:17] <gaal> in the spoken rendition. in Mandarin, is it sometimes the case that a character is two?

[19:17] <TimToady> well, now I'm being hauled off to lunch... &

[19:18] <Juerd> Hmm... Perl certification spam

[19:20] <audreyt> gaal: no, never

[19:20] <audreyt> it's always monosyllabic

[19:20] <audreyt> which allegedly makes it a more ideal programming language according to Guy Steelr

[19:21] <audreyt> lamb is here, bbiab again

[19:21] <audreyt> &

[19:24] <xerox> gaal: yes, Galois is Haskell powered :)

[19:25] <gaal> <audrey xerox> >>: cool

[19:25] * xerox falls from the chair

[19:25] * xerox can't wait to see what's in the Google gift pack, yay....

[19:26] * xerox boings randomly

[19:43] <gaal> so, what should p6 divmod return in scalar context?

[19:44] <gaal> assuming it exists :)

[19:50] *** weinig|work is now known as weinig

[19:54] *** Zemyla joined
[19:54] <Zemyla> Holy crap, Dr. Michaud is here!

[20:05] <audreyt> greetings, Zemyla.

[20:06] <audreyt> gaal: in scalar context it returns a List object ;)

[20:06] <audreyt> I think.

[20:11] <svnbot6> r10724 | audreyt++ | * ditto the s/last/length/ fix in Prim.hs for readline().

[20:18] <kolibrie> I just built pugs r10722, which worked fine, but make install says Could not find module 'Data.ByteString'

[20:19] <kolibrie> and make exits with Error 2

[20:23] <audreyt> mmm weird.

[20:23] <audreyt> did you makeinstall as root?

[20:23] <kolibrie> yes

[20:23] <audreyt> did it rerun Makefile.PL as root?

[20:23] <audreyt> (trying to duplicate here now)

[20:24] <kolibrie> not sure if in reran Makefile.PL

[20:24] <audreyt> it worksforme

[20:24] <audreyt> try chown everything to yourself again recursively

[20:25] <audreyt> and reinstall as root?

[20:25] <audreyt> (or give me a shell tomorrow)

[20:25] * kolibrie tries

[20:26] <kolibrie> still same error

[20:27] <audreyt> which GHC version?

[20:28] <kolibrie> 6.4.1

[20:28] <audreyt> try hack Makefile by hand

[20:28] <audreyt> look for

[20:28] <audreyt>         $(PERLRUN) util/ghc_setup.pl copy --copy-prefix=$(DESTDIR)

[20:28] <audreyt> and change it to

[20:28] <audreyt> copy --user

[20:28] <audreyt> i.e.

[20:28] <audreyt>         $(PERLRUN) util/ghc_setup.pl copy --user --copy-prefix=$(DESTDIR)

[20:28] <audreyt> and see if it helps

[20:29] <audreyt> I'm not sure what's going on...

[20:29] <audreyt> what's your cabal version as listed by ghc-pkg list ?

[20:30] <kolibrie> ghc-pkg describe cabal: cannot find package cabal

[20:30] <audreyt> Cabal

[20:31] <audreyt> not cabal

[20:31] <kolibrie> version 1.0

[20:31] <audreyt> mm.

[20:31] <audreyt> do you have easy access to 6.4.2? if not don't worry I'll still fix it.

[20:32] <audreyt> also try the --user

[20:32] <kolibrie> using debian unstable

[20:33] <kolibrie> don't see 6.4.2 there yet

[20:33] <kolibrie> will try the --user fix in Makefile

[20:35] <kolibrie> oh, and every time I run make install, I have to reset my terminal because no characters show up when I type (this is not something new)

[20:36] <audreyt> wow.

[20:36] <audreyt> hm.

[20:36] <audreyt> if the fix doesn't work for you, maybe try upgrading your Cabal?

[20:37] <audreyt> ( http://www.haskell.org/cabal/release/cabal-1.1.4/cabal-1.1.4.tar.gz )

[20:37] <kolibrie> the --user thing didn't change anything

[20:38] <audreyt> k.

[20:39] *** prozessor13 joined
[20:43] <gaal> should I make divmod infix or divmod($a,$b)?

[20:43] <TimToady> func is fine

[20:44] <gaal> ok. I'm actually making it equivalent to quotRem, which is the non-Integral version.

[20:44] <gaal> but we can still call it divmod, right? :)

[20:45] <TimToady> hmm, we were just about to make div and mod the integer versions of %

[20:45] <TimToady> and % rather

[20:45] <TimToady> so I think divmod should integerize and we should have quotrem separately

[20:45] <gaal> okay, no prob

[20:46] <pasteling> "kolibrie" at 66.239.158.2 pasted "make install log, in case audreyt is interested" (141 lines, 9.6K) at http://sial.org/pbot/17784

[20:47] <gaal> actually I'm wrong, quot in Haskell is a modulus truncated towards zero.

[20:47] <audreyt> sorry, it's getting to 11pm here, my brain is shutting down (as on .tw timezone it's 5am)

[20:47] <audreyt> but 1)it's still bright outside and 2)we're _still_ having dinner.

[20:47] <kolibrie> audreyt: no hurry

[20:47] <TimToady> still thinking about slices...

[20:48] <TimToady> and whether we still allow [1,2,3] as synonym for (1,2,3)

[20:48] <audreyt> not synonyms...

[20:48] <TimToady> effectively

[20:48] <audreyt> only synonyms at rhs scalar cxt

[20:48] <audreyt> and in tokyo we cancelled that

[20:48] <audreyt> $a := [1,2,3]; $a.push(4); # fine

[20:48] <TimToady> I meant as lvalue

[20:48] <audreyt> $a := (1,2,3); $a.push(4); # err

[20:48] <audreyt> ah.

[20:49] <TimToady> no, I'm talking about .() and .[] not bare forms

[20:49] <audreyt> oh ok.

[20:49] <audreyt> well, [] always scalar and () always list worksforme.

[20:49] <audreyt> alternatives being [()] and [,]

[20:50] <audreyt> I think the cleanest treatment of @a[1,2,3] is just to err out and tell user to write as @a(1,2,3)

[20:50] <audreyt> maybe.

[20:50] <TimToady> I'm just thinking if an object has both Array interface and Code, then we don't have .() available

[20:50] <TimToady> and so there has to be a .[1,2,3] form

[20:50] <audreyt> well we can also say that it is parsed as a list always

[20:51] <audreyt> but actually does not do slice if the inner thing returns 1 thing.

[20:51] <audreyt> that is

[20:51] <audreyt> $a[f()][0]

[20:51] <audreyt> if f returns a scalar then it's a [0] on the scalar

[20:51] <audreyt> if f returns a list then it's a [0] on that slice.

[20:51] <audreyt> and listcxt is only parselevel

[20:51] <audreyt> and if f want to return a 1slice they have to return (1,)

[20:51] <audreyt> or write

[20:51] <audreyt> return (1)

[20:52] <audreyt> which would be a 1slice.

[20:52] <audreyt> but

[20:52] <audreyt> return(1) and return 1

[20:52] <audreyt> are both 1scalar

[20:52] <audreyt> I think it's rather more intuitive and does not take the .() form out of reach

[20:52] <audreyt> since .() currently suggests Code much more than it suggests list

[20:53] <audreyt> that is, we go back to your decouple idea

[20:53] <audreyt> the SIMPLE is always just parselevel

[20:53] <audreyt> and the actual interpretation of lhs depends on the runtime evaluated expr

[20:53] <audreyt> which for SIMPLE we know it's gonna be scalar

[20:53] <audreyt> but for non-simple it may still be a scalar at runtime

[20:54] <TimToady> and .[$x,] or .[($x)] is the escape valve to force list.

[20:55] <TimToady> even if one element, if it matters.

[20:55] <audreyt> aye.

[20:55] <TimToady> does it have a run-time performance hit, I wonder...

[20:55] <TimToady> for SIMPLE, I guess not.

[20:55] <audreyt> not for SIMPLE

[20:56] <audreyt> and for non-simple, well, yes, but it's worthit.

[20:56] <TimToady> *n*o*d*

[20:56] <gaal> @hoogle (a,a) -> (a -> b) -> (b,b)

[20:56] <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)

[20:56] <gaal> err, no

[20:56] <audreyt> @djinn (a,a) -> (a->b) -> (b,b)

[20:56] <lambdabot> f (_, a) b = (b a, b a)

[20:56] <audreyt> heh, not helpful

[20:56] <audreyt> @djinn (a -> b) -> [a] -> [b]

[20:57] <lambdabot> -- f cannot be realized.

[20:57] <gaal> @djinn (a,a) -> [a]

[20:57] <lambdabot> -- f cannot be realized.

[20:57] <gaal> @hoogle (a,a) -> [a]

[20:57] <lambdabot> No matches, try a more general search

[20:58] <gaal> @hoogle (a,a) -> [b]

[20:58] <lambdabot> No matches, try a more general search

[20:58] <xerox> It doesn't know about lists.

[20:58] <xerox> (Djinn, that is.)

[20:58] <gaal> @hoogle Confused a, Unconfused b => a -> b

[20:58] <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a

[20:58] <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()

[20:58] <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()

[20:59] <gaal> wow

[20:59] <xerox> Hoogle is a bit b0rked :)

[20:59] <gaal> I just proved it's unsafe to understand haskell?

[20:59] <xerox> No way.

[21:00] <gaal> a -> b doesn't sound very sound to me :)

[21:00] <audreyt> well, throwError is exactly what that does :)

[21:00] <gaal> unless you stipulate that you can otherwise proove that confusion encapsulates intrinsically the source of unconfusion.

[21:01] <gaal> s/oo/o/

[21:01] <xerox> Your function is:

[21:01] <audreyt> TimToady: please put in speclang, if possible, once you've given it some thought, so I can pickit up tomorrow and do a release :)

[21:01] <xerox> join (***) :: (a,a) -> (a -> b) -> (b,b)

[21:01] <TimToady> k

[21:02] <gaal> whee, now I'm seeing stars

[21:02] <xerox> (-:

[21:02] *** fglock left
[21:02] <gaal> @type join

[21:02] <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a

[21:02] <gaal> @type (***)

[21:02] <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')

[21:02] * xerox grins evilly

[21:03] <gaal> * -> * eh. I'd say, "how unkind", except kind is exactly what that is

[21:03] <xerox> Hint: it uses the same type constructor in the m and a tyvar instances :)

[21:03] <xerox> (Our code, that is.

[21:03] <xerox> )

[21:04] <gaal> I think I'll go with the ungolfy pattern match and longhand for now... :)

[21:04] <xerox> > join (*) 2

[21:04] <lambdabot>  4

[21:05] <xerox> > ((+1) *** (*2)) 2

[21:05] <lambdabot>  add an instance declaration for (Num (b, b'))

[21:05] <xerox> > ((+1) *** (*2)) (1,2)

[21:05] <lambdabot>  (2,4)

[21:05] <xerox> Sorry.

[21:05] <gaal> > ((+1) *** (*2)) (7, 13)

[21:06] <lambdabot>  (8,26)

[21:06] <xerox> instance Monad ((->) e) where join f x = f x x ...

[21:07] <xerox> instance Arrow (->) where

[21:07] <xerox>  (f *** g) (x,y) = (f x,g y)

[21:07] <xerox>  (f &&& g) x     = (f x,g x)

[21:07] <xerox>  first f (x,y)   = (f x,y)

[21:07] <xerox>  second f (x,y)  = (x,f y)

[21:07] <xerox>  (>>>) = flip (.)

[21:07] <xerox> There you go.

[21:08] <gaal> the problem with this is that it is not utterly incomprehensible

[21:08] <xerox> Is it?

[21:08] <xerox> They are just combinators.

[21:09] <gaal> yeah, so I'm going to try to understand them and thus lose sleep. hence, problem

[21:11] <audreyt> dinner finally going to over

[21:11] <audreyt> bbl :) &

[21:12] *** larsen joined
[21:13] <xerox> gaal - Sorry, I don't understand. The definitions aren't clear? (***) is an infix combinator which takes two functions, f, and g, and takes a pair. It applies the first function to the first element of the pair, and the second function to the second element.

[21:13] <gaal> in "instance Monad ((->) e)", what's e?

[21:13] <xerox> join takes a function and an argument, and applies the same argument two times to the function.

[21:13] <xerox> One uses e instead of a because the monad is also known as the Reader Monad. And the Reader Monad is used for Enviroments, mostly.

[21:14] <gaal> and why does *** need to be an instance for (->)? I don't grok ->-as-a-type yet.

[21:14] <xerox> > runReader (do {env <- get; return (env+2)}) 1

[21:14] <lambdabot>  add an instance declaration for (MonadState s (Reader r))

[21:14] <lambdabot>   In a 'do' exp...

[21:14] <xerox> Gasp.

[21:14] <xerox> > runReader (do {env <- ask; return (env+2)}) 1

[21:14] <lambdabot>  3

[21:14] <xerox> Sorry.

[21:14] <gaal> you and audreyt explained that to me a few days ago, but I didn't get it yet

[21:14] <xerox> Oh.

[21:15] <xerox> (->) is the type constructor of functions.

[21:15] <gaal> please keep going :)

[21:15] <xerox> It has this strange kind:

[21:15] <xerox> ?kind (->)

[21:15] <lambdabot> ?? -> ? -> *

[21:15] <xerox> Nevermind the interrobangs..

[21:15] <xerox> It takes a type, another type, and returns a type.

[21:15] <gaal> remind me what ?? and ? mean in kinds?

[21:15] <gaal> ah

[21:16] <xerox> (??, ?, are GHC-specific notation for boxed/unboxed types or something.)

[21:16] <xerox> Anyway.

[21:16] <xerox> If you feed a type, say Int, and another type, say Char, to the type constructor (->) it will return you |Int -> Char|, a type.

[21:17] <gaal> all right. how's ((->) e) equivalent to the Reader monad again?

[21:17] <xerox> Okay!

[21:17] <gaal> yup

[21:17] <xerox> It comes directly from the definition of that monad, that is:

[21:17] <xerox> data Reader e a = Reader { runReader :: e -> a }

[21:17] <xerox> Are you familiar with this syntax?

[21:17] <gaal> ah!

[21:17] <gaal> yes.

[21:18] <xerox> class (Monad m) => MonadReader m e where

[21:18] <xerox>    ask :: m e

[21:18] <xerox>    local :: (e -> e) -> m e

[21:19] <gaal> yes, I know this part

[21:20] <xerox> Some interesting types under the Reader are those of (>>=), ap, join, fmap/liftM, liftM2, liftM*, ...

[21:20] <gaal> so what's the relationship between reader and that arrow business? or in the arrow interpretation is this no longer a reader?

[21:20] <xerox> The (->) Arrow is not a Reader Monad, nope.

[21:20] <xerox> Every Monad is an Arrow, not every Arrow is a Monad. (->) is an Arrow.

[21:21] <xerox> (Arrows are required to hold quite more laws, for one.)

[21:21] <gaal> okay

[21:22] <xerox> The definition is what I showed you.

[21:22] <xerox> In fact it is a rendundant definition, because some of the combinators can be derived from a little subset.

[21:22] <xerox> They are quite handy!

[21:23] <gaal> in (->) 2-tuples play a big part. in other arrows is this still the case?

[21:24] <xerox> That's one big point. The answer is yes, quite.

[21:24] <xerox> I would suggest to write your own ArrowState sometime (-:

[21:24] <gaal> are there conventional roles for the two elements in an arrowish tuple?

[21:25] <xerox> Yup.

[21:25] <gaal> are you going to spill the beans? :)

[21:25] <xerox> Let me think...

[21:27] *** larsen joined
[21:27] <xerox> They were born from Swierstra and Duponcheel's Parsing ideas.

[21:27] <gaal> I feel safe already

[21:28] <xerox> The problem with Monadic parsing is that backtracking is costly.

[21:28] * gaal nods

[21:29] <xerox> So they built a framework where the choose combinator can choose between its arguments (parsers) immediately.

[21:29] <xerox> So no need to save the input in case other alternatives from the first one has to be tried.

[21:29] <xerox> (If I remember correctly.)

[21:30] <xerox> So passing through Category Theory, they defined Arrows (-:

[21:30] <xerox> (Their parser couldn't implement bind.)

[21:31] <gaal> bind in this context =?   (I know Parsec, oh wait, do you mean the very basic glue of parsec?)

[21:31] <xerox> That is, rather than using |a -> Parser s b| Hughes defined a b c, which is an arrow from b to c.

[21:32] <xerox> That is, the data DynamicParser .. = .. didn't allow a (>>=) definition, so not being a Monad.

[21:33] <gaal> yeah, ok

[21:33] <xerox> The very precise reason for that is that the second argument is a function, and the only thing one can do with a function is apply it. But there are cases where you lack of a suitable `a' to apply it to.

[21:35] <xerox> So, Arrows. An Arrow is a type constructor with two parameter, along with the supporting operations analogous to return and bind for Monads.

[21:35] <xerox> a b c is `a computation with input b delivering a c'

[21:35] <gaal> okay, and the two parameters are typically?

[21:35] <xerox> GHC 6.5 and > has a nicer syntax for them:

[21:36] <xerox> (Arrow (~>)) => (a ~> b) -- Provided you have a good ~ in your font ;)

[21:36] <gaal> input and output of what audrey I think named "flows"?

[21:36] <gaal> is ~> meant to be a visual pun on -> ?

[21:36] <xerox> Yes :)

[21:37] <xerox> You want to rush to Arrows or want to see how Monads are potential Arrows? :)

[21:37] <gaal> so (~>) is a type constructor?

[21:37] <xerox> Yes.

[21:37] <gaal> whichever

[21:37] <xerox> Let's define:

[21:37] <xerox> class Arrow a where

[21:38] <xerox>   arr :: (b -> c) -> a b c

[21:38] <xerox>   (>>>) :: a b c -> a c d -> a b d

[21:38] <xerox> For any Monad m, functions of type |a -> m b| are potential arrows.

[21:38] <xerox> newtype Kleisli m a b = K (a -> m b)

[21:38] <gaal> "apply" and "associate"?

[21:39] <xerox> So to implement arrow operations as follows:

[21:39] <gaal> (my nicknames according to what they look to me)

[21:39] <xerox> instance (Monad m) => Arrow (Kleisli m) where

[21:39] <xerox>   arr f = K (\b -> return (f b))

[21:39] <xerox>   (K f) >>> (K g) = K (\b -> f b >>= g)

[21:40] <gaal> I'm sorry, who's this Kleisli fellow and what is he doing with our bow?

[21:40] <xerox> This gives for each Monad type the corresponding Arrow.

[21:40] <xerox> Ah, note that there _are_ non-monadic implementations of the Arrow signature.

[21:41] <xerox> gaal, it is just a name for those functions, which for each Monad m give us a potential Arrow.

[21:41] <gaal> hmmm okay

[21:41] <xerox> It shows how Monads go to Arrows.

[21:42] <xerox> However arr and (>>>) are not sufficient to write useful Arrow code.

[21:42] <xerox> So we extend the class to contain first :: a b c -> a (b,d) (c,d)

[21:43] <gaal> where'd d come from here?

[21:43] <xerox> It converts an arrow from b to c into an arrow on pairs, that applies its argument to the first component and leaves the second component untouched.

[21:43] <xerox> You see?

[21:44] <xerox> (b ~> c) -> ((b,d) ~> (c,d))

[21:44] <xerox> Pairwisely we define second :: a b c -> a (d,b) (d,c) such that:

[21:44] <xerox> second f = arr swap >>> first f >>> arr swap

[21:45] <xerox> (You see now how some of the combinators come from the previous one.)

[21:45] <gaal> hold on, I don't understand the type for first. how can it not diverge?

[21:45] <xerox> Are you still with me?

[21:45] <gaal> think curry-howard for a minute; how is d infered?

[21:45] <lumi> It's the same d on both sides

[21:45] <gaal> hey lumi

[21:46] <xerox> The resulting arrow from `first' does do `id' on the `d' value.

[21:46] <xerox> So it could be forall d. d.

[21:46] <lumi> Think of first :: (b -> c) -> ((b,d) -> (c,d))

[21:46] <lumi> Hi

[21:46] <xerox> (It is better to use ~> for Arrows, even though (->) is an Arrow.)

[21:46] <gaal> ah, (b,d) -> (c,d), that makes more sense

[21:46] <lumi> Proofwisely, I know how to derive c given a b, and I know how to derive d given a d

[21:47] <gaal> yes yes. the first definition was a (b,d) (c,d)

[21:47] <xerox> Yup.

[21:47] <xerox> We also defin a combinator which processes both components of a pair:

[21:47] <xerox> *define

[21:47] <xerox> f *** g = first f >>> second g

[21:47] <xerox> And a combinator which builds a pair from the result of two arrows:

[21:48] <xerox> f &&& g = arr (\b -> (b,b)) >>> (f *** g)

[21:49] <xerox> A funny note is that like we abstracted the idea of applying a binary operator to the result of two monadic combinators with liftM2, we can do that for Arrows too.

[21:49] <gaal> that's &&&, isn't it?

[21:50] <xerox> liftA2 :: (Arrow (~>)) => (a -> b -> c) -> (b ~> c) -> (d ~> b) -> (d ~> c)

[21:51] <xerox> liftA2 op f g = (f &&& g) >>> arr (\(b,c) -> b `op` c)

[21:51] <xerox> Puff. Pant.

[21:51] <gaal> hmmmmmm

[21:53] <gaal> ok

[21:53] <xerox> (Hughes then gives explanations of how to use Arrows to build Interpreters, LC for instance.)

[21:54] <xerox> (Then how to define Swierstra and Duponcheel's Parsers as Arrows.)

[21:55] <xerox> Stream Processor, Functors (Maybe, State, CPS).

[21:55] <xerox> Which are probably what you were aiming for, talking about `what the type var usually look like'... :)

[21:56] <gaal> well you know what they say, a little abstraction is a dangerous thing

[21:57] <xerox> But I can satisfy your hunger with some code before going to sleep.

[21:57] <gaal> yes, please do! :)

[21:58] <xerox> http://haskell.galois.com/~paolo/haskell/ArrowState.hs

[21:58] <xerox> Have fun. Talk to you tomorrow =)

[21:59] <gaal> hope so

[21:59] <gaal> thanks for the walkthrough!

[21:59] <xerox> Quite fun. Oyasuminasai!

[22:00] <gaal> night!

[22:05] <gaal> there's a hole in my understanding of basic haskell syntax. when not a function application, what does "a b" mean? I always assumed it was sugar for monads but apparently it isn't?

[22:05] <audreyt> uh?

[22:05] <audreyt> as type, or as term?

[22:06] <gaal> xerox was earlier giving

[22:06] <gaal> first :: a b c -> a (b,d) (c,d)

[22:07] <gaal> the soundness of which I had problems understanding

[22:07] <integral> that's application of a type constructor

[22:07] <gaal> then this was given:

[22:07] <gaal> first :: (b -> c) -> ((b,d) -> (c,d))

[22:07] <gaal> which is more obviously sound to me. are they equivalent?

[22:07] <integral> a = (->); first :: (->) b c -> (->) (b,d) (c,d)

[22:08] <gaal> ah, because that was "first" in the -> arrow?

[22:08] <integral> right :)

[22:08] <gaal> so "x y" really is application of y to x

[22:08] <gaal> er

[22:08] <gaal> of x to y :)

[22:08] <integral> or x to y

[22:09] <lumi> It's an application of the type constructor

[22:09] <gaal> but okay. what does it mean more generally?

[22:09] <TimToady> audreyt: checked in an S3 revision.  Have a glance if you're still awake.

[22:09] <lumi> Er doh, integral said that already :P

[22:09] * integral runs off to sleep

[22:09] <lumi> More generally how?

[22:10] <gaal> e.g. (Monad m) => m a

[22:11] <gaal> first, what could have come in place of Monad there?

[22:11] <gaal> syntactically that is

[22:11] <lumi> Class constraints?

[22:11] <gaal> and what is "m a"? the application of m to a just like above?

[22:12] <Juerd> TimToady: I apologize for my bad choice of words earlier today; I still feel the same way, but I should have waited before expressing my opinion.

[22:12] <TimToady> np

[22:12] <gaal> so Maybe Int (to pick a simple case) is the application of Maybe on Int?

[22:12] <lumi> Yeah, m is of kind (* -> *), right? You can't use it in a concrete type until you fully apply it

[22:12] <lumi> Yeah

[22:13] <gaal> ?kind Monad

[22:13] <lambdabot> Class `Monad' used as a type

[22:13] <gaal> ?kind Monad m

[22:13] <lambdabot> Not in scope: type variable `m'

[22:13] <lumi> ?kind Reader

[22:13] <gaal> how did you infer m has that kind?

[22:13] <lambdabot> * -> * -> *

[22:14] <gaal> ?kind Maybe

[22:14] <lambdabot> * -> *

[22:14] <gaal> ?kind Maybe a

[22:14] <lambdabot> Not in scope: type variable `a'

[22:14] <gaal> ?kind Maybe Int

[22:14] <lambdabot> *

[22:14] <gaal> okay.

[22:14] <lumi> Class Monad asserted it for me, I think

[22:14] <audreyt> TimToady: you had

[22:14] <audreyt> (SIMPLE) is simple in part of slic

[22:14] <audreyt> so

[22:14] <audreyt> @a[(1)] = f()

[22:14] <lambdabot> Unknown command, try @list

[22:14] <audreyt> is parsed as scalar= ?

[22:15] * xerox decided for a icecream before sleep

[22:15] <TimToady> yes, that's still scalar, I think.

[22:15] <TimToady> we can still have (@a[1]) = f()

[22:15] <xerox> gaal, lumi is right. It looks like |class forall (m :: * -> *). Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b|.

[22:16] <TimToady> I thought the "useless use of parens" criterion was a bit too vague.

[22:16] <TimToady> the alternative would be to special-case the inside of .[]

[22:16] <TimToady> didn't really like either of those approaches...

[22:16] <xerox> gaal - I highly reccommend a tour of the Prelude and the sensible modules of the library hierarchy.

[22:17] <TimToady> and we do still have @a[1,] = f() as well.

[22:17] <xerox> @fptools Prelude

[22:17] <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs

[22:17] <gaal> done that actually (twice), but not the past couple of months. will do again with kinds in mind.

[22:17] <audreyt> TimToady: yup

[22:18] <gaal> okay anyway. I should sleep. have fun everybody

[22:18] <lumi> Have fun

[22:19] <xerox> Goodnight again :) <licks last pieces>

[22:19] <TimToady> otsukaresamadeshita.

[22:20] <audreyt> it's well past midnight now... I'm feeling incoherent, overlapping and undecidable :)

[22:20] <audreyt> so, g'nite

[22:20] <audreyt> TimToady: the spec is I think good enough for the release. thanks!

[22:20] <TimToady> dreat sweams

[22:20] <TimToady> *dreet, I mean

[22:21] * TimToady realizes that what audreyt means is "keep your cotton-pickin' hands of the spec now"... :)

[22:22] <audreyt> well, yeah, not another assign.t-style reverse-decision  :)

[22:22] <audreyt> (though that was for the better, definitely)

[22:23] <TimToady> I wonder if the tests need tweaking?

[22:23] <audreyt> prolly yes

[22:23] <TimToady> I'll have a peep.

[22:23] <audreyt> yay

[22:23] <audreyt> TimToady++ TimToady++ TimToady++

[22:23] <TimToady> she says feebly

[22:23] <audreyt> *wave* &

[23:03] *** chris2 joined
[23:11] *** sahadev2 joined
[23:11] *** macroron joined
[23:49] *** bpederse left
[23:49] *** cmarcelo joined
[23:51] <svnbot6> r10725 | lwall++ | Revised tests for list assignment syntax with scalar assignment semantics.

[23:52] *** kanru joined
[23:53] *** justatheory joined
