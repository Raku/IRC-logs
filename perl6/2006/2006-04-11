[00:00] <mugwump> I hate those stupid keyboards that move the whole block down one row of keys, so that printscreen is where my fingers expect insert to be

[00:00] <arcady> the 3 "useless" keys are pause/break, scroll lock, prtscrn/sysrq

[00:00] * theorbtwo is fossilized into using the old DOS edit logical copy-and-paste keys: shift-insert is paste.

[00:00] <Juerd> Just because someone thought that nobody would use it. While that's *generally* true, it is still used in hotkeys like copy/paste hotkeys, and by 9 out of 10 cheap KVM switches.

[00:00] <Juerd> arcady: Print Scrn is exceptionally useful.

[00:00] <theorbtwo> Even worse, "power off" is where page up should be.

[00:01] <theorbtwo> Er, wait, I have that reversed or somesuch.

[00:01] <Juerd> I'm also quite used to ctrl|shift + insert

[00:01] <arcady> I think for number of useless keys, though, sun keyboard wins

[00:02] <arcady> they even have a blank key

[00:02] <theorbtwo> I hate it enough that the diag keys are in the wrong places on my laptop for playing nethack.

[00:02] <Juerd> Though using OS X for a while, and a kinesis keyboard (with awkward insert position) has taught me to also love crtl + c|v

[00:03] <Juerd> What are diag keys?

[00:03] <theorbtwo> diagnol

[00:03] <theorbtwo> Diaganol.

[00:03] <theorbtwo> Er...

[00:03] <theorbtwo> diagonal

[00:04] <theorbtwo> (Because there is no usable numeric keypad, and I never learned "vi keys".)

[00:04] <theorbtwo> Of course, this has meant that I waste much less time playing nethack on my laptop, and instead find other ways to waste time, like talk about keyboards on #perl6.

[00:04] <Juerd> Diagonal keys?

[00:04] <Juerd> I still don't know what you mean.

[00:05] <arcady> like on a numeric keypad, I think

[00:05] <Juerd> 7913?

[00:06] *** frederico joined
[00:07] <arcady> home, pgup, end, pgdn

[00:07] <audreyt> TimToady: the new comment rule has a weird consequence

[00:07] <audreyt> say I have

[00:07] <audreyt> sub f {

[00:07] <audreyt>  ...

[00:07] <audreyt> }

[00:07] <audreyt> if I prepend each line with #

[00:07] <audreyt> to comment it out

[00:07] <audreyt> then

[00:07] <audreyt> #}

[00:07] <audreyt> will introduce a comment block

[00:08] <audreyt> to be terminated by {

[00:08] <audreyt> that's what happened with Test.pm

[00:08] <theorbtwo> Yeah, those.

[00:08] <audreyt> a workaround is to limit legit opening to, well, opening quotes

[00:08] <audreyt> but #{

[00:08] <audreyt> is still possible

[00:09] <arcady> that just seems wrong

[00:09] <audreyt> another workaround is to use ## instead of #, but I'm not sure it's better

[00:09] <Juerd> arcady: Multiline comments themselves just seem wrong

[00:10] <Juerd> They naturally introduce visual and mechanical parsing troubles

[00:10] <audreyt> $x.##{your advertisement here}.moose;

[00:10] <Juerd> Inline comments ditto.

[00:10] <arcady> yes

[00:10] <arcady> I don't see what was wrong with the existing comment mechanism

[00:10] <Juerd> audreyt: Really, with either #{} or ##{}, who would actually use that to line up method names?

[00:10] <Juerd> Or, worse, #x.##{

[00:10] <Juerd> eh

[00:11] <Juerd> Or, worse, $x.##{

[00:11] <Juerd> }.moose;

[00:11] <Juerd> }.moose looks like it's a Hash method.

[00:11] <Juerd> Or a method on a closure.

[00:11] <Juerd> Not on $x

[00:11] <audreyt> indeed

[00:11] <audreyt> though line up doesn't need #

[00:11] <audreyt> $x.    .moose;

[00:11] <mugwump> #*  *# ?

[00:11] <audreyt> is okay

[00:12] <audreyt> long dot is quite orthogonal to inline comments

[00:12] <Juerd> mugwump: Before we try and find useful glyphs, why aren't we discussing what problem inline comments solve?

[00:13] * Juerd doesn't like long dot either, but doesn't dislike it enough to fight it.

[00:13] <Juerd> I personally still don't see any problem with space before dot.

[00:13] <mugwump> I guess it's the problem where sometimes you have to change the layout of a piece of code to put a comment on it

[00:14] <Juerd> mugwump: Do you have code to illustrate your guess?

[00:14] <mugwump> or if you want to comment out a block, you have to use POD

[00:14] <Juerd> Commenting out blocks is stupid by itself. But those who feel they have to, can use POD, or their programmer's editor to do so.

[00:14] <Juerd> I don't see why they'd need a third way.

[00:14] <FurnaceBoy_> ` ' mapping to typographic single quotes was a convention used by Knuth, and perpetuated by GNU/texinfo

[00:14] <FurnaceBoy_> ditto `` '' as ligatures

[00:15] <Juerd> I personally like if 0 { ... } better for temporary disabling code.

[00:15] <arcady> you have to comment it out if it's a syntax error or something

[00:15] <Juerd> No, if there's a syntax error, there are two possibilities

[00:15] <Juerd> 1. The code is irrelevant and can be *removed*

[00:16] <Juerd> 2. The code is needed and must be *fixed*

[00:16] <Juerd> Commenting code is like removing it, only it doesn't clean up as much :)

[00:17] <arcady> well, if you think you might want it back...

[00:17] <arcady> then you should be using version control.

[00:17] <Juerd> Why would you want code back that isn't even syntactically correct? :)

[00:17] <Juerd> I can't imagine people think like that...

[00:18] <arcady> and inline quotes are, I think, even less useful

[00:18] <Juerd> Agreed.

[00:18] <arcady> err... comments

[00:18] <arcady> last time I used them, it was actually for some horrible java preprocessor thing

[00:18] <mugwump> that's the nice thing about perl.  timtowtdi.  if you don't like a feature you don't have to use it

[00:19] <Juerd> mugwump: But this kind of feature has great impact on other parts of the language.

[00:19] <arcady> and it's a feature that if you don't know about can bite you

[00:19] <Juerd> mugwump: And about how people perceive the code. Also, "if you don't like it, just don't use it" only works for people who never ever have to maintain other people's code.

[00:19] <arcady> as just demonstrated

[00:20] <mugwump> right, so if multiline/inline comments are to work, they should be visually obvious the first time you see them

[00:20] <Juerd> And it has to be implemented, maintained, and tested.

[00:20] <Juerd> mugwump: I'd really like to know why we'd need them, first.

[00:20] <audreyt> anyway... this coding monkey has implemented them (committing)

[00:20] <Juerd> I know that some people want them. I've never heard those people present any convincing case, though.

[00:20] <mugwump> Juerd: but, you've already stated that you won't accept any explanation!

[00:20] <audreyt> (it doesn't mean I neccessarily like single # to introduce inline comments)

[00:21] <TimToady> audreyt: #} is not a legal opening sequence.

[00:21] <audreyt> TimToady: but #{ is

[00:21] <Juerd> mugwump: I haven't stated that.

[00:21] <TimToady> yes.

[00:21] <audreyt> TimToady: but q}...{ is fine, no?

[00:21] <audreyt> same reason as q>...<

[00:21] <TimToady> no, I don't think so.

[00:21] <audreyt> oh, so it is biased.

[00:21] <TimToady> I think so.

[00:21] <audreyt> that means q>...>

[00:21] <audreyt> is legal?

[00:22] <audreyt> same as q!...!

[00:22] <TimToady> in theory, but someone who does it should be shot.

[00:22] <Juerd> TimToady++

[00:22] <audreyt> gotcha.

[00:22] <Juerd> TimToady: Though did you know that in Finland, >>foo>> quotes are used? :)

[00:22] <Juerd> TimToady: I learned so today, from Wikipedia

[00:22] <TimToady> That...explains a lot...

[00:22] <wolverian> Juerd, they are rather oldish and not used in modern texts.

[00:23] <wolverian> sorry. :)

[00:23] <arcady> also, wikipedia says that " is called rabbit ears

[00:23] <wolverian> there is no easy explanation..

[00:23] <Juerd> wolverian: That's with all traditional quotes. They're replaced by ASCII ;)

[00:23] <Juerd> Except in France, where they still stubbornly use their <<>>.

[00:23] <audreyt> . o O (you believe things you read on wikipedia?)

[00:23] <wolverian> Juerd, yeah. except it's not " that is used in print, but the curly version.

[00:24] <audreyt> TimToady: anyway, that still leaves the #{ problem, though maybe it is nonfatal enough

[00:24] <TimToady> I think so.

[00:24] <Juerd> audreyt: I do! And you should too... you could learn things about yourself that you didn't already know :)

[00:24] <TimToady> I only believe things inside French quotes.

[00:25] <audreyt> Juerd: jimbo just two days ago said in taipei that you are supposed to believe in things in Wikipedia-stable only

[00:25] <Juerd> #{ would introduce a comment? Probably a big problem, because many people are used to s/^/#'ing in vim.

[00:25] <audreyt> (when it comes to happen RSN)

[00:25] <Juerd> audreyt: Heh :)

[00:25] <Juerd> wolverian: Blame MS Word.

[00:26] <TimToady> shouldn't be a problem #{...#} still works.

[00:26] <TimToady> as long as the brackets balance.

[00:26] <Juerd> TimToady: Sure, but inside brackets, you don't parse Perl.

[00:26] <Juerd> TimToady: So any quoted string in it, with an imbalanced pair, fails.

[00:26] <TimToady> I think people will learn to do s/^/# / instead.

[00:26] <Juerd> They shouldn't have to.

[00:26] <mugwump> agreed.

[00:26] <TimToady> screw 'em

[00:27] <Juerd> They shouldn't have to discover that # alone no longer suffices.

[00:27] <audreyt> #{

[00:27] <audreyt> # {...}

[00:27] <svnbot6> r9887 | audreyt++ | * Implement the commenting rules in S02v22:

[00:27] <audreyt> #}

[00:27] <svnbot6> r9887 | audreyt++ |     $a.#(your advertisement here).method;

[00:27] <svnbot6> r9887 | audreyt++ |     say #<<< Foo <bar> >>> "Hello, world";

[00:27] <audreyt> would fail, no? or brackets in comments are still followed?

[00:27] <Juerd> They shouldn't have to be bitten by a feature that they probably won't even ever used.

[00:27] <mugwump> How about if you enforce a trailing # too?

[00:27] <Juerd> Though this prediction can be ignored :)

[00:27] <audreyt> #<  1<2  >

[00:27] <mugwump> say #<<< Foo <bar> >>># "Hello, world"

[00:28] <audreyt> I thought this should parse fine, not delayed

[00:28] <Juerd> mugwump: An make it even uglier? Also, how far do you want to look ahead, when parsing? :)

[00:28] <audreyt> Juerd: there is no lookahead :)

[00:28] <mugwump> that doesn't need more than one token lookahead

[00:28] <Juerd> audreyt: backtrack then

[00:28] <audreyt> $x.#( moose )#.meth

[00:28] <audreyt> Juerd: there is also no backtrack... failure to close an inline comment block is syntax error

[00:28] <audreyt> not magical reparse

[00:28] <Juerd> audreyt: I see.

[00:29] <Juerd> Then, how far do you want to look ahead, or backtrack, visually?

[00:29] * theorbtwo thinks lookahead of up to 6 characters is OK.  More then that and people forget what they are looking for.

[00:29] <audreyt> I sorta like the balancing trailing # mugwump proposed.

[00:29] <Juerd> My gut reaction to multiline comments is very negative.

[00:29] <theorbtwo> So do I... but I still wonder why we need them.

[00:29] <audreyt> it agrees with /*...*/, {-...-}, <--...-->

[00:30] <theorbtwo> Humans think symmetry is good and orderly.  I wonder how this works with MJD's hypothisis that symmetry detecting is about spotting preditors in the jungle.

[00:30] <audreyt> cf: http://wadler.blogspot.com/2006/01/bikeshed-coloring.html

[00:31] <Juerd> I think we're all just wasting time and brain energy

[00:31] <theorbtwo> audreyt: Except I think we are worrying a fair bit about the colour of the trim, and not at all about if we need a bike-shed at all.

[00:31] <audreyt> wadler observes that "Lexical syntax of comments" is 8x more attractive than semantics :)

[00:31] <theorbtwo> What was wrong with $foo.      meth?

[00:32] <Juerd> theorbtwo: That trailing dot is visually hard to spot at the end of a line.

[00:32] <Juerd> theorbtwo: And makes that the next line looks like a function call, not a method call.

[00:32] <Juerd> e.g.:

[00:32] <Juerd> $foo.

[00:32] <Juerd> bar().

[00:32] <Juerd> baz();

[00:33] <audreyt> say #<<< Foo <bar> >>> "Hello, world";

[00:33] <audreyt> say #<<< Foo <bar> >>># "Hello, world";

[00:33] <Juerd> whereas this is immediately obvious, and what most people are used to already:

[00:33] <Juerd> $foo

[00:33] <Juerd> .bar()

[00:33] <Juerd> .baz();

[00:33] <audreyt> TimToady: I think the second form is quite a bit more readable...

[00:34] <Juerd> Though \s+\. doesn't work if you insist that "foo .bar" mean "foo($_.bar)", which is a axiom I think we can do without.

[00:34] <mugwump> and an accidental multiline comment is much more likely to be a syntax error, because hardly anyone puts comments right after }

[00:34] <theorbtwo> $foo#{

[00:34] <wolverian> Juerd, maybe we should just require ()s on sub calls. ;

[00:34] <wolverian> ;)

[00:35] <theorbtwo> }#.bar seems like just about maximal uglyness.

[00:35] <Juerd> wolverian: Well, not require it at all, but make it the obvious solution.

[00:35] <wolverian> Juerd, that's a good point. how?

[00:35] <Juerd> wolverian: Documentation, peer pressure...

[00:35] <wolverian> warnings?

[00:36] <theorbtwo> I don't like requiring parens on functions.  Indeed, I don't even much like it on method calls, but I don't think it's avoidable there.

[00:36] <Juerd> No, you shouldn't warn about ambiguity. You might as well forbid the syntax then.

[00:36] <theorbtwo> It lets you think of a void context function call like a command.

[00:36] <wolverian> theorbtwo, I agree, and I think most people her edo.

[00:36] <wolverian> s,her e,here ,

[00:37] <wolverian> Juerd, maybe foo\s*.bar should be forbidden.

[00:37] <Juerd> wolverian: *? :)

[00:37] <Juerd> wolverian: + then, please ;)

[00:37] <Juerd> Otherwise I won't even consider it

[00:37] <wolverian> it seems logical. always use ()

[00:37] <wolverian> ..to separate

[00:37] <Juerd> wolverian: Don't forget that \n is in \s

[00:37] <wolverian> mmhm

[00:38] <wolverian> anyway, I'm not serious. just taking the python approach and seeing how it works

[00:38] <Juerd> I think the "long dot" is fine, I just liked ... . better than . .

[00:39] <mugwump> “$foo = .property” should work, but “say .property” shouldn't?

[00:39] <Juerd> In any case \.\s+ doesn't work for me, and I like the old \s+\. best but realise that it is a problem if you consider .bar

[00:39] <wolverian> mugwump, hopefully not. :)

[00:39] <theorbtwo> I think long dot seems like a quite reasonable WTDI.

[00:39] <wolverian> (as in, hopefully that is not true)

[00:40] <Juerd> Or we could try to make . infix instead of postfix, and solve the entire thing with precedence.

[00:41] <theorbtwo> For that matter, \s*...\s* being semanticly equiv to the empty string -- where one of the space-strings is nonempty -- seems reasonable.

[00:41] <Juerd> (maybe.)

[00:41] <theorbtwo> Er, that'd conflict with yaddayaddayadda, though.

[00:41] <wolverian> heh. sub bomb { return { ... } }

[00:42] <Juerd> sub bomb { { ... } }

[00:42] <Juerd> Then it even looks like one

[00:42] <Juerd> Good night

[00:42] <theorbtwo> G'night, Juerd.

[00:42] <TimToady> 'nite.

[00:42] <wolverian> Juerd, hm, I thought the closure is immediately executed there

[00:43] <wolverian> (due to some special rule whose motivation I forgot)

[00:45] <theorbtwo> Um, there's the closure in void context rule, but that's not void context, it's an implicit return.  Is there another rule I don't know about?

[00:46] <wolverian> maybe I'm just confused, but that's what I remember.

[00:46] <audreyt> ?eval sub f { { 3 } } say f()

[00:47] <evalbot_9886> OUTPUT[<SubBlock(<anon>)> ] bool::true

[00:47] <FurnaceBoy_> hehe

[00:47] <TimToady> bare block at a statement boundary is just special cased to imply a "do".

[00:47] <TimToady> that's a bug in pugs.

[00:48] <TimToady> you have to return a block explicitly if that's what you mean.

[00:48] <TimToady> ?eval sub f { return { 3 } } say f()

[00:48] <theorbtwo> Ah, it's not "in void context", but "as a top-level statement".

[00:48] <evalbot_9886> OUTPUT[<SubBlock(<anon>)> ] bool::true

[00:48] <theorbtwo> That makes sense.

[00:49] <TimToady> ?eval sub f { do { 3 } } say f()

[00:49] <evalbot_9886> OUTPUT[3 ] bool::true

[00:49] <TimToady> that's supposed to be the default without the do.

[00:49] <audreyt> fixed, committing.

[00:49] <theorbtwo> s/a top-level statement/as the top level of a statement/

[00:50] <wolverian> hrm, I don't really like that, probably because I don't like 'return'

[00:50] <TimToady> if you see a { when you're looking for a new statement.

[00:50] <TimToady> though, oddly, do { 3 } violates the other usage of "do statement".

[00:51] <TimToady> well, I guess not really...

[00:51] <audreyt> not really.

[00:51] <wolverian> not if it's }\n? my brain melts

[00:51] *** sneex joined
[00:52] <TimToady> what's the } got to do with it?

[00:52] <audreyt> I've also implemented #(...)# -- but not committing for now until S* changes :)

[00:52] <TimToady> btw, why OUTPUT[3 ] and not OUTPUT[3]?

[00:52] <wolverian> TimToady, the \n makes it a statement, or something.

[00:52] <audreyt> TimToady: \n in IRC is flattened into space

[00:52] <TimToady> Eh?  this is Perl, not Python or Ruby...

[00:53] <audreyt> TimToady: line-ending-after-}-adds-an-implicit-semicolon

[00:53] <TimToady> It does imply a semicolon, I'll grant you.  But

[00:53] <Juerd> So does that make it Python, or Ruby?

[00:53] <TimToady> you've already committed to the statement type as soon as you pass {

[00:53] <Juerd> Choose now ;)

[00:53] <Juerd> Though I'm sleeping, so I'll read the answer tomorrow

[00:53] <Juerd> afk

[00:54] <TimToady> ah.

[00:54] <TimToady> I thought maybe it was interpolating ' ' after the last elem. :)

[00:56] <theorbtwo> So +{\n...\n}\n is useless use of nummification in void context?

[00:57] <TimToady> only if it *is* in void context.  as the last statement it'd be "Don't know how to numerify a closure" or some such.

[00:57] *** sneex left
[00:59] <theorbtwo> Er, right.

[00:59] *** cyrup joined
[01:00] <theorbtwo> Which reminds me, do we still generate useless warnings where the definition is sideffectless, even if we can't prove it's not overriden with a sideeffectful version?

[01:00] <theorbtwo> s/do/should/

[01:00] <theorbtwo> s/reminds me/makes me wonder/

[01:07] *** amnesiac joined
[01:08] *** Quell joined
[01:13] <TimToady> theorbtwo: we can if the proto specifies the multies are all readonly on the parameters in question.

[01:14] <TimToady> and since "readonly" is the default...

[01:15] <TimToady> but in the worst case we might not know till runtime.

[01:15] <TimToady> (if then)

[01:21] <audreyt> TimToady: consider

[01:21] <audreyt> sub f { {$^a} }

[01:21] <audreyt> what then?

[01:25] <audreyt> also

[01:25] <audreyt> sub f { ->{3} }

[01:26] <audreyt> maybe both should return closure

[01:26] <audreyt> and bare blocks only fold if there are no implicit params in it

[01:26] <audreyt> makes sense?

[01:28] *** jserv-- joined
[01:29] <audreyt> (also I can't find the paragraph in the specs that talks about executing bare blocks in statement level)

[01:32] <svnbot6> r9888 | audreyt++ | * Revamped the bare-block-running rule.  All statement-level

[01:32] <svnbot6> r9888 | audreyt++ |   bare blocks always run immediately:

[01:32] <svnbot6> r9888 | audreyt++ |     (sub { { 3 } }).()  # 3 under any context

[01:32] <svnbot6> r9888 | audreyt++ |   however, those with implicit params in it, as well as pointy

[01:32] <svnbot6> r9888 | audreyt++ |   blocks, are exempt from this rule. (XXX unspecced)

[01:36] <TimToady> Hmm, {print} has an implicit parameter too.  I think we should probably blow up { {$^a} }.  -> isn't a problem since it's not starting with { at the statement boundary.

[01:36] <audreyt> TimToady: well, the implicit $+_ is fine I think

[01:37] <TimToady> not if it executes at the wrong time.

[01:37] <audreyt> currently pugs treats a bare block with $_ as the only implicit param as still "bare"

[01:37] <audreyt> well, {print} is ambiguous.

[01:37] <TimToady> that's the point.

[01:37] <TimToady> return {print} isn't.

[01:37] <audreyt> but {print $_} is

[01:38] <audreyt> so one must write

[01:38] <audreyt> do { print $_ }

[01:38] <audreyt> or

[01:38] <audreyt> do { print }

[01:38] <audreyt> always?

[01:38] <TimToady> Yes, and what you do with it depends on whether the { is at the statement boundary. I suspect.

[01:38] <TimToady> no, bare {...} is always do {...}

[01:38] <audreyt> ok... bare {$^a} would be an error

[01:38] <audreyt> and bare {$_} would be special-cased to be fine

[01:38] <TimToady> right, like do { $^a }

[01:39] <TimToady> $_ likes to alias to its outer scope.

[01:41] <audreyt> implemented as such.

[01:41] <audreyt> (where in the S* is this, btw?)

[01:42] <TimToady> might just be a p6l decision.  need to research it more.

[01:42] <TimToady> grep bare.block doesn't find it.

[01:42] <audreyt> yeah, I can't seem to vgrep anything like it

[01:43] <audreyt> seems to belong somewhere near beginning in S04

[01:43] <mugwump> what built misc/pX/Common/Pugs-Compiler-Rule/lib/Pugs/Grammar/Rule/Rule.pmc ?  v6-pugs ?

[01:44] <audreyt> mugwump: no, lrep

[01:44] <audreyt> see misc/pX/Common/Pugs-Compiler-Rule/Makefile.PL

[01:45] *** kanru joined
[01:45] <audreyt> bbiab...

[01:45] <mugwump> ah, right

[01:46] <svnbot6> r9889 | audreyt++ | * Statement-level bare blocks with implicit params (except for $_)

[01:46] <svnbot6> r9889 | audreyt++ |   become errors.

[01:46] *** Leandro- joined
[01:46] <TimToady> from A04:

[01:46] <TimToady> [Update: Bare blocks are still legal, and always execute immediately

[01:46] <TimToady> as expected.  To return a closure you should use an explicit C<return>.]

[01:46] <Leandro-> anybody know how translate it: $hhmmssd = date("His").substr(sprintf("%0.1f",microtime()),-1); to perl?

[01:47] <amnesiac> Spanish++

[01:47] <amnesiac> eerrr

[01:47] <audreyt> TimToady: please update S04 when you get some cycles :)

[01:47] <audreyt> &

[01:48] <TimToady> k

[01:48] <TimToady> gotto go spend some cycles calculating my income taxes though...

[01:48] <TimToady> s/income/outgo/ is more like it...

[01:48] <TimToady> heading home. &

[01:54] <Leandro-> How i got the microtime?

[01:54] *** justatheory joined
[01:55] <FurnaceBoy_> mathetes, This may sound a little strange, but, the whale, at the Denver Sea Park, is going to die, unless we get it to the moon.

[01:55] <FurnaceBoy_> wc

[02:07] *** kanru joined
[02:09] *** mako132_ joined
[02:25] *** hlen_ joined
[02:35] *** hlen_ is now known as hlen

[02:48] *** DesreveR joined
[02:52] <mugwump> I don't see any superclass stuff in S12.  what's the syntax to call a superclass method?

[02:52] <mugwump> (or next_method or whatever)

[02:58] <arcady> with next, I think...

[02:59] <audreyt> mugwump: "call"

[02:59] <mugwump> thanks

[02:59] <audreyt> or "next METHOD" if you don't care about rv

[02:59] <audreyt> (bbiab) &

[03:08] <TimToady> audreyt: I just special-cased # on the left margin to always be a line-end comment regardless.

[03:09] <mugwump> that's awful

[03:10] <TimToady> I'm tired of everything being awful regardless of what I decide.

[03:10] <audreyt> TimToady: I just implemented it.

[03:10] <audreyt> also, nesting.

[03:10] <TimToady> thanks.

[03:10] * audreyt puts on the "coding monkey" hat.

[03:10] <TimToady> ...to keep from getting her designer head bitten off, I presume.  :)

[03:10] <audreyt> indeed :)

[03:11] <audreyt> moreover, I think it's actually somewhat sane now, with both nesting and 1col.

[03:12] <audreyt> the 1col doesn't bother me

[03:12] <audreyt> because we already special case

[03:12] <audreyt> #line 10

[03:12] <audreyt> which is also a 1col constraint.

[03:12] <TimToady> and =begin

[03:12] <audreyt> yeah.

[03:12] <audreyt> writing unit tests for them

[03:12] <mugwump> ok, maybe i'll warm to it

[03:13] <TimToady> I saw some of them just coming through with svn up.  audreyt++

[03:13] <audreyt> =)

[03:16] <audreyt> all of the rest are implemented as of r 9890.

[03:16] <audreyt> I really need to get back to $job now :)

[03:16] * audreyt waves &

[03:16] <svnbot6> r9890 | audreyt++ | * comments: finish off the rest of comment syntax as of r8637 svn.per.org:

[03:16] <svnbot6> r9890 | audreyt++ |     use v6;

[03:16] <svnbot6> r9890 | audreyt++ |     #line 1

[03:16] <svnbot6> r9890 | audreyt++ |     #< this is still one-line comment

[03:16] <svnbot6> r9890 | audreyt++ |      #< but this is inline comment >

[03:16] <svnbot6> r9890 | audreyt++ |      #< and it <also> nests >

[03:16] <svnbot6> r9890 | audreyt++ |      #[[[ even [[[across]]] multichar delims ]]]

[03:17] <TimToady> uh, that last line wasn't how it's currently specced, but if it's easier to do it that way, I can change it.

[03:18] <audreyt> I think it's quite a bit more symmetric

[03:18] <audreyt> i.e. nesting only looks at the delims

[03:18] <TimToady> I was going both ways about it.

[03:18] <TimToady> it would be easy to persuade me to go the other way.

[03:18] <audreyt>  #[[[ simple [ nonbalance should be fine ]]]

[03:18] <audreyt> because if you use [[[, you anticipate [ in it

[03:18] <TimToady> I'm trying to remember why I decided the other way.  I guess I

[03:19] <TimToady> was influenced by how closures work in PGE.

[03:19] <audreyt> well, we can also go

[03:19] <audreyt> #[[[ #< foo > ]]]

[03:19] <audreyt> but that would warrant the trailing # you don't like

[03:19] <audreyt> so I think reusing the same set of delim all the way makes more sense

[03:19] <TimToady> Okay, I'll fix it to the other way.

[03:20] <audreyt> thanks :)

[03:20] <audreyt> TimToady++

[03:20] <TimToady> I also blinked at the 4.  .say test a couple of times.

[03:20] <audreyt> nod.

[03:21] <TimToady> er, sqrt, actually.  but that implies more lookahead than /^.\s/

[03:21] <audreyt> there's no lookahead really

[03:21] <TimToady> Since 4. + 3 should probably be 7.

[03:21] <audreyt> it's a parsefail.

[03:21] <arcady> fwiw, ruby prohibits both 1. and .1

[03:22] <audreyt> you can make it backtrack, but I don't think it's worth it

[03:22] <audreyt> arcady: that's sane also.

[03:23] <TimToady> I don't mind losing 1.

[03:23] <TimToady> but .1 should continue to work, I think.

[03:23] <audreyt> sure.

[03:23] <audreyt> it's interesting in designing minip6-for-PGE-also-PIL2 how much we can get just be dropping BEGIN

[03:24] <TimToady> well, at least it's probably an easy one to figure out a decent message for, given a bit of backtracking in the error message producer.

[03:24] <audreyt> i.e. once BEGIN (and anything causing it) is dropped, almost all sugar disappears

[03:24] <TimToady> which, of course, indicates the power of the beastie.

[03:24] <audreyt> ?eval 1. +2

[03:25] <evalbot_9889> Error:  unexpected " " or "." expecting "_", exponent, term postfix, "#", operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[03:25] <audreyt> (at line 1 column 2)

[03:25] <audreyt> not the best errmsg ever, but at least the column position is clear

[03:26] <TimToady> Should say, "1. must be written 1.0"

[03:26] <audreyt> k.

[03:27] <TimToady> but again, I'm assuming that all the backtracking smarts we don't allow in the real parse are brought to bear for better error messages.

[03:27] <TimToady> so I'd say don't sweat it till we're self hosting.

[03:27] <audreyt> yup.

[03:30] <TimToady> on the other hand, the error we're currently getting indicates that it hasn't really committed to a long dot after seeing ". ", which it seems to me it could.

[03:32] <audreyt> okay, implemented

[03:32] * audreyt praises a default-commit engine

[03:43] <TimToady> I suspect we could figure out a way to make rules autocommit, at least pragmatically.

[03:43] <svnbot6> r9891 | audreyt++ | * postfix long-dot now commits by default and never backtrack.

[03:43] <audreyt> $ ./pugs -e '1. +3'

[03:43] <audreyt> *** unexpected "+" expecting "#" or "." at -e line 1, column 4

[03:44] <audreyt> obviously the correct errmsg (without special casing)

[03:44] <TimToady> audreyt++

[03:45] <audreyt> yeah, autocommit is a win because it saves you the trouble of thinking (as any DBI programmers will attest)

[03:45] <audreyt> really &

[03:46] <TimToady> ciao, and thanks &

[03:59] <TimToady> ?eval 1.#(hmm) + 3

[03:59] <evalbot_9891> Error:  unexpected "+" expecting "#" or "."

[03:59] <TimToady> cool

[04:06] *** cyrup left
[04:06] *** hcchien_ joined
[04:07] *** rashakil joined
[04:07] <arcady> btw, ruby actually does parse 1. + 3

[04:08] <arcady> as 1.+(3)

[04:08] <arcady> calling the method '+' on 1, with argument 3

[04:08] <arcady> and .1 being prohibited is a fairly recent thing, presumably to rationalize the syntax

[04:08] <arcady> since it was allowed before, that means that it's at least parseable

[04:10] <TimToady> Hmm.  Well, if ruby ever wants to move from SMD to MMD, 1.+(3) is going to give them heartburn.

[04:10] <arcady> yeah, they don't do MMD

[04:11] <arcady> a feature that I very much miss

[04:11] <TimToady> ?eval 1. + 2

[04:12] <evalbot_9891> Error:  unexpected "+" expecting "#" or "."

[04:12] <TimToady> ?eval 1.+2

[04:12] <evalbot_9891> 3/1

[04:12] <TimToady> that's a bit wonky...

[04:16] <arcady> ?eval 1.+ 2

[04:16] <svnbot6> r9892 | fglock++ | PCP - Precedence.pm passes some tests

[04:16] <evalbot_9891> 3/1

[04:28] <svnbot6> r9893 | Darren_Duncan++ | ext/Rosetta/ : updated the docs about how Rosetta relates to 'The Third Manifesto' and about what the latter actually is

[04:34] *** penk joined
[04:41] <TimToady> 1.+ 2 should say "missing method name after .+"

[04:41] <TimToady> and 1.+2 should say "2 is not a legal method name after .+" or some such...

[04:42] <arcady> what does .+ do these days?

[04:42] <TimToady> calls all the named methods like .*foo does, but requires at least

[04:42] <audreyt> the .*/.?/.+ isn't yet supported.

[04:43] <TimToady> one to succeed or throws and exception.

[04:43] <TimToady> np

[04:43] <audreyt> need to implement "call" properly for it

[04:43] <TimToady> just saying where I think it should eventually go

[04:43] <audreyt> commit a test :)

[04:43] <audreyt> btw, how is ::Capture going?

[04:44] <TimToady> haven't started yet.  ghostwriters would not be looked askance at.

[04:44] <mugwump> audreyt, does Module::Install handle building Module::Compile .pmc files at build time yet?

[04:46] <audreyt> mugwump: sure

[04:46] <audreyt> mugwump: you need to say

[04:46] <audreyt> pmc_support;

[04:46] <mugwump> nice!

[04:46] <audreyt> TimToady: roger

[04:50] <svnbot6> r9894 | fglock++ | PCP - code, docs cleanup

[04:51] <mugwump> http://utsl.gen.nz/talks/perl6.now/start.html  # comments/feedback, anyone?  I'll be giving this in ~1hour :)

[04:51] *** Khisanth joined
[04:54] <TimToady> that's not what "begat" means...

[04:54] <mugwump> ain't it ?

[04:55] <mugwump> oh, silly be

[04:55] <mugwump> silly me

[04:56] <mugwump> "perl 6 and haskell begat pugs" -- that's better, huh?

[04:57] <mugwump> actually I think I'll just pull those parts, they're a fairly tenuous joke anyway

[04:57] <arcady> I'm confused. are you your own grandfather?

[04:57] <arcady> : )

[04:58] <mugwump> ok, so (perl5 + Haskell spec -> Haskell), (Haskell + perl6 spec -> pugs), (perl5 + perl6 spec -> perl6)

[04:59] <mugwump> tenuous, because it requires "perl" (all versions) to be considered a parent of Haskell

[04:59] <mugwump> usually you can get away with that sort of incongruency when giving a talk.  But it's gone now :)

[05:00] <TimToady> this is a nit, and maybe a bug in Moose, but $.x = 0 is still supposed to call the virtual accessor even in the current class.

[05:01] <mugwump> right, is $:x = 0 the equivalent, then?

[05:01] <TimToady> $!x = 0

[05:01] <mugwump> The last time I asked about how that went I was told to look up the term, "necro-equine flagellation"

[05:01] <mugwump> :)

[05:03] <audreyt> mugwump: wow, you wrote my YAPC::NA talk for me

[05:04] <TimToady> the :: in the P6 equivalent MMD examples is unnecessary for any predeclared class or role.

[05:04] <mugwump> right

[05:05] <mugwump> also there are nicer ways to write that.  but I wanted the code to look very similar

[05:05] <audreyt> Intermediate language: IMC

[05:05] <audreyt> it's now always PIR

[05:05] <audreyt> IMC is totally gone

[05:06] <mugwump> heh, that's what I get for re-acquainting myself with things by browsing the source :)

[05:06] <mugwump> the first version still used "pX" :)

[05:06] <TimToady> but the P5 example doesn't use ::, so that makes it look different...

[05:08] <mugwump> oh yeah, I keep forgetting that's valid p5

[05:08] <TimToady> and you might note that coro is in fact completely unspecced with respect to P6...

[05:10] <mugwump> oh, I thought I saw a draft somewhere along the line.

[05:10] <audreyt> it's drafted in S17.

[05:10] <audreyt> and implemented as such in JS/Pugs

[05:10] <audreyt> also Hs/Pugs

[05:10] <audreyt> but not yet canonical

[05:11] <TimToady> does Perl6::Currying still use .prebind?  We changed it to .assuming ages ago...

[05:11] <mugwump> that module is now an antique

[05:13] <audreyt> mugwump: "Brian Ingerson => "Ingy dot Net"

[05:13] <audreyt> the umlaut over o is optional

[05:13] <merlyn> Ingy döt Net

[05:13] <mugwump> ok

[05:13] <TimToady> someone is likely to ask you the relationship of lrep and pge

[05:14] <mugwump> sure, they're parallel implementations, right?

[05:14] <audreyt> right.

[05:14] <TimToady> hopefully convergent...

[05:14] <TimToady> but maybe we live in a hyperbolic space rather than elliptical...

[05:14] <audreyt> (there is another rules implementation, Text.Parser.Rule, that I intend to use to converge to the same grammar)

[05:15] <TimToady> What I implement 3 times is true?

[05:15] <audreyt> indeed

[05:15] <audreyt> (there is also a ruby port by tewk somewhere.)

[05:15] <mugwump> hey, you only need three seperate implementations and a spec to get an IETF standard

[05:16] <TimToady> what about Pecmarl?

[05:16] <audreyt> ooh, Perl 6 rules as RFC ;)

[05:16] <mugwump> Pecmarl?

[05:16] <TimToady> p-ecma-rl

[05:18] <audreyt> mugwump: it's not

[05:18] <audreyt> next clear

[05:18] <audreyt> it's

[05:18] <audreyt> next METHOD

[05:18] <audreyt> the label name is literal

[05:18] * mugwump fixes that

[05:18] <TimToady> pcre -> pcrecma :)

[05:19] <mugwump> ActiveParrot

[05:19] <TimToady> does Builtins redefine caller if you only import system?

[05:20] <mugwump> heh.  I cut and paste that from the man page :)

[05:20] <mugwump> I'll check

[05:23] <mugwump> oh, heck, Contextual::Returns *does* require Want

[05:23] <TimToady> given/when ... ? doesn't seem to have a slide yet

[05:23] <mugwump> that's because I couldn't find a module that implemented it :)

[05:23] <mugwump> lots of similar ones called switch etc

[05:23] <mugwump> one of them almost has the spirit of smartmatch

[05:25] <TimToady> but if Contextual::Returns uses a controlled subset of Want, maybe it's less core-dumpy.

[05:25] <mugwump> it seems to only use it for Contextual::Return::Failure

[05:25] <audreyt> clkao: hmm, seems we mussed Perl6::Binding...

[05:26] <audreyt> missed, even.

[05:27] <TimToady> not sure why 3D uses LEAVE.  could just $.z = 0 before next METHOD.

[05:27] <audreyt> mugwump: damian now pefers Perl6::Export::Attrs

[05:27] <mugwump> right.  well, I wanted it to be just like "after"

[05:27] <audreyt> over Perl6::Export

[05:27] <mugwump> audreyt: ok

[05:28] <mugwump> maybe that's too academic a distinction

[05:28] <audreyt> also, v6-pugs would (presuambly) use pugs -CPerl5

[05:28] <audreyt> whilst v6-lrep would use lrep

[05:29] <audreyt> (but that is still in flux.)

[05:29] <mugwump> right, I wasn't sure whether the perl5 backend to pugs was still alive

[05:30] <audreyt> *nod* keep it ambiguous for now :)

[05:30] <fordinal> hi all

[05:30] <audreyt> it's also possible that -CPerl5 just calls lrep.

[05:31] <mugwump> cheat :P

[05:32] *** fglock joined
[05:32] <audreyt> that's what pugs has been doing all along :)

[05:33] <fglock> hi!

[05:33] <mugwump> oh.  here was I thinking that perl5 was a regular backend like JS, parrot etc

[05:33] <mugwump> hi fglock !

[05:33] <audreyt> mugwump: yeah, but -CJS just calls pil2js.pl

[05:33] <audreyt> only -CParrot is handled by haskell

[05:34] <gaal> hey there

[05:34] <audreyt> (bbiab...)

[05:34] <gaal> quick type question

[05:34] <gaal> aw

[05:34] <audreyt> make it quick :)

[05:34] <fglock> audreyt: the P::C::X op-precedence parser now uses Parse::Yapp - thanks to some undocumented features :)

[05:35] <gaal> Prim.hs around 1304 op2Ord

[05:35] * mugwump rebuilds and re-pushes the slides to the web server

[05:36] <gaal> I'm adding "defined" guards for the input, to fail if an argument to &sign are undef

[05:36] <gaal> but this I can't figure out a signature that would allow this.

[05:36] <audreyt> gaal: in op2Ord, test for

[05:36] <audreyt> op2Ord f VUndef _ = fail ...

[05:37] <audreyt> s/f/_/

[05:37] <audreyt> and again for another arg

[05:37] <audreyt> like that?

[05:37] <gaal> well, I tried explicit code (when or if) and got errors on rigid types, but i'l try this

[05:37] <audreyt> to use that, change "a" in type to Val

[05:37] <mugwump> thanks all for the feedback :)

[05:38] <audreyt> mugwump: np :) good luck

[05:38] <gaal> trying.

[05:39] <gaal> whee, yes, that worked. thanks :)

[05:39] <gaal> now to understand why

[05:39] <audreyt> left as exercise :)

[05:39] <audreyt> &

[05:41] <TimToady> hmm, now that I look at it again, the multis still aren't right.  If the sig has (Index, Whatever) the args aren't gonna show up in @_, so you'll need (Index $ix, Whatever, $what)

[05:42] <mugwump> ok, I'll rework that

[05:43] <TimToady> otherwise don't see anything else

[05:43] <TimToady> and I should probably go to bed now...

[05:43] <mugwump> thanks heaps TimToady !

[05:44] <TimToady> don't mention it.

[05:44] <TimToady> nite all. &

[05:44] <fglock> mugwump: I'm working on a new p5 based compiler, which gets closer to the p6 spec than lrep

[05:45] <mugwump> fglock: cool.  thought about going DSCM for it?

[05:46] <mugwump> (distributed source code management) = any(git, codeville, mercurial, monotone)

[05:46] <mugwump> or just keep in the pugs tree?

[05:48] <fglock> it's in pX/Common - it is modular: currently there are Pugs::Compiler::Rule (already in CPAN), Pugs::Compiler::Tokenizer (started yesterday), and Pugs::Compiler::Precedence (started today)

[05:49] <mugwump> lastlog -clear

[05:50] <fglock> then another module for the main grammar, and then an emitter, ...

[05:50] <audreyt> fglock: did you see my notes here about try to ignore anything that desugars to BEGIN

[05:51] <audreyt> as well as BEGIN itself

[05:51] <audreyt> for now? because I think it's clearer to separate the language into two such parts.

[05:51] <audreyt> i.e. all the BEGIN desugaring can be handled in one top-down macro layer

[05:53] <fglock> yes - but I'm not sure what it means - have you written more about it? Is it related to compile time expression evaluation?

[05:53] <audreyt> I'll try to write more about it tonight

[05:53] <audreyt> really gotta run now... bbiab

[05:54] *** GeJ joined
[05:54] <audreyt> (the key idea being that p6 is completely regular if you ignore ::= and BEGIN{} and "sub foo" and only allow "my &foo := sub {...}")

[05:55] <GeJ> good localtime folks

[05:59] *** avar joined
[06:00] <fglock> mugwump: the main idea is to make a compiler that p5 people can contribute to - lrep is too dense/monolithic/non-standard :)

[06:02] *** Southen_ joined
[06:02] *** azuroth joined
[06:07] <fglock> hopefully, most of Pugs::Compiler will be readable code

[06:11] *** jserv-- joined
[06:12] <arcady> somebody should write a perl 6 compiler in perl 6

[06:14] <fglock> arcady: that's the idea - lrep grammar is written in perl 6 already

[06:15] <fglock> now we need a precedence-parser module for perl 6

[06:15] <fglock> but we can 'use' a perl 5 module in the meanwhile

[06:36] *** sockstat joined
[06:42] <fglock> no new p6 summaries, no new pugs blogs :(

[06:47] *** bsb joined
[06:49] *** nothingmuch joined
[06:59] *** fglock left
[07:09] *** oozy joined
[07:23] *** tifo joined
[07:23] <Juerd> 􏿽xABtest􏿽xBB

[07:23] <Juerd> Neat. What am I sending? latin1 or utf8?

[07:24] <tifo> latin1

[07:24] <Juerd> Darn

[07:24] <Juerd> ????????

[07:24] <Juerd> ??????

[07:24] <Juerd> ????????

[07:24] <Juerd> Hm, guess so.

[07:26] <Juerd> «and now?»

[07:26] <tifo> utf8

[07:27] <Juerd> Yay

[07:27] <Juerd> Finally!

[07:27] <Juerd> 日本語

[07:27] <Juerd> Hm, that's still fucked up in display

[07:28] <Juerd> It looked nice on the input line

[07:29] <Juerd> ĉ ĝ ĥ ĵ ŝ ŭ

[07:29] <Juerd> :(

[07:29] <Juerd> é

[07:29] <Juerd> So I'm sending utf-8, but something tries to make it latin1 for display... Or something like that :(

[07:33] <Juerd> 日本語

[07:34] <Juerd> Okay, that works better now.

[07:34] <Juerd> Now I just need a better font

[07:34] <Juerd> (What font on earth has japanese, but not esperanto characters?!)

[07:35] <Juerd> Neat

[07:35] <Juerd> ĉ ĝ ĥ ĵ ŝ ŭ

[07:35] <Juerd> Now I just need a NICE font :)

[07:35] *** dakkar joined
[07:43] <Juerd> I now have all the scripts I care about display properly. Yay.

[07:46] <Juerd> I wonder how I could input the euro symbol

[07:47] *** nothingmuch joined
[07:49] <Juerd> Hi nothingmuch! Ï hàvé ûnĩcøde wörkìng! :), err, ☺

[07:55] <clkao> audreyt: mm

[08:00] *** pdcawley joined
[08:16] *** KingDiamond joined
[08:17] <theorbtwo> Juerd: Euro is compose,e,= on my keyboard: €

[08:22] <Juerd> theorbtwo: Not on mine :(

[08:23] <Juerd> I tried e= first, it made most sense, knowing L=(₤) and Y=(¥)

[08:23] <Juerd> Ohh

[08:23] <Juerd> Capital E

[08:23] <Juerd> E=, not e=

[08:23] <Juerd> €

[08:23] <Juerd> Wheee

[08:23] <Juerd> € 99999999999,99

[08:28] *** nothingmuch joined
[08:29] *** tifo joined
[08:30] <theorbtwo> That's kind of funky -- what does e= do?  Nothing?

[08:32] <Juerd> Nothing, indeed.

[08:32] <Juerd> Same nothingness occurs with l= and y=

[08:32] <Juerd> Well, y= gets to be =

[08:36] <theorbtwo> Hm, most odd.

[08:36] <Juerd> Where are these defined?

[08:37] <dakkar> if you're under the x.org X11 server, the compose rules are in /usr/lib/X11/locale/<name of the locale>/Compose

[08:37] <Juerd> Locale, eh? Hmm.

[08:37] <integral> except that locale appears to be that of the X server, which may not bare a relation to your locale :-/

[08:37] <Juerd> Oh, I do have one

[08:37] <dakkar> (I'm not sure if the path is searched on the server's machine, or on the client's)

[08:37] <Juerd> dakkar: I have no such file.

[08:38] <Juerd> server == client here

[08:38] <dakkar> Juerd: /usr/X11R6/lib/X11 etc?

[08:38] <Juerd> dakkar: Sure it's not s/lib/share/?

[08:38] <dakkar> Juerd: on my 2 Gentoo Linux machines, it's 'lib'

[08:40] <Juerd> Hmm, ŭ is formed with compose-b-u

[08:40] <Juerd> dakkar: More proof that Gentoo is not to be trusted!

[08:40] <Juerd> :P

[08:40] <Juerd> I would never have guessed the b

[08:40] <Juerd> Though b for breve makes sense.

[08:41] <Juerd> Hm, UU is Ŭ, like bU, but uu doesn't work.

[08:42] <theorbtwo> /usr/X11R6/lib/X11/locale/en_US.UTF-8/Compose on my debian system.

[08:43] <Juerd> Same here

[08:43] <Juerd> Though I got there via /usr/share/X11/locale

[08:43] <Juerd> (Ubuntu)

[08:44] <Juerd> H₂O

[08:44] <Juerd> Fun!

[08:45] <theorbtwo> Hmm, some of the things in there don't work.

[08:45] <Juerd> ① ② ③ :)

[08:45] <Juerd> Heh, they exist all the way to ⑳. I wonder WHY.

[08:46] <dakkar> Juerd: mysteries of the Unicode

[08:46] <azuroth> for simulating the lottery?

[08:46] <Juerd> azuroth: With only ①..⑳?

[08:47] <theorbtwo> Because some first-class charset they wanted to be able to round-trip easily contains them.

[08:47] <Juerd> It seems so arbitrary :)

[08:48] <azuroth> I don't actually have ⑳. nor even 2470

[08:49] <Juerd> ‹foo!›

[08:49] <Juerd> <foo!>

[08:49] <Juerd> The best glyph is somewhere in between, I guess

[08:49] <dakkar> « »

[08:49] <Juerd> TimToady: Will Perl 6 treat ‹these› the same way it treats <these>?

[08:49] <Juerd> TimToady: Or is only «this» unicodish?

[08:50] <dakkar> Juerd: write a macro for that ;-)

[08:50] <Juerd> dakkar: I'm not interested in macros, alternate grammars, modules, etcetera, right now. I'm interested in getting the most optimal standard language.

[08:51] <Juerd> When it's released and I still don't like it, those things will be considered.

[08:51] <theorbtwo> s/When/If/, or did you mean to be horribly fatalistic?

[08:52] <Juerd> I did.

[08:52] <theorbtwo> Ah.

[08:52] <Juerd> My major complaint being that <-> isn't official yet

[08:54] <Juerd> Hm, ⑤ is (5), but (c) is ⓒ, not ©, which is oc.

[08:55] <Juerd> :þ

[08:56] <Juerd> (What other use can there be for þorn?)

[08:57] <theorbtwo> Compressing þe?

[08:58] <Juerd> And undo history? No thanks

[08:59] *** marmic joined
[08:59] <Juerd> „COOL!” I can type traditional Dutch quotes now.

[08:59] <Juerd> Hmmm...

[09:00] <Juerd> €foo = „Hello, World!”;

[09:00] <Juerd> say « €foo »;

[09:01] <Juerd> I can see governments creating their own Perl standard, to further adhere to charset policies.

[09:02] *** nnunley joined
[09:05] <Juerd> $foo = „”;  # funny looking empty string!

[09:15] *** KingDiamond joined
[09:28] *** bsb_ joined
[10:07] *** chris2 joined
[10:09] *** renormalist joined
[10:09] *** KingDiamond joined
[10:12] *** renormalist joined
[10:18] *** cognominal joined
[10:25] *** cognominal joined
[10:30] *** elmex joined
[10:31] *** cognominal joined
[10:38] *** KingDiamond joined
[10:59] * dakkar is away: pranzo

[10:59] * dakkar is away: pranzo

[11:05] *** b_jonas joined
[11:28] *** kanru joined
[11:33] *** kanru joined
[12:03] *** tifo joined
[12:11] *** kolibrie joined
[12:14] *** revdiablo joined
[12:17] *** tifo joined
[12:18] <audreyt> TimToady: you outlawed 1.+3 completely

[12:18] <audreyt> that's a bit surprising...

[12:18] <audreyt> (but implemented)

[12:19] <Juerd> I'm pleasantly surprised :)

[12:19] <rgs> "." as a method call I assume

[12:19] <audreyt> interestingly, ruby thinks 1.+3 is

[12:19] <rgs> or as a decimal point ?

[12:19] <audreyt> 1.infix:<+>(3)

[12:20] <audreyt> er, I mean 1.-3

[12:20] <audreyt> rgs: decimal point

[12:20] <audreyt> "1." is no longer valid literal

[12:20] <rgs> avoid ambiguous parsing

[12:20] <audreyt> yup

[12:20] <rgs> yes, "1." is not pretty

[12:22] <Juerd> ?eval my $foo = 3; $foo.+int

[12:22] <evalbot_9894> Error: No such method in class Int: "&+int"

[12:22] <Juerd> Hm

[12:22] <Juerd> &+?

[12:22] <audreyt> Juerd: the .+ form is not yet supported

[12:22] <audreyt> (simulatenous multi dispatch)

[12:23] <audreyt> it would mean calling .int for $foo and all its superclasses that defines int

[12:25] <theorbtwo> I consider 1. evil, but scientists seem to think it's a perfectly normal way of writing 1 to one significant digit, rather then C<1>, which is one exactly.

[12:25] <theorbtwo> Or, at least, that's what I was taught in high school.

[12:26] <audreyt> *nod*

[12:26] <audreyt> but then, scientists don't overload . to mean other things.

[12:29] <theorbtwo> True enough.

[12:30] <Juerd> audreyt: Good; I don't like the operator :)

[12:31] <audreyt> well, $foo.?method can be convenient.

[12:31] <audreyt> I'm not atall sure about .* and .+.

[12:32] <audreyt> but I'm more prepared to lobby against a feature when it's 1)implemented and 2)used and 3)found to be evil

[12:32] <svnbot6> r9895 | audreyt++ | * Pugs.Parser.Number: "1." is now _not_ a valid literal.

[12:32] <svnbot6> r9895 | audreyt++ |   (tests welcome)

[12:32] * dakkar is back (gone 01:33:00)

[12:33] <Juerd> Yeah, well, don't expect 2) for .+ and .*

[12:39] *** Limbic_Region joined
[12:47] *** bsb_ is now known as bsb

[12:48] <bsb> .* and friend seem a little ugly to me too

[12:51] <bsb> access to the list of methods using :canonical, :preorder, etc is nice

[12:52] <bsb> but they seem to be better iterated with code

[12:52] <bsb> list p5's sort & reduce

[12:52] <bsb> s/list/like

[12:56] <Limbic_Region> casual observation:  The list > 6 months ago was full of questions and threads that never came to resolution but spun off into dozens of tangental conversations

[12:57] <Limbic_Region> it seems that relatively recently this has changed

[12:57] <Limbic_Region> there is a whole lot more concreteness to answers and updates to synopses to support these decisive decisions

[12:57] * Limbic_Region feels good about that

[12:58] * audreyt praises Robrt for quickly setting up the commit->p6l gateway

[12:58] <audreyt> all I did was complain a few times... and then it magickally happened (also with parrot pdds)

[12:59] <audreyt> Limbic_Region: there were actually synopses updates, it's just they escaped p6l and was very hard to track

[12:59] <audreyt> (also synopses typos/miscommits were completely elusive)

[12:59] <bsb> It does seemed to have helped

[13:03] <Limbic_Region> audreyt - I am not saying it was all doom and gloom but you know as well as I do there were plenty of things decided on the list that didn't seem to be captured

[13:03] <bsb> I wish my complaining was as productive

[13:03] <Limbic_Region> I am just saying things are looking much better

[13:03] <audreyt> Limbic_Region: and I'm agreeings vigorously :)

[13:03] <audreyt> s/s//

[13:04] <Juerd> tëst

[13:06] <Limbic_Region> well, make sure the cabal knows that it hasn't gone un-noticed

[13:06] <Limbic_Region> I was going to attempt to send an email to the list stating as much but I apparently have lost access to gmail and half the internet

[13:06] <audreyt> aww

[13:07] <audreyt> Limbic_Region: you can make sure the cabal knows about it by saing "TimToady: *backlog mark*" or some such

[13:07] <audreyt> but TimToady backlogs even more comprehensively than me it seems, so that seems to be unneccessary

[13:10] *** SamB joined
[13:11] <audreyt> bbl...

[13:17] *** Qiang joined
[13:20] *** colares joined
[13:21] *** frederico joined
[13:21] * theorbtwo thinks audreyt having commit access and TimToady being here helped a lot too.

[13:22] <theorbtwo> Then again, perhaps it's just me not being there that helped.

[13:28] *** avarab_ joined
[13:28] <avarab_> Hey

[13:34] <Limbic_Region> theorbtwo - what are you working on these days?

[13:35] *** chris2 joined
[13:40] <theorbtwo> Lots of this-and-that.

[13:40] <theorbtwo> Currently, I'm messing about with zcode.

[13:47] <theorbtwo> It's kind of funny, in a way.  Of course, it's also horribly not-funny.  I know I should get a job -- I'm more or less stuck in my life, I need some sort of external motivation.

[13:47] <theorbtwo> But I'm afraid of work, in part because I need external motivation.

[13:48] <Limbic_Region> adopt a child - having that sort of motivation will get you to do a lot

[13:48] <theorbtwo> I'm /so/ not ready for that kind of responsibility.

[13:49] <kolibrie> very rarely is one ready for responsibility - you just jump in

[13:56] *** jserv-- joined
[13:57] <Limbic_Region> theorbtwo - propose to Jess and offer to pay for the wedding

[13:57] * Limbic_Region thinks he is going to give theorbtwo a heartattack with all this potential external motivation

[13:58] *** fglock joined
[13:59] <theorbtwo> Yes, that seems quite likely.

[13:59] <svnbot6> r9896 | fglock++ | PC-Precedence - more specific tests, higher level API

[14:07] *** moscaoo joined
[14:14] *** cognominal joined
[14:15] *** vel joined
[14:15] *** autark joined
[14:16] *** justatheory joined
[14:20] *** cognominal joined
[14:24] *** justatheory joined
[14:25] *** mako132_ joined
[14:30] <Limbic_Region> anyone know who is the keeper of S29 and where the draft copy might be available for perusal?

[14:31] <Limbic_Region> dev.perl.org/perl6 says it is Rod Adams

[14:31] <Limbic_Region> last modified 2006-03-16

[14:31] <Limbic_Region> but I also seem to recall one in the Pugs repository too

[14:31] *** cognominal joined
[14:32] <Limbic_Region> nevermind - it isn't there

[14:36] *** renormalist left
[14:38] <moscaoo> How I got the sub-second?

[14:44] *** lichtkind joined
[14:45] *** cognominal joined
[14:48] <gaal> [OT] a c REPL: http://neugierig.org/software/c-repl/

[14:55] <svnbot6> r9897 | fglock++ | PC-Precedence - fixed postcircumfix

[14:58] *** penk left
[15:04] <moscaoo> How i got the "day of the year"? For example: 1 January = 0, 2 January = 1..

[15:05] <Limbic_Region> moscaoo - it sounds like you are looking for julian date

[15:05] <PerlJam> moscaoo: Jan 1 == day 1 , you're count is off :)

[15:06] <Limbic_Region> this is a perl6 channel not a perl help channel so if you want to know how to do this in perl5

[15:06] <Limbic_Region> go to #perl and ask about POSIX 'strftime'

[15:06] <Limbic_Region> and fwiw - julian day is actually wrong but it is used incorrectly enough to be considered right

[15:08] <moscaoo> [Limbic_Region] yes, julian date

[15:08] <moscaoo> how I got it?

[15:08] *** amnesiac joined
[15:08] <PerlJam> Limbic_Region: Even strftime uses %j for the julian day, so it's right enough :)

[15:09] <PerlJam> moscaoo: ask on #perl

[15:09] <Limbic_Region> moscaoo - you go to #perl and ask how to use POSIX 'strftime'

[15:09] <moscaoo> thank you

[15:09] <amnesiac> no, you better want to read about it first :P

[15:11] *** FurnaceBoy joined
[15:11] *** m joined
[15:20] *** hcarty joined
[15:22] <svnbot6> r9898 | fglock++ | pX/Common/Pugs-Grammar-Perl6 - perl6.pl - p6 grammar prototype

[15:28] *** Aankhen`` joined
[15:28] <svnbot6> r9899 | gaal++ |  r9912@sike:  roo | 2006-04-10 14:48:40 +0300

[15:28] <svnbot6> r9899 | gaal++ |  * Spec and test update: sign(undef) => fail, not undef

[15:28] <svnbot6> r9900 | gaal++ |  r9913@sike:  roo | 2006-04-11 18:24:21 +0300

[15:28] <svnbot6> r9900 | gaal++ |  * make C<sign> and C<< <=> >> fail when an argument is undefined.

[15:28] <svnbot6> r9900 | gaal++ |  * add a withDefined combinator for this kind of thing. Where else

[15:28] <svnbot6> r9900 | gaal++ |    should we put it? C< cmp > probably, for a start...

[15:34] *** hcarty left
[15:41] *** chris2 joined
[16:00] *** cjeris joined
[16:04] *** justatheory joined
[16:09] *** fglock joined
[16:13] *** lumow joined
[16:27] *** ghenry joined
[16:27] *** m_ joined
[16:27] *** m_ is now known as m

[16:32] *** vel joined
[16:33] *** vel joined
[16:35] *** colares joined
[16:36] *** cjeris left
[16:37] *** pankaj_ joined
[16:38] *** vel joined
[16:42] *** pankaj_ joined
[16:44] *** ghenry joined
[16:44] *** Odin- joined
[16:44] *** amv joined
[16:44] *** LeTo joined
[16:44] *** Juerd joined
[16:44] *** audreyt joined
[16:44] *** tewk joined
[16:44] *** Steve_p joined
[16:45] <lichtkind> can i say @primzahlen = 2,3,5,7,11,13,17,19,23; ?

[16:45] <pmurias> hi all!

[16:45] *** vel joined
[16:45] <fglock> hi!

[16:45] <Limbic_Region> I don't know - can you?

[16:46] <lichtkind> ?eval @primzahlen = 2,3,5,7,11,13,17,19,23;

[16:46] <evalbot_9900> Error: Undeclared variable: "@primzahlen"

[16:46] <lichtkind> ?eval my @primzahlen = 2,3,5,7,11,13,17,19,23;

[16:47] <evalbot_9900> [2, 3, 5, 7, 11, 13, 17, 19, 23]

[16:47] <lichtkind> seems like array with one element which is listref

[16:48] <lichtkind> ?eval my @primzahlen = (2,3,5,7,11,13,17,19,23);

[16:48] <pmurias> pugs repo should set svn:eol-style to native automaticly

[16:48] <evalbot_9900> [2, 3, 5, 7, 11, 13, 17, 19, 23]

[16:48] <lichtkind> ?eval my @primzahlen = ([2,3,5,7,11,13,17,19,23]);

[16:48] <evalbot_9900> [[2, 3, 5, 7, 11, 13, 17, 19, 23],]

[16:50] <lichtkind> thanks evalbot

[16:51] <pmurias> fglock: some file Pugs-Compiler-Tokenizer have mixed eol's, do you use the same repo in different operating systems?

[16:51] <svnbot6> r9901 | fglock++ | PC* - moved some files around

[16:51] <pmurias> s/repo/working copy/

[16:53] *** vel joined
[16:53] <fglock> pmurias: yes - I use whatever is around :)

[17:01] <pmurias> don't mind if i set eol-style to native?

[17:01] <fglock> sure

[17:02] <integral> there's a script in util/ to setup the standard properties on files

[17:03] <integral> (it [util/add-svn-props.sh] also puts a mime-type of text/plain; charset=UTF-8 on the files)

[17:03] <pmurias> why isn't it called automaticly upon file adding?

[17:04] *** marmic joined
[17:06] <svnbot6> r9902 | fglock++ | PG-Perl6 - error calling superclass

[17:06] *** pankaj_ joined
[17:06] *** lumow left
[17:08] <FurnaceBoy> pmurias, afaik, pre-commit hooks aren't allowed to modify the transaction?

[17:08] <integral> pmurias: that'd have to be wired up server side

[17:09] <FurnaceBoy> although I suppose a post-commit hook could do it

[17:13] <fglock> I've got a problem in Pugs::Grammar::Infix.pm - '$self->SUPER::method' is calling the grandparent instead of the parent class

[17:13] <integral> but unfortunately you can't access the hooks.  you have to set them up using direct access to the repository

[17:15] <kolibrie> fglock: how did that happen?

[17:17] <fglock> I'm still debugging - it's something about some modules calling each other and interaction between BEGIN blocks

[17:17] <kolibrie> nasty

[17:17] <Limbic_Region> is there somehow circular inheritence then?

[17:17] <fglock> I guess I'll just put everithing in a single module for now

[17:18] <fglock> everything

[17:18] <pmurias> intergral: who can access them?

[17:18] * Limbic_Region avoids making a very bad joke about fglock going back in time and being his own father

[17:19] *** q[uri] joined
[17:19] <fglock> yes, it looks like circular inheritance - will try to fix it

[17:19] <integral> pmurias: people who run openfoundry I guess,  but not generally just people who use them for hosting

[17:21] <Limbic_Region> fglock - out of curiosity - you are using SUPER because you have subclassed and overidden a method and need to invoke the original method from the parent right

[17:22] <fglock> yes

[17:23] <Limbic_Region> it would be interesting to know then what would happen if your subclass didn't overide the method and you let dispatch find it

[17:23] <Limbic_Region> not that it solves your problem - just seems like an interesting problem

[17:24] <kolibrie> fglock: so your current work will allow people to write a grammar in p6, compile it to p5, and obtain match objects or AST structure from p5?

[17:25] <Limbic_Region> fglock rawks

[17:25] <fglock> kolibrie: I'm doing quite a few things - Pugs::Compiler::Rule compiles Rules to p5

[17:25] <fglock> lrep compiles simple p6 to p5

[17:25] *** Qiang joined
[17:26] <fglock> the other modules compile full-p6 to AST

[17:27] <Limbic_Region> fglock - and this all "just works" - the person using your stuff doesn't need to know which to use where right

[17:27] <fglock> Limbic_Region: ?

[17:28] <Limbic_Region> I guess what I am asking is - do I need to know if I need lrep to use it

[17:29] <Limbic_Region> IOW - if I wanted to write X in p6 but have it run on p5 - do I need to know which thing(s) you are working on will accomplish that or can I just use fglock::rawks

[17:31] <kolibrie> fglock: I'm interested in general-purpose data-extraction using p6 grammars, producing some AST structure defined by the grammar

[17:31] <pmurias> kolibrie: the p6 grammars are the most mature part

[17:32] <fglock> Limbic_Region: you can use lrep to compile simple p6 to p5 - you can call methods and rules just like normal p5 code

[17:32] <Limbic_Region> that doesn't answer my question

[17:32] <Limbic_Region> how do I know what I need to use

[17:33] <fglock> kolibrie: lrep can probably compile your grammar to p5, if you only use the things that are already implemented

[17:33] <kolibrie> fglock: does it support return?

[17:33] <Limbic_Region> if I knew nothing about your projects other than they are used to run p6 code on p5 - how would I choose which pieces were right for the p6 I was writing?

[17:33] <fglock> Limbic_Region: you can use lrep to compile modules written in p6; you use P::C::R if you need rules inside your p5 code

[17:34] <fglock> kolibrie: yes

[17:34] <kolibrie> fglock: cool - I'll try to build something this afternoon

[17:35] <fglock> Limbic_Region: you can use P::C::Tokenizer or P::C::Precedence if you are writing a P6 compiler yourself

[17:36] <fglock> but P::C::Precedence can be used with AST in general

[17:36] *** pankaj__ joined
[17:37] <PerlJam> fglock: er... why are those restricted to "writing a perl6 compiler"?

[17:37] <PerlJam> fglock: specifically, P::C::P

[17:38] <PerlJam> does it have intimate knowledge of P::C::T?

[17:38] <fglock> the tokenizer is specific to p6, mostly - but the op-precedence is generic

[17:38] <PerlJam> okay, good.

[17:38] <Limbic_Region> fglock - so IOW, if lrep doesn't do the job then you are on your own but here are the tools you need to survive in the desert?

[17:38] <fglock> yes :)

[17:39] * PerlJam hands Limbic_Region a device that pulls water from N-dimensional space but forgets the instruction manual.

[17:39] <fglock> lrep is "here is a bootstrapped p6 compiler"

[17:39] *** _bernhard joined
[17:39] <fglock> the other ones are tools for building a real compiler

[17:40] <Limbic_Region> ok - I got it

[17:40] <Limbic_Region> if you want rules in p5 but want to write p5 - use X

[17:40] <Limbic_Region> if you want to write p6 and don't want to worry about how it gets to p5 - use Y but understand that it can't handle everything yet

[17:41] <Limbic_Region> if you wrote some p6 that Y couldn't handle or you are just interested in writing your own p6 compiler - use Z

[17:41] *** justathe1ry joined
[17:42] <fglock> if you want operator-precedence use W (rules are not the best tool for this)

[17:42] <PerlJam> The time isn't quite ripe yet (IMHO), but it would make for an interesting article on perl.com (or elsewhere) to explain all of the tools that has come from parrot/pugs/perl6

[17:42] <PerlJam> Just a survey article "here are all of the tools"

[17:42] <PerlJam> then later, as the technology matures, some "here's how to use tool X" artricles.

[17:43] <Limbic_Region> fglock - I asked the way I did (like an idiot) mostly because I wanted to write a follow up perlmonks node on the matter and partly because I am an idiot

[17:43] <fglock> which node?

[17:44] <Limbic_Region> saying that you can do p6 on p5 today without some more specific instructions is unlikely to draw any attention

[17:44] <Limbic_Region> http://perlmonks.org/index.pl?node_id=534224

[17:45] * Limbic_Region doesn't think the Perl6:: modules on CPAN today are used very much so why would this be any different

[17:45] <fglock> I think the important points are - we have a bootstrapped compiler (and we can now work on a more complex one); and - you can help even if you only know perl5

[17:46] <fglock> compiling p6 to p5 is a byproduct

[17:46] <Limbic_Region> fglock - well, what you sell and how you sell all depends on your target consumer

[17:47] <Limbic_Region> I'm not a marketing guy but I know what it takes for me to open the wallet

[17:49] * PerlJam idly wonders if anyone will recast the parser in HOP in terms of perl6 (or at least one of the bootstraps :-)

[17:51] <fglock> the parser in PCR look a lot like the one in HOP - and that's a coincidence

[17:51] <kolibrie> PerlJam: I thought someone already did: examples/hop6/Parser.pm

[17:51] <PerlJam> kolibrie: oh did they?  I haven't even looked.

[17:52] <fglock> bbiab &

[17:52] <PerlJam> fglock: I don't think it's so much of a coincidence if you understand the concepts elucidated in HOP

[17:59] *** ruoso joined
[18:00] *** pankaj__ is now known as spo0nman

[18:02] *** KingDiamond joined
[18:03] *** cognominal joined
[18:24] <fglock> back

[18:25] *** larsen joined
[18:28] <pmurias> is there a way to trace how Inline::C compiles stuff?

[18:29] <Limbic_Region> pmurias - IIRC there are flags for that

[18:30] <Limbic_Region> you can even make it so it doesn't remove the temprorary work in progress

[18:31] * Limbic_Region tries to find it

[18:31] <pmurias> found them

[18:32] <pmurias> thanks

[18:33] * Limbic_Region used them to have Inline::C write his XS for him (the easy way)

[18:35] <pmurias> ordering Inline to print the details of the compile, made it give up,and solve the problem by itself

[18:36] *** mako132_ joined
[18:39] <Limbic_Region> heh - It was a heisenbug then

[18:39] <svnbot6> r9903 | fglock++ | Pugs-Grammar-Perl6 - tokenizer works for both operators and operands;

[18:39] <svnbot6> r9903 | fglock++ | generates the operator precedence table

[18:40] *** david__ joined
[18:45] *** chris2_ joined
[18:49] <pmurias> Inline::C dosn't want to bind functions which return Parrot_Interp(dispite passing the typemap file mapping it with TYPEMAP

[18:49] <pmurias> )

[18:50] <pmurias> TYPEMAPS actually

[18:52] *** p5evalbot joined
[18:53] <pmurias> fixed the bug used void in the parameter list

[19:00] <svnbot6> r9904 | fglock++ | Pugs-Grammar-Perl6 - fixed long-names

[19:09] <svnbot6> r9905 | fglock++ | Pugs-Grammar-Perl6/perl6.pl - the expression compiler works

[19:10] <fglock> that's the 3-layer perl6 compiler working :)

[19:11] <kattana_> :) fglock++

[19:11] <fglock> it still needs a lot of refactoring - the code is scary

[19:15] <Limbic_Region> scary or ugly?

[19:15] <Limbic_Region> and flgock++

[19:17] <fglock> both - perl6.pl is the prototype - now it needs to be separated into modules

[19:17] <fglock> bbiab &

[19:20] *** nothingmuch joined
[19:21] *** lichtkind joined
[19:22] <kolibrie> fglock++ # 3-layer perl6 compiler works

[19:27] <ruoso> fglock++

[19:29] *** chris2 joined
[19:34] <fglock> back

[19:34] *** nothingmuch_ joined
[19:35] <fglock> ruoso: hi!

[19:40] <ruoso> fglock, hi...

[19:42] <ruoso> fglock, does this code already emits perl 5 code?

[19:43] <ruoso> it looks like it does

[19:44] * ruoso is sad he doesn't have the time to play with it... :(

[19:44] <fglock> ruoso: it generates AST only - actually, it generates perl5 code for compiling p6

[19:44] <fglock> but it doesn't do AST->perl5

[19:44] <ruoso> hhmmm so it's still Perl 6 AST

[19:46] <fglock> yes - but it can compile much more complex expressions than lrep does

[19:46] <ruoso> fglock, nice...

[19:47] <ruoso> but we still need a "Perl 6 AST -> Perl 5 AST" converter (we actually need to define what "Perl 5 AST" means)

[19:47] <ruoso> or do you plan to use it to generate PIR?

[19:47] <fglock> now you can build extendable languages - like, you can define new precedence levels in the rule compiler

[19:48] *** avarab_ is now known as avarab

[19:48] *** Cyrup joined
[19:49] <fglock> ruoso: currently, it is a development platform for the p6 grammar - the objective is to define a single grammar that can be used by ghc-pugs, and pge-parrot

[19:49] <fglock> it's intentionally modular - so everithing after the AST will be done by other modules

[19:49] <fglock> everything

[19:50] <fglock> it would be nice if even the existing modules could be pluggable

[19:54] <fglock> also, Pugs::Compiler::Perl6 doesn't aim to be self-hosting - but it can be translated to p6 later

[19:54] <svnbot6> r9906 | fglock++ | PG-Perl6 - Pugs/Grammar/Expression.pm - encapsulates the expression parser

[19:58] <ruoso> as soon as I have some free time, I'll try to play with languages/perl6 inside parrot...

[19:59] <mugwump> we'll really be getting close to a p6 pre-alpha soon

[19:59] <mugwump> one these grammars are used by pge on parrot etc

[19:59] * ruoso wishes he could have more free time...

[20:00] <ruoso> mugwump, in theory the grammars fglock is writing can be used inside PGE...

[20:00] <ruoso> s/inside/with/

[20:01] <mugwump> ruoso: yes, as I mentioned in my talk last night to Wellington.pm (utsl.gen.nz/talks/perl6.now)

[20:01] <svnbot6> r9907 | fglock++ | PG-Perl6 - Pugs::Grammar::Expression->parse( q(10 + $a / "abc") )

[20:01] <svnbot6> r9907 | fglock++ | returns a match with AST

[20:01] <fglock> ruoso: try Pugs-Grammar-Perl6/perl6.pl

[20:04] * ruoso running make in all Pugs-.+-.+

[20:08] <ruoso> fglock, impressive...

[20:09] <ruoso> but it looks a lot like an optree

[20:09] <fglock> and it is completely modular and extendable :)

[20:09] <ruoso> :)

[20:09] <fglock> you can change the AST at will

[20:09] <fglock> this is just what I need for testing

[20:10] <ruoso> fglock++

[20:10] * justathe1ry is learning Ruby

[20:10] *** justathe1ry is now known as justatheory

[20:11] <fglock> the plan is to have the AST in a separate module - but I'm not sure how to link modules together yet - maybe I'll use a compiler factory

[20:11] <ruoso> fglock, I don't think you need to have such thing... let people write their compilers choosing from a set of individual modules

[20:11] <justatheory> I'm trying to remember, does Perl 6 have something like Ruby's symbols/

[20:13] <fglock> ruoso: it may be useful to have a default compiler in which you just say my $compiler = Compiler->new( rule_ast => 'mymodule' ) - but this is just syntax sugar

[20:14] <ruoso> fglock, you can provide it as yet another separated module...

[20:14] <ruoso> it doesn't need to be part of the rest

[20:15] <fglock> yes, but you need to tell the compiler to use the other module instead of the default

[20:17] <ruoso> hmm.... maybe you want to delimit better each layer...

[20:17] <ruoso> in theory you should have A -op1-> B -op2-> C -op3-> D

[20:17] <justatheory> ruoso: ah, cool.

[20:18] <ruoso> I mean, each part should receive an input, return an output and that's all...

[20:18] <svnbot6> r9908 | fglock++ | PG-P6 - added tests for the expression parser

[20:19] <ruoso> and then you can combine any implementation of op1,op2 and op3 to make a X -> Y compiler

[20:20] <fglock> ruoso: the matching and ast generation are kind of glued together by using return-blocks

[20:20] <fglock> but I'm making it modular by using callbacks

[20:21] <ruoso> hmmm...

[20:22] <ruoso> wouldn't it be better to have the match returning just the match... and feeding the match to a match2ast module?

[20:23] <ruoso> I mean... Perl 6 -matcher-> P6Match -match2ast-> P6AST

[20:23] <fglock> it's much more complex - that's how parrot/TGE would work

[20:24] <fglock> but audreyt is the right person to ask

[20:25] <ruoso> yes... that's MATCH -> PAST -> POST -> PIR

[20:27] <ruoso> but separating the match from ast building can make it easier to detect dialects that can be represented in a smarter way in the ast...

[20:33] *** vel joined
[20:33] <pmurias> ruoso: hi

[20:36] <ruoso> pmurias, hi

[20:36] <svnbot6> r9909 | fglock++ | PC-P6 - new module Pugs/Grammar/StatementControl.pm

[20:43] *** larsen_ joined
[20:51] <svnbot6> r9910 | fglock++ | PG-P6 - added non-working test for statement-control

[20:54] <fglock> audreyt, TimToady: what's the plan for detecting end-of-expression? like in 'if 1+1 {...}' - is it the space+'{' delimiter?

[20:59] * ruoso hopes the parenthesis are allowed only for expressions that doesn't contain blocks...

[21:00] <ruoso>  /parenthesis/non-parenthesis/

[21:00] <ruoso> it would be weird to have if {block condition} {run block}

[21:00] <mugwump> isn't it just: if EXPR BLOCK

[21:01] <ruoso> is a block an expression?

[21:03] <ruoso> if $a = { closure } { block }

[21:04] <TimToady> space + block is a top-level block only where an operator is expected, and you're not in brackets.

[21:05] <TimToady> where a term is expected, it's just a closure argument.

[21:05] <TimToady> (or a hash composer)

[21:05] *** SamB joined
[21:05] *** Southen_ joined
[21:05] *** azuroth joined
[21:05] <pmurias> if {block condition} {run block} is the tcl wat

[21:06] <pmurias> s/wat/way/

[21:06] <TimToady> early Perl had "if BLOCK BLOCK" but we eventually deprecated it.

[21:07] <ruoso> but... should 'if { a => 1 } { block }' work?

[21:08] *** FurnaceBoy_ joined
[21:08] <TimToady> a hash is true if it has any entries in it, so sure.

[21:08] <TimToady> On the other hand, we haven't given an ordinary bare closure any kind of boolean value.

[21:09] <ruoso> so... if { my $a = 1; print $a } { my $a = 2; print $a } is valid

[21:09] <TimToady> so you'd have to write "if do { $retval } { block }" for that.

[21:10] <ruoso> I know it would probably do nothing...

[21:10] <ruoso> but it's still valid syntax...

[21:10] <TimToady> if a bare closure has any kind of boolean value, it'd probably be true if defined.  You need "do" to call it, or .() after.

[21:11] <TimToady> Yes, the question is whether it has any useful semantics.

[21:11] <ruoso> well... if you have how to get it later... maybe...

[21:12] <mugwump> TimToady: is there a brief answer to when {} is a block and when it's a hash constructor?

[21:12] <ruoso> at least for an obfu

[21:12] <TimToady> Probably should give you "Useless use of a closure in boolean context" or some such.

[21:12] <mugwump> someone asked me that last night, and I said I didn't know

[21:12] <TimToady> basically if the top level looks like a list of pairs.

[21:13] <mugwump> is that look-ahead?  or is a block that returns just pairs automatically a hash constructor?

[21:13] <mugwump> (I guess perl5 map { } already does something like this)

[21:14] <TimToady> A bare block that just returns pairs is turned into a hash composer, basically.

[21:14] <mugwump> what about an empty list of pairs?

[21:14] *** vel joined
[21:14] <mugwump> my $foo = {}

[21:15] <mugwump> or my $foo = {function()}, where function() returns a list of pairs

[21:15] <TimToady> I believe it defaults to hash in the absence of evidence to the contrary.

[21:15] <TimToady> no, it has to syntactically be a list of pairs, (or at least the first list item has to be a pair).

[21:16] <TimToady> if it's too ambiguous, you should just use hash() instead.

[21:16] <theorbtwo> So does it default to hash in the absense of evidence to the contrary, or must it be syntactically a list of pairs?

[21:16] <theorbtwo> They seem in direct conflict.

[21:18] <TimToady> It's possible to fudge it so it works out.  "do {}" is evidence to

[21:18] <TimToady> the contrary.

[21:18] <TimToady> as is {}.()

[21:19] <TimToady> A bare {} is assumed to be hash, but we can also give it a polymorphic interface to .() that does nothing.

[21:19] <TimToady> the important thing is that

[21:19] <TimToady> $x = {};

[21:19] <TimToady> $x<foo> = 1;

[21:19] <TimToady> works.

[21:20] <ruoso> should $x = {}; $x.() also work???

[21:20] <TimToady> Isn't that what I just said?

[21:20] <ruoso> yes... just to be sure...

[21:21] <TimToady> you don't have to allow for extensibility of the Code role, unlike the Hash role

[21:21] <mugwump> heh, so {} both .does(Code) and .does(Hash)... sick, I like it

[21:21] <TimToady> one could go as far as to disable the Code role as soon as you know it's a hash.

[21:22] <TimToady> but there doesn't seem to be much point.

[21:22] <ruoso> or as soon it's assigned to a var that is a hash

[21:22] <TimToady> bound, I assume you mean.

[21:22] <ruoso> yes

[21:22] <ruoso> sorry

[21:23] * ruoso is used to some portuguese terms that conflict...

[21:23] <TimToady> Maybe all hashes respond to .(), and empty hashes just happen to return undfe.

[21:23] <TimToady> *undef

[21:24] <ruoso> hmm... after all { a => b } can be understood as a closure that returns a pair... oooo...

[21:24] <TimToady> maybe all Hashes and Arrays do generalized list comprehensions with the .() interface.

[21:24] <TimToady> But that doesn't square entirely with Capture objects.

[21:25] <mugwump> hey, btw, I ended up talking about the new inline/multiline comments thing to Wellington.pm...

[21:26] <TimToady> I hope you told them how ugly it is.  :)

[21:26] <mugwump> and got groans when I mentioned 'except in the first column', and some smart aleck came up with some idea about adding a trailing # :)

[21:27] * avar likes inline comments;)

[21:27] <mugwump> but hey, all's fair if you predeclare 'n' all

[21:27] <TimToady> right-o

[21:27] <avar> But I don't think they'd fit well into the Perl 6 syntax

[21:28] <mugwump> avar: backlog for the flames

[21:28] <TimToady> Er...

[21:28] <mugwump> or refer p6l discussion

[21:28] <avar> mugwump: I know

[21:28] <TimToady> Or just read S02.

[21:28] <pmurias> good night

[21:29] <TimToady> sweet dreams

[21:29] <avar> I sometimes use them in C when I have something like if (foo() || bar()) which I turn into if (/*foo() ||*/bar()) while debugging ;)

[21:29] <mugwump> yeah, that's one handy use for them

[21:33] <sri_> stevan: ping

[21:33] * sri_ wants a new Moose

[21:34] <mugwump> sri_: what's wrong with Moose at the moment?  Missing higher order types?

[21:34] <sri_> missing roles

[21:34] <mugwump> 0.03_01 has them

[21:34] <mugwump> https://pause.perl.org/incoming/Moose-0.03_01.tar.gz

[21:35] <mugwump> apparently cpan isn't replicating it or something

[21:35] <sri_> not found

[21:35] <mugwump> or you can pull "cpan" branch from git://utsl.gen.nz/Moose

[21:35] <mugwump> (that's my repo, not his :))

[21:35] <sri_> i'd prefer a tarball :)

[21:36] <mugwump> http://www.utsl.gen.nz/pm/Moose-0.03_01.tar.gz

[21:37] <stevan> sri_: you can ask in #moose too :)

[21:37] <sri_> mugwump++

[21:37] <stevan> sri_: roles are incomplete though

[21:38] <sri_> hope it's complete enough fwiw

[21:38] <stevan> sri_: wdyw?

[21:38] <sri_> i tell you once i know :)

[21:38] <stevan> :)

[21:39] <stevan> sri_: ping me in #moose if it doesnt do what you want, and we can talk

[21:39] * stevan wanders off to eat some dinner 

[21:40] <sri_> stevan++

[21:41] <avar> dinner++

[21:49] <svnbot6> r9911 | fglock++ | PG-P6 - StatementControl.pm - parses bare block

[21:51] <fglock> what category '<expression>?;' belongs to?

[21:57] <TimToady> don't understand what you're asking...

[21:58] <fglock> is there a category for plain-statement?

[21:58] <TimToady> expression is one of the things in statement_control perhaps?

[22:02] <fglock> I'll try to use it as statement_control

[22:12] <fglock> later &

[22:12] <svnbot6> r9912 | fglock++ | PG-P6 - added a failing test for 'statement;'

[22:15] *** fglock left
[22:16] *** Limbic_Region joined
[22:25] *** tri joined
[22:26] *** mako132_ joined
[22:34] <tewk> ™

[22:34] <tewk> ™™¡

[22:49] <Juerd> ¿™?

[23:03] * mugwump has ™ bound to AltGr+Shift+8 on his keyboard :)

[23:25] *** ruoso joined
[23:25] * ruoso starting to play with languages/perl6 in parrot...

[23:26] * ruoso having to debootstrap debian unstable to get prebuild parrot...

[23:26] <ruoso> s/prebuild/prebuilt/

[23:27] <TimToady> parrot builds rather rapidly (compared to Pugs).

[23:27] <mugwump> and ghc6

[23:27] <avar> TimToady: what doesn't?;)

[23:28] <mugwump> OpenOffice ?  :)

[23:28] <ruoso> OpenOffice has 200Mb source

[23:28] <ruoso> (ok... that probably includes artwork)

[23:29] <mugwump> the OOo build takes something like 8 hours on a reasonably well equipped amd64

[23:29] *** Cyrup left
[23:30] <avar> Ugh, OO

[23:30] <avar> Does it still need tcsh to build?

[23:30] <ruoso> worse... it needs java

[23:31] <ruoso> fortunally gcj is sufficient...

[23:34] * ruoso wonder where is Parrot::Config

[23:34] <ruoso> I could find Parrot::Configure

[23:34] <ruoso> but not Config

[23:35] *** ruoso left
[23:35] *** ruoso joined
[23:41] * ruoso realizes Parrot::Config should be one result of the build process...

[23:42] * ruoso also realizes the debian maintainer didn't include it in the final package...

[23:44] * ruoso will rebuild parrot and submit a bug report... sigh...

[23:46] <ruoso> rafl, ping

[23:46] <ruoso> nice to have the maintainer around :)

[23:47] <TimToady> I'd go ahead and build bleedparrot--they seem to keep it pretty clean, and I always run pugs against the latest parrot.

[23:48] <ruoso> hmm... debian version is still 0.4.2...

[23:49] <ruoso> that's bad...

[23:49] <TimToady> most days parrot passes 100% of its tests.

[23:50] <TimToady> in a few minutes I can tell you whether today's bleedparrot passes.

[23:50] <ruoso> hmm... that would be really nice...

[23:51] <ruoso> but

[23:51] <ruoso> 0.4.3 is quite recent...

[23:51] <ruoso> less than 10 days

[23:52] <ruoso> it wouldn't hurt...

[23:52] <ruoso> i think

[23:53] <TimToady> r12178 (today) at least passes all pge, I can tell you.

[23:54] <TimToady> All tests successful, 8 tests and 354 subtests skipped.

[23:54] <TimToady> Files=230, Tests=4650, 317 wallclock secs (148.74 cusr + 47.46 csys = 196.20 CPU)

[23:54] <ruoso> ok... I'll take it...

[23:55] <ruoso> rafl, do you think it makes sense to have a parrot-svn package?

[23:56] <ruoso> rafl, if you want help on the parrot package I can package the 0.4.3...

[23:56] <ruoso> in the meanwhile

[23:56] <ruoso> I'll build r12178

[23:56] <arcady> I'd say most people are still getting it from svn and building themselves

[23:56] <ruoso> I'm the lazy type...

[23:57] <TimToady> I build it pretty much every day.

[23:57] <ruoso> if it's in debian I prefer taking it...

[23:57] <TimToady> It's not clear that the monthly builds are any cleaner on average...

[23:57] <ruoso> 0.4.3 is just a monthly build?

[23:57] <TimToady> basically

[23:58] <ruoso> hmmm... that changes everything...

[23:58] <TimToady> all you really know is that it built cleanly on leto's machine.

[23:58] <ruoso> ok...

[23:58] <TimToady> though I suppose he might have more than one he tries it on.

[23:59] *** mako132_ joined
