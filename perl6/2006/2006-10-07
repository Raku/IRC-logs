[00:06] *** mjk joined
[00:12] *** discordja joined
[00:30] *** Qiang joined
[00:34] <svnbot6> r14011 | audreyt++ | * Massive round of unTODO now that references don't recursively autoderef.

[01:12] *** awwaiid joined
[01:15] <pasteling> "TimToady" at 71.139.13.112 pasted "Can't "make profiled"" (217 lines, 15.2K) at http://sial.org/pbot/20236

[01:15] <TimToady> audreyt: see above

[01:16] <TimToady> a "realclean" doesn't help, nor does making fastprof.

[01:16] <TimToady> blowing away and restoring the HsSyck and HsJudy subtrees doesn't help.

[01:16] <TimToady> I'd really like to be able to figure out why my 10 hr program is 98.9% GC.

[01:17] <TimToady> which means it ought to run in 6 minutes...

[01:18] *** mako132 joined
[01:20] <audreyt> TimToady: your GHC itself is not profiled

[01:20] <audreyt> if installed via some rpm, look in the same source for a -prof package

[01:20] <audreyt> 98.9% GC sounds very, very wrong

[01:20] <audreyt> ./pugs-prof with +RTS -p

[01:20] <audreyt> will indeed show the cost centre

[01:21] <audreyt> but I need to run to @@family for $mid_autumn

[01:21] <audreyt> will continue triage on the way but will only have intermittent wifi...

[01:23] <audreyt> and I'll see if I can fix the "no compatible" peeve

[01:23] <audreyt> have fun! &

[01:23] <TimToady> thank!

[01:23] <TimToady> have -Ofun

[01:24] <TimToady> maybe it's time to install 6.6, sigh...

[02:02] *** SubStack joined
[02:07] *** Daveman joined
[02:13] *** markstos_ joined
[03:14] *** SubStack_ joined
[03:21] *** weinig is now known as weinigSleep

[03:34] *** SCalimlim joined
[03:45] *** justatheory joined
[03:46] *** beppu joined
[04:01] *** badalex joined
[04:03] *** sri_ joined
[04:24] *** SubStack_ is now known as SubStack

[05:16] *** BooK joined
[05:41] *** iblechbot joined
[05:48] *** lisppaste3 joined
[06:07] *** Salzh joined
[06:51] *** Psyche^ joined
[06:58] *** Psyche^ is now known as Patterner

[07:09] *** kanru joined
[07:11] *** iblechbot joined
[07:31] *** gnuzoo joined
[07:32] *** gnuzoo left
[07:44] *** SubStack joined
[09:00] *** elmex joined
[09:05] *** jferrero joined
[09:17] *** kane-xs joined
[09:28] *** masak joined
[09:44] *** pmurias joined
[09:49] <pmurias> OT: is someone intrested here in js/AJAX work here?

[09:51] <pmurias> eq. porting a site from a custom solution to using google maps?

[09:51] *** chris2 joined
[09:53] <pmurias> s/eq./specificly/

[09:54] <pmurias> s/in/in doing paid/

[09:54] <pmurias> s/last ?//

[10:13] *** larsen joined
[10:45] *** stennie left
[10:47] *** stennie joined
[11:08] *** b_jonas joined
[11:28] *** markstos joined
[11:29] *** norageek joined
[11:30] <audreyt> rehi

[11:30] <audreyt> I rewrote Pugs.Monad ;)

[11:30] <audreyt> all control exceptions work now

[11:30] *** turrepurre joined
[11:30] <audreyt> @tell Limbic_Region I managed to fix your desired "next/last in a sub" semantics.

[11:30] <lambdabot> Consider it noted.

[11:48] *** norageek joined
[11:57] *** postgre joined
[11:57] *** postgre left
[11:59] *** weinigSleep is now known as weinig

[12:02] <svnbot6> r14012 | audreyt++ | * Pugs.AST.Internals: Add three variants to VControl:

[12:02] <svnbot6> r14012 | audreyt++ |     ControlLoop: redo/next/last

[12:02] <svnbot6> r14012 | audreyt++ |     ControlGiven: break/continue

[12:02] <svnbot6> r14012 | audreyt++ |     ControlLeave: leave/return/yield

[12:02] <svnbot6> r14012 | audreyt++ |   All nonlocal control are now unified to use VControl.

[12:02] <svnbot6> r14012 | audreyt++ | * Also the envDepth slot is changed from a Int into a [Frame],

[12:03] <svnbot6> r14012 | audreyt++ |   to distinguish Routine/Loop/Given frames that captures different

[12:03] <svnbot6> r14012 | audreyt++ |   kinds of Control structures, so we can meaningfully raise exceptions

[12:03] <svnbot6> r14012 | audreyt++ |   when the program attempts to raise a control exception that won't be

[12:03] <svnbot6> r14012 | audreyt++ |   recognized.

[12:03] <svnbot6> r14012 | audreyt++ | * Bump CompUnit version because of the envDepth change.

[12:03] <svnbot6> r14013 | audreyt++ | * regen Instances.

[12:03] <svnbot6> r14014 | audreyt++ | * Closure traits in bare-do-once blocks is now recognized:

[12:03] <svnbot6> r14014 | audreyt++ |     use v6;

[12:03] <svnbot6> r14014 | audreyt++ |     {

[12:03] <svnbot6> r14014 | audreyt++ |         ENTER {...}

[12:03] <svnbot6> r14014 | audreyt++ |         LEAVE {...}

[12:03] <svnbot6> r14014 | audreyt++ |     }

[12:03] <clkao> mmmmmmmmmm

[12:06] *** avar joined
[12:06] <svnbot6> r14015 | audreyt++ | * Pugs.Monad: The generalized enterSub now sets a resetT

[12:06] <svnbot6> r14015 | audreyt++ |   barrier for both routines and blocks, and enforces various

[12:06] <svnbot6> r14015 | audreyt++ |   closure traits on them.

[12:06] <svnbot6> r14015 | audreyt++ | * Support for PRE/POST design-by-contract assertions.

[12:06] <svnbot6> r14015 | audreyt++ | * Support for KEEP/UNDO blocks, with the provision that

[12:06] <svnbot6> r14015 | audreyt++ |   "return 1" is counted as KEEP, not UNDO.  (The spec

[12:06] <svnbot6> r14015 | audreyt++ |   is not clear on this, but agentzh++'s test wants this

[12:06] <svnbot6> r14015 | audreyt++ |   behaviour.)  They are now interleaved as part of the

[12:06] <svnbot6> r14015 | audreyt++ |   LEAVE queue as specced.

[12:06] <svnbot6> r14016 | audreyt++ | * Pugs.Internals: Add a "finallyM" helper to consolidate

[12:06] <svnbot6> r14016 | audreyt++ |   the common pattern noticed by gaal++ a while ago:

[12:06] <svnbot6> r14016 | audreyt++ |     rv <- actionA

[12:06] <svnbot6> r14016 | audreyt++ |     actionB

[12:06] <svnbot6> r14016 | audreyt++ |     return rv

[12:06] <svnbot6> r14016 | audreyt++ |   is now written as:

[12:06] <svnbot6> r14016 | audreyt++ |     actionA `finallyM` actionB

[12:09] <svnbot6> r14017 | audreyt++ | * Pugs.Parser.Types: Keep KEEP/UNDO blocks in their slots still,

[12:10] <svnbot6> r14017 | audreyt++ |   because some day we may want to introspect them with

[12:10] <svnbot6> r14017 | audreyt++ |   &code.KEEP or some such.  However, they are now also added to

[12:10] <svnbot6> r14017 | audreyt++ |   the LEAVE queue, to preserve their relative ordering.

[12:13] <svnbot6> r14018 | audreyt++ | * Pugs.Run: Obsolete the &?BLOCK_EXIT hack now that control

[12:13] <svnbot6> r14018 | audreyt++ |   exceptions can express given/when controls better.

[12:13] <svnbot6> r14019 | audreyt++ | * Pugs.Prim.Eval: INIT blocks should be run as soon as eval""

[12:13] <svnbot6> r14019 | audreyt++ |   finishes compilation:

[12:13] <svnbot6> r14019 | audreyt++ |     eval "INIT { ... }"

[12:13] <svnbot6> r14019 | audreyt++ |   ditto for INIT blocks in modules.

[12:16] <svnbot6> r14020 | audreyt++ | * Pugs.Prim: Add "&leave" to leave a block, "&break" to break

[12:16] <svnbot6> r14020 | audreyt++ |   out of a "given", and "&continue" to break out of a "when".

[12:16] <svnbot6> r14020 | audreyt++ | * Also update various control primitives to use VControl consistently.

[12:16] <svnbot6> r14021 | audreyt++ | * Pugs.Parser: do{...}, loop{...}, given{...}, when{...} and

[12:16] <svnbot6> r14021 | audreyt++ |   default{...} can all admit closure traits in their body now.

[12:16] <svnbot6> r14021 | audreyt++ | * Also permit this form:

[12:16] <svnbot6> r14021 | audreyt++ |     given EXPR -> $x { ... }

[12:16] <svnbot6> r14021 | audreyt++ |   by unifying the parser rules for "given" and "for".

[12:17] <svnbot6> r14021 | audreyt++ |   (This is unspecced but seems useful enough.)

[12:20] <svnbot6> r14022 | audreyt++ | * Pugs.Eval: Rewrite the various loop structures to fully

[12:20] <svnbot6> r14022 | audreyt++ |   support closure traits, as well as control exceptions

[12:20] <svnbot6> r14022 | audreyt++ |   raised under other lexical scopes:

[12:20] <svnbot6> r14022 | audreyt++ |     sub my_last { last }

[12:20] <svnbot6> r14022 | audreyt++ |     while 1 { my_last }         # this now works

[12:20] <svnbot6> r14022 | audreyt++ |     while 1 { eval 'my_last' }  # even this works

[12:20] <svnbot6> r14023 | audreyt++ | * Prelude.pm: &eval no longer default to $_ as the code,

[12:20] <svnbot6> r14023 | audreyt++ |   which means "eval()" no longer works; write ".eval" instead.

[12:20] <svnbot6> r14024 | audreyt++ | * enter_leave.t: Correct an off-by-one misassumption in the test.

[12:23] <svnbot6> r14025 | audreyt++ | * first.t: Another off-by-one error in test.

[12:23] <svnbot6> r14026 | audreyt++ | * keep_undo.t: The test was assuming "return 0" is UNDO.

[12:23] <svnbot6> r14026 | audreyt++ |   That is not so; only "return undef" is UNDO.

[12:23] <svnbot6> r14026 | audreyt++ |   (It now all passes after this correction.)

[12:23] <svnbot6> r14027 | audreyt++ | * next.t: Change unneccessary eval'' to try{}, and add test descriptions.

[12:25] <svnbot6> r14028 | audreyt++ | * given.t: Correct several test misassumption, including

[12:25] <svnbot6> r14028 | audreyt++ |   confusion of next vs continue.

[12:25] <svnbot6> r14028 | audreyt++ | * Also, this form seems unspecced:

[12:25] <svnbot6> r14028 | audreyt++ |     given EXPR {

[12:25] <svnbot6> r14028 | audreyt++ |         # Supposedly means ~~EXPR1 _or_ ~~EXPR2

[12:25] <svnbot6> r14028 | audreyt++ |         when EXPR1, EXPR2 { ... }

[12:25] <svnbot6> r14028 | audreyt++ |     }

[12:25] <svnbot6> r14028 | audreyt++ |   So change it instead to a nested when.

[12:25] <svnbot6> r14029 | audreyt++ | * default_scalar.t: "say $out," is bogus; change it to "$out.say()".

[12:26] *** elmex joined
[12:27] *** wilx_ joined
[12:27] <svnbot6> r14030 | audreyt++ | * Massive unTODO of now-passing tests.

[12:46] <clkao> were you actually having family meal?

[12:46] <audreyt> I was

[12:47] <audreyt> but some extend family members arrived late

[12:47] <audreyt> so I hacked a while

[12:47] <audreyt> then I hacked some more whilst they were having this absurd barbeque thing.

[12:48] * audreyt still doesn't understand why barbeque somehow got associated with midautumn in the last decade

[12:48] <clkao> @@family[1..*]

[12:49] <clkao> it's just like how daimond got associated with wedding

[12:49] *** discordja joined
[12:50] <audreyt> but there's no De Beers for barbeque

[12:56] *** xinming joined
[12:58] <svnbot6> r14031 | audreyt++ | * Reduce standalone blocks even if nested:

[12:58] <svnbot6> r14031 | audreyt++ |     { { { say 3 } } }

[12:58] <svnbot6> r14032 | audreyt++ | * Pugs.Parser: Remove the special AST nodes for postfix:for

[12:58] <svnbot6> r14032 | audreyt++ |   and postfix:given.

[13:01] <svnbot6> r14033 | audreyt++ | * fix plan for next.t

[13:02] <elmex> elmex++

[13:02] <perlbot> What kind of idiot karmas himself?  Your kind of idiot!

[13:02] <elmex> perlbot: die;

[13:03] <markstos> perlbot++

[13:05] <svnbot6> r14034 | audreyt++ | * Pugs.Eval: "loop { next }" now works correctly.

[13:06] <audreyt> t/ space nearly done; I'll take a break and finish ext/ space tomorrow

[13:06] <svnbot6> r14035 | audreyt++ | * Er, oops, misfixed the plan.

[13:10] <elmex> perlbot--

[13:12] *** putter joined
[13:13] <putter> svnbot++ audreyt++ delightful to start the day seeing impressive progress...

[13:13] <audreyt> putter: greetings. I've gott a 4-day stretch for pugs and not $job, thanks to this national holiday thing

[13:13] <elmex> elmex--

[13:13] <putter> holidays++ ;)

[13:14] <audreyt> re 1/2 of me: yeah, that's very true, but well, c'est la vie. :)

[13:14] <elmex> sex++

[13:14] <audreyt> at least $job let me take monthlong vacations every season or so

[13:15] <putter> there just *has* to be a better way... :/

[13:16] <audreyt> also Moose already rolled into $job

[13:16] <audreyt> as is lots of haskell stuff

[13:17] <audreyt> pugs with p5embed is finally useful enough such that next project I'll try to roll in straight #!/usr/bin/pugs parts

[13:17] <audreyt> if that happens, it'd perhaps give better motivation on making pugs non-toy enough for practical work

[13:18] <putter> "language development as funding bootstrap", intriguing

[13:18] <audreyt> (this is re: TimToady's "Haskell is a Really Big toy, but still a toy", as it lacks lots of things that are important to field hackers but irrelevant to researchers)

[13:19] <audreyt> which is also changing, not because haskell.org got some funding, but several key hackers on #haskell found ways to write $job stuff with it and fix broken parts

[13:20] <putter> "perl6 is the mechanism by which haskell, finally, takes over the world"

[13:20] <markstos> audreyt: I'll be publishing some updated docs on Perl5 embedding syntax soon. Basically, a prose version of t/perl5/basic.t tests I added recently.

[13:20] <audreyt> markstos: woot. that will be very helpful

[13:21] <putter> any chance of a haskell-next switching from monads to arrows?

[13:22] <markstos> I'm happy with the functionality pugs has now (well, OO needs a little work), I see performance as the key thing.

[13:22] <audreyt> putter: GHC 6.6 already has Control.Applicative as the base control structure in the base lib

[13:23] <audreyt> putter: which gives you what arrow is practically used for (increased sharing) with a more familiar syntax (inspired by parsec)

[13:23] <putter> will look.  tnx.

[13:23] <audreyt> good thing is that it's all library space :)

[13:24] <putter> lol :)

[13:24] <audreyt> I don't have much experience with applicatives yet; I still havn't checked out what are those strong lax monoidal functors

[13:24] <audreyt> the relevant paper is apparently http://www.soi.city.ac.uk/~ross/papers/Applicative.html

[13:25] <lambdabot> Title: Applicative Programming with Effects, http://tinyurl.com/zjmbp

[13:25] <putter> p5embed cabalizable?

[13:25] <audreyt> already done as AntiBuddha

[13:25] <audreyt> looked to merge codebase but havn't got the tuits

[13:25] <putter> lol :loudly

[13:31] * putter finally finds ghc release cycle status...

[13:31] <audreyt> markstos: the naive interpreter probably won't ever be as fast as perl5; codegen is definitely needed, the question is more like which VM to focus targetting on. Targetting GHC takes least effort; targetting Perl5 is also fun; either one should give reasonable performance

[13:31] <putter> 6.6 apparently still churning

[13:32] <audreyt> putter: yeah, I'm semiracing against that :)

[13:32] <putter> :)

[13:32] <markstos> audreyt: Thanks for the details. We can also expect that computers will keep getting faster. :)

[13:33] <audreyt> markstos: or the compiler keeps getting faster...GHC -head alone gives some 10% boost against 6.6

[13:33] <markstos> It also seems like on the web, there's a trend for all languages to use solutions like mod_perl, FastCGI, etc so we can write easier code on top of increasingly complex stacks.

[13:33] <audreyt> nodnod.

[13:34] <audreyt> really need to sleep now. some triaging (e.g. take a look at why ext/ fails are failing) will be very much appreciated

[13:34] <audreyt> to be resumed tomorrow...

[13:35] <markstos> Thanks audrey.

[13:35] <putter> good night! :)  fun chatting.

[13:35] <putter> shift change! toot.

[13:35] * audreyt hits the "Shift" key

[13:36] <putter> (milk comes out nose.  bad audreyt)

[13:36] <putter> oh my

[13:37] <audreyt> sorry about the milk :) have fun

[13:37] <audreyt> &

[13:46] <svnbot6> r14036 | audreyt++ | * given.t: continue in "for" blocks is semi-conjectural

[13:46] <svnbot6> r14036 | audreyt++ |   in spec, so we :todo<unspecced> this failing test.

[13:46] <svnbot6> r14037 | rodi++ | Fixed postfix:<++> on Automata::Cellular objects to run correctly on most

[13:46] <svnbot6> r14037 | rodi++ | recent pugs.

[13:46] *** xerox joined
[13:53] *** Limbic_Region joined
[13:53] <Limbic_Region> audreyt ping

[13:53] <lambdabot> Limbic_Region: You have 1 new message. '/msg lambdabot @messages' to read it.

[13:53] <Limbic_Region> labdabot @messages

[13:53] <Limbic_Region> lambdabot @messages

[13:53] <Limbic_Region> lambdabot messages

[13:53] <putter> Limbic_Region: recently went to "sleep"

[13:53] <Limbic_Region> ok

[13:54] * putter considers Inline::Haskell, but calling haskell from C is still way to scary.

[13:54] <Limbic_Region> @tell audreyt thanks for the fix.  I only managed to fix a few failing tests in ext/ but I think I found 2 pugs bugs.  I want to talk to you about them first though

[13:54] <lambdabot> Consider it noted.

[13:56] <Limbic_Region> putter - I am thinking about finishing my current project up using Haskell so that will be perl imbedded with C and Haskell on the side

[13:57] <putter> neat.

[13:58] <putter> Anyone who wants a lambdacamel project, AntiBuddha is requesting cleanup.  http://urchin.earth.li/darcs/antibuddha/README

[13:58] <lambdabot> http://tinyurl.com/qubvt

[13:58] <putter> Limbic_Region: Haskell as separate process?

[14:03] <putter> and smoking.  bbiab

[14:07] <Limbic_Region> putter - yes

[14:07] <Limbic_Region> basically I was trying to do everything in Perl but it was far too slow

[14:21] *** mako132 joined
[14:30] <putter> if interactive subprocess, application-specific wire protocol or something general?

[14:31] <putter> it would be nice to finally get a standard module set for subprocess "embedding" of other languages in perl.  inability to do so is major language-limitation pain.  last time I checked, the open3 flavored cpan modules weren't even working cleanly. :/

[14:32] <putter> be neat to easily "embed" js, rb, py in pugs/p5, as prelude to having native p6 implementations.

[14:36] *** awwaiid_ joined
[14:37] *** mauke joined
[14:42] <putter> ?eval ?eval("1",:lang<perl5>)

[14:42] *** evalbot_r14007 is now known as evalbot_r14037

[14:42] <evalbot_r14037> Error: Unsafe function 'Pugs::Internals::eval_perl5' called under safe mode

[14:43] <svnbot6> r14038 | audreyt++ | * coro.t: This release broke coroutines because they interfere

[14:43] <svnbot6> r14038 | audreyt++ |   with loop control exceptions.  Add a test case for that and

[14:43] <svnbot6> r14038 | audreyt++ |   workaround earlier tests so they can test what they were testing.

[14:44] <putter> I'm getting eval("1",:lang<perl5>) => False on head (of a moment ago).  So no t/perl5/ tests. :/

[14:45] *** wilx_ joined
[14:45] *** stennie joined
[14:45] *** kane-xs joined
[14:45] *** iblechbot joined
[14:45] *** theorbtwo joined
[14:45] *** pmichaud_ joined
[14:45] *** TimToady joined
[14:45] *** cognominal joined
[14:45] *** bcorn joined
[14:45] *** takanori joined
[14:45] *** lumi joined
[14:45] *** nnunley joined
[14:46] *** mauke joined
[14:49] *** mauke joined
[14:50] <markstos> The Perl 5 embedding docs just got a significant update: http://rakudo.org/perl6/index.cgi?using_perl_5_embedding

[14:50] <lambdabot> http://tinyurl.com/rswkg

[14:51] <putter> markstos: awesome.  I notice embedding stopped working between

[14:51] <putter> r14011 and r14037

[14:51] <putter> ?eval("1",:lang<perl5>) now returns False.

[14:51] <lambdabot> Unknown command, try @list

[14:51] *** evalbot_r14037 is now known as evalbot_r14038

[14:51] <evalbot_r14038> Error:  Unexpected "now" expecting comment, operator, statement modifier, ";" or end of input

[14:53] <markstos> putter: that's too bad.  I've only made doc changes. :)

[14:54] <putter> lol

[14:54] <putter> markstos++ for doc

[14:55] * putter looks to add passing closures to table...

[14:55] <markstos> putter: does that work? I haven't tested it and t/perl5/*.t seems to have no tests for it.

[14:55] <markstos> Would it be just \&perl6_func ?

[14:56] <markstos> It's difficult to test at the moment. :)

[14:56] <markstos> Oh good, I have an older pugs lying around, where P5E isn't b0rked.

[14:58] <putter> just &f

[14:58] <svnbot6> r14039 | audreyt++ | * Make the closure trait blocks lazy, because "LAST" blocks

[14:58] <svnbot6> r14039 | audreyt++ |   need to fire only when the "for" knows for sure there's no

[14:58] <svnbot6> r14039 | audreyt++ |   more iterations to come, but that decision has to come _after_

[14:58] <svnbot6> r14039 | audreyt++ |   the block body has been executed.  To wit:

[14:58] <svnbot6> r14039 | audreyt++ |     for =$fh {

[14:58] <svnbot6> r14039 | audreyt++ |         my $line = $fh.readline;

[14:58] <svnbot6> r14039 | audreyt++ |         LAST { say "this is the last line" }

[14:58] <svnbot6> r14039 | audreyt++ |     }

[14:58] <svnbot6> r14039 | audreyt++ |   For Pugs.Eval, we need to pretend we've added LAST into the

[14:58] <svnbot6> r14039 | audreyt++ |   LEAVE queue in the first place, but don't actually do that

[14:58] <svnbot6> r14039 | audreyt++ |   until absolutely needed, otherwise t/builtins/io/io_in_for_loops.t

[14:58] <putter> my $t = eval('sub { $_[0]->("hi") }',:lang<perl5>); sub f($x) { "$x ho" } $t(&f)

[14:58] <svnbot6> r14039 | audreyt++ |   will fail.  Fortunately, lazy evaluation lets us do exactly that.

[15:00] <putter> re "oh good", yeah, I did a "quick reach for Ctrl-C" on an upgrade make ;)

[15:01] <putter> no anonymous edits --

[15:07] <putter> well, http://www.socialtext.com/company/legal is certainly minimal: "Socialtext, Socialtext Workspace, Socialtext Kwikspace and Socialtext Eventspace are trademarks of Socialtext Incorporated."

[15:07] <lambdabot> Title: Legal | Socialtext Enterprise Wiki

[15:07] *** mako132 joined
[15:10] *** wilx_ joined
[15:10] *** stennie joined
[15:10] *** kane-xs joined
[15:10] *** iblechbot joined
[15:10] *** theorbtwo joined
[15:10] *** pmichaud_ joined
[15:10] *** TimToady joined
[15:10] *** cognominal joined
[15:10] *** bcorn joined
[15:10] *** takanori joined
[15:10] *** lumi joined
[15:10] *** nnunley joined
[15:11] *** demerphq joined
[15:12] <svnbot6> r14040 | audreyt++ | * Temporarily workaround the strange "?eval(1, :lang<perl5>)"

[15:12] <svnbot6> r14040 | audreyt++ |   bug by using if/elsif/else in Prelude.pm instead of given/when,

[15:12] <svnbot6> r14040 | audreyt++ |   which could've been interfering with pseudo-primitives.

[15:12] <svnbot6> r14040 | audreyt++ |   Will investigate tomorrow, but this will get p5eval working first.

[15:13] * putter wonders if programming while sleeping is as unrestful as wandering cats...

[15:14] <svnbot6> r14041 | audreyt++ | * In eval(..., :lang<perl5>), unboxed primitive values returned

[15:14] <svnbot6> r14041 | audreyt++ |   from the eval should simply become primitive values in Pugsland.

[15:14] <putter> but thanks audreyt :)

[15:14] <demerphq> ah. just the person i popped in to visit.

[15:14] <putter> hi :)

[15:14] <demerphq> greetings.

[15:16] <putter> just now playing with perl5 embedded in pugs, so can eventually use new regexp toys

[15:17] *** wilx_ joined
[15:17] *** stennie joined
[15:17] *** kane-xs joined
[15:17] *** iblechbot joined
[15:17] *** theorbtwo joined
[15:17] *** pmichaud_ joined
[15:17] *** TimToady joined
[15:17] *** cognominal joined
[15:17] *** bcorn joined
[15:17] *** takanori joined
[15:17] *** lumi joined
[15:17] *** nnunley joined
[15:20] <demerphq> really?

[15:20] <putter> demerphq: so what are your plans?

[15:20] <putter> re "really",

[15:21] <putter> ?eval eval("1",:lang<perl5>)

[15:21] *** evalbot_r14038 is now known as evalbot_r14039

[15:21] <evalbot_r14039> Error: Unsafe function 'Pugs::Internals::eval_perl5' called under safe mode

[15:21] <putter> doesnt work because it is unsafe, but...

[15:21] <demerphq> well, i want to get YES/NO/ACCEPT/SUCCEED/CUT/COMMIT/DEFINE working.

[15:21] <putter> markstos just now posted http://rakudo.org/perl6/index.cgi?using_perl_5_embedding

[15:21] <lambdabot> http://tinyurl.com/rswkg

[15:23] <putter> and there is http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/browse/t/perl5/

[15:23] <lambdabot> Title: OpenFoundry&#40;Ëá™Áî±ËªüÈ´îÈëÑÈÄ Â ¥-Â∞àÊ°àÈñãÁôºÂπ≥Âè∞&#41; -- OSSF, http://tinyurl.com/e8ucv

[15:23] <putter> and pugs is currently using p5 for regexp (p6-flavor) support thanks to fglock++ et al.

[15:24] <demerphq> the syntax translation being done in perl?

[15:24] <putter> (end of "really?"  response:)

[15:24] <putter> yes

[15:25] <putter> actually, I believe the p5 engine is currently only being used at the leaves of the re ast, with all the backtracking etc glue being in p5 code.

[15:26] <putter> a more extensive translation would of course speed things up a lot.

[15:26] <putter> maybe already does - not sure.

[15:26] <demerphq> hrm.

[15:26] <demerphq> that frigtens me. :-)

[15:27] <putter> :)

[15:28] <putter> there is also... http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/browse/misc/pX/Common/regexp_and_parser_spike/ http://rt.openfoundry.org/Foundry/Project/Source/index.html/pugs/browse/misc/pX/Common/regexp_engine_cruft/ to frighten you. ;)

[15:29] <lambdabot> Title: OpenFoundry&#40;Ëá™Áî±ËªüÈ´îÈëÑÈÄ Â ¥-Â∞àÊ°àÈñãÁôºÂπ≥Âè∞&#41; -- OSSF, http://tinyurl.com/nu4qc

[15:29] <putter> what is YES/NO?

[15:30] <putter> and are there multiple flavors of cut?   p6 has group, rule, and pattern match level cuts.

[15:30] <demerphq> oh my you have lots of links for me.

[15:31] <demerphq> im not sure if we are using the terms the same way.

[15:31] * putter thinking prolog...

[15:32] <demerphq> The idea of YES is to say this pattern matches. dont bother trying to match any more of the pattern that follows the YES, but if inside of a looping construct return to it and continue.

[15:32] <demerphq> a NO is similar but the opposite.

[15:32] <putter> ok, where should I look for info on  YES NO ACCEPT SUCCEED CUT COMMIT DEFINE

[15:32] <putter> re YES,NO, ok...

[15:32] <demerphq> ACCEPT/REJECT would be "this pattern matches/fails, do not do anything more, regardless of where we are in the pattern"

[15:33] <putter> looping construct == quantifier (*+etc)?  :g too?

[15:33] <demerphq> COMMIT would be "this pattern matches, and must match from this point, do not backtrack past here, if we cant match from here then fail outright"

[15:34] <putter> ok

[15:34] <demerphq> CUT would be "this string must match in this pass of the regex engine, if it fails do not try the pattern at any other point in the string"

[15:35] <demerphq> I dont know if you are familiar with the terms that Friedl uses in MRE.

[15:35] <putter> assume not for clarity...

[15:36] <demerphq> But CUT would affect what he calls the "transmission"

[15:36] <putter> ok,

[15:36] <putter> COMMIT DEFINE?

[15:37] <putter> oh, you did COMMIT, oops, sorry ;P

[15:37] <demerphq> DEFINE would be just "the contents of this define block are not to be executed except via recursion/subroutine call.

[15:38] <putter> ok, a question about that in a bit

[15:38] <putter> SUCCEED?

[15:38] <demerphq> SUCCEED was renamed to ACCEPT.

[15:38] <demerphq> :-)

[15:39] <putter> ah, ok

[15:39] <demerphq> Since its currently the name of another unrelated regop. (although similar in principle to YES, but with special uses)

[15:39] <putter> YES NO ACCEPT REJECT COMMIT CUT DEFINE

[15:40] <demerphq> yeah, although YES/NO will be called REGYES/REGNO internally.

[15:40] <demerphq> Since YES/NO tend to be used for stuff in perl core code.

[15:41] <demerphq> ok, going back to this term "the transmission"

[15:41] <putter> aka, "accept/reject" on "loop" and pattern, commit pattern, and commit to starting point.

[15:41] <putter> and define.

[15:41] <demerphq> yeah, pretty much.

[15:41] <putter> what is "loop"?

[15:42] <demerphq> er......

[15:43] <putter> bah.  I hate irc eating my regexps with "No such command."

[15:43] <demerphq> case SUCCEED: /* successful SUSPEND/UNLESSM/IFMATCH/CURLYM */

[15:43] <putter>  /a*/  /a+/ ?  /a?/ ?  /a/g ?

[15:43] <demerphq> no, those would actually be optimised to simpler regops.

[15:44] <putter> ah, so...  while 1 { /a/ }  loops???

[15:44] <demerphq> an example would be that it signals the end of a (?=...) block for instance. or marks the finish of a (COMPLEX_PATTERN)*

[15:44] <demerphq> ok. now you are asking questions that bring us back to the concept of the transmission.

[15:45] <putter> lol

[15:45] <putter> ok...

[15:45] <putter> say on

[15:45] <demerphq> the perl regex engine, and i asssume that most push-down automata regexec engines, are divided into two conceptual parts in the execution arena

[15:45] <demerphq> the first the "transmission" and the second is the "engine"

[15:46] <demerphq> the "transmission" controls where the "engine" starts runnning from.

[15:46] <demerphq> So for instance you are familiar with fixed string optimisations.

[15:47] <demerphq> If we know that our pattern MUST match a given fixed string then we can efficiently look for that string before turning on the engine.

[15:47] <putter> http://regex.info/ , offline book

[15:47] <lambdabot> Title: Jeffrey Friedl's Mastering Regular Expressions

[15:47] <putter> ok

[15:47] <demerphq> the part of the code that handles such things is the transmission. its the thing that says "ok you failed at pos 0, try it again at pos 1" and stuff like that (assuming no optimisations in the transmission)

[15:48] <putter> so "transmission" in a gear sense, not a radio one

[15:48] <demerphq> for FSM implemented engines there isnt really a transmission.

[15:48] <demerphq> yes right.

[15:48] <demerphq> BTW, ive decide that the terms NFA/DFA are just so totally confusing and overloaded that i prefer not to use them.

[15:48] <putter> agreed

[15:49] <demerphq> For people actually doing implementation there are no NFA engines. Just DFA simulators of NFA engines, which are usually really push-down automata. And what most folks call DFA is really FSA.

[15:50] <demerphq> ok. cool. i guess i didnt need to say all that.

[15:50] <demerphq> :-)

[15:50] <putter> good for the #perl6 channel log and backlogging readers... :)

[15:50] <demerphq> Anyway, in the perl engine the tranmission is handled partially by re_intuit_start() and partially by the pp code that hands regex related stuff.

[15:51] <demerphq> and one of the things that Friedl commented on, and said he wanted, was a way to control the transmission from the pattern. so that where the CUT operator comes in.

[15:51] <putter> so the loop affected by YES/NO is in the transmission...?

[15:51] <demerphq> no, that would be in the engine.

[15:52] * putter goes back to attentively listening...

[15:52] <demerphq> a construct like (A[bc]+foo)* ends up producing an outer pair of regops, CURLYM/WHILEM with the stuff for /A[bc]+foo/ being inside

[15:53] <Limbic_Region> hey demerphq - have some time to help me with an Inline::C question unrelated to perl 6?

[15:53] <demerphq> i can try L_R.

[15:53] <Limbic_Region> I need to write 2 functions

[15:53] <Limbic_Region> one to determine the characters that 2 strings have in common

[15:54] <Limbic_Region> one to determine the characters one string has that the other doesn't

[15:54] <demerphq> SUCCEED is used to signal and end of the loop in some situations. CURLYM/WHILEM are like "iter-start, next"

[15:54] <demerphq> ok.

[15:54] <Limbic_Region> oh, probably should take this into /msg since it is OT

[15:54] <demerphq> are we talking utf8 or are we talking latin-1?

[15:54] <Limbic_Region> but basically my issue is with the return values and being smart about memory mgmt

[15:54] <Limbic_Region> plain a-z

[15:54] <demerphq> er, s/utf8/unicode/

[15:54] <putter> Limbic_Region: here's fine.  Inline::C++

[15:55] <demerphq> return an SV.

[15:55] <Limbic_Region> ok, putter

[15:55] <Limbic_Region> demerphq - I was hoping to pass in a third string and just fill it in the function

[15:55] <demerphq> you want an SvPV

[15:55] <demerphq> thats fine.

[15:55] <demerphq> same idea.

[15:56] <Limbic_Region> because my knowledge of perl internals is next to non-existant

[15:56] <Limbic_Region> and my C is pretty weak

[15:56] <putter> before getting fancy, just try   char *f(char* s1, char* s2) { ... perl_malloc()... }

[15:56] <putter> the inline glue should do the right thing.

[15:57] <demerphq> basically you dont something like SvGROW(sv,array_size_in_bytes); U32 *counts=(U32*)SvPVX(sv);

[15:57] <demerphq> no, i wouldnt go that way.

[15:57] <putter> ?

[15:57] <demerphq> the problem there is you then have to manage the memory yourself.

[15:57] <Limbic_Region> would the following be sane

[15:57] <demerphq> if you wrap it in a SV then perl deals with it for you.

[15:57] <putter> ah, right

[15:57] <nothingmuch> hello hello!

[15:57] <Limbic_Region> let's say instead of the two functions I really need - I wanted to concatenate 2 strings

[15:58] <nothingmuch> if anybody wants to see gaal in the shower paypal me and i'll sneak in

[15:58] <svnbot6> r14042 | markstos++ | [t/perl5/basic.t]

[15:58] <svnbot6> r14042 | markstos++ | A new (passing!) test for passing a Perl 6 coderef to Perl 5.

[15:58] <svnbot6> r14042 | markstos++ | An impressive trick...

[15:58] <nothingmuch> 6 megapixels, telephoto lens

[15:58] <demerphq> btw, limbic if you look at the code make_trie in regcomp.c you will see pretty close to exactly the code you are talking about.

[15:58] <Limbic_Region> if I passed in 3 strings (the third being presized as long as the first 2)

[15:58] <Limbic_Region> would I need to do any memory mgmt?

[15:58] <demerphq> well, that would be a risky interface.

[15:59] <Limbic_Region> ok then

[15:59] <demerphq> SvGROW is pretty straightforward.

[15:59] <Limbic_Region> can I just ask that you do it for me - and I promise not to just use it blindly but take some time to understand it?

[15:59] <Limbic_Region> I already have a couple of the Inline::C functions I need written - but they are just returning ints - not mortal SVs

[16:00] <demerphq> er...

[16:00] <demerphq> :-)

[16:00] <Limbic_Region> and my embedding and extending book is at work

[16:01] <demerphq> er.

[16:01] <demerphq> howabout we go mid way.

[16:01] <Limbic_Region> ok

[16:01] <demerphq> ill give you some code that should be pretty close and you see where you go with it?

[16:01] <Limbic_Region> wonderful - in fact, I should only need one of the two

[16:02] <Limbic_Region> so if you get me close to one

[16:02] <Limbic_Region> I should be able to finish it and do the second on my own

[16:02] <demerphq> ok.

[16:03] <Limbic_Region> in fact, let me nopaste the two functions I already have so you can see my skill level (or lack there of)

[16:03] <Limbic_Region> perlbot nopaste

[16:03] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[16:04] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "my two true/false inline::C functions so far" (54 lines, 2.3K) at http://sial.org/pbot/20248

[16:06] <putter> err, why use SvGROW for something this simple?  why not just newSVpv?

[16:07] *** jferrero joined
[16:07] <pasteling> "demerphq" at 84.58.62.1 pasted "count the chars, put the result in sv_ret (assumes that sv_ret and sv_source are already SvPOK)" (12 lines, 247B) at http://sial.org/pbot/20249

[16:08] <demerphq> he said he wanted to pass the SV in...

[16:08] <demerphq> And newSVpv would need initialization....

[16:09] <demerphq> does that help? and obviously its untested.

[16:09] <Limbic_Region> checking now

[16:09] <Limbic_Region> was AFK - daughter wanted attention

[16:10] *** mako132 joined
[16:10] <Limbic_Region> no, I am afraid it doesn't at the moment

[16:10] <demerphq> you want to be careful with using 'char' as its not defined by the C standard as to whether its signed or unsigned.

[16:11] <Limbic_Region> let me spend a few moments with it

[16:11] <Limbic_Region> I really need to study perlguts

[16:11] <demerphq> so if you are counting chars you dont want to use char. you want to use U8 (which is #defined to be 'unsigned char')

[16:11] <demerphq> otherwise you will try to index your array with a negative index when you encounter a high char (on some architectures anyway)

[16:12] <putter> SV* greeting(SV* sv_name) { return (newSVpvf("Hello %s!\n", SvPV(sv_name, PL_na))); }

[16:12] <Limbic_Region> well, I am not trying to write portable code but thanks - good practice

[16:12] <demerphq> SvPV(sv_name, PL_na)

[16:12] <demerphq> is now spelled SvPVX(sv_name)

[16:13] <demerphq> i think that will leak putter, you want sv_2mortal around the newSVpvf()....

[16:13] <putter> SV* JAxH(char* x) { return newSVpvf("Just Another %s Hacker", x);}    another line from Inline::C-Cookbook

[16:14] <demerphq> oh, is inline handling the mortalization? hmm.

[16:14] <Limbic_Region> demerphq - I do appreciate but I need to go pick up my daughter.  If you could add some comments that would help when I get back to it

[16:14] <demerphq> its been about a year since i did inline::c

[16:15] <putter> docs say inline handles the mortalization, checking...

[16:15] <demerphq> LR

[16:15] <demerphq> see u when u get back

[16:19] <putter> yep, does (sv_2mortal)   couldn't remember how to keep the build around in _Inline/build/, but adding a syntax error works great ;)

[16:19] <demerphq> heh

[16:19] *** Psyche^ joined
[16:19] <demerphq> theres some option to the config. i dont recall either.

[16:19] <putter> soooo, loops

[16:19] <demerphq> ja, where were we?

[16:20] <demerphq> SUCCEED is used to signal and end of the loop in some situations. CURLYM/WHILEM are like "iter-start, next"

[16:20] <demerphq> was my last comment i think

[16:21] <putter> the "loops" which YES/NO operate on are created by quantifiers?  just not the specific regexps /a+/ which get optimized?  but /somethingorother+/ for some value of somethingorother?

[16:22] <putter> YES/NO's "loops" are created by quantifiers?  are not created by anything else?

[16:22] <demerphq> easiest way to grok this is to get yourself a copy of blead set up, and then look at what happens with perl -Mre=Debug,COMPILE,EXECUTE -e"/a+/; /(foo[bz]+)+/

[16:23] <putter> since that perl expr only has a regexp, I gather the answer to "YES/NO's "loops" are created by quantifiers?" is yes?

[16:24] <demerphq> but yeah, the way that a complex pattern with a quantifier is handled is by wrapping it in some control ops called CURLY/WHILEM.

[16:24] <demerphq> And YES would affect that loop.

[16:24] <putter> ok. yay.  let's see...

[16:24] <putter> does anything else create CURLY/WHILEM loops?  ie, anything besides quantifiers?

[16:24] <demerphq> imagine something like 'foofoofoobarbar'=~/(?foo|bar(?YES))+/

[16:25] <demerphq> it would match foo three times then match bar ONCE.

[16:25] <demerphq> putter: no.

[16:25] <putter> ok, let's see...

[16:26] <putter> you know, I don't think p6 regexs have that critter... checking...

[16:26] <demerphq>  'foofoofoobarbarbar'=~/(?foo|bar(?YES))+bar/ would match the first three 'foo's then 'bar' once inside the * loop, then bar, leaving the last bar unconsumed.

[16:26] <demerphq> whereas 'foofoofoobarbarbar'=~/(?foo|bar(?ACCEPT))+bar/ would match ONLY the first bar, and wouldnt even try the last 'bar' EXACT op in the pattern.

[16:28] <putter> Ah, I was confused  http://dev.perl.org/perl6/doc/design/syn/S05.html  Backtracking control

[16:28] <lambdabot> Title: Synopsis 5: Regexes and Rules - perl6:, http://tinyurl.com/mqbs8

[16:28] <Limbic_Region> ok - I am back

[16:29] <Limbic_Region> I'm afraid I still don't get it though

[16:29] <putter> http://dev.perl.org/perl6/doc/design/syn/S05.html#Backtracking_control

[16:29] <lambdabot> Title: Synopsis 5: Regexes and Rules - perl6:, http://tinyurl.com/nx6hh

[16:31] *** Psyche^ is now known as Patterner

[16:31] <demerphq> so perl6 does have the concepts?

[16:32] <demerphq> LR hang on a jiff.

[16:32] <Limbic_Region> k

[16:32] <putter> no, I don't think we have a way to say "next;" within a quantifier loop.  nor fail just the loop.  you would have to wrap the quantified body in a rule.

[16:32] <demerphq> btw, _some_ of this stuff can be done with "lookaround" (positve/negative look-ahead/behind)

[16:32] <demerphq> but it tends to be really cryptic, and frankly not very efficient.

[16:32] *** rindolf joined
[16:33] <rindolf> Hi all.

[16:34] <markstos> Hello rindolf

[16:34] <putter> actually, YES after "a" is just (a|...)+ .  NO after a is...

[16:35] <rindolf> Hi markstos

[16:35] <rindolf> markstos: are you new here?

[16:36] <markstos> rindolf: I've been around the past few weeks.

[16:36] <markstos> you?

[16:36] <demerphq> putter, not sure what you mean...

[16:36] <markstos> I've been working on porting CGI::Application to Perl 6, as well, as docs, tests, and blog updates.

[16:36] <rindolf> markstos: I've been hanging around here on and off for one or two years.

[16:37] <rindolf> markstos: is that you: http://mark.stosberg.com/ ?

[16:37] <lambdabot> Title: Mark Stosberg

[16:37] <markstos> Yeah.

[16:37] <rindolf> markstos: I see.

[16:37] <markstos> Although lately I tend do most of blogging other places, including some at http://pugs.blog.com lately.

[16:37] <demerphq> skateboarding in a nice shirt++

[16:37] <demerphq> must be brutal on the clothes budget tho. :-)

[16:37] <markstos> :)

[16:38] <markstos> demerphq: Unfortunately, that day, it was. I had new pants on, and ripped a hole in the knee.

[16:38] <markstos> Usually I wear proper clothing for it, that day I snuck out from work on a nice spring day to go play...

[16:38] <rgs> rindolf: fwiw I began to investigate the segfault of XML::Twig with blead. I reproduce it

[16:38] <demerphq> yep. i know the deal. although i tend to do it cycling. :-)

[16:39] <rindolf> rgs: nice.

[16:39] <rindolf> rgs: let me know if you need anything.

[16:39] <markstos> demerphq: Actually, I spend a lot more time cycling lately myself. Later today I will haul 90 lbs of concrete to the dump.

[16:40] <markstos> bbiab.

[16:41] <putter> "The idea of YES is to say this pattern matches. dont bother trying to match any more of the pattern that follows the YES, but if inside of a looping construct return to it and continue." "a NO is similar but the opposite." sorry, my brain is misfiring.  what is does the opposite mean?

[16:41] <rindolf> ingy: pingy.

[16:41] <demerphq> it says This loop should stop, but keep going if its ok to do so.

[16:41] <putter> so "break;" for quantifier loops.

[16:42] <demerphq> well, consider the pattern again.

[16:42] <demerphq>  'foofoofoobarbarbar'=~/(?foo|bar(?NO))+bar/ would match the first 3 foos, then the tailing 'bar'.

[16:43] <Limbic_Region> demerphq - the code you wrote in http://perlmonks.org/?node_id=123072 to find the diff between 2 strings - would you say that the code is still "best" ?

[16:43] <lambdabot> Title: Re: Difference Of Two Strings (in C)

[16:44] <putter> can you backtrack over that NO?

[16:44] <putter>  'foofoofoobar'=~/(?foo|bar(?NO))+bar/

[16:44] <demerphq> lr: checking now

[16:46] <Limbic_Region> oh wait, you didn't actually write the C, someone translated your perl into C

[16:47] <demerphq> right

[16:48] <demerphq> if thats the behaviour you want it looks to me like its ok.

[16:49] <demerphq> Although, one thing comes to mind in both your original code and that code, which is that it doesnt look like it handles null bytes properly.

[16:49] <Limbic_Region> well - I won't ever have null bytes

[16:50] <Limbic_Region> a - z

[16:50] <Limbic_Region> all lowercase

[16:51] <Limbic_Region> woot

[16:51] <Limbic_Region> thanks

[16:51] <demerphq> thats fine, but as a matter of good practice you should never make such assumptions.

[16:52] <demerphq> they will sneak up on you and bite you when you are in the worst postion to resolve them.

[16:53] <Limbic_Region> well - the line of code preceding that function call is tr/a-z//cd;

[16:53] <Limbic_Region> but yeah

[16:53] <Limbic_Region> I generally write flexible re-useable code

[16:53] <Limbic_Region> this is not the intent here

[16:54] <demerphq> putter, sorry i didnt see that comment. i think so, but id have to see what you mean to say for sure.

[16:54] <putter>  'foofoofoobaRbArbAR'=~/(?foo|bar(?NO))+bar/i  matches 'foofoofoobaR', yes?

[16:55] <demerphq> right

[16:55] <putter> 'foofoofoobaR'=~/(?foo|bar(?NO))+bar/i also?

[16:55] <demerphq> er... hang on, i didnt pay proper attention to the string.

[16:55] <demerphq> ok, right. :-)

[16:55] <demerphq> on both counts.

[16:57] <demerphq> in this example its hard to see the point. but consider if it was something like:

[16:58] <putter> 'foofoofoobaRfoobar'=~/(?foo|bar(?NO))+bar/i  fails?

[16:58] <demerphq> like (?:FOO|BAR(?:IER(?NO)|.*FOO)|YADA)/

[16:58] <demerphq> irc keeps interpretingmy patterns.

[16:59] <putter> you can use a leading space

[16:59] <demerphq> ill keep that in mind. :-)

[17:00] <putter> 'foofoofoobaRfoobar'=~/(?foo|bar(?NO))+bar/i  fails?

[17:00] <demerphq> no.

[17:00] <demerphq> it consumes 'foofoofoobaR'

[17:00] <putter> oh, right, um,

[17:01] <putter> 'foofoofoobaRfoobar'=~/(?foo|bar(?NO))+bar$/i  fails?

[17:01] <markstos> I created a quick blog entry to announce having some decent Perl 5 Embedding docs:

[17:01] <markstos> http://pugs.blogs.com/pugs/

[17:01] <markstos> Now it's time to eat and bike some in the nice weather...

[17:02] * demerphq is jealous. good weather days are gone for a while here

[17:02] <putter> markstos: looks good.  though "now" might be better as the rsn release?

[17:02] <putter> just in case it breaks again in head, etc.

[17:02] <demerphq> putter: yes, the last one fails.

[17:03] <putter> markstos++

[17:03] <demerphq> afaict NO is fairly easily simulatable by negative lookahead/lookbehind.

[17:03] <markstos> putter: You mean, suggest that people try the RSN release ?

[17:03] <markstos> rather than say just "now"

[17:03] <putter> ok

[17:03] <putter> oh, yes, I'm wondering if "now" is the right advice.

[17:04] <putter> especially if we can get a full release out in the next few days.  which seems at least vaguely plausible

[17:04] <markstos> I see what you mean. I'll think of some different phrasing.

[17:04] <putter> full time audreyt + only 5 failing t/ files

[17:04] <ingy> hi rindolf

[17:05] <ingy> et al

[17:05] <rindolf> ingy: hi.

[17:05] <rindolf> ingy: I see you haven't uploaded IO::All yet.

[17:05] <markstos> putter: "Updated Perl 5 Embedding is just one of the many updates that will available in the next release of pugs, expected to happen in the next few days."

[17:06] <ingy> rindolf: today may be a good day

[17:06] <rindolf> ingy: OK.

[17:06] <ingy> although I am starting a really good book

[17:06] <markstos> s/will/will be/

[17:06] <ingy> ;)

[17:06] <putter> err, "never make schedule commitments you are not sure you can keep".  expected to happen rsn?

[17:06] <markstos> putter: agreed.

[17:06] <rindolf> ingy: meanwhile I have graver problems with getting my homesite built using bleadperl - XML::Twig segfaults. rgs is helping me with it.

[17:06] <rindolf> ingy: which book?

[17:07] <ingy> Database in Depth

[17:07] <markstos> s/in the next few days/Real Soon Now/

[17:07] <ingy> C J Date

[17:07] <putter> "expected soon"?

[17:07] <markstos> putter++. Committing.

[17:08] <rindolf> ingy: uploading to CPAN should only take a minute.

[17:08] * markstos &

[17:08] <ingy> rindolf: that's true

[17:09] <putter> markstos: nifty.  advanced advertising to generate buzz. ;)

[17:09] * ingy tests rindolf's theory

[17:10] <putter> demerphq: so let's see, what would be an example of YES?

[17:11] <demerphq> examples like we covered already. match a branch inside of a quantifier once, but match all the others according to the quantifier.

[17:12] <demerphq> if you restructure the pattern you can probably eliminate the need for YES/NO. But having them IMO would make certain things a lot easier.

[17:12] <putter> oh, to summarize, (?NO) non-backtrackingly jumps to ...

[17:13] <ingy> rindolf: the Changes META.yml $VERSION etc all need updating

[17:13] <ingy> so no one minute upload

[17:13] <demerphq> the next thing that should be matched.

[17:13] <ingy> :P

[17:13] <putter> hmm...  'foohee' =~ /^(foo(?NO)bar)hee$/ matches or no?

[17:13] <ingy> I'll take a look after breakfast

[17:14] <demerphq> no. fails outright

[17:14] *** wilx_ is now known as wilx

[17:14] <demerphq> incie its not in a quantifier and the pattern is anchored.

[17:15] <demerphq> you would use YES/NO to tweak a large pattern from the inside without having to completely restructure it.

[17:15] <putter> so, to summarize, (?NO) non-backtrackingly jumps to beyond the current quantifier or if there isn't one, to pattern end.

[17:15] <demerphq> As i said, you could simulate the use of YES/NO by lookaround.

[17:15] <demerphq> right.

[17:16] <demerphq> at least thats my idea so far. im open to better ones.

[17:16] <demerphq> definitely.

[17:16] <demerphq> if you have something you want in the perl5 engine let me know. :-)

[17:16] <Limbic_Region> grrrr - that code I found doesn't do what I want :-(

[17:17] <demerphq> its for  a specific purpose LR.

[17:17] <putter> and (?YES) non-backtrackingly jumps to the beginning of the current quantifier, or if there isn't one, to pattern end.

[17:17] <Limbic_Region> right

[17:17] <putter> yes?

[17:17] <demerphq> btw putter, i feel like we are monopolising the chat... should we go elsewhere where its easier to do private chat?

[17:18] <demerphq> YES terminates the loop and continues.

[17:18] <rindolf> ingy: thanks

[17:18] <Limbic_Region> demerphq - if you are discussing perl 6 rules and/or changes to perl 5 re engine

[17:18] <demerphq> NO terminates the loop but backtracks to the last checkpoint before it was executed and then continues in the pattern.

[17:18] <Limbic_Region> this is the right place to be discussing it

[17:18] <Limbic_Region> the channel is logged btw

[17:19] <Limbic_Region> making referring to conversation later by others easier

[17:19] <demerphq> okey. i just dont want to be accused of being a channel hog.

[17:19] <demerphq> after all this is esoteric shit.

[17:19] <putter> na, there are lots of people who are interested in the regex stuff.  if we were doing just p5 engine internals maybe.  but this is more "what's nice regexp vocabulary" and how does these p5 regexp vocabulary correspond to p6 vocabulary

[17:19] <demerphq> yeah.

[17:20] <Limbic_Region> well - I am only personally interested in getting my Inline::C code working - but others will benefit from your conversation

[17:20] <demerphq> part of what i had in mind with all the control verbs was to make such a transition/translation easier to accomplish.

[17:20] <demerphq> since grammars are more sophisticated than pure regexes.

[17:21] <demerphq> and also my thinking was that while i might not exactly find a use for a given thing, if its something that cant be done now most likely somebody will find a use for it even if its only a curiosity to me.

[17:23] <putter>  (a(?YES)b)+ == (a(?COMMIT))+ ?

[17:24] <pasteling> "demerphq" at 84.58.62.1 pasted "updated: count the chars, put the result in sv_ret (assumes that sv_ret and sv_source are already SvPOK)" (12 lines, 698B) at http://sial.org/pbot/20250

[17:25] <putter> or YES only commits the inner quantifier, and if that quantifier is nested in an alternation or another quantifier, that level is not commited

[17:25] <demerphq> putter: no, since commit will prevent backtracking to a point before that subpattern begins, but YES wouldnt.

[17:26] <demerphq> lr with that you could do @array=unpack "L!*",sv_ret;

[17:26] <demerphq> (or something close to that, you need to check the pack format)

[17:27] <Limbic_Region> demerphq - I am afraid I am far too below your example even with comments

[17:28] <Limbic_Region> I know how to pass two strings into the C function

[17:28] <Limbic_Region> I know how to determine the characters in string one that are not present in string 2

[17:28] <Limbic_Region> I just can't figure out how to store those characters in a mortal SV and return it to perl

[17:28] <demerphq> well most of the code is in my sample there.

[17:29] <Limbic_Region> right - except none of your code looks at all like I would do it

[17:29] <demerphq> *cough*

[17:29] <Limbic_Region> IOW - I am still writing baby code

[17:29] <demerphq> thats just counting the chars in a single string.

[17:29] <demerphq> its not a complete solution. i figured you could extrapolate how to procede.

[17:29] <demerphq> So you have two strings as input?

[17:30] <Limbic_Region> demerphq - I can't figure out how to proceed because of the perlguts stuff you have there

[17:30] <putter> so there are two concepts.  one is making a normally backtracking quantifier sometimes turn non-backtracking, depending on input.  the other is jumping, from one point in the regexp to another, in this case to beyond quantifier or to "beginning".

[17:30] <Limbic_Region> I understand Perl and I understand basic C but I don't have a clue as to how the two meet

[17:31] <Limbic_Region> for instance ret_sv,256*sizeof(U32)

[17:31] <Limbic_Region> I know ret_sv is retrieve sv

[17:31] <Limbic_Region> I wouldn't have the first clue as to know that I needed 256 there

[17:31] <Limbic_Region> or what U32 is def'd as

[17:32] <Limbic_Region> most of what you provided is greek to me

[17:32] <Limbic_Region> while I can easily guess the meaning of sv grow

[17:32] <Limbic_Region> SvCUR_set is WTF

[17:32] <putter> Limbic_Region: just can just do it as you might in C, with a static C string, then instead of strdup'ing it on the way out, just newSVpv it.

[17:33] <putter> hmm, that's not quite right

[17:33] *** weinig is now known as weinig|bbl

[17:33] <putter> but the core idea is, unless you want to be using a perl array or hash or whatever, just do it as you would in C, and convert as the last step.

[17:33] <putter> and the conversions can be quite easy.

[17:34] <demerphq> sorry was afk

[17:35] <demerphq> L~R gimme a minute, ill beef up the example

[17:35] *** elmex joined
[17:35] <Limbic_Region> perphaps it would be better if I wrote an example of where I am and you or putter augment it

[17:35] <demerphq> U32 -> 'unsigned long'

[17:35] <demerphq> U -> unsigned.

[17:36] <demerphq> 32 -> minimum number of bits in the type.

[17:36] <demerphq> so, on most archtictures U32 is an unsigned long.

[17:36] <demerphq> On some its something else, maybe 64 bits even.

[17:37] <demerphq> U8 -> 'unsigned char'

[17:38] <demerphq> in perlcore/inline etc its encouraged not to use "normal c types" since they have a habit of platform dependent as to exactly what they are.

[17:38] <demerphq> For instance an int can be anywhere from 16 to 64 bits.

[17:39] <demerphq> ive even seen a comment in the perl core that suggests that its possible that sizeof(int) > sizeof(unsigned long)

[17:39] <pasteling> "Limbic~Region" at 24.35.57.240 pasted "Where I am starting from" (27 lines, 1.2K) at http://sial.org/pbot/20251

[17:40] <demerphq> i think that last one maybe was on a cray.

[17:42] *** wilx_ joined
[17:46] *** wilx_ is now known as wilx

[17:50] <pasteling> "demerphq" at 84.58.62.1 pasted "untested" (28 lines, 1.2K) at http://sial.org/pbot/20252

[17:51] <putter> Limbic_Region: simplest thing might be to first finish your computation, creating say a results[256] like exists[], and then simply return  newPVsvn(results,256).   A perl wrapper function can unpack the string and convert it to characters.

[17:51] <demerphq> thing is he isnt clear on what he wants. does he want an array with the counts or a string with single chars for any char ommitted.

[17:51] <putter> hmm, looking at demerphq's code, I think we are unclear on intended spec.

[17:52] <putter> :)

[17:52] <demerphq> putter: going back to your last regexp comment: that is basically the idea.

[17:54] <demerphq> is he afk again?

[17:54] <Limbic_Region> I want the string

[17:54] <Limbic_Region> or rather

[17:54] <Limbic_Region> I want the string that represents the characters in string1 that aren't in string2

[17:54] <putter> Limbic_Region: I think a little example might help.

[17:55] <demerphq> well i think that my last paste should do that.

[17:55] <Limbic_Region> so if I have 'foo' and 'boa' it should return 'f'

[17:55] <Limbic_Region> er

[17:55] <Limbic_Region> 'fa' rather

[17:55] <Limbic_Region> as they share o

[17:55] * demerphq slaps l~r with a trout

[17:56] <Limbic_Region> why?

[17:56] <demerphq> just because.

[17:56] <demerphq> :-)

[17:56] <Limbic_Region> oh

[17:57] <putter> Hmm, now that we are going from Inline::C to debugging LR's spec, that might be a time to got to /msg ;)

[17:57] <Limbic_Region> so with face and bart fce should be returned

[17:57] <demerphq> heh

[17:58] <putter> Limbic_Region: but the one liner is - it is unclear (to me at least;) what ordering and repetition constraints you want on the output.

[17:59] <demerphq> so putter, does that stuff sound reasonable?

[17:59] <Limbic_Region> putter - perhaps I failed to mention - or more likely, it has been so long you forgot

[17:59] <Limbic_Region> that the original two strings are in alphabetical order

[17:59] <Limbic_Region> and are unique within themselves

[17:59] <putter> (and that would not take very long today... brain of tapioca)

[17:59] <demerphq> no actually i dont think you mentioned that part. :-)

[18:00] <Limbic_Region> so 'abfgh' and 'bcdef' should be 'agh'

[18:01] <Limbic_Region> probably another conversation in which I mentioned it then

[18:01] <Limbic_Region> sorry

[18:01] <putter> char result[256]; int result_index = 0;  result[result_index++] = c;  return newSVpv(result,result_index);

[18:01] <demerphq> is 'aaaaaabbbbbbcccccc' a legal string?

[18:01] <Limbic_Region> no

[18:01] <Limbic_Region> abc

[18:01] <Limbic_Region> each character within a string is unique

[18:02] <demerphq> ok, then try the "untested" code i sent you.

[18:02] <demerphq> i think that should do the trick.

[18:02] * Limbic_Region does

[18:02] <Limbic_Region> er try that is

[18:02] <demerphq> although can change it from an int [] to a char [].

[18:03] <putter> demerphq: re YES/NO,

[18:04] <putter> ok, brainstorm mode for a moment...

[18:04] <Limbic_Region> demerphq - it blew up

[18:05] <Limbic_Region> checking to see if I can debug

[18:05] <putter> s/brainstorm/brainstorming/

[18:05] <demerphq> blew up.

[18:05] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "errors" (28 lines, 1.4K) at http://sial.org/pbot/20253

[18:05] <demerphq> can you post a working Inline::C example?

[18:06] <demerphq> the framework?

[18:06] <Limbic_Region> demerphq - the things I posted earlier are working

[18:06] <Limbic_Region> the ones demonstrating my skill level

[18:06] <demerphq> hrm.

[18:07] <demerphq> what version of perl are you on?

[18:07] <Limbic_Region> [12:04] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "my two true/false inline::C functions so far" (54 lines, 2.3K) at http://sial.org/pbot/20248

[18:07] <demerphq> sv_catpvn

[18:07] <demerphq>     Concatenates the string onto the end of the string which is in the SV. The len indicates number of bytes to copy. If the SV has the UTF-8 status set, then the bytes appended should be valid UTF-8. Handles 'get' magic, but not 'set' magic. See sv_catpvn_mg.

[18:07] <demerphq>             void    sv_catpvn(SV* sv, const char* ptr, STRLEN len)

[18:07] <Limbic_Region> 5.8.8 I believe

[18:07] <Limbic_Region> yep 5.8.8

[18:08] <demerphq> no i mean including the Inline specific stuff.

[18:08] <putter> p6 allows committing enclosing sequence, alternation, regex, and the entire pattern match.  YES/NO points out that commiting the enclosing quantifier might also be nice.

[18:08] <demerphq> what does committing mean to you? no backtrack possible?

[18:08] <Limbic_Region> I am confused - use Inline C=>; at the top and right above my paste __END__ and __C__

[18:08] <putter> yes

[18:08] <demerphq> does that include transmission level bumping?

[18:09] <Limbic_Region> demerphq - you want a 100% working perl script with inline::c?

[18:09] <putter> hmm...

[18:09] <demerphq> something i can do `perl script.pl` and have run (assuming i have inline::c installed)

[18:09] <Limbic_Region> sure - just need to add 3 lines to the paste I already provided

[18:10] <Limbic_Region> will new paste in a sec

[18:11] <putter> it is obvious the fail match does.  but for the rest.... I would not think so.

[18:11] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "working foo.pl with inline::c" (35 lines, 1.3K) at http://sial.org/pbot/20254

[18:14] <demerphq> putter: ok.

[18:14] <putter> so we have  sequence, alternation, quantifier, regex, transmission, match.

[18:15] <demerphq> its not yet clear to me the difference. i mean commiting in the different ways.

[18:15] <putter> in p6 syntax those are  :, ::, n/a, :::, n/a, <commit>.

[18:16] <demerphq> but i need to review the documents youve pointed at.

[18:19] <putter> regex foo /a(bc|d)+/     b:c would commit bc, but not bc|d, after seeing b.  b::c would commit bc|d, but not (...)+, after seeing b.  b:::c commits foo, but not the the entire match of which foo may be a subrule (eg, rx/x<foo>y/).  b<commit>c commits that top level match attempt.

[18:20] <pasteling> "demerphq" at 84.58.62.1 pasted "this works on my box." (38 lines, 1.4K) at http://sial.org/pbot/20255

[18:20] <demerphq> ok, im going to have to stare at that for a minute. :-)

[18:21] <Limbic_Region> demerphq - works on mine too ;-)

[18:21] <Limbic_Region> thanks

[18:21] <Limbic_Region> off to check it a bit more robustly now

[18:22] <demerphq> k.

[18:22] <demerphq> putter, im not getting where 'b:c' or things like that would be put....

[18:22] <putter> so three questions come to mind: does p5 have the current flavors of p6 commit?  should p6 get the missing two flavors of proposed p5 commit?  and ...

[18:23] <putter> sorry, trying to save typing.  expanded it would be...

[18:23] <putter> regex foo /a(bc|d)+/; $str ~~ rx/x<foo>y/;

[18:24] <demerphq> ok.

[18:24] <putter> then versions with /a(bc|d)+/ changed to /a(b:c|d)+/  /a(b::c|d)+/  /a(b:::c|d)+/  /a(b<commit>c|d)+/

[18:26] <putter> the third question is given all these commits, can we generalize the commit concept somehow?

[18:26] <demerphq> ok, so /a(b::c|d)/ would say, "if you match 'b', you must match 'c', do not even try to match 'd'. but if you dont match 'b' you can try matching 'd'?

[18:27] <putter> oh, and I guess there is a fourth question - should p6 have a jump concept, either contained in a YES/NO-like quantifier committer (which could exist without one), or generalized?

[18:27] <demerphq> wheras /a(b:c|d)/ would say "if you match 'b' you must match 'c' but if that doesnt work out you can try 'd'?

[18:28] <putter> yes

[18:28] <demerphq> so you could generalize it to, commit to the nth previous checkpoint?

[18:29] <demerphq> i mean what would happen if you had /a((b::c)?|d)+/

[18:30] <demerphq> or is the number of colons closely associated with a specific checkpoint type?

[18:30] <putter>  I think the group would dominate that example.  so /a((b::c)?|d)+/ == /a((b:c)?|d)+/

[18:31] <demerphq> so then there is ambigouty?

[18:31] <putter> why?

[18:31] <putter> or for what?

[18:32] <demerphq> given the equivelency you just said, it doesnt seem clear to me how the different colons are supposed to work.

[18:32] <putter> (b::c) is a one branch alternation.  == (b::c|<fail>)

[18:32] <demerphq> on the other hand, i kinda see the idea. im just trying to grok it.

[18:33] <demerphq> im also trying to figure out how i can map the concepts :-)

[18:33] <Limbic_Region> demerphq - running it against the real dataset now - should take 15 minutes or less (since 15 minutes is how long the perl takes)

[18:34] <demerphq> <fail> being match level failure, not transmission level failure?

[18:35] <putter> if one was doing a hierarchy of things it would be, err,  "thingy/atom/mumble", sequence, alternation, group (which creates a thingy), quantifier, etc

[18:35] *** weinig|bbl is now known as weinig

[18:36] <putter> re fail, yes

[18:36] <putter> oh, wait, no

[18:36] <putter> fail being <please backtrack now>.

[18:37] <putter> (?=a)(?!a)

[18:38] <mauke> a.k.a (?!)

[18:38] <demerphq> ok.

[18:39] <demerphq> so something like NO.

[18:39] *** araujo joined
[18:40] <demerphq> hmm.

[18:40] <demerphq> im going to have to think about some of this and how i can work it into the perl5 engine.

[18:40] <putter> attempting to backtrack through :: makes the alternation into a (?!)

[18:40] <putter> well, not really.

[18:41] *** [particle] joined
[18:42] <putter> but if one thinks of a stack of choice points, it pops those of the alternation, and continues backtracting from there.

[18:42] <putter> s/those/that/  (maybe, depending on implementation/ definition of choice point)

[18:43] <demerphq> BTW, thats where things get interesting and illustrates why a* is different from (......)*

[18:43] <putter> explain?

[18:43] <demerphq> the type of data needed to store checkpoints in a* is totally different from (COMPLEX_PATTERN)*

[18:43] <putter> ah

[18:43] <demerphq> consider for a* you can store a single frame of data.

[18:44] <demerphq> whereas for the complex case you may need much much more.

[18:45] <putter> yeah.  the confusion was caused by a sometimes being used as a "metavariable", symbolizing an arbitrary atom, rather than as a literal char.

[18:45] <demerphq> anytime the length of the match is fixed you can do "simple checkpointing" anytime the match is floating you need to handle complex checkpointing

[18:45] <putter> ok

[18:47] <Limbic_Region> 13m18.328s - only shaved 2 minutes off the runtime :-(

[18:47] <putter> so backtracking through :: fails the alternation of which it is directly (no intervening grouping) part... and maybe I'm wrong about that.

[18:47] <putter> hmm, consider...

[18:47] <Limbic_Region> perhaps most of that is I/O though (which was needed on the 1st run to confirm identical output)

[18:47] * Limbic_Region runs again without IO

[18:48] *** justatheory joined
[18:49] <putter> Limbic_Region: going to/from C has cost.  by rm'ing _Inline, adding a C syntax error (there's a real way to do this too;), and looking in _Inline/build/mumble, you can see the code generated.  you are going through a perl sub wrapper.  so you have to pass over enough work to make the transition cost worthwhile.

[18:50] <demerphq> presize the sv as well.

[18:50] <putter> oh, is it using that sv_cat thing... :(.   LR: and avoid using the perlapi when you don't really need to. ;)

[18:51] <demerphq> yeah well, sometimes its a lot easier than the rest.

[18:52] <demerphq> anyway, im gunna do some real hacking and maybe ill have something working for you to poke at and comment on.

[18:52] <putter> oh, but wait,

[18:52] <putter> I may have given you misinformation.

[18:52] <demerphq> :-)

[18:52] <demerphq> do tell?

[18:53] <putter> consider (b::c)|x, does :: affect the | or not?

[18:53] <putter> I guessed not, but, that would seem unfortunate if one just wanted to do (?i:b::c)|x   (err, mixing p5 and p6 syntax;)

[18:54] <putter> checking tests...

[18:57] <putter> bah.  our test suite has been pruned to apparently not include any cases of ::.  maybe I'm just missing them.  with regexs, our philosophy has oft resembled dont test what doesnt work.  grumble grumble ;)

[18:58] <demerphq> ha

[18:58] <putter> ah well.  what I've said appears to be spec.

[18:58] <demerphq> ETOOMANYCOLONS

[18:58] <demerphq> :-)

[18:58] <putter> lol

[18:58] <Limbic_Region> heh, the perl version without the IO runs in 2min36 secs

[18:59] <Limbic_Region> so I think I/O is a big part of the problem

[18:59] <putter> everyone together now: "measure before optimizing!"  <background cheers> ;)

[18:59] <Limbic_Region> and the Inline C is 36 seconds

[18:59] <Limbic_Region> yay

[18:59] *** Aankhen`` joined
[18:59] <Limbic_Region> putter - the IO is constant

[18:59] <Limbic_Region> the rest is not

[19:00] <Limbic_Region> and the IO was necessary to confirm the output was the same

[19:00] <putter> ah

[19:00] <putter> oh well, it was a good thing to cheer periodically anyway :)

[19:00] <Limbic_Region> so what I really am comparing is 156 seconds against 36

[19:01] <putter> demerphq: so, to wrap up,

[19:02] <putter> after definitions, we didn't get to go beyond YES/NO to the others, but it was very interesting, and raised interesting questions :)

[19:04] <putter> oh, one thing I was going to mention but didnt, is some of these constructs are nestable, and it would be nice if, like with LABEL:s and code loops, one could specify which loop one wished to affect.

[19:04] <putter> err, which level one wished to affect.

[19:04] <putter> though labels would be a way of generalizing "commit what".

[19:06] <demerphq> hrm.

[19:06] <demerphq> well let me get some rudimentary commit support happening, and then we can play with it and see where it goes.

[19:07] <demerphq> i think you understand the material better than i. i just happen to more or less grok the perl5 implementation, so probably need to be guided to the appropriate stuff to really make supporting perl6 possible in perl5.

[19:09] <pasteling> "putter" at 66.30.119.55 pasted "variant of http://sial.org/pbot/20255" (39 lines, 1.4K) at http://sial.org/pbot/20256

[19:09] <pasteling> "putter" at 66.30.119.55 pasted "variant of http://sial.org/pbot/20255 [bugfix]" (39 lines, 1.4K) at http://sial.org/pbot/20257

[19:11] <demerphq> you need to manually add a 0

[19:11] <putter> Limbic_Region: this probably wont make any difference, but it avoids the sometimes expensive perlapi for things which dont need to be there, and removes the U8 casts, which were unnecessary (the bits being operated on are locally declared), and thus only added confusion and risk (well, not really, but fear of risk;).

[19:12] <putter> really, ok.  then results[257], etc.

[19:12] <pasteling> "demerphq" at 84.58.62.1 pasted "naughty naught, prevent buffer overun" (40 lines, 1.4K) at http://sial.org/pbot/20258

[19:13] <putter> buffer overruns by whom?

[19:13] <demerphq> the code that tries to printit out. :-)

[19:13] <putter> perl is perfectly happy with embedded nulls.  so who needs the trailing one?

[19:13] <putter> oooooopps.  tnx.

[19:14] <demerphq> the only thing i would do to change that maybe is to change the way the memory allocation occurs to avoid the copy.

[19:16] <putter> re printit out... p5 is happy; the p5 api doesnt in general assure null termination, does it?;  if not, you mean hand written C print code which maintains a non-local contract with the algorithm to null terminate the perl strings it might be handed?  what am I misunderstanding?

[19:18] <putter> demerphq: re commit support, sounds like a plan.  I don't know that I "understand" it better than you do.  that would take audreyt or TimToady or pm or someone...  I just got a chance to read the p6 docs earlier :)

[19:19] <demerphq> if you read the docs there are various notes admonishing one to make sure that the end of the string has a 0, regardless as to what perl generally does.

[19:20] <demerphq> so its just habit.

[19:20] <putter> ah.  ok.  good point.

[19:21] <demerphq> i think for instance that sometimes the perl does call out to c code that expects null terminated strings.

[19:21] <demerphq> but im not sure on the details.

[19:21] <putter> ok.

[19:22] <putter> and better for code which incorrectly assumes simple non-nulls+null strings to fail less dramatically.

[19:23] <putter> though if null termination was generally avoided, one might even fewer overflow problems, because crufty code would be found quickly ;)

[19:26] *** mauke joined
[19:27] <pasteling> "demerphq" at 84.58.62.1 pasted "no copy and let me tell you, once Jarkko bitches a few times about you breaking build by indexing arrays with vars of type 'char' you won't do it anymore." (44 lines, 1.5K) at http://sial.org/pbot/20259

[19:29] <putter> p6 takeaway questions: should we have a quantifier loop or "transmission/pos start" loop commit constructs?

[19:29] <demerphq> the U8 casting is a hard learned lesson. :-)

[19:29] <Limbic_Region> demerphq - that's the way I was thinking of doing it had I known how

[19:29] <Limbic_Region> basically size the string as large as it possibly could be

[19:29] <Limbic_Region> and then resize it at the end

[19:30] <putter> (re grouping and ::, having to say [:i a] :: [:i b] | x  isn't too bad... it just a pain when refactoring [:mumble ab] to [:mumble a::b] to have to say [:mumble a] :: [:mumble b])

[19:31] <demerphq> im really going to have to mull over that.

[19:32] <demerphq> i think theres a faster way to do it actually.

[19:33] <putter> rx/[:i a]/ is just perl5 /(?i:a)/

[19:33] <putter> but yeah, seems to need mulling

[19:36] <putter> interacts really badly when the regex is assembled by subs.  you almost want a "grouping brackets transparent to ::".

[19:38] <putter> right now (in p5) you can wrap anything in arbitrary (?:...) and preserve meaning.  :: stopping at [...] would seem to break that.  no more "wrap it to make it case-insensitive" and such games.

[19:39] <putter> so there is a second p6 takeaway question: does :: stop at the first enclosing group [], and are we really happy with that?

[19:39] <pasteling> "demerphq" at 84.58.62.1 pasted "maybe this is faster?" (41 lines, 910B) at http://sial.org/pbot/20260

[19:39] <putter> demerphq: faster way?

[19:40] <putter> ah, inline::c, not regexs.

[19:41] <demerphq> well, we are trying to shave a yak werent we :-)

[19:41] <demerphq> or rather LR was....

[19:42] <demerphq> so we might as well give it a close shave =)

[19:44] <Limbic_Region> ver1 and ver2 are almost identical

[19:44] <putter> must. resist. yak. puns.

[19:44] <Limbic_Region> checking ver3 (latest) now

[19:45] <demerphq> it could be slower. i dunno.

[19:45] <putter> all the delay is likely in the wrapper sub at this point.

[19:46] <Limbic_Region> demerphq - all 3 versions run within 1 second of each other

[19:46] <Limbic_Region> I am not going to quibble further

[19:46] <putter> you could try ripping the safety checks out of the wrapper code :)

[19:46] <Limbic_Region> nah - 156 to 36 is good enough for me

[19:47] <putter> success

[19:47] <Limbic_Region> of course the next step may be computational unrealistic regardless so....

[19:48] <putter> sigh.  see earlier cheer :)

[19:48] <demerphq> heh

[19:51] <Limbic_Region> 2.2 billion iterations isn't outside the realm of possibilities and that's the upper boundary - realistically it should be far less than that

[19:55] <putter> US or UK billion?

[19:55] <Limbic_Region> US

[19:55] <Limbic_Region> UK billion == US trillion?

[19:56] <putter> yes

[19:56] <Limbic_Region> I would abandon at that point

[20:02] <putter> :)

[20:02] <svnbot6> r14043 | putter++ | t/regex/from_perl6_rules/array_cap.t - force_todo a test.  all tests pass (again?).

[20:02] * Limbic_Region wanders off to think of the best way to reduce the problem space without costing more than is gained

[20:02] <Limbic_Region> thanks for all the help

[20:06] <putter> np, was fun.

[20:06] <putter> demerphq++

[20:10] <demerphq> er, why?

[20:10] <demerphq> not that its not nice or anything.

[20:16] <putter> "Limbic_Region: thanks for all the help"

[20:16] <svnbot6> r14044 | putter++ | t/xx-uncategorized/p6regex_oddity.t - created.

[20:16] <svnbot6> r14044 | putter++ | Something odd is going on with this for() loop.  Watch what happens after test 9.

[20:17] <putter> ooo, neat.  t/examples/all_parse.t segfaults.

[20:31] <svnbot6> r14045 | putter++ | t/oo/roles/anonymous.t - fixed typo.  all tests pass.

[20:41] <TimToady> yow, my last smoke took 20 minutes longer than my previous one.

[20:41] <rindolf> Hi TimToady

[20:41] <TimToady> hi

[20:42] *** markstos joined
[20:43] <TimToady> @tell audreyt something that got checked in last night took my smoke from 48 minutes to 68 minutes.  Pretty sure I didn't have anything else running...

[20:43] <lambdabot> Consider it noted.

[20:44] <TimToady> nap &

[20:46] <rindolf> TimToady: bye.

[21:01] *** justatheory joined
[21:19] <svnbot6> r14046 | putter++ | t/perl5/exception_handling.t - added missing "->new".

[21:24] *** glasser joined
[21:31] *** nothingmuch joined
[21:35] <svnbot6> r14047 | putter++ | t/perl5/array.t - some cleanup.  Doesn't currently run because of .new problem.

[21:38] <rindolf> ingy: ping

[22:09] *** markstos joined
[22:34] <putter> anyone around?

[22:44] *** Limbic_Region joined
[23:16] <putter> does the following sound plausible?  p6 regex does not simply support: commit the surrounding quantification loop; succeed or fail out of the surrounding quantification; commit to the current start point; fail of the full subrule tree (ie, try next start).  I believe everything else is covered.  They can all be faked with embedded code, though the last requires an external trampoline.

[23:17] *** c6rbon joined
[23:21] <putter> oh, and succeed out of the entire match.  That can be badly faked (let()s dont work right).

[23:24] <putter> and the only way to succeed out of a group is by wrapping the rest of the sequence as a group, so a non-pretty non-local close-bracket is needed.

[23:25] <putter> (and they also non-prettily nest)

[23:26] <putter> s/succeed out of group/succeed out of sequencer/

[23:26] <putter> s/r$//

[23:34] <putter> no, arg.  succeed out of sequence is wrapping - a[b]??:.  out of alternation is a[b]??:|c a[b]??::|c.  out of group, the same.

[23:36] <putter> oh, I left out backtracking-succeed out of sequence - a[b]?? .

[23:36] <putter> brain pudding.  later &

[23:39] *** demerphq joined
