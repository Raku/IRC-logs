[00:03] *** q[uri] joined
[00:36] *** avar joined
[00:41] *** avar joined
[00:43] *** stevan_ joined
[00:47] *** avar joined
[01:00] *** f0rth joined
[01:13] <stevan_> nothing_pasta: ping

[01:13] *** stevan_ is now known as steevan

[01:13] *** steevan is now known as stevan

[01:22] *** zgh joined
[01:22] <FurnaceBoy> mmmmm pasta

[01:23] * FurnaceBoy goes out to the garden to pick some

[01:24] * arcady wishes he had a pasta tree

[01:30] *** jiing_mIRC joined
[01:31] *** jiing_mIRC left
[01:45] *** justatheory joined
[01:48] *** amnesiac joined
[02:01] <svnbot6> r9860 | fglock++ | PCR/Category - more tests: runtime definition of op precedence; parenthesis

[02:03] *** xern joined
[02:36] *** justatheory joined
[02:44] *** DesreveR joined
[02:49] *** justatheory joined
[03:21] *** vel joined
[03:23] <azuroth> ?eval

[03:24] <azuroth> ?eval 5

[03:24] <evalbot_9860> 5

[03:25] <azuroth> ?eval sub infix:<+|+>($a,$b){abs($a) + abs($b)}; say 10 +|+ 3; say 10 +|+ 5; say 10 +|+ -2;

[03:25] <evalbot_9860> OUTPUT[11 15 -2 ] bool::true

[03:27] <azuroth> ahh, the infix sub isn't actually doing anything

[03:29] *** FurnaceBoy_ joined
[03:34] *** Khisanth joined
[03:45] *** Quell joined
[03:46] *** mako132_ joined
[04:00] *** pdcawley joined
[04:05] *** Khisanth joined
[04:46] <arcady> probably cause it's parsing as 10 +| + 3 or so

[04:49] <azuroth> what would + | mean, I wonder

[04:49] <azuroth> ?eval +|

[04:49] <azuroth> ?eval 5 +|

[04:50] <evalbot_9860> Error:  unexpected "|" expecting "0" or fraction

[04:50] <evalbot_9860> Error:  unexpected end of input expecting end of input or term

[04:50] <azuroth> ?eval 5 +| 2

[04:50] <evalbot_9860> 7

[04:50] <arcady> bitiwse or

[04:50] <azuroth> ohh yeah!

[04:51] <GeJ> morning folks

[04:51] *** kanru joined
[04:51] <azuroth> ?eval 5 ~| 2

[04:51] <evalbot_9860> "7"

[04:51] <azuroth> ?eval "blah" ~| "bana"

[04:51] <evalbot_9860> "bmoi"

[04:51] <arcady> ?eval 5 ?| 2

[04:51] <evalbot_9860> bool::true

[04:52] <arcady> ?eval 4 ?| 2

[04:52] <evalbot_9860> bool::true

[04:52] <azuroth> I totally forgot about that. duh

[04:52] <arcady> yeah

[04:52] <arcady> lots of those operators

[04:59] <azuroth> ?eval sub circumfix:<|...|>($a) {abs $a}; say |-5|

[04:59] <evalbot_9860> Error:  unexpected end of input expecting end of input or term

[04:59] <azuroth> ?eval sub circumfix:<||>($a) {abs $a}; say |-5|

[05:00] <evalbot_9860> Error:  unexpected end of input expecting end of input or term

[05:05] <TimToady> that'd be circumfix:<| |> these days.  You use whitespace to make a two element slice.

[05:06] <TimToady> ?eval sub circumfix:<| |>($a) {abs $a}; say |-5|

[05:06] <evalbot_9860> Error:  unexpected end of input expecting end of input or term

[05:06] <TimToady> ah well...

[05:08] <arcady> ?eval sub circumfix:<| |>($a) {abs $a}

[05:08] <evalbot_9860> undef

[05:21] *** justatheory joined
[05:23] *** Barry joined
[05:26] <azuroth> ahh, okay

[05:27] *** justatheory joined
[05:30] *** Barry left
[06:05] <buu> ?eval 42

[06:05] <evalbot_9860> 42

[06:12] *** xinming joined
[06:26] *** ankurg joined
[06:42] *** cognominal joined
[06:44] *** iblechbot joined
[07:00] *** xinming joined
[07:14] *** ankurg joined
[07:26] *** drrho joined
[07:32] *** marmic joined
[07:33] *** kane_ joined
[08:42] *** elmex joined
[08:54] *** bsb joined
[09:04] *** chris2 joined
[09:16] *** LCamel joined
[09:52] *** tennin joined
[09:54] *** iblechbot joined
[10:02] *** clkao joined
[10:02] <svnbot6> r9861 | clkao++ | Implement slurpy bind.

[10:21] <autark> .trivia meanings_gr6 10

[10:41] <clkao> sub foo($a) { $a =:= $b }; foo($b)

[10:41] <svnbot6> r9862 | clkao++ | Use lexalias rather than mg for rw binds.

[10:41] <clkao> should it be true in foo?  it's ro alias to $b

[10:42] <audreyt> it is only true if $b is also ro.

[10:42] <audreyt> i.e. if $b is a proper Scalar, then no.

[10:42] <audreyt> variable($a) === variable($b) # =:= means something like this

[10:42] <clkao> ok, then the current implementation is doing the right thing

[10:43] <audreyt> good

[10:43] <clkao> almost there

[10:43] * audreyt was just looking at the tests

[10:43] <audreyt> "dynamic scope, are you kidding?" # clkao++

[10:43] <clkao> there's no test for this yet

[10:43] <audreyt> you know, you can do pad walker :)

[10:43] <gaal> anyone still have a url for that talk about functional programming and the game industry? I can't find it anywhere

[10:43] <clkao> i know

[10:43] <clkao> but i want to keep the file close to the original

[10:43] <audreyt> http://lambda-the-ultimate.org/node/1277

[10:43] <wolverian> gaal, http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf

[10:44] <wolverian> audrey beat me to it :)

[10:44] <gaal> sweet, thanks

[10:44] <audreyt> but you removed one level of indirection :)

[10:44] * audreyt is wrangling with Sporx for tomorrow's OSDC.tw tutorial

[10:44] <audreyt> 3hr about pugs... still don't know what to say

[10:45] <nothing_pasta> wow

[10:45] <nothing_pasta> this is such a PITA

[10:45] *** frederico joined
[10:45] <audreyt> then the day after, 3hr about haskell

[10:45] * audreyt ponders plagiarizing gaal's slides

[10:45] <audreyt> gaal: may I? :)

[10:45] <audreyt> or maybe I can plagiarize TimToady's tokyo slides

[10:45] <audreyt> TimToady: may I? :)

[10:46] <gaal> my slides? go ahead

[10:46] <audreyt> :D

[10:46] <audreyt> though that means I need to takahashify it

[10:46] <gaal> i'm giving that talk in yapc::na btw (hopefully updated with the new cool things :)

[10:47] <audreyt> woot :)

[10:47] <gaal> that == Peek, not the game one :)

[10:47] <audreyt> I know :)

[10:48] <gaal> huh, maybe we can do -C3DGame and I can talk about that

[10:48] <audreyt> -CGameOfLife

[10:48] <gaal> 3hr about haskell, cool

[10:49] <gaal> lots of work for you but how I wish I had that one year ago :)

[10:49] <audreyt> yeah, my 45min one really want to expand some details on the Tech part

[10:49] <audreyt> I think the Basics part is already very solid

[10:49] <audreyt> except for maybe typeclasses

[10:50] <audreyt> but then, typeclasses are hard

[10:50] <audreyt> anything else you hoped I'd cover more during the osdc.il talk?

[10:50] <gaal> re -CGameOfLife, ISTR there was some way of encoding information in GOL states? I mean a surprising way

[10:50] <gaal> typeclasses aren't THAT hard when you explain them right

[10:51] <gaal> forall, now that's hard. :)

[10:51] <clkao> sub foo ($foo, *@args) {}, @args will take all remaining ones, like (@array,3) for foo(1,@array,3), even if @array is not flatten with *@array?

[10:51] <audreyt> turing maching on -CGameOfLife

[10:51] <gaal> and in fact there's a natural segue to typeclasses in your talk (as you know)

[10:51] <audreyt> clkao: aye. the * in sig means "I flatten for you"

[10:52] <clkao> ah ok.

[10:58] <gaal> audreyt: if you do do the peek talk, I think I dropped a slide in the rule part, when giving the various synonyms for $-1.

[10:58] <audreyt> k

[11:05] <clkao> *yawn*

[11:08] <svnbot6> r9863 | clkao++ | Implement flattening for slurpy bind.

[11:10] *** TimToady joined
[11:12] <gaal> my favorite bit in that talk is "Factoid: C# exposes more than 10 integer-like data types, none of which are those defined by (Pythagoras, 500BC)."

[11:16] <clkao> audreyt: do you want to write a quick and dirty translator so i can run more tests under t/sub/ for bindings?

[11:22] *** iblechbot joined
[11:22] <audreyt> clkao: after osdc.tw sure

[11:22] <azuroth> more than ten integer types?

[11:22] <audreyt> gaal: lol

[11:22] <clkao> not during osdc? :p

[11:25] *** frederico joined
[11:44] *** elmex joined
[11:55] <bsb> how are the html synopses (?) generated?  Can we add a TOC?

[11:55] <bsb> at dev.perl.org

[11:59] <azuroth> I had a feeling some/at least one did. hum

[12:00] <audreyt> the http://search.cpan.org/dist/Perl6-Bible/ one did

[12:00] <audreyt> not sure how dev.perl.org one is genned

[12:01] <audreyt> might be Ask or Robrt's doing

[12:01] *** mako132_ joined
[12:02] <gaal> S08 will need to be retitled

[12:02] <obra> it's robrt's oing

[12:07] <audreyt> gaal: S08: Capture

[12:12] *** _meppl joined
[12:13] *** kolibrie joined
[12:17] *** Limbic_Region joined
[12:26] * bsb is emailing about the toc thing

[12:31] <gaal> audreyt: is there an outline for that doc yet?

[12:37] *** pmurias joined
[12:37] <pmurias> hi all

[12:46] *** _meppl is now known as meppl

[12:46] *** meppl is now known as _meppl

[13:09] *** ruz joined
[13:12] *** stevan joined
[13:19] *** fglock joined
[13:19] <pmurias> hi fglock

[13:19] <fglock> hi

[13:22] <fglock> how does the p6 tokenizer work? does it lookup in a table of previously defined subs/macros?

[13:24] *** turrepurre joined
[13:27] <fglock> is Miniperl::Tokenizer in Parrot dist usable?

[13:34] *** xinming joined
[13:38] *** feng123 joined
[13:38] <pmurias> it's from 2002, and p6 changes at a frightning pace

[13:40] <pmurias> regarding the first question, i would like to know myself

[13:40] <fglock> I mean, how complex is the tokenizer supposed to be? like, is $a tokenized like '$','a' or '$a'

[13:42] <pmurias> the tokenizers are generaly meant to encapsulate the low level parts of parsing so $a should be tokenized into $a

[13:43] *** vel joined
[13:46] <cognominal> http://perlmonks.org/?node_id=541711 # recursive anonymous subroutine

[13:46] <cognominal> I know this is possible in javascript. Is it in Perl6?

[13:48] <cognominal> http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Functions:arguments:callee  # how it is done in js

[13:48] <bsb> http://dev.perl.org/perl6/doc/design/syn/S06.html#The_&?ROUTINE_object

[13:49] <bsb> &?BLOCK for anon closures

[13:49] <bsb> I mean blocks

[13:50] <clkao> what's the difference between slurpy scalar and normal scalar in parameter list?

[13:51] <fglock> cognominal: this is a snippet from a p6 sub in PCR: $alt = ruleop::concat( $node, ruleop::optional( sub { $alt(@_) } ), );

[13:53] <cognominal> ho, the general answer is &$ROUTINE, I think

[13:53] <cognominal> bsb, thx for pointing to me to the right part of the doc

[13:54] <bsb> nws

[14:02] <bsb> Is a zero invocant multi allowed? multi sub test ( : $one, $two) { ... }; test( : 1, 2);

[14:02] <bsb> or is that just total nonsense?

[14:03] <Juerd> I thought invocants were methodthings, not subthings

[14:05] <Limbic_Region> cognomial - did you read further down in that thread - the p6 example was given

[14:06] <Limbic_Region> cognomial - see http://perlmonks.org/index.pl?node_id=541736

[14:07] <bsb> Juerd: maybe.  I thought in multis is invocants meant the things dispatched on (although I can't find anything to back that up)

[14:08] <Juerd> No, all arguments are used for dispatching, afaik

[14:12] <bsb> E06 has "The parameters that the interpreter is going to consider when deciding

[14:12] <bsb> which variant to call are specified to the left of a colon (C<:>)"

[14:13] <bsb> L<E06/Many parts>

[14:14] <Juerd> I see

[14:24] *** justatheory joined
[14:25] <azuroth> you can have multis with no params at all, can't you, so presumably so? ( infix:<+>() )

[14:26] <Juerd> What would there be to multi?

[14:26] <Juerd> And how can an infix operator not have arguments?

[14:27] <azuroth> it's er, magic I guess

[14:27] <azuroth> for the reduce magic

[14:27] <azuroth> unless I'm mistaken

[14:28] *** rashakil joined
[14:28] <fglock> Juerd: '[+] @a' with an empty @a

[14:29] <fglock> or one element

[14:30] *** Qiang joined
[14:30] <Juerd> Ah, I didn't know it'd use mmd to decide the value

[14:30] <Juerd> so multi sub infix:<+> { 0 } ?

[14:30] <Juerd> multi sub infix:<*> { 1 }

[14:31] <azuroth> s/>/>()/

[14:31] <Juerd> Oh, right

[14:31] <azuroth> and there's infix:<*>($a) { $a }  which is invoked on [*] 5

[14:36] *** siosiosios joined
[14:37] *** xinming joined
[14:44] *** fglock left
[14:55] <azuroth> girls on film!

[14:58] <svnbot6> r9864 | clkao++ | Bind slurpy hash for args.

[15:00] <Juerd> azuroth: Hmmm... So, would an infix:<+>(*@_) be callable via [+]?

[15:01] <azuroth> humm. only two-elems at a time, I believe

[15:01] <pmurias> azuroth: what did 'girls on film!' refere to?

[15:01] <Juerd> azuroth: That's too bad, because a listop would be able to optimize.

[15:02] <azuroth> yeah, it's a good idea

[15:02] <Juerd> azuroth: i.e. return 0 if any(@_) == 0, in infix:<*> :)

[15:02] <azuroth> pmurias: I was just listening to it and was bored

[15:05] *** b_jonas joined
[15:07] <pmurias> azuroth: i mostly listen to the bbc 'Arts & Drama' section while coding

[15:08] *** FurnaceBoy_ joined
[15:12] <svnbot6> r9865 | clkao++ | Slurpy scalar, whatever it means.

[15:12] <svnbot6> r9864 | clkao++ | Bind slurpy hash for args.

[15:13] <azuroth> bbc's arts and drama section? is it radio plays, or..?

[15:19] <pmurias> lots of different stuff stories,plays,interviews

[15:32] *** elmex joined
[15:36] *** chris2 joined
[15:39] *** ghenry joined
[16:00] *** hexmode joined
[16:05] *** amnesiac joined
[16:08] *** fglock joined
[16:12] *** bsb_ joined
[16:17] <azuroth> night all

[16:17] *** q[uri] joined
[16:26] <pmurias> fglock: i'm abandoning xs towards Inline

[16:43] <LeTo> mutt

[16:43] <LeTo> oops

[17:19] *** tcliou joined
[17:24] *** kane_ joined
[17:25] *** zgh joined
[17:46] *** frederico joined
[17:51] *** _meppl is now known as meppl

[17:54] *** clkao joined
[19:07] *** rw-rw-r-- joined
[19:09] <gaal> seen putter

[19:10] *** Eimi joined
[19:23] *** justatheory joined
[19:43] *** fglock joined
[19:55] *** colares joined
[20:03] *** penk joined
[20:13] <TimToady> Juerd, azuroth: reduce is now defined in terms of list ops so we can optimize listily.  The listop is autogenerated from the infix only if there is no explicit reduce listop.

[20:13] <TimToady> Thanks.

[20:14] *** SamB joined
[20:15] <PerlJam> "explicit reduce listop"?  what does that mean exactly?

[20:15] <PerlJam> A sub literally named "reduce" or the punctuation form or what?

[20:15] <Steve_p> listily?

[20:17] <PerlJam> BTW, TimToady++  you deserve more karma than we can ever give, but here's a pittance anyway

[20:20] <TimToady> PerlJam: read lastest S02 diffs on p6l.  "proto prefix:<[*]> (*@args)" is one way to declare a reduce op.

[20:21] <PerlJam> ah, I see.

[20:21] <TimToady> (There is still a "reduce" operator that takes a slurpy closure too.)

[20:21] <TimToady> and in fact many of the built-in reduce ops are just curried from that.

[20:23] <TimToady> er, I meant S03 diffs.  S02 is about "long dot".

[20:24] <TimToady> fglock: P6 tokenizer is defined through <%hash> mappings, where the hash key is the "longest token", and the hash value is the rule that triggers from it.

[20:25] <TimToady> I originally thought that %hash would magically map multiple syntactic categories by declaration, but

[20:25] <TimToady> we might allow <%statement_control|%prefix|%term> or some such to

[20:26] <TimToady> specify inline that certain grammatical categories are treated together under longest rule, but

[20:26] <TimToady> *longest token rule

[20:26] <TimToady> but if the same token occurs in multiple hashes, the first hash wins.

[20:27] <fglock> ok

[20:28] <TimToady> otherwise that'd have to be implicit in %hash, and it'd be nice to have the pecking order explicit in the grammar.  On the other hand,

[20:28] <TimToady> if we want to allow people to add new grammatical categories on the fly, they'd have to rewrite all the rules, which is bad

[20:29] <TimToady> so maybe we want some way to declare a hash as a composite of a list of hashes.

[20:29] <TimToady> or maybe a grammar rule of the form <@hashlist> has that semantics.

[20:30] <TimToady> then the user could just push another %hash onto @hashlists, or splice it in.

[20:31] <TimToady> So basically the ordinary alternation of <@array> would have to be smartened about hash alternatives.

[20:33] <TimToady> And we'd have to figure out what happens if you intermix rules with hashes inside @array.

[20:33] <fglock> how about use a 'grammar' instead of a hash, and the rules replace the function of the hash elements

[20:34] <fglock> that's how I'm implementing categories currently

[20:35] <TimToady> I think any of <$foo> <@foo> <%foo> should allow any kind of matching object as long as longest-token can be preserved across all constant prefixes of everything inside <>.

[20:36] <fglock> and allow a grammar to be implemented procedurally - I think PGE bottom-up API works like this too

[20:36] <TimToady> I don't think a grammar can currently tell you its longest token keys.

[20:37] *** mind joined
[20:37] <TimToady> You can always call a grammar under the null key of a hash too as the default when longest-token fails.

[20:38] <TimToady> we have to be able to mix two grammars prefix tokens under longest token.  If we can't, it's arguably borken.

[20:38] <TimToady> *grammar's

[20:41] *** q[uri] joined
[20:42] <fglock> sorry, it looks like I was mixing the tokenizer and the precedence parser functions in my comments

[20:42] *** segv joined
[20:43] *** mind left
[20:44] <segv> hi i was just reading audrey's perlcast and she said she wants help from english speakers who know POD

[20:44] <segv> so that's me

[20:45] <segv> i was looking at the pugs blog and couldn't find out how to 'announce my availability'

[20:45] <segv> help?

[20:45] <fglock> the tokenizer is lexical, right? like in the case of a user-defined infix:<xxx>, where xxx must be added to the lexer

[20:46] <arcady> segv just wait a while, audreyt will show up eventually

[20:46] <TimToady> basically, the <%hash> mechanism is your tokenizer that's called from bottom-up parser.  It can dispatch down into any number of subgrammars or subrules to parse the token top-down (and perhaps drop back into a lower-level bottom-up parser if the token contains subexpressions.)

[20:48] <TimToady> Yes, the %hash or @hashlist in question would probably be lexically scoped from the standpoint of the program, which usually means dynamically scoped from the standpoint of the compiler.

[20:49] <TimToady> And $?PARSER is meant to track the current top-level grammar (so eval is in terms of the current parser, for instance.)

[20:50] <TimToady> so maybe PARSER is really a pseudopackage that can contain the current grammar and any supporting hashes.

[20:50] <TimToady> or maybe we can unify it with COMPILING.

[20:50] <TimToady> except

[20:51] <TimToady> COMPILING is specifically the lexical scope that's compiling, and my $x has different scoping rules (as a name) than "macro foo".

[20:52] <TimToady> The parser has pseudo-lexical scopes from "here to end of scope", whereas my $x is the same scope for the whole COMPILING scope.

[20:53] <TimToady> in other words, a new macro of the same name changes the grammar, but a new my $x doesn't introduce a new variable.

[20:53] <TimToady> so I don't think we can unify them.

[20:55] <fglock> but the change is lexical, like, can I call the OUTER macro?

[20:56] <TimToady> either that, or it's just erroneous to redefine the grammar that way after you've used a macro that depends on the old definition.

[20:57] <TimToady> you can always use OUTER:: explicitly.

[20:57] <TimToady> the question is, if you don't use OUTER:: on something that is outer,

[20:57] <TimToady> and then redefine it in the current scope, is it only variables and subs that complain?

[20:57] <TimToady> or do we also make grammars follow the same rules?

[20:58] <TimToady> trouble is, you have to expand a macro immediately, before you know

[20:58] <TimToady> the definition will change, but you can always complain anyway, I suppose, when you see the redef.

[20:59] <TimToady> on the other hand, we did in fact parse the beginning of the block with a different parser than the end of the block, and trying to level that like we levelled my $x might be a bad plan.

[21:00] <TimToady> otherwise we're in the situation that an eval is always parsed with the parser that was in effect at the end of the block rather than where the eval is situated.

[21:00] <TimToady> and that would make retroactive macros "work".

[21:01] <TimToady> and that seems kinda wrong to me.

[21:01] *** segv left
[21:02] *** mj41_ joined
[21:03] <TimToady> So if we view a grammar as a dynamic value in the parser, we'd basically have to snapshot all the data structures whenever we see $?PARSER (implicitly in eval).

[21:03] <TimToady> I didn't say that well.

[21:03] *** rindolf joined
[21:03] <TimToady> s/grammar/parser/ and s/parser/compiler/

[21:04] <TimToady> er, in the other order :)

[21:05] <PerlJam> you guys are speaking greek again.

[21:05] <TimToady> so $?PARSER is a funny kind of closure, really.

[21:05] <TimToady> No, we're just assuming intimate familiarity with various things including the synopses.

[21:06] * fglock has lazy familiarity

[21:06] <TimToady> :)

[21:07] <TimToady> Okay, when I say "we", it's mostly the royal "we".  :-)

[21:07] <TimToady> but the basic underlying priniciple to grasp is that the compilation of a lexical scope is really a dynamic scope from the standpoint of the compiler.

[21:09] <TimToady> oops, I killed kolibrie...  :/

[21:09] <fglock> 'grammar' is just an object, and the p6 compiler grammars exists both at parse and runtime, right?

[21:10] <TimToady> yes, but that's not the whole story.

[21:10] <TimToady> A grammar by itself seems like something immutable, but if we tweak

[21:11] <TimToady> the grammar with data structures that add, say, macros,

[21:11] <rindolf> TimToady: you keep using "X is just a funny kind of Y"? Does this mean "X is-a Y"?

[21:11] <TimToady> then we don't have immutable objects, and we have to think about how to COW.

[21:12] <TimToady> I doubt all my analogies are Liskovian...

[21:12] *** pmurias_ joined
[21:13] <merlyn> and do you mean funny ha ha, or funny strange? :)

[21:13] <TimToady> but if you think of my analogies as more like deriving from prototype objects, then it's more of a "is a child of".

[21:13] <PerlJam> Um ... when does a grammar become immutable?

[21:13] <TimToady> in the non-class-based OO languages such as Self or Javascript.

[21:14] * obra keeps meaning to look at Self

[21:14] <TimToady> when you take a snapshot of it so that the $?PARSER variable can mean the same thing at runtime that it meant at that moment of compile time.

[21:14] <TimToady> .oO(should I confess that I've never actually looked at Self myself?)

[21:14] <PerlJam> Then the next obvious question is "how?"

[21:14] <merlyn> just gotten it all secondhand?

[21:15] <merlyn> Class::Prototyped is vaguely close to Self

[21:15] <TimToady> er, copy on write.  Implementation details left to the reader.  :)

[21:15] <merlyn> javascript is also similar

[21:15] <merlyn> newtonscript is also similar

[21:15] <TimToady> .oO(should I confess that I've never actually looked at Smalltalk?)

[21:15] <fglock> I was thinking in terms of, at runtime, macros are defined again, so you don't have to remember the grammar state

[21:16] <merlyn> ahh, that explains perl5's object model. :)

[21:16] <fglock> as it was at parser time

[21:16] <fglock> so the runtime grammar can actually be different in some contexts

[21:16] <PerlJam> fglock: that seems weird.

[21:16] <TimToady> I think it would a lot cleaner to just remember the parser state than to try to reconstruct it.

[21:17] <TimToady> I made that mistake in Perl 4...

[21:17] <merlyn> if you actually understood smalltalk, you might be able to explain the place where the universe folds back in on itself

[21:17] <TimToady> had two different engines, one to do constant folding, and one to do "real" evaluation, and they were always getting out of sync.

[21:17] <PerlJam> I liked the idea of lexical changes for humans equate to dynamic changes for grammars that you mentioned earlier.  That had some truth-feel to it.

[21:17] <TimToady> I'll let Stevan explain all the MOP stuff.  :)

[21:18] <TimToady> and the MMOP stuff.

[21:18] <TimToady> and the MMMOP stuff.

[21:18] <TimToady> and the MMMMOP stuff.

[21:18] <TimToady> ...

[21:19] <merlyn> yeah, I'm not sure he really understood the smalltalk magic either

[21:19] <PerlJam> I thought we had at most 2 turtles?

[21:19] <PerlJam> :-)

[21:19] <theorbtwo> PerlJam++

[21:19] <merlyn> it seems like he reinvented what they did in smalltalk76, before they had the insight that led to smalltalk 80

[21:19] <merlyn> but I didn't have enough time to describe the differences to him

[21:20] <TimToady> I think he'd be interested in hearing what you have to say about it, but I suspect he's probably thought about it already.  I've been feeding him different specs that the Smalltalk people were working from...

[21:21] <merlyn> this is pretty good - http://www.ifi.unizh.ch/richter/Classes/oose2/05_Metaclasses/02_smalltalk/02_metaclasses_smalltalk.html

[21:21] *** bzerodi joined
[21:21] *** tennin joined
[21:21] <TimToady> s/that/than/

[21:23] <TimToady> Perl 6 isn't limiting itself to SI or SMD or even class-based objects.  Behind .meta we can hide multiple MOPs, so if Stevan's default one is wrong, we can always swap it out.  :-)

[21:24] <TimToady> I think Stevan's already on his 3rd or 4th model himself...

[21:24] <PerlJam> at least

[21:26] <PerlJam> What's really weird for me is that things that are "static" aren't.  But as long as I don't have to understand how they aren't static in order to use them, we're doing the right thing I think.

[21:26] <PerlJam> (I should say parts of the object model that I've always thought of as "static" aren't)

[21:27] <PerlJam> It's almost like Einstein creating space-time

[21:34] *** bsb_ left
[21:36] <gaal> say, what's the benefit in the style of sub definitions used in lrep and co.?

[21:36] *** iblechbot_ joined
[21:36] <gaal> *{subname} = sub { ... }

[21:36] <fglock> what kind of parser the p6 bottom-up parser needs to be? (SLR, LALR...)

[21:37] <fglock> gaal: it was intended as a way to define unicode names

[21:37] <gaal> ah, clever :)

[21:41] <TimToady> fglock: p6 bottom up is intended to be satisfiable with a mere operator precedence grammar.  PGE already does that.

[21:42] <TimToady> anything else can just be top-down, and doesn't have much impact on performance.

[21:42] <TimToady> since the big top-down hit is descending through 22 levels of precedence on each term.

[21:42] <TimToady> an operator precedence gets rid of that.

[21:43] <gaal> FWIW, wikipedia says that "Parsec is a monadic parser combinator library for Haskell, which can parse LL(\infty), context-sensitive grammars, but performs best when the grammar is LL(1)."

[21:43] <TimToady> op prec also lets us install new precedence levels trivially as data rather than recompiling the whole grammar.

[21:44] <TimToady> basically we just do top-down when we need a term to look ahead, which is supposed to be rare in P6.

[21:45] <TimToady> unless you count things like $ looking ahead too see if the next thing is a "foo".

[21:46] *** ruoso joined
[21:46] <TimToady> all those top-down term rules are supposed to be dispatched through the <%hash> mechanism, one way or another, though we were thinking up some variations earlier.

[21:47] <gaal> oh, TimToady: the other day I noticed Math::Base::sign(undef) and <=> return undef and thought they should fail, but then I wasn't sure. what do you think?

[21:47] <gaal> <=> in particular for one-liners should perhaps not fail

[21:48] <TimToady> I guess I don't follow you...

[21:48] <gaal> TimToady: the spec says that Math::Base::sign(undef) returns undef; and is basically equivalent to "<=> 0"

[21:49] <gaal> first time I saw that, it looked like this should not return undef, but rather fail;

[21:49] <TimToady> Ah, gotcha.  Yes, in general, anything that would return undef in p5 should be a fail in p6

[21:49] <TimToady> but fail in one-liner context *does* return undef.

[21:50] <gaal> ah, because that has no fatal in effect?

[21:50] *** justatheory joined
[21:50] <TimToady> well, our default of "no fatal" still tries to fail if you throw away such a value without looking at it somehow.  So it could still die even without "use fatal".

[21:51] <TimToady> but it's lazy death.  :)

[21:51] <TimToady> or lazy exceptions, if you will...

[21:51] <gaal> okay, what does this do? { no fatal { fail; CATCH { say "failed" } }

[21:52] <gaal> (missed the semicolon there after the pragma directive)

[21:52] <TimToady> return the failure, ignoring the CATCH.

[21:52] <gaal> okay, good.

[21:53] <gaal> then I think I do understand how that works.

[21:53] <TimToady> it's the caller's policy that controls it.

[21:53] <gaal> yeah. nothingmuch mentioned something that spooked me, but either he was wrong or he meant something different from what I took him to mean.

[21:54] <ruoso> TimToady, but... if in "no fatal" it returns undef... how one can differ "fail" from "return undef"?

[21:54] <stevan> merlyn: we tossed out the Smalltalk 76 meta-meta-meta-meta-... stuff several months ago

[21:55] <gaal> ruoso: if they decided to turn off out of band signalling, they'll have to deal with the semipredicate problem

[21:55] <TimToady> in general one should not be using undef to represent a meaningful value without attaching more data to it.  fail at least lets you attach a failure exception.

[21:55] <merlyn> OK, I haven't kept up

[21:55] <stevan> merlyn: at this point the model is a cross between Smalltalk 80 and CLOS

[21:55] <ruoso> TimToady, but... what if undef *is* a meaningful value?

[21:55] <ruoso> like... for accessing a value in a database

[21:56] <TimToady> what part of "undefined" do you not understand?

[21:56] <stevan> merlyn: and some prototype-ish stuff thrown in for good measure

[21:56] <PerlJam> ruoso: don't decorate it ?

[21:56] *** fglock left
[21:56] <TimToady> we have many undefined values now, and undef only returns an undecorated one.

[21:57] <ruoso> hmm...

[21:57] <TimToady> but if you want an interesting value of undef, we have lots of ways to produce them.

[21:57] <ruoso> now I understand...

[21:57] <stevan> merlyn: Class::MOP and Moose (both on CPAN) are the most recent "versions", both of which the *next* Perl 6 MOP will likley be based on

[21:57] <TimToady> $x = 1 / 0; produces an interesting value of undef now, for instance.

[21:57] <merlyn> I need to read those

[21:58] <stevan> merlyn: I would love any feedback you have to offer

[21:58] <TimToady> which probably even evaluates to Inf in a numeric context.

[21:59] <merlyn> in my copious spare time

[21:59] <gaal> \x -> reverse ("PO" ++ take x (repeat 'M'))

[21:59] <ruoso> TimToady, and, in some way, tells me "Division by Zero Error"...

[22:00] <ruoso> if I ask for it

[22:00] <TimToady> ruoso: yes, if you try to misuse it as a real numeric value.

[22:00] <TimToady> it'll even tell you where you did the division by zero.

[22:00] <TimToady> Think of interesting values of undef as little cockpit recorders that will tell you why the plane crashed.

[22:00] <gaal> ruoso: it's like a hot potato you can keep passing around as long as you don't try to eat it.

[22:00] <theorbtwo> And, I assume, there's some method you can call on an interesting undef that will give you it's data?

[22:01] * theorbtwo likes that analogy.

[22:01] <ruoso> gaal++

[22:01] <PerlJam> Just keep in mind that perl6 is *Very* lazy :)

[22:01] <theorbtwo> Well, I thought there were two things you couldn't do: eat it or throw it away.

[22:01] <TimToady> theorbtwo: yes, you can use methods to get at the interesting bits,

[22:01] <TimToady> depending on the type of the undef.

[22:03] <TimToady> you can't throw away an unthrown exception, but other kinds of undef might be discardable.

[22:04] <TimToady> if you never do anything with plain undef, it probably shouldn't fail.

[22:04] <TimToady> on the other hand, most of the places that fail are not returning plain undef.

[22:04] <TimToady> but undef containing an unthrown exception.

[22:04] <PerlJam> What's the "tell me more about yourself" method for undef?

[22:04] <TimToady> or maybe even a bunch of unthrown exceptions.

[22:05] <TimToady> depends on what kind of hierarchy we set up.  An undef is really just anything that returns false from .undefined.

[22:05] <TimToady> *.defined rather

[22:06] <theorbtwo> It occours to me that we can have a .undefined method, which returns the interesting thing, and allow the magic of unthrown execptions to be all in the interesting thing.

[22:06] <TimToady> I'd imagine that $x.error or some such would be valid on unthrown exception thingies.

[22:06] <theorbtwo> Boring undefs just have a .undefined of 1.

[22:07] <theorbtwo> Unthrown exceptions complaign in their DESTROY, unless shut up by the .catch method.

[22:07] * PerlJam wanders off to pick up kids ...

[22:07] <TimToady> Yes, it's probably a good idea to feed it all through a single method chokepoint, like .meta.

[22:07] * ruoso wonders that this will just make a big brain-lockup in the people from other languages that are used to declared exceptions...

[22:07] <TimToady> so we don't accidentally call something of the same name on the defined version.

[22:08] <TimToady> maybe it's even .UPPERCASED something to avoid collisions even harder...

[22:09] * theorbtwo doesn't think YELLING is really called for.

[22:09] <TimToady> $x.OOPS

[22:10] <TimToady> generally though the oops is just aliased to $!.

[22:12] <TimToady> makes me wonder if $x!foo can be overloaded for that...

[22:12] <TimToady> probably a bad plan.

[22:12] * theorbtwo thinks so.

[22:12] <theorbtwo> We already have plenty of ways to call methods with strange puncuation.

[22:12] <ruoso> in "my $x = foo()"... if foo can return two different "lazy exceptions (I just loved this name)" how is the syntax to catch it only if it's one of them?

[22:13] <TimToady> my $x = foo() err fail "Oopsie: $!" still works fine, I think.

[22:14] <theorbtwo> $! is the interesting bit of the most recently mentioned variable with an interesting bit?

[22:14] <theorbtwo> Seems overly magical.

[22:14] <TimToady> fail aliases $! in the callers scope to the interesting bits, basically.

[22:14] <theorbtwo> But what's the $! in the argument to fail?

[22:14] <TimToady> depends on what you fed to fail().

[22:15] <theorbtwo> But if we assume foo() called fail, you mean the grandcaller.

[22:15] <TimToady> or is that what you're asking?

[22:15] <TimToady> yes, technically it'd be the grandcaller.

[22:16] <TimToady> and one could do carpish tricks as well.

[22:16] *** Limbic_Region joined
[22:17] <ruoso> TimToady, hmm... that would catch any "lazy exception"... wouldn't it?

[22:17] <ruoso> if foo() can return the lazy exception BAR or the lazy exception BAZ...

[22:17] <TimToady> but the point is that we don't really need to set $! by checking the return value of foo() every time, supposing that fail() is capable of doing it only in exceptional situations.  That bodes well for performance.

[22:18] <ruoso> how could I catch only BAZ and not BAR?

[22:18] <TimToady> use fatal and write a CATCH block is one way.

[22:19] <TimToady> and maybe one can examine the type of the unthrown exception without marking it as "handled".

[22:19] <theorbtwo> It seems to me that you should be able to call whatever methods you want on the unthrown exception, so long as you don't use the word catch to do it.

[22:20] <TimToady> but at some point you probably just want to move to a standard exception catching mechanism.

[22:21] <TimToady> we currently mark an undef as handled if you test it for boolean or defined.

[22:21] <theorbtwo> That seems much too early.

[22:21] <TimToady> which is why the $! alias doesn't actually care about handledness.

[22:21] <TimToady> print $foo err fail $!

[22:21] <TimToady> has to work

[22:22] <TimToady> audreyt thrashed this out with me in Tokyo.

[22:22] <theorbtwo> So make $! change when you throw away an exception after checking for definedness (otherwise it'd die), but before marking it catched.

[22:23] <TimToady> mego

[22:23] <theorbtwo> mego?

[22:23] <TimToady> my eyes glaze over

[22:23] <theorbtwo> Ah.

[22:24] <TimToady> you can also say things like

[22:24] <TimToady> print

[22:24] <TimToady> print $foo err return;

[22:24] <TimToady> and that counts as handled.

[22:25] <ruoso> the magic is in the "err"...

[22:25] <TimToady> more specifically, in calling .defined on the result.

[22:26] <TimToady> $! is just a convenient way to get at the "last error" whether or not it has been handled.

[22:26] <ruoso> just like it is today... "last error" just means something more... informative...

[22:27] <TimToady> It also functions as an accumulator of unhandled exceptions, though if you really want bulletproof, you should be going with CATCH.

[22:28] <TimToady> so  $x = 1 / 0; print $foo err fail $!; is allowed to report both exceptions, not just print's.

[22:29] <TimToady> (probably with some coalescing of the "Last message repeated 42347 times" kind.)

[22:29] *** q[uri] joined
[22:29] <TimToady> so the innards of $! might actually be a hash.

[22:32] <ruoso> but it would be really nice to have a "lazy exception" throwing a warning if it's not handled and goes out of scope...

[22:32] <TimToady> more than a warning. the default is to throw it as a real exception as soon as we can determine that it is abandoned.

[22:33] <ruoso> even with "no fatal"?

[22:33] <TimToady> yes.

[22:34] <TimToady> we want print $foo to raise a real exception when you run out of disk space whether you ask it to or not.

[22:34] <TimToady> but if you're lazy it can be lazy.

[22:35] <TimToady> it's sort of GC for exceptions.

[22:37] <TimToady> nap attack coming on... &

[22:40] <TreyHarris> it's legal to say "my $foo = INIT { 3 };", isn't it?  and $foo should get 3 at INIT time?

[22:42] <arcady> $foo would get the value of 3 at INIT time, probably

[22:42] <arcady> which just so happens to be the same value that 3 has at most other times

[22:43] *** PolettiX joined
[22:43] <ruoso> so... $foo, at regular run time would receive the return value of the thing inside the block at init time...

[22:44] <ruoso> is it?

[22:44] <arcady> as far as I know, yes

[22:44] <arcady> that's what those blocks mean

[22:44] <arcady> "evaluate this block at init time"

[22:45] <arcady> things get confusing fast when the block drags its surroundings in with it to be evaluated

[22:45] <ruoso> "INIT {$*foo = 0}; $*foo = 4; $foo = INIT { $foo }; print $foo;" would print 0

[22:45] <ruoso> s/$foo/$*foo/

[22:46] <arcady> ?eval INIT {$*foo = 0}; $*foo = 4; $foo = INIT { $foo }; print $foo;

[22:46] <evalbot_9865> OUTPUT[4] bool::true

[22:46] <arcady> the evalbot begs to differ.

[22:47] <arcady> though I think it's probably wrong

[22:47] <ruoso> wait... the code was wrong...

[22:47] <arcady> ?eval INIT {$*foo = 0}; $*foo = 4; $*foo = INIT { $*foo }; print $*foo;

[22:47] <evalbot_9865> OUTPUT[4] bool::true

[22:48] <ruoso> yeah... some output

[22:48] <ruoso> s/some/same/

[22:48] <arcady> I think it should be 0 though

[22:49] <ruoso> arcady, hmmm... INIT { $*foo = 0 } returns a true value...

[22:49] <ruoso> it makes sense

[22:49] <ruoso> INIT is kind of special...

[22:50] <ruoso> it doesn't say it returns the value of the evaluating block

[22:50] <arcady> true

[22:50] <ruoso> it said: I did successfully evaluated that block at init time...

[22:51] <ruoso> makes sense...

[22:52] * ruoso thinks my $foo = INIT { bar }; should be written as: INIT { $*baz = bar }; my $foo = $*baz;

[22:53] <TreyHarris> so from S04, "Those marked with a * can also be used within an expression"... those examples need to be fixed

[22:53] <TreyHarris> because they certainly suggest this should work

[22:55] <TreyHarris> ?eval my $foo = INIT { 4 }; print $foo;

[22:55] <evalbot_9865> OUTPUT[4] bool::true

[22:56] <TreyHarris> ?eval my $foo = 4; print $foo;

[22:56] <evalbot_9865> OUTPUT[4] bool::true

[22:57] <arcady> ?eval my $foo = INIT { 4 }; INIT { print $foo }

[22:57] <evalbot_9865> OUTPUT[4] \bool::true

[22:58] <TreyHarris> ?eval bar(); my $foo = INIT { 3 }; sub bar () { print $foo }

[22:58] <evalbot_9865> OUTPUT[] \3

[22:59] <arcady> watch out though

[22:59] <arcady> evalbot and INIT are also somewhat confusing in their interaction

[23:00] <TreyHarris> pugs is too, at least the trunk i got a week ago

[23:00] <TreyHarris> same thing

[23:00] <TreyHarris> that's why i asked here

[23:00] <arcady> not pugs

[23:00] <arcady> just the interactive

[23:00] <arcady> because "at run time, ASAP" (the S04 definition of INIT)

[23:01] <arcady> means "now" in the case of evalbot

[23:01] <arcady> if you put this in a .p6 file and then run it

[23:01] <arcady> it will produce different output

[23:02] <arcady> so INIT blocks only work the way you think they should when you are actually compiling and running a file

[23:03] <pasteling> "TreyHarris" at 207.171.180.101 pasted "output of pugs is nil" (14 lines, 137B) at http://sial.org/pbot/16660

[23:04] <arcady> um. yes.

[23:04] <pasteling> "TreyHarris" at 207.171.180.101 pasted "but now, output of pugs is 72" (15 lines, 167B) at http://sial.org/pbot/16661

[23:05] <arcady> hm. that's somewhat weird

[23:32] *** mako132_ joined
[23:41] *** elmex joined
[23:45] *** hexmode joined
[23:52] <audreyt> yo

[23:52] * audreyt goes to osdc.tw

[23:52] <audreyt> bbiab

[23:53] <clkao> *yawn*

[23:54] <clkao> crap, i need to get to airport in 5 hrs

[23:59] *** larsen joined
