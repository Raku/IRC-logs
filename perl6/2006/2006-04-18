[00:07] *** lichtkind joined
[00:18] *** oylenshpeegul joined
[00:35] *** drrho joined
[00:44] *** azuroth left
[00:55] *** vel joined
[01:14] *** amnesiac joined
[01:18] *** lichtkind joined
[01:21] <lichtkind> ?eval sub 5 {5}; 5();

[01:21] *** evalbot_9982 is now known as evalbot_10007

[01:21] <evalbot_10007> Error:  unexpected "5" expecting "#", subroutine parameters, trait or block

[01:21] <lichtkind> ?eval sub l5 {5}; l5();

[01:21] <evalbot_10007> 5

[01:22] <lichtkind> ?eval sub l5 {5}; &l5;

[01:22] <evalbot_10007> \sub {...}

[01:22] <lichtkind> ?eval sub l5 {5}; l5;

[01:22] <evalbot_10007> 5

[01:23] <lichtkind> thanks evalbot

[01:54] *** LCamel joined
[01:56] *** LCamel joined
[01:58] *** LCamel joined
[02:02] *** LCamel joined
[02:03] *** stclare joined
[02:03] *** ko1_away0 is now known as ko1_away

[02:25] <avar> ?eval multi sub postfix:<!> (Int $num) { [*] 1 .. $num } 5!

[02:25] <avar> ?eval multi sub postfix:<!> (Int $num) { [*] 1 .. $num } say 5!

[02:25] <evalbot_10007> 120

[02:25] <avar> buu: boo!

[02:25] <evalbot_10007> OUTPUT[120 ] bool::true

[02:26] <buu> Wierdo

[02:26] *** oylenshpeegul left
[02:26] <avar> arg, it's just slow

[02:26] <buu> Yeah it is

[02:26] <buu> They done unhappiness to it.

[02:26] <avar> what kind of unhappiness?

[02:26] <buu> No idea

[02:29] *** mjk joined
[02:29] <wolverian> it's not niced, at least

[02:37] <mugwump> backtracking gone mad

[02:44] *** DesreveR joined
[02:58] *** saorge_ joined
[03:13] *** saorge_ joined
[03:26] *** FurnaceBoy_ joined
[03:28] *** LCamel joined
[03:29] *** FurnaceBoy_ joined
[03:37] *** mako132_ joined
[03:43] *** qu1j0t3 joined
[03:43] *** LCamel joined
[04:08] * PerlJam listens to Larry's talk from Israel  (rindolf++)

[04:08] *** FurnaceBoy joined
[04:13] *** avar left
[04:13] *** avar joined
[04:22] *** KingDiamond joined
[04:27] *** justatheory joined
[04:31] *** justatheory joined
[04:36] *** Khisanth joined
[04:55] <PerlJam> How does one ask a class what methods it contains?  And does the syntax of the question change if the "class" is a grammar and the "methods" are rules?

[05:00] <PerlJam> oh, I see that S12 mentions .getmethods() down at the end.

[05:03] * mugwump titters

[05:03] <mugwump> yes, er, slightly underspecced, you might say :)

[05:04] <PerlJam> In the slides to Larry's talk he has an example like Float.top("-6.02e+23"); print $/{'sign'};  How would I know that there is a "sign" thingy in Float if I didn't have access to the source?

[05:04] <PerlJam> This is what prompted the original question.

[05:04] <mugwump> $/.meta.getmethods

[05:05] <mugwump> quite what that *is* or *does* is not yet clear :)

[05:06] <PerlJam> maybe I'll ping TimToady on it tomorrow if he's around  :)

[05:07] <mugwump> you might like to ask stevan.  Larry'll just end up designing off the cuff.  and we know where that leads

[05:08] <PerlJam> yeah, it leads to unexpected places.  That's all part of the adventure  :)

[05:11] *** KingDiamond joined
[05:18] <pmichaud> hello, pj

[05:18] <PerlJam> greets pm

[05:18] <PerlJam> What's new in the world?

[05:19] <pmichaud> just continuing to make progress on a compiler :-)

[05:19] <PerlJam> Any low hanging fruit on that compiler?

[05:19] <pmichaud> yes, and people seem to be picking a lot of it :-)

[05:20] <pmichaud> leo improved lexical handling today, and I've fixed up listop parsing and restored "if"

[05:20] <pmichaud> we can skip pod comments and the long dot

[05:21] <mugwump> pmichaud: are you using fglock's grammars ?

[05:22] <pmichaud> mugwump: not really -- working a slightly different one

[05:22] <pmichaud> so far I can read mine better than fglock's

[05:22] <mugwump> right.  the interesting thing to me about flavio's work was the circularity of it

[05:23] <mugwump> do you think that is important?

[05:23] <pmichaud> circularity?  as in...?

[05:23] <PerlJam> pm: why does line 69 of grammar_rules.pge say  print "\n"  ?

[05:23] <mugwump> pmichaud: in particular, the rules that define the grammar for rules.  ie, the "bootstrap"

[05:24] <pmichaud> mugwump: oh, I had that early own.  But rule expressions really need to be parsed bottom-up and not top-down

[05:24] <pmichaud> s/own/on/

[05:24] <pmichaud> so I've since switched to doing a bottom-up parse of rule expressions

[05:25] <pmichaud> also, it's circular in the sense that a rule can call the bottom up parser, so we can have a rule to parse perl6 rules.  In PGE/Parrot it's just  <p6rule>

[05:25] <mugwump> right.  very interesting

[05:25] <mugwump> so, it's not recursive descent, it's continuitive ascent?

[05:25] <pmichaud> shift/reduce

[05:26] <pmichaud> shift/reduce with operator precedence

[05:27] <PerlJam> mugwump: it's "try this parsing strategy for a while, then try this other one for a while" with free movement between them  :)

[05:27] <pmichaud> pj: what version are you at?

[05:27] <PerlJam> pm: 12318

[05:27] <pmichaud> except in the PGE grammar case there's very little "try" to it

[05:27] <pmichaud> i.e., it's "okay, now we get this sort of thing -- next we get that sort of thing", etc.

[05:27] <mugwump> ok, is that a similar concept to "backtracking" ?

[05:27] <pmichaud> hardly any backtracking

[05:28] <PerlJam> mugwump: It's more like sidestepping  :)

[05:28] <pmichaud> the operator precedence parser and grammar can generally figure out what to do next by looking at the next character

[05:28] <pmichaud> (or very short string)

[05:28] <PerlJam> sometimes you want to be on the fast moving conveyor belt, sometimes you want to be on the slow moving one, but they're both moving in the same direction.

[05:29] <pmichaud> pj: I see no "print" statement in lib/grammar_rules.pge

[05:30] <mugwump> I'm still having a little difficulty seeing how that differs from the ivory tower parsing indoctrination I am afflicted with (ie, "state machine" parsing for regular languages and "recursive descent with back-tracking" for CFG's)

[05:31] <mugwump> is there a good place to start reading about this?

[05:31] <pmichaud> bottom-up is essentially a state machine parse

[05:31] <pmichaud> with a couple of stacks to keep track of operator precedence

[05:31] <pmichaud> recursive-descent with backtracking is essentially perl6 rule syntax

[05:31] *** LCamel joined
[05:32] <PerlJam> pm: weeeeirrrrrrd.  now it's gone!  I won't question my sanity, but maybe I was being fooled by a some leftover junk in a vim buffer

[05:32] <mugwump> OH.  now THAT'S cool :)

[05:33] <pmichaud> Here's the current grammar I have

[05:33] <pmichaud> http://svn.perl.org/parrot/trunk/languages/perl6/lib/grammar_rules.pge

[05:33] <PerlJam> pm: btw, are you running FC5?

[05:34] <pmichaud> pj: I'm running SUSE 10.0

[05:34] <pmichaud> I have FC5 here and put it on the laptop, but decided I liked SUSE better (it's been on my desktop since jan)

[05:35] <pmichaud> http://svn.perl.org/parrot/trunk/languages/perl6/lib/grammar_optok.pge has the operator definitions

[05:35] <pmichaud> (as well as the inline code for Parrot/PIR)

[05:36] <PerlJam> pm: well, fyi, I've yet to have a single fc5 install go smoothly.  On the laptop and desktop (an install and upgrade respectively), it errored out of the install and I had to start over. And on the old meridian, the install *seemed* to go fine, but when it reboots, it boots to a grub prompt.

[05:36] <pmichaud> hmmm

[05:36] <pmichaud> I didn't have any trouble with my fc5 install

[05:36] <pmichaud> boot to dvd, set up partitions, install, done

[05:36] <pmichaud> (had to work a bit to get the wireless card to work, but that's not uncommon)

[05:38] <mugwump> pmichaud: that file you linked looks very like early pugs source

[05:38] <pmichaud> really?  wow, that's good

[05:38] <mugwump> pmichaud: which file in the parrot source is the pge bootstrap?

[05:38] <mugwump> pmichaud: do you grok Haskell?

[05:39] <pmichaud> nope, I looked at Haskell enough to get a few ideas from it, but I can't really read it well yet

[05:39] <pmichaud> mugwump: the code for parsing perl6 rules is in   http://svn.perl.org/parrot/trunk/compilers/pge/PGE/P6Rule.pir

[05:40] <pmichaud> it adds a bunch of operator tokens, and has a few routines for specialized parsing

[05:40] <pmichaud> (e.g., literals, \x sequences, whitespace handling, etc.)

[05:40] <mugwump> ok.  is there a corresponding set of rules that can compile to something like that code?

[05:41] <pmichaud> there is now

[05:41] <pmichaud> :-)

[05:41] <pmichaud> the two *.pge files I sent earlier compile down to executable rules

[05:41] <pmichaud> just a sec

[05:41] <PerlJam> pm: done any benchmarking yet, btw?

[05:42] * PerlJam would guess not :)

[05:42] <pmichaud> mugwump: the grammar_rules.pge and grammar_optok.pge files I linked earlier compile to this:  http://www.pmichaud.com/sandbox/grammar_gen.pir

[05:43] <pmichaud> pj: no, I'm not far enough along to benchmark things just yet

[05:43] <pmichaud> working code first, then optimize :-)

[05:44] <PerlJam> yeah, I wasn't thinking about optimization as much as "ball parking"

[05:44] <pmichaud> no, I don't know.  It's very easy to write slow parsers, though

[05:45] <pmichaud> and it will likely speed up drastically once we have Capture in a .pmc (and when I've migrated Match to use Capture)

[05:45] <mugwump> pmichaud: right.  so, presumably, that initial bootstrap PIR file (P6Rule.pir) could be a temporary one - perhaps not even installed - that just builds the rules file to the grammar_gen.pir file, which is the one used by the rest of the system ?

[05:46] <pmichaud> mugwump: yes, it could happen that way, but for some time the bootstrap pir file is going to be more efficient than the generated one.  And at the parse level, speed is important

[05:46] <pmichaud> and keep in mind that P6Rule.pir just describes how to parse perl 6 rules, it doesn't actually generate the code

[05:47] <mugwump> right, but perhaps it could, if the perl6 rules could have PIR action blocks

[05:47] <pmichaud> oh, they already have that

[05:47] <mugwump> so, you could have the rules inline the relevant PIR pieces that generate the code

[05:48] <pmichaud> the code generation is a fair bit more complex than just emitting code from each node

[05:48] <pmichaud> essentially the PGE rules implementation is its own language -- has its own AST, optimization step, etc.

[05:49] <mugwump> yes, you would just call those hooks.

[05:50] <mugwump> probably just create an AST node, and let whatever is doing the parsing worry about the next steps

[05:50] <pmichaud> right

[05:50] <pmichaud> that's essentially what it does now

[05:50] <pmichaud> but I think the embedded pir code would end up looking a fair bit worse.  And we're not at a point where we can totally eliminate the pir

[05:51] <pmichaud> and I'm expecting/hoping we'll be able to translate a good bit of it into C

[05:51] <pmichaud> so it'll run quicker than it does now with Parrot op dispatch

[05:52] <mugwump> by embdedding the code to perform the AST building, there would be a huge chance of convergance between the grammars used by the three Perl6 ports

[05:53] <pmichaud> convergence is a good goal but it's not my primary one at the moment

[05:53] <PerlJam> mugwump: I think there's more to be had with convergence of minds than technology.

[05:54] * mugwump lets that comment fly straight out of left field and past

[05:55] <PerlJam> mugwump: What I mean is that there are several different approaches.  Let them feed each other ideas and see where they go rather than coming up with One Holy Grammar.

[05:56] <pmichaud> this is already happening

[05:56] <PerlJam> I mean, we really do have multiple perl6 implementations.  :)

[05:56] <mugwump> each port will have their own variances of it, it would just be great if the pieces that are agreed upon could be easily tracked with source

[05:56] *** p5evalbot joined
[05:57] <pmichaud> that's why I'm specifying the grammar using perl 6 syntax and not PIR :-)

[05:57] <mugwump> s/variances/variants/

[05:58] <pmichaud> and leaving the variances to other pieces rather than trying to embed them in the grammar

[05:58] <mugwump> right.  This is an interesting fault in the rules system, perhaps - perhaps this is a reason to allow rule bases that augment other rulesets with code blocks?

[05:58] <pmichaud> I could probably come up with a similar set of specs for p6rule parsing for some parts of it, but parsing literals and some of the other constructs is a real pain

[05:59] <pmichaud> PGE allows the factoring to take place at the subrule level -- i.e., a rule can call any subroutine using <sub>, not just a rule

[05:59] * PerlJam still wonders how you introspect grammars

[06:00] <pmichaud> pj:  essentially a rule is just a method on a grammar

[06:00] <PerlJam> MyGrammar.^getmethods()  hardly seems right though.

[06:00] <pmichaud> perljam: why not?

[06:01] <PerlJam> because it should be "getrules" or something.  Just because we've said A is just B doesn't mean it always makes sense to talk about B when you're really talking about A

[06:02] <pmichaud> pj: would you have a problem with   $/.getmethods()  ?

[06:02] <pmichaud> (or whatever we're calling the match object this week)

[06:03] <PerlJam> It's the same as above, so yes.

[06:03] <pmichaud> well, it works out okay for me

[06:04] <PerlJam> It feels like talking about my C variables in terms of machine registers when I should be talking about them in terms of ... well, C variables  to me

[06:07] <mugwump> well, there's no reason the meta-object for grammars has to be exactly the same as the one for classes

[06:08] <PerlJam> mugwump: indeed, I expect them to be different

[06:12] <pmichaud> I think tuesday's task will be to parse double-quoted string literals

[06:12] <PerlJam> Apparently allison has something against trailing "e" characters on filenames.

[06:12] <pmichaud> ..pj?

[06:13] <pmichaud> example?

[06:13] <PerlJam> pm: just just changed *.tge and *.pge to *.tg and *.pg respectively in the punie source

[06:14] <ayrnieu> (why .getmethods and not .methods ?)

[06:14] <PerlJam> s/just/she/

[06:14] <pmichaud> oh, that makes sense to me

[06:14] <pmichaud> .tg == tree grammar,   .pg == parser grammar

[06:14] <PerlJam> pmichaud: me too, it's just an odd thing to change really :)

[06:14] <pmichaud> I'll probably do the same in the perl6 tree

[06:15] <PerlJam> ayrnieu: Didn't you see the sign when you came in?  It says "here be dragons".  :-)

[06:18] *** nnunley_ joined
[06:20] <pmichaud> well, time for sleep

[06:20] <PerlJam> good night pm.

[06:20] * mugwump waves

[06:22] *** xern joined
[06:22] *** xern_ joined
[06:24] * PerlJam is likely to nod off soon too

[06:34] <audreyt> hm. I have an interesting (and probably useful) idea

[06:34] <audreyt> I wonder if someone has cycles to prototype it on perl5

[06:34] <audreyt> the API is very simple

[06:34] <audreyt> use pureperl; # prefer pure-perl libraries to xs ones

[06:35] <audreyt> use pureperl -fallback; # use pureperl ones if xs can't be found or not loaded

[06:35] <audreyt> the implementation is likewise simple

[06:35] <audreyt> pureperl::DBI will be a module that simply aliases the DBI::PurePerl symtable to itself

[06:36] <audreyt> pureperl::DBD::mysql ditto, for DBD::mysqlpp

[06:36] <audreyt> pureperl::Crypt::OpenPGP may actually be a wrapper that uses `gpg`

[06:36] <audreyt> and so on

[06:36] <audreyt> and all pureperl.pm does is

[06:36] <audreyt> 1. register the caller and the order of preference

[06:37] <audreyt> 2. hack @INC so that the pureperl/ subtree becomes part of it

[06:37] <audreyt> 3. turn itself off when "no pureperl" is registered in the nearer caller frame

[06:38] <audreyt> and the repository of XS->pureperl mappings will be maintained as part of pureperl.pm distro -- or each XS module can ship its own designated fallback in lib/Module/Name

[06:38] <audreyt> I mean lib/pureperl/Module/Name

[06:38] <audreyt> this could solve the infinitely complex Foo vs Foo_PP vs FooPP vs Foo::PurePerl problem

[06:39] *** bsb joined
[06:39] <PerlJam> audreyt: it would also solve the module-version-author problem with a few modifications.

[06:39] <audreyt> and enable applications and modules that want to depend on something that can be XS for performance and for PP if it can't be installed (eg relying on shared library)

[06:39] <audreyt> PerlJam: why, yes indeed. the idea is to not use coderef-in-@INC

[06:39] <arcady> that last one seems quite useful

[06:40] <audreyt> but instead use a link forest, the way kane intended in the 6PAN spec draft

[06:41] <audreyt> use pureperl-fallback; use A_lot_of_XS_modules

[06:41] <PerlJam> audreyt: aye, push down on the code and up sprouts some data.

[06:41] <audreyt> preferably Module::Install would also use the same data

[06:41] <audreyt> to suggest alternate installation for people without C compiler

[06:42] <audreyt> basically a Module::CoreList-esque data module that contains the currently known mappings

[06:42] <audreyt> maintained in a potentially decentralized fashion

[06:42] <audreyt> except the mappings are themselves .pm files

[06:42] <audreyt> this is like, the Apache2.pm idea done right :)

[06:43] <audreyt> (because pureperl::* are strictly emulation layers that depends on other modules, and not functional code themselves)

[06:44] <audreyt> anyway, I probably wouldn't have cycles to code up a prototype soon, so takers welcome :)

[06:45] * PerlJam sleep &

[06:47] *** KingDiamond joined
[07:15] *** iblechbot joined
[07:24] *** marmic joined
[07:31] *** KingDiamond joined
[07:33] *** Aankhen`` joined
[07:40] *** Soga joined
[07:42] *** p5evalbot joined
[07:43] *** _fordinal joined
[07:54] <svnbot6> r10008 | yiyihu++ | change `our Num multi Num::sign (Num $x)` to `our int multi Num::sign (Num $x)`.

[08:12] *** pmurias joined
[08:12] <pmurias> hi

[08:12] <xinming> hi

[08:14] *** elmex joined
[08:14] <pmurias> OT: can one move already opened programs to screen

[08:15] <pmurias> s/opend/runing/

[08:15] <xinming> pmichaud: I don't think so.

[08:15] <pmurias> s/pmurias/pmichaud/

[08:15] <xinming> pmurias: I don't think so. :-)

[08:16] *** pmurias joined
[08:16] <xinming> screen -S irssi -c irc.freenode.net :-)

[08:17] <xinming> screen -S irssi irssi -c irc.freenode.net :-/

[08:18] <pmurias> forgot to turn screen on :(

[08:19] *** pmurias joined
[08:21] <xinming> pmurias: what does OT mean?

[08:22] <miyagawa> Off Topic?

[08:23] <xinming> because pmurias every said... `pmurias OT: can one move already opened programs to screen`

[08:23] <xinming> miyagawa: maybe

[08:34] *** gringott joined
[08:35] *** f0rth joined
[08:49] *** iblechbot_ joined
[08:57] <svnbot6> r10009 | audreyt++ | * Beginning of librules, a C implementation of Perl 6 Rules

[08:57] <svnbot6> r10009 | audreyt++ |   (really just the operator precedence parser for now.)

[08:57] <svnbot6> r10009 | audreyt++ |   (Why am I doing this? Mostly I want to understand how the

[08:57] <svnbot6> r10009 | audreyt++ |    new OPTable.pir and Parse::YAPP works. :))

[08:58] <audreyt> (also I imagine a shared operator precedence parser among Hs/P5/PIR may not be a bad idea.)

[09:01] <miyagawa> hi audreyt

[09:01] <audreyt> miyagawa: hi

[09:02] <miyagawa> happy birthday

[09:02] <audreyt> thanks! :))

[09:02] <miyagawa> I am planning to go to Taiwan again

[09:02] <miyagawa> April 27th to May 1st

[09:03] <LeTo> audreyt: what are the p6 shift ops arithmetic vs. logic right?

[09:03] <audreyt> in ~1hr I'm going to one of the best - as in creative taiwanese cuisine - restaurant, and I have no idea what will be on table tonight :)

[09:03] <audreyt> miyagawa: oooh

[09:04] <audreyt> miyagawa: for some event or?

[09:04] <miyagawa> for just hacking, again

[09:04] <audreyt> LeTo: say what?

[09:04] <miyagawa> I'll be staying in gugod's

[09:05] <audreyt> LeTo: you mean +< &< ~<

[09:05] <audreyt> er +> &> ~>

[09:05] <audreyt> or somthing else?

[09:05] <LeTo> audreyt: is +> logic shr or arithmetic?

[09:05] <LeTo> i.e. does it shift the sign?

[09:05] <audreyt> ?eval 123 +< 2

[09:06] *** evalbot_10007 is now known as evalbot_10009

[09:06] <evalbot_10009> 492

[09:06] <audreyt> ?eval -123 +< 2

[09:06] <evalbot_10009> -492

[09:06] *** pjcj joined
[09:06] <audreyt> I think it preserves the sign.

[09:06] <audreyt> same as perl5 >>, no?

[09:06] <LeTo> ?eval -2 +> 1

[09:06] <evalbot_10009> -1

[09:06] <LeTo> arithmetic

[09:07] <audreyt> oh, _not_ same as perl5 >> in that regard

[09:07] <audreyt> but yes, + should indicate arithmetic semantics.

[09:07] <audreyt> (consistently)

[09:07] <LeTo> ?eval -2 ?> 1

[09:08] <evalbot_10009> Error:  unexpected "?" expecting "#", operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[09:08] <audreyt> there is no ?> in the spec iirc

[09:08] <LeTo> nope

[09:09] <audreyt> miyagawa: cool, I'll visit you probably

[09:09] <miyagawa> nice

[09:09] <LeTo> ?eval my $a=2; $a +<=3; say $a;

[09:10] <evalbot_10009> Error: Can't use readline() or getc() in safemode.

[09:10] <LeTo> ?eval my $a=2; $a +<= 3; say $a;

[09:10] <evalbot_10009> Error: Can't use readline() or getc() in safemode.

[09:10] <LeTo> a bug?

[09:10] <xinming> no

[09:10] <xinming> I think It's not a bug. :-)

[09:11] <xinming> hmm, I don't think it's a bug

[09:11] <audreyt> it is a bug.

[09:11] <audreyt> and fixed in r10010.

[09:11] <LeTo> audreyt++

[09:12] <svnbot6> r10010 | audreyt++ | * missing assignment ops, reported by Leo:

[09:12] <svnbot6> r10010 | audreyt++ |     +<= +>= ~<= ~>=

[09:13] <LeTo> ?eval my $a=2; $a +<=3; say $a;

[09:13] <evalbot_10009> Error: Can't use readline() or getc() in safemode.

[09:13] <LeTo> p6> my $a=2; $a +<=3; say $a;

[09:13] <LeTo> 16

[09:14] <LeTo> *g*

[09:14] <audreyt> well, evalbot is in sleep :)

[09:15] <svnbot6> r10011 | audreyt++ | * also fix the same assignment ops in the lexer

[09:16] <LeTo> audreyt: are these stringwise shifts ~<= ~>= ... really sane?

[09:17] <audreyt> LeTo: well if you think they operate on 21-bit words...

[09:17] <audreyt> well, maybe they are insane ;)

[09:17] <audreyt> but ~| is useful.

[09:18] <LeTo> yep, at least if the result string is marked being binary ;)

[09:20] <audreyt> I'm not sure

[09:22] <audreyt> I mean, "\x[E0000]" >>~|<< <M o o s e>

[09:22] <audreyt> can conceivably give you those Unicode Tagging Characters

[09:22] <audreyt> but they are insane themselves...

[09:27] <LeTo> ?eval my $x = 'A'; $x ~|=3; say $x

[09:27] *** evalbot_10009 is now known as evalbot_10011

[09:27] <evalbot_10011> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[09:29] <audreyt> weird, it worksforme.

[09:29] <audreyt> ?eval $_ = 'A'; $_ ~|= 3; $_

[09:29] <evalbot_10011> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[09:30] * audreyt wonders what's wrong with evalbot

[09:30] <audreyt> oh well... I need to run for dinner now.

[09:33] *** kanru joined
[09:34] <gaal> audreyt: forgot to svk add src/rules/* ?

[09:37] <svnbot6> r10012 | pmurias++ | PG-P6 know can dump structures in p5,yaml and xml

[09:38] <bsb> miyagawa: I leave taiwan the day before you arrive

[09:38] <svnbot6> r10013 | audreyt++ | * add src/rules/* for real.

[09:38] <miyagawa> bsb: ah :/

[09:38] <miyagawa> I'll stay in gugod's place, in Chupei

[09:38] <miyagawa> not Taipei

[09:40] <bsb> I have zero Taiwan clues so far, will read a guide when I get to HK

[09:42] <audreyt> gaal: committed

[09:42] <audreyt> feel free to pick up :)

[09:43] * audreyt waves & bbl

[09:47] *** elmex joined
[09:53] <Soga> quit

[10:10] <svnbot6> r10014 | gaal++ |  r10071@sike:  roo | 2006-04-18 13:06:25 +0300

[10:10] <svnbot6> r10014 | gaal++ |  * optable.c - logic fix and minor golfage

[10:15] <gringott> ?eval $_ = 'A'; $_ ~|= 3; $_

[10:16] *** evalbot_10011 is now known as evalbot_10013

[10:16] <evalbot_10013> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[10:38] *** izut_ is now known as izut

[11:21] *** drrho joined
[11:23] *** nnunley joined
[11:42] *** frederico joined
[12:07] *** iblechbot joined
[12:20] *** frederico joined
[12:25] *** Limbic_Region joined
[12:37] *** kolibrie joined
[12:44] <svnbot6> r10015 | ruz++ | * make base dir for target before copy

[12:50] *** Blicero_ left
[13:00] * Limbic_Region gives up trying to figure out what "NMAKE : fatal error U1077: 'cd' : return code '0x1'" means and decides that getting Pugs running on his work machine is a lost cause

[13:01] * theorbtwo snaps his fingers.

[13:01] <theorbtwo> You're trying to run lines like cd foo; do something; cd .. ?

[13:01] <theorbtwo> Does your nmake || shell understand the semicolon?

[13:01] * theorbtwo hasn't used nmake in a while, and doesn't remember.

[13:02] *** pmurias joined
[13:02] <Limbic_Region> theorbtwo - this just mysteriously stopped working

[13:02] <Limbic_Region> but only on my work machine - works fine at home

[13:02] <theorbtwo> :(

[13:03] <Limbic_Region> about the only thing that could have conceivably changed is the addition of MinGW - but I hand crafted %PATH to ensure no funny business

[13:04] <Limbic_Region> I wiped out the repo and did a fresh check out - yadda yadda yadda

[13:04] <Limbic_Region> bah - it will give me a chance to read The Prgamattic Programmer

[13:07] <pmurias> looked at FAQ/FUD.pod

[13:08] <pmurias> The "Programming Perl 6 will be multivolum" question IMHO seem quite realistic

[13:09] <pmurias> s/question/fear/

[13:09] *** Qiang joined
[13:14] <pmurias> what will be the answer to "

[13:15] <pmurias> Every module requires 42 "use" statements to improve syntax!"

[13:15] <pmurias> bundles?

[13:15] <pmurias> the syntax is good already?

[13:16] <gaal> pmurias: I don't understand that fear very well, but facades will be possible because reexport is possible.

[13:16] <gaal> bundles are a packaging issue

[13:18] <theorbtwo> The fear goes like this, I think...  Right now, every non-trivial bit of code ends up beginning with "use warnings;\nuse strict;", at least if you're of the perlmonks school.  (Which I certianly am.)

[13:19] <theorbtwo> In perl6, it'll begin "use terse_math; use reasonable_call_syntax; use this; use that; use the_other;", because there's so many silly decisions being made that you'll have to fix.

[13:20] <pmurias> there a need for such thing in perl5 too

[13:20] <theorbtwo> There seem to be two reasonable responses: "Larry's really bad decisions tend to get fixed later in the design process, we hope", and "If you keep using the same modules over and over, you can make a module that uses all of those modules, and still end up with the things getting exported to teh right place".

[13:20] <theorbtwo> s/teh/the/

[13:23] <pmurias> A third one could be that "You should be happy to be able to fix bad desision, in languages with static grammar you would be screwed"

[13:24] <pmurias> maybe in more diplomatic words

[13:25] *** lichtkind joined
[13:25] <theorbtwo> The only sane response I can think of to "Programming Perl will be several volumes" is "yeah, but you'll only need to read the first one", which is awful weak.

[13:25] *** sahadev joined
[13:27] <lichtkind> ?eval  2:3;

[13:27] *** evalbot_10013 is now known as evalbot_10015

[13:27] <evalbot_10015> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[13:27] *** mako132 joined
[13:28] <pmurias> "with the advances in book bindings technology we will be able to have twice as many pages in a single book" :)

[13:28] <lichtkind> yes :)

[13:28] <lichtkind> ?eval  :2(3);

[13:28] <evalbot_10015> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[13:30] <lichtkind> ?eval  (3):2;

[13:30] <gaal> ?eval "I am well"

[13:30] <evalbot_10015> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[13:30] <evalbot_10015> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[13:30] <gaal> guess evalbot isn't very well.

[13:30] <lichtkind> ok but this fancy bace notation was right?

[13:31] <lichtkind> :2(3) is boolean

[13:31] <gaal> theorbtwo: is there a particular reason to believe that there are more things wrong in the p6 defaults than in p5?

[13:31] <gaal> lichtkind: the syntax is right but of course 3 isn't a valid digit in binary

[13:32] <pmurias> i think p6 has generaly saner defaults

[13:32] <theorbtwo> gaal: I'm not sure yet.

[13:32] <lichtkind> gaal i mean to convert a dec 3 to bin , i still wander how to pronounce things at the base like 43

[13:32] *** Arathorn joined
[13:33] <gaal> lichtkind: :n() is from base n

[13:33] <theorbtwo> lichtkind: That's not how you do that.

[13:33] <gaal> I forget how to to to base n

[13:33] <theorbtwo> What you said is "This is the number 3, in base 2."  That's like saying "what colour is scent".

[13:33] <gaal> probably with .as

[13:34] <pmurias>  theorbtwo: have many wrong/controversive defaults does p6 has now?

[13:34] <gaal> s/to to to/to do to/

[13:34] <gaal> of course if you have a lotta knobs, people will want to set them at different places

[13:34] <theorbtwo> There's a fair number of them, I think, but they mostly seem to have their reasons, and I'm not sure how many of them will really be bad, as opposed to just be feared...

[13:35] <theorbtwo> ...and many of those aren't really syntax.

[13:35] <theorbtwo> print (1, 2) for example.

[13:35] <theorbtwo> And 1<2.

[13:35] <gaal> as opposed to not having knobs, and people wanting to set them not being able to :)

[13:35] <lichtkind> ok gaal but how to express base over 16 :42(dDg5a) ?

[13:36] <theorbtwo> lichtkind: Base 17 is 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g.

[13:36] <pmurias> any way use theorbtwo:Style or use pbp:Style should be enough

[13:36] <gaal> lichtkind: not sure it's specced yet, but presumably up to 64 it's straightforward

[13:37] <theorbtwo> Exactly.  That's the second answer to the fear that I just gave.

[13:37] <gaal> after that, maybe accept a list of numbers strictly lower than the base?

[13:38] <gaal> i dunno; what does the spec say?

[13:38] <pmurias> should i check in the answers to the fear?

[13:38] <gaal> pmurias: why not

[13:38] <theorbtwo> pmurias: Good with me.

[13:38] <lichtkind> theorbtwo thanks and jow to convert dec to a base and how will be performed real number?

[13:39] <gaal> re fears, it's not like any of these have an authoratative answer, anyway

[13:39] <theorbtwo> gaal: I think the syntax is that you seperate each "digit" with colons, and write them in base 10.

[13:39] <gaal> makes sense.

[13:39] <theorbtwo> You're free to use that with any (supported) base, of course.

[13:39] <theorbtwo> That's what we specced back when perl6-documentation was active, anyway.

[13:39] <pmurias> i'll add a new fear of mine "Perl 6 will split into incompatible dialects"

[13:40] <gaal> :16( :16(a) :24(a) )    :-)

[13:40] <gaal> :16( :16(a); :24(a) )    that is

[13:40] <theorbtwo> gaal: I hope that isn't legal...

[13:40] <gaal> which is surprising perhaps but has a clear meaning

[13:41] <gaal> well actually no

[13:41] <gaal> :25( :16(a); :24(a) ) does.

[13:41] <lichtkind> pmurias but something like perl6 would have prevented the split into php

[13:42] <theorbtwo> No, it wouldn't have.

[13:42] <lichtkind> why?

[13:42] <theorbtwo> You could easily make perl6 into PHP, but you'd have to work at it, and you could still get perl6 out of it then.

[13:42] <theorbtwo> I think the php writers wanted something simpiler then perl, which perl6 certianly isn't.

[13:43] <lichtkind> but perl6 has very simple subsets

[13:43] <lichtkind> you cant everything use as referenz like in php which where you have only one sigil

[13:44] <theorbtwo> lichtkind: That sentence didn't make much sense, try again.

[13:46] <lichtkind> i said that perl6 is very simpel like php in many areas for instance in unifying sigils you can in perl6 even use arrays and hashes wit $ as references

[13:48] <svnbot6> r10016 | pmurias++ | + 42 modules answered

[13:48] <svnbot6> r10016 | pmurias++ | + incompatible dialect

[13:49] <theorbtwo> "Perl6 is very simple, like php, in many areas, for instance in unifying sigils.  In perl6, you can even use arrays and hashes using only $s."

[13:49] <theorbtwo> lichtkind: If you just put in a little effort to use capitals and puncuation, you'd be a lot more understandable.

[13:50] <pmurias> custom grammars could be used to enfore very stict coding rigour

[13:52] <lichtkind> so i have to do :10(:2(0101));?

[13:53] <theorbtwo> lichtkind: No.

[13:53] <theorbtwo> :base(number) is a way of writing literals.

[13:53] <theorbtwo> How would you do what you want to do in perl 5?

[13:55] *** vel joined
[13:58] <lichtkind> my mistake i meant to convert dec 3 in 011 like printf "%b", 03;

[13:58] *** dakkar joined
[14:04] <theorbtwo> say 3.as("%b")

[14:05] *** hexmode joined
[14:07] <xinming> ?eval say :2(3)

[14:07] *** evalbot_10015 is now known as evalbot_10016

[14:07] <evalbot_10016> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[14:12] *** fglock joined
[14:12] *** cm_ joined
[14:13] <lichtkind> thanks orb

[14:13] *** justatheory joined
[14:18] <svnbot6> r10017 | fglock++ | PG-P6 - code cleanup; updated TODO; added test.pl

[14:18] <pmurias> hi fglock

[14:22] <lichtkind> theorbtwo your nick has nothing todo with music?

[14:24] <theorbtwo> Correct.

[14:24] <theorbtwo> I named myself theorb before I'd ever heard of the band.

[14:26] * Limbic_Region named himself long before there was a bad movie by the same title

[14:26] <fglock> audreyt: re implementing the precedence parser in C - you should maybe reuse bison ?

[14:26] <audreyt> bison allows runtime extension of tokens?

[14:27] <audreyt> or removal of

[14:28] <gaal> hey audreyt, are there any tests for the opparser?

[14:29] <fglock> I haven't looked - but it is already there...

[14:29] <dakkar> bison generates LALR(1) parsers in the form of C source code... no run-time modifications are (sensibly) possible

[14:29] <gaal> or any way at all to tell hackage is in the right direction?

[14:30] <audreyt> dakkar: that's what I think.

[14:31] <fglock> audreyt: what is the top-level recdescent-parser needed for? so far PG-P6 didn't need it

[14:32] <audreyt> fglock: toplevel recdescent? no, I just want to do the OPTable part

[14:32] <audreyt> fglock: as a learning project purely, but pmichaud also mentioned that he'd like to port that to C to avoid parrot's overhead

[14:33] * gaal wonders if modern c compilers optimize strlen("string literal")

[14:33] <audreyt> gaal: they should, prolly

[14:33] <rgs> bison isn't very good at operator precedence parsers

[14:33] <audreyt> gaal: re tests, I don't really know

[14:33] <fglock> I mean, as in "perl6 will have a three-level parser" - why does it need 3 levels?

[14:36] <nothingmuch> audreyt: Do you seek to enter the United States to engage in export control violations, subversive or terrorist activities, or any other unlawful purpose? Are you a member or representative of a terrorist organization as currently designated by the U.S. Secretary of State? Have you ever participated in persecutions directed by the Nazi government of Germany; or have you ever participated in genocide?

[14:36] <nothingmuch> ... "I am Codename Tea, member of the secret terrorist organization IGNY!"

[14:37] <nothingmuch> "I will take over your counly with my mad programming skillz!"

[14:37] <nothingmuch> "Evolve or die, capitalist pigs!"

[14:37] <gaal> subversive activities? heavens no, audreyt uses svk

[14:38] <pmichaud> actually, the part I'm most interested in seeing ported to C is the Match object PMCs

[14:38] <pmichaud> but having the op-precedence parser in C (or the top-down one, for that matter) will be excellent also

[14:39] <audreyt> pmichaud: I've started some structs in optable.h

[14:39] <audreyt> pugs/src/rules/optable*

[14:39] <pmichaud> yes, I saw the checkin notices and briefly scanned the diffs

[14:40] <audreyt> does the structs make sense?

[14:40] <pmichaud> very much so

[14:40] <audreyt> cool. the idea is that the "extras" thing will hold the arbitrary traits each token want to carry

[14:41] <audreyt> such as the raw "pir" generation code etc

[14:41] <pmichaud> good idea.  I just added that myself this past week (i.e., exposing the token's hash to the caller to let them hang extra properties on them)

[14:42] <clkao> audreyt: should i rename data::bind to data::capture?

[14:42] <audreyt> clkao: Perl6::Capture XD

[14:42] <audreyt> clkao: Pugs::Runtime::Capture probably?

[14:42] <clkao> i thought perl6:: is for syntax stuff

[14:42] <audreyt> yup

[14:43] <clkao> pugs::runtime? but it's really usable for normal perl5 as well ;)

[14:43] <pmichaud> audreyt: also, if it helps, I took a lot of clues from http://www.cs.rpi.edu/~gregod/Sugar/doc/design.html

[14:43] <clkao> i mean the underlying binding logic only here

[14:43] <audreyt> so Data::Bind is fine

[14:43] <audreyt> with Capture and Signature as concrete objs

[14:43] <clkao> *nod*

[14:45] <audreyt> pmichaud: woot, thanks

[14:45] <fglock> the only reference I found is "Perl 6 "sandwiches" an operator-precedence parser in between two Recursive descent parsers in order to achieve a balance of speed and dynamism." http://en.wikipedia.org/wiki/Operator-precedence_parser

[14:45] <audreyt> pmichaud: btw, you have some kind of tests or optable?

[14:46] <audreyt> fglock: I have no idea what that means... I've always thought that there are just two levels

[14:46] <audreyt> what's the bottom level recdescent?

[14:46] <fglock> I use it for the tokenizer/lexer

[14:47] <pmichaud> audreyt: at the moment I don't have any real tests for the optable, other than the fact that PGE can't compile/run without it.  :-)

[14:48] <pmichaud> audreyt:  terms and other constructs below expressions can be recdescent (at least they are in PGE's grammar)

[14:48] <pmichaud> so we have recdescent for statements and block-level constructs, bottom-up for expressions, and then recdescent for terms

[14:49] <pmichaud> (plus any operators that need something more sophisticated than what we can do with simple tokens)

[14:49] <fglock> I'm using bottom-up for statements and blocks

[14:52] <fglock> I was thinking about a way to translate some class of rules to bottom-up - this would allow to add a <precedence $var> to rules, and make left recursion easier

[14:53] <pmichaud> yeah, there have been some speculative discussions in the past among the design team about having a way to translate rules into bottom-up forms

[14:54] <fglock> as used in http://svn.openfoundry.org/pugs/misc/pX/Common/Pugs-Grammar-Perl6/lib/Pugs/Grammar/Operator.pm - but with rule-ish syntax

[14:55] *** lisppaste3 joined
[15:04] <fglock> non-backtracking rules are a good target

[15:05] <audreyt> fglock: how is "header" used?

[15:05] <audreyt> fglock: oh btw, pmichaud and I discussed a possible way to do "statements" in a uniform fashion

[15:05] <fglock> it is compiled together with the precedence table

[15:06] <audreyt> fglock: consider

[15:06] <audreyt> if -e { 3 }

[15:06] <audreyt> versus

[15:06] <audreyt> say 1; 2; 3;

[15:06] <clkao>   'Testing: `sub foo($n, *%h, *@a){ }; foo 1, n => 20, y => 300, 4000`';

[15:06] <clkao> how should this die?

[15:06] <audreyt> fglock: it turns out if the "if" can tell the expression parser that it should terminate parsing upon seeing " {"

[15:06] <clkao> the order of positional and named matters?

[15:07] <audreyt> fglock: and if the statements parser can tell the expression parser that it should terminate parsing upon seeing ";"

[15:07] <audreyt> fglock: then both can be done efficiently

[15:08] <fglock> audreyt: that's easy to add - just need some flags - do you have a link?

[15:08] <pmichaud> audreyt: yes, I'm working on that part today.  I'm thinking I'll either pass the expression parser the token to stop parsing on, or pass it a regex that tells it when to stop

[15:09] <audreyt> fglock: grep S04 for "old times"

[15:09] <fglock> ok

[15:09] <audreyt> pmichaud: I think the expr parser knows about the token already

[15:09] <audreyt> pmichaud: so it's safe to address it byname

[15:09] <pmichaud> audreyt: that's what I'm thinking also

[15:10] <pmichaud> so, we'd have    / if <expression: postcircumfix:{ }> <block> /    and   (statement level)   / <expression: infix;> /

[15:10] <pmichaud> oops, / <expression: infix:;> /

[15:10] <pmichaud> oh, wait

[15:10] <pmichaud> if <expression: circumfix:{ } > <block> /

[15:10] <audreyt> aye.

[15:11] * pmichaud has far too many "post" thingies floating around at the moment

[15:11] <audreyt> but in fact, it needs _both_ postcircum and circum.

[15:11] <audreyt> if 1 + { } # circum

[15:11] <audreyt> if 1 { } # postcircum

[15:12] <audreyt> (the 1+ should become a parse error)

[15:12] <pmichaud> okay, so it'll have to be a list of tokens to stop on

[15:12] <fglock> isn't bottom-up more efficient?

[15:12] <pmichaud> actually, no,

[15:12] <pmichaud> if 1 { } isn't postcircumfix, it's two terms

[15:12] <audreyt> right

[15:13] <audreyt> so you think term:{ fixes both?

[15:13] <pmichaud> so just circum

[15:13] <audreyt> circum, sorry

[15:13] <pmichaud> if 1 { } is already handled -- the expression terminates at the 1 already

[15:13] <audreyt> cool.

[15:14] <pmichaud> so yes, it's just   <op> { ... } that we have to deal with, and that's circumfix:{ } :-)

[15:15] <pmichaud> I can always extend later to have the opparse look for a rule to stop on as well as specific tokens

[15:15] <audreyt> fglock: yes, but bottom-up for infix:<;> has something like

[15:15] <audreyt> 1 if 4; 2 if 5;

[15:15] <pmichaud> fglock: bottom-up is more efficient as long as you don't have backtracking

[15:15] <audreyt> fglock: the "if" can only happen once per statement

[15:15] <audreyt> fglock: and it's rather hard to model that way using bottom-up alone

[15:15] <audreyt> (I tried, and failed, many months ago)

[15:16] <audreyt> so the end-parse-on idea is much better

[15:16] <fglock> I'll try - one sec...

[15:16] <pmichaud> afk -- bbiab

[15:17] <fglock> how about specifying it as infix:<if> at the syntax level

[15:17] <fglock> oh you mean it will not detect syntax errors

[15:17] <PerlJam> fglock: that makes me wonder what [if] does  :-)

[15:18] <audreyt> fglock: and it would allow

[15:18] <audreyt> my $a = (1 if 2);

[15:19] <audreyt> which should be fine if user has infix:<if>

[15:19] <audreyt> but this is statement_modifier:<if>

[15:19] <audreyt> and totally not the same thing.

[15:19] <PerlJam> yeah, things like that need do {...} to keep the humans straight.

[15:20] <audreyt> actually, "do" is another case where we need to switch parser mode ;)

[15:20] <lichtkind> theorbtwo orb is cool, orbital too, currently i like also very much the band of one "the orb" cofounder: KLF which made vary inspiring music

[15:20] <audreyt> (in Perl6, "do" doesn't need the bracket.)

[15:20] <audreyt> my $x = do 1 if 2;

[15:20] <PerlJam> oh, that's right, I forgot about that.

[15:23] <fglock> ok - I'm adding these to my tests

[15:24] <PerlJam> Is there an inverse of escher's water fall?  If so, it would make a good logo for perl6 where it's perpetually rising

[15:25] <fglock> it may actually work - if 'do' is looser than 'if' - retrying...

[15:26] <PerlJam> fglock: do and if are operators in your grammar?

[15:27] <fglock> PerlJam: I'm just experimenting with the idea

[15:27] <PerlJam> experimentation++

[15:30] <audreyt> mm perpetual motion

[15:31] *** autark joined
[15:32] <Juerd> Argh--for the very first time I'm hating that there's little good professional Linux support available

[15:33] <Juerd> I need to revive a broken amd64 system, and for that need a non-broken 64bit livecd, which practically doesn't exist.

[15:33] <Juerd> And I'm desperate enough to want to pay for a solution.

[15:34] <Juerd> Oh, and I'm remembered by this why I hated grub. Grub's way too complex, and requires too much from a system to even get installed. A broken grub sucks.

[15:34] <fglock> audreyt: it seems to work - "1 if 4; 2 if 5;my $x = do 1 if 2;" parsed ok

[15:34] <Juerd> I wouldn't have had this problem *at all* if it were lilo, which tries much less to be smart.

[15:35] <audreyt> fglock: excellent! (committed?)

[15:35] <fglock> I made 'if' and 'do' equal precedence, and tighter than ';'

[15:36] <audreyt> what about

[15:36] <audreyt> 1 if 2 if 3

[15:36] <audreyt> ?

[15:36] <fglock> committing - see test.pl

[15:36] <fglock> trying...

[15:36] <audreyt> and what about

[15:36] <audreyt> say(3 if 4)

[15:36] <audreyt> ?

[15:37] <audreyt> then need to be rejected

[15:37] <audreyt> (brb)

[15:37] <fglock> the say() is likely to work

[15:38] <fglock> both fail

[15:38] <svnbot6> r10018 | fglock++ | PG-P6 - experimental implementation of do/if using operators

[15:40] <xinming> fglock++

[15:41] <fglock> bbiab - lunch &

[15:43] <audreyt> fglock: but it allows

[15:43] <audreyt> (4 if 5) + (6 if 7)

[15:43] <audreyt> which is prolly wrong...

[15:44] <Limbic_Region> so how does it feel to be a quarter of a century old audreyt?

[15:46] *** aufrank joined
[15:46] <audreyt> Limbic_Region: I feel unixy

[15:46] * pmichaud has felt a quarter of a century old for about 10 years.  :-)

[15:46] <aufrank> hey all

[15:46] <pmichaud> but when I was a quarter of a century old, I didn't feel a quarter of a century old :-)

[15:48] * pmichaud lunch, errands &

[15:48] <Juerd> audreyt: Is it your birthday?

[15:48] <PerlJam> pmichaud: I doubt it very seriously that you've felt .25 century for the last 10 years.

[15:48] <pmichaud> pj: why's that?

[15:48] <theorbtwo> audreyt: Happy brithday, BTW.

[15:48] <PerlJam> pm: because I've seen you change.  there are times when you've clearly suffered from "old-man" syndrome  :)

[15:49] <pmichaud> pj: eh?  speak up a bit... I can't hear you!

[15:49] *** FurnaceBoy joined
[15:49] * pmichaud lunch, errands, for real this time &

[15:49] * Limbic_Region wonders how many people don't read her journal

[15:49] *** cdpruden joined
[15:50] <Limbic_Region> she made the 10K commit 3 hours in to her 25th bday

[15:50] * theorbtwo was around at the time.

[15:50] * Limbic_Region pulled a merlyn for his 25th bday

[15:50] * theorbtwo wonders if it's 25 lunar years or 25 solar years.

[15:52] <PerlJam> Limbic_Region: My imagination is running wild with ideas for what you mean by "pulled a merlyn", so what do you mean?  :)

[15:52] <Juerd> audreyt: Happy birthday :)

[15:52] <Juerd> audreyt: And happy 10kth

[15:53] <audreyt> thanks :)

[15:53] <audreyt> theorbtwo: 25 solar years.

[15:53] <xinming> audreyt: do you drink? hmm, I mean beers.. :-)

[15:54] <audreyt> xinming: well, a bit... not really

[15:55] <Limbic_Region> PerlJam - having written that, I think it be best not to answer publicly where it is logged so I will /msg you

[15:55] <PerlJam> heh

[15:55] <audreyt> you can avoid logging by say

[15:55] <audreyt> or sometihng like that

[15:56] <xinming> audreyt: You really should drink much today. :-P

[15:57] <svnbot6> r10019 | clkao++ | Make it 17 times slower than normal unpack binding, rather than 25 times.

[15:57] <audreyt> xinming: I got excellent food instead, so no alchohol required really

[15:57] <xinming> hmm, I don't suggest that either... as I wish to see pugs "finished" as fast as It can be. :-)

[15:57] <PerlJam> audreyt: forget drinking, but you should take a vacation or something (at least for the day)

[15:57] <audreyt> PerlJam: oh but I did

[15:57] <clkao> she is always on vacation

[15:57] <clkao> and having fun ;)

[15:57] <PerlJam> clkao: yeah, I was thinking just that

[15:57] <xinming> audreyt: did you ever come to Kunming?

[15:58] <audreyt> had arguably the best meal I had in .tw ever

[15:58] <clkao> what's the point about kunming during spring?  it only has a point when it's not spring elsewhere ;)

[15:58] <audreyt> xinming: not sure... if YAPC::China happen sometime this year then maybe

[15:58] <audreyt> mm, kunming the cospring

[15:58] <xinming> clkao: It's all spring...

[15:58] <clkao> that's what i meant.

[15:58] <Juerd> It's naive to assume there's only one logbot here.

[15:59] <audreyt> I stand corrected.

[15:59] <Juerd> And there are probably many lurker clients that log

[15:59] <audreyt> *nod*

[15:59] <aufrank> audreyt: my girlfriend still goes on about the food in .tw from when she studied there

[15:59] <xinming> which means, the temperature in Kunming almost everyday is about 10 - 23 centigrade...

[15:59] <kolibrie> audreyt: happy birthday (just in time)

[16:00] * Limbic_Region wonders if audreyt meant to say "I sit corrected" or if she really isn't standing - in the shower, on a hike in the mountains, fast asleep - she hacks everywhere

[16:00] <audreyt> indeed, now it's past... :)

[16:00] <PerlJam> audreyt: What's your localtime?

[16:00] <xinming> audreyt: Not passed here. :-P

[16:00] <audreyt> PerlJam: 00:01

[16:00] <kolibrie> audreyt: you are now at midnight 19 april?

[16:00] <audreyt> yup

[16:00] <audreyt> (shower, bbiab)

[16:00] * xinming wonders where is she now....

[16:01] <fglock> back

[16:01] <audreyt> Limbic_Region: I was actually walking around

[16:01] <xinming> s/where is/where she is/

[16:01] <audreyt> xinming: taipei

[16:01] <PerlJam> Limbic_Region: she could be like rumsfeld and stand as her desk/whatever to hack.

[16:02] * PerlJam imagines audreyt walking around with a monicle and one of those one-hand chording keyboards.

[16:04] <Juerd> That'd be scary

[16:05] * xinming images there is a water-proof computer in bathroom....  :-)

[16:05] <Juerd> You don't need your computer to be water proof

[16:05] <Juerd> A laptop and a water proof keyboard suffice.

[16:05] <svnbot6> r10020 | aufrank++ | rounding methods as requested in TASKS

[16:05] <svnbot6> r10020 | aufrank++ | no tests yet

[16:06] <Juerd> Just put something over the laptop when you get out of the bath

[16:06] <xinming> aufrank++

[16:06] <aufrank> I've had those sitting around for months

[16:06] <aufrank> and decided I'd better just check them in since I wasn't working on them :)

[16:06] <aufrank> thanks xinming

[16:07] <xinming> audreyt: did round suite passed your test?

[16:07] <fglock> audreyt: re (6 if 7) - how about "postcircumfix:<if ;>"  :)

[16:08] <xinming> Juerd: I mean using computer while we are sitting in bath

[16:08] <Juerd> xinming: The computer itself doesn't need to be in the water, I think?

[16:08] <PerlJam> fglock: heh.

[16:08] <Juerd> xinming: You only need a screen, which can stand next to the bath, and a keyboard, which are available in water proof form for around $15

[16:10] * xinming wonders why the round suite of mine are all erased... :-/

[16:11] <xinming> Juerd: how about the screen leak the electricity....

[16:11] <xinming> aufrank: I've implemented... :-/

[16:11] <aufrank> my mistake xinming

[16:11] <aufrank> very sorry

[16:12] <Juerd> xinming: The screen doesn't need to be in the water either.

[16:12] <Juerd> xinming: Most human heads can rotate by means of a neck.

[16:13] <xinming> Juerd: well, but the problem is in bathroom... it's wet... how about it went 'short circut' ?

[16:13] <xinming> aufrank: hmm, I think you can rename mine... :-)

[16:13] <xinming> first revert, and revert mine...

[16:13] <xinming> oops.

[16:13] <xinming> rename...

[16:13] <kolibrie> fglock: when I try to run the MyGrammar example in Pugs/Compiler/Rule.pm, I get:

[16:13] <kolibrie> perl MyGrammar.pm Can't locate object method "any" via package "MyGrammar" at (eval 5) line 9.

[16:14] <xinming> first revert mine, and rename it...

[16:14] <kolibrie> fglock: is there a 'use' I should add

[16:14] <xinming> aufrank: and let others who needs this to use that...

[16:17] <aufrank> xinming, check /msg

[16:17] <xinming> aufrank: yes, I've seen your mess...

[16:17] <fglock> kolibrie: did you try - use base 'Pugs::Grammar::Base'

[16:17] <xinming> hmm, I don't like to type /msg in each line... :-)

[16:18] <Juerd> xinming: Has never happened to my laptop.

[16:18] <Juerd> xinming: But it could happen, and a permanent installation should probably be designed to not shock people.

[16:19] <Juerd> xinming: My point was that to use a computer while bathing, you don't need much

[16:19] <xinming> hmm, In my opinion, and water-proff pda is enough... :-)

[16:21] <svnbot6> r10021 | fglock++ | PCR - fixed POD example

[16:21] <xinming> aufrank: It's ok, I've reverted mine, and renamed mine with another name... :-)

[16:22] <aufrank> ok, sorry about that

[16:22] <svnbot6> r10022 | yiyihu++ | Because aufrandk also implemented rounding suite... And It overrite mine...

[16:22] <svnbot6> r10022 | yiyihu++ | So I renamed mine, and commit... :-)

[16:22] * aufrank had better get more comfortable with svk :[

[16:23] * xinming uses svn... because xinming thinks that svn is easier...

[16:23] * aufrank goes to look at xinming's version

[16:24] <kolibrie> fglock: hmm, no 'base' in my use Pugs::Grammar::Base line

[16:24] <PerlJam> svk is more powerful

[16:24] <fglock> kolibrie: I fixed the docs

[16:24] * xinming will switch to svk after PerlJam's words

[16:24] <kolibrie> fglock: thank you

[16:27] <xinming> In fact, I believe that svk is more powerful than svn, as It can work offline... But there my internet connection is always on here. And my laptop almost online everyday... So this reason made me not to switch to svk. :-) maybe a excuse...

[16:27] <FurnaceBoy> sure, you only need svk if you need the extra layer

[16:27] <audreyt> no, that's entirely fine :)

[16:27] <audreyt> if you have fast disk and always-on net

[16:28] <audreyt> svn and svk is quite indistinguishable

[16:28] <PerlJam> audreyt: sometimes that's a problem :)

[16:28] <PerlJam> svn sync # oops

[16:28] <xinming> In China, an Adsl connection will cost around 12 ~ 18 US dollars...

[16:29] <xinming> audreyt: In fact, I think that I should learn svk too. :-)

[16:30] <obra> audreyt: that's not true. with svn, merging still sucks

[16:30] <xinming> the speed is about 64K byte upload, and about 200K download...

[16:30] <PerlJam> indeed. merge tracking is a *really* good reason to use svk

[16:30] <xinming> obra: But I believe svk will be the future. :-)

[16:31] <PerlJam> merge tracking + offline work + mirroring are all *really* good reasons to use svk.  More so if you combine them :)

[16:31] <obra> xinming: so do I

[16:31] <xinming> obra: oops... I misunderstand your post... :-/

[16:31] <Juerd> audreyt: Shouldn't quickref be removed entirely, to avoid double maintenance?

[16:31] * PerlJam want svk features folded into svn.

[16:31] <xinming> obra: I ever thought you said that svk sucks...

[16:31] <Juerd> (and worse: desyncs)

[16:31] <obra> xinming: no worries. I was reminding audrey of one of svk's killer features.

[16:32] <audreyt> Juerd: maybe... leave a README there that redirects to Perl6::Overview?

[16:32] <audreyt> Juerd: see the README in docs/AES/

[16:32] <audreyt> Juerd: also I didn't import the Namespace one

[16:32] <audreyt> quite tricky to update

[16:33] <clkao> i should move to slovakia

[16:33] <Juerd> audreyt: People don't read readmes :)

[16:33] <clkao> svk is the future!

[16:33] <FurnaceBoy> me too

[16:33] <Juerd> audreyt: Maybe delete only the documents that were migrated?

[16:33] * obra grins at cl

[16:34] <audreyt> Juerd: sure... that's all 'cept Namespace I believe

[16:34] <audreyt> Juerd: would you do that?

[16:35] <Juerd> audreyt: Sure, but later.

[16:35] <pmurias> clkao: why do you wish to move to slovakia?

[16:35] <clkao> because their country code is svk which is the future!

[16:36] <pmurias> i see

[16:36] <xinming> audreyt: IMO, svk lacks tutorial... I ever tried to switch to svk, but failed... Your 30 seconds(maybe) tutorial doesn't give much info about svk... :-)

[16:36] <svnbot6> r10023 | audreyt++ | * quickref - rm the ones that were migrated to Perl6::Overview.

[16:37] <audreyt> Juerd: s/later/now then :)

[16:38] <svnbot6> r10024 | audreyt++ | * add a redirection README.

[16:38] <PerlJam> xinming: svk is just like svn except you need to learn about sync, mirror, push, pull, and probably something else I'm forgetting.

[16:39] <FurnaceBoy> clkao, I thought it was for the girls :)

[16:39] *** SamB joined
[16:39] <PerlJam> btw, speaking of svk, are there any rpms for FC5?

[16:39] <xinming> PerlJam: But the problem is, why we switch svk is all about it's offline working, and svk doesn't gives much... hmm, maybe It's all because of I didn't try much... :-)

[16:39] <FurnaceBoy> xinming, see http://www.bieberlabs.com/wordpress/svk-tutorials/

[16:40] <xinming> FurnaceBoy: thanks

[16:40] <FurnaceBoy> yw

[16:41] <audreyt> xinming: if you don't do "svn merge" at all, svk is not very useful (mostly just convenience things like "svk desc")  -- but if you do any merges, svk is also very nice, as obra said

[16:41] <clkao> you can use svk for connected environment... no .svn, faster checkout operations

[16:43] <PerlJam> audreyt: who *doesn't* do any merging?

[16:43] <svnbot6> r10025 | fglock++ | PG-P6 - the AST nodes are more regular

[16:44] <audreyt> PerlJam: people who only work with a single dir and never conflicts?

[16:44] <FurnaceBoy> well, one-person teams do less merging :)

[16:44] <audreyt> unless you have multiple workspaces

[16:44] <theorbtwo> I just use svn ci.

[16:44] <audreyt> (or you are schizophrenic)

[16:44] <theorbtwo> Sometimes I conflict, in which case it tells me, I co, resolve any conflicts, and ci again.

[16:44] <PerlJam> heck, even when I was the only one using svn, I'd make branches that needed merging back into mainline development

[16:45] <audreyt> I guess that counts toward multiple workspaces

[16:45] <FurnaceBoy> sure PerlJam, it all depends on the project... I rarely branch mine

[16:46] <FurnaceBoy> in a team, it would be hard to avoid from time to time

[16:47] <FurnaceBoy> usually when I branch I regret it later for the extra bureaucracy and mental housekeeping :-)

[16:47] <obra> see, svk makes that suck less

[16:50] <PerlJam> FurnaceBoy: if you'd use svk, that wouldn't be a problem :)

[16:53] <FurnaceBoy> I guess so PerlJam, but even so, branching is rarely required

[16:53] <FurnaceBoy> (one man team)

[16:53] <FurnaceBoy> I'm about to set up svk for another group,

[16:53] <FurnaceBoy> so I'll end up learning a bit about it

[16:53] <FurnaceBoy> maybe I'll start using it myself :-))

[17:00] <PerlJam> The only problem I have with svk is that it's always a bit of a pain to install.

[17:04] <fglock> the parenthesis after 'sub name ...' make a 'Signature'?

[17:05] *** ruz joined
[17:06] <PerlJam> fglock: aye.

[17:08] <audreyt> fglock: "sub name (...)" it's just sugar for

[17:09] <audreyt> BEGIN { our &name := sub is signature (...) {...} }

[17:09] <audreyt> er

[17:09] <audreyt> sub is signature(:(...))

[17:09] <audreyt> where :(...) is a Signature constructor special form

[17:09] <audreyt> and "sub" is a Sub constructor special form

[17:10] <LeTo> $ /usr/bin/perl util/gen_prelude.pl -v -i src/perl6/Prelude.pm -p ./pugs --output blib6/lib/Prelude.pm.yml

[17:10] <LeTo> Generating precompiled Prelude... pugs: user error (***  unexpected ":" expecting word character, "#" or "=>" at <prelude> line 32, column 13)

[17:10] <LeTo> I'm getting this during 'make'

[17:11] <fglock> and 'Capture' is the bound arg list, right?

[17:11] <audreyt> fglock: right

[17:11] <audreyt> LeTo: looking

[17:13] <fglock> docs/notes/laziness.txt may need some updating

[17:15] <PerlJam> :() <- \() is weird

[17:16] <PerlJam> It's one of those things where I think I'd want more correspondence between a Signature and a Capture.

[17:16] <PerlJam> (syntax -wise)

[17:18] <pmurias> fglock: we could use a DSL instead of a series of calls to add_rule at Infix.pm

[17:20] <fglock> pmurias: it will be implemented with 'proto name is tighter name;' when it gets translated to p6

[17:21] <Juerd> :() is someone with fat lips

[17:21] <fglock> actually, it is the other way out - add_rule is what 'proto' compiles to

[17:21] <svnbot6> r10026 | audreyt++ | * Preparing for a default-commit parser.

[17:21] <svnbot6> r10026 | audreyt++ |   (also fix the Lexer overeager commit reported by Leo.)

[17:21] <Juerd> I can't imagine what \() should be :|

[17:21] <audreyt> or just parse http://svn.perl.org/parrot/trunk/languages/perl6/lib/grammar_optok.pge :)

[17:21] <fglock> audreyt: sure

[17:22] <Juerd> audreyt: Do you have preliminary performance improvement figures for the s/try// hacks?

[17:22] <audreyt> Juerd: it parsefails very fast.

[17:22] <audreyt> ;)

[17:22] <audreyt> which is an improvement alright

[17:22] <audreyt> but those used to be parseok and should continue to be

[17:22] <audreyt> so all figures are purely empty at this point

[17:23] <Juerd> audreyt: :)

[17:23] <Juerd> audreyt: Okay; thanks

[17:23] *** geoffb joined
[17:24] <pmurias> fglock: how far is PG-P6 from parsing grammar_optok.pgr?

[17:24] <fglock> pmurias: I'll check - I've been targetting Test.pm so far

[17:28] <fglock> pmurias: it looks reasonably regular - I think it takes some 5 or so new keywords

[17:29] <pmichaud> fglock: the rules for parsing optok.pge are in compilers/pge/pgc.pir  (in the parrot svn)

[17:30] <pmichaud> fglock: line 258

[17:30] <svnbot6> r10027 | audreyt++ | * undo another lexer tweak - not the time yet

[17:30] <LeTo> audreyt: should r10026 have fixed my build bug?

[17:31] <audreyt> LeTo: r10027, yes

[17:31] <LeTo> up'ing ...

[17:31] <fglock> pmichaud: I'm trying to parse statements using bottom-up - I wonder if this is plain wrong, of just not standard

[17:32] <pmichaud> fglock: I really don't know the answer to that

[17:32] <fglock> otherwise I'll change back to rules

[17:32] <pmichaud> I think the grammar will be easier to manage if statements and above are top-down

[17:32] <fglock> what's above statements?

[17:32] <pmichaud> blocks, subs

[17:33] <pmichaud> (okay, subs are also expressions, but parsing a sub is probably easier top-down)

[17:33] <LeTo> audreyt: thanks, that worked

[17:34] *** DaGo joined
[17:35] <fglock> the statement grammar is about 40 lines so far - it may get to about twice that when it is complete

[17:42] *** vanjuggler left
[17:43] <fglock> but this is still just a test... and I could translate the rules to bottom-up just to see if it works

[17:45] * audreyt waves g'nite &

[17:47] <lichtkind> good night

[17:47] <lichtkind> ?eval  do{;}

[17:48] *** evalbot_10016 is now known as evalbot_10025

[17:48] <evalbot_10025> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[17:48] <xinming> ?eval do {;};

[17:48] <evalbot_10025> ***      unexpected "$"     expecting "#" or identifier     at -e line 2, column 8

[17:48] <lichtkind> still broken i think

[17:48] <xinming> a bug... :-)

[17:48] <audreyt> wait a while

[17:48] <audreyt> r10027 fixes that :)

[17:50] <lichtkind> but it was valid perl6?

[17:50] <xinming> lichtkind: IMO, It' valid

[17:50] <lichtkind> thanks (writing chapter5 : control flow)

[17:57] *** evalbot_10027 joined
[17:58] <audreyt> ?eval do {;};

[17:58] <evalbot_10027> undef

[17:58] *** larsen joined
[18:00] *** zgh joined
[18:03] <aufrank> lichtkind: writing what for what?

[18:04] <lichtkind> aufrank perl6 tutorial for our german perl community

[18:04] <aufrank> neat :)

[18:04] <lichtkind> aufrank  the plan is if there is nothing better there to translate it too back

[18:04] <aufrank> excellent

[18:05] <lichtkind> yes but still a plan im working on this a since 7,8 days maybe

[18:07] *** KingDiamond joined
[18:09] <lichtkind> aufrank wanne see ?

[18:09] <aufrank> my german's not so good :[

[18:10] <lichtkind> your name sounded german to me :)

[18:11] <aufrank> yeah, it's in my background but I don't speak any

[18:11] <svnbot6> r10028 | fglock++ | PG-P6 - parses Test.pm until line 282; half implemented Signature

[18:12] <aufrank> I'm austin frank in the real world, aufrank is just a shortening

[18:22] <fglock> PG-P6 is parsing about 40 lines/second

[18:23] <aufrank> fglock: what is the PG in PG-P6?

[18:23] <fglock> the Pugs::Grammar::Perl6 p5 module

[18:24] <aufrank> gotcha

[18:25] <PerlJam> fglock: and can it parse iteself?

[18:25] <pmurias> it can't parse p5

[18:25] <fglock> hey, that's just about 15 lines to go :)

[18:25] <fglock> PerlJam: it's written in p5 (so far)

[18:26] <fglock> the rest of the file is pod

[18:26] <PerlJam> fglock: can it generate pir ?

[18:27] <fglock> PerlJam - it is just the parser - but you can plug a pir emitter

[18:27] <fglock> it generates a syntax tree

[18:28] <PerlJam> so, it's conceivable that the TGE tools can work on it?

[18:28] <fglock> PerlJam: I hope so

[18:29] <pmurias> it can generate the syntax tree in yaml,p5 or xml

[18:30] <pmurias> so if you can import any of those into parrot TGE can do the dirty work

[18:30] <xinming> then... perl 6 will be self hosting. :-)

[18:31] <PerlJam> I don't think TGE yet groks any of those syntaxes.

[18:31] <TimToady> fglock: the problem with doing bottom-up everywhere is that you'll end up inventing a stack to do what top-down does naturally in terms of nested scopes that have different terminators.

[18:31] <pmurias> parrot had a yaml parser, but i think it's broken now

[18:31] <TimToady> or other scoped policies.

[18:32] <PerlJam> TimToady: everyone has their own path to enlightenment :)

[18:32] <TimToady> plus bottom-up almost never produces as good an error message.

[18:33] <pmurias> PerlJam: i have a module to embed parrot on my hd, if you invent a way to pass data to it you can use TGE

[18:33] <fglock> TimToady: the only problem I found so far is (1 if 1) - do you have other possible examples? re error messages - right

[18:33] <TimToady> so mostly we introduced bottom up to handle all the precedence levels efficiently, not because we though bottom up was an end of its own.

[18:33] <fglock> ok

[18:34] <TimToady> An term that has arbitrary bracketed terminators is going to be better top-down.

[18:34] <TimToady> *Any

[18:34] <TimToady> qq/ foo { bar } baz / for instance, has to terminate the inside on } but the outside on /

[18:35] <TimToady> That's the sort of place you *want* to use recursion.

[18:35] *** ra015599 joined
[18:36] <TimToady> plunging through 22+ levels of precedence is where you don't want to use recursion...

[18:36] <PerlJam> 22+?  are they multiplying?  Or are you just including the potential user-levels?

[18:37] <Juerd> We have 22+?

[18:37] <lichtkind> 22

[18:37] <fglock> 'qq' is actually a term in PG-P6 (it's a 'mini language')

[18:37] <TimToady> users yes

[18:37] <TimToady> A term is an entry to a top-down parser.

[18:37] <TimToady> Entry to any mini-language is a top-down parser.

[18:37] <fglock> qq is parsed by a rule

[18:38] <TimToady> Anything that's parsed by a subrule is top-down.

[18:38] * Juerd wishes that with all the activity here, and in things he understands (rather than Haskell ;)), he had more time to spend on Perl 6

[18:38] <TimToady> don't we all...

[18:38] <PerlJam> TimToady: What do you do for a day-job these days?

[18:38] <fglock> qq is parsed by a rule, and the result is term... ?

[18:38] <Juerd> I can barely keep up with what's going on; I'd need much more time to actually understand all of it and even more to help hacking :(

[18:38] <TimToady> I'm working with an outfit called Netlogic Microsystems.

[18:39] <PerlJam> TimToady: let me guess ... doing stuff that in no way relates to language design?

[18:39] <TimToady> A term is just something that looks single to the bottom-up parser.  It can be arbitrarily complicated inside.

[18:40] <TimToady> has to do with pattern matching.  They seem to think I know a little about regex... :)

[18:40] <TimToady> Can't say much more than that...

[18:40] <TimToady> If there is top-down at the top of the grammar, it's probably a rather thin layer.

[18:41] <fglock> yes - the idea is that complicated things won't bother the bottom-up parser - so far it seems to work

[18:41] <TimToady> Probably mostly just to give the grammar a named rule at the top so you could, say use .wrap on it.

[18:41] <fglock> I think we are in agreement

[18:41] <TimToady> but I think everything down to the expression level could easily be top down without affecting performance.

[18:42] <fglock> yes - the bottom-up parser is wrapped into a rule API

[18:43] * fglock should learn to make cool drawings

[18:43] <TimToady> so, for instance, statement_modifier:<if> could be handled top down rather than bottom up in order to enforce the no-nested modifiers rule.

[18:44] <TimToady> I made some cool drawings once...but I think everyone's tired of them by now...

[18:44] <fglock> :)

[18:45] <pmichaud> TimToady: maybe some new cool drawings for yapc or oscon?  ;-)

[18:46] <fglock> modifying the parser once it is working is rather easy anyway :)

[18:46] <PerlJam> pmichaud: Are you going to bring a rendition of perl6?  That would be the coolest drawing ever :)

[18:46] <pmichaud> PerlJam: I shall do my best :-)

[18:47] <pmichaud> personally, I think that grammar_parse.pge and grammar_optok.pge are quite nice looking :-)

[18:47] * theorbtwo wonders if a call-tree of grammar rules would be...

[18:47] <theorbtwo> ...(a) hard

[18:47] <theorbtwo> ...(b) pretty

[18:48] <theorbtwo> ...(c) useful

[18:48] <PerlJam> ...(d) pretty hard

[18:48] <PerlJam> .....(e) hardly useful

[18:48] <PerlJam> .....(f) pretty useful

[18:49] <pmichaud> I was already thinking of putting some counters into PGE that would let us keep track of, say, the number of backtracks that occur

[18:49] <pmurias> pmichaud: grammar_parse.pge looks good..

[18:49] <PerlJam> pmichaud: you think the line between top-down and bottom-up might need to move?

[18:50] * theorbtwo U+2665's dot.

[18:50] <pmichaud> PerlJam: I have it exactly where timtoady suggests -- that seems like exactly the place to go

[18:50] <fglock> pmichaud: would grammar_rules.pge work without '<after...>'? It is not yet implemented in PCR :(

[18:51] <pmichaud> fglock:  I'm thinking I'll be able to eliminate the <after ...>

[18:51] <pmichaud> I didn't like having it in there in the first place

[18:51] <PerlJam> fglock: sounds like an incentive to implement <after:> though :)

[18:51] <fglock> pmichaud: re counters - that's a good idea

[18:51] <pmichaud> especially with audreyt's observation about infix:;

[18:52] *** ra015599 is now known as cmarcelo

[18:52] <fglock> PerlJam: I started implementing it, but then I started PG-P6...

[18:52] <lichtkind> ?eval do {;}

[18:52] *** evalbot_10027 is now known as evalbot_10028

[18:52] <evalbot_10028> undef

[18:52] <lichtkind> ?eval do {}

[18:53] <evalbot_10028> undef

[18:54] <Juerd> http://www.reghardware.co.uk/2006/04/18/amd_reverse_smt/  # "It's the very antithesis of the push for greater levels of parallelism", "the software industry will have had several years focusing on multi-threaded apps, and it may not want to go back."

[18:54] *** cmarcelo left
[18:54] * Juerd also  dot, but actually has the unicode character at his disposal ;)

[18:56] <theorbtwo> I'm in the console at the moment.

[18:56] <theorbtwo> I'm expermenting with avoiding X and it's visual distractions.

[18:56] <theorbtwo> So far, it's not going too well.

[18:56] <pmurias> use ratpoison

[18:56] <theorbtwo> pmurias: I don't mean the window manager.

[18:56] <theorbtwo> I mean firefox.

[18:57] <ayrnieu> theorbtwo - ratpoison or treewm can both make it easy for you to shove firefox out of the way for a time.

[18:57] <theorbtwo> Turns out that firefox isn't as huge a problem as I thought.

[18:57] <theorbtwo> Irssi is.

[18:58] <ayrnieu> theorbtwo - how many channels do you have?

[18:58] <theorbtwo> 9.

[18:59] <PerlJam> theorbtwo: cut back to just the essentials.  #perl, #perl6, #parrot.  :-)

[18:59] <theorbtwo> I'm not on #perl or #parrot.

[18:59] <PerlJam> well, for you then just stick to #perl6 and cut the rest!  :)

[18:59] <pmurias> i was on perl.org #perl for a while, but some of the people were sick so i left

[19:00] * theorbtwo gets rid of #london.pm, #catalyst, and #dbix-class

[19:00] <pmurias> what do you have left?

[19:00] * aufrank is curious what the other five are ;)

[19:02] * Juerd is on 24 channels...

[19:02] <theorbtwo> #axkit-dahut, #qemu, #foobarbaz, #perl6, #chat, #perlmonks

[19:02] <Juerd> But I don't feel any need to look at them regularly.

[19:02] <Juerd> They don't get in the way of getting things done.

[19:03] <ayrnieu> cutting out channels /does/ help, though.  It also helps to switch from something like irssi to something like rcirc, where you can scatter visible channels across your workspaces and not spend time switching between channels in one window.

[19:03] * theorbtwo closes #qemu too.

[19:04] <pmurias> theorbtwo: you are an emacs user?

[19:04] <theorbtwo> Yes.

[19:05] <theorbtwo> I use mostly emacs the text editor, not emacs the operating system, though.

[19:05] <PerlJam> yeah, but rcirc seems to require emacs and that's just a tad beyond the pale :-)

[19:06] <ayrnieu> PerlJam - IRC is already dead easy to write a client for.  Knowing Emacs just lets you target that platform and save on UI the way you'd normally save by targetting a terminal in unix.

[19:07] <Juerd> 21:07 < ayrnieu> PerlJam - IRC is already dead easy to write a client for.

[19:07] <ayrnieu> Juerd - it's true :-)

[19:07] <Juerd> Writing a good one, suited for people who spend a lot of time on irc, is HARD.

[19:08] <buu> ayrnieu: I seem to be recoding emacs as an irc client =[

[19:08] <Juerd> Getting the right user interface is the hard part. The protocol is the easy part.

[19:08] <Juerd> I'm a very demanding user when it comes to IRC.

[19:08] <Juerd> Irssi is far from perfect, but the best solution I'm aware of.

[19:09] <buu> Juerd: So, just curiously, what features are you missing?

[19:09] <Juerd> buu: A usable splitscreen layout, or better: tiled windows

[19:09] <Juerd> i.e. horizontally AND vertically split

[19:10] <buu> Juerd: Irssi doesn't do that?!

[19:10] <buu> Juerd: Damn, even mine does that.

[19:10] <Juerd> Not in a way I can use in a nice way.

[19:10] <ayrnieu> Juerd - I prefer rcirc to irssi, and only technical problems have prevented me from sticking with that.  Eventualy I'll have a pretty client in Erlang instead of this debugging: http://paste.lisp.org/display/19114

[19:10] <buu> What is a nice way?

[19:10] <buu> ayrnieu: A pretty client.. FULL OF ANGST.

[19:10] <Juerd> Typing commands to switch windows sucks, having the input line removed far from the window you're looking at sucks.

[19:10] <buu> Ah

[19:11] <Juerd> buu: A nice way duplicates the entire interface, rather than only the scrolling part.

[19:11] <buu> I'm pretty sure you can bind a key to switch windows..

[19:11] <ayrnieu> I also dislike input windows that are smaller than my input.

[19:11] <Juerd> buu: And a nice way lets one switch tiles with easy commands.

[19:11] * PerlJam uses Alt-N to switch windows (where N is digit from 0-9)

[19:11] <Juerd> buu: Given tiled windows, the nicest way to switch would be some meta key combined with cursor keys.

[19:11] * theorbtwo uses alt-a to switch windows.  It automatically switches to the next window with input.

[19:11] <buu> Juerd: I ask because I'm entertaining my self by bolting irc on to the back of my scary CUI

[19:12] <pmurias> CUI?

[19:12] <Juerd> PerlJam: I mean visual windows, not the windows as irssi has them. I switched to calling them "tiles" to differentiate.

[19:12] <buu> Juerd: You can't bind "alt-left" to "/window next" ?

[19:12] <PerlJam> Juerd: oh, I see

[19:12] <buu> Juerd: Ratpoison =]

[19:12] <Juerd> buu: I want alt-left to select the tile that's visually left of the currently focussed one

[19:12] <buu> Screen irssi, open up X screens that view it..

[19:12] <theorbtwo> Other then that, I use esc, N to switch channels -- alt-N switches virtual terminals.

[19:12] <Juerd> buu: I do not want multiple X windows for irssi; I want to keep it within one screen(1) window.

[19:12] <buu> Juerd: But multiple X windows are cool.

[19:13] <ayrnieu> (with rcirc and emacs I've had pretty crazy channel layouts.)

[19:13] <PerlJam> buu: not really.  I'm with Juerd on this one.

[19:13] <Juerd> No, they suck, until there's a nice way to combine it with screen.

[19:13] <ayrnieu> Juerd - why not in multiple windows under screen(1) ?

[19:13] <buu> PerlJam: Only in a crappy window manager.

[19:13] <PerlJam> buu: name a non-crappy window manager

[19:13] <buu> Anyway, I'm soliciting feature requests

[19:13] <ayrnieu> PerlJam - treewm.

[19:13] <buu> PerlJam: Ratpoison =]

[19:13] <pmurias> ratpoison++

[19:13] <buu> Although stump is starting to look cool.

[19:14] <PerlJam> cd

[19:14] <PerlJam> oops

[19:14] <pmurias> wmii is looking promising

[19:14] <buu> Really?

[19:14] <ayrnieu> buu - if stump doesn't look as cool, hack it.  I easily added windowgroups.

[19:14] <pmurias> buu: have you seen the latest snapshot?

[19:14] <Juerd> wmii sucks. It doesn't do visual intuitive navigation, and they're going to remove tiled mode.

[19:14] <buu> ayrnieu: I dislike hacking in lisp. And RP does everything I need so I have no real incentive to switch

[19:14] <buu> pmurias: Negative.

[19:15] <Juerd> ayrnieu: Because screen can also not split vertically, also has weird focussing key combinations.

[19:15] <Juerd> ayrnieu: And because you can't move irssi windows from one irssi process to another.

[19:15] <buu> Juerd: At the moment I have the code to create multiple windows on the screen, each one with its own typing buffer and contents and so forth.

[19:15] <buu> I'm bolting IRC to it, but I'm unsure how to do it generically

[19:16] <buu> Also I need a data query language..

[19:18] <buu> I think regexen would be too limited but SQL seems too verbose

[19:18] <buu> Not to mention requiring some sort of SQL interpreter

[19:18] <theorbtwo> sqlite?

[19:19] <pmurias> buu: what is a cui interface?

[19:19] <pmurias> command user interface?

[19:19] <ayrnieu> curses.

[19:19] <buu> pmurias: Console, curses, etc

[19:19] <theorbtwo> Like a CLI, but rhymes better with GUI.

[19:19] <buu> pmurias: Like screen.

[19:19] <buu> theorbtwo: Not really...

[19:19] <ayrnieu> theorbtwo - also, different.

[19:19] <buu> I may be in the minority here but I think there is a distinct difference between CLI and CUI

[19:20] <theorbtwo> Oh!

[19:20] <buu> CUI is a GUI in every respect except implemented with characters instead of pixels

[19:20] <theorbtwo> You mean "give all the functions hotkeys".

[19:20] *** aufrank joined
[19:20] <buu> You get windows and buttons and such like

[19:20] <theorbtwo> Oh.

[19:20] <PerlJam> buu: I've always called that a TUI (Text)

[19:20] <buu> CLI programs only operate directly from a command line.

[19:20] <theorbtwo> How is this like screen?

[19:20] <buu> PerlJam: Well, yeah.

[19:20] <pmurias> theoreticly CLI could display graphics

[19:21] <buu> theorbtwo: Screen is a [CTX]UI that displays CLI applications =]

[19:21] <buu> theorbtwo: Better example is IRSSI, VIM, EMACS, CAPITAL LETTERS.

[19:21] * aufrank just started up rcirc for the first time

[19:21] <pmurias> and what is ratpoison?

[19:21] <ayrnieu> anyway, "I want to print things to multiple windows which should act mostly like terminals and accept control codes and such, and I also want to get mostly line- but also with hotkeys input from the user." is a common and generic enough problem that you should be able to write an IRC client with a CUI and then switch over to a GUI with as much trouble as loading a differently-named library.

[19:22] <buu> pmurias: Er. What?

[19:22] <buu> ayrnieu: This is true.

[19:22] <pmurias> is ratpoison a CUI?

[19:22] <buu> pmurias: Er. No.

[19:22] <theorbtwo> Most of those examples, except possibly vim, have two distinct ways of interacting with them, which you blend.

[19:22] *** lichtkind joined
[19:22] <buu> Ratpoison is a window manager =]

[19:22] <theorbtwo> One is typing commands into a command-line within the application.

[19:22] <theorbtwo> The other is to press hotkeys.

[19:22] <lichtkind> ?eval do 1 if 2;

[19:22] <buu> theorbtwo: The distinction isn't how you input commands, it is how you see results.

[19:22] <evalbot_10028> 1

[19:22] <ayrnieu> theorbtwo - buu's 'CUI' differs in that it controls the interface with terminal control codes; 'CLIs' are just normal unix programs.

[19:23] <theorbtwo> Ah.

[19:23] <buu> For example, 'display foo.png' is a CLI command, but the window it creates is a GUI

[19:23] <buu> More or less. I'll admit it can be a tad fuzzy

[19:23] <buu> I mean, what is bash?

[19:23] <pmurias> a shell

[19:23] <buu> =]

[19:24] <ayrnieu> buu - a CLI, even with GNU readline.

[19:24] <buu> Yeah, I think so

[19:28] <pmurias> vim can be a pure CLI if it want to

[19:28] <pmurias> just run :ex

[19:28] <pmurias>                                     *wants

[19:30] <ayrnieu> vim++ not supporting vi's Q

[19:35] <pmurias> use gQ, Q dosn't work dispite the manual

[19:36] <theorbtwo> Hmmpf, why does  $stack[@stack] = $game->object($global_vars[195])->parent;

[19:36] <theorbtwo> call FETCHSIZE on tied(@global_vars) ?

[19:36] <PerlJam> theorbtwo: that doesn't look like perl6 ;-)

[19:36] <theorbtwo> Hm, perhaps I should join a actual perl channel.

[19:37] <pmurias> he used "use regresive <arrow>;" at the top

[19:38] <pmurias> *regressive

[19:38] <PerlJam> theorbtwo: $stack[@stack] is odd btw.  Why not just use push?

[19:39] <theorbtwo> PerlJam: Becuase I want to be able to say $a = ... (store), and $stack[@stack] = ...

[19:39] <theorbtwo> That's generated code.

[19:39] <svnbot6> r10029 | fglock++ | PG-P6 - Test.pm parsing succeeds - except that it is trying to parse the

[19:39] <svnbot6> r10029 | fglock++ | examples in the pod...

[19:39] <aufrank> fglock++

[19:39] <pmurias> shower&

[19:39] <fglock> it's not usable yet

[19:44] <ayrnieu> pmurias - vim admits to not supporting Q, last I saw; which is good for me because when I use !vim vi I am somehow always hitting that key.

[19:44] *** Arathorn is now known as Aragone

[19:53] *** b_jonas joined
[19:56] *** coumbes joined
[19:57] *** coumbes joined
[19:58] *** hcarty joined
[20:00] *** hcarty left
[20:04] <pmurias> ayrnieu: it's describe in :help Q, anyway i don't need it so i don' care what disables it

[20:07] <pmurias> *described

[20:26] <pmurias> fglock: can't locate Pugs/Grammar/Ternary.pm

[20:26] <fglock> adding...

[20:27] <svnbot6> r10030 | fglock++ | PG-P6 - Ternary.pm

[20:28] <fglock> pmurias: I think now it is possible to work in the AST in parallel with the parser - most of the remaining things are just refactorings

[20:28] <fglock> do you think we need an AST class for creating nodes?

[20:30] <pmurias> depends on the for of the AST, but if we have references why not bless them?

[20:30] <pmurias> *form

[20:33] <pmurias> what oo module should we use Moose,Spiffy or default bare-bones

[20:34] <pmurias> ?

[20:34] <mugwump> Moose!

[20:34] <buu> pmurias: Flee in terror.

[20:34] <mugwump> As the author of a different oo accessors module :)

[20:35] <fglock> I'd rather use bare bones for speed...

[20:35] <fglock> bbiab &

[20:35] <pmurias> buu: do you think a herd of angry moose is comming to punish me for mentioning Spiffy?

[20:36] *** PolettiX joined
[20:36] <buu> Yes.

[20:37] <pmurias> resistance against the moose if futile

[20:38] <buu> I have a timber wolf who begs to differ.

[20:43] <cognominal> but what about a pack of lambda-meese?

[20:44] <buu> Flame throwers.

[20:44] <cognominal> they will invoke a continuation an reappear elsewhere :)

[20:45] <cognominal> s/an/and/

[20:45] <buu> Probably. Bastards.

[20:46] <fglock> Meese = Moose.All

[20:46] <buu> EXACTLY.

[20:53] *** PolettiX is now known as froh-doh

[20:54] <pmurias> fglock: if you care about speed much, subroutine would would be faster

[20:55] <pmurias> we could use only those feathers of Moose wich don't use to much speed

[20:59] <pmurias> will the generated code use Moose if not it would be an aditional dependency

[20:59] <svnbot6> r10031 | fglock++ | PG-P6 - TODO - more detailed bugs and workarounds

[20:59] <pmurias> good night

[20:59] <pmurias> sleep&

[21:08] *** ruoso joined
[21:11] <ruoso> pmichaud++

[21:12] * ruoso just saw parrot/languages/perl6

[21:12] <pmichaud> it's coming along very nicely, yes :-)

[21:12] <pmichaud> I still need to craft up an announcement.  Maybe I'll do that while waiting at my kids' swim lessons

[21:15] * ruoso will take a better look @ home

[21:15] * ruoso wishes he could have more free time :|

[21:17] *** particle_ joined
[21:17] <particle_> hi-o

[21:18] <particle_> what do infix:~< and ~> do to a string?

[21:19] <theorbtwo> Stringy bit-shift.

[21:19] <particle_> is that per-char?

[21:19] <theorbtwo> Da.

[21:19] <particle_> thx # implementing in parrot's languages/perl6

[21:20] <TimToady> not intended to be per-char, actually.

[21:20] <particle_> please tell me more

[21:20] <TimToady> really only intended for buffer types that are of fixed width chars

[21:20] <TimToady> As in, treat the entire string as a single n-bit number.

[21:20] <particle_> say, ucs-2

[21:20] <TimToady> As soon as you start shifting bits, characters are meaningless.

[21:21] <TimToady> I'd be comfy limiting it to byte buffers.

[21:21] <particle_> okay, so it's actually bit shifting. that should be fun

[21:22] <particle_> (to use)

[21:22] <TimToady> If you want to do a bunch of them in parallel you should probably be using an array and a hyperop anyway.

[21:22] <TimToady> so I think it can just blow up on anything that looks like characters, or at least characters that might be bigger than 255

[21:23] <b_jonas> couldn't we just have a bit vector type, and some conversion functions to/from integer and byte string?

[21:23] <TimToady> but probably it should be explicitly limited to strings that we know are restricted that way already.

[21:23] <LeTo> TimToady: that should be a method on BitArray then, but not a char opcode, I think

[21:23] <fglock> TimToady: [op] is only meant for infix ops, right?

[21:23] <TimToady> right

[21:24] <b_jonas> I mean, in ruby, you can use & | ^ << >> on bignums, and [] too to get a bit, but not []= because numbers are immutable, so you don't have a real bit vector

[21:24] <TimToady> With Int being arbitrary precision, the need for a larger shiftable type becomes less.

[21:25] <LeTo> and given the proposed 'chained strings' (a mix of various encodings for one string) - what would/should ~< do?

[21:25] <b_jonas> which just shows why I think Int isn't a good type for bit vectors

[21:25] <TimToady> I don't mind most of this ending up in a bit array type.

[21:26] <TimToady> as long as we can set/get as as buffer

[21:26] <theorbtwo> I wouldn't either, if the bit vectors are easily convertable to/from a... exactly.

[21:26] <b_jonas> what operators would you use with a bit array type btw? I mean like ~&, +&, ?&, or something else?

[21:26] <theorbtwo> Even better if they're tied together.

[21:26] <mugwump> pmichaud: I'm going to write about our little interview yesterday on use.perl.org...

[21:26] <LeTo> ~< as now could work on any charsets/encodings, which doesn't make sense to me

[21:27] <b_jonas> yep, easy conversion is important

[21:27] <TimToady> ~< is free to blow up on any data type that doesn't make sense.

[21:27] <pmichaud> mugwump: okay, excellent

[21:28] <LeTo> ok - but what does make sens - shifting (7,8,16,21,32,utf8, ...) whatever bits/encodings around?

[21:29] <LeTo> this needs more specs, also with ~| et al

[21:29] <LeTo> the implementation can of course just bitwise_foo what is there ;)

[21:30] <TimToady> I think we maybe have some types that can be viewed either through the $ or @ interfaces.  The $ interface can treat the whole thing as a huge integer for bit ops, but really only if the individual bits of it are consistent.  Doing parallel bitops to dissimilar values should always use @ interface, i think.

[21:30] <TimToady> but yes, it needs to be specced better.

[21:30] <LeTo> is the $ interface really needed then?

[21:31] <TimToady> the entire spec is quite weak on the buffer vs string distinction right now

[21:31] <b_jonas> if we'd have long bitshifts, it would make a fast implementation of game of life possible

[21:32] <TimToady> The intent of ~< is to do long bitshifts in something like a byte buffer.

[21:32] <LeTo> a Int is a nice bit buffer, and supports shift anyway as well as an Array of int1 ;)

[21:32] <TimToady> depends on the implementation

[21:33] <TimToady> some BigInt implementations are, like, base 100,000, not some binary base.

[21:33] <TimToady> harder to pull the bits out of.

[21:33] <b_jonas> LeTo: let me repeat, you can do bitwise ops on an Int and shift it, but there's no easy syntax for setting a single bit, and possibly not for reading a single bit either

[21:33] <theorbtwo> So why not spec one?

[21:33] <TimToady> The stringwise bitops in Perl 5 are very handy for some things, but of course they have nothing to do with Unicode.

[21:34] <TimToady> why not spec one what?

[21:34] <b_jonas> TimToady: that's true (bc is base 10, and iirc Math::BigInt::Calc is base 10_000), but GMP which is a great and _very_ _fast_ bignum implementation is base 2^n

[21:34] <mugwump> TimToady: is there a way with rules to specify which language the block at the end is in, or to give alternate language versions, or to augment rules in a grammar with code blocks?

[21:34] <b_jonas> (though sign-magnitude, but that's a detail)

[21:34] <LeTo> b_jonas: +|= +& ...

[21:34] <theorbtwo> Way to get some bits out of a bit-buffer.

[21:35] <TimToady> fine, but we can't really use GMP if it's pure GPL.

[21:35] <pmichaud> mugwump:  rx :lang('Ruby') / \d+ \s+ {{ ruby code here }} /

[21:35] <b_jonas> hmm. licencing. that's a point.

[21:35] <b_jonas> ruby's bigints are slow and are base 2^n too.

[21:35] <b_jonas> I think base 2^n is usually the way to go in today's computers

[21:36] <TimToady> it really depends on what you're going to do with them.

[21:36] <LeTo> if the implementation is using bits or base 10_000 doesn't matter, if the result is correct (it'll be just slower maybe)

[21:36] <TimToady> If you're mostly going to be converting base 10 numbers and just doing a few calculations, a power of 10 rep can beat a power of 2 rep.

[21:37] <b_jonas> yes, that's true, but it's rarely needed in reality

[21:37] <LeTo> yes, but then ~> doesn't help either

[21:37] <b_jonas> I think the bignum library could also easily be pluggable

[21:38] <TimToady> I'm just saying it's really easy to to bitops on a bit/byte/constantwidth buffer.

[21:38] <LeTo> ... with layed out semantics ;)

[21:39] <TimToady> well, then it becomes "easy to do it right", rather than just "easy", but yes.

[21:39] <TimToady> There are lots of times you just want to play with a block of memory.

[21:40] <TimToady> We just haven't really nailed down the relationship of that to strings yet.

[21:40] <b_jonas> GPG is under the LGPL (at least the official variant). does that make it possible to use it?

[21:40] <TimToady> GMP?

[21:41] <b_jonas> uh, yes, GMP

[21:41] <b_jonas> LeTo: I don't really understant that

[21:41] <TimToady> makes it possible

[21:41] <b_jonas> do you mean +|= 1 +< $n and +&=+^ 1 +< $n ?

[21:43] <particle_> that's what i'd use, b_jonas

[21:43] <b_jonas> and, you know, what makes GMP fast is that a derivative of it is used in GPG which has to do lots of bignum calculations

[21:43] <LeTo> the mathematical shifts should work on any Int implementation (the Int isn't 32/64 bit anymore)

[21:43] <TimToady> That's all fine for +< and such, but we'll still have ~< et al.

[21:44] <particle_> well, i'm gonna wait on implementing ~> just now

[21:44] <b_jonas> particle_: and two of them with an if when you have to assign to a bit?

[21:45] * mugwump wishes SVN's web interface didn't suck

[21:45] <TimToady> I think what I'd like to say is that any compact array of native integer type can be used as if it were a string

[21:45] <b_jonas> GnuPG itself is under the GPL, not LGPL btw

[21:45] <TimToady> my uint8 @array; substr(@array,0,8) being the canonical byte buffer.

[21:46] <TimToady> so @array ~< $bits would just naturally fall out of that.

[21:47] <TimToady> Maybe better to alias it to $array though.

[21:48] <TimToady> Alternately, a byte string $buffer can be used as an array @$buffer.

[21:49] <particle_> i have a clear picture of that

[21:49] <TimToady> (same holds for bit strings, nybble strings, etc.)

[21:49] <particle_> (which is nice :)

[21:49] <theorbtwo> Only for bit-buffer strings, right?

[21:50] <TimToady> If I say bit string, I'm not thinking Unicode...

[21:51] <TimToady> I'm using "string" in a very old fashioned sense that predates even "byte strings"

[21:51] <particle_> encoding is binary

[21:51] <theorbtwo> OK.

[21:51] <TimToady> A string is just a sequence of similar things.  Just how similar is a negotiation with the compiler.

[21:51] <theorbtwo> I'm just making sure we aren't going to make 'asdf'[3] magically do the wrong thing.

[21:52] <TimToady> In the case of bit string, the things are of necessity very similar.

[21:53] <TimToady> to some people that would be "the right thing".

[21:53] <theorbtwo> Yes.

[21:53] <TimToady> but in Perl think it should probably be modulated through an @ somewhere.

[21:53] <theorbtwo> They can use a pragmata, or give their strings the right type.

[21:53] <TimToady> right

[21:54] <TimToady> at most, I thing .[] can happen naturally on fixed width things (that is, explicitly declared fixed width, not accidentally fixed width like an ASCII Unicode string...)

[21:55] <TimToady> *think

[21:55] <TimToady> so my ByteStr $foo = 'asdf';  $foo[3]; is okay, but

[21:56] <TimToady> my Str $foo = 'asdf'; $foo[3] is not.

[21:56] <LeTo> ?eval "asdf" ~< 8

[21:56] *** evalbot_10028 is now known as evalbot_10031

[21:57] <evalbot_10031> "\d[0]\d[0]\d[0]\d[0]"

[21:57] <TimToady> that would depend on how you've told the current lexical scope to compile stringish literals.

[21:57] <TimToady> default is Unicode, so it would fail.

[21:57] <TimToady> As unicode that is accidentally ASCII.

[21:58] <TimToady> there has to be some explicit representation somewhere that you intended "asdf" to represent a string whose maximum abstraction level is, say, bytes

[22:00] <particle_> is there a way to cast it anonymously?

[22:00] <TimToady> to what?

[22:00] <particle_> 'asdf'(is ByteStr) ~< 8 or such

[22:00] <theorbtwo> ('asdf' as ByteStr) ~< 8

[22:01] <theorbtwo> I think...

[22:01] <TimToady> I'm sure if there isn't a way someone will write a macro very quickly...

[22:01] <b_jonas> what about "asdf".encode(current_source_encoding) ~< 8

[22:02] * particle_ thinks that should die

[22:02] * TimToady thinks it's bogus too.

[22:02] <TimToady> the current source encoding disappears by the time you parse

[22:02] <TimToady> everything is Unicode to the parser.

[22:03] <b_jonas> oh. then you need something like q8"asdf"

[22:03] <TimToady> It's vaguely possible that it could remember the source encoding

[22:03] <TimToady> and if so, it's possible to encode it explicitly

[22:03] <b_jonas> oh, you mean it's lost even at that phase

[22:03] <TimToady> but it's kind of a nutty thing to do

[22:04] <TimToady> You shouldn't be driving the data encoding from the source encoding

[22:04] <particle_> that's in the spirit of perl :)

[22:04] *** equinox5 joined
[22:04] <TimToady> Undoubtedly it's possible, but we don't have to go out of our way to make it trivially easy.

[22:04] <equinox5> hi

[22:05] <equinox5> people

[22:05] <equinox5> How is perl 6 going

[22:05] <equinox5> ?

[22:05] <TimToady> And, of course, in Perl 6 anything that's possible can also be made trivially easy. :)

[22:05] <TimToady> It's not going, it's coming.

[22:05] <particle_> let's hope the trivially easy things are possible, too :)

[22:05] <equinox5> When is it coming?

[22:05] <TimToady> Christmas

[22:06] <theorbtwo> Perl6 seems to be good at the hard things possible.

[22:06] <TimToady> Actualy, it's coming right now.

[22:06] <equinox5> Are you sure?

[22:06] <theorbtwo> I'm less sure about the easy things easy.

[22:06] <theorbtwo> ?eval "Yes"

[22:06] <TimToady> Am I sure of what?

[22:06] <evalbot_10031> "Yes"

[22:06] <equinox5> about CHristmast?

[22:06] <TimToady> you'll not we didn't say which Christmas...

[22:06] <TimToady> *note

[22:06] <theorbtwo> equinox5: Around some christmas, plus or minus six months.

[22:07] <equinox5> that is insidious.

[22:07] <b_jonas> Christmas? thought perl6 was timtowtdi for religions too

[22:07] <TimToady> that is by design.  It's done when it's done.

[22:07] <theorbtwo> It's also within +/- 6 months of Passover.

[22:07] <b_jonas> maybe april 1?

[22:07] <TimToady> Now, if we'd said Feb 29, we'd have more of a problem.

[22:07] <theorbtwo> Indeed.

[22:07] <b_jonas> orb++ ah yes, that way it's good for everyone

[22:08] <pmichaud> we still didn't say which Feb 29 :-)

[22:08] <pmichaud> although I had a contract once that said "Sep 31"

[22:08] <TimToady> that's why it's just more of a problem.

[22:08] <particle_> it's within +/- 2 years of feb 29th

[22:08] <TimToady> now Sep 31 is a problem

[22:08] <equinox5> Do you still have a contract ?\

[22:08] <TimToady> for someone or other

[22:08] <b_jonas> and there's a slight chance that it's not within \pm6 month around Easter too

[22:08] <pmichaud> equinox5: it was a friendly contract, and we noticed the mistake a little later but decided to leave it

[22:09] <TimToady> It'll be within a month or so of summer, I can say for sure.

[22:09] <equinox5> what is the problem?

[22:09] <equinox5> because parrot is not finished?

[22:10] <equinox5> or perl 6 is not finished?

[22:10] <theorbtwo> b_jonas: I think there isn't if you define "month" correctly.

[22:11] <equinox5> is parrot good enough?

[22:11] <TimToady> good enough for what?

[22:11] <equinox5> for running commercial software on it?

[22:11] <b_jonas> theorbtwo: I'm not sure. Easter date can change more than a month.

[22:12] <TimToady> That would be up to the commerce to decide.  Most would not choose to use it yet.

[22:12] <TimToady> But a forward looking company that wants to bet on where Parrot might be in a year might well decide the other way.

[22:13] <equinox5> What other way?

[22:14] <TimToady> The other way from most.

[22:14] <theorbtwo> Oh, right.  Easter's date is kind of screwy.  You'll note that I said Passover, not Easter.

[22:14] <mugwump> http://use.perl.org/~mugwumpjism/journal/29365

[22:14] <particle_> equinox5: parrot is still under development wrt io, exceptions, threads, events, and more

[22:14] <theorbtwo> A forward-looking company that wants to bet on where Parrot would be in a year would do well to cheat on the bet.

[22:15] <particle_> true

[22:15] *** kanru joined
[22:16] <TimToady> You mean like Perl 6 is cheating on the bet?  :)

[22:16] <b_jonas> by cheating, do you mean they'd develop it or sabotage its development?

[22:17] <TimToady> Maybe Leo needs a bodyguard...

[22:17] <theorbtwo> Well, I'd personally prefer the first.

[22:17] <SamB> developing isn't cheating

[22:17] <particle_> leo has a cat for a bodyguard

[22:17] <TimToady> how big?

[22:18] <equinox5> You mean the company would be developing Perl6 to survive?

[22:18] <particle_> big enough that he can type while sitting on leo's shoulder :)

[22:18] <LeTo> 2 cats, 2 dogs

[22:18] <LeTo> err 3 dogs

[22:18] <fglock> pmichaud: grammar_rules.pge doesn't use a "stop" parameter for communicating with the bottom-up parser yet?

[22:19] <particle_> my god, those dogs multiply like rabbits!

[22:19] <b_jonas> LeTo: http://www.perlmonks.com/?node_id=322329

[22:22] <b_jonas> particle_: the same

[22:23] <equinox5> ok bye

[22:23] <LeTo> lhs substr should die,die,die

[22:23] <equinox5> I liked ti

[22:24] <b_jonas> it shouldn't. even BASIC has it.

[22:25] *** equinox5 left
[22:25] <theorbtwo> I only don't like it because of the strange fragility.

[22:25] <theorbtwo> $foo = substr(...); $foo = 'bar'; doesn't act like substr(...)='bar'

[22:26] <b_jonas> yes, because there it's copied, not referenced.

[22:26] <theorbtwo> Fortunately, in perl6, we have = and :=.

[22:26] <fglock> TimToady: is specifying an 'end token' parameter the way to go in interfacing the rule-based statement parser to the bottom-up parser?

[22:26] <TimToady> $foo = $x; $foo = 'bar'; doesn't act like $x='bar' either.

[22:27] <theorbtwo> True enough, I suppose.

[22:27] <b_jonas> $foo = \substr(...); $$foo = 'bar'; acts like it

[22:27] <TimToady> "an" end token is probably limiting it unnecessarily.  A set of end tokens is more like it.

[22:28] <TimToady> But a match can match a set of tokens, so passing in an end match is probably sufficient.

[22:28] <TimToady> $foo = \$x; $$foo = 'bar' too.

[22:29] <TimToady> The real problem with lvalue substr is that Perl 5 fakes it without a real COW engine underneath.

[22:30] <fglock> are the things inside brackets parsed using subrules? like in (@a;@b); - so that the 'end' is not matched in the wrong place

[22:31] <TimToady> As a basic rule of thumb, if you have brackets, you probably want a subrule

[22:31] *** Limbic_Region joined
[22:32] <TimToady> though it's possible to do with op prec if you fiddle with infinities in the relative precedence inside and outside.

[22:32] <TimToady> but it's difficult to detect the (@a;@b] error without knowing the "right" terminator.

[22:33] <fglock> thanks - things are starting to fit together :)

[22:34] *** KingDiamond joined
[22:34] <fglock> is sub 'circumfix:( ]' a valid spec?

[22:34] <TimToady> It's sort of like the difference between which things you need to use recursive regex on vs which things you can match with a flat regex (in P5 terms).

[22:35] <TimToady> syntactically, yes, that's valid.  You're nuts if you do it though.

[22:35] <TimToady> And you'll likely get a warning anyway if you define two circumfixes with the same left side.

[22:35] *** frederico joined
[22:35] <TimToady> s/two/a second/

[22:37] <TimToady> but there's nothing says a circumfix can't be <fred barney>

[22:39] <TimToady> Any pair of fixed strings is syntactically legal.  Just can't be anything fancier than a string.

[22:41] <b_jonas> that reminds me to the new string literal syntax in lua 5.  Now not only [[this is a string]] but [=[this is too]=] and [==[this too]==] and [===[up to infinity]===]

[22:41] <Juerd> What happens if you'd declare a set of {'<fred', 'barney>'}? Will it warn about the clash with {'<', '>'}?

[22:42] * fglock imagines code written using embedded objects and data structures - "Matching against non-strings" in s05

[22:42] <Juerd> (Or just die, which may make more sense)

[22:42] <fglock> Juerd: yes - there is the longest-token rule

[22:43] <Juerd> Your "yes" doesn't agree in boolean sense with the explanation "there is the longest-token rule"...

[22:44] <fglock> it's not a clash

[22:44] <fglock> so it will not warn

[22:44] <fglock> but '<','barney>' is a clash

[22:45] <fglock> likewise with this more concrete example: '<<','>>'

[22:46] <FurnaceBoy> 	*	mugwump wishes SVN's web interface didn't suck

[22:46] <FurnaceBoy> have you tried ViewVC (formerly known as ViewCVS), or WebSVN?

[22:47] <FurnaceBoy> I don't think I'd want more than the current functionality (browse HEAD) built into mod_(dav_)svn itself

[22:51] <fglock> is "sub '++' {}" declaring "prefix:++" by default, or it a separate sub?

[22:53] <fglock> which just happens to clash with prefix:++ in some context?

[22:57] <svnbot6> r10034 | fglock++ | p6ast_draft - added some notes about keeping the operator fixity information

[22:58] <fglock> later & - YAPC::Brasil social meeting :)

[22:59] <fglock> another question for when I backlog:

[22:59] <fglock> how to declare a global '++'? is it "  sub *'++' {}  "?

[23:00] *** fglock left
[23:00] <TimToady> fglock: sub '++' {} is not legal syntax.

[23:01] <TimToady> any name that is not an identifier has to be in the foo:<++> form.

[23:01] <TimToady> or foo{'++'}, equivalently.

[23:01] <TimToady> or foo:{'++'}, rather

[23:04] <TimToady> prefix:++ is also illegal.  Has to be prefix:<++>

[23:16] *** weinig joined
[23:22] *** b_jonas joined
[23:25] *** ruoso left
[23:26] <particle_> is the latest flip-flop name 'till' or 'ff'

[23:27] <TimToady> ff

[23:27] <particle_> is there an ^ff^

[23:27] <TimToady> yes.

[23:28] <particle_> thx

[23:28] <particle_> is there a definitive list of ops i should look at? i think S03 is incomplete

[23:29] <particle_> so is pugs's src/Pugs/Parser/Operator.hs

[23:31] <meppl> gute ancht

[23:31] <TimToady> S03 is supposed to be complete.  Where it's not, we should fix it.

[23:32] <TimToady> (that is, complete in the sense of documenting the all the differences from Perl 5.)

[23:32] <particle_> okay. i've been using the precedence section to implement the op tokens, i'll send a list to p6l of ops that don't appear there

[23:33] <TimToady> thanks

[23:33] <particle_> s/list/patch/

[23:33] <TimToady> though some of the precedence levels are necessarily incomplete

[23:33] <TimToady> such as list operators

[23:33] <particle_> understood

[23:35] *** FurnaceBoy_ joined
[23:37] <particle_> the same fff variants exist as ff, correct?

[23:44] <TimToady> particle_: yes, that was part of the motivation for s/till/ff/

[23:44] <TimToady> though arguably the sed semantics of , are broken

[23:45] <particle_> first catch of missing op is =~

[23:45] <b_jonas> why, til and till is just like .. and ... or fil and fill in TeX

[23:45] <particle_> should be parsed, and throw error

[23:45] <TimToady> there is no =~ operator. :)

[23:46] <TimToady> it's just in there explicitly to catch that error.

[23:46] <particle_> i'm reading S03... the parser will define infix:<=~>...

[23:46] <particle_> so, i have it defined as   is pir<"    'die'('brain-o. use ~~ or ~= instead.')">

[23:46] <TimToady> that's fine.

[23:47] <TimToady> doesn't even matter what precedence level it is...

[23:47] <b_jonas> why, what's ~= then?

[23:47] <TimToady> P5's .=

[23:47] <b_jonas> oh.

[23:47] <particle_> because perl6's .= is totally different

[23:47] <particle_> i don't grok 'modifies the object inplace'

[23:48] <particle_> replaces the instance with another?

[23:48] <TimToady> @foo.sort returns a sorted list.

[23:48] <TimToady> @foo.=sort sorts @foo in place.

[23:48] <particle_> ah. thx

[23:48] <TimToady> @foo .= sort is the binary op form of it.

[23:48] <b_jonas> now that's a good idea, removing =~ completely

[23:49] * TimToady curtsies.  er, bows.

[23:49] <b_jonas> will that mean that ~~ will have the same operand order as =~, that is, the opposite as ruby's === ?

[23:50] <particle_> ??? and !!! are missing, too

[23:50] <TimToady> those are terms, not operators.

[23:50] <TimToady> unless of course we turn them into prefix operators

[23:50] <b_jonas> S3 doesn't mention ~~

[23:50] <particle_> sure it does

[23:51] <particle_> 5th bullet in 'New operators'

[23:51] <TimToady> Are you looking at a recent S03?

[23:51] <b_jonas> probably not then

[23:51] <particle_> also listed in 'chaining binary' under precedence

[23:51] <particle_> http://dev.perl.org/perl6/doc/design/syn/S03.html

[23:51] <TimToady> should theoretically be up-to-date as of yesterday.

[23:52] <TimToady> unless the nightly copy has died.

[23:52] <TimToady> but you probably want svn.perl.org's copy for the most recent.

[23:52] <particle_> i see a 7 Apr 2006 date, version 18 at that url

[23:52] <TimToady> but then you have to read pod.

[23:52] <TimToady> version 18 is the most recent.

[23:53] <TimToady> Maybe the html formatter is screwing up?

[23:53] <particle_> i mentioned this to pm when writing pge tests... the synopses are very well written -- quite easy to code tests against

[23:53] <TimToady> My copy of the html seems fine.

[23:54] <TimToady> maybe you're getting the copy from perl.com?

[23:54] <TimToady> that would be ancient

[23:55] <particle_> is there an index of synopses?

[23:55] <particle_> i expected that to be S01, but no

[23:55] <TimToady> the index of synopses is the Camel book.  :)

[23:56] <TimToady> Anyway ~~ is intended to be a fairly symmetrical operator, to the extent possible.

[23:56] <b_jonas> symmetrical? wierd.

[23:56] <TimToady> Ruby has a lot of unnecessary assymmetry builtin because of it's SMD model.

[23:57] <b_jonas> why would it have to be symmetrical?

[23:57] <b_jonas> SMD model?

[23:57] <particle_> hrmm, <> and <<>> seem to be missing, too

[23:57] <b_jonas> SMD?

[23:57] <TimToady> single method dispatch.

[23:57] <b_jonas> no, that's not the only reason

[23:57] <TimToady> you mean postfix:{'<','>'} ?

[23:57] <b_jonas> look,

[23:57] <particle_> i mean like qw

[23:57] <particle_> circumfix

[23:57] <TimToady> that's a term, not an operator.

[23:58] <particle_> ah, also a term.

[23:58] <TimToady> though the distinction is somewhat artificial.

[23:58] <mugwump> TimToady: wouldn't that be post_circumfix:<<{ }>> ?

[23:58] <b_jonas> suppose Foo is a class and you say 'when Foo', which tests '$_ ~~ Foo'

[23:58] <TimToady> postcircumfix, yes

[23:58] <particle_> postcir...

[23:58] <particle_> yes

[23:58] <b_jonas> now you want this to match iff $_ is an instance of Foo or one of its descendants

[23:58] <TimToady> You can also say Foo ~~ $_

[23:59] <b_jonas> but then, would Class ~~ Foo match? Class is not a Foo but Foo is a Class

[23:59] <TimToady> There is not Class class in Perl 6.

[23:59] <b_jonas> yes, but does that really ruin my point?

[23:59] <b_jonas> it's still not symmetrical I think

