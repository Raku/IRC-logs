[00:02] *** mako132_ joined
[00:17] *** awwaiid joined
[00:17] *** bonesss joined
[00:28] *** rlb3 joined
[00:43] *** whooosh joined
[00:57] *** thepler joined
[01:43] *** scw joined
[01:59] *** mako132_ joined
[02:03] *** whooosh joined
[02:21] *** mako132_ joined
[02:49] *** mako132_ joined
[02:58] *** jferrero joined
[03:21] *** n0ps1d joined
[03:40] *** sweinig is now known as sweinig|zZz

[03:47] *** stevan_ joined
[04:04] *** H0LE joined
[04:31] *** justatheory joined
[04:35] *** Ickyshuffle joined
[04:38] *** nopsid joined
[05:19] *** scw joined
[05:31] *** nopsid joined
[05:36] *** Ickyshuffle joined
[06:13] *** [particle] joined
[06:15] *** BooK joined
[06:17] *** nopsid joined
[06:28] *** H0LE joined
[06:29] *** TreyHarris joined
[06:29] *** badalex joined
[06:29] *** autark_ joined
[06:29] *** Eidolos joined
[06:29] *** bcorn_ joined
[06:29] *** silug joined
[06:29] *** pasteling joined
[06:29] *** Gothmog_ joined
[06:29] *** smash_ joined
[06:48] *** nopsid joined
[07:06] *** scsibug_ joined
[07:18] *** nopsid joined
[07:23] *** dduncan joined
[07:35] *** H0LE left
[07:58] *** jabbot joined
[08:25] *** boo is now known as beu

[08:42] *** iblechbot joined
[09:01] *** sweinig joined
[09:01] *** TreyHarris joined
[09:01] *** badalex joined
[09:01] *** autark_ joined
[09:01] *** Eidolos joined
[09:01] *** bcorn_ joined
[09:01] *** silug joined
[09:01] *** pasteling joined
[09:01] *** Gothmog_ joined
[09:01] *** smash_ joined
[09:13] *** SamB joined
[09:13] *** Southen joined
[09:13] *** sweinig joined
[09:13] *** iblechbot joined
[09:13] *** jabbot joined
[09:13] *** dduncan joined
[09:13] *** BooK joined
[09:13] *** [particle] joined
[09:13] *** justatheory joined
[09:13] *** nicodaemos joined
[09:13] *** gnuvince joined
[09:13] *** miyagawa_ joined
[09:13] *** marmic joined
[09:13] *** spoop joined
[09:13] *** shadowspar joined
[09:13] *** qmole joined
[09:13] *** baest joined
[09:13] *** penk joined
[09:13] *** frankg joined
[09:13] *** slanning joined
[09:13] *** kanru joined
[09:13] *** Patterner joined
[09:13] *** SCalimlim joined
[09:13] *** Yappo joined
[09:13] *** drbean_ joined
[09:13] *** sri___ joined
[09:13] *** lambdabot joined
[09:13] *** AzureBOT joined
[09:13] *** gantrixx joined
[09:13] *** GabrielVieira joined
[09:13] *** orafu joined
[09:13] *** mj41_ joined
[09:13] *** Khisanth joined
[09:13] *** buu joined
[09:13] *** bennymack joined
[09:13] *** jrockway joined
[09:13] *** evalbot_r14767 joined
[09:13] *** svnbot6 joined
[09:13] *** mugwump joined
[09:13] *** buubot joined
[09:13] *** dbrock joined
[09:13] *** ofer0 joined
[09:13] *** nekokak__ joined
[09:13] *** ruz joined
[09:13] *** integral joined
[09:13] *** mako132 joined
[09:13] *** webmind joined
[09:13] *** pmichaud_ joined
[09:13] *** plural joined
[09:13] *** leo_ joined
[09:13] *** chip joined
[09:13] *** Juerd joined
[09:13] *** audreyt joined
[09:13] *** wolverian joined
[09:13] *** xinming joined
[09:13] *** eviltwin_b joined
[09:13] *** spo0nman joined
[09:13] *** f0rth joined
[09:13] *** puddingpimp_work joined
[09:13] *** perlbot joined
[09:13] *** mdiep joined
[09:13] *** PerlJam joined
[09:13] *** pdcawley joined
[09:13] *** norageek joined
[09:13] *** sjn joined
[09:13] *** idiotmax joined
[09:13] *** kane-xs joined
[09:13] *** wilx joined
[09:13] *** revdiablo joined
[09:13] *** meppl joined
[09:13] *** takesako joined
[09:13] *** takanori_ joined
[09:13] *** cognominal joined
[09:13] *** hcchien joined
[09:13] *** tcliou joined
[09:13] *** jiing joined
[09:13] *** nine joined
[09:13] *** Ikarus joined
[09:13] *** nipotaway joined
[09:13] *** kolibrie joined
[09:13] *** pnu joined
[09:13] *** Maddingue joined
[09:13] *** Shabble joined
[09:13] *** broquaint joined
[09:13] *** nnunley joined
[09:13] *** kcwu joined
[09:13] *** rafl_ joined
[09:13] *** cj joined
[09:13] *** Debolaz joined
[09:13] *** rgs joined
[09:13] *** knewt joined
[09:13] *** spinclad joined
[09:13] *** GeJ joined
[09:13] *** cmeyer joined
[09:13] *** LCamel joined
[09:13] *** cookys joined
[09:13] *** masak joined
[09:13] *** dvorak joined
[09:13] *** prism joined
[09:13] *** beppu_ joined
[09:23] *** Lorn joined
[09:40] *** elmex joined
[09:58] <nothingmuch> audreyt: i need some advice

[09:58] <nothingmuch> MO is going to be bootstrapping itself soon

[09:58] *** larsen_ joined
[09:58] <nothingmuch> through .pmcs

[09:58] <audreyt> so not dep on oldMoose anymore?

[09:58] <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.

[09:58] <audreyt> @massages

[09:58] <lambdabot> Limbic_Region said 1d 10h 39m 7s ago: Win32 hangs smoking on t/perl5/modify_inside_p5_p6.t

[09:58] <lambdabot> fglock said 20h 20m 53s ago: see r14779

[09:58] <nothingmuch> for development of MO itself I need two versions in %::

[09:59] <nothingmuch> one is Moose MO, and one is MO MO

[09:59] <nothingmuch> and of course, later, i need to keep a stable copy of MO MO

[09:59] <nothingmuch> in .pmc form

[09:59] <audreyt> sure

[09:59] <nothingmuch> fortunately since MO is not very strict about package naming i can do that fairly easily by using class transforms

[09:59] <nothingmuch> and renaming the class in the registry

[10:00] <nothingmuch> but it can get nasty

[10:00] <audreyt> you can also use http://pugs.blogs.com/pugs/2006/06/multiversioning.html#more hack

[10:00] <lambdabot> http://tinyurl.com/yxeyae

[10:00] <audreyt> which enables caller-sensitive symbol processing

[10:00] <nothingmuch> yes, that's what I wanted to ask =)

[10:00] <audreyt> it should be fairly self explanatory

[10:00] <nothingmuch> aye

[10:01] <audreyt> 23:04 <@gnat> I have no joke here, I just like to say "first you simply swap out the entire symbol table."

[10:01] <nothingmuch> i'm more interested in what you're doing at load time

[10:01] <nothingmuch> e.g. how do you load two Foo.pms as Foo1 and Foo2

[10:01] <audreyt> easy

[10:02] <audreyt> load Foo

[10:02] <nothingmuch> load and then hijack?

[10:02] <audreyt> %Foo1:: = %Foo::

[10:02] <nothingmuch> oh right i can actually do this with an inc hook

[10:02] <nothingmuch> nevermoose =)

[10:02] <audreyt> Symbol::delete_package('Foo')

[10:02] <audreyt> yes, or hijack CORE::require

[10:02] <nothingmuch> Foo::Bar will also be moved to Foo1::Bar, right?

[10:02] <audreyt> it's trivial :)

[10:02] <audreyt> yes.

[10:02] <nothingmuch> okies

[10:03] <nothingmuch> lastly, do you know of a good way to force load the .pm if a valid .pmc exists?

[10:03] <nothingmuch> 	eval "#line 1 $INC{$file}\n" . do { local (@ARGV, $/) = $INC{$file}; <> }; # FIXME YUCKYUKCYUCKCKCKCKC

[10:03] <audreyt> via INC hook you can hijack search algo.

[10:03] <nothingmuch> }

[10:03] <nothingmuch> that's what I do now

[10:03] <nothingmuch> avar suggested inc hook

[10:03] <nothingmuch> aye, but that is deeper than that

[10:03] <nothingmuch> the .pmc overload is at the open stage

[10:03] <nothingmuch> doopen_pm

[10:03] <nothingmuch> not the search

[10:04] <nothingmuch> i can use my own FH

[10:04] <audreyt> you just pass content

[10:04] <nothingmuch> but that's not much different

[10:04] <audreyt> no pseudo fh required

[10:04] <nothingmuch> is that new?

[10:04] <audreyt> do a @INC file search yourself

[10:04] <audreyt> no it's just undocumented.

[10:05] <nothingmuch> ... ;-)

[10:05] <audreyt>             # Return all contents line-by-line from the file inside PAR

[10:05] <audreyt>             my @lines = split(

[10:05] <audreyt>                 /(?<=\n)/,

[10:05] <audreyt>                 $zip->memberNamed($filename)->contents

[10:05] <audreyt>             );

[10:05] <audreyt>             return (sub {

[10:05] <audreyt>                 $_ = shift(@lines);

[10:05] <audreyt>                 return length $_;

[10:05] <audreyt>             });

[10:05] <audreyt> that's how PAR used to do its job

[10:05] <nothingmuch> ah

[10:06] <audreyt> thoroughly undocumented although dependable on 5.6+

[10:07] <nothingmuch> coolness

[10:07] <audreyt> "we no longer write games in perl because perl itself is the game" etc

[10:08] <nothingmuch> hehe

[10:11] <nothingmuch> return length $_? not return length @lines or something?

[10:11] <nothingmuch> or will it stop when $_ becomes undef?

[10:12] <audreyt> the latter

[10:12] <audreyt> I took that from Acme::use::strict::with::pride

[10:13] <audreyt> which actually is a good model for you to adapt from

[10:14] <nothingmuch> bah, it becomes /loader/0x18c332c/examples/Point.pm

[10:14] <audreyt> #line

[10:15] <audreyt> as $lines[0]

[10:16] <nothingmuch> erm

[10:16] <nothingmuch> yeah

[10:16] <nothingmuch> no diff than what I was doing before, really ;-)

[10:16] <audreyt> so, exactly same as A::u::s::w::p

[10:16] <audreyt> well, a bit different

[10:16] <audreyt> the eval call stack is "right"

[10:16] <nothingmuch> ah'

[10:16] <audreyt> unlike manual ppeval

[10:16] <nothingmuch> fair enough

[10:26] <nothingmuch> ughghghg

[10:26] <nothingmuch> weird compilation errors from nowhere

[10:26] <nothingmuch> syntax error at examples/Point.pm line 24, near ":"

[10:26] <audreyt> did you empty $_? returned 0 eventually?

[10:27] <nothingmuch> yes

[10:27] <nothingmuch> i have warn $i++ . ": $_"; in the returned sub

[10:28] <audreyt> uhm. try some voodoo debugging

[10:28] <audreyt> I can't actually focus on code now, sorry

[10:28] <pasteling> "nothingmuch" at 84.108.53.74 pasted "output" (43 lines, 1.7K) at http://sial.org/pbot/21210

[10:28] <nothingmuch> okay

[10:28] <nothingmuch> thanks =)

[10:29] <audreyt> np :)

[10:32] * nothingmuch goes back to the old method

[10:33] <nothingmuch> leaving the new one commented as "# this is more correct but doesn't work" ;-)

[10:38] *** dduncan left
[10:51] *** polettix joined
[10:55] *** Belaf joined
[10:57] *** iblechbot joined
[11:14] *** chris2 joined
[11:25] *** xinming joined
[11:38] *** buetow joined
[11:50] *** SCalimlim joined
[12:05] *** elmex joined
[12:05] *** TimToady joined
[12:30] *** Psyche^ joined
[12:37] *** sweinig is now known as sweinig_

[12:37] *** sweinig_ is now known as sweinig

[12:38] *** ludan joined
[12:42] *** jferrero joined
[12:46] *** Psyche^ is now known as Patterner

[13:00] *** eggzeck joined
[13:01] *** b00t joined
[13:16] <xinming> anyone here would help me clarifying what does term mean?

[13:17] <xinming> I'm reading synopsis. And find the word term...

[13:21] <svnbot6> r14788 | audreyt++ | * add back movies.html to pugscode.org

[13:22] * nothingmuch 's brain froths

[13:22] <nothingmuch> xinming: a syntactic unit

[13:22] <nothingmuch> that's a bit vague

[13:23] <nothingmuch> generally... a variable, or a function call, or something like that

[13:23] <audreyt> a term is a subexpression that can also be a valid expression in itself

[13:23] <nothingmuch> i think the line is "an expression that has a value" is a term

[13:23] <audreyt> as opposed to an operator, which needs terms to be operated on

[13:23] <audreyt> and are not valid expressions in itself

[13:23] <audreyt> "that has a value" is a good explanation too

[13:23] <nothingmuch> but far less precise =)

[13:24] <audreyt> it's actually isomorphic :)

[13:24] <nothingmuch> hmm

[13:24] <nothingmuch> fair enough

[13:25] <nothingmuch> audreyt: i have a far more sane bootstrap plan, btw

[13:25] <nothingmuch> .pmc MO compiles to bootstrap::MO::Compile::Class etc

[13:25] <nothingmuch> .pmc MO compiles non .pmc MO, that is

[13:26] <nothingmuch> and then right before the DDS dump it does 'local %{"MO::"} = %{"bootstrap::MO::"}

[13:26] <audreyt> aha

[13:26] <audreyt> clevar

[13:26] <nothingmuch> aye

[13:26] <audreyt> nothingmuch++ # clavar

[13:26] <nothingmuch> and it's a very simple trick in MO::P5::Registry

[13:27] <audreyt> excellent plan if DDS doesn't use MO :)

[13:27] <audreyt> which it has no reason to

[13:27] <audreyt> so very safe

[13:27] <audreyt> cool hack.

[13:27] <nothingmuch> well, theoretically it still works

[13:27] <nothingmuch> because bootstrap::MO::* is compiled, after all

[13:28] <nothingmuch> so even if we swap the MO version underneath, it should still work

[13:28] <nothingmuch> bar api incompatibilities

[13:28] <audreyt> provided it's api compatible

[13:28] <audreyt> which you can't guarantee at that stage

[13:28] <nothingmuch> only the first version of DDS doesn't need to use MO =)

[13:28] <audreyt> it's stage1

[13:28] <audreyt> right =)

[13:28] <nothingmuch> (woohoo! it doesn't ;-)

[13:28] <audreyt> ok. looking forward to crossgenerate native p6 class in both runcores :)

[13:29] <audreyt> nothingmuch++ # right mix of insanity and cleverness

[13:29] <xinming> Ok, so term is a subset of expression which can be expression itself, right? :-P

[13:29] <nothingmuch> current plan: .pmcify the moose incarnation of MO

[13:29] <nothingmuch> (the .pmc generating code wouldn't know the diff anyway)

[13:29] <audreyt> xinming: not subset, "part of"

[13:29] <audreyt> xinming: "1" is part of "1+2"

[13:29] *** BrendaSexy joined
[13:29] <nothingmuch> and then incrementally swap out Moose based impl with a MO based one

[13:29] <xinming> audreyt: thanks.

[13:30] <xinming> audreyt: How to say 'term' in Chinese?

[13:30] <audreyt> yup. sane plan

[13:31] <audreyt> xinming: zh-cn?

[13:31] <xinming> audreyt: zh-tw is ok

[13:31] <audreyt> U+9805 I think is -cn

[13:32] <xinming> 我的意思是怎麼翻譯。

[13:32] <xinming> :-)

[13:32] <nothingmuch> i hope you had to use a reference

[13:32] <audreyt> xinming: U+9805 :)

[13:32] <audreyt> xiang

[13:32] <audreyt> 項

[13:32] <xinming> Ok...

[13:32] <xinming> thanks.

[13:36] <audreyt> xinming: I think 詞彙 is zh-tw

[13:37] <audreyt> you can combine both to make 詞項

[13:37] <audreyt> which I think is the best translation

[13:37] <audreyt> I think 詞項 is also used in classical logic textbooks

[13:37] <audreyt> so go ahead with that

[13:38] <audreyt> operator = 算符, operand = 算元, expression = 陳述式 (zh-cn simply has it as "式" I think)

[13:40] <audreyt> zzz *wave* &

[13:41] <xinming> audreyt: thanks

[13:42] <xinming> operator = 操作符， operand = 操作對象, expression = 表達式， :-)

[13:46] <nothingmuch> i hope you had to use a reference

[13:48] <xinming> nothingmuch: Most books in mainland are from TaiWan.

[13:48] <xinming> :-)

[13:48] <nothingmuch> i meant i hoped that audrey didn't remember U+9805 from memory

[13:48] <nothingmuch> then I thought IRC was my terminal and hit up, enter

[13:49] <xinming> ...

[13:49] <xinming> How to type uncide?

[13:49] <xinming> eg, give you a number.

[13:49] <xinming> how to type that?

[13:50] <nothingmuch> no

[13:50] <nothingmuch> that the word for 'term' is unicode number blah blah blah

[13:50] <nothingmuch> it's inhuman to know unicode numbers by heart

[13:50] *** mdiep joined
[13:50] <xinming> But she is super-woman.. ;-)

[13:50] <nothingmuch> that was the joke =)

[13:55] *** eggzeck joined
[13:58] <nothingmuch> w 19

[14:05] *** mdiep joined
[14:06] * smash_ good day

[14:35] *** sweinig is now known as sweinig|bbl

[14:35] *** turrepurre joined
[14:46] <Belaf> Hi all! I've got a question: willing to play a little bit with pugs, should I get Perl6-Pugs-6.2.13 from CPAN or is it any better try to stick with the latest SVN ?

[14:47] <Patterner> latest imho

[14:49] <Belaf> Thanks Patterner. Does this mean SVN head is stable (still, just for playing :)) enough?

[14:49] <Patterner> why do you care about stable anyway? :)

[14:50] <Patterner> for playing it's good enough

[14:51] <Belaf> Well, in some cases things from repository heads are not even meant to be compilable. Glad to hear it's not the case :). Thanks a lot!

[14:53] *** SCalimlim joined
[15:14] *** thepler joined
[15:17] <nothingmuch> YAY

[15:17] <nothingmuch> MO::Compile::Field::Simple is now written in MO

[15:18] <nothingmuch> and Simple.pm.boot is written in Moose, and is used to compile itself

[15:20] <nothingmuch> and the resulting Simple.pmc can replace the moose written Simple.pm.boot

[15:40] *** turrepurre joined
[16:03] *** H0LE joined
[16:04] *** IndyBC joined
[16:04] *** IndyBC left
[16:18] *** eggzeck joined
[16:29] *** sweinig|bbl is now known as sweinig

[17:00] *** beu is now known as immortalbeu

[17:02] *** immortalbeu is now known as beu

[17:15] *** lisppaste3 joined
[17:19] *** f0rth joined
[17:19] *** buu joined
[17:19] *** qmole joined
[17:27] *** thepler joined
[17:28] *** gnuvince joined
[17:28] *** penk joined
[17:28] *** frankg joined
[17:28] *** buubot joined
[17:28] *** ofer0 joined
[17:28] *** perlbot joined
[17:28] *** Limbic_Region joined
[17:29] *** sweinig is now known as sweinig|food

[17:29] *** frankg joined
[17:29] *** ofer0 joined
[17:35] *** penk joined
[17:36] *** buubot joined
[17:38] *** nopsid joined
[17:45] *** fglock joined
[17:49] *** turrepurre joined
[17:54] <svnbot6> r14789 | fglock++ | MP6  - bootstrapped compiler generates stable code (compiled == previous)

[17:54] <svnbot6> r14789 | fglock++ | - autoquote hash keys      { a => 42 }

[17:54] <svnbot6> r14789 | fglock++ | - pair syntax sugar        { :$a }

[17:55] *** fglock joined
[17:57] <fglock> audreyt, nothingmuch: ping?

[18:08] *** nopsid joined
[18:12] *** mako132_ joined
[18:19] *** mako132_ joined
[18:24] *** sweinig_ joined
[18:35] <nothingmuch> @tell fglock /msg me when you're back and I'll backlog if it helps

[18:35] <lambdabot> Consider it noted.

[18:36] <nothingmuch> nobody in particular:

[18:36] <nothingmuch> the constructor protocol for MO, as I see it, in the default class is going to be:

[18:36] <nothingmuch> Class->create_instance( $meta_field => $value ); # low level constructor, interfaces with layout directly

[18:36] <nothingmuch> this can be used to serialize objects without knowing their representation format, for example

[18:37] <nothingmuch> and then around that Class->new

[18:37] <nothingmuch> which will take the params

[18:37] <nothingmuch> hand them to every attribute

[18:37] <nothingmuch> expecting back a list of field/value pairs

[18:37] <nothingmuch> which it gives back to create_instance

[18:37] <nothingmuch> then it calls BUILDALL

[18:37] <nothingmuch> does that make sense?

[18:38] <nothingmuch> in Perl 6 the semantics are slightly different, as the various BUILD methods actually handle the attr initialization, IIRC

[18:38] <nothingmuch> that's more difficult to inline, though

[18:38] <nothingmuch> (in p5 space)

[18:41] *** gnuvince joined
[18:56] *** rodi joined
[19:08] *** mako132_ joined
[19:15] *** elmex joined
[19:15] *** araujo joined
[19:19] *** rindolf joined
[19:19] <rindolf> Hi all.

[19:31] *** sweinig_ is now known as sweinig

[19:32] *** sweinig is now known as sweinig|bbl

[19:39] *** frost joined
[20:01] *** sweinig|bbl is now known as sweinig

[20:09] *** Corion joined
[20:09] *** Corion left
[20:11] *** Captain_Fourier joined
[20:11] <Captain_Fourier> hello

[20:27] *** mdiep joined
[20:27] *** Aankhen`` joined
[20:34] *** Aankhen`` is now known as TR0LL

[20:34] *** TR0LL is now known as Aankhen``

[20:35] <rindolf> Hi Captain_Fourier

[20:35] <Captain_Fourier> wwhere can i get a good tutorial on p6

[20:37] <audreyt> Captain_Fourier: http://www.programmersheaven.com/2/Perl6-FAQ

[20:37] <lambdabot> Title: Perl6-FAQ at Programmers Heaven

[20:39] <rindolf> Hi audreyt

[20:39] <audreyt> hi. just woke up and going to sleep again

[20:39] * audreyt is still sleeping in <5hr chunks

[20:40] <gnuvince> Has anyone ever experienced an out-of-memory problem compiling pugs?

[20:41] <gaal> I forget.

[20:41] <gaal> gnuvince: vi config.yml and tweak the ghc heap setting.

[20:42] <audreyt> gnuvince: or just "make" again

[20:42] *** mdiep joined
[20:46] *** dduncan joined
[21:03] *** anatolyv joined
[21:23] *** eggzeck joined
[21:34] <dduncan> seen stevan_

[21:34] <jabbot> dduncan: stevan_ was seen 262 days 23 hours 14 minutes 59 seconds ago

[21:35] <dduncan> are there any Moose people on the list now?

[21:35] <dduncan> I have a few questions or suggestions that may help improve Moose

[21:36] <Debolaz> dduncan: He's in #moose @ magnet.

[21:36] <dduncan> actually, that just came to mind ...

[21:36] <dduncan> I knew there was a #moose channel, but not what IRC server it is on

[21:37] <stevan_> dduncan: whats up

[21:38] <Debolaz> Apparently, also here. :-)

[21:39] <stevan_> hey Debolaz :)

[21:39] <Debolaz> Heya.

[21:39] * Debolaz is about to head off to work to start a new project which will be using Moose.

[21:40] * stevan_ is babysitting a partially-automated data import script :)

[21:41] <dduncan> oh you are here

[21:42] <stevan_> dduncan: yup :)

[21:42] <dduncan> stevan_ , this concerns type constraints

[21:42] <dduncan> first, the question ...

[21:43] <dduncan> in your Moose::Util::TypeConstraints, I notice that 'Str' and 'Int' and 'Num etc assert that the given value is not a reference type

[21:43] <stevan_> yes, this is to model p5

[21:43] <dduncan> however, what would this do if someone wanted to use a BitInt or BigNum etc type that are bundled with Perl?

[21:43] <dduncan> I mean, BigInt

[21:44] <stevan_> isa => 'BigInt'

[21:44] <dduncan> presumably, Perl 6's numbers are based on those so to have arbitrary precision

[21:44] <stevan_> assuming that a $bigint->isa(BigInt)

[21:44] <dduncan> that isn't what your "subtype 'Int"" contains

[21:45] <stevan_> dduncan: the Moose type constraint system does not try to emulate p6's type system

[21:45] <stevan_> only p5s

[21:45] <stevan_> a BigInt in p5 is a overloaded class

[21:45] <stevan_> which is (at it's core) a reference

[21:45] <dduncan> so the 'Int' you predeclare is explicitly not big, just what a normal Perl 5 SV can hold?

[21:45] <stevan_> yup

[21:46] <dduncan> I would have thought the default 'Int' ought to accept either an SV int or a BigInt

[21:46] <stevan_> I pondered trying to model p6 types, and Moose::Autobox was where I was experimenting with it

[21:46] <dduncan> since both act like an int

[21:47] <stevan_> dduncan: well yes, in theory

[21:47] <dduncan> but you decided in practice that this was bad?

[21:47] <stevan_> but in practice it is very hard to do that and still be efficient

[21:47] <stevan_> no, it would be good

[21:47] <stevan_> I agree with you

[21:47] <stevan_> the problem is that there is no way to say $thing->does(Num)

[21:48] <stevan_> which a BigInt would most likely do

[21:48] <stevan_> unless of course autobox was involved, and even then it gets very tricky

[21:49] <dduncan> fyi, for context, I made this as a utility for my database-implementing module: http://darrenduncan.net/QDRDBMS/GSTV.pm

[21:50] <stevan_> dduncan: a more pluggable type system for Moose is on the todo list

[21:50] <dduncan> in the process of doing that, I noticed that what it does is similar to what the Moose TypeConstraint is for

[21:50] <stevan_> not far below the performance enhancements and roles fixes

[21:50] <dduncan> basically provide a simple way to constrain the creation of a Perl scalar to within a particular domain

[21:51] <stevan_> yes, they looks very similar

[21:51] <stevan_> ideally I would like for people to be able to use thier favorite type-checking/validation modules for Moose type constraints

[21:51] <dduncan> I thought about explicitly checking for !ref, to ensure a built-in, but then thought to not assert !ref to give users more flexability

[21:51] <stevan_> Params::Validate comes to mind

[21:52] <stevan_> I think Alias has one out there too

[21:52] <stevan_> and you could certainly use this as well

[21:53] <dduncan> if I try using the input in a numeric context and it auto-coerces to what looks like a number, then presumably the user knows what they're doing ... more importantly, the user of my constraint-checked value can be confident that what they think is tested to be eg a number will in fact be useable like a built-in one

[21:53] <dduncan> now, a suggestion ...

[21:55] <dduncan> since newer Perls, 5.8 at least, have a distinct concept of SV strings being either characters or bytes, via the utf-8 flag ... I suggest that Moose have distinct Str and Blob TypeConstraints which check that the strings are being interpreted as desired

[21:55] <dduncan> because otherwise, bytes with the 8th bit set are ambiguous

[21:55] *** frost left
[21:56] <dduncan> if a string is not in character mode, and the 8th bit is set, and you try to use the string as a character, it may autocoerce using the wrong character set ...

[21:56] <stevan_> dduncan: well I am still trying to keep 5.6 support right now

[21:56] <stevan_> I might have to ditch that soon though, depending on the way the .pmc stuff works out

[21:56] <dduncan> probably latin1 or something ... and I personally like to use utf8

[21:57] <dduncan> so by having distinct Str and Blob constraints, we require users to have already explicitly disambiguated their data before we get it, so our users can then consider it unambiguous

[21:57] <stevan_> dduncan: its out my realm of expertise though, so if you want to supply a patch, I would be happy to apply it

[21:58] <dduncan> if the string is character mode, then we know the users already dealt with determining what character set it is

[21:58] <dduncan> the file I pointed you to already has the test I've been using ... you could lift it from there

[21:59] <dduncan> or since I don't use actual patches much, I can send you the text of the replacement/new functions and where they go, which you can manually insert

[21:59] <dduncan> they're very short, afaik

[22:03] <stevan_> dduncan: that works

[22:05] <stevan_> like I said, I wont be getting around to this until after the other two big items on the todo list

[22:06] <pasteling> "dduncan" at 24.69.53.198 pasted "revised Str and new Blob TypeConstraint for Moose" (9 lines, 303B) at http://sial.org/pbot/21219

[22:06] <dduncan> okay, see if that helps you

[22:06] <stevan_> and at that point it might actually make more sense for me to just write a plugin to use your module for type constraints instead :)

[22:08] <stevan_> so a Blob is a non-utf8 string?

[22:08] *** mako132_ joined
[22:09] <dduncan> you could, but the module of mine that I pointed you to is extremely simple, and meant mainly to help bootstrap my QDRDBMS framework under Perl ... and the framework is deprecated in favor of a Perl 6 version ... you should just copy any code you find useful

[22:09] <dduncan> a Blob is a byte-oriented string

[22:09] <dduncan> which is what you have if the utf8 flag is turned off on an SV

[22:10] <dduncan> afaik, byte-oriented is how Perl 5 works by default, such as when you've read in file data

[22:10] <dduncan> if you haven't done something like ...

[22:11] <dduncan> this first: binmode *main::STDIN,  ':utf8';

[22:11] <stevan_> ok

[22:11] <dduncan> if you did that, then the file input should be character-oriented

[22:11] <stevan_> I might switch the names a bit, since the default in p5 is closer to Blob then Str

[22:12] <stevan_> maybe Str and UnicodeStr

[22:12] <stevan_> something like that

[22:12] <dduncan> I used the names Blob and Str for bytes and chars because that is the meaning of the same-named Perl 6 types

[22:12] <dduncan> I was unsuccessful in getting character strs renamed to something more character-meaning like Text

[22:13] <dduncan> but at least Blob got added as a separate item

[22:13] *** jferrero joined
[22:13] <stevan_> cool, I have to run, but thanks for the patch :)

[22:13] <dduncan> still, you can name them what you think best ... the important thing is to have the 2 distinct types with their distinct character-mode vs byte-mode semantics

[22:14] *** larsen_ joined
[22:27] *** awwaiid joined
[22:27] *** perlbot joined
[22:29] <nothingmuch> dduncan: moose doesn't do any string operation s

[22:29] <nothingmuch> it should be as pass-through as possible

[22:30] <nothingmuch> or we risk interfering with existing code that is also pass-through

[22:30] <nothingmuch> and most perl 5 code is

[22:30] <nothingmuch> when it comes to utf8 strings

[22:32] <dduncan> the type constraint utilities are optional, and users only use them if they want those constraints

[22:32] <nothingmuch> yes, but Str means one thing to most perl users: either utf8 or a bytestring

[22:32] <dduncan> afaik, the "utf8" name is a misnomer ... it really means character-mode vs byte-mode

[22:33] <nothingmuch> by that rationale you can make a custom constraint pair, UnicodeString and Buf or something like that

[22:33] <nothingmuch> you know what i meant =/

[22:33] <dduncan> so you are saying that Moose's "Str" type should be the union of byte and char types? ...

[22:33] <dduncan> and have 2 new names to be constrained to one?

[22:34] <dduncan> if so, that's reasonable

[22:34] <nothingmuch> yes

[22:34] <nothingmuch> and that they should probably not be available by default to keep confusion down

[22:34] <dduncan> so then, I suggest naming them "Str", "Text", "Blob"

[22:34] <nothingmuch> people who actually need the distinction on that level are probably better off implementing them themselves

[22:35] <nothingmuch> because generally code bases like that tend to have at the very most one layer that actually does octet <-> character conversion

[22:35] *** spoop joined
[22:35] <dduncan> yes, but it is a best practice to include utilities for what users are going to write again and again when using your module

[22:35] <nothingmuch> and even then it's usually just pushed to PerlIO

[22:35] <nothingmuch> that's what I'm saying

[22:35] <nothingmuch> that 99% of the users won't write it even once

[22:35] <dduncan> well the addition I suggested doesn't actually do any character conversion, it just asserts whether the user already did that or not

[22:36] <dduncan> so users still do their own conversion

[22:36] <nothingmuch> i get that, that's not what I'm adressing

[22:36] <dduncan> I see my proposal of checking character/byte mode as being no different from distinguishing number-mode or int-mode from either

[22:37] <nothingmuch> it is a little different

[22:37] <dduncan> it is a natural fit, and no more complicated

[22:37] <nothingmuch> the reason it is that strings can be upgraded in place

[22:37] <nothingmuch> and that sometime non i18n aware code is used in i18n aware code

[22:37] <nothingmuch> and due to their isomorphism it Just Works

[22:37] <dduncan> the fact we assert Num or Int or whatever is that the user wants to treat a weak type as a strong type

[22:37] <nothingmuch> no

[22:38] <nothingmuch> there are things that are not Num, but only Int

[22:38] <nothingmuch> like indices

[22:38] <nothingmuch> or cardinal values

[22:38] <dduncan> yes

[22:38] <nothingmuch> that is not a "pass-through" in that sense

[22:38] <nothingmuch> Num vs. Int is like the difference between Str and \w+

[22:38] <dduncan> question ...

[22:40] <nothingmuch> ...?

[22:40] <dduncan> Perl 5's hash keys ... when you say "$hash{$scalar} = $something;", I know that $scalar is coerced to being defined and a string not a num, but is it coerced to byte or character mode?

[22:41] <nothingmuch> that depends

[22:41] <nothingmuch> if $scalar stringifies via overloading, then whatever that was

[22:41] <nothingmuch> if not, then it's a bytestring

[22:41] <nothingmuch> unless it already was a unicode string

[22:41] <dduncan> eg, if you stick a key in a hash that has a particular utf8 flag, will that flag be preserved when you use .keys?

[22:41] <nothingmuch> yes

[22:42] <nothingmuch> hash keys are not true scalars

[22:42] <nothingmuch> but they do know the utf8ness

[22:42] <nothingmuch> utf8 strings have a negative length

[22:42] <nothingmuch> IIRC

[22:42] <nothingmuch> of course, this is not exposed, just used internally to tell them apart within the specific table

[22:44] <nothingmuch> http://www.perl.com/pub/a/2000/12/p5pdigest/THISWEEK-20001210.html

[22:44] <dduncan> so if you say $hash{'Perl'} and $hash{'Perl'} where one of those strings has utf8 on and the other off, will they match?

[22:44] <lambdabot> Title: perl.com: This Week on p5p 2000/12/10, http://tinyurl.com/y4ojss

[22:44] <dduncan> s/Perl/<any arbitrary string>/

[22:45] <nothingmuch> that's a good question

[22:45] <dduncan> or not

[22:45] <nothingmuch> i'm not sure

[22:45] <nothingmuch> you can test it with use utf8;

[22:45] <dduncan> that's part of the crux of the matter

[22:45] <dduncan> in a strong typed system, 'Perl' with the flag on and 'Perl' with the flag off are distinct types

[22:45] <nothingmuch> for ascii it is the same

[22:45] <dduncan> distinct values I mean

[22:45] <nothingmuch> prolly

[22:46] <pasteling> "nothingmuch" at 84.108.53.74 pasted "utf8 test" (24 lines, 190B) at http://sial.org/pbot/21220

[22:47] <pasteling> "nothingmuch" at 84.108.53.74 pasted "output" (5 lines, 116B) at http://sial.org/pbot/21221

[22:47] <nothingmuch> pretty much what i expected

[22:47] <dduncan> fyi, the reason my example Str test that I passed Stevan checked for higher bits is, afaik, the "use utf8;" pragma of Perl 5 will only actually set the flag true for strings that contain non-ascii values

[22:47] <nothingmuch> if utf8 is required to represent the charstring then they are district

[22:47] <nothingmuch> distinct

[22:47] <nothingmuch> could be

[22:48] <nothingmuch> remember that perl will automatically upgrade non utf8 strings when they are e.g. concatenated with utf8 strings

[22:48] <anatolyv> dduncan: you can test with explicit utf8::upgrade etc.

[22:48] <dduncan> so "$foo = 'Perl'" will always have the flag off, even under the utf8 pragma ... I discovered this through working with it

[22:48] <nothingmuch> yes

[22:48] <nothingmuch> becasue that's how perl is

[22:49] <dduncan> nothingmuch, yes that upgrade will happen

[22:49] <nothingmuch> the conversion only happens when needed

[22:49] <anatolyv> dduncan: whether two hash keys with ascii values work the same w/ and w/o the utf-8 flag in them

[22:49] <avar> does p6 have $str[range] ?

[22:49] <nothingmuch> 0

[22:49] <nothingmuch> uj

[22:49] <nothingmuch> avar: yes, I believe that Str does Array

[22:49] <dduncan> but if a $str, say read from a file in byte mode, contains 8-bit latin1, it will be upgraded as such, even if the file is some other encoding ... hence the auto-upgrade did the wrong thing

[22:50] <nothingmuch> or that in fact Array of Char does Str ;-)

[22:50] <nothingmuch> dduncan: yes

[22:50] <dduncan> or should I say, the file contains 8-bit anything, it will be treated as latin1

[22:50] <avar> ?eval my $str = <abc>; $str[0]

[22:50] *** evalbot_r14767 is now known as evalbot_r14789

[22:50] <evalbot_r14789> \"abc"

[22:50] <nothingmuch> avar: that's an array ref in $str

[22:50] <dduncan> hence my Text-type flags 8-bit value input with the flag off as an error, since it is ambiguous, and a subsequent auto-upgrade may do the wrong thing

[22:51] <nothingmuch> ?eval my $str = 'abc'; $str[0]; # probably won't work

[22:51] <evalbot_r14789> \"abc"

[22:51] <nothingmuch> dduncan: what business is it of Moose's?

[22:51] <anatolyv> ?eval my $str=<abc>; $str[0..1]="12"; $str;

[22:51] <evalbot_r14789> Error: Can't modify constant item: VStr "abc"

[22:51] <anatolyv> doesn't do Array then

[22:51] <nothingmuch> not yet anyway

[22:51] <anatolyv> just does post_circumfix:<[ ]>

[22:52] <nothingmuch> anatolyv: bot not DWIM

[22:52] <nothingmuch> dduncan: my original point was that a system typically implemented in moose, a reusable one, will take strings of any type

[22:52] <nothingmuch> and maybe combine them, or process them, or whatever

[22:52] <nothingmuch> and emit back strings of the same type

[22:52] <anatolyv> nothingmuch: don't think it should, Str is immutable.

[22:52] <dduncan> I brought up this business for Moose because the problem I was addressing seemed generic to any Perl program that deals with text, and since Moose had a default set of type constraints, I felt the distinction would do well to be included for the benefit of all Moose users

[22:53] <nothingmuch> that's how perl's utf8 was plugged in

[22:53] <nothingmuch> most code ignores the distinction, and subsequently Just Works

[22:53] *** BooK joined
[22:53] <nothingmuch> and for code where that distinction is needed, code that does the actual IO or the layer right after it, precooked things are typically just not clear enough

[22:54] <dduncan> yes, but having it in Moose adds extra sanity checks, in case the user forgot to do the right thing at IO time

[22:54] <nothingmuch> returning to my original conjecture that when this is an issue it is typically not handled by moose type constrains

[22:54] <nothingmuch> but *why*?

[22:54] <nothingmuch> consider a user class

[22:54] <dduncan> I still see the matter as being analagous to the difference between characters and numbers ... even if you don't

[22:54] <nothingmuch> package User; has name => ( isa => "..." ); # which is correct here?

[22:55] <nothingmuch> i think you just haven't dealt with utf8 strings in practice enough

[22:55] <dduncan> names are characters

[22:55] <nothingmuch> sorry, bullshit

[22:55] <nothingmuch> because 99% of the strings that will be fed to it won't be unicode aware

[22:55] <nothingmuch> it's not a perfect world =(

[22:55] <dduncan> the world not being perfect is a red herring

[22:56] <nothingmuch> in fact, typically youc an give it a utf8 bytestring, and it will *still* work correctly

[22:56] <nothingmuch> because unless you:

[22:56] <nothingmuch> substring

[22:56] <nothingmuch> use length()

[22:56] <nothingmuch> use regexes

[22:56] <nothingmuch> there's no real difference

[22:56] <nothingmuch> and because there is no real difference on that level barely any code makes that distinction

[22:56] <nothingmuch> and hence code that enforces this check will simply not play well with others

[22:57] <nothingmuch> and confuse the hell out of any user who isn't used to i18n

[22:57] <dduncan> generally, byte mode is appropriate for binary data like random files, or image or sound data etc ... character mode is for text, including people's names, addresses, descriptions, etc

[22:57] <nothingmuch> i know, i know

[22:57] <nothingmuch> remember that I'm not a native english speaker

[22:57] <nothingmuch> hebrew is one of the languages with the most crappy encodings in existence

[22:57] <dduncan> and character mode is encoding-agnostic

[22:57] <nothingmuch> i know

[22:57] <nothingmuch> but IO isn't

[22:58] <dduncan> well thats a separate issue

[22:58] <nothingmuch> and 99% of the time even if it was supposed to be character mode

[22:58] <nothingmuch> and even if it is non ascii

[22:58] <nothingmuch> it won't be

[22:58] <dduncan> in any event, I already agreed with having separate Str, Text, Blob

[22:58] <nothingmuch> that's just how it is

[22:58] <nothingmuch> you don't get it =(

[22:58] <nothingmuch> putting that in moose is just adding 2 more types

[22:58] <nothingmuch> that most users don't know the difference between

[22:59] <nothingmuch> and that almost all users will never actually need to distinguish

[22:59] <dduncan> and for those that do, more power to them

[22:59] <nothingmuch> and more docs

[22:59] <nothingmuch> and more  confusion

[22:59] <nothingmuch> and more subtle bugs

[22:59] <nothingmuch> it's overengineering

[23:00] <dduncan> well, if you believe strongly in doing things a certain way, more power to you ... and if you're a Moose developer, it will probably be done your way too ... so be it

[23:00] <nothingmuch> you're still missing the point, sorry =(

[23:01] <dduncan> in any event, my continued work in Perl 5 is deprecated until I can work in Perl 6 full time, at which time all of this will be moot

[23:01] <dduncan> for me

[23:01] <nothingmuch> fair enough

[23:01] <dduncan> fyi, my Perl 5 framework is named "Quick and Dirty ..." on purpose, because it is only meant to be a stand-in for people to use until the Perl 6 version is ready

[23:02] <nothingmuch> perl 6 won't be quirk free

[23:02] <nothingmuch> it's only a matter of time

[23:02] <dduncan> so I'm just making something that works for a DBMS now, and for that task, stronger distinguishing for data types is important

[23:03] <nothingmuch> i'm nto saying the distinction is wrong

[23:03] <nothingmuch> but not every user writes a DBMS support layer

[23:03] <nothingmuch> that worries about string representations

[23:03] <dduncan> yes

[23:03] * dduncan well, back to work

[23:04] <nothingmuch> enjoy

[23:05] <dduncan> P.S. If stevan hasn't read our exchange, you may want to talk him out of using what I sent him

[23:06] <nothingmuch> he asked me what my opinion was, so i came here to make some noise ;-)

[23:06] <dduncan> if he hasn't already decided the same as you by himself

[23:06] <nothingmuch> btw, for what it's worth I do think a MooseX::MoreConstraints or somesuch module could contain this and more

[23:07] <nothingmuch> that way it's reusable, but not adding more conceptual bloat to the core dist

[23:16] <dduncan> fyi, one thing I got out of this exercise is that I think I will make exceptions when otherwise naming my basic data types after semantically-same Perl 6 types ... in this case, I will not name my character-only type 'Str', and instead call it 'Text'

[23:17] <dduncan> so I won't have a Str type at all, and that should lessen confusion of users

[23:18] <nothingmuch> probably

[23:18] <nothingmuch> especially for a db related system

[23:18] <nothingmuch> where text and blob are the conventions

[23:18] <dduncan> yes

[23:19] * nothingmuch is omnigraffling

[23:19] <nothingmuch> DEMOLIS HALL

[23:21] *** sweinig is now known as sweinig|food

[23:27] <dduncan> okay, so now http://darrenduncan.net/QDRDBMS/GSTV.pm uses 'Text' rather than 'Str'

[23:28] <nothingmuch> btw, no need to

[23:28] <nothingmuch> $v = '' . $v;

[23:28] <nothingmuch> a. dual values are legal

[23:28] <nothingmuch> b. there's no way to tell except with PvOK

[23:28] <dduncan> okay, I'll remove those then

[23:29] <dduncan> but the 0 + elsewhere is okay?

[23:29] <nothingmuch> if you want to force numification that will actually do something, yes

[23:29] <nothingmuch> but perhaps Scalar::Util::looks_like_number is better

[23:29] <dduncan> I already use that

[23:29] <nothingmuch> ah

[23:30] <nothingmuch> then it's not really useful

[23:30] <nothingmuch> if you just use it as a number, which you do later (in the int) then perl will cache the numified version IIRC

[23:30] <dduncan> but I thought the 0+ would eliminate bounding whitespace and such, unless looks_like already fails stuff with spaces

[23:30] <nothingmuch> it doesn't

[23:30] <nothingmuch> and yes, that will take care of the spaces, etc

[23:30] <nothingmuch> $v += 0; # more concise though

[23:31] <dduncan> sure

[23:32] <dduncan> okay, those changes are applied, thank you

[23:35] <dduncan> fyi, the other reason to force numification is that so any subsequent use as a string will see a canonical string

[23:35] <dduncan> eg, we don't get '0' or '0.0' etc

[23:36] <dduncan> similarly, by Bool constructor canonicalizes the input

[23:36] <dduncan> s/by/my/

[23:37] <dduncan> subsequently, doing string equality tests on any of my 5 data types will always DWIM

[23:38] <dduncan> if I was inclined to use the same operator for all types like it was a generic comparator

[23:48] *** eggzeck joined
