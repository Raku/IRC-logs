[00:10] <TimToady> Actually, it's just Weird Al...

[00:27] *** Khisanth joined
[00:29] <cognominal> @a = < a b >; @b = << foo@a >>; # what do I get here?   is this equivalent to:  @b = < fooa foob > ?

[00:30] <cognominal> ?eval  @a = < a b >; @b = << foo@a >>;

[00:30] <evalbot_10184> Error: Undeclared variable: "@a"

[00:31] <cognominal> ?eval  my @a = < a b >;  my @b = << foo@a >>;

[00:31] <evalbot_10184> ["foo\@a",]

[00:31] <particle_> :)

[00:31] <cognominal> ?eval  my $a = 'a';  my @b = << foo$a >>;

[00:31] <evalbot_10184> ["fooa",]

[00:35] *** OutThere joined
[00:35] *** OutThere is now known as SubStack

[00:40] <TimToady> ?eval  my @a = < a b >;  my @b = << foo@a[] >>;

[00:40] <evalbot_10184> ["fooa", "b"]

[00:40] <TimToady> that looks about right to me.

[00:41] <cognominal> so that's a simple string interpolation

[00:41] <TimToady> no implicit hyperops there...

[00:41] <cognominal> :)

[00:42] <particle_> will perl6 users want and expect -0.0, or can 0.0 be the sole floating point zero value?

[00:43] <TimToady> looks like a hardware dependency to me...

[00:43] <TimToady> what does IEEE say?

[00:43] <particle_> well, IEEE754 specifies both

[00:43] <TimToady> AND or OR?

[00:44] <particle_> AND, iirc

[00:44] <particle_> i expect parrot will differ from 754 a bit, as does java

[00:45] <TimToady> One should attempt convergence where performance is not terribly impacted...

[00:45] <particle_> for example, user selectable rounding modes when converting from float to int

[00:46] <TimToady> user-selectable in which scope?

[00:46] <TimToady> such a thing should generally be lexically scoped in Perl 6 if possible.

[00:46] <particle_> good question. i'll have to look closely at the spec

[00:47] <TimToady> "magical rounding at a distance..." :/

[00:47] <particle_> rounding modes include up, down, or towards zero

[00:47] <TimToady> and a bazillion other options...

[00:47] <particle_> well, the ieee rounding modes

[00:50] <particle_> right now, parrot numbers are stringified in a hardware-specific manner

[00:50] <particle_> that's a problem.

[00:51] <particle_> we need to decide on what the representations are

[00:51] <particle_> and if, how & where we're diverging from ieee

[00:52] <particle_> -0.0 being the only real number i'm opposed to

[00:52] <particle_> however, it's used in a limited capacity, for instance meteorologists round small negative temperatures to -0.0

[00:53] <TimToady> Is that how IEEE distinguishes negative underflow from positive?

[00:53] <particle_> it's a side-effect of the representation, that the value happens to exist

[00:53] <particle_> since there's a signbit

[00:55] <particle_> if perl doesn't care, then i'll bother somebody whose language does care :)

[01:06] *** justatheory joined
[01:24] <svnbot6> r10206 | audreyt++ | * Makefile.PL: Support for arbitrary GHC probed from outside PATH in building third-party dependencies.

[01:26] <szbalint> morning? :)

[01:27] <TimToady> audreyt: I think t/builtins/lists/empty_list_in_map.t is failing because { () } looks like a 0-ary closure to the map rather than 1-ary.  Changing to -> $_ { () } makes it work.

[01:27] <TimToady> well, all, but the { undef } one...

[01:32] <TimToady> decommuting &

[01:35] *** rawr joined
[01:37] *** rawr is now known as SubStack

[01:37] <FurnaceBoy> 	<particle_>	i expect parrot will differ from 754 a bit, as does java

[01:37] <FurnaceBoy> that's an understatement :-) http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf (Kahan) How Java's Floating-Point Hurts Everyone Everywhere

[01:38] <FurnaceBoy> more IEEE754 links @ http://www.sonic.net/~jddarcy/Borneo/

[01:45] <particle_> thx

[01:56] *** jserv-- joined
[01:57] *** mako132_ joined
[02:05] <FurnaceBoy> yw

[02:09] *** kanru joined
[02:11] *** reZo joined
[02:31] *** schneiker joined
[02:37] *** schneiker left
[02:37] *** schneiker joined
[02:38] <FurnaceBoy> ola schneiker

[02:38] <FurnaceBoy> any response?

[02:40] *** EdLin joined
[02:41] <schneiker> FurnaceBoy: Greetings. Didn't see anything yet.

[02:46] <schneiker> William Kahan is pretty amazing--brilliant pit bull. I met him at IEEE754 meetings.

[02:46] <schneiker> (I was one of people representing Nat. Semi's at the time.)

[02:48] *** EdLin left
[02:58] *** aufrank joined
[03:00] *** weinig is now known as weinig|sleep

[03:02] <lisppaste3> aufrank pasted "build error on osx 10.3.9 with ghc 6.4.1" at http://paste.lisp.org/display/19602

[03:05] <aufrank> it builds fine once I do the ranlib on both of the haskell libraries

[03:05] <FurnaceBoy> yeah, I spent some time on his site a while back. most impressive.

[03:08] <schneiker> s/Nat. Semi's/Natl. Semi./

[03:08] <schneiker> FurnaceBoy: Just discovered email reply from earlier perl.org inquiry.

[03:08] <schneiker> (The perl.* groups are gated via a mail2news gateway from the perl.org

[03:08] <schneiker> mailing lists.  They're carried by many, but not all, USENET news

[03:08] <schneiker> servers, including google groups.  They are carried by my DSL

[03:08] <schneiker> provider, AT&T.)

[03:08] <schneiker> My news server doesn't carry perl.perl6.*, which is why G.Group

[03:08] <schneiker> restriction was a suprise to me.

[03:12] <obra> schneiker: you're really talking about a perl6-something mailinglist

[03:12] <obra> perl.org admins have your request in hand.

[03:13] <obra> the last time we talked about it, there was a little bit of a concern that a "perl6 newbies" list was premature.

[03:20] <schneiker> obra: Didn't realize inquiry was a request, so that's good news.

[03:20] <schneiker> What level newbies? Folks interested in p5 to p6 or total perl newbies?

[03:20] <schneiker> Any especially noteworthy concens?

[03:22] *** kanru joined
[03:22] *** FurnaceBoy_ joined
[03:23] <obra> *laugh*

[03:23] <obra> it certainly got escalated to a request ;)

[03:24] <obra> So, I guess the basic concern was that "total newbies" might get suckered into diving into p6 before it was really ready

[03:24] <obra> But I think more input is useful.

[03:28] <schneiker> Maybe:

[03:28] <schneiker>     perl.perl6.pre-alpha.general?

[03:28] <schneiker>     perl.perl6.early-proto.general?

[03:28] <schneiker> (or .misc)

[03:29] <lisppaste3> aufrank pasted "make install error on osx 10.3.9 with ghc 6.4.1" at http://paste.lisp.org/display/19603

[03:30] <aufrank> the install still seems to run fine, despite the error above

[03:42] <obra> schneiker: it might be worth reusing an existing list

[03:45] *** fglock joined
[03:49] *** drbean_ joined
[03:51] <schneiker> obra, Good idea. Specific suggestions?

[03:51] <schneiker> "perl.perl6.meta" seems closest approximation to a *6.general or *6.misc.

[03:51] <schneiker> That would be fine with me.

[03:51] <schneiker> I'm looking at list on (http://www.nntp.perl.org/group/).

[03:51] *** Quell joined
[03:52] <obra> looking

[03:52] <obra> basically, do the audrey thing and just start taking over something existing

[03:53] <obra> . o O  {http://www.nntp.perl.org/group/perl.perl6.language.flow}

[03:53] <obra> meta is good

[03:57] <schneiker> OK. What does it take to get into Google Groups (like other 4 perl.perl6.* groups)?

[03:57] <svnbot6> r10207 | Darren_Duncan++ | ext/Locale-KeyedText/ : added export_as_hash() methods to KeyedText.pm ; changed module version to 1.73.0 from 1.72.2, corres to p5v CPAN release

[04:07] <obra> I bet "start to post to it"

[04:10] <schneiker> OK, will try. (But I didn't see any GG archives for other *perl6* groups besides current 4.)

[04:10] <obra> robrt works for perl6 now.

[04:10] <obra> er

[04:10] <obra> for google

[04:11] <obra> I bet we can get it fixed fast once we're using it

[04:11] <schneiker> OK, thanks.

[04:23] *** cognominal joined
[04:27] <svnbot6> r10208 | audreyt++ | * unTODO now-passing pairs.t tests

[04:27] <svnbot6> r10209 | audreyt++ | * unTODO: Hash attributes no longer crahes the parser

[04:31] *** cognominal joined
[04:32] *** kanru joined
[04:39] *** cognominal joined
[04:48] *** qu1j0t3 joined
[04:48] *** Ymmv joined
[04:49] *** cognominal joined
[04:53] *** cognominal joined
[04:58] <aufrank> audreyt: ping?

[04:59] <aufrank> ?eval for 1..3 -> $x { say $x }

[04:59] <evalbot_10184> OUTPUT[1 2 3 ] undef

[05:02] <aufrank> ?eval my $x = 'a';  $x ~~ / a b c /;

[05:02] <evalbot_10184> *** Cannot parse PGE:  a b c  *** Error: Cannot find the parrot executable in PATH Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} )

[05:03] <aufrank> ?eval my $x = 'a';  $x ~~ m/ a b c /;

[05:03] <evalbot_10184> *** Cannot parse PGE:  a b c  *** Error: Cannot find the parrot executable in PATH Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} )

[05:27] *** Quell joined
[05:33] *** fglock left
[05:52] *** aufrank joined
[06:04] <aufrank> ?eval %hash<foo> = 1; %hash<food> = 1; %hash<foosball> = 1;  $x = 'fo'; $x ~~ / %hash /;

[06:04] <evalbot_10184> Error: Undeclared variable: "%hash"

[06:05] <aufrank> ?eval my %hash = { 'foo' => 1, 'food' => 1, 'foosball' => 1 }; my $x = 'fo'; $x ~~ / %hash /;

[06:06] <evalbot_10184> *** Cannot parse PGE:  %hash  *** Error: Cannot find the parrot executable in PATH Match.new(   ok => bool::false,    from => 0,    to => 0,    str => "",    sub_pos => (),    sub_named => {} )

[06:13] *** FurnaceBoy joined
[06:25] *** kanru joined
[06:31] *** drrho joined
[06:41] <gaal> one of the js backends seems to've broke:

[06:41] <gaal> lib6/Prelude/JS/Operators.pm

[06:42] <gaal> gives an error at the end of 'make'

[06:43] *** trampel joined
[06:46] <svnbot6> r10210 | audreyt++ | * Block-comma-list fix for PIL2JS reported by gaal++

[06:47] *** KingDiamond joined
[06:55] *** iblechbot joined
[07:07] *** H5N1 left
[07:09] <schneiker> obra: Did 2 posts to perl.perl6.meta, but nothing came back yet.

[07:09] <schneiker> Did 2 posts with 2 different newsreaders to nntp.perl.org.

[07:09] <schneiker> Sent email to Ask Bjørn Hansen (shown as nntp site owner) about it.

[07:13] <schneiker> (line 2) s/Did 2/Did above 2/

[07:13] <schneiker> &

[07:14] *** schneiker left
[07:31] *** ghenry joined
[07:41] *** kanru joined
[08:04] *** marmic joined
[08:08] *** f0rth joined
[08:28] *** chris2 joined
[08:47] *** vytautas joined
[08:48] *** Odin-LAP joined
[08:55] *** pdcawley joined
[08:58] <xinming> audreyt: ping

[08:58] *** nnunley joined
[09:03] *** nnunley joined
[09:27] *** xinming joined
[09:46] *** penk joined
[10:54] *** iblechbot joined
[10:56] *** NEURAL_PHANTOM joined
[10:56] <NEURAL_PHANTOM> hello any one on

[10:57] <xinming> hi

[10:58] <NEURAL_PHANTOM> hello

[10:58] <NEURAL_PHANTOM> i need some help

[10:58] <NEURAL_PHANTOM> think mind if i pm

[10:59] <xinming> hmm, if it is perl 6 or pugs related question... just ask

[10:59] <azuroth> help with what?

[10:59] <NEURAL_PHANTOM> dmake

[10:59] <NEURAL_PHANTOM> and setting it up on a xp box

[11:00] * xinming can't be helpful... xinming hides...

[11:00] <azuroth> what's going wrong?

[11:00] <NEURAL_PHANTOM> well i get an error when i try the dmake test command

[11:01] <NEURAL_PHANTOM> this is the error "Error code 1, while making 'perlglob.o'"

[11:03] <NEURAL_PHANTOM> 'gcc' is not recognized as an internal or external command,

[11:03] <NEURAL_PHANTOM> operable program or batch file.

[11:03] *** TimToady joined
[11:03] <NEURAL_PHANTOM> I have minGW with all updates

[11:03] <NEURAL_PHANTOM> not sure what to do

[11:03] <azuroth> hmm, ok. is gcc in the path?

[11:04] <NEURAL_PHANTOM> CChmome path

[11:04] <NEURAL_PHANTOM> ?

[11:05] <azuroth> hmm, I couldn't say

[11:05] <NEURAL_PHANTOM> mind if i pm

[11:05] <azuroth> if you just run 'gcc' from the term, does it work?

[11:05] <azuroth> sure

[11:10] <azuroth> is "nyet problimski" real russian?

[11:10] <mtve> nope

[11:10] <azuroth> damn. but it sounds so cool

[11:13] *** elmex joined
[11:14] *** kanru joined
[11:24] <NEURAL_PHANTOM> azuroth

[11:24] <azuroth> yo

[11:24] <azuroth> you didn't pm me?

[11:25] <NEURAL_PHANTOM> i found where the gcc.exe is stored and when i go to that dir and execuite it, it runs

[11:25] <NEURAL_PHANTOM> says i cant need to reg

[11:25] <azuroth> oh ok, cool

[11:25] <azuroth> to register..?

[11:25] <NEURAL_PHANTOM> my nick

[11:25] <azuroth> oh

[11:25] <azuroth> right

[11:25] <NEURAL_PHANTOM> one sec and ill reg

[11:26] <azuroth> well, if you need to be in gcc's dir to execute it, so would nmake. so you'll have to add that directory to the path

[11:26] <azuroth> so it can be run from anywhere

[11:27] <azuroth> maybe you should just join #nmake_np, so we don't flood the channel with this crap

[11:29] <NEURAL_PHANTOM> ok in chan

[11:46] <azuroth> ?eval my $x = 5; my $x; say $x;

[11:46] <evalbot_10184> OUTPUT[ ] bool::true

[11:46] <azuroth> ?eval my $x = 5; my $x = 5; say $x;

[11:47] <evalbot_10184> OUTPUT[5 ] bool::true

[11:47] <azuroth> hm, I have a feeling that's wrong?

[11:47] <azuroth> 'if you declare a lexical twice in the same scope, it is the same lexical' ... oh, I guess that doesn't mean anything about my's initialisation behaviour

[11:48] <azuroth> ?eval my $x = 5; my $r = \$x; my $x = 2; say $x; say $$r;

[11:48] <evalbot_10184> OUTPUT[2 5 ] bool::true

[11:48] <azuroth> if I wasn't spineless, I would probably commit a test

[11:51] * broquaint notes Data::Bind's similarities to Params::Named ...

[11:52] *** wilx`` joined
[11:55] <azuroth> ?eval my ($a, $b, $c) >>=<< 5; say $b;

[11:55] <evalbot_10184> Error:  unexpected ">" expecting comment, trait, "=", ".=", ":=", "::=", ";" or end of input

[11:56] <azuroth> :-(

[11:57] <avar> ?eval my ($a, $b, $c); ($a, $b, $c) »= 5; say $b;

[11:57] <evalbot_10184> Error:  unexpected "\\" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[11:57] <avar> ?eval my ($a, $b, $c); ($a, $b, $c) »=« 5; say $b;

[11:57] <azuroth> isn't it hyper on both sides?

[11:57] <evalbot_10184> Error:  unexpected "\\" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[11:58] <azuroth> ?eval my ($a, $b); ($a, $b) >>=<< 5; say $b;

[11:58] <evalbot_10184> Error:  unexpected ">" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[11:58] <azuroth> ?eval my @a; @a >>=<< 5; say @a;

[11:58] *** FurnaceBoy joined
[11:58] <evalbot_10184> Error:  unexpected ">" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[11:59] <azuroth> ?eval my @a; @a = @a >>+<< 5; say @a;

[11:59] <evalbot_10184> OUTPUT[ ] bool::true

[11:59] <azuroth> hm, ok then..

[11:59] <azuroth> ?eval my @a; @a =<< 5; say @a;

[11:59] <evalbot_10184> Error:  unexpected end of input expecting block, "\\", "$/", "$!", ">>" or "<<"

[12:00] <avar> ?eval my @a; @a = @a >>+<< 5; say @a[0];

[12:00] <evalbot_10184> OUTPUT[ ] bool::true

[12:00] <azuroth> ?eval my @a = (1,2,3); @a = @a >>+<< 5; say @a;

[12:00] <evalbot_10184> OUTPUT[678 ] bool::true

[12:02] *** jsiracusa joined
[12:04] <azuroth> ?eval while my $x = 1 { last } $x # should there be a semicolon there, or is this voodoo?

[12:04] <evalbot_10184> Error: No such method in class Any: "&my"

[12:04] <azuroth> ?eval while my $x = 1 { last }; $x # should there be a semicolon there, or is this voodoo?

[12:04] <evalbot_10184> Error: No such method in class Any: "&my"

[12:05] <azuroth> ?eval my ($a, $b, $c) = 5; say $a; say $b;

[12:05] <evalbot_10184> OUTPUT[5  ] bool::true

[12:15] *** wilx`` is now known as wilx

[12:16] *** kane_ joined
[12:22] <audreyt> azuroth: that is voodoo -- $x = 1 {last} shouldn't even parse

[12:24] <audreyt> (sorry for the absence; $job went a bit crazy today (and likely tomorrow))

[12:24] <audreyt> ...and the part of "port GHC to AIX 4.3" is certainly among the craziest

[12:27] <azuroth> ahh, ok

[12:29] <azuroth> should there be an equals hyperop, or ?  is any 'op' able to be hyper'ed?

[12:31] <audreyt> any "op" theoretically allows hyper'ing

[12:31] *** kolibrie joined
[12:31] <azuroth> ah ok, cool

[12:33] <azuroth> ?eval { my $x = 5; my $r = \$x; my $x = 2; say $x; say $$r; } # I have a feeling this should print 2 and 2, but I could be interpreting the synopses wrong..

[12:33] <evalbot_10184> OUTPUT[2 5 ] bool::true

[12:34] <audreyt> no, your interp is totally correct

[12:34] <audreyt> double-my in pugs currently is not noop

[12:34] <audreyt> that is certainly a bug.

[12:34] <audreyt> write a test?

[12:34] *** iblechbot joined
[12:34] <azuroth> sure will - in t/builtins/my.t?

[12:34] <audreyt> sure

[12:38] <azuroth> I was unsure whether the second my should say, 'zero' it to undef though. I guess not, though.

[12:38] *** lichtkind joined
[12:38] <audreyt> no, it should be noop.

[12:42] <svnbot6> r10211 | azuroth++ | added test for two 'my' decls in same scope

[12:43] <azuroth> what's the justification behind double-mys anyway, do you know?

[12:43] <lichtkind> sorry where are the synopses ? http://svn.openfoundry.org/pugs/docs/Perl6/

[12:44] <azuroth> http://dev.perl.org/perl6/doc/synopsis.html these ones are pod2htmlified daily, I think

[12:44] <lichtkind> i mean in svn i found some quirks

[12:45] <azuroth> oh, sorry

[12:45] <lichtkind> and wanted look if its already fized

[12:45] <audreyt> http://svn.perl.org/perl6/doc/trunk/design/syn

[12:45] <lichtkind> in s6 the pipe operator has written ==> ans <==

[12:46] <lichtkind> thanks

[12:46] <audreyt> what's wrong with <== and ==>?

[12:47] <lichtkind> so far i read s03 they are spelled ===>

[12:47] <Gothmog_> azuroth: I think you made a typo... don't you mean $f = 5 instead of $a = 5?

[12:47] <xinming> rinary ? : becomes ?? !!. It is a syntax error to use an operator in the middle that binds looser in precedence, such as =

[12:47] <xinming> any example?

[12:47] <xinming> trinary*

[12:47] <azuroth> argh!

[12:48] <lichtkind> audreyt or you can use both?

[12:48] <audreyt> er no, ===> is not an operator

[12:49] <audreyt> fixed.

[12:49] *** stennie joined
[12:50] <audreyt> lichtkind: I've fixed S03; where it reads ===> it should just be "#"

[12:50] <svnbot6> r10212 | azuroth++ | typo in last commit; Gothmog++

[12:50] <lichtkind> audreyt ok thanks

[12:51] <audreyt> thank _you_ :)

[12:52] <azuroth> hmm, sorry if this is a stupid question, but why do zip and each use semicolons instead of commas to separate args?

[12:52] <audreyt> because

[12:52] <audreyt> zip(1,2,3;4,5,6)

[12:53] <azuroth> ahh

[12:53] <audreyt> it's like

[12:53] <audreyt> zip <== 1,2,3 <== 4,5,6

[12:53] <audreyt> two pipe batches

[12:54] <azuroth> would zip's signature be an is parsed, or is possible to use semicolons always?

[12:55] *** KingDiamond joined
[12:55] <audreyt> it is always possible.

[12:56] <audreyt> see S06, Multidimensional argument

[12:57] <azuroth> ahh, cool

[13:04] *** fglock joined
[13:08] <azuroth> off to bed, good night all!

[13:08] <svnbot6> r10213 | fglock++ | docs/notes - added more details to generator/lazy array

[13:09] <fglock> re SoC: how about implementing lazy array in parrot?

[13:10] *** weinig|sleep joined
[13:11] <audreyt> fglock: that'd be nice

[13:11] <audreyt> parrot doesn't yet have general-purpose generators

[13:11] <audreyt> nor "Range"

[13:12] <audreyt> I wonder if there is a good C library somewhere that we can just link with, though.

[13:13] <fglock> audreyt: will look

[13:19] *** Qiang joined
[13:24] *** cdpruden joined
[13:27] <audreyt> zzz &

[13:29] <fglock> audreyt: http://www.sgi.com/tech/stl/char_producer.html

[13:29] *** Limbic_Region joined
[13:33] <aufrank> good morning!

[13:33] <aufrank> have to go to work, biab &

[13:34] <wolverian> fglock, hm, ropes seem interesting. thanks

[13:38] *** Ymmv joined
[13:40] <fglock> wolverian: I'm checking if there are reusable libraries for lazy arrays - or if it makes sense to write one

[13:51] *** jserv-- joined
[13:52] *** macroron__ joined
[13:52] <clkao> mi/win 24

[13:57] *** pdcawley joined
[13:58] *** vel joined
[14:03] *** dvorak joined
[14:03] *** kanru joined
[14:05] *** justatheory joined
[14:07] *** particle_ joined
[14:11] *** aufrank joined
[14:12] <aufrank> can someone explain the difference between m{ foo (bar) baz } and m{ foo <(bar)> baz } to me?

[14:13] *** flounder99 joined
[14:16] <flounder99> what is reverse suposed to do to a hash in p6?

[14:17] <flounder99> ?eval my %h=(1,2,3,4);%h=reverse %h;%h{1}.say;

[14:17] <fglock> aufrank: the first match stringifies to "foobarbaz", the second stringifies to "bar"

[14:17] <evalbot_10184> OUTPUT[2 ] bool::true

[14:18] <flounder99> ?eval my %h=(1,2,3,4);%h=zip %h.values,%h.keys;%h{2}.say;

[14:18] <evalbot_10184> OUTPUT[1 ] bool::true

[14:18] <aufrank> and $/[0] is 'bar' in both cases?

[14:18] <fglock> aufrank: I think so

[14:19] <aufrank> ?eval my $x = 'bar';  my $y = $x ~~ / foo (bar) baz /; say $x; say $y; $say $/[0];

[14:19] <evalbot_10184> Error:  unexpected "$" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[14:19] <flounder99> I couldn't find anything in the synopses about reverse on a hash

[14:20] <aufrank> flounder99: I don't know the answer to this one

[14:20] <aufrank> ?eval my $x = 'bar';  my $y = $x ~~ / foo <(bar)> baz /; say $x; say $y; $say $/[0];

[14:20] <evalbot_10184> Error:  unexpected "$" expecting comment, operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input

[14:20] <particle_> flounder99: what would you expect reverse to do?

[14:21] <aufrank> fglock: did I mess something up in those?

[14:21] <fglock> aufrank: but maybe not - S05 states: "other captures (named or numbered) are unaffected"

[14:22] * aufrank is reading S05 now :)

[14:22] <fglock> ?eval my $x = 'bar';  my $y = $x ~~ / foo (bar) baz /; say $x; say $y; say $/[0];

[14:23] <evalbot_10184> *** Cannot parse PGE:  foo (bar) baz  *** Error: Cannot find the parrot executable in PATH OUTPUT[bar   ] bool::true

[14:23] <fglock> aufrank: s/$say/say/

[14:23] <aufrank> heh

[14:23] <aufrank> funny

[14:24] <flounder99> swap the keys and values like in p5. Actually I think P5 flattens it into a list and reverses the list which has the effect of  reversing the keys and values. Except of course duped values.

[14:24] <flounder99> where the last key based on the hash algorithm wins

[14:25] <particle_> well, now a hash is a set of pairs

[14:25] <particle_> if you want to get p5 semantics, i think you'll have to reverse the pairs

[14:26] <flounder99>  %h = zip %h.values, %h.keys

[14:26] <particle_> i don't know syntax well enough, but something like %hash.each.reverse might work

[14:28] <flounder99> %h.kv.reverse seems to work

[14:28] <particle_> good news :)

[14:29] <flounder99> ?eval my %h=(,1,2,3,4);%h=%h.kv.reverse;%h.say;

[14:30] <evalbot_10184> Error:  unexpected "," expecting comment, expression or ")"

[14:30] <flounder99> ?eval my %h=(1,2,3,4);%h=%h.kv.reverse;%h.say;

[14:30] <evalbot_10184> OUTPUT[2	14	3 ] bool::true

[14:30] <flounder99> oops, fat finger

[14:31] <particle_> that deserves to be an example in a synopsis, if it's not already.

[14:33] <flounder99> I didn't see it -- but I don't have them memorized.

[14:33] *** orafu joined
[14:34] <aufrank> there's no kv.reverse in the syns

[14:36] <flounder99> I think TimToady should rule if the current pugs implementation is right or if it should act like P5.

[14:36] <particle_> reversing a hash is a common p5 op, it warrants an example. dunno if it belongs in the synopses

[14:37] <flounder99> I do it now and then in P5

[14:37] <aufrank> ?eval my $x = 'b'; my $y = $x ~~ / (a) <( b )> c /; say $x; say $y; say $/[0]; say $/[1];

[14:37] <evalbot_10184> *** Cannot parse PGE:  (a) <( b )> c  *** Error: Cannot find the parrot executable in PATH OUTPUT[b    ] bool::true

[14:39] <flounder99> ?eval my %h=(1,2,3,2);%h=%h.kv.reverse;%h.say;

[14:39] <evalbot_10184> OUTPUT[2	1 ] bool::true

[14:40] <fglock> ?eval my %h=(1,2,3,2);%h=%h.kv.reverse;

[14:40] <evalbot_10184> {("2" => "1"),}

[14:42] <flounder99> I get the same in P5

[14:49] <flounder99> I see reversing an array of pairs doe not reverse the pairs themselves

[14:49] <flounder99> ?eval my @a=(1=>2,3=>4);@a.reverse.say

[14:49] <evalbot_10184> OUTPUT[3	41	2 ] bool::true

[14:50] <flounder99> It reverses the order of the pairs in the array not the elements of the pairs

[14:51] <flounder99> I have to think of => as something other than a left stringifying comma

[14:54] <flounder99> ?eval my @a=("1",2,"3",4);@a.reverse.say

[14:54] <evalbot_10184> OUTPUT[4321 ] bool::true

[14:56] <flounder99> Toto, I don't think we're in Perl5 land anymore

[15:02] *** avarab joined
[15:04] *** vel joined
[15:09] *** Arathorn joined
[15:17] *** vel joined
[15:21] <wolverian> ?eval my %h = (a => 1, b => 2); %h.reverse

[15:21] <evalbot_10184> "2\tb 1\ta"

[15:22] <wolverian> ?eval my %h = (a => 1, b => 2); %h.kv

[15:22] <evalbot_10184> ("a", 1, "b", 2)

[15:22] <wolverian> ?eval my %h = (a => 1, b => 2); %h.kv.reverse

[15:22] <evalbot_10184> "2 b 1 a"

[15:22] <wolverian> ?eval my %h = (1,2,3,4)

[15:22] <evalbot_10184> {("1" => 2), ("3" => 4)}

[15:22] <wolverian> hm. okay.

[15:23] <wolverian> ?eval my %h = (a => 1, b => 2); my @h = %h.kv.reverse; @h

[15:23] <evalbot_10184> [2, "b", 1, "a"]

[15:23] <wolverian> ?eval my %h = (a => 1, b => 2); my @h = %h.kv.reverse; %h = @h; %h

[15:23] <evalbot_10184> {("1" => "a"), ("2" => "b")}

[15:23] <xinming> ?eval my %h = (a => 1, b => 2); my @h = %h.pair.reverse; @h

[15:23] <evalbot_10184> [("b" => 2), ("a" => 1)]

[15:23] <xinming> I think You should use pair... :-)

[15:23] <xinming> hmm, work...

[15:24] <wolverian> I think people were wondering whether perl6 still has the perl5-esque reverse(%hash)

[15:24] * xinming feels sorry if he interrupted your conversation...

[15:24] <wolverian> and I'm wondering where the tabs come from

[15:24] <wolverian> oh well. prettyprinter, I guess.

[15:25] <xinming> wolverian: @h defaults to seperate every elems using space, And I think, for hash, It use table to indent key-value pair....

[15:25] <wolverian> yeah.

[15:25] <xinming> I mean in scalar context...

[15:25] <aufrank> wolverian: why don't you need any quotes in %h = ( a => 1, b => 2 ) ?

[15:26] <wolverian> aufrank, => still autoquotes its LHS

[15:26] <wolverian> (like in perl5)

[15:26] <aufrank> gotcha

[15:26] <aufrank> thx

[15:28] *** kanru joined
[15:30] <avarab> %h = (eval => 1, eval, 2);

[15:31] <xinming> ?eval my @a = 1..1000; [*] @a;

[15:31] <xinming> :-P

[15:31] <evalbot_10184> 4023872600770937735437024339230039857193748642107146325437999104299385123986290205920442084869694048004799886101971960586316668729948085589013238296699445909974245040870737599188236277271887325197795059509952761208749754624970436014182780946464962910563938874378864873371191810458257836478499770124766328898359557354325131853239584630755574091142624174743493475534286465766116677973966688202912073791438537195882498081268678383745597317461360853795345

[15:32] <flounder99> ?eval my(@a,%h);@a=%h=(1,2,3,4);@a.say;@a=%h;@a.say;

[15:32] <evalbot_10184> OUTPUT[1234 1	23	4 ] bool::true

[15:33] <flounder99> it seems @a=%h=... does not "pairify" @a but @a=%h; does

[15:40] <flounder99> @a=%h=... seems to do %h=...;@a=...;

[15:41] <flounder99> I would think it should do %h=...;@a=%h;

[15:49] <Gothmog_> It doesn't in Perl 5, either.

[15:49] <lichtkind> works the for loop as topicalizer as a given?

[15:50] <Gothmog_> flounder99: Think of =()=, eg...

[15:50] <flounder99> perl5 doen't have Pairs

[15:50] <flounder99> thats what I'm thinking of

[15:51] *** Ymmv joined
[15:51] *** ruz joined
[15:51] <Gothmog_> I think the question is more general about chained assignment operators.

[15:52] <flounder99> ?eval my(@a,%h);@a=%h=(1,2,3,4);say +@a;@a=%h;say +@a

[15:52] <evalbot_10184> OUTPUT[4 2 ] bool::true

[15:53] <wolverian> lichtkind, yes

[15:53] <wolverian> ?eval for 1..4 { say when 3 }

[15:53] <evalbot_10184> Error: No such method in class Int: "&when"

[15:53] <svnbot6> r10214 | lwall++ | commification of sort and reduce

[15:53] <wolverian> ?eval for 1..4 { when 3 { say } }

[15:53] <Gothmog_> flounder99: I see your point. I thought of

[15:53] <evalbot_10184> OUTPUT[ ] undef

[15:53] <Gothmog_> perl -le '$_="foo bar baz"; $a =()= m/ba./g; print $a'

[15:53] <Gothmog_> 2

[15:53] <wolverian> evalbot_10184, sigh!

[15:54] *** ruz joined
[15:54] <flounder99> @a=%h=(1,2,3,4) @a has 4 elements @a=%h @a has 2 elements

[15:54] <lichtkind> wolverian cool so we have also a for when

[15:54] <lichtkind> wolverian  i like this idea

[15:54] <wolverian> lichtkind, 'when' is just 'if $_ ~~ ...'

[15:54] <wolverian> except it also breaks out of the surrounding block

[15:55] <lichtkind> wolverian i thought there is no except in perl6

[15:55] <wolverian> lichtkind, hm?

[15:55] <lichtkind> wolverian i also thought because for can set more topics there are in $^a ..etc

[15:55] <wolverian> I don't know how 'when' works with those. read the appropriate synopsis. :)

[15:56] <flounder99> Gothmog_: =()= is what I was thinking of

[15:57] <lichtkind> wolverian thanks all i wanted know if the first parameter of for goes in $_

[15:57] <Gothmog_> *nods*

[15:58] <Gothmog_> Perhaps you should ask @Larry, if there's nothing about it in the synopses...

[16:00] <flounder99> audreyt fixes things I point out before I can think of another example

[16:00] <FurnaceBoy> hehe

[16:01] <FurnaceBoy> Faster than a speeding packet

[16:02] <Gothmog_> But you can't speak of fixing until it's clear you found a bug. :-)

[16:03] <flounder99> Yep, yesterday I asked "is this right" and in less than a minute audrey answered "No" and committed a fix

[16:04] <flounder99> I wasn't even sure it was wrong

[16:07] *** coumbes joined
[16:16] *** mago_ joined
[16:25] *** hexmode joined
[16:33] *** nnunley_ joined
[16:36] *** vel joined
[16:38] *** eric256 joined
[16:39] *** weinig|sleep is now known as weinig|away

[16:50] <wolverian> uh..

[16:50] <wolverian> "He [Damian] was a bit taken aback, and said they weren't planning on changing that feature. I read recently that they've decided to change it after all; you'll have to set some godawful global variable, possibly dollar-unicode-chinese-horse-symbol, to turn on auto-list flattening" http://www.cabochon.com/~stevey/blog-rants/blog-ancient-perl.html

[16:52] <wolverian> I'm pretty sure perl6 still has list flattening...

[16:53] <eric256> just read it somewhere... @list[*] i think.  ...

[16:53] * eric256 probably missed the point, goes to read irc logs

[16:54] <wolverian> ?eval my @foo = ("a".."c"); (1, 2, @foo)

[16:54] <evalbot_10184> (1, 2, ["a", "b", "c"])

[16:54] <wolverian> oh. that doesn't flatten?

[16:54] <avarab> ew

[16:54] <eric256> ?eval my @foo = ("a".."c"); (1, 2, @foo[*])

[16:54] <avarab> foo = ("a".."c"); (1, 2, *@foo)

[16:54] <evalbot_10184> Error:  unexpected "]" expecting term

[16:54] <avarab> eval? my @foo = ("a".."c"); (1, 2, *@foo)

[16:55] <eric256> ?eval my @foo = ("a".."c"); (1, 2, *@foo)

[16:55] <avarab> ?eval my @foo = ("a".."c"); (1, 2, *@foo)

[16:55] <evalbot_10184> (1, 2, "a", "b", "c")

[16:55] *** Blicero joined
[16:55] <eric256> i wasn't too far off

[16:55] <eric256> since they don't auto-flatten it means you can pass them to subs and stuff. it realy is nice actualy. ;()

[16:55] <wolverian> does autoflattening ever happen anymore?

[16:56] <wolverian> ?eval (1, 2, ("a".."c"))

[16:56] <evalbot_10184> (1, 2, "a", "b", "c")

[16:56] <wolverian> List still autoflattens.

[16:56] <wolverian> Array doesn't.

[16:57] * eric256 counts the hours till he can go to radio shack and buy the parts needed to make a homemade custom shutter trigger for his DSLR ;)

[16:58] <avarab> ?eval my @a = ("a" .. "c"); sub subbie (@a is Array, $b is Int) { [ \@a, $b ] }; subbie(@a, 5)

[16:58] <evalbot_10184> [["a", "b", "c"], 5]

[16:59] <wolverian> anyway, I don't think pugs has Captures yet

[16:59] <wolverian> they might change the semantics somewhat

[16:59] <avarab> so it doesn't just automatically convert it to subbie(\@a, 5) as it would do if the whole thing worked on some evil Perl 5 prototypes level?

[16:59] <avarab> I.e. subbie (\@@) { ...

[17:02] <eric256> avarab no

[17:02] <eric256> we get real function prototypes ;)  i beleive thats part of why arrays don't auto flatten.

[17:02] <eric256> ?eval my @a = ("a" .. "c"); sub subbie (@a is Array, $b is Int) { [ @a, $b ] }; subbie(@a, 5)

[17:02] <evalbot_10184> ["a", "b", "c", 5]

[17:02] <wolverian> ?eval ((1,2,3),)

[17:03] <evalbot_10184> (1, 2, 3)

[17:03] <wolverian> hm.

[17:03] <eric256> koay thats kinda odd isn't it?  i guess the return is still flattened?

[17:03] <eric256> ?eval my @a = ("a" .. "c"); sub subbie (@a is Array, $b is Int) { ( @a, $b ) }; subbie(@a, 5)

[17:03] <evalbot_10184> (["a", "b", "c"], \5)

[17:03] <wolverian> ?eval [(1,2,3),4]

[17:03] <evalbot_10184> [1, 2, 3, 4]

[17:04] <eric256> arg beat me to it. so its the [ ] that is flattening the array.

[17:04] <PerlJam> um ... if you mean [[1,2,3],4], why not say that?

[17:04] *** trampel left
[17:05] <wolverian> I'm trying to find out what flattens now and what doesn't. and what exactly "list context" even is nowadays.

[17:05] <eric256> not thinking about it from that angle is why. just trying to see where it flattens and where it doesn't

[17:05] <PerlJam> Well, I'm not sure that "flattening" even applies here.  What makes you think that [(1,2,3),4] has "substructure"?

[17:06] <eric256> ?eval ((1,2,3),4)

[17:06] <evalbot_10184> (1, 2, 3, 4)

[17:06] <PerlJam> if you say my $a = (1,2),(3,4);  # how many things are in $a?

[17:06] <wolverian> nothing, really. I'm just unclear on the rules.

[17:06] <wolverian> since they're not written explicitly in the AES, I think.

[17:07] <PerlJam> wolverian: that's okay, I'm not clear on them either ;-)

[17:07] <wolverian> :)

[17:07] <eric256> ?eval my @a = (1,2,3); (@a,5,6);

[17:07] <evalbot_10184> ([1, 2, 3], 5, 6)

[17:07] <eric256> thats what got us confused on the falttening

[17:07] <wolverian> in other words, I want "context" well defined

[17:07] <eric256> ?eval  ( (1,2,3),5,6);

[17:07] <evalbot_10184> (1, 2, 3, 5, 6)

[17:08] <eric256> so what is happening there?  why aren't those two the same?

[17:09] <audreyt> those two should be the same. what you are seeing is yet-another-pugs-bug :)

[17:10] <eric256> which is the problem with learning perl6 by example ;)

[17:10] <wolverian> audreyt, do you have a formal definition of context?

[17:10] <eric256> i was looking at t/builtins/arrays and t/builtins/lists but i don't see any files that this would seem to fit in

[17:11] <eric256> maybe something like t/builtins/lists/sanity.t  ?

[17:11] <audreyt> pugs>  my @a = (1,2,3); (@a,5,6);

[17:11] <audreyt> (1, 2, 3, 5, 6)

[17:11] <audreyt> I wonder where does evalbot get the idea.

[17:11] <PerlJam> audreyt: um ... is that what's supposed to happen?

[17:12] <audreyt> wolverian: well, a formal definition for "flattening"

[17:12] <audreyt> PerlJam: I think so; write (@a[], 5, 6) if you want no-flattening, I think

[17:12] <wolverian> audreyt, is it in AES?

[17:13] <PerlJam> audreyt: I think that's exactly backwards (of course, I could be wrong)

[17:13] <PerlJam> audreyt: I'd expect (@a,5,6) to be a list of 3 elements.

[17:13] <eric256> how do you get pugs to print its version i thought *$PUGS_VERSION but thats not it.

[17:13] <audreyt> eric256: $?PUGS_VERSION

[17:14] <eric256> PerlJam a minute ago you where arguing that ((1,2,3),4) should be four elements.../me is confused

[17:14] <eric256> ?eval $?PUGS_VERSION

[17:14] <evalbot_10184> \"Perl6 User\'s Golfing System, version 6.2.11, February 1, 2006 (r10178)"

[17:14] <audreyt> PerlJam: a list in parenthesis always flattens the expressions between commas

[17:14] <TimToady> in list contecxt

[17:14] <PerlJam> eric256: I wasn't arguing, I was inquiring why you guys thought so.  :)

[17:15] <TimToady> you can't tell what the context is there yet.

[17:15] <audreyt> TimToady: even in scalar context... my $x = (@a, 5, 6); still flattens @a, no?

[17:15] <audreyt> at least S02 line 1815 seems to say that

[17:15] <wolverian> what I'm wondering is, is context just a reformulation of return type mmd or does it encompass other things?

[17:15] <TimToady> yes, I mean the context applied to the first arg.

[17:15] <avarab> ?eval $+LC_ALL

[17:15] <TimToady> foo(@a,5,6) may take @a as scalar.

[17:15] <evalbot_10184> Error: Undeclared variable: "$+LC_ALL"

[17:15] <wolverian> (or s/reformulation/application/)

[17:16] <audreyt> but that is not in a paren-list; it's not infix:<,>

[17:16] <audreyt> it's in a capture, and is subject to capture rules

[17:16] <TimToady> certainly, if you supply more context, it's more meaningful.

[17:16] <eric256> eval bot seems to be several revisions behind

[17:16] <audreyt> (which indeed just remember @a)

[17:17] <PerlJam> TimToady: so ... (@a,@b) = (@b,@a) is as in perl5 or not?  Do I need to use := there ?

[17:17] <TimToady> the original example had (@a,5,6) as the last statement in block, and it's not clear what the context of that is.

[17:18] <audreyt> but even if it's assigned to a scalar, that still flattens @a, and puts a List into that scalar, no?

[17:18] <TimToady> but yes, it's not a Caputre.

[17:18] <audreyt> it can only be a Capture when you say

[17:18] <audreyt> return(@a, 5, 6)

[17:18] <audreyt> instead of

[17:18] <audreyt> (@a, 5, 6);

[17:19] * eric256 's head starts spinning

[17:19] <audreyt> the first can respond to binding; the latter always is just a List, which may or may not get flattened into the caller side's other lists

[17:19] <TimToady> that seems a bit odd.

[17:20] <TimToady> most folks would rather think of return as the same as what happens at the end of the block, with an extra goto.

[17:20] *** weinig|away is now known as weinig

[17:20] <audreyt> alternately, we can pretend there is always an implicit \() around the last statement.

[17:20] <audreyt> (S06: Advanced subroutine features, The C<return> function)

[17:21] *** nnunley joined
[17:21] <audreyt> or rather, an implicit return()

[17:21] <audreyt> (which amongs to the same thing, except for exception)

[17:21] <TimToady> I think that'd make more sense to most people.

[17:21] <eric256> so in capture context the @a retains its ...err identity....but in any other context it flattens?

[17:21] <audreyt> (that is, the implicit-return form does not trigger UNDO)

[17:21] <TimToady> capture just implies that any flattening is lazily done later.

[17:22] <TimToady> when you know the actual context.

[17:22] <audreyt> sub f { :x<1>, :y<2> }; # potentially two named-return-subject-to-binding

[17:22] <audreyt> sub f { (:x<1>, :y<2>) }; # always just a List of two pairs

[17:22] <audreyt> that's what implicit-return would suggest to me

[17:22] <audreyt> (which kinda makes sense)

[17:22] <eric256> ahhh okay. that kinda makes sense. that way you can store stuff in a captuer to pass to other subroutines and match their signature.

[17:23] <flounder99> ?eval my %h=(1,2,3,4);my @a=%h; say +@a;

[17:23] <evalbot_10184> OUTPUT[2 ] bool::true

[17:24] <eric256> ?eval my %h=(1,2,3,4);my @a=%h; say @a.perl;

[17:24] <evalbot_10184> OUTPUT[[("1" => 2), ("3" => 4)] ] bool::true

[17:24] <flounder99> 2 pairs

[17:24] * eric256 needs to start grokiing pairs and now captures. ;)

[17:25] <audreyt> will help if I implement them this weekend :)

[17:26] <wolverian> TimToady, is there a definition of context in the AES or somewhere else?

[17:26] <theorbtwo> The context that can be defined is not the true context.

[17:26] <TimToady> sure, probably mutually contradictory. :)

[17:27] <TimToady> but hey, I'm a good marketeer... :)

[17:27] <PerlJam> wolverian: I like this one:  context n 1: discourse that surrounds a language unit and helps to determine its interpretation

[17:27] <PerlJam> :-)

[17:27] <wolverian> heh. :)

[17:27] <wolverian> so it's not actually an element of the language formalism, just a name on something else?

[17:28] <flounder99> This also goes back to my earlier question about reversing a hash

[17:29] <flounder99> ?eval my %h=(1,2,3,4);%h.reverse.perl.say;

[17:29] <evalbot_10184> OUTPUT["4\t3 2\t1" ] bool::true

[17:29] <eric256> ?eval reverse ( 1=>2,3=>4);

[17:29] <evalbot_10184> "4\t3 2\t1"

[17:29] <eric256> that seems right...whats the problem?

[17:29] <PerlJam> I'm still kind of hung up on (@a,5,6) though.  I hesitate to say this, but in absense of context, that looks like a list of 3 things.   I think it also, makes sense that people should have to ask for flattening explicitly.  But what I've just seen here leads me to believe that asking can be explicit but quite subtle.

[17:30] <PerlJam> s/also,/also/

[17:30] <flounder99> ?eval my %h=(1,2,3,4);%h=%h.reverse;%h.say;

[17:30] <evalbot_10184> OUTPUT[1	23	4 ] bool::true

[17:31] <eric256> ?eval my %h=(1,2,3,4);%h=%h.reverse;%h.perl;

[17:31] <evalbot_10184> "\{(\"1\" => 2), (\"3\" => 4)}"

[17:31] <wolverian> ?eval my %h = (1,2,3,4); %h.reverse

[17:31] <PerlJam> flounder99: that just looks like a bug to me :)

[17:31] <evalbot_10184> "4\t3 2\t1"

[17:31] <flounder99> ?eval my %h=(1,2,3,4);%h=%h.kv.reverse;%h.say;

[17:31] <evalbot_10184> OUTPUT[2	14	3 ] bool::true

[17:31] <audreyt> TimToady: @x[f()] = @y[g()]; # f() is in scalar context, g() is in list context, correct?

[17:32] <audreyt> (but @y[g()] is in scalar context.)

[17:32] <PerlJam> audreyt: how do you figure?  Why is f() in scalar context?

[17:32] <PerlJam> Apparently I'm going to have to re-read the AES soon.

[17:33] <audreyt> PerlJam: S03:

[17:33] <audreyt> Perl 6 does not attempt to intuit whether an lvalue slice is meant to be one element or several, so you must use parens in that case

[17:33] <audreyt> but S02: subscripts are always evaluated in list context (when used as rvalue)

[17:33] <TimToady> yes, I think that's the current interpretation

[17:34] <audreyt> ok. I'll commit a couple lines of clarification to S02

[17:34] <audreyt> as this lhs-vs-rhs is quite subtle :)

[17:35] <TimToady> hmm, well, sometimes "subtle" means "wrong"...

[17:35] <PerlJam> subtle == evil IMHO (for the most part)

[17:35] *** schneiker joined
[17:36] <audreyt>     @x[f()]   = g();      # scalar context for f() and g()

[17:36] <audreyt>     @x[f()]   = @y[g()];  # scalar context for f(), list context for g()

[17:36] <audreyt>     @x[f()]   = @y[+g()]; # scalar context for f() and g()

[17:36] <audreyt>  

[17:36] <audreyt>     (@x[f()]) = g();      # list context for f() and g()

[17:36] <audreyt>     (@x[f()]) = @y[g()];  # list context for f() and g()

[17:36] <audreyt>     (@x[f()]) = @y[+g()]; # list context for f(), scalar context for g()

[17:36] <audreyt> # current interpretation

[17:36] <TimToady> looks right

[17:36] <audreyt> k, committing

[17:37] <audreyt> wolverian: I think list-context is now always statically a "flatten" node on AST

[17:38] <audreyt> wolverian: ...and that's it. the Signature may apply more flattening, but that's part of Signature-binding definition

[17:38] <wolverian> audreyt, can that be reduced to return type mmd? (I'm kind of stuck to that notion for some reason)

[17:38] <audreyt> yes it can, but it requires finesse

[17:39] <wolverian> finesse from the design or implementation?

[17:39] <audreyt> see docs/notes/context_coercion.pod

[17:39] <TimToady> I'm still not sure return should Capture by default.

[17:39] <wolverian> thanks! audreyt++

[17:39] <audreyt> wolverian: np, but I think using type inferrence for that is a bit overgeneralizing things

[17:39] <audreyt> in any case it's going to be special-cased before 6.2831 here, I think

[17:40] <audreyt> TimToady: "named returns" too sick? :)

[17:40] <TimToady> foo(1,2,bar()) should allow bar to return a list that flattens, or we've basically destroyed list returns.

[17:40] <PerlJam> Is there an operator actually called "list"?

[17:40] <PerlJam> i.e.   list EXPR  puts EXPR in list context

[17:40] <wolverian> audreyt, mm. as long as it doesn't change semantics it seems, uh, less arbitrary to do it with type inference.

[17:40] <TimToady> I wouldn't want to force people to have to say foo(1,2,*bar()) all the time.

[17:40] <audreyt> TimToady: but bar() in that position does flatten

[17:41] <audreyt> even if it's a Capture; the difference is whether nameds become pairs

[17:41] <audreyt> or become further nameds to foo

[17:41] <TimToady> but it can't flatten eagerly

[17:42] <TimToady> foo(bar()) needs to know what foo expects as the first argument

[17:42] <audreyt> sub bar { (3,4,5) }

[17:42] <audreyt> can sure flatten eagerly

[17:42] <audreyt> the problem case is

[17:42] <audreyt> sub bar { 3,4,5 }

[17:42] <audreyt> I think.

[17:42] <audreyt> (substitute "3" above to three())

[17:42] <audreyt> (or @three)

[17:43] <audreyt> that's the same as

[17:43] <wolverian> (btw, is --> now written outside the argument list?)

[17:43] <audreyt> sub bar { return( (3,4,5) )}

[17:43] <audreyt> sub bar { return( 3,4,5 )}

[17:43] <TimToady> assuming return is a function

[17:43] <audreyt> wolverian: --> occurs only in signature lists

[17:44] <audreyt> or a macro-parsed-as-function, yes.

[17:44] <wolverian> what's a signature list? that is, 'sub foo (--> bar)' or 'sub foo () --> bar'?

[17:44] <audreyt> the first one

[17:44] <TimToady> well, my brain isn't working well enough to think this through yet this morning.

[17:45] <TimToady> so let me stew about it a while.

[17:45] <audreyt> I tried arguing for the latter one in tokyo but TimToady thinks I need to rewire my brain, so I did :)

[17:45] <audreyt> TimToady: k. I'll hold off the S06 patch then

[17:45] <audreyt> +If the function ends with an expression without an explicit C<return>,

[17:45] <audreyt> +that expression is also taken to be a C<Capture>:

[17:45] <audreyt> +

[17:45] <audreyt> +    sub f { :x<1> }     # possibly named-argument binding

[17:45] <audreyt> +    sub f { (:x<1>) }   # always just one positional Pair object

[17:45] <audreyt> +

[17:46] <wolverian> ah, ok. context_coercion.pod still uses the () --> style

[17:46] <audreyt> yeah. feel free to fix :)

[17:46] <wolverian> mmhm

[17:48] <flounder99> Should a hash flattten to a list of pairs or should it flatten to a list?

[17:49] <TimToady> list of pairs

[17:49] <flounder99> ?eval my %h=(1,2,3,4);my @a=%h; say +@a;@a.perl;

[17:49] <evalbot_10184> OUTPUT[2 ] "[(\"1\" => 2), (\"3\" => 4)]"

[17:49] <flounder99> that's what it does

[17:49] <TimToady> to get the P5 behavior you use .kv

[17:50] <flounder99> so reverse(%h) is now %h.kv.reverse

[17:50] <schneiker> obra: Some good perl.perl6.meta news....

[17:50] <schneiker> Got reply back from Ask Bjprn Hansen (nntp.perl.org) about why posts didn't appear:

[17:50] <schneiker>   > What is status of perl.perl6.meta? ....

[17:50] <schneiker>   It was closed a few years ago.

[17:50] <schneiker> However, after sending him requested info/link on discussion, my new posts later showed up

[17:50] <schneiker> in newsreader (but not in http://www.nntp.perl.org/group/perl.perl6.meta archives).

[17:50] <schneiker> Will start work on preliminary FAQ to post on it this weekend.

[17:50] <schneiker> Suggestions (especially links and content pointers) welcome,

[17:50] <schneiker> preferably posted to perl.perl6.meta, but I routinely skim #perl6 logs too.

[17:51] <flounder99> %h.reverse just moves around the pairs not reversing the elements of the pairs, right?

[17:52] <flounder99> That is what pugs does now

[17:52] <schneiker> Back to $work&

[17:52] *** schneiker left
[17:52] <wolverian> audreyt, does pugs currently implement context_coersion.pod? (with an 's')

[17:53] <TimToady> It's kind of silly to ask a hash to reverse its value.

[17:53] <TimToady> arguably %h.=reverse might mean something

[17:53] <particle_> yep, not silly in p5, but it is in p6

[17:53] <TimToady> need to commute to work.

[17:53] <particle_> %h.kv.reverse makes sense

[17:54] <TimToady> back in 15min or so... &

[17:55] <particle_> not many can beat that commute

[17:55] <PerlJam> no commute is the best commute

[17:55] <particle_> that's my commute

[17:55] <particle_> bed -> desk

[17:56] <PerlJam> Though, I guess it's good to know that TimToady is commutative.  He's probably also associative and distributive too  :)

[17:56] *** Aankhen`` joined
[17:56] <particle_> well, then he's not exponential

[17:57] *** Alb joined
[17:57] <PerlJam> but he is non-linear

[17:57] <flounder99> if not chaotic

[17:58] *** pdcawley joined
[17:58] <particle_> he is non perfect

[17:58] <particle_> s/non/not/

[17:58] <audreyt> wolverian: no, pugs currently does not implement any static typing at all

[17:59] <wolverian> hrm, I forgot --verbatim again

[17:59] <audreyt> wolverian: it does limiated runtime inference on lvalue, but it's been ruled as unneccessary now so I'll pull it out soon

[17:59] <svnbot6> r10215 | wolverian++ | fix 'sub foo () --> bar' to 'sub foo ( --> bar)'

[17:59] <wolverian> yay, svnbot fixed it

[18:00] <wolverian> audreyt, right. oh well, it's all a bit too deep for me. basically I just want the more typeful approach to be used, whichever that is..

[18:00] <wolverian> (because "it works for haskell". :)

[18:00] <audreyt> runtime typecasing is awfully hard for haskell, y'know? :)

[18:01] <audreyt> typecase in general is possible with GADTs

[18:01] <audreyt> but that's all closed-world; perl6-style open-world MMD based on runtime subtyping

[18:02] <wolverian> can context be deduced at compile time?

[18:02] <audreyt> is quite unnatural for haskell - you end up comparing TypeRep or something

[18:02] <audreyt> the flatten-vs-nonflatten, sure

[18:02] <audreyt> I think it's strictly static

[18:02] <wolverian> but some aspects of context can be dynamic?

[18:02] <audreyt> but I don't think the constraints can be statically inferred

[18:02] <wolverian> right

[18:03] <audreyt> see "Hybrid Typechecking"

[18:03] <audreyt> linked from my journal

[18:03] <wolverian> thanks

[18:03] <audreyt> np :)

[18:03] <wolverian> so, next question

[18:03] <wolverian> why do we need context? :)

[18:03] <audreyt> because implicit concatenation is fun?

[18:04] <audreyt> (assuming you as asking about flattening)

[18:04] <audreyt> (not general return-type-mmd)

[18:04] <wolverian> the list-vs-single thing is the visible aspect, yeah

[18:04] <audreyt> implicit concat is perlish :)

[18:04] <wolverian> so the only reason we have context is implicit flattening?

[18:04] <audreyt> I think so.

[18:04] <wolverian> mmkay, thanks.

[18:05] <audreyt> other parts (constraints, return type mmd etc) can be straightforwardly modeled

[18:05] <audreyt> in the usual type systems

[18:05] <flounder99> ?eval my(@a,%h);@a=%h=(1,2,3,4);@a.say;@a=%h;@a.say;

[18:05] <evalbot_10184> OUTPUT[1234 1	23	4 ] bool::true

[18:05] <flounder99> is chained = different context?

[18:05] <audreyt> but implicit concat makes perl perl... without it maybe we should call this language Ruby2 or something

[18:06] <audreyt> flounder99: no. it's a bug

[18:06] <audreyt> write a test :)

[18:14] <TimToady> degone

[18:15] *** Alb left
[18:17] <wolverian> audreyt, okay. it's just that context seems like an awful lot of complexity just for flattening. flattening _is_ very perlish, though.

[18:22] <Arathorn> audreyt: thanks again for random judy handholding over the weekend - got it all working nicely after the realisation of the macros silent &-ing. still to investigate using judy1 for iterating over judyhs's, though

[18:22] <svnbot6> r10216 | flounder99++ | Added Name to AUTHORS

[18:22] <audreyt> Arathorn: k :)

[18:23] <flounder99> hey! it worked!

[18:24] <audreyt> "it works! if you see this, your pugs committership has been set up properly."

[18:39] <webmind> anyone here going to the perl workshop ?

[18:41] <Juerd> I am!

[18:41] <Juerd> Do you mean Dutch Perl Workshop? :)

[18:41] <webmind> yes

[18:41] <Juerd> Or just any?

[18:41] <webmind> the Dutch Perl Workshop in 2006, this month

[18:41] <Juerd> 2006-05-17

[18:41] <webmind> that one yes

[18:41] <Juerd> Well, I am :)

[18:41] <webmind> good

[18:42] <webmind> who else?

[18:42] <Juerd> You are?

[18:42] <webmind> indeed

[18:45] *** Arathorn is now known as Aragone

[18:47] *** neoesque joined
[19:00] *** hexmode joined
[19:09] * Limbic_Region spent almost the entire day reading every single one of luqui's blog entries

[19:13] <kolibrie> Limbic_Region: do you feel enlightened?

[19:14] <Limbic_Region> kolibrie - I took away a lot of great links

[19:14] * Limbic_Region decided to take a day off from thinking about programming and just read what someone else was thinking

[19:18] *** sahadev joined
[19:21] <Limbic_Region> who runs http://planetsix.perl-foundation.org/ btw?  It is b0rk (pulling in very old entries as if they were posted today)

[19:21] <szbalint> which is luqui's blog, Limbic_Region, If I may ask?

[19:21] <particle_> http://use.perl.org/~luqui/journal

[19:22] <szbalint> ty

[19:23] <Limbic_Region> no

[19:24] <Limbic_Region> http://luqui.org

[19:24] <Limbic_Region> the use.perl journal is specific to p6 design and meeting minutes

[19:24] <Limbic_Region> and hasn't been updated in some months

[19:25] <Limbic_Region> sorry - was reading the Catalyst upheaval announcement

[19:27] <obra> Limbic_Region: planet just does that sometimes

[19:27] <obra> it's a planet/use.perl issue

[19:29] *** elmex joined
[19:29] <Limbic_Region> oh - not seen it before and I check twice a day on workdays and at least once a weekend

[19:30] <lichtkind> reverse is an array method?

[19:31] <Limbic_Region> ?eval my @foo = 1..5; my @bar = @foo.reverse; say ~@bar;

[19:31] <evalbot_10184> OUTPUT[5 4 3 2 1 ] bool::true

[19:31] <szbalint> thanks L~R :)

[19:31] <Limbic_Region> ?eval my @foo = (1..5).reverse; say ~@foo;

[19:31] <evalbot_10184> OUTPUT[5 4 3 2 1 ] bool::true

[19:32] <Limbic_Region> lichtkind - I would say that if something can be treated as a list then .reverse is a method that can be applied to it

[19:32] <Limbic_Region> no problem szbalint

[19:32] <Limbic_Region> ?eval my @inf = 1...;

[19:33] <evalbot_10184> pugs: out of memory (requested 1048576 bytes)

[19:33] <lichtkind> Limbic_Region can or specced sorry but i have be serious about this

[19:33] <Limbic_Region> hmmm - so that's still bork or is that correct behavior?

[19:33] <Limbic_Region> lichtkind - not hard to check the synopses

[19:34] <Limbic_Region> lichtkind - for instance, search for .reverse in S02

[19:35] <Limbic_Region> http://dev.perl.org/perl6/doc/design/syn/S02.html

[19:35] <lichtkind> Liimbic_Region done that (otherwise i wouldnt ask) all i got is reverse 1..2 oh i checked only s3

[19:35] <lichtkind> because its a kind of operator

[19:36] <lichtkind> thanks

[19:36] <Limbic_Region> I would have thought that it would have been in S09 too but apparently not

[19:37] <PerlJam> I sure hope perl6 doesn't suffer the same documentation problems that other OO languages do.

[19:38] *** eric256 left
[19:38] <Limbic_Region> PerlJam - haven't read a lot of TFMs on other OO languages but

[19:39] <Limbic_Region> I would want a summarized list of all methods that certain objects/data types can take in a single place

[19:39] <Limbic_Region> and then I can dig further if need be in S29 or where ever the method itself would be further defined

[19:41] <PerlJam> Most other OO languages tend to force you to hunt out more information about the thing you're interested in before you can find out what you need to know (in my experience anyway).  It's better (IMHO) that if you know you need info on something called "reverse" that the docs help you find out what you need to know

[19:41] *** bryan| joined
[19:41] *** bryan| left
[19:42] <PerlJam> that sure doesn't look as sensical as I want it to be  :)

[19:42] <lichtkind> why in s29 they see fifference in array and list? its array vs lazy list?

[19:43] <lichtkind> sorry difference

[19:43] <Limbic_Region> lichtkind - look at the last update to S29

[19:43] <lichtkind> in mailinglist?

[19:43] <svnbot6> r10217 | flounder99++ | /t/assign.t - added chained equals @=%=list; $=%=list; and (@a,@b)=(@b,@a) tests

[19:43] <Limbic_Region> no - http://www.rodadams.net/Perl/S29.html

[19:43] <Limbic_Region> last updated over a year ago

[19:49] <lichtkind> dear chained equals?? iv got to lot to learn

[19:51] *** larsen_ joined
[19:51] <Limbic_Region> well - that's chained equals with context specified I think

[19:52] *** coumbes joined
[19:56] *** weinig is now known as weinig|away

[19:57] <lichtkind> nevertheless to high for me now currently i try to grok all the subroutine stuff

[19:58] <lichtkind> ?eval :2(3)

[19:58] <evalbot_10184> 3

[19:59] <flounder99> ?eval my(@a,%h);@a=%h=(1,2,3,4);@a.say;@a=%h;@a.say;

[19:59] <evalbot_10184> OUTPUT[1234 1	23	4 ] bool::true

[19:59] *** larsen__ joined
[20:00] <flounder99> ?eval my(@a,%h);@a=%h=(1,2,3,4);@a.perl.say;@a=%h;@a.perl.say;

[20:00] <evalbot_10184> OUTPUT[[1, 2, 3, 4] [("1" => 2), ("3" => 4)] ] bool::true

[20:00] <lichtkind> ?eval :2(101)

[20:00] <evalbot_10184> 5

[20:01] <flounder99> thats what I mean by chained equals.  The bug is @a=%h=... is not the same as %h=...;@a=%h;

[20:02] <flounder99> it should be

[20:04] <PerlJam> flounder99: Though currently it's a great way to  turn a list into a list of pairs  :)

[20:05] <Limbic_Region> PerlJam - wouldn't .kv do that too

[20:05] <Limbic_Region> and zip :by

[20:05] <Limbic_Region> hrm - not sure about zip on a single list

[20:05] <Limbic_Region> *shrug*

[20:06] <PerlJam> Limbic_Region: @L2 = map { $^a => $^b } @L1;

[20:07] <flounder99> @a=%h and @a will be a list of pairs. @a=%h.kv is a flattend list, according to TimToady, at least today ;)

[20:07] <PerlJam> though I guess my map needs a comma these days

[20:08] <PerlJam> @L2 = map { $^a => $^b }, @L1;  or perhaps @L2 = L1 :map { $^a => $^b };

[20:08] <PerlJam> er, s/L1/@L1/

[20:08] <Limbic_Region> so as always, TIMTOWTDI

[20:09] *** larsen joined
[20:10] <flounder99> What confused me is that %h = reverse %h; no longer swaps keys and values like in perl5

[20:10] <PerlJam> @L2 = zip(@L1[0..*:by(2)],@L1[1..*:by(2)]);

[20:11] <Limbic_Region> flounder99 - that confuses me still - why not?

[20:12] <Limbic_Region> because it is list context on both sides

[20:12] <Limbic_Region> so you get a list of pairs in reverse order?

[20:12] <PerlJam> Limbic_Region: because the pairs don't flatten

[20:12] <PerlJam> right

[20:12] <PerlJam> (though that makes no sense as hashes are unordered anyway)

[20:12] <Limbic_Region> so is there a * (splat) operator to force the flattening?

[20:13] <flounder99> that show I understand it

[20:13] <flounder99> .kv seems to flatten it

[20:13] <Limbic_Region> ok so %h = %h.kv.reverse;

[20:14] <PerlJam> or even %h.=kv.reverse (I think)

[20:14] <flounder99> ?eval my %h=(1,2,3,4);%h=%h.reverse;%h.perl.say;%h=%h.kv.reverse;%h.perl.say;

[20:14] <evalbot_10184> OUTPUT[{("1" => 2), ("3" => 4)} {("2" => "1"), ("4" => "3")} ] bool::true

[20:16] <flounder99> ?eval my %h=(1,2,3,4);my @a=*%h;@a.perl;

[20:16] <evalbot_10184> "[(\"1\" => 2), (\"3\" => 4)]"

[20:16] <flounder99> apparently splat doesn't flatten a hash, at least not now

[20:20] <flounder99> I don't think .= is implemented yet

[20:23] <lichtkind> 5.as("%b") is konverting to binary but how to convert to the base of 3?

[20:43] <TimToady> the most recent version of S29 is pugs/docs/Perl6/Spec/Functions.pod

[20:54] <lichtkind> shit , perl6 is awfull lot of of syntax (sorry but i was temporary frustratet after making some index of all operators and after over 40 items and hairy wikisyntax no end in sight)

[20:56] <lichtkind> is there currentl< a alphabetical table of all operators?

[20:58] * PerlJam loves the svk error messages:  Oh no, no more exceptions!

[20:58] <TimToady> there are no alphabetical lists of anything.

[21:01] <lichtkind> so the good news is i have the alphabetical list :)

[21:01] <lichtkind> still in progress but fairly anhanced

[21:04] <clkao> PerlJam: bah, that's svn::mirror :/

[21:05] <PerlJam> clkao: well, now when I try to update my pugs, I get this: Can't locate Regexp/Shellish.pm in @INC

[21:05] *** FurnaceBoy_ joined
[21:07] <clkao> hmm do you have it?

[21:08] <PerlJam> clkao: apparently I do not.  However, unless yum removed it, I don't understand why I never saw this before.

[21:11] *** p5evalbot joined
[21:43] *** weinig|away joined
[21:45] *** aufrank joined
[21:49] *** weinig|away_ joined
[21:50] *** SamB joined
[21:51] *** larsen_ joined
[21:53] *** coumbes_ joined
[21:55] *** coumbes_ is now known as coumbes

[21:58] *** weinig|away_ is now known as weinig

[22:00] *** fglock left
[22:03] *** larsen_ is now known as larsen

[22:10] *** larsen_ joined
[22:13] *** ghenry joined
[22:21] *** r0nny joined
[22:21] <r0nny> hi

[22:23] *** larsen joined
[22:23] <TimToady> nm

[22:26] *** jsiracusa joined
[22:28] *** Ymmv joined
[22:31] *** larsen__ joined
[22:31] *** ryan` joined
[22:31] *** ryan` left
[22:34] *** |mjk| joined
[22:38] *** ruoso joined
[22:39] * ruoso back after workers holiday

[22:42] <arcady> workers? holiday?

[22:43] <arcady> (never mind that the whole thing started in the US... they still don't know anything about it here)

[22:48] *** Khisanth joined
[22:49] *** larsen_ joined
[23:00] *** mako132_ joined
[23:04] *** neoesque joined
[23:18] *** Limbic_Region joined
[23:25] *** SamB joined
[23:47] *** Ymmv joined
[23:51] <meppl> gute nacht

