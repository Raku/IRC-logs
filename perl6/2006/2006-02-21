[00:09] *** dduncan joined
[00:36] *** kakos joined
[00:54] *** drbean left
[01:08] *** lao_ joined
[01:29] *** oylenshpeegul joined
[01:45] *** oylenshpeegul left
[01:47] *** Amnesiac joined
[01:51] *** arcady joined
[02:12] *** arcady joined
[02:30] *** Ovid joined
[02:41] *** ayrnieu joined
[02:42] *** alexe joined
[02:43] *** Cryptic_K joined
[02:59] *** Ovid joined
[03:40] *** szbalint joined
[03:49] *** drbean joined
[04:01] *** drbean left
[04:11] *** alexe left
[04:13] *** putter joined
[04:14] <putter> bsb: (faint, long delayed) "pong..."

[04:33] <svnbot6> r9082 | putter++ | misc/pX/Common/Tasks - removed regexp_engine_demo.pl entry, as that spike is now finished.

[04:36] <svnbot6> r9083 | putter++ | modify Tasks again.

[04:36] <svnbot6> r9082 | putter++ | misc/pX/Common/Tasks - removed regexp_engine_demo.pl entry, as that spike is now finished.

[04:37] <putter> re p5 regexp engine performance... finally getting some sane numbers now (ie, slow enough to seem plausible;), after taking into account Regexp::Parser optimizations.  still looks adequate.

[04:38] *** vel joined
[04:38] <putter> svnbot6: thanks for rubbing it in ;)  # re commit, change mind, commit again

[04:44] <putter> i hope to be around tomorrow.  good night &

[05:40] *** scook0 joined
[06:09] *** kisu joined
[06:31] <svnbot6> r9084 | gaal++ | * Rationalize single-pass build.

[06:31] <svnbot6> r9084 | gaal++ |   The Prelude is now always inlined in source form in Pugs.Prelude, which

[06:31] <svnbot6> r9084 | gaal++ |   is promoted to a real Haskell file (not an #include as before). This means

[06:31] <svnbot6> r9084 | gaal++ |   we don't need PreludePC.hs-null, and the build should be much less flaky.

[06:32] <gaal> &

[07:04] <svnbot6> r9085 | audreyt++ | * If PreludePC.yml is not present during precomp, don't emit

[07:04] <svnbot6> r9085 | audreyt++ |   useless "Right Nothing" warnings.

[07:10] <svnbot6> r9086 | audreyt++ | * Parser: split ruleStatementList's semicolon handling

[07:10] <svnbot6> r9086 | audreyt++ |   into two functions to cut ~2000 parsecBind calls.

[07:17] *** beppu joined
[07:21] *** f joined
[07:26] *** f is now known as fandango

[07:32] <audreyt> bbl

[07:32] <audreyt> (-> hackathon)

[07:32] <svnbot6> r9087 | autrijus++ | * revert the nonSep commit for now -- will continue after more profiling is done en route to hackathon

[07:33] <obra> the hackathon. wow. so jealous.

[07:33] <gaal> whee &

[07:33] <GeJ> morning happy .il hackathoners

[07:33] *** gaal left
[07:33] <GeJ> morning obra

[07:33] <GeJ> audreyt++ # journaling :)

[07:38] *** Aankhen`` joined
[07:40] *** iblechbot joined
[07:43] *** drbean joined
[07:53] *** marmic joined
[07:55] *** Ovid joined
[08:02] <dduncan> I have been building r9084, and it has been sitting at the "Reloading Prelude from source..." for awhile now ...

[08:02] <dduncan> top shows the 'pugs' process having 30 min+ of cpu time

[08:03] <dduncan> I killed it, re-pulled, and try make again

[08:03] *** rantanplan_ joined
[08:11] *** Bit-Man joined
[08:12] *** KingDiamond joined
[08:24] *** kane_ joined
[08:40] *** elmex joined
[08:46] *** drrho joined
[08:51] *** clkao joined
[09:02] <buu> ?eval 1

[09:02] <buu> SUCK

[09:02] *** evalbot_9054 is now known as evalbot_9084

[09:04] <evalbot_9084> (no output)

[09:09] *** KingDiamond joined
[09:21] <clkao> it seems the current smoke still thinks it's smoking a release

[09:27] *** nnunley joined
[09:45] *** knewt_ joined
[09:51] <dduncan> similar problem with latest

[09:52] <dduncan> 'make' has been sitting at "Generating precompiled Prelude, Test... " for 100 CPU minutes and counting

[09:52] <dduncan> or rather, that's how long the current 'pugs' process has been running

[09:52] <dduncan> killing ...

[09:53] <dduncan> maybe better luck tomorrow

[09:54] *** xinming joined
[09:55] *** xinming joined
[09:58] *** knewt_ is now known as knewt

[10:36] *** penk joined
[10:48] *** elmex joined
[10:52] *** drbean joined
[11:06] *** chris2 joined
[11:27] *** kisu joined
[11:46] *** iblechbot joined
[12:00] *** drbean joined
[12:04] *** iblechbot_ joined
[12:06] *** kane-xs joined
[12:07] <kane-xs> seen audreyt

[12:07] <jabbot> kane-xs: audreyt was seen 4 hours 34 minutes 30 seconds ago

[12:42] *** robkinyon joined
[12:47] *** alexe joined
[13:05] *** kolibrie joined
[13:31] *** Limbic_Region joined
[14:08] *** Qiang joined
[14:17] <svnbot6> r9088 | fglock++ | iterator_engine_p6regex.pl - compile and run simple rules 

[14:17] <svnbot6> r9088 | fglock++ | like '<word> <ws> xyz'

[14:19] *** azurot1 joined
[14:23] *** cdpruden joined
[14:49] *** chris2 joined
[14:54] *** vel joined
[14:56] <svnbot6> r9089 | audreyt++ | * Draft of my OSDC.il hackathon plans.

[14:59] <svnbot6> r9090 | audreyt++ | * Unbreaking the build by generating the inline prelude using

[14:59] <svnbot6> r9090 | audreyt++ |   proper line escaping.

[14:59] <svnbot6> r9091 | audreyt++ | * Refactor operators part out of Pugs.Parser into Pugs.Parser.Operator

[14:59] <svnbot6> r9091 | audreyt++ |   to save compilation time.

[15:02] <svnbot6> r9092 | audreyt++ | * Test.pm: Bump copyright year.

[15:02] *** iblechbot joined
[15:05] <audreyt> gaal broke the build; sorry about that. it's been repaired

[15:05] <audreyt> (just arrived to the hackathon site with wireless set up)

[15:06] <audreyt> evalbot will resume service shortly.

[15:07] <audreyt> http://svn.openfoundry.org/pugs/misc/pX/audreyt/hackathon-plan # some draft plan done on the car

[15:07] <audreyt> s/on/in/

[15:23] *** nothingmuch joined
[15:23] <audreyt> cool, the wifi extends to the cabin

[15:23] <nothingmuch> greetings from the hackathon

[15:23] <audreyt> though not the common room

[15:23] <nothingmuch> where is the common room?

[15:23] <nothingmuch> the one to the south?

[15:23] <audreyt> the one with the ping pong tables

[15:24] <nothingmuch> ooh

[15:24] <nothingmuch> where's that?

[15:24] <audreyt> I'll show you

[15:24] <GeJ> are you having a hackathon in a 80 rooms castle?

[15:25] *** Ovid joined
[15:26] <audreyt> we're not :)

[15:26] <audreyt> though the field is large-ish

[15:26] <nothingmuch> GeJ: this cabiny place

[15:26] <nothingmuch> hola Ovid 

[15:26] <audreyt> (I think, havn't completed the survey)

[15:26] <Ovid> Good morning all.

[15:27] *** gaal joined
[15:27] <audreyt> hey ovid

[15:27] <gaal> hola

[15:27] <Ovid> Morning Audrey.

[15:28] <nothingmuch> hola gaal

[15:28] <nothingmuch> this feels very sad

[15:28] <theorbtwo> Allo, crowd!

[15:28] <nothingmuch> i turn my head to the left and see that gaal is ignoring me

[15:28] <nothingmuch> but then i look slightly ot the right and see that he is in the wrong window

[15:28] <gaal> nothingmuch! hello!

[15:28] <nothingmuch> hi!

[15:28] <gaal> I'm so happy you're here

[15:29] <gaal> I'd not be here either

[15:30] * theorbtwo thinks p6-on-p5 should be called SF.

[15:30] <theorbtwo> 65->sixty-five->SF.

[15:30] <Qiang> howdy, audreyt . how is jerusalem ; )

[15:31] *** bsb joined
[15:31] <Arathorn> SF has too many sourceforge connotations...

[15:31] <theorbtwo> D'oh.

[15:31] <theorbtwo> We could call it sci-fi.

[15:41] *** gaal_ joined
[15:41] <Arathorn> how does p6-on-p5 via pugs tie in with Larry's p5-to-p6 translator (if at all)?

[15:43] <kolibrie> theorbtwo: p6-on-p5 -> 6/5 -> six-fifths (what a tongue twister)

[15:44] <spinclad> sxi-fvi

[15:44] *** xerox_ joined
[15:45] <spinclad> 6/5 -> a fifth again

[15:45] <spinclad> bartender! i'll have ...

[15:46] * theorbtwo likes "another fifth" as a name.

[15:52] <audreyt> Qiang: jerusalem has excellent dinner, otherwise I havn't spent time on it

[15:53] <audreyt> Arathorn: not tied at all at this moment

[15:53] <clkao> so when will we be able to use string eval in js backend?

[15:54] <xinming> p5++ :-P

[15:54] <clkao> i shall say how.

[15:54] <xinming> how about the name p5++ ?

[15:55] <stevan_> horray the hackathon has begun :)

[15:56] <theorbtwo> Hard to google for.

[15:56] <stevan_> audreyt: IIRC autobox.pm no longer needs a patch to perl :)

[15:56] <audreyt> yup, I discovered that too :)

[15:56] * audreyt has TAOMP with her as the only book brought to the hackathon

[15:57] <stevan_> :)

[15:59] <stevan_>  looks like a good plan though 

[15:59] <stevan_> hackathons++ 

[16:00] *** gaal_ is now known as gaal

[16:00] *** stevan_ is now known as stevan

[16:00] <nothingmuch> hola stevan 

[16:00] <stevan> heya nothingmuch 

[16:02] <stevan> audreyt: re: p6 over Class::MOP, I think that will be not too hard actually

[16:03] <stevan> I wrote up an example of changing method dispatch order the other day (http://search.cpan.org/src/STEVAN/Class-MOP-0.11/examples/C3MethodDispatchOrder.pod)

[16:03] <stevan> it is fairly straightforward

[16:03] *** dduncan left
[16:06] <audreyt> cool

[16:06] <stevan> audreyt: how far are you along in AMOP?

[16:08] *** hexmode joined
[16:10] *** fglock joined
[16:12] <fglock> hi all!

[16:12] <stevan> hey fglock 

[16:12] <fglock> hi stevan! are you in the hackaton too?

[16:13] <fglock> I wish I was there

[16:13] <stevan> fglock: yes, but not physically :P

[16:13] <fglock> :)

[16:13] <stevan> fglock: hackathons can have virtual participants too

[16:14] *** TMTOWTDIt joined
[16:15] <gaal> audreyt: hey, do you think a prim that dumps a Parse-YAML string programmatically is in order?

[16:24] *** r0nny joined
[16:34] <audreyt> gaal: sure, why not

[16:34] <audreyt> stevan: not far... ch3 I think

[16:35] <obra> 'morning

[16:36] <nothingmuch> everyone interested join hackathon, this is for administrative

[16:36] <nothingmuch> a

[16:37] *** justatheory joined
[16:38] <audreyt> nothingmuch means #hackathon

[16:38] <audreyt> (for administrative things)

[16:39] <svnbot6> r9093 | fglock++ | iterator_engine_p6regex.pl - rules now operate on 'str' instead of array of char

[16:48] <svnbot6> r9094 | fglock++ | iterator_engine_p6regex.pl - simplified internal API - rules are now almost plain-p5

[16:52] <fglock> changing emit_rule() to try to emit a p5 regex, and then fallback to code = very fast rules under p5

[16:52] *** vel joined
[17:00] <fglock> what is the syntax to call p5 code from within a rule? something like 'rule { xyz perl5:{ some_code } }'

[17:24] *** xerox_ joined
[17:50] *** rantanplan_ joined
[17:56] <nothingmuch> yes

[17:56] <nothingmuch> sorry

[17:59] *** as joined
[18:05] *** anatolyv joined
[18:05] <audreyt> fglock: "rule { xyz { v5; ... } }" perhaps

[18:06] <nothingmuch> glue( $gaal, $kolibrie );

[18:06] * gaal sticks

[18:07] *** vel joined
[18:07] <gaal> so, parsing Perl 6

[18:07] * kolibrie sticks

[18:07] <kolibrie> gaal: very gently, please, my haskell is almost nil, and parsing not much better

[18:07] *** xinming joined
[18:08] <kolibrie> but I very much want to learn

[18:08] <gaal> okay :) we use a library called Parsec

[18:08] <kolibrie> got that

[18:08] <gaal> the scary description for it is "monadic combinator parsing library"

[18:08] <gaal> ignore the monadic for a minute :)

[18:08] <gaal> combinator just means that it works by combining functions

[18:09] <gaal> let's look at a simple example

[18:09] <kolibrie> nothingmuch mentioned the monadic part automatically keeps track of where we were in the input

[18:09] <kolibrie> but that's it

[18:09] <gaal> yeah, ignore it for now

[18:09] * kolibrie ignores it for now

[18:10] * gaal looks for a rightly sized example

[18:10] <gaal> sec

[18:12] *** putter joined
[18:12] <gaal> okay, a really simple example in ruleHashSubscriptBraces

[18:12] <gaal> line 1515

[18:12] * kolibrie looks for it

[18:12] <gaal> between (symbol "{") (char '}') $ option id $ ...

[18:12] <fglock> audreyt: thanks

[18:13] <kolibrie> gaal: which file?

[18:13] <gaal> Parser.hs

[18:14] <gaal> so we're right in the middle of parsing perl

[18:14] <gaal> we're looking at the bit that parses out the {"moose"} in %myhash{"moose"}

[18:15] <gaal> I'll connect this to the big picture in a minute

[18:15] * kolibrie arrives at line 1515

[18:16] <putter> fglock: rule { ... [:perl5:: this is p5 ] ... }

[18:17] <putter> or [:perl5(1) this is perl5 ]

[18:17] <gaal> the parser is trying for example to look at something like my $elk = %myhash{"moose"}

[18:18] <kolibrie> ok

[18:18] <fglock> putter: what does (1) mean in :perl5(1) ?

[18:18] <gaal> and at among other things it wants to distinguish between "my $elk = %myhash" (which assings a reference to the hash into $elk) and what the programmer really meant, which is to look up a value *in* the hash and assign that to $elk.

[18:19] <gaal> so suppose our current position is just after the identifier %myhash

[18:19] <gaal> if we succeed in parsing this ruleHashSubscriptBraces, this will indeed be a hash lookup

[18:20] <kolibrie> so the next character is '{'

[18:20] <gaal> if not, and ruleHashSubscriptBraces fails, then whoever called it will try something else; for example, if it hits the sentence end then the assignment is for the hashref like we said

[18:20] <gaal> so yes

[18:20] <gaal> the next character is '{'

[18:21] <gaal> but the code says between (symbol "{") (char '}') ...

[18:21] <gaal> which is a fancy way of setting up "expect '{' now, then -- hold on I'll tell you in a second, -- and THEN a closing brace

[18:21] <putter> :foo is a "normal" modifier.  its argument defaults to 1.  so :foo is equiv :foo(1).  in a regexp, you have to figure out where the modifier ends. eg, in /:perl5aa/, is that a :perl5aa modifier and no content, a :perl5a modifer on "a", a... etc.  so you can either have the explicit argument list, or use :: which at the beginning of a group is a no-op, and can't be misinterpreted as part of the modifier.

[18:22] <gaal> and then indeed say what was supposed to go inside the braces

[18:22] <gaal> kolibrie: in the Haskell syntax level, it works like this

[18:22] <fglock> putter: thanks!

[18:22] <gaal> between A B C

[18:23] <gaal> in this case A == (symbol "{")

[18:23] <gaal> B == (sumbol "}")

[18:23] <gaal> and C is the rest of the function

[18:23] <kolibrie> so we are defining the beginning and ending of the input we are examining, and then looking at the stuff in between

[18:23] <gaal> inded. this demonstrates something nice about parsec, which is how you can compose rules out of simpler ones

[18:24] <putter> two random sidebar thoughts: with custom re, it should be possible to do <subrules> in normal p5 regexps.  calling out to qr returning subs.  so full grammars.  they wouldn't capture, and their implementations are constrained, but hey.

[18:24] <putter> random other thought: do each p5 thread get its own regexp engine?  if so, one could hack around non-reentrancy. ;)

[18:24] <gaal> kolibrie: if for some reason the opening part of the syntactic rule we wer parsing were much more complex than "{", we could have called a named function that parses for it

[18:24] <putter> but those are both fish for another fry.

[18:25] <gaal> in fact, we already do that -- 'symbol "{"' is a function call too!

[18:25] <kolibrie> ok

[18:25] <gaal> symbol is a function inside parsec

[18:26] <gaal> now lets zoom up for a second and see who called us

[18:26] <bsb> putter,I have someting for you http://www.perlmonks.org/index.pl?node_id=531465

[18:26] <gaal> (since we are a reusable function, maybe more than one guy does)

[18:26] <bsb> although it's probably too late

[18:26] <gaal> but no! just ruleHashSubscript does :)

[18:27] <gaal> however ruleHashSubscript can be called from several places :-)

[18:27] <fglock> putter: would you take a look in iterator_engine_p6regex.pl later?

[18:27] <gaal> kolibrie: one of them is for example qInterpolatorPostTerm

[18:28] <kolibrie> gaal: and the 'choice' in ruleHashSubscript is like 'any'

[18:28] <gaal> which is what's responsible for "this is a stirng containing %myhash{'moose'} interpolated in it!"

[18:28] <gaal> kolibrie: yes

[18:29] <gaal> it tries to parse with the first rule, and if that fails, it backtracks and tries the next one in the list of choices

[18:29] <kolibrie> and we have several of those in qInterpolatorPostTerm

[18:29] <gaal> "option" is similar to choice -- it means "try mathching with this rule. but if you don't succeed, that's okay too"

[18:30] <gaal> oh indeed

[18:30] <gaal> they are tried in order - which can be significant of coures

[18:31] <kolibrie> so in 'choice', a match must occur, and 'option' means it could be there

[18:32] <gaal> yes. option x   is like    choice [x, nothingAtAll]

[18:32] <kolibrie> ok

[18:32] <gaal> of course, if a rule did match, it consumes its input

[18:33] <kolibrie> and if it fails, it returns to where it left off and tries the next item

[18:33] <gaal> so on the consumption direction, what we have is lots of rules that eat up the input, occasionally backtracking a bit and trying a different route...

[18:34] <putter> bsb: ooo, neat :)

[18:34] <gaal> if the failure goes all the way up and there's no way to parse, the user gets an error

[18:34] <putter> bsb++

[18:34] <kolibrie> right

[18:34] <gaal> usually it goes three steps in, two steps out, and so on, until everything is consumed

[18:34] <gaal> (for some values of two and three)

[18:35] <gaal> so actually ordering the rules cleverly can have impact on preformance... but nevre mind that :)

[18:35] <gaal> but i was saying

[18:35] <putter> have to think about that.  but first, the new regex engine.  the case for using a flexible parser for OnPerl5 is a lot stronger if one actually exists. ;)

[18:36] <gaal> this is the consumption direction. what do we want out of the parser?

[18:36] <putter> very neat

[18:36] <gaal> we want a tree structure: AST, or parse tree

[18:36] <kolibrie> verily

[18:36] <putter> fglock: looking...

[18:36] <gaal> let's digress for a sec and see an example of that

[18:37] * kolibrie follows gaal's digression

[18:38] <gaal> run this please:

[18:38] <gaal> ./pugs -CParse-YAML -e 'if 42 { say "hi" } else { say "oops" }'

[18:38] <gaal> pipe it through less :)

[18:39] <gaal> and ignore completely the hs/MkPad bit

[18:39] * kolibrie sees nifty YAML

[18:39] <gaal> jump straight to hs/Stmts

[18:39] <gaal> line 22

[18:39] <svnbot6> r9095 | fglock++ | iterator_engine_p6regex.pl - rule::capturing_group hack

[18:41] <kolibrie> gaal: I see that at the very top, I think

[18:41] <gaal> intuitively we know we ought to have an if with the true case code under it, and the else case code under it also

[18:41] *** elmex joined
[18:41] <gaal> kolibrie: you don't see !hs/MkPad and then !hs/Map? that's... a bug :)

[18:42] <kolibrie> oh well, I'm a few revisions behind

[18:42] <kolibrie> should I play on feather?

[18:42] <gaal> okay, cool

[18:42] <gaal> no no

[18:42] <gaal> yours is the info we need now

[18:42] <gaal> so

[18:42] <gaal> from hs/Stmts

[18:43] <audreyt> macro use_ok ($module) is export {

[18:43] <gaal> (hs/ is a serialization detail, ignore it now)    Stmts

[18:43] <audreyt>     require $module :COMPILING;

[18:43] <audreyt>     KEEP { return CODE { &OUR::proclaim(1) } }

[18:43] <audreyt>     UNDO { return CODE { &OUR::proclaim(0) } }

[18:43] <gaal> ooooh multiplexing

[18:43] <audreyt> }

[18:43] <audreyt> # weird implementation of use_ok

[18:43] <putter> fglock: same suggestion as before I think: get set up to do testing.  two reasons - the domain is complex enough to forget about screw cases which constitute constraints on large-scale architecture; and two, performance really matters on this, and so also constitutes an architectural constraint.  the easiest way to deal with both is to run tests...

[18:43] <gaal> kolibrie: so, we have a satement list

[18:44] <gaal> the first statement is a Syn

[18:44] <gaal> of type if

[18:44] * kolibrie follows along

[18:44] <gaal> the if has a condition, a true-case, and an else-case

[18:44] <fglock> putter: right

[18:45] <gaal> the condition in this case is a very simple expression - just a value

[18:45] <putter> random other thoughts if you'd like them.  rule::foo might be better rule__foo or foo__rule (easier to attach) so the normal package inheritance works with them.

[18:45] <gaal> but it could have been more complex, that is more deedp

[18:45] <putter> grammars for free :)

[18:46] <kolibrie> gaal: so that gets us to the 42

[18:46] <gaal> if you look at the true-case, you see (among the noise) some stuff which is certianly the AST for 'say "hi"'

[18:46] <gaal> but it's easier to put this data aside for a minute and look at what _can_ come in the tree

[18:46] <kolibrie> oh, way down there

[18:47] <gaal> please go to Pugs.AST.Internals

[18:47] <gaal> line 946

[18:47] <gaal> data Exp

[18:47] * kolibrie moves to other file

[18:48] <putter> fglock: alternation is first match (not longest).  though we need a separate longest match for tokens.

[18:49] * kolibrie arrives at line 946

[18:49] * putter follows kolibrie

[18:49] <gaal> kolibrie: okay, this is the succinct definition of a Pugs AST node

[18:50] <gaal> it's a recursive definition, so anything from a lowliest value to a complete program can be expressed with it

[18:50] <gaal> side by side with the YAML dump -

[18:50] <fglock> putter: ok

[18:50] <gaal> we had "if 42"

[18:50] <gaal> the 42 is a

[18:50] <gaal> well, not lowly

[18:51] <gaal> but it's just a value

[18:51] <gaal> so line 957

[18:51] * kolibrie sees it

[18:51] <gaal> one of the variants in Exp is Val

[18:51] <gaal> and this is indeed what we have in the yaml:

[18:52] * putter runs off to code..

[18:52] <gaal> - !hs/Val : - !hs/VInt : - 42

[18:52] <gaal> if you excuse my ad-hoc yaml onelinerization

[18:52] <gaal> which is bogus 

[18:53] <gaal> but anyway

[18:53] <kolibrie> I understood it

[18:53] <gaal> the condition happens to be a Val (which is a *kind* of Exp)

[18:54] <gaal> do you know enough haskell to understand the type of the Val variant?

[18:54] <gaal> it's a little confusing:

[18:54] * kolibrie thinks not

[18:55] <gaal> there's a type called Val, which doesn't immediately have anything to do with the variant Val - it's a pun

[18:55] <gaal> we could have renamed this to something like this:

[18:55] <gaal> data Value = ....

[18:56] <gaal> data Exp = .. .. | ValNode Value

[18:56] <gaal> ValNode is a constructor

[18:56] <gaal> it takes a Value, and returns and Exp

[18:56] <kolibrie> type has to do with what kind of data is held?  and variant?

[18:57] <gaal> data types in haskell are a like unions in c

[18:57] <gaal> a thing of type Exp is actually

[18:57] * kolibrie never did c :(

[18:57] <gaal> either a ValNode

[18:57] <gaal> or a FunctionApplication

[18:58] <gaal> or a SyntaxThingie

[18:58] <gaal> but a function can be polymorphic and accept any kind of Expat all

[18:58] <audreyt> hm, I really want :$foo now

[18:59] <gaal> kolibrie: am I making any sense? :)

[18:59] <kolibrie> so a Value is something simple, and an Exp may be made of multiple things

[19:00] <gaal> yes, Value is a final kind of ting, say a number or a string

[19:01] <gaal> but a FunctionApplication is a more complex thing

[19:01] <gaal> it needs to contain who's the function that's being called and what its arguments are

[19:01] <gaal> but they're both expressions

[19:02] <putter> puns in code --

[19:02] <gaal> so in the Exp data structure we indeed see this

[19:02] <gaal> instead of FunctionApplication it's spelled App

[19:02] <gaal> and it goes like this:

[19:02] <gaal> App Exp (Maybe Exp) [Exp]

[19:03] <gaal> WeAreApplyingAFunction Name (it might have an invocant) [arglist]

[19:03] <gaal> say "moose"

[19:04] <gaal> App "&say" Nothing [ (Val (VStr "Moose")) ]

[19:04] <gaal> see the correspondence?

[19:05] * kolibrie catches up after an interruption

[19:05] <gaal> nothing just means this is a function call, not a method invocation

[19:06] <putter> (for extra credit, ;)  someone should capture gaal's exposition to help other people spin up...)

[19:06] *** justatheory joined
[19:06] <gaal> putter: it will be slidified and incorporated in my coming osdc talk. I really have to thank kolibrie for nudging me about this so soon :-)

[19:06] * kattana_ spins

[19:07] *** kattana_ is now known as Kattana

[19:07] <putter> or at least drop a link to the irc log in someplace.  wish we had done that with some of audreyt's old expositions, now buried in the log...

[19:07] * kolibrie thanks kolibrie for helping him, too

[19:07] <kolibrie> I mean, gaal

[19:07] <putter> :)

[19:08] <gaal> kolibrie: so, I mentioned a method invocation

[19:08] <gaal> let's spell it in that style:

[19:08] <gaal> "moose".say

[19:08] <audreyt> oh well, instead of moosing around I'll just go implement $:foo

[19:08] <gaal> that parses as

[19:09] <gaal> App "&say" (Just (Val (VStr "moose"))) []

[19:09] <gaal> it happens to mean the same ultimately, but the parse tree is different as you can see

[19:09] <kolibrie> the one is called with a Val

[19:10] <gaal> there are no args, but the invocant is a the moose

[19:10] <kolibrie> the other is invoked from a Val

[19:10] <gaal> yes

[19:10] <gaal> note the [] at the end of the second AST

[19:10] <kolibrie> indicating no args

[19:10] <gaal> indeed.

[19:11] <gaal> Just and Nothing, btw, are haskellish things

[19:11] <kolibrie> Nothing kind of makes sense, Just is a little harder

[19:12] <gaal> nevre mind the details, but Nothing is like a... null pointer

[19:12] <gaal> just means "it's not a null pointer, it's a..."

[19:12] <gaal> it looks tiresome, but it's actually useful, because you can' have Just Nothing

[19:13] <gaal> nothing and something can be distinguished in places that care about them

[19:13] * putter tries to remember what $:foo is... finds ':' hasnt reached the twigle table in S02...

[19:13] <kolibrie> couldn't that just be Nothing, without the Just?

[19:14] <gaal> yes, the type is called Maybe (look in the code again)

[19:14] <kolibrie> oh, 'Just' means 'something'

[19:14] <audreyt> putter: :$foo, sorry

[19:14] <audreyt> not $:foo

[19:15] <audreyt> typo

[19:15] <putter> ahhhhh

[19:15] <putter> ;)

[19:15] <audreyt> (and I've got it implemented)

[19:15] <gaal> (Maybe Exp) can be an Exp

[19:15] <gaal> and code that handles that type know it can be Nothing

[19:15] <putter> re Just/Nothing, think data field with a one bit flag indicating whether the data field is valid.  invalid gets presented as "Nothing".  valid as "Just(whatever)".

[19:15] <gaal> if they ignore the possibility and just look at the Exp, they get a compiler error :-)

[19:16] <gaal> well, in some cases, a warning

[19:16] <kolibrie> so Maybe indicates the value may be defined or undefined

[19:17] <gaal> but you can in fact write your code knowing that you are liable to forget to check for null pointers occasionally, and and then it won't compile until you remember. or something

[19:17] <putter> Maybe Foo is just the way of declaring this a data field of type Foo, plus this bit.  re def/undef, yes

[19:17] <gaal> kolibrie: for our purposes, "an optional invocant" is good enough

[19:17] <kolibrie> ok

[19:18] <gaal> but the Maybe type has good implications on code quality, so don't purge it from your consciousness

[19:18] <svnbot6> r9096 | fglock++ | iterator_engine_p6regex.pl - tests with Test::More - putter++

[19:19] <gaal> sooo where were we

[19:19] <kolibrie> Pugs/AST/Internals.hs shows a grammar of sorts?

[19:19] <gaal> ah yes

[19:20] <gaal> which was because, like we saw, the various functions in Parser all return... an Exp !

[19:20] <kolibrie> ahh

[19:21] <kolibrie> and we define what Exp is

[19:21] <gaal> so now we can tie up the "combinator" part of the description we gave to Parsec

[19:21] <gaal> each funciton *is* a parser

[19:21] <gaal> typically a small one

[19:22] <kolibrie> and that is in Pugs/Parser.hs

[19:23] <gaal> if you ever write a language of your own, and you need in part of it to parse { ...smthing... }

[19:23] <gaal> you can reuse our code! :-)

[19:24] <gaal> ruleHashSubscriptBraces *is* a parser that tries to match a hash subscripted with braces

[19:24] <gaal> and returns the AST for it

[19:24] <gaal> whoever called us uses us and expects an AST back, or failure

[19:25] <gaal> if the failure happened inside a "choice", parsec silently tries the next option

[19:25] *** marmic joined
[19:25] <gaal> if not, eventually that may fail the entire parse, like we said earlier

[19:26] <kolibrie> so the AST is defined in Pugs/AST/Internals.hs, and the mini parsers in Pugs/Parser.hs

[19:26] <svnbot6> r9097 | audreyt++ | * Implement :$foo in its various capacities as shorthand for (foo=>$foo):

[19:26] <svnbot6> r9097 | audreyt++ |     :$var.kv;           # pair object

[19:26] <svnbot6> r9097 | audreyt++ |     function(:$foo);    # named arg

[19:26] <svnbot6> r9097 | audreyt++ |     m:$nth/.../;        # adverb

[19:26] <svnbot6> r9097 | audreyt++ | * :$.property and :$Fully::Qualified::name both work; the latter is

[19:26] <svnbot6> r9097 | audreyt++ |   desugared with "name" as the key.

[19:27] <gaal> ok, now actually i lied

[19:27] <gaal> this particular parser doesn't return an AST

[19:27] <gaal> it returns an AST transformer

[19:27] <gaal> which is less scary than it sounds :-)

[19:27] <gaal> btw the others here are losing connectivity

[19:27] <gaal> so sorry if i drop

[19:27] <gaal> heh, they seem to have it back :-)

[19:27] <kolibrie> (connectivity)++

[19:31] * kolibrie wonders if connectivity at the hackathon has truly been interrupted

[19:31] <gaal> if you scan the signatures in Parser you see more simple ones too

[19:32] <gaal> do grep '^.*::' on that file to see all its sigs

[19:32] <gaal> (sec)

[19:32] <gaal> back

[19:32] <gaal> for example ruleRuleDeclaration is one of those simplier-typed parsers

[19:33] <gaal> it does return some kind of AST node

[19:33] <gaal> you can tell because it has the type 

[19:33] <gaal> ruleRuleDeclaration :: RuleParser Exp

[19:33] <gaal> the RuleParser part is the monad stuff (which we're still in denial of)

[19:33] <gaal> bottom line, you have an Exp

[19:34] <kolibrie> ok

[19:34] <gaal> in our ruleHashSubscriptBraces, you have (Exp -> Exp)

[19:34] <putter> audreyt++ # dynamic pairs!

[19:34] *** sili joined
[19:34] <gaal> which means it returns that takes one Exp and yields another

[19:35] <gaal> which is precisely what I mean by "Exp transformer"

[19:35] <kolibrie> ah

[19:35] <gaal> like if you had a function that doubles its integer input, you'd call it "double", but more genreally you'd say it's an integer transformer

[19:36] <gaal> okay, why would we need that?

[19:36] <gaal> here, that is?

[19:36] <rep> http://support.microsoft.com/kb/314458/EN-US/

[19:37] *** bernhard joined
[19:37] <kolibrie> we want to know whether we are interested in the hash, or the value in the key

[19:37] <svnbot6> r9098 | fglock++ | iterator_engine_p6regex.pl - added many tests

[19:37] * putter wonders if there is a timing/pacing to exposition which would allow it to be mechanically recognized in the irc log...

[19:37] <gaal> well, if this rule succeeded, we *do* have a subscirpt

[19:38] <kolibrie> so we may have to change the AST to point to the correct value

[19:38] <gaal> we want to let our caller do some AST munging

[19:38] <gaal> so we give them a closure that does it in the proper way!

[19:39] <gaal> ruleHashSubscriptBraces A B C

[19:39] <gaal> ruleHashSubscriptBraces open close middleBit

[19:39] <gaal> oops

[19:39] <gaal> between A B C

[19:39] <Kattana> putter: the bantar back and forth seems to have a certain tone to it, gaal obviouly leading the convo, lots of vertical spam from him

[19:39] <gaal> lumi++

[19:39] <putter> ok... so what grammars for p5 or p6 regexp do folks know of...?  putter is boiling up a stew...

[19:39] <gaal> (online copyediting)

[19:40] <gaal> between A B C

[19:40] <gaal> C's the interesting but

[19:40] <gaal> in this case it's

[19:40] <gaal> option id $ do

[19:40] <gaal>     exp <- ruleExpression; return $ \x -> Syn "{}" [x, exp]

[19:40] <gaal> which means:

[19:40] <gaal> option FALLBACK RULE

[19:40] <gaal> if RULE fails, return FALLBACK

[19:41] <gaal> "id" is the identity function

[19:41] <gaal> in Perl 6:   sub ($x) { $x }

[19:42] <audreyt> in Perl 6: {$^x}

[19:42] <gaal> so that's like a transformer that... doesn't transform much :)

[19:42] <gaal> audreyt: :)

[19:43] <kolibrie> which part is the FALLBACK, and which the RULE?

[19:43] <gaal> when would that happen?

[19:43] <gaal> as in the order I gave

[19:43] <gaal> option (fallback: id) (rule: the rest)

[19:44] <gaal> the rest in this case is:

[19:44] <svnbot6> r9099 | audreyt++ | * Test.pm: Change :depends($depends) and :todo($todo) etc to

[19:44] <svnbot6> r9099 | audreyt++ |   :$depends and :$todo etc.

[19:44] <kolibrie> if RULE succeeds, return the 'return' part

[19:44] <gaal>     exp <- ruleExpression

[19:44] <gaal>     return $ \x -> Syn "{}" [x, exp]

[19:45] <gaal> ignoring monads again - the first line means we're going to do a ruleExpression

[19:46] <kolibrie> the 'return' part is the rule?

[19:46] <gaal> that's a pretty general parser that looks for SOME kind of expression

[19:46] <elmex> elmex--

[19:46] <gaal> no, they're both part of the rule

[19:46] <gaal> they both _are_ the rule

[19:46] * kolibrie sighs

[19:47] <lumi> ruleExpression is the name of a parser that parses, curiously enough, an expression; we're tryign to match it, and if it matches, "exp" will have its return

[19:47] <gaal> ... and if it doesn't, the current twoline parser will.. fail

[19:47] <gaal> meaning the "option" will return "id"

[19:48] <kolibrie> so part of this particular rule is to call a parser called ruleExpression

[19:48] <lumi> Yep, and save its return

[19:48] <kolibrie> whose return value will go into exp

[19:48] <gaal> but if exp does get bound successfully to some expression, we (and our whole function) result in

[19:48] <gaal> \x -> Syn "{}" [x, exp]

[19:48] <gaal> which is haskell for

[19:49] <gaal> p5: sub { Syn "{}" [ $_[0], exp }

[19:49] <gaal> well, for some value of p5

[19:50] <svnbot6> r9100 | fglock++ | iterator_engine_p6regex.pl - implemented non-capturing group

[19:50] <putter> misc/Grammars/rx_grammar.pl,  the prolog engine, parrot's compilers/pge/P6Rule.grammar and pge/PGE/*.pir, src/Text/Parser/Rule.hs, ... am I forgetting anything?

[19:50] <gaal> the idea is we return a closure that takes SOME x, and wraps it in a Syn node

[19:51] <kolibrie> so 'x' is what got passed to us, the original Exp

[19:51] <gaal> what's the type of x?

[19:51] <gaal> exactly: and there are two ways to deduce that

[19:51] <gaal> one is our type:

[19:51] <gaal> (Exp -> Exp)

[19:52] <gaal> we know we return a function that gets an Exp and returns one

[19:52] * Kattana has not had trouble following whats going on but not knowing haskell makes the details of what is happening unclear

[19:52] <gaal> btw: if we were successful, we even know that the resulting Exp is in fact a Syn

[19:52] *** nothingmuch joined
[19:53] <gaal> but we can't say we're Exp -> Syn, beucase in the case that we fail, we return id

[19:53] <kolibrie> oh, so given Exp 'x', we create a Syn "{}"

[19:54] <gaal> and our poor caller may hand the closure we gave him any Exp at all

[19:54] <gaal> exactly

[19:54] <kolibrie> and the [x, exp]?

[19:54] <gaal> the other way we can reason that x must be an x is how we are using it inside the closure:

[19:55] <putter> Kattana: if you hang microphones on people, you can tell all sorts of stuff about group dynamics, just by looking at the strip chart of who is talking when... :)

[19:55] <gaal> the haskell expression Syn "{}" [x, exp]

[19:55] <gaal> (look at AST.Internals again)

[19:55] <gaal> is a "constructor" for Exp

[19:55] <fglock> putter: looking (I'm writing the grammar using A05)

[19:56] <gaal> it is Syn String [Exp]

[19:56] <gaal> that is:

[19:56] <gaal> it takes a string

[19:56] <gaal> and a list of Exp

[19:56] <gaal> .... and returns an Exp of the Syntax variant

[19:57] <gaal> which, if you are familiar with haskell type signature, looks like

[19:57] <gaal> Syn :: String -> [Exp] -> Exp

[19:57] <kolibrie> the string is "{}" and the list of Exp is [x, exp]

[19:58] <gaal> exactly!

[19:58] <gaal> in our closure, we can't know much more about x

[19:58] <gaal> there is one more detail

[19:58] <gaal> how can this possibly fail?

[19:59] <gaal> well, one way is that there's a totally bogus expression in between the braces

[19:59] <gaal> %myhash{this can't parse, can it?}

[20:00] <kolibrie> so then the ruleExpression fails?

[20:01] <gaal> sure, but eventually that means the whole program will fail parse

[20:01] <kolibrie> so ruleExpression is very generic

[20:02] <gaal> because in THAT case, we will not have consumed our input till after the braces, and eventually the parse error will propagate up.

[20:03] <gaal> when can this option do the fail case legitiamately?

[20:03] <gaal> in the empty case:

[20:03] <gaal> %myhash{}

[20:04] <putter> fglock: might be better or using P6Rule.grammar

[20:04] <kolibrie> oops!  I have a meeting at work.  Be back in 30 min?

[20:04] <gaal> sure

[20:04] <audreyt> eg. print "The associations are:\n%bar<>"

[20:04] <putter> s/or/off

[20:05] <audreyt> (that's subtlte for the realspace soundtrack from lwall)

[20:06] <Juerd> audreyt: Great that you got your .de visa; I'm looking forward to meeting you again.

[20:10] <audreyt> Juerd: woot

[20:11] <Juerd> The only thing I have to bribe dieties for still is my car. A repair attempt is done tomorrow; if it fails, I'll have to fix a plan B.

[20:11] <Juerd> deities.

[20:12] <Juerd> More correct and more symmetrical :)

[20:13] *** sili joined
[20:13] <svnbot6> r9101 | fglock++ | iterator_engine_p6regex.pl - alternation (not working yet)

[20:20] <gaal> a2

[20:22] * kolibrie returns

[20:22] <gaal> hello

[20:22] <gaal> soo

[20:23] <gaal> just to sum up the parse options:

[20:23] <putter> audreyt: re hackathon plan... imports! :)

[20:23] <gaal> either we have %myhash{42}

[20:23] <gaal> or actually, %myhash{ $a + $b ~ "abcde" }

[20:24] <gaal> (these are all %myhash{ some Expression }

[20:24] <gaal> )

[20:24] <gaal> OR

[20:24] <kolibrie> right

[20:24] <gaal> we can have %myhash{}

[20:24] <kolibrie> then Exp is Nothing

[20:25] <gaal> which as larry explains, is useful in interpolations where you want the whole hash:

[20:25] <gaal> "myhash is %myhash{}"

[20:25] <gaal> (because you can no longer say "%myhash" in a string and have it interpolate)

[20:25] <gaal> no, not Nothing

[20:26] <gaal> if the line

[20:26] <gaal> exp <- ruleExpression

[20:26] <gaal> then the whole twoliner action " exp <- ruleExpression ; return .... " fails

[20:26] <gaal> a bit like an exception

[20:27] <gaal> and that's when "option" will fall back on "id"

[20:27] <gaal> (um, if that line _fails_ then the action fails)

[20:28] <kolibrie> so, if there is no value between the braces, the ruleExpression fails, so the RULE fails, and FALLBACK is returnd

[20:30] <gaal> yes: but the function ruleHashSubscriptBraces as a whole succeeds

[20:30] <svnbot6> r9102 | fglock++ | iterator_engine_p6regex.pl - reimplementing using P6Rule.grammar

[20:30] <kolibrie> yes

[20:30] <kolibrie> and if no braces follow %myhash, then ruleHashSubscriptBraces fails

[20:30] <gaal> the only way ruleHashSubscriptBraces can fail is if some

[20:30] <gaal> exactly :)_

[20:31] * kolibrie almost feels like he understands

[20:31] <gaal> cool

[20:31] *** justatheory joined
[20:32] <audreyt> ?eval 

[20:32] <evalbot_9084> No code to eval given.

[20:32] <audreyt> ?eval 1

[20:32] <evalbot_9084> 1 

[20:33] <gaal> so

[20:33] <gaal> whoever called us will get one of three cases

[20:34] <gaal> either a Syn {} wrapper closure

[20:34] <gaal> or a noopish transformer

[20:34] <gaal> or failure

[20:35] <gaal> if failure, then our caller can either deal with it (via a "choice" or something similar, which expects it),

[20:35] <gaal> or *they* will fail as well.

[20:35] <svnbot6> r9103 | audreyt++ | * Makefile.PL:

[20:35] <svnbot6> r9103 | audreyt++ | * don't build readline on GHC 6.4.0 as Linux doesn't like it,

[20:35] <svnbot6> r9103 | audreyt++ |   as reported (again) by anatolyv.

[20:35] <svnbot6> r9103 | audreyt++ | * Parrot has changed the build_dir key to top_builddir for

[20:35] <svnbot6> r9103 | audreyt++ |   autoconf compatibility; chase it in our parrot probe code.

[20:35] <svnbot6> r9103 | audreyt++ |   Reported by lwall.

[20:35] <kolibrie> a noopish transformer is when the id is returned?

[20:36] <gaal> yes. in simpler rules, typically the return value is an AST node

[20:36] <gaal> we saw an example of that, but didn't analyze it very thoroughly

[20:36] <Juerd> audreyt: Is PID 23877 on feather doing something useful, or in some kind of infinite loop?

[20:36] *** calanya joined
[20:37] <gaal> you can indentify what it returns by looking at the function sig

[20:37] <gaal> in Pugs, all our top-level functions have signatures

[20:37] <gaal> (that's not required by haskell, but it's considered good form)

[20:38] <audreyt> ?eval  sub f (:$x is copy) { $x ?? $x-- * f(:$x) !! 1 } f(:x(10))

[20:38] <evalbot_9084> Error:  unexpected "f" expecting term not a class name or Only one invocant allowed 

[20:38] <kolibrie> and helps newbies

[20:38] <audreyt> Juerd: the latter; it's now dead.

[20:39] <gaal> it helps everyone, because you can quickly scan the whole project for things that behave in certain ways

[20:39] <Juerd> audreyt: Okay, thanks

[20:39] <gaal> there's an in credibly useful tool for haskell hackers called hoogle

[20:39] <gaal> http://haskell.org/hoogle/

[20:39] <gaal> try it out: say "a -> [a]" there

[20:40] * kolibrie tries

[20:40] <gaal> it gives you standard haskell funcs that take something of type a and yield a list of elements of that type

[20:41] <gaal> the topmost hit is "repeat"

[20:41] <gaal> reapeat 5 = [5, 5, 5, 5, 5, 5, .....]

[20:41] <Juerd> repeat sounds like exactly the right name for such a function

[20:42] <gaal> the others hits are less exact matches, for good reasons that will become clear after some haskell hacking :)

[20:42] <audreyt> unlike, say, onAndOnAndOn

[20:42] <gaal> banana

[20:43] <kolibrie> how does the AST know when to be flat, and when have more depth?

[20:43] <anatolyv> or InfiniteListOfEntitiesAllCopiesOfTheSameArgument

[20:43] <gaal> if you look for "a -> Int -> [a]", you'll see it first gave you something of type "Int -> a -> [a]"

[20:44] <gaal> replicate, which is defined as \n x -> drop n (infiniteListOfEntitiesAllCopiesOfTheSameArgument x)

[20:44] <Juerd> audreyt: onAndOnAndOn is too finite :) Hm, does Haskell have infinite identifiers? :)

[20:45] <gaal> Juerd: it does if you use DrIFT

[20:45] <Juerd> That's just scary

[20:45] <gaal> also not true

[20:45] <gaal> I was just pulling your moose

[20:45] <nothingmuch> a -> Int -> [a] is just take . repeat

[20:45] <audreyt> ?eval 1

[20:45] *** evalbot_9084 is now known as evalbot_9086

[20:45] <evalbot_9086> 1 

[20:45] <gaal> errr, yes, take, not drop

[20:45] <gaal> thank you nothingmuch 

[20:46] <gaal> but I was avoiding pointfree style for exposition value

[20:46] <nothingmuch> we need a flip somewhere

[20:46] <audreyt> ?eval sub f (:$x is copy) { $x ?? $x-- * f(:$x) !! 1 } f(:x(10))

[20:46] *** evalbot_9086 is now known as evalbot_9103

[20:46] <evalbot_9103> 3628800 

[20:47] <gaal> kolibrie: as you can see sometimes it's almost obvious what a function does just by looking at its sig

[20:47] <nothingmuch> flip $ (flip take) . repeat

[20:47] <kolibrie> gaal: almost obvious

[20:48] <gaal> nothingmuch: "somewhere"? forM = flip mapM

[20:48] <clkao> did someone fix the smoke-think-its-release problem?

[20:48] <nothingmuch> gaal: ?

[20:48] <audreyt> clkao: I wasn't aware of that

[20:48] <clkao> see the smoke report, first entry.

[20:48] <clkao> i smoked that last night with trunk, but it thinkgs itself as a relesae 

[20:48] <gaal> I was kidding :) 

[20:48] <gaal> anymoose:

[20:48] <putter> fglock: just don't believe everything you read in P6Rule.grammar...

[20:49] <gaal> so now you know how much of parsec works!

[20:49] <kolibrie> truly

[20:49] <gaal> there's also operators, and this whole monad side to it which we haven't talked about

[20:49] <fglock> putter: oh, ok :)

[20:49] <gaal> but this is enough to see how pugs parses something

[20:49] <audreyt> clkao: hmm -- I'm out of tuits now maybe se if nothingmuch or gaal or other hackathoners can help

[20:49] <kolibrie> if I want to try it out, a 'hello world' sized one, what do I need?

[20:50] <gaal> there's also the tool -CParse-YAML that you can see the result of the parse with

[20:50] <clkao> audreyt: what are you hacking on atm?

[20:50] <gaal> kolibrie: you mean you want a standalone parser for your own minilang?

[20:50] <audreyt> clkao: sundry and various

[20:51] <gaal> parseTest can help with that

[20:51] <kolibrie> gaal: something like that, so I can make sure I understand

[20:51] <audreyt> clkao: http://svn.openfoundry.org/pugs/misc/pX/audreyt/hackathon-plan

[20:52] <audreyt> I'll probably journal about what's being done here on tomorrow morning; if I do it now it'll be overlapping, incoherent and undecidable

[20:52] <clkao> Should "Perl 5 as a runtime" have a name - surely pXnie!

[20:52] <obra> clkao: stallion

[20:52] <audreyt> why is everybody fixated over the p.nie bitmask?

[20:53] <clkao> because it looks like PIE?

[20:53] <obra> because it's punny

[20:53] <gaal> kolibrie: http://www.cs.uu.nl/~daan/download/parsec/parsec.html and look for parseTest on that page

[20:54] <gaal> kolibrie: I have to go now, we can continue tomorrow :-)

[20:55] <kolibrie> gaal: thank you very much

[20:55] <clkao> audreyt: what do you have in mind for the JS.pm entry in javascript?

[20:55] <clkao> btw there's js::pp and js::code

[20:55] <kolibrie> gaal: I'll play with this a little bit and probably have more questions tomorrow

[20:57] <clkao> hmm json-based seperate compilation.. doesn't the compiler has be compiled into js?

[20:57] <gaal> kolibrie: np :)

[20:58] <clkao> i need a braindump from someone i guess.

[20:59] <Juerd> obra: Oh, Stallion's harsh :)

[20:59] <Juerd> obra: Funny, though

[21:10] *** hexmode joined
[21:11] *** calanya left
[21:15] * putter ponders the consequences of the the character-class-sublanguage engine assuming some rule correctly/non-buggily matches a single character... and being wrong.

[21:16] <svnbot6> r9104 | fglock++ | iterator_engine_p6regex.pl - implemented '<term>*' - documented bugs

[21:20] <fglock> putter: current plan is to finish a minimal compiler that can read P6Rule.grammar; then maybe improve the emitter so it can be tested

[21:24] <putter> fglock: neat

[21:25] <putter> testability++

[21:25] *** larsen joined
[21:31] <svnbot6> r9105 | fglock++ | iterator_engine_p6regex.pl - warnings cleanup

[21:32] *** KingDiamond joined
[21:32] *** fglock left
[21:37] *** r0nny joined
[21:54] *** SamB joined
[22:34] *** rafl joined
[22:42] *** penk left
[22:53] *** Lord-Dark joined
[22:54] <Lord-Dark> 8,2Lalalallalaa

[22:54] <Lord-Dark> 8,2Je Parle

[22:59] *** Lord-Dark left
[23:11] *** avar joined
[23:21] *** rantanplan_ joined
