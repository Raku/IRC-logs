[00:11] *** Zoffix joined
[00:11] <Zoffix> Will scripts that run in Perl 5 run in Perl 6?

[00:12] <Patterner> theoretically yes

[00:13] <Zoffix> ok

[00:13] *** Zoffix left
[00:17] *** markstos joined
[00:23] *** nekokak joined
[00:30] *** hikozaemon joined
[01:01] *** mr_goose joined
[01:03] *** mr_goose left
[01:27] *** azr|elious is now known as azr|el

[01:37] *** nnunley joined
[01:54] *** justatheory joined
[01:59] *** xdg joined
[02:21] *** revdiablo joined
[02:22] *** f0rth joined
[02:24] *** lambdabot joined
[02:36] *** tcliou joined
[02:47] *** kastol joined
[02:59] *** KingDiamond joined
[03:11] *** Aankhen`` joined
[03:25] *** evilmnky joined
[03:37] *** Daveman joined
[04:05] *** ofer0 joined
[04:19] *** kastol joined
[04:44] <svnbot6> r13587 | gaal++ | * Pugs.Val: add -funbox-strict-fields to let ValNative be what it says

[04:44] <svnbot6> r13587 | gaal++ | * castVal for ValUndef and ValNative

[04:48] *** amv joined
[04:53] *** buetow joined
[04:57] <ingy> seen [particle]

[04:57] <jabbot> ingy: [particle] was seen 2 days 10 hours 21 minutes 15 seconds ago

[05:14] *** BooK joined
[05:15] <svnbot6> r13588 | fglock++ | [v6]

[05:15] <svnbot6> r13588 | fglock++ | - fixed prefix:<$> rule (added quotemeta);

[05:15] <svnbot6> r13588 | fglock++ | - Term table cleanup; disabled '$()';

[05:15] <svnbot6> r13588 | fglock++ | - fixed '${...}', '$[...]', ':$<...>', '$0'

[05:15] <svnbot6> r13588 | fglock++ | - fixed coercions in emitter

[05:15] <svnbot6> r13588 | fglock++ | [Pugs-Compiler-Rule]

[05:15] <svnbot6> r13588 | fglock++ | - added method Match.chars

[05:15] <svnbot6> r13588 | fglock++ | - RegexPerl5 accepts parameters  i m s x ;

[05:15] <svnbot6> r13588 | fglock++ | [plain_regex]

[05:15] <svnbot6> r13588 | fglock++ | - code cleanup; added bug list

[05:15] <svnbot6> r13588 | fglock++ | - added  ^^ $$ \n \N  - TimToady++

[05:15] <svnbot6> r13588 | fglock++ | - /./ matches 2-char newline

[05:15] <svnbot6> r13588 | fglock++ | - <'literal'>

[05:15] <svnbot6> r13588 | fglock++ | - simple character classes, negated char classes

[05:16] <svnbot6> r13588 | fglock++ | [Pugs-Compiler-Python]

[05:16] <svnbot6> r13588 | fglock++ | - first commit (in misc/pX/Common)

[05:21] <svnbot6> r13589 | lwall++ | Renamed .words to .comb

[05:21] <svnbot6> r13589 | lwall++ | More Foo:: whackage and "method is export" insertage.

[05:22] <clkao> Pugs-Compiler-Python!

[05:29] *** mdiep_ joined
[05:45] *** nekokak_ joined
[05:53] *** marmic joined
[05:55] *** hikozaem_ joined
[06:00] *** Dr_Pi joined
[06:32] *** Gothmog_ joined
[06:40] *** iblechbot joined
[06:52] <svnbot6> r13590 | audreyt++ | * HsBridge: Improved dump of named arguments.

[07:03] *** kastol joined
[07:16] *** zakharyas joined
[07:25] *** iblechbot joined
[07:30] *** ludan joined
[07:55] *** scw joined
[08:01] *** nothingmuch joined
[08:08] *** kane-xs joined
[08:14] *** ruoso joined
[08:47] *** drrho joined
[08:59] <svnbot6> r13591 | audreyt++ | * Remove t/Dialects now that our test suite is spec-based.

[09:05] <svnbot6> r13592 | audreyt++ | * "try {...}" now catches internalErrors as well as user errors.

[09:05] <svnbot6> r13592 | audreyt++ | * "slurp" now uses strict ByteString.readFile instead of the much

[09:05] <svnbot6> r13592 | audreyt++ |   slower readFile.

[09:05] <svnbot6> r13592 | audreyt++ | * Infix "===" now correctly compares value (instead of pointer)

[09:05] <svnbot6> r13592 | audreyt++ |   equivalence.

[09:05] <svnbot6> r13593 | audreyt++ | * "pugs -Ifoo -Ibar" now correctly lists foo before bar on @*INC.

[09:05] <svnbot6> r13593 | audreyt++ |   (This was a regression from previous release.)

[09:05] <svnbot6> r13594 | audreyt++ | * Pugs.Compile: Misc cleanup on list compiling.

[09:08] <svnbot6> r13595 | audreyt++ | * Pugs.Eval: Allow "last" and "redo" in "repeat { ... }" loops.

[09:08] <svnbot6> r13595 | audreyt++ | * Also implement \($x, $y, |$z, $w) splicing.

[09:09] <svnbot6> r13596 | audreyt++ | * Allow 0_1234 to mean 0d1234; disallow "\_1234" to mean "\d1234".

[09:12] <svnbot6> r13597 | audreyt++ | * "my &infix:<foo>" without explicit associativity now

[09:12] <svnbot6> r13597 | audreyt++ |   defaults to left-associative.

[09:12] <svnbot6> r13598 | audreyt++ | * On Unix systems, don't bork on source files with CRLF line endings.

[09:12] <svnbot6> r13599 | audreyt++ | * "my $x; { $x; my $x }" now fails with a sensible error message.

[09:15] <svnbot6> r13600 | audreyt++ | * Pugs.Parser: Rename parseHasParenParamList to ruleParenArgs

[09:15] <svnbot6> r13600 | audreyt++ |   as we are now more careful about the distinction between

[09:15] <svnbot6> r13600 | audreyt++ |   params (Signature) and arguments (Capture).

[09:15] <svnbot6> r13600 | audreyt++ | * "do { ... }" is now made a true block, by desugaring it into

[09:16] <svnbot6> r13600 | audreyt++ |   "repeat { ... } while False".

[09:16] <svnbot6> r13600 | audreyt++ | * "f( :$x :$y :$z )" without commas between them is now legal syntax.

[09:19] <svnbot6> r13601 | audreyt++ | * Add missing svn:eol-style on test files.

[09:22] <svnbot6> r13602 | audreyt++ | * proto.t: Fix parsefail and don't (yet) treat proto as expressions.

[09:22] <svnbot6> r13603 | audreyt++ | * return_function.t: Use |(f) instead of *f() to agree with the new spec.

[09:26] <svnbot6> r13604 | audreyt++ | * splatty_in_caller_position.t: It's f(|@args), not f(*@args).

[09:39] <audreyt> oy... rt.openfoundry.org crashed again, we're back to readonly

[09:42] *** renormalist joined
[09:56] <nothingmuch> 3/w 12

[09:59] <nothingmuch> audreyt: if you're awake please op the opbots on #moose

[09:59] <nothingmuch> clkao: you too

[10:14] <gaal> audreyt: commas are mandatory between params in Signatures, right?

[10:15] <gaal> and another question about r13600, shouldn't a do{} block evaluate to its uh, last evaluated value?

[10:17] *** elmex joined
[10:59] <svnbot6> r13605 | audreyt++ | * Pugs.Types: Allow $::x to mean exactly the same as $x.

[10:59] <svnbot6> r13606 | audreyt++ | * Add svn:eol-style to TASKS as well.

[11:00] <svnbot6> r13606 | audreyt++ | (r13604 accidentally included all tests in the previous triage run,

[11:00] <svnbot6> r13606 | audreyt++ |  but I don't quite feel like reverting and committing them separately again... :-))

[11:00] <svnbot6> r13607 | audreyt++ | * temp.t: TODO a pseudo-regression -- this test was passing

[11:00] <svnbot6> r13607 | audreyt++ |   because =:= wasn't implemented. ;)

[11:01] *** chris2 joined
[11:03] <svnbot6> r13608 | audreyt++ | * symbolic_deref.t: $*IN should be compared with ===, not =:=.

[11:05] <audreyt> gaal: right. and yes, a do block does that; so does "do repeat {...} while False".

[11:05] <svnbot6> r13609 | audreyt++ | * 1.WHICH should be 1, not undef.

[11:05] <svnbot6> r13610 | audreyt++ | * Perl6::FAQ::Capture: Use |$x not [,]=$x.

[11:07] <gaal> audreyt: ah, I misparsed "true" in "true block".

[11:07] <svnbot6> r13611 | audreyt++ | * Pugs.Parser: Allow ::Int:: to mean the same thing as ::Int.

[11:07] <svnbot6> r13611 | audreyt++ |   This is wrong -- It should be a Package object associated with

[11:07] <svnbot6> r13611 | audreyt++ |   ::Int -- but that will need to wait until MI is rolled in.

[11:10] <svnbot6> r13612 | audreyt++ | * Minor: Give rules in Pugs.Lexer and Pugs.Parser.Literal names.

[11:12] <audreyt> ah. "true" as in "last/redo/next works"

[11:12] <svnbot6> r13613 | audreyt++ | * Oops, typo in the previous commit.

[11:12] <svnbot6> r13614 | audreyt++ | * The main package is now ::Main, not ::main.

[11:16] <gaal> *nod*

[11:23] *** kanru joined
[11:31] *** rafl joined
[11:55] <gaal> lol. I'm reading the sources for syb stuff now. cast's implementation is amusing

[11:55] <gaal> cast x = r where r = if typeOf x == typeOf (fromJust r) ....

[12:14] *** Limbic_Region joined
[12:37] <svnbot6> r13615 | audreyt++ | * PCR: Add the case of (""~~/<null>/) to t/03-match.t.

[12:40] <kolibrie> slides from my talk (as delivered) are up: http://feather.perl6.nl/~kolibrie/extraction.xul

[12:40] <lambdabot> http://tinyurl.com/rxtmp

[12:40] <svnbot6> r13616 | audreyt++ | * PCR: Regex wasn't allowed to match at end of string; this fixed it.

[12:40] <svnbot6> r13617 | audreyt++ | * 07-simple-multisubs.t: Reformat the sanity test somewhat.

[12:40] *** rafl joined
[12:40] <kolibrie> with soundtrack: http://feather.perl6.nl/~kolibrie/extraction.mp3

[12:40] <lambdabot> http://tinyurl.com/femjh

[12:40] *** rafl joined
[12:40] *** iblechbot joined
[12:41] <kolibrie> (now we just need to fix the slides that are wrong)

[12:46] <audreyt> gaal: yeah, that's a neat trick to work around the lack of scoped tyvar

[12:47] <gaal> audreyt: uh huh.

[12:47] <kolibrie> audreyt: gaal: thank you very much for the last minute help with my slides - I think the talk went okay

[12:47] <audreyt> with scoped tyvar (part of -fglasgow-exts) it'd be

[12:48] <audreyt> cast :: forall a b. Typeable a, Typeable b => a -> b

[12:48] <audreyt> er, -> Maybe b

[12:48] <audreyt> cast x = r where r = if typeOf x == typeOf (undefined :: b) ...

[12:48] *** juzek joined
[12:49] *** juzek left
[12:57] <Limbic_Region> hey - I mostly understand that aramaic er uh, haskell

[12:58] <audreyt> nice! :)

[12:58] <gaal> audreyt: ACK, ACK.

[12:59] <gaal> anyone know of a omnigraffle-like tool for linux or windows?

[12:59] <gaal> (free)

[13:00] <audreyt> umbrello?

[13:00] <svnbot6> r13618 | audreyt++ | * More s/main::/Main::/ fixes.

[13:01] <gaal> i'll try that, thanks.

[13:01] <Limbic_Region> gaal - I think you would have more luck searching for visio rip-offs than omnigraffe

[13:01] <Limbic_Region> where rip-off == free alternative

[13:01] <audreyt> aka dia, kivio

[13:02] <gaal> i don't want something with very complex graphical caps. way I need is something that's smooth to work with and create an ordered graph

[13:02] <gaal> I mean I don't need very complex caps

[13:03] <Limbic_Region> Graphviz perhaps?

[13:03] <gaal> that's pleasant to enter data directly to from the gui

[13:03] *** xinming joined
[13:04] *** agentzh joined
[13:09] *** fglock joined
[13:09] <svnbot6> r13619 | audreyt++ | * "sub ($x = 0 is copy)" is invalid; say "sub ($x is copy = 0)" instead.

[13:11] <Limbic_Region> audreyt - for those following along at home

[13:11] <Limbic_Region> is that example assigning a value to $x if it already exists - or only giving it a default value if not defined?

[13:14] <lumi> The latter, I think?

[13:15] <Limbic_Region> lumi - I think so too but it was a leading question

[13:15] <Limbic_Region> does it only work if not defined?

[13:15] <Limbic_Region> IOW - can I do something like //= 0

[13:16] <gaal> Limbic_Region: neither. it's predicated on whether $x was mentioned in the capture.

[13:16] <Limbic_Region> gaal - oh, present or not

[13:16] <Limbic_Region> not - defined or not

[13:16] * Limbic_Region neverminds

[13:16] <gaal> :($x = X) is equivalent to :($x? = X)

[13:17] <gaal> audreyt: does r13619 mean order of param parts is now specced?

[13:18] <gaal> are all parts order-strict? or do we need a classifier after all?

[13:19] * gaal might make do with vi x.dot and dotty x.dot, seeing as http://www.graphviz.org/Gallery/directed/unix.dot.txt is so elegant

[13:19] <lambdabot> http://tinyurl.com/jbw8h

[13:19] <audreyt> I think the =xxx part obviously follows the "is foo" part

[13:20] <gaal> because the traits don't modify the default value, yes.

[13:21] <gaal> is there ever a case where :($x where {...} is ~Y~) and the trait modifies the closure?

[13:21] <audreyt> not likely

[13:21] <audreyt> so I think those two are order indep

[13:22] <gaal> so, data ParamModifier = ModTrait Trait | ModConstraint Code | ...

[13:22] <gaal> and something to reassemble these parts.

[13:26] <fglock> just checking:  ':$<rule>'  is  'rule => $($/<rule>)'  right?

[13:26] *** dakkar joined
[13:26] *** crem joined
[13:28] <fglock> and:  'after => :$<rule>'  is  'after => { rule => $($/<rule>) }'  ?

[13:29] *** Odin-LAP joined
[13:31] *** arhuman joined
[13:31] <arhuman> hi

[13:32] <fglock> or should that be  ' :$$<rule> '   # a pair with string value

[13:32] *** evalbot_r13586 is now known as evalbot_r13619

[13:33] <audreyt> :$<rule> is

[13:33] <audreyt> rule => $/<rule>

[13:33] <audreyt> there's no $() part

[13:33] *** vel joined
[13:33] <audreyt> you need :$$<rule> for that yes

[13:33] <fglock> does $() still exists?

[13:35] <audreyt> it does

[13:35] <audreyt> $() is short for $$/

[13:35] <audreyt> @() is short for @$/

[13:35] <lambdabot> Maybe you meant: . bf ft id pl v wn

[13:35] <audreyt> %() is short for %$/

[13:35] <audreyt> ok, they are not shorter

[13:35] <fglock> :)

[13:35] <audreyt> so maybe s/short/alternative spelling/ :)

[13:36] *** lanny joined
[13:36] <obra> $() sure is a lot nicer to read than $$/

[13:36] <obra> . o O { And some day will be abused to make code that compiles in perl6 and javascript }

[13:37] <audreyt> yes, that's in fact my first reaction when that syntax emerged :)

[13:37] <obra> Heh.

[13:39] <svnbot6> r13620 | lanny++ | [READTHEM]

[13:39] <svnbot6> r13620 | lanny++ | added wikibooks.org entry for online Haskell

[13:40] *** baest joined
[13:47] *** xerox joined
[13:49] <lanny> So are  things like rand() in S29 declared both method and sub to allow folks to multi on rand() without having to define a method on some class (to be rand()-ed)?  Declaring method rand(Int:) and sub rand(Int) seems like  the sub will never be invoked unless folks go out of their way.  E.g., rand(7,)

[13:51] *** arhuman left
[13:52] <audreyt> I think it's jsut that TimToady havn't got around tuit on the method-is-export campaign

[13:52] <audreyt> method rand () is export {  } # will suffice

[13:53] <audreyt> otoh we do need a multi rand () {}

[13:53] <obra> it's really "is export" and not "is exported"?

[13:53] <audreyt> which rdispatches to 1.rand

[13:54] <audreyt> or "is exportable"? yeah, that's faq and I gave up long ago :)

[13:55] <obra> yeah. ok.

[13:58] <lanny> So why would we need a multi rand that re-dispatched?  I would have thought the method rand() would have been found before  you got to the sub for the redispatch back up to a method.

[13:58] <lanny> Since it's arity-1.  Arity-1+ I can see.

[13:59] <audreyt> the arity-1-sub-to-method-preference is specced, yes, and implemented

[13:59] <lanny> I'm all for covering all the bases since it's good documentation.  Just wondering if there are deeper reasons I'm missing.

[13:59] <audreyt> but that was before we can export methods

[14:00] <audreyt> and TimToady is still considering whether we can teach people to write $x.foo and don't expect foo($x) to work unless it's exported

[14:00] <lanny> Aha.

[14:00] <audreyt> in which case the preference (which causes quite some headache in f(this_is_a_call_that_does_different_things_in_itme_vs_list_context()).

[14:01] <audreyt> ...can go away.

[14:01] <audreyt> (when interpreted as .f, the cxt is item, but when interp as f(), there may well be a slurpy &f in scope)

[14:01] <lanny> Well I hope there's at last a 'use SlowLearner' because I would want foo($x) without having to import if  there was a foo() in Perl5.

[14:01] <audreyt> but you can't go back and reeval it as slurpy anymore

[14:02] <svnbot6> r13621 | fglock++ | v6 - implemented  $(), @(), %(), :$$<...>

[14:02] <audreyt> yes, which is why we export all p5-builtin-like methods such as rand.

[14:02] <audreyt> the export is just a sugar multi that redispatch back into the method anyway

[14:02] <lanny> Ok.  Good to know I got  it mostly right on motivation.

[14:03] <audreyt> =)

[14:03] <lanny> Must run girls to school.  Thanks for the clue, audreyt.

[14:04] *** iblechbot joined
[14:11] <svnbot6> r13622 | audreyt++ | * unTODO passing tests.

[14:11] <Limbic_Region> audreyt - when is the ETA for new release?

[14:12] <Limbic_Region> number of failing tests seems to continue fluctuate and not only go down

[14:12] <Limbic_Region> OTOH (new tests)++

[14:15] *** lisppaste3 joined
[14:16] *** orafu joined
[14:23] <svnbot6> r13623 | fglock++ | v6 - s/Regex/Token/ in Term.pm

[14:24] *** lollan joined
[14:24] <audreyt> Limbic_Region: those are not new tests, merely parsefail tests made nonparsefail

[14:25] <audreyt> triage eta another couple days

[14:25] <audreyt> with chglog help perhaps this weekend

[14:29] <svnbot6> r13624 | fglock++ | Pugs-Compiler-Rule - refactored Rule grammar to use shortcuts, such as

[14:30] <svnbot6> r13624 | fglock++ | '{ return { after => :$$<rule>, } }'

[14:32] <fglock> compiling the compiler with itself is funny, as you can use the newly implemented features in the source code

[14:33] <audreyt> yeah :)

[14:33] <audreyt> nice use, that

[14:35] <theorbtwo> You're providing a pre-compiled version, I assume, to saneify the circularity of it all?

[14:35] <obra> seen pdcawley

[14:35] <jabbot> obra: pdcawley was seen 1 days 1 hours 22 minutes 42 seconds ago

[14:35] * theorbtwo gets On Trusting Trust flashbacks.

[14:37] <fglock> theorbtwo: yes, there is a perl5 .pmc file, which is re-generated each time the p6 code is edited

[14:37] <theorbtwo> Right-o.

[14:39] <fglock>  does <!aaa> matches 3 chars or one?

[14:40] <[particle]> you mean <![aaa]> ?

[14:40] <audreyt> isn't that negated 'aaa' ?

[14:40] <audreyt> I mean <aaa>

[14:40] <fglock> yes - 3 chars, I think

[14:41] <fglock> oh, right

[14:41] <audreyt> but <aaa> here is named subrule

[14:41] <[particle]> right, named subrule

[14:41] <[particle]> that's where i was confused

[14:41] <fglock> oh, I meant - <!<'aaa'>>

[14:41] <fglock> sorry

[14:41] <[particle]> ! is always a zero width assertion

[14:42] <fglock> [particle]: thanks!

[14:42] <audreyt> if it boolifies to false, it can't have a from/to, I think

[14:43] <audreyt> though I can argue the other way, but it makes it easier this way :)

[14:43] <audreyt> (and if it boolifies to ture, then that [particle] said applies.)

[14:43] <TimToady> ⅋ ZZZ

[14:44] <audreyt> hi TimToady :)

[14:44] <TimToady> mornin'

[14:44] <fglock> so <!<'aaa'>> is the same as <!before <'aaa'>>  ?

[14:45] <fglock> TimToady: hi

[14:45] <ajs_> I'm still having throuble with the captures threads. I think my big point of confusion is on what this means, or even if it works: |c = \$s

[14:45] <audreyt> seems so... which makes S05:923 rather redundant...

[14:46] <audreyt> ajs_: well, it havn't been decided yet whether |c can be assigned to

[14:46] <[particle]> fglock, audreyt: indeed

[14:46] <audreyt> i.e. if it' more like & or more like @

[14:46] <ajs_> audreyt: We're quoting Synopses by chapter and verse, now? I can't wait to see the guy that goes to basebal games with "S03:16" signs

[14:46] <audreyt> :)

[14:47] <[particle]> fglock: should your example be <!'aaa'> ?

[14:48] <ajs_> I see. well, still the real question is "what is \$s" is it a capture in the same sense that "\($s:)" is? is it just filling the scalar slot as some recent messages on the list have asserted?

[14:48] *** ajs_ is now known as ajs_work

[14:48] <theorbtwo> I'm not sure I know what the difference between those is.

[14:48] <audreyt> ajs_work: yes.

[14:49] <theorbtwo> Isn't \($s:) just filling the scalar slot?

[14:49] <audreyt> currently as specced \$s \($s:) \($s) all bois down to the same thing

[14:49] <ajs_work> theorbtwo: yes

[14:49] <fglock> [particle]: I don't know if that works, maybe

[14:49] * PerlJam sticks a  $ s ( ) and a :  in a box and shakes up

[14:49] <ajs_work> Wait... \($s) should be equiv to \(=[$s]) not \($s:)

[14:49] <audreyt> if the unary-sub-makes-method preference goes away, then it may make sense to make \($s) mean \(: $s) but \$s still means \($s :) -- though I'm not sure about that.

[14:50] <audreyt> s/unary-sub/unary-subcall/

[14:50] <ajs_work> So, \&f fills the scalar slot with the sub?

[14:51] <fglock> [particle]: maybe the difference is that <!before ...> takes a regex argument, while <! ...> takes a single metasyntax term?

[14:51] <audreyt> ajs_work: yes, and you take it out with $ not with &

[14:53] <[particle]> fglock: perhaps... what would <!foo+bar-baz> do? is that equiv to <+!foo+bar-baz>? or more like (syntactically incorrect) <!(+foo+bar-baz)>

[14:53] <[particle]> ...basically, must it be a single metasyntax term

[14:53] <[particle]> and if not, how does it interpolate

[14:54] <[particle]> ...a "metasyntax expression".

[14:54] *** jferrero joined
[14:55] <ajs_work> thanks audreyt. This makes more sense to me now, though \ seems pretty heavy-weight.

[14:58] *** buetow joined
[14:59] <[particle]> hrmm, reading, i believe ! is just like + or -, and takes a single term

[14:59] <fglock> [particle]: fixed

[14:59] <svnbot6> r13625 | fglock++ | Pugs-Compiler-Rule - <! ...> takes a metasyntax expression (not a rule pattern)

[15:00] <[particle]> what tests are you currently running?

[15:00] <[particle]> t/regex/from_perl_rules?

[15:02] <fglock> I'm running just the pcr tests, and checking if Test.pm compiles

[15:02] <audreyt> ajs_work: if it's immmutable, we don't have to alloc the redundant storage at all...

[15:03] <fglock> [particle]: I was fixing v6.pm hash/array, and got distracted :)

[15:04] *** ofer0 joined
[15:11] <TimToady> it's a bit odd that <!!foo> means something different than <?foo>.  I wonder if we should have a different "suppress named capture" char.

[15:11] <Juerd> Postfix ?, perhaps?

[15:12] <Juerd> Prefix #

[15:12] <Juerd> <#foo>

[15:12] <[particle]> prefix:<.>

[15:13] <Juerd> <.foo>? I'd expect that to call a method.

[15:13] <TimToady> it's supposed to.

[15:13] <TimToady> assuming that $_ is meaningfully set to something callable

[15:13] <Juerd> Grin. Prefix / :)

[15:13] <Juerd> </html>

[15:14] <[particle]> i don't see 'A leading .' in the spec, perhaps it's in [AE]05

[15:14] <TimToady> I get caught *every* time I write s/x/<foo>x</x>/

[15:14] <Juerd> Isn't not-capturing like not-caring?

[15:15] <Juerd> 'cause perhaps you can sneak in Whatever here.

[15:15] <Juerd> <*foo>

[15:15] <TimToady> <=foo>

[15:15] * theorbtwo likes the Whatever idea.

[15:15] <theorbtwo> A foo.  Whatever foo happens to be around, I don't care.

[15:15] *** c6rbon joined
[15:16] <TimToady> "find me a rull ending in foo"

[15:16] <TimToady> *rule

[15:16] <theorbtwo> <.*zug>

[15:17] <TimToady> <|foo> heh

[15:17] *** vel joined
[15:17] <audreyt> pipe is the new colon

[15:17] <zakharyas> hah

[15:18] <obra> . o O { Larry gets the pipe }

[15:18] <theorbtwo> In the conservatory?

[15:18] <TimToady> <|this> is not a pipe

[15:18] * [particle] is |$smoking

[15:18] <zakharyas> foward --> slewis surely?

[15:19] <TimToady> <^foo>

[15:19] <[particle]> so, <!!foo> is legal?

[15:20] <audreyt> TimToady: I've changed the tests such that the only remaining tests for [,] ensures it's noop-ish

[15:20] <TimToady> yeah, you almost need |<<[,] to get anywhere...

[15:20] <audreyt> and all magic interpolation replaced by  |$foo and |<< @bar, %bax

[15:20] <TimToady> that's fine.

[15:20] <audreyt> ...which are, incidentally, implemented along with  "my |x"

[15:21] <audreyt> cool :) will commit+sleep in a bit

[15:21] <TimToady> particle: why not? ! and ? are recursively defined.

[15:21] <theorbtwo> |<< @bar ?

[15:22] <audreyt> theorbtwo: |(@bar[0]), |(@bar[1]), ...

[15:22] <theorbtwo> Oh, hyper-pipe prefix operator.

[15:22] <TimToady> instead of making [,] do it magically

[15:22] <theorbtwo> Yeah, seems more or less sane.

[15:23] <theorbtwo> That is, it seems the saner of those two positions.

[15:23] <audreyt> since [,] was losing any resemblance of reductional nature implied by [] :)

[15:23] <theorbtwo> Oh, do Captures have a type slot -- can you ::|foo?

[15:23] <TimToady> <??!!?!???foo> is theoretically legal.

[15:24] <TimToady> or to raise putter's question, do they have a slot for the constructor you'd call to reconstruct the original (reversibility at stake here)

[15:24] <audreyt> theorbtwo: I hope not... neither does it have a &|foo position.

[15:24] <svnbot6> r13626 | fglock++ | v6 - cleanup Term grammar

[15:25] <audreyt> (brb)

[15:27] <PerlJam> Could someone explain to me exactly what we gain by sigilizing Captures?

[15:27] <PerlJam> I'm just not seeing it.

[15:28] *** lisppaste3 joined
[15:32] *** chris2 joined
[15:33] <TimToady> mostly we gain not having to write |$foo everywhere we can currently write |foo.  But it might be a fair trade to require |$foo in a signature for the ability to write |func() in an rvalue.

[15:33] <Juerd> TimToady: <*foo> doesn't say "anything ending in foo", as much as *@foo doesn't. Perl 6 doesn't have globs anyway :)

[15:33] *** fglock left
[15:33] <audreyt> otoh, if | is made special form just like the old splatty *, |<< will still work.

[15:34] <TimToady> but * as in Whatever has strong connotations of maximizing whatever it is in a globby or Inf way.

[15:34] <Juerd> TimToady: ($foo, *, $bar) = (5, 6, 7)

[15:34] <Juerd> TimToady: I thought that that'd "capture" only 5 and 7.

[15:34] <TimToady> |<< works as long as | parses as prefix:<|>

[15:35] <TimToady> the operator in question doesn't have to pay attention to those "strong connotations"

[15:35] <TimToady> :)

[15:35] <audreyt> I like :(*|x) as alternative to :(\$x) but the latter is quite livable

[15:36] <audreyt> and so indeed there doesn't seem to be a strong argument for sigilizing |

[15:36] <Juerd> I read *|x as any(Whatever, x)

[15:36] <audreyt> well, yeah, there's that too.

[15:36] <TimToady> by \$x you mean a param that must be a capture?

[15:36] <TimToady> as opposed to |$x which would capture all the rest of the params into $x?

[15:36] <audreyt> the "take the unprocessed arglist and put them into this"

[15:37] <audreyt> it would?

[15:37] <TimToady> I'm saying if we demoted | to unary then |$x is the old \$x

[15:37] <TimToady> in a declaration

[15:38] <audreyt> ah right.

[15:38] <Juerd> What's the use of that?

[15:38] <Juerd> i.e. why not just use \ instead then

[15:38] <audreyt> and it reads slightly better than $|x

[15:38] <audreyt> and it reads slightly better than *|x

[15:38] *** weinig|bbl is now known as weinig

[15:38] <TimToady> don't want to put | into the twigil slot.

[15:38] <TimToady> |$+capture

[15:38] <audreyt> nodnod.

[15:38] <TimToady> in declaration | is more like * slot

[15:38] <audreyt> Juerd: the signature syntax tries to mimick the actual syntax in reduspatch

[15:39] <Juerd> What is reduspatch?

[15:39] <audreyt> sub (:$x) { redispatch(:$x) }

[15:39] <Juerd> Oh, redispatch

[15:39] <Juerd> audreyt: But why couldn't you use \ in both?

[15:39] <audreyt> sub (|$x) { redispatch(|$x) }

[15:39] <audreyt> uh because then it's not a redispatch anymore?

[15:39] <TimToady> same reason you can't interchange * and & in C

[15:40] <Juerd> I see.

[15:40] * audreyt prepares to revert the ruleSigil patch

[15:40] <TimToady> not that C's declaration syntax is to be emulated here...

[15:40] * Juerd must be missing something sufficiently relevant :)

[15:40] <audreyt> not having oto write |(f()) is a win indeed 

[15:41] <TimToady> of course, then someone will ask what "my |@foo =" means...

[15:43] <TimToady> yeah, I've been worrying about |(f()) for a couple of days now...

[15:43] <audreyt> the same question can be raised against *@foo anyway

[15:43] <TimToady> I mean "my |@foo :="

[15:43] <audreyt> it's @foo bound to Capture

[15:44] <audreyt> which means you automagically gets interpolating access to its positionals...

[15:44] <audreyt> my @foo is Capture

[15:44] <TimToady> and %@foo gives you the named?  :)

[15:44] <audreyt> |%foo, yes

[15:44] <audreyt> and |@@foo gives you access to raw feeds

[15:44] <TimToady> and @@@foo gives you the, er...

[15:46] <svnbot6> r13627 | audreyt++ | * Temporarily, for the duration of this commit, | is made sigil.

[15:46] <svnbot6> r13627 | audreyt++ |   It's going to be reverted in the next commit...

[15:46] <Juerd> Hehe, nice commit message

[15:46] *** buetow joined
[15:46] <ajs_work> Question about List vs Lazy: is there a difference or should that be written "lazy List" as opposed to "eager List"? Reason I ask is that S06 says that List is always lazy, so I don't see why we're using "Lazy" in S29

[15:47] <TimToady> the type hierarchy in .hs has List (Lazy...Eager)

[15:47] <audreyt> S06 I think says List by default is lazy

[15:47] <TimToady> but is there really an Eager type?

[15:47] <audreyt> so maybe List (Eager)

[15:47] *** justatheory joined
[15:48] <audreyt> or is it a strictness annotation?

[15:48] *** hexmode joined
[15:48] <audreyt> Seq is eager, tough.

[15:49] <audreyt> s/tough/though/

[15:49] <TimToady> it's a promise about side effects or something

[15:49] <TimToady> how can you have a mutable eager thing?

[15:50] <TimToady> so maybe Seq =:= Eager

[15:51] <audreyt> indeed

[15:52] <audreyt> fglock's plan (and the same in newVal) is have List present a immutable interface but maintain some Range/Seq/other-producer-things underneath

[15:52] <TimToady> does that mean the prefix:<seq> is the new eager?

[15:52] <audreyt> not unlike how Str maintains buf underneath

[15:53] <audreyt> hm, that sees strangely familiar...

[15:53] <audreyt> Seq(1..Inf) will do already no?

[15:54] <TimToady> I guess I'm confusing laziness with immutability here...

[15:54] <TimToady> something can be immutable but lazy

[15:54] <audreyt> right

[15:54] <audreyt> =<> for example. 

[15:55] <TimToady> ENOTENOUGHMUGSOFCOFFEE

[15:55] <ajs_work> I think I might have gotten an answer, but I'm not sure ;)

[15:56] <ajs_work> It does seem, though, that List implies laziness, so at the very least, I don't think we need Lazy in S29

[15:56] <TimToady> yes, but it's a lazy answer.

[15:56] <ajs_work> heh

[15:56] <TimToady> yeah, but is there any reason Eager is inside List in Types.hs?

[15:57] *** kanru joined
[15:57] *** prefiks joined
[15:57] <TimToady> or maybe Eager is the subset of values that are evaluated Right Now.  :)

[15:57] <ajs_work> I'm not sure that I followed the mutable implies non-eager comment, so I don't think I can answer that.

[15:59] <TimToady> actually, I was addressing the lady hunched over the mac

[15:59] <ajs_work> I realized, I was just poking for more info on the nature of mutability, really. ;)

[16:01] <TimToady> biab &

[16:01] *** wilx left
[16:08] <audreyt> well, not exactly hunching...

[16:08] * audreyt discovers OSX doesn't like 0bytes left in / and has to reboot

[16:10] <Juerd>                                                                                                            

[16:10] <Juerd> Oops. Sorry for that :)

[16:10] *** mauke_ joined
[16:11] <[particle]> i thought you had zero bytes left in #perl6 :)

[16:20] *** mauke_ is now known as mauke

[16:23] *** fglock joined
[16:24] <svnbot6> r13628 | audreyt++ | * As promised, | is no longer a rule but a special form prefix.

[16:24] <svnbot6> r13629 | audreyt++ | * Implement splicing: \( |<< @array_of_captures )

[16:25] <audreyt> sigh, s/no longer a rule/no onger a sigil./

[16:25] *** prefiks left
[16:26] <svnbot6> r13630 | audreyt++ | * Change the type "Pugs::Internals::VRule" back to "Regex".

[16:27] *** Psyche^ joined
[16:27] <svnbot6> r13631 | audreyt++ | * Chase the s/Pugs::Internals::VRule/Regex/ change in tests.

[16:29] *** penk joined
[16:29] <svnbot6> r13632 | audreyt++ | * Change [,] to the shiny new | and |<<.

[16:31] *** penk joined
[16:34] <fglock> how is :$$<foo> meant to be parsed? it is currently using a special rule in Term; are things like :$$$$<foo> valid?

[16:35] <audreyt> well, :$$<foo> is no exactly specced

[16:36] <audreyt> however, it parse the same as any consecutive sigils 

[16:36] <audreyt> $$$foo always binds tighter than anything else

[16:36] <audreyt> i.e. $$$foo[0] is always ($$$foo)[0] and never $$($foo[0])

[16:37] <audreyt> :eval my $foo = \10; :$$<foo>

[16:37] <audreyt> ?eval my $foo = \10; :$$<foo>

[16:37] *** weinig joined
[16:37] *** evalbot_r13619 is now known as evalbot_r13627

[16:37] <fglock> :@%$<foo>

[16:37] <evalbot_r13627> Error:  Unexpected ":$$<" expecting "::"

[16:37] <audreyt> hm ,havn't caught up yet

[16:37] <TimToady> "Gee, Dad, that is that swearing?" --Heidi

[16:38] <fglock> so ':' just looks ahead for an identifier

[16:38] <TimToady> (fyi, hacking [,] -> | in syns, btw)

[16:39] <audreyt> &infix:<plus> means something extremely different from $infix:<plus>

[16:39] <audreyt> the latter is a named pair literal

[16:39] <audreyt> plus => $infix<plus>

[16:39] <audreyt> I wonder if that form can find some better alternative...

[16:39] <theorbtwo> That's somewhat scary.

[16:40] <audreyt> and unimplemented by pugs as I can't seem to find a way to do it without massive lookahead

[16:40] *** zakharyas left
[16:40] <theorbtwo> Would there be a major problem with getting rid of the $infix:<plus> form, then?

[16:40] *** Psyche^ is now known as Patterner

[16:41] <audreyt> not sure. I mean, :$<foo> is a special case of that

[16:41] <audreyt> :$/<foo> is not valid

[16:41] <audreyt> $/:<foo> would be the currently specced equiv

[16:42] <audreyt> another thought is to make :%h<foo> parse as foo=>%h<foo>

[16:42] <audreyt> not (h=>%h)<foo> which is likely nonsensical

[16:43] <audreyt> I think I've raised that with damian on Chicago and he agreed, bu tthen we got distracted into multi dispatch...

[16:43] <theorbtwo> Gah, I need to pay more attention, it seems.

[16:44] <theorbtwo> However, more importantly, I need to go eat, right now.

[16:44] <theorbtwo> Later.

[16:45] <audreyt> and I need to sleep :)

[16:45] <audreyt> TimToady: best luck synhacking :)

[16:46] <fglock> do you mean %h:<foo> ?

[16:46] *** weinig is now known as weinig|bbl

[16:46] <audreyt> fglock: I mean have :%h<foo> replace %h:<foo>

[16:48] <fglock> so this is better left to implement after a few days :)

[17:05] <svnbot6> r13633 | fglock++ | Pugs-Compiler-Rule - Match.kv, Match.elems

[17:09] <svnbot6> r13634 | audreyt++ | * Pugs.Lexer: tryVerbatimRule now actually tries :)

[17:12] <svnbot6> r13635 | audreyt++ | * ruleSigiledVar no longer backtracks.

[17:12] <svnbot6> r13635 | audreyt++ | * Change existing uses of tryVerbatimRule back into verbatimRule.

[17:14] <ajs_work> I've fired off a message to the list, condensing my question here into something much longer and rambling ;)

[17:16] *** lanny joined
[17:16] <svnbot6> r13636 | fglock++ | Pugs-Compiler-Rule - $/{0} === $/[0]

[17:16] <ajs_work> One question about mutability. I know we've had the "Str is immutable, does that mean I can't assign to .substr" conversation, but I don't recall what was decided.

[17:17] <gaal> hello, hello. I'm running a smoke after a while of not running the whole thing - and I see the output's more verbose than it used to. is this intentional?

[17:17] <gaal> audreyt: any specific triaging help I can moose?

[17:18] <gaal> (I see we're not in mass-TODO phase yet)

[17:20] <lanny> I got the feeling it was the changelog she was not looking forward to, gaal, but was only an impression from one comment when someone asked about ETA.

[17:20] <gaal> yes, changelog's a daunting task

[17:21] <gaal> I'll help by submitting my stuff there, then, while the smoke completes :)

[17:22] <fglock> ajs_work: lvalue substr changes the "container" contents (such as $str); whether or not it creates a new string depends on the actual backend implementation

[17:29] *** mdiep joined
[17:31] *** bernhard joined
[17:40] *** ludan joined
[17:48] *** Odin-LAP joined
[17:48] <svnbot6> r13637 | fglock++ | Pugs-Compiler-Rule - updated Match pod, TODO

[17:50] *** pjcj joined
[17:51] *** vel joined
[17:53] *** pjcj joined
[17:54] <gaal> @tell audreyt vardecl and particularly "my T ($x, $y)" doesn't use the Signature parser yet, does it? There are two items in the ChangeLog about this that may be misleading.

[17:54] <lambdabot> Consider it noted.

[17:54] <svnbot6> r13638 | gaal++ | * ChangeLog: gaal's stuff

[17:56] <ajs_work> fglock, so you are saying that $str.substr(0,1) = "A" is the same as $str = "A"~$str.substr(1) ?

[17:57] <ajs_work> Which would mean that lvalue methods can't be used on non-lvalues... which might be fine... just thinking it through.

[17:58] <ajs_work> I think regexp substitution is going to be a pain in the ass to write.

[17:58] <TimToady> it was a pain to write in C...

[17:59] <ajs_work> I just mean in terms of the replacement of multiple sub-sequences. It's going to have to re-allocated the string for each :g iteration

[17:59] <fglock> ajs_work: yes  - and the underlying implementation may decide whether to use mutating buffers or not

[18:00] <fglock> meeting &

[18:00] *** fglock left
[18:00] <ajs_work> Will there be mutating buffers with string semantics?

[18:04] <TimToady> If you want something that varies, maybe you want a variable.  :)

[18:04] <ajs_work> eh?

[18:07] <ajs_work> It was my understanding, based on S06 that "my Str $str = "one fine day"; $str =~ s/<alpha>/{$1.uc}/g" would either fail, or re-assign $str a newly allocated Str several intermediate times. fglock's statement about the potential use of an intermediate mutating buffer instead was what lead to my question.

[18:08] <ajs_work> er :g

[18:08] <ajs_work> you know what I meant ;)

[18:08] <ajs_work> and ~~

[18:09] <ajs_work> and all that Perl 6 stuff... shoot me, I still have to write a lot of Perl 5 code ;)

[18:09] <TimToady> I don't see anything in there that prevents it from doing it all with one copy operation.

[18:10] <TimToady> "my Str $str" is merely a guarantee that $str will return a Str, not necessarily the same one you put there...

[18:11] <ajs_work> Right... ok.

[18:13] *** weinig|bbl is now known as weinig

[18:17] <TimToady> I guess the interesting question is whether method substr($self: ...) can bind a new object to $self and have it propagate back into $str.substr

[18:18] <lanny> Wouldn't that be $str .= substr(...)?

[18:20] <TimToady> that would chop it down to a substr of itself, but not allow substitution of a substr

[18:20] <lanny> ah.  right.  Forgot this was about lvalues.

[18:21] <TimToady> anyway, commuting... &

[18:29] *** MenTaLguY joined
[18:41] *** fglock joined
[18:42] <svnbot6> r13639 | kolibrie++ | talk - Practical Extraction with Perl 6

[18:48] <svnbot6> r13640 | kolibrie++ | added talk to ChangeLog

[18:51] <ajs_work> Was toying with \$foo in pugs. Seems that \ is just ignored. Interestingly the reverse is true: $$foo works, regardless of what's in $foo.

[18:54] <fglock> is this right? 'Match does Str does Array does Hash'

[18:54] <fglock>  'Match does Str|Array|Hash' ?

[19:01] *** weinig is now known as weinig|away

[19:03] <kolibrie> fglock: thanks for all your help with my talk.  I'm going to try to correct any syntax errors I may have put in the slides

[19:04] <fglock> kolibrie: it helped me debug the $/ shortcuts in v6.pm :)

[19:04] <kolibrie> fglock: I think it was good for a number of people :)

[19:05] <kolibrie> I get to present it again this Friday at work

[19:05] <fglock> kolibrie: I'm starting to reimplement map() so that it can run the match-to-HOH transform

[19:05] <kolibrie> HOH?

[19:06] <fglock> (hash-of-hashes)

[19:06] <kolibrie> oh, awesome

[19:06] <fglock> kolibrie: if you have some time, take a look at the new Pugs::Grammar::Rule2.pm

[19:07] <kolibrie> fglock: I will

[19:15] *** ofer0 joined
[19:17] <TimToady> Match does Capture?

[19:17] <fglock> yes, I think so

[19:17] <clkao> fglock: what's with rule2 ?

[19:18] <fglock> clkao: it uses some new shortcut syntax for getting/coercing match elements

[19:18] <ajs_work> <strikethrough>Match does</strikethrough> Capture?

[19:19] <ajs_work> Or does Match have some extra state/methods not implied by Capture?

[19:19] <clkao> where is rule.pmc compiled from these dys?

[19:20] <kolibrie> ajs_work: Match is a pretty specific thing, Capture is very generic

[19:20] *** vel joined
[19:21] <TimToady> Match has .from and .to

[19:22] <fglock> clkao: the source code is Rule2.pm - it has a different name so that it does not get recompiled by mistake - which could break everything :)

[19:26] <fglock> Rule2.pm is the actual p6 bootstrap - v6.pm just adds more syntax

[19:27] <clkao> *nod*

[19:37] <svnbot6> r13641 | fglock++ | v6 - fixed compile-time objects; all methods should return objects

[19:39] <fglock>  Str('abc').eq( Str('xyz') ) returns BoolExpression( " 'abc' eq 'xyz' " )  - is there a node in Pugs for this?

[19:40] <fglock> I'd like to reuse the node names

[19:41] * wolverian throws a hissy java fit

[19:50] <fglock> CapInternals.hs has 'ExpVal' - so maybe 'an expression that returns a bool value' would be 'ExpValBool'

[19:50] <fglock> bbiab

[19:56] <gaal> fglock: the type is Val, ExpVal is an alias

[19:56] <gaal> Bool is PureBool

[19:56] <gaal> or PureBit maybe

[19:57] <gaal> CapInternals is no longer a very good reference, I'm afraid. a diverging approximation, if you will.

[19:59] *** hexmode joined
[20:01] <[particle]> @approximations.>>.diverge;

[20:01] <lambdabot> Unknown command, try @list

[20:02] <wolverian> heh.

[20:11] <fglock> gaal: how would you name the node for an expression that returns a bool ?

[20:12] <gaal> you mean boolean context, like ?EXPR   ?

[20:12] <gaal> because I we don't have haskell-style type annotations...

[20:13] *** ofer0 joined
[20:15] <gaal> so if you do mean that, it's an Exp of the application of ? to another exp....

[20:15] <fglock> gaal: I have a Bool, which is the result of an expression (lazy evaluated)

[20:16] <gaal> EControl (CCall "&prefix:<?>" some_expression)

[20:16] <gaal> oh

[20:16] <gaal> okay, well so?

[20:17] <gaal> it's just the expression

[20:18] <fglock> yes, but I want to attach the type info to it - so I thought of naming the node something like ExpBool

[20:19] <gaal> what does attaching the type mean here, an annotation that would allow a typechecker to perform some assertion?

[20:19] <gaal> because at the end, you probably have simply some Val

[20:20] <fglock> yes, the main use for this is autoboxing (in perl5)

[20:20] <gaal> EVal (VPure (PureBit True))

[20:22] <gaal> if the value is already reduced, then that's all the information you need

[20:22] <gaal> unless I'm not understandind where you are

[20:25] <gaal> I don't think Perl gives you a way to promise that an expression will yield some type.

[20:26] <fglock> gaal: this is for low level types only - so the compiler can work as much as possible with unboxed values

[20:27] <fglock> so that it knows for example that 'abc'~'d' is still a string

[20:27] <gaal> hm, we do have a ValNative that has PureBit too... but I'm still not sure I see how AST fits into this

[20:28] <gaal> er

[20:28] <gaal> NBit that is

[20:29] <gaal> but it looks to me you need to do some semantic analysis? maybe you're looking to build another tree, with more hints in it?

[20:30] <fglock> yes - it is performing an ast transformation - at the code-generator level

[20:30] <gaal> ah. you're more advanced than the pugs runcore then.

[20:31] <gaal> meaning, these AST types don't express what you want :/

[20:31] <fglock> oh, ok

[20:34] *** Limbic_Region joined
[20:38] <fglock> I have 3 kinds of bool: unboxed/native value (1 or 0), object (Bool), and unboxed/native expression result ( ?$a )

[20:40] <[particle]> is Bool implemented using bool? if so, then it's really two types

[20:41] <fglock> [particle]: yes

[20:43] <fglock> hmm - it's really 4 types at compile-time: unboxed/boxed and lazy/eager

[20:44] <fglock> ugh - Pugs::Emitter::Perl6::Perl5::Bool::unboxed::lazy

[20:46] <fglock> in p6, if you create a named module inside of another module, does it inherits the base name?

[20:47] <fglock> like: Class X { Class Y { } } - is class Y actually X::Y ?

[20:49] *** kastol joined
[20:52] *** weinig|away is now known as weinig

[20:56] <svnbot6> r13642 | fglock++ | v6 - added Pugs::Emitter::Perl6::Perl5::Expression

[20:57] <[particle]> gaal, did i mention to you that pmichaud's working on PAST now?

[20:59] *** jferrero joined
[20:59] <gaal> P-as-in-Parrot PAST?

[20:59] <[particle]> yes.

[20:59] <[particle]> it should express semantics of all parrot hlls

[21:00] <gaal> I really don't know anything about that. Should probably educate myself!

[21:00] <[particle]> fglock pointed me at p6ast_draft, and i forwarded a link to him

[21:00] <gaal> the draft is outdated

[21:00] <[particle]> well, that's what happens to drafts, isn't it :)

[21:00] <gaal> even more than CapInternasls :)

[21:00] <gaal> especially re: values.

[21:01] <[particle]> where's the latest info?

[21:01] <fglock> [particle]: heh - it is in our heads

[21:01] <gaal> src/Pugs/Val.hs, src/Pugs/Val/*.hs, src/Pugs/Exp.hs

[21:02] <gaal> simply ignore every block not starting with 'data' :-)

[21:05] <[particle]> comments++

[21:08] <svnbot6> r13643 | fglock++ | v6 - moving new emitter to pX/Common/Pugs-Compiler-Perl6

[21:09] <[particle]> parrot/perl6 already uses p6 grammar syntax to define the grammar

[21:09] <[particle]> is there interest in using same to generate grammars for haskell or p5 backends?

[21:09] <[particle]> ...allowing us to unify on a single grammar?

[21:10] <fglock> [particle]: sure

[21:10] <fglock> this was my TPF proposal

[21:10] <[particle]> oh? i had no idea.

[21:10] <gaal> see also scw's misc/pX directory

[21:11] <gaal> (rules -> parsec)

[21:11] * [particle] gets easily lost in the pugs repo

[21:12] *** weinig is now known as weinig|bbl

[21:14] <svnbot6> r13644 | fglock++ | v6 - moving new emitter to pX/Common/Pugs-Compiler-Perl6 (more)

[21:16] <svnbot6> r13645 | fglock++ | v6 - moving new emitter to pX/Common/Pugs-Compiler-Perl6 (done)

[21:18] <TimToady> fglock: yes, class declarations default to "our".  It's just the outer one that happens to be in the * package.

[21:19] <fglock> TimToady: thanks

[21:21] *** spoop joined
[21:24] *** timbunce joined
[21:29] <fglock> gaal: in short, v6.pm creates a syntax tree, very close to p6 syntax - the emitter transforms this tree into a compile-time tree, which knows how to stringify to perl5

[21:29] <gaal> *nod*

[21:30] <fglock> it is probably possible to do this in a single step

[21:33] <gaal> yes, but then you lost portable macros in AST :)

[21:33] <gaal> okay, bedtime for me... good night &

[21:34] <fglock> gaal: it is still an ast tree, I just need to keep node names compatible

[21:36] <fglock> it can be reblessed into another emitter class

[21:36] *** MenTaLguY left
[21:37] <fglock> actually, all the emitter needs to do is to bless the nodes in the syntax tree

[21:41] <fglock> which is actually a good idea, so the syntax tree don't get polluted with these Pugs::Emitter::Perl6::very::large::node::names::which::are::a::pain::to::write

[21:48] *** larsen joined
[21:52] <svnbot6> r13646 | fglock++ | pX/Pugs-Compiler-Perl6 - added tests for ast->perl5

[21:55] *** gunya joined
[22:08] <fglock> when I do ' Bool::True == 42 ' - does it coerce 42 to Bool, or Bool::True to Int ?

[22:09] <fglock> ?eval Bool::True == 42

[22:12] <wolverian> the table in S03 indicates the latter

[22:13] <fglock> wolverian: which section is that?

[22:13] <wolverian> "Smart matching"

[22:14] <wolverian> == seems to be the numeric comparator, in other words.

[22:14] <fglock> found it - thanks!

[22:14] <wolverian> you're welcome

[22:22] *** weinig|bbl is now known as weinig

[22:24] *** SubStack joined
[22:24] <svnbot6> r13647 | fglock++ | pX/v6 - more tests

[22:24] <fglock> so far so good - it can make coercions, and it keeps the Type info

[22:34] *** ludan joined
[22:39] <svnbot6> r13648 | fglock++ | pX/v6 - more compile-time evaluation & typing

[22:39] *** fglock left
[22:42] *** kastol joined
[22:50] *** Aankhen`` joined
[22:51] *** ludan joined
[23:03] *** nperez joined
[23:17] *** weinig is now known as weinig|away

[23:23] *** mako132 joined
[23:29] *** Shabble joined
[23:40] *** aufrank joined
[23:48] *** markstos_ joined
