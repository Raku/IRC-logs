[00:00] <TreyHarris> audreyt: ok, but which of those should have worked?

[00:00] <TreyHarris> i don't see any "unbinding" syntax in synopses

[00:00] <audreyt> $x := Scalar.new;

[00:00] <audreyt> should have worked.

[00:01] <audreyt> Scalar(6) may work but it's not yet clearly specced

[00:01] <audreyt> but $x := Scalar.new should always work.

[00:01] <audreyt> to unbind just bind to undef ;)

[00:01] <TreyHarris> ok, so my tests should be for both $x := Scalar.new and $x := undef

[00:02] <TreyHarris> thanks!

[00:02] <audreyt> but then you can't assign into $x

[00:02] <audreyt> because Undef isn't a good lvalue

[00:02] <TreyHarris> oh...

[00:02] <audreyt> i.e.

[00:02] <audreyt> $x := undef ; $x = 5

[00:02] <audreyt> will fail.

[00:02] <TreyHarris> so "my $x" is syntactic sugar for.... what?

[00:02] <audreyt> my $x is Scalar

[00:02] <audreyt> which binds $x to Scalar.new

[00:02] <audreyt> upon each pad entry

[00:03] <TreyHarris> oh, because Scalar::infix:<=> does that?

[00:03] <audreyt> hm?

[00:03] <audreyt> my $x;

[00:03] <audreyt> is same as

[00:03] <audreyt> my $x is Scalar := Scalar.new;

[00:03] <audreyt> rather, my $x is Scalar; ENTER { $x := Scalar.new }

[00:04] <TreyHarris> but "my Moose $x;" is not the same as "my $x is Moose; ENTER { $x := Moose.new }".

[00:04] <clkao> audreyt: so commitbit worky?

[00:04] <TreyHarris> so where's the magic, if not in Scalar's =?

[00:04] <audreyt> well, neither is "my Scalar $x".

[00:04] <audreyt> look closer :)

[00:05] * TreyHarris cocks his head sidewise

[00:05] <audreyt> my PROTO-CONSTRAINT $x is CONTAINER-CLASS

[00:05] <audreyt> "my $x" is saying

[00:05] <audreyt> my Any $x is Scalar

[00:05] <audreyt> "my Moose $x" is saying

[00:05] <audreyt> my Moose $x is Scalar

[00:05] <audreyt> or actually

[00:05] <audreyt> my Moose $x is Scalar of Moose

[00:05] <audreyt> or actually

[00:06] <audreyt> my $x is Scalar of Moose; ENTER { $x := Scalar.new(::Moose) }

[00:06] <TreyHarris> ok, then "my $x is Moose;" should be the same as "my $x is Moose; ENTER { $x := Moose.new }" then?  so it's a bug?

[00:06] *** _SamB_bot joined
[00:06] <audreyt> what's a bug?

[00:06] <audreyt> "my $x is Moose" is useful when you don't want to assign into $x

[00:06] <audreyt> or when Moose actually handles infix:<=>.

[00:07] <TreyHarris> ?eval my $x is Moose;  $x.WHAT

[00:07] <evalbot_r14596> ::Scalar

[00:07] <audreyt> that is a bug.

[00:07] <audreyt> clkao: aye, worky. do you have a way to measure bandwidth?

[00:07] <TreyHarris> ok.  should complain at compiletime that Moose is undefined, or at runtime that Moose::infix:<=> is undefined?

[00:07] <audreyt> mod_bwshare ?

[00:07] <audreyt> TreyHarris: well, the former

[00:08] <TreyHarris> roger dodger.

[00:09] *** Psyche^_ joined
[00:09] <audreyt> the understanding of this interaction wasn't clear to me until this summer :)

[00:09] *** Psyche^_ is now known as Patterner

[00:09] <audreyt> so Pugs's old runcore lags behind a lot.

[00:10] <audreyt> which is what all this newVal newExp thing is about :)

[00:11] <TreyHarris> right.  I think that's why the Lang/TSa/any(@Larry, me, etc.) conversations go on for so long....  it's very, very difficult to extrapolate the core from the synopses, so since we have a known-incorrect core for experimentation...

[00:11] <TreyHarris> thanks, i'll go write tests now

[00:11] <svnbot6> r14597 | fglock++ | MiniPerl6 - implemented "If", "When", "Int", "Undef" nodes

[00:12] <clkao> audreyt: svn? jifty?

[00:13] <audreyt> clkao: moddav

[00:17] <anatolyv> ?eval { $x }

[00:17] *** evalbot_r14596 is now known as evalbot_r14597

[00:17] <evalbot_r14597> \undef

[00:17] <anatolyv> ?eval { $another_x }

[00:17] <evalbot_r14597> \undef

[00:17] * TreyHarris boggles

[00:17] <anatolyv> evalbot is non-strict?

[00:18] <TreyHarris> ?eval $x = 1

[00:18] <evalbot_r14597> \1

[00:18] <anatolyv> ?eval { usr strict; $another_x }

[00:18] <evalbot_r14597> Error: No compatible subroutine found: "&strict"

[00:18] <anatolyv> ?eval { use strict; $another_x }

[00:18] <evalbot_r14597> Error: *** Unsafe function 'use' called under safe mode‚ê§    at -e line 16, column 7-77

[00:18] <TreyHarris> oh, right, that's a new change

[00:18] <anatolyv> oh well :)

[00:18] <TreyHarris> anatolyv: it didn't used to be strict

[00:18] <anatolyv> audreyt: my point - which I can't demonstrate with evalbot - is this: { $x; my $x } does not fail in strict mode. Is this a bug?

[00:19] <TreyHarris> if i have a moment, i'll look and see if i can modify evalbot to let you do "strict;" or some such.  use is non-safe.

[00:19] <anatolyv> sounds nice.

[00:21] <clkao> audreyt: i don';t know. but i bet you can use throttle of some other stuff

[00:24] *** silug joined
[00:25] *** Psyche^ joined
[00:25] *** Psyche^ is now known as Patterner

[00:26] <eviltwin_b> ...Vensre?

[01:03] *** mako132_ joined
[01:15] <svnbot6> r14598 | audreyt++ | * Quite impossibly, most of MiniPerl6 is now parsed!

[01:15] <svnbot6> r14598 | audreyt++ |   <fglock> Now let's write an emitter!

[01:15] <svnbot6> r14598 | audreyt++ |   <audreyt> Or two...

[01:21] *** dmq joined
[01:22] *** mako132_ joined
[01:22] *** rodi joined
[01:27] *** kanru joined
[01:36] <audreyt> seen on #haskell:

[01:36] <audreyt> 02:34 < audreyt> before Pugs showed up, people used to say the only way to run perl6 code is to ship a complementary clone  of larry wall with each installation of perl6...

[01:36] <audreyt> 02:35 < Igloo> Of course, the advent of pugs has set back the development of cloning processes by decades

[01:39] <eviltwin_b> heh

[01:50] *** diakopter joined
[01:59] *** xinming joined
[02:06] *** scsibug joined
[02:16] *** kanru joined
[02:23] *** geoffb joined
[02:26] *** _SamB_bot joined
[02:33] *** loumz joined
[03:00] *** shobadobs joined
[03:19] *** stevan joined
[03:20] *** shachaf_ joined
[03:47] *** RHainsworth left
[03:52] *** weinig is now known as weinig|zZz

[03:55] *** loumz joined
[03:56] *** penk joined
[03:59] *** mako132_ joined
[03:59] *** SubStack joined
[04:31] <svnbot6> r14599 | allbery_b++ | AUTHORS: hello, world\n :)

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/Compat.hs: added file time tests

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/Internals.hs, src/Pugs/Prim.hs: abstract out guts of "time" for

[04:31] <svnbot6> r14599 | allbery_b++ |   use in $*BASETIME and file tests

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/Run.hs: add $*BASETIME

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/AST.hs: document _reserved and filterUserDefinedPad; add $*BASETIME

[04:31] <svnbot6> r14599 | allbery_b++ |   to _reserved

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/Prim.hs: add file time operators -M, -C, -A

[04:31] <svnbot6> r14599 | allbery_b++ | src/Pugs/Prim/FileTest.hs: add implementation of file time operators

[04:31] <svnbot6> r14599 | allbery_b++ | t/operators/filetest.t: correct existing file time operator tests, add a few

[04:31] <svnbot6> r14599 | allbery_b++ |   more, add all of them to the plan

[04:31] <eviltwin_b> maybe I should have done it in smaller chunks :)

[04:45] *** f0rth joined
[04:49] *** SubStack joined
[05:14] *** eggzeck[laptop] joined
[05:26] <meppl> guten morgen

[05:39] *** drrho joined
[05:55] *** baest joined
[05:55] <jrockway> ok, i got pugs to build on openbsd :)

[05:56] <jrockway> the issue was that the int __init in p5emebed.c conflicts with an __init function in the C library

[05:56] <jrockway> let's see what the test suite thinks about my renaming :)

[05:57] <jrockway> i think the C standard forbids naming a symbol with a __ prefix... it's reserved for internal compiler use

[05:57] <jrockway> let me go look that up

[06:06] <eviltwin_b> correct.  but one common use for __init is that it serves as a shared library initialization.

[06:06] <eviltwin_b> which is in fact what (a) the embed probably wants (b) libc also wants

[06:07] *** nusgnaf joined
[06:07] <eviltwin_b> but openbsd, per usual, is not following the convention, so they conflict

[06:08] <jrockway> any objections to renaming it to something like _p5embed_init?

[06:08] *** nusgnaf joined
[06:09] <eviltwin_b> well, correct behavior is to figure out what the platform wants for a shlib initialization symbol.

[06:09] <eviltwin_b> on some platforms it *must* benamed __init

[06:09] <jrockway> i see

[06:09] <eviltwin_b> on others __init will be used a s a fallback but correct procedure is to insert a reference to the symbol in some object file section.

[06:10] <eviltwin_b> in any case,m just renaming it will likely break other platforms

[06:11] <eviltwin_b> (the linker maps __init specially on those platforms; GNU C has a way to do the magic section foo on ELF platforms, but for the general case one relies on the linker to do magic)

[06:15] <jrockway> probably needs to be IFDEF'd then if people want to compile it from !ports

[06:15] <jrockway> in ports it can just be a patch, though, depending on how y'all feel about IFDEFs

[06:47] *** mr_ank joined
[06:55] *** mr_ank joined
[07:16] *** mr_ank joined
[07:26] *** mr_ank joined
[08:08] *** esstone joined
[08:14] *** marmic joined
[08:15] *** iblechbot joined
[08:35] *** larsen_ joined
[08:57] *** kisu joined
[09:22] *** the_dormant joined
[09:23] *** buetow joined
[09:24] *** larsen_ joined
[09:31] *** kisu joined
[09:52] *** ruoso joined
[09:54] *** kisu joined
[09:58] *** ludan joined
[10:03] *** drrho joined
[10:34] *** BooK joined
[10:38] *** chris2 joined
[11:08] *** jferrero joined
[11:13] *** mr_ank joined
[11:21] *** gene9 joined
[11:30] *** mr_ank joined
[12:14] *** fglock joined
[12:23] *** cmarcelo joined
[12:25] <cmarcelo> is feather ssh down or something?

[12:25] <lambdabot> cmarcelo: You have 1 new message. '/msg lambdabot @messages' to read it.

[12:29] <Juerd> cmarcelo: No. I say this from a feather ssh session :)

[12:30] *** norageek joined
[12:31] <cmarcelo> hmm. its rejecting my pass in ssh but accepting it on feather site.. (webirc).

[12:32] *** Psyche^ joined
[12:32] <cmarcelo> (hmm.. maybe is the firewall in here..)

[12:47] *** ilogger2 joined
[12:56] <xinming> @tell Juerd "Sorry, I don't know that pugs bot would take so much cpu usage. I'll renice it.

[12:56] <lambdabot> Consider it noted.

[12:57] <cmarcelo> @tell audreyt re moh: with only pure functional data, how would I keep "object identity", e.g., Attached methods "points" to their origin classes, but adding methods (eg. when add the constructor to a class or sth else) actually changes the class. a maybe solution is making an indirection on this identification (via IORef).. what do you think?

[12:57] <lambdabot> Consider it noted.

[13:00] *** Limbic_Region joined
[13:06] *** cmarcelo joined
[13:07] <miyagawa_> clkao++

[13:07] <miyagawa_> # for Data::Hierarchy performance improvement

[13:07] <miyagawa_> now svk co for plagger is 10 seconds

[13:15] *** timbunce joined
[13:16] *** diakopter joined
[13:16] *** timbunce joined
[13:19] <Limbic_Region> src/Pugs/Run.hs:38:7: Could not find module `System.Posix.Time':

[13:19] <Limbic_Region> is that a known build error?

[13:23] *** larsen_ joined
[14:05] *** ilogger2 joined
[14:05] <eviltwin_b> \first revision used EpochTime, later corrected to use the same time as everything else

[14:05] <Limbic_Region> I was trying to sneak in the library without the unix package but decided I had better not

[14:06] <Limbic_Region> so I can remove the import line locally?

[14:06] <Limbic_Region> things should then "just work"?

[14:08] <eviltwin_b> yes.  I'm doing a quick compile here to verify then I'll commit

[14:08] <Limbic_Region> well, I didn't wait for a reply - I am attempting a compile now

[14:08] <Limbic_Region> on 8 of 92

[14:08] <eviltwin_b> hm, I don't understand the FileTest error

[14:09] <Limbic_Region> what file test error?  masak's ?

[14:09] <eviltwin_b> yes

[14:10] <eviltwin_b> okay, it's happy here.

[14:10] *** Limbic_Region joined
[14:10] <Limbic_Region> grrr

[14:10] <Limbic_Region> I am not sure that masak is Win32

[14:11] <masak> Limbic_Region: nope, it's CentOS here

[14:11] <Limbic_Region> I however am not building locally even after removing the import line

[14:11] <Limbic_Region> perlbot nopaste

[14:11] <perlbot> Paste your code at http://sial.org/pbot/perl and #perl will be able to view it

[14:11] <lambdabot> Title: sial.org Pastebot - pasteling

[14:11] <masak> lambdabot: you bots are so cute

[14:12] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "r14599 after removing the import System.Posix.Time line from Run.hs" (27 lines, 1.7K) at http://sial.org/pbot/20853

[14:12] <masak> filling in for each other

[14:13] <Limbic_Region> eviltwin_b - I won't have much more time to test/debug

[14:13] <eviltwin_b> huuuh.  those are defined *in* Compat.hs

[14:13] <svnbot6> r14600 | allbery_b++ | src/Pugs/Run.hs: whoops, System.Posix.Time left over from early EpochTime-based

[14:13] <svnbot6> r14600 | allbery_b++ |   time code that I scrapped to match the rest of Pugs

[14:13] <eviltwin_b> nor will I, need to get ready for work soon

[14:13] <Limbic_Region> did you see my nopaste though - if you have ideas let me know and I will take a look

[14:15] <eviltwin_b> yes, I saw it

[14:15] <eviltwin_b> hm, I think I get it

[14:16] <eviltwin_b> yep.  I can't fix it

[14:16] <eviltwin_b> problem is that the stat file time calls don't exist on win32

[14:16] <eviltwin_b> I suppose I need to insert fail stubs

[14:17] <Limbic_Region> please @tell audreyt as you know better than I do

[14:18] <Limbic_Region> today is apparently going to be a busy $work day too :-(

[14:20] *** iblechbot joined
[14:20] <eviltwin_b> @tell audreyt it appears you can't do stat() foo on win32.  committing failWith stubs now

[14:20] <lambdabot> Consider it noted.

[14:22] <svnbot6> r14601 | allbery_b++ | src/Pugs/Compat.hs: Win32 doesn't implement getFileStatus, it appears

[14:24] <Limbic_Region> eviltwin_b - trying build now

[14:25] <eviltwin_b> win32 compatibility is obviously not one of my strong points

[14:26] <Limbic_Region> well - hacking in something is better than hacking in nothing so eviltwin_b++

[14:26] <Limbic_Region> things appear to be compiling

[14:26] <Limbic_Region> 33 of 92

[14:31] <svnbot6> r14602 | allbery_b++ | t/operators/filetest.t: skip file time tests on win32

[14:34] <svnbot6> r14603 | allbery_b++ | t/operators/filetest.t: one-line paste overshoot

[14:34] <Limbic_Region> 81 of 92, look like it might make it

[14:43] *** kisu joined
[14:47] *** shobadobs joined
[14:57] <Limbic_Region> @tell eviltwin_b r14603 built fine on Win32 - thanks

[14:57] <lambdabot> Consider it noted.

[14:57] <eviltwin_b> ok

[14:57] <lambdabot> eviltwin_b: You have 1 new message. '/msg lambdabot @messages' to read it.

[14:58] <eviltwin_b> (will be around for about 10 minutes more)

[14:58] <Limbic_Region> @tell audreyt after removing the import System.Posix.Time from Run.hs and eviltwin_b++ changing to failWith stubs - Win32 compiles fine as of r14603

[14:58] <lambdabot> Consider it noted.

[14:58] <Limbic_Region> ahh, didn't know

[14:58] <eviltwin_b> @messages

[14:58] <lambdabot> Limbic_Region said 55s ago: r14603 built fine on Win32 - thanks

[14:58] <eviltwin_b> dunno if it hols on to those forever or something :)

[15:01] *** rlb3 joined
[15:18] *** jferrero joined
[15:20] <audreyt> eviltwin_b: you can opPerl5.

[15:20] <lambdabot> audreyt: You have 7 new messages. '/msg lambdabot @messages' to read them.

[15:20] <audreyt> eviltwin_b: namely call into perl5 to get stat

[15:20] <audreyt> that's Always Our Plan now

[15:20] <audreyt> see how fork and crypt is done in Pugs.Prim

[15:20] <audreyt> the talk was a resounding success!

[15:20] <Limbic_Region> audreyt++

[15:20] <audreyt> people asked a lot of perl6 questions

[15:20] <masak> audreyt: cool. congrats

[15:21] <audreyt> someone asked if I'm afraid fglock is forking pugs and we'll diverge

[15:22] <audreyt> and I answer "no, because I met fglock in person. :) and that was hilarious

[15:22] <audreyt> and people seems feeling very upbeat about perl, even nonperl users

[15:22] <audreyt> so I suspect Brazil perl mongers is doing some good work here :)

[15:22] *** Pomin joined
[15:22] <Limbic_Region> nice

[15:22] <masak> great

[15:23] <audreyt> lunch now, more hacking this afternoon as I can't grok any of the pt-br talks anyway...

[15:23] <audreyt> be back in a couple hours.

[15:23] <Limbic_Region> audreyt - if I understood one of your last blog entries, we intentionally dropped code for certain features in favor of a unified code base and that in the interim of building that unified code base back up with those features we can just use v5;

[15:24] <Limbic_Region> hrm, shouldn't have taken so long to type the question I guess

[15:25] <masak> I'm still getting the same make error

[15:25] <masak> strange

[15:25] <masak> maybe time to upgrade to GHC 6.6...

[15:43] <Limbic_Region> masak - it will soon be required so make the plunge

[15:44] * masak plunges immediately

[15:46] *** polettix joined
[15:52] *** diakopter joined
[16:03] *** hexmode joined
[16:04] <masak> plunge complete. attempting compile again...

[16:12] *** miyagawa_ joined
[16:51] *** DHGE joined
[16:53] *** avar joined
[17:00] *** DHGE joined
[17:10] *** Debolaz2 joined
[17:12] *** jferrero joined
[17:27] *** polettix joined
[17:28] *** pmurias joined
[17:28] <pmurias> hi

[17:30] <pmurias> Audrey's blog states that thing bootstraped in MiniPerl6 will be faster the the handwriten parts

[17:31] <pmurias> is it due to the fact the will be written with less low-speed constructs?

[17:32] <pmurias> eg. things witch are emulated

[17:33] <TimToady> that's how I read it

[17:43] <audreyt> pmurias: correct. for example, the calling convention will be so simple that te call site syntax is exactly as normal perl5 calls

[17:43] *** rodi joined
[17:43] * nothingmuch grazes

[17:43] * nothingmuch also greets the hackathoners

[17:44] <xerox> have you taken part to the hackaton?

[17:44] * nothingmuch ?

[17:44] <nothingmuch> no, i was hiking

[17:44] <nothingmuch> and now i'm pooped

[17:44] <xerox> er.

[17:44] <[particle]> moose poop

[17:44] <nothingmuch> both activities were not being performed in .br

[17:45] * nothingmuch woke up today, and proceeded to nap on the couch, subsequently resting in the arm chair

[17:45] <audreyt> fglock is giving a p6 crash course to conisli people

[17:45] <xerox> alright

[17:45] <xerox> do you know that there are the videos online of the event?

[17:45] <nothingmuch> oh! cool

[17:45] <xerox> @yarr

[17:45] <lambdabot> I'd like to drop me anchor in her lagoon

[17:46] <audreyt> I'm back at my room going to take a nap and then finish up commitbit transition; ook up iveminder as our todo list, and sketch up some microgrant ideas, and other administrivia. oh and also finish up emitter design

[17:46] <eviltwin_b> I'm not going to touch win32 stuff, sinced (as I demonstrated) I can't test it

[17:46] <audreyt> that line should read "hook up hiveminder"

[17:46] * nothingmuch ooks up a CPAN

[17:46] <xerox> Ook! Ook?

[17:46] <xerox> √π

[17:47] <xerox> @google site:wikipedia.org ook programming language

[17:47] <lambdabot> http://en.wikipedia.org/wiki/Brainfuck

[17:47] <xerox> Er.

[17:48] <audreyt> @tell cmarcelo you can use IORef, or you can use recursive-do notation ("mdo"). I'd suggest ioref for ease of mplementation

[17:48] <lambdabot> Consider it noted.

[17:51] <nothingmuch> audreyt: what is that for?

[17:51] <nothingmuch> the mutable fields of the classes?

[17:53] <audreyt> nothingmuch: yes

[17:53] <nothingmuch> please ignore the 'is rw'

[17:53] <nothingmuch> make them all ro

[17:53] <nothingmuch> that's just out of laziness because we can in perl

[17:53] <nothingmuch> but moh should be purely functional

[17:54] <audreyt> how do you attach methods ten

[17:54] <audreyt> then

[17:54] <nothingmuch> that's for pugs

[17:54] <nothingmuch> to use moh pugs will map the mutable model to the pure ones

[17:55] <audreyt> can you add comments on the MO code where such mapping will suppose to happen?

[17:55] <audreyt> that'd help caio and me a lot

[17:55] <nothingmuch> nowhere in the mo code

[17:55] <nothingmuch> that is the responsibility of moh using code, i guess

[17:56] <nothingmuch> the structure of the mutable metaclasses should be optimized for the convenience of pugs' implementation

[17:57] <nothingmuch> as long as it's easily translatable to moh before pugs uses moh it still makes sense

[17:57] <nothingmuch> that way moh is useful for systems which don't care about mutable metaclasses

[17:57] <audreyt> ok

[17:57] <nothingmuch> sorry for blabberring, i'm not very coherent

[17:57] <nothingmuch> that sentance wasn't coherent either... it was ambiguously redundant ;-)

[17:59] *** diakopter joined
[17:59] <audreyt> bbiab...

[17:59] <nothingmuch> @tell cmarcello please backlog for around the time audreyt's moosage was sent... unless she objects i think i ruled otherwise

[17:59] <lambdabot> Consider it noted.

[18:05] <pmurias> audreyt: thanks

[18:10] <Limbic_Region> audreyt - if I understood one of your last blog entries, we intentionally dropped code for certain features in favor of a unified code base and that in the interim of building that unified code base back up with those features we can just use v5;

[18:16] *** ludan joined
[18:17] *** hexmode joined
[18:24] <nothingmuch> audreyt: please pong, i'd like to toss around an idea before p6l-ing

[18:34] *** loumz joined
[18:34] <jrockway> hmm, so i'm smoking trunk on openbsd now

[18:35] <jrockway> and it's been printing "# Actual: undefined" for the last hour or so

[18:35] <jrockway> shoudl I just kill the smoke?

[18:42] <loumz> a little question, 1 == 0 in the pugs shell returns Bool::False ... how do I print this Bool::False value so that it is visible?

[18:42] <svnbot6> r14604 | particle++ | v6: whitespace cleanup and editor hints

[18:43] <jrockway> oh, it finished :)

[18:48] <nothingmuch> loumz: what do you mean by visible?

[18:49] <loumz> nothingmuch: print Bool::False doesn't print anything... how do I convert this Bool::False into a string representation like the way the pugs shell does it

[18:49] <nothingmuch> .perl

[18:49] <nothingmuch> ?eval Bool::False

[18:49] <evalbot_r14604> Bool::False

[18:49] <nothingmuch> ?eval Bool::False.perl

[18:49] <evalbot_r14604> "Bool::False"

[18:49] <loumz> nothingmuch: thanks

[18:49] <nothingmuch> .perl is a dumper

[18:49] <nothingmuch> much like Data::Dumper

[18:50] <nothingmuch> ?eval Bool::False.yaml

[18:50] <evalbot_r14604> "--- false\n"

[18:50] <nothingmuch> also useful =)

[18:50] <loumz> nice :)

[18:54] <nothingmuch> foooooo

[19:13] *** frederico joined
[19:28] *** cmarcelo joined
[19:28] <nothingmuch> hola cmarcelo

[19:29] <cmarcelo> hey

[19:29] <lambdabot> cmarcelo: You have 1 new message. '/msg lambdabot @messages' to read it.

[19:29] <cmarcelo> @moosages

[19:29] <lambdabot> audreyt said 1h 40m 12s ago: you can use IORef, or you can use recursive-do notation ("mdo"). I'd suggest ioref for ease of mplementation

[19:29] <nothingmuch> err, two

[19:29] <cmarcelo> nothingmuch: its cmarcelo with only one L

[19:29] <nothingmuch> i sent mine to cmarcello =(

[19:29] <nothingmuch> yeah

[19:29] <cmarcelo> but i read

[19:29] <nothingmuch> i do that every time

[19:30] <cmarcelo> so i should ignore this origin/attach thing?

[19:30] <nothingmuch> nope

[19:30] <nothingmuch> origin is precisely what allows moh to be purely functional

[19:30] <nothingmuch> without too much effort when the input was mutable to begin with

[19:30] <nothingmuch> also, it lets us do weird shit with the layouts/accessor inlining

[19:31] <cmarcelo> well:

[19:32] <nothingmuch> { origin :: Show a => a, item :: b }

[19:33] <nothingmuch> then you could give this data type the instance over the type class AttachedAttribute if b has an instance of the typeclass attribute, for example

[19:33] <nothingmuch> my syntax is off, but you get what i'm saying, right?

[19:33] <cmarcelo> if I attach method to a class [both data] the class itself would change, so origin I create for the method will be obsolete dont?

[19:33] <nothingmuch> nope

[19:34] <nothingmuch> the notion of attaching is different

[19:34] <nothingmuch> you can add a method in a mutable model

[19:34] <nothingmuch> that doesn't matter

[19:35] <nothingmuch> the type of the function that plumbs pugs land into moh land should be along the lines of MetaObject (IORef Method) -> IO MetaObject Method

[19:35] <nothingmuch> where MetaObject is something like a class

[19:35] <nothingmuch> and (IORef Method) and Method are the type of the subitems

[19:35] <nothingmuch> of course, a richer meta object would require types for the other possible submeta objects

[19:35] <nothingmuch> then when this is all fed into the meta model moh runs through it

[19:35] <nothingmuch> and creates attachment 'tags' that simply keep track of where a method was found

[19:36] <stevan> so there is a meta object to indicate the attachment as well

[19:36] <nothingmuch> yes

[19:36] <stevan> your meta-crazy boy!

[19:36] <nothingmuch> the idea is that given $class->all_methods you get back a list of items

[19:36] <nothingmuch> and you can know which susperclass each method was defined in

[19:36] <nothingmuch> and the method meta object doesn't have to keep track of this on it's own

[19:37] <stevan> is the attachment object two way?

[19:37] <nothingmuch> this makes metamodel translation easier

[19:37] <nothingmuch> it's a wrapper

[19:37] <stevan> wrapper?

[19:37] <nothingmuch> class AttachedMethod { has $method; has $origin }; # plus some delegated methods for conenience

[19:38] <stevan> origin --> class?

[19:38] <nothingmuch> $class->all_methods; # this runs through the class precednece list, as computed by the MRO, including all roles etc

[19:38] <nothingmuch> # and for each class it encournters it lists all it's defined methods

[19:38] <nothingmuch> and attaches them to that class

[19:38] <nothingmuch> the result is a list of AttachedMethod objects

[19:38] <nothingmuch> each of which contains the origin (class/role which the method was defined in)

[19:38] <nothingmuch> and the method itself

[19:40] <stevan> so by using the monads to associated metas (which is what I assume the IO* stuff is), you are keeping it purely functional?

[19:40] <nothingmuch> no, i don't do that at all

[19:40] <stevan> ok

[19:40] <nothingmuch> s/me/moh/;

[19:40] <nothingmuch> in theory

[19:40] <nothingmuch> mo is just a computation library

[19:40] <nothingmuch> for object oriented stuff

[19:41] <cmarcelo> nothingmuch: when I add a method to a class, it changes the class, making older origins obsolete, .. or Im getting wrong and should provide every method upfront?

[19:41] <nothingmuch> no

[19:41] <nothingmuch> you never add a mehtod to a class in moh

[19:41] <nothingmuch> you create a new class that has thed combination of the methods

[19:41] <stevan> you attach it :)

[19:41] <nothingmuch> no =)

[19:41] <stevan> :P

[19:41] <nothingmuch> attached items are intermediate data structures

[19:41] <nothingmuch> they are only used during compilation to mark the origin of a method

[19:42] <nothingmuch> they are not maintained and kept up to date at all

[19:42] <stevan> so how do you handle runtime introspection then?

[19:42] <nothingmuch> s/introspection/modification/;

[19:42] <stevan> nop

[19:42] <nothingmuch> that's pugs' responsibility

[19:42] <stevan> e

[19:42] <nothingmuch> wtf?

[19:42] <nothingmuch> you just do it

[19:43] <stevan> s/modification/introspection on immutable attributes/

[19:43] <nothingmuch> they must be wrapped in a language b indeing

[19:43] *** TSa joined
[19:43] <stevan> who is "they"

[19:44] <nothingmuch> all the methods

[19:44] <nothingmuch> sorry

[19:44] <nothingmuch> for example

[19:44] <nothingmuch> all_methods

[19:44] <stevan> other than the people in the black helicopter who follow my every move

[19:44] <nothingmuch> that is a method on meta classes

[19:44] <nothingmuch> in pugs that wrapper will do this:

[19:44] <nothingmuch> take the mutable meta class in question, present moh with an immutable "snapshot" of this

[19:44] <nothingmuch> call the moh all_methods method on that snapshot

[19:45] <nothingmuch> and wrap the result in whatever monad it's using to evaluate

[19:45] <nothingmuch> e.g. Eval [MetaMethod]

[19:45] <stevan> ok

[19:46] <stevan> so the mutable meta class which Pugs has, this is not introspectable on it's own?

[19:46] <nothingmuch> it is

[19:46] <stevan> all introspection and modification must go through MOH ?

[19:46] <nothingmuch> not necessarily

[19:46] <nothingmuch> the lightweight stuff can ignore mo

[19:46] <nothingmuch> for example extracting the "local" methods

[19:46] <stevan> what is lightweight?

[19:46] <nothingmuch> (not inherited ones)

[19:47] <nothingmuch> anything that doesn't require computation over the meta model is just a direct mapping to the data structure

[19:47] <nothingmuch> for example superclasses is lightweight

[19:47] <nothingmuch> it's just a list

[19:47] <stevan> I think maybe it should still be MOH's responsibiltiy

[19:47] <cmarcelo> nothingmuch: im trying to commit some code so you can see what im getting wrong

[19:47] <nothingmuch> class_precedence_list, on the other hand, is heavy weight

[19:47] <TimToady> memoized metas, yum.

[19:48] <nothingmuch> my latest obsession is getting FRP support in perl 6 through passthrough types

[19:48] <nothingmuch> i'll p6l that once i reach more coherence

[19:48] <stevan> nothingmuch: why not put it all on MOH's burden

[19:48] <PerlJam> FRP support?

[19:48] <nothingmuch> so theoretically recompution through P6MO will be very very easy

[19:48] <nothingmuch> PerlJam: functional reactive programming

[19:48] <PerlJam> ah

[19:49] <PerlJam> #perl6 is always speaking in tongues to me  ;-)

[19:49] <nothingmuch> stevan: because the question "what are all the methods of class x, which inerhits blah blah blah" is not related to IORefs in any way

[19:49] <TimToady> I thought it was Fantasy Role Playing...

[19:50] <nothingmuch> with FRP the translation layer in pugs/p6 will be to simply present moh with signals for classes

[19:50] <nothingmuch> for example the 'superclasses' will be Signal [Method]

[19:50] <TimToady> I suppose that's not so different, actually...

[19:50] <nothingmuch> err

[19:50] <nothingmuch> Signal [Class]

[19:50] <nothingmuch> and methods will be Signal [Method]

[19:50] <nothingmuch> the moh code will be transformed by the signal passthrough type to recompute as necessary

[19:50] <nothingmuch> when the signal is updated due to some event

[19:50] <nothingmuch> e.g.. modifying the metaclass

[19:51] <TSa> HaloO, what does MOH mean?

[19:52] <nothingmuch> the port of MO to haskell

[19:52] <nothingmuch> http://nothingmuch.woobling.org/MO/

[19:52] <TimToady> it's .HOW spelled rotated 180¬∞

[19:52] <lambdabot> Title: Index of /MO

[19:52] <nothingmuch> TimToady++

[19:53] <nothingmuch> ... the reason for all this purely functional mumbo jumbo is that you can then do translations of the metamodel with no worries

[19:54] <TimToady> What, me worry?

[19:54] <nothingmuch> for example, augmenting all the classes with an additional method is simply a matter of running the meta model through a mapping function that takes a class and returns a copy of that class with an augmented list of methods

[19:54] <stevan> nothingmuch: it eliminates side-effects,... worries are another thing entitely

[19:54] <stevan> because the p6 view of it is not purely functional

[19:55] <nothingmuch> i just explained how it is =)

[19:55] <TimToady> It's all safely hidden behind .HOW as far as I'm concerned.  Ignorance is bliss...

[19:55] <nothingmuch> it's not purely functional

[19:55] <nothingmuch> it just inverts the control flow

[19:55] <nothingmuch> such that the computation part is purely functional

[19:55] <stevan> ok

[19:56] <nothingmuch> pugs' purify_class :: IOClass -> IO Class

[19:56] <stevan> I mean that from the p6 point of view, the transformation of metaclasses are a side-effectual thing

[19:56] <nothingmuch> all_methods :: IOClass -> IO Method

[19:56] <stevan> unless of course I am misunderstanding (which is entierly possible)

[19:56] <nothingmuch> all_methods = all_methods . purify_class

[19:57] <nothingmuch> that's two steps

[19:57] *** SubStack joined
[19:57] <nothingmuch> transform, and then commit back to the metamodel

[19:57] <nothingmuch> the metamodel is kept in some sort of IORef in the pugs runtime

[19:57] <nothingmuch> the symbol table, likely

[19:57] <nothingmuch> but the "natural" return value of a transformation is just an anonymous class

[19:57] <nothingmuch> the input is also an anonymous class

[19:58] <nothingmuch> classes don't know their names in moh, just their definitions

[19:59] <cmarcelo> nothingmuch: http://feather.perl6.nl/~cmarcelo/moh/MO/Compile/Class.hs .. see class Class, the method add_method_class doesnt make sense, at least not for creating constructors and such, right? they should be created all toghether and once..

[19:59] <lambdabot> http://tinyurl.com/yndc8n

[19:59] <nothingmuch> cmarcelo: moh does not have add_* or remove_*

[19:59] <nothingmuch> that's just the pugs meta model

[19:59] <nothingmuch> MO.Compile.Class is a snapshot of a pugs meta class

[20:00] <nothingmuch> that is, you can easily do add_method in mo

[20:00] <nothingmuch> and the type is indeed c -> AnyMethod -> c

[20:00] <nothingmuch> but wrapping that in a monad is the responsibility of whoever is using moh

[20:00] <stevan> nothingmuch: so (meta)object identity is not tied to a particular meta object, but transfered during the transformation process?

[20:01] <nothingmuch> stevan: not unless it's necessary for the meta model itself

[20:01] <stevan> yes

[20:01] <cmarcelo> ok. if Pugs need change something itll regenerate everything again...

[20:01] <stevan> but if there is a change and a new class is generated

[20:01] <nothingmuch> cmarcelo: naively yes

[20:01] <nothingmuch> stevan: explain?

[20:01] <stevan> c -> AnyMethod -> c

[20:01] <nothingmuch> the input c and the output c are not the same c

[20:01] <stevan> yes

[20:02] <nothingmuch> they may be stored in an IORef that is accessible under the same name

[20:02] <stevan> but from an identity POV they are

[20:02] <nothingmuch> no

[20:02] <stevan> yes, that is what I mean

[20:02] <stevan> nothingmuch: nomenclature issues abound :P  but I think I understand

[20:02] <nothingmuch> my $anon_class_with_method = $anon_class->add_method( $method );

[20:03] <nothingmuch> while we can support this in MO(H)? i don't think this is useful in any way

[20:03] <stevan> and $anon_class_with_method->oid == $anon_class->oid right?

[20:03] <nothingmuch> stevan: there is no oid in mo

[20:03] <nothingmuch> it's all haskell baby

[20:03] <stevan> ->name then

[20:03] <nothingmuch> no name either

[20:03] <stevan> whatever,.. some kind of global identifier with which you can access it from perl-land

[20:04] <nothingmuch> none

[20:04] <stevan> it does not have to be in the haskell itself

[20:04] <nothingmuch> there is no such thing

[20:04] <nothingmuch> unless the user explicitly adds it to their meta classes

[20:04] <stevan> if it has no name,.. how do I find it

[20:04] <nothingmuch> you have to give a way to find it

[20:04] <nothingmuch> that's the whole point

[20:04] <nothingmuch> moh doesn't care at all

[20:04] <stevan> yes

[20:04] <nothingmuch> instalce MyClass Mo.Class blah blah blah

[20:04] <stevan> but someone will have to care at some point

[20:04] <nothingmuch> where MyClass has some oid

[20:04] <stevan> yeah

[20:05] <nothingmuch> *nod*

[20:05] <stevan> ok,.. makes sense

[20:05] <nothingmuch> but yhou only need it for "root" objects

[20:05] <cmarcelo> nothingmuch: i'll get rid of add_method then and see if get the origin/attach into class..

[20:05] <nothingmuch> a method doesn't need to care about which classes it's attached to

[20:05] <nothingmuch> cmarcelo: origin/attach are orthogonal to add_method

[20:05] <nothingmuch> they are very very important

[20:05] <nothingmuch> so please keep them =)

[20:06] <nothingmuch> add_method might be part of a convenience package

[20:06] <stevan> so really MOH is a set of functions to operate over the meta-land data structures

[20:06] <nothingmuch> yes

[20:06] <stevan> s/MOH/MO/

[20:06] <nothingmuch> i've said so before, perhaps not so succintly

[20:06] <stevan> no you said it fine :)

[20:06] <nothingmuch> well, not realily functions, since it's OO ;-)

[20:07] <cmarcelo> nm: yep, but add_method was making origin/attach depend on mutable data..

[20:07] <audreyt> cmarcelo: where are you?

[20:07] <nothingmuch> no

[20:07] <audreyt> methods are just named closures ;)

[20:07] <nothingmuch> origin/attach is just where it c ame from "right now"

[20:07] <nothingmuch> audreyt: not in mo

[20:07] <nothingmuch> the class is responsible for naming them

[20:08] <audreyt> 21:06 < nothingmuch> well, not realily functions, since it's OO ;-)

[20:08] <cmarcelo> audreyt: in Perl "stand" but is very noisy here.. where you?

[20:08] <audreyt> was metareplying

[20:08] <audreyt> not userland

[20:08] <nothingmuch> ah =)

[20:08] <nothingmuch> cmarcelo: remember that $attached is an intermediate value

[20:08] <audreyt> cmarcelo: in my room just woke up. maybe 1)you come up and hack or 2)we meet at lobby and hack, say in 30min?

[20:08] <nothingmuch> if you have class A isa B { method foo } class B { method bar }

[20:08] <nothingmuch> then A.all_methods will return two methods, 'bar', and 'foo'

[20:09] <nothingmuch> wrapped in Method::Attached objects

[20:09] <nothingmuch> which point to the class they were found in

[20:09] <cmarcelo> audreyt: lobby in 30min then

[20:09] <nothingmuch> audreyt: got 10 mins?

[20:10] <cmarcelo> audreyt: btw, unicamp folks were *very* amazed with pugs' anarchistic dev environment...

[20:10] <audreyt> nothingmuch: yes?

[20:10] <audreyt> cmarcelo: and what's this unicamp? :)

[20:10] <cmarcelo> err.. University of Campinas :)

[20:11] <nothingmuch> audreyt: i have been thinking of how to specify "wrapper" types, or "passthrough" types, whichever name is more metaphorically applicable

[20:11] <audreyt> oh ok :)

[20:11] <nothingmuch> the idea is basically to create values with added value ;-)

[20:11] <nothingmuch> this is for FRP in Perl 6 without adding FRP to the core

[20:11] <nothingmuch> for example, the FRP signal object is a wrapper over any value

[20:11] <nothingmuch> a parametrized type

[20:12] <nothingmuch> that supports all the methods that the underlying type supports

[20:12] <nothingmuch> but gets to intercept them

[20:13] <nothingmuch> to implement an FRP signal you first delegate to the normal method with all the arguments

[20:13] <nothingmuch> if the arguments are signals themselves you unwrap them

[20:13] <nothingmuch> then you capture the caller continuation, and put it in all the signal arguments' update list

[20:14] <nothingmuch> thus you can reuse "normal" code that operates on a certain type in FRP code with no change

[20:14] <nothingmuch> by simply giving that chunk of code wrapped types

[20:14] <nothingmuch> runtime costs will be fairly high, i guess

[20:14] <nothingmuch> but this is very useful

[20:14] <nothingmuch> $audreyt->sanity_check( @backlog );

[20:14] <audreyt> er, I know, and that's how exactly we'll target CLR

[20:15] <nothingmuch> okay

[20:15] <audreyt> from what I gather with emeijer and other CLR folks

[20:15] <nothingmuch> i think i can draft up a new type

[20:15] <nothingmuch> wrapper Foo { ... }

[20:15] * audreyt is glad a certain microsoft is now contractually obliged to not sue us over patents if we make that happen

[20:15] <nothingmuch> ooooh

[20:15] <nothingmuch> shiny

[20:16] <nothingmuch> who is "us" in that sentance?

[20:17] <nothingmuch> .. the reason i'm liking FRP so much lately is that it really simplifies writing dynamically updating code

[20:17] <nothingmuch> so things like changing the metaclass can be supported without making the code that compiles the metaclass (moh in perl 6) very very ugly ;-)

[20:18] <nothingmuch> this naturally also applies to link time optimizations being unvalidated by dynamically loaded code

[20:18] <nothingmuch> and other crazy stuff which we want but don't want to really write

[20:18] <audreyt> "us" is whomever works on pugs -CCLR, probably not now, maybe some time in the future :)

[20:18] <nothingmuch> ah

[20:18] <nothingmuch> anymoose, please think about the api wrapper types will want

[20:19] <nothingmuch> for representing overloaded passthrough values

[20:19] <nothingmuch> for stuff like FRP, foreign objects, etc

[20:19] <nothingmuch> i will try to write something up, and then maybe you can give critique

[20:19] *** c6rbon joined
[20:20] <audreyt> okay.

[20:20] <nothingmuch> where is Cont documented, btw?

[20:20] <nothingmuch> oh, nevermoose

[20:20] <nothingmuch> found it

[20:21] <nothingmuch> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html

[20:21] <lambdabot> http://tinyurl.com/gnsuu

[20:21] <cmarcelo> audreyt: did you find more help to translate ppencode?

[20:22] <audreyt> cmarcelo: no

[20:23] <audreyt> nothingmuch: it's just CPS.

[20:24] <nothingmuch> audreyt: yeah, i've been finally reading up on it

[20:24] <nothingmuch> i was curious where when came from

[20:24] <nothingmuch> but it's actually in Monad

[20:28] *** mauke joined
[20:30] *** fglock joined
[20:33] <nothingmuch> zzzz &

[20:33] * audreyt prepares to go down to lobby

[20:37] <fglock> audreyt: we're at the Perl booth

[20:37] <lambdabot> fglock: You have 2 new messages. '/msg lambdabot @messages' to read them.

[20:38] <nothingmuch> @mooooooooooooosages

[20:38] <lambdabot> Unknown command, try @list

[20:38] <audreyt> fglock: ok, tell cmarcelo I'll go to perl booth to fetch him (or you both)

[20:38] <nothingmuch> <3 lambdabot

[20:38] <nothingmuch> *poof*

[20:39] <fglock> ashleyb: re http://sial.org/pbot/20775 - I included it in the test suite - thanks! I couldn't fix it yet

[20:39] <obra> how's the conference?

[20:39] <lambdabot> Title: Paste #20775 from "ashleyb" at 66.201.51.66

[20:39] <fglock> obra: fine!

[20:39] <obra> excellent.

[20:40] <obra> I really must get there one of these years.

[20:40] <fglock> obra: we are the only language with a booth :)

[20:40] *** cmarcelo joined
[20:41] <fglock> I'm working on the MiniPerl6 emitter (written in MiniPerl6, of course)

[20:42] <audreyt> ...but not emitting to miniperl6...

[20:42] <clkao> but... i want maxiperl6

[20:42] <clkao> and also poniperl6

[20:42] <TimToady> @fglock¬ª++

[20:42] <lambdabot> Unknown command, try @list

[20:42] *** dvorak joined
[20:43] <fglock> emitting to Perl5, for now

[20:43] * obra wonders if MiniPerl6 would be an interesting language for one of the parrot hackers to just hack up

[20:43] <fglock> Parrot hacks bottom-up, Pugs hacks top-down

[20:44] <TimToady> there's a middle there somewhere...

[20:44] <obra> TimToady: as long is the middle isn't that cloud that we see in the middle of every network diagram

[20:45] <TimToady> I dunno--that's been a pretty successful cloud, as clouds go...

[20:45] <fglock> you know the chinese icon for "stay" (up and down) balas++ for teaching some chinese to us

[20:45] <audreyt> U+5361

[20:45] <obra> Fair enough

[20:45] <TimToady> Âç°

[20:46] <fglock> not knowing if a middle actually exists, the projects keep moving

[20:48] <fglock> ugh - can't commit from the booth - ssh blocking firewall

[20:48] <TimToady> the middle usually exists when the radical is used as part of another characrer: Â≥†

[20:50] <TimToady> Âû∞ Â≥† Êåä Ê°õ Ë£É Èûê

[20:52] <TimToady> ‰Ωß Êã§ ËÉ© Èâ≤ are the ones without a middle.

[20:52] <TimToady> (at least in my font)

[20:52] * audreyt praises TimToady's reverse semantic index system into UniHan

[20:53] <TimToady> one of these years I'll have to do all the compatibility characters as well...

[20:54] *** miyagawa_ joined
[20:55] <audreyt> it's fortunate that you're still hacking perl instead of joining Unicode.org's Ideographic Rapporteur Group...

[20:55] <TimToady> by the way, Âç° is called "checkpoint" in my system.  The "middle" form is called "updown".

[20:55] <audreyt> I hear people go into IRG and was never heard from again...

[20:55] <Limbic_Region> audreyt - if I understood one of your last blog entries, we intentionally dropped code for certain features in favor of a unified code base and that in the interim of building that unified code base back up with those features we can just use v5;

[20:56] <TimToady> I almost went into my own private IRG and was never heard from again...

[20:56] * Limbic_Region wonders if his client is eating his chatter

[20:57] <Limbic_Region> half of what I have typed has apparently not made it into the channel according to the irc logs

[20:57] <audreyt> Limbic_Region: well, it's more like we want to Bootstrap Now

[20:57] <TimToady> you'll either have to type twice as fast or half as fast.  Not sure which...

[20:57] <audreyt> in particular the grammar engine is to be thoroughly ported to perl6

[20:58] <audreyt> but we also want it to run competitively fast on both our runtimes

[20:58] <audreyt> and the full perl6 just can't run on perl5 competitively fast without a bunch of XS speedups

[20:58] <audreyt> which increases maintainence overhead

[20:58] <fglock> Limbic_Region: MiniPerl6 works as an intermediate language, also good for bootstrapping

[20:58] <fglock> bootstrapping = implementing Rules, MO

[20:59] <fglock> and a Perl6 compiler

[20:59] <audreyt> but _not_ the runtme :)

[21:00] <fglock> the Perl6 compiler will then implement the remaining features

[21:00] <Limbic_Region> ok - I guess I either didn't spend enough time reading that blog post or the intent wasn't clear

[21:00] * Limbic_Region re-reads it

[21:00] <fglock> which can be supported by the VM natively or not

[21:01] *** aufrank joined
[21:02] <fglock> Limbic_Region: a nice thing is that MiniPerl6 is written in MiniPerl6 - and it took just a couple of days to put it together

[21:03] <fglock> audreyt: mk is here

[21:03] <Limbic_Region> my confusion came from "Oud rallying cry is one single Pugs codebase in Perl 6, as we seek to remove the massive code duplication in the current Haskell and Perl 5 runtimes."

[21:04] <Limbic_Region> and then "To facilitate the migration, I've amended the relevant part of the Modules spec (S11), so now we can trivially inline Perl 5 code inside a Perl 6 programs, with use v5 at the beginning of a lexical block."

[21:04] <Limbic_Region> but if what this really means is bootstrapping then wooooooot

[21:04] <fglock> Limbic_Region: yes, these are 2 unrelated features

[21:05] <TimToady> they'd have had to remove a lot more of S?? to chop the entire language down to that size.  :)

[21:06] <audreyt> Limbic_Region: let's see... we still implement full perl 6.

[21:06] <audreyt> but we implement the full perl 6 with part of perl 6.

[21:06] <audreyt> and at this moment that part of perl 6 includes some part of perl 5.

[21:06] <TimToady> (at least for now)

[21:06] <Limbic_Region> audreyt - yeah, I get it now

[21:06] <audreyt> and once we have full perl 6 implemented in part of perl 6

[21:06] <audreyt> then we implement full perl 6 in full perl 6 :)

[21:07] <fglock> Perl6 can grow back lost limbs

[21:07] <wolverian> wasn't this the plan like, three years ago? nice to see plans working out :)

[21:07] <audreyt> more than three years ago

[21:07] <audreyt> but yeah :)

[21:07] <audreyt> "mini" is shorter to type than "featherweight".

[21:08] <TimToady> Perl6ish is shorter by 1

[21:08] <audreyt> Perl6i is shorter

[21:08] <TimToady> Perl6ly

[21:08] <audreyt> it's the next version of Perl5i

[21:08] <wolverian> perl6.0-omega

[21:08] <audreyt> of damian's

[21:08] <TimToady> Perk6

[21:09] <wolverian> er, pork.. now I'm hungry. bye!

[21:09] <audreyt> if I continue IRC I'll never make downstairs

[21:09] <jrockway> anything cool that we can do with miniperl6 right now? (i'm way behind on my perl6 lists :/ )

[21:09] <audreyt> so... bbiab

[21:09] <fglock> audreyt: are you at the lobby? I need some help :)

[21:09] <fglock> oh, ok :)

[21:09] <audreyt> fglock: going there in a bit

[21:10] <TimToady> jrockway: not yet, unless you just want to compile MiniPerl6.

[21:10] <Limbic_Region> so my limited understanding of bootstrapping is that you write a minimal compiler for lang X in lang Y and then compile lang Y with that minimal compiler and for subsequent iterations you use the complete lang Y implementation

[21:10] <TimToady> they're currently working on emitters.

[21:10] <Limbic_Region> except when you need to start fresh and there isn't a pre-existing binary

[21:10] <fglock> jrockway: yes - write itself (it's under devel)

[21:10] <Limbic_Region> in which case you always keep around the minimal version in lang X

[21:10] <Limbic_Region> so my question is this

[21:10] <TimToady> then you usually do cross-compiler instead.

[21:11] <Limbic_Region> what is our lang X - ghc?

[21:11] <jrockway> "mini" things are always exciting to me because they're small enough to do a really good job on, which is nice

[21:11] <jrockway> :)

[21:11] <Limbic_Region> TimToady - yes, I understand the cross-compiling

[21:12] <fglock> Limbic_Region: MiniPerl6 "X" is (Haskell|Perl5)

[21:12] <Limbic_Region> fglock - ok

[21:12] <TimToady> that's what blog meant by "unified", in part

[21:12] <Limbic_Region> so we are trying to keep MiniPerl6 as mini as possible so that Lang X could be any lang X?

[21:12] <fglock> and hopefully Parrot soon

[21:12] <Limbic_Region> IOW - parrot

[21:13] <Limbic_Region> ahh, ok

[21:13] <fglock> Limbic_Region: yes - Javascript, for example

[21:13] * Limbic_Region is experiencing a great deal of lag

[21:13] <Limbic_Region> not everything I am typing is getting to the channel either

[21:14] <Limbic_Region> ok, well fglock++ audrey++ TimToady++ upvotes all around

[21:14] <fglock> so we implement the mini-perl6 emitter in lang X, and it compiles the remaining parts (but you still need to make the runtime libs)

[21:15] <cj> so... I heard something about perl6 running in a javascript vm?

[21:16] <Limbic_Region> does smartlinks give us an indicator of what percentage of the existing spec is implemented?

[21:16] <fglock> cj - not yet - it's a plan

[21:16] <cj> fglock: alrighty

[21:16] <cj> I'll not plan on using it in production then :)

[21:16] *** kane-xs joined
[21:17] <fglock> Limbic_Region: MP6 requires a different programming style - it's not likely to compile Test.pm

[21:17] *** penk joined
[21:17] <Limbic_Region> fglock - not what I meant

[21:18] <avar> where's this in svn?

[21:18] <avar> (mp6)

[21:18] <fglock> Limbic_Region: ?

[21:18] <fglock> avar: /v6

[21:18] <Limbic_Region> fglock - I am asking in any/all backend with our test suite smart linked to the synopses

[21:19] <fglock> no, I think only Pugs is smartlinked

[21:19] <Limbic_Region> ok, so for Pugs then - does the smart linking give us an indicator of the % of the existing spec that is implemented

[21:20] <Limbic_Region> fglock - I apologize, I switched thoughts without telling you

[21:21] <fglock> I don't know

[21:21] <Limbic_Region> seems like it would be a nice metric to have

[21:22] <TimToady> seems like you'd have to smartlink to individual sentences to have that.

[21:22] <Limbic_Region> "The existing Perl 6 specification is 87% of the expected complete specification.  Pugs implements 98% of the known Perl 6 specification."

[21:22] <TimToady> I suspect most smartlinks only test a few sentences out of a paragraph

[21:22] <Limbic_Region> TimToady - I suspect you are right

[21:23] <Limbic_Region> my quoted statement above for anyone not reading context is an example of the thing it would be nice to say and does not necessarily reflect reality

[21:23] <Limbic_Region> </disclaimer>

[21:23] *** crem joined
[21:26] <wolverian> I don't really see the specification's completeness as a linear percentage.

[21:26] <Limbic_Region> well great work everyone - have a good weekend wherever you might be

[21:26] * Limbic_Region calls it a weekend

[21:27] <TimToady> the most accurate measure of that is probably the ratio of todos to todones, given there are tests for most of P6 already, even if coverage is a bit spotty.

[21:27] <wolverian> it seems like you'd want to graph it at least in two dimensions :)

[21:30] *** rodi joined
[21:41] *** BooK_ joined
[21:42] *** eggzeck[laptop] joined
[21:52] *** fglock joined
[21:53] *** cmarcelo joined
[22:03] <TimToady> Chinese doesn't have preincrement or postincrement, but it does have topincrement: Ëìé

[22:25] <svnbot6> r14605 | audreyt++ | * Pugs::Runtime::Perl6 - Disallow typed assignment into a Value type.

[22:25] <svnbot6> r14605 | audreyt++ | * Pugs::Runtime::Perl6 - Also allow easy-blessing syntax for classes:

[22:25] <svnbot6> r14605 | audreyt++ |     class Foo { has $.x; has $.y; }

[22:25] <svnbot6> r14605 | audreyt++ |     Foo(x => 1, y => 2); # makes an object.

[22:25] <svnbot6> r14605 | audreyt++ | * Pugs::Runtime::Perl6 - Add a native .perl method to all objects.

[22:30] <svnbot6> r14606 | audreyt++ | * MP6: fglock++ implemented the beginning of the ->perl5 emitter,

[22:30] <svnbot6> r14606 | audreyt++ |   wrote tests in MiniPerl6 and coverted sanity tests into MiniPerl6,

[22:30] <svnbot6> r14606 | audreyt++ |   and it all passed with flying colours.

[22:30] <svnbot6> r14606 | audreyt++ |   (fglock++ would like to point out audreyt++ helped a bit as well.)

[22:35] <ashleyb>   fglock: thanks for adding my test...

[22:38] <fglock> ashleyb: np - I'll try to fix it later

[22:39] <fglock> it's a backtracking problem, it seems

[22:44] *** Aankhen`` joined
[22:45] <ashleyb> fglock: one other question, when I switch the module from 'Regex' to 'Rule' my grammer stops working (code that that test was taken from) - and prints out some ugly error -- is this something you know about or should I send you another test?

[22:48] *** larsen_ joined
[22:49] <Juerd> TimToady: Ooh! topfix:<...> operators :)

[22:49] <lambdabot> Juerd: You have 1 new message. '/msg lambdabot @messages' to read it.

[22:49] <TimToady> topfix:<~>

[22:50] <Juerd>       ~

[22:50] <Juerd> Si, senor

[22:51] <TimToady> topfix:<¬®>

[22:54] <TimToady> hmm, circumfix should really be ambifix.  a true circumfix would be like ‚Éù        20DD            COMBINING ENCLOSING CIRCLE

[22:55] <fglock> ashleyb: try 'Token' instead - Rule adds significant-space, this may change the meaning

[22:56] <TimToady> on the other hand, if it relies on backtracking...

[22:59] *** diakopter joined
[23:04] <ashleyb> fglock: for example, take that test and s/Regex/Token/g or also s/Regex/Rule/g and you get the same thing.

[23:14] <fglock> ashleyb: backtracking into Token/Rule quantifiers is not implemented

[23:14] <ashleyb> ok cool.

[23:18] <TimToady> somebody forgot to add continuations to Perl 5.  :/

[23:19] * avar blames TT

[23:20] <TimToady> TrueType?  :)

[23:28] <avar> TimToady: nope:)

[23:32] *** Limbic_Region joined
[23:35] <diakopter> has svn been moved over yet?

[23:36] *** gnuvince joined
[23:39] *** cmarcelo joined
[23:41] <pasteling> "cmarcelo" at 200.150.229.66 pasted "new (final?) translation" (156 lines, 2.5K) at http://sial.org/pbot/20862

[23:43] <svnbot6> r14607 | audreyt++ | * Pugs::Runtime::Perl6: Add .yaml for all objects.

[23:43] <svnbot6> r14608 | audreyt++ | * Pugs::Grammar::Term - Allow @.foo but for now parse it as $.foo

[23:46] <svnbot6> r14609 | audreyt++ | * Pugs::Grammar::Expression - Parse for hyper methods: "@foo.>>bar", "@foo>>.bar"

[23:46] <svnbot6> r14609 | audreyt++ |   and "@foo.>>.bar", because MiniPerl6 emitters really want that ;)

[23:46] <svnbot6> r14610 | audreyt++ | * Pugs::Emitter::Perl6::Perl5 - Support for emitting hyper method calls

[23:46] <svnbot6> r14610 | audreyt++ |   and hash/array dereferences.

[23:49] <audreyt> diakopter: no, I'll send a mail to every committer when that happens

[23:49] <svnbot6> r14611 | audreyt++ | * MiniPerl6 Emitter: Add emission for these classes:

[23:49] <svnbot6> r14611 | audreyt++ |     Lit::Seq Val::Num Val::Buf Val::Undef

[23:49] <svnbot6> r14611 | audreyt++ |     Val::Object Lit::Seq Lit::Array Lit::Hash

[23:49] <svnbot6> r14611 | audreyt++ |     Index Lookup Call Apply Return If Index Lookup

[23:49] <audreyt> also working on hiveminder integration

[23:49] <audreyt> dinner bbiab

[23:59] *** mako132_ joined
