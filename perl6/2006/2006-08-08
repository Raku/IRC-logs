[00:03] *** rodi joined
[00:09] *** autark_ is now known as autark

[00:30] *** Pietro_KC joined
[00:30] *** nekokak joined
[00:31] *** Pietro_KC left
[00:32] *** lichtkind joined
[00:47] *** diakopter joined
[00:48] *** justatheory joined
[00:54] *** toku_away is now known as tokuhirom

[00:55] <audreyt> rehi

[00:55] <TreyHarris> audreyt: hi... do you know anything about the svn outage?

[00:55] <audreyt> openfoundry down but http://svn.perl.org/perl6/pugs/trunk/ seems to have the Pugs.Val branch intact

[00:55] <lambdabot> Title: Revision 10680: /pugs/trunk

[00:56] <audreyt> s/branch/work/

[00:56] <audreyt> TreyHarris: I know that it'll usually be back once someone shows up at work

[00:56] <audreyt> which is soon (8:56am here)

[00:56] <TreyHarris> ok, good :-)

[00:57] <audreyt> once sussman implements svn:* propedit in his repo

[00:57] <audreyt> I may seriously consider switch over to it

[00:57] <audreyt> as the invitation system can be migrated rather easily

[00:57] <audreyt> and he said "soon" so here's hope...

[00:58] <TreyHarris> audreyt: is coercion documented anywhere?  it's implied in several synopses, but other than being .as, i don't see it explicitly discussed

[00:58] <jmf> hey did you guys see the "google hosting" announcement?

[00:58] <TreyHarris> jmf: links are good :-)

[00:58] <audreyt> jmf: sussman's repo is the google repo.

[00:58] <audreyt> :)

[00:58] <jmf> http://code.google.com/hosting/

[00:58] <lambdabot> Title: Google Code - Project Hosting

[00:59] <jmf> oh ok

[00:59] <lichtkind> audreyt which licence for the doc? i would like dual license artistic/free wiki licence

[00:59] <audreyt> lichtkind: I don't quite care, but for text, I usually prefer CC-by

[00:59] <TimToady> jmf: did you ever get your commit bit?  (not that it works at the moment...)

[00:59] <jmf> nope ive been waiting for openfoundry to come back

[00:59] <lichtkind> by what ?

[00:59] <jmf> that sites been down since yesterday

[01:00] <audreyt> lichtkind: http://creativecommons.org/licenses/by/2.5/

[01:00] <lambdabot> Title: Creative Commons Deed

[01:01] <audreyt> jmf: yeah. the good part about openfoundry is when I'm in .tw, it's fast for me and the uptime during daytime is guaranteed

[01:01] <audreyt> the bad part about openfoundry is for people in different time zones

[01:01] <TimToady> heh, google is just across the street from me.  :)

[01:01] <audreyt> which is the majority, when it's down it takes an awful time to come back up..

[01:02] <jmf> google would probably be fast everywhere

[01:02] <jmf> :)

[01:02] <TimToady> plus we could start corrupting google from the inside. :)

[01:02] <audreyt> TimToady: yeah, and because sussman & co ported svn to google's BigTable filesystem, GET operations is mirrored and very fast everywhere

[01:02] <audreyt> however commits will probably take longer for me

[01:03] <audreyt> but that's a small price to pay, esp. considering that it will still be faster for everyone else :)

[01:03] <TimToady> just work offline with svk and then push it all every time you come to the U.S.  :)

[01:03] <lichtkind> audreyt yes its a lot saner decision than free wiki license which is far more complicated

[01:03] <audreyt> lol

[01:03] <obra> audreyt: does openfoundry not have 24x7 coverage these days?

[01:03] <clkao> is the repostory back?

[01:03] <clkao> obra: they don't know how to run a site

[01:03] <TimToady> not as of 5 minutes ago

[01:04] <audreyt> obra: it should have, but the hardware situation is weird

[01:04] <clkao> "no one gets paged if the site is down"

[01:04] <audreyt> which is why I'd like to switch to google repo as soon as they allow us to backport svn:author

[01:05] <TimToady> they probably define "down" as "can't ping".  And since pings still work...

[01:05] <clkao> audreyt: have you asked them about it?

[01:06] <jmf> how come the perl foundation doesnt get listed here? http://code.google.com/organizations.html

[01:06] <audreyt> ssh is down too

[01:06] <lambdabot> Title: Google Code - Open Source Organizations and Affiliations

[01:06] <audreyt> clkao: yes, sussman has a hiveminder ticket that he accepted.

[01:06] <audreyt> clkao: it all ties together :)

[01:07] <TimToady> Google CPAN.

[01:07] <TimToady> Just hide it all in svn.

[01:08] <diakopter> CPANG

[01:09] <audreyt> indeed, an autoimport of CPAN to google svn

[01:09] <audreyt> with PAUSE comaints automagically get commit bits

[01:09] <audreyt> to their registered modules

[01:09] <audreyt> is something I'd like to work on too

[01:10] <TimToady> then a CP

[01:10] <TimToady> a CPAN install bar in firefox...

[01:12] <TimToady> then make perl6: a prefix like http: and off we go...

[01:13] <audreyt> use http://perl.org/;

[01:13] <jmf> well it could just be perl:

[01:13] <lambdabot> Title: The Perl Directory - perl.org

[01:13] * obra talked to icann about URI schemes last week, actually

[01:13] <obra> The terrifying thing is that the way registration works is "if the IETF doesn't object formally within two weeks, it's oked"

[01:14] <TimToady> when do they go on vacation?

[01:14] <audreyt> wow. does it work that way too for  MIME types?

[01:15] <dduncan> I almost finished writing some questions to p6l, but then realized that the answers may be somewhere in the Synopsis that I couldn't find, so I'll ask here first ...

[01:16] <dduncan> if you say @foo = (1,2), then what is the type of @foo?

[01:16] <dduncan> is it an Array or Seq?

[01:16] <dduncan> if you say $foo instead, then the type of the value would carry on into $foo, but I'm wondering if the @ forces a coersion

[01:16] <audreyt> @foo is bound to Array

[01:16] <lambdabot> Maybe you meant: faq todo yow

[01:17] <audreyt> Array's assignment method takes a slurpy *@

[01:17] <TimToady> array assignment implies a copy of the values.

[01:17] <audreyt> so Seq is evaluated in slurpy (aka list) context

[01:17] <dduncan> okay, so then the anonymous Seq was just copied into an Array

[01:17] *** tokuhirom left
[01:17] <audreyt> correct.

[01:17] <TimToady> yes.  Now := would be another story.

[01:18] <dduncan> I asked this partly because I was looking at some tests yesterday, such as data_types/array.t and saw a lot of p5isms there

[01:18] *** miyagawa joined
[01:18] <audreyt> := will change @foo's underlying object from Array to Seq

[01:18] <dduncan> ah, nice to know

[01:18] <dduncan> I was trying to get an idea how many of the @foo = (1,2) were faulty, but it seems now that maybe none are

[01:18] <TimToady> well, = is supposed to emulate p5 pretty closely.

[01:19] <TimToady> that was the main point of keeping it and also having :=

[01:19] <dduncan> okay, so if I say @foo := (1,2), then I can keep the @ but have a Seq instead

[01:20] <dduncan> next question ...

[01:20] <TimToady> and push will fail.

[01:20] <dduncan> yes

[01:20] <audreyt> yes. and then @foo.push(1) will fail with no-such-method

[01:20] <TimToady> great minds...

[01:20] <audreyt> :D

[01:20] <dduncan> on that note, I assume that Array.does(Seq) is true, but that Seq.does(Array) is false?

[01:20] <audreyt> that would be correct, I think

[01:21] <dduncan> next question ...

[01:21] <TimToady> the binding would fail otherwise, presuming that @foo remembers it's an Array.

[01:21] <dduncan> the syntax for declaring a Mapping ...

[01:21] <audreyt> Mapping(x => 1, y => 2)

[01:21] <dduncan> would it be reasonable to say $foo = (1=>2,3=>4); and that be unambiguous as a Mapping rather than a Seq?

[01:21] <audreyt> is currently the less controvertial option

[01:21] <audreyt> (unspecced)

[01:22] <dduncan> its the same as a Hash, but parens instead

[01:22] <audreyt> probably not -- you can legitimatlly have {}

[01:22] <audreyt> but having () be a mapping is bad

[01:22] <dduncan> btw, did you mean to say mapping(...)? lowercase

[01:22] <audreyt> (1=>2, 3, 4) too

[01:22] *** hikozaemon joined
[01:23] <audreyt> no... it's Mapping()

[01:23] <audreyt> class name used as function denotes class-specific constructor/coercer of some kind

[01:23] <audreyt> Mapping.new() may work too

[01:23] <audreyt> but the point is there's no surface syntax (yet)

[01:24] <audreyt> one possibility is {x=>1,y=>2}:mapping

[01:24] <dduncan> I'll have to check the synopsis again, but there seem to be some dis-similarities in style between that and some built-in shorthands

[01:24] <audreyt> but not sure if it's common enough to warrant that

[01:24] <dduncan> eg, I think it gives hash() as a shorthand for a Hash

[01:25] <dduncan> er, long-hand

[01:25] <audreyt> I wonder if Hash() works better there and is more consistent...

[01:25] <dduncan> if that is true, I'm inclined to think it should be cased Hash() instead for consistency

[01:25] <TimToady> that's kind of a leftover from when it was "hash" v "sub"

[01:25] <audreyt> there's no array() either

[01:26] <dduncan> but then, the lowercase for builtins seemed to be more consistent with 'sub' or 'class' etc

[01:26] <audreyt> and scalar() doesn't give you a Scalar.

[01:26] <clkao> last time someone mentioned if it's a single(?) pair in {} then it's a hash?

[01:26] <audreyt> so it's quite inconsistent currently

[01:26] <dduncan> and yes, if we have a hash(), we should have an array() too for consistency

[01:26] <TimToady> well, we can't even decide if it's scalar() or item()...

[01:26] <dduncan> and a Seq() etc

[01:26] <audreyt> clkao:

[01:26] <audreyt> If the closure

[01:26] <audreyt> appears to delimit nothing but a comma-separated list starting with

[01:26] <audreyt> a pair (counting a single pair as a list of one element), the closure

[01:26] <audreyt> will be immediately executed as a hash composer.

[01:27] <audreyt> TimToady: with the want-as-&return.signature view, the context will agree with the signature terminology...

[01:27] <dduncan> the point is, it would be nice to have more consistency than I saw

[01:27] <clkao> is this somewhere in perl6::spec ?

[01:27] <dduncan> looking ...

[01:27] <audreyt> i.e. if &return.signature is (*@) then it's slurpy array context; if it's (@) it's nonslurpy array context

[01:27] <audreyt> if it's (@, *@), then we don't have an easy name for it

[01:28] <audreyt> but even that could happen

[01:28] <audreyt> (@_, *@x) := f();

[01:29] <dduncan> ah, looking back at S02 now, I see title-case names for Scalar(), Array(), Hash() having some purpose

[01:29] <TimToady> hmm, int() vs Int() might be useful.

[01:30] <dduncan> refering to Captures though

[01:30] <dduncan> indeed ... then the case matches the actual class name

[01:31] <audreyt> clkao: line 748 in S04 "Statements"

[01:31] <dduncan> here we go ... S04 has a hash() but S02 a Hash() ... something's inconsistent here

[01:31] <TimToady> hash is the native type.  :)

[01:31] <audreyt> we have a machine-native hash now?

[01:31] <audreyt> which chip is that? :)

[01:32] <clkao> cool. i can refer there when i care next time

[01:32] <TimToady> the Judy chip

[01:32] <audreyt> lol

[01:32] <dduncan> that's only the Haskell implementation ... not portable

[01:32] <TimToady> they're not calling it the Haskell chip because that would scare people.

[01:33] <dduncan> S06 also uses lowercase hash() as well as pair()

[01:33] <TimToady> I have no problem with making those uppercase if we decide Foo() can do that consistently.

[01:34] <dduncan> it mentions pair() being a list operator though, so may be different than a constructor

[01:34] <audreyt> well, that's not a problem really

[01:34] <dduncan> for consistency, if constructors match the class name, and non-constructors are spelled differently, it would clear some things up

[01:34] <audreyt> hash() is also listop

[01:35] <audreyt> the constructor just need to handle the (*@) cast

[01:35] <audreyt> case

[01:35] <audreyt> and/or the (*%) case

[01:35] <TimToady> or it's just a capture...

[01:35] *** diakopter left
[01:36] <dduncan> I assume we're also treating a non-Junction Set like Mapping, so you declare it with Set() rather than some non-alpha syntax?

[01:36] <audreyt> that seems prudent :)

[01:37] <dduncan> okay, so if those are the plans, it will give me something more concrete to be consistent with in my own modules

[01:37] *** diakopter joined
[01:38] <audreyt> TimToady: hm, somehow S04 now doesn't have the

[01:38] <audreyt> empty {} is a Hash

[01:39] <audreyt> wording anymore

[01:39] <dduncan> isn't that {,} now?

[01:39] <audreyt> also, {%x,...} should also be a Hash, right?

[01:39] <audreyt> oh, then maybe pugs needs changing :)

[01:39] <audreyt> but why? {,} is far more useful than {;}...

[01:39] <TimToady> I don't think anything's changed recently on that topic.

[01:40] <audreyt> k. so {}, {%x} are still hash composers

[01:40] <dduncan> okay, I wasn't thinking ... that was meant to be an extrapolation of {... ,} disambiguating as a hash

[01:41] <dduncan> but whatever

[01:42] *** christopher joined
[01:42] <diakopter> yap6n00b here

[01:42] <TimToady> would you like a commit bit?

[01:42] <diakopter> sure, if I can ever register with openfoundry

[01:43] <dduncan> which is down afaik

[01:43] <TreyHarris> sorry to keep asking this... but is coercion discussed anywhere?

[01:43] <diakopter> or did you mean for parrot ;)

[01:43] <TimToady> I don't know how to hand out commit bits for parrot...

[01:43] <dduncan> maybe ask on #parrot ?

[01:43] <audreyt> TreyHarris: S02

[01:45] <audreyt> TreyHarris: there are two kinds: implicit coercion takes place when the target is a builtin value type

[01:45] <audreyt> the table is partially given out on S02

[01:45] <audreyt> explicit coercion takes place with the .as() method

[01:45] <audreyt> which the infix:<as> operator falls back to

[01:45] <audreyt> or maybe the other way around, that havn't been decided yet

[01:46] <TimToady> does an as declaration also create the corresponding constructor?

[01:46] <diakopter> to get up to speed, do I need to read the entire log history of this channel?

[01:46] <TreyHarris> audreyt: ok.  does it use MMD?

[01:46] <TimToady> presumably MMDable, so other explicit

[01:46] <TimToady> constructors don't interfere

[01:46] <TreyHarris> diakopter: yes.  we'll see you back here in October. ;-)

[01:47] <audreyt> TimToady: conceivably the Foo($x) form falls back to $x.as(Foo) if Foo doesn't handle it

[01:47] <TreyHarris> diakopter: no, just listen and read the synopses and you'll get up to speed

[01:47] <audreyt> hm

[01:47] <audreyt> actually.

[01:47] <audreyt> Foo($x) is parsed as $x.Foo

[01:47] <audreyt> so maybe that's how .as is declared ;)

[01:47] <TimToady> I thought we separated that out again.

[01:47] <audreyt> (never mind that)

[01:48] <TimToady> so that MMD would work right.

[01:48] <audreyt> iirc it's partially separated

[01:48] <audreyt> only for the f(g()) form

[01:48] <TreyHarris> hmm... but are MMD right?  it's kind of upside-down, isn't it?  what one would like is if you say $foo.as(Bar), and there's no good candidate to turn a Foo directly into Bar, but there is one for turning Foo into SubclassOfBar, you want to call that one, because that'll do just fine... right?

[01:49] <audreyt> if g() still returns a single something, that something is still used as invocant...

[01:49] <TreyHarris> er, s:w/are MMD/are MMD semantics/

[01:49] <dduncan> another question: since undef containers are meant to be prototype objects, is it generally reasonable to just start using a new undefined container as if it were an actual object whose current value equaled the prototype?

[01:49] <dduncan> I have generally been treating them like that now

[01:49] <audreyt> and disamig is f(g(),). if it's changed, I don't remember seeing that in spec

[01:49] <dduncan> seems to work fine ...

[01:50] <dduncan> and so Perl 6 is then effectively doing what I wanted, where all containers implicitly have a value of the requisite type all the time even if not explicitly given one

[01:50] <audreyt> TreyHarris: that is correct. contravariant MMD at this point is not well defined :)

[01:50] <audreyt> TreyHarris: so a better proposal is welcome

[01:51] <audreyt> dduncan: code please

[01:51] <TimToady> need to decommute to work &

[01:51] <audreyt> my Dog $x; $x.bark

[01:51] <audreyt> you mean this?

[01:51] <dduncan> for example, yes

[01:52] <audreyt> "my Dog $x" is sugar for "my $x is Scalar of Dog; $x = ::Dog"

[01:52] <dduncan> but also, I can say: my Array $ary; $ary.[3] = 3;

[01:52] <dduncan> or remove the .

[01:52] <TreyHarris> audreyt: like i said last night, my red tape is about to be cut and i'll be able to actually use my commit bit, so I'll write some tests expressing how I think it should work for some common cases.  if that helps.  if what you're looking for is more theoretical....

[01:52] <audreyt> that only works because of vivification

[01:52] <dduncan> but either way, I assume that after the element assignment, $ary is no longer undefined

[01:53] <audreyt> TreyHarris: test-driven is fine, sprinkled with comments :)

[01:53] <dduncan> and contains an actual object rather than a prototype

[01:53] <audreyt> correct. but again that's because Array does vivification

[01:53] <audreyt> i.e. when you use a undefined Array in rw position

[01:53] <audreyt> it mallocs an instance

[01:53] <dduncan> then with strings ... eg: my Str $foo; $foo .= 'bar';

[01:54] <audreyt> ~= you mean

[01:54] <dduncan> yes, I meant that

[01:54] <audreyt> ::Str stringifies to ''

[01:54] <audreyt> so that falls out automatically

[01:54] <audreyt> (currently not the case with pugs)

[01:54] <dduncan> either way, I like what seems to be happening here ... its like all types can/do now autovivify

[01:54] <audreyt> (but will be)

[01:55] <audreyt> er, not so quick

[01:55] <dduncan> and so if I want to ignore the .defined status of a variable, I can safely do so ... any use of it will act like that type's "default" value

[01:55] <audreyt> my Point $p; say $p.x

[01:55] <audreyt> that will die

[01:55] <audreyt> not vivify

[01:55] <dduncan> but all built-in types will vivify?

[01:55] <audreyt> under "class Point is rw { has $.x; has $.y }"

[01:55] <audreyt> no. Code also does not vivify

[01:55] <dduncan> and I can declare that my own class will too?

[01:56] <audreyt> my Code $x; $x.signature # dies

[01:56] <dduncan> okay, but anything that is like a number or string or list will autovivify?

[01:56] <dduncan> or boolean

[01:56] <dduncan> they all have conceptual "empty" values

[01:56] <audreyt> value types all have sane defaults

[01:56] <audreyt> Array and Hash and Scalar vivify following p5

[01:57] <audreyt> all other types there's no guarantee

[01:57] <audreyt> in particular, I don't expect Buf, IO, Routine, Regex etc to vivify.

[01:58] <dduncan> I would expect Buf to autovivify to a zero-length unit like Str does

[01:58] <audreyt> my IO $fh; $fh.say(hi)

[01:58] <audreyt> but Str is immutable

[01:58] <audreyt> if you think Buf should vivify as per Array

[01:58] <audreyt> that's a valid view

[01:58] <dduncan> yes

[01:58] *** dolmans joined
[01:58] <audreyt> but that also means it better be resizable

[01:58] <audreyt> which I guess it should

[01:58] <dduncan> I thought it was?

[01:58] <audreyt> so ok. why not :)

[01:58] <audreyt> yeah.

[01:59] <dduncan> buf is fixed size, but Buf isn't afaik

[01:59] <audreyt> yup

[02:00] <audreyt> as Pugs.Val.* is getting filled

[02:00] <dduncan> so on that note, since I am creating an immutable type, I would like to know what to say in the class so it knows what its prototype is

[02:00] <audreyt> you'll have access to those toys soon :)

[02:00] <audreyt> the prototype is just the class name

[02:00] <audreyt> if your methods do not use the structure fields

[02:01] <audreyt> then those methods will continue to work on the prototype

[02:01] <audreyt> as for autovivification, I don't think there's currently a syntax for that

[02:01] <audreyt> will be great to have one though

[02:01] <dduncan> fyi, the prototype for my classes are meant to be like those for Set ... an empty set

[02:01] <audreyt> my Point $p; say $p.x; # 0

[02:01] <dduncan> which is a reasonable default

[02:01] <audreyt> is the use case

[02:02] <audreyt> one way to think about it is

[02:02] *** tup joined
[02:02] <dduncan> I have to go to dinner ... will backlog

[02:02] <dduncan> thank yu

[02:02] <dduncan> s/s/o/

[02:03] <dduncan> forget that

[02:03] <dduncan> just thank you

[02:03] <audreyt> class Point { has $.x=0; has $.y=0; multi Point () { Point.new } }

[02:03] <audreyt> not sure

[02:03] <audreyt> no prob :) thank you for doing something with this language...

[02:03] <audreyt> I need to run for lunch too

[02:03] <audreyt> bbia

[02:04] *** neoesque joined
[02:10] *** xinming joined
[02:21] <audreyt> TimToady: perhaps "close f()" try sub dispatch first, then fallback to method

[02:21] <audreyt> and f().close is the other way around

[02:22] <audreyt> that will make "return f()" not be a special form

[02:43] <dduncan> back

[02:44] <dduncan> will try that Point example

[02:54] *** lollan joined
[02:55] <dduncan> ?eval class Bar { has $!baz = 3; }

[02:55] *** evalbot_11967 is now known as evalbot_11982

[02:55] <evalbot_11982> Can't exec "./pugs": No such file or directory at examples/network/evalbot//evalhelper-p5.pl line 46.

[02:56] <dduncan> anyway, my Pugs gives an error with that: unexpected "=" expecting comment, trait, "handles", ";" or "}"

[02:56] <dduncan> I thought defaults assignment used to work, but if so, its broken now

[02:59] <svnbot6> r11983 | clkao++ | Merge Pugs-Compiler-{Rule,Perl6} from pX/Common/ to perl5/.

[03:04] <dduncan> yay ... repo's back

[03:11] <svnbot6> r11984 | Darren_Duncan++ | ext/Set-Relation/ : minor updates to newest Relation.pm code

[03:18] *** amnesiac joined
[03:22] <cmarcelo> audreyt: ping?

[03:34] <TimToady> audreyt: yes, we already decided to do it that way once.  but we can decide it again if you like.  :)

[03:40] *** [particle] left
[03:45] *** nirgle joined
[03:48] <cmarcelo> why in t/operators/assign.t line 347 (it's the dwimming section), @a == 'S' and not @a == ('S') ?

[03:49] <nirgle> t as in Turing O_o

[03:53] <cmarcelo> t as in perl =)... i'm talking about the tests on pugs repo.

[03:54] <jmf>  i dont see what you're talking about

[03:54] <jmf> line 347:     is(@a, 'S',    'lhs dwims @a[0] as scalar');

[03:55] <cmarcelo> yes. and @a is defined by @a[0] = W, I don't get why @a isn't an array, or it is and i'm missing something?

[03:57] <jmf> does that test pass for you?

[03:58] <cmarcelo> yes it pass. but i'm trying to understand why it should pass. (i'm experimenting changing IArray implementation and it doesn't pass in my alternative impl.)

[03:59] *** xdg joined
[04:07] <jmf> ah

[04:07] <jmf> it is being called in scalar context

[04:07] <jmf> if you did () i think it would then return 'L'

[04:10] <cmarcelo> jmf: if I did () where? scalar context shouldn't get me 1 instead of 'S' (first and only element in this case)?

[04:12] <jmf> why 1?

[04:15] <cmarcelo> jmf: (sorry, maybe i'm confusing things with perl 5)... +@a (forced scalar context in perl5) returns number of elements. but I just discovered ~@a, which gets me "S", which equals 'S'..

[04:16] <jmf> this is the assignment to @a correct?     my @z = (@a[0] = W, W);

[04:16] <cmarcelo> yes.

[04:16] <jmf> in that context W is being called to return a scalar

[04:16] <jmf> since its just a 1 element slice

[04:16] <jmf> so it should return 'S'

[04:17] <jmf> even though @a is a list

[04:18] <jmf> here is the definition of W: my sub W () { substr(want, 0, 1) }

[04:18] <jmf> and want is explained here: http://dev.perl.org/perl6/rfc/21.pod

[04:19] <gaal> mornin'

[04:20] <cmarcelo> jmf: I get why W returns 'S'.. the problem is, after @a[0] = W, i expected @a = ('S'), ie. one-element array containing 'S'. what i didn't knew is that is(@a, 'S') is evaluating @a in some "string"-scalar context into 'S', so the test passes. is that right?

[04:21] <jmf> yes @a[0] is evaluated as a scalar

[04:21] <PerlJam> cmarcelo: is() uses the boolean ops doesn't it?  They provide the scalar context.

[04:23] <jmf> PerlJam: only because its 1 element though, if it were @a[0,] or such it would still be a list

[04:24] <jmf> actually i dont know about that - but it has already been evaluated before the is()

[04:24] <cmarcelo> tks, i think i got the test.. but in is(+@a, 1), the "+" is forcing what context into @a evaluation?

[04:25] <PerlJam> cmarcelo: numeric scalar

[04:25] <PerlJam> (thus yielding the number of elements in @a)

[04:26] <cmarcelo> so @a in scalar context means by default ~@a ("string"-scalar context)?

[04:26] <PerlJam> no

[04:27] <PerlJam> (except perhaps in a buggy pugs :)

[04:29] <gaal> in Perl 6? @a in scalar context is @a as an object.

[04:32] *** xinming joined
[04:33] <cmarcelo> gaal: @a "as an object" for "my @a = ('S');" is just 'S'?

[04:33] <jmf> cmarcelo: its what PerlJam said about eq

[04:33] <gaal> that's not @a in scalar context :)

[04:34] <jmf> is() is using eq not ==

[04:37] <cmarcelo> sorry.. now i see.. (the presence of both eq and == is new to me =o) ). @a in scalar means ~@a in that case because "eq" forced string "evaluation", then?

[04:38] <jmf> right

[04:38] <cmarcelo> gaal: what's "@a as an object"?

[04:38] <jmf> apparently

[04:41] <gaal> cmarcelo: well, if we still had references, $sc = @ar would cause $sc to have the reference to @ar

[04:42] <gaal> as opposed to @ar2 = @ar1 where you get a shallow copy

[04:43] <gaal> $sc[42] would modify @ar, where @ar2[42] would not modify @ar1[42]

[04:45] <cmarcelo> gaal: I see, by default @a in scalar is a "kind of reference" to the array, but "operators" like == or eq can force specific contexts like numeric and string..

[04:47] *** nirgle left
[04:47] <gaal> cmarcelo: and you can force subcontext yourself with ? + ~...

[04:47] <gaal> ?eval 42

[04:47] *** evalbot_11982 is now known as evalbot_11984

[04:47] <evalbot_11984> Can't exec "./pugs": No such file or directory at examples/network/evalbot//evalhelper-p5.pl line 46.

[04:47] <gaal> ?eval ?42

[04:47] <evalbot_11984> Can't exec "./pugs": No such file or directory at examples/network/evalbot//evalhelper-p5.pl line 46.

[04:47] <gaal> ?eval ~42

[04:47] <evalbot_11984> Can't exec "./pugs": No such file or directory at examples/network/evalbot//evalhelper-p5.pl line 46.

[04:47] <gaal> beh.

[04:48] <cmarcelo> gaal: i get it =)

[04:48] <gaal> that would result in   42, True, "42"

[04:48] <jmf> gaal: are you able to compile the latest revision?

[04:48] <gaal> it's still running here

[04:49] <jmf> oh ok

[04:55] <gaal> why is the section on Built-in Types in S06, "Subroutines", and not somewhere more data oriented?

[04:57] <gaal> jmf: build fixed, committing.

[04:58] <svnbot6> r11985 | gaal++ | * unbreak the build

[04:58] <svnbot6> r11986 | gaal++ | * add svn:ignore prop

[05:00] <gaal> is google hosting going to require a google account for ci?

[05:01] <obra> yes

[05:01] <jmf> nice,

[05:02] <jmf> thats what audrey is waiting for i think

[05:02] <jmf> to see if theres a workaround

[05:02] <gaal> ah, thanks

[05:04] <jmf> awesome it worked

[05:06] <gaal> cool

[05:08] *** kanru joined
[05:11] <gaal> isn't Yuval's "weak roles" proposal talking about something that should already exist in roles? ie consumed method disambiguation

[05:11] <gaal> I consume two unrelated roles that define a method with the same name

[05:12] <gaal> when I view an object as doing one role, I'd like to get that method; when I view it as the other I'd like the other

[05:13] <gaal> assuming these are compile-time composed, it could be (I had thought it was?) that these methods are not conflated

[05:15] <jmf> sorry, where is this from?

[05:15] <gaal> jmf: p6-l

[05:22] <TreyHarris> gaal: I think you're referring to "Conjectural: If the original invocant is in a variable that is constrained to be of one role or another, then that type could be used to dispatch to the correct role's method in cases where they can't be distinguished by differences in the actual argument types"?

[05:23] <gaal> TreyHarris: I got that from the verbal tradition, not scripture, but yes.

[05:24] <gaal> the problem nothingmuch is discussing seems to be how to declare definitions of abstract methods in the consumer

[05:25] <TreyHarris> right.  i think it also touches on this sentence in S06: "If the roles forget to declare them as multi, you can force a multi on the roles' methods by installing a multi stub in the class being constructed"

[05:27] <TreyHarris> it seems to me that yuval's proposal is doing much the same thing, but from the perspective of the role rather than the class

[05:28] <TreyHarris> but from observing nothingmuch, i get the sense that he often prefers declaration in code to disambiguation at runtime

[05:28] <TreyHarris> i'm but a bear of little brain in such matters, which i'll leave to TimToady and @Larry

[05:28] <gaal> er, I think the proposal is about the consuming class.

[05:29] <TreyHarris> oops, you're right.  i read what i thought i was reading in Yuval's message rather than what i actually read.  hrm.

[05:29] <TreyHarris> yeah, i don't see any difference then

[05:32] <TreyHarris> nothingmuch's syntax seems more explicit.  i think the multi stub mechanism will need to be commented every time it's used, it seems semi-magical (even though it's not)

[05:33] <gaal> does anyone know how, in vim, to limit filename completion? I'm sick of hitting :e src/Pugs/In<TAB> and getting the .hi file because it's lexically prior to .hs

[05:34] *** [particle] joined
[05:34] <gaal> cf. "Why C is Superior to Haskell: 'c' lt 'o'"

[05:35] <cmarcelo> gaal: look for suffixes option

[05:35] <gaal> cmarcelo: excellent, thanks!

[05:47] <gaal> maybe you also know, why is mapping things to function keys flaky? sometimes it works but sometimes it just resolves to ~~~.

[05:48] <gaal> eg. I just want :map <F3> :cn<CR>

[05:49] <TreyHarris> gaal: sometimes meaning successive keypresses may act differently?  or sometimes in the sense of different vim sessions or different logins?

[05:49] <gaal> I think it's a terminal thing...

[05:50] <cmarcelo> here in gnome-terminal that seems to work (mapping F3), what term are you using? via ssh or something?

[05:50] <gaal> ah, yes, it's definitely my terminal messing with me. I use putty+ssh.

[05:51] <TreyHarris> getting f-keys from keyboard to app under unix involves a frighteningly large number of layers of indirection

[05:52] <gaal> aha! think I solved it. settings, terminal/keyboard, function keys, vt100+.

[05:53] <cmarcelo> gaal: just to know, what was setted before you change to vt100+?

[05:53] <TreyHarris> ansi, i'll bet, if you were getting tildes

[05:53] <gaal> ESC[n~  -- which precisely explains why f3 was ~~~ and f2 was ~~ :)

[05:57] <gaal> and while I'm pulling a magnet over my vim nits, does anyone know why sometimes, when I view a source file, move to a buffer that has no syntax mode, then move back, my source is not hilighted and I have to syn on again?

[05:58] <cmarcelo> gaal: do you use minibufexpl ? sometimes it happens to me too, and i read somewhere (maybe in the mbe source) that's a minibufexpl problem.. =P

[05:58] *** weinig joined
[05:59] <cmarcelo> (thinking better doesn't look like it's your case...)

[06:01] <pasteling> "cmarcelo" at 200.232.237.151 pasted "Implement IArray and IHash using HsJudy, try #2. Tested against r11916." (539 lines, 22K) at http://sial.org/pbot/18841

[06:01] <gaal> cmarcelo: no it is my case :)

[06:02] <gaal> maybe I should try the new tabbed mode I heard vim7 has? or is that just for gvim? (I never use gvim)

[06:04] <cmarcelo> audreyt: the late corrected version for last patch. "./pugs -e 'my @a; @a[999999999] = 2; say @a[999999999];'" works here and didn't work with trunk... i'm running smoke on it but t/op/*.t and t/builtins/* t/data_types/*  are coherent with trunk.

[06:07] <cmarcelo> audreyt: and as I said before, both "pop @a" and [email@hidden.address] are calling something before getting into my implementations of array_fetchSize and array_pop, and this "something" is blocking the execution (for @a defined as my last msg)..

[06:09] <wolverian> gaal, ot'

[06:09] <wolverian> gaal, it's for all vim flavours

[06:13] *** weinig_ joined
[06:14] *** weinig_ is now known as weinig|sleep

[06:19] <gaal> yay, I'll give it a look

[06:19] <gaal> btw all vim users, http://vim.sourceforge.net/scripts/script.php?script_id=294 is a nice plugin for aligning stuff.

[06:19] <lambdabot> Title: Align - Provides commands and maps to help produce aligned text, eqns, declarati ...

[06:29] <svnbot6> r11987 | agentz++ | [TASKS]

[06:29] <svnbot6> r11987 | agentz++ | updated the description of the new TODO mechanism by merging good ideas from TimToady++, gaal++, and many others.

[06:30] *** marmic joined
[06:30] <svnbot6> r11988 | agentz++ | TASKS - clarified the version number fed into &todo is optional.

[06:32] *** weinig|sleep is now known as weinig

[06:41] *** weinig is now known as weinig|sleep

[06:47] *** hexmode joined
[07:04] *** buetow joined
[07:09] *** drrho joined
[07:26] *** integral_ joined
[07:27] *** integral_ is now known as integral

[08:04] <gaal> audreyt: okay, I'm sufficiently awake and will now start writing up about Val

[08:11] *** penk joined
[08:18] *** elmex joined
[08:22] *** crem joined
[08:24] <audreyt> woot!

[08:26] <buetow> w00t! :)

[08:31] <jmf> does there exist a written grammar for valid syntax anywhere yet?

[08:33] <audreyt> there is perl5/Pugs-Compiler-Perl6/lib/Pugs/Grammar/Perl6.pm

[08:34] <audreyt> there is also a similar one in parrot tree

[08:37] <gaal> audreyt: instance ((:>:) Id) NativeBuf where cast = MkId . NBuf

[08:37] <gaal> beautiful, but can't we get all of native all in one there?

[08:39] <gaal> instance ValNative a => ((:>:) Id) a where cast = MkId . {- hw -}

[08:39] <audreyt> not seeing an easy way

[08:39] <audreyt> hm

[08:39] <audreyt> yeah, if you introduce a Native class

[08:40] <gaal> why not?

[08:40] <audreyt> no reason not to. :)

[08:40] <audreyt> go ahead :)

[08:40] <gaal> yay

[08:42] * audreyt goes installing xcode 2.4

[08:47] <audreyt> ...heh, the download link is broken.

[08:47] <audreyt> oh well, back to PureStr

[08:49] <audreyt> the idea is to do piggyback on the same places where PerlSV is handled specially

[08:49] <svnbot6> r11989 | audreyt++ | * Eval.hs: fix trivial typo

[08:50] <audreyt> so we can override method dispatch to the new MOP

[08:51] <nothingmuch> gaal: i'm not aware of the semantics of role disambiguation

[08:51] <nothingmuch> the idea of this thing wwas that when it's too hard to disambiguate two roles that you want to 'do'

[08:51] <nothingmuch> then you declare them as weak

[08:51] <gaal> nothingmuch: you guys are nuts, that's about the first thing I asked about when I was introduced to roles

[08:51] <nothingmuch> and you can only do one of them at a time

[08:52] <nothingmuch> yes

[08:52] <nothingmuch> i been wanting disambiguation forever too =)

[08:52] <nothingmuch> the point is, when a conflict can't be statically resolved

[08:52] <nothingmuch> because it's too difficult

[08:52] <nothingmuch> you off load it to your consumer to say which role it wants for a given scope

[08:53] <nothingmuch> making the behavior of the entire class context sensitive (but the context is explicit, not implicit)

[08:57] <nothingmuch> gaal: does that make more sense?

[08:59] <gaal> nothingmuch: sorry, not enough cycles at the moment.

[08:59] <nothingmuch> the core idea is "sometimes you just can't disambiguate two roles"

[08:59] <nothingmuch> but you may still want them

[09:02] <nothingmuch> me wonders if mark "gets" that abstract base classes are just like roles except less useful

[09:07] *** crem_ joined
[09:08] <audreyt> hm. what we really want is a way to mark contravariant mmd

[09:08] <nothingmuch> contravariant on whose side?

[09:08] <nothingmuch> invoker or invokee?

[09:08] <audreyt> $x.as(Moose)

[09:08] <audreyt> now if you have defined both

[09:08] <audreyt> as(SpecialMoose)

[09:08] <audreyt> as(Animal)

[09:08] <audreyt> you actually want the SpecialMoose to win

[09:09] <audreyt> at this moment Animal wins

[09:09] <audreyt> which is totally bogus.

[09:09] <nothingmuch> fix mmd again? ;-)

[09:09] <audreyt> just need an annotation

[09:10] <audreyt> that says "reverse the narrowing rule for htis position"

[09:12] <nothingmuch> within the class body?

[09:12] <audreyt> in the proto

[09:12] <nothingmuch> aye

[09:12] <nothingmuch> does the invocant get any say?

[09:12] <nothingmuch> if the invocant actually prefers Animal?

[09:12] <audreyt> proto method as (::t --> t) {}

[09:13] <audreyt> er, no way... you wouldn't say .as(Moose) and get back an elephant

[09:13] <audreyt> if elephant doesn't do moose

[09:14] <nothingmuch> wait wait wait

[09:14] <audreyt> haskell has builtin

[09:14] * nothingmuch pressed audreyt's rewind button

[09:14] <audreyt> asTypeOf :: a -> a -> a

[09:14] <audreyt> oh ok.

[09:15] <nothingmuch> a bit more examples this time =)

[09:15] <audreyt> Point is Shape; 3DPoint is Point

[09:15] <audreyt> er I mean Poind3d

[09:15] <audreyt> Point3d

[09:15] <audreyt> you have an object $o

[09:15] <audreyt> you want to get back Point

[09:15] <audreyt> say $o.as(Point).x

[09:15] <nothingmuch> aye

[09:16] <audreyt> $o is actually of class Moose

[09:16] <audreyt> Moose has

[09:16] <audreyt> multi method as (Shape)

[09:16] <audreyt> multi method as (Point3d)

[09:16] <audreyt> if we list "as" using the normal MMD rule

[09:16] <audreyt> proto as ($) {}

[09:16] <audreyt> then Point comes in and Shape is selected

[09:17] <audreyt> but we want Point3d

[09:17] <audreyt> not Shape, to win

[09:17] <nothingmuch> isn't .as(Point) going to fail if it returns a Shape?

[09:17] <nothingmuch> i mean

[09:17] <nothingmuch> the rules here are reversed

[09:17] <nothingmuch> Point is not a parameter to .as in the natural sense

[09:17] <audreyt> it is going to fail only if we consider the return type

[09:17] <audreyt> right

[09:17] <nothingmuch> that's what I meant

[09:18] <nothingmuch> isn't it more like $x.(as :: Point).x

[09:18] <nothingmuch> mmd on the return value?

[09:18] <audreyt> that's what I said.

[09:18] <nothingmuch> so why is Point a param to .as?

[09:18] <audreyt> because we currently has no capacity of annotating as return type

[09:18] <audreyt> also there's no capacity of return type mmd.

[09:19] <nothingmuch> wasn't return type mmd considered good up until a while ago?

[09:19] <audreyt> it is good, but it's undecidable

[09:19] * nothingmuch wonders why he missed it becoming evil again =P

[09:19] <nothingmuch> isn't it just contravariant mmd on the caller continuation's type annotation?

[09:20] <audreyt> yes, but the caller itself may be waiting for you

[09:20] <audreyt> to decide which variant to mick

[09:20] <nothingmuch> "accept as a parameter a function whose first parameter is...."

[09:20] <audreyt> multif(multig())

[09:20] <nothingmuch> in this case the context is the proto of f

[09:20] <audreyt> which is most of the time not going to help

[09:20] <nothingmuch> right

[09:20] <nothingmuch> but that's not for this case

[09:20] <nothingmuch> it's for the case:

[09:21] <nothingmuch> my Shape $x = $y;

[09:21] <nothingmuch> and for simple methods

[09:21] <audreyt> so syntax wise

[09:21] <audreyt> I wonder if we can still model it as a method call

[09:21] <audreyt> just dispatched contravariantly

[09:21] <audreyt> proto method as (::t --> t) {}

[09:21] <nothingmuch> if we introduce continuation passing style, of course =)

[09:21] <audreyt> is my working hypothesis

[09:21] <audreyt> but we do

[09:22] <audreyt> TimToady said that "want" can simply be &return.signature

[09:22] <audreyt> which will massively simplify things

[09:22] <nothingmuch> aye

[09:22] <nothingmuch> okay

[09:22] <audreyt> the old idea of "context" is changed to simply "signature"

[09:22] <nothingmuch> so CPS in env variables =)

[09:22] <gaal> audreyt: can we still somehow do newtype Id deriving (:>:) ValNative now that there is no ValNative?

[09:22] <audreyt> gaal: parse error

[09:22] <gaal> "now" = when I change Native to a class

[09:23] <nothingmuch> do we provide type annotations on arbitrary expressions yet?

[09:23] <audreyt> then you can't

[09:23] <nothingmuch> maybe we just want Moose( $x.as )

[09:23] <audreyt> I think native should still be a variant

[09:23] <nothingmuch> no wait

[09:23] <audreyt> easier to manage

[09:23] <nothingmuch> that's for the constructor

[09:23] <nothingmuch> i kinda like the haskell way, it's very obvious

[09:23] <audreyt> you can creaatee a helper class

[09:23] <gaal> ugh, ok, undoing stuff then.

[09:23] <audreyt> a variant _and_ a class :)

[09:23] <nothingmuch> my $moose = ( $x :: Moose ); my Moose $moose = $x; ### the same

[09:24] <gaal> ok, the class being just for things that have themseleves as Ids?

[09:24] <audreyt> yeah

[09:24] <audreyt> I almost beginto think that Id should be a new opaque type in surface land

[09:25] <audreyt> but never mind me :)

[09:25] <audreyt> i.e. maybe .valid on all value types should return themselves

[09:25] <audreyt> instead of doing the force-to-true massage

[09:26] <nothingmuch> ++ ++ ++

[09:26] <audreyt> and we distinguish the prototypes by saying that .valid is always Undef

[09:26] <audreyt> since value types are never Undef

[09:26] <audreyt> nothingmuch likes this ? :)

[09:27] <nothingmuch> i don't like force-to-anything for DWIM's sake

[09:27] <gaal> so what does this do?  $x := (); undef $x

[09:27] <nothingmuch> i'd much rather have the evaluating context have an easier way to specify what it means more accurately

[09:27] <audreyt> gaal: unless Seq.undef is somehow defined

[09:27] <audreyt> I imagine it to be method not found

[09:28] <audreyt> it's "undefine" nowadays btw.

[09:28] <gaal> interesting.

[09:28] <audreyt> nothingmuch: I agree

[09:30] <gaal> bottom does not inhabit perl 6 value types and trying to assign it yields an error :)

[09:33] <audreyt> according to the spec, implicit coercion only happens for four types

[09:33] <audreyt> so maybe we treat them specially

[09:33] <audreyt> (Bit/Int/Num/Str)

[09:34] <audreyt> and introduce four methods

[09:34] <audreyt> .bit .int .num .str

[09:34] <audreyt> (note that the first two already exists)

[09:34] <audreyt> I kinda like this

[09:35] <audreyt>  .to_i .to_f .to_s

[09:35] <audreyt> as well as the .to_b Ruby never got

[09:36] <audreyt> to quote matz:

[09:36] <nothingmuch> NOOOOOOOOOOO ! NO UNDERSCORES!

[09:36] <audreyt> <matz> In general, such attempt to define new false values is not worth the

[09:36] <audreyt> performance cost we all have to pay.

[09:36] <audreyt> nothingmuch: er I mean I like .bit .int .nnu .str

[09:36] <nothingmuch> ;-)

[09:36] <nothingmuch> i actually like .to_int etc a bit better but *shrug*

[09:37] <lumi> .to_b might cause bad punning

[09:37] <audreyt> .to_b || .to_b!

[09:37] <audreyt> .to_b?

[09:37] <nothingmuch> if ( .to_b ||  !.to_b ) {  } will always evaluate

[09:37] <nothingmuch> die(); sleep();'

[09:38] <nothingmuch> i think hamlet really ment "to be xor not to be"

[09:38] <nothingmuch> meant

[09:38] <nothingmuch> which is why we will never be able to translate.

[09:38] <nothingmuch> .. *sigh*

[09:39] <audreyt> I think he meant "to be // not to be"

[09:39] <audreyt> as in defined-or

[09:39] *** rodi joined
[09:42] <audreyt> mm. matz doesn't want .to_b for a very good reason

[09:42] *** kane-xs joined
[09:43] <audreyt> as in ruby that would mean you can redefine TrueClass#to_b

[09:43] <audreyt> (since nothing is sealed)

[09:43] <audreyt> and have "true" to mean false

[09:43] <audreyt> perl5 took the middle path and basically seal all value types

[09:44] <audreyt> but allow reference types to define their own "bool"

[09:44] <nothingmuch> both have merits

[09:45] <nothingmuch> the question is who the hell wants to explain to $junior_programmer why if ( true ) { print "moose" } isn't evaluating

[09:45] <audreyt> somehow I think preventing method redefinition for builtin value types is attractive.

[09:45] <nothingmuch> i totally agree

[09:45] <rodi> well, true meaning false has worked very well for some politicians...

[09:47] <audreyt> ok. so all builtin method for value types is final

[09:47] <audreyt> what about Array.int?

[09:47] <audreyt> 4 + @foo

[09:48] <nothingmuch> hmm

[09:48] <audreyt> should the user be able to override it

[09:48] <nothingmuch> i think not

[09:48] <nothingmuch> unless they tie it

[09:48] <audreyt> in which case it's not Array

[09:48] <nothingmuch> in which case it's no longer Array

[09:48] <audreyt> but SomeOtherType

[09:48] <nothingmuch> aye

[09:48] <nothingmuch> $[ is evil, it was deprecated for a reason

[09:48] <nothingmuch> this is not precisely the same, but it's related

[09:50] <audreyt> ok.

[09:53] <gaal> audreyt: should there be ((:>:) Id) instances for all Val types?

[09:53] <nothingmuch> i think it *is* legitimate to give base values new roles though

[09:53] <nothingmuch> kinda like haskell type classes

[09:53] <audreyt> gaal: that's just their valId

[09:53] <audreyt> nothingmuch: sure, as long as they don't conflict with their existing methods

[09:54] <nothingmuch> yep

[09:54] <audreyt> gaal: so sure...

[09:54] <gaal> yes, but was Val.hs:59 just a demo or is it goign to be used somewhere?

[09:54] <audreyt> it's used on line 57

[09:54] <audreyt> that was just experimenting; but sure

[09:55] <audreyt> hm. there's another implicit coercion that perl does all the time

[09:55] <audreyt> I'll call it .list for old time's sake

[09:55] <gaal> -> PureSeq ?

[09:55] <audreyt> PureList

[09:56] <audreyt> ($x, @y, %z) is translated to infix:<,>(variable($x).list, variable(@y).list, variable(%z).list)

[09:56] <audreyt> and infix:<,> just does concat

[09:57] <audreyt> and builtin .list is again nonoverridable

[09:57] <audreyt> but that does let you write an array clasD[D[D[D[D[Ds that does not flatten

[09:57] <audreyt> and then it's bound to @x, then it won't flatten anymore

[09:57] <audreyt> how does this sound?

[09:59] <gaal> so there's Id context and... List context? confusing.

[10:00] <audreyt> Id context?

[10:00] <gaal> (:>: Id)

[10:00] <audreyt> that's just used for .valid

[10:00] <gaal> ((:>:) Id)

[10:00] <audreyt> it's an upcast... not coercion

[10:00] <audreyt> (:>:) in general is upcast not coercion

[10:00] <audreyt> it's just for internal use

[10:01] <gaal> yes....

[10:01] <audreyt> the coercions written here will take place in the SIO monad

[10:01] <audreyt> if not Eval monad

[10:01] <audreyt> (still not sure)

[10:01] <audreyt> probably SIO monad

[10:01] <audreyt> at least for the builtin types

[10:02] <audreyt> ok. I'll write ImplicitCoercion class

[10:03] * gaal needs to take a nap... &

[10:04] *** chris2 joined
[10:29] <rodi> ?eval my $args = \(1,2,3,:mice<blind>)

[10:29] *** evalbot_11984 is now known as evalbot_11989

[10:29] <evalbot_11989> [1, 2, 3, ("mice" => "blind")]

[10:29] <rodi> ?eval @$args[3]<mice>

[10:29] <evalbot_11989> Error: Undeclared variable: "$args"

[10:30] <rodi> oops

[10:30] <rodi> ?eval my $args = \(1,2,3,:mice<blind>); @$args[3]<mice>

[10:30] <evalbot_11989> \"blind"

[10:30] <rodi> I really love you, evalbot_11989.

[10:31] <rodi> pugs, perl6, and all of you are so, so, so cool.

[10:31] <wolverian> ?eval my $args = \(1,2,3,:mice<blind>); $args[3]<mice>

[10:31] <evalbot_11989> \"blind"

[10:32] <rodi> is that supposed to work?

[10:33] <rodi> I'm still catching on to the invariant sigils, not to mention twigils.

[10:34] <wolverian> I don't know capture semantics yet.

[10:35] <rodi> %@$args[3]<mice> # definitely does not work...

[10:35] <wolverian> S02 doesn't specify if Capture responds to postfix:<[ ]>

[10:37] <rodi> more specifically:

[10:37] <rodi> ?eval my $a = \<a b c>; say $a[1]

[10:37] <evalbot_11989> OUTPUT[b ] Bool::True

[10:38] <rodi> seems to invalidate the notion of invariant sigils in my mind, though I understand Capture is magic.

[10:38] <rodi> I expect:

[10:38] <rodi> ?eval my $a = \<a b c>; say @$a[1]

[10:38] <evalbot_11989> OUTPUT[b ] Bool::True

[10:38] <rodi> to work.

[11:38] *** xdg joined
[11:53] *** arbaalo joined
[11:53] <arbaalo> hi

[11:57] *** codermattie joined
[12:04] <meppl> guten morgen

[12:04] *** justatheory joined
[12:06] *** Limbic_Region joined
[12:08] *** bpphillips joined
[12:10] <rodi> wie gehts

[12:24] <svnbot6> r11990 | fglock++ | pX/v6 - lazy rules compilation in syntax categories

[12:24] <clkao> fglock - you might noticed it's already merged to perl5/

[12:27] <svnbot6> r11991 | audreyt++ | * Pugs.Val: Coercion interface.

[12:27] * Limbic_Region idly wonders if Luke has returned from the dark side

[12:32] *** fglock joined
[12:36] *** kanru joined
[12:37] *** iblechbot joined
[12:38] <fglock> Test.pm on v6 now takes less than 8s; '-e' takes 1s cpu time

[12:38] <audreyt> yay!

[12:39] <fglock> fglock: it is 'autoloading' the rules (lazy compiling)

[12:40] <kolibrie> fglock: very exciting!

[12:40] <fglock> s/fglock/audreyt/ :)

[12:40] *** cdpruden joined
[12:40] * kolibrie is going to try to get v6 up-and-running today

[12:41] <fglock> this version is still in pX/Common

[12:41] <kolibrie> fglock: so, by the time I have it working locally, it will be merged :)

[12:42] *** nine joined
[12:44] <fglock> it is still using a lot of ram - it is possible that the new insideout objects are not being destroyed

[12:44] <kolibrie> one step at a time

[12:45] * kolibrie is not in a hurry

[12:48] *** frederico joined
[12:53] *** jferrero joined
[12:54] *** jferrero left
[12:54] *** jferrero joined
[12:54] <fglock> oh, clako merged to perl5/ in r11983 - I'll move my changes there to

[12:54] <fglock> clkao

[12:54] <fglock> too

[12:57] <svnbot6> r11992 | gaal++ | * improve error messages on failed coersion

[12:57] <pasteling> Someone at 192.115.25.249 pasted "missing instance breaks build on 6.4.1" (7 lines, 448B) at http://sial.org/pbot/18852

[13:02] <fglock> clkao: I just backlogged - I'll merge now

[13:02] <lambdabot> right now?

[13:02] <rodi> lambdabot: you are a bot, right?

[13:04] <gaal> > True

[13:04] <lambdabot>  True

[13:09] <audreyt> gaal: so... I'm trying to resolve the circularity a bit

[13:09] <svnbot6> r11993 | audreyt++ | * unbreak the build by supplying an instance for new val

[13:09] <audreyt> gaal: the idea is that all pure value types should have visibility to each other

[13:09] <audreyt> I think

[13:09] *** lypanov joined
[13:09] <audreyt> yet they are to be defined in different modules

[13:10] <audreyt> which means Pugs.Val will import and then export them

[13:10] <audreyt> via .hs-boot

[13:10] <lypanov> hey *

[13:10] <audreyt> somehow putting "Coercible" into .hs-boot seems to not work

[13:10] <audreyt> lypanov: hi

[13:11] <lypanov> heya audreyt :)

[13:11] * lypanov was stolen by $job and mov and ->paint()

[13:11] * lypanov reads teh blogs

[13:19] *** rodi is now known as rodi_away

[13:19] <nothingmuch> hola lypanov

[13:19] <nothingmuch> welcome back

[13:22] <lypanov> yoyo nothingmuch!

[13:22] <nothingmuch> slinky lypanov!

[13:22] *** xinming_ joined
[13:22] <lypanov> heh

[13:22] <nothingmuch> did you paint anything nice? or just walls?

[13:23] <lypanov> nothingmuch: just walls :(

[13:23] <svnbot6> r11994 | fglock++ | v6 - merged lazy rule compilation

[13:25] <gaal> audreyt: won't making classes of all of them help?

[13:25] <svnbot6> r11995 | fglock++ | v6 - pX/Common cleanup

[13:26] *** fglock joined
[13:26] *** mauke_ joined
[13:26] <audreyt> gaal: "them"?

[13:27] <audreyt> the class is Pure...

[13:27] <gaal> i didn't know instance Coercible SIO Val where {- nothing -} is valid haskell

[13:27] *** kanru joined
[13:27] *** christopher joined
[13:27] <gaal> or that instance X {} is either, for that matter

[13:27] <audreyt> {} is same as nothing

[13:28] <gaal> hmm you're right it's already Pure...

[13:29] <gaal> of all things why is it pure that needs all-to-all visibility?

[13:29] <gaal> because of coersion?

[13:29] <gaal> (coercion?)

[13:30] <audreyt> yeah

[13:30] <audreyt> so strictly speaking just the coercion targets

[13:30] <audreyt> needs to be visible

[13:34] *** Qiang joined
[13:36] <audreyt> valMeta is now automagic :)

[13:36] <audreyt> i.e. if it's called in Hs as "PureStr" then it gets the p6 name "Str"

[13:37] * audreyt plunges ahead to make "say `hello`" work

[13:37] <svnbot6> r11996 | audreyt++ | * valMeta now works again by intuiting p6land data type

[13:37] <svnbot6> r11996 | audreyt++ |   from hsland data type.

[13:40] *** justatheory joined
[13:40] <gaal> wow

[13:40] *** mauke_ is now known as mauke

[13:41] <nothingmuch> wow?

[13:42] <gaal> nothingmuch: r11996 is cool

[13:43] *** buetow joined
[13:43] <gaal> though, I wonder, 42.meta autoboxes 42, so what's the chance of seeing a native meta? natives are unboxed and don't have metas, no?

[13:44] *** dmsantam joined
[13:44] <pasteling> "gaal" at 192.115.25.249 pasted "the other Cabal is jealous?" (2 lines, 143B) at http://sial.org/pbot/18855

[13:47] <audreyt> did you build once with and once without embed parrot?

[13:49] <gaal> always with, but sometimes optimized and sometimes not.

[13:50] <audreyt> mmm

[13:50] <audreyt> weird. :/

[13:50] <audreyt> try not enable embed parrot while you are coding this, I guess

[13:50] <gaal> nuking .o and .his from dist and src, trying again...

[13:50] <gaal> yes, that fixed it. funny.

[13:52] <nothingmuch> ugh

[13:53] <nothingmuch> my sister

[13:53] <nothingmuch> is sooooooooooooooooooooooooooooo

[13:53] <nothingmuch> ugh

[13:53] <audreyt> ugh?

[13:54] <nothingmuch> ugh.

[13:54] <gaal> alias deadchicken find . -name \*.hi | perl -n00le '@a = split /\n/, $_; print $a[rand@a]' | xargs rm

[13:54] <gaal> nothingmuch: give her a commit bit.

[13:54] <nothingmuch> no,  i'd rather not communicate with her today

[13:54] <nothingmuch> she is in a teacher mood

[13:56] <kolibrie> and nothingmuch does not want to be her eager student?

[13:56] <nothingmuch> well

[13:56] <nothingmuch> she doesn't teach you anything

[13:56] <nothingmuch> she just treats you like a preschooler

[13:56] <nothingmuch> when she does it to my dad it's almost amusing

[13:57] <gaal> what's the name of that search-in-source-files-of-one-kind tool again?

[13:57] <nothingmuch> ack

[13:57] <nothingmuch> ?

[13:57] <gaal> yes, thanks

[13:59] <gaal> audreyt: what's P and what is Identity?

[13:59] <gaal> hmm

[13:59] <gaal> @hoogle Identity

[14:00] <lambdabot> Control.Monad.Identity :: module

[14:00] <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a

[14:00] <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a

[14:00] <gaal> aha

[14:00] <gaal> (answer: "Go read this paper")

[14:01] <gaal> http://web.cecs.pdx.edu/~mpj/pubs/springschool.html

[14:01] <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism

[14:02] <nothingmuch> is mpj spj's evil twin?

[14:03] <gaal> professor s and professor m. no, doesn't have quite the right ring to it

[14:04] <audreyt> P is Identity

[14:05] <gaal> yes, trying to find out what that is

[14:05] <gaal> :)

[14:05] <gaal> ugh, and it's not mentioned by that name inthe Overloading paper?

[14:05] <gaal> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html is not very useful

[14:06] * gaal suddenly vaguely recalls Identity is a monad?

[14:06] <audreyt> yes

[14:06] <audreyt> newtype Identity a = Identity a

[14:07] <audreyt> it's a monad that's erased by the compiler

[14:07] <audreyt> P stands for Pure

[14:07] <audreyt> the idea is that each of the three variant is associated with a monad

[14:07] <audreyt> Pure with P, Mut with STM, Ext with SIO

[14:08] <gaal> ah, so all code that deals with them polymorphically can be monadic

[14:09] <svnbot6> r11997 | audreyt++ | * Bridge VV-land coercion with oldland fromVal, so this now works:

[14:09] <svnbot6> r11997 | audreyt++ |     say `Hello, World!`;

[14:09] <audreyt> exactly

[14:09] <gaal> and when we are inside pure code we can escape out of the monad

[14:09] <audreyt> yup

[14:09] <audreyt> by saying "liftP"

[14:09] <audreyt> liftP :: Monad m => P a -> m a

[14:09] <gaal> unsafeExceptReallyThisIsSavePerformP

[14:09] <audreyt> yup

[14:10] <audreyt> I think my work today is done

[14:11] <audreyt> if you'd like, you can try this exercise

[14:11] <audreyt> say `1`+`1`

[14:11] <audreyt> which involves adding fromVV to Pugs.AST.Internals's

[14:12] <audreyt> Value Vint, Value VNum

[14:12] <audreyt> cases

[14:12] <audreyt> and elaborate the corresponding asNum and asInt in VV land

[14:12] <audreyt> I also wonder if we should adopt a convention for type classes

[14:13] <audreyt> ICoercible, IValue, etc

[14:13] <gaal> good, except doesn't the parser already quote the thing iside ``s?

[14:13] <audreyt> to visually distinguish them

[14:13] <audreyt> yes, so it's testing PureStr->PureInt coercion

[14:13] <audreyt> I'd like to get the PureStr case done right

[14:13] <audreyt> and then select a Mut class to test

[14:14] <audreyt> perhaps a mutable hash implemented by JudyHS

[14:14] <audreyt> and then a Ext class, perhaps file handle

[14:14] <pasteling> "gaal" at 192.115.25.249 pasted "another 6.4.1 error?" (19 lines, 1K) at http://sial.org/pbot/18856

[14:14] <audreyt> and once the three are bridged

[14:14] <audreyt> then we'll know the MOP is ready

[14:15] <audreyt> seems so; I've added a -fallow-overlapping-instances

[14:15] <svnbot6> r11998 | audreyt++ | * cure 6.4.1 build.

[14:15] <audreyt> see if it helps

[14:15] <gaal> pulling

[14:15] <gaal> yes, thanks

[14:16] <audreyt> yay

[14:16] <audreyt> so, once Pure/Mut/Ext can be shown to be bridged to the old runloop

[14:16] <gaal> ok I'll try to moose it

[14:16] <audreyt> Capture and Signature can then be introduced

[14:16] <audreyt> at which point we convert PerlSV to Ext

[14:17] <audreyt> and then retire the old Value class

[14:17] <audreyt> at which point the new MOP takes over

[14:17] <audreyt> and then we can tackle Exp

[14:18] <audreyt> have fun :)

[14:18] <audreyt> *wave*

[14:18] <gaal> say `moo` just prints moo here..

[14:18] <audreyt> that's correct

[14:18] <gaal> is that what was indtended?

[14:18] <audreyt> what else do you expect? :)

[14:18] <audreyt> try

[14:19] <audreyt> ./pugs

[14:19] <audreyt> pugs> :d `foo`

[14:19] <audreyt> Noop;

[14:19] <audreyt> VPure (MkStr "foo")

[14:19] <gaal> so `` is surface Val.Val -> VStr?

[14:19] <gaal> ah, the coercion is later

[14:19] <gaal> i get it

[14:20] <gaal> heh, the new ast will probably get rid of those leading Noops too :)

[14:20] <gaal> ok good night audreyt :)

[14:20] *** hexmode joined
[14:20] <audreyt> :))

[14:20] <audreyt> &

[14:21] <svnbot6> r11999 | audreyt++ | * add fromVV to oldland Val itself.

[14:31] *** cjeris joined
[14:32] *** fridim joined
[14:32] <fridim> hi

[14:36] *** mdiep joined
[14:38] <Limbic_Region> lo

[14:39] *** hexmode` joined
[14:48] <svnbot6> r12000 | gaal++ | * New naming convention gives "I" prefix to general interfaces.

[14:48] <svnbot6> r12000 | gaal++ |   For now, this is used only in IValue and ICoercible.

[14:48] <svnbot6> r12000 | gaal++ | * Maybe use "A" for ASTish typeclasses (e.g. APure instead of IPure)?

[14:53] *** awwaiid joined
[14:53] <svnbot6> r12001 | fglock++ | v6 - move for/while/until/loop macros to %StatementControl

[14:54] <fglock> it should now be possible to lexically redefine statementcontrols - i haven't tried yet

[14:55] <fglock> &

[14:56] *** fglock left
[15:03] *** Eimi joined
[15:18] *** vel joined
[15:26] *** marmic joined
[15:26] *** crem joined
[15:30] *** weinig joined
[15:43] *** rodi_away is now known as rodi

[15:54] *** fglock joined
[15:56] <audreyt> gaal: I think I solved the context puzzle for real :)

[15:56] <svnbot6> r12002 | audreyt++ | * Finally, an extremely sane treatment for item/list contexts.

[15:56] <svnbot6> r12002 | audreyt++ |   both only occur in ByVal (i.e. when the return continuation is

[15:56] <svnbot6> r12002 | audreyt++ |   expecting something not "is rw").

[15:56] <svnbot6> r12002 | audreyt++ |   The compiler inserts a runtime dispatch of .item or .list on the

[15:56] <svnbot6> r12002 | audreyt++ |   term (usually a container).

[15:56] <svnbot6> r12002 | audreyt++ |   A user-defined object can elect to return its content

[15:56] <svnbot6> r12002 | audreyt++ |   (like Scalar.item, Scalar.list and Array.list) or not

[15:56] <svnbot6> r12002 | audreyt++ |   (like Array.item, Hash.item and Int.list).

[15:56] <svnbot6> r12002 | audreyt++ |   The choice in Hs level is controlled in asList and asItem

[15:56] <svnbot6> r12002 | audreyt++ |   method; the P6 level equivalence would be ".item" and ".list"

[15:56] * audreyt happily goes back to sleep

[15:56] <svnbot6> r12002 | audreyt++ |   unless later overruled. :-)

[15:56] <svnbot6> r12002 | audreyt++ | * Bridged this treatment to oldland VV as well.

[15:56] <gaal> audreyt: cool! I've beed adding PureInt `1` stuff

[15:57] *** weinig joined
[15:57] <gaal> but problems with circularity and ICoercible etc. mean some stuff is shoved in Pugs.Val

[15:57] <audreyt> yup

[15:57] <audreyt> solving circularity somehow would be a win

[15:57] <gaal> it's almost finished compiling now, let's see if it works

[15:57] <audreyt> but my brain is fried :)

[15:57] <audreyt> ooh nice

[15:57] <audreyt> *wave* again

[15:57] <audreyt> be back in ~10hrs

[15:58] <gaal> night :)

[16:03] <gaal> so, because `foo` is a string, how do I get to see MkInt in action?

[16:04] <gaal> it parses and compiles and all, but I still get MkStr "1"

[16:04] *** jferrero joined
[16:05] <gaal> guess I need to be more clever aroudn Parser:2008

[16:12] <gaal> okay, so I completely hijacked this and did:

[16:12] <gaal> return . Val . VV $ val (cast ((read str) :: Integer) :: PureInt)

[16:12] <gaal> but that's obviously lying since it depends on the existing Show class to do to the conversion

[16:13] <gaal> and yet, it works :)

[16:13] <gaal> though interestingly I find that + doesn't work on ints! `1`+`1` seems to require them to be lifted to doubles (VNum). isn't that a bug?

[16:13] <svnbot6> r12003 | fglock++ | v6 - finished %StatementControl migration

[16:17] *** frederico joined
[16:20] *** frederico joined
[16:20] <svnbot6> r12004 | audreyt++ | * Experiment with two higher-order instances of cast:

[16:20] <svnbot6> r12004 | audreyt++ |     "return . cast" can be written as "cast"

[16:20] <svnbot6> r12004 | audreyt++ |     "fmap cast" can be written as "cast"

[16:20] <svnbot6> r12004 | audreyt++ |   also, most "liftX" can now be written as "cast" as well.

[16:20] <svnbot6> r12004 | audreyt++ |   If this proves to be too confusing and/or causing too

[16:20] <svnbot6> r12004 | audreyt++ |   much overlaps, then they could be retired (esp. the first

[16:20] <svnbot6> r12004 | audreyt++ |   case that gives out "Just" and "singleton" for free).

[16:21] <Limbic_Region> is a realclean currently necessary to build after recent commits?

[16:21] <Limbic_Region> I ask because I haven't been able to build on Win32 for about the last 5 commits

[16:23] <Limbic_Region> and fwiw - make realclean is b0rk on Win32

[16:24] <gaal> Limbic_Region: nopaste?

[16:24] <svnbot6> r12005 | audreyt++ | * document the meaning of "cast" better: It must be injective,

[16:24] <svnbot6> r12005 | audreyt++ |   i.e. different inputs must be mapped to different outputs.

[16:25] <Limbic_Region> gaal - just a sec

[16:25] <Limbic_Region> which - the realclean or the build problem?

[16:25] <gaal> the one that bothers you more :)

[16:26] *** xinming_ is now known as xinming

[16:26] <Limbic_Region> ah, well then that's the build

[16:26] <Limbic_Region> perlbot nopaste

[16:26] <gaal> argh, audreyt, conflict in ci now. you're sleepcommitting again :)

[16:26] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[16:26] <gaal> audreyt the somnasvkcist

[16:26] <pasteling> "Limbic_Region" at 129.33.119.12 pasted "Build problem on Win32" (31 lines, 2.3K) at http://sial.org/pbot/18858

[16:27] <gaal> Limbic_Region: let me finish this commit and i'll be with you

[16:27] <svnbot6> r12006 | fglock++ | v6 - TODO cleanup

[16:28] <Limbic_Region> gaal - already attempting a realclean so I might be a few minutes myself

[16:28] <[particle]> i'm here too, doing realclean of older pugs

[16:28] <[particle]> (win32)

[16:29] *** ruz joined
[16:30] * Limbic_Region wanders off for food but bbiab

[16:31] <svnbot6> r12007 | fglock++ | v6 - v6.pm 0.012; Pugs::Compiler::Rule 0.13

[16:32] *** Psyche^ joined
[16:33] <fglock> this v6.pm is likely the cpan version - please report bugs

[16:36] <gaal> Limbic_Region: are you running the very latest r? this error is the same kind you had the other day. what does svk pull ; svk st Pugs.cabal.in say?

[16:36] <svnbot6> r12008 | gaal++ | * Add VV support for PureInt. The verification is awkward to make with

[16:36] <svnbot6> r12008 | gaal++ |   the `` hack, so it's commented out.

[16:36] <svnbot6> r12008 | gaal++ | * Belay the attempts at -boot files since they don't seem to allow

[16:36] <svnbot6> r12008 | gaal++ |   ICoercible. The cost is that instances for that class must be defined

[16:36] <svnbot6> r12008 | gaal++ |   in Pugs.Val.

[16:37] *** hcarty joined
[16:38] <gaal> perhaps we can group types and have Pugs.Val.Pure instead of .Str, .Int etc.?

[16:42] <Limbic_Region> gaal - I was running the very latest rev (which was working) up until about 11998 or so

[16:42] <gaal> please make sure your Pugs.cabal.in is up to date

[16:43] <Limbic_Region> it is

[16:43] <Limbic_Region> in fact, the first thing I did this morning was remove it and svn up to verify it was restored and working (which it was)

[16:43] <Limbic_Region> I can post what it looks like if you think that might be of interest

[16:43] <gaal> does it have Pugs.Val.Str?

[16:44] <gaal> try a clean build again. worst comes to worst, clean checkout.

[16:45] <Limbic_Region> yes it has Pugs.Val.Str

[16:46] <Limbic_Region> and I am still trying the clean build from [12:28] <Limbic_Region> gaal - already attempting a realclean so I might be a few minutes myself

[16:48] <gaal> okay. remember unoptimized

[16:48] *** Psyche^ is now known as StudiesInWords

[16:48] <Limbic_Region> I am not going to do a clean checkout - I know if I reverted back to 11990 or so it would work again - and I haven't done anything other than svn and nmake

[16:49] * Limbic_Region never does unoptimized primarily because he doesn't care how long the build takes as long as the runtime is relatively fast

[16:49] <Limbic_Region> not that I write much Perl 6 these days or do anything with Pugs other than verify it compiles

[16:49] <gaal> when testing build problems...

[16:50] <gaal> bbl &

[16:50] <Limbic_Region> k

[16:54] <Limbic_Region> it appears that all that was necessary was a realclean and a nmake

[16:54] * Limbic_Region is not entirely sure why that is necessary sometimes but things appear to be working just fine now

[16:56] <fglock> I forgot to update the changelog - too late

[16:57] <fglock> v6 0.012 is in cpan :)

[16:58] <[particle]> fglock++

[16:58] <Limbic_Region> yep - successfully built

[16:58] <Limbic_Region> particle - were you also having build problems on Win32?

[16:58] <[particle]> fglock: i'm trying now to add some of your parser rules to parrot/perl6

[16:58] <[particle]> l_r: i was going to look into yours

[16:59] <[particle]> but my system is really slow due to currently executing backup

[16:59] <fglock> [particle]: cool - please let me know if i can help

[16:59] <[particle]> fglock: it'd be great to have one representation, perhaps P::C::P6 could be generated?

[17:00] <cjeris> Limbic_Region: I'm building on win32 and can't get the ghc_heap_size: 512m setting in config.yml to take effect ... keep dying on Pugs.Parser

[17:00] <fglock> actually, v6-compiler would be the best source

[17:00] <Limbic_Region> cjeris - either change the size of the heap or just type nmake again after it dies - it will continue on happily

[17:00] <fglock> I plan to emit v6.pm from v6-compiler in the (near) future

[17:00] <[particle]> fg: is that in the pugs repo?

[17:01] <[particle]> i see

[17:01] <Limbic_Region> ok, built 12005 successfully and just svn'd up to 12008 - will see if that builds fine without realclean

[17:01] <cjeris> Limbic_Region: what do I have to do to get the setting from config.yml to stick though?  I don't remember having to edit anywhere else a few weeks ago

[17:01] * Limbic_Region notices that Pugs.cabal.in has been updated

[17:02] <fglock> [particle]: yes - v6/v6-Compiler - I'm working on both in parallel

[17:02] <Limbic_Region> cjeris - dunno though I am not the right person to be asking

[17:02] <fglock> v6-Compiler is 'p6p6' and v6.pm is 'p6p5'

[17:03] <Limbic_Region> cjeris - IOW, if uncommenting # ghc_heap_size: 348m in your config.yml and/or adjusting it doesn't stick - I am at a loss

[17:03] <[particle]> ah, i see. p6p6 is viable now? that's great.

[17:03] <clkao> fglock: whoot release. does syntax/braces-in-rule pass?

[17:04] <fglock> v6.pm is supposed to compile v6-Compiler, and then you only need v6.pm to implement low-level stuff

[17:05] <fglock> clkao: should I have tested before releasing? :)

[17:05] <[particle]> fglock: well if i can get the prereqs set up on windows, i may be able to help with parser mods

[17:05] <fglock> clkao: I'll try

[17:06] <fglock> [particle]: I installed in windows with vanilla-perl

[17:06] *** weinig joined
[17:07] <Limbic_Region> if anyone is using AS Perl with mingw then I can tell you how to get all the v6.pm prereqs installed

[17:08] <[particle]> l_r: could you write up a pod?

[17:08] <Limbic_Region> AS is broke and Module::Build finds the error

[17:08] <Limbic_Region> particle - it would be easier just to point to the PerlMonks node where I asked (and got solutions)

[17:09] <Limbic_Region> btw - Jan Dubois from AS applied the patch that bart came up with and it is going to be part of build 818

[17:09] <[particle]> ah. those bums at perlmonks helped ;)

[17:09] <nothingmuch> Juerd: ping

[17:09] <fglock> bbiab &

[17:10] <Limbic_Region> see http://perlmonks.org/index.pl?node_id=565276

[17:10] <lambdabot> Title: Re^3: Help building Devel::Caller

[17:11] <Limbic_Region> while that addresses Devel::Caller, the patch actually fixes the AS Perl, MinGW, Module::Build problem

[17:11] <nothingmuch> Juerd: actually, hold that ping, i am going to take a shower first

[17:12] *** frederico joined
[17:14] <fglock> clkao: do you know what needs to be added to Makefile.PL in order to have precompiled Test.pm and Prelude in the distro?

[17:14] <fglock> (Module::Compile stuff)

[17:20] *** weinig joined
[17:24] <clkao> crazy module::install-fu. ask ingy

[17:30] <Limbic_Region> ok, that was odd

[17:30] <bpphillips> fglock: check http://search.cpan.org/src/INGY/Module-Compile-0.18/README under the "DISTRIBUTION SUPPORT" section

[17:30] <Limbic_Region> I finally got build 12005 working after doing a realclean

[17:30] <Limbic_Region> I svn'd up to 12008

[17:31] <Limbic_Region> I did an

[17:31] <fglock> bpphillips: thanks!

[17:31] <Limbic_Region> nmake

[17:31] <Limbic_Region> built fine - but doing a pugs -v still shows 12005?

[17:36] *** weinig joined
[17:36] <svnbot6> r12009 | fglock++ | v6 - t/syntax/parsing/braces_in_rules.t "ok 1 - expression parsed"

[17:36] <svnbot6> r12010 | fglock++ | more...

[17:36] <fglock> clkao: fixed :)

[17:42] *** weinig joined
[17:45] *** aufrank joined
[17:46] *** baest joined
[17:47] *** pmurias joined
[17:47] <pmurias> hi

[17:47] <ingy> hola

[17:50] <pmurias> what would the following english order somebody to do, say "h" if 1 is unequal to 1 or 2 or 3, otherwise say "hello"

[17:50] <pmurias> ?

[17:51] <wolverian> "h"

[17:51] <Limbic_Region> pmurias - I believe it is ambiguous that given the verbal direction to different people would result in different responses

[17:51] <Limbic_Region> pmurias but I would tend to agree with wolverian that the majority would go with "h"

[17:52] <pmurias> meant "hi" :)

[17:52] <aufrank> there's definitely an ambiguity in scope

[17:52] <wolverian> this is why junctions and negations are strange.

[17:52] <pmurias> well, the example was inspired by the synopsis

[17:54] <pmurias> that was (i'm not sure if correct) translation of "if $a != 1 | 2 | 3 {...}"

[17:54] <Limbic_Region> pmurias in a programming language it is easy, all that is necessary is to know the precedence of or

[17:56] <Limbic_Region> of course, or ne junction so that kind of breaks down too

[17:58] <pmurias> the synposis suggest that that code should raise a warning , because it work diffrently in perl and in english,

[18:00] <wolverian> "if a is not 1 or 2 or 3..."

[18:00] <wolverian> is the translation you are looking for

[18:01] <wolverian> which means 'if $a != all(1,2,3)'

[18:02] <Limbic_Region> wolverian - um, no

[18:03] <Limbic_Region> that should be any(1,2,3)

[18:03] <wolverian> well, that is how I parsed the english.

[18:03] <Limbic_Region> 1 & 2 & 3 would = all(1,2,3)

[18:03] <wolverian> yes.

[18:03] <wolverian> but I did not translate from perl to perl, but from english to perl.

[18:03] * Limbic_Region isn't complaining about your english translation - just your code

[18:04] <wolverian> I _meant_ 1 & 2 & 3

[18:04] *** jferrero joined
[18:04] <wolverian> "if a is not 1 or 2 or 3" means that a can not be any of them, i.e. all(), not any()

[18:04] <Limbic_Region> um, than you should s/or/and/

[18:05] <Limbic_Region> or rather

[18:05] <wolverian> "if a is not 1 and 2 and 3" does not make sense. :)

[18:05] <Limbic_Region> s/or/and not/g

[18:05] <wolverian> right.

[18:05] <Limbic_Region> if a is not 1 and not 2 and not 3

[18:05] <wolverian> anyway, I believe that is what the synopsis refers to - people do use "or" there.

[18:06] <pmurias> by the way is there a word in english meaning xor?

[18:07] <pmurias> remembered the either form :)

[18:07] <wolverian> yes, xor. :-)

[18:07] <wolverian> ..not many people use it though..

[18:10] <pmurias> "i will go on foot xor call a taxi" is a bit strange...

[18:12] <Limbic_Region> there is a www.dictionary.com entry for xor but not a http://thesaurus.reference.com/ entry so I doubt there is a common english word that means the same as xor

[18:12] <lambdabot> Title: Thesaurus.com

[18:15] <pmurias> the polish word is "albo'

[18:16] <merlyn> exclusively or. :)

[18:16] <merlyn> or the word OR with a lot of emphasis

[18:16] <TimToady> xor is generally "or" in English.

[18:16] <c6rbon> in English, 'or' is most often used as xor.

[18:16] <merlyn> you can have the cake ORRRRRRRR the ice cream

[18:16] <TimToady> to really mean "or" you say "and/or"

[18:17] <c6rbon> even without emphasis, xor is its usual meaning.

[18:17] <merlyn> which is never pronounced "and or or" :)

[18:17] <merlyn> even though logically, it must mean that

[18:18] <c6rbon> English doesn't really have a logical OR I can think of - we rarely use that meaning in speech.

[18:19] <TimToady> I'm thinking that fake methods should be treated syntactically as type coercions rather than methods, so that would change .meta to .Meta or Meta(), .valid to .ValueId or ValueId(), and also variable() to .Variable or Variable()

[18:20] <TimToady> assuming we recognize type names as method calls representing coercions

[18:21] * wolverian sits down

[18:21] <merlyn> english has illogical or

[18:21] <wolverian> TimToady, all types?

[18:21] <TimToady> :D

[18:22] <TimToady> most of 'em are uppercase, so it might not be a big collision problem.

[18:22] <gaal> logicians have optimistic expectations of formalization

[18:22] <TimToady> if foo() and .foo are nearly the same, then Type() and .Type should probably be nearly the same thing.

[18:22] <pmurias> merlyn: i think got the point quite clearly

[18:23] <wolverian> but I'm used to seeing the type in front of the name

[18:23] <TimToady> then write it that way.

[18:24] <wolverian> I'm playing devil's advocate, mostly. does prefix type coerce too then?

[18:24] <TimToady> another way of saying what I'm saying is that I'm claiming the types Meta, ValueId and Variable rather the method name.

[18:25] <TimToady> whether Type($x) can also be written $x.Type is orthogonal to that.

[18:25] <wolverian> oh. yeah. sorry.

[18:26] <TimToady> alternatively we could claim META(), VALUEID(), and VARIABLE()

[18:26] *** bernhard joined
[18:26] <TimToady> still as type names...

[18:27] <TimToady> syntactically speaking

[18:27] <pmurias> that would be better

[18:28] <pmurias> than Meta,ValueId and Variable IMHO

[18:28] <TimToady> I suppose we could have $x.META without allowing $x.Int, but it seems cleaner to generalize

[18:28] <TimToady> since .META actually is saying "make me a metaclass object out of this"

[18:30] *** fitzzz joined
[18:30] <TimToady> On the contravariant "as", I think we just say that it's not really a method in this class.  You're really writing a default constructor for the other class.

[18:30] *** fitzzz left
[18:31] <TimToady> and $x as Foo then calls Foo($x)

[18:31] <TimToady> and there is no .as method

[18:32] <TimToady> you just say $x.Foo if that's what you want

[18:36] <TimToady> in which case maybe we don't need infix "as".

[18:36] <TimToady> that might give us back .as for formats.

[18:37] <TimToady> biab &

[18:37] <wolverian> I am liking it.

[18:41] <TreyHarris> we do mean boolean-or sometimes.  "if you are an elite member of one of our frequent-flyer partners OR are seated in first class rows 1-8, you may now board OR later at your leisure".  one boolean or, one xor.

[18:49] *** weinig joined
[18:57] <svnbot6> r12011 | fglock++ | v6 - updated v6-rule grammar; fixed token <@array>

[18:59] <TimToady> I suppose if the value id is just the value itself for value types, it could just be .VALUE or .VAL

[18:59] <TimToady> and then VARIABLE could be .VAR

[19:00] <TimToady> VAR($x).foo

[19:00] <wolverian> I like the short-and-caps style.

[19:01] <TimToady> if we say that any .TypeName is recognized at compile time, that gives us potentially a general way to write other macro-like methods too.

[19:02] <TimToady> and it even kindof follows the cpp macros-in-uppercase convention

[19:04] <TimToady> and/or, we require/allow $x.::TypeName

[19:05] <TimToady> if required, then you'd have to write META($x) or $x.::META

[19:05] <TimToady> but we have the .^ notation as a shorthand still, presumably.

[19:06] <TimToady> I dunno, I'm inclined to allow but not require the ::

[19:07] <[particle]> does the :: sigil interact with any twigils?

[19:07] <TimToady> but that does create a natural conflict between compile-time vs run-time dispatch.

[19:07] <TimToady> can't have it both as a macro, and as a fallback from .Foo to Foo() at run-time.

[19:08] <TimToady> unless the class marks its constructor as a macro maybe

[19:09] <TimToady> then $x.FOO could be translated to FOO($x) at compile time, but $x.BAR could just call Object.BAR which defers to BAR($x).

[19:09] <TimToady> hmm, well, I really oughta go to work...

[19:09] <TimToady> since it's already after noon...

[19:10] *** frederico joined
[19:21] <TimToady> method ::Foo { ... } # how to write coercion?

[19:21] <TimToady> method ::Foo { Foo(self) } # default coercion?

[19:27] <TimToady> I think it's probably better to make all classes macroish methods to give the optimizer a shot at them.

[19:28] <TimToady> not sure how this fits in with virtualized classes though.

[19:30] <TimToady> I guess the compiler already knows which classnames are virtualized though.

[19:33] *** justatheory joined
[19:33] *** broquaint joined
[19:43] *** andez joined
[19:43] *** andez left
[19:52] *** jmf left
[20:00] *** weinig joined
[20:02] *** weinig joined
[20:10] *** vel joined
[20:18] *** bpphillips left
[20:18] *** weinig joined
[20:19] *** buubot joined
[20:25] *** asz joined
[20:31] *** jferrero joined
[20:47] *** equinox5 joined
[20:47] <equinox5> hi

[20:47] <equinox5> what will be ready by Christmast?

[20:48] <equinox5> I have heard of Perl 6 will be ready by then.

[20:48] <equinox5> What backend will be ready by then?

[20:55] <obra> equinox5: it's a joke. Nobody will tell you which christmas

[20:55] *** SageLT joined
[21:03] * marcus_ is dreaming of a green christmas

[21:03] <marcus_> obra: congrats on the hiveminder going public

[21:03] <obra> thanks

[21:06] <marcus_> -/win 5

[21:06] <marcus_> agh

[21:06] <StudiesInWords> yes, congrats, obra

[21:08] <equinox5> obra.. joke Yes, I heard that a year ago...

[21:09] <equinox5> but on http://www.pugscode.org/ I saw a presentation and a graph showing the end of 2006....

[21:09] <lambdabot> Title: Pugs - pugscode

[21:09] <equinox5> as a finish line.

[21:11] *** Maddingue joined
[21:13] <svnbot6> r12012 | fglock++ | v6 - added 'StatementModifier' grammatical category

[21:15] *** fglock joined
[21:18] <fglock> re what backend will be ready first - I guess they are very likely to get ready together, as the spec gets stable and we get more reusable algorithms and code

[21:22] <fglock> ingy: ping

[21:26] <fglock> ingy: 'pmc_support' didn't work in v6 Makefile.PL - I'm reinstalling M::Install and M::Compile ...

[21:27] *** kanru joined
[21:31] <fglock> it works now - I had to remove ../../inc

[21:37] <fglock> now i've got to find out how to exclude files from precompilation

[21:37] <svnbot6> r12013 | fglock++ | v6 - added precompilation support to Makefile.PL (needs more work)

[21:39] <fglock> &

[21:39] *** fglock left
[21:49] <equinox5> bye

[21:50] *** dduncan joined
[21:51] *** fglock joined
[21:51] *** dduncan left
[22:00] *** Psyche^ joined
[22:00] *** dduncan joined
[22:08] *** weinig joined
[22:14] *** Psyche^ is now known as StudiesInWords

[22:19] <svnbot6> r12014 | fglock++ | v6 - added 'Quote' grammatical category

[22:21] *** hcarty left
[22:21] <svnbot6> r12015 | Sage++ | The -R option for translation (which makes minimal changes to regexs) is now functional, I'm also working on making it change captures too (which should make it a valid option for translation instead of a shortcut for code that doesn't use captures).

[22:21] <svnbot6> r12015 | Sage++ | Some functionality is in place for translating exports. The translator now knows which functions need to have "is export" added, but the actual translation doesn't happen yet.

[22:24] *** cjeris left
[22:32] *** StudiesInWords joined
[22:43] <svnbot6> r12016 | fglock++ | v6 - added ?\194?\171quotes?\194?\187 but Text::Balanced doesn't recognize it; needs some work

[22:43] *** frederico joined
[22:45] <svnbot6> r12017 | fglock++ | v6 - ':!a' adverbial pair

[22:56] *** Excedrin joined
[23:03] *** Bit-Man joined
[23:11] *** cm joined
[23:22] *** froh-doh joined
[23:24] *** fglock left
[23:24] <svnbot6> r12018 | fglock++ | v6 - non-working '=begin END', commented out

[23:28] *** lumi joined
[23:34] *** luqui joined
[23:34] *** mauke_ joined
[23:41] *** explorer__ joined
[23:43] *** theorb joined
[23:44] *** mauke_ is now known as mauke

[23:44] *** explorer__ joined
[23:46] *** weinig joined
[23:47] <svnbot6> r12019 | rodi++ | Tests for correct interpolation of whole hashes in double quotes.

[23:47] <cognominal> usr/bin/ld: warning multiple definitions of symbol _PC

[23:47] <cognominal> /usr/lib/gcc/i686-apple-darwin8/4.0.1/../../../libreadline.dylib(terminal.so) definition of _PC

[23:47] <cognominal> /usr/lib/gcc/i686-apple-darwin8/4.0.1/../../../libncurses.dylib(lib_tputs.o) definition of _PC

[23:47] <cognominal> /usr/bin/ld: warning multiple definitions of symbol _UP

[23:48] <cognominal> pugs does not like on my macbook to have both readline and libncurses installed :(

[23:50] *** jferrero joined
[23:53] *** vel joined
[23:54] *** Jackfrost joined
[23:55] *** theorb is now known as theorbtwo

[23:59] <audreyt> cognominal: it's just a warning

[23:59] <audreyt> feel free to ignore it

