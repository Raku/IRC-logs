[00:33] <metaperl> is Sam Vilain here? what handle does he go by?

[00:37] <dduncan> he goes by 'mugwump'

[02:05] *** avar\afk\woo is now known as avar

[05:05] <audreyt> rehi lambdacamels.

[05:05] <svnbot6> r8526 | audreyt++ | * It's 2006 now, so update copyright notice in README and Perl6::Pugs.

[05:05] <svnbot6> r8526 | audreyt++ | * Also add PArrows's copyright (BSD3) notice.

[05:08] <avar> oh shit

[05:08] <avar> I'm going to have to start updating my copyrightnotices too

[05:08] <tewk> audreyt: I've got a start to wsEnum, getting rid of typing errors

[05:11] <audreyt> tewk: ooh, cool

[05:11] <audreyt> eta of a commit? I'll do container types first then

[05:12] <tewk> 2-3 minutes

[05:13] <audreyt> woot

[05:13] <audreyt> tewk++

[05:13] * audreyt goes find some breakfast... be back in 2-3

[05:13] <audreyt> minutes, that is

[05:14] <tewk> Ok one type error left, how do I write an empty FastString ie ""

[05:15] <avar> mm

[05:15] <avar> do you know any tool that'll show you the main authors of code based on its CVS history?

[05:15] <tewk>     Couldn't match `[Char]' against `Char'

[05:15] <tewk>       Expected type: [[Char]]

[05:15] <tewk>       Inferred type: [Char]

[05:15] <tewk>     When checking the pattern: ""

[05:15] <tewk>     In the definition of `scan': scan "" _ = error "No closing ']>' for charlist"

[05:19] <tewk> wsEnum is going to have a scheme feel to it, I'm sure there is a better haskellized version.

[05:20] <tewk> Aw,  FastPackedString ""  ie empty

[05:22] <stevan> Happy New Year!

[05:23] <tewk> stevan: Happy New Year, are you on the east coast ?  two hours to go here.

[05:23] <stevan> tewk: yes I am :)

[05:23] * tewk cureses [Char] vs FastPackedString type errors :)

[05:39] <gaal> morning!

[05:41] <stevan> morning gaal 

[05:44] <gaal> avar: maybe not quite what you want, but see "svn praise" - shows you for each line as it is in a revision who made it.

[05:45] <gaal> tewk: still not working? "empty" it is

[05:47] <audreyt> rehi

[05:48] <audreyt> tewk: still blocking on something? :)

[05:48] <tewk> Well here it comes, I'm learning Haskell.  I've gotten to the point where it is starting to be fun and enjoyable, instead of painful.

[05:48] <audreyt> excellent

[05:48] <audreyt> I think the boxed ::Str type is going to be (Seq Char) for the time being

[05:51] <svnbot6> r8527 | tewk++ | src/Text/Parser/Rule.hs - First attempt at wsEnum

[05:51] <audreyt> (until someone hacks in a self-upgrading implementation for (Seq Word8) vs (Seq Char))

[05:51] <audreyt> ooh, tewk++

[05:51] * audreyt goes look

[05:51] <stevan> hey audreyt 

[05:51] <audreyt> stevan: hey. I've just reread S12

[05:51] <audreyt> looks like we are on solid grounds

[05:52] <stevan> audreyt: yes, i think so 

[05:52] <stevan> leo's stuff makes sense too

[05:52] <audreyt> I plan to hack in ::Args and ::Sigs

[05:52] <audreyt> so we can do

[05:52] <audreyt> $x := $y

[05:52] <stevan> cool

[05:52] <stevan> I have some questions re: ::Array 

[05:52] <stevan> got a sec?

[05:53] <audreyt> ::Sigs`create($x).BIND(::Args`create($y))

[05:53] <audreyt> sure, go ahead

[05:53] <tewk> Took me a while to figure out that "]>":xs should be ']':'>':xs.  Looking for constructive criticism.  I'm learning.

[05:53] <audreyt> ok.

[05:53] <audreyt>             scan empty        _   = error "No closing ']>' for charlist"

[05:53] <audreyt> s/empty/""/

[05:54] <audreyt> you are really operating on [Char] ehre

[05:54] <audreyt> and "empty"will just bind anything to the lex var "empty"

[05:54] <audreyt> instead of pattern pathing on the "empty" function

[05:54] <audreyt> s/pathing/matching/

[05:55] <tewk> yeah, that was a left over from debugging type errors, I had "" to start with

[05:55] <stevan> audreyt: this is what I have for ::Array.shift 

[05:55] <stevan> $elem := self`fetch_elem(0);

[05:55] <stevan>     self`store_list(self`fetch_list()`splice(1));

[05:55] <stevan>     $elem;

[05:55] <gaal> tewk: I think instead of ++ [ '\n' ] etc., you can say ++ "\n" instead

[05:55] <stevan> the first time I call it,.. i get back what I expect,.. the second time I call it I get a list of the remaining items

[05:56] <gaal> s,\S+$,,

[05:56] <stevan> it seems like store_list is not expecting a native list (i.e. - [ 1, 2, 3 ])

[05:56] <tewk> Because of "]>":xs, I got led astray debugging [[Char]] verses [Char] type errors.

[05:56] <gaal> since [ '\n' ] is a list of one char, that is, a string.

[05:57] <tewk> gaal: point well taken.

[05:57] <audreyt> stevan: store_list is expecting vararg... that's probably wrong

[05:57] <audreyt> fixing

[05:58] <stevan> audreyt: and it seems create expects this too,.. which is problematic when creating a new array like in map & grep

[05:58] <audreyt> aye, fixing both

[05:58] <stevan> audreyt: thanks :)

[05:58] <audreyt> hm

[05:59] <tewk> What is "\e" ?  is that a valid escape in haskell? Vim didn't syntax highlight it.

[05:59] <audreyt> ok, I'll make both array`create and hash`create expect a nativeseq.

[05:59] <stevan> shouldnt hash`create expect a native hash?

[06:00] <audreyt> but what about objects as keys?

[06:00] <audreyt> or do you think we special case them?

[06:00] <audreyt> by using subsequent .store calls?

[06:00] <audreyt> `store_elem, even

[06:00] <gaal> tewk: probably an "ESC" char

[06:00] <gaal> that's what it means in p5

[06:00] <stevan> hmm, I haven't gotten that far yet,.. I suppose native seq is okay for now

[06:01] <audreyt> otoh, we can make native seqs and maps autobox.

[06:01] <stevan> maybe

[06:02] <gaal> tewk: sorry to come out of context, but are you hiding Prelude.scan on purpose?

[06:02] <audreyt> gaal: "span"

[06:02] <stevan> unless that will affect the class/obj bootstrap code 

[06:02] <audreyt> it would not

[06:02] <gaal> audreyt: says "scan" in the code

[06:02] <audreyt> import Prelude hiding (lookup, null, drop, span, break, head, tail, splitAt)

[06:03] <audreyt> oh, you mean he redefined "scan"

[06:03] <tewk> scan is my little utility function.

[06:03] <gaal> audreyt: also the code has the sig for a scan func

[06:03] <stevan> audreyt: lets keep it simple for now, and not autobox

[06:03] <audreyt> stevan: ok

[06:03] <gaal> tewk: sure, there's a Prelude function of that name though

[06:03] <tewk> gaal: so should I rename mine or hid it in Prelude.

[06:03] <audreyt> stevan: so, I need some sanity checking on the vararg thing

[06:04] <stevan> ok

[06:04] <audreyt> stevan: two choices: either all objprims take fixed number of args

[06:04] <audreyt> or we introduce slurpy forms to PILN

[06:04] <audreyt> so you can say $obj.method(*@foo)

[06:04] <stevan> I think a fix num is probably better

[06:04] <gaal> tewk: I suppose the compiler doesn't give a warning cause this isn't a top-level func

[06:04] <stevan> at this level that is

[06:04] <audreyt> ok

[06:05] <gaal> oh actually it isn't the same sig as the prelude scan

[06:05] <gaal> @typeof scan

[06:05] <gaal> grrrr, the prelude has "scanl" etc., not scan

[06:05] <gaal> and we don't have lambdabot here

[06:05] <gaal> scanl :: (a -> b -> a) -> a -> [b] -> [a]

[06:06] * gaal makes a note to put a lambdabot in the channel

[06:06] <gaal> scan is like a fold with yields sprinkled in it.

[06:06] <tewk> On another import issue: I added qualified Prelude imports of head, init, tail, last should I remove.  Should I remove head and tail from the prelude hiding clause on the line above?

[06:07] <gaal> one thing you can do is "import qualified"

[06:07] <gaal> why are you hiding the prelude though? because of faststring?

[06:07] <gaal> then import faststring qualified :-)

[06:07] * tewk would love and abuse a lambdabot, especially if it knew about pugs types also :)

[06:07] <gaal> note there are two "import Data.FastPackedString"

[06:07] <gaal> lines in that file

[06:08] <gaal> -- This module is intended to be imported @qualified@, to avoid name

[06:08] <gaal> -- clashes with Prelude functions.  eg.

[06:08] <gaal> -- >  import qualified Data.FastPackedString as P

[06:09] <audreyt> tewk: it works!

[06:09] <tewk> I gently massaged the imports for Prelude GHC.List functions, the rest is pre-tewk

[06:09] <gaal> then unqualified access resolves to prelude, and P.concat etc. gives you the FastString version.

[06:09] <gaal> tewk: right (but there should still only be one import declaration for that module :-)

[06:09] <tewk> audreyt: quick bug fix/cleanup checkin comming

[06:09] <audreyt> tewk: we are likely to conflict

[06:09] <audreyt> please sync r8528 first

[06:09] <tewk> I will update first and resolve

[06:09] <audreyt> ghci -isrc src/Text/Parser/Parser.hs  src/cbits/*o

[06:10] <tewk> audreyt: Cool :)

[06:10] <audreyt> *Text.Parser.Parser> parseRule "<-[abc]>"

[06:10] <audreyt> RTerm (TermEnum (EnumComplement (EnumChars "abc")))

[06:12] <svnbot6> r8528 | audreyt++ | * enum parsing -- we need to change "scan" to something

[06:12] <svnbot6> r8528 | audreyt++ |   more FastPackedString-ish instead of doing the heavy pack/unpack,

[06:12] <svnbot6> r8528 | audreyt++ |   but this works for now.

[06:13] <tewk> audreyt: I just kinda figured out the FastPackedString-ish vs String.  I can convert it.

[06:14] <gaal> tewk: sorry to bug you about this, but the high-level signature and the type of scan don't agree

[06:14] <gaal>             -- scan :: Input -> enumList -> enumList

[06:14] <audreyt> cool! just make use of FPS functions, like "span"

[06:14] <gaal>             -- scan :: Str -> [Char] -> ( [Char], Str )

[06:14] <tewk> gaal: fix coming

[06:15] <gaal> audreyt: that there are "error"s and not "fail"s in the code means it dies on errors uncachably, no?

[06:18] * stevan has to go to sleep before he falls over 

[06:18] <stevan> audreyt: I will work on Roles more tomorrow (~10 hours from now)

[06:18] * gaal outrageously has to go to $work

[06:18] <stevan> or rather Array and Hash roles

[06:19] <stevan> nite all, and happy new year

[06:19] * stevan &

[06:20] <tewk> gaal: Is it possible to combine lines 6 & 7 into one line without qualifing all of Prelude,  I'm not in the mood to go through the entire file and find every unqualified use of Prelude :)

[06:21] <gaal> tewk: qualify FastPackedString :)

[06:21] <gaal> leave prelude unqualified

[06:22] <audreyt> stevan: fixed

[06:22] <audreyt> gaal: no, you can catch them in the IO monad... but it should be converted to "fail" in the Maybe monad

[06:23] <audreyt> tewk: I've already qualified FPS as "Str"

[06:23] <svnbot6> r8529 | audreyt++ | * Instead of variadic arguments, ::Array`create and ::Hash`create

[06:23] <svnbot6> r8529 | audreyt++ |   now accepts a single argument (either a NativeSeq, or a NativeMap

[06:23] <svnbot6> r8529 | audreyt++ |   that will be flattened into a NativeSeq).

[06:23] <svnbot6> r8529 | audreyt++ | * Same goes for store_list.

[06:24] <tewk> audreyt:  there are two import of FastPackedString,  I'll try commenting out the unqualified one and see what happens.

[06:25] *** waltz is now known as walterbrunswick

[06:25] <audreyt> tewk: the reason why I hid most of prelude list functions

[06:25] <gaal> urp, an efficient FPS version of this isn't trivial at all

[06:25] <audreyt> is becase in Text.Parser.Rule it makes sense to only use FPS functions for tokenizing

[06:26] <audreyt> give me 5 minutes... I'll demo what I mean :)

[06:26] <tewk> Yep about 60 Not in scope errors.

[06:27] *** walterbrunswick is now known as waltz

[06:27] <tewk> audreyt: Is it ok if I try to qualify them ( the 60 not in scope errors)  That was gaal's idea, or should I convert wsEnum to FPS tokenizing first ?

[06:27] * gaal has bad ideas sometimes :)

[06:28] <audreyt> tewk: I've almost finished FPSizing wsEnum

[06:28] <audreyt> give me a few mins

[06:28] <tewk> Sorry I probably didn't make it clear.  I Could see that either way there was going to be a lot of qualifing to do.

[06:29] <tewk> It is so nice to have an audreyt around to fix everything,  she probably could have written wsEnum in 1/100th of the time it took me.  But it was a good learning exercise.

[06:30] <tewk> Mostly in learning haskell.  The version I came up with was elegant, I thought.  Much more simpler and easier to understand than PIR.  I'm sure FPSizing will make it not only elegant but performant.

[06:31] <tewk> Gotta love functional programming.  Once you get it,  things (such as tokenizing and parsing) become so much more consice.

[06:31] <avar> gaal: I found a tool..;)

[06:32] <avar> statcvs.sf.net

[06:32] <gaal> avar: cool!

[06:32] <audreyt> tewk: no, I couldn't have written in 1/100th of time, because 99% of it will be spent on reading PIR :)

[06:33] <tewk> I spent a lot of time reading pir too.  I've dabbled with a python compiler for PIR, so the PIR made some sense.

[06:33] <avar> now I just have to battle with sourceforge cvs ...

[06:35] * gaal wonders if the next version of the haskell spec will allow ("hello ":xs) patterns

[06:35] <avar> make is such a drag

[06:35] * avar just wrote a makefile in bashscript

[06:36] <tewk> gaal: the current version does it just types it as [[Char]] instead of [Char].  That confused me quite a bit.

[06:37] <gaal> "hello":xs doesn't make sense as syntax. but maybe "hello"++xs ?

[06:37] <tewk> can you use "hello"++xs in matching?  that was what I was trying to do.

[06:38] <tewk> That what they should add ++ in matching, I got it.

[06:38] <gaal> tewk: I don't think so. I realize why "str":xs won't work. I think I learned the hard way, like you :)

[06:38] <gaal> shower &

[06:38] <audreyt> ..done

[06:38] <audreyt> committing

[06:39] <gaal> ooh

[06:40] <tewk> gaal: Nice to know other like to learn the hard way.

[06:40] <tewk> s/other/others/

[06:41] <gaal> not sure about the "like"... wait till you get to monads :)

[06:41] <gaal> bbiab(fab)

[06:42] <tewk> I'm in the middle of "getting" Monads (the hard way),  Which is the only way you "get" monads I believe.

[06:43] <tewk> :)

[06:45] <tewk> My thesis takes advantage of looking at list comprehensions as monads, but when it comes to using/understanding them in Haskell, I have a long ways to go.

[06:46] <audreyt> r8530 :)

[06:47] <svnbot6> r8530 | audreyt++ | * Convert tewk++'s wsEnum scanning routine to FPS.

[06:47] <svnbot6> r8530 | audreyt++ |   Note that we'll need a postprocessing step in _Enum this way.

[06:48] <audreyt> the \w etc in Enum needs to be converted to EnumShortcut

[06:48] <audreyt> so we need a postprocessor in _Enum anyway

[06:49] <audreyt> but it doesn't belong (yet) in scanning

[06:49] <audreyt> which is just charged to return Maybe (Str, Str) -- i.e. the matched and remaining parts

[06:49] <audreyt> so doScan should do one thing, and _Enum takes over the rest

[06:50] <audreyt> also note the "do" notation for Maybe monads^Wactions

[06:50] <audreyt> in line 439, if doScan returns Nothing (i.e. if it "fail"s)

[06:50] <audreyt> then wsEnum will just return Nothing

[06:50] <audreyt> in line 444, the "return" is converted into a Just.

[06:52] * tewk looking

[06:52] <Aankh|Clone> A (belated|early) Happy New Year, #perl6. :-)

[06:52] *** Aankh|Clone is now known as Aankhen``

[06:54] <audreyt> Aankhen``: you too :)

[06:54] <Aankhen``> Hmm, come to think of it, "early" is probably no longer necessary.

[06:59] <svnbot6> r8531 | audreyt++ | * remove of hardcoded "empty" cases in FPS because it

[06:59] <svnbot6> r8531 | audreyt++ |   throws off our positional-based scanning.

[06:59] <svnbot6> r8531 | audreyt++ | * tidying up T.P.Rule's imports.

[07:02] <gaal> what's idx?

[07:03] <gaal> ah ok it's a FPS thing

[07:04] <gaal> where does metachar expansion happen?

[07:04] <gaal> the _Term stuff?

[07:06] * gaal feels a great kinsmanship with asavige, Alias_ etc.

[07:07] <gaal> It is 1 January and I am wearing a t-shirt

[07:07] <gaal> $work &

[07:08] <audreyt> :p

[07:08] <audreyt> gaal: _Enum will handle expansion

[07:08] <audreyt> doesn't now, but should do

[07:09] <tewk> So idx is the position of a "substring" FPS in its parent string?

[07:09] <audreyt> yup

[07:09] <audreyt> same as SvIVX inperl5

[07:09] <svnbot6> r8532 | audreyt++ | * minor adjustments to miniLang grammar -- it compiles!

[07:10] <audreyt> are you up to handle the _Enum expansion?

[07:12] <audreyt> mostly converting "ab]-[a" into EnumMinus (EnumChars "ab") (EnumChars "a")

[07:12] <audreyt> which makes "]-[" almost like an infix operator -- so maybe define another opTable to parse that. hmm. or just use traditional scanning

[07:12] <audreyt> I'll brb

[07:13] <tewk> So what does wsEnum do?

[07:15] <audreyt> it takes an input string

[07:16] <audreyt> and maybe returns a pair of strings

[07:16] <audreyt> the one consumed (And to be post processed by _Enum)

[07:16] <audreyt> and the one to continue parsing

[07:16] <tewk> I got that.  

[07:16] <tewk> Are you just throwing away escapes \n right now?

[07:16] <audreyt> _Enum in turn takes the FPS that's consumed

[07:16] <audreyt> not throwing away... putting them into consumed list

[07:17] <audreyt> because \n handling is going to be different from \w

[07:17] <avar> http://tools.wikimedia.de/~avar/COPYING ;)

[07:17] <avar> I wonder how hard it is to obtain OSI certification

[07:17] <audreyt> and wsEnum is not the place to do that

[07:17] <tewk> so all wsEnum does is get the substring that represents the Enum

[07:17] <audreyt> yup

[07:19] <tewk> Ok, head str == '\\' = doScan (drop 2 str)   consumes escapes so that \] doesn't terminate the Enum

[07:19] <audreyt> yup

[07:30] <svnbot6> r8533 | audreyt++ | * compilation for TermEnum.

[07:36] <svnbot6> r8534 | audreyt++ | * better error message prettyprinting for negative assertions.

[07:38] <tewk> audreyt: Sorry wife got home from work in the ER.  so what does ws in wsEnum mean? whitespace?

[07:41] <audreyt> yeah, PIR legacy

[07:41] <audreyt> feel free to rename it

[07:45] <gaal> audreyt: so, re .yaml emitting. how much sense does it make to acummulate the emitted string with a FPS?

[07:51] <gaal> and, how do you suggest getting over the circular dependency of Prim.Yaml and Data.Yaml.Syck?

[07:52] <gaal> tewk: must have been a busy shift!

[07:54] <Alias_> gaal: "Kinsmanship?"

[07:54] <gaal> it's like summer

[07:54] <Alias_> You mean in that I have NFI what is going on?

[07:54] <Alias_> oooohhh

[07:54] <Alias_> heh

[07:54] <audreyt> gaal: it may make some sense, but a dedicated self-extending buffer may be more eficient

[07:55] <audreyt> gaal: what circular dep?

[07:55] <Alias_> ugh

[07:55] <Alias_> I just got to my office and it's 35-40 degrees in here

[07:55] <Alias_> Nobody has been here all day, and the air-con hasn't kicked in yet

[07:56] <gaal> audreyt: the emitter callback gets some sort of Val node and recurses into it, but how does it know about Val? You suggested a Val->SyckNode (or YamlNode) function, but how to import it?

[07:57] <audreyt> gaal: Val->SyckNode is defined in D.Y.S

[07:57] <audreyt> er I mean

[07:57] <audreyt> in P.P.Y

[07:57] <audreyt> and P.P.Y hands off the finished SyckNode to DYS

[07:57] <gaal> Alias_: you count in Celsius! yay

[07:57] <audreyt> which doesn't have to know PPY

[07:57] <gaal> audreyt: but does that map a whole tree or just this one node?

[07:57] <Alias_> gaal: hmm? of course. Only the US counts in crazy numbers any more

[07:59] <gaal> audreyt: mapping a tree would mean two recursions. maybe that's okay...

[08:00] <gaal> but doesn't that imply making a copy of the data?

[08:01] <audreyt> gaal: we need to make copies anyway

[08:02] <audreyt> gaal: the whole tree, when mapped lazily, only copies once

[08:02] <audreyt> so there's no loss

[08:02] <gaal> okay. so..

[08:02] <gaal> toYaml :: Val -> Eval YamlNode

[08:02] <gaal> ?

[08:03] <gaal> can I get rid of the Eval there?

[08:04] <audreyt> prolly not if you are to follow VRef

[08:04] <gaal> how do I hand that to D.Y.S then?

[08:05] <gaal> well, I do have

[08:05] <gaal> dumpYaml v = do { obj  <- toYaml =<< fromVal v ; rv   <- liftIO (emitYaml obj) ; {- error handling -} }

[08:05] <gaal> so maybe that's okay?

[08:06] <audreyt> yup

[08:06] <gaal> YamlNode needs an Undef (or is that subsumed under Scalar?)

[08:06] <gaal> err, Str

[08:07] <gaal> (Str!?)

[08:08] <audreyt> hmm?

[08:08] <audreyt> YamlNode is currently using a [Char]

[08:08] <audreyt> that may need to change in the future

[08:08] <gaal> undef.yaml => "~"

[08:08] <gaal> "~".yaml => "'~'"

[08:09] <gaal> how does YamlNode represent undef?

[08:10] <audreyt> YamlUndef would do

[08:10] <audreyt> a new node

[08:10] <audreyt> or YamlNil

[08:11] <gaal> also, eval<yaml> is buggy in deserializing ~ :-)

[08:11] <gaal> yeah, adding that.

[08:13] <gaal> gee, I make dyslectic abbreviations

[08:13] <gaal> eval ... :lang<yaml>

[08:18] <svnbot6> r8535 | asavige++ | Haskell versus madgolfer, round one to Haskell overwhelming madgolfer's pea brain with a withering barrage of PhD-powered Greek letters and arcane-in-the-extreme terminology (damn you audrey;-)

[08:19] <Alias_> heh

[08:21] <audreyt> asavige: hey!

[08:21] <gaal> yeah, well sometime this year I will have to grok the overly implicit fix, "y f = f (y f)"

[08:22] <Alias_> asavige: You know of course have to explain that checkin comment :)

[08:22] <asavige> hi audrey, I'm exhausted from 40 degree heat and learning haskell

[08:22] <asavige> Alias_: The Haskell community seems full of academics and they love to invent arcane

[08:23] <Alias_> "full of"

[08:23] <asavige> terminology that I find exhausting to grok

[08:23] <Alias_> I'd say, "consists only of"

[08:23] <asavige> oh and they love to use greek letters

[08:23] <Alias_> Haskell is indeed mind-twisting

[08:23] <asavige> anyway it's been fun, for some definition of fun actually it's become a vendetta

[08:24] <Alias_> I tried for 3 hours then realised it was making my head hurt so much I'd put it aside until I had something useful to do with it

[08:24] <gaal> Alias_: I'd say "consists in", because that's a very academic golfage.

[08:24] <Alias_> And audreyt's Haskell talk is WAY more understandable than most of the online things

[08:24] <Alias_> gaal: Fair enough

[08:25] <asavige> despite that, my examples/rpn/hask program seems to now be working just like the Perl versions ^.^

[08:25] <asavige> though the style is probably all wrong and I have something I don't understand, might goto #haskell

[08:26] <gaal> goto #haskell? I think they use cps when they want to do that...

[08:26] * gaal stops being silly for a moment

[08:27] <gaal> (maybe that's how I should have spent my leap second)

[08:33] <azuroth> ?eval {"a" => b.

[08:33] <azuroth> ?eval {"a" => "b"}.yaml

[08:34] <pasteling> "gaal" at 192.115.25.249 pasted "src/Pugs/Prim/Yaml.hs:49:23: C" (13 lines, 424B) at http://sial.org/pbot/15197

[08:34] <gaal> oops, sorry, forgot a --message. why does it infer [[b]] ?

[08:35] <gaal> azuroth: not yet, working on it.

[08:36] <azuroth> bah, it should be finished. you've had how many public holidays lately to work on it? :-)

[08:37] <gaal> not I

[08:37] <gaal> no holiday here unless you go to school

[08:38] <Alias_> where's here?

[08:38] <Alias_> Israel?

[08:38] <gaal> yeah

[08:39] <Alias_> They don't give you the day off for Christmas? </american>

[08:39] <Alias_> (heh)

[08:39] <Alias_> Although do you have colliding holdays in there anywhere?

[08:40] * gaal tends not to notice holidays until someone greets him with a blessing, anyway

[08:43] <gaal> audreyt: what's wrong with this? http://sial.org/pbot/15197

[08:44] <gaal> and: I don't need to do TVar stuff when emitting, do I?

[08:44] <audreyt> gaal: fmap YamlSeq (mapM toYAML items)

[08:45] <audreyt> you are using mapM as a pure value, that doesn't work

[08:45] <audreyt> look at .perl implementation for some guidance

[08:45] <gaal> oooh a cargo cultist like myself should benefit from anthropology!

[08:50] <audreyt> hm, in "http://www.oreillynet.com/pub/wlg/8894" chromatic claims:

[08:50] <audreyt> As of the last report, Patrick's code can parse Perl 6 expressions. 

[08:50] <audreyt> I can't find that in the parrot tree.

[08:51] <audreyt> maybe I should go asking in #parrot.

[08:59] <gaal> argh. undefined errors on DataziFastPackedString_PS_con_info etc. audreyt, what's the right place to add deps+libss in the makefile now? it's gotten a little confusing.

[09:29] <audreyt> tewk: your grammar worked beautifully :)

[09:30] <audreyt> * Text.Parser.PArrow: Finish negated charset support.

[09:30] <audreyt> * PIL.Native.Parser: the main "<expression>" rule in miniLang grammar now works correctly, after removing some left recursions. Now we just need to translate them back...

[09:30] <audreyt> (r8536)

[09:31] <tewk> audreyt: Good

[09:31] <tewk> Can you explain   ++ noWs (op (_Enum EnumChars)                    Term "<[" wsEnum) , I'm trying to understand the sturcture.

[09:32] <tewk> What is Term, where is it defined?  is it a type constructor?

[09:32] <audreyt> yes

[09:33] <audreyt> ok, you are going to see some magic.

[09:33] <audreyt> line 66 in src/Text/Parser/OpTable.hs

[09:33] <audreyt> that line simply means

[09:33] <audreyt> --- parse the Term "<[", if it matches, hand the rest to wsEnum to see if it actually matches

[09:33] <audreyt> if wsEnum rejects it, pretend we've never seen "<["

[09:34] <audreyt> it's all controlled by the "op"function

[09:34] <audreyt> which takes an variadic number of arguments

[09:34] <audreyt> and depends on their type, combine them in interesting ways

[09:34] <audreyt> and contrary to popular belief, haskell does have variadic functions

[09:35] <audreyt> see line 413 and below of OpTable.hs for the implementation.

[09:35] <audreyt> asavige: Rpn.hs is quite nice :)

[09:36] <asavige> audreyt: thanks, next step is to learn about Parsec I guess

[09:36] <asavige> oh and grok monads (i've started on that)

[09:36] <audreyt> cool... there is also this shiny new parser on the block :)

[09:36] <audreyt> (Text.Parser.Rule and Text.Parser.OpTable)

[09:47] <audreyt> hm, we need a p6rule.vim

[09:49] <tewk> Thant all made sense, now I just want to find where the pieces come from.  Term for example,  Optable:117 ? if so why Term and not MkTerm?

[09:50] <audreyt> Term is a pun

[09:50] <audreyt> used as a function, it's a data constructor

[09:50] <audreyt> Term :: Str -> Op

[09:50] <audreyt> used as a type, it's a newtype that's isomorphic to a Str.

[09:51] <audreyt> I think I should rename the latter to "Name" or "Lead" or something

[09:51] <tewk> So which is it in Term "<[" wsEnum)

[09:52] <audreyt> the function one

[09:52] <audreyt> I'll commit the rename

[09:53] <tewk> Thanks for answering the questions, I know it's impossible to keep naming clear,  it just makes me feel better when the answers to my confusion are followed by, "That should be renamed" :)

[09:53] <audreyt> :D

[09:53] <audreyt> again, it's legacy from PIR

[09:53] <audreyt> PGE/OpTable.pir uses the "term" name for 3 different things

[09:53] <audreyt> so I was confused myself

[09:56] <audreyt> committed

[09:57] <tewk> Yeah, I've picked up that a lot of this comes from PIR, I have just been slow to inflict that pain on myself,  especially since you have already paid the price

[09:57] <svnbot6> r8537 | audreyt++ | * Text.Parser.OpTable: rename the very confusing "Term" 

[09:57] <svnbot6> r8537 | audreyt++ |   type to the mor appropriate "TokenName".  Reported by tewk++.

[09:57] <svnbot6> r8538 | audreyt++ | * OpTable: fix a couple minor warnings.

[09:58] <audreyt> indeed... so refactoring much welcome

[09:59] <tewk> Well, I think I'm a couple of days out, from really getting my head around this, but once I do I'll pitch in more.

[10:01] <audreyt> that'd rock

[10:01] <audreyt> I've moved the grammar to src/PIL/Native/Native.grammar

[10:01] <audreyt> any .vim-proficient people around?

[10:03] <Alias_> audreyt: How do you currently deal with releasing

[10:03] <svnbot6> r8539 | audreyt++ | * factor our the PIL^N grammar into src/PIL/Native/Native.grammar.

[10:03] <audreyt> Alias_: of pugs?

[10:03] <Alias_> audreyt: I imagine you must build packages where not all tests pass

[10:03] <Alias_> of pugs will do

[10:03] <audreyt> Alias_: I TODO the tests.

[10:03] <Alias_> So makedist requires that all tests pass?

[10:03] <Alias_> wait, this isn't really a problem

[10:03] <Alias_> never mind

[10:04] <audreyt> :)

[10:04] <Alias_> It just occured to me that if you checkout a svn snapshot and it fails on YOUR computer, why would you send it to be mass tested on other environments

[10:04] * audreyt is written a grammar file to parse a grammar file... mmm bootstrapping

[10:04] <Alias_> Although maybe in your specific case you do want some idea about which tests fail on different platforms

[10:04] <audreyt> s/written/writing/

[10:04] <audreyt> Alias_: yes.

[10:05] <audreyt> different GHC versions, perl versions, etc

[10:05] <Alias_> So is the TODO needed to make tardist, or just so that people don't think it's failing

[10:06] <audreyt> the latter I think

[10:06] <svnbot6> r8540 | audreyt++ | * rename the grammar file to a more descriptive "Syntax.grammar"

[10:06] <svnbot6> r8541 | audreyt++ | * more tidying up of PIL.Native.Syntax

[10:07] <Alias_> hmm. OK, so in that case I imagine it wouldn't be too hard to write a SVN -> testing connector

[10:07] <audreyt> *nod*

[10:08] * Alias_ ticks off that item and goes back to writing PITA::Scheme::Perl5::Make

[10:10] <tewk> audreyt: Syntax.grammer -- very nice, I knew there was something like [ ]? , I should have gone and looked at S05 again, Looks nice.

[10:11] <audreyt> :D

[10:11] <audreyt> rule expressionList     { <expression> [; <expressionList> | ;? ] }

[10:11] <audreyt> also this handles trailing semicolons

[10:12] <audreyt> hm, I guess we really want :ws.

[10:12] <audreyt> :w, rather

[10:14] * Debolaz watches an MSN window using 3 minutes to open when burning someting with his crappy burner.

[10:14] <nothingmuch> happy new year

[10:15] <audreyt> happy new year, nothingmuch

[10:15] <Alias_> and to you my crazy israeli friend

[10:15] * nothingmuch makes releases of the new C::P::Session stuff

[10:15] <nothingmuch> oh wait, wrong channel

[10:16] <Alias_> yes, much too boring and non-insane for this channel

[10:16] <nothingmuch> audreyt or Alias_: since you have a billion modules, do you have a tool to diff a CPAN release with pwd?

[10:16] <Alias_> pwd?

[10:16] <nothingmuch> present working directory

[10:17] <Alias_> I commit a copy of every tarball to my /releases directory before I upload

[10:17] <Alias_> So I tend to just untar, and then diff to pwd

[10:18] <Alias_> It's not automated, but it's like 3 commands

[10:18] <nothingmuch> oh right, /branches

[10:18] <Alias_> Well, I keep the ACTUAL tarball, since I don't believe in SVN branches

[10:18] <nothingmuch> since i have trunk in my pwd directly, and not root, i keep forgetting it

[10:18] <nothingmuch> how come?

[10:18] <audreyt> ...and I just use svk.

[10:18] <Alias_> It's just a copy

[10:18] <audreyt> svk ci --import

[10:18] <nothingmuch> audreyt: explain?

[10:19] <Alias_> svn implements branches partly in wetware

[10:19] <Alias_> And I don't trust wetware

[10:19] <nothingmuch> wetware?

[10:19] <audreyt> Alias_: I talked with clkao and svk will get the ability of per-subdirectory properties that declares tagness, branchness, viewness, etc

[10:19] <Debolaz> Alias_: Err... how is that? :)

[10:19] <audreyt> Alias_: so the software will enforce wetwar econstraints

[10:19] <audreyt> wetware, even

[10:19] <Alias_> nothingmuch: "wetware" is that stuff in your skull... that's wet

[10:19] <nothingmuch> oh

[10:20] <Alias_> Debolaz: It's just a copy

[10:20] <Debolaz> Alias_: I kinda figured... but how is this a bad thing I mean?

[10:20] <Alias_> If I give you a value, you cannot write a function that verifies what I give you as a branch

[10:20] <Alias_> That it's a "branch" only exists in your head

[10:20] <Alias_> As far as the computer is concerned, you just copied your project

[10:21] <Alias_> Ditto tags

[10:21] <Alias_> But even more so

[10:21] <Debolaz> Again, why does the VCS need to keep track of what's a branch, what significant disadventage does it have to keep branches as directories? 

[10:21] <Alias_> From the documentation... "A tag is also just a copy. Unless you change it, in which case it becomes a branch"

[10:21] <Alias_> Debolaz: You can't verify them

[10:21] <Debolaz> Looking for a VCS myself, I'm somewhat interested in this. :)

[10:21] <Alias_> If you can't identify something as a branch, is it a branc?

[10:21] <audreyt> nothingmuch: svk ci --import --to-checkout //tmp/foo .

[10:21] <nothingmuch> i actually like this flexibility

[10:22] <nothingmuch> in darcs and svk

[10:22] <Alias_> Basically, SVN is a versioning remote filesystem

[10:22] <nothingmuch> to-checkout is not documented in my svk help ci

[10:22] <Debolaz> Alias_: But why is this neccesary to have in software? It could just be kept in document, or you could use naming conventions. 

[10:22] <Alias_> SVK is a VCS implemented using the SVN versioning filesystem

[10:22] <Alias_> Debolaz: Say I want to write a SVN client

[10:23] <Alias_> And I want it to identify all the branches in your repository, so I can understand what work you are doing

[10:23] <Alias_> Well you can't do that

[10:23] <Alias_> Not robustly... you can guess and hope

[10:24] <Debolaz> Alias_: I still don't see this as a significant problem, more a matter of project policy... but then again, I do not claim to be any expert on this so there may be something I'm not seeing. :)

[10:24] <Alias_> Policy is wetware

[10:24] <tewk> Convention vs Configuration,  Convention wins again.

[10:24] <Alias_> It relies on people to not be stupid

[10:24] <Debolaz> I guess advisory metadata wouldn't hurt though.

[10:24] <Alias_> I'll give you a concrete example

[10:24] <Alias_> My standard one

[10:24] <Alias_> I used to work at Cisco in a development centre

[10:24] <Debolaz> Alias_: I have never ever encountered such a problem myself anyway. In real life that is.

[10:25] <Alias_> As part of that work, we had some projects being done in India by outsourcers

[10:25] <Alias_> Who we could pretty much rely on to do stupid things from time to time

[10:25] <Alias_> As you can with any outsourcing company

[10:25] <Alias_> The number one problem was related to releases

[10:26] <Alias_> They would send us a release, we would release it, and then we'd send bug reports

[10:26] <Alias_> They'd say "which version", and then a whole $thing would ensue whereby they could replicate the original version

[10:26] <Alias_> Because they were either using no version control, or shit version control

[10:26] <Alias_> So we instituted a policy after 3 or 4 projects had these problems...

[10:27] <Alias_> You MUST use CVS, and all releases were to be in the form of a CVS tag

[10:27] <Alias_> Don't send us the code, send us a repository tag

[10:27] <audreyt> ...and to set up this constraint in SVN would require WebDAV-based control, or pre-commit hooks, which is a bit more complicated than in CVS.

[10:27] <Alias_> We'll export direct from your CVS at that tag, and deploy it

[10:27] <Alias_> wait wait...

[10:27] <Alias_> Complication isn't the problem

[10:28] <audreyt> you can set up so they can only copy into a tag and never commit into tags.

[10:28] <nothingmuch> Alias_: how does a VCS stop you from makking e.g. '@hourly   cd $project; vcs commit -m "hourly commit"' in your crontab?

[10:28] <nothingmuch> how does a vcs force you to write good code?

[10:28] <Alias_> What the policy we instituted did was it meant that EVEN THOUGH we didn't trust the outsourcers, we could trust the CVS software

[10:28] <nothingmuch> split it into files

[10:28] <Debolaz> But I don't see how naming conventions wouldn't solve this. For instance, having /branch/blah and /tag/blah. Or /blah-branch or /blah-tag. You could implement this with metadata to aid automated clients of course, but it doesn't seem neccesary when the functionality you'd get wouldn't be neccesary with naming.

[10:28] <nothingmuch> at the very least

[10:28] <nothingmuch> you need to rely on people at some point

[10:28] <Alias_> Debolaz: Those naming conventions only exist in wetware.

[10:28] <Alias_> No you don't

[10:29] <audreyt> Debolaz: Alias_ is relying on the constraint that you can't modify a tag in CVS once it's done.

[10:29] <nothingmuch> and increasing software complexity because people are generally stupid is not a good strategy

[10:29] <Alias_> nothingmuch: The entire point was we didn't

[10:29] <Debolaz> Alias_: But it would be the same concept as enforcing a certain use of CVS.

[10:29] <nothingmuch> you just get complex software, that will still get abused =)

[10:29] <Alias_> With CVS, you have to be intentionally destructive to break the tagging

[10:29] <audreyt> Alias_: if you've set up the WebDAV or pre-commit server yourself, you can too block inadvertant commits into tags/ space.

[10:29] <Alias_> That's fine, we can live with that. You can never stop that sort of thing

[10:30] <Alias_> audreyt: So you are asking Cisco to give every single outsourcer access to the crown jewels

[10:30] <audreyt> Alias_: I do not follow that

[10:30] <audreyt> what has that to do with this?

[10:30] <Alias_> maybe I'm reading you wrong

[10:30] <audreyt> you can limit their GET access to only /project/*

[10:30] <Alias_> The problem with conventions is they aren't envorcable

[10:31] <audreyt> and COPY access to /project/tags/

[10:31] <Alias_> audreyt: NOBODY outside the company gets access to the multi-gigabyte Cisco repositories

[10:31] <audreyt> and disallow anything else in /project/tags/

[10:31] <Alias_> They won't even let you in the firewall

[10:31] <audreyt> Alias_: that's fine, you can set up a small svn where your cvs currently is

[10:31] <Alias_> Imagine allowing 400 companies all around the world access to the internals

[10:31] <audreyt> Alias_: basically I'm saying whatever you are using CVS currently for, you can use SVN with a bit more configuration.

[10:32] <Alias_> Every sane implementation of SVN I've heard of involves big doses of CYJ

[10:32] <Alias_> But we didn't use CVS

[10:32] <audreyt> CYJ?

[10:32] <Alias_> Can't You Just

[10:32] <Alias_> ask purl

[10:32] <audreyt> right. I do agree it's more complicated than it should.

[10:32] <Alias_> Again, we didn't use CVS

[10:32] <Alias_> We just required the outsourcers did

[10:32] <Alias_> And that was enough

[10:33] <Alias_> They give us a tag, we check it out, we deploy, done

[10:33] <Debolaz> It's a bit more complicated, but when you're doing more complex tasks, it's actually a lot easier than with other similar systems.

[10:33] <Alias_> We didn't need to send security experts for site audits to definitively prove that they had SVN set up correctly

[10:33] <Alias_> How do you know if $outsourcer has set up SVN they way you dictate

[10:34] <Alias_> You don't, unless you do expensive crazy things

[10:34] <Alias_> You have to trust the people, and that's a bad thing

[10:34] <Alias_> With "real" tags, you don't

[10:34] <Alias_> You trust the VCS

[10:34] <nothingmuch> so why did you guys not use a "real" VCS?

[10:34] <Alias_> CVS is a real VCS

[10:34] <nothingmuch> i meant commercial that isn't source safe

[10:35] <nothingmuch> ack

[10:35] <Alias_> Because everybody had CVS?

[10:35] <nothingmuch> my gpg pubring file was corrupted

[10:35] <Alias_> We'd have to force all 400 contractors to use some particular VCS, and not their own

[10:35] <Debolaz> Alias_: It seems to me that the original problem you described doesn't require that particular solutions (It's just one solution), however, the problem you describe now arrises from assuming this is the only solution... ?

[10:35] <Alias_> And make them pay for azillion licenses

[10:36] <Alias_> Yes, it's just one solution

[10:36] <Alias_> But it was cheap, and it worked

[10:36] <Alias_> And you can't do anything with SVN to make a solution

[10:36] <Alias_> Although this concept of pseudo-tags seems decent enough

[10:36] <Alias_> path + repo version

[10:37] <Alias_> ignore SVN's "tags" and apply your own version

[10:37] <Alias_> hence, I consider SVN's tags not to be "tags"

[10:37] <Alias_> And why I say they are implemented in wetware

[10:38] <Alias_> Making your version control rely on people to not be stupid is a silly idea

[10:38] <Alias_> Anyways, I'm babbling

[10:38] <Alias_> SVK is something closer to the right approach

[10:38] <Alias_> Using SVN as a "version control driver" and implement the actual VCS on top of it

[10:38] <Debolaz> Well, you made me think about this. :)

[10:39] <Alias_> The basic summation is that Version Control is a protection against stupidity

[10:40] <Alias_> And an anti-stupidity scheme that just says "don't be stupid" is no protection at all

[10:41] <Alias_> Also, I'm something of a zealot on this idea, since I've hit problems with it in real life

[10:41] <Debolaz> I see the problem, enforcing a certain development policy without a lot of hazzle. And CVS "just worked" for this task... but I think this is a special case, which doesn't make SVN any worse for general usage since you can enforce a policy with it, you just can't do it as easy as with CVS. Which usually doesn't create problems, except when you have a lot of small third parties with no access to your own system where you need to enforce a policy. But I realiz

[10:43] <Alias_> If you control the server, and you trust every person commiting to it to not be stupid, and you'll never expand beyond that situation, then SVN is fine (except for the whole every-tag is a copy and consumes a ton of disk space problem)

[10:43] <Alias_> So a personal SVN server is just fine, and I'm switching over to it for my CPAN development

[10:43] <Alias_> And I also use SVN for the OpenOpenOffice project and a few other things

[10:43] <Alias_> Stuff that doesn't use tags heavily

[10:43] <nothingmuch> Alias_: tag copies don't consume disk space

[10:43] <Alias_> nothingmuch: They do on the client

[10:44] <nothingmuch> oh

[10:44] <nothingmuch> hehe

[10:44] * nothingmuch only has trunk checked out

[10:44] <audreyt> "ln"-based checkout may be cool

[10:44] <audreyt> but maybe too cool ;)

[10:44] <Alias_> That's one minor other problem

[10:44] <Alias_> You can't checkout the base of any sufficiently complex project

[10:44] <Debolaz> I guess the problem arises from SVN not trying to do the task of 2 systems in one, revision control and development model. While those are handy for certain situations to have in one application, it can also be a problem when you need a different model/policy. So SVN chose a more laissez faire solution implementing the model in wetware, but having facilities to make it easy as long as people understood what they needed to do, while CVS makes the assumption t

[10:45] <Debolaz> I'm just babbeling btw, getting my thoughts in writing to remember it better. :)

[10:45] <Alias_> CVS implements an entire VCS, SVN implements a versioning remote filesystem

[10:45] <Alias_> And as long as you don't treat SVN as a full VCS, it makes a really really awsome versioning remote filesystem

[10:46] <Alias_> It's only when people with non-trivial needs try to do things on top of SVN that you hit problems

[10:46] <Alias_> For ordinary work it's just fine

[10:46] <Debolaz> Alias_: Imho, that's wrong. I don't think a VCS always needs to enforce a certain policy.

[10:46] <Alias_> sure

[10:46] <Alias_> But it needs to enforce the things it says it does

[10:46] <Alias_> If SVN didn't have tags, I'd be just fine

[10:47] <Alias_> See, your hard drive implements branches and tags to!

[10:47] <Debolaz> It's very handy for some situations, such as the one you described and I think it's a perfectly valid point you bring up. Just that it doesn't make it a non-VCS by not enforcing a model.

[10:47] <Alias_> In fact, your photocopier implements branches and tags as well

[10:47] <audreyt> $ env LC_ALL=C svn help tag

[10:47] <audreyt> "tag": unknown command.

[10:47] <Alias_> Put a sheet of paper in your photocopier, and write "tag" on the copy, and it's a tag

[10:48] <Alias_> Unless you write something else on it, then it's a branch

[10:48] <Alias_> Just because you CALL it a tag, doesn't make it a tag

[10:48] <nothingmuch> tag isa copy, branch isa copy

[10:48] <nothingmuch> the point is reducing software complexity

[10:49] * Alias_ points at audreyt 

[10:49] <Alias_> See, it doesn't implement tags

[10:49] <nothingmuch> you can write a 15 line shell script that implements "real" tagging and copying

[10:49] <nothingmuch> on top of SVN

[10:49] <Alias_> The only place the concept of tags exist is in the manual

[10:49] * nothingmuch thinks it's a good thing

[10:49] <Alias_> nothingmuch: ... and you have to repeat that on every single installation?

[10:49] <nothingmuch> and likes SVN more than many systems because of that

[10:49] <nothingmuch> since you can branch and tag arbitrary dirs

[10:49] <Alias_> You'd love VMS

[10:49] <nothingmuch> i doubt it

[10:49] <Alias_> See, VMS has native versioning filesystems

[10:49] <nothingmuch> from what I've heard

[10:50] <Alias_> It's like SVN, but locally!

[10:50] *** Aankh|Clone is now known as Aankhen``

[10:50] <nothingmuch> anyway, my point is - perforce is too complicated

[10:50] <nothingmuch> because it tries to give SVN flexibility

[10:50] <nothingmuch> with "real branches" and stuff

[10:50] <nothingmuch> tags somehow survive this

[10:50] <Alias_> All I want is branches that you can see, and tags you can see... in code

[10:50] <nothingmuch> but it's SSSSSSSOOOOOOOOOOOOOOOOOOOOOOO complicated to manage branching that you want to cry

[10:51] <Alias_> If I write a function that takes a "tag" as a pameter, I want to be able to write an is_tag() function 

[10:51] <Alias_> parameter

[10:51] <nothingmuch> so write a wrapper

[10:51] <nothingmuch> and make a pretty dist

[10:51] <nothingmuch> and make them use that

[10:51] <nothingmuch> or don't do it at all

[10:51] <nothingmuch> and don't use SVN

[10:51] <Alias_> I don't :)

[10:51] <nothingmuch> or don't use real tags and real branches

[10:51] <nothingmuch> right

[10:51] <nothingmuch> this discussion is looping =)

[10:51] <Alias_> See, the solution to SVN not having tags tends to come down to not using SVN

[10:51] <Alias_> And yet the manual keeps insisting it has tags

[10:51] <nothingmuch> heh

[10:52] <Alias_> It's just they are tags you can't use

[10:52] * nothingmuch is perfectly happy, as are many others

[10:52] <Alias_> Well, so am I

[10:52] <nothingmuch> i don't like SVN for it's centralness

[10:52] <Alias_> Just only use it for the projects that need lots of tags

[10:52] <nothingmuch> and i don't really like SVK because i think it's too complicated

[10:52] <Alias_> err don't need

[10:52] <Alias_> If all you have are simple needs, SVN is probably fine

[10:52] <nothingmuch> but then again i really like SVK because it gives me what I want from the defacto standard which is SVN

[10:53] <nothingmuch> what I really like is darcs

[10:53] <Alias_> I have one system that needs in the order of 40-50 tags a day

[10:53] <Alias_> That's a hell of a lot of copies

[10:53] <nothingmuch> because in darcs every things are very very simpl

[10:53] <nothingmuch> e

[10:53] <nothingmuch> you don't need these checked out

[10:53] <Alias_> audreyt: darcs is a patch-based vcs right?

[10:53] <nothingmuch> yes

[10:54] <Alias_> There's two types of VCS, repository and patch-based

[10:54] <nothingmuch> it has only tags

[10:54] <Alias_> There's good reasons for both of those

[10:54] <nothingmuch> and every branch is just it's own repo

[10:54] <nothingmuch> or working copy

[10:54] <nothingmuch> or whatever

[10:54] <Alias_> yep

[10:54] <Alias_> It's a control thing though

[10:54] <Alias_> Some situations dictate the need for control

[10:54] <Alias_> It's a sliding scale

[10:55] <Alias_> svk makes a nice half-way point

[10:55] <Alias_> Because it's a repository-based VCS you can use in patch-mode (sort of)

[10:55] <nothingmuch> svk is a powertool

[10:55] <Alias_> I like the idea of SVK, I just don't quite need it yet

[10:55] <nothingmuch> with lots of bells and whistles

[10:55] <nothingmuch> it should have a few more sirens though

[10:55] <Alias_> Again, like anything, it depends if you need them

[10:56] <Debolaz> The main idea behind SVK is decentralized repositories though, that's the significant difference from SVN.

[10:56] <nothingmuch> darcs is like SVK in terms of theoretical flexibility

[10:56] <nothingmuch> but it's much more minimalistic

[10:56] <nothingmuch> and not compatible with SVN

[10:56] <nothingmuch> which is why I use both

[10:56] <Alias_> Debolaz: But that's the idea behind all those patch-based systems

[10:58] <nothingmuch> if someone wants to buy me a present because I'm so cool: http://cgi.ebay.com/ws/eBayISAPI.dll?ViewItem&item=7576649753&rd=1&sspagename=STRK%3AMEWA%3AIT&rd=1

[10:58] <Alias_> Instead of being purely distributed though, SVK is still sort of star-patterned

[10:58] <Debolaz> Personally, I'm looking at mercurial for my own use. It's probably between that and svk.

[10:59] <Alias_> When SVK gets a GUI client, I'll consider it

[10:59] <Alias_> audreyt: Speaking of which, remind me to talk to clcao some time about reusing the gear we're making for the Perl editor to make a SVK gui

[11:00] <Alias_> There's a few new components now that should make Perl desktop GUI software a bit easier to CPANify

[11:00] <nothingmuch> clkao, not claco or clcao ;-)

[11:00] <Alias_> damn it

[11:01] <nothingmuch> tab completion is your friend =)

[11:01] <Alias_> he's here?

[11:01] <Alias_> ah

[11:02] <Alias_> In fact, I should write an Acme:: module documenting photocopier version control

[11:02] <Alias_> Acme::SVN::Photocopier

[11:02] <Alias_> or just Acme::VCS::Photocopier

[11:03] <nothingmuch> please don't, too much chaffe

[11:03] <Alias_> heh

[11:03] <nothingmuch> CPAN's SNR ratio is pretty fucked up as it is ;-)

[11:03] <Alias_> Acme:: is there for a reason though :)

[11:03] <nothingmuch> right, but for evangelism there are blogs

[11:04] <Alias_> Well, I've used Acme:: to make a point before

[11:04] <Alias_> And it was very useful

[11:04] <Alias_> Go see Acme::BadExample

[11:04] <Alias_> Acme:: contains a lot of that sort of proof of concepts

[11:05] <Alias_> audreyt: More M:I problems... the way Module::AutoInstall does it's auto-sudo'ing has issues

[11:05] <Alias_> audreyt: It's leaving behind root-owned files that break the main install

[11:07] <audreyt> hm

[11:07] <audreyt> maybe we do without autosudoing altogether.

[11:07] <audreyt> it was because CPAN.pm doesn't have proper sudo support

[11:07] <Alias_> And bailout instead?

[11:07] <Alias_> The idea works, it's just you aren't cleaning up

[11:07] <audreyt> but now CPAN.pm is probing for sudo

[11:07] <Alias_> Otherwise you have do sudo the entire 4 commands

[11:08] <Alias_> or at least the last 3

[11:08] <audreyt> since this October

[11:08] <Alias_> You'd have to sudo make

[11:08] <Alias_> Which would mean you'd have to sudo make test

[11:08] <audreyt> so both CPAN.pm and CPANPLUS now has sudo support

[11:08] <Alias_> Which could create spurious results for file tests

[11:08] <audreyt> and they did it in the right place

[11:08] <audreyt> namely "make install"

[11:08] <audreyt> so I think we can retire our sudo support

[11:08] <Alias_> How do you install deps?

[11:09] <audreyt> via CPAN.pm and CPANPLUS.pm

[11:09] <Alias_> They have to be installed before make test

[11:09] <audreyt> which, again, both already have sudo support

[11:09] <Alias_> By hand? Or by calling to them...

[11:09] <audreyt> by calling to sudo

[11:10] <Alias_> No, does M:I just say "Go install the deps yourself" or pass off to CPAN.pm which then magically does it...

[11:10] <audreyt> CPANPLUS 0.05x and CPAN 1.8x

[11:10] <audreyt> the latter

[11:10] <audreyt> if you want you can add a warning if CPAN.pm is <1.80 or CPANPLUS < 0.050

[11:11] <audreyt> saying they don't have sudo support and you will probably fail

[11:11] <Alias_> Which is a lot of systems

[11:11] <audreyt> and recommend an upgrade

[11:11] <audreyt> or something

[11:11] <audreyt> yes, but it's not our layer

[11:11] <Alias_> I note that M:I is supposed to work with older things... it's a big selling point

[11:11] <audreyt> it used to be, but is no longer

[11:11] <audreyt> yes, so if you don't like the warning idea, do the proper cleaning by hand

[11:11] <audreyt> works too

[11:11] <Alias_> I do

[11:12] <Alias_> The install fails horribly with errors all over the place, I go WTF and sudo make realclean and then start it again, and then it works

[11:12] <Alias_> But it's hella ugly, and I doubt the normals will enjoy it

[11:12] <Alias_> I'm not entirely sure why it would need to leave root-owned files around at all

[11:14] <Alias_> Whatever it's doing to do the sudo-ed installs, I wouldn't have thought it would leave files in the current install's directory

[11:14] <audreyt> are you using CPAN.pm instead of CPANPLUS.pm?

[11:15] <Alias_> um... I'm not using either

[11:15] <Alias_> I'm doing perl Makefile.PL; make; etc by hand

[11:15] <Alias_> So it's using CPANPLUS itself I think

[11:18] <audreyt> hm

[11:18] <Alias_> audreyt: If it's creating files, could we create a subdir, move into it do to the installs, then back up and remove it?

[11:18] <Alias_> to do

[11:18] <audreyt> yes, but CPANPLUS already do that

[11:18] <audreyt> let's just disable sudo support when using CPANPLUS as backend.

[11:19] <Alias_> ok

[11:19] <audreyt> ...implemented.

[11:19] <audreyt> committing

[11:19] <Alias_> Don't release

[11:19] <Alias_> I badly need to proof the docs

[11:19] <Alias_> Will do shortly

[11:23] <audreyt> ok

[11:23] <audreyt> the fix is in as r74

[11:23] <Alias_> ok

[11:23] <Alias_> I'm almost done with PITA::Scheme::Perl5::Make, then I'll deal with the docs. An hour at most

[11:24] <audreyt> cool

[11:24] * audreyt thinks Alias_ is a relentless machine

[11:25] <Alias_> It's weird, it hasn't even been hard to write

[11:25] <Alias_> Everyone else (CPAN, CPANPLUS, M:B, M:I) seems to have huge problems 

[11:25] <Alias_> I'm wondering if I just haven't hit the hard bits yet

[11:26] <Alias_> PITA::Scheme::Perl5::Make is only 80 lines of code

[11:26] <Alias_> and half of that is boilerplate and param checking

[11:27] <Alias_> And the only reason I seem relentless is that I like to write things slowly and make sure the tests pass :)

[11:28] <Alias_> Stemming from my absolute uselessness to work on anything that bores me, and thus to deal with bug reports :)

[11:29] <Alias_> You certainly seem to work a lot faster than I do

[11:31] <obra> Alias_: are you using 'make'? or implementing your own?

[11:31] <Alias_> obra: umm...

[11:31] <Alias_> It just runs Makefile.PL; make; make test;

[11:31] <Alias_> That's it

[11:31] <obra> Or is ::Perl5::Make not actuall something that. oh.

[11:32] <Alias_> It's a mass testing thing, I am just running what a human would

[11:32] <obra> Or presumably ./Build if it exists?

[11:32] <Alias_> Perl5::Build

[11:32] <obra> ah. cool

[11:32] <Alias_> ::Perl5 will autosense Makefile.PL or Build.PL and rebless as needed

[11:33] <Alias_> So for each new type of install, you write a new (smallish) ::Scheme:: class

[11:33] <Alias_> And the schemes should roughly match those in the Perl 6 C<use> specification

[11:33] <Alias_> or something :)

[11:33] <Alias_> I'm feeling my way as I go a bit in regards to the schemes

[11:34] <obra> (on the fly specification)++

[11:34] <Alias_> sometimes :)

[11:45] <gaal> audreyt: where's that variadic stuff again?

[11:45] <audreyt> OpTable line 418

[11:45] <audreyt> and below

[11:45] <gaal> (,,) ?

[11:45] <audreyt> er, sorry

[11:45] <audreyt> look for

[11:45] <audreyt> class OpClass a where op :: a

[11:45] <audreyt> and below

[11:46] <gaal> op :: a is.. interesting

[11:46] <audreyt> it's still finite types

[11:47] <audreyt> Text.Printf has infinite types :)

[11:48] * Debolaz wish SVK would have better support for mirroring a CVS repository.

[11:49] * audreyt thinks tailor.py support is long overdue

[11:49] <Alias_> tailer.py?

[11:50] <Debolaz> Doesn't tailor use VCP as well? 

[11:50] <audreyt> nope

[11:50] <Debolaz> VCP is badly badly broken. :/

[11:50] <Debolaz> Any attempt to mirror anything but small CVS repos will cause borking. 

[11:55] <obra> Debolaz: do you have time to help improve svk's CVS import support?

[11:57] <Debolaz> obra: I should at least set aside time to learn tailor better.

[11:57] <obra> *nod*

[12:09] <gaal> audreyt: where's the right place to add cbits to include+link settings now for pugs?

[12:12] <audreyt> gaal: what would you like to link/include in?

[12:12] <audreyt> it's Pugs.cabal.in 

[12:16] <gaal> sorry, meeting ant $work, bbiab

[12:22] <gaal> audreyt: error: fpstring.h: No such file or directory /  function ‘DataziFastPackedString_zdwccall_entry ...

[12:22] <joao> happy new year!

[12:22] <gaal> and then in linking (if I add -Idata/cbits manuall) there's an additional error

[12:22] <Alias_> hmmm

[12:22] <Alias_> What is involved in "mirroring" CVS

[12:23] <Alias_> I may be able to help

[12:24] <Alias_> Could you just use the old CVS Monitor backend code to pull the entire metadata set for the repository, and then reconstruct it from that?

[12:24] <audreyt> gaal: you want to link in FPS?

[12:25] <gaal> audreyt: I just added '#include "../../fpstring.h"' in Data.Yaml.Syck,

[12:25] <audreyt> gaal: then you need to tweak Makefile.PL as well

[12:25] <audreyt> also add FPS to additional-modules

[12:25] <audreyt> in cabal

[12:25] <gaal> audreyt: yeah, I wasn't where what-where etc.

[12:26] * Debolaz reads some more about darcs and likes it untill the word "haskell" pops up.

[12:26] <Alias_> hmmm?

[12:27] <nothingmuch> Debolaz: ?

[12:27] <Alias_> Haskell == good (+ braintwisty)

[12:28] <audreyt> gaal: ok... I can give it a stab after dinner

[12:28] <audreyt> but I need to run to dinner now

[12:32] * Debolaz goes back to making haskell behave properly on FreeBSD+pkgsrc.

[12:43] <Debolaz> How do I make ghc include /usr/pkg/lib/ghc-6.4.1/include when it compiles something so that it may suck in ghcconfig.h? (And why isn't this default behaviour?!)

[12:43] <Debolaz> I should ask that in another channel.. :)

[12:44] <Debolaz> Just pointing out why I don't like haskell.

[13:36] <gaal> audreyt: thanks, I keep getting distracted by work and I don't want to break PIL^N etc.

[13:57] *** DesreveR is now known as r0nny

[14:03] <svnbot6> r8542 | audreyt++ | * Full grammar support for Text.Parser.Rule.

[14:03] <svnbot6> r8542 | audreyt++ |     parseGrammar :: String -> Grammar

[14:03] <svnbot6> r8542 | audreyt++ | * PIL.Native.Syntax: The .grammar file works!

[14:03] <svnbot6> r8542 | audreyt++ | * Text.Parser.Rule: Support for assertions ^ $ ^^ $$.

[14:30] <svnbot6> r8543 | audreyt++ | * remove the no longer used isPrefixOf'.

[14:32] <gaal> what causes stuff to show up in ghc-options? I want to get -isrc/cbits there, but the .in file just has magicals like extra-libraries: __LIBS__ etc.

[14:34] <audreyt> gaal: those magicals are in Makefile.PL

[14:41] <gaal> audreyt: I don't see __LIBS__ in Makefile.PL?

[14:41] <audreyt> it's @libs

[14:41] <audreyt> I mean $libs

[14:41] <audreyt> er, nvm

[14:41] <gaal> :):

[14:42] <audreyt> so, the magic is in utuils/build_pugs.pl

[14:42] <audreyt>     my @libs = map substr($_, 2), grep /^-l/, @_;

[14:42] <gaal> aha

[14:43] <audreyt> so if you put -lsomething in oneof( $profiled_flags $ccdlflags $ghc_output )

[14:43] <audreyt> in Makefile.PL

[14:43] <audreyt> then it appears magically

[14:43] <audreyt> it makes no sense... except it's a stopgap to preserve Makefile.PL semantics with cabalization

[14:43] <audreyt> it's one of those stopgaps that lasts forever, though.

[14:43] <audreyt> s/lasts/seems to last/

[14:44] <gaal> as aristotle is fond of pointing out

[14:45] <gaal> so okay, if I get cbits into one of these, it oughta work. but which one is best for not breaking PIL?

[14:46] <audreyt> gaal: you can't break PIL anyway.

[14:46] <audreyt> it's not managed by cabal

[14:46] <gaal> PIL is invincible!

[14:46] <audreyt> heh

[14:46] <gaal> what's the proper -l for cbits?

[14:46] <gaal> -lcbits? :)

[14:46] <audreyt> there's no -l

[14:47] <audreyt> just throw src/cbits/fpstring.o into the list

[14:47] <audreyt> that's all

[14:47] <audreyt> same as syck

[14:47] <audreyt> look at inc/Module/Install/Pugs.pm

[14:47] <audreyt> add -isrc/cbits/ to it

[14:47] <audreyt> I think that's all it takes

[14:47] <gaal> ETOOMANYLOCATIONS

[14:48] <rafl> Juerd_: Aye. I think I'll send it tomorrow.

[14:48] <audreyt> gaal: isn't it :/

[14:48] <audreyt> I'd like to convert them all to cabal

[14:48] <rafl> Juerd_: But can you please send me your address via mail again? Such things tend to get lost in my irc logs.

[14:49] <gaal> (make unoptimized)++

[14:49] <gaal> but no!

[14:49] <gaal> Compiling Data.FastPackedString ( src/Data/FastPackedString.hs, dist/build/src/Data/FastPackedString.o )

[14:49] <gaal> /tmp/ghc21322.hc:12:22: error: fpstring.h: No such file or directory

[14:49] <Juerd_> rafl: ok. And thanks in advance :)

[14:49] <gaal> /tmp/ghc21322.hc: In function ‘r9CL_entry’:

[14:50] <gaal> beh, $work

[14:50] <gaal> bbiab &

[14:50] <audreyt> gaal: oy... let me take a look

[14:53] <audreyt> ... it turns out we want -I not -i.

[14:53] <audreyt> done.

[14:53] <gaal> (I seem to recall some liner hint also being needed) &

[14:53] <audreyt> r8544

[14:54] <audreyt> stevan: I wonder if we should split the mutable interface and immutable interfaces of Hash and Array

[14:54] <audreyt> that way Args and Sigs and even NativeSeq can implement the "fetch" part

[14:54] <svnbot6> r8544 | audreyt++ | * compile Data.FastPackedString as part of Pugs.

[14:54] <audreyt> but not the "store" part

[14:55] <gaal> (Another issue I have is one that luqui was faced with a while ago; you can't patmatch against VHash, so what to do for toYaml VHash?)

[14:56] <Debolaz> Building Pugs-6.2.10...

[14:56] <Debolaz> ghc-6.4.1: unrecognised flags: -Wl,-R/usr/pkg/lib

[14:56] <Debolaz> This is fun. :/

[14:56] <audreyt> gaal: you see a VRef, do a readRef, and go from there

[14:56] <gaal> audreyt: ACK.

[14:57] <audreyt> Debolaz: nopaste your Pugs.cabal?

[14:57] <audreyt> gaal: see the "perl" prim

[14:59] <lisppaste3> Debolaz pasted "Pugs.cabal" at http://paste.lisp.org/display/15254

[14:59] <pasteling> "gaal" at 192.115.25.249 pasted "link error" (12 lines, 1.3K) at http://sial.org/pbot/15199

[15:00] <audreyt> me multiplexeth

[15:00] <audreyt> Debolaz: aha, you are building with p5embed

[15:00] <audreyt> naughty you

[15:01] <audreyt> fixing

[15:02] <Debolaz> *Removes*

[15:04] <Juerd_> rafl: Why do several German people write "n" as "u"? I just discovered this and managed to assure 2 more cacert applicants :)

[15:04] <audreyt> gaal: hm, is the link error before or after r8545?

[15:04] <gaal> audreyt: after. r8545 fixes the compilation error.

[15:04] <Juerd_> Or, well, it's more like |\|, which I interpreted as "u", but apparently is "n".

[15:04] <Juerd_> Ehm, no, |/| it is.

[15:05] <rafl> Juerd_: No idea why. But it's only a "u" if there's a line above it. Otherwise it's "n".

[15:05] <Juerd_> A line above it?

[15:05] <Juerd_> (huh?)

[15:06] <rafl> As "u" and "n" are written pretty similar you need to distinguish between them.

[15:06] <Juerd_> This is new to me :)

[15:06] <rafl> So some people put a line above the u.

[15:06] <Juerd_> That they are similar, and that a line can help to disambiguate.

[15:06] <Juerd_> In Dutch, a line above a vowel is a lazy way of writing an umlaut...

[15:06] <webmind> it is ?

[15:07] <Juerd_> (Well, trema, which is the same glyph as umlaut, but has a different function)

[15:07] <Juerd_> webmind: Yes.

[15:07] <webmind> Juerd_, never seen or knew that

[15:07] <Juerd_> webmind: Especially ij is too often written as y with a line above it. *shivers*

[15:07] <rafl> Juerd_: I also write umlauts that way. Other's don't.

[15:07] <Juerd_> I have several cacert forms with actual Us without lines above them.

[15:08] <Juerd_> And none with.

[15:08] <rafl> Juerd_: So by removing one ambiguity another one is introduced.. :-)

[15:08] <audreyt> gaal: ok... let me try to duplicate

[15:08] <Juerd_> Except one for Fuhrerschein, but I guess that it's an umlaut there :)

[15:08] <rafl> Juerd_: It's not that common anymore. My grandparents are used to write that.

[15:08] * Debolaz contemplates stracing haskell in order to figure out what is causing the horrible bugs in pkgsrc automated builds.

[15:08] <Debolaz> The complete lack of documentation about this problem is getting frustrating.

[15:09] <Juerd_> rafl: I have 8 forms with Us without lines, so I don't think many people know about this disambiguation :)

[15:09] <Juerd_> However, all the Us are very clearly written, with the right side attached to the line, while almost no n is written with the left side attached to the vertical line.

[15:10] <Juerd_> Though there's also one Edmund, whose name I can interpret as Edmuud, Edmnnd, Edmnud or Edmund...

[15:10] <pasteling> "gaal" at 192.115.25.249 pasted "syckemit patch wip" (158 lines, 5.1K) at http://sial.org/pbot/15200

[15:10] <rafl> Juerd_: As I said. It's common for older people. I think my parents also do that.

[15:10] <Juerd_> The two characters are exactly equal :)

[15:10] <Juerd_> rafl: You're not older.

[15:10] <Juerd_> "das hier ist die Ziffer 'ueuu'" - Guess that's 'neun' then :)

[15:11] <gaal> audreyt: please don't fix it now though because I have to work and I'm on a terribly low self-discipline day :)

[15:11] <Juerd_> Interesting.

[15:11] <rafl> Juerd_: Did I write a "u" with a dash about it?

[15:11] <Juerd_> Actually, there's no "u" in your form

[15:11] <Juerd_> And TBH, I can't read much of what you wrote :)

[15:11] <rafl> That's common as well. :-)

[15:12] <Juerd_> I know what it says because I know who you are...

[15:12] <Juerd_> Flo---__ Ronsthphnp or something like that, it looks like :)

[15:12] <audreyt> gaal: okay :)

[15:12] <Juerd_> I like, by the way, how german 1s are tents. :)

[15:13] <rafl> Juerd_: I surely don't have 'php' in my surname!

[15:14] <rafl> Juerd_: How do 1s look in the netherlands?

[15:14] <audreyt> gaal: try r8545 and see if it links

[15:14] <svnbot6> r8545 | audreyt++ | * pure cargoculting to try to get syck linking back.

[15:17] <audreyt> Debolaz: I've attempted a fix in r8546 on building with p5embed.

[15:17] <svnbot6> r8546 | audreyt++ | * Debolaz++ reports the perl5 embedding's -Wl options still

[15:17] <svnbot6> r8546 | audreyt++ |   found there way into ghc-options field; remove them.

[15:18] <Debolaz> audreyt: Still compiling this, I can check out a trunk and try it once I've gotten the pkgsrc version working.

[15:18] <audreyt> ok

[15:18] <Debolaz> Which may take a little while since haskell doesn't like being friendly.

[15:21] <audreyt> I'm one of the AIX GHC porters; I know that feeling.

[15:21] <audreyt> ...though I tend to think AIX shares half of the blame.

[15:22] <Debolaz> I need to figure out what environment variable makes haskell go ballistic. :/

[15:22] <audreyt> mmm you can do a binary search ;)

[15:23] <audreyt> or write your own ~/bin/ghc wrapper and permute the env

[15:24] <pasteling> "gaal" at 192.115.25.249 pasted "link still fails" (7 lines, 1K) at http://sial.org/pbot/15201

[15:24] <Debolaz> It somehow doesn't feel like the "right" solution. :)

[15:24] <gaal> (r8545)

[15:25] <audreyt> so. you called syck_flush

[15:25] <audreyt> are you sure it's not syck_emitter_flush ?

[15:25] <audreyt> are you 100% sure? :)

[15:25] <Alias_> heh, he said syck_emitter_flush

[15:27] <gaal> :)

[15:27] * gaal checks

[15:28] <pasteling> "gaal" at 192.115.25.249 pasted "no end to fun" (9 lines, 1.3K) at http://sial.org/pbot/15202

[15:28] <gaal> so, that helped, but there are still a few bumps.

[15:29] <Debolaz> audreyt: It seems that pugs don't include the parrot library directory so the linking fails at the end. PARROT_PATH is set correctly.

[15:30] <audreyt> Debolaz: is this a parrot build tree or installed parrot?

[15:30] <audreyt> gaal: kill your dist/build/src/Data/Yaml and try again

[15:31] <rafl> Juerd_: I still did not receive your snail mail address via email.

[15:31] <Debolaz> audreyt: Installed parrot. PARROT_PATH is set to "/usr/pkg/parrot" and libparrot is in /usr/pkg/parrot/lib/blib/lib/

[15:32] <Debolaz> audreyt: It tries to use /usr/pkg/parrot/blib/lib instead.

[15:32] <audreyt> Debolaz: ok. I think we don't yet have support for installed parrot.

[15:32] <audreyt> I'll fix.

[15:32] <audreyt> fixed.

[15:32] <audreyt> committing

[15:33] <rafl> audreyt: Actually it works with an installed, dynamically linked parrot using the Debian pakages.

[15:33] <audreyt> committed.

[15:33] <audreyt> rafl: oh, cool

[15:33] <audreyt> didn't know that.

[15:33] <svnbot6> r8547 | audreyt++ | * accomodate for installed parrot in -L$base/blib/lib tree.

[15:33] <audreyt> er, I meant lib/blib/lib/ in the commit log.

[15:34] <Juerd_> rafl: What address do you want me to use?

[15:34] <rafl> Juerd_: [email@hidden.address] is fine.

[15:34] <rafl> audreyt: We should better fix parrots installation system.

[15:34] <Debolaz> audreyt: Where do I patch this for the purpose of making it build with the currently released version?

[15:34] <Juerd_> rafl: ok

[15:34] * Debolaz should probably just check what was committed before asking dumb questions.. :/

[15:34] <audreyt> Debolaz: you prod me for the next release.

[15:34] <Juerd_> rafl: Forwarded

[15:35] <audreyt> rafl: I agree...

[15:35] <audreyt> Debolaz: and yes, see the fix in r8547 for details

[15:37] <stevan> audreyt: I think seperate mutable and imutable interfaces are not a problem

[15:38] <stevan> role ImutableArray {}; role MutableArray { does ImutableArray; }

[15:38] <audreyt> stevan: right, although there's a deeper connection

[15:39] <stevan> how so?

[15:39] <audreyt> for example, if you have an Array, you can reverse it

[15:39] <audreyt> there is immutable (functional) reverse which returns the reversed thing

[15:39] <audreyt> and an mutable counterpart which does it inplace

[15:39] <audreyt> same goes for updating an elemtn, etc

[15:40] <stevan> is that speced? I thought p5 was always a functional reverse?

[15:40] <audreyt> no, it's not part of spec

[15:40] <stevan> ok

[15:40] <stevan> how does it tell the difference?

[15:40] <audreyt> I'm merely thinking whether it makes sense for all destructive operations to have a functional counterpart that returns the same type

[15:40] <stevan> yes

[15:41] <stevan> so store() returns a new list with eht new item?

[15:41] <stevan> uc(store)

[15:41] <audreyt> and if so, a mutable container just returns itself

[15:41] <stevan> ok

[15:41] * Alias_ pulls out a new low in his attempts to knock audreyt off the CPAN perch

[15:41] <audreyt> whilst an immutable thing that does the interface returns an updated stuff

[15:41] <audreyt> does this makes any sense?

[15:41] <Alias_> (have a read of PITA::Test::Dummy::Perl5::Make when it appears on recent uploads) :)

[15:41] <stevan> so both intereface are the same, but the immutable one returns new copies?

[15:42] <audreyt> stevan: that's what I've been thinking. I'm not sure if it's sane.

[15:42] * stevan ponders disagreeing with audreyt 

[15:42] <gaal> audreyt: it works now, thanks!

[15:42] <stevan> what is your reasoning?

[15:42] <stevan> pure is easier to optimize?

[15:43] <Debolaz> audreyt: Gives an error now which is probably related to parrot not being dynamic. A step forward. :)

[15:43] <stevan> .../reason-about/write-a-thesis-on/etc

[15:43] <audreyt> @foo := ::Array`create([]); @foo.push(3).push(4); @foo`fetch_list; # [3,4]

[15:44] <audreyt> @foo.push(3).push(4)`fetch_list # also [3,4]

[15:44] <stevan> hmm

[15:44] <stevan> the first line is mutable, the second is immutable 

[15:44] <stevan> right?

[15:44] <audreyt> no, both are mutable, as ::Array is mutable

[15:45] * stevan is confused then

[15:45] <audreyt> it's a container

[15:45] <audreyt> but the second line would also work if @foo is bound to something that is not an ::Array

[15:45] <stevan> oh sorry ,.. didnt see the @foo in the second line

[15:45] <audreyt> for example, a Match object.

[15:46] <audreyt> so, my reasoning is twofold

[15:46] <audreyt> 1. it saves us some namespace -- instead of .unshift and .cons, there is just .unshift

[15:47] *** nnunley_ is now known as nnunley

[15:47] <stevan> .cons being the immutable interface?

[15:47] <gaal> prettyVal is so pretty!

[15:47] <audreyt> yeah

[15:49] <audreyt> 2. instead of have all destructive operation returning nil, we let them return the container itself, which makes chained assignments etc happier

[15:49] <audreyt> and it generalizes the .push interface so instead of returning the number of elems, it returns the container (which numifies to the number of elems)

[15:49] <luqui> audreyt, you know that larry is trying really hard to avoid returning self

[15:50] <luqui> putting in all sorts of language features to make that unneccesary

[15:50] <audreyt> luqui: no. why?

[15:50] <luqui> he says that "we don't want people to return self instead of returning something useful"

[15:50] <luqui> (or something like that)

[15:50] <audreyt> not sure if it's relevant in the PILN level

[15:50] <luqui> maybe not, but it's something to keep in mind

[15:50] * stevan things that returning self can be useful

[15:50] <luqui> stevan, I think he means something with information in it

[15:51] * stevan thinks self contains plenty of information too 

[15:51] <luqui> not any *new* information

[15:51] <stevan> luqui: of course it does,.. if you just changed self in some way

[15:51] * luqui thinks stevan knows what he means, and is just being troublesome

[15:51] <audreyt> stevan: anyway. the only drawback I can see from this plan is that .shift becomes awkward

[15:52] <stevan> audreyt: as does pop()

[15:52] <audreyt> well, same issue

[15:52] <audreyt> and .delete

[15:52] <audreyt> that's the three

[15:52] <stevan> luqui: I do understand, but I very much disagree

[15:52] <luqui> stevan, even with facilities like monkey but?

[15:52] <audreyt> and not surprisingly, in Haskell they only does the destruction, not return the original value

[15:53] <audreyt> so you need an extra fetch call before the pop.

[15:53] <stevan> audreyt: so we follow haskell then

[15:53] <luqui> so stevan, how is returning self useful?

[15:53] <stevan> luqui: method chaining

[15:54] <stevan> as the primary use

[15:54] <luqui> $foo but { .bar; .baz; .quux }

[15:54] <luqui> beacause: $foo.bar.baz

[15:54] <stevan> luqui: yes, in some cases

[15:54] <stevan> monkey but is not always the right way to do it

[15:55] <audreyt> stevan: cool... user-space "pop" can be built using two explicit prim calls

[15:55] <audreyt> but we don't do it at prim level

[15:55] <luqui> *prevents* bar from ever deciding that it should return something

[15:56] <luqui> stevan, when is monkey but not the right way to do chaining?

[15:56] <luqui> or rather, why?

[15:56] <stevan> luqui: not *always* the right way

[15:56] <luqui> example?

[15:56] * luqui knows that stevan is busy, and will rest the argument until later if he likes

[15:56] <stevan> $foo.bar.baz.quux

[15:57] <luqui> stevan, why is that better?

[15:57] <stevan> Foo::bar returns a ::Baz

[15:57] <stevan> Baz::Baz returns a ::Quux

[15:57] <stevan> etc

[15:57] <luqui> oh...

[15:57] <Debolaz> I think I noticed a problem with the parrot build... when you make world_shared, it will link the parrot executable to the dynamic libparrot, but it doesn't compile in where to find libparrot, assuming that it'll be found by the dynamic linker which won't find it because it installs it in /usr/pkg/parrot/.../ 

[15:57] <luqui> that's not returning self though

[15:57] <stevan> will monkey but handle that?

[15:57] <stevan> no, your right

[15:58] <luqui> method chaining is definitely useful (except in pugs where it is broken :-(

[15:58] * stevan ponders

[15:58] <luqui> but returning self so that you can conveniently do multiple method calls on the same object is broken thinking

[15:58] <Juerd_> IMO, method chaining is incredibly useful, just never with any .foo returning its invocant.

[15:58] <luqui> imo

[15:58] <Juerd_> Unless the .foo is .self :)

[15:58] <luqui> :-)

[15:59] <audreyt> luqui: ($a = $b) += 4;

[15:59] <audreyt> is it the kind of broken thinking p6 is going to avoid?

[15:59] <audreyt> :)

[15:59] * luqui hopes so

[15:59] <audreyt> (the .infix:<=> returns self)

[15:59] <luqui> but probably not

[15:59] <Juerd_> audreyt: To that, I do not object.

[15:59] <luqui> I hate code like that

[16:00] <gaal> (my $me = $0) =~ s,^.*/,,;

[16:00] <Juerd_> Well, to this specific example, I do, because it should be $a = $b + 4

[16:00] <audreyt> Juerd_: ah, but my proposal above was risen to do that easily in PILN

[16:00] <luqui> gaal, yeah, exactly, that sucks

[16:00] <Juerd_> But with s///, it's definitely useful.

[16:00] <luqui> Juerd_, but we're fixing that

[16:00] <gaal> luqui: I agree. What's the platonically pure spelling though?

[16:00] <audreyt> my $me = $0 but { s,^.*/,, }

[16:01] <Juerd_> I see.

[16:01] <luqui> my $a = $b.subst(rx|^.*/|, "")

[16:01] <luqui> (or something like that)

[16:01] <luqui> we haven't really decided, but we have decided that there will be one

[16:01] <Juerd_> I still think (believe!) that all methods should be non-mutating by default, including sugared ones like s///.

[16:01] <Juerd_> And that ~~ s/// makes little sence, while .s/// would.

[16:01] <gaal> my $me = $0 but i_told_you_i_dont_LIKE_pathnames;

[16:01] <Juerd_> Even though it's arcane and special syntax.

[16:01] <Alias_> Juerd_: Isn't that going to involve a hell of a lot of copying

[16:02] <luqui> Juerd_, well, it's one style of coding

[16:02] <stevan> luqui: I guess I can't think of a particularly useful situation at the moment, but I just dont like the idea that I wont be able to

[16:02] <luqui> Alias_, not if we plan for it

[16:02] <stevan> "broken thinking" or not

[16:02] <Juerd_> Alias_: Eh, no?

[16:02] <luqui> stevan, you will be able to

[16:02] <Alias_> $one_meg_string =~ s/foo/bar/;

[16:02] <luqui> we just don't like you to

[16:02] <gaal> my $pizza = $yours but hold_the_pepperoni;

[16:02] <luqui> but in Perl, as usual, style guidance is never gospel

[16:02] <gaal> works for me

[16:02] <stevan> luqui: ok, thats fine then :)

[16:02] <Juerd_> Alias_: .= can be an optimized thing. Only if the mutation-specific method is lacking, copying is used.

[16:03] <audreyt> luqui: so, what about .pop, .shift and .infix:<=>?

[16:03] <audreyt> oh and .postfix:<++> while you are at it.

[16:03] <luqui> audreyt, .pop and .shift?

[16:03] * stevan goes back to PIL^N 

[16:03] <gaal> is it true that ruby doesn't have ++?

[16:03] <audreyt> luqui: they are like s///

[16:03] <Juerd_> Alias_: For example, @foo.=sort better be optimized, while inline operation on $foo.=sqrt makes no sense at all.

[16:03] <audreyt> luqui: do one destructive thing and return a side effect

[16:04] <luqui> audreyt, are you arguing Juerd_'s comment?

[16:04] <luqui> that there shouldn't be any destructive methods?

[16:04] <audreyt> 17:01 < luqui> my $a = $b.subst(rx|^.*/|, "")

[16:04] <Juerd_> Alias_: So Perl can simply see that there's no mutation specific sqrt method, and do $foo = $foo.sqrt instead.

[16:04] <audreyt> I thought you are indicating that the p6 team is introducing nonmutating alternatives to mutating operations

[16:05] <luqui> not for all of them it seems.  We just want to get around operation(my $x = $y)

[16:05] <luqui> where it is common

[16:05] <audreyt> ah. ok.

[16:05] <luqui> and I don't fully agree with Juerd_ that there shouldn't be any mutating operations

[16:05] <luqui> It's a good principle, but it can be linguistically awkward

[16:06] <luqui> but maybe that means that we introduce linguistic facilities to enable that, too

[16:06] <audreyt> I don't know, I've been brainwashed by cc2e that mutations that returns anything but nil (or the object itself) is error prone

[16:06] <Juerd_> luqui: Wait a sec; that's not what I said (at least not what I meant)

[16:06] <audreyt> s/object itself/post-operation object/

[16:06] <Juerd_> luqui: I think there should be no mutating *methods*, where methods specifically mean \.\w+ :)

[16:06] <luqui> audreyt, why?

[16:06] <luqui> Juerd_, that's what I meant

[16:07] <luqui> for example, .pop is linguistically awkward in that case

[16:07] <Juerd_> luqui: A postfix ++ should be mutating, of course!

[16:07] <audreyt> luqui: same reason why ($a++ + $b++ ) is a bad idea

[16:07] <Juerd_> Even if written as .++

[16:07] <luqui> audreyt, you mean $a++ + $a++ ?

[16:07] <audreyt> yeah

[16:07] * luqui got CC2E, but hasn't started it yet

[16:08] <luqui> hmm, that's an interesting perspective

[16:08] <audreyt> namely, programmers have an intuitional understanding of rvalues and lvalues

[16:08] <Juerd_> luqui: Hm, I hadn't exactly considered array size changes. It is a good point. Consider my remark limited to scalars :)

[16:08] <luqui> Juerd_, your remark is getting kind of special-casey...

[16:08] <audreyt> and "functions" that compute things, as well as "procedures" that do things

[16:08] <luqui> audreyt, and they should be separate?

[16:09] <Juerd_> luqui: It seems so.

[16:09] <audreyt> and there is a convention for procedure to return an error code, or the state-after-procedure, or nil

[16:09] <audreyt> but some procedures masquerate as functions and return something entirely unrelated

[16:09] <audreyt> for example, .chomp returns a newline.

[16:09] <audreyt> (except when it does not.)

[16:09] <audreyt> and .push returns a number.

[16:09] <luqui> audreyt, getLine :: IO String

[16:09] <luqui> function or procedure?

[16:10] <audreyt> luqui: "input".

[16:10] <Juerd_> audreyt: .chomp according to quickref/data returns the modified string, with a .newline property indicating what was removed (ugly, and probably unneeded)

[16:10] <audreyt> it doesn't do anything to its argument :)

[16:10] <luqui> audreyt, touche

[16:10] <Juerd_> But I do believe that .chomp should not mutate, while .=chomp obviously should

[16:10] <luqui> Juerd_, woah...

[16:10] <audreyt> Juerd_: yeah, and what I'm saying is that, now we have .= form and monkey but

[16:10] <luqui> that's right, I remember that

[16:11] <Juerd_> "and monkey but" doesn't parse

[16:11] <luqui> but I just now realized that it's a really bad solution

[16:11] <audreyt> monkey-but

[16:11] <Juerd_> What does that mean?

[16:11] <luqui> $foo but {.bar}

[16:11] <gaal> grrr, I have a CLong that's actually a void* to a frozen YamlNode. how do I get it back?

[16:11] <luqui> equivalent to:   $foo.bar; $foo

[16:11] <Juerd_> What's the monkey part?

[16:11] <luqui> you're "monkeying around" with the argument

[16:11] <Juerd_> Ahh

[16:12] <gaal> (syck trafficks longs instead of void*s)

[16:12] <Juerd_> Missed the introduction of that slang expression :)

[16:12] <audreyt> it's a bad joke -- I learned it from luqui. he and nothingmuch showed monkey butt pictures around the hackathon.

[16:12] <luqui> Juerd_, Damian's idea, of course

[16:12] <audreyt> gaal: "cast".

[16:12] <Juerd_> luqui: Somehow I knew that already ;)

[16:12] <Debolaz> How may I override a variable from Config.pm when running Makefile.PL?

[16:13] <audreyt> gaal: in your FFI import, declare it as a Ptr 

[16:13] <Juerd_> I haven't thought of this use of but, and can't say if I like it.

[16:13] <audreyt> gaal: never mind the C side declaration.

[16:13] <audreyt> Debolaz: the main Config.pm?

[16:13] <luqui> Juerd_, you'll know when the time is right

[16:13] <gaal> ooh!

[16:13] <luqui> I've used it once or twice, and it really increases elegance in those one or two cases

[16:13] <Juerd_> It may be the fundamental mistake esperanto made (it's dynamic and polymorphic, but every word has a base form, and derivation depends on whether the base word was a noun, adjective, or verb...)

[16:14] <luqui> it was introduced, as we've been saying, as an alternative to returning self for chained method calls

[16:14] <audreyt> luqui: it's too bad that the .predicate?() and .mutation!() form from ruby is not adopted :)

[16:14] <Debolaz> audreyt: I need to change "ccdlflags" un order to unbreak parrots dynamic build.

[16:14] <audreyt> I kinda like effect sigiling :)

[16:14] <luqui> audreyt, agreed

[16:14] <audreyt> Debolaz: I already committed a fix

[16:14] <Juerd_> luqui: Does it turn a mutating method into a non-mutating one?

[16:14] <audreyt> Debolaz: util/build_pugs.pl r8546

[16:14] <luqui> Juerd_, no

[16:14] <Juerd_> Then I fear I don't grok it yet

[16:15] <luqui> $foo but { .bar; .baz }  is exactly equivaent to $foo.bar;  $foo.baz;  $foo

[16:15] <luqui> that's all you need to know

[16:15] <Juerd_> Ahh

[16:15] <audreyt> luqui: actually... is there a specific reason why effect sigiling is not adopted?

[16:15] <Juerd_> Is that good for "but", though?

[16:15] <audreyt> luqui: it doesn't conflict with any existing mechanisms

[16:15] <luqui> audreyt, I'm not sure... we *do* have those useless .* and .+ forms

[16:15] <Juerd_> As "$foo but true" does not make $foo itself true.

[16:15] <Debolaz> audreyt: Well, the problem isn't specific to pugs. Even if you make pugs work without a dynamic parrot, other applications might want it so I try to make the parrot build as all-pleasing as possible.

[16:16] <luqui> we could kill those and use .? and .! instead

[16:16] <luqui> or something like that

[16:16] <audreyt> luqui: .*? .+?

[16:16] <audreyt> what are you talking about?

[16:16] <Juerd_> While .bar and .baz can be unpure (and probably are, if used like this), and thus change state

[16:16] <luqui> (.! might be bad because of private attrs)

[16:16] <audreyt> Debolaz: oh. I don't know, then.

[16:16] <luqui> audreyt, you don't know about .+ and .*?

[16:16] <Juerd_> .+ and .* suck

[16:16] <luqui> consider yourself lucky, audreyt 

[16:16] <Debolaz> audreyt: I could just run sed on root.in and hardwire in the proper directories, but it feels like an ugly hack.

[16:16] * luqui looks to see if they're in the synopsis

[16:16] <Juerd_> They MAY be useful, but I don't think the ugliness is warranted.

[16:16] <luqui> if not, then I'm happy

[16:17] <Juerd_> luqui: They were last time I checked.

[16:17] * luqui just doesn't think that they deserve syntactic liberation

[16:17] <audreyt> S06? S02?

[16:17] <luqui> S12 I think

[16:17] <Juerd_> audreyt: 3

[16:17] <luqui> Juerd_, really?

[16:17] <Juerd_> luqui: Yes

[16:17] <luqui> ahh, also S12

[16:17] <audreyt> ow

[16:17] <Juerd_> Well, quite briefly in S03

[16:18] <luqui> also quite briefly in S12

[16:18] <audreyt> yeah, I remember looking at it

[16:18] <Juerd_> But I always check S03 for the precedence table, and they're there.

[16:18] <audreyt> and consciously decided to punt

[16:18] <luqui> to be honest, I'm not totally sure what they do

[16:18] <Juerd_> audreyt++

[16:18] <gaal> audreyt: is readNode the inverse of freezeNode? is this "SYMID" just the address?

[16:18] <luqui> .? is pretty nice though

[16:18] <audreyt> self!?method

[16:18] <audreyt> that's very !?

[16:18] <luqui> okay, it doesn't look nice

[16:18] <luqui> the functionality is nice

[16:19] <audreyt> gaal: yes and yes, I think

[16:19] <Juerd_> What's better about $foo.?bar compared to try { $foo.bar }?

[16:19] <luqui> oh wait

[16:19] <audreyt> yeah, what Juerd_ said

[16:19] <luqui> I thought that $foo.?bar meant $foo // $foo.bar

[16:19] <audreyt> $foo.?bar is utterly weird

[16:19] <gaal> audreyt: argh no, it isn't; syck_lookup_sym calls st_lookup... weird

[16:19] <Juerd_> $foo.?bar is, IIRC, more or less equal to $foo.bar if $foo.can<bar>

[16:19] <gaal> ah i know why, it's a reentrancy guard

[16:20] <luqui> right... which is less cool

[16:20] <Juerd_> Or is that still $foo.can('bar')?

[16:20] <luqui> $foo.can<bar> means $foo.can(){'bar'}

[16:20] <Juerd_> Oh, right

[16:20] <Juerd_> But we have $foo.can:"bar" now, right? 

[16:20] <Juerd_> :)

[16:20] <luqui> yep

[16:20] <Juerd_> Okay

[16:20] <Juerd_> Don't like the colon, still, but it's better than parens.

[16:20] <audreyt> we do?

[16:20] <luqui> ?eval "foo".substr: 1,2

[16:21] <Juerd_> I don't get how the colon works together with indirect syntax

[16:21] <audreyt> oh, adverbial suffix.

[16:21] <luqui> where's evalbot?

[16:21] <Juerd_> luqui: It was gone when I left from .nl last Monday :)

[16:21] <luqui> oh my

[16:21] * luqui starts him up again

[16:21] <stevan> luqui: he was out on a bender last night,.. got really messed up,.. probably hung over

[16:22] <luqui> I told him not to do that!

[16:22] <Juerd_> luqui: It's still software. Software can be quite disobedient

[16:22] <luqui> no kidding

[16:22] <luqui> ?eval "foo".substr: 1, 2

[16:22] <evalbot_8547> \"oo" 

[16:22] <Juerd_> oo!

[16:23] <Juerd_> ?eval substr "foo": 1, 2

[16:23] <evalbot_8547> \"oo" 

[16:23] <Juerd_> ?eval substr "foo".substr: 1, 2: 1,1  # ehhm. right.

[16:23] <evalbot_8547> Error:  unexpected "." expecting term postfix, operator, ":", ",", postfix conditional, postfix loop, postfix iteration, ";" or end of input Only one invocant allowed 

[16:23] <Juerd_> So combining it doesn't quite work well :)

[16:23] <Juerd_> Probably a good thing, though

[16:23] <luqui> yeah

[16:23] <luqui> It was specced which one got precedence

[16:23] <luqui> I don't remember though

[16:23] <Juerd_> ?eval substr ("foo".substr: 1, 2): 1,1  # ehhm. right.

[16:23] <evalbot_8547> \"o" 

[16:24] <Juerd_> Wow, that actually even works.

[16:24] <luqui> I think it's $foo.bar: gets precedence

[16:24] <Juerd_> Impressive :)

[16:24] <luqui> i.e. what pugs currently does :-)

[16:24] <Juerd_> luqui: It should, as . is alwas communicated as having topmost precedence

[16:24] <audreyt> luqui: oh, http://svn.openfoundry.org/pugs/src/PIL/Native/Syntax.grammar

[16:24] <audreyt> nice test case for you :)

[16:24] <audreyt> (it works in the Hs implementation now)

[16:24] <luqui> cool

[16:24] <luqui> I don't have a rule parser though

[16:24] <audreyt> that's okay, I do have one

[16:25] <audreyt> just tell me what to emit :)

[16:25] <luqui> where is it so I can tell it?

[16:25] <luqui> rather, where do I tell it?

[16:25] <audreyt> it's in http://svn.openfoundry.org/pugs/src/Text/Parser/Rule.hs

[16:25] <Juerd_> Oh, are we at the point yet where we can try my XML grammar, that was written over 3 years ago?

[16:25] <audreyt> see "data Rule"

[16:25] <audreyt> Juerd_: I believe so

[16:25] <Juerd_> http://perlmonks.org/index.pl?node_id=179755 if you feel like it. I lack the guts.

[16:25] <audreyt> where is it again?

[16:26] <audreyt> mm, preempted

[16:26] <Juerd_> Also, http://groups.google.com/group/perl.perl6.language/browse_frm/thread/76d4ea76b181e160/e99e0455a5a65b9f#e99e0455a5a65b9f

[16:26] <luqui> audreyt, alright, looks straightforward enough

[16:26] <audreyt> luqui: you can easily write a Pretty instance for it

[16:26] <audreyt> luqui: yeah, I think it's kinda nice :)

[16:26] * Juerd_ read that as "write a pretty insane for it"

[16:26] <luqui> :-)

[16:28] <audreyt> Juerd_: which one? the latter (complex) one?

[16:29] <audreyt> (in the perlmonk post)

[16:29] <Juerd_> audreyt: The google thing is a p6l post, which links to the perlmonks one

[16:29] <Juerd_> Oh, let's see

[16:29] <Juerd_> It's the long one alright, although it's truncated

[16:29] <gaal> audreyt: how do I slurp in an enum definition from a .h with FFI?

[16:29] <Juerd_> You can run the Perl 5 script using the XML spec document as input to re-generate.

[16:29] <audreyt> I also see   # Large block manually removed.

[16:29] <audreyt> Juerd_: heh... maybe tomorrow

[16:30] <Juerd_> Certainly some tweaks are needed, as this is 2002-age Perl 6 :)

[16:30] <audreyt> I thought you did run it against pge at one point

[16:30] <audreyt> and discovered impossible memory leaks

[16:30] <audreyt> gaal: use #enum, perhaps

[16:31] <Juerd_> audreyt: Hm, interesting. All I got out of it when I wrote that p6l writeup was segfaults

[16:31] <audreyt> gaal: see http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html

[16:31] <gaal> audreyt: that means duplicating it yes? I don't mind (it's small) but I thought there was a better way

[16:31] <gaal> audreyt: that's one of the docs I'm looking at

[16:31] <Juerd_> How does one debug a grammar anyway, even if it does compile?

[16:31] <audreyt> the better way involves c2hs

[16:31] <audreyt> which I don't yet know

[16:32] <audreyt> Juerd_: you can look at the excellent error mesg

[16:32] <Juerd_> Yeah, but if you haven't written the grammar yourself, and it's quite mechanical as this one is, I doubt that'll help much :)

[16:32] <audreyt> then you'll need a tracer :)

[16:32] <gaal> Yet Another Dependency, Don't Add

[16:33] <Juerd_> And - sometimes there is a match, but it's the wrong match. Then there's no error message 

[16:36] <svnbot6> r8548 | audreyt++ | * a zero-length string is also a valid beginning of line.

[16:37] <audreyt> $ ./pil -r 'c | a$' 'az'

[16:37] <audreyt> Expecting: 'c' at line 1, column 1 Or: end of input at line 1, column 2

[16:37] <audreyt> hm, the "Or" is actually a separate line.

[16:37] * audreyt very much likes this error reporting.

[16:37] <Alias_> weird casing

[16:38] <audreyt> Expecting: 'c' at line 1, column 1

[16:38] <svnbot6> r8549 | audreyt++ | * err. never mind last commit. it should be fixed at FPS level...

[16:38] <audreyt>        Or: end of input at line 1, column 2

[16:38] <Alias_> Still weird casing

[16:38] <audreyt> makes more sense when it's lined up

[16:38] <audreyt> you think "or:" is better?

[16:38] <Alias_> or OR

[16:38] <Alias_> reminds me of W3C specs

[16:39] <Juerd_> audreyt: expecting [ 'c' at line 1, column 1 | end of input at line 1, column 2 ]

[16:39] <audreyt> Juerd_: maybe, but that gets long

[16:40] <Juerd_> I think that in general, "line 1, column 2" could use a much shorter form. I'd suggest ":1,2"

[16:40] <svnbot6> r8550 | audreyt++ | * Text.Parser.Rule: change "Or:" to "or:" in error message,

[16:40] <svnbot6> r8550 | audreyt++ |   so Alias++ won't have W3C-related nightmares.

[16:40] <gaal> :93

[16:40] <gaal> oops

[16:40] <Juerd_> Hm, not ",", because that's used in ed..vim for other ranges

[16:41] <audreyt> also note it's the usual parsec format

[16:41] <Juerd_> audreyt: It wasn't a serious suggestion, the [ foo | bar ] one

[16:41] <audreyt> because that lets us say "column 2-14"

[16:41] <audreyt> to denote a range

[16:41] <Juerd_> audreyt: :1:2..14

[16:41] <audreyt> ok :)

[16:41] <audreyt> Juerd_: nah. :)

[16:42] <Juerd_> I am serious about wanting a short form. I just don't know yet what I like.

[16:42] <audreyt> yeah, and it will in any case be an object you can query from

[16:42] <Juerd_> But "at foo.pl line 5" reads much better as "(foo.pl:5)"

[16:42] <audreyt> and you can happily redefine its coercion however you want :)

[16:42] <Juerd_> Because it's shorter, and the position is relevant to the programmer onlyway.

[16:42] <Juerd_> s/onlyway/only anyway/  # what happened to my keystrokes?

[16:43] <audreyt> stevan: hm, I wonder if we should go all the way with roles.

[16:43] <stevan> audreyt: how so?

[16:43] <audreyt> stevan: instead of having this very very adhoc list of methods and role groupings, actually make use of role hierarchy for all plurals

[16:44] <audreyt> basically, just copy http://scala.epfl.ch/docu/files/api/index.html ;)

[16:44] <audreyt> which is much better thought out that quickref and the current synopses

[16:45] <stevan> audreyt: I am working on something similar already :)

[16:45] <audreyt> ooh.

[16:45] <stevan> I am basically just starting with the quickref as a guide for now,.. to make sure things work as we expect

[16:46] <audreyt> cool... please do consider the scalar/collection/* traits

[16:46] <audreyt> it's currently the one that makes most sense to me

[16:46] <gaal> hmmm, I want to pass a string literal to a c function (CString). Can I convert it on the fly or do I need to alloca etc?

[16:46] <audreyt> gaal: withCString

[16:47] <gaal> ah, great.

[16:47] <gaal> thanks

[16:47] <audreyt> np :)

[16:47] <audreyt> and if you are in the FPS land, useAsCString

[16:47] <audreyt> or if you are letting the C world modify the FPS, unsafeUseAsCString.

[16:48] <gaal> nope, it's a constant (so in principle can be global)

[16:48] <audreyt> k

[16:48] <gaal> "string"

[16:48] <audreyt> withCString "string" $ \cs -> ...

[16:48] <audreyt> is the idiom

[16:49] <gaal> yeppers

[16:51] <stevan> audreyt: ok, r8551 is the first stab at all this

[16:51] <svnbot6> r8551 | stevan++ | PIL/Native/Bootstrap.pil

[16:51] <svnbot6> r8551 | stevan++ | - first stab at adding roles to "boxed" types, all seems

[16:51] <svnbot6> r8551 | stevan++ |   to be going well, although we need several things which

[16:51] <svnbot6> r8551 | stevan++ |   I have noted in the source. We need to write some tests

[16:51] <svnbot6> r8551 | stevan++ |   for the ::rArray role as well. More planning as well. 

[16:51] <stevan> I realized I need Pair object

[16:52] <stevan> but I should be able to create that completely in PILN

[16:53] <audreyt> Pair is going to be our first value composite

[16:53] <stevan> and with .join, we need a notion of string context maybe

[16:53] <audreyt> no contexts please

[16:53] <audreyt> MMDs yes, but not contexts

[16:54] <stevan> no your right

[16:54] <stevan> as_str should work

[16:54] <audreyt> yup

[16:54] <audreyt> context is just a way for the compiler to cheat with the runtime to insert cast calls, in a very unreliable way

[16:54] <stevan> yes

[16:54] <audreyt> it's totally not the runtime's duty to intuit them :)

[16:55] <audreyt> stevan: though I think builtin ::Pair makes sense too

[16:55] <stevan> why? speed?

[16:55] <audreyt> no, constraints

[16:55] <audreyt> not using p6opaque layout

[16:55] <stevan> ?

[16:55] * audreyt is thinking

[16:56] <audreyt> a Pair with two value objects should not be itself mutable, right?

[16:56] <stevan> why not?

[16:57] <audreyt> (1 => 2) = "3";

[16:57] <audreyt> it doesn't assign into the pair so it becomes (1 => 3)

[16:57] <audreyt> that would be absurd

[16:57] <audreyt> at least imvvho :)

[16:57] <stevan> yes

[16:57] <audreyt> but yet

[16:57] <stevan> but $p := (1 => 2); $p.set_key(3); should work

[16:58] <audreyt> ah, so your Pair is more like a size-bounded array

[16:58] <audreyt> in that case, sure, just inherit from ::Array

[16:58] <stevan> yeah basically

[16:58] <stevan> I could see a need for a immutable version too

[16:58] <audreyt> although I'm not sure it's the perl6 ::Pair's behaviour

[16:58] <audreyt> which are immutable

[16:58] <stevan> hmm

[16:59] <audreyt> and can be used in value positions

[16:59] <stevan> but thats Perl 6,.. 

[16:59] <stevan> I can make them immutable I guess

[17:00] <audreyt> nah, just use whatever fits. what's a few fetch/store calls among friends :)

[17:00] <stevan> yes :)

[17:01] <stevan> if I dont need them mutable, then I will make them immutable

[17:01] <stevan> I was mostly thinking about partial construction

[17:01] <audreyt> *nod*

[17:01] <stevan> but I suppose I can avoid that easily enough

[17:03] <stevan> ok, I will work more on this tonight

[17:03] <stevan> lunch time now &

[17:04] <luqui> Juerd_, have you ever used Parse::RecDescent?

[17:06] * luqui begins to wonder whether virtual classes are actually *better* than parameterized types

[17:06] <luqui> or whether they are exactly equivalent

[17:06] <luqui> (then it's only a cognitive issue)

[17:06] <Alias_> luqui: nerd :)

[17:06] <luqui> ?

[17:07] <Alias_> oh wait... we're here. Everyone's that way

[17:07] <Alias_> :)

[17:07] <luqui> yeah...

[17:07] * luqui wonders why Alias_ chose to say that *now*

[17:07] <Alias_> flashbacks

[17:07] <Alias_> never mind

[17:08] <Juerd_> luqui: Yes, once or twice

[17:08] <Juerd_> afk  3 food

[17:08] <luqui> Juerd_,  have you used the trace feature?

[17:08] <Juerd_> No

[17:09] <Juerd_> s/3/#/

[17:09] <luqui> oh

[17:09] <luqui> it is profoundly annoying

[17:09] <luqui> research in debugging grammars needs to happen

[17:09] <luqui> thanks for pointing that out, it's on my mind now :-)

[17:09] <audreyt> luqui: huh? write a virtual class to represent [a]?

[17:10] <audreyt> what's the type of the cons function (:) ?

[17:13] <audreyt> hm, how do I attach POST blocks to rules?

[17:13] <luqui> audreyt, what would they mean?

[17:14] <audreyt> rule literal { undef | true | false }

[17:14] <audreyt> now suppose I don't want a match obj

[17:14] <audreyt> but actually want a literal object

[17:14] <audreyt> I can write another AG outside to match stuff

[17:14] <audreyt> but then that means I can't do the normal combinatorial parsing on something that calls <literal> and expect to get a Literl obj

[17:14] <luqui> I'm thinking AG is how you do that kind of stuff.  You always have to return a match object.

[17:15] <luqui> hmm

[17:15] <audreyt> and as such can't do conditional parsing easily

[17:15] <audreyt> always need to consume all

[17:15] <luqui> well, grammar Foo is short for class Foo is Match

[17:15] <audreyt> or rely on adhoc "fail" closures

[17:15] <audreyt> yes, and at this point you'll tell me to write wrapper methods

[17:15] <luqui> hmm?

[17:15] <audreyt> rule _lteral { undef | true | false }

[17:15] <luqui> I will?

[17:16] <luqui> oh, no, that's not what I was thinking

[17:16] <luqui> If you have information you want to return from the match, it is an instance of the grammar.

[17:16] <luqui> but that's broken

[17:16] <audreyt> method literal { ... match self._literal and do things with it ... }

[17:16] <audreyt> thanks, I too think it's broken :)

[17:17] <luqui> I mean having instance data in the match object

[17:17] <luqui> (also wrapper methods are broken)

[17:17] <luqui> or kludgey at the least

[17:17] <audreyt> yeah. there should be sugar to gen wrapper methods

[17:17] <luqui> audreyt, do you have an idea of how it should look?

[17:17] <audreyt> or better, attach AG-like things to rules

[17:17] <audreyt> yes, I do

[17:18] <luqui> do tell

[17:18] <luqui> I'm about to compose a message to p6l about rules

[17:18] <luqui> maybe you can delay it while I incorporate more stuff

[17:19] <audreyt> rule literal :POST{Lit.new($/)} { undef | true | false } 

[17:19] <audreyt> it's even valid perl6.

[17:19] <audreyt> (because POST blocks are just closure traits.)

[17:19] <luqui> do POST blocks return, or just side-effect?

[17:19] <audreyt> I don't know. if they are sideeffect only

[17:20] <audreyt> rule literal :POST{$/ = Lit.new($/)} { undef | true | false } 

[17:20] <luqui> that's bad

[17:20] <audreyt> I can live with that.

[17:20] <luqui> Lit needs to obey the Match interface

[17:20] <audreyt> does it? why?

[17:20] <audreyt> that's the thing I don't grok about rules

[17:20] <luqui> because rules use the match interface to figure out where to continue parsing, etc.

[17:20] <audreyt> why do they have to --> Match ?

[17:20] <pasteling> "gaal" at 192.115.25.249 pasted "marshalling woes" (41 lines, 1.5K) at http://sial.org/pbot/15203

[17:21] <audreyt> luqui: but that's what they matched, not what they yielde

[17:21] <luqui> audreyt, it's kind of like parsec.  Rules have to -> RuleParser a

[17:21] <audreyt> luqui: the engine of course knows what matched

[17:21] <luqui> we just aren't that cool

[17:21] <gaal> I'm freezing as a Sycknode, and thawing as a YamlNode, but I'm not sure that matters

[17:21] <audreyt> luqui: ah, but there's "a"

[17:21] <luqui> yep

[17:21] <gaal> could I be missing an indirection?

[17:21] <audreyt> what you are saying is Rules have to (IsMatch a) => RuleParser a

[17:21] <luqui> audreyt, which is why we need to do something about it

[17:21] <audreyt> which parsec does not impose, but rules do

[17:22] <audreyt> and that sucks.

[17:22] <luqui> audreyt, that's not true

[17:22] <luqui> I'm saying that the "a" in the Match object ends up being a member

[17:22] <gaal> readNode fwiw does   ptr     <- peek . castPtr =<< peek nodePtr

[17:22] <gaal> which is *two* peeks more than I do.

[17:22] <luqui> rather than a monadic bindable thingy

[17:23] <luqui> but all in all, I think we need AG-attachables

[17:23] <Debolaz> Aight, pkgsrc now has dynamically built parrot. :)

[17:23] <audreyt> luqui: oh, I missed the "member" bit

[17:23] <audreyt> that does make it very hard to typecheck.

[17:23] <audreyt> unless Match parameterizes on the ::a.

[17:23] <luqui> not with parameterized classes..

[17:23] <luqui> but yes

[17:24] <audreyt> the good thing about PArrows and Parsec is that if you don't consume things properly, your rule doesn't compose

[17:24] <audreyt> it's almost like saying

[17:24] <audreyt> our Lit rule foo { ... }

[17:24] <audreyt> and the <foo> will operate with that knowledge

[17:25] <audreyt> but then, without attachable consumers, it doesn't matter if the knowledge is there, as nobody will use it after parse completion

[17:25] <audreyt> which means attachable consumers is a must

[17:25] <luqui> attachable consumers?

[17:25] <audreyt> and the current ways (bracket followed by a {...//fail}; wrapper methods; POST blocks that assigns $/) are kinda ugly

[17:26] <audreyt> "functions consuming the match that you can attach to a rule"

[17:26] <luqui> I don't really follow

[17:26] <audreyt> 18:22 < luqui> but all in all, I think we need AG-attachables

[17:26] <luqui> oh, yeah, I think I do

[17:26] <audreyt> the same thing you are calling AG-attachables.

[17:26] <luqui> uh, really?

[17:27] <luqui> I'm just talking about being able to define an AG inline with a grammar

[17:27] <audreyt> yes, that's exactly what I'm talking about.

[17:27] <audreyt> AGs are even nicer because they simplify traversal.

[17:27] <audreyt> I'm using haskell Generics for the same purpose

[17:28] <audreyt> but if AGs can be declared alongside rules -- and trigger at partial, not only complete match -- that'd rock

[17:28] <luqui> there are of course problems with triggering at partial match

[17:28] <luqui> but those problems should only arise when you do something impossible

[17:28] <audreyt> which is already broken anyway.

[17:28] <audreyt> (note that in UUAG, they do trigger at partial match)

[17:28] <audreyt> because of lazy evaluation and all that.

[17:28] <luqui> yeah

[17:29] * luqui is convinced that lazy evaluation is better than compilation

[17:29] <audreyt> so you can use partial results and pretend they happened

[17:29] <luqui> because it is more flexible

[17:29] <audreyt> you should see the mdo notation I've been raving about :)

[17:29] <luqui> you mean the syntax around Monad.Fix?

[17:29] * luqui has seen that

[17:30] <audreyt> just replace "do" with "mdo" and you can refer to anything in a block inside it regardless of sequence, just like let-block

[17:30] <audreyt> yeah. PILN now uses it in class bootstrapping

[17:30] <luqui> unfortuantely, there is no parsec Monad.Fix instance

[17:30] <audreyt> fortunately, we can make PArrows an ArrowFix.

[17:30] <luqui> really!?

[17:31] <luqui> I thought that there was no Monad.Fix for parsec for a reason

[17:31] <luqui> because it's impossible

[17:31] <audreyt> yes

[17:31] <audreyt> but PArrows is not a monad

[17:31] <audreyt> and will never be

[17:31] <luqui> hmm..

[17:31] <audreyt> because it doesn't do monadic application

[17:31] <audreyt> it's just glorified CPS :)

[17:31] <luqui> I still wonder how that works

[17:31] <audreyt> in which fixpoints are obvious.

[17:31] <luqui> you can refer to information that you haven't parsed yet...

[17:32] <luqui> does it just diverge then?

[17:32] <audreyt> ...as long as you can obtain it without strictly depending on information you are computing toward

[17:32] <audreyt> otherwise it diverges, yes

[17:32] <luqui> it would be nice if perl 6 were lazier

[17:33] <audreyt> it's already quite lazy :)

[17:33] <luqui> audreyt, ?

[17:33] <luqui> it's call-by-value...

[17:33] <audreyt> you can explicitly mark lazy streams producers and consumers

[17:34] <audreyt> and closure creation is inexpensive

[17:34] <luqui> but you would have no chance of writing fix the haskell way

[17:34] <audreyt> heh... haskell can't write the untyped lambda-calculus fix either

[17:34] <luqui> well, I guess you could do it with closures

[17:34] <audreyt> win some lose some :)

[17:35] <audreyt> oh wait, you can do that in haskell with unsafeCoerce# ;)

[17:35] <luqui> :-p

[17:35] <luqui> okay, so inline AGs

[17:36] <luqui> the thing that makes them hard is that they really ought to be *inside* the rule definitions, which I find yucky

[17:36] <luqui> because the implementations differ based on which alternation you take

[17:38] <audreyt> sure

[17:38] <audreyt> but that's fine

[17:39] <luqui> well, the thing I don't like about Parser.hs

[17:39] <audreyt> /:proc{...} .../

[17:39] <luqui> is that you can't see the grammar

[17:39] <audreyt> also

[17:39] <luqui> it's just code

[17:39] <luqui> you kind of lose that declarative flavor

[17:39] <audreyt> /[:proc{...} alt1 ] | [:proc{...} alt2 ]/

[17:39] <audreyt> and you can also lift the :proc to outside

[17:39] <audreyt> rx:proc{...}//

[17:39] <wolverian> not just :{}?

[17:40] <audreyt> :{} worksforme too

[17:40] <luqui> wolverian, yeah, we could make that a shorthand

[17:40] <audreyt> and I'd really like it to return something

[17:40] <audreyt> not just augmenting $/

[17:40] <luqui> is there a way to pull the proc out further, but still depend on which alternation was taken

[17:41] * luqui can't think of anything offhand

[17:41] <luqui> audreyt, you would return something through the "ret" attribute or some such

[17:41] <wolverian> (I don't even like $/)

[17:41] <luqui> again, we could shorthand canonical returns if we like

[17:42] <luqui> wolverian, you mean you don't like how it looks?

[17:42] <audreyt> rule value { \d+ }

[17:42] <audreyt> rule leaf :{.min = $<value>} { <value> }

[17:42] <wolverian> I don't like that it's a variable. just return the match object

[17:43] <luqui> wolverian, how do you refer to the match object you're currently constructing

[17:43] <luqui> audreyt, that has its own problems

[17:43] <wolverian> luqui, maybe I like it inside rules, then, but not outside. 

[17:43] <luqui> rule leaf :{.pos = $<value>.from} { <value> }

[17:43] <luqui> wolverian, then do you dislike $1, $2, ... too?

[17:43] <wolverian> luqui, yes. vehemently

[17:43] <audreyt> luqui: what's wrong with that?

[17:44] <luqui> audreyt, nothing, unless we go with what you suggest

[17:44] <luqui> oh wait

[17:44] <luqui> no, yours is fine too

[17:44] <luqui> because of how match objects numify

[17:44] <audreyt> yeah.

[17:44] <audreyt> me and pmichaud argued for that.

[17:44] <luqui> okay, I thought you were arguing for return value stuff

[17:45] <luqui> wolverian, you like $1, $2, but you don't like $/...

[17:45] <luqui> even though $1 is shorthand for $/[1]

[17:45] <wolverian> luqui, I _don't_ like them, sorry.

[17:45] <luqui> oh

[17:45] <audreyt> if I have access to bothway propagation, I'm fine with having to pull it out from $/

[17:46] <luqui> well in that case your argument is solid

[17:46] <luqui> and I simply disagree

[17:46] <luqui> by bothway propagation, you mean inh and syn?

[17:46] <audreyt> yup

[17:46] <audreyt> rule literal :{Lit.new($/)} { a | b | c }

[17:46] <audreyt> now, I do like that a lot

[17:46] <audreyt> and it'd be wonderful if we can have it

[17:47] <wolverian> luqui, that's fine, I trust others to make this decision. it's just a pet peeve from perl5, where I always my ($foo, $bar) = ... =~ ...; probably because I'm not sure if the $n variables reset or not. :)

[17:47] <luqui> so you would like the return value of :{} to go into a canonical attr?

[17:47] <audreyt> as it saves a lot of unneccessary shipping around of match data

[17:47] <luqui> wolverian, ahh, but in perl 6 they're lexical

[17:47] <luqui> so you don't have to worry anymore

[17:47] <audreyt> I thought they are environmental.

[17:47] <audreyt> luqui: yes. and maybe pull it out as $$/. or maybe that's too gonzo.

[17:47] <luqui> $/ is env?

[17:48] * luqui is tempted to introduce another punctuation var

[17:48] * luqui slaps himself

[17:48] <audreyt> luqui: S02

[17:48] <audreyt> larry conjectured that $! and $/ are made env

[17:48] <audreyt> which will make dduncan and I very very happy

[17:49] <luqui> why?

[17:49] <audreyt> we tried to lobby him to drop the "Conjectural:" bit

[17:49] <audreyt> hadn't yet happened

[17:49] <audreyt> $! is obvious because it was a global

[17:49] <audreyt> which just doesn't make sense

[17:49] * luqui thought it was lexical

[17:49] <audreyt> and complicates error handling

[17:49] <audreyt> no. S02:

[17:49] <audreyt> Certain of these global values may retain punctuational

[17:49] <audreyt> shortcuts, such as $!  for $*ERROR.

[17:49] <luqui> yuck

[17:50] <luqui> okay, so env is the next best option

[17:50] <audreyt> can we please make it die?

[17:50] <luqui> so why do you want them to be env instead of lex?

[17:51] <audreyt> because otherwise you can't write your own &catch?

[17:51] <luqui> audreyt, why not?

[17:51] <audreyt> catch($!); # right, that works

[17:51] <audreyt> but it's kinda convenient to have them as $+!

[17:51] <luqui> you can also do it: catch {...}

[17:51] <luqui> well, kinda annoying too

[17:52] <luqui> because you need to test $! immediately after you try, lest some other function mess with it

[17:52] <audreyt> also, in the CATCH blocks

[17:53] <luqui> what about them?

[17:53] <audreyt> they get bound to $_ also

[17:53] <audreyt> which is lexical

[17:54] <audreyt> so there's no reason to make $! global, even if you want to let CATCH modify it.

[17:54] * luqui is convinced that $! shouldn't be global

[17:54] <luqui> i'm trying to figure out whether it should be env or lex

[17:54] <audreyt> so, if it's lex. how is it declared?

[17:55] <luqui> what do you mean declared?

[17:55] <luqui> it's declared the same way $_ is

[17:55] <luqui> i.e. implicitly (I know, it'd be nicer to have them more like "regular" variables than special implicit ones)

[17:56] <luqui> (but I think that the env/lex distinction outweighs that aesthetic argument)

[17:56] <audreyt> so, each scope has an implicit $!.

[17:56] <luqui> each try {} introduces a $!

[17:56] <audreyt> in its caller's scope.

[17:56] <luqui> yeah

[17:57] <audreyt> so it needs to be environmental. qed :)

[17:57] <luqui> very nice, but:

[17:57] <Debolaz> audreyt: Hmm, I've got a shared parrot library in the right location now, but pugs seems to prefer trying to use the static library?

[17:58] <audreyt> Debolaz: oh? hm. how about you removing the .a?

[17:58] <luqui> sub trace($msg) { try {...};  $*ERR.say: $msg }   CATCH { trace "Got here";  when X::Foo {...} }

[17:58] <luqui> er

[17:58] <luqui> wait

[17:58] <luqui> wrap a try {...} around that CATCH

[17:59] <audreyt> $*ERROR and $*ERR conflicts

[17:59] <luqui> huh?

[17:59] <audreyt> another ergonomic reason among the 1,048,576 ones that $! shoudl not be global

[17:59] <luqui> I meant STDERR

[17:59] <audreyt> (nvm, I'm ranting some other point)

[18:00] <audreyt> so, what is it trying to do?

[18:00] <audreyt> thr try{} inside trace won't modify anything that CATCH does

[18:00] <luqui> why?

[18:00] <audreyt> because the $! is environment al at &trace level

[18:00] <audreyt> and $+! stops at first frame

[18:00] <audreyt> not two frams back

[18:01] <audreyt> need $CALLER::CALLER::! to get to the CATCH frame

[18:01] <luqui> oh... so I was misunderstanding env vars

[18:01] <audreyt> yeah. they are just like haskell implicit vars with proper shadowing.

[18:01] <luqui> okay good

[18:01] <audreyt> so can we please have $! and $/ environmental? :)

[18:01] <luqui> env makes sense to eme then

[18:01] <luqui> s/eme/me

[18:02] <luqui> sure, got my vote

[18:02] <luqui> because the design process is oh so democratic

[18:02] <luqui> I feel uneasy about changing it in the syn if Larry was uneasy

[18:02] <audreyt> hm, a Syn patch sent to p6l then?

[18:03] <audreyt> (or to 6p, if it's warranted)

[18:03] <luqui> (the thing I don't like is that I get much quicker responses on 6p)

[18:03] <luqui> (but I like to keep everything out in the open)

[18:03] <luqui> I'll p6l it

[18:04] <audreyt> danke

[18:04] <luqui> oh, I didn't realize that $_ was also env

[18:04] <luqui> hmm.. does that mean:

[18:04] <luqui> sub foo() { .say }   given "quux" {  foo(); }  # says quux

[18:05] <luqui> I kinda like that and I kinda don't.

[18:08] <audreyt> no, it doesn't say quux

[18:08] <audreyt> because it's environmental, and you can't see your caller's $_ by writing $_.

[18:08] <audreyt> you have to write $+_.

[18:08] <audreyt> $_ only reaches to OUTER.

[18:08] <audreyt> which is why there is no twigil for OUTER.

[18:09] <luqui> aa soo

[18:09] <luqui> coolness

[18:09] <luqui> okay, then everything makes sense and feels warm and fuzzy to me

[18:09] <luqui> oh, btw, what was $/ before?

[18:10] <Juerd_> luqui: I've once used a regex demonstration tool that would show different parts of the regex, and the match, in different colours. This isn't feasible for entire grammars, but something like it would be great.

[18:10] <Juerd_> luqui: I think visual debugging may be the only way to debug a grammar without getting insane :)

[18:10] <luqui> Juerd_, it's quite possible

[18:11] <luqui> two windows: one with the text with the part that has been matched by the rule highlighted

[18:11] <luqui> the other with the current rule...

[18:11] <Juerd_> I was thinking of a two-pane thing

[18:12] <Juerd_> Well, three.

[18:12] <audreyt> luqui: $/ was "implicitly lexical"

[18:12] <luqui> splain

[18:12] <Juerd_> I'll try to draw it tonight to show you

[18:12] <luqui> audreyt, okay.  I don't have such a strong argument for that one then

[18:12] <luqui> Juerd_, schweet

[18:12] <Juerd_> It's a very rough idea

[18:12] <audreyt> luqui: among the three surviving punctuations, two are env and one is lex

[18:12] <Juerd_> But it's been in my mind for a few days, so it's a good thing to let it out and have others think of the details :)

[18:13] <audreyt> luqui: also, it makes some sense to call into another_sub

[18:13] <audreyt> and let it see your $1 and $2

[18:13] <audreyt> without passing $/ around

[18:13] <audreyt> as we currently do in p5 a _lot_

[18:13] <audreyt> and $+1 is a good compromise.

[18:14] <luqui> audreyt, what are these punctuations.  Are you just talking about $_ $/ and $!?

[18:14] <audreyt> yes.

[18:14] <audreyt> there's only three, instead of 16,384.

[18:14] <luqui> which one is lex?

[18:14] <audreyt> $/, currently.

[18:14] <audreyt> $_ is env, $! is global (and we better get that changed)

[18:14] <luqui> ahh.  so you meant to say one is env, one is lex, and one is global

[18:15] <luqui> which has a nice symmetry to it.  Too bad it's so wrong.

[18:15] <audreyt> yes, but after $! is renormalized to env, it makes sense to make $/ env too for consistency and convenience

[18:15] <luqui> agreed

[18:15] <audreyt> and larry put the "conjecture" in S02 that groups $/ and $! together

[18:15] <audreyt> and as such he must've already thought about it

[18:15] <audreyt> just need to take down the horrible "$! is alias to $*ERROR" line from S02 and remove the "conjecture" line

[18:16] <luqui> audreyt, how do I find the IRC logs starting where we started this conversation?

[18:16] <luqui> should $! have a synonym?

[18:16] <luqui> sorry, a SYNONYM?

[18:17] <luqui> is it $+ERROR, or $?ERROR?

[18:17] <audreyt> luqui: irc.pugscode.org

[18:17] <audreyt> and click on the right pane

[18:17] * luqui knows about that

[18:18] <audreyt> to obtain a "#name"

[18:18] <luqui> ahh the right pane

[18:18] <luqui> my browser was hiding that

[18:18] <audreyt> I'm fine with $+ERROR.

[18:18] <audreyt> as is $+TOPIC and $+MATCH.

[18:18] <audreyt> and the current-scope ones can be $?ERROR if you so prefer.

[18:19] <luqui> it feels weird to have $TOPIC not refer to $_

[18:19] <luqui> if $+TOPIC refers to $CALLER::_

[18:20] <audreyt> otoh, the implicitness makes $?TOPIC attractice.

[18:20] <audreyt> attractive, even.

[18:20] <audreyt> $+?TOPIC # ugh.

[18:21] <audreyt> nah. too silly.

[18:21] <audreyt> I vote for no SYNONYM forms unless explicitly declared.

[18:21] <luqui> I'll punt on defining those for now

[18:21] <audreyt> yes.

[18:23] <Khisanth> heh trying to make it look more like cartoon cursing? :P

[18:29] <luqui> I found an argument for $/ to be env

[18:29] <luqui> besides aesthetic appeal:

[18:30] <luqui> $foo.subst(/(bar.*)/, { "foo$+1" })

[18:30] <luqui> hmm

[18:30] <luqui> would $/ be bound there, or would it be bound in the body of subst()

[18:30] <luqui> or...

[18:30] <luqui> that's actually a really weird case

[18:32] <luqui> because the passed-in rule would be called as a subrule

[18:32] <luqui> so $/ would not be set

[18:32] <luqui> would subst bind $/ itself?

[18:32] <luqui> could subst bind $/ on behalf of its caller?

[18:33] <luqui> yeah, I think subst would bind $/ on behalf of its caller

[18:35] <luqui> stepping back to the AG discussion

[18:35] <luqui> I would be satisfied if you could define a rule more than once

[18:35] <Debolaz> -rwxr-xr-x  1 root  wheel  21916667 Jan  1 19:34 pugs

[18:36] <Debolaz> Yay.

[18:36] <theorbtwo> And have them implicitly ored?

[18:37] <luqui> yeah

[18:37] <luqui> well... except for the ordering thing

[18:37] <luqui> since or's are ordered in rules

[18:37] <luqui> but that relates to the post I'm composing now

[18:37] <luqui> of making rules independent of the evaluation strategy

[18:51] <luqui> where'd everybody go?

[18:53] <Debolaz> luqui: Into hiding?

[21:06] <luqui> audreyt, ping

[21:17] <luqui> nevermind

[22:09] <Juerd_> luqui: I can't draw it, because the gimp is terribly frustrating and being counter productive.

[22:19] <gaal> weird. make works fine; make ghci gives a wrong(!) error about NoSuchMethod not accepting an argument in Pugs.Eval. Has anyone seen this?

[22:39] <gaal> yo anatolyv 

[22:39] <anatolyv> oh hey

[22:40] <luqui> Juerd_, :-(

[22:40] <luqui> it does that

[22:42] <luqui> gaal, looks like a ghc bug

[22:42] <Juerd_> luqui: I've used good old ballpoint and paper :)

[22:42] <gaal> luqui: yeah :/

[22:42] <Juerd_> luqui: http://juerd.nl/rule.jpg

[22:43] <luqui> gaal, you can hack around it by changing NoSuchMethod cls to NoSuchMethod {}  and removing the reference to cls

[22:43] * luqui examines Juerd_'s picture

[22:44] <gaal> yeah, the weird {} hack was mentioned here just the other day, no?

[22:44] <gaal> anyway I found GHCi doesn't work on colinux where I wanted it so it don't matter.

[22:44] <luqui> I don't think that {} is a hack

[22:44] <luqui> but I think that using it in this situation would be hacking around the problem

[22:45] <luqui> Juerd_, when you say "without alternations or subrule names"

[22:45] <luqui> how far down the chain do you go?

[22:45] <Juerd_> Just the raw things that actually matched.

[22:45] <gaal> I meant Just {} and was it Nothing {} is.. interesting

[22:46] <Juerd_> So characters and quantifiers at most.

[22:46] * gaal is reading the fisrt SYB paper... wonderful!

[22:46] <luqui> Juerd_, hmmm... it might be nice to see the abstraction too, though

[22:46] <luqui> I like the "without alternations" bit

[22:46] <luqui> flattening the rule, as it were

[22:46] <Juerd_> So that if "x" was matched by an "x", it's an "x", while if it were matched as a "\w", it'd be clearly "\w"

[22:47] <Juerd_> luqui: To know which rule it was, just click it to select that rule in the lower pane

[22:47] <luqui> you might get more insight from seeing the rule name though.  I.e. if "34too" matched <id>, you know something's wrong

[22:47] * luqui looks again

[22:47] <Juerd_> luqui: As rules may be nested n deep, I don't think it's doable to have the rule names in the match document view.

[22:47] <luqui> so the Grammar pane would have a cursor wherever that rule was in the "call stack"?

[22:48] <luqui> you might be right

[22:48] <luqui> so where do you see the rule call stack?

[22:48] <Juerd_> The rule call stack is visualized by the nested coloured boxes

[22:49] <Juerd_> I had just one colour pen :)

[22:49] <luqui> uh...

[22:49] <luqui> that stack can get really deepo

[22:49] <luqui> s/o$//

[22:49] <Juerd_> Then it can get really many boxes :)

[22:50] <luqui> maybe you can prune those with the mouse

[22:50] <luqui> like you show a textual call stack, and then you select the ones you want to see boxes for

[22:50] <Juerd_> What's pruning?

[22:51] <Juerd_> I'm imagining useful KDE-like tooltip popups, by the way.

[22:51] <luqui> oh, are you envisaging using this on a completed match or a in-progress match?

[22:51] <Juerd_> What's the difference?

[22:52] <Juerd_> I'm not familiar with the terminology

[22:52] <luqui> no, but you have a cursor, so it must be in progress

[22:52] <luqui> well, I was asking if it showed you the string and how the rule *ended up* finding a way to match ir

[22:52] <luqui> it

[22:52] <Juerd_> The cursor does not indicate any kind of "current" position, in the matching engine, in my idea

[22:53] <luqui> oh

[22:53] <luqui> or do you view the dynamic process of the computer trying to match the text

[22:53] <luqui> i.e. with "step" and whatnot from debuggers

[22:53] <Juerd_> No, the result of matching the entire thing

[22:53] <Juerd_> However, updated at real time

[22:53] <luqui> updated wrt what?

[22:53] <luqui> what is changing?

[22:54] <gaal> zzZ &

[22:54] <Juerd_> The rules, because the grammar pane is rw

[22:54] <Juerd_> It's just a text editor, tiny edition :)

[22:54] <luqui> also perhaps the text?

[22:54] <Juerd_> That's a nice idea, but I hadn't thought of it yet.

[22:54] <luqui> To me, the easiest way to debug a grammar would be to put in a bunch of sample strings

[22:54] <luqui> and see if they matched the way I wanted them to

[22:55] <luqui> but others might find tweaking the rules an easier way to debug

[22:55] <Juerd_> And the current cursor position in the grammar editor could just insert some kind of debugging thing into the rule temporarily, to collect a list of positions where it matches.

[22:55] <Juerd_> To visualize that in the match

[22:55] <luqui> I don't quite follow that...

[22:56] <Juerd_> If you have "rule foo { \w+\d+ }" and the cursor is in between \w+ and \d+,

[22:56] <Juerd_> you could insert something like "{ push @POS, .pos }"

[22:57] <Juerd_> And use @POS after the match to indicate where these boundaries between \w+ and \d+ are.

[22:57] <luqui> oh, you're just talking about implementation

[22:57] <Juerd_> aoeusnth234234

[22:57] <Juerd_>         ^

[22:57] <Juerd_> Like so :)

[22:57] <Juerd_> Yes, but only because I thought this would be the easiest way to explain it

[22:58] <luqui> oh, you're explaining the cursor, I get it

[22:58] <Juerd_> Right

[22:58] <Juerd_> I think this mostly (if not completely) eliminates the need for stepping

[22:58] <luqui> hmm... I can't see much use for that offhand

[22:58] <Juerd_> Hm, no, you need stepping because of backtracking. Ignore this.

[22:59] <Juerd_> The use is to link, visualy, the grammar to the document

[22:59] <luqui> it would be nice to have a strategy-independent debugger

[22:59] <luqui> so far it looks like you're describing one

[22:59] <Juerd_> It's somewhat like a reversed breakpoint. It doesn't break, but it does show you where it is :)

[23:00] <Juerd_> Now this may not make sense.

[23:00] <Juerd_> It's hard to describe things that are vague in your own mind.

[23:00] <luqui> I kind of like the "completed match" view of the debugger though

[23:01] <luqui> I was always thinking procedural

[23:01] <Juerd_> Procedural is nice, but as we have a match object with plenty of introspection, it may save a lot of time.

[23:01] <Juerd_> Both writing the debugger, and debugging.

[23:02] <luqui> aye

[23:02] * luqui ponders a debugger for L::AG

[23:03] <luqui> that shouldn't be too hard.  A trace log would give you plenty of information, I think...

[23:03] <luqui> anyway

[23:03] <luqui> that's cool.  Grammar hacking is always difficult, especially with recursive descent systems

[23:04] <luqui> (because one little error somewhere can cause a backtrack and then a completely weird interpretation)

[23:04] <luqui> (ordering dependencies often make trouble too)

[23:04] <luqui> if Perl 6 is going to be the next-generation text processing language, it will be important to have one of these

[23:06] <Juerd_> I totally agree

[23:06] <Juerd_> Perl's most useful debugging feature is -Mre=debug

[23:06] <Juerd_> I use it much more often than the actual debugger

[23:07] <Juerd_> And I've often wanted for the introspection that $/ provides

[23:07] * luqui hasn't seen that module

[23:07] <Juerd_> The huge amounts of output you get from tracking what the regex engine does, really slows down the actual debugging. Most of the time, I just want to know what matched what.

[23:07] <Juerd_> Not? Oh, wow :)

[23:08] <Juerd_> Try it some time :)

[23:08] * luqui is trying it now

[23:10] <Juerd_> Like it?

[23:11] <luqui> woah, this is really detailed aobut how it does it's magic

[23:11] <luqui> it works quite differently from how I expected

[23:11] <Juerd_> It shows the bare guts of some of the optimizations, that's what I like.

[23:11] <luqui> could be useful for implementing a regex engine too

[23:12] <Juerd_> Certainly

[23:12] <luqui> which someone like, oh, say, me, would be interested in

[23:12] <Juerd_> IIRC, mauke used this when writing his

[23:12] <luqui> mauke?

[23:12] <Juerd_> Someone in efnet #perlhelp

[23:12] <Juerd_> Talented hacker.

[23:12] <luqui> someone reimplemented a regex engine?

[23:12] <Juerd_> He wrote a toy language to teach himself how to write a compiler (or interpreter, I don't remember)

[23:13] <Juerd_> With very weird, but regular, syntax

[23:13] <Juerd_> And with regexes.

[23:13] <Juerd_> With again, very weird, but regular, syntax

[23:13] <luqui> heh

[23:14] <luqui> was his syntax different from the weird regular syntax of regexes?

[23:14] <Juerd_> Very.

[23:14] <luqui> ... weird :-p

[23:14] <Juerd_> 00:14 <@Juerd> mauke: What was your toy language again? Where are its files?

[23:14] <Juerd_> 00:14 <@Juerd> mauke: Does it sport documentation?

[23:14] <Juerd_> Now to wait for a reply :)

[23:14] <Juerd_> Feel free to join efnet #perlhelp

[23:15] <Juerd_> 00:15 <@mauke> http://home.cs.tum.edu/~mai/ploki/

[23:23] <luqui> -Mre=debugcolor  # cool

[23:27] <Juerd_> Except there's very little color in there :)

[23:36] <Juerd_> Good night

[23:37] <luqui> gute nacht

[23:40] <Juerd_> Warum auf Deutsch?

[23:41] <luqui> nein

[23:41] <Odin-LAP> O_o

[23:41] <Juerd_> Err :)

[23:41] <Odin-LAP> "Why?" "No." :p

[23:41] <luqui> case in point.

[23:42] <Juerd_> luqui: Ich hoffe, dass du weisst dass ich kein Deutsch sprechen kann

[23:43] <Juerd_> luqui: Also erwart keine Deutsche Antwort :)

[23:44] <Juerd_> IAL - MI NUN IRAS DORMI. GXIS MORGAUX! :)

[23:44] <luqui> Ich weiß, daß Sie Deutsches sprechen können, dumm.

[23:44] <Juerd_> Falsch! Ich kann 's nur tippen und verstehen ;)

[23:45] <Juerd_> Aber ich sagte auf Esperanto dass ich jetzt schlafen gehe; Bis morgen.

[23:45] <Odin-LAP> Esperanto is intriguing.

[23:46] <luqui> Ich Dose "Art" und verstehe sie, auch.  Es gerades Nehmen ich holen zum google.

[23:46] <luqui> G'night Juerd_ 

[23:46] <Odin-LAP> It's just too inflexive, dammit!

[23:47] <luqui> Odin-LAP, phonologically?

[23:49] <Odin-LAP> Haven't the foggiest.

[23:49] * Odin-LAP is thinking of noun declension, mostly.

[23:49] <Odin-LAP> (Yeah. English hates that, too.)

[23:49] <luqui> oh, do you mean "inflective" then?  Or is my terminology messed up?

[23:50] <Odin-LAP> See above.

[23:50] <luqui> hmm?

[23:50] <Odin-LAP> I haven't studied linguistics at a level which makes me learn the English terminology. :/

[23:50] <luqui> ahh, that's what you mean

[23:51] <luqui> I hadn't heard of "inflex", but I assumed it was something like "retroflex"

[23:51] <luqui> but instead, it's just lost in translation

[23:51] <buu> ?join #buubot

[23:51] <luqui> buu, who are you asking to do that?

[23:51] <buu> luqui: The only thing in here that responds!

[23:52] <buu> Except it used to get svnbot, but I see someone fixed it.

[23:54] <buu> wtf?

[23:54] <luqui> and now evalbot is fixed, too :-)

[23:55] <luqui> (but you can still private message him)

[23:55] <buu> er

[23:55] <buu> What do you mean?

[23:55] <luqui> he won't respond to ?join in a public channel

[23:55] <buu> oh

[23:55] <luqui> for the same reason he doesn't respond to ?quit

[23:55] <buu> Well bring him back

[23:55] <luqui> he takes a minute or so to start up

[23:55] <luqui> ah, there he is

[23:56] <buu> Hurrah!

[23:56] <buu> hrm

[23:56] <buu> eval: 1

[23:56] <buu> Hurrah!

[23:58] <theorbtwo> ?eval5 local $x=4; 4

[23:58] <evalbot_8551> Error:  unexpected "l" expecting operator, postfix conditional, postfix loop, postfix iteration, ";" or end of input 

