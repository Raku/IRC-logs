[00:07] <svnbot6> r9610 | lwall++ | Nit in Perl sub call grammar.

[00:10] <Juerd> ruoso++

[00:11] *** chromatic joined
[00:11] <Juerd> You better watch out / You better not cry / You better not pout / I'm telling you why

[00:11] <Juerd> SANTA CLAUSE IS ALREADY HERE :)

[00:12] <Juerd> chromatic: Santa is ruoso; how 'bout that?

[00:12] <chromatic> Trying to figure out why the -o flag doesn't work in the bootstrapped version.

[00:12] <Juerd> Can't help you with that; sorry.

[00:13] <chromatic> Ahh, because it's wrong.

[00:15] <chromatic> Maybe no primitive for open?

[00:17] <chromatic> Looks like it.  How do I add one?

[00:21] *** binary42_ joined
[00:22] <Juerd> I wish I knew. I've only had tuits to watch IRC :(

[00:22] <chromatic> It looks like the first step is defining a grammar rule in Grammar/Perl6.p6.

[00:23] <chromatic> Then defining some behavior in Emitter/Perl5.pm

[00:23] * Juerd has a desk at home that you can electrically adjust in height.

[00:23] <Juerd> I left it in standing height.

[00:23] <chromatic> What's the right grammar rule though?  I wrote:

[00:23] <chromatic>   my $out_fh = open( $output_filename, :w );

[00:23] <Juerd> I got home, tired, parens already sleeping, and now I have to stand

[00:24] <Juerd> It's too noisy to use at night :(

[00:24] <Juerd> s/parens/parents/

[00:24] <Juerd> chromatic: Pick an existing rule and copy it?

[00:24] <chromatic> Yeah, working on that.  Have I ever mentioned that I don't like parsing?

[00:25] <Supaplex> parsing is tEh suck

[00:25] <Juerd> Not that I've read.

[00:25] <chromatic> If only Larry or Patrick were still awake... it's barely 4:25 pm on the west coast!

[00:26] <Juerd> It's 1:26 am here, and I'm about to fall asleep, which is bad given that I'm not sitting.

[00:26] <Juerd> So I better go to bed

[00:26] <Juerd> Good night, and good luck with open

[00:26] <Limbic_Region> [18:26] <TimToady> oyasuminasai!

[00:26] <Limbic_Region> that was an hour ago

[00:27] <TimToady> rehi

[00:28] <chromatic> konnichiwa

[00:29] <TimToady> in a meeting at $work...

[00:29] <clkao> that was a light sleep

[00:30] <clkao> 63min from oyasumi to konnichiwa :p

[00:31] <TimToady> ‰ªÆÂØù desu...

[00:32] <chromatic> It always seems like morning after a meeting ends.

[00:33] *** binary42_ is now known as binary42

[00:33] <TimToady> currently just in mourning

[00:52] *** nivrrex joined
[01:00] *** nivrrex left
[01:21] <chromatic> Aha.

[01:21] <chromatic> I hate parsing.

[01:22] <kattana_> Stop parsing my sentences then!

[01:24] <jisom> what are you parsing?

[01:24] <svnbot6> r9611 | chromatic++ | Added open() and indirect filehandle output support.  (It's ugly but it works.)

[01:24] <jisom> bf?

[01:25] <chromatic> Perl 6.

[01:25] <svnbot6> r9612 | chromatic++ | Add bootstrap target for second-stage lrep bootstrap.

[01:25] <jisom> from the beginning I don't think it ever looked easy to parse

[01:26] <chromatic> There are two problems.  #1, I hate writing parsers.  #2, indirect objects suck.

[01:43] *** arcady joined
[01:50] *** hcarty joined
[01:55] <GabrielVieira> chromatic your modification had worked?

[01:55] <GabrielVieira> i mean print filehandle works well?

[01:56] <GabrielVieira> print $out_fh $code; <-

[01:57] <TimToady> that's illegal p6...

[01:58] <TimToady> it would have to be "print $out_fh: $code"

[01:58] <GabrielVieira> hum

[01:58] <GabrielVieira> just insert : in the code

[01:58] <GabrielVieira> :)

[01:58] <TimToady> or "$out_fh.print: $code"

[01:58] <TimToady> or "$out_fh.print($code)"

[01:58] <GabrielVieira> or.. ?

[01:58] <GabrielVieira> :P

[01:59] <GabrielVieira> looks nice

[02:00] <GabrielVieira> <varscalar> (\.) $op := (print|say|warn|die) (\:) <p6ws>? <list> <p6ws>? \;

[02:00] <GabrielVieira> does it works for the 2∫ one?

[02:01] <avar> what does := do now?

[02:02] <GabrielVieira> gives $op the parentheses inside value

[02:02] <GabrielVieira> inst it?

[02:02] <jisom> so that's in a rule?

[02:02] <GabrielVieira> not yet

[02:02] <chromatic> Oh yeah, I forgot the colon.

[02:02] <chromatic> I'm used to Larry getting it.

[02:03] <GabrielVieira> chromatic :)

[02:03] <chromatic> Let me see if I can fix it.

[02:03] <TimToady> chromatic::

[02:03] <chromatic> I originally thought about doing the direct object invocation, but lrep doesn't do objects yet.

[02:03] <GabrielVieira> chromatic your open function... u goona make read and write too?

[02:04] <TimToady> assuming MMD, print($out_fh,$code) could also conceivably work.

[02:04] <chromatic> Gabriel, maybe.  I haven't needed to use read yet so I didn't do it.

[02:04] <GabrielVieira> $op := (print|say|warn|die) <p6ws> <varscalar> <p6ws>? (\:) <p6ws> <list> <p6ws>? \; # resolves the colon problem in the 1st method?

[02:04] <GabrielVieira> humm

[02:05] <GabrielVieira> chromatic ill look for p6 open documentation

[02:05] <GabrielVieira> i need to be updated

[02:05] <chromatic> I don't think it's right there; I think it needs to be <varscalar> \: or something like that.

[02:05] <GabrielVieira> :P

[02:05] <chromatic> Maybe there should be a rule for indirect object notation.

[02:07] <svnbot6> r9613 | damian++ |  r6@Gort:  damian | 2006-03-16 10:31:40 +1100

[02:07] <svnbot6> r9613 | damian++ |  r7@Gort:  damian | 2006-03-16 12:45:22 +1100

[02:07] <svnbot6> r9613 | damian++ |  Updated Pod semantics to reflect Larry's preliminary input

[02:08] <GabrielVieira> TimToady where is open documentation?

[02:08] <TimToady> I dunno.

[02:08] <GabrielVieira> hum

[02:08] <TimToady> To the first approximation, assume it's the same as P5 but with first argument moved out as return value.

[02:09] <TimToady> probably with real :foo<bar> replacing the in-string arguments.

[02:09] <TimToady> doubtless pugs has some prior art as well...

[02:10] <chromatic> Gabriel, see t/builtins/io/*.t

[02:10] <ayrnieu> E02 makes use of &Main::open

[02:10] <GabrielVieira> chromatic going to :)

[02:10] <ayrnieu> E03, rather.

[02:10] <svnbot6> r9614 | chromatic++ | Changed the filehandle printing to use the proper indirect object notation.

[02:10] <GabrielVieira> ops

[02:12] <GabrielVieira> my $mad = "scientist"; wont work?

[02:13] <GabrielVieira> i'll need to predaclare $mad?

[02:13] <chromatic> Right.

[02:13] <chromatic> Apparently you can't declare and assign to a variable in the same statement.

[02:13] <GabrielVieira> but goona change?

[02:14] <TimToady> eventually, or it's not P6

[02:14] <GabrielVieira> hum

[02:14] <GabrielVieira> it not good =/

[02:14] <GabrielVieira> ist*

[02:14] <GabrielVieira> ops

[02:14] * GabrielVieira sad its :P

[02:14] *** Quell joined
[02:15] <jisom> what are you on, and where can I get some?

[02:17] <TimToady> The porting-howto suggests: open my $fh, "<", $filename or die $!;    ->   my $fh = open($filename, :r) err die $!;

[02:18] <GabrielVieira> chromatic couldnt really have a space betwen the FH and the colon?

[02:18] *** pfenwick joined
[02:18] <GabrielVieira> humm

[02:18] <TimToady> I think space is okay there.  It's the space after the colon that keeps it from turning into, say, :foo or something.

[02:19] <GabrielVieira> but open $fh : $file

[02:19] <TimToady> And we've been careful not to have an infix:<:> operator.

[02:19] <GabrielVieira> wont work

[02:19] <TimToady> why not?

[02:20] <chromatic> My parser rule forbids it, for one.

[02:20] <chromatic> Although that's the only reason...

[02:20] <GabrielVieira> hum

[02:21] <GabrielVieira> what about give arguments in new lines?

[02:21] <GabrielVieira> like:

[02:21] <GabrielVieira> $fh =

[02:21] <TimToady> I think the only place we have to be careful about space before : is in L

[02:21] <TimToady> LABEL:

[02:21] <GabrielVieira> etc..

[02:21] <GabrielVieira> what u mean TimToady?

[02:22] <chromatic> It's ambiguous there?

[02:22] <TimToady> LABEL : goto LABEL; might be a problem.  But don't worry about it.

[02:22] <TimToady> It might not be a problem.

[02:23] <GabrielVieira> ohh

[02:23] <GabrielVieira> i got

[02:23] <GabrielVieira> :)

[02:23] <jisom> doesn't 99% of coding practice have the colon immediately after?

[02:23] <GabrielVieira> TimToady ur right

[02:24] <TimToady> I don't understand your newline question.

[02:24] <ayrnieu> jisom - in labels?  I've never seen it otherwise.  ew.

[02:24] <GabrielVieira> i meant

[02:24] <GabrielVieira> $fh = open

[02:24] <GabrielVieira> $file,

[02:24] <GabrielVieira> rw

[02:24] <GabrielVieira> ;

[02:25] <TimToady> it'd have to be :rw to avoid being a bareword, but other than that, it's fine.

[02:25] <GabrielVieira> a argument per line or whatever its showed

[02:25] <chromatic> I think the problem there is that the current grammar doesn't allow statement assignments to follow variable declarations.

[02:27] *** hcarty left
[02:29] *** binary42 left
[02:31] <GabrielVieira> humm

[02:32] <GabrielVieira> which files i need to modifie to insert a new rule?

[02:32] <chromatic> Grammar/Perl6.p6 and Emitter/Perl5.pm, likely.

[02:35] *** DesreveR joined
[02:43] <GabrielVieira> was what i thought

[02:43] <svnbot6> r9615 | chromatic++ | Added an indirect object rule and made print_with_fh rule use it.

[02:43] <chromatic> If you look at the checkin for #9615, you'll see what I did.

[02:43] <GabrielVieira> about 5hours ago i tried to do the print with filehandle function with no success :~

[02:43] <GabrielVieira> :P

[02:44] <chromatic> You have to be stubborn and hate parsers.  That's why I did it.

[02:44] <GabrielVieira> stubborn?

[02:45] <chromatic> Focus your hate into pure coding frenzy.

[02:45] <TimToady> You just have to hate parsers less than you hate non-parsers.

[02:46] <TimToady> Parsers are like democracy.

[02:46] <GabrielVieira> hahah

[02:46] <chromatic> You have to be Winston Churchill to make them work.

[02:47] <TimToady> I think WC was a better emitter than parser, but leave it be...

[02:47] <FurnaceBoy> but in the morning, chromatic will be sober.

[02:48] <GabrielVieira> chromatic u took the colon out?

[02:48] <TimToady> ohayogozaimasu!

[02:48] <TimToady> it was there when I looked.

[02:49] <GabrielVieira> from open function

[02:49] <chromatic> I took it out from the _print_with_fh rule and subsumed it into the indirect_object rule.

[02:49] <GabrielVieira> ops

[02:49] <TimToady> open doesn't take an indirect object.

[02:49] <chromatic> It's mini-penance for duplicating most of the _print*.

[02:49] <GabrielVieira> was not open

[02:49] <GabrielVieira> :)

[02:49] *** Quell is now known as K

[02:50] <GabrielVieira> chromatic nice :)

[02:50] <chromatic> http://lists.utsl.gen.nz/pipermail/pugs-commits/2006-March/006946.html

[02:52] <TimToady> wow. you're an Author now.

[02:52] <chromatic> Been a sub-creator for years and years....

[02:52] <TimToady> glub glub

[02:52] <GabrielVieira> haha

[02:53] <chromatic> Now I'm tempted to rewrite the Makefile to rebuild everything.  Maybe I'll ponder that over dinner.

[02:53] <TimToady> chromatic: fortunately for us, GV is easily amused.

[02:53] <GabrielVieira> <dot> is defined... what about creat a <colon> too?

[02:53] <chromatic> GV, not GVR?

[02:54] <jisom> rule color { \: } ?

[02:54] <jisom> *colon

[02:54] <chromatic> I thought about it, but unless it's in use elsewhere, I'm not sure it's necessary.

[02:55] <GabrielVieira> yep

[02:55] <kattana_> dont name rules after what they are made of, name them after what they do

[02:55] <GabrielVieira> iv done

[02:55] <GabrielVieira> <dot> does "."

[02:55] <GabrielVieira> :P

[02:55] <ayrnieu> I'd think { : | \: | <[:]> } equivalent.

[02:55] <jisom> what about gt and lt?

[02:55] <jisom> a bare colon has the cutoff meaning

[02:55] <GabrielVieira> <colon> would do ":"

[02:56] <jisom> or backtracing

[02:56] <jisom> some wording

[02:56] <kattana_> what if you want to change "."? allways leave options

[02:57] <TimToady> It would appear that nothing uses <dot>

[02:57] <TimToady> ayrnieu: bare : is metacharacter in P6

[02:58] <TimToady> oh, sorry jisom, you just said that.

[02:58] <GabrielVieira> can i paste 4 lines of code here?

[02:58] <TimToady> : is backtracking prevention on the previous atom, so probably illegal as the first thing.

[02:58] <jisom> eh, wrote the regexdna shootout, and I used the p6rules with pge.... my first foray into p6rules

[03:00] <TimToady> kattana_: we'd like this grammar not to run until the heat-death of the universe, at least until we get bootstrapped onto PGE for (hopefully) better speed.

[03:00] <jisom> pge seems to allow it...but it does cause a problem

[03:00] <jisom> and for pge, using \: instead of <colon> would be faster

[03:02] <pasteling> "GabrielVieira" at 200.141.147.108 pasted "print syntax rule" (13 lines, 436B) at http://sial.org/pbot/16344

[03:02] <GabrielVieira> could you see that paste?

[03:02] <TimToady> pge doesn't seem to allow initial *, and I don't think it should allow initial : either.

[03:03] <jisom> well it errors on calling the matchsub

[03:03] <TimToady> but maybe it helps with something else to treat it that way...

[03:03] <chromatic> Hm, for the direct object invocation syntax, there ought to be a more general rule... but it's difficult to desugar that in general until there's object method support somewhere.

[03:03] <jisom> it doesn't throw a syntax exception

[03:04] <TimToady> "foo" ~~ /: foo/

[03:04] <TimToady> works.

[03:04] <TimToady> same thing with * doesn't parse

[03:04] <jisom> I get a "Null PMC access in invoke()" problem

[03:05] <TimToady> well, I'm running with a *very* recent Parrot...

[03:05] <jisom> I'm with r11858

[03:06] <jisom> which, as the joke goes, is ancient

[03:06] <TimToady> I got the Null PMC when I just said /:/ instead of /: foo/

[03:06] <jisom> oh, I forgot the space

[03:06] <jisom> I was using :foo

[03:07] <TimToady> by ten years from now you probably won't make that mistake.

[03:07] <jisom> ten years from now I'll be on perl7

[03:07] <chromatic> Showoff.

[03:08] <jisom> hm?

[03:08] <GabrielVieira> how can i renew my lrep codes? like update, but when i do update my entries gonna still be there and i want them out :D

[03:08] <chromatic> *I* don't even have Perl 7 yet.

[03:08] <jisom> I don't have perl6 yet either

[03:08] <jisom> technicall

[03:08] <chromatic> Gabriel, svn or svk revert.

[03:08] <ayrnieu> jisom - 'on' is the right word to use, there, as perl7 will be, like all 'programming languages' of 2016, a virus in your VR kit.

[03:09] <GabrielVieira> 5 months from now ill be working entirely with perl6 x)

[03:09] <GabrielVieira> :P

[03:10] <GabrielVieira> chromatic but.. all the files? how can i do?

[03:10] <chromatic> I use svk revert *, if I don't care about any changes I made.

[03:11] <TimToady> gotta decommute, bbiab &

[03:12] <GabrielVieira> didnt work :T

[03:13] <chromatic> rm *; svk up

[03:15] <GabrielVieira> now yes

[03:15] <GabrielVieira> :D

[03:15] <GabrielVieira> tkz

[03:19] *** K is now known as Quell

[03:20] *** amnesiac joined
[03:21] *** Quell is now known as K

[03:22] <GabrielVieira> so

[03:22] <GabrielVieira> in what u all r working at?

[03:22] <GabrielVieira> (in lrep i mean)

[03:33] <pasteling> "chromatic" at 63.105.17.30 pasted "Bootstrapping the rest of the code breaks Grammar/Perl6Primitives.p6 -- here's my Makefile patch to prove it" (56 lines, 1.7K) at http://sial.org/pbot/16345

[03:33] <chromatic> Dinnertime.

[03:43] <TimToady> GabrielVieira: I'm not working on anything in lrep.  I'm not allowed to implement Perl 6, for fear it'll turn out like Perl 5. :-)

[03:46] <GabrielVieira> hahaha

[03:46] <GabrielVieira> dude

[03:46] <GabrielVieira> my bed is claiming for me

[03:47] <GabrielVieira> so...

[03:47] <GabrielVieira> :P

[03:47] <TimToady> sweet dreams++

[03:47] <GabrielVieira> tkz ;)

[03:47] <GabrielVieira> good (night|morning|etc)

[03:47] <GabrielVieira> :)

[03:47] <GabrielVieira> []s

[03:49] <mugwump> TimToady: well, look at the way Linus handles patches to the Linux kernel.  He could conceivably get away with not writing any code at all, just picking patches after they get reviewed/flamed on the relevant list

[03:49] <jisom> isn't that what he does now?

[03:49] <mugwump> well apart from the odd trivial thing here and there

[03:50] <mugwump> open svn might be nice for collaborative hacking, but the distributed model (as offered by git or svk push -P) is better for stable dev.

[03:55] *** K is now known as Quell

[03:55] <mugwump> but hey, no point changing what's working for now.

[04:10] *** dvst joined
[04:17] *** szbalint_ joined
[04:26] *** pdcawley joined
[04:31] *** Alias_ joined
[04:31] <Alias_> audreyt: ping?

[04:32] <Alias_> I'll just leave a tidbit behind then

[04:32] *** Alias_ changes topic to: pugs.blogs.com | pugscode.org | pugs.kwiki.org | paste: http://sial.org/pbot/perl6 | <stevan> Moose... it's the new Camel ":P | .pmc == PPI source filters!

[04:32] * Alias_ runs

[04:32] *** Alias_ left
[04:37] *** mako132_ joined
[04:37] *** justatheory joined
[05:07] *** nirgle joined
[06:10] *** justatheory joined
[06:22] *** justatheory joined
[06:28] *** stennie joined
[06:35] *** stennie joined
[06:37] *** Aankhen`` joined
[06:37] *** Quell joined
[06:38] *** tcliou joined
[06:40] *** stennie joined
[06:51] *** stennie joined
[06:54] *** GeJ joined
[06:54] *** kane_ joined
[07:02] *** Frances joined
[07:03] <nothingmuch> morning

[07:05] <GeJ> morning nm

[07:06] <GeJ> morning folks

[07:21] *** pfenwick left
[07:37] * GeJ fires up the mule, the donkey, the firefox and the ftp-thingy

[07:39] <GeJ> take that you damn french senators!

[07:40] *** drrho joined
[07:44] *** szbalint_ is now known as szbalint

[07:50] *** fandango joined
[07:56] *** szabgab joined
[07:56] <Quell> brb, reinstalling x-chat

[07:57] <szabgab> In case of @a = readdir($dir); @b = readdir($dir);    @b should be empty and not undef, right ?

[07:58] <ayrnieu> what type is $dir ?

[07:58] <szabgab> $dir = openddir "."

[07:59] <szabgab> IO::Dir

[07:59] <ayrnieu> (not ::Str , then)

[08:00] *** iblechbot joined
[08:01] <ayrnieu> szabgab - I get @b as empty after that...

[08:01] <szabgab> ok, I see that was my bug in checking it...

[08:01] *** Quell joined
[08:02] <ayrnieu> ./pugs -e 'for opendir "." -> $d { my @a = readdir $d; my @b = readdir $d; say @b.perl }'

[08:02] <ayrnieu> OK.

[08:02] <szabgab> using ok(+@b, 0) instead of is(+@b, 0)

[08:02] <ayrnieu> (although that prints [] where I get () interactively.  but nevermind, I don't understand it.)

[08:05] <jisom> I haven't used perl6 much, but I have to say the "for @array -> $scalar {}" syntax a little unreadable, how complicated would it to allow "for @array as $scalar {}"?

[08:05] <svnbot6> r9616 | szabgab++ | quickref: files and directories

[08:05] <svnbot6> r9616 | szabgab++ | more opendir/readdir related test

[08:06] <ayrnieu> jisom - er, your suggested syntax is a little unreadable to me :-)

[08:07] <jisom> the "@array -> $scalar" makes me think of storing an array reference of @array into $scalar

[08:07] <jisom> or perl5's method invocation

[08:07] <jisom> on an array

[08:07] <jisom> although 'foreach @array as $scalar' seems more readable

[08:08] <ayrnieu> *shrug*  I'd never, ever write that.

[08:08] <jisom> it's easier for me to read words than characters

[08:10] *** marmic joined
[08:10] <ayrnieu> it's interesting that you note the -> as a perl5 funcall.  That hadn't even occured to me.  I guess I see perl6 as a different enough language.

[08:11] <jisom> me too....when the question comes up of "is perl6 still perl?", I just sort of think, how many perl1 programs run under perl5, and how many perl programs at all run under perl6

[08:12] <ayrnieu> I didn't mean it in that way.  Incidentally, I have never seen a perl1 program, but I've seen old perl poetry which perl5 couldn't parse.

[08:13] <jisom> you can download perl1

[08:13] <ayrnieu> where it was indicated as having parsed.

[08:13] <ayrnieu> *nod*, but I haven't.

[08:13] *** nothingmuch joined
[08:13] <jisom> it's simple, "compiles as far as some programs run"

[08:14] <jisom> I imagine many programs, those that don't use something like "$  = 'foo';" would work fine

[08:14] <jisom> and not use oo

[08:14] <ayrnieu> perl1 strikes me as something which ought to exist as a simple module under Acme::

[08:15] <ayrnieu> and not use more than just OO :-)

[08:15] <ayrnieu> perl4, even, lacked lexically scoped variables, and proper references.

[08:16] <pasteling> "jisom" at 64.85.214.233 pasted "snippets from perl1's man page" (40 lines, 1.2K) at http://sial.org/pbot/16348

[08:16] <jisom> true, but syntactically, it's one of the major differences

[08:16] <jisom> my and our being new, our being only 5.6

[08:17] <ayrnieu> OO is not much, syntatically.

[08:17] <jisom> nevertheless, it's an important part of many "application languages"

[08:17] <ayrnieu> -> and bless(); I don't know if packages already existed.

[08:18] <jisom> it's not so much "how many perl5 programs would run on perl1", but "how many perl1 programs could run on perl5"

[08:19] <ayrnieu> ah, and we got here by your passing 'and not use oo'.

[08:20] <jisom> eh

[08:20] <ayrnieu> Not to offend, but I really, really don't care about perl1.  It's sort of pleasant that it has been made to be downloadable again, and I recall some present of that to the community, but it's not a language I care about.

[08:20] *** nothingmuch joined
[08:21] <ayrnieu> perl4 is disturbing enough, when I come across it.

[08:21] <jisom> but it sort of goes back to "is perl6 perl"....which of course came from the "for @array -> $scalar" thing reminding me of perl5's oo method invocation

[08:22] <jisom> "A subroutine is called using the do operator.  (CAVEAT: For  efficiency reasons  recursive  subroutine calls are not currently supported.  This restriction may go away in the future.  Then again, it may not.)" besides that part of course

[08:22] <ayrnieu> I see 'is perl' as a function based on a fuzzy bag of features and biases, at least including contexts of expressions and a bias in favor of language complexity.

[08:23] <jisom> maybe that's why my sub calls seg faulted

[08:24] <ayrnieu> The function you seem to suggest, that 'is perl' depends on the previous Perl code that can run on it, that doesn't matter quite so much to me.  Especially not "can I write the 'is perl' language just as I wrote previous Perl"

[08:24] <ayrnieu> because, again, perl4->perl5 is shocking :-)

[08:24] <jisom> not necessary features but how to write in it....and I'm not biased against perl6, but I notice things that make me think "you could call this by another name and people might not call it perl"

[08:25] <nothingmuch> jisom: what doesn't support recursion?

[08:25] <jisom> perl1, apparently

[08:25] <ayrnieu> I'd still call it very perl-like, because it has contexts of expressions and a bias towards language complexity an some other stuff I haven't cleared up with myself.

[08:26] <jisom> I started with perl5, on a mac(not osx)...until one time I saw perl1 being available, I'd never used it or seen it, but it sort of surprises me how few of the things have changed

[08:26] <ayrnieu> ah, OK.

[08:27] *** szabgab left
[08:27] <jisom> I like the one-liner capability(that may span multiple lines on my terminal) and being able to write easy to read programs

[08:28] <ayrnieu> I guess the important victim of progress is idiomatic language.  perl4 and perl5 are similar in endless ways, but if you present a perl5 program written perl4ly people will look at you like you are a space alien.

[08:28] <jisom> when it comes to rules, I think the easier ability to write noncapturing groups is good, but I don't like the more complicated character classes

[08:28] <ayrnieu> jisom - example of a more complicated character class?

[08:29] <jisom> "<[abc]>" compared to "[abc]"

[08:29] <jisom> and how "<foo>" calls foo

[08:29] <ayrnieu> ah.  Well, it may scale better.

[08:29] <ayrnieu> Contrast with [[:alpha:]] and such of perl5.

[08:29] <jisom> but that's easily understandable

[08:30] <jisom> to me anyway

[08:30] <jisom> anyway, how does perl6 rules do it? I haven't worked with that on pge yet

[08:31] <ayrnieu> <?alpha> , I assume, but I'll check.

[08:31] <ayrnieu> <alpha>

[08:32] <ayrnieu> <alpha+[0-3]-[jJ]>  # heh.

[08:32] *** jisom_ joined
[08:33] <ayrnieu> <alpha>

[08:33] <ayrnieu> <alpha+[0-3]-[jJ]>  # heh.

[08:33] * jisom_ hates his isp sometimes

[08:33] <jisom_> well the <alpha> syntax would actually be slower under pge than <[a-zA-Z]> :-p

[08:34] <ayrnieu> actually, off-hand, I don't know how I would as neatly express [[:alpha:]]-but-not-[jJ] in perl5.  (?:(?![jJ])[[:alpha:]]) I suppose.

[08:34] <ayrnieu> jisom - well, [a-ZA-Z] is also not the same as alpha

[08:34] <jisom_> true, but for ascii it's right

[08:35] <ayrnieu> so, (?:(?![jJ])[[:alpha:]]){5} becomes <alpha-[jJ]>**{5}  ?

[08:35] <ayrnieu> if you want to match ascii, match ascii :-)

[08:36] <ayrnieu> perl6 makes that readable enough that people might actually think that way.

[08:36] <jisom_> although for the complicated situations, p5 regex can be unwieldily, but for most cases, it doesn't come to that

[08:37] <jisom_> and in for other situations, hopefully the person reads perlpacktut and uses pack instead

[08:37] * jisom_ wishes parrot had a pack/unpack

[08:37] <ayrnieu> well of course, when a tool gets unwieldy people tend to do something else.

[08:38] <ayrnieu> I don't sit around trying to force concurrency-oriented-programming into my perl5.  I just don't do that :-)

[08:38] <ayrnieu> but that's a neat way to do things, and so might <xdigit-[0]> turn out.

[08:39] <jisom_> yes, there's the whole "right tool for the job" thing, but if you know perl, and don't want to learn a new language, you'll figure out the weird regex

[08:39] <ayrnieu> <+xdigit-[0]>

[08:39] <jisom_> yes, I will admit it can be very beneficial

[08:40] <jisom_> but for character classes alone, none of that other complex stuff, and character classes are quite common in my experience, it's more characters and from a standard regex usage, it'll lead to a definite learning curve

[08:40] <nothingmuch> jisom: "figure out the weird regex" is consistent with "perl is a write only language"

[08:41] <nothingmuch> Perl 6 is trying to make it almost as concise to write throwaways

[08:41] <nothingmuch> just as easy to write throwaways

[08:41] <jisom_> or a "write once, document well" language :)

[08:41] <nothingmuch> but possible to write a big app too

[08:41] <nothingmuch> without needing exceptional programmers

[08:41] <ayrnieu> I'm not sure that "OK, [1-9] is <[1..9]> and [^ab] is <-[ab]> , enjoy." is such a difficult first jump :-)

[08:41] <jisom_> haven't you ever heard of Eagleson's law?

[08:41] <nothingmuch> no, i haven't

[08:42] <nothingmuch> but documentation < self documenting code, for maintenance purposes

[08:42] <jisom_> Eagleson's Law:

[08:42] <jisom_>         Any code of your own that you haven't looked at for six or more

[08:42] <jisom_>         months, might as well have been written by someone else.  (Eagleson

[08:42] <jisom_>         is an optimist, the real number is more like three weeks.)

[08:42] <nothingmuch> type annotations, for example, can *REALLY* help clarity

[08:42] <nothingmuch> that law needs a name?

[08:42] <jisom_> well, I do tend to write self documenting code, but still, sometimes if you're wanting that extra performance improvement, you use comments

[08:42] <jisom_> oh, that's from fortune

[08:43] <ayrnieu> jisom - that's not correct, and it's sort of a verbose way to say "readability is important", and the perl6 Camel Book will probably have, as previous Camels, an 'optimizing for maintainability' section.

[08:43] <nothingmuch> err

[08:43] <nothingmuch> comments?

[08:43] <nothingmuch> how do those improve performance?

[08:43] <ayrnieu> nothingmuch - jisom is saying that you will comment your obscure optimizations.

[08:43] <nothingmuch> oh

[08:44] <nothingmuch> well, that should never be more than 5% of the code or so

[08:44] <jisom_> well certain operations can be improved better by a human than a computer

[08:44] * nothingmuch works on performance intensive C++ code

[08:44] <jisom_> it's often small portions, but at bottlenecks, or places you know you can optimize

[08:44] <nothingmuch> and one of the lessons I've learned is that if you write beasts in the name of performance you will lose so much more later on

[08:44] <nothingmuch> nowadays we are optimizing things by 50% or so

[08:44] <nothingmuch> just by simplifying a bit

[08:45] <nothingmuch> the reason it got this way is that the code was so convulted it took a team effort to understanad it all

[08:45] <nothingmuch> since we're 2nd generation programmers for this part of the product

[08:45] <nothingmuch> balance is everything

[08:45] <nothingmuch> keep most code optimiz*able*

[08:45] <jisom_> I remember what a friend said, he had a friend who was essentially needing to save space, so it was delete the comments in the other guy's opinion, my friend replied "delete the code, you can recreate it from the comments, but without the comments you won't understand the code"

[08:45] <nothingmuch> by making it clear and easy

[08:46] <buu> jisom_: Until the comments are wrong =]

[08:46] <nothingmuch> and only if you can prove by profiling are you allowed to optimize it

[08:46] <jisom_> buu: fire the programmers who don't comment o:-)

[08:46] <nothingmuch> i disagree with that

[08:46] * nothingmuch doesn't comment i++

[08:46] <jisom_> profiling or benchmarks

[08:46] <ayrnieu> I particularly like perl6 rules in that I see them as allowing me to tend to more strictly match my input, rather than for sanity's sake loosely read input and then write very many tests to make sure it's not brokenly loose.

[08:46] <nothingmuch> but if i delete

[08:46] <nothingmuch> then it won't work anymore

[08:46] <jisom_> nothingmuch: does your code document itself?

[08:46] <buu> jisom_: I never said they didn't comment, I said the comments wre wrong.

[08:46] <buu> Yay selfdocumenting code!

[08:48] <buu> jisom_: I generally feel that if your code isn't self explanatory, it should be rewritten (or it's C)

[08:48] <jisom_> ayrnieu, given that perl6 rules use [] for non capturing, and {} still for counting, I don't know of an alternative, though perhaps I'd have choosen {} for non capturing instead.....but, what about when <foo> does more than just a character and a whole pattern? what should a reader expect <foo-[abc]> to think?

[08:49] <ayrnieu> jisom - it has to be <+foo-[abc]>, sorry.

[08:49] <jisom_> I go for pir nowadays....should be easier with the hllmacros.pir file, hopefully

[08:49] <nothingmuch> jisom_: yes

[08:49] <nothingmuch> jisom_: i make sure

[08:49] <nothingmuch> and if it doesn't i comment

[08:49] <ayrnieu> jisom - {} are already used by closures within rules.

[08:49] <nothingmuch> and then think hard how to remove the comments

[08:49] <jisom_> so it has to be **{2} for counting?

[08:49] <nothingmuch> (by correcting the code)

[08:49] <nothingmuch> (correcting == making it more readable)

[08:50] *** jisom_ is now known as jisom

[08:50] <nothingmuch> the problem with macro programming, with all due respect, jisom, is that they don't compose well

[08:50] <nothingmuch> no matter how good hllmacros.pir is

[08:50] <jisom> but say the code's performing some algorithm, then it's more of a case of "get it right and get it working fast" rather than "what's this say again?"

[08:50] <ayrnieu> jisom - yes.

[08:51] <nothingmuch> pir will not be a good high level language for writing human optimized code

[08:51] <jisom> nothingmuch: pir's an assembly, macro's can help greatly

[08:51] <nothingmuch> yes, i know

[08:51] <nothingmuch> i wrote a lot of assembley and our assembler didn't have macros and how i longed for them

[08:52] <nothingmuch> but there's still a "deeper" level of all encompassing abstraction

[08:52] <nothingmuch> a sort of consistency

[08:52] <nothingmuch> what is a value

[08:52] <nothingmuch> what is a construct

[08:52] <nothingmuch> these questions can become very limiting later on

[08:52] <jisom> yeah, in less than 30ish lines of code, I added support for nested macros and then added a hllmacros.pir file to make it easier to program in pir, and programming for parrot can be good, and just as people will write in machine assembly over other languages, people will write in pir in years to come

[08:53] <nothingmuch> right

[08:53] <nothingmuch> and that's a good thing

[08:53] <nothingmuch> but that's not a replacement for Perl 6's values

[08:53] <jisom> yeah, my initiative to add the support was porting some oo code that was sort of complex......and the macros help prevent bugs

[08:54] <jisom> absolutely, eventually I'll learn perl6 well and for some things I'll use it often, pir's not for one liners after all

[08:54] <jisom> but with jit, it's not impossible to get "faster than c"

[08:54] <jisom> I think parrot has two shootouts that can run faster than c with jit enabled on x86

[08:55] <jisom> it's one of those "do what I say" type things

[09:01] <audreyt> jisom: noncomposable macros can bring more bugs, though

[09:01] <audreyt> (just look at XS)

[09:01] <jisom> what's noncomposable mean?

[09:01] <audreyt> jisom: I'd like to have some form of composable macros in parrot-land, be it PIR or AbsPIR or something

[09:01] <audreyt> jisom: noncomposable means when you nest two macros

[09:01] <jisom> parrot supports that

[09:01] <jisom> I added it

[09:02] <audreyt> you can accidentally change one's meaning

[09:02] <audreyt> if two macros know about each other

[09:02] <audreyt> then they can conspire to fix this

[09:02] <audreyt> but in general, C-style macros (and naive Scheme-style macros) doesn't compose

[09:02] <jisom> "perldoc -F runtime/parrot/include/hllmacros.pir" in parrot's root

[09:02] <audreyt> currently the "Foreach" macros in parrot

[09:02] <jisom> oh

[09:02] <audreyt> doesn't compose with itself

[09:03] <jisom> well that's complicated....

[09:03] <audreyt> you can work around that

[09:03] <audreyt> but in general where side-effects can occur in noncomposble macros

[09:03] <audreyt> is an undecidable problem

[09:03] <Ara4n> morning folks

[09:03] <jisom> the .sym  is changed to .local for the lexer, and unlike .local in macros where it creates something specific, .sym just reserves the name and is there as a replacement for .local and has no special meaning different from .local

[09:04] <audreyt> jisom: yeah, I went thru hllmacros.pir with leo

[09:04] <jisom> ok

[09:04] <nothingmuch> jisom: jit cannot be faster than C for high level code if high level knowlege is not passed down

[09:04] <jisom> an alternative could be using push/pop whichever thing, but there was discussion recently on removing that

[09:04] <audreyt> "Composable and Compilable macros" from matthew flat, and "Composable Macros" from oleg

[09:05] <nothingmuch> because a boxed value, no matter how optimized in assembly will always be more complex than an unboxed value

[09:05] <jisom> nothingmuch: benchmarks often are low level

[09:05] <nothingmuch> that's why benchmarks are irrelevant

[09:05] <nothingmuch> we shouldn't be chasing benchmarks

[09:05] <jisom> but they're often used

[09:05] <audreyt> jisom: so in any case, I fear the XS-doom will be upon PIR-macro programmers if people starting to nest them often

[09:05] <nothingmuch> for what good purpose?

[09:05] <nothingmuch> name one good reason to use synthetic benchmarks that is not propaganda

[09:06] <audreyt> jisom: (not that I think hllmacros.pir is bad -- I think it's cool and saves a lot of typing)

[09:06] <jisom> audreyt: I haven't worked with xs, I've hadn't even wanted to look at it, let alone the macros of it, so I can't comment on xs macros

[09:06] <nothingmuch> propaganda is important, but it's only there to make the first step

[09:06] <audreyt> jisom: ok... but think about C macros in general :)

[09:06] <nothingmuch> after that works, you need to prove that your propaganda isn't lies and deception =)

[09:06] <audreyt> jisom: XS is just C macros went wrong

[09:06] <jisom> and it works with the "ok, you use unless for an if block and if for an unless block"  trouble

[09:06] <audreyt> into its own minilanguage

[09:06] <jisom> ouch

[09:07] <audreyt> hllmacros.pir of course is not going there _yet_

[09:07] <jisom> propaganda helps pr....

[09:07] <audreyt> but the temptation is there I'd say

[09:07] <audreyt> e.g. the temptation to use two Foreach is high :)

[09:07] <jisom> perhaps, but many basic blocks are often rewritten time and time again, and can be bug prone

[09:07] <jisom> I know

[09:07] <jisom> sometimes I just add a "foreach2"

[09:07] <nothingmuch> jisom: if you truuely *polymorphic* macros

[09:07] <nothingmuch> then that's just OO eventually

[09:08] <audreyt> ooh foreach2 :-/

[09:08] <jisom> but perhaps a buggy foreach with a comment about it's bug is better than none?

[09:09] <jisom> you do have to change variable names....

[09:10] <jisom> if .sym had the .local $label properties, it'd be possible.... but .sym doesn't allow that

[09:10] <nothingmuch> *cough*

[09:10] <nothingmuch> see that's exactly my point about macros != high level constructs

[09:10] <nothingmuch> they have this sort of gap

[09:10] <nothingmuch> where yuckyness leaks through

[09:11] <nothingmuch> the only language where macros make sense as the basic building block is forth

[09:11] <nothingmuch> because it's *so* simple that macros *do* compose

[09:11] <jisom> pir's so simple that macros can compose :-p

[09:14] <nothingmuch> i seriously doubt that

[09:14] *** Quell joined
[09:14] <jisom> what do you define as "can compose"?

[09:15] <nothingmuch> it's a touchy feely thing

[09:15] <nothingmuch> any language with calling conventions is too high level for macros to work well, IMHO

[09:15] <nothingmuch> but that's just my opinion

[09:16] <pasteling> "jisom" at 64.85.215.200 pasted "forget hello world" (18 lines, 617B) at http://sial.org/pbot/16350

[09:19] <nothingmuch> pil is still a low level language

[09:19] <jisom> pir?

[09:19] <nothingmuch> err, yes

[09:19] <jisom> yes, it's an assembly with nicer things like subroutines and objects, arrays, etc, but still assembly, there's not even an if statement without macros

[09:23] <jisom> my intent for doing it when I did it was to make more readable code, a greater hope is that others who come to pir won't be immediately put off and make it easier for beginners to learn it

[09:24] <jisom> and try to solve a bug in a program I've yet to fully fix(or locate the problem)

[09:24] *** Arathorn joined
[09:26] <audreyt> jisom: definitely the hllmacro is a step forward :)

[09:27] <audreyt> by making macros nest, the temptation is to take a step sideways and use them as inner subs and higher-order functions

[09:27] <audreyt> if people can resist the temptation and/or reason about it, then it's just fine :)

[09:28] <audreyt> but I'm boardin in 2mins :)

[09:28] <jisom> well if they remember it's an assembly and not an hll, and they realize they're programming in pir, it won't be too bad

[09:28] <audreyt> yup

[09:28] <audreyt> but XS programmers very often forget they are dealing with C.

[09:29] * audreyt goes boarding &

[09:29] *** rindolf joined
[09:29] <nothingmuch> boarding?

[09:29] <nothingmuch> audreyt: are you learning to snowboard?

[09:29] <Arathorn> boarding swoosh swoosh swoosh? or boarding 'this is last call for gate 28'?

[09:30] <nothingmuch> or boarding 'they're coming to get us, quick get the hammer'?

[09:30] * jisom wonders how fast you can go from irc to a ski slope

[09:30] <nothingmuch> jisom: knowing audreyt she's probably skiing *with* the laptop

[09:30] * Arathorn has been on irc from a chairlift before :/

[09:31] <jisom> just need a place to rest it while skiing

[09:31] <jisom> even though most laptops aren't "rated" for that cold

[09:31] *** meppl joined
[09:31] <rindolf> Hi all!

[09:31] <nothingmuch> hi rindolf

[09:32] <rindolf> What expression holds the line number in pugs.

[09:32] <rindolf> nothingmuch: hi! What's up?

[09:32] <nothingmuch> jisom: i mean physically, on the slope

[09:32] <nothingmuch> in a bag or something

[09:32] <nothingmuch> so that she can code on the lift

[09:32] <nothingmuch> etc

[09:32] <nothingmuch> rindolf: not much

[09:32] * jisom wonders what nothingmuch thought he ment

[09:32] <nothingmuch> rindolf: $?POSITION

[09:32] <nothingmuch> or somesuch

[09:32] <nothingmuch> err, so what did you mean by 'skiing'?

[09:32] <nothingmuch> err

[09:32] <nothingmuch> 'rest it'

[09:32] <nothingmuch> sorry

[09:33] <jisom> skiing, mountain, snow

[09:33] <nothingmuch> no, not by 'skiing'

[09:33] <jisom> do you need more coffee or less coffee?

[09:33] <nothingmuch> i need less windows

[09:33] <nothingmuch> and a different ISP

[09:33] * nothingmuch is coding, changing ISP and chatting at the same time

[09:33] <jisom> in time, you may find a kernel in p6

[09:34] <nothingmuch> jisom: do you know House?

[09:34] <jisom> no

[09:35] <nothingmuch> http://www.cse.ogi.edu/~hallgren/House/

[09:35] <nothingmuch> it's an OS in haskell

[09:36] *** azuroth joined
[09:37] <jisom> I forget the name but there's a fairly new os written only in machine assembly...

[09:37] <jisom> personally I think that if you're at that point, you need a hll

[09:39] <nothingmuch> how portable is it? ;-)

[09:39] <Arathorn> . o O ( written in parrot )

[09:39] <jisom> x86 only :(

[09:41] <jisom> once parrot's jit gets improved across all platforms(instead of just major ones), forking it into a compiler for machine code could help write platform independent machine code

[09:41] *** Daniel_Nee joined
[09:43] <nothingmuch> jisom: platform independant machine code makes no sense

[09:43] <nothingmuch> why use it

[09:43] <nothingmuch> if it's not platform dependant

[09:43] <jisom> neither does the intel vs at&t syntax

[09:44] <nothingmuch> i mean, if you're not exploiting CPU features to death, might as well use a high level language

[09:44] <nothingmuch> for this argument i consider PIR high level

[09:44] <nothingmuch> because it has semi-opaque data types

[09:44] <nothingmuch> and memory abstraction

[09:44] *** kakos joined
[09:45] <jisom> it's a cisc, but if you were to strip it to a risc, and change certain parts(like being able to deal directly with ram), it could work

[09:46] <jisom> I'm not saying change pir directly to an assembly syntax, but perhaps strip it and modify it

[09:46] <jisom> not for parrot

[09:46] <jisom> just because perl6 has oo and runs as asm, doesn't mean asm has oo

[10:17] *** xinming joined
[10:18] *** elmex joined
[10:36] <rindolf> Yay! My first Perl 6 program is working.

[10:37] *** kanru joined
[10:49] <nothingmuch> rindolf: what is it?

[11:07] <xinming> nothingmuch: Hello world! :-P

[11:16] <rindolf> xinming: no.

[11:17] <rindolf> nothingmuch: it is a port of my Perl 5 program for solving the Expert QOTW 8 - calculating the graham number.

[11:17] <rindolf> Well, I'm going to rest. Bye all!

[11:18] *** Gothmog_ joined
[11:18] *** DesreveR is now known as r0nny

[11:19] *** Gothmog_ joined
[11:22] *** r0nny joined
[11:41] *** ruoso joined
[11:46] * ruoso is happy to see others working in lrep-compiler :)

[11:49] <svnbot6> r9617 | ruoso++ | t/macro.p6t - Tests the macro compilation

[11:53] <ruoso> does unless still exists in perl 6?

[11:55] <rgs> it works in pugs

[11:56] <ruoso> ok...

[12:06] <nothingmuch> ]

[12:07] <nothingmuch> ]\]

[12:07] <nothingmuch> oops

[12:09] <nothingmuch> anybody seen obra?

[12:10] <svnbot6> r9618 | ruoso++ | Documenting TODO... Proposing a way to refactor Perl6.p6

[12:16] *** Khisanth joined
[12:19] <svnbot6> r9619 | ruoso++ | no <?p6ws> between subname and ( in this(that)

[12:23] <Juerd> ruoso: Yes; Damian's insanity re that hasn't reached Perl 6 yet ;)

[12:23] * Juerd doesn't use unless because it's not natural to him, but understands why it is very useful to have.

[12:26] <ruoso> Juerd, specially whith limited rules

[12:26] <ruoso> Juerd, if ( ! $var ) is harder to implement than

[12:26] <ruoso> Juerd, if ( $var ) and unless ( $var )

[12:27] <Juerd> I wouldn't know

[12:29] *** chris2 joined
[12:52] *** slurpee joined
[12:58] <svnbot6> r9620 | ruoso++ | if and unless are not macro anymore... generated lrep can replace the hand-written lrep.pl, updated Makefile to reflect that

[12:58] <svnbot6> r9621 | ruoso++ | removing lrep.pl in favour of lrep, which is compiled from lrep.p6

[13:04] <svnbot6> r9622 | ruoso++ | updating TODO

[13:07] *** mako132_ joined
[13:13] *** nothingmuch joined
[13:16] *** iblechbot joined
[13:23] *** Frances_ joined
[13:25] <nothingmuch> http://www.cerado.com/web20quiz.htm

[13:25] <nothingmuch> dear god

[13:27] *** Frances_ joined
[13:28] *** Frances_ is now known as fransees

[13:28] *** Limbic_Region joined
[13:29] <ruoso> When someone declares a grammar (which is like a package in Perl 5, right?) the rules are scoped to that Grammar. right? which is the syntax to load an external grammar and to match with some rule of that grammar?

[13:30] <nothingmuch> a grammar is just a class

[13:30] <nothingmuch> so Grammar::rule

[13:30] <nothingmuch> and use Grammar <rule>;

[13:30] <nothingmuch> but

[13:30] <nothingmuch> remember that both exports are lexical

[13:30] <nothingmuch> and rules can be lexical

[13:30] <nothingmuch> my rule foo { }

[13:30] <nothingmuch> and rule foo is export { }

[13:31] <ruoso> hmmm

[13:31] *** Frances_ joined
[13:31] <ruoso> ok... but if one wants to avoid the export and use it where it is

[13:32] <nothingmuch> Grammar::rule

[13:32] <nothingmuch> but only for 'our rule foo' or 'rule foo', not for 'my rule foo'

[13:32] <obra> nothingmuch: I'll be around in an hour

[13:32] <ruoso> but Grammar::rule is a subroutine call, isn't it?

[13:32] <ruoso> shouldn't it be Grammar.rule?

[13:32] <nothingmuch> obra: aye... thanks =)

[13:33] <nothingmuch> ruoso: no, that invokes the class method 'rule'

[13:33] <nothingmuch> or the class rule 'rule'

[13:33] <nothingmuch> but all rules are instance methods on the match object

[13:33] <ruoso> now I'm confused

[13:34] <nothingmuch> okay

[13:34] <nothingmuch> here's how rules work

[13:34] <nothingmuch> in theory

[13:34] <nothingmuch> the domain specific language for rules is parsed into an AST defining rules

[13:34] <nothingmuch> which is mostly a lambda calculus

[13:34] <ruoso> ok

[13:34] <ruoso> this part I understood

[13:34] <nothingmuch> there are combinator rules, like +, (), and so forth

[13:35] <ruoso> ok

[13:35] <nothingmuch> the rule methods in perl space are perl wrappers that execute those ASTs

[13:35] <nothingmuch> the methods are invoked on the rule evalutor state object thing

[13:35] <nothingmuch> the match object

[13:35] <nothingmuch> which is like an interpreter env

[13:35] <nothingmuch> this match object contains:

[13:35] <nothingmuch> the current state

[13:35] <nothingmuch> the current match data

[13:35] *** Frances_ joined
[13:35] <nothingmuch> various control structures

[13:36] <nothingmuch> etc

[13:36] <nothingmuch> and the rules-compiled-into-methods are invoked on it

[13:36] <nothingmuch> now, this is just at the semantic level

[13:36] <nothingmuch> the implementation may in fact compile the rules into a different language

[13:36] <nothingmuch> like PIR

[13:37] <nothingmuch> but at the seam it should always pretend to look like regular perl methods

[13:37] <ruoso> but... the match object isn't the return of a rule execution?

[13:37] <nothingmuch> that move match data around

[13:37] <nothingmuch> it's implied

[13:37] <nothingmuch> when you start a match

[13:37] <nothingmuch> then it constructs a new match object

[13:37] <ruoso> ah ok...

[13:37] <nothingmuch> and binds it to $/

[13:37] <ruoso> the ~~ operator already starts the match

[13:37] <nothingmuch> and then starts executing the anonymous method

[13:37] <nothingmuch> right

[13:37] <nothingmuch> so rx:/..../ is an anonymous method

[13:38] <nothingmuch> this is just invoked on the $/ object

[13:38] <nothingmuch> $/ contains the input data too

[13:38] <nothingmuch> and the method will cause changes to the internal state

[13:38] <nothingmuch> pulling in input, accumilating oputput

[13:38] <nothingmuch> and backtracking

[13:38] <ruoso> so rx:/..../ will be compiled also

[13:38] <nothingmuch> yes

[13:38] <nothingmuch> it's essentially like saying 'my method { }'  with no name

[13:38] <ruoso> but...

[13:39] <nothingmuch> now, what goes on inside is obviously different

[13:39] <ruoso> how can $/.rulexxx be invoked if rulexxx is defined in a external grammar?

[13:39] <nothingmuch> okay

[13:39] <nothingmuch> so the way this works is that all invocations on rulexxx etc are *normally* done as:

[13:39] <nothingmuch> rx:/ <Grammar::rulexxx> /;

[13:39] <nothingmuch> as a parallel to:

[13:39] <nothingmuch> $/.Grammar::rulexxx

[13:40] <nothingmuch> but i think $/.Grammar::rulexxx is not enough

[13:40] <nothingmuch> the API is not specced enough

[13:40] <nothingmuch> and there is a handwavy hole in the middle

[13:40] <nothingmuch> basically:

[13:40] <nothingmuch> do grammars inherit from Match?

[13:40] <nothingmuch> or does Match have a Grammar object that it internally invokes rules on?

[13:40] <ruoso> do it?

[13:40] <nothingmuch> this stuff isi underspecced

[13:40] <nothingmuch> we don't know

[13:40] <nothingmuch> that's what I'm hoping pX will sort out

[13:41] <nothingmuch> see Hierarchy.pod in docs

[13:41] <nothingmuch> this details all the parts I could think of that are either specced or not yet specced

[13:41] <nothingmuch> and is also missing parts which i couldn't think of

[13:41] <ruoso> ok...

[13:41] <nothingmuch> if you like, try to expand on the areas where the match/grammar lower level API can be detailed

[13:41] <nothingmuch> also

[13:41] <nothingmuch> luqui created Parse-Rule

[13:42] *** Frances_ joined
[13:42] <ruoso> where?

[13:43] *** Frances_ is now known as fransees

[13:45] * ruoso reading Perl6::Bible again

[13:49] <nothingmuch> ruoso: sorry, back

[13:49] <nothingmuch> parse-rules is in misc somewhere, i think

[13:49] <nothingmuch> it's a proposition for the Match object interface

[13:49] <nothingmuch> that tries to make sure it can compile to many backend systems

[13:50] <nothingmuch> ruoso: sorry, it's in ext/

[13:50] <nothingmuch> despite having just stubs

[13:50] <ruoso> nothingmuch, ok...

[13:51] *** Frances_ joined
[13:51] * ruoso still wondering how "$match = Grammar::Perl6::grammar($source);" should look like in real perl 6

[13:52] <nothingmuch> ruoso: explain

[13:52] <nothingmuch> I think it'll be something like

[13:52] <nothingmuch> my $c = Perl::Grammar::Compiler.new();

[13:53] <nothingmuch> my $parse_tree = $c.parse( $rule_source ); # whatever hooks

[13:53] <nothingmuch> err, that's a parser, not a compiler

[13:53] <nothingmuch> and then it compiles depending on the backend

[13:53] <nothingmuch> either to Perl 6

[13:53] <nothingmuch> or to PIR

[13:53] <nothingmuch> or to both

[13:53] <nothingmuch> depending on what can be done

[13:53] <nothingmuch> i have a billion ideas on this topic of compiling, if you want to talk about it later

[13:53] <nothingmuch> but i have to go now

[13:54] <ruoso> so $c.parse means "$c is the grammar object and parse is a rule"

[13:55] <nothingmuch> oh

[13:56] <nothingmuch> on that level

[13:56] <nothingmuch> i think you're forgettin ghtat rules need to be emitted and stuff

[13:56] <nothingmuch> if you have a single step parse-rule-syntax-and-execute method

[13:56] <nothingmuch> then there's not enough separation for later

[13:56] <nothingmuch> or do you mean something else?

[13:56] <nothingmuch> $c is the rule compiler

[13:56] <nothingmuch> and .parse is a method defined on the rule compiler

[13:57] <nothingmuch> this stuff is invoked by the Perl 6 compiler extension that handles the DSL for rules

[13:57] <ruoso> hmmm... for runtime rule compilation... ok....

[13:58] <ruoso> but I don't have a single step

[13:59] <ruoso> but in this case, I'm using a pre-defined set of rules, that are already compiled...

[14:02] *** Arathorn joined
[14:13] <ruoso> so... it would looks like: "$source ~~ /<Grammar::Perl6::grammar>/; $match = $/;"

[14:14] <ruoso> hmmm... better yet "$match = $source ~~ /<Grammar::Perl6::grammar>/;"

[14:21] *** GabrielVieira joined
[14:22] <GabrielVieira> hello there

[14:22] *** Limbic_Region joined
[14:24] *** renato joined
[14:44] <svnbot6> r9623 | ruoso++ | notes on how a match should perform

[14:45] <pasteling> "ruoso" at 201.9.45.97 pasted "proposed emmited code to a perl 6 match..." (5 lines, 164B) at http://sial.org/pbot/16351

[14:46] <ruoso> audreyt, TimToady, anyone... please take a look at http://sial.org/pbot/16351

[14:49] <audreyt> looking

[14:51] *** chris2 joined
[14:51] <Limbic_Region> ruoso - just finished backlogging

[14:51] <Limbic_Region> ruoso - does your latest change in lrep fix the thingy where chromatic said bootstrapping the rest breaks?

[14:51] <Limbic_Region> and if yes - is it Christmas?

[14:51] <ruoso> Limbic_Region, yes... not that it really fix...

[14:52] <ruoso> Limbic_Region, but Data::Dumper.Dump($capture) solves the problem

[14:52] <ruoso> Limbic_Region, I don't have a clue of why

[14:52] <ruoso> the Dump modifies the Capture somehow

[14:52] <ruoso> that it just works...

[14:53] <ruoso> I still needs to debug it to know exactly which is the difference

[14:53] <ruoso> christmas:

[14:53] <ruoso> ?

[14:54] *** vel joined
[14:55] <audreyt> ruoso: can you lexically-scope $/ ?

[14:55] <ruoso> oh... sorry

[14:55] <ruoso> it should be something like

[14:55] <ruoso> $MATCH

[14:55] <audreyt> $MATCH = Perl6::Runtime::Match->new(Grammar::Perl6->grammar->($source))

[14:55] <ruoso> in the perl 5 code

[14:55] <audreyt> is what I'd expect

[14:56] * ruoso parsing the code

[14:57] <ruoso> hmmm... ok

[14:57] <audreyt> or maybe just ->grammar($source)

[14:57] <ruoso> audreyt, i think so

[14:58] <audreyt> k

[14:59] <ruoso> audreyt, Grammar::Perl6::grammar is already the compiled rule

[15:00] <ruoso> audreyt, i think it's just ->grammar($source)

[15:01] *** justatheory joined
[15:01] <ruoso> which would be a good name for the match variable in perl 5?

[15:02] <ruoso> $MATCH may not be a good name...

[15:04] <ingy> hi justatheory

[15:05] <ingy> hi audreyt

[15:05] * ruoso will use something weird like... $M_A_T_C_H____I_T

[15:05] * stevan wonders if ingy notices him

[15:05] * ruoso doubt something would create a variable with this name

[15:05] * ingy *rubs* stevan

[15:06] * stevan *blushes*

[15:06] <ingy> did I rub you the wrong way?

[15:06] <eric256> why not just $_MATCH ?

[15:06] <ruoso> eric256, ok... $_MATCH is a good name

[15:06] <stevan> ingy: :)

[15:07] <ingy> $m√§tch

[15:07] <stevan> ingy: did you see my Moose?

[15:07] <ingy> no

[15:07] * eric256 wonders hos stevan can keep loosing his Moose

[15:07] <stevan> ingy: http://search.cpan.org/~stevan/Moose-0.01/

[15:08] <rgs> makes object orientation sound easy

[15:09] <ingy> stevan: cute

[15:09] <ingy> almost Spiffy

[15:09] <stevan> ingy: next step is mixins,.. then it will be spiffy-er

[15:10] <rgs> Makes Object Orientation Spiffy- Er

[15:10] <stevan> :)

[15:10] <ingy> use Spiffy -er;

[15:11] <ingy> hmm

[15:11] <stevan> :)

[15:11] <rgs> more ideas than you can handle !

[15:11] <stevan> ingy: I have before/after/around methods though,.. Spiffy aint got that

[15:11] <stevan> :P

[15:12] <rgs> My Overcraft Overfilled with Some Eels

[15:12] * rgs will stop the acronym game nom

[15:12] <stevan> rgs: no, please,.. go on :)

[15:12] * stevan is writing them all down

[15:13] <rgs> :)

[15:14] <stevan> Moose Often Ovulate Sorta Early

[15:14] *** hexmode joined
[15:14] <ruoso> stevan++...

[15:15] <stevan> Most Other Object Systems Emasculate

[15:16] <obra> heh

[15:17] * ruoso is hungry... needs to lunch...

[15:17] <ingy> "Moo" says Elk!

[15:17] <ingy> ELK!

[15:17] <ruoso> ingy+++++++

[15:17] <rgs> :))

[15:23] *** elmex joined
[15:23] <eric256> heheh i meant to make a short response to http://perlmonks.org/?node_id=536951 and ended up with an essay

[15:23] <eric256> lol

[15:26] <eric256> i don't understand why people think micro and macro evlotion are seperate things when they are just different views of the same process at different scales. ....blah

[15:26] <svnbot6> r9624 | ruoso++ | $/ in Perl 6 will be emmited as $_MATCH in Perl 5

[15:31] *** rindolf joined
[15:31] <rindolf> Hi all!

[15:32] <eric256> hey

[15:32] <rindolf> eric256: hi! What's up?

[15:33] <eric256> currently just griping about micro/macro evolution and why some people think they are different. lol

[15:33] <eric256> you?

[15:35] *** pmichaud joined
[15:36] <obra> hey pmichaud

[15:36] <rindolf> eric256: I finished converting my first program from Perl 5 to Perl 6.

[15:36] <pmichaud> hiya, obra

[15:36] <rindolf> eric256: now I'm looking for ways to make it more perl-sixy

[15:36] <obra> I was literally just going through the milestones doc.

[15:36] <obra> I had typed "svk log" and not yet hit return to see how recently you'd updated ;)

[15:36] <obra> oh. I did hit return. but the console was on another desktop

[15:37] <pmichaud> not recently, I'm afraid.  I can do that after I track down the parrot bug that has me blocked

[15:37] <arguile> Many Overloaded Object Systems Exists -- Moose Offers Often Super Extensions

[15:37] <obra> Would you rather edit directly or reply to a bit of mail from me and have me edit?

[15:37] <eric256> hehe i read that perl-sexy lol

[15:37] <pasteling> "rindolf" at 88.153.140.201 pasted "Perl 6 Program to Calculate the Graham Numer" (258 lines, 7.7K) at http://sial.org/pbot/16352

[15:37] <pmichaud> if you send me the mail, I'll edit or reply as appropriate :-)

[15:37] <obra> Ok :)

[15:40] <eric256> rindolf loop ($p=$start_from; ; $p++) looks wierd... what about  while(1) { $p++   ?

[15:40] <eric256> a little clearer that this loop is going to go forever if it doesn't find a stop case on its own

[15:41] <lumi> while(1) {} is written loop {}, isn't it?

[15:41] <rindolf> eric256: thing is the $p++ needs to be at the end, and I need to use $p = $start_from;

[15:41] <obra> pmichaud: sent

[15:41] <pmichaud> obra: okay, thanks

[15:41] <eric256> yea but $p = $start_form can be before the loop.

[15:42] <rindolf> eric256: I like it better as loop.

[15:42] <eric256> though ti looks like your loop always stops at the first occurence of $n % $p = 0 so why not make the loop seperate?

[15:42] <lumi> If it's not scoped to the loop anyway...

[15:42] <pmichaud> obra: received.  I'll tackle it as soon as I get over the parrot hump

[15:42] <rindolf> eric256: can I do something like first { $n % $_ == 0 } ($start_from..Inf)

[15:43] <obra> thanks

[15:43] <rindolf> ?

[15:43] <eric256> do { $p++ } until  ($n % $p == 0);

[15:43] <TimToady> for $start_from... -> $p { ... }

[15:44] <eric256> $p = $start_from; while ($n % $p) { $p++ };

[15:45] <lumi> lazy { filter { !($n % $^a) } $start_from..Inf } ?

[15:46] * eric256 stares at lumi

[15:46] <lumi> Too long in haskell-land, sowwy

[15:46] <rindolf> lumi: I only need the first element.

[15:46] <lumi> Yeah, so [0] from that :)

[15:47] <rindolf> lumi: Scalar::Util has a first function.

[15:47] <rindolf> lumi: sorry List::Util.

[15:47] <rindolf> lumi: does Perl6 has something like that?

[15:48] <lumi> Nunno

[15:48] <TimToady> [||] or some such

[15:49] * eric256 wonders if we can get rindolf to post this to PM with some test cases. ;)

[15:50] <rindolf> eric256: Perl Monks?

[15:50] <eric256> yea rindolf...i'm trying to drag perlmonks into p6 land slowly ;)

[15:50] <eric256> besides we have to start accumulating this ideas and code somewhere, and thats already there.

[15:51] <rindolf> So is there a "first" or "take" or whatever?

[15:51] <eric256> i don't think so. but it would be easy to write your own.

[15:52] <gaal> wasn't gather/take stipulated in S29?

[15:52] <lumi> Ah yeah, take

[15:52] <rindolf> gaal: ahoy!

[15:52] <gaal> hi rindolf

[15:52] <rindolf> gaal: sup?

[15:53] <gaal> it's all good

[15:53] <rindolf> gaal: good.

[15:53] <eric256> sub first (Code &code, @list) { for @list { return $_ if &code($_) } }; or something like that

[15:54] <eric256> symantics might be wrong there dunno

[15:54] <TimToady> guys, first is [||]

[15:54] <gaal> TimToady: [//] probably?

[15:54] <rindolf> TimToady: [||]

[15:54] <rindolf> TimToady: how do I use it?

[15:54] <TimToady> it's just a list operator [||] @list

[15:54] <eric256> TimToady how can that be used when he wants the first one that that forumula returns 0 on?

[15:54] <rindolf> TimToady: lemme se.

[15:55] <gaal> eric256: [//] instead :)

[15:55] <eric256> @list.first { $n % $^a == 0 };

[15:55] <eric256> [//] map { $n % $^a } @list; ??

[15:56] <eric256> maybe something like [//] grep { $n % $^a ==0 } @list;

[15:56] <gaal> rindolf: [someop] @list is reduce @list with someop

[15:56] <rindolf> gaal: OK.

[15:57] <gaal> eric256: which is lumi's suggestion :)

[15:57] <gaal> except he spelt 'grep' 'filter' because he's such a golfer

[15:57] <eric256> gaal in a not so haskell way. lol

[15:57] <TimToady> It's kind of a shame that [someop] has to be limited to predeclared infix ops.

[15:58] <eric256> yea those are all still a pretty un-obiovus way to write @list.first:{$n % $^a == 0};

[15:58] <rindolf> Hmmm... lazy{[||] grep { 10 % $_ == 0 } (3..Inf)} does not work.

[15:58] <TimToady> but otherwise it's ambiguous with [1,2,3] things

[15:58] <gaal> TimToady: are backticks used already for something? :)   # haskell `f` infix-anything

[15:58] <TimToady> I don't think pugs does infinite lists yet correctly.

[15:58] *** FurnaceBoy joined
[15:59] <TimToady> backticks are attempting to be reserved for users to define

[15:59] <gaal> use MyBackticksAreStrongerThanYours;

[15:59] <TimToady> right

[16:00] <TimToady> at least we can differentiate infix:<`> from prefix:<`>

[16:00] <gaal> good thing Perl isn't in the habit of giving primes to the user to generate more identifiers, or we'd be dealling with `, `', `'', `''', ...

[16:01] <TimToady> well, the mathematicians use primes because numbers confuse them.

[16:01] <eric256> feather is crawling today ;)

[16:01] <gaal> eric256: did someone perhaps forget to nice their build?

[16:01] <rgs> mmh quotes in identifiers : a sudden puff of perl 4.

[16:02] <gaal> I don't think you could use adjacent quotes in identifiers in perl4

[16:02] <gaal> My::::Distant::::::::Relative

[16:02] <rgs> I don't have a perl 4 handy to check :)

[16:03] <TimToady> perl 5 doesn't allow a''b

[16:03] <TimToady> a'b actually derived from Ada.

[16:04] * rgs notes that perl 5 had no regression test for the "Bad name" error, and adds

[16:05] <gaal> .oO( quote from the future: "I don't have a perl 5 handy to check :) )

[16:05] <TimToady> though in Ada a'b was indicated that b was a property of a

[16:06] <gaal> no nested or otherwise deep namespaces there?

[16:06] <gaal> brb

[16:07] <rindolf> Hmmm... now [//] grep { $n % $_ == 0 } ($start_from .. $n); fails some tests

[16:07] <TimToady> package why_would_you_need_deep_nesting?

[16:07] <eric256> rindolf [||] ( 1..150).grep:{ 10 % $_}; does work. so you just need to pick a high enogh number

[16:07] <eric256> err beat me to that...me and my slugish pug. lol.  what does it fail?

[16:08] <lumi> Is // right?

[16:08] <lumi> == would be a boolean, not ever an undef

[16:09] <TimToady> == is not what grep returns

[16:09] <rindolf> I see it converted it to a fraction. I had to intify it.

[16:09] <TimToady> it returns grepped number

[16:09] <TimToady> but then seems like it could just be [0] as suggested earlier.

[16:10] <TimToady> unless that forces non-lazy behavior on its left side.

[16:10] <eric256> ( 5..150).grep:{ 12 % $_ == 0}[0]; works

[16:12] <TimToady> The question is, will (5...).grep: { 12 % $_ == 0 }.[0] work eventually when infinite lists work?

[16:12] <eric256> shouldn't it? i mean it should unlazify up to the requested element

[16:12] <pasteling> "rindolf" at 88.153.140.201 pasted "New version of graham.p6" (250 lines, 7.5K) at http://sial.org/pbot/16353

[16:13] <TimToady> I think it should work.

[16:17] <eric256> doesn't p6 have memoization built in?

[16:17] <rindolf> eric256: maybe it does.

[16:17] <rindolf> eric256: but I need to memoize only on $n and not on $start_from.

[16:18] <eric256> you don't care where they are starting from?

[16:18] <rindolf> eric256: in the original p5 script, my own custom memoization was faster than MJD's Memoize module.

[16:18] <rindolf> eric256: I'm talking about get_squaring_factors.

[16:19] <rindolf> eric256: $start_from is passed by the upper functions in the stack to indicate where to start looking for new factors.

[16:20] <eric256> hmm can't find any reference to memoization in the docs, must have imagined that

[16:21] <eric256> i could have swarn i read about it and it let you defined which parts of the sub signature to memoize on, must have been currying i was thinking of

[16:24] <eric256> for @$n_sq_factors -> my $p  ..... the my there is redundant i've been told.

[16:26] <TimToady> yes, $p is a formal parameter to the block, so it's automatically lexically scoped to the block.

[16:27] <eric256> would if (($min_id < 0) || ($min_id > $id)) be clearer as !(0 < $mind_id < $id)

[16:29] <TimToady> I'd kinda like to see $min_id !~ 0..$id myself

[16:30] <pmichaud> er, that would need to be !(0 <= $min_id <= $id), yes?

[16:30] <Limbic_Region> $min_id eq none(0 .. $id); # what's the right way to say this with a junction?

[16:30] <eric256> pmichaud dunno, i have a hard time with the < || situation, hurts my brain. lol

[16:31] <Limbic_Region> $min_id ~~ none(0..$id); # perhaps

[16:31] <eric256> Limbic_Region that assumes they are integers

[16:31] <TimToady> what if $min_id is 1.5?

[16:31] *** szabgab joined
[16:31] <TimToady> Why use a junction if a range will do?

[16:31] <Limbic_Region> then you sleep while you are at work because you aren't getting any at home with the newborn

[16:32] <szabgab> ?eval my @a = (1, 2, 3); my @b = map { {"v"=>$_, "d" => $_*2} } @a; say @b.elems;

[16:32] <TimToady> what makes you think it gets any better later?   :)

[16:32] *** evalbot_9601 is now known as evalbot_9624

[16:32] <evalbot_9624> OUTPUT[6 ] bool::true

[16:32] <eric256> Limbic_Region  been there done that. ;)

[16:32] <szabgab> so how do I create hash refs in a map ?

[16:33] <Limbic_Region> szabgab - you can say hash

[16:33] <eric256> szabgab hash { "v"=>$_}

[16:33] <szabgab> ?eval my @a = (1, 2, 3); my @b = map { hash {"v"=>$_, "d" => $_*2} } @a; say @b.elems;

[16:33] <Limbic_Region> ?eval my @a = 1..3; my @b = map { hash {"v" => $_, "d" => $_ * 2} } @a; say @b.elems

[16:34] <TimToady> but it ought to be taking that as a hash anyway.

[16:34] * Limbic_Region is little slow

[16:34] <evalbot_9624> OUTPUT[3 ] bool::true

[16:34] <Limbic_Region> ?eval my @a = 1..3; my @b = map { hash {"v" => $_, "d" => $_ * 2} } @a; @b.perl

[16:34] <evalbot_9624> "[(\"d\\t2\" => (\"v\" => 1)), (\"d\\t4\" => (\"v\" => 2)), (\"d\\t6\" => (\"v\" => 3))]"

[16:34] <Limbic_Region> ?eval my @a = 1..3; my @b = map {  {"v" => $_, "d" => $_ * 2} } @a; @b.perl

[16:34] <Limbic_Region> I think it was TimToady

[16:34] * Limbic_Region verifies

[16:35] <szabgab> TimToady: so is my first example a bug in Pugs ?

[16:35] <evalbot_9624> "[(\"d\" => 2), (\"v\" => 1), (\"d\" => 4), (\"v\" => 2), (\"d\" => 6), (\"v\" => 3)]"

[16:35] <TimToady> looks like it to me.

[16:35] <Limbic_Region> no szabgab - but probably in evalbot

[16:35] <szabgab> it is the same in my Pugs

[16:35] <rindolf> eric256: I'd rather keep it with the || because I'm using two different conditions.

[16:35] <szabgab> that's why I asked as I could not figure out

[16:36] *** amnesiac joined
[16:36] <TimToady> looks like maybe the presence of $_ is forcing a closure interpretation when it should only be paying attention to the =>,=> ness

[16:37] <szabgab> I add a test somehere

[16:39] *** sahadev joined
[16:40] <eric256> rindolf or something like my @ids = @$final_vec.map:{ %primes_to_ids_map{$p} }; my $min_id = sort { $^a <=> $^b } [0];  then just look up the prime from the id ;)

[16:41] <eric256> and pretty much all of your c style loops can be wrtten with for ( ) -> { } format.

[16:42] * eric256 starts building a Util::Array module that has  .first:{}, .last:{}, .min, .max ;)

[16:42] <rindolf> eric256: you have  few typos in your lines.

[16:43] <eric256> rindolf not surprising. ;)

[16:43] *** bernhard joined
[16:44] <eric256> anyone know where the documentation on array and hash methods can be found?

[16:45] <rindolf> eric256: I'm not sure there is a way to look up the prime from the ID.

[16:46] <eric256> rindol... you wrote it. ;) i thought from other spots it looked like some of your code could be reduced if you had a hash mapped the other way too.

[16:46] <audreyt> eric256: yes, in docs/Perl6/API/Array.pod

[16:46] <audreyt> eric256: but (surprisingly) you need to write it first! :)

[16:46] <eric256> errr i was looking in the S\d? is that not the place to look?

[16:46] <audreyt> eric256: you can take materials from docs/Perl6/Spec/Builtins.pod

[16:46] <svnbot6> r9625 | szabgab++ | multi-key hashref is flattend in map

[16:46] <audreyt> eric256: but S29 (Builtins.pod) is probably not going to cover every single class methods

[16:47] <audreyt> neither would it be desirable to put everything in a .pod

[16:47] <audreyt> eric256: so maybe help factoring out some :)

[16:48] <eric256> are those .pod converted into HTML for easy viewing anywhere?  yes i'm aware some people find pod easy to view, i'm just not one of them

[16:49] <audreyt> try "make htmlifypods" ?

[16:49] <audreyt> in the docs/Perl6 directory

[16:50] <audreyt> or, once we upload Perl6::Doc to CPAN, use the search.cpan.org interface

[16:50] <justatheory> hi ingy

[16:50] <audreyt> or, pod2html Builtins.pod > builtins.html

[16:51] <audreyt> or, (for now) http://search.cpan.org/dist/Perl6-Bible/lib/Perl6/Bible/S29.pod

[16:51] <audreyt> timtowtdi :)

[16:52] <TimToady> did someone say my name?

[16:52] <audreyt> er no, it's a common soundalike

[16:52] <eric256> rindolf btw my %id_to_prime =  reverse %prime_to_id; should work...i think

[16:53] <TimToady> I need to get a better name...

[16:53] <eric256> is that where you got your name?

[16:53] <rindolf> eric256: I see.

[16:53] <lumi> I didn't know irssi had soundex notify

[16:53] <TimToady> amazing what you can do with festival...

[16:55] <pasteling> "rindolf" at 88.153.140.201 pasted "graham.p6 - latest version" (250 lines, 7.4K) at http://sial.org/pbot/16354

[16:55] <rindolf> audreyt: do you have any idea how to better perl6-ify http://sial.org/pbot/16354 ? It's a solution to the Perl Expert QOTW 8.

[16:55] <TimToady> though now that I test it, it doesn't actually say those two quite the same.

[16:56] <TimToady> I'm sure if I actually did hook up #perl6 to festival my family would rebel.

[16:56] <pmichaud> TimToady: if they haven't rebelled by now.... what makes you think they ever will?  ;-)

[16:56] <audreyt> I tried that once... doesn't really work

[16:56] <audreyt> if you can hook nicks to different voice profiles

[16:56] <TimToady> ]I think it might work for notification of someone looking for you though.

[16:56] <audreyt> then maybe

[16:57] <audreyt> rindolf: looking

[16:57] <ingy> justatheory: :)

[16:57] <ingy> justatheory: you wrote Test.Simple, right?

[16:57] <justatheory> ingy: I did.

[16:57] <justatheory> It has my name on it, no?

[16:57] <ingy> I use it a lot

[16:57] <ingy> I wrote Test.Base

[16:57] <justatheory> Yes, I saw that you bundled it with one of your JSAN modules.

[16:58] <justatheory> Right, that one

[16:58] <justatheory> Why not just require Test.Simple?

[16:58] <eric256> audreyt  on the docs front...should i move the Array part out of Builtins...or just copy it to API/Array.pod ?  copy seems bad sense there would be two non-synced versions.

[16:58] <ingy> Do you know what Test::Base is on CPAN?

[16:59] <ingy> it's a data driven framework over Test::More

[16:59] <ingy> Test.Base is the port to JS

[16:59] <justatheory> I figured

[17:00] <ingy> so what do you mean by your question?

[17:00] <TimToady> eric256: this is a profound question relating to MMD vs SMD.

[17:00] <ingy> oh bundled...

[17:00] <ingy> I get it

[17:00] <ingy> because I patch it quite a bit

[17:01] <TimToady> in the long run it can probably only be solved by hyperlinking of some sort or other.

[17:01] <ingy> I was wondering if you wanted the patches?

[17:01] <ingy> I end up bundling Test.Base and Test.Simple in other modules too.

[17:01] <ingy> But a Makefile does all the work

[17:02] <audreyt> eric256: just copy

[17:03] <audreyt> eric256: for things that takes an array as invocant

[17:03] <audreyt> and doesn't ever care about its other argument's type (or that only one type would make sense)

[17:03] <audreyt> I think bring them forward to API/Array makes sense

[17:03] <eric256> i read the README but it doesn't mention what the Spec versus API directories are

[17:03] <TimToady> but what will we do about MMD.  I'd tend to argue they should be also sorted by first arg.

[17:04] <TimToady> but with refs from the "other" type, maybe, unless it becomes culturally obvious.

[17:04] * eric256 thinks we need something entirly different than pod...or some way to compose pods together

[17:04] <TimToady> on the other hand, people adding MMD "after the fact" probably don't have access to the original docs in some cases...

[17:05] <TimToady> obviously we just need to teach everyone to look up docs via &foo:(Array,Hash).docs()

[17:05] <eric256> okay my head hurts.. lol

[17:06] *** fglock joined
[17:06] <TimToady> MMD hyperlinks, yum.

[17:06] * gaal meows

[17:06] <eric256> but seriously what about some way to register all the function documentation once for each function, and then have some index files that pull all that info together in different ways?  one synced copy, and multiple static lookup pages.  just my two cents

[17:07] <TimToady> sure, it'd be nice if p6 docs were actually searchable, unlike a certain other language I could name.

[17:08] * eric256 begins to ponder if pod could be abused as some sort of database for functions. or if that is abusing pod too much

[17:09] <TimToady> pod specs are currently being nailed down, so now's a good time to ask.  gee, is ingy hiding now?  :)

[17:09] *** ruoso joined
[17:09] * ingy hides

[17:10] <eric256> it would be nice to include as part of the pods specs because then it could be used in actual applications

[17:11] <fglock> ruoso: hi!

[17:12] <TimToady> perhaps it doesn't need to be in the initial pod specs, as long as =use is powerful enough to pull in a system of sufficient functionality.

[17:12] <ingy> eric256: join #perldoc

[17:13] <TimToady> because I think docs, like programming languages, need to be able to evolve as needs change, and nailing down one way to do it is probably going to be wrongish in the long run.

[17:13] <ruoso> fglock, hi

[17:13] <hcchien> hmm...., pugs seems a little slow on my powerbook.

[17:13] <ingy> TimToady++

[17:13] <fglock> ruoso: congrats for lrep.p6!

[17:14] <TimToady> fglock++ too

[17:14] <ruoso> fglock, it wouldn't be where it is without your work

[17:14] <ruoso> fglock++

[17:15] <GabrielVieira> :)

[17:15] *** pdcawley_ joined
[17:15] <justatheory> ingy: Yes, send me the patches.

[17:16] <ingy> justatheory: ok, next time I'm in there I will do.

[17:16] <ingy> which is pretty often

[17:16] <justatheory> Cool.

[17:16] <justatheory> We can always chat about it on #jsan on freenode, too

[17:17] <fglock> ruoso: I rewrote parts of the rule engine, to allow for OO grammars - but I still need a few more hours before I can commit something that works

[17:18] <ruoso> fglock, right... I'm almost in the point to use it the way you're doing...

[17:18] *** SamB joined
[17:19] <ruoso> fglock, but, I'll be working in other stuff this afternoon... so if you want to switch the rule engine in lrep-compiler... feel-free...

[17:20] <ruoso> fglock, I'm still thinking in the refactoring of Perl6.p6

[17:20] <eric256> i joined perldoc but there isn't anyone in there. lol

[17:21] <ruoso> fglock, take a look at Grammar_Model.txt and see how I plan to re-organize the rules

[17:21] <fglock> ruoso: the engine internals changed, and the code will need recompilation - but I wrote a version of lrep that can compile to the new engine

[17:21] <ruoso> fglock, and change it at will

[17:21] <eric256> TimToady is there someone i can see current spec for use?

[17:21] <fglock> ruoso: ok

[17:21] <ruoso> fglock, we're bootstrapped now...

[17:22] <ruoso> fglock, we can change lrep and recompile everything...

[17:22] <GabrielVieira> what is going to be the open syntax?

[17:22] <ruoso> :)

[17:22] <ruoso> GabrielVieira, there is an example in lrep.p6

[17:22] <ruoso> GabrielVieira, I don't know if that is correct

[17:22] <GabrielVieira> but without a method attribute

[17:22] *** r0nny joined
[17:22] <GabrielVieira> like if is < or > or >>

[17:22] <TimToady> eric256: do you mean =use?

[17:23] <GabrielVieira> or r, rw, etc

[17:23] <eric256> yea

[17:23] <ruoso> GabrielVieira, I used IO::File at first time...

[17:23] <ruoso> GabrielVieira, then I let to implement it later...

[17:23] <GabrielVieira> we were talking a time ago about that

[17:23] *** ghenry joined
[17:23] <GabrielVieira> TimToady whats that guys nickname? chromatic?

[17:24] <GabrielVieira> he made the open function.. but without an atributte

[17:24] <GabrielVieira> buuut..

[17:24] <TimToady> yes, chromatic temporarily forgot that indirect object in P6 requires colon.

[17:24] <TimToady> but it's fixed.

[17:24] <ruoso> fglock, btw... feel free to commit there anytime even if it breaks everything :)...

[17:24] <ruoso> fglock, broke things are more produtive

[17:25] <ruoso> s/broke/broken/

[17:25] <GabrielVieira> the "lrep" file (which i imagine that is the perl6 compiled by perl6) has a open $out_fh, '>', $output_filename; syntax...

[17:25] <GabrielVieira> TimToady im talking about the "open for write.. read.. etc.. attribute.. :) the colon was fixed

[17:26] <fglock> ruoso: I've already enough broken things

[17:26] <GabrielVieira> ruoso "lrep" is the lrep.p6 compiled by lrep.p6?

[17:27] <fglock> ruoso: new engine, new grammar, new compiler, new OO - I wonder if this will work :)

[17:27] <ruoso> GabrielVieira, yes... I removed lrep.pl...

[17:27] <GabrielVieira> hum

[17:27] <GabrielVieira> so

[17:28] <ruoso> fglock, if not, we'll make it work :)

[17:28] <GabrielVieira> in lrep the open function is with a "write" attribute... but lrep.p6 there inst

[17:28] <ruoso> GabrielVieira, chromatic probably implied the ">" in Emitter::Perl5

[17:29] <GabrielVieira> hum

[17:29] <GabrielVieira> so

[17:29] <GabrielVieira> can i fix?!

[17:29] <GabrielVieira> xD

[17:29] <GabrielVieira> eheh

[17:30] <GabrielVieira> i dind find perl6 open syntax... if its gonna be "open FH: $file, rw" or with > again..

[17:31] <svnbot6> r9626 | fglock++ | PCR - updated grammar (compiled by a modified lrep); engine migration under way (tests fail)

[17:32] <ruoso> GabrielVieira, Perl6::Bible

[17:32] <ruoso> GabrielVieira, take a look there

[17:32] <GabrielVieira> iv done

[17:33] <GabrielVieira> but the open function inst there yet

[17:33] <GabrielVieira> i thing its going to be the same

[17:34] <szabgab> GabrielVieira: try docs/quickref/files

[17:35] <szabgab> GabrielVieira: is my $fh = open "filename", :r

[17:35] <GabrielVieira> hum

[17:36] <rindolf> audreyt: here?

[17:38] <justatheory> seen stevan

[17:39] <justatheory> bah, no purl. :-(

[17:40] <stevan> hey

[17:40] <justatheory> stevan: Just noticed your Class::MOP.

[17:41] <justatheory> Am I insane, or is it kinda similar to Class::Meta?

[17:41] <GabrielVieira> szabgab humm

[17:41] <GabrielVieira> so

[17:41] <stevan> similiar, but not the same

[17:41] <GabrielVieira> so r: means open to read?

[17:41] <justatheory> No, of course not the same, or else there wouldn't be two of them, eh? ;-)

[17:41] <stevan> :)

[17:41] <stevan> justatheory: I think the two modules have different goals though

[17:41] <justatheory> But the same idea: introspection/reflection, class generation, etc.

[17:42] <justatheory> ah?

[17:42] <justatheory> oh?

[17:42] <stevan> class generation is a side-feature of Class::MOP

[17:42] <justatheory> uh-huh

[17:42] <stevan> the primary goal of C::MOP is metaclasses

[17:42] <stevan> which can be attached to any old p5 class

[17:43] <stevan> from what I could grok of Class::Meta it seemed to be more about introspection and reflection for Class::Meta based classes

[17:43] <stevan> I could be wrong though

[17:45] <GabrielVieira> szabgab do u know about the :r in open function?

[17:45] <szabgab> GabrielVieira: personally? not much :-) but it means to open to read

[17:45] <TimToady> :r is the default, obviously.

[17:46] <GabrielVieira> heheh

[17:46] <TimToady> so open($filename) just works.

[17:46] <GabrielVieira> humm

[17:46] <GabrielVieira> what about open to print?

[17:46] <GabrielVieira> ops

[17:46] <GabrielVieira> write :P

[17:46] <ruoso> TimToady, that's exactly the opposite chromatic made on lrep.p6 :)

[17:46] <szabgab> :w write :a append

[17:46] <GabrielVieira> hum

[17:46] <GabrielVieira> is there a documentation about it?

[17:47] <szabgab> :rw read and write

[17:47] <TimToady> it's not clear yet whether '>' etc are good to continue to support.

[17:47] <GabrielVieira> humm

[17:47] <ruoso> TimToady, that's why I choose to use IO::File in the meanwhile.. :)

[17:47] <stevan> justatheory: if you want, we can talk about this is more detail, just /msg me over at irc.perl.org (I lost my freenode password :)

[17:47] <TimToady> It's also not clear that all of these are "open", which is getting rather heavily overloaded.

[17:48] <szabgab> with '>' people sometimes think it is shell redirection

[17:48] <szabgab> maybe   print "text" > "filename"  should work ?

[17:48] <TimToady> it's supposed to be suggesting of that, but if it ends up after the fliename, it's counterintuitive, and if it's before, it's ambigious.

[17:49] * ruoso thinks open doesn't need to be a core function

[17:49] <TimToady> I wouldn't spell it with '>' if we had such an operator.  Maybe

[17:49] <TimToady> print "text" ==> "filename" could be overloaded to work.

[17:50] <TimToady> but "filename" ==> @list

[17:50] <TimToady> would be taken as a single element list.

[17:50] <TimToady> ="filename" is about as close as you can get without special redirection ops.

[17:51] <TimToady> and even that assumes unary = is smart about strings.

[17:52] <TimToady> =<filename> probably works.

[17:57] <TimToady> but that doesn't solve the open problem, which is fundamentally the fact that open is trying to intuit OOish ideas from non-OOish arguments, and there are too many dimensions to make every linear representation the "right" order of arguments.

[18:00] <TimToady> for example, the filename wants to come before the modifiers when you're opening an ordinary file, but when you're opening a pipe, you'd like the modifiers, and then the command as a variadic list.

[18:01] <TimToady> named argument syntax can sort of some of that, but eventually you really need to break your single function down into different methods, or the same named method on different classes.

[18:01] *** Limbic_Region joined
[18:01] <szabgab> shouldn't opening a pipe be a separate function ?

[18:02] <TimToady> probably, but do we split it out on the name axis or the type axis?

[18:02] <eric256> open :file("filename") :r    pure named params. totaly obvious ;) and you could even do :pipe(whatever would go here)

[18:02] <ruoso> eric256++

[18:02] <TimToady> open http: $foo

[18:03] <TimToady> open uri: $foo

[18:03] <TimToady> open file: $foo

[18:03] <TimToady> open pipe: $foo

[18:03] <eric256> only problem is people who do open :file "x" :pipe "y" etc.

[18:03] <TimToady> if those are types, that's just indirect form of:

[18:03] <TimToady> http.open($foo)

[18:03] <TimToady> uri.open($foo)

[18:03] <TimToady> etc.

[18:03] <eric256> ohhh that works too.

[18:04] <ruoso> i like it

[18:04] <wolverian> what does open http versus uri mean?

[18:04] <TimToady> then the question arises whether open should be polymorphic and just dispatch to the "real" underlying constructor.

[18:04] * ingy likes the lazy open ala IO::All

[18:04] <eric256> URI could be a network file wolverian

[18:04] <wolverian> eh, of course. thanks :)

[18:04] <TimToady> and whether "use open <uri file pipe>" should influence the handler order.

[18:04] <wolverian> albeit that doesn't feel very pure - http.does(uri)?

[18:05] <TimToady> the question is whether it assumes "http:" on the front.

[18:05] <ruoso> but this is in the same level IO::File is...

[18:05] <ruoso> or IO::*

[18:06] <szabgab> open dir:

[18:06] <justatheory> stevan: Sorry, I gotta take care of my sick daughter. I'll bbl

[18:06] * justatheory & # bbl

[18:06] <stevan> justatheory: take your time :)

[18:08] <ruoso> so, how does 'open http:"www.google.com"' looks like?

[18:08] <TimToady> one is inclined to shorten open uri: to uri(), but that's inside out like P5's hex function.

[18:08] <TimToady> under an MMD view, you want to cast the string:

[18:08] <TimToady> open uri($foo)

[18:08] <TimToady> maybe

[18:08] <ingy> night all

[18:10] <theorbtwo> I'm not sure it makes terribly much sense to try to unifiy directory open and file open; the only thing they have in common is that they both open files.  You can't read bytes out of a directory, or files out of a nondirectory.

[18:10] * ruoso always get confused by the hex funtion...

[18:10] <TimToady> night, ingy.

[18:10] <TimToady> which is why hex() is gone in p6

[18:10] <theorbtwo> Lots of newbies get confused by hex() when they want sprintf("%x"...)

[18:11] <Arathorn> hex() always seemed to be a bit of a BASIC refugee

[18:11] <ruoso> TimToady, isn't it the case to leave open just to files and the rest to modules?

[18:11] <TimToady> it violates the cultural expectation that foo(bar) turns a bar into a foo.

[18:11] <TimToady> ruoso: that's kind of what I've been working around to.

[18:12] <TimToady> but arguably someone from the future could argue that uri should be the default rather than bare filename...

[18:13] <TimToady> so I've been putting off designing open() because, well, I always want to have my cake and eat it too...

[18:13] <ruoso> TimToady, for a module, maybe... for a reserved word... I don't think so...

[18:13] <ruoso> TimToady, oneliners usually don't use open

[18:13] <TimToady> which is why I wonder about "use open".

[18:13] <theorbtwo> I think it'd be nicer if there was no function named open, so nonfile open could share an API with file open, just on a different module.

[18:13] <theorbtwo> My oneliners often use open, but they use LWP::Simple almost as often.

[18:14] * ruoso votes for plain modules in place of open...

[18:14] <theorbtwo> (We probably want to have the module for ordinary open around without using it, but that's an implementation detail.)

[18:15] <eric256> if we go file.open, uri.open etc then those would each be in a module right? easy to add to the same syntax form later

[18:15] <TimToady> I think standard function open() is "proto open (Str, *%args)" or some such, and everything else is left to MMD.

[18:15] <theorbtwo> BTW, note that there's no way to give a CWD-rel path as a file: URL.

[18:15] <TimToady> Right, if you call as SMD, you get SMD.

[18:16] <TimToady> if you call as a function or list operator, you get MMD.

[18:16] <TimToady> but I think that means we don't have

[18:16] <TimToady> open('>', $filename);

[18:16] <theorbtwo> Shouldn't those not be in the root namespace?

[18:17] <theorbtwo> Is writing "file." that hard?

[18:17] <TimToady> SMD methods are never in the root namespace.  Which "those" are you meaning?

[18:17] <ruoso> TimToady, what about: open($file) or open(*%args,$file)

[18:17] <theorbtwo> I mean the "file", etc, modules.

[18:18] <eric256> i like file.open("test" :r);  or even file.open("test" :read)

[18:18] <ruoso> eric256, why not just parameters?

[18:18] <TimToady> nit: probably requires comma before :r there...

[18:18] <eric256> i don't think most people will mind file. if it means they also get things like http.open

[18:19] <ruoso> eric256, then it's better to be IO::File.open($file,:r)

[18:19] <eric256> TimToady yea i wasn't sure about the comma and open could be multi with a string followed by named, or just pure named right?

[18:19] <ruoso> using standard module names

[18:19] <TimToady> I'm saying we can have file.open as well as open().  We've been careful to distinguish SMD from MMD calls for anything with multiple args.

[18:19] <eric256> ruoso why?  file could be a standard module

[18:20] <theorbtwo> Why do we want open() when we have file.open() or IO::File.open()?

[18:20] <ruoso> eric256, it's confusing to have some modules Capitalized and some lowercase...

[18:20] <eric256> ruoso lowercase modules are used by default.  strict and warnings aren't confusing

[18:20] <ruoso> eric256, they are pragmas

[18:20] <ruoso> eric256, that's why they aren't confusing

[18:21] * eric256 doesn't find standard modules with lowercase names confusing in the least

[18:21] <TimToady> to2: huffman wants something short for just reading a file.

[18:21] *** fglock left
[18:21] <ruoso> TimToady, there's slurp...

[18:22] <TimToady> slurp is not the same

[18:23] <theorbtwo> ...but file access types are the kind of thing that people are going to want more of, and it'll lead to the proliferation of short, lowercase, colonless module names on CPAN-ish.

[18:24] <ruoso> TimToady, so... just reading a file requires just open("file","mode")

[18:24] <eric256> theorbtwo not if its just used for the builtins, whatever those turn out to be

[18:24] <TimToady> "Short, lowercase, colonless module names, the Final Frontier..."

[18:24] <TimToady> no, just open $file

[18:24] * theorbtwo laughs.

[18:24] <eric256> TimToady it sounds like you *can* have your cake and eat it too

[18:25] <TimToady> up to a point, and I think that point is open('>', $filename).

[18:25] <theorbtwo> I think that's a reasonable point.

[18:25] <eric256> errr...meaning? lol i'm a little slow

[18:25] <ruoso> so... two prototypes: open($filename) or open($mode,$filename)

[18:26] <TimToady> unless we special-case :> or some such.

[18:26] <eric256> :> ewww

[18:26] * ruoso see no problems in using > inside quotes

[18:26] *** bsb joined
[18:27] <TimToady> but there's no MMD proto open (Str, Str).

[18:27] <eric256> open('file') ==> $fh; #read,       $fh ==> open('file'); #write

[18:28] <TimToady> congrats, you're reinventing IO::All  :)

[18:28] <eric256> lol

[18:28] <TimToady> only with sane pipe ops.

[18:28] <eric256> my $fh <== open("filename");   is kidn of pretty in its own way

[18:29] <TimToady> If we're gonna do that, I'd rather also have

[18:29] <TimToady> io('file') ==> $stuff

[18:29] <Limbic_Region> TimToady - I know you aren't implementing Perl 6 for fear that it will become Perl 5 but are you working with Nicholas at all on modifying Perl 5 to support p5 -> p5 and ultimately p5 -> p6?

[18:29] <GabrielVieira> so

[18:30] <GabrielVieira> open an url is going to be possible with open?

[18:30] <TimToady> LR: yes, I wrote the first year's worth of that code.  I haven't gone back and looked at what remains after integration with blead yet though.  Keep getting distracted by this IRC thang...

[18:30] <TimToady> certainly with uri.open()

[18:30] <TimToady> probably with open uri($str) if there's an MMD proto open (Uri...)

[18:31] <TimToady> but bare open $str is still gonna resolve to open(Str...)

[18:31] <TimToady> which defaults to files.

[18:31] <TimToady> unless we decide otherwise.

[18:31] <TimToady> but I think history is on the side of open defaulting to files.

[18:32] <ruoso> and what if ReadOnlyFile, WriteFile, AppendFile are types...

[18:32] <TimToady> If we want something to default to uris, maybe it's wget() or some such.

[18:32] <ruoso> and you have special tokens to them

[18:32] <ruoso> like >'file' will create a WriteFile type

[18:32] <ruoso> <'file' will create a ReadOnlyFile type

[18:32] <ruoso> and so on

[18:32] <TimToady> If they are, I don't want to know about it.  :)

[18:32] <wolverian> File does Write

[18:33] <TimToady> IO types is one of those areas where people have gone far too much in the analytical/reductionist direction.

[18:33] <ruoso> then open is a MMD, that has entries to open(read),open(write)

[18:33] <TimToady> why preserve a meme that's too heavily overloaded?

[18:34] <GabrielVieira> $content = open.file('file.txt',r);

[18:34] <GabrielVieira> $content = open.pipe('ls',w); # if w warns are displayed if -w they arent. :D

[18:34] <GabrielVieira> $content = open.url('www.google.com','80');

[18:34] <GabrielVieira> $content = open.https('www.google.com','6002');

[18:34] <GabrielVieira> $content = open.protocol('irc.freenode.org','irc','6667');

[18:34] <GabrielVieira> :P

[18:34] <eric256> ruoso if you do that then at least do open read(file) and open write(file_ instead)

[18:35] * Limbic_Region really likes GabrielVieira's approach fwiw

[18:35] <GabrielVieira> :)

[18:35] <TimToady> I don't really like a pseudo-type like "open.foo"

[18:36] <eric256> hmm make open the package and the method actualy be file?  drop the . add a space and you have the mmd approach

[18:36] <TimToady> all you've really done is invent a new indirect object notation.

[18:36] <GabrielVieira> yep

[18:36] <ruoso> open ==>'file'  open <=='file'  open <+='file'

[18:36] * ruoso brainstorming

[18:36] * Limbic_Region doesn't like indirect object notation but he does like clarity

[18:36] <GabrielVieira> it need to be easier as possible

[18:36] <eric256> ruoso stop stealing my ideas. lol

[18:37] <ruoso> ok... open is a mmd

[18:37] <eric256> $fh = open file('file.txt');  #is still clear

[18:37] <Limbic_Region> eric256 yes

[18:37] <GabrielVieira> maybe open, socket e pipe function resolves everything

[18:39] <TimToady> but do we really need the extra abstraction of a string that knows what it's supposed to turn into when opened?  why doesn't file() just open it?

[18:39] <eric256> yea i was kinda just wondering that.

[18:39] <GabrielVieira> socket('irc','irc.freenode.org','6667') / socket('https','www.google.com','6602') / socket('http','www.google.com') 80 is default / pipe('ls') / open for files

[18:39] <eric256> what is gained by making all of these work with just open? and is that gain kept with the MMD approach or just abstracted into oblivion

[18:40] <GabrielVieira> TimToady $filehandle = open(file);

[18:40] <eric256> i mean do they all return something thats a Handle object that the same operations can be done one?

[18:41] <TimToady> If we're goin to have self-typed strings, then we might as well just go with the http: convention.

[18:41] <TimToady> rather than reinventing it.

[18:41] <GabrielVieira> $filehandle = open.file('file.txt');

[18:41] <GabrielVieira> $content = open.file('file.txt',r).content;

[18:41] <GabrielVieira> :P

[18:41] <eric256> open("file://filename"); open("http://www.google.com"); open("ftp://");

[18:41] <theorbtwo> I'd rather prefer the uri:...'http://', but if you can say it either way, I'm happy.

[18:42] <theorbtwo> eric256: What's perl5's open("./foo") ?

[18:42] <pasteling> "ruoso" at 201.9.35.107 pasted "summary" (8 lines, 302B) at http://sial.org/pbot/16356

[18:42] <TimToady> to2: exactly the same

[18:42] <theorbtwo> OK.

[18:42] <TimToady> I think open just opens files by default.  and io() takes a uri-ish thing.

[18:43] <theorbtwo> Might get confusing if people want to use old-macos style filenames.

[18:43] <TimToady> to2: please explicate

[18:43] <theorbtwo> Is http:foo http://foo/, or is it ./http/foo?

[18:43] <theorbtwo> ?

[18:43] <GabrielVieira> ruoso looks nice :)

[18:43] <TimToady> string boundaries have to be good for something...

[18:44] <theorbtwo> Er, or is that /http/foo?  I don't actually use any version of macos...

[18:44] <eric256> the advantage of the type being contained in the string is that then the same code could work wether its reading from a file or a website, or an ftp.  the config file could just contain the entire URI ?

[18:45] <GabrielVieira> $filehandle = open.file('file.txt');

[18:45] <GabrielVieira> print $filehandle.content;

[18:45] <GabrielVieira> ?

[18:45] <theorbtwo> You can do that in any case if one of the types is URI.

[18:45] <TimToady> Right, and that's presumably the io() interface stolen (in part) from IO::All.

[18:45] <eric256> theorbtwo hmmm true...

[18:45] <GabrielVieira> how we get the file content?

[18:45] <eric256> GabrielVieira slurp it or my $content = [~] $fh;

[18:46] <TimToady> how do you want it?

[18:46] *** levengli joined
[18:46] <GabrielVieira> eric256 i mean with the open function

[18:46] <Limbic_Region> shaken not stirred

[18:46] <eric256> GabrielVieira open returns a file handle. you get the contents from the filehandle

[18:46] <TimToady> what's open got to do with it?

[18:46] <eric256> my $content = [~] open("file");

[18:46] <TimToady> io() returns something that can be used as a filehandle.

[18:47] <GabrielVieira> $filehandle = open.file('file.txt');

[18:47] <GabrielVieira> print $filehandle.content[5]; # prints to STDOUT the line 5

[18:47] <TimToady> you can't reduce a scalar, eric256

[18:47] <eric256> my $content = [~] @{open("file")}; #? ??

[18:47] <eric256> of course that doesn't realy matter cause you woul djust do my $content = slurp "file";

[18:47] <TimToady> but an io() object can be smart about list context.

[18:47] <theorbtwo> open("file").slurp sounds good to me.

[18:48] <TimToady> that should work, if you want it all as a single string.

[18:48] <TimToady> slurp is not context sensitive though.

[18:49] <eric256> so you can't do @lines = slurp "file"; ?? thats kind of sad

[18:49] <theorbtwo> Yeah, wasn't that what we were going for?  If not, my @lines = =open("file")

[18:49] <TimToady> sure you can, just not with slurp.

[18:49] <eric256> just get rid of open all together  have read(uri); write(uri); and append(uri) and move on ;)

[18:49] <TimToady> how 'bout @lines = lines "file".

[18:50] <eric256> why have lines when we have slurp?

[18:50] <GabrielVieira> $filehandle = open.file('file.txt');

[18:50] <GabrielVieira> print $filehandle[5]; # prints to STDOUT the line 5

[18:50] <GabrielVieira> print slurp($filehandle); #prints all the content

[18:50] <theorbtwo> Even better; I don't much like prefix =.

[18:50] <TimToady> or =io('file')

[18:51] <TimToady> probably io('file') ==> my @lines does what you want.

[18:52] <TimToady> but the whole point of introducing slurp() is to turn off line processing.

[18:52] <eric256> which of course means my @lines <== io('file');

[18:52] <TimToady> that too

[18:52] <TimToady> though note that that's almost certainly lazy.

[18:52] <eric256> fits me well.

[18:53] <eric256> well we went round and round and didn't get anywhere ;)

[18:54] <TimToady> I didn't even get to $job.  Oops...

[18:54] <TimToady> I'd better toodle...

[18:54] <theorbtwo> Adios.

[18:54] <TimToady> cioa&

[18:55] <TimToady> s/oa/ao/

[19:03] *** particle_ joined
[19:07] *** FurnaceBoy joined
[19:15] *** _meppl joined
[19:23] * chip wanders past, scheming to destroy 'Scalar of'

[19:26] * wolverian ties chip down and demands an explanation

[19:28] <GabrielVieira> what was decided about open?

[19:28] <GabrielVieira> :)

[19:30] <integral> why don't we fix parrot instead of breaking perl6?

[19:31] <particle_> the door to #parrot is always open... come on in :)

[19:31] <integral> too much C.

[19:31] <Arathorn> why did you kill the little 'Scalar of'? it was your friend :'(

[19:36] <particle_> parrot could definitely use more tests, which don't require C at all

[19:37] <integral> instead they require stupid PIR

[19:38] <particle_> they require PIR, or PASM, or perl6 rules, or perl5 regexes

[19:38] <LeTo> see also: languages/pugs/t/pmc/*.t

[19:38] <LeTo> in the parrot repo

[19:40] <integral> particle_: perl5 regexes?   doesn't perl5 come with a big test suite for those?

[19:42] <particle_> integral: yep, it does. and most of it (~800 tests) has been stolen to test parrot. but regression tests are rarely enough.

[19:43] <integral> ah, I thought those one were more than regression

[19:43] <integral> probably the best thing would be a regexp generate and test it in a QuickCheck style

[19:43] <integral> *generator

[19:44] <particle_> that would be most welcome

[19:44] *** hlen joined
[19:58] <eric256> GabrielVieira there was no decision, it was more just a discussion of options than trying to come to a decision

[19:58] <GabrielVieira> humm

[19:58] <GabrielVieira> :P

[19:59] <GabrielVieira> it needs to be implemented hurry

[19:59] <GabrielVieira> hurry is right?

[19:59] <GabrielVieira> :P

[20:00] <GabrielVieira> there is lots os options

[20:01] * GabrielVieira there are

[20:04] <TimToady> open($filename, :foo, :bar) is the basic interface for opening a filename stored in a string.

[20:04] <TimToady> when you want to attach it to "stdio"ish routines.

[20:05] <TimToady> sysopen() or some such is the low-level OS-ish routine that bypasses stdio/Perl::IO/whatever.  It maybe need to be imported from some OSish module to be there...

[20:06] <TimToady> piped opens are not done with open, but with some variant of run(), most likely.

[20:06] <TimToady> where run() is the replacement for system/exec things.

[20:07] <chip> back

[20:07] <TimToady> all dwimmery should be isolated to an explicitly dwimmy interface, so that we don't accidently enable injection attacks like 2-arg open did in Perl 5.

[20:07] <chip> integral: Parrot doesn't need fixing.  Perl 6 needs fixing becuase it's started to suffer from the Python Disease

[20:07] <chip> "There's only so much orthogonality a language can take until it becomes Python."

[20:08] <chip> "Array of Integer": good   "Scalar of Integer": Python disease

[20:08] <TimToady> parrot has designated that the only true value types are int, num, and str.

[20:08] * Limbic_Region lines chip and larry up to see who can pee further

[20:08] <TimToady> everything else is implicitly Scalar of

[20:09] <chip> TimToady: You're assuming your conclusoin ... which, as a designer, is of course your privilege, but let's be clear

[20:09] <chip> "True value types" is a McGuffin

[20:10] * eric256 thinks both TimToady and chip talk in riddles or lies...but can't decide which ;)

[20:10] <integral> which one of you is designing perl6 and which parrot?

[20:10] <chip> eric256: Go not to architects for wisdom for they will ask you for use cases

[20:11] <TimToady> Scalar of is not a problem when we've already said it's dead unless explicitly declared in a lexical scope, and then it's the compiler's problem.

[20:12] <TimToady> I see "Scalar of" as basically the "does Tieable" interface.

[20:12] <chip> TimToady: I confess my objections, coming from me as they are, might have been (reasonably) misinterpreted as "it won't work on Parrot if you do that".  Like I've observed before, I think audreyt is up to targeting Turing machines; Parrot is hardly a challenge

[20:12] <TimToady> so we know in a lexical scope whether we have to pessimize.

[20:13] <TimToady> It's quite possible that all three of us are talking about different elephants...

[20:13] <chip> My point is, the "Scalar of" model means that Perl 6 is embracing the -concept- of value objects implicitly, and that seems to me a poor match for the already-established presumably-still-primary target

[20:13] <chip> (i.e. Parrot, which does not have and doesn't plan to have any such abstraction)

[20:14] <chip> Not to mention an extra level of indirection in a place where it can scarce be afforded.  Though perhaps I'm only picking on the the bit of the elephant to which I've been exposed

[20:15] <TimToady> A value is simply an object that is sufficiently read-only that it doesn't matter if we treat all instances of it as the same instance on some abstract level.

[20:15] * Limbic_Region gets the elephant reference and wonders if chip and larry are mice

[20:15] <chip> Yes, that much I get.

[20:15] <LeTo> chip: you are missing the advantage of shared values it seems

[20:17] <chip> TimToady: Allowing for the extra value of indirection is expensive in complexity and introduced possibility of bugs, and when an alternative exists that is simpler, often faster, and never slower, I don't see why you abandoned it

[20:17] <chip> s/value/level/

[20:19] <TimToady> Don't see how you can claim that when efficient modern VMs depend on COW.

[20:19] <chip> The Parrot PMC model allows for modified Scalar semantics the same way Perl 5 does: By tricking out the value to respond to another protocol.  Imagine a Perl5 in which the magic vtable worked for all objects, there was only one magic structure per object, and every semantic (including base semantics) were accessed thereby.  Simple!  Fast!

[20:19] <TimToady> oops, I'm being dragged off to lunch by my compatriots.

[20:20] <TimToady> bbiab&

[20:20] <TimToady> you can have the last word.  :)  &

[20:21] <chip> what makes you think I'll stop at one?  :-)

[20:21] <Limbic_Region> chip - what's up with geeksunite?

[20:21] * Limbic_Region can't get to the page

[20:22] <chip> me neither.  didn't expect that.  I'll investigate

[20:22] <szbalint> oh its been like that for weeks now

[20:22] <szbalint> I wanted to ask but didn't want to interrupt. :)

[20:23] <Limbic_Region> well, that's not exactly good

[20:25] <szbalint> no, it's not.

[20:26] <chip> Weeks?!

[20:26] <chip> WTF

[20:26] * Limbic_Region has to admit he only checks it about once a month so can't confirm szbalint's statement

[20:27] * Limbic_Region would check more regularly if chip blogged there (or anywhere for that matter)

[20:27] <Limbic_Region> last use.perl journal entry was June of last year

[20:28] <Limbic_Region> luqui has apparently stopped journaling the p6 weekly meeting minutes too (unless of course they are on hiatus)

[20:29] <Limbic_Region> Allison hasn't journaled much lately either

[20:29] <Limbic_Region> Jonathan Worthington dominates planet parrot with very few other contributors

[20:30] * Limbic_Region has been having a hard time getting his fix for what's the skinny on the Cabal

[20:30] * Limbic_Region feels like one of the Watchers

[20:31] <szbalint> I admit that I only realised your situation chip around 2 weeks ago when I read the link on the perl summary thing.

[20:31] <szbalint> So I wanted to check out your site but it was unavailable

[20:31] <szbalint> so I used google and wikipedia and found the slashdot discussion about it, but the site was timing out.

[20:34] <pmichaud> Limbic_Region: the weekly meetings are still taking place, although I missed a bunch of them because of paying-job-deadlines (and scope creep on that job)

[20:34] <chip> szbalint: I think I figured out why the site isn't working.  I'll pass the word to those who run it

[20:35] <chip> thanks for the heads-up

[20:35] <szbalint> I wonder if it was constantly down since I checked or up and down periodically :\

[20:38] <particle_> there are logs of the parrot weekly meetings at parrotcode.org: http://www.parrotcode.org/misc/parrotsketch.html

[20:40] <Limbic_Region> thanks particle_

[20:40] <Limbic_Region> thanks pmichaud too

[20:42] <particle_> btw anyone is welcome to come watch the proceedings on #parrotsketch (irc.perl.org), too

[20:43] <FurnaceBoy> oh?

[20:43] <FurnaceBoy> what's on offer? live badger juggling

[20:43] * Limbic_Region is more interested in just keeping up with what everyone is working on particle_

[20:43] <FurnaceBoy> ?

[20:43] <Limbic_Region> I live vicariously through others

[20:44] <particle_> limbic_region: well, you can watch in realtime, or read the log, it's the same to me. just glad folks are interested in what's going on

[20:45] <Limbic_Region> particle_ - I am extremely interested in everything perl[56]/parrot/ponie/pugs related and read everything I can on how people are involved

[20:45] <Limbic_Region> I just haven't been too involved myself for some time

[20:50] *** hcarty joined
[20:53] *** kanru joined
[20:55] *** iblechbot joined
[20:59] *** hcarty left
[21:08] *** Muable joined
[21:09] *** Muable left
[21:09] *** Muable joined
[21:14] *** _meppl joined
[21:29] *** _meppl joined
[21:30] *** dolmen joined
[21:34] *** Quell joined
[21:39] *** broquain1 joined
[21:40] *** leo_ joined
[21:41] <leo_> is anyone doing weird things on feather?

[21:41] <eric256> it needs  akick in the pants ;)

[21:41] <leo_> it?

[21:41] <eric256> feather

[21:48] *** _meppl is now known as _meppl_

[21:49] *** broquaint joined
[21:50] *** _meppl_ is now known as meppl

[21:50] *** anatoly joined
[21:50] *** PerlJam joined
[21:51] *** webmind joined
[21:51] *** wolverian joined
[21:51] *** chip___ joined
[21:51] <wolverian> heh, audrey's pugs is bogging down feather :/

[21:52] <leo_> what did she do?

[21:53] <wolverian> I don't know, I just saw pugs hogging all the cpu in top..

[21:54] <leo_> which script?

[21:54] <wolverian> 'pugs'

[21:54] <wolverian> so, not very useful

[21:54] <leo_> ps axww|grep pugs

[21:54] <wolverian> can't connect anymore

[21:54] *** LeTo joined
[21:55] <wolverian> wait, now it's back

[21:56] <wolverian> hrm.. all I saw was svnbot from audrey, and one defunct process. now feather isn't replying again

[21:56] <wolverian> (s,process,pugs process,)

[21:56] <leo_> yeah, its not really clear, what's happening

[22:02] <wolverian> it's the attack of martians!!

[22:06] *** audreyt joined
[22:06] *** anatoly joined
[22:08] *** sahadev joined
[22:09] *** webmind_ joined
[22:09] *** broquain1 joined
[22:10] *** LeTo__ joined
[22:10] *** chip joined
[22:11] *** taeli joined
[22:11] * ruoso reading S05 one more time

[22:12] * ruoso hopes he'll fully understands it some time

[22:13] *** anatoly joined
[22:16] *** webmind joined
[22:17] *** PerlJam joined
[22:17] *** chip___ joined
[22:17] <ruoso> So... if the closure inside a rule returns something, it should be used as the value for the match object, else not... is it correct?

[22:18] <ayrnieu> closures always return something.  but audreyt wrote to p6* about that recently.

[22:20] *** anatoly_ joined
[22:20] <ayrnieu> and also: "An explicit return from the closure binds the result object for this match, ignores the rest of the current rule, and reports success"

[22:20] *** audreyt joined
[22:20] *** nothingmuch joined
[22:21] <ruoso> ayrnieu, so I must really check if there is a return statement inside the block?

[22:22] <ruoso> ayrnieu, during parsing, i mean..

[22:22] <ayrnieu> perhaps, if you want to handle explicit returns from the closure as S05 describes.

[22:22] * ruoso trying to make the rule for "real Perl 6 code inside rule closure"

[22:22] <ruoso> ayrnieu, the problem is that I actually use closure inside Grammar::Perl6.p6

[22:24] <ruoso> "fail" could be something like "die"? or like "return false"

[22:24] <ayrnieu> I recall it offered as something flexible that could be a die or a 'return undef'

[22:25] <ayrnieu> but in S04: The "fail" function responds to the caller's "use fatal" state.  It either returns an unthrown exception, or throws the exception.

[22:26] <ruoso> ouch... I think I won't support fail for now... :)

[22:26] <ayrnieu> meaning that it acts like 'return $exception', not that it returns that itself.  Hopefully :-)

[22:26] *** huhlig joined
[22:27] <ruoso> "When called as a closure, a Match object evaluates to its underlying result object"

[22:27] <ruoso> so... the default return of the closure is the match itself

[22:27] <ruoso> "Usually this is just the entire match string"

[22:27] <ayrnieu> honestly, the 'explicit return' thing in rules strikes me as odd.

[22:28] <ruoso> so... the closure is called with match defined. The default return is the match itself... if the return of the closure is something different from the match, then blablabla

[22:29] <ruoso> makes sense?

[22:29] <ayrnieu> ruoso - no.  It has to be an 'explicit return'.

[22:29] <ayrnieu> 'return' is magical in rules, unlike everywhere else.

[22:29] <huhlig> could someone look at three lines of code and tell me where I flubbed up

[22:29] *** leo_____ joined
[22:30] <ayrnieu> ruoso - look at an example from S05, for instance: / (\d+) { $0 < 256 or fail } /

[22:30] <eric256> sounds like it should be set_match_object($obj) instead

[22:30] <ayrnieu> that closure has a return value that isn't a match object.

[22:30] *** leo_____ is now known as LeTo

[22:30] <ruoso> ayrnieu, this still fits to what I proposed

[22:31] <huhlig> http://pastebin.com/606358

[22:31] *** broquain1 joined
[22:31] <ruoso> the closure, by default, would return the match itsel

[22:31] *** chip joined
[22:31] <ruoso> f

[22:31] <eric256> ruoso no because that would return 0 or 1 for true or false. which wouldn't be what it matched

[22:31] <ayrnieu> ruoso - you mean that you insert a 'return $?SELF' at the end of the closure unless you see that it has a 'return $foo' in it?

[22:31] <ruoso> s/unless.+$//

[22:32] <ruoso> if there is a return before, the second return will not be called

[22:32] * eric256 smells a hack.. if its a special case then shouldn't it have a special call? i.e. match $obj; instead of return $obj;

[22:32] <ayrnieu> ruoso - oh.  oh :-)

[22:32] <ayrnieu> ruoso - hah, I'm silly, that's a perfectly straightforward way to have the magical return.

[22:33] <ruoso> eric256, certainly it is...

[22:33] <ruoso> eric256, but as a closure, it makes sense to avoid creating a different syntax...

[22:33] <ruoso> eric256, since it's just regular Perl 6 code...

[22:33] *** webmind_ joined
[22:33] * huhlig sighs

[22:34] <eric256> but you ARE giving it different syntax in a hidden magical way which is -- to me

[22:34] <ayrnieu> so, 'closures in perl6 rules end in an implicit ``return $?SELF'''

[22:34] <eric256> because even though regular clousers return the last value, these wont

[22:34] <ayrnieu> or, you know, ';$?SELF'

[22:35] <ruoso> ayrnieu, but this is hidden

[22:35] <ruoso> eric256, ^^^

[22:35] <eric256> yes that surly is better than adding a new keyword for this... </sarcasim>

[22:35] <eric256> or even $?MATCH = new Object;  would be better.

[22:35] <ruoso> eric256, the magical return itself is strange...

[22:35] <integral> "sarcasm"

[22:35] *** Limbic_Region joined
[22:36] <eric256> thats what i am saying. magical return = bad

[22:36] <eric256> integral i like to pronounce the "sim" ;)

[22:36] <ayrnieu> it's not magical anymore, it's just 'return' in the context of "closures in perl6 rules end in an implicit 'return $?SELF'" -- pretend that this is in S05 :-)

[22:37] <eric256> it is magical because the closure is now ignore implicit returns which are used everywhere else

[22:37] <ruoso> reading S05... it really seems confusing...

[22:38] <ayrnieu> eric - the context of the closure is magical, in that it inserts 'return $?SELF'

[22:38] <nirgle> are there actual developers active in this channel or is this more of a "read-only" group of perl6 followers/fans

[22:38] <eric256> why not just $?MATCH holds the current match object. replace it with your own if you want.

[22:38] <ruoso> TimToady, what do you think?

[22:38] <eric256> done, no implicit,/explicit magic

[22:38] <ayrnieu> but that there is magicalness in /rules/ is less surprising.

[22:38] <integral> nirgle: we're all fans!   But yes, some of us develop of Pugs, and others are rather well known in designing perl6

[22:39] <eric256> ayrnieu but why even have the magical crap when tehre are two easy/clean/non-magical solutions

[22:39] <ruoso> is there any example in S05 of a closure that does not magic-return?

[22:39] <ayrnieu> eric - well, return values are simply ignored otherwise, and this makes them neatly useful.

[22:39] *** PerlJam joined
[22:40] <ayrnieu> eric - so it's sort of DWIMy, but it doesn't offend me anymore.

[22:40] *** anatoly joined
[22:40] <ruoso> "Embedded code does not usually affect the match--it is only used for side-effects"

[22:40] <eric256> how is ignoring implicit returns usefull?  randomly removing a feature people are used to is just plan bad form unless it is needed

[22:41] <eric256> in this case you arn't saving anything at all by doing this, and instead are adding another layer of magic.

[22:41] <ayrnieu> eric - well, see the random example from S05 again.

[22:41] <ayrnieu> / (\d+) { $0 < 256 or fail } /

[22:41] * ruoso tends to agree with eric256

[22:41] <huhlig> ayrnieu mind looking at something quick?

[22:41] <ruoso> eric256, but... what the hell would happen to the return of the closure...

[22:42] <eric256> ayrnieu i didn't say you shouldn't ignore the return. i  am saying that only ignoring implicit and not explicit is bad

[22:42] <ruoso> got it...

[22:42] <eric256> ruoso nothing. ignore it ALWAYS.  and only care about the $?MATCH vairable.  (or whatever it would be called)

[22:42] <ayrnieu> that closure does something useful, but it has a perfectly useless return value.  Either refusing to add the magic 'return $?SELF' or refusing to ignore return values leaves you with explicit 'return $?SELF' in every closure in perl6 rules.

[22:42] <ruoso> eric256, makes sense... really

[22:43] * eric256 (d+) { $0 << 256 or return 0 } /   or / (d+) { $0 << 256 or $?MATCH = 0 } /

[22:43] *** Ara5n joined
[22:43] <nirgle> integral: thanks for the intro

[22:43] <nirgle> i'll hang out for a while

[22:43] <eric256>   / (\d+) { $0 < 256 or return 0 } /   or / (\d+) { $0 < 256 or $?MATCH = 0 } /

[22:43] <ruoso> ayrnieu, no... if you ignore it at all, no implicit return $?SELF is needed

[22:43] <eric256> its about the same  but the first one handles { $0 < 256 or 0 } badly

[22:44] <ayrnieu> eric - the first what?  When is 'or 0' handled badly when you want any return to be the new $?MATCH ?

[22:44] <ruoso> eric256, and what about fail?

[22:44] <ayrnieu> although '$foo or 0' can be reduced to '0' without looking too closely at $foo

[22:44] <eric256> ayrnieu you are ignoring the implicit return of 0

[22:45] <eric256> "return 0;" and "0;"  shouldn't have different effects

[22:45] <ruoso> eric256, yes... that's correct

[22:45] <ayrnieu> eric - OK, then they should both be useless.

[22:45] <eric256> yes

[22:46] <eric256> thats what i'm saying.  better that they are both useless and a different feature used, than overloading them just in this special case

[22:46] <ayrnieu> eric - the alternative is explicit $?MATCH at the end of every rule when you only want to do something simple like optionally fail.

[22:46] <eric256> why?

[22:46] <eric256> fail would still work the same...what am i missing?

[22:46] <ayrnieu> eric - the alternative to making them useless is explicit $?MATCH.\

[22:47] <ayrnieu> eric - no, '{ test or fail }' does not ever work well in the 'any return is the new $?MATCH' universe.

[22:47] <ruoso> eric256, ayrnieu, see the example code just before "Subpattern captures" in S05

[22:47] <eric256> err ayrnieu i'm not saying we use the return at all. thats my whole point

[22:47] <ayrnieu> the q(implicit 'return $?SELF' at the end of closures in rules) universe, however, differs from the ignore-all-return-values universe *only* in that an explicit return does something useful.

[22:48] <ayrnieu> eric - yes, I restated myself as you seemed confused.

[22:48] <ayrnieu> (by my reference to fail.)

[22:48] <ruoso> eric256, ayrnieu, the two blocks

[22:48] <ruoso> one redefines the match

[22:48] <eric256> but what is gained by the default implicit return that isn't also gained by using $?MATCH = $obj instead of return $obj ?

[22:48] <ruoso> other returns

[22:48] <ayrnieu> so 'return $foo' is either perfectly meaningless or useful.  Why not make it useful?

[22:48] <ruoso> eric256, return $obj sets the capture

[22:49] <ruoso> eric256, doesn't change the match itself

[22:49] <ruoso> eric256, at least this is what seems to be in S05

[22:49] <eric256> ayrnieu because doing so makes implicit and explicit returns different which i think is bad

[22:49] <huhlig> hmm

[22:49] <ayrnieu> eric - what is gained is inoffensive DWIMy.

[22:49] <ruoso> eric256, and still there is the "stop matching" thing

[22:49] <eric256> it is offensive to anyone who reads the line "closures implicitly return there last value"

[22:50] <eric256> it is the "except inside clousures inside rules" that i think is bad

[22:50] <ayrnieu> eric - er, OK, but I disagree -- and I am also anyone.

[22:50] <ruoso> eric256, ayrnieu, the spec is confuse...

[22:50] <ayrnieu> rules are highly magical places.

[22:50] <eric256> ayrnieu yes so don't make them highly confusing too just to make return DWIM for some people

[22:50] * Ara5n loves the proliferatino of terms like 'therein' and 'forsworn' in the pX doc

[22:51] <eric256> breaking expected closure returns jsut to be pretty when there are perfectly usable alternatives is annoying at best

[22:51] <ruoso> eric256, ayrnieu, we need an explicit keyword to that

[22:51] <ayrnieu> ruoso - it's not confusing to me, just lacking here in explicit defence or implementation suggestions.

[22:51] <ayrnieu> eric - um, they aren't highly confusing.

[22:52] <ayrnieu> and the expected closure returns aren't broken.

[22:52] <ruoso> "return '0';" and "'0';" should behave the same way everywhere...

[22:52] <eric256> i didn't say they are confusing. i say its annoying to change return behaviours on a clousure just because it will make it pretty.

[22:52] <eric256> ruoso++

[22:52] <eric256> ;) thats the entire point ayrnieu  they should always act the same

[22:52] <ayrnieu> There are *two* sane alternatives.  "Always ignore return values" and "Do as the standard says, which happens also to make explicit return useful"

[22:52] *** anatoly joined
[22:53] <eric256> ayrnieu use a variable to hold the match, let the closure modifiy it if it wants.  whats bad about that?

[22:53] <ayrnieu> ruoso - those only behave the same when they happen to be the last expression of a block.

[22:53] <ruoso> so... we need to have both 'failed' and 'success'

[22:53] <ayrnieu> ruoso - of a subroutine, rather.

[22:53] <eric256> closure return values in rulse go unused.

[22:53] <ruoso> closures are subroutines... aren't it?

[22:54] <eric256> failed shouldn't care about what we do with returns, and success is automatic unless it failed..

[22:54] <ayrnieu> ruoso - uh, yes, I'm just saying that "return $foo" and "$foo" are only the same when in they occur as the last expression of a subroutine.

[22:54] <nothingmuch> obra: ping

[22:54] <eric256> i think there must be some other part ayrnieu of this return thing that isn't getting communicated

[22:55] <ruoso> Summary: 1) closure return values in rules are always ignored. 2) fail stop the match with failure. 3) ok(or something) stop the match with success.

[22:55] <ayrnieu> anyway, S05 does something useful with explicit return values.  I can't defend it anymore except by repeating myself.

[22:55] <obra> nothingmuch: I always read scrollback. just ask me things in /msg

[22:55] <ayrnieu> with explicit return, rather.

[22:56] <ruoso> ayrnieu, that's what I'm trying to address in the summary I just made...

[22:56] *** broquaint joined
[22:56] <ayrnieu> ruoso - OK.  Your summary conflicts with S05 on the issue of an explicit 'return'.

[22:57] <ruoso> ayrnieu, I know that

[22:57] <eric256> ayrnieu S05 isn't gospel. its just the current spec

[22:57] *** audreyt joined
[22:57] <ayrnieu> ruoso - OK.  Where are you getting #3?

[22:57] <ruoso> #3 is new :)

[22:57] <eric256> hell you could even just change it from return to matched and be done.

[22:57] <ruoso> if something can fail, it can succeed...

[22:57] <ruoso> :)

[22:57] <ayrnieu> ruoso - I see.

[22:58] <ruoso> so, the counter-part for fail is ok

[22:58] <ruoso> as you need explicit fail

[22:58] <ruoso> it makes sense to require an explicit ok

[22:58] <eric256> make matched $obj; and macro for $?SELF = $obj; or whatever

[22:58] <ruoso> (that's what the explicit return wants to do)

[22:59] <ruoso> matched $obj; is nice for explicit "ok"

[22:59] <ayrnieu> OK, hear ye: ruoso's implementation ignores return values and offers a magical ok() to replace S05's magical 'return'.

[22:59] * eric256 sees that they are executed as methods of Match which explains wanting to st $?SELF instead of $?MATCH....whats in a name. lol

[22:59] *** anatoly_ joined
[23:00] <ruoso> ayrnieu, the magic "matched" is ok too

[23:00] *** macli joined
[23:00] <ruoso> probably better than just ok

[23:00] <eric256> yea you don't want to confuse it with actual Test::More tests. ;)

[23:01] <eric256> matched $OBJ;  could desugar to $?SELF = $OBJ; $OBJ.passed = 1; return;  or something along those lines, raising the flag to say, hey we are done, don't process the rest of the regex

[23:01] <eric256> no magic, no confusion, still pretty ;)

[23:02] <ruoso> seems ok to me

[23:02] <ayrnieu> there's still magic, of course.

[23:02] <eric256> ayrnieu yes. but not added to already existing items like 'return'

[23:02] <ruoso> eric256, that's relevant...

[23:02] <ayrnieu> eric - also, when do you turn $OBJ into a "Matched" objected?

[23:02] <ayrnieu> er, object.

[23:03] <eric256> actualy i see less magic, because now you have a way to know it was explicitly returned so don't process the rest of the rule

[23:03] <ruoso> matched is a special return that tells the rule to use it and ignore the rest...

[23:03] <ruoso> matched extends return

[23:03] <eric256> ayrnieu theoricatly you are building that object ot explicitly return anyway

[23:03] <ruoso> eric256, exactly... the match object already  exists somewhere

[23:04] <ruoso> and the explicit return doesn't overwrite the match, but the capture

[23:04] <ruoso> at least is what it seems in S05

[23:04] <eric256> the macro/method/keyword could do whatever you needed, thats the nice part of it not being return

[23:04] <ayrnieu> eric - well, no.  In in the 'closures-with-implicit-$?SELF-return', there's no magic about turning strings into Matched

[23:05] <ayrnieu> eric - anyway, the implementation of 'matched $foo' is something ruoso can decide when he implements it.

[23:05] <eric256> if you do return "10" inside of that then the macro for matched "10" would do whateever your current magic for explicit return does

[23:05] <ruoso> ayrnieu, but the return also had to handle it

[23:05] <ayrnieu> eric - I only wanted to point out that your 'desugar' does not work.

[23:05] <ayrnieu> ruoso - no, it didn't.

[23:05] <ruoso> no?

[23:05] <eric256> ayrnieu it was psuedo macro stuff not meant as is ;)

[23:06] <Ara5n> does anyone know how up-to-date http://dev.perl.org/perl6/doc is?

[23:06] *** PerlPilot joined
[23:06] *** broquaint joined
[23:06] <eric256> Ara5n most documents have a last modified date you can check

[23:07] <Ara5n> ah, of course - thanks

[23:07] <ayrnieu> ruoso - no.  in S05, with my interpretation of implicit returns of $?SELF, closures in rules are run as methods on the "Match" object and either end up returning $?SELF or something else.  Those 'something else' don't need to be coerced into 'matched objects'.  eric's suggested desugar is more magical than this, but you can see how magical your own implementation needs to be.

[23:07] <ruoso> ok... matched($obj); is an extension to return that does: $explicit_return = 1;return($obj);

[23:07] <ayrnieu> ara5n - you might compare those with the latest Perl6::Bible on CPAN.

[23:08] <ruoso> ayrnieu, this way we keep it working the same way... just uses "matched" to be explicit

[23:09] <ruoso> ayrnieu, what do you think? matched == explicit return

[23:09] <ruoso> working exactly as "explicit return" is documented

[23:09] <eric256> ayrnieu as said my suggested desugar isn't right. that doesn't mean that matched can't be desugared to work as an explicit return

[23:09] <ayrnieu> *nod*, so, hear ye: ruoso's implementation will have an implicit 'return $?SELF' with 'matched $foo' as with S05's current 'return $foo' -- and will presumably do something to suppress actual 'return $foo' in closures.

[23:10] <ayrnieu> s/as with/replacing/

[23:10] <eric256> ayrnieu you are confusing sometimes. the implementation deems what happends to the returns. if it ignores them it need not suppress them

[23:11] <ruoso> eric256, he's talking about the implementation side... not user side

[23:11] <ayrnieu> eric256 - what it does will be functionally equivalent to what I describe.

[23:11] <ruoso> ayrnieu, yes... something will need to be done with eventual returns in the closure....

[23:11] <eric256> and wether with matched or explicit return something still needs done with the value returned/matched wether that is putting it in the capture or the match object or whatever

[23:11] <ruoso> in the implementation side

[23:11] <ayrnieu> although, all this fuss and the only difference is a name change :-)

[23:12] <ruoso> but I still can leave it as a bug for now :)

[23:12] <ruoso> the documented is "matched"

[23:12] <eric256> thats why i didn't understand the fight.  the point is not to confuse the meaning of returned when its not what you want, if it doesn't work as is and there is a viable alternative, why fight to leave it with a name somepeople would find confusing?

[23:12] <ruoso> ayrnieu, no... sorry...

[23:12] <ruoso> ayrnieu, I'm wrong

[23:12] <eric256> there is already plenty of stuff to screw up poor newbs or converst without adding more

[23:12] <ruoso> matched can set another variable in the closure

[23:13] <ruoso> and ends removing the need for the default return $?SELF

[23:13] <ruoso> I would only check the result of the closure if the $explicit_return bit is setted

[23:13] <ayrnieu> eric - I disagree, and your rationale doesn't convince me either.  But it doesn't matter.

[23:14] <ruoso> matched($obj); would expand to $explicit_return=1;return($obj);

[23:14] <ruoso> where $explicit_return is another variable from the closure, as $/

[23:14] <ruoso> ayrnieu, see?

[23:15] <ayrnieu> ruoso - this is functionally equivalent to my earlier description :-)

[23:15] <ruoso> no... there is no need to filter other returns from the closure

[23:15] <ruoso> and no need to default return $?SELF at the end

[23:16] <eric256> then returns can still be used to short circuit without ending the match

[23:16] <ayrnieu> ruoso - OK.  Then you'll implement it exactly as S05 describes, but with a 'matched' macro than you will document and encourage.

[23:16] <ruoso> ayrnieu, hopefully, matched could be promoted to spec

[23:16] <eric256> just have to find out who is in charge around here ;)

[23:16] <eric256> thats always teh hard part...might try a post to p6l ?

[23:16] <ayrnieu> please don't take my !hopefully to heart.

[23:16] <ruoso> ayrnieu, returns that do not set the $explicit_return bit will be ignored

[23:17] <ruoso> maybe a fourth person could give some oppinion...

[23:17] <ruoso> TimToady, audreyt, stevan, someone?

[23:18] *** anatoly joined
[23:18] <ayrnieu> it would seem to make more sense to ask p6l.

[23:18] <ruoso> yeah..

[23:20] <ruoso> who writes?

[23:21] <eric256> ruoso you seem closest to the implementation...but i'm just guessing that from this conversation ;)

[23:22] <eric256> and ayrnieu doesn't like it so we dont want him too lol

[23:22] <ruoso> :)

[23:22] <GabrielVieira> all give my opinion.. and u just gonna do what i say!

[23:22] <GabrielVieira> >/

[23:22] * GabrielVieira just kidding :)

[23:23] <GabrielVieira> i didnt get the point yet.. what r u talking about?

[23:23] <ruoso> S05

[23:24] <ruoso> explicit return inside rule closure

[23:25] <ayrnieu> GabrielVieira - closures in perl6 rules as defined by S05 differentiate between explicit and implicit returns.  ruoso and eric256 would rather S05 define them as ignoring any kind of return value, with a 'matched()' to replace the functionality of the current explicit return.  One of them may write to p6l about this, and a new S05 may come out.

[23:29] *** chip joined
[23:29] *** PerlJam joined
[23:30] <Ara5n> ruoso: does lrep share any code with Pugs::Compiler::Rule and it's siblings?

[23:30] <Ara5n> (or anyone else, for that matter)

[23:30] *** anatoly_ joined
[23:31] * Ara5n is confused as to why grep -r Pugs $pugs/misc/pX/Common/lrep-compiler doesn't show anything up

[23:36] *** audreyt joined
[23:37] *** webmind joined
[23:37] *** broquaint joined
[23:37] <ruoso> Ara5n, not yet

[23:37] <ruoso> Ara5n, fglock is working on it

[23:40] <Ara5n> cool

[23:40] <Ara5n> if I wanted to have a play with the latest p6-rules-in-p5 stuff, then, I should presumably use Pugs::Compiler::Rule rather than trying to run p6 code under lrep?

[23:42] <TimToady> You guys all seem to be under the misapprehension that return returns a value from the innermost closure.  It doesn't, not even in ordinary subs or methods.  It throws a control exception to the official sub or method (or now, rule).

[23:42] <eric256> Ara5n yes i beleive thats the way it works

[23:42] <eric256> TimToady then yes we where confused

[23:42] <ruoso> TimToady, what?

[23:43] <eric256> so return is *already* magical in closures then obviously that whole discussion was in vein. lol

[23:43] <TimToady> sub foo { print; { return 1 }; print } returns from the "sub", not the inner closure.

[23:43] <ayrnieu> ruoso - translated: "return throws an execption to the official sub or method, everywhere in perl6"

[23:43] <TimToady> yes.

[23:44] <eric256> so closures already behave differently for explicit versus implicit returns.....ayrnieu that was the missing peice i kept asking about. lol

[23:44] <eric256> ahhh well thats going to be confusing just in general then. lol

[23:44] <ayrnieu> TimToady - thanks.

[23:44] <TimToady> this is consistent with that.  The only magic is that the rule stores the value into the match item slot because rules have weird linkage.

[23:45] <eric256> ayrnieu if you knew that then why didn't you mention it? hehe

[23:45] <TimToady> It's exactly what newbies expect return to do if they don't know that half the control structres in their code are being emulated elsewhere.

[23:45] <ayrnieu> eric - I didn't.

[23:45] <eric256> ahh

[23:45] <eric256> TimToady newbs expect return to dump out of the clousre AND out of the calling routine?

[23:45] <TimToady> This is all right out of A06/S06.

[23:45] <TimToady> s:g/6/4/

[23:46] <theorbtwo> ...and it lets bare blocks act like them.

[23:46] <theorbtwo> eric256: newbs write closures with sub.

[23:46] <eric256> you couldn't all have been around earlier lol

[23:46] <TimToady> Every block in your sub is a closure.

[23:46] <eric256> ohhh

[23:47] <eric256> well that does change things.. return would have to or you'd have to return several times to get out of nested loops

[23:47] <TimToady> return doesn't care which of them are in void context, which of them happen to be controlled by "if", "while", "mumble", "whatever".

[23:47] * eric256 is yet agian surprised by new perl6 features. lol

[23:47] <TimToady> eric256: you got it.

[23:48] <eric256> S05 reads like it is treating explicit returns special, but its not realy

[23:48] <eric256> maybe its just a documentation cleanup then

[23:48] <TimToady> and since we're completely trying to obscure the built-in vs user-defined distinction, we have to define return in terms of throwing a control exception to something expecting it.

[23:49] <eric256> so i could have my sub catch returns thrown inside its for loop (for example?)

[23:49] <TimToady> And all the magic is on the receiving end.

[23:49] *** kakos joined
[23:49] <TimToady> yes, you could, and do something weird with it.  It's like a CATCH block, only it's a CONTROL block instead.

[23:50] <eric256> so rules can just execute the closure and use a CONTROL block to grab it only when they do "return $x"; ?

[23:50] <TimToady> the optimizer is of course free to optimize away the exception where it can determine that a stack peelback is unnecessary, but that's just an optimization.

[23:50] <TimToady> right.

[23:50] <eric256> spiffy

[23:51] <TimToady> it's only the immediate context that determines syntactically whether the closure is in void, boolean, or rule context.

[23:51] <TimToady> Since side effects turn out to be mostly what closures are used for, and since "doing nothing" is the simplest thing, bare closures are void context.

[23:52] <TimToady> <?{...}> is now boolean context

[23:52] <TimToady> so is <!{...}>

[23:52] <TimToady> only negated.,

[23:52] <TimToady> <{...}> installs the return of the closure as subrule and executes it.

[23:52] <theorbtwo> Ah, right, side effects are mostly what closures /in regexes/ are used for.

[23:53] <TimToady> right--look at yacc grammars.  Most of the statements either are side effects or set $$ (equivalent to our current return semantics)

[23:54] <TimToady> but I think "return" actually reads better for that than setting some magic variable.  AT least, I think poeple can get used to it.

[23:55] <TimToady> you can still do magical variables if you like, of course.  Match objects are full of 'em.

[23:56] <TimToady> does this all make more sense to y'all now?

[23:57] <TimToady> (not sure how it helps to implement "return" in Perl 5 internals, of course...)

[23:57] <TimToady> You might actually have to use a magical variable and die "_RETURN" or some such.

[23:58] <theorbtwo> Well, you can always implement it exactly as specced: Make it die \$returned, 'reallyareturnvalue', and put an eval{} around every sub/method/rule.

[23:58] <TimToady> but ordinary subs are gonna have to do the same thing.

[23:59] <TimToady> probably really wants a specially blessed exception object.

[23:59] <theorbtwo> Isn't that what I just said?

[23:59] <TimToady> I didn't realize die did autobless these days.

