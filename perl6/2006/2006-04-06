[00:03] <TimToady> avar: the bootstrapping book by Jules Verne is "The Mysterious Island".  It doesn't "cheat" nearly as much as, say, Swiss Family Robinson, but I suspect it does have some improbabilities for your typical tropical volcanic island...

[00:03] <TimToady> But then, they're being helped, and saying more than that would be a spoiler...

[00:08] *** justatheory joined
[00:33] *** justathe1ry joined
[00:34] *** mugwump joined
[00:52] *** stclare joined
[00:56] <audreyt> clkao: if @a[2] is rw, then yes.

[00:56] <audreyt> clkao: consider:

[00:56] <audreyt> my @a := (1, 2, 3);

[00:56] <audreyt> @a[2] = 4; # boom

[00:56] <audreyt> but,

[00:56] <audreyt> my $x; my @a := (1, 2, $x);

[00:56] <audreyt> @a[2] = 4; # that's just fine, $x=4

[00:57] <audreyt> i.e. @a[2]'s mutability is independent of @a's.

[00:57] <audreyt> clkao: makes sense?

[00:57] <audreyt> TimToady: I like the name Capture

[00:59] *** sean` joined
[01:00] <azuroth> what about um, maybe... my @a := (\1,\2); @a[1] = 3?

[01:02] <audreyt> that is same as

[01:02] <audreyt> \2 = 3

[01:02] <audreyt> and since Arguments can't be used as lvalue, that is certainly fail

[01:02] <audreyt> even if we spec so that it can serve as lvalue by propagating to the invocant in it

[01:02] <audreyt> "2" still can't be used as lvalue

[01:02] <audreyt> so would neccessarily fail

[01:02] <azuroth> cool

[01:03] <audreyt> but arguments as lvalue is bad idea anyway

[01:03] <audreyt> \$x = 5; # boom

[01:03] <audreyt> $(\$x) = 5; # sure why not

[01:03] <audreyt> I think that's clearer and easier to explain (and is what the current spec says)

[01:03] <azuroth> hmm, yeah

[01:08] <avar> p5 ${\$x} = 5; doesn't work anymore?

[01:09] <audreyt> avar: we changed ${} to $() for consistency

[01:09] <audreyt> or just prefix $

[01:09] *** ptolomy joined
[01:09] <avar> $\$x = 5; ? (not valid p5)

[01:10] <audreyt> that is certainly legal

[01:10] <audreyt> if a bit obscure to p5 eyes

[01:10] <audreyt> easier to write as

[01:10] <audreyt> $ \$x = 5;

[01:10] <audreyt> or use parens

[01:12] <avar> ${} to $() for consistency with what? Grouping in general? While {} usually means a block

[01:12] <audreyt> er no. ${} is a special form

[01:12] <audreyt> $() is just a prefix operator

[01:12] <audreyt> you can write it without parens too

[01:12] <audreyt> it's just like prefix ~

[01:12] <audreyt> or prefix +

[01:13] <audreyt> it's a caster

[01:13] <avar> ah

[01:13] <audreyt> doesn't quite make sense to make a mere prefix caster

[01:13] <audreyt> but use the hash deref syntax for it

[01:13] <audreyt> esp. since we don't have

[01:13] <audreyt> $glob{CODE}

[01:13] <audreyt> anymore

[01:13] <audreyt> so the hash analogy is long gone

[01:14] <avar> will $%foo<bar> mean the same thing as ${$foo{bar}} in p5, or ${$foo}{bar} ?

[01:14] <audreyt> avar: +%foo<bar>

[01:14] <audreyt> so surely, it means the p5  ${$foo{bar}}

[01:14] <avar> eh, that doesn't make any sense, I mean @%foo<bar>

[01:14] <audreyt> same

[01:14] <avar> cool;)

[01:14] <audreyt> it'd meanthe p5 @{$foo{bar}}

[01:15] <audreyt> unless the sigil is part of a variable name

[01:15] <audreyt> it assumes the same prec as prefix +, prefix ~ etc

[01:15] <audreyt> and variable names can't consist of 2+ sigils

[01:15] <avar> I see, that's nice

[01:15] <audreyt> so it all follows naturally

[01:16] <theorbtwo> (Following naturally)++

[01:16] <theorbtwo> Way too many @{}s in my p5 code.

[01:16] <audreyt> yeah. the Reference/ImplementationType/Container ambiguity has plagued p6l for too long

[01:16] <audreyt> glad to put an end to it

[01:17] <avar> theorbtwo: yeah, like for my $i (@{$hash{key}})) ..

[01:17] <avar> that's for @%hash<key> -> $i { ... } now right?

[01:17] <audreyt> right

[01:18] <audreyt> %hash<key>.map($i -> {...})

[01:18] <avar> So it'll never automagically dereference stuff like in p5?

[01:19] *** Southen joined
[01:19] <audreyt> well, we can spec so that "for" will perform another level of flattening

[01:19] <audreyt> such that

[01:19] <audreyt> for (1,2,3) -> $i {...}

[01:19] <audreyt> and

[01:19] <audreyt> for [1,2,3] -> $i {...}

[01:19] <audreyt> both iterates 3 times

[01:20] <audreyt> I'm fine with that too

[01:20] <audreyt> and is in fact what pugs implements

[01:20] <audreyt> but there is nothing magical about that

[01:20] <theorbtwo> I'm not so sure about that.

[01:20] <audreyt> it's simply saying statement_control<for> is equivalent to a map

[01:20] <theorbtwo> It's convient, but it will sometimes mean that you have to put in extra brackets to get it to do what you actually wrote.

[01:21] <audreyt> right, as in

[01:21] <audreyt> for [$x] {...}

[01:21] <audreyt> if you don't know whether $x contains a list or not

[01:22] <theorbtwo> for $x.foo -> {...}, where $x->foo returns a list of arrayrefs.  Does it do something different if there happen to only be one foo?

[01:22] <avar> I don't know, I've coded a lot of Perl 5 (hey, I even get paid for it;) But I've yet to find a situation where something like "print for [qw(1 2 3)]" was useful, other than sitting there being consistent with the rest of the language

[01:23] <avar> Which has its values too

[01:24] <audreyt> theorbtwo: well, if foo returns a list of one element and it's an array

[01:24] <audreyt> theorbtwo: i.e.

[01:24] <audreyt> (@a,)

[01:24] <audreyt> then it still will iterate just once

[01:24] <theorbtwo> Blink.

[01:24] <audreyt> so I'd say it's consistent

[01:25] <theorbtwo> Does that not flatten anymore?

[01:25] * theorbtwo has forgotten most of perl6, it seems.

[01:25] <audreyt> (it doesn't flatten under scalar context)

[01:25] <theorbtwo> Um, but that's list context.

[01:25] <audreyt> it may help to write out foo explicitly

[01:26] <audreyt> oh wait, you said arrayrefs

[01:26] <audreyt> that is (\@a,)

[01:26] <theorbtwo> Right.

[01:26] <audreyt> which doesn't flatten in any context.

[01:26] <audreyt> so sure, it gets iterated once.

[01:26] <theorbtwo> (\@a), or (\@a, \@b), depending on the state of $x.

[01:26] <audreyt> right. that is then just fine.

[01:27] <avar> well just like any scalar would

[01:27] <avar> evalbot_9807: print for "foo"

[01:27] * avar bows in shame

[01:27] <audreyt> ?eval print for 'foo'

[01:28] *** evalbot_9807 is now known as evalbot_9835

[01:28] <evalbot_9835> OUTPUT[] undef

[01:28] <theorbtwo> But if for removes an outer layer of arrayrefness, wouldn't it take out the layer on \@foo?

[01:28] <theorbtwo> ?eval sub foo {return ([1]);} for foo() -> $x {say $x}

[01:28] <evalbot_9835> OUTPUT[1 ] undef

[01:28] <theorbtwo> ?eval sub foo {return ([1],[2]);} for foo() -> $x {say $x}

[01:29] <avar> audreyt: you've changed that I see;)

[01:29] <evalbot_9835> OUTPUT[1 2 ] undef

[01:29] <audreyt> theorbtwo: there is a difference between (\@a,) and (\@a)

[01:29] * avar spoke of p5

[01:29] <theorbtwo> Oh.

[01:29] <audreyt> theorbtwo: (\@a,).map(...) gets run once only

[01:30] <theorbtwo> I've got a lot of rereading to do if I'm going to be able to speak intelegently on this channel again.

[01:30] * theorbtwo calls it a night, at least for a few hours.

[01:30] <audreyt> (\@a).map(...) runs as many times as the element of @a (that is, if we define "map" on the Capture object.)

[01:30] *** xern joined
[01:30] <audreyt> or maybe it just dies.

[01:42] *** hexmode joined
[01:43] <audreyt> TimToady: I think this should no longer work:

[01:43] <audreyt> $bar = @foo;

[01:43] <audreyt> *$bar = (1,2,3);

[01:44] <audreyt> to make it work we'd say a lvalue Capture biases toward the positionals always

[01:44] <audreyt> (otherwise, consider $bar=%foo; *$bar = (1=>2))

[01:44] <audreyt> and that's probably bad idea

[01:44] <audreyt> we have the @$bar=(1,2,3) form already

[01:53] <audreyt> interestingly the definition of prefix \ is just

[01:53] <audreyt> sub prefix:<\> (\$_) {$_}

[02:02] *** amnesiac joined
[02:20] <azuroth> wouldn't that be dereferencing...?

[02:20] <azuroth> or uh, deargumenting

[02:20] *** justatheory joined
[02:20] <azuroth> err, never mind!

[02:21] <avar> audreyt: Looks like an incomplete definition

[02:21] <avar> y~.~:~

[02:22] <audreyt> hm?

[02:22] <audreyt> no, \$x in arglist captures the entire arglist

[02:23] <audreyt> see \$args in S06

[02:43] *** r0nny joined
[02:55] <TimToady> audreyt: I disagree with [1,2,3] autoderef in list context.  (1,2,3) is fine though for interpolating, since parens only group, and have no effect on list commas.

[02:57] <TimToady> (I'm referring to the for [1,2,3] bit earlier.)

[03:00] <TimToady> I think if we break the scalar/list context distinction, Perl programmers will revolt.

[03:01] <TimToady> biab &

[03:05] *** diotalevi joined
[03:25] *** mako132_ joined
[03:37] *** Quell joined
[03:40] *** LCamel joined
[03:40] *** Soga joined
[03:40] *** ingy joined
[03:41] *** gugod joined
[03:41] *** lumi joined
[03:41] *** pjcj joined
[03:44] *** kakos joined
[03:49] *** arguile joined
[03:49] <PerlJam> Where exactly would someone look for simple examples using TGE?  I just started looking (thinking about how to use the tools to write a small compiler) and I'm having trouble seeing the forest for the trees I think.

[03:50] *** kanru joined
[04:03] *** scw_ joined
[04:03] *** xern_ joined
[04:17] <audreyt> TimToady: er, [1,2,3] never autoderefs

[04:17] <audreyt> I'm merely referring to the behaviour of

[04:17] <audreyt> for $array -> $i {...}

[04:18] <audreyt> i.e., whether "for" performs the flattening

[04:18] <audreyt> I'm certainly fine with requiring people writing

[04:18] <audreyt> for @$array -> $i {...}

[04:18] <audreyt> it feels more consistent anyway.

[04:23] <audreyt> for *$array -> $i {...} # works too

[04:23] <audreyt> if we consider $array containing positional args to the slurpy for

[04:23] * PerlJam was just about to ask

[04:25] <audreyt> sub statement_control:<for> (*@, *&) {...}

[04:25] <audreyt> if that's the prototype, then I think the above behaviour follows

[04:29] <arcady> that's how I would write the prototype for for (assuming such a thing can be written)

[04:31] <PerlJam> arcady: It must be able to be written or we are lost :)

[04:32] <arcady> because perl 6 desperately needs to define itself in terms of itself

[04:32] *** stclare left
[04:32] <arcady> it's like... super bootstrapping

[04:35] *** stclare joined
[04:43] *** nirgle joined
[04:50] <TimToady> audreyt: I believe (*@, *&) is a legal sig.  Might even work the other way around, given a smart enough "slurpy" definition of {...} hunting.

[04:51] <TimToady> but in this case probably controlled by an "is parsed" implicit to statement_control:<if>

[04:51] <TimToady> *for rather

[04:51] *** nirgle left
[04:52] <TimToady> arcady: not everyting has to be defined in terms of sigs, since "is parsed" is available, not to mention the entire grammar available for replacement...

[04:52] <arcady> yeah, that definitely makes it easier

[04:52] <TimToady> But it would certainly be nice to keep things as regular as possible.

[04:53] <TimToady> And needing to go outside the sig is probably a code odor of some sort, if not exactly a code smell...

[04:55] <arcady> by the way, how much of "the perl 6 grammar" exists at the moment?

[04:57] *** hlen joined
[04:57] *** Maddingue joined
[04:58] <TimToady> depends on how you count, I suppose.  rule syntax is fairly well characterized by now.  a lot of it is specced pretty well, for some definition of pretty that ain't pretty.

[04:59] <arcady> so at least we can have something like the grammar grammar

[04:59] <TimToady> Most of the operator precedence is not done with rules at all.

[04:59] <TimToady> Yes, the grammar grammar is already bootstrapped approximately twice.

[04:59] <arcady> it's kinda hard to keep track of all the stuff going on...

[05:00] <TimToady> there'e very little top-down grammar over the bottom-up expression parser.

[05:00] <TimToady> more top-down involved in scanning complex tokens containing subexpressions.

[05:00] <TimToady> but the main complication remaining is just making sure all the grammatical categories work as envisioned.

[05:01] <TimToady> Then there's just little detail of attaching semantics to the parse...  :)

[05:01] <TimToady> s/little/the little/

[05:02] <arcady> that can be left as an exercise to the implementors : )

[05:02] <TimToady> But audreyt says that Perl 6 now fits in her head, so that should be finished a day or two after the grammar is done.

[05:04] <arcady> that would be most awesome

[05:05] <TimToady> well, even a month or two would be awesome.  a year or so is more likely before we have something really, really solid.  Still, I'm very happy with how it's going.

[05:05] <arcady> well, I'm happy that you're happy, and that it's going

[05:05] <arcady> I guess it's not entirely obvious from here

[05:06] <arcady> and all the various bootstrap efforts and targets and so on are confusing

[05:07] <TimToady> Hmm, yes.  Audrey

[05:07] <TimToady> Audrey's development methodology resembles a flooding algorithm at times...

[05:08] <TimToady> Or maybe a genetic algorithm.

[05:08] <arcady> well, as long as things get done that need to get done

[05:08] <arcady> still, it'd be nice if us spectators could follow along more easily

[05:11] <arcady> what's going on with parrot, by the way?

[05:12] <arcady> and how does any of that connect to any of this?

[05:12] *** Khisanth joined
[05:12] <TimToady> well, now that updates are logged on either p6l or here, between the two of those it's pretty easy to keep up with the high-level stuff.  p6i for the parrot stuff.

[05:13] <TimToady> Parrot is sort of the other end of the world from me, so I just follow along in p6i mostly.  I hear conflicting things, but I think it'll get there eventually, for some definition of "there".

[05:14] <TimToady> Whether it will be "the" Perl platform or "a" Perl platform, or somewhere in between, remains to be seen.

[05:14] <audreyt> rehi

[05:15] <TimToady> nobody here but us chickens...

[05:16] * arcady squawks

[05:16] <audreyt> TimToady: so, @a[0]:=1 is an action on @a, and @a[0]=1 is an action on @a[0], not on @a

[05:16] <audreyt> TimToady: and whether an array is rebindable depends on how it allocs the storage of its element cells, and has nothing to do with what individual elements are bound to

[05:16] <TimToady> makes sense, I think

[05:17] <TimToady> (unless @a[0] needs to be created for the assignment)

[05:17] <audreyt> yeah, lvalue autovivify is another phase

[05:18] <TimToady> subject to the constraints that you could attempt to bind the array to a storage mechanism that doesn't work for the element cells you have in mind.

[05:18] <audreyt> but it's cool... I'll totally swap out the current code in Pugs now that I think everything is clear. will go with no automagic dereferencing at all for Capture objects (i.e. (\(1,2,3))[0] would be illegal) and everything needs a explicit cast

[05:18] <audreyt> TimToady: yup

[05:18] <TimToady> I suppose we could outlaw binding an array that has anything in it...

[05:19] <audreyt> for the default sparse array (Array of Scalar of Any), you can indeed freely rebind

[05:19] <TimToady> either that, or just throw away the old contents

[05:19] <audreyt> yup

[05:19] <audreyt> I suspect it's more useful

[05:19] <audreyt> as p5 already allows you to use it

[05:20] <audreyt> (i.e. alias $x[0] = $y; in Data::Alias)

[05:21] <TimToady> I suppose some people want a stricture of the FP variety that prevents reassignment or rebinding.

[05:21] <TimToady> basically, treat everything as immutable...

[05:22] <TimToady> likely to be slow in some cases though...

[05:22] <audreyt> but you can do that easily

[05:22] <audreyt> my @x := (1,2,3,4);

[05:22] <TimToady> yeah, just xlate to Haskell... :)

[05:22] <audreyt> now pushing and rebinding of @a[0] fails

[05:23] <audreyt> since it's bound to a Tuple instead of sparse Array

[05:23] <audreyt> assigning to @a[0] would fail because 1 is not mutable

[05:23] <audreyt> otoh, my @a := [1,2,3,4] would permit pushing and rebinding

[05:24] <audreyt> and depends on whether we want the circumfix [] to scalarify its elements

[05:24] <audreyt> may also allow assigning into @a[0]

[05:25] <audreyt> TimToady: damian mailed us something very strange

[05:25] <audreyt> claiming that S02's

[05:25] <audreyt> $x     .(...)

[05:25] <audreyt> $x     .<string>

[05:25] <audreyt> is to be written as

[05:25] <audreyt> $x.    (...)

[05:25] <audreyt> $x.    <string>

[05:25] <audreyt> I don't quite know how that came to be

[05:25] <TimToady> yes, in fact that's what S02 says now.

[05:25] <TimToady> Damian and I did that at the hackathon.

[05:26] <audreyt> but

[05:26] <audreyt>     :longkey(1)  .($value)

[05:26] <TimToady> psychologically, we'd like .mumble with whitespace in front to always

[05:26] <audreyt> is still there

[05:26] <TimToady> be $_.mumble

[05:26] <TimToady> an oversight.

[05:26] <audreyt> gotcha.

[05:27] <audreyt> which change was that?

[05:27] <audreyt> (or some commit log keyword)

[05:29] <TimToady> 8563 is when it came in--neglected to mention in log

[05:29] <TimToady> I did 8561..8566 today.  Also did grammatical category cleanup.

[05:30] <audreyt> ok, I'll fix S02 to align with them.

[05:30] <audreyt> done as r8573.

[05:30] <TimToady> and clarified reducability

[05:31] <audreyt> yeah, I saw that. nice

[05:32] <audreyt> probably need to clarify what rule_mod_internal:

[05:32] <TimToady> The proscription of infix .foo is a bit draconian, but I think necessary to preserve sanity.

[05:32] <audreyt> and rule_mod_external:

[05:32] <audreyt> means

[05:33] <audreyt> and change the example from:p5 to :P5 or :Perl5

[05:33] <audreyt> or allow :p5 again in S05

[05:33] <TimToady> somewhere it says that those might actually be the same grammatical

[05:33] <TimToady> category with a parameter.

[05:33] *** drrho joined
[05:33] <audreyt> aye

[05:33] <TimToady> the internal/external are documented in S06.

[05:33] <TimToady> *5

[05:34] *** feng joined
[05:34] <audreyt> ahh

[05:34] <audreyt> so maybe use :g

[05:34] <audreyt> as example of _external ?

[05:35] <TimToady> something that makes no sense inside.  :g, or maybe :nth(3)

[05:36] <TimToady> though arguably either of those could be forced to work inside with sufficient .* <(...)> .* chicanery.

[05:37] <audreyt> yeah, in which case everything is external

[05:37] <TimToady> but probably not worth it, unless it is.

[05:37] <audreyt> I'll keep the diff

[05:38] <TimToady> one could also just have one category but blow up on things that make no sense.

[05:38] <TimToady> but 2 categories seems cleaner for now

[05:38] <audreyt> yeah

[05:38] <audreyt> r8574.

[05:44] <audreyt> I guess we need a mirrorer so that svnbot6 can announce synopsis changes here too

[05:44] * audreyt goes setting one up on feather

[05:45] <arcady> that would be a very good idea

[05:45] <arcady> since synopses aren't exactly all that short anymore

[05:48] <spinclad> please remind me, where do i look for an svn view of [AES]*?

[05:49] <spinclad> (I remember them in pugs doc/ formerly, but i doubt now that was canonical)

[05:54] <TimToady> spinclad: https://svn.perl.org/perl6/doc/trunk/design/syn

[05:55] <audreyt> spinclad: docs/Perl6/Spec/ will soon have a (read only) mirror

[06:01] <spinclad> thanks, both.  will peruse.  sometimes i feel (but is it true?) that my second readings are better if i can see how things have been mutating.

[06:01] <spinclad> it certainly helps make sure i'm of the changes themselves...

[06:02] <spinclad> oops, s/i'm of/i'm aware of/

[06:02] <ayrnieu> You can determine if this is true by repeatedly reading the entire document over its lifetime of changes, so that you have read all of the documents at least N times in a repository of N patches.

[06:03] <ayrnieu> Then you can write a spooky poetic book about living in a labyrinth called "The tunnel of perl6"

[06:04] <spinclad> "the name of the camel"

[06:09] <svnbot6> r9842 | audreyt++ | * Begin mirroring ofr upstream svn.perl.org Synopses as

[06:09] <svnbot6> r9842 | audreyt++ |   read-only Spec documents:

[06:09] <svnbot6> r9842 | audreyt++ |    01 Overview     02 Syntax   03 Operator

[06:09] <svnbot6> r9842 | audreyt++ |    04 Block        05 Rule     06 Subroutine

[06:09] <svnbot6> r9842 | audreyt++ |    09 Structure    10 Package  11 Module

[06:09] <svnbot6> r9842 | audreyt++ |    12 Object       13 Overload

[06:09] *** GeJ joined
[06:09] *** fridim_ joined
[06:13] * audreyt praises svk for making things like this trivial

[06:14] <audreyt> clkao++

[06:15] <azuroth> humm, is there a word for "unrequired"?

[06:15] <ayrnieu> 'unrequired'.

[06:15] <FurnaceBoy_> optional ?

[06:15] <ayrnieu> yeah, or that :-)

[06:15] <azuroth> right. gaim told me unrequired wasn't a real word

[06:16] <ayrnieu> gaim doesn't know about 'real words', it only knows about dictionary words, which aren't the same thing.

[06:16] <FurnaceBoy_> I agree with gaim on this

[06:16] <TimToady> audreyt: I have asked sixperl what they think of Capture.

[06:16] <azuroth> hum. I'll leave it at "not required"

[06:16] <FurnaceBoy_> yeah

[06:17] <ayrnieu> azuroth - 'not required' and 'unrequired'/'optional' differ in grammatic use.

[06:18] <FurnaceBoy_> there are others in the ballpark too. dispensable, etc. A thesaurus would help.

[06:18] <azuroth> not when "not required" is used an adjective ;-)

[06:18] <azuroth> hmm. cool

[06:18] <ayrnieu> azuroth - "not required elements include"  -- bzzt.

[06:19] <azuroth> I just reworded it; "it contains many not required functions" to "it contains many functions that are not required;" I think it reads a lot nicer...

[06:19] <ayrnieu> If you like copulas.  Pffth :-)

[06:19] <azuroth> of course, my spurious use of semicolons there would suggest that I don't really know

[06:19] <azuroth> copula?

[06:20] <azuroth> interesting

[06:20] <ayrnieu> "If you like the verb 'to be'.  Pffth :-)"  -- I don't actually know if 'copula' is the correct term.  I take that from descriptions of J grammar.

[06:20] <TimToady> If you're going to use "not required" as an adjective you have to spell it "not-required".

[06:21] <TimToady> Well, you don't have to, but it's clearer, I think...

[06:22] <ayrnieu> aside, "it contains many functions that are not required" seems weird without context.  I'd expect something like "It also has many useful functions in excess of those described by the FOO and BAR standards."

[06:22] <audreyt> surely "nonrequired" would do?

[06:22] <ayrnieu> in addition to those.

[06:22] <azuroth> hmm.. would you suggest a different adjective? I don't really like optional, because it doesn't have quite the... negative feeling I think we're looking for

[06:22] <audreyt> nonmandatory, even

[06:22] <TimToady> extraneous

[06:23] <ayrnieu> I think the solution is to not look for a single word.

[06:23] <azuroth> extraneous, I like it!

[06:23] <ayrnieu> extraneous is good for negative feelings.

[06:23] <TimToady> I'm really good at thinking up negative words. :)

[06:23] <audreyt> TimToady++ # positive words too

[06:25] <azuroth> it's weird. we're doing this feasibility report for college, for this point of sales system. but what would happen if it was found it wasn't feasible? I imagine we'd do it anyway

[06:25] <spinclad> infeasible

[06:25] <ayrnieu> If the results of your report don't matter, don't be party to them.

[06:26] <TimToady> Maybe it's just infeasible without more fees.

[06:26] <ayrnieu> although if it fails as you predicted you can at least say you told them so :-)

[06:27] <azuroth> hmm, yeah

[06:27] <spinclad> of course, 'feasible' doesn't quite mean 'required'...

[06:27] <ayrnieu> and if it doesn't fail: you're wrong.

[06:27] <TimToady> well, it's infeasible for me to stay up much longer, so g'nite all.

[06:27] <audreyt> sleep well

[06:27] <azuroth> night!

[06:27] <audreyt> don't let the bed pugs bite!

[06:27] <spinclad> sweet dreams

[06:27] <TimToady> ow!

[06:28] <TimToady> &

[06:28] * spinclad dreams of bed pugs all night

[06:28] <ayrnieu> (it's unrequired for me to stay up much longer, but I have an extraneous hour and my other tasking is optional)

[06:28] <azuroth> spinclad: we're saying that MYOB's POS has extraneous features that would just distract from the efficiency of the user...

[06:28] <TimToady> .oO(ped bugs pite...)

[06:29] <audreyt> there is no such word as "pite"...

[06:29] <TimToady> .oO(is now. zzzz) &

[06:29] <audreyt> g'pite

[06:30] <azuroth> s/word/verb/. I'm sure I've seen pide spelled with a t

[06:32] <spinclad> let's call said features omissible, maybe

[06:33] <spinclad> enim censeo, featura ista delenda esse

[06:37] <spinclad> "i really think those 'features' have got to go"

[06:38] <azuroth> "I certainly recommend, feat..." you didn't give me enough time ;-)

[06:46] *** iblechbot joined
[06:48] <spinclad> "truly i deem those features to deserve expunction"

[06:50] <spinclad> and other echoes of the elder Cato

[06:51] * spinclad goes off to dream of bedpugs &

[06:51] *** marmic joined
[07:00] *** KingDiamond joined
[07:05] *** hugues23 joined
[07:06] <gaal> "Seize" is shorter than "Capture"... :)

[07:08] <arcady> but not a noun

[07:08] <arcady> how about Seizure!

[07:08] <gaal> Seize is also a noun

[07:08] <arcady> since that's what it will give those who attempt to understand it

[07:09] *** premshree_ joined
[07:09] <gaal> like, oh, Siege

[07:10] <gaal> wait now I've got my English crosswired.

[07:11] <gaal> what's the name for a verb functioning in noun role (in English)

[07:11] <gaal> "The arrest of the mad linguist"

[07:13] <gaal> "The love od the mad linguist"

[07:14] <azuroth> hmm. interesting questions

[07:14] <azuroth> -s

[07:14] <gaal> "The seize of the mad linguist's subversive proposals"

[07:14] <gaal> in the case of love clearly that's a standard noun there

[07:15] <gaal> not sure about the other two

[07:15] <azuroth> http://en.wikipedia.org/wiki/Verbal_noun maybe..

[07:15] <audreyt> I think Capture works

[07:15] <gaal> audreyt: sure, also easier to spell

[07:16] <gaal> azuroth: yes, that's it

[07:17] <azuroth> it's a boring name for it. I was hoping for something like sublightdriveitive

[07:18] <gaal> azuroth: well, it invokes the gerund, so there's some fun there.

[07:21] *** bsb joined
[07:22] <arcady> I still think Seizure is more fun

[07:25] <gaal> Snare :-)

[07:26] *** Barry joined
[07:28] <gaal> uh, or plain Catch

[07:28] <gaal> but these verby nouns are all confusing.

[07:29] <bsb> Are we playing rename the Arguments?

[07:30] <lumi> It's not an argument, you're just contradicting me

[07:32] <gaal> catch, like capture, has an accepted nounly usage at least

[07:32] <gaal> lumi: are you proposing Contradiction for a name?

[07:32] <gaal> this isn't Haskell yet you know

[07:33] <rgs> contradiction is not diction

[07:33] <gaal> or a Joni Mitchell song. .oO( and he took his contradictions out / and he splashed them on my brow )

[07:33] *** Barry left
[07:34] <gaal> s,.oO(),~/~,

[07:34] <audreyt> I think Capture is long enough :)

[07:35] <audreyt> huffman says that it shouldn't be very short

[07:35] <audreyt> as we are not expecting humans to write them in code

[07:35] <lumi> I thought the Arguments looked fairly record-like, but maybe I'm missing the point..

[07:35] *** bsb_ joined
[07:36] <audreyt> record?

[07:37] <lumi> Yeah, I was reading TaPL, it mentions the record as a supertype of a tuple

[07:37] <bsb_> Maybe Glist, as in "A Glist"

[07:37] <lumi> So it's ordered but it can have named values

[07:37] *** kane__ joined
[07:40] <gaal> hw = "~Y~" : [ "~Y"++x | x <- hw ]

[07:40] <audreyt> lumi: I think it's something like

[07:40] <audreyt> data Capture = MkCapture

[07:40] <audreyt>     { invocant   :: Val

[07:40] <audreyt>     , named      :: Map Str ral

[07:40] *** KingDiamond joined
[07:40] <audreyt>     , positional :: Seq Val

[07:40] <audreyt>     , block      :: Val

[07:41] <audreyt>     }

[07:41] <audreyt> s/ral/Val/

[07:41] <audreyt> of course, both invocant and block are actually "Maybe Val"

[07:41] <gaal> hw !! 2

[07:42] <gaal> # live commentary in Haskell

[07:42] <lumi> Looks kinda Ruby-ish (and that first line would get you mauled by nothingmuch :P)

[07:43] <gaal> lumi: which first line, invocant :: Val ?

[07:43] <lumi> Yeah

[07:43] <lumi> Not mmd enough!

[07:43] <gaal> ah

[07:44] *** ko1_away is now known as ko1_

[07:44] <gaal> how would you express it then? [Val] ?

[07:45] <audreyt> gaal:

[07:45] <audreyt> hw = unfoldr (\x -> Just ("~Y"++x, x)) "~Y~"

[07:45] <audreyt> hm, but comprehension is actually more readable

[07:46] <bsb_> audreyt: regarding and example for $args ~~ $sig yesterday...

[07:46] <bsb_> if $args ~~ $sig means thisi $args would bind to this $sig without error,

[07:47] <audreyt> slightly better version:

[07:47] <audreyt> hw = unfoldr (\x -> let y = "~Y"++x in Just (y,y)) "~"

[07:47] <bsb_> then a sub that takes an Arguments could do ordered pattern matching dispatch

[07:47] <bsb_> like case desugared Haskell using given/when.

[07:47] <gaal> audreyt: surely there's a scan version hiding somewhere

[07:47] *** bsb_ is now known as bsb

[07:48] <audreyt> gaal: indeed

[07:48] <audreyt> hw = scanl (++) "~" (repeat "Y~")

[07:48] <gaal> I don't understand the Just versions though, where

[07:48] <gaal> 's the rest of the monadic trickery?

[07:49] <audreyt> unfoldr :: (b -> Maybe (a, b)) -> b -> [a]

[07:49] <gaal> oh

[07:49] <gaal> hmm? why the Maybe?

[07:49] <audreyt> termination.

[07:49] <gaal> ah, that

[07:49] <audreyt> bsb: I think it makes sense

[07:50] <gaal> then, obviously the wrong function given the streaming nature of the handwave

[07:50] <gaal> I like your scanl version. The comprehension still is shorer though...

[07:52] <gaal> hadwave is the new Hello World

[07:52] <gaal> s/d/nd/

[07:53] <bsb> audreyt: that's a relief

[07:53] <gaal> evolution of a * programmer: 1. hello world 2. ... n. fac ... k. handwave

[08:23] <audreyt> (bbiab)

[08:53] *** nothing_pasta joined
[08:53] *** mj41_ joined
[09:03] <wolverian> heh, that's a lot of grammatical categories

[09:16] *** wilx`` joined
[09:19] *** elmex joined
[09:41] <gaal> trivial nit: in S02, Grammatical Categories:

[09:41] <gaal> # has $.tail handles <wag>

[09:41] <gaal> # my $x shall conform<TR123>

[09:42] <gaal> should there be whitespace after the trait?

[09:46] <audreyt> mmm

[09:46] <audreyt> you mean

[09:47] <audreyt> my $x shall conform('TR123');

[09:47] <audreyt> or something else?

[09:47] <Juerd> audreyt: There's a space between handles and <wag>, but not between conform and <TR123>

[09:47] <Juerd> has $.tail handles <wag>

[09:47] <Juerd> my  $x     shall   conform<TR123>

[09:47] <Juerd> But I agree it can be very confusing.

[09:48] <audreyt> I have no idea what "conform" does here.

[09:48] <azuroth> maybe like a subtype or something?

[09:48] <audreyt> if it's a named arg to "shall"

[09:48] <audreyt> then it should be

[09:48] <audreyt> my $x shall :conform<TR123>;

[09:48] <audreyt> the "shall" is user-defined trait auxillary

[09:48] <audreyt> like "is"

[09:49] <Juerd> Is shall synonymous to is?

[09:49] <Juerd> Or will we have to remember a load of trait categories?

[09:49] <audreyt> no... "shall" occurs to the same position as "is"

[09:49] <audreyt> it is user-defined

[09:49] <Juerd> (Which to me is as hard as 1st 2nd 3rd)

[09:49] <audreyt> you can declare your own trait auxillaries

[09:49] <audreyt> there is nothing special about "shall"

[09:50] <audreyt> it's not part of the base language

[09:50] <Juerd> I see.

[09:50] <audreyt> sub trait_auxillary:<must> {...}

[09:50] <audreyt> then you can say

[09:50] <Juerd> Oh my

[09:50] <audreyt> my $x must :be<happy>;

[09:51] <audreyt> TimToady: is it simply a case of missing colon before "conform"?

[09:52] <Juerd> Will Perl 6 have floating point %?

[09:54] <azuroth> unrelated, but I think that parrot consciously doesn't

[09:54] <audreyt> Juerd: I don't see why not

[09:55] <Juerd> I don't know if regarding % will follow sanity, or Perl 5 :)

[09:55] <Juerd> Perl 5 has only integer %, and I couldn't find anything in a synopsis specifying Perl 6 would be different

[09:55] <audreyt> well, docs/Perl6/Spec/Builtins.pod is the place to look for now...

[09:55] <audreyt> I think floating % makes sense.

[09:55] <Juerd> So do I

[09:56] <audreyt> azuroth: why is it so?

[09:56] <azuroth> err. I might be off base. float percent, or float-keyed hash?

[09:56] <Juerd> Modulus

[09:56] <azuroth> haha, oh

[09:56] <azuroth> sorry!

[09:58] <audreyt> np :)

[09:58] <audreyt> Juerd: fix Builtins.pod ?

[09:58] <audreyt> (and write a test)

[09:59] <Juerd> Well, I think it may need some discussion first

[10:00] <Juerd> Because it's a difference with Perl 5, and I can't imagine Perl 5's surprising behaviour was chosen arbitrarily.

[10:00] * audreyt ponders whether it's worth it to upgrade to gnome 2.14

[10:01] <audreyt> Juerd: I think it is chosen arbitrarily.

[10:01] <Juerd> I see :)

[10:01] <gaal> Detective AudreyT in the Case of the Missing Colon

[10:02] <Juerd> Hm, I could "svk up" twice

[10:02] <audreyt> py/rb/js all does floating %

[10:03] <gaal> uh, what is floating point %?

[10:03] <gaal> 5.2 % 7.3 == ?

[10:04] <audreyt> 5.2 ;)

[10:04] <audreyt> 7.3 % 5.2 is 2.1.

[10:04] <gaal> s/one/the other/

[10:05] <gaal> .oO(pi % e)

[10:06] <Juerd> gaal: $bar / $foo - int($bar / $foo) * $foo

[10:06] <svnbot6> r9854 | juerd++ | %

[10:06] <gaal> .oO(2 pi % pugs version)

[10:07] <Juerd> gaal: It can be very useful to know that 5 % 2.5 == 0

[10:07] <Juerd> While Perl 5 does int(5) % int(2.5) == 1

[10:08] <Juerd> It wouldn't be a problem if it warned about this, but it silently truncates the numbers

[10:08] <gaal> *nod

[10:09] <Juerd> Oh, and the behaviour for negative numbers should probably be specified by documentation rather than implementation :)

[10:10] <audreyt> there's a pretty good doc in

[10:10] <audreyt> ri Numeric.divmod

[10:18] <svnbot6> r9855 | juerd++ | t/%

[10:19] *** ko1_ is now known as ko1_away

[10:29] <gaal> when I do svk log -l 1, I get some empty commit messages

[10:30] <gaal> oh, I see svnbot tracked a skip in the r number too. why's that?

[10:30] <gaal> 9843-54 weren't mentioned here.

[10:30] <Juerd> 12:10 < svnbot6> r9854 | juerd++ | %

[10:30] <perlbot> What kind of idiot karmas himself?  Your kind of idiot!

[10:30] <Juerd> perlbot: steefu

[10:31] <audreyt> gaal: yeah, those are empty mergebases

[10:31] <gaal> -53

[10:31] <gaal> audreyt: say what?

[10:32] <gaal> also, after svk pull of quite a few upstream changes, I want to svk log -v and see what file each upstream patch did, but I only see the filelist for the pull unit (merge ticket? whatever the term is)

[10:33] <audreyt> gaal: those revs are just for telling svk upstream are cp'ed

[10:34] <audreyt> gaal: as they don't have a commit log, they are not shown

[10:34] <audreyt> gaal: not sure how to do that... try #svk

[10:35] <gaal> k

[10:46] <gaal> shouldn't Math::Basic::sign(undef) fail instead of return undef?

[10:46] <gaal> (Builtin.pod)

[10:47] <gaal> likewise <=>

[10:48] <audreyt> sure

[10:48] <audreyt> fix away :)

[10:51] <gaal> hmm now I'm not sure! <=> admitting undefs is probably useful in oneliners

[10:52] <gaal> btw, is there a TOC for synopses that includes the unwritten ones?

[10:53] <gaal> ah, perldoc Perl6::Bible

[10:53] <audreyt> (bbiab...)

[10:55] *** iblechbot joined
[11:03] *** chris2 joined
[11:10] <wolverian> audreyt, yeah, upgrading to gnome 2.14 is worth it, for some definition of "it".

[11:10] <wolverian> audreyt, dapper is stable enough nowadays to just install it, for some definition of "enough".

[17:34] *** ilogger2 joined
[17:42] *** Southen joined
[17:43] <arguile> If <=> is the spaceship operator, is <===> the mothership?

[17:43] <pmurias> the biggest problem is that the parrot api is really minimal roughly only init interpreter,load any run bytecode is defined

[17:45] <wolverian> TimToady, what's <===>? is === well ordered? that sounds weird.. :) or is that <= ==>?

[17:45] <pmurias> fglock:the biggest problem is that the parrot api is really minimal roughly only init interpreter,load any run bytecode is defined

[17:46] <fglock> pmurias: you may have to write a bit of code - see the Inline::Parrot stuff

[17:46] <pmurias> fon the other hand it may be enough, i have to go for swimming now

[17:46] <pmurias> s/fon/on

[17:46] <pmurias> bbiab

[17:46] *** siosiosios joined
[17:47] <b_jonas> it's <=== >

[17:57] *** zgh joined
[18:00] <Juerd> Hm, I kind of like the ...\s*... proposal

[18:00] <Juerd> $foo...

[18:00] <Juerd> ...bar

[18:00] <Juerd> is clearer than

[18:00] <Juerd> $foo.

[18:00] <Juerd> .bar

[18:00] <Juerd> And ... isn't that much harder to type than .

[18:06] *** hlen is now known as hlen_

[18:06] <TimToady> I'd prefer ...\s+. I think.  And we'd have to make current ... something else, like ..* or some such.

[18:06] *** hlen_ is now known as hlen

[18:06] <pmichaud> TimToady: the lookahead on    say .1   is because ".1" is a term and not postfix?  Or did I miss the example entirely?

[18:07] <Juerd> TimToady: \.\.\.\s+\. would be fine too. It's the trailing single . that I think is too inconspicuous

[18:08] <Juerd> Hmmm... /\.\.\.[\s+\.+]?/

[18:16] * Limbic_Region notices about 20 Synopses changes in the last 24 hours and wonders if TimToady has figured out how to hack in his sleep too

[18:20] *** mj41_ joined
[18:20] <TimToady> On the other hand :foo...   .($bar) is awfully unweildy if you're just trying to line up your pair arguments.

[18:22] <Juerd> TimToady: Maybe \.+\s+\.+ then

[18:22] <TimToady> $min..$max

[18:22] <Juerd> TimToady: \s+

[18:22] <TimToady> $min.. $max would be an error

[18:23] <Juerd> No, it would be a range operator, because \s+ didn't match and the postfix . is no longer considered.

[18:23] <Juerd> Or do I then not understand how parsers work?

[18:23] <TimToady> Just trying to avoid backtracking over a line boundary.

[18:23] <TimToady> $min..

[18:23] <TimToady> $max

[18:24] <xinming> TimToady: You use too much puctuations. :-P  do you considered ` ?

[18:24] <Juerd> Uh oh.

[18:24] <xinming> since ` isn't used in perl 6 yet IMHO,

[18:24] <TimToady> ` is reserved for user ops, or maybe units

[18:24] <TimToady> $x`meters

[18:24] <pmichaud> TimToady: what's the issue of backtracking over a line boundary?  Does it have to do with statement ends?

[18:24] <theorbtwo> pmichaud: Has to do with humans.

[18:25] <Juerd> theorbtwo: Humans can take this.

[18:25] <Juerd> Humans intuitively understand the difference between .. and .

[18:25] <Juerd> ., I think

[18:25] <TimToady> $min..

[18:25] <TimToady> =begin

[18:25] <TimToady> ...

[18:25] <TimToady> =end

[18:25] <TimToady> $max

[18:25] <Juerd> TimToady: A bit contrived though :)

[18:25] <Juerd> Anyone who puts POD in the middle of expressions should be shot anyway :P

[18:26] <pmichaud> TimToady: I haven't seen the latest pod docs, but in the version of the grammar I'm working with now pod would just be comments

[18:26] <pmichaud> (active comments, but still comments)

[18:26] <Juerd> Oh, I wanted to ask. Do we still have meaningful comments like #line?

[18:27] <Juerd> (Not referring to the shebang)

[18:27] <pmichaud> i.e., I was planning to put =begin into the ws rule

[18:27] <TimToady> could be =line now maybe

[18:28] <pmichaud> so, if that worked, backtracking over a line isn't an issue for the parser.  It might be for the human, but that's what they get for podding in the middle of an expression

[18:28] <svnbot6> r9858 | fglock++ | PCR/Category - improved testability

[18:28] <TimToady> It's still lookahead with an arbitrary number of intermediate characters.

[18:28] <Juerd> I don't think anything is going to look great and selfevident with pod in between.

[18:29] <TimToady> Anyway, we could just say that .. is always the range operator, and go with either ... or .

[18:29] <xinming> hmm, anyone here would tell me what does back track over a line mean? :-/ I'm not sure if I fully understand

[18:29] <Juerd> TimToady: But isn't every whitespace sensitivity thing suffering from that?

[18:29] <xinming> ... is yada operator.

[18:29] <TimToady> I think that's how people would rather read it.

[18:30] <pmichaud> we already have lookahead with an arbitrary number of intermediate characters ---  that's just the nature of whitespace, isn't it?

[18:30] <TimToady> it's the yada term.

[18:30] *** fglock joined
[18:30] <TimToady> has nothing to do with where an operator or postfix is expected.

[18:30] <TimToady> but not lookahead that changes whether we're expecting a term or operator.

[18:30] <TimToady> (I hope)

[18:31] <Juerd> xinming: It's simple. You're allowed to think and pause with ... within sentences, but the rules of the game are that you fail if you do so at the beginning ;)

[18:32] <Juerd> xinming: Many operators have different meaning, depending on where they are used. Consider, for example, * and ^

[18:32] <xinming> yes, + is plus, but in rule, It is at least one match

[18:32] <xinming> is it * or +

[18:32] <Juerd> xinming: "plus" itself has two different meanings.

[18:32] <xinming> oops

[18:33] <xinming> Is not plus...

[18:33] <theorbtwo> +$x, $a+$b

[18:33] <Juerd> xinming: +$foo, where + is used prefix, and $foo + $bar, where + is used infix, are different.

[18:33] <Juerd> Where +$foo happens to equal 0+$foo in most cases.

[18:33] <TimToady> more dramatically /$foo/ vs $x/$y

[18:33] *** cognominal joined
[18:34] <theorbtwo> And 1.0 vs $x.foo vs .foo vs ..1

[18:34] <Juerd> And : in rules, versus :pair, versus foo bar: list, versus foo: args, versus ::Foo, versus Foo::Bar, versus ... :)

[18:34] <TimToady> ..1 not legal currently

[18:34] <xinming> but now, what do we need?

[18:35] <theorbtwo> Oh, I thought it was -Inf..1

[18:35] <TimToady> not any more than 1.. is 1...

[18:35] <Juerd> ..1 could be $_..1 ;)

[18:35] <TimToady> erg

[18:35] <theorbtwo> Ah, right.

[18:35] <Juerd> I'm sure someone will event a use for that some day!

[18:35] <Juerd> s.event.invent.

[18:36] <pmichaud> TimToady: I know you've been down this path before, but I'm starting to agree that "dot" isn't the correct whitespace eater

[18:36] <Juerd> Heh. If ^\d methods always return the method name, on every object, and even undef, we don't need a special rule for .5 anymore ;)

[18:37] <TimToady> Maybe we should go with *.. and ..* and *..* as infinite ranges, much like ^.. ..^ and ^..^

[18:37] <jmcadams> sorry to bother you all, but I was forwarded an email saying that you might want to have a perl6 hack-a-thon pre-YAPC::NA

[18:37] *** fglock left
[18:37] <Juerd> TimToady: Personally, I really do not mind typing "Inf" when I mean inf.

[18:37] <jmcadams> if so, do you want me to find a place for everyone to meet up

[18:37] <pmichaud> jmcadams: last I heard it was to be a post-yapc::na hackathon

[18:37] <pmichaud> (but I could be well out of the loop)

[18:38] <Juerd> TimToady: These are three operators that I think are entirely unneeded

[18:38] <jmcadams> any idea of who the loop consists of?

[18:38] <jmcadams> I'm out of it myself

[18:40] <xinming> hmm, what about \.* for the back track?

[18:40] <TimToady> I don't understand what you're asking.

[18:42] <xinming> If I understand correctly, backtrack is used for something like \ at the end in C, which means, the next line and current are "grouped", sorry for me poor English. :-/

[18:43] <TimToady> ah, no, backtracking is a pattern matching term.  \ is a "line continuation".

[18:43] <Juerd> xinming: Backtracking is finding out you can't go any further, and going back to where you came from to try another alternative

[18:43] * xinming shuts up.

[18:43] <Juerd> xinming: Like in a maze, or a pattern match, or a detecvite story.

[18:44] <Juerd> detective

[18:44] *** cognominal joined
[18:44] <Juerd> xinming: Backtracking can be annoying, because it means what you did before was in vain, and the going back itself isn't free either.

[18:45] <TimToady> I think we could safely say that, in postfix position (that is, with no preceding whitespace) a /\.+<ws>/ always means "the postfix is continued after the whitespace with a leading dot".

[18:46] <TimToady> Backtracking in the parser also tends to mean that the user can also be confused by the syntax.

[18:46] <pmichaud> TimToady: is that just "gappy dot"?

[18:46] <Juerd> TimToady: Is there any difference between <ws> and \s+?

[18:47] <TimToady> <ws> includes comments and pod presumably.  "gappy dot" didn't require a dot after the whitespace.

[18:47] <Juerd> Aha

[18:47] <TimToady> This is a compromise that allows both $x... .foo and $x. .foo

[18:47] <TimToady> And $x.. .$foo if your'e so inclined.

[18:47] <Juerd> and $foo............................................

[18:47] <Juerd> .$bar :)

[18:48] <TimToady> but $x..$y is still a range, as is ($x...)

[18:48] <Juerd> TimToady: Is there any specific reason for not allowing ... after the <ws>?

[18:48] <Juerd> Foo...

[18:48] <Juerd> ...bar

[18:48] <Juerd> ...baz

[18:48] <Juerd> is quite common in normal languages

[18:49] <Juerd> Though perhaps that it means something else should be a blinking sign that it shouldn't be used for this ;)

[18:49] <Juerd> s/;/:/

[18:50] <TimToady> my problem with ...bar() is that it doesn't look like .bar() at all.

[18:50] <pmichaud> so, juerd's proposal would be more like   /\.+<ws>\.*<before \.>/

[18:50] <TimToady> To me  $x... ...bar() comes out to $xbar().

[18:51] <TimToady> $x...........................

[18:51] <TimToady> ................................bar()

[18:51] <xinming> ......

[18:51] <pmichaud> heh, that reminds me of   /* ... */ in C/C++.    $x...   wait for it ...bar()

[18:51] <TimToady> .oO(...)

[18:52] <Juerd> pmichaud: No, credits for ... ... go to David Green. I myself am not entirely convinced the second ... is a good idea, but I like it visually.

[18:52] <TimToady> $x... --- ...bar()  # sos

[18:52] <Juerd> ... we could have

[18:52] <Juerd> multiline

[18:53] <Juerd> comments ...

[18:53] <Juerd> ;)

[18:53] <pmichaud> that needs to be the debugging operator.    infix:<...---...>

[18:53] <Juerd> ...---... is the yadayadayadaaaaaaaaaaaaaaaaaaaaaaaaaaaargh operator?

[18:54] <pmichaud> TimToady: I don't see a problem with implementing /\.+<ws>/, fwiw

[18:54] <Juerd> I think it's wonderful.

[18:55] <TimToady> Well, let's bounce it off of p6l and see if juerd complains there. :)

[18:55] <pmichaud> I think maybe it should be   /\.+<ws><before \.>/, however, and we require the <ws> to be non-empty

[18:55] <Juerd> I think a special syntax for being able to format your code better is unique to Perl, or at least typical.

[18:55] <Juerd> TimToady: ;)

[18:56] <TimToady> $x. . . . . . . . . .42  # TOC entry.

[19:00] *** dduncan joined
[19:01] <pmichaud> gotta go look at a house, bbiab

[19:06] *** autark joined
[19:22] <svnbot6> r9859 | Darren_Duncan++ | ext/Rosetta/ : multiple docs updates in Language.pod and SeeAlso.pod

[19:29] *** dduncan left
[19:44] *** b_jonas joined
[19:45] <pmichaud> so, does this mean that it's valid to write   $x... ...   to mean $x..Inf  ?

[19:45] <PerlJam> ouch

[19:45] <PerlJam> that hurts my eyes

[19:46] <pmichaud> I think it really brings out just how big "Inf" can be.  :-)

[19:46] <PerlJam> And if we can chain ranges, then  $x... ... ... ... ... ... is valid too

[19:47] <pmichaud> uhhhh, no.  Range is C<..>

[19:47] <pmichaud> oh, I see

[19:47] <pmichaud> never mind :-)

[19:47] <pmichaud> ranges are non-chaining, fortunately

[19:47] <pmichaud> (see S03)

[19:48] <PerlJam> perl6 sure has opened up new avenues for obfuscation

[19:49] <PerlJam> btw, I think you guys are crazy to allow $x.................... .foo

[19:49] <PerlJam> $x. .foo I can stand though

[19:50] <PerlJam> and in fact, it's looking better and better :)

[19:50] <TimToady> I suspect best practices will be to use . to continue on this line and ... to continue on the next line.

[19:51] <pmichaud> TimToady: in S03, can we get rid of the phrase that talks about the "yada yada yada" operator?

[19:51] <pmichaud> and change it to be the "yada yada yada" term?

[19:51] <TimToady> I thought we'd already put a note to that effect, but maybe it was somewhere else.

[19:51] <pmichaud> However, ... as a term is the "yada, yada, yada" operator, which is used as the body in function prototypes. It complains bitterly (by calling fail) if it is ever executed. Variant ??? calls warn, and !!! calls die.

[19:52] <pmichaud> it does say "as a term" there, but I think people tend to focus on the word "operator" and translate that to "infix"

[19:52] <pmichaud> it's a minor nit, but one I thought I'd point out :-)

[19:53] <TimToady> maybe it's a prefix operator.

[19:53] <pmichaud> interestingly, postfix:<...> doesn't appear in the operator precedence table at the bottom of S03

[19:53] <TimToady> should

[19:53] <b_jonas> but that's right, because it does have a precedence

[19:54] <pmichaud> where should postfix:<...> go?  I'm guessing autoincrement precedence...?

[19:54] <b_jonas> to decide if $x + 1 .. means ($x + 1) .. or $x + (1 ..)

[19:55] <pmichaud> or, given that, perhaps it should be lower

[19:55] <b_jonas> if it's the range operator, it should have about the same precedence as the infix range I think

[19:55] *** _bernhard joined
[20:08] <PerlJam> So ...  would $foo.*bar become  $foo....  .*bar  or $foo.*... .bar  or  $foo.  *   .bar  or what?   I'm guessing it would be the first.

[20:12] <pmichaud> pj: you lost me there

[20:13] <pmichaud> but $foo.*bar would be   postfix:<.*>($foo, bar) or something like that

[20:13] <PerlJam> The other method invocation syntaxes.   A.B   A.*B  A.+B  and A.?B  (IIRC)

[20:13] <pmichaud> $foo.*B  is   $foo... .*B

[20:14] <pmichaud> the /\.+\s<ws>/ allows one to move the postfix thingy away from the term

[20:16] *** SamB joined
[20:16] *** hexmode joined
[20:16] <PerlJam> right, I'm just not taking any "obvious" thing for granted :-)

[20:17] <pmichaud> <pmichaud>	but $foo.*bar would be postfix:<.*>($foo, bar) or something like that           <---- ignore that, I wasn't thinking clearly again

[20:17] <pmichaud> my brain seems fogged today :-(

[20:21] *** chris2_ joined
[20:21] <pmurias> isn't $foo.*bar infix:<.*> (not thinking fully after exersise)

[20:22] <TimToady> no, methods are always considered postfix, even with .* in front.

[20:23] <TimToady> but they are never declared postfix:<.*foo> since we have method foo.

[20:24] <pmichaud> TimToady: does the method name have to abut the '.*' (or '.' or whatever)?

[20:24] <TimToady> yes

[20:24] <pmichaud> okay, good, that's what I was hoping :-)

[20:24] <TimToady> I think a more interesting question is whether it's $x>>. .foo or $x.  >>.foo

[20:25] <TimToady> offhand I'd guess the first, and the other would have to be written $x. .>>.foo or some such

[20:27] <PerlJam> that just dosn't look right without a @ to me

[20:27] <pmichaud> okay, perljam:    $x.   # but perljam thinks it should be @x \n  .>>.foo

[20:27] <pmichaud> er, @x.

[20:27] <pmichaud> fap

[20:28] <PerlJam> pmichaud: I hope this isn't affecting your perl6 work today  ;-)

[20:28] <pmichaud> pj: you mean the brain cloud?  no, not really

[20:29] <pmichaud> I'm trying to decide how I want to code/structure the past-->post translation at the moment

[20:30] <TimToady> doesn't matter, since left side is scalar context even with >>, so you'll get an array one way or another.  Though in the case of $x containing an array, you can certainly wite @$x if it makes you--except that the precedence would now attach the . more tightly than the @, so it'd have to be @($x)>>.foo or $x[]>>.foo

[20:31] <TimToady> /you/you happy/

[20:31] <PerlJam> Yeah, but that's what I expected that I needed to write.

[20:31] <PerlJam> you've shattered that expectation though

[20:31] <PerlJam> :)

[20:37] *** chris2 joined
[20:57] *** colares joined
[21:00] <pmurias> hello world from an embeded parrot in perl5 works!

[21:01] <pmichaud> pmurias: nice

[21:01] <webmind> yay :)

[21:07] *** nirgle joined
[21:11] *** chris2_ joined
[21:18] *** iblechbot joined
[21:41] <pmurias> dobra noc

[22:01] *** oneiron joined
[22:08] *** enantiodromos joined
[22:11] *** kanru joined
[22:15] *** stclare joined
[22:15] *** stclare left
[22:21] *** enantiodromos joined
[22:44] *** nirgle left
[22:53] *** theorbtwo joined
[23:00] *** FurnaceBoy joined
[23:32] *** larsen joined
[23:32] *** deejay_ joined
[23:33] <deejay_> anyone here know if waitpid(-1,WNOHANG) works in Windows XP? it seems to block for me.

[23:35] *** deejay_ left
[23:40] *** kakos joined
[23:49] *** PolettiX joined
[23:49] * Toaster vaguely remembers it not

