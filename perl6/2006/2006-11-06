[00:04] *** BooK_ joined
[00:08] <svnbot6> r14646 | audreyt++ | * MiniPerl6: EOL fixes; fix emitted code to be valid mp6

[00:11] *** Psyche^ joined
[00:24] *** Psyche^ is now known as Patterner

[00:29] *** Nickiniz joined
[00:29] *** Nickiniz left
[00:30] *** eggzeck joined
[00:34] *** nekokak joined
[00:35] <svnbot6> r14647 | fglock++ | MP6 - adding <%hsh> parsing

[00:35] *** fglock joined
[00:44] *** hikozaemon joined
[00:45] *** FOAD_ joined
[00:46] * eviltwin_b is testing a quick fix to the filetest parsing issue

[00:48] *** gantrixx joined
[00:49] * audreyt meanwhile is hacking in ::Dog(heads => 3)

[00:49] <eviltwin_b> so far, so good; it compiled and the initial sanity tests didn't chunk :)

[00:50] <audreyt> my Dog $Cerberus .= (heads => 3)

[00:51] <audreyt> and I'm hacking it in on all three implementations :)

[00:51] <audreyt> (MP6, P5, Hs)

[00:57] <GeJ> new is now optional?

[00:57] <GeJ> damn, it's moving too fast...

[00:59] <eviltwin_b> I'm thinking that's confusing

[01:00] <eviltwin_b> ::class(initializer) looks too much like :key(value) given how easy to miss a colon is

[01:00] <eviltwin_b> (or am I misunderstanding what's going on?)

[01:00] <audreyt> no you are not

[01:00] <audreyt> you can omit the ::

[01:01] <audreyt> Dog(heads=>3)

[01:01] <audreyt> provide ::Dog is in scope

[01:01] <audreyt> which should remind you of certain other languages...

[01:01] <clsung> GeJ: hi, good to see you here :)

[01:02] <GeJ> clsung: always been here idling in the corner trying to follow what's happening. But boy sometimes it's hard

[01:03] *** shobadobs joined
[01:04] <GeJ> clsung: talking about things happening here, maybe someone(tm) should get in touch with people from haskell@ to get the new GHC in the ports ;)

[01:04] *** lyokato joined
[01:07] <GeJ> ok, I'm getting parrot fixed in FreeBSD... next step pugs and then take over the world

[01:08] <eviltwin_b> ah, ok

[01:11] <svnbot6> r14648 | audreyt++ | * Pugs::Compiler::Perl - Implement ::Class( field => 'val' ) construction syntax.

[01:11] <svnbot6> r14649 | audreyt++ | * MiniPerl6::Grammar - Remove the v5 helper blessers and consistently

[01:11] <svnbot6> r14649 | audreyt++ |   use the new ::Class(field=>'val') syntax.

[01:22] *** dmq joined
[01:33] *** miyagawa_ joined
[01:37] <audreyt> fully implemented.

[01:38] <audreyt> fglock just fried his brain for the day... I'm going to fade too

[01:38] <audreyt> more hacking tomorrow morning :)

[01:38] * audreyt waves &

[01:39] <svnbot6> r14650 | audreyt++ | * Pugs.AST.Internals: Allow prototype objects to act as Code

[01:39] <svnbot6> r14650 | audreyt++ |   objects, which for now simply delegates named parameters to

[01:39] <svnbot6> r14650 | audreyt++ |   the .new call.  (In the future it may also serve as coercion.)

[01:39] <svnbot6> r14650 | audreyt++ |     my $cerberus = ::Dog(heads => 3);

[01:39] <svnbot6> r14650 | audreyt++ |     my $cerberus = ::Dog.new(heads => 3); # same thing

[01:39] <svnbot6> r14650 | audreyt++ |   This is semi-specced, but not really formalized, but extremely

[01:39] <svnbot6> r14650 | audreyt++ |   handy, so we implement it anyway.

[01:39] <svnbot6> r14650 | audreyt++ | * Pugs.Parser.Operator: Correctly parse for "$x .= (1,2,3)"

[01:39] <svnbot6> r14650 | audreyt++ |   to mean "$x = $x.(1,2,3)", so we can write:

[01:39] <svnbot6> r14650 | audreyt++ |     my Dog $cerberus .= (heads => 3);

[01:39] <svnbot6> r14650 | audreyt++ |   and save three characters of typing.

[01:39] <svnbot6> r14650 | audreyt++ | * Pugs.Parser: Adjust a comment about canonical status as

[01:39] <svnbot6> r14650 | audreyt++ |   the ".=meth" term is now canonical in S03.

[01:54] <svnbot6> r14651 | lanny++ | * clean up unexpected passing TODOs

[01:56] *** cmarcelo joined
[02:09] <aufrank> ?eval class Foo { method bar { say "baz" } } my $foo = Foo.new; $foo.bar; $foo.can("bar");

[02:09] <evalbot_r14651> OUTPUT[baz␤] Error: No compatible subroutine found: "&can"

[02:09] <aufrank> ?eval class Foo { method bar { say "baz" } } my $foo = Foo.new; $foo.bar; $foo.^can("bar");

[02:09] <evalbot_r14651> Error: ␤Unexpected "^"␤expecting ".", "\187", ">>", "=", operator name, qualified identifier, variable name, "...", "--", "++", array subscript, hash subscript or code subscript

[02:12] <aufrank> oh, just found can.t

[02:13] <cmarcelo> @tell audreyt i'm home and safe :) _thank you_ for helping me out with MOH and "walking" thru the details of the bootstrap plan [btw, remember to commit that file]. I'll work out my english skills so next time we see I'll be more "talkative", like I was with .br mongers :o)

[02:13] <lambdabot> Consider it noted.

[02:14] <cmarcelo> nothingmuch++ # MOH is MO ;)

[02:15] *** cmarcelo left
[02:17] *** esstone joined
[02:24] <svnbot6> r14652 | audreyt++ | 03:13 < cmarcelo> [btw, remember to commit that file].

[02:24] <GeJ> parrot 0.4.5 back in FreeBSD

[02:24] <GeJ> waiting for a bison upgrade to import 0.4.6

[02:27] <audreyt> GeJ++

[02:27] <lambdabot> audreyt: You have 3 new messages. '/msg lambdabot @messages' to read them.

[02:28] <audreyt> @massages

[02:28] <lambdabot> TimToady said 19h 17m 24s ago: aforementioned bug now infests examples/algorithms/fibonacci_memoization.pl

[02:28] <lambdabot> cmarcelo said 11h 42m 8s ago: I pushed mi.t equivalent for MOH. Now Roles are on the way. I'll leave Sao Paulo tonight around 9-10pm, so if afternoon you have time i'll be happy to see how/where

[02:28] <lambdabot> this will get into pugs

[02:28] <lambdabot> cmarcelo said 15m 20s ago: i'm home and safe :) _thank you_ for helping me out with MOH and "walking" thru the details of the bootstrap plan [btw, remember to commit that file]. I'll work out my

[02:28] <lambdabot> english skills so next time we see I'll be more "talkative", like I was with .br mongers :o)

[02:28] <eviltwin_b> still running full test on my parser change.  still looking good --- some unexpected test failures but they look related to others' work (eg regex tests)

[02:31] <GeJ> audreyt: you're not running FreeBSD anymore, correct?

[02:31] <audreyt> GeJ: my old laptop still does

[02:31] <audreyt> but this one is darwinports, aye

[02:34] <GeJ> If I can't lobby FreeBSD people to upgrade ghc, could I come back to you as my "Help us Audrey Tang, you are our only hope." chance?

[02:35] <audreyt> you can also lobby Igloo and JaffaCake.

[02:35] <audreyt> JC is busy. Igloo is paid to care.

[02:35] <clsung> upgrade ghc?

[02:35] <GeJ> I mean for pushin a bootstrap image on the ghc repo, from there I should fill a PR and use the regular process to upgrade the port

[02:35] <audreyt> that'd be Igloo's job. find him on #ghc and #haskell

[02:35] <audreyt> also note you _can_ use the same boot image as 6.4.

[02:35] <audreyt> 6.4 can boot 6.6 just fine.

[02:35] <audreyt> so maybe you don't need that.

[02:36] <GeJ> clsung: unless I missed it during the slush craze, I didn't see ghc move to 6.6

[02:36] <clsung> ah ha

[02:36] <GeJ> audreyt: thanks for the tip, I'll look into that and see if I can send a PR

[02:36] <audreyt> ok. have fun!

[02:36] <svnbot6> r14653 | aufrank++ | added tests for $foo.^can('bar') and $foo.^isa('Foo') syntax for introspection metamethods

[02:36] * audreyt sleeps for real &

[02:36] <GeJ> thank you

[02:37] <GeJ> nighty night

[02:37] <aufrank> gnight audreyt

[02:37] <audreyt> aufrank: cool, that means we'll get more yellow boxes once MO is rolled in

[02:37] <aufrank> yellow is pass :todo<feature> ?

[02:40] <audreyt> pass :todo<anything>

[02:40] <aufrank> neat :)

[02:40] <eviltwin_b> freshports shows it still at 6.4.2_1

[02:41] <aufrank> macports got bumped to 6.6 last week

[02:46] <eviltwin_b> hrm.  guess I need to understand the parser a bit better

[02:46] <eviltwin_b> didn't break anything; also didn't fix anything

[02:48] *** mako132_ joined
[02:53] <GeJ> eviltwin_b: true, and I intend to get this fixed (ghc-related)

[02:54] * eviltwin_b foolishly realizes what he did was actually a no-op, and the real problem is somewhere else

[02:57] <eviltwin_b> hm, but that leaves me wondering why the file test ops parse differently than e.g. -=

[02:57] <svnbot6> r14654 | aufrank++ | added tests for .^does to go along with .HOW.does

[03:05] <eviltwin_b> hm.  think I know.  parsec docs are at work, though

[03:09] <eviltwin_b> ...or online

[03:12] *** scw joined
[03:14] *** shobadobs joined
[03:24] <aufrank> is there sugar getting the last index in an array

[03:25] <aufrank> @array.elems - 1 works, but I thought I remembered having a sugary substitute

[03:25] <lambdabot> Unknown command, try @list

[03:25] <aufrank> thanks for nothing, lambdabot

[03:31] <eviltwin_b> if you're using it as an index (and not part of a range), index -1 should work I think

[03:32] <aufrank> eviltwin_b: can you put that in code?  @array...

[03:33] <eviltwin_b> ?eval my @a = <1 2 3>; @a[-1]

[03:33] <evalbot_r14654> \"3"

[03:33] <aufrank> oh, right

[03:33] <aufrank> thx

[03:41] *** bcorn_ joined
[03:48] *** avar joined
[03:53] <aufrank> could @array[0].exists ever be made a synonym for @array.exists(0) ?

[04:01] *** Aankhen`` joined
[04:17] <eviltwin_b> ew

[04:18] *** penk joined
[04:20] <aufrank> ew what?

[04:55] <avar> aufrank: ew as in that would be horrid

[04:55] <avar> hrm, or maybe not

[04:55] * avar remembers that @a[0] is not a slice anymore:)

[04:56] <TimToady> the problem with .exists (and .deletes) is that it has to retroactively change the meaning of the subscripting operation, and that basically makes it a macro

[04:59] <aufrank> TT: that makes sense

[05:00] <aufrank> it's pretty least-surprising to me, but I see why it's a complicated addition

[05:01] <aufrank> maybe a .exists? macro to go along with .exists() method ?

[05:05] <TimToady> more likely would be a :exists and :delete modifier on ordinary subscripting

[05:05] <aufrank> how does that work on nested lists, for example?

[05:06] <TimToady> depends on what the slice digs up, just like ordinary subscripting

[05:07] <TimToady> having the @foo[@list]:delete form also would emphasize that the deleted elements are returned (as they are in Perl 5)

[05:08] <TimToady> the main thing I don't like about @foo.delete(@list) is that the right side doesn't look like a slice

[05:08] <aufrank> yeah, I agree

[05:09] <TimToady> one could make a .delete or .exists method that gives a different "view" of the array to the subscript:

[05:09] <TimToady> %hash.delete{@keys}

[05:09] <TimToady> but that gets a bit tricky if you don't actually do the delete right away.

[05:09] <TimToady> and potentially involves you with proxy overhead

[05:10] <aufrank> I like &h.delete{} and @a.delete[] better than the .() form

[05:10] <aufrank> s/&/%/

[05:11] <aufrank> if that's what you were suggesting

[05:11] <TimToady> but again, it's more like a macro modifying the subscript there.

[05:11] <aufrank> yup

[05:11] <TimToady> and then you don't have to worry about people saying $ref = %hash.delete;

[05:12] <aufrank> the deleted items are returned but you think you're getting a hashref of the altered hash?

[05:12] <TimToady> problem I see is returning a self-deleting hash to someone unsuspecting

[05:13] <TimToady> so macro view is safer

[05:13] <TimToady> question is whether we can have a .delete{} macro that doesn't interfere with .delete()

[05:15] <TimToady> .foo implies run-time dispatch, and macros tend to interfere, unless this macro just remapped .delete{} to .delete([]) or some such

[05:17] <TimToady> I said that deleting and existing are just modifiers to subscripting, but practically speaking you might not want to clutter your normal subscripting code with optional control flow.

[05:18] <aufrank> you'd tend to only use the modifiers to be explicit about getting Bools for tests, though, right?

[05:18] <aufrank> oh, that's true for exists but not delete

[05:19] <TimToady> contextual

[05:19] * aufrank is stuck on the one I'm trying to use now ;)

[05:19] <aufrank> man, my person-foo is weak this evening

[05:24] <aufrank> TT: feeling better after whatever kept you out of Brazil?

[05:25] *** kanru joined
[05:27] <TimToady> it's more of a long-term thing, but I think I'm improving.  Part of it was my wife was also sick for a month, and between the two of us we almost make one human being...

[05:29] <TimToady> I just think the summer schedule took a lot more out of us that we realized at the time.

[05:30] <TimToady> and when I do that to myself, my body has lots of ways to tell me it's time to back it off a notch or two for a while.

[05:31] <aufrank> glad to hear you're improving.  I hope you get a chance to catch up to yourself now.

[05:31] <TimToady> well, this whole Perl 6 thing has taught me that I have to pace myself.  I'm the only person who's not really allowed to quit, after all.  :)

[05:31] <aufrank> granted :)

[05:34] <aufrank> ?eval my @tmp; @tmp<foo>.push('bar')

[05:34] <evalbot_r14654> Error: Cannot cast into Hash: VRef <Array:0xb67d8720>

[05:35] <TimToady> ?eval my %tmp; %tmp<foo>.push('bar')

[05:35] <evalbot_r14654> 1

[05:35] <aufrank> ?eval my @tmp; @tmp[0]<foo>.push('bar')

[05:35] <evalbot_r14654> 1

[05:35] <aufrank> that's what I meant

[05:35] <TimToady> I think autoviv is saner in P6 than in P5

[05:36] <aufrank> I'm with you there

[05:36] <aufrank> though I wouldn't pretend to know either completely ;)

[05:36] <TimToady> but it's one of the reasons exists has to know that it's doing that and not an assignment, say

[05:37] <aufrank> yup

[05:37] <TimToady> though I suppose the real P5 autoviv problem comes before the final subscript op

[05:38] <TimToady> cascading subscript ops need to propagate the rvalue/lvalue context up, and P5 botched that

[05:46] *** avarab joined
[05:47] *** kanru_ joined
[05:52] <svnbot6> r14655 | lwall++ | [t/var/state.t] fib test that fails

[05:52] <svnbot6> r14655 | lwall++ | [examples/algorithms/fibonacci_memoization.pl] work around state=list problem

[05:56] <svnbot6> r14656 | lwall++ | Off by one on previous test

[05:57] *** avarab_ joined
[05:59] <svnbot6> r14657 | lwall++ | Might as well add test of workaround variant to make sure that doesn't break

[06:15] *** BooK joined
[06:44] <aufrank> TimToady: still around?

[06:47] <eviltwin_b> hm.  I don't think you want to parse the leading hyphen of a file test op with @name@

[06:53] *** iblechbot joined
[06:53] <TimToady> aufrank: vaguely

[06:54] <eviltwin_b> misread it.  still looks like it's being parsed with the wrong verb, but at 2am I'm too fuzzy

[06:56] <aufrank> TimToady: have you had reason to do any command line parsing for your $job p6 code?

[06:56] <aufrank> with GetOpt and friends?

[06:56] <aufrank> I've had trouble getting perl5:Getopt::Long to work correctly here

[06:57] <TimToady> not really.  I tend to avoid getopts of all sorts.

[06:58] <TimToady> and the particular program doesn't need args

[06:58] <TimToady> (except a filename)

[06:58] <aufrank> and you're just doing $*ARGS.shift or somesuch for that?

[07:00] <eviltwin_b> right.  "symbol name" parses the "-"... and eats trailing whitespace.  (makeOp1)

[07:00] <TimToady> yeah.  I'm kinda waiting for someone to implement S06:2468

[07:02] <TimToady> in fact, the last line of my proggie currently reads: MAIN(); exit;   # should be automatic some day

[07:05] <TimToady> @tell audreyt interesting factoid: when I was profiling the "if->" patch, it came to my attention that about 90% of our current test failures are caused by that patch--seems to give Span and Span::Num fits somehow.  But it's not obvious from the failures how they're related to "if->".

[07:05] <lambdabot> Consider it noted.

[07:06] *** zptao joined
[07:08] <TimToady> 'z' xx * &

[07:10] <aufrank> gnight

[07:11] <gaal> mmm, that means "sleep for as long as desired"

[07:12] <aufrank> hmm.  should I be able to call split on =<> ?

[07:13] <aufrank> my ($foo, $bar) = =<>.split(",") #doesn't work

[07:13] <gaal> does (item =<>).split work?

[07:13] * eviltwin_b gives up for the night.  &

[07:14] <aufrank> gnight etb

[07:14] <aufrank> yes, yes it does

[07:14] * aufrank thanks gaal

[07:19] *** marmic joined
[07:19] <gaal> sure thing :) it was a wrong context

[07:25] *** justatheory joined
[07:31] <aufrank> is there a reason to prefer @list.grep():{$_ ~~ /foo/} to @list.grep( {$_ ~~ /foo/} )

[07:59] *** eggzeck joined
[08:01] *** Psyche^ joined
[08:10] <aufrank> if anyone's still around, can you explain this to me?

[08:11] <aufrank> ?eval class Bar { has @.x is rw; has $.y; $.y := @x[0]; }

[08:11] <evalbot_r14657> Error: Cannot bind this as lhs: Syn "${}" [App (Var "&y") (Just (Var "&self")) []]

[08:13] <aufrank> $.y is an accessor, not a real variable.  But I'd still like to bind it as if it were a variable.

[08:17] *** Psyche^ is now known as Patterner

[08:18] *** avarab_ is now known as avar

[08:28] *** DHGE joined
[08:37] *** kisu joined
[08:46] <lumi> Maybe you can bind $!y?

[08:47] <lumi> Unless it's been renamed; at any rate it doesn't seem to work

[08:55] *** kane-xs joined
[08:57] <aufrank> lumi: I think the problem is that $.x and $!y aren't really Scalars, they're Code.  That's why the error is about not being able to bind &x

[08:58] <aufrank> $.x is actuall method x { return $x } or something like that

[08:58] <aufrank> s/actuall/actually/

[09:01] *** drrho joined
[09:01] <lumi> I thought $!y is supposed to be the actual variable, with $.y being the generated accessor

[09:02] <aufrank> $!y is definitely private.  I don't know if that means it's a plain old Scalar or not

[09:02] <lumi> Oh, you don't bind scalars, do you? You bind names

[09:03] <lumi> So it mostly can't bind it because it gets desugared too early

[09:03] *** autark joined
[09:05] <aufrank> I think I follow

[09:07] <lumi> I don't know what would be correct behaviour.. maybe to do what you want you need: method y is rw { return @.x[0] } or something?

[09:07] <aufrank> makes sense, yeah

[09:10] <lumi> Also it seems to work now

[09:10] <lumi> ?eval class Bar { has @.x is rw; method y is rw { return @.x[0]} }; my Bar $x .= (); $x.y = 2; say $x.x;

[09:10] <evalbot_r14657> OUTPUT[2␤] Bool::True

[09:12] *** buetow joined
[09:13] <aufrank> ?eval class Baz { has @.x is rw; method y is rw { return @.x[0] } }; my $qux = Baz.new( :x(1,2,3) ); $qux.y; $qux.y = 'foo';

[09:13] <evalbot_r14657> Error: Can't modify constant item: VInt 1

[09:14] <aufrank> anyway, I think I'd better sleep now

[09:14] <lumi> Looks like $.x got set to a list, instead of an array, maybe?

[09:14] <lumi> Night

[09:15] <aufrank> ?eval class Baz { has @.x is rw; method y is rw { return @.x[0] } }; my $qux = Baz.new( :x(1,2,3) ); $qux.x[0];

[09:15] <evalbot_r14657> \1

[09:15] <aufrank> ?eval class Baz { has @.x is rw; method y is rw { return @.x[0] } }; my $qux = Baz.new( :x(1,2,3) ); $qux.x[2];

[09:15] <evalbot_r14657> \3

[09:15] <aufrank> ?eval class Baz { has @.x is rw; method y is rw { return @.x[0] } }; my $qux = Baz.new( :x(1,2,3) ); $qux.x;

[09:15] <evalbot_r14657> [1, 2, 3]

[09:15] <lumi> ?eval class Baz { has @.x is rw; method y is rw { return @.x[0] } }; my $qux = Baz.new( :x(1,2,3) ); $qux.x.WHAT;

[09:15] <evalbot_r14657> ::Array::Const

[09:40] *** SubStack joined
[09:40] *** BooK joined
[09:45] *** elmex joined
[09:47] *** iblechbot joined
[09:49] *** Coleoid joined
[09:50] *** andara joined
[09:58] *** ruoso joined
[10:15] <svnbot6> r14658 | lumi++ | Added tests for $foo .=() construction, and for lists initiated in the constructor being mutable.

[10:19] *** kensanata joined
[10:37] <nothingmuch> hola

[10:54] <lumi> Morning, nothingmuch

[10:54] <nothingmuch> hola lumi

[11:08] *** kanru_ is now known as kanru

[11:19] *** xinming_ joined
[11:32] *** BooK joined
[11:42] *** kane-xs_ joined
[11:43] *** HiTech69 joined
[11:54] *** mako132 joined
[12:00] *** thisvieira joined
[12:09] *** penk joined
[12:14] *** BooK_ joined
[12:17] *** thisvieira is now known as todd-

[12:19] *** penk joined
[12:22] *** chris2_ joined
[12:30] *** HiTech69 joined
[12:30] *** Psyche^ joined
[12:35] *** penk joined
[12:37] *** ludan joined
[12:37] *** mako132_ joined
[12:43] *** Psyche^ is now known as Patterner

[12:44] *** rodi joined
[12:44] *** Lorn joined
[12:45] *** DaGo joined
[13:10] *** mako132 joined
[13:12] *** iblechbot joined
[13:33] *** kanru joined
[13:35] *** BooK_ is now known as BooK

[13:37] *** electrogeek joined
[13:46] *** boo joined
[13:48] *** lumi_ joined
[13:48] *** mbradley is now known as mbradley|bus

[14:05] *** BooK_ joined
[14:18] *** woremacx joined
[14:40] *** diakopter joined
[14:49] *** rodi joined
[14:52] *** hexmode joined
[14:54] *** xinming_ is now known as xinming

[14:56] *** rlb3 joined
[15:03] *** c6rbon joined
[15:03] *** mbradley|bus is now known as mbradley

[15:04] *** GnuVince joined
[15:04] <GnuVince> ?eval ~(1.1 .. 3)

[15:04] <evalbot_r14658> "1.1 2.1 3.1"

[15:04] <GnuVince> is that proper behaviour?

[15:05] <GnuVince> how about this:

[15:05] <[particle]> no, i don't think it is

[15:05] <GnuVince> ?eval (~(1..3.4), ~(1..3.5))

[15:05] <evalbot_r14658> ("1 2 3", "1 2 3 4")

[15:08] *** iblechbot joined
[15:10] <GnuVince> Both seem incorrect to me, however no tests mention floats.  I'll need to talk to audreyt or TimToady to know for sure.

[15:11] <[particle]> i think you should add failing tests

[15:12] <[particle]> that way they'll get corrected either way

[15:12] <GnuVince> I have added them to my working copy

[15:12] <GnuVince> Okay

[15:12] <GnuVince> I'll do that

[15:12] <[particle]> did you look at the spec?

[15:12] <GnuVince> Yeah, no mentions

[15:12] <GnuVince> I assume the behavior should be like Perl 5, to truncate

[15:13] <GnuVince> the 1.1 .. 3 seems especially wrong, it goes beyond the upper limit

[15:13] <[particle]> yes indeed

[15:19] *** justatheory joined
[15:20] *** ruoso joined
[15:22] *** laudiceia joined
[15:23] *** rodi joined
[15:27] *** woremacx joined
[15:32] <svnbot6> r14659 | gnuvince++ | Added test cases for the range operator with floating point numbers.

[15:35] <svnbot6> r14660 | gnuvince++ | Shamelessly added myself to AUTHORS

[15:35] <nothingmuch> nekokak: you mean proudly =)

[15:36] <nothingmuch> err

[15:36] <nothingmuch> GnuVince: that was for you, not nekokak

[15:38] *** Limbic_Region joined
[15:40] <lumi_> Surely there's no shame in it, so it's shameless

[15:40] <nothingmuch> compare:

[15:40] <nothingmuch> Your mother is uglyness-less

[15:40] <nothingmuch> Your mother is pretty

[15:40] <nothingmuch> the first one is a borderline insult

[15:41] *** shobadobs joined
[15:41] <nothingmuch> because it hints of the bad that was expected but in fact was not present

[15:41] <xinming> ...

[15:41] <lumi_> It's more borderline weird

[15:41] <GnuVince> nothingmuch: Proudly, yes.  Shamelessly too.  I didn't wait to have a few commits before adding myself.  Bang, on the first one :)

[15:41] <nothingmuch> GnuVince: in that case it was a bootstrap

[15:41] <lumi_> GnuVince: That's the proud (shameless?) Pugs tradition

[15:42] <nothingmuch> that way we guilt people into actually making changes afterwords =)

[15:42] *** lumi_ is now known as lumi

[15:42] <GnuVince> Hahaha :)

[15:42] <GnuVince> Well I look forward to having more commits, that's for sure.

[15:42] <GnuVince> But for now work (PHP :( ) calls

[15:43] <GnuVince> bbl

[15:50] * gaal mooses

[15:52] * kolibrie_ released DateTime::Format::Oracle in perl 5 land

[15:57] *** timbunce joined
[15:59] *** notThat joined
[16:10] *** aufrank joined
[16:14] <aufrank> hey folks

[16:15] <rodi> salut, aufrank

[16:15] <lumi> Hi aufrank

[16:16] <lumi> aufrank: I added a test for the borkage you found

[16:16] <aufrank> lumi++ # checked in tests last night

[16:18] <aufrank> this is sort of a basic question, but for a file foo.pl where I 'use v6-alpha' should I be able to do run 'perl fool.pl' or is 'pugs foo.pl' all that works now?

[16:18] <nothingmuch> aufrank: perl foo.pl

[16:18] *** jferrero joined
[16:18] <aufrank> I get an error that v6.pm isn't in @INC

[16:18] <nothingmuch> install v6 then =)

[16:19] <aufrank> should make install install v6?

[16:19] <nothingmuch> whose make install?

[16:19] <nothingmuch> http://search.cpan.org/~fglock/v6-alpha-0.015/

[16:19] <lambdabot> Title: Fl&#225;vio Soibelmann Glock / v6-alpha-0.015 - search.cpan.org, http://tinyurl.com/yxjxfd

[16:20] <aufrank> in a pugs checkout

[16:20] <nothingmuch> *nod*

[16:20] <nothingmuch> v6 is not pugs

[16:20] *** ofer0 joined
[16:20] <nothingmuch> i'm not sure  if it'll install

[16:20] <nothingmuch> but you can install v6 from the cpan

[16:20] * aufrank goes to perl -M'CPAN' -e'install v6'

[16:21] <TimToady> I don't know how up-to-date the CPAN version will be

[16:21] <nothingmuch> oh, right

[16:21] <nothingmuch> it's been almost two months

[16:21] <Debolaz> Our friend on wikipedia has vandalised the perl 6 page again. http://en.wikipedia.org/w/index.php?title=Perl_6&curid=1146638&diff=85985214&oldid=85984845

[16:21] <lambdabot> http://tinyurl.com/y58znp

[16:21] <aufrank> so what's the approved way of getting v6.pm into @INC?

[16:22] <nothingmuch> aufrank: osrry, i'm not very up to date

[16:22] <nothingmuch> maybe pugs' own make install will install it as well

[16:22] <nothingmuch> i never ran that though =(

[16:22] <TimToady> me either

[16:23] <TimToady> I don't think so, but I don't do "make install" these days

[16:24] <TimToady> I think if I were gonna do it, I'd either go down into pugs's perl5 dir and try to install stuff from there, or I'd try to add those blibish directories to @INC

[16:24] <aufrank> it seems not to, as I've done a make install from a recent checkout but can't run v6-alpha modules with perl 5.8

[16:24] <TimToady> or copy the file I want to run down into the directories.

[16:24] <pasteling> "nothingmuch" at 84.108.53.74 pasted "v6.pm" (6 lines, 236B) at http://sial.org/pbot/20930

[16:24] <nothingmuch> i don't know which one is the True™ version

[16:24] <nothingmuch> i suppose the top level

[16:25] <aufrank> TimToady: do you mostly just use pugs to run p6 code, or is there some better option to get it working with perl5 that I am not considering?

[16:25] <nothingmuch> oh

[16:25] <nothingmuch> This is not the perl5 v6-alpha, see perl5/Pugs-Compiler-Perl6 for that.

[16:25] <TimToady> the stuff in toplevel v6/ is the new v6 in MiniPerl6, I think

[16:25] <nothingmuch> *nod*

[16:25] <nothingmuch> that line i just pasted was from ./v6/README

[16:25] <TimToady> I mostly just use the Haskell runtime currently

[16:26] * nothingmuch mostly uses MO nowadays

[16:26] <nothingmuch> actually nowadays I mostly sit and "hmmm"

[16:26] *** notThat left
[16:26] <TimToady> aufrank> is there a reason to prefer @list.grep():{$_ ~~ /foo/} to  @list.grep( {$_ ~~ /foo/} )

[16:27] <TimToady> with the latter you have to remember to put the paren at the end

[16:27] <TimToady> plus you don't get the magic } line-ending parsing where you might want it

[16:27] <[particle]> my editor reminds me of that

[16:27] <TimToady> so it really depends on how big the block is and whether it's final

[16:27] <aufrank> TT: thanks

[16:28] <TimToady> but it's not a grep-only thing

[16:28] <TimToady> it's a general method: @ARGS thing

[16:28] * nothingmuch finds @list.grep():{ } extremely confusing

[16:28] <nothingmuch> the "stuff that is given to  grep" intuitively extends up to the closing )

[16:28] * dmq waves hello

[16:28] <nothingmuch> hola dmq

[16:28] <TimToady> I always put a space between the : and the {

[16:28] <TimToady> : turns a method into a listop

[16:28] <Debolaz> That whitespace sensitivity is pretty much my only objection to perl6. It makes things occationally difficult to read.

[16:29] <Debolaz> For me.

[16:29] <dmq> I thought id note for those not following p5p that I posted a redo of my earlier stack control verbs for the regex engine today.

[16:29] <TimToady> it's all driven by the need to be able to add postfix operators

[16:29] * Debolaz knows. :-/

[16:29] <dmq> I tried to incorperate what feeback ive received so far.

[16:31] <TimToady> < aufrank> ?eval class Bar { has @.x is rw; has $.y; $.y := @x[0]; }

[16:31] <TimToady> it would be very difficult to make that mean something

[16:31] <TimToady> because attributes are generic until BUILD time

[16:32] *** chris2_ joined
[16:32] *** peernaute459 joined
[16:32] * nothingmuch always kinda thought that all actions on $.foo in the class decl are saved as continuations to be invoked during BUILD for every object

[16:33] *** chris2_ is now known as chris2

[16:33] *** boo is now known as boo_

[16:33] <TimToady> nope

[16:33] <nothingmuch> so they are special cased?

[16:33] *** boo_ is now known as boo

[16:34] <TimToady> has is a declarator and can do whatever it wants to "rechronify" its actions, including its = clause

[16:34] *** peernaute459 left
[16:34] *** boo is now known as beboom

[16:34] <TimToady> but the class's code only runs when the class itself is constructed

[16:35] <TimToady> it's just a method on the metaclass, I think

[16:35] <nothingmuch> ++

[16:35] *** beboom is now known as beBOOm

[16:35] <TimToady> if the class body ran at BUILD time we wouldn't need BUILD

[16:35] <nothingmuch> i sort of meant that the rechronification could be implemented in terms of continuations and thus could support e.g. $.y := @x[0];

[16:36] <nothingmuch> oh, no

[16:36] <nothingmuch> not the entire body

[16:36] <nothingmuch> just the actions on future variables

[16:36] <nothingmuch> at class construct time $.y doesn't exist

[16:36] <nothingmuch> it's a place holder for every $.y that will exist

[16:36] <TimToady> I think it would be very easy to intermix things inconsistently

[16:36] <nothingmuch> *nod*

[16:36] <Limbic_Region> TimToady - thanks for the insight on the fibonacci memoization

[16:37] <TimToady> and it would be much better to put them somewhere where the temporal context isn't implicit

[16:37] <xinming> TimToady: Is there a way to get the "class" using .perl?

[16:37] <nothingmuch> but then again saying class Foo { has $.x = 1 } is sort of the same as class Foo { has $.x; submethod BUILD { $.x = 1 } }

[16:37] <xinming> Since we can easily get an object using .perl

[16:37] <TimToady> I think "insight" is perhaps too dignified a word for what I do...

[16:38] <xinming> I wonder if we would have a method get the code it self... :-)

[16:38] <nothingmuch> that's a matter of good programming standards =)

[16:38] <nothingmuch> i don't think $.x := @y[0] is good style

[16:38] <nothingmuch> it's just that intuitively i saw no reason for it to not be supported technically

[16:38] <nothingmuch> in a predictable way

[16:38] <Limbic_Region> well in any case, I clearly wasn't thinking clearly

[16:39] * Limbic_Region wanders off after kicking off a smoke

[16:40] <TimToady> xinming: whether you can get at the class of an object probably depends a little on whether the object actually has a class.

[16:40] <dmq> the posting can be found here if anybody wants to see: http://aspn.activestate.com/ASPN/Mail/Message/perl5-porters/3328324

[16:40] <lambdabot> Title: [PATCH] New regex syntax omnibus :: ASPN Mail Archive :: perl5-porters, http://tinyurl.com/y87qu8

[16:41] *** amnesiac joined
[16:43] <xinming> TimToady: what do you mean please? >_<

[16:44] <TimToady> P6 supports both class and prototype paradigms

[16:44] <TimToady> prototype objects don't really have classes.

[16:44] <kolibrie> aufrank: I installed v6.pm and dependencies from CPAN, and then go into pugs/perl5 and install from there to keep up-to-date

[16:44] <TimToady> also, since the body of a class is a run-once thing, whether you can get at it depends on whether the metaclass keeps the closure around.

[16:45] <xinming> ...

[16:45] <xinming> Ok,

[16:45] <nothingmuch> aufrank: ping

[16:45] <nothingmuch> err

[16:45] <nothingmuch> audreyt: ping

[16:45] <TimToady> if you want to be able to take a snapshot of a class and use it as a role, then you probably do need to keep the class definition closure

[16:45] <nothingmuch> || cmarcelo for that matter

[16:46] <TimToady> but P6 does not guarantee this behavior

[16:46] <xinming> TimToady: What I wonder is if we can pass the whole "object"-implementation and object to another machine. :-P

[16:46] <TimToady> that will depend more on what nothingmuch is working on...

[16:47] <aufrank> kolibrie: thanks, that helps

[16:47] <xinming> TimToady: Just a crazy idea comes out of my mind. If we can do that, We can write a very short code and eval remotely. :-P

[16:47] <xinming> TimToady: hmm, Thanks for your explanation. ;-)

[16:47] <nothingmuch> xinming: that has lots and lots of issues  beyond serialization

[16:47] <nothingmuch> look at the E language

[16:47] <nothingmuch> for some insight on this

[16:47] <aufrank> kolibrie: which modules in perl5/ do you end up building by hand?

[16:48] <nothingmuch> suppose you have two models, thick and thin proxying

[16:48] <nothingmuch> whereby in thin proxying proxy objects on the other side are created for every local value

[16:48] <nothingmuch> and an RPC call is made for every access

[16:48] <nothingmuch> and thick proxying serializes the whole thunk and it's env and thaws it on the other side, optionally syncing back when done

[16:49] <kolibrie> aufrank: Pugs-Compiler-Perl6, Pugs-Compiler-Rule, and I'm sure there's one more...

[16:49] <nothingmuch> under the first model it's "easy" but you don't gain much

[16:49] <TimToady> the second model breaks === equivalence

[16:49] <TimToady> at least temporarily

[16:49] <nothingmuch> of course

[16:49] <nothingmuch> proxying is yucky any way you look at it

[16:50] <nothingmuch> =(

[16:50] <nothingmuch> under the second model, if you haven't instructed your compiler to remove meta data

[16:50] <nothingmuch> then it can deduce the meta object fgrom the type box

[16:50] <nothingmuch> and simply serialize that

[16:50] <nothingmuch> since it's a simple object it doesn't need to compile to a perl 6 class definition

[16:50] <nothingmuch> just a serialized representation of the finished meta object

[16:51] <nothingmuch> a perl 6 class definition could be pretty printed, of course, but that's only supported for meta class instances which can be expressed declaratively

[16:51] <nothingmuch> ?eval sub { 1 }.perl

[16:51] <evalbot_r14660> "sub \{Syn \"block\" \{1}}"

[16:52] <nothingmuch> if that is supported and the remote side trusts the local side, and will execute arbitrary code on it's behalf it should be very easy

[16:52] <xinming> thanks, I think I know, as HOW and WHICH would be useless in that case. Hope what I understand is correct. :-P

[16:52] <nothingmuch> why useless?

[16:53] <nothingmuch> .HOW is the type box meta data

[16:53] <kolibrie> aufrank: maybe that's it, looks like Pugs-Emitter-Perl6 moved in with Pugs-Compiler-Perl6

[16:53] <nothingmuch> if the object in .HOW can b e serialized

[16:53] <nothingmuch> and the meta-meta-class can be assumed to exist on the other side

[16:53] <nothingmuch> (or any n-order of meta-meta-meta) then there's no bootstrap problem

[16:54] *** mosca joined
[16:54] <nothingmuch> with these two prerequisites you can theoretically serialize any arbitrary object along with it's class for remote execution

[16:54] <aufrank> kolibrie: do you get "Warning: prerequisite Pugs::Emitter::Perl6::Perl5 0 not found." when you make Pugs-Compiler-Perl6?

[16:54] *** kanru joined
[16:54] <nothingmuch> what I doubt is not the technical feasability but the usefulness

[16:54] <TimToady> similarly for the identity expressed by .WHICH, in which case you're getting identities more of the URI persuasion

[16:55] <TimToady> though having the same .WHICH should hopefully also make some guarantees about eventual resyncing

[16:56] <TimToady> then you get into timing issues like a Palm Pilot...

[16:56] <nothingmuch> i think that is more of a per-bridge policy

[16:56] <kolibrie> aufrank: it appears to be in pugs/perl5/Pugs-Compiler-Perl6/lib/Pugs/Emitter/Perl6/Perl5.pm

[16:56] <nothingmuch> automagical remote execution that Just Works will Just Work for about 5% of the cases ;-)

[16:56] <nothingmuch> i'

[16:56] <TimToady> yeah, well, per-bridge policy is how we ended up with uucp instead of the internet...

[16:56] <nothingmuch> heh

[16:56] <kolibrie> aufrank: but it used to be a separate package

[16:57] <xinming> well, Yesterday, What my crazy idea is... We process different objects on different machine, Just pass the Whole object to the first machine, and the first machine run the object once. and then, pass the newly created object to another machine. and at last. we'll have the result return. :-)

[16:57] <xinming> hmm, well, It's just kind of dream... :-P forget it.

[16:57] <nothingmuch> *nod*

[16:58] <nothingmuch> that should be supported

[16:58] <nothingmuch> but the different mkachine must trust the first machine, or it must already know of the class the object is in

[16:58] <nothingmuch> and know it's definition

[16:58] <nothingmuch> otherwise you have security issues

[16:58] <nothingmuch> again, see the E language info

[16:58] <nothingmuch> http://www.erights.org/

[16:58] <lambdabot> Title: Welcome to ERights.Org

[16:58] <TimToady> basically you get tribal semantics where you were hoping for individual semantics

[17:00] <xinming> nothingmuch: Security issue is ignored in that case. Since, we can only see only one computer, the one which sends objects to other machine.

[17:00] <nothingmuch> ?

[17:00] <nothingmuch> are you saying that the slave machines necessarily trust the master?

[17:01] <xinming> nothingmuch: yes, the code only executes from the trusted host.

[17:01] <nothingmuch> so short answer: yes, it should Just Work to some limited extent of Work

[17:02] <nothingmuch> (e.g. breaking === semantics, synchronization,  and all the other issues related to freeze-thawing)

[17:03] <xinming> and another issue is, the dynamicly created object. So, if we pass the source to another machine, another can eval it.

[17:04] <nothingmuch> anonymous classes should also Just Work

[17:04] <nothingmuch> also classes that cannot be represented using a class { } declaration (at least not trivially)

[17:04] <TimToady> depends on how abstractly you represent "the source"

[17:04] <nothingmuch> also classes with dependencies on other (meta-)classes

[17:05] *** mosca joined
[17:05] <TimToady> C's include model is based on "the source", and breaks badly

[17:05] <TimToady> source filtering is another source-based approach that frequently breaks

[17:06] <TimToady> you'd have to treat the source as immutable, and you have to guarantee that it gets evaluated in the same context, or it means something different

[17:06] <TimToady> that's hard

[17:06] *** lumi joined
[17:07] <nothingmuch> whereas serialzing the metaclass is more in tune with the actual meaning of thje class, context free

[17:07] <nothingmuch> metaclasses instances are jsut data structures

[17:07] <nothingmuch> dinnertime

[17:07] <TimToady> assuming all the dependencies are data-driven, and not temporal

[17:08] <TimToady> showertime &

[17:08] <xinming> ...

[17:08] <xinming> bed time &

[17:09] *** justatheory joined
[17:10] *** loumz joined
[17:14] <nothingmuch> a meta class with a temporal dependency is the type of magic you shouldn't mix with magic like transparent object proxying =)

[17:20] *** stevan_ joined
[17:29] *** ruoso joined
[17:30] *** diakopter left
[17:32] *** GnuVince joined
[18:13] *** chris2_ joined
[18:22] *** dvorak joined
[18:28] *** Lorn_ joined
[18:32] *** chris2_ is now known as chris2

[18:42] *** bernhard joined
[18:47] *** cjeris joined
[18:49] <cj> could I get some comments on this, and perhaps some ideas about how to implement?

[18:49] <cj> http://cjcollier.livejournal.com/231863.html

[18:54] <ingy> hi cj

[18:54] <ingy> seen [particle]

[18:54] <ingy> seen [particle]?

[18:54] *** buetow joined
[18:58] <Debolaz> usrbinpurl seems to want references to the claim that static typing is beneficial. I didn't remove this from the article since it's not outright vandalism but it should probably be dealt with.

[18:58] <Debolaz> (Perl 6 article @ Wikipedia)

[19:19] <TimToady> you probably want to google for "gradual typing"

[19:26] <Limbic_Region> I had to re-read Debolaz's comment a few times to understand what it was that should be considered vandalism

[19:26] <Limbic_Region> it isn't that static typing is beneficial - it is that someone is asking for a reference because they don't believe it is true

[19:27] <Limbic_Region> the wp article talks about dynamic and static typing and indicates perl 6 is using hybrid

[19:27] <Limbic_Region> which is accurate

[19:27] <Limbic_Region> at least, that's the way I understand it

[19:28] <Debolaz> Limbic_Region: I didn't consider it vandalism, but the user has vandalised the page before.

[19:30] *** justatheory_ joined
[19:42] <Limbic_Region> Debolaz - all I meant was it wasn't clear WHAT was undesireable content.  It took me several passes to get your intended meaning

[19:46] *** Alchemy joined
[19:46] *** prism joined
[19:51] *** gnuvince` joined
[19:57] *** ofer0 joined
[20:00] *** vel joined
[20:07] *** TSa joined
[20:07] <TSa> HaloO

[20:18] *** thepler joined
[20:31] <audreyt> TSa: greetings

[20:31] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[20:31] <svnbot6> r14661 | audreyt++ | * Pugs.Parser.Operator: "state (...) = ..." now desugars correctly.

[20:31] <audreyt> TSa: a new object system with roles and introspection and runtime augmentation is arriving to Pugs

[20:31] <audreyt> I'm tidying it up, but it should arrive within this week

[20:32] <audreyt> once tests pass with it I'll call it 6.28.0 :)

[20:32] *** seano joined
[20:32] <cj> heya ingy

[20:41] *** beppu joined
[20:43] <audreyt> @tell cmarcelo I took your MOH and mutated into thoroughly monadic :)

[20:43] <lambdabot> Consider it noted.

[20:43] <Limbic_Region> woot - I have a project lying in wait audreyt

[20:44] <audreyt> @tell cmarcelo I'll not commit back to feather; rather, this is going into src/MO/ directly in a bit -- please put your further hacking in the main Pugs repo.  great work, btw :)

[20:44] <lambdabot> Consider it noted.

[20:47] *** ashleyb joined
[20:48] *** polettix joined
[20:49] *** statico joined
[20:57] *** crem joined
[20:59] *** eggzeck joined
[21:01] *** Limbic_Region joined
[21:04] *** beppu_ joined
[21:04] <audreyt> TimToady: dynamic defaults are not part of the default Class clas right?

[21:04] *** cmarcelo joined
[21:05] <audreyt> class C { has $.x = rand }; C.new.x === C.new.x

[21:05] <audreyt> cmarcelo: heya. I'm about to commit monadic MOH to pugs

[21:06] <cmarcelo> audreyt: ola :) nice, i waiting to see it.

[21:06] <lambdabot> cmarcelo: You have 2 new messages. '/msg lambdabot @messages' to read them.

[21:07] <cmarcelo> @moosages

[21:07] <lambdabot> audreyt said 23m 11s ago: I took your MOH and mutated into thoroughly monadic :)

[21:07] <lambdabot> audreyt said 22m 33s ago: I'll not commit back to feather; rather, this is going into src/MO/ directly in a bit -- please put your further hacking in the main Pugs repo. great work, btw :)

[21:07] <audreyt> cmarcelo: ok... I'll commit things under src/MO/, including the sketch-tests such as roles.hs

[21:17] *** DHGE joined
[21:19] <audreyt> cmarcelo: feel free to play with it: http://perlcabal.org/~audreyt/tmp/for-cmarcelo

[21:19] <lambdabot> http://tinyurl.com/yl9dem

[21:19] <audreyt> cmarcelo: I think it's all working correctly, but please sanity check before I commit it back to Pugs

[21:20] <audreyt> I'm going to dinner now; be back in a bit :)

[21:20] <cmarcelo> oka

[21:20] *** Daveman joined
[21:28] *** ashleyb joined
[21:29] <TimToady> audreyt: yes, that's correct according to current thought, use { rand } to go dynamic, and { { foo() } } to init code with a closure.  though I don't feel strongly about it if we came up with a reason and syntax to do it the other way.

[21:30] <TimToady> and after all, there's the autoclosing of s[foo] = rand on the other side

[21:32] <TimToady> but part of the reason we didn't make = autoclose is that "will first" and "will build" are intended to be be the real way to supply a closure with explicit {...} if you want that.

[21:32] <TimToady> can't quite see s[foo] will {...} though...

[21:33] <TimToady> actually, with "will build" we could just say that = is never dynamic, and throw out the magical get one .() free semantics

[21:37] <TimToady> I'm not sure we actually have a name for the time that = runs, though.

[21:38] <TimToady> has $.x = $y is something like has $.x will build { $!x = COMPOSE { $y } }

[21:40] <TimToady> where COMPOSE really means something more like OUTER, insofar as it isn't really composition time either, but when the "has" is being executed just prior to composition.

[21:42] <TimToady> has $.x will now { $tmp = $y } will build { $!x = $tmp }

[21:42] <TimToady> except with correct scoping...

[21:45] *** jferrero joined
[21:47] <TimToady> I suppose an argument could be made that declarators that run = earlier than "now" are already autoclosing, so "has" should just autoclose and run at build time.

[21:48] <TimToady> then you'd have to say "has $.x = FIRST { rand }" to get a single one.

[21:48] <TimToady> that would fit better with the autoclosing of s[foo] as well.

[21:49] <SamB> like run = "yesterday"?

[21:53] <TimToady> not sure what you're asking...

[21:57] *** Limbic_Region joined
[21:58] *** Debolaz2 joined
[21:58] *** rodi joined
[22:00] *** ashleyb joined
[22:05] <svnbot6> r14662 | lwall++ | fib memo can now use list assignment, audreyt++

[22:08] <TimToady> if we did autoclose "has=", it's an interesting question what the visibility of $r would be after

[22:08] <TimToady> has $.x = constant $r = rand;

[22:08] <TimToady> or whethe we have an anonymous syntax of

[22:09] <TimToady> has $.x = constant $ = rand;

[22:09] <TimToady> which I also wanted for (state @ = 0,1,1).[$n] //= fib($n - 1) + fib($n - 2)

[22:10] <TimToady> after all, if we allow a sig like ($,$,@), and the declarator introduces a sig...

[22:10] <TimToady> but it's currently a syntax error.

[22:14] *** larsen_ joined
[22:18] <TimToady> I'm starting to think that ={...} vs ={{...}} is a design smell.

[22:31] <cmarcelo> @tell audreyt in MO/C/Class.hs line 201, don't you want "return (name, val)"?

[22:31] <lambdabot> Consider it noted.

[22:32] *** justatheory_ is now known as justatheory

[22:38] <audreyt> cmarcelo: er, right :)

[22:38] <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.

[22:38] <audreyt> @massage

[22:38] <lambdabot> TimToady said 15h 32m 36s ago: interesting factoid: when I was profiling the "if->" patch, it came to my attention that about 90% of our current test failures are caused by that patch--seems to give

[22:38] <lambdabot> Span and Span::Num fits somehow. But it's not obvious from the failures how they're related to "if->".

[22:38] <lambdabot> cmarcelo said 6m 56s ago: in MO/C/Class.hs line 201, don't you want "return (name, val)"?

[22:39] *** davidfetter joined
[22:40] <davidfetter> seen audryt

[22:40] <audreyt> davidfetter: greetings.

[22:40] <davidfetter> hi :)

[22:40] <davidfetter> i'm in rio :) :)

[22:40] <audreyt> so where di you end up staying?

[22:40] <davidfetter> copacabana rio hotel

[22:41] <davidfetter> nsa. sra. copacabana 1256

[22:41] * audreyt is quite satisfied with le meridien :)

[22:41] <davidfetter> w00t

[22:41] <audreyt> oh, so we are close ish

[22:41] <davidfetter> i may want to move elsewhere. the internet is not so great here :P

[22:41] <davidfetter> as in it's not in my room

[22:41] <pasteling> "TimToady" at 64.0.7.8 pasted "proposed S12 patch making has= autoclose" (34 lines, 1.5K) at http://sial.org/pbot/20932

[22:41] <SamB> you have to carry it in buckets?

[22:41] <audreyt> oy. I got the hotel to relocate me to another room to get internet, also

[22:41] <davidfetter> but at least i'm not sleeping on the beach this evening :)

[22:42] <davidfetter> i'll have to change hotels to get that. the internet is 8 floors down from my room

[22:42] <davidfetter> SamB, bit buckets ;)

[22:42] <SamB> you have to carry the internet in buckets up eight flights of stairs?

[22:42] <audreyt> TimToady: I like that more. I'll model it in MOH; please checkin :)

[22:43] <SamB> how toilsome!

[22:43] <audreyt> SamB: they have buckets of pigeons

[22:43] <davidfetter> it's good exercise. maybe i'll be able to see my toes when i look down...

[22:43] <audreyt> each carrying RFC 1149 packets

[22:43] <davidfetter> i hope they won't be pigeon toes...

[22:44] <SamB> hmm. thats a new one.

[22:44] <audreyt> but having them flying around in the hotel causes trouble

[22:44] <audreyt> so they're put into buckets

[22:44] <SamB> IP over dead avian carriers?

[22:44] <davidfetter> heh

[22:44] <audreyt> no, just with contrainted mobility

[22:44] <SamB> how is that better than having a person carry a briefcase full of packets?

[22:44] <davidfetter> ah, so there's a venting & feeding spec for the buckets. ok :)

[22:45] <davidfetter> SamB, more geek cred.

[22:45] <audreyt> SamB: that wouldn't be RFC complaint

[22:45] <audreyt> I mean, compliant

[22:45] <SamB> well, wait till april

[22:45] <audreyt> and Standards is very important!

[22:45] <SamB> submit proposal for "IP over bussiness carriers"

[22:45] <SamB> or something like that

[22:46] <audreyt> . o O (IP over disease carriers)

[22:46] <davidfetter> IP over Pointy-Hairs. i like it already

[22:46] <audreyt> bird-flu-network

[22:46] <TimToady> IP over IP lawyers...

[22:46] <audreyt> TimToady++

[22:46] <davidfetter> IP/SARS

[22:46] <davidfetter> lol

[22:46] <audreyt> so you submit a patent to SYN and file a lawsuit to ACK?

[22:47] <davidfetter> audreyt, how was your flight/transit to hotel?

[22:48] <audreyt> davidfetter: flight got delayed 1hr. otherwise uneventful

[22:49] <davidfetter> i had a bizarre little while @ the hotel. they hadn't heard about my reservation.

[22:50] <SamB> IP over IP lawyers would have a patently absurd cost...

[22:51] <davidfetter> <pt_BR>legal</>

[22:51] <SamB> it would probably also take an awful lot of paper to write packets in legalese

[22:52] <TimToady> never overestimate the bandwidth of a briefcase full of legal documents...

[22:52] <davidfetter> hereinafter, notwithstanding the foregoing...

[22:53] <audreyt> TimToady: class C { has $.x = die } C.new(x=>1)

[22:53] <audreyt> won't die, correct?

[22:53] <SamB> davidfetter: how many bits was that?

[22:53] <TimToady> that is correct.

[22:53] <TimToady> has= only fires if no explicit init

[22:54] <davidfetter> 40000. at the usual rate of $500/hour, 1 hour minimum.

[22:55] <audreyt> cmarcelo: still there?

[22:55] <TimToady> $.x = die unless self.exists<$.x> or some such.

[22:56] <audreyt> cmarcelo: http://perlcabal.org/~audreyt/tmp/for-cmarcelo-2

[22:56] <lambdabot> http://tinyurl.com/y98ftz

[22:57] <audreyt> cmarcelo: I think it's correct and useful enough to go in as Pugs 6.28 :) but quick sanity check still welcome

[22:57] * audreyt works on the glueing bits

[22:57] <TimToady> hmm, if the topic is the currently initing attribute, it's almost $.x = die unless .exists;

[22:58] <audreyt> TimToady: currently it's simply merged into a (:$x =) Signature part.

[22:58] <audreyt> and let normal binding deal with it

[22:58] <audreyt> since the default clause in Signature is also autoclosing and trigger each run

[22:58] <TimToady> binding at beginning of BUILD call? or after?

[22:59] <TimToady> has to take into account that body might have $.x = 123

[22:59] <cmarcelo> audreyt: i'm here reading the changes. (btw, i'm keeping feather repo updated until you commit on pugs)

[22:59] <audreyt> has to be beginning I think, since by BUILDALL time it's all done

[22:59] <audreyt> if I understand correctly

[22:59] <audreyt> i.e. it's done in BUILD binding time, essentially

[22:59] <audreyt> and the body of BUILD is too late to change it

[22:59] <audreyt> must do it in the sig dircetly:

[23:00] <audreyt> submethod BUILD ($.x) { ... } # is fine

[23:00] <audreyt> submethod BUILD { $.x = 10 } # is too late

[23:00] *** justatheory_ joined
[23:00] <TimToady> that's when it's specced, though, or at least apo'd

[23:01] <TimToady> submethod BUILD { { user-stuff } implicit init stuff }

[23:01] <audreyt> oh hm.

[23:01] <TimToady> including all the implicit BUILDs supplied by roles

[23:02] <audreyt> that doesn't quite work on value objects...

[23:02] <audreyt> i.e. this assumes a mutable hash as layout

[23:02] <audreyt> that you can test for .exists and do overriding updates

[23:02] <TimToady> submethods can be special

[23:02] <TimToady> that's why we distinguish infrastructural methods

[23:03] <TimToady> I'm using .exists metaphorically there

[23:03] <audreyt> but within BUILD you can already call self.normal_method

[23:03] <audreyt> so that means at user-stuff time it's already a full instance

[23:03] <davidfetter> seen fglock

[23:03] <cmarcelo> audreyt: what shell magic you use to make tags file? just "find | xargs hasktags -c" isn't enough for my vim, neither sorting the tags file [some tags wont work]..

[23:03] <audreyt> or do you think tat it can be a partially-filled-in-prototype-thing ?

[23:03] <audreyt> cmarcelo: "make ghci" and then ":ctags"

[23:03] <TimToady> it's always been my assumption that BUILD should not assume a complete object in user code

[23:03] <audreyt> ghci has builtin ctags and emacstags

[23:04] <audreyt> TimToady: but $.x is a normal method

[23:04] <audreyt> only $!x is not

[23:04] <audreyt> and if we restrict BUILD to only operate on $!x then that is fine to have it incomplete

[23:04] <TimToady> which is why at one point I conjectured that submethod requires $! instead of $.

[23:04] <audreyt> since you are working on a staging-copy of the object

[23:04] <audreyt> I think it's wise, as people will be confused when we say

[23:05] <TimToady> or force $. to mean $! there, but only on known attrs

[23:05] <audreyt> "$.x inside BUILD is really $!x and too bad if you had a virtual rw somewhere"

[23:05] <audreyt> I think having $.x to force into $!x but $.x() diying

[23:05] <audreyt> is awfully inconsistent

[23:06] * [particle] agrees. SWYM trumps DWIM here

[23:06] <TimToady> it's fine by me too

[23:06] <TimToady> construction time ops on "real" object can go in "new".

[23:07] <audreyt> which means you will control BUILDALL by yourself

[23:07] <audreyt> right?

[23:07] <audreyt> if you override new, that is

[23:07] <TimToady> the default BUILDALL is completely implicit generally

[23:07] <TimToady> yes, explicit override of new

[23:08] <audreyt> so new calls bless, bless calls BUILDALL

[23:08] <TimToady> we expect people to redefine BUILD more often than BUILDALL

[23:08] <TimToady> yes

[23:08] <audreyt> and in the BUILDALL part, which visits BUILD for each segment of layout

[23:09] <audreyt> and inside that segment, the object metaclass is constrained to only contain the layout of the already-built part (i.e. its superclasses)

[23:09] <audreyt> and knows nothing about the yet-to-be-filled-in part

[23:09] <TimToady> so perhaps we allow SUPER but not self

[23:09] <audreyt> and so trying to use "self" as a full-fledged layout always fail

[23:09] <TimToady> (calls, that is)

[23:09] <audreyt> or maybe we don't have self.

[23:09] <audreyt> er, jinx.

[23:10] <audreyt> so submethod are even closer than subs this way

[23:10] <TimToady> just got through speccing that self means the newish object...

[23:10] <TimToady> self!privmeth would be okay

[23:10] <audreyt> as is SUPER and quantified calls

[23:10] <TimToady> since those are just subs

[23:10] <audreyt> ok, maybe not quantified calls

[23:11] <audreyt> but if

[23:11] <audreyt> D  is C; E is D;

[23:11] <audreyt> and in D::BUILD time we actually have a D object

[23:11] <audreyt> even if it's E.new calling it

[23:11] <TimToady> well, my first inclination is to err on the side of "enough rope"

[23:12] <audreyt> that may still work, as the layout match at that stage for D

[23:12] <audreyt> mm, what is on that side again? :)

[23:12] <TimToady> on the other hand, this is a good time to be conservative.

[23:13] <TimToady> well, if someone is willing to go the trouble of saying self.MyClass::method to get at their own methods ahead of time, we should probably let 'em.

[23:13] <audreyt> I think the problem largely goes away if SomeClass::BUILD always just see a SomeClass object as self

[23:13] <audreyt> not as in liskov but as in concrete class

[23:14] <audreyt> i.e. it's not a ChildClass-instance-being-filled-in operating under ParentClass's method table when ParentClass::BUILD is run

[23:14] <TimToady> if we just disallow $.foo where $.foo is known to be $!foo here, that's probably okay for now.

[23:14] <audreyt> but actually it's just a ParentClass instance, to be later augmented by ChildClass

[23:15] <audreyt> this is strictly inheritence-is-delegation view

[23:16] <TimToady> and maybe submethods merely carp a lot when you use $.foo where they think you should use $!foo.

[23:16] <audreyt> but you can't use $!foo to assign to your parent class's slots

[23:16] <audreyt> you have to use $.foo=

[23:17] <TimToady> that's correct

[23:17] <audreyt> even inside BUILD

[23:17] <TimToady> that's not somehting a BUILD would carp about

[23:17] <audreyt> so that use is lega

[23:17] <audreyt> legal

[23:17] <cj> audreyt: you mentioned that using mono as a runtime isn't out of the question.  What steps need to be taken to get things moving?

[23:17] <TimToady> my SUPER comment above

[23:17] <audreyt> class C { has $.x is rw }; class D is C { has $.y is rw }; class E is D { has $.z is rw }

[23:17] <audreyt> in D::BUILD

[23:18] <audreyt> $.x=1 # is fine

[23:18] <audreyt> $.y=1 # not fine; please write $!y

[23:19] <TimToady> right

[23:19] <audreyt> $.z=1 # not even possible

[23:19] <audreyt> neither is $!z possible

[23:20] *** mauke joined
[23:20] <TimToady> though probably $.z isn't caught till pet peeve time.

[23:20] <audreyt> cj: find someone to fly the #moose team and/or cmarcelo or me to the Ximian team (Boston? Utab?) :)

[23:20] <audreyt> TimToady: point is that $.z fails with "method not found"

[23:20] <audreyt> not "slot uninitialized"

[23:20] <audreyt> I think.

[23:21] <TimToady> "compatible with what?"

[23:21] <cj> audreyt: Boston

[23:21] <audreyt> TimToady: ok, I think we agree. will go make it happen at the code front :)

[23:22] <TimToady> audreyt += *

[23:22] <audreyt> TimToady: consider this:

[23:23] <audreyt> class C { has $.x is rw }; class D is C { has $.x is rw }

[23:23] <audreyt> does C::BUILD still fire and allowcate something

[23:23] <audreyt> only to be later overriden?

[23:23] <audreyt> i.e. if C is "has $.x is rw = die", it still dies

[23:23] <audreyt> I think it's consistent, and natural fallout from the algorithm above

[23:24] *** mr_ank joined
[23:24] <TimToady> makes sense

[23:24] <audreyt> nothingmuch: ^^backlog cursor^^^ TimToady ruled that Layout is determined per-class, and shadowing happens only on derived class, never globally. cheers :)

[23:25] <audreyt> TimToady: and thanks for whack it out on spec-front :)

[23:26] <audreyt> TimToady: the fun thing is that that means

[23:26] <audreyt> class C { has $.x is rw = 1; method foo { $!x } } class D is C { has $.x is rw = 2 }

[23:26] <audreyt> D.new.foo will be 1

[23:26] <audreyt> D.new(x=>9).foo will still be 1

[23:27] <audreyt> but it's probably natural.

[23:27] <audreyt> "if you write $!x you give up on extensibility"

[23:27] <TimToady> !extensible

[23:27] <audreyt> hm wait. maybe the latter case is 9 after all

[23:27] <audreyt> since C::BUILD also gets the x=>9 message

[23:28] <TimToady> true

[23:28] <audreyt> it's just the later assignment can't ever change that from outside

[23:28] <TimToady> anyway, C's methods can still get at $!x despite override

[23:28] <audreyt> but only C can do that

[23:28] <TimToady> yup

[23:29] <audreyt> which is excellent, because MP6 can represent this despite having no inheritence at all :)

[23:29] * audreyt remembers A12 said that was the plan all along.

[23:29] <TimToady> yes, well, that was one of the basic design goals, to make sure private attributes have no influence on inheritance

[23:29] <TimToady> indeed

[23:37] * aufrank takes back requests for class C { has @.x; has $.y := @.x[0] }, btw

[23:38] <svnbot6> r14663 | gnuvince++ | Added tests to t/operators/range.t to make sure that lists were forced to scalar context.

[23:41] *** shobadobs joined
[23:41] <audreyt> aufrank: hm? that is completely kosher except you have to write = $!x[0]

[23:41] <audreyt> not :=

[23:42] *** gnuvince joined
[23:42] <audreyt> and not @.x

[23:42] <audreyt> but @!x[0] should work just fine.

[23:43] <audreyt> in general you can't := to either $.x or $!x unless you have a friendly layout

[23:43] <audreyt> but p6opaque as I'm writing it is not friendly to that :)

[23:43] <aufrank> is this idea of layout defined somewhere?

[23:44] <audreyt> yes it's specced in S12 :repr

[23:44] <TimToady> A12 originally

[23:44] <aufrank> I confess I don't know when the term started springing up, but I haven't seen it until today

[23:44] * aufrank goes to look

[23:44] <audreyt> layout is nothingmuch's term

[23:44] <audreyt> it means a metaobject responsible for a representation

[23:44] <audreyt> ie. :repr is a map from string names into layout objects

[23:44] <aufrank> ok

[23:45] <aufrank> so MOH is a layout for pugs

[23:45] <audreyt> no, MOH is object model for pugs

[23:45] <audreyt> in it I define a P6opaque layout

[23:45] <audreyt> that is currently

[23:45] <TimToady> most OO systems don't let you have pluggable layout, but this is specced in A12

[23:45] <aufrank> gotcha

[23:45] <audreyt> { staticSlots :: (Array Int Object), dynamicSlots :: (HashTable ID Object) }

[23:45] <aufrank> so we could have all object as records like in OCaml if someone wrote the layout

[23:45] <audreyt> where dynamicSlots is for the rubyish case of

[23:46] <audreyt> eval " class C is also { has $!extra_field } "

[23:46] *** frankg joined
[23:52] *** mauke joined
[23:52] *** Limbic_Region joined
[23:52] *** polettix joined
[23:52] *** hexmode joined
[23:52] *** Coleoid joined
[23:52] *** kane-xs joined
[23:52] *** gantrixx joined
[23:52] *** nekokak joined
[23:52] *** mbradley joined
[23:52] *** GeJ joined
[23:52] *** wilx joined
[23:52] *** spinclad joined
[23:52] *** theorbtwo joined
[23:52] *** Khisanth joined
[23:52] *** perlbot joined
[23:52] *** knewt joined
[23:52] *** rgs joined
[23:52] *** Grrrr joined
[23:52] *** sri joined
[23:52] *** cmeyer joined
[23:52] *** lambdabot joined
[23:52] *** eviltwin_b joined
[23:52] *** Eimi joined
[23:52] *** clsung joined
[23:52] *** rafl joined
[23:52] *** Yappo joined
[23:52] *** jiing joined
[23:52] *** kalven joined
[23:52] *** tcliou joined
[23:52] *** hcchien joined
[23:52] *** revdiablo joined
[23:52] *** buu joined
[23:52] *** PerlJam joined
[23:52] *** pmichaud_ joined
[23:52] *** chip joined
[23:52] *** webmind joined
[23:52] *** plural joined
[23:52] *** leo joined
[23:52] *** audreyt joined
[23:52] *** Juerd joined
[23:52] *** wolverian joined
[23:52] *** spoop joined
[23:52] *** cognominal joined
[23:52] *** takanori_ joined
[23:52] *** takesako joined
[23:52] *** Kattana joined
[23:52] *** meppl joined
[23:52] *** tokuhirom joined
[23:52] *** aufrank joined
[23:52] *** mr_ank joined
[23:52] *** justatheory_ joined
[23:52] *** Debolaz2 joined
[23:52] *** beppu_ joined
[23:52] *** beppu joined
[23:52] *** prism joined
[23:52] *** dvorak joined
[23:52] *** woremacx joined
[23:52] *** scw joined
[23:52] *** AzureBOT joined
[23:52] *** scsibug_ joined
[23:52] *** norageek joined
[23:52] *** ingy joined
[23:52] *** nperez joined
[23:52] *** qmole joined
[23:52] *** masak joined
[23:52] *** Odin- joined
[23:52] *** araujo joined
[23:52] *** svnbot6 joined
[23:52] *** evalbot_r14660 joined
[23:52] *** integral joined
[23:52] *** cookys joined
[23:53] *** jferrero joined
[23:53] *** cmarcelo joined
[23:53] *** crem joined
[23:53] *** buetow joined
[23:53] *** cjeris joined
[23:53] *** Patterner joined
[23:53] *** kane-xs_ joined
[23:53] *** marmic joined
[23:53] *** miyagawa_ joined
[23:53] *** awwaiid joined
[23:53] *** ruz joined
[23:53] *** bennymack joined
[23:53] *** TimToady joined
[23:53] *** [particle] joined
[23:53] *** cj joined
[23:53] *** frankg joined
[23:53] *** gnuvince joined
[23:53] *** stevan_ joined
[23:53] *** idiotmax joined
[23:53] *** buubot joined
[23:53] *** rafl_ joined
[23:53] *** mugwump joined
[23:53] *** kcwu joined
[23:53] *** pjcj joined
[23:53] *** nnunley joined
[23:53] *** broquaint joined
[23:53] *** gaal joined
[23:53] *** amv joined
[23:53] *** gugod joined
[23:53] *** SamB joined
[23:53] *** arguile_ joined
[23:53] *** Shabble joined
[23:53] *** Maddingue joined
[23:53] *** pnu joined
[23:53] *** drbean joined
[23:53] *** kolibrie joined
[23:53] *** Cugel joined
[23:53] *** nipotaway joined
[23:53] *** Ikarus joined
[23:53] *** nine joined
[23:53] *** cjeris left
[23:54] <audreyt> aufrank: however, all I've said only applies if you called C.new(x=>1).

[23:55] <audreyt> if you had instead written

[23:55] <audreyt> C.bless({x=>1})

[23:55] <audreyt> then none of it apply; you can always rebind $!x happily

[23:55] <audreyt> because its layout is a Hash object that happily responds to mutable assignment.

[23:56] <audreyt> the difference between C.bless(x=>1) and C.bless({x=>1}) is a subtle one :)

[23:56] *** f0rth_ joined
[23:56] <audreyt> ( S12:497 )

[23:57] <zptao> like chicks with surprises inside?

[23:57] <audreyt> heh :)

