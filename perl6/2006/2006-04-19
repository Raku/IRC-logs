[00:00] <TimToady> perhaps not.  that's why we say "to the extent possible"

[00:00] <TimToady> certainly /foo/ ~~ /bar/ makes little sense.

[00:00] <b_jonas> so it's almost symmetrical only because it DWIMs

[00:00] <b_jonas> (I don't like DWIM)

[00:00] <TimToady> it can only DWIM when there's something fairly obvious to DWIM.

[00:01] <TimToady> The point of having a DWI

[00:01] <TimToady> M operator

[00:01] <TimToady> is to keep all the weirdness in one spot.

[00:01] <TimToady> it's a form of encapsulation

[00:02] <TimToady> whatever we decide about ~~, given/while automatically does exactly the same thing.

[00:02] <b_jonas> do you mean "when"?

[00:02] <TimToady> and any number of "match this" parameters or "where" constraints automatically fall out too.

[00:02] <TimToady> subset Odd where { $_ % 1 }

[00:03] <TimToady> that falls out of $foo ~~ { $_ % 1 }

[00:03] <b_jonas> btw, if we have smart matches, will grep do a smart match with its first argument, instead of just calling it as a function? (that's the way ruby does)

[00:03] <TimToady> Yes, that would fall out too.

[00:04] <b_jonas> nice

[00:04] <TimToady> grep Dog, @mammals

[00:05] <b_jonas> (and then we can remove the function call operator, as a function call is a smart match, and a regexp matching is a function call :)

[00:05] <TimToady> um...

[00:05] <particle_> !!! is a term, that takes an optional argument? sounds like an op to me

[00:06] <TimToady> I confess an inordinate fondness for function call syntax.

[00:06] <TimToady> it would be a prefix op, yes.

[00:06] <TimToady> in fact, pretty much an exact synonym for die.

[00:06] <particle_> right, which is what i'll code in pir for it

[00:07] <particle_> is ... also prefix? (can it take an arg?)

[00:07] <TimToady> unless it's prefix precedence.

[00:07] <b_jonas> uh. open()||!!!$!

[00:07] <particle_> make that open // !!! $!

[00:07] <TimToady> as in !$a, $b is (!$a), $b

[00:08] <TimToady> pity we don't have angly exclamation mark.

[00:08] <b_jonas> but really I think !!! and ??? are nice syntax addittions as they catch the eye

[00:08] <TimToady> wait, italic...

[00:08] <TimToady> now where did Unicode put the italic font...

[00:08] <particle_> :)

[00:09] <b_jonas> I used !! as an or operator in a language I made

[00:09] <b_jonas> is that close?

[00:09] <particle_> there's always the upside-down question mark

[00:09] <FurnaceBoy_> haha

[00:09] <b_jonas> ?? was and

[00:09] <TimToady> I'd be more inclined to use those for a ternary operator. :)

[00:09] <particle_> isn't that the same thing? :)

[00:10] <b_jonas> I don't say we should use them

[00:10] <TimToady> only if a ?? b returns a status that can be used by !!

[00:10] <TimToady> that would be rather, iconic

[00:10] <b_jonas> it was because ? and ! also had opposite significances in the language

[00:11] <TimToady> ah well, everyone's a language designer.  :-)

[00:11] *** Khisanth joined
[00:12] <b_jonas> A ? B was a conditional that tested A and if it was true, it evaluated B and jump out of the innermost set of parenthesis and make it return the value B returned

[00:13] <b_jonas> so (A; B ? ; D; *) was the equivalent of perl's {A; B and last; D; redo}

[00:14] <b_jonas> but it had the power that you could also return a value from the block which last can't

[00:14] *** ruoso joined
[00:14] <TimToady> well, a couple of days ago I proposed "last <== @retval"

[00:15] <b_jonas> and (A ? B ; C) was the equivalent of (A ? B : C)

[00:15] <TimToady> so basically ? is kind of a case operator like in infix "when".

[00:16] <TimToady> s/in/an/

[00:17] <b_jonas> um. I don't know. ? could do an if-elseif condition, but it didn't do matches. and I don't know how when operates exactly.

[00:17] <b_jonas> was it like that postfix when and prefix when was different?

[00:19] <TimToady> there is no postfix or prefix when.  there's a statement control and a statment modifier...

[00:20] *** amnesiac joined
[00:21] <b_jonas> I'll just look it up

[00:22] <b_jonas> "If the smart match succeeds, the associated closure is executed, and the surrounding block is automatically broken out of." -- yes, than it is like that

[00:23] <b_jonas> or not. I assume "broken off" means what "next" does there

[00:23] <particle_> is Y= same as ¥=?

[00:23] <b_jonas> while my "?" was rather breaking out like "last"

[00:25] <TimToady> next is meaninful only in a loop.

[00:25] <b_jonas> yes, I've read further now,

[00:25] <b_jonas> "If you have a switch that is the main block of a for loop, and you break out of the switch either implicitly or explicitly, it merely goes to the next iteration of the loop."

[00:26] <TimToady> the loop is conceptually outside the switch even if they're sharing the same braces.

[00:27] <b_jonas> so my "?" operator is more powerful, because it can be used as a loop termination condition, which is one of the points why I introduced it

[00:27] <b_jonas> I wanted to have a loop where I can have the condition at the beginning, the end, or somewhere in the middle, with only one syntax, no need for separate ones like while{} and do{}while

[00:27] <b_jonas> just like bash does

[00:28] <TimToady> sometimes people would rather have more than one construct, I've noticed. :)

[00:29] <TimToady> you can write everything with loop {...} in Perl 6 too.  But somehow I expect to see a lot of while loops yet.

[00:29] <b_jonas> and how would you jump out of that in the middle?

[00:29] <TimToady> last if condition, just like P5

[00:29] <b_jonas> well, I don't say "?" was a good idea, but I just had to experiment with it at that time

[00:30] <b_jonas> and it also made the interpreter interesting. I didn't need exceptions but I could still jump out of a loop.

[00:30] <TimToady> I've done an experiment or two in my time...

[00:30] <b_jonas> what does "your time" mean there?

[00:31] <TimToady> An "interesting" interpreter.  Sounds like a curse. :)

[00:31] <b_jonas> yep. that interpreter has "delete this;" and triple pointers

[00:32] <b_jonas> and it has triple pointers (like Foo ***var) at two places and I only understand one of them now

[00:32] <b_jonas> :(

[00:32] <TimToady> my interpreter has a few rough spots too...

[00:32] <b_jonas> well, it was a homework assignment. the point was that the professor didn't have a chance to understand it but I did.

[00:33] <b_jonas> the one I understand was because I of a tail call optimization

[00:34] <b_jonas> when the parser found a binary operator, it would normally had to parse both arguments and then create a node in the syntax tree passing both of them

[00:34] <b_jonas> but instead of that

[00:34] <TimToady> "there's nothing that can't be solved with another level of indirection...except the problem of too many levels of indirection."

[00:35] <particle_> hence, the deref operator

[00:35] <b_jonas> I parsed the first one, created a node with it, but the node constructor gave me back a pointer of where I should store the pointer to the node representing the second argument of the operand

[00:36] <b_jonas> that's two levels, the third is because C can have one return value only so I have to pass a pointer to it so that it can store the extra return value

[00:36] <b_jonas> I hope that didn't make sense

[00:36] <TimToady> well, opcode trees will drive anyone nuts.

[00:36] <TimToady> especially in C.

[00:37] <b_jonas> but I've just read the HOP and it talks about such continuation thingies at some places

[00:37] <b_jonas> it's a good book contrary to what I say

[00:38] <b_jonas> I could have used a proper parser generator like bison you know,

[00:38] <b_jonas> and then I couldn't even have thought of such hacks

[00:38] <TimToady> bison doesn't save you from that sort of thing, really...

[00:38] <TimToady> you still have to build the opcode tree yourself.

[00:38] <b_jonas> yes, it merely makes those sort of things impossible to do

[00:39] <b_jonas> it leaves no choice but to create the node after both arguments are available

[00:39] <TimToady> you will note that we're not using bison or yacc for Perl 6. :)

[00:39] <particle_> but we are for parrot

[00:39] <b_jonas> sure

[00:40] <TimToady> parrot is, in some ways, heavily optimized for running Perl 5.  :)

[00:40] <b_jonas> it would have been impractical especially because compile and runtime is mixed in perl6 and bison is difficult to use with a garbage collector

[00:40] <b_jonas> without knowing bison's inner workings at least

[00:40] <particle_> true, but that's changing (in chip's mind) right now

[00:41] <TimToady> yes, not leaking memory on a parse failure is really difficult with yacc.

[00:41] <b_jonas> and of course you couldn't customize perl6 grammar in runtime with bison

[00:41] <b_jonas> hmm. optimized for running Perl 5? I didn't see that.

[00:42] <particle_> perl5 begat topaz begat parrot

[00:43] <TimToady> it's just sort of natural--most of the parrot programmers know a lot more about Perl 5 than Perl 6, so it's kind of unconscious

[00:45] <TimToady> but it's been getting better, particularly as we do a better job of actually saying what Perl 6 *is*...

[00:46] <particle_> the new generation of compiler tools (pge, tge) are making hll development much easier

[00:47] <TimToady> The pugs implementation has done a wonderful job of flushing out a lot of the implicit P5isms of the P6 design.  It's just there's some natural latency in that whole process.

[00:48] <particle_> there's much less latency now than there was a few years ago

[00:48] <TimToady> The nice thing about flushing out the implicit P5isms is that then we can look at them and decide which ones were good ones and which ones were not so good.

[00:49] <b_jonas> uhum

[00:49] <TimToady> yes, a lot of us have been trying very hard to make that happen. :)

[00:50] <TimToady> communities naturally tend to diverge unless there is a core of people who are actively working toward making them converge.

[00:51] <particle_> speaking of convergence... off to a perl meeting. cya!

[00:52] <TimToady> ciao. and yes Y is yen.

[00:54] <b_jonas> good night, everyone

[01:12] *** Quell joined
[01:22] <TreyHarris> note to any trainers out there: do not try to teach /m in the same class in which you introduce regexes.  poor students' heads explode.

[01:29] *** karjala joined
[01:31] *** Quell joined
[01:37] *** hlen joined
[01:42] <TimToady> Hmm, I wonder if ^^ and $$ will fare better?

[01:46] <pmichaud> so far they seem to work okay

[01:47] *** qu1j0t3 joined
[01:49] <pmichaud> well, I finally have the pge parser able to deal with whitespace, postfix, long dots, { } terms in <if>, statement modifiers, and all of the other fun quirks of this language.  :-)  pairs are probably next.

[01:52] <TimToady> I mean whether ^^ and $$ will make people's heads explode if explained in the same class that regexes were introduced...

[01:54] <pmichaud> right... when I described perl6 rules to dfw perl mongers last year, the heads exploded on far more than ^^ and $$.  Most people could grok ^^ and $$ w/o problem (or maybe they were just too far gone by then to care)

[01:58] <TimToady> commuting &

[02:04] <svnbot6> r10036 | audreyt++ | * pmichaud requested a Junction-free Test.pm, and here it is.

[02:12] *** chovy joined
[02:12] <chovy> audreyt:

[02:13] <audreyt> mm?

[02:17] <audreyt> chovy: ?

[02:22] <svnbot6> r10037 | audreyt++ | * librules: more optable node slots and API mockups.

[02:23] *** jserv-- joined
[02:44] *** r0nny joined
[03:14] *** FurnaceBoy_ joined
[04:05] *** mako132_ joined
[04:28] *** nirgle joined
[04:33] *** qu1j0t3 joined
[05:12] *** iblechbot joined
[05:23] <ayrnieu> pmurias - it doesn't seem that you ever understood me.  I: don't want Q.  Hate Q.  Am totally glad that vim does not support it.  100%.  Am irritated by !vim's support if it.

[05:28] *** Blicero_ joined
[05:31] *** rgs joined
[05:37] *** xinming joined
[06:03] *** Frances joined
[06:27] *** marmic joined
[06:28] *** Soga joined
[06:51] *** KingDiamond joined
[07:05] *** lypie joined
[07:05] *** iblechbot joined
[07:10] *** LCamel joined
[07:37] *** Aankhen`` joined
[07:53] *** KingDiamond joined
[07:55] *** Toaster joined
[08:03] *** drrho joined
[08:17] *** Aragone is now known as Arathorn

[08:17] *** Alias_ joined
[08:18] * Alias_ stomps in

[08:18] <Alias_> seen TimToady?

[08:18] <jabbot> Alias_: TimToady was seen 6 hours 20 minutes 11 seconds ago

[08:20] * Arathorn reads the Captures FAQ and looks petrified

[08:21] <Arathorn> whilst i can see how it might be useful to have a nice OO way of passing around arguments to functions/methods, complete with the invocant

[08:21] * Alias_ has visions of JavaScript

[08:21] <Arathorn> i'm failing to see how you'd use it elsewhere - especially in the context of Rules capturing, which seems to be obliquely hinted at but never explained

[08:22] <Arathorn> you mean the 'arguments' keyword/pseudovariable/thing?

[08:22] <Alias_> Well, the fact that "this" sort of can follow you around

[08:22] <Arathorn> ah, yeah

[08:22] <Alias_> everything is a Function

[08:23] <Alias_> Except that every Function has an invocant

[08:23] <Alias_> Which means everything is a Method, except you never say so

[08:24] <arcady> huh?

[08:24] <Alias_> EXACTLY!

[08:24] <arcady> I though invocant is optional

[08:24] <arcady> says so in the capture FAQ, at least

[08:24] <arcady> "at most one"

[08:24] <Arathorn> but when you do $foo = \$bar, you're assigning $bar into the invocant slot of the $foo capture, right?

[08:25] <Arathorn> s/assigning/binding/

[08:25] * Arathorn really doesn't understand why such a seemingly obscure feature merits the huffman of $$foo and $foo syntax

[08:25] *** p5evalbot joined
[08:25] <arcady> because it does the things that were done by those syntaxes in perl 5

[08:26] <arcady> or something like that

[08:26] *** buu is now known as p5evalbot

[08:26] <Arathorn> except you'd no longer use it for compound data structures

[08:27] *** p5evalbot is now known as buu

[08:27] <Arathorn> and you have the := operator to bind things together by reference

[08:28] <arcady> yes

[08:28] <Arathorn> so having "removed references from perl6", why do you still need $ and \? (other than to totally confuse migrating perl5 programmers)

[08:28] <Arathorn> esp. given that they're not actually syntactic sugar for := style binding magick

[08:29] <Arathorn> but a totally different structure under the hood

[08:29] <arcady> binding is not references though

[08:29] *** p5evalbot joined
[08:29] <arcady> and, superficially, it does seem to work like references

[08:30] <arcady> when you do $foo = \$bar, you assign to $foo a reference with the invocant bound to $bar

[08:30] * arcady actually is just pretending that he knows what he's talking about

[08:30] <Arathorn> i guess my problem is, then, that I can't see a scenario where you'd ever want to do that, given binding and compound DSs not needing refs

[08:31] <Arathorn> and that passing args into a function/method by reference happens by reference by default (by means of read-only proxies)?

[08:31] <Arathorn> unless you say 'is rw', or 'is copy' for that particular arg

[08:32] <Arathorn> anyway, this kind of confusion is prolly not conducive to the channel's (or my) wellbeing at this time of day

[08:32] * Arathorn applies coffee :/

[08:32] <arcady> by binding to readonly variables, or something like that

[08:33] *** p5evalbot joined
[08:33] <Arathorn> right. so when would you ever want to $foo = \$bar in practice?

[08:33] <Arathorn> or is it just one more way to accomplish something like binding, but with a user-accessible capture object you can then play with?>

[08:35] <arcady> in practice? doesn't seem too useful

[08:35] <arcady> though maybe $foo = \@bar might be more so

[08:35] <Arathorn> heh

[08:36] * Arathorn can't see why, other than to tempt you to start writing $foo->[$baz] :)

[08:38] <arcady> you can't even do that

[08:38] <arcady> you can, however, do $foo[$baz]

[08:39] <Arathorn> hm, surely that should be $$foo[$baz]

[08:39] *** elmex joined
[08:39] *** Alias_ left
[08:39] <Arathorn> or can you apply the [] to a capture object directly?

[08:40] <arcady> yes, I think you can

[08:41] <arcady> wait. no, not like that

[08:41] <arcady> it would indeed have to be $$foo[$baz]

[08:42] <Arathorn> well, i guess it does provide some kind of quasi-perl5 syntax for newbies to hang themselves with

[08:43] <Arathorn> and allows you to decorate all the capture nodes with arguments if you felt the urge

[08:43] * Arathorn boggles

[08:43] <arcady> I think it's best to wait around for someone who actualy knows what all of it is for

[08:43] <Arathorn> fair enough :)

[08:43] <arcady> then all will be made clear

[08:44] <Arathorn> thanks for bouncing ideas, all the same...

[08:44] <arcady> they're bouncing too much in my head. time to sleep I think.

[08:56] <Arathorn> night

[09:10] *** nicbrown joined
[09:17] <lypie> nothingmuch: you should mail me again daily until i do that thing btw :P

[09:17] * lypie is such a lazy !@#@

[09:20] *** nicbrown joined
[09:32] <lypie> audreyt: the new capture rules noted on the blog are interesting

[09:32] * lypie debates replying to article rather than using irc

[09:35] <Arathorn> post a link if you comment on the blog rather than chat in here

[09:35] <Arathorn> as i also find the capture semantics interesting

[09:35] <Arathorn> interesting in a terror-inducing kinda way

[09:35] <lypie> if i were to comment it would be on the pil2 nodes rather than capture

[09:35] <lypie> lol

[09:36] *** dakkar joined
[09:38] * lypie wonders what string-buffer-fragments are and if they are in any way related to cords

[09:38] <Arathorn> fair enough

[09:39] <integral> lypie: I believe the answer to the second bit is: "Yes"

[09:39] <lypie> integral: very neat

[09:39] <lypie> cords rock

[09:40] *** macroron joined
[09:40] <integral> yeah.

[09:57] *** Soga joined
[09:58] *** KingDiamond joined
[10:03] *** frederico joined
[10:04] *** xinming joined
[10:09] *** GeJ joined
[10:09] <GeJ> hello folks

[10:11] <GeJ> is there any freebsd user around? with the latest firefox version if possible.

[10:11] <Grrrr> yes

[10:12] <GeJ> Mr. Grrrr... nice to see you.

[10:12] <Grrrr> well, with firefox-1.5.0.1_2,1, I have not updated to the latest yet

[10:12] <audreyt> TimToady: does @ signify integer keys, or orderedness?

[10:12] <xinming> GeJ: I know audreyt use Freebsd...

[10:13] <audreyt> TimToady: i.e., is @foo['moose'] more blasphemic or is %bar.keys.[0] more so?

[10:13] <audreyt> i.e., if I have an ordered mapping from objects to objects, is that @ or %?

[10:13] <GeJ> hum, ok. it's just that I bumped into a firefox crash while looking at audrey's http://www.pugscode.org/osdc/pugs.xul

[10:14] <GeJ> Hello audrey, Happy Birthday btw :)

[10:14] <audreyt> thanks! :)

[10:14] <lypie> good reminder ;)

[10:14] <GeJ> the crash happens after the slide "Pugs is..."

[10:14] *** lichtkind joined
[10:14] <lypie> happy birthday audreyt :)

[10:15] <lypie> GeJ: my firefox also really dislikes it

[10:15] <lichtkind> hey :)

[10:15] <lichtkind> ?eval d:{1}; goto d;

[10:16] <GeJ> lypie: thanks...

[10:16] *** evalbot_10031 is now known as evalbot_10037

[10:16] <evalbot_10037> Error: No such method in class Block: "&d"

[10:16] <GeJ> lypie: distro?

[10:16] <lypie> GeJ: debian?

[10:16] <lypie> hehe

[10:16] <lypie> working for me this time around

[10:16] <GeJ> ok, so it maybe a FF issue and not only a FreeBSD one

[10:17] <GeJ> hum...

[10:17] <lichtkind> ?eval do{ return 1; 2;};

[10:17] <evalbot_10037> Error: cannot cast from VUndef to Pugs.AST.Internals.VCode (VCode)

[10:17] <lypie> GeJ: firefox on debian is heavily patched, its unstable and crap

[10:17] <lichtkind> ?eval do{ 2;};

[10:17] <lypie> (where crap == it doesn't get rendering right in many instances due to non upstream patch sets)

[10:17] <audreyt> try reload

[10:17] <evalbot_10037> 2

[10:17] <Grrrr> GeJ: works here - but it really depends on the extensions you have, I would imagine

[10:17] <audreyt> see if it works better

[10:18] <lichtkind> happy birthday audrey

[10:18] <audreyt> (also space key should now work if you reload again)

[10:18] <audreyt> lichtkind: thanks :))

[10:21] <GeJ> 'The application 'Gecko' lost its connection to the display :0.0;'

[10:21] <GeJ> 'An exit code of 1 was returned by firefox'

[10:21] <GeJ> Well, time to add debug symbols...

[10:22] <lypie> hehe

[10:22] <GeJ> sorry for the noise.

[10:25] <Arathorn> audreyt: if you have a second to glance over my confusion at http://colabti.de/irclogger/irclogger_log/perl6?date=2006-04-19,Wed&sel=120#l188 and elucidate for the masses, it'd be hugely appreciated

[10:29] <lypie> audreyt: wrt pugs.xul, the perl5 example code with hash access -> the thing i hated most about p5

[10:30] <audreyt> Arathorn: sec...

[10:30] <audreyt> ok. the question was why \ and $ warrante 1 char.

[10:30] <Arathorn> yup.

[10:30] <audreyt> I can defend \ much easier than $ so I'll do thatfirst.

[10:33] <audreyt> the motivation for \ is no longer complex data structures

[10:33] <audreyt> but rather reusable argument lists

[10:33] <Arathorn> right - and presumably not function/method calling by deference either, given you have read-only proxies by default, and 'is rw' and 'is copy'

[10:34] <Arathorn> okay - why would I ever want to reuse argument lists in practice? (if i weren't writing a dispatcher of some kind)

[10:34] * Arathorn was hoping/assuming that the answer was something to do with how Captures would be used by Rules, but can't seem to find any info apart from rather oblique hints ;)

[10:35] <audreyt> Captures are superclasses of Match

[10:35] <audreyt> so all Rule application return captures.

[10:36] <Arathorn> is the invocant slot used on the Capture objects which get returned?

[10:36] * Arathorn tries to work out what it'd mean to  one of them

[10:36] <audreyt> yes. to wit

[10:37] <audreyt> my $rv = ("x-y-z-moose" ~~ /(.)-(.)-(.)-<animal> :{ return *$/ })

[10:37] <audreyt> er

[10:37] <audreyt> my $rv = ("x-y-z-moose" ~~ /(.)-(.)-(.)-<animal> :{ return give_birth(*$/) })

[10:37] <audreyt> many things happen here

[10:38] <audreyt> give_birth gets 'x','y','z' as positional args

[10:38] <audreyt> and :animal<moose> as named

[10:38] <audreyt> so far so good?

[10:38] <Arathorn> yup, with you

[10:38] <audreyt> it can return a Moose object

[10:38] <audreyt> now $rv has the same positionals and named slots

[10:38] <audreyt> and its invocant slot becomes that Moose object

[10:38] <audreyt> makes sense?

[10:39] <Arathorn> yes, it does.

[10:39] <audreyt> now you can get back the Moose by saying

[10:39] <audreyt> $rv as Animal

[10:39] <Arathorn> presumably nested captures then become nested Captures within positional slots in the master Capture?

[10:39] <audreyt> yes.

[10:39] <audreyt> that's the idea.

[10:39] <audreyt> so you can * into them

[10:40] <audreyt> if you want to retrieve some of them as args to other funcs.

[10:40] <Arathorn> ah ha!

[10:40] <audreyt> this is all here to do what TGE does

[10:40] <audreyt> (and more)

[10:40] * Arathorn has his 'ah ha!' moment

[10:40] <audreyt> in a natural Perl6 syntax

[10:40] <audreyt> so we can manipulate trees very easily

[10:40] <lypie> Arathorn: hehe

[10:40] <audreyt> since Capture is also the natural data type for XML elements.

[10:40] <audreyt> or other annotated nodes with children.

[10:41] <audreyt> so they should be unified, and the way to introduce literal of that kind is \().

[10:41] <audreyt> another sugar is &func\(1,2,3)

[10:41] <audreyt> which is &func.assuming(1,2,3)

[10:41] <audreyt> which would make haskell people envious

[10:41] <audreyt> as this can assume into nameds as well.

[10:42] <audreyt> so, imagine this as somewhat of our answer to Erik Meijer and his XML literals ;)

[10:42] <gaal> whee, that's new isn't it?

[10:42] <audreyt> (and native tree manipulations)

[10:42] <Arathorn> yup, that makes a whole lot more sense now

[10:42] <lypie> umm...

[10:42] <audreyt> gaal: it's been around before I requested the p6l commit mailing

[10:42] * lypie gets the idea that he really should be reading this

[10:43] <dakkar> I really look forward to a Captures-based DOM-like tree

[10:43] <audreyt> Arathorn: your can also think that Rules become XSLT and binding become XQuery and deref+casting become XPath

[10:43] <gaal> so is positional-named figured out?

[10:43] <audreyt> but I prefer not to think that unless neccessary.

[10:43] <audreyt> gaal: positional-named?

[10:43] <gaal> audreyt: <doc><e/></e><e/></doc>

[10:44] <audreyt> oh that. probably named "e" contains a simple Tuple

[10:44] <gaal> s,/e,e/,

[10:44] <wolverian> audreyt, whoa. I _really_ like &foo\(1, 2, 3). now figure out a way to fit that in with $obj.foo method call syntax :)

[10:44] <audreyt> of three empty captures

[10:44] <audreyt> that what Match is done now with

[10:44] <audreyt> /<moose>+/

[10:44] <audreyt> it's cheap and cheerful, so why not.

[10:45] <audreyt> Arathorn: if you have some cycles to add some part of it -- or refactor altogether -- into Capture.pod that'd be lovely.

[10:45] <lichtkind> audreyt sorry but whats all about that running gag with moose?

[10:45] <audreyt> lichtkind: I have no idea.

[10:45] <audreyt> it's all gaal's fault.

[10:45] <lypie> bacon

[10:45] <lypie> aw, damn irssi and its unliner!

[10:45] <audreyt> he is the archlambdamoose that brainwashed us all

[10:46] *** Barry joined
[10:46] <audreyt> by using moose in every examples during OSDC.il hackathon

[10:46] <audreyt> (and then some.)

[10:46] <Arathorn> audreyt: sure, will do

[10:46] <Arathorn> "Captures are a fundamental class for expressing annotated nodes with children, such as rules captures, argument lists, XML nodes, etc." sounds like it should make its way into Capture.pod somewhere near the top

[10:46] <gaal> moose is the new orange...

[10:47] <lypie> where can i find more docs on this &foo\(1,2,3) syntax?

[10:47] <audreyt> Arathorn: sure... just commit :)

[10:47] <lypie> as in, whats foo? :)

[10:47] <GeJ> audreyt: some recent statistics based on #perl6 logs tend to prove that gaal is not the only one in the moose/elk conspiracy.

[10:47] <GeJ> nm is as much (if not more) guilty as him

[10:47] <audreyt> hm, strangely

[10:48] <audreyt> S06 doesn't have the &foo\() form anymore

[10:48] <gaal> GeJ: that merely exhibits the difference between activism and activatism.

[10:48] * audreyt reads the log

[10:48] <Barry> Is this logged somewhere?

[10:49] <audreyt> Barry: irc.pugscode.org

[10:49] <Barry> How about #perl?

[10:50] <audreyt> not sure

[10:50] <GeJ> Barry: http://colabti.de/irclogger//irclogger_logs/perl6

[10:50] <audreyt> oh, it's in S02.

[10:50] <audreyt> postcircumfix:<\( )>

[10:51] <audreyt> With multiple dispatch, C<&foo> may not be sufficient to uniquely name a

[10:51] <audreyt> specific function.  In that case, the type may be refined by using a

[10:51] <audreyt> signature literal as a postfix operator:

[10:51] <gaal> wicked cool

[10:51] <audreyt>     &foo:(Int,Num)

[10:51] <audreyt> It still just returns a C<Code> object.  A call may also be partially

[10:51] <audreyt> applied by using an argument list literal as a postfix operator:

[10:51] <audreyt>     &foo\(1,2,3,:mice<blind>)

[10:51] <audreyt> so, .variants and .assuming each get onechar huffman

[10:51] <audreyt> somehow I think that's a good call :)

[10:51] <wolverian> hrm, to get a bound method object, I do '&Class::meth\($obj:);', right?

[10:52] <audreyt> wolverian: yes

[10:52] <wolverian> I still wish that was prettier. oh well. :)

[10:52] <audreyt> $obj.meth\();

[10:52] <audreyt> is better

[10:52] <wolverian> nooooo, does that work?!

[10:52] <audreyt> that is speculative.

[10:52] <wolverian> hrm. now I'm feeling torn. the \ is rather hidden there

[10:52] <audreyt> $obj.can('meth')\();

[10:53] <audreyt> is perhaps better

[10:53] <audreyt> $obj.can('meth')\($obj); # I mean this

[10:53] <wolverian> \($obj:)?

[10:53] <audreyt> no

[10:53] <audreyt> one arg is always imnplicit inv

[10:53] <audreyt> close $fh;

[10:53] <wolverian> oh. okay.

[10:53] <audreyt> close $fh:;

[10:53] <audreyt> same thing

[10:53] <wolverian> right

[10:53] <wolverian> makes sense

[10:53] <gaal> {$obj.meth(*@_,*%_)}   ?

[10:54] <audreyt> ->\$_{$obj.meth(*$_)}

[10:54] <wolverian> gaal, I was hoping for real partial application.. :)

[10:54] <gaal> we don't have autocurrying either...

[10:54] <gaal> ah, -> \$_ is neat

[10:55] <gaal> though i'm not sure why it should work

[10:55] <audreyt> why not?

[10:55] <gaal> patmatch?

[10:56] <audreyt> \$x in arglist captures all remaining stuff into a Capture

[10:56] <audreyt> I mean paramlist.

[10:56] <audreyt> I mean Signature. (darn)

[10:56] <gaal> huh, okay

[10:56] <gaal> {$obj.meth(*$^a)}    ? :)

[10:57] <Arathorn> is Signature a superclass of Capture, then?

[10:57] <audreyt> gaal: no that's positional

[10:57] <audreyt> no.

[10:57] <audreyt> Arathorn: these two are not at all related.

[10:57] <audreyt> class-wise

[10:57] * Arathorn tries to understand why (1,2,3,:mice<blind>) describes a signature rather than an argument list

[10:57] <audreyt> it descrives an argument list.

[10:57] <audreyt> it has nothing to do with signature!

[10:57] <audreyt> the mice<blind> is currying

[10:57] <audreyt> (afk, brb...)

[10:58] <wolverian> is --> a part of it?

[10:58] <audreyt> part of Signature?

[10:58] <Arathorn> oh, because it identifies the correct method based on the example argument list?

[10:58] <wolverian> audreyt, right, or Capture

[10:58] <audreyt> you can't say --> in Capture literals.

[10:58] <audreyt> in Signature, opinions differ on whether it's a type constructor (which I think it is)

[10:59] <audreyt> or just shorthand to attach two Signatures to one Sub, one for in and one for out.

[11:00] * dakkar is away: pranzo

[11:01] <audreyt> Arathorn: now, justifying $.

[11:02] <audreyt> if something can sensibly contain a distinguished, potentially lvalue, object

[11:02] <Arathorn> purely for symmetry so that people can use it a bit like perl5?

[11:03] <audreyt> then that something can define "as Scalar", which is what $ calls.

[11:03] <audreyt> same way that +$foo calls $foo's "as Int".

[11:03] <Arathorn> ok

[11:04] <Arathorn> doesn't $ just return the invocant slot of the Capture object, though?

[11:04] <audreyt> that is what Capture defaults its "as Scalar".

[11:04] *** TimToady joined
[11:05] <audreyt> granted, it is somewhat difficult to imagine other uses for it

[11:05] <Arathorn> ah, right

[11:06] <audreyt> however, the term $() means $($/)

[11:06] <audreyt> I mean, the prefix $ defaults to CALLER::<$/>

[11:06] <audreyt> as @() and %()

[11:06] <wolverian> wait.. we're stealing AJAX too now? :)

[11:07] <theorbtwo> So $($foo) and $$foo mean completely different things?

[11:07] <audreyt> theorbtwo: no, completely the same thing.

[11:07] <audreyt> +($foo) vs +$foo.

[11:07] <audreyt> wolverian: I think "Str as Scalar" is not defined

[11:08] <audreyt> but you can define it as

[11:08] <audreyt> "document.getElementById($?SELF)"

[11:08] <audreyt> and write $("moose)"

[11:08] <audreyt> er $("moose")

[11:08] <audreyt> in your program

[11:08] <wolverian> oh, we're adhering to the DOM? great!

[11:09] <audreyt> whether it will make Perl6 a better Rails DSL platform remains to be seen ;)

[11:09] <Arathorn> that's rather sexy

[11:10] <audreyt> rather insane too :)

[11:11] <audreyt> so, to summarize, I think prefix sigil casters are not as useful as circumfix \() and :()

[11:11] <audreyt> they are sugary for various misc. purposes

[11:12] <audreyt> and fit the general feeling of prefix casters

[11:12] <audreyt> + ~ ?

[11:12] <xinming> and can :-) be prefix?

[11:12] <audreyt> but if there are better uses for them, I wouldn't mind losing them

[11:13] <audreyt> maybe. :)

[11:14] <theorbtwo> xinming: If you want to define it, sure... I think.  Make sure you let it be :) too, though, or you'll confuse people...

[11:14] <xinming> hmm, If so, I think we might be able to write a macro to replace :-) into $, and then... We will work happily every day...

[11:14] <lichtkind> ?eval do{ return 2; 1;}

[11:14] <audreyt> I'd suggest using the unicode symbol

[11:14] <evalbot_10037> Error: cannot cast from VUndef to Pugs.AST.Internals.VCode (VCode)

[11:14] <audreyt> U+263A U+263B

[11:15] <audreyt> lichtkind: here I get

[11:15] <audreyt> pugs> do{ return 2; 1;}

[11:15] <audreyt> *** cannot return() outside a subroutine

[11:15] <audreyt> I don't know why evalbot is confused.

[11:15] <lichtkind> thanks audrey

[11:15] <xinming> lichtkind: IIRC, you should use leave instead of return. :-)

[11:15] *** nirgle left
[11:16] <lichtkind> ximming but leave leaves no return values :)

[11:16] <Arathorn> is $("moose") equivalent to %($/)<moose>?

[11:17] <Arathorn> uh, $($/)<moose> even

[11:17] * Arathorn tries to work out where the literal "moose" actually goes

[11:17] <xinming> lichtkind: eg...  my $a; $a = do loop (;test_statement;) { };

[11:17] <audreyt> Arathorn: nonono

[11:17] <audreyt> Arathorn: $("moose") is just that.

[11:17] <audreyt> prefix:<$>("moose")

[11:17] <audreyt> the only thing here is that

[11:17] <audreyt> $()

[11:17] <audreyt> means

[11:17] <xinming> lichtkind: LW said it we should use leave to return the value...

[11:17] <audreyt> $($/)

[11:18] *** kane_ joined
[11:18] <audreyt> by virtue of a default argument

[11:18] <xinming> lichtkind: because if we use return, It will exit the sub...

[11:18] <Arathorn> oh!

[11:18] <xinming> hmm, not sub, the block...

[11:18] <Arathorn> so you're making a method call to the invocant of $/, with "moose" as a single positional arg?

[11:18] <audreyt> supposedly you can use leave with return values

[11:18] <Arathorn> invocant in $/, even

[11:19] <audreyt> leave Block <== 1,2,3;

[11:19] <audreyt> but nobody would be on the other side to receive 1,2,3

[11:19] <audreyt> so there's little point.

[11:19] <lichtkind> xinming now i understand but do blocks you cannot leave prematurly?

[11:19] <audreyt> Arathorn: sorry.

[11:19] <theorbtwo> $() means $$/.  $('foo') is infix:as('foo', ::Scalar).  $/<foo> is postcircumfix:{"<",">"}($/, 'foo').

[11:19] <audreyt> $(ANYTHING) means just that.

[11:19] <audreyt> $() means $$/ only when there is nothing.

[11:20] <clkao> what is $/ ? i assume it's diffferent from perl5

[11:20] <xinming> lichtkind: perl can goto hell; :-)

[11:20] <audreyt> proto prefix:<$> ($thing? = CALLER::<$/>)

[11:20] <audreyt> clkao: it is something I'd like to see renamed to $?MATCH but not getting it :)

[11:20] <xinming> lichtkind: hmm, I mean use goto...

[11:20] <theorbtwo> clkao: It's the container of perl5's $1..$n, and the like, and such, and soforth.

[11:20] <lichtkind> xinming hehe yeah but thats seems the only option :)

[11:21] <audreyt> clkao: it is the previous result of ~~ against rules.

[11:21] <audreyt> usually a Match object, which isa Capture object.

[11:21] <xinming> lichtkind: No, there are other choices.

[11:21] <xinming> lichtkind: I think leave is for this purpose maybe...

[11:21] <lichtkind> lichtkind: perl can goto hell; :-)

[11:21] <lichtkind> shit

[11:22] <wolverian> $perl->can(goto => "hell")

[11:22] <audreyt> theorbtwo: actually I suspect that $/<foo> is postcircumfix:{'{', '}'}($/, 'foo')

[11:22] <theorbtwo> You can do sub {...}->() instead of do{...}, and get full sub semantics.  Er, in perl5, that is.

[11:22] <audreyt> theorbtwo: and there is a macro postcircumfix:{'<', '>'} that rewrites the call.

[11:22] <theorbtwo> audreyt: Er, right.  Whoops.

[11:22] <lypie> ruby.can(keep_being=>:really_slow);

[11:22] * xinming thinks he should use perl 6 can goto hell...

[11:23] <audreyt> lypie: I hear that YARV is fast

[11:23] <xinming> lichtkind: http://dev.perl.org/perl6/list-summaries/2006/p6summary.2006-02-07.html

[11:23] <theorbtwo> xinming: Return always returns from the innermost block with the word "sub" at the beginning.  leave returns from the innermost thing that can return... I think.

[11:23] <lypie> audreyt: its not

[11:23] <audreyt> too bad ;)

[11:23] <lypie> audreyt: based on the benches and on the theory. it can never be fast

[11:23] <lypie> still just "an interpreted language"

[11:23] <xinming> theorbtwo: yes, that's what I think also.  :-)

[11:23] <audreyt> but it's not YARV's fault by rather VALUE*'s

[11:24] <lypie> audreyt: yarv can't even perform inlining

[11:24] <lypie> without inlining there is no such thing as performance :)

[11:24] <audreyt> I thought it has AOT _and_ JIT

[11:25] * Arathorn battles his mental block in the hope that it may help anyone else solve the same mental block...

[11:25] <Arathorn> so $("moose") just returns $moose?

[11:25] <audreyt> no.

[11:25] <Arathorn> meh - sorry :(

[11:25] <audreyt> $("moose") is an error ;)

[11:25] <lypie> audreyt: /join #yarv

[11:25] <lypie> oops

[11:25] <lypie> audreyt: sorry. ignore that

[11:25] <audreyt> I'm already there :)

[11:26] <Arathorn> ah.

[11:26] <lypie> that was what /i/ am pmeant to do :P

[11:26] <lypie> s/pm/m/

[11:26] * lypie gives up

[11:26] <theorbtwo> Assuming you don't define it to do something else, that is.

[11:26] <lypie> coffee time?

[11:26] <audreyt> $("moose") means casting a string into a Scalar

[11:26] <audreyt> which isn't really interesting or possible, as a string really doesn't have a scalar storage somewhere in it

[11:26] <audreyt> it can of couse be defined to return itself

[11:26] <audreyt> essentially making it a shorthand for scalar("moose")

[11:27] <audreyt> but I think that's confusion.

[11:27] <audreyt> so, an error is probably saner.

[11:27] <audreyt> but if you supply a definition

[11:27] <audreyt> so that it returns (say) an AJAX snippet

[11:27] <audreyt> then that's fine ;)

[11:27] <theorbtwo> Or it could be defined to do CALLER::$($argument), if you wanted to be evil.

[11:27] <audreyt> yes, or that.

[11:28] <audreyt> but thankfully you need to "env $moose"

[11:28] <audreyt> otherwise it's not visible without runtime-specific backdoor functions

[11:28] <audreyt> (which I'm sure will exist.)

[11:28] <lypie> audreyt: i dislike the basic premise of writing a new runtime in anything other than the dest lang

[11:29] <theorbtwo> lypie: You think assemblers should only be written in machine language?

[11:29] <audreyt> lypie: that line of thinking usually only applies to languages that can be optimized statically.

[11:29] <audreyt> like, writing perl5 interpreter with perl5 is insane.

[11:29] <audreyt> and metacircular scheme interpreters isn't really popular in production.

[11:30] <xinming> lypie: the first assembler is written in machine language... and after that, we can use the tools "people" invented...

[11:30] <lypie> xinming / theorbtwo: i grok this. sorry

[11:31] *** b_jonas joined
[11:31] <lypie> audreyt: maybe i'm just a dreamer :) until i've failed i can't bare to think its not possible

[11:31] <xinming> what does grok mean BTW. :-)

[11:31] <lypie> xinming: understand, but at a deep level

[11:32] <xinming> lypie: thanks

[11:32] <lypie> xinming: http://www.urbandictionary.com/define.php?term=grok

[11:32] <audreyt> it stands for "gestalt resonance of knowledge"

[11:32] <audreyt> (or maybe not.)

[11:32] <lypie> (that makes sense)

[11:33] <audreyt> afk for real. bbiab

[11:35] <b_jonas> also in the jargon file: http://www.science.uva.nl/~mes/jargon/g/grok.html

[11:35] <lypie> nice ref

[11:35] * lypie hasn't read that for years

[11:37] <lypie> audreyt: what i recall of yarv was that there was not yet aot/jit. tho i'd really love a correction to be honest...

[11:37] * lypie also goes "afk" (aka, working)

[11:42] * dakkar is back (gone 00:42:01)

[11:45] <audreyt> TimToady: can we get := becoming statement level?

[11:45] <audreyt> nested := introduces parsing ambiguities.

[11:45] <audreyt> \$x := \$y := $z

[11:45] <audreyt> *@x := *@y := @z;

[11:46] <audreyt> TimToady: desugaring two special forms from one text chunk neccesitates saving-buffer-then-parse-twice

[11:46] <audreyt> something that is unnatural in p6

[11:47] <audreyt> being statement level and always have no return value would help.

[11:48] <audreyt> (in other words, the infix:<:=> macro wouldn't compose well with any other regular things)

[11:48] <audreyt> (as it foces :() on lhs and \() on rhs)

[11:49] <theorbtwo> So $a := $b is now :($a).bind(\($b)) ?

[11:49] <audreyt> yes.

[11:51] <audreyt> TimToady: in any case, parsing

[11:53] <audreyt> $x where {3} := $y;

[11:54] <audreyt> without backtracking

[11:54] <audreyt> is interesting

[11:54] <audreyt> and I also see that you specced

[11:54] <audreyt> $ := moose();

[11:54] <audreyt> form

[11:55] <audreyt> I wonder if reparse is unavoidable there

[11:55] <audreyt> or if we can make Signature syntax always also valid perl6 surface syntax.

[11:56] <audreyt> s/surface/expression/

[11:58] <audreyt> also

[11:58] <theorbtwo> What would $ := moose() do?

[11:58] <audreyt> ($x : $y : $z) := (1,2,3)

[11:58] <audreyt> theorbtwo: it would assert that moose returns at least one thing.

[11:58] <audreyt> (and otherwise has no effect.)

[11:58] <theorbtwo> Hm.

[11:58] <audreyt> actually, exactly one thing.

[11:59] <theorbtwo> You can always use explitic calls to :(), \(), and bind for the ones that aren't valid expressions.

[11:59] <audreyt> yes.

[11:59] <audreyt> but those nonvalids is currently part of S06

[11:59] <audreyt> (see "twodogs")

[11:59] <audreyt> which makes them valid, de jure

[11:59] <audreyt> I merely wonder how we can parse them without rescanning.

[11:59] <audreyt> especially if := is made infix.

[12:00] <audreyt> as it is an usual infix macro that modifies parsing of LHS

[12:00] <audreyt> (RHS is fine.)

[12:00] <theorbtwo> Ah.

[12:01] <audreyt> so, two problems

[12:01] <audreyt> one is that x:=y:=z involves "y" punning

[12:01] <audreyt> which is Bad Thing and should never happen in p6

[12:01] <audreyt> another problem is

[12:01] <audreyt> long...expression...here := moose

[12:01] <audreyt> the long exp may be invalid p6exp but valid p6sig.

[12:01] <audreyt> and how to parse that without prescan.

[12:02] <theorbtwo> It's not x := (y := z), or (x := y) := z, but (x := y) and (y := z) ?

[12:02] <theorbtwo> Does :(...) := ... make sense now, or could that be used to disambugate ?

[12:02] <audreyt> it makes sensenow, unfortuately

[12:03] <audreyt> :($x, $y) := Dog.new(x => 1, y => 2)

[12:03] <audreyt> would bind 1 to $x and 2 to 4y.

[12:03] <audreyt> $y

[12:03] <audreyt> it's called, structural unpacking.

[12:04] <ayrnieu> destructuring-bind

[12:04] <theorbtwo> Um, funky...

[12:06] <audreyt> very useful for writing tree matching :)

[12:06] <audreyt> pmichaud: your input would also be welcome :)

[12:06] <audreyt> (on matching SIG := ...) where SIG is an invalid p6 expresisno but valid p6 signature

[12:07] <audreyt> )

[12:07] <theorbtwo> BBIAB.

[12:09] <audreyt> (one easy way out is forcing people to write :(SIG) := ... always, as theorbtwo observed)

[12:09] <audreyt> and ordinary LHS := ... will simply take LHS to be an expression

[12:09] <audreyt> and cast that to Signature at runtime.

[12:10] <audreyt> and strucutral unpacking would be :( :(...) ) := b...

[12:10] <audreyt> s/b//

[12:10] <audreyt> I can't seem to find any other way out... suggestions welcome.

[12:10] <dakkar> why 2 nested Sig object in that LHS?

[12:10] <audreyt> dakkar: the outer one is Sig form

[12:10] <audreyt> the inner one indicates a structural unpacking

[12:11] <audreyt> see S02, Unpacking tree node parameters.

[12:11] <audreyt> much like

[12:11] <audreyt> [$x, $y] := foo

[12:11] <wolverian> audreyt, do you happen to have any opinion on the best method of doing multitasking in perl5? :)

[12:12] <audreyt> is very much ambiguous, and I think is better written as

[12:12] <audreyt> :( [$x, $y] ) := foo

[12:12] <audreyt> but maybe I'm missing something.

[12:12] <dakkar> unpacking by assignment is done by :($x,$y)=expression_that_returns_hash() ?

[12:12] <dakkar> (or something like that)

[12:13] <audreyt> no, bind to expression that returns hash.

[12:13] <audreyt> or rather

[12:13] <clkao> ETOOMANYCOLONS

[12:13] <audreyt> bind to a hash-ish invocant.

[12:13] <audreyt> clkao: indeed

[12:13] <dakkar> can unpack only with binding? not with assignment?

[12:13] *** kolibrie joined
[12:13] <audreyt> so maybe reparse is valid as long as LHS is valid expression? but it may trigger any number of macros

[12:13] <audreyt> dakkar: yup.

[12:14] <dakkar> stupid question: why?

[12:14] <audreyt> because with binding the RHS preserves the structure

[12:14] <audreyt> so you can say

[12:15] <audreyt> sub f (Tree :($left, $right), Dog :($head, $tail) ) { ... }

[12:15] <audreyt> f(tree(), dog());

[12:15] <audreyt> as well as

[12:15] <audreyt> # ignoring the reparse problem, according to current spec

[12:15] <audreyt>  (Tree :($left, $right), Dog :($head, $tail) ) := (tree(), dog());

[12:15] <audreyt> whilst if it's assignment

[12:16] <audreyt> the (tree(),dog()) would lose their identity

[12:16] <audreyt> another example:

[12:16] <audreyt> ($x) := (x => 4); # binds $x to 4

[12:17] <audreyt> ($x) = (x=>4); # no way to recover $x

[12:17] *** Limbic_Region joined
[12:17] <dakkar> can I write :($head is copy, $tail)=give_me_a_list() ?

[12:18] <audreyt> I suspect not, otherwise we are back to parse the list

[12:18] <dakkar> s{=}{:=}

[12:18] <audreyt> for Pair objects

[12:18] <audreyt> oh

[12:18] <audreyt> :=

[12:18] <dakkar> sorry

[12:18] <audreyt> so, according to the current syntax

[12:18] <audreyt> give_me_a_list would need to return a hash

[12:18] <audreyt> {head => 'moose', tail => 'foose')

[12:18] <audreyt> }

[12:18] <audreyt> for that to work

[12:18] <audreyt> you probably really want

[12:19] <audreyt> [$head is copy, *@tail] := give_me_a_list;

[12:19] <audreyt> which would indeed work, if it returns a single list (or array) object.

[12:19] <dakkar> yes, that one.

[12:19] <dakkar> 'binding' sounds to me like perl5's glob assignment... sharing of the container and stuff...

[12:19] <audreyt> *nod*

[12:20] <dakkar> so, in that last line you wrote, @tail would be a read-only alias to the rest of the list?

[12:20] <audreyt> that's the idea, yes.

[12:20] * broquaint wonders how hard it would be to implement globs in perl6 ...

[12:21] * theorbtwo thinks the answer is /entirely/ too easy.

[12:21] <audreyt> easily, just subclass Capture

[12:21] <audreyt> and add a CODE, an IO, and a FORMAT slot.

[12:21] <dakkar> ':=' has the same semantic as parameter-passing in a sub call, right?

[12:22] <audreyt> dakkar: right, except lhs has no implicit "is readonly".

[12:22] <broquaint> And I imagine adding a sigil would involve a bit of macro magic.

[12:22] <audreyt> yeah. it involves defining

[12:23] <dakkar> I think that the explicit 'this is a Signature' :() on the LHS of := is good documentation

[12:23] <dakkar> otherwise reading expr_returning_a_sig() := something() is *way* ambiguous...

[12:26] <audreyt> macro term:<|> is parsed / \| <name> / { Perl6::AST::Var.new(~$/) }

[12:26] <audreyt> that would allow |var to start acting as a variable name.

[12:27] *** elmex joined
[12:27] <audreyt> (presuming the p6ast_draft nodes and a Perl6::AST package to hold them.)

[12:27] * audreyt likes it that there is much less hand waving around here :)

[12:28] <audreyt> dakkar: indeed, I think LHS := RHS should always parse LHS as expr

[12:28] <audreyt> and then evaluate into a sig

[12:28] <audreyt> via casting if needed

[12:28] <audreyt> to continue allowing

[12:28] <audreyt> $x := $y

[12:28] <audreyt> working

[12:28] <dakkar> there is not enough context to disambiguate in the case of complex LHS, otherwise...

[12:29] <audreyt> yeah, that's what I just observed...

[12:29] <b_jonas> isn't that the same as with assignment? you have to parse the lhs without knowing it's an lvalue

[12:29] <lichtkind> ?eval sub b {leave 2; return 1};b;

[12:29] <audreyt> b_jonas: no, lvalue parses same as rvalue.

[12:29] <evalbot_10037> Error: No such method in class Int: "&leave"

[12:29] <Barry> Is there an alphabetical index of Perl 6...um...functions (or whatever they're called) that includes := so someone could look up "colon" and learn what a := does? I'm not a beginning to end tech book reader.

[12:29] <b_jonas> yes, because it has to

[12:30] <b_jonas> perl makes them the same

[12:30] <audreyt> b_jonas: but sig doesn't parse same as expr.

[12:30] <lichtkind> barry i just begun to make such an index

[12:30] <audreyt> there are valid sigs that isn't valid expr

[12:30] <audreyt> $,$,$ comes to mind.

[12:30] <b_jonas> yes, that's the problem

[12:30] <Barry> Bless you

[12:30] <audreyt> *$,*@,*% another.

[12:31] <audreyt> there are also valid exprs that isn't valid sig, or at least doesn't mean the same at all.

[12:31] <audreyt> [BEGIN{ die 1 }] comes to mind.

[12:33] <lichtkind> ?eval sub b { return 1};b;

[12:34] <evalbot_10037> 1

[12:34] <lichtkind> ?eval sub b { leave 1};b;

[12:34] <b_jonas> I have once written a bison parser where I had to convert lvalues to rvalues at the first point where it became clear that they can't be rvalues

[12:34] <evalbot_10037> Error: No such method in class Int: "&leave"

[12:34] <b_jonas> or, failing that, when they were used as rvalues

[12:34] <b_jonas> but that woul work only with a simple language

[12:35] <b_jonas> where such a conversion is easy to write

[12:35] <broquaint> I'm a bit late to the Capture party, but \(...) returns a Capture right?

[12:35] <audreyt> broquaint: well, it is a Capture literal

[12:35] <audreyt> not really a call to prefix:<\>

[12:35] <theorbtwo> It's not?

[12:35] <audreyt> it's macro circumfix:<\( )>

[12:35] <audreyt> but yes. :)

[12:36] <audreyt> theorbtwo: it's not.

[12:36] <theorbtwo> Er, right.

[12:36] <broquaint> Ok. So \() no longer returns a list of references?

[12:36] <audreyt> broquaint: right.

[12:36] <broquaint> Marvellous.

[12:36] <b_jonas> I needed all kinds of rules to convert different (grammatical) kinds of lvalues to rvalues

[12:36] <audreyt> :D

[12:36] <audreyt> b_jonas: yeah, if there is an universal translator fom p6 exp into signature

[12:36] <audreyt> and make sure that signatures are a strict subset of p6 exp

[12:37] <audreyt> much as lvalue is

[12:37] <b_jonas> yes, that's why I said it's a problem

[12:37] <audreyt> then the specced form would work

[12:37] <b_jonas> I needed a rule to convert '[a, b, ' to an rvalue if the value after the comma was an rvalue itself

[12:37] <audreyt> currently valid Sig forms that are not valid Expr forms:

[12:38] <audreyt> Dog ::T $fido

[12:38] <b_jonas> and a rule to convert an lvalue array '[a, b, c]' to an rvalue

[12:38] <audreyt> --> Moose

[12:38] <b_jonas> lots of duplications

[12:38] <audreyt> $moose?

[12:38] * lypie returns

[12:38] <broquaint> Although the pseudo-hash-ness of Captures seems a little dangerous. But I'm probably just being too suspicious.

[12:38] <audreyt> $top ($left, $right)

[12:38] <broquaint> s/a little dangerous/potential confusing/

[12:38] *** Barry left
[12:39] <audreyt> broquaint: pseudohash shares same set of underlying data.

[12:39] <audreyt> broquaint: positional and named zones in Capture are entirely separate.

[12:39] <audreyt> :)

[12:39] <broquaint> They feel a little too close to PHP's associative arrays. I think that's where this discomfort comes from ;)

[12:40] <audreyt> mm, I fail to note the similarity

[12:41] <b_jonas> Captures sort of remind me to lua tables. these are just hashes, but are internally implemented in such a way that if they have integral keys, than array operations are fast on them

[12:41] <broquaint> It's just a visual similarity.

[12:41] <broquaint> None of the ickiness of: $a = array("one","two"); $a[0] === $a[one]

[12:42] <broquaint> $a[1] === $a[one] # even

[12:42] <audreyt> \(Body:  :bgcolor<black> :topmargin(3)  \(A:  :href($url) 'Body Text'))

[12:42] <audreyt> in this example, the [0] is the inner "A" capture

[12:42] <b_jonas> audreyt: is Body the invocant there?

[12:42] <audreyt> [0][0] is 'Body Text'

[12:43] *** tifo joined
[12:43] <audreyt> [0]<href> is $url

[12:43] <audreyt> b_jonas: yes.

[12:43] <audreyt> presumably a predefined type name

[12:43] <b_jonas> ah, nice example

[12:43] <audreyt> maybe we can call them X-expressions

[12:43] <audreyt> ;)

[12:43] <b_jonas> and how would you use such a capture

[12:44] <b_jonas> I mean would you use it for calling a function or just access its individual elements?

[12:45] <audreyt> say that is in $node

[12:45] <audreyt> you can call

[12:45] <audreyt> foo(*$node)

[12:46] *** Southen joined
[12:47] <audreyt> class Body; multi method foo (:$bgcolor where /black|blue/, *@children) { ... }

[12:47] <audreyt> and maybe draw things based on other attributes

[12:47] <audreyt> using the wonder of multimethods

[12:48] <broquaint> Is there anything that perl6 can't do?

[12:48] <broquaint> In theory?

[12:48] <audreyt> solving the halting problem?

[12:49] <theorbtwo> audreyt: BTW, don't write HTML element names with caps, please.

[12:49] <audreyt> noted, but then lowercase classes are unboxed in p6

[12:49] <theorbtwo> Hm, point, I suppose.

[12:50] <theorbtwo> Should probably all be HTML::body, etc.

[12:50] <audreyt> \(<body>: style => 'moose');

[12:50] <b_jonas> theorbtwo: q is a reserver word, and link is a function

[12:50] <wolverian> wouldn't the stringification handle it?

[12:50] <audreyt> it even reads like xml ;)

[12:50] *** azuroth joined
[12:50] <audreyt> \(<link>: :href<http://moose.org/>);

[12:51] <b_jonas> but I don't see why you'd need multi methods. don't you just need one method per class, like one in Body, one in A, etc?

[12:51] <audreyt> b_jonas: oh sure.

[12:51] <audreyt> the multi is for

[12:51] <audreyt> :$bgcolor where 'black'

[12:51] <b_jonas> hmm.

[12:51] <audreyt> i.e. if you want to do different things based on only on invocant

[12:51] <audreyt> but on values of certain args.

[12:51] <audreyt> if the invocant is the sole discriminator

[12:52] <audreyt> then ordinary methods would do fine.

[12:52] <wolverian> where'd css go? :)

[12:52] <b_jonas> css would be translated to multi methods

[12:54] <b_jonas> like 'table #big [bgcolor="red"] { font-size: 18px }' would become 'class Table; multi method foo(:$bgcolor where /red/, :$id where /big/, ...) { $.font_size = 18*px; SUPER.foo; }'

[12:55] <audreyt> actually, SUPER is going away

[12:55] <audreyt> it's now simply

[12:55] <audreyt> next METHOD;

[12:55] <wolverian> b_jonas, ah. right

[12:55] <wolverian> except please change the bgcolor to something semantic in the example :)

[12:55] <audreyt> or, even golfier:

[12:55] <audreyt> call;

[12:56] <nothingmuch> lypie: you should mail me daily to mail you daiily ;-)

[12:56] <b_jonas> and with next METHOD, how do you change the arguments?

[12:56] <audreyt> you can't

[12:56] <audreyt> so use call.

[12:56] <nothingmuch> lypie: seriously, it's a todo tracker... just add an item =)

[12:56] <audreyt> call; # default to original arguments

[12:57] <audreyt> call(); # calls with zero arguments

[12:57] <wolverian> that's icky

[12:57] <b_jonas> because I really want to add :font_size(18*px) to the arguments

[12:57] <audreyt> (see S12)

[12:57] *** theorbtwo joined
[12:58] <wolverian> I mean, doesn't that make it a special case?

[12:58] <audreyt> nope.

[12:58] *** xinming joined
[12:58] <audreyt> the signature for call is

[12:59] <lypie> nothingmuch: hehe

[12:59] <audreyt> proto call (*@; := CALLER::<@;>) { ...dispatch with *@;... }

[13:00] *** particle_ joined
[13:00] <audreyt> that is another thing that needs FAQ for :)

[13:00] <audreyt> (see S12, Zero-dimensional argument list)

[13:01] <b_jonas> now that's wierd

[13:01] <dakkar> what's that semicolon for?

[13:02] <audreyt> the semicolon twigil indicates a Capture with multiple named and positional sequences.

[13:02] <audreyt> a Capture is ordinarily

[13:02] <audreyt> invocant, positional, named

[13:02] <audreyt> but it can actually be

[13:02] <audreyt> invocant, (positional, named)*

[13:02] <audreyt> to use regex notation

[13:03] <dakkar> argh

[13:03] <audreyt> that is, ordinarily a Capture has one set of pos/nam

[13:03] <audreyt> but in bad times, it can have several.

[13:03] <audreyt> zip(1,2,3;4,5,6;7,8,9)

[13:03] <audreyt> shows an argument list of three sets of pos/nam

[13:03] <dakkar> I parsed *@; as splat - array - end_statement ...

[13:03] <audreyt> each one populated with 3 positional elements.

[13:04] <audreyt> yes, me too, I think the choice of ; is weird

[13:04] <dakkar> it's the "same" semicolon as in the C-style for...

[13:04] <broquaint> Can you access the current function's Capture? e.g sub foo(This $a, That $b) { caller(0).args.delete('That') } # or summat

[13:04] <audreyt> but then, it works in practice, so why not :)

[13:04] <audreyt> broquaint: you can only do that in the sig.

[13:04] <audreyt> otherwise it defeats optimization.

[13:05] <audreyt> sub foo (\$args:(This $a, That $b)) { ... }

[13:05] <broquaint> You can only do what in the sig?

[13:05] <broquaint> Aah.

[13:05] <broquaint> Nifty.

[13:05] *** autark joined
[13:05] <audreyt> so, back to this multiset thing.

[13:06] <b_jonas> so if you say foo, then foo gets zero (pos,named) pairs?

[13:06] <b_jonas> but with foo(), it gets an empty one

[13:06] <audreyt> yes.

[13:06] <audreyt> ordinarily they don't differ at all.

[13:06] <audreyt> for all Sigs that doesn't have *@;moose in it, it's entirely the same.

[13:07] <audreyt> for Sigs that does have *@;, however, you can discriminate based on +@;moose.

[13:07] <b_jonas> and I guess, if you want to call a subref with no (pos,named) pairs, you have to say something like $subref.call

[13:07] <audreyt> note also that @;moose contains Capture objects with empty invocant part.

[13:07] <audreyt> yes.

[13:08] <lypie> audreyt: honestly i shouldn't join this channel... i feel like working on rubydium again :/

[13:08] <theorbtwo> So how do you get the positionals from the second set in :(1,2,3;4,5,6) ?

[13:08] <audreyt> you mean \(1,2,3;4,5,6)

[13:08] *** Qiang joined
[13:08] <audreyt> ordinarily, if you bind it to say *@_

[13:08] <audreyt> it behaves identically as \(1,2,3,4,5,6)

[13:09] <audreyt> which is to say, @(\(1,2,3;4,5,6)) is just (1,2,3,4,5,6).

[13:09] <theorbtwo> Er, yes, I do.

[13:09] <audreyt> nonordinarily, if you really want to distinguish

[13:09] <audreyt> you bind it to *@;moose

[13:10] <audreyt> and @;moose[0] would be \(1,2,3)

[13:10] <audreyt> @;moose[1] would be \(4,5,6).

[13:10] <audreyt> the twigil is where this behaviour happens

[13:10] <audreyt> not the name 'moose'

[13:10] <audreyt> (ok, that part of explanation is maybe unneccessary.)

[13:11] *** amv joined
[13:11] <audreyt> lypie: why is that a bad thing?

[13:11] <lypie> audreyt: because it left me with no social life :P

[13:12] <audreyt> Arathorn: are you still up to, er, capture this into Capture.pod?

[13:12] <svnbot6> r10038 | arathorn++ | Add elucidation from audrey on how Captures work in the context of

[13:12] <svnbot6> r10038 | arathorn++ | Rules, and how they can be used as a natural data type for XML-style

[13:12] <svnbot6> r10038 | arathorn++ | annotated nodes with children.  Summarized from:

[13:12] <svnbot6> r10038 | arathorn++ | http://colabti.de/irclogger/irclogger_log/perl6?date=2006-04-19,Wed&sel=212#l318

[13:12] <audreyt> or someone else can take care of this?

[13:12] <Arathorn> svnbot6 says all ;)

[13:12] <audreyt> (everything above is fully specced in S06 and S12)

[13:12] <lypie> lol

[13:12] <lypie> timing+++

[13:12] <audreyt> Arathorn++

[13:12] <Arathorn> that said, i've only summarized the initial part there

[13:13] <Arathorn> and probably mangled it fairly badly

[13:13] <audreyt> looks fairly good actually

[13:13] <audreyt> Arathorn++

[13:13] <theorbtwo> Er, speaking of -- does svnbot6 miss merges from the svn.perl.org repo, or is there some deeper magic?

[13:14] <audreyt> theorbtwo: the deeper magic is that the automerge is currently broken and I havn't got cycles to investigate strange svk merge-base errors.

[13:14] <audreyt> I suspect per-file merge tickets isn't quite what I imagined them to be.

[13:14] <theorbtwo> Ah.

[13:22] <Arathorn> audreyt: not sure i totally grok the '$ calls "as Scalar"' -> document.getElementById($?SELF) -> $("moose") AJAX/RoR magick yet, so i'm going to hold off confusing Capture.pod still further

[13:22] <Arathorn> (and also $job prolly wants me back, for better or worse :)

[13:29] <audreyt> :)

[13:29] <audreyt> I think the @;parallel thing is more interesting

[13:30] <audreyt> as in, makes more interesting question

[13:30] <audreyt> the AJAX magick probably doesn't belong in FAQ :)

[13:30] <audreyt> FMTYNTK, maybe.

[13:37] <Arathorn> far more than you...?

[13:38] <particle_> need to know

[13:39] * Arathorn got NTK ;)

[13:39] <Arathorn> just checking i'd filled in FMTY right

[13:39] <audreyt> (it's better known as FMTYEWTK)

[13:39] <particle_> oh. yes.

[13:39] <Arathorn> ah, that's more familiar

[13:40] * Arathorn sues google for not doing a "did you mean to type: FMTYEWTK" :)

[13:40] <audreyt> it does that if you do FMTYENTK

[13:40] <audreyt> I did it just a few secs ago :)

[13:50] *** vel6608 joined
[13:51] *** fglock joined
[13:59] <audreyt> journal up (awfully short this time)

[13:59] <audreyt> good night :)

[13:59] <audreyt> &

[14:00] <audreyt> hm, maybe I should p6l my := question lest it's lost in huge scrollback.

[14:00] * lypie reads journal

[14:03] *** pmurias joined
[14:03] <pmurias> hi

[14:03] <theorbtwo> Hi, pmurias.

[14:03] <theorbtwo> You just missed audrey.

[14:07] <fglock> audreyt: how do I get the text matched, if ${$match} returns the capture instead?

[14:08] <dakkar> ~$/ (from one of the examples passed here)

[14:09] <audreyt> fglock: what dakkar said

[14:09] <audreyt> or hm

[14:10] <audreyt> less confusingly, maybe make it a method?

[14:10] <audreyt> usually the result object is simply the string

[14:10] <audreyt> but in parser combinator mode it's the AST

[14:10] <theorbtwo> Apparently, you didn't so much miss audreyt, she's just IRCing in the background.

[14:11] <audreyt> maybe you can put the text matched into the AST and make that stringify as the source string.

[14:11] <audreyt> fglock: btw, $rv is still the Match

[14:11] <audreyt> $$rv is the Moose

[14:11] <audreyt> it used to be $rv()

[14:12] <audreyt> but then, specifying a code deref that you can't ever pass in anything feels weird

[14:12] <audreyt> it was chosen to be .() simply to allow the $() shorthand to mean $/()

[14:12] <audreyt> but now $() means $($/), and we get @() to mean @($/)

[14:12] <audreyt> and %() to mean %($/)

[14:12] <audreyt> so the original motivation goes away, and it doesn't need to be .() anymore,

[14:13] <audreyt> so maybe the source fragment is better made available as $match.source.

[14:14] <clkao> audreyt: what automerge breakness?

[14:14] <clkao> pulling file changes?

[14:14] <audreyt>  system("svk sm -m '' -I -l $path/S$k.pod //mirror/pugs/docs/Perl6/Spec/$v.pod\n");

[14:14] <audreyt> single file sms

[14:15] <clkao> hmm. ok let me take a look

[14:15] <clkao> which one is supposed to be merged?

[14:15] <audreyt> the ticket reads

[14:15] <audreyt> 3eb29b82-81e5-0310-bad4-b280dcad658b:/doc/trunk/design/syn/S10.pod:8453

[14:15] <audreyt> on docs/Perl6/Spec/Package.pod

[14:15] <clkao> *nod*, you can do sm -t file.. but i mean which has changes

[14:15] <clkao> and fails to merge

[14:17] <audreyt> Cannot find the path which '//mirror/pugs/docs/Perl6/Spec/Subroutine.pod' copied from.

[14:17] <audreyt> this is with:

[14:17] <audreyt> svk sm -m ''  -I -l -t //mirror/pugs/docs/Perl6/Spec/Subroutine.pod

[14:17] <clkao> doh, of course. me stupid

[14:19] <audreyt> but if I use

[14:20] <clkao> audreyt: r11638 is manual merge.. no ticket

[14:20] <clkao> "svk sm -C //mirror/p6-doc/design/syn/S10.pod Package.pod" gives me a 'g'

[14:20] <clkao> and the new ticket looks fine

[14:21] <audreyt> svk sm -m '' -I -l //mirror/perl6/doc/trunk/design/syn/S06.pod //mirror/pugs/docs/Perl6/Spec/Subroutine.pod

[14:21] <audreyt> I got Can't find merge base for /mirror/perl6/doc/trunk/design/syn/S06.pod and /mirror/pugs/docs/Perl6/Spec/Subroutine.pod

[14:21] <audreyt> This is svk, version 1.07.

[14:21] <clkao> oh fun. depot path doesn't work, but copath works

[14:22] <audreyt> same for Package and S10

[14:22] <audreyt> oh, what fun.

[14:22] <audreyt> that a bug?

[14:22] <clkao> wait

[14:22] <clkao> i was merging 10 -> sub.. wrong

[14:23] <clkao> wfm

[14:23] <audreyt> with repopath?

[14:24] <clkao> yues

[14:24] <audreyt> svk 1.99?

[14:24] <clkao> 1.07

[14:25] <audreyt> :/

[14:25] <clkao> weird

[14:25] *** mncharity joined
[14:25] <clkao> s06 -> sub gives me conflict though

[14:25] <audreyt> ok... maybe you can run the mergeloop?

[14:25] *** mncharity is now known as putter

[14:25] <audreyt> putter: hey!

[14:25] <audreyt> ltns!

[14:26] <putter> hi :)  indeed... life.

[14:26] <audreyt> putter: I've been holding off re::override release and such :)

[14:26] <putter> p6 progress! !:)

[14:26] <putter> lol

[14:27] <putter> hmm, have some month+ old doc I could check in... someplace.   but i'm thinking less-than-ideally fruitful development path, no?

[14:28] <audreyt> I still think it's an useful interface.

[14:28] <clkao> audreyt:

[14:28] <clkao> r11638 (orig r9989):  audreyt | 2006-04-17 18:51:16 +0100

[14:28] <clkao> * Perl6::Spec - update to upstream r9741

[14:29] <audreyt> that's by hand

[14:29] <clkao> you don't really mean 9741... can you lookup the actual remote rev

[14:29] <clkao> so i can fix the merge tickets

[14:29] <audreyt> you mean actual remote rev for each pod?

[14:30] <clkao> no just that r9741

[14:30] <putter> the re:override, certainly.  but the underlying "let's reverse engineer some version of perlguts and try to magic an api where one wasn't intended"... less so.

[14:30] <clkao> 'cause latest in p6-doc is r8874

[14:30] <clkao> so maybe it's your local rev

[14:30] <audreyt> it's just typo

[14:30] <audreyt> 8741

[14:31] <audreyt> sowwy

[14:31] <putter> anyway.  is there a cleanish "code as spec" of OPP existant?  anything close?

[14:31] <clkao> k

[14:31] <audreyt> closest is still PGE/OPTable.pir.

[14:31] <putter> shudder

[14:31] <theorbtwo> Other People's Problems have a specification?

[14:31] <putter> :)

[14:31] <audreyt> ok, try

[14:31] <audreyt> misc/pX/tewk/Ruby-Rules-Parser/OpTable.rb

[14:32] <audreyt> it's ruby, should be clear ;)

[14:32] <audreyt> but the algorithm in PIR land has changed (definitely for the better)

[14:32] <putter> a pig in the sun is easier to see than a pig at night, but...

[14:32] <audreyt> pmichaud merged all four tables into one

[14:33] <audreyt> because as more distinguishers appear

[14:33] <audreyt> four tables threatens to evolve into 8 and 16

[14:33] <audreyt> so it's now a bitmap "mode"

[14:33] <putter> hmm, operators and terms merged?!?

[14:33] <audreyt> as you can see in my .h.

[14:33] <audreyt> now a "expects" mitmask takes over.

[14:33] <audreyt> #define PGE_OPTABLE_EXPECT_TERM     0x0010

[14:33] <audreyt> #define PGE_OPTABLE_EXPECT_OPER     0x0060

[14:33] <audreyt> #define PGE_OPTABLE_EXPECT_TERMPOST 0x0050

[14:33] <clkao> there's weird conflict... is it line-encoding or stuff

[14:34] * putter wists for a high-level spec

[14:34] <audreyt> putter: that is actually what I'm trying to start doing with C.

[14:34] <dakkar> this is the second time I seen 'wist' used as a verb...

[14:34] <audreyt> src/Text/Parser/OpTable.hs is very high level.

[14:34] <audreyt> same algo as the ruby one

[14:34] <theorbtwo> .oO(If you wist upon a star, doesn't mawter where you are...)

[14:34] <putter> whists even

[14:35] <audreyt> not exactly friendly though, all the use of implicit parameters.

[14:35] <putter> I was thinking p6.  or rb.  or even p5.  OOy.  clarity over performance.  no bitmasks :)

[14:35] <dakkar> theorbtwo: always thought that was 'wish' (never seen it written down, and English is not my native language)

[14:35] <theorbtwo> dakkar: It is.  It was a joke.

[14:35] <dakkar> ow

[14:35] <audreyt> I think C is the correct level here. I thought D is far saner because it has easy and fast hash/array with full OO

[14:36] <audreyt> putter: this is not a very OO problem though :)

[14:36] <audreyt> i.e. very little identities

[14:36] <audreyt> s/little/few/

[14:37] <audreyt> anyway, p5 has one

[14:38] <audreyt> misc/pX/Common/Pugs-Compiler-Precedence/lib/Pugs/Grammar/Precedence.pm

[14:38] <audreyt> codegens to Parse::Yapp

[14:38] <audreyt> not OO at all

[14:38] <putter> not entirely joke.  just very very archaic - http://65.66.134.201/cgi-bin/webster/webster.exe?search_for_texts_web1828=wistful

[14:38] <putter> but making a comeback! :)

[14:38] <audreyt> quite mature: fglock bases PGP6 on it.

[14:38] <putter> but, it's wist, not whist.  sorry

[14:38] <audreyt> so, take your pick :)

[14:38] <integral> wistful is archaic?!

[14:39] <putter> no, wist

[14:39] <putter> audreyt: thanks

[14:39] <audreyt> (I really want C for something that can be shared, but that may be just me :))

[14:39] <audreyt> and with Judy, it's asif I'm programming in D :)

[14:39] <pmichaud> tis me also :-)

[14:39] <audreyt> pmichaud: hey :)

[14:40] <putter> re not oo, I just want a spec.  a nice clean spec.  C!=spec.  nor pir.

[14:40] <obra> (PGP6, audrey?0

[14:40] <audreyt> obra: Pugs::Grammar::Perl6

[14:40] <obra> ah. ok.

[14:40] <audreyt> putter: I wonder if pmichaud can be bribed into annotating OPTable.pir with literate-style comments

[14:41] <audreyt> that can then pod2html into spec.

[14:41] <putter> C great for implementation, esp sharing.  great thing.  perhaps easier to write with clean spec in hand.  perhaps easier to read too.

[14:41] <pmichaud> audreyt: that's in my plans

[14:41] <pmichaud> depending on what one means by "literate-style comments"  :-)

[14:41] <putter> lol

[14:41] <putter> pm++

[14:41] <audreyt> :)

[14:42] <pmichaud> as it is I had to re-do the stoptoken code this morning (not ci'ed yet), and I'm re-examining the handling of close tokens

[14:42] <audreyt> ah, so still somewhat in flux... POD can definitely help then

[14:42] <audreyt> (to track algo changes)

[14:43] <pmichaud> well, it keeps fluxing because the language keeps fluxing.  :-)

[14:43] <pmichaud> getting long dot to work took a bit of thought

[14:43] <pmichaud> oops, phone

[14:43] <putter> second question... how goes the pugs grammar non-bt overhaul?

[14:44] <audreyt> putter: it compiles, it parses sanities

[14:44] <audreyt> runs sanities

[14:44] <audreyt> it does _not_ parse Prelude

[14:44] <audreyt> which is why I'm not checking it in.

[14:45] <putter> how different from the current Parser.hs is it?   I could use a reference grammar.... hopefully later today...

[14:45] <audreyt> er, I posted a diff

[14:45] <audreyt> in my blog

[14:46] <putter> err, I meant, hopefully I'll be at the point of needing it, not, hopefully you will have done it ;)

[14:46] <audreyt> oh. heh

[14:46] <audreyt> we are still pondering how best to do this reference grammar thing.

[14:46] * theorbtwo wonders /what/ this reference grammar is.

[14:47] <theorbtwo> Is it a perl6 grammar for perl6, without any implementation-specific details?

[14:47] <audreyt> I still think compiling Parsec into Rules, turning the midstream tree munging into miniperl6 embedded, is sanest.

[14:47] <theorbtwo> Ah.  Yes, it is.

[14:48] <putter> ah, there it is (the diff)

[14:49] <putter> ok, np

[14:49] <PerlJam> audreyt: nice question to p6c

[14:50] <audreyt> PerlJam: thx. I try to make miniperl6-embedded a strict subset of p6

[14:50] <audreyt> by exposing the p6ast nodes asis

[14:50] <audreyt> but the Bind node has nontrivial surface form

[14:50] <audreyt> and parsing them back is rather hard.

[14:54] <audreyt> in any case, I'd welcome pairing on optable.c and/or extracting a spec out of OPTable.pir this weekend... hopefully with pmichaud's latest batch of edits factroed in

[14:55] <audreyt> good night for real.

[14:55] <audreyt> :)

[14:55] <audreyt> &

[14:56] <putter> oh, good night audreyt, thanks for your help

[14:56] <putter> and pmichaud

[14:57] <putter> lunch &  hopefully back sometime this week.  (lnog lunch)

[14:58] <lichtkind> ? eval if not 0 {1}

[14:58] <dakkar> ?eval if not 0 {1}

[14:58] *** evalbot_10037 is now known as evalbot_10038

[14:58] <evalbot_10038> 1

[14:59] <lichtkind> thanks dakkar time to sleep

[15:00] <pmichaud> good morning, PerlJam :-)

[15:05] <pmurias> it's not proper ruby

[15:06] <pmurias> sorry

[15:07] <theorbtwo> G'night, lichtkind.

[15:07] <lichtkind> thanks

[15:07] *** lichtkind is now known as lk

[15:10] *** pmurias joined
[15:49] * audreyt wakes up from an epiphany

[15:49] <audreyt> pmichaud: ping

[15:50] <audreyt> pmichaud: if all we have is a single precedence

[15:50] <audreyt> and you have a populated tokentable space in various categories

[15:50] <audreyt> surely it is possible to write out a non-backtracking Rule that parses as efficiently as OPTable?

[15:53] * stevan hands audreyt a glass of warm milk and sends he back to bed ..... it was just a bad dream honey, its okay

[15:54] <audreyt> pmichaud: also, currently Pugs has "optional unary" category for eg rand

[15:54] <audreyt> where

[15:54] <audreyt> rand + 1; # this means rand() + 1

[15:56] <audreyt> rand * 1; # this means rand() * 1

[15:56] <audreyt> ?eval rand +1000

[15:56] <evalbot_10038> 994.0632201018891

[15:56] <audreyt> ?eval rand + 1000

[15:56] <evalbot_10038> 970.1031268271857

[15:57] <audreyt> so, er, it heaves as rand(+1) but rand()*1

[15:57] <theorbtwo> How's that diffierent from a normal unary?

[15:57] <theorbtwo> Er, nevermind.

[15:58] <audreyt> pmichaud: basically it tests if the next one is valid term; if yes it goes to rand(term); if not it parses as rand OP

[15:58] <theorbtwo> Why does this need a seperate category?

[15:58] <audreyt> pmichaud: perl5 does that. shall we?

[15:58] <audreyt> theorbtwo: it doesn't, it's just prefix with "optional" arity.

[15:59] <audreyt> but currently PGE::OpTable has no "optional unary" arity

[15:59] <audreyt> hence the question.

[15:59] <audreyt> in any case, I figure that we can compile a level of precedence to

[16:00] <theorbtwo> I think it's a generally good idea.  I can't think of a case that requires lots of lookaround, just to the next token, I think.

[16:00] <theorbtwo> rand++ vs rand+1 requires more then one character, but only one token.

[16:01] <pmichaud> audreyt: PGE::OpTable is supposed to allow optional unary via the "nullterm" property

[16:02] <pmichaud> prefix:<rand> is nullterm ...

[16:02] <audreyt> ah. but it only makes sense for unary, right?

[16:02] <audreyt> infix with nullterm bothsides would be fun

[16:02] <pmichaud> and listfix

[16:02] <audreyt> as is listop

[16:02] <audreyt> yeah

[16:02] <pmichaud> and I think listop allows nullterm

[16:02] <pmichaud> actually, infix can have a nullterm also :-)

[16:03] <audreyt> on RHS only?

[16:03] <pmichaud> yes, rhs only I think

[16:03] <pmichaud> but it can still chain

[16:03] <theorbtwo> As in 1,2,3,

[16:03] <pmichaud> theorbtwo: exactly -- infix:<,> is nullterm

[16:04] <audreyt> pmichaud: so, is it possible, assuming a single precedence level, to write out a parse using rules alone?

[16:04] <audreyt> TimToady did a sketch of that a few days back here, but incomplete

[16:04] <pmichaud> audreyt: I hadn't really thought about it; my suspicion is that it is possible

[16:04] <audreyt> putter asked for a spec, and that seems a good spec.

[16:05] <audreyt> pmichaud: because if you take the highest level of prec

[16:05] <audreyt> apply such compile-to-rule to that level

[16:05] <audreyt> take the result rule as the "term" for next level

[16:05] <audreyt> then you get a operator precedence parser with no backtracking

[16:05] <audreyt> into a single topdown rule that should be as fast as the optable one

[16:06] <pmichaud> I'm not sure it's "as fast" (more, long explanation)

[16:07] <pmichaud> originally PGE used a top-down parser for parsing p6rules

[16:07] <audreyt> that is how the current Pugs low-level parser is built, and I originally thought that it can't work with p6rules because that you can't compose several hashes together, and you can't return a partially applied node

[16:07] <audreyt> but p6 rules can do both now

[16:07] <audreyt> top-down with no backtracking?

[16:07] <pmichaud> yes, top-down, no backtracking

[16:07] <pmichaud> it was much slower than the current prec-parser version

[16:08] <audreyt> what was the bottleneck?

[16:08] <pmichaud> I don't know for sure.  It could've been a quirk of implementation, plus since it was in PIR there were a lot of sub call overheads taking place

[16:08] <pmichaud> my thinking was the same as yours -- that since there wasn't any backtracking, it shouldn't make a big different.  But my experience showed otherwise

[16:08] <pmichaud> s/different/difference/

[16:08] <audreyt> mmmm.

[16:09] <audreyt> but in any case, I think speccing optable with p6rule syntax may be interesting

[16:09] *** justatheory joined
[16:09] <audreyt> even if it runs slower, it can certainly make putter feel much better

[16:09] <pmichaud> I'm fully willing to say it was inadequacy on the part of the programmer.  But since TimToady advised that we were going to need a bottom-up parser anyway, it seemed like it was a good idea to use it for p6rules and I got the speed performance :)

[16:10] <audreyt> oh right, we'd need a bottom up parser

[16:10] <audreyt> I was just wondering if we can do what parsec does and compile it to a topdown parser.

[16:10] <audreyt> (because in parsec I saw the reverse speed profile)

[16:10] <pmichaud> interesting.

[16:11] <audreyt> i.e. my hand-rolled Text.Parser.OpTable is no match for compiled-to-topdown parsers

[16:11] <audreyt> it might be inadequacy on the part of programmer as well :)

[16:11] <pmichaud> I've already started to document OpTable.pir, and I thought I'd give a "theory of operation" section in the pod

[16:12] <pmichaud> but it'll be at least a few days before I can have it really well spec'd

[16:12] <pmichaud> and I'm still trying to figure out how I want to deal with close tokens :-|

[16:12] <audreyt> what was the problem?

[16:13] <pmichaud> for some parses using the bottom-up parser, the close token isn't a token

[16:13] <pmichaud> for example:    rx % pattern %

[16:13] <audreyt> rx% moose %

[16:13] <pmichaud> somehow the literal has to know that the '%' is a close token

[16:13] <pmichaud> because in   rx/  %moose% /   it isn't

[16:14] <audreyt> can you push a local stoptoken?

[16:14] <audreyt> and reuse the termination rule

[16:14] <pmichaud> hmmmmmm

[16:14] <audreyt> basically model the close not as a categ

[16:14] <audreyt> but a stack of things to stop/ret from

[16:15] <particle_> don't forget balanced open-close tokens

[16:15] <particle_> { }

[16:15] <pmichaud> particle_: yes, I ran into that one last night :-|

[16:15] <audreyt> sure, same thing...

[16:15] <particle_> how does perl5 do it?

[16:15] <audreyt> because in

[16:15] <pmichaud> p5 does interpolation

[16:15] <pmichaud> i.e., it uses a "quoted string"

[16:16] <audreyt> if -e rx% moose {purr} % { ... }

[16:16] <audreyt> the " {" in {purr is not treated as stoptoken

[16:16] <pmichaud> oh, that's no problem, it's embedded in the rx term

[16:16] <pmichaud> the rx term will parse all the way to the closing %

[16:16] <audreyt> ok, but suppose it's circumfix <rx% %>

[16:17] <audreyt> instead of a term

[16:17] <particle_>  if -e rx{ moose {<{>} } { ... } # should work, too

[16:17] <audreyt> the same thing shall still happen

[16:17] <pmichaud> then the { is within a circumfix op so it also doesn't count

[16:17] <particle_> ah, true

[16:17] <pmichaud> at the moment, PGE only considers stoptokens at the "top level" -- i.e., outside of any circumfix ops

[16:18] <audreyt> and it seems to suggest that "close" and "stoptoken" are very similar ideas

[16:18] <audreyt> as perl6 has no superrightbracket that closes several opens at once.

[16:18] <pmichaud> I thought about implementing it as "close", but decided separate was easier for now

[16:18] <audreyt> (as in (+ 1 (cdr moose]

[16:19] <pmichaud> I think I would probably introduce a new syncat for a superclose

[16:19] <particle_> :) seems like a good one

[16:19] <pmichaud> (not needed for p6, but for a more general solution)

[16:19] <audreyt> nod

[16:20] <pmichaud> well, lemme see if I can detail the problem.  when parsing a rule, the opp calls a <parse_ws_lit> subrule to parse out literals and whitespace

[16:20] <pmichaud> parse_ws_lit already knows about the standard metacharacters for p6rules, but it doesn't know about any user-specified terminator

[16:21] *** SamB joined
[16:21] <pmichaud> so, if the programmer has done   rx %xyza%     <parse_ws_lit> needs to know that % isn't a valid char in a literal

[16:21] <pmichaud> it has to get that information out-of-bound, so to speak

[16:21] <pmichaud> s/bound/band

[16:21] <particle_> sounds like a named optional arg to parse_ws_lit

[16:22] <audreyt> pmichaud: (as an complete aside, do PGE support <%foo> or <@bar>?)

[16:22] <pmichaud> but then every (sub)rule that will be called from the opp has to be able to handle that named optional arg

[16:22] <pmichaud> audreyt: not yet -- I'm wanting to get lexicals implemented first

[16:23] <audreyt> ok

[16:23] <audreyt> I just wonder if in <%foo>, rather than ignoring the values

[16:23] <audreyt> maybe the values mean "is parsed".

[16:23] <pmichaud> I thought that was already the case

[16:23] <audreyt> no.

[16:24] <audreyt> it only runs if the values are Code

[16:24] <audreyt> not Match

[16:24] <audreyt> I mean Rule

[16:24] <pmichaud> but rules are Code

[16:24] <audreyt> method without invocant?

[16:24] <audreyt> or you mean

[16:24] <pmichaud> or one can consider the match object to be the invocant

[16:25] <audreyt> /moose/.("moosemoose")

[16:25] <audreyt> is legal?

[16:25] <audreyt> (that's what "rules are Code" would mean to me)

[16:25] <audreyt> rx/moose/.("moosemoose"), to disambiguate a bit more,

[16:26] <pmichaud> my basis is "rules are subs".  I would take that to mean that they can be called as subs, and can take parameters.  Certainly TimToady has been speaking of them that way

[16:26] <pmichaud> and I've been implementing them that way

[16:26] <audreyt> named rules, for sure.

[16:26] <audreyt> but rx literals?

[16:26] <audreyt> (which is what <%foo> would contain)

[16:27] <pmichaud> %foo['x'] = rx% moose %;    seems a lot like %foo['x'] = sub { moose } ;

[16:27] <pmichaud> (modulus brackets)

[16:27] <PerlJam> greetings

[16:27] <particle_> rx literal is then an anonymous sub

[16:27] <pmichaud> right.  "rules are subs"

[16:27] <audreyt> pmichaud: ok... if that's the case, then it takes Match

[16:28] <audreyt> to resume the parse state?

[16:28] <pmichaud> I lost the antecedent of "it"

[16:28] <audreyt> %foo<x>

[16:28] <audreyt> i.e. if I do

[16:28] <audreyt> %foo<x>.('bigmoose' ~~ /big/)

[16:29] <audreyt> it would continue matching at the 'moose' position?

[16:29] <pmichaud> yes

[16:29] <particle_> kewl

[16:29] <pmichaud> at least in the current implementation

[16:29] <audreyt> but that is quite unlike what "is parsed" does, iirc

[16:29] <audreyt> "is parsed" works like

[16:30] <pmichaud> I'll quickly admit to possibly being wrong about "is parsed" :-)

[16:30] <audreyt> %foo<x>.('bigmoose' ~~ /<before big>/)

[16:30] <pmichaud> ohhh

[16:30] <pmichaud> that's different :-)

[16:30] <audreyt> yeah, hence my confusion :)

[16:30] <pmichaud> at least, I think of it differently

[16:30] <pmichaud> going back to the original  <%foo>

[16:31] <audreyt> ok. it does a longest-token match on its keys

[16:31] <pmurias> is it ok to check the beginnings of a C version of Inline::Parrot into misc/pX?

[16:31] <audreyt> pmurias: sure!

[16:31] * pmichaud rechecks S05 to verify what he thinks he is going to say

[16:32] <audreyt> S05 stupilates that if %foo<x> is a rule

[16:32] <audreyt> it's run "as a subrule"

[16:32] <audreyt> I mean, stipulates.

[16:32] <audreyt> which seems to me that it will run after the 'big'

[16:32] <particle_> stupilates++

[16:32] <audreyt> rather than as in opp, where it run before the 'big'

[16:32] *** saorge joined
[16:32] <pmichaud> TimToady and I had a conversation about that last year -- i.e., I asked t he same question

[16:33] <pmichaud> and I think the result was that it called the subrule at the beginning of the key, not after the key

[16:33] *** _bernhard joined
[16:33] <audreyt> but S05's wording clearly suggests otherwise

[16:33] <pmichaud> or, more to the point, the key was treated as a zero-width match

[16:33] <audreyt> I 100% agree with you here

[16:33] <audreyt> so maybe just fix S05? :)

[16:34] <audreyt> i.e. in

[16:34] <pmichaud> we decided that because we don't want the called sub to have to do a lookbehind to figure out which key caused it to be called

[16:34] <audreyt> If it is a string or rule object, it is executed as a subrule.

[16:34] <audreyt> which suggests at the end of the match

[16:35] <audreyt> change it to say ... "at the beginning of the match, treating the key as a zero-width match"

[16:35] <audreyt> and maybe on the previous item

[16:35] <audreyt> the one that says "string"

[16:35] <PerlJam> So, in <%foo>, if the keys are rules, what are the values?

[16:36] <pmichaud> same as %foo

[16:36] <audreyt> pmichaud: so

[16:36] <pmichaud> the difference between <%foo> and %foo is how the keys are treated

[16:36] <audreyt> %foo = ('moose' => 'antler')

[16:36] <audreyt> this will never match?

[16:36] <audreyt> I have to say

[16:36] <audreyt> %foo = ('moose' => 'mooseantler')

[16:36] <audreyt> ?

[16:36] <audreyt> that seems counterintuitive.

[16:36] <lypie> hehe

[16:36] <audreyt> I'd suggest to treat Str and Rule values separately.

[16:36] <audreyt> Str matches after

[16:37] <audreyt> Rule matches before

[16:37] <audreyt> makes sense?

[16:37] <lypie> audreyt: i love the fact that i return from work and you are still talking while &'ed ;)

[16:37] *** miyagawa is now known as Tatsuhiko

[16:37] <pmichaud> I think we should get rid of the "or rule object" in If it is a string or rule object, it is executed as a subrule.

[16:37] <audreyt> lypie: I have evil plans to make opp into a simple compiler that produces rules, and I'm making sure that rules does it :)

[16:37] <pmichaud> because if it's a rule object, it's a closure

[16:37] <PerlJam> lypie: perhaps audreyt's away cycles are much shorter than normal people's

[16:37] <lypie> audreyt: yay evil plans ++++!

[16:37] <svnbot6> r10039 | pmurias++ | the beginning of a C version of Inline-Parrot

[16:38] <audreyt> pmichaud: but for normal closures, we don't rollback the parse

[16:38] <audreyt> to the begin point

[16:38] <audreyt> we only do that for rules

[16:38] <audreyt> normal closures are just run for side effects really

[16:38] <audreyt> makes very little sense to move to begin-of-parse for them

[16:38] <audreyt> so I think it's 3 cases

[16:39] <audreyt> not 2

[16:39] <pmichaud> except if I have    %foo = ( 'moose' => &xyz, 'beaver' => &xyz )

[16:39] <pmichaud> then &xyz has no way of knowing if it was called by moose or beaver

[16:39] *** Tatsuhiko is now known as miyagawa_

[16:39] <pmichaud> (except lookbehind)

[16:39] <PerlJam> pmichaud: unless whatever matched was implicitly passed as the topic for &xyz

[16:40] <PerlJam> (maybe not the topic, but passed implicitly none-the-less)

[16:40] *** miyagawa_ is now known as miyagawa

[16:40] <audreyt> yeah, that'd be natural.

[16:40] <pmichaud> (not that lookbehind is necessarily bad)

[16:40] <audreyt> i.e. the Match obtained by the key

[16:40] <audreyt> is passed into the closure

[16:40] <audreyt> which, when treated as a Str, becomes 'moose' or 'beaver'.

[16:41] <PerlJam> right

[16:41] <audreyt> but then, I probably don't want to rollback to before m/b.

[16:41] <audreyt> I prolly only want to do that if I'm a subrule and want a say in whether the parse succeeded or not.

[16:42] <pmichaud> but rollback on a closure would only occur if it returned or executed fail somehow

[16:42] <pmichaud> otherwise closures always succeed -- there's no 'rollback'

[16:43] <pmichaud> I do see the difference with "is parsed", however

[16:43] <audreyt> yes

[16:43] <audreyt> which is why the cursor shouldn't move to beginning

[16:43] <audreyt> when the value is Code

[16:43] <audreyt> but why it should do that when the value is Rule.

[16:43] <pmichaud> I don't tend to think of cursors moving in closures anwyay

[16:43] <pmichaud> er, anyway

[16:44] <audreyt> I agree

[16:44] <audreyt> what I mean is

[16:44] <audreyt> given

[16:44] <pmichaud> %foo can call the closure with the cursor wherever it wants -- the closure doesn't move the cursor -- %foo does

[16:44] <audreyt> my %x = (foo => { say "Hi" });

[16:45] <audreyt> "foofoo" ~~ /<%x>/

[16:45] <svnbot6> r10040 | pmurias++ | compiles and runs now

[16:45] <audreyt> and

[16:45] <audreyt> "foofoo" ~~ /<%x><%x>/

[16:45] <audreyt> should probably both work.

[16:45] <pmichaud> in each case, it's the <%x> that decides to move the cursor, not the closure

[16:45] <audreyt> yes.

[16:45] <audreyt> but compare to

[16:46] <audreyt> my %x = (foo => rx/Hi/);

[16:46] <audreyt> "fooHi" ~~ /<%x>/; # this should fail!

[16:46] <pmichaud> there's a difference there -- rx/Hi/ has an explicit return

[16:46] <audreyt> yes, but <%x> moves cursor back to 0

[16:47] <audreyt> before invoking subrule

[16:47] <audreyt> rx/Hi/

[16:47] <audreyt> not stay at 3

[16:47] <audreyt> as with the {say"Hi"} case.

[16:47] <pmichaud> why does moving the cursor for { say "Hi" } make any difference?

[16:47] <audreyt> "foofoo" ~~ /<%x><%x>/

[16:47] <audreyt> or  rather

[16:48] <audreyt> "foofoo" ~~ /^<%x><%x>$/

[16:48] <audreyt> if cursor moves back to 0, that will fail

[16:48] <pmichaud> it's not the closure that moves the cursor

[16:48] <audreyt> if cursor doesn't move back for closures

[16:48] <audreyt> then it will succeed.

[16:48] <pmichaud> in both cases <%x> calls the closure or subrule

[16:48] <pmichaud> if the closure or subrule  has an explicit return, then <%x> uses the explicit return to figure out where the cursor should go

[16:48] <pmichaud> if there's no explicit return, then <%x> puts the cursor at the end of the key

[16:49] <audreyt> define explicit return

[16:49] <audreyt> return 3; # surely not this?

[16:49] <pmichaud> foo { return 0; } /

[16:49] <pmichaud> oops

[16:49] <pmichaud>     rx / foo { return 0; } /

[16:49] <audreyt> but I thought that is the result object syntax.

[16:50] <audreyt> are we overloading things here?

[16:50] <pmichaud> yes, I'm saying it's much the same thing

[16:50] <audreyt> but it can't be

[16:50] <audreyt> result object doesn't affect cursors

[16:50] <audreyt> they are orthogonal

[16:50] * pmichaud thinks

[16:51] <PerlJam> You guys are confusing to watch :)

[16:51] <pmichaud> what should happen with    %moose = ( foo => { return 3; } )

[16:52] <audreyt> as currently specced

[16:52] <audreyt> the return value for that Code is ignored

[16:52] <pmichaud> "foofoo" ~~ rx/ %moose /

[16:52] <audreyt> <%moose>

[16:52] <audreyt> if it is not ignored, I suppose it sets the result object to 3.

[16:52] <pmichaud> I'm asking about rx/ %moose /

[16:52] *** amnesiac joined
[16:53] <audreyt> ok.

[16:53] <pmichaud> (in this case   rx/ %moose /  is the same as rx/ <%moose> /  I think)

[16:54] <PerlJam> A literal reading of S05 would say that the match fails.

[16:54] <pmichaud> perljam: why?

[16:54] <audreyt> no way...

[16:54] <audreyt> it succeeds, and then nothing happens, is literal reading of S05

[16:54] <audreyt> I think it can safely be extended to mean that the result object slot becomes 3

[16:55] <audreyt> so $() is 3, and so is ~$/ and friends.

[16:55] <pmichaud> but if we say the result object slot is 3, we should probably also immediately return from the match

[16:55] <PerlJam> I'm reading where it says "An interpolated hash matches ..." and the list says closure -> execute, string -> subrule, 1 -> nothing special but succeeds, and "Any other value causes the match to fail."

[16:55] <pmichaud> similar to what we do with  / foo { return 3; } /

[16:55] <audreyt> PerlJam: that is talkign about f==>1.

[16:55] <audreyt> PerlJam: we have f=>&closure.

[16:56] <audreyt> pmichaud: I'm less sure.

[16:56] <PerlJam> oh, duh.  I misread what pm wrote

[16:56] <audreyt> if the user means

[16:56] <audreyt> foo { return 3; }

[16:57] <TimToady> the current S05 description of / %foo / and / <%foo> / is incorrect.

[16:57] <pmichaud> yay!  TimToady, our saviour!

[16:57] <audreyt> then maybe it's just setting the "foo" named slot

[16:57] <audreyt> and $<foo> would be 3

[16:57] <audreyt> not the entire $/

[16:57] <audreyt> TimToady: whew.

[16:57] <pmichaud> audreyt:  %foo doesn't capture

[16:57] <pmichaud> (sorry, %moose doesn't capture)

[16:57] <audreyt> pmichaud: in that case, it can return from the toplevel match.

[16:57] <TimToady> but I haven't backlogged enough to know what you're actually discussing...

[16:58] <audreyt> so your interpretatinon would be correct

[16:58] <audreyt> TimToady: ok. suppose we have

[16:58] <audreyt> %foo = (x => /.../, y => { say 'hi' }, z => 'moose');

[16:58] <audreyt> should

[16:59] <audreyt> 'xxx' ~~ /%foo/

[16:59] <audreyt> fail or succeed?

[16:59] <audreyt> should

[16:59] <audreyt> 'yy' ~~ /^ %foo %foo $/

[16:59] <audreyt> fail or succeed?

[16:59] <audreyt> should

[16:59] <audreyt> 'zmoose' ~~ /%foo/

[16:59] <audreyt> fail or succeed?

[17:00] <pmichaud> audreyt++   excellent examples

[17:00] <TimToady> my current S05 has the last one definitely succeeding.

[17:00] <audreyt> I think "succeed" on all of them.

[17:00] <TimToady> the first fails because x traverses the first x leaving not enough for ...

[17:00] <audreyt> aha, but PGE's OpTable does it the other way

[17:01] <TimToady> the third succeeds and leaves the cursor after the first y.

[17:01] <audreyt> by resetting the begin for the "is parsed" rule for easy recognition of what was just parsed.

[17:01] <TimToady> *second

[17:01] <audreyt> TimToady: the $ assersion would fail then.

[17:01] <TimToady> yes

[17:02] <TimToady> oh, misread the 2nd

[17:02] <audreyt> so it's actually fail, fail, succeed

[17:02] <TimToady> I think second succeeds now

[17:02] <pmichaud> I'm fine with 2nd and 3rd

[17:02] <audreyt> good, that's at least consistent

[17:03] <TimToady> in my s5 hash keys are always, always matched literally under longest token

[17:03] <audreyt> now, to look at 1st closer

[17:03] <TimToady> current s5 allows rules in keys, but that's bogus

[17:03] <pmichaud> TimToady: (just more detail)  last year I asked about this -- specifically the case of

[17:03] <audreyt> the motivation is for the subrule in value slot to be able to reparse

[17:03] <TimToady> consistently the key is the literal prefix to the rule that follows.

[17:03] <TimToady> and i think the following rule can then assume that the literal has been traversed.

[17:04] <pmichaud> %foo = (x => &sub, y => &sub)

[17:04] <audreyt> if it doesn't do that, then it must take the matched part as arg

[17:04] <audreyt> e.g. sub would receive a Match that stringifies to 'x' or 'y'

[17:04] <pmichaud> so that &sub has no way to know what key caused it to be called

[17:04] <audreyt> in pmichaud's example above

[17:04] <TimToady> I think we can now make that an environment variable or some such.

[17:04] <audreyt> $+/ works for that too.

[17:05] <audreyt> or even preseeded $/.

[17:05] <TimToady> right $/ is implcitly env.

[17:05] <audreyt> but in any case, it's harder for subrules to read $+/.

[17:05] <audreyt> so in

[17:05] <audreyt> my $rule = rx{ ... };

[17:05] <audreyt> %foo = (x => $rule, y => $rule);

[17:06] <audreyt> pmichaud's idea is that the $rule can gein with

[17:06] <audreyt> (x|y)

[17:06] <audreyt> to essentially reparse the match

[17:06] <audreyt> I find this cute, but a bit inconsistent, but would prefer if a clear wording in S05 is made

[17:07] <audreyt> (otherwise I can't compile opp to rules :))

[17:08] <TimToady> another approach would be to have some way for the dispatcher to look at the rule and know whether it wanted the cursor before or after.

[17:08] <TimToady> but I still think the default should probably be after.

[17:09] <audreyt> so if I go

[17:09] <audreyt> %moose := <%foo>

[17:09] <audreyt> (or %moose := %foo)

[17:09] <audreyt> in a rule

[17:09] <audreyt> the subrules/subroutines in moose

[17:09] <audreyt> gains visibility to $+<foo>

[17:10] <audreyt> right?

[17:10] <audreyt> (is that valid shorthand?)

[17:10] <audreyt> (or do I have to write $+/<foo> ?)

[17:10] <audreyt> sorry, wrong order.

[17:10] <audreyt> /$foo := %moose/

[17:11] <audreyt> %moose = (x => { say "I matched $+<foo>" });

[17:11] *** madero joined
[17:11] <audreyt> 'x' ~~ /$foo := %moose/; # says "I matched x"

[17:11] <audreyt> sane?

[17:11] <TimToady> well $+/<foo> is certainly safer.  Maybe we can allow the shorthand.

[17:11] <pmichaud> does a called closure have any ability to affect the success of the "match"?

[17:11] <audreyt> ok. but the visibility :)

[17:11] <audreyt> pmichaud: "fail"

[17:12] <PerlJam> TimToady: Can't you just use <before <%foo>> if you want the cursor before (if it's needed for individual keys, then it should be placed on individual keys)

[17:12] <TimToady> but I'm not sure the binding to foo has happened yet.

[17:12] <pmichaud> right

[17:12] <pmichaud> I don't think the binding has occurred yet if the match hasn't succeeded

[17:12] <audreyt> TimToady: why not, though?

[17:12] <audreyt> isn't a binding a "let" form

[17:12] <audreyt> which can be backtracked later?

[17:12] <audreyt> doesn't hurt to do two let in a row

[17:13] <TimToady> I'd think if you're binding to %foo then you're inserting key/value pairs, and while you've traversed the key, you have no value yet.

[17:13] <audreyt> sorry, $foo := %moose

[17:13] <audreyt> not %foo := %moose

[17:14] <TimToady> $foo has to contain the entire %moose match then

[17:14] <pmichaud> in (modulo syntax)   %moose = ( x => rx / $+<foo> more to match / )

[17:14] <clkao> i wonder if all these seem so complicated because i know perl5 too much

[17:14] <pmichaud> and then  'x' ~~ / $foo := %moose/

[17:14] <audreyt> pmichaud: I think the cursor is already after

[17:14] <audreyt> and you only use $+<foo> for disambiguation

[17:14] <pmichaud> you're saying a subrule value doesn't move the cursor?

[17:15] <clkao> if we change the sigils to some funny unicode it might be less confusing ;)

[17:15] <audreyt> I think that's what TimToady says that should happen by default

[17:15] <audreyt> and if I get visibility of how I matched

[17:15] <pmichaud> oh, sorry, I'm making the wrong point :-)

[17:15] <audreyt> I care less :)

[17:15] <pmichaud> in  %mose = ( x => rx / { do something with $+<foo> more to match / )

[17:15] <pmichaud> arrrrgh

[17:15] <audreyt> yes.

[17:16] <pmichaud> in %moose = ( x => rx / { do something with $+<foo> } more to match / )

[17:16] <audreyt> yes.

[17:16] <audreyt> or, if you capture with (%moose)

[17:16] <pmichaud> and   'xmoretomatch' ~~ / $foo := %moose /

[17:16] <pmichaud> what's the value of '$foo'?

[17:16] <PerlJam> clkao: I think it's confusing because the semantics change from day to day on some things ;-)

[17:16] <audreyt> then $+/[-1] gets you the last capture

[17:17] * clkao PANIC

[17:17] <audreyt> pmichaud: inside the rx in %moose<x> it is x

[17:17] <audreyt> then it's re-letted into 'more to match'

[17:17] <audreyt> I mean 'moretomatch'

[17:17] <audreyt> and is what the outside sees

[17:17] <audreyt> I think it makes sens

[17:17] <TimToady> clkao: this is a sausage factory.

[17:17] <pmichaud> (I hope you mean 'xmoretomatch')

[17:17] <TimToady> not for the squeamish...

[17:18] <pmichaud> oh, maybe 'moretomatch'

[17:18] <audreyt> pmichaud: I didn't mean that but come to think about it why not :)

[17:18] <audreyt> heh

[17:18] * pmichaud decides now would be a good time to be squeamish

[17:18] <audreyt> whichever one that's saner

[17:18] <PerlJam> "moretomatch" is saner in my eyes.

[17:19] <TimToady> how about <key> backs up over the current key?

[17:19] <pmichaud> stepping back for a second, can I get a clarification of how "is parsed" should work then?

[17:19] <audreyt> TimToady: sure, that'd work

[17:19] <PerlJam> TimToady: Watching audreyt and pmichaud discuss this made me think that we should have <mark> and <rollback> assertions  :-)

[17:20] <pmichaud> I had been thinking that the keys of a hash would serve as selectors to is parsed rules

[17:20] <pmichaud> but that the is parsed rule would be responsible for the entire token, not just the part that came after the key

[17:20] <TimToady> we kind of do now, given we're probably changing grammar rules not to backtrack by default

[17:21] <pmichaud> so, if that's not the case, or if I'm making a connection that shouldn't be made, I could use a clarification

[17:21] <TimToady> that to PerlJam...

[17:23] <pmichaud> (btw, I'm *very* glad to hear that hash keys are always literal string matches, that makes me much happier)

[17:23] <TimToady> is parsed is the same way, it's only the args after what would naturally be matched by the macro name

[17:23] <audreyt> TimToady: but what of circumfix?

[17:23] <TimToady> presumably <key> could work there too.

[17:24] <audreyt> it should govern only the part inside

[17:24] <audreyt> not including the close, right?

[17:24] <TimToady> probably.

[17:24] <TimToady> if we can automate it.

[17:24] <audreyt> what of infix?

[17:24] <TimToady> see my reply on p6c

[17:24] <PerlJam> pmichaud: and when tries to use <%foo>  with rx// keys, should perl tell them to go implement that feature?  ;)

[17:24] *** buu joined
[17:25] <TimToady> it's illegal as soon as I check in my copy of S05

[17:26] <audreyt> so, infix can't reparse lhs

[17:26] <TimToady> that's what we decided at some point.

[17:26] <audreyt> and := would rewrite the AST of lhs

[17:26] <TimToady> has to just be normal expr

[17:27] <TimToady> could

[17:27] <audreyt> if it's :() literal, then it's preserved as is

[17:27] <audreyt> otherwise it checks "simple"ness

[17:27] <audreyt> and rewrite as it can

[17:27] <audreyt> if it cannot... it's an expression and it prays it evaluates to a Signature.

[17:27] <audreyt> like that?

[17:27] <TimToady> It's one of those retro things that humans have a lot less trouble with than the computer.

[17:28] <TimToady> but I'm inclined to go conservative and say :() is required on anything fancier than a variable list for now.

[17:28] <clkao> mmm sausages...

[17:28] <audreyt> the problem goes away if we have a preceding declarator

[17:28] <TimToady> like -> :)

[17:28] <pmichaud> okay, so the rule portion of an "is parsed" trait doesn't include whatever key(s) might have caused it to be called.  Okay

[17:29] <TimToady> -> $a := ...

[17:29] <TimToady> ouch.

[17:29] <audreyt> er no

[17:29] <audreyt> what I had in mind is scope declator.

[17:29] <audreyt> let $x := ...;

[17:29] <TimToady> what about ::=

[17:29] <clkao> the U+8178 operator

[17:29] <audreyt> let ($x, $y, ...some sig here) := l...

[17:29] <audreyt> same goes for ::=.

[17:29] <TimToady> temporize to compiler?

[17:30] <audreyt> no, bind at compile time

[17:30] <TimToady> let would imply that it's unbound only on failure...

[17:30] <audreyt> and temporize at runtime

[17:30] <audreyt> but I mean, any declarator would fix

[17:30] <audreyt> my ($x, $y, *@moose) := ...;

[17:31] <audreyt> and even

[17:31] <TimToady> so we get the lhs of infix macro as a parameter, the macro name is skipped but available as <key> or some such in the is parsed.

[17:31] <audreyt> my ($x, $y, [*$hd, *@tl]) := ...;

[17:31] <audreyt> (this would declare all four variables lexically)

[17:31] <TimToady> biab

[17:32] *** stevan joined
[17:32] <audreyt> and :() := ... becomes a valid form as well

[17:32] <audreyt> but ($x, $y) := foo(); would not be

[17:33] <TimToady> ungone

[17:33] <audreyt> but this is more optimized for consistency

[17:33] <audreyt> I agree for sheer ergonomics, "simple expression" is better.

[17:35] <audreyt> (but if the scope declarator idea works, then it becomes very easy to explain parameter list)

[17:35] <audreyt> sub f ($x, $y) { ... }

[17:35] <audreyt> is not unlike

[17:36] <TimToady> hmm, constant &foo := means &foo ::= maybe

[17:36] <audreyt> sub f (\$_) { my ($x is readonly, $y is readonly) := *$_; ... }

[17:36] <TimToady> if declarators influence := time as well as = time.

[17:36] <audreyt> *nod*

[17:36] <TimToady> state $x := $y at first time...

[17:37] <audreyt> declarators are already somewhat magical anyway...

[17:37] <audreyt> my ($x, undef, $y) = (1,2,3); # valid p5

[17:37] <TimToady> declarators already limit the expression to a subset of signatures, I think, so I don't see a downside.

[17:38] <audreyt> so instead of continuing the "undef" trick

[17:38] <audreyt> maybe now it can be written as

[17:38] <audreyt> my ($x, $, $y) := (1,2,3);

[17:39] <audreyt> yeah, and it's far easier to make rvalues from signatures

[17:39] <audreyt> than the other way around.

[17:39] <audreyt> in rvalue:

[17:39] <audreyt> @foo = my($x, $, $y) := (1,2,3);

[17:39] <audreyt> can simply mean

[17:39] <audreyt> @foo = ($x, undef, $y);

[17:40] <TimToady> I'd think that would declare $x and $y in the current scope.

[17:40] <audreyt> sure, extending to the right :)

[17:41] <audreyt> so actually, if we have

[17:41] <audreyt> my $x = my $y = my $z = 4;

[17:41] <audreyt> it still works all the same

[17:41] <TimToady> interestingly, if = and := are listops, then right to left associativity just falls out of it.

[17:41] <audreyt> my $x := my $y := my $z := 4

[17:41] <audreyt> would work as well.

[17:42] <audreyt> (using the declarator-signature rule)

[17:42] <audreyt> TimToady: yeah, parsing them as listops makes some sense

[17:43] <audreyt> it makes sense for all := instances

[17:43] <audreyt> what about

[17:43] <audreyt> say($x = 3, $y = 4); ?

[17:43] *** ruoso joined
[17:43] <TimToady> that's the anti-use case

[17:44] <TimToady> particlarly in loop($x = 3, $y = 4; $x; $x++, $y++)

[17:44] <audreyt> I'm find with scalar= being infix and list= infix+listop...

[17:44] <audreyt> and because := doesn't care

[17:44] <audreyt> it can always be listop

[17:44] <TimToady> that fixes += and friends as well

[17:44] <audreyt> or rather CaptureOp

[17:45] <audreyt> i.e. "is parsed" using capture rule

[17:45] <TimToady> yup

[17:45] <TimToady> it's just an arglist...

[17:45] <audreyt> in nodes without a static context

[17:45] <audreyt> foo() = 1,3,4

[17:45] <audreyt> we already say it defaults to list

[17:45] <TimToady> yu

[17:45] <TimToady> p

[17:46] <audreyt> so parsing is preditable

[17:46] <audreyt> predictable, even

[17:46] <TimToady> unpredictable parsing is always odd

[17:46] <audreyt> does that mean

[17:46] <audreyt> my $x = 3;

[17:47] <audreyt> confer scalar= because of $x is a simple Var

[17:47] <audreyt> with $ sigil

[17:47] <audreyt> but

[17:47] <audreyt> my ($x) = 3;

[17:47] <audreyt> confer list= because $x is now parsed as Sig?

[17:47] *** fglock joined
[17:47] <TimToady> I think that's what people would expect.

[17:47] <audreyt> i.e. all Sig-declarator form is naturally listop=

[17:47] <audreyt> and it even agrees with p5.

[17:47] <audreyt> (without planning for it)

[17:47] <TimToady> in particular, since my = happens exactly at the same time as ordinary assign woudl

[17:48] <audreyt> right, my point is distinguishing between

[17:48] <audreyt> my Int $x = 3;

[17:48] <audreyt> with

[17:48] <audreyt> my (Int $x) = 3

[17:48] <TimToady> only difference is the context on the right, I think

[17:48] <audreyt> yes.

[17:49] <audreyt> so after declarator, we scan for either a very very simple form of type+var

[17:49] <audreyt> or a paren, and it's sig inside it

[17:49] <audreyt> the latter always listop=

[17:49] *** pdcawley joined
[17:50] <TimToady> seems good

[17:50] <audreyt> the former might be infix= if the sigil calls for it.

[17:50] <audreyt> woot!

[17:50] <audreyt> I mean, yay!

[17:50] <pmichaud> this sounds cool

[17:50] <TimToady> I'm not so old I can't s/woot/yay/ in my head... :)

[17:50] <pmichaud> *very* nice

[17:50] <pmichaud> (assuming I'm understanding what you two are talking about)

[17:50] <TimToady> even if I'm still more than twice your age.

[17:51] <audreyt> pmichaud: you are :)

[17:51] <PerlJam> heck, even I'm understanding it :)

[17:51] <pmichaud> I don't yet understand all of the details of how to make it work, though :-)

[17:51] <PerlJam> pmichaud: That's the advantage of mostly being a lurker here ;)

[17:51] <audreyt> TimToady: so, Sig would need to function as lvalue

[17:52] <audreyt> but that's fine, I think it can be made to work

[17:52] <pmichaud> out of curiosity -- the = in   "@a = ..." would be...?

[17:52] <audreyt> :($x, $y) = 1,2; # should work.

[17:52] <audreyt> pmichaud: it would be listop= by virtue of @, I think

[17:52] <audreyt> @a = 1,2,3; # should work

[17:52] <pmichaud> same with %

[17:52] <audreyt> aye

[17:52] <TimToady> righto

[17:53] *** Alya joined
[17:53] <pmichaud> and how does the parser distinguish listop= from infix=?  I didn't fully grok that part

[17:53] <TimToady> :() = can steal constants but should still copy non-constants

[17:53] <TimToady> probably

[17:53] <TimToady> can't quite just translate to :=

[17:53] <audreyt> have to pretend it's a lvalue tuple to begin with

[17:54] <audreyt> and then work from there

[17:54] <audreyt> pmichaud: three cases

[17:54] <PerlJam> TimToady: copy? I thought it was binding (even without :=, but because it's a Sig)

[17:54] * pmichaud whips out a pen and pape...woops, this is irc!

[17:54] <TimToady> my $x = $y doesn't alias

[17:55] <PerlJam> TimToady: right, but :() = does.  right?

[17:55] *** fglock left
[17:55] <TimToady> my :($x) = $y doesn't necessarilyhave to alias either

[17:55] <TimToady> if we make people write

[17:55] *** fglock joined
[17:55] <audreyt> pmichaud: once you reach infix =

[17:55] <TimToady> my :($x) := $y to mean that.

[17:56] <audreyt> you look at $<lhs> to determine is-parsed of RHS

[17:56] <audreyt> you can do that because supposedly the "parsed" rule has access to already committed part

[17:57] <audreyt> case0: if it's a scalar-sigilled Var or Sym node -- that is, if it's term:<$> to begin with -- then it's normal infix=

[17:57] *** ghenry joined
[17:58] <audreyt> case1: if it's a declarator with no parens, i.e. "my Int $x = ...", then look at the Var part to see if it's $-sigiled. if yes, normal infix=

[17:58] <audreyt> case2: everythiing else is listop=.

[17:59] <audreyt> (this illustrates why parser combinators is a good idea as you can get the tree form of LHS instead of having to work with token match tree form.))

[17:59] <audreyt> s/tree form of LHS/P6AST tree form of LHS/

[18:00] <fglock> audreyt: is '$' a prefix op in some sense? like in ${'var'} (if this is valid syntax) so '$'+'bareword' is a scalar variable

[18:00] *** larsen joined
[18:00] <TimToady> more concretely, you can look at $() instead of just $/

[18:00] <audreyt> but even if you only have the literal match string of LHS, you can still reparse ;)

[18:00] <TimToady> ${} is dead in favor of $()

[18:00] <pmichaud> audreyt:  well, by the time I get to infix:+ i have the (parsed) version of the lhs argument already available, because of the reduction

[18:01] <TimToady> and ${'foo'} was never valid in Perl 6

[18:01] <pmichaud> the lhs is just the thing on the top of the termstack

[18:01] <TimToady> you have to write $::{'foo'}

[18:01] <audreyt> fglock: $moose is a Var term; $::('moose') is a Sym term; $('moose') is a Call on prefix:<$> with 'moose' as invocant.

[18:01] <audreyt> pmichaud: right, but at OPTable you get a Match tree not a PASTt tree

[18:01] <pmichaud> it's good enough for what I need :-)

[18:01] <audreyt> pmichaud: so you need to work with various variants of possible $-stuff

[18:02] <particle_> is ${...} valid as anything in p6, like perhaps {...} as Scalar ?

[18:02] <TimToady> $('moose') should probably fail.

[18:02] <audreyt> "my Int $x", "$()", "$/", "scalar moose", etc.

[18:02] <audreyt> TimToady: yes, by default

[18:02] <audreyt> TimToady: in the backlog there is a crazy idea of defining it to return

[18:03] <audreyt> "document.getElementById($_)"

[18:03] <audreyt> to make Perl6 compatible with prototype.js.

[18:03] <audreyt> but it's userland -- railland, in particular.

[18:03] <PerlJam> So ... is this valid perl6?    [=] my($x,$y,$z), 5;  # or something similar?

[18:04] <TimToady> I don't think we should negate the benefits of checking for accidental symbolic refs.

[18:04] <Juerd> PerlJam: Heh. Even if it's valid, please never use it :)

[18:04] <audreyt> PerlJam: I think it's kosher

[18:04] <pmichaud> come to think of it, I don't think it would that difficult to get the opp to return the past

[18:05] <pmichaud> s/past/p6ast/

[18:05] <pmichaud> it already does it for p6rules

[18:05] <audreyt> pmichaud: uh, how'd you do that with TGE?

[18:05] <Arathorn> ooooh

[18:05] <pmichaud> currently I'm using tge to transform the parse tree to an ast

[18:05] <audreyt> partial trees doesn't neccessarily compile

[18:06] <audreyt> or compile the same way as toplevel

[18:06] <audreyt> s/toplevel/it would be on/

[18:06] <particle_> my($a, $b) << 5; # same as [=] my($x,$y,$z), 5;  ?

[18:06] * Arathorn finally ges the $('moose') <---> document.getElementById('moose') thing from earlier

[18:06] <Arathorn> by redefining "as Scalar" for strings to invoke document.getElementById

[18:06] <particle_> s/same/similar/

[18:06] <audreyt> Arathorn: yeah. but really, bad idea :)

[18:06] <PerlJam> particle_: I think you need a = near the <<  :)

[18:07] <Arathorn> well, at least i understand it

[18:07] <audreyt> Arathorn: _maybe_ makes sense on the JavaScript target.

[18:07] <audreyt> it can be quite convenient.

[18:07] <audreyt> but otuwise $*OS=='browser'... probably not good :)

[18:07] <audreyt> s/otuwise/outside/

[18:07] <TimToady> probably a bad idea to be incompatible too

[18:08] <audreyt> oh, sure, it's all userland :)

[18:08] <particle_> perljam: sorry, typo, yep.

[18:09] <audreyt> pmichaud: in any case, I think it'd be easier to ask the AST tree object

[18:09] <audreyt> "do you confer scalar context on lvalue?"

[18:09] <pmichaud> right

[18:09] <audreyt> than somehow reconstruct this info by matching against parse tree

[18:09] <audreyt> the latter way is... not really fun

[18:09] <pmichaud> I'm wondering if we can build the ast lazily

[18:10] <audreyt> that's what parser combinators do...

[18:10] <audreyt> but parrot has no native thunks

[18:10] <audreyt> so you'd need to somehow wing it.

[18:10] <pmichaud> well, tge is essentially thunking things already

[18:10] <pmichaud> (if I understand it)

[18:11] <pmichaud> lately I've been toying with the notion of "returns" traits on rules

[18:11] <audreyt> internally

[18:11] <audreyt> but the return value is eager

[18:12] <audreyt> and if there is a lot of backtracking, we want the return value be thunked

[18:12] <audreyt> fortunately, p6 doesn't have much backtracking

[18:12] <audreyt> so eager tree construction is fine I think

[18:12] <pmichaud> I can certainly return a lazy something, yes?

[18:13] <audreyt> sure, but if commit dominates, thunk creation cost overshadows saved scratch backtracked objects

[18:13] <audreyt> (unless you make thunk creation cost really really low.)

[18:13] <audreyt> (but that's not parrot.)

[18:13] <pmichaud> I'll have to thunk about it some more

[18:13] <audreyt> who would have thunk of that

[18:13] <pmichaud> ...over lunch, at that :-)

[18:14] <pmichaud> btw, this was all a side-question off of the original discussion of terminating rule expressions.  :-)

[18:14] <PerlJam> If you're strictly talking about the bootstrap, "cost" doesn't matter too much and you can choose whichever way is easiest to understand/use.

[18:15] <audreyt> pmichaud++ TimToady++ # /%x/ consistency; visibility of <key>; my (SIG); listop=; "is parsed" semantics

[18:15] <pmichaud> but I'll come back to that later.  Essentially I'm guessing the termination character will have to be passed out of band

[18:15] <audreyt> we got a lot of things done :)

[18:15] <TimToady> BLing, I'm worried that P5 folk will continually misunderstand $$foo[$bar]

[18:16] <TimToady> precedence now makes that $($foo[$bar]) and they'll expect ($$foo)[bar]

[18:16] <TimToady> I wonder if we should outlaw $$

[18:16] <audreyt> $$foo[bar] in p5 means $foo.[bar]

[18:16] <PerlJam> TimToady: There's lots more gotchas for p5 folk.  One more won't hurt (much)  ;)

[18:17] <audreyt> not $$foo.[bar]

[18:17] <audreyt> so if they expect $$foo.[bar], they deserve to get surprised

[18:18] <TimToady> $$foo.bar then

[18:18] <Arathorn> TimToady: i made that mistake earlier today, fwiw

[18:18] <Arathorn> (as a token p5 folk)

[18:18] <TimToady> is now $($foo.bar), and p5 folk will parse ($$foo).bar

[18:18] <Arathorn> http://colabti.de/irclogger/irclogger_log/perl6?date=2006-04-19,Wed&sel=143#l222 to be precise

[18:19] <Arathorn> anyway

[18:19] *** Arathorn is now known as Aragone

[18:19] <TimToady> indeed, that's why I brought it up

[18:19] <audreyt> why can't we say parse that as part of regular Var rule?

[18:19] <audreyt> that is, make <sigil>+<name> always bind together

[18:19] <TimToady> well, that's essentially what P5 does

[18:19] <TimToady> Just means $ $foo is different from $$ foo.

[18:20] <TimToady> $$foo, even

[18:20] <audreyt> and both are different from $$foo.

[18:20] <audreyt> oh wait, no, $ $foo is same as $$foo.

[18:20] <TimToady> in result, but not in precedence

[18:20] <audreyt> right.

[18:21] <audreyt> that is what p5 people would expect

[18:21] <audreyt> and I don't see anything inherently wrong

[18:21] <audreyt> $foo already doesn't mean $(foo())

[18:21] <audreyt> so it's just generalization of the same rule

[18:21] <TimToady> it's just sort of recursive twigils...

[18:21] <audreyt> maybe they are called pregils...

[18:21] <TimToady> sigils as recursive twigils

[18:22] * pmichaud votes for zigils

[18:22] <TimToady> but then what's $$$foo?

[18:22] <audreyt> sligils

[18:22] <TimToady> nsigils?

[18:22] <pmichaud> $$$make $$$money $$$fast

[18:22] <audreyt> pmichaud++

[18:22] <PerlJam> audreyt++ :)

[18:23] <pmichaud> time for a break -- bbiah

[18:23] <audreyt> sligilsligilsligils # mm pretty bridge

[18:23] <TimToady> Maybe they're all just igils

[18:23] <TimToady> but some are more igil than others

[18:24] <audreyt> ok, I need to get a ^C also

[18:24] <audreyt> good night :)

[18:24] <audreyt> &

[18:24] <TimToady> let's see that 0..speed of light

[18:24] <TimToady> almost

[18:24] <TimToady> nite

[18:24] <audreyt> TimToady: so, follow up on p6c thread?

[18:25] <TimToady> k

[18:25] *** zgh joined
[18:27] <pmichaud> did we decided on $<key> and $<lhs> in "is parsed", or were those just idea placeholders with syntax to be determined later?

[18:27] <pmichaud> s/decided/decide

[18:28] <audreyt> <key> would be special rule in fact

[18:28] <pmichaud> and maybe $<lhs> should be $<pre>

[18:28] <audreyt> no idea about $<lhs>- $<pre>

[18:28] <pmichaud> oh, special rule

[18:28] <audreyt> sigh

[18:28] <pmichaud> okay, I can do that

[18:28] <audreyt> (sigh = preempted :))

[18:28] <particle_> make that 0..^speed of light

[18:28] <audreyt> woot! MSR paid for my YAPC::NA trip!

[18:29] <audreyt> MSR++

[18:29] <pmichaud> so, <key> is a special subrule that returns the hash key that caused the rule to be called

[18:29] <audreyt> yes.

[18:29] <pmichaud> I agree, no idea bout <pre>

[18:29] <pmichaud> I'll think about it :-)

[18:29] <audreyt> probably not <pre> :) probably visibility as $<pre>

[18:30] <audreyt> or even just as $/.

[18:30] <audreyt> but you'll think about it and I'll sleep :)

[18:31] <audreyt> &

[18:39] *** b_jonas joined
[18:39] *** FurnaceBoy joined
[18:43] <TimToady> left side is passed as an official parameter to macro, so could be seen in "is parsed" directly, or passed in as a parameter to an indirect rule.

[18:45] <TimToady> <key> is a bit of a placeholder insofar as it might be clearer to call it <token> or some such that works for both macro name and <%hash> key.

[18:47] <TimToady> course, the macro name turns into a key in some <%hash> somewhere, so maybe <key> is still fine from the grammar writer's point of view.

[18:47] <pmichaud> a couple of questions

[18:47] <pmichaud> first, this means that whatever processes the rule in   "is parsed( ... )"  has to know that the ... is receiving a extra parameter

[18:48] <pmichaud> yes?

[18:48] <pmichaud> (either that, or all rules have to assume they're receiving extra params, or all rules have slurpy things, either of which is fine w/me)

[18:48] *** weinig joined
[18:48] <pmichaud> s/slurpy things/slurpy args

[18:48] <TimToady> all methods implicitly have %_

[18:49] <pmichaud> okay, great, excellent

[18:49] <pmichaud> I had forgotten about that -- that has some wonderful ramifications (in a good sense) for rules

[18:49] <pmichaud> thank you

[18:50] <pmichaud> (I hadn't forgotten, just didn't make the connection)

[18:50] <TimToady> as in natural language, you can always put an adverb on the verb.  The listener may, of course, not be able to make heads or tails of it.

[18:50] <pmichaud> my other question:  do we just have a single infix:=, or are there separate "things" for assignment?

[18:50] <pmichaud> (one more after this, actually)

[18:50] <TimToady> Please pass the gravy graphically.

[18:51] <TimToady> not sure quite what you're asking

[18:51] <pmichaud> I'm looking at it from a parsing perspective; and trying to find out if I need to break some simplifications (more)

[18:51] <pmichaud> we have a scalar = that parses at one level of precedence, and a list = that parses at another

[18:52] <pmichaud> are they both known as "infix:=", or is there something that separates them?

[18:52] <TimToady> I think that's all the parser needs to know.  semantically you have to know when the assignment happens

[18:52] <TimToady> since the declarator can change that.

[18:53] <pmichaud> okay, then I didn't understand what was being said earlier

[18:53] <TimToady> and, in a sense, the parser then needs to know that constant $x = 1

[18:53] <TimToady> happens immediately

[18:53] <pmichaud> how can   @a = 1, 2, 3, 4   work if = is higher precedence than , ?

[18:54] <TimToady> At the point that macro infix:<=> fires off, it dispatches "is parsed" based on its lhs's characteristics.

[18:55] <TimToady> could even be "is parsed(test() ?? /foo/ !! /bar/)" I suppose.

[18:55] *** nicbrown joined
[18:55] <TimToady> test($lhs) rather

[18:55] <pmichaud> okay, yes, this will get tricky then

[18:55] <pmichaud> I definitely have to do a bunch of stuff to the opp

[18:55] <TimToady> depends on subsequent things seeing the bindings earlier in the macro declaration.

[18:56] <pmichaud> @a = 1, 2, 3, 4    and   @b = 5, 6, 7

[18:56] <TimToady> or could just call in with a different precedence.

[18:56] <pmichaud> right, the opp doesn't have a precedence parameter yet

[18:56] <pmichaud> but that becomes easy now that all rules take %_

[18:57] <pmichaud> s/easy/easier

[18:57] <TimToady> :) * .5

[18:57] <pmichaud> (still easier now that parrot's slurpy hashes actually work when slurpy arrays are present)

[18:59] <TimToady> phone call in an hour, wandering here and there in the house to eat lunch and stuff...

[19:00] <TimToady> any other questions for now?

[19:00] <pmichaud> I have one last question but I'm trying to get the phrasing correct

[19:00] <TimToady> "How did an idiot like you get put in charge of Perl?"

[19:00] <TimToady> :)

[19:00] <pmichaud> no, that's not it

[19:00] <pmichaud> okay, I have it

[19:01] <pmichaud> for convenience I defined a special "prelist" category to handle listops  (e.g., say, etc.)

[19:01] <pmichaud> think it would be possible to use something like a prefix_meta*:<> to do it?

[19:02] <pmichaud> or maybe prefix_circumfix_meta_operator:<>

[19:02] <pmichaud> it probably doesn't matter now since you've described infix:= as a macro

[19:03] <pmichaud> so, never mind.  I'll come back to it if it makes sense later

[19:03] <TimToady> in fact, maybe %prefix rule could do similar trick to figure out which prefixes are listy.

[19:03] <pmichaud> ooooh

[19:04] <pmichaud> *that* sounds pretty good

[19:04] <pmichaud> the trick has always been that a listop has one precedence coming in and another going out

[19:04] <TimToady> <%prefix|%prelist> could still do longest token, and then you could use normal lookup.

[19:05] <TimToady> I always thought of list ops as a left paren without a right paren.

[19:05] <TimToady> so it'd be fine by me to do top-down at that spot.

[19:05] <pmichaud> i.e.,   in   3 && say 'ok',    the say looks like a term to the && but like a low-precedence paren to its list

[19:05] <pmichaud> I'm still holding the possibility of doing it top-down in reserve, but I have this feeling that it gets a little messy when dealing with postfixes and other ops

[19:06] <TimToady> top-down handles surreal prec nicely.

[19:06] <TimToady> instead of forcing parens to handle it.

[19:06] <pmichaud> my observation is that it's very similar now to what we're doing with infix:=

[19:06] <TimToady> depends on how well you parameterize the terminator set.

[19:07] <TimToady> is parsed is top-down by definition.

[19:07] <pmichaud> yup

[19:07] <pmichaud> okay, that gives me plenty to go on

[19:07] <pmichaud> many thanks

[19:07] <TimToady> a macro is just a term, and a term implies top-down to me.

[19:07] <TimToady> yer welcum.

[19:07] <pmichaud> just out of curiosity, would you strongly *prefer* that listops be done top-down instead of the path I had been taking?

[19:08] <TimToady> course infix macro ain't a term, but we'll gloss over that...

[19:08] <TimToady> I think it's likely to produce better error messages in the long run

[19:08] <TimToady> and it's not that big a speed hit.

[19:08] <pmichaud> I agree it's not a speed hit

[19:08] <TimToady> so my guess is that it'd be better.

[19:09] <TimToady> and maybe cleaner, given you can clean the infinities out of precedence handling

[19:10] <pmichaud> okay.  I'm going to lunch, thanks again

[19:10] <TimToady> me too, see you in 50 minutes

[19:10] <pmichaud> omg, it's 19:10 already?!?

[19:10] <pmichaud> (the day has gone)

[19:11] <pmichaud> I didn't connect your "phone call in an hour" comment, sorry

[19:31] *** PolettiX joined
[19:32] *** PolettiX is now known as froh-doh

[19:34] *** hexmode joined
[19:36] <obra> indeed. time moves quickly

[19:36] <obra> Can Perl6 fix time for me?

[19:36] <clkao> the time machine operator

[19:37] <PerlJam> clkao: it makes time?

[19:37] <clkao> maybe zips

[19:38] <TimToady> you'll have to take that up with TheDamian

[19:42] <particle_> do some profiling... DProf gives negative timing on some subs

[19:44] <TimToady> Kind of like those waves that the front can travel faster than light if you ignore the fact that the average is still C.

[19:44] <obra> "But Perl is far beyond C"

[19:44] <obra> I,I "Light years ahead of C"

[19:45] <particle_> fixing time is a hard thing, but perl 6 makes it possible

[19:46] <TimToady> Maybe Perl is really a language from the 22nd century.  I'll never tell.

[19:47] <particle_> at this pace, it just might be :)

[19:47] <ruoso> heh

[19:49] <ruoso> that's the problem of Perl 6 being so lazy...

[19:49] <TimToady> audreyt: I think @ signifies orderedness, but .[] implies integer keys to the extent that the optimizer is allowed to assume it.

[19:49] <TimToady> audreyt: but @foo may supply a Hash role, and %foo may supply an Array role.

[19:50] <TimToady> (backlogging cont...)&

[19:51] <PerlJam> perl6 is clearly the work of a madman  ;)

[19:53] <pmichaud> "design by committee" rears its head, too :-|

[19:53] *** lk joined
[19:53] <pmichaud> fortunately the committee is headed by madmen and madwomen, so we should be safe

[19:54] <TimToady> I think Audrey is maybe the time traveler.

[19:54] <TimToady> would explain a lot.

[19:55] <lk> hihi

[19:55] *** lk is now known as lichtkind

[19:55] <PerlJam> when audreyt talks to herself, she *really* talks to herself (from the future)

[19:59] *** DaGo joined
[19:59] <TimToady> would also explain the cavalier attitude to gender, if they have girl-boy guns by then.  I read that in the TFOS guide.

[19:59] *** gru joined
[19:59] *** ghoq joined
[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:00] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ruoso> geez

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <rw-rw-r--> ...

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <rw-rw-r--> How do they cram that much stupid into one human being's head?

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <pmichaud> times like this, /ignore comes in handy :-)

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] *** gru left
[20:01] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:01] <particle_> any ops about?

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] <ghoq> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[20:02] *** ghoq left
[20:02] <ruoso> poor irc logger

[20:04] <kolibrie> what is the name of the script to set up SVK properties on new files?

[20:04] <particle_> was that an Acme:: module in action

[20:04] <ruoso> nah... Acme:: are supposed to be funny

[20:06] <TimToady> patrick, are you able to get through to 6p call?

[20:07] <kolibrie> found it: util/add-svn-props.sh

[20:07] <pmichaud> TimToady: no

[20:07] <TimToady> probably time keyed...

[20:08] <PerlJam> pm: the rest of the cabal is really trying to give you a hint about something  ;)

[20:10] <obra> TimToady: you saw my irc msg?

[20:10] <svnbot6> r10041 | kolibrie++ | initial import of compile_p6grammar.pl

[20:10] <svnbot6> r10041 | kolibrie++ | * compiles grammars in Perl 6 syntax into Pugs::Compiler::Rule-based Perl 5 modules

[20:11] <TimToady> obra: yes, I did.

[20:13] *** coumbes joined
[20:26] *** saorge joined
[21:11] *** merlyn joined
[21:11] *** high-rez joined
[21:12] *** high-rez left
[21:15] *** aufrank joined
[21:15] <aufrank> hello all!

[21:16] <merlyn> all("hello")? :)

[21:17] <lichtkind> was that valid perl6?

[21:18] <theorbtwo> all("hello") is.

[21:19] * Toaster read that all("hellow") works in C too :D

[21:22] <theorbtwo> I'm not sure it's terribly meaningful making a single-element conjunction, but it's certianly legal.

[21:22] *** heng joined
[21:29] *** beppu joined
[21:32] *** FurnaceBoy_ joined
[22:20] <ruoso> wow... we'll have the first "brazillian lisp users meeting" in the FISL...

[22:20] <ruoso> that surprised me...

[22:36] *** Limbic_Region_ joined
[22:36] *** Limbic_Region_ is now known as Limbic_Region

[23:02] *** pdcawley joined
[23:10] *** brad_ joined
[23:18] *** Bgah joined
[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <amv> \o/

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <Bgah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:18] <ruoso> again...

[23:18] <particle_> aren't there any channel ops here?

[23:19] <ruoso> I think it's time to have a bot op

[23:19] *** Bzagah joined
[23:19] <ruoso> to kill flood bot

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] *** colares joined
[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:19] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:20] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:20] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:20] <Bzagah> #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai #fazlamesai

[23:20] *** Bzagah left
[23:22] <beppu> wtf?

[23:22] <theorbtwo> beppu: Spam.

[23:22] <FurnaceBoy_> some guy in Wilmington Delaware, spamming freenode

[23:23] <FurnaceBoy_> or using a zombie there :|

[23:26] <svnbot6> r10042 | uzair++ | P6-style $0 was being used in the P5 version of the example.

[23:29] *** lilo joined
[23:29] * lilo looks in

[23:30] <lilo> hi all....is everyone here mostly registered to nickserv and identified?

[23:30] <ruoso> I think mostly are...

[23:31] <lilo> hmmmm

[23:31] <lilo> let me see what I've got here

[23:33] <theorbtwo> lilo: If you don't log yourself there's a log at irc.pugscode.org

[23:33] <ruoso> BTW... I asked lilo for help about the spam bot...

[23:45] *** Khisanth joined
[23:48] *** ruoso left
