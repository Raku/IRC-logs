[00:03] <markstos> I can't find any tests for "Calling Sets of Methods": http://feather.perl6.nl/syn/S12.html#Calling_sets_of_methods

[00:03] <lambdabot> Title: S12, http://tinyurl.com/ga3uw

[00:03] <markstos> so I'm going to add some.

[00:05] <markstos> This is exactly a feature I could use to clean up some code in CGI::Application. We use it to implement a plugin scheme there, going to the inheritence tree to call all the methods any class for particular plugin slots.

[00:05] *** jferrero joined
[00:07] <TreyHarris> markstos: to answer the question in your comment (how to just pass %h), there are at least three ways, none of which are currently supported

[00:07] <markstos> audreyt mentioned [,]%h, which I guess is one of them.

[00:07] <TreyHarris> 1. test_dispatch(%h:<m1 m2 call expect>)

[00:07] <TreyHarris> 2. test_dispatch([,](%h))

[00:08] <TreyHarris> 3. sub test_dispatch ({:$m1, :$m2, :$call, :$expect}) ... test_dispatch(%h)

[00:08] <markstos> So only #2 allows to pass through truly arbitrary data.

[00:08] <TreyHarris> no, none of them do

[00:09] <TreyHarris> well, only three does, if you do it like this:

[00:09] <TreyHarris> 3. sub test_dispatch ({:$m1, :$m2, :$call, :$expect, *%arbitrary_hash_data}) ... test_dispatch(%h)

[00:09] <markstos> [,]%h looks arbitrary. :)

[00:10] <TreyHarris> nope, named arguments have to be named arguments... if there are keys in %h that don't map to named arguments of test_dispatch, and test_dispatch doesn't accept a slurpy hash, then you're calling the subroutine with extra parms and will get a failure at runtime.

[00:10] <TreyHarris> s/parms/params/

[00:11] <audreyt> markstos: as re

[00:11] <audreyt> 01:38 < svnbot6> r12965 | markstos++ | The spec is not specific about multi method dispatch details, saying:

[00:11] <clkao> *yawn*

[00:11] <audreyt> markstos: please see docs/notes/mmd-draft.txt

[00:11] <markstos> So [,]%h, plus a slurpy hash is a solution.

[00:11] <audreyt> markstos: I've been trying to get TimToady bless it :)

[00:11] * TreyHarris waves at audreyt

[00:11] <audreyt> markstos: but it's the closest as we have for the dispatch defaults

[00:11] <TreyHarris> audreyt: we've been on different circadians for several days now :-)

[00:11] <audreyt> we have.

[00:12] <markstos> audreyt:  Wow, it's been 8 hours  since you went to sleep already. I should go outside before it's dark here...

[00:12] <TreyHarris> audreyt: did you notice the interactive problem with LoH literals I've been mentioning for a few days now?

[00:12] <audreyt> I managed to completely miss it.

[00:12] <clkao> audreyt: hey. how about making jifty's moosification with Web::Field::* converted first. they seem more isolated

[00:12] <markstos> audreyt: I'll review that doc. Thanks.

[00:12] <audreyt> clkao: sure, feel free to pickup the branch and run with it...

[00:13] <TreyHarris> audreyt: only at the interactive pugs prompt, not in read code, and not in -e, and not in eval, "({a => 'a'}, {b => 'b'})" segfaults

[00:13] <clkao> audreyt: i meant how about you finishing it up ;)

[00:13] <audreyt> clkao: or, if you want me to do the pickup, that probabaly needs to wait till next week

[00:13] <clkao> alright. i will haraess you next week

[00:13] <audreyt> I have pugs releng to do first :)

[00:13] <TreyHarris> audreyt: i was at a total loss as to how to document with a test short of implementing Expect in P6 :-)

[00:13] <audreyt> "until next week"

[00:13] <clkao> "hide until"

[00:14] <audreyt> TreyHarris: it doesn't segfault for me

[00:14] <audreyt> TreyHarris: so give me a gdb bt?

[00:14] <audreyt> gdb ./pugs

[00:14] <audreyt> run

[00:14] <audreyt> pugs> expr

[00:14] <audreyt> bt

[00:14] <markstos> Are all of these considered current? docs/notes/mmd.kwid  docs/notes/mmd_match_order.txt  docs/notes/multimethods.pod

[00:15] <audreyt> markstos: no. oh wow

[00:15] <audreyt> sorry. only misc/pX/Common/mmd-draft.txt is current

[00:15] <audreyt> the others are materials to make misc/pX/Common/mmd-draft.txt

[00:15] <markstos> ?eval @%(a => <b>)<a>

[00:15] *** evalbot_12953 is now known as evalbot_12966

[00:15] <evalbot_12966> (no output)

[00:15] <pasteling> "TreyHarris" at 207.171.180.101 pasted "gdb output showing segfault on LoHs" (17 lines, 620B) at http://sial.org/pbot/19433

[00:16] <audreyt> ?eval @(%(a => <b>)<a>)

[00:16] <evalbot_12966> ["b",]

[00:16] <markstos> TreyHarris: My eval might related to your segfault: It segfaults too, which is why evalbot doesn't return.

[00:16] <markstos> I added a test for it in t/data_types/hash.t

[00:16] <audreyt> it dies in showHex! wow

[00:16] <audreyt> completely unexpected

[00:17] <audreyt> this GHC 6.4.1 on powerpc?

[00:17] <TreyHarris> 6.4.2, ppc

[00:17] <audreyt> okie. fixing

[00:17] <TreyHarris> but it has been seen on linux and on 6.4.1

[00:17] <clkao> what's exciting in new release?

[00:18] <audreyt> clkao: embed perl5 by default; 2x+ faster runtime, esp. compiled with GHC 6.6; support UTF* in source; Roles actually work instead of being poor inheritance imitations

[00:19] <clkao> (!)

[00:19] <clkao> embed perl5 by default? how come?

[00:19] <audreyt> much faster sparse arrays and hashes

[00:19] <audreyt> how come not? I think it's culturally important

[00:19] <audreyt> as it enables us to use PCR isntead of PGE for rx://

[00:19] <markstos> I think it's important to.

[00:19] <audreyt> and P5Re instead of PCRE for rx:P5//

[00:19] <audreyt> and Moose and Data::Bind for callconv.

[00:19] <audreyt> (to p5land)

[00:19] <markstos> With it, I think people will use the CGI::App port sooner.

[00:20] <markstos> Without out, it's a hassle to get a decent default template engine.

[00:20] <audreyt> yes. having to enable p5embed by hand was only a workaround because activeperl was b0rk

[00:20] <audreyt> but now it's fixed, there's no excuse anymore

[00:20] <audreyt> as per spec, any perl6 implementation must be able to run perl5.

[00:20] <markstos> That's part of the spec, though? *surprised*.

[00:21] <audreyt> yes. S01:

[00:21] <audreyt> Migration is important.  The perl interpreter will assume that it

[00:21] <audreyt> is being fed Perl 5 code unless the code starts with a "class" or

[00:21] <audreyt> ...

[00:21] <audreyt> and other various places.

[00:21] <markstos> Right. I recall that now.

[00:21] <clkao> wsaueggcellent

[00:22] <TreyHarris> audreyt: i tried to do use p5:IO::Prompt, and the only way I found to call prompt was via perl5:IO::Prompt.can('prompt').  is this expected behavior?

[00:22] <audreyt> TreyHarris: no. you should be able to

[00:22] <audreyt> use perl5:IO::Prompt 'prompt';

[00:22] <audreyt> prompt(...)

[00:22] <audreyt> the "default import" doesn't yet quite work with our lexical import

[00:22] <clkao> remembre to put something in __DATA__...

[00:22] <audreyt> so you need to be explicit

[00:22] <audreyt> for now

[00:22] <clkao> iirc that was on my list

[00:23] <clkao> but it didn't seem that people care

[00:23] <audreyt> people will start to care very soon.

[00:24] <pasteling> "TreyHarris" at 207.171.180.101 pasted "audreyt++'s syntax worked, but it panicked" (4 lines, 250B) at http://sial.org/pbot/19434

[00:24] <audreyt> oy.

[00:24] * audreyt looks at clkao

[00:24] <clkao> are we set in pdx hackathon?

[00:24] <clkao> lets fix that in yapc::sa? ;)

[00:24] <audreyt> i've been waiting from semaphor from bestpractical

[00:25] <audreyt> sure ;)

[00:25] <audreyt> s/from/for/

[00:25] <clkao> Want is evil

[00:25] <audreyt> as befits damian's module

[00:25] <clkao> okay. let's sort it out tomorrow. i should book my tickets

[00:25] <audreyt> 'k

[00:25] * clkao plans birthday drinks

[00:26] <audreyt> ah right. your birthday is nigh

[00:26] <markstos> audreyt: mmd-draft.t doesn't mention optionals at all. Should I patch it ?

[00:26] <clkao> yaq

[00:26] <clkao> horrible

[00:26] <audreyt> markstos: sure!

[00:27] <audreyt> markstos: that algorithm should get reflected Sub::Multi in full, too, which is another piece of p5 hacking open for hacking :)

[00:27] <clkao> aaaaaah!

[00:28] <clkao> i irc there was soemthing blocking

[00:28] <markstos> Let's see about getting it blessed before we start spreading around implementations of it too far.

[00:28] <clkao> i can't remember

[00:28] <TreyHarris> is anybody using irssi and actually seeing the random non-ascii strings that show up on here regularly?  and if so, is there some trick?  (i'm using a unicode font that has the characters in question for my terminal.  but i'm also using screen, which maybe is the problem)

[00:28] <clkao> see, iam getting old

[00:28] <audreyt> markstos: I think the only nonblessed part is syntax, actually.

[00:28] <audreyt> markstos: namely, the use of

[00:28] <audreyt> sub f ($x ; $y ;; $z)

[00:28] <clkao> audreyt: qtell me again about this *@@; thingy

[00:28] <audreyt> to denote levels instead of

[00:28] <markstos> The double semicolon ?

[00:28] <audreyt> sub f ($x ; $y ; $z)

[00:28] <audreyt> to denote the same thing

[00:28] <audreyt> yes.

[00:29] <audreyt> clkao: ok... when you pass in multiple feeds

[00:29] <markstos> Ok. What I have to say about optionals probably won't make any headway on the double semi-colon debate.

[00:29] <audreyt> each feeds being a list of pos and a map of nam

[00:29] <audreyt> markstos: it's purely syntax, too, so orthogonal to optionals

[00:30] <clkao> mmmmmmm seems complicated

[00:30] <audreyt> clkao: and when the Sig part is of sigil @@x on slurpy position

[00:30] <audreyt> then @x is bound to a list of that feeds

[00:30] <markstos> I don't think it's purely syntax, as it also implies an extra level of distinction, which otherwise wouldn't exist.

[00:30] <audreyt> with each element being a Capture of nam/pos of that feed slice

[00:30] <audreyt> markstos: uhm no. the spec currently already makes that level of distinction

[00:30] <audreyt> markstos: the spec currently says

[00:31] <audreyt> "add one semi at end if there's no semi"

[00:31] <audreyt> "then, the final semi denotes ;;"

[00:31] <audreyt> semantically it's entirely equivalent

[00:31] <audreyt> it's the same underlying model

[00:31] <markstos> interesting.

[00:31] <clkao> airhgt... so there can be names+pos in each ;-separated ones

[00:31] <clkao> ?

[00:31] <audreyt> yes.

[00:31] <clkao> give me an example

[00:31] <clkao> ?

[00:31] <clkao> is it somewhere in example/ or t/ ?

[00:31] <markstos> Anyway, perhaps the new optionals clause will nudge resolution on that issue.

[00:32] <audreyt> clkao: no, examples only has

[00:32] <audreyt> for each(1,2,3;4,5,6) { ... }

[00:32] <clkao> aaah what should it be doing

[00:32] <audreyt> iterating thru 1,4,2,5,3,6

[00:33] <audreyt> markstos: cool

[00:34] <clkao> what's the prototype like?

[00:34] <TreyHarris> markstos: what is your tweak involving optionals?

[00:35] <markstos> TreyHarris: I'm thinking it through now, but will make all tests pass that I just sent to p6l when I wrote about the issue there.

[00:35] <markstos> s/will/it will/ :)

[00:36] *** spoopithy is now known as spoop

[00:36] <markstos> I hope it will just clarify what people expect to happy anyway. :)

[00:38] *** lectus joined
[00:41] *** nothingmuch joined
[00:42] <markstos> The optionals rule boils down to this, which addresses all the related tests:

[00:42] <markstos> For each optional parameter, a case with and without the optional parameter is considered, and the case with it is attempted to match first.

[00:42] <lectus> Is perl 6 available for windows?

[00:43] <audreyt> lectus: yes, try http://www.jwcs.net/~jonathan/perl6/

[00:43] <lambdabot> Title: Jonathan Worthington :: Perl 6 / Parrot

[00:43] <lectus> thanks

[00:44] <lectus> is it possible to test perl 6 without touching my current Active Perl setup?

[00:46] <markstos> I don't even think we need the clause: "and the case with it is attempted to match first.", because when you consider an optional parameter as two cases, best matching spec'ed elsewhere should Do The Right Thing.

[00:49] <TreyHarris> markstos: do you mean that it's possible that you will call a multi with an optional parameter that doesn't exist in the signature of the sub you end up calling?  that seems very.... perl5ish... maybe not in a bad way.  i'm just not used to Perl 6 ignoring extra parameters the sub doesn't refer to

[00:49] <svnbot6> r12967 | markstos++ | Add section on optionals and slurpies to mmd-draft.txt,

[00:49] <svnbot6> r12967 | markstos++ | which was otherwise unaddressed.

[00:49] *** ayrnieu joined
[00:50] <markstos> TreyHarris? Could you clarify with an example? I included some examples I had in mind in the change I made.

[00:50] <TreyHarris> looking...

[00:51] <markstos> be back in 20 min or so.

[00:53] <TreyHarris> audreyt: what do you think of my suggestion of changing but's semantics to clone, and to have a "is cloned" parameter trait?

[00:55] <audreyt> lectus: sure

[00:56] <audreyt> lectus: if you'd like to use your activeperl modules with perl6, maybe helps us testing the perl5 embedding?

[00:56] <audreyt> lectus: you can do that by installing TortoiseSVN or Subversion

[00:57] <audreyt> check out http://svn.openfoundry.org/pugs/ with it, installing GHC by extracting http://haskell.org/ghc/dist/current/dist/ghc-6.5.20060819-i386-unknown-mingw32.tar.gz into c:\ghc\, and then

[00:57] <lambdabot> Title: Revision 12954: /

[00:57] <audreyt> perl Makefile.PL

[00:57] <audreyt> nmake

[00:58] <audreyt> on the checked-out pugs directory

[00:58] <audreyt> that should give you a pugs.exe that can use perl5 modules installed in activeperl

[00:58] <audreyt> TreyHarris: deep clone?

[01:08] *** theorbtwo joined
[01:10] *** weinig|bbl is now known as weinig

[01:12] <pasteling> "TreyHarris" at 207.171.180.101 pasted "cloned trait" (10 lines, 279B) at http://sial.org/pbot/19435

[01:12] <TreyHarris> audreyt: i was thinking like that ^^^^

[01:12] <audreyt> yay, the GHC pumpking solved the segfault

[01:12] <audreyt> nice that there's dedicated fulltime support for GHC nowadays :)

[01:13] <nothingmuch> audreyt: http://nothingmuch.woobling.org/MO/

[01:13] <lambdabot> Title: Index of /MO

[01:13] <nothingmuch> very simple split runtime/compile time metamodel

[01:13] <nothingmuch> single inheritence, stupid attrs with rw accessors

[01:13] <nothingmuch> but all nicely decoupled

[01:13] <nothingmuch> c3 MI + roles tomorrow, maybe

[01:13] <nothingmuch> then smarter layouts

[01:14] <nothingmuch> then foreign dispatch types

[01:14] <nothingmuch> it needs to not uses hashes as rvalues

[01:14] <nothingmuch> but aside from that i'm happy with the code

[01:14] <svnbot6> r12968 | audreyt++ | * Igloo++ solved the showHex segfault, by advising us to

[01:14] <svnbot6> r12968 | audreyt++ |   unsafeCoerce# into an unboxed word (Word#) instead of a

[01:14] <svnbot6> r12968 | audreyt++ |   boxed word (Word), which will work for value types as

[01:14] <svnbot6> r12968 | audreyt++ |   well as for mutable types.

[01:14] <audreyt> oh wow.

[01:14] <audreyt> nothingmuch++ nothingmuch++ nothingmuch++

[01:14] <audreyt> is this going back to C::MOP some day? :)

[01:15] <nothingmuch> i hope so

[01:15] <nothingmuch> i need to convince stevan it's sane

[01:15] <nothingmuch> my Master Plan is that the methodtable responderinterface can be compiled to perl 5 packages

[01:15] <nothingmuch> everything else is just going to be slow dispatch ;-)

[01:15] <audreyt> aye aye

[01:15] <nothingmuch> also

[01:15] <nothingmuch> note lack of bless {}

[01:16] <nothingmuch> it's not using perl 5's OO at all at this stage

[01:16] <nothingmuch> aside from bootstrapping the metamodel

[01:16] <audreyt> TreyHarris: I see what you mean

[01:16] <audreyt> but perl6's .clone amounts to .perl.eval

[01:16] <audreyt> i.e. thoroughly deep clone

[01:17] <nothingmuch> hmm

[01:17] <audreyt> though maybe it's okay for "but".

[01:17] <audreyt> nothingmuch: yes, I see that.

[01:17] <audreyt> very, very nice.

[01:18] <nothingmuch> it could also use a bit of memoization, since everything is 'is ro' for now, too

[01:18] <TreyHarris> audreyt: ahhh.  of course it can be overridden (and that was my motivation for using .clone in the first place), but the default will be most common, so that's probably bad.  is there a shallow clone?

[01:19] <audreyt> TreyHarris: actually whether .clone is deep or shallow

[01:19] <audreyt> appears to be unspecced!

[01:19] <nothingmuch> anymoose

[01:19] <nothingmuch> good night

[01:19] <TreyHarris> but causing its LHS to change is just very, very surprising, and i don't think it's desirable

[01:19] * nothingmuch votes for shallow

[01:19] <nothingmuch> too many ways to do deep

[01:19] <nothingmuch> wrt "singletonish" objects

[01:19] <audreyt> I'm fine with shallow.

[01:20] <nothingmuch> e.g. DBIx::Class rows referring to their result source

[01:20] <nothingmuch> cloning the entire schema is not a good idea ;-)

[01:20] <audreyt> TreyHarris: ok, so shallow copy for "but" blocks

[01:21] <audreyt> sounds sane. can you supply a patch to p6l on S12:610 and related places?

[01:21] <TreyHarris> i was thinking it was very natural for "XXX but" to map, not to "do given XXX", but to "do given XXX -> $xxx is cloned", but I was assuming .clone is shallow

[01:22] <audreyt> "$xxx is clone", btw.

[01:22] <audreyt> we don't say "$xx is copied"

[01:22] <audreyt> or maybe we should, but anyhow :)

[01:23] * audreyt not really have a strong opinion on ergonomics

[01:23] <audreyt> TreyHarris: but I agree with the sentiment

[01:23] <audreyt> (does the "but" in above sentence clone TreyHarris?)

[01:24] <nothingmuch> audreyt: whs that p6l request to me?

[01:24] <audreyt> nothingmuch: no, to TreyHarris

[01:25] <audreyt> my request for you is to sleep :)

[01:25] <nothingmuch> ah

[01:25] <nothingmuch> =)

[01:25] <nothingmuch> yes, working on it

[01:25] <nothingmuch> TreyHarris: YOU LIKE SHALLOW CLONES

[01:25] <nothingmuch> </hypnosis>

[01:26] <TreyHarris> <zombie>I LIKE SHALLOW CLONES</zombie>

[01:27] <nothingmuch> HERE IS YOUR SHALLOW CLONE SHERBERT

[01:28] <TreyHarris> audreyt: um, S12:610 is talking about hyperops on junctions...

[01:29] <audreyt> er, typo. 510.

[01:29] <clkao> win 25

[01:29] <audreyt> clkao: sounds like your birthday motto

[01:30] <clkao> errr.that's a bit silly

[01:30] <clkao> ;)

[01:30] <clkao> it's a square number1 what should i do this year

[01:31] <audreyt> I didn't know you attach special meaning to square numbered ages...

[01:33] <clkao> i don't know either. it just came up

[01:36] <audreyt> hmmm

[01:36] <audreyt> make svk the first widely deployed p6 app? :)

[01:37] <clkao> heh

[01:37] <audreyt> looks at what darcs did to haskell :D

[01:37] <clkao> nice try

[01:37] <clkao> if only everything works...

[01:37] <audreyt> when darcs was started, almost nothing works in GHC for realworld apps either...

[01:37] <clkao> ....

[01:38] <audreyt> droundy's talk at last year's ICFP was basically how he coerced more and more stuff into GHC that makes it fast/featureful/compact enough

[01:38] * clkao giggles

[01:38] <markstos> interesting.

[01:38] <clkao> tell me again when i am done with birthday drinking tomorrow

[01:38] <audreyt> heh sure

[01:38] <clkao> it might be possible after some beers/wines

[01:42] <TreyHarris> audreyt: since unlike .valid, everything produces a .SKID, is there a way to distinguish whether a given value is of a value type or not?

[01:42] *** weinig is now known as weinig|bbl

[01:42] <audreyt> there's no .valid anymore

[01:42] *** weinig|bbl is now known as weinig

[01:43] <ayrnieu> ?eval <1>.SKID

[01:43] *** evalbot_12966 is now known as evalbot_12968

[01:43] <evalbot_12968> undef

[01:43] <TreyHarris> right, that was my point.  .valid would return undef if the object was a non-value type.  .SKID returns an address.  so you can use .SKID in boolean context like you could for .valid

[01:43] <svnbot6> r12969 | audreyt++ | * hash.t: Correct the segfault test to test for segfaults.

[01:43] <audreyt> hm, we need a .META.isValueType

[01:43] <audreyt> except not capitalized as such

[01:43] <audreyt> add it to the spec too?

[01:44] <TreyHarris> ok

[01:44] <audreyt> .META.mutable  or something

[01:44] <TreyHarris> is "foo" mutable?

[01:44] <audreyt> no.

[01:44] <svnbot6> r12970 | audreyt++ | * More unsafeCoerce# and segfault avoidance.

[01:44] <audreyt> hell no.

[01:45] <audreyt> we are not ruby, after all.

[01:45] <TreyHarris> lol.  is class Point { has $.x is rw; has $.y is rw; } mutable?

[01:45] <audreyt> an instance of that class would be mutable.

[01:45] <ayrnieu> whath, the class definition?

[01:46] <audreyt> the class itself... is debatable. I think yes

[01:46] <TreyHarris> sorry, yes, i meant an instance of

[01:46] <audreyt> as it's by default an open class.

[01:46] <audreyt> so both are mutable

[01:47] <clkao> see, i still want a gentle migration plan. starting from using the classes/roles and signatures

[01:48] <audreyt> moosification gets you the first

[01:48] <clkao> ya

[01:48] <audreyt> as for the latter... yeah. :)

[01:48] <markstos> ?eval @%(a => <b>)<a>

[01:48] <evalbot_12968> Error: Cannot cast into Hash: VRef <Array::Const:0xb6e512ec>

[01:48] <clkao> zzzzzzzzzzzzzzzzz

[01:48] <svnbot6> r12971 | markstos++ | refine out optionals on are handled in mmd-draft.txt.

[01:48] <markstos> segfault fixed!

[01:49] <markstos> my grammar is apparently sucking.

[01:51] <audreyt> :)

[01:52] <markstos> audreyt: I think I should make docs/multi_method_dispatch/ and put the four related docs there, and a README explaining which one is current.

[01:52] <audreyt> markstos: these are all but historical drafts aiming to make it to S12

[01:53] <audreyt> so should be discarded once it's made into S12

[01:53] <audreyt> but sure, please do that

[01:53] <audreyt> and clarify their status in that README

[01:53] <clkao> audreyt: btw env $x is gone right?

[01:53] <audreyt> markstos++

[01:53] <audreyt> clkao: it's now "my $x is context"

[01:53] <clkao> right. there are a few tests with that

[01:53] <audreyt> thanks to merlyn and uri

[01:53] * clkao really zzz

[01:55] <TreyHarris> ok, then, so $obj.clone should walk all attributes, public and private, of $obj, and if !($obj.$attr.META.mutable) assign a clone of it, otherwise just assign it.  should '=' (theoretically) already have these semantics?

[01:57] <svnbot6> r12972 | audreyt++ | * change "env $x" into "my $x is context" as noticed by clkao++.

[01:57] <svnbot6> r12972 | audreyt++ |   note that pugs doesn't handle the latter form yet.

[01:58] <audreyt> uhm, you just described deep cloning

[01:58] <audreyt> recursively

[01:58] <audreyt> I thought you want shallow

[01:58] <nothingmuch> WHO HAS AWAKENED THE MUMMY OF THE CLONES?

[01:58] <nothingmuch> YOU MUST CLONE SHALLOWLY

[01:58] <nothingmuch> FOR THOU ART SHALLOW AND LIKETH BRITNEY SPEARS

[01:58] <nothingmuch> OBEY OBEY OBEY

[01:59] <audreyt> TreyHarris: s/assign a clone of it/assign it/

[01:59] <nothingmuch> *poof*

[02:01] <TreyHarris> audreyt: yes.  I was falling into the forgetting-about-what-autoboxing-really-means trap, and was trying to simulate it in Perl 5 :-)

[02:03] <audreyt> :)

[02:04] *** weinig is now known as weinig|zZz

[02:04] <audreyt> I think I need some more napping. bbl...

[02:04] <audreyt> *poof*

[02:07] <svnbot6> r12973 | markstos++ | organize and add README explaining the MMD docs status. (will move the new dir into notes/)

[02:10] <svnbot6> r12974 | markstos++ | move multi_method_dispatch dir into notes.

[02:32] *** mako132_ joined
[02:32] *** Flying joined
[02:43] <svnbot6> r12975 | markstos++ | Add some tests for "L<S12/"Calling Sets of Methods">.

[02:43] <svnbot6> r12975 | markstos++ | They nearly all fail now.

[02:43] <markstos> sleep &

[02:53] <svnbot6> r12976 | audreyt++ | * More segfault avoidance on freebsd with optimized build.

[02:57] *** nothingmuch joined
[03:06] <svnbot6> r12977 | audreyt++ | * Pugs.Val: Use the Word# casting trick for SKID too.

[03:32] *** lambdabot joined
[03:40] *** lambdabot joined
[04:29] *** nothingmuch joined
[05:33] *** iblechbot joined
[07:45] *** nwc10 left
[08:23] *** onsen joined
[08:25] *** DaGo joined
[08:44] *** elmex joined
[08:58] *** iblechbot joined
[09:01] *** kane-xs joined
[09:26] *** reZo joined
[09:49] *** gaal joined
[10:02] <nothingmuch> morning

[10:03] *** bernhard joined
[10:11] *** araujo joined
[10:21] <araujo> morning

[10:25] *** larsen joined
[10:33] *** elmex joined
[11:15] *** markstos joined
[11:18] *** ofer0 joined
[11:22] *** LeoNerd joined
[11:22] <LeoNerd> Heh.. just checking

[11:22] *** LeoNerd left
[11:37] *** Revision17 joined
[11:44] *** theorb joined
[11:44] <svnbot6> r12978 | markstos++ | remove bogus example in optionals section of mmd-draft.txt, pointed by Luke Palmer.

[11:53] <svnbot6> r12979 | markstos++ | [t/blocks/signature_match.t]

[11:53] <svnbot6> r12979 | markstos++ | Add smart link

[12:01] *** kanru joined
[12:04] *** chris2 joined
[12:15] *** pjcj joined
[12:21] <svnbot6> r12980 | markstos++ | [t/blocks/multi_sub.t t/blocks/param_signature.t t/blocks/signature_matching.t]

[12:21] <svnbot6> r12980 | markstos++ | Add smart links.

[12:24] <svnbot6> r12981 | markstos++ | Rename t/blocks/signature_matching.t t/blocks/multi_named_vs_pos.t]

[12:24] *** ludan joined
[12:24] <svnbot6> r12981 | markstos++ | This makes it more easily found with the other multi_* test there.

[12:26] <ludan> ola

[12:28] *** soisoisoi joined
[12:28] *** heng joined
[12:35] <integral> Is S5 the spec for perl6 rules?  And, is there a perl5 impl of them?

[12:35] *** job joined
[12:36] <audreyt> yes and yes.

[12:36] <audreyt> the impl is on CPAN as Pugs::Compiler::Rule

[12:36] <audreyt> and found in pugs/perl5/ as well

[12:36] *** job left
[12:37] <integral> ah, thanks!

[12:37] <audreyt> glad to help :)

[12:38] *** jkva joined
[13:09] * gaal mooses

[13:09] <audreyt> heya gaal :)

[13:09] * audreyt is previewing dons's great fps paper

[13:09] <gaal> ooh

[13:09] <audreyt> explaning all about the details of the 2.5x speedup lately

[13:10] <gaal> is it in preprint?

[13:10] <audreyt> no, private review still

[13:11] <gaal> moose

[13:23] <audreyt> from my feedback to dons:

[13:23] <audreyt> 15:20 <audreyt> bytestring is the only real reason

[13:23] <audreyt> 15:20 <audreyt> that convinced me pugs should not be thrown away as a prototype

[13:23] <audreyt> 15:20 <audreyt> and instead GHC is a good imperative VM in its own right

[13:26] <gaal> :)

[13:27] <audreyt> (of course the bootstrap to write the compiler in p6 will still happen; I'm referring to the runtime system :))

[13:27] * gaal like fusipugs

[13:27] <audreyt> pushion

[13:28] <gaal> 6.8 needs a fps literal constructor to replace ""

[13:28] <gaal> also make it available in patmatch

[13:29] *** plisk joined
[13:29] <gaal> ah and: can you explain why W#.unsafeCoerce# fixed the segfaults?

[13:29] <gaal> as opposed to just saved some memory?

[13:30] <audreyt> sure

[13:30] <audreyt> a Word is actually

[13:30] <audreyt> data Word = W# Word#

[13:30] <audreyt> here W# is constructor, Word# is the value

[13:30] <audreyt> so it's a boxed heap object

[13:30] <gaal> yupun

[13:30] <audreyt> taking two words

[13:30] <audreyt> one for the constructor tag one for the value

[13:31] <audreyt> you can't generally cast an incompatible heapobject into that

[13:31] <gaal> ah

[13:31] <audreyt> but any heap object is at least one word

[13:31] <audreyt> so can always be cast into the layout-independent W#

[13:31] <audreyt> which is just void*

[13:32] <audreyt> end of explanatation :)

[13:32] <gaal> :)

[13:33] <audreyt> I like the new :main in ghci

[13:33] *** weinig|zZz is now known as weinig

[13:33] <audreyt> :main -Iblib6/lib t/foo.t

[13:33] <xerox> :main? :D

[13:34] <audreyt> yeah, saves withArgs orother sillyness

[13:34] *** theorbtwo joined
[13:34] <xerox> It calls main with args.. oh nice.

[13:38] *** weinig is now known as weinig|bbl

[13:38] <svnbot6> r12982 | audreyt++ | * Pugs.Parser: "role A does A" is not allowed anymore.

[13:38] <svnbot6> r12982 | audreyt++ |   This fixes t/xx-uncategorized/self_inheritance.t.

[13:39] <gaal> oh nice

[13:40] <gaal> audreyt: whenever convenient, please see 'open questions' on last Sig commit

[13:41] <gaal> (r12960)

[13:41] <svnbot6> r12983 | audreyt++ | * t/var/var.t: this is no longer allowed:

[13:41] <svnbot6> r12983 | audreyt++ |     my $x;

[13:41] <svnbot6> r12983 | audreyt++ |     {

[13:41] <svnbot6> r12983 | audreyt++ |         $x = 1;

[13:41] <svnbot6> r12983 | audreyt++ |         my $x = 2;

[13:41] <svnbot6> r12983 | audreyt++ |     }

[13:41] <svnbot6> r12983 | audreyt++ |   so don't test for it.

[13:43] <audreyt> uhm

[13:44] <audreyt>     :($moose! is Beautiful is Fair)

[13:44] <audreyt> doesn't do what you think it does, I think...

[13:44] <audreyt> namely, it's not :(Beautiful Fair $moose)

[13:46] <audreyt> the latter I think translates to :($moose of Beautiful of Fair)

[13:47] <gaal> audreyt: I know

[13:47] <audreyt> which talks about $moose's content, not the alloc

[13:47] <audreyt> oh ok

[13:47] <gaal> it means some other user def aux

[13:47] <audreyt> okie

[13:47] <gaal> goes into the p_slots table

[13:48] <gaal> are 'Fair $moose' and $moose of Fair' entirely equivalent? if so I can trivially add support for 'of'.

[13:48] <audreyt> they are.

[13:48] <gaal> my question was where to put 'does' constraints

[13:48] <audreyt> and I think it does different things based on whether Fair is role or class.

[13:48] <gaal> as well as parametric variables, which need to be stored in the Param but also reported to the constructed Sig

[13:48] <audreyt> as re #0

[13:49] <audreyt> sub f ($x does Moose)

[13:49] <audreyt> is actually never canonical

[13:49] <audreyt>  spec only lets you talk about sub f ($x of Moose)

[13:49] <audreyt> which means "does" iff Moose is role

[13:49] <audreyt> "does" enters picture when you wantto use a class as a role

[13:50] <audreyt> in type position

[13:50] <gaal> hm ok

[13:50] <audreyt> but I'm not sure it's sane, or going in, or anything.

[13:50] <gaal> i'll ignore it then. :)

[13:50] <audreyt> good :)

[13:50] <gaal> what about ::T then?

[13:51] <gaal> it could be either an incoming or outgoing type

[13:51] <gaal> and in some cases it's an error!

[13:51] <audreyt> before you ignore it, put in a ocmment that says that :)

[13:51] <audreyt> (the "does' thing)

[13:51] *** b00t joined
[13:51] <audreyt> I think we either admit tyvars in p_types

[13:51] <gaal> eg. :(Dog ::T $x, Cat ::T $y) - error, ::T already bound?

[13:52] <audreyt> i.e. extend our Type to admit tyvars

[13:52] <gaal> nod

[13:52] <audreyt> or introduce  p_tyvars

[13:52] *** wilx joined
[13:53] <gaal> okay. I think we need the latter, since ruleParam now needs an incoming tyvar parameter

[13:53] <audreyt> that depends on how unification is done

[13:54] <gaal> er, that's actually unrelated

[13:54] <audreyt> I think latter is saner

[13:54] <audreyt> ::T and ::T may not be error

[13:54] <audreyt> it maybe a requestto unify

[13:54] <audreyt> i.e. find the common T such...

[13:54] <gaal> ouch

[13:54] <gaal> this is teh intricate

[13:55] <audreyt> depends on how much left bias we want

[13:55] <audreyt> I think p_tyvars allows flexibility at that point

[13:56] <gaal> flexibility against future spec?

[13:56] * audreyt has long ago decided not to think about tyvar until Callconv, Objmodel and Grammar is done

[13:56] <audreyt> yes.

[13:56] *** hermax_ joined
[13:57] <gaal> well, I'm happy with not even parsing this for this release

[13:57] <audreyt> as am I

[13:57] <gaal> just need to fix a small bug in requiring an optionality hint, plus implement named params

[13:58] <gaal> and then it's at compatible level to oldexp parser

[13:59] <audreyt> niiiice :)

[13:59] *** lisppaste3 joined
[14:00] * audreyt has started the long journey of bottom-to-up triaging

[14:00] * gaal wonders if he should give a "haskell for beginners" talk in OSDC::Il

[14:00] <svnbot6> r12984 | audreyt++ | * s/try/do/ in t/var/type.t now we parses "my Int $f"

[14:00] * xerox nods

[14:01] <audreyt> please do! :)

[14:01] <audreyt> you can use ziggy's material too

[14:01] <audreyt> just make sure to pull the IO chapters from the last to first

[14:01] <audreyt> and use bytestrings :)

[14:02] <gaal> I don't know if: I know enough, there's enough interest, and if audreyt isn't crazy :)

[14:02] <xerox> Anybody knows how to do interpolation of values in a string with io:format in Erlang? I know it's a strange question =P

[14:02] <gaal> lol

[14:02] <audreyt> I've just read TypEr paper that does inferencing for Erlang... great stuff

[14:02] <gaal> audreyt: use bytestrings, suuure, why not explain type Eval =

[14:03] <audreyt> gaal: seriously, I wish there's a MinHs in style of MinCaml

[14:03] <audreyt> it's by far the best compiler introductory (1st year university students)

[14:03] <audreyt> that I've seen in any language

[14:03] <gaal> don't know MinCaml, but have you tried Helium?

[14:03] <audreyt> http://min-caml.sourceforge.net/index-e.html

[14:03] <lambdabot> Title: A Crash Course for the MinCaml Compiler

[14:03] <gaal> specialcased friendly error messages

[14:04] <audreyt> sure but MinCaml is a 2kloc implementation of ML in ML

[14:04] <gaal> audreyt: seriously, I wish there were a mini Perl

[14:04] <audreyt> that compiles code that is faster than GCC :)

[14:04] <gaal> !

[14:04] <audreyt> and it touches all parts of the compiler chain

[14:04] <marcus_> boring sunday

[14:04] <audreyt> from parsing down to register allocation

[14:04] <audreyt> and three intermediate languages

[14:04] <audreyt> fascinating, no?

[14:04] <gaal> my moose

[14:05] * gaal is reminded of graydon's talk, where he mentioned ocaml came with great tools

[14:06] *** nothingmuch joined
[14:06] <gaal> # http://www.venge.net/graydon/talks/mkc/html/

[14:06] <lambdabot> Title: MagicPoint presentation foils

[14:06] <audreyt> yeah. Hs should be comparable on loc

[14:06] <audreyt> if not almost identical

[14:06] <svnbot6> r12985 | audreyt++ | * add MinCaml to READTHEM

[14:07] <audreyt> but "faster than GCC in 2kloc" is such an alluring strategy.

[14:07] <audreyt> it explains let-reduction, lambda-lifting, constant folding, dead code elimination, type-inferencing

[14:08] <audreyt> register spilling, register targetting/allocation, VM and assembly

[14:08] <audreyt> which are admittedly somewhat FP specific, but a lot of the concepts is reusable here as well

[14:09] <gaal> I'll definitely look into this

[14:09] <audreyt> adapt it into a OSDC.il talk would befun.

[14:09] <gaal> not sure my audience will agree

[14:10] <audreyt> mmmmm

[14:10] <audreyt> ok, maybe not for a 45min talk...

[14:13] * gaal contemplates a Moose monad

[14:15] <xerox> o_0

[14:20] *** nothingmuch joined
[14:20] <audreyt> Moose is also monoid

[14:20] <audreyt> Moose `mappend` Moose is still Moose

[14:21] <xerox> What's the mempty :: Moose? :)

[14:22] *** araujo joined
[14:24] <audreyt> Moose :)

[14:24] <nothingmuch> clkao: BOY!?!?

[14:24] <audreyt> data Moose a = Moose

[14:25] <nothingmuch> http://nothingmuch.woobling.org/MO/ is now purely functional

[14:25] <lambdabot> Title: Index of /MO

[14:25] <nothingmuch> all memoizations removed

[14:26] <audreyt> wnice     

[14:26] <wolverian> someone is lagging... :)

[14:26] <audreyt> err, sorry :)

[14:26] <audreyt> nothingmuch: any chance of Hsification? :)

[14:26] <nothingmuch> audreyt: that's what I'm planning on doing soon

[14:26] <nothingmuch> hence the changes

[14:26] <audreyt> yay

[14:26] <nothingmuch> i need to do MI slot allocation

[14:26] <nothingmuch> and i need to stop using hashes

[14:26] <nothingmuch> and use set::object

[14:26] <audreyt> 'k

[14:27] <nothingmuch> and add name-based constraints somewhere else

[14:27] <nothingmuch> however, i'm still in the exploratory stage

[14:27] <nothingmuch> i don't know precisely what it's going to be, so hsification is perhaps premature

[14:27] <audreyt> nodnod

[14:27] <nothingmuch> i think in ca. 2 days we should have something

[14:27] <nothingmuch> anymoose, where's that clkao... he needs a present

[14:46] <svnbot6> r12986 | audreyt++ | * Temporarily parse "my $x is context" by assuming that

[14:46] <svnbot6> r12986 | audreyt++ |   "env $x" was seen, although the latter is no longe canonical.

[14:46] <svnbot6> r12986 | audreyt++ |   The proper fix is to admit "is context" in the new Param structure.

[14:46] <svnbot6> r12987 | audreyt++ | * Pugs.Val.Code: add slot for "is context".

[14:47] *** xinming joined
[14:47] <xinming> TimToady: ping...

[14:47] <xinming> :-)

[14:49] <gaal> so, I'm working on this network component, and am looking at the way it handles network errors.

[14:49] <gaal> for some strange reason, the firewall I've been using to simulate chopping the network connection doesn't trigger the same error case as actually pulling the plug

[14:49] <avar> What's the status of the Perl6 Perl6 parser?

[14:49] <gaal> so I'm finding myself pulling the (eth) plug a lot

[14:49] <gaal> now, here's the thing:

[14:50] <gaal> if I pull it just enough to trigger the applicative error, and plug myself back quickly, all's well

[14:50] <gaal> if I leave the cable disconnected for about a minute, the machine reboots

[14:51] <gaal> the first time it happened, I was just touching the tip of the rj jack, so of course I was thinking some freak electrical thing had occured

[14:52] *** Limbic_Region joined
[14:52] * gaal decides to leave all switches in the "more magic" position

[14:53] <Limbic_Region> gaal - that's the problem with magic switches

[14:53] <Limbic_Region> switching between levels of magics has side effects

[14:54] *** lectus joined
[15:05] *** justatheory joined
[15:07] <xinming> seen TimToady

[15:07] <xinming> ?? It seems seenbot is away. :-/

[15:08] <integral> xinming: you can use SeenServ: /msg seenserv seen timtoady

[15:08] <integral> oh, well not quite, doesn't do last spoken times. *sigh*

[15:10] <xinming> >_<

[15:10] <Limbic_Region> ?seen TimToady

[15:10] <lambdabot> TimToady is in #perl6. I don't know when TimToady last spoke.

[15:11] <Limbic_Region> anyone built recently see a weird output o Parser.hs????

[15:11] <xinming> integral: hmm Ok, I want someone to make a English name for me. anyone here would help? :-P

[15:12] <[particle]> how about larry? :)

[15:13] <xinming> hmm, Can I have more? :-P

[15:13] <Limbic_Region> xinming - are you looking for an approximate representation of your name in english or

[15:13] <Limbic_Region> are you looking for something with a specific meaning

[15:13] <Limbic_Region> something that reflects your personality

[15:13] <Limbic_Region> etc

[15:13] <Limbic_Region> choosing a name isnt something one should do lightly IMO

[15:14] <Limbic_Region> and if you weren't aware, there are many "baby name" websites that list names, how popular they are, and what their meaning and origin is

[15:14] <xinming> Limbic_Region: approximate representation is ok, and for my personality, I want to be a very good person. :-)

[15:14] <xinming> where the url is plz?

[15:15] <Limbic_Region> the indicates one - there are dozens if not hundreds

[15:15] <Limbic_Region> just google for baby name

[15:15] <xinming> Limbic_Region: thanks

[15:15] <Limbic_Region> do you happen to know the origin and/or meaning of your current name?

[15:16] <audreyt> Limbic_Region: weird output?

[15:16] <xinming> Limbic_Region: yes, Xin means trust, and believable. and Ming, means clear(in mind), and knowing much.

[15:17] <xinming> Oh... audreyt, Your Chinese is good, could you please give me an English name? :-) Because I think You may choose a real good name for me. :-)

[15:18] <audreyt> I think I prefer xinming :)

[15:18] <Limbic_Region> audreyt - yeah, only now I closed the window so I will have to do it again

[15:18] <Limbic_Region> it finished compiling fwiw

[15:19] <Limbic_Region> audreyt - I expected you to be sleeping.  Is tomorrow a $work day?

[15:19] <xinming> audreyt: But the problem is, It can't be used as an English name, I'm in a Company, and they ask me to make a English name. I don't really want to change my English name in the future.

[15:19] <audreyt> Limbic_Region: it's not, but you're right, Ishould sleep, not triage

[15:19] <xinming> hmm, I think "Larry Lai" is Ok. But the problem is, I don't know if it might become offensive. :-)

[15:20] <Limbic_Region> well, if you triage - do it in silence (IOW off channel so you don't get sucked into other things)

[15:20] <audreyt> it's a pretty good name.

[15:20] <Limbic_Region> xander is pronounced zander in english fwiw xinming - so there are several english names beginning with an x

[15:21] <Limbic_Region> though it is uncommon

[15:21] <[particle]> xavier is more common

[15:21] <Limbic_Region> right particle - unless you are a BTVS fan

[15:21] <Limbic_Region> audreyt - stick around long enough for me to nopaste the weird output though

[15:21] <audreyt> sure

[15:22] <Limbic_Region> re-running now

[15:24] <svnbot6> r12988 | kudra++ | This week's summary

[15:24] *** hermax_ joined
[15:26] <Limbic_Region> xinming - come to think of it, there might even be a site to convert non-english names to english ones since it happens all the tie

[15:26] <Limbic_Region> time

[15:27] <Limbic_Region> preparing to nopaste

[15:27] <xinming> Limbic_Region: thanks, I'm reading baby names site. :-)

[15:27] <xinming> hmm, I really don't know how audreyt find this name... :-/ really good

[15:28] <Limbic_Region> audreyt - not just on parser.hs, several produce this weird output

[15:29] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "Weird output when building" (80 lines, 4.3K) at http://sial.org/pbot/19441

[15:29] <Limbic_Region> xinming - audreyt may have been lucky

[15:29] <Limbic_Region> looking for female names beginning the the same couple letters

[15:29] <Limbic_Region> au

[15:29] <Limbic_Region> wouldn't have produced that many choices

[15:29] <Limbic_Region> she liked one and went with it

[15:29] <Limbic_Region> not that it actually happened that way, but it is plausible

[15:30] <Limbic_Region> audreyt - I believe the output in Parser.hs is the same as nopasted above

[15:30] <xinming> Oh, the name audrey still can be found in baby names. :-) thanks

[15:31] <Limbic_Region> nopasting anyway just in case

[15:31] <audreyt> it actually happened that way :)

[15:31] <xinming> I'll also hunt my baby's name this night... :-P

[15:32] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "More weird output while building" (72 lines, 3.4K) at http://sial.org/pbot/19442

[15:32] <Limbic_Region> xinming - and if the meaning is important - some of the sites allow you to search that way.  I think they may not be free though

[15:32] <[particle]> xinming: here's a really cool name visualizer -- http://babynamewizard.com/namevoyager/lnv0105.html

[15:32] <lambdabot> Title: The Baby Name Wizard: NameVoyager, http://tinyurl.com/3ln7n

[15:33] <[particle]> it shows popularity over the last 125 years or so

[15:33] <Limbic_Region> I had to scrape a lot of geneology, baby name, and census websites for a project a while back

[15:34] <Limbic_Region> audreyt - AFAICT, those are the only two producing that weird output

[15:34] <svnbot6> r12989 | audreyt++ | * Allow symbolic evaluation of qualified types.

[15:34] <svnbot6> r12989 | audreyt++ |     ::('X::B')

[15:34] <svnbot6> r12990 | audreyt++ | * Fix a warning due to the new isContext slot,

[15:34] <svnbot6> r12990 | audreyt++ |   as noticed by Limbic_Region++

[15:34] <Limbic_Region> and the build finishes and no weird output when running

[15:35] <Limbic_Region> audreyt - is the ugly hack still in place or did you miraculously find some time to investigate Cabal and/or setup.exe?

[15:35] <audreyt> bth are fixed

[15:35] <audreyt> no, ENOTIME. maybe tomorrow, but triage takes prec

[15:35] <audreyt> (and changelogging too, but I was hoping for some help :))

[15:36] <[particle]> which ghc do i need now?

[15:36] <audreyt> 6.4.1 or above

[15:36] <Limbic_Region> audreyt - I tried to help, I really did

[15:36] <audreyt> not changed in this release

[15:36] <svnbot6> r12991 | audreyt++ | * fix the init warning in Pugs.Parser too.

[15:36] <Limbic_Region> unfortunately those that updated the changelog didn't bother to indicate what commits went with what comments

[15:36] <Limbic_Region> or even where the last accumulative rev left off

[15:37] <audreyt> I understand

[15:37] <audreyt> [particle]: on win32, last known good build is 0819 if you want to try with GHC 6.6, though GHC 6.4.2 will build pugs fine

[15:37] <Limbic_Region> I know with this project I shouldn't be afraid to screw things up

[15:37] <Limbic_Region> but...

[15:38] <Limbic_Region> particle - if you want to be a brave soul and go with GHC 6.6, I can help there

[15:38] <audreyt> *nod* note you can use "svn log ChangeLog" to see where markstos injected the changes

[15:38] <Limbic_Region> though 6.5 from the 19th works out of the box

[15:38] <audreyt> but I need to sleep now :)

[15:38] <audreyt> see you tomorrow!

[15:38] <Limbic_Region> sleep well

[15:42] *** marmic joined
[15:43] <gaal> xinming: "Earnest" maybe?

[15:43] <Limbic_Region> . o O ( the importance of being? )

[15:44] <[particle]> 'abe' can evoke the same imagery :)

[15:44] *** justatheory joined
[15:47] <gaal> Limbic_Region: it sorta fits with the literal meaning of the original name

[15:47] <svnbot6> r12992 | kudra++ | A quote was missing

[15:47] <audreyt> or "Ernesto"

[15:48] <xinming> gaal: Larry Lai.... :-)  Just hope that I'll be as good as larry wall. :-)

[15:48] <audreyt> "Ernesto Lai" sounds rather nice

[15:49] <audreyt> and immediately summons the image of an socialanarcho activitist ;)

[15:49] <nothingmuch> @seen clkao

[15:49] <lambdabot> clkao is in #perl6. I don't know when clkao last spoke.

[15:49] * gaal fnies for the pords

[15:49] <Limbic_Region> all better audreyt

[15:51] <xinming> audreyt: What does Ernesto mean?

[15:51] <gaal> ..and starts moving home

[15:51] <gaal> I believe "Ernesto" is the Italian equivalent of "earnest"

[15:51] <Limbic_Region> me too

[15:51] <gaal> bbiab&

[15:52] <audreyt> also Spanish, probably

[15:52] <audreyt> as in Ernesto Guevara de la Serna :)

[15:54] *** elmex_ joined
[15:56] * Limbic_Region wanders off for the day

[15:56] <Limbic_Region> TTFN all

[15:59] <[particle]> is it che lai in here, or is it just me?

[16:02] *** weinig|bbl is now known as weinig

[16:04] <xinming> [particle]: what does che lai mean? :-/

[16:17] *** Psyche^ joined
[16:29] *** Psyche^ is now known as Patterner

[16:29] *** mauke joined
[16:31] *** BooK__ joined
[16:31] *** BooK__ left
[16:31] <svnbot6> r12993 | book++ | typo

[16:40] <svnbot6> r12994 | audreyt++ | * More test triaging...

[16:40] <gaal> I don't understand the treatment of unpacking in Subroutine.pod:1222

[16:40] <gaal> my Dog :($fido, $spot)  := twodogs();   # one twodog object

[16:41] <gaal> the whole section had dealt with sub signatures, now this is a variable declaration

[16:41] <gaal> but one that actually only declares the patmatched inner vars

[16:41] <svnbot6> r12995 | audreyt++ | * Parse for slurpy :(*@x) in Signature literals; not yet

[16:41] <svnbot6> r12995 | audreyt++ |   reflected into the real Sig structure, but good enough

[16:41] <svnbot6> r12995 | audreyt++ |   to make siglist.t (which btw is getting moved) not fail.

[16:42] <gaal> that's fine, except (a) looks to me like it should be a different section

[16:42] <gaal> and (b) the syntax is bizzare -- ':($fido, $spot)' elsewhere means something completely different

[16:42] <gaal> also:

[16:42] <gaal> my Dog $ ($fido, $spot) := twodogs();   # one twodog object

[16:43] <gaal> what is this $ <ws> (...) thing?

[16:43] <gaal> also also, there are literal tabs there :(

[16:43] <audreyt> declarator takes Param

[16:43] <audreyt> or Sig in parens

[16:43] <gaal> other than that, I can implement unpacking in the sig parser :)

[16:44] <audreyt> vardecl share syntax with paramdecl

[16:44] <audreyt> entirely

[16:44] <gaal> well, that's a fine unification, but it's sort of not indicated in the text, which just flows associatively from talking about subs to talking about vars.

[16:45] <gaal> also, I still don't understand 'Dog $ ($fido, $spot)'

[16:45] <gaal> what is this empty $ thing?

[16:45] <gaal> ah, that's the disambiguator mentioned above.

[16:45] <gaal> it's like haskell '' in (x,y)

[16:46] <gaal> as opposed to 'n' in 'n@(x,y)'

[16:46] <audreyt> rofl.

[16:47] <gaal> why don't we write a Haskell emitter? Perl 6 == Haskell

[16:47] <audreyt> TimToady might have been overpessimizing here.

[16:47] <audreyt> my Dog ($x, $y)

[16:47] <audreyt> is perhaps better written as

[16:47] <gaal> audreyt is a lazy sleeper

[16:47] <audreyt> my (Dog $x, Dog $y)

[16:47] <audreyt> but I can see the redundant typing

[16:48] <audreyt> problem is

[16:48] <audreyt> my Dog (Cat $x)

[16:48] <audreyt> really doesn't mean much

[16:48] <audreyt> except maybe we special case it to say that declarator followed by type names

[16:48] <audreyt> distributes those type names in the signature list that follows.

[16:48] <gaal> my (Dog ::T $x, ::T $y) # groan

[16:48] <audreyt> in which case it needs to be said as such...

[16:49] <audreyt> gaal: deconstructing binds goes way back

[16:49] <audreyt> before either perl6 or haskell :)

[16:50] <svnbot6> r12996 | audreyt++ | * move t/unspecced/siglist.t to t/syntax/signature.t

[16:50] <svnbot6> r12996 | audreyt++ |   as it's (thank gawd) no longer unspecced.

[16:50] <gaal> Miranda? ML?

[16:50] <audreyt> ML prolly

[16:50] <gaal> ML++ thne

[16:50] <audreyt> 1970s technology

[16:51] <gaal> 1970s++, hella great music

[16:51] <gaal> um okay, about order. how sensitive are params to the order of:

[16:52] <gaal> auxillaries, where-{}, unpackings

[16:52] <gaal> it's of course easier to implement parsing this if the order is rigid

[16:53] <gaal> also, in full sig-style unpacking, why was () used and not :()?

[16:53] <gaal> the latter is longer but would have been more intuitive (I think)

[16:54] <audreyt> it can be

[16:54] <audreyt> ()is mere abbrev

[16:55] <audreyt> You may omit the top variable if you prefix the parentheses with a colon

[16:55] <audreyt> to indicate a signature.

[16:55] <audreyt> the intro text is very backwards though.

[16:55] <gaal> well! that does not say that w/o the colon is just an abbreviation

[16:55] <audreyt> I concur

[16:55] <gaal> and it doesn't guarantee that you can always put the colon

[16:55] <audreyt> how about you reorder/refactor/rewrite the entire section and send to p6l :)

[16:56] * audreyt agrees it looks very confusing

[16:56] <gaal> yeah, I'll do that.

[16:56] <audreyt> so, re order.

[16:56] <gaal> is there another place where the param<->vardecl equiantlerhood _is_ discussed?

[16:56] <audreyt> I _think_ where/unpack/trait is unordered.

[16:56] <audreyt> but you can certainly parse it ordered first...

[16:57] <gaal> and freely intermixed?

[16:57] <gaal> that's okay, it just means we need a classifier

[16:57] <audreyt> yes, S03 declarator

[16:57] <audreyt> Variable declarators such as C<my> now take a I<signature> as their

[16:57] <audreyt> argument.  (The syntax of function signatures is described more fully in S06.)

[16:57] <audreyt> The parentheses around the signature may be omitted for a

[16:57] <audreyt> simple declaration that declares a single variable, along with its

[16:57] <audreyt> associated type and traits.  Parentheses must always be used when

[16:57] <audreyt> declaring multiple parameters:

[16:57] <audreyt> etc.

[16:57] <audreyt> also note

[16:57] <audreyt>     sub foo :($a,$b) {...}      # okay

[16:58] <gaal> data ParamPostMoose = Aux .. | Unpack Sig | Constraint Code

[16:58] <gaal> hmm ok, but some sigs clearly don't make sense in vardecl

[16:58] <gaal> my $x?

[17:00] <audreyt> why not?

[17:00] <gaal> what does that mean?

[17:01] <gaal> as opposed to my $x!   ?

[17:01] <audreyt> sub f { return() }; my $x? := f();

[17:01] <audreyt> would work, while

[17:01] <audreyt> my $x! := f()

[17:01] <audreyt> would fail

[17:02] <audreyt> the unification of binding vs callconv is complete, you see :)

[17:02] <gaal> whoa.

[17:03] <audreyt> it's probably the most far-reaching change in the YAPC::Tokyo Protocol :)

[17:03] <gaal> *applause*

[17:03] <audreyt> btw I just committed to S03

[17:03] <audreyt> +Types occuring between the declarator and the signature are distributed into

[17:03] <audreyt> +each variable:

[17:03] <audreyt> +

[17:03] <audreyt> +    my Dog ($b, $c);

[17:03] <audreyt> +    my (Dog $b, Dog $c);    # same thing

[17:03] <audreyt> +

[17:04] <gaal> well, if that's a declarator-specific amenity there should be a note saying so

[17:04] <gaal> ie "Differences between param decl and signatures, although we said they're equivalent"

[17:04] <gaal> :)

[17:05] <audreyt> thing is, in signature literals

[17:05] <audreyt> there's nowhere to hang that :)

[17:05] <gaal> sure, since s03 is about vars and s06 is about subs :)

[17:06] <audreyt> *nod*

[17:06] <audreyt> also note that you can do

[17:06] <audreyt> sub f ($x is context) { ... }

[17:07] <audreyt> my $x is copy := ...

[17:07] <audreyt> which follows quite easily from the unification

[17:08] * gaal notes one thing you can't do is n+k patterns, and isn't seen complaining just yet

[17:08] <audreyt> sub f (1+$x) { ... }

[17:08] <gaal> suuure

[17:08] <wolverian> please don't. :)

[17:08] <audreyt> if we do that, we might as well do "$x is free".

[17:08] <audreyt> and then unify using backtracking and introduce first-class end goals.

[17:09] <gaal> $x is up(grabs)

[17:09] <audreyt> reading Curry conference proceedings is a dangerous way to fall asleep...

[17:09] <obra> heh

[17:09] <obra> bad dreasms?

[17:09] <audreyt> mad dreams, most likely

[17:10] <audreyt> (Curry is Haskell extended to express Prolog)

[17:10] <gaal> a bad dreasms is when you can't fall asleep because your lover keeps texting you dirty messages?

[17:10] <audreyt> gaal++

[17:11] <audreyt> bbl tomorrow :)

[17:12] <gaal> sleep audreyt `seq` goodMorning audreyty

[17:14] <nothingmuch> @pl sleep audreyt `seq` goodMorning audreyty

[17:14] <lambdabot> sleep audreyt `seq` goodMorning audreyty

[17:15] <gaal> being strict about audreyt's sleep schedule is pointless

[17:15] <nothingmuch> @hg a -> b -> c -> ( b a , c a )

[17:15] <lambdabot> Maybe you meant: . bf ghc id msg pl v wn

[17:15] <nothingmuch> heh

[17:16] <gaal> but, nm, you mean '@hoogle'

[17:17] <nothingmuch> @hoogle a -> b -> c -> ( b a , c a )

[17:17] <lambdabot> No matches, try a more general search

[17:17] <gaal> I don't see how that can be a valid type though

[17:17] <nothingmuch> yes, i'm stupid

[17:17] <nothingmuch> @hoogle a -> (a -> b)  -> ( a -> c ) -> ( b, c )

[17:17] <lambdabot> No matches, try a more general search

[17:18] <nothingmuch> @pl foo audreyt = sleep audreyt `seq` goodMorning audreyt

[17:18] <lambdabot> foo = liftM2 seq sleep goodMorning

[17:18] <nothingmuch> ah

[17:18] <gaal> heh

[17:18] <nothingmuch> that's what i was trying to do

[17:18] *** jkva joined
[17:19] <gaal> even \bot sings audreyt lullabies

[17:19] <nothingmuch> @t liftM2

[17:19] <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v

[17:19] <nothingmuch> @type liftM2

[17:19] <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

[17:20] <nothingmuch> i don't grok that at *all*

[17:20] <gaal> nothingmuch:

[17:21] <gaal> liftM2 f x y = do

[17:21] <gaal>   xv <- x

[17:21] <gaal>   yv <- y

[17:21] <gaal>   return f xv yv

[17:21] <nothingmuch> ah

[17:21] <gaal> er, return $ ...

[17:21] <nothingmuch> yep

[17:22] <mauke> @pl \x -> f x `c` g x

[17:22] <lambdabot> liftM2 c f g

[17:22] <mauke> oh god, the function monad

[17:22] <gaal> !grok

[17:23] <gaal> mauke: we actually generate liftMn functions for various values of n, up to 12 I think :-)

[17:23] <nothingmuch> why did lambdabot decide that `seq` was mondaic in this case? it already knows it?

[17:23] <gaal> because the standard libs come with up to liftM5

[17:24] *** Aankhen`` joined
[17:24] <gaal> nothingmuch: I don't rightly know! but there is much to be studied in the plugin dir

[17:24] * nothingmuch shies away

[17:24] <nothingmuch>  meta model stuff is getting priority time slices

[17:25] <xerox> lambdabot decided what?

[17:25] <gaal> yeah, and i should get back to Syn editing and then parsing unpacking sigs!

[17:25] <gaal> hm, mauke's @pl shows perhaps it didn't?

[17:25] <nothingmuch> gaal++

[17:25] <nothingmuch> gaal: yes, that's why i asked

[17:25] <gaal> bbiab :)

[17:26] <xerox> nothingmuch: it uses the ((->) a) monad, aka Reader.

[17:26] <nothingmuch> ah

[17:26] <xerox> nothingmuch: it doesn't mean that the code is monadic in the IO sense.

[17:26] <nothingmuch> i know of other monads

[17:26] <nothingmuch> but the notion that liftm2 is sequential

[17:27] <nothingmuch> in that there is a binding

[17:27] <xerox> ?type liftM2

[17:27] <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

[17:27] <nothingmuch> whereas f x `c` g x is not necessarily so is peculiar

[17:27] <xerox> Expanded for m = (e ->) becomes: (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c).

[17:28] <xerox> @djinn (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c).

[17:28] <lambdabot> Cannot parse command

[17:28] <xerox> @djinn (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)

[17:28] <lambdabot> f a b c d = a (b d) (c d)

[17:28] <xerox> @. pl djinn (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)

[17:28] <lambdabot> f = liftM2

[17:28] <xerox> :D

[17:28] <nothingmuch> so how is the reader monad implied?

[17:28] <nothingmuch> @i

[17:28] <lambdabot> Maybe you meant: id index instances instances-importing . v

[17:28] <xerox> As soon as you pass a function as the second and third argument, you're done.

[17:28] <nothingmuch> @instances ((->) a)

[17:28] <nothingmuch> ?

[17:28] <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.

[17:29] <xerox> ?type \f -> liftM2 f (+1)

[17:29] <lambdabot> forall a2 r a. (Num a) => (a -> a2 -> r) -> (a -> a2) -> a -> r

[17:29] <xerox> Ta-da.

[17:29] <nothingmuch> brb

[17:29] <xerox> @instances Monad

[17:29] <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []

[17:30] <xerox> ?type \f -> liftM2 f (undefined :: IO a)

[17:30] <lambdabot> forall a2 r a. (a -> a2 -> r) -> IO a2 -> IO r

[17:37] *** mako132_ joined
[17:43] *** mako132_ joined
[17:43] *** ruz joined
[17:58] *** DaGo joined
[18:08] *** khisanth_ joined
[18:10] *** khisanth_ is now known as Khisanth

[18:11] <gaal> English is hard, let's go shopping

[18:11] <gaal> (p6-l query up)

[18:14] *** traecer left
[18:20] *** axarob joined
[18:20] *** axarob left
[18:22] *** salty-horse joined
[18:40] *** jkva left
[18:53] <salty-horse> are parameter types implemented yet?

[18:54] <gaal> salty-horse: not yet, working on it.

[18:55] <salty-horse> is anything in the repository yet? source I can look at?

[18:56] <gaal> the groundwork is parsing signatures into newVal objects:

[18:56] <gaal> ?eval :(Moose $x)

[18:56] *** evalbot_12968 is now known as evalbot_12996

[18:56] <evalbot_12996> CCall "perl" CaptMeth {c_invocant = VPure (SigSubSingle {s_requiredPositionalCount = 1, s_requiredNames = {"x"}, s_positionalList = [MkParam {p_variable = "$x", p_types = [(mkType "Moose")], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = "x", p_slots = {}, p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = {}, s_slurpyScalarList = [], s_slurpyArray = Nothing, s_slurpyHas

[18:57] <gaal> ignore the CCall for now, look at SigSubSingle:

[18:57] <salty-horse> i'm trying to avert my eyes

[18:58] <gaal> there is one Param in the positional list, and the p_types field is just "mkType 'Moose'"

[18:58] <gaal> this looks better prettier-printed :)

[18:58] <TreyHarris> gaal: *clap* I like it

[18:58] <gaal> (btw, see that p_unpacking = Nothing? give me ten minutes :)

[18:59] <gaal> so, there are various subparsers that already work, for example arbitrary auxillaries:

[19:00] <gaal> ?eval :($x is rw is ref is illegible)

[19:00] <evalbot_12996> Error:  unexpected "i" expecting comment, "," or ")"

[19:00] <gaal> heh, hasn't updated

[19:00] <gaal> ?eval :($x! is rw is ref is illegible)

[19:00] <evalbot_12996> CCall "perl" CaptMeth {c_invocant = VPure (SigSubSingle {s_requiredPositionalCount = 1, s_requiredNames = {"x"}, s_positionalList = [MkParam {p_variable = "$x", p_types = [], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = "x", p_slots = {"illegible":=VPure (MkBit True)}, p_hasAccess = AccessRW, p_isRef = True, p_isContext = False, p_isLazy = False}], s_namedSet = {}, s_slurpyScalarList = [], s_slurpyArray = Nothin

[19:00] <TreyHarris> gaal: I may be blind, but I've stared at evalbot's output for a bit and I can't see where the first two {'s terminate, and it looks like "False}]" terminates a { that doesn't exist within the []

[19:00] <gaal> TreyHarris: copy to vim and 'setf haskell' :)

[19:01] <gaal> (and thanks! :)

[19:01] <TreyHarris> heh, ok

[19:01] <gaal> salty-horse: so, what I was asking audreyt earlier was where the ::T in 'Dog ::T $fido' goes

[19:02] <gaal> and the answer is that probably Pugs.Val.Code.Param needs a p_tyvar field

[19:02] <gaal> salty-horse: please add it :)

[19:02] <gaal> got a commit bit?

[19:03] <salty-horse> yes. but i want to try and understand all this first :)

[19:04] <salty-horse> i am very new to haskell, and understand very little of pugs internals :/

[19:04] <gaal> it's much easier to start by looking at src/Pugs/Val/Code.hs

[19:04] <gaal> of if you want the big picture of our new AST, src/Pugs/AST/CapInternals.hs

[19:05] *** weinig is now known as weinig|bbl

[19:06] <salty-horse> what does ":(Expression)" mean in the pugs prompt? I can't find it in :h (newbie question)

[19:06] <gaal> CapInternals.hs is compilable, but doesn't reallt run yet. we're picking out parts of it and vivifying them into the old runcore, gradually

[19:06] <gaal> ah, :($x) is a Signature constructor

[19:06] <gaal> doesn't have anything to do with the prompt

[19:07] <gaal> just an unfortunate coincidence

[19:07] *** markstos joined
[19:07] <gaal> audreyt mentioned en passant what's the best way to explain this:

[19:07] <gaal> consider:

[19:08] <gaal> sub make_car ($model, $doors? = 4, $color? = 'black') { ... }

[19:08] <gaal> that's actually:

[19:08] <gaal> sub make_car :($model, $doors? = 4, $color? = 'black') { ... }

[19:08] <gaal> that is, this signature is a first-class object. and I can do

[19:09] <gaal> my $sig = :($model, $doors? = 4, $color? = 'black')

[19:09] <gaal> or presumably something like &make_car.signature

[19:09] <gaal> and the introspection goes from there.

[19:09] <TreyHarris> would sub make_car $sig { ... } be valid?

[19:10] <TreyHarris> assuming $sig was set in a BEGIN block or otherwise in time?

[19:10] <gaal> not sure - not sure how much sense it makes. (because, what's the body?)

[19:10] <gaal> if it's a literal ..., maybe

[19:13] <TreyHarris> ok, so i slept on it and I think I've got a working idea of how shallow cloning and 'is clone' should work.  But it requires two things that aren't in the synopses (yet):

[19:14] <TreyHarris> 1) right now 'has @.foo = 1..3' and 'has $.foo = 1..3' do precisely the same things, and elsewhere in the class you can refer to the attribute declared either way as "$.foo" or "@.foo"--it just imposes a different context if it matters in use.  I think that it also makes a difference in cloning:

[19:14] <TreyHarris> has @.foo = 1..3; # $obj.clone will get a new array

[19:14] <TreyHarris> has $.foo = 1..3; # $obj.clone will get the same array

[19:14] *** Aankh|Clone joined
[19:15] <salty-horse> gaal, how do you suggest pretty-printing the pugs command line's output?

[19:15] <gaal> you mean in evalbot? I don't :(

[19:15] <gaal> but that particular one, with the haskell dump?

[19:16] <gaal> ./pugs -e ':(Moo $x).yaml.say'

[19:16] <salty-horse> the haskell dump.

[19:16] <TreyHarris> 2) there needs to be a specifier for (private-only?) attributes that make no sense to be shared among clones.  for example, "has %!private_instance_cache is reallyprivate".  those attributes shouldn't be assigned to the clone, but should be cloned in the clone.  i don't know what the right word for it is, obviously not 'reallyprivate' :-)

[19:16] <gaal> ah actually no, that won't work :(

[19:17] <gaal> so just copy it to vim, turn on syntax hilighting, and... good luck :)

[19:17] <gaal> TreyHarris: not responding since I don't know about this stuff, I'm not ignoring you :)

[19:18] <TreyHarris> well, i was hoping nothingmuch was back, he said 'brb' 100 minutes ago or so :-)

[19:18] <gaal> he meant bwb # be wrong back

[19:18] <gaal> aw, that was awful, sorry

[19:18] <TreyHarris> lol

[19:19] <gaal> it's a little known fact that 'bbl' means be back left

[19:19] <gaal> ok I'd better stop

[19:21] <salty-horse> be blatantly late

[19:21] <TreyHarris> gaal: however, seeing whether my intuition is right would be helped if i could prototype some code, and your recent diffs look like they're moving in that direction.  will user-defined param traits be implementable soon?

[19:21] <nothingmuch> TreyHarris: i am

[19:22] <svnbot6> r12997 | gaal++ | * fix hintless required params, so this works again:

[19:22] <gaal> you mean actually callable ones? hmm, why not, go ahead and hack them in :)

[19:22] <svnbot6> r12997 | gaal++ |     :($x is rw)

[19:22] <nothingmuch> gaal: yes, while you're in the wabe

[19:22] * gaal gyres

[19:22] * gaal gimbles

[19:23] <nothingmuch> =)

[19:24] <TreyHarris> gaal: my haskell-fu is still somewhere between nil and nonexistant.  i meant being able to write 'roll clone { multi sub trait_auxiliary:is(clone $trait, Any $container, &block?) {... } }" and have it actually work

[19:24] <TreyHarris> s/roll/role

[19:24] <nothingmuch> it's not nil, it's Nothing

[19:24] <nothingmuch> that's the first step ;-)

[19:24] <gaal> yes, because at least that's Maybe

[19:25] <gaal> Haskell is an optimistic language.

[19:25] <TreyHarris> nothingmuch: anyway, look in your scrollback at my comments starting at :13 after this hour.  does that seem sane to you?

[19:25] *** perlbot joined
[19:25] <gaal> argh how do I get a PureSig from a wrapped Val?

[19:26] <gaal> I don't wanna import VPure :(

[19:26] <nothingmuch> TreyHarris: yes, 5'0 f6r 5t

[19:26] <nothingmuch> clone should be in the same domain as ===

[19:26] <nothingmuch> wheras copy is more like eqv

[19:26] <nothingmuch> and must be user code

[19:26] <nothingmuch> i think

[19:27] <nothingmuch> clone should be there for the moral equivalent of bless { %$obj };

[19:27] <nothingmuch> and not for high level duplication

[19:27] <nothingmuch> for that we need an optional user role

[19:29] * TreyHarris is still trying to figure out "5'0 f6r 5t"

[19:30] <nothingmuch> that was my keyboard getting messed up

[19:30] <nothingmuch> i think it was my numlock key

[19:30] <nothingmuch> i couldn't type for a short while

[19:30] <nothingmuch> but the numlock was off

[19:30] <nothingmuch> i toggled it anyway

[19:30] <nothingmuch> and it went back to normal

[19:35] <TreyHarris> ah, ok.  so is there actually a distinction between 'is copy' and 'is clone'?  for value (~~ non mutable) types, 'is copy' performs the useful service of letting you do mutating methods against them (which produce a new object).  but for non-value (~~ mutable) types, it doesn't do anything but let you do anything beyond the default 'is ro', except to reassign the param another object, which seems like a rather unusual need.  so maybe 'is clone' doesn't exist

[19:36] <TreyHarris> whoops, i'm sure that got cut off.  but where?  one of these days I have to figure out how to make irssi not let me type more than the server allows

[19:43] <gaal> 'but where' - see irc.pugscode.org

[19:44] <gaal> 'figure out how to'

[19:44] <nothingmuch> TreyHarris: i think maybe 'is copy' is for value types

[19:44] <nothingmuch> is clone is for value types + 1 layer

[19:44] *** Trey2 joined
[19:44] <nothingmuch> i was being confusing, i think

[19:44] <TreyHarris> ah, ok.  so is there actually a distinction between 'is copy' and 'is clone'?  for value (~~ non mutable) types, 'is copy' performs the useful service of letting you do mutating methods against them (which produce a new object).  but for non-value (~~ mutable) types, it doesn't do anything but let you do anything beyond the default 'is ro', except to reassign the param another object, which seems like a rather unusual need.  so maybe 'is clone' doesn't ...

[19:44] <TreyHarris> ... exist, and 'is copy' always clones (falling back for efficiency's sake to plain old cow semantics when the param is of a value type)?

[19:45] <nothingmuch> i think not

[19:45] <nothingmuch> the distinction is... unnecessary

[19:45] * nothingmuch ponders

[19:45] <nothingmuch> intuitively:

[19:45] <nothingmuch> copy means you can ruin it without worry

[19:45] <nothingmuch> clone means it's another one of those

[19:45] <TreyHarris> yay irssi+perl.  (that ... ... but was done automatically)

[19:45] <nothingmuch> yes

[19:46] <nothingmuch> there's a script for that =)

[19:46] <TreyHarris> oh.  lol

[19:46] <nothingmuch> i forget what it's called

[19:46] <nothingmuch> irssi++

[19:46] <nothingmuch> anymoose

[19:46] <wolverian> splitlong

[19:46] <nothingmuch> i'm not sure what my spider sense is telling me

[19:46] <nothingmuch> it's saying "maybe copy is a deep clone"

[19:47] <nothingmuch> but it's also saying "no no, deep clones should *always* be defined by the actual class - they can't be automated"

[19:47] <TreyHarris> right, because deep clones can easily cause infinite recursion

[19:48] <nothingmuch> not only that

[19:48] <TreyHarris> without help as to the semantics of what an attribute containing another instance of your class might mean

[19:48] <nothingmuch> we tend to have a notion of "attached" objects in non purely functional languages

[19:48] <nothingmuch> objects which manage (or don't manage) their own registration in a parent object of some sort

[19:49] <nothingmuch> it's a simple way to get this stuff done easily

[19:49] <nothingmuch> wheras in haskell you need to use something like thezipper

[19:49] <nothingmuch> or do everything from the parent

[19:50] <nothingmuch> when you clone this way

[19:50] <nothingmuch> and it's a deep clone

[19:50] *** weinig|bbl is now known as weinig

[19:50] *** Limbic_Region joined
[19:50] <nothingmuch> then you clone the entire hierarchy

[19:50] <nothingmuch> when you usually mean "clone and return a detached copy"

[19:50] <nothingmuch> or "clone and attach to the parent with a different key"

[19:50] <nothingmuch> or something of the sort

[19:50] <nothingmuch> this is where cloning becomes strictly a high level operation

[19:50] <nothingmuch> and there's no way to do this sanely

[19:51] *** weinig is now known as weinig|food

[19:51] <TreyHarris> yes, but i'm just talking about what the Any::clone method should do.  i suspect, as always, most perl programmers will not implement a Cloneable role or override .clone, so .clone should do something a little bit more--but as little more as is sanely possible--than plain shallow cloning

[19:52] <nothingmuch> well

[19:53] <nothingmuch> that's exactly my point... they should be separate

[19:53] <nothingmuch> you shouldn't override clone

[19:53] <nothingmuch> clone should simply have a usable meaning

[19:53] <nothingmuch> if you want to a Clonable role

[19:53] <nothingmuch> then the api is probably going to let clone take an argument which says how it should be cloned

[19:53] <nothingmuch> Storable::dclone is also useful though

[19:53] <nothingmuch> for when you *do* want *every* related object to be duplicated

[19:54] <nothingmuch> i'm thinking .clone is always shallow

[19:54] <nothingmuch> and .copy is always dclone

[19:54] <nothingmuch> and something in the middle

[19:54] <nothingmuch> a user method

[19:54] <nothingmuch> is a "real" clone

[19:56] <TreyHarris> well, let me give an example.  say we have "class Point { has $.x, has $.y }".  it would be very natural to write "my $sameHeight = $p but { .x = 0 }".  assuming but clones, this works fine.

[19:56] <salty-horse> ?eval :(dog $fido = 3)

[19:56] *** evalbot_12996 is now known as evalbot_12997

[19:56] <evalbot_12997> Error:  unexpected "=" expecting comment, trait, "," or ")"

[19:56] <salty-horse> ?eval :(dog $fido= 3)

[19:56] <evalbot_12997> CCall "perl" CaptMeth {c_invocant = VPure (SigSubSingle {s_requiredPositionalCount = 0, s_requiredNames = {}, s_positionalList = [MkParam {p_variable = "$fido", p_types = [(mkType "dog")], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = "fido", p_slots = {}, p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = {}, s_slurpyScalarList = [], s_slurpyArray = Nothing, s_slurpyHa

[19:57] <gaal> salty-horse: will fix

[19:57] <salty-horse> salty-horse will fix?

[19:57] <TreyHarris> but then it gets reimplemented as "class Point { has SpaceLocator $.coord; method x { ... } method y { ... } }".  now that same but code is going to cause $p to be modified, because x no refers indirectly to $.coord, which is an object.

[19:57] <gaal> you're welcome to, but I meant I'll fix :)

[19:57] <TreyHarris> s/x no refers/.x now refers/

[19:58] <nothingmuch> TreyHarris: preecisely

[19:58] <nothingmuch> that's the issue with .clone

[19:58] <nothingmuch> the only use it has is as a convenience methods

[19:58] <nothingmuch> method

[19:58] <nothingmuch> when you can be reasonably sure of the semantics of the instance structure

[19:59] <nothingmuch> however

[19:59] <nothingmuch> let's for a minute assume that we can know whether or not a value is mutable by means of introspection

[20:00] <TreyHarris> audreyt says it will be via ?(.META.mutable)

[20:01] <nothingmuch> okay

[20:01] <nothingmuch> .clone need never both copying mutables, right?

[20:01] <nothingmuch> 1.clone is a noop;

[20:01] <nothingmuch> since e.g. ++ is a container method

[20:01] <nothingmuch> you can't say 1++

[20:01] <wolverian> you meant immutables right?

[20:01] <nothingmuch> err

[20:01] <nothingmuch> yes

[20:02] <nothingmuch> sorry, kind of distracted

[20:02] <TreyHarris> um noooooo, i think not.  i think 1.clone is equivalent to Int.new(1)

[20:02] <TreyHarris> because "0 but True" should not change the truth of 0 from then on

[20:02] <nothingmuch> it can't change

[20:03] <nothingmuch> 0 but True doesn't actually change 0

[20:03] <nothingmuch> it wraps it in something that overrides truth

[20:03] <TreyHarris> right, it changes a clone of 0

[20:03] <nothingmuch> and delegates everything else

[20:03] <TreyHarris> right

[20:03] <nothingmuch> my understanding is that immutables never change at all

[20:03] <nothingmuch> and thus there is no point in cloning them ;-)

[20:04] <nothingmuch> anymoose

[20:04] <TreyHarris> right.  there's a switch somewhere that causes different behavior based on $obj.META.mutable.  it can be in clone, or it can be in but, but it has to be somewhere.

[20:04] <TreyHarris> this is what i've been cogitating on

[20:04] <nothingmuch> by this rationale cloning only makes sense  if $x !=== $x.clone is always true

[20:05] <nothingmuch> your fine line is in @.x etc

[20:05] <nothingmuch> @x === @y;

[20:05] <lambdabot> Maybe you meant: . v

[20:05] <nothingmuch> heh

[20:05] <TreyHarris> lambdabot: no, he didn't. ;-)

[20:05] <nothingmuch> wait, let me read a small bit

[20:06] <nothingmuch> okay

[20:06] <nothingmuch> @x.clone !=== @y.clone

[20:06] <lambdabot> Unknown command, try @list

[20:06] <nothingmuch> aghg

[20:06] <nothingmuch> i'm really confused

[20:06] <nothingmuch> @x.clone !=== @x;

[20:06] <lambdabot> Unknown command, try @list

[20:06] <nothingmuch> because you can edit @x.clone.[1] without altering @x

[20:07] <TreyHarris> but @x.clone eqv @x?

[20:07] <nothingmuch> yes

[20:07] <nothingmuch> we are in agreement that @x.clone.[1] === @x[1] right

[20:07] <nothingmuch> 5?

[20:07] <TreyHarris> yes

[20:07] <nothingmuch> okay

[20:07] *** Aankh|Clone is now known as Aankhen``

[20:08] <nothingmuch> my conjecture is that what we are searching for

[20:08] <nothingmuch> is to declare $.coord as a "part" of the point

[20:08] <nothingmuch> so that it's ===

[20:08] <nothingmuch> and it'll be cloned too

[20:08] <TreyHarris> yes.  i was thinking "has SpaceLocator $.coord is value"

[20:08] <nothingmuch> yes

[20:08] <nothingmuch> okies

[20:09] <nothingmuch> why did i miss that =/

[20:09] <nothingmuch> i spent 15 minutes beating around the bush and juggling two conversations to restate something you already knew

[20:09] <TreyHarris> no, it's helpful

[20:09] <nothingmuch> anymoose, we already have 'is value'

[20:09] <nothingmuch> is ro

[20:09] <nothingmuch> i think

[20:09] <nothingmuch> it basically says that you can never change $.coord

[20:10] <nothingmuch> within the point object

[20:10] <nothingmuch> $point.coord = foo never works

[20:10] <nothingmuch> it's more like an organizational layout

[20:10] <nothingmuch> likewise $foo = $point.coord;

[20:10] <nothingmuch> $foo.x = 1;

[20:10] <nothingmuch> doesn't change $point.coord.x

[20:12] <nothingmuch> maybe that's the diff between is ro and is value?

[20:12] <TreyHarris> from outside the class, yes

[20:12] <nothingmuch> also, can you is value anything

[20:12] <nothingmuch> is it recursive?

[20:12] <TreyHarris> but inside the class, you can alter coord

[20:12] <nothingmuch> if it's deep then $point.coord.x = 1;

[20:12] <nothingmuch> can't really work

[20:13] <nothingmuch> hmm

[20:13] <nothingmuch> or maybe it can =/

[20:13] <nothingmuch> $foo = $point.coord;

[20:13] <nothingmuch> $foo !=== $point.coord; # true?

[20:14] <TreyHarris> hmm... what "is value" does is say, "this attribute is mutable, but treat it from the outside of the class as if it were immutable"

[20:14] <nothingmuch> ah

[20:14] <nothingmuch> so only to the outside

[20:14] <nothingmuch> yes, that makes sense

[20:14] <TreyHarris> right

[20:15] <nothingmuch> can two points share a coord?

[20:15] <nothingmuch> or is it implicitly shallow cloned on assignment

[20:15] <TreyHarris> no... or not sanely.  if they did, they'd be the same point

[20:15] <TreyHarris> i think it is on assignment, but not on binding

[20:15] *** b_jonas joined
[20:16] <nothingmuch> hmm

[20:17] <TreyHarris> so assuming "my Point ($x, $y); $x .= new(3,3);" we're agreed that "$y = $x" and "$y = $x.clone" must be different, yes?

[20:18] <nothingmuch> i think so

[20:18] <nothingmuch> $y = $x is a shallow thing

[20:18] <nothingmuch> since the point is by ref

[20:18] <nothingmuch> i think i sort of got it

[20:18] <nothingmuch> Point can say 'is value'

[20:18] <nothingmuch> on itself

[20:18] <TreyHarris> yes, but that's what got me into trouble yesterday.... it's helpful to think of "by ref", but references are gone

[20:19] <nothingmuch> if Point is value

[20:19] <nothingmuch> then $y = $x; is implicitly like $y = $x.clone;

[20:19] <nothingmuch> i think

[20:19] <TreyHarris> yes, if it said "is value" on itself, then "$y = $x" and "$y = $x.clone" would be the same

[20:19] <nothingmuch> that is the byrefness i mean

[20:20] <nothingmuch> i don't think it's useful for a class to say that it's 'is value' and still be mutable

[20:20] <TreyHarris> then you'd do "$y = \$x" if you wanted to do reffy things

[20:20] <nothingmuch> well

[20:20] <nothingmuch> $p1.x = 4;

[20:20] <nothingmuch> err

[20:20] <nothingmuch> $p2 = $p1; $p1.x = 4; $p2.x ?

[20:21] <TreyHarris> no, i think is value on a class means that having a mutator is an error

[20:21] <nothingmuch> okay

[20:21] <nothingmuch> i was thinking that if a class is value-ish

[20:21] <nothingmuch> 'autocloning' if you will

[20:21] <nothingmuch> then any assingment on a member

[20:21] <nothingmuch> is an implicit clone-and-overlay

[20:22] <nothingmuch> like a haskell record

[20:22] <TreyHarris> ok... that works too

[20:23] <nothingmuch> hmm

[20:23] <TreyHarris> then "$p1.x = 4" is equivalent to "$p1 = $p1.clone(:x(4))"

[20:23] <nothingmuch> how does this relate to @x et al?

[20:23] <TreyHarris> well, for non-value types, an attribute in "has @.xs" should be cloned into a new array @.xs with the same elements

[20:24] *** ruz joined
[20:24] <TreyHarris> but an attribute in "has $.xs", even if an array, will be shared after cloning

[20:24] <TreyHarris> unless the *attribute* is marked "is value"

[20:24] <nothingmuch> @x is unvalue; # ;-)

[20:24] <lambdabot> Maybe you meant: . v

[20:25] <nothingmuch> lambdabot: @stfu

[20:25] <lambdabot> Unknown command, try @list

[20:25] <TreyHarris> no.... that's what i want to avoid, the degenerate (in both senses of the word) behavior of a clone's internal behavior causing its preceptor to change

[20:26] <nothingmuch> uh

[20:26] <nothingmuch> let me parse that

[20:26] <TreyHarris> let me rephrase

[20:28] <TreyHarris> if a not-all-that-sophisticated perl programmer writes an ordinary C-struct-y class as would be obvious, if it is cloned, dwimmery should result such that they should act as separate structs.  making a call on the clone shouldn't result in the preceptor (the object it was cloned from) changing

[20:28] <nothingmuch> yes

[20:28] <nothingmuch> agreed

[20:28] <nothingmuch> however, if a slightly-sophisticated perl programmer wnats to use the @ sigil

[20:29] <nothingmuch> and yet have it shared between clones

[20:29] <nothingmuch> then... do we give that programmer the option?

[20:29] <TreyHarris> i don't think so, because "has @.x" and "has $.x" at this point is defined as having no difference.  it's an error to have both

[20:30] <TreyHarris> so, for the sophisticates, we tell them to do "has $.array", which wouldn't occur to the novitiates

[20:30] <nothingmuch> ah

[20:30] <nothingmuch> hmm

[20:34] <TreyHarris> i think there is also a "is transient", which has at least two effects: one, when the object is stored persistently, the attribute so marked is skipped.  two, *either* a) in cloning, the attribute is considered 'is value' and is cloned, or b) in cloning, the attribute is not cloned at all.  i don't know which is more useful

[20:35] <TreyHarris> has $!scratchpad is transient;

[20:35] <nothingmuch> i think the class of scratchpad defines it's cloned-or-uininitialized semantics

[20:35] <nothingmuch> but yes

[20:35] <nothingmuch> these are important, too

[20:37] <TreyHarris> nothingmuch: not necessarily.  Int's class has nothing to say about "has Int $!times_called is transient"

[20:38] <nothingmuch> hmm

[20:38] <nothingmuch> i am actually pondering this in an unrelated way

[20:38] <nothingmuch> thinking about attribute grammars

[20:38] <nothingmuch> and slots

[20:38] <nothingmuch> in terms of the metamodel stuff

[20:38] <nothingmuch> external vs. internal slots

[20:39] <nothingmuch> and how they are optimized for cases of cloning etc

[20:40] <marcus_> I think slots should be renamed sluts

[20:41] <marcus_> would make conversation much more entertaining

[20:43] <TreyHarris> i think classes could be marked 'is transient' too, just as they could be marked 'is value'.  for example, wouldn't a filehandle be transient?  storing it persistently is worthless.  if so, that would argue for cloning behavior to be to consider "is transient" the same as "is value": clone it since it's useful right now.

[20:44] <gaal> and 'is transvestite'? a regular Pugsy Horror Picture Show

[20:44] <nothingmuch> TreyHarris: i think it's an error

[20:44] <nothingmuch> not a silent "skip" to store a filehandle

[20:45] <nothingmuch> you need to make a symbolic reference on dump

[20:45] <nothingmuch> and resolve it on load

[20:45] <TreyHarris> so you can't store an object that has a filehandle attribute?

[20:46] <nothingmuch> not sanely

[20:46] <nothingmuch> when you load it

[20:46] <nothingmuch> does it reopen the file?

[20:46] <nothingmuch> does it die with 'can't call method read on undefined value'?

[20:47] <nothingmuch> these are issues with high level serialization

[20:47] <TreyHarris> i'm thinking it's exactly the same as "$!scratchpad"... the object must be able to deal with the possibility that at any time $!scratchpad may disappear.

[20:48] <TreyHarris> so if you mark the filehandle attribute "is transient", then it isn't an error to store it, it will just be skipped.  if you don't, it is an error to store it.

[20:49] <TreyHarris> $!scratchpad, on the other hand, could have been stored, but you've told Perl not to

[20:49] *** justatheory joined
[20:50] <nothingmuch> oh

[20:50] <nothingmuch> if you explicitly say that the FH is transient

[20:50] <nothingmuch> then yes

[20:50] <nothingmuch> it's OK

[20:51] <TreyHarris> ok... then you're advocating 'transient' being an ok trait for attributes, but not for classes?

[20:52] <TreyHarris> bbut 'value' is ok for both?

[20:52] <nothingmuch> hmm

[20:52] *** soisoisoi joined
[20:52] <nothingmuch> well

[20:52] <gaal> zzZ &

[20:52] <nothingmuch> i think we should allow transient on classes

[20:52] <nothingmuch> Int might not say it is transiet

[20:52] <nothingmuch> ient

[20:52] <nothingmuch> but SIllyCache might

[20:53] <pasteling> "TreyHarris" at 216.254.17.198 pasted "Somebody try this, do you kill pugs as well?" (12 lines, 331B) at http://sial.org/pbot/19443

[20:55] <TreyHarris> and "class Filehandle is transient {...} class SillyThing { has Filehandle $.moose; ...} my SillyThing $obj .= new", would storing $obj be an error unless you changed it to "has Filehandle $.moose is transient"?

[20:56] <nothingmuch> class Filehandle should't be transient

[20:56] <nothingmuch> it wouldn't

[20:56] <nothingmuch> think of u

[20:56] <nothingmuch> err

[20:56] <nothingmuch> a thingy is transient

[20:56] *** weinig|food is now known as weinig

[20:57] <nothingmuch> if it's marked as such by it's container

[20:57] <nothingmuch> or it's class

[20:57] <nothingmuch> or both

[20:58] <TreyHarris> why shouldn't a filehandle be transient?

[20:58] <nothingmuch> because that would silence it's errors

[20:58] <nothingmuch> sometimes people might accidentally serialize a filehandle

[20:59] <nothingmuch> and they should get an error

[20:59] <nothingmuch> and say "oh right, this should be transient"

[20:59] <nothingmuch> or "oh crap, i forgot it has a filehandle, i can't store that"

[20:59] *** justatheory joined
[21:00] <TreyHarris> sounds like you're arguing that classes should *not* be marked transient

[21:04] *** vytautas joined
[21:05] <TreyHarris> can someone please try to replicate the above paste?

[21:06] <nothingmuch> no

[21:06] <nothingmuch> i'm trying to argue that classes should be able to be marked as transient

[21:06] <wolverian> argh. why does perldoc mess up '=head2 C<foo> bar' ?

[21:06] <nothingmuch> but that only very specific classes should be allowed to do that

[21:07] <TreyHarris> maybe it's an error to create an attribute using a transient class that is not marked transient itself?

[21:09] <nothingmuch> then you have to type it twice

[21:09] <nothingmuch> my point is, by convention mark the attr as transient, not the class

[21:09] <nothingmuch> but to omit typing 'is transient' all the time

[21:10] <nothingmuch> classes which are obviously transient could be marked as such

[21:10] *** crem joined
[21:10] <nothingmuch> e.g. debugging aids, memoziation tables, etc

[21:11] <TreyHarris> but filehandle is not "obviously transient"... because people might be tempted to store it?  so instead, it should... what... override .store to throw an exception?

[21:11] <TreyHarris> sorry, i'm confused... i can tell you have a clear picture, i just can't see what it is :-)

[21:13] <nothingmuch> well

[21:13] <nothingmuch> my $email = ...;

[21:13] <nothingmuch> whatever

[21:13] <nothingmuch> let's say you are storing that

[21:13] <nothingmuch> and the impl detail is that $email is lazy loaded from a file

[21:13] <nothingmuch> the right behavior is to not try to store the file handle

[21:13] <nothingmuch> but instead slurp everything from it

[21:13] <nothingmuch> and then serialize the structure

[21:13] <nothingmuch> of the email

[21:14] <nothingmuch> the actual text

[21:14] <nothingmuch> and then when it's load it

[21:14] <nothingmuch> then it's just loaded as a fully delazified object

[21:14] <nothingmuch> that will not use the filehandle

[21:14] <salty-horse> question: when i "eval :(dog $fido)" i get the internal representation. Param.Default is comprised of DExp and Exp, but is printed as <Param.Default> (in Pugs.Val.Code) - how can I inspect its contents?

[21:16] <TreyHarris> ?eval :(dog $fido)

[21:16] <evalbot_12997> CCall "perl" CaptMeth {c_invocant = VPure (SigSubSingle {s_requiredPositionalCount = 1, s_requiredNames = {"fido"}, s_positionalList = [MkParam {p_variable = "$fido", p_types = [(mkType "dog")], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = "fido", p_slots = {}, p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = {}, s_slurpyScalarList = [], s_slurpyArray = Nothing, s_sl

[21:16] <TreyHarris> what contents do you want?

[21:16] <TreyHarris> ?eval :(dog $fido).perl

[21:16] <evalbot_12997> "CCall \"perl\" CaptMeth \{c_invocant = VPure (SigSubSingle \{s_requiredPositionalCount = 1, s_requiredNames = \{\"fido\"}, s_positionalList = [MkParam \{p_variable = \"\$fido\", p_types = [(mkType \"dog\")], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = \"fido\", p_slots = \{}, p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = \{}, s_slurpyScalarList = [], s_slurpyArr

[21:16] <TreyHarris> hrm

[21:16] <TreyHarris> ?eval (:(dog $fido)).perl

[21:16] <evalbot_12997> Error:  unexpected ")" expecting comment, trait, "," or end of input

[21:16] <salty-horse> <Param.Default> stores "rDefault" and "isOptional"

[21:16] <TreyHarris> ?eval my $sig = :(dog $fido); $sig.perl

[21:16] <evalbot_12997> "\\VPure (SigSubSingle \{s_requiredPositionalCount = 1, s_requiredNames = \{\"fido\"}, s_positionalList = [MkParam \{p_variable = \"\$fido\", p_types = [(mkType \"dog\")], p_constraints = [], p_unpacking = Nothing, p_default = <Param.Default>, p_label = \"fido\", p_slots = \{}, p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = \{}, s_slurpyScalarList = [], s_slurpyArray = Nothing, s_slurpyHash = Nothing,

[21:17] <salty-horse> see Pugs/Parser.hs:1378

[21:17] <TreyHarris> ?eval my $sig = :(dog $fido); $sig.p_default

[21:17] <evalbot_12997> Error: No compatible subroutine found: "&p_default"

[21:18] <salty-horse> it's inside a parameter's

[21:18] <TreyHarris> salty-horse: dunno, i'm illiterate at that level

[21:18] <salty-horse> (oh wait, it's not)

[21:18] *** buetow joined
[21:18] <salty-horse> hmm

[21:18] <salty-horse> why i'm asking: http://colabti.de/irclogger/irclogger_log/perl6?date=2006-09-03,Sun&sel=694#l1147

[21:19] <lambdabot> Title: #perl6 2006-09-03,Sun, http://tinyurl.com/epuwm

[21:19] *** DaGo joined
[21:20] <salty-horse> i found out that commenting "lookAhead (char '=') >> return True" in isOptional (Pugs/Parser.h) does not give the error.

[21:20] <salty-horse> but it's important to check for the trailing "=", so I can't just remove it

[21:21] <TreyHarris> salty-horse: i don't think there are any lambdacamels on at the moment, unless nothingmuch has been keeping track of this stuff...

[21:22] <salty-horse> TreyHarris, i'll just leave gaal a message then. thanks

[21:23] *** weinig is now known as weinig|bbl

[21:24] <svnbot6> r12998 | fglock++ | * v6

[21:24] <svnbot6> r12998 | fglock++ |   - Expression.pm is reentrant again

[21:24] <svnbot6> r12998 | fglock++ |   - unified rule parser with Pugs-Compiler-Rule

[21:24] <svnbot6> r12998 | fglock++ |   - other minor fixes

[21:24] <svnbot6> r12998 | fglock++ | * Pugs-Compiler-Rule

[21:24] <svnbot6> r12998 | fglock++ |   - faster rule parser: hash dispatch, non-backtracking,

[21:24] <svnbot6> r12998 | fglock++ |     converted several tail-calls into quantifiers.

[21:24] <svnbot6> r12998 | fglock++ |   - the rule parser is now bootstrapped with v6.pm

[21:24] <svnbot6> r12998 | fglock++ |     (requires some editing to fix dependencies)

[21:24] <svnbot6> r12998 | fglock++ |   - implemented <!before ...>

[21:24] <svnbot6> r12998 | fglock++ |   - implemented '=pod END'

[21:24] <nothingmuch> TreyHarris: i'm waaaaaaaay too zonked

[21:24] <nothingmuch> i'm having a heavy weight conversation

[21:25] <nothingmuch> in my high prio thread

[21:25] <nothingmuch> so sorry =/

[21:25] <nothingmuch> i guess that should be s/TreyHarris/salty-horse/;

[21:26] <salty-horse> nothingmuch, no need to apologize.. i settled for messaging gaal

[21:27] <nothingmuch> okies

[21:27] <nothingmuch> good luck =)

[21:30] *** kasei left
[21:32] *** siossois joined
[21:32] <svnbot6> r12999 | wolverian++ | Add C<foo> to a few places, fix typos and other small nits.

[21:41] *** elmex joined
[21:56] *** Aankhen`` joined
[22:10] *** plisk joined
[22:13] *** elmex joined
[22:15] *** jferrero joined
[22:17] *** elmex joined
[22:31] *** MacVince joined
[22:31] *** Aankhen`` joined
[23:02] *** ludan left
[23:18] *** Daveman joined
[23:33] *** markstos joined
[23:52] *** markstos left
[23:52] *** markstos joined
