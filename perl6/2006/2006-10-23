[00:07] <root4o> tring this :

[00:07] <root4o> class test {

[00:07] <root4o>     method blah($a) { $a };

[00:07] <root4o>     method blah($a,$b) { $a + $b };

[00:07] <root4o> }

[00:07] <root4o> my $obj = test.new;

[00:07] <root4o> say $obj.blah(a => 5);

[00:07] <root4o> doesn't work

[00:07] <root4o> if I remove second method it is ok..

[00:07] <TreyHarris> perlbot: nopaste

[00:07] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[00:07] <TreyHarris> root4o: multi method

[00:08] <root4o> off.. sorry ;(

[00:08] <root4o> thanx

[00:12] <eviltwin_b> yeh, that requires multi

[00:15] <root4o> yep, forgot ;)

[00:17] <TreyHarris> svn isn't working for me even for reads (assuming "svn up" and "svn stat -uq" count as a read)

[00:22] *** nekokak joined
[00:26] *** glasser` joined
[00:27] *** Aankh|Clone joined
[00:31] *** hikozaemon joined
[00:54] *** mauke_ joined
[01:10] *** polettix joined
[01:16] *** nipotaway is now known as nipotan

[01:22] <audreyt> temporary plan: setting up new machine may take time. so we're making feather the master

[01:22] <audreyt> Juerd: I'll install CommitBit on feather and expose it thru http.

[01:23] <audreyt> clkao is getting the raw (cleaned up) svn dumps to feather

[01:23] <audreyt> will take some time to transfer auth tokens up

[01:24] *** glasser` joined
[01:25] *** mauke_ is now known as mauke

[01:32] *** thepler joined
[01:47] *** trym_ joined
[01:47] <audreyt> dinner, bbiab

[01:58] <root4o> trying "Method call vs. Subroutine call" in S12

[01:58] <root4o> it seems that it is working the other way around

[01:58] <root4o> i.e. it defaults to sub call not to method call

[01:59] <root4o> ?class test { method foo($a) { 'method' } }; sub foo($a) { 'sub' }; my $obj = test.new; say foo($obj);

[01:59] <lambdabot> Unknown command, try @list

[02:11] <eviltwin_b> root4o: lots of stuff isn't implemnted yet.  (as of this morning Captures work, thank audreyt++)

[02:12] <root4o> yeah... i'm just testing...posting here just for information, so that the devs are aware ;)

[02:15] <TreyHarris> root4o: write a test

[02:16] * eviltwin_b is still waiting for darwinports to quit rebuilding the same stuff over and over and rebuild the satuff that actually needs it

[02:16] <eviltwin_b> probably should give up and do it from scratch

[02:16] <TreyHarris> though, of course, until svn is back, writing a test won't be too useful to implementors...

[02:16] <root4o> i do it like :todo test , right ? if it doesn't work at the moment ?

[02:16] <TreyHarris> no

[02:16] <TreyHarris> just write it

[02:17] <TreyHarris> audreyt or gaal or fglock or whomever will see it's failing, and then they'll either fix it or add a todo

[02:17] <root4o> aha...so if it seems to me that something doesnt work...i ask here

[02:18] <root4o> if it indeed didn't work i know it is not my error, but it is not implemented yet

[02:18] <root4o> correct?

[02:18] <TreyHarris> root4o: that's often useful... but also, just go to smoke.pugscode.org

[02:18] <TreyHarris> look at a recent smoke

[02:18] <TreyHarris> click the SYN link

[02:18] <TreyHarris> and find the part of the docs describing what you think is broken

[02:18] <TreyHarris> if there's no test, then it's almost definitely unimpl, and you should add a test

[02:19] <TreyHarris> if there's a test, you can see what the state is

[02:19] <TreyHarris> make sense?

[02:20] <root4o> yes

[02:21] *** shobadobs joined
[02:22] *** mako132_ joined
[02:46] *** SubStack joined
[02:48] <svnbot6> r14484 | raptor++ | adding tests for method vs sub call (S12)

[02:57] *** thepler joined
[03:23] *** cjeris left
[03:37] *** rodrickbrown joined
[03:46] *** glasser joined
[03:56] *** stennie left
[04:00] <svnbot6> r14485 | audreyt++ | * meth_vs_sub_call.t: Fix plan number.

[04:07] *** seano joined
[04:07] <svnbot6> r14486 | audreyt++ | * Pugs.Prim: Rename "atomically" to "contend" and "retry" to "defer".

[04:07] <TimToady> audreyt: can we delay decision on statement bare block till after we see if there is something after it, so that {}.perl and such don't violate Least Surprise?

[04:08] <TimToady> I though you used defer for something else already...

[04:08] <TimToady> *thought

[04:09] <bsb> Scalar::Defer?

[04:10] <audreyt> scalar::defer but are we getting that in p6?

[04:10] <TimToady> oh, was that only p5?

[04:10] <audreyt> yeah

[04:10] <TimToady> okay, np.

[04:10] <audreyt> re after it, not sure good idea

[04:10] <audreyt> consider

[04:10] <audreyt> { ... }

[04:10] <audreyt> .say for @foo;

[04:11] <TimToady> that reduces on end of line } rule though

[04:11] <TimToady> almost any real bare block is going to have } on its own line.

[04:11] <audreyt> sorry, thought you were talking about that

[04:12] <TimToady> ?eval { say "hi" }.perl

[04:12] <evalbot_r14485> OUTPUT[hi‚ê§] "\\undef"

[04:12] <TimToady> that's rather bogus

[04:12] <audreyt> how did that get reduced?

[04:12] <TimToady> decided } ended bare block, and .perl is $_.perl

[04:13] <TimToady> is my guess

[04:13] <audreyt> that's correct...

[04:13] <audreyt> fixing

[04:17] <audreyt> done

[04:17] <audreyt> so, maybe.

[04:17] <audreyt> maybe {} is statement level?

[04:17] <svnbot6> r14487 | audreyt++ | * Standalone blocks must terminate a statement on its own.

[04:17] <audreyt> or is it both prefix and chaining binary?

[04:17] <audreyt> or is it something else?

[04:17] <audreyt> the original syntax was

[04:18] <audreyt> my $x = ({ ...}.or_else:{...}.or_else:{...}).();

[04:18] <audreyt> but not sure what &maybe looks like

[04:19] <TimToady> yes, I think it was intended as syntactically equiv to if/elsif/else without the conditionals...

[04:19] <audreyt> but those are stmtlvl

[04:19] <TimToady> so it's more like else/else/else

[04:19] <audreyt> so to get rv use do?

[04:19] <audreyt> $rv = do maybe {this} maybe {that}

[04:19] <audreyt> that's almost pretty.

[04:20] <TimToady> $rv = do

[04:20] <TimToady>          maybe {this}

[04:20] <TimToady>           maybe {that}

[04:20] <TimToady> s/\x20//

[04:20] <TimToady> I think it works okay.

[04:20] <audreyt> but wouldn't that end stmt on first maybe?

[04:20] <audreyt> but anyway, do{} will fix that

[04:20] <audreyt> sure, implementing

[04:21] <audreyt> (just so I can show Real Code tomorrow :))

[04:21] <TimToady> no, maybe extends current statement like else.

[04:21] <TimToady> it really does parse a lot like else/else/else

[04:21] <audreyt> but else only follows if

[04:21] <audreyt> so you mean

[04:21] <audreyt> this maybe {that}

[04:21] <TimToady> and maybe only follows maybe.  :)

[04:21] <audreyt> ?

[04:21] <audreyt> heh, so it's still stmt lvl

[04:21] <audreyt> got it

[04:21] *** perlbot joined
[04:22] <audreyt> the irreconcilables now has a new "SIMD vs MIMD" dimension...

[04:22] <audreyt> (btw, GHC does SSE2 on x86_64 happily and will probably get that on x86 soon)

[04:22] <audreyt> so once we have unboxed arrays (which we'll get with newVal)

[04:22] <audreyt> then PDL stuff get vectorized

[04:22] <TimToady> we're fine as long as it's Haskell's brain that explodes and not the user's...

[04:23] <audreyt> yeah, perl6 is this huge soft water bed between it and the user...

[04:23] <TimToady> SSE2?

[04:23] <audreyt> intel's vector opcodes

[04:23] <audreyt> SIMD stuff

[04:23] <audreyt> primarily for graphics folks

[04:24] <audreyt> @array_of_ints >>++

[04:24] <lambdabot> Unknown command, try @list

[04:24] <audreyt> s/ /./

[04:24] <audreyt> s:P5/ /./, even.

[04:24] <TimToady> there was a slashdot last week about some of the games folks working on a *86/GPU chip

[04:25] <audreyt> just had dinner with William Cook (programming chair of oopsla, the guy who did the initial denotational semantics of inheritance)

[04:26] <TimToady> cool

[04:26] <audreyt> and he appears to highly appreciate p6 taking out the private-member-access-of-superclasses part

[04:26] <audreyt> saying "that stuff has absolutely nothing to do with inheritance"

[04:27] <TimToady> hmm, /home/larry/pugs/third-party/installed/lib/Pugs-6.2.13/ghc-6.6/libHSPugs-6.2.13.a(Parser.o):(.rodata+0x528): undefined reference to `Pugszm6zi2zi13_PugsziParserziLiteral_lvl208_closure'

[04:27] <audreyt> which I guess is common sense around here but, it's nice to hear nevertheless :)

[04:27] <audreyt> had a partially aborted incremental make?

[04:27] <TimToady> I was just doing what TheDamian told me to there... :)

[04:27] <TimToady> yea

[04:27] <audreyt> if the ^C happens between recursive modules

[04:27] <audreyt> then it does that. annoying :/

[04:28] <TimToady> well, doesn't take that long to rebuild.

[04:28] <audreyt> no other known ways than rm -rf dist/build/

[04:36] <TimToady> ?eval { say "hi" }.perl

[04:36] <evalbot_r14487> "\{Syn \"block\" \{App \&say (: \"hi\")}}"

[04:36] <audreyt> that is correct modulo we had bad deparse.

[04:37] <TimToady> ?eval { :a(1,2,3) }<a>

[04:37] <evalbot_r14487> [1, 2, 3]

[04:37] <TimToady> good

[04:37] <TimToady> ?eval {}

[04:37] <evalbot_r14487> undef

[04:38] <TimToady> ?eval { :a(1,2,3) }

[04:38] <evalbot_r14487> ("a" => (1, 2, 3))

[04:39] <audreyt> oy, I accidentally reverted

[04:39] <audreyt> if 4 -> $x {...}

[04:39] <audreyt> support, right before release

[04:40] <audreyt> bad me :/

[04:40] <audreyt> that was somehow rolled back along with the Judy changes

[04:40] <TimToady> blame your fingers.

[04:43] <audreyt> bbiab...

[04:43] <svnbot6> r14488 | audreyt++ | * ChangeLog: Minor fixup, and note the fact that if/elsif/else

[04:43] <svnbot6> r14488 | audreyt++ |   didn't really take pointies...

[04:49] <svnbot6> r14489 | audreyt++ | * Restore support for:

[04:49] <svnbot6> r14489 | audreyt++ |     if EXPR -> $x {

[04:49] <svnbot6> r14489 | audreyt++ |         ...

[04:49] <svnbot6> r14489 | audreyt++ |     }

[04:49] <svnbot6> r14489 | audreyt++ |     elsif EXPR -> $x {

[04:49] <svnbot6> r14489 | audreyt++ |         ...

[04:49] <svnbot6> r14489 | audreyt++ |     }

[04:49] <svnbot6> r14489 | audreyt++ |     else -> $x {

[04:49] <svnbot6> r14489 | audreyt++ |         ...

[04:49] <svnbot6> r14489 | audreyt++ |     }

[04:51] <TimToady> er, else -> $x ???

[04:51] <audreyt> yes so you know whether it was a 0 or a ''

[04:51] <audreyt> same as until

[04:52] <audreyt> seems consistent

[04:52] <TimToady> k

[04:52] <audreyt> there are as many interesting falses as there are trues..

[04:52] <TimToady> what a concept!

[04:52] <audreyt> hm. what should defer do outside contend block?

[04:52] <audreyt> noop?

[04:52] <audreyt> also, what should maybe do?

[04:52] <audreyt> imlicitly contend itself?

[04:53] <audreyt> I'd certainly like autocontend for maybe

[04:53] <TimToady> hmm

[04:53] <TimToady> outside of the lexical scope of a contend?

[04:54] *** justatheory joined
[04:54] <TimToady> contend {{{{{{{{ maybe {} }}}}}}} could be expected to autocontend by the user

[04:54] <TimToady> if they've forgotten the outer contend by then.

[04:55] <TimToady> probably not a huge issue, given common use will be directly inside a contend

[04:55] <audreyt> dynamic scope actually

[04:55] <TimToady> defer seems more like a control exception.

[04:55] <audreyt> I think both are dynamic in nature

[04:55] <audreyt> if you think it as control exception

[04:55] <audreyt> then defer would refuse to work outside contend

[04:56] <TimToady> in which case you can't know whether the maybe was intended to autocontend

[04:56] <audreyt> no, what I was saying is

[04:56] <TimToady> so we probably ought not autocontend

[04:56] <audreyt> maybe { foo } maybe { bar }

[04:56] <audreyt> is probably sufficient

[04:56] <audreyt> since nested contends are noops

[04:56] <audreyt> it seems to me that foo/bar must be atomic in nature

[04:57] <audreyt> and so maybe maybe should simply enter atomicity

[04:57] <audreyt> and defer should fail as a cont excp

[04:59] <TimToady> I suppose the state of a set of maybes should be held by the autocontend around them in any case, rather than some further out contend that might be managing several maybe roundrobins

[04:59] <audreyt> hm, I thought maybes are syntactic groups

[04:59] <audreyt> right.

[04:59] <audreyt> exactly what you said.

[04:59] <audreyt> so hmm, that makes

[04:59] <audreyt> maybe {...};

[04:59] <audreyt> exactly!

[04:59] <audreyt> the same as

[04:59] <audreyt> content {...};

[05:00] <TimToady> yes, except unless the contend is part of an outer maybe chain.

[05:01] <TimToady> maybe {...} maybe {...} contend {...} might be syntactically legal.

[05:01] <TimToady> esp with newlines

[05:01] <TimToady> but the maybes are their own thing, and the contend something else.

[05:02] <TimToady> hmm.  on p6l someone once asked whether you could say if $x {...}; else {...}

[05:02] <TimToady> don't think anyone ever answered...

[05:03] <TimToady> maybe {...} maybe {...}; maybe {...} is similar

[05:03] <audreyt> <warnock> applied, thanks

[05:03] <TimToady> I think if someone puts the semi, they probably intended to terminate the larger construct.

[05:04] <TimToady> but it's a lot of weight to put on a little semicolon, especially between maybe sets.

[05:04] <audreyt> which is why I originally think it as infix

[05:05] <audreyt> which avoids the problem by shoving people into operator think

[05:05] <TimToady> but then runs into last } on line issues

[05:05] <audreyt> contend/maybe acting exactly like if/elsif ?

[05:05] <svnbot6> r14490 | audreyt++ | * recurrence-grep.t: temporarily disable loopign test

[05:05] <audreyt> contend {...} maybe {...} maybe {...}

[05:06] <TimToady> seems to break the parallelism of the roundrobin

[05:06] <audreyt> but not really

[05:06] <audreyt> we're just changing the name of the first maybe

[05:06] <audreyt> contend {...    contend {...} maybe {...} }

[05:06] <audreyt> is totally legal

[05:07] <TimToady> I think the intent of contend is inward looking while the intent of maybe is outward looking

[05:07] <TimToady> so we shouldn't confuse them.

[05:07] <audreyt> ok. implementing maybe chains as is then

[05:07] <TimToady> good enough for now, and we can probably tweak later.

[05:09] <TreyHarris> where were contend and defer and maybe discussed?  i don't see them in synopses or on p6-l?

[05:09] <TimToady> they've only been discussed here

[05:10] <audreyt> TimToady: see examples/concurrency/stm*

[05:10] <TreyHarris> ah, ok.  i'll check scrollback then

[05:10] <TimToady> but it's been a couple of months ago

[05:11] <audreyt> coded up.

[05:11] <svnbot6> r14491 | audreyt++ | * Implement maybe {...} maybe {...} STM round-robin retry chains.

[05:12] <TimToady> actually, it was around July 1

[05:14] <audreyt> so, another two primitives with GHC where we don't implement yet

[05:14] <svnbot6> r14492 | audreyt++ | * Pugs.Prim: Remove retry_with.

[05:14] <audreyt> one is unsafeIOToSTM

[05:14] <audreyt> where let you "say ..." anyway in a contend

[05:14] <audreyt> promising you don't carre about rollign it back.

[05:14] <TimToady> the problem with autocontend around maybes is that defer wants to restart the official contend outside of that, not just the round-robin state container.

[05:14] <audreyt> actually defer there is like "break"

[05:14] <audreyt> in that it goes to the next robin

[05:15] <audreyt> and only on end of chain goes to outer contend

[05:15] <audreyt> I think it's sane...

[05:15] <root4o> is there some docs on contend/maybe

[05:15] <audreyt> root4o: they just existed like, 5 minutes ago

[05:15] <TimToady> for some reason I thought it started from the top but just selected the next path through.

[05:15] *** BooK_ joined
[05:15] <audreyt> TimToady: an orElse chain has the same semantic as maybe chain

[05:16] <audreyt> and I think retry in that falls to the next orElse first

[05:16] *** wilx joined
[05:16] <audreyt> we can force it to go upward using a counter

[05:16] <audreyt> but this current way is prolly fine

[05:16] <audreyt> anyway. unsafeIOToSTM.

[05:16] <audreyt> another primitive we don't expose is "assert"

[05:16] <audreyt> assert {...}

[05:17] <audreyt> runs the expression on each STM contention mutation point

[05:17] <audreyt> and if it evals false, then it's retried

[05:17] <audreyt> it implements the C in ACID

[05:17] <audreyt> (STM provides A/I)

[05:17] <audreyt> it sunds like a closure trait to me

[05:18] <audreyt> ALWAYS {...}

[05:18] <audreyt> ENSURE {...}

[05:18] <audreyt> or something, but not sure.

[05:20] <TimToady> INVAR if you want to go all CSy, but I kinda like ALWAYS

[05:21] <TimToady> maybe and CERTAINLY  :)

[05:22] <audreyt> INDEED {...}

[05:22] <gaal> FERSURE {...}

[05:22] <TimToady> AMEN {...}

[05:22] <TimToady> {...} DARNIT

[05:22] <gaal> YOUBET {...}

[05:23] <audreyt> ALWAYS makes perhaps most sense...

[05:23] <TimToady> doesn't work as a closure trait if you regularly autocontend

[05:23] <gaal> INVARIABLY, but that's long

[05:23] *** DHGE joined
[05:23] <audreyt> it's actually not a closure specific thing

[05:23] <audreyt> it's global within that contend

[05:23] <audreyt> so hm.

[05:23] <TimToady> maybe {...} maybe {... } always {...}

[05:24] <audreyt> contend {...} always {...}

[05:24] <TimToady> should it have access to lexical scope of contend?

[05:25] <TimToady> almost seems like it shouldn't

[05:25] <audreyt> it should be dynaamic

[05:25] <audreyt> (it's dynamic in the host language)

[05:25] <audreyt> which means always as "else" makes sense

[05:26] <gaal> is this assert prim a block that if fails, causes the transaction to be retried?

[05:26] <gaal> oh, 07:17 < audreyt> and if it evals false, then it's retried

[05:26] <audreyt> yes and it's checked on every TVar update

[05:27] <audreyt> Tim Harris's work. http://lambda-the-ultimate.org/node/1500

[05:27] <lambdabot> Title: Transactional memory with data invariants | Lambda the Ultimate

[05:27] <TimToady> contend if $whatever {...}

[05:27] <TimToady> maybe if $whatever {...}

[05:27] <audreyt> "if" doesn't seem right

[05:27] *** Aankh|Clone is now known as Aankhen``

[05:27] <TimToady> well, there's prior art in PRE/POST for blocks that are boolean context

[05:28] <TimToady> esp if it gets sent around as a closure

[05:29] <audreyt> yeah

[05:29] <audreyt> ALWAYS spans in the entire dynamic downward graph

[05:32] <svnbot6> r14493 | audreyt++ | * Pugs.Parser: This is one statement not several:

[05:32] <svnbot6> r14493 | audreyt++ |     maybe {...}

[05:32] <svnbot6> r14493 | audreyt++ |     maybe {...}

[05:32] <svnbot6> r14493 | audreyt++ |     maybe {...}

[05:35] <svnbot6> r14494 | audreyt++ | * examples/stm-retry-with.pl: Clean up it a bit.  It now runs just fine.

[05:35] <svnbot6> r14495 | audreyt++ | * rename to stm-contend.pl

[05:40] <audreyt> root4o: there's docs now...

[05:41] <svnbot6> r14496 | audreyt++ | * Perl6::Spec::Concurrency: Update nomenclature.

[05:41] <audreyt> root4o: read the first 183 lines of http://svn.openfoundry.org/pugs/docs/Perl6/Spec/Concurrency.pod

[05:41] <lambdabot> http://tinyurl.com/yjl9we

[05:42] <audreyt> start from "=head2 No user accessible locks"

[05:44] <svnbot6> r14497 | audreyt++ | * some more cleanup.

[05:44] <audreyt> TimToady: can any()/all() short circuit with data parallelism?

[05:44] <audreyt> that is

[05:44] <audreyt> any(1..999999999) > 0

[05:44] <audreyt> taking constant time even if you don't have that many processor?

[05:45] <audreyt> (only during an collapsing bool-cxt operation, of course)

[05:45] <TimToady> yes, junctions are allowed to bail out as soon as they're falsifiable or truifiable

[05:46] <audreyt> yay

[05:46] <audreyt> if any(1..9999).say { ... }

[05:46] <audreyt> will only print 1, then

[05:46] <audreyt> which is perhaps fine.

[05:47] <audreyt> (well, it will print 2+ numbers on SMP that didn't abort in time, but that's fine too)

[05:48] <audreyt> actually, junctional invocants are never really talked about

[05:48] <audreyt> iirc

[05:48] <audreyt> but it fallback to sub in this particular case

[05:48] <audreyt> but that means

[05:48] <audreyt> any($obj1, $obj2).meth

[05:48] <TimToady> yes, junctions make no promise about how many side effects may or may not happen

[05:48] <audreyt> can't go calling $obj1.meth and $obj2.meth unless they hapen to be exported meths

[05:49] <audreyt> or maybe it redispathch thru method first too...

[05:49] <TimToady> unlike hypers, which guarantee all, but not necessarily in any order

[05:52] <TimToady> I would not expect any(@x).meth to vectorize prettily in general unless there's some way to prove that all the elements would dispatch the same way.

[05:53] <audreyt> well but it can still SMP/Grid parallelise

[05:53] <audreyt> which is a bigger win in general

[05:53] <audreyt> vectorize instructions only works for unboxed storage cells anyway

[05:54] <TimToady> still, you'd expect any(1..100).abs to vectorize pretty well.

[05:55] <audreyt> *nod*

[05:55] <audreyt> any(1..100).someIntMethod

[05:55] <audreyt> wouldn't neccessarily, though.

[05:55] <TimToady> can have multis that pick individual values

[05:55] <audreyt> $obj.*meth has nothing to do with parallelism, right?

[05:56] <audreyt> i.e. I'm not allowed to SMP calls across the MRO?

[05:56] <TimToady> .* is pretty much defined to visit in standard order.

[05:56] <audreyt> seeing how BUILDALL is built on it that's probably wise

[05:56] <TimToady> and any one of them can use "last" to abort the rest

[05:56] <audreyt> nod

[05:57] <TimToady> so one would have to use STM tricks to parallelize a .* on spec

[05:58] <TimToady> and defer if anyone earlier did "last"

[05:58] <audreyt> yeah. but that still means unordered IO

[05:58] <audreyt> or even no IO

[05:58] <audreyt> neither of which is part of .*meth promise probably

[05:58] <TimToady> yeah

[05:58] <TimToady> well, that's good that they fill different niches.

[05:59] <TimToady> I guess .* is a funny kind of monad

[06:00] <TimToady> sort of an internal IO monad for relations between objects...

[06:04] <audreyt> *nod*

[06:08] <svnbot6> r14498 | raptor++ | adding myself ;")

[06:17] <eviltwin_b> I finally have almost-stable dports (after giving up on doing it "right", nuking everything, and reinstalling...)

[06:17] *** marmic joined
[06:17] <eviltwin_b> I might be able to get a pugs build that works now

[06:18] <audreyt> ooh

[06:19] <eviltwin_b> (at minimum, my perl5 was horked, but pugs found and used it, so things were a bit odd)

[06:21] *** root4o left
[06:27] <audreyt> sleeptime. *wav*

[06:54] *** seano joined
[06:55] *** iblechbot joined
[07:12] *** yts joined
[07:17] *** ditto joined
[07:18] <TimToady> @tell audreyt my latest smoke ran almost 200% slower.  ouch.  will try again with realclean while I sleep...

[07:18] <lambdabot> Consider it noted.

[07:21] <TimToady> @tell audreyt probably not a problem--looks like my cpu was stuck on low speed for some reason.

[07:21] <lambdabot> Consider it noted.

[07:21] *** buetow joined
[07:23] <TimToady> Ôº∫Ôº∫Ôº∫ÔºÜ

[07:40] <Juerd> audreyt: Okay

[07:52] <xinming> @tell xinming This is a test

[07:52] <lambdabot> You can tell yourself!

[07:52] <xinming> ....

[08:04] *** cnrocks is now known as cumulonimbus

[08:07] *** cumulonimbus is now known as CumuloNimbus

[08:07] <lumi> Is docs/Perl6/Spec/Concurrency.pod under pugs svn?

[08:08] <lumi> There's a typo there (outermose), which should probably be "outermost" and not "outermoose"

[08:10] <xinming> lumi: How about your email? /msg me

[08:12] <svnbot6> r14499 | lumi++ | A typo, fixed.

[08:17] *** drrho joined
[08:29] <gaal> hmm, I think I'd prefer ÔºÆ ÔºÆ ÔºÆ to Ôº∫Ôº∫Ôº∫. Integer sleep? meh

[08:29] <svnbot6> r14500 | lumi++ | More typos smitten.

[08:30] <gaal> Ôº≤Ôº≤Ôº≤ is also good

[08:31] * gaal doesn't consider "outermoose" to be a typo, but that's just me and my deer

[08:35] <lumi> Dear sir or ungulate

[08:51] *** hikozaem_ joined
[09:15] *** andara joined
[09:56] *** ruoso joined
[09:57] *** kensanata joined
[10:03] *** idiotmax_ joined
[10:03] *** hcchien joined
[10:04] *** f0rth_ joined
[10:04] *** cookys_ joined
[10:04] *** penk joined
[10:07] *** penk joined
[10:15] *** hcchien joined
[10:24] *** iblechbot joined
[10:24] *** jferrero joined
[11:06] *** chris2 joined
[11:14] *** xinming_ joined
[11:23] *** weinig|bbl is now known as weinig_

[11:23] *** weinig_ is now known as weinig

[11:31] *** Psyche^ joined
[11:32] *** fglock joined
[11:40] <svnbot6> r14501 | fglock++ | v6/runtime

[11:40] <svnbot6> r14501 | fglock++ | - added setup_type() create typed-cell p5-classes

[11:40] <svnbot6> r14501 | fglock++ | v6/emitter(2)

[11:40] <svnbot6> r14501 | fglock++ | - my/our take parameters { readonly => 1, type => Dog }

[11:40] *** Psyche^ is now known as Patterner

[11:44] *** thepler joined
[11:46] <svnbot6> r14502 | fglock++ | v6/emitter(2) - merged minor HACKING, TODO, Any.pm changes

[12:15] *** Limbic_Region joined
[12:25] *** HiTech69 joined
[12:39] *** mauke joined
[12:47] *** nipotan is now known as nipotaway

[12:50] *** vel joined
[12:50] *** iblechbot joined
[12:58] <svnbot6> r14503 | fglock++ | v6/emitter(2) - the type of cell depends on the context

[12:58] <svnbot6> r14503 | fglock++ |     $native.bind_from is read-only

[12:58] <svnbot6> r14503 | fglock++ |     $native.VAR is read-write

[13:02] *** fglock joined
[13:02] <fglock> ?eval (1,2,3)[1]=5

[13:02] <evalbot_r14503> user error (Incompatible version number for compilation unit‚ê§Consider removing blib6/lib/Prelude.pm.yml and make it again‚ê§)‚ê§pugs: user error (*** *** Can't modify constant item: VUndef‚ê§        at <prelude> line 785, column 9-46‚ê§           <prelude> line 785, column 9-46‚ê§    at)‚ê§

[13:04] *** bonsai joined
[13:08] <gaal> ?eval "prelude fix?"

[13:08] <evalbot_r14503> pugs: user error (*** *** Can't modify constant item: VUndef‚ê§        at <prelude> line 785, column 9-46‚ê§           <prelude> line 785, column 9-46‚ê§    at)‚ê§

[13:11] <gaal> ?eval "prelude fix?"

[13:11] <evalbot_r14503> "prelude fix?"

[13:11] <gaal> yay

[13:13] *** ditto joined
[13:17] <svnbot6> r14504 | fglock++ | v6/emitter(2) - added more questions in HACKING

[13:21] *** jiing joined
[13:25] *** [particle] joined
[13:26] *** [particle] joined
[13:49] <audreyt> @messages

[13:49] <lambdabot> TimToady said 6h 31m 43s ago: my latest smoke ran almost 200% slower. ouch. will try again with realclean while I sleep...

[13:49] <lambdabot> TimToady said 6h 28m 42s ago: probably not a problem--looks like my cpu was stuck on low speed for some reason.

[13:49] <audreyt> greetings \camels

[13:51] *** AzureBOT joined
[13:52] <gaal> yo yo audreyt

[13:53] <Limbic_Region> salutations audreyt

[13:53] * Limbic_Region is posting his meditation about his NP complete project but plans on running a smoke soonish

[13:53] <[particle]> hi audreyt, what part of the world are you in today?

[13:54] *** rlb3 joined
[13:54] <audreyt> [particle]: Portland. in ~7 hours going to present my talk at OOPSLA/DLS

[13:54] <[particle]> g'luck

[13:54] <audreyt> the doubled room for DLS is beyond maxed out (200+ known attendees in a 205 capacity room)

[13:54] <audreyt> so they got student volunteers to act as bouncers to prevent walkin people

[13:55] <[particle]> you've got bouncers?

[13:55] <audreyt> any(<SeaSide PyPy Pugs>) must be attractive to some people...

[13:56] <audreyt> actually s/SeaSide/DabbleDB/

[13:57] <audreyt> Limbic_Region: cool! *goes to perlmonks to read*

[13:59] <fglock> audreyt: does $a := $b does typechecking?

[14:00] <gaal> if i were a walkin person i'd masquerade as a bouncer

[14:05] *** hexmode joined
[14:08] <xinming_> audreyt: what do you use for editing haskell please?

[14:08] <audreyt> xinming_: vim

[14:08] <xinming_> audreyt: do you use Emacs?

[14:08] <audreyt> oy, perlmonks trapped me

[14:08] * audreyt posted a reply to http://perlmonks.org/?node_id=580004

[14:09] <lambdabot> Title: Parrot, threads & fears for the future.

[14:09] <xinming_> audreyt: In fact, I like Emacs more, But now, I switch to vim, as start up speed in Emacs is really slow.

[14:09] * xinming_ goes to read the post

[14:15] <audreyt> xinming_: and no, I do not

[14:15] <audreyt> I've passing acquaintance with both Emacs and Eclipse

[14:16] <audreyt> my ability to script either is not as good as my ability scripting my shell

[14:16] <audreyt> so I prefer making shell my IDE, but that's entirely a personal choice :)

[14:17] *** cjeris joined
[14:19] <wolverian> audreyt, nice post ;)

[14:21] *** kensanata joined
[14:22] <audreyt> wolverian: BrowserUK tends to get me into this tone ;)

[14:22] <xinming_> Emacs is powful, But Emacs Makes A Computer Slow is really a truth, Now, I use emacs as my "OS", and vim as my primary editor, I am tired of waiting emacs to open a file to edit for me

[14:22] <Limbic_Region> audreyt - will ping you when it is ready, lots of links to include

[14:22] <wolverian> audreyt, you're not the only one :)

[14:25] *** iblechbot joined
[14:25] <gaal> resuming the sleep thread, audreyt's of course is Ôº£Ôº£Ôº£

[14:25] <gaal> it's real, but she commits at the same time

[14:28] <osfameron> ooo, shiny :-)  I think it was a good PM post if it got a good result like that

[14:28] <osfameron> of course, it'll be shinier if concurrent stuff properly works in Win32 as well

[14:28] <audreyt> osfameron: it does not?

[14:28] <audreyt> I thought SMP parallization does in win32 as well

[14:29] <audreyt> and STM I tried with Win32 just he other day...

[14:29] <audreyt> (GHC 6.6, trunk Pugs)

[14:29] <osfameron> I mean that for concurrent *Perl5* Win32 is a second class citizen

[14:29] <osfameron> fork + alarm is very flakey

[14:29] <audreyt> oh that

[14:30] <osfameron> so if it all works on win32 come perl6 that's fantastic

[14:30] <audreyt> sure it all works :)

[14:30] <wolverian> hm, I see the concurrency pod has some new stuff (or at least new names for things). interesting

[14:30] *** seano joined
[14:30] <wolverian> and pugs implements all of it?

[14:30] <audreyt> it had better, as I think Win32 is one of the first tier work platforms for the GHC HQ at MS Research

[14:31] <audreyt> wolverian: yes

[14:31] <wolverian> very nice!

[14:31] <audreyt> (after FreeBSD and Linux, I think)

[14:31] <audreyt> Apple hardware is still not popular in MSR. I wonder why ;)

[14:31] <osfameron> it was one of the questions I asked in the "Ask Perl 6" back in... oh!  2002

[14:32] <osfameron> of course I no longer use Win32 when I can avoid it, but I still think it'll be an advantage

[14:33] <wolverian> audreyt, is the purity of atomic blocks detected at compile time?

[14:35] <audreyt> wolverian: once we gen codegen to GHC (via MOH, for Great Performance) then yes

[14:35] <audreyt> currently it's runtime.

[14:36] <wolverian> yay :)

[14:36] <audreyt> some of them will remain runtime though

[14:36] <audreyt> since you can rebind previously pure functions into nonpure ones

[14:36] <audreyt> and then compiler can't catch that

[14:37] <audreyt> but that's fine; runtime still does

[14:37] <wolverian> whoo, DateTime::Natural::Parse!

[14:37] <audreyt> wooo!

[14:37] <wolverian> hm. it's not very i18n.

[14:38] <audreyt> and fails tests. but hey, first day of a module

[14:38] <wolverian> it's the principle :)

[14:38] <audreyt> BEGIN { release } loop { release }

[14:42] *** weinig is now known as weinig|coffee

[14:47] *** mj41 joined
[14:50] *** nothingmuch joined
[14:54] *** weinig|coffee is now known as weinig

[15:21] *** ofer0 joined
[15:25] *** elmex joined
[15:29] <audreyt> Q: which way to write has_twim_prime is most clear to you?

[15:30] <audreyt>     is_prime(all($n, $n + any(2, -2)));

[15:30] <audreyt>     is_prime($n & ($n + (2 | -2)));

[15:30] <audreyt>     is_prime($n + (0 & (2 | -2)));

[15:30] <audreyt>     is_prime($n) and is_prime($n + any(2, -2));

[15:30] <audreyt>     is_prime($n) and is_prime($n + 2 | $n - 2);

[15:31] <audreyt> (bbiab)

[15:34] <kensanata> not knowing anything about perl6 and therefore not knowing the foo(a|b) syntax, i still like the last variant best.

[15:37] *** chris2 joined
[15:38] <wolverian> same here.

[15:41] <mauke> is_prime($n + (0 & (2 | -2))); for minimized redundancy

[15:44] <wolverian> heh. I thought it was bitops. sigh.

[15:47] <TimToady> ?eval sub infix:<¬±> ($b,$d) { $b + $d | $b - $d } say 42 ¬± 3

[15:47] <evalbot_r14504> OUTPUT[any(VInt 39,VInt 45)‚ê§] Bool::True

[15:47] <masak> last one

[15:48] <TimToady> isprime($n) and is_prime($n ¬± 2)

[15:49] <audreyt> how do you pronounce the infix +- ?

[15:49] <TimToady> plus-or-minus

[15:49] <wolverian> heh. now I can finally write the equation for second order polynomials properly

[15:50] <audreyt> TimToady: you think it's better?

[15:51] <audreyt> I'll so a lexical sub infix then

[15:51] <wolverian> makes me want a both()

[15:51] <audreyt> both?

[15:51] <TimToady> plus-and-minus, I presume

[15:52] <audreyt> ah.

[15:52] <mauke> .oO( any (all is_prime . map (n +)) (map ((0 :) . return . flip id 2) [id, negate]) )

[15:52] <wolverian> waving hands in that direction, yeah

[15:53] <wolverian> also, all/any is weird with two item arguments

[15:53] <audreyt> which is why we have infix...

[15:54] <wolverian> and why people preferred them in this case, I suppose. good point. :)

[15:55] *** shobadobs joined
[15:56] *** justatheory joined
[15:57] *** arguile joined
[15:58] <TimToady> The recent PM thread on threads makes me wonder how long it would take to write a Parrot byte code interpreter in Haskell...

[15:59] <audreyt> the real trick is in the PMCs...

[15:59] <ofer0> will perl6 require a new CPAN ?

[15:59] <audreyt> ofer0: an improved CPAN :)

[15:59] <ofer0> audreyt, wonderful

[16:01] <wolverian> so I'm trying to pass the + function to another function in C. this calls for a beer or two (to celebrate)

[16:02] <TimToady> C has approximately as much support for first class functions as it does for first class strings...  :/

[16:02] <fglock> in '$a := $b' does $b needs to agree with the previous type of $a?

[16:05] <TimToady> it should agree with the type of VAR($a)

[16:05] <TimToady> doesn't have to agree with the previous contents

[16:07] <TreyHarris> hm.  ext/Recurrence/t/recurrence-grep.t spun its wheels all night in my last smoke... r14489

[16:10] <audreyt> TreyHarris: I disabled it... havn't had time to investigate. help welcome (try pugs -d)

[16:11] *** Gothmog__ joined
[16:11] * fglock hides <== guilty of quite a few infinite loops

[16:12] *** HiTech69 joined
[16:13] *** Gothmog__ is now known as Gothmog_

[16:16] *** frankg joined
[16:26] <audreyt> TimToady: also, Parrot opcodes were designed to be insanely fast interpreted and only augment with some JIT

[16:26] <audreyt> to which D or C+ASM is still be better host language to code that

[16:27] <Limbic_Region> audreyt - http://perlmonks.org/index.pl?node_id=580093

[16:27] <audreyt> Pugs otoh will use ahead of time compilation mostly to gain performance, or find some VM that has good JITting/runtime tuning (StrongTalk et al, some more advanced JVMs). maybe both.

[16:28] <lambdabot> Title: How many words does it take?

[16:29] <audreyt> insanely fast interpretation makes a lot of sense, but with rapidly converging CPU types, is at disadvantage with CPU-specific AOT schemes...

[16:29] <audreyt> Limbic_Region: woot

[16:31] <Limbic_Region> it only takes 1 word to use all the letters audreyt - ambidextrously

[16:32] <audreyt> very, very cute

[16:33] <audreyt> though Parrot's interpretation speed, like Squeak's, is already quite Fast Enough (i.e. better than perl5 generally)

[16:33] <Limbic_Region> http://www.gatcomb.org/dictdemo/demo.cgi if you want to try the demo for yourself

[16:33] <lambdabot> Title: How many words does it take.....

[16:34] <audreyt> so it's largely the OO dispatch, multi dispatch, junctional dispatch etc that matters

[16:34] <audreyt> (all 3 has currently quite unnatural encoding on Parrot that defeats the fast runloop)

[16:35] <audreyt> (not surprisingly, seeing how they are specced only after parrot implemented something else entirely...)

[16:35] <audreyt> (so they are fixable given time and effort and C-fu.)

[16:36] * Limbic_Region needs to re-read the parrot and threading meditation now that many more folks have replied

[16:37] *** SCalimlim joined
[16:45] *** chaoslawful joined
[16:46] <Limbic_Region> audreyt++ for her responses in that thread and in general for just being her

[16:47] <audreyt> er, uhm. thanks. *blush*

[16:49] <audreyt> the irreconcilable slide for parallelism is now titled

[16:49] <audreyt> "Concurrency vs Sanity"

[16:49] <audreyt> uploading for review...

[16:51] <[particle]> jonathan++ for taking on objects pdd

[16:51] <[particle]> ww, but it still applies :)

[16:51] <gaal> random periodic prod: how do multi sub express the notion of guards, in light of guard order and separate compilation?

[16:52] <audreyt> gaal: still where clauses

[16:52] <audreyt> multi f ($x, $y where { $x > $y > 1 }) {}

[16:53] <audreyt> and ordered guard must be when'd

[16:53] <audreyt> multi f ($x, $y) { when $x > $y > 1 { ... } when $x == $y { ... } }

[16:53] <audreyt> Pugs has freed when from given

[16:53] <audreyt> so that style is noe encouraged

[16:53] <audreyt> now

[16:53] <gaal> oh! this is new

[16:53] <audreyt> yes

[16:53] <audreyt> as of 6.2.13

[16:53] <audreyt> part of the rewritten Eval monad

[16:54] <gaal> so multiness and guardiness is orthogonal, as desired

[16:54] <audreyt> yes.

[16:54] <audreyt> and break/continue in when works as you expect

[16:54] <audreyt> even outside given

[16:54] <audreyt> given is now purely sugar for

[16:54] <gaal> though, is the body inside the when? that's funny

[16:54] <audreyt> (-> $_ is rw {...})()

[16:54] <gaal> oh sorry

[16:54] <gaal> it's inside the body, not the sig

[16:54] <audreyt> yup

[16:55] <gaal> can when accept a signature? I'm tihngking unpacking

[16:55] <gaal> when BinTree $x :($left, $right) { ... }

[16:55] <audreyt> yes. and actually part of S03

[16:56] <audreyt> you can even do this:

[16:57] <audreyt> sub f (|$_) { when :(...sig...) {...} when :(...sig...) {...} }

[16:57] <audreyt> which gives you pattern guards.

[16:57] <gaal> w00t

[16:57] <audreyt> this is finally looking like a usable language, isn't it :)

[16:57] <gaal> the only thing not to like about this is the wasted indent level

[16:57] <audreyt> you are free to not indent ;)

[16:58] <gaal> but haskell's gotta be good for something :-P

[16:58] <audreyt> and infact intend level is the same

[16:58] <audreyt> sub f (|$_) {

[16:58] <audreyt>     when :(...)

[16:58] <audreyt>     { ... }

[16:58] <audreyt>     when :(...)

[16:58] <audreyt>     { ... }

[16:58] <audreyt> }

[16:58] <audreyt> if you write it that way

[16:58] <gaal> as guard syntax, yes, but not declarative

[16:58] <audreyt> yup

[16:59] *** cdpruden joined
[16:59] <gaal> because multis do not capture that

[16:59] <audreyt> well they do if all your when is matching with sigs

[16:59] <gaal> but it's much saner like this.

[16:59] <audreyt> yup.

[16:59] <gaal> I wouldn't use them for that, because order is hard to predict

[16:59] <audreyt> aye

[17:00] <audreyt> I helped clkao briefly a couple days ago to write new SVK::Mirror in implemented subset of perl6

[17:00] <audreyt> it's surprisingly 1)easy 2)fun

[17:00] <audreyt> @.meth: 1,2,3;

[17:00] <lambdabot> Unknown command, try @list

[17:00] <audreyt> alone, saved screenfuls of lines.

[17:01] <TimToady> :)

[17:01] <gaal> what does that mean?

[17:01] <TimToady> it means I'm happy.

[17:01] <TimToady> :)

[17:01] <audreyt> @(self.meth(1,2,3))

[17:01] <lambdabot> Unknown command, try @list

[17:01] <audreyt> :D

[17:01] <audreyt> TimToady++

[17:01] <gaal> :)

[17:02] <audreyt> gaal: because that means you can override in subclass the accessors

[17:02] <audreyt> and have the consumer not care about if it's an accessor or a method

[17:02] <audreyt> because they ae exactly the same thing

[17:02] <audreyt> $.foo does not promise anything about $!foo's existence

[17:02] <TimToady> to the user, it *is* an array with a "longer name"

[17:02] <audreyt> and neither does the other way around

[17:02] <audreyt> and "user" here means "derived class"

[17:03] <audreyt> which is amazing abstraction.

[17:03] <seano> audreyt: I'm looking at trying to implement .can/.methods/.whatever...  any hints on where to get started looking at metaclasses inside pugs?  findSub in Var.hs is, at 270 lines, somewhat daunting...

[17:03] <audreyt> seano: oy! you don't want Eval.Var

[17:03] <TimToady> for a change, an abstraction that seemed obvious to /me

[17:03] <audreyt> seano: you want to help getting MOH fully implemented

[17:03] <gaal> *nod* cool

[17:03] <audreyt> since Eval.Var is going to be swapped entirely out to MOH

[17:03] <seano> ah...  who's on that?

[17:03] <audreyt> cmarcelo, nothingmuch

[17:04] <seano> I thought I remembered your mentioning something about that...

[17:04] <audreyt> http://perlcabal.org/~cmarcelo/moh/

[17:04] <lambdabot> Title: Index of /~cmarcelo/moh

[17:04] * seano really wants his tab-completion in the shell ;)

[17:04] <audreyt> source: http://nothingmuch.woobling.org/MO/

[17:04] <lambdabot> Title: Index of /MO

[17:04] <seano> thanks

[17:04] <audreyt> seano: MOH gives us true reflection; what Pugs currently does is just embed into packages

[17:04] <audreyt> which is curiously exactly the same as Perl5

[17:04] <audreyt> and not at all relevant or correct anymore

[17:05] <audreyt> and instead of writing an abstraction DWIM layer like Class::MOP/Moose

[17:05] <audreyt> we might as well implement the Right Thing right away

[17:05] <seano> ok.  thanks.  is the MO stuff up for the next release-ish, or is that a long way off?

[17:05] <audreyt> which is also considerably faster since it has the option of compiling into native haskell

[17:05] <audreyt> it's what next release will be about.

[17:05] <audreyt> and I plan to import it when I'm in Brazil

[17:05] <audreyt> so like, a couple weeks, a couple months tops.

[17:05] <seano> what's that, "the right is the enemy of the tolerable"?

[17:06] <audreyt> we tolerated the Pythonic Perl5 OO model for long enough...

[17:06] *** aufrank joined
[17:06] <seano> cool...  well, I'll look into this then back-burner it, probably.

[17:06] <aufrank> hi hi

[17:06] <audreyt> cool thanks!

[17:06] <audreyt> aufrank: heya

[17:06] * audreyt gets ready to go to the conference

[17:06] <aufrank> which syntax works for passing named arguments into p5 subs?

[17:07] <audreyt> %h.kv

[17:07] <audreyt> since they are, well, not named.

[17:07] <aufrank> my $foo = Text::CVS_XS.new( sep_char => "|") #works

[17:07] <audreyt> oh, yes, since pairs are implicitly kv's

[17:07] <audreyt> for the p5bridge

[17:07] <aufrank> but adverbial doesn't work?

[17:07] <audreyt> I mean named pairs.

[17:08] <audreyt> :sep_char<|> should work

[17:08] <audreyt> does it not?

[17:08] <audreyt> if not, write a test, though I'm surprised.

[17:08] <audreyt> http://pugs.blogs.com/talks/dls06-pugs.pdf up.

[17:09] <aufrank> Can't use string ("sep_char") as a HASH ref while "strict refs" in use at /opt/local/lib/perl5/site_perl/5.8.8/darwin-thread-multi-2level/Text/CSV_XS.pm line 63.

[17:09] <audreyt> 250 slides, 60 minutes

[17:09] * aufrank goes to write a test

[17:14] <gaal> good luck :)

[17:14] <gaal> or did you already give it?

[17:14] <TimToady> I thought you were wishing aufrank good luck writing a test.  :)

[17:15] *** ajs left
[17:15] <gaal> aw, I should have said "or did you already do it?" and maintain the ambiguity

[17:15] <gaal> english has these wonderfully wimpy verbs

[17:15] <TimToady> it is fortunate that pronouns in English are ambiguous as to gender.

[17:16] <TimToady> Even "you guys" is genderless (more or less) in California

[17:16] <gaal> Hebrew gender markings are a pain, and are being eroded

[17:17] <aufrank> question: I've got my svk mirror set to svn.perl.org, which is RO.  Is there a way to change it to the openfoundry mirror without resyncing the whole thing?

[17:17] <Limbic_Region> TimToady - I find it more unfortunate that there is not an explicit singular form of gender neutral pronoun

[17:17] <gaal> some of them don't make sense though; the -a suffix means feminine all over the place, but in the cardinals, it means masculine.

[17:17] <TimToady> on the other hand, English is wonderfully expressive when it comes to verbs of destruction.  There are hundreds of ways to destroy something.

[17:18] <gaal> b0rk b0rk b0rk

[17:18] <gaal> oh, that's Swedish

[17:18] <TimToady> sure there is, people just don't like that it's "they".

[17:18] <TimToady> but singular "they" goes back many centuries.

[17:19] <aufrank> there was a great language log post showing singular third person use of "they" going back a long ways, including in Shakespeare

[17:19] *** justatheory joined
[17:19] * gaal pulls out oed2...

[17:19] <[particle]> and all this time i've been using s?he

[17:20] <audreyt> aufrank: no, please remirror. sorry.

[17:20] <gaal> 1526 first citation

[17:20] <aufrank> yargh.  OK.  test might take a while ;)

[17:21] <Limbic_Region> TimToady - wasn't aware that 'they' was grammatically correct for singular though I use it for that purpose all the time

[17:22] <TimToady> indeed, everyone does, even proscriptive English teachers.

[17:22] <TimToady> they just don't notice when they're doing it.

[17:22] * gaal wonders who W. de W. was

[17:23] <TimToady> maybe we should change "they" to default to singular, and then use "they guys" for the plural.

[17:23] <gaal> relatedly, where does "them apples" come from?

[17:24] <gaal> (how do you like, etc.)

[17:24] <[particle]> how's about them apples!

[17:24] <TimToady> I blame Steve Jobs.

[17:25] <gaal> lol

[17:26] <[particle]> urbandictionary points to WWI

[17:27] <fglock> audreyt: re Rule.pmc slide - it now looks a little different

[17:27] <gaal> beh. oed has a bug, vol 17 page 889 says THEIST-THEIST, but it's actually THEIST-THEM

[17:27] <aufrank> http://itre.cis.upenn.edu/~myl/languagelog/archives/002742.html

[17:27] <gaal> i wonder if they hand out commit bits

[17:27] <lambdabot> Title: Language Log: Singular <B><I>they</I></B> with known sex, http://tinyurl.com/sjdfl

[17:27] <aufrank> http://itre.cis.upenn.edu/~myl/languagelog/archives/002748.html

[17:27] <lambdabot> Title: Language Log: Shakespeare used <B><I>they</I></B> with singular antecedents so t ..., http://tinyurl.com/yzjybe

[17:28] <gaal> aufrank: 1526 is even earlier

[17:29] <aufrank> but without the oomph of little Willy

[17:30] <gaal> imagine the fun if W. de W. turned out to be "William Williamson"

[17:32] *** BooK__ joined
[17:32] <audreyt> fglock: ok, fixing

[17:36] <fglock> audreyt: that difference was due to recent s/lrep/v6.pm/ for bootstrapping

[17:38] <gaal> oof, the bibiliography is buggy also :(

[17:45] *** macli joined
[17:46] *** theorb joined
[17:50] *** seano left
[17:50] *** seano joined
[18:03] *** buetow joined
[18:09] *** polettix joined
[18:20] *** penk joined
[18:21] <ingy> hi TimToady

[18:28] *** beppu joined
[18:30] *** hexmode joined
[18:31] *** seano joined
[18:50] <aufrank> can I query the signature of a builtin function in the pugs shell?

[18:50] <aufrank> for example, can I find out what arguments open takes?

[18:50] <gaal> not yet!

[18:50] <gaal> but soon

[18:50] <gaal> definitely before next release

[18:51] <aufrank> neat :)

[18:51] <aufrank> in that case, can I query the channel?  ;)

[18:51] <gaal> aufrank: if you want to help make this soon*er*, you can

[18:51] <gaal> eg:

[18:52] <gaal> ?eval :($the :sig($parser) :already($works)

[18:52] <evalbot_r14504> Error: ‚ê§Unexpected "($"‚ê§expecting qualified identifier, "*" or ":"

[18:52] <gaal> ?eval :($the :sig($parser) :already($works))

[18:52] <evalbot_r14504> Error: ‚ê§Unexpected "($"‚ê§expecting qualified identifier, "*" or ":"

[18:52] <gaal> doh!

[18:52] <gaal> ?eval :($the, :sig($parser), :already($works))

[18:52] <evalbot_r14504> CCall "perl" CaptMeth {c_invocant = VPure (SigSubSingle {s_requiredPositionalCount = 1, s_requiredNames = fromList ["already","sig"], s_positionalList = [MkParam {p_variable = "$the", p_types = [], p_constraints = [], p_unpacking = Nothing, p_default = <ParamDefault:Nothing>, p_label = "the", p_slots = fromList [], p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = fromList [("already",MkParam {p_variabl

[18:52] <gaal> that is actually correct output, kinda :)

[18:52] <gaal> ?eval :($the, :sig($parser), :already($works)).perl

[18:52] <evalbot_r14504> "CCall \"perl\" CaptMeth \{c_invocant = VPure (SigSubSingle \{s_requiredPositionalCount = 1, s_requiredNames = fromList [\"already\",\"sig\"], s_positionalList = [MkParam \{p_variable = \"\$the\", p_types = [], p_constraints = [], p_unpacking = Nothing, p_default = <ParamDefault:Nothing>, p_label = \"the\", p_slots = fromList [], p_hasAccess = AccessRO, p_isRef = False, p_isContext = False, p_isLazy = False}], s_namedSet = fromList [(\"already\",M

[18:53] <gaal> anymoose:

[18:53] <gaal> in the parser, there are *two* functions handling function signatures now

[18:53] <aufrank> gaal-- very cool!

[18:53] <gaal> the old one needs to be retired

[18:53] <gaal> and replaced by the new one

[18:54] <gaal> the new one's called ruleSignature

[18:54] <gaal> it's what constructed this literal above

[18:54] <aufrank> what's the old one called?

[18:55] <aufrank> do the new and old haskell functions have the same signature?

[18:55] *** arguile_ joined
[18:56] <gaal> ruleSubParameters or thereabouts

[18:56] <gaal> they don't have the same signature

[18:56] <aufrank> so it's not just a find and replace

[18:57] <gaal> ruleSubParameters :: ParensOption -> RuleParser (Maybe [Param])

[18:57] *** hexmode joined
[18:57] <gaal> the flag is whether the parens are optional or not

[18:57] <gaal> and it returns a list of *oldstyle* parameters

[18:58] <gaal> ruleSignature returns an Exp, but it's always a newVal Signature

[18:59] <gaal> the parser isn't the only place that'll need to be changed; everywhere were its result is interrogated must be upgraded too

[18:59] <gaal> but that's what's type inference is for :-)

[18:59] <aufrank> gaal: is there a clear-cut step 1 here?

[19:06] *** bernhard joined
[19:07] <[particle]> write tests?

[19:07] <gaal> oops, sorry, back

[19:07] <gaal> tests for the most part exist

[19:08] <gaal> ie, 98% of t/

[19:08] <gaal> will break without functions :)

[19:09] <gaal> I think there are two ways to go about it.

[19:09] <gaal> The first it to gradually port the old sig parser to use new Params and not old ones

[19:09] <gaal> this way there's a chance you'll get something to compile faster

[19:10] <gaal> it may break on e.g. named args or optional ones, but it would be a start

[19:10] <gaal> that way you get to start modifing code in other portions apart from Parser, which is good

[19:11] <gaal> the drawback of this approach is that you may find the teasing apart difficult. I can't say... maybe worth trying.

[19:11] <gaal> the other WTDI is to just delete the old function, wire everything to use the new one, and chase the errors.

[19:12] <gaal> s/8/9.6/

[19:15] <aufrank> gaal: sounds like something I could work on

[19:15] <aufrank> I won't get to look at it in detail until tonight, though

[19:15] <aufrank> right now I'm trying to use Getopt::Long with v6-alpha for $work

[19:17] <gaal> yay

[19:17] <gaal> aufrank++

[19:18] <aufrank> anyone have any ideas why the result of the GetOptions() method from Getopt::Long is getting returned as 1.0 instead of a hash of option declarations?

[19:20] <gaal> can you show us the line where you call it?

[19:21] <gaal> also, try (GetOptions(....)).perl

[19:22] <PerlJam> Assuming the perl6 version adheres to the perl5 semantics, GetOptions returns a true value or a false value but doesn't necessarily say what those values are.  (so a true value could be 1)

[19:22] <pasteling> "aufrank" at 128.151.80.181 pasted "trying to use v6-alpha and perl5:Getopt::Long" (13 lines, 238B) at http://sial.org/pbot/20615

[19:24] <gaal> oh, PerlJam's right

[19:24] <aufrank> PerlJam: I see.  I thought it returned a hash of option-name option-value pairs

[19:24] *** chris2 joined
[19:24] <gaal> the idiom i use for that is GetOptions \my %opt, qw(spec here)

[19:24] <PerlJam> aufrank: that would be a sanish thing to do probably  :-)

[19:25] <aufrank> ok, so now there's just the question of why setting the option on the command line isn't working

[19:25] * aufrank notes gaal's neat idiom

[19:26] <gaal> well, in p5 you'd need to say

[19:26] <gaal> 'in=s' => \$infile

[19:27] <aufrank> ?eval my $infile = '-'; $infile.perl.say; \$infile.perl.say

[19:27] <evalbot_r14504> OUTPUT[\"-"‚ê§\"-"‚ê§] \Bool::True

[19:27] <aufrank> same difference in perl6, right?

[19:27] <aufrank> ?eval my $infile = '-'; $infile.perl == \$infile.perl;

[19:27] <evalbot_r14504> Bool::True

[19:27] <gaal> it's a Capture constructor in p6

[19:28] <gaal> which I think p5bridge uses to express a p5 reference

[19:28] <gaal> so try it?

[19:28] <gaal> bbl&

[19:28] <aufrank> no good

[19:29] <gaal> look for p5bridge tests...

[19:29] <aufrank> ok, thx

[19:29] <gaal> gotta moose

[19:29] <aufrank> moose ya later

[19:29] <[particle]> moose him now! moose him now!

[19:32] * aufrank mooses gaal

[19:35] <audreyt> talk starting in <30min... (and you're on the projector again)

[19:35] <aufrank> audreyt: did you just finish or are you about to go?

[19:35] <Limbic_Region> hello everyone from irc land

[19:35] <audreyt> about to go

[19:36] <aufrank> gluck!

[19:36] <audreyt> stats in 25mins

[19:36] <audreyt> *start

[19:37] <aufrank> TimToady: any chance you're using Getopt::Long in your $job code?  Any tips on getting it to play nice with v6-alpha?

[19:39] <audreyt> some day I'll try (was it jonasbn++?)'s IRC-to-slides stream generator

[19:39] <audreyt> but the day is not today...

[19:40] <aufrank> my $file = 'foo.txt'; my $fh = $foo.open('<'); # is this a p6 open?

[19:40] <audreyt> $foo.open is sufficient

[19:41] <audreyt> $foo.open(:r) is okay too

[19:42] <aufrank> I remember being told to always use 3-arg open when I was but a wee monk ;)

[19:42] <audreyt> that's because we don't do open("> foo.txt") anymore I think

[19:42] <audreyt> we in fact have no way for taintattacks that way atm

[19:42] <audreyt> which is probably Good

[19:42] <aufrank> indeed

[19:42] <audreyt> or at least Sane

[19:43] <aufrank> gaal showed me the new ruleSignature.  very moose.

[19:45] <audreyt> well the trick is make it actually Pugs.Bind-able...

[19:45] <leo> hi

[19:45] <audreyt> and implement mmd-draft.txt on it

[19:45] <aufrank> yeah, we talked about that too

[19:45] <audreyt> leo: greetings! (yes you're still on the projector)

[19:45] <aufrank> well, the first part

[19:45] <leo> is above ment as $file.open?

[19:45] <audreyt> yes

[19:46] <audreyt> Str does not have .open

[19:46] <audreyt> so it falls back into the lexical subroutine open

[19:46] <audreyt> via the normal meth-to-sub fallback dispatch

[19:46] <leo> ah - ok

[19:46] <audreyt> but if you class Str is also { method open { ... } }

[19:46] <audreyt> then that of course takes precedence.

[19:46] <leo> I had the slight fear that you want to force a Str.open

[19:47] <audreyt> nah. why would we want that? :)

[19:47] <leo> good

[19:47] <audreyt> leo: how's $job, btw? are you using any of the newtechs for that?

[19:47] <leo> nice job, newtech is Perl 5 ;)

[19:48] <audreyt> any chance of Moosification? ;)

[19:48] <leo> far on the horizon

[19:48] <Limbic_Region> audreyt - smoke is taking an inordinate amount of time

[19:48] <audreyt> Limbic_Region: does it lop on recurrence-grep or something?

[19:49] <Limbic_Region> saw that TimToady had similar issue but had chalked it up to cpu contention

[19:49] <audreyt> (it smokes normally here)

[19:49] <audreyt> hm. then maybe it's something deeper

[19:49] <Limbic_Region> will wait till after your talk to discuss it

[19:49] <Limbic_Region> been running for over an hour now

[19:49] <audreyt> okay, will do. maybe the new pointy if/then/else rollback wasn't done fully completely

[19:49] <audreyt> actually can you locally revert that change and see if it speeds up things?

[19:50] <audreyt> upstream r14489

[19:50] <Limbic_Region> just that change or revert to a rev prior to that change?

[19:50] <audreyt> r15381 (orig r14489):  audreyt | 2006-10-22 21:47:42 -0700

[19:50] <audreyt> * Restore support for:

[19:50] <audreyt> if EXPR -> $x {

[19:50] <audreyt> just that single one

[19:50] <audreyt> that changes CompUnit version too, so rm blib/lib/*yml while you are at it.

[19:50] <audreyt> I'll definitely recheck after talk

[19:50] <audreyt> (due in 10min now)

[19:51] <Limbic_Region> tell you what - will test in an hour when I get home

[19:51] <Limbic_Region> I want to let this smoke finish

[19:51] <Limbic_Region> it is in t/syntax now

[19:51] <audreyt> ok. sorry for not being able to respond promptly

[19:51] <audreyt> safe trip home

[19:52] <Limbic_Region> no worries - just noticed it and wanted to let you know

[19:52] <audreyt> 'k. I wonder if I run on this Macbook with SMP=2

[19:52] * Limbic_Region doesn't need it ATM for anything

[19:52] <audreyt> and the parallelization gain somehow offset the speed hit

[19:52] <audreyt> but we'll see.

[19:52] <Limbic_Region> well, that would be nice

[19:52] <Limbic_Region> because that means when the speed hit is fixed

[19:52] <Limbic_Region> the parallezation will be even faster

[19:52] <audreyt> then the world will be a better place, yes

[19:53] <Limbic_Region> ;-)

[19:53] <audreyt> (and if you have a 16core then pugs will be faster than perl5 ;))

[19:53] <aufrank> should something like this work?

[19:53] * Limbic_Region is stuck with a dual proc ATM

[19:53] <aufrank> for =$file -> ($first, $second, *@rest) { ... }

[19:53] <Limbic_Region> actually - work = 1CPU and home = 2CPU

[19:54] <audreyt> Limbic_Region: you need to set GHCRTS=-N2

[19:54] <aufrank> in any case, how would you pull just the first line off of a file using an =$iterator?

[19:54] <audreyt> to use those 2 CPUs

[19:54] <audreyt> aufrank: my $line = =$iterator

[19:54] <audreyt> given =$iterator { ... }

[19:54] <audreyt> item =$iterator

[19:54] <audreyt> etc, etc.

[19:54] <aufrank> thx

[19:55] <audreyt> np hth :)

[19:55] <Limbic_Region> audreyt - that's what I am going to try at home

[19:55] <aufrank> can pointy blocks take slurpy params?

[19:55] <audreyt> Limbic_Region: though  if you are already smoking with concurrent=2

[19:55] <audreyt> then those two CPUs are bound anyway

[19:55] <audreyt> and SMP will only gain you trivial amounts of time

[19:55] <audreyt> (or not at all)

[19:55] <audreyt> aufrank: pointy blocks take the full Signature syntax

[19:55] <aufrank> cool cool cool

[19:55] <audreyt> the only difference ie that it does not place a Routine boundary

[19:56] <aufrank> bbib

[19:56] <kolibrie> audreyt: good luck with talk!

[19:57] <TimToady> my second smoke last night was normal speed, it was apparently just my CPU clock, unless realclean fixed something.

[19:58] <audreyt> the conf org just tell me I can go 15min overtime

[19:58] <audreyt> good, that means more Q/A time

[19:58] <TimToady> quality assurance...

[19:58] <audreyt> Quantum/Acceleration...

[19:58] <[particle]> not in my company...

[19:59] <audreyt> [particle]: I thought you are already accelerated yourself...

[19:59] <[particle]> yes, when i'm alone :)

[19:59] <audreyt> ahh. Not Observed

[19:59] <audreyt> that's the key

[19:59] * Limbic_Region will test the realclean

[19:59] <TimToady> if we had real quantum entanglement we could do timely destruction...

[20:00] <audreyt> ...of the universe

[20:00] * [particle] spins 3/2

[20:00] <audreyt> there's some qubits library out there, is there not?

[20:00] <TimToady> break a fingernail...

[20:00] <audreyt> talk postponed for 5min to let post-lunch people trickle in...

[20:01] <[particle]> maybe you should have 5 mins of pre-talk q/a so it's not cut short

[20:02] <audreyt> hmm asking question about a talk that you have no idea what will it be about

[20:02] <audreyt> what a concept

[20:02] <Limbic_Region> 79.08 minutes - trying realclean here and will experiment further at home

[20:03] <audreyt> Limbic_Region: cool

[20:03] <audreyt> ok, seems there's sufficient population in the room now...

[20:03] <audreyt> switching y'all offscreen. wish me luck :)

[20:03] <TimToady> luck!

[20:03] <audreyt> bbiab &

[20:03] <Limbic_Region> gl

[20:04] * PerlJam wishes audreyt skill as she already has enough luck  :-)

[20:09] <wilx> And not enough skill? :D

[20:15] <PerlJam> audreyt has plenty of both.  I'm just trying to maintain balance.

[20:16] *** lollan_ joined
[20:16] *** lollan joined
[20:36] *** Odin- joined
[20:39] *** jferrero joined
[20:42] <gaal> is "attempt" perhaps a better name than "maybe" for stm choices?

[20:43] <gaal> also, "yield" would have been great for "defer" if it weren't for coros, but now, how to we call call-by-name now that defer is spoken for?

[20:44] <gaal> what were the old proposals? "later"?

[20:44] <[particle]> relent

[20:45] <[particle]> give in

[20:45] <[particle]> succumb

[20:45] <[particle]> none are particularly catchy ;)

[20:46] <gaal> relent is nice

[20:47] <[particle]> remit

[20:49] <[particle]> i don't like "maybe". it's an adverb

[20:50] <[particle]> attempt or promise are better

[20:52] <gaal> remit would be hopelessly confusing in the standard bank account example :)

[20:52] *** dduncan joined
[20:53] <gaal> (in British English it's common to use it where in American you'd say "refund")

[20:53] *** thepler joined
[21:01] <kolibrie> remit does seem very tied to currency

[21:01] <kolibrie> relent might be okay

[21:03] <gaal> flirt {...}

[21:03] <cjeris> acquiesce?

[21:03] <gaal> (for maybe)

[21:03] <gaal> acquiesce is good. but long and easy to mistype :)

[21:04] *** Limbic_Region joined
[21:06] <clkao> seen audreyt

[21:06] <jabbot> clkao: audreyt was seen 1 hours 2 minutes 55 seconds ago

[21:08] *** fglock left
[21:11] <Limbic_Region> clkao - she's in the middle of giving a presentation

[21:12] *** foo\ joined
[21:12] <clkao> Limbic_Region: is it delayed?

[21:15] <Limbic_Region> dunno - I left work about 40 minutes ago

[21:22] <aufrank> clkao: she started ~5 minutes late so that the lunch crowd could return

[21:22] <clkao> ok, thanks

[21:41] <Limbic_Region> @tell audreyt same machine went from 79 min smoke to 59 min smoke just by doing realclean (same pugs rev)

[21:41] <lambdabot> Consider it noted.

[21:42] <audreyt> clkao: pong

[21:42] <lambdabot> audreyt: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:43] <aufrank> audreyt: done?

[21:43] <aufrank> how'd it go?

[21:43] <audreyt> aufrank: yes. fabulously successful

[21:44] <Limbic_Region> audreyt - at home now, running a baseline smoke now but more than happy to try anything if you suspect there to be a problem

[21:44] <audreyt> chatted with felleisen, wadler, siek (the gradual typing guy), & more

[21:46] <aufrank> I'm trying to think of how to use a hyper to execute audreyt++ on the lazy list [1..*]

[21:46] <aufrank> audreyt: good questions after from the audience?

[21:46] <audreyt> oh, very good ones.

[21:46] *** c6rbon_ joined
[21:47] <aufrank> full debrief to come on the blog?

[21:47] <audreyt> how our runtime distinguish STM from IO actions (by runlevels)

[21:47] <clkao> audreyt: pong

[21:47] <audreyt> how our typesystem infer in the face of unannotated subtyping (we don't at all - we're annotation driven)

[21:47] <clkao> audreyt: wher eare you ? in the convention centre?

[21:47] <clkao> audreyt: we are in lobby and wonder if we should go pick you up ?

[21:47] <audreyt> how our module system avoid augmented metaclass from leaking to other modules (long names and separate compilation)

[21:48] <audreyt> how our macros can affect compile site in face of hygenic renaming (the :COMPILING flag)

[21:49] <audreyt> how can we avoid unfortunate side effects in face of lazy evaluation (we only do lazy constructors with list producers and lazy{} annotations, not generic lazy functions)

[21:49] <clkao> audreyt: balas has checked out the hotel and we can go pick you up

[21:49] <audreyt> sure, pick me up at the conv center

[21:49] <audreyt> the Max station

[21:49] <audreyt> I'll walk to it

[21:49] <audreyt> eta 3min

[21:50] <clkao> ok

[21:50] <aufrank> audreyt: gratz on the good talk.  excited to hear what comes of hallway sessions and listening to other talks!

[21:51] <audreyt> no, Best Practical whisks away yours truly in 3 mins

[21:51] <audreyt> I don't get to attend OOPSLA at all :/

[21:51] <aufrank> hrm

[21:51] <audreyt> so, bbl tonight when we arive at hotspring site for Hackathon

[21:51] <clkao> audreyt: we will be there in 5 min

[21:51] <aufrank> well, excited to hear about mad hacking with clkao++ and obra++

[21:51] <audreyt> *wave* &

[21:52] <audreyt> and Schwern++

[21:52] <aufrank> neat :)

[21:58] <aufrank> What is the way to declare the variables that used to be declared with env?  Merlyn asked that it be changed, but I can't remember what the final decision was.

[21:59] *** justatheory joined
[22:09] <aufrank> heading home, bye all

[22:22] *** mauke joined
[22:25] *** Aankhen`` joined
[22:29] *** nicodaemos joined
[22:31] *** seano joined
[22:35] *** KingDiamond joined
[22:36] *** weinig is now known as weinig|food

[22:38] *** iblechbot joined
[22:46] *** amv joined
[23:02] *** cjeris left
[23:03] *** norageek joined
[23:09] *** mauke joined
[23:20] *** c6rbon joined
[23:38] *** justatheory joined
