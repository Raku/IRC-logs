[00:16] *** prism joined
[00:49] *** Aankhen`` joined
[00:58] *** ofer0 joined
[01:03] *** frederico joined
[02:08] <buu> TimToady: Hrm, you around?

[02:08] <buu> Actually I guess I can punt it to p5p maybe

[02:14] *** Aankh|Clone joined
[02:22] *** weinig is now known as weinig|zZz

[02:31] *** Aankh|Clone is now known as Aankhen``

[03:17] *** fglock joined
[03:20] *** jdv79 left
[03:26] <fglock> anyone else is having problems logging into openfoundry svn?

[03:30] <TimToady> I just did an svn up and it worked (though there wasn't anything to get).

[03:31] <TimToady> but that's probably anonymous

[03:32] *** justatheory joined
[03:33] *** xinming joined
[03:35] <fglock> yes, svn up works, but I can't commit

[03:35] <fglock> maybe it's because I'm trying to commit the Python parser :)

[03:57] *** lambdabot joined
[04:32] *** awwaiid joined
[05:15] *** BooK_ joined
[05:29] *** mdiep_ joined
[05:31] *** cerculetz joined
[05:39] *** jeffz joined
[05:42] *** awwaiid joined
[05:43] *** jeffz left
[05:51] *** Aankh|Clone joined
[05:57] <TimToady> yeah, I can't commit either...

[05:57] <audreyt> same here

[05:58] <audreyt> expect it to be fixed tomorrow morning

[05:58] <audreyt> which is 20 hours from now

[05:58] <audreyt> I fixed test parsefails

[05:58] <TimToady> wait, it is tomorrow morning where you are...

[05:58] <audreyt> down to ~400 fails now

[05:58] <TreyHarris> would you like a commit bit?  i hear audreyt can give you one...

[05:58] <TimToady> what's the symbol for rolling one's eyes?

[05:58] <TimToady> audreyt++

[06:00] <audreyt> TimToady: U+2681

[06:00] *** Aankhen`` joined
[06:00] <TimToady> I've done something to S29 that's likely to be controversial...

[06:00] <TimToady> ⚁       2681            DIE FACE-2

[06:00] <audreyt> ... "you rolled a 2"

[06:01] <TimToady> which is to turn reverse the args on split, and take away the default.

[06:01] <TimToady> $string.split($delim)

[06:01] <TimToady> split($string: $delim)

[06:01] <TimToady> but never split($delim, $string)

[06:01] <audreyt> that's already the case...

[06:01] <audreyt> oh

[06:01] <audreyt> you simply exported the split?

[06:01] <TimToady> yeah.

[06:02] <audreyt> it might be unpopular, seeing how @x.map(&x) but map(&x, @x).

[06:02] <TimToady> I think it's more consistent, and we can warn if $string looks like $delim

[06:02] <TimToady> anyway, I think split is getting de-emphasized in any event

[06:02] <TreyHarris> well, multis can make both map(&x: @x) and map(@x: &x) work, no?

[06:03] <TreyHarris> but split, both args are strings...

[06:03] <TimToady> yes, but split($x,$y)

[06:03] <audreyt> unless we say one end always must be regex...

[06:03] <TimToady> (for the function form)

[06:03] <TreyHarris> well, split($re: $str) could be multi then, but that might be too confusing

[06:04] <TimToady> on the one hand we'll mostly see .split(/pat/)

[06:04] <TimToady> there is no default pattern anymore for split.

[06:04] <TimToady> because splitting into words is now done with the corresponding function that

[06:05] <TimToady> specifies what you *want* to match, not what is in the crevices.

[06:05] <TimToady> that function used to be named .words

[06:05] <audreyt> perhaps split(Regex, Str) is the only form and split(Str, Str) is deliberately an error

[06:05] <TimToady> but at the moment it is named .comb

[06:05] <audreyt> that tells people to use Str.split(*)

[06:05] <TimToady> that's what I was saying

[06:05] <audreyt> .comb for "combining"?

[06:06] <TimToady> no, for "comb through looking for the good bits"

[06:06] <TimToady> or to arrange in a comb structure.

[06:06] <TimToady> I've been spending most of the day in the thesaurus trying to find the right word

[06:06] <audreyt> .comb suggests combining to me, nevertheless...

[06:07] <TimToady> except you're doing the opposite of interpolation, whatever that is.

[06:07] <TimToady> .extract is the closest English word for that concept, but it's too long.

[06:07] <TimToady> and doesn't imply plurality like comb.

[06:08] <TimToady> etymologically, comb has not much to do with combine, unless maybe you go back to IndoEuropean...

[06:08] <TimToady> but there's honeycomb as well.

[06:09] <TimToady> basically in IE it was a repeating structure, I think.  Need to look it up in my AmHer

[06:10] <TimToady> combers as in ocean waves is also the repeating pattern idea.

[06:10] <audreyt> *nod*

[06:10] <audreyt> so split(rx/x/, "xxx") still works?

[06:11] <TimToady> no

[06:11] <audreyt> ok...

[06:11] <TimToady> it's "xxx".split(/x/) or split("xxx", /x/) with the direct object of the verb in the correct place.

[06:12] <audreyt> but &map stays as-is?

[06:12] <TimToady> yes

[06:13] <TimToady> we could not export split, and then it'd require split("xxx": /x/)

[06:13] <TimToady> that might be more acceptable, really

[06:13] <audreyt> I'd find that survivable.

[06:13] <audreyt> yes.

[06:13] <TimToady> as I say, split is really inside out from what you usually want anyway.

[06:13] <audreyt> nod.

[06:13] <TimToady> unless you're processing the passwd file

[06:14] <TimToady> even CSV can more easily be expressed with comb than split, I think.

[06:14] <TimToady> once you start handling quotes

[06:15] *** Aankh|Clone joined
[06:15] <TimToady> .comb(/pat/,$n) is really short for .match(rx:c:global:x(0..$n)/pat/)

[06:15] <TimToady> though the :c is implied by the :g

[06:16] <TimToady> might go as far as to make :c short for :comb in regex

[06:16] <TimToady> :continue is not terribly accurate

[06:16] <TimToady> or precise, or something

[06:17] <TimToady> hmm, except .comb implies :global, and :c doesn't

[06:19] <TimToady> .comb(/./) is a really easy way to split to chars.

[06:21] <TimToady> should be able to comb anything that can convert to Str, like arrays and filehandles.

[06:21] <TimToady> +$*IN.comb is word count on stdin

[06:29] *** cerculetz left
[06:33] <wolverian> TimToady, why doesn't the /foo/ in .split(/foo/) not mean $_~~/foo/?

[06:33] <wolverian> er, one negation less :)

[06:35] <wolverian> (possibly a silly question.)

[06:36] <TimToady> because /foo/ is rx/foo/ unless you put it into a context that forces evaluation.

[06:37] <TimToady> m/foo/ forces immediate evaluation, but so does putting into string or numeric context.

[06:38] <TimToady> (or boolean)

[06:38] <TimToady> at that point it fastens onto $_ if nobody's given it any better idea.

[06:39] <TimToady> making split not be a macro was one of the reasons for formulating it that way.

[06:40] <TimToady> In P5 the parser essentially has to rewrite the first argument.

[06:41] <TimToady> when you write split(/^/) that gets turned into split(/^/mg) by the time the runtime gets it.

[06:42] <TimToady> actually, it's worse than that because of having to undo the implicit $_ =~

[06:42] <TimToady> so we just clean all that up in P6

[06:44] <audreyt> *nod*

[06:49] <TimToady> ت

[06:49] <audreyt> as in, backlogged and agreed with the reasoning.

[06:50] <TimToady> well, it's all straight out of A5...

[06:52] <wolverian> it's been a few years since I read that... :)

[06:52] <wolverian> thanks!

[07:00] *** pdcawley joined
[07:01] <pdcawley> seen obra?

[07:01] <jabbot> pdcawley: obra was seen 4 hours 49 minutes 34 seconds ago

[07:01] *** awwaiid joined
[07:03] *** pdcawley joined
[07:10] <TimToady> ഃ☽

[07:11] <pdcawley> Is there any documentation (apart from the source) on using madskills?

[07:12] * pdcawley is trying to work out how to implement the rest of a refactoring engine...

[07:14] <audreyt> TimToady: I wonder if f([,] \(1,2,3), \(4,5,6)); should simply become f(1,2,3,4,5,6) without the need of =

[07:14] <audreyt> if it should not, then the example

[07:14] <audreyt> @args = \@foo, 1, 2, 3

[07:14] <lambdabot> Avast!

[07:14] <audreyt> as currently in S03 can't be made to work...

[07:15] <audreyt> @args = (scalar @foo, 1, 2, 3) # maybe change it to that, then

[07:15] <lambdabot> Aye

[07:22] <TimToady> pdcawley: not that I know of, though Nick might have made some notes while installing it in 5.9

[07:23] <TimToady> audreyt:  I wonder if we should scrap [,] and go with |<<

[07:23] <pdcawley> So, no B::MadProps yet?

[07:23] <audreyt> that will make me happy as currently prefix:= is made both special-macro _and_ regular function app

[07:23] <pdcawley> Or do the various B modules get the madprops stuff for free?

[07:23] <TimToady> madprops was specifically avoiding anything to do with B

[07:23] <audreyt> to satisfy the [,] =$x

[07:23] <audreyt> requirement

[07:23] <audreyt> (anything less won't work)

[07:24] <audreyt> and if we can demagicaklize =, that's certaily a win

[07:24] <TimToady> I started trying to hack B to return madprops and gave up.

[07:24] <pdcawley> Ah.

[07:24] <TimToady> madprops are just dumped out as an XML file at the moment via dump.c

[07:25] <audreyt> though |<< also needs to be magickal, but we can explain the magick much easier

[07:26] <pdcawley> So I get at madprops by doing '...; dump' ?

[07:26] <TimToady> then the nomad script runs over that and moves stuff around in the tree to slightly less insane locations.

[07:27] <pdcawley> Ah... found the mad subdirectory :)

[07:27] <TimToady> setenv PERL_MADSKILLS=1 if I recall

[07:28] <pdcawley> Yup. Configure asks me about that now.

[07:29] <pdcawley> Ah, but not about the environment.

[07:30] <TimToady> then [,] degenerates to the listop form of [...], fwiw

[07:30] <TimToady> and can go back to returning a scalar.

[07:31] <audreyt> yes.

[07:31] <TimToady> demagic on = is good too.

[07:31] <audreyt> malaire can be happy then

[07:31] <audreyt> he was quite confused why [,] doesn't seem at all reductive :)

[07:32] <TimToady> it was redactive. :)

[07:32] <audreyt> redactive? :)

[07:33] <TimToady> a redactor is someone who edits historical texts because they think they know better.

[07:33] <audreyt> lol

[07:33] <TimToady> ഃ☽

[07:36] <audreyt> my $x = \( 1; 2 );

[07:36] <audreyt> f(0, |$x, 3);

[07:36] <audreyt> should this expand naively?

[07:36] <audreyt> f(0, 1; 2, 3)

[07:37] <TimToady> we try to be smart about named...

[07:37] <TimToady> or maybe our approach to that is also naive...

[07:38] <audreyt> perhaps always-naive make sense

[07:38] <TimToady> it could also mean f(0,1,3 <== 2)

[07:38] <audreyt> yes, that's another possibility

[07:39] <TimToady> but then what is f(0, |$x, |$x)

[07:39] <audreyt> 0,1,1 ; 2,2

[07:39] <audreyt> presumably

[07:39] <TimToady> or 0,1,1; 2; 2

[07:39] <audreyt> yeah.

[08:02] <TimToady> ತ⋎ತ

[08:04] <audreyt> capture merging implemented...

[08:04] <audreyt> using the naive approach for now

[08:04] <audreyt> g'nite :)

[08:32] *** prefiks joined
[08:37] *** marmic joined
[09:06] *** bernhard joined
[09:09] *** iblechbot joined
[09:15] <nothingmuch> audreyt: you up?

[09:15] <nothingmuch> 3/w 21

[09:15] <nothingmuch> beh

[09:25] * ayrnieu tries to fit "3/w 21" into a/s/l

[09:29] <audreyt> nothingmuch: hihi

[09:30] <nothingmuch> hi ho

[09:30] <nothingmuch> /w 21 is /window 21

[09:30] <nothingmuch> and 3 is a typo

[09:30] <audreyt> ok :)

[09:30] <audreyt> readine MO::Overview

[09:32] <nothingmuch> okies

[09:37] <audreyt> how's your schedule?

[09:37] <audreyt> I relenged quite a bit so far today

[09:37] <audreyt> will go to dinner in 20 minutes and back in maybe 2hr

[09:38] <audreyt> then hack for another 4hr and then sleep, and then hack for another 16hr :)

[09:40] *** mozzz joined
[09:41] <nothingmuch> audreyt: i can't hack much today

[09:41] <nothingmuch> i accidently made friday my weekend

[09:41] <nothingmuch> so i need to work today

[09:41] <nothingmuch> and tomorrow

[09:41] <nothingmuch> but the rest of thhe week i should have time

[09:41] <audreyt> oh ok

[09:42] <audreyt> so it seems Tuesday is best for MI hacking

[09:42] <audreyt> I'll focus on grokking your tests and releng tomorrow then

[09:42] <audreyt> and bounce you questions here

[09:44] <nothingmuch> sure thing

[09:44] <nothingmuch> i'm going to keep working on it, low pri

[09:44] <nothingmuch> i want to finish the ag parent finding protocol

[09:44] <nothingmuch> with a private method

[09:57] *** rodi joined
[10:16] *** buetow joined
[10:48] <bernhard> ?eval  -"-aaa"'

[10:48] <evalbot_r13586> Error:  Unexpected "'" expecting term postfix, comment, operator, statement modifier, ";" or end of input

[10:48] <bernhard> ?eval  -"-aaa"

[10:48] <evalbot_r13586> -0.0

[10:49] <Juerd> - is strictly numeric in the current implementation. I don't know if this is spec or wrong.

[10:49] <Juerd> ?eval -"foo"

[10:49] <evalbot_r13586> -0.0

[10:49] <Juerd> For all I care, it stays numeric. I've never used -string except for the bareword case, but APIs that require that suck anyway, especially considering :pairs.

[10:51] <bernhard> ?eval  +"-aaa"

[10:51] <evalbot_r13586> 0.0

[10:54] <Juerd> ?eval -"0xff"

[10:54] <evalbot_r13586> -255.0

[10:54] <Juerd> Perfect.

[11:02] *** chris2 joined
[11:09] *** penk joined
[11:11] *** renormalist joined
[11:18] *** kane-xs joined
[11:51] *** foo\ joined
[11:53] *** revdiabl1 joined
[11:54] *** rindolf joined
[11:54] <rindolf> Shanah Tovah Lambdacamels!

[11:56] <nothingmuch> audreyt: any comments on the overview? missing bits i could clarify, etc?

[11:57] <rindolf> Hi nothingmuch

[11:57] <rindolf> ingy: here?

[11:58] <nothingmuch> hi rindolf

[11:58] <nothingmuch> he's probably sleeping

[11:58] *** knewt joined
[11:58] <nothingmuch> it's around 5-5 am there

[11:58] <nothingmuch> 4-5

[12:00] <rindolf> nothingmuch: I see.

[12:00] <rindolf> nothingmuch: where does ingy live?

[12:00] <miyagawa_> rindolf: I guess he's in seattle

[12:01] <rindolf> miyagawa_: I see.

[12:01] *** integral_ joined
[12:01] *** integral_ is now known as integral

[12:03] *** pdcawley joined
[12:03] <rindolf> miyagawa_: weren't you the first CPAN Author to have over 100 CPAN distros?

[12:04] <miyagawa_> not sure I'm the first one. There're Simon, Audrey and AdamK. But yeah i have 100+ distros now :)

[12:04] <rindolf> miyagawa_: nice.

[12:04] <ofer0> hey rindolf, how are you doing?

[12:04] <rindolf> Hi ofer0

[12:04] <rindolf> ofer0: I'm fine.

[12:04] <rindolf> ofer0: Shanah Tovah!

[12:04] *** nnunley_ joined
[12:04] <ofer0> Shana Tova!

[12:05] <rindolf> ofer0: I have posted new entry in my homesite's blog.

[12:05] <ofer0> Can you please link me?

[12:05] <rindolf> ofer0: sure.

[12:05] <rindolf> ofer0: http://community.livejournal.com/shlomif_hsite/3573.html

[12:05] <lambdabot> Title: shlomif_hsite: New Additions to the Site, http://tinyurl.com/gvqxe

[12:05] <ofer0> rindolf, Thanks!

[12:06] <rindolf> http://www.shlomifish.org/open-source/nostalgia/ - some of my old C++ code.

[12:06] <lambdabot> Title: Shlomi Fish' Ancient Code, http://tinyurl.com/j5o7x

[12:06] <rindolf> ofer0: do you have an RSS reader?

[12:06] <ofer0> Yes

[12:27] *** elmex joined
[12:27] *** ofer0 joined
[12:45] *** xdg joined
[12:52] <rindolf> ofer0: then you can subscribe to it.

[12:53] <rindolf> ofer0: or you can subscribe to http://www.shlomifish.org/me/blogs/agg/shlomif-blogs-aggregate.xml which is my aggregated feed.

[12:53] <lambdabot> http://tinyurl.com/mxbft

[13:00] <audreyt> @tell TimToady Maybe sub (\$x) {...} is now sub (*|x) {...} for consistency?

[13:00] <lambdabot> Consider it noted.

[13:00] <clkao> capture syntax changed?

[13:00] <audreyt> @tell TimToady That will also play well with |<< replacing [,], effectively making \ thec constructor and | the destructor

[13:00] <lambdabot> Consider it noted.

[13:01] <audreyt> clkao: TimToady just added a new sigil to perl6... we're dealing with its consequences

[13:01] <clkao> aaaaah

[13:01] <pdcawley> What's the new sigil?

[13:01] <audreyt> |

[13:01] <pdcawley> Used for?

[13:02] <audreyt> for captures

[13:02] * pdcawley has been away from Perl 6 for too long... 'captures'?

[13:02] *** markstos joined
[13:02] <rindolf> Hi clkao

[13:02] <obra> pdcawley: pong

[13:03] <pdcawley> Hi obra: I'm busy hacking away on the refactoring hack.

[13:03] * nothingmuch wonders if we have / and - for captures

[13:03] <nothingmuch> so that we can have the spinner op

[13:04] <pdcawley> Making it a little less hacky I hope (turns out we can do it without having to write anything out to a file by parsing $@ from an eval "$code; 1"

[13:04] <audreyt> pdcawley: http://perlcabal.org/~audreyt/Capture.html

[13:04] <obra> cool

[13:04] <nothingmuch> 404

[13:04] <audreyt> refresh

[13:04] <nothingmuch> still 404

[13:05] <audreyt> can't be

[13:05] <nothingmuch> now it works

[13:05] <pdcawley> obra: I think we can use a similar trick for 'rename variable'

[13:05] <pdcawley> Find the declaration of the variable. Change it.

[13:05] <pdcawley> then keep evalling the code parsing the error and changing the entry at the given line until it compiles again.

[13:05] <nothingmuch> captures are one of the prettier refactorings Perl 6 has gone through

[13:05] <nothingmuch> it's gaal's fault, right?

[13:06] <audreyt> I think it's my fault :) but @Larry came up with that name

[13:06] <nothingmuch> ah

[13:06] <nothingmuch> audreyt++

[13:06] <nothingmuch> @Larry++

[13:06] <lambdabot> Unknown command, try @list

[13:06] <nothingmuch> gaal++ # for good measure ;-)

[13:06] <pdcawley> audreyt: Is this somewhat akin to smalltalk's reification of a message?

[13:06] <nothingmuch> pdcawley: no that's my hobby ;-)

[13:06] <pdcawley> But allowing for custom parsing of an argument list?

[13:06] <audreyt> pdcawley: it's reifying whatever that can occur in a call

[13:07] <audreyt> it's a call without the message :)

[13:07] <audreyt> er, the method/sub name.

[13:07] <pdcawley> With deferred evaluation in the caller's context?

[13:07] <audreyt> no, it's pre-evaluated

[13:07] <audreyt> the caller may flatten it differently.

[13:08] <audreyt> but it's ultimately a XML-node-like structure

[13:08] <nothingmuch> think of it as a superbind

[13:08] <audreyt> with one tag, some positionals, some nameds

[13:08] <nothingmuch> when you're binding the values on the right side into a $something

[13:08] <obra> pdcawley: I'd worry a bit about the code transforms needed for rename variable

[13:08] <nothingmuch> and you don't know what that something is yet

[13:08] <nothingmuch> a capture is a generalization of all the $somethings

[13:08] <pdcawley> obra: I'll worry about it as I write the tests:

[13:08] <obra> :)

[13:12] <pdcawley> Can Perl 6's eval take an environment argument as well?

[13:12] <pdcawley> "So, I have this code block, but I want to evaluate it in *this* context"

[13:12] <pdcawley> Ruby has some neat tricks you can do with eval. Ferinstance, you can do 'some_object.instance_eval(&block)' and the block gets evaluated as if it were a an instance method, ie, self is bound to 'some_object'.

[13:12] <pdcawley> remarkably handy for DSLy type tricks.

[13:14] <Juerd> Perl 6's eval evals strings, not coderefs.

[13:14] <audreyt> it doesn't seem to me like the same thing as eval taking an environment argument.

[13:14] <audreyt> .instance_eval is easier than reifying the execution context

[13:14] <Juerd> I expect that you can supply methods in variables in .

[13:14] <Juerd> $foo.$method(...)

[13:14] <audreyt> sure, that's already available at this moment

[13:15] <Juerd> Uhhuh

[13:15] <Juerd> It's in Perl 5, so there must be something like it in Perl 6 :)

[13:15] <audreyt> ?eval my $meth = 'sqrt'; 4.$meth()

[13:15] <evalbot_r13586> 2.0

[13:15] <Juerd> ?eval my $meth = method { sqrt $^a }; 3.$meth()

[13:15] <evalbot_r13586> Error: No compatible subroutine found: "&method"

[13:15] <nothingmuch> what's the prospect for signature inference by means of capture flatenning?

[13:16] <Juerd> Oh, too bad :)

[13:16] <nothingmuch> simple cases will be inferrable, right?

[13:16] <audreyt> signature inference?

[13:16] <nothingmuch> like sub foo (\$args ) { bar(|$foo, :extra("bar") }

[13:16] <nothingmuch> infers that foo's signature is bar's signature minus the named param 'extra'

[13:17] <audreyt> probably. I wonder if TimToady will agree with my latest refactoring idea

[13:17] <nothingmuch> which was?

[13:17] <audreyt> sub foo (*|args) { bar(|args, :extra<bar>) }

[13:17] <audreyt> I think it's significantly cleaner

[13:17] <nothingmuch> syntactically?

[13:17] <audreyt> yeah

[13:17] <nothingmuch> ah

[13:17] <nothingmuch> yes, it looks prettier ;-)

[13:17] <nothingmuch> but it's not semantically different, right?

[13:18] <nothingmuch> and sub foo ( |args ) is simply a sub which takes one capture as it's argument, right?

[13:18] <nothingmuch> which must be called as foo( \( $bar ) ) etc?

[13:18] <audreyt> yup

[13:18] <nothingmuch> ok

[13:19] * nothingmuch crawls back into his hole

[13:26] *** prism joined
[13:26] *** crem_ joined
[13:32] *** pdcawley joined
[13:34] *** shachaf_ joined
[13:41] *** jferrero joined
[13:44] *** qmole joined
[13:45] *** frederico joined
[13:59] *** weinig|zZz is now known as weinig

[14:10] <audreyt> @tell TimToady I wonder if scalar(1) makes a mutable scalar and item(1) makes simply 1...

[14:10] <lambdabot> Consider it noted.

[14:10] <nothingmuch> audreyt: ann can't commit the summaries for some reason

[14:10] <nothingmuch> it keeps asking her for her password

[14:10] <nothingmuch> it's likely an svk problem

[14:11] <nothingmuch> but i thought you might know something

[14:11] <audreyt> nothingmuch: openfoundry.org is down until 12 hours in the future

[14:11] <nothingmuch> ah, good to know

[14:12] <nothingmuch> oops, i told her too late, she already mailed you

[14:13] *** prism joined
[14:16] *** foo\ joined
[14:35] <Juerd> audreyt: I thought scalar was gone.

[14:42] *** weinig is now known as weinig|bbl

[14:56] <TimToady> ot

[14:56] <lambdabot> TimToady: You have 3 new messages. '/msg lambdabot @messages' to read them.

[14:56] <TimToady> it's probably Scalar vs item

[14:57] <TimToady> Scalar : item :: Array : list

[14:59] <xerox> Oh, how is '::' called in this context?

[14:59] <integral> : = "is to", :: = "as".  "Scalar is to item as Array is to list"

[15:00] <xerox> I knew there was a variation on a/b = c/d from long time, but I couldn't find it anywhere.  OK cool.

[15:02] <TimToady> audreyt: actually I was thinking about |$tell where | is like * but means "slurp everything but don't slurp anything" in a lookaheadish way.  But maybe that's just (|foo) $self:... or something

[15:03] <TimToady> but gotta run &

[15:05] <clkao> btw, svk 2.0tp1 is now on cpan. i am writing the release notes ;)

[15:11] <xdg> clkao: ++

[15:19] <nothingmuch> audreyt: any input on the overview thingy?

[15:20] <nothingmuch> clkao: when do we get darcs style cherry picking? ;-)

[15:21] <clkao> nothingmuch: christmas

[15:21] <clkao> probably next ;)

[15:21] <nothingmuch> not for my birthday? *sniff* *sob*

[15:21] <nothingmuch> actually, for my birthday you could make me buy an ice a\xe

[15:21] <nothingmuch> axe

[15:21] <nothingmuch> that'd be a nicer present =)

[15:27] <clkao> heh

[15:28] <gaal> nothingmuch: gotta clean that fridge more often...

[15:28] <lambdabot> gaal: You have 1 new message. '/msg lambdabot @messages' to read it.

[15:29] <gaal> lambdabot: @messages

[15:29] <lambdabot> lanny said 18h 24m 25s ago: On porting DIEHARD. Um... no. :)

[15:29] <gaal> heh.

[15:35] <rindolf> Hi gaal

[15:35] <rindolf> gaal, nothingmuch: where did you spend Rosh Hashanah's eve?

[15:35] <nothingmuch> nothingmuch: i meanrt that clkao should invite to hike in .tw

[15:35] <nothingmuch> rindolf: at home

[15:36] <rindolf> nothingmuch: with your ext. family?

[15:36] <nothingmuch> nope

[15:36] <nothingmuch> our ceremonial activities ended at apples and pomgrendates

[15:36] <rindolf> nothingmuch: I see.

[15:36] <nothingmuch> grenades

[15:36] <nothingmuch> beh

[15:36] <nothingmuch> spelling is hard, let's go shopping

[15:37] <nothingmuch> .q 1`

[15:37] <nothingmuch> bah

[15:37] <nothingmuch> keyboard transposed

[15:41] <obra>   

[15:41] *** agentzh joined
[15:42] <clkao> obra: hi

[15:43] * nothingmuch desperately wants *someone* to bash MO::Overview

[15:43] <nothingmuch> there must be *something* wrong

[15:43] * nothingmuch makes a puppy face to all present

[15:43] <lumi> Um, it.. sucks.. for some reason I'm unwilling to divulge?

[15:43] <obra> clkao: got throug hsecurity by 3:40

[15:44] <nothingmuch> thanks lumi, that really helped =)

[15:44] <gaal> url?

[15:44] <nothingmuch> http://nothingmuch.woobling.org/MO/lib/MO/Overview.pod

[15:44] <lambdabot> http://tinyurl.com/law9f

[15:45] <clkao> obra: not too bad eh

[15:45] <obra> would be better if there were powerpoints that let me sit somewhere at a table

[15:45] <clkao> lounge?

[15:45] *** larsen joined
[15:46] <rindolf> Hmmm... one of the perl-5.9.4 tests ( s../ext/POSIX/t/sysconf.t ) segfaults on my machine.

[15:46] <rindolf> Let me try bleadperl.

[15:46] <obra> clkao: no lounge tillsize gets here. lest I strand her.

[16:00] <nothingmuch> .oO( 10 passengers * 4oz of gellatenous explosives is enough to depressurize a plane and kill everyone if placed on the plexiglass windows, right?

[16:00] <nothingmuch> )

[16:00] <nothingmuch> http://www.tsa.gov/travelers/airtravel/prohibited/permitted-prohibited-items.shtm#1

[16:00] <lambdabot> Title: TSA: Permitted and Prohibited Items, http://tinyurl.com/mydvw

[16:01] *** prism joined
[16:03] *** soisoisoi joined
[16:07] *** mauke_ joined
[16:09] *** prism joined
[16:22] *** mauke_ is now known as mauke

[16:23] *** Psyche^ joined
[16:39] *** Psyche^ is now known as Patterner

[16:48] *** Xenobius joined
[16:51] *** Xenobius left
[17:09] *** fglock joined
[17:11] *** ajs_ joined
[17:15] *** rodi joined
[17:22] <audreyt> nothingmuch: sorry, was busy triaging and havn't looked at MO yet

[17:22] <audreyt> have to sleep now though

[17:23] <audreyt> triaged 84 test files; all parsefails fixed; up to 11448 ok compared to 10349 today morning

[17:23] *** mako132_ joined
[17:23] <audreyt> implemented quite a few things as well (===, try{...} catches IO errors too, 0_123, capture splicing)

[17:24] <wolverian> audreyt++

[17:25] <audreyt> another 120 tests to go...

[17:25] <audreyt> hopefully can be finished by tomorrow

[17:25] <audreyt> but sleep first. :) *wave* &

[17:26] <audreyt> Juerd: btw, now t/ is spec-based, I'll simply rm t/Dialects if you're okay with it...

[17:26] *** penk joined
[17:26] <TimToady> night!

[17:29] *** mdiep joined
[17:31] *** justatheory joined
[17:32] *** gunya joined
[17:33] <agentzh> audreyt++ audreyt++

[17:35] <nothingmuch> audreyt: fairynuff

[17:36] <prism> sorry all for the join/part of ^daemon daemon^ I seem to be logged on from more than one machine

[17:46] *** agentzh left
[17:49] <rindolf> Hi TimToady

[18:10] *** Aankhen`` joined
[18:19] *** mozzz left
[18:33] *** nperez joined
[18:35] *** Aankh|Clone joined
[18:35] *** araujo joined
[18:42] *** putter joined
[18:43] *** SCalimlim joined
[18:43] <putter> re "Capture", I realize we are all getting used to it, but I suggest it is still an unfortunate name.

[18:43] <lambdabot> putter: You have 1 new message. '/msg lambdabot @messages' to read it.

[18:44] <putter> 1- "capture" already has a meaning in cs, and this isn't it

[18:46] *** revdiabl1 is now known as revdiablo

[18:47] *** revdiablo joined
[18:47] <putter> 2- the english meaning doesnt quite line up - the noun form of "capture" refers to the act of capturing itself, rather than the loot.  and has assorted implications (violent removal) which are inapplicable.

[18:47] <putter> 3- at least some people have cognitive dissonance between "capture" and "closure".

[18:47] <putter> So I suggest we stay in a mode of "we are calling it 'Capture', but looking for a better name.  any ideas?".

[18:49] *** mako132_ joined
[18:50] <putter> I might suggest "Actuals", for actual arguments, but it already has a different meaning in finance, and plural names sacrifice the ability to easily refer to pluralities.

[18:51] <putter> :(

[18:51] <putter> Hopefully someone will have a brainstorm at some point?

[18:52] <SCalimlim> I don't like "capture" much either, but I don't like "actuals" either

[18:53] <SCalimlim> er, one too many "either"s in there

[18:56] *** weinig|bbl is now known as weinig

[18:57] *** Odin-LAP joined
[18:58] <putter> nothingmuch: comments coming

[19:00] *** Aankh|Clone is now known as Aankhen``

[19:18] *** Limbic_Region joined
[19:20] *** elmex joined
[19:21] <Juerd> audreyt: I'm okay with that

[19:21] <Juerd> audreyt: I won't have any time to deal with it anyway :(

[19:23] *** prism joined
[19:30] <nothingmuch> putter: awesome

[19:30] *** zakharyas joined
[19:30] *** Alchemy joined
[19:31] *** prism joined
[19:33] <gaal> Booty?

[19:36] <pasteling> "putter" at 66.30.119.55 pasted "some comments on MO Overview" (64 lines, 2.5K) at http://sial.org/pbot/19937

[19:37] *** elmex joined
[19:38] * putter goes to search the Snn to figure out what attribute grammars are...

[19:40] <putter> no joy.

[19:40] <putter> "attribute grammars", anyone?

[19:41] <gaal> I didn't know either.

[19:43] <gaal> is this related to the parsing technology Allison was working on?

[19:43] <gaal> # http://en.wikipedia.org/wiki/Attribute_grammar

[19:43] <lambdabot> http://tinyurl.com/jnjl5

[19:44] <gaal> s/on/with/

[19:44] <putter> I fuzzily recall the question comming up before.  My impression is it wasn't the first thing I thought of, ANTLR-like silly argument passing in parse engine games.

[19:45] <gaal> I don't know ANTLR.

[19:45] <putter> My impression is "attribute grammar" is one of those unfortunate phrases that gets used for a variety of different things.

[19:45] <putter> re pedia, looking...

[19:45] <gaal> hmm

[19:47] <putter> http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

[19:47] <lambdabot> Title: WhyAttributeGrammarsMatter - TmrWiki, http://tinyurl.com/h5byl

[19:47] *** mako132_ joined
[19:47] <putter> including section "What are attribute grammars?".

[19:48] <putter> re ANTLR, http://www.antlr.org/

[19:48] <lambdabot> Title: ANTLR Parser Generator

[19:50] <putter> re ANTLR... well, I've found it very difficult to use, and an indictment of the current state of parser tech.

[19:51] <gaal> because LL(k) in general is harder to write than infinite backtrack?

[19:51] <gaal> or because of more technical reasons?

[19:54] *** ^daemon joined
[19:55] <putter> re attribute grammars, so it looks like declarative composable tree crawling.

[19:57] *** ofer0 joined
[19:58] <rindolf> Hi gaal

[19:58] <gaal> hello

[19:59] <putter> re ANTLR,

[20:00] <putter> and yacc, and... most everything but a few low profile universal parsers,

[20:01] <putter> you don't write a grammar, you right "machine code" to control a particular parser engine.

[20:01] <putter> Success profoundly depends on understanding exactly what the parser engine is doing as a result of your instructions.

[20:02] <putter> And minor changes in grammar can have completely non-linear non-local impacts in how you have to express the grammar.

[20:03] <putter> :/

[20:04] <gaal> I wonder what came of the ghci debugger SoC, because if it was successful, that + Parsec would rule.

[20:04] * putter greps for SoC...

[20:04] <gaal> google summer of code, sorry.

[20:04] <integral> there was a post to the haskell mailing list on that.  Sounds like it'll probably be merged to GHC

[20:05] <putter> http://haskell.org/haskellwiki/GHC/GHCiDebugger

[20:05] <lambdabot> Title: GHC/GHCiDebugger - HaskellWiki, http://tinyurl.com/lxsxa

[20:06] <integral> that's really rather cool

[20:07] <gaal> safeCoerce, lol! though I wonder how is it different from Generics.cast?

[20:08] <gaal> (...why does it take a GHC.Session arg?)

[20:10] <putter> a related problem:

[20:10] <putter> Match objects should really have a link to what rule created them.

[20:10] <putter> Then a parse is an ast.

[20:11] <putter> Having to embed code in rules to create an ast both reduces their generality and flexibility, and makes optimization a pain.

[20:11] <gaal> I need to finish rereading S05, but I think there's a way to get exactly that.

[20:11] * putter 's ears perk, checks...

[20:16] <putter> I don't see it.  The once was a concept of :parsetree, which did both class tagging and what is now :keepall, but :keepall got broken out and the rest disappeared.

[20:16] <gaal> p6-l it, it sounds too useful to miss.

[20:16] <theorbtwo> I think a parsetree is more or less the default.

[20:17] <theorbtwo> Without an explicit return, a rule returns a Rule, which is probably a |capture now.

[20:18] <putter> a regexp match returns a Rule?!?  if so, that's startling.

[20:19] <putter> the issue is when a regex is run against a string, it returns a tree of matches, but the individual matches are not tagged with what rule generated them.

[20:20] <putter> so groveling over the resulting tree is vastly harder than if this information was not thrown away.

[20:21] <putter> like writing XSLT with all the nodes crushed down to a single node type.

[20:21] *** jferrero joined
[20:21] <gaal> I'm off to bed... &

[20:21] <putter> g'night gaal

[20:23] <putter> you want to be able to walk the match tree resulting from, say, parsing some language, and say "if this is an expression node, do x; if literal, do y".

[20:24] <putter> currently you would have to do something like add { $<tag> = 'literal' } to the literal rule, etc.

[20:24] <putter> which means the regex optimizer has to be able to recognize that construct, so it doesn't interfere with optimization.

[20:24] *** fglock joined
[20:25] <putter> though that might be doable, and is thus an alternative to having Match's remember their rules.

[20:25] <fglock> putter: hi

[20:26] <putter> hi fglock!

[20:27] <fglock> hmm - hash-dispatched subrules have 'KEY' - which is kind of a tag of the current rule

[20:27] <wolverian> so, do we still have Foo|Bar as a type signature, or is that a junction?

[20:28] <fglock> wolverian: I think it is a junction operation that results into a signature

[20:29] <fglock> into a type

[20:29] <putter> ie, both :)

[20:29] <wolverian> so I don't get two instances of the interpreter from then on? :)

[20:29] <putter> lol

[20:30] <putter> in copenhagen perl6...

[20:31] <wolverian> it seems like a fairly intuitive special case, in any case

[20:32] *** rindolf joined
[20:32] <putter> so fglock, where are we with the pcr switch + fleshing out

[20:32] <fglock> putter: maybe named rules could make Matches with KEY=>"method_name"

[20:33] <putter> re special case, why special?  just how the type algebra is defined.

[20:33] <fglock> putter: I can't wait for your backtracking implementation :)

[20:33] <putter> fglock: it would be nice to get the rule object itself.  then you can ask it for its name, grammar, etc.

[20:33] *** rindolf joined
[20:34] <putter> hmm, it's not "rule" anymore

[20:34] <fglock> putter: I've been working a bit with emitting plain p5 regex - it actually work in many cases

[20:34] <putter> is there a name for "named regex"?

[20:34] <fglock> grammar methods?

[20:35] <putter> before your work, the state was... what?  individual leaf nodes like \d get their own regexp call (or implementation)?  so the change is combining adjacent ones?

[20:36] <fglock> we need both implementations - plain p5regex only works for unnamed p6regex

[20:36] <fglock> because backtracking in p6 works differently

[20:37] <putter> re being unhappy with names, the "Grammar" (p6 mixin) vs "grammar" (the broader parsing concept), still bugs me. ;)

[20:37] * putter doesn't understand fglock's last two lines...

[20:39] <fglock> putter: if you have a named p6regex with /.*/, it will backtrack until the *caller*  rule matches

[20:40] <putter> rx/\d\d/ can become two nodes (digit,digit), or one, (p5able-regex('\d\d')), and emit as (eat('\d'),eat('\d')) or as (eat('\d\d')).  no?

[20:40] <fglock> for example, you can have / x <ws> \s y /

[20:40] <fglock> yes

[20:40] <putter> (the number of nodes and how it emits are independent options)

[20:41] <fglock> but compare with: '  regex some_digits { \d+ };  rx/ <some_digits> \d / '

[20:42] <putter> so one takes primitive, non-repeating leaf nodes, and combines them up until one hits a quantifier or... couple of other things.

[20:42] <fglock> <some_digits> must backtrack on the caller context

[20:43] <fglock> yes, there are a few other things to consider

[20:43] <putter> re some_digits, indeed, its \d+ can only easily eat('\d').

[20:44] <fglock> it must stop before the last \d, or the caller would fail

[20:45] <putter> "easily" because the rx// could do global (multiple rule) optimization, or one could indeed eat('\d+') if it were givin a wrapper which remembered the last match, and shrank it each time the wrapper was backtracked into.

[20:45] <putter> A wrapper may or may not be faster, depending on how complex the underlying regexp is.

[20:46] <fglock> the problem is how do you 'shrink' a p5regex

[20:46] <putter> s/shrank it/shrank it and ran the regexp again/

[20:47] <putter> re shrink, you shrink the target string, eg,

[20:47] <fglock> but this would create problems with <before> and <after>, for example

[20:48] <fglock> and <at> & others

[20:48] <putter> "123" ~~ /above example/  first matches \d+ with "123".  then \d fails, we backtrack, and /\d+/ is matched against a chop()ed "123", namely "12".  which matches, we proceed, and win.

[20:49] <putter> basically each regex gets both a staring pos, and a must-be-done-by pos.

[20:53] <fglock> how about rx/\d+?/  - it needs to start small, and then grow instead of shrink

[20:55] <putter> there you can just do /\d+?/ the first time, remember its .to, and then on failure, start at .to with another \d.

[20:56] <putter> or more simply, just do \d the first time, etc.

[20:57] <fglock> not too different from current pcr regex

[20:57] <putter> there we are managing the backtracking ourselves, and don't get any ->p5regexp benefit.  re not too different, yes

[20:57] <putter> oh, so that raises one other idea,

[20:58] <putter> while in general we need to manage backtracking, captures, etc, it could be useful sometimes to separate the "finding match" from the "ok, found match, lets do the p6-ish stuff".

[20:59] <fglock> pcr has a dsl for the first part, and a wrapper for the second part

[21:00] <putter> Ie, rx/foo(bar)hee/  first runs p5/foobarhee/ , and only once it finds a match, does it start at that location and do the full p6 version.

[21:01] <putter> the p5 version can suck in the definitions of subrules.

[21:02] <putter> s/suck in/inline/

[21:02] <fglock> but it would need to do this at runtime

[21:03] <putter> well, the usual "has this changed since compile time, if not, use the stashed optimized version", but yes

[21:03] <putter> not clear it's worth doing "if has changed".

[21:04] <fglock> it depends on how you have subclassed the grammar

[21:04] <putter> explain?

[21:05] <putter> oh,

[21:05] <fglock> you may have redefined <ws> to include pod, for example

[21:06] <putter> rules are mixins, yes?, so each child grammar gets distinct Rule objects.  maybe?  if not, then yes, the Rule needs to have a stash indexed by which grammar it is being used in.

[21:07] <fglock> in the pcr/v6.pm implementation, rules are plain p5 methods

[21:08] <fglock> (class methods)

[21:09] <putter> no problem.  almost all of these musings are "stuff for version 2".  ie, one can live with much simpler, if somewhat slower, implementations.  and even if they stay methods, one can just use them to index a objects elsewhere (err, called "inside-out objects" maybe?).

[21:10] *** Aankhen`` joined
[21:10] <putter> s/inside-out objects/inside-out design pattern/.

[21:11] <putter> which brings us back to what pcr needs done to it right now.

[21:11] <putter> what's the current priority list look like, given that audreyt seems to be targetting a release early next week

[21:11] <putter> ?

[21:12] <putter> perhaps not worth fiddling at all with the runtime in that time frame, no?

[21:12] <fglock> fixing infinite loops if there are any left

[21:13] <putter> "left" as in remaining, or "left" as in left recursions? :)

[21:13] <fglock> remaining :)

[21:14] <putter> what else?

[21:16] <fglock> special-casing '+' and '+?' implementations would be great - it currently calls 'concat' recursively

[21:17] <putter> what else? :)

[21:18] <fglock> fix the compile-time capture counter

[21:18] <putter> what is the state of the t/rules, err, now t/regex smoke using pcr?

[21:19] * putter goes to look...

[21:19] <fglock> there are some unimplemented features, like ignore-case and such

[21:19] <fglock> not too difficult to fix

[21:19] <putter> re smoke, iblech++ as always

[21:21] <putter> a lot of skipping going on...

[21:26] <putter> oh, before I forget, my one-liner on the p5 regexp engine performance is "C; some things are blazing *pc++; some good analysis (trie's); dumb - but otherwise the analysis/optimization is not very aggressive".  so the ideal is to do our own aggressive optimization, and then farm out the low level to p5.

[21:29] <putter> http://www.geocities.com/mparker762/clawk#regex has some nice optimizations, but suffers from "at phase n we need the information we threw away at phase n-m :(".

[21:29] <lambdabot> Title: REGEX/CLAWK/LEXER Packages, http://tinyurl.com/r9tnv

[21:30] <putter> anyway, so let's see...

[21:31] <fglock> we could join the current code into a single emitter, which tried to emit p5regexp, and if that fails, emits ratchet code, and if all else fails, emits high-level backtracking code

[21:31] <putter> repeats are parsed now, yes?  is there an implementation?

[21:31] <fglock> repeats == quantifiers?

[21:32] <putter> if not, have you seen backtrack_api.pl's sub_repeat?  could its core be easily transcribed to be used in pcr?

[21:32] <putter> oops, sorry.  ranges

[21:33] <putter> of all the quantifiers, ? * + ?? *? +? {x..y} {x} {x..}, only the ranges aren't working, yes?

[21:34] <putter> oops, left out  {x..y}? , non-greed range

[21:35] <fglock> you can plug the range into the backtracking state - it might work

[21:36] <putter> you mean a range, as in p6 Range?

[21:37] <fglock> yes - I included it in the parser, btw

[21:38] <fglock> it only needs the emitter code

[21:38] <putter> ok, looks like my next task is to become familiar with the pcr runtime.

[21:44] <fglock> trying again to commit...

[21:56] *** rodi joined
[22:03] <fglock> audreyt, kolibrie: $$<foo> is fixed in v6.pm (but svn commits are down)

[22:07] <fglock> hmm - $$<foo>.chars doesn't work because .method is tighter than $

[22:07] <putter> evening &

[22:09] <fglock> $<foo>.chars  - works

[22:33] *** larsen joined
[22:37] *** weinig is now known as weinig|food

[22:37] <Juerd> ?eval "€".chars

[22:37] <Juerd> ?eval "€".bytes

[22:37] <evalbot_r13586> 1

[22:37] <evalbot_r13586> 3

[22:37] <Juerd> I thought evalbot used to be faster than this.

[22:56] *** nothingmuch joined
[23:17] *** bsb joined
[23:35] *** weinig|food is now known as weinig|bbl

[23:42] *** gunya joined
[23:45] *** mjk joined
