[00:03] *** mauke_ is now known as mauke

[00:46] *** robkinyon joined
[00:56] <dazjorz> Khisanth: Now you've banned me too! 0.o

[00:57] <Khisanth> your assumption that it was unintentional is incorrect

[00:58] <dazjorz> aww

[00:58] <dazjorz> :(

[00:58] <dazjorz> He was the one who called me an asshole :P

[00:58] <dazjorz> my bot reaction was quite understandable

[00:59] <Khisanth> that is a very ... poor excuse

[00:59] <dazjorz> yeah, but its the best one i have >.<

[01:06] <dazjorz> Khisanth: At least unban _me_ in #perl plz, i'll keep the bot out of there

[01:15] *** khisanth_ joined
[01:15] *** khisanth_ is now known as Khisanth

[01:40] *** elmex joined
[01:46] *** agentzh joined
[01:48] <agentzh> audreyt: could you get openfoundry support https? http here is awfully slow since only one proxy here can connect to that.

[01:56] *** aufrank joined
[02:03] *** justatheory joined
[02:21] *** Yappo joined
[02:32] <agentzh> it seems to me there's a lot of differences between FIRST {} and INIT {}.

[02:32] <agentzh> not only the one mentioned in S04.

[02:33] <TimToady1> INIT runs once just before the mainline code runs.

[02:33] <agentzh> even if INIT is in a block?

[02:33] <TimToady1> FIRST runs later when you first try to use a block.

[02:33] <TimToady1> yes.

[02:34] <agentzh> ah, so S04 is confusing.

[02:34] <TimToady1> a FIRST will run multiple times in a block that is clones as a closure.

[02:34] <TimToady1> INIT only ever runs once.

[02:34] <TimToady1> *cloned

[02:34] <agentzh> TimToady1: thanks!

[02:34] <TimToady1> basically, FIRST is there to support "state"

[02:34] <agentzh> FIRST won't be called at the time of block construction?

[02:34] <TimToady1> and each clone of a closure gets its own state.

[02:35] <agentzh> TimToady1: yes, S04 states that.

[02:35] <TimToady1> I don't know what you mean by block construction.

[02:35] <agentzh> $ref = { FIRST {...} }

[02:35] <TimToady1> that is when the closure is cloned.

[02:36] <agentzh> it is cloning a sub?

[02:36] <TimToady1> a bare { ... } is a sub

[02:36] <agentzh> i mean "=" clones a sub?

[02:36] *** justatheory joined
[02:36] <TimToady1> executing the {...} construct clones it.

[02:36] <TimToady1> = doesn't care.

[02:37] <agentzh> oh, gotcha!

[02:38] <agentzh> it is already specc'd somewhere in the synopses.

[02:42] *** MacVince joined
[02:52] *** justatheory joined
[03:01] *** nperez joined
[03:03] <pasteling> "agentzh" at 210.22.200.67 pasted "Tests for FIRST/INIT blocks. TimToady: Please check their sanity. :)" (22 lines, 491B) at http://sial.org/pbot/18944

[03:06] <agentzh> Hmm, the relationship between FIRST {} and state variables now makes much sense to me. :)

[03:23] *** mako132_ joined
[03:24] *** MacVince left
[03:28] *** mako132_ joined
[03:29] *** nirgle joined
[03:31] *** mako132_ is now known as mako132

[03:31] <svnbot6> r12177 | agentz++ | [ext/Test/lib/Test.pm]

[03:31] <svnbot6> r12177 | agentz++ | s/say/warn/ in sub diag in order to get more detailed diagnostic messages when using prove or prove6.

[03:38] <svnbot6> r12178 | agentz++ | [ext/Test/lib/Test.pm]

[03:38] <svnbot6> r12178 | agentz++ | s/warn/$*ERR.say/ in sub diag to be more consistent with other parts of Test.pm.

[03:43] *** lambdabot joined
[04:01] *** tup joined
[04:37] *** ruz joined
[04:48] *** norageek joined
[04:49] <norageek> Boofy

[04:54] *** lambdabot joined
[04:54] <svnbot6> r12179 | gaal++ | * parameterize Capt (now spelt that way again) over Exp for runtime

[04:54] <svnbot6> r12179 | gaal++ |   or Val for parsetime.

[04:59] *** agentzh joined
[05:00] <agentzh> dolmans: re backtracking

[05:01] <agentzh> from the machine's point of view, no backtracking means the engine won't step back to some earlier point of the matching process so as to try out an alternative matching rule when a mtach failure occured.

[05:02] <agentzh> in case of matching /.*\w/ against "abc", the matching process is as follows:

[05:03] <agentzh> 0)   abc   .*\w

[05:03] <agentzh> 1)    bc   .*\w

[05:03] <agentzh> 2)     c   .*\w

[05:03] <agentzh> 3)         \w

[05:03] <agentzh> 2)     c   \w

[05:04] <agentzh> so the backtracking happened at step 3.

[05:05] <agentzh> From the programmer's point of view, no backtracking means at any point of the matching process, there's no more than one matching rule (or matching route) to try out.

[05:06] <agentzh> the best way of grokking it may be writing a elementary backtracking regex or rule engine using CPS or Combinators yourself. :)

[05:11] <TimToady1> agentzh: I don't think that's quite right.  What I meant was that the cloning sets up to init the variable again, but it doesn't actually get set till the block is called.

[05:12] <agentzh> TimToady1: Hmm

[05:12] <TimToady1> also, the INIT's settings are going to get wiped out when the my is executed, so you probably just end up with 'o'

[05:12] *** TimToady1 is now known as TimToady

[05:13] <agentzh> TimToady1: yes, the INIT {} test is a typo. :P

[05:14] <agentzh> TimToady: so exactly when will FIRST {} get called?

[05:15] <TimToady> when you say "state $x = func()", func() has to have access to everything that happened right up until that moment the = is executed, which is the same moment it would have been exectued for a my.  the difference is it only does it once.

[05:16] <TimToady> so maybe FIRST isn't even a block  property.

[05:17] * agentzh is confused.

[05:17] <agentzh> TimToady: would you please correct the FIRST tests for me?

[05:17] <TimToady> if the above desugars to "state $x; FIRST { $x = func }" then it has to execute after the declaration.

[05:17] <agentzh> tests maybe better for me to understand this issue.

[05:18] <TimToady> can't right now, but maybe tomorrow.

[05:18] <agentzh> TimToady: okay. i'll reread your message above.

[05:18] <agentzh> *messages

[05:19] <TimToady> basic point is that state initializer has to have access to the current routine's parameters, plus any prior my declarations.

[05:20] <agentzh> TimToady: hmm, this makes sense.

[05:22] <TimToady> anyway, gotta run...

[05:22] <agentzh> TimToady: so "state $x = FIRST {}" calls func() everytime the sub gets cloned while "my $x = FIRST {}" calls func() only once?

[05:22] * agentzh thinks hard on this.

[05:23] <TimToady> the implicit FIRST has to be around the assignment.

[05:23] <TimToady> in fact, the state one is redundant, since it desugars to

[05:24] <TimToady> state $x;  FIRST { $x = FIRST {} }

[05:24] <TimToady> the my example would calculate a FIRST value, and then every time

[05:24] <TimToady> through reinit $x to that value.

[05:25] <agentzh> TimToady: fair enough :)

[05:25] <TimToady> in either case, a FIRST is reset by cloning.

[05:25] <agentzh> got it

[05:25] <TimToady> It's just a different function that has the same name.

[05:25] <TimToady> or something like that.

[05:26] <TimToady> but anyway, I think FIRST isn't a block property like ENTER or LEAVE.

[05:26] <agentzh> TimToady: so S04 needs tweaks?

[05:26] <TimToady> it just runs inline.  so maybe it shouldn't be capitalized.

[05:26] <agentzh> *nod*

[05:27] <TimToady> it's just a control structure with a bit of its own hidden state.

[05:27] <agentzh> it's a source of confusion.

[05:27] <TimToady> on the other hand, that's a good reason for capitalizing it too. :)

[05:30] <TimToady> it's a "until state $hiddenstate++ {...}" or some such, only without the variable name.

[05:30] <agentzh> S04 -- "FIRST {...}*   at every block entry time" but in fact, the "entry" time is very fuzzy.

[05:31] <TimToady> I don't think FIRST even belongs in that list any more.

[05:31] <agentzh> :)

[05:31] <TimToady> but let me think about it overnight.

[05:32] <agentzh> please do :)

[05:32] <TimToady> thanks, and good night. &

[05:32] <agentzh> night!

[05:36] *** weinig is now known as weinig|sleep

[05:42] <svnbot6> r12180 | agentz++ | [t/closure_traits]

[05:42] <svnbot6> r12180 | agentz++ | renamed eval.t to in_eval.t

[05:43] <agentzh> TimToady: the INIT test *is* correct, since it's "my $str ~= 'o'" instead of "my $str = 'o'". :)

[06:03] <svnbot6> r12181 | agentz++ | [t/closure_traits/init.t]

[06:03] <svnbot6> r12181 | agentz++ | added tests for cases like INIT in nested scope and closures with INIT {} in it which is cloned multiple times.

[06:18] <svnbot6> r12182 | agentz++ | [t/closure_traits]

[06:18] <svnbot6> r12182 | agentz++ | added tests to first.t to reflect today's IRC discussion with TimToady. (hopefully i'm not misunderstanding him)

[06:18] <svnbot6> r12182 | agentz++ | TimToady: please tweak these tests mercilessly. :)

[06:18] <svnbot6> r12183 | agentz++ | [t/closure_traits]

[06:18] <svnbot6> r12183 | agentz++ | fixed an obvious bug in first.t

[06:24] <svnbot6> r12184 | agentz++ | [t/closure_traits/in_eval.t]

[06:24] <svnbot6> r12184 | agentz++ | fixed the FIRST test.

[06:26] * agentzh is somewhat discouraged by the handwaving parts of the Perl 6 Spec.

[06:26] *** norageek joined
[06:29] <agentzh> I'll simply code up the tests by my understanding and leave the validity issue to TimToady.

[06:29] <agentzh> anyone who's interested in Perl 6's closure traits can help out under t/closure_traits! :)

[06:30] <nirgle> what's the t stand for

[06:30] <agentzh> nirgle: t is a directory.

[06:30] <nirgle> in in_eval.t

[06:30] <agentzh> .t?

[06:30] <agentzh> t means "test"

[06:31] <agentzh> .t files are also perl scripts just like .pl files.

[06:31] <agentzh> nirgle: does it make sense now?

[06:33] * agentzh goes back to prepare more tests &

[06:33] <nirgle> thanks

[06:34] *** crem_ joined
[06:52] <pasteling> "agentzh" at 210.22.200.67 pasted "tests for traits blocks used in a for loop. comments welcome." (18 lines, 491B) at http://sial.org/pbot/18946

[06:59] *** MacVince joined
[07:09] <svnbot6> r12185 | agentz++ | [t/closure_traits]

[07:09] <svnbot6> r12185 | agentz++ | removed the "obsolete" obsolete.t

[07:09] <svnbot6> r12185 | agentz++ | added in_loop.t with the remaining tests in obsolete.t, which tests various traits blocks in a ``for'' loop.

[07:09] <svnbot6> r12185 | agentz++ | TimToady: please check the validity.

[07:12] <agentzh> so much for t/closure_traits...i'll turn to other parts of the test suit...

[07:13] * agentzh worries about his productivity.

[07:32] *** marmic joined
[07:41] <agentzh> TimToady: does unspace also work in comments? for example, "#\  (comment)".

[07:42] <agentzh> ?eval my $a = #\  (abc) 32;

[07:43] *** evalbot_12172 is now known as evalbot_12185

[07:43] <evalbot_12185> Error:  unexpected end of input expecting comment or term

[07:43] <agentzh> pugs doesn't support this form.

[07:43] *** iblechbot joined
[07:46] *** tup joined
[07:49] <svnbot6> r12186 | agentz++ | [t/syntax/comments.t]

[07:49] <svnbot6> r12186 | agentz++ | added an unpace-in-embedded-comment test. (TimToady: check the validity please.)

[07:51] *** Aankhen`` joined
[07:58] <svnbot6> r12187 | agentz++ | [t/syntax/force_context.t]

[07:58] <svnbot6> r12187 | agentz++ | fixed some misleading comments.

[07:58] <svnbot6> r12187 | agentz++ | added tests for the case of prefix:<->, revealing pugs' "-0" bug.

[07:58] <svnbot6> r12187 | agentz++ | improved the coding style

[08:00] <froh-doh> agentzh: ping

[08:00] <agentzh> froh-doh: pong

[08:01] <froh-doh> I've coded a minimal implementation for quotemeta

[08:01] <agentzh> :)

[08:01] <froh-doh> :)

[08:01] <agentzh> oh, where's it?

[08:01] <froh-doh> basically replicating what's in Perl 5

[08:01] <froh-doh> I waited to commit

[08:01] <froh-doh> because I wanted to ask if it's all ok doing this

[08:02] <agentzh> which file/directory will you commit to?

[08:02] <agentzh> Prelude.pm?

[08:02] <froh-doh> no, wait 10 seconds that I see

[08:03] <froh-doh> M   docs/Perl6/Spec/Functions.pod

[08:03] <froh-doh> M   src/Pugs/Prim.hs

[08:03] <froh-doh> A   t/builtins/strings/quotemeta.t

[08:03] <froh-doh> the docs, the implementation and the test

[08:03] <agentzh> ah, froh-doh++ # haskell programer

[08:04] <froh-doh> well, I actually added 6 lines of code :)

[08:04] <agentzh> *programmer

[08:04] <agentzh> haskell tends to be extremely concise. :)

[08:05] <froh-doh> now, is there some procedure before committing? I compiled and run the test, and it seems fine

[08:05] <agentzh> feel free to commit!

[08:05] <agentzh> if it compiles, commiting is fine.

[08:06] <froh-doh> ok, I'll update my working copy and the I'll commit

[08:06] <agentzh> froh-doh++

[08:07] <froh-doh> it would be great if someone added some test to the test suite, in particular using weird characters

[08:09] <agentzh> froh-doh: i will try later. :)

[08:09] <froh-doh> ok, thanks

[08:10] <froh-doh> ah, one thing

[08:10] <svnbot6> r12188 | agentz++ | [t/syntax/force_context.t]

[08:10] <svnbot6> r12188 | agentz++ | added a magic link (L<...>) to it.

[08:10] <froh-doh> the quotemeta function isn't documented, this is why I worked on docs/... as well

[08:10] <froh-doh> but I see that the maintainer of this doc is TimToady, is it ok to add stuff there?

[08:12] <froh-doh> ok, there will be occasion to revert, {version control}++

[08:12] <svnbot6> r12189 | polettix++ | Added quotemeta builtin, based on current Perl 5 semantics

[08:13] <agentzh> froh-doh: look at Spec/Function.pod

[08:14] *** norageek joined
[08:15] <froh-doh> ah, like it wasn't written clearly! :)

[08:15] <agentzh> froh-doh: i don't think you can commit to synopses maintained by Larry.

[08:15] <agentzh> i didn't find "quotemeta" in the synopses via grep.

[08:16] <froh-doh> this is weird, because there was a placeholder

[08:16] <froh-doh> a single   =item quotemeta    in Spec/Functions.pod

[08:16] <agentzh> oh? in S29?

[08:16] <froh-doh> hmmmm

[08:16] <agentzh> heh, i didn't grep S29. ;-)

[08:17] <agentzh> so i think quotemeta is already specified.

[08:18] <froh-doh> I basically copied the help from Perl5 documentation :)

[08:18] <agentzh> froh-doh: no need to revert then. :)

[08:18] * froh-doh is struck by a light

[08:18] <froh-doh> apparently out of context: does .shift work on @_ by default? and on @*ARGS at the top level?

[08:19] <agentzh> froh-doh: nope.

[08:19] <agentzh> .shift always work on $_ according to S04 or S02.

[08:19] <agentzh> *works

[08:20] <froh-doh> ok, this seems consistent (but a little less perlish)

[08:20] <agentzh> of course, you can always cheat by binding @_ to $_.

[08:20] <agentzh> say, $_ := @_;

[08:21] <agentzh> froh-doh: i think Perl 6 encourages using explicit param list. :)

[08:21] <agentzh> sub foo ($a, $b, *@others) {...}

[08:22] <froh-doh> yes, I've seen this. And it's agreeable. Once you have this, having shift working on @_ by default is only a nostalgic memory

[08:23] <agentzh> aye

[08:30] <svnbot6> r12190 | agentz++ | [t/syntax/force_context.t]

[08:30] <svnbot6> r12190 | agentz++ | added more magic links to Syn.

[08:31] *** norageek joined
[08:39] <agentzh> i'm not sure whether or not Perl 6's quotemeta should be the same as Perl 5's.

[08:39] <froh-doh> this was my fear, but I thougth that could be a reasonable starting point

[08:40] <froh-doh> *thought

[08:41] <agentzh> froh-doh: have you seen the quotemeta.t in perl 5.9.3's test suit?

[08:41] <agentzh> froh-doh: indeed.

[08:42] <froh-doh> no, I'll check it out! That's Columbus' egg!

[08:42] <agentzh> i'll paste it here if you like.

[08:43] <froh-doh> if there's some repository I'll take it from there, don't waste time :)

[08:43] <agentzh> okay

[08:44] <agentzh> even a quotemeta deserves a lot of thinking. :)

[08:47] <agentzh> Hmm, perl 5's quotemeta looks quite sane. maybe it's already enough for perl 6 strings. :)

[08:49] <froh-doh> all the tests are defined in terms of escaping sequences, but I'll try to extract something reasonable

[08:50] <agentzh> heh, simply copying over the tests in quotemeta.t is fine.

[08:50] <froh-doh> uhm, I'm not sure. quotemeta is used as the backend function for stuff like  "\Qhey you\E"

[08:51] <froh-doh> ah, now I get what you mean

[08:51] <froh-doh> test-driven development

[08:51] <agentzh> yeah

[08:52] <froh-doh> OTOH, it will be probably useful to replicate some of the tests in order to directly exercise quotemeta

[08:52] <agentzh> we can also borrow other tests in perl 5's test suit if appropriate.

[08:52] <agentzh> froh-doh: indeed.

[09:05] <agentzh> suppertime &

[09:05] *** agentzh left
[09:08] *** norageek joined
[09:09] *** cnhackTNT joined
[09:18] *** chris2 joined
[09:24] *** ruz joined
[09:31] *** ruz joined
[09:37] <froh-doh> it seems that the behaviour of quotemeta in Perl 5 isn't exactly that specified in the docs

[10:08] *** luqui joined
[10:12] <svnbot6> r12191 | polettix++ | Added some tests from the Perl 5.9.3 test suite, as suggested by agentzh.

[10:12] <svnbot6> r12191 | polettix++ | There remain the question of what to do with Unicode, see comments just

[10:12] <svnbot6> r12191 | polettix++ | before the failing tests (marked with :todo<bug>)

[10:13] <froh-doh> ouch, I forgot to put [t/builtins/strings/quotemeta.t] in the log message :/

[10:41] *** kanru joined
[10:41] *** dazjorz joined
[10:45] *** HEx joined
[10:57] *** kane-xs joined
[11:08] <kane-xs> seen audreyt

[11:08] <jabbot> kane-xs: audreyt was seen 18 hours 38 minutes 1 seconds ago

[11:10] *** Nanomon joined
[11:12] *** elmex joined
[11:14] *** agentzh joined
[11:15] * agentzh is using WaysOnlines' proxy to connect to IRC, which is very reliable but costs him 1.3 US dollar per month.

[11:19] * agentzh ponders replacing t/syntax/hexidecimal.t with t/syntax/char_by_number.t.

[11:29] <svnbot6> r12192 | luqui++ | Reworked t/closure_traits/first.t to represent my interpretation of

[11:29] <svnbot6> r12192 | luqui++ | TimToady's comments.  This exposed a bug (previously, the test was

[11:29] <svnbot6> r12192 | luqui++ | bugged and pugs was working correctly).

[11:32] <agentzh> luqui++

[11:35] <svnbot6> r12193 | luqui++ | Fixed the test that INIT runs only once, in spite of multiple

[11:35] <svnbot6> r12193 | luqui++ | copies of a closure.  I am about to break this. :-)

[11:35] <svnbot6> r12194 | agentz++ | [t/syntax]

[11:35] <svnbot6> r12194 | agentz++ | renamed hexadecimal.t to char_by_number.t and also added more test for \x[a] and \x[a,b].

[11:38] <agentzh> luqui, or maybe "for <first second third> {}". ;-)

[11:38] <agentzh> the code looks much shorter. nice.

[11:38] <luqui> why?  is two not enough to test?

[11:38] <agentzh> i'm kidding. never mind.

[11:38] <luqui> agentzh, well, in addition to looking shorter, it tests what it is supposed to :-)

[11:39] <luqui> (cloning a closure means it is the same position in the code, but in two different lexical environments)

[11:39] <agentzh> really? i didn't know.

[11:39] <luqui> that is my impression

[11:42] <agentzh> luqui: what happened if it's not in the same position?

[11:43] <luqui> that's not really... possible

[11:43] <luqui> basically, each time around the loop, you can consider a new Code object created with its lexical environment

[11:43] <luqui> even though the text is the same, it creates a different object.

[11:43] <luqui> FIRST is associated to that object, not the text.

[11:44] <luqui> whereas in the tests that were there before, you created only one object

[11:44] <agentzh> hmm

[11:44] <luqui> and just called it from multiple places

[11:45] <agentzh> i see. thanks!

[11:47] *** chris2 joined
[11:48] *** cognominal joined
[11:49] *** norageek joined
[11:50] <agentzh> luqui: is #\ (foo) valid perl 6?

[11:50] <luqui> #\ ?

[11:50] <svnbot6> r12195 | luqui++ | Fixed the test that INIT runs only once, in spite of multiple

[11:50] <svnbot6> r12195 | luqui++ | copies of a closure.  I am about to break this. :-)

[11:50] <svnbot6> r12196 | luqui++ | Conjected that state variables do not leak outside of cloned closures.

[11:50] <svnbot6> r12196 | luqui++ | See the test for a better explanation.

[11:50] <agentzh> "\ " is an unspace mark or so.

[11:51] <luqui> oh right

[11:51] <luqui> I'd expect unspace not to count after a comment

[11:51] <agentzh> okay, so it should be invalid.

[11:51] <luqui> I would think that it is just a comment

[11:52] <agentzh> yes, i was saying whether it is a valid embedded comment or not.

[11:53] <luqui> so.. for example you mean:  $foo += #\ (foo) 42

[11:53] <luqui> would in fact add 42 to $foo?

[11:53] <agentzh> aye

[11:53] <luqui> hmm... that's a good question

[11:54] <luqui> I don't know

[11:54] <agentzh> i'd like to see what TimToady will say on this. ;-)

[11:54] <luqui> likewise

[11:54] <luqui> well, I don't actually care, but it's an interesting corner case

[11:55] <agentzh> i've already added this to t/syntax/comments.t

[11:55] <agentzh> it is failing (as expected). :)

[12:01] <froh-doh> people are probably too used to the idea that what follows unquoted # is a comment

[12:02] <luqui> froh-doh, however, I believe we have $foo += #{bar} 42

[12:02] <froh-doh> ugh

[12:03] <agentzh> and also $foo += #<< bar << foo >> >> 42;

[12:03] * froh-doh fears this will open the gates of hell

[12:03] <agentzh> ;-)

[12:03] <agentzh> froh-doh: see t/syntax/comments.t for more horrible samples.

[12:06] <agentzh> froh-doh: see S02 (Spec/Syntax.pod) for the formal description of embedded comments in Perl 6.

[12:06] *** mandhriah joined
[12:07] *** |mandhri| joined
[12:08] * froh-doh "ohmygod"s!

[12:11] * agentzh also thinks Perl 6 is a horrible language.

[12:11] <svnbot6> r12197 | agentz++ | [t/syntax/force_context.t]

[12:11] <svnbot6> r12197 | agentz++ | more magic links to Syn

[12:16] *** plisk joined
[12:16] <agentzh> luqui: please take a look at t/closure_traits/in_loop.t when you have some cycles. :)

[12:17] <agentzh> i'm not sure whether i was doing a right thing there.

[12:20] *** mandhriah joined
[12:21] <agentzh> S04 says too little about ENTER/LEAVE/NEXT/LAST/etc. :-/

[12:21] <luqui> looking

[12:24] <agentzh> yay

[12:25] <luqui> for the first one, it all looks good, except I'm not sure about the ordering of such block

[12:25] <luqui> s

[12:25] <luqui> for example if LAST comes before LEAVE or not

[12:26] <luqui> however, if FIRST comes before ENTER, I would expect LAST to come *after* LEAVE

[12:27] <agentzh> Hmm, sounds reasonable.

[12:27] <agentzh> fixing

[12:28] <luqui> for the second one, "exit" blocks (LAST, LEAVE) should come in reverse order of their appearance

[12:28] <luqui> that is Leave2 Leave1 Last2 Last1, probably

[12:29] <luqui> hmm

[12:29] <agentzh> but i'm doubting whether NEXT and LAST should run at the same time.

[12:29] <agentzh> they seem to be similar things.

[12:29] <luqui> NEXT and LAST are mutually exclusive, are they not?

[12:29] <luqui> oh, but whether NEXTs should be in reverse order, too?

[12:30] <agentzh> yes

[12:30] <luqui> Maybe you ought to fire off a message to p6l asking about these thing?

[12:30] <luqui> *things

[12:30] <agentzh> good idea!

[12:30] <luqui> i.e. relative ordering between types, and reverseness

[12:30] <agentzh> and also the #\ (...) one. :)

[12:42] *** robkinyon joined
[12:48] *** norageek joined
[12:55] <agentzh> mails sent to p6-l. :)

[12:55] *** cm joined
[13:03] <agentzh> night, all &

[13:03] *** agentzh left
[13:04] *** luqui joined
[13:20] *** Aankh|Clone joined
[13:31] <audreyt> my $obj = (class { has $.x }).new(x=>1);

[13:31] <audreyt> I wonder what name of META($obj) has

[13:31] <luqui> hey audreyt, I'm trying to redo state variables

[13:32] <audreyt> and whether they are somewhere in side the symbol table

[13:32] <luqui> how do closures work?

[13:32] <audreyt> that also relates to anonclass in general

[13:32] <audreyt> my C $obj; $obj does Foo; # this creates anonclass

[13:32] <audreyt> but is META($obj) still known as "C"?

[13:33] <audreyt> in perl5, you can always take ref() as a string and look it up with symbol table, walking from root

[13:34] <luqui> I don't think that last property is essential

[13:34] <luqui> I would say either that META($obj) doesn't have a name, or it has a name like ANON006346

[13:34] <audreyt> right. what I'm getting to is that if you have two classes

[13:34] <luqui> which would not be in the symbol table.

[13:34] <audreyt> both known as Bit (counting from the root namespace up)

[13:35] <audreyt> in perl5 they are guaranteed to be the same thing

[13:35] <audreyt> I wonder if it would help to keep that

[13:35] <luqui> how does this affect that?

[13:35] <audreyt> (there's nothing stopping ANON006346to be in the symbol table too)

[13:35] <audreyt> concretely, an object can either keep a identifier

[13:35] <audreyt> as its META

[13:36] <audreyt> or it can keep a pointer to another object

[13:36] <audreyt> as its META

[13:36] <luqui> that's true... I suppose I would like it not to have a name, so that anon classes can be GC'd

[13:36] <luqui> while still being safe

[13:36] *** xdg joined
[13:36] <audreyt> but then it can't be shared

[13:36] <luqui> how so?

[13:36] <audreyt> arguably we want the

[13:36] <audreyt> my C $obj; $obj does D;

[13:37] <audreyt> my C $obj2; $obj2 does D;

[13:37] <luqui> oh my, yes

[13:37] <audreyt> at this point it might be wiser to have $obj/$obj2 share a table

[13:37] <audreyt> instead of blindly GC'ing things away

[13:37] <audreyt> so that argues for a nominal, put-it-into-symbol-table-with-a-name system

[13:38] <luqui> isn't the type of $obj and $obj2 supposed to be the same according to the language, too?

[13:38] <audreyt> that is underspecced...

[13:38] <audreyt> it might or might not be.

[13:38] <audreyt> I think they should, following a recent discussion with stevan

[13:38] <luqui> I seem to recall that it is, but I could be misremembering

[13:38] <audreyt> also our module name identifier is already pretty liberal

[13:38] <luqui> from a logical standpoint, it could be made clean by having classes be value types

[13:39] <luqui> but I don't think that will fly

[13:39] <audreyt> that won't fly as it will seal them

[13:39] <audreyt> we don't want to seal them...

[13:39] <audreyt> i.e. they need to be mutable whilst preserving identity

[13:39] <audreyt> which means they are not value types

[13:39] <audreyt> Type, however, can be a value type

[13:39] <audreyt> what I'm getting to is that objects carry Type names

[13:40] <audreyt> and then you always lookup concrete Class from that type by walking sym table

[13:40] <luqui> class X { method foo() {...} }    multi foo(X $self) {...}   # same thing?

[13:40] <audreyt> luqui: no, not really

[13:41] <luqui> okay.  in any case, I think we are thinking the same thing.

[13:41] <audreyt> $obj.foo # this dispatches via meth first and then fallback to multi

[13:41] <audreyt> &foo($obj) # multi gets it, meth never consulted

[13:41] <luqui> Ever since L::AG, I have been paranoid about GC

[13:41] <audreyt> so they are not same thing

[13:41] <luqui> so I would like a way to clean up unused classes

[13:41] <audreyt> I understand as you are working with a refcounting GC :)

[13:42] <luqui> not really that, it's more that I don't like named indirection

[13:42] <audreyt> ok. anyway, back to your Q

[13:42] <audreyt> but in this case name is full

[13:42] <luqui> full?

[13:43] <audreyt> Bool is actually perl6:Bool-6.0.0-cpan:LWALL

[13:43] <audreyt> or something like that

[13:43] <luqui> I mean I don't like named indirection because it kills GC

[13:43] <kane-xs> hey audreyt. pop over to #p5p for a sec if you have the time please

[13:43] <luqui> okay, anyway, back to my Q

[13:43] <audreyt> luqui: not neccessarily

[13:43] <luqui> :-)

[13:43] <audreyt> you can still tell the Type to keep a ref to the concrete class

[13:43] <audreyt> and make the symtable enttry weak

[13:44] <audreyt> then it will be gone the time the last object with that type gets GCed

[13:44] <luqui> right, then it doesn't seem reasonable to have a symtable entry at all

[13:44] <luqui> just make it all referential

[13:44] <audreyt> well no

[13:44] <audreyt> then you kill sharing

[13:44] <audreyt> think $obj and $obj2 above

[13:44] <audreyt> they won't have a way to know about each other anymore

[13:44] <luqui> well, symtable for implementation purposes I suppose would be okay.  kind of like a cache.

[13:44] <audreyt> yup

[13:45] <luqui> I don't think it should be language-accessible

[13:45] <luqui> well, non-uberguts-language accessible anyway

[13:45] <audreyt> really?

[13:45] <audreyt> right.

[13:45] <audreyt> ok, I think we are in violent agreemtn

[13:45] <luqui> okay then

[13:45] <luqui> state varaibles are presently broken

[13:45] <luqui> I would like to fix them

[13:45] <luqui> but I can't figure out where to look

[13:46] *** foo\ joined
[13:46] <luqui> for ^2 { my $c = { state $x = 42; say $x }; $c();  $c() }

[13:46] <luqui> print 42 43 44 45

[13:46] <luqui> should print 42 43 42 43

[13:47] <luqui> er, *say $x++

[13:48] *** Aankh|Clone is now known as Aankhen``

[13:49] <audreyt> hm

[13:49] <audreyt> state vars are to be cloned when closure is cloned

[13:49] *** lichtkind joined
[13:49] <luqui> aye

[13:49] <audreyt> k. didn't know that

[13:50] <luqui> S04:670

[13:50] <audreyt> yup

[13:52] <audreyt> thinking

[13:53] <audreyt> Eval.hs line 414 governs closure cloning

[13:54] <luqui> hm, okay that is what I was looking for

[13:54] <audreyt> the subBody will look like

[13:54] <audreyt> subBody = Syn "block" [Pad SState MkPad (padToList [("$x",[(<ref>,<ref>)])])

[13:54] <audreyt> the problem is that "Pad SState" refers to compiletime-generated refs

[13:55] <audreyt> as well as first_run etc

[13:55] <audreyt> but they must exist in compile time

[13:55] <audreyt> so one solution is do a full run thru subBody

[13:55] <audreyt> search for Pad nodes

[13:55] <luqui> was that the reason for the @INIT[$idx] business for rvalue INIT?

[13:55] <audreyt> and thoroughly clone their values

[13:56] <luqui> is there a way to plop state variables in the sub's env?

[13:57] <audreyt> in the new AST yes, quite easily,

[13:57] <audreyt> it's just Pugs.Val.Code.c_pad

[13:57] <audreyt> in the old one... no. you need to walk the subBody for Pad nodes.

[13:57] <audreyt> (which is why we are switching to the new one :))

[13:57] <luqui> ouch

[13:58] <luqui> well I'm interested in working on the new one

[13:58] <luqui> but as I told gaal, I'm having trouble navigating it; i.e. finding tasks to do

[13:58] <audreyt> so maybe you can help writing the fromVV instance for Code

[13:58] <audreyt> I mean toVV

[13:58] <audreyt> in line 229 Internals

[13:58] <audreyt> yeah. we ourselves isn't yet very sure of the roadmap of mmigration

[13:59] <audreyt> the nominal Type versus concrete Clas thigng

[13:59] <audreyt> was a blocker

[13:59] <audreyt> that gaal identified; I'm glad to find a (at least emporarily looks-sane) solution of it

[13:59] *** jferrero joined
[13:59] *** robkinyon joined
[13:59] <audreyt> so, to case oldland Code to newland Code

[14:00] <audreyt> toVV' (VCode v) = return $ VV $ val $ ((cast v) :: PureCode)

[14:00] <audreyt> will do

[14:00] <audreyt> but then you need to write a cast instance from old to new

[14:00] <audreyt> by collecting all the oldland's Pad and stuff it to newland's

[14:00] <audreyt> which means you are writing a Pad walker anyway

[14:01] <audreyt> so maybe you can first write a padwalking cloner

[14:01] <audreyt> as was the original plan on Eval line 414

[14:01] <audreyt> and then we reuse that to make it oldPad->newPad

[14:01] <audreyt> the alternate path would be for Parser to directly generate newCode

[14:01] <audreyt> (er I meant oldCod-e>newCode)

[14:02] <audreyt> but that is significantly riskier, as we are still exploring the layouts that works

[14:02] <luqui> I never really grokked pugs's pads

[14:02] <luqui> so I think the former would be good

[14:02] <luqui> are you going to be around for a while?

[14:02] <audreyt> a while, yes, maybe 1 hour or 2

[14:03] <luqui> kay, I'll ask you if I run into troubles, assuming I do not fall asleep first

[14:03] <audreyt> Internals line 1069 is definition of pad

[14:03] <audreyt> ok

[14:03] <audreyt> have fun :)

[14:03] <luqui> (I'm switching from nocturnal)

[14:11] *** explorer__ joined
[14:12] *** elmex joined
[14:23] *** explorer__ left
[14:23] *** jferrero joined
[14:25] *** weinig|sleep is now known as weinig

[14:35] <luqui> what does the 'fresh' field do?

[14:35] <luqui> er, audreyt, ^

[14:35] <luqui> it is not used immediately from the pad structure, but its guts get passed around a lot

[14:39] <audreyt> yo

[14:39] <audreyt> the fresh field controls whether "my" refresh should happen

[14:40] <luqui> which is what?

[14:40] <audreyt> line 316 Eval

[14:40] <audreyt> in "sub f { my $x; BEGIN { say $x } }"

[14:40] <audreyt> you are in compile time looking at a container already

[14:41] <luqui> with a proper clone is that still necessary?

[14:41] <audreyt> that container should not get freshened when f() is first called

[14:41] <audreyt> but any subsequent calls to f() will refresh i

[14:41] <audreyt> but any subsequent calls to f() will refresh it

[14:42] <audreyt> you can verify this curious behaviour in perl5 with

[14:42] <audreyt> sub f { my $x; BEGIN { $x = "Hi!\n" }; print $x } f()

[14:42] <luqui> ahh, i see

[14:42] <audreyt> I'm not sure if it's sane keeping it, but many BEGIN-time behaviour seems to rely on this

[14:42] <audreyt> since the main body closure is a block after all

[14:43] <audreyt> so we pay the cost

[14:43] <audreyt> fresh means roughly "has been entered at runtime"

[14:43] <luqui> now I remember what hacking in haskell is like.  Stare at code for an hour to make a one-line change :-)

[14:43] <audreyt> you can add comments around the code :)

[14:43] <luqui> that's not what I meant...

[14:44] <audreyt> but yeah, it seems to have  that Zen-like pattern

[14:44] <audreyt> it's typechecking your brain

[14:44] <luqui> more as a contrast to C, where you type constantly for an hour to make the same change

[14:44] <audreyt> if you know what you are doing, then you can do it instantly

[14:44] <audreyt> if you don't, then typing around won't help :)

[14:46] <luqui> so um, where are 'state's stored?  in envLexical?

[14:47] <audreyt> they are genearted by Pad nodes

[14:47] <audreyt> at runtime they are joined into envLexical

[14:47] <audreyt> line 342 Eval

[14:47] <luqui> heh, that place again

[15:16] *** Jedai joined
[15:19] <audreyt> gaal: oleg reimplemented the syb idea without Typeable and Data deriving

[15:19] <audreyt> ccshan dubbed it "smash your boilerplate" as it's all compile time and requires no runtime reflection

[15:20] <audreyt> # http://www.haskell.org/pipermail/haskell/2006-August/018353.html

[15:20] <lambdabot> Title: [Haskell] Smash your boiler-plate without class and Typeable

[15:20] <audreyt> # http://okmij.org/ftp/Haskell/syb4.hs

[15:20] <audreyt> investigating applicability :)

[15:29] *** cognominal joined
[15:31] <audreyt> hm, probably not applicable. oh well.

[15:31] * audreyt goes back metamodeling

[15:34] <luqui> yay it compiles!  let's see if it works

[15:42] <wolverian> hrm, it seems to be my GHC or Cabal installation is borked. I get this on 'perl Makefile.PL': Could not find module `Distribution.Simple'

[15:43] <wolverian> any hints how to fix? I just have the ubuntu ghc6 package, shouldn't have anything in local

[15:45] <wolverian> hrm actually: library-dirs: /usr/local/lib/Cabal-1.1.4/ghc-6.4.1

[15:45] <wolverian> weird.

[15:45] <wolverian> (that doesn't exist)

[15:47] <wolverian> btw, README refers to Artistic License 2.0b5. should that be updated?

[15:53] <audreyt> wolverian: I'd like to stay GPL compatible for a while...

[15:53] <audreyt> we can probably upgrade to A2 once OSI/FSF people have reviewed it, and GPL3 is out which will probably will be compatible with A2

[15:53] <wolverian> audreyt, I thought A2 is compatible with GPL2

[15:54] <audreyt> really? apache2 is not, so I doubt artistic2 is

[15:54] <audreyt> both has patent retaliation clause

[15:54] <wolverian> ah, okay.

[15:55] <audreyt> (GPL will be updated to be compatible with that, but meanwhile.)

[15:55] <wolverian> yeah.

[15:56] <wolverian> I thought you can kind of ignore the differences because of 4.c.ii

[15:56] <wolverian> (relicense clause)

[15:59] <audreyt> yeah.

[16:00] <audreyt> it's compatible-by-casting

[16:00] <audreyt> but then we might as well go GPL all the way :)

[16:00] <wolverian> depends on how compatible we want to be with perl6 ..

[16:00] <audreyt> or perl5...

[16:00] <wolverian> licenses are hard

[16:01] <audreyt> I mean, parrot and perl5 are both in A1/GPL

[16:01] <wolverian> why is there no Comparison of Free Software Licenses page on wikipedia?

[16:05] *** cmarcelo joined
[16:08] <audreyt> cmarcelo: hi!

[16:08] <cmarcelo> audreyt: hello =).. apparently the lots of errors is a mistake I made in trying make this work statically. at least GHC 6.4.2 + dynamic link works fine (almost same number of errors) with quasi-trunk..

[16:09] <audreyt> oh good

[16:09] <audreyt> commit! commit!

[16:09] <cmarcelo> i'm investigating now segfault problems with GHC 6.5... and how to came back with static thing.. ("make" takes too much time here)

[16:10] <audreyt> ah. ok :)

[16:10] * audreyt meanwhile is deep in mzscheme, mono and ruby internals

[16:11] <luqui> does audreyt find the ruby internals frighteningly undocumented?

[16:11] <audreyt> er no

[16:11] <luqui> really?

[16:11] <audreyt> I find it to be crystal clear compared to perl5

[16:11] * luqui has hardly touched the perl5 source

[16:12] <audreyt> you see, I start with a very low expectation...

[16:12] <audreyt> ;)

[16:12] <luqui> the code is clearly written, but there was nary a comment to be found

[16:12] <audreyt> because, as ingy likes to say, the code is self-documenting

[16:12] <luqui> I submitted a -2 line patch to p5p once

[16:12] <audreyt> (that is true only sometimes.)

[16:12] <luqui> yeah... as an embedder, not a hacker, I would have appreciated english

[16:12] <luqui> but yeah, it's pretty nice code when you get down to it

[16:13] <audreyt> mono's handling of MONO_TYPE_VALUETYPE got me what Im looking for

[16:13] <luqui> and I understand that matz's english is not so great; probably a mixed blessing

[16:13] <audreyt> so I'm happy :)

[16:13] <luqui> neat

[16:13] <audreyt> well, _my_ english is pretty bad, and that partly explains the lack of comments in my code...

[16:14] <audreyt> (though the blogging had made my english considerably more natural, I've heard)

[16:14] <luqui> yeah, audrey, your english is terrible.  I mean you make minor grammatical errors one in ten utterances.  Come on, get with the program!

[16:14] <audreyt> :D

[16:17] *** iblechbot joined
[16:20] *** sysfault joined
[16:20] *** sysfault left
[16:21] <audreyt> ok. I think I grokked how value types are treated in mono

[16:22] <audreyt> will try to put that into code tomorrow

[16:22] <audreyt> when I finally got a whole day for pugs :)

[16:22] * audreyt waves and goes to sleep &

[16:23] *** pdcawley joined
[16:26] *** Psyche^ joined
[16:26] *** Psyche^ is now known as Patterner

[16:33] <gaal> ooh, thanks for the link audreyt!

[16:33] <gaal> sadly I'm zonked after $work

[16:33] <gaal> maybe recover in a few hours, if not - Tuesday

[16:34] <gaal> ah, I notice you mentioned it's not applicabele. oh well.

[16:34] <audreyt> it;s applicable but requires hand deriving of the Dat type

[16:34] <audreyt> (or DrIFT-assisted deriving)

[16:34] <audreyt> since unlike Data, there's no builtin support

[16:35] <gaal> I was amazed that ((:<:) Foo) was autoderivable

[16:35] <audreyt> and the visitors, while easier to write than syb's and more powerful, I don't see an easy way to use the more powerful parts

[16:36] <gaal> (*why* was it derivable?)

[16:36] <audreyt> it's only derivable for newtypes

[16:36] <audreyt> you can derive anything for newtypes :)

[16:37] <gaal> what's a good thing to read to grok why that is the case?

[16:37] <gaal> the report?

[16:37] <audreyt> newtypes are at runtime exactly the same thing as its base type

[16:37] <audreyt> it exists solely to give you a chance to hang different instances to it

[16:37] <audreyt> so you can automate deriving by simply adding the tycon and casing it

[16:38] <audreyt> and in fact the compiler erases both anyway before codegen

[16:38] <audreyt> GHC user guide, "7.4.12. Generalised derived instances for newtypes"

[16:38] <gaal> so it's just lip service to the typechecker?

[16:39] <gaal> ok i'll read that

[16:41] <SamB> actually they are also useful for keeping you from getting confused, sometimes

[16:41] <audreyt> :) &

[16:44] * gaal zones out &

[16:49] *** vel joined
[17:08] *** robkinyon joined
[17:19] *** justatheory joined
[17:26] *** Odin- joined
[17:33] *** lumi_ joined
[17:36] *** weinig is now known as weinig|away

[17:41] *** mauke_ joined
[17:45] *** xerox joined
[17:45] *** lollan__ joined
[17:45] *** lollan joined
[17:45] *** lollan_ joined
[17:55] *** nirgle joined
[17:56] *** nothingmuch joined
[17:57] *** lollan joined
[18:01] *** mauke_ is now known as mauke

[18:13] *** diakopter joined
[18:56] *** cm joined
[19:00] *** hexmode joined
[19:08] *** mdiep joined
[19:14] *** lumi joined
[19:20] *** jferrero joined
[19:34] <mdiep> Coke++ # test_more.tcl changes

[19:36] <mdiep> err... wrong channel :-)

[19:36] *** justatheory joined
[19:36] <marcus_> Ë

[19:38] *** rgs joined
[20:19] <diakopter> seen TimToady

[20:20] <jabbot> diakopter: TimToady was seen 14 hours 47 minutes 22 seconds ago

[20:40] *** weinig|away is now known as weinig

[20:42] *** cognominal left
[20:43] *** cognominal joined
[20:44] *** cognominal left
[20:53] *** cognominal joined
[21:26] *** rashakil joined
[21:26] *** crapulous joined
[21:30] *** vsoni joined
[22:17] *** hexmode joined
[22:23] *** weinig is now known as weinig|coffee

[22:51] *** weinig|coffee is now known as weinig

[23:08] *** justatheory joined
[23:18] *** justatheory joined
[23:30] *** ludan joined
[23:48] *** kanru joined
[23:50] *** diakopter_ joined
[23:59] *** Bit-Man joined
