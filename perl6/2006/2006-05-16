[00:00] *** mncharity joined
[00:06] <mncharity> I had a very odd dream last night that people had forgotten that pugs oo wasn't working, were energetically puzzled by no one writing big oo projects over the last year, and were mad at me for not telling them! :-)

[00:07] <mncharity> So, I note,  class A {has $.x;} sub f(){A.new}  f().x   remains unchanged.

[00:10] *** llp joined
[00:10] *** justatheory joined
[00:22] *** rashakil joined
[00:31] *** Quell joined
[00:35] <mncharity> &

[00:36] *** penk joined
[00:36] *** pen1 joined
[01:02] <meppl> gute nacht

[01:06] *** flounder99 joined
[01:15] *** oylenshpeegul joined
[01:23] *** Ymmv joined
[01:35] *** jserv-- joined
[01:38] <svnbot6> r10359 | lwall++ | CGI util test had bogus eval

[01:41] <theorbtwo> -

[01:46] *** oylenshpeegul left
[01:52] <TimToady> I have just realized that pugs tests misuse "not" as a unary operator all over the place when it's currently defined as a list operator.  Hmm.

[01:58] *** _SamB_ joined
[02:01] <TimToady> that's interesting...true 1,2,3 does not parse the same as not 1,2,3

[02:01] *** llp left
[02:20] <audreyt> because not is listop

[02:21] <audreyt> why is "not"listop again?

[02:28] *** mako132_ joined
[02:28] *** bsp joined
[02:29] <audreyt> currently not is a listop that returns undef on 0arg, True if all args are false, and False otherwise

[02:29] <audreyt> I wonder why is it specced that way in p5 :) and also why "true" doesn't work the same way as "not"...

[02:29] <audreyt> (or vice versa)

[02:31] <FurnaceBoy> so...

[02:31] <FurnaceBoy> it's really not(a || b ...)

[02:32] <TimToady> just rewrote the precedence table...

[02:32] <FurnaceBoy> "none of"

[02:34] <TimToady> actually, I think we can combine comma with listop while we're at it.

[02:35] <TimToady> with a little handwaving...

[02:36] <TimToady> I think we aren't going to be able to teach people not to write things like:

[02:36] <TimToady> ok not -r 'doesnotexist.t', "-r returns false on non existant files";

[02:36] <audreyt> which means not becomes unary?

[02:36] <TimToady> see S03 :)

[02:36] <audreyt> (and do we go ahead with the plan of killing the ?=$_ for unaries)

[02:38] <TimToady> I think so.

[02:40] <audreyt> k

[02:41] *** hikozaemon joined
[02:47] * pmichaud takes a peek at S03

[02:49] <TimToady> hang on, updating again.

[02:49] <pmichaud> okay

[02:50] <TimToady> svn up or wait for p6l logger

[02:51] <pmichaud> svn up'd

[02:52] <pmichaud> interesting that 'and' is combined with '<=='

[02:53] <TimToady> not anymore

[02:53] <pmichaud> oh, sorry, wrong message

[02:53] *** justatheory joined
[02:54] <pmichaud> okay, so to make sure I have this right

[02:54] <TimToady> the "loose unary" category now maps nicely to the "everything tighter than comma" category.

[02:55] <pmichaud> foo 3, bar 4   parses as foo(3,bar(4))   (more)

[02:55] <TimToady> listops still parse pretty much exactly like they did before.

[02:55] <pmichaud> foo 3, bar { baz }.xyz   parses as foo(3, bar({baz}).xyz)   ?

[02:55] *** Quell joined
[02:56] <TimToady> I think that's probably the most natural interpretation.

[02:56] <pmichaud> okay, good, because that's what my parser will likely do

[02:56] * pmichaud tests

[02:57] <TimToady> I'm wondering whether we can make foo 3, bar { baz };.xyz mean the other thing.

[02:57] <pmichaud> no, please

[02:57] <TimToady> at some point parens are fine

[02:57] <pmichaud> that looks to me like foo 3, bar { baz }; $_.xyz

[02:58] <TimToady> It would just be applying the postfix rule to a statement, but yes, it would drive the golfers nuts.

[02:58] <pmichaud> "at some point parens are fine"  :-)

[03:00] <TimToady> Anyway, listops are all kinda weird anyway, so we can just handwave them all to the same precedence level, given it's kinda sort left-associative when it's not being list associative anyway...

[03:00] <TimToady> *sorta

[03:04] <pmichaud> TimToady: works for me

[03:04] <TimToady> and I'm happier with "and" separated out from the pipes.

[03:05] <pmichaud> definitely -- that looked very odd

[03:05] <TimToady> probably easier to remember that way despite being an extra level.

[03:05] <audreyt> makes sense.

[03:05] <pmichaud> and it's official that the named unaries always have an operand?

[03:06] <pmichaud> i.e., don't assume $_ ?

[03:06] <TimToady> yes.

[03:06] <pmichaud> excellent

[03:06] <audreyt> but what about -e ?

[03:07] <audreyt> and "exit"?

[03:07] <TimToady> speaking of which !-e "foo" doesn't parse

[03:07] <TimToady> exit; is a term.

[03:07] <audreyt> exit 1;

[03:07] <audreyt> so exit is still "optional unary"

[03:07] <TimToady> that's a named unary.  :)

[03:07] <TimToady> only if MMD lets us.

[03:07] <audreyt> i.e. it has both () and ($) forms

[03:07] <audreyt> which is not at all diff from ($?) forms

[03:08] <audreyt> since it needs to be parsed as both term and unary

[03:08] <TimToady> I'm getting rid of the $? forms because it duplicates the .foo forms mostly.

[03:08] <audreyt> unless we say that exit() must be written as such when ambiguous

[03:08] <TimToady> just make it a listop?

[03:08] <audreyt> so ($?) becomes listop

[03:09] <audreyt> is that the idea?

[03:09] <TimToady> lemme think

[03:09] <audreyt> (-e becoming a listop would be odd.)

[03:09] <pmichaud> (fwiw, I still don't have an issue with optional arguments to named unaries, I was just asking)

[03:10] <TimToady> I think we just require exit() if ambiguous.

[03:10] <audreyt> (I think defaulting to $_ can go, but other forms of defaulting still introduces ambig, and we need to bias against ($))

[03:10] <audreyt> so ($?) parses as ($) and require () for the () variant

[03:11] <audreyt> say exit; # fine

[03:11] <TimToady> require () when ambiguous, you mean

[03:11] <audreyt> say exit < 3; # not fine

[03:11] <audreyt> yes

[03:11] <TimToady> yes, shift over reduce.

[03:11] <TimToady> "longest token'

[03:11] <audreyt> which is not different from how PGE and Pugs treat them currently

[03:12] <TimToady> or P5, for that matter.

[03:12] <audreyt> right. ok. so, what about -e?

[03:12] <audreyt> simply require

[03:12] <audreyt> -e $_

[03:12] <audreyt> ?

[03:12] <audreyt> .file_exists ?

[03:12] <TimToady> or .is_exists?

[03:12] <audreyt> .is_exists

[03:12] <TimToady> .is_dir etc.

[03:12] <TimToady> .is_there?

[03:12] <audreyt> was thinking about that

[03:13] <audreyt> "no it's here, not there"

[03:13] <TimToady> .is

[03:13] <audreyt> too confusing with trait auxisllary

[03:13] <TimToady> yeah...

[03:13] <audreyt> ._e

[03:13] <TimToady> yeah, I was just wondering that myself

[03:14] <audreyt> may not be a bad idea

[03:14] <TimToady> but also wondering about _e $file

[03:14] <audreyt> that is, remove the conflict with unary -

[03:14] <TimToady> seems a bit gauche.

[03:14] <pmichaud> =e

[03:14] <audreyt> "lacking social polish"

[03:14] <pmichaud> oh, nm

[03:14] <pmichaud> won't work as .=e

[03:15] <audreyt> TimToady: if there is a postfix "int"

[03:15] <audreyt> what does

[03:15] <TimToady> .-e is actually available, for all that.

[03:15] <audreyt> $foo.int

[03:15] <audreyt> prefer?

[03:15] <audreyt> or, better example, postfix factorial !

[03:15] <audreyt> $num.!

[03:15] <audreyt> does it go to prefix or postfix?

[03:15] <audreyt> why is $x.++ prefer potfix

[03:15] <audreyt> postfix

[03:16] <audreyt> but $x.meth calls meth($x)?

[03:16] <audreyt> or is it "if there is postfix, use that"

[03:16] <audreyt> otherwise use prefix?

[03:16] <audreyt> because if that rule is in place

[03:16] <audreyt> then .-e works.

[03:16] <TimToady> cause nobody defined postfix:<meth>?

[03:16] <audreyt> yeah, that's what I'm wondering

[03:17] <audreyt> i.e. the $foo.meth call is actually a fallback to prefix

[03:17] <TimToady> foo() is already ().foo

[03:17] <audreyt> and would parse as "$foo meth" when got a chance

[03:17] <TimToady> semantically

[03:17] <TimToady> huh?

[03:17] <audreyt> but if we have both prefix ! and postfix !

[03:17] <audreyt> then "! $x" and "$x !" parses differently

[03:17] <audreyt> and we said that "$x.!" prefers postfix

[03:18] <audreyt> but if no-one defines postfix !, and there is already prefix !

[03:18] <TimToady> $x ! is always illegal

[03:18] <audreyt> maybe we can get "$x.!" parse as prefix

[03:18] <audreyt> nono, I mean someone defined

[03:18] <audreyt> sub postfix:<!> ($x) { [*] 1..$x }

[03:18] <TimToady> yes, but the syntax "$x !" is illegal.  no space allowed.

[03:18] <audreyt> ok. then "$x!" vs "!$x"

[03:18] <TimToady> I with you on the semantics

[03:19] <audreyt> so if there is no postfix:<!> defined yet

[03:19] <audreyt> then "$x.!" goes back to "!$x"

[03:19] <audreyt> but "$x!" is parsefail

[03:19] <audreyt> and that gains us ".-e"

[03:19] <TimToady> right.

[03:20] <audreyt> interestingly that means ".-----" is a provisional call on -----

[03:20] <TimToady> well, assuming that the declaration of prefix:<-e> makes it syntactically visible as postfix:<-e> but not, er, as a postfix.

[03:20] <audreyt> or maybe we do require that a prefix prototype is already seen for non-identifiers

[03:20] <audreyt> yes, that you said.

[03:20] <audreyt> but ".unseen" is always provisional call

[03:21] <TimToady> yes, falls out for idents

[03:21] <audreyt> it's only on ".--something-not-identifier" we need a predeclaration of either pre or post

[03:21] <audreyt> ok, I like that.

[03:21] <TimToady> affix:<-e>

[03:21] <audreyt> I think simply "postfix:<-e>" is sufficient :)

[03:21] <audreyt> er I mean

[03:21] <audreyt> prefix:<-e>

[03:21] <TimToady> except that allows $x-e

[03:22] <audreyt> right, typo

[03:22] <TimToady> and if you want to disallow it you declare your own postfix.

[03:22] <TimToady> hmm.

[03:22] <audreyt> makes sense

[03:22] <TimToady> what if there's a conflicting infix

[03:22] <audreyt> I like .-e a lot more than .is_exists

[03:23] <audreyt> TimToady: longest token

[03:23] <TimToady> oh wait, there's always a dot

[03:23] <audreyt> .--moose-declared  trumps .--moose - declared

[03:23] <audreyt> if it's declared

[03:23] <audreyt> yup

[03:23] <pmichaud> yes, essentially the dot rule becomes something like   <dot> <%postfix|%postcircumfix|%prefix> ?

[03:23] <pmichaud> preferring postfix and postcircumfix to prefix?

[03:23] <TimToady> yeah.

[03:24] <audreyt> *nod*

[03:24] <audreyt> and a |<ident> finally

[03:24] <TimToady> sneaking <[=*+?]> in there somehow

[03:25] <TimToady> heh.  foo().@

[03:25] <audreyt> fortunately -e is not [=*+?]

[03:25] <audreyt> wow. useful.

[03:25] <audreyt> @$_ becomes .@

[03:26] <TimToady> ().$

[03:27] <TimToady> one little problem $x.$method

[03:29] <audreyt> put that before ident

[03:29] *** FurnaceBoy_ joined
[03:29] <TimToady> but it would see .$ before that.

[03:29] <audreyt> before ident = same as prefix

[03:29] <audreyt> so longest win

[03:29] <audreyt> var is longer than a simple $

[03:29] <pmichaud> but we can't look up from the hash

[03:29] <TimToady> we can't put all those into the hash.

[03:30] <pmichaud> <%prefix>

[03:30] <pmichaud> it'd have to go before the <%postcircumfix|%postfix|%prefix>

[03:30] <TimToady> well, the .$ rule could resolve it its own self.

[03:30] <audreyt> and require 2char lookahead

[03:30] <audreyt> that too

[03:30] *** KingDiamond joined
[03:31] <TimToady> we can perhaps allow postfix:<.$> with an explicit dot to allow only the dot form.

[03:32] <pmichaud> TimToady: just committed the revised grammar with the updated <?ws> and long dot rules

[03:32] <TimToady> pmichaud++

[03:32] <pmichaud> (in case you want to peek when you get a chance)

[03:33] <TimToady> still don't know what my chances are the next few days...

[03:33] <pmichaud> it still has the issues with precedence among prefix/postfix, but we'll cross that bridge when we get there :-)

[03:34] <pmichaud> TimToady: np, thanks for the help on it

[03:34] <audreyt> what does $obj.@methods mean anyway?

[03:34] <audreyt> what bout $obj.%method_name_and_arguments?

[03:35] <TimToady> those don't mean anything right now.

[03:35] <audreyt> nod, mostly because they are illegal in p5?

[03:35] <TimToady> we could break .$method and force it more symbolic defer-like

[03:35] <TimToady> though .($method) doesn't work...

[03:36] <TimToady> and .::($method) kinda gives the wrong idea.

[03:36] <audreyt> .$method is a symbolic lookup

[03:36] <audreyt> and never treat $method as anything but a string, right?

[03:36] <TimToady> right.

[03:36] <audreyt> then probably keep it that way is fine

[03:37] <audreyt> may make sense to generalize to .@method

[03:37] <TimToady> so .::($method) works, but kinda implies there's a package name on the front.

[03:37] <audreyt> yeah.

[03:37] <TimToady> .*@method maybe.

[03:37] <TimToady> .?$method

[03:37] <audreyt> yeah.

[03:38] <audreyt> though .?$method lose the "fail if lookup fails"

[03:38] <audreyt> otoh, it's much more likely to fail when you put names into a var

[03:39] <pmichaud> back later

[03:39] <audreyt> otoh, I think $obj.$method is p5ish and worth keeping. maybe .@meth and .%meth should not work after all

[03:39] <TimToady> .+$method isn't quite right either.  Want .**{1}$method

[03:39] <audreyt> well, I proposed .:$method for that but that was shot down...

[03:40] <TimToady> .:method($method)

[03:40] <audreyt> yeah. bad idea

[03:40] <TimToady> reminds me of the lying P5 exec semantics...

[03:40] <audreyt> I think the parser can work with .$method

[03:40] <TimToady> me too.

[03:42] <TimToady> on the other hand, .::($method) would be more consistent with other sym stuff

[03:42] <TimToady> and $::("foo") doesn't imply any package either.

[03:43] <audreyt> and it's fortunately in tokyo to said :: is not a prefix caster.

[03:43] <audreyt> (that's not english, mostly because I'm multitasking on visa stuff :))

[03:43] <audreyt> (if it's caster than it would mean .prefix:<::>(...))

[03:44] <audreyt> so .::($method) can work

[03:44] <audreyt> and would make hobgoblins happy

[03:44] <TimToady> though we currently have Package.::.{$sym}

[03:45] *** scw_ is now known as scw

[03:45] <audreyt> Package.%.{$sym}

[03:45] <audreyt> according to the new pre-as-dot-post rule.

[03:46] *** particle_ joined
[03:46] <TimToady> Hmm %(Package) is different from %Package.

[03:47] <audreyt> that falls out from symderef-requiring-::

[03:47] <audreyt> so was like that for some time now

[03:47] <audreyt> maybe it's possible to have just Package.{$sym}

[03:47] <TimToady> arguably longest token is ::( there

[03:48] <TimToady> and do metatype stuff with .[] and .(), I guess.

[03:49] <TimToady> or ^Packge

[03:50] <TimToady> little problem that ^foo as a unary operator is looser than ^foo.bar

[03:50] <TimToady> But don't really want to make ^Dog a special form.

[03:50] <TimToady> since that would clobber ^int($x) and such.

[03:51] <TimToady> so we might end up seeing a lot of (^Dog).methods and such.

[03:51] <TimToady> unless we go with something else for .meta shorthand.

[03:51] *** _SamB_ is now known as SamB

[03:52] <TimToady> Maybe it's all Dog.^methods and such.

[03:52] <TimToady> same problem with prefix:<^>, same solution...

[03:54] <TimToady> and I guess ^Dog could still be the metadog as long as people don't expect to write ^Dog.methods

[03:54] <TimToady> "everything in the range of Dogness"

[03:55] <audreyt> Dog.^method is the same as

[03:55] <audreyt> Dog.^.method

[03:55] <audreyt> so I don't see a big difficulty in explaning the .^method form

[03:55] <TimToady> cool

[03:56] <audreyt> cool. I look forward to spec :) will fix -e and make .prefix work

[03:56] <TimToady> Cat^..^method

[03:56] <audreyt> $foo.+++ means calling postfix ++ with + semantics

[03:57] <audreyt> strange but true

[03:57] <audreyt> bbiab :)

[04:06] *** penk joined
[04:11] <TimToady> I don't see how.  It'd have to be $foo.++.+ since we require dot on prefix-as-postfix

[04:11] <TimToady> the only other parse is $foo.++ + where final + is infix

[04:11] <TimToady> But a .+.++ parse would require violating longest token.

[04:17] <audreyt> $foo.+method

[04:18] <audreyt> calls all methods (1 or more)

[04:18] <audreyt> principle of most surprise

[04:18] <audreyt> or the meth modifier doesn't apply to symbolics?

[04:18] <audreyt> because $foo.+int should work.

[04:25] *** KingDiamond joined
[04:27] <TimToady> I think $foo.+::("++") would actually be clearer...

[04:29] <TimToady> or $foo.+postfix:<++>

[04:30] <TimToady> so I'm inclined to say that the .+ forms have to be alpha (or maybe ::)

[04:35] *** kanru joined
[04:37] <audreyt> so there needs to be two hashes

[04:37] <audreyt> one for symbolic unary one for named unary

[04:39] <TimToady> why?

[04:40] <audreyt> because one is subject to + and one is not

[04:40] <audreyt> "int" is named unary

[04:41] <audreyt> "-e" is symbolic unary

[04:41] <audreyt> .+int works, .+-e not.

[04:41] <TimToady> -e is named unary

[04:41] <TimToady> the constraint has nothing to do with precedence level

[04:41] <audreyt> ok. still

[04:41] <audreyt> right. sorry. I meant ident unary

[04:42] <audreyt> and nonident unary.

[04:42] <TimToady> that I'll grant you

[04:43] <TimToady> $x.say("me too")

[04:43] <TimToady> prefix:<say>

[04:47] <TimToady> probably prohibited with extra args

[04:47] <TimToady> that is, the prefix-as-postfix fallback.

[04:48] <TimToady> 100.^(:by(2))

[05:14] *** elmex joined
[05:34] *** Quell joined
[05:39] <svnbot6> r10360 | lwall++ | Whacked a lot of the =$+_ defaults.

[05:41] *** Quell joined
[05:44] *** Quell joined
[06:19] *** tardisx joined
[06:32] *** marmic joined
[06:32] *** iblechbot joined
[06:56] *** kanru joined
[06:58] <gaal> antlerless brown moose sleep ferociously

[07:01] *** avar joined
[07:12] *** neoesque joined
[07:38] *** elmex joined
[07:40] *** kane_ joined
[07:59] *** kanru joined
[08:02] *** froh-doh joined
[08:15] *** lypanov joined
[08:19] *** bsb left
[08:24] *** lisppaste3 joined
[08:54] *** tardisx joined
[09:05] *** lypanov left
[09:11] <svnbot6> r10361 | audreyt++ | * unTODO now-passing tests.

[09:31] *** nnunley joined
[10:01] *** chris2 joined
[10:04] *** tardisx joined
[10:12] *** ludan joined
[10:24] *** tardisx joined
[10:39] *** jserv-- joined
[10:56] *** kane__ joined
[10:59] *** kane___ joined
[11:04] *** chris2 joined
[11:28] *** tardisx joined
[11:55] *** kanru joined
[11:57] *** mako132_ joined
[12:01] *** jsiracusa joined
[12:20] *** iblechbot joined
[12:21] *** kolibrie joined
[12:23] *** trym joined
[12:24] *** weinig joined
[12:58] *** f0rth joined
[12:58] *** f0rth_ joined
[12:59] *** f0rth joined
[13:06] *** iblechbot joined
[13:06] *** nnunley joined
[13:07] *** nnunley joined
[13:07] *** shachaf joined
[13:08] *** jserv-- joined
[13:12] <[BlueT_at_Mars]> jserv--: @@

[13:20] *** khisanth_ joined
[13:21] *** elmex joined
[13:23] *** justatheory joined
[13:31] *** rashakil joined
[13:42] *** cdpruden joined
[13:42] *** KingDiamond joined
[13:43] *** hexmode joined
[13:43] *** chris2 joined
[13:53] *** kanru joined
[14:06] <svnbot6> r10362 | fglock++ | PCR - <p6ws> renamed to <ws>; :ratchet - Match::Ratchet is closer to a 'Capture'; basic named captures

[14:13] *** Limbic_Region joined
[14:21] *** rashakil_ joined
[14:37] *** rindolf joined
[14:38] <rindolf> Hi all.

[14:40] *** FurnaceBoy joined
[14:52] *** szbalint_ joined
[14:54] *** szbalint_ is now known as szbalint

[15:15] *** Ymmv joined
[15:23] *** cdfh_ joined
[15:28] <TimToady> mumble, blear, gah, mornings are lovely, and I hate 'em.

[15:28] *** IR7080 joined
[15:29] <rindolf> TimToady: hi.

[15:30] <TimToady> howdy!

[15:30] <rindolf> TimToady: what's up?

[15:30] <IR7080> .

[15:30] <IR7080> hello everyone

[15:30] <IR7080> im kinda new to perl6

[15:30] <rindolf> TimToady: torturing some lambda-camels?

[15:30] <IR7080> ive been reading the perl6-all mailing list stuff

[15:30] <IR7080> looks like one hell of a language

[15:30] <TimToady> just rewrote the precedence table yesterday, rindolf

[15:31] <TimToady> IR7080: in both senses, yes.

[15:31] <IR7080> too bad its no clearer than chinese

[15:31] <PerlJam> IR7080: I find perl6 *much* easier to read than chinese  :)

[15:31] <TimToady> the chinese think chinese is rather clear

[15:31] <rindolf> TimToady: so now the p6 operators have different precedence?

[15:31] <TimToady> just some of the looser ones

[15:32] <TimToady> true and not are now tighter than comma

[15:32] <PerlJam> TimToady: I take it you're still trying to unify precedences where ever you can?

[15:32] <TimToady> just unified comma with listops last night, with a little handwaving.

[15:33] <TimToady> actually had the pipe operators unified with "and" for a bit, but then decided that was a bad plan.

[15:33] <PerlJam> TimToady: don't you mean "True" or did that change again too?  :)

[15:33] <TimToady> True is a value; true is a function

[15:33] <PerlJam> oh

[15:33] <TimToady> and *that's* why True is uppercase.

[15:34] <PerlJam> maybe perl6 is like chinese then  :)

[15:34] <TimToady> I'm hoping to learn chinese one of these days.

[15:35] <TimToady> perl6 too.

[15:35] <rindolf> TimToady: heh heh.

[15:35] <rindolf> Well I'd better get back to my todo list.

[15:36] <rindolf> That or set my desktop wallpapers to the new ones.

[15:36] <TimToady> have the appropriate amount of fun.

[15:36] <PerlJam> The subtlties of pronunciation make chinese really hard for the western tongue  IMHO (I've only had a small exposure though)

[15:36] <rindolf> New major KDE version - new work - new backgrounds.

[15:37] <TimToady> learning a new phonological systems is difficult for anyone over the age of 2

[15:37] <IR7080> yep

[15:37] * PerlJam will never forget the anglo EE with chinese wife trying to explain the difference between two words that both sounded like "shi"

[15:38] <TimToady> if you happen to know what "retroflex" means, it becomes clearer.

[15:38] <TimToady> but the main problem is that you have a bunch of neurons hardwired to classify sounds,

[15:39] <TimToady> and those two sounds basically fall into the same recognizer if you're an english speaker

[15:39] <TimToady> just as Japanese have trouble distinguishing our r and l

[15:40] <TimToady> to do phonetics/phonology as a linguist, you have to figure out how to discount what your english recognizers are telling you, and listen to what's really there.

[15:40] <TimToady> in tagmemics this is called the etic/emic distinction.

[15:41] <PerlJam> interesting  ... that's like artists who have to make a mental effort to draw what they see rather than what they think they see.

[15:41] <TimToady> yes, very much so

[15:41] <TimToady> in fact, the training is similar

[15:41] <TimToady> an artist will turn a picture upside down, and copy it that way.

[15:42] <TimToady> to learn phonetics, you take tapes of random languages and just try to imitate them without trying to think of them as language.

[15:42] <TimToady> and then you try to figure out what you did with your mouth to make those sounds.

[15:42] <PerlJam> for some reason the aural analog to turning the picture upside down seems harder

[15:43] <PerlJam> must have something to do with the rather large chunk of my brain wired for sight

[15:43] <PerlJam> (vs. the smaller chunk wired for sound)

[15:43] <TimToady> It's temporally based--you have to do the imitation immediately without thinking about it.

[15:43] <rindolf> Wallpapers changed. :-)

[15:44] <rindolf> Now back to my todo list.

[15:44] <TimToady> some people just can't turn off the signal from their native phonological processor; they should not become phoneticists.

[15:44] <TimToady> I think it helps to be slightly autistic.

[15:44] * PerlJam waits for "Hearing on the Right Side of the Brain" to be published.

[15:45] <TimToady> also helps to be a musician, probably.

[15:45] <PerlJam> The human brain also seems to be wired to interpolate where ever it can.  This may make a good survival trait, but it sucks when trying to capture reality.

[15:45] <rindolf> PerlJam: free speech is a left-hemisphere function.

[15:46] <FurnaceBoy> I thought it was a Constitutional right!

[15:46] <TimToady> I'm more into free association.

[15:46] <FurnaceBoy> you're just a free radical.

[15:46] <rindolf> FurnaceBoy: I'm talking about freeform speech as opposed to singing and poetry.

[15:46] * PerlJam douses FurnaceBoy with anti-oxidants

[15:47] <TimToady> FurnaceBoy: then why don't I feel more charged up?

[15:47] <rindolf> FurnaceBoy: of course left-handed people have the left and right hemisphere switched.

[15:47] <TimToady> or just mixed up.

[15:47] <FurnaceBoy> ah... I never knew that.

[15:47] <FurnaceBoy> I knew there was SOMETHING up with them ;-)

[15:48] <TimToady> I think in general, some functions are switched and some arent'.

[15:48] * FurnaceBoy goes back to crashy USB driver...

[15:48] <FurnaceBoy> TT, that was interesting regarding learning to hear.

[15:48] <TimToady> but it's not a perfect swap.  reminds me of bidi pairs...

[15:48] <rindolf> TimToady: ambidextrous people have them mixed up.

[15:48] <FurnaceBoy> typographers also use the "page upside-down" trick.

[15:49] <PerlJam> my 4 month old twins are already showing signs of being right handed, but when my 4yr old son was their age he was quite ambidextrous and it's only recently that he's stopped using his left hand so much (except that I've been encouraging him to throw balls and things with his left hand lately)

[15:49] <FurnaceBoy> sometimes helps judging letterspacing. but you can train your eyes to see patterns instead of letters (takes time).

[15:50] <TimToady> the basic skill is to "relax" a part of your brain that wants to not relax.

[15:50] <FurnaceBoy> yes!!!!

[15:50] <FurnaceBoy> disengage.

[15:50] <FurnaceBoy> de-train.

[15:51] <TimToady> helps to be running an interpreter rather than a compiler.

[15:51] <FurnaceBoy> :-)

[15:51] <FurnaceBoy> raw input rather than cooked.

[15:52] <TimToady> "seeing what's really there" is a pervasive goal for me.

[15:52] <rindolf> PerlJam: Pete_I said he had to stop being ambi-dextrous so he can stop being dyslexic.

[15:52] <TimToady> it extends to things like "gee, this precedence table is screwed up"

[15:54] <TimToady> I'm pretty good at the disengaging.  I have more difficulty with the reengaging... :/

[15:54] <TimToady> I sort of hate making decisions.

[15:54] <TimToady> which is why sometimes when I do make decisions they seem like snap decisions.

[15:55] <TimToady> (because I know I don't dare hesitate)

[15:55] <TimToady> (and because I know I'll just disengage again later anyway).

[15:55] <TimToady> but it can certainly give the appearance of waffling.

[15:55] <PerlJam> that's me.  If I give myself time to waffle, I will and I won't be able to make a decision

[15:56] <TimToady> I think the trick for a language designer is to pay attention to the things people are carping about, and attempt to waffle on those.

[15:56] <TimToady> but you also have to pay attention to your own gut feelings occasionally.

[15:57] <TimToady> because people tend to carp about surface issues, and a designer has to get down to deeper issues

[15:58] <PerlJam> people typically only see the surface of the water bed, not what's beneath  :)

[15:58] <TimToady> It's funny, because in this case they're stuck on the etic side rather than the emic side.

[15:59] <TimToady> but the bikeshed hopefully contains a bicycle.

[15:59] <TimToady> I wonder if bikesheds attract tornadoes?

[16:00] *** gugod joined
[16:00] <TimToady> I also wonder if mobile homes attract asteroids, but it's hard to get a large enough statistical sample there...

[16:01] <TimToady> sorry, told you I was into free association...

[16:02] *** Ymmv joined
[16:03] <PerlJam> TimToady: as long as you limit your IRC activity to #perl6 and #parrotsketch, I will not despair of your free association  (Particularly stay away from #perl ;)

[16:05] *** pdcawley_ joined
[16:05] <particle_> bikesheds attract tornadoes with a force directly proportional to the product of their masses...

[16:05] *** pdcawley joined
[16:06] <TimToady> do you play a graviton on TV?

[16:07] <particle_> some days i do. want an autograph?

[16:07] <szbalint> Association is good. I do it all the time, mostly about obscure things...

[16:07] <TimToady> Heh, I'd love to see the signature of a graviton...

[16:07] <particle_> come closer :)

[16:08] <Limbic_Region> [TimToady] - it would spin you around in your seat (twice)

[16:08] <TimToady> More than that, if it's heavy enough.

[16:09] <TimToady> wouldn't it be funny if black holes came with integral spins...

[16:09] * Limbic_Region isn't sure if TimToady understood his joke or just knows more about the topic

[16:09] <TimToady> I suppose they must, at some level.

[16:09] <TimToady> Yes, I know gravitons are spin 2

[16:10] <Limbic_Region> apparently he just knows more about the topic

[16:10] <Limbic_Region> well - are predicted to have a spin of 2

[16:10] <TimToady> My oldest son is a quantum physicist.  How could I not?

[16:10] <Limbic_Region> oh really - cool beaners and moldy chicken

[16:10] <Limbic_Region> so does he go for 10 dimensions or 26?

[16:11] <TimToady> doesn't like string theory at all.

[16:11] <TimToady> likes quantum gravity.

[16:11] <particle_> that's so five minutes ago

[16:11] <TimToady> part of the reason he went to U Maryland is because they're, er, heavily into quantum gravity there.

[16:11] * particle_ is rereading 'a brief history of time'

[16:11] <PerlJam> It's hard to get excited about string theory (or M theory) until it makes some useful predictions.

[16:12] * Limbic_Region doesn't live to far away from U Maryland's main campus

[16:12] <TimToady> Aron lives in Silver Spring.

[16:13] <particle_> nice town. i have family there

[16:13] <Limbic_Region> wow - close.  Not as close as when I lived in Ellicott City but still pretty close

[16:13] <Limbic_Region> if I had ever gone to college - that's what I would have studied (if I had studied that is)

[16:14] <TimToady> yeah, I got one of them too... :/

[16:15] <PerlJam> Limbic_Region: There's nothing stopping you from being an autodidact :)

[16:15] <TimToady> he obviously is one.

[16:15] <TimToady> but you have to decide to be one at some point.

[16:16] <TimToady> my younger son is extremely bright, but hasn't learned to think yet...

[16:16] <particle_> there's no common law autodidact?

[16:16] <TimToady> maybe he's just a late bloomer like me...

[16:17] <PerlJam> well, L~R is an autodidact in a general sense, but why "would he have studied quantum gravity" (if he had studied) instead of "is studying" or whatever?

[16:17] * Limbic_Region intends to win the lottery so that he can audit classess he finds appealing without the necessary prerequisites and fund opensource and well um - play

[16:17] <PerlJam> TimToady: how old is he?

[16:18] <PerlJam> (your younger son)

[16:18] <TimToady> almost 17

[16:18] * particle_ wonders if lr plays the lottery

[16:18] <particle_> leaving home taught me to think

[16:18] <Limbic_Region> particle_ not as often as I should

[16:19] <PerlJam> TimToady: I've got 2 brothers, 26 and 28 who have yet to find their place in the world.

[16:19] <TimToady> well, hey, I'm still working on that myself... :)

[16:19] <particle_> your place is over there ==>

[16:20] <TimToady> and...

[16:20] <PerlJam> TimToady: you're firmly established as the perl6 language designer.  that's quite a good place to be (for you :)

[16:20] <particle_> <== don't forget over there

[16:20] <PerlJam> I would suck as a language designer.

[16:21] <TimToady> so do I, but I just try to suck less, I guess...

[16:21] <particle_> after how many years, and the language still isn't right? ;)

[16:22] <TimToady> It's like sending out a fleet of exploratory ships.  You know most of them are going to run aground, but you do it anyway.

[16:23] <Juerd> stevan: ?

[16:24] * PerlJam goes back to finding the code he was working on 3 weeks ago.

[16:24] * TimToady wanders off to run aground again...

[16:24] <PerlJam> (this is why I would suck as language designer.  I wrote a program but didn't stick it in svn and now I can't find it)

[16:25] <FurnaceBoy> :(

[16:26] <Juerd> PerlJam: We don't know how often TimToady designed Perl 6 before sticking it in version control ;)

[16:28] <TimToady> let me put it this way--I ran svn add for the first time yesterday.

[16:28] <rindolf> TimToady: seriously?

[16:29] <TimToady> all the design docs were put there by other people.

[16:29] * Juerd is impressed

[16:29] <TimToady> It's possible I've run it before and just forgot, but by and large, I don't initiate things like that.

[16:30] <TimToady> it's part of my personal disability not to initiate.

[16:30] <IR7080> how long do you guys think it will take to put perl6 out, a stable 6.0 ?

[16:30] <Juerd> IR7080: It'll probably be released somewhere around, or during, Christmas.

[16:30] <TimToady> when deja news first came out, merlyn did a scan of my old articles, and discovered that all but one of them were followups to someone else.

[16:30] <Juerd> TimToady: Haha :)

[16:30] <IR7080> excelent

[16:31] <Juerd> TimToady: And the one remaining post was the first announcement of Perl 1?

[16:31] <PerlJam> TimToady: I have a similar disease I think.

[16:31] <particle_> IR7080: he didn't say *which* christmas

[16:31] <Juerd> I *had* this disease, and somehow managed to get rid of it a few years ago.

[16:31] <TimToady> I think merlyn actually missed a few, but the pattern is definitely there.

[16:32] <PerlJam> IR7080: my personal opinion on the subject (and this changes over time, so ask me again in a couple of months) is that we will see the first alpha release of "the" perl6 compiler before the end of this year.

[16:32] <TimToady> It was a growth action for me to complain about morning on an IRC channel that nobody was talking on yet.

[16:32] <TimToady> I had to decide to do that.

[16:33] <particle_> pj: sure, you work with the guy writing it, no?

[16:33] <PerlJam> particle_: no, I don't work with pmichaud; not for 2 years or so now.

[16:33] <IR7080> let us hope he meant "this" christmas

[16:33] <particle_> ah, sorry

[16:33] <TimToady> "meaning" christmas doesn't help.  only working on it helps.

[16:33] <Juerd> PerlJam: Is than an opinion, or estimation, or assumption? :)

[16:34] <Juerd> PerlJam: Or just a wild guess :)

[16:34] <PerlJam> Juerd: SWAG :)

[16:34] <Juerd> What's that?

[16:34] <IR7080> http://www.google.com/search?q=define%3Aswag&sourceid=mozilla-search&start=0&start=0&ie=utf-8&oe=utf-8&client=mozilla&rls=org.mozilla:en-US:unofficial

[16:34] <PerlJam> Scientific Wild Ass Guess

[16:34] <IR7080> "Curtain window treatments that can be hung on a rod or attached to a mounting board"

[16:34] <TimToady> it'll be done sooner if you help, IR7080.  Would you like a commit bit?

[16:34] <IR7080> yeah,

[16:35] <IR7080> i was about to comit to the svn some changes, on the ... file

[16:35] <IR7080> yeah

[16:35] <PerlJam> TimToady: I'm not so sure of that assertion.  A certain book by Fred Brooks comes to mind  ;)

[16:35] <TimToady> this is not a late software project, by definition.  It'll be done when it's done.

[16:35] <stevan> Juerd: ??

[16:35] <Juerd> stevan: Ah, there you are :)

[16:35] <Juerd> stevan: You pinged me

[16:35] <IR7080> the best i can do is /maybe/ help on syntax errors made by the devs on the POD s

[16:36] <Juerd> stevan: Probably because I asked you :)

[16:36] <stevan> Juerd: yes, you were asking something about Roles

[16:36] <TimToady> you could write tests maybe

[16:36] <PerlJam> TimToady: It's all about perception.  There is a perception by the vast majority that perl6 is indeed late.  (man those people suck! ;)

[16:36] <Juerd> stevan: Indeed. Is there a good overview for end-users?

[16:36] <stevan> Juerd: not really, not at the moment anyway

[16:36] <Juerd> stevan: Of how to choose between class and role, and maybe a design best practice?

[16:36] <Juerd> stevan: Hm - that's very unfortunate :)

[16:37] <rindolf> stevan: is DBIx::Class going to be based on Moose?

[16:37] <stevan> Juerd: I think the basic assumption goes something like this:

[16:37] <Juerd> I'm doing a talk about Perl 6 OO tomorrow, and expect this question from the audience if I don't come up with the answer first

[16:37] <stevan> if you were thinking of using a mixin, java-style-interface, abstract-base-class

[16:37] <stevan> then use a role

[16:37] <PerlJam> stevan: that begs the question: why *wouldn't* I use a mixin, etc. ?

[16:38] <Juerd> I was about to say that...

[16:38] <stevan> rindolf: mst has been talking about using Moose with DBIx::Class yes, but not sure how planned that is

[16:38] <TimToady> because those are all degenerate cases of role

[16:38] <PerlJam> Juerd: I know, I'm trying to help you out :)

[16:38] <stevan> PerlJam: a role is a mixin which can do some conflict checking

[16:38] <Juerd> Also: why roles, not multiple inheritance?

[16:38] <stevan> TimToady: exactly :)

[16:38] <stevan> Juerd: you can use MI too, but MI gets messy after a while

[16:39] <Juerd> I don't get what "degenerate case" means

[16:39] <stevan> when you use roles instead, you get the method conflict resolution

[16:39] <Juerd> stevan: Do you happen to have examples?

[16:39] <stevan> Juerd: No, but what kind of examples are you looking for? I can maybe make some up

[16:40] <Juerd> stevan: An example of how something would be implemented with, and how it would be implemented without roles. Something that shows they're not just theoretical fluff.

[16:40] <stevan> yes, let me whip up a few

[16:40] <PerlJam> stevan, Juerd; a tutorial on roles would make a good article for perl.com  :)

[16:40] <Juerd> stevan: That would be great. Thanks :)

[16:40] <Juerd> PerlJam: Indeed; I could certainly use one :)

[16:40] <TimToady> that's hard, given that the whole point of roles is to represent theoretical fluff.  :)

[16:40] <Juerd> Have I shown my spooky photo, by the way? http://photo.juerd.nl/verkeer/zeedijk.jpg

[16:41] <Juerd> TimToady: ... :)

[16:41] <Juerd> It was very windy, and I couldn't hold my camera stable enough.

[16:42] <Juerd> I'm going to try again soon.

[16:42] <TimToady> motorcycle?

[16:42] <TimToady> or burned out headlight?

[16:42] <Juerd> Normal headlight, as far as I know

[16:42] <TimToady> the shadows aren't doubled...

[16:42] <Juerd> The beams don't cross close to the car

[16:43] <TimToady> or did you use a flash?

[16:43] <Juerd> And the second shadows would often fall besides the tree

[16:43] <Juerd> No, these are headlights

[16:43] <Juerd> High beam

[16:43] * Juerd goes outside to check if they still both work

[16:43] <TimToady> how close together?

[16:43] <Juerd> afk

[16:44] * PerlJam assumes Juerd is going to measure the distance now  :)

[16:45] * particle_ calculates the resolving power

[16:45] <TimToady> I think he was standing in front of the car blocking the cross lighting.

[16:46] <particle_> no human shadow

[16:46] <TimToady> but I think I see a doubled shadow on the 4th tree from the right.

[16:46] <pasteling> "stevan" at 71.234.63.100 pasted "Classic Equality Role" (19 lines, 288B) at http://sial.org/pbot/17223

[16:46] <PerlJam> TimToady: He's standing in the cone of darkness between the lights.  And the shadows do look doubled in the trees that are further out.

[16:46] <particle_> i think that's flowers & pole, not double shadow

[16:46] <PerlJam> it's hard to tell though

[16:46] *** sri_ joined
[16:47] <stevan> Juerd: this is a very common example given for things like roles

[16:47] <stevan> in Ruby it would be a mixin, in Eiffell it is deferred class

[16:47] <TimToady> but the line of the shadows shows that the right light is to the right of the observer while the left light is to the left of the observer.

[16:47] <Juerd> 1 m

[16:47] <TimToady> so it has to be two lights.

[16:47] <Juerd> stevan: Thank you much. I'll look at it in a minute

[16:47] <TimToady> just with little crossover.

[16:48] <TimToady> 1 m is pretty close together.

[16:48] <stevan> TimToady: could you please make sure I am correct on the syntax, I have been a little out of the loop lately

[16:48] <PerlJam> stevan: do you have a non-parameterized example?

[16:48] <stevan> PerlJam: the parameter in there just makes not_equal_to type safe

[16:48] <stevan> you could remove it and it would do the same

[16:48] <Juerd> TimToady: We have normal sized cars.

[16:48] <PerlJam> Juerd: for europe :)

[16:49] * particle_ thought juerd might be a shriner

[16:49] <pasteling> "stevan" at 71.234.63.100 pasted "Classic Equality Role (no parameters)" (18 lines, 272B) at http://sial.org/pbot/17224

[16:49] <Juerd> 1m is the distance between the centres of the lights

[16:49] <PerlJam> Juerd: are you sure it's not a motorcycle?  :)

[16:49] <Juerd> I am :)

[16:50] <PerlJam> I'm in Texas, so apply  the usual stereotypes :)

[16:50] <stevan> the stars at night, are big and bright!

[16:50] * stevan reminds PerlJam he must complete the song by law

[16:50] <PerlJam> heh

[16:50] <stevan> they will fry you if you dont

[16:51] <PerlJam> Bush isn't governor anymore!

[16:51] <Juerd> http://photo.juerd.nl/tmp/headlights.jpg

[16:51] <TimToady> you have to use {...} to stub a method.

[16:51] <Juerd> Now I'm going to read stevan's examples :)

[16:52] <TimToady> and a type parameter would be ::T

[16:52] <stevan> ok

[16:52] <TimToady> then you can use as bare T within the scope.

[16:52] <Juerd> stevan: Ahh - this is also the first time I understand how parameters are useful :)

[16:53] <stevan> Juerd: cool :)

[16:53] <Juerd> TimToady: I was indeed in between the lights

[16:53] <wolverian> Juerd, your subs haven't taken any parameters before? :)

[16:53] <Juerd> wolverian: My classes never have, and I've never had roles.

[16:53] <pasteling> "stevan" at 71.234.63.100 pasted "Basic plugin example" (21 lines, 287B) at http://sial.org/pbot/17225

[16:53] <stevan> Juerd: this is how you might use Roles for "plugins"

[16:53] *** m__ joined
[16:54] <stevan> currently people usually do mixins (liek CGI::App) and MI (like Catalyst) for plugins

[16:54] <Juerd> stevan: What's App::Base's function?

[16:54] <stevan> but roles will actually be a much safer way to compose with plugins

[16:54] *** weinig joined
[16:54] <stevan> Juerd: think of it as a base class for all applications maybe

[16:54] <Juerd> stevan: Does App::Logger, or My::App lack an "is App::Base"?

[16:55] <stevan> oh yes,.. sorry

[16:55] <stevan> class My::App is App::Base does App::Logger {}

[16:55] <Juerd> Hm, so a single class can do several roles, that each define equally named methods?

[16:55] <stevan> no

[16:56] <Juerd> So another role couldn't provide another &run?

[16:56] <particle_> app::base is meant to be an abstract base class?

[16:56] <stevan> if you combine several roles, and there is a name conflict, then the composition fails

[16:56] <particle_> oh, i see

[16:56] <stevan> particle_: kind of, but it's abstractness is mostly there because I couldnt come up with something for it to do :)

[16:56] <Juerd> stevan: Then I don't understand why roles are useful for plugins, in this example.

[16:57] <particle_> a method needs to be defined in a class before it can be defined in a role

[16:57] <stevan> The App::Logger::run will be called if you did My::App.run()

[16:57] <Juerd> particle_: That'd be... very redundant :|

[16:57] *** Qiang joined
[16:57] <wolverian> particle_, no.

[16:57] <stevan> particle_: in this example yes, only because i use next METHOD within the Role

[16:57] <Juerd> stevan: And "next METHOD" calls App::Base::run?

[16:57] <particle_> right.

[16:57] <stevan> Juerd: yes

[16:58] <Juerd> stevan: Seems useless for plugins, to be honest, if two plugins can't use the same hook.

[16:58] <stevan> Juerd: I agree, this is why I added method-modifiers to Moose

[16:58] <TimToady> could if they were declared multi, I think.

[16:58] <stevan> TimToady: but they wouldnt all be called though

[16:59] <stevan> it just wouldnt fail in the composition

[16:59] <TimToady> next METHOD is defined to work with multis too.

[16:59] <stevan> oh yes

[16:59] <stevan> very try

[16:59] <stevan> true

[16:59] <stevan> TimToady: but wont that impose some kind of ordering on the role composition?

[17:00] <stevan> which one is called first?

[17:00] <TimToady> multis are ordered by type.

[17:00] * stevan ran into this in Moose, but decided it was a feature :)

[17:00] <TimToady> if they're the same type

[17:00] <TimToady> then you have a tie

[17:00] <TimToady> but you could still call them all with .* and then do last METHOD to stop.

[17:00] <stevan> yup

[17:01] <TimToady> it's just that would take the collusion of the class.

[17:01] <TimToady> it might be something better handled with wrappers.

[17:01] * particle_ points to qpsmtpd

[17:01] <stevan> yes, this puts an aweful lot of burden on the plugin developer

[17:02] <stevan> Juerd: well, maybe the plugin example is not so good

[17:02] <TimToady> I'm not sure plugins are going to be the best use-case for roles

[17:02] <TimToady> that's very much in the realm of mixins.

[17:03] <Juerd> I was thinking an array with .? would be better :)

[17:03] <TimToady> and when you mixin, you get hiding rather than collisoins.

[17:03] <stevan> TimToady: they are working pretty well in Moose with the before/after/around method modifiers as well as inner() and super() calls

[17:03] <TimToady> and next METHOD would work fine.

[17:03] <TimToady> before/after/around *is* wrapping

[17:03] <stevan> yes exactly :)

[17:03] <Juerd> stevan: But - I think the logger example also isn't really great

[17:03] <stevan> but they can be composed

[17:03] <TimToady> but in P6 you probably just want .wrap

[17:03] <Juerd> stevan: I'd want multiple things to wrap around run...

[17:03] <stevan> TimToady: yes

[17:04] <stevan> Juerd: yes, I agree, not the best example

[17:04] * particle_ turns on the two turntables

[17:04] <Juerd> So, to summarize: I still don't understand why roles are useful

[17:04] * stevan waves his hands in the air,... like he just doesnt care

[17:04] <TimToady> well, have you read the traits paper?

[17:04] <Juerd> No

[17:05] <stevan> Juerd: They are also good for Java-style interfaces

[17:05] <TimToady> that would be a good place to start, I think.

[17:05] <Juerd> I lack knowledge outside Perl...

[17:05] <TimToady> What makes you think I know Smalltalk?

[17:05] <Juerd> I had no idea I was implying that.

[17:05] <stevan> Juerd: an interface just defines a set of methods and a name

[17:06] <stevan> then you class "implements" the interface by providing actual code for those methods

[17:06] <Juerd> stevan: But a role's method gets precedence over the outer class's

[17:06] <Juerd> stevan: Would the role have "next METHOD" in each method?

[17:06] <stevan> then you can treat instances of that class as if they were that interface ,.. regardless of the class they actually come from

[17:07] <TimToady> Juerd: no, the class's method takes precedence.

[17:07] <stevan> the local class to be more specific

[17:07] <Juerd> TimToady: Oh - then I don't get stevan's first example anymore :)

[17:07] <stevan> class beats role, role beats superclass

[17:07] <Juerd> As then the role's run wouldn't be used...

[17:07] <Juerd> .oO( and this is supposed to make programming *easier*? )

[17:07] <stevan> no, harder

[17:07] <stevan> :P

[17:07] <Juerd> Why?

[17:07] <stevan> just kidding

[17:08] <particle_> scissors cuts paper

[17:08] <stevan> roles are hard to see the usefulness until you really start actually using them

[17:08] <Juerd> Nobody seems to have good examples of exactly when and why it's useful, and its complexity is off my chart...

[17:08] <TimToady> read the Traits paper.

[17:08] <Juerd> stevan: Has anyone used them?

[17:08] <stevan> Juerd: they are better in complex situations actually

[17:08] <stevan> Juerd: nothingmuch has done a fair amount of playing with them in perl 6 and Moose

[17:09] <stevan> I have been using them in Moose (as plugins :P)

[17:09] <Juerd> Then perhaps I'm better off asking nothingmuch?

[17:09] <stevan> there are a few papers out there about refactoring the Smalltalk collection heirarchy and Java.IO package using traits

[17:09] <Juerd> TimToady: I might, if I can find the time in between now and tomorrow morning.

[17:09] <Juerd> stevan: Are traits the same thing as roles?

[17:09] <stevan> Juerd: basically yes, but traits have a few more features

[17:10] <Juerd> Are these traits the same traits as Perl 6's traits?

[17:10] *** bpederse joined
[17:10] <TimToady> no

[17:10] <stevan> I honestly think it will take a little while before we discover the true usefulness of traits/roles

[17:11] <stevan> people need to start using them in real-world designs

[17:11] <Juerd> stevan: ... (!)

[17:11] <Juerd> They need to start using them without any idea, without any guidelines, without concrete thoughts...

[17:11] <stevan> Juerd: no, when you start using them,.. you start thinking in roles more

[17:12] <stevan> and as more and more people use them, it will become more clear where they fit in

[17:12] <Juerd> I wonder if the wheel was invented like it. "Nice, shiny, geometrically correct. What is it?" "I call it... the wheel" "I see - and how do you use it?" "I haven't quite figured that out yet, but in a few centuries from now, all cars will have several of these." "What's a car?" "I have no idea."

[17:13] <stevan> I doubt the inventors of OO knew exactly where it would be best used

[17:13] <stevan> Juerd: exactly!

[17:14] <particle_> traits are a form of polymorphism which allows a SI hierarchy, and also allows subclasses to have different behavior from their superclasses

[17:14] <Juerd> Doesn't really make me enthusiastic about it.

[17:14] <TimToady> MMD is defined in terms of roles, not classes.

[17:14] <stevan> they are much more exciting in a SI language

[17:15] <Juerd> I think I'll just ignore roles for now.

[17:15] <TimToady> it lets you finesse the difference between named typing and duck typing

[17:15] <Juerd> And try to fill 45 minutes with other stuff, and then say "I was going to discuss roles too, but I'm out of time. Maybe next year!"

[17:15] <Juerd> :)

[17:15] <stevan> :)

[17:16] *** fglock joined
[17:16] * stevan .does(Lunch)

[17:17] <Juerd> Well, that's a good example.

[17:17] <Juerd> You !isa Lunch, you do Lunch.

[17:17] <Juerd> Can't really relate that to technical stuff, though...

[17:17] *** penk joined
[17:17] <TimToady> let's hope Stevan.handles(Lunch)

[17:17] <stevan> sandwich.does(Consumable)

[17:18] <Juerd> Why *does*, not *is" consumable?

[17:18] <TimToady> they really are for doing type analysis without commitment to objecthood.

[17:18] <stevan> pizza.does(Consumable)

[17:18] <Juerd> TimToady: Care to explain that?

[17:18] <stevan> Juerd: to avoid making the commitement of a Consumable base class which all my foodstuff inherits from

[17:19] <Juerd> stevan: And that's needed, or useful, because...?

[17:19] <TimToady> this is all explained in the Traits paper in much better detail...

[17:19] <stevan> Juerd: also please see the paper on refactoring the smalltalk collection hierarchy

[17:19] <TimToady> the basic problem is that classes are used for two completely different things

[17:19] <stevan> they demonstate that composing with roles saves many unneeded methods

[17:20] <TimToady> 1) managing the creation and destruction of objects

[17:20] <TimToady> 2) type specification

[17:20] <stevan> Juerd: see http://www.iam.unibe.ch/~scg/Research/Traits/ (1st and 3rd papers in the list)

[17:20] <Juerd> The problem is that these papers are lots of reading, and I have approx. 3 hours.

[17:21] <stevan> no, you have 365 days + 3 hours ;)

[17:21] <Juerd> I didn't really expect to have to do this much research for this talk, so I didn't schedule any time for it.

[17:21] <TimToady> just think, there's really no such thing as an abstract class.

[17:21] <Juerd> I sort of assumed that if so much effort was put into it, there'd be some (Perl 6) documentation, and examples, about it.

[17:21] <TimToady> a class is about real objects.  roles are about abstractions.

[17:21] <Juerd> TimToady: That is nice

[17:22] <Juerd> TimToady: And understandable. I wish I could think of a way how that'd work, though.

[17:23] <Juerd> Maybe I've just done class OO too much...

[17:23] <TimToady> when you want to do type reasoning, you don't really care what the composition of an object is, you only care what interfaces it supports.

[17:23] <TimToady> roles can be thought of as mere interfaces with some default implementation for handiness.

[17:23] <particle_> .print()

[17:24] <TimToady> and a bit of generic instantiation thrown in for good measure.

[17:24] <Juerd> TimToady: I know inheritance can be used for this, and often is. There probably is some negative side about inheritance that I don't get yet.

[17:24] <TimToady> Roles are actually a unification of several things in the Comp Sci field that a language would otherwise have to incorporate separately.

[17:24] <TimToady> see C++, for instance.

[17:25] *** ruoso joined
[17:25] <TimToady> yes, like diamond inheritance.  roles solves that.

[17:26] <Juerd> Fsck; have to go.

[17:26] <PerlJam> TimToady: So would macros though; what makes roles special?   (still trying to help Juerd :)

[17:26] *** [BlueT_at_Mars] is now known as BlueT_at_Mars

[17:27] <TimToady> ciao.

[17:27] <Juerd> Please pretend I'm still here, and talk to me; I'll read everything when I'm back (as little sense as that makes if I'm still here)

[17:27] <Juerd> afk

[17:27] <TimToady> roles can be thought of as a funny way to write macros

[17:28] <TimToady> all generics are sorta-macros

[17:28] <PerlJam> macros don't do conflict resolution though

[17:28] <TimToady> roles try to be particularly hygienic with respect to typology

[17:28] <TimToady> these macros do.  :)

[17:29] <PerlJam> roles give you finer control over conflict resolution rather than always bailing out.

[17:29] <TimToady> they're more like declarative macros than imperative though.

[17:30] <TimToady> so in that sense "does" is more like "use".

[17:30] <TimToady> you request the interface, and some implementation comes along for the ride.

[17:30] <kolibrie> could something like serialization be written as a role?  any object could do the roles YAML, XML, Perl?

[17:31] <TimToady> certainly.

[17:31] <particle_> you'd probably want to use templates for that, too

[17:31] <particle_> for the roles, that is

[17:31] <PerlJam> To me roles are what "types" should be and classes are just heavy weight versions  :)

[17:32] *** ludan joined
[17:32] <TimToady> classes are roles that happen to have working constructors.  :)

[17:33] <kolibrie> so really almost everything should be written as a role?

[17:33] <TimToady> but yes, roles are the real "types" in Perl 6.

[17:33] <ludan> hi

[17:33] <TimToady> don't go off the deep end.

[17:34] <TimToady> as long as a class can be used as a role, it doesn't much matter

[17:34] <PerlJam> kolibrie: while you can probably write everything as a role, it is unadvisavle to do so  :)

[17:34] * pmichaud has trouble lexing "unadvisavle"

[17:34] <PerlJam> kolibrie: roles are just a tool to be used like any other.

[17:34] <pmichaud> looks too weird

[17:35] * kolibrie wants to know, like Juerd, when roles are the right tool, and when not

[17:35] <TimToady> if it's natural to write a type as a class or a subset or an enum, by all means do it that way.  all of these can be used for type matching.

[17:36] <PerlJam> kolibrie: Do as oft happens in the world of programming languages: implement everything under the sun using roles.  Eventually you'll figure out where you should have used something else :)

[17:36] <pmichaud> there's more than one ONE way to do it :-)

[17:36] <TimToady> inheritance has to be good for something...

[17:37] <FurnaceBoy> blue eyes

[17:37] <FurnaceBoy> dimples

[17:37] <FurnaceBoy> baldness

[17:37] <pmichaud> estate taxes

[17:38] <kolibrie> I often think of roles as a way to add functionality to a bunch of unrelated classes

[17:38] <TimToady> but, in fact, what OO calls inheritance has very little to do with real inheritance.

[17:38] <TimToady> a proto based language like Self is much closer, where everything is just a clone of its parents.

[17:38] <pmichaud> ah, I remember Self

[17:39] <TimToady> that's another language I don't know that I know all about... :)

[17:39] <pmichaud> I'm in the same boat.  It was a big topic at OOPSLA '87

[17:39] <pmichaud> but I was busy at DisneyWorld

[17:42] <TimToady> I think inheritance is a beautiful match to derived grammars, because both the base grammar and the derived grammar are real objects.

[17:42] <TimToady> but that's because grammars are rather platonic.

[17:43] <TimToady> most of world is aristotelian, however.

[17:43] <TimToady> inheritance is lousy at modelling gene pools.

[17:44] <TimToady> "What would my great-great-great-great-grandpappy do?

[17:45] *** trym joined
[17:46] <TimToady> Inheritance also only works well for computers with central CPUs where everyone can see the same class definitions.

[17:46] *** larsen joined
[17:46] <TimToady> As we move toward distributed computing, type information gets distributed more like a gene pools info.

[17:47] <TimToady> *pool's

[17:47] <TimToady> and every object needs to carry around its own DNA, not ask its great-great-grandparent what to do.

[17:48] <TimToady> It scales, as long as there's enough sex.

[17:49] <FurnaceBoy> If I had a dollar...

[17:50] <PerlJam> TimToady: or a suitable source of mutations :)

[17:50] * FurnaceBoy curses ECC!

[17:51] *** DaGo joined
[17:52] <TimToady> I've spent long enough sitting cross-legged on this mountain.  Need to go primp for work...

[17:55] <TimToady> PerlJam: I first read that as "munitions", which also have an effect on the gene pool...

[17:55] <TimToady> &

[17:55] *** penk joined
[17:55] <PerlJam> I bet if all of the perl6 naysayers spent some time on #parrot and #perl6, they'd see that there is some progress being made and so wouldn't say so much nay.

[17:56] <PerlJam> I wonder if it would be useful to have a this-week-in-#parrot-or-#perl6 web page

[17:56] <ruoso> PerlJam, it would be really nicee

[17:56] <ruoso> PerlJam, I'm not having time to read the logs myself...

[17:56] <kolibrie> naysayers like saying nay.  builders like building.

[17:56] * pmichaud volunteers PerlJam

[17:57] <PerlJam> pmichaud: But then I'd have to pay attention to what's going on rather than just dropping into the middle of things like I normally do

[17:58] <pmichaud> or just log the channel and summarize it afterwards :-)

[17:58] <PerlJam> maybe just summarizing the svn logs would be enough.

[17:58] <pmichaud> that would be interesting (and possibly very useful)

[17:58] <PerlJam> this week on #perl6/#parrot:   stuff changed.  radically.  :-)

[17:58] <pmichaud> we just need the "radical change index"

[17:58] <pmichaud> "how much did things change this week?"

[17:59] *** elmex joined
[17:59] <ruoso> "what you thought you had to learn last week that is dead this week"

[17:59] <PerlJam> Hmm.  Summarizing the log wouldn't be enough since TimToady occasionally sneaks conjectural stuff in with out putting it in the log message (or marking it as conjectural in the document :)

[17:59] *** bernhard joined
[18:00] <FurnaceBoy> just label ALL his commits.

[18:00] <FurnaceBoy> coloured background.

[18:00] <ruoso> heh

[18:01] <pmichaud> one could claim that most everything here is conjectural :-)

[18:01] <ruoso> pmichaud++

[18:02] <PerlJam> change per unit time is easy enough to generate, the problem is perceiving that change as progress.  How do you know that things are moving towards a goal?

[18:05] * particle_ moves the goalpost yet again

[18:18] *** aufrank joined
[18:27] *** FurnaceBoy_ joined
[18:27] *** rashakil joined
[18:48] <Juerd> Why have both roles and classes? Would having only roles not suffice?

[18:49] <Juerd> (If they could instantiate)

[18:50] <Juerd> PerlJam: I bet if some of the perl6 naysayers spent time here, there'd be some serious discussion about roles on slashdot :)

[18:51] *** justatheory joined
[18:57] <Juerd> nothingmuch: pingishness

[18:58] <particle_> juerd: tmtowtdi

[18:59] <particle_> if you want an SI model with roles, use it.

[18:59] <particle_> if you want a MI model with classes, use it.

[19:02] <Juerd> Sure, but adding stuff just to add more ways to do it is a bad idea.

[19:02] <Juerd> That's PHP's approach :)

[19:02] <Juerd> I like my programming language properly abstracted.

[19:03] <particle_> well then... sometimes, roles are the proper abstraction

[19:03] <Juerd> Sigh.

[19:03] <Juerd> This is so circular.

[19:03] <particle_> :)

[19:03] <Juerd> self-referential, recursive, etc.

[19:03] <particle_> qwhine? ;)

[19:04] <Juerd> Let me put it differently: what are the benefits of inheritance compared to composition?

[19:04] <Juerd> Why do we need inheritance, ignoring backwards and cultural compatibility?

[19:05] <merlyn> if all you have is composition, you need an easy way to show delegation

[19:06] <merlyn> I imagine you can prove that inheritance is nothing more than good delegation onto a composite

[19:06] <merlyn> but I'm not smart enough to figure out the difference

[19:06] *** justathe1ry joined
[19:07] *** weinig is now known as weinig|away

[19:11] <Juerd> merlyn: Can you explain what you mean with delegation?

[19:11] * Juerd can't really parse it with the definition he knows

[19:11] <merlyn> $myobject.some_method gets sent to $myobject.some_attribute.some_method

[19:11] <merlyn> so you can build up a "car" from an "engine" and "wheels" and "gas tank"

[19:12] <merlyn> wait, ignore that example

[19:12] <ruoso> Juerd, rules can be applied to instances, while inheritance refers only to classes?

[19:13] <Juerd> merlyn: So it was the same definition.

[19:13] <Juerd> merlyn: I don't understand the relation between inheritance and delegation

[19:13] <Juerd> A role can also has $.foo handles <bar baz>

[19:13] <merlyn> if I can't inherit from my superclass, I'll have to compose an object of that superclass, and delegate all methods to it

[19:14] <Juerd> ruoso: s/rules/roles/, I guess, and then I still don't get the point :)

[19:14] <ruoso> Juerd, sorry... it's roles, indeed...

[19:14] <Juerd> merlyn: Why would you have to delegate?

[19:14] <merlyn> to get my ->foo to really be my parent's -.foo

[19:14] <merlyn> darn it, using p5 syntax. :)

[19:15] <Juerd> merlyn: There's no parent, but you already get the role's foo if you call foo on $bar, where $bar does the role that has foo.

[19:15] * Juerd rereads that

[19:15] * Juerd hopes merlyn can parse it :)

[19:16] <ruoso> inheritance is a type of role, isn't it?

[19:16] *** gdickie joined
[19:17] * stevan points out that we all how our roles to play on this great stage of life

[19:17] <stevan> Juerd: I think merlyn is talking about prototype style OO

[19:18] <stevan> in prototype OO, if a method fails to resolve to a local definition, it tries passes the call onto it's prototype

[19:18] <stevan> which is basically delegation

[19:19] <stevan> because the prototype-slot is really just another slot

[19:19] <stevan> it just has special meaning during method dispatch

[19:20] <Juerd> But Perl 6 doesn't do that, right?

[19:20] <stevan> Juerd: no, Perl 6 does not have Prototype based OO

[19:20] <stevan> at least not by default ;)

[19:21] <Juerd> if Foo does Bar, and Bar does Quux, and they all have a method xyzzy, will composition then fail?

[19:22] <stevan> not nessecarily

[19:22] <Juerd> Depending on?

[19:22] <stevan> Bar.xyzzy can override Quux.xyzzy

[19:22] <stevan> and Foo.xyzzy can override Bar.xyzzy

[19:22] <stevan> however

[19:23] <stevan> if you had Baz, which has a method .xyzzy

[19:23] <stevan> and you did Foo does Bar does Baz

[19:23] <stevan> it would fail

[19:23] <Juerd> Okay

[19:23] <stevan> because the Baz.xyzzy and Bar.xyzzy would conflict

[19:23] <stevan> only when you compose one or more roles will it possibly conflict

[19:24] <Juerd> So - roles/composition can be used in all sane cases of classes/inheritance, with the added benefit of getting a clear error message up front if you try to "inherit" from two classes that both claim a certain method name? (ignoring MMD)

[19:24] <stevan> yes

[19:24] <Juerd> Why the h*ck still have classes, then?

[19:25] <stevan> in that sense, it can make MI easier to manage

[19:25] <Juerd> It's safer for MI, practically equal for SI.

[19:25] <stevan> because classes deal with the allocation/initialization of instances

[19:25] <particle_> btw, if you're going to compose with more than one role, you can specify methods to exclude, so there's no conflict

[19:25] <Juerd> stevan: But why don't roles?

[19:25] *** penk joined
[19:25] <stevan> particle_: no, that is traits

[19:25] <stevan> Juerd: because then if Roles do that,.. you are back at classes again,.. as if you never left

[19:25] <particle_> oh. rats.

[19:26] <Juerd> stevan: Which is back, because?

[19:26] <Juerd> stevan: Which is bad, because?

[19:26] <Juerd> I guess I'm asking: what do roles give us except protection against name clashes...

[19:27] <Juerd> Why not abstract these two things into one thing

[19:27] <ruoso> Juerd, you can use roles to compose classes or instances

[19:27] <Juerd> So you only have to learn one thing (which is a HUGE benefit)

[19:27] <ruoso> but you must use a class to get an instance

[19:27] <stevan> Juerd: decoupling the more mundane details for things like instance allocation/intialization and method dispatch and other lower level class things from the more abstract idea of "types" and "behaviors"

[19:27] <Juerd> ruoso: That's not an explanation...

[19:28] <Juerd> stevan: Why is this decoupling needed or useful?

[19:28] <stevan> Juerd: regular OO says "a Class is a Type"

[19:28] <Juerd> Perl has never ever done "regular OO"

[19:28] <Juerd> And probably never will.

[19:28] <stevan> Foo $foo = Foo.new();

[19:28] <Juerd> It has had "classes" without having classes. packages sufficed.

[19:28] <stevan> Juerd: Perl's OO is regular enough for this

[19:29] <stevan> Juerd: lets stick with idiomatic Perl 5 OO for the moment

[19:29] <Juerd> Why do types matter?

[19:29] <Juerd> All I care about, when I'm about to call $foo.bar, if $foo.can('bar').

[19:29] <stevan> because $foo->isa(Foo)

[19:29] <stevan> then you are duck typing

[19:29] <Juerd> I might sometimes want to know if something does a certain interface

[19:29] <stevan> yes

[19:30] <stevan> then you want roles

[19:30] <Juerd> But why would I be interested in is-a relations, ever?

[19:30] <stevan> $foo.does(Bar)

[19:30] <stevan> Juerd: you may not be, but that is not how everyone views it

[19:30] <Juerd> Why would <someone> be ...

[19:30] <Juerd> :)

[19:30] <stevan> some people place more importance on isa than others

[19:30] <Juerd> Why do they?

[19:30] <Juerd> What are their arguments, besides being used to isa/typeof

[19:30] <stevan> dunno,.. gotta ask one

[19:30] <stevan> :)

[19:31] <stevan> Well, to be honest in a dynamic language like Perl/Ruby/Python it is less of an issues

[19:31] <stevan> we have duck typing

[19:31] <Juerd> What's duck typing again?

[19:31] <stevan> if it quacks(),.. its a Duck

[19:31] <stevan> rather than $donald.isa(Duck)

[19:32] <stevan> it is what you said,.. $donald.can(quack)

[19:32] <stevan> then you know donald is a Duck

[19:32] *** ruz joined
[19:32] <stevan> but in more static langauges, the isa() relations are more important during compile time

[19:33] <stevan> but being stuck within the confines of isa() type relationships is no good

[19:33] <stevan> not everything fits into that type of model

[19:33] <Juerd> I understand why roles are more useful, I think

[19:33] <ingy> `_`

[19:33] <Juerd> I don't yet understand why classes are still needed.

[19:34] <stevan> because if we didnt have classes, roles would have nothing to compose into ;)

[19:34] <Juerd> It seems to me that roles can do everything that classes can (but with different semantics and names, but I fail to find relevance)

[19:34] <Juerd> If roles had constructors, you wouldn't need to.

[19:34] <stevan> well

[19:35] <stevan> then you end up with some not-so-general roles

[19:35] <ruoso> Juerd, isa relations are important in modeling also

[19:35] <Juerd> ruoso: Why?

[19:35] <Juerd> ruoso: And wouldn't does relations suffice?

[19:35] <stevan> Roles work well in the very abstract parts of a model

[19:35] <particle_> class attributes, attribute inheritance?

[19:35] <stevan> then you can get specific in classes

[19:35] <ruoso> what makes more sense: Duck does Animal? or Duck isa Animal?

[19:36] <nothingmuch> Juerd: pong

[19:36] <nothingmuch> note: i'm sick - i'm zoning out, but i will still backlog

[19:36] <nothingmuch> so you can /msg

[19:36] <Juerd> nothingmuch: Oh, if you're sick, I won't bother you. Nevermind.

[19:36] <nothingmuch> sick == bored but incapacitated

[19:36] <Juerd> particle_: No different in roles

[19:37] <nothingmuch> so i'm actually potentially interested, as long as it's not too hard ;-)

[19:37] <gdickie> It might be useful to have roles which provide constructors: does ConstructFromFileByDeserialize, does ConstructFromHash

[19:37] <stevan> ah Juerd I found a good example

[19:37] <Juerd> nothingmuch: I'm seeking knowledge re classes versus roles. Especially, when does one use classes instead of roles. And whether inheritance is still needed for anything.

[19:38] <Juerd> nothingmuch: Word has that you've already played with roles, and are probably the most knowledgeable about them now

[19:38] <nothingmuch> my rule of thumb has been (so far) that if it makes Liskov happy then it's inheritence

[19:38] <nothingmuch> but anything else should default to roles

[19:38] <nothingmuch> and

[19:38] <nothingmuch> it's been working for me

[19:38] <Juerd> Liskov?

[19:39] <nothingmuch> one sec, wikipedia link

[19:40] <aufrank> stevan: example coming?

[19:40] <nothingmuch> http://en.wikipedia.org/wiki/Liskov_substitution_principle

[19:40] <stevan> aufrank: yes

[19:40] <nothingmuch> i don't agree that the Liskov substitution principal always be in place

[19:41] <nothingmuch> i much prefer duck typing

[19:41] <nothingmuch> roles let you have the benefits of ducktyping with some formalism thrown in

[19:41] <nothingmuch> and they are much safer to both cherry pick, and add everything but the kitchen sink

[19:41] <PerlJam> Juerd: by tomorrow you'll be an expert in all of this, right?  ;)

[19:41] <nothingmuch> two extremes that MI is not very good for

[19:42] <Juerd> nothingmuch: I wish I understood that article. It's over my head

[19:42] <nothingmuch> it's really quite simple:

[19:42] <Juerd> PerlJam: By tomorrow I'll be dead.

[19:42] <nothingmuch> any code that has code

[19:42] <nothingmuch> err

[19:42] <nothingmuch> sorry, (i'm sick ;-)

[19:43] <PerlJam> Juerd: basically liskov says that derived classes can be used anywhere superclasses can

[19:43] <nothingmuch> any code that has a variable/whatever containing calls that assume a certain class is being acted on

[19:43] <nothingmuch> like $uri->host; $uri->schema;

[19:43] *** elmex joined
[19:43] <nothingmuch> should always be 100% supported by any subclass

[19:43] <nothingmuch> subclasses may change implementation details

[19:43] <nothingmuch> or add to an interface

[19:44] <nothingmuch> but not change it in an incompatible way

[19:44] <particle_> that's a *very* strict definition of subclassing... and in combination with a language supporting roles, i like it.

[19:44] * Juerd sends the Traits paper (143 pages) to his laser printer

[19:44] * Juerd prepares for a sleepless night

[19:44] <nothingmuch> Juerd: double sided please =)

[19:44] <Juerd> nothingmuch: Duplexer is broken.

[19:45] <Juerd> nothingmuch: It's theoretically okay to do a role, but override a method in an incompatible way?

[19:47] <Juerd> Can a role inherit from a class?

[19:47] <PerlJam> Juerd: no.

[19:47] <Juerd> Can you "does" a class?

[19:47] <nothingmuch> Juerd: in Perl there will prolly be a way to cheat

[19:48] <nothingmuch> that is, use a role as a class or vice versa

[19:48] <nothingmuch> in theory they are distinct

[19:48] <PerlJam> nothingmuch: you can easily cheat with a mixin  :)

[19:48] <nothingmuch> exactly

[19:48] <Juerd> nothingmuch: Disregard cheating please :)

[19:48] <PerlJam> (and delegation)

[19:48] <particle_> can a role inherit at all?

[19:48] <nothingmuch> particle_: it can does

[19:48] <nothingmuch> the main thing about roles is that instead of being order sensitive, they are symmetric

[19:48] <PerlJam> particle_: roles are composed (of other roles).

[19:48] <particle_> sure, but i expect isa and does are orthogonal

[19:48] <nothingmuch> and any clash between two roles that is not resolved is an error

[19:49] <particle_> isa is for classes, does is for roles

[19:49] <Juerd> What's the verb missing in "class : inherit : is-a  ::  role : ? does"

[19:49] <Juerd> What's the verb missing in "class : inherit : is-a  ::  role : ? : does"

[19:49] <Juerd> implement?

[19:49] <Juerd> use?

[19:49] <nothingmuch> the verb is "consume" usually

[19:49] <PerlJam> implement sounds good to me.

[19:49] <nothingmuch> roles compose, and are then consumed by a class

[19:49] <nothingmuch> PerlJam: that's more like interfaces

[19:50] <Juerd> consumption would imply that someone else can no longer use it ;)

[19:50] <PerlJam> nothingmuch: yeah, I guess so.

[19:50] <Juerd> If I consume food, someone else can no longer eat it.

[19:50] <nothingmuch> I think either is equally OK

[19:50] <Juerd> Not in its original form anyway :)

[19:50] <PerlJam> nothingmuch: but roles can be used like interfaces just fine :)

[19:50] <nothingmuch> yes that's true =)

[19:51] <nothingmuch> Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T

[19:51] <nothingmuch> this could sound better as:

[19:51] <PerlJam> roles are like classes but without hooks into the type system (until they are composed into a class)

[19:52] <nothingmuch> If you read about it in the superclass's docs you can use it on the subclass with no exceptions

[19:52] <ruoso> you can't have an instance of a role

[19:52] <nothingmuch> (liskov substitution principle)

[19:52] <particle_> or, "everything you can do, i can do better"

[19:52] <nothingmuch> particle_++

[19:52] <PerlJam> ruoso: you can (sort of).

[19:52] <ruoso> roles "decorates" classes

[19:53] <ruoso> PerlJam, how?

[19:54] <nothingmuch> ruoso: decoration is a verb that usually describes altering an existing class

[19:54] <ruoso> nothingmuch, that's what a role can do

[19:54] <nothingmuch> not really

[19:54] <PerlJam> ruoso: at least I remember Larry saying at one point that if you attempted to instantiate a Role, then an anonymous class was generated that "does" the role.

[19:54] <nothingmuch> existing == methods in place

[19:54] <PerlJam> (perhaps that's changed)

[19:54] <nothingmuch> roles cannot override things in the class (in theory)

[19:54] <nothingmuch> in Moose you can do that though

[19:54] <ruoso> PerlJam, yes... that's not an instance of the role...

[19:54] <nothingmuch> which is probably naughty

[19:55] <PerlJam> ruoso: but it looks that way from the outside.

[19:55] <ruoso> PerlJam, ok... but "looks like" != "is" :)

[19:55] <FurnaceBoy_> url for roles?

[19:55] <nothingmuch> duck typing ;-)

[19:55] <nothingmuch> anyway, i'm off

[19:55] <PerlJam> FurnaceBoy_: http://dev.perl.org/perl6/doc/design/syn/S12.html

[19:55] <nothingmuch> Juerd: i hope i helped more than I harmed ;-)

[19:56] <PerlJam> FurnaceBoy_: read the whole thing  :)

[19:56] <FurnaceBoy_> thx

[19:57] <Juerd> nothingmuch: You've all harmed more than helped, I'm afraid.

[19:57] <Juerd> Before, I knew nothing about the subject

[19:57] <Juerd> Now, I know the differences, but seriously and heavily doubt that it's useful to still have classes.

[19:57] <Juerd> Or, that it's useful to have roles, if protection in MI fixes the main problem too.

[19:58] <particle_> a little learning is a dangerous thing

[19:58] <Juerd> I really do not understand why we would ever need both classes and roles.

[19:59] <particle_> well, it puts the burden of constraint on the programmer, instead of on the language designer

[19:59] <Juerd> And I don't understand when inheritance is better instead of composition - regarding semantics and use.

[19:59] <PerlJam> Juerd: you can't have roles without classes.  Roles only make sense when you can compose them into a class.

[19:59] <Juerd> particle_: That's my major concern indeed.

[19:59] <Juerd> PerlJam: Sure, but that's because it's designed like that.

[19:59] <Juerd> PerlJam: It doesn't have to be like that. Roles could have constructors.

[19:59] <PerlJam> Juerd: But think of roles as reusalbe bits of behavior that aren't tied to a particular class, but can be used in any class (to facilitate duck typing for instnace)

[20:00] <pasteling> "stevan" at 71.234.63.100 pasted "Roles as "Kinds"" (36 lines, 589B) at http://sial.org/pbot/17231

[20:00] <stevan> Juerd: please look at this paste

[20:00] <particle_> pj: not any class... unless they're specifically designed for that

[20:00] <Juerd> PerlJam: Being tied or not isn't terribly relevant for semantics, is it?

[20:00] <stevan> this is where the traditional isa model can break down

[20:00] <PerlJam> particle_: what do you mean?

[20:01] <Juerd> stevan: Understood. But is there any isa model that cannot be expressed equally in roles?

[20:01] <stevan> Juerd: dunno, I havent tried them all yet ;)

[20:01] <Juerd> Have you ever encountered one?

[20:02] <stevan> Juerd: not that I can think of no

[20:02] <Juerd> Why would we support traditional inheritance if we could mechanically translate without breaking anything...

[20:02] <Juerd> Or - why would we not just implement inheritance in terms of composition.

[20:02] <stevan> Juerd: because composition and inheritence are two very different things

[20:02] <Juerd> ...

[20:02] <stevan> In composition, the methods are copied into the classes namespace

[20:03] <stevan> more aliased actually

[20:03] <PerlJam> Juerd: why would we use C++ if we can use C with macros?

[20:03] <Juerd> stevan: Does that *matter*?

[20:03] <stevan> Juerd: yes,

[20:03] <stevan> you cannot dynamically uncompose a role

[20:03] <Juerd> stevan: Why would I, a programmer, care about why Baz's methods work on an instance of Foo?

[20:03] <stevan> Juerd: *you* may not, but *i* might

[20:03] <Juerd> Why would you, a programmer, ...

[20:03] <stevan> it all depends on how black you want your OO box to be

[20:04] <stevan> Juerd: I like metaclasses :)

[20:04] <Juerd> Is there any difference in semantics, for an end user that doesn't play with internals or metamodels?

[20:04] <stevan> Juerd: probably not all that much

[20:04] <Juerd> If you play with metamodels, you're likely to draw your own plan anyway :)

[20:04] <stevan> however, compsition is a much more 'final' act

[20:05] <Juerd> Would anyone be hurt in any way if roles had constructors, "class" was an alias for "role", etcetera?

[20:05] <stevan> yes,.. me :)

[20:05] <Juerd> And if you had no way of knowing that it was an alias?

[20:05] <Juerd> Ignore your knowledge of internals for a second

[20:05] <stevan> ok

[20:05] <stevan> then yes, you are correct

[20:06] <stevan> in fact the last P6 metamodel prototype had : Role.isa(Class) and Class.does(Role)

[20:06] <stevan> which made classes and roles completely interchangeable

[20:07] <Juerd> Why spend any effort on blocking this interchangability?

[20:07] <Juerd> On implementing two models when one is a subset of the other, in practical terms?

[20:07] <TimToady> roles are immutable.  classes are mutable.

[20:07] <Juerd> TimToady: Can you explain that with an example?

[20:07] <stevan> actually let me clarify ,.. they were not 100% interchangable

[20:07] <TimToady> I never do examples.

[20:07] <TimToady> My brain doesn't work that way.

[20:08] <stevan> Class handled the method dispatch and isa relationships

[20:08] <TimToady> especially when I'm overdue for lunch...

[20:08] <stevan> Roles just handled methods and attributes

[20:08] <stevan> TimToady: why are roles immutable?

[20:08] <TimToady> biab &

[20:08] * Limbic_Region just gets mean when he hasn't had sufficient sustenance

[20:09] <Limbic_Region> . o O ( I probably get stupid too but am too busy being mean to notice )

[20:09] <Juerd> TimToady: Perhaps not an example, but further clarification of what exactly is (im)mutable, then?

[20:09] *** justathe1ry is now known as justatheory

[20:10] <stevan> Juerd: immutable == cannot be changed , muttable == can be changed

[20:10] <Juerd> stevan: Would it be bad, in practice, to have one thing that does both method dispatching, and methods and attributes?

[20:10] <Juerd> stevan: What cannot be changed. The name, the value of attributes, the composition/@ISA, the virtual array of methods, ...?

[20:10] <stevan> Juerd: of course not, thats what a class does

[20:11] <stevan> Juerd: ask TimToady, I dont see roles as immutable myself

[20:11] <Juerd> You keep speaking in terms of definitions, instead of requirements. That constantly makes me think there's a huge XY problem.

[20:12] <Juerd> It appears you're not solving any actual problem, just shifting the landscape because it's a fun exercise, because you think it's needed (without being able to explain why it's needed) -- that can't be true, given your levels of competence.

[20:13] <Juerd> Each requirement usually has a motivation, like "speeds up development"

[20:13] <Juerd> or "makes implementation easier"

[20:13] <stevan> Juerd: have you ever made a class, which was not "complete"

[20:13] <Juerd> or "makes things predictable"

[20:13] <Juerd> this just seems to "add another way to do it", which I can't really grok to be very reasonable :)

[20:14] <Juerd> stevan: Yes, and I already understand that roles are better than classes in many occasions

[20:14] <Juerd> I just don't understand yet why difference between classes and roles is needed.

[20:14] <Juerd> Or what benefit it has.

[20:15] <stevan> because sometimes you want an inheritence relationship

[20:15] <stevan> and sometimes you want to compese

[20:15] <stevan> compose

[20:15] <stevan> if two methods conflict in a composotion, then it dies

[20:15] <stevan> if you are using MI

[20:15] <stevan> then it lives

[20:16] <stevan> without an isa() relationship, you dont have a superclass

[20:16] <Juerd> You've said that, and I asked why you would want inheritance instead of composition -- as consuming methods or inheriting them makes no practical difference for as far as has been explained to me.

[20:16] <stevan> to call SUPER::foo()

[20:16] <stevan> you can't call SUPER:: if there is no SUPER:: to call

[20:17] <stevan> you can handle this manually like in C++, and call Bar::foo

[20:17] <Juerd> Couldn't there be a SUPER with roles?

[20:17] <stevan> nope

[20:17] <Juerd> Why not?

[20:17] <stevan> there is no super relationship

[20:17] <stevan> roles are composed

[20:17] <stevan> a role does not have parent roles

[20:18] <Juerd> The model of the composition could be stored

[20:18] <stevan> it only has a list of roles which it is composed with

[20:18] <stevan> Juerd: now you have classes

[20:18] <stevan> its very circular

[20:18] <Juerd> Quite.

[20:18] <Juerd> That's my gripe

[20:18] <stevan> add a little to roles, you get classes

[20:18] <stevan> take a little away from classes,.. look you got roles

[20:18] <Juerd> There's no fundamental difference that seems important enough to me to differentiate.

[20:18] <stevan> i just said it

[20:18] <stevan> SUPER::

[20:19] <Juerd> Oh, nevermind.

[20:19] *** aufrank joined
[20:19] <stevan> and since when roles compose they dont care about ordering

[20:19] <Juerd> We're not getting anywhere.

[20:20] <Juerd> I have no idea what approach to take to explaining classes and roles tomorrow.

[20:20] *** qu1j0t3 joined
[20:20] <stevan> skip it :)

[20:20] <Juerd> I can explain how to use them.

[20:20] <Juerd> I can explain that roles have protection, and that classes have SUPER

[20:21] <stevan> Juerd: to be honest, my guess is that you wont use them much

[20:21] <Juerd> But I can't explain WHY to use them.

[20:21] <stevan> I will use them more

[20:21] <Juerd> And I can't explain why classes don't have protection, and why roles don't have SUPER.

[20:21] <stevan> nothingmuch will probably use them too

[20:21] <stevan> chromatic better use them, there were his idea to put them into P6

[20:22] <Juerd> I think it's wiser to have one thing, that does both what roles do and what classes do.

[20:22] <Juerd> I'm not convinced that a hybrid is impossible.

[20:23] <stevan> Juerd: it is not impossible

[20:23] <stevan> but if you have to do it,..then I would rather have classes, which can be composed into one another like roles, as well as inherited like traditional classes

[20:24] <Juerd> They're not incompatible. Well, they are, but only by design, and not as a result of anything else.

[20:24] <stevan> yes basically

[20:24] <Juerd> I think that's incredibly stupid.

[20:24] <stevan> however,.. how would you compose an isa() relationship?

[20:24] <stevan> if isa() relationships are order sensitive

[20:25] <stevan> and does() are not order sensitive

[20:25] *** amnesiac joined
[20:25] <Juerd> It does make sense to not be able to consume a class that inherits.

[20:25] <stevan> then when I compose a class into another class, how do I deal with any isa() it hash

[20:25] <stevan> Juerd: there are a lot of edge cases

[20:25] <Juerd> There are?

[20:25] <stevan> I wont even start on the composing of attributes

[20:25] <Juerd> Are they documented somewhere?

[20:25] <stevan> my test suites

[20:26] <stevan> the traits paper

[20:26] <stevan> (you have to probably read them all though to get a good list)

[20:26] <Juerd> Test suites are driven by definition, or are the definition. They're typically not driven by requirement or problems.

[20:26] <stevan> Juerd: I wrote tests to assure that the edges cases succeeded or failed as expected

[20:27] <stevan> trust me ,.. they exists

[20:27] <Juerd> Books have to be written about this, tutorials too. Perl itself needs documentation. Example code needs to exist. This is something new to most people.

[20:27] <stevan> yup

[20:27] <stevan> totally agree

[20:27] <Juerd> This better all be around by the time Perl 6 is released.

[20:27] <Juerd> Because I think Perl 6 will die of ridicule if it's not :(

[20:28] <stevan> Juerd: traits/roles are getting a lot of buzz in teh OO community

[20:28] <Juerd> Understandable.

[20:28] <stevan> there are implementations in Java, Smalltalk, C#, C++ (i think), Perl

[20:28] <Juerd> But keeping classes. I'm not sure that that is smart.

[20:28] <stevan> we wont be laughed at for having roles

[20:28] <Juerd> I'm not laughing, indeed.

[20:28] <stevan> Juerd: getting rid of classes is not smart :)

[20:29] <stevan> they will laugh at us for that for sure

[20:29] <Juerd> stevan: If roles are modified slightly to do what classes did, nobody would notice.

[20:29] <stevan> Juerd: but then you have a whole new set of edge cases

[20:29] <stevan> Juerd: to be honest, I think you might want to attempt to write an implementation

[20:30] <stevan> roles sound really simple until you try and actually make the damn things work

[20:30] <Juerd> A set of edge cases that are documented and return useful diagnostics is easier to handle than two different models used together, which are incompatible by design but one depends on the other, again, only by design.

[20:31] <stevan> Juerd: I am not the designer, so I cannot speak to the "by design" restrictions

[20:31] <stevan> but knowing the guts of how classes work, and the guts of how roles work, I think you are simplifying things a little too much

[20:31] <ruoso> one thing I think I agree with Juerd is that roles and classes are much like the same thing...

[20:32] <ruoso> the difference is in the use of them

[20:32] <stevan> if *everything* inherits from Object, then you can never have a class which does not inherit

[20:32] <stevan> and Obejct is where .new() lives

[20:32] <Juerd> if, indeed

[20:32] <stevan> Juerd: so now we are back to making out own constructors all the time?

[20:33] * stevan doesnt wanna stick with p5 

[20:33] <Juerd> But that everything inherits from Object is a design definition, not justified by any reason that leads back to increase of productivity.

[20:33] <stevan> wrong

[20:33] <Juerd> You could have a role Constructor.

[20:33] <Juerd> And compose that into your role.

[20:34] <stevan> this is only slightly better than having to write sub new { bless {} => shift } all the time

[20:34] <Juerd> "Object has .new, so if X doesn't inherit from Object, you can't re-use the .new method and have to roll your own." is bad logic.

[20:34] <Juerd> Especially if roles are primarily meant for code reuse

[20:35] <stevan> X will *always* inherit from Object

[20:35] <stevan> Object might be composed of the Constructor role

[20:35] <stevan> that works

[20:35] <Juerd> If having to type "does Object" is the problem, then "class Foo" can be a macro that expands to "role Foo { does Object;"

[20:35] <stevan> Juerd: please read the trait papers

[20:35] <Juerd> I'm off to read the traits paper.

[20:35] <Juerd> The 143 page one that I just printed.

[20:36] <stevan> enjoy :)

[20:36] <Juerd> Did I mention that the workshop starts at 8:00, and that it's 22:35 here?

[20:36] *** coumbes joined
[20:36] <stevan> I hope you printed the one about the smalltalk coll hierarchy?

[20:36] <ruoso> anyway...

[20:36] <Juerd> stevan: Dunno.

[20:36] <stevan> Juerd: send me a plane ticket, I will be glad to come help ;)

[20:36] <PerlJam> I was away for a while, but it still sounds like Juerd is almost arguing "Why do we have C++, I can do all that stuff in C"

[20:36] <ruoso> what if role and class are the same, but you still have isa and does

[20:36] <ruoso> ?

[20:36] <Juerd> Traits - Composing Classes from Behavioral Building Blocks

[20:36] <PerlJam> (almost, but not quite)

[20:36] <Juerd> stevan: I'm not convinced you could help.

[20:37] <stevan> Juerd: help? oh no,.. just entertain and annoy :)

[20:37] <ruoso> heh

[20:37] <Juerd> stevan: Your explanations are recursive, and that doesn't work with an audience that doesn't have this in their minds yet.

[20:37] <stevan> Juerd: sorry, I am a very meta-circular guy

[20:38] <Juerd> Things that "just are", are great only if they've "just been" for at least a generation.

[20:38] <stevan> Juerd: if we want we can talk about how Class is an instance of Class

[20:38] <Juerd> No, thanks.

[20:38] <stevan> :)

[20:38] <Juerd> I understand THAT, by the way.

[20:38] <Juerd> But only because it's explained by terms I'm already deeply familiar with.

[20:38] <Juerd> s/by/in/

[20:39] <stevan> yes

[20:39] <Juerd> I wouldn't understand that if I were new to OO.

[20:39] <stevan> roles can be defined in terms of roles as well,.. but its a little weirder

[20:39] <Juerd> Well, the DEFINITION of roles is no problem. I can do that.

[20:39] <Juerd> I can't explain why we need both classes and roles.

[20:39] <Juerd> explaining things is much harder than defining them.

[20:39] <ruoso> because of the constructor?

[20:39] <stevan> Juerd: read the papers,.. they are much smarter and more articulate than I will ever be

[20:40] <Juerd> You should try it. It's a nice exercise.

[20:40] <stevan> Juerd: not my thing ;)

[20:40] <arguile> Can you reference the papers you're talking about again? I didn't catch them and the discussion sounds interesting

[20:40] * stevan waves goodbye to Juerd and then promptly falls off the cutting edge of OO

[20:40] <Juerd> ruoso: That's definition again. The definition is that roles don't have constructors, and cannot be instantiated. But they COULD.

[20:41] <stevan> arguile: see here http://www.iam.unibe.ch/~scg/Research/Traits/

[20:41] <Juerd> The paper I'm reading now is titled Traits.

[20:41] *** justathe1ry joined
[20:41] <ruoso> Juerd, but then the constructor would conflict while composing

[20:41] <PerlJam> Juerd: I believe it was Richard Feynman who said something like, "If I can't explain it to a college freshman, then that I means I don't understand it"  Regardless of what he actually said, the sentiment is quite true.

[20:41] <Juerd> Subtitled Composing Classes from Behavioral Building Blocks.

[20:41] <stevan> arguile: I recommend the 1st and 3rd papers

[20:41] <Juerd> ruoso: Only because of definition.

[20:41] <Juerd> ruoso: Sorry, but I'm going to ignore you for a while.

[20:41] <arguile> stevan: Thanks

[20:41] <stevan> arguile: your welcome

[20:42] <stevan> Juerd: I got a shout-out in "Traits ? Composing Classes from Behavioral Building Blocks"

[20:42] <stevan> he talks about Class::Trait and how it comparse to the smalltalk model

[20:42] <Juerd> stevan: I'm approx 100 pages removed from that part.

[20:43] <stevan> :)

[20:43] * stevan wonders why the dutch read so slow ;)

[20:43] <Juerd> IRC

[20:43] <stevan> :D

[20:43] <Juerd> Oh!

[20:43] <Juerd> Can someone re-model Mail::Box to incorporate roles?

[20:44] <Juerd> (without implementation)

[20:44] <Juerd> Maybe that would help.

[20:44] * stevan goes to look

[20:44] <Juerd> It uses inheritance quite heavily

[20:44] <Juerd> So there must be cases where composition would be better...

[20:45] <PerlJam> Are there any prototype roles stuff in the pugs examples?

[20:45] <stevan> Juerd: the first bit i see is all his has-a relations

[20:45] <stevan> Mail::Message has-a Mail::Message::Body and has-a Mail::Message::Head

[20:46] <stevan> those could possibly be roles

[20:47] <PerlJam> ah t/oo/roles

[20:48] <PerlJam> Hrm..  those tests look mostly like roles-as-interfaces

[20:48] <stevan> Juerd: I would also suspect that if you broke down the Mail::Box::Message:: subclasses, you could make some of them into roles

[20:48] <Juerd> Foo is Bar, Bar does Quux. Quux has a method xyzzy. Does Foo have xyzzy?

[20:49] *** pmurias joined
[20:49] <stevan> yes

[20:49] <stevan> inherited from Bar

[20:49] <Juerd> stevan: Shouldn't has-a be implemented with, err, "has"?

[20:50] <stevan> Juerd: you can do it that way

[20:50] <Juerd> has Mail::Message::Body $body handles *;

[20:50] <Juerd> (What's the syntax for saying you handle all the thing's methods? :)

[20:50] <Juerd> )

[20:50] <stevan> which is very similar to doing it as a role

[20:51] <PerlJam> Juerd: that looks good to me (considering *'s new role (heh) as the Whatever indicator)

[20:51] <Juerd> Are role attributes that do not have accessors accessible from the class that consumes the role?

[20:51] <stevan> Juerd: this is one of those ugly edge cases

[20:51] <stevan> the assumption is yes

[20:51] <Juerd> PerlJam: You have no idea how much I've been avoiding non-technical uses of the word "role" today :)

[20:52] * stevan really has to go walk the dog

[20:52] <stevan> and I fear I am disturbing Juerd's reading :)

[20:53] <Juerd> What reading?

[20:53] <Juerd> Ohh, you mean that stack of paper that has page 2 on top?

[20:53] * stevan woofs

[20:54] <Juerd> Is there a way to indicate that your role requires methods it doesn't define by itself?

[20:54] <stevan> Juerd: yes, ... role Foo { method bar { ... } }

[20:54] <stevan> any class which comsumes Foo will be required to implement bar

[20:55] <PerlJam> stevan: overloaded use of ellipsis there.

[20:55] <Juerd> But that doesn't fail until runtime

[20:55] <stevan> PerlJam: :)

[20:55] <stevan> Juerd: no, it fails at class composition time

[20:56] <Juerd> Then an older definition no longer holds. Okay.

[20:56] *** weinig|away is now known as weinig

[20:56] <PerlJam> Hmm

[20:56] <stevan> Juerd: by "older" do you mean one from a superclass?

[20:56] <Juerd> I'm considering not explaining Perl 6 *classes* tomorrow.

[20:56] <Juerd> stevan: No, in time.

[20:57] <Juerd> stevan: The definition that ... does fail() - fail() is imperative, so assumed to be runtime.

[20:57] *** Gothmog_ joined
[20:57] <Juerd> "Forget classes, use roles."

[20:57] * stevan ~ time is fleeting,... madness,.. takes its toll ~

[20:57] <Juerd> "And here's how:"

[20:57] <PerlJam> Juerd: you could just leave roles as an interesting, if confusing topic at the end and then give them links to go look up stuff for themselves.

[20:57] * stevan does the Time Warp and goes to walk the dog for real this time

[21:00] *** kanru joined
[21:01] *** cdfh joined
[21:01] * nothingmuch is completely out of focus:

[21:02] <nothingmuch> i read this: "Patrick R. Michaud      Re: lvalues and "is rw" parameter passing" as "lvalues and is r

[21:02] <Juerd> PerlJam: But I think roles are easier to explain, and more useful.

[21:02] <nothingmuch> walue parameter passing"

[21:02] <nothingmuch> and i asked myself why is he contradicting himself?

[21:02] <Juerd> Blergh. They DEPEND ON classes, so if I explain roles, I have to do classes too

[21:03] <PerlJam> yep

[21:07] <PerlJam> I think it's interesting that a role-method will hide an inherited method of the same name and a class-method will hide a role-method

[21:07] <PerlJam> I don't remember the justification for that ordering.

[21:09] <PerlJam> But coupled with roles that define but do not implement methods, there doesn't appear to be a way to say (in the role), "the class that this role is composed into must have a foo() method" and have that foo() method come from a superclass.

[21:09] <PerlJam> (unless you just happen to define things that way)

[21:12] *** justatheory joined
[21:15] <PerlJam> Hm.  I guess you can do  role Foo { proto method bar { ... } }   class A { method bar { print "hi" } };  and class X is A does Foo will use A's bar method

[21:15] * PerlJam really needs to re-read the synopses

[21:16] <Juerd> http://feather.perl6.nl/~juerd/classes_roles.png

[21:16] <Juerd> Is that more or less correct?

[21:17] <aufrank> Juerd: did you mean to label the individual bubbles?

[21:17] <aufrank> or am I supposed to recognize the structure without any labels?

[21:18] <PerlJam> I would guess that the red things are classes and the blue things are roles.

[21:19] <aufrank> I get it

[21:19] <azuroth> it's nine below zero!

[21:20] <aufrank> are you asserting that what I get is nine below zero?

[21:20] <Juerd> Image updated

[21:20] <azuroth> no, I'm saying it's cold!

[21:21] <Juerd> PerlJam: If that's obvious, then I did something right: )

[21:21] <PerlJam> Juerd: yep  :)

[21:21] <Juerd> aufrank: If I did it right, unlabeled should speak for itself.

[21:21] <Juerd> Try the updated image, which indicates more impossibilities

[21:21] <Juerd> Eh

[21:21] <PerlJam> um ... the image looks the same.

[21:21] <Juerd> Right.

[21:22] <Juerd> Still had to enter my password

[21:22] <PerlJam> ah, better

[21:22] <Juerd> I hope my audience will not have many colour blind people in it :)

[21:23] <aufrank> at least you used blue and not green

[21:23] <Juerd> aufrank: I knew about that :)

[21:23] * ruoso is color blind, but saw it clearly

[21:23] <azuroth> a class can't own a role ?

[21:23] *** marmic joined
[21:24] <Juerd> azuroth: Nothing can "own".

[21:24] <azuroth> (is that what the red to blue with black line is)

[21:24] <PerlJam> azuroth: "own" doesn't make sense.  Pick another verb.

[21:24] <PerlJam> azuroth: that's "inherit"

[21:24] <azuroth> ahh

[21:25] <Juerd> inkscape++  # quick drawings

[21:25] <aufrank> Juerd: I remember something about being able to "does" a class

[21:25] <aufrank> do you know if that's still around (or if it ever was)?

[21:25] <azuroth> isn't that what the left parts are?

[21:25] <Juerd> aufrank: What has been said here the past few hours indicates that that isn't possible.

[21:26] <Juerd> azuroth: No, those are classes that consume ("do") roles

[21:26] <azuroth> oh, sorry, read that wrong

[21:26] <azuroth> thought before typing :-) probably need a coffee

[21:26] <aufrank> ok.  I am pretty sure I remember some handwaving about a class also being available as a role for the purpose of composition

[21:27] <Juerd> This will be the first time I have a diagram in a talk.

[21:27] <aufrank> but it makes more sense without that

[21:30] <Juerd> stevan: When you're back, please review http://feather.perl6.nl/~juerd/classes_roles.png

[21:31] <stevan> Juerd: looks sane, but more details would help to confirm that assumption

[21:31] * stevan has to go cook dinner though

[21:33] <Juerd> stevan: What kind of details?

[21:34] <qu1j0t3> nice diagram

[21:39] <Juerd> Added legend

[21:41] <aufrank> Juerd: do you want to add any dotted lines to the role that does another role?

[21:41] <Juerd> Dotted line means "is the same thing"

[21:43] <aufrank> well then maybe add that to the legend, as lubs like me might not get it ;)

[21:43] <aufrank> and anyway, isn't the role within a role the same thing as one of the external roles?

[21:44] <aufrank> if the three roles are A, B, and C, B does A or B does C, but I can't tell which because there are no dotted lines from that role in B

[21:44] <PerlJam> aufrank: er, what?  He's illustrating that you can build roles out of other roles.  Naming the roles aren't important.

[21:44] <Juerd> No, the legend gets too crowded then

[21:45] <Juerd> And certainly I don't want names here.

[21:46] <particle_> juerd: blue isa blue should also be shown crossed out, i believe

[21:46] <aufrank> I wasn't suggesting names, just that you use the dotted line to convey identity from the "done" role to one of the other roles, just like you did for classes

[21:47] <aufrank> but it's not a big deal

[21:47] <particle_> dotted line is like an explosion, to a close up, or something... right?

[21:48] <aufrank> particle_: "is the same thing" says Juerd

[21:48] <particle_> ah, yep. grt.

[21:48] <Juerd> particle_: Good one!

[21:48] * aufrank has to leave the office now

[21:49] <aufrank> good luck on the presentation tomorrow, Juerd

[21:57] <Juerd> Thank you

[21:57] <Juerd> (image updated)

[21:59] *** jsiracusa joined
[22:00] <particle_> i can think of a few more relations

[22:01] <particle_> superclass & subclass can't both does role

[22:01] <particle_> (the same role)

[22:02] <Juerd> particle_: Documented where?

[22:02] <ruoso> particle_, wouldn't it result in the same thing?

[22:02] <particle_> and there's one more, but it's really messy

[22:02] <particle_> wouldn't it conflict?

[22:02] <Juerd> I think I don't want that level of detail by the way, but I would like to know more

[22:02] <particle_> i think if the role is defined already, it can't be redefined

[22:02] <particle_> that's what "is immutable" means

[22:02] <Juerd> particle_: What's there to conflict, if you have two *equal* roles? Absence of order makes me think it's set-like: duplicates are ignored.

[22:03] <particle_> hrmm, maybe that's the case

[22:03] <PerlJam> particle_: sure a superclass and subclass could "does" the same role.

[22:03] <particle_> so parent and child could both specify, but child specification is optional

[22:03] <particle_> pj: if parent does it, child does it is implied, yes?

[22:04] <particle_> juerd++ # i like this picture a lot

[22:05] <PerlJam> particle_: child overrides role overrides parent as far as method use goes.

[22:06] <Juerd> particle_: There is no child/parent in roles :)

[22:06] <Juerd> Oh, nevermind

[22:06] <particle_> the child / parent is in c...

[22:06] <Juerd> Too much context switching

[22:06] <Juerd> (drawing, slides, irc, still browsing through the traits paper)

[22:07] <particle_> ...and not sleeping

[22:11] <Juerd> What's the syntax for an "is rw" method?

[22:11] <Juerd> Does it return an lvalue like in Perl 5?

[22:13] <particle_> class Bar is rw {

[22:13] <particle_>     has $.readwrite_attr;

[22:13] <particle_> }

[22:14] <Juerd> No, not an automatically generated one :)

[22:14] <particle_> $bar.readwrite_attr++; say $bar.readwrite_attr; # 1

[22:14] <Juerd> I want to show what's generated

[22:14] <particle_> oh

[22:14] <Juerd> But it's perl5 lvalue-like

[22:15] <Juerd> So boring

[22:15] <Juerd> Skipping...

[22:16] * particle_ wanders off for a bike ride

[22:19] <mugwump> so.  how are type constraints (subset) supposed to ever be applied at compile time?

[22:42] *** fglock left
[22:48] <TimToady> mugwump: by basing them on something immutable.

[22:49] <TimToady> but the main point of typing in P6 is not type safety so much as MMD.

[22:49] <Juerd> TimToady: /home/juerd/classes_roles.png

[22:49] <Juerd> TimToady: Do you think I have the most important uses and impossibilities covered?

[22:49] <TimToady> you wanna try that url again?

[22:49] <Juerd> Ehm, hehe :)

[22:50] <Juerd> TimToady: http://feather.perl6.nl/~juerd/classes_roles.png

[22:50] <Juerd> The weird thing is that I have no idea how that /home "URL" ever made it into my browser.

[22:50] <Juerd> I never type that...

[22:50] <Juerd> (in a browser)

[22:50] <Juerd> (in a browser's address bar)

[22:51] <TimToady> they know where you are...

[22:51] <Juerd> Apparently :)

[22:53] <mugwump> TimToady: it would just be nice if code that it impossible to run because of conflicting type constraints could be noticed during compile time

[22:53] <TimToady> if the type constraints are based on immutables, then it can be known at compile time.

[22:54] <mugwump> where are those described?  I think I misunderstood your answer the first time

[22:55] <mugwump> oh, n/m, found it

[22:55] <TimToady> roles are basically immutable once they're defined.  they fill the role of closed classes without being closed classes.

[22:55] <TimToady> stevan doesn't quite see them that way, but that's because he's thinking about the infrastructure behind them.

[22:55] <mugwump> right.  oh, cool, a Tuple type

[22:56] <TimToady> Tuple?  we got rid of that.

[22:56] <TimToady> it's now Seq.

[22:56] <TimToady> what are you reading?

[22:56] <mugwump> It's on S02

[22:57] <TimToady> not any more... :)

[22:58] <Juerd> TimToady: No "role Foo is also { ... }", then?

[22:58] <Juerd> TimToady: Or would you have to do "role Foo does Foo is instead { ... }"? :)

[22:58] <TimToady> phone...

[22:58] <Juerd> role Phone does Ring

[22:59] <mugwump> I had a thought before, you should be able to curry types...

[23:00] <mugwump> though an explicit syntax for it is probably unnecessary

[23:01] * Juerd has 34 slides

[23:01] <Juerd> Should be more than enough.

[23:01] <Juerd> For 45 minutes :)

[23:01] <Juerd> mugwump: Hm? Str.assuming(...)?

[23:01] <Juerd> :)

[23:01] <mugwump> role Mapping [ Key does eq, Value ] { };   role Hash [ Value] is Key [ Key does str, Value ]  {   }

[23:02] <mugwump> or something like that

[23:02] <mugwump> in that instance, "Hash" is a curried version of "Mapping"

[23:02] <Juerd> Can []-parameters/arguments be used with classes too?

[23:03] <mugwump> I don't think that makes sense

[23:03] <mugwump> I agree with roles being parametric, but classes are concrete

[23:05] <TimToady> "role Foo is also" is like saying "for large values of 2"

[23:11] <Juerd> Why?

[23:13] <mugwump> a mismatch of concepts; roles don't capture "is"-ness

[23:13] <mugwump> (guess)

[23:19] *** rashakil joined
[23:19] <TimToady> classes are type containers; roles are type values

[23:20] *** Quell joined
[23:23] * qu1j0t3 's head explodes

[23:27] *** _meppl joined
[23:28] <mugwump> classes is, roles do.  Therefore it makes little sense to say what roles are

[23:28] <mugwump> makes about as much sense as trying to infer substance from observation

[23:29] <TimToady> you're using substance in a rather medieval sense...

[23:29] <mugwump> role Existence is Turtles_All_The_Way_Down { ... }

[23:30] <mugwump> Hmm, perhaps "Observable_Universe" beats "Existence" there

[23:31] <mugwump> ah, better not keep trying to combine metaphysics and programming.  usually gets me into trouble :)

[23:33] *** rashakil_ joined
[23:58] *** obra_work joined
