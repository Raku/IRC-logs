[00:02] *** Quell joined
[00:02] <TimToady> you know, @;_ is really ugly.  I wonder if @@_ would be better for multidims...

[00:07] <TimToady> Must be Friday night in the US again...

[00:08] <Limbic_Region> yep

[00:08] <Limbic_Region> and as far as aestectics go - they both look like you are attempting ascii art to me

[00:16] * buu sends Limbic_Region an h

[00:16] <buu> TimToady: Perl6 is just trying to win a competition that involves how many emoticons you can make compile, right?

[00:16] <Limbic_Region> it is Friday and I never claimed to be able to speel

[00:17] <TimToady> it would presumaby confuse Ruby programmers, which would have to be a plus...

[00:17] <buu> Reasonable.

[00:22] *** stevan_ joined
[00:24] *** stclare` left
[00:34] <KingDillyDilly> So, semicolons might be used for more than ends of lines in Perl 6?

[00:34] * SamB thought newlines were the method of choice for ending lines

[00:34] <KingDillyDilly> Ends of statements, or whatever.

[00:36] <KingDillyDilly> I remember some BASIC terminology. Not so good with Perl.

[00:54] <KingDillyDilly> If I may revisit my old Function Critique from http://perlmonks.com/index.pl?nodenum=388534&node=Visit%20Reaped%20Nodes, I think the standard mathematical notation for abs should be allowed in Perl 6, and anything that needs to be changed to accomodate it should be. Possibly not much change would be needed, from what I remember of the discussion (http://perlmonks.com/?node_id=388534).

[00:54] *** FurnaceBoy_ joined
[00:58] *** qu1j0t3 joined
[01:00] <meppl> gute nacht

[01:01] <KingDillyDilly> Some quoted TimToady commenting about using the standard notation for abs, I think from back when he was developing the first version. He made it sound like that's way at the end of his priorities, but I wasn't clear on what he meant. I'd have to look through a bunch of threads to find the quote.

[01:02] <TimToady> macro circumfix:<| |> {...} is all you need.

[01:03] <KingDillyDilly> Yeah, I think that's what I said in the PM thread.

[01:04] <KingDillyDilly> Well, sort of.

[01:06] <TimToady> But it's certainly true that we're not bending over backwards to support pure "math notation".

[01:10] <TimToady> We've kept away from defining any prefix:<|> more because it would be visually confusing with infix:<|> than out of respect for math notation.

[01:16] <KingDillyDilly> Pure math notation is well defined and easy to support. Iif it's not built into Perl because of some conflict or confusion with other stuff, maybe there should be a pure math mode, or at least a module. I should say it's easy though because I don't really know how many symbols and whatnot there are.

[01:17] <KingDillyDilly> s/should/shouldn't/

[01:17] <TimToady> Pure math notation is optimized for mathematicians, not humans.  We'll make it possible to define things how you like, but Perl ain't math.

[01:20] <KingDillyDilly> There would be keyboard limitations anyway. It's just a coincidence that keyboards have vertical bars like the abs notation.

[01:21] <TimToady> Mathematicians use all sorts of weird whitespace dependencies and two-dimensional thingies that don't work out terribly well in a computer language.

[01:22] <TimToady> They're also quite inconsistent about what some symbols mean, even comma and vertical bar.

[01:22] <Steve_p> Its all context driven :-/

[01:22] <TimToady> I was just about to say that.

[01:23] <TimToady> At least we're allowing the user to define Unicode operators, which is a lot more than you can say for most other programming languages.

[01:24] * Steve_p bites his tongue ;)

[01:24] <TimToady> "enough rope to shoot yourself in the foot"

[01:25] <KingDillyDilly> At least you won over the biologists if not the mathematicians.

[01:26] <TimToady> Biologists have simple desires.  :)

[01:26] <TimToady> Infinite strings, mostly.

[01:26] <TimToady> well, huge strings...

[01:27] <TimToady> and maybe a decent database to store them in.

[01:27] <TimToady> sort of CGI writ large.

[01:28] <TimToady> But I think Perl 6 has a decent shot at the mathematicians as well.

[01:28] <TimToady> Or rather, some future variant of Perl 6...

[01:29] <Steve_p> Wall Street programming types like Perl too, and Sybase, oddly enough.

[01:30] <TimToady> One thing I can guarantee the mathematicians is that standard Perl will never waste juxtaposition on multiplication.

[01:31] <TimToady> I think the Wall Street types will particularly like the ability to nail down modules to particular versions, along with the ability to use different versions in the same program.

[01:31] <TimToady> At least some of them are very picky about upgrading modules...

[01:33] <KingDillyDilly> That sounds like a good Perl 6 installation will become huge with various versions of each module.

[01:36] *** vel joined
[01:38] <KingDillyDilly> I'm picturing someone looking for scripts on the internet and finding that they all specify a particular version of a module, then the kid decides to download the full module package and ties up his computer for hours. But I don't know exactly what "nailing down" would mean exactly.

[01:40] <KingDillyDilly> Anyway, if I'm thinking correctly, extra care to reduce bugs in modules and reduce the number of versions should be recommended for Perl 6 modules.

[01:40] <avar> As opposed to him downloading the script witch would just silently fail because the API of the version you have is not compatable with the one it's written for?

[01:41] <KingDillyDilly> Failed download or not working...same thing.

[01:43] <avar> But you'd know that it happens due to incompatable versions, witch you wouldn't know otherwise. So I fail to see how this could be a problem since you're given more to work with to solve the problem.

[01:44] <KingDillyDilly> Currently, programmers strive to make their scripts backwards compatible. Allowing them to specify a module version might make them lazy and put the problem on the consumer.

[01:45] <KingDillyDilly> I think it's good, it's just that there are issues.

[01:46] <KingDillyDilly> We may see more inlining of modules.

[01:47] *** bsbr joined
[01:48] *** aufrank joined
[01:55] *** justatheory joined
[01:57] <KingDillyDilly> Hey, look how far ahead of my time I was. My auto-updating snippets idea could be adapted for this (http://perlmonks.com/?node_id=374851) to install or inline modules that the script calls for.

[02:01] <PerlJam> KingDillyDilly: you know, modules could always treat the versions as roles I bet.  At least they have the ability to specify which API they conform to in various ways.

[02:02] *** vel joined
[02:05] <KingDillyDilly> I heard that term "roles" somewhere. That's all I know.

[02:10] <PerlJam> In the language design game we're all entitled to makeup our own terms.  Fortunately, only Larry's terms count for perl6 :)

[02:10] <TimToady> well, terms and operators...

[02:12] <PerlJam> speaking of which ...  @; makes more sense as @@?  What happened to the mnemonicity relating to  @foo[@a;@b]  ?

[02:13] <PerlJam> (well, there was a connection in my head if no where else :)

[02:13] <PerlJam> And why is it that I always seem to be eating while watching this channel?

[02:15] <azuroth> heh, I'm eating too

[02:15] <avar> I want pizza

[02:15] * PerlJam make make some homemade pizza this weekend.  

[02:16] <PerlJam> I need some cheese though.

[02:16] <azuroth> we were planning on making this apparently uber dough tonight, and cooking tomorrow

[02:19] * avar suspects drug slang

[02:19] <Steve_p> heh

[02:19] <TimToady> @@a is just a different mnemonic.

[02:19] * Steve_p blinks

[02:19] <TimToady> And it looks a lot less like a bare @ with a terminator after it.

[02:20] <TimToady> well, speaking of dinner, I'm being hauled off...

[02:20] <TimToady> so biab &

[02:27] <buu> So what is @@a? or @;a or what not

[02:36] *** p5evalbot joined
[02:36] *** vel joined
[02:38] <nothingmuch> what's the Rule -> Regex change about?

[02:39] <TimToady> After spending much time dithering about for a good name for non-backtracking rules, Damian hit upon the idea of just calling those "rules" and resurrecting "regex" to refer to the general regex {...} form.

[02:40] *** amnesiac joined
[02:43] *** vel joined
[02:47] *** vel joined
[02:50] <KingDillyDilly> buu: Multidimentional array, I think.

[02:50] <buu> Scary.

[02:50] <buu> @@x[1][2] ?

[02:50] <buu> @@@x[1][2][3]

[02:51] <KingDillyDilly> He originally said @;a_ and @@a_ and I thought the underscore was part of it, but I don't know anymore. Not that I'd know how to use it anyway.

[02:52] <KingDillyDilly> buu: that's hot I thought of it and I was going to suggest a number instead of multiple @, but I know, like, nothing about this, so I shut up. I figured you'd be proud of me for that.

[02:52] <KingDillyDilly> s/hot/how/

[02:52] <buu> Oh I am.

[02:53] * KingDillyDilly dries his hair and eats

[02:53] <azuroth> humm. I guess it makes sense. though it wouldn't be necessary, would it? just some optional type safety?

[02:55] <nothingmuch> good night

[02:56] <audreyt> TimToady: so how is

[02:56] <audreyt> regex {... }

[02:56] <audreyt> different from

[02:56] <audreyt> rx { .. }

[02:56] <audreyt> ?

[02:57] <audreyt> can we not have the first form? :)

[02:57] <audreyt> (I know of the quotelike vs anon declarator difference)

[02:58] <audreyt> actually, never mind. timtowtdi.

[03:21] *** coumbes joined
[03:21] *** xern_ joined
[03:30] *** penk joined
[03:30] *** marmic_ joined
[03:30] *** scook0 joined
[03:38] *** frederico joined
[03:41] *** Entonian joined
[04:10] *** FurnaceBoy joined
[04:12] *** KingDillyDilly left
[04:13] *** elmex joined
[04:19] <PerlJam> okay, I just re-read S06 and @@_ does read better.  I guess it's just weird that we have a "list of lists" thingy that looks like [;] which gets put in an array that looks like @@.  Just like it's also weird to me that we have a \() matching up with a :()

[04:20] <PerlJam> perhaps though, syntactic correspondence isn't that important.

[04:21] <PerlJam> (as long as I can keep the concepts straight, it's all good :-)

[04:21] <arcady> I mean, you also have @ with [] and % with {}

[04:22] <arcady> @@_ and [;] don't seem too bad

[04:22] <PerlJam> arcady: yes, but those @[] and %{} are usually on the same side of an expression, while the others are on opposite sides of some sort of binding or assignment.

[04:23] <arcady> true

[04:24] <arcady> but @@ is definitely better than @;

[04:24] <arcady> @;foo; looks wrong to me.

[04:24] <PerlJam> though I almost want to say (0..3 @ 'a'..'d') instead of (0..3; 'a'..'d')

[04:25] <arcady> well, the ; there makes its own sense

[04:25] <arcady> with its original meaning of a super-comma

[04:25] <PerlJam> sure, I'm just letting the neurons fire as they may :)

[04:26] <arcady> I think by the time perl 10 comes around, syntax will be reduced to just UNICODE SYMBOL DO-WHAT-I-MEAN

[04:26] <PerlJam> heh

[04:37] <PerlJam> btw, would $@foo make any sense?  Because if I make a list of all twigiled vars using @arrays, the second @ sure looks like a twigil and begs the question of $@foo and %@foo

[05:09] <scook0> $@foo looks like what you'd write if you wanted to use @foo in list context, but as an Array rather than flattening -- of course, in that interpretation, it's not acting as a twigil

[05:12] <scook0> one issue with @@foo is that it suggests @@@foo et al. should be meaningful, by analogy with $$$foo

[05:16] <FurnaceBoy> 	<KingDillyDilly>	Yes, me again. There's nothing in the topic of #perl6 that explains that this channel isn't about the current version of Perl and that it isn't for support of the current version.

[05:16] <FurnaceBoy> is that guy as dumb as he sounds?

[05:17] <arcady> sounds like it

[05:17] <FurnaceBoy> eek

[05:18] * FurnaceBoy pins his hopes on natural selection

[05:18] <arcady> first I saw him, he was trying to sell a web-based diff...

[05:19] <FurnaceBoy> oh gawd, I think I heard that pitch

[05:20] *** reZo joined
[05:32] *** KingDillyDilly joined
[05:33] <KingDillyDilly> What's there to sell? It's free with no ads. http://www.polisource.com/diffnote/

[05:34] <KingDillyDilly> Is the topic for this channel so obviously about Perl 6 development than a Perl newbie would know? I know nothing about any of the things in the topic, like pugscode.

[05:41] <arcady> um... the channel name...

[05:42] <KingDillyDilly> That's the problem. How's someone to know Perl6 isn't the latest version that someone new to Perl would need to know? Are they supposed to copy and paste each of those web addresses in a browser to see if it applys to the Perl they want to ask about?

[05:43] <arcady> how would they get here in the first place?

[05:43] <arcady> and how often is this even a problem?

[05:43] <KingDillyDilly> U S A B I L I T Y

[05:43] <KingDillyDilly> Write it 100 times on the blackboard

[05:44] <KingDillyDilly> If they were referred to an IRC channel by a tutorial, they'd probably be referred to the correct one, but they may just be on Freenode browsing.

[05:44] <TimToady> then they're probably just troublemakers. :)

[05:45] <KingDillyDilly> Well, at least I'm taller now. I used to be called a troll.

[05:47] <TimToady> Well, I'm not a person to be poking labels on people, but I have noticed that there are certain people who are never happy unless they have something to be unhappy about.

[05:48] <TimToady> I don't profess to understand the contradiction...

[05:49] <KingDillyDilly> This was just a minor proposal, but then buum FurnaceBoy, and arcady started name calling.

[05:49] <KingDillyDilly> s/buum/buu/

[05:49] <TimToady> Maybe they thought you'd enjoy it.  I dunno...

[05:51] <KingDillyDilly> Nobody enjoys being called dumb, but mostly it degrades this community when someone who wants a clearer topic is attacked and called names.

[05:54] <KingDillyDilly> Or just changing #perl to #perl5 should work. No big deal...

[05:54] <KingDillyDilly> Actually, in Gaim, the room list isn't alphabetical, but that's another issue.

[05:56] <KingDillyDilly> By no big deal, I mean I don't think it's a big deal and I ended the conversation on #perl and here, and people brought it up again. I don't get into protracted debates about these things. If you think someone is dumb for a suggestion like this, keep it to yourself.

[05:57] <TimToady> Well, I've been fighting the flu, so I'd better toddle off to bed.

[05:58] <TimToady> I don't think you're dumb.  You're just persistent, which can be both a strength and a weakness.

[05:58] <TimToady> nite &

[05:58] <KingDillyDilly> Symbols even with nite?

[05:59] <ayrnieu> postfix & is an idiom for a public '/away'.

[06:00] <ayrnieu> Used to make it clear that you'll not be around for a while, of course, if you've spoken recently.

[06:00] <KingDillyDilly> Oh

[06:00] <ayrnieu> think of shell syntax.

[06:00] <KingDillyDilly> I never think of shell syntax, or know it.

[06:01] <arcady> it's the unix way of putting a program in the background

[06:01] <ayrnieu> Should you come to learn it, you will now have amusing context to tie into what you learn.

[06:04] <KingDillyDilly> I know to put semicolons between commands. That's about it. I had to figure out Tar once and immediately wrote EzTar for myself if nobody else. I guess someone will accuse me of "selling" EzTar now. Go on an buy it. I'm shamelessly plugging two charities on its webpage.

[06:05] <arcady> well, the idea of a web-based diff, especially one for local files just struck me as kind of... dubious

[06:05] <ayrnieu> wrapping such things is normal; I often wrap 'find' to not print permission errors.

[06:06] <arcady> yeah, and tar has a pretty nasty syntax

[06:06] <arcady> probably because it is the Tape ARchiver

[06:07] <ayrnieu> although it's sufficient for probably everyone to know a common subset of tar usage, and consult the manual if they need to do anything strange.

[06:08] *** Aankhen`` joined
[06:08] <KingDillyDilly> Many changes to web pages don't need to be kept secret, but you're correct that people should be aware that I can access what they're diffing. People have diffed mailing lists.

[06:08] <ayrnieu> I noticed the other day that I will tend to tell people to read manuals for things that I actually learned first by example.  'tar' is an example of this; for a while I had invocation instructions in my home directory.

[06:09] <ayrnieu> an instance.

[06:13] <KingDillyDilly> I'm half way towards having a Unix philosophy (classic, no GUI Unix). A pretty graphical interface isn't so important, but it still has to have usability, and TAR wasn't usable enough for me.

[06:14] <KingDillyDilly> And it just takes the right text. Too bad programmers don't analize the words they use as much as their computer programs. Or even half as much. I often do.

[06:14] <arcady> the benefit of the unix way is that you CAN wrap tar however you want, relatively easily

[06:15] <KingDillyDilly> I don't want to. I want it done for me.

[06:15] <scook0> ... and the failure of the unix reality is that you may have to :P

[06:20] *** scook0 joined
[06:48] <aufrank> is : ever a twigil?

[06:48] <aufrank> does $:a mean something?

[06:52] <scook0> aufrank: I think at one stage it had something to do with pairs or named args, but that's probably been dropped

[06:52] * aufrank will have to look at the twigil table again tomorrow

[06:54] <scook0> aufrank: I don't see $: in the latest S02 (21 Apr)

[06:55] <scook0> :$foo means :foo($foo) [S06], and at one point I think it used to be $:foo

[06:56] <scook0> $:foo is probably unused (but that might be a good thing)

[06:58] <aufrank> scook0: yeah, the :$foo form posted to the list today made me wonder about $:foo

[06:58] <aufrank> I thought it might have been one of the within-object twigils

[06:58] <aufrank> like $.foo

[07:00] *** ntgrl joined
[07:02] <scook0> maybe ... but then private became `!`, so it's now $!foo (or self!foo)

[07:02] <aufrank> yeah, that jives with what I remember

[07:04] <audreyt> TimToady: surely "let" and "temp" are also declarators? they does not affect the pad, but should prolly be parsed the same

[07:06] <aufrank> can anyone give a use case of the .= form of method calls?

[07:06] <audreyt> @arry .= sort;

[07:07] <audreyt> $moose .= chomp;

[07:07] <TimToady> audreyt: if it makes sense, sure.  The lists weren't not meant to be exhaustive, which is why I used "include"

[07:07] <audreyt> TimToady: k, cool

[07:07] <aufrank> heh.  I guess that ones a win

[07:07] <aufrank> s/ones/one's/

[07:08] <scook0> my Dog $spot .= new;

[07:08] <TimToady> ?eval my @array .= sort;

[07:08] *** evalbot_10053 is now known as evalbot_10054

[07:08] <evalbot_10054> Error:  unexpected ";" expecting word character, "::", dot, ":", "(", comment, block construct, identifier, term, term postfix or operator The .= operator needs a type specification.

[07:08] <TimToady> ?eval my @array.=sort

[07:08] <audreyt> *nod* it's statement_control:<my> now ;)

[07:08] <audreyt> which is wrong

[07:09] <evalbot_10054> Error:  unexpected end of input expecting word character, "::", dot, ":", "(", comment, block construct, identifier, term, term postfix or operator The .= operator needs a type specification.

[07:09] <audreyt> TimToady: can I go ahead and add temp/let?

[07:09] <aufrank> "if you're looking for a mathematical vector product, this isn't where you'll find it"

[07:09] <TimToady> sure, as long as you point out that they don't actually declare variables.

[07:09] <aufrank> is there somewhere w/in perl 6 that I will find a vector product?

[07:10] <TimToady> not currently.

[07:10] <TimToady> (that I know of, anyway)

[07:11] <TimToady> doubtless the PDL folks will have one or two hanging about eventually...

[07:11] <audreyt> actually, per S06,

[07:11] <audreyt> temp ($x, $y) = (1,2);

[07:11] <audreyt> is currently unspecced

[07:12] <audreyt> but that's probably useful

[07:12] <aufrank> it'd be nice to get a @@outer_product out of @col_vec by @row_vec

[07:12] <TimToady> It's not clear to me that signature is a good default arg.

[07:12] <aufrank> but yeah, I reckon it'll show up when the pdl folk do

[07:13] * aufrank doesn't know who in the community actively works on PDL

[07:13] <TimToady> we've certainly left sufficient bait in S09 for the pdlers.

[07:13] <aufrank> are any of them involved in p6 development?

[07:13] <audreyt> TimToady: it works the same for single-args though

[07:13] <aufrank> yeah, I've been waiting for someone to rise to it

[07:13] <audreyt> what this prevents you from doing is

[07:13] <audreyt> temp 1 = 3;

[07:13] <audreyt> and define Int.TEMP

[07:13] <TimToady> how is that different from ordinary assignment?

[07:13] <audreyt> but I don't see a big loss there

[07:14] <audreyt> oh sorry .I mean

[07:14] <audreyt> temp 1;

[07:14] <audreyt> without the assignment.

[07:14] *** KingDiamond joined
[07:14] <TimToady> P5 still treats it as an lvalue.

[07:14] <audreyt> per current S06 it's legal

[07:14] <audreyt> because temp takes an objec

[07:15] <audreyt> and triggers .TEMP at end of scope

[07:15] <audreyt> and do nothing more.

[07:15] <audreyt> I still think it should take Sigs forms

[07:15] <TimToady> maybe temp only works on mutable objects.

[07:15] <audreyt> temp ($x, $y);

[07:15] <audreyt> # not mutable

[07:15] <TimToady> distributes to two mutable objects

[07:16] <TimToady> ($x, $y) = 1,2

[07:16] <aufrank> declarators take sigs, not seqs right?

[07:16] <TimToady> have to be mutable anyway.

[07:16] <TimToady> sure, but these aren't declararing anything really

[07:17] <TimToady> they're just instructing a mutatable object to start a transaction.

[07:18] <TimToady> sides, you can temporize methods, and those are *illegal* in sigs.

[07:18] <TimToady> they're just lvalues

[07:19] <KingDillyDilly> I edited Wikipedia's article ( http://en.wikipedia.org/w/index.php?title=Perl_6&curid=1146638&diff=49551766&oldid=49521898 ) and quoted this channel, including people's handles ( http://en.wikipedia.org/wiki/Talk:Perl_6#Back_to_Regexes ). Just want to make sure that's ok. Are the IRC logs for this channel permanent?

[07:22] <audreyt> TimToady: ok, I'll check in that.

[07:24] <audreyt> r8908

[07:24] <TimToady> thanks, KingDillyDilly.  I note that there are some other things that have suffered "design rot" too.  Couple places where they seem to think <{...}> is an assertion, for instance, when it should be <?{...}>.

[07:25] <audreyt> KingDillyDilly: yes, irc.pugscode.org

[07:26] <KingDillyDilly> Well, unless there's an HTML element within those angle brackets, I know nothing about it.

[07:27] <KingDillyDilly> Should I replace every instance of <{...}> with <?{...}> ? Literally?

[07:28] * KingDillyDilly is into Wikipedia because I shamlessly plug several of my webpages there and want to give something back

[07:29] <audreyt> TimToady: *func() runs func under list context?

[07:29] <TimToady> I would think so.

[07:29] <audreyt> mm

[07:29] <audreyt> because the S06-capture design has that

[07:30] <audreyt> my $moose = \(*@x, *@y);

[07:30] <audreyt> does not really flatten @x, just cast them into captures

[07:30] <audreyt> and *$pair would expode that into named

[07:31] <audreyt> so, either *func provides a Capture-item context, or its use inside \() expressions is not the same as outside

[07:31] <TimToady> KDD: there are only two <{...}> that should be <?{...}>, I think.

[07:32] <KingDillyDilly> IE only found one.

[07:32] <audreyt> (also we have "list" prefix listop to do that)

[07:32] <audreyt> the flattening that is

[07:33] <audreyt> because if * only confers flattening

[07:33] <TimToady> but the whole point of capture is to do the same thing a normal function arglist would do...

[07:33] <audreyt> then *$pair can't be made to work

[07:33] <audreyt> yes. which is why I think *$foo should be caster into Capture, not caster into List

[07:33] <audreyt> and "list" should be caster into List

[07:34] <audreyt> in, *func(), if func has

[07:34] <audreyt> return(1,2,3)

[07:34] <TimToady> KDD, the first is Simplified code assertions: <{...}>

[07:35] <audreyt> that still works even if * confers item context

[07:35] *** kanru2 is now known as kanru

[07:35] <TimToady> the second is the second line of the example below

[07:35] <KingDillyDilly> I changed the only one my browser found...searching for the other...

[07:35] <TimToady> rx { ( ab* ) <{ $1.size % 2 == 0 }> }

[07:35] <audreyt> so I'm not sure what list context buys us here (this is re S03 change on C<*>)

[07:36] <audreyt> (also, does +func() confer Num or Int context?)

[07:36] <audreyt> probably num

[07:37] <KingDillyDilly> Done

[07:38] <TimToady> uh, what S3 change?

[07:38] <audreyt> ~ + ? * $ @ % &  ==>  Str Num Bool Capture Scalar Array Hash Code

[07:38] <audreyt> TimToady: in your last S3 change, you added <*> among the item-context consters but call it a list-context one

[07:39] <pasteling> "audreyt" at 220.135.90.73 pasted "S03 fix" (24 lines, 1.3K) at http://sial.org/pbot/16843

[07:39] <audreyt> er, never mind, I'm sorry

[07:39] <audreyt> that line was already here. :)

[07:40] <TimToady> reformatted para

[07:41] <audreyt> (still, I think * cannot confer list context now)

[07:41] <aufrank> audreyt: I see the point of going * is Capture context, but there's something to be said for the */** lazy/eager mnemonic

[07:42] <TimToady> but *func() in list context just falls out of the fact that func() always defaults to list if it doesn't know.

[07:42] <audreyt> right. where it matters is *$x

[07:42] <TimToady> I'm not sure we want to call func() lazily...

[07:42] <TimToady> but there it doesn't matter since we can do it lazily.

[07:43] <audreyt> so, would this work?

[07:43] <TimToady> certainly $x doesn't care if it's in list context.

[07:43] <audreyt> $x = (named => 'pair'); func(**$x);

[07:43] <TimToady> it's only *@a that might be a problem

[07:43] <TimToady> and *%a

[07:43] <audreyt> if %a is flattened, we get a list of pairs

[07:44] <audreyt> but func(*%a) and func(**%a) has them as named

[07:44] <audreyt> compared to *@a

[07:44] <audreyt> where func(*@a) always goes to positionals

[07:44] <audreyt> even if @a contains pair elements

[07:45] <audreyt> I think they should work the same as $x

[07:45] *** iblechbot joined
[07:45] <audreyt> (when holding an Array or Hash object)

[07:45] <TimToady> fine by me.  But ** is more list contexty than *, in a way.

[07:45] <audreyt> which means * couldn't flatten-to-list

[07:45] <audreyt> so, does ** simply mean "cast to Capture, but eagerly" in function args?

[07:46] <audreyt> or it's the eager list caster, and therefor **%a can't become named?

[07:46] <audreyt> I'm fine with the latter, but as aufrank noted, * and ** would be a bit different

[07:46] <TimToady> I'm fine with eager Capture.

[07:47] <audreyt> cool. that leaves room for lazy hashes in the future :)

[07:47] <audreyt> (lazy mappings, really; they can't be hash tables)

[07:47] <TimToady> novice: "What does that mean, 'Can't capture infinite list eagerly.'?"

[07:48] <TimToady> what did we decide about duplicate named args?

[07:48] <audreyt> they get bound according to Sig sigil

[07:48] <audreyt> @ gets all; others get last.

[07:48] <TimToady> right.

[07:49] <TimToady> could go with normal sigil gets last, and new @@ sigil gets all.

[07:50] <TimToady> though it's not the normal multidim situation...

[07:50] <audreyt> ok. then this running example

[07:50] <audreyt> push @foo, *$bar;

[07:50] <audreyt> would cease to work; you have to say $bar[], or @$bar

[07:50] <audreyt> three ways to do the same thing is a bit much anyway

[07:51] <audreyt> oh wait, if push has *@_ as last arg

[07:51] <audreyt> then it still works; infix:<push> is different from method push.

[07:52] <TimToady> infix?

[07:52] <audreyt> I mean, prefix:<push>.

[07:52] <TimToady> @foo push 1,2,3;

[07:52] <aufrank> reads alright.

[07:52] <audreyt> @foo.push(*$bar) # wouldn't work if $bar is a Hash... but maybe it's a feature

[07:52] <TimToady> arguably it's ,=

[07:53] <TimToady> which we've rejected several times.

[07:53] <TimToady> as to hard to tell from .=

[07:53] <TimToady> *too

[07:53] <aufrank> audreyt: wouldn't work because it would be a lazy Capture of named?

[07:54] <TimToady> %foo.push would presumably add pairs to the hash

[07:54] <TimToady> sorry, off on a tangent...

[07:54] <aufrank> %foo push *$bar # add pairs to the hash?

[07:55] <aufrank> heh, TimToady beat me to it

[07:55] <audreyt> aufrank: %foo.push(x => 1, y => 2);

[07:56] <audreyt> aufrank: right, and I presume Array.push wouldn't take nameds well

[07:56] <TimToady> I think we have to stick with * to deref as arglist and % to deref as hash object

[07:56] <aufrank> surely you could have an Array of Pairs as a data structure that you wanted to push to

[07:57] <audreyt> aufrank: but you'll use normal postfix [] or prefix @ for that

[07:57] <audreyt> which explicitly denotes arrayness

[07:57] <aufrank> fine, I guess I'll settle for two ways to do something I'll almost never do anyway ;)

[07:57] <audreyt> TimToady: the listfix= has a twist:

[07:57] <audreyt> $moose[] = @x;

[07:57] <TimToady> @pairs.push(%foo.pairs) if nothing else

[07:58] <meppl> guten morgen

[07:58] <aufrank> guten nacht

[07:58] <audreyt> TimToady: do we do a syntactic scan for postfix zen-slices as well?

[07:58] <audreyt> $moose[1,2,3] = @x; # this too

[07:58] <audreyt> TimToady: pugs has a screenful of code doing that analysis

[07:58] <audreyt> (but I think we can't get rid of them, right?)

[07:59] <TimToady> yes, that's interesting, but I think it has to do what the user expects.

[07:59] *** kanru joined
[07:59] <audreyt> ok. so for [] and {} before =, we need to do a heuristic scan

[07:59] <TimToady> and they'll certainly expect that to be a list assignment.

[07:59] <TimToady> if there are multiple subscripts

[08:00] <TimToady> we could probably get away with just saying it's list assignment if there's a subscript at all.

[08:00] <audreyt> and $moose[$foo[$blah[1]]] = ...context...

[08:00] <audreyt> context = scalar

[08:00] <aufrank> audreyt: with listfix= your example would have a copy of @x in slots 1,2, and 3 ?

[08:00] <audreyt> and $moose[$foo[$blah[1,2,3]]] = ...list...

[08:01] <audreyt> aufrank: nono, no way, it takes the first 3 elements of @x.

[08:01] <audreyt> TimToady: $moose[1] = @x; # too useful

[08:01] <TimToady> how often are people going to write loop ($a[0] = 1, $a[1] = 2; ...

[08:01] <aufrank> oh, got it

[08:01] <audreyt> otoh, maybe it's not that useful. hm. not sure

[08:02] <audreyt> p5 doesn't have this problem because it's shadowed by sigil variance :)

[08:02] <TimToady> yep.

[08:04] <TimToady> I think it is probably okay to train people that P6 subscripts like to pretend that they're lists.

[08:04] <TimToady> if you say $moose[@jaw] you going to get a slice.

[08:05] <audreyt> $moose[$antler] too.

[08:05] <TimToady> and it's just a little like the interpolate-ending-with-brackets rule

[08:06] <aufrank> what's the point of using the scalar container at all in that case?

[08:06] <audreyt> it's just a 1-slice, but for assignment purposes it still confers lists context

[08:06] <TimToady> On the other hand, there's probably some optimizations that depend on knowing you only are getting one value out of it.

[08:06] <audreyt> aufrank: actually, @moose[@jar] and @moose[$antler] works the same.

[08:06] <aufrank> right-- does $moose[@jar] buy you something that @moose[@jar] doesn't?

[08:07] <audreyt> TimToady: for those optimizations, s/one/statically known/ is good enough

[08:07] <audreyt> TimToady: so doesn't have to be oneness

[08:07] <TimToady> oneness lets you throw out the looping code.

[08:08] <audreyt> er, ok...

[08:08] <TimToady> you say you alredy have the code to do the analysis?

[08:08] <audreyt> yes

[08:08] <audreyt> inferExpCxt

[08:09] <audreyt> in src/Pugs/Eval/Var

[08:09] <TimToady> much to be said for inferring the expected context...

[08:09] <audreyt> it's the code luqui actively hates

[08:09] <audreyt> (which is why he put all of them into Eval.Var)

[08:09] <audreyt> and it's really heuristics

[08:09] <audreyt> based on (say) known calls to "list"

[08:10] <audreyt> and inferring return types for statically bound functions

[08:10] <audreyt> and recursively for [] and {} in it

[08:10] <TimToady> a mess, in other words

[08:10] <audreyt> yes.

[08:10] <audreyt> (but neccessary to preserve the p5 look-n-feel without sigil variance annotation)

[08:10] <KingDillyDilly> ...don't get me started on "say"

[08:10] <TimToady> how about a simple heuristic.  one number or scalar, it's scalar.  Otherwise assumes list

[08:11] <audreyt> TimToady: recursively for sure?

[08:11] <audreyt> $x[$y[1]]

[08:11] <aufrank> I would want a scalar there for sure

[08:11] <TimToady> that would seem wise.

[08:12] <aufrank> $x[$y<a>] too

[08:12] <TimToady> that's defined as a single element

[08:12] <TimToady> so yes.

[08:12] <aufrank> oh, right-- no list context anyway

[08:13] <audreyt> and by "scalar" you mean scalar literals, non- @ and % variables, and nothing else?

[08:13] <audreyt> even "undef"?

[08:13] <audreyt> (which is not a literal)

[08:13] <audreyt> or "rand"?

[08:13] <audreyt> (which is not a literal)

[08:13] <TimToady> any function goes list

[08:13] <audreyt> cool! deal

[08:13] <TimToady> except + or ~ ish things

[08:14] <audreyt> oh , er, heh

[08:14] <audreyt> how do  know those are special?

[08:14] <audreyt> by "proto"?

[08:14] <audreyt> (which fallsback to full analysis)

[08:14] <TimToady> I think people will be happier if we simply enumerate them.

[08:15] <TimToady> + is special inside [], and ~ is special inside {}.

[08:15] <audreyt> and -func() is

[08:15] <TimToady> and maybe vice versa

[08:15] <TimToady> ooh

[08:15] <audreyt> scalar

[08:16] <audreyt> has to be, otherwise $x[-$moose] is gone

[08:16] <TimToady> negation is kind of important for subscripts.

[08:16] <TimToady> kinda goes with +

[08:17] <scook0> it sounds like this "scalar inference" is getting too complicated for its own good

[08:17] <audreyt> scook0: it's currently full try-binding inference

[08:17] <audreyt> which is even more costly (and one of the reason of pugs's runtime slowness in profiles)

[08:17] <audreyt> TimToady: so

[08:18] <audreyt> $x[-$moose] = @foo; #scalar

[08:18] <audreyt> $x[$match.from] = @bar; # list

[08:18] <audreyt> (it's the second one that prompted full try-binding inference)

[08:18] <audreyt> and you have to disambiguoate with

[08:18] <audreyt> $x[+$match.from] = @bar;

[08:19] <TimToady> $x[$match.from] = +@bar too

[08:19] <audreyt> or (scalar @bar)

[08:19] <audreyt> but anyway, yeah.

[08:20] <TimToady> I don't suppose we can delay it till we actually know how many

[08:20] <scook0> what would happen if you made scalar subscripts the default, and introduced some kind of statically-visible "marker" for slicing?

[08:20] <audreyt> TimToady: can't, it's parsetime

[08:20] <audreyt> TimToady: this wasn't an issue when listop= wasn't there

[08:20] <TimToady> oh right, we just did that... dud

[08:20] <TimToady> duh

[08:20] <audreyt> TimToady: but now it is, my dynamic inference has to be lifted into parser

[08:20] <audreyt> which has significantly fewer info

[08:21] <audreyt> scook0: like @{$hash}{func()}?

[08:21] <audreyt> I believe someone tried that

[08:21] <audreyt> didn't work too well :)

[08:21] <TimToady> parse as list, capture, then revert to assignment semantics?

[08:21] <audreyt> TimToady: revert at runtime?

[08:22] <audreyt> $x[moose()] = 3, 4, 5;

[08:22] <TimToady> based on 1 vs many subscripts

[08:22] <audreyt> not sure it can work

[08:23] <audreyt> pretty sure it can't :)

[08:23] <audreyt> I think it's a parsetime decision, and it's either proto-lookup or enumerated forms

[08:23] <audreyt> (or both, heh)

[08:23] <audreyt> but enumerated forms feels cleaner

[08:24] <TimToady> how 'bout [1] [$x] [+anything] [-anything] is scalar, all else list

[08:24] <audreyt> and I suspect slices are rarer in practice than singulars

[08:24] <TimToady> maybe with recursive subscripts

[08:25] <audreyt> sure, but another idea is [@x] [list y] [any,] is a list, everything is scalar

[08:25] <audreyt> *everything else

[08:25] *** Southen joined
[08:25] <audreyt> (if slices are rarer, then that'd be more natural)

[08:26] <audreyt> (and again with recursive subscripts)

[08:26] <scook0> audreyt: that's closer to what I had in mind with my earlier suggestion

[08:26] <audreyt> scook0: *nod*

[08:26] <scook0> after all, what about @[$base + $offset]

[08:26] <audreyt> yeah. I think list forms are more syntatcically distinct

[08:26] <audreyt> than scalar forms

[08:26] <TimToady> have to include ..

[08:27] *** KingDillyDilly left
[08:27] <audreyt> right

[08:27] <TimToady> ; is pretty good indication too...

[08:27] <audreyt> $x[@list.reverse,] = ...

[08:27] <audreyt> $x[@list.reverse;] = ...

[08:27] <audreyt> both works

[08:28] <TimToady> $x[*@list.reverse] :)

[08:28] <audreyt> that isn't guaranteed to work :)

[08:28] <audreyt> but sure, we can statically detect that

[08:29] <audreyt> and get the capture object and deref with all its positionals

[08:29] <audreyt> that's fine

[08:29] *** larsen joined
[08:30] <audreyt> nobody will deref an array using a pair anyway.

[08:30] <TimToady> I mislike the trailing comma for visualness

[08:31] <audreyt> you can allow prefix semi.

[08:31] <audreyt> $x[;@list.reverse]

[08:31] <audreyt> a zen followed by anything

[08:31] <audreyt> is just anything

[08:31] <audreyt> zen is identity here.

[08:31] <aufrank> audreyt: what is the zen jargon standing in for here?

[08:31] <TimToady> except if you do have a multidimensional array, that means "all of the first dimension"

[08:31] <audreyt> aufrank: $x[] is a zen slice; you give it nothing and get back everything

[08:32] <aufrank> cute :)

[08:32] <TimToady> "make me one with everything"  could just be a hot dog

[08:32] <audreyt> TimToady: I thought $x[1;2;3] is just sugar for $x[1][2][3]

[08:32] <audreyt> and if you have a multidim, $x[][1][2][3] gets you the same thing

[08:32] <audreyt> am I mistaken?

[08:33] <TimToady> I think you're okay.  If you really wanted to splat the first dim you'd say $x[*;1;2;3]

[08:33] <audreyt> right

[08:33] <audreyt> so prefix ; becomes natural disambiguator

[08:33] <TimToady> well, I don't know as I'd go as far as to call it natural.

[08:34] <aufrank> time for this one to sleep

[08:34] <TimToady> and in a sense, it's not really right, because $x[;$y] is still a single element, presumably.

[08:34] <audreyt> yeah. if we make it to mean list, it'd be hijacking the meaning

[08:34] <audreyt> so nvm. hm.

[08:34] <aufrank> sorry to butt in on the adults while they're trying to work =P

[08:35] <TimToady> nite aufrank.  thanks.

[08:35] <audreyt> aufrank: sleep well :)

[08:35] <audreyt> so, I have less problem with $x[$y,] = ...

[08:35] <audreyt> because , still appears before =

[08:35] <audreyt> but I agree prefix denotation may look better

[08:36] <audreyt> $x[($y)] = ... # ok, bad idea.

[08:36] <audreyt> (but kinda goes with the lvalue visual marker)

[08:36] <TimToady> unless you want to use the same rules you use for lhs in general.

[08:36] <audreyt> yeah.

[08:36] <TimToady> great minds...

[08:36] <audreyt> sick minds, more like, but thanks :)

[08:36] * audreyt thinks some more

[08:36] <TimToady> the two are not mutually exclusive.

[08:37] <TimToady> something before the [] maybe.

[08:37] <audreyt> there is no general-purpose circumfix scalar

[08:37] <audreyt> context marker

[08:37] <audreyt> hm

[08:37] <TimToady> $x() is going to run into role conflicts...

[08:38] <audreyt> I think so far I like $x[($y)] better than $x[+$y]

[08:38] <audreyt> and default-item, make provision to list and tuple forms

[08:38] <TimToady> I should probably sleep on it.

[08:38] <audreyt> sure. doesn't have to be fixed today :)

[08:38] <audreyt> I'll commit the C<*>-not-producing-list-anymore fix.

[08:39] <TimToady> k

[08:39] <TimToady> this time maybe I won't try going to sleep with one eye on the IRC screen... :)

[08:40] <audreyt> :D

[08:40] <TimToady> anything else need deciding soon?

[08:40] <audreyt> sleep well, TimToady :)

[08:40] <audreyt> no, that's the only fallout I see from the parsing changes

[08:40] <audreyt> nonparsable = showstopper :)

[08:40] <TimToady> okay, g'nite, and thanks.

[08:40] <TimToady> &

[08:40] <audreyt> ditto :)

[08:41] <meppl> good night timtoady

[08:44] *** xern joined
[08:48] <TimToady> .zZ( $x.*[foo()] = @foo )

[08:51] <audreyt>     my @x = [1..2, 3..4];       # @x has 4 elements

[08:51] <audreyt>     my @y = [*(1..2), *(3..4)]; # @y has 2 elements

[08:51] <audreyt> is the natural consequence

[08:51] <audreyt> somehow I don't think it's a great problem :)

[08:52] <audreyt> (that is, outside argument lists (same place where x=>y means a Pair literal), * still doesn't become a list)

[08:52] <audreyt> s/same/=same/

[09:00] *** DaGo joined
[09:03] *** meppl joined
[09:06] <audreyt> so, why do we need unary =

[09:06] <audreyt> when we can say

[09:06] <audreyt> for @$fh -> { ... }

[09:06] <audreyt> ?

[09:06] <audreyt> :)

[09:07] <audreyt> (MJD will be happy)

[09:07] <audreyt> (as the Tie::File author, that is)

[09:08] <audreyt> and then, = can mean "next" always

[09:08] <audreyt> say =$fh; # always just one line

[09:08] <audreyt> say @$fh; # always all lines

[09:08] <audreyt> and the same iterating concept can be used to everything

[09:09] <xinming> yeap, then, = means lazily, and @$fh means eagerly... :-)

[09:09] <audreyt> well, not really

[09:09] <audreyt> both means lazily

[09:09] <xinming> audreyt: is ** and * dead?

[09:09] <xinming> ...

[09:09] * xinming is confused...

[09:09] <audreyt> what I'm proposing is that =$fh  always return the next item

[09:09] <audreyt> like perl5's each(%foo) or readline($bar)

[09:09] <xinming> yes

[09:10] <audreyt> and if you want a lazy stream of all items

[09:10] <audreyt> use @$fh

[09:10] <audreyt> for @$fh -> $line { ... }

[09:11] <xinming> audreyt: do you mean? a whole file will slurp into a "line" ?

[09:11] <audreyt> no... remember

[09:11] <audreyt> for 1..100 -> $line { ... }

[09:11] <audreyt> so it iterates one by one

[09:11] <audreyt> but

[09:11] <audreyt> for =$fh -> $line { ... }

[09:11] <audreyt> will only run once

[09:11] <audreyt> under my proposal

[09:11] <audreyt> so you won't usually use it.

[09:12] <audreyt> (you still will use it when you want to read a line only)

[09:13] <xinming> how about @$fh?

[09:13] <audreyt> for @$fh -> $line { ... }

[09:13] <audreyt> will then run the loop once for each line

[09:13] <audreyt> for *@fh -> $line { ... }

[09:13] <audreyt> will read every line first

[09:14] <audreyt> pack it up into "for"'s argument list

[09:14] <audreyt> just like

[09:14] <audreyt> for '1', '2', '3' -> $line { ... }

[09:14] <audreyt> I think it makes some sense.

[09:15] *** DaGo joined
[09:15] *** xern joined
[09:15] *** iblechbot joined
[09:15] *** p5evalbot joined
[09:15] *** stevan_ joined
[09:15] *** pdcawley joined
[09:15] *** turrepurre joined
[09:15] *** Toaster joined
[09:15] *** TimToady joined
[09:15] *** Aragone joined
[09:15] *** mako132 joined
[09:15] *** nothingmuch joined
[09:15] *** dvtoo joined
[09:15] *** chip joined
[09:15] *** chihchun joined
[09:15] *** pasteling joined
[09:15] <audreyt> or even

[09:15] <audreyt> I mean for *$fh, sorry

[09:15] <audreyt> there is no @fh :)

[09:15] <audreyt> for *$fh -> $line { ... }

[09:16] <audreyt> makes an eager loop, just like **$fh (that's the spec)

[09:19] *** penk joined
[09:20] *** lumi joined
[09:21] <xinming> I understand * and **, but I saw you use @$fh instead of *, So I wonder what that does... :-)

[09:21] <audreyt> xinming: wait me a bit, I'll commit to S03 the * changes

[09:22] <audreyt> it's a conjecture, it's not spec yet

[09:22] <audreyt> (if ever)

[09:22] <audreyt> I was wondering why we still need context-sensitive readline, and why we can't use @$fh and =$fh explicitly as two forms

[09:26] <xinming> I can understand what * in front of many things, eg a capture.  Which means * will be flaten....

[09:26] <xinming> audreyt: But I wonder What's the difference between *$fh and @$fh

[09:27] *** turrepurre_ joined
[09:28] *** chris2 joined
[09:28] *** p5evalbot joined
[09:28] *** chip joined
[09:29] *** pdcawley joined
[09:29] <audreyt> xinming: if $fh contains 100000 lines

[09:29] <audreyt> =$fh will not consume that many lines

[09:29] <audreyt> in a for loop

[09:30] <audreyt> and *$fh is specced to read that many lines first

[09:31] <xinming> hmm,

[09:31] * xinming wonders, is @$fh same as *$fh ?

[09:32] <audreyt> currently it's illegal

[09:32] <audreyt> I was proposing using it as a replacement to list-context =$fh.

[09:32] <audreyt> and have =$fh always mean scalar-context =$fh

[09:32] <audreyt> it's unrelated to *$fh :)

[09:37] <audreyt> another idea is to have *$fh read lazily

[09:37] <audreyt> and **$fh read eagerly

[09:37] <audreyt> and forget about = in list context altogether.

[09:37] <audreyt> that seems to work better

[09:38] <xinming> audreyt: how about @ ?

[09:39] <audreyt> then we don't need @

[09:39] <audreyt> since @$fh would mean you can assign back to it

[09:39] <audreyt> @$fh = (1,2,3);

[09:39] <audreyt> # clobber the file so it become 3 lines

[09:39] <audreyt> which is why I said it will make MJD happy

[09:40] <audreyt> but maybe too magical.

[09:40] <xinming> my $a = (1,2,3); @$a; --->  my @a = (1,2,3); @a; these two are the same IMO.

[09:40] <audreyt> that is correct.

[09:40] <audreyt> the only difference is that in the first case

[09:40] <audreyt> you can't push into @$a

[09:41] <audreyt> or say

[09:41] <audreyt> @$a = ();

[09:41] <audreyt> if you want to do that, you'll have to say

[09:41] <audreyt> my $a = [1,2,3]

[09:41] <xinming> a bit complicated. :-)

[09:41] <audreyt> yeah, but it was always very strange hwen (...) can magically turn into [...] :)

[09:41] <audreyt> that strangeness is now gone

[09:42] <audreyt> (1,2,3) is always a list and you can't extend it or delete from it

[09:42] <xinming> [] means list, () means capture. { } means hash?

[09:42] <audreyt> [1,2,3] is always an Array and you can do whatever you want

[09:42] <xinming> or () == tuple...

[09:42] <audreyt> well, in this case () doesn't mean anything

[09:42] <audreyt> you can say

[09:42] <audreyt> my @a = 1,2,3;

[09:42] <audreyt> my @a = (1,2,3);

[09:43] <audreyt> and they mean the same thing now

[09:43] <audreyt> (as of yesterday)

[09:43] <xinming> so () is gone...  and () is only for group and other thing, right?

[09:44] <xinming> audreyt: my @a = [1,2,3]; ==>  @a contains  [1,2,3], ?

[09:44] <audreyt> () is always just for grouping...

[09:44] <audreyt> xinming: no, @a will contain one element

[09:44] <xinming> instead of 1,2,3?

[09:44] <xinming> audreyt: ???

[09:44] <audreyt> yeah

[09:45] <audreyt> because those are actually two different operators :)

[09:45] <xinming> which do you "yeah" for please? :-/

[09:45] <audreyt> there is scalar=, and there is list=

[09:45] <xinming> [1,2,3], or 1,2,3 ?

[09:45] <audreyt> @a = [1,2,3]; # list=; @a.elems is 1

[09:45] <audreyt> $a = [1,2,3]; # scalar=; $a.elems is 3

[09:46] <audreyt> because list= turns [1,2,3] into

[09:46] <audreyt> ([1,2,3],)

[09:46] <xinming> :-)

[09:46] <audreyt> i.e. a List containing one Array

[09:46] <audreyt> and scalar= do no such thing

[09:47] <xinming> hmm,

[09:48] <xinming> my $a = 1,2,3;  so $a contains 1,2,3   but why can't we make it act as a list?

[09:48] * xinming still lives in reference... :-/

[09:49] <xinming> I mean modify the data in $a.

[09:50] <Juerd> xinming: That's still (my $a = 1), 2, 3

[09:50] <Juerd> That's why you need the parens.

[09:52] <xinming> Juerd: ok, my $a = (1,2,3); but I don't understand why can't we push something in to $a... :-/

[09:53] <audreyt> xinming: because $a will contain a List object, and you can't push into lists :)

[09:53] <audreyt> or assigning into it.

[09:53] <audreyt> as a whole, I mean.

[09:53] <audreyt> (assigning into its members are fine as long as those members are mutable)

[09:53] <audreyt> so

[09:54] <audreyt> $a = 4;

[09:54] <audreyt> is fine

[09:54] <audreyt> but

[09:54] <audreyt> $a = (1,2,3); @$a = 4;

[09:54] <audreyt> would be bad

[09:54] <audreyt> $ perl

[09:54] <audreyt> (1,2,3) = 4

[09:54] <audreyt> Can't modify constant item in list assignment at - line 1, at EOF

[09:55] <xinming> hmm, so ,this list object is static compiled into the bytecode?

[09:55] <audreyt> yes.

[09:57] <xinming> my $a = (1..100000),  will (1,2,3,4,5,6,7,8,9...100000) compiled as bytecode? :-)

[09:57] <xinming> if so, if someone ask for a program larger than 100M, It's easy to do in perl 6. :-)

[09:59] <xinming> (1..100) <-- will this create a list object?

[10:01] <audreyt> xinming: that's a Range object :)

[10:02] <audreyt> which can be seen as a List

[10:02] <audreyt> I'll bbiab...

[10:03] <audreyt> TimToady: never mind the *$fh doesn't flatten part

[10:03] <audreyt> in

[10:03] <audreyt> @x = [*$moose]

[10:03] <audreyt> $moose is still exploded as arguments to circumfix:<[ ]>

[10:03] <audreyt> so it still does what one expect it to do

[10:04] <audreyt> and if we have

[10:04] <audreyt> $foo = \(3, :by(3);

[10:04] <audreyt> $foo = \(3, :by(3));

[10:04] <audreyt> then

[10:04] <audreyt> 0..*$foo;  # 0, 3

[10:04] <audreyt> which manes *$fh in statement_control:<for> always work.

[10:04] <audreyt> raised that on p6l; noncontrovertial cleanup committed to S03

[10:05] <audreyt> be back in an hour.

[10:13] *** elmex joined
[10:19] *** pdcawley_ joined
[10:30] *** pmurias joined
[10:30] <pmurias> hi

[11:07] *** dvtoo joined
[11:10] *** turrepurre joined
[11:26] <Toaster> wow, it's a fantabulously nice day outside

[11:26] * Toaster throws down keyboards and heads out

[11:27] *** merlyn joined
[11:41] *** avar joined
[12:13] *** iblechbot joined
[12:18] *** ghenry joined
[12:33] *** macroron joined
[12:40] *** macroron__ joined
[13:14] <audreyt> gaal: packrat is fun

[13:16] <audreyt> gaal: it is very space intensive without lazy eval

[13:17] <audreyt> and now that rules commit by default...

[13:18] <audreyt> perl6 is made very predictive

[13:18] *** fglock joined
[13:18] <audreyt> it is a lot of fun though.

[13:19] <audreyt> but I'm not convinced that dynamic ambiguoation resolution via infinite lookahead can by us much in parsing perl6 itself.

[13:19] <audreyt> it has a lot of potential in optimizing :panic though

[13:19] <audreyt> basically making regexes as fast as rules

[13:19] <audreyt> just pay in space cost

[13:20] <audreyt> the XTC folks has a pretty solid implementation in Java called Rats!

[13:21] <cognominal> XTC?

[13:21] <audreyt> http://cs.nyu.edu/rgrimm/xtc/

[13:21] <audreyt> "making regexes as fast as rules" is a big win

[13:21] <audreyt> but designing a language based on it

[13:22] <audreyt> is another matter

[13:22] <audreyt> if we adopt packrat, all it buys us is whitespace irrelevance

[13:22] <audreyt> i.e. all the disambiguated-by-whitespace places can disappear

[13:22] <audreyt> say 1<2; # would be fine again

[13:22] <audreyt> and not much else.

[13:23] <audreyt> and the cost for it is a space penalty (linear to number of subrules)

[13:24] <audreyt> as well as making it harder to teach newbies

[13:24] <audreyt> since their eyes must also backtrack

[13:24] <cognominal> audreyt: I think that a objectified siva is indeed possible by hanging a parrotobjet on it. by chance (or desing), at the PIR level attribute accesses use (set/get)__attributes  even if they use arrays/hashes at the pmc level.

[13:24] <audreyt> cognominal: I think it's by design

[13:24] <cognominal> that means I should get away by redirecting these calles to the underlying object.

[13:25] <cognominal> I hope to have something working at the end of the week-end

[13:25] <audreyt> on the other hand, making "1<2" work does seem like a win.

[13:25] <audreyt> pugs currently (erroneously!) recognizes it

[13:25] <audreyt> but once we switch to optable, that will be gone

[13:25] <audreyt> and I think I'm going to miss that.

[13:26] <cognominal> I am thinking about a micro language that would be a cross of a simplified perl6 and e4x, to manipulate trees (that is ASTs).

[13:27] <audreyt> (background: packrat is a way to memoize redundant backtracks and guarantee linear time for fully backtracking regexes)

[13:27] <audreyt> cognominal: I think I'm doing the same, so let's gobby up.

[13:27] <cognominal> and could control how the bits are layed out in the underlying objectified siva

[13:27] <cognominal> gobby?

[13:27] <audreyt> are you on mac or nonmac?

[13:27] <cognominal> ho

[13:28] <cognominal> the editor?

[13:28] <audreyt> yeah

[13:28] <cognominal> go for it

[13:28] <audreyt> the collaborative editor

[13:29] <cognominal> join on sterfp.dyndns,org

[13:30] <fglock> audreyt: can I declare a rule with parameters:   rule balanced ( $start, $end ) {  $start .*? $end }

[13:30] <audreyt> fglock: yes you can.

[13:31] <audreyt> pmichaud has the syntax

[13:31] <audreyt> <balanced: 1, 2>

[13:31] <audreyt> to call it from other places

[13:47] <audreyt> cognominal: connectino lost

[13:47] <cognominal> oops my bobby exploded

[13:47] <cognominal> save the files please

[13:48] <cognominal> I don't know if I can get them back

[13:49] <audreyt> I've read the FAQ now

[13:49] <audreyt> fascinating stuff

[13:50] <cognominal> can you connect and paste bili.pod?

[13:50] <cognominal> arf

[13:50] <audreyt> another crash

[13:50] <cognominal> crashed again

[13:50] <audreyt> sigh

[13:50] <audreyt> so much for technology

[13:51] <audreyt> you connect to perlcabal.org?

[13:51] <cognominal> ok

[13:51] <cognominal> were you able to save bili.pod?

[13:53] <audreyt> sure

[13:54] <cognominal> if you are interested I can mail you the text version of the e4x faqs

[13:54] <cognominal> it seems that big documents crashe gobby

[13:54] <audreyt> I already saved that too

[13:55] <audreyt> I think we have slightly different need for compilers than for generic xml processing

[13:56] <audreyt> for example, in "1+2", both side of the "+" node are parsed with the same subparser

[13:56] <audreyt> and so wouldn't quite make sense to index them by name

[13:56] <audreyt> i.e.

[13:57] <audreyt> the E4Xesque

[13:57] <audreyt> node.*.[0]

[13:57] <audreyt> feels rather verbose

[13:57] <audreyt> I'd rather just say $node[0].

[14:00] <xinming> audreyt perl6 is made very predictive     <--- what does this mean pleae?

[14:00] <xinming> s/pleae/please/

[14:01] *** bsb joined
[14:01] <audreyt> xinming: it means that you can generally know what a snippet of perl 6 text means

[14:01] <audreyt> without looking at the parts after it.

[14:02] <audreyt> for example

[14:02] <audreyt> 1<2

[14:02] <audreyt> or rather

[14:02] <audreyt> $x<2

[14:02] <audreyt> can only mean "dereferncing $x as a hash, passing a string beginning with 2 as param

[14:02] <audreyt> so if you see

[14:03] <audreyt> $x<2...

[14:03] <audreyt> without seeing ...

[14:03] <audreyt> a predictive grammar will not "backtrack"

[14:03] <audreyt> a backtracking grammar, like packrat's, can backtrack

[14:03] <audreyt> so

[14:03] <audreyt> $x<2;

[14:03] <audreyt> backtracks

[14:03] <audreyt> and now < means comparison

[14:03] <audreyt> not quoting anymore

[14:03] <xinming> so, which means, if we see $x<2  we could know that it is not comparison ?

[14:04] <audreyt> right!

[14:04] <audreyt> and when you see

[14:04] <audreyt> $x <2...

[14:04] <audreyt> you always know it _is_ comparison

[14:04] <xinming> $x < 2, then, It is comparison...

[14:04] <audreyt> yes

[14:04] <audreyt> this allows expresisons like

[14:04] <audreyt> $x<2;3;4;5;6;longstringhey>

[14:04] <audreyt> to be unambiguous to the human eye.

[14:05] * xinming thinks, perl 6 will scare many people who wish to switch python to perl 6.  :-)

[14:05] <audreyt> currently the pugs parser is backtracking

[14:05] <audreyt> so we can correctly parse one way or another

[14:05] <audreyt> depending on whether there is a closing >

[14:05] <audreyt> we pay for this in time and space cost

[14:05] <audreyt> packrat let us eliminate the time cost

[14:05] <xinming> hmm, so, backtracking isn't needed, right?

[14:06] <audreyt> but TimToady's point is that, by nonbacktracking, it also makes the language easier for humans.

[14:06] <audreyt> see the longstringhey example above.

[14:06] <xinming> for, $x<2, and $x < 2 example,  if it is predictive, then, backtracking is not needed, right?

[14:06] <audreyt> yes.

[14:08] *** BooK joined
[14:08] <xinming> $x<2;3;4;5;6;longstringhey> ...  --> (in backtracking circumstance) it will become ?($x<2); 3; 4; 5; 6; longstringhey> ...    :-)

[14:08] <xinming> I think I understand

[14:09] <audreyt> er, wrong

[14:09] <audreyt> in backtracking

[14:09] <audreyt> it becomes

[14:09] <audreyt> $x{'2;3;4;5;6;longstringhey'}

[14:09] <audreyt> but if you drop the >

[14:09] <audreyt> it becomes

[14:10] <audreyt> $x < 2; 3; 4; 5; 6; longstringhey

[14:10] <audreyt> so basically it means infinite lookahead

[14:10] <audreyt> which is naively exponential time

[14:10] <audreyt> which is why pugs parses slowly

[14:10] <audreyt> but packrat reduce that to linear time

[14:10] <audreyt> and linear (though large) space

[14:11] <audreyt> but I agree with TimToady that requiring infinite lookahead may not be good for humans.

[14:11] <audreyt> though it's very convenient

[14:11] <xinming> audreyt: did your see, ?($x<2) in my example... ? here, ?($x<2) what I mean is comparison. :-)

[14:11] <audreyt> oh ok

[14:11] <audreyt> yes

[14:11] <audreyt> so yeah, you do understand :)

[14:12] <xinming> audreyt: hmm, backtracking is good for writing JAPH program. :-)

[14:12] <audreyt> it is!

[14:15] * audreyt ponders the @array[{$_ < 3}] overhuffmanization for @array.grep:{$_ <3}

[14:15] <xinming> audreyt: what will be used to bootstrap perl6 do you think?

[14:15] <audreyt> xinming: perl 6

[14:15] <xinming> ...

[14:15] <audreyt> by definition :)

[14:15] <xinming> I mean the first perl 6. :-)

[14:16] <xinming> pugs or pX ?

[14:16] <audreyt> now, if you mean which implementation will bootstrap first...

[14:16] <audreyt> I have no idea XD

[14:16] <audreyt> probably a mixture of all three, or more.

[14:16] <xinming> I'm still in confusion about why can't pugs. I mean the one you write to write a compiler... :-/

[14:18] <audreyt> xinming: mostly because the part needed to write a compiler -- namely, structural unpacking, tree binding, etc, is not yet supported by pugs.

[14:18] <audreyt> so to use pugs-today to write a compiler will be... if not as painful as writing it in perl5, certianly comparable.

[14:19] * PerlJam wonders if fglock thinks of what he's doing as "painful"  :)

[14:20] * audreyt notes that the codegen and optimizers are more nontrivial

[14:20] <audreyt> and yet must be done somehow

[14:20] <pmurias> PerlJam: most of pX is written in DSL's

[14:20] <audreyt> fglock wrote the same parsing engine in perl6 too

[14:20] <audreyt> runnable by pugs

[14:20] <xinming> audreyt: how much is it completed about fglock's work?

[14:21] <PerlJam> pmurias: this is true.

[14:21] * xinming means about pX

[14:21] <audreyt> xinming: well... it still has yet to pass 01-sanity

[14:22] <xinming> ...

[14:23] <pmurias> xinming: lrep and lrep-compiler could run some primitive perl6, but were wiped out by api changes

[14:24] * xinming now understands that the first perl 6(not-official) won't be out until next year....(maybe longer...)

[14:25] <xinming> since audreyt made pugs for 1 year... :-/

[14:25] <audreyt> well, it's not _all_ my doing :)

[14:25] <audreyt> and perl6 today is far, far easier to implement

[14:25] <audreyt> than one year ago.

[14:25] <audreyt> (thanks primarily to the test suite)

[14:25] <audreyt> and also for sanity in Synopses

[14:26] <audreyt> or at least, consistency.

[14:26] * xinming found the sunlight through the darkness...

[14:27] <xinming> audreyt: so you mean, what they need to do currently is just write a compiler... and check it if it passed the test suite?

[14:27] *** lisppaste3 joined
[14:28] <audreyt> yes.

[14:28] *** justatheory joined
[14:30] <xinming> then, do you mean pX will implement perl 6? which the same is as pugs does.

[14:30] <xinming> but they(pugs and pX) still aren't perl 6. :-/

[14:31] *** enantiodrome joined
[14:32] * xinming gives up for trying to understand why perl 6 is so hard to implement... It's far beyond his knowledge...

[14:32] <PerlJam> xinming: I bet you that we have a perl6 before the end of this year

[14:33] <avar> PerlJam: perl6 as in..?

[14:33] <PerlJam> avar: as in *the* perl6.  (not final, ready for production, but certianly alpha quality)

[14:33] <audreyt> as in equivalent to Pugs 6.283.0

[14:33] <audreyt> I really doubt we can get the entire static analysis part figured out.

[14:33] <PerlJam> As in, does everything that the specs say it should

[14:34] <audreyt> since the typesystem part inthe spec is all speculative

[14:34] <audreyt> and the design space... is huge.

[14:34] <audreyt> but as a dynamic language, sure :)

[14:34] <fglock> is there a problem with the svn server? I'm getting "400 bad request"

[14:34] <merlyn> as long as you have prototypes and macros together with / being both divide and regex, you can't do static analysis

[14:35] <audreyt> merlyn: post-parsing analysis.

[14:35] <xinming> PerlJam: I know what you mean, But I don't think so. :-)

[14:35] <audreyt> also known as "optimizer"

[14:35] <audreyt> and "typechecking"

[14:35] <audreyt> and "inferencing"

[14:35] <merlyn> right.  presuming parsing includes the compile-time execution context

[14:35] <merlyn> as I brought up two days ago. :)

[14:35] <PerlJam> xinming: I will remain eternally optimistic ;-)

[14:35] <audreyt> yeah

[14:35] <audreyt> post-parsing analysis is certianly possible

[14:35] <audreyt> because we have compilation units

[14:35] <audreyt> and they can't affect each other's parsing

[14:36] <audreyt> it may even be neccessary

[14:36] <audreyt> for storage classes such as

[14:36] <audreyt> my int @x; @x[3]

[14:36] <audreyt> that must emit a different code than

[14:36] <audreyt> my Int @x;

[14:36] <audreyt> to support packed int arrays

[14:37] <xinming> PerlJam: But I hope you are right. :-) as I almost can't wait to use perl 6. :-)

[14:38] <xinming> PerlJam: pugs now can do many things, But it is too slow sometimes... that's why I want the self-hosting perl 6. :-)

[14:38] <audreyt> xinming: a major source of slowness is backtracking parser

[14:39] <audreyt> another major source is old, reference-based mutable containers

[14:39] <audreyt> another major source is using maps to emuulate hashes

[14:39] <xinming> :-)

[14:40] <audreyt> the first is now resolved by "rule" always being predictive

[14:40] <audreyt> by default

[14:40] <audreyt> and we'll switch to a optable-based parser

[14:40] <audreyt> and remove "try" in parsec

[14:40] <audreyt> the second is now resolved with Capture, first-class Lists, and death of references

[14:40] <audreyt> the third can be solved with Judy. I hope.

[14:42] <xinming> audreyt: do you believe, that perl 6 will scare many people who wish to learn the language... as their are too man differences compared perl 6 with many languages. :-)

[14:42] <audreyt> xinming: perl5 did that already

[14:42] <PerlJam> xinming: no more than perl5 scares people.

[14:42] <audreyt> I don't think p6 will be different

[14:42] <PerlJam> Though I think perl6 will scare more perl5 people than random newbies :)

[14:45] <xinming> audreyt: yes, but perl 5 isn't that hard to learn, as there are not many "rules" as perl 6 does.  eg,  $obj.    .doit()    and  your example above, $x <1  $x<1  :-)

[14:45] <xinming> and perl 5 is in relax mode by default... this is good for some newbies.... :-)

[14:46] <avar> xinming: mostly it isn't

[14:46] <audreyt> @{$moose}{3,4,5}

[14:46] <audreyt> $x = //;

[14:46] <audreyt> *$g->{CODE}

[14:47] <xinming> avar: hmm, new people will always forget the $x<1 if they mean comparison. :-)

[14:47] <audreyt> I can go on and on and on...

[14:47] <xinming> audreyt: :-)   <<My heart will go on>>

[14:47] <pmichaud> <fglock> audreyt: can I declare a rule with parameters: rule balanced ( $start, $end ) {  $start .*? $end }

[14:47] <pmichaud> <audreyt> pmichaud has the syntax

[14:47] <pmichaud> <audreyt> <balanced: 1, 2>

[14:47] <pmichaud> <audreyt> to call it from other places

[14:48] <pmichaud> actually, the syntax is  <balanced(1,2)> for multiple parameters.

[14:48] <pmichaud> the syntax <balanced: 1, 2>  is equivalent to <balanced('1, 2')>   (and is still conjectural in A05)

[14:48] <audreyt> mea culpa

[14:49] <pmichaud> np, just wanted to keep someone from having to backtrack later :-)

[14:49] <audreyt> (conjectural-in-A05 and nonexistent-in-S05 means probably it doesn't exist :))

[14:49] <audreyt> in specspace, that is

[14:49] <pmichaud> I asked TimToady about it yesterday and he said it was okay to leave it in and leave it as conjectural :-)

[14:49] <audreyt> heh.

[14:49] <audreyt> what's wrong with <balanced('1')>?

[14:49] <audreyt> longer to type?

[14:49] <pmichaud> it was one of the reasons he introduced the <<< ... >>> syntax

[14:50] <pmichaud> from a purely PGE perspective,  <balanced: ...> is slightly easier to parse

[14:50] <pmichaud> ultimately PGE will have to work with Perl 6 to be able to parse parameter lists

[14:51] *** FurnaceBoy joined
[14:51] <pmichaud> I have thought about updating PGE to parse constant parameter lists, however

[14:52] <audreyt> yeah, uniform syntax seems better...

[14:52] <audreyt> but I'm fine with the : form as well

[14:52] <pmichaud> so, <balanced(1,2)> and <balanced('1')> would be okay, but <balanced($foo[3])> isn't going to do much until there's a perl6 to help it along

[14:52] <audreyt> it just feels like another special case :)

[14:52] <audreyt> sure

[14:52] <pmichaud> and I may end up needing <balanced(delim=>';')> anyway.

[14:53] <audreyt> yeah. I thikn one autoquoter (=>) is one too many

[14:53] * pmurias goes out to read perlguts on a nice bench somewhere

[14:53] <audreyt> and another autoquoter, meh :)

[14:55] * avar likes autoquote;)

[14:55] <avar> my (eval => 5);

[14:55] <avar> eh, fleh

[14:56] * theorbtwo likes that autoquoter.

[14:56] * audreyt likes :eval(5) more... but well :)

[14:56] <audreyt> timtowtdi

[14:58] <theorbtwo> I'll probably use :eval(5) when thinking of adverbs, and eval=>5 when thinking of pairs, even though they're the same thing.

[14:58] <xinming> audreyt: tmtowtdi   <<==  I ever used timtowtdi, larry told me he always use "there's" rather than "there is" :-)

[14:58] <theorbtwo> ...just like unless (...) and if (!...) are.

[14:58] <audreyt> I think it may make sense to have it always mean adverb and pair

[14:58] <audreyt> so we can rid of the f((x=>1)) hack

[14:59] <audreyt> but then, there is too much p5 mental legacy

[14:59] <audreyt> in named=>'arg'

[14:59] <audreyt> so it wouldn't fly, sadly

[14:59] <pmichaud> I also chose delim=>';'  above because that's the parrot syntax

[14:59] *** aufrank joined
[14:59] <pmichaud> (for better or worse)

[15:00] <audreyt> <balanced(:delim<;>)>

[15:00] <audreyt> really reads much nicer to me :)

[15:00] <audreyt> but well, yeah, legacy and all that.

[15:00] <pmichaud> actually, in PGE I could just search for the closing paren and pass the whole thing directly to Parrot

[15:01] <pmichaud> er, PIR

[15:01] <pmichaud> whenever the hosting language != Perl 6

[15:01] <audreyt> not sure it buys you must

[15:01] <audreyt> as PIR ne nesting language

[15:01] <audreyt> pmichaud: have you seen http://perlcabal.org/~autrijus/tmp/p6.html ?

[15:01] <pmichaud> yes -- saw it in the backlog yesterday

[15:01] <pmichaud> very cool

[15:01] <merlyn> for some of us, "PIR" is "Portland International Raceway", and it's hard to shake the link

[15:05] *** macroron__ joined
[15:05] *** mago joined
[15:07] <xinming> could I have an account on perlcabal.org?

[15:08] <xinming> Or, It is internally use only. :-/

[15:08] <theorbtwo> xinming: cd docs; find -name feather

[15:13] <xinming> theorbtwo: yes, I've in that dir. :-) but I still don't know if I have an account on perlcabal.org  :-)

[15:16] <xinming> s/if I/if I can/

[15:18] *** reisio joined
[15:19] * xinming thinks he should ask Juerd. :-)

[15:19] *** Khisanth joined
[15:19] <audreyt> xinming: just mail to justatheory

[15:19] <audreyt> I mean, Juerd

[15:21] <xinming> audreyt: Ok.

[15:21] <aufrank> is @statements>>.compile the same as @statements.each.compile?

[15:21] <aufrank> (good morning!)

[15:21] <xinming> aufrank: I don't think so. :-)

[15:22] <audreyt> aufrank: it's @statements.map:{.compile}

[15:22] <audreyt> but doesn't guarantee order

[15:22] <xinming> for @statements -> $one { $one.compile };

[15:22] <aufrank> ok

[15:22] <aufrank> got it

[15:22] <xinming> audreyt: does for @ary guarantee order?

[15:23] <wolverian> yes.

[15:23] <audreyt> yes.

[15:23] <audreyt> >>.compile guarantee order-of-result but not order-of-evaluation

[15:24] *** dvtoo_ joined
[15:24] <xinming> audreyt: why not make it guarantee the eval order?

[15:24] <avar> xinming: for sp33d

[15:24] <xinming> audreyt: hmm, It's much more human-understandable IMO. :-)

[15:24] <xinming> avar: thanks.

[15:25] <avar> xinming: I can't imagine myself writing something like @arr>>.lc (or something) and caring about the order it happens in

[15:25] <cognominal> audreyt: in S02, the comment with user-selected bracket is incorrect? if I judge par the criteria (every opening user-select bracket must be close).

[15:25] <cognominal> s/close/closed/

[15:26] <audreyt> mrr?

[15:26] <cognominal> mrr?

[15:26] <audreyt> what do you mean?

[15:26] <cognominal> what does it means?

[15:26] <audreyt> For all quoting constructs that use user-selected brackets, multiple,

[15:26] <audreyt> adjacent, identical opening brackets must always be matched by an

[15:26] <audreyt> equal number of adjacent closing brackets.

[15:26] <audreyt> this?

[15:26] <xinming> avar: but how about this example?

[15:26] <cognominal> ho, I missed the word adjacent

[15:27] <cognominal> it should probably say that the example contains non adjacent brackets to better convey the idea

[15:28] <audreyt> patches to p6l :)

[15:28] <cognominal> oki

[15:28] <xinming> my @arry = ($a_object, $b_object, $c_object, $d_object); and we declared a multi to handle these 4 objects, which name is temporary mymeth, @array.mymeth should automatically handle these four type, but these 4 types need the right sequence... :-)

[15:29] <audreyt> xinming: @array.mymeth doesn't do that at all

[15:29] <xinming> avar: but maybe, This example is abit not correct. If it is in order, we then know to push them in order...

[15:29] <audreyt> what you described is

[15:29] <audreyt> mymeth(*@array);

[15:29] <avar> xinming: I have no doubts that my example doesn't compile, execute etc.;)

[15:29] <xinming> audreyt: I mean @array>>.mythem... :-)

[15:29] <audreyt> but that just means

[15:30] <audreyt> ($a.mymeth, $b.mymeth, $c.mymeth, $d.mymeth)

[15:30] <audreyt> and has nothing to do with multis

[15:30] <audreyt> if you mean

[15:30] <audreyt> f(*(@array>>.mymeth));

[15:30] <audreyt> only the result order is important

[15:30] <audreyt> and not the order of evaluation

[15:30] <xinming> audreyt: yes, they need order to be called... I mean, $a.mymeth first, and etc... etc...

[15:30] <audreyt> why?

[15:31] <audreyt> you can call $b.mymeth first.

[15:31] <audreyt> as long as it still occurs in the correct slot

[15:31] <audreyt> in the result list

[15:31] <audreyt> that is, if @array contains (1,2,3,4)

[15:31] <audreyt> and you do

[15:31] *** axarob joined
[15:31] <audreyt> @array >>.say;

[15:31] <audreyt> perl6 doesn't guarantee the order

[15:31] <audreyt> you may see

[15:31] <audreyt> 2

[15:31] <audreyt> 1

[15:31] <audreyt> 3

[15:31] <xinming> if $b.mymeth failed, then, $a.mymeth will fails...

[15:31] <audreyt> 4

[15:31] <audreyt> on your screen

[15:32] <audreyt> xinming: oh you mean that... well in that case, the multi will still guarantee that

[15:32] <xinming> audreyt: but people most want the ordered say... :-)

[15:32] <audreyt> well, in which case they use

[15:32] <audreyt> say for @array;

[15:32] <audreyt> or something like that.

[15:33] <audreyt> it's not like it's hard :)

[15:33] <audreyt> @array.map:{.say}

[15:33] <audreyt> map(&say, @array)

[15:33] <aufrank> audreyt: now is @array.each.say relevant?  or does this form not exist?

[15:34] <xinming> ....

[15:35] <xinming> audreyt: thanks... I know... why that doesn't guarantee order.. :-)

[15:35] <audreyt> aufrank: I don't know what it means...

[15:35] *** davidfetter joined
[15:35] <davidfetter> hello

[15:35] <aufrank> hello davidfetter

[15:35] <audreyt> aufrank: @array.each may mean =@array, that, iterating over array

[15:35] <audreyt> aufrank: but that will only print one number

[15:36] <xinming> perl 6 rocks...

[15:36] <davidfetter> i was talking w/flavio & he said to ask here

[15:36] <davidfetter> i'd like to see about a prototype pl/Perl6

[15:36] <merlyn> probably best to embed parrot

[15:36] <davidfetter> interesting

[15:36] <davidfetter> whom would i talk w/about that

[15:37] <audreyt> davidfetter: perl6-internals, also jhorwitz (Jeff Jorwitz) and leo (Leopold Totsch) in particular

[15:37] <fglock> audreyt: is it possible to embed Pugs?

[15:37] <audreyt> davidfetter: if you want to embed pugs in C-land, you can do that also; in that case, talk to clkao or me :)

[15:38] <audreyt> fglock: yes, libHSPugs.a is a shared lib

[15:38] <audreyt> and you can call "pugs_Eval" and "pugs_Apply"

[15:38] <audreyt> see src/perl5/pugsembed.h

[15:38] <audreyt> currently you need to link in p5 too

[15:39] <audreyt> because the Apply returns SV

[15:39] <audreyt> but it doesn't have to

[15:39] <audreyt> if someone has a use for it, we can easily expand the API :)

[15:40] *** axarob left
[15:40] <davidfetter> ok

[15:41] * davidfetter takes a look at mod_parrot...

[15:41] <audreyt> davidfetter: when you succeed in embedding parrot,

[15:41] <audreyt> you can link in pugs and use the mod_pugs interface

[15:41] <audreyt> (because pugs is a compreg)

[15:41] <audreyt> I mean, registered compiler in parrot

[15:42] <audreyt> or use parrot's trunk

[15:42] <davidfetter> hm. interesting. the C here is way, way over my head. i'm just a db weenie

[15:42] <audreyt> there's a languages/perl6/perl6.pbc

[15:42] <davidfetter> trunk? i thought elephant's had trunks

[15:42] *** KingDillyDilly joined
[15:42] <audreyt> which you can load and use the parrot-native, currently-minimal but udner-active-development, compiler

[15:43] <KingDillyDilly> What is it about 9:15 that makes people join this channel then?

[15:43] <audreyt> davidfetter: trunk means http://svn.perl.org/parrot/trunk/

[15:43] <audreyt> davidfetter: you can use "svn co http://svn.perl.org/parrot/trunk/" to get the latest parrot code

[15:44] <davidfetter> it's 12:43 here

[15:44] <davidfetter> maybe it's that 9:15 influence

[15:44] <xinming> 23:48 here...

[15:44] <KingDillyDilly> 11:44 here, but I'm talking about the times at http://colabti.de/irclogger/irclogger_log/perl6?date=2006-04-22,Sat

[15:45] * davidfetter sees whether he has svn on his mac...

[15:45] <KingDillyDilly> Thought those times might be clien side times.

[15:47] <KingDillyDilly> Hmmm... s/ht(.*)clien/h$1client/

[15:49] *** reisio left
[15:49] *** alec joined
[15:50] <KingDillyDilly> I was wondering if it's copycating, or if they're all on a network, or some client they all use that does that.

[15:52] *** Limbic_Region joined
[15:56] <aufrank> audreyt: totally off topic, feel free to ignore:  do you know how to prepare a breakfast food from .tw called dan bing?

[15:57] <audreyt> yes.

[15:57] <aufrank> any chance you'd mail me a recipe?  my girlfriend misses that in particular and I'd like to make it for her if I could

[15:59] <Limbic_Region> audreyt - when was the last time you built on Win32?

[15:59] * Limbic_Region has had a problem for about a week now but hasn't bothered to try nmake realclean before building

[15:59] * Limbic_Region is trying that now

[16:01] <audreyt> Limbic_Region: sorry, wasn't aware of that.

[16:01] <audreyt> I'll fix tomorrow... have to sleep soon

[16:01] <Limbic_Region> not your fault

[16:01] <Limbic_Region> I will confirm that it is still broke after a realclean make

[16:01] <Limbic_Region> and nopaste the error

[16:01] <Limbic_Region> so you can backlog

[16:01] <Limbic_Region> sleep well

[16:02] <aufrank> audreyt: I figured you must be fading, as it seems you've been here since I left last night :\

[16:02] <aufrank> get to bed!

[16:02] <davidfetter> g'night, aufrank

[16:03] <aufrank> no no, I'm just getting here!

[16:04] <KingDillyDilly> aaufrank: there's a dan bing recipe at http://mmm-yoso.typepad.com/mmmyoso/cooking/index.html

[16:07] *** mako132_ joined
[16:10] *** xerox joined
[16:20] *** xinming joined
[16:21] <pmurias> davidfetter: you want to embed parrot from c or perl5?

[16:22] <merlyn> C

[16:22] <merlyn> inside postgresql

[16:22] <davidfetter> using the SPI stuff

[16:22] <merlyn> I told him to look at mod_parrot as a potential example

[16:22] * davidfetter digs up a reference...

[16:23] <pmurias> i'll look at how mod_parrot does data exchange

[16:24] <davidfetter> http://www.postgresql.org/docs/8.1/static/spi.html <-- SPI

[16:24] <davidfetter> http://www.postgresql.org/docs/8.1/static/plperl.html <-- current PL/Perl usage

[16:27] <pmurias> davidfetter: you can also look at misc/pX/Inline-Parrot in the pugs repo if you are realy desperate (it's pretty minimal at the moment)

[16:28] * davidfetter is just in the idea stage of this project

[16:28] <audreyt> journal updated... good night for real :)

[16:28] <audreyt> &

[16:28] <aufrank> gnight audreyt

[16:29] <KingDillyDilly> Get that recipe, aufrank, or am I on ignore?

[16:30] <KingDillyDilly> Just like the good ol' days. I'd start a Perl6_Improved column if I knew anything about it.

[16:31] <aufrank> sorry KingDillyDilly, missed it

[16:31] <aufrank> found it now

[16:31] <aufrank> thanks for that :)

[16:32] <KingDillyDilly> :) Long page, but I didn't use the paste bin because there are pictures that might help.

[16:33] <KingDillyDilly> Anyone else need a recipe? That's about all I can help with here.

[16:33] *** dvtoo joined
[16:34] <Limbic_Region> audreyt - for backlog, still fails on realclean build

[16:34] <Limbic_Region> perlbot nopaste

[16:34] <perlbot> Paste your code here and #<channel> will be able to view it: http://sial.org/pbot/<channel>

[16:34] <pasteling> "Limbic_Region" at 24.35.57.240 pasted "Win32 build failure (for about the last week or so)" (29 lines, 1.5K) at http://sial.org/pbot/16851

[16:35] <xinming> Limbic_Region: She is in trance... :-P

[16:35] <Limbic_Region> heh

[16:36] <xinming> C:\Perl\bin\perl.exe here, we should use C:\\Perl\\bin\\perl.exe

[16:36] <xinming> otherwise, It can't found perl.exe

[16:36] <xinming> or you can use c:/perl/bin/perl.exe

[16:36] <xinming> this is nothing to say, except Windows sucks... :-)

[16:37] <xinming> hmm, sorry, I think I misunderstand that... :-/

[16:38] *** KingDiamond joined
[16:44] <pmurias> xinming: you use windows?

[16:45] <xinming> linux...

[16:45] <pmurias> :)

[16:46] <KingDillyDilly> There's nothing wrong with Windows. In fact, a recent study showed Windows servers are safer than Unix servers.

[16:47] <xinming> I ever used windows, but I like how to do things in Linux, eg: with compiler, and you can upgrade the whole system without restart...

[16:47] *** mako132_ joined
[16:48] <xinming> KingDillyDilly: I don't think there are the safe os, and this depends on something who admin the system.

[16:48] <xinming> KingDillyDilly: But what I don't like windows is that, for the fresh install, you have to restart at least 4 times... :-)

[16:49] <pmurias> xinming: i hate the GUI

[16:49] <xinming> It's a pain if you are helping people installing windows, and there are many a day... :-)

[16:49] <xinming> pmurias: In fact, there is nothing wrong with GUI. :-)   I prefer GUI + CLI.

[16:50] <xinming> pmichaud: eg, you wish to do some quote in irc, or you wish paste something to pastebin, In CLI, IMO, It's a pain. :-)

[16:50] <cognominal> you must have choice and avalaibility of free software development tools

[16:51] <pmurias> xinming: it's pmurias :)

[16:51] <cognominal> unix shine at that, plus linux proposes everything nicely packaged

[16:51] <FurnaceBoy> "	<KingDillyDilly>	There's nothing wrong with Windows. In fact, a recent study showed Windows servers are safer than Unix servers.

[16:51] <FurnaceBoy> " -- do you believe everything you read?

[16:52] <xinming> Why I like Gnu/Linux is all because it is "free", I mean, I can know manything from Linux, and In Windows, I have to just click the mouse... and nothing more.

[16:52] <KingDillyDilly> Can't find the reference at the moment, but I recall it being an independent study. It's on MS's website somewhere.

[16:52] <merlyn> it's "linux", not "gnu/linux" please

[16:52] <FurnaceBoy> it is, is it?

[16:52] <merlyn> RMS be damned

[16:53] <xinming> FurnaceBoy: In fact, I believe that both Linux and Windows are safe... but it depends on the admin. But Windows restarts too much...

[16:53] <xinming> merlyn: hmm, do you think a kernel can do all?

[16:53] <FurnaceBoy> there is no upside to windows. it's all cost, and all lockin. by design. that's why it's going away...

[16:53] <cognominal> " independent study."  not congruent to "It's on MS's website somewhere."

[16:53] <merlyn> linus called the whole thing linux

[16:53] <merlyn> it's his baby

[16:53] <davidfetter> rms lost that fight before he started it

[16:53] <xinming> merlyn: I'd like to say gnu/linux instead of linux. :-)

[16:53] <FurnaceBoy> yeah, you'd think that was too obvious to need explaining, cognominal ...

[16:53] <merlyn> linus is a much nicer guy tham RMS

[16:53] <merlyn> so RMS be damned on that one

[16:53] <davidfetter> that, or say X/BSD/GNU/vim/linux

[16:54] <merlyn> I know, I've had dinner with both of them. :)

[16:54] <davidfetter> i'm sure i've left out a few

[16:54] <davidfetter> same here

[16:54] <pmurias> KingDillyDilly: it's not independent if it is on ms

[16:54] <FurnaceBoy> plus, it's not true

[16:54] <cognominal> FurnaceBoy: in IRC, better never leave anything imploed

[16:54] <FurnaceBoy> indeed ;-)

[16:54] <pmurias> things on gnu.org aren't indepenent too

[16:54] *** amnesiac joined
[16:54] <davidfetter> i won't repeat the rms dining experience. it's like eating with a 4-year-old with CP. enough to put you off your feed :P

[16:54] <xinming> merlyn: well, if you call the whole system we use Linux, the problem raised...

[16:54] <xinming> merlyn: what the role of gnu is?

[16:54] <merlyn> I call the entire distro "linux", yes

[16:54] <KingDillyDilly> I'm sure it's elsewhere too. I'll look.

[16:55] <merlyn> it's built with a  bunch of gnu tools

[16:55] <merlyn> but it's still all called linux

[16:55] <merlyn> that's what linus calls it

[16:55] <merlyn> and it's his baby

[16:55] <merlyn> he can call it what he wants

[16:55] <davidfetter> :)

[16:55] <cognominal> linux is just sane huffmanization of gnu'linux, rms can nothing agains that.

[16:55] <FurnaceBoy> KDD, we don't care. such assertions are errant crap, made by the ignorant or gullible. take it elsewhere.

[16:55] <pmurias> and the gnu supply the ideology for the masses

[16:55] * davidfetter wonders what RMS has done code-wise this decade

[16:56] <merlyn> it was only GNU/linux when RMS realized he didn't have any more battles to fight

[16:56] <cognominal> davidfetter: he is very active on emacs I was said.

[16:56] <davidfetter> meh

[16:56] <merlyn> so he tried to ride the coattails of the linux project

[16:56] <merlyn> that's crap on him

[16:56] <FurnaceBoy> so, I guess there are few GPL licensors here...

[16:56] <KingDillyDilly> When I was looking into which distro to install (I chose SUSE, but I don't have a writable CDROM, so didn't install it), I saw so many people bashing various distros. Saying "Linux is..." is meaningless.

[16:56] <merlyn> he's bad for trying to do that

[16:57] <FurnaceBoy> I'm sure we can agree to be grateful for the GPL, at least??

[16:57] <xinming> merlyn: hmm, so, what do we call windows?  the kernel? or the whole operating system?

[16:57] <merlyn> Yes - he gets HUGE CREDIT for the GNU project.  but dammit, the name of the thing that Linus runs on his machien is "Linux", not "GNU/Linux"

[16:57] <merlyn> I don't call windows anything

[16:57] <merlyn> except swear words

[16:57] * FurnaceBoy smiles

[16:57] <cognominal> well, it was tough for him to see that linux relaized its dream of a free complete linux (kernel and all) at a time the bsds has dubious legal status.

[16:57] <pmurias> merlyn++

[16:57] <cognominal> but rms carried his dream pretty far except for the kernel

[16:58] <merlyn> right RMS is just sad about Herd

[16:58] <FurnaceBoy> sure, he is, but more than people imagine, methinks

[16:58] <cognominal> Hurd?

[16:58] <merlyn> and tries to claim that Linux is really GNU/Linux

[16:58] <merlyn> yes hurd

[16:58] <FurnaceBoy> that remark about GNU/Linux has been retailed further than it was ever intended, I suspect

[16:58] <merlyn> sorry for spelling it like english. :)

[16:58] <pmurias> merlyn: is it true that rms dosn't like perl?

[16:58] * davidfetter heard hurd herds hirds

[16:58] <merlyn> I don't think he's much of a Perl user, no.

[16:59] <merlyn> he uses emacs lisp and that other thing they came up with

[16:59] <davidfetter> heh

[16:59] <merlyn> gnuscheme?

[16:59] <KingDillyDilly> Not security related, but: http://www.computerworld.com/softwaretopics/os/story/0,10801,102137,00.html ... still looking

[16:59] <merlyn> what was it called?

[16:59] <davidfetter> something like that

[16:59] <cognominal> esr does not like Perl and tells it loudly but he is wrong on so many things...

[16:59] <merlyn> esr is a totally another story

[16:59] <FurnaceBoy> yup cognominal

[17:00] <merlyn> I've also had many beers with him too. :)

[17:00] <merlyn> ESR gets the "practical" side better than RMS

[17:00] <FurnaceBoy> except I like his hacker logo. best thing he ever did imho ;-)

[17:00] <davidfetter> <aol>me, too!</>

[17:00] <merlyn> but ESR is difficult to take in more than small doses

[17:00] <davidfetter> he gets other things wronger tho

[17:00] <FurnaceBoy> famously

[17:00] <pmurias> the Art of Programming was a good book

[17:00] <davidfetter> s/f/inf/

[17:00] <pmurias> of UNIX Programming

[17:00] <FurnaceBoy> thx

[17:01] <FurnaceBoy> saved me the trouble

[17:01] * davidfetter always wonders how much of an ESR thing any ESR-claimed thing really is.

[17:01] <davidfetter> take fetchmail. please.

[17:01] <cognominal> btw: http://geekz.co.uk/lovesraymond/archive/vmwhere

[17:02] <xinming> merlyn: RMS is a coding guy, and Linus is good at politics, whether you believe or not...  Anything RMS do, is want the design of the software best... But Linus doesn't...  though, I have to say, Linus give us a good product. But one thing you have to accept, most people don't know anything about gnu while they using Gnu/Linux...

[17:02] <xinming> well, I'll stop. It's too off topic....

[17:03] <FurnaceBoy> heh, well, nor while using OS X, which is built by gcc...

[17:03] <FurnaceBoy> etc

[17:03] <FurnaceBoy> I don't think rms need be concerned about his legacy being forgotten, somehow ;-)

[17:04] <FurnaceBoy> Linux *is* GPL, that's a powerful endorsement of your primary creation....

[17:04] <FurnaceBoy> so, in the pantheon of geeks, lwall gives us Perl, rms gives us GPL, and esr gives us ... fetchmail

[17:04] <xinming> rms also gives us Emacs. :-)

[17:04] <FurnaceBoy> and gcc 1.x

[17:04] <FurnaceBoy> etc, etc, etc, etc, etc

[17:05] *** dvtoo_ joined
[17:05] <cognominal> well, I am trapped in emacs, I want to escape :)

[17:05] <FurnaceBoy> I'd stand him a beer any time :)

[17:05] * FurnaceBoy whispers "vi!" "vi!"

[17:05] <xinming> But IMO, what RMS gives us most is that the freedom in software area...

[17:05] <cognominal> vim is cleaner but does not have shell buffers

[17:06] <FurnaceBoy> yes ... nobody else stood up to the plate, xinming ... so GPL will be his most enduring legacy perhaps

[17:06] <FurnaceBoy> that's one heck of a vision

[17:06] * xinming uses vim for editing config file, and emacs for editing program...

[17:07] <xinming> hmm, s/program/source code/

[17:07] <KingDillyDilly> http://download.microsoft.com/download/1/e/e/1ee952f2-2287-4cc3-8ccd-03bb62e38e5a/SecInnovation.pdf

[17:07] <KingDillyDilly> Based upon both counts/lifecycles of bugs and the absence/presence of qualitative drivers of security, it appears that Microsoft may have an edge in many environments.

[17:07] <KingDillyDilly> Put another way, looking at the software security factors that each vendor has the ability to directly affect  software security quality and security response  the data shows that a web server workload built using Windows Server 2003 has fewer security vulnerabilities requiring customer mitigation or patching than a similar workload built on Red Hat Enterprise Linux.

[17:07] <KingDillyDilly> From a company called SecurityInnovation.

[17:07] <FurnaceBoy> print it out and wipe your ass with it

[17:08] <xinming> lol...

[17:08] <FurnaceBoy> you clearly don't know what you're talking about

[17:08] <FurnaceBoy> you're the perfect audience for such 'studies'

[17:09] <xinming> me?

[17:09] <FurnaceBoy> no

[17:09] <KingDillyDilly> So Security Innovation is corrupt?

[17:09] <FurnaceBoy> very likely. but principally, WRONG.

[17:09] <FurnaceBoy> jeez.

[17:09] <FurnaceBoy> go RUN a web server and find out for yourself.

[17:10] *** justatheory joined
[17:10] <pmurias> we've got windows in our school library

[17:10] <KingDillyDilly> I don't think they mentioned web servers as opposed to other servers.

[17:10] <FurnaceBoy> alright:

[17:10] <FurnaceBoy> Run ANY kind of server.

[17:10] <FurnaceBoy> go get some experience before quoting 'studies'

[17:11] <FurnaceBoy> and you'll see that you're being led up the garden path -- or your checkbook is, in particular.

[17:11] <KingDillyDilly> A study is a better indicator than one persons experience.

[17:11] <FurnaceBoy> ........

[17:11] <FurnaceBoy> it ain't ONE person's experience.

[17:11] <FurnaceBoy> PLONK.

[17:12] <KingDillyDilly> Ok, more than one could count as a study. I'll compare SecurityInnovation's methodology with yours when yours is complete.

[17:12] <FurnaceBoy> windows is crap -- if you'd ever tried anything else, this would be self evident.

[17:12] <FurnaceBoy> I don't know why I bother with this conversation.

[17:13] <xinming> FurnaceBoy: as game box... windows is perfect... :-)

[17:13] <pmurias> got a friend who prefers linux for gaming

[17:14] <pmurias> dispite having a dual boot

[17:15] <KingDillyDilly> Maybe there are more free games.

[17:15] <xinming> pmurias: for normal people... windows is better, this is why windows rules....  Warcraft III is really a good game... :-)

[17:15] <xinming> pmurias: wesnoth is good. :-)

[17:15] <pmurias> he just play Enemy Territory

[17:15] <pmurias> i like wesnoth

[17:16] <xinming> wesnoth is too hard for me... my pawns are always experience for enemy...

[17:17] <xinming> Enemy Territory in Gentoo...

[17:17] <xinming> gentoo++

[17:17] <pmurias> gentoo++

[17:17] <KingDillyDilly> Gentoo is one of the distros I heard was difficult.

[17:18] <KingDillyDilly> SUSE, Mandriva, and those African named ones are easy.

[17:19] <xinming> KingDillyDilly: well, if you are tired of upgrade system,  try community-based distributions... :-)

[17:19] <pmurias> the installation requires CLI experience, otherwise nothing too dificult for a 16 old

[17:20] <pmurias> what i can't get to work with it is hardware accleration

[17:20] <wolverian> I can recommend Ubuntu, myself.

[17:20] <xinming> KingDillyDilly: by the way ubuntu is good too. It's debian based.

[17:21] <pmurias> i have bad experience with it

[17:21] <KingDillyDilly> I think that's the one that strives to have as much language support as possible. I don't like that priority. And it's new.

[17:21] <wolverian> well, I can say that the upcoming release is looking very good. :) maybe try it again then. it's always fun.

[17:21] *** davidfetter joined
[17:21] <xinming> pmurias: if you know debian, ubuntoo isn't that hard as you think.

[17:22] <wolverian> KingDillyDilly, do note that language support doesn't affect the system itself, as specific languages are separate language-support-* packages.

[17:22] <xinming> though, /me doesn't try ubuntoo,

[17:22] <pmurias> it wasn't hard

[17:22] <pmurias> what pissed me off, it didn't include compilers in the default install

[17:22] <wolverian> install build-essential :)

[17:23] <xinming> I used gentoo for maybe 40 days... It's good except lack some software, the major ones are there, but not as much as debian...

[17:23] <KingDillyDilly> Ubuntoo was one of the distros recommended to me by http://www.zegeniestudios.net/ldc/

[17:23] <xinming> BTW, why I switch too gentoo is all because I prefer the debian testing instead of sid. :-)

[17:23] <pmurias> KingDillyDilly: what distro do you have now?

[17:24] <KingDillyDilly> None. I don't have a writable CDROM, so my choice was too limited. Mainly to Slackware, which may be the most difficult distro, so I just didn't bother.

[17:24] <xinming> and in testing, Ghc is always 6.2, and I have to install package from sid.. that's a pain, so I switch to gentoo. compile the system myself, and use newest ghc. :-)

[17:24] <pmurias> xinming:have you tried changing the compiler

[17:25] <xinming> pmichaud: yes, a fully optmized os here. :-)

[17:25] <wolverian> xinming, ubuntu dapper has ghc 6.5 as a binary package. compiling takes time. :)

[17:25] <pmurias> xinming: i'm pmurias :)

[17:25] <wolverian> KingDillyDilly, Ubuntu ships CDs for free each release.

[17:26] <cognominal> mandriva  has ghc and parrot too,  packaged by respectively by rgs and misc

[17:26] <xinming> wolverian: and another reason I don't like debian is because it's community... in #debian. I sometimes see people being kicked out by hammer. :-)

[17:26] <wolverian> xinming, I don't deal with debian myself, much, besides feather.

[17:26] <xinming> wolverian: how does the company make money?

[17:26] <wolverian> xinming, support.

[17:27] <wolverian> (to companies)

[17:27] <KingDillyDilly> I wanted a free version because I didn't really need Linux. I got a new external hard drive that I wanted to dual boot with my internal one. That's too hard, so I lowered my requirements a couple of times, getting more weary of the search with each iteration, and I finally gave up.

[17:27] <xinming> wolverian: and I have to say, If I need manage many servers, I'd like choose debian.

[17:28] <wolverian> xinming, aye, me too.

[17:28] <pmurias> xinming: if you change your compiler do you have to recompile your system

[17:28] <xinming> wolverian: how much a year?

[17:28] <wolverian> xinming, sorry, how much what?

[17:28] <xinming> wolverian: I mean how much will ubuntoo ask for tech support?

[17:29] <wolverian> xinming, http://www.ubuntu.com/support/supportoptions/paidsupport if you really want to pay :)

[17:29] <xinming> pmurias: Yes, we have, but, if you just switch 3.4.5 to 3.4.6, I don't think recompile is needed

[17:29] * KingDillyDilly eats

[17:29] *** KingDillyDilly left
[17:30] <xinming> pmurias: and If you like to try the compiler which is not in testing, I'd suggest you leave it out.  I ever tried gcc-4.1.0  and there are many packages can't pass the compile.

[17:31] <wolverian> xinming, note that ubuntu provides free community support and several canonical employees support the packages in 'main' without cost to the community.

[17:31] <wolverian> xinming, http://www.ubuntu.com/support/supportoptions/freesupport

[17:31] <xinming> wolverian: If that's true, It's really a bit hard to make money IMO.  :-/

[17:32] <wolverian> xinming, apparently it works for them. :)

[17:32] <pmurias> two languahes i wanted to try didn't want to compile with my archaic gcc 3.3.5

[17:32] <pmurias> s/languahes/languages

[17:33] *** mako132_ joined
[17:33] <xinming> pmurias: you can use gcc-config to switch the compiler, and then, after compilation, switch the compiler back. :-)

[17:33] <xinming> pmurias: that's what I do, I think there is another way to do this. :-)

[17:35] <xinming> pmurias: by the way, If you got some problems, I'm not good at gentoo, so try #gentoo...  :-)

[17:36] <pmurias> thanks for the tip

[17:43] *** larsen joined
[17:48] *** mako132_ joined
[18:13] *** BooK joined
[18:16] *** mako132_ joined
[18:36] *** davidfetter joined
[18:41] *** larsen joined
[18:50] *** mago joined
[18:54] <svnbot6> r10055 | pmurias++ | Inline-Parrot:

[18:54] <svnbot6> r10055 | pmurias++ | * moved Inline-Parrot to Common

[18:54] <svnbot6> r10055 | pmurias++ | * some commit encouragment in README

[18:54] <svnbot6> r10055 | pmurias++ | * some initial contact with parrot established

[19:06] <pmurias> how should the pmc the perl5 code resives be manipulated?

[19:06] <pmurias> what would be better keeping the list of macros in Inline-Parrot or parsing vtable.h everytime?

[19:08] <pmurias> any wishes for the PMC manipulation api?

[19:21] *** mako132_ joined
[19:36] <TimToady> * audreyt ponders the @array[{$_ < 3}] overhuffmanization for

[19:36] <TimToady>           @array.grep:{$_ <3}

[19:36] *** pdcawley joined
[19:37] <TimToady> audreyt: doesn't work for two reasons

[19:37] <TimToady> .[] allows optimizer to assume integer slices.

[19:38] <TimToady> and {$_ < 3} would probably select indices from the current dimension

[19:38] <TimToady> or we couldn't generalize to multidims.

[19:39] <TimToady> I think if we install a generalized index selector, then it should go in via .{} or .() instead.

[19:40] <wolverian> @array{ $_ < 3 }; # hey, it's inside { }s..

[19:40] <TimToady> since .{} doesn't give any special instructions to the optimizer

[19:40] <TimToady> @array{ {$_ < 3} }; it would have to be

[19:41] <TimToady> or @array( {$_ < 3} ) maybe

[19:43] <TimToady> in any event bare .[] probably shouldn't support that kind of generality.  Maybe overload .?[] or .*[] for that, if we don't swipe it for slice forcing.

[19:44] <TimToady> but it's probably best to prototype with some kind of .foo( {$_ < 3} ) first.

[19:44] <TimToady> later we can talk about sugar if it's deemed necessary.

[19:44] <wolverian> .grep:{ <3 } would be nice.. :)

[19:44] *** dvtoo joined
[19:45] <TimToady> no, it'd be a syntax error.

[19:45] <wolverian> dang, no automatic currying.

[19:45] <TimToady> sometimes syntax errors are the nicest thing you can do.

[19:45] <cognominal> .grep:{ .<3 } ?

[19:46] <TimToady> that's no better.

[19:46] <TimToady> how bout jsut .grep: ^3, ...

[19:47] <TimToady> first arg to grep is just a smart match

[19:47] <TimToady> and ^3 is 0..^3

[19:47] <TimToady> (differs for negative, I realize)

[19:47] <wolverian> .grep(^3) ?

[19:48] <TimToady> just a Range object.

[19:48] <wolverian> yeah, just unclear on what .grep: ^3 means

[19:48] <TimToady> : is Haskell's $ there, more or less

[19:48] <TimToady> stands in for a left paren with no corresponding right paren.

[19:49] <wolverian> ah.

[19:49] <TimToady> .grep: ^3... is the same as .grep(^3...

[19:49] <TimToady> )

[19:49] <wolverian> I hadn't realised that's generalised

[19:49] <wolverian> nice.

[19:53] <theorbtwo> Wouldn't @arr.grep(...3) grep against the values, not the indeces?  ...or was that what was meant?

[19:54] <wolverian> that's equivalent to .grep:{ $_ < 3 }, yes

[19:54] <wolverian> which is what audrey was talking about

[19:54] <TimToady> yes, grep is on values

[19:54] <theorbtwo> Right.

[19:55] <TimToady> by the way, I'm thinking of destroying ... in favor of something more general.

[19:55] <merlyn> .... ? :)

[19:55] <TimToady> that is, ... meaning ..Inf

[19:55] <theorbtwo> It seems like overhufmanization.

[19:55] <TimToady> it's problematic in several ways.

[19:55] <TimToady> first, it parses as an infix that is missing its right argument.

[19:56] <TimToady> rather than as a postfix.

[19:56] <theorbtwo> Why?

[19:56] <TimToady> so you can put a space before it like .. can have a space before it.

[19:56] <theorbtwo> Surely it's longest token, and ... is longer then ..?

[19:56] <TimToady> we never allow postfix with a space in front nowadays.

[19:57] <theorbtwo> Ah.

[19:57] <TimToady> another problem is the visual clash with the yada operator.

[19:57] *** macroron joined
[19:57] <TimToady> a third problem turned up when I decided that maybe we should have xxx to go along with xx.

[19:57] <theorbtwo> Not really any more then !3 and .3 clash...

[19:58] <TimToady> yes it's a minor problem, at least to the computer.

[19:58] <theorbtwo> 3xxx being 3 xx Inf ?

[19:58] <Juerd> theorbtwo: than

[19:58] <Juerd> theorbtwo: if/then, more than.

[19:58] <TimToady> except you can't write $fooxxx 3

[19:58] <theorbtwo> D'oh.

[19:58] <theorbtwo> Well, yes, but you can't write $foox 3 either...

[19:58] <TimToady> and 3xxx will get you funny looks even if the computer groks it

[19:59] <TimToady> but that's just another reason it has to be a weird infix rather than a postfix.

[19:59] <TimToady> or we force people to write .xxx

[19:59] <theorbtwo> Now that'd be odd.

[19:59] <TimToady> so I think what we want here is some generalization that inserts Inf on the right side.

[19:59] <theorbtwo> 3xxx does look odd, so don't write it.

[19:59] <TimToady> and I think it's the fact that * with no argument means "Whatever".

[20:00] <TimToady> 3 xx *    0..*  take Whatever to mean positive Infinity (and Beyond!)

[20:00] <Juerd> Doesn't that clash with prefix *?

[20:01] <TimToady> *..* would then possibly mean -Inf..+Inf.

[20:01] <TimToady> is no term starting with ..

[20:01] <theorbtwo> It still seems like overhufmanization.

[20:01] <Juerd> 3 .. *$foo

[20:01] <aufrank> 0 .. ^*

[20:01] <TimToady> is the same operator that means Any in [*;0..5;*]

[20:01] <TimToady> aufrank: if you want to exclude Inf, sure.

[20:02] <aufrank> =P

[20:02] <TimToady> except that ^ has to be contiguous with ..

[20:02] <TimToady> or you've just said 0 .. 0..^Inf

[20:02] <wolverian> TimToady, does 0..Any equal 0..Inf semantically, then?

[20:02] <Juerd> Are ranges really important enough to have a lot of complexity surround them?

[20:02] <aufrank> good catch, I hadn't thought through that part of it

[20:03] <Juerd> Inclusive, exclusive, inclusive/exclusive, exclusive/inclusive, infinity written as something other than "Inf", a special ^ operator, ...

[20:03] <Juerd> Really, I think I much prefer Perl 5's simple ..

[20:03] <TimToady> I think this is a simplfication over ...

[20:03] <Juerd> Yes, and I still think ... is silly.

[20:03] <TimToady> fine, it's dead

[20:03] <aufrank> basketball perl and haskell are so much more interesting than this paper I'm supposed to be concentrating on

[20:03] <Juerd> :)

[20:04] <wolverian> Juerd++ # convincing argumentation

[20:04] <theorbtwo> Indeed.

[20:04] <Juerd> I'm not sure * is great, though. Have to think about it.

[20:04] <xerox> How's pugs, people?  (-:

[20:04] <Juerd> xerox: Cute and sweet.

[20:04] <aufrank> hey xerox

[20:04] <TimToady> .oO(baskerlell)

[20:04] <xerox> I have a creepy proposal for you puggers.

[20:05] <TimToady> people are so used to * meaning Whatever in globbing.

[20:05] <aufrank> this should be good =)

[20:05] <TimToady> copy us, xerox

[20:05] <Juerd> TimToady: I'm used to * playing three other roles in Perl 6 already.

[20:05] <TimToady> this is a role that * is already being used for.

[20:05] <xerox> Seems like Haskell.org is going to partecipate to the Google Summer of Code as mentoring organization this year!!  Would pugs offer chances to publish some Haskell project?  What do you think?

[20:06] <aufrank> xerox: audreyt was thinking of submitting pugs as a mentoring organization

[20:06] <Juerd> Splat (is it still called that?), multiply, slurpy

[20:06] <Juerd> TimToady: But in the other use, it's encosed in brackets

[20:06] <theorbtwo> I thought splat and slurpy were the same thing.

[20:07] <aufrank> and they're actually capture interpolation now

[20:07] <Juerd> theorbtwo: Different sides, different features. They are related, though.

[20:07] <TimToady> generalize that to "behavior selected by the associated operator"

[20:07] <Juerd> TimToady: But there's already prefix *

[20:07] <xerox> We're going to get some wiki to put the proposal on, the discussion is going on on [email@hidden.address] mailinglist.  I think it would be fun :-)

[20:07] <TimToady> argumentless * is just a Capture of the Whatever idea.

[20:07] <Juerd> And after .., a term is expected

[20:07] <TimToady> indeed.

[20:08] <Juerd> TimToady: So, * is Whatever, only if no other term follows?

[20:08] <aufrank> xerox: I reckon audreyt will backlog this when she's back among the waking

[20:08] <TimToady> that's how it already works in subscript slices

[20:08] <Juerd> I see

[20:08] <xerox> aufrank: hope so.

[20:08] <theorbtwo> I thought we were moving to backtracklessness?

[20:08] <Juerd> That could work.

[20:09] <Juerd> theorbtwo: One can prevent backtracking by looking ahead instead :)

[20:09] <theorbtwo> I suppose.

[20:09] <TimToady> It is backtrackless if you ignore whitespace.

[20:09] <Juerd> TimToady: I don't see how Whatever means Inf, though.

[20:09] <TimToady> 0..Whatever means Inf

[20:10] <theorbtwo> Because the .. operator treats it as +Inf on the right side, or -Inf on the left.

[20:10] <Juerd> It's neither 0..Everything nor 0..AnythingAtAll

[20:10] <theorbtwo> Is Inf case-sensitive, BTW?

[20:10] <TimToady> yes

[20:10] <Juerd> It's 0..SomethingVerySpecific, namely (+)Inf

[20:10] <avar> inf is the native machine representation of infinity>;)

[20:10] <TimToady> No, it's really 0..ArbitrarilyLarge

[20:10] <aufrank> well said Juerd

[20:11] <TimToady> but we can translate that to +Inf for practical purposes.

[20:11] <Juerd> TimToady: Well, then this boils down to a very different perception of infinity.

[20:11] <TimToady> Computers can't understand infinity any better than we do.

[20:11] <xerox> There are perceptions, and there are formalizations.

[20:12] <Juerd> I don't think the concept of infinity is close to the concept of anything arbitrary.

[20:12] <TimToady> on the right side of .. it is.

[20:12] <Juerd> I think 9.5e12 is already arbitrarily large.

[20:12] <Juerd> :)

[20:12] <xerox> Maybe it is close to the thought that the concept of infinity isn't close to the concept of anything arbitrary ;-)  Goedel++

[20:13] <TimToady> Okay, how about ArbitrarilyLargeEnough instead?  :)

[20:13] <avar> 0 .. OmgHuge

[20:13] <TimToady> Maybe define it as the first uninteresting number...

[20:13] <TimToady> oh wait...

[20:14] <Juerd> TimToady: Do you have other meanings for * in mind yet?

[20:14] <TimToady> "foo" xx *

[20:14] <TimToady> my ($a, $b, $c) = 1 xx *;

[20:14] <Juerd> TimToady: I meant, other, as in: not Inf.

[20:14] <theorbtwo> Juerd: On the right side of $_ ~~ $b..$a, the question is "is $_ bigger then $b", and the salient point of Inf is that it's bigger then anything else.

[20:14] <TimToady> $x[*;0..5;*]

[20:15] <TimToady> there Whatever means whatever the domain of the key type

[20:15] <TimToady> %x{*;'a'..'z';*}

[20:15] <TimToady> see S09

[20:15] <Juerd> One is a globlike match-all, one is infinity, any others?

[20:15] <TimToady> rand *   :)

[20:16] <theorbtwo> TimToady: Which returns any random number in the range of floats?

[20:16] *** SamB joined
[20:16] <TimToady> for * {...}

[20:16] <TimToady> for Whatever {...}

[20:16] <Juerd> theorbtwo: Or Inf. If * can mean Inf, it should certainly include it when it means Whatever :)

[20:17] <TimToady> could be the new =<> if we go with Audrey's new idea.

[20:17] <Juerd> .*  # .pick

[20:17] <Juerd> (Nice for golfers :P)

[20:18] <Juerd> I understand the idea, but doubt it's worth having for the same reason I didn't like ...

[20:18] <TimToady> /foo/ ff *

[20:18] <Juerd> What's ff?

[20:18] <aufrank> my Dog $fido .= new; $fido.* # unpredictable mutt

[20:18] <TimToady> flipflop

[20:18] <TimToady> in this case it means "false"

[20:19] <Juerd> This may be a bit too much context sensitivity.

[20:19] <Juerd> A term that changes meaning depending on the operator it's an operand of

[20:20] <TimToady> It doesn't--it always means Whatever.  :)

[20:20] <TimToady> but that's sophistry...

[20:20] <theorbtwo> Juerd: It just returns an object of type Whatever.  The thing it's passed can do whatever it wants with it.

[20:20] <Juerd> Of which Whatever cannot, and Inf, can be represented in a different way.

[20:20] <TimToady> you mean like @foo changes meaning under + vs say

[20:21] <theorbtwo> It does, though, seem that * buys us nothing new.

[20:21] <Juerd> theorbtwo: That does not change what I said, though. It still means different things in different contexts, regardless of implementation.

[20:21] <theorbtwo> It's a whole two keypresses longer then Inf.

[20:21] <theorbtwo> Er, shorter then.

[20:21] <Juerd> TimToady: Yes, but this goes far beyond normal Perl contexts

[20:21] <Juerd> theorbtwo: than

[20:21] <TimToady> I don't think so.

[20:21] * theorbtwo slaps himself on the head again.

[20:22] <theorbtwo> What is * when you aren't mindful of it?

[20:22] <Juerd> TimToady: *'s (semantic) meaning doesn't depend on void/list/item context, or type context.

[20:22] <theorbtwo> What does +(*) do, or ~(*), or ?(*).

[20:23] <aufrank> can we use ^* as a formal parameter in a Sig?

[20:23] <aufrank> sorry, $^*

[20:23] <theorbtwo> That seems like a really long way to say Any, aufrank.

[20:23] <theorbtwo> IIRC, we already have Any as a type.

[20:24] <TimToady> to2: I'd expect it to do much the same as +(Any), which is to say,

[20:24] <TimToady> probably throw an exception.

[20:24] <Juerd> I can see why it's nice to have * generalized beyond .[]

[20:24] <TimToady> which certainly falls under the rubric of "Whatever

[20:24] <TimToady> "

[20:24] <Juerd> But my style rule list will probably contain "Do not use * outside of subscripts"

[20:25] <Juerd> I find *, when it means Inf, unnecessary obfuscation.

[20:25] <TimToady> In general the * prefix just means "splat something in here that is not directly specified"

[20:25] <Juerd> I do like the Whatever-ness.

[20:26] <TimToady> I don't think anyone can look at 0..* and not grok it.

[20:26] <Juerd> There may be very practical uses for it. Just not for a number, I think.

[20:26] <Juerd> TimToady: My mind still translates that to 0.+

[20:27] <TimToady> s/anyone/anyone not seriously damaged by earlier exposure to computer culture. :)/

[20:27] <pmurias> 0..* looks like blow up operator to me

[20:27] <Juerd> pmurias: It's not as bad as *..*

[20:28] <Juerd> Which fortunately has no practical uses :)

[20:28] <TimToady> Make me one with *..*

[20:28] <aufrank> we need merlyn to name that one

[20:28] <Juerd> Or, possibly, *..* means none()

[20:28] <theorbtwo> Blink?

[20:28] <theorbtwo> Why none()?

[20:28] <avar> The-man-who-witnessed-goatse-operator *ducks*

[20:28] <pmurias> 0..Inf looks better, and is 2 char's more

[20:29] <Juerd> theorbtwo: any(*..*) == none(undef)  # :)

[20:29] <Juerd> pmurias: Agreed (if that wasn't obvious yet)

[20:29] <theorbtwo> I should think it'd mean -Inf..Inf, pretty obviously.

[20:29] <theorbtwo> Of course, I can't think of where you'd use that...

[20:29] <avar> But I like 0 .. Inf better.

[20:29] <TimToady> In a selector when you're too lazy to say Num.

[20:29] <aufrank> I like * in ranges for a..*

[20:29] <theorbtwo> Trying to iterate over it just gives you -Inf a lot, and if you want to match anything, ~~ing with 1 is simpiler.

[20:29] <aufrank> keep going to the end of the current character class

[20:30] <TimToady> that's another reason for it.  'a'..*

[20:30] <aufrank> yeah, that's the ticket

[20:30] <TimToady> the endpoint is *not* Inf.

[20:30] <Juerd> Hmmm

[20:30] <TimToady> It's...its...er...

[20:30] <aufrank> right, that's a good Whatever endpoint

[20:30] <TimToady> Whatever.

[20:31] <aufrank> "I just want it all"

[20:31] <Juerd> It's a nice precedent too.

[20:31] <Juerd> Now we can re-use every other prefix operator as a term too :)

[20:31] <aufrank> dibs on :

[20:31] <aufrank> I called it

[20:31] <TimToady> Sorry, I already called the colon.

[20:32] <aufrank> =P

[20:32] <aufrank> we could have a nice short hand for indifference in the channel

[20:32] <Juerd> Maybe a lone . could mean .self, so that it becomes an alias for $_

[20:33] * aufrank says *

[20:33] <TimToady> Whatever...

[20:33] <aufrank> no, that is Whatever..*

[20:33] <TimToady> right.

[20:33] <aufrank> :)

[20:33] <TimToady> "Whatever" xx *

[20:34] <aufrank> I went through that stage around the age of 14 or so

[20:34] <Juerd> * xx 4  # (*, *, *, *)?

[20:34] <aufrank> '*' xx 4 # <* * * *>

[20:34] <pmurias> * xx *

[20:34] <Juerd> TimToady: Any news on XX yet?

[20:35] <TimToady> It googles for Whatever and starts replicated the I-feel-lucky page

[20:35] <TimToady> s/ted/ting/

[20:35] * FurnaceBoy googles for Whatever

[20:35] <TimToady> was just wondering about XXishness

[20:35] <aufrank> what are the ideas for XX ?

[20:36] <TimToady> not to have it.

[20:36] <TimToady> :)

[20:36] <Juerd> aufrank: Evaluate left side n times instead of once.

[20:36] <TimToady> I think we can just get away with recognizing a closure on the left to mean that.

[20:36] <avar> so basically EXPR for 0 .. $n ?

[20:37] <TimToady> { say "Whatever" } x *

[20:37] <Juerd> aufrank: my $password = { any("a" .. "z").pick } X 8;

[20:37] <aufrank> int(6 * rand) XX 3 # roll for D&D ability scores?

[20:37] <Juerd> aufrank: Yes, though I think I wanted a closure on the LHS

[20:37] <theorbtwo> TimToady: So how do you write a list of a repeated subs?

[20:37] <Juerd> Since we no longer have map EXPR, LIST either.

[20:38] <TimToady> and you want that because...

[20:38] <aufrank> Juerd: I don't know what you mean with the connection to map

[20:38] <aufrank> what did we lose and why does this fix it?

[20:38] <TimToady> Juerd, actually, we do have map EXPR, LIST now.  That's *all* we have.

[20:38] <TimToady> map {...}, LIST is just a selector in the first arg.

[20:38] <Juerd> TimToady: Sure, but it doesn't do much if EXPR isn't Code, right?

[20:39] <TimToady> "selector"

[20:39] <Juerd> aufrank: There is no connection, except for wanting {} on the LHS instead of a bare expression.

[20:39] <aufrank> oh, ok

[20:39] <TimToady> about an hour ago we just through talking about grep(0..3, @nums)

[20:39] <Juerd> TimToady: What would that do?

[20:40] <TimToady> pick the entries that match the selector.

[20:40] *** DaGo joined
[20:40] <TimToady> a selector is smart matched.

[20:40] <TimToady> a smart match against a range checks to see if something is in that range.

[20:40] <Juerd> But the same makes little sense for map?

[20:40] <TimToady> selectors return boolean.

[20:40] <theorbtwo> do {my @result; for (@nums) {push @result, $_ if $_ ~~ 0..3}; @result}

[20:41] <TimToady> right, sorry

[20:41] <TimToady> I mentally translated your map to grep

[20:41] <TimToady> but it's still the case that the syntax is map EXPR, LIST.

[20:41] <Juerd> grep X, LIST; is like grep { $_ ~~ X }, LIST?

[20:41] <Juerd> But then not recursive :P

[20:41] <Juerd> TimToady: Syntax, but not use.

[20:42] <TimToady> it's just map does something different.

[20:42] <TimToady> you could probably use anthing that maps though, like a hash.

[20:42] <TimToady> map %xlate, @values

[20:42] <Juerd> I hope documentation won't use "EXPR" anymore, especially when as specific type is wanted :)

[20:42] <theorbtwo> TT: Isn't that just %xlate{@values}?

[20:42] <Juerd> theorbtwo: You're quick.

[20:43] <TimToady> how can you tell what type is wanted in the presence of ubiquitous MMD?

[20:43] <TimToady> I guess there's a return sig anyway

[20:43] <aufrank> by my book he is-- I was still typing it!

[20:43] <Juerd> I'm talking about documentation, the realm of EXPR.

[20:43] <TimToady> Item --> Boolean for instance

[20:43] <theorbtwo> grep SmartMatchable, Array seems like reasonable documentation.

[20:44] <TimToady> We'ver already named those Selectors

[20:44] <theorbtwo> Hm, OK.

[20:45] <TimToady> I agree that EXPR is not specific enough.

[20:46] <Juerd> theorbtwo: Well chosen signatures are great documentation =item's by themselves.

[20:46] <Juerd> Though I'd like to step away from pod, TBH

[20:46] <Juerd> To some kind of property of which the value is a string.

[20:47] <Juerd> is documented(q[ ... ])

[20:47] <TimToady> If you have opinions on that subject you should help Damian and Ingy with the revised S26, whatever it's called these days...

[20:48] <Juerd> I think it will be very hard to align our opinions.

[20:48] <aufrank> Juerd: couldn't that just be a macro that got expanded to POD?

[20:48] <Juerd> aufrank: I think it'd be scary if POD processors would have to parse macros.

[20:48] <TimToady> pugs/docs/Perl6/Spec/Documentation.pod or some such.

[20:49] <TimToady> on the other hand, the document structure will be availabe to the surrounding code.

[20:50] <avar> $=section, right?

[20:50] <TimToady> so anything that is naturally code goes in as code, and anything that is naturally doc goes in as doc, but is still available as if you'd put it in as code.

[20:50] <Juerd> My thoughts are class Foo does Bar is documented(q[]) { has $.foo is documented(q[]); method foo($bar, $baz, @quux) is documented(q[]) { ... } ... }

[20:50] <TimToady> is documented--

[20:51] <TimToady> %=DOC++

[20:51] <Juerd> The first would be the semi-equivalent of DESCRIPTION, the second and third of PROPERTIES and METHODS

[20:52] <theorbtwo> Juerd, the problem is when one of those is documented q[]s are several screenfuls, and you forget where you were by the time you're done.

[20:52] <TimToady> the document model will even give you the nearby comments if you want smart comments

[20:52] * avar forsees stuff like multi sub factorial is documented "This function takes ... and returns" { ...

[20:52] <Juerd> The more I document code, the more I think something/someone else should structure it. I just want to document methods, not add text that happens to have a heading with the same name.

[20:52] <TimToady> so just use the shiney new #{...} for your inline docs.

[20:53] <Juerd> theorbtwo: I'm against pagefuls of documentation for single items anyway.

[20:53] <theorbtwo> What I would like is the combination of the inline is documented, and a very good system for setting it later.

[20:53] <Juerd> theorbtwo: And, if these are strings, you can interpolate :)

[20:53] <TimToady> how...literate...

[20:53] <avar> TimToady: #{} ?, comments starting / ending at arbitary points?

[20:53] <TimToady> yes, except they can't start in the leftmost column.

[20:53] <Juerd> theorbtwo: You're right, though, that "is documented" (though that syntax sucks) isn't enough.

[20:54] <TimToady> happened a week or two ago

[20:54] <TimToady> see S2

[20:54] <theorbtwo> Thus, you should be able to get at an element in the signature of a purticular method, and set it's is documented property later.

[20:54] <Juerd> TimToady: I've always had a nice difference between documentation and comments, and I think using #{} would mess that up.

[20:54] <pmurias> sleep& #i'll be away from #perl6 for two weeks school exchange(east germant), and an alogrithmic camp so have fun

[20:55] <TimToady> cool.

[20:55] <Juerd> Avalon--  # boring movie.

[20:55] <theorbtwo> Juerd: More then a screenful is probably too much, but several lines seems like it'd be quite common.

[20:55] <theorbtwo> pmurias: "eastern Germany" is a region of Germany.  East Germany is a country that doesn't exist anymore.

[20:55] <Juerd> s/(using '#{}')/$0 for documentation/

[20:56] <Juerd> theorbtwo: It's common, but not a style of documentation that I like or write.

[20:56] <TimToady> you get to pick your delimiter with #{}, so you can pick something distinctive.

[20:56] <Juerd> TimToady: How does that work? #<> and such?

[20:56] <pmurias> theorbtwo: sorry, eastern Gemany

[20:56] <TimToady> try again. :)

[20:57] <merlyn> how do you hunt IRC?

[20:57] <aufrank> Juerd: I think you have to use things that are matched pairs in unicode

[20:57] <merlyn> Oops ... please ignore that.

[20:57] <aufrank> and <> are nto?

[20:57] <TimToady> all defined in S2

[20:57] <aufrank> merlyn: I know this one!  with an IRC-gun?  carefully?

[20:58] <TimToady> nto?

[20:58] <aufrank> s/nto/not/

[20:58] <aufrank> sorry =\

[20:58] <TimToady> defined such as to include <>

[20:58] <TimToady> despite not being Ps/Pe

[20:59] <avar> On POD...

[20:59] <Juerd> <> are the texas 

[20:59] <TimToady> basically, "bracketing characters" in Perl 6 are now defined to be either Ps/Pe pairs or bidirectional mirror pairs.

[21:00] <TimToady> :)

[21:00] <aufrank> good to know

[21:00] <Juerd> TimToady: Does the definition include <<>>, the texas ?

[21:00] * Juerd should really reread the synopses (and such) again

[21:00] <aufrank> any stacked openers have to be matched by an equal number of stacked closers covers that I think

[21:00] <TimToady> Yes, multiples are consistently supported, though the semantics of <<>> are special in some places.

[21:01] <aufrank> [[[bracketed]]]

[21:01] <Juerd> But I'm wasting my saturday of tuits on movies and irc :(

[21:01] <TimToady> [[[*]]]

[21:01] <avar> Since I began writing pod for Perl 5 code a few things have annoyed me, but the biggest one is probably that documenting a given file with POD is not as straightforward as Javadoc or phpdoc (although you get more in return), basically you can't tell if a pod section above a sub describes it or just happens to live there

[21:01] <TimToady> we're fixing that.

[21:01] <avar> there's no standard section name like METHODS (correct me if I'm wrong),

[21:01] <avar> TimToady: good;)

[21:02] <TimToady> get involved in the Documentation.pod rewrite if you like.

[21:02] <Juerd> #In item context, returns a Tuit

[21:02] <TimToady> legal

[21:02] <Juerd> Hm, I may be using unicode in my sources after all then :)

[21:03] <TimToady> Hey, Unicode has to be good for something...

[21:03] <Juerd> avar: There are no standard section names. Only de-facto ones. Methods are often under DESCRIPTION, as a =head2 Methods

[21:03] <Juerd> TimToady: How about this and this? :)

[21:03] <Juerd> Is "" just the texas ? :P

[21:04] <TimToady> those don't match.

[21:04] <avar> Juerd: Yeah, that was kind of my point, I'm not saying that the system should enforce it, merely that the equivalent of perldoc perlpod should "lay down the law" as it were;)

[21:04] <Juerd> TimToady: Why not?

[21:04] <TimToady> I think you've mixed different quote types.

[21:04] <aufrank> the first set was mirrored and bidirectional...

[21:04] <Juerd> My Compose file thinks they match

[21:04] <Juerd> And my font does too :)

[21:06] <TimToady> Okay, the first set match--my font is screwed up.

[21:06] <Juerd> The second is Afrikaans, Dutch, Hungarian, Norwegian, Polish, Romanian

[21:06] <TimToady> the second can't match unless they're defined as a Ps/Pe pair.

[21:07] <Juerd> I know them from my childhood, when I still read non-electronic dutch texts :)

[21:07] <avar>  is a german quote pair

[21:07] <avar> also used by other locales..

[21:07] <Juerd> I've never seen them ever since, except in some ASCII attempts to emulate them (,,''), and in the wikipedia article Quotation_mark

[21:08] <aufrank> you can tell how much of a rube I am-- this is the most unicode I've ever seen in one buffer

[21:08] <Juerd> avar: Yea, the second glyph is different there indeed. We use , Germans use 

[21:08] <ayrnieu> I like chinese quotation.

[21:08] <Juerd> ayrnieu: So do I.

[21:08] <avar> Juerd: fleh;)

[21:08] <ayrnieu> aufrank - I've seen whole pages of unicode -- but I can't read any of this.

[21:09] <Juerd> I can see my documentation be enclosed in 

[21:09] <avar> ayrnieu: yeah, it rocks;)

[21:09] <Juerd> #The maximum number of Tuits

[21:10] <Juerd> afk  # hurts

[21:10] <aufrank> OT:  it's a good day to be a Cleveland Cavaliers fan

[21:11] <ayrnieu> avar - the difference between POD and langdoc isn't that you have some things not as straightforward and get other things more in return, it's that the former is meant for human consumption and the latter for mechanical consumption.  (And the latter never really stops being for mechanical consumption)

[21:14] <svnbot6> r10056 | pmurias++ | removed too unused functions

[21:14] *** xinming joined
[21:15] <aufrank> TimToady: re: PDL bait in S09

[21:15] <TimToady> yes?

[21:15] <aufrank> do you think design is far enough along that I could propose a PDL in p6 SoC project?

[21:15] <pmurias> is there a way to fix typo's in commit msg's?

[21:16] <TimToady> pmurias: I don't think anyone cares about typos there.

[21:16] <pmurias> *typos,msgs

[21:16] <aufrank> pmurias: commit again ;)

[21:16] <TimToady> aufrank: have to bounce that off of Audrey

[21:16] <aufrank> ok, I'll keep an eye out

[21:16] <ayrnieu> | deleted some stuff OH AND THAT WAS 'TWO'

[21:17] <TimToady> I'm not sure where multidim arrays are currently, implementation-wise

[21:17] <aufrank> | gratuitous commit, me-- to keep karma fair

[21:17] <aufrank> ;)

[21:18] <aufrank> TimToady: well heck, maybe that's something to work on :)

[21:18] <aufrank> s/something to/something I could/

[21:20] * TimToady issues aufrank a duplicate commit bit

[21:20] <ayrnieu> http://www.selectparks.net/modules.php?name=News&file=article&sid=442  # unrelatedly, this is a really awesome video

[21:21] *** lidden joined
[21:21] <aufrank> TimToady: gathering ideas for the time in a few weeks when my shipment of tuits comes in

[21:21] <aufrank> but yes, I should produce more

[21:24] *** mako132_ joined
[21:28] <TimToady> my gut level feeling is that PDLness probably *would* make a good SoC project.

[21:29] <aufrank> good to hear :)

[21:30] <TimToady> at worst, it'd be kludged in the way it's kludged into Perl 5, but integration is sufficiently open-ended that one wouldn't run out of things to do quickly, yet one could declare success at any point.

[21:31] <aufrank> that's an especially encouraging way to think about it :)

[21:31] <TimToady> Plus it's something that is likely to be useful in whatever state it comes out, so people can build on it.

[21:32] <TimToady> And it would be good to flesh out that part now rather than later, since it's one part of the design where I'm doing more guessing than usual.  (Hard, I know.)

[21:33] <aufrank> ok, I'll try to talk to audreyt later today and if things look promising I'll probably solicit comments from p6c

[21:34] <TimToady> I'm behind you 100% at least until the shooting starts...

[21:34] <aufrank> we're making a movie?

[21:34] <TimToady> playing marbles

[21:35] <aufrank> I've got a killer aggie

[21:36] <TimToady> I used to have a nice set *cough* years agol.

[21:36] <TimToady> *ago

[21:36] <aufrank> WhatevercoughWhatever

[21:37] <TimToady> well, I'd better curl up in a corner and contemplate what's happening to the fish operator.

[21:37] <aufrank> I've always thought we should do something with squiggly arrows

[21:37] <TimToady> =<> for those following along at home...

[21:37] <aufrank> they're so cute!

[21:37] <aufrank> ~>

[21:38] <TimToady> that looks like a bird about to eat a catapillar

[21:38] *** fglock joined
[21:39] <TimToady> Hmm. I wonder what unary string rightshift would mean...

[21:39] <aufrank> for @foo ~> / (\d+) / { say $0 }

[21:40] <aufrank> or is there already a way to do selectors in pointy subs?

[21:40] <TimToady> Unfortunately we already have infix:{'~>'}

[21:40] <aufrank> really?

[21:40] <aufrank> which Syn is it in?

[21:40] <TimToady> S03

[21:41] <TimToady> string right shift

[21:41] * aufrank goes to check

[21:41] <TimToady> for @foo -> $_ where / (\d+) / { say $0 } might work

[21:42] <xinming> perl 5 used all the punctuations in a normal keyboard... and perl 6 used all 2 key sequence composition in punctuations... :-)

[21:42] <aufrank> oh come on, we could still poach haskell's {- and -}

[21:42] <aufrank> there are plenty of 2-grams left

[21:43] <obra> nah. we need multiline ascii art sigils

[21:43] <obra> :  ^   ^

[21:44] <obra> :   o  o

[21:44] <TimToady> I think you're looking for Befunge or some such.

[21:44] <obra> :   ---

[21:44] * obra grins

[21:44] <obra> and is no good at ascii art in a linemode editor

[21:44] <TimToady> I recognized it...

[21:44] <TimToady> actually, I think my interpolation helped...

[21:45] <TimToady> coming between the eyes and the mouth

[21:45] <obra> I need a bit of unicode to do whiskers correctly. and the eyes were offset

[21:45] <TimToady> what about the little chevronny things?

[21:46] <obra> ah, yeah.

[21:46] <obra> "I need an irc client that can display utf8 or latin1"

[21:46] <obra> I fall back to >> and <<

[21:46] <merlyn> fall back

[21:46] * obra wonders what the neko operator would do.

[21:46] <aufrank> obra, rcirc in cvs emacs is working nicely for me

[21:47] <obra> merlyn: was that sent as latin1 or utf8? It worked fine

[21:47] <merlyn> utf8

[21:47] <obra> aufrank: I use irssi in screen.

[21:47] <merlyn> and from emacs

[21:47] <obra> ah. excellent.

[21:47] <TimToady> anyway, if we make =<> only ever read one line from @ARGS, then we end up with a special case on * if we want

[21:47] <TimToady> for *<> {...}

[21:47] <merlyn> actually.  Terminal.app in utf8 mode -> ssh -> screen -U -> emacs -> irc.el -> sockets -> ircd

[21:47] <merlyn> I'm amazed it works

[21:48] <obra> nice.

[21:48] <merlyn> bullet

[21:48] <TimToady> to fill that role now.  As long as it's a special case...

[21:48] <merlyn> your 2

[21:48] <merlyn> spaceship_dock

[21:49] <merlyn> OK - time to go to Yet Another BBQ in Brazil

[21:49] <TimToady> then for * {...} is just a slightly specialler case...

[21:49] <aufrank> merlyn, do you have a name for the *..* range ?

[21:49] <TimToady> I was actually a bit serious earlier when I said

[21:49] <TimToady> for Whatever {...}

[21:50] <aufrank> TimToady: you want for Whatever rather than for * ?

[21:50] <TimToady> no, Whatever is what it means.

[21:50] <aufrank> oh oh

[21:50] <aufrank> ok

[21:50] <TimToady> surface syntax is still *

[21:50] <TimToady> just in that context means *<> or *$ARGS or some such

[21:51] <aufrank> what does * search over in that context?

[21:52] <aufrank> seems like there a lot of things that could appear in first position to for

[21:52] <TimToady> dunno.

[21:52] <Juerd> Oh no. * is the second default :|

[21:53] <aufrank> Juerd: I'm not familiar with the :| term.  Can you explain it? ;)

[21:53] <TimToady> if empty postfix <> still means ARGS though, and if we ignore @<foo> from Match objects

[21:53] <TimToady> then @<> could mean all the lines from ARGS

[21:53] <TimToady> but @@<> would mean to keep the separate file's lines as a separate dimension.

[21:53] <aufrank> I like the last bit

[21:54] <TimToady> but it depends on swiping empty <> from @()

[21:55] <TimToady> which we could conceivably do, since the empty key doesn't mean anything anymore to $/

[21:57] <TimToady> but it's a little confusing that @<foo> means $/<foo> when @<> means *$ARGS

[21:59] <aufrank> it's not that bad: $/<foo> is a Capture and @<> is a Capture, right?

[22:00] <TimToady> mmmm

[22:00] <TimToady> explain that to a five-year old

[22:01] <aufrank> heck, I wasn't even sure I was right when I said it

[22:01] <avar> Maybe you should declare that Perl 6 will look like python 2.8 if you want it to be 5 year old explainable;)

[22:01] <TimToady> 'Course a 5 year old will simply take on faith that "for * {...}" works and run with it.

[22:02] <aufrank> but I would say something like @<*> is a way to get at groups that have been bound together previously in the program

[22:02] <TimToady> groups?

[22:02] <aufrank> and that sometimes they were bound by a Match, and sometimes they came in pre-bound in a file

[22:02] <aufrank> I was trying not to say Capture

[22:02] <aufrank> five year olds don't call you out on vagueness!

[22:03] <TimToady> yeah, tell me about it... :/

[22:03] <aufrank> (did you notice my Whatever?  @<*>  )

[22:03] <TimToady> yes, I did

[22:03] <aufrank> =D

[22:05] <aufrank> the reason Whatever parses for me is that that's pretty much how I read the Kleene star in regex anyway

[22:05] <aufrank> well, I guess that's how I read m/.*/

[22:07] <aufrank> of course, that makes me think that if * is Whatever, + is Something

[22:07] <TimToady> for + {...}

[22:07] <aufrank> for + -> { say $_ } # won't try to say undef?

[22:07] <aufrank> s/->//

[22:08] <TimToady> for ? {...}

[22:08] <TimToady> for **{0..10} {...}

[22:09] <TimToady> that...almost works...

[22:09] <aufrank> ? is qbit or something

[22:10] <TimToady> for "do" | "do not" {...}

[22:10] <aufrank> I don't know if I understand what the Whatever loops buy us

[22:10] <aufrank> I don't think I get the use case

[22:10] <TimToady> for "better" | "worse" {...}

[22:11] * aufrank chuckles

[22:11] <TimToady> It's probably too cute, mostly because the context is too diffuse

[22:11] <TimToady> I could more easily believe that * is the ARGS iterator if it were used like =* or @*

[22:11] <aufrank> *..'b'|!'b'

[22:12] <TimToady> ...

[22:12] <aufrank> yeah, I botched that one

[22:12] <TimToady> ?('b'|!'b') maybe

[22:13] <aufrank> *..'b' | !*..'b'

[22:13] <TimToady> hmm *..'x'

[22:13] <aufrank> I was trying to riff on *..$foo ranges as being "to $foo"

[22:13] <TimToady> I wonder what a negative string looks like?

[22:14] <aufrank> I had to write on my forehead to figure it out

[22:14] <TimToady> /foo$/

[22:14] <aufrank> oof

[22:14] <TimToady> or would that be /oof$/

[22:14] <TimToady> bingo

[22:14] <aufrank> and I think it would be \oof$\

[22:14] <TimToady> surly \$foo\

[22:15] <TimToady> \$oof\ I mean

[22:16] *** larsen joined
[22:17] <TimToady> pity f doesn't have a bidi mirror...

[22:19] <aufrank> yes, it's the only thing keeping this from being a totally practical discussion ;)

[22:19] <aufrank> anyway, I was going for "to be or not to be" trying to use ranges

[22:20] <aufrank> ^'b' | !^'b'

[22:21] <TimToady> I'm not sure you can ! a range...

[22:22] <TimToady> though I suppose it could be useful.

[22:22] <TimToady> Oddly, $a..$b is contiguous, but !($a..$b) wouldn't be...

[22:23] <aufrank> right

[22:23] <aufrank> but you could want to check that a value is outside of a range

[22:23] <aufrank> is that just negating the smart match?

[22:23] <TimToady> that would generally be clearer, i suspect.

[22:23] <TimToady> On the other hand, as a general selector...

[22:23] <aufrank> oh, right

[22:24] <TimToady> I guess you could always pass { $_ !~ $range }

[22:25] <TimToady> say not $a .. $b   # -Inf, -Inf,-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,...

[22:25] <YetAnotherEric> what's a junction?

[22:27] <aufrank> YetAnotherEric: examples include any(@foo) and none(@foo)

[22:28] <TimToady> It's a set of data values along with a hint about their logical relationship

[22:28] <YetAnotherEric> sorry, I thought a negated range could be a junction

[22:28] <aufrank> if 'foo' ~~ none(@bar) { say "no foo here" }

[22:29] <aufrank> junctions also guarantee that operations on the junction spawn new threads, right?

[22:29] <TimToady> Currently junctions are only discrete values, whereas ranges are (in the abstract) continuous.

[22:30] <TimToady> rather, use of a junction is a promise that the "legs" of it can be calculated in parallel without interference.

[22:30] <aufrank> much better.  it sounded off as I wrote it.

[22:30] <TimToady> Unlike hyperops, even ordering is lost.

[22:30] * YetAnotherEric returns to lurk mode

[22:31] <TimToady> even completeness is lost, in the sense that a hyper goes to completion

[22:31] <TimToady> while a junction is free to short-circuit any way it likes

[22:31] <TimToady> as long as the logical relationship can be proven.

[22:31] <TimToady> so $a ~~ 1 | 2 | 3

[22:32] <TimToady> can quit as soon as it finds any match.

[22:32] <aufrank> right, if 'x' ~~ one(@foo) { say }  can short circuit as soon as it's got one match

[22:32] <TimToady> no

[22:32] <TimToady> it can quit as soon as it finds two matches. :)

[22:32] <aufrank> you got me

[22:33] <TimToady> if 'x' ~~ any(@foo) { say } can quit on one match

[22:33] <aufrank> yup

[22:33] <TimToady> as can all(@foo) if it's false

[22:34] <TimToady> or none(@foo) if it's true

[22:34] <aufrank> are there two(@foo), three(@foo), etc, or is there a general junction form to say "exactly n"?

[22:35] <TimToady> nothing like that

[22:36] <Juerd> TimToady: If a StrLen object hangs on two StrPos objects, which in turn are Str dependent, then why not have a SubStr instead of StrLen?

[22:37] <Juerd> TimToady: Also, do $strpos2 - $strpos1 and $strpos1 .. $strpos2 mean the same thing?

[22:37] <TimToady> well, that's exactly what $0 is...

[22:38] <TimToady> I doubt .. would know what to do with StrPos, but StrPos might figure out what to do with ..

[22:38] <Juerd> A range makes more sense to me than substraction, actually.

[22:39] <TimToady> and .. could exclude the endpoints. :)

[22:39] <Juerd> And when working with times, I prefer periods to differences. (The difference between times A and B is the length of the equally shaped period)

[22:40] <TimToady> I once had a font with square periods...

[22:40] <Juerd> Don't make fun of my bad English please :)

[22:40] <TimToady> i wasn't making fun of your bad English

[22:40] <Juerd> Oh

[22:40] <TimToady> I was making a pun.

[22:40] <TimToady> I do that sometimes...

[22:41] <TimToady> unfortunately...

[22:41] <Juerd> Disregard my last statement then :)

[22:42] <TimToady> Fortunately, time is kinda uniform (to the first approximation),  Unfortunately, string lengths have multipathing problems.

[22:43] <Juerd> Personally, I think integers are fine, and some pragma can select which integers are wanted. I'm not likely to ever want anything else than character boundaries anyway.

[22:44] <TimToady> but it certainly the case that we should prefer APIs that deal with the strings themselves rather than indirectly referring to them via their locations

[22:44] <Juerd> Someone working with languages a lot will probably disagree with me that you need only one kind of position at a time.

[22:44] <Juerd> (no pun intended)

[22:44] <TimToady> Well, and byte boundaries are likely to be the internal form a StrPos in many cases.

[22:45] <TimToady> but you might have a pos in a string that doesn't even *have* bytes.

[22:45] <Juerd> Perl 5's strings also work fine for me. They give me characters, which typically is exactly what I want :)

[22:45] <Juerd> How does a byteless string work?

[22:45] <TimToady> espcially now that we can do things like @foo ~~ /stuff/

[22:46] <TimToady> you get handed a string with its minimum abstraction level set to, say, codepoints, and you aren't allowed to know it's repr internally.

[22:46] <Juerd> I see.

[22:46] *** Khisanth joined
[22:47] <Juerd> Would it make sense to make strings much simpler by default, and enabling all these non-character operations only if explicitly requested through a pragma?

[22:47] *** xinming joined
[22:47] <TimToady> Or you are matching an array of token objects.

[22:47] <Juerd> It would take a lot of complexity out of the language, without making anything less possible.

[22:47] <TimToady> That's the Str vs Buf distinction.

[22:48] <Juerd> Bufs don't do unicode

[22:48] <TimToady> that's correct.

[22:48] <TimToady> Unicode doesn't do integers.

[22:48] <Juerd> It does in Perl 5, and that happens to work well in most applications

[22:49] <TimToady> Even UTF-16 is not a fixed-width representation.

[22:49] * Juerd already knows much more about unicode/utf-8 than he would have liked to

[22:49] <TimToady> And at grapheme level, even shoving everything into UTF-32 doesn't help

[22:50] <Juerd> For many programmers, it'd be nice if there were just a sane default, instead of a forced choice. "length" may not make sense to unicode, it does make sense to most users...

[22:50] <TimToady> no, they just think it makes sense...

[22:50] <TimToady> And it does make sense, but not in the way they think it does.

[22:51] <Juerd> That hasn't bothered them before...

[22:51] <TimToady> They weren't using Unicode before.

[22:52] <TimToady> The reason the default level is graphemes is because that's closest to their intuition of what was happening before, even though that's harder for us.

[22:53] <TimToady> You can use integers at grapheme level, just as you can use integers in Perl 5 at codepoint level, but you have to do tricks to deal with variable length characters in any case.

[22:54] <Juerd> I wonder what the most often used application of string length is

[22:54] <Juerd> Could be %s-like stuff.

[22:54] <TimToady> that's yet another definition of length.

[22:55] <Juerd> In which case it's futile anyway, if someone should use  characters :)

[22:55] <TimToady> which has nothing to do with any of bytes, codepoint, graphemes, or characters...

[22:55] <TimToady> it's just a definition that depends on knowing your output device.

[22:55] <TimToady> or not caring.

[22:56] <TimToady> you'll note that HTML gets along fine without %s.

[22:56] <Juerd> Not caring, is my guess from what I've seen :)

[22:56] <Juerd> I use HTML almost always in combination with %s, but never witch character counts in between % and s :)

[22:56] <TimToady> basically, for interpolation, not sizing.

[22:56] *** coumbes joined
[22:57] <Juerd> sprintf(q[<a href="%s">%s</a>], uri_escape($url), encode_entities($url))

[22:57] <TimToady> interpolation

[22:57] <Juerd> Yes.

[22:57] * Juerd wonders what he would use in Perl 6

[22:58] * Juerd still wants a generic encoding thing, that works for every encoding. Probably not doable.

[22:58] <TimToady> q[<a href="{uri_escape($url)}">{encode_entities($url)}</a>]

[22:58] <Juerd> I think that's very ugly.

[22:58] <TimToady> don't deny it.

[22:58] <Juerd> Wouldn't you need qq, by the way?

[22:58] <TimToady> yeah

[22:58] <Juerd> Or q:c (?)

[22:59] <avar> print CGI->a($url, href => $url);

[22:59] <TimToady> q:url($rul)/.../

[23:00] <TimToady> s/ru/ur

[23:00] <Juerd> qq[<a href="{ $url.enc: <URI> }">{ $url.enc: <HTML> }</a>]  # dreaming

[23:00] <avar> you shouldn't be manually generating html in the first place;)

[23:00] <Juerd> avar: EEWWWWWwww, no. Please, no. No CGI->a.

[23:00] <Juerd> Or CGI.a

[23:00] <Juerd> Or anything generating a single tag with 1:1 translations.

[23:00] <TimToady> Didn't we tell you?  Perl 6 is an attempt to re-invent PHP...

[23:00] <xinming> Juerd: CGI.new.a IMO. :-)

[23:01] <avar> yay php

[23:01] <FurnaceBoy> it's best to warn him now

[23:01] <Juerd> If you have to know "a", you have to know HTML. If you know HTML, you're better off writing it yourself than letting code do it for you.

[23:01] <avar> Juerd: Whatever you're using it sucks less than manual HTML

[23:01] <avar> Juerd: no you're not

[23:01] <Juerd> If I have to learn a second syntax, please let it be DIFFERENT, so it doesn't feel like I'm wasting my time.

[23:02] <avar> Well actually your main code should probably not know of HTML at all;)

[23:02] <TimToady> I think we should write it all in lisp...

[23:02] <Juerd> Also, HTML <a> tags have nothing to do with CGI, at all. Please let this mistake stay out of Perl 6 world.

[23:02] <Juerd> avar: That's a better one already.

[23:02] <Juerd> avar: If if you have to abstract, let it be templates, not tag generation methods. Ew.

[23:02] <avar> Juerd: Indeed, html generation should not be in CGI

[23:03] <TimToady> declarative programming++

[23:03] <TimToady> as long as it's all imperative underneath :)

[23:04] <Juerd> imperative++  # Makes me feel I'm in control.

[23:04] <TimToady> feelings

[23:05] <Juerd>  :)

[23:06] <Juerd> 'does $this interpolate' the variable $this?

[23:06] <TimToady> hmm, statistical range objects...  say $x ~~ $y3   # "maybe"

[23:06] <avar> Juerd: yes

[23:07] <avar> ?eval my $x = 5; $x

[23:07] <avar> bleh

[23:07] <TimToady> no it doesn't

[23:07] *** evalbot_10054 is now known as evalbot_10056

[23:07] <evalbot_10056> *** Undeclared variable: "$x"     at -e line 15, column 7-43

[23:07] <TimToady> <<..>> do shellish quoting syntax

[23:07] *** larsen joined
[23:07] <avar> I thought it was just like " ' $foo ' "

[23:08] <Juerd> avar: It was the '' within  that I was curious about, as  does interpolate, but shellish '' doesn't

[23:08] <Juerd> I like .

[23:08] <TimToady> why would we want to duplicate " ' $foo ' "

[23:08] <Juerd> I've even taught my environment utf-8 for it.

[23:08] *** marmic__ joined
[23:09] *** marmic__ is now known as marmic

[23:09] <Juerd> TimToady: This doesn't glob, I hope? :)

[23:09] <TimToady> good gad no

[23:10] <TimToady> just the quoting

[23:10] <TimToady> and that not including backticks.

[23:10] <Juerd> Great

[23:11] *** Alya joined
[23:11] *** axarob joined
[23:25] * theorbtwo likes $x plusorminus $y as equiv to $x-$y .. $x+$y.

[23:26] <theorbtwo> (My compose key isn't set up to work in the console...)

[23:27] <theorbtwo> ?eval 1.1 ~~ 1..2

[23:28] <evalbot_10056> bool::false

[23:28] <theorbtwo> Hm.  Is that correct?

[23:28] <theorbtwo> (I'd prefer it be incorrect...)

[23:30] <avar> ?eval 1.1 == any(1,2)

[23:30] <evalbot_10056> bool::false

[23:30] <avar> ?eval [1..2]

[23:30] <evalbot_10056> [1, 2]

[23:30] <avar> ?eval 1 <= 1.1 <= 2

[23:31] <evalbot_10056> bool::true

[23:31] <avar> so you see it all makes perfect sense

[23:31] <theorbtwo> Yeah, avar, I know... hm, I suppose it doesn't make terrible amounts of sense for it to mean 1,2 in list context, but match anything between 1 and 2 as a smart-matcher.

[23:31] <theorbtwo> ...but writing {1<=$_<=2} when you want something to match against seems a bit of a false hufmanization.

[23:32] <Juerd> ?eval 1..2 :by(.1)

[23:32] <evalbot_10056> Error:  unexpected ":" expecting comment, operator, "does", "but", "is", "^till", "till^", "^..^", "till", "..^", "<=>", "^..", "cmp", "..", postfix conditional, postfix loop, postfix iteration, ";" or end of input

[23:33] <theorbtwo> Juerd: pugs doesn't parse adverbs on ...

[23:33] <theorbtwo> I wonder...

[23:33] <theorbtwo> ?eval infix:<..>(1, 2, :by(.1))

[23:33] <evalbot_10056> Error: No such sub: "&infix:.."

[23:36] *** FurnaceBoy_ joined
