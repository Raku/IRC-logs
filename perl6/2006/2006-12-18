[00:21] *** neonse left
[00:23] *** nekokak joined
[00:42] *** jamessan joined
[00:47] *** TimToady joined
[01:03] *** silent1985 joined
[01:03] *** audreyt joined
[01:06] *** mako132_ joined
[01:14] *** stef__ joined
[01:14] *** stef__ left
[01:22] <Nei> ?eval my $age = 7; given $age { when 4..12 { "good age".say } }

[01:22] <evalbot_r14912> undef

[01:22] <Nei> :(

[01:25] <Tene> ?eval my $age = 7; given $age { when 4..12 { "good age".say }; default { "omgwtf".say } }

[01:25] <evalbot_r14912> OUTPUT[omgwtf␤] Bool::True

[01:26] <Nei> any neat way to express the intended, avoiding $_?

[01:28] <Tene> ?eval my $f = 7; if ( $f ~~ 4..12 ) { say "it works" }

[01:28] <evalbot_r14912> undef

[01:28] <Tene> Huh.  I thought that worked.

[01:32] *** mr_ank joined
[01:40] *** lyokato joined
[01:55] <Nei> ?eval my $age = 7; given $age { when any 4..12 { "good age".say } }

[01:55] <evalbot_r14912> OUTPUT[good age␤] Bool::True

[01:56] <Nei> :)

[01:56] <Nei> ?eval my $age = 3; given $age { when any 4..12 { "good age" } default { "no." } }

[01:56] <evalbot_r14912> "no."

[02:03] *** phpError joined
[02:16] <Nei> is there a way to actually fall through in a given/when like in C?

[02:19] <audreyt> "continue"

[02:20] <Nei> ?eval my $age = 7; given $age { when 7 { continue } when 8 { "fail" } }

[02:20] <evalbot_r14912> undef

[02:20] <Nei> switch (7) { case 7:; case 8: printf("fail"); break; } --> fail

[02:22] <audreyt> oh, you mean to fallthru without testing

[02:22] <audreyt> S04:478

[02:22] <audreyt> (Note that, unlike C's idea of falling through, subsequent C<when>

[02:22] <audreyt> conditions are evaluated.  To jump into the next C<when> block you

[02:22] <audreyt> must use a C<goto>.)

[02:23] *** cognominal joined
[02:23] <allbery_b> hm, as I red that, you can do it with:  given $age { when 7 { foo } when any 7..8 { bar } }

[02:24] <allbery_b> ^red^read

[02:24] <audreyt> when 7|8 { bar }

[02:24] <allbery_b> or that

[02:24] <Nei> these are ugly, because they test twice

[02:25] <audreyt> the C treatment, though, is very confusing to me

[02:25] <audreyt> timtowtdi I guess...

[02:26] <allbery_b> yeh, many folks consider C's no-implicit-break to be a major source of bugs

[02:26] <allbery_b> (lint used to warn about cases without break unless you put a /*FALLTHROUGH*/ comment, even)

[02:26] <Nei> confusing for some, but powerful without doubt

[02:27] <ayrnieu> not that lint is anything to emulate.

[02:28] <allbery_b> hm?  old lint was a useful tool for catching most common semantic bugs.  the lint replacements I've seen over the past several years haven't been worth much, I'll grant

[02:30] <Nei> can someone show me a quick example of the goto way, I'm obviously too stupid

[02:30] <audreyt> Nei: you are not too stupid, pugs is 

[02:30] <audreyt> *goto is not implemented

[02:31] <audreyt> actually, t/blocks/goto.t doesn't really test goto LABEL.

[02:31] <audreyt> Nei: edit that file to add some failing tests?

[02:31] <audreyt> (do you have a commit bit? if not, what's your email addr? :-))

[02:32] <Nei> heh, I see

[02:32] <audreyt> the relevant spec is S04/The goto statement

[02:32] <Nei> that part of s04 seems pretty brief and without illustration

[02:32] <Nei> I guess everyone knows how goto works from p5

[02:33] <audreyt> well, you can port perl5's goto tests then

[02:34] <Nei> but thanks for the confirmation of pugs being the culprit :)

[02:34] <audreyt> but the #1 reason why this feature is not there, is that nothing tests for it :)

[02:34] <Nei> I have never committed anything to pugs

[02:36] <audreyt> do you have a commit account, though?

[02:36] <audreyt> if not, may I have your email address?

[02:38] <audreyt> welcome aboard!

[02:39] <audreyt> please commit with the account "Nei" to svn.pugscode.org after receiving the commit-bit mail

[02:39] <audreyt> http://search.cpan.org/dist/Perl6-Pugs/docs/Pugs/Doc/Hack.pod has some quickstart guide

[02:39] <lambdabot> Title: Pugs::Doc::Hack - How to hack on Pugs - search.cpan.org

[02:39] <audreyt> it's customary to add yourself to the AUTHORS file first, then commit it

[02:39] <audreyt> to test that svn works

[02:39] <audreyt> have fun :) I'll bbiab

[02:40] <Nei> I'm a wee bit scared though

[02:40] <audreyt> you'll get used to it :)

[02:41] <Nei> adding yourself to the authors for a tiny test, sounds a bit exaggerated

[02:42] <Nei> I'll see what I can do, though

[02:43] <allbery_b> the real reason pugs isn't complete is that @Larry's holding out until half the internet's in AUTHORS :>

[02:44] <Nei> heh

[02:48] *** silent1985 left
[02:49] *** bonesss joined
[03:15] *** scw joined
[03:36] *** bonesss joined
[03:38] *** hobbs joined
[03:38] *** bpalmer` joined
[04:05] *** robkinyon joined
[04:05] <robkinyon> stevan: ping

[04:05] *** bpalmer` left
[04:40] <stevan> robkinyon: ping me over on irc.perl.org please :)

[04:40] <stevan> unless you wanna chat here :)

[04:41] <robkinyon> feh

[05:04] *** lisppaste3 joined
[05:04] <svnbot6> r14913 | Nei++ | * Added myself (Nei) to AUTHORS to test svn commit, as per recommendation by audreyt.

[05:06] <Eidolos> :)

[05:18] <audreyt> Nei++

[05:18] <Nei> now, if I add just some goto label

[05:18] <Nei> that will make pugs fail hard

[05:19] *** nipra joined
[05:19] <Nei> should I try to catch that somehow?

[05:19] <audreyt> you can use eval""

[05:19] <audreyt> see t/README for ideas

[05:20] <audreyt> is(eval("goto FOO; FOO: 1"), 1)

[05:20] <audreyt> something like that

[05:25] <svnbot6> r14914 | Nei++ | * Test for goto LABEL

[05:25] <audreyt> woot

[05:26] <Nei> I'll port the p5 tests (maybe) if this one passes

[05:26] <audreyt> Nei++

[05:28] <gaal> haha oleg does it again. variable type state monad

[05:28] <Nei> I understand this is not  the focus, but is there some secret to improving pugs startup time? it spends 20 seconds on the prelude =)

[05:28] <gaal> do you have a blib6/lib/Prelude.pm.yml file?

[05:28] <gaal> and: did you 'make

[05:28] <gaal> ' or 'make fast'?

[05:29] <gaal> also, run a new GHC, it helps

[05:29] <gaal> gotta moose &

[05:31] <Nei> I did a make, I have a Prelude.pm.yml

[05:31] <Nei> I'll try a new ghc

[05:31] <Eidolos> pugs takes only a second or so to boot up here (r14912 :))

[05:31] <Tene> couple seconds here.

[05:31] <Tene> 10 seconds or so on desktop.

[05:31] <Nei> my computer is exceptionally bad ;)

[05:32] <Eidolos> Ah, not much to be done about that, especially if you used make and not make fast.

[05:32] <Nei> so make fast makes faster, at the expense of slower runtime?

[05:33] <Eidolos> Yeah, pretty sure.

[05:34] <Nei> has someone started an easy & comprehensive p6 intro yet? there is a shitload of docs, but the exegeses/synopsis/apocalypsis stuff is a bit too much to read through for me.. I suspect maybe I'm just being blind

[05:35] <Tene> Nei: what sort of things would you want covered in an intro?

[05:36] <Nei> good question... I think something in the lines of perl5intro and perl5syn

[05:37] <Tene> I haven't seen one, but I might put one together sometime.

[05:38] <Nei> cool :)

[05:39] <Tene> I wish I would have thoguht of those for the last-minute presentation I threw together last week.

[05:39] <Eidolos> Will perl6 still have computed gotos?

[05:39] <Eidolos> er, Perl6 :)

[05:39] <Eidolos> That's another thing you might add a test for, Nei.

[05:39] <Eidolos> perl -e 'goto "label" . (1+1); label1: die "1"; label2: die "2";' -- dies with 2

[05:40] *** luqui joined
[05:41] <Nei> thing is, imo the docs concerning goto are not very detailed

[05:41] * Eidolos nods.

[05:46] <luqui> My guess is that goto LABEL is illegal, and it is either gone or spelled goto 'LABEL'

[05:49] <Nei> it is definitely not gone

[05:49] <Nei> since s05/a04 talk about it

[05:50] <Nei> *s04

[05:50] <Nei> as for whether the label needs to be quoted... I'd disagree, it is nothing evaluated during runtime

[05:50] <Nei> (although p5 does support the goto EXPR, as mentioned by Eidolos )

[05:51] <luqui> Nei, so goto has special syntax?

[05:51] <luqui> i.e. it is a macro?

[05:51] <Nei> are there standard means to resolve uncernties in the specs ?

[05:51] <luqui> ask @Larry

[05:51] <Eidolos> Nei: await the return of The Man :)

[05:52] <luqui> luqui (in) @Larry, but doesn't usually make decisions

[05:53] <Nei> on second thought

[05:53] <Nei> you might be right

[05:53] <Nei> :P

[05:54] * luqui doesn't have much clue about this matter...

[05:54] <ingy> hola

[05:54] <luqui> guten tag, ingy 

[05:54] <ingy> nihao luqui 

[05:55] <luqui> anata wa como estas?

[05:55] <luqui> :-p

[05:55] <svnbot6> r14915 | Nei++ | * [t/blocks/goto.t] Added quotes to the goto 'label' as pointed out by luqui. (This is in line with last.)

[05:55] <ingy> ooo luqui, you make me so hot.

[05:56] *** gosha joined
[05:56] <Eidolos> hmm.

[05:56] * ingy takes a cold shower

[05:56] <luqui> . . .

[05:56] <gosha> hey guys, just curious does perl have templates and generics?

[05:56] <gosha> perl6 that is

[05:56] <luqui> gosha, fortunately not

[05:56] <luqui> (yes, sortof)

[05:56] <ingy> of course it does

[05:56] <gosha> fortunately?

[05:57] <ingy> Perl 6 has CPAN!

[05:57] <luqui> it has generics in the haskell/ml sense, not the c++ sense

[05:57] <ingy> it all just works

[05:57] <luqui> (again, sortof)

[05:57] * ingy ducks

[05:59] <luqui> S06 covers some of that, S12 covers some of that, but I still think we're not totally solid on the generics model

[06:00] <luqui> Nei, you said "this is in line with last"?

[06:00] <luqui> the test suite disagrees.  is there somewhere in the specs you are quoting?

[06:00] <gosha> Hmm. I understand I can define a list of integers like so:  my Int @list. Why not generic classes like "my SomeClass @list"?

[06:01] <Nei> ?eval my @h = 'cat', 'dog'; LOOP: for @h -> $t { $t.say; last 'LO' ~ 'OP'; }

[06:01] <luqui> gosha, uh, yeah, of course

[06:01] <evalbot_r14915> OUTPUT[cat␤] undef

[06:02] <luqui> ?eval my @h = <cat dog>; LOOP: for @h -> $t { $t.say; last LOOP; }

[06:02] <evalbot_r14915> OUTPUT[cat␤] Error: No compatible subroutine found: "&LOOP"

[06:02] <luqui> aa soo

[06:02] <luqui> okay, good

[06:02] <luqui> I'm satisfied with that

[06:04] <Nei> maybe goto should be a statement and not a block?

[06:04] <luqui> goto is a block?

[06:04] <Nei> maybe not, but the file is in t/blocks/goto.t

[06:05] <luqui> oh, so you're just talking about test organization

[06:05] <luqui> yeah, statements makes sense to me

[06:06] <Nei> is the statements/last.t test concerning last LABEL .. wrong?

[06:06] <Nei> or is pugs wrong

[06:06] <luqui> I'm guessing pugs is wrong

[06:06] <luqui> S06, line 2655

[06:06] *** gosha left
[06:06] <luqui> (the C<leave> function)

[06:07] *** bsb left
[06:07] <luqui> er, line 2045

[06:09] <Eidolos> Wow, the examples/cookbook directories are damn near empty. :/

[06:09] <Nei> *sigh*

[06:10] <Nei> so my initial code might have been correct as far as the specs go

[06:10] <Nei> well I suppose that goto EXPR still wont go away

[06:10] <Nei> good thing we've talked about it 

[06:24] <Nei> bah, pugs ignores last EXPR

[06:31] <svnbot6> r14916 | Nei++ | * bah >_>

[06:35] <Eidolos> What's the idiomatic way to add an element to an array? I don't see push in any of the testing code.

[06:38] <Nei> ?eval @a = 'cat'; @a.push('dog'); @a

[06:38] <evalbot_r14915> ["cat", "dog"]

[06:38] <Nei> looks like push is still there

[06:38] <Eidolos> huh. OK, thanks :)

[06:45] *** Aankhen`` joined
[06:52] <TimToady> @tell luqui yes, that is correct, there are no places in Perl 6 where a list in scalar context defaults to returning the final value.  it just returns the list as an item.

[06:52] <lambdabot> Consider it noted.

[06:55] <Eidolos> ?eval %x = (foo => "bar", baz => "quux"); %x ~~ "foo";

[06:55] <evalbot_r14916> Bool::False

[06:56] <Eidolos> Does hash ~~ scalar check for existence or truth?

[06:57] <Eidolos> A04 and S04 say truth, but..

[06:57] <TimToady> S03 sez existence

[06:57] <Eidolos> ohh

[06:58] <Eidolos> Yeah I'm misreading the table, sorry.

[06:58] <TimToady> assuming Hash/Any matches first.

[06:59] <TimToady> Nei: loop and goto labels are one of those areas where we just handwaved it to be "like Perl 5".  It's not terribly well specced how to deal with ambiguities though.

[07:00] <TimToady> should "goto foo()" parse, for instance...

[07:01] <TimToady> I'm inclined to say that goto, next, etc force the next identifier to autoquote, and if you really need computed goto, you should have to say goto(foo()).

[07:02] <TimToady> alternately, only allow autoquotes of labels that are visible in the current outer scope.

[07:02] <TimToady> Unfortunately that doesn't help in parsing forward goto's...

[07:04] <Nei> is there a tradition of introducing mandatory () to force non-autoquoting?

[07:05] <TimToady> there's a tradition of forcing *something* where autoquoting would get it wrong.

[07:05] <TimToady> in the case of =>, "foo" => "bar"

[07:06] <TimToady> or foo() => "bar"

[07:06] *** ofer1 joined
[07:06] <TimToady> Perl 5 has a long tradition of jumping though hoops to try to second guess the programmer.

[07:07] <TimToady> we're trying not jump through quite so many hoops for Perl 6

[07:08] <TimToady> but certain keywords are much like sigils

[07:08] <TimToady> if you say $foo() it parses as $foo and (), not as $ and foo()

[07:09] <TimToady> so I don't think forcing goto foo() to parse as "goto foo" and () is all that bad.

[07:09] <TimToady> the situation won't arise all that often in practice.

[07:09] <Nei> mhm

[07:10] <Nei> I wonder if you can always get away with "this wont happen so often"

[07:10] <TimToady> 'course not, for things that happen often. :)

[07:10] <Eidolos> Strings don't have a length method?

[07:10] <TimToady> measured in what units?

[07:10] <Eidolos> ahh, thanks :)

[07:10] <TimToady> .chars works

[07:11] <Nei> ?eval my $x = sub { "c" }; $x()

[07:11] <evalbot_r14916> "c"

[07:11] <TimToady> .bytes might or might not work depending on whether the particular string type lets you.

[07:11] * Eidolos nods.

[07:14] <Nei> ?eval sub foo { "l" }; my %x = ( foo() => "n" ); %x

[07:14] <evalbot_r14916> {("l" => "n"),}

[07:14] <Nei> I think it'd make most sense to treat the autoquoting of labels like =>

[07:15] <TimToady> .chars is guaranteed to work, but only by downgrading to the maximum allowed abstraction level, so depending on lexical context and the type of the string, might really mean graphemes or codepoints or even bytes.

[07:15] <Nei> so that goto foo() would jump to "l"

[07:15] <Eidolos> :)

[07:15] <Nei> this happens to match my intuitive opinion, but ymmv of course

[07:15] <TimToady> except that => has the benefit of seeing foo() from the right side rather than the left.

[07:16] <TimToady> we're not installing multi-token lookaheads if we can help it.

[07:16] <Nei> I dont write compilers, parsers or other sick shit

[07:17] <TimToady> and unfortunately the parser has to decide what foo is pretty much as soon as it sees it.

[07:17] *** marmic joined
[07:17] <Nei> actually you're not making much sense

[07:18] <Nei> => sees foo() on the left side afaikt

[07:18] <TimToady> on its left side, but on the "foo()"'s right side, is what I meant.

[07:18] <ingy> on the left == from the right

[07:18] <TimToady> it sees it on the parenthesis side.

[07:19] <Nei> mhm well I'm sure you know a lot of stuff and I dont; and surely I cannot decide what perl6 will be :)

[07:20] <Nei> just saying that I could see some sense in handling labels similar to how => autoquotes.. cant judge if it's "not worth the effort"

[07:20] <Nei> on the other hand, if these cases rarely occur, does it still matter so gravely?

[07:21] <TimToady> well, having put lots of such heuristics into Perl 5, I would prefer to keep things a bit simpler in Perl 6 where we can get away with it.

[07:21] <TimToady> the heuristics belong in trying to explain error messages, not it trying to parse things despite the ambiguity.

[07:21] <Nei> but if the lack of heuristics actually causes illogical behaviour that requires special documenting

[07:21] <TimToady> so I'd prefer that "goto foo()" fail but give a good diagnostic why.

[07:22] <Nei> then we might be better off disallowing LABEL altogether and always requiring or assuming EXPR

[07:22] <TimToady> by far the LABEL is the common case.

[07:23] <TimToady> I've written two or three EXPR goto/next's in my life.

[07:23] <Nei> I don't like having to explain "well you have this goto here and in most of the cases you can omit the () but you see, if you want the  goto to jump to the return of a sub, theeen you have to use goto()"

[07:23] <TimToady> requiring goto(foo()) is not really any hardship as long as it doesn't just silently misbehave without the parens.

[07:23] <Nei> but thats just me of course :)

[07:25] <Nei> I think another discrepancy in my mind is that I assocate () with functions, and I dont like to view control statements as such

[07:25] <TimToady> well, there is that.

[07:25] <TimToady> goto (foo()) also works.

[07:25] <TimToady> so does goto &foo()

[07:25] <Nei> yea, of course 

[07:26] <TimToady> anything that stops it looking like an identifier.

[07:26] <Nei> I still need to get accustomed to the &sub() syntax that I tried to forget in p5

[07:26] <svnbot6> r14917 | Ovid++ | Misses a "splice in scalar context" test.  It's fixed now.

[07:26] <TimToady> again, much like $foo vs $$foo or $(foo)

[07:27] <Nei> how do you go to a sub in p6?

[07:27] <TimToady> oh, &foo.call() or some such.

[07:28] <TimToady> unlike in P5, &foo never calls foo, it's just the sub object.

[07:30] <Nei> there has to be a syntax similar to goto &foo

[07:30] <Nei> or not :/?

[07:31] <Nei> ?eval goto foo;

[07:31] <evalbot_r14917> Error: No compatible subroutine found: "&foo"

[07:31] <Nei> what is it doing there?

[07:31] <TimToady> P6 supports tailcall optimization, so all it has to be is an ordinary call, really.

[07:31] <TimToady> but sometimes you want to make it explicit.

[07:32] <Nei> it is looking for some &foo, but with which goal?

[07:32] <TimToady> goto isn't implemented yet.

[07:32] <Nei> ah so

[07:33] <revdiablo> ?eval goto goto;

[07:33] <evalbot_r14917> Error: No compatible subroutine found: "&goto"

[07:33] <TimToady> if it had found foo() it wouldn't have found goto()

[07:33] <revdiablo> =)

[07:33] <Nei> ye makes sense now

[07:33] <TimToady> ?eval foo foo;

[07:33] <evalbot_r14917> Error: No compatible subroutine found: "&foo"

[07:33] <Nei> so there wont be a goto &foo ?

[07:34] <TimToady> not with that syntax.

[07:34] <Nei> ?eval sub foo { "l" }; &foo.goto

[07:34] <evalbot_r14917> "l"

[07:35] <TimToady> that currently works, and we might keep it.

[07:35] <Nei> whats the difference between foo, &foo.goto and &foo.call?

[07:37] <TimToady> .call is for use within wrappers, and things like wrappers, that want to pretend they're not on the call stack.  so it may subsume .goto

[07:38] <TimToady> basically foo is for a "real" call from the viewpoint of the user, and .call and friends are infrastructural

[07:39] <TimToady> so an autoloader would use .call just as it would use 'goto &foo' in P5

[07:39] <TimToady> except we've split out the lookup and call parts of autoloading in P6

[07:40] <TimToady> .call also assumes you're passing the current argument list in to another routine with the same (or similar) signature.  You can override that, but it's not default for .call.

[07:42] <Nei> I see, thanks for the explanations

[07:42] <TimToady> if we keep &foo.goto then probably goto &foo also works still.

[07:44] <TimToady> it's not like goto could do much else with a sub ref, other than fail...

[07:44] <Nei> heh

[07:44] <TimToady> implicitly calling it would be not in the spirit of P6

[07:45] <TimToady> so oddly it's one of things that actually is a little cleaner in P6; it's just that goto &foo is smelly in P5, and that kind of carries over a little.

[07:47] <Nei> well tbh I rarely use goto &sub

[07:47] <Eidolos> I almost used it once.. hehe.

[07:47] <Eidolos> (then I turned the recursive loop into an iterative one..)

[07:47] <Nei> but goto expr is more common imo, or at least from what I know

[07:47] <TimToady> I've actually used goto &sub a lot more than goto LABEL.

[07:47] <TimToady> but I've written a lot of autoloaders...

[07:48] <Nei> because you have an excuse for goto &sub, whereas goto label is mostly just BASIC

[07:48] *** iblechbot joined
[07:48] <TimToady> and any place goto LABEL is used repetitively, we've replaced it with something else, like "redo"

[07:49] <TimToady> arguably, that's something people might want for case statements.

[07:49] <TimToady> the problem with having a "fallthrough" verb, though, is what to do if the next statement is not a "when".

[07:50] <TimToady> it seems like it's okay to fall back to goto for this, rather than defining a new verb.

[07:50] <Nei> the flexibility of perl's given, makes this difficult

[07:51] <Nei> but actually, goto will still not make me happy

[07:51] <TimToady> and having a goto paired with a label in the target block makes it unambiguous even if an intervening statement is added

[07:51] <Nei> given $x { when a { goto B } when b { B: goto C } when c { C: goto D } } 

[07:51] <Nei> now add a case

[07:51] <Nei> besides its a waste of labels :/

[07:52] <TimToady> well, almost certainly indicates you should have been using polymorphism rather than a case statement...

[07:53] <Nei> there might be better ways to do what you want, agreed :)

[07:53] <Nei> *what I want

[07:53] <TimToady> no, you don't want it.  you just think you *might* want it someday.

[07:54] <TimToady> I don't think you ever actually will.

[07:54] <Nei> it is probably too ugly ^^

[07:54] *** TimToady joined
[07:55] <Nei> just because I write stuff like that in $other_language, probably it can be done in a nicer way in perl

[07:56] <TimToady> at some point, as a language designer I have to cut it off and say "the opportunity cost of people learning this new feature is too great to be justified on the few possible use cases."

[07:56] <TimToady> my tolerance for forcing people to learn features is pretty high, compared to most language designers.

[07:57] <Nei> ^^

[07:57] <TimToady> but even I have my limits.  :)

[07:57] <TimToady> mostly because it also means I have to keep explaining the feature.

[07:57] <Nei> although, a statement that would just skip the next "when" test, might work

[07:58] <Nei> or maybe

[07:58] <Nei> isnt there something to say

[07:58] <Nei> when "previous" or ... { ..}

[07:58] <Nei> basically an inverse fallthrough

[07:59] <TimToady> wouldn't need anything special

[07:59] <TimToady> given $x { my $fallthru = 1; ... when $fallthru or ... {...}

[08:01] <Nei> basically you need to reset the fallthru variable at each  new fallthru block

[08:01] <Nei> it doesnt look too bad, I guess

[08:01] <TimToady> nah, just default like C.  :)

[08:01] <TimToady> I'd much rather encourage people to use "next METHOD" instead.

[08:02] <Nei> what do you mean exactly?

[08:02] <TimToady> the dispatchers are already set up to allow redispatch to the next-most-likely method.

[08:02] <TimToady> see S12.

[08:04] <Nei> mhm

[08:04] <TimToady> basically if you're doing multi dispatch, various routines could handle your data, but you call the most specific ones first, and they can use "next METHOD" to call more generic ones after themselves.

[08:04] <TimToady> which is usually what you want fallthrough for in a switch.

[08:05] <Nei> true

[08:05] <Nei> but that sounds very oo-ish

[08:05] <TimToady> well, sure, in spots.  multimethod dispatch is more about types than objects though.

[08:07] <Nei> but how many more lines does the multimethod stuff add over a C switch, for some reason I have the impression that it is enormous

[08:07] <Nei> like you need to have your own sub for each case

[08:07] <TimToady> which for short ones can be one line, just like a 'when'

[08:08] <TimToady> the problem with switches is that they can't do multidimension pattern matches without cascaded switch statements

[08:09] <TimToady> and they're very hard to maintain.

[08:10] <TimToady> especially when you want to make decisions that cut across the "wrong" dimension

[08:10] <TimToady> multiple dispatch solves these sorts of problems easily.

[08:10] <Nei> do I not need a class hierarchy for that stuff to work?

[08:11] <TimToady> you need types for it to work.  a class hierarchy is one way of supplying types.

[08:11] <Nei> I'm too much of a n00b

[08:11] *** awwaiid joined
[08:12] <TimToady> well, you don't have to learn it all at once.  in the meanwhile, P6's switch statement is a lot more powerful than anything in P5...

[08:12] <Nei> heh

[08:12] <Nei> I already like it :)

[08:13] <Nei> I tried the source filter p5 switch in some project but it really should carry some bigger warnings

[08:13] <TimToady> indeed, source filtering is one of those things where you use it on a problem, and then you have two problems...

[08:14] <TimToady> one of those areas where the P5 solution was too simple.

[08:15] <TimToady> the trick has been to design in all the necessary complexity without making the simple jobs any harder.

[08:15] <TimToady> I think we mostly been successful there.

[08:15] <TimToady> but there's definitely more there to learn if you decide to learn it all.

[08:16] <TimToady> it's almost a complete course in C.S. to get to the bottom of it all, in fact...

[08:16] <TimToady> but worth it for those who get there, we sincerely hope...

[08:17] <TimToady> and we hope there are many metastable waystations at which to rest.

[08:17] <Eidolos> Hrm.

[08:18] <Nei> :)

[08:18] <TimToady> with plenty of signs that say "HERE THERE BE (nice) DRAGONS!"

[08:18] <Eidolos> I think I have a bug here with Pugs' delete.

[08:18] <TimToady> you know it doesn't support P5 syntax?

[08:18] <Eidolos> %food_color.delete(<Carrot Apple Cabbage>) works, but the following doesn't: delete (%food_color, <Carrot Apple Cabbage>);

[08:18] <Eidolos> hehe, yes :)

[08:19] <Eidolos> I'm working on upgrading the Perl Cookbook's code! :)

[08:19] <Eidolos> (and in the meantime learning the little changes in the language)

[08:19] <Nei> why is there push,but not delete?

[08:19] <Eidolos> Let me try to isolate the problem.

[08:19] <TimToady> well, you'd have to write it delete(%food_color: <...>)

[08:19] <TimToady> no space, plus a colon after the invocant

[08:20] <Eidolos> is delete(%h1, <c d e>), @cde, "test for delete multiple keys. (Indirect notation)";

[08:20] <Eidolos> passes tests :/

[08:20] <TimToady> probably a historical accident, but we might choose to preserve it.

[08:20] <TimToady> much like it really ought to be push @foo: 1,2,3, but we still allow push @foo, 1,2,3

[08:21] <Nei> better rid yourself of these things while you still can

[08:22] <TimToady> some of 'em, not all of 'em

[08:22] <TimToady> Perl will still be a TMTOWTDI language

[08:24] *** luqui joined
[08:25] <Eidolos> Hmm, OK, maybe it isn't a bug in pugs.

[08:25] <Eidolos> or at least I can't reproduce it except in the original script.

[08:28] <Nei> does anyone actually use Form(at)s?

[08:29] <Eidolos> I've never used Perl5 formats, no

[08:30] <Eidolos> OK, cool, I got it to fail.

[08:32] <Eidolos> Hmm.

[08:33] <Nei> how do I force types in perl?

[08:33] <Eidolos> like: my Int $x; ?

[08:33] <Nei> ?eval my Int $x

[08:33] <evalbot_r14917> \::Int

[08:34] <Nei> ?eval my Int $x; $x = "a"; $x

[08:34] <evalbot_r14917> \"a"

[08:34] <Eidolos> I don't think pugs supports it yet.

[08:34] <Nei> ok thanks

[08:35] <Eidolos> That's weird.

[08:35] <Eidolos> I don't get the problem in pugs -e

[08:35] <Eidolos> but I have a .t file that's failing.

[08:36] <Eidolos> http://www.rafb.net/paste/results/wyHt9f11.html

[08:36] <buubot> The paste wyHt9f11 has been copied to http://erxz.com/pb/608

[08:36] <Eidolos> Expected: 'Lemon', Actual: 'Banana Carrot Lemon Apple'

[08:38] <Eidolos> (you have to: use Test plan => 1)

[08:39] <Nei> Eidolos this really works in pugs?

[08:39] <TimToady> remove the space after delete

[08:39] <Eidolos> It doesn't work here.

[08:39] *** fayland joined
[08:39] <Eidolos> yep, that fixes it. Weird!

[08:40] <TimToady> not weird, if you understand why S02 requires function args to be adjacent

[08:40] <Eidolos> I see.

[08:40] <TimToady> otherwise the parentheses are taken to be around the first argument.

[08:41] <TimToady> in order to have a very extensible language system that allows postfix operators, you have to distinguish real postops from things that aren't

[08:41] <Eidolos> ahh

[08:41] <TimToady> and function args are in the "real" category.

[08:41] <Nei> a little bit evil

[08:42] <TimToady> but very consistent, once you get used to it, and motivated for futureproofing reasons.

[08:42] <TimToady> see S02 for more explanation.

[08:42] <Eidolos> So would it work OK without any parentheses?

[08:42] <TimToady> probably.

[08:42] <dduncan> I have a question in the spirit of that recent supertype discussion on p6l ... maybe the answer is similar, or maybe not ...

[08:43] <Eidolos> yeah, works OK without parens.

[08:43] <TimToady> k, though I should be getting to bed pretty soon...

[08:43] <dduncan> is it possible to declare something in Perl 6 such that if a value is declared, it would automatically assume the most specific data class / the most-sub subclass that it could be part of?

[08:44] <TimToady> you mean like 1 is an Int and not a Num

[08:44] <dduncan> eg, if someone declared a "subset Evens" within scope, and then after we said my $foo = 6; then the value of $foo isa Evens rather than Int

[08:44] <TimToady> on the other hand, why is it not a UInt2 in that case?

[08:45] <TimToady> since 0..1 is large enough...

[08:45] <dduncan> whatever

[08:45] <TimToady> you can't be "isa" a subtype

[08:45] <dduncan> okay

[08:46] <TimToady> if you ask for the actual type of a value it will give you the "base" type on which the subset is based.

[08:46] *** drrho joined
[08:46] <dduncan> its possible that my idea is somewhat contrived, but that's why I'm putting it out here quickly rather than on p6l

[08:46] <Eidolos> my Evens $foo; ?

[08:47] <dduncan> or a similar interesting feature would be, given a particular $foo, if there was a short-hand to introspect the system for the most specific type that includes that value

[08:47] <Eidolos> Like Haskell's :t?

[08:47] <dduncan> I'm not that familiar with Haskell

[08:48] <dduncan> on a tangent ...

[08:48] <TimToady> it sounds remarkably like multi dispatch to the most specific sig.

[08:48] <TimToady> assuming there was some particular call that all types participate in.

[08:49] <TimToady> as the single first argument

[08:49] <Eidolos> :t (in Haskell) lets you inspect the type of any expression. I think it's actually most general, not specific, type that fits, because otherwise you run into that UInt2 problem. :)

[08:49] <lambdabot> parse error on input `in'

[08:49] <dduncan> just as we can declare a variable like "my Foo|Bar $baz;", could we alternately say "my Foo&Bar $baz;" or some such ... eg, $baz must be something that is both a Foo and a Bar ... or I suppose perhaps this constraint is usually specified with a chain instead

[08:49] <Eidolos> :t fibs = 1 : 1 : (zip (+)) fibs (tail fibs)

[08:49] <lambdabot> parse error on input `='

[08:49] <Eidolos> :t 1 : 1 : (zip (+)) fibs (tail fibs)

[08:50] <lambdabot> Not in scope: `fibs'

[08:50] <lambdabot>  

[08:50] <lambdabot> <interactive>:1:29: Not in scope: `fibs'

[08:50] <Eidolos> oh, nevermind, I'll knock it off :)

[08:50] <dduncan> anyway, don't take my questions too seriously for the moment

[08:50] <TimToady> for the moment we're trying to limit junctional types to where constraints, not to real storage declaratoins

[08:50] <Eidolos> (oh, I see, I used zip where I needed zipWith, duh)

[08:50] <Eidolos> among other things >_>

[08:51] <Eidolos> I'll stick to Perl..

[08:51] <dduncan> okay ... but if you change your mind, that might be useful, perhaps

[08:51] <dduncan> mind you, from my own work into this area ...

[08:51] <TimToady> well, if every type declaration automatically generates a "multi mostspecific (MyType)" then it would work

[08:52] <TimToady> or it would fail on ambiguity

[08:52] <TimToady> probably usually fail

[08:52] <TimToady> 42 is Even and also UInt8

[08:53] <TimToady> which is more specific?

[08:53] <TimToady> assuming Even is "subset Even of Int where ($_ !% 2)" or some such

[08:54] <TimToady> I guess a use case would be in order.

[08:55] <dduncan> fyi, I've been spending the last few hours writing down an intro to a type system I may use in my database project which is based on sets, such that every type is a set of values, and subtypes are typically subsets, etc ... in the process was also brought up matters of multiple inheritence, such as a diamond-inheritence of Parallelogram, Rectangle, Rhombus, Square ... Square in this case is the intersection type of Rectangle and Rhombus

[08:56] <dduncan> suffice it to say that it is a simpler landscape than what Perl is dealing with

[08:56] <Eidolos> wheren't :)

[08:56] <TimToady> yeah, and the set theory turns inside out when you switch between extensional and intensional views.

[08:57] <dduncan> in the system I setup, all possible values belong to a universal set, which correspond's to Perl's "Any" designation (which no value can have, but variables can hold), and normal data types are subsets thereof

[08:58] <TimToady> well, I should have used {...}, not (...), and if I did add !% it would probably mean "not divisible evenly by", but that's inconsistent with ! in other ways.

[08:58] <dduncan> practically, all user-defined types have to be based on system-defined ones, either through subtyping or unioning or construction

[08:59] <dduncan> in the case of subtyping, the user hasn't added new values that can be seen, but with construction they have

[08:59] <dduncan> construction meaning like declaring a class with attributes

[09:00] <dduncan> in this system, while a value can be of multiple types, it has its own most-specific-type, and is automatically promoted to the most-specific-type in the system that includes it

[09:00] <dduncan> mind you, some of those details users probably can ignore

[09:01] <dduncan> practically, it is still like values of a subtype of Foo still being considered just a Foo

[09:01] <dduncan> anyway, good night!

[09:01] <TimToady> well, according to mmd, the most specific type of 42 is 42.

[09:02] <dduncan> in the system I described, if a type called "EvenInts" was defined, then 42 would be one of those

[09:03] <TimToady> but if I say "multi foo (42) {...}" it matches only type 42.

[09:03] <dduncan> if I had declared "multi foo (Int)" and "multi foo (EvenNum)", I assume the latter would be invoked

[09:04] <TimToady> as long as you didn't have (foo) too

[09:04] <TimToady> (42) rather

[09:04] <dduncan> mind you, according to good design, it shouldn't matter ... because both such functions should have identical semantics

[09:05] <TimToady> that's why we spend a lot of time handwaving that enums are types as well as values.

[09:05] <dduncan> and so the latter would only even be defined if EvenNum was defined as something else that does Int and is implemented differently underneath

[09:05] <dduncan> rather than as a subset

[09:06] <TimToady> yeah, it gets into duck vs named typing eventually

[09:06] <TimToady> for some definition of duck, and name...

[09:06] <TimToady> well, really gotta go snooze, my eyes are glazing over.

[09:07] <dduncan> indeed, good night 1 and Inf

[09:07] <TimToady> I'll settle for 1 and *

[09:07] <TimToady> zzz &

[09:07] <dduncan> yyy &

[09:17] *** dduncan left
[09:33] *** RHainsworth joined
[09:33] *** RHainsworth left
[09:51] *** araujo_ joined
[09:52] *** araujo joined
[10:01] *** elmex joined
[10:05] *** buetow joined
[10:14] <Debolaz> Will @foo>>.bar; call method bar on each object in @foo? That's what I'm reading S12 as, but I can't get it to work in pugs.

[10:16] <jrockway> ?eval (1,2,3)>>.sqrt

[10:16] <evalbot_r14917> (1.0, 1.4142135623730951, 1.7320508075688772)

[10:16] <jrockway> works for me :)

[10:17] <jrockway> ?eval my @a = (1,2,3); @a>>.sqrt

[10:17] <evalbot_r14917> (1.0, 1.4142135623730951, 1.7320508075688772)

[10:17] <jrockway> Debolaz: what is in @foo, and can it bar?

[10:17] <Debolaz> class Foo { sub bar { say "Hello world!" } }; my @baz = (Foo.new,Foo.new); @baz>>.bar;

[10:18] <Debolaz> Is there a typo here somewhere?

[10:18] <jrockway> can you ?eval that?

[10:18] <Debolaz> I got the sqrt example to work.

[10:18] <Debolaz> ?eval class Foo { sub bar { say "Hello world!" } }; my @baz = (Foo.new,Foo.new); @baz>>.bar;

[10:18] <evalbot_r14917> Error: No compatible subroutine found: "&>>bar"

[10:19] <jrockway> ?eval class Foo { sub bar { say "Hello world!" } }; Foo.new

[10:19] <evalbot_r14917> Foo.new()

[10:19] <jrockway> i'm not 100% sure that ClassName.new() creates a new instance

[10:19] <jrockway> but then i don't really know :(

[10:19] <Debolaz> Foo.new.bar works btw.

[10:20] <jrockway> oh

[10:20] <jrockway> what happens if you do something without side-effects?

[10:20] <Debolaz> ?eval class Foo { sub bar { "Hello world!" } }; Foo.new.bar

[10:20] <jrockway> bar { 42 }

[10:20] <evalbot_r14917> "Hello world!"

[10:20] <Debolaz> So Foo.new obviously works in some context..

[10:20] <jrockway> ?eval class Foo { sub bar { "Hello world!" } }; (Foo.new(), Foo.new()).bar

[10:20] <evalbot_r14917> Error: No compatible subroutine found: "&bar"

[10:21] <jrockway> ah, it's calling it on the list

[10:21] <jrockway> (1,2).sqrt

[10:21] <jrockway> ?eval (1,2).sqrt

[10:21] <evalbot_r14917> 1.4142135623730951

[10:21] <jrockway> i see...

[10:21] <jrockway> i guess >>. should work

[10:22] <Debolaz> Am I doing something wrong here?

[10:22] <jrockway> not that i know, but you're asking the wrong person :)

[10:22] <jrockway> i guess you could do:

[10:22] <jrockway> ?eval (Foo.new(),Foo.new()).map { 42 }

[10:23] <evalbot_r14917> Error: ␤Unexpected "{"␤expecting operator

[10:23] <jrockway> i forget the syntax for map though

[10:23] <jrockway> s/forget/don't know/

[10:23] <jrockway> :/

[10:23] <Debolaz> Still, the problem isn't so much getting all methods called. It's that S12 says this should work and it does apparently work on some arrays of objects but not on others..

[10:24] <Debolaz> And I suspect I may be the one who is doing something wrong, but I have no idea what. 

[10:26] <jrockway> well, let's look at the tests and see what they do

[10:26] <jrockway> i know in audreyt++'s slides, she uses the sqrt example :)

[10:26] <jrockway> and that works :)

[10:27] * Debolaz prods audreyt.

[10:28] <Debolaz> audreyt: Help the less intelligent ones. Tell me what I'm doing wrong here. 

[10:28] <jrockway> i'm looking through the tests to give you an example

[10:32] <Tene> Debolaz: what's different about the arrays that work and those that don't?

[10:33] <Debolaz> Tene: Only thing I can see is different is whether they contain blessed objects or not.

[10:33] <Tene> and which one works?

[10:34] <Debolaz> (1,2,3)>>.sqrt works

[10:34] <Debolaz> (Foo.new)>>.bar don't

[10:34] * Tene tests

[10:34] <Debolaz> ?eval class Foo { sub bar { say "Hello world!" } }; my @baz = (Foo.new,Foo.new); @baz>>.bar;

[10:34] <evalbot_r14917> Error: No compatible subroutine found: "&>>bar"

[10:35] <Debolaz> ?eval (1,2,3)>>.sqrt

[10:35] <evalbot_r14917> (1.0, 1.4142135623730951, 1.7320508075688772)

[10:35] <wolverian> ?eval my @foo = (1..3); @foo>>.sqrt

[10:35] <evalbot_r14917> (1.0, 1.4142135623730951, 1.7320508075688772)

[10:35] <Debolaz> wolverian: Already tried this. :)

[10:35] <jrockway> hehe, exactly the same two steps

[10:35] <wolverian> oh, yeah, you did.

[10:36] <jrockway> heh, i fixed some of the tests but can't commit because the repository UUID changed...

[10:36] <wolverian> looks like a weird parsing error :)

[10:36] <Debolaz> ?eval class Foo { sub bar { say "Hello world!" } }; (Foo.new)>>.bar;

[10:36] <jrockway> waiting ... :)

[10:36] <evalbot_r14917> Error: No compatible subroutine found: "&>>bar"

[10:36] <wolverian> oh

[10:36] <wolverian> dammit

[10:37] <wolverian> Debolaz, 'method bar

[10:37] <wolverian> '

[10:37] <wolverian> not sub

[10:37] <jrockway> ?eval class Foo { method bar { 42 } }; (Foo.new,Foo.new)>>.bar

[10:37] <evalbot_r14917> Error: No compatible subroutine found: "&>>bar"

[10:37] <jrockway> it worked for him when he did Foo.new.bar remember

[10:37] <jrockway> ?eval Foo.new

[10:38] <evalbot_r14917> Error: No compatible subroutine found: "&Foo"

[10:38] *** ofer1 joined
[10:38] <Tene> ?eval class Foo { method bar { 42 } }; Foo.new.bar;

[10:38] <evalbot_r14917> 42

[10:38] <Debolaz> wolverian: Oops.. yeah, that should've been method, but as jrockway says, it's not the problem.

[10:38] * jrockway goes to read S12

[10:39] <Tene> ?eval class Foo { method bar { say 42 } }; .bar for (Foo.new,Foo.new)

[10:39] <evalbot_r14917> OUTPUT[42␤42␤] undef

[10:45] <svnbot6> r14918 | jrockway++ |  r4@foo:  jon | 2006-12-18 04:42:53 -0600

[10:45] <svnbot6> r14918 | jrockway++ |  fix a minor typo

[10:47] <jrockway> hmm, should xx-uncategorized/hyperop.t exist still?

[10:47] <jrockway> (t/)

[10:52] <jrockway> ?eval ("f", "oo", "bar")>>.length

[10:52] <evalbot_r14918> Error: No compatible subroutine found: "&>>length"

[10:53] *** nekokak joined
[10:53] *** ruoso joined
[10:54] <jrockway> indeed, that's a failing TODO test

[10:55] <jrockway> i wonder why sqrt works and not length

[10:56] <jrockway> ?eval ("foo", "bar")>>.match("foo")

[10:56] <evalbot_r14918> Error: No compatible subroutine found: "&>>match"

[10:56] <jrockway> Debolaz: it looks like this stuff should work... the tests are TODO though

[11:09] *** xpika joined
[11:09] *** norageek joined
[11:12] <avar> what's the authorative kwid spec? google knows nothing of it

[11:21] *** kanru joined
[11:24] <svnbot6> r14919 | jrockway++ |  r6@foo:  jon | 2006-12-18 05:23:14 -0600

[11:24] <svnbot6> r14919 | jrockway++ |  Add some tests to see if hyper-method call works (suggested by

[11:24] <svnbot6> r14919 | jrockway++ |  Debolaz++) ( i.e (Foo.new)>>.bar )

[11:24] <svnbot6> r14919 | jrockway++ |  Add a test to see if hyper works on lists of integers (>>.sqrt)

[11:25] <jrockway> Debolaz: added some tests for what you were trying to do

[11:26] <jrockway> however since it's 5am and I have to go to work in 3 hours, I'll see if I can find the cause (etc.) later :)

[11:41] *** iblechbot joined
[11:58] <jrockway> should this work?:

[11:59] <jrockway> ?eval class Foo { method bar { 42 } }; $foo = Foo.new; $foo.can('bar');

[11:59] <evalbot_r14919> Error: No compatible subroutine found: "&can"

[11:59] <jrockway> ?eval class Foo { method bar { 42 } }; $foo = Foo.new; $foo.HOW.can('bar');

[11:59] <evalbot_r14919> Error: No compatible subroutine found: "&can"

[11:59] <jrockway> ?eval class Foo { method bar { 42 } }; $foo = Foo.new; $foo.^can('bar');

[11:59] <evalbot_r14919> Error: ␤Unexpected "^"␤expecting ".", "\187", ">>", "=", operator name, qualified identifier, variable name, "...", "--", "++", array subscript, hash subscript or code subscript

[11:59] <jrockway> maybe i'm misreading S12?

[12:06] <audreyt> no, that will work once MO is merged in

[12:07] <audreyt> which, really, is RSN :)

[12:07] <jrockway> cool :)

[12:07] <jrockway> what about the (Foo.new)>>.bar business from above?

[12:07] <audreyt> ?eval class Foo { method bar { 42 } } Foo.new.>>.bar

[12:07] <evalbot_r14919> Error: No compatible subroutine found: "&>>bar"

[12:08] <audreyt> ?eval class Foo { method bar { 42 } } [Foo.new, Foo.new].>>.bar

[12:08] <evalbot_r14919> Error: No compatible subroutine found: "&>>bar"

[12:08] <audreyt> hm, weird, I tought it worked

[12:08] <audreyt> ?eval (1..10).>>.sqrt

[12:08] <evalbot_r14919> (1.0, 1.4142135623730951, 1.7320508075688772, 2.0, 2.23606797749979, 2.449489742783178, 2.6457513110645907, 2.8284271247461903, 3.0, 3.1622776601683795)

[12:08] <jrockway> i added a test for that, but there was one similar

[12:08] <audreyt> k

[12:08] <audreyt> will look

[12:08] <jrockway> ?eval ("f", "foo", "bar")>>.length

[12:08] <evalbot_r14919> Error: No compatible subroutine found: "&>>length"

[12:08] <audreyt> .chars

[12:08] <audreyt> not length

[12:09] <jrockway> ok, so the test was wrong :)

[12:09] <jrockway> ?eval ("f", "foo", "bar")>>.chars

[12:09] <evalbot_r14919> (1, 3, 3)

[12:09] <jrockway> beautiful, i'll fix that

[12:09] <audreyt> hm, perl is 19 years old now

[12:10] <Debolaz> audreyt :)

[12:10] <Debolaz> The example (3,8,2,9,3,8) >>->> 1; from S03 doesn't seem to work either.

[12:11] <audreyt> currently the other dir of hyper is not implemented -- tests welcome

[12:11] <jrockway> ?eval 1 >>-<< (1,2,3)

[12:11] <evalbot_r14919> (0, -1, -2)

[12:11] <jrockway> ?eval (1,2,3) >>-<< 1

[12:11] <evalbot_r14919> (0, 1, 2)

[12:14] *** hcarty joined
[12:16] <svnbot6> r14920 | jrockway++ |  r8@foo:  jon | 2006-12-18 06:13:26 -0600

[12:16] <svnbot6> r14920 | jrockway++ |  s/.length/.chars/ in hyper test

[12:16] <jrockway> ?eval (1,2,3) >>- 1

[12:16] <jrockway> ?eval (1,2,3) >>->> 1

[12:16] <evalbot_r14919> Error: ␤Unexpected ">>-"␤expecting operator

[12:16] <evalbot_r14919> Error: ␤Unexpected ">>->>"␤expecting operator

[12:49] *** xinming_ joined
[13:08] *** penk joined
[13:20] *** melllwa_ joined
[13:32] *** melllwa__ joined
[13:35] *** penk joined
[13:38] *** melllwa joined
[13:41] *** gnuvince joined
[13:46] *** rafl joined
[13:49] *** melllwa_ joined
[13:52] *** melllwa__ joined
[14:05] *** melllwa joined
[14:09] *** penk joined
[14:11] *** robkinyon left
[14:12] *** melllwa_ joined
[14:12] *** penk joined
[14:13] *** penk joined
[14:22] *** melllwa__ joined
[14:43] *** ruoso joined
[14:46] *** bonesss joined
[14:59] <svnbot6> r14921 | szabgab++ | more keywords in perl6.vim

[14:59] *** kanru joined
[15:02] <svnbot6> r14922 | szabgab++ | more hash related tests

[15:02] <svnbot6> r14922 | szabgab++ | retab test files

[15:18] *** hcarty joined
[15:40] *** hcarty joined
[15:42] *** rindolf joined
[15:43] *** melllwa_ joined
[15:45] *** melllwa joined
[16:00] <rindolf> Hi all.

[16:00] <jrockway> hello

[16:01] *** Eidolos_ joined
[16:01] *** marmic joined
[16:02] *** jamessan_ joined
[16:03] *** hexmode joined
[16:04] *** stevan joined
[16:18] *** kanru joined
[16:23] *** stevan_ joined
[16:26] *** jamessan joined
[16:32] *** stevan_ joined
[16:33] *** azazello joined
[16:35] *** chris2 joined
[16:42] *** kanru_ joined
[17:12] *** weinig|away is now known as weinig

[17:38] *** _bernhard joined
[17:46] *** ashelyb_ joined
[17:49] *** justatheory joined
[18:08] * scrottie surveys someone else's domain

[18:14] *** hcarty joined
[18:22] *** BooK joined
[18:29] *** cmeyer joined
[18:43] *** DebolazY joined
[18:48] *** RHainsworth joined
[18:48] *** RHainsworth left
[19:08] *** wamiks joined
[19:10] <sili> huzzah

[19:16] *** buetow joined
[19:17] *** hcarty joined
[19:25] *** jdv79 joined
[19:26] *** Snafoo joined
[19:37] *** DebolazY is now known as DebolazX

[19:41] *** Caelum joined
[19:41] *** Aankhen`` joined
[19:42] *** ofer0 joined
[19:50] *** larsen_ joined
[19:55] *** fglock joined
[19:58] *** fglock left
[20:02] *** Daveman joined
[20:05] *** prism joined
[20:14] *** mj41 joined
[20:25] *** Alchemy joined
[20:35] *** weinig is now known as weinig_

[20:36] *** weinig_ is now known as weinig

[20:42] *** prism joined
[20:43] *** Dr_Pi joined
[20:45] *** prism joined
[20:45] <Dr_Pi> gaal: I'm still stuck in dial-up here in Italy. I'm hoping to get my 200Kps cell phone connection working by tomorrow afternoon.

[20:49] *** prism joined
[20:54] *** pbuetow joined
[21:05] *** Azure-BOT joined
[21:11] *** bonesss joined
[21:19] *** Ovid joined
[21:20] *** Ovid joined
[21:20] <Ovid> Hi all.

[21:22] <Ovid> Anyone know why http://rafb.net/paste/results/7EEn0898.html gives me scalar references?

[21:22] <buubot> The paste 7EEn0898 has been copied to http://erxz.com/pb/615

[21:22] *** Psyche^ joined
[21:22] <Ovid> I think that's a bug, but I don't want to commit a test if I'm wrong.

[21:28] *** weinig is now known as weinig|bbl

[21:28] <TimToady> I'd say it's probably a buglet.  happens that putting "item $elem" suppresses it.

[21:29] <TimToady> effectively you're getting a scalar container instead of the value, but since Perl 6 doesn't really have references, it should work the same most of the time as an rvalue.

[21:29] <Ovid> Ah, thanks.  I'll see if I can replicate that and commit a test.  Thanks.

[21:29] <TimToady> unfortunately it lies about being modifyable.

[21:29] <TimToady> basically you've ended up with a temp lvalue, I think.

[21:30] <TimToady> that's why I had an extra "item" in one of my examples somewhere.

[21:30] <TimToady> also, I think luqui's patch might have broken the current gather.

[21:31] <wolverian> must.. resist.. MMDing..

[21:31] <TimToady> gather is in a state of flux to becoming a "statement_prefix" like do

[21:31] <Ovid> Where do you put in the "item $elem"?  I can't figure it out.  On the other hand, I'm recompiling, so I'll check it again.  However, if what you posted was legal syntax, I'll commit that as a test unless it's not reasonable (since it sounds like the syntax might change)

[21:32] <TimToady> after the !!

[21:33] <Ovid> Oh, duh!  I was looking at some different gather/take code just now :)

[21:33] *** luqui joined
[21:33] <luqui> hey Ovid, got your message

[21:33] <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.

[21:33] <TimToady> you can prove that it's a temp lvalue and not a ref to $elem by adding in a "d".

[21:33] <TimToady> if it were \$elem then it would presumably have the same value.

[21:34] <TimToady> or maybe not, since it's a formal parameter to a closure

[21:34] <TimToady> so gets cloned.  nevermind

[21:34] <luqui> Ovid, I'm guessing that it's due to my recent change to gather syntax

[21:35] <luqui> Ovid, I'm investigating

[21:37] *** xpika joined
[21:37] <Ovid> The 'item' fixed it in my code.  Thanks.  And luqui's changes apparently broke http://perlmonks.org/?node_id=590147, too.  Bad luqui :)

[21:37] <lambdabot> Title: Re^2: 99 Problems in Perl6 (Lisp, Prolog, Haskell)

[21:38] <TimToady> that's what we were referring to.

[21:38] *** Psyche^ is now known as Patterner

[21:38] <TimToady> the item thing is not luqui's fault...

[21:39] <TimToady> or if it is, differently.  :)

[21:39] <luqui> it seems to be a closing brace dwimmery issue

[21:39] <luqui> I killed the inside of the inner gather

[21:39] <luqui> take [

[21:39] <luqui>     gather {;}

[21:39] <luqui> ]

[21:40] <luqui> breaks, but

[21:40] <luqui> take [ gather {;} ]

[21:40] <luqui> compiles

[21:40] <TimToady> weird

[21:40] <luqui> the implicit semicolon only should take effect when it is syntactically valid, right?

[21:40] <luqui> i.e., since we are inside a [] construct, it shouldn't be happening?

[21:41] <TimToady> hmm

[21:41] <TimToady> except the idea of "do" and "gather" is to introduce a statement level parse...

[21:42] <TimToady> so arguably it should auto-semi there, and then return out to ]

[21:42] * luqui doesn't follow

[21:43] <TimToady> we set up "do" to just expect a statement after

[21:43] <TimToady> but what happens if you say

[21:43] <TimToady> $x = [ do for @foo {

[21:43] <TimToady>       ...

[21:43] <TimToady>   }

[21:44] <TimToady> ]

[21:44] <TimToady> ;

[21:44] <luqui> ah, the statementness of the for will do the autonewliney thing...

[21:44] <luqui> should do override that?

[21:44] <TimToady> we're trying to put gather/contend/etc into the same syntactic category now.

[21:45] <luqui> (side note, what about try?)

[21:45] <TimToady> do sets up expectation of a statement following, which may or may not be a block.

[21:45] <TimToady> try too

[21:45] <TimToady> $x = do LABEL: goto LABEL;

[21:46] * luqui iack

[21:46] <luqui> er, ack

[21:46] <TimToady> seems to me if do mumble can be terminated by ; it can also be terminated by lonely }

[21:47] <luqui> hmm

[21:47] <luqui> so Ovid's code is in fact an error?

[21:47] <TimToady> which code?

[21:47] <TimToady> p6u?

[21:47] <luqui> er, yours I guess

[21:47] <luqui> http://perlmonks.org/?node_id=590147

[21:47] <lambdabot> Title: Re^2: 99 Problems in Perl6 (Lisp, Prolog, Haskell)

[21:47] <TimToady> It used to parse.

[21:48] <luqui> before gather was a statement introducer

[21:48] <TimToady> if a statement_prefix is followed by a block, that's the only argument

[21:48] *** devogon joined
[21:48] <TimToady> shouldn't matter whether you assume ; there.

[21:48] <Ovid> I know it's too late to do anything about it, but I find myself writing "is copy" more than I care to in signatures. Is there a shortcut?  (http://rafb.net/paste/results/ENLPqk79.html)

[21:48] <buubot> The paste ENLPqk79 has been copied to http://erxz.com/pb/616

[21:49] *** lumi_ is now known as lumi

[21:49] <luqui> if you assume a ; on the inner gather, then there's a ; inside an array, which is bad

[21:49] <luqui> s/array/array constructor/

[21:49] <TimToady> but we don't have to assume it there

[21:50] <luqui> the reason we don't is because it's inside an array constructor?

[21:50] <TimToady> because the gather already slurps the block and treats it as an arg

[21:50] <TimToady> just as $x = do {...} + 3 does

[21:51] <luqui> $x = do { 1 }

[21:51] <luqui> +3

[21:51] <luqui> say $x;   # 1

[21:51] <luqui> er, semicolon after the +3

[21:52] <luqui> is that not the issue we're talking about?

[21:52] <TimToady> that would imply ; after } because it's outer level.

[21:52] <luqui> okay, so it seems that my assessment is correct, even though you're not telling me so

[21:52] *** debugger| joined
[21:53] <luqui> the reason we don't assume a ; after the gather is because it's not outer-level

[21:53] <debugger|> hey pbuetow :D

[21:53] <pbuetow> Halluh!

[21:53] *** pbuetow is now known as buetow

[21:53] <debugger|> <---  bLader

[21:53] <luqui> aha!  it wasn't my fault, I just exposed a bug that was already there! :-)

[21:53] <luqui> my $x = [ do { 1 }

[21:53] <luqui> + 3 ];

[21:53] <luqui> # parse error

[21:53] <TimToady> cool

[21:54] <TimToady> Ovid: I think the "is copy" on slurpy arrays at least can eventually go away.

[21:54] <TimToady> it's just the elements that are readonly, not the array itself.

[21:54] <TimToady> much as @_ in Perl 5 works

[21:54] <Ovid> That would be very handy.  "99 Problems" are much more concise without "is copy" all over the place.

[21:55] <TimToady> interesting other question is whether $x = [ do stuff(); ] is legal.

[21:55] <Ovid> I'm only up to 22, though.  Christmas shopping for family members I've only just met.  Very stressful.

[21:58] <TimToady> because if that works, then this is possible:

[21:58] <TimToady> sub group2 (*@a is copy) {

[21:58] <TimToady>     gather while @a {

[21:58] <TimToady>         take [

[21:58] <TimToady>             gather loop (my $h = @a[0]; @a and $h eq @a[0]; take shift @a) {}

[21:58] <TimToady>         ]

[21:58] <TimToady>     }

[21:58] <TimToady> }

[21:59] <luqui> hmm...

[21:59] <svnbot6> r14923 | luqui++ | Added test for auto-semicolon not at top level bug.

[21:59] <luqui> that is spooky to me

[22:00] <TimToady> is $x = [ do stuff(); ] spooky to you?

[22:00] <luqui> yeah

[22:01] <TimToady> don't see how it's much different from $x = [ do {...} ]

[22:01] <TimToady> distinguishing from $x = [ do {...} + 1 ]

[22:01] <luqui> yeah... but...

[22:02] <TimToady> ] is a know escape from the current subparse

[22:02] <TimToady> *known

[22:02] <luqui> it looks wrong.  I suppose that is the big difference

[22:02] <TimToady> well, you could presumably leave out the semi and say $x = [ do stuff() ] and get the same effect

[22:03] *** Snafoo joined
[22:03] <TimToady> but parsewide stuff() is at the statement level.

[22:03] <TimToady> s/wide/wise

[22:03] <luqui> uh huh

[22:04] <luqui> does that imply:  my $x = do stuff();;

[22:04] <luqui> is correct, and only one semi would be wrong?

[22:04] <TimToady> don't think so

[22:05] <TimToady> one statement termination does for both.

[22:05] <TimToady> have to bracket to get it to work otherwise

[22:06] <TimToady> basically on that level do, gather, try etc are just modifiers on the following statement.

[22:06] <luqui> $x = do [ stuff(), 3 ]   # how is this parsed?

[22:06] <luqui> er

[22:07] <luqui> $x = [ do stuff(), 3 ]

[22:07] <TimToady> presumabably the same as $x = [ do { stuff(), 3 } ]

[22:07] <luqui> so do is really loose binding

[22:08] <TimToady> $x = try gather contend do stuff();  # still only one ;

[22:08] <luqui> and $x = do foo for 1..5;  is the same as $x = do { foo for 1..5 };

[22:08] <TimToady> yes

[22:08] <luqui> okay

[22:09] <Ovid> No matter how many times I run this function (http://rafb.net/paste/results/j1xXsN10.html), the final result is always ("a", "a", "a").  is this a bug or am I doing something stupid?  It's supposed to return $count number of random elements from a list.

[22:09] <luqui> hmm.. I guess I don't see how the ; is part of the statement

[22:09] <buubot> The paste j1xXsN10 has been copied to http://erxz.com/pb/617

[22:09] <TimToady> well, in a sense it isn't.

[22:09] <TimToady> it's just a terminator

[22:10] <luqui> right, it's at the statement list level, not the statement level

[22:10] <luqui> so I guess that is why I don't buy $ x = [ do stuff(); ]

[22:10] <luqui> unless that ; is a multidimensional array separator (uh... is it?)

[22:10] <luqui> (I don't actually remember how the multidimensional stuff turned out)

[22:11] <TimToady> Ovid: well, pick(3) is specced to do that but is unimplemented.

[22:12] <luqui> Ovid, maybe I don't grok your code... why @list[ @list [...

[22:13] <TimToady> yeah, that part doesn't make sense to me either.

[22:13] <luqui> it seems @list :: int -> Str, so you can't index it with its own return

[22:13] <Ovid> Ah, sheesh. Thanks luqui.  That will teach me not to do 99 Problems while drinking Rum-n-Coke :)

[22:13] <Ovid> Sorry for the stupidity.

[22:13] <TimToady> try Sprite instead.

[22:13] <TimToady> and maybe Vodka...

[22:14] <jrockway> Ovid: go for the espresso + coke + coffee icecubes someone posted on their use perl; journal :)

[22:14] *** py1hon joined
[22:14] <TimToady> well, even if ; were a multidimensional array separator, there's nothing after it to separate.

[22:14] <Ovid> Well, I'm out of Laphroaigh, so this is all I got (and Laphroaig is cheaper on this side of the pond)

[22:15] <luqui> okay, so I don't buy [ do stuff(); ]

[22:16] <TimToady> I think using ; as statement terminator eats it up for other purposes, so it would never be interpreted as a dim sep

[22:16] <luqui> it's a _separator_, not a terminator

[22:16] <TimToady> no, it's an optional terminator.

[22:17] <luqui> hm.  is this essentially correct:

[22:17] <TimToady> it's optional where } and eof make it obviously missing.

[22:17] <TimToady> not difficult to add ] to that list when there [...] outside.

[22:17] <luqui> stmtlist ::= stmt ; stmtlist | stmt

[22:17] <luqui> stmt ::= (empty) | ...

[22:18] <luqui> barring the dwimmery

[22:19] <TimToady> gotta go to $job, unfortunately...

[22:20] <luqui> kay

[22:20] <luqui> it'll make me stop arguing and start fixing this bug

[22:20] <luqui> :-)

[22:20] <TimToady> ^_^

[22:20] <TimToady> ja ne. &

[22:20] <Ovid> See you. Thanks for your help.

[22:21] <jrockway> btw, while there's life in the channel :) is this correct:

[22:21] <jrockway> ?eval (1,2,3) >>+<< 1

[22:21] <evalbot_r14923> (2, 3, 4)

[22:21] <luqui> yeah

[22:21] <TimToady> not according to current spec

[22:21] <luqui> oh

[22:21] <jrockway> right, that's what I thought

[22:21] <luqui> you changed it again!

[22:21] <TimToady> but current spec is not implemented

[22:21] <jrockway> it shoudl be >>+>> 1

[22:21] <luqui> ack!

[22:21] <Ovid> :)

[22:21] <jrockway> the pointy things point to what you want to be dwim'd

[22:21] <xpika> ?eval (1,2,3) >>*<< 2

[22:22] <evalbot_r14923> (2, 4, 6)

[22:22] <TimToady> >>+<< does no dwimmery

[22:22] <xpika> ?eval (1..100) >>*<< 2

[22:22] <evalbot_r14923> (2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200)

[22:22] <luqui> by no dwimmery, you mean that it doesn't autoexpand?

[22:22] <jrockway> xpika: yes, it works for lists that are more than 3 elements long :)

[22:22] <TimToady> correct.

[22:22] <TimToady> later &

[22:22] <jrockway> so should i fix the tests for this then?

[22:23] <luqui> with :todo<feature> ?

[22:23] *** Aankhen`` joined
[22:23] <jrockway> there are tests for >>+<< DWIM-ing

[22:24] <jrockway> those should fail

[22:24] <jrockway> and >>+>> should pass

[22:24] <jrockway> as should <<+>>, i guess

[22:24] *** buetow left
[22:27] <jrockway> i'll wait until tomorrow, because it's difficult to work with unicode on the machine i'm at right now (cygwin, ugh...)

[22:31] <jrockway> ?eval 1 <<+>> 1

[22:31] <evalbot_r14923> Error: ␤Unexpected "<<+>>"␤expecting operator

[22:32] <Ovid> There's no .shuffle method for arrays specced, is there?

[22:33] <luqui> No.  Though I don't see why there shouldn't be.

[22:33] <obra> That'd make a nice cpan6 sample module demonstrating how to extend a base type

[22:33] <luqui> touche

[22:34] <obra> So, luqui, what's brought you back to six-land?

[22:34] <luqui> school ending

[22:35] <Ovid> I was wondering that myself :)

[22:35] <luqui> this is finals weeks

[22:35] <luqui> s/s$//

[22:35] <luqui> and I'm taking the spring off

[22:36] <jrockway> to work on perl6 exclusively? :)

[22:36] <svnbot6> r14924 | luqui++ | Auto-semicolon was too liberal with statementizers (like "do" and "gather"). 

[22:36] <svnbot6> r14924 | luqui++ | Fixed that, hopefully without breaking the statementizers (the tests in

[22:36] <svnbot6> r14924 | luqui++ | t/syntax passed, at least).

[22:36] <luqui> uh no

[22:37] <luqui> I'd love to, but need $$

[22:37] <Ovid> So, er, I'm looking at http://perlcabal.org/syn/ and I don't see the syntax for extending base types.  What do I look at?  (and is it implemented?)

[22:37] <lambdabot> Title: Official Perl 6 Documentation

[22:37] <luqui> Ovid, it's just like extending non-base types

[22:37] <luqui> "is also" I believe

[22:37] <jrockway> S12, btw

[22:37] <obra> luqui: nice. congrats on getting some free time :)

[22:38] <obra> and welcome back

[22:38] <luqui> thanks.  Don't get your hopes up; last time I was back it wasn't for very long

[22:38] <luqui> it's not clear that this time will be different

[22:38] <luqui> but I hope it will be

[22:39] <Ovid> luqui:  I know that you've had ups and downs here, but I really hope you stick with it.

[22:39] <Ovid> So where would I find the syntax for extending non-base types?

[22:39] <luqui> it's not really "here" that is the problem

[22:39] <luqui> it's elsewhere

[22:39] <luqui> I like this community :-)

[22:39] <luqui> Ovid, S12 somewhere

[22:39] <Ovid> And most of us like you too :)

[22:40] <Ovid> Ah, I see it.

[22:40] <luqui> S12 line 1515, section "Open vs Closed classes"

[22:41] <wolverian> wasn't .pick supposed to work as a shuffle if you do @foo.pick(@foo.elems) or so?

[22:42] <jrockway> ?eval class Str is also { method length { self.chars } }; "foo".length

[22:42] <evalbot_r14923> 3

[22:42] <luqui> wolverian, yeah, that would do it

[22:42] <jrockway> awesome :)

[22:42] <wolverian> ?eval ("a".."c").pick(3)

[22:42] <evalbot_r14924> Error: No compatible subroutine found: "&pick"

[22:43] <luqui> wolverian, working on that now

[22:43] <jrockway> ?eval my @foo; for all(1..10){ push @foo, $_ }; @foo

[22:43] <evalbot_r14924> Error: ␤Unexpected ";"␤expecting term postfix, operator or block construct

[22:43] <jrockway> something like that could technically shuffle the list

[22:43] <jrockway> ?eval my @foo; for all(1..10){ push @foo, $_ } @foo

[22:43] <evalbot_r14924> Error: ␤Unexpected "@foo"␤expecting operator or block construct

[22:46] <jrockway> ENOSLEEP :)

[22:47] <jrockway> oh, also... should this work:

[22:47] <jrockway> my @data = (1,2,3); my @out; @data ==> map { 42 } ==> @out; @out;

[22:47] <jrockway> ?eval my @data = (1,2,3); my @out; @data ==> map { 42 } ==> @out; @out;

[22:47] <evalbot_r14924> Error: ␤Unexpected " map"

[22:50] <TimToady> pick is specced in docs/Perl6/Spec/Functions.pod

[22:51] <Ovid> Is "is also" not yet implemented?

[22:51] <TimToady> feeds aren't really implemented yet.

[22:51] <wolverian> luqui++

[22:51] <TimToady> Ovid: dunno.

[22:53] <TimToady> syntactically, though @data ==> is very much like do in taking a bare Code on the right.

[22:54] <Ovid> Looks like it's recognized, but broken. This prints "[]" twice:  http://rafb.net/paste/results/0h3itz58.html (syntax from http://perlcabal.org/syn/S12.html)

[22:54] <buubot> The paste 0h3itz58 has been copied to http://erxz.com/pb/618

[22:55] <jrockway> Ovid: is also appeared to work above, right?

[22:56] <Ovid> jrockway?  Where?

[22:56] <jrockway> ?eval class Str is also { method length { self.chars } }; "foo".length

[22:56] <evalbot_r14924> 3

[22:56] <jrockway> ?eval "foo".length

[22:56] <evalbot_r14924> Error: No compatible subroutine found: "&length"

[22:56] <TimToady> ?eval class Foo { say "hi" }; class Foo { say "lo" }

[22:56] <evalbot_r14924> OUTPUT[hi␤lo␤] Bool::True

[22:58] <jrockway> Ovid: are you thinking of something else?

[22:59] <TimToady> ?eval class Str { method length { self.chars } }; "foo".length

[22:59] <evalbot_r14924> 3

[22:59] <TimToady> I'd say "is also" is currently the default.

[22:59] <jrockway> the spec says that should warn or error though

[22:59] <jrockway> class redefinition

[23:00] <jrockway> and redefinition implies replace

[23:00] <Ovid> Not sure if evalbot recognizes that spread over multiple lines.  (Oh, it looks like it might).  All I know is that I tried to implement .shuffle for the Array class and it failed miserably.  I don't know if it's me or Pugs.

[23:00] <jrockway> ?eval my @array = (1,2,3); @array.WHAT

[23:00] <evalbot_r14924> ::Array

[23:01] <luqui> I can't say I like .WHAT, .WHO, etc. very much.  They are not very descriptive

[23:01] <jrockway> ?eval class Array is also { method shuffle { (1,2,3) } }; (3,1,2).shuffle 

[23:01] <evalbot_r14924> (1, 2, 3)

[23:01] <luqui> (.WHERE isn't too bad)

[23:01] <jrockway> :)

[23:01] <jrockway> time to head home &

[23:07] *** seano joined
[23:09] <svnbot6> r14925 | luqui++ | Implemented @list.pick(num).

[23:14] <luqui> ?eval [1,2,3].pick(2)

[23:14] <evalbot_r14924> Error: No compatible subroutine found: "&pick"

[23:15] <svnbot6> r14926 | luqui++ | Made pick faster.

[23:18] <luqui> next step: implement >>.pick for infinite lists, using the axiom of choice

[23:18] <luqui> sayonara

[23:18] <Ovid> I have no idea, but when I run "make realclean" with Pugs and it hits the line "mv Makefile Makefile.old > /dev/null 2>&1", I have to hit "return/enter" to make it continue (mac os x).  Anyone know why?

[23:28] *** polettix joined
[23:30] *** gnuvince joined
[23:39] *** luqui joined
[23:45] <TimToady> Ovid: is your mv aliased to mv -i?

[23:45] <jrockway> do shell aliases apply to makefiles?

[23:46] *** Psyche^ joined
[23:46] <TimToady> who knows on a mac...

[23:46] <Ovid> TimTodoady: no.

[23:46] <TimToady> acts like it...

[23:46] <TimToady> does it hang if you rm Makefile.old first?

[23:46] <py1hon> could change it to mv -f in the makefile

[23:47] <jrockway> that sounds right

[23:47] <Ovid> I'll have to wait for a bit.  Rebuilding pugs again.

[23:47] <jrockway> otherwise it will prompt

[23:47] <jrockway> actually, i'm looking at the GNU mv manpage

[23:47] <jrockway> openbsd's mv is the same though... that could be the issue

[23:47] <jrockway> maybe redirect dev null to stdin also?

[23:48] <TimToady> course, if it takes it as "false"...

[23:48] <jrockway> acutally, "mv -f Makefile Makefile.old" seems cleanest

[23:48] <jrockway> yeah

[23:48] <py1hon> that wouldn't help, it'd hang and hitting enter wouldn't do anything

[23:48] *** Snafoo joined
[23:48] <jrockway> not having makefile.old doesn't sound like the worst thing in the world

[23:48] <jrockway> py1hon: no, getchar will fail

[23:48] <jrockway> EOF

[23:48] <py1hon> oh, der

[23:48] <jrockway> /dev/null is a stream of EOFs :)

[23:48] <py1hon> yeah, i knew that ;p

[23:49] <jrockway> it would be the same as hitting C-d

[23:49] *** Snafoo left
[23:50] <py1hon> so, is there anything usefull a c coder could do?

[23:51] <jrockway> parrot

[23:52] <py1hon> how is that these days? last i looked (awhile ago) it was still in the "rapid work by mostly one person" phase

[23:53] <TimToady> they've actually managed to diversify that somewhat now

[23:53] <jrockway> no, there are lots of people involved now

[23:53] <jnthn> py1hon: If the "mostly one person" you refer to is who I think you are, that person isn't so involved now.

[23:53] <jnthn> Due to $WORK_STUFF

[23:53] <jrockway> plenty of stuff for people new to the project to do :)

[23:53] <jnthn> Come join the fun! irc.perl.org, #parrot :-)

[23:53] <jrockway> how come #parrot is on MagNET and perl6 is on Freenode?

[23:54] <TimToady> why not?

[23:54] <jnthn> :-)

[23:54] <py1hon> jnthn, possibly, i'm having trouble remembering names

