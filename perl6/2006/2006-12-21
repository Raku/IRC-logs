[00:05] *** awwaiid joined
[00:09] *** polettix joined
[00:10] *** awwaiid__ joined
[00:22] *** awwaiid_1 joined
[00:58] *** lyokato joined
[01:00] *** mako132_ joined
[01:20] <Debolaz> What's the status of multithreading with pugs?

[01:21] <audreyt> async works, which creates a thread object

[01:21] <audreyt> and you can manipulate it a bit

[01:21] <audreyt> grep -r async examples

[01:22] <Debolaz> What other choices than async for managing threads? 

[01:22] <audreyt> you mean, for creation?

[01:22] <audreyt> not sure the context of the question

[01:22] * Debolaz realizes that was somewhat vague.

[01:23] *** mako132_ joined
[01:27] *** Auzon joined
[01:27] <Debolaz> Where is async documented?

[01:29] <audreyt> not anywhere, really. docs/Perl6/Spec/Concurrency.pod mentions it but it's not doc

[01:29] <audreyt> it follows perl5 api

[01:29] *** felipe joined
[01:29] * TreyHarris waves at audreyt

[01:29] <TreyHarris> audreyt: long time no speak :)

[01:29] <audreyt> TreyHarris: heya!

[01:29] <audreyt> indeed

[01:30] <audreyt> been busy with realspace. it's turning rather beautiful lately though :)

[01:30] <TreyHarris> well, me too... amazon holiday rush, i go incommunicado for at least three weeks every year

[01:30] <audreyt> I can imagine that

[01:33] <TreyHarris> audreyt, allbery_b and i were talking on another channel about ovid's question on junctions.  maybe the autothreading property needs to be drawn out in greater detail--if Ovid could miss it, knowing how accomplished a hacker he is, i fear that others will too

[01:34] <TreyHarris> (drawn out in S09 i mean)

[01:34] <allbery_b> I pointed out that when I look at what ovid is doing, my naive initial response is the same as his --- I have to think it through before realizing that autotheading is the *correct* thing to do

[01:35] <audreyt> aye.

[01:36] *** luqui joined
[01:36] <Debolaz> That's actually something else I've been wondering about, where is there a magical junction thing, why not have functions generating threads based on lists (Ie, the any(x,x) way of using junctions)?

[01:36] <jrockway> example?

[01:36] <Debolaz> I should really look stuff up in documentation so I can reference it before I ask.

[01:36] <Debolaz> :/

[01:37] *** bonesss joined
[01:37] <jrockway> not a documentation issue so much as, "show us what you want to do"...

[01:37] <jrockway> i'm not quite sure what you're asking :)

[01:38] <Debolaz> It's not so much what I want to do, but why I'm able to do it.. why can I do my $foo = 1 & 2?

[01:38] <TreyHarris> Debolaz: the way i formulate it in my brain is, Junctions are a sibling, not a descendant, of Any.  So unless you specifically use Junction as a parameter type, you're asking for an argument under Any, not Junction.  So Perl does a coercion--which in the case of Junctions, causes autothreading to happen

[01:39] <TreyHarris> ?eval my $foo = 1&2; $foo += 3|4; $foo.perl.say

[01:39] <evalbot_r14932> OUTPUT[\((4 | 5) & (5 | 6))␤] Bool::True

[01:39] <Debolaz> It seems like adding uneccesary complexity when you can do the same with any & co..

[01:39] <TreyHarris> for things like that

[01:39] <jrockway> ?eval my $foo = all(1,2); $foo += any(3,4); $foo.perl.say

[01:39] <evalbot_r14932> OUTPUT[\((4 | 5) & (5 | 6))␤] Bool::True

[01:39] <jrockway> it's the same thing

[01:39] <luqui> Debolaz, heh... I argued that case for many months

[01:40] <jrockway> & and | are nicer to look at though

[01:40] <luqui> Debolaz, junctions did not want to move

[01:40] <jrockway> junctions are quite useful in real life

[01:40] <Debolaz> jrockway: I know it's the same thing, if it were different things I wouldn't have this problem. :)

[01:40] <luqui> Debolaz, oh, are you arguing agains the & / | syntax?

[01:40] <jrockway> you are upset that there are two ways to say the same thing?

[01:40] <Debolaz> luqui: Yes. any() I'm fine with.

[01:41] <TreyHarris> Debolaz: well, do you have the same qualm with (err|//), (or/||), (and/&&)?

[01:41] <luqui> oh, nevermind then.  that is not the same as my case

[01:41] <jrockway> "foo" vs qq/foo/ vs qq{foo}

[01:41] <Debolaz> TreyHarris: That's not quite the same.

[01:41] <TreyHarris> Debolaz: ok, so what is the difference?  that's what i'm trying to tease out

[01:41] <Debolaz> and and && are used the same way, any() and | aren't used the (exact) same way.

[01:41] <luqui> Debolaz, neither is all/&;  one is a listop, the other is an infix operator

[01:42] <jrockway> why not?

[01:42] <jrockway> say $_ for (1&2&3);

[01:42] <jrockway> ?eval say $_ for (1&2&3);

[01:42] <evalbot_r14932> OUTPUT[all(VInt 1,VInt 2,VInt 3)␤] undef

[01:42] <jrockway> erm

[01:42] <luqui> the only difference between && and "and", is that one has tight precedence, the other loose

[01:43] <Debolaz> my $a = 1 | 2; does magical stuff. my $a = any(1,2) does not. It's just a function returning an object, it makes perfect sense. | and & adds complexity.. when I look at $a, I think scalar, not junction. At least if junctions had their own @$% type prefix, it'd be somewhat ok..

[01:43] <Debolaz> (Yes, I realize objects are already also on the $ bandwagon)

[01:43] <TreyHarris> "magical stuff"?  what magical stuff

[01:44] <luqui> Debolaz, so the fact that 1|2 returns an object is weird to you?

[01:44] <TreyHarris> with autoboxing, just plain 1 returns an object too.

[01:44] <jrockway> should we replace 2 + 3 with add(2,3) ?

[01:44] <jrockway> it sounds like that's what you want

[01:44] <jrockway> and when you do that, everything sort of makes sense, but you end up with PHP

[01:44] <Debolaz> luqui: The fact that it's very easy to think scalar when it really isn't scalar. I don't think I would ever recommend anybody ever using & and | when assigning something to a variable, it's just too prone to cause difficult to spot bugs.

[01:45] <jrockway> they tried the "everything is a function" approach, and failed miserably

[01:45] <jrockway> oh, i see

[01:45] <TreyHarris> but (1|2) *is* a scalar....

[01:45] <luqui> Debolaz, but using any() is o.k.?

[01:45] <jrockway> what i don't see how any(...) solves the problem

[01:45] <jrockway> right

[01:45] <TreyHarris> it's a junction composed of scalars, so it's a scalar

[01:45] <Debolaz> luqui: As long as you don't assign the result to anything, yes. 

[01:45] <jrockway> are you expecting bitwise and to occur when you do 1&2

[01:45] <luqui> (my case was that assigning junctions at all to scalars causes difficulties, no matter how you construct them)

[01:46] <luqui> Debolaz, oh.

[01:46] <jrockway> ?eval class Foo { method bar { 42 } }; my $f = Foo.new; $f.bar;

[01:46] <evalbot_r14932> 42

[01:46] <TreyHarris> luqui: can you construct a quick example of a difficulty it causes?

[01:46] <jrockway> junctions are just like Foo, except more useful

[01:46] <luqui> if $x < 0 { say "a" }   if $x >= 0 { say "b " }

[01:47] <luqui> if $x is a junction, then that is not equivalent to using if {...} else {...}

[01:47] <jrockway> ?eval $x = 1|2; if $x > 1 { say "a" }

[01:47] <evalbot_r14932> OUTPUT[a␤] Bool::True

[01:47] <jrockway> that's fine right?

[01:47] <Debolaz> for any(1,2,3) -> { } would be ok. my $a = 1&2&3; for $a -> { } would be confusing. Same functionality, but the former is much easier to understand.

[01:47] <jrockway> x is greater than 1

[01:48] <Debolaz> So just let me emphasize again, I'm not fundamentally against the concept of junctions, just the way they are wedged in.

[01:48] <luqui> jrockway, in your example, both $x >= 2 and $x < 2 hold

[01:48] <Debolaz> Even though I think junctions are less than elegant.

[01:48] <Debolaz> I can probably grow to like them. :)

[01:48] <jrockway> luqui: yeah

[01:49] <luqui> I think junctions are beautiful, but when they "do their thing" it should be marked

[01:49] <Caelum> oh neat, there's a Perl6::Junction on CPAN

[01:49] <jrockway> i think they tend to just work

[01:49] <luqui> otherwise they have a tendency to break the laws associated with data types

[01:49] <jrockway> Quantum::Superpositions

[01:49] <jrockway> i use it in my HTML parser

[01:49] <luqui> jrockway, I'm not saying junctions are bad

[01:49] <luqui> I'm saying they don't scale

[01:49] <jrockway> luqui: i think in the examples we're using, they look ugly

[01:49] <luqui> they are only there for small syntactic conveniences

[01:50] <jrockway> in places where people would use them, they work great and are transparent

[01:50] <jrockway> i.e.:

[01:50] <Debolaz> luqui: They have a tendency to cause surprise among new programmers. That's supposedly why the author of ruby invented that language, because he was tired of languages (Refering to C++) that kept surprising him even after he had learnt them. 

[01:50] <luqui> and using their (powerful) semantics is too tricky

[01:50] <TimToady> junctions are a linguistic convenience, not a real mathematical thing.

[01:50] <TreyHarris> luqui: your example just falls out from the properties of junctions.  like quaternions or surreal numbers or any number of other constructs, they violate some of the properties of the real number (or real truth) space

[01:50] <jrockway> if $tag eq any(qw<br a li ul>) { ... }

[01:50] <jrockway> if that's a variable, it makes sense

[01:50] <luqui> TimToady, you agree with me

[01:50] <jrockway> it could be just br, or it could be just li, or it could be either

[01:50] <jrockway> that's fine, the code in the block is happy either way

[01:51] <jrockway> yes, you get things that are both equal and not equal

[01:51] <luqui> which is why I don't think they should autothread if they're inside a variable

[01:51] <jrockway> but if you're not testing for both, there's no confusion

[01:51] <TimToady> sure, I just don't agree with people who want to turn them from linguistic conveniences into mathematical thingies.

[01:51] * TreyHarris agrees with TimToady 

[01:51] <allbery_b> seems to me that they scale fine.  it might be worth having warnings (which can be disabled by experts) when a junction is used in some situations and isn't explicit

[01:52] <allbery_b> such as your variable case.

[01:52] <TimToady> the only reason they got in in the first place is because I realized English has 'em.  :)

[01:52] <luqui> TimToady, my case was to pick one.  either make them a mathematical thing, or make sure that the language knows they are linguistic

[01:52] <TimToady> I think the restriction on parameters accomplishes most of that.

[01:52] <allbery_b> (this doesn't help Ovid's confusion though since his was explicit)

[01:52] <TimToady> if we want to restrict variables as well, well a pragma could do that.

[01:52] <TimToady> just not clear it's worth a default.

[01:53] <TimToady> since the variable is usually in the same "visual scope" as the junction.

[01:53] *** ssig33 joined
[01:53] <TimToady> people who return junctions should maybe be taken out and shot though.

[01:53] <luqui> you don't say: John is happy or sad.  Is john happy? (yes)   John is happy and sad?  Is john happy? (no)

[01:54] <luqui> junctions don't abstract across discourse.  They are only useful *within* a sentence

[01:54] <jrockway> the html example is a counterexample

[01:54] <jrockway> "if we have one of these, then"

[01:54] <jrockway> works fine

[01:55] <Caelum> you can be happy and sad, and you can be unsure if john is happy or sad or both

[01:55] <luqui> jrockway, but your junction is in the part of the sentence "one of", not "these"

[01:55] <TimToady> I think of junctions much like placeholders--if it hurts, don't do that...

[01:55] <jrockway> why pick opposites

[01:55] <jrockway> how about "clothes john is wearing"

[01:55] <jrockway> he can have a shirt, pants, both, neither, socks, ...

[01:55] <jrockway> so if you want to ask "does john have some article of clothing" or "is john clothes-less", junctions allow that nicely

[01:56] <luqui> TimToady, my fear is that they will start to be used in API interfaces

[01:56] <luqui> (I have seen it already)

[01:56] <jrockway> without your if statement needing to know the details of how people wear clothes

[01:56] <luqui> and they don't belong there

[01:56] <jrockway> people abuse perl5 too

[01:56] <TimToady> I've just made Ranges kinda autohyper themselves

[01:56] <luqui> jrockway, again, you are using the junction in that sentence when you say "some article of clothing"

[01:56] <jrockway> in the end, it's their problem

[01:56] <luqui> jrockway, as "any(@clothes)"

[01:56] <luqui> which I am fine with

[01:57] <jrockway> true, true

[01:57] <TreyHarris> TimToady: "people who return junctions should maybe be taken out and shot though": what, sqrt(4) shouldn't return 2|-2? :)

[01:57] <luqui> TreyHarris, TimToady, precisely!

[01:57] *** kanru joined
[01:57] <jrockway> TreyHarris++

[01:57] <jrockway> much better example :)

[01:57] <luqui> sqrt(4) should definitely not return 2|-2

[01:57] <jrockway> what should it return? -2 ?

[01:57] <TimToady> yeah, it's 2^-2

[01:58] <TimToady> :)

[01:58] * luqui sighs

[01:58] <TimToady> sqrts(4)

[01:59] <luqui> sqrts(4) == set(2,-2)

[01:59] <luqui> not a junction, again :-)

[01:59] * TreyHarris groans

[01:59] <jrockway> how does a "set" work

[01:59] <jrockway> is the sqrt(4) less than 0?

[01:59] <jrockway> is it greater than 0?

[01:59] <Tene> Is perl6 sqrt going to return x^-x ?

[01:59] <TimToady> sets aren't imperialistic about the logical relationship

[01:59] <TimToady> Tene: no

[01:59] <Tene> kk

[01:59] <TreyHarris> luqui: is that even mathematically correct?  the mathematical square root of 4 is plus-or-minus 2.  that seems junctional to me; it's a single value that has two states, not two values

[02:00] <luqui> jrockway, sqrt(4) is greater than 0, not less than

[02:00] <jrockway> -2 * -2 = 4

[02:00] <luqui> TreyHarris, the mathematical square root of 4 is 2

[02:00] <jrockway> what?

[02:00] <luqui> because we define square root to mean principal square root

[02:00] <luqui> (i.e. the positive one)

[02:00] <luqui> so that it is a functoin

[02:00] <luqui> the solutions to the equation x^2 = 4 are sqrt(4) and -sqrt(4)

[02:00] * TreyHarris cocks his head

[02:00] *** jdv79 left
[02:01] <jrockway> that is true

[02:01] <jrockway> you can use the negative half too, if you want

[02:01] <TreyHarris> It all depends on your definitions, I guess.  But if I write a radical symbol over 4, it reduces to +/- 2, not 2

[02:01] <TimToady> luqui's other point is also that a set is just the two numbers, without the enforcement of & or | or ^

[02:01] <luqui> TreyHarris, not in my maths educatoin

[02:01] <TreyHarris> perhaps "sqrt" is not the same as 2-with-radical

[02:02] <TimToady> you don't know what logic you want to apply to the numbers out of context.

[02:02] <luqui> mathematicians don't use things as functions when they aren't

[02:02] <TimToady> maybe you want all(@root) not any(@roots)

[02:02] <jrockway> well here's the thing

[02:02] <jrockway> let's say you want to write a perl6 root solver

[02:02] <jrockway> the junction syntax will be great for that

[02:02] <jrockway> no more handling the negative case and the postive case separately

[02:02] <jrockway> it Just Works

[02:02] <luqui> jrockway, are you kidding?

[02:02] <TreyHarris> luqui: maybe this is a point of discrepancy depending on where you took maths.  i was a math minor, and that's how *i* learned it :)

[02:03] <jrockway> yes. i lost many many points on exams until i made sure that sqrt(4) == 2|-2 :)

[02:03] *** bonesss joined
[02:03] <luqui> jrockway, are you sure you are not referring to solutions of equations?

[02:03] <TimToady> that's a highly context-sensitive |

[02:04] <luqui> hmm...

[02:04] <jrockway> TimToady: you have a good point

[02:04] <jrockway> I think TreyHarris and I like the idea of | in our context

[02:04] <jrockway> and can think of places where the current implementation makes sense

[02:04] <TimToady> yes, but...

[02:04] <luqui> jrockway, ooh

[02:04] <luqui> here's a good one

[02:04] <TimToady> you have to realize that you're using the listiness of junctions there

[02:04] <jrockway> it you guys think it will do more harm than good, i suppose that's ok

[02:04] <TimToady> to emulate sets

[02:05] <luqui> sqrt(4)*sqrt(4) == -16 ?

[02:05] <jrockway> hmm, let me try something

[02:05] <TimToady> a set doesn't care about & or |

[02:05] <jrockway> ?eval (2,-2)*4

[02:05] <evalbot_r14932> 8.0

[02:05] <jrockway> ?eval any(2,-2)*4

[02:05] <evalbot_r14932> (-8 | 8)

[02:05] <TimToady> the pragmatic question of whether 1|2|3 is a valid way to write a set depends on whether we allow junctions to coerce to sets.

[02:06] <TimToady> and that can be argued either way.

[02:06] <Debolaz> jrockway: That would make more sense using hyperoperators though.

[02:06] <jrockway> before we explore that direction; luqui could you explain what you would like to change?

[02:06] <jrockway> ?eval (2,-2)>>*<< 4

[02:06] <evalbot_r14932> (8, -8)

[02:06] <jrockway> ok

[02:07] <luqui> jrockway, I would like it either to be illegal to store a junction in a variable, or make the use of junctions in variables as junctions explicit

[02:07] <luqui> allow me to elaborate a little

[02:07] <luqui> my $x = 1 | 2;  $x == 2;  # error, can't compare junction to number

[02:07] <luqui> 1 | 2 == 2;  # fine, true

[02:07] <luqui> my $x = 1 | 2;   J$x == 2;  # true   (for some value of J)

[02:08] <jrockway> i definitely see your point

[02:08] <jrockway> things have the potential to go very wrong...

[02:08] <jrockway> ?eval 1.0 == 1

[02:08] <evalbot_r14932> Bool::True

[02:09] <luqui> jrockway, the biggest reason for that, is that i want to be able to pass junctions into any function

[02:09] <luqui> functions which handle objects generically, without worrying about what type it is

[02:09] <luqui> but we can't allow junctions to come into functions expecting numbers as numbers...

[02:10] <jrockway> why can't objects think they're equal to both 1 and 2, though

[02:10] <allbery_b> any($x) / all($x) seems the obvious syntax for that

[02:10] <jrockway> is that physically impossible?

[02:10] <jrockway> (ok, yes, i guess it is...)

[02:10] <luqui> jrockway, no, of course you can overload == to do that

[02:10] <jrockway> but that's all a junction is

[02:10] <luqui> but that would not be considered good practice :-)

[02:10] <jrockway> ok

[02:10] <Debolaz> jrockway: Someone should probably write a doc about why junctions are neccesary (In the sense that they do something you cannot do with hyperoperators and/or list magic)

[02:10] <TreyHarris> to put the definition-of-root question aside, since that's not directly relevant, what if you wanted to write a sub that returned the result of the quadratic formula.  it contains a +/-.  is the result a set?  or a junction?

[02:10] <jrockway> Debolaz: the if case

[02:11] <jrockway> Debolaz: i use Q::Superpositions in perl5 code and it saves me typing

[02:11] <jrockway> keyboard typing that is :)

[02:11] <TimToady> they're mostly there for "when"

[02:11] * jrockway wonders...

[02:11] <jrockway> ?eval (1,2)>>==<<(2,3)

[02:11] <evalbot_r14932> (Bool::False, Bool::False)

[02:11] <jrockway> that is somewhat interesting

[02:11] <allbery_b> TreyHarris: I could argue return principal root if scalar context, else list...

[02:12] <Debolaz> jrockway: Sure, I like the ifs. But junctions seems to add a lot of complexity for something that could probably had been implemented simpler..

[02:12] <luqui> allbery_b, that can get deadly though:   my @x = (sqrt(1), sqrt(2), sqrt(3))

[02:12] <luqui> @x has six elements?

[02:12] <lambdabot> Maybe you meant: . v

[02:12] <jrockway> ?eval if (1,2)>>==<<2 { say "yup" }

[02:12] <evalbot_r14932> OUTPUT[yup␤] Bool::True

[02:12] <jrockway> so hyper handles the any case

[02:12] <luqui> jrockway, not so

[02:12] <jrockway> what about the all case

[02:12] <allbery_b> point.  set would probably be better but there is no "set context" in perl

[02:12] <luqui> ?eval if (5,6) >>=<< 2 { say "yup" }

[02:12] <evalbot_r14932> Error: ␤Unexpected ">>=<<"␤expecting operator or bare or pointy block construct

[02:13] <luqui> huh?

[02:13] <jrockway> ==

[02:13] <luqui> ?eval if (5,6) >>==<< 2 { say "yup" }

[02:13] <evalbot_r14932> OUTPUT[yup␤] Bool::True

[02:13] <TreyHarris> allbery_b: whereas i would imagine the next question i'd want to ask be, "is $x a root?" and thus writing "if $x == rootOf($eqn)"... in that case, rootOf returning a junction would be natural.  if it returned a list or set, I'd have to write quite a bit more code

[02:13] <TimToady> a hyper is almost always going to true in Boolean context

[02:13] <TimToady> unless there were 0 elems

[02:14] <jrockway> heh

[02:14] <jrockway> even though:

[02:14] <jrockway> ?eval (5,6)>>==<<7

[02:14] <evalbot_r14932> (Bool::False, Bool::False)

[02:14] <jrockway> false, false == true ?

[02:14] <luqui> jrockway, a list with two elements is true

[02:14] <TimToady> yes, there are 2 elems so trjue

[02:14] <luqui> because it has more than 0 elements

[02:14] <jrockway> *nod*

[02:14] <jrockway> return undef; in perl5

[02:14] <TimToady> hypers are not for logic

[02:15] <TimToady> junctions are for logic

[02:15] <jrockway> junctions are

[02:15] <jrockway> yeah...

[02:15] <TreyHarris> ?eval any(5,6) == 7

[02:15] <evalbot_r14932> (Bool::False)

[02:15] * TreyHarris afk's a moment

[02:17] <TimToady> @foo[ $start + ^3 ] now does @foo [ $start <<+<< (0..2) ]

[02:17] <lambdabot> Unknown command, try @list

[02:18] <TimToady> s:2nd/<sp>\[/[/

[02:19] <TimToady> what actually happens is $start + ^3 turns into $start ..^ $start + 3

[02:20] <luqui> oh, interesting

[02:20] <TimToady> but it means we can write slices in start/length form instead of start/end form.

[02:20] <TimToady> see S03 diff on p6l

[02:21] <TimToady> I was trying to think of a new syntax for it, but realized it fell out if we did Range transforms properly.

[02:22] *** devonst17 joined
[02:23] <TimToady> not that pugs really even has Range objects yet...

[02:24] <TreyHarris> ?eval -> $x { say $x }.(all(1..3))

[02:24] <evalbot_r14932> OUTPUT[1␤2␤3␤] (Bool::True)

[02:24] <TreyHarris> ?eval for all(1..3) -> $x { say $x }

[02:24] <evalbot_r14932> OUTPUT[all(VInt 1,VInt 2,VInt 3)␤] undef

[02:24] <TreyHarris> what's the difference there?

[02:24] <luqui> TimToady, so does range arithmetic work as it does in eg. mathematica?

[02:24] <luqui> or is it simpler-minded than that?

[02:24] <TimToady> how can I answer that when I don't know how mathematic does it?

[02:25] <TimToady> but I presume it's something like my conjecture at the bottom

[02:25] <luqui> essentially you apply the operation to all the numbers in the set and take the new set

[02:25] <luqui> i.e. (-4..4)**2 == (0..16)

[02:26] <TreyHarris> I thought for all(@list) -> $item { CODE } and  -> $item { CODE }.(all(@list) were equivalent

[02:27] <TimToady> looks like for defeats autothreading.

[02:27] <TimToady> luqui: which "you" is me?

[02:27] <TreyHarris> TimToady: should it?

[02:27] *** Auzon left
[02:27] <TimToady> TreyHarris: dunno

[02:28] <luqui> it might be nice if "given" did not defeat autothreading

[02:28] <luqui> could be a nice threading idiom

[02:28] <luqui> maybe...

[02:28] <TimToady> blocks aren't exactly subs...

[02:28] <TimToady> when you use a block as a block, it's still the same chunk of code psychologically.

[02:28] <TreyHarris> In some talk I saw him give... or blog post... or something, Damian at one point used "for all..." as an example of how Perl 6 does hard things more naturally, so I just assumed it would work.

[02:29] <TreyHarris> i even put it into the perl 6 wikipedia article *grin*  and wikipedia's always correct, so i think it trumps any other considerations *smirk*

[02:29] <TimToady> currently you'd have to say "for all(@foo).values {...}"

[02:30] <TimToady> but we could debate whether junctions should be list context sensitive and just do .values for you.

[02:30] <TreyHarris> yes, but that would specifically not authothread

[02:30] <TreyHarris> "for all" reads like it should autothread

[02:31] <luqui> to me, it reads like an assertion

[02:31] <luqui> but not really

[02:31] <TimToady> for a while we had "for any(@foo) == 42 { ... }"

[02:32] <TreyHarris> luqui: but the word "for" introduces an assertion in theorems, so that doesn't really matter unless you want to get rid of the for loop :)

[02:32] <TreyHarris> TimToady: I liked that

[02:32] <TimToady> but the basic problem is that junctions do not imply ordering

[02:32] <TimToady> and usually you want to preserve it.

[02:33] <luqui> for @foo.grep 42 {..} is fine

[02:33] <luqui> er, .grep(42)

[02:33] <dduncan> can .grep work that way?

[02:34] <TimToady> ?eval for list(1..100) ~~ /7/ { .say }

[02:34] <luqui> I think .grep() takes anything that you can put after "when"

[02:34] <evalbot_r14932> OUTPUT[7␤17␤27␤37␤47␤57␤67␤70␤71␤72␤73␤74␤75␤76␤77␤78␤79␤87␤97␤] undef

[02:34] <TimToady> I think that's where we left it.

[02:34] <dduncan> okay

[02:34] <TreyHarris> well, if you just want to dispatch a block on some set of values, you've basically already decided that ordering doesn't matter.  (unless you're returning values and collecting them, but a for loop is usually imperative, not functional)

[02:34] <dduncan> it doesn't have to be

[02:35] <TreyHarris> dduncan: i know it doesn't have to be, that's why i said "usually" :)

[02:35] <luqui> it pretty much is imperative

[02:35] <luqui> given the uselessness of its return value

[02:35] <luqui> (last thing executed on the last iteration)

[02:35] <TimToady> anyway list(@foo) currently does that in comparison context.

[02:35] * TreyHarris nods

[02:36] <luqui> ?

[02:36] <dduncan> on the other hand, assuming there are no situations where 'for' means the same thing as 'map', then I agree it is imperative

[02:36] <TimToady> seem eval abovfe

[02:36] <TimToady> see eval above even

[02:36] <luqui> haha

[02:36] <luqui> oh... weird

[02:36] <luqui> where is the spec for that?

[02:36] <TreyHarris> ?eval gather { for list(1..100) ~~ /7/ -> $x { take ":$x:" } }

[02:36] <evalbot_r14932> (":7:", ":17:", ":27:", ":37:", ":47:", ":57:", ":67:", ":70:", ":71:", ":72:", ":73:", ":74:", ":75:", ":76:", ":77:", ":78:", ":79:", ":87:", ":97:")

[02:36] <TimToady> S09 I think, checking

[02:37] <TreyHarris> TimToady: so is that getting ordered after the for loop has completed?  or is the for loop not allowed to autothread?

[02:38] <TimToady> there's no junction there.

[02:38] <TimToady> list(1..100) ~~ /7/ basically turns into a grep

[02:39] <dduncan> that's an interesting thought ... situations where the actual execution order of iterations doesn't matter, but just that outputs have the same order as their corresponding inputs

[02:39] <dduncan> that could still be parallelized, but its more tricky than when the order doesn't matter

[02:39] <TreyHarris> right... so if i wanted to autothread and didn't care about ordering, I'd have to write...  um...

[02:40] <luqui> so what does list(...) return?

[02:40] <luqui> just a list?

[02:40] <TreyHarris> oh, we don't have list comprehensions, do we?  so i couldn't write it with autothreading

[02:40] <TimToady> S02:2206

[02:40] <dduncan> maybe behind the scenes each list item could be tagged with meta-data that says what its original ordinal position was, then they hyperthread, then the results are sorted by the same meta-data

[02:40] <luqui> see, that's essentially how I want junctions to work...

[02:41] <TreyHarris> so there's no implicit way for me to say, "in any order, give me the numbers between 1 and 100 containing a 7, surrounded by colons, and please autothread"

[02:41] <dduncan> but I'm applying the above to actual arrays or seqs where we somehow determine no connection between iterations

[02:41] <luqui> list(1,2,3) < list(4,5,6) # ?

[02:41] <dduncan> I don't see junction elements as having an order

[02:42] *** dmq joined
[02:42] <luqui> I don't know why we don't adopt the standard list comprehension idea...

[02:42] <TreyHarris> ?eval any(1..10) ~~ /7/

[02:42] <evalbot_r14932> (no output)

[02:42] <luqui> being able to use logical language like that is nice

[02:42] <TreyHarris> ?eval my @a = any(1..10) ~~ /7/; @a.perl.say

[02:42] <evalbot_r14932> (no output)

[02:43] * TreyHarris doesn't understand

[02:43] <luqui> no output is a bad thing... means crash or something right?

[02:43] <TreyHarris> ?eval 1 + 1

[02:43] <evalbot_r14932> 2

[02:43] <TreyHarris> luqui: yeah, you're right, it gives me a bus error on my local pugs

[02:43] <luqui> TreyHarris, yes, it's crash

[02:43] <TimToady> segv

[02:44] <TreyHarris> ok, running way late now, decommuting.  thanks for the interesting things to think about, all :)

[02:44] * TreyHarris &

[02:48] <luqui> ooh, junctions really do "thread" on pugs

[02:49] <TimToady> so do hypers

[02:49] * luqui struggles to find a way to test that

[02:49] <TimToady> ?eval (0..10)>>.say

[02:49] <evalbot_r14932> OUTPUT[1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤0␤] (Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True)

[02:50] <TimToady> ?eval (1,2,3,4,5,6,7)>>.say

[02:50] <evalbot_r14932> OUTPUT[2␤3␤4␤5␤6␤7␤1␤] (Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True)

[02:50] <luqui> yeah...

[02:51] <luqui> but how do I know it's not just mixing up the order (it's fairly obvious that it's not in this case, but for the junction case it wasn't)

[02:51] *** GeJ_ joined
[02:51] <TimToady> cuz I was here when audreyt hacked it in :)

[02:51] <luqui> I was outputting [0][1][2][3][4], and I got it to output [0][1[2][3][4]]

[02:51] <luqui> hehe

[02:52] <TimToady> and her hypers ran twice as fast on her 2-cpu machine...

[02:53] <luqui> cool

[02:53] <luqui> oh, can I have outer, please?

[02:53] <luqui> (maybe with a good name, too?)

[02:54] <luqui> we have zip and roundrobin...

[02:55] *** awwaiid__ joined
[02:55] <TimToady> outer?

[02:55] <TimToady> @foo XX @bar ?

[02:55] <lambdabot> Maybe you meant: faq ft todo yow

[02:56] *** Psyche^ joined
[02:56] <luqui> outer(1,2; 3,4) == ([1,3], [1,4], [2,3], [2,4])

[02:56] <luqui> XX eh?

[02:56] <luqui> ?eval (1,2) XX (3,4)

[02:56] <evalbot_r14932> Error: ␤Unexpected "XX"␤expecting operator

[02:56] <TimToady> not impl

[02:56] <TimToady> but see "your" synopsis

[02:57] <TimToady> S03:1186

[02:57] <TimToady> Cross operators

[02:58] <luqui> huh.

[02:58] <luqui> a metaoperator..

[02:58] <luqui> a bit overkill, but satisfactory

[02:59] <TimToady> feel free to implement it.  :)

[03:00] <luqui> can I ask a metadesign question?

[03:00] *** fridim joined
[03:00] <fridim> hi there.

[03:00] <luqui> why all the metaoperators?

[03:01] <luqui> hi there fridim 

[03:01] <TimToady> why not?

[03:02] <luqui> because they will be hard to look up for people not familiar with them

[03:02] <TimToady> beats doubling the number of operators

[03:02] *** Lee_ joined
[03:02] <luqui> I mean, why not:  cross(&infix:<~>, <a b>, <c d>)

[03:02] <TimToady> I think we'll have to be sure to provide a pleaseexplain "X,X" command

[03:02] <luqui> along with XeqX, X~X, etc...

[03:02] <TimToady> because <a b> X <c d> is prettier.

[03:03] <luqui> yeah, but it doesn't matter if it's never used

[03:03] <TimToady> I think X will be used frequently.

[03:03] <luqui> I've never used whatever functional programming word there is for [\+]

[03:03] <TimToady> particularly in constructing filenames

[03:04] <TimToady> I'm not too worried as long as we have something that will explain snippets

[03:04] <luqui> I like outers... Haskell's list monad is so good at them that I use it for any type of combinatorical or probabilistic problem I have

[03:05] <TimToady> it saves a heap of nested loops.

[03:06] <TimToady> and we'll see a lot of "for @foo XX @bar XX @baz -> [$a, $b, $c] {...}"

[03:06] *** Lee_ is now known as LeeD

[03:06] <luqui> well, I can at least implement X and XX, without implementing the whole metaoperator

[03:06] <luqui> TimToady, true, but the big reason to do that is when you don't know how many arrays you have

[03:06] <TimToady> everything else just desugars to XX and reduce

[03:06] <luqui> would you say:  for [XX] @arrays -> @xs {...}

[03:07] <TimToady> why not?

[03:07] <luqui> okay...

[03:07] <luqui> (it took too much thinking to determine whether that was what I wanted :-

[03:07] <TimToady> dinner &

[03:08] *** wamiks joined
[03:10] *** hexmode left
[03:11] *** Psyche^ is now known as Patterner

[03:43] <svnbot6> r14933 | luqui++ | Implemented XX (but not the metaoperator).

[03:43] *** GeJ_ is now known as GeJ

[03:50] *** luqui joined
[03:50] <luqui> ?eval 1,2 XX 3,4

[03:50] <evalbot_r14932> Error: ␤Unexpected "XX"␤expecting operator

[03:50] <luqui> ?eval 1,2 Y 3,4

[03:50] <evalbot_r14932> ((1, 3), (2, 4))

[03:53] <TimToady> ?eval 1,2 XX 3,4

[03:53] <evalbot_r14932> Error: ␤Unexpected "XX"␤expecting operator

[03:53] <TimToady> huh, recompiled mine in that time...

[03:53] <luqui> i think evalbot checks every 5 minutes or so

[03:54] <luqui> so it may have just started

[03:56] <TimToady> ?eval 1,2 XX 3,4

[03:56] <evalbot_r14932> Error: ␤Unexpected "XX"␤expecting operator

[04:01] * luqui wonders whether evalbot cleans before rebuild

[04:02] <TimToady> ?eval 1,2 XX 3,4

[04:02] <evalbot_r14932> Error: ␤Unexpected "XX"␤expecting operator

[04:03] <TimToady> ?eval 1,2 XX 3,4

[04:03] <evalbot_r14933> ((1, 3), (1, 4), (2, 3), (2, 4))

[04:04] <TimToady> ?eval [~]<< 1,2 XX 3,4

[04:04] <evalbot_r14933> Error: ␤Unexpected "<< 1"␤expecting dot, ":", "(", term postfix or operator

[04:04] <luqui> no hyper-reduce?

[04:04] <luqui> ?eval [~]<< [1,2,3]

[04:04] <evalbot_r14933> Error: ␤Unexpected "<< ["␤expecting dot, ":", "(", term postfix or operator

[04:04] <luqui> of course that is nonsense

[04:05] <luqui> ?eval [~]<<[1,2,3]

[04:05] <evalbot_r14933> Error: ␤Unexpected "<<["␤expecting dot, ":", "(", term postfix or operator

[04:05] <TimToady> ?eval [~]« 1,2 XX 3,4

[04:05] <evalbot_r14933> Error: ␤Unexpected "\171"␤expecting dot, ":", "(", term postfix or operator

[04:05] <luqui> so is (-4..4)**2 == (0..16) ?

[04:05] <luqui> huh?

[04:05] <TimToady> why not?

[04:06] <luqui> no reason

[04:06] <luqui> interval arithmetic can get tricky

[04:06] <luqui> but as long as we only define it for "normal" operators, it should be fine

[04:06] <TimToady> question is what does (-4..4:by(2)) ** 2 give you?

[04:07] <TimToady> something that would be hard to write otherwise, I expect

[04:08] <luqui> let's see... (16, 4, 0, 4, 16).   so it would be :by(4(i-2))

[04:09] <luqui> hmm... :by(4($^i-2))

[04:09] <luqui> shades of the einstein notation discussion

[04:10] <luqui> except that's wrong..

[04:12] <luqui> (-12, -4, 4, 12)   :by(8*$^i-12)

[04:12] <luqui> but that's not really important...

[04:13] <luqui> the point is log(1..4) listifies to (0, log(2), log(3), log(4))

[04:13] <TimToady> right

[04:14] <luqui> but how far do we take it?

[04:14] <luqui> and ranges are not referentially transparent (very strange)

[04:14] <TimToady> however far we take it, someone else will take it farther... :/

[04:15] *** ssig33 joined
[04:15] <luqui> (-1..1) * (-1..1)  == (-1..1)  ;  my $x = -1..1;  $x * $x == (0..1)

[04:16] <TimToady> multidimensional ranges?

[04:16] <luqui> affine and nonlinear slices, you mean?

[04:17] <TimToady> I'm not a PDLer...

[04:17] <luqui> I'm not either..

[04:18] <TimToady> at some point I wish those folks would say something.

[04:18] <luqui> just slices whose span are not hypercubes

[04:48] *** mr_ank joined
[04:49] *** kanru joined
[05:37] *** nipra joined
[05:39] *** nekokak joined
[05:59] *** nipra joined
[06:01] *** iblechbot joined
[06:03] *** nipra joined
[06:11] *** justatheory joined
[06:12] *** baest joined
[06:15] *** BooK_ joined
[06:16] *** kanru joined
[06:57] *** lisppaste3 joined
[06:57] *** Lee_ joined
[07:01] *** ofer1 joined
[07:08] *** rintaro joined
[07:21] *** RHainsworth joined
[07:27] *** TSa joined
[07:38] *** luqui joined
[07:42] <TSa> HaloO Luke

[07:47] *** RHainsworth left
[07:58] *** Lee__ joined
[08:10] <luqui> hello TSa 

[08:15] <TSa> ups that was a long reaction time

[08:22] <luqui> heh, there is a little lag :-)

[08:22] <TSa> not now

[08:22] <luqui> hey

[08:22] <TSa> what's your local time

[08:23] <luqui> 1:23 am

[08:23] <TSa> nighttime then

[08:23] <TSa> I'm not sure what the best time is on #perl6

[08:23] <luqui> well, I suppose.  Boulder time is 1:23 am.  Luke time is about 3:00 pm

[08:24] <TSa> european evening seems a bad time

[08:24] <luqui> perhaps

[08:24] <luqui> I don't know when audreyt comes around

[08:24] <luqui> TimToady is around during US daytime

[08:25] <TSa> have you discussed supertyping with larry

[08:25] <luqui> not really

[08:25] <dduncan> I have an opinion question re the naming of a data type ...

[08:25] <luqui> I don't really get the module thing he proposed

[08:25] <luqui> dduncan, ... kay

[08:26] <TSa> BTW, do you meet him in person on a regular basis?

[08:26] <luqui> no

[08:26] <dduncan> I would like to have a data type which can have just 1 value, and it is used as the implicit default value for a variable or parameter or whatever whose declared type is Any.

[08:26] <luqui> TSa, I (am going to start) attend(ing) the weekly phone meetings again

[08:26] <dduncan> its more meant as a marker, something people can query for to see if it isn't a normal value

[08:27] <dduncan> and the declared semantics of Undef suggest that isn't quite what I want

[08:27] <TSa> you have been offlist for a whie

[08:27] <luqui> Nothing?

[08:27] <dduncan> because the type I'm thinking of should not automatically become the prototype value for other classes

[08:27] <luqui> TSa, ya, beed doing school

[08:27] <luqui> s/beed/been/

[08:27] <dduncan> that's a thought

[08:28] <dduncan> I wanted to use it in some of the same places that a SQL Null is used, but I explicitly want to not name it Null, so that people wouldn't be confused as it is different

[08:28] <baest> 7win 1

[08:28] <baest> sorry :)

[08:28] <dduncan> I suppose I could go with Nothing until something better comes up

[08:28] <luqui> Nothing is better than something!

[08:28] <dduncan> indeed

[08:29] * luqui is reminded of a great dialogue in my linguistics homework:  "I suppose this sandwich is better than nothing"  ;  "You're right, nothing is worse than that sandwich!"

[08:31] <dduncan> does Nothing sound better or worse than None ?  or Empty ?

[08:32] *** devonst17 left
[08:32] <luqui> Empty is reasonable; though that seems more like the name of a container  (my $x is Empty)

[08:32] <dduncan> or is there a common term that describes both the number zero and the empty string, which are normal values that are closest to that type's concept of nothingness

[08:32] <luqui> Idenitity...

[08:33] <luqui> haha

[08:33] <luqui> "Nullity"

[08:33] <TSa> lugui: are 'is also' re-openings of classes lexically scoped?

[08:34] <luqui> TSa, I don't think so

[08:34] <dduncan> fyi, for declared types of Str or Int etc, I would default containers of such to the empty string or zero, but in the case of containers declared Any, I have to use some other type because there is no value of type Any

[08:34] <dduncan> that's the context ... something thematically similar that works with Any

[08:34] <TSa> so they re-open the underlying package of the class

[08:34] <luqui> dduncan, but specifically isn't of a more specific type?

[08:34] <luqui> TSa, yeah... multis can be lexically scoped

[08:35] * luqui isn't sure whether he wants to embrace lexically scoped methods

[08:36] <luqui> reminds me of the dependency problems of C++ (and most other statically typed OO languages)

[08:36] <dduncan> Any is conceptually like the maximal type of Perl 6 ... everything else is one, but you can't have a value of Any ... though I think Perl 6 also uses Object for a similar purpose

[08:36] <TSa> another thing that haunts me is homonymous role, class and module

[08:37] <TSa> dduncan, I can imagine a undef of Any

[08:37] <dduncan> anyway, thanks for your help

[08:37] <luqui> TSa, homonymous?

[08:38] <TSa> yes, e.g. Array denotes a class and a role

[08:38] <luqui> oh.

[08:38] <luqui> I suppose

[08:38] <TSa> how does user code achive this?

[08:38] <luqui> I kind of like the role/class homonymy.  the role is the type or the interface, the class is the implementation

[08:39] <luqui> it means you can re-implement the interface of a class if you need to, and it will work everywhere the class was expected

[08:39] <luqui> without inheriting...

[08:39] <TSa> I like this as well, but I'm unsure if you can have both under the same name

[08:40] <luqui> I think of the class as the thing that comes before .new, and the role as everything else

[08:41] <TSa> Yeah, but how is homonymity written? Aren't roles and class declarations competing for the same name slot=

[08:43] <TSa> or can you write 'does A' even if A is a class?

[08:43] <luqui> a role name comes after "does"

[08:43] <luqui> it's actually kind of annoying me... there is very little difference between a role and a class anymore

[08:44] <luqui> I'm beginning to think that most perl 6 code will simply ignore the distinction

[08:44] <dduncan> you can't instantiate a Role, can you?

[08:44] <luqui> no

[08:44] <luqui> but that is pretty much the only difference

[08:44] <TSa> a role is closed

[08:44] <dduncan> does that mean a Role can have attributes?

[08:44] <TSa> yes

[08:45] <luqui> yes, a role can have attributes

[08:45] <luqui> they are (yay!) just shorthand for their accessors

[08:45] <TSa> but they will become attributes of the class the role is composed into

[08:46] <TSa> what is unclear to me is if roles are kept after compilation

[08:46] <dduncan> that sounds good ... it means the class still has the actual say of physical representation, and it is encapsulated away from the role code

[08:46] <TSa> that is for looking up methods

[08:47] <TSa> or is the role not needed after composition because all info is stored in the class

[08:47] <luqui> yeah, I like the situation:  I beginning to think that inheriting structure is not as good as inheriting interface

[08:47] <luqui> so I don't see the point of class inheritance

[08:48] <luqui> TSa, I think that's the idea

[08:48] <TSa> so the only remains of the role is the fact that instances of teh class do the role

[08:49] <luqui> and that the role can be mixed in to existing objects

[08:50] <TSa> ahh, yes but again it is edited in not linked by reference

[08:52] <luqui> hmm..

[08:52] <luqui> that's a good question

[08:52] <luqui> my gut says referential semantics are more expressive

[08:52] <luqui> but then composition rules break if you can edit roles

[08:53] <luqui> ah, essentially the discussion that was happening during the supertyping thread

[08:53] <TSa> yes

[08:54] <TSa> so we have some fundamental differences between role and class

[08:54] <luqui> hm.  okay.

[08:58] <TSa> could the compiler always distinguish role and class contexts?

[08:58] <TSa> I mean when it were allowed to have homonymous class and role

[08:59] *** Lee_ joined
[09:01] <luqui> I think so...

[09:02] <luqui> in term position, it is the class (the package); in type position, it is the role

[09:02] <luqui> hmm

[09:02] <luqui> what about .does?

[09:02] <luqui> .does(MyRole)   # MyRole is in term position

[09:05] <TSa> BTW, should homonymous class and role be allowed only when teh class does the role

[09:06] <TSa> I mean could there be some automatisms to enforce it?

[09:06] <TSa> E.g. 'class does Foo' could give the role name to the class

[09:07] <TSa> and of course there can be only one otherwise anonymous class that does the role

[09:13] <TSa> I'll be AFK for a while

[09:22] *** araujo joined
[09:31] *** elmex joined
[09:41] *** andara joined
[09:49] *** zdeqb joined
[09:53] *** buetow joined
[09:57] *** devogon joined
[09:57] *** nipra joined
[10:23] *** zdeqb joined
[10:24] *** zdeqb left
[10:24] *** foo\ joined
[10:40] *** fglock joined
[10:44] *** nipra joined
[10:54] *** nekokak_ joined
[10:57] *** nipra joined
[11:11] *** ruz joined
[11:32] *** Kattana joined
[11:38] *** dduncan left
[11:42] *** iblechbot joined
[11:59] *** kanru joined
[12:15] *** chris2 joined
[12:16] *** frankg joined
[12:24] *** RHainsworth joined
[12:24] *** RHainsworth left
[12:30] *** nipra joined
[12:53] *** araujo joined
[13:28] *** luqui joined
[13:30] *** buetow joined
[13:35] *** kanru joined
[13:38] *** LeeD joined
[13:56] *** elmex joined
[13:59] *** Shabble_ joined
[14:16] *** gnuvince joined
[14:27] *** andara joined
[15:07] <TSa> bye to whoever listens

[15:08] *** hexmode joined
[15:13] *** araujo joined
[15:26] *** fglock joined
[15:28] *** stevan joined
[15:31] *** marmic joined
[15:49] *** bonesss joined
[15:49] *** penk joined
[15:54] *** weinig|away is now known as weinig

[15:55] *** kanru joined
[16:09] *** iblechbot joined
[16:14] *** RHainsworth joined
[16:17] *** RHainsworth left
[16:19] <xinming> what is the name of the module which is make perl 5 oop better please? I forgot.

[16:20] *** chris2 joined
[16:22] *** wamiks joined
[16:22] <broquaint> Moose.

[16:23] <xinming> Thanks. :-)

[16:24] *** amnesiac joined
[16:38] *** elmex joined
[16:56] *** kane-xs_ joined
[17:12] *** justatheory joined
[17:13] *** ruoso joined
[17:23] *** nipra joined
[17:28] *** weinig is now known as weinig|away

[17:36] *** ozo joined
[17:47] *** nipra joined
[17:49] *** _bernhard joined
[18:02] *** weinig|away is now known as weinig

[18:13] *** buetow joined
[18:15] *** bonesss joined
[19:04] *** rindolf joined
[19:05] <rindolf> Hi all.

[19:07] <TimToady> howdy.

[19:09] <rindolf> Hi TimToady! What's up?

[19:09] *** justatheory joined
[19:09] <rindolf> TimToady: what was the first computer you worked on?

[19:12] <TimToady> PDP 11/20

[19:13] <rindolf> TimToady: did the 20 means 20 KB of memory?

[19:14] <rindolf> TimToady: did it ran some kind of unix?

[19:15] <TimToady> maybe, if you count in octal.

[19:15] <TimToady> it had 16KB

[19:15] <rindolf> TimToady: hmm...

[19:16] <rindolf> Then what did the /20 stand for? Some kind of model?

[19:16] <TimToady> I think it was just a model

[19:16] <TimToady> they soon upgraded to an 11/45

[19:16] <Juerd> But... 11/45 < 11/20 :)

[19:16] <TimToady> and we programmed in RSTS

[19:16] <Juerd> Were they trying to reach 0 eventually? :)

[19:17] <TimToady> which eventually was upgraded to RSTS/E

[19:17] <TimToady> don't know what you get when you divide RSTS by E...

[19:17] <TimToady> maybe that's 0.

[19:17] <Juerd> Depends on the value of E.

[19:17] <Juerd> Perl 5 would make this a division by 0 :)

[19:17] <rindolf> http://en.wikipedia.org/wiki/PDP-11#PDP-11_models

[19:18] <Juerd> http://svg.tnx.nl/dump/2006-12-21T00:19:19_g9k7v0.svg.gz

[19:18] <Juerd> Wrong window

[19:18] <Juerd> Ignore that url :)

[19:18] <Juerd> (Or not, I don't care, but note that it's incredibly off topic here)

[19:18] *** thestarslookdown joined
[19:20] <TimToady> I do remember we got an offer several years later for V6 Unix for $300 "a special price because we're going to V7".

[19:20] <TimToady> we didn't see the point, at that point.

[19:21] <TimToady> "It doesn't seem to have BASIC..."

[19:22] <rindolf> TimToady: when did you receive this offer?

[19:22] <TimToady> so I never ran Unix till after I was married and moved to LA.

[19:22] <TimToady> mid 70's, don't remember exactly.

[19:23] <rindolf> TimToady: OK.

[19:24] <TimToady> and it wasn't like we could dual-boot The Computer which was the only computer in the whole college.

[19:24] <rindolf> TimToady: so this was at college?

[19:24] <Juerd> My first computer was Intel 80286 based :)

[19:24] <rindolf> Juerd: mine was 8080-based.

[19:24] <rindolf> 8088 even

[19:24] <TimToady> yes, though I also worked there while packing 4 years into 8.

[19:24] <Juerd> I had an 8088 later

[19:25] <jrockway> 4.7MHz or 8?

[19:25] <Juerd> The 286 belonged to my parents; the XT was MINE :)

[19:25] <TimToady> first computer I ever *owned* was an Amiga 1000.

[19:25] <Juerd> jrockway: I have absolutely no idea. I wasn't geek enough at the age of 7.

[19:25] <Juerd> The XT quickly broke, and I was back to not owning a computer.

[19:25] <jrockway> Juerd: ah, i remember when I got (to use) a tandy1400 laptop that was 8MHz instead of my tandy 1000 at 4.7MHz :)

[19:25] <jrockway> memories :)

[19:26] <TimToady> I still have that Amiga 1000.

[19:26] <TimToady> It still runs.

[19:26] <rindolf> TimToady: heh.

[19:26] <rindolf> TimToady: have you tried running Linux or BSD on it?

[19:26] <Juerd> I have owned an Apple ][, but sold it, not realising how hard it'd be to get one again.

[19:26] <TimToady> Linux never made it onto the 1000, as far as I know.  No memory management.

[19:27] <TimToady> had it on the 2000 and the two 3000s though.

[19:27] <jrockway> Juerd: i've gotten over my attraction to junk computers.  probably related to having no storage space in my apartment :)

[19:28] <Juerd> My current office has too much unused wall.

[19:29] <Juerd> I want old junk computers up there

[19:29] <Juerd> But I need a few to begin with. Otherwise it just looks silly

[19:31] <TimToady> I mean Unix in any form never made it onto the 1000.  The Unix on the higher models was a SysV clone.

[19:31] <TimToady> but it cost like $500, so never installed it.

[19:33] *** larsen_ joined
[19:46] <Juerd> I've never in my life worked with a commercial Unix

[19:46] <Juerd> Just never encountered it

[19:46] *** wamiks joined
[19:48] <TimToady> I've been on most of them at one time or another, but mostly 

[19:48] <TimToady> Solaris

[19:49] <TimToady> however, mostly I was on BSD.  (the Real BSD. :)

[19:49] <TimToady> that was back when "All the world is a Vax."

[19:51] <Juerd> I guess I'm just lucky :)

[19:51] <TimToady> ah, yes, HP/UX and AIX...fond memories.

[19:51] <TimToady> "smit happens"

[19:52] * Juerd has always taken all the nice modern tools for granted :)

[19:52] <TimToady> and 10 years from now you'll wonder how you ever survived without something that hasn't been invented yet.

[19:52] <Juerd> In fact, it wasn't until the post-oscon Amsterdam.pm meeting where you got the black camel trophee, that I knew that *you* made patch :)

[19:53] <Juerd> Yea. I already can't imagine how I ever survived without a car, even though they were invented long before I was born :)

[19:55] <gaal> so was cdr

[19:55] <TimToady> I don't think it was invented before I was born...

[19:56] <Juerd> Hehe :)

[19:56] * kolibrie isn't sure how he survived without Perl 6 regexes, and they are not even finished being invented

[19:56] <TimToady> yeah, it's turning us all into a bunch of whiners...

[19:57] <Juerd> I'm finding it harder and harder to cope without gather/take, actually :)

[19:57] <TimToady> but we have gather/take.  :)

[19:57] <gaal> I like how lambda calculus was around before computers.

[19:57] <Juerd> TimToady: I don't have it in my production perl 5 :)

[19:58] <TimToady> not that difficult to emulate, actually.

[19:58] <gaal> Acme::Gather::Round:Ye::Perl6::Hackers

[19:59] <kolibrie> looks like it's not implemented in v6.pm yet

[20:06] <jrockway> kolibrie: just use pugs instead of perl :)

[20:06] <TimToady> we just need a Haskell-to-MiniPerl6 translator.

[20:06] <kolibrie> jrockway: but then it is not in Juerd's production perl 5

[20:07] <TimToady> how hard can h2m be?

[20:07] * kolibrie times TimToady 

[20:07] <TimToady> hmm, I'd have to learn Haskell again...

[20:08] * kolibrie stops his stopwatch - any other takers?

[20:08] <wolverian> did you unlearn it?

[20:09] <TimToady> didn't have to, kinda unlearned itself.

[20:09] <kolibrie> only a temporary rewiring then

[20:10] <TimToady> It's just a variant of BASIC, right?

[20:10] <jrockway> instead of GOSUB they have lambda

[20:10] <jrockway> i think this would be nice, btw:

[20:11] <wolverian> it's very intuitive, except when it's not.

[20:11] *** mrossetti joined
[20:11] <jrockway> use Haskell; let f = ( * 2); use v6; print f(2);

[20:11] <jrockway> misplaced space...

[20:11] <TimToady> use Inline::Haskell

[20:13] <jrockway> although perl6 seems to remove the "inline" part and make it Just Work

[20:13] <jrockway> i.e., no Inline::Perl5 required, just "use v5"

[20:14] <TimToady> well, sure, it's just a multi-line macro now.

[20:17] *** thestarslookdown joined
[20:42] *** ruoso joined
[20:52] *** thestarslookdown joined
[21:00] <Tene> ?eval use Haskell; let f = ( * 2); use v6; print f(2);

[21:00] <evalbot_r14933> Error: *** Unsafe function 'use' called under safe mode␤    at -e line 16, column 7-112

[21:07] <gaal> when does a gather/take assignment happen? Can my @g = gather { ... refer to @g ... } ever make sense?

[21:11] <Juerd> IIUC, declarations happen instantly, so "my $foo = \$foo" would be problematic.

[21:13] *** penk joined
[21:15] *** miyagawa joined
[21:19] *** elmex joined
[21:33] <TreyHarris> anyone with CPAN.pm clue on right now?  please IM me?

[21:36] *** dduncan joined
[21:36] <Juerd> TreyHarris: This is #perl6, about Perl 6. You may want to try #perl for Perl 5 stuff.

[21:38] <TreyHarris> Juerd: i was in the wrong window

[21:38] <TreyHarris> apologies

[21:39] *** elmex_ joined
[21:41] *** gnuvince joined
[21:43] <jrockway> maybe he was trying to get the 6pan up and running :)

[21:55] <Juerd> Brave

[22:18] <gaal> is "gather { return }" legal?

[22:19] <gaal> I'm sure you can all guess what I'm spending the evening on :-)

[22:19] *** justatheory joined
[22:29] *** justatheory joined
[22:36] *** gnuvince` joined
[22:37] *** gnuvince joined
[23:02] <gaal> http://perlcabal.org/~gaal/Perl6-Gather-0.01.tar.gz though after I finished testing it I discovered Damian already put something on CPAN.

[23:03] <gaal> ah well, mine has fewer deps. :)

[23:03] <qmole> that's a good hint that you're doing something slightly crazy

[23:04] *** Odin-LAP joined
[23:04] <gaal> you be the judge. :)

[23:05] <gaal> although being on this channel is alredy considered a good hint

[23:06] <qmole> heh

[23:07] <qmole> i observe from a safe distance

[23:07] *** mrossetti joined
[23:08] *** mrossetti left
[23:15] *** Aankhen`` joined
[23:17] *** thestarslookdown joined
[23:19] *** Psyche^ joined
[23:21] *** amnesiac_ joined
[23:23] *** dolmen joined
[23:25] <avar> http://sial.org/pbot/21928 <- from perl 5.10 docs, isn't this just something that should be fixed in s04 if it hasn't already?

[23:25] <lambdabot> Title: Paste #21928 from Someone at 85.197.228.236

[23:28] *** GeJ joined
[23:31] *** luqui joined
[23:34] *** thestarslookdown joined
[23:35] *** polettix joined
[23:37] *** Psyche^ is now known as Patterner

[23:41] *** neonse joined
[23:50] *** weinig is now known as weinig|away

