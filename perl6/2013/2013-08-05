[00:01] *** leont left
[00:03] *** Vlavv left
[00:05] <jnthn> 'night, #perl6

[00:05] <ruoso> night jnthn 

[00:11] *** ggoebel left
[00:22] *** benabik left
[00:27] *** benabik joined
[00:41] *** dayangkun joined
[00:44] *** BenGoldberg left
[01:00] *** markov left
[01:01] *** markov joined
[01:04] *** kriptik joined
[01:05] <kriptik> i'm looking forward to learn perl6, can anyone tell me what would be a perfect usecase to experiance the language power

[01:07] <ruoso> text parsing using grammars would be my suggestion

[01:09] <timotimo> indeed. the simplicity by which a grammar and an actions class construct useful data structures from your input data is quite an awesome thing to behold

[01:10] <timotimo> of course if your input format is sufficiently insane, the simplicity gets kind of lost in the shuffle

[01:11] <kriptik> thnx, any super awesome tutorial out there i should check out for that/

[01:11] <kriptik> ?

[01:12] <timotimo> i thought the perl6 book was okay, but it really depends on what your background is

[01:12] <timotimo> there's a few things the perl6 book didn't explain. ("why is there suddenly a colon here?")

[01:13] <timotimo> that's probably because i hadn't written a single line of perl5 yet

[01:13] <kriptik> i did some perl5 using dancer then switched back to ruby/sinatra

[01:13] <timotimo> one resource that i found super nice was the advent calendar posts on perl6advent.wordpress.com, but that's more like an appetizer than an introduction or tutorial text

[01:18] <timotimo> we have a dancer-alike called Bailador, you can check that and other modules out on modules.perl6.org

[01:18] <timotimo> otherwise asking questions here is always okay; right about now most people are asleep, though

[01:20] <kriptik> thanks timotimo, i didnt know that bailador was perl6

[01:20] <kriptik> is it plack compatible?

[01:20] <timotimo> unfortunately i don't know anything about web app development. i only did some django a few years back

[01:21] <kriptik> you use perl6 for?

[01:21] <timotimo> uh ... experimenting, learning, hacking the compiler ;)

[01:21] <kriptik> hacking the compiler, please explain :)

[01:21] <timotimo> i contribute little things to rakudo itself

[01:21] <kriptik> what is rakudo?

[01:22] <timotimo> fixing low hanging fruit bugs for example

[01:22] <timotimo> rakudo is our current "main" implementation of perl6

[01:22] <kriptik> i like that experession low hanging fruit bugs :)

[01:22] <kriptik> nice

[01:22] <timotimo> hah, i didn't think of the two running together yet

[01:23] <kriptik> so what do you like most about perl6

[01:23] <timotimo> i was drawn to perl6 for its type system and object system

[01:24] <timotimo> after running into too much trouble writing a kind of big framework in python, i needed something to complain at compile time when i'm doing obvious type errors

[01:24] <kriptik> python is complied language?

[01:25] <timotimo> more or less

[01:25] <timotimo> it's bytecode compiled, but there is no compile-time type checking

[01:25] <timotimo> but really all the other aspects are really interesting to me: the way functional programming flows so seamlessly into most other concepts, the short and expressive syntax that has gained so much readability compared to perl5 (the rules syntax for grammars is so super nice) and all the other stuff

[01:26] <timotimo> and perl6 has what masak likes to call "strange consistencies"; concepts that pop up in many places; it's all connected, like a conspiracy theorist would claim

[01:27] <kriptik> hmm, i never understood these stuff, i hope i will soon. thats what drawn me into perl 6 and ruby 2, i wanna know which one would be faster or even use a low level web api like rake or plack based on the language... i am kinda of an ultimate tool freak seeker, i know its pointless still i can't help it

[01:27] <timotimo> oh, you want execution speed? :|

[01:27] <kriptik> perl6 is fast right?

[01:27] <timotimo> it can be

[01:28] <kriptik> no wait, i thought it will be faster than perl5

[01:28] <timotimo> niecza is very fast compared to rakudo, but niecza lacks a bunch of features

[01:28] <kriptik> hmm, niecza is...?

[01:28] <timotimo> another perl6 implementation, that one runs on .net and mono

[01:29] <kriptik> i wouldnt use a .net framework or mono

[01:29] <kriptik> is there such a thing as perl virtual machine

[01:30] <timotimo> rakudo is currently being ported to the JVM, we are hoping for good speed improvements there. after that comes a new VM that is custom made for perl6

[01:30] <timotimo> parrot used to be that, and rakudo runs on that

[01:30] <kriptik> yeah i came accross parrot 

[01:30] <timotimo> but sadly it isn't very fast

[01:30] <kriptik> compared to...?

[01:31] <timotimo> niecza, if you want to compare it to other perl6 implementations

[01:31] <dalek> perl6-roast-data: 0b38e01 | coke++ | / (5 files):

[01:31] <dalek> perl6-roast-data: today (automated commit)

[01:31] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/0b38e01421

[01:31] <timotimo> you can definitely get speed improvements when you use natively typed variables (int, str and num instead of Int, Str and Num), but it only gets you so far.

[01:32] <flussence> Parrot's performance is comparable to the Javascript engine on a ~15 year old browser

[01:33] <timotimo> in the next few days, we'll get compile-time inlining for some sub calls for the JVM; i'm hoping for a decent speed boost from that alone, but we won't be faster than perl5 for complicated tasks so soon.

[01:34] <timotimo> sadly, i've been toying around with pypy before i came to perl6; the speed difference is crazy

[01:35] <timotimo> anyway, rakudo is definitely still in the "make it work" phase, the real "make it fast" phase is yet to come

[01:35] <timotimo> and with good compile-time analysis at our disposal, i think we'll get to very nice places indeed.

[01:36] *** xinming left
[01:38] *** xinming joined
[01:38] *** raiph joined
[01:45] <ruoso> r: sub foo { CONTROL { say "Inside CONTROL!" }; return "bar" }; say foo(); 

[01:45] <camelia> rakudo 8d851b: OUTPUT«bar␤»

[01:45] <ruoso> wasn't "Inside CONTROL!" supposed to be printed above as well?

[01:45] *** xinming left
[01:47] *** colomon joined
[01:47] <timotimo> r: sub test { sub foo { CONTROL { say "Inside CONTROL!" }; return "bar" }; say foo(); CONTROL { say "outside control!" } }; test;

[01:47] <camelia> rakudo 8d851b: OUTPUT«bar␤»

[01:47] * timotimo doesn't know about CONTROL

[01:47] <timotimo> r: sub test { sub foo { CONTROL { say "Inside CONTROL!" }; note "something"; return "bar" }; say foo(); CONTROL { say "outside control!" } }; test;

[01:47] <camelia> rakudo 8d851b: OUTPUT«something␤bar␤»

[01:47] *** xinming joined
[01:48] <timotimo> r: sub test { sub foo { CONTROL { say "Inside CONTROL!" }; warn "something"; return "bar" }; say foo(); CONTROL { say "outside control!" } }; test;

[01:48] <camelia> rakudo 8d851b: OUTPUT«Inside CONTROL!␤outside control!␤something  in sub foo at /tmp/j9RkIWYtwk:1␤␤bar␤»

[01:48] <timotimo> seems like return control exceptions don't fire yet?

[01:51] <ruoso> I am slightly confused about how "next/last" is currently implemented. It was my understanding that they would be control exceptions, but there is no QAST nodes that create the CONTROL catching, so next/last are probably just hacked in right now

[01:52] <timotimo> look at MapIter

[01:52] <timotimo> it has an nqp::handle thing for LAST, REDO and NEXT

[01:54] <ruoso> yeah, but that is not what is called from the Actions

[01:54] <timotimo> can you elaborate? if you have a for loop you get a MapIter that gets sunk, don't you?

[01:55] <ruoso> I am looking at Actions.nqp around line 988

[01:55] <ruoso> I don't see MapIter being created at those points

[01:56] <timotimo> did you look at tweak_loop?

[01:57] <timotimo> at least it reacts to NEXT, FIRST and LAST phasers

[01:57] <ruoso> yes, but phasers are a different thing altogether

[01:57] <timotimo> OK

[01:58] <timotimo> well, at least the for loop gets these control exception thingies from a call to "map" which creates a MapIter

[01:58] <ruoso> for instance statement_control:sym<loop> doesn't even mention map, it goes straight for the while op

[01:59] <timotimo> right, i was looking for that op, is that an nqp op?

[01:59] <timotimo> yes, it seems to be 

[02:00] <ruoso> and I only see parrot-specific references to NEXT/LAST as control exceptions in MapIter.pm 

[02:00] <ruoso> (which may explain why it works in parrot and fails in the jvm)

[02:00] <ruoso> r: say gather loop { take 1; last }

[02:00] <camelia> rakudo 8d851b: OUTPUT«1␤»

[02:00] <timotimo> mhm, could be

[02:01] <timotimo> unfortunately i don't know more :(

[02:01] <timotimo> and i'm late for bed yet again ;)

[02:01] <ruoso> :)

[02:01] <timotimo> good luck! and good luck to you too, kriptik 

[02:03] *** ggoebel joined
[02:19] *** xinming left
[02:20] *** xinming joined
[02:25] *** arcterus joined
[02:30] *** ggoebel left
[02:43] <kriptik> thanks timotimo, appreciate your insights, saved me time 

[02:43] *** fred_ joined
[02:43] *** fred_ is now known as Guest5573

[02:44] *** Guest5573 left
[02:47] *** raiph left
[02:54] *** raiph joined
[02:58] *** PacoAir left
[03:07] *** arcterus left
[03:21] *** xinming left
[03:23] *** xinming joined
[03:39] <diakopter> sorear: ping

[03:44] *** preflex_ joined
[03:44] *** ChanServ sets mode: +v preflex_

[03:44] *** preflex left
[03:44] *** preflex_ is now known as preflex

[03:46] *** zacts left
[03:52] <sorear> diakopter: pong

[04:02] *** raiph left
[04:05] *** ivan``_ left
[04:07] *** ivan`` joined
[04:08] *** raiph joined
[04:14] *** ivan`` left
[04:18] <lizmat> good *, #perl6!

[04:19] *** colomon left
[04:25] *** zacts joined
[04:38] *** ivan`` joined
[04:44] *** celesta left
[04:49] *** birdwindupbird joined
[04:52] *** zacts left
[04:56] *** raiph left
[04:58] *** crab2313 joined
[05:02] <moritz> \o *

[05:02] <lizmat> moritz /o!

[05:05] *** arcterus joined
[05:10] *** arcterus left
[05:12] *** dayangkun left
[05:13] <lizmat> colomon: I started integrating Set/Bag changes from Niecza, but am now blocking on naming special operators like ⊆,∈,∋,∪ to texan.  Suggestions?

[05:13] <lizmat> .tell colomon I started integrating Set/Bag changes from Niecza, but am now blocking on naming special operators like ⊆,∈,∋,∪ to texan.  Suggestions?

[05:13] <yoleaux> lizmat: I'll pass your message to colomon.

[05:13] <preflex>  yoleaux: you have 1 new message. '/msg preflex messages' to read it.

[05:15] <JimmyZ> lizmat: you want use E, U temporarily ?

[05:16] <lizmat> well, I could, but what about ∋ ⊆ ∅

[05:16] <lizmat> ø I guess for ∅

[05:16] <lizmat> I mean, is there an official -> texan translation for these ?

[05:16] <lizmat> .u -

[05:16] <yoleaux> U+002D HYPHEN-MINUS [Pd] (-)

[05:17] <lizmat> .u -

[05:17] <yoleaux> U+002D HYPHEN-MINUS [Pd] (-)

[05:18] <JimmyZ> ョ

[05:18] <lizmat> gee, that's a real minus

[05:18] <JimmyZ> ヨ

[05:18] <lizmat> JimmyZ: colomon warned against using any non-texan for these, as it will make parsing the setting 4x as slow

[05:18] <JimmyZ> yes

[05:18] <lizmat> I'm frustrated enough with building a core setting taking 5 minutes or so already

[05:19] *** crab2313 left
[05:20] <JimmyZ> I spent all my time to compile NQP this morning after every small code modification 

[05:20] <JimmyZ> :(

[05:24] *** fridim_ left
[05:25] <lizmat> ok, I was exaggerating: it is real	3m51.304s

[05:26] <JimmyZ> Stage post       : 16101.782

[05:27] <JimmyZ> this one it was when I compile it with 1GB memory 

[05:27] <JimmyZ> on Parrot

[05:28] <lizmat> 4.5 hours ?

[05:28] <lizmat> wow

[05:28] <JimmyZ> yeah

[05:28] <sorear> hey

[05:28] <benabik> 1GB = many swapping

[05:28] <sorear> .c ⊆

[05:28] <yoleaux> sorear: Sorry, no results!

[05:28] <JimmyZ> benabik: yeah

[05:28] <sorear> .u ⊆

[05:28] <yoleaux> U+2286 SUBSET OF OR EQUAL TO [Sm] (⊆)

[05:29] <lizmat> JimmyZ: indeed…  no way to get more memory ?

[05:29] <sorear> does sub infix:["\c[SUBSET OF OR EQUAL TO]"] work ?

[05:29] <sorear> because 1. it should if I'm remembering the spec correctly 2. it will fix the slowness if I'm remembering the etiology correctly

[05:29] <JimmyZ> lizmat: no... I was on linode server

[05:30] <lizmat> $ perl6 -e 'sub infix:["\c[SUBSET OF OR EQUAL TO]"]'

[05:30] <lizmat> ===SORRY!===

[05:30] <lizmat> No such method 'ast' for invocant of type 'NQPMu'

[05:30] <sorear> JimmyZ: that's why I started niecza

[05:30] <lizmat> but that could be because I don't have icu

[05:30] <sorear> could also be the lack of a signature and a body

[05:31] <sorear> r: sub infix:["z"]($x,$y) { say $x };  3 z 4

[05:31] <camelia> rakudo 8d851b: OUTPUT«===SORRY!===␤No such method 'ast' for invocant of type 'NQPMu'␤»

[05:31] <JimmyZ> sorear: :-)

[05:31] <sorear> or, it could be a real bug

[05:31] <sorear> r: sub infix:<<z>>($x,$y) { say $x };  3 z 4

[05:31] <camelia> rakudo 8d851b: OUTPUT«3␤»

[05:31] <sorear> r: sub infix:<<\x2286>>($x,$y) { say $x };  3 ⊆ 4

[05:31] <camelia> rakudo 8d851b: OUTPUT«3␤»

[05:31] <sorear> try that

[05:32] <lizmat> will do

[05:32] <lizmat> $ perl6 -e 'sub infix:<<\x2286>>($x,$y) { say $x };  3 ⊆ 4'

[05:32] <lizmat> ===SORRY!===

[05:32] <lizmat> Two terms in a row

[05:33] <lizmat> infix:<<\x2286>>($x,$y) { say $x };  3 ⏏â

[05:33] <lizmat> hmmmm….

[05:33] <sorear> basically, parsing turns into molasses because the parser does a lot of indexing into strings

[05:33] <sorear> parrot without ICU supports only utf8 and latin1 as encodings

[05:34] <lizmat> I consider it molassy enough as it is

[05:34] <sorear> if you include literal non-latin1 characters in CORE.setting, the setting is a unicode string, and indexing goes quadratic

[05:34] <lizmat> I guess this applies to *any* source code: it's just worse because the setting is so large, right|?

[05:34] <sorear> JimmyZ: you could try the JVM port.  it uses less memory to build.

[05:35] <sorear> lizmat: right

[05:35] <JimmyZ> sorear: I'm waiting for MoarVM :P

[05:36] *** raiph joined
[05:44] *** bluescreen10 left
[05:44] *** iSlug joined
[05:55] <dalek> rakudo/nom: 09953c2 | (Elizabeth Mattijsen)++ | / (4 files):

[05:55] <dalek> rakudo/nom: Give KeySey its own file

[05:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/09953c2fad

[05:56] <lizmat> *KeySet  *sigh*

[06:00] *** iSlug left
[06:02] *** dayangkun joined
[06:18] *** iSlug joined
[06:27] *** FROGGS joined
[06:27] <lizmat> morning FROGGS!

[06:27] <FROGGS> morning lizmat 

[06:35] *** iSlug left
[06:42] <sorear> o/

[06:42] <FROGGS> hi sorear

[06:51] *** kaleem joined
[06:54] *** dmol joined
[06:55] *** arcterus joined
[07:07] *** iSlug joined
[07:10] *** yannickberthoud joined
[07:10] *** iSlug left
[07:15] *** Timbus left
[07:17] *** Timbus joined
[07:21] *** iSlug joined
[07:21] *** yannickberthoud left
[07:24] <lizmat> I thought I'd test how molassy things would get: Stage parse normally around 127 seconds: still waiting after more than 30 minutes now for Stage parse to finish

[07:24] <lizmat> I guess the lack of icu is making things even worse

[07:25] <lizmat> so I would say we're looking at a factor of 15 in my case at least

[07:25] *** iSlug left
[07:25] *** yannickberthoud joined
[07:28] *** woolfy joined
[07:30] *** arcterus left
[07:30] *** yannickberthoud left
[07:30] *** iSlug joined
[07:30] <lizmat> I'll just let it run to see where it ends while cycling&

[07:31] <jnthn> morning, #perl6

[07:34] *** sqirrel joined
[07:37] <jnthn> .tell ruoso the next/last handlers for while loop are emitted as part of code generation, that is a QAST::Op while (and until, repeat_while and repeat_until) gets them "for free". MapIter handles them for for loops and contains a Parrot-specific version as well as a generic version of the looping code that JVM uses.

[07:37] <yoleaux> jnthn: I'll pass your message to ruoso.

[07:40] *** kriptik left
[07:41] <jnthn> r: sub infix:["\x65"]($a, $b) { "$a & $b" }; say 1 A 2

[07:41] <camelia> rakudo 09953c: OUTPUT«===SORRY!===␤No such method 'ast' for invocant of type 'NQPMu'␤»

[07:41] <jnthn> Hmm

[07:42] <jnthn> lizmat: If we can get syntax like infix:["\xAB"] working then we can declare those operators in the setting without them literally appearing, I guess...

[07:42] *** iSlug left
[07:42] *** yannickberthoud joined
[07:45] *** iSlug joined
[07:45] *** yannickberthoud left
[07:52] *** dmol left
[07:52] *** ssutch joined
[07:56] *** leont joined
[08:01] *** iSlug left
[08:26] <sorear> morning jnthn 

[08:27] <jnthn> o/ sorear 

[08:27] <jnthn> Keeping busy?

[08:28] <diakopter> jnthn: actually, the compilation unit also needs collectable too.. 

[08:28] <diakopter> er, ww

[08:30] *** kaleem left
[08:31] <sorear> jnthn: yeah

[08:31] <sorear> finally got a weekend off, too zonked to p6 though

[08:32] <jnthn> *nod*

[08:33] <jnthn> It's important to take some rest too :)

[08:35] *** iSlug joined
[08:37] *** daxim joined
[08:43] *** rindolf joined
[08:43] *** yannickberthoud joined
[08:43] *** iSlug left
[08:46] *** iSlug joined
[08:46] *** yannickberthoud left
[08:50] *** iSlug left
[08:50] *** yannickberthoud joined
[08:59] *** crab2313 joined
[09:04] *** dakkar joined
[09:06] *** yannickberthoud left
[09:09] *** fhelmberger joined
[09:17] *** dmol joined
[09:25] <mathw> morning

[09:25] <mathw> rest? rest? What's that? *twitch*

[09:26] <jnthn> mathw: That thing where you use http

[09:30] <mathw> oh yeah, that

[09:30] <mathw> been reading about that lately, might be writing a restful service in the near future

[09:31] <mathw> I like the idea of actually using all these HTTP methods we usually ignore :)

[09:37] *** Vlavv joined
[09:47] <moritz> mathw: I recently read that if you want to insult a random programmer, you tell him "your API isn't really RESTful!"

[09:48] <mathw> I'm not sure that works... what if htey weren't trying to write a RESTful API?

[09:48] <mathw> I'm pretty sure a lot of people out there don't actually care

[09:49] <mathw> I mean, if people really cared about that kind of thing they wouldn't be so keen to write things in JavaScript, surely?

[09:50] <mathw> (false association for a Monday morning, woohoo!)

[09:51] <moritz> mathw: you keep saying that, but I don't believe you, since your API isn't RESTful!!!! :-)

[09:52] <mathw> actually, Form.pm's API is entirely stateless and it's pure, too

[09:52] <mathw> so naaaaaaaah

[09:53] <jnthn> People tend to use REST to mean a bunch of different things :)

[09:55] <moritz> mathw: it doesn't use HTTP, so it can't be RESTful :-)

[09:55] *** iSlug joined
[09:55] <jnthn> .oO( Any sufficiently adopted term will be misused sufficiently that it becomes useless for precisely describing anything )

[09:55] <moritz> mathw: and it's not in CLOUD either !!!

[09:57] *** arcterus joined
[09:59] *** iSlug left
[09:59] *** crab2313 left
[10:00] *** iSlug joined
[10:01] *** arcterus left
[10:06] *** iSlug left
[10:06] *** yannickberthoud joined
[10:07] <mathw> All our problems can be solved by putting it in the cloud.

[10:07] <mathw> I'm even putting my internet connection in the cloud, so I can access it from everywhere

[10:08] <moritz> sounds legit.

[10:10] *** yannickberthoud left
[10:10] <mathw> Absolutely

[10:10] <mathw> jnthn: I agree, especially if it's something to do with the internet

[10:13] *** iSlug joined
[10:15] *** yannickberthoud joined
[10:15] *** iSlug left
[10:15] *** raiph left
[10:20] *** iSlug joined
[10:20] *** yannickberthoud left
[10:22] *** rindolf left
[10:25] *** yannickberthoud joined
[10:25] *** iSlug left
[10:28] *** ssutch left
[10:30] *** yannickberthoud left
[10:38] <mathw> yay for unit tests!

[10:38] * mathw completes the first stage of a behaviour change: break the unit tests

[10:38] <mathw> or rather, adjust the unit tests to expect the new, correct, behaviour

[10:44] *** flussence_ joined
[10:45] *** japhb_ left
[10:45] *** pecastro left
[10:45] *** pecastro joined
[10:46] *** japhb_ joined
[10:48] *** kaleem joined
[10:59] <mathw> I'm really liking test-driven stuff. It's great gradually turning all those red failure markers into success markers :)

[11:00] <FROGGS> right, that is very satisfying

[11:02] <mathw> The trick then becomes being sure you've got a comprehensive test suite, so when it's all green you know you're done

[11:02] *** Rotwang joined
[11:02] *** dayangkun left
[11:03] <FROGGS> troo

[11:03] <timotimo> there should be a test that tells you if the test suite is good enough

[11:03] <mathw> why not solve the halting problem while you're at it?

[11:03] <FROGGS> and you must keep in mind that you probably never have a comprehensive test suite :o)

[11:04] <moritz> it's pretty much a question of experience

[11:04] <moritz> when you work with a codebase for a while, you learn how much to (not) rely on its test suite

[11:07] <timotimo> tadzik: i was thinking the other day: if a user wants to put multiple spaces into table cells, all they need to do is make a table header that explicitly sets the cell widths.

[11:07] *** crab2313 joined
[11:08] <tadzik> timotimo: or maybe they should just use |

[11:13] <timotimo> both things would probably end up using the same code (that i still need to write, mind you)

[11:14] <timotimo> last night while i lay awake thinking about rakudo, i had the crazy idea that pruning away match objects in the perl6 grammar could speed up parsing because it would relieve pressure off the GC

[11:16] *** PacoLinux joined
[11:21] <timotimo> so maybe today i'll write up a quick and dirty .prune for NQPMatch or what it's called and see if it reduces the peak memory usage noticably and if it decreases parse time at all

[11:25] <moritz> interesting idea

[11:25] <timotimo> sometimes in my pre-sleep lunacies i get desparate for that rakudo performance :P

[11:27] <timotimo> oh, i just noticed this hasn't been reviewed yet, should be straight-forward: https://github.com/rakudo/rakudo/pull/189/files

[11:30] <dalek> rakudo/nom: e8320df | (Timo Paulssen)++ | src/Perl6/Actions.nqp:

[11:30] <dalek> rakudo/nom: make sure that tabs in heredocs get properly dedented.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e8320df5fe

[11:30] <dalek> rakudo/nom: 3340362 | moritz++ | src/Perl6/Actions.nqp:

[11:30] <dalek> rakudo/nom: Merge pull request #189 from timo/heredoc_tabs

[11:30] <dalek> rakudo/nom: 

[11:30] <dalek> rakudo/nom: make sure that tabs in heredocs get properly dedented.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33403622a6

[11:30] <timotimo> appreciate it :)

[11:30] * moritz too

[11:35] <timotimo> i can use "self" in an nqp class, right?

[11:35] <timotimo> oh, i may not even have to, though

[11:35] *** mtk left
[11:35] <moritz> method prune() { @!array := nqp::list(); %!hash := nqp::hash(); }

[11:35] <moritz> :-)

[11:36] <timotimo> well, @!array and %!hash are defined to be in NQPCapture, not in NQPMatch and i was writing the method for the latter

[11:36] *** nyuszika7h is now known as vimperator

[11:36] *** vimperator is now known as nyuszika7h

[11:37] <moritz> er, right

[11:37] <timotimo> so i was using nqp::bindattr for that

[11:37] *** mtk joined
[11:37] <timotimo> also, i thought it would be important to $!cursor := Nil, too

[11:39] <FROGGS> is Nil available there?

[11:39] <moritz> NQPMu is

[11:40] <moritz> now the realy interesting question is: where to call $/.prune?

[11:40] <timotimo> good

[11:41] <timotimo> i'd sprinkle calls to $/.prune into action methods in Grammar.nqp in rakudo as i see fit and try not to make it explode :)

[11:41] <timotimo> hoping it'll explode during setting compile if i make a mistake ;)

[11:44] <moritz> I'd thought the .prune() calls go into Actions

[11:45] *** hanekomu left
[11:45] <timotimo> er, yes, of course

[11:45] <timotimo> "action methods in grammar.nqp" doesn't make a whole lot of sense

[11:46] <moritz> (because if we don't need the captures at all, we can use non-capturing calls in the first place)

[11:46] *** PacoLinux left
[11:46] <timotimo> exactly, the prune goes after the action has done enough with it to create an .ast

[11:47] *** PacoLinux joined
[11:55] *** colomon joined
[12:03] <lizmat> timotimo: there should be a test that tells you if the test suite is good enough"  There is for Perl 5: it's called Devel::Cover::Test, part of the Devel::Cover distribution, see: https://metacpan.org/release/Devel-Cover

[12:05] *** crab2313 left
[12:07] <timotimo> right. good luck with that for a test suite like roast, though :(

[12:07] *** Rotwang left
[12:07] <timotimo> .o( timotimo—— for moving the goalpost )

[12:10] *** skids left
[12:12] <lizmat> actually, I think rakudo is much better suited to be able to do this than Perl 5, judging from jnthn's work on the debugger

[12:13] <timotimo> oh; well for code coverage maybe; but concept coverage is not doable :P

[12:14] *** fridim_ joined
[12:14] <lizmat> troo

[12:15] <timotimo> about to test prune vs. no-prune.

[12:15] <jnthn> A coverage tool may not be too hard to hack together a first cut of.

[12:19] *** fridim_ left
[12:22] *** mucker joined
[12:22] <timotimo> hrmpf. time spent parsing is about the same

[12:24] <timotimo> maxresident went down by like 8% or so

[12:24] <timotimo> from 1656512k to 1587572

[12:24] <timotimo> ah. more like 4%

[12:25] <timotimo> so the effort wasn't worth it at all. but a negative result is a result nonetheless. just means that the hashes and lists in our match objects don't take up crazy much space (or clearing them out along with the cursor doesn't lead to sufficient amounts of memory being freed, your pick)

[12:25] <timotimo> i *could* still try it on jvm, though

[12:26] <mathw> that might be interesting

[12:26] <mathw> you know you want to

[12:26] *** domidumont joined
[12:26] <timotimo> i'm already doing it

[12:27] <timotimo> though since the gc is already concurrent, i don't think relieving GC pressure by removing the match objects will make a difference in time used

[12:28] <timotimo> and the jvm memory usage pattern is also not as easy to inspect just with /bin/time

[12:28] *** domidumont left
[12:28] *** domidumont joined
[12:28] <timotimo> hm, maybe bindattr'ing nqp::list() and nqp::hash() was a bad choice and i should have used NQPMu instead. i can still try that.

[12:29] <jnthn> yes, it would allocate a new list and hash...

[12:29] <timotimo> oh the things you do when you don't think it through ...

[12:30] *** daxim left
[12:30] *** hoelzro left
[12:30] <mathw> We've all been there...

[12:30] *** daxim joined
[12:30] *** hoelzro joined
[12:36] <timotimo> oh, wow! that ... changed absolutely nothing :|

[12:37] <FROGGS> >.<

[12:37] <timotimo> i guess that just means that nqp::list() and nqp::hash() are pretty fast?

[12:41] <timotimo> and now: misspelling =time make as just =make

[12:42] <tadzik> and now, the conclusion

[12:42] <[Coke]> "previously.... on #perl6"

[12:43] <moritz> timotimo: where did you add the $/.prune() calls? (which methods)?

[12:44] <timotimo> hm, what's the easiest way to collate that?

[12:44] <timotimo> in 33 places, if that helps?

[12:45] *** crab2313 joined
[12:45] <timotimo> well, the memory savings are pretty much nonexistent; at least nothing spectacular shows up in the maxresident piece of the readout of time.

[12:45] <timotimo> and the compilation speed doesn't seem to change either

[12:46] <moritz> one nastiness is that nqp::list and nqp::hash themselves allocate new objects

[12:46] <moritz> I wonder if we should bind NQPMu instead

[12:46] <timotimo> well, i replaced that with NQPMu already, so that's not it

[12:46] *** domidumont1 joined
[12:46] <moritz> ok

[12:46] <moritz> did you add the .prune() to all the literals?

[12:47] <moritz> like quibbler and numish etc.

[12:47] <timotimo> i just put $/.prune at the end of many methods. not to those, though

[12:47] <timotimo> quibble could be a good idea indeed.

[12:49] <moritz> and fwiw the GC isn't concurrent on parrot

[12:49] <timotimo> yes, that part above was refering to trying it on the jvm

[12:49] *** crab2313_ joined
[12:49] *** crab2313_ left
[12:49] *** domidumont left
[12:50] <moritz> ah

[12:51] <timotimo> when passing :node to a QAST::Op, will that make a copy?

[12:53] <FROGGS>     method node(*@value)       { $!node := @value[0] if @value; $!node }

[12:53] <FROGGS> I think not because it does a bind, right?

[12:54] <timotimo> is that what gets called?

[12:54] <FROGGS> yes

[12:54] <timotimo> in that case, it shouldn't copy

[12:54] <FROGGS> nqp/src/QAST/Node.nqp:22:    method node(*@value)       { $!node := @value[0] if @value; $!node }

[12:54] *** domidumont1 left
[12:55] *** domidumont joined
[12:58] <timotimo> it seems like i put too much pruning in there now.

[12:58] <timotimo> EXPR_reduce in NQPHLL is complaining

[12:59] *** arcterus joined
[12:59] <jnthn> Note that if $!node holds a reference to a match object, which in turns holds a reference to a cursor, then they ain't gonna go away when pruning as they are still referenced.

[13:01] <moritz> jnthn: that's why NQPMatch.prune assigns NQPMu to $!cursor

[13:02] <jnthn> ah, ok

[13:02] <jnthn> Note that a more conservative thing to do may be to clear $!cstack inside of CAPHASH iff $!bstack is null

[13:03] <jnthn> (if $!bstack is null and since match objects are cached, $!cstack will be unrequired beyond that point)

[13:03] <jnthn> Note that this may already be done :)

[13:03] *** arcterus left
[13:03] <timotimo> i'll have a quick look

[13:05] *** PacoLinux left
[13:06] <timotimo> that is currently not being done

[13:06] *** imarcusthis- left
[13:08] <jnthn> It's probably a reasonable thing to do.

[13:08] <FROGGS> jnthn: tell us more :o)

[13:08] <timotimo> i've added it, i can commit it later. should prune make it into nqp/master?

[13:10] <jnthn> timotimo: Not sure about that one yet.

[13:11] <jnthn> timotimo: But the $!cstack throwing away is probably worth a spectest :)

[13:11] <timotimo> will do

[13:13] *** konundra joined
[13:14] *** xinming left
[13:16] *** xinming joined
[13:17] *** domidumont left
[13:19] *** pmurias joined
[13:19] <pmurias> jnthn: did you find the problem ruoso was having with --target=ast?

[13:20] <jnthn> pmurias: I patched QAST::BVal to not explode, yes.

[13:21] <pmurias> good

[13:21] <pmurias> being able to look at the ast is really important for new developers

[13:21] <jnthn> *nod*

[13:22] <jnthn> Wonder if we should somehow try to test it somewhere...at least test it won't explode.

[13:27] <mathw> 'not exploding' is a good first step for testing

[13:27] <mathw> the great thing about software is that we can catch explosions without expensive repair work required afterwards

[13:27] <frettled> unless it's controller software for a sentrifuge ;)

[13:28] <pmurias> jnthn: I have a start of a unit tests for QAST, https://github.com/pmurias/rakudo-js/blob/master/t/qast-node.t

[13:29] *** xinming left
[13:30] <pmurias> jnthn: I thought about testing --target=ast but wasn't sure we want to hardcode the exact format into the tests

[13:31] *** xinming joined
[13:31] <jnthn> We shouldn't test the exact contents, no

[13:31] <jnthn> But we can look for some obviousthings

[13:31] <jnthn> like "if I call a function elephant, does the word elephant appear in the dump output"

[13:31] <jnthn> I'd test $somenode.dump really, not --target=ast itself.

[13:32] <jnthn> r: sub elephant() { }; elegant

[13:32] <camelia> rakudo 334036: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    elegant used at line 1. Did you mean '&elephant'?␤␤»

[13:32] <jnthn> :D

[13:32] <tadzik> that's irrelephant

[13:32] <FROGGS> >.o

[13:33] <jnthn> I want to think of a better pun than that, but I can't trumpet

[13:33] <pmurias> nqp --help was broken untill recently so we should test that too ;)

[13:33] <FROGGS> why not... testing the command line arguments for sanity isnt soo bad

[13:36] <[Coke]> do the tests for nqp get run as part of a rakudo build?

[13:37] <[Coke]> (IFF nqp had to be built as part of the build for rakudo)

[13:37] <pmurias> we could have some rought sanity checks for command line arguments and unit tests for the trickier dump methods

[13:38] <FROGGS> [Coke]: no, dont think so

[13:45] <timotimo> spectests are about to finish

[13:45] *** rindolf joined
[13:46] <timotimo> try.rakudo.parrot is b0rked, no tests run

[13:46] *** btyler joined
[13:46] <timotimo> documentation/why.t failed one, but i think that file is dirty locally

[13:46] <timotimo> IO-Socket-INET fails 7 of 41, i suppose that's known?

[13:47] <[Coke]> timotimo: https://github.com/coke/perl6-roast-data/blob/master/rakudo_summary.out#L2477

[13:47] <[Coke]> they have been failing for some time.

[13:47] <[Coke]> :(

[13:48] <jnthn> timotimo: How does the try one fail?

[13:49] <timotimo> one prune too many :)

[13:49] <jnthn> Too many prunes always lead to crap...

[13:52] <timotimo> yeah. i'm thinking of leaving the prune stuff out completely now. doesn't seem to have any benefits.

[13:53] <timotimo> but i'll stash it away in a branch and put it up on github because maybe one day someone finds out what's wrong with my approach and does the obvious one-line-fix and makes it all much better :)

[14:01] <timotimo> clearing the cstack doesn't seem to affect parse time btw

[14:02] <jnthn> I didn't expect it'd help time, but it should allow less memory usage.

[14:02] <timotimo> i will need to check that

[14:02] <timotimo> at least try now works :)

[14:06] <timotimo> barely a difference in maxresident

[14:14] *** PacoLinux joined
[14:15] *** kaare_ joined
[14:24] *** sqirrel left
[14:33] *** kaleem left
[14:40] *** cognominal left
[14:41] *** Psyche^_ left
[14:41] *** cognominal joined
[14:42] *** Psyche^ joined
[14:49] *** anuby_h joined
[14:50] *** skids joined
[14:50] *** xinming left
[14:52] *** xinming joined
[14:53] *** crab2313 left
[14:53] *** BenGoldberg joined
[14:54] *** rindolf left
[14:56] *** domidumont joined
[15:00] *** rindolf joined
[15:05] *** PacoLinux left
[15:07] <daxim> when is nqp/rakudo 2013.08 scheduled for release?

[15:08] *** rindolf left
[15:08] *** domidumont left
[15:08] <FROGGS> daxim:  2013-08-22   Rakudo #67                      moritz

[15:08] <FROGGS> https://github.com/rakudo/rakudo/blob/nom/docs/release_guide.pod

[15:08] <daxim> och

[15:11] *** PacoLinux joined
[15:19] *** atrodo left
[15:19] *** birdwindupbird left
[15:21] *** atrodo joined
[15:25] * jnthn grabs his Perl 6 tuits

[15:25] <mathw> I didn't see the 'u' in that for a moment

[15:25] <jnthn> o.O

[15:25] <jnthn> What are you used to reading?! :P

[15:26] <mathw> I think I spent too long in the pub on Saturday

[15:26] <mathw> with a bunch of martial artists

[15:27] <mathw> I do value our traditions of training, but I'm not sure we need to preserve the one about getting really really drunk afterwards

[15:27] <slava> jnthn: that was an awesome talk on the perl6 debugger (I think it was you), also, epic beard :D

[15:28] <slava> mathw: shush, that is the important part

[15:28] <jnthn> slava: I'm probably to blame for debugger talks, yes. :)

[15:28] <moritz> speaking of talks, I have a distinct lack of slides so far.

[15:28] <slava> jnthn: your beard is how I know perl6 will be alright :)

[15:28] <diakopter> marshal autists

[15:30] <jnthn> moritz: Erm, me too, and I have 3 talks O.O

[15:30] *** rindolf joined
[15:30] <jnthn> slava: I guess I better keep it then... :P

[15:30] * jnthn is happy of it most of the time, except in these summer temperatures... :)

[15:31] * mathw shaved off most of his hair a couple of weeks ago

[15:31] <slava> yes

[15:31] <slava> http://www.wired.com/wiredenterprise/2012/06/beard-gallery/

[15:32] <mathw> it seemed prudent, as I was contemplating four days of aikido in a place with no air conditioning and generally poor ventilation when it's reaching 30C outside

[15:32] <diakopter> slava: yes, but jnthn's 1/3-1/2 their ages :)

[15:33] <mathw> nothing wrong with starting early

[15:33] <slava> diakopter: so perl6 will be even mroe awesome :)

[15:34] <mathw> don't forget the important contribution of $larry's moustache

[15:34] <slava> mathw: that goes without saying, IMO

[15:34] <slava> I can't wait for a Perl6 book to come out so I can bug everyone at YAPC :P

[15:36] *** rindolf left
[15:36] <timotimo> bug them for signatures?

[15:37] <jnthn> .oO( camelia them for signatures? )

[15:37] <PerlJam> slava: A Perl 6 book has already come out  :)

[15:37] * mathw makes note: make camelia costume

[15:37] <slava> err, when?! :(

[15:37] <slava> I am so behind :(

[15:38] * mathw makes a better note: persuade friends more talented in textiles to make camelia costume for him

[15:38] <PerlJam> slava: I'm teasing somewhat.  But there's "Using Perl 6" and the much older "Perl 6 and Parrot Essentials"

[15:38] <timotimo> wow

[15:39] <timotimo> PerlJam: the state of the "perl6 book", at least the one that's on perl6/book, isn't really that amazing yet

[15:39] <moritz> and it won't become amazing, because work on it has ceased

[15:39] <PerlJam> indeed

[15:39] <PerlJam> :(

[15:39] <moritz> I've tried to put the stuff into perl6/doc instead

[15:39] <moritz> and improve it there

[15:40] <moritz> but it's a lonely quest, and I'm not good at sustaining such efforts alone

[15:40] <moritz> std: 1 1

[15:40] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/unf45YRB4C line 1:␤------> [32m1 [33m⏏[31m1[0m␤    expecting any of:␤ feed_separator␤ infix or meta-infix␤    infixed function␤       statement modifier loop␤Parse failed␤FAILED 00:00 42m␤»

[15:40] * moritz tries to get the file name in there

[15:42] *** dmol left
[15:42] *** konundra left
[15:43] *** FROGGS left
[15:45] <moritz> I'm not too happy with the way STD does it

[15:46] *** btyler left
[15:47] <lizmat> timotimo:  "IO-Socket-INET fails 7 of 41, i suppose that's known?" Yes, I put them there, because the test seems to work out ok, but at the expense of 7 x 20 second timeouts

[15:47] <lizmat> not sure yet if it is the general socket code that's to blame, or the test setup, but something is seriously wrong there

[15:48] <lizmat> each test is not also tested for the time it took: if it is more than 5 seconds, it will fail

[15:48] <timotimo> righto

[15:48] <lizmat> all of these failures are at 20 seconds

[15:48] <lizmat> if these are fixed, doing a spectest will be at least 1 minute shorter in wallclock when doing a parallel test

[15:49] <lizmat> and 2.5 minutes when doing a non-parallel test

[15:50] <timotimo> ... oh no

[15:50] <timotimo> i think i lost the only good copy of rakudo_optimiser_transformer.p6

[15:50] <timotimo> how am i going to rapid-prototype my stuff now? ;_;

[15:50] *** btyler joined
[15:50] <moritz> because rakudo batches several error in one message, so with the current format the file name is repeated for every routine

[15:53] <moritz> how would you like it if we changed it  ===SORRY!==== Error while compiling $file\n

[15:53] <moritz> and then the rest of the message as is, without the file names?

[15:57] <moritz> dammit, I wanted to make slides, now I'm hacking rakudo again

[15:58] <timotimo> :D

[15:59] <jnthn> moritz: CDD :P

[16:01] <timotimo> so when i have a QAST::Var, i can search through the lexpads; is there a central place where i should look to find out what kinds of things are stored in there for variables? like type constraints and such?

[16:02] *** daxim left
[16:02] <moritz> nr: say Bool.pick

[16:02] <camelia> rakudo 334036: OUTPUT«False␤»

[16:02] <camelia> ..niecza v24-88-g1f87209: OUTPUT«True␤»

[16:04] <lizmat> r: say Int.pick

[16:04] <camelia> rakudo 334036: OUTPUT«Nil␤»

[16:04] <lizmat> hmmm...

[16:05] <timotimo> kind of hard to pick from the range of all BigInts :P

[16:07] <timotimo> ah, that's how; lexpad.symbol("name")<type> will be ... a thing

[16:08] <benabik> r: Bool ~~ Enum

[16:08] <camelia> rakudo 334036:  ( no output )

[16:08] <benabik> r: say Bool ~~ Enum

[16:08] <camelia> rakudo 334036: OUTPUT«False␤»

[16:08] <timotimo> r: say Bool.^mro

[16:08] <camelia> rakudo 334036: OUTPUT«(Bool) (Cool) (Any) (Mu)␤»

[16:08] <benabik> I keep wanting camelia to output the result if there's no other output.

[16:09] <jnthn> benabik: I think we had it that way once and it was just differently confusing :)

[16:09] <benabik> jnthn: Ah, but it would less confusing for *me*, you see.  ;-)

[16:09] *** anuby_h left
[16:09] *** PacoLinux left
[16:09] <benabik> Ah.  .pick and .roll are simply implemented special for Bool.

[16:09] *** FROGGS joined
[16:11] <benabik> Ah, sorry I expected it to be an EnumMap not an Enum.  But EnumMap doesn't seem to have .pick either?  Eh.

[16:12] *** PacoLinux joined
[16:13] *** pmurias left
[16:19] <moritz> r: say %*ENV.pick.perl

[16:19] <camelia> rakudo 334036: OUTPUT«"PERLBREW_HOME" => "/home/p6eval/.perlbrew"␤»

[16:23] * jnthn wonders why on earth some seemingly innocent changes break the Rakudo on Parrot build

[16:25] *** fhelmberger left
[16:25] <timotimo> r: my $foo where * > 10 = 20;

[16:25] <camelia> rakudo 334036:  ( no output )

[16:25] * timotimo can't seem to find the code in actions that handles the "where" clause in token type_constraint :|

[16:25] <timotimo> or is that rule post_constraint?

[16:26] <jnthn> It's post_ there ain't it?

[16:26] <timotimo> that seems to be for parameters, though. or is that the same?

[16:26] * jnthn sees a method post_constraint

[16:26] <timotimo> oh

[16:26] <jnthn> oh...

[16:26] <jnthn> hmm

[16:26] <timotimo> it does at least handle a where block

[16:26] <jnthn> I didn't even know you could write that :P

[16:26] <timotimo> r: my $foo where * > 10 = 5;

[16:26] <camelia> rakudo 334036:  ( no output )

[16:27] <timotimo> oh ... well :)

[16:27] <timotimo> r: my ($foo where * > 10) = 5;

[16:27] <camelia> rakudo 334036:  ( no output )

[16:27] <timotimo> r: my ($foo where * > 10); $foo = 5;

[16:27] <camelia> rakudo 334036:  ( no output )

[16:27] <timotimo> doesn't seem very effective so far.

[16:28] <jnthn> Right :)

[16:28] <jnthn> Maybe it's NYI :)

[16:28] <timotimo> r: sub Foo returns Int where * > 10 { 5 }; Foo;

[16:28] <camelia> rakudo 334036: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/9aUIcATTe8:1␤------> [32msub Foo returns Int [33m⏏[31mwhere * > 10 { 5 }; Foo;[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be defin…

[16:28] <timotimo> r: sub Foo returns (Int where * > 10) { 5 }; Foo;

[16:28] <camelia> rakudo 334036: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/ErDJ8cIxxE:1␤------> [32msub Foo returns [33m⏏[31m(Int where * > 10) { 5 }; Foo;[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be def…

[16:28] *** rindolf joined
[16:28] <timotimo> r: sub Foo(--> Int where * > 10) { 5 }; Foo;

[16:28] <camelia> rakudo 334036: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/2SnkNntE9f:1␤------> [32msub Foo(--> Int [33m⏏[31mwhere * > 10) { 5 }; Foo;[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be defined␤…

[16:29] <timotimo> mhm.

[16:29] <timotimo> anyway, i'll go have a bit of balconytime :3

[16:34] *** dmol joined
[16:37] *** PacoLinux left
[16:38] *** PacoLinux joined
[16:52] *** vk_ joined
[16:52] *** benabik left
[16:56] <masak> oh hai, #perl6

[16:56] <lizmat> masak!

[16:57] <jnthn> evening, masak o/

[16:57] <lizmat> fwiw, I retried compiling the setting with a single line of "# ⊆" added to the prologue

[16:57] <lizmat> stage parse went from 127 seconds to 3400 seconds

[16:57] <jnthn> o.O

[16:57] <jnthn> lizmat: Did you see my workaround suggestion?

[16:58] <lizmat> that's about 26 times slower

[16:58] <lizmat> jnthn: not yet, after cycling I had to catch up on some sleep and email  :-)

[16:58] <jnthn> k :)

[16:58] <lizmat> going to run a spectest with the resulting setting, see if there are any differences there

[16:59] <lizmat> won't be able to do much more until much later this evening

[16:59] *** zwut00 joined
[17:00] <pmichaud> yeah, we really need to fix the string handling and utf8 stuff in the regex engine :-/

[17:00] <jnthn> I don't think the problem exists on JVM

[17:00] <pmichaud> I'm sad I haven't had time to do that yet.  Lots of lost time and opportunity in there.

[17:00] <pmichaud> I hope it doesn't exist on JVM :)

[17:00] <jnthn> Of course, we have OTHER problems with strings on the JVM :D

[17:00] <lizmat> pmichaud!

[17:00] <pmichaud> if it was a problem on the jvm I'd be even more sad.

[17:01] <jnthn> And Moar is NFG (or an approximation thereof so far...) so it's all fixed width.

[17:01] <lizmat> result of make: real	63m10.308s, user	63m6.534s, sys	0m3.673s

[17:01] <pmichaud> \o/

[17:02] <lizmat> I would say, about 12 times slower in total

[17:05] <diakopter> wow

[17:08] <lizmat> and that by adding a single line of comment with a non-ascii character  :-)

[17:09] <diakopter> what if you add it at the end

[17:10] <lizmat> I'll try that later, just for reference

[17:10] <lizmat> spectest comes out ok, without a timing difference

[17:11] <timotimo> is there a good short way to print out everything in an nqp::hash?

[17:11] *** spider-mario joined
[17:11] <jnthn> timotimo: in nqp?

[17:11] <timotimo> yes

[17:11] <lizmat> make is running, I'll check back in 30 mins or so, afk&

[17:12] <jnthn> for %h { say($_.key ~ ' = ' $_.value) }

[17:12] <jnthn> ? :)

[17:12] <timotimo> oh that's surprisingly easy

[17:12] *** preflex left
[17:12] <FROGGS> jnthn / timotimo: can't we make a gist/DUMP method for hashes in nqp?

[17:12] *** preflex_ joined
[17:12] *** ChanServ sets mode: +v preflex_

[17:13] *** preflex_ is now known as preflex

[17:13] *** domidumont joined
[17:13] <[Coke]> r: say 3400/127

[17:13] <camelia> rakudo 334036: OUTPUT«26.771654␤»

[17:14] <pmichaud> I'm afk

[17:15] <timotimo> i fear i'll run into a few unstringifyables

[17:15] *** konundra joined
[17:16] *** dakkar left
[17:16] <moritz> is that, like, unspeakables?

[17:16] <FROGGS> meh

[17:16] * FROGGS wanted to make a "lost for words" joke

[17:16] <timotimo> yeah, in this case i got a null pmc access :)

[17:17] <timotimo> there's nqp::isstr, right?

[17:17] <FROGGS> nqp: say(nqp::isstr("hello"))

[17:17] <camelia> nqp: OUTPUT«1␤»

[17:17] <FROGGS> seems like

[17:17] <timotimo> right, i could have totally checked that here :S

[17:18] *** Ben_Goldberg joined
[17:18] <FROGGS> :P

[17:18] *** flussence_ is now known as flussence

[17:18] <timotimo> currently trying to replace a couple of p6store ops with p6storeunchecked (which i had to freshly map)

[17:19] *** btyler left
[17:19] * moritz tries to give compile-time errors with ===SORRY!=== the file name

[17:19] *** mucker left
[17:20] *** BenGoldberg left
[17:21] *** domidumont left
[17:22] <timotimo> so, in a my Int $foo, the lexpad entry will have a .<descriptor> and that's a ContainerDescriptor and its .of will be the Int type object?

[17:22] <timotimo> kind of seems like

[17:22] *** domidumont joined
[17:25] <FROGGS> r: sub test(*@s is rw) { for @s -> $s is rw { $s = 1} }; my %h = a => 1; for %h.keys { test($_) }; say %h

[17:25] <camelia> rakudo 334036: OUTPUT«Cannot modify an immutable value␤  in sub test at /tmp/8U83bCPD34:1␤  in block  at /tmp/8U83bCPD34:1␤␤»

[17:25] <jnthn> timotimo: Somethin glike that, yes

[17:25] <FROGGS> jnthn: your commit 787295d0d2ea732e1a716795c5f3a150885f8346 changed the behaviour of the code above ^^

[17:25] <FROGGS> was that intended?

[17:26] <FROGGS> (it wasn't dying before)

[17:26] <jnthn> huh...the change mostly made code like that *not* die.

[17:26] <jnthn> We untodo'd a bunch of related tests.

[17:27] <FROGGS> star: sub test(*@s is rw) { for @s -> $s is rw { $s = 1} }; my %h = a => 1; for %h.keys { test($_) }; say %h

[17:27] <camelia> star 2013.02: OUTPUT«("a" => 1).hash␤»

[17:27] <FROGGS> see -------------------------^ ó.ò

[17:27] <jnthn> Um

[17:27] <jnthn> oh, .keys

[17:27] <jnthn> wtf 

[17:27] <FROGGS> yeah

[17:27] <jnthn> That doesn't even make any sense.

[17:27] <jnthn> I'm glad it dies now :P

[17:28] <jnthn> How on earth did it work before, anyways? :)

[17:28] <FROGGS> yeah, just wanted to make sure that my v5 code needs changing :o)

[17:28] <timotimo> magic & unicode farts

[17:28] <FROGGS> farts mostly

[17:28] * FROGGS giggles

[17:28] <timotimo> did i write unicode? i meant unicorn.

[17:28] <FROGGS> hehe

[17:28] <timotimo> i don't think there's a unicode fart emoticon

[17:28] <jnthn> I'm sure Unicode probably does have a char for fart :P

[17:28] <FROGGS> that makes it even more funny :P

[17:28] <timotimo> although that would be so cool

[17:28] <jnthn> It has pile of poo :P

[17:29] <FROGGS> .u fart

[17:29] <yoleaux> No characters found

[17:29] <timotimo> if i could use it in identifiers ... :D

[17:29] <FROGGS> meh

[17:30] <timotimo> if i have a container descriptor that has an rw of 1 and an of of Mu, can i turn any p6store into a p6storeunchecked automatically?

[17:30] <timotimo> although how often does that happen. what about Mu?

[17:30] <diakopter> .u 5c41

[17:30] <yoleaux> No characters found

[17:30] <timotimo> (i'm only looking at p6store Var, Var right now, though

[17:30] <jnthn> timotimo: Yes, you probably can

[17:30] <diakopter> aww, it doesn't have 5c41

[17:30] <jnthn> If you're doing it in the optimizer

[17:31] <timotimo> i'll hopefully be able to put Var + typechecked return value into the same optimisation thing right after that

[17:31] <timotimo> yes, this is all in the optimizer

[17:31] <jnthn> dinner, bbiab

[17:33] <timotimo> hm, is the correct check nqp::istype($desc.of, $!Mu) or is it $desc.of =:= $!Mu?

[17:35] <diakopter> .u 1f4a8

[17:35] <yoleaux> U+1F4A8 DASH SYMBOL [So] (💨)

[17:36] <diakopter> .ask dpk which unicode version does yoleaux have for .u ?

[17:36] <yoleaux> diakopter: I'll pass your message to dpk.

[17:40] *** PacoLinux left
[17:40] *** btyler joined
[17:42] <timotimo> nqp: say(NQPMu =:= NQPMu);

[17:42] <camelia> nqp: OUTPUT«1␤»

[17:42] *** araujo left
[17:44] <timotimo> oh yikes, i get so much "turning it unchecked" output from compiling the setting

[17:44] <timotimo> i'm sure it's super broken now :D

[17:45] *** ssutch joined
[17:46] <timotimo> haha, yes, i think nqp::istype(something, $!Mu) is pretty dumb :)

[17:52] <[Coke]> masak: http://alloveralbany.com/images/northshire_bookstore_saratoga13.jpg (this place is opening soon relatively near me)

[17:52] <timotimo> '"nothing is written in stone" is written in stone' it should say

[17:54] <timotimo> i can't tell how to check if the types match; =:= doesn't trigger on Int, Int apparently, and eqv isn't in nqp

[17:54] <timotimo> perhaps i can istype that?

[17:54] *** lue left
[17:56] <masak> [Coke]: :D

[17:56] <masak> [Coke]: notice also that the book in the window almost says... "FROGGS" o.O

[17:57] <[Coke]> masak: I pretty much have to go patronize their shop now!

[17:57] <timotimo> my code turned 3 p6store into p6storeunchecked based on matching descriptor .of types

[17:58] <PerlJam> masak: I think you're imagining things ... the book says "FROGS", not "FROGGS"  :)

[17:58] <masak> PerlJam: hence "almost" :)

[17:58] <timotimo> cool, that seems like it kinda works

[17:58] <FROGGS> :o)

[17:59] <timotimo> i hope the spectest harness isn't confused by the mass amount of debug output

[18:00] <masak> [Coke]: there's a strain of self-defeating autopuns like that, which are simply a consequence of people not thinking things through. I don't like them at all. but this one is kinda funny because it's so deliberate.

[18:00] <PerlJam> timotimo: It should be  ``"nothing" is written in stone''  :-)   Classic use/mention dichotomy :)

[18:00] <masak> PerlJam: that would be funny, too. but not an autopun.

[18:00] <PerlJam> yep

[18:00] * masak .oO( "this" is not a pipe )

[18:01] * masak .oO( you think that's "air" you're breathing? )

[18:01] *** arcterus joined
[18:01] <timotimo> i do get a bunch of spectest fails

[18:02] <PerlJam> Coke: that setting looks fairly permanent.  Perhaps suggest to them that they could swap out the saying every once in a while  :)

[18:02] * FROGGS .oO( employees must "wash hands" )

[18:03] *** wtw joined
[18:05] *** arcterus left
[18:05] <timotimo> i had kind of hoped i could just make it work no-prob, but no ... :(

[18:06] *** lue joined
[18:08] *** zby_home joined
[18:08] <FROGGS> r: { try die "huhu"; CATCH { $! = "42" } }; say $! # how can I unset $! ?

[18:08] <camelia> rakudo 334036: OUTPUT«huhu␤  in block  at /tmp/406uIpZynY:1␤  in block  at /tmp/406uIpZynY:1␤␤»

[18:09] <timotimo> $! = Nil? ;)

[18:10] <FROGGS> timotimo: where? in the CATCH block?

[18:11] <FROGGS> r: try { die "huhu"; CATCH { say "catched"; $! = Nil } }; say $!

[18:11] <camelia> rakudo 334036: OUTPUT«catched␤huhu␤  in block  at /tmp/lI7iIMwd3g:1␤␤»

[18:12] <FROGGS> hmmm

[18:12] <timotimo> hm

[18:13] <FROGGS> r: try { die "huhu"; CATCH { say "catched"; OUTER::<$!> = Nil } }; say $!

[18:13] <camelia> rakudo 334036: OUTPUT«catched␤Cannot modify an immutable value␤  in block  at /tmp/XYuPd26nLB:1␤  in block  at /tmp/XYuPd26nLB:1␤␤»

[18:14] <FROGGS> r: try { die "huhu"; CATCH { say "catched"; OUTER::DYNAMIC<$!> = Nil } }; say $!

[18:14] <camelia> rakudo 334036: OUTPUT«catched␤Cannot modify an immutable value␤  in sub infix:<=> at src/gen/CORE.setting:14966␤  in block  at src/gen/CORE.setting:2137␤  in block  at /tmp/uqBrUoxQHd:1␤  in block  at /tmp/uqBrUoxQHd:1␤␤»

[18:14] <FROGGS> r: try { die "huhu"; CATCH { say "catched"; OUTER::DYNAMIC::<$!> = Nil } }; say $!

[18:14] <camelia> rakudo 334036: OUTPUT«catched␤huhu␤  in block  at /tmp/Bw4pNKBaQ9:1␤␤»

[18:14] <timotimo> oh my. it seems like i have to make sure i don't p6store a !rw thing into a container or something

[18:17] <masak> r: try { die "huhu"; CATCH { default { say "unset!" } } }; say "alive"

[18:17] <camelia> rakudo 334036: OUTPUT«unset!␤alive␤»

[18:17] <masak> FROGGS: this?

[18:17] *** raiph joined
[18:17] *** rafl left
[18:17] <FROGGS> r: try { die "huhu"; CATCH { default { say "unset!" } } }; say "alive $!"

[18:17] <camelia> rakudo 334036: OUTPUT«unset!␤alive huhu␤»

[18:17] <masak> ah.

[18:17] <FROGGS> masak: no, $! should be unset

[18:18] <masak> hrm.

[18:18] <masak> r: try { die "huhu"; CATCH { default { $! = "nah" } } }; say $!

[18:18] <camelia> rakudo 334036: OUTPUT«huhu␤  in block  at /tmp/VFtawR5inf:1␤␤»

[18:19] <masak> weird.

[18:19] <FROGGS> yeah

[18:19] <masak> r: try { die "huhu"; CATCH { default { $_ = "nah" } } }; say $!

[18:19] <camelia> rakudo 334036: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/Ks5PWeJxmi:1␤  in block  at /tmp/Ks5PWeJxmi:1␤␤»

[18:19] <FROGGS> I need it to mimik Perl 5's chop/chomp

[18:20] <timotimo> oh. well, crap.

[18:21] <timotimo> my $a; my $b = sub($arg) { $a := $arg }; my $val = 42; $b($val); dies_ok { $a = 23 }, "bound ro sub param remains readonly";

[18:21] <timotimo> how am i supposed to rely on the descriptor if it can be changed just like that :|

[18:21] <timotimo> can i check for readwriteness at optimize time *at all*, *ever*?

[18:22] <FROGGS> timotimo: I can't help you there :/

[18:22] <timotimo> the only way to make this safer is to look everywhere that reaches the var i'm currently looking at and see if any binding goes on either directly or indirectly. great :|

[18:22] <timotimo> well, afk for a bit first. maybe jnthn has an idea when he returns from nomming

[18:25] *** rafl joined
[18:25] <FROGGS> r: $! = 42; try { temp $!; die "huhu"; CATCH { default { 1; } } }; say $! # *narf*

[18:25] <camelia> rakudo 334036: OUTPUT«42␤»

[18:26] <FROGGS> n: $! = 42; try { temp $!; die "huhu"; CATCH { default { 1; } } }; say $! # *narf*

[18:26] <camelia> niecza v24-88-g1f87209: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/GJRlu4FVFW line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /home/p6eval/niecza/li…

[18:26] <FROGGS> n: try { temp $!; die "huhu"; CATCH { default { 1; } } }; say $! # *narf*

[18:26] <camelia> niecza v24-88-g1f87209: OUTPUT«Internal error in exception dispatch: Writing to readonly scalar␤  at <unknown> line 0 (KERNEL Scalar.TEMP @ 0) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤»

[18:26] <FROGGS> n: try { die "huhu"; CATCH { default { 1; } } }; say $! # *narf*

[18:27] <camelia> niecza v24-88-g1f87209: OUTPUT«huhu␤»

[18:27] <FROGGS> w/e

[18:30] *** domidumont left
[18:31] <FROGGS> jnthn / lizmat: did I got it right that we might want to avoid unicode chars in the nqp/rakudo codebase?

[18:32] <dalek> perl6-roast-data: 5280008 | coke++ | / (5 files):

[18:32] <dalek> perl6-roast-data: today (automated commit)

[18:32] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/528000838f

[18:32] <[Coke]> FROGGS: yes, please.

[18:33] <FROGGS> [Coke]: that cover « and » too

[18:33] <FROGGS> covers*

[18:33] <[Coke]> ... dunno if latin1 is safe.

[18:33] <[Coke]> ^^^^ jvm percentage is dropping slightly.

[18:33] *** domidumont joined
[18:33] <FROGGS> dunno about safe, but it is a matter of speed as I understand it

[18:34] *** crab2313 joined
[18:36] *** benabik joined
[18:41] <jnthn> FROGGS: Yeah, though I think latin-1 is fine.

[18:41] <jnthn> *chars in latin-1

[18:41] <FROGGS> k

[18:43] <timotimo> i suppose if i only fire my optimisation if the lhs of the p6store has :decl, it could be safe from the binding problem

[18:44] <timotimo> but then it won't give much optimization any more

[18:45] <[Coke]> FROGGS: yes, speed impact is what I meant by safe.

[18:45] *** Ben_Goldberg left
[18:46] <timotimo> jnthn: can i ask you for guidance later for implementing p6storeunchecked on the jvm? i'm guessing it'll not be more than copypasting one to five lines from p6store, but i don't know what most of the checks entail and which are safe to remove

[18:47] *** ssutch left
[18:52] *** rindolf left
[18:54] <timotimo> really, timotimo? "!nqp::isnull($op[0].decl) is wrong, i need to check if the decl is 'var'. This should do nicely: 'nqp::isnull($op[0].decl) eq "var"'" >_>

[18:55] <jnthn> timotimo: Well, storeUnchecked is implemented in RakudoContainerSpec.java already, which is the thing that's doing the actual skipping

[18:55] <timotimo> oh, neat!

[18:56] <jnthn> The op wants to look the same, just call spec.storeUnchecked, not store, afaict

[18:56] *** crab2313 left
[18:57] *** domidumont left
[18:57] *** domidumont joined
[18:57] <timotimo> btw, all these CallSiteDescriptors are invokedynamic-related, yes?

[18:59] <jnthn> No

[18:59] <jnthn> Invocation related though

[18:59] <jnthn> They describe the arguments

[18:59] <timotimo> ok

[19:00] <timotimo> now my optimisation doesn't fire at all any more :(

[19:01] <timotimo> huh. shouldn't my Int $a = 5; result in a QAST::Var that has :decl set in addition to :scope<lexical>?

[19:01] <timotimo> huh. the vars that have the lexical declarations are all at the very top of the block

[19:02] *** arcterus joined
[19:02] <timotimo> that's no good for my optimisation; it seems like i'll have to check for "bind" ops to the same lexical inside its scope and additionally do some barebones "escape analysis"

[19:02] <timotimo> why did i ever think this would be easy?

[19:03] *** domidumont left
[19:04] <jnthn> :decl is just 'var', no?

[19:04] <jnthn> You're looking for p6store ops, then probably want to go look at the thing being assigned to if it's a QAST::Var, and find the container

[19:05] <timotimo> in this case :decl is contvar, but the var with the decl is in the wrong place.

[19:05] *** sqirrel joined
[19:05] <jnthn> decls always go into the first QAST::Stmts node.

[19:05] <jnthn> That's normal.

[19:05] <jnthn> But that's not where the assignment is

[19:06] <timotimo> now i just have p6store for Var lexical $a, Var lexical $orig

[19:06] <jnthn> Right, that's all you need. 

[19:06] <jnthn> You take the name $a, look in the symtable, and the hash you get back will probably contain a descriptor key

[19:06] <timotimo> except when someone goes ahead and binds a read-only container to my var behind my back

[19:06] <jnthn> That is the container descriptor.

[19:06] <jnthn> ah, rebinds...

[19:06] <timotimo> that's how i do it now, but i get spectest fallout, i'll copypaste the explodin gcase now

[19:07] <jnthn> Right.

[19:07] <timotimo> my $a; my $b = sub($arg) { $a := $arg }; my $val = 42; $b($val); dies_ok { $a = 23 }, "bound ro sub param remains readonly";

[19:07] <jnthn> Well, I've for a while expected the optimizer to start collecting "facts" about variables and parameters as it goes

[19:07] <timotimo> yes, that would be at the very least necessary

[19:08] <timotimo> did you stop expecting that? or is "for a while" a start point + duration, rather than start point + duration + end point?

[19:08] <jnthn> So really it's a case of pushing the optimizations we can probably do onto a list somewhere, and then at the end of analyzing the block, check that the optimization wasn't "poisoned"

[19:08] <jnthn> No, I still expected it. :)

[19:08] <jnthn> *expect

[19:08] <jnthn> I just didn't get around to it :)

[19:08] <timotimo> :D

[19:08] <jnthn> Seeing a bind to a variable counts as poisoning this particular opt, for example

[19:08] <timotimo> in this case it would even be possible to do it and hold a reference to the op we changed and the var it depends on and then reverting that as soon as we hit a bind

[19:08] <jnthn> I suspect there's a neat way to factor it.

[19:08] <jnthn> That feels icky

[19:09] <timotimo> right, i'll avoid that then

[19:09] <jnthn> I'd prefer to record what we can do and do it when we know it's safe, ratehr than speculatively do stuff, in this case.

[19:09] <jnthn> The trick to keeping optimizers sane is always knowing when you're doing analysis and when you're doing transformation, and not muddling the two.

[19:09] <timotimo> one question that remains is how to keep these facts around throughout compilation; if i put my $a into a MysteryFunctionFromOuterSetting, how do i remember wether that's safe or not?

[19:10] <timotimo> oh, hold on, i don't think that applies here, does it?

[19:11] <timotimo> i mean i can't pass a variable to a function that doesn't have lexical access and change its container through binding or some other witchcraft?

[19:13] <jnthn> Not unless it's a contextual

[19:15] <timotimo> not quite sure what that means...?

[19:16] <jnthn> $*foo

[19:16] <timotimo> ah, yeah sure

[19:16] <timotimo> i should be able to tell by the :scope, right?

[19:16] <jnthn> Yeah, I guess...should be contextual

[19:17] <jnthn> Though "is context" may be interesting

[19:17] <jnthn> Put it in as a level 3 opt while we assess it

[19:17] <timotimo> i have it at 3, but the default is 3 at the moment anyway

[19:17] <timotimo> interestingly, $*orig is just as :decl(contvar) as $a and both are defined as lexical

[19:18] <timotimo> but the lookup is used with &DYNAMIC rather than a QAST::Var, so my optimisation would appear to be safe from that

[19:18] <timotimo> maybe while writing the analysis part of the poisoning process, it'll turn out that turning lexicals into locals will be a very low hanging fruit

[19:20] *** vk_ left
[19:21] <timotimo> is that a "nice little optimization" or "a worthwhile optimization"?

[19:23] <jnthn> timotimo: The default is 3 for setting comp, the default for outside of that is 2

[19:23] <jnthn> timotimo: Note setting comp passes --optimize

[19:23] <jnthn> uh

[19:23] <jnthn> --optimize=3

[19:23] <jnthn> Lexicals to locals needs more care

[19:24] <jnthn> It's do-able but things like pseudo-package use can spoil it

[19:24] <timotimo> oh, ok

[19:25] *** PacoAir joined
[19:25] <jnthn> So that needs to also "poison"

[19:25] <timotimo> pseudo-packages like OUTER etc?

[19:25] <timotimo> no, more likely CALLER

[19:25] <jnthn> OUTER, yeah

[19:25] <jnthn> 'cus that relies on the lexical stuff

[19:25] <timotimo> that's easier to have poisoning for than other lexical stuff

[19:25] <timotimo> (eval will be interesting, too. probably just a blanket poison for everything if eval is encountered)

[19:26] <jnthn> Right.

[19:28] <masak> timotimo: the formal definition of "strangely consistent" is something like this: given that infix:<~> joins strings, infix:<+> adds numbers, and prefix:<+> numifies, what's the operator that stringifies? it's prefix:<~>. why? because when that's the answer, it's strangely consistent.

[19:28] <masak> there are consistencies that are even stranger than that, though. that particular consistency is fairly normal, as consistencies go.

[19:29] <timotimo> bbl for now.

[19:29] * masak .oO( bbn for later )

[19:29] <dalek> nqp: 34ce310 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[19:29] <dalek> nqp: Op inline info for JVM backend.

[19:29] <dalek> nqp: 

[19:29] <dalek> nqp: Go with an opt-out approach, rather than the opt-in one on the Parrot

[19:29] <dalek> nqp: backend, since that is overwhelmingly the right default.

[19:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/34ce310f1c

[19:30] <dalek> rakudo/nom: e815354 | jnthn++ | src/vm/parrot/ops/perl6.ops:

[19:30] <dalek> rakudo/nom: Improve an error, less op variants.

[19:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e81535426e

[19:30] <dalek> rakudo/nom: fe419d2 | jnthn++ | src/ (5 files):

[19:30] <dalek> rakudo/nom: Get optimizer inlining working on JVM backend.

[19:30] <dalek> rakudo/nom: 

[19:30] <dalek> rakudo/nom: This also fixes an oops-looking-at-invalid-memory bug that could take

[19:30] <dalek> rakudo/nom: place on the Parrot backend post-inline.

[19:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe419d2c61

[19:31] *** PacoAir left
[19:34] <jnthn> OK, that's that done... :)

[19:34] *** araujo joined
[19:34] *** araujo left
[19:34] *** araujo joined
[19:36] * lue thinks the bitwise ops are a possible extension to that definition of strangely consistent

[19:36] <masak> oh! another good strange consistency: given that infix:<< <=> >> does numeric comparison, what operator does string comparison. why, infix:<leg>, of course.

[19:36] <masak> lue: yes, I'd say so.

[19:38] <timotimo> jnthn, please suggest a good datastructure for the poisoning, especially since itneeds to mirror the block stack/lexpad

[19:39] <timotimo> maybe the infovcould actually be saved there? does that make sense? is the @BLOCKS listbgoing to be serialist orvsomething likevthat?

[19:40] <timotimo> wow this keyboard is difficult

[19:41] <timotimo> i am not sure i see the strangeness in leg and <=>

[19:42] <timotimo> or in pre/infix + and ~

[19:42] *** arcterus left
[19:42] <timotimo> my interpretation of strange seems to include "surprising in a bad way" or something

[19:44] <jnthn> timotimo: Do we already have a notion of "curent block information"?

[19:44] <timotimo> i did not see anything obvious in that vein, no

[19:45] *** arcterus joined
[19:45] <jnthn> OK, I suggest something a bit like that, where each points to its outer

[19:46] <timotimo> ah because we may need to follow BVal often

[19:46] <timotimo> how do we properly go from a bval to ts dataset? cuid?

[19:46] <jnthn> You don't need to follow BVal, I don't think

[19:46] <jnthn> That doesn't imply anything about lexical nesting

[19:47] <timotimo> well if i call a block i need to know if it users eval or CALLER

[19:48] <timotimo> or is that done by looking for op:call with a name into the lexpad instead?

[19:49] <timotimo> in that case do i get the block object that has the poison information another way?

[19:50] <timotimo> oh another stumbling block in that case will be multis and methods...

[19:52] *** sqirrel left
[19:52] <jnthn> timotimo: You can't determine anything statically about CALLER

[19:52] <jnthn> timotimo: The point is you don't need to though.

[19:53] <timotimo> i am ni longer convinced i can get this to work properly without tremendous amounts of assistance

[19:53] <jnthn> The caller could be in another compilation unit. Or late bound.

[19:53] <timotimo> bbl

[19:53] *** dmol left
[19:54] *** vk_ joined
[19:54] *** dmol joined
[19:58] *** zby_home left
[20:00] <dalek> nqp: 1c9a894 | (Tobias Leich)++ | src/QAST/Node.nqp:

[20:00] <dalek> nqp: strip non-latin1 chars

[20:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1c9a8940e0

[20:01] <dalek> rakudo/nom: 89216fa | (Tobias Leich)++ | src/Perl6/Pod.nqp:

[20:01] <dalek> rakudo/nom: strip non-latin1 chars

[20:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/89216fac2b

[20:02] *** kaare_ left
[20:05] <timotimo> i thought using CALLER should poison

[20:06] <jnthn> Hm

[20:06] <jnthn> I don't know it needs to poison lexical demotion though.

[20:06] <jnthn> Because anything that is not $*foo or declared with the "is dynamic" trait should not be accessible via CALLER today anyway.

[20:06] <colomon> tadzik: MuEvent started failing overnight?

[20:06] <yoleaux> 05:13Z <lizmat> colomon: I started integrating Set/Bag changes from Niecza, but am now blocking on naming special operators like ⊆,∈,∋,∪ to texan.  Suggestions?

[20:07] <timotimo> ah, ok

[20:09] <dalek> rakudo/nom: 156de3b | moritz++ | src/ (2 files):

[20:09] <dalek> rakudo/nom: Inlcude file name after the SORRY line

[20:09] <dalek> rakudo/nom: 

[20:09] <dalek> rakudo/nom: that way bulk messages (like for missing subroutines) get the file

[20:09] <dalek> rakudo/nom: name exactly once (not 0 times as before, and not repeated for every occurrence either)

[20:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/156de3be59

[20:10] <colomon> lizmat: those all have existing texan identities … usually the next thing in the file in the Niecza version.  I think rakudo already supports all of these?  something like (<=), (elem), (cont), and (|) for those particular examples./

[20:12] *** konundra left
[20:12] <tadzik> colomon: not my fault :)

[20:12] *** konundra joined
[20:13] <colomon> tadzik: I certainly never said it was!  Just wanted to make sure you knew.  :)

[20:15] <jnthn> timotimo: feel free to kick off a bench run, btw

[20:15] <timotimo> ah, yes, indeed

[20:15] <timotimo> inlining \o/

[20:17] *** arcterus left
[20:23] *** colomon left
[20:25] <FROGGS> jnthn: btw « is stored as C2 AB instead of AB... is it still okay then?

[20:25] <jnthn> FROGGS: The important thing is that it can be transcoded to something fixed width, which latin-1 is

[20:25] <FROGGS> k

[20:26] *** cognominal left
[20:26] <lizmat> skimming backlog: FROGGS, yes, please no non-ascii: stage parse at 3384 seconds (rather than 3400) with non-ascii char at end of setting

[20:27] <lizmat> this is probably noise, so it doesn't matter

[20:27] <jnthn> lizmat: Note that anything in latin-1 is OK

[20:27] <lizmat> colomon: I figured as much, will look at this later tonight / tomorrow

[20:27] <lizmat> afk again&

[20:27] *** cognominal joined
[20:29] <woolfy> lizmat: you're still here :-)

[20:30] <FROGGS> *g*

[20:31] <masak> woolfy! \o/

[20:31] <FROGGS> .u ø

[20:31] <yoleaux> U+00F8 LATIN SMALL LETTER O WITH STROKE [Ll] (ø)

[20:31] <lizmat> .oO( woolfy is demoing IRC to a friend of ours )

[20:33] *** BenGoldberg joined
[20:35] <FROGGS> I think there are no other non-latin chars left

[20:36] *** colomon joined
[20:37] <timotimo> irc is truly a marvel of modern engineerspersonship

[20:37] *** Mouq joined
[20:39] <Mouq> Hey #perl6

[20:39] <Mouq> What does $(1,2,(9,10)) mean?

[20:40] <Mouq> So, for example, if I create a Parcel ((1,2,(9,10))=>"hiding",5), I access it with .[0].{$(1,2,(9,10))}

[20:41] <Mouq> I don't know why anyone would find this useful, of course

[20:42] <Mouq> Well, actually...

[20:43] <jnthn> $(...) is the same as (...).item

[20:44] <Mouq> Oh! Okay, cool. Thank you

[20:45] <jnthn> Note that @(...) is the same as (...).list, and same for % and .hash

[20:45] <Mouq> So it's forcing a context

[20:46] <jnthn> Yes

[20:46] <Mouq> Cool

[20:48] <timotimo> this is taking me a bit longer than it should ...

[20:48] <jnthn> timotimo: The optimizer thing?

[20:49] <timotimo> no, getting the benchmark up

[20:49] <jnthn> oh :)

[20:49] <jnthn> Was gonna say, you shouldn't feel bad about optimizer hacking taking a while :)

[20:50] <timotimo> now i'm starting it

[20:54] *** ssutch joined
[20:54] <timotimo> well, i'm starting the newest build at least

[20:56] <lizmat> hmmm… quite a few spectests are failing for parakudo atm

[20:56] <lizmat> $ perl6 t/spec/S02-literals/string-interpolation.t

[20:56] <lizmat> use of uninitialized value of type Any in string context  in any  at src/Perl6/Grammar.nqp:933

[20:56] <lizmat> ===SORRY!=== Error while compiling t/spec/S02-literals/string-interpolation.t

[20:56] <lizmat> Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that

[20:57] *** konundra left
[20:57] <lizmat> all test failures seem to be like that: although the subtests seem to pass

[20:58] <lizmat> hmm.. could it be that warnings all of a sudden became fatal ?

[20:59] <timotimo> need to leave my workspace for a bit

[21:00] <lizmat> r: sub f ($x is copy) { my $x }

[21:00] <camelia> rakudo 89216f: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/a2Efi2HMHw:1␤    ------> [32msub f ($x is copy) { my $x [33m⏏[31m}[0m␤»

[21:00] <lizmat> in HEAD this has become:

[21:00] <lizmat> ===SORRY!=== Error while compiling -e

[21:00] <lizmat> Redeclaration of symbol $x

[21:00] <jnthn> lizmat: Maybe a consequence of the recent moritz++ patch?

[21:01] <lizmat> feels like it

[21:02] <lizmat> although looking at the diff, it doesn't seem to be

[21:05] <jnthn> lizmat: fwiw, fe419d2 I spsectested on Parrot and it didn't seem problematic. So it's probably between that and HEAD.

[21:05] <lizmat> making / spectesting without moritz's patch

[21:10] <lizmat> yup, it's moritz's patch

[21:11] *** benabik left
[21:12] <timotimo> 10/43: Testing while_push

[21:13] *** vk_ left
[21:13] *** skids left
[21:17] *** konundra joined
[21:22] <timotimo> these benchmarks take soooo looooong

[21:24] *** btyler_ joined
[21:24] *** dmol left
[21:27] *** atrodo left
[21:27] *** btyler left
[21:29] *** kingbeast joined
[21:30] *** atrodo joined
[21:34] *** xinming left
[21:36] *** xinming joined
[21:36] <timotimo> 19/43: Testing for_assign ...

[21:38] <masak> heh. I still find wanradt's question kinda backwards in https://gist.github.com/masak/5768668

[21:38] <masak> "have you considered using Perl 5 instead?" -- no, I guess I didn't consider that.

[21:42] <tadzik> I don't suppose $remaining_time.Int works in Perl 5

[21:42] <timotimo> you could have used - in identifiers

[21:42] <timotimo> that's not in perl5, right?

[21:43] <masak> :P

[21:43] <dalek> rakudo/use-from-java: 1d8f4d7 | jnthn++ | src/Perl6/Grammar.nqp:

[21:43] <dalek> rakudo/use-from-java: Start processing use more smartly.

[21:43] <dalek> rakudo/use-from-java: 

[21:43] <dalek> rakudo/use-from-java: This handles it through the usual longname parser, meaning we now can

[21:43] <dalek> rakudo/use-from-java: pick out the name itself from any colonpairs.

[21:44] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/1d8f4d7659

[21:44] <dalek> rakudo/use-from-java: 1dbc3d8 | jnthn++ | src/Perl6/ (4 files):

[21:44] <dalek> rakudo/use-from-java: Pass use/need colonpairs to module loader.

[21:44] <dalek> rakudo/use-from-java: 

[21:44] <dalek> rakudo/use-from-java: This also catches any use of :from<...> and complains for now; this is

[21:44] <dalek> rakudo/use-from-java: the hook where :from<jvm> support will go.

[21:44] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/1dbc3d84df

[21:45] <perigrin> tadzik: using MooseX::Types it works but it doesn't do what you'd expect or want :)

[21:46] <jnthn> lizmat: Above will help when ver/auth stuff is reached also :)

[21:46] <timotimo> \o/

[21:46] <lizmat>  I was looking at it and pleasantly surprised :-)

[21:46] <dalek> rakudo/nom: df814a2 | (Elizabeth Mattijsen)++ | src/core/Exception.pm:

[21:46] <dalek> rakudo/nom: Fixes spectests that were broken by 156de3be59136b3b75f4eb51c7ee1697667a5cfe

[21:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df814a2196

[21:47] <FROGGS> hmmm, my version was just a bit more verbose compared to jnthn++'s :o)

[21:47] <lizmat> moritz: seems you fatalized a lot of warnings

[21:48] <lizmat> fixed this by:

[21:48] <lizmat> -my class X::Comp::Group does X::Comp {

[21:48] <lizmat> +my class X::Comp::Group is Exception {

[21:48] <lizmat> which was the original state before your patch

[21:49] <lizmat> not sure whether it is the right thing to do, but it fixes the spectests

[21:50] <jnthn> lizmat: Yeah, doing it 'cus I want some basic use foo:from<java>; support for my JVM talk at YAPC::Eu

[21:51] <lizmat> :)

[21:56] <lizmat> .tell moritz please check df814a2, it was needed to fix many spectests, but fear it is not the solution you had in mind

[21:56] <yoleaux> lizmat: I'll pass your message to moritz.

[21:57] <lizmat> on that thought, I call it a night: more early tomorrow

[21:57] <lizmat> sleep&

[21:58] <jnthn> 'night, lizmat++

[22:00] *** zwut00 left
[22:03] <slava> where is YAPC:Eu?

[22:03] <slava> I'll look it up, nvm

[22:03] <jnthn> Kyiv

[22:03] <slava> ooh, maybe I should go

[22:04] <slava> stop by in my home town, too

[22:04] <jnthn> There's a Perl 6 hackathon on Sun, then talks Mon-Wed. :)

[22:08] <timotimo> is it already on the upcoming weekend?

[22:08] <tadzik> yep

[22:08] <timotimo> oh my

[22:10] <timotimo> after learning about the nonexistence of the exam directly adjacent to that event, maybe i should have reconsidered and tried to get there

[22:10] <timotimo> a bit late now

[22:12] *** FROGGS left
[22:20] <timotimo> 39/43: Testing visit_2d_indices_cross ...

[22:20] <timotimo> not long now

[22:22] *** spider-mario left
[22:23] <timotimo> 39/43: Testing visit_2d_indices_cross ...

[22:23] <timotimo> java.lang.StackOverflowError

[22:23] <timotimo> should that be the error mode? o_O

[22:23] <jnthn> gather/take can sometimes fail in that way

[22:27] <timotimo> all right

[22:27] <timotimo> yay benchmark run done. let me whip up some graphs

[22:30] <timotimo> http://t.h8.lv/p6bench/after-jvm-inline.html - here we go

[22:30] <timotimo> wow, not bad in some of them!

[22:31] * jnthn looks

[22:31] <timotimo> 156de3b is the new one fwiw

[22:32] <tadzik> wow

[22:32] <tadzik> an order of magnitude here and there

[22:35] *** btyler_ left
[22:35] <diakopter> what does while empty look like

[22:35] <diakopter> can you paste the source of the tests?

[22:35] <jnthn> diakopter: They're all in the perl6-bench repo, fwiw

[22:36] <tadzik> timotimo: maybe it's not too late

[22:36] <timotimo> er, some are a bit changed up

[22:36] <tadzik> I bought the conf ticket yesterday, booked the hotel yesterday... 

[22:36] <timotimo> i'm definitely not spontaneous enough

[22:36] <timotimo> ;)

[22:37] <tadzik> not with that attitude! :)

[22:37] <timotimo> yup

[22:37] <diakopter> which perl6-bench repo

[22:38] <timotimo> hold on, i'll push up my local dirty changes

[22:38] <diakopter>  you so dirty

[22:39] <timotimo> https://github.com/timo/perl6-bench/tree/latest-stuff in the microbenchmarks.pl file

[22:41] <timotimo> feel very free to contribute changes and/or new micro or macrobenchmarks

[22:42] <diakopter> japhb said he was being very careful not to microoptimize individual tests for each language

[22:42] <diakopter> but to keep the look as close as possible instead

[22:42] <timotimo> ah

[22:42] <timotimo> well, in some cases there was pathologicality introduced ... or something

[22:42] <timotimo> i think most of the 1s are no longer necessary

[22:43] <diakopter> I thought () allocated

[22:43] <diakopter> wouldn't a 1 be faster?

[22:43] <slava> jnthn: I just told someone that you are working on rakudo-jvm :)

[22:44] <slava> the thought of using perl6 instead of javascript (rhino) appealed to them greatly

[22:44] <timotimo> the point was hat nested for loops used to create ridiculous amounts of list elements

[22:45] <japhb_> Anyone happen to remember the name of the project to use the ipython notebook protocol to talk to Rakudo?  (Or even better, knows the status?)

[22:46] <diakopter> .oO(  someone must be using python...  )

[22:46] <diakopter> japhb: timotimo

[22:46] <diakopter> https://github.com/timo/iperl6kernel

[22:48] *** kingbeast left
[22:48] <timotimo> i did, yes. it's very far from usable, though

[22:48] <timotimo> got blocked somewhat by zeromq and lack of threading

[22:51] <dalek> rakudo/use-from-java: e40c9bc | jnthn++ | src/Perl6/ModuleLoader.nqp:

[22:51] <dalek> rakudo/use-from-java: Add a mechanism to register :from loaders.

[22:51] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/e40c9bc802

[22:51] <dalek> rakudo/use-from-java: 42c2152 | jnthn++ | src/Perl6/ (2 files):

[22:51] <dalek> rakudo/use-from-java: Refactor to make alternative loaders easier.

[22:51] <dalek> rakudo/use-from-java: 

[22:51] <dalek> rakudo/use-from-java: This relaxes what is returned to just be something hash-ish, not a

[22:51] <dalek> rakudo/use-from-java: full-blown context.

[22:51] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/42c215228f

[22:52] <dalek> rakudo/use-from-java: d3b14a7 | jnthn++ | / (2 files):

[22:52] <dalek> rakudo/use-from-java: Very basic :from<java> support.

[22:52] <dalek> rakudo/use-from-java: 

[22:52] <dalek> rakudo/use-from-java: The objects are decidedly lacking in sugar so far, not to mention the

[22:52] <dalek> rakudo/use-from-java: marshalling of Perl 6 types will need a lot of work. But you can do:

[22:52] <dalek> rakudo/use-from-java: 

[22:52] <dalek> rakudo/use-from-java:     use java::lang::System:from<java>;

[22:52] <dalek> rakudo/use-from-java:     say System.currentTimeMillis();

[22:52] <dalek> rakudo/use-from-java: 

[22:52] <dalek> rakudo/use-from-java: And it works.

[22:52] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/d3b14a7458

[22:56] <lee_> wow, cool

[22:57] *** btyler joined
[22:58] <colomon> \o/

[23:01] <diakopter> jnthn: so it follows the "import" semantics of Java?

[23:01] <jnthn> diakopter: apparently :)

[23:02] <diakopter> heh.

[23:02] <diakopter> if someone has a couple hours, feel free to volunteer to help me set up rakudo-jvm on a new evalbot host

[23:03] *** takesako_______ joined
[23:03] *** Bucciarati joined
[23:03] *** segomos joined
[23:03] *** nwc10 joined
[23:04] *** dagurval joined
[23:04] *** Hor|zon joined
[23:04] *** szbalint joined
[23:04] *** avuserow joined
[23:05] <masak> 'night, #perl6

[23:06] <diakopter> 0/

[23:06] *** FOAD left
[23:06] *** FOAD joined
[23:27] *** leont left
[23:29] <timotimo> i'm kind of saddened that our rc-forest-fire isn't running anywhere near fast enough for the benchmark framework to even consider a second run ...

[23:30] *** skids joined
[23:42] <japhb_> timotimo, agreed, definitely.  :-(

[23:43] <japhb_> diakopter, Well, I have to use Python anyway, I figured I might as well enjoy tab completion in my Perl 6 REPL ...

[23:44] <timotimo> ipython is darn excellent.

[23:44] <japhb_> timotimo: Wiill zeromq and threading still be a problem when use-from-java is merged, assuming I can otherwise use rakudo-jvm?

[23:46] *** Rotwang joined
[23:46] <timotimo> dunno. i'd personally hope for something more like zavolaj-on-jvm or something to get zmq

[23:46] <japhb_> I had to modify the parameters for rc-forest-fire several times to even get any useful data out (at first it would generate and display the first frame and already be over enough_time)

[23:46] <timotimo> ipython has a requirement for a server to listen and respond to pings regularly, otherwise the frontend will shut down

[23:47] *** btyler left
[23:47] <japhb_> nodnod

[23:47] <timotimo> if you don't have that in a thread, you're dooooooomed

[23:48] <japhb_> nodnod

[23:48] <timotimo> did you see my last results?

[23:52] <japhb_> Not yet, no.  Link?

[23:54] <timotimo> http://t.h8.lv/p6bench/after-jvm-inline.html

[23:54] <timotimo> jnthn gave our jvm port support for compile-time inlining of subs and such

