[00:00] <BenGoldberg> But somehow, I don't think that that form can be made into an infinite lazy list ;)

[00:01] * BenGoldberg could be wrong, though :)

[00:11] *** thou left
[00:13] *** avuserow left
[00:20] <raiph> http://en.wikipedia.org/wiki/Thue-Morse_sequence # odious & evil

[00:21] <kurahaupo> BenGoldberg: isn't that sequence simply the second-to-top bit from a greys coding?

[00:21] <kurahaupo> (or inversion thereof)?

[00:22] <BenGoldberg> Huh?

[00:22] <BenGoldberg> A gray coding involves an order reversal, I think.

[00:22] *** tgt left
[00:22] <kurahaupo> grays encoding: an encoding of binary where counting up or down by one only ever flips one bit

[00:23] <kurahaupo> 1, 11, 10, 110, 111, 101, 100, 1100 ...

[00:23] <kurahaupo> read the second-to-left bit from each element, and I think it will read out your putative non-lazy sequence

[00:24] <BenGoldberg> I don't see it

[00:24] * kurahaupo will have to investigate more thoroughly, but they certainly look related

[00:27] <BenGoldberg> Of course they're related, they're both made from zeros and ones!

[00:27] <BenGoldberg> ;)

[00:32] <kurahaupo> r: @a = 1; @a := @a, @a, map{1-$_} @a for 1..6; say @a;

[00:32] <camelia> rakudo 37c995: OUTPUT«===SORRY!===␤Variable '@a' is not declared␤at /tmp/_gAtpHMLcb:1␤------> @a⏏ = 1; @a := @a, @a, map{1-$_} @a for 1..␤    expecting any of:␤        postfix␤»

[00:32] <kurahaupo> r: my @a = 1; @a := @a, @a, map{1-$_} @a for 1..6; say @a;

[00:32] <camelia> rakudo 37c995: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/5YjFPCpg87:1␤------> my @a = 1; @a := @a, @a, map{1-$_} ⏏@a for 1..6; say @a;␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modif…

[00:32] <kurahaupo> r: my @a = 1; @a := @a, @a, map{1-$_}, @a for 1..6; say @a;

[00:32] <camelia> rakudo 37c995: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'map' will never work with no arguments (line 1)␤    Expected any of:␤    :(&code, *@values)␤»

[00:37] <kurahaupo> (drat, came in half way through that conversation and didn't scroll back far enough to see the previous mention of Grays coding)

[00:54] <kurahaupo> r: my @a=0; @a := @a, map {1-$_}, @a for 1..6; say @a; my @b=0; @b := map {$_,1-$_}, @b for 1..6; say @b;

[00:54] <camelia> rakudo 37c995: OUTPUT«0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0␤0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0␤»

[00:54] * kurahaupo recognizes the sequence: parity on binary counting

[01:01] <kurahaupo> In P5 roughly: @a = map { unpack( "%32b32", pack "V", $_ ) % 2 } 0 .. MAXINT

[01:12] *** kbenson left
[01:13] *** adu joined
[01:42] *** FROGGS_ joined
[01:46] *** FROGGS left
[02:10] *** rhinux_ left
[02:16] *** japhb_ left
[02:32] *** daniel-s_ joined
[02:32] <diakopter> agentzh++ (openresty++) http://www.techempower.com/benchmarks/#section=data-r3

[02:33] <diakopter> so, I look at these benchmark numbers

[02:34] <diakopter> and I'm forced to imagine rakudo's http server doing this

[02:35] *** daniel-s left
[02:35] *** census left
[02:40] *** lustlife joined
[02:40] <diakopter> my first guess is that rakudo/parrot could maybe get 1,000x slower than the fastest ones in every test

[02:45] *** orafu left
[02:49] <labster> that's only 3 orders of magnitude -- and 1 order of magnitude from PHP

[02:49] <labster> look at the bright side

[02:50] *** orafu joined
[02:51] <diakopter> o_O and in base-1000, 1 order of magnitude

[02:53] <bonsaikitten> geeeh, why is that website so retarded ... I can't see the benchmark results

[02:53] <bonsaikitten> people really need to remember how http works I guess

[02:54] <diakopter> I suppose you could suspect that if it worked for less than nearly everyone..

[02:55] <bonsaikitten> oooh. oooooooh.

[02:55] <bonsaikitten> you need to enable javascript so that the links work

[02:55] <bonsaikitten> I have no idea what that's supposed to mean, but at least it's futuristic

[03:06] <labster> \o/ finally figured out how to use precompiled regexes in the setting!

[03:36] <labster> well, that's a new one: Error while constructing error object:Could not locate compile-time value for symbol Syntax::Confused  Error while compiling, type X::Syntax::Confused at line 8526, near "my $str_no"   Still manages to be informative, though.  

[03:37] <labster> It's an error I made in the setting, so don't worry about fixing it.

[03:43] *** Nom- left
[03:43] *** Nom- joined
[04:10] *** kaleem joined
[04:18] *** lustlife left
[04:20] *** kurahaupo left
[04:20] *** kurahaupo1 joined
[04:23] *** SmokeMachine left
[04:26] *** Patterner left
[04:30] *** SmokeMachine joined
[04:46] *** Psyche^ joined
[04:46] *** Psyche^ is now known as Patterner

[04:52] *** kaare_ joined
[05:05] *** BenGoldberg left
[05:05] *** adu left
[05:09] *** SamuraiJack joined
[05:13] *** kaare_ left
[05:14] *** ilbot6 left
[05:14] *** _ilbot left
[05:15] *** moritz left
[05:26] *** frdmn left
[05:46] *** unknown_ joined
[05:47] *** unknown_ left
[05:48] *** fgomez left
[06:01] *** FROGGS_ left
[06:14] *** FROGGS_ joined
[06:15] *** frdmn joined
[06:15] *** FROGGS_ is now known as FROGGS

[06:15] *** fgomez joined
[06:54] *** moritz joined
[06:54] <moritz> \o

[06:55] <japhb> o/ moritz

[06:55] <japhb> BTW ... clogs are clogged.  :-/

[06:55] <moritz> I know

[06:55] <japhb> I figured you might.

[06:55] <moritz> the server is unreachable :(

[06:56] <japhb> Not even you can reach it?  Ouch.

[06:56] <moritz> it's a vm, and the hypervisor is ping-able

[06:56] <japhb> At least it's not net-silent

[06:57] <moritz> but I don't have access to the hypervisor (the VM is shared among several folks)

[06:57] *** kurahaupo1 left
[07:00] *** domidumont joined
[07:14] <labster> o/

[07:15] <FROGGS> \o

[07:15] <hoelzro> ahoy #perl6!

[07:15] <FROGGS> harrrr! hoelzro 

[07:17] <tadzik> is it talk like a pirate day again, mateys?

[07:17] *** sqirrel joined
[07:17] <FROGGS> dunno if that is today

[07:18] <FROGGS> hmmm, looks like today is a non-special day... according to the google page 

[07:19] *** hoelzro joined
[07:19] <tadzik> heh

[07:19] <tadzik> http://www.wolframalpha.com/input/?i=today

[07:19] <tadzik> Chernobyl anniversary

[07:19] <tadzik> Gestapo establishment anniversary

[07:19] <tadzik> Confederates surrender anniversary

[07:20] <tadzik> nothing worth the google page I guess :)

[07:20] <FROGGS> ya

[07:20] *** domidumont left
[07:20] <FROGGS> for me it is a "I'm sick"-day -.-

[07:20] <tadzik> aw

[07:20] *** domidumont joined
[07:21] * tadzik hugs FROGGS

[07:21] <FROGGS> thanks ó.ò

[07:21] <tadzik> for me it's "I have a Networking exam and then I slack off" day

[07:21] <labster> hugme: hug FROGGS 

[07:21] * hugme hugs FROGGS

[07:21] <tadzik> where "slack off" may end up being "hacking on panda"

[07:21] * labster doesn't want to get the germs on myself

[07:22] <FROGGS> *g*

[07:27] <labster> Finally!  Just got File::Spec Unix, Win32, and Cygwin working in core.

[07:27] <labster> Naturally every file I added failed for a different reason.

[07:28] <diakopter> labster: cool. :D

[07:28] <diakopter> labster++

[07:40] *** kresike joined
[07:40] <FROGGS> labster++

[07:40] <kresike> hello all you happy perl6 people

[07:40] <FROGGS> hi kresike 

[07:40] <labster> hello kresike 

[07:42] <kresike> FROGGS, labster o/

[07:45] <FROGGS> does someone gets this error msg too? Missing or wrong version of dependency 'src/Perl6/Pod.nqp'

[07:48] <lizmat> didn't jnthn commit something in that area yesterday ?

[07:49] <FROGGS> ohh, good hint, will look at the commits

[07:50] <FROGGS> hmmm, just for the jvm build though :/

[07:52] *** rindolf joined
[07:56] <FROGGS> ohh, might be my fault...

[07:59] <lizmat> rn: my $a; my $x = [postcircumfix:<{ }>] $a,<foo bar>; say $a

[07:59] <camelia> rakudo 37c995: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/BX8792UNA1:1␤------> my $a; my $x = [postcircumfix:<{ }>] ⏏$a,<foo bar>; say $a␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement en…

[07:59] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/yA_wcxH2AA line 1:␤------> my $a; my $x = [postcircumfix:<{ }>] ⏏$a,<foo bar>; say $a␤␤Parse failed␤␤»

[08:00] *** kaleem left
[08:01] * lizmat trying to grok S03:4562

[08:02] <lizmat> rn &infix:<dehash> ::= postcircumfix:<{ }>;

[08:02] <lizmat> rn: &infix:<dehash> ::= postcircumfix:<{ }>;

[08:02] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Cannot find definition for binding??? at /tmp/qwZn7jcUCs line 1:␤------> &infix:<dehash> ::= postcircumfix:<{ }>⏏;␤␤Undeclared routine:␤      'infix:<dehash>' used at line 1␤␤Unhandled exception: Check failed␤␤…

[08:02] <camelia> ..rakudo 37c995: OUTPUT«===SORRY!===␤Cannot use bind operator with this left-hand side␤at /tmp/lS9Jbd0V9J:1␤------> &infix:<dehash> ::= postcircumfix:<{ }>⏏;␤    expecting any of:␤        argument list␤        postfix␤»

[08:02] <lizmat> I guess NYI

[08:03] <FROGGS> :/

[08:03] <moritz>     &infix:<dehash> ::= postcircumfix:<{ }>;

[08:03] <moritz> I'm pretty sure that must be &postcircumfix:<{ }>; on the right, no?

[08:04] <nwc10> we're not being logged? So I can say impolite things about Perl 3? :-)

[08:04] <lizmat> not sure…  I'm cutting/pasting from S03:4562

[08:04] <moritz> nwc10: countless monkeys are working on restoring the server

[08:04] <lizmat> nwc10: we are being logged  and you can say impolite things about Perl 3

[08:06] <moritz> fwiw ilogger2 is still active

[08:06] <moritz> (I guess)

[08:06] <moritz> though I don't know where it logs to :-) (not my bot)

[08:12] *** berekuk joined
[08:17] <lizmat> away until later today&

[08:36] *** berekuk left
[08:40] <dalek> specs: 2f51c10 | moritz++ | S03-operators.pod:

[08:40] <dalek> specs: [S03] fix a small thinko

[08:40] <dalek> specs: review: https://github.com/perl6/specs/commit/2f51c10036

[08:49] *** spider-mario joined
[08:54] *** berekuk joined
[09:00] *** MrMeek joined
[09:02] *** MrMeek-afk left
[09:07] *** daxim joined
[09:14] *** kaleem joined
[09:28] *** bbkr joined
[09:29] * jnthn yawns

[09:31] <FROGGS> g'yawning jnthn

[09:39] *** raiph left
[09:41] *** sqirrel left
[09:58] <masak> good antenoon, #perl6

[09:58] <moritz> \o masak 

[09:59] <moritz> masak: I'm a wee bit disappointed that you didn't mention the trick of how my t2 solution recognizes nouns, verbs etc. :-)

[10:02] <moritz> lunsj&

[10:02] <masak> moritz: oh!

[10:02] <masak> yes, sounds like there was something I missed pointing out there.

[10:03] * masak looks again

[10:05] * nwc10 wonders what keyboard layout puts lunsj near to lunch

[10:06] <jnthn> nwc10: I think that's how you actually spell it.

[10:06] <nwc10> aha.

[10:06] <jnthn> nwc10: In Norwegian.

[10:09] * masak .oO( any sufficiently advanced spelling system is indistinguishable from a typo )

[10:10] <jnthn> Jes.

[10:10] <tadzik> Tak jest.

[10:12] *** lustlife joined
[10:22] <masak> :P

[10:32] <bbkr> when registration for PLPW 2013 ends?

[10:35] <masak> bbkr: there doesn't seem to be a deadline for registration.

[10:35] <masak> bbkr: http://act.yapc.eu/plpw2013/

[10:35] <masak> I don't see anything on that page.

[10:35] <jnthn> I love how on http://act.yapc.eu/plpw2013/talks masak is the only person undecided whether to give his talk in Polish or English :P

[10:36] <bbkr> :)

[10:37] <masak> I've decided to late-bind that decision.

[10:37] <masak> who knows what will happen between now and then.

[10:38] <masak> (fixed)

[10:41] <tadzik> so there are no Polish talks :)

[10:41] <tadzik> how international :)

[10:41] <tadzik> bbkr: we don't plan a deadline

[10:41] <tadzik> maybe we'll close it when we order the t-shirts :)

[10:42] <bbkr> nice

[10:43] <tadzik> I just sent a new invitation that I expect to be a Great Success

[10:43] <tadzik> I was supposed to give a Perl talk on my university, but the class was cancelled that day

[10:43] <tadzik> so I took a liberty to invite all the students on the mailing list, saying "come, it's fun, you learn a lot and free beer"

[10:44] <tadzik> there's at least one thing there that'll easily trigger their attention :)

[10:44] <jnthn> There's free beer?!

[10:44] <tadzik> there'll be at least some free beer

[10:46] *** tgt joined
[11:06] <sorear> moritz: 03:51 <+g0ph3r_> anyone else getting 504 on http://irclog.perlgeek.de/rosettacode/today ?

[11:06] <sorear> moritz: i get a connection timeout; just referred them here as well

[11:08] <moritz> the host is down

[11:50] *** snarkyboojum joined
[11:50] <masak> snarkyboojum! \o/

[11:58] <timotimo> i'd like to hear your opinion on if (True, False).pick { ... } else { ... } vs ({ ... }, { ... }).pick.()

[11:59] <masak> timotimo: first off, 'if Book.pick'

[11:59] <masak> you're welcome. :) (I made sure that worked by spec.)

[11:59] <timotimo> my preference is the latter, especially since it more naturally expands to more than two branches

[11:59] <timotimo> even though for that a given ^3).pick { when 0 { .. }; when 1 { ... } ...} may work as well

[11:59] <masak> timotimo: second, not knowing the context, the former one feels much easier to read.

[11:59] <masak> timotimo: and a great example of not having too much end-weight.

[12:00] <timotimo> not having to manually write numbers for each branch is a plus, too

[12:00] <masak> put all the choices in an array. do @choices.pick().()

[12:00] <timotimo> that^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^Hthat's not considered end-heavy, because it's a new line?

[12:01] <masak> because it's short :)

[12:01] <colomon> masak: does pick work like Bool.pick on enu,s?

[12:01] <colomon> *enums

[12:01] <daxim> ololol, literal ^H

[12:01] <masak> colomon: yes.

[12:02] <daxim> ␡eted!

[12:02] <masak> timotimo: the "end weight" problem is when you first see a big expression and the statement appears to do one thing, but then you see the end and it turns out to do something completely different.

[12:03] <masak> timotimo: '.pick.()' in your second alternative has that problem. 'if Bool.pick' doesn't.

[12:04] <timotimo> i see why that's so. thanks!

[12:05] <colomon> masak, timotimo: then maybe defining an enum with a descriptive name for each branch is the way to go?

[12:05] *** bluescreen10 joined
[12:05] <cognominal> nqp:  sub a($a-a) {}

[12:05] <camelia> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "($a-a) {}"␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[12:05] <timotimo> would you consider pick(1, {...}, {...}).() to be better?

[12:05] * masak .oO( "end weight" will be one of the topics in the FREE #masakism workshop on Wednesday. sign up! )

[12:05] <cognominal> nqp: my $a-a

[12:05] <camelia> nqp:  ( no output )

[12:05] <timotimo> already looking forward to the workshop :)

[12:10] <timotimo> i really dislike not being ble to tell if the tssh connection is just very laggy/disconnected or if the irc channel's just very slow. can't even tell by the clock in the lower right corner, because it's usually one to four minutes out of sync with my local one >_>

[12:11] *** arlinius left
[12:13] <masak> colomon: yes, descripting enum is a very nice idea.

[12:13] <masak> descriptive*

[12:13] *** spider-mario left
[12:25] *** tgt left
[12:27] <timotimo> agreed. although it offers only a little bit of "added value" over a list of strings (or am i missing something cool?)

[12:28] *** census joined
[12:28] <jnthn> Can use enums as type constraints too

[12:28] *** xinming left
[12:28] <timotimo> masak: also, when you said "I made sure that worked by spec.", do you mean you made sure that it would get put into the spec or that you checked with the specs if that is correct?

[12:29] <timotimo> i imagine this use case to be my enum Decision <use-rule ignore-rule>; given decision.pick { when ... { ... } ... }  and then forget about the enum; not sure where the type constraint w^Hcomes in

[12:29] <masak> timotimo: the former, IIRC.

[12:30] *** xinming joined
[12:30] *** kaleem left
[12:31] <timotimo> good thinking :)

[12:31] <timotimo> ^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^H^Hmakes me wonder what the neatest way would be to write a decision where each branch has a given "probability" to be chosen near it

[12:32] * [Coke] waves

[12:33] <timotimo> i am aware of the given a number between 0 and 1 { when 0 .. 0.25 { ... }; when 0.25 .. 0.75 { ... }; default { ... } } way already, which seems to be what most people would write

[12:34] <timotimo> i dislike that because it expresses the probability as the difference between two numbers and changing probabilities in the middle requires some extra work every time

[12:35] <timotimo> anyway, gotta get out of the tram now. will check in later for a few clever answers :3

[12:36] <pmichaud> when * < 0.25 { ... };  when * < 0.75 { ... };  default { ... }

[12:42] *** domidumont left
[12:43] *** sergot_ is now known as sergot

[12:43] *** mattp_ left
[12:43] *** skids left
[12:45] *** frdmn|afk joined
[12:45] *** frdmn|afk left
[12:46] <[Coke]> sergot++ # noted the module list was updated at some point.

[12:46] *** frdmn left
[12:46] <tadzik> I think it updates daily now

[12:46] <tadzik> which is very cool

[12:51] <masak> timotimo: you might want to check out KeyBag's .pick and .roll, which weight things for you.

[12:55] *** kaleem joined
[13:04] *** donaldh joined
[13:05] <dalek> v5: 101f503 | (Tobias Leich)++ | rakudo.patch:

[13:05] <dalek> v5: this patch contains unapplied patches for rakudo

[13:05] <dalek> v5: 

[13:05] <dalek> v5: These are usually WIP, and must be confirmed by Commit Committee and the

[13:05] <dalek> v5: Bad Ideas Reversal Squad(R) before they can be applied.

[13:05] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/101f5034a8

[13:19] *** shinobicl left
[13:25] <gfldex> could the Bad Ideas Reversl Squad have a talk with my government please?

[13:26] *** fhelmberger joined
[13:29] <timotimo> pmichaud: ah, of course given/when is serial. but this just makes the individual probabilities even harder to spot

[13:29] <timotimo> especially if the blocks are big-ish

[13:30] <moritz> maybe you want something along the lines of

[13:30] <moritz> my @probs = 0.25 => &sub1, 0.3 => &sub2, ...;

[13:30] <moritz> my $sum = 0;

[13:31] <moritz> for @probs { $sum += .key; if $value <= $sum { .value.(); last } }

[13:33] <timotimo> maybe a macro would be cool for this.

[13:33] <jnthn> r: say Macro ~~ Cool

[13:33] <camelia> rakudo 37c995: OUTPUT«False␤»

[13:33] <jnthn> Nope. :P

[13:36] <pmichaud> use a bag and .pick, then.

[13:36] *** fhelmberger left
[13:37] <pmichaud> or .roll

[13:38] <moritz> or .rick-roll

[13:39] <timotimo> that's nice, i like KeyBag.

[13:39] *** SmokeMachine left
[13:39] <timotimo> that's a thing i should try out more often

[13:40] *** SmokeMachine joined
[13:48] *** crab2313 joined
[13:50] <donaldh> jnthn: hai

[13:50] <dalek> v5: c4d4cb2 | (Tobias Leich)++ | STATUS.md:

[13:50] <dalek> v5: update

[13:50] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/c4d4cb2eee

[13:51] <donaldh> jnthn: I am just catching up with NQP and JVM after much dayjob travel and vacation.

[13:52] <dalek> v5: ee6aaf8 | (Tobias Leich)++ | Makefile:

[13:52] <dalek> v5: adding blib is dangerous when v5 is installed, directory gets changed and Perl 5 scripts get require-d

[13:52] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/ee6aaf8075

[13:52] *** crab2313 left
[13:52] <donaldh> jnthn: I see that JVM has landed in the NQP repo now

[13:52] <donaldh> jnthn: what exciting things are on the todo list?

[13:53] <moritz> make rakudo run on top of NQP+JVM :-)

[13:53] *** PacoAir joined
[13:54] *** crab2313 joined
[13:54] *** kbenson joined
[13:54] <jnthn> donaldh: I got your asm stuff merged and we're using invokedynamic in a couple of places by now.

[13:55] <donaldh> jnthn++

[13:55] <jnthn> donaldh: Still more to come; I need to get method calls working with invokedynamic. May do that this evening...

[13:55] <jnthn> donaldh: Mostly though it's working through getting Rakudo to run.

[13:56] <jnthn> There's still some nqp:: ops missing; a handful of big int related ones, and various IO related ones come to mind.

[13:56] <jnthn> Also, I hacked together a simple readline thing but it doesn't quite work yet, so the NQP REPL doesn't function. That should be quite approachable to work on.

[13:56] <donaldh> jnthn: okay, I could explore some of that.

[13:57] <jnthn> :)

[13:57] <donaldh> I get test failures on nqp/jvm on MacOS

[13:57] <donaldh> Are some to be expected just now ?

[13:58] <nwc10> jnthn: 5% speedup for that Levenstein benchmark from using invokedynamic

[13:58] <jnthn> Yeah; they're ones that never were in the nqp-jvm-prep.

[13:58] <donaldh> So some of them will target the missing ops, etc. ?

[13:59] <jnthn> donaldh: I think only one of them (nqpop) fails due to those kinds of reasons.

[13:59] <FROGGS> btw, there are issues with &is-prime on mac+rakudo+parrot too

[14:00] <jnthn> donaldh: I think the missing ops are largely things that Rakudo uses and are thus indirectly covered by spectest, but don't have direct NQP tests.

[14:00] <[Coke]> FROGGS: yes, there's finally a ticket for that.

[14:00] <FROGGS> ya, just wanted to point on that

[14:00] * [Coke] notes that [WEIRD] is not really a useful diagnostic bug label, he thinks.

[14:01] <[Coke]> r: say 643 - 70

[14:01] <camelia> rakudo 37c995: OUTPUT«573␤»

[14:02] <moritz> [Coke]: it helps me ignore some bug reports when I want to work on stuff that I want to be helpful to users immediately

[14:02] <dalek> v5: f8bd973 | (Tobias Leich)++ | t/v5/ (37 files):

[14:02] <dalek> v5: strip 'use perl5;', because there is no such thing

[14:02] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f8bd9730a1

[14:05] <[Coke]> moritz: hokay

[14:06] <dalek> rakudo/nom: 71ea142 | (Timothy Totten)++ | src/core/Temporal.pm:

[14:06] <dalek> rakudo/nom: DateTime uses Int timezone offsets.

[14:06] <dalek> rakudo/nom: 

[14:06] <dalek> rakudo/nom: Signed-off-by: Moritz Lenz [email@hidden.address]
[14:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71ea142406

[14:06] <moritz> [Coke]: there, that should make your rakudo spectests clean(er) again

[14:08] *** skids joined
[14:08] <[Coke]> masak: https://rt.perl.org/rt3/Ticket/Display.html?id=73230 - please followup?

[14:09] *** tgt joined
[14:11] <[Coke]> FROGGS: didn't you fix a bug like this recently: https://rt.perl.org/rt3/Ticket/Display.html?id=73742

[14:14] <FROGGS> r: class JSON::Tiny::Actions

[14:14] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Unable to parse class definition␤at /tmp/MSBdkl1WdH:1␤------> class JSON::Tiny::Actions⏏<EOL>␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        generic role␤»…

[14:15] <FROGGS> [Coke]: I'm not aware of fixing it

[14:15] <FROGGS> r: { use Test }

[14:15] <camelia> rakudo 71ea14:  ( no output )

[14:15] <FROGGS> (that one fails locally using v5 )

[14:25] *** arlinius joined
[14:28] <skids> r: for (rand xx 50) -> $p is copy { my sub P ($chance) { $p -= $chance; $p < 0 }; when P(0.25) { "a".print }; when P(0.5) { "b".print }; default { "c".print } }

[14:28] <camelia> rakudo 71ea14: OUTPUT«cabcbabbbbbbabbcaccbcbbabacbcbcbbbbbbbcaaabbbcacbb»

[14:28] <[Coke]> https://github.com/blog/1227-commit-status-api - this could be nifty.

[14:28] <[Coke]> it was "PRE ; " vs. "PRE {}" I think.

[14:30] *** bbkr left
[14:30] *** frdmn joined
[14:30] <FROGGS> ya, there was a PHASER ; issue once

[14:31] <FROGGS> because <blorst> was faulty

[14:32] <skids> .oO(yes I know that's very procedural but I'm not a fan of functionality over functionality... oh wait... crap.)

[14:34] *** SamuraiJack left
[14:39] *** domidumont joined
[14:42] *** mattp_ joined
[14:43] <gtodd> o/ all

[14:47] <gtodd> in perl5 land there are things like PAR and I think other approaches to  python eggish deployment (not sure how popular or widely used these are) is there a synopsis or set of discussions on current/future tools for perl6 for cross platform packaging/deployment ?

[14:48] <tangentstorm> we should bring back penguin :)

[14:48] *** kaleem left
[14:49] <tangentstorm> http://www.hpcf.upr.edu/~humberto/documents/penguin-safe-scripting.html

[14:49] <tangentstorm> actually nothing like python eggs but that reminded me of this for some reason. :)

[14:50] <gtodd> heh ok wasn't sure if panda/penguin etc were prototypes for future even better stuff or ...

[14:50] <tangentstorm> panda is the cpan-alike for perl6 as far as i can tell.

[14:51] <tangentstorm> penguin is a very old thing for distributed computing and mobile code.

[14:51] <tangentstorm> (it actually does have to package up (running!) code so it can run in different places)

[14:51] <gtodd> ah ... perl6 features/approaches seem to cross pollinate with perl5 (e.g. Moose)  so was wondering if packaging was doing that too :-)

[14:52] *** mobi_d joined
[14:52] <skids> Probably the banging out the module loading filestructure will come before serious efforts.

[14:53] <gtodd> tangentstorm: someone in mojolicious channel mentioned wanting to run perl/mojo on a cell phone so the demand is there :-)

[14:53] <skids> (not to call panda "unserious")

[14:54] <gtodd> skids: ok I thought maybe it was a chariot/horses thing ... like a much better cart will be possible when our horses are ready

[14:56] <tangentstorm> gtodd: cool, but not that kind of mobile... mobile like it's running on one machine, then you freeze it and send it over to another machine and it thaws out and continues running there.

[14:56] <tangentstorm> like distributed computing

[14:56] <gtodd> right

[14:56] <tangentstorm> but i guess there could be a lot of overlap between that and the modern sense of "mobile" :)

[14:57] <gtodd> that is cool though

[14:57] <tangentstorm> though reading this again, i'm not sure penguin actually does this :/

[14:58] <gtodd> more cool than cloud computing ... sort of more like a swarm/flock

[15:02] <tangentstorm> this paper says it's new (in 1996)... i think the perl journal article was from a little later in the development cycle

[15:03] *** spider-mario joined
[15:03] <gtodd> tangentstorm: is that the sort of thing erlang can do currently?

[15:04] <tangentstorm> not sure. it's been probably 10 years since i read this article. looking for it now.

[15:04] *** donaldh left
[15:05] <tangentstorm> http://www.foo.be/docs/tpj/issues/vol4_4/tpj0404-0011.html  <- weren't people talking about getting perl on the jvm in here recently? :D

[15:07] *** raiph joined
[15:08] <gtodd> erlang's vm errm I mean abstract machine only runs erlang code ... not perl :)

[15:08] <gtodd> oh wait you said jvm 

[15:08] <gtodd> yes

[15:08] <tangentstorm> found it.. looks like there were two penguin articles in TPJ... both from 1996... i guess it died out after that.

[15:08] <tangentstorm> http://www.foo.be/docs/tpj/issues/vol1_2/tpj0102-0002.html

[15:09] <tangentstorm> http://www.foo.be/docs/tpj/issues/vol1_3/tpj0103-0004.html

[15:09] <gtodd> interesting

[15:11] *** crab2313 left
[15:12] *** arlinius left
[15:12] <kresike> bye folks

[15:12] *** kresike left
[15:12] *** raiph left
[15:13] *** mobi_d left
[15:13] <nwc10> tangentstorm: there's a heck of a lot of difference between getting some simple test code working, and having a full-on language

[15:14] <nwc10> let alone one that is actually as fast as the "current" implementation

[15:15] <tangentstorm> nwc10: yeah, i know... i just thought it was funny to see that from so long ago.

[15:15] <jnthn> .oO( And don't I know it... )

[15:16] <tangentstorm> blast from the past... in 1998-1999 perl was such a dominant languange... it was every bit as big as java. how times change. :)

[15:16] <nwc10> perl has fewer CVEs.

[15:17] <nwc10> Be nice if it were zero

[15:18] <tangentstorm> well there were plenty of buggy and insecure cgi scripts written *in it* though :)

[15:18] <tangentstorm> tpj was really awesome: http://www.foo.be/docs/tpj/

[15:22] *** raiph joined
[15:26] <gtodd> some people say java took over the world ... but it was probably just a pre-beta version of the world ... perl will be there when World 2.0 is ready :)

[15:27] <sorear> don't forget that the market has not remained a constant size

[15:28] <dalek> nqp: 746aa35 | jnthn++ | src/vm/jvm/ (2 files):

[15:28] <dalek> nqp: Eliminate arg array assembly in sub call code.

[15:28] <dalek> nqp: 

[15:28] <dalek> nqp: Instead, we use invokedynamic to do it, which reduces the amount of

[15:28] <dalek> nqp: code we generate for sub argument passing. Also should hopefully give

[15:28] <dalek> nqp: better performance, since we're delegating this assembly work to the

[15:28] <dalek> nqp: combinators provided by the JVM, which presumably it knows how to work

[15:28] <dalek> nqp: with efficiently.

[15:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/746aa35258

[15:28] <dalek> nqp: 1d725ae | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/IndyBootstrap.java:

[15:28] <dalek> nqp: Fix invokedynamic handling of lexotic.

[15:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1d725ae80e

[15:28] <dalek> nqp: 2696e10 | jnthn++ | src/NQP/Actions.nqp:

[15:28] <dalek> nqp: Make return code-gen something more optimizable.

[15:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2696e10b27

[15:29] *** FROGGS left
[15:34] *** dmol joined
[15:36] *** daxim left
[15:40] <spider-mario> trying to compile nqp for the jvm outputs:

[15:40] <spider-mario> Unknown compilation target 'classfile'

[15:40] <spider-mario> am I doing it wrong?

[15:41] <spider-mario> (I ran perl ConfigureJVM.pl --prefix=(…); then make)

[15:41] <jnthn> spider-mario: Sounds like something I fixed yesterday, if it comes towards the end of the build

[15:42] <spider-mario> oh, I think I know

[15:42] <spider-mario> I built a parrot nqp in the same directory

[15:42] <spider-mario> I’ll try to clean and do it again

[15:43] *** TimToady_ is now known as TimToady

[15:43] *** TimToady left
[15:43] *** TimToady joined
[15:49] *** domidumont left
[15:49] *** tgt left
[15:56] <spider-mario> it worked

[15:56] <spider-mario> :)

[15:59] <sjn> moritz: heya, what's up with the irclog? (Can't seem to reach it :-\)

[16:00] <masak> sjn: <moritz> the host is down

[16:01] <masak> [Coke]: yes, https://rt.perl.org/rt3/Ticket/Display.html?id=73230 is closeable now.

[16:01] <sjn> ook

[16:05] *** kshannon left
[16:12] *** kshannon joined
[16:20] *** orevdiabl left
[16:20] *** revdiablo joined
[16:25] *** kaleem joined
[16:30] *** FROGGS joined
[16:33] *** sqirrel joined
[16:34] *** kaleem left
[16:56] *** sjohnson joined
[16:56] *** sjohnson left
[16:56] *** sjohnson joined
[16:58] *** Chillance joined
[17:19] *** SmokeMachine left
[17:19] *** SmokeMachine joined
[17:22] *** thou joined
[17:31] *** domidumont joined
[17:54] <cognominal> r:    'hi' ~~  / hi { say matched 'hi '} /;

[17:54] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared routine:␤    matched used at line 1␤␤»

[17:55] <cognominal> oops

[17:55] <cognominal> r:    'hi' ~~  / hi { say 'matched hi '} /;

[17:55] <camelia> rakudo 71ea14: OUTPUT«matched hi ␤»

[18:05] *** geekosaur left
[18:05] *** ingy left
[18:06] *** ingy joined
[18:07] *** shachaf joined
[18:09] *** geekosaur joined
[18:11] *** shachaf left
[18:14] *** SmokeMac_ joined
[18:15] *** SmokeMachine left
[18:15] *** shachaf joined
[18:17] *** geekosaur left
[18:19] *** colomon left
[18:20] *** shachaf left
[18:20] *** colomon joined
[18:25] *** grondilu joined
[18:25] <grondilu> rn: package Foo { our $msg; our sub talk { say $msg } }; $Foo::msg = "hello"; Foo::talk;

[18:25] <camelia> rakudo 71ea14: OUTPUT«(Any)␤»

[18:25] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«hello␤»

[18:26] *** geekosaur joined
[18:27] *** domidumont left
[18:33] *** geekosaur left
[18:34] *** shachaf joined
[18:38] *** bluescreen100 joined
[18:38] *** shachaf left
[18:38] *** bluescreen10 left
[18:40] *** frdmn left
[18:42] *** rurban joined
[18:49] *** tgt joined
[18:58] *** lustlife left
[18:59] *** lustlife joined
[19:00] *** raiph left
[19:01] *** SamuraiJack joined
[19:02] *** SmokeMachine joined
[19:02] *** sqirrel left
[19:03] <masak> n: say val("003")

[19:03] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«003␤»

[19:03] <masak> n: say +val("030")

[19:03] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«30␤»

[19:04] *** SmokeMac_ left
[19:06] <lizmat> r: say val("030")

[19:06] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared routine:␤    val used at line 1. Did you mean '&eval'?␤␤»

[19:06] <lizmat> NYI

[19:06] <lizmat> check

[19:11] *** rindolf left
[19:12] *** rindolf joined
[19:14] <lizmat> n: say ~val(30)

[19:14] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«30␤»

[19:14] <lizmat> n: say ~val(30).WHAT

[19:14] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Int()␤»

[19:14] <lizmat> shouldn't that be Str ?

[19:17] *** japhb_ joined
[19:22] <masak> lizmat: method calls bind tighter than prefixes.

[19:22] <masak> n: say (~val(30)).WHAT

[19:22] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(Str)␤»

[19:23] <masak> heh, "Int()", "(Str)".

[19:23] <lizmat> n: say (+val("030")).WHAT

[19:23] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(Int)␤»

[19:23] <dalek> perl6-roast-data: 41d6282 | coke++ | / (4 files):

[19:23] <dalek> perl6-roast-data: today (automated commit)

[19:23] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/41d6282911

[19:24] <lizmat> n: say 30.WHAT

[19:24] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(Int)␤»

[19:24] <lizmat> n: say val(30).WHAT

[19:24] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(Int)␤»

[19:24] <lizmat> n: say ~val(30).WHAT

[19:24] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Int()␤»

[19:24] <lizmat> weird

[19:25] <[Coke]> rakudo has been clean for 1 day.

[19:25] <timotimo> r: my $kb = KeyBag.new(0.5 => "a", 1.5 => "b"); say $kb.gist; # how do i make proper numbers as keys here?

[19:25] <camelia> rakudo 71ea14: OUTPUT«keybag("0.5" => "a", "1.5" => "b")␤»

[19:25] <grondilu> rn: package Foo { our $msg; our sub talk { say $msg } }; $Foo::msg = "hello"; Foo::talk;  # posted again, just to make sure I hve your attention

[19:25] <camelia> rakudo 71ea14: OUTPUT«(Any)␤»

[19:25] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«hello␤»

[19:26] *** daniel-s__ joined
[19:26] <grondilu> rn: package Foo { our $msg = "hello"; our sub talk { say $msg } }; $Foo::msg = "bye"; Foo::talk;

[19:26] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«bye␤»

[19:27] <timotimo> so it only works in rakudo if Foo::msg already has a value?! that's strange :)

[19:27] <grondilu> strange indeed.

[19:28] <grondilu> rn: package Foo { our Str $msg; our sub talk { say $msg } }; $Foo::msg = "bye"; Foo::talk;

[19:28] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Cannot put a type constraint on an 'our'-scoped variable␤at /tmp/wJimU9qRlP:1␤------> package Foo { our Str $msg⏏; our sub talk { say $msg } }; $Foo::msg␤    expecting any of:␤        scoped declarator␤        const…

[19:28] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Common variables are not unique definitions and may not have types at /tmp/JNJzkBNUGj line 1:␤------> package Foo { our Str $msg⏏; our sub talk { say $msg } }; $Foo::msg␤␤Unhandled exception: Check failed␤…

[19:28] <grondilu> oops, didn't know that.

[19:28] <timotimo> oh? maybe that's the key.

[19:28] *** daniel-s_ left
[19:30] <timotimo> it may even be to spec in rakudo and niecza is out of sync with the specs? dunno

[19:31] *** rindolf left
[19:32] <timotimo> std:  package Foo { our $msg = "hello"; our sub talk { say $msg } }; $Foo::msg = "bye"; Foo::talk;

[19:33] <camelia> std 86b102f: OUTPUT«ok 00:00 44m␤»

[19:33] <timotimo> std:  package Foo { our $msg = "hello"; our sub talk { say $msg } }; $Foo::msg = "bye"; Foo::talk;

[19:33] <camelia> std 86b102f: OUTPUT«ok 00:00 44m␤»

[19:33] <timotimo> oh?

[19:33] <labster> good morning, everyone

[19:35] <masak> hi, labster 

[19:36] <nwc10> jnthn: WTF did you just do? nqp head is 28% faster than 5 hours ago

[19:36] <timotimo> whoa.

[19:36] <timotimo> there is obviously much performance to be had.

[19:36] <timotimo> nwc10: what's the comparison to parrot-nqp by now?

[19:36] <nwc10> fbf65e4041e306e288436a3e7192082edda22677 is 2.0683e+02 +/- 8.2e-01

[19:37] <nwc10> 2696e10b27803eb7b0d1f8317fcdba340d4b8e3c is 1.4725e+02 +/- 7.2e-01

[19:37] *** woolfy1 joined
[19:37] <nwc10> there will be a delay while I try to answer that

[19:38] <nwc10> 5 hours might be an exaggeration. Possibly it's 8

[19:38] <timotimo> whoa.

[19:38] <timotimo> do you take that long to build? or do you have a huge benchmark suite?

[19:39] <nwc10> no, it's one program run under dumbbench that takes a while

[19:39] <nwc10> it most definately isn't a benchmark suite, or representative

[19:39] <nwc10> but it is the *same* program :-)

[19:39] <jnthn> nwc10: fbf65e was from last night just before I started doing invokedynamic changes

[19:39] <nwc10> it's the levenstein code for the variable names, extracted, and looping

[19:40] <nwc10> oh, OK. Nearly 24 hours

[19:40] <nwc10> that's much less impressive :-)

[19:40] <jnthn> Well, it depends what is to thank for it

[19:40] <timotimo> ah, i'm glad my code still gets used for miscellaneous stuff :D

[19:41] <nwc10> yes, about 6 commits. After I try to answer the parrot question, I'll see if I can work if if any particular commit was the "problem"

[19:41] <jnthn> 2a34af7 was the initial introduction for sub calls. 55e954c were some minor improvements. 746aa35 greatly improved arg handling for sub calls.

[19:41] <nwc10> actually, so it's not fbf6

[19:41] <jnthn> And from there to HEAD optimized return 

[19:41] <nwc10> I think I had one that was 1.9+e02 from today

[19:41] <nwc10> so, sorry, it's probably only 20%. Not 28%

[19:42] <lizmat> I'll take 20% any day

[19:42] <jnthn> Sure, that still means 28% since < 24 hours, though? ;)

[19:42] <nwc10> <aol>me too</aol>

[19:42] <nwc10> jnthn: yes, I guess so :-)

[19:43] <lizmat> I assume this has nothing to do with fixing the slowdown that masak saw with string concatenation I believe?

[19:43] <nwc10> I don't know for sure, but I think it's far more likely to be with jnthn reducing sub call overhead

[19:44] <nwc10> something like "I love it when a plan comes together"

[19:47] * lizmat imagines jnthn with a big cigar and a glass of bourbon

[19:51] *** mathw_ is now known as mathw

[19:54] *** geekosaur joined
[19:56] <masak> 19 signups for https://github.com/perl6/mu/wiki/perl6-workshop-may-2013 -- amazing.

[19:56] <masak> I'm planning it now, and from what I can see, it's gonna be great :>

[19:56] <mathw> \o/

[19:57] <labster> I'm looking forward to it

[19:57] <masak> in a week, we'll all be looking backward to it :)

[19:57] <lizmat> and be much wiser :-)

[19:58] <labster> and much more beautiful

[19:58] <lizmat> ah, maybe on the inside, I don't think the outside can be fixed on IRC

[20:00] <census> masak++

[20:00] <mathw> it's going to be grand I'm sure

[20:01] <mathw> Although I won't be there I will be keen to hear about it afterwards

[20:01] *** thou left
[20:02] <masak> chances are we'll get _ilbot back by then :)

[20:03] <mathw> :)

[20:03] <mathw> It's on my birthday, as it happens, and I'll be spending the evening at aikido helping teach one of my favourite techniques :)

[20:05] <masak> ooh! enjoy!

[20:05] <mathw> I need to talk to the instructor for that night to make sure he's actually going to do that

[20:05] <mathw> it's on the schedule, but I will make a special request

[20:06] <mathw> Sometimes he decides to change the timetable

[20:06] *** census left
[20:07] <lizmat> rn: constant foo=1; sub foo {say "hi"}; foo; foo

[20:07] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2:  ( no output )

[20:07] <lizmat> should the definition of a sub with the same name as a constant generate a warning?

[20:08] <lizmat> rn: sub foo { say "hello" }; sub foo {say "hi"}; foo

[20:08] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Redeclaration of routine foo␤at /tmp/j8eu8XAmDw:1␤------>  foo { say "hello" }; sub foo {say "hi"}⏏; foo␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modif…

[20:08] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Illegal redeclaration of routine 'foo' (see line 1) at /tmp/MoFgdeW1EM line 1:␤------> sub foo { say "hello" }; sub foo ⏏{say "hi"}; foo␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/li…

[20:09] <lizmat> or even bomb like this?

[20:09] <jnthn> The sub is installed as &foo, not foo, so there's no immediate conflict.

[20:10] <masak> lizmat: same name as a constant: no, because the names aren't the same.

[20:10] <jnthn> The warning I might expect is that a constant is in sink context.

[20:10] <masak> what jnthn said.

[20:11] <lizmat> constant foo=1; sub foo {say "hi"}; foo; &foo

[20:11] <lizmat> r: constant foo=1; sub foo {say "hi"}; foo; &foo

[20:11] <camelia> rakudo 71ea14:  ( no output )

[20:11] <lizmat> r: constant foo=1; sub foo {say "hi"}; foo; foo()

[20:11] <camelia> rakudo 71ea14: OUTPUT«hi␤»

[20:11] <lizmat> shouldn't &foo and foo() be the same here then?

[20:12] <masak> no.

[20:12] <lizmat> or is that my perl 5 background confusing me?

[20:12] <masak> that's Perl 5 think :)

[20:12] <masak> the sigil doesn't make the call happen, the parens do.

[20:12] <jnthn> &foo is a noun

[20:13] * lizmat has met a false friend

[20:13] <tadzik> hello hello

[20:14] <mathw> heh that makes it look like tadzik is lizmat's new false friend

[20:15] <lizmat> r: foo; constant foo=1; sub foo {say "hi"}

[20:15] <camelia> rakudo 71ea14: OUTPUT«hi␤»

[20:16] <lizmat> r: foo; constant foo=1; sub foo {say "hi"}; foo

[20:16] <camelia> rakudo 71ea14: OUTPUT«hi␤»

[20:16] <lizmat> S02:4154 "You still must declare your subroutines, but a bareword with an unrecognized

[20:16] <lizmat> name is provisionally compiled as a subroutine call, on the assumption that

[20:16] <lizmat> such a declaration will occur by the end of the current compilation unit:"

[20:16] <masak> tadzik! \o/

[20:16] <lizmat> r: foo; constant foo=1; sub foo {say "hi"}; say foo

[20:16] <camelia> rakudo 71ea14: OUTPUT«hi␤1␤»

[20:17] <lizmat> r: say foo; constant foo=1; sub foo {"hi"}; say foo

[20:17] <camelia> rakudo 71ea14: OUTPUT«hi␤1␤»

[20:17] <lizmat> I assume this is logical, but it is counter-intuitive at least to me

[20:19] <tadzik> masak! \o/

[20:19] <mathw> did it call foo() and then output the value of foo??

[20:19] <tadzik> mathw: how's your t430? :)

[20:19] <mathw> tadzik: lovely!

[20:19] <tadzik> mathw: you know what

[20:19] <tadzik> I ordered mine on tuesday

[20:19] <mathw> hahaha

[20:19] <mathw> I hope you like it as much as I like mine

[20:19] <masak> lizmat: what's your desired semantics? name collision?

[20:19] <tadzik> I asked the guy yesterday, "when is it going to arrive?"

[20:19] <lizmat> r: say foo; constant foo="constant"; sub foo {"sub"}; say foo

[20:19] <camelia> rakudo 71ea14: OUTPUT«sub␤constant␤»

[20:19] <tadzik> and he answered "I'm probably going to send it on monday"

[20:20] <tadzik> what a basterd :|

[20:20] <lizmat> well, either that or disallow a bareword as a provisional subroutine call

[20:20] <mathw> faster than mine

[20:20] <tadzik> well, I expected it to arrive today at worst

[20:20] <jnthn> .oO( that's a crappy of "bastard" :P )

[20:20] <jnthn> *crappy spelling

[20:20] <tadzik> my sl500 is quite falling apart

[20:21] <tadzik> which doesn't surprise me, considering what I put it through

[20:23] <lizmat> masak: it shouldn't matter whether a sub definition has been seen

[20:24] <lizmat> whether "foo" is a sub call or a constant

[20:25] <lizmat> as you just said: the parens make a sub call, so why aren't they needed when the sub is not defined yet?

[20:26] <lizmat> I would therefore suggest that S02:4158 changes thus:

[20:26] <lizmat> -    foo;         # provisional call if neither &foo nor ::foo is defined so far

[20:26] <lizmat> +    foo;         # not a provisional call since only () force calling the sub

[20:27] <lizmat> *forces

[20:27] <masak> lizmat: hold on, hold on.

[20:27] *** frdmn joined
[20:27] * lizmat is holding on

[20:27] <masak> lizmat: as another data point, nothing you've said or shown so far really surprises me as a sixer.

[20:27] <lizmat> that "foo" does different things depending on order of compilation?

[20:28] <masak> lizmat: besides, this is a very narrow corner case we're talking about, where the programmer *in her own scope* overloads a subroutine name with a constant name.

[20:28] *** SamuraiJack left
[20:28] <masak> lizmat: we agree that Perl 6 is one-pass, yes? by necessity.

[20:28] <lizmat> agree, as per spec

[20:28] <masak> good.

[20:28] <masak> in that light, I find the current semantics very reasonable.

[20:29] <masak> it's sort of a "best guess".

[20:29] <jnthn> Well, we could consider it an illegal post-decl.

[20:29] <lizmat> r: say foo; sub foo {"hi"}; say foo

[20:29] <camelia> rakudo 71ea14: OUTPUT«hi␤hi␤»

[20:29] <jnthn> r: A; class A { }

[20:29] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Illegally post-declared type:␤    A used at line 1␤␤»

[20:29] <masak> jnthn: yes, that's a variant. I could accept that.

[20:30] <masak> that's like "you implicitly agreed to the assumption to treat this as a function call, and then you went and invalidated that same assumption. ERROR"

[20:30] <masak> lizmat: what do you think?

[20:30] <lizmat> that seems logical to me

[20:30] *** sorear left
[20:30] <mathw> I'm still finding it weird that constants and subs don't seem to share a namespace

[20:30] <lizmat> r: foo; constant foo=1

[20:30] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (lines 1, 1)␤»

[20:30] <gtodd>  /j #parrot

[20:31] <gtodd> oops

[20:31] <mathw> or rather they kind of maybe do. Maybe I've been doing too much C# lately.

[20:31] <masak> mathw: it's more like, subs get to sometimes hang out in the constants' namespace.

[20:31] <lizmat> masak,jnthn: so "foo; constant foo=1" would become such an error?

[20:31] <masak> lizmat: yes.

[20:32] <lizmat> that would make sense, yes

[20:32] <mathw> I wouldn't object to postdeclared subs being illegal too, but that's not very Perlish is it :)

[20:32] <masak> I'd still like to hear what TimToady thinks about this. but in the meantime, maybe one of us could write this up as a spec issue?

[20:32] <TimToady> sub foo is really in the & namespace; the use of bare foo is a special case

[20:32] <jnthn> std: foo; constant foo=1

[20:32] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Illegally post-declared type:␤       'foo' used at line 1␤Check failed␤FAILED 00:00 41m␤»

[20:32] <masak> mathw: postdeclared subs are staying :) that's how you do mutual recursion :)

[20:33] <jnthn> bah, to the degree STD is spec, STD already has it that way...

[20:33] <masak> heh.

[20:33] <TimToady> constants are in the type namespace as barewords, no &

[20:33] <mathw> masak: yeah I know they're useful :)

[20:33] <masak> shall I submit a rakudobug?

[20:34] <lizmat> masak: fwiw, I was *not* against post-declared subs

[20:34] <diakopter> darn, just missed TimToady

[20:34] *** sorear joined
[20:34] <masak> lizmat: yes, I know.

[20:34] <lizmat> just that a bareword would be encoded as a call to a sub before declaration was seen

[20:34] <lizmat> ok

[20:36] <TimToady> diakopter: was someone shooting at me?  :)

[20:36] <diakopter> oh, I saw the trailing &

[20:37] <masak> *lol*

[20:38] *** skids left
[20:38] * masak .oO( darn, just missed diakopter )

[20:39] <TimToady> nr: pi; constant pi = 3;

[20:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Lexical symbol 'pi' is already bound to an outer symbol (see ??? line 0);␤  the implicit outer binding at line 1 must be rewritten as pi␤  before you can unambiguously declare a new 'pi' in this scope at /tmp/0L1j5YIuDc line…

[20:39] <camelia> ..rakudo 71ea14:  ( no output )

[20:39] <masak> ooh, STDbug.

[20:39] <lizmat> rn: pi; constant pi = 3; say pi

[20:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Lexical symbol 'pi' is already bound to an outer symbol (see ??? line 0);␤  the implicit outer binding at line 1 must be rewritten as pi␤  before you can unambiguously declare a new 'pi' in this scope at /tmp/Zd1bkwxfs0 line…

[20:39] <camelia> ..rakudo 71ea14: OUTPUT«3␤»

[20:39] <TimToady> std: pi; constant pi = 3

[20:39] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Lexical symbol 'pi' is already bound to an outer symbol (see CORE.setting line 95);␤  the implicit outer binding at line 1 must be rewritten as OUTER::OUTER::<pi>␤  before you can unambiguously declare a new 'pi' in this scope at /tmp/j…

[20:40] <TimToady> huh

[20:40] <masak> oh, it wasn't STD.

[20:40] <masak> the bug's in Niecza.

[20:40] <TimToady> it's the OUTER:: limits

[20:40] <lizmat> eerie music abounds

[20:40] <TimToady> std: OUTER::pi; constant pi = 3;

[20:40] <camelia> std 86b102f: OUTPUT«ok 00:00 41m␤»

[20:41] * TimToady wonders why the double OUTER

[20:41] <diakopter> we control the horizontal, but not quite the vertical

[20:43] <lizmat> rn: constant foo=1; constant foo=2; say foo

[20:43] <camelia> rakudo 71ea14: OUTPUT«2␤»

[20:43] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Illegal redeclaration of symbol 'foo' (see line 1) at /tmp/d6O2LmsOMT line 1:␤------> constant foo=1; constant foo⏏=2; say foo␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.set…

[20:43] <lizmat> that doesn't seem right in rakudo either, or does it?

[20:44] <TimToady> std: constant foo=1; constant foo=2; say foo

[20:44] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Illegal redeclaration of symbol 'foo' (see line 1) at /tmp/eiRVcuRNBP line 1:␤------> constant foo=1; constant foo⏏=2; say foo␤Check failed␤FAILED 00:00 42m␤»

[20:44] <diakopter> r: eval 'my $OUTER::foo = 45'; say eval '$foo'

[20:44] <camelia> rakudo 71ea14: OUTPUT«Cannot modify an immutable value␤  in block  at eval_0:1␤  in any  at eval_0:1␤  in sub eval at src/gen/CORE.setting:602␤  in sub eval at src/gen/CORE.setting:593␤  in block  at /tmp/xrWh4VGeVF:1␤␤»

[20:45] <TimToady> the 'immutable value' here being the closed lexpad

[20:46] <diakopter> r: eval 'my \OUTER::foo = 45'; say eval '$foo'

[20:46] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'NQPMu'␤»

[20:46] <diakopter> you're an ast

[20:47] <diakopter> r: my \OUTER::foo = 45

[20:47] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'NQPMu'␤»

[20:47] <TimToady> std: my \OUTER::foo = 45

[20:47] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Term definition requires an initializer at /tmp/5_ATXwfLVG line 1:␤------> my \OUTER⏏::foo = 45␤Confused at /tmp/5_ATXwfLVG line 1:␤------> my \OUTER:⏏:foo = 45␤    expecting any of:␤        coloncircumfix…

[20:48] <TimToady> no :: allowed in a term

[20:50] * TimToady had better sleep off this Novocaine®, not that a geezer needs an excuse to sleep...

[20:51] <TimToady> look, ma, no &

[20:54] <masak> TimToady: sleep well. dream of full STD compliance, everywhere.

[20:56] * lizmat is wondering how something can generate an error in STD, and not in Rakudo?

[20:56] <mathw> because Rakudo doesn't always match STD's rules yet

[20:57] <lizmat> ah, so rakudo doesn't use std as its grammar…  Hmmmm...

[20:58] * lizmat hadn't realised that

[20:59] <mathw> Ultimately it would be good if it did, but obviously to start with it couldn't because it wouldn't have been able to cope... LTM being a particular issue

[21:00] <jnthn> Well, it's not like exactly using STD is a goal either.

[21:00] * lizmat hadn't realised that either

[21:00] <mathw> I kind of thought it was

[21:00] <mathw> but I'm rather out of touch :)

[21:00] <jnthn> Accepting the programs STD does, and rejecting the ones STD does with at least as good error messages is a goal, for sure.

[21:00] <masak> Niecza is fairly close to STD. it's basically an implementation of STD, if I understand correctly.

[21:01] <masak> and Rakudo has been nudging closer in *spriit* to STD for a long time now.

[21:01] <jnthn> masak: Even Niecza diverged some amount - because you *have* to if you want to write a Perl 6 implementation, not just a Perl 6 parser.

[21:01] <sorear> STD needs some fairly substantial tweaks to be usable as a compiler frontend

[21:01] <masak> yeah.

[21:02] * lizmat learned a lot today

[21:04] <[Coke]> "we learned something today."

[21:07] <mathw> no day in which you learn something is a loss

[21:10] <lizmat> wisdom it is you speak

[21:11] <mathw> it's a bit pat really

[21:11] <mathw> but it's true

[21:12] *** BenGoldberg joined
[21:15] *** toddr joined
[21:16] *** mattp__ joined
[21:17] *** mattp_ left
[21:29] *** raiph joined
[21:33] <lizmat> rn: my (|$a) := { "hello" }

[21:33] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Cannot use bind operator with this LHS at /tmp/5e4vPb5hmL line 1 (EOF):␤------> my (|$a) := { "hello" }⏏<EOL>␤␤Potential difficulties:␤  Unsupported use of | with sigil; nowadays please use | without sigil…

[21:33] <camelia> ..rakudo 71ea14: OUTPUT«Obsolete use of | or \ with sigil on param $a␤»

[21:33] <lizmat> S02:5175 gives this example

[21:34] <lizmat> does that imply the spec is outdated as well?

[21:35] <masak> think so.

[21:35] <masak> it's porbably just |a these days.

[21:35] <masak> but don't take my word for it.

[21:36] <diakopter> lizmat: sounds like a candidate for clarification/updating in the list

[21:36] <lizmat> will add

[21:36] <diakopter> anyone else familiar with the implementations want to take on another Syn?

[21:37] <lizmat> actually, it is S03:5175

[21:37] <diakopter> masak: you're not allowed to volunteer; you owe me a few thousand slides or something

[21:37] <masak> yeah, something like that.

[21:38] <masak> probably an even thousand, though. not a few thousand.

[21:41] *** bluescreen100 left
[21:46] *** bruges_ joined
[21:48] *** bruges left
[21:49] *** xilo left
[21:53] *** xilo joined
[21:53] *** Chillance left
[22:00] <lizmat> rn: goto "foo"

[22:00] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Illegal control operator: goto(foo, dynamic)␤  at /home/p6eval/niecza/lib/CORE.setting line 1530 (_lexotic @ 8) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1532 (goto @ 4) ␤  at /tmp/JDK814MATF line 1 (mainline @ 3) ␤  at /home/p6e…

[22:00] <camelia> ..rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared routine:␤    goto used at line 1␤␤»

[22:00] <diakopter> lizmat: :)

[22:00] <dalek> nqp: 18640c0 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[22:00] <dalek> nqp: Fix some stack management issues.

[22:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/18640c0acf

[22:00] <dalek> nqp: 8bf2ac7 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[22:00] <dalek> nqp: Scatter some stack spilling operations.

[22:00] <dalek> nqp: 

[22:00] <dalek> nqp: Get us towards enforcing "stack empty on call", which will simplify

[22:00] <dalek> nqp: using invokedynamic for methods but, more importantly, is a prereq for

[22:00] <dalek> nqp: coroutine support which Rakudo will need.

[22:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8bf2ac7420

[22:00] <dalek> nqp: 359abcc | jnthn++ | src/vm/jvm/ (2 files):

[22:00] <dalek> nqp: Basic invokedynamic handling for methods.

[22:00] <dalek> nqp: 

[22:01] <dalek> nqp: Gets the dispatch logic out of the generated code, which in the case

[22:01] <dalek> nqp: of the method-call heavy QAST compiler knocks a third off the size of

[22:01] <dalek> nqp: the output. Not really faster yet; need to stack a PIC-ish thing up in

[22:01] <dalek> nqp: the callsite for that.

[22:01] <dalek> nqp: review: https://github.com/perl6/nqp/commit/359abcc4f7

[22:02] <timotimo> r: my $kb = KeyBag.new(0.5 => "a", 1.5 => "b"); say $kb.gist; say "i didn't get an answer to this before. how do i turn the keys into proper numbers?"

[22:02] <camelia> rakudo 71ea14: OUTPUT«keybag("0.5" => "a", "1.5" => "b")␤i didn't get an answer to this before. how do i turn the keys into proper numbers?␤»

[22:03] <flussence> r: my KeyBag[Num] $kb;

[22:03] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Type KeyBag cannot accept type arguments␤»

[22:03] <flussence> well there goes that idea...

[22:04] <lizmat> rn: my $kb = KeyBag.new(0.5 => "a", 1.5 => "b"); say $kb.keys.gist

[22:04] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«0.5 1.5␤»

[22:04] <lizmat> not sure if I understand the issue

[22:04] <masak> flussence: the keys should be proper numbers by default, I *think*...

[22:04] <masak> flussence: unless KeyBag defaults to Str keys, like Hash does.

[22:04] *** lustlife left
[22:04] <masak> flussence: I'm actually not sure. TimToady?

[22:04] <lizmat> rn: my $kb = KeyBag.new(0.5 => "a", 1.5 => "b"); say $_.WHAT for $kb.keys

[22:04] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Str)␤(Str)␤»

[22:05] <lizmat> rn: my $kb = KeyBag.new(0.5 => "a", 1.5 => "b"); say (+$_).WHAT for $kb.keys

[22:05] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Rat)␤(Rat)␤»

[22:06] * lizmat looks up specs on KeyBag

[22:07] <lizmat> "A mutable C<Bag> container, represented as C<KeyHash of UInt>."

[22:07] <lizmat> so you're saying it should die on using "0.5" as a key?

[22:08] *** arlinius joined
[22:08] <diakopter> lizmat: oh, I kinda skimmed over that part on S02 b/c I wasn't familiar with rakudo's status

[22:08] <lizmat> the way I understand KeyBag, is that the *values* are UInt

[22:10] <lizmat> "A C<KeyHash> represents a mutable set of values, represented as the keys

[22:10] <lizmat> of a C<Hash>.  When asked to behave as a list it ignores its values

[22:10] <lizmat> and returns only C<.keys>.  C<KeySet> and C<KeyBag> are derived from

[22:10] <lizmat> this type, but constrain their values to be C<Bool> and C<UInt>,

[22:10] <lizmat> respectively."

[22:10] <sorear> not Int?

[22:11] <lizmat> the spec says UInt

[22:11] <lizmat> S32/Containers:1212

[22:11] *** jac50 joined
[22:12] *** toddr_ joined
[22:13] <sorear> no love for homology eh

[22:14] <masak> please explain.

[22:14] <masak> what use would KeyBag have from being able to have negative values?

[22:15] <lizmat> rn: my $kb = KeyBag.new(a=>"b"); $kb<a>++; say $kb<a>; say $kb<a>.WHAT

[22:15] <camelia> rakudo 71ea14: OUTPUT«1␤(Int)␤»

[22:15] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Excess arguments to KeyBag.new, unused named a␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (KeyBag.new @ 1) ␤  at /tmp/iD6iVRzSeC line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6…

[22:15] *** shachaf joined
[22:15] *** toddr left
[22:16] <flussence> I suspect the spec's using an unreasonably narrow type just for the unsignedness...

[22:16] <lizmat> fwiw, I think not having negative values is right, good and as intended

[22:16] <lizmat> a bag can contain 0 or more copies of an item

[22:17] *** thou joined
[22:17] <lizmat> not -1 copies of an item

[22:17] <sorear> masak: free abelian group on a type of generators

[22:17] <sorear> masak: there are natural objects in several fields of math that look like signed keybags

[22:18] <sorear> elliptic curve divisors, homology classes

[22:18] <masak> sorear: interesting.

[22:18] <sorear> factor representations of rationals / relations in the quadratic sieve and derivatives

[22:19] <masak> sorear: fwiw, I'm actively studying group theory and category theory at present. every day I'm more well-equipped to understand what you're saying without using Wikipedia as an adapter :)

[22:20] <flussence> .oO( it's not too hard to turn those fractions into whole numbers, @values *= ([+] @values).denominator; )

[22:20] <masak> sorear: but I'm kinda inclined to agree with lizmat here. at least until I understand the benefits of allowing negative integers.

[22:20] <lizmat> maybe you want KeyWeight?

[22:21] <sorear> the only algorithm I can think of offhand that would use this is the quadratic sieve

[22:21] <lizmat> "A C<KeyHash of FatRat>; like a C<KeyBag> but may have non-integral

[22:21] <lizmat> weights for use in weighted picking."

[22:21] <sorear> lizmat: maybe

[22:21] <lizmat> it specifically mentions negative values:

[22:21] <lizmat> "Keys with fractional weights

[22:21] <lizmat> are deleted if they go to 0.  Negative weights are not deleted, but

[22:21] <lizmat> the implementation may complain if it notices you attempting to use

[22:21] <lizmat> such a weight.

[22:21] <lizmat> "

[22:23] *** grondilu left
[22:25] <masak> I don't see why it should complain. depending on the domain, that may be perfectly legit.

[22:26] *** adu joined
[22:28] *** adu left
[22:29] <lizmat> hence the *may* ?

[22:30] <masak> yes, but how will it know? :)

[22:31] <lue> hello world o/

[22:32] *** adu joined
[22:32] <lizmat> masak: no idea

[22:32] <lizmat> more worringly:

[22:32] <lizmat> rn: say KeyBag.new(a=>"b")<a>

[22:32] <camelia> rakudo 71ea14: OUTPUT«0␤»

[22:32] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Excess arguments to KeyBag.new, unused named a␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (KeyBag.new @ 1) ␤  at /tmp/Qqhm9N9Ikq line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6…

[22:32] <masak> Niecza has it right.

[22:32] <timotimo> i was interested in a KeyBag with fractional numbers rather than integers to get the .pick/.roll behavior that uses the values for probability

[22:33] <sorear> MAY.  or perhaps SHOULD, or SHOULD NOT

[22:33] <timotimo> (and now i realize that using 0.5 => 2 is idiotic, because the key is the value and the value is how often it is in there)

[22:33] <lizmat> aha...

[22:33] <masak> lizmat: there's a tension there between routine arguments and hash pairs.

[22:33] <masak> lizmat: and in a .() the former wins by default.

[22:34] <masak> lizmat: I believe S02 or S06 details how to get around that.

[22:34] <masak> rn: say KeyBag.new( (a=>"b") )<a>

[22:34] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«b␤»

[22:34] <timotimo> why do the () make a difference?

[22:35] <masak> timotimo: because what I just said.

[22:35] <timotimo> oh, in the one case it will be unpacked, in the other it won't?

[22:35] *** dmol left
[22:35] <masak> timotimo: there's a tension between routine arguments and hash pairs.

[22:35] <timotimo> ah, i read that as "routing arguments" and was parsefail

[22:35] * masak .oO( "the deneuralizer" )

[22:35] <lizmat> but but, shouldn't a keybag only contain uints as values

[22:36] <masak> yes.

[22:36] <lizmat> and complain about "b" being passed as a value?

[22:36] <masak> yes.

[22:36] * masak submits rakudobug

[22:37] <adu> what does {YOU_ARE_HERE} mean?

[22:38] <adu> https://github.com/perl6/nqp/blob/master/src/NQP/Grammar.nqp#L197

[22:40] *** spider-mario left
[22:40] <lizmat> adu: S02:2631 and following

[22:41] * lizmat must admit not completely grokking that section of the spec

[22:46] <lue> my understanding is that it basically means YOUR CODE GOES HERE, where "you" are the user of the language with a P6 script.

[22:47] *** PacoAir left
[22:47] <lue> (in rakudo's setting, it is the very last statement in the generated CORE.setting file)

[22:48] <lizmat> timotimo: maybe you want something like:

[22:48] <lizmat> rn: my $kb= KeyBag.new((a => 1, b => 10)); say $kb.pick(*)

[22:48] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«b b b b b b a b b b b␤»

[22:48] <camelia> ..rakudo 71ea14: OUTPUT«b b b b b a b b b b b␤»

[22:50] <lizmat> rn: my $kb= KeyBag.new((a => 1, b => 1)); say $kb.pick; say $kb.perl; say $kb.pick

[22:50] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«a␤KeyBag.new({"a" => 1, "b" => 1}.hash)␤b␤»

[22:50] <camelia> ..rakudo 71ea14: OUTPUT«b␤KeyBag.new(("a" => 1, "b" => 1).hash)␤b␤»

[22:50] <lizmat> two "b"?s

[22:51] <lizmat> is this the Perl 5 bug/feature "each" iterator being reset by "keys" all over again?

[22:51] <sorear> sure

[22:52] <sorear> lizmat: no, "pick" selects an element at random

[22:53] <sorear> run it again and you'll get a different answer (with probability 15/16)

[22:54] <lizmat> aha, I read the spec as "pick" attaching some magic that would keep how many times it had already picked values

[22:54] <sorear> no, it only keeps that state within a single call

[22:54] <lizmat> but it is only within the .pick method call that the "without" replacement part is actually taking place

[22:54] <lizmat> indeed

[22:56] <lizmat> I guess this can be easily subclassed with .pick doing a .pick(*), saving that in an array and then shifting values out as requested

[22:57] <lizmat> rn: my $kb= KeyBag.new((a => 1, b => 1)); say $kb.pick(3).elems

[22:57] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«2␤»

[22:58] <lizmat> wonder whether or not that should be a warning/error

[22:59] <lizmat> picking N elements from a M picks keybag where N > M

[23:01] <sorear> it's sort of expected that it's not

[23:01] <sorear> rn: say [1..5].pick(10).elems

[23:01] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«5␤»

[23:01] <sorear> overpicks always limit

[23:02] *** census joined
[23:02] <lizmat> it's not specced what should happen

[23:02] <lizmat> afaik

[23:03] <TimToady> I believe it's specced somewhere...

[23:03] <BenGoldberg> rn: my @a=^Inf; my @b = @a; shift @a; say @b[^5];

[23:03] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)»

[23:03] <camelia> ..rakudo 71ea14: OUTPUT«1 2 3 4 5␤»

[23:04] <TimToady> yes, S32/Containers, line 258

[23:05] <TimToady> "If C<*> is specified as the number (or if the number of elements in the list is less than the specified number), all the available elements are returned in random order"

[23:05] <BenGoldberg> rn: my @a=^Inf; my @b = @a; shift @b; say @a[^5];

[23:05] <lizmat> I've been looking at that paragraph, and did not parse that

[23:05] <masak> adu: perhaps it's easiest to understand {YOU_ARE_HERE} in terms of the -n and -p flags. the {YOU_ARE_HERE} terms is simply a mechanism for injecting the program that the user wrote into a larger setting.

[23:06] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)»

[23:06] <camelia> ..rakudo 71ea14: OUTPUT«0 1 2 3 4␤»

[23:06] <masak> adu: and that's excatly what's needed to make -n and -p work, for example.

[23:06] <adu> masak: thanks, that makes sense

[23:06] <masak> adu: but also for the regular setting, called CORE.

[23:06] *** adu left
[23:06] <masak> 'night, #perl6

[23:06] <TimToady> YOU_ARE_HERE is just a lazy eval of something that will be specified later :)

[23:07] <lizmat> 'night masak

[23:07] <lue> ♞ masak o/

[23:07] <TimToady> o/

[23:07] <BenGoldberg> Good evening everyone! :)

[23:07] <dalek> nqp: ec08455 | jnthn++ | / (4 files):

[23:07] <dalek> nqp: Improve method invocation by using guard clauses.

[23:07] <dalek> nqp: 

[23:07] <dalek> nqp: This means we don't have to re-enter the bootstrap method per type of

[23:07] <dalek> nqp: invocant that occurs at the callsite.

[23:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ec084557fa

[23:07] <diakopter> BenGoldberg: 'night

[23:07] *** adu joined
[23:07] <masak> {YOU_ARE_HERE} is a templating mechanism with one parameter :)

[23:07] <masak> really 'night

[23:08] * lizmat as well

[23:08] <lue> Think of it like those maps in public locations. If you're traversing a large setting, it's nice to know where YOU ARE when you run code.

[23:08] <lizmat> gnight #perl6

[23:08] <lue> ♞ lizmat o/

[23:10] <jnthn> OK, that's the majority of the first round of invokedynamic work done.

[23:10] <TimToady> .oO(the tyranny of the minority...)

[23:10] <BenGoldberg> r: my @a := ^Inf; my @b := @a; shift @b; say @a[^5];

[23:10] <camelia> rakudo 71ea14: OUTPUT«No such method 'shift' for invocant of type 'Range'␤  in sub shift at src/gen/CORE.setting:6387␤  in block  at /tmp/voUECkiWZK:1␤␤»

[23:11] * BenGoldberg is confused.

[23:11] <TimToady> Range is effectively immutable, and iterates by returning a different Range

[23:12] <TimToady> so a shift in place ain't gonna cut it

[23:12] <BenGoldberg> So why does it work when I use = instead of := ?

[23:13] <TimToady> because = is smart enough to switch to lazy semantics in rakudo when it sees infinity

[23:13] <TimToady> (but not smart enough in niecza, last I checked)

[23:13] <BenGoldberg> Ok.

[23:13] <TimToady> and = has copy semantics

[23:14] <TimToady> r: my @a; @a.plan: ^Inf; shift @a; say @a[^5]

[23:14] <camelia> rakudo 71ea14: OUTPUT«No such method 'plan' for invocant of type 'Array'␤  in block  at /tmp/Y4wQXhP0gv:1␤␤»

[23:14] <TimToady> hmm

[23:15] <TimToady> n: my @a; @a.plan: ^Inf; shift @a; say @a[^5]

[23:15] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«1 2 3 4 5␤»

[23:15] <TimToady> I guess niecza++ is ahead there

[23:17] <BenGoldberg> Speaking of = vs :=

[23:17] <BenGoldberg> r: my @a = gather { take $_*2 for ^Inf }; say @a[^3]

[23:17] <camelia> rakudo 71ea14: OUTPUT«(timeout)»

[23:17] <BenGoldberg> r: my @a := gather { take $_*2 for ^Inf }; say @a[^3]

[23:17] <camelia> rakudo 71ea14: OUTPUT«0 2 4␤»

[23:18] <TimToady> r: my @a := @(^Inf); my @b := @a; shift @b; say @a[^5];

[23:18] <camelia> rakudo 71ea14: OUTPUT«1 2 3 4 5␤»

[23:18] <TimToady> = is "mostly eager"

[23:19] <TimToady> but it can't see the Inf inside the gather

[23:20] *** woolfy1 left
[23:26] <pmichaud> my Int @a;  @a[0] = 'hello';  say @a

[23:26] <pmichaud> r: my Int @a;  @a[0] = 'hello';  say @a

[23:26] <camelia> rakudo 71ea14: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in block  at /tmp/YOgxRxKA1y:1␤␤»

[23:26] <pmichaud> r: my Int %s;  %s<a> = 'hello';  say %s

[23:26] <camelia> rakudo 71ea14: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in block  at /tmp/ubaGTtEZjh:1␤␤»

[23:27] <jnthn> The mystical $v...

[23:27] <pmichaud> I was just looking at RT #117773 real quick.

[23:27] <pmichaud> (KeyBag doesn't enforce int-ness)

[23:29] <pmichaud> r: class XYZ { has Int %!h; method abc() { %!h<a> = 'hello'; } };  XYZ.new.abc(); say 'alive';

[23:29] <camelia> rakudo 71ea14: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in method abc at /tmp/diaJD8BY_d:1␤  in block  at /tmp/diaJD8BY_d:1␤␤»

[23:30] <pmichaud> r: class A { has Method @.slots; }; A.new.slots.push: [1,2,3];  # RT #112660

[23:30] <camelia> rakudo 71ea14:  ( no output )

[23:30] <pmichaud> r: class A { has Method @.slots; }; A.new.slots.push: [1,2,3];  say 'alive'; # RT #112660

[23:30] <camelia> rakudo 71ea14: OUTPUT«alive␤»

[23:30] <pmichaud> r: class A { has Str @.slots; }; A.new.slots.push: [1,2,3];  say 'alive'; # RT #112660

[23:30] <camelia> rakudo 71ea14: OUTPUT«alive␤»

[23:34] <pmichaud> r: class A { has Str @.slots; }; A.new.slots.push: 1;  say 'alive'; # RT #112660

[23:34] <camelia> rakudo 71ea14: OUTPUT«alive␤»

[23:34] <pmichaud> I'm afk

[23:38] <adu> who was working on the java port of NQP?

[23:38] <adu> jnthn?

[23:38] <TimToady> yes

[23:39] <adu> how do I get in on that?

[23:40] <TimToady> ask jnthn, I suppose

[23:42] *** berekuk left
[23:42] <jnthn> adu: It lives in the NQP repository these days; perl ConfigureJVM.pl then make

[23:42] <adu> jnthn: how do I get in on that?

[23:42] <adu> ok

[23:45] <adu> TimToady: did I tell you about my experience with clang?

[23:46] <jnthn> adu: The jvm-support branch in Rakudo is where work is happening to get a Rakudo that builds/runs on NQP on JVM. Nothing too exciting to see yet, alas.

[23:46] <jnthn> (I mean, it builds a bunch of stuff...but you can't do anything with it yet. :))

[23:47] <jnthn> Time for some rest here... 'night

[23:47] <adu> jnthn: I'd like to help if I can

[23:47] <lue> ♞ jnthn o/

[23:47] <adu> jnthn: good night

[23:47] <jnthn> adu: OK; best bet is to get a build and take a look around, then catch me sometime when it's not 2am and I can give some better pointers. :)

[23:47] <jnthn> o/

[23:48] <adu> jnthn: thanks :)

[23:51] *** thundergnat joined
[23:58] * lue almost mentioned how "2am" without a timezone attached is nearly useless :P

[23:59] <census> hi thundergnat!

