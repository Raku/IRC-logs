[00:00] *** berekuk left
[00:04] *** sftp left
[00:12] *** sftp joined
[00:12] *** Psyche^_ joined
[00:13] <jnthn> evening, #perl6

[00:13] <preflex>  jnthn: you have 2 new messages. '/msg preflex messages' to read them.

[00:14] *** berekuk joined
[00:16] *** Psyche^ left
[00:16] <jnthn> lizmat: Thanks for working on that

[00:16] <jnthn> lizmat: I'll update the slides for my NPW talk

[00:16] <lizmat> ok

[00:16] <jnthn> lizmat: It's probably good for me to do that to make sure I know what to say when I give the talk ;)

[00:17] <lizmat> there is one pb with .cue

[00:17] <lizmat> that I don't undersnad

[00:17] <lizmat> (hehe)

[00:17] <jnthn> Oh?

[00:17] <jnthn> Maybe I can .cure it :P

[00:17] <lizmat> I hope

[00:17] * jnthn drank the most coffee-tasting stout in his life this evening...

[00:17] <jnthn> It was actually like expresso.

[00:17] <lizmat> $*SCHEDULER.cue gives:

[00:17] <lizmat> Ambiguous call to 'cue'; these signatures all match:

[00:17] <lizmat> :(ThreadPoolScheduler : &code, Mu *%_)

[00:17] <lizmat> :(ThreadPoolScheduler : &code, Mu *%_)

[00:18] <lizmat> but I don't see anything wrong with the candidates

[00:18] <lizmat> in src/vm/jvm/core/ThreadPoolScheduler.pm

[00:18] <dalek> rakudo-star-daily: e80a7f1 | coke++ | log/ (4 files):

[00:18] <dalek> rakudo-star-daily: today (automated commit)

[00:18] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/e80a7f1555

[00:18] * lue probably just yak-shaved himself into writing a couple of Pod6 modules in the interests of P6-ifying the perl6/book repo :)

[00:19] <dalek> perl6-roast-data: e139d7d | coke++ | / (5 files):

[00:19] <dalek> perl6-roast-data: today (automated commit)

[00:19] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e139d7db81

[00:19] <dalek> perl6-roast-data: 11112ec | coke++ | / (5 files):

[00:19] <dalek> perl6-roast-data: today (automated commit)

[00:19] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/11112ec4ec

[00:19] <jnthn> lizmat: Wait, just a plain, empty, $*SCHEDULER.cue?

[00:19] <lizmat> jnthn: line 54 and following

[00:19] <lizmat> no, cue({...})

[00:19] <lizmat> no named params

[00:19] <jnthn> oh...

[00:20] <jnthn> I don't think you can do stuff like

[00:20] <jnthn> multi method cue(&code) { ... }multi method cue(&code) { ... }

[00:20] <jnthn> oops

[00:20] <jnthn> multi method cue(&code) { ... }

[00:20] <jnthn> in the role

[00:20] <jnthn> I mean, the "requirement" thing works at the level of top-level routines and doesn't look into multi candidate lists.

[00:21] <jnthn> tbh I'd leave a method cue(|) { ... } in the role

[00:21] <jnthn> And then move the proto into the implementing things

[00:21] <lizmat> so it needs to be a single .cue that handles all permuattions?

[00:21] <jnthn> Not saying that

[00:21] <jnthn> You can implement it as a multi

[00:21] <lizmat> ok, so take it out of Schediuler

[00:21] <jnthn> Just saying that the in the role, you want a single stub method

[00:22] <lizmat> and put it in ThreadPoolScheduler and CurrentThreadSchdeuler ?

[00:22] <jnthn> Right

[00:22] <lizmat> ok

[00:22] <jnthn> This does raise a spec issue. :)

[00:22] <jnthn> But that's the fix, anyways.

[00:23] <lizmat> building

[00:24] *** berekuk left
[00:26] *** dmol left
[00:33] *** sftp left
[00:33] *** johnny5_ left
[00:34] *** sftp joined
[00:35] *** johnny5_ joined
[00:37] *** johnny5_ left
[00:39] *** johnny5_ joined
[00:52] <dalek> rakudo/nom: e4d07a1 | (Elizabeth Mattijsen)++ | src/vm/jvm/core/ (3 files):

[00:52] <dalek> rakudo/nom: Further Scheduler tweaks

[00:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e4d07a199a

[00:53] <lizmat> getting further but still failing scheduler.t

[00:53] <lizmat> jnthn: too tired now, will look at tomorrow

[00:53] <lizmat> gnight #perl6!

[00:58] <jnthn> lizmat: OK :)

[00:58] * jnthn is too tired too :)

[00:58] *** wbill joined
[00:59] <jnthn> 'night o/

[01:07] *** xenoterracide left
[01:14] *** daniel-s joined
[01:19] *** Rotwang left
[01:26] *** ingy^ joined
[01:36] *** johnny5_ left
[01:37] *** johnny5_ joined
[01:41] *** ingy^ left
[01:41] *** benabik joined
[01:43] *** eternaleye left
[01:45] *** johnny5_ left
[01:45] *** eternaleye joined
[01:46] *** johnny5_ joined
[01:50] *** benabik left
[01:52] *** johnny5_ left
[01:53] *** johnny5_ joined
[01:57] *** johnny5_ left
[01:58] *** johnny5_ joined
[02:02] *** Shellcat left
[02:07] *** araujo left
[02:08] *** araujo joined
[02:17] *** FROGGS left
[02:19] *** jnap left
[02:21] *** FieldsaBB joined
[02:31] *** davecc joined
[02:35] *** LordVorp left
[02:35] *** LordVorp joined
[02:37] *** pdurbin joined
[02:38] *** dwarring left
[02:39] *** FROGGS joined
[02:54] *** FROGGS left
[02:56] *** FROGGS joined
[02:56] *** wbill left
[03:01] *** wbill joined
[03:34] *** FROGGS left
[03:52] *** FROGGS joined
[03:54] * [Coke] yawns.

[04:04] <diakopter> .

[04:06] *** rurban joined
[04:07] * timotimo has some trouble sleeping

[04:09] <tadzik> watch some classic, but boring film

[04:09] <tadzik> last time I checked, the space odyssey was 3 hours long

[04:10] <tadzik> they say it's a blasphemy to fast-forward the boring parts

[04:18] *** Shellcat joined
[04:19] *** ggoebel15 left
[04:23] *** preflex_ joined
[04:23] *** ChanServ sets mode: +v preflex_

[04:24] *** preflex left
[04:24] *** preflex_ is now known as preflex

[04:32] *** telex left
[04:32] <tadzik> (look, I put timotimo to sleep just by talking about it)

[04:36] *** FROGGS left
[04:36] *** telex joined
[04:44] *** BenGoldberg left
[04:51] <timotimo> no you did not :(

[04:53] *** FROGGS joined
[04:55] <tadzik> :(

[04:55] *** cognominal joined
[04:55] <tadzik> sweet kitty soft kitty little ball of fur

[04:56] <tadzik> something something something something purr purr purr

[04:59] <lue> r: sub song($a, $b, :$ndverse = 1) { print "$a kitty, $b kitty, "; say ($ndverse - 1) ?? "purr purr purr." !! "little ball of fur;" }; song("soft", "warm"); song("happy", "sleepy", :2ndverse);

[04:59] <camelia> rakudo-jvm 882e33: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Q0k91_iNhN‚ê§Malformed radix number‚ê§at /tmp/Q0k91_iNhN:1‚ê§------> [32mft", "warm"); song("happy", "sleepy", :2[33m‚èè[31mndverse);[0m‚ê§    expecting any of:‚ê§        number in radix notation‚ê§¬ª

[04:59] <camelia> ..rakudo-parrot e4d07a: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/au54O86JmH‚ê§Malformed radix number‚ê§at /tmp/au54O86JmH:1‚ê§------> [32mft", "warm"); song("happy", "sleepy", :2[33m‚èè[31mndverse);[0m‚ê§    expecting any of:‚ê§        number in radix notat‚Ä¶¬ª

[05:00] <lue> std: sub song($a, $b, :$ndverse = 1) { print "$a kitty, $b kitty, "; say ($ndverse - 1) ?? "purr purr purr." !! "little ball of fur;" }; song("soft", "warm"); song("happy", "sleepy", :2ndverse);

[05:00] <camelia> std 8adbc60: OUTPUT¬´ok 00:01 133m‚ê§¬ª

[05:00] <lue> n: sub song($a, $b, :$ndverse = 1) { print "$a kitty, $b kitty, "; say ($ndverse - 1) ?? "purr purr purr." !! "little ball of fur;" }; song("soft", "warm"); song("happy", "sleepy", :2ndverse);

[05:00] <camelia> niecza v24-98-g473bd20: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1355 (warn @ 5) ‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 266 (Mu.Str @ 15) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/‚Ä¶¬ª

[05:00] <lue> (Apparently it's not ok for *me* to dare use the :2nd adverb trick...)

[05:04] *** benabik joined
[05:06] *** rurban left
[05:08] *** rurban joined
[05:08] *** krunen joined
[05:10] *** broquain1 joined
[05:10] *** smash__ joined
[05:10] *** mtj_- joined
[05:10] *** telex left
[05:10] *** telex joined
[05:11] *** johnny5_ left
[05:11] *** krunen_ left
[05:11] *** mtj_ left
[05:11] *** broquaint left
[05:11] *** jtpalmer left
[05:11] *** jtpalmer joined
[05:11] *** johnny5_ joined
[05:12] *** rurban1 joined
[05:12] *** tokuhirom joined
[05:13] *** rurban left
[05:17] *** rurban1 left
[05:53] *** nnunley left
[05:54] *** davecc left
[06:12] *** darutoko joined
[06:39] *** kaare_ joined
[06:43] *** rurban joined
[06:47] *** rurban left
[06:53] <moritz> \o

[06:54] <timotimo> o/

[07:01] * timotimo investigates what the performance implication of using native ints for DateTime is

[07:03] <timotimo> bleh. stage post for the core setting takes 77 seconds on my laptop

[07:03] <timotimo> that's a target for optimizations some day, too

[07:07] *** nnunley joined
[07:07] <timotimo> i'm glad the intermediate text stage has been left out for moar

[07:07] <timotimo> stringifying all the stuff can only lead to sadness

[07:09] <Woodi> hi everyone :)

[07:09] <timotimo> good day woodi

[07:11] <timotimo> well, to be fair, the optimizer takes 33 seconds, too ... i wonder if i've gone a bit over board with the optimizations lately? :P

[07:11] *** nnunley left
[07:14] <timotimo> no improvement with native ints? huh.

[07:17] <Woodi> there is ARMA / Operation Flashpoint (games, military theme) scripting language and it seems quite user friendly :) it run on VM. it have 'call' for functions but also 'spawn' for running functions in background. it also have 'execVM' for firing FSM's (Finite State Machines) files eg. guard is patrolling walking 'Paths', having 'Sensors' buildin, guard can report 'All OK' or can start to shoot...

[07:18] <Woodi> or zombie is (still) patrolling and 'follow' when see a 'target' :)

[07:20] <Woodi> syntax for calling is via lists: ["param1", _listOfLists, "more", "params"] call funcName;

[07:21] <Woodi> and in func: _param1 = _this select 0; _param2 = _this select 1;

[07:22] <Woodi> what quite reminds old, good Perl syntax :) and looks quite CPU-friendly, or VM-stack friendly...

[07:23] *** cognominal left
[07:23] <timotimo> hmm

[07:23] <Woodi> makes me thing Perl designer have in mind eventual sub calls optimization via rewriting it in asm :)

[07:25] <Woodi> FSM have syntax like scripts with a kind of 'preprocesor' directives for defining nodes and arcs

[07:26] <Woodi> and game servers are CPU heavy :) no idea is Arma VM spawns real threads but that 'spawn' into background functionality is perfect for scripter

[07:27] <Woodi> thinked about sharing this for some time and #moarvm discussion triggerered something probably :)

[07:31] <Woodi> on the other topic: CSP was designed with Transputers in mind - many CPUs comunicating via common bus. multicores are more similiar to plain cpu and using sharing memory insted of communications looks much more efficient and natural for amateur eye...

[07:35] <Woodi> also: amateur comes from French amateur "lover of" (some thing) - love is good thing  ! in contrast 'proffesional' comes from what ? ;)

[07:35] <timotimo> hm. my int $x = 1000; my int $y = $x + 500; in PIR does 2 unboxings and 2 boxings ... why? :|

[07:36] <timotimo> i suppose it's for typechecking the return value from the inlined operator

[07:37] <timotimo> https://gist.github.com/timo/ba460c27719f23f6fa51 - like this

[07:38] <timotimo> perhaps it's using the Int, Int --> Int variant instead of the/a int, int --> int variant?

[07:39] <timotimo> or is perl6_box_int actually for int and the same thing for Int looks different?

[07:40] <timotimo> ah, with Int it doesn't seem to inline, it gets the two Int objects from the world and does a full call to &infix:<+>

[07:47] <timotimo> i wonder if it'd be worthwhile to do a pass on the PIR to see things like "create a Resizable*Array, push $CONST_N values in, use the Array" could be found and have a "pre-allocate exactly $CONST_N slots" call after creation?

[07:56] <masak> Woodi: "CSP"?

[07:56] <masak> (oh hai, #perl6)

[07:56] *** cognominal joined
[07:57] <moritz> good morning, masak

[07:59] <masak> Woodi: re 'professional', it seems to come from Medieval Latin's "professi≈ç", "[I] take a vow [of a religious order]"

[08:04] *** FROGGS left
[08:07] *** p5eval joined
[08:17] <masak> as it happens, I have a bit of disposable time today for p6ery.

[08:17] <masak> modulo external influences, I will probably spend it on t4 reviews.

[08:18] *** FROGGS joined
[08:19] <timotimo> sounds good to me :)

[08:19] <timotimo> i think perf may be a too low-level tool to get good measurements out of parrot and friends

[08:21] <timotimo> "ah, so mov    0x10(%rax),%rsi is the culprit!"

[08:22] <masak> :)

[08:27] *** berekuk joined
[08:45] *** rurban joined
[08:47] *** FieldsaBB left
[08:51] *** rurban left
[08:57] <masak> hehe. seen on Hacker News: "Poe's law is strong with this one" :)

[09:04] *** [Sno] left
[09:06] *** [Sno] joined
[09:09] *** cognominal left
[09:17] *** berekuk left
[09:34] *** berekuk joined
[09:37] *** Shellcat left
[09:38] <dalek> roast: da2ccdc | (Tobias Leich)++ | S02-types/hash.t:

[09:38] <dalek> roast: test for RT #73230

[09:38] <dalek> roast: review: https://github.com/perl6/roast/commit/da2ccdcfe7

[09:38] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=73230

[09:43] *** cognominal joined
[09:44] <dalek> roast: 535f150 | (Tobias Leich)++ | S02-types/hash.t:

[09:44] <dalek> roast: fixed test for RT #73230

[09:44] <dalek> roast: review: https://github.com/perl6/roast/commit/535f150a3e

[09:44] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=73230

[09:46] *** cognominal left
[09:48] <FROGGS> p: use Test; class Bar { }

[09:48] <camelia> rakudo-parrot e4d07a: ( no output )

[09:48] <FROGGS> n: use Test; class Bar { }

[09:48] <camelia> niecza v24-98-g473bd20: ( no output )

[09:48] <FROGGS> pugs: use Test; class Bar { }

[09:48] <camelia> pugs: OUTPUT¬´pugs: *** Unsafe function 'use' called under safe mode‚ê§    at /tmp/BcCsKaU4eg line 1, column 1‚ê§¬ª

[09:49] <dalek> roast: dd282b8 | (Tobias Leich)++ | S10-packages/use-with-class.t:

[09:49] <dalek> roast: test for RT #73910

[09:49] <dalek> roast: review: https://github.com/perl6/roast/commit/dd282b8275

[09:49] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=73910

[09:52] <masak> FROGGS++ # RT spectests

[09:56] <Woodi> about scripting games: language is called 'sqf'; https://github.com/vbawol/DayZ-Epoch/blob/master/SQF/dayz_code/system/building_monitor.sqf

[09:58] <Woodi> csp: https://en.wikipedia.org/wiki/Communicating_sequential_processes; but it later evolved and is probably quite usefull 

[10:02] * masak .oO( So Quite... Forth? )

[10:03] <masak> Woodi: I hope the future will contain lots of scriptable virtual worlds. it feels like a fairly safe bet that it will.

[10:04] <masak> CSP looks a bit like a precursor to pi calculus.

[10:05] <masak> lunch &

[10:05] *** sqirrel joined
[10:05] *** cognominal joined
[10:22] <Woodi> if some perl6 implementation can listen to telnet connections then MUDs can be done right now :)

[10:25] <timotimo> yeah, parrot and jvm already can

[10:31] <Woodi> I always wanted to parse DIKU-style area files in automatic way ;)

[10:32] *** Jeffrey joined
[10:35] *** Jeffrey left
[10:40] *** JeffreyKegler joined
[10:43] *** denisboyun joined
[10:44] <dalek> rakudo/nom: be3eea7 | (Elizabeth Mattijsen)++ | src/vm/jvm/core/ThreadPoolScheduler.pm:

[10:44] <dalek> rakudo/nom: Fix copy-n-pasto thinko with JVM interop

[10:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be3eea746c

[10:46] *** JeffreyKegler left
[10:48] *** rurban joined
[10:49] *** berekuk left
[10:49] *** ssutch left
[10:51] *** kaare_ left
[10:52] *** berekuk joined
[10:53] *** rurban left
[10:53] *** Rotwang joined
[10:58] <dalek> roast: d67e271 | (Elizabeth Mattijsen)++ | S17-concurrency/ (6 files):

[10:58] <dalek> roast: Make S17-concurrency fudgeable for rakudo.parrot

[10:58] <dalek> roast: review: https://github.com/perl6/roast/commit/d67e2716cf

[10:59] <dalek> rakudo/nom: 631c5e2 | (Elizabeth Mattijsen)++ | t/spectest.data:

[10:59] <dalek> rakudo/nom: Add S17-concurrency tests to roast

[10:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/631c5e2cd8

[11:00] <moritz> 19 files changed, 1193 insertions(+), 6 deletions(-)

[11:00] <moritz> from my last pull

[11:00] <moritz> uhm, is the concurrency stuff twice in there now?

[11:01] <lizmat> is this for nom?  then yes, looks like a lot

[11:01] <lizmat> However, no

[11:01] <lizmat> I added 14 files

[11:01] <lizmat> splitting Threading.pm into logical components

[11:01] <lizmat> so maybe it *is* correct

[11:02] <moritz> splitting a file shouldn't cause 1k more lines

[11:02] <timotimo> yeah, it should have an equal amount of deletions

[11:02] <timotimo> but didn't you keep the old threading.pm around, lizmat?

[11:02] <lizmat> yes, I did, for now

[11:02] <lizmat> actually *am* about to remove it now

[11:02] <lizmat> at least in the repo  :-)

[11:03] *** Rotwang left
[11:03] <moritz> ok, that explains a lot

[11:04] <dalek> rakudo/nom: 450519b | (Elizabeth Mattijsen)++ | src/vm/jvm/core/Threading.pm:

[11:04] <dalek> rakudo/nom: Threading.pm has served its purpose

[11:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/450519b173

[11:05] <timotimo> here's a funny for you: sprintf("%s%s%s%s", "foo", "bar", "baz", "quux") is about 10% faster than join("", ["foo", "bar", "baz", "quux"])

[11:06] <moritz> but it doesn't do that same thing, no?

[11:06] <moritz> join with a [] stringifies the array

[11:06] <moritz> p: say ~["foo","bar", "baz", "quux"]

[11:06] <camelia> rakudo-parrot e4d07a: OUTPUT¬´foo bar baz quux‚ê§¬ª

[11:06] <moritz> still shouldn't be that slow

[11:06] <timotimo> oh?

[11:07] <moritz> p: say join '', ["foo","bar", "baz", "quux"]

[11:07] <camelia> rakudo-parrot e4d07a: OUTPUT¬´foo bar baz quux‚ê§¬ª

[11:07] <timotimo> you're right, i'm dumb :)

[11:08] <timotimo> OK, that's quite a bit faster

[11:08] <dalek> roast: 123ce1e | (Elizabeth Mattijsen)++ | S17-concurrency/lock.t:

[11:08] <dalek> roast: Make "pass" visible to the rakudo.parrot fudger

[11:08] <dalek> roast: review: https://github.com/perl6/roast/commit/123ce1ea0f

[11:08] <timotimo> i was probably thinking of nqp::join

[11:14] <timotimo> i wonder why nqp::join is soooooo much faster than perl6's join

[11:14] <lizmat> boxing/unboxing ?

[11:15] <timotimo> rakudo does 10000 in 17 seconds, nqp does 10000000 in 22 seconds

[11:16] <timotimo> that's 10_000 and 10_000_000

[11:16] * masak liked http://curiousprogrammer.wordpress.com/2013/11/07/perl-and-python-the-same-language-different-skins/

[11:17] *** sqirrel left
[11:21] *** Rotwang joined
[11:24] *** berekuk left
[11:30] *** dmol joined
[11:39] *** berekuk joined
[11:40] <jnthn> afternoon, #perl6

[11:41] <timotimo> good day jnthn :)

[11:43] <jnthn> Finally. A decent amount of sleep.

[11:43] <masak> you're writing in your sleep? :P

[11:43] <jnthn> maybe... :P

[11:44] <timotimo> jnthn: do you have an idea for me what i could try to optimize? :|

[11:44] <timotimo> i'm in a "rakudo is too slow" mood

[11:45] <timotimo> i plugged eqat into the implementation of "literal" QRegex nodes on parrot btw. at first i measured a 10% speed improvement, but it turned out to be just noise :(

[11:45] * masak .oO( after waking up, jnthn could not decide whether he was a programmer dreaming of compilers, or a compiler dreaming of programmers )

[11:45] *** cognominal left
[11:49] <timotimo> jnthn: could there be something wrong with the inliner, btw? i looked at the PIR rakudo generates for "my int $foo = 1000; my int $bar = $foo + 500" and it had 2x perl6_box_int and 2x repr_unbox_int (OSLT)

[11:49] <masak> TIL: "factoring" is AmE, and in other varieties of English it's called "factorising". I wonder if (but doubt that) this goes for the programming term as well as the math concept.

[11:50] <jnthn> timotimo: That sounds rather wrong...

[11:50] <timotimo> https://gist.github.com/timo/ba460c27719f23f6fa51

[11:51] <timotimo> also, i'm wondering if it'll be super hard to get rid of the perl6_type_check_return_value, because the last statement of the function is known, at nqp level, to return an int and should thus be fine

[11:51] <jnthn> perl6_type_check_return_value

[11:51] <jnthn> ah...

[11:51] <jnthn> Right.

[11:51] <timotimo> yes, that's how i figured out it was doing the inlining

[11:51] <timotimo> well, that and _inline_arg_1 :)

[11:54] <timotimo> i got there by wondering why the hell get-local-timezone-offset contributes 0.1s to each startup of rakudo (an empty program takes 1.1s on my machine, so it's almost 10%)

[11:54] <timotimo> then i put "int" in front of all the variables in the calculations that seemed to contribute the biggest portion of the time and saw no change whatsoever

[12:10] <dalek> roast: 1057aed | (Elizabeth Mattijsen)++ | S17-concurrency/thread.t:

[12:10] <dalek> roast: Added thread ID test before .join

[12:10] <dalek> roast: review: https://github.com/perl6/roast/commit/1057aed62f

[12:11] *** dmol left
[12:11] <dalek> roast: 650fd6e | (Elizabeth Mattijsen)++ | S17-concurrency/thread.t:

[12:11] <dalek> roast: Added todo test for lockable variables

[12:11] <dalek> roast: review: https://github.com/perl6/roast/commit/650fd6e1d6

[12:12] <lizmat> jnthn: todo test to show the problem mostly, no solution yet, I know  :-)

[12:12] <lizmat> at least it doesn't segfault  :-)

[12:16] <jnthn> lizmat: Well, it's extremely questionable to me if that's a bug.

[12:16] <lizmat> for *you*, yes

[12:16] <jnthn> lizmat: The entire point of the primitives I've been pushing is that you do *explicit* inter-task communication.

[12:17] <jnthn> "Doesn't segfault" - yes, we should not segfault on such things, on any backend. That much I can agree with. :)

[12:18] <lizmat> in any case, it is an easy mistake to make

[12:18] <lizmat> especially when using threads/promises/channels with modules that don't know about these things

[12:18] <jnthn> *nod*

[12:19] <lizmat> so we should at least test that it doesn't segfault

[12:19] <lizmat> :-)

[12:20] <jnthn> Yeah, but then the test should be passing already :P

[12:20] <lizmat> well..  eh,. can we catch segfaults?

[12:20] <lizmat> ah, ok

[12:20] <timotimo> i don't think we can, actually

[12:20] <lizmat> hmmm...

[12:20] <jnthn> No, but dies_ok... :)

[12:20] <jnthn> Means no excetion

[12:20] <jnthn> And if there's an explicit test plan and you segfaut the VM, you never emit the ok

[12:21] <jnthn> And that means the harness considers it a fail.

[12:21] <timotimo> yeah

[12:22] <jnthn> Thing is that it's easy to look at this case and say "oh, let's do X to make it work". But in general you can't do this by static analysis.

[12:23] <jnthn> Which means you have to pessimize almost every variable access. Which we really, really do not want to do.

[12:23] <dalek> roast: b2a26fc | (Elizabeth Mattijsen)++ | S17-concurrency/thread.t:

[12:23] <dalek> roast: Make test always pass, as discussed on #perl6

[12:23] <dalek> roast: review: https://github.com/perl6/roast/commit/b2a26fcd82

[12:24] <lizmat> I was more thinking about pessimising it only for variables with a certain trait

[12:25] <jnthn> ah

[12:25] <jnthn> Maybe. But trouble is that even that's not the real problem here

[12:25] <lizmat> ah?

[12:26] <jnthn> Reading a scalar or binding a value to it is an attribute access, and that already is all-or-nothing

[12:26] <lizmat> problem that ++ in rakudo is not atomic ?

[12:26] <jnthn> It's the ++ operator

[12:26] <jnthn> s/in rakudo/in every mainstream language I knwo of/ ;)

[12:26] <jnthn> But yeah, it's about the ++

[12:27] <lizmat> maybe it would be a thing to introduce an atomic +++ op ?

[12:28] <jnthn> hmm :)

[12:28] <jnthn> $a += 5 # immediately the same problem

[12:28] <lizmat> conversely, an atomic --- as well

[12:29] <jnthn> All these things are ameanable to cas-like things as retrying them is harmless

[12:29] *** tobyink joined
[12:29] <lizmat> indeed

[12:29] <lizmat> std: my $a; $a+^+

[12:29] <camelia> std 8adbc60: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Prefix requires an argument at /tmp/zhcR_qB4gb line 1 (EOF):‚ê§------> [32mmy $a; $a+^+[33m‚èè[31m<EOL>[0m‚ê§Other potential difficulties:‚ê§  +^+ is not an infix operator (to suppress warning put space between infix +^ and pr‚Ä¶¬ª

[12:29] <lizmat> std: my $a; $a^-

[12:29] <camelia> std 8adbc60: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Prefix requires an argument at /tmp/x9nyi5eqFK line 1 (EOF):‚ê§------> [32mmy $a; $a^-[33m‚èè[31m<EOL>[0m‚ê§Other potential difficulties:‚ê§  ^- is not an infix operator (to suppress warning put space between infix ^ and prefi‚Ä¶¬ª

[12:29] <lizmat> std: my $a; $a-^-

[12:29] <camelia> std 8adbc60: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Prefix requires an argument at /tmp/urVazIM57b line 1 (EOF):‚ê§------> [32mmy $a; $a-^-[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:01 124m‚ê§¬ª

[12:32] <masak> "Prefix requires a term", more like.

[12:32] <masak> "argument" plays on the wrong end of the operator-function analogy.

[12:33] <lizmat> I'm just worried that porting modules from p5 "verbatim" would introduce problems in concurrent code

[12:33] <lizmat> more worringly, introduce heisenbugs

[12:35] * masak suggests 'atomic { $x++ }' instead

[12:35] <masak> with or without the braces.

[12:35] <masak> keyword name negotiable.

[12:36] <masak> anyway, I'd rather see that than introducing atomic flavors of existing operators.

[12:36] <jnthn> atomic { ... } is heading to scary STM land :)

[12:36] <lizmat> masak: that's all nice and dandy, but that would force knowledge of concurrency onto module developers

[12:36] <lizmat> worse: it would need rethinking standard modules

[12:36] <masak> lizmat: I should hope so!

[12:37] <lizmat> perhaps that's also a good thing  :-)

[12:37] <masak> lizmat: "force knowledge onto", that is.

[12:37] <jnthn> lizmat: Standard modules that are essentially "pure" in their operation are untroubled. 

[12:37] <masak> lizmat: I don't believe it's realistic to be threadsafe and also be unaware of thread safety.

[12:38] <jnthn> lizmat: Perhaps most importantly, though, there are ways to build tools that detect data races.

[12:38] <jnthn> lizmat: We'd do well to learn about those and steal the best ideas. :)

[12:38] <lizmat> atomic {} has its uses without STM

[12:39] <jnthn> On $a++, what's spec'd today is cas $a, { $_ + 1 }

[12:39] <jnthn> (Though not implemented)

[12:39] *** Rotwang left
[12:39] <lizmat> feels we need sugar for that

[12:39] <lizmat> but yes

[12:39] <jnthn> lizmat: You need to have an implementation strategy for it, though. I thought STM was that?

[12:40] <lizmat> atomic is really just about not being interrupted

[12:40] <lizmat> so, I guess the opposite of yield

[12:40] <jnthn> A code-level mutex?

[12:40] <lizmat> but I'm not sure VM's support that?

[12:41] <jnthn> Well, depends what you're asking for... :)

[12:42] <lizmat> hehe, just looking at the old S17, which was morphed from my original vision :-)

[12:42] <timotimo> jnthn: doesn't that lack a loop? or is the loop inside the cas itself?

[12:42] <jnthn> timotimo: Yes, that's the point o fthe code-block-taking cas. To factor the loop out. :)

[12:42] <lizmat> timotimo: in the cas itself

[12:42] <jnthn> It's quite cute. 

[12:43] <timotimo> oh!

[12:43] <timotimo> is that so :)

[12:43] * jnthn has written/taught writing that kinda loop enough times to figure it should just be factored out :)

[12:44] <timotimo> it's nice we can just do that sort of thing

[12:44] <jnthn> Heck, there was one in the C# class I was doing yesterday :)

[12:46] <timotimo> r: Q:PIR { new $P5004, 'ResizableStringArray'; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; push $P5004, "hello world"; }

[12:46] <camelia> rakudo-parrot 450519: OUTPUT¬´===SORRY!===‚ê§error:imcc:syntax error, unexpected ';', expecting '\n' (';')‚ê§        in file '(file unknown)' line 65‚ê§‚ê§¬ª

[12:46] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´===SORRY!===‚ê§Error while compiling op call: To compile on the JVM backend, QAST::VM must have an alternative 'jvm'‚ê§¬ª

[12:46] <timotimo> ah

[12:46] <lizmat> jnthn: I'll think about it some more

[12:47] <timotimo> r: Q:PIR { new $P5004, 'ResizableStringArray'‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ push $P5004, "hello world"‚ê§ }

[12:47] <camelia> rakudo-parrot 450519: ( no output )

[12:47] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´===SORRY!===‚ê§Error while compiling op call: To compile on the JVM backend, QAST::VM must have an alternative 'jvm'‚ê§¬ª

[12:47] <timotimo> jnthn: do you think it would be worth anything at all to find this kind of code in PIR-compiled output and put a "setelems $N; setelems 0" after the "new"?

[12:47] <timotimo> because we know the exact amount of things we want to push?

[12:51] <jnthn> timotimo: Belongs in nqp::list, nqp::list_s etc implementaiton, just don't do it for the 0 case :)

[12:51] <timotimo> oh

[12:52] <timotimo> well, that's nice :)

[12:53] <timotimo> oh hey, it seems super simple to do even!

[12:56] *** Rotwang joined
[12:56] *** xenoterracide joined
[12:56] <timotimo> how do i find out what pirop i need to push to set the element count of the RPMCA?

[12:57] <timotimo> also, how come we still use RPMCA instead of QRPA?

[12:57] <timotimo> wasn't that supposed to be way faster? i think it was :)

[12:57] <timotimo> maybe i should investigate that again

[12:59] <timotimo> nqp-p: my $t := nqp::time_n(); my $l := nqp::qlist(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); nqp::pop($l); nqp::pop($l); nqp::shift($l); nqp::shift($l); nqp::push($l, 99); nqp::unshift($l, -1); nqp::say(nqp::time_n() - $t);

[12:59] <camelia> nqp-parrot: OUTPUT¬´2.21729278564453e-05‚ê§¬ª

[12:59] <timotimo> wow, that was fast

[13:00] <timotimo> nqp-p: my $t := nqp::time_n(); my $l := nqp::list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); nqp::pop($l); nqp::pop($l); nqp::shift($l); nqp::shift($l); nqp::push($l, 99); nqp::unshift($l, -1); nqp::say(nqp::time_n() - $t);

[13:00] <camelia> nqp-parrot: OUTPUT¬´6.19888305664062e-06‚ê§¬ª

[13:00] <timotimo> well, that was ... faster

[13:00] <timotimo> but it's probably very noisy at that level of speed

[13:00] * timotimo tries for a better benchmark

[13:02] <timotimo> the benchmark is probably not better, but qrpa is a tiny bit faster in it ...

[13:03] *** denisboyun left
[13:04] *** nnunley joined
[13:06] *** denis_boyun joined
[13:08] *** sqirrel joined
[13:10] *** cognominal joined
[13:10] <dalek> rakudo/nom: abdccca | (Elizabeth Mattijsen)++ | src/vm/jvm/core/ (3 files):

[13:10] <dalek> rakudo/nom: Still more S17 up-to-specness

[13:10] <dalek> rakudo/nom: 

[13:10] <dalek> rakudo/nom: Scheduler.outstanding -> Scheduler.loads

[13:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abdccca309

[13:11] *** denis_boyun left
[13:12] <dalek> roast: 0c3d669 | (Elizabeth Mattijsen)++ | S17-concurrency/scheduler.t:

[13:12] <dalek> roast: S17: Scheduler.outstanding -> Scheduler.loads

[13:12] <dalek> roast: review: https://github.com/perl6/roast/commit/0c3d6690ba

[13:15] <lizmat> hmmm....  .cue with every *and* :at or :in seem broken  :-(

[13:16] <jnthn> oh noes you busted it :P

[13:17] <jnthn> Probably "just" mis-using the API or something...

[13:17] <jnthn> (The Java Timer one, that is)

[13:18] <lizmat> yeah, probably

[13:18] <lizmat> although there was no test for it before, so how can we tell ?

[13:18] <jnthn> Point ;)

[13:19] <lizmat> I just realize: with these cued tests and the evalserver, they will just continue running

[13:20] <jnthn> How about 11:50 on the Friday?

[13:20] <lizmat> I guess I need to add a flag to make them stop

[13:20] <jnthn> uh, oops

[13:21] <lizmat> hmm.... how do I stop something that is restarted every .1 second ?

[13:22] <jnthn> Not sure ;)

[13:22] <jnthn> We don't have a way yet I think. Just didn't get to that yet :)

[13:24] <lizmat> not even specced  :-)

[13:24] <masak> what's .cue meant to return?

[13:24] <masak> maybe this is one of those "return a convenient handler object" situations?

[13:25] <jnthn> masak: Probably

[13:25] <jnthn> Ties into the more general issue of cancellation

[13:25] <jnthn> Which is one of the under-worried-about areas so far :)

[13:26] <masak> I can read through S17 with an eye towards cancellation.

[13:27] <jnthn> .oO( Cancellable eye for the async guy )

[13:31] <masak> "cancellable eye" sounds kinda gross :)

[13:32] *** berekuk left
[13:34] *** berekuk joined
[13:35] <masak> $*SCHEDULER.cue in all its varieties should definitely return such an object. (how about calling the class Cue, too?)

[13:36] <lizmat> how is .cue then different from a thread ?

[13:36] <masak> sorry, what? it's still the same, except it can now be canceled.

[13:36] <lizmat> because it can be scheduled on an existing thread

[13:37] <masak> no direct relation to threads at all.

[13:37] <lizmat> yup, got that :-)

[13:37] <masak> this is the nice thing about schedulers. they allow us to control things from above :)

[13:37] <masak> scheduling as well as canceling.

[13:37] <masak> cancellation*, whatever

[13:38] <masak> it's an open question whether it should be an error condition to .uncue something that has already happened (and isn't an :every)

[13:39] <masak> (re $*SCHEDULER.loads) "[Conjecture: perhaps these should be separate methods.]" -- rather than an array of arbitrary positional things? why, yes, please. :)

[13:39] <lizmat> yes, we internally, with/without in/at/every are two different things

[13:40] <lizmat> *well

[13:40] <masak> right. all of those variants *can* be uncued before they happen.

[13:40] *** pippo joined
[13:40] <masak> but :every is different in that it happens more than once.

[13:41] <pippo> o/ #perl6

[13:41] <jnthn> That's like, "before it happens *again*" :)

[13:41] <masak> jnthn: right.

[13:42] <FROGGS> hi pippo 

[13:42] <FROGGS> hi all

[13:42] <masak> anyway, the only open question so far is whether it's a no-op or an error to .uncue schedulings that were *not* :every, and already triggered.

[13:42] <masak> hi FROGGS++

[13:42] <FROGGS> ?

[13:43] <masak> !

[13:43] <FROGGS> .

[13:43] <masak> Promises seem to be totally exempt from needing Cue objects and the like.

[13:44] <lizmat> I would say trying to stop a Cue object that didn't have an "every" or an "at/in"

[13:44] <lizmat> would be an error

[13:44] <masak> though I notice when skimming through that section, that there's an .in method and an .at method, but no .every method. that feels like an omission.

[13:44] <masak> lizmat: interesting -- why?

[13:45] <lizmat> because you cannot know whether sometihng ran already or not

[13:45] <lizmat> unless you're going to wrap the Callable somehhow

[13:46] <masak> the scheduler knows whether it started or not.

[13:46] <masak> so maybe an error if it already started?

[13:46] <lizmat> no, in Perl6 land, the scheduler does *not* know whether it started

[13:46] <lizmat> in JVM land maybe

[13:47] <masak> maybe I am using the wrong term. the scheduler knows whether it already scheduled something. :)

[13:47] <masak> if not, how could it avoid scheduling the same thing twice?

[13:47] *** pippo left
[13:47] <lizmat> the .cue method hands it off to JVM to do the scheduling

[13:48] <masak> ok. then I agree.

[13:48] <masak> then it's the conservative thing to have it be an error condition.

[13:48] <lizmat> perhaps we can interrogate the JVM

[13:48] <masak> perhaps.

[13:48] <jnthn> lizmat: The scheduler does know... :)

[13:49] <rjbs-> Is "cue" an existing term of art, here?

[13:49] <jnthn> In fact that's basically its jub :)

[13:49] *** rjbs- is now known as rjbs

[13:49] *** rjbs left
[13:49] *** rjbs joined
[13:49] <masak> rjbs: it's TimToady's spelling of .schedule

[13:50] <rjbs> I think that's going to lead to real confusion.

[13:50] <masak> jnthn: yes, that was my point

[13:50] <rjbs> "Oh, I should queue this task?" "Yes." "It didn't work." "Oh, it's cue, not queue."

[13:50] <lizmat> fwiw, Perl6 doesn't have queues

[13:50] *** pochi left
[13:50] <rjbs> lizmat: Sure, but jargon cross-pollenates.

[13:50] <rjbs> It's a cue-t name, but‚Ä¶

[13:51] <lizmat> well, Perl6 doesn't have async either

[13:51] <masak> rjbs: see https://github.com/perl6/specs/commit/f597d201ed23e052bcafb51cae03e42cc284827a

[13:52] <jnthn> otoh, you're not really going to interact with the scheduler directly that often

[13:52] <masak> rjbs: homonyms in CS are not unheard of. cf "tree" and "trie", for example.

[13:52] <jnthn> So it's not like most people will .cue that much

[13:52] <rjbs> masak: I totally agree, but that doesn't mean we shouldn't consider the confusion they can create before adding more!

[13:53] <jnthn> Most will start { the_party }, not $*SCHEDULER.cue({ the_party }) 

[13:55] *** sqirrel left
[13:55] <FROGGS> jnthn: what signature do I need if I want to slurp n (three in this case) lists? https://gist.github.com/FROGGS/a6c7ba8f673eb2818dd1

[13:56] <lizmat> $*SCHEDULER.cue( &cycling )

[13:57] <jnthn> FROGGS: Are you after **@lol?

[13:58] <FROGGS> maybe

[13:58] <FROGGS> lol sounds about right :o)

[13:59] <FROGGS> ohh yes

[13:59] <FROGGS> jnthn++

[14:02] *** tobyink left
[14:08] <Woodi> ad. atomic: we have experimental '__transaction_*' primitive in gcc now. also it is proposed as new feature to C++/C by ppls from Intel, IBM, HP, Oracle and Red Hat :) - so nearly 100% of cpu manufacturers. gcc implements it as library and via global lock. generated assembler code calls that library so probably we have new market for transactional libraries :) but all that is probably a preparation for HTM in processors.

[14:10] <Woodi> but that __transaction_* constructs works on native types and we want something like:

[14:11] <Woodi> class Account does Atomic { has NumericType balance; ...}  # where NumericType isn't native for eg. financial purposes... 

[14:12] <Woodi> so high level transaction construct would be nice for Perl6 used by all banks around the globe :)

[14:14] <Woodi> here is nice link:  http://www-users.cs.umn.edu/~boutcher/stm/

[14:17] *** tobyink joined
[14:33] *** M_o_C joined
[14:35] <FROGGS> nr: n: .say for 1, 2, 3 ... 10, 20 ... 100, 125 ... 200 # will push a fix after spectest

[14:35] <camelia> niecza v24-98-g473bd20: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§20‚ê§30‚ê§40‚ê§50‚ê§60‚ê§70‚ê§80‚ê§90‚ê§100‚ê§125‚ê§150‚ê§175‚ê§200‚ê§¬ª

[14:35] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Cannot call 'infix:<...>'; none of these signatures match:‚ê§:($a, Mu $b)‚ê§  in any  at gen/jvm/BOOTSTRAP.nqp:1201‚ê§  in block  at /tmp/VGEXl1nxL3:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚Ä¶¬ª

[14:35] <camelia> ..rakudo-parrot abdccc: OUTPUT¬´Cannot call 'infix:<...>'; none of these signatures match:‚ê§:($a, Mu $b)‚ê§  in any  at gen/parrot/BOOTSTRAP.nqp:1218‚ê§  in any  at gen/parrot/BOOTSTRAP.nqp:1209‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16316‚ê§  in block  at /tmp/ZmwImpXFbk:1‚Ä¶¬ª

[14:35] <FROGGS> ahh, labels++

[14:44] <masak> rjbs: agree about not adding undue confusion. I hadn't thought about the risks of cue/queue before you mentioned them.

[14:46] <rjbs> masak: I am glad to have raised the issue.  Also, if the method is rarely called (as someone said abovee) then it need not be short.

[14:46] <masak> also true.

[14:46] <moritz> .oO( a true cue )

[14:47] * masak .oO( too Huffmanized )

[14:47] <moritz> well, huffmanization isn't just about making often-used things short, but also about making fewer-used things long

[14:47] <moritz> water bed theory of huffmanization: you can't make everything short

[14:56] *** raiph joined
[14:57] <masak> well, you *can*, but if everything's short, nothing's easily accessible.

[15:00] <masak> or, put differently, Huffman only makes sense when the alphabet is small.

[15:07] *** broquain1 left
[15:08] *** broquaint joined
[15:18] *** M_o_C left
[15:31] *** ggoebel15 joined
[15:42] *** denisboyun joined
[15:42] *** berekuk left
[15:49] <dalek> rakudo/nom: cab7404 | (Tobias Leich)++ | src/core/operators.pm:

[15:49] <dalek> rakudo/nom: make infix:<...> a proper list infix

[15:49] <dalek> rakudo/nom: 

[15:49] <dalek> rakudo/nom: Now it can appear several times in the same statement.

[15:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cab7404276

[16:00] *** benabik left
[16:00] *** berekuk joined
[16:01] <masak> \o/

[16:01] <masak> FROGGS++

[16:04] *** denisboyun left
[16:10] *** thelorax123 joined
[16:17] *** zakharyas joined
[16:18] *** thelorax123 left
[16:19] *** thelorax123 joined
[16:19] <FROGGS> nr: .say for 1, 2, 3 ... 10, 20 ... 100, 125 ... 200

[16:19] <camelia> niecza v24-98-g473bd20: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§20‚ê§30‚ê§40‚ê§50‚ê§60‚ê§70‚ê§80‚ê§90‚ê§100‚ê§125‚ê§150‚ê§175‚ê§200‚ê§¬ª

[16:19] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Cannot call 'infix:<...>'; none of these signatures match:‚ê§:($a, Mu $b)‚ê§  in any  at gen/jvm/BOOTSTRAP.nqp:1201‚ê§  in block  at /tmp/LrYxsBRCgM:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚Ä¶¬ª

[16:19] <camelia> ..rakudo-parrot abdccc: OUTPUT¬´Cannot call 'infix:<...>'; none of these signatures match:‚ê§:($a, Mu $b)‚ê§  in any  at gen/parrot/BOOTSTRAP.nqp:1218‚ê§  in any  at gen/parrot/BOOTSTRAP.nqp:1209‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16316‚ê§  in block  at /tmp/dhs9QknbUn:1‚Ä¶¬ª

[16:20] <FROGGS> aww

[16:20] <masak> too soon, prob'ly.

[16:20] <FROGGS> yeah... though I thought rp rebuilds at 8 * * * *

[16:21] *** thelorax123 left
[16:21] <jnthn> std: .say for 1, 2, 3 ... 10, 20 ... 100, 125 ... 200

[16:21] <camelia> std 8adbc60: OUTPUT¬´ok 00:01 123m‚ê§¬ª

[16:21] <dalek> rakudo/nom: c205efa | (Elizabeth Mattijsen)++ | src/vm/jvm/core/ (3 files):

[16:21] <dalek> rakudo/nom: Fix .cue, damn you MMD!

[16:21] <dalek> rakudo/nom: 

[16:21] <dalek> rakudo/nom: Turns out I got bitten by unexpected MMD behaviour with multiple named

[16:21] <dalek> rakudo/nom: parameters.  I can't help but wonder how many people will be bitten by

[16:21] <dalek> rakudo/nom: this unexpected MMD behaviour in the future :-(

[16:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c205efac90

[16:22] <masak> many people, no doubt.

[16:22] <dalek> roast: c9337f0 | (Elizabeth Mattijsen)++ | S17-concurrency/scheduler.t:

[16:22] <dalek> roast: Extra .cue tests

[16:22] <dalek> roast: review: https://github.com/perl6/roast/commit/c9337f06ca

[16:22] *** thelorax123 joined
[16:24] *** thelorax123 left
[16:24] <masak> p: multi x(:$foo) { say 1 }; multi x(:$bar) { say 2 }; multi x(:$foo, :$bar) { say 3 }; x(:foo, :bar)

[16:24] <camelia> rakudo-parrot abdccc: OUTPUT¬´3‚ê§¬ª

[16:25] <masak> p: multi x(:$foo, :$bar) { say 3 }; multi x(:$foo) { say 1 }; multi x(:$bar) { say 2 }; x(:foo, :bar)

[16:25] <camelia> rakudo-parrot abdccc: OUTPUT¬´3‚ê§¬ª

[16:26] <masak> p: multi x(:$foo, :$bar) { say 1 }; multi x(:$foo, :$bar!) { say 2 }; x(:foo, :bar)

[16:26] <camelia> rakudo-parrot abdccc: OUTPUT¬´1‚ê§¬ª

[16:26] <masak> lizmat: something like that last one?

[16:26] <FROGGS> p: multi x(:$foo!) { say 1 }; multi x(:$bar) { say 2 }; multi x(:$foo!, :$bar) { say 3 }; x(:foo, :bar)

[16:26] <camelia> rakudo-parrot abdccc: OUTPUT¬´3‚ê§¬ª

[16:26] <FROGGS> p: multi x(:$foo!) { say 1 }; multi x(:$bar!) { say 2 }; multi x(:$foo!, :$bar) { say 3 }; x(:foo, :bar)

[16:26] <camelia> rakudo-parrot abdccc: OUTPUT¬´3‚ê§¬ª

[16:27] <jnthn> If you pass :foo and :bar then only a candidate taking a foo and a bar will pass the bind-check

[16:27] <masak> *nod*

[16:27] <jnthn> It's textual first one but you didn't create any ambiguity in these examples yet :)

[16:28] <jnthn> p: multi x(:$foo, :$bar) { say 1 }; multi x(:$foo!, :$bar!) { say 2 }; x(:foo, :bar)

[16:28] <camelia> rakudo-parrot cab740: OUTPUT¬´1‚ê§¬ª

[16:28] <FROGGS> nr: .say for 1, 2, 3 ... 10, 20 ... 100, 125 ... 200 # \o/

[16:28] <camelia> rakudo-parrot cab740, rakudo-jvm 882e33, niecza v24-98-g473bd20: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§20‚ê§30‚ê§40‚ê§50‚ê§60‚ê§70‚ê§80‚ê§90‚ê§100‚ê§125‚ê§150‚ê§175‚ê§200‚ê§¬ª

[16:28] <jnthn> That example is one where you might get surprised if you think nameds factor into the sorting in some way.

[16:29] <jnthn> I think the majority of confusion with methods and nameds and multi-dispatch probably comes from the *%_

[16:29] <jnthn> (which is implicit and easily forgotten)

[16:30] <masak> aye.

[16:30] *** raiph left
[16:30] <FROGGS> yay, I can unskip tests!

[16:31] <masak> usually during discussions about this behavior there is a point where methods and *%_ are mentioned, and everything becomes clear.

[16:34] <lizmat> scenario: (:$a!, :$b!) and (:$a!) as signatures, call with ( :a, :b ) will take the (:$a) candidate

[16:34] <lizmat> to me, that's a bug

[16:35] *** tobyink left
[16:37] <masak> oh, right, that's the one.

[16:38] <masak> just to be sure: are we talking about subs here, or methods?

[16:38] <masak> r: multi sub x(:$a!, :$b!) { say "a-b" }; multi sub x(:$a!) { say "a" }; x(:a, :b)

[16:38] <camelia> rakudo-parrot cab740, rakudo-jvm 882e33: OUTPUT¬´a-b‚ê§¬ª

[16:39] <lizmat> methods

[16:39] <masak> r: multi x(:$foo, :$bar) { say 3 }multi sub x(:$a!, :$b!) { say "a-b" }; x(:a, :b)

[16:39] <camelia> rakudo-jvm 882e33: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/DneSdxuLXz‚ê§Two terms in a row‚ê§at /tmp/DneSdxuLXz:1‚ê§------> [32mmulti x(:$foo, :$bar) { say 3 }[33m‚èè[31mmulti sub x(:$a!, :$b!) { say "a-b" }; x[0m‚ê§    expecting any of:‚ê§        postfi‚Ä¶¬ª

[16:39] <camelia> ..rakudo-parrot cab740: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/jIgb1OsbzI‚ê§Two terms in a row‚ê§at /tmp/jIgb1OsbzI:1‚ê§------> [32mmulti x(:$foo, :$bar) { say 3 }[33m‚èè[31mmulti sub x(:$a!, :$b!) { say "a-b" }; x[0m‚ê§    expecting any of:‚ê§        pos‚Ä¶¬ª

[16:39] <masak> p: multi x(:$foo, :$bar) { say 3 }; multi sub x(:$a!, :$b!) { say "a-b" }; x(:a, :b)

[16:39] <camelia> rakudo-parrot cab740: OUTPUT¬´a-b‚ê§¬ª

[16:39] <masak> lizmat: right. because with subs, it works.

[16:39] <masak> as you intend.

[16:40] <masak> lizmat: with methods, *%_ slurps up the :$b named, even in a multi method which does not declare a :b named.

[16:40] <masak> lizmat: so the methods actually tie, and so textually-first-one wins.

[16:40] *** kaare_ joined
[16:41] <lizmat> well, that's a nice technical explanation, but from a developers point of view, it's just confusing

[16:41] <masak> lizmat: which I guess is a way of saying, if you have a problem with that semantics, you have a problem with S12/Interface Consistency.

[16:41] <lizmat> hehe, indeed

[16:41] * lizmat makes not to go over S12 again

[16:42] <lizmat> *note

[16:42] <masak> and every criticism against the current semantics should start from the assumptions made in that section.

[16:42] <masak> or at least take them into account somehow.

[16:42] <masak> actually, I believe this is a case where A12 explains it in a bit more detail.

[16:42] <masak> (though possibly with very old syntax)

[16:48] *** xenoterracide left
[16:51] *** dmol joined
[16:56] <timotimo> yawn

[16:56] <timotimo> i'm not sure catching up on sleep with a kinda long nap was a very good idea

[16:56] *** djanatyn left
[16:57] <FROGGS> :/

[16:57] *** Tene left
[16:59] <masak> at least you're still in your own time zone. *grumble*

[16:59] <timotimo> apparently all i have to do to implement setelems is to use the "assign" pir op

[17:02] <dalek> rakudo-debugger: 78d3547 | (Steve Mynott)++ | lib/Debugger/UI/CommandLine.pm:

[17:02] <dalek> rakudo-debugger: typo fix

[17:02] <dalek> rakudo-debugger: review: https://github.com/jnthn/rakudo-debugger/commit/78d354720b

[17:02] <dalek> rakudo-debugger: 68db53f | jonathan++ | lib/Debugger/UI/CommandLine.pm:

[17:02] <dalek> rakudo-debugger: Merge pull request #17 from stmuk/master

[17:02] <dalek> rakudo-debugger: 

[17:02] <dalek> rakudo-debugger: typo fix

[17:02] <dalek> rakudo-debugger: review: https://github.com/jnthn/rakudo-debugger/commit/68db53fbc0

[17:04] *** cognominal left
[17:04] <lizmat> r: loop { CATCH { default { say "hi" } } }

[17:04] <camelia> rakudo-parrot cab740: OUTPUT¬´===SORRY!===‚ê§Error while compiling op handle: StopIteration‚ê§¬ª

[17:04] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´===SORRY!===‚ê§No such method 'jast' for invocant of type 'NQPMu'‚ê§¬ª

[17:04] <lizmat> these both seems LTA error messages

[17:04] <lizmat> should there be an error ?

[17:05] <jnthn> Looks like bug to me

[17:05] <jnthn> Shouldn't be an error at all

[17:05] <lizmat> that's what I thought

[17:05] <lizmat> r: loop { { CATCH { default { say "hi" } } } ; last} 

[17:06] <camelia> rakudo-parrot cab740, rakudo-jvm 882e33: ( no output )

[17:06] <lizmat> an extra block is a workaround, but shouldn't be needed, right ?

[17:06] <masak> shouldn't be needed.

[17:06] <masak> please submit.

[17:06] <timotimo> could it be the for @children -> $name, $handler_code loop in the handle compiling code?

[17:07] *** benabik joined
[17:07] * lizmat submitted rakudobug

[17:09] <lizmat>  #120498 for the interested

[17:09] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=120498

[17:10] <benabik> synopsebot++

[17:11] *** dmol left
[17:14] *** cognominal joined
[17:20] * FROGGS cries: Cannot .push an infinite list

[17:22] <colomon> push onto an infinite list, or push an infinite list onto something?

[17:22] <FROGGS> the latter

[17:22] <FROGGS> in:

[17:22] <colomon> Hmmm, I would hope that would work.

[17:23] <lizmat> I guess it could be done

[17:23] <FROGGS> nr: say 1 ... 5, 10 ... *

[17:23] <lizmat> but with some deep reification magic ?

[17:23] <camelia> niecza v24-98-g473bd20: OUTPUT¬´(timeout)¬ª

[17:23] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Cannot .push an infinite list‚ê§  in sub infix:<...> at gen/jvm/CORE.setting:16045‚ê§  in block  at /tmp/Ncy1kVajQd:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚ê§  in any command_eval at gen/jvm‚Ä¶¬ª

[17:23] <camelia> ..rakudo-parrot cab740: OUTPUT¬´Cannot .push an infinite list‚ê§  in method sink at gen/parrot/CORE.setting:11990‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16323‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16316‚ê§  in block  at /tmp/8irnLczrtP:1‚ê§  in any  at /tmp/8irnL‚Ä¶¬ª

[17:23] <colomon> I think that sort of thing is still on pmichaud++'s plate?

[17:23] <FROGGS> n: .say for 1, 2, 3 ... 10, 20 ... 100, 125 ... *

[17:23] <camelia> niecza v24-98-g473bd20: OUTPUT¬´(timeout)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§20‚ê§30‚ê§40‚ê§50‚ê§60‚ê§70‚ê§80‚ê§90‚ê§100‚ê§125‚ê§150‚ê§175‚ê§200‚ê§225‚ê§250‚ê§275‚ê§300‚ê§325‚ê§350‚ê§375‚ê§400‚ê§425‚ê§450‚ê§475‚ê§500‚ê§525‚ê§550‚ê§575‚ê§600‚ê§625‚ê§650‚ê§675‚ê§700‚ê§725‚ê§750‚ê§‚Ä¶¬ª

[17:24] <FROGGS> nr: say (1 ... 5, 10 ... *)[20]

[17:24] <camelia> niecza v24-98-g473bd20: OUTPUT¬´85‚ê§¬ª

[17:24] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Cannot .push an infinite list‚ê§  in sub infix:<...> at gen/jvm/CORE.setting:16045‚ê§  in block  at /tmp/fDiotqAq_e:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚ê§  in any command_eval at gen/jvm‚Ä¶¬ª

[17:24] <camelia> ..rakudo-parrot cab740: OUTPUT¬´Cannot .push an infinite list‚ê§  in method sink at gen/parrot/CORE.setting:11990‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16323‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16316‚ê§  in block  at /tmp/oBk7VVWhnt:1‚ê§  in any  at /tmp/oBk7V‚Ä¶¬ª

[17:24] <colomon> seems like it should be reasonable to join two lists even if one or both are infinite.  and push is just a join...

[17:25] <FROGGS> nr: say (1 ... 5, 10 ... *)[^20]

[17:25] <camelia> rakudo-parrot cab740: OUTPUT¬´Cannot .push an infinite list‚ê§  in method sink at gen/parrot/CORE.setting:11990‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16323‚ê§  in sub infix:<...> at gen/parrot/CORE.setting:16316‚ê§  in block  at /tmp/eQ7MotE3Lx:1‚ê§  in any  at /tmp/eQ7Mo‚Ä¶¬ª

[17:25] <colomon> FROGGS: based on what you were saying yesterday, niecza's probably not even doing a push at all in that case.

[17:25] <camelia> ..niecza v24-98-g473bd20: OUTPUT¬´1 2 3 4 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80‚ê§¬ª

[17:25] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Cannot .push an infinite list‚ê§  in sub infix:<...> at gen/jvm/CORE.setting:16045‚ê§  in block  at /tmp/qZYqYEfloH:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚ê§  in any command_eval at gen/jvm‚Ä¶¬ª

[17:26] <jnthn> rj: say "I seem more reliable nowadays..."

[17:26] <camelia> rakudo-jvm 882e33: OUTPUT¬´I seem more reliable nowadays...‚ê§¬ª

[17:26] <moritz> \o/

[17:26] <lizmat> I guess src/core/List, line 189 needs some further study

[17:26] <moritz> but, uhm, 882e33 is like, really old

[17:27] <moritz> from Oct 23

[17:27] <FROGGS> rp: my @a := ( ^4, 10 ... * ).flat # that is what niecza does

[17:27] <camelia> rakudo-parrot cab740: ( no output )

[17:27] <FROGGS> rp: my @a := ( ^4, 10 ... * ).flat; say @a[^10]

[17:27] <camelia> rakudo-parrot cab740: OUTPUT¬´Unable to deduce sequence‚ê§  in method sink at gen/parrot/CORE.setting:11990‚ê§  in block  at gen/parrot/CORE.setting:16238‚ê§  in any coro at gen/parrot/CORE.setting:7398‚ê§  in method reify at gen/parrot/CORE.setting:7380‚ê§  in method reify at gen/pa‚Ä¶¬ª

[17:27] <moritz> but I kinda guess it's actually newer than that

[17:28] <FROGGS> colomon: I think I can fix it

[17:28] <moritz> j: my $p = start { say 42 }; $p.wait

[17:28] <camelia> rakudo-jvm 882e33: OUTPUT¬´No such method 'schedule_with_catch' for invocant of type 'Scalar'‚ê§  in method start at gen/jvm/CORE.setting:17172‚ê§  in block  at /tmp/m0wRqnMw77:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚Ä¶¬ª

[17:28] <moritz> erm, what?

[17:28] *** spider-mario joined
[17:29] <lizmat> hmmm... did I break that ?

[17:29] <lizmat> guess I did

[17:30] <dalek> nqp: 99d42a4 | (Timo Paulssen)++ | src/vm/parrot/QAST/Operations.nqp:

[17:30] <dalek> nqp: pre-size lists if we know the size at compile-time.

[17:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/99d42a4b6e

[17:31] <dalek> rakudo/nom: 8e2ee89 | (Elizabeth Mattijsen)++ | src/vm/jvm/core/P (2 files):

[17:31] <dalek> rakudo/nom: Fix start {} and friends

[17:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8e2ee898be

[17:32] <lizmat> moritz: missed that in the migration to new spec

[17:32] <lizmat> (and there are apparently no tests for it)

[17:32] <lizmat> dinner&

[17:32] <moritz> aka we have no tests for start yet?

[17:33] <jnthn> There must be tests for it, unless they didn't get updated yet

[17:33] <lizmat> will look after dinner&

[17:33] <jnthn> 'cus I wrote various tests for async { ... } a week and a half ago, I'm sure...

[17:35] *** kivutar joined
[17:37] <timotimo> FROGGS: do you remember the work we've done on QRPA and stuff?

[17:37] <timotimo> do you think we should bring it up to date again?

[17:38] <timotimo> i don't really recall why we didn't finish it

[17:38] <moritz> something about serialization?

[17:38] <timotimo> oh, there was something, indeed!

[17:41] <timotimo> and i stole quicksort from parrot

[17:42] <timotimo> i wonder if it'd be good for rakudo to implement timsort at some point

[17:42] <moritz> timotimosort

[17:42] <timotimo> haha, no, definitely not :)

[17:43] <timotimo> i just used qlist in the qast compiler for parrot and it didn't seem to break during the build

[17:43] <timotimo> so maybe the serialisation issue was fixed in master at some point?

[17:44] <FROGGS> timotimo: I though we're using QRPA's, no?

[17:45] <timotimo> we're not

[17:45] <timotimo> at the moment we're still using ResizablePMCArray

[17:45] <timotimo> and i don't know if we have a QRPA equivalent for ResizableStringArray and ResizableIntegerArray

[17:48] * timotimo gets super ballsy and turns default_for('@') from list to qlist

[17:48] <jnthn> No, though on non-Parrot, list_[sin] are implemented that way.

[17:49] <jnthn> All lits on JVM and Moar are using the QRPA algorithm

[17:49] <timotimo> good choice

[17:49] <timotimo> jnthn: how do you feel about a commit or multiple that turn lots of .pop etc into nqp::pop etc?

[17:50] <timotimo> becaue qrpa doesn't have those methods. i have a commit stashed away in the far past that adds the methods, but pm said it has a very strongly negative performance impact

[17:51] *** cognominal left
[17:52] <jnthn> I cna't see it being worse than .pop today on RPA.

[17:52] <jnthn> And .pop works on @foo in NQP code.

[17:52] <jnthn> On non-Parrot it's just a normal method that does nqp::pop(self)

[17:52] *** ssutch joined
[17:53] <timotimo> OK, i'll pull in the commit that adds the methods in that case

[17:55] <timotimo> jnthn: would you still accept patches to turn the methods into ops, if they are that much faster?

[17:55] <timotimo> only for hot paths, i suppose

[17:55] <timotimo> and finding those is ... sometimes challenging :(

[17:56] <jnthn> timotimo: I'd rather keep the code cleaner

[17:56] <jnthn> timotimo: JVM may already be inlining them, and Moar will learn to.

[17:57] <dalek> rakudo/nom: 0cfe87b | (Tobias Leich)++ | src/core/operators.pm:

[17:57] <dalek> rakudo/nom: optimize infix:<...> for lols

[17:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cfe87b028

[17:57] <timotimo> that's all right

[17:58] <dalek> roast: 755cd56 | (Tobias Leich)++ | S03-sequence/misc.t:

[17:58] <dalek> roast: unfudge now passing tests

[17:58] <dalek> roast: review: https://github.com/perl6/roast/commit/755cd56668

[17:58] <timotimo> FROGGS: good work! :)

[17:58] <FROGGS> thanks :o)

[17:59] <moritz> http://www.pyret.org/ looks interesting

[17:59] <moritz> they have whatever-currying, thought with _ instead of *

[18:01] *** colomon left
[18:01] <timotimo> jnthn: should i change nqp::list to create a QRPA instead of a RPMCA, or should i change default_for('@') to qlist? i'd tend to do the former

[18:02] <jnthn> timotimo: I think we could just try switching nqp::list over and seeing what happens

[18:03] <timotimo> yes, i'll try that next

[18:09] <timotimo> i wish i didn't have to implement bitmaps+skiplists for cclasses to figure out how much time that would shave off the parse time >_>

[18:10] <jnthn> Well, the scarier bit of implementing it is that it'll need NFA support too...

[18:10] <timotimo> oh

[18:10] <jnthn> Since cclasses are declarative

[18:10] <timotimo> how many backends do i have to touch?

[18:10] <jnthn> All of 'em

[18:10] <timotimo> is that all shared stuff?

[18:10] <timotimo> oh my >_<

[18:10] <jnthn> Well

[18:10] <jnthn> NFA construction is shared

[18:10] <jnthn> NFA evaluation is per-backend 'cus it's rather performance sensitive.

[18:11] <timotimo> yes

[18:11] <timotimo> oof

[18:11] <jnthn> Anyway, not trying to put you off, just saying it's a non-trivial undertaking :)

[18:12] <jnthn> Or rather, letting you have a reasonably correct guesstimate of the magnitude of the task so you know before you start :)

[18:12] <timotimo> yeah. moritz was hoping he could do it, so i already feared it would be something hard :)

[18:13] <dalek> Heuristic branch merge: pushed 33 commits to rakudo/moar-support by jnthn

[18:14] <timotimo> well, first i'll look at what a skip list looks like and see if i can figure out how to implement something like that for cclasses

[18:14] <timotimo> on the other hand, it may already be a performance boost for bigger cclasses to ensure that the codes are sorted and then do a binary search instead of a linear scan

[18:15] <jnthn> Well, the "cheap" solution may be to introduce an alternative to enumcharlist that is enumcharrange :)

[18:16] <jnthn> But don't know that'd give as much benefit.

[18:17] <timotimo> it would certainly do so for pathological cases like \x[0]..\x[FFFFFFFF] or whatever j)

[18:17] <timotimo> ;)

[18:18] <timotimo> but the last time i saw that, it threw an error for "invalid character FOO", which the range version wouldn't do on its own

[18:19] <jnthn> Not sure that's a feature ;)

[18:20] * timotimo can't find the mention in the irclog any more

[18:23] <timotimo> i'm not sure a skiplist is the data structure that moritz had in mind; at least it doesn't have anything about ranges "in it"

[18:24] <jnthn> I thought it was an inversion list...

[18:24] <moritz> skip list, inversion list, all the same

[18:24] <moritz> at least for some definitions :-)

[18:24] <jnthn> oh :)

[18:24] <moritz> and yes, it's basically just an implementation of a set of ranges

[18:25] <timotimo> OK

[18:26] *** tobyink joined
[18:26] <timotimo> i can't find any mention of inversion lists on the wikepedia :|

[18:27] <timotimo> and just changing RPMCA to QRPA causes some test failures

[18:28] <moritz> I think I've written something about inversion lists on perlmonks, let me dig it up for you

[18:29] *** dmol joined
[18:29] <timotimo> cool, thanks

[18:30] <moritz> timotimo: http://www.perlmonks.org/?node_id=908453

[18:34] <timotimo> seems like punching holes into cclasses like that would be a pretty simple operation using the demorgan trick

[18:36] <moritz> yes

[18:36] *** ajr joined
[18:37] *** ajr is now known as Guest11767

[18:37] *** Guest11767 is now known as ajr_

[18:40] <TimToady> FROGGS: .push is defined to be eager, you want .plan for a lazy push (though afaik it's NYI)

[18:45] * TimToady still thinks two-level lazy bitmaps like P5 uses are the right way to do cclasses, since the set bits tend to clump

[18:46] *** raiph joined
[18:46] <timotimo> i don't know what that means :|

[18:46] <TimToady> that's why I said it :P

[18:46] <timotimo> two-level, does that mean you have one top-level bitmap to state where sub-bitmaps are?

[18:48] <TimToady> well top level can be an array or a hash of bitmaps, divvied up by the high bits of value you're looking up

[18:49] <TimToady> iirc the first swatch is 256 bits, and subsequent swatches are 128 bits in p5

[18:49] <TimToady> I think p5 uses a hash at the top level, call a 'swash', short for swatch hash

[18:50] <TimToady> unless it's changed recently

[18:50] <masak> Zefram's bug reports are awesome.

[18:50] <TimToady> anyway, it's pretty fast, and basically constant lookup unless you get a "miss"

[18:50] <masak> I wonder what causes #120484.

[18:50] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=120484

[18:51] <timotimo> i don't understand, why does a miss give you bad performance?

[18:52] <TimToady> it just has to generate the new swatch from the "heavy" version that knows all the bits

[18:52] <TimToady> but as with most things in p5, if you've done something once, it assumes you're going to do it again, so it never throws away swatches once they're generated

[18:53] <timotimo> oh, is that for insertion of new bits?

[18:53] <TimToady> let's say it digests a chunk of the low-speed complete data into high-speed incomplete data

[18:54] <timotimo> ah, that's why it's lazy?

[18:54] <TimToady> you generally only need to keep the bits that you use, and most strings use a very small subset of Unicode

[18:54] <TimToady> but the swatches have good locality for script blocks, if you're in Swahili or some such

[18:54] <TimToady> well, Devangari would be a better exmaple

[18:55] <TimToady> whereas skip lists for, say, digits, are going to pick a few characters out of each block, and be badly fragmented

[18:56] <TimToady> and a binary search has got to be slower than a two-level lookup for anything vaguely complicated

[18:56] <timotimo> ah, sure

[18:57] <timotimo> i still don't know where a miss comes into the picture, though. my current understanding is we can create the whole two-level datastructure from parsing a character class definition and then query it later while running the regex

[18:58] <TimToady> there's no point in creating the parts of the bitmap that will never be used

[18:59] <TimToady> at least, not in memory

[18:59] <timotimo> ah, OK

[18:59] <TimToady> p5 basically generates the bitmaps from skiplists that are on disk

[18:59] <TimToady> but only a swatch at a time

[19:00] <timotimo> the skiplists on disk are like a skiplist for :alpha:, a skiplist for :digit:, ...?

[19:00] <TimToady> yes

[19:00] <TimToady> those are all pregenerated from the unicode data

[19:01] <TimToady> p5's bitmaps are optimized for utf8 though

[19:01] <timotimo> is there a smart way to handle intersections/subtractions of cclasses there?

[19:01] <TimToady> so the first N-1 bytes of utf8 find the swatch, and the final byte looks up the bit

[19:01] *** darutoko left
[19:02] <TimToady> don't remember what p5 does there, but it's certainly possible to merge skip lists

[19:02] <timotimo> sounds like a lot of work in any case :P

[19:03] <timotimo> i guess i can write up a detailed quest description for questhub for this whole thing

[19:03] <TimToady> well, if you want it to start up fast, and run fast...

[19:03] <TimToady> there is prior art in p5, at least

[19:03] <timotimo> it would include pregenerating the skip lists during nqp compilation, then implementations for that stuff in the NFA for all three backends and probably also for all three QAST Compilers for the QRegex nodes?

[19:06] <TimToady> one could view the skip lists as the basic implementation, and the lazy bitmaps as a mere optimization

[19:06] <timotimo> that sounds like a good milestone, actually

[19:07] <timotimo> i suppose those also don't have to be pre-generated at nqp-compiler-compile-time from the statr

[19:07] <TimToady> also "two-level bitmap" is a little misleading, if the top level is really a hash

[19:07] <TimToady> so there's some overhead in hashing the non-bitmap index

[19:07] <timotimo> that shouldn't be terribly bad

[19:09] <TimToady> well, once could throw memory at it and make it an array instead; if your bitmaps were 256 bits, then you'd have 0x10ff entries in the top level array, so one could go with three levels instead

[19:09] <TimToady> *one

[19:10] <TimToady> lots of ways to do it, most of them faster than skip lists

[19:10] <TimToady> well, maybe not most, but some :)

[19:11] <TimToady> well, I'm paying good money for this conference, so I'd better attend some of it...

[19:11] <TimToady> afk &

[19:12] <timotimo> have fun! :)

[19:12] <timotimo> and thanks for your time

[19:15] <GlitchMr> https://github.com/rakudo/rakudo/commit/c31f307885a912ff2cba260549c1e7c0fd1cbae4

[19:15] <GlitchMr> Huh? Methods with empty prototype are constants?

[19:17] <jnthn> GlitchMr: No, doing them as a sub just to have a place to hang DEPRECATED calls 

[19:17] <jnthn> GlitchMr: Which you can't on a constant.

[19:19] * jnthn bbiab

[19:21] <timotimo> http://questhub.io/realm/perl/quest/527e8b569f567ad27a000054 - writeup

[19:23] *** raiph left
[19:23] *** q1999 joined
[19:23] *** kurahaupo joined
[19:25] *** q1999 left
[19:25] <benabik> ++timotimo

[19:25] <timotimo> doesn't mean i'll actually tackle it

[19:25] <benabik> Oh, well then.  --timotimo  ;-)

[19:25] <timotimo> haha.

[19:25] <benabik> timotimo++ # Good writeup

[19:25] <timotimo> moritz isn't on questhub, otherwise i would have invited him :)

[19:27] <GlitchMr> https://github.com/perl6/specs/commit/d8cd922a5a4c69e68f96867432b62cac2ba65e0a

[19:27] <GlitchMr> I liked it :-(.

[19:27] <FROGGS> TimToady: hmmm, we could implement @a.plan(@b) like: @a := (@a, @b).list, right?

[19:27] <timotimo> oh!

[19:29] *** raiph joined
[19:29] <timotimo> nqp-p: my $t := nqp::time_n(); "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ~~ /<[a..zA..Z]>+/; say nqp::time_n() - $t;

[19:29] <camelia> nqp-parrot: OUTPUT¬´Confused at line 2, near "say nqp::t"‚ê§current instr.: 'panic' pc 16305 (gen/parrot/stage2/NQPHLL.pir:6018) (gen/parrot/stage2/NQPHLL.nqp:426)‚ê§¬ª

[19:30] <timotimo> nqp-p: my $t := nqp::time_n(); "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:30] <camelia> nqp-parrot: OUTPUT¬´0.000205039978027344‚ê§¬ª

[19:30] <timotimo> too fast to give a meaningful benchmark %)

[19:30] <timotimo> nqp-p: my $data := nqp::x("a", 10000); my $t := nqp::time_n(); $data ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:30] <camelia> nqp-parrot: OUTPUT¬´0.00267195701599121‚ê§¬ª

[19:30] <timotimo> nqp-p: my $data := nqp::x("a", 100000); my $t := nqp::time_n(); $data ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:30] <camelia> nqp-parrot: OUTPUT¬´0.0246500968933105‚ê§¬ª

[19:30] <timotimo> nqp-p: my $data := nqp::x("Z", 100000); my $t := nqp::time_n(); $data ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:30] <camelia> nqp-parrot: OUTPUT¬´0.0549299716949463‚ê§¬ª

[19:31] <timotimo> hehe

[19:31] <timotimo> binary search should equalise those times to something in between

[19:36] <timotimo> nqp-p: my $data := nqp::x("a", 10000000); my $t := nqp::time_n(); $data ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:36] <camelia> nqp-parrot: OUTPUT¬´2.14942002296448‚ê§¬ª

[19:36] <timotimo> nqp-p: my $data := nqp::x("Z", 10000000); my $t := nqp::time_n(); $data ~~ /<[a..zA..Z]>+/; say(nqp::time_n() - $t);

[19:36] <camelia> nqp-parrot: OUTPUT¬´5.0132429599762‚ê§¬ª

[19:36] <timotimo> (less noise, hopefully)

[19:36] <moritz> timotimo: I'm pretty sure I am

[19:36] <moritz> (on questhub, that is)

[19:36] <timotimo> oh, yes!

[19:36] <timotimo> invited :)

[19:37] <timotimo> feel free to delegate sub-tasks to me if you think i can do something for you in this quest 

[19:39] <moritz> my plan is to first prototype it in pretty high-level NQP

[19:39] <moritz> and then figure out the rest from there

[19:40] <timotimo> well, first i'll plop a binary search onto the cclass matching and see if that helps any :)

[19:40] <moritz> timotimo: only do that when there are more than 10 or 20 chars in the char class,

[19:41] <moritz> otherwise a linear search is likely faster

[19:41] <timotimo> i should be able to do that

[19:42] <timotimo> hm, how about doing a two-layer approach, where i only look into the middle and then do a linear search from either the middle or the beginning?

[19:42] <FROGGS> my @odd = 1,3,5 ... 8; say @odd[^4] # this will correctly hang, because the RHS is not known to be infinite, right?

[19:43] <timotimo> 8 is not known to be infinite? :)

[19:43] <timotimo> oh, *THAT* RHS :)

[19:43] <FROGGS> *g*

[19:43] <timotimo> yes, but we had a discussion recently that rakudo should, for simple series like these, warn if the end point is not part of the series

[19:44] <timotimo> because in that case the developer could just as well have written * instead of 8

[19:46] <timotimo> i wonder at what point one would have to insert code to detect that a regex without captures and with only declarative elements is being used

[19:46] <timotimo> because in that case, there's no need to do more than run the NFA on it, right?

[19:47] <timotimo> the NFA knows how to do non-anchored matches, right?

[19:47] <masak> Publish... is a class?

[19:49] <moritz> timotimo: NFA matches are always implicitly anchored

[19:49] <moritz> timotimo: at the QAST level, everything except :rxtype<scan> is anchored

[19:49] <moritz> (at the start)

[19:50] <timotimo> ah

[19:50] <timotimo> IIUC it's very easy to teach a NFA to scan

[19:51] *** kivutar left
[19:52] <moritz> I'm not so sure

[19:53] <moritz> you have to add a .*? at the start

[19:53] <moritz> and I don't think frugal quantifiers are in REG

[19:53] *** zakharyas left
[19:53] <benabik> [^first letter]

[19:53] <benabik> [^first letter]*

[19:54] <benabik> Oh, no that doesn't work does it, because the prefix might have it.  Darn.

[19:54] <moritz> stuff ain't easy :-)

[19:55] <timotimo> well, all i think i'll need to add is a loop from the start state back to the start state that eats any character

[19:56] <timotimo> and then it would be enough to run until the first fate is encountered

[19:56] <timotimo> (if the search isn't exhaustive etc etc)

[19:56] <moritz> and then how do you know where the actual regex has started matching?

[19:57] <timotimo> *oh*

[19:57] <timotimo> hehe :)

[19:57] <benabik> NFA?  Then you just match not first letter and on first letter transition to both starting the literal matching and not.  ;-)  Non-determinism is fun that way.

[19:59] <moritz> benabik: note that in computer science, NFAs are just used for boolean questions, "does that match?"

[20:00] <moritz> benabik: and in that spirit, you can just prepend .* to the regex, and it scans

[20:00] <moritz> benabik: but for our purposes, we are searching for the longest match of the regex after the .*, but .* is greedy

[20:01] <moritz> benabik: *and* we need to know where the stuff that comes after the .* started matching

[20:02] <masak> 'night, #perl6

[20:02] <timotimo> 'night masak :)

[20:03] <timotimo> i hope t4 reviews were good to you today :)

[20:03] <benabik> moritz: Well, if we could actually run non-deterministically it wouldn't be too hard.  Shame quantum computers are still pie-in-the sky.  The difficulty is really in doing it deterministically.

[20:03] <timotimo> Perl6/Grammar.nqp has 7 enumcharlist nodes that have more than 20 characters

[20:05] <moritz> do you know how big they are?

[20:05] <timotimo> yes

[20:06] <timotimo> 2x 192, 1x 26, 4x 62

[20:07] <timotimo> 6 more are compiled during setting compilation: 5x 52, 1x26

[20:07] <lue> how do I find out the number of parameters that need to be passed to WhateverCode?

[20:07] <benabik> How many there are is somewhat less important than how often they get used.

[20:08] <benabik> r: (* + *).arity.say

[20:08] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: ( no output )

[20:09] <benabik> Got caught by the whatever code expanding...

[20:09] <benabik> r: my &a = *+*; say &a.arity

[20:09] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´2‚ê§¬ª

[20:09] <moritz> overcurried!

[20:09] <FROGGS> rp: my $a := (* + *); say $a.signature.count

[20:09] <camelia> rakudo-parrot 0cfe87: OUTPUT¬´2‚ê§¬ª

[20:09] *** raiph left
[20:10] <lue> benabik: I'm just accepting as input P6 *-5..*-1 notation for ranges, so I just need to know how many times to give it the array size.

[20:11] <timotimo> tbh, more interesting would be to know how often they are matched against

[20:11] *** berekuk left
[20:12] <dalek> roast: 72e40a8 | (Tobias Leich)++ | S32-exceptions/misc.t:

[20:12] <dalek> roast: test for RT #73938

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/72e40a8b19

[20:12] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=73938

[20:16] <moritz> r: say nqp::div_i(5, 2)

[20:16] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´2‚ê§¬ª

[20:17] <FROGGS> nqp: say(nqp::div_i(5, 2))

[20:17] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT¬´2‚ê§¬ª

[20:18] <FROGGS> good.

[20:19] *** colomon joined
[20:22] *** ssutch left
[20:24] *** kivutar joined
[20:24] *** dmol left
[20:26] <FROGGS> timotimo: maybe this can be enhanced like cclasses too? https://github.com/perl6/nqp/blob/master/src/HLL/Grammar.nqp#L4

[20:27] <timotimo> wow, what a long-ass line :|

[20:28] <benabik> Except that's not a set of characters, it's a long list of pairs of characters.

[20:28] <FROGGS> true

[20:29] <timotimo> yeah, but still

[20:29] <timotimo> "# if it's a closing bracket, that's an error also"

[20:29] *** raiph joined
[20:29] <timotimo> it's not a problem, the list could be split in two just as well.

[20:30] <timotimo> that seems sensible. have a list of openers, a list of closers, sort the openers by index, have the closers have corresponding indices

[20:30] <benabik> You need to preserve the mapping between the pairs.

[20:31] <timotimo> yes, that's what i meant with "corresponding indices"

[20:31] <timotimo> maybe a hash would be better though?

[20:33] <FROGGS> dunno

[20:42] *** berekuk joined
[20:52] *** berekuk left
[20:53] <timotimo> though a hash of integers would probably be better than a string.

[20:54] <timotimo> er, a hash of single-character strings

[20:59] <dalek> nqp: dd3fde1 | (Tobias Leich)++ | src/QRegex/P6Regex/Grammar.nqp:

[20:59] <dalek> nqp: **0..1 to ? in token quantifier:sym<**>

[20:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dd3fde1ed1

[20:59] *** kivutar left
[20:59] <dalek> rakudo/moar-support: ce8cc4c | jnthn++ | src/ (2 files):

[20:59] <dalek> rakudo/moar-support: Start on sig binder for MoarVM.

[20:59] <dalek> rakudo/moar-support: 

[20:59] <dalek> rakudo/moar-support: Doesn't bind anything beyond the empty signature so far.

[20:59] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/ce8cc4c334

[21:00] <timotimo> \o/

[21:01] <FROGGS> \o/ # indeed!

[21:02] <timotimo> FROGGS: fwiw, i don't think the bracket searching code will hit any high numbers often at all

[21:02] <timotimo> so it may be superfluous or even detrimental to put a binary search there

[21:02] <timotimo> most brackets are (), [], <> or {}, perhaps ¬´¬ª.

[21:02] <FROGGS> timotimo: ahh, yes, true

[21:04] <moritz> uhm, is the order of arguments of nqp::splice different from Perl 5 splice?

[21:04] <timotimo> yes

[21:04] <timotimo> oh

[21:04] <timotimo> it is different from perl6 splice, that muc hi know

[21:06] <timotimo> maybe it would be a good first step to make a "charrange" qregex node instead of making the whole skip list thing directly

[21:06] <dalek> rakudo/moar-support: 4a0502f | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:06] <dalek> rakudo/moar-support: Handle anonymous capture params.

[21:06] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/4a0502f284

[21:06] <timotimo> and that could only be used if the characters are in one contiguous range

[21:11] <moritz> nqp-p syntax errors consistently point to one line below the line with the error

[21:11] *** logie left
[21:11] <timotimo> i've experienced that, too

[21:13] *** Tene joined
[21:13] *** Tene left
[21:13] *** Tene joined
[21:16] <moritz> https://github.com/perl6/nqp-inversion-list

[21:17] <moritz> so far it's an untested NQP port of Set::IntSpan::Fast::PP

[21:21] <timotimo> maybe later i'll write some tests for you

[21:22] <moritz> \o/

[21:22] <moritz> sleep&

[21:22] <FROGGS> gnight moritz

[21:22] <timotimo> gnite moritz

[21:22] <jnthn> 'night, moritz++

[21:23] *** tobyink left
[21:24] *** logie joined
[21:24] *** davecc joined
[21:27] *** zakharyas joined
[21:29] *** logie_ joined
[21:30] *** logie left
[21:32] <dalek> nqp: 40d723f | dwarring++ | examples/rubyish/ (2 files):

[21:32] <dalek> nqp: minor rubyish fixes to variables, signatures and precedence

[21:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/40d723fe05

[21:39] *** pochi joined
[21:40] *** kaare_ left
[21:43] *** ggoebel joined
[21:47] <itz> is [email@hidden.address] correct for rt bug reports?

[21:48] <FROGGS> I only know  [email@hidden.address]
[21:49] <itz> are rt email bug reports usually lagged?

[21:50] <FROGGS> itz: though, I've heard you  can create them in the web interface nowadays

[21:50] <FROGGS> itz: not sure

[21:51] *** ingy^ joined
[21:51] *** lue left
[21:54] <itz>  [email@hidden.address] as displayed on the rt webpage clearly doesn't work

[21:55] <FROGGS> write a bug report then *g*

[21:57] <itz> I did :P

[21:57] <FROGGS> itz: btw, that is exactly what I feared... the last star release bumped the submodule versions, but somehow the submodules are still old

[21:57] *** ajr_ left
[21:57] <itz> I don't think the git checkouts are on master

[21:58] <FROGGS> I am talking about that: https://github.com/rakudo/star/commit/528fe30f078285910294fcfa9190c465d5a23ed1

[22:00] <FROGGS> jnthn: it fails to build m-Metamodel on linux because it can't find 'ModuleLoader.moarvm' which is in nqp/

[22:00] <FROGGS> just wanna let you know... I'm going to debug that now

[22:00] <itz> FROGGS: ah I see

[22:00] <jnthn> FROGGS: That...makes no sense :S

[22:00] <jnthn> FROGGS: As in, I don't know of anything platform specific in that area...

[22:01] <jnthn> FROGGS: Anyways, debugging very welcome :)

[22:01] <FROGGS> :o)

[22:04] <timotimo> hmm. so how do i do the test stuff ...

[22:04] *** lue joined
[22:04] <timotimo> can i just "use InversionList" in t/ and have -Ilib?

[22:05] <FROGGS> nqp: use lib 't'

[22:06] <camelia> nqp-jvm: OUTPUT¬´java.nio.file.NoSuchFileException: lib‚ê§  in  (src/vm/jvm/ModuleLoader.nqp:62)‚ê§  in load_module (src/vm/jvm/ModuleLoader.nqp:52)‚ê§  in load_module (gen/jvm/stage2/NQP.nqp:284)‚ê§  in statement_control:sym<use> (gen/jvm/stage2/NQP.nqp:2041)‚ê§  in !reduce (gen/jvm‚Ä¶¬ª

[22:06] <camelia> ..nqp-parrot: OUTPUT¬´"load_bytecode" couldn't find file 'lib.pbc'‚ê§current instr.: '' pc 1946 (gen/parrot/stage2/module_loader.pir:895) (src/vm/parrot/ModuleLoader.nqp:55)‚ê§¬ª

[22:06] <camelia> ..nqp-moarvm: OUTPUT¬´(signal ABRT)While looking for 'lib.moarvm': no such file or directory‚ê§frame_name_33‚ê§¬ª

[22:06] <FROGGS> try it, I can't tell

[22:06] <timotimo> will do

[22:06] <timotimo> is there something i can use to compare two integer lists for equality in nqp or should i write my own sub?

[22:07] <japhb___> Oh jnthn, I keep forgetting to mention something while you're still online: I managed to blow the jvm stack a couple days agao by doing an async_qx that had to read a lot of lines.  At the time I didn't have a chance to golf the problem, but does it ring a bell?

[22:08] <jnthn> japhb___: If you were unlucky enough to hit a gather/take it could be that

[22:08] <japhb___> hmmm

[22:10] <japhb___> Is the gather/take problem in jvm likely to be a simple bug or a deeper issue?

[22:11] *** dmol joined
[22:11] <jnthn> japhb___: It's a bit nasty; I was hoping sorear++ might find tuits to do it as he undertands the gather/take on JVM best, but didn't see him in a long while :(

[22:12] <jnthn> japhb___: afaiu, each take accidentally makes the stack a level deeper

[22:12] *** xinming_ joined
[22:13] *** zakharyas left
[22:14] <timotimo> nqp doesn't take -I

[22:14] <timotimo> that's probably why things for nqp are always catted together :P

[22:14] <jnthn> timotimo: It also requires things to have been compiled already, too

[22:14] <timotimo> ah, all i have to do is put it into . ?

[22:15] <jnthn> I guesss that works

[22:15] *** xinming left
[22:21] <timotimo> how do i even Makefile

[22:22] <timotimo> make: *** No rule to make target `lib/InversionList.nqp', needed by `InversionList.pir'.  Stop.

[22:22] <timotimo> but the file already exists :o

[22:22] <timotimo> oh, it's called .pm not .nqp

[22:23] <itz> "The submodule repositories added by ‚Äúgit submodule update‚Äù are ‚Äúheadless‚Äù. This means that they aren‚Äôt on a current branch.To fix this, we simply need to switch to a branch"

[22:26] *** emma joined
[22:26] *** Zoffix joined
[22:26] <timotimo> splice() not implemented in class 'ResizableIntegerArray' - huh!

[22:40] *** colomon left
[22:41] <timotimo> japhb___: since you're already looking at the inversion list, can you figure out if my test or the code is wrong?

[22:41] <timotimo> also, good catch on the infinity typo

[22:44] *** berekuk joined
[22:45] *** Zoffix left
[22:45] *** colomon joined
[22:56] *** berekuk left
[23:02] <itz> hmmm git submodules are *really* complex

[23:04] <timotimo> sleep &

[23:07] <lizmat> gnight timotimo 

[23:07] <lue> itz: integrating a project into your own frequently is :)

[23:09] <lizmat> just found an inconsistency:

[23:09] <lizmat> r: my &foo; say &foo.WHAT

[23:09] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´(Any)‚ê§¬ª

[23:10] <lizmat> r: sub a(:&b) { say &b.WHAT }; a()

[23:10] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´(Callable)‚ê§¬ª

[23:10] <lizmat> a &foo variable is different from a &foo parameter?

[23:11] <lue> r: my &foo; sub a(:&b) { say &b.WHAT }; a(:b(&foo));

[23:11] <camelia> rakudo-parrot 0cfe87: OUTPUT¬´Nominal type check failed for parameter '&b'; expected Callable but got Any instead‚ê§  in sub a at /tmp/BEpd93gJkp:1‚ê§  in block  at /tmp/BEpd93gJkp:1‚ê§  in any  at /tmp/BEpd93gJkp:1‚ê§  in any  at gen/parrot/stage2/NQPHLL.nqp:1146‚ê§  in any eval at ‚Ä¶¬ª

[23:11] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´Nominal type check failed for parameter '&b'‚ê§  in block  at /tmp/uZuye0JnXG:1‚ê§  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086‚ê§  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292‚ê§  in any command_eval at gen/jvm/stage2/NQPHLL.nqp:1196‚ê§  in any com‚Ä¶¬ª

[23:11] *** PacoAir left
[23:11] <lizmat> lue: indeed

[23:11] <lue> my $igil; my @rray; my %ash; my &ode; say $igil.WHAT; say @rray.WHAT; say %ash.WHAT; say &ode.WHAT;

[23:11] <lizmat> r: sub a(&b?) { say &b.WHAT }; a()  # doesn't have to be a named parameter

[23:11] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´(Callable)‚ê§¬ª

[23:12] <lue> r: my $igil; my @rray; my %ash; my &ode; say $igil.WHAT; say @rray.WHAT; say %ash.WHAT; say &ode.WHAT;

[23:12] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´(Any)‚ê§(Array)‚ê§(Hash)‚ê§(Any)‚ê§¬ª

[23:12] <lue> $ and & have something in common :)

[23:12] <lizmat> but why would that be diffferent for parameters ?

[23:12] <lue> $ -> Any makes sense to me, & -> Any less so. (It should be & -> Callable IMO, like @ -> Array or % -> Hash)

[23:13] <lue> r: sub a($ig, @rr, %as, &od) { say $ig.WHAT; say @rr.WHAT; say %as.WHAT; say &od.WHAT }

[23:13] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: ( no output )

[23:13] <lue> r: sub a($ig, @rr, %as, &od) { say $ig.WHAT; say @rr.WHAT; say %as.WHAT; say &od.WHAT }; a()

[23:13] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Calling 'a' requires arguments (lines 1, 1)‚ê§    Expected: :($ig, @rr, %as, &od)‚ê§¬ª

[23:13] <lue> r: sub a($ig?, @rr?, %as?, &od?) { say $ig.WHAT; say @rr.WHAT; say %as.WHAT; say &od.WHAT }; a()

[23:13] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´(Any)‚ê§(Array)‚ê§(Hash)‚ê§(Callable)‚ê§¬ª

[23:14] <lue> & is the only inconsistent one it seems.

[23:14] <lizmat> yup

[23:14] * lizmat submits rakudobug

[23:15] <lue> r: my ¬¢apture; say ¬¢apture.WHAT; # :P

[23:15] <camelia> rakudo-parrot 0cfe87: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/qQr9Im1L7B‚ê§Malformed my‚ê§at /tmp/qQr9Im1L7B:1‚ê§------> [32mmy [33m‚èè[31m¬¢apture; say ¬¢apture.WHAT; # :P[0m‚ê§    expecting any of:‚ê§        scoped declarator‚ê§¬ª

[23:15] <camelia> ..rakudo-jvm 882e33: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/0hCwgqXpZ4‚ê§Malformed my‚ê§at /tmp/0hCwgqXpZ4:1‚ê§------> [32mmy [33m‚èè[31m¬¢apture; say ¬¢apture.WHAT; # :P[0m‚ê§    expecting any of:‚ê§        scoped declarator‚ê§¬ª

[23:17] <lizmat> #120501 for those interested

[23:17] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=120501

[23:21] *** berekuk joined
[23:22] *** berekuk left
[23:22] *** bbkr_ joined
[23:23] *** spider-mario left
[23:24] <bbkr_> how to write :exists adverb on whatever star? assuming i have array of hashes and I want to grep only those with given key, old code: @hashes.grep: *.exists('key')

[23:25] *** panchiniak_ joined
[23:26] <lizmat> @hashes.grep: $_<key>:exists

[23:26] <lizmat> @hashes.grep: *<key>:exists  # perhaps?

[23:27] *** cognominal joined
[23:27] <bbkr_> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: *<a>:exists'

[23:27] <camelia> rakudo-jvm 882e33: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/eSTso9opUB‚ê§You can't adverb that‚ê§at /tmp/eSTso9opUB:1‚ê§------> [32m{a=>2}, {b=>3}; say @t.grep: *<a>:exists[33m‚èè[31m'[0m‚ê§    expecting any of:‚ê§        pair value‚ê§¬ª

[23:27] <camelia> ..rakudo-parrot 0cfe87: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/s12B7Y8Awc‚ê§You can't adverb that‚ê§at /tmp/s12B7Y8Awc:1‚ê§------> [32m{a=>2}, {b=>3}; say @t.grep: *<a>:exists[33m‚èè[31m'[0m‚ê§    expecting any of:‚ê§        pair value‚ê§¬ª

[23:28] <lizmat> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: $_<a>:exists

[23:28] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´‚ê§¬ª

[23:29] *** berekuk joined
[23:29] <lizmat> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: {$_<a>:exists}

[23:29] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´("a" => 1).hash ("a" => 2).hash‚ê§¬ª

[23:29] <FROGGS> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: {$_<a>:v}

[23:29] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´("a" => 1).hash ("a" => 2).hash‚ê§¬ª

[23:29] <bbkr_> thanks

[23:29] <lizmat> FROGGS: if any of the keys had 0 or Any as value, they wouldn't be included

[23:30] <lizmat> with :v I mean

[23:30] <FROGGS> yeah

[23:30] <bbkr_> why exists method was removed? it was much easier to use

[23:30] <FROGGS> I just wonder why the key is included when I ask for values... but maybe my expectations are off :o)

[23:31] <lizmat> FROGGS: it was a grep, not a map 

[23:32] <lizmat> bbkr_: because .exists only works on one key, whereas you can use :exists and other adverbs on slices

[23:32] <lizmat> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: {any($_<a b>:exists)}

[23:33] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´("a" => 1).hash ("a" => 2).hash ("b" => 3).hash‚ê§¬ª

[23:33] <lizmat> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: {all($_<a b>:exists)}

[23:33] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´("a" => 1).hash ("a" => 2).hash ("b" => 3).hash‚ê§¬ª

[23:33] <bbkr_> oh!

[23:34] <lizmat> hnnn... that last one seems incorrect  :-(

[23:34] <lizmat> ah, no, it is correct

[23:34] <lizmat> :exists also acts as a filter

[23:35] <lizmat> r: my @t = { a=>1}, {a=>2}, {b=>3}; say @t.grep: {all($_<a b>:!k)}

[23:35] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´("a" => 1).hash ("a" => 2).hash ("b" => 3).hash‚ê§¬ª

[23:35] <bbkr_> what does :exists(value) do?  I see test cases but cannot figure this out

[23:35] <lizmat> any adverb can be given a valu

[23:35] <lizmat> :foo is just foo => True

[23:35] <lizmat> :foo<bar> is foo => 'bar'

[23:36] <lizmat> :exists(True) is long for :exists, :exists(False) is long for :!exists

[23:36] <lizmat> any value given to :exists will be taken as a boolean

[23:37] <lizmat> same for :delete

[23:37] <lizmat> :delete($really)  # depend on boolean value of $really to really delete given keys

[23:38] <bbkr_> I'm surprised how consisted it is, making adverbs using colon-pair constructorÖ nice design

[23:38] <lizmat> r: my %a=(a=>1); say %a<a>:exists; say %a<b>:!exists

[23:38] <camelia> rakudo-parrot 0cfe87, rakudo-jvm 882e33: OUTPUT¬´True‚ê§True‚ê§¬ª

[23:39] <bbkr_> thanks for explanation. I'm off to fixing warnings in my modules now :)

[23:39] <lizmat> yw!

[23:42] *** cognominal left
[23:42] *** xenoterracide joined
[23:43] <dalek> rakudo/nom: f485315 | (Elizabeth Mattijsen)++ | src/vm/jvm/core/ (5 files):

[23:43] <dalek> rakudo/nom: Migrate cue_with_catch to cue(:&catch)

[23:43] <dalek> rakudo/nom: 

[23:43] <dalek> rakudo/nom: Also some left-behind schedule_* fixes.  Unfortunately, specifying a :catch()

[23:43] <dalek> rakudo/nom: currently blows up:

[23:43] <dalek> rakudo/nom: 

[23:43] <dalek> rakudo/nom: Unhandled exception: Method 'postcircumfix:<( )>' not found for invocant of class 'Scalar'

[23:43] <dalek> rakudo/nom:   in  (gen/jvm/BOOTSTRAP.nqp:1675)

[23:43] <dalek> rakudo/nom: 

[23:43] <dalek> rakudo/nom: Will look at this tomorrow, unless someone else beats me to this

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4853151eb

[23:44] <jnthn> lizmat++ # increasing bus number of the threading stuff :)

[23:44] <lizmat> and with this I bid you all a good night!

[23:44] <jnthn> 'night, lizmat 

[23:52] *** berekuk left
[23:52] <woolfy> Reini Urban played by Daniel Metz in movie Computer Chess ( http://www.imdb.com/title/tt2007360/ )

