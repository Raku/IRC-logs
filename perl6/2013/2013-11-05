[00:11] *** benabik left
[00:13] *** Psyche^ joined
[00:16] *** benabik joined
[00:16] *** Psyche^_ left
[00:21] <TimToady> I feel good now, forgetting preflex can handle messages too--in fact, the more I forget, the better I feel! :)

[00:28] *** benabik left
[00:33] *** ajr_ left
[00:38] *** benabik joined
[00:51] *** benabik left
[00:56] *** toebu joined
[00:57] *** wbill joined
[00:57] *** lawrmcfa left
[00:58] *** [Sno] left
[00:58] *** xalbo left
[00:58] *** Timbus left
[00:58] *** ivan`` left
[00:58] *** tipdbmp left
[00:58] *** risou_awy left
[00:58] *** moritz joined
[00:58] *** xalbo joined
[00:58] *** risou_awy joined
[00:59] *** ivan`` joined
[00:59] *** ivan`` left
[00:59] *** ivan`` joined
[00:59] *** camelia joined
[00:59] *** [Sno] joined
[01:00] *** Timbus joined
[01:00] *** ChanServ sets mode: +v camelia

[01:01] *** pernatiy joined
[01:05] *** wbill left
[01:07] *** wbill joined
[01:09] *** Guest76482 is now known as denysonique

[01:13] <dalek> specs: eb0f216 | larry++ | S04-control.pod:

[01:13] <dalek> specs: unspec statement_prefix:lift

[01:13] <dalek> specs: 

[01:13] <dalek> specs: This is going away in favor of better parameter declarations that can

[01:13] <dalek> specs: implicitly default to operators as seen by the caller.

[01:13] <dalek> specs: review: https://github.com/perl6/specs/commit/eb0f21689e

[01:17] <colomon> hmmm

[01:20] *** benabik joined
[01:25] *** tipdbmp joined
[01:40] *** benabik left
[01:53] <dalek> specs: f597d20 | larry++ | S17-concurrency.pod:

[01:53] <dalek> specs: Scheduler refinements/defilements

[01:53] <dalek> specs: 

[01:53] <dalek> specs: Renamed basic scheduler method to .cue

[01:53] <dalek> specs: Combined various other scheduler methods to use named parameters instead

[01:53] <dalek> specs: Added :at($instant) for a way to specify an absolute time

[01:53] <dalek> specs: Removed .outstanding because...

[01:53] <dalek> specs: Added .loads to give info on how many cues are in delayed/startable/running states

[01:53] <dalek> specs: review: https://github.com/perl6/specs/commit/f597d201ed

[02:02] *** benabik joined
[02:34] *** araujo left
[02:37] <dalek> specs: bd42b63 | larry++ | S17-concurrency.pod:

[02:37] <dalek> specs: s/cause/excuse/

[02:37] <dalek> specs: 

[02:37] <dalek> specs: Broken promises don't have causes, they have excuses.  :)

[02:37] <dalek> specs: (Plus .excuse is the same length as .result for better alignment, fwiw.)

[02:37] <dalek> specs: review: https://github.com/perl6/specs/commit/bd42b63230

[02:44] *** jnap joined
[02:47] *** jnthn left
[02:47] *** jnthn joined
[03:02] <dalek> perl6-roast-data: ac8e517 | coke++ | / (5 files):

[03:02] <dalek> perl6-roast-data: today (automated commit)

[03:02] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ac8e517949

[03:03] *** raiph joined
[03:03] *** mathw left
[03:04] *** mathw joined
[03:04] <dalek> specs: 7b9010f | larry++ | S17-concurrency.pod:

[03:04] <dalek> specs: Conjectures, s/keeper/vow/ to stay non-commital

[03:04] <dalek> specs: 

[03:04] <dalek> specs: Speculations in some spots that could have better syntax.

[03:04] <dalek> specs: 

[03:04] <dalek> specs: The word "keeper" kind of implies you're going to keep the promise,

[03:04] <dalek> specs: when in fact you might break it.  To avoid this overtone, as well

[03:04] <dalek> specs: as other unfortunate meanings of "keeper" ("Yep, he's a keeper!"),

[03:04] <dalek> specs: we rename the internal stewardship of the promise to "vow".

[03:04] <dalek> specs: review: https://github.com/perl6/specs/commit/7b9010f562

[03:05] <timotimo> oh! i thought that one was a keeper ...

[03:06] <lue> I wonder if TimToady has thought about the design of Perl 6 today.

[03:07] <[Coke]> good evening, you perl people

[03:09] *** johnny5_ left
[03:10] *** johnny5_ joined
[03:12] <TimToady> also, I dislike resurrecting the verb "select" when we've just taken out and shot the two forms of "select" from Perl 5...

[03:13] <TimToady> lue: no design, just a lot of opinions :)

[03:14] * lue slowly backs out of TimToady's office, "select/case" proposal in hand :)

[03:14] * TimToady is not against the concept, just the specific word :)

[03:16] <TimToady> it's really a kind of race, except we've used that word already

[03:17] <TimToady> well, the second form isn't a race, in the sense that it only looks to see if you already have a winner

[03:20] <TimToady> it's really a declaration of who is racing, so maybe "racers {...}" or some such

[03:23] <TimToady> or "racing {...}" to imply that a race is actually being run, with "racer" declarations inside like "when" statements, so that we can go back to ending cases with } rather than },

[03:26] *** johnny5_ left
[03:26] * lue should read S17 and see what -Ofun naming suggestions he comes up with.

[03:27] *** johnny5_ joined
[03:27] <lue> TimToady: I think I'd like racing { track { } } or racing { contestant { } } or somesuch instead of racing { racer { } }, if only to avoid too-similar names.

[03:30] <TimToady> at the moment I have winner { when $p1 {... } }

[03:32] <geekosaur> gate?

[03:32] <geekosaur> that is, racing / gate

[03:32] <raiph> why is it schedule.cue but promise.start (not promise.cue)?

[03:33] *** dansamo joined
[03:35] *** huf joined
[03:36] <TimToady> because a cue is at some point in time, but start means "asap"

[03:38] <TimToady> to look at it another way, the scheduler actually will start the closure when a thread becomes available to attach it to, while the promise is notionally scheduled immediately (though of course there could be delay in doing that)

[03:39] <TimToady> and .start sounds more impatient than .cue, which I think is appropriate for the two pragmatic contexts

[03:40] <TimToady> and .cue is really kinda short for .cue-this-when-you-feel-it's-appropriate-to

[03:41] <TimToady> really, .schedule-a-cue  :)

[03:42] <TimToady> but it works well with the modifiers: "cue this in 10 seconds"

[03:42] <TimToady> also, there's the cue/queue pun that jnthn++ likes

[03:46] *** johnny5_ left
[03:46] <BenGoldberg> Looking at S17-concurrency, it seems to me that in addition to $promise.then(&code) which fires code if the promies is either kept or broken, we might want $promise.then(&when_kept,&when_broken), which fires either of two subs when the promise is kept or broken.  It might even be a good idea to offer $promise.kept(&code) and $promise.broken(&code)

[03:47] *** johnny5_ joined
[03:47] *** camelia left
[03:48] *** johnny5_ left
[03:49] <raiph> TimToady: thanks

[03:49] *** johnny5_ joined
[03:50] *** camelia joined
[03:51] *** ChanServ sets mode: +v camelia

[03:53] *** mathw left
[03:53] *** mathw joined
[03:55] *** dansamo left
[03:58] <lue> .oO(    $promise.I-guess-SOME-PEOPLE-just-don't-understand-the-value-of-keeping-promises(&code)    )

[03:59] *** rurban joined
[03:59] <geekosaur> promise-cuous

[04:00] <geekosaur> (or maybe promise-cue-ous and you need to remind it?)

[04:02] *** pjcj joined
[04:05] *** _ilbot left
[04:06] *** _ilbot joined
[04:08] <TimToady> BenGoldberg: yes, that's one approach I'm considering

[04:09] <dalek> specs: f0f514e | larry++ | S17-concurrency.pod:

[04:09] <dalek> specs: Spec a statement-level construct for racing things

[04:09] <dalek> specs: review: https://github.com/perl6/specs/commit/f0f514e20f

[04:11] <benabik> Most promise/then APIs I'm aware of cascade failures.  If $a fails, then $a.then() also fails.

[04:12] <benabik> (As .then generally itself returns a failure.

[04:12] <benabik> Future.  Promise.  Whatever.

[04:12] <TimToady> I can see variants where each then has its own failure, and variants where you want a single failure handler for the whole cascade

[04:13] <TimToady> for logic operators we defined both 'andthen' and 'orelse', and leave it up to the user to parenthesize :)

[04:14] <TimToady> given those are thunky, maybe there's some way to unify them

[04:14] <benabik> If you have $b = $a.then(&pass, &fail), then what does $b represent?  Does it get the return value of &fail as a success if $a fails?

[04:15] <lue> r: sub infix:<∃>(&a, &b) { &a for &b }; say $_ ∃ ^10

[04:15] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[04:15] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Nominal type check failed for parameter '&a'; expected Callable but got Nil instead␤  in sub infix:<∃> at /tmp/ZHVMkkw0kA:1␤  in block  at /tmp/ZHVMkkw0kA:1␤  in any  at /tmp/ZHVMkkw0kA:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in an…»

[04:15] <lue> r: sub infix:<∃>(&a, &b) { &a for &b }; -> {say $_} ∃ ^10

[04:15] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[04:15] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Nominal type check failed for parameter '&b'; expected Callable but got Range instead␤  in sub infix:<∃> at /tmp/I9XNE3LZL3:1␤  in block  at /tmp/I9XNE3LZL3:1␤  in any  at /tmp/I9XNE3LZL3:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in …»

[04:19] <TimToady> benabik: dunno, getting into semi-predicate problems there...I suspect a lot of folks will just want to program the success path and let the failure path throw automatically in a 'use fatal' sort of way

[04:24] <dalek> specs: e17c32f | larry++ | S17-concurrency.pod:

[04:24] <dalek> specs: missed some Subscribables -> Supply

[04:24] <dalek> specs: review: https://github.com/perl6/specs/commit/e17c32ff19

[04:26] <timotimo> supply? as in supply and demand?

[04:26] *** BenGoldberg left
[04:26] * TimToady had probably better let those changes settle a bit before proposing better syntax for "on" and such

[04:26] <TimToady> supply as in "water supply", or some stronger substance

[04:26] <timotimo> guys, are you serious? i think it's time to name Grammar and Actions into Interpretation and Meaning or something

[04:27] <lestrrat> :w

[04:27] <lestrrat> sorry, typo.

[04:28] *** preflex_ joined
[04:28] *** ChanServ sets mode: +v preflex_

[04:29] <TimToady> timotimo: what, lengthen those names to make up for shortening names like Subscribable?  :)

[04:29] <timotimo> it's called an "ecosystem" and if you don't keep it in balance, you're killing the rainforest.

[04:29] <timotimo> rainforest.perl6.org. i kinda like that

[04:29] *** preflex left
[04:30] <TimToady> jungle.perl6.org would be shorter :)

[04:30] *** preflex_ is now known as preflex

[04:30] <timotimo> okay, and we call the local database "knees"

[04:30] <timotimo> you know, because it's "welcome to the jungle watch it bring you to your knees"?

[04:30] <timotimo> i think i'm trying too hard

[04:32] <TimToady> but we also are trying to keep the concepts far enough apart that names can develop from merely descripting into "proper names" where that's appropriate

[04:32] <TimToady> this is the main reason "roast" is called "roast" and not "spectests" :)

[04:32] <TimToady> well, that, and tab completion :)

[04:33] <timotimo> .o( it's roasting implementors in implementor hell? )

[04:33] <TimToady> that too :)

[04:33] <TimToady> and roasting the implementions till they're yummy

[04:35] <TimToady> English is a big language with lots of concepts, and there's really little reason to stick to overly descriptive CS-y names when we can latch onto a solid metaphor and make it stick

[04:35] <TimToady> to mix a few sticky metaphors...

[04:35] <timotimo> that sounds like a very -Ofun thing to say :)

[04:36] <TimToady> well, it's certainly a fun thing to do

[04:36] * TimToady notes with pleasure that our choice of the concept "roles" has caught on in the Perl 5 world as well as in Perl 6

[04:40] <TimToady> because that's what roles are in the real world: generic more-or-less immutable parts ("Hamlet") that are instanciated by mutable actors

[04:40] * perigrin hides MX::RoleParameterized from TimToady 

[04:42] *** jnap left
[04:42] <TimToady> s/Parameterized/Cast/  :)

[04:42] <TimToady> well, not really...

[04:42] *** johnny5_ left
[04:42] *** johnny5_ joined
[04:43] <TimToady> the part isn't cast till a class gets hold of it

[04:43] <TimToady> .oO(obviously an acting class)

[04:44] * TimToady had better wander off and find something else to screw up instead of S17 :)

[04:45] <perigrin> heh

[04:46] <perigrin> class Cumberbatch is Actor { ... }

[04:52] <lue> I can't help but wonder if a Key object would be useful alongside Lock objects.

[04:52] *** FROGGS left
[04:52] <lue> (likely not)

[05:04] *** lue left
[05:06] *** lue joined
[05:09] *** SamuraiJack joined
[05:13] *** raiph left
[05:22] *** toebu left
[05:24] *** [Sno] left
[05:24] *** raiph joined
[05:31] *** raiph left
[05:36] *** araujo joined
[05:46] *** cognominal left
[05:46] *** cognominal joined
[06:05] *** johnny5_ left
[06:06] *** johnny5_ joined
[06:13] *** rurban left
[06:20] *** darutoko joined
[06:23] *** fridim_ left
[06:34] *** Hellcat joined
[06:35] *** Hellcat is now known as Guest21227

[06:36] *** Guest21227 left
[06:36] *** Guest21227 joined
[06:37] *** Guest21227 left
[06:37] *** Guest21227 joined
[06:37] *** Guest21227 is now known as Shellcat

[06:42] *** [Sno] joined
[06:49] *** ssutch_ left
[07:01] *** wbill left
[07:08] *** lue left
[07:11] *** dmol joined
[07:13] *** xenoterracide left
[07:17] *** tobyink joined
[07:20] *** virtualsue joined
[07:23] *** ggoebel14 left
[07:24] *** Shozan is now known as SHODAN

[07:24] *** ggoebel14 joined
[07:24] *** xenoterracide joined
[07:26] *** stevan_ left
[07:28] *** [Sno] left
[07:35] *** [Sno] joined
[07:37] *** Shellcat left
[07:40] *** tobyink left
[07:45] <TimToady> http://rosettacode.org/wiki/Function_frequency#Perl_6

[07:47] *** darutoko- joined
[07:50] *** darutoko left
[07:51] * TimToady is slightly interested in why QAST lists each function call twice...

[07:56] *** zakharyas joined
[07:56] *** virtualsue left
[07:57] <moritz> TimToady: related to sink context (more)

[07:57] <moritz> basically each statement is emitted as   want_sink ?? sink(statement) !! statement

[07:58] <moritz> (so QAST::Want(statement, 'v', sink(statement)) or something along these lines)

[07:58] <moritz> and at the time the QAST is dumped, that decision isn't made yet

[07:59] <TimToady> thanks

[08:05] *** darutoko joined
[08:07] *** darutoko- left
[08:12] *** tobyink joined
[08:13] <dalek> nqp: 89cc08f | (Arne Skjærholt)++ | src/vm/jvm/runtime/org/perl6/nqp/ (4 files):

[08:13] <dalek> nqp: CArray REPR on JVM, with supporting int and num.

[08:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/89cc08facd

[08:13] <arnsholt> Bah, braino in the commit message. Oh well, nothing to do 'bout it now =)

[08:14] *** nnunley left
[08:15] *** nine left
[08:16] *** nine joined
[08:22] *** zakharyas left
[08:25] *** FROGGS joined
[08:38] *** virtualsue joined
[08:40] <mathw> best to spot those before you push :)

[08:40] *** stevan_ joined
[08:41] *** darutoko- joined
[08:42] *** zakharyas joined
[08:44] *** darutoko left
[08:48] *** Vendethi_ joined
[08:49] *** Vendethi_ left
[08:49] *** Vendethi_ joined
[08:51] *** Vendethi_ left
[08:52] *** Vendethi_ joined
[08:52] *** darutoko joined
[08:53] *** Vendethi_ left
[08:54] *** virtualsue left
[08:54] *** darutoko- left
[08:54] *** Vendethi_ joined
[08:54] *** Vendethi_ left
[08:55] *** Vendethi_ joined
[08:56] <hoelzro> o/ #perl6

[08:56] <hoelzro> !

[08:57] *** dansamo joined
[08:57] *** Vendethi_ left
[08:58] *** Vendethi_ joined
[08:59] *** Vendethi_ left
[08:59] *** Vendethi_ joined
[09:01] *** Vendethi_ left
[09:01] *** Vendethi_ joined
[09:02] *** darutoko- joined
[09:02] *** Vendethi_ left
[09:03] *** Vendethi_ joined
[09:03] <hoelzro> so I was thinking about Perl 6 and getting people to contribute last night...

[09:03] <hoelzro> ...and I thought it would be cool if we had something like this: http://www.whatcanidoformozilla.org/

[09:04] *** nnunley joined
[09:05] *** Vendethi_ left
[09:05] *** darutoko left
[09:05] *** Vendethi_ joined
[09:07] *** Vendethi_ left
[09:07] *** Vendethi_ joined
[09:09] *** Vendethi_ left
[09:09] *** nnunley left
[09:09] *** Vendethi_ joined
[09:10] <moritz> hoelzro: feel free to create a perl6.org/contribute/ page or so

[09:10] <hoelzro> I just might do that =)

[09:11] *** Vendethi_ left
[09:11] <hoelzro> I just need to come up with a list of tasks/categories/whatever

[09:11] *** Vendethi_ joined
[09:13] *** Vendethi_ left
[09:13] *** Vendethi_ joined
[09:14] *** pjcj left
[09:15] *** Vendethi_ left
[09:15] *** Vendethi_ joined
[09:17] *** Vendethi_ left
[09:17] *** Vendethi_ joined
[09:19] *** Vendethi_ left
[09:19] *** Vendethi_ joined
[09:21] *** Vendethi_ left
[09:23] *** Vendeth__ joined
[09:23] *** Vendeth__ left
[09:24] *** Vendethi_ joined
[09:25] *** Vendethi_ left
[09:26] *** Vendethi_ joined
[09:27] *** Vendethi_ left
[09:28] *** Vendethi_ joined
[09:30] *** Vendethi_ left
[09:30] *** Vendethi_ joined
[09:32] *** Vendethi_ left
[09:34] *** Vendethi_ joined
[09:35] *** kresike joined
[09:35] <kresike> hello all you happy perl6 people

[09:35] *** Vendethi_ left
[09:36] *** daxim joined
[09:36] *** Vendethi_ joined
[09:36] <hoelzro> ahoy kresike !

[09:37] *** Vendethi_ left
[09:38] *** Vendethi_ joined
[09:39] *** Vendethi_ left
[09:40] *** SevenWolf joined
[09:41] *** Vendethi_ joined
[09:43] *** Vendethi_ left
[09:44] *** Vendethi_ joined
[09:45] *** SevenWolf left
[09:46] *** Vendethi_ left
[09:46] *** Vendethi_ joined
[09:48] *** Vendethi_ left
[09:48] *** Vendethi_ joined
[09:50] *** Vendethi_ left
[09:50] *** Vendethi_ joined
[09:52] *** Vendethi_ left
[09:52] *** Vendethi_ joined
[09:54] *** Vendethi_ left
[10:01] *** dakkar joined
[10:03] *** pjcj joined
[10:11] *** Vendethi_ joined
[10:20] *** fhelmberger joined
[10:23] *** jaffa4 joined
[10:23] <jaffa4> hi all

[10:23] <jaffa4> Hoq do I merge a hash and key value pair?

[10:25] <moritz> jaffa4: what have you tried?

[10:26] <jaffa4> @tokens[*-1][0] ~ :wcp

[10:26] <jaffa4> r: say :a ~: b

[10:27] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[10:27] <camelia> ..rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZyxA7E5bD0␤Bogus statement␤at /tmp/ZyxA7E5bD0:1␤------> [32msay :a ~[33m⏏[31m: b[0m␤    expecting any of:␤        pair value␤        postfix␤        infix stopper␤        inf…»

[10:27] <moritz> ~ is for string concatenation

[10:27] <jaffa4> r: say :a,: b

[10:27] <moritz> how do you add keys and values to a hash?

[10:27] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[10:27] <camelia> ..rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/AQf12_sZ1q␤Two terms in a row␤at /tmp/AQf12_sZ1q:1␤------> [32msay :a,[33m⏏[31m: b[0m␤    expecting any of:␤        pair value␤        postfix␤        infix stopper␤        i…»

[10:27] <jaffa4> it is not a hash, reference to hash

[10:28] <jaffa4> r:  (:o).perl

[10:28] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[10:28] <camelia> ..rakudo-parrot 215ba6: ( no output )

[10:33] *** toebu joined
[10:41] <jaffa4> moritz: tokens[*-1][0]}.push(:wcp)

[10:52] *** nnunley joined
[10:57] *** nnunley left
[11:08] *** Vendethi_ left
[11:10] *** Vendethi_ joined
[11:12] *** kaare__ joined
[11:12] *** Vendethi_ left
[11:14] *** davec` left
[11:15] *** davec` joined
[11:16] *** Vendethi_ joined
[11:18] *** Vendethi_ left
[11:19] *** Vendethi_ joined
[11:21] *** Vendethi_ left
[11:21] *** Tiggez joined
[11:22] *** Vendethi_ joined
[11:24] *** Vendethi_ left
[11:25] <Tiggez> Hi, I just wanted to give Perl6 a try... correct me if i'm wrong,  but there are no bindings to any GUI nor to any major database?

[11:26] *** dansamo left
[11:26] *** yves joined
[11:26] <hoelzro> there are bindings to MySQL, SQLite, and PostgreSQL

[11:27] <hoelzro> I played with the idea of creating bindings to GTK a while ago, but I haven't gotten a round to it

[11:27] *** dansamo joined
[11:27] <Tiggez> cool thanks, i will give it a try

[11:29] *** dansamo left
[11:29] *** dansamo joined
[11:32] *** dansamo left
[11:32] *** dansamo joined
[11:34] *** Vendethi_ joined
[11:35] *** dansamo left
[11:35] *** Vendethi_ left
[11:36] *** dansamo joined
[11:45] *** dansamo left
[11:45] *** dansamo joined
[11:49] *** Vendethi_ joined
[11:50] *** Vendethi_ left
[11:55] *** Vendethi_ joined
[11:56] *** pernatiy left
[11:57] *** Vendethi_ left
[12:03] *** dansamo left
[12:04] *** dansamo joined
[12:05] *** Vendethi_ joined
[12:07] *** Vendethi_ left
[12:10] *** Vendethi_ joined
[12:11] *** Vendethi_ left
[12:12] *** Vendethi_ joined
[12:14] *** Vendethi_ left
[12:17] *** colomon left
[12:18] *** colomon joined
[12:21] *** Vendethi_ joined
[12:23] *** Vendethi_ left
[12:23] *** Tiggez left
[12:24] *** mtk left
[12:25] *** tobyink left
[12:30] *** mtk joined
[12:33] *** Vendethi_ joined
[12:35] *** Vendethi_ left
[12:35] *** Vendethi_ joined
[12:36] *** tobyink joined
[12:41] *** nnunley joined
[12:41] *** benabik left
[12:43] *** tobyink left
[12:45] *** nnunley left
[12:51] * [Coke] waves, briefly.

[12:53] <colomon> o/

[12:57] *** tobyink joined
[12:59] *** lizmat joined
[13:00] *** toebu left
[13:03] *** toebu joined
[13:08] *** pernatiy joined
[13:10] *** toebu left
[13:15] <[Coke]> ༽o༼

[13:16] <colomon> very long arms?

[13:16] *** itz_ joined
[13:16] <colomon> martini glass with olive?

[13:16] <[Coke]> vampire?

[13:17] <daxim> anus shades

[13:17] *** Vendethi_ left
[13:18] *** Vendethi_ joined
[13:18] *** itz left
[13:19] *** Vendethi_ left
[13:19] <dalek> specs: 9cfcf5a | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[13:19] <dalek> specs: Some more s/Subscribable/Supply/

[13:19] <dalek> specs: review: https://github.com/perl6/specs/commit/9cfcf5af3c

[13:19] <[Coke]> I do wonder why ⑻ exists. seems like we could have avoided that one.

[13:19] *** ssutch left
[13:20] <[Coke]> rp: ('⚀'..'⚅').roll(3);

[13:20] <camelia> rakudo-parrot 215ba6: ( no output )

[13:20] <[Coke]> rp: ('⚀'..'⚅').roll(3).say;

[13:20] <camelia> rakudo-parrot 215ba6: OUTPUT«⚀ ⚀ ⚃␤»

[13:22] *** Vendethi_ joined
[13:22] <[Coke]> ~~

[13:24] *** Vendethi_ left
[13:24] <pdurbin> perl 6 mentioned: http://programmingisterrible.com/post/65893117803/progress-is-measured-in-lines-of-code-broken

[13:30] <nwc10> Likely his expressed opinion are reasonably representitive of an end-user developer viewpoint, but

[13:31] <daxim> cpan stagnation? that's news to me

[13:31] <nwc10> I see no route that gets from a "call" for a "Perl 5 rewrite" to a finished project

[13:32] <nwc10> and I'd love to see his objective numbers on Python 3 takeup

[13:33] <daxim> http://python3wos.appspot.com/

[13:33] <daxim> users or libraries?

[13:34] <nwc10> daxim: users. I'm well aware that that's now "Wall of Superpowers"

[13:34] <nwc10> once Andrea has upgraded her machine, I'll be able to get a sane idea about Python 3 packags on ubutu again

[13:34] <nwc10> but it was "very few"

[13:35] <nwc10> even Guido thinks that Python 2 is better for new users: https://mail.python.org/pipermail/python-dev/2013-September/129031.html

[13:40] <daxim> codacademy teaches python 2

[13:41] <nwc10> but not Python 3: http://help.codecademy.com/customer/portal/articles/887853-why-do-you-teach-python-2-7-3-

[13:42] *** ajr joined
[13:42] *** ajr is now known as Guest40872

[13:43] *** Guest40872 is now known as ajr_

[13:43] *** konundra joined
[13:46] *** rindolf joined
[13:47] *** nnunley joined
[13:50] *** toebu joined
[13:56] <lizmat> commute to Amsterdam&

[13:56] *** lizmat left
[13:58] *** _sri left
[14:00] *** rafl left
[14:04] *** rafl joined
[14:04] *** _sri joined
[14:12] *** mr- joined
[14:12] *** mr- left
[14:15] *** PacoAir joined
[14:18] *** rurban joined
[14:25] <moritz> ok, there's a mail on p6l about the license of roast and specs

[14:26] <moritz> I'm pretty sure roast should get artistic license 2.0, just like rakudo and nqp (and pugs, iirc, from which repository it comes from)

[14:26] <moritz> any objections to me adding an AL2 LICENSE file to roast?

[14:26] <FROGGS> none from me

[14:26] <colomon> +1

[14:26] <geekosaur> sounds sensible to me

[14:27] * colomon had always assumed that's what it was under.

[14:27] * moritz too

[14:28] <moritz> regarding the specs: I'm not sure if AL2 is a good fit for documents

[14:28] <moritz> so I won't take action in that area

[14:28] <dalek> roast: b213c5a | moritz++ | LICENSE:

[14:28] <dalek> roast: Add Artistic License 2

[14:28] <dalek> roast: 

[14:28] <dalek> roast: The test suite comes originally from the Pugs repository, which used

[14:28] <dalek> roast: Artistic License 2 by default, and community concensus seems to agree.

[14:28] <dalek> roast: review: https://github.com/perl6/roast/commit/b213c5a927

[14:28] *** jnap joined
[14:29] <colomon> +1 on thinking about the documents.

[14:29] <colomon> surely they should be free to copy.

[14:29] <moritz> yes

[14:29] <colomon> but freedom to make changes to them seems kind of weird.

[14:29] <moritz> the question if whether they should have a "rename if you fork" clause

[14:29] <colomon> "I'm going to fork the perl 6 spec"

[14:30] <anocelot> .oO( Well, it's been knifed at least once... )

[14:32] <geekosaur> ...how do you fork a liquid?...

[14:32] <colomon> \o/  # finally got my $work program to link again

[14:35] <anocelot> \o/  (Similar happiness/situation on my end, fwiw.)

[14:37] <moritz> geekosaur: with a very broad fork, of course :-)

[14:37] <geekosaur> as for forking the specs, I think the only constraint is that the result is not calling itself STD?

[14:38] <moritz> best we wait for Larry's opinion on that

[14:39] *** konundra left
[14:43] *** bluescreen10 joined
[14:44] <dalek> nqp: f7e7e7f | (Tobias Leich)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[14:44] <dalek> nqp: s/index_s/indexfrom/

[14:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f7e7e7f751

[14:46] <FROGGS> prove -v -e nqp-p t/docs/opcodes.t | grep "not ok" | wc -l # 179 issues left

[14:52] *** Tene left
[14:53] *** djanatyn left
[14:53] *** xalbo left
[14:54] *** tobyink left
[14:58] <lee_> that last commit short hash is a palindrome

[14:58] <lee_> just had to point that out!

[14:59] <moritz> lee_++

[15:02] <TimToady> lee_++_eel

[15:10] *** btyler joined
[15:17] <TimToady> forking a liquid requires a supply and a series of taps

[15:17] *** rurban left
[15:18] *** pdurbin left
[15:20] <perigrin> TimToady: if the liquid is already in a stream you just need some tee

[15:21] <kresike> bye all

[15:21] *** kresike left
[15:22] <PerlJam> you can fork a liquid all you want, but it's much more efficient to use a spoon

[15:23] <PerlJam> (or freeze the liquid if you must use a fork)

[15:23] <geekosaur> perl 6 spoonerisms?

[15:30] *** colomon left
[15:37] *** ggoebel15 joined
[15:38] *** fridim_ joined
[15:38] *** rurban joined
[15:39] *** ggoebel14 left
[15:47] *** ajr_ left
[15:48] <dalek> nqp: fd17a3a | (Tobias Leich)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[15:48] <dalek> nqp: mapped [open|nextfile|close]dir

[15:48] <dalek> nqp: 

[15:48] <dalek> nqp: nextfiledir on MoarVM is slightly different from JVM, it does not prepend the foldername

[15:48] <dalek> nqp: we have opened. Though we can cope with it in rakudo.

[15:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fd17a3a782

[15:58] <dalek> nqp: 848c285 | (Tobias Leich)++ | docs/ops.markdown:

[15:58] <dalek> nqp: document nqp::backendconfig

[15:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/848c285561

[16:01] <dalek> nqp: b2836cb | (Tobias Leich)++ | docs/ops.markdown:

[16:01] <dalek> nqp: strip backslashes

[16:01] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b2836cb560

[16:02] *** benabik joined
[16:04] *** dwarring left
[16:08] *** jeffreykegler joined
[16:09] *** toebu left
[16:20] *** btyler left
[16:21] <dalek> nqp: 7cd42ab | (Tobias Leich)++ | t/docs/opcodes.t:

[16:21] <dalek> nqp: consider src/vm/parrot/NQP/Ops.nqp on parrot too

[16:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7cd42ab2fd

[16:23] *** [Sno] left
[16:24] *** xalbo joined
[16:26] <[Coke]> FROGGS++ # opcode doc fixes

[16:27] <FROGGS> :o)

[16:28] *** toebu joined
[16:28] <dalek> nqp: b840584 | (Tobias Leich)++ | t/docs/opcodes.t:

[16:28] <dalek> nqp: take jvm's and moar's NQP::Ops into accout

[16:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b840584d16

[16:32] *** btyler joined
[16:32] *** dalek left
[16:33] *** sergot left
[16:33] *** Util left
[16:34] *** [Coke] left
[16:34] *** masak left
[16:34] *** tadzik left
[16:34] *** pmichaud left
[16:34] *** Juerd left
[16:34] *** Juerd joined
[16:34] *** PerlJam left
[16:34] *** masak joined
[16:35] *** sergot joined
[16:35] *** Util joined
[16:35] *** PerlJam joined
[16:35] *** pmichaud joined
[16:35] *** dalek joined
[16:35] *** ChanServ sets mode: +v dalek

[16:36] *** tadzik joined
[16:36] *** synopsebot joined
[16:36] *** hugme joined
[16:36] *** ChanServ sets mode: +v hugme

[16:36] *** [Coke] joined
[16:37] <[Coke]> weird, feather just vanished for a bit.

[16:37] <[Coke]> (looks like it wasn't in DNS briefly)

[16:39] <[Coke]> "we're all fine, here, now. ... How are you?"

[16:39] * [Coke] -> again

[16:44] *** renormalist left
[16:45] *** fhelmberger_ joined
[16:49] *** fhelmberger left
[16:50] *** fhelmberger_ left
[16:50] *** renormalist joined
[16:52] *** sqirrel joined
[16:57] *** zakharyas left
[16:57] *** ajr joined
[16:58] *** ajr is now known as Guest53641

[16:58] *** Guest53641 is now known as ajr_

[17:05] <diakopter> daxim: cpan stagnation? the rate of cpan's growth has been decreasing for a long time, whereas the rate of growth of all the other languages' central library archives/repos has been increasing

[17:08] *** dansamo left
[17:09] <japhb__> diakopter: That could be explained by CPAN supplying the majority of user's day-to-day needs.  Running out of itches to scratch that aren't either very niche or very hard.

[17:10] <anocelot> Not to mention helpful core updates.

[17:10] <tadzik> the reason why I started contributing to Perl 6 was actually the fact that I couldn't think of any way to contribute to Perl 5: everything I could think of was there

[17:11] <jeffreykegler> For me, the value of CPAN is really in CPANtesters ....

[17:11] <diakopter> that might be accurate, except the sizes of nearly all the other languages' central library archives/repos are dramatically bigger than cpan's

[17:11] <jeffreykegler> That is, the metric to use is the number of *tested* distributions.

[17:11] <diakopter> so it's kindof hard to imagine that cpan is more comprehensive, when it's dwarfed by the others

[17:11] <FROGGS> diakopter: maybe bigger because there is more crap in there :o)

[17:11] <anocelot> Size of code base or numbers of entries?

[17:11] <tadzik> ever tried to use python profilers? :D

[17:12] <diakopter> anocelot: both

[17:12] <diakopter> anocelot: but mostly number of distributions

[17:12] <jeffreykegler> ... and I believe no other repository even attempts the kind of testing done at anything like that volume level

[17:14] <jeffreykegler> Without testing, a repository is just a place you cn upload to and that's a lot easier to do, but a lot less useful.

[17:16] <japhb__> An interesting (but very time consuming and difficult to do in an unbiased manner) study would be to compare the problem spaces covered by the various repositories.

[17:16] <diakopter> japhb__: like 11 distributions on cpan (updated in the past 3 years) mention Mongo in their names, whereas Java's Maven central repo has 309 (as of a few months ago)

[17:18] *** benabik left
[17:18] *** Celelibi left
[17:19] <diakopter> FROGGS: if only that was the case.. somehow I'd think the portion of crap is not all that much different between all of them, except perhaps Hackaga, which is very well groomed (and perhaps Nuget, and perhaps to a lesser extent, npm)

[17:19] *** benabik joined
[17:20] <diakopter> er, *Hackage

[17:20] <diakopter> (but Nuget and npm mostly because they're so new)

[17:21] <FROGGS> diakopter: well, I guess cpan is really smaller than the others... but it still offers all what I need, really

[17:21] <FROGGS> dinner &

[17:22] *** Celelibi joined
[17:23] * diakopter has belatedly realized that realism is a better motivator than pusillanimous whimsicality

[17:23] <diakopter> [.. and alarmism]

[17:26] <PerlJam> greetings Perl people

[17:29] <moritz> diakopter: there is also a large part defensism going on, people battling the idea "perl is dead" so hard that they don't realize it could be more alive

[17:30] <diakopter> I think it's skating dangerously close to the technicality tendency of that usage

[17:30] <diakopter> *closely?

[17:31] <moritz> close

[17:32] *** ssutch joined
[17:32] <moritz> there's already a /ly <.wb>/ before it :-)

[17:33] <diakopter> yeah but adverbs can modify adverbs

[17:33] <jeffreykegler> Perl 5 remains unexcelled as an infrastructure within which to develop a volunteer open-source project, as far as I can tell ...

[17:34] <jeffreykegler> and I'd be grateful if someone convinced me otherwise, because then I would switch

[17:36] <PerlJam> BTW folks ... 25 days until advent

[17:38] <tadzik> good catch; time to start planning

[17:39] <diakopter> okay, this can't be right

[17:39] <dalek> mu: bdb90e9 | duff++ | misc/perl6advent-2013/ (2 files):

[17:39] <dalek> mu: Start of advent 2013 planning

[17:39] <dalek> mu: review: https://github.com/perl6/mu/commit/bdb90e901d

[17:40] <diakopter> (work thing emitting 549,000 files when it should be emitting only 1

[17:40] <diakopter> )

[17:40] <moritz> PerlJam++

[17:40] <diakopter> well, the Advent of Advent Season, anyway

[17:41] <PerlJam> diakopter: Got any topics you'd like to cover this advent season?  :)

[17:41] <moritz> diakopter should blog about MoarVM

[17:41] * diakopter assesses that to be a very good question

[17:41] <PerlJam> moritz: you can read my mind!  ;)

[17:42] *** sqirrel left
[17:42] <dalek> mu: 37e80c4 | tadzik++ | misc/perl6advent-2013/topic-brainstorming:

[17:42] <dalek> mu: Remove topic done last year

[17:42] <dalek> mu: review: https://github.com/perl6/mu/commit/37e80c44ba

[17:42] <arnsholt> Are we planning a Star release for November?

[17:42] <moritz> arnsholt: which collective "we" are you talking about? :-)

[17:42] <PerlJam> moritz: have you been the lone Star release manager?  I can only remember you doing releases.

[17:43] <diakopter> PerlJam: I'm still of the perspective that it should remain hidden under a bushel until it reaches criticality, or singularity... whichever comes first

[17:43] <arnsholt> s/we/you/ # If you prefer ;)

[17:43] <arnsholt> Or in the passive perhaps: Is a November Star release planned? =)

[17:43] *** [Sno] joined
[17:43] <moritz> PerlJam: lue++ has done last month's star release

[17:43] <moritz> PerlJam: and I'd like it if others took up that task too

[17:43] <arnsholt> Anyways, the reason I'm asking is NativeCall on JVM

[17:44] <PerlJam> diakopter: agreed.

[17:44] *** fhelmberger joined
[17:44] <moritz> though maybe this month's star release could be a tad tricky, since the build system changed

[17:44] <moritz> so I might do it again this month

[17:44] <PerlJam> moritz: Where do people sign up to do R* releases?

[17:44] * diakopter thinks someone could automate/script the release much more than it is.., but that someone is not I, because I don't have the requisite scripting skillz

[17:45] <arnsholt> So that I can try to manage my tuit supply a bit actively, to maybe get NativeCall done for Star-time

[17:45] <moritz> PerlJam: I'd say in star's tools/star/release-guide.pod

[17:45] <PerlJam> ah.   (in the other repos, that's in docs)

[17:45] <moritz> arnsholt: so yes, if all goes well, there'll be star release this month too

[17:45] <moritz> PerlJam: I know; It's a bit weird, because docs/ in star is actually included in the tar ball

[17:45] <tadzik> idea: we need a set of modules, possibly with a maintainers crew, to maintain a rock-solid implementations of things that we need, and of which the current implementations are very fragile

[17:46] <diakopter> it would be nice if an account on some server somewhere had all the required credentials and web service calls or whatever scripted and ready to go so someone could type make star-release and it does its thing

[17:46] <tadzik> (LWP, HTTP servers etc)

[17:46] *** SmokeMachine joined
[17:46] <PerlJam> oh, right. I forgot R* repo was weird that way

[17:46] <diakopter> b/c it seems the process is already formalized enough with the release guide

[17:47] <PerlJam> tadzik: and a CI-thingy to tell us when they break  :)

[17:47] <tadzik> PerlJam: yeah, poke us on the channeu

[17:47] <tadzik> one of the things about those modules is that they rely on sockets, which are 1) a bit of a moving target 2) tricky to test (esp. if you're a server)

[17:48] <arnsholt> moritz: Cool. Roughly when do you expect it to be? 25th-ish?

[17:48] <diakopter> what I'm imagining is the release script could issue its blocking errors to #perl6 when it reaches them...

[17:48] <moritz> arnsholt: sounds plausible-ish :-)

[17:49] <arnsholt> Excellent-ish

[17:49] <arnsholt> I think that might be reasonable(-ish) for NativeCall on JVM

[17:49] <moritz> possibly sooner, since Rakudo release is already on the 22nd, but we can delay if necessary

[17:49] <PerlJam> arnsholt: nice!

[17:49] <arnsholt> 'Cept my target really is the 22nd, now that I think about it, since the relevant code actually lives in NQP

[17:51] <moritz> 'cept for the code in NativeCall.pm

[17:52] <diakopter> I kinda think it should be in nqp

[17:53] <arnsholt> The code in NativeCall.pm is just porcelain, to use git terminology

[17:53] <arnsholt> The real work is all implemented in NQP

[17:54] <japhb__> jnthn: @concurrency_wishes.push('API "works" in rakudo-parrot, but just uses the single-threaded scheduler instead', 'Provide a spec-approved way to test if the implementation will run single-threaded');

[17:56] <retupmoca> somewhat related question: iirc, common lisp had a *FEATURES* global variable that was an array of enabled features (threading, sockets, etc.)

[17:57] <retupmoca> does perl6 have a $*FEATURES variable or somesuch?

[17:57] *** ktrout joined
[17:57] <japhb__> Don't think so, unless you look at $*VM.

[17:58] <FROGGS> retupmoca: we don't keep track of enabled/implemented/available features (yet)

[17:58] *** ktrout left
[17:59] <PerlJam> Those things strike me as being roles on the perl6 instance.  WE'd just need to spec the appropriate names and behaviors

[17:59] <FROGGS> because the main goal is that all backends on all platforms support everything

[17:59] <japhb__> Right now my test for concurrency actually checks if ::('Thread') ~~ Failure;

[17:59] <PerlJam> "just" :)

[18:00] <arnsholt> japhb__: Oooh, that's a really neat idiom!

[18:00] *** SamuraiJack left
[18:01] <retupmoca> ah, here we go: *features* contains ( [...] :GENCGC :IEEE-FLOATING-POINT :INLINE-CONSTANTS :LARGEFILE :LINKAGE-TABLE :LINUX :LITTLE-ENDIAN

[18:01] <retupmoca> and such

[18:01] <retupmoca> (in common lisp)

[18:02] *** pernatiy left
[18:02] *** darutoko- left
[18:02] <retupmoca> I don't need it (at least right now), but it seems like a nice feature

[18:02] <arnsholt> Yeah, it's probably a good feature to keep in mind

[18:04] <arnsholt> Common Lisp is a neat language, in general. Just a shame the syntax is such a pain ^_^

[18:05] <retupmoca> I like a lot of what it has, I just generally don't enjoy coding in it.

[18:06] *** dakkar left
[18:08] <arnsholt> I haven't used it much, but I end up a bit ambivalent about it

[18:08] <arnsholt> On the one hand there's much cool stuff (loop is ridiculously powerful, for example), but sometimes it's really annoying as well

[18:08] <arnsholt> The impedance mismatch of Lisps assuming that everyone works in Emacs is a contributing factor as well, I must admit

[18:26] *** fhelmberger left
[18:26] <hoelzro> $obj.method: $foo, $bar, $baz is bsaically $obj.method($foo, $bar, $baz), right?

[18:27] *** fhelmberger joined
[18:30] <jnthn> right

[18:30] <jnthn> arnsholt: A NativeCall on JVM for this month would rock. Especially if it handles what DBIish needs :)

[18:31] <arnsholt> Yeah, I'd love to get that done

[18:31] *** fhelmberger left
[18:31] <jnthn> Grrr...$dayjob stole my Perl 6 day next week as well as this week :/

[18:31] <arnsholt> I've gotten the basic CArray stuff done now, and I hope the rest of CArray will follow soon-ish

[18:32] <arnsholt> Then it's back to pondering for a while, to figure out CStruct

[18:32] *** xinming_ joined
[18:33] *** tobyink joined
[18:34] *** sqirrel joined
[18:35] *** xinming left
[18:36] *** stevan_ left
[18:41] *** rurban left
[18:45] *** jeffreykegler left
[18:45] *** tobyink left
[18:45] <japhb__> jnthn: Awww, that bites.

[18:45] *** xinming_ left
[18:47] *** xinming joined
[18:49] <tadzik> .tell Mouq I've only just noticed your rakudobrew pull requests, dunno why I didn't get memo on them before. Thanks, much appreciated!

[18:49] <tadzik> ...shouldn't that work?

[18:50] <jnthn> Gah, next week is 4 days of teaching spread over 3 cities and 2 countries

[18:50] <tadzik> ,tell Mouq I've only just noticed your rakudobrew pull requests, dunno why I didn't get memo on them before. Thanks, much appreciated!

[18:50] <tadzik> graghdrstarsdg

[18:50] * jnthn saturates his schedule with Perl 6 time in the week after it...

[18:50] <jnthn> tadzik: preflex will send messages

[18:51] <jnthn> tadzik: yoleaux lived up to its name...

[18:51] <tadzik> hah

[18:51] <tadzik> preflex: help

[18:51] <preflex>  try 'help help' or see 'list' for available commands

[18:51] <tadzik> preflex: list

[18:51] <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:

[18:51] <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]

[18:52] <tadzik> preflex: tell Mouq I've only just noticed your rakudobrew pull requests, dunno why I didn't get memo on them before. Thanks, much appreciated!

[18:52] <preflex>  Consider it noted.

[18:52] <tadzik> yay

[18:54] <xalbo> The documentation of the anyof combinator on promises seems wrong. Specifically, the part that says "If the first promise to produce a result is instead broken, then the resulting Promise is also broken. The excuse is passed along. "

[18:55] <TimToady> in what way do you think it is wrong?

[18:56] <TimToady> it's not testing for success, it's testing for a result

[18:57] <moritz> that doesn't sound like 'anyof', rather 'firstof'

[18:58] <TimToady> yes, it's winner-take-all semantics

[18:58] <TimToady> (which is why the other construct is currently named "winner")

[18:58] *** sqirrel left
[18:59] *** rurban joined
[19:00] <xalbo> Then the text "The anyof combinator creates a Promise that is kept whenever any of the specified Promises are kept. " threw me off. I read that as saying that *if* any of them is kept, the result is kept.

[19:00] * TimToady doesn't think that was the intent, but admits it's unclear

[19:00] *** daxim left
[19:01] <TimToady> junctional notions in the time domain come out a little funny, especially when overlaid with succeed/fail semantics

[19:02] *** ingy^ joined
[19:03] *** ingy^ left
[19:03] <TimToady> the as-yet unimplemented race primitive is supposed to let everyone finish in whatever order they come in, like a marathon.  anyof and winner are more like match-play golf, where as soon as the winner is determined, the other person goes home and doesn't finish

[19:04] <TimToady> anyway, all these names are still negotiable

[19:04] <xalbo> Right, but I was assuming that anyof still waited for at least one person to cross the finish line. As I read it now, if anyone is disqualified before the first person wins, the whole race is called off.

[19:05] *** rindolf left
[19:05] <TimToady> perhaps we need to spec a way to distinguish those cases, other than hand-coding a loop

[19:06] <TimToady> one can see the argument that a broken promise is very near to a blow-up-the-rocket exception, so cancelling the race isn't so strange

[19:06] *** Hellcat joined
[19:07] *** Hellcat is now known as Guest53708

[19:07] <TimToady> one could also make the other argument that a promise that is broken for a good reason should be relatively easy to retry

[19:07] *** ingy^ joined
[19:07] <TimToady> STM kinda works like that

[19:08] *** lue joined
[19:08] <lue> Hello world o/

[19:08] <ingy^> TimToady: shortest token match?

[19:08] <TimToady> software transactional memory

[19:09] <ingy^> ic

[19:09] *** Guest53708 left
[19:09] *** ingy^ left
[19:09] *** Guest53708 joined
[19:09] *** Guest53708 is now known as Shellcat

[19:09] *** lizmat joined
[19:10] <dalek> nqp: 901a922 | (Tobias Leich)++ | / (2 files):

[19:10] <dalek> nqp: mapped op sayfh

[19:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/901a922de2

[19:11] *** stevan_ joined
[19:12] *** stevan__ joined
[19:13] <moritz> TimToady: sounds like we could have a concurrent grep for finding kept promises, and then the current anyof comibnator would do

[19:13] <jnthn> japhb__: I managed to stack 3 of the up in the week after next and begged that no more than two be stolen or I'll be very very sad. :)

[19:15] <jnthn> anyof has the same semantics as Task.Any from .Net, that is, if *any* of the promises are kept, it will be. Thus it is kept as soon as one of them is. It doesn't actually care much what happens after that.

[19:16] <jnthn> TimToady: I didn't spec it anywhere yet or try it, but at least for subscribables...uh...supplies (?) I'd imagined a .catch(...)

[19:16] *** stevan_ left
[19:17] <tadzik> aargh. I was trying to fix a pandabug that relied on JSON failing to build, and now when I came up with a possible fix JSON builds correctly again

[19:18] <jnthn> I agree that with anyof/allof you might not care about whether a promise was kept/broken, just that one or all of them came to a result.

[19:18] *** sqirrel joined
[19:18] <jnthn> otoh, often the breakage is a problem

[19:18] <xalbo> jnthn: Then "If the first promise to produce a result is instead broken, then the resulting Promise is also broken. The excuse is passed along. " doesn't seem true. If the first promise to return a result is broken, doesn't it keep waiting to see if another is kept?

[19:19] <jnthn> xalbo: That is now how it's implemented now.

[19:19] <jnthn> oh dammit

[19:19] <jnthn> xalbo: That is not how it's implemented now.

[19:19] <Util> #ps in 11 minutes. (Yes, the time changed, but UTC stayed the same)

[19:19] <jnthn> xalbo: It just says "oh, one has a result", and it then if htat result was breakage it's conveyed.

[19:20] <xalbo> Then it sounds pretty much exactly like winner.

[19:20] <jnthn> You kinda want it that way I think

[19:20] <xalbo> (or maybe it should be firstof, not anyof)

[19:20] <jnthn> Consider the timeout use-case.

[19:20] <tadzik> uhh. Is it possible that precompilation randomly returns non-zero exit status from time to time these days?

[19:21] <jnthn> If you get a broken promise back from the thing you were trying to do, you do *not* want your anyof to sit around waiting for the timeout.

[19:21] <jnthn> I have no idea what winner is because I didn't read the commits any deeper than the commit message syet.

[19:21] <xalbo> Fair enough.

[19:22] <jnthn> (Too much $dayjob...)

[19:22] <tadzik> FROGGS, FROGGS 

[19:22] <FROGGS> tadzik, tadzik 

[19:22] <FROGGS> what's up?

[19:22] <tadzik> I don't know yet, but it might be Proc::Status

[19:22] <FROGGS> hmm?

[19:22] <FROGGS> problems?

[19:22] <tadzik> with panda build, yes

[19:22] <tadzik> https://gist.github.com/tadzik/7324616

[19:23] <tadzik> it says exit 255, but nothing seems to have failed, at least not visible on stdout/err

[19:23] <FROGGS> hmmm

[19:23] <tadzik> also, when you die from perl6, the return code is 1, not 255

[19:23] <dalek> specs: bc9c55b | util++ | S99-glossary.pod:

[19:23] <dalek> specs: [S99] Add STM and IC

[19:23] <dalek> specs: review: https://github.com/perl6/specs/commit/bc9c55becb

[19:23] <FROGGS> that would mean that the try block failed, with a shell() or run()

[19:24] <tadzik> hrmrm

[19:24] <FROGGS> well, the 255 was there before, but only for one of the two (shell XOR run)

[19:24] <tadzik> hm

[19:24] <tadzik> oh, oh

[19:25] <tadzik> so we have run() now? 

[19:25] <tadzik> maybe panda should use that, instaed of shell

[19:25] <FROGGS> we have

[19:25] <FROGGS> why?

[19:25] <xalbo> I suggest that anyof be changed to "firstof", and the text "The anyof combinator creates a Promise that is kept whenever any of the specified Promises are kept. " be changed to "The firstof combinator creates a Promise that has as its result the result of whatever of the specified Promises returns first" (or something cleaned up from that)

[19:25] <FROGGS> tadzik: what is the command you invoke?

[19:25] <tadzik> to avoid shell :P

[19:25] <tadzik> also, I'm trying to shotgun-fix the issue :P

[19:26] <tadzik> shell "$*EXECUTABLE_NAME --target={compsuffix} --output=$dest $file

[19:26] <tadzik> ...I know ;)

[19:26] <tadzik> but no shell features in there

[19:26] <FROGGS> right

[19:26] <jnthn> xalbo: Well, that's changing the semantics a bit

[19:26] <FROGGS> then use run() so you dont have to stringify/auto-quote yourself

[19:27] <tadzik> aye

[19:27] <jnthn> But yeah, firstof may be clearer

[19:27] <xalbo> Then I'm completely confused.

[19:27] <jnthn> xalbo: At the moment it simply .keep(True)

[19:27] <jnthn> xalbo: And doesn't convey *what* was to thank for the success

[19:27] <xalbo> Ahh, ok.

[19:28] <jnthn> At present, anyof and allof are implemented in terms of an !n_of

[19:28] <jnthn> Doesn't have to stay that way.

[19:33] <xalbo> The firstof combinator waits until at least one of its Promises has a result, and then is kept (with a result of True) if that Promise is kept. If that Promise is broken, then the firstof is also broken, with the same excuse.

[19:33] <xalbo> Would that accurately describe it?

[19:34] <jnthn> Seems reasonable, if that doesn't replicate what winner does, which I need to see :)

[19:34] <xalbo> winner seems to tell you which promise first has a result, firstof seems to tell what what the result is.

[19:35] <xalbo> (well, whether it's kept or broken)

[19:41] * jnthn wonders if winner is the new name for select... :)

[19:43] <TimToady> yes, plus a bit of syntax

[19:43] <jnthn> k

[19:43] <jnthn> So long as the syntax isn't "when"... :)

[19:44] <diakopter> "upon"?

[19:44] <TimToady> well, currently it is, but that's negotiable

[19:44] <jnthn> Well

[19:44] <jnthn> It can be when if you don't expect it to parse the same as a given block. :)

[19:44] <jnthn> That is, it accepts nothing on the inside but when and treats them specially, not like the usual when

[19:44] <TimToady> I think winner is a macroish thing that forces its block to be interpreted as a monad of statement-like things

[19:44] <jnthn> I guess the pun with default is tepting.

[19:45] <jnthn> ok

[19:45] <TimToady> so it could change the meaning of when and default, presumably

[19:45] <TimToady> or we could pick different words

[19:45] <jnthn> And presumably you're not allowed to write anything other than a when or default?

[19:45] <TimToady> right, unless we find a way to generalize the monad

[19:45] <jnthn> Given that the non-sequentiality means we have no clue when to run such other code? :)

[19:46] <jnthn> ok, then I think I can live with the when/default

[19:46] <TimToady> "run all these statements in parallel, and whichever finishes first"

[19:46] <TimToady> so the generalization would be statements that presumably need scheduling somehow

[19:47] <TimToady> but not sure how that interacts with what we currently have

[19:47] <jnthn> The name "select" came from Go in this case rather than either of the Perl 5 meanings, btw ;)

[19:47] <TimToady> figgered

[19:47] <jnthn> (But I'm not defending keeping it at all. It was just a "safe" choice. :))

[19:47] <TimToady> winner is not perfect, but first is taken

[19:47] <jnthn> Sot's race I guess

[19:48] <jnthn> *so's

[19:48] <TimToady> race is a marathon, where everyone still tries to finish :)

[19:48] <TimToady> winner says "forget you" to the runners-up

[19:48] <jnthn> point :)

[19:49] <jnthn> Well, it's better than victor :)

[19:49] <TimToady> other than default, the other way would be to have a winner variant that doesn't block, winner-maybe or something, and returns Nil if nothing is done

[19:50] <TimToady> but it seemed okay to have a block on the "still racing" branch

[19:50] <TimToady> which can return Nil if you want

[19:53] <TimToady> hmm, might work better parsing like if/elseif/else

[19:54] <TimToady> only with the same keyword for both if and elseif

[19:54] <TimToady> then we can simply have an else at the end for 'no winner yet'

[19:55] <TimToady> or not

[19:56] <lue> .oO( winner { contestant 1 { } contestant "foo" { } contestant $const { } darkhorse { } } )

[19:56] <TimToady> hard to think of a good keyword for that offhand...

[19:57] <xalbo> Also, what does winner (however spelt) do if more than one of its promises has a result?

[19:57] <jnthn> xalbo: Pick one at random.

[19:57] <TimToady> lue: more like wins $p1 { } wins $p1 { } else { }

[19:57] <jnthn> TimToady: That looks weird to me if the word is wins :)

[19:58] <TimToady> not suggesting that word

[19:58] <TimToady> placeholder

[19:58] <jnthn> k

[19:58] <lue> champ $p1 { } champ $p2 { } ...

[19:58] <TimToady> yay $p1 {} yay $p2 {} boo {}

[19:58] <xalbo> done $p1 { } done $p2 { } else { }

[19:59] <lue> +1 yay/boo :D

[19:59] <PerlJam> .oO( then how do we fit in the boo-ya op? )

[20:00] <TimToady> using the .oO() metaoperator, obviously

[20:00] <xalbo> ko $p1 { } tko { } decision { }

[20:00] <TimToady> :)

[20:02] <TimToady> yay firstof @promises {} ...

[20:02] *** kaare__ left
[20:02] *** virtualsue joined
[20:02] <TimToady> gotta work "verily" in there somehow

[20:03] <PerlJam> Promises, promises.  Why do I believe?

[20:03] <jnthn> Is it too horrible to have like "winner { $p1 { }; $p2 { } }" :)

[20:04] <jnthn> Then we don't need another wrod on the inside :)

[20:04] <TimToady> ttiar?

[20:04] <jnthn> oh

[20:04] <jnthn> yeah, well, we allow that in othe rplaces we feel like it ;-)

[20:04] <jnthn> But this one likely causes too bad errors.

[20:06] <TimToady> would be nice if the insides at least parsed like a list of statements, even if we don't run them in sequence

[20:07] <PerlJam> oh, that already sounds confusing

[20:07] <TimToady> on Prancer {} on Donner {} on Vixen {}

[20:08] <TimToady> of course, Rudolph usually wins that race

[20:08] *** kaare__ joined
[20:08] *** kaare__ is now known as kaare_

[20:09] <jnthn> .oO( oh nose, he won again! )

[20:09] *** rurban left
[20:09] <xalbo> So how is "winner { when $p1 { } when $p2 { } default {}}" different from "if $p1 { } elseif $p2 { } else { }"? I can see how the non-default case is different.

[20:10] <TimToady> well, syntactically, it avoid the outer block

[20:11] <TimToady> which is not a very good scope if you can't put a 'my $x;' into it

[20:11] <jnthn> I think the outer block is important as it bounds the race and sets a non-sequential context up front.

[20:12] <jnthn> I think there may be stronger arguments for it, but I don't immediately have them... :)

[20:12] <TimToady> jnthn: that was my monadic feeling too

[20:13] <perigrin> TimToady: Rudolf only wins by a nose.

[20:13] *** Tene joined
[20:13] <TimToady> otoh if you're always going to put a loop around it anyway, you get a lot of extra braces

[20:14] <jnthn> nothing stopping us having a winnerloop or whatever though :)

[20:14] <TimToady> well, except that really looks like bloat to me

[20:14] <lizmat> looking at .vow, I can't help but feel that that is going to be the more common case

[20:15] <lizmat> maybe at leas Vow.new should be a shortcut for $p=Promise.new; $p.vow

[20:15] <jnthn> lizmat: But you need both.

[20:16] <TimToady> there are two very different meanings of "promise"

[20:16] <TimToady> depending on whether you're the promiser or the promisee.

[20:16] <TimToady> and I just went with the English notion that a promise is generally something you make to others, while a vow is generally something you make to yourself

[20:17] <jnthn> *nod*

[20:17] <jnthn> Note that you only need to pay attention to .vow if you really want to.

[20:17] <lizmat> I guess it depends on how paranoid you are

[20:17] <jnthn> Right. If I'm writing Promise.run, I'm paranoid. :)

[20:18] <jnthn> If I'm in my own code, using them in a scope I control, I'm less so :)

[20:18] <jnthn> In .Net you actually make a new TaskCompletionSource(); and then call .Task on that to get the task it has control over

[20:19] <jnthn> So you don't have a choice.

[20:19] <lizmat> I guess, being paranoid, I would use vow almost always

[20:19] <jnthn> AND you hve to type TaskCompletionSource all the time, dammit!

[20:19] <jnthn> lizmat: Well, in reality I hope that we provide enough combinators for the common cases that you don't need to do Promise.new that often.

[20:19] <jnthn> lizmat: And then there'll be the PromisePAN :)

[20:20] <lizmat> hehe...  good point

[20:22] *** daxim joined
[20:24] *** xalbo is now known as xalbo_

[20:25] *** xalbo_ left
[20:33] <japhb__> jnthn++ # PromisePAN

[20:41] <TimToady> nr: (do { say 'one' }␤do { say 'two' })

[20:41] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[20:41] <camelia> ..rakudo-parrot 215ba6, niecza v24-98-g473bd20: OUTPUT«one␤two␤»

[20:42] <TimToady> p: (do { say 'one' }␤do { say 'two' }).perl.say

[20:42] <camelia> rakudo-parrot 215ba6: OUTPUT«one␤two␤Bool::True␤»

[20:43] <dalek> specs: 039bbfd | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[20:43] <dalek> specs: Some code example tweaks

[20:43] <dalek> specs: review: https://github.com/perl6/specs/commit/039bbfdbf8

[20:48] *** dmol left
[20:48] *** dmol joined
[20:53] <TimToady> hmm, we don't really need await; turns out ($p1,$p2)».result works just as well

[20:54] <jaffa4> Somebody from London?

[20:54] <timotimo> could the former get some cleverness out of the scheduler?

[20:54] <TimToady> don't see how, the semantics are basically identical

[20:56] <jnthn> At one point I had thought that, but these days I'd rather just encourage people to stay async rather than altrnatte between sync/async styles.

[20:56] <jnthn> jaffa4: About 10 million people are, but I dunno if any are here...

[20:57] <jnthn> (where that = "do something more efficient")

[20:57] <TimToady> hypers are async style :P

[20:58] <TimToady> or are you claiming await is sync?

[20:58] <jnthn> I'm claiming anything that blocks is sync :)

[20:58] <TimToady> well, await is sync on one side and async on the other

[20:58] <jnthn> Aye. But it's those async => sync transitions that I'd rather we discourage maing too many of

[20:59] <dalek> specs: 2bd66db | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[20:59] <dalek> specs: Some more s/subscribable/supply/

[20:59] <dalek> specs: review: https://github.com/perl6/specs/commit/2bd66db213

[20:59] <jnthn> That's why I emphasized subscribables more and channels less of late

[20:59] <jnthn> uh, supplies :)

[20:59] <jnthn> that'll take some getting used to ;)

[20:59] <TimToady> if a channel is just a degenerate subscribable^Wsupply/tap we could just get rid of channels

[21:00] *** sqirrel left
[21:00] <lizmat> TimToady: my feelings exactly

[21:00] <jnthn> I think they're different tools for different jobs

[21:00] <jaffa4> jhthn: you made some lecture about rakudo compiler, right? Is it online?

[21:00] *** daxim left
[21:01] <jnthn> No, I already did the "should channels and supplies be the same" and concluded no.

[21:01] *** daxim joined
[21:01] <jnthn> Not to mention that I already felt the pain of trying to do things better suited to one with the other...

[21:01] <jnthn> Channels are nice 'cus they're really just concurrent queues underneath, which are nice and cheap.

[21:02] <jnthn> And you can compete to grab items, supporting scale-out in staged architectures.

[21:02] <jnthn> Supplies aren't good for that usage pattern.

[21:02] <TimToady> well, not without a .steal kind of tap, anyway

[21:03] <jnthn> I spent quite a while trying to unify channels and supplies and really didn't like where it led, and concluded they're different, so make them different and allow coercion between 'em.

[21:03] <TimToady> alternately, a waitress manning (?) the tap to dole out the drinks

[21:03] <lizmat> so a channel is a value queue, and a tap is an event queue ?

[21:04] <jnthn> lizmat: A channel is something you pull things out of at your own pace.

[21:04] <TimToady> events are values too!!!

[21:04] <jnthn> lizmat: A supply is something that pushes things at you.

[21:04] <TimToady> and they drop if you're not there

[21:04] <jnthn> that too

[21:04] <TimToady> okay, we can call them both keepers for now :)

[21:05] <jnthn> :)

[21:06] <jaffa4> jnthn:  is something wrong with my question>

[21:06] <jnthn> jaffa4: No, it just arrived when I was dealing with more interesting quesitons :P

[21:06] <jnthn> Then I forgot it 

[21:06] <jaffa4> aomehow I guessed it

[21:06] <jnthn> Are you asking about my talks I just did at Austiran Perl Workshop?

[21:06] <jnthn> Well, I *am* tired... :)

[21:07] <jnthn> jnthn.net/papers/2013-apw-conc.pdf and jnthn.net/papers/2013-apw-lessons.pdf if so

[21:07] <jnthn> I'm giving the first one again at Nordic Perl Workshop. I thought I go to re-use the material but now I'll have to go and update all the names and syntax :P

[21:07] <lizmat> hypothetical: what would you get if you would allow .tap on a channel ?

[21:07] <jaffa4> are you tired or the question was not intellectually challenging?

[21:08] <lizmat> jnthn is tired

[21:08] <jnthn> jaffa4: I'm really tired, 'cus of 2 days of teaching, and still not fully recovered from only getting 2 hours of sleep one night recently...

[21:08] *** rurban joined
[21:09] * jnthn has to go teach tomorrow too

[21:09] <jnthn> Of coures, my train home is running late... :/

[21:09] <TimToady> jaffa4: are you asking about the 2-day workshop last month?

[21:09] <jaffa4> mot sure anymore

[21:09] <TimToady> the one about compiler internals?

[21:09] <jaffa4> I kjust remember there was something

[21:10] *** daxim is now known as daxim_

[21:10] <jaffa4> compiler internals yes

[21:10] *** daxim joined
[21:10] *** daxim_ left
[21:10] <jnthn> oh,, that one

[21:10] <lizmat> jaffa4: https://github.com/edumentab/rakudo-and-nqp-internals-course

[21:11] <jnthn> https://github.com/edumentab/rakudo-and-nqp-internals-course

[21:11] <jnthn> beaten

[21:11] <lizmat> :-)

[21:11] <jnthn> In my defense, train wifi... :)

[21:11] <lizmat> 4G wifi here as well, fwiw

[21:12] <jaffa4> ok

[21:12] *** virtualsue left
[21:13] <jaffa4> by the way. why do you teach so much? does somebody force you to?

[21:13] <lizmat> it's $work for jnthn 

[21:13] <PerlJam> jaffa4: you don't think he could find teaching enjoyable?

[21:14] <FROGGS> I do when I am allowed to

[21:14] <jaffa4> it hardly can be enjable if he is too tired.

[21:14] <TimToady> typical geek attitude :P

[21:14] <FROGGS> well, he's not teaching now :o)

[21:14] <lizmat> nothing is enjoyable when you're too tired

[21:14] <FROGGS> sleep

[21:14] <lizmat> but shit happens :-)

[21:15] <TimToady> people enjoy running marathons

[21:15] <TimToady> and they're *definitely* too tired

[21:15] <FROGGS> on the numpad maybe :o)

[21:15] <jnthn> I enjoy teaching, but it is exhausting.

[21:15] <jnthn> I just happen to have a load of it bunched up these weeks, mixed in with a lot of travel.

[21:16] <TimToady> people have this silly idea that happiness and enjoyment are controlled by the same knob

[21:17] <TimToady> you can be quite sad on one level and quite joyful on another

[21:17] <jaffa4> multiple personality?

[21:17] <lizmat> multiple roles, more likely

[21:18] <jaffa4> multiple ago states?

[21:18] *** Mouq joined
[21:18] <lizmat> amsterdam PM meeting shutting down, decommute&

[21:18] *** lizmat left
[21:18] <jaffa4> ago->ego

[21:22] *** rurban left
[21:22] <Mouq> lookie at all the commits in the past few days

[21:22] <preflex>  Mouq: you have 1 new message. '/msg preflex messages' to read it.

[21:23] <Mouq> tadzik: It's fine; I probably should have messaged you about it. Thanks for making rakudobrew to begin with!

[21:32] *** rurban joined
[21:35] *** rurban left
[21:38] *** ktrout joined
[21:39] *** zakharyas joined
[21:39] *** ktrout left
[21:42] *** BenGoldberg joined
[21:43] *** jaffa4 left
[21:46] *** Rotwang joined
[22:01] <diakopter> .

[22:11] *** FROGGS_ joined
[22:11] *** FROGGS left
[22:12] <jnthn> yay, home

[22:12] <jnthn> And boo, primary net connection busted

[22:13] *** xinming left
[22:17] <Mouq> Is there any reason .assuming is in Routine instead of Code? As is, it leads to:

[22:17] <Mouq> p: (*-1,#`⟦don't want the * the method call⟧)[0].assuming(4).say

[22:17] *** xinming joined
[22:17] <camelia> rakudo-parrot 215ba6: OUTPUT«No such method 'assuming' for invocant of type 'WhateverCode'␤  in block  at /tmp/1N1oP839RB:1␤  in any  at /tmp/1N1oP839RB:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles a…»

[22:17] <Mouq> p: {"normal block, primed with "~$^a}.assuming(4).say

[22:17] <camelia> rakudo-parrot 215ba6: OUTPUT«No such method 'assuming' for invocant of type 'Block'␤  in block  at /tmp/LZQzAjjeJE:1␤  in any  at /tmp/LZQzAjjeJE:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles at gen/p…»

[22:19] *** kaare_ left
[22:20] <Mouq> Hm… S06:3081 too

[22:20] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_3081

[22:20] <Mouq> p: say Block ~~ Callable

[22:20] <camelia> rakudo-parrot 215ba6: OUTPUT«True␤»

[22:23] <Mouq> S32::Callable says it should be in Code, though, rather than Callable

[22:23] *** zakharyas left
[22:24] *** Tene left
[22:25] *** benabik left
[22:27] *** stevan__ left
[22:28] *** FROGGS_ is now known as FROGGS

[22:39] <lue> jnthn: *primary* net connection?

[22:41] <FROGGS> hehe, yeah, I've seen that too :o)

[22:42] <FROGGS> the question is: is the primary connection in East or West?

[22:45] <dalek> specs: c01155a | Mouq++ | S32-setting-library/ (3 files):

[22:45] <dalek> specs: [S32] Use modern return type syntax

[22:45] <dalek> specs: review: https://github.com/perl6/specs/commit/c01155abea

[22:46] *** raiph joined
[22:48] <timotimo> that's more modern?

[22:48] <Mouq> ... It... isn't it?

[22:48] <Mouq> std: sub Bool a () {True}; a

[22:48] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Return type Bool is not allowed between 'sub' and 'a'; please put it:␤  after the (missing) scope declarator but before the 'sub',␤  within the signature following the '-->' marker, or␤  as the argument of a 'returns' trait …»

[22:50] <timotimo> oh!

[22:50] <timotimo> didn't even know that :)

[22:51] <Mouq> There are a lot of things wrong with S32::Callable, though

[22:53] <lue> That's not a surprising statement :)

[22:53] *** hummeleB1 joined
[22:54] * Mouq tries to fix it up some

[22:56] *** PacoAir left
[22:58] <TimToady> Mouq: you seem to have clobbered a bunch of {...}s

[23:00] *** Rotwang left
[23:01] *** djanatyn1 joined
[23:02] *** Tene joined
[23:02] *** Tene left
[23:02] *** Tene joined
[23:05] * Mouq tries to fix his clobbers up some too

[23:07] *** dwarring joined
[23:07] *** jnap left
[23:08] *** Tene left
[23:08] *** djanatyn1 left
[23:09] *** stevan_ joined
[23:11] *** huricool joined
[23:11] *** toebu left
[23:11] *** djanatyn joined
[23:14] *** Tene joined
[23:14] *** Tene left
[23:14] *** Tene joined
[23:19] *** bluescreen10 left
[23:20] <dalek> nqp: 3cab7b7 | dwarring++ | examples/rubyish/t/ (4 files):

[23:20] <dalek> nqp: tidied rubb^Hyish tests

[23:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3cab7b702d

[23:20] <dalek> nqp: 84b433f | dwarring++ | examples/rubyish/ (2 files):

[23:20] <dalek> nqp: rubyish parameter defaults

[23:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/84b433f430

[23:28] *** huricool left
[23:29] *** tobyink joined
[23:30] *** ajr_ left
[23:32] *** avuserow joined
[23:33] <lue> rn: say glob("~/.foo")

[23:34] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[23:34] <camelia> ..niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'glob' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_u…»

[23:34] <camelia> ..rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/5KJ45xf6F5␤Undeclared routine:␤    glob used at line 1␤␤»

[23:34] <lue> (all of you)-- >:/

[23:35] *** jeffreykegler joined
[23:36] <jnthn> sleep &

[23:36] <lue> Is there a (non-workaroundy) way to make Perl 6 expand things like ~ ? I *could* just put the full path in, but 1) I shouldn't have to, and 2) that makes the script *very* platform specifc :)

[23:37] <lue> [btw, that "you" (all of you) above refers to the compilers, not any actual people]

[23:37] <lue> ♞ jnthn o/

[23:38] <jercos> >implying ~-notation isn't already platform psecific

[23:39] <lue> jercos: in this case, I'm playing with an XCompose file, so I would hope ~ does something :)

[23:39] <lue> (and I would also hope Windows has its ~ equivalent anyway)

[23:40] <geekosaur> it doesn't

[23:40] <geekosaur> it does have %foo% in place of unix's $foo

[23:40] <lue> I got the implication from S32::IO that glob() DWIW, (no description of glob itself, but its usage in an example with an # expands filenames commet) but doesn't exist.

[23:41] <lue> geekosaur: ō.ō Why am I shocked but not surprised?

[23:41] <jercos> fun fact: wuindows' variable failure case results in the literal string used to access the variable being used

[23:41] <jercos> so echo %foo% will echo "%foo%" if there is no variable foo

[23:42] <diakopter> jercos: yeah, you've got to test it and set to blank if you want the other behavior

[23:43] <lue> there is at least a  currentuser  command, that P6 could use to do 'C:\common\prefix\' ~ qx/currentuser/ ~ '\users\dirs', right? ...Right?

[23:43] *** colomon joined
[23:43] <jercos> lue: not as such.

[23:43] <lue> In any case, is glob supposed to expand ~ or no?

[23:44] *** btyler left
[23:44] <diakopter> lue: well corporate machines often have a remote "roaming" profile on some network location

[23:44] <diakopter> but yes there is a current user variable

[23:44] *** salv0 left
[23:44] <diakopter> USERNAME=mwilson

[23:44] <diakopter> USERPROFILE=C:\Users\mwilson

[23:44] <lue> .oO(How the hell do you get stuff done without symlinks, /usr/lib/<libraries>, ~, etc. etc.‽)

[23:44] <diakopter> (output of set)

[23:44] <jercos> there's %UserProfile% yeah

[23:45] <jercos> you get stuff done by... getting stuff done, not focussing on what directories and variables exist or don't exist.

[23:45] <diakopter> jercos++

[23:45] <diakopter> nature will find a way

[23:45] *** btyler joined
[23:47] <lue> I was referring to the idea of /usr/lib, not the specific directory.

[23:48] <lue> My point is that to someone who uses Linux, MSDOS is needlessly complicated in areas :)

[23:48] <diakopter> lue: in windows, applications have traditionally installed their systemwide-intended dlls in c:\windows\system(32)

[23:49] <Mouq> lue: "~/mah/path".subst(/^\~/,{qx[echo ~].chomp})

[23:49] <Mouq> But maybe that's what you mean by a work-around

[23:49] <lue> I am aware of that, but also of how libraries are typically tied to the application (instead of libraries being something that *always* gets put in a common location because they're, y'know, libraries.)

[23:49] <lue> Mouq: it is a bit workaroundy, but a lot smaller than what I would've come up with. :)

[23:50] <diakopter> lue: the problem is that there are many different versions of same-named libraries

[23:50] <diakopter> and total [or just assumed] backward compatibility is often infeasible

[23:50] <lue> Linux found a way :P

[23:50] <diakopter> an app often doesn't want some other app stomping on its dependencies

[23:50] <diakopter> lue: not really

[23:50] <lue> [ Windows did too, but I prefer the Linux solution :) ]

[23:51] <diakopter> lue: so just think of them as if they're statically linked

[23:52] <lue> I suppose it's just hard to get my mind into the MS-DOS mindset when I'm busy with using Linux (especially unhelpful is that I'm playing with XCompose files at the moment :P). Windows' solutions are valid WTDI, but they look funny to me :)

[23:57] <lue> Hm. &glob might be interesting to implement, but it's totally unspecced atm, and I don't trust myself to not throw away a bunch of features on account of "I wouldn't use it" :D

[23:59] <lue> (Reading the perldoc on File::Glob) "As a special case {, }, and {} are passed undisturbed." Does that mean glob("{a}") eq glob('{a}') ?

