[00:05] <labster> ah, okay, I see how rel2abs would infinite loop on Windows.

[00:08] <labster> it gets $*CWD as a parameter, which is something like "C:\foo", which looks non-absolute from a unix point of view, so it recurses trying to make $*CWD begin with a slash.

[00:10] <labster> I wonder if I should just disallow calling of no-argument .relative and .absolute unless you're on the appropriate system.

[00:20] <labster> oh well, in the meantime...

[00:25] <dalek> roast: 499c45f | (Brent Laabs)++ | S32-io/io-path-win.t:

[00:25] <dalek> roast: fudge IO::Path.absolute due to infinite recursion on Win32

[00:25] <dalek> roast: review: https://github.com/perl6/roast/commit/499c45fae8

[00:49] *** Targen joined
[00:51] <TimToady> pmichaud: on Pm-24, how could you ever tell the difference?  an inner : is moot if the outer *: cannot backtrack into it, seems to me

[00:51] *** snearch left
[00:53] *** kurahaupo left
[00:53] *** kcwu left
[00:59] *** anuby joined
[01:00] *** woosley joined
[01:01] *** kurahaupo joined
[01:08] <labster> r: sub not-foo { "2" }; say not-foo();

[01:09] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    foo used at line 1␤␤»

[01:09] <timotimo> er, shouldn't longest token matching catch that?

[01:10] <TimToady> n: sub not-foo { "2" }; say not-foo();

[01:10] <camelia> niecza v24-40-g31f36d2: OUTPUT«2␤»

[01:10] <TimToady> so it would seem

[01:21] *** FROGGS_ joined
[01:35] *** arlinius joined
[01:38] *** japhb_ left
[01:42] *** adu joined
[01:43] <adu> someone in this chatroom made an HTML template, and I'm trying to find it

[01:45] <adu> it was an HTML template with, like, a bunch of donate buttons, like paypal, bitcoin, ...

[01:45] <adu> I can't remember the name, but it's something like "free-your-web-site"

[01:45] <adu> who was it?

[01:47] <diakopter> is there a shorthand to ask try() to catch/return if something is thrown?

[01:47] <diakopter> (catch/return that exception, I mean)

[01:48] <diakopter> I mean, I suppose a macro could do it.

[01:48] <flussence> diakopter: not sure, but «try foo() orelse bar($!)» might work

[01:48] *** cooper_ joined
[01:50] <diakopter> r: (my $a= try die 44) orelse say $a

[01:50] <camelia> rakudo 9ed5c5: OUTPUT«Nil␤»

[01:50] <diakopter> r: (my $a= try 44) orelse say $a

[01:50] <camelia> rakudo 9ed5c5:  ( no output )

[01:50] <diakopter> r: (my $a= try 44) orelse say $a; say "'$a'"

[01:50] <camelia> rakudo 9ed5c5: OUTPUT«'44'␤»

[01:55] <flussence> r: (my $a = try die 'foo') orelse say $!

[01:55] <camelia> rakudo 9ed5c5: OUTPUT«foo␤  in block  at /tmp/KMPzlzpNV8:1␤␤»

[01:56] <flussence> r: (my $a = try die 'foo') orelse say "'$!'"

[01:56] <camelia> rakudo 9ed5c5: OUTPUT«'foo'␤»

[02:00] *** lustlife joined
[02:09] *** arlinius left
[02:10] *** xorp joined
[02:12] *** xorp left
[02:16] *** kurahaupo left
[02:34] *** adu left
[02:45] *** adu joined
[03:06] *** daniel-s_ joined
[03:11] *** xinming joined
[03:17] *** kurahaupo joined
[03:35] <dalek> roast: 1b67b86 | coke++ | S32-str/capitalize.t:

[03:35] <dalek> roast: rakudo fudge

[03:35] <dalek> roast: review: https://github.com/perl6/roast/commit/1b67b861f6

[03:36] *** crab2313 joined
[03:42] *** adu left
[03:43] *** adu joined
[03:44] *** preflex_ joined
[03:45] *** preflex_ is now known as preflex

[03:49] *** crab2313 left
[04:13] <labster> r: sub so-say { "we all" }; print so-say;

[04:13] <camelia> rakudo 9ed5c5: OUTPUT«␤True»

[04:13] * labster combines bugs for fun.

[04:23] <TimToady> not-so-funny :)

[04:25] *** Psyche^ joined
[04:26] <adu> hi all

[04:27] <adu> TimToady: so are you really the grand designer?

[04:27] <adu> labster: is that a reference to battlestar?

[04:28] <adu> labster: BTW, I'm a huge battlestar fan

[04:29] <adu> I'm convinced that Starbuck is an Angel

[04:29] *** Psyche^ is now known as Patterner

[04:30] <labster> Well, it definitely has to do with prefix:<not> and prefix:<so>. 

[04:31] <labster> rn: sub funny { ":)" }; sub not-so-funny { ">:O"}; say funny() and not-so-funny;

[04:31] <camelia> rakudo 9ed5c5: OUTPUT«:)␤Cannot convert string to number: radix (in decimal) expected after ':' in ':⏏)' (indicated by ⏏)␤  in method Numeric at src/gen/CORE.setting:10020␤  in sub prefix:<-> at src/gen/CORE.setting:2818␤  in sub prefix:<-> at src/gen/CORE.setting:2817␤  in sub prefix:<…

[04:31] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«:)␤»

[04:31] <labster> not even sure what happened there ^

[04:32] <labster> adu: yes, it's a battlestar reference.  Perl poetry has gotten even easier.

[04:32] * adu <3 labster 

[04:33] <labster> what kind of Angel do you mean?  The kind with wings, or the really strange ones in Neon Genesis Evangelion?

[04:33] *** skids left
[04:34] <adu> labster: there are 4 Angels in battlestar, Baltar's head Six, Six's head Baltar, Baltar's head Baltar, and Kara Trace after she dies and is resurrected

[04:34] <diakopter> r: sub so'so-so'-so { "we all" }; print so'so-so' -1

[04:34] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/QCLO_Rtx1p:1␤------> [32msub so'so-so[33m⏏[31m'-so { "we all" }; print so'so-so' -1[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be …

[04:34] <labster> or just the attractive woman type of angel.  if it's that kind, I definitely agree.

[04:34] <diakopter> argh.

[04:35] <sorear> adu: TimToady is actually Mr.Wall; the proper title in cases like this is generally "Senior Cat Herder"

[04:35] <adu> sorear: lolol

[04:36] * diakopter knows why to laugh too, even though I haven't seen BG

[04:36] <labster> rn: sub so-what { say "nyan" }; so-what;

[04:36] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/VgyjRtkueq:1␤------> [32msub so-what { say "nyan" [33m⏏[31m}; so-what;[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement …

[04:36] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/fP698c8Uj2 line 1:␤------> [32msub so-what { say "nyan" [33m⏏[31m}; so-what;[0m␤␤Parse failed␤␤»

[04:36] <sorear> diakopter: that's a BG reference?  I did not know

[04:36] <adu> sorear: also, the force that makes the final five listen to music could be considered a type of Angel

[04:37] <adu> er i Mean labster 

[04:37] <diakopter> sorear: er, oops I misread... seems not; ergh.

[04:38] <labster> geez, I really need to watch the last couple of seasons of BSG.  I missed a few episodes, subsequently got lost, and decided to watch it later on netflix -- and haven't done it yet.

[04:38] <adu> labster: it makes soooo much more sense if you agree with me

[04:40] <adu> labster: there are 3 types of people in battlestar: Humans, Cylons, and Angels, ….. just keep that in mind

[04:41] <bonsaikitten> and just remember, jesus saves

[04:41] <labster> and takes half damage

[04:41] <adu> bonsaikitten: whom?

[04:41] <bonsaikitten> I found that rather annoying, random religion stapled on to the end because ... err ... yeah

[04:42] <adu> bonsaikitten: that was not a complete sentance

[04:42] <labster> adu: parse error?

[04:42] <bonsaikitten> adu: that's about as far as I understood the reasoning for the big Allah Akhbaah at the end

[04:42] <adu> bonsaikitten: please complete your sentance so I can refute it

[04:43] <bonsaikitten> adu: that would imply that I have the mental flexibility to "understand" how turning SciFi into religious propaganda makes sense

[04:44] <adu> bonsaikitten: battlestar isn't religious propaganda, it's a story about a bunch of people fighting robots

[04:44] <labster> BSG the original started out waist-deep in Mormon theology.  I'm not getting the surprise here.

[04:45] <bonsaikitten> adu: until in (iirc) season 5 it turns into a christian story of redemption for no apparent raisin

[04:45] <diakopter> r: .++

[04:45] <camelia> rakudo 9ed5c5: OUTPUT«===SORRY!===␤Method 'unshift' not found for invocant of class 'NQPMu'␤»

[04:45] <bonsaikitten> labster: if it starts out like that it's fine

[04:45] <adu> labster: also, the original started out with Baltar wanting to kill all Humans

[04:46] <adu> labster: and ended with Baltar begging the Cylons to spare his life, … what a pitiful Human

[04:48] <adu> bonsaikitten: season 5 did have a particular focus on Baltar, and Baltar was the only side-story with cristian undertones, aside from that most of it was Machine brutality

[04:49] <bonsaikitten> adu: I guess I interpret things mildly different from you

[04:50] <adu> bonsaikitten: have you ever heard of thestone.com?

[04:50] <bonsaikitten> adu: about 12 seconds ago ;)

[04:50] * labster submits rakudobug

[04:51] <adu> bonsaikitten: the community charged with maintaining that website can be found at http://www.scarecrowsfield.com/, but that's besite the point

[04:51] <adu> bonsaikitten: it was an incredibly inspiring collection of visual puzzles

[04:52] <adu> thestone.com made you think about what it means to be first, what it means to be important, what it means to be history

[04:53] <adu> it was an incredibly religious experience, and yet it was pure logic

[04:54] <adu> it made you question the line between religion and reason

[04:54] <bonsaikitten> what a strangely hostile website

[04:55] <bonsaikitten> adu: religion is the absence of reason

[04:55] <adu> bonsaikitten: I guess I interpret things mildly different from you

[04:55] <bonsaikitten> faith demands no proof. proofs demand no faith

[04:55] <TimToady> that is a religious statement :)

[04:56] <labster> r: my $faith is Cool; $faith.bless(*)

[04:56] <camelia> rakudo 9ed5c5:  ( no output )

[04:57] <labster> no output from camelia -- she's more into Zen.

[04:57] <diakopter> her cocoon also freezes time

[04:58] <adu> labster: lolol

[04:58] <TimToady> frantic progress on the inside, lack of external signs on the outside, seems fitting :)

[04:59] <bonsaikitten> adu: possibly we use the word "religious" with different meanings

[05:01] <adu> bonsaikitten: from meriam-webster: "scrupulously and conscientiously faithful", that's my definition

[05:02] <adu> bonsaikitten: but in order to solve thestone.com, you had to be faithful that you would be rewarded for your efforts in solveing the puzzles

[05:03] <adu> because the only reward you ever got, was the answer

[05:04] <adu> and an HTML page that said "Yes, the answer is ..."

[05:08] <sorear> adu: getting DNS errors

[05:09] <adu> sorear: from http://www.scarecrowsfield.com/?

[05:09] <sorear> no, http://isup.me/thestone.com

[05:09] <adu> thestone.com shut down about 14 years ago

[05:10] <adu> as I said, http://www.scarecrowsfield.com/ maintains the legacy of thestone.com as what they call "The Stone Monument"

[05:11] <adu> sorear: sorry about the confusion

[05:12] <adu> apparently there was no money in inspiring people

[05:13] <sorear> stupid registration forms

[05:13] <adu> sorear: it's worth it :D

[05:14] <adu> sorear: I should be more specific "The Stone Monument" / "The Immediate"

[05:15] <sorear> and some jerk deleted the "bugmenot" account

[05:15] <adu> sorear: it should be free

[05:16] <moritz> \o

[05:16] <adu> o/

[05:18] <adu> sorear: yes, I just made an account for free

[05:19] *** dmol joined
[05:20] <sorear> is there any legitimate reason for the site to require registration?

[05:23] *** fgomez left
[05:23] <adu> sorear: dependency resolution, the later puzzles require that you've solved the earlier puzzles

[05:55] *** adu left
[05:56] *** frdmn joined
[06:02] <dalek> star: 7bfa75a | (Gabor Szabo)++ | .gitignore:

[06:02] <dalek> star: ignore *.swp files

[06:02] <dalek> star: review: https://github.com/rakudo/star/commit/7bfa75a02c

[06:06] *** clkao joined
[06:22] *** dickinsm joined
[06:33] *** dmol left
[06:34] *** kaleem joined
[06:36] *** FROGGS_ left
[06:44] *** dickinsm left
[06:45] *** daxim left
[06:46] *** xinming left
[06:49] *** xinming joined
[06:51] *** domidumont joined
[06:52] *** FROGGS_ joined
[06:53] *** FROGGS_ is now known as FROGGS

[07:03] *** domidumont left
[07:04] *** domidumont joined
[07:19] *** dickinsm joined
[07:21] *** kivutar joined
[07:25] *** dickinsm left
[07:27] *** arlinius joined
[07:35] <lizmat> labster: the so-foo/not-foo is more endemic:

[07:35] <lizmat> rn: sub s-foo { "2" }; say s-foo()

[07:35] <camelia> niecza v24-40-g31f36d2: OUTPUT«2␤»

[07:35] <camelia> ..rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter ) (must be quoted to match literally)␤at /tmp/DcI9kTMvXd:1␤------> [32msub s-foo { "2" }; say s-foo([33m⏏[31m)[0m␤Regex not terminated␤at /tmp/DcI9kTMvXd:1␤------> [32msub s-foo { "2" }; say s-foo…

[07:35] <lizmat> rn: sub m-foo { "2" }; say m-foo()

[07:35] <camelia> niecza v24-40-g31f36d2: OUTPUT«2␤»

[07:35] <camelia> ..rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter ) (must be quoted to match literally)␤at /tmp/sOpOL5i4FG:1␤------> [32msub m-foo { "2" }; say m-foo([33m⏏[31m)[0m␤Regex not terminated␤at /tmp/sOpOL5i4FG:1␤------> [32msub m-foo { "2" }; say m-foo…

[07:37] <labster> I guess it is.

[07:38] <labster> rn: my \s = 3; say s.perl;

[07:38] <camelia> niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Regex missing terminator (or semicolon must be quoted?) at /tmp/Dbyk3jXPmk line 1 (EOF):␤------> [32mmy \s = 3; say s.perl;[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[07:38] <camelia> ..rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter ; (must be quoted to match literally)␤at /tmp/fCH_zj2z8h:1␤------> [32mmy \s = 3; say s.perl[33m⏏[31m;[0m␤Couldn't find terminator $stop␤at /tmp/fCH_zj2z8h:1␤------> [32mmy \s = 3; say s.perl;[33…

[07:38] <lizmat> that last one already has a bug report, FROGGS has told me

[07:39] *** rindolf joined
[07:42] <labster> r: sub rx-for-loneliness { "the love doctor"}; say rx-for-loneliness;

[07:42] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/ZWwR3Nnm2Y:1␤------> [32mliness { "the love doctor"}; say rx-for-[33m⏏[31mloneliness;[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤    …

[07:43] *** kivutar left
[07:43] <labster> sub rx-for { "the love doctor"; }; say rx-for;

[07:44] <labster> r: sub rx-for { "the love doctor"; }; say rx-for;

[07:44] <camelia> rakudo 9ed5c5: OUTPUT«␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀S␀␀␀O␀␀␀R␀␀␀R␀␀␀Y␀␀␀!␀␀␀␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀␤␀␀␀U␀␀␀n␀␀␀r␀␀␀e␀␀␀c␀␀␀o␀␀␀g␀␀␀n␀␀␀i␀␀␀z􏿽xE2

[07:44] <labster> oh wow

[07:53] <moritz> and on the terminal you wouldn't even notice it

[07:53] <moritz> because most terminals don't print the 0-bytes

[07:53] <moritz> it's related to UTF-32 leaking out through error messages

[07:54] <lizmat> strange, I only get "Regex not terminated"

[07:55] <lizmat> r: sub rx-for { "the love doctor"; }; say rx-for

[07:55] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Regex not terminated␤at /tmp/VWk5A_NKwG:1␤------> [32mx-for { "the love doctor"; }; say rx-for[33m⏏[31m<EOL>[0m␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤        infix stopper…

[07:55] <lizmat> the ; makes a difference

[07:55] <FROGGS> -.-

[07:55] *** census joined
[07:56] <FROGGS> morning fellows in misery

[07:56] <lizmat> morning FROGGS!

[07:56] <FROGGS> O/

[07:56] <tadzik> hey hey

[07:56] <FROGGS> ola

[07:57] <FROGGS> labster: btw, I was sure the already is a report for so-foo/not-foo, but I can't find it

[07:57] <diakopter> FROGGS: misery? I do feel miserly..

[07:58] <diakopter> r: say so not Cool, max

[07:58] <camelia> rakudo 9ed5c5: OUTPUT«True-Inf␤»

[07:59] <labster> FROGGS: you're probably right.  The channel was just being so silly then that I felt like being productive.

[07:59] <diakopter> moi?

[08:00] <labster> not you diakopter.

[08:00] <FROGGS> diakopter: btw, that output of ./smoke is a bit, well, nonverbose... do you managed to capture that TAPs yet?

[08:00] <diakopter> :D

[08:01] <tadzik> I guess http://feather.perl6.nl/~sergot/modules/module/Test::Harness.html has to be fineshed by someone [tm]

[08:01] <tadzik> I may find some tuits for it this week

[08:02] <tadzik> I have a version of Panda somewhere that uses it instead of running prove

[08:02] <tadzik> last time I checked, it always said "all tests pass" ;)

[08:03] *** kresike joined
[08:03] <kresike> hello all you happy perl6 people

[08:03] <diakopter> FROGGS: wait what?

[08:03] <diakopter> I don't smoke

[08:04] <diakopter> or ./smoke

[08:04] <FROGGS> hmmm, that it is a braino on my side

[08:04] <tadzik> I think colomon++ was interested in smoking

[08:06] <diakopter> VMware Workstation unrecoverable error: (vmx)

[08:06] <diakopter> NOT_IMPLEMENTED d:/build/ob/bora-1031769/bora/lib/aioManagers/aioWin32Completion.c:3173

[08:06] <diakopter> oops, ww

[08:07] <diakopter> [that error is new to me... :S ]

[08:07] <FROGGS> ahh, my fault

[08:07] <FROGGS> sorry diakopter 

[08:13] *** fhelmberger joined
[08:14] <FROGGS> tadzik++

[08:14] <FROGGS> tadzik: feel free to give me tasks for that

[08:19] <tadzik> FROGGS: well, I suppose I should read up on P5's TAP::Harness and its definition of Success

[08:19] <FROGGS> true

[08:19] <FROGGS> (and then write todo-list :o)

[08:20] <tadzik> :) yep

[08:20] <FROGGS> or better: make issues

[08:20] <lizmat> rn: 

[08:20] <lizmat> rn: my %a= Set.new( (a => 2) ); say %a

[08:20] <camelia> niecza v24-40-g31f36d2: OUTPUT«Unhandled exception: Unmatched key in Hash.LISTSTORE␤  at /tmp/yTYO0kb6Vn line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4312 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4313 (module-CORE @ 583) ␤  at /home/p6eval/niec…

[08:20] <camelia> ..rakudo 9ed5c5: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:6889␤  in block  at /tmp/X2DeQn_GNk:1␤␤»

[08:20] <tadzik> FROGGS: I think there's a panda branch running p6prove

[08:20] <tadzik> or if there isn't, it's a one-line change anyway

[08:20] <lizmat> I don't understand this error

[08:20] <tadzik> it'd be nice to know on what modules p6prove is wrong when determining test result

[08:20] <lizmat> looking at src/core/Set.pm

[08:20] <tadzik> then I can track down individual things

[08:21] <lizmat> line 20:                 when Pair { %e{.key} = True; }

[08:21] <lizmat> am I missing something here ?

[08:21] <tadzik> I'm afraid I brought Set to Rakudo :)

[08:21] <FROGGS> tadzik: k, will try that today

[08:22] <tadzik> FROGGS++

[08:22] <tadzik> my %a= Set.new( Pair.new(:key(a), :value(2) ); say %a

[08:22] <tadzik> r: my %a= Set.new( Pair.new(:key(a), :value(2) ); say %a

[08:22] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in argument list; couldn't find final ')'␤at /tmp/UJxTFP5RPw:1␤------> [32mw( Pair.new(:key(a), :value(2) ); say %a[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[08:22] <tadzik> ooh

[08:22] <tadzik> r: my $a= Set.new( (a => 2) ); say %a

[08:22] <camelia> rakudo 9ed5c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '%a' is not declared. Did you mean '$a'?␤at /tmp/ntWwi4puYY:1␤------> [32mmy $a= Set.new( (a => 2) ); say %a[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[08:23] <tadzik> r: my $a= Set.new( (a => 2) ); say $a.perl #grrrrr

[08:23] <camelia> rakudo 9ed5c5: OUTPUT«set("a")␤»

[08:23] <tadzik> lizmat: there you are

[08:23] <tadzik> if you assign one value to %a, being Set or not, you get a key with no value

[08:23] <lizmat> *sigh*

[08:23] <tadzik> r: my %a = 5

[08:23] <camelia> rakudo 9ed5c5: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:6889␤  in block  at /tmp/i7qzEX2O8X:1␤␤»

[08:23] <lizmat> that makes utter sense....

[08:23] * lizmat is going to do some fitness to clear the mind

[08:23] *** donaldh joined
[08:26] *** kivutar joined
[08:30] *** rhr_ left
[08:31] <mathw> morning

[08:31] *** rhr joined
[08:31] <tadzik> hello mathw 

[08:32] <mathw> hi tadzik

[08:32] <mathw> how's it going?

[08:33] <tadzik> pretty good. Busy times

[08:33] <tadzik> but I finally got my t430 last week \o/

[08:34] <hoelzro> tadzik: thinkpad?

[08:34] <tadzik> yep

[08:34] <tadzik> my old one is on the well-deserved retirement

[08:35] <hoelzro> \o/

[08:35] * hoelzro has a t420

[08:35] <hoelzro> I love that machine

[08:35] * diakopter too

[08:35] <diakopter> s

[08:35] <FROGGS> toos?

[08:35] <diakopter> 420s

[08:35] <FROGGS> :o)

[08:35] * FROGGS has an awesome dell machine

[08:35] <tadzik> s like "smaller"?

[08:36] * mathw is liking very much his T430 but isn't so keen on the instability Linux is exhibiting on it

[08:36] <tadzik> I wouldn't mind a 13"-ish thing

[08:36] <mathw> not sure if that's the machine or the latest crop of distros though. Possibly a bit of a mixture of both.

[08:36] *** daxim joined
[08:36] <tadzik> mathw: I put the new xubuntu on mine, works like a charm

[08:36] <tadzik> even got smapi to work

[08:36] <mathw> wow

[08:37] <mathw> I initially put Fedora 18 on mine, but there were a number of really strange and nasty issues with text rendering

[08:37] <tadzik> well, "smapi"

[08:37] <tadzik> it's no longer a thinkpad specific kernel module, just one named acpi_call and a Perl script running it

[08:37] <diakopter> tadzike: hopefully I'm getting an X1 Carbon Touch next week

[08:37] <mathw> then I put ubuntu 13.04 on it, and that was fine (with me even starting to get used to Unity) when it decided abruptly that Empathy wasn't going to be able to talk to the telepathy account manager anymore

[08:38] <mathw> and all I could find about it was something suggesting it's an apparmor config issue which has resurfaced after being a problem around the 12.04 era

[08:38] <mathw> however none of the log files which are supposed to mention this sort of thing mention anything, so I'm not sure

[08:38] <mathw> but on the bright side it's not just me

[08:41] <tadzik> diakopter: wow

[08:42] <tadzik> mathw: I keep away from any big DEs

[08:42] <tadzik> I ignore xfce and use i3 on my xubuntu

[08:42] <tadzik> I basically only run ubuntu for Steam sake :P

[08:43] <bonsaikitten> tadzik: that no sense

[08:45] <tadzik> why not?

[08:45] <tadzik> I like the comfort of working with my OS, not _on_ my OS

[08:46] <tadzik> on ubuntu everything Just Works, most of the problems are already solved

[08:46] <bonsaikitten> hrm, you must use a different ubuntu than I did

[08:46] <bonsaikitten> since I hate compiling I don't use it anymore :)

[08:47] <tadzik> keep in mind I'm not using Unity as a desktop environment :)

[08:47] <tadzik> without it ubuntu is pretty much debian with newer glibc

[08:48] <bonsaikitten> heh

[08:48] <bonsaikitten> yeah, I tried using unity

[08:48] <bonsaikitten> it was a fun game, but ... it doesn't make any sense

[08:48] * FROGGS has seen a greeting card: "5 out of 4 people can't do fractions"

[08:49] <mathw> yeah unity is a bit weird

[08:49] <moritz> r: '' ~~ /<:L>/

[08:50] <camelia> rakudo 9ed5c5: OUTPUT«Cannot get character of empty string␤  in regex  at /tmp/et0dL5aQYn:1␤  in method ACCEPTS at src/gen/CORE.setting:10370␤  in method ACCEPTS at src/gen/CORE.setting:683␤  in block  at /tmp/et0dL5aQYn:1␤␤»

[08:50] <mathw> not all the interactions seem to have been really thought through, so it's got some bizarre inconsistencies

[08:50] <mathw> and I don't like the way they try to hide the menus

[08:50] <moritz> I think I know where it needs fixing

[08:50] <mathw> however I'm not entirely averse to new stuff as I'm extremely comfortable with gnome shell

[08:50] <moritz> nqp/src/vm/parrot/QAST/Compiler.nqp method uniprop

[08:50] <bonsaikitten> mathw: it also doesn't seem to like the idea of using multiple windows

[08:51] <bonsaikitten> so it might work on a mobile phone, but even there it's quite crummy I guess

[08:51] <mathw> I'm VERY dubious about the one OS for all those form factors idea

[08:51] <moritz> probably nees a check that makes the regex fail if the string is shorter than the pos

[08:52] <moritz> mathw: it can make sense to have one OS for all those, but I'm very sceptical of having the same UI for them

[08:52] <bonsaikitten> mathw: KDE seems to have figured that one out - multiple "shells" that are specialized for one use, but all using the same backend machinery

[08:54] <mathw> moritz: point, have to separate the relevant parts. Same kernel is proven after all. Could share more of the stack than that, but not sure a tablet should use the same shell as a desktop or a laptop or a phone.

[08:54] <mathw> probably shouldn't

[08:54] <mathw> bonsaikitten: they may be onto something there, if only it wasn't all ugly and awkward (to my way of thinking)

[08:54] <jnthn> moritz: I gotta head out in just a moment, but I suspect a fix can be stolen from enumcharlist or cclass

[08:55] <mathw> they seem to have a nice pile of tech to play with though

[08:55] <bonsaikitten> mathw: hrm, I find the gtk way horribly fugly, and they still haven't figured out simple widgets like a file selector

[08:56] <moritz> jnthn: looks like a good hint

[08:57] <mathw> bonsaikitten: I think the best thing is that neither of us are forced to use what we don't like at this point.

[08:57] <bonsaikitten> mathw: well, thanks to the nice people from redhat we shouldn't even have that choice

[08:58] <bonsaikitten> so much effort just to keep them from breaking everything 

[08:59] *** donaldh left
[09:00] <mathw> are you referring to systemd and friends?

[09:01] <jnthn> meeting &

[09:05] <bonsaikitten> mathw: yes, such a great downgrade to be more like windows

[09:05] <arnsholt> TBH, I'm glad some people are trying to replace init and friends

[09:05] <bonsaikitten> and little things like breaking input methods

[09:06] <bonsaikitten> arnsholt: good idea, bad implementation - they don't even write any comments in the sourcecode when they can avoid it

[09:06] <arnsholt> Really, it's the best (maybe) tech the early 1980s have to offer

[09:06] <bonsaikitten> also, sysvinit has been beefed up a lot ... OpenRC, for example

[09:06] <bonsaikitten> (which is amusingly the best candidate for debian now)

[09:09] <masak> good antenoon, #perl6

[09:11] <FROGGS> hi masak 

[09:11] <mathw> hi masak

[09:12] <tadzik> hi masak

[09:16] <Timbus> hi masak

[09:16] *** berekuk joined
[09:16] <Timbus> do you have logs to the masakism course

[09:17] <tadzik> GlitchMr has them, I think

[09:17] *** berekuk left
[09:19] <masak> they're on irclog

[09:19] <moritz> irclog.perlgeek.de has them

[09:19] <masak> http://irclog.perlgeek.de/masakism/2013-05-01

[09:20] <Timbus> oh neato

[09:20] <masak> moritz++

[09:20] <Timbus> i can read these and just, imagine im there

[09:20] *** thou left
[09:29] *** berekuk joined
[09:34] <masak> :)

[09:35] <masak> interesting fact: the word "awesome" was used six times that day. ;)

[09:35] <masak> (four times by me, but still)

[09:35] <moritz> I wonder how often it's used in the IRC channel of the window manager named 'awesome' :-)

[09:40] * masak .oO( all their errors are LTA )

[09:59] *** kurahaupo left
[10:01] * mathw .oO( window managers shouldn't have errors )

[10:02] <tadzik> heh, you can use this one which has Less Than 1000 sloc [tm], it's probably bug-free

[10:08] <moritz> iirc xmonad is quite short

[10:10] * arnsholt uses XMonad

[10:10] *** anuby left
[10:11] <tadzik> I very like i3

[10:11] <tadzik> it's probably the only one where you configure it, not write pieces of code. And it has tray *gasp*!

[10:11] <arnsholt> I'm pretty happy with it. But configuring it can be a bit daunting at times, since it's all done in Haskell =D

[10:11] <tadzik> :)

[10:11] <arnsholt> Yeah, I should probably figure out something tray-ish for my XMonad

[10:13] <dalek> nqp: b4ad9fc | moritz++ | src/vm/parrot/QAST/Compiler.nqp:

[10:13] <dalek> nqp: [QRegex] fix matching of <:L> past end of string

[10:13] <dalek> nqp: 

[10:13] <dalek> nqp: Fixes RT #117889

[10:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b4ad9fc9c6

[10:32] *** daniel-s_ left
[10:33] *** bbkr joined
[10:44] <FROGGS> n: my @var = <a b ab c>; my $aref = \@var; say 'a b ab c0' ~~ m/$aref[0]/

[10:44] <camelia> niecza v24-40-g31f36d2: OUTPUT«Potential difficulties:␤  Apparent subscript will be treated as regex at /tmp/gCjEvrZD33 line 1:␤------> [32maref = \@var; say 'a b ab c0' ~~ m/$aref[33m⏏[31m[0]/[0m␤␤False␤»

[10:44] <FROGGS> n: my @var = <a b ab c>; my $aref = \@var; say 'a b ab c0' ~~ m/$aref/

[10:44] <camelia> niecza v24-40-g31f36d2: OUTPUT«False␤»

[10:45] <dalek> roast: 23dc92a | (Tobias Leich)++ | S05-metasyntax/litvar.t:

[10:45] <dalek> roast: fix test (precedence)

[10:45] <dalek> roast: review: https://github.com/perl6/roast/commit/23dc92a9f8

[10:47] *** WinRar joined
[10:47] *** WinRar left
[10:49] <moritz> http://irclog.perlgeek.de/ now with small activity images

[10:50] <moritz> all those images are on the same time scale, but with diffent scalings on the y axes

[10:51] <FROGGS> uhh, cool!

[10:51] <FROGGS> moritz++

[10:51] <arnsholt> Neat!

[10:51] <arnsholt> Time scale last 24 hours or something like that?

[10:52] <moritz> no, time scale since I started logging

[10:52] <arnsholt> Ah, cool

[10:52] <moritz> needs much less redoing :-)

[10:52] <moritz> like, once a week or so

[10:53] <moritz> it's not yet cron'd, but I plan to do that eventuelly

[10:53] <moritz> *eventually

[10:53] <moritz> and then on the #perl6 index page, I could add a per-month activity image

[10:53] <FROGGS> is #perl6 the most active channel?

[10:54] <arnsholt> moritz: In that case, I guess y is "lines per logged day"?

[10:54] <FROGGS> moritz: that could be used as background image of the calendar-title-cell

[10:55] <FROGGS> that page could benefit from github's style :o)

[10:55] <moritz> arnsholt: y is "lines logged per time unit", where time unit = timespan of loggin / 100

[10:55] <moritz> FROGGS: good idea

[10:56] <sergot> hi ! o/

[10:56] <FROGGS> hi sergot 

[10:56] <dalek> rakudo/nom: ad71045 | moritz++ | src/core/Str.pm:

[10:56] <dalek> rakudo/nom: fix argument type of :$where in Str.wordcase

[10:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad71045014

[10:56] <dalek> rakudo/nom: a4c8c57 | moritz++ | tools/build/NQP_REVISION:

[10:56] <dalek> rakudo/nom: bump NQP revision to get fix for RT #117889

[10:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4c8c57669

[10:57] <dalek> roast: d07a830 | moritz++ | S05-mass/properties-general.t:

[10:57] <dalek> roast: RT #117889: <:L> past the end of string

[10:57] <dalek> roast: review: https://github.com/perl6/roast/commit/d07a830fa8

[10:59] <FROGGS> ohh, I like it if bugs dont 'live' longer than a day \o/

[10:59] <FROGGS> moritz++

[10:59] <moritz> jnthn++ gave a good hint how to fix it

[10:59] <FROGGS> ('live' means: bugfix-date minus discovery-date)

[11:00] <arnsholt> moritz: That makes sense. No need to plot thousands of points for that

[11:20] <masak> moritz: it's interesting that #perl6 is the only channel with a constant activity :)

[11:21] <nwc10> moritz: the graphs currently show parts and joins as activity? If so, is it easy to either (a) have two lines, one excluding parts and joins or (b) the one line exclude parts and joins?

[11:24] <masak> I'd go with (b).

[11:24] <tadzik> b

[11:24] <masak> no need to clutter up a nice clean idea ;)

[11:24] <tadzik> parts/joins are mostly worthless on irc imho

[11:24] <moritz> masak: it's the only channel that I log for so long

[11:25] <masak> oh!

[11:25] <masak> that makes more sense. (but is less interesting, too) :)

[11:25] <moritz> you are right, I should remove all those lines

[11:26] *** daxim left
[11:27] <moritz> ... done in git.

[11:27] *** daxim joined
[11:38] <lizmat> rn: my Set $h .= new( ( foo => 1, bar => 0).hash ); say $h

[11:38] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«set(foo, bar)␤»

[11:39] <lizmat> is it wrong of me to expect that the constructor would only add keys to the set that have a True value ?

[11:40] <moritz> apparently, yes :-)

[11:40] <moritz> you'd use a bag otherwise, no?

[11:40] <moritz> rn: my Bag $h .= new( ( foo => 1, bar => 0).hash ); say $h

[11:40] *** sqirrel joined
[11:40] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«bag("foo" => 1)␤»

[11:40] <moritz> rn: my Bag $h .= new( ( foo => 1, bar => 0).hash ); say $h.set

[11:40] <camelia> niecza v24-40-g31f36d2: OUTPUT«Unhandled exception: Unable to resolve method set in type Bag␤  at /tmp/My_QzKGyvu line 1 (mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4312 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4313 (module-CORE @ 583) ␤  at /home/p6…

[11:40] <camelia> ..rakudo a4c8c5: OUTPUT«No such method 'set' for invocant of type 'Bag'␤  in block  at /tmp/4JLBVOEMt5:1␤␤»

[11:40] <moritz> rn: my Bag $h .= new( ( foo => 1, bar => 0).hash ); say set($h)

[11:40] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«set(foo)␤»

[11:41] <lizmat> -                when Pair { %e{.key} = True; }

[11:41] <lizmat> +                when Pair { %e{.key} = True if .value; }

[11:41] <lizmat> src/core/Set.pm, line 20

[11:42] <moritz> lizmat: I don't think that's desirable

[11:42] <moritz> lizmat: because that behavior is already available if you use a bag

[11:44] <lizmat> well, I would think that would make things *more* consistent

[11:44] <moritz> nr: my %h = (a => 1, b => 0); say so 'b' ~~ %h

[11:44] <camelia> niecza v24-40-g31f36d2: OUTPUT«False␤»

[11:44] <camelia> ..rakudo a4c8c5: OUTPUT«True␤»

[11:45] <moritz> nr: my %h = (a => 1, b => 0); say so 'b' ~~ set(%h(

[11:45] <moritz> nr: my %h = (a => 1, b => 0); say so 'b' ~~ set(%h)

[11:45] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in argument list; couldn't find final ')'␤at /tmp/CHxLwtWaW6:1␤------> [32m (a => 1, b => 0); say so 'b' ~~ set(%h([33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        argument list␤»…

[11:45] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unable to parse argument list at /tmp/hGEehJgezJ line 1 (EOF):␤------> [32m (a => 1, b => 0); say so 'b' ~~ set(%h([33m⏏[31m<EOL>[0m␤Couldn't find final ')'; gave up at /tmp/hGEehJgezJ line 1 (EOF):␤------> [32m (a => 1…

[11:45] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«False␤»

[11:45] <moritz> nr: my %h = (a => 1, b => 0); say so 'b' ~~ set(<a b>)

[11:45] <camelia> niecza v24-40-g31f36d2: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/jgu_9hbH33 line 1:␤------> [32mmy [33m⏏[31m%h = (a => 1, b => 0); say so 'b' ~~ set[0m␤␤False␤»

[11:45] <camelia> ..rakudo a4c8c5: OUTPUT«False␤»

[11:45] <moritz> wtf?

[11:46] <moritz> nr: say set(<a b>)

[11:46] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«set(a, b)␤»

[11:46] <moritz> nr: say so 'a' ~~ set(<a b>)

[11:46] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«False␤»

[11:46] <colomon> I don't think Set or Bag do ACCEPTS

[11:46] <moritz> I would have expected that to a membership test

[11:46] <moritz> Any       Set       force set comparison    Set($_) === X

[11:47] <colomon> rn: say 'a' (elem) set(<a b>)

[11:47] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«True␤»

[11:47] <moritz> that's what I would have expected

[11:47] <moritz> anyway

[11:48] <moritz> rn: say 'b' ~~ %( a => 1, b => 0)

[11:48] <camelia> niecza v24-40-g31f36d2: OUTPUT«False␤»

[11:48] <camelia> ..rakudo a4c8c5: OUTPUT«True␤»

[11:48] <moritz> that's a niecza bug

[11:48] <moritz> Cool      Hash      hash entry existence    X.{$_}:exists

[11:49] <colomon> moritz: not disagreeing with you on the question of ACCEPTS, just stating what it does and how to get that effect.

[11:49] *** kurahaupo joined
[11:49] <moritz> opened https://github.com/sorear/niecza/issues/172

[11:49] <colomon> moritz++

[11:50] <moritz> what I actually wanted to show to lizmat is that set(%h) should (IMHO) be consistent with ~~ %h

[11:52] <colomon> moritz: I'm still fuzzy this morning, but Set and Bag are not consistent with each other about how they handle getting a => 0....

[11:53] <moritz> colomon: yes, that's kinda my point

[11:53] <moritz> colomon: a Bag excludes a => 0

[11:53] <colomon> right

[11:53] <lizmat> "KeySet and KeyBag are derived from this type, but constrain their values to be Bool and UInt, respectively. A KeyHash automatically deletes any key whose value goes false."

[11:53] <moritz> so the behavior that lizmat wants for Set already exists in Bag

[11:53] <lizmat> the type being KeyHash

[11:54] <moritz> lizmat: weren't you experimenting with Set?

[11:54] * moritz now also confused

[11:54] <lizmat> yes, I'm trying to write a lightning talk for tonights Amsterdam.pm meeting, Perl5 to Perl6 nuggets, part 2

[11:55] <lizmat> whether it's Set or KeySet is not important for the examples

[11:56] <lizmat> anyways, I was thinking it was a small oversight in src/core/Set.pm

[11:56] <lizmat> fixable by: when Pair { %e{.key} = True if .value; }

[11:56] <colomon> lizmat: I'm not sure it's an oversight, but it might be a design error.

[11:56] <lizmat> (adding the "if .value")

[11:57] <lizmat> is it worth making an issue out of it?

[11:59] <colomon> feels like it deserves a thoughtful blog post.

[12:01] <lizmat> well, if I'm going to blog, it would be about the inconsistency between:

[12:01] <lizmat> rn: my %a= foo => 1, bar => 2; say %a

[12:01] <camelia> niecza v24-40-g31f36d2: OUTPUT«{"bar" => 2, "foo" => 1}␤»

[12:01] <camelia> ..rakudo a4c8c5: OUTPUT«("foo" => 1, "bar" => 2).hash␤»

[12:01] <lizmat> and:

[12:02] <lizmat> my Hash $a.= new( foo => 1, bar => 2 ); say $a

[12:02] <lizmat> rn: my Hash $a.= new( foo => 1, bar => 2 ); say $a

[12:02] <camelia> niecza v24-40-g31f36d2: OUTPUT«Unhandled exception: Excess arguments to Hash.new, unused named foo, bar␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Hash.new @ 1) ␤  at /tmp/PWFoPihsRF line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4312 (ANON @ 3) ␤  at /home…

[12:02] <camelia> ..rakudo a4c8c5: OUTPUT«().hash␤»

[12:02] <lizmat> at least Niecza tells me what I'm doing "wrong"  :-)

[12:03] <jnthn> That should probably Just Work.

[12:03] <jnthn> In fact, I'm a bit surprised it doesn't already.

[12:03] <lizmat> apparently only positionals are taken into account, and any named parameters are dropped on the floor

[12:04] * lizmat needs to get on the road

[12:05] *** woolfy joined
[12:07] * nwc10 sees that jnthn made it safely back from Euroland.

[12:08] <jnthn> nwc10: Yes, my work there is finnished. :)

[12:09] <nwc10> groan

[12:09] <FROGGS> hehe

[12:24] *** donaldh joined
[12:25] *** kivutar left
[12:26] * masak .oO( lol your puns are so Pori )

[12:28] <jnthn> .oO( can't Tampere with my punning... )

[12:28] <masak> nwc10: btw, Sweden is in Euroland, too. just not in the Euro*zone* :P

[12:28] *** kivutar joined
[12:28] <donaldh> jnthn: Should VMExceptionInstance be stringifiable or should Ops.smart_stringify have a special case for VMExceptionInstance?

[12:28] <jnthn> donaldh: I though I'd already done that.

[12:28] <donaldh> jnthn: oh/

[12:28] <masak> nwc10: let me explain it to you with this simple Euler diagram: https://en.wikipedia.org/wiki/Template:Supranational_European_Bodies

[12:28] <jnthn> donaldh: (in smart_stringify)

[12:29] <donaldh> jnthn: on rak_jvm_support?

[12:29] <jnthn> donaldh: possibly :)

[12:30] *** Woodi joined
[12:32] *** cognominal joined
[12:32] <donaldh> jnthn: yep, just on rak-jvm-support. I'll switch to that branch. (I think I said that last week)

[12:34] <Util> rn: my @a = {title => "a"}, {title => "b"}; my @t = map *.<title>, @a; say @t.perl;

[12:34] <camelia> niecza v24-40-g31f36d2: OUTPUT«["a", "b"].list␤»

[12:34] <camelia> ..rakudo a4c8c5: OUTPUT«Array.new("a", "b")␤»

[12:34] <Util> rn: my @a = {title => "a"}, {title => "b"}; my @t =  @a>>.<title>;     say @t.perl;

[12:35] <camelia> niecza v24-40-g31f36d2: OUTPUT«Unhandled exception: Cannot use hash access on an object of type Str␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 352 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/gmCmKI4bxJ line 0 (ANON @ …

[12:35] <camelia> ..rakudo a4c8c5: OUTPUT«postcircumfix:<{ }> not defined for type Str␤  in method sink at src/gen/CORE.setting:10030␤  in method STORE at src/gen/CORE.setting:6889␤  in sub hash at src/gen/CORE.setting:7042␤  in sub hyper at src/gen/CORE.setting:14023␤  in sub hyper at src/gen/CORE.setting…

[12:35] <Util> Didn't that work sometime in the past?

[12:40] <moritz> yes, and it will work again some day, when rakudo and niecza catch up the current spec

[12:40] <timotimo> "how hard can it be? *opens code* -  ... oh"

[12:41] *** lizmat joined
[12:41] <moritz> timotimo: I did that twice for this very problem

[12:42] * lizmat is on the road

[12:43] <Util> moritz, timotimo: Thanks!

[12:45] <moritz> oh, might not be so hard after all

[12:45] <moritz> "just" needs fixing method dispatch:<hyper>(Mu \SELF: $name, |c)

[12:45] <timotimo> cool!

[12:47] <moritz> or maybe multi sub hyper(\op, \obj) {

[12:47] <moritz> that's where the difficulties start :/

[12:54] *** kurahaupo left
[12:57] <FROGGS> I dont get it, running t/spec/S11-modules/nested.t using ./perl6 passes, but fails using t/harness :/

[13:00] <jnthn> FROGGS: Do you have a Something.pm lying around in your Rakudo repo?

[13:00] <FROGGS> maybe... brb

[13:00] <jnthn> FROGGS: iirc, t/harness gives -I. or so

[13:00] <FROGGS> k, thanks so far

[13:01] <moritz> FROGGS: also maybe the test plan doesn't match the number of tests

[13:01] <moritz> or the the test produced additional output to STDOUT

[13:01] <moritz> t/harness is stricter than visual inspection :-)

[13:07] *** FROGGS left
[13:14] <moritz> I have a patch. It causes 4 spectests to fail

[13:15] <moritz> $ ./perl6 -e 'say ({ b => 1}, {b => 2})>>.<b>'

[13:15] <moritz> 1 2

[13:18] <moritz> r: say -Any

[13:18] <camelia> rakudo a4c8c5: OUTPUT«use of uninitialized value of type Any in numeric context  in block  at /tmp/WfzkxA_mod:1␤␤0␤»

[13:18] <moritz> meh

[13:18] * moritz HATES THE DUCKMAP SPEC

[13:18] *** PacoAir joined
[13:18] <moritz> "(For this meaning of "responds to", we ignore any multi candidates defined in Cool, or the negation above would not work, since Array responds to negation via Cool."

[13:18] <moritz> no, Array responds to negation via Any

[13:18] <moritz> at least in Rakudo

[13:19] <moritz> n: say -Any

[13:19] <camelia> niecza v24-40-g31f36d2: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1356 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 294 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/l6Jvd6dXDB line 1 (mainli…

[13:19] <moritz> and since Any has to respond to negation, there's no point in adding an extra layer of Cool(aid)

[13:19] <pmichaud> I wonder if the spec means "defined in Cool or Any or Mu"

[13:20] <pmichaud> anything defined in Any is (to some extent) also defined for Cool.

[13:20] <moritz> anyway, it's unimplementable at the moment

[13:20] <moritz> because we don't have a multi dispatcher that we can tell to exclude Cool

[13:21] *** MrMeek-afk joined
[13:21] *** ajr joined
[13:21] <moritz> I'm so ».« close to just freakin' give @foo>>.method different semantics than -<< @foo

[13:22] *** ajr is now known as Guest5794

[13:22] <moritz> because that solves 99% of the user-visible problems with the current behavior without implementing duck mapping

[13:22] <moritz> which is a crazy concept anyway, which I never liked

[13:24] *** FROGGS joined
[13:25] <jnthn> I really, really do not want duck mapping.

[13:25] <masak> moritz: let's hear it -- what are you proposing?

[13:25] <pmichaud> do we need a multi dispatcher that can exclude Cool, OOC?

[13:26] <pmichaud> what about .^methods(:excl) ?

[13:26] <jnthn> pmichaud: Do we care if it's fast?

[13:26] <moritz> masak: make   anyting>>.method go only one level deep, always

[13:26] <jnthn> +1 to make anything>>.method go only one level deep always

[13:27] <masak> moritz: oh, I'm forever +1 on that one.

[13:29] <jnthn> The problem is we'd have to duplicate the whole cache infrastructure for the "exclude cool" dispatch.

[13:31] *** skids joined
[13:31] <pmichaud> moritz: is your proposal assuming that operators would also be restricted to one-level-deep, too?

[13:31] <pmichaud> or is it just >>.method ?

[13:33] <moritz> pmichaud: just >>.method

[13:33] <pmichaud> so, that wouldn't fix the .{ }  case above, right?

[13:34] <moritz> .{ } is a method, in that context (afaict)

[13:34] <pmichaud> it's not going to be.

[13:34] <pmichaud> postcircumfix:<{ }> is slated to become an operator.

[13:34] <masak> yay

[13:34] <pmichaud> (as is postcircumfix:<[ ]>)

[13:35] <masak> sorear++ was right all along... :)

[13:35] <moritz> pmichaud: then I'd propose "anything with >> in postfixish"

[13:35] <pmichaud> "anything with >> in postfixish" has a smell, I think.

[13:35] <FROGGS> jnthn: I had a A.pm in reakudo/ -.-

[13:35] <jnthn> Do we want >>+<< to be more than one level deep?

[13:35] <moritz> pmichaud: "every time >> is used on a postfix operator or method call"

[13:36] <pmichaud> moritz: still smelly that we have two different hyper interpretations.

[13:36] <moritz> or just "every time >> is used on a postfix"

[13:36] <pmichaud> jnthn: [[1,2], [3,4]] >>+<< [[5,6], [7,8]]

[13:36] <moritz> pmichaud: aye; but not as smelly as duck mapping

[13:36] <pmichaud> pretty sure that doesn't want to be [4, 4]

[13:37] <jnthn> pmichaud: That outer [...] should not flatten anyway?

[13:38] <pmichaud> modulo syntax

[13:38] <pmichaud> ((1,2), (3,4)) >>+<< ((5,6), (7,8))  if you insist.

[13:38] <jnthn> Well, that one just falls out of flattening

[13:38] <jnthn> ([1,2],[2,4]) ... is the interesting one, iiuc.

[13:39] <FROGGS> ahh jnthn: do you have time today to talk about symbol tables?

[13:40] <pmichaud> S03 gives the example of   -<< [ [1,2], 3]   becoming  [ [-1, -2], -3 ]   so I think my original example was correct-ish.

[13:41] <FROGGS> nr: say -<< [ [1,2], 3]

[13:41] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«-1 -2 -3␤»

[13:41] <FROGGS> nr: say (-<< [ [1,2], 3]).perl

[13:41] <camelia> rakudo a4c8c5: OUTPUT«([-1, -2], -3)␤»

[13:41] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[[-1, -2], -3].list␤»

[13:42] <pmichaud> bug.  :)

[13:43] <jnthn> Do we not have some ticket about other meta-ops flattening too much?

[13:43] * jnthn forgets the details

[13:43] <jnthn> FROGGS: Later on, yes. Meant to be being attentive to a meeting atm ;)

[13:43] <pmichaud> yes, we have lots of flattening issues

[13:44] <pmichaud> but that one isn't a flattening issue, it's a "hyper doesn't respect containers on its arguments" issue, I think.

[13:44] <FROGGS> jnthn: cool

[13:45] *** Targen left
[13:46] <masak> FROGGS: are you submitting a rakudobug, or should I?

[13:47] <moritz> fwiw I have a local patch that changes >>.method and >>.<subscript> to only go deep one level

[13:47] <moritz> it just fails one block of spectests, which expects to be able to say %hash>>.abs and have it work on the hash values, not the pairs

[13:48] <pmichaud> I'm not a fan of having different meanings for hyper depending on the postfixishness.  I'm not saying that the current duck mapping is the answer either, but giving hypers this sort of distinction feels very wrong to me.

[13:49] *** kivutar left
[13:49] <masak> pmichaud: agreed.

[13:49] <moritz> so let's have >> for flat-hyper and >>> for deep hyper

[13:49] <masak> pmichaud: fwiw, I'm not a fan of deep hypering in any situation. I could accept that as an operator adverb, but I don't like it as the default behavior.

[13:50] <masak> moritz: or just a method for deep hyper.

[13:50] <moritz> and «« vs «

[13:50] <masak> moritz: «« would need to be <<<< as ASCII :)

[13:50] <pmichaud> masak: what about the [[1,2], [3,4]] >>+<< [[5,6], [7,8]]  situation above?

[13:50] <pmichaud> just say we don't support it?

[13:50] <masak> pmichaud: hm.

[13:50] <moritz> masak: I'm not sure an method is the correct solution for something symmetrical

[13:51] <masak> pmichaud: I can't help thinking it's S09-related. like, maybe hyper does the right thing if you've defined a shape for the data structure.

[13:51] <pmichaud> masak: yes, I was wondering that also.

[13:51] <pmichaud> masak: but I don't know that I should have to define a shape just to get nested arrays to dtrt.

[13:51] <masak> pmichaud: I dunno, doesn't feel like too much to ask.

[13:51] <jnthn> And typically in Perl we use different operators for different sematnics.

[13:52] <masak> pmichaud: it's kind of a lead-in to S09. "predeclare, and you'll get nice features!"

[13:52] <jnthn> (In this case, meta-operators)

[13:52] <jnthn> I'd be happiest if we could differentiate the shallow vs deep cases.

[13:52] <masak> but I admit to not having thought deeply about this :)

[13:53] <pmichaud> well, TimToady++ has been backing off of things that do too much introspective dwimming, so perhaps this will be another one of those instances.

[13:53] <pmichaud> jnthn: duckmapping *does* differentiate the shallow vs deep cases; we just don't like the way it does it.  :)

[13:53] <jnthn> pmichaud: No no. I mean, *you write something different in the code*. :)

[13:54] <pmichaud> right, you're wanting it to differentiate syntactically

[13:54] <jnthn> >>+<< vs >>>+<<< for example, though maybe not like that :P

[13:54] <pmichaud> but it's not really the case that we always change operators for different semantics

[13:54] <pmichaud> at least, I don't think it is.

[13:54] *** kivutar joined
[13:54] <jnthn> Well, eq vs ==, for example.

[13:54] <moritz> pmichaud: at least we try to, really hard

[13:55] <moritz> like abandoning perl 5's reverse() ambiguty

[13:55] <sjn> \o

[13:55] <jnthn> We've also split reverse into flip and reverse, to give another example where we've leaned to naming different operations differently.

[13:55] <masak> sjn: \o

[13:55] <jnthn> It just depends I guess how different we consider the two.

[13:55] <pmichaud> I know we can come up with examples where we have different operators for different semantics, I'm just not sure it's universal yet.

[13:55] <moritz> also p5's & can be string or integer bitwise ops

[13:55] *** kaleem left
[13:55] <sjn> masak, jnthn: any thoughts about good short poster-able examples? :)

[13:56] <jnthn> .oO< @a >>+<< @b :depth(*)

[13:56] <jnthn> )

[13:56] <moritz> pmichaud: we have a few operators that violate that rule deliberately, like ~~

[13:56] <jnthn> Adverbs are always a big of a hack though :)

[13:56] <jnthn> uh, bit of, but... :)

[13:56] <moritz> @a >*>+<*< @b

[13:56] * moritz not quite serious about >*>+<*<

[13:57] <jnthn> o.O :)

[13:57] <pmichaud> I may be wrong, but it also feels like we're arguing for different semantics based on difficulty of implementation, and not necessarily what the programmer would want/expect.

[13:57] <pmichaud> (in the hypers case)

[13:58] <pmichaud> I haven't seen many examples of above where we say "it needs to be this way because that's what programmers expect"

[14:01] <moritz> pmichaud: when duck mapping was introduced, I also presented several arguments about it violating the principle of least surprise

[14:01] <pmichaud> moritz: oh, I can believe that.

[14:01] <pmichaud> I truly am not a fan of duck mapping either.

[14:01] <moritz> pmichaud: likt that it's not safe against adding operations to container types

[14:01] <pmichaud> but I'm not convinced that "make everything shallow" is the right answer to that.

[14:02] <moritz> no, but "make postfixes shallow" is a the best compromise I've heard of so far

[14:02] <pmichaud> I wonder if deepness is somehow tied to the operator or method being hypered.

[14:03] * masak decommutes

[14:03] *** lizmat left
[14:03] <jnthn> decommute also &

[14:03] <pmichaud> moritz: I don't think I want   -<< [[1,2], 3]   to be deep but   [[1, -2], 3]>>.abs to be shallow.

[14:03] <moritz> oh wait

[14:03] *** lizmat joined
[14:03] <moritz> S03 has this piece:

[14:03] <moritz> Unary hyper operators always produce a hash or array of exactly the

[14:03] <moritz> same I<declared> shape as the single argument.  If the item is not

[14:03] <moritz> declared with a shape, only the top dimension is mapped, equivalent

[14:03] <moritz> to a normal C<.map> method.  

[14:04] <moritz> which directly contradicts the -<< [[1,2], 3] example

[14:04] <pmichaud> Yes, I believe that the spec is self-contradictory on duckmapping also, which is part of what makes it confounding.

[14:05] *** census left
[14:06] <pmichaud> because it also says

[14:06] <pmichaud> For unary hypers, we use a policy called "duck mapping", which says that when a node responds directly to the operator supplied, it is considered a leaf node, and any Iterable components of the node are ignored.

[14:08] <lizmat> something entirely different, if I may:

[14:08] <lizmat> rn: class Hash2 is Hash { multi method new (*%n-->Hash) { nextwith(%n.kv) } }; my $h= Hash2.new( a => 1, b => 2 ); say $h;

[14:08] <camelia> niecza v24-40-g31f36d2: OUTPUT«Unhandled exception: Illegal control operator: nextsame/nextwith␤  at /home/p6eval/niecza/lib/CORE.setting line 1538 (nextwith @ 5) ␤  at /tmp/sdtnjMCFIG line 1 (Hash2.new @ 5) ␤  at /tmp/sdtnjMCFIG line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.…

[14:08] <camelia> ..rakudo a4c8c5: OUTPUT«Too many positional parameters passed; got 5 but expected 1␤  in method new at src/gen/CORE.setting:727␤  in any  at src/gen/Metamodel.nqp:2885␤  in any call_with_args at src/gen/Metamodel.nqp:2882␤  in block  at src/gen/CORE.setting:548␤  in method new at /tmp/t8i…

[14:09] <moritz> pmichaud: right; I believe we had the exact same discussion before

[14:09] <lizmat> I guess I'm either not understanding multi-dispatch, or I'm doing something else wrong ?

[14:09] <moritz> pmichaud: which ended in me telling you that the section I quoted earlier was newest, and I wanted to remove the rest, and you said you weren't sure and wanted to get TimToady's opinion first

[14:10] <pmichaud> I don't think we want   -<< [[7,8], 9]  to suddenly become [-2, -9], no.

[14:11] * lizmat arriiving in Amsterdam, afk until later

[14:11] *** lizmat left
[14:12] <pmichaud> but yes, if the unary hyperops end up being shallow for arguments with no declared shape, then hyperops in general probably ought to be shallow in all such situations as well.

[14:15] *** bluescreen10 joined
[14:15] <pmichaud> what's the new "leave a message" syntax?

[14:15] <pmichaud>   (.tell who what?)

[14:16] <moritz> .msg pmichaud like this, maybe?

[14:16] <yoleaux> moritz: Sorry, this command is admin-only.

[14:16] <moritz> .tell pmichaud like this, maybe?

[14:16] <yoleaux> moritz: I'll pass your message to pmichaud.

[14:16] <pmichaud> .tell lizmat (Hash2.new multimethod fail)   the problem appears to be that Rakudo's Hash.new method isn't declared 'multi'.

[14:16] <yoleaux> 14:16Z <moritz> pmichaud: like this, maybe?

[14:16] <yoleaux> pmichaud: I'll pass your message to lizmat.

[14:16] <pmichaud>     method new(*@args) { @args.hash }

[14:22] <pmichaud> (afk)

[14:25] *** Moukeddar joined
[14:32] * moritz opened https://github.com/perl6/specs/issues/42

[14:33] <hoelzro> the bot should report opened issues!

[14:34] <Moukeddar> guys,o/ , can i bother you with some cqrs related questions

[14:38] *** Targen joined
[14:43] *** frdmn left
[14:46] *** am0c joined
[14:51] *** rindolf left
[14:58] *** kbenson joined
[15:00] *** mucker joined
[15:01] *** Moukeddar left
[15:02] *** sftp left
[15:02] *** sftp joined
[15:10] *** kaare_ joined
[15:11] <kresike> bye folks

[15:11] *** kresike left
[15:16] *** stevan_ joined
[15:20] *** kaleem joined
[15:25] *** domidumont left
[15:37] *** am0c left
[15:41] <mucker> java.lang.RuntimeException: java.lang.RuntimeException: Method code too large! #JAVA_OPTS=-Xms512M -Xmx1G -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=384M 

[15:42] <mucker> trying to build nqp

[15:44] <jnthn> mucker: It's fixed in the rak-jvm-support branch; I'll try and get that merged shortly (next couple of days) so that master will also be fixed for this.

[15:44] <nwc10> jnthn: you know the cause?

[15:45] <mucker> jnthn++ can I checkout the branch now ?

[15:45] <jnthn> mucker: Yes, it should build just fine.

[15:46] <jnthn> nwc10: Yeah, a patch that I didn't think had gone into master did, somehow. 

[15:46] <nwc10> aha. Oops.

[15:46] <jnthn> nwc10: The reason I can't just merge the branch already is 'cus Rakudo's mainline branch won't build against rak-jvm-support at the moment on Parrot.

[15:46] <nwc10> that's a tad inconvenient

[15:47] <jnthn> Yeah. All is fine in the jvm-support branch of Rakudo, though. :)

[15:47] <nwc10> that branch will build with Parrot?

[15:47] <jnthn> Yes.

[15:47] <jnthn> But if I merge it now I also drag JVM stuff into Rakudo mainline.

[15:48] <jnthn> Which may not be desirable until I get it to at least run *something*. :)

[15:48] <donaldh> jnthn: I could send a pull request for the sub() {...} workaround.

[15:49] <jnthn> Anyway, what I can do is rebase -i that jvm-support branch, put all the refactor-related patches before the JVM-support-adding patches, then merge the branch up to the end of the support-adding ones. :)

[15:49] <jnthn> And then "problem solved" :)

[15:49] *** kaleem left
[15:50] <jnthn> donaldh: I plan to get the branch merged in the next couple of days somehow, so don't worry about it. :)

[15:50] <donaldh> cool

[15:50] <donaldh> jnthn: I sent a pull request for REPL

[15:52] <donaldh> jnthn: I was looking for a lib for full REPL editing/history. Could be http://jline.sourceforge.net/

[15:52] <jnthn> Ooh, great :)

[15:53] <donaldh> I'll work on that next unless there's something more useful :-)

[15:53] <jnthn> BSD license is fine, too :)

[15:54] <jnthn> A working REPL is certainly useful.

[15:54] <dalek> perl6-roast-data: ea3e082 | coke++ | / (4 files):

[15:54] <dalek> perl6-roast-data: today (automated commit)

[15:54] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ea3e082b7b

[15:56] * donaldh decommutes

[15:56] *** donaldh left
[15:57] <dalek> nqp/rak-jvm-support: d0a2b89 | (Donald Hunter)++ | src/vm/jvm/runtime/org/perl6/nqp/ (2 files):

[15:57] <dalek> nqp/rak-jvm-support: Updates to IO ops to get REPL working

[15:57] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/d0a2b89475

[15:57] <dalek> nqp/rak-jvm-support: 19008e4 | jonathan++ | src/vm/jvm/runtime/org/perl6/nqp/ (2 files):

[15:57] <dalek> nqp/rak-jvm-support: Merge pull request #95 from donaldh/repl

[15:57] <dalek> nqp/rak-jvm-support: 

[15:57] <dalek> nqp/rak-jvm-support: Updates to JVM IO ops to get REPL working

[15:57] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/19008e4df9

[15:58] *** stevan__ joined
[16:02] *** stevan_ left
[16:09] *** clkao left
[16:09] *** clkao joined
[16:10] <[Coke]> does anyone care enough about szabgab's .gitignore commit to revert it?

[16:10] <[Coke]> (rakudo-star)

[16:11] *** thou joined
[16:12] <[Coke]> (I do, but will probably not get to it for days)

[16:16] <sorear> n: {} ~~ {}

[16:16] <camelia> niecza v24-40-g31f36d2:  ( no output )

[16:16] <sorear> n: say {} ~~ {}

[16:16] <camelia> niecza v24-40-g31f36d2: OUTPUT«False␤»

[16:16] *** lizmat joined
[16:18] *** mucker left
[16:22] *** lizmat left
[16:28] *** stevan__ left
[16:29] <colomon> rn: my %h = a => 12; say 'a' ~~ %h; say %h ~~ %h

[16:29] <camelia> niecza v24-40-g31f36d2: OUTPUT«False␤True␤»

[16:29] <camelia> ..rakudo a4c8c5: OUTPUT«True␤False␤»

[16:29] <colomon> hmm.

[16:29] <masak> um.

[16:29] *** Subterra joined
[16:30] <masak> at least one of <Niecza Rakudo> is wronge there ;)

[16:31] <colomon> I'm leaning towards both!

[16:31] <colomon> Hash      Hash      hash keys same set      $_.keys === X.keys

[16:31] <masak> me too.

[16:31] <masak> so Rakudo is wrong on the second one.

[16:31] <masak> and Niecza is wrong on the first one. :)

[16:31] <colomon> Any       Hash      hash slice existence    X.{any @$_}:exists

[16:31] <masak> colomon: or evern

[16:32] <masak> Cool      Hash      hash entry existence    X.{$_}:exists

[16:32] <masak> even*

[16:32] <colomon> Niecza is actually wrong on the second too, you just can't tell

[16:32] * masak .oO( secretly wrong! )

[16:33] *** dmol joined
[16:33] *** gtodd joined
[16:33] *** xilo joined
[16:34] <colomon> rn: my %a = a => 1; my %b = a => 2; say %a ~~ %b

[16:34] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«False␤»

[16:34] <colomon> should be true, right?

[16:35] <PerlJam> How do you figure?

[16:35] <colomon> PerlJam: Hash smartmatch is supposed to compare the hash's keys.  

[16:36] <masak> colomon: yes.

[16:36] <colomon> https://github.com/perl6/roast/blob/master/S03-smartmatch/hash-hash.t#L7-L29

[16:36] <colomon> it's a bad sign when half the tests are todo'd on every single implementation.

[16:36] <PerlJam> weird.

[16:36] <masak> PerlJam: agreed.

[16:36] <masak> PerlJam: but perhaps makes a little more sense in a 'when' than in a '~~'

[16:38] <dalek> Heuristic branch merge: pushed 19 commits to nqp/rak-jvm-support by jnthn

[16:39] <colomon> though does $_.keys === X.keys actually make sense as a test?

[16:39] <colomon> rn: say <a b> === <a b>

[16:39] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«False␤»

[16:39] <colomon> Either I don't understand something or $_.keys === X.keys is a very sloppy approximation of what is actually wanted

[16:39] *** lizmat joined
[16:41] <masak> colomon: huh. yes, === feels very wrong there.

[16:41] <colomon> rn: say <a b> <<===>> <a b>

[16:41] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of >> to do right shift;  in Perl 6 please use +> or ~>␤at /tmp/I6Xelja_SW:1␤------> [32msay <a b> <<===>>[33m⏏[31m <a b>[0m␤»

[16:41] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot make assignment out of <<== because sequencer operators are too fiddly at /tmp/zM9TLs3cUJ line 1:␤------> [32msay <a b> <<===[33m⏏[31m>> <a b>[0m␤␤Bogus statement at /tmp/zM9TLs3cUJ line 1:␤------> [32msay <a b> …

[16:42] <masak> colomon: «===» I woulda understood, like with Array Array.

[16:42] <colomon> rn: say <a b> «===» <a b>

[16:42] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«True True␤»

[16:42] <colomon> masak: that can't be right, because order of .keys is not guaranteed.  

[16:43] <colomon> what is actually wanted here is Set equality...

[16:43] *** Guest5794 left
[16:43] *** lizmat left
[16:43] <masak> colomon: oh, yes.

[16:44] <colomon> $_.set eqv X.set

[16:44] <colomon> except Set eqv Set is NYI in Niecza.  Dunno about Rakudo.

[16:44] <colomon> afk # fetching noms for family

[16:45] <dalek> nqp/rak-jvm-support: c3f5a0f | jnthn++ | src/QRegex/P5Regex/Grammar.nqp:

[16:45] <dalek> nqp/rak-jvm-support: Fix all but one of the P5Regex tests on JVM.

[16:45] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/c3f5a0f340

[16:46] <masak> feels weird-ish to define smartmatching between hashes in terms of sets, for some reason.

[16:46] <colomon> of course, then the question becomes is it $_.set eqv X.set or $_.keys.set eqv X.keys.set ?

[16:47] <colomon> masak: that's probably not the right way to implement it, but it is exactly the desired semantics.  I think.

[16:47] *** fhelmberger left
[16:48] <sorear> masak: niecza doesn't have a Hash.ACCEPTS, it's inherited from Mu :D

[16:50] *** mucker joined
[16:53] <masak> colomon: agreed.

[16:53] <masak> sorear: hehe. "what is the sound of one Hash clapping?" :P

[16:54] *** frdmn joined
[16:56] <daxim> 1/0  # oh shi…

[16:59] <dalek> nqp/rak-jvm-support: 75b5649 | jnthn++ | src/QRegex/Cursor.nqp:

[16:59] *** stevan_ joined
[16:59] <dalek> nqp/rak-jvm-support: Make !dump_array tolerate nullness better.

[16:59] <dalek> nqp/rak-jvm-support: 

[16:59] <dalek> nqp/rak-jvm-support: Gets us down to just 3 p6regex tests failing on JVM.

[16:59] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/75b5649eee

[16:59] <colomon> sorear: I'm working on that issue... thus the questions!

[17:00] <[Coke]> jnthn++

[17:02] *** DarthGandalf joined
[17:32] *** Chillance joined
[17:34] *** daxim left
[17:35] <TimToady> re unary hypers, see https://github.com/perl6/specs/commit/3320ccbb61c4b3cf4a36eccbf7a158ab5573e428

[17:36] <TimToady> dunno why dalek didn't report it...

[17:36] *** domidumont joined
[17:37] <moritz> TimToady++

[17:37] <pmichaud> so it is "per operator"!  \o/

[17:38] <TimToady> FAQ answer: "That's a nodal operator, so it doesn't recurse."

[17:38] <TimToady> hopefully not too F

[17:38] <pmichaud> as long as the dwim really dwtm it won't be F  :)

[17:38] <moritz> I'm just not sure if I understood the method case

[17:39] <TimToady> you have to have a proto, I think, to have a structural method

[17:39] <TimToady> otherwise it's probably going to be assumed to be non-structural

[17:40] <TimToady> has to be something that is easy for the hyper controller to discover quickly, anyway

[17:40] <TimToady> assuming it can't be known at compile time

[17:40] <TimToady> which some methods might be knowable depending on which classes can close/finalize at CHECK time

[17:42] <TimToady> and yes, it's an introspection, but hopefully it's the least smelly way to get something that dwims most of the time

[17:43] <TimToady> in any case, it's an introspection that doesn't need to be made on every node, just on the initial hyper dispatch

[17:43] <pmichaud> well, it's introspection at the level of the operator, which means we can likely hotpath some of them

[17:43] <TimToady> two minds with but a single thought... :)

[17:48] <arnsholt> masak: http://translate.google.no/#no/sv/postoppkrav

[17:48] <moritz> wait, doesn't it need to introspect for each element again?

[17:48] <arnsholt> (And anyone else Scandinavian-phone, I guess. moritz perhaps?)

[17:49] <moritz> I guess it can cache based on type

[17:50] <masak> arnsholt: wt...

[17:52] <sorear> .tr :no :sv postoppkrav

[17:52] <yoleaux> TORSK (no → sv)

[17:52] <arnsholt> masak: There's a relatively coherent explanation for it

[17:53] <pmichaud> it needs to introspect each element for non-structural operators.  Yes, it could cache based on type.

[17:53] *** kivutar left
[17:53] <sorear> arnsholt: Is that one of those statistical translation glitches?

[17:53] <arnsholt> There's probably no translation model for the no-sv pair (not surprising since they're both small languages and statistical MT requires relatively large parallel corpora)

[17:53] <arnsholt> sorear: Sort of

[17:53] <sorear> like how city names sometimes get switched

[17:53] <pmichaud> for structural operators, such as .{} and .elems it wouldn't need to introspect.

[17:54] <sorear> .tr :no :en postoppkrav

[17:54] <yoleaux> COD (no → en)

[17:54] <sorear> .tr :sv :en torsk

[17:54] <yoleaux> cod (sv → en)

[17:54] <arnsholt> So instead of not allowing translation from Norwegian to Swedish, they first translate from Norwegian to English and then to Swedish

[17:54] <sorear> so it goes through english and gets "roundoff error"?

[17:54] <arnsholt> I'd say roundoff error is on the charitable side, but yeah =)

[17:55] <TimToady> for operators that are known to be disjunct with structural operations, one could still do the failover trick in one direction or the other

[17:55] <sorear> do these two words refer to specific species of fish?

[17:56] <TimToady> (the .duckmap vs .deepmap distinction is really only useful when the operators are not know to be disjunct)

[17:56] <TimToady> so the initial dispatch itself can in many cases serve as the "introspection"

[17:57] <sorear> Aha

[17:57] <TimToady> *the initial dispatch on the item

[17:57] <pmichaud> indeed... in Rakudo's case it can introspect the operator at compile-time

[17:57] <sorear> Haha

[17:57] <pmichaud> I'm afk again... TimToady++ for rapid spec issue clarifications.

[17:57] <arnsholt> sorear: No. Postoppkrav is Cash on delivery (or whatever COD is an abbreviation for)

[17:58] * sorear looks at https://no.wikipedia.org/wiki/Postoppkrav and https://sv.wikipedia.org/wiki/Torsk

[17:58] <arnsholt> Torsk is the fish cod, though

[17:58] <arnsholt> Oh. Collect on delivery

[17:59] <arnsholt> Nothing fish-related, at any rate =)

[17:59] <jnthn> :D

[17:59] <arnsholt> (And the all-capsing of COD as an abbreviation triggers all-caps TORSK on the Swedish side, of course)

[18:01] <arnsholt> In fact, I think I'll show this one to my students on Friday ^_^

[18:03] <sorear> What do you teach?

[18:04] *** gtodd left
[18:04] <arnsholt> Introduction to comp.ling./NLP

[18:05] <arnsholt> (IIRC the official title is introduction to language technology)

[18:05] <arnsholt> And I talked about SMT last friday, so it's pretty relevant to what I've taught recently. And this lecture is the sum-stuff-up lecture, anyways

[18:06] *** gtodd joined
[18:06] <masak> arnsholt: oh, that's wonderful :)

[18:07] <masak> arnsholt: and it makes perfect sense.

[18:07] <masak> arnsholt: I hope in 20 years we'll have a translator algorithm that will literally laugh at GT for being so silly. ;)

[18:07] <arnsholt> We can hope ;)

[18:07] <arnsholt> 20 years is far enough into the future that it's hard to guess what's possible, anyways =)

[18:08] <sorear> "hi.  while translating your manuscript into German I found a way to radically simplify the proof of theorem 4.6"

[18:09] <colomon> "And I think theorem 4.7 might be wrong..."

[18:09] <arnsholt> Heh. Is that an actual thing that's happened, or conjecture? =)

[18:09] <sorear> arnsholt: no, we don't have AGI at that level yet

[18:10] <TimToady> The state of machine translation in 20 years will be that the meat is rotten, but the booze is holding out. :)

[18:10] <arnsholt> Yeah. Figured it might have come from a human translator at some point =)

[18:10] <arnsholt> TimToady: =D =D =D

[18:11] <arnsholt> The lectures from last year (written by my advisor) had a variant on that, but I cut it from my slides, sadly =)

[18:11] *** rindolf joined
[18:11] <dalek> specs: 3320ccb | larry++ | S03-operators.pod:

[18:11] <dalek> specs: distinguish structural unaries by 'is nodal' trait

[18:11] <dalek> specs: 

[18:11] <dalek> specs: People naturally expect structural unaries like subscripts to be flat

[18:11] <dalek> specs: but non-structural unaries to recurse when hypered.  The best place to

[18:11] <dalek> specs: hang this info is on the top-level function/method/proto that will be

[18:11] <dalek> specs: passed to the hyper controller as object representing the operation

[18:11] <dalek> specs: in question.  Subscripts and methods like .values are considered

[18:11] <dalek> specs: "nodal".  For static functions on static shapes of known type, this

[18:11] <dalek> specs: enables compile-time knowledge of what can be sent to the GPU.

[18:11] <dalek> specs: 

[18:11] <dalek> specs: Fixes #42

[18:11] <dalek> specs: review: https://github.com/perl6/specs/commit/3320ccbb61

[18:12] <TimToady> there it is, finally...

[18:12] <PerlJam> dalek: had to read it and understand it first.

[18:12] <PerlJam> s/://

[18:13] <TimToady> TCF?

[18:13] <sorear> arnsholt: closest case I know of is the Titius-Bode law one

[18:14] *** lizmat joined
[18:14] <sorear> https://en.wikipedia.org/wiki/Titius-Bode_law#History p. 2-3

[18:15] *** ajr joined
[18:15] *** ajr is now known as Guest20215

[18:16] <arnsholt> sorear: Neat. Didn't know about that one!

[18:17] *** gcole joined
[18:20] *** stevan_ left
[18:28] *** thou left
[18:31] <masak> TimToady++ # nodality

[18:34] <dalek> perl6-roast-data: 02e44a5 | coke++ | / (4 files):

[18:34] <dalek> perl6-roast-data: today (automated commit)

[18:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/02e44a5523

[18:36] *** domidumont left
[18:37] <[Coke]> niecza has been dirty for 294 days. pugs has been dirty for 3 days. rakudo has been dirty for 3 days.

[18:37] <TimToady> nr: (1,2,3).:<[+]>.say

[18:37] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/7iDxACw3kN:1␤------> [32m(1,2,3).:[33m⏏[31m<[+]>.say[0m␤»

[18:37] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Colonpair dotties NYI at /tmp/uoLg6yFGDT line 1:␤------> [32m(1,2,3).:<[+]>[33m⏏[31m.say[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza…

[18:37] <[Coke]> rakudo failures have changed. niecza is much improved. someone is killing pugs.

[18:38] <sorear> niecza is improving?

[18:38] <diakopter> spec regression? :)

[18:38] <[Coke]> sorear: colomon is fudging and fixing, yes.

[18:39] <[Coke]> down to 35 failures, from 182 yesterday.

[18:41] <TimToady> nr: (1,2,3).&prefix:<[+]>.say

[18:41] <camelia> niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'prefix:<[+]>' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤ …

[18:41] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    &prefix:<[+]> used at line 1␤␤»

[18:44] <TimToady> nr: (1,2,3).reduce(&[+]).say

[18:44] <camelia> rakudo a4c8c5, niecza v24-40-g31f36d2: OUTPUT«6␤»

[18:44] <colomon> sorear: I started feeling guilty about working on automatically smoke testing the Rakudo ecosystem while ignoring the routine Niecza fails [Coke] was reporting every day.  :)

[18:45] <sorear> colomon++

[18:45] <colomon> sorear: though a lot of it is just that my $work has been incredibly dreary the last few weeks.

[18:45] <sorear> aww.

[18:45] * TimToady occasionally wishes for shorter postfix reduction sugar when working on RC solutions that are largely left-to-right

[18:46] <moritz> nr: say 1, 2, 3 ==> &[+]

[18:46] <camelia> niecza v24-40-g31f36d2: OUTPUT«123␤Unhandled exception: Feed ops NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 1504 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3447 (infix:<==>> @ 4) ␤  at /tmp/YpAiU3ZybZ line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[18:46] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/HqUzS3bAyu:1␤------> [32msay 1, 2, 3 ==> &[+][33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[18:47] <moritz> r: 1, 2, 3 ==> [+]

[18:47] <camelia> rakudo a4c8c5:  ( no output )

[18:47] <moritz> r: 1, 2, 3 ==> [+] ==> say

[18:47] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix ==> instead␤at /tmp/TGPYBfDCLC:1␤------> [32m1, 2, 3 ==> [+] ==>[33m⏏[31m say[0m␤»

[18:47] *** alester joined
[18:48] <TimToady> r: 1, 2, 3 ==> [+]() ==> say

[18:48] <camelia> rakudo a4c8c5: OUTPUT«6␤»

[18:48] <TimToady> r: 1, 2, 3 ==> ([+]) ==> say

[18:48] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/siTeIx_LHv:1␤------> [32m1, 2, 3 ==> ([+]) ==> say[33m⏏[31m<EOL>[0m␤    expecting any of:␤        argument list␤        postfix␤»

[18:49] <moritz> r: 1, 2, 3 ==> infix:<+> ==> say

[18:49] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix ==> instead␤at /tmp/Cfs22VMnMl:1␤------> [32m1, 2, 3 ==> infix:<+> ==>[33m⏏[31m say[0m␤»

[18:49] <moritz> r: 1, 2, 3 ==> say

[18:49] <camelia> rakudo a4c8c5: OUTPUT«1 2 3␤»

[18:49] <moritz> r: 1, 2, 3 ==> infix:<+>

[18:49] <camelia> rakudo a4c8c5:  ( no output )

[18:49] <moritz> r: say(1, 2, 3 ==> infix:<+>)

[18:49] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in argument list; couldn't find final ')'␤at /tmp/zuDNTmCYRQ:1␤------> [32msay(1, 2, 3 [33m⏏[31m==> infix:<+>)[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤»…

[18:49] * moritz gives up

[18:52] <diakopter> r: say 1, 2, 3 ==> &infix:<+>

[18:52] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/TOOPjOUSaf:1␤------> [32msay 1, 2, 3 ==> &infix:<+>[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[18:52] <dalek> niecza: 69a3432 | (Solomon Foster)++ | lib/CORE.setting:

[18:52] <dalek> niecza: Implement respectable version of Hash.ACCEPTS.

[18:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/69a3432d22

[18:52] *** thou joined
[18:52] <TimToady> note that say is tighter than ==>

[18:53] *** japhb_ joined
[18:53] <TimToady> and in any case, the pointy end of ==> wants something variadic

[18:55] <TimToady> r: say (1,2,3 ==> &prefix:<[+]>)

[18:55] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/aslS2jON63:1␤------> [32msay (1,2,3 ==> &prefix:<[+]>[33m⏏[31m)[0m␤    expecting any of:␤        postfix␤»

[18:55] <TimToady> r: say (1,2,3 ==> prefix:<[+]>)

[18:55] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    prefix:<[+]> used at line 1. Did you mean '&prefix:<+>', '&prefix:<++>', '&prefix:<+^>'?␤␤»

[18:55] <diakopter> r: say (1,2,3 ==> [&prefix:<+>])

[18:55] <camelia> rakudo a4c8c5: OUTPUT«prefix:<+> 1 2 3␤»

[18:56] <diakopter> heh.

[18:56] <TimToady> r: say (1,2,3 ==> [&infix:<+>])

[18:56] <camelia> rakudo a4c8c5: OUTPUT«infix:<+> 1 2 3␤»

[18:56] *** bluescreen100 joined
[18:56] <jnthn> If the final thing is an array it pushes onto it :)

[18:57] *** bluescreen10 left
[18:57] *** thou left
[18:57] <jnthn> More typically you write ... ==> my @a; :)

[18:57] <masak> r: sub plus(*@v) { [+] @v }; say (1, 2, 3 ==> &plus)

[18:57] <TimToady> but that should maybe be parsing as a reduction, not a composer?

[18:57] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/36T977i8hw:1␤------> [32m(*@v) { [+] @v }; say (1, 2, 3 ==> &plus[33m⏏[31m)[0m␤    expecting any of:␤        postfix␤»

[18:57] <masak> r: sub plus(*@v) { [+] @v }; say (1, 2, 3 ==> plus)

[18:57] <camelia> rakudo a4c8c5: OUTPUT«6␤»

[18:57] <masak> \o/

[18:58] <jnthn> TimToady: oh, hmm

[18:58] <jnthn> TimToady: I dunno if Rakudo does the [&foo] case of reduction yet.

[18:58] *** sqirrel left
[18:58] <TimToady> nr: [&infix:<+>] 1,2,3

[18:58] <camelia> niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/Hhe9Sv4lF4 line 1:␤------> [32m[&infix:<+>] [33m⏏[31m1,2,3[0m␤␤Parse failed␤␤»

[18:58] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/PjEIZg25Qt:1␤------> [32m[&infix:<+>] [33m⏏[31m1,2,3[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement modifier␤        st…

[18:59] <jnthn> std: [&infix:<+>] 1,2,3

[18:59] <camelia> std b33d8e0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/5VqsJvXb2R line 1:␤------> [32m[&infix:<+>] [33m⏏[31m1,2,3[0m␤    expecting any of:␤       infix or meta-infix␤    infixed function␤       statement modifier loop␤Parse

[18:59] <camelia> ..failed␤F…

[18:59] <TimToady> hmm

[18:59] <jnthn> Hm, even STD doesn't recognize that one. :)

[18:59] <colomon> n: say 1e0 .. 1e0

[18:59] <camelia> niecza v24-40-g31f36d2: OUTPUT«1e0..1e0␤»

[18:59] <TimToady> nr: [&(*+*)] 1,2,3

[18:59] <camelia> rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/P8BnCl9eW6:1␤------> [32m[&(*+*)] [33m⏏[31m1,2,3[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement modifier␤        statem…

[18:59] <camelia> ..niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/b5rs468vgW line 1:␤------> [32m[&(*+*)] [33m⏏[31m1,2,3[0m␤␤Parse failed␤␤»

[19:00] <TimToady> nr: [&[+]] 1,2,3

[19:00] <camelia> niecza v24-40-g31f36d2: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/TcEoqfJ6Ri line 1:␤------> [32m[&[+]] [33m⏏[31m1,2,3[0m␤␤Parse failed␤␤»

[19:00] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/Aot5CXctge:1␤------> [32m[&[+]] [33m⏏[31m1,2,3[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement modifier␤        statemen…

[19:03] <dalek> rakudo/jvm-support: ad71045 | moritz++ | src/core/Str.pm:

[19:03] <dalek> rakudo/jvm-support: fix argument type of :$where in Str.wordcase

[19:03] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/ad71045014

[19:03] <dalek> rakudo/jvm-support: a4c8c57 | moritz++ | tools/build/NQP_REVISION:

[19:03] <dalek> rakudo/jvm-support: bump NQP revision to get fix for RT #117889

[19:03] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/a4c8c57669

[19:03] <dalek> rakudo/jvm-support: 29d5cbe | jnthn++ | / (2 files):

[19:03] <dalek> rakudo/jvm-support: Merge branch 'nom' into jvm-support

[19:03] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/29d5cbee10

[19:03] <Util> #parrotsketch (network irc.perl.org) meeting in 27 minutes. GSoC proposals will be discussed. (Including "JavaScript backend for NQP&Rakudo")

[19:03] *** thou joined
[19:08] <colomon> rn: my $a = Any; say 1..$a;

[19:08] <camelia> niecza v24-42-g69a3432: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1356 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 294 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.s…

[19:08] <camelia> ..rakudo a4c8c5: OUTPUT«use of uninitialized value of type Any in numeric context  in block  at /tmp/2YQuNE4M4A:1␤␤1..0␤»

[19:09] <colomon> rn: my $a = Any; say (1..$a).perl;

[19:09] <camelia> rakudo a4c8c5: OUTPUT«use of uninitialized value of type Any in numeric context  in block  at /tmp/nbYdZlmhnj:1␤␤1..0␤»

[19:09] <camelia> ..niecza v24-42-g69a3432: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1356 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 294 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.s…

[19:11] <FROGGS> jnthn: do you have time now? (I promise it won't take to long :o)

[19:11] <TimToady> nr: [&(&[+])] 1,2,3

[19:11] <camelia> niecza v24-42-g69a3432: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/w5nPflTWkx line 1:␤------> [32m[&(&[+])] [33m⏏[31m1,2,3[0m␤␤Parse failed␤␤»

[19:11] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/XfS0HSkWqn:1␤------> [32m[&(&[+])] [33m⏏[31m1,2,3[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement modifier␤        state…

[19:11] <dalek> roast: 6e3ee4d | (Solomon Foster)++ | S0 (6 files):

[19:11] <dalek> roast: Unfudge tests for Niecza.

[19:11] <dalek> roast: review: https://github.com/perl6/roast/commit/6e3ee4daa2

[19:12] <jnthn> FROGGS: Yes :)

[19:13] <FROGGS> cool

[19:13] <FROGGS> so, we have a per-package symbol table ($package.WHO)

[19:13] *** census joined
[19:13] <jnthn> Yes.

[19:13] <FROGGS> which is a hash, key is the longname of the var/sub, value is its, well, "value"

[19:14] <jnthn> Well, var/sub/type/constant/whatever :)

[19:14] <jnthn> it's actually a Stash

[19:14] <jnthn> r: say (package foo { }).WHO.WHAT

[19:14] <camelia> rakudo a4c8c5: OUTPUT«(Stash)␤»

[19:14] <moritz> but Stash isa Hash :-)

[19:14] <jnthn> r: say (package foo { }).WHO.^mro

[19:14] <camelia> rakudo a4c8c5: OUTPUT«(Stash) (Hash) (EnumMap) (Iterable) (Cool) (Any) (Mu)␤»

[19:14] <jnthn> Which is a kind of Hash with diddles. :)

[19:14] <FROGGS> k, so it behaves like a hash

[19:14] <FROGGS> diddles O.o?

[19:14] <FROGGS> okay, I'll read what a stash is later

[19:14] <jnthn> I think it overrides at_key for some reason

[19:14] <jnthn> Just look at Stash.pm.

[19:15] <FROGGS> will do

[19:15] <jnthn> Though I think it has an extra method in jvm-support branch

[19:15] <FROGGS> so, in perl5, there is a bit more within the symbol table, for example the package from where a variable was imported

[19:15] <timotimo> i've read somewhere that putting lots of hashes into your compiler or runtime guarantees for bad performance. does rakudo or nqp have that problem?

[19:15] <FROGGS> package-name

[19:15] <TimToady> nr: say [[&infix:<+>]] 1,2,3

[19:16] <camelia> niecza v24-42-g69a3432: OUTPUT«6␤»

[19:16] <camelia> ..rakudo a4c8c5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in bracketed infix; couldn't find final ']'␤at /tmp/qs9aGp9G3I:1␤------> [32msay [[&[33m⏏[31minfix:<+>]] 1,2,3[0m␤»

[19:16] <jnthn> Adding the name is probably easy.

[19:17] <FROGGS> and, in perl5 the key is not the longname, but the desigilname, so $var, %var, @var and &var are stored within the same slot for some reason

[19:17] <jnthn> Why does it track where things were imported from?

[19:17] <FROGGS> I dont think we actually want/need that, but just wanted to say

[19:17] <jnthn> I'm pretty sure we should not be storing them under the desigilname in Perl 6. :)

[19:17] <jnthn> timotimo: Well, package lookups at runtime are not an especially common case.

[19:17] <FROGGS> jnthn: redeclaration of symbol X, it was already imported from Y or similar

[19:18] <FROGGS> so, now my questions:

[19:18] * jnthn isn't sure he gets the redeclaration issue; either it's the same thing, or it's a different thing. :)

[19:18] <timotimo> jnthn: and lexical variables are looked up more cleverly through lexpads?

[19:18] <jnthn> timotimo: Lexpads on Parrot are hash-based, but it can optimize things in the current block to a register access.

[19:19] <timotimo> i suppose the lookup is made at compiletime and a more direct kind of access?

[19:19] <timotimo> ah, okay

[19:19] <jnthn> timotimo: The JVM impl is smarter and resolves most things to an index.

[19:19] <FROGGS> why it is a problem to do the autovivify thing for our-vars, and add the lookups properly?

[19:19] <jnthn> What is "the auto-vivifying thing"?

[19:19] <FROGGS> r: our @var; say @var.WHAT

[19:19] <camelia> rakudo a4c8c5: OUTPUT«(Any)␤»

[19:20] <jnthn> At the moment, though, I suspect that a Stash does the same kind of auto-viv as a nomrla Hash.

[19:20] <jnthn> I mean, if you do

[19:20] <FROGGS> err, it doesnt do that yet...

[19:20] <jnthn> Sure it does

[19:20] <FROGGS> hold on, I'll grab for the right word

[19:20] <jnthn> r: my %h; say %h<@a>.WHAT

[19:20] <camelia> rakudo a4c8c5: OUTPUT«(Any)␤»

[19:21] <jnthn> I think what probably *should* happen is that, at compile time, we install the correct kind of container (be it scalar, array, or hash)

[19:22] <jnthn> Just like we do for lexicals.

[19:22] <FROGGS> here: if I declare a my-var, it reifies correctly

[19:22] <FROGGS> so, I've stolen this code, and it reifies correctly to an array or hash so I can assign to it when declaring

[19:23] <FROGGS> but for this, I have to comment out the symbol lookup code

[19:23] *** thou left
[19:23] <FROGGS> Perl6::Actions line 1924 that is

[19:23] <jnthn> And you'll probably also find that you have turned it into a lexical, and it's not stored in the package. :)

[19:24] <FROGGS> ya, looks like

[19:25] <jnthn> I think that what needs to happen at block entry is just binding the lexical to the thing in the package, so it's a lexical alias to the thing in the package.

[19:25] <jnthn> I think we may even do that bit today

[19:25] <jnthn> The missing piece is that we don't install anything in the package at compile time.

[19:25] <FROGGS> ya, my last patch just installed something at a place from what I thought it is the package

[19:25] <FROGGS> right?

[19:26] *** thou joined
[19:26] <jnthn> Um, where is your last patch?

[19:28] <FROGGS> talking about this commit: https://github.com/rakudo/rakudo/commit/ffe441fa9cccb550f21f65a0b5ecd602f226b166

[19:28] <jnthn> oh

[19:28] <FROGGS> so, I have to put it in $package.WHO, and add the reify-code to the place called $pkg there?

[19:28] <jnthn> That patch looks like a confusion of compile time and runtime.

[19:29] <jnthn> No, you should not be generating code to do anything other than binding the lexical to the container in the package.

[19:29] <jnthn> The container should be installed in the package at compile time.

[19:29] <jnthn> Into $*PACKAGE.WHO

[19:29] <jnthn> Like install_lexical_container installs into the lexpad at compile time. The difference being that lexpads clone those per entry, whereas there's only one package.

[19:30] <jnthn> r: package Foo { { our $x = 42; }; say $x }

[19:30] <camelia> rakudo a4c8c5: OUTPUT«42␤»

[19:30] <jnthn> That is *wrong*.

[19:30] <jnthn> And I think ffe441f is to blame.

[19:30] <FROGGS> why is that wrong?

[19:31] <jnthn> Because $x is not in scope there.

[19:31] <moritz> because $x is just a lexical alias to $Foo::x

[19:31] <jnthn> our declares a *lexical* alias.

[19:31] <moritz> and the lexical isn't allowed to leak from its scope

[19:31] *** thou left
[19:31] * moritz is surprised we don't have a spectest for that

[19:32] <FROGGS> so only this is allowed to work? package Foo { { our $x = 42; }; say $Foo::x }

[19:32] <moritz> yes

[19:32] <FROGGS> ahh

[19:33] <FROGGS> I always thought I dont need to prefix the package-name I'm in

[19:34] <TimToady> I believe it's currently specced that the = 42 happens at INIT time

[19:34] <moritz> p5eval: use strict; { our $x = 5 }; print $x

[19:34] <p5eval> moritz: ERROR: Global symbol "$x" requires explicit package name at (eval 7) line 3.

[19:34] <moritz> even p5 does it with lexical aliases

[19:35] <FROGGS> O.o

[19:35] <FROGGS> okay

[19:35] <TimToady> and if we allow initializers on 'our', we should probably warn if some location is initialized to two different values

[19:37] <jnthn> Should multiple "our $x" declarations warn?

[19:37] <jnthn> (even without an initializer)?

[19:37] <TimToady> no, I don't think so

[19:37] <dalek> rakudo/nom: 37c7620 | (Tobias Leich)++ | src/core/Cursor.pm:

[19:37] <dalek> rakudo/nom: dont't treat array references as arrays in regexes

[19:37] <dalek> rakudo/nom: 

[19:37] <dalek> rakudo/nom: They will be stringified instead, and must be dereferenced to be arrayish.

[19:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/37c7620bd6

[19:37] <moritz> r: my $x; my $x

[19:37] <camelia> rakudo a4c8c5: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/s_kBIlWPRK:1␤    ------> [32mmy $x; my $x[33m⏏[31m<EOL>[0m␤»

[19:37] <jnthn> Actually it's not clear to me how to warn for the initializer but not for the declaration.

[19:37] <TimToady> well, two our in the same scope, sure

[19:38] <TimToady> std: our $x; our $x

[19:38] <camelia> std b33d8e0: OUTPUT«ok 00:00 42m␤»

[19:38] <TimToady> well, maybe not :)

[19:38] <jnthn> :)

[19:39] <FROGGS> I think I have enough information to go ahead...

[19:39] <FROGGS> thanks, y'all

[19:40] <TimToady> our $x; INIT { $x.defined and $x !=== 42 and warn "\$x initialized to both $x and 42"; $x = 42 }

[19:40] <TimToady> something like that

[19:41] <jnthn> Needs care if the initializer has side-effects, but yes

[19:42] <TimToady> or less LTA "42 overrides previously initialized value of $x"

[19:42] <FROGGS> but that is obvious, 42 overrides everything

[19:42] <TimToady> you have a tremendous grasp of the obvious :)

[19:43] <FROGGS> *g*

[19:46] <FROGGS> TimToady: why does p5 have this (in my eyes weird) symbol table? is it because of the sigil-changing nature of p5?

[19:48] * ingy *grasps* for air

[19:48] <TimToady> partly that, and partly a premature space optimization

[19:48] <dalek> nqp/rak-jvm-support: d37930f | jnthn++ | src/vm/parrot/ (2 files):

[19:48] <dalek> nqp/rak-jvm-support: Turn various lexical lookups into nqp:: ops.

[19:48] <dalek> nqp/rak-jvm-support: 

[19:48] <dalek> nqp/rak-jvm-support: These were Perl 6 ops before, but aren't really Perl 6 specific and

[19:48] <dalek> nqp/rak-jvm-support: probably would be easier to optimize here.

[19:48] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/d37930ffe2

[19:48] <FROGGS> k, thanks

[19:49] <TimToady> also some early operators mistakenly related values with the same desigilname

[19:50] <moritz> open FOO;

[19:50] <moritz> (short for open FOO, $FOO)

[19:50] <TimToady> like that, yeah

[19:51] <FROGGS> moritz: that is exactly the point where I hit this weirdness lately

[19:51] <FROGGS> you pass a thing called filehandle to open, which is (so I have learned) a reference to the symbol table entry

[19:52] <moritz> iirc you can also do   push a, 42;  and have it automatically push to @a

[19:52] <FROGGS> but this symbol table entry can contain the other vars of the same desigilname as well

[19:52] <TimToady> which is why sometimes it's hard to tell the difference between FOO and *FOO

[19:52] *** berekuk left
[19:52] <FROGGS> and I have to support that these days >.<

[19:52] <moritz> p5eval: push a, 42; \@a

[19:52] <p5eval> moritz: [42]

[19:52] <FROGGS> ohh man

[19:53] <moritz> but that warns iin my environment

[19:53] <TimToady> obviously it means the array, since you're doing a push :)

[19:53] <FROGGS> hehe, yeah

[19:53] * TimToady was differently stupid back then

[19:53] * FROGGS .oO( and there is this 42 again..., obviously... )

[19:54] *** berekuk joined
[19:54] * TimToady wonders why they skipped 5 and just use 2, 3, and 7...

[19:56] * FROGGS scratches his chin but can't make sense of that

[19:56] <moritz> r: say [*] 2, 3, 7

[19:56] <camelia> rakudo a4c8c5: OUTPUT«42␤»

[19:57] <FROGGS> ohh

[19:57] <moritz> r: say (^8).grep: *.is-prime

[19:57] <camelia> rakudo a4c8c5: OUTPUT«2 3 5 7␤»

[19:57] * FROGGS takes his nerd-badge off

[20:00] <PerlJam> .oO( We don't need no stinkin' badges! )

[20:03] *** kaare_ left
[20:07] *** Rix left
[20:08] *** lizmat left
[20:08] <cognominal> In a grammar  with the appropriate braid set, why could not use  <Regex.Nibler> as a short for <.LANG('Regex','nibbler')> ?  Is there already a meaning for that syntax?

[20:09] <jnthn> LANG is quite coupled to having a %*LANG. It's not part of Cursor itself; it's part of the compiler infrastructure that comes from HLL::Grammar.

[20:10] <jnthn> If you just want to call a rule in another grammar, there is <GrammarName::rulename> iirc

[20:10] *** Rix joined
[20:10] <cognominal> yes, that why I talked of braid.

[20:11] <cognominal> So why using %*LANG if there is already another syntax?

[20:13] <cognominal> what is the benefit, except possibly overriding %*LANG deeper in the grammar, which is not done as far I understand

[20:13] *** domidumont joined
[20:13] <cognominal> anyway, having <.LANG(…)> is already nice.

[20:13] <colomon> rn: say 'b' ~~ %( a => 1, b => 0)

[20:14] <camelia> rakudo 37c762, niecza v24-42-g69a3432: OUTPUT«True␤»

[20:16] <TimToady> does <GrammarName::rulename> rebless the cursor into the other grammar?

[20:16] <jnthn> cognominal: %*LANG is about the actions

[20:16] <TimToady> if not, it could have surprising dispatches internally

[20:16] <jnthn> TimToady: rebless doesn't really make sense, but it does create a cursor of the correct type, yes.

[20:16] <TimToady> what I meant

[20:16] <jnthn> Yeah :)

[20:16] *** thou joined
[20:17] <TimToady> "the cursor" makes about as much sense as "the electron" does in QM

[20:17] <jnthn> :)

[20:18] <dalek> roast: 731db03 | jnthn++ | S32-io/io-path- (2 files):

[20:18] <dalek> roast: Fix fudging of IO::Path tests.

[20:18] <dalek> roast: 

[20:18] <dalek> roast: It is io-path-unix.t that has hangs on Windows, not io-path-win.t.

[20:18] <dalek> roast: review: https://github.com/perl6/roast/commit/731db030aa

[20:19] <jnthn> labster: Please see 731db03 when you get chance; seems I miscommunicated what was hangin' on Win32 yesterday.

[20:19] <jnthn> labster: I fudged the exact two that hang.

[20:19] <dalek> rakudo/jvm-support: 70f1e4e | jnthn++ | src/Perl6/Actions.nqp:

[20:19] <dalek> rakudo/jvm-support: Start refactoring $_ handling.

[20:19] <dalek> rakudo/jvm-support: 

[20:19] <dalek> rakudo/jvm-support: This refactors the routine case, but not the general block case. The

[20:19] <dalek> rakudo/jvm-support: aim is to eliminate special casing of $_ in Perl6Lexpad.

[20:19] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/70f1e4e621

[20:19] <dalek> rakudo/jvm-support: c17d5bd | jnthn++ | src/ (3 files):

[20:19] <dalek> rakudo/jvm-support: Switch to use new nqp:: ops.

[20:19] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/c17d5bdd88

[20:20] <labster> Oh.  Thanks.  Actually, you communicated it right, I just did it wrong.

[20:20] <dalek> rakudo/jvm-support: cff67a3 | jnthn++ | src/vm/parrot/ops/perl6.ops:

[20:20] <dalek> rakudo/jvm-support: Elimiante dynops moved to NQP level.

[20:20] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/cff67a38e2

[20:20] <jnthn> labster: ah, ok. I was so tired after the travel yesterday... ;)

[20:20] <jnthn> Assume dit was me. :)

[20:21] <labster> I investigated the cause, and then fudged, so I forgot what I was doing, I guess.

[20:21] <colomon> \o/

[20:21] <[Coke]> colomon?

[20:22] <colomon> [Coke]: just excited to see jnthn++ hard at work.  :)

[20:22] <labster> jnthn: since I have your attention, can a fellow get a commit bit to rakudo?

[20:23] <labster> I sent in the CLA last month.

[20:23] *** Guest20215 is now known as ajr

[20:23] <[Coke]> .seen allison?

[20:23] <yoleaux> I haven't seen allison? around.

[20:23] <[Coke]> .seen allison

[20:23] <yoleaux> I haven't seen allison around.

[20:23] <pmichaud> labster: commitbit coming up

[20:23] <moritz> labster: jnthn already approved via email; now somebody (I think pmichaud) just has to actually give you one

[20:23] *** ajr is now known as Guest58766

[20:23] <moritz> I don't think I have the permissions

[20:24] <cognominal> pmichaud, jnthn, so, if I want to use some NQP grammar rules and their associated actions in my own language, do I have do do something else between setting the braid by updating LANG in the TOP rule and calling them using <.Lang('NQP', 'somerulename')>  ?

[20:24] <cognominal> s/language/grammar/

[20:24] <pmichaud> moritz: I'm pretty sure you have permissions... could you go ahead and grant the commitbit to verify that you do?

[20:24] <cognominal> ...and importing NQPHLL

[20:25] *** Guest58766 left
[20:25] <cognominal> s/between/besides/

[20:26] <pmichaud> cognominal: I don't know.  I don't know that anyone has tried to use the NQP rules from another language.

[20:26] *** ajr_ joined
[20:28] <pmichaud> inheriting from HLL::Grammar and HLL::Actions is pretty standard, but haven't tried using the NQP equivs yet.

[20:28] <cognominal> NQP already uses Regex rules, but that's a little different.

[20:29] *** domidumont left
[20:30] <grondilu> rn: (my @A)[0] = *; @A[2] := (@A[0,1]); @A[0] = "foo"; say @A[2];  # trying to put intra-array references in an array

[20:30] <camelia> rakudo 37c762, niecza v24-42-g69a3432: OUTPUT«foo (Any)␤»

[20:30] * grondilu is amazed this actually works

[20:34] <jnthn> cognominal: LANG requies that %*LANG has an entry for the thing you want to switch to.

[20:34] <cognominal> yes, I know that

[20:34] <jnthn> %*LANG<NQP> := nqp::getcomp('nqp').parsegrammar; # or so may do it

[20:35] <jnthn> And similar for NQP-actions

[20:36] <cognominal> so          %*LANG<MAIN>          := NQP::Grammar;     will not be sufficient

[20:36] <jnthn> Well, that makes your main language be NQP

[20:36] <cognominal> oops I meant

[20:36] <jnthn> I don't think you have NQP::Grammar in scope.

[20:36] <cognominal> so          %*LANG<NQP>          := NQP::Grammar;     will not be sufficient

[20:36] <jnthn> That'd be a confusion of running compiler and running program.

[20:36] <jnthn> Which we musn't do, otherwise we are in epic trouble for bootstrapping :)

[20:37] <pmichaud> well, *we* can't do it because of bootstrapping, but other languages aren't bootstrapping :)

[20:38] <jnthn> pmichaud: Oh, sure, just explaining why NQP::Grammar ain't automatically in scope.

[20:38] <pmichaud> right.

[20:38] <jnthn> Unfortunately you can't just "use NQP" either to get them.

[20:38] <cognominal> that's for my AST  generating language. But I think the rule I will use is pretty safe except if the user type :$a

[20:38] <pmichaud> when a compiler for XYZ is running, the NQP compiler isn't automatically loaded.  It'd have to be use'd or otherwise loaded first.

[20:39] <jnthn> Well, you can in another compiler probably...

[20:39] <cognominal> in that case it will need the context to find a variable.

[20:39] <jnthn> If you're pre-compiling.

[20:39] *** Moukeddar joined
[20:39] <cognominal> …and that's the problem jnthn describes

[20:39] <Moukeddar> o/ #perl6

[20:42] <masak> Moukeddar! \o/

[20:46] <sorear> o/

[20:51] <cognominal> jnthn, for your trick to work, I would need to write  a modified compunit that receive as parameter the rule to call.  statmenlist in the case of nqp, and colonpair in my cade.

[20:51] <cognominal> jnthn, thx you, you helped very much

[21:01] *** skids left
[21:05] *** Subterra is now known as Kelder

[21:06] <dalek> rakudo/jvm-support: deba5d3 | jnthn++ | src/Perl6/ (2 files):

[21:06] <dalek> rakudo/jvm-support: Another step on the $_ cleanups.

[21:06] <dalek> rakudo/jvm-support: 

[21:06] <dalek> rakudo/jvm-support: This should mean that the code path for a null $_ in Perl6Lexpad PMC

[21:06] <dalek> rakudo/jvm-support: is never hit. Seems we get one test failure from this.

[21:06] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/deba5d357d

[21:06] <dalek> rakudo/jvm-support: 210d023 | jnthn++ | src/ (6 files):

[21:06] <dalek> rakudo/jvm-support: Eliminate Perl6Lexpad PMC's magical $_ handling.

[21:06] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/210d02335e

[21:06] <dalek> rakudo/jvm-support: 4855dd8 | jnthn++ | src/Perl6/World.nqp:

[21:06] <dalek> rakudo/jvm-support: Fix POST block regression.

[21:06] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/4855dd8526

[21:09] <jnthn> TimToady: For S12's interface consistency section, do we just want to make sure that leftover named arguments are accepted, or is the creation of a *%_ important?

[21:10] <jnthn> TimToady: That is, what it the default is an anonymous *% parameter?

[21:10] <jnthn> TimToady: This would mean we don't need to actually bind a %_ variable.

[21:10] <pmichaud> jnthn: istr that %_ was only necessary if it was used.

[21:11] <jnthn> pmichaud: I don't see anything in the S12 section that says that

[21:11] <jnthn> pmichaud: Also, what does "used" mean?

[21:11] <pmichaud> used as in "appears in source", I think.

[21:11] <jnthn> That is a good general question for optimization, in fact.

[21:12] <jnthn> method foo() { eval('say %_'); } # what about this, for example...

[21:12] <pmichaud> I'd think that's DIHWIDT.

[21:12] <jnthn> MY::<%_> ?

[21:12] <pmichaud> it's similar to @_ in that respect, I think.

[21:13] <pmichaud> jnthn: S06:327 might be relevant.

[21:13] <jnthn> looking

[21:13] <pmichaud> "depending on whether either or both of those variables are used in the body of the routine.

[21:14] <jnthn> That seems to be about the use of %_ as a placeholder, which I'd considered a different case so far.

[21:14] <jnthn> Well, a usage in the same class as placeholder-y things, anyway.

[21:14] <pmichaud> right, but given

[21:14] <pmichaud>     sub foo { ... }

[21:15] <pmichaud> would foo( :named )    be valid or invalid?

[21:15] <jnthn> Invalid.

[21:15] *** SmokeMachine left
[21:15] <pmichaud> rn: sub foo { ... };   say foo(1);  # checking

[21:15] <jnthn> But for methods .foo(:named) is always valid (modulo "is hidden")

[21:15] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'foo' will never work with argument types (int) (lines 1, 1)␤    Expected: :()␤»

[21:15] <camelia> ..niecza v24-42-g69a3432: OUTPUT«Unhandled exception: >>>Stub code executed␤  at /tmp/dtSWr4mG9M line 1 (foo @ 4) ␤  at /tmp/dtSWr4mG9M line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4329 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4330 (module-CORE @…

[21:15] *** bluescreen100 left
[21:16] <pmichaud> okay... yes, it's different.

[21:16] <jnthn> Trouble is that at the moment we do some...magic...on %_ to try and reduce the cost.

[21:17] <jnthn> But it's (a) ugly, (b) hurts access to %_, and (c) a complete nightmare to port.

[21:17] <jnthn> Whereas I'd prefer to have a way to know to just not bind a %_.

[21:17] <jnthn> S12 seems to want to accept unknown named args, which a *% would do without binding anything.

[21:18] <FROGGS> do we need that too? https://github.com/noidontdig/gitdown

[21:18] <jnthn> We can of course try to catch/simplify this in the optimizer, but it's nice if we don't have to ;)

[21:18] *** donaldh joined
[21:18] <pmichaud> well, if %_ could be created but populating it could be deferred until actually used, that might work okay.  but that might be messy, too.

[21:19] <jnthn> That's effectivley what we do today and it is icky.

[21:19] *** sqirrel joined
[21:19] <pmichaud> how much does it save us?

[21:19] <jnthn> One object allocation per method call...

[21:20] <pmichaud> that's it?

[21:20] <jnthn> Yes.

[21:20] <jnthn> It's every method call, of course.

[21:20] <pmichaud> right, but we already do a lot of allocations.  Not sure one more will hurt.

[21:20] <jnthn> but it costs us an entire extra attribute per QAST::Var node.

[21:20] <jnthn> no, wait

[21:20] <jnthn> That's not true.

[21:20] *** SmokeMachine joined
[21:20] <jnthn> It's an extra entry in the symbol table.

[21:21] <jnthn> Still, it's a little fragile.

[21:21] <jnthn> And it only works at all because all Parrot lexical lookups are, optimization aside through strings. 

[21:21] <jnthn> On the JVM I've no equivalent of the LexPad PMC.

[21:21] <jnthn> And I've no desire to have that.

[21:21] <diakopter> I didn't think we did lots of allocations on method calls

[21:21] <pmichaud> what does the extra attribute per QAST::Var have?

[21:22] <diakopter> oh wait what channel/year is this

[21:22] <jnthn> I misspoke; there isn't one.

[21:22] <pmichaud> okay.

[21:22] <jnthn> It's the :lazyinit thing that goes in the .symbols hash.

[21:22] <jnthn> Which I would also not be sad to lose.

[21:22] <pmichaud> anyway, might be worth removing the %_ optimization and see what hurts.

[21:23] <jnthn> It's kinda hard to keep.

[21:23] <jnthn> I'd rather toss the current one and find a way to win it back through some kind of analysis.

[21:23] <pmichaud> works for me, definitely.

[21:23] <pmichaud> unless toss the current one means we go back to 2010-era slowness.

[21:24] <jnthn> If one extra allocation per method call (until I elimiante it) does that, we're in trouble...

[21:24] <pmichaud> exactly.

[21:24] <pmichaud> anyway, I'm fine with always generating the %_ parameter.  We probably want it for introspection anyway.

[21:24] <jnthn> And maybe TimToady++ will backlog this and decide that *% is enough :)

[21:24] <pmichaud> *% can work too.

[21:25] <pmichaud> I have to go do other stuff for the evening... be back tomorrow

[21:25] <jnthn> OK.

[21:25] <jnthn> I had one other question, but it can wait. 

[21:25] *** gdey joined
[21:26] *** Kelder is now known as Ayiko

[21:32] *** dmol left
[21:35] *** sjohnson left
[21:36] *** sjohnson joined
[21:37] *** kurahaupo joined
[21:38] <ajr_> Which synopsis deals with the "special" variables? (Specifically, any equivalent to $. )

[21:38] <masak> ajr_: S28.

[21:38] <ajr_> Thanks

[21:38] <jnthn> https://raw.github.com/perl6/specs/master/S28-special-names.pod

[21:43] <FROGGS> r: say $.

[21:43] <camelia> rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/RxnCNA26Rb:1␤------> [32msay $[33m⏏[31m.[0m␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤»

[21:44] <FROGGS> you get a hint for some of them:

[21:44] <FROGGS> r: say $@

[21:44] <camelia> rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/pKITiyX4Y3:1␤------> [32msay $[33m⏏[31m@[0m␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤»

[21:44] <FROGGS> hmmm

[21:44] <FROGGS> r: try 'failed!!'; say $@

[21:44] <camelia> rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/MSeonUss8K:1␤------> [32mtry 'failed!!'; say $[33m⏏[31m@[0m␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-prefix␤»

[21:44] <FROGGS> ?

[21:45] <FROGGS> r: try 'failed!!'; say $@;

[21:45] <camelia> rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $@ variable as eval error; in Perl 6 please use $!␤at /tmp/NT_LroV8k3:1␤------> [32mtry 'failed!!'; say $@[33m⏏[31m;[0m␤»

[21:45] <FROGGS> ahh, there you go

[21:45] <FROGGS> r: say $.;

[21:45] <camelia> rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $. variable; in Perl 6 please use the filehandle's .line method␤at /tmp/bfm7owJKNF:1␤------> [32msay $.[33m⏏[31m;[0m␤»

[21:47] <sorear> n: say $.

[21:47] <camelia> niecza v24-42-g69a3432: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Non-declarative sigil is missing its name at /tmp/yvOVlOwK1s line 1:␤------> [32msay [33m⏏[31m$.[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /t…

[21:47] <sorear> n: say $@

[21:47] <camelia> niecza v24-42-g69a3432: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of $@ variable as eval error; in Perl 6 please use $! at /tmp/TXSrlrwQKK line 1 (EOF):␤------> [32msay $@[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[21:48] *** rindolf left
[21:50] *** PacoAir left
[21:57] <ajr_> Is $*IN.input_record_number() NYI ?

[21:58] <flussence> well it's not in rakudo/src anywhere, so it seems not

[21:58] <ajr_> tx

[21:59] *** kurahaupo left
[22:00] <FROGGS> r: say $*IN.^methods

[22:00] <camelia> rakudo 37c762: OUTPUT«open close eof get getc lines read seek tell write opened t print slurp copy chmod Str flush d e f l r s w x z modified accessed changed say <anon> <anon> <anon>␤»

[22:01] *** pmurias_ joined
[22:01] *** pmurias_ left
[22:01] *** pmurias joined
[22:01] <pmurias> jnthn: re %_ read the whole paragraph

[22:02] <jnthn> pmurias: In S12?

[22:02] *** lustlife left
[22:02] *** kurahaupo joined
[22:03] *** Moukeddar left
[22:03] *** mucker left
[22:03] <jnthn> pmurias: I did, a couple of times. I don't see anything that I missed :)

[22:03] <pmurias> I missed the fact that methods accept unspecifed named argument ;)

[22:04] <pmurias> but for subs we should only put the %_ into signature if mentioned

[22:04] <jnthn> Correct; I was just talking about methods here.

[22:05] <jnthn> The sub case is already handled correctly afaik.

[22:05] <jnthn> Well, so is the method case, it's just a matter of optimization/optimizability.

[22:05] <pmurias> is %_ a contextual?

[22:05] <jnthn> No

[22:05] <dalek> rakudo/jvm-support: 7dc4bdc | jnthn++ | src/ (6 files):

[22:05] <dalek> rakudo/jvm-support: Eliminate %_ magic in Perl6LexPad.

[22:05] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/7dc4bdcabd

[22:05] <dalek> rakudo/jvm-support: 1082c07 | jnthn++ | src/Perl6/Actions.nqp:

[22:05] <dalek> rakudo/jvm-support: Elimiante final lazyinit mention.

[22:05] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/1082c07225

[22:06] <pmurias> so we could optimize it away in the absence of eval/MY

[22:06] <pmurias> (if it's not used othewise)

[22:06] <dalek> nqp/rak-jvm-support: 9a087d2 | jnthn++ | src/vm/parrot/QAST/Compiler.nqp:

[22:06] <dalek> nqp/rak-jvm-support: Kill off lazyinit thing we no longer need.

[22:06] <dalek> nqp/rak-jvm-support: 

[22:06] <dalek> nqp/rak-jvm-support: It was always a bit of a hack, anyway.

[22:06] <dalek> nqp/rak-jvm-support: review: https://github.com/perl6/nqp/commit/9a087d2bcf

[22:06] <jnthn> Yeah. We could do with knowing the rules for such things.

[22:07] <jnthn> The pseudo-package usages we can spot without too much trouble.

[22:07] <jnthn> But eval is trickier, especially the method form of it.

[22:08] * jnthn wonders why we have a method form of eval... :)

[22:08] <pmurias> how does it look like?

[22:08] <jnthn> "foo".eval

[22:08] <pmurias> shouldn't we get rid of that? ;)

[22:09] <jnthn> That's a language design question I guess. :)

[22:10] <sorear> %_ is pretty lazy though, does it really cost that much?

[22:10] <sorear> oh, jnthn is removing the lazy %_ optimization?  what?

[22:10] <jnthn> But it's one that needs considering in so far as we already made CALLER:: restricted so we can optimize lexicals away, but not knowing what an eval may happen kinda scuppers that.

[22:10] *** sqirrel left
[22:11] <jnthn> sorear: The optimization was unportable and depended on being able to hook lexical lookups by name.

[22:11] <sorear> let's add a tcl-like uplevel()

[22:11] <sorear> :)

[22:12] <jnthn> sorear: I'd rather do the optimization through realizing %_ is never used 

[22:12] <jnthn> (And turn it into *%)

[22:12] <sorear> jnthn: can't you generate special code for %_ lookups that autovivifies?

[22:12] <jnthn> sorear: I can but...ick.

[22:12] * colomon used the method form of eval sometime in the last week...

[22:12] <jnthn> sorear: Trouble is that it spreads all over. Like, into MY:: and OUTER:: and eval.

[22:12] <sorear> jnthn: You seem to be turning into me.  Stop it. :D

[22:18] <pmurias> jnthn: so with the current language design to optimize away lexicals we will have to determine the possibility of a function/method being eval in disguise?

[22:18] <jnthn> pmurias: Well, that's kinda my question: how do we determine that? I think the answer probably wants to be spec.

[22:19] * sorear doesn't want to rule out the possibility of uplevel()

[22:19] <sorear> though this may fall under "all's fair if you pre-declare"

[22:20] <jnthn> sorear: Yeah. Lexical stuff (like eval) is pretty fine to analyze. It's method-y things that are too late bound.

[22:21] <sorear> jnthn: tcl uplevel(2, "foo") does an eval("foo") in the lexical scope of CALLER::CALLER

[22:21] <pmurias> isn't writing uplevel in speced Perl6 impossible?

[22:21] <jnthn> sorear: oh, my...

[22:21] <jnthn> sorear: I think the rules about CALLER:: and its interaction with anything not marked "is dynamic" already creates "fun" for that one.

[22:22] <jnthn> Though, predeclaration to make everything "is dynamic" could potentially cut it... :)

[22:23] <pmurias> eval ignores "is dynamic" so we might as well have uplevel ;)

[22:23] <masak> 'night, #perl6

[22:23] <diakopter> o/

[22:25] <pmurias> is there much demand for having eval first class? making it syntactical would help with it violating "is dynamic"

[22:30] <diakopter> pmurias: but... how would that help anything? you want the compiler to try to predict what code will end up in it?

[22:32] <diakopter> but if you're saying making it syntactical would merely prevent the &eval symbol from being declared so that the compiler knows when it sees an eval, there's an eval there, that can already be statically determined, or at least conservatively guessed.

[22:33] <sorear> diakopter: cannot be conservatively guessed, unless you want to trigger on everyfunction call

[22:33] <sorear> any function symbol can be rebound to &eval at runtime

[22:33] <diakopter> I was assuming that wouldn't be allowed either

[22:34] <sorear> also, there's an eval method on Str

[22:34] <diakopter> (it wouldn't be a function object)

[22:34] <diakopter> oh yeah.

[22:34] <sorear> so $foo."$method"() might cause an eval

[22:36] <diakopter> oh, I confused myself and my point.. <grr, fail>

[22:39] *** skids joined
[22:43] *** lizmat joined
[22:47] *** ajr_ left
[23:03] <donaldh> jnthn: you have pull request :-)

[23:04] *** Chillance left
[23:05] * donaldh sleeps

[23:06] *** donaldh left
[23:09] * grondilu spent half an hour trying to figure out the silliest error he's made in ages 

[23:10] * TimToady suspects .eval may be in the category of .WHAT

[23:10] <grondilu> So I had an error about a value being "Any", which caused a problem.  So in order to debug, I put a "warn $value.perl if $value ~~ Any;"

[23:10] <grondilu> After half an hour, I realized that Any matches pretty much anything:

[23:11] <jnthn> Oops. Yes.

[23:11] <grondilu> rn: my $x = "foo"; say $x ~~ Any;

[23:11] <camelia> rakudo 37c762, niecza v24-42-g69a3432: OUTPUT«True␤»

[23:11] <diakopter> TimToady: that would help, yes, iiusorearc

[23:11] <labster> r: my $path = "foo/bar".path;  say ~$path ~~  ~$path.perl.eval;  # .perl test

[23:11] <camelia> rakudo 37c762: OUTPUT«True␤»

[23:11] *** berekuk left
[23:12] <TimToady> nr: my $meth = 'WHAT'.  say 42."$meth"()

[23:12] <camelia> niecza v24-42-g69a3432: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/0DR6cE_uzs line 1:␤------> [32mmy $meth = 'WHAT'. [33m⏏[31m say 42."$meth"()[0m␤␤Parse failed␤␤»

[23:12] <camelia> ..rakudo 37c762: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/TtXzw0TXwp:1␤------> [32mmy $meth = 'WHAT'. [33m⏏[31m say 42."$meth"()[0m␤»

[23:12] <TimToady> sigh

[23:13] <diakopter> period as semicolon; giggle

[23:15] *** berekuk joined
[23:15] <TimToady> nr: my $meth = 'WHAT';  say 42."$meth"()

[23:15] <camelia> rakudo 37c762: OUTPUT«No such method 'WHAT' for invocant of type 'Int'␤  in block  at /tmp/OwZ3mB9sgd:1␤␤»

[23:15] <camelia> ..niecza v24-42-g69a3432: OUTPUT«Unhandled exception: Unable to resolve method WHAT in type Int␤  at /tmp/uBId7EI1cC line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4329 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4330 (module-CORE @ 583) ␤  at /home/p…

[23:16] <TimToady> nr: my $meth = 'eval';  say 42."$meth"()

[23:16] <camelia> rakudo 37c762, niecza v24-42-g69a3432: OUTPUT«42␤»

[23:18] <labster> Maybe EVAL should be in capital letters too, as a warning that something is likely to go wrong there.

[23:18] <diakopter> n: my $foo := &goto; hi: $foo('hi')

[23:18] <camelia> niecza v24-42-g69a3432: OUTPUT«(timeout)»

[23:18] <TimToady> I don't mind if we break that

[23:19] <jnthn> TimToady: I could live with .eval being specialer too

[23:20] <diakopter> also, expanded to .EVALUATERATIONISMISTIFICNESSMENTACIOUSLY()

[23:20] <jnthn> TimToady: Should we pick some trait to put on the proto for the eval sub, rather than treating the name "eval" specially?

[23:22] <TimToady> postfix:<.eval>

[23:23] <diakopter> heh

[23:24] *** pmurias left
[23:24] <diakopter> TimToady: I'm sorry to keep asking this (if I have?), but why isn't the language inside postfix:<HERE> a regex slang-ish thing

[23:26] <diakopter> maybe one that disallows whitespace or something, except postcircumfix, which requires one

[23:27] <jnthn> .tell donaldh thanks for the PR; I need to tweak it a bit before I can apply it, as it seems spaces instead of tabs got into the Makefile and the .bat needs updating as well as the .sh runner. Otherwise seems fine...will get to it tomorrow

[23:27] <yoleaux> jnthn: I'll pass your message to donaldh.

[23:27] <jnthn> Sleep time... 'night, #perl6

[23:27] <TimToady> diakopter: I have no idea what you're asking for...

[23:28] <diakopter> a kitchen sink factory generator designer excavator

[23:30] <TimToady> a slang derives an entire language, which comprises many syntactic categories, but it may add methods in any category including postfix

[23:30] <TimToady> but it makes little sense to talk about one category as a slang

[23:30] <sorear> because the language inside <HERE> is a single-quoted quotewords string

[23:30] <diakopter> sorear: :) I know what it is

[23:31] <sorear> if you forbid whitespace in that, you break %hash<a b c>

[23:31] <sorear> which I use fairly often in p5

[23:31] <diakopter> sorear: but yes, I'm wondering why it's that and not prefix:/ this is my pattern for my prefix operator /

[23:32] *** lue joined
[23:32] <sorear> because regexes are code and so not comparable

[23:32] <TimToady> oh, so that's what you mean by 'regex'

[23:32] <TimToady> this was not AT ALL clear

[23:32] <sorear> name suffixes need to be comparable in order for MMD and explicit calling to work

[23:33] <diakopter> but like I said, I suspected I have (or someone had) asked that before, but I just (like always) don't remember the answer

[23:34] <TimToady> all of the :<> :() etc forms are degenerate cases of :foo<> and :bar()

[23:34] <TimToady> and the <> and () are optional in those cases

[23:35] <TimToady> so we can't allow :foo/stuff/

[23:35] <TimToady> since / looks like an infix

[23:35] <TimToady> ergo, :// would have to be a very special case

[23:35] <TimToady> and we try to avoid those, feebly

[23:39] <diakopter> hrm. going out on a twig here.., but

[23:39] <TimToady> and in general, if you really need to pick your quote for some reason, you can do :[ q/stuff/ ]

[23:40] <diakopter> wait what

[23:40] <sorear> TimToady: I think diakopter was suggesting that it literally be a regex, because "is parsed" isn't good enough ?

[23:40] <sorear> not just change the quote to /

[23:40] <diakopter> nod

[23:41] <TimToady> okay, now that I finally know what you mean, I'll have to think about it.  :)

[23:41] <diakopter> I mean, it's a pattern, so..   or at least allow a level of indirection where it can refer to a named pattern

[23:41] <TimToady> what is the use case?

[23:42] <diakopter> family of similar operators

[23:42] <TimToady> that's a noun phrase, not a use case :P

[23:42] <TimToady> what's the verb?

[23:42] <diakopter> eval("family of similar operators")

[23:43] <TimToady> pretend I'm really stupid today

[23:43] <sorear> sub infix:/ '%' \w+ '%' / ($x, $y) { } # emulate R's generic infix syntax

[23:44] <TimToady> oh, you mean in *declarations*

[23:44] <TimToady> you never said that, I was thinking rvalue names

[23:44] *** quietfanatic joined
[23:44] <TimToady> well, I've wanted 'method *' from time to time :)

[23:45] * diakopter adjusts the gamma rays away from Mountain View

[23:45] <diakopter> there, now you can read my mind better

[23:46] <TimToady> this seems like a less powerful feature than supporting macros in syntax categories that can have 'is parsed'

[23:47] <diakopter> also, it might mean the operator's symbol table name isn't identical to its pattern, but has a more descriptive name

[23:47] <TimToady> or maybe 'is reparsed' in this case, so that it doesn't try to parse the <sym> automatically

[23:47] <TimToady> yes, another way of saying what I just said :)

[23:48] <TimToady> like the prefix:reduce rule that is really controlling '[' ~ ']' <infixish>

[23:48] <TimToady> but I'd rather get the generalized macro parsing mechanism hooked up than come up with a low-wattage sugar for some of it

[23:48] <diakopter> while I'm dreaming, could this be how more alternations can be added to [wrapped around?] term in a slang?

[23:49] <TimToady> sub term:<foo> already adds terms, I believe

[23:49] <TimToady> or my \foo

[23:50] <TimToady> but we had other reasons for those bits of sugar

[23:50] <TimToady> nr: sub term:<foo> { 42 }; say foo + 2

[23:50] <camelia> rakudo 37c762, niecza v24-42-g69a3432: OUTPUT«44␤»

[23:51] <TimToady> there you go

[23:51] <TimToady> a new derived grammer with more term: entries

[23:51] <diakopter> well sorta

[23:53] <sorear> r: module Foo {}; BEGIN { for 'a'..'z' -> $l { FOO::EXPORT::DEFAULT::{'&term:<'~$l~'>'} = sub { "$l$l$l" } } }; import Foo; say x

[23:53] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤Could not find symbol '&DEFAULT'␤»

[23:53] <TimToady> the subset of macros that can be parsed that can be thought of as fitting in 'function call' syntax are worth dealing with that way, but we need to be able to write macros that fire off on any category and proceed by 'is parsed'

[23:53] <sorear> r: module Foo {}; BEGIN { for 'a'..'z' -> $l { FOO::EXPORT::{'&term:<'~$l~'>'} = sub { "$l$l$l" } } }; import Foo; say x

[23:53] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤Could not find symbol '&EXPORT'␤»

[23:54] <sorear> r: module Foo {}; BEGIN { for 'a'..'z' -> $l { EXPORT::DEFAULT::{'&term:<'~$l~'>'} = sub { "$l$l$l" } } }; import Foo; say x

[23:54] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤Could not find symbol '&DEFAULT'␤»

[23:54] <sorear> r: module Foo { BEGIN { for 'a'..'z' -> $l { EXPORT::DEFAULT::{'&term:<'~$l~'>'} = sub { "$l$l$l" } } } }; import Foo; say x

[23:54] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤Could not find symbol '&DEFAULT'␤»

[23:56] <diakopter> r: module Foo { BEGIN { for 'a'..'z' -> $l { $EXPORT::DEFAULT::{'&term:<'~$l~'>'} = sub { "$l$l$l" } } } }; import Foo; say q

[23:56] <camelia> rakudo 37c762: OUTPUT«␤»

[23:56] <diakopter> O_O

[23:56] <diakopter> r: say q

[23:56] <camelia> rakudo 37c762: OUTPUT«␤»

[23:56] <diakopter> oh.

[23:57] <sorear> r: module Foo { sub zz is export {}; BEGIN { EXPORT::DEFAULT::{'&term:<a>'} = 1 } }

[23:57] <camelia> rakudo 37c762: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling block  (source text: "{ EXPORT::DEFAULT::{'&term:<a>'} = 1 }"): Error while compiling op p6store (source text: "="): Error while compiling op hllize: Error while compiling op callmethod (source text: …

[23:57] <sorear> i think I may have found a bug

[23:57] <diakopter> :D

[23:57] <diakopter> or 3

[23:57] <sorear> rn: say q

[23:57] <camelia> niecza v24-42-g69a3432: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤No delimiter found at /tmp/dpsFCE7mEl line 1 (EOF):␤------> [32msay q[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[23:57] <camelia> ..rakudo 37c762: OUTPUT«␤»

[23:58] <TimToady> r: say 42 ~ q

[23:58] <colomon> std: say q

[23:58] <camelia> rakudo 37c762: OUTPUT«42␤»

[23:58] <camelia> std b33d8e0: OUTPUT«[31m===[0mSORRY![31m===[0m␤No delimiter found at /tmp/F_zp0DEQzy line 1 (EOF):␤------> [32msay q[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:00 41m␤»

[23:59] <TimToady> well, rakudo doesn't use a quote nibbler quite like std or niecza

[23:59] <sorear> r: say q.perl

[23:59] <camelia> rakudo 37c762: OUTPUT«␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀S␀␀␀O␀␀␀R␀␀␀R␀␀␀Y␀␀␀!␀␀␀␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀␤␀␀␀C␀␀␀o␀␀␀u␀␀␀l␀␀␀d␀␀␀n␀␀␀'␀␀␀t␀␀␀ ␀␀␀f􏿽xE2

