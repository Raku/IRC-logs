[00:01] *** not_gerd left
[00:02] *** dayangkun joined
[00:08] <quester> Does anyone recall if Perl6 was ever intended to have lazy strings?  For example, this xor's a list with an indefinite number of copies of a key...

[00:09] <quester> r: say <a b c> xx * Z~^ <0 0 0 4 4 4 8>;

[00:09] <p6eval> rakudo 932bc5: OUTPUT«Q R S U V W Y␤»

[00:09] <sorear> quester: that has been intended in the past, I think

[00:09] <diakopter> I also remember it

[00:09] <sorear> we've also talked about a 'Cat' type which is functionally identical to Str but lazy

[00:10] <quester> Ah, so NYI, but possibly coming in the future when there are enough tuits?

[00:10] <colomon> jnthn++

[00:10] <quester> r: say "abc" x * Z~^ "0004448";

[00:10] <p6eval> rakudo 932bc5: OUTPUT«0004448␤»

[00:15] <quester> Oh.  Thanks, sorear++, I found it in S03, "The count may not be * because Perl 6 does not support infinite strings.... [which] may someday be emulated with cat($string xx *), in which case $string x * may be a shorthand for that.

[00:16] <quester> ... so not yet specified.

[00:18] *** msuszczy joined
[00:21] *** pmurias left
[00:34] *** aindilis left
[00:44] *** aindilis joined
[00:45] *** kaare_ joined
[00:50] *** msuszczy left
[00:50] *** ssds joined
[00:51] *** marloshouse joined
[00:51] *** ssds left
[00:57] *** thou_ joined
[00:57] *** adu joined
[01:00] *** thou left
[01:05] *** anuby joined
[01:05] <colomon> rn: say $_ if $_.is-prime for 1 .. 10;

[01:05] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2␤3␤5␤7␤»

[01:05] <colomon> rn: say $_ if $_.is-prime for 1 .. 10;

[01:05] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2␤3␤5␤7␤»

[01:06] <colomon> rn: say $_ if $_.is-prime for 1 .. 10;

[01:06] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2␤3␤5␤7␤»

[01:06] <colomon> rn: say $_ if $_.is-prime for 1 .. 10;

[01:06] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2␤3␤5␤7␤»

[01:07] <colomon> rn: say $_ if $_.is-prime for 1 .. 10; say $_ if $_.is-prime for 1 .. 10; say $_ if $_.is-prime for 1 .. 10;

[01:07] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2␤3␤5␤7␤2␤3␤5␤7␤2␤3␤5␤7␤»

[01:08] *** hypolin joined
[01:08] <colomon> I get the same results Ovid reported, where Rakudo sometimes reports 2 3 5 7 for that and sometimes 2 3 4 5 6 7 8 9 10

[01:09] <colomon> I've seen brokenness in is-prime on my platform before, but previously assumed it was always broken and had something to do with what C libraries I had installed (like Unicode issues sometimes do).

[01:10] <benabik> Isn't is-prime probabilistic?  ;-)

[01:11] <diakopter> that's an interesting bug

[01:12] <diakopter> colomon: does it happen with much larger numbers input too?

[01:12] <colomon> I believe so.

[01:13] <colomon> benabik: yes, but it should fail less frequently than cosmic rays make memory bits swap on your computer.  ;)

[01:13] <colomon> rn: say 45724385972894572891.is-prime

[01:13] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«False␤»

[01:13] <colomon> I get true locally

[01:13] <diakopter> always?

[01:14] <colomon> seemed like I was before, but I just restarted p6 and it was False the first 3 times and then True the fourth.

[01:14] <diakopter> rn: while 1 { say 'OOPS' if 45724385972894572891.is-prime }

[01:14] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«(timeout)»

[01:15] <diakopter> rn: while 1 { say 'OOPS' if 4.is-prime }

[01:15] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«(timeout)»

[01:18] <rjbs> jnthn++ # enjoying seeing updates about jvm port

[01:19] *** kaare_ left
[01:20] <diakopter> colomon: after it starts being wrong, does %% still work?

[01:21] <colomon> to a quick check, yes.

[01:22] <colomon> it seems like the pattern of failures is consistent?  I just did it again with that same number, and it was three falses and then True just like before.

[01:22] <diakopter> o_O

[01:22] <colomon> makes me wonder if it is running out of randomness or something.

[01:22] <diakopter> heh

[01:23] <diakopter> self-modifying math system..

[01:23] <TimToady> but the algorithm used just uses the first N primes as "random" numbers, so it seems as though the table of primes is getting clobbered somehow

[01:24] *** adu left
[01:24] <TimToady> also, 4 should never be prime because it does trial division by the first N primes too

[01:24] <colomon> I'm trying to track down NQP's implementation now.

[01:26] <colomon> nqp_bigint_is_prime special-cases 1, which is why that always works.

[01:26] <TimToady> I thought rakudo was using libtommath's primality tester

[01:26] <colomon> seems like it's actually libtommath which is failing? 

[01:27] <colomon> either that or there's something more subtle going on.

[01:27] <TimToady> somebody's trying to cache something, and botching it?

[01:28] <colomon> that's what I meant by more subtle.

[01:28] <diakopter> colomon: is it always in the repl?

[01:28] <colomon> I'm not seeing any sign of that in the code, mind you.

[01:28] <colomon> diakopter: no, I've gotten it running spectest as well

[01:29] <TimToady> could GC be clobbering libtommath's prime table somehow?

[01:29] <diakopter> colomon: are you on Windows?

[01:30] <diakopter> I can't reproduce it here

[01:30] <TimToady> could throw a check in libtommath that its table still has the right primes in it

[01:30] <colomon> nope, OS X

[01:30] <colomon> I was wondering if I should try running REPL with valgrind turned on?  if it's memory clobbering that might detect it.

[01:31] <colomon> when I do make t/spec/S32-num/is-prime.t tests 1 & 2 consistently fail, everything else passes.

[01:31] <colomon> which is kind of unlike the REPL behavior, because there it seems it's later tests which fail more consistently.

[01:33] <colomon> it looks like NQP has it's own copy of libtommath, so it's probably not a bad install of one on my system.

[01:34] <colomon> why don't I just try running under gdb?

[01:34] <benabik> breakpoints are your friend?

[01:34] <benabik> Alternatively rakudo's debugger.

[01:35] <diakopter> or both?

[01:35] <colomon> rakudo's debugger is too high level, I think.  I'm going to look at the C code.

[01:35] <colomon> and fail.  

[01:37] <colomon> breakpoint didn't get hit.   now trying to add a printf to the libtommath code.

[01:39] <colomon> though I have to say I'm not clear on how to recompile that.  :\

[01:44] *** MikeFair left
[01:46] *** MikeFair joined
[01:49] <quester> colomon:  I'm running under Linux and not seeing any failures.

[01:49] <quester> diakopter:  Are on on Windows, Linux, or other?

[01:49] <diakopter> win8

[01:49] <diakopter> 64

[01:50] <quester> Oh, right, my Linux is 64 bit too (Fedora 17, kernel 3.7.6).

[01:54] *** PacoAir left
[01:54] <census> yay windows! :)

[02:00] <colomon> valgrind generates a gazillion errors, but it looks like they are mostly garbage collection things.

[02:03] <quester> Good night, #perl6.  Good hunting, colomon++

[02:05] *** quester left
[02:11] * colomon wishes moritz was awake.

[02:17] <colomon> I tried adding nok 45724385972894572891.is-prime, "45724385972894572891 is not prime"; four times to is-prime.t.  If I put it as tests 3-6, it works.  If I put it first in the file (tests 1-4) it fails every time.

[02:18] <colomon> Guess that suggests the error depends on more than just calls to is-prime.

[02:28] <colomon> Judging by errors in valgrind, there is a bunch of GC before the first (correct) result in the REPL, then nothing for the next two (correct) results, then another burst of GC before the first wrong answer.

[02:42] *** s1n joined
[02:54] *** FROGGS_ joined
[02:58] *** FROGGS left
[03:02] *** census left
[03:07] <[Coke]> r: my $a = /a/; say $a;

[03:07] <p6eval> rakudo 932bc5: OUTPUT«␤»

[03:07] <[Coke]> anyway to get something like "a" back out of that?

[03:08] <[Coke]> r: my $a = /a/; say $a.^methods;

[03:08] <p6eval> rakudo 932bc5: OUTPUT«No such method 'gist' for invocant of type 'Sub'␤  in method gist at src/gen/CORE.setting:5131␤  in sub say at src/gen/CORE.setting:7601␤  in block  at /tmp/IvHmXFebun:1␤␤»

[03:08] <dalek> roast: 658c88c | (Solomon Foster)++ | S32-num/is-prime.t:

[03:08] <dalek> roast: Add a lot of tests for 45724385972894572891.is-prime, because it

[03:08] <dalek> roast: is showing inconsistent results on my Rakudo build.

[03:08] <dalek> roast: review: https://github.com/perl6/roast/commit/658c88cead

[03:13] <colomon> yeah, Linux seems to work fine for me.

[03:21] <[Coke]> r: my $a="a"; my $b = eval "/$a/"; say $b ~~ "whoa";

[03:21] <p6eval> rakudo 932bc5: OUTPUT«False␤»

[03:21] * colomon is out of ideas.

[03:23] * colomon is out of whisky

[03:23] <colomon> (in the glass, plenty in the cupboard)

[03:23] <labster> Which is worse?

[03:23] <benabik> Are those related?

[03:23] * geekosaur puts on "Whisky In The Jar"

[03:24] <labster> how can I test if something is a basic type, like Array or Bool?

[03:25] * colomon is afraid he is going to have to learn "Whisky in the Jar" for St. Patrick's Day

[03:25] <labster> old code has ~~ Any, which matches just about anything.

[03:26] <colomon> what do you mean by "basic type"?

[03:26] *** dukeleto left
[03:27] *** dukeleto joined
[03:27] <colomon> you might get by with ~~ Cool

[03:27] <colomon> but even then, it's certainly possible for a user-created class to be Cool, they just aren't by default

[03:28] <colomon> or possibly better question (trying to think like TimToady), why do you want to know if something is a "basic type"?

[03:28] <labster> Okay, the code I'm looking at wants to take strings as parameters, but if it's something like Array or Hash, use that class to create a new object.

[03:28] <colomon> to create a new string or some other sort of object?

[03:29] <labster> it's Text::CSV, so yeah, basically.

[03:30] <colomon> one sec, want to check on my son.

[03:31] *** orafu left
[03:31] *** orafu joined
[03:32] <colomon> seems like you would want a case for each type you want to represent specially, and let everything else just use .Str or .perl or something?

[03:33] <labster> maybe I'll just check !~~ Str instead.

[03:33] *** Dave joined
[03:34] *** Dave is now known as Guest49257

[03:34] <labster> This is masak's code, but I think the general idea is parse($data, output => MyArray) is as valid as the built-in option  parse($data, output => 'hashes')

[03:37] *** dayangkun left
[03:38] *** daniel-s joined
[03:38] <labster> I'll probably go with the string comparison option because Str.new is going to choke on having a list of hash arguments anyway.

[03:39] <[Coke]> ok, https://github.com/coke/p6-lingua-en-syllable is now usable.

[03:39] *** Guest49257 left
[03:40] <[Coke]> This is a cleaned up version of the one I used in the p6cc (also bugfixes)

[03:42] <colomon> [Coke]++

[03:45] <labster> nice work

[03:46] <labster> .oO ( would a Japanese syllable counter just be $kana.chars? )

[03:49] <[Coke]> mmheheh.

[03:49] *** adu joined
[03:52] *** xiaq joined
[03:53] <colomon> $syl -= @SubSyl.grep( $word ~~ * );

[03:53] <colomon> my $syl = @AddSyl.grep($word ~~ *) - @SubSyl.grep( $word ~~ * );

[03:56] <[Coke]> yah, it was a very simplistic translation of the p5 code.

[03:58] *** dayangkun joined
[04:00] <[Coke]> colomon: that matches every regex.

[04:00] <colomon> [Coke]: yeah, I'm trying to figure out how to do it correctly now.  :)

[04:00] <colomon> actually cloned your repo and started hacking.

[04:01] <[Coke]> mmhehehe.

[04:07] *** adu left
[04:07] <colomon> okay, interesting

[04:07] <colomon> @AddSyl.grep(-> $re { $word ~~ $re }) works great

[04:08] <colomon> @AddSyl.grep({ $word ~~ $_ }) does not work, nor does $word ~~ *

[04:08] *** adu joined
[04:10] <[Coke]> ok. updated to:

[04:11] <[Coke]>     my $syl = @AddSyl.grep(-> $re {$word ~~ $re}) -

[04:11] <[Coke]>               @SubSyl.grep(-> $re {$word ~~ $re});

[04:12] <colomon> This code needs more tests!

[04:13] <[Coke]> ... Hey, the p5 version only tested "hoopty"

[04:13] <colomon> https://gist.github.com/colomon/4970109 is what I ended up with

[04:14] <[Coke]> (I'll let you make a pull request if you like, including the grep addition.)

[04:14] <[Coke]> I'll apply it, but only if you can combine the first 3 lines into a chained method call!

[04:26] <colomon> new version: https://gist.github.com/colomon/4970109

[04:29] <colomon> if you haven't changed it on your own by morning, I might remember to make a pull request.  right now I'm going to bed.  :)

[04:37] <swarley> You know, the day that i get the audio shield for my arduino is of course the day that their website goes down

[04:37] <swarley> Looks like no documentation for me

[04:39] *** adu left
[04:39] <dalek> specs: a3b902f | larry++ | S32-setting-library/Containers.pod:

[04:39] <dalek> specs: don't really need a .powerset method

[04:39] <dalek> specs: 

[04:39] <dalek> specs: also, allow a too-bit range to stop at size of the container

[04:39] <dalek> specs: review: https://github.com/perl6/specs/commit/a3b902fcd9

[04:39] <TimToady> s/too-bit/too-big/, gah

[04:40] <swarley> Cross your fingers and hope the word nazis of the internet don't find you

[04:40] <[Coke]> colomon++ #updated

[04:43] *** Chillance left
[04:49] *** preflex_ joined
[04:50] *** preflex left
[04:50] *** preflex_ is now known as preflex

[05:01] *** awwaiid joined
[05:02] *** dayangkun left
[05:03] *** dayangkun joined
[05:12] *** adu joined
[05:17] *** xinming_ joined
[05:17] *** simcop2387 left
[05:18] *** simcop2387 joined
[05:20] *** xinming left
[05:27] *** adu left
[05:41] <labster> phenny: tell masak I sent a pull request for Text::CSV to fix support for output to arbitrary type objects.  12 more tests now pass (mainly because t/04-output.t died in the middle), but output=>'hashes' is still broken.

[05:41] <phenny> labster: I'll pass that on when masak is around.

[05:53] <dalek> specs: 6fa36ad | larry++ | S32-setting-library/Containers.pod:

[05:53] <dalek> specs: nah, just default it to the powerset

[05:53] <dalek> specs: 

[05:53] <dalek> specs: Upon mature consideration, the powerset is the best default, if for no

[05:53] <dalek> specs: other reason than it will force some people to consider the degenerate

[05:53] <dalek> specs: case of 0 elements.

[05:53] <dalek> specs: review: https://github.com/perl6/specs/commit/6fa36adb4f

[06:11] *** xiaq left
[06:17] <dalek> nqp/target-pbc: 97fd401 | moritz++ | src/QAST/ (3 files):

[06:17] <dalek> nqp/target-pbc: [QAST dumper] include a bit more info

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/97fd401ee9

[06:17] <dalek> nqp/target-pbc: b1258d7 | jnthn++ | tools/ (2 files):

[06:17] <dalek> nqp/target-pbc: Revert "Merge remote-tracking branch 'origin/spacey'"

[06:17] <dalek> nqp/target-pbc: 

[06:17] <dalek> nqp/target-pbc: This reverts commit 1db6167740f7306a0e3acf04ccb15dfcc27c3dcb, reversing

[06:17] <dalek> nqp/target-pbc: changes made to c9bc4a25ba2ca57e3642dbe870da31fd1b661322.

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/b1258d7c12

[06:17] <dalek> nqp/target-pbc: 0514fec | jnthn++ | src/NQP/ (2 files):

[06:17] <dalek> nqp/target-pbc: Remove a now-unused option.

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/0514fec9f2

[06:17] <dalek> nqp/target-pbc: 1e0a374 | jnthn++ | src/NQP/Actions.pm:

[06:17] <dalek> nqp/target-pbc: Remove a redundant load.

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/1e0a374c0a

[06:17] <dalek> nqp/target-pbc: c6832d5 | jnthn++ | src/NQP/Actions.pm:

[06:17] <dalek> nqp/target-pbc: Add a way to specify a custom regex lib.

[06:17] <dalek> nqp/target-pbc: 

[06:17] <dalek> nqp/target-pbc: Useful for nqp-jvm while it only has the runtime part of it.

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/c6832d5b63

[06:17] <dalek> nqp/target-pbc: b19dbc1 | (Gerhard R)++ | / (7 files):

[06:17] <dalek> nqp/target-pbc: Merge branch 'master' into target-pbc

[06:17] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/b19dbc141a

[06:28] *** SamuraiJack joined
[06:32] *** lustlife joined
[06:51] *** xinming_ left
[06:52] *** xinming joined
[06:56] *** Khisanth left
[07:06] *** labster left
[07:12] *** Khisanth joined
[07:17] *** PacoAir joined
[07:35] *** ggoebel_ left
[07:46] *** am0c joined
[07:48] <moritz> \o

[07:56] *** kre joined
[07:56] *** kre is now known as Guest51384

[07:57] <Guest51384> perl6: say "1".WHICH

[07:57] <p6eval> rakudo 932bc5: OUTPUT«Str|1␤»

[07:57] <p6eval> ..niecza v24-23-g0520c7c: OUTPUT«str|1[2D49A800]␤»

[07:58] *** SamuraiJack_ joined
[08:00] *** SamuraiJack left
[08:02] *** PacoAir left
[08:02] <dalek> rakudo/optimizer-void-context: a5a3718 | moritz++ | src/Perl6/Optimizer.pm:

[08:02] <dalek> rakudo/optimizer-void-context: steal match widening from rakudo-debugger

[08:02] <dalek> rakudo/optimizer-void-context: 

[08:02] <dalek> rakudo/optimizer-void-context: now "23 + 4" in sink context reports the whole expression, not just the operator

[08:02] <dalek> rakudo/optimizer-void-context: review: https://github.com/rakudo/rakudo/commit/a5a3718e45

[08:38] <moritz> all spectest pass on this branch

[08:39] <moritz> jnthn: want do a code review of the optimizer-void-context branch? any objections to merging?

[08:40] <moritz> and: other ideas what do with the void context analysis?

[08:41] <moritz> maybe warning about variables in sink context

[08:44] <nwc10> moritz: is there any sort of benchmark that demonstrates where it gains?

[08:44] * nwc10 isn't competant to review it

[08:46] <moritz> nwc10: no. The stuff so far is about the warnings, not about optimizations

[08:47] <nwc10> aha

[08:51] *** Guest51384 left
[08:52] <moritz> (some of the patches involve adding source (file, line) info to some nodes, so we might even use a bit more memory than before)

[08:53] <moritz> apt-get upgrade gives me a new perl 5 version. I'm scared.

[09:00] <moritz> jnthn: and I'm increasingly wishing for $!dba attribute or so in QAST::Node, because variables can compile to QAST::Vars and calls and all that stuff

[09:01] <moritz> and literals to QAST::Want

[09:01] <moritz> or should I reuse the existing hash component?

[09:03] *** s1n left
[09:06] *** dukeleto left
[09:07] *** dukeleto joined
[09:15] * nwc10 blocks on /dev/pun, and doesn't seen to have a /dev/upun

[09:17] *** not_gerd joined
[09:17] <not_gerd> o/

[09:17] <moritz> TODO: write a tool that derives many cheap puns from a sngle pun idea :-)

[09:20] <nwc10> moritz: is my search on your IRC logger making it very busy?

[09:21] *** SamuraiJack__ joined
[09:21] *** SamuraiJack__ left
[09:21] <moritz> nwc10: should just keep one core busy

[09:21] *** SamuraiJack_ left
[09:21] *** SamuraiJack__ joined
[09:22] <moritz> and maybe a bit disc IO

[09:22] <not_gerd> could someone check if nqp/examples/load_bytecode.nqp is supposed to work right now?

[09:23] <FROGGS_> ./nqp examples/load_bytecode.nqp 

[09:23] <FROGGS_> Error while compiling block : ResizableStringArray: Can't shift from an empty array!

[09:23] <moritz> though it's on my TODO to put the data into a proper search index

[09:23] <FROGGS_> not_gerd^^

[09:23] <not_gerd> FROGGS_: thanks, so not my fault

[09:41] *** chromis joined
[09:47] *** pmurias joined
[09:47] <dalek> nqp-jvm-prep: aba0d5c | (Paweł Murias)++ | t/ (2 files):

[09:47] <dalek> nqp-jvm-prep: In qast_trig.t compare to a given epsilon as we get slightly different results for different implementations of trigonometric functions.

[09:47] <dalek> nqp-jvm-prep: 

[09:47] <dalek> nqp-jvm-prep: Add qast_output_is_approx to t/helper.t we use for that.

[09:47] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/aba0d5c819

[09:55] <dalek> rakudo-js: 8259a46 | (Paweł Murias)++ | / (5 files):

[09:55] <dalek> rakudo-js: Implement nqp::sleep (using node module sleep) and nqp::exit.

[09:55] <dalek> rakudo-js: Pass t/qast_process.t.

[09:55] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/8259a4661b

[09:55] <dalek> rakudo-js: e650024 | (Paweł Murias)++ | / (4 files):

[09:55] <dalek> rakudo-js: Pass t/qast_trig.t from nqp-jvm.

[09:55] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/e6500248d5

[09:56] <pmurias> one qast_*.t test remaining ;)

[10:01] *** hypolin left
[10:03] *** chromis left
[10:04] *** arlinius left
[10:07] *** kaare_ joined
[10:08] *** mmcleric left
[10:09] <FROGGS_> nr: my @var = <a b c>; say "a0" ~~ /@var[0]/

[10:09] <p6eval> niecza v24-23-g0520c7c: OUTPUT«Potential difficulties:␤  Apparent subscript will be treated as regex at /tmp/hAPNnXGPBS line 1:␤------> [32mmy @var = <a b c>; say "a0" ~~ /@var[33m⏏[31m[0]/[0m␤␤｢a0｣␤␤»

[10:09] <p6eval> ..rakudo 932bc5: OUTPUT«Potential difficulties:␤    Apparent subscript will be treated as regex␤    at /tmp/0RbZGE0pw0:1␤    ------> [32mmy @var = <a b c>; say "a0" ~~ /@var[33m⏏[31m[0]/[0m␤#<failed match>␤»

[10:10] *** FROGGS_ is now known as FROGGS

[10:14] *** anuby left
[10:15] *** am0c left
[10:18] *** arlinius joined
[10:24] <tadzik> hello hello

[10:27] *** muixirt joined
[10:28] <muixirt> good morning

[10:28] <FROGGS> morning

[10:30] *** spider-mario joined
[10:31] <muixirt> minor complaint: nqp/docs/bootstrapping.pod talks about nqp-rx and is probably outdated, and in general the different text formats there (pod, markdown, plain text)

[10:34] <dalek> nqp/target-pbc: 7cd9056 | (Gerhard R)++ | src/HLL/Compiler.pm:

[10:34] <dalek> nqp/target-pbc: integrate PBC generation more naturally into HLL::Compiler

[10:34] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/7cd9056768

[10:35] <FROGGS> muixirt: can you supply a patch?

[10:38] <muixirt> FROGGS: I leave that to the experts ;-)

[10:38] <FROGGS> meh :o)

[10:38] *** mberends left
[10:39] *** mberends joined
[10:47] *** dayangkun left
[10:50] <dvj> rakudo: class a { has @.b; }; $c = a.new; $c.b = qw{hello world};

[10:50] <p6eval> rakudo 932bc5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$c' is not declared␤at /tmp/gzFGrYfptG:1␤------> [32mclass a { has @.b; }; $c[33m⏏[31m = a.new; $c.b = qw{hello world};[0m␤    expecting any of:␤        postfix␤»

[10:50] <dvj> rakudo: class a { has @.b; }; my $c = a.new; $c.b = qw{hello world};

[10:50] <p6eval> rakudo 932bc5:  ( no output )

[10:52] <FROGGS> that NFA stuff is not a LHF, right? ó.ò

[10:53] <FROGGS> rakudo: class a { has @.b; }; my $c = a.new; $c.b = qw{hello world}; say $c.b

[10:53] <p6eval> rakudo 932bc5: OUTPUT«hello world␤»

[10:58] <moritz> FROGGS: what NFA stuff?

[10:58] <FROGGS> arrays in regexes

[11:00] <dvj> rakudo: class a { has $.b; }; sub c (:$d = False) { a.new.b = $d  }; c();

[11:00] <p6eval> rakudo 932bc5: OUTPUT«Cannot assign to a readonly variable or a value␤  in sub c at /tmp/1iZbpwWujP:1␤  in block  at /tmp/1iZbpwWujP:1␤␤»

[11:00] <dvj> why am I getting that error?

[11:00] <moritz> FROGGS: might not be

[11:00] <FROGGS> moritz: jnthn told me that it should be

[11:00] <moritz> FROGGS: he knows better than me, I think

[11:01] <FROGGS>  /@a/ should be /| @a/ by default

[11:01] <moritz> dvj: because you can't write to an accessor of an attribute, unless you mark it as 'is rw'

[11:01] <FROGGS> and you can switch to sequential matching by doing / || @a /

[11:01] <FROGGS> that's what my local changes are doing right now

[11:01] <moritz> (note that list assignment is a different beast, which is why you don't get an error with @ sigils)

[11:02] <dvj> moritz: ok, thanks!

[11:02] <moritz> dvj: the attribute itself (ie not the accessor) is known inside the class as $!b

[11:02] <not_gerd> if anyone is bored, try fixing `make test` on https://github.com/gerdr/rakudo/tree/target-pbc using https://github.com/perl6/nqp/tree/target-pbc

[11:03] <jnthn> moritz: I will take a look over it soon

[11:03] <jnthn> (the optimizer branch)

[11:03] <nwc10> good pm, jnthn

[11:04] <FROGGS> .oO( an optimistic branch? )

[11:04] <jnthn> o/ nwc10 

[11:05] <not_gerd> jnthn: nqp --target=pbc does work for simple stuff, but I couldn't get Rakudo to build yet replacing the two step process (nqp/parrot) with a single one

[11:06] <not_gerd> jnthn: also, my patched Rakudo fails some tests :(

[11:09] <moritz> I thought it didn't even build?

[11:09] <not_gerd> moritz: it builds as long as and don't use nqp --target=pbc

[11:10] <not_gerd> the branch makes 2 changes, really: use whiteknight's PackfileView instead of EvalPMCs and add a new frontend target

[11:11] <not_gerd> you can build Rakudo using the former (with failing tests) but not yet the latter

[11:12] <jnthn> moritz: ah, it wasn't actually that big a diff between nom and the branch. Just read thorugh it. Didn't spot anything that gave me concern.

[11:12] <jnthn> moritz: Does it catch this case:

[11:12] <jnthn> my $x = 1, 2, 3;

[11:13] * jnthn didn't see anything to suggest it does

[11:20] <jnthn> not_gerd: Maybe try taking a file that won't work with --target=pbc and stripping stuff out of it until it works. May give some hints.

[11:23] <not_gerd> jnthn: wild guess is that it might be related to library loading, but the simple example from nqp/examples actually failes on standard NQP as well ;)

[11:24] <dvj> rakudo: my Bool $a; my @b = <1 2 3>; $a = '2' eq any @b;

[11:24] <p6eval> rakudo 932bc5: OUTPUT«Type check failed in assignment to '$a'; expected 'Bool' but got 'Bool'␤  in block  at src/gen/CORE.setting:2166␤  in sub AUTOTHREAD at src/gen/CORE.setting:2158␤  in block  at /tmp/sJX_9t5mxj:1␤␤»

[11:24] <dvj> expected bool, got bool?

[11:25] <FROGGS> rakudo: my Bool $a; my @b = <1 2 3>; say '2' eq any @b;

[11:25] <p6eval> rakudo 932bc5: OUTPUT«any(False, True, False)␤»

[11:25] <jnthn> It should indeed fail. I think the error reporting is busted.

[11:26] <FROGGS> rakudo: my Bool $a; my @b = <1 2 3>; say ('2' eq any @b).WHAT;

[11:26] <p6eval> rakudo 932bc5: OUTPUT«Junction()␤»

[11:27] <dvj> I thought that was a correct way of checking if an element is in a list

[11:27] <FROGGS> rakudo: my Bool $a; my @b = <1 2 3>; $a = ('2' eq any @b).Bool;

[11:27] <p6eval> rakudo 932bc5:  ( no output )

[11:27] <jnthn> dvj: It is, but the result is not a Bool

[11:27] <dvj> is any similar to variant one would use in C++?

[11:29] <jnthn> It's makes a type called a Junction 

[11:31] <jnthn> Any operation that you do against a Junction automatically distributes, so '2' eq $some_junction produces a Junction of booleans. Put that in a boolean context and it collapses to a single true/false value. Of course, optimization may make the collapse instant when it knows there is a boolean context in place

[11:31] <dvj> interesting :)

[11:33] <pmurias> jnthn: how do junctions fit into QAST/sixmodel?

[11:33] <moritz> pmurias: they are handled at the Perl 6 / CORE level

[11:34] <moritz> ie there's a separate type Junction, which is handled like any other by QAST

[11:34] <pmurias> multis do the autothreading?

[11:34] <jnthn> It's a multi-dispatch failover, yes

[11:34] <jnthn> And in the single dispatch case, a binding failover.

[11:35] <pmurias> and when calling a method?

[11:35] <jnthn> That's single dispatch :)

[11:35] <jnthn> Oh, you mean calling a method on a junction?

[11:35] <jnthn> iirc, that's handled by the fallback mechanism.

[11:35] <jnthn> All 3 of these code paths lead to the same place, though.

[11:36] *** msuszczy joined
[11:37] <jnthn> r: my Bool $a; my @b = <1 2 3>; try { $a = ('2' eq any @b).^name; }; say $!.perl

[11:37] <p6eval> rakudo 932bc5: OUTPUT«X::TypeCheck::Assignment.new(symbol => "\$a", operation => "assignment", got => "Junction", expected => Bool)␤»

[11:38] <jnthn> oh, fail

[11:38] <jnthn> r: my Bool $a; my @b = <1 2 3>; try { $a = ('2' eq any @b); }; say $!.perl

[11:38] <p6eval> rakudo 932bc5: OUTPUT«X::TypeCheck::Assignment.new(symbol => "\$a", operation => "assignment", got => Bool::False, expected => Bool)␤»

[11:38] <jnthn> Hm, so it's wrong before we even get the exception object constructed.

[11:38] <moritz> huh, what's wrong?

[11:39] <moritz> assignment isn't coercion

[11:39] <moritz> you need to coerce yourself

[11:39] <FROGGS> well, the exception object doesnt do much magic, right?

[11:39] <moritz> r: my Bool $a; my @b = <1 2 3>; $a = so '2' eq any @b; say $a

[11:39] <p6eval> rakudo 932bc5: OUTPUT«True␤»

[11:39] <jnthn> moritz: The error message

[11:40] <jnthn> moritz: It should say got => Junction or so

[11:40] <moritz> oh, it did so in the first one

[11:40] <moritz> but not in the second

[11:40] <moritz> right

[11:40] <jnthn> yes, because I tried to assign .^name which is a Str :)

[11:40] <jnthn> Well, the got seems to be the value

[11:40] <jnthn> oh, I found it...

[11:41] <jnthn> %c_ex<X::TypeCheck::Assignment> := sub ($symbol, $got, $expected)

[11:41] <moritz> well yes

[11:41] <jnthn> That'll auto-thread :)

[11:41] <moritz> that needs a Mu or Two

[11:41] <jnthn> aye :)

[11:41] * moritz guilty as charged

[11:41] <jnthn> Any reason it is a sub, not just a pointy?

[11:41] <jnthn> oh, the trait

[11:42] * jnthn adds Mu and builds

[11:42] *** dukeleto left
[11:42] <FROGGS> bad dukeleto!

[11:42] *** dukeleto joined
[11:45] <jnthn> > my Bool $a; my @b = <1 2 3>; $a = '2' eq any @b;

[11:45] <jnthn> Type check failed in assignment to '$a'; expected 'Bool' but got 'Junction'

[11:45] <jnthn> \o/

[11:45] <moritz> \o/

[11:47] <FROGGS> .oO( it should automatically open a ticket if $expected and $got are equal... )

[11:47] <moritz> FROGGS: not at all

[11:47] <not_gerd> FROGGS: you're thinking too small: it should fix the bug and send a pull request!

[11:47] <FROGGS> :o)

[11:47] <FROGGS> moritz: why?

[11:47] <FROGGS> maybe it should check for open tickets first *g*

[11:48] <moritz> r: class A { }; my A $x = do { my class A { }; A.new }

[11:48] <p6eval> rakudo 932bc5: OUTPUT«Type check failed in assignment to '$x'; expected 'A' but got 'A'␤  in block  at /tmp/BhzbwVxDIO:1␤␤»

[11:48] <moritz> that's correct

[11:48] <FROGGS> it is, yes

[11:48] *** daniel-s left
[11:48] <FROGGS> then it should check if the types are the identical

[11:48] <FROGGS> not just their name

[11:49] * not_gerd broke bootstrapping

[11:49] <not_gerd> how did Münchhausen do that again?

[11:51] <masak> afternoon, #perl6

[11:51] <phenny> masak: 05:41Z <labster> tell masak I sent a pull request for Text::CSV to fix support for output to arbitrary type objects.  12 more tests now pass (mainly because t/04-output.t died in the middle), but output=>'hashes' is still broken.

[11:52] <FROGGS> hi masak 

[11:55] <masak> phenny: tell labster can I deny that pull request? '$output eqv Any' looks unidiomatic to me -- shouldn't it ve '$output === Any'? same with '$output.not' -- shouldn't it be '!$output'? beyond that, it looks fine.

[11:55] <phenny> masak: I'll pass that on when labster is around.

[11:56] <jnthn> .oO( working > idiomatic... )

[11:56] <masak> yes, which is why I didn't *close* the pull request.

[12:00] <jnthn> r: say Any !~~ / 'RT #67234' /

[12:00] <p6eval> rakudo 932bc5: OUTPUT«use of uninitialized value of type Any in string context  in any  at src/gen/BOOTSTRAP.pm:99␤␤True␤»

[12:13] <masak> fwiw, I cannot reproduce Ovid's https://rt.perl.org/rt3//Public/Bug/Display.html?id=116777 ;)

[12:21] <masak> phenny: tell labster nvm, I pulled and fixed those myself. :) keep up the good work!

[12:21] <phenny> masak: I'll pass that on when labster is around.

[12:23] <jnthn> masak++

[12:25] <colomon> masak: what platform are you using?

[12:26] * colomon has no trouble reproducing Ovid's bug on his OS X Rakudo build, as documented at length in the #perl6 backlog.

[12:27] <arnsholt> Weirdness. I mean, yes we're using a probabilistic primality test, but it shouldn't be -that- weird

[12:27] <masak> TimToady++ # making .combinations default to the power set

[12:28] *** PacoAir joined
[12:28] <masak> colomon: I'm on a Debian 64-bit VM inside a Windows 7 host.

[12:28] *** pmurias left
[12:28] <masak> my hardware is some Intel thing from HP.

[12:29] <colomon> I don't know what Ovid is using, but every Linux box we tested last night worked fine.

[12:30] <colomon> the other possibility is it depends on what version of libtommath you're calling.  does NPQ always use the one included with it?

[12:31] <not_gerd> oO( Ovid uses a quantum computer )

[12:31] <jnthn> Yes, should do.

[12:33] *** census joined
[12:34] <arnsholt> I can try to reproduce on my Mac later tonight

[12:39] <masak> not_gerd: Münchhausen never really documented his bootstrapping method. likely his technique was very ad-hoc.

[12:40] *** PacoAir left
[12:40] *** census_ joined
[12:40] *** PacoAir joined
[12:41] *** census left
[12:49] *** protist joined
[12:49] <dalek> nqp/target-pbc: 6fc76a3 | (Gerhard R)++ | src/stage0/ (9 files):

[12:49] <dalek> nqp/target-pbc: rebootstrap so we can build on parrot branch eval_pmc

[12:49] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/6fc76a3d8e

[12:57] *** census_ left
[12:59] *** census joined
[13:14] <FROGGS> nr: say "aabbbcccc" ~~ / [a|cccc|aab] / # it will never match "cccc" because it already stared matching from "a", right?

[13:14] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«｢aab｣␤␤»

[13:15] <FROGGS> and that is how it is meant to be?

[13:16] <moritz> yes

[13:16] <FROGGS> k, thanks

[13:16] <moritz> left-most match principle applies even before LTM

[13:20] *** PacoAir left
[13:21] *** PacoAir joined
[13:22] <FROGGS> nqp: my @a := <a cccc aab>; say("aabbbcccc" ~~ / @a /)

[13:22] <p6eval> nqp: OUTPUT«aab␤»

[13:22] <FROGGS> then thats already enough?

[13:22] <moritz> yes

[13:22] <FROGGS> then I just need to implement the ||@a switch

[13:22] <FROGGS> cool

[13:30] *** daniel-s joined
[13:31] <moritz> r: my @a = <a aab>; say 'aabb' ~~ / @a /

[13:31] <p6eval> rakudo 932bc5: OUTPUT«#<failed match>␤»

[13:34] <FROGGS> didnt push yet

[13:40] *** cobra joined
[13:43] *** protist left
[13:46] *** Tedd1 joined
[13:49] *** ssds joined
[13:50] *** census left
[13:52] *** spider-mario left
[13:52] *** SunilJoshi joined
[13:52] *** msuszczy left
[14:11] <masak> whoa. 114 comments. http://www.reddit.com/r/programming/comments/18nfst/perl_6_is_now_half_as_old_as_perl/

[14:15] <masak> does anyone know whether this is true? it's nothing I've heard before. http://www.reddit.com/r/programming/comments/18nfst/perl_6_is_now_half_as_old_as_perl/c8glc7f

[14:16] *** SunilJoshi left
[14:16] <masak> I remember there being some weirdness in the selection of talks, which inadvertently affected Perl 6 talks. but I don't think it was a deliberate *policy*.

[14:16] *** ElDiabolo joined
[14:18] *** curtispoe joined
[14:19] <masak> (also, how come even when reddit threads generate a lot of discussion on Perl 6, they are never actually about the thing the blog post was about?)

[14:19] <ElDiabolo> Is there a standard way to create a perl6 module skeleton yet ?

[14:19] <ElDiabolo> Hi masak

[14:19] <jnthn> A tool, or a guide for how to do it? http://wiki.perl6.org/Create%20and%20Distribute%20Modules provides the latter.

[14:20] <ElDiabolo> jnthn, A tool would be preferable, but that will do, too.

[14:21] *** Psyche^ joined
[14:22] <curtispoe> Hi all. I'm digging into the red-black tree code in Perl 6 and trying to figure out the correct way of describing 'my $tree = Any'. Is that saying we're assigning the Any class to the $tree scalar?

[14:22] *** dukeleto left
[14:22] *** dukeleto joined
[14:24] *** Patterner left
[14:24] *** Psyche^ is now known as Patterner

[14:25] <jnthn> "class object" isn't quite accurate; Any is a type object, which represents the type Any. It has the same type as an instance of Any; the the closest thing to class object is the meta-object, which is what holds information about methods and so forth.

[14:26] <curtispoe> Cheers for that.

[14:26] <jnthn> Another way of thinking about it is that it's a typed undef.

[14:26] <curtispoe> Also, can anyone else replicate this bug? It always happens to me after the *third* time I ask for primes: https://rt.perl.org/rt3//Public/Bug/Display.html?id=116777

[14:26] <masak> ElDiabolo: hi. thanks for the email. I'll reply to it shortly.

[14:27] <jnthn> Some people could reproduce the bug, other people couldn't. I'm not sure we've managed to spot a pattern yet...

[14:27] *** jac50 joined
[14:27] <curtispoe> And I want to apologize to any Perl 6 hackers who feel like I dumped on them when I started the Perl 7 firestorm. That was very poorly thought out on my part :(

[14:27] <masak> curtispoe: think of 'Any' as the new 'undef'. every class has its own type object, which stands in as 'the undefined value' for that type.

[14:28] <masak> curtispoe: there's a fair bit of backlog about your bug report, fwiw.

[14:28] <masak> curtispoe: http://irclog.perlgeek.de/perl6/2013-02-17

[14:29] <jnthn> I did it 20 times in the repl and can't reproduce here...maybe I can find myself an environment where I can do so.

[14:29] <masak> curtispoe: re Perl 7, I was surprised to see the initial blog post, because it's so evidently a crap idea from my perspective. but I like where it's currently heading with mst++'s "Pumpkin Perl" proposal.

[14:30] <curtispoe> Yes, I was totally brain-dead in my initial discussion and I regret it, but I'm happy to see that there might be a positive takeaway for the issue.

[14:31] <curtispoe> I'm currently writing up a post about Perl 6 and explaining the red-black tree implementation to try to put something positive about Perl 6 out there. I really like what I'm seeing.

[14:33] <masak> my takeaway from FOSDEM is that people really liked what they were seeing.

[14:33] <masak> it's nice sometimes to be reminded of the significant improvement to Perl 5 that Perl 6 represents. it's easy to forget if all you see is Perl 6 all day. :)

[14:34] <curtispoe> jnthn: I love seeing your work on the JVM recently. Are you willing to speculate on a timeframe for a full(ish) port of Rakudo?

[14:34] <curtispoe> e.g., when can people start reliably using it?

[14:35] <masak> in some sense, it's rather useless to post historical retrospectives on reddit, because all they do is parrot the common outsider beliefs about the unviability of Perl and/or Perl 6.

[14:36] <moritz> masak: I disagree. There are usually many people who read the article, even if they don't comment

[14:36] <masak> hm, that is true.

[14:36] <moritz> often you see perl posts with positive reputation but lots of troll comments

[14:36] <curtispoe> masak: agreed about the improvement that Perl 6 represents. If we can get the performance up there and include concurrency, it could really be a game-change. I don't think any major dynamic language has a working concurrency model.

[14:36] <moritz> and the positive reputation is proof that more people liked it than not

[14:37] <masak> wow, it got 140 points. \o/

[14:37] <masak> moritz++ # seeing silver linings

[14:37] <curtispoe> perl6: say "testing"

[14:37] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«testing␤»

[14:37] <curtispoe> perl6: say ($_ if $_.is-prime for 1..5).join(',');say ($_ if $_.is-prime for 1..5).join(',');say ($_ if $_.is-prime for 1..5).join(',');say ($_ if $_.is-prime for 1..5).join(',');

[14:37] <p6eval> rakudo 932bc5, niecza v24-23-g0520c7c: OUTPUT«2,3,5␤2,3,5␤2,3,5␤2,3,5␤»

[14:39] <curtispoe> Ok, on my box that repeats 2,3,4,5 on four lines.

[14:39] <jnthn> curtispoe: I think NQP will reach the point of being able to cross-compile itself to the JVM within a month from now. It's quite hard for me to give a good prediction on Rakudo. My goal is that it's in a good state ahead of the summer conference season.

[14:39] <curtispoe> jnthn: thanks. Can I post that to my blog?

[14:39] <jnthn> Well, the channel is logged, so I guess I already just said it publicly :P

[14:39] <masak> curtispoe: today's backlog also concludes that the bug is platform-related.

[14:39] <jnthn> masak: Oh, did we nail down any specifics?

[14:40] <jnthn> curtispoe: Anyway, so long as it's clear it's an estimate... Also it's not just "port Rakudo", it's "make sure the ecosystem can cope"

[14:41] <masak> jnthn: no. arnsholt said he'll try on a Mac.

[14:41] *** shinobicl joined
[14:42] <jnthn> masak: OK. I didn't hit it here

[14:42] <colomon> curtispoe: what platform are you using to get the is-prime bug?  I can definitely see it on my Mac, but my Linux box works fine.

[14:43] <curtispoe> OS X.

[14:43] <jnthn> colomon: How much RAM to those two have, ooc?

[14:43] <curtispoe> Darwin Ovid.local 11.4.2 Darwin Kernel Version 11.4.2: Thu Aug 23 16:25:48 PDT 2012; root:xnu-1699.32.7~1/RELEASE_X86_64 x86_64

[14:43] <jnthn> *do

[14:43] <colomon> jnthn: 8 gigs each

[14:43] <jnthn> OK

[14:43] <curtispoe> And I have 4 gigs of RAM.

[14:43] <moritz> jnthn: did you get around to review my branch yet?

[14:44] <jnthn> http://irclog.perlgeek.de/perl6/2013-02-17#i_6463574

[14:45] <jnthn> moritz: "Didn't spot anything that gave me concern" = "yes, you can merge it" :)

[14:45] <moritz> 4GB or RAM, linux amd64, can't reproduce the is-prime bug

[14:45] <jnthn> OK, smaller memory systems GC more often...

[14:46] <jnthn> Can somebody who can reproduce it perhaps try parrot -G perl6.pbc code-that-does-it.p6

[14:46] <jnthn> Which will run without GC. If it still happens, we know it's not GC related.

[14:46] <moritz> fwiw my branch doesn't catch "my $x = 1, 2, 3;"

[14:46] <colomon> jnthn: when I valgrinded it, it definitely seemed like there was a GC run before the results changed for the worst. 

[14:46] *** s1n joined
[14:46] <moritz> because = is not pure, so it doesn't complain about infix:<,> in void context

[14:47] <colomon> jnthn: on it

[14:47] <jnthn> moritz: But the precedence is (my $x = 1), 2, 3

[14:47] <jnthn> Oh, I see what you're saying.

[14:47] <moritz> jnthn: yes

[14:47] <moritz> 1, die 2

[14:47] <moritz> is also a , in void context we don't complain about

[14:47] <colomon> jnthn: with parrot -G it runs successfully

[14:47] <jnthn> Urgh.

[14:47] <moritz> I could make it complain, but I'm not sure it's a good idea

[14:48] <jnthn> std: my $x = 1, 2, 3;

[14:48] <p6eval> std 7551b8f: OUTPUT«ok 00:00 43m␤»

[14:48] <jnthn> Hm, I thought it warned on that one.

[14:48] <jnthn> moritz: I'm mostly thinking of trying to catch a common thinko.

[14:49] <jnthn> The optimizer may not bet the place to do it, though.

[14:49] <colomon> jnthn: if I use the parrot invocation with -G, it works.  parrot invocation without -G, 19 fails.  (That's on S32-num/is-prime.t.)

[14:52] <moritz> jnthn: I might experiment with more agressive warnings later, but first I want to see how the community responds to the new warnings

[14:53] <jnthn> moritz: +1

[14:54] *** mtk left
[14:54] * geekosaur generally thinks more warnings == good

[14:54] <moritz> geekosaur: well yes, if you get a low rate of false positives

[14:55] <geekosaur> point

[14:55] <dalek> rakudo/nom: a10db62 | moritz++ | src/Perl6/Optimizer.pm:

[14:55] <dalek> rakudo/nom: try to track void context in the optimizer

[14:55] <dalek> rakudo/nom: 

[14:55] <dalek> rakudo/nom: does not work yet, it seems to consider all string literals in void context.

[14:55] <dalek> rakudo/nom: No idea why :(

[14:55] *** dalek left
[14:55] * geekosaur , speaking of, updates rakudo and niecza

[14:56] <moritz> and in theory, the warnings are perfect and never give fals positives. But we all know how theory turns out sometimes :-)

[14:56] <moritz> good bye dalek

[14:56] *** dalek joined
[14:56] *** ChanServ sets mode: +v dalek

[14:58] *** mtk joined
[14:58] <dalek> rakudo/nom: d2795bb | moritz++ | docs/ChangeLog:

[14:58] <dalek> rakudo/nom: update ChangeLog with new warnings

[14:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2795bb7b2

[14:59] *** spider-mario joined
[15:00] *** mtk left
[15:03] <geekosaur> hrm, how do I make the rakudo build check compilers all over again?  I upgraded os and xcode since last time I built it, it's looking for /usr/bin/gcc-4.2 still

[15:03] *** mtk joined
[15:04] <moritz> geekosaur: rakudo gets its configuration from parrot

[15:05] <moritz> geekosaur: so one way is to delete the installed parrot, and then do a   perl Configure.pl --gen-parrot   in rakudo

[15:05] <geekosaur> I did the --gen-parrot, guess I need to nuke the existing

[15:05] <moritz> right

[15:06] *** mtk left
[15:07] *** mtk joined
[15:07] *** thou_ left
[15:17] *** s1n left
[15:20] *** mtk left
[15:21] *** SamuraiJack joined
[15:23] *** SamuraiJack__ left
[15:24] *** mtk joined
[15:33] *** b1rkh0ff joined
[15:40] *** cobra left
[15:40] <moritz> http://www.perlmonks.org/?node_id=1019130 # another fun discussion about advancing Perl 5. LanX++ for not talking about naming :-)

[15:42] <masak> moritz++ # reply

[15:44] <masak> moritz: fwiw, I'm not sure "evolvement" (in the last paragraph) is the word you're looking for.

[15:44] <rjbs> moritz++ # good reply

[15:45] <rjbs> and the word you wanted is probably "evolution"

[15:48] <masak> oh! yes. the closest I got to guessing the meaning was "involvement". but it didn't feel right.

[15:50] <curtispoe> Terminology question: for the red-black tree code, we have the following signature:  multi balance(B, [R, [R,$a,$x,$b], $y, $c ], $pivot, $right);. The [] aren't being used here for a sub signature, but to assist in the pattern matching. What is this usage called and where is it documented?

[15:50] <curtispoe> s/sub signature/sub-signature/

[15:50] <jnthn> It is a sub-signature

[15:51] <masak> and it's documented in S06.

[15:51] <jnthn> In a multiple dispatch, sub-signatures function as tie-breakers

[15:51] <curtispoe> Ah, I thought sub-signatures required a named variable before them.

[15:51] <curtispoe> Cheers for that.

[15:51] <masak> nope.

[15:51] <masak> let me get you a closer reference.

[15:51] <jnthn> No, if you don't care to name the unpackee you don't have to

[15:51] <jnthn> er, maybe don't use the word unpackee :)

[15:52] <jnthn> "original argument" or something is probably better :)

[15:52] <moritz> curtispoe: I even blogged about sub-signatures recently: http://perlgeek.de/blog-en/perl-6/2013-pattern-matching.html

[15:53] <curtispoe> moritz: yes, that's what first pointed me to the red-black tree example I'm writing up.

[15:53] <moritz> ah, but I didn't mention that it works without variables too

[15:53] <moritz> probably because I wasn't aware of it :-)

[15:54] <moritz> I should retro-add it

[15:54] <masak> colomon: "Unpacking array parameters" in S06 finds you a good clarification.

[15:54] <masak> er, curtispoe, not colomon.

[15:54] <curtispoe> :)

[15:55] <colomon> :)

[15:55] <jnthn> If you're curious how it works: it coerces the incoming argument to a Capture and then recurses into the signature binding process.

[15:55] <jnthn> So all the stuff you know how to do in a normal signature, you can also do in a sub-signature.

[15:58] <dalek> nqp/target-pbc: de66164 | (Gerhard R)++ | src/ (3 files):

[15:58] <dalek> nqp/target-pbc: untangle code

[15:58] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/de66164b3b

[15:58] <dalek> nqp/target-pbc: 4068cef | (Gerhard R)++ | t/ (4 files):

[15:58] <dalek> nqp/target-pbc: adjust tests

[15:58] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/4068cef76e

[15:58] <dalek> nqp/target-pbc: 7fef0cc | (Gerhard R)++ | src/stage0/ (9 files):

[15:58] <dalek> nqp/target-pbc: rebootstrap

[15:58] <dalek> nqp/target-pbc: review: https://github.com/perl6/nqp/commit/7fef0cca19

[16:00] <masak> jnthn: with the extra niceness that you can bind names down in a sub-siggy, and they remain bound even in your routine. but maybe that falls out from the simple fact that sub-signatures are not scopes. :)

[16:03] <jnthn> Yeah, they all declare in the current lexical scope

[16:03] <jnthn> And don't introduce new scopes

[16:03] <jnthn> Really you're just building up a data structure that the binder walks over.

[16:04] <curtispoe> Out of curiosity, are sub signatures powerful enough that I could use them to get rid of the "when" statements in the red-black tree example? (via extra multis) http://rosettacode.org/wiki/Pattern_matching#Perl_6

[16:05] <moritz> curtispoe: you could, with multi ins( $x, @s [$col, $a, $y where { $x before $y }, $b] )

[16:05] *** SamuraiJack_ joined
[16:05] <curtispoe> OK, I was hoping that was the case, but I wasn't sure.

[16:06] *** SamuraiJack left
[16:07] <not_gerd> jnthn: all tests pass with --target=pbc

[16:07] <not_gerd> see https://github.com/rakudo/rakudo/pull/102

[16:07] <not_gerd> would be nicde if someone would pull it into a branch so others can (spec)test more easily

[16:07] <not_gerd> ^nice

[16:10] <masak> curtispoe: yes, but multi dispatch has "nice" properties when you're doing nominal type checking, but is basically equivalent to a series of "when"s when you're doing "where" checking.

[16:10] *** Chillance joined
[16:14] <moritz> right, that's why we don't recommend excessive use of where in signatures

[16:17] *** ElDiabolo left
[16:20] *** ElDiabolo joined
[16:21] <colomon> using a bunch of wheres would be significantly less efficient than using whens, yes?

[16:22] <masak> well, at least as long as the "where"s are evaluated at least twice, as they are now :P

[16:23] <colomon> wouldn't it also force the signature to bind multiple times?

[16:23] <masak> maybe -- could you explain your reasoning?

[16:24] <jnthn> Yes, if you have two signatures that differ only by a where clause deep in an unpack, it's verifying the thing as a whole each time.

[16:24] <colomon> well, if you've got multi ins( $x, @s [$col, $a, $y, $b]  where blah).... what jnthn said.

[16:25] <colomon> is "deep in an unpack" important there?  

[16:25] <ElDiabolo> masak, Is ESQL (for Embedded SQL) a reasonable name ? Sounds a bit like Haskell, which is also cool.

[16:25] <masak> probably not, but it does make it worse.

[16:25] <masak> ElDiabolo: dang, I should really reply to that email, shouldn't it? doing it now.

[16:25] <moritz> yes, because it tries the binding of the inner signatures for every multi candidates

[16:25] *** zby_home joined
[16:25] <moritz> *candidate

[16:25] <jnthn> colomon: Not really, just emphasizing the scenario where it's most obviously wasteful

[16:26] <colomon> gotcha.  

[16:26] <ElDiabolo> masak, Never mind. There isn't much in it by now.

[16:27] <moritz> also you can retro-name it to "Extended" if you want :-)

[16:27] *** am0c joined
[16:35] <masak> ElDiabolo: email sent.

[16:36] <masak> ElDiabolo: I have some syntax reservations that I managed to get down on paper. probably easier to explain over email than here.

[16:36] <masak> ElDiabolo: that said, feel free to continue the discussion either here or via email.

[16:37] *** jac50 left
[16:37] *** jac50 joined
[16:38] *** dukeleto left
[16:38] *** dukeleto joined
[16:41] *** muixirt left
[16:46] *** thou joined
[16:49] *** xinming left
[16:56] *** census joined
[16:56] *** xinming joined
[16:58] *** James_ joined
[16:58] *** James_ is now known as Guest76939

[16:59] <census> hi!

[17:01] *** jac50 left
[17:02] *** shinobicl left
[17:02] <masak> hi, census.

[17:03] <census> all quiet on the western front?

[17:07] <moritz> not quite quiet

[17:08] *** xenoterracide left
[17:10] <masak> census: did you come here to ask whether it's all quiet?

[17:12] *** xenoterracide joined
[17:13] <moritz> r: 1 + 2; say 42

[17:13] <p6eval> rakudo d2795b: OUTPUT«WARNINGS:␤Useless use of constant expression "1 + 2" in sink context (line 1)␤42␤»

[17:15] <moritz> r: q[1]; say 42

[17:15] <p6eval> rakudo d2795b: OUTPUT«WARNINGS:␤Useless use of constant string "1" in sink context (line 1)␤42␤»

[17:16] <moritz> I should probably change that use to use q[1] instead of "1"

[17:16] <moritz> r: my $x = 42; $x; say $x

[17:16] <p6eval> rakudo d2795b: OUTPUT«42␤»

[17:16] <moritz> huh, I thought that one too warned

[17:17] <moritz> oh, I never pushed that patch :/

[17:17] <masak> moritz++ # constant warnings

[17:18] <moritz> prepare for more :-)

[17:18] <census> no, i didn't do that.  i came to say hello!  but nobody said hello back

[17:18] <census> except for you

[17:19] <moritz> census: I'm sure people would greet you more friendly if you contributed more to on-topic discussions here

[17:19] *** ssds is now known as msuszczy

[17:19] <masak> +1

[17:20] <census> thank you for the pointer.  i will work on that

[17:20] <[Coke]> I have a mac. what needs reproducing?

[17:21] <moritz> [Coke]: run   ($_ if $_.is-prime for 1 .. 10 );  a few times in a row in the REPL

[17:21] <masak> [Coke]: https://rt.perl.org/rt3/Ticket/Display.html?id=116777

[17:22] *** xenoterracide left
[17:22] *** xenoterracide joined
[17:22] <benabik> Gives me 2..10 on run #3.  (OS X)

[17:23] *** msuszczy left
[17:24] *** ssds joined
[17:25] <benabik> runs 3,4,5,7,9,10...  then I got bored.

[17:25] <moritz> benabik: how much memory does your machine have?

[17:25] <benabik> moritz: 8 GiB

[17:26] <benabik> Although I wonder how much Parrot thinks I have.  ISTR Parrot misestimating it.

[17:26] *** ssds left
[17:26] *** ssds joined
[17:26] * moritz will try at $work tomorrow, with 8GB ram and linux amd64

[17:28] <benabik> Yes.  Parrot's method of getting memory size is capped at 2GB on OS X.

[17:29] <benabik> (So it runs GC more often.)

[17:29] *** msuszczy joined
[17:30] <[Coke]> moritz: yes, I can duplicate that.

[17:31] <moritz> too bad parrot doesn't respect ulimits when determining memory size

[17:31] <moritz> the it would be much, much easier to simulate machines with smaller memory (no VM needed)

[17:31] *** ssds left
[17:31] <moritz> *then

[17:31] *** msuszczy left
[17:32] *** ssds joined
[17:32] <[Coke]> There is an open feature request to have a command line option to parrot to say how much memory to use (ala the jvm)

[17:33] <moritz> that too would be a good idea

[17:33] <masak> ...though respecting ulimit sounds like a good idea, too ;)

[17:33] * moritz opens another ticket for that

[17:35] <benabik> Checking limit inside Parrot_sysmem_amount is probably easier than figuring out how to cap total allocations.

[17:35] <benabik> *ulimit

[17:37] <moritz> yes, that's what I mean

[17:37] <moritz> man getrlimit

[17:37] *** ssds left
[17:37] *** ssds joined
[17:38] <benabik> If I wasn't up to my eyeballs in homework, I'd do it.  Place to add it is src/platform/*/sysmem.c, Parrot_sysmem_amount

[17:40] <moritz> I've opened https://github.com/parrot/parrot/issues/935

[17:40] *** ssds left
[17:41] *** ssds joined
[17:41] <colomon> "Parrot's method of getting memory size is capped at 2GB on OS X."  Wait, is this why I have trouble getting Rakudo to handle big files on my machine?

[17:41] <moritz> possibly :-)

[17:41] <benabik> It would cause Parrot to GC far more frequently.

[17:41] <benabik> Shouldn't cap memory allocations or anything like that.

[17:44] <colomon> I'm guessing running super slow from GCing all the time would be nearly indistinguishable from running super slow because of lowmemory...

[17:44] *** adu joined
[17:46] <benabik> There's a different function to use, but it's not available on all OS X.  Nobody's spent the time to create code that works for both me and kid51.  :-D

[17:46] *** ssds left
[17:47] *** ssds joined
[17:47] <pmichaud> I sent a message to the issue ticket, but memory limits was also covered in issue #795.

[17:48] <pmichaud> You can also probably check the #parrot logs around the timeframe of #795 for more details.

[17:49] <colomon> I've been wondering if this bug has always been there in is-prime, or if it is a recent thing.

[17:49] <masak> pmichaud! \o/

[17:49] <pmichaud> good morning, #perl6

[17:49] <jnthn> o/ pmichaud 

[17:49] <not_gerd> good morning ;)

[17:49] <raiph_> hi #perl6

[17:50] <raiph_> is github currently using a p5 highlighter on p6 code?

[17:51] <colomon> benabik: is there a way to hardcode the limit on Parrot, so we can see if Linux has the same sort of problems OS X does if it's running out of memory?

[17:51] <colomon> argh, end of that sentence was incoherent.

[17:51] <benabik> colomon: Change Parrot_sysmem_amount to `return SMALLNUMBER`

[17:51] <masak> raiph_: I'm assuming so.

[17:52] *** ssds left
[17:52] *** ssds joined
[17:53] *** census left
[17:54] *** alec__ joined
[17:55] *** ssds left
[17:55] *** ssds joined
[17:57] <colomon> If I'm using Parrot built by Rakudo's Configure.pl and I rebuild that Parrot by using make in its directory, how do I then rebuild Rakudo?

[17:57] * colomon cannot believe he has not run into trying to do this before....

[17:57] <raiph_> masak: thanks; I've just found the answer and yes, it's currently same as perl5

[17:57] *** ssds left
[17:58] <arnsholt> colomon: Remake NQP and then Rakudo, probably

[17:58] *** alec__ left
[17:59] <not_gerd> colomon: just `make` or if that doesn't work `perl Configure.pl --with-parrot=... --gen-nqp`

[17:59] <FROGGS> "make realclean" maybe before "make"

[18:04] <dalek> evalbot: 3819da9 | thundergnat++ | lib/EvalbotExecuter.pm:

[18:04] <dalek> evalbot: Update lib/EvalbotExecuter.pm

[18:04] <dalek> evalbot: 

[18:04] <dalek> evalbot: Update evalbot to deal with new URL scheme for gists.

[18:04] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/3819da9644

[18:05] *** shinobicl joined
[18:06] <moritz> thundergnat++

[18:07] <masak> TimToady will be pleased. he evals gists quite a bit :)

[18:10] <colomon> I think I've got it rebuilt, and it doesn't seem to make any difference on Linux.

[18:10] <colomon> Guess that's not wildly surprising if it's really a memory error.

[18:18] <not_gerd> bye, #perl6 

[18:18] *** not_gerd left
[18:20] *** James_ joined
[18:20] *** James_ is now known as Guest31828

[18:21] *** arlinius left
[18:22] *** daxim joined
[18:22] *** dukeleto left
[18:22] *** Guest76939 left
[18:23] *** dukeleto joined
[18:25] <benabik> colomon: I didn't think that was it.  Just more "oh, yeah, this thing is still broken on OS X"

[18:30] *** mberends left
[18:31] *** mmcleric joined
[18:41] *** rindolf joined
[18:48] *** arlinius joined
[18:53] *** domidumont joined
[19:01] *** Guest31828 left
[19:01] *** Guest31828 joined
[19:04] <masak> "Simple Generators v. Lazy Evaluation" -- interesting and not too complicated. http://okmij.org/ftp/continuations/PPYield/

[19:04] *** domidumont left
[19:06] *** domidumont joined
[19:10] *** spider-mario left
[19:11] *** labster joined
[19:12] <labster> good morning #perl6 (yes, still technically morning here)

[19:12] <phenny> labster: 11:55Z <masak> tell labster can I deny that pull request? '$output eqv Any' looks unidiomatic to me -- shouldn't it ve '$output === Any'? same with '$output.not' -- shouldn't it be '!$output'? beyond that, it looks fine.

[19:12] <phenny> labster: 12:21Z <masak> tell labster nvm, I pulled and fixed those myself. :) keep up the good work!

[19:13] <FROGGS> labster: it's always morning in UTG

[19:13] <FROGGS> UGT

[19:14] * labster looks at wikipedia: Unified Tasmania Green party?

[19:15] <labster> I didn't think it was that far south to get the midnight sun down there.

[19:15] <masak> labster: http://thinkmoult.com/ugt.html

[19:18] *** SamuraiJack_ left
[19:18] <labster> Thanks for fixing my idiom.  I think that just comes from reading a lot of code in a language, and I certainly need to read more in Perl 6.

[19:19] <masak> 'eqv' is for deep equality, fwiw.

[19:19] <masak> I practically never see .not in code.

[19:19] <masak> and prefix:<!> feels "safer" somehow, as it doesn't require that method to be there.

[19:20] <labster> That just came because I was switching between .defined and .not until I got the behavior I wanted.

[19:20] <jnthn> r: say Mu.^methods

[19:20] <p6eval> rakudo d2795b: OUTPUT«ACCEPTS WHERE WHICH take WHY Bool so not defined new CREATE bless BUILDALL BUILD_LEAST_DERIVED Numeric Real Str Stringy item say print gist perl DUMP DUMP-ID isa does can clone Capture Method+{<anon>}.new() dispatch:<::> Method+{<anon>}.new() Method+{<anon>}.new() …

[19:21] <jnthn> r: say Mu.^methods.grep(*.name eq 'not')

[19:21] <p6eval> rakudo d2795b: OUTPUT«not␤»

[19:21] <jnthn> masak: YOu should fear .not :)

[19:21] <jnthn> uh, should .not fear

[19:22] <labster> self.not.fear but fear(self)?

[19:22] <masak> ok. still gonna stick to ! :P

[19:22] <masak> labster: I tend to use 'defined $x' instead of '$x.defined', too :) but that one is more debatable.

[19:23] <moritz> I use $x.defined, because you can use it in lists

[19:23] <moritz> foo(defined $x, $y) vs. foo($x.defined, $y)

[19:23] <dalek> nqp: 54985c7 | jnthn++ | src/ (6 files):

[19:23] <dalek> nqp: Eliminate a bunch of pir::.

[19:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/54985c7d3a

[19:23] <dalek> nqp: 3c896f1 | jnthn++ | t/nqp/62-subst.t:

[19:23] <dalek> nqp: Update test to not pass due to a PCC fail.

[19:23] <dalek> nqp: 

[19:23] <dalek> nqp: Something that takes no parameters will not check that it got none.

[19:23] <dalek> nqp: Fixing the test, rather than porting the bug.

[19:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3c896f153d

[19:23] <dalek> nqp: d47185c | jnthn++ | src/core/Regex.pm:

[19:23] <dalek> nqp: Further portability tweak.

[19:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d47185cb2c

[19:24] <dalek> nqp-jvm-prep: 1a5005a | jnthn++ | nqp-src/NQPCORE.setting:

[19:24] <dalek> nqp-jvm-prep: Add match and subst to the setting.

[19:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1a5005a26f

[19:24] <dalek> nqp-jvm-prep: cf179ce | jnthn++ | t/nqp/62-subst.t:

[19:24] <dalek> nqp-jvm-prep: Pass 62-subst.t.

[19:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/cf179ce35d

[19:25] *** Guest31828 is now known as jac50

[19:27] <nwc10> yay, another test file

[19:27] <nwc10> 7 left?

[19:28] <masak> GlitchMr: when you link to my blog post in http://glitchmr.github.com/perl-6-changes-2013W07.html , do you think you could link to the post and not to the blog?

[19:28] <jnthn> nwc10: aye

[19:29] <nwc10> the small problem with 4 being a prime every so often

[19:29] <nwc10> it's old.

[19:29] <nwc10> building the revision of Rakudo that first added it

[19:29] <nwc10> but 2012.10 was a problem

[19:30] <GlitchMr> masak, haven't noticed

[19:31] <GlitchMr> Should be fixed when GitHub will rebuild my blog

[19:31] <masak> thank you.

[19:31] <jnthn> To anybody who either knows or knows how to use Google better than me: what's the best way to take a Unicode character name and turn it into the appropriate character in Java? :)

[19:32] <nwc10> shell out to Perl? :-)

[19:32] <GlitchMr> I know how to convert character to Unicode name...

[19:33] <GlitchMr> You could try using http://site.icu-project.org/, by the way

[19:33] <GlitchMr> It has entire Unicode table.

[19:33] <masak> I'm reaching the same answer.

[19:33] *** dukeleto left
[19:33] <colomon> nwc10++ # researching history of is-prime bug

[19:34] *** dukeleto joined
[19:34] <jnthn> GlitchMr: Yes, I know it can go in the other direction

[19:34] <jnthn> GlitchMr: Which makes me think you should be able to do the other thing too

[19:35] <GlitchMr> Well, technically you could initialize entire table, but that would be slow.

[19:35] <GlitchMr> And waste lots of memory.

[19:35] <masak> jnthn: I'll ask on ##java

[19:36] <jnthn> GlitchMr: Well, can do it on first request

[19:36] <jnthn> It's not like we need to do this unless somebody actually writes a program containing \c[PILE OF POO] or so

[19:37] <masak> jnthn: well, of course building a hash table of All The Characters would work.

[19:37] <jnthn> masak: Yes, my question was more "a better way than the obvious". :)

[19:37] <nwc10> oooh. 4 is a prime on FreeBSD after a while

[19:38] <nwc10> you have to be *more* persistent

[19:38] <nwc10> that's on spectre

[19:39] <nwc10> persist further, it isn't

[19:39] <nwc10> persist further, it is

[19:39] <nwc10> no obvious periodicity

[19:39] <rindolf> Hi all.

[19:40] <rindolf> Hi jnthn , masak GlitchMr 

[19:40] <GlitchMr> Hi

[19:40] <nwc10> -G cures all

[19:40] <jnthn> o/ rindolf 

[19:41] <arnsholt> jnthn: You'd think there would be some way to query the Unicode DB from JAva, but on second thought, I wouldn't be surprised if the solution ends up being creating something for NQP

[19:42] <jnthn> *nod*

[19:42] <jnthn> I don't need it right now, I'm just looking through where the HLL libs use pir::

[19:43] <nwc10> OK, 4 is sometimes a prime at 2e336562bdca282c537dba70577d1ad7bfa6e0b8

[19:43] <nwc10> that's the commit where Moritz added is-prime

[19:43] <GlitchMr> Just wondering, how Perl 6 on Parrot does that.

[19:43] <jnthn> GlitchMr: ICU

[19:43] <GlitchMr> Because I'm sure \C[] has to do it somehow.

[19:43] <GlitchMr> Isn't ICU available on Java too?

[19:43] <colomon> nwc10: 4 is reliably not prime before that?

[19:43] <nwc10> nqp similiary 21st-September-like c458a08a723a58146ae9b3fd7fb72198691de337

[19:43] <jnthn> It doesn't do it on my build 'cus I don't have a build with ICU

[19:43] <colomon> nwc10: or is that the first one with is-prime?

[19:43] <nwc10> colomon: before that, who knows. There was no is-prime method

[19:43] <nwc10> yep

[19:43] <jnthn> GlitchMr: I don't want to pull in the whole of ICU just for one very rarely used feature.

[19:43] <nwc10> parrot at the 4.8.0 release

[19:44] <jnthn> That's more wasteful than building the hash table of all the chars :)

[19:44] <rindolf> jnthn: what's up?

[19:44] <jnthn> rindolf: Not much, just hacking and eating icecream :)

[19:44] <rindolf> jnthn: what kind of Icecream?

[19:45] <colomon> nwc10: okay, so it's always been broken.  that's more of a pain (because we can't trace the problem to a single change) but it's still useful information to knmow.  nwc10++

[19:45] <colomon> *knoiw

[19:45] <colomon> *knbow

[19:45] <colomon> *know

[19:45] <colomon> sigh

[19:45] <nwc10> yes, sigh

[19:45] <nwc10> I agree.

[19:45] <nwc10> it's not a regression

[19:45] <nwc10> however, *also*, I can replicate it on a FreeBSD machine

[19:45] <nwc10> it's not just OS X

[19:46] <jnthn> rindolf: Strawberry

[19:46] <rindolf> jnthn: ah.

[19:46] <GlitchMr> Well, the hax could be to initialize tables when using \C[] using the long loop.

[19:47] *** shinobicl left
[19:48] <arnsholt> jnthn: I guess one way would be to sort the characters by name and store it in fixed-width format and mmap the file (Java lets you mmap, no?)

[19:48] <arnsholt> And then binary search and possibly a small cache

[19:49] <nwc10> or make a trie

[19:50] <arnsholt> Yeah, a trie might be the most compact storage

[19:51] <jnthn> Yeah

[19:52] <jnthn> Don't want to spend a load of time on it, but if somebody wants to trie something clever I'll be happy to use it :)

[19:52] <jnthn> Not going to block on it for a bit :)

[19:53] <nwc10> OK, I can't build 2e336562bdca282c537dba70577d1ad7bfa6e0b8 on FreeBSD (add expmod and is-prime)

[19:53] <nwc10> explosive backtrace from compiling src/gen/BOOTSTRAP.pm

[19:53] <nwc10> I can build that revision on OS X

[19:53] <jnthn> pmichaud: HLL::Compiler manages to load all of dumper.pbc, PGE/dumper.pbc, PCT/Dumper.pbc and Parrot/Exception.pbc

[19:54] <jnthn> pmichaud: Don't suppose you recall anything about the history of that and if any are just bogus/unrequired?

[19:54] *** arlinius left
[20:09] <masak> "This article is about a tree data structure. For the French commune, see Trie-sur-Baïse." :)

[20:10] <masak> someone should make a tumbler about funny Wikipedia sentences.

[20:10] <masak> also, does anyone else think that both pronunciations of "trie" are silly?

[20:11] *** bruges left
[20:11] <pmichaud> back again

[20:11] <pmichaud> jnthn: looking

[20:12] <pmichaud> jnthn: the dumper stuff was (is?) the thing that handled --target=past and --target=parse output

[20:12] <pmichaud> I think I might have replaced most of it

[20:12] <jnthn> ah, ok

[20:12] *** bruges joined
[20:12] <jnthn> I tossed the Parrot/Exception.pbc seemingly without problems

[20:13] <pmichaud> looks like Parrot's dumper is still used in src/HLL/Compiler.pm

[20:13] <pmichaud> well, still referenced, at any rate

[20:13] <pmichaud> looking

[20:13] <jnthn> Yes, 3 different dumper-related PBCs are loadbytecode'd :)

[20:13] <pmichaud> no, I mean it actually references the _dumper function

[20:14] <jnthn> Ah, ok

[20:14] <pmichaud> method dumper at src/HLL/Compiler.pm:444

[20:14] <pmichaud> if we can replace that with a nqp-only version, we can eliminate the parrot stuff.

[20:15] <pmichaud> Or we can ignore the --target=parse or --target=past stuff.

[20:15] <pmichaud> I did a start on dumping capabilities in src/core/NQPMu.pm

[20:16] <pmichaud> method __dump is there

[20:16] <pmichaud> (which is what Parrot's Data::Dumper uses)

[20:17] <pmichaud> anyway, I'd be fine with a HLL::Dumper module.

[20:17] <pmichaud> or a NQP::Dumper one.

[20:22] *** jac50 left
[20:22] *** jac50 joined
[20:25] *** salv01 left
[20:26] <dalek> nqp: 4500780 | jnthn++ | src/HLL/Compiler.pm:

[20:26] <dalek> nqp: Remove one seemingly unrequired loadbytecode.

[20:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4500780d2e

[20:26] <dalek> nqp: 26b0b8e | jnthn++ | src/QAST/Operations.nqp:

[20:26] <dalek> nqp: Map some more SC related ops.

[20:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/26b0b8ee72

[20:26] <dalek> nqp: 90f5160 | jnthn++ | src/ (4 files):

[20:26] <dalek> nqp: More pir:: => nqp::.

[20:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/90f51607d8

[20:39] <nwc10> 4 is a prime some of the time on FreeBSD with: This is perl6 version 2012.10 built on parrot 4.4.0 revision RELEASE_4_4_0

[20:39] <nwc10> but not with -G

[20:42] <moritz> "4 is a prime" would be a nice band name

[20:43] <masak> :D

[20:43] <masak> and then they get rid of their band member "-G"

[20:44] <jnthn> Or they only use 5 of the guitar strings...not the G string.

[20:44] <tadzik> 5 other, you mean :)

[20:44] <curtispoe> To atone for my sins, I've decided to start blogging more about Perl 6. I've written up an explanation of how Perl 6's red-black tree code works. I would be delighted if anyone could spot errors and correct me: http://blogs.perl.org/users/ovid/2013/02/red-black-trees-in-perl-6-explained.html

[20:44] <tadzik> if they used only the G string they could call themselves a G-unit (ohoho)

[20:44] <masak> curtispoe++

[20:45] * masak reads

[20:45] <moritz> jnthn: one of the dumpers might be unnecessary, now that QAST is dumped with the QAST::Node.dump method

[20:45] <jnthn> Also, is it me or does --target=parse give a lot too much info?

[20:45] <jnthn> I mean...I'm not quite sure when I do --target=parse I want to know the set of integers on the bstack... :)

[20:46] <moritz> um, a lot too little, because it usually dies before getting to the interesting parts

[20:46] <moritz> but also too much, yes :-)

[20:47] *** pmurias joined
[20:47] <jnthn> Well, we probably don't want to go dumping what hangs off the .ast also :)

[20:47] <jnthn> Since if you wanted that you'd look at --target=past ;)

[20:47] <jnthn> Also, we should maybe call that just ast

[20:49] <moritz> agreed

[20:49] <moritz> on both accounts

[20:50] <masak> curtispoe: looks nice.

[20:51] <masak> curtispoe: I'm actually not sure why, in this case, a dedicated sentinel value was not used in place of Any.

[20:51] <curtispoe> masak: thanks! It took quite a bit of time to put together. I have to say that I'm quite impressed with where Perl 6 is.

[20:51] <masak> but I have the feeling that TimToady likes to use the type objects as sentinels :)

[20:51] <curtispoe> masak: that was one area of the code I was the most unclear about.

[20:51] <masak> know, though, that something like this coulda worked, too:

[20:52] <masak> r: constant RedBlackSentinel = {}

[20:52] <p6eval> rakudo d2795b:  ( no output )

[20:52] <masak> ...or whatever name you'd give it.

[20:54] <masak> (and yes, "expressivity" is a word) :)

[20:56] <jnthn> curtispoe++ # nice post

[20:56] <masak> I also can't help thinking about ADTs when I see this example. I wonder if we'll ever get good AST support into Perl 6 (preferably through a module). the nice semantic advantage would be if it could be somewhat clever about making sure that all cases of the ADT were always covered in a 'given' statement.

[20:56] <masak> or in a set of multis.

[20:56] <curtispoe> Thanks jnthn.

[20:57] <jnthn> masak: good AST support? Ain't that your job? ;)

[20:57] <masak> er. ADT!

[20:57] <masak> :P

[20:57] * masak looks around shiftily

[20:57] <jnthn> :)

[20:58] <jnthn> the keys are like, right next to each other

[20:58] <jnthn> :P

[20:59] <masak> yed!

[20:59] *** adu left
[21:01] <pmurias> masak: how would the ADT be different from classes?

[21:01] * moritz was think more of haskell-y types

[21:02] <masak> pmurias: they're quite different in nature.

[21:02] <moritz> rbtree = JustANode | Node rbtree:left rbtree:right Color

[21:02] <moritz> of course I can't remember the proper syntax

[21:03] <masak> data Tree = Empty | Leaf Int | Node Tree Tree

[21:03] <masak> for example.

[21:03] *** am0c left
[21:03] <masak> pmurias: classes are all about (hidden) data and (public) behavior. ADTs are all about (public) data.

[21:04] <masak> ...to a first approximation.

[21:04] <shachaf> Well, you can sort of represent both sides of the expression problem with ADTs.

[21:04] <pmurias> class Tree {};class Empty is Tree {};class Leaf is Tree {has Int $.val};class Node is Tree {has Tree $.left;has Tree $.right}

[21:04] <nwc10> jnthn: the state of tests is stable

[21:04] <nwc10> (I believe that pun is reused)

[21:05] *** jac50 left
[21:05] <shachaf> E.g. these are both valid representations for a shape: data Shape = Circle Double | Rectangle Double Double; data Shape = Shape { area :: Double, perimeter :: Double }

[21:05] <jnthn> nwc10: You're get horse if you keep reporting this often :P

[21:05] <shachaf> One of them is about what a shape "is" and the other one is about what you can do with it.

[21:05] <masak> ...destructuring is an important aspect of ADTs.

[21:05] <nwc10> jnthn: possibly

[21:05] <nwc10> I did get a sore throat after reading too many chapters of Winne-the-Pooh

[21:06] <masak> i.e. in guards, you can destructure right into an ADT, just like we do with subsignatures.

[21:06] <nwc10> jnthn: as I said earlier, I'm blocking on /dev/pun, and don't seem to have /dev/upun

[21:06] <masak> pmurias: that's mainly what's missing from your converstion to classes, fwiw.

[21:06] <moritz> curtispoe++ # very nice blog post

[21:06] <nwc10> floging a dead meme

[21:06] <masak> pmurias: no simple way to destructure that.

[21:06] <nwc10> er, flogging I think. My fingers can't spell

[21:06] <masak> yes, "flogging".

[21:06] <curtispoe> I probably should have started with something a bit simpler :)

[21:07] <masak> nwc10: and nice way to bring up the horse topic again :P

[21:07] <moritz> no, it's great

[21:09] <rindolf> shachaf: hi.

[21:09] <shachaf> hi

[21:09] <pmurias> masak: so what we are missing is a more concise syntax for definition, and a destructuring syntax? 

[21:10] <curtispoe> Is there anything in Perl 6 which is equivalent to SQL's NULL? I would love to have an "UNKNOWN" type which is comparable to nothing. That avoids many subtle bugs that crop up in Perl 5 (see http://blogs.perl.org/users/ovid/2010/12/a-desired-sql-affordance.html for background if that didn't make sense).

[21:12] <moritz> curtispoe: I dimly recall reading in the specs that comparing anything to an undefined value should fail(), and a Failure in boolean context is always False

[21:12] <masak> pmurias: yes. and a way for the compiler to assert that 'given' statements have complete coverage.

[21:12] <moritz> curtispoe: but that's not implemented, and probably contradicts much of the current feeling of Perl 6

[21:12] <jnthn> r: sub anagram(*@a) { [eqv] (.subst(' ', '').comb.sort.item for @a).lol }; say anagram('hamburgers', 'shergars bum') 

[21:13] <p6eval> rakudo d2795b: OUTPUT«True␤»

[21:13] <jnthn> nwc10: ^^ ;)

[21:14] <curtispoe> moritz: but that sort of contradicts three-valued logic. "my @chosen = $_ where $_.salary < 50000 for @employees" would return employees with an UNKNOWN salary, yes?

[21:15] <curtispoe> s/where/if/

[21:15] <moritz> no, if Any < 50000 returned a Failure, then the 'if' evaluates to false

[21:15] <tadzik> wouldn't Failure in numeric be 0?

[21:15] <moritz> tadzik: no, either blow up or propagate as Failure

[21:16] <japhb> jnthn, that anagram cannot be correct. Too many 's's.

[21:16] <tadzik> ah, right

[21:16] <moritz> unless it's .handled

[21:16] *** pmurias left
[21:17] <jnthn> japhb: Oh...hm, so howe'd I get my anagram checker wrong.. :)

[21:18] <japhb> Did you mean to .sort.item, or was there supposed to be a .join in there?

[21:18] <jnthn> I meant to sort the letters then itemize...

[21:18] <jnthn> Oh, hm

[21:18] <moritz> the .item takes care that the [eqv] doesn't flatten it out

[21:18] <jnthn>  :)

[21:18] <moritz> a .join would have worked too

[21:18] <jnthn> Yeah, but then I did a .lol on the outside too

[21:19] <moritz> eqv doesn't care if it works on a two lists of chars, or on two strings

[21:19] <jnthn> r: say 'hamburgers'.comb.sort.item

[21:20] <p6eval> rakudo d2795b: OUTPUT«a b e g h m r r s u␤»

[21:20] <moritz> r: say 'hamburgers'.comb.sort.join

[21:20] <p6eval> rakudo d2795b: OUTPUT«abeghmrrsu␤»

[21:23] <jnthn> oh, it was my .lol that screwed it up

[21:23] <jnthn> r: sub anagram(*@a) { [eqv] (.subst(' ', '').comb.sort.item for @a) }; say anagram('hamburgers', 'shergars bum') 

[21:23] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:23] <jnthn> r: sub anagram(*@a) { [eqv] (.subst(' ', '').comb.sort.item for @a) }; say anagram('hamburgers', 'shergar bum') 

[21:23] <p6eval> rakudo d2795b: OUTPUT«True␤»

[21:23] <jnthn> Better.

[21:23] <masak> r: sub infix:<ana>($l, $r) { [eq] ($l, $r)>>.comb>>.sort>>.join }; say 'hamburgers' ana 'shergar bum'

[21:23] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:24] <masak> r: sub infix:<ana>($l, $r) { [eq] ($l, $r)>>.comb(/\w/)>>.sort>>.join }; say 'hamburgers' ana 'shergar bum'

[21:24] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:24] <masak> dang.

[21:24] <masak> r: say ('hamburgers', 'shergar bum')>>.comb(/\w/)>>.sort.perl

[21:25] <p6eval> rakudo d2795b: OUTPUT«(("h",), ("a",), ("m",), ("b",), ("u",), ("r",), ("g",), ("e",), ("r",), ("s",), ("s",), ("h",), ("e",), ("r",), ("g",), ("a",), ("r",), ("b",), ("u",), ("m",))␤»

[21:25] <masak> hrm.

[21:25] <jnthn> Remeains of the time when >> was spec'd to recurse into iterables, I think.

[21:25] <masak> oh :(

[21:25] <curtispoe> r: my @a = (6,2,Any,7);my @less = ($_ if $_ < 6 for @a); say @less.perl;

[21:25] <p6eval> rakudo d2795b: OUTPUT«use of uninitialized value of type Str in string context  in block  at /tmp/v_HV9YduUh:1␤␤use of uninitialized variable  of type Any in numeric context  in block  at /tmp/v_HV9YduUh:1␤␤Array.new(2, Any)␤»

[21:25] <masak> r: say ('hamburgers', 'shergar bum')>>.comb(/\w/).map({ .sort }).perl

[21:25] <p6eval> rakudo d2795b: OUTPUT«(("h",), ("a",), ("m",), ("b",), ("u",), ("r",), ("g",), ("e",), ("r",), ("s",), ("s",), ("h",), ("e",), ("r",), ("g",), ("a",), ("r",), ("b",), ("u",), ("m",)).list␤»

[21:26] <moritz> r: sub infix:<ana>($a, $b) { [eq] ($a, $b).map: *.comb.sort.join  }; 'hamburgers' ana ''shergar bum'

[21:26] <p6eval> rakudo d2795b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/tIi4lbY1Vi:1␤------> [32m*.comb.sort.join  }; 'hamburgers' ana ''[33m⏏[31mshergar bum'[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤   …

[21:26] <moritz> r: sub infix:<ana>($a, $b) { [eq] ($a, $b).map: *.comb.sort.join  }; 'hamburgers' ana 'shergar bum'

[21:26] <p6eval> rakudo d2795b:  ( no output )

[21:26] <moritz> r: sub infix:<ana>($a, $b) { [eq] ($a, $b).map: *.comb.sort.join  }; say 'hamburgers' ana 'shergar bum'

[21:26] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:26] <curtispoe> moritz: that's the problem I'm referring to. 'Any' is not "less than" 6 because its value is unknown. That could cause weird bugs to propagate. I'd like to know how I could cleanly work around that.

[21:26] <jnthn> r: sub infix:<ana> { [eq] (.comb(/\w/).sort.join for @_ }; say 'hamburgers' ana 'shergar bum'

[21:26] <p6eval> rakudo d2795b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in parenthesized expression; couldn't find final ')'␤at /tmp/JLHCt1QnXW:1␤------> [32ma> { [eq] (.comb(/\w/).sort.join for @_ [33m⏏[31m}; say 'hamburgers' ana 'shergar bum'[0m␤    expecting any of:␤     …

[21:27] <moritz> curtispoe: as I said, it's not implemented (and might not ever be)

[21:27] <jnthn> r: sub infix:<ana> { [eq] (.comb(/\w/).sort.join for @_) }; say 'hamburgers' ana 'shergar bum'

[21:27] <p6eval> rakudo d2795b: OUTPUT«True␤»

[21:27] <jnthn> masak: That's the shortest I can think of :)

[21:27] <moritz> curtispoe: currently I'm not aware of a good solution

[21:27] <curtispoe> moritz: OK. Thanks.

[21:27] <jnthn> masak: 'cus it gets rid of the parameter list :)

[21:28] <curtispoe> Er, don't we have a comparable role in Perl 6? If so, an "unknown" type could have its own comparable method that always returns false.

[21:28] * curtispoe is just wildly guessing here.

[21:29] <moritz> curtispoe: comparison is done via subs, not methods

[21:29] <colomon> n: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag ≼ $b-bag && $b-bag ≼ $a-bag; } say 'hamburgers' ana 'shergar bum'

[21:29] <p6eval> niecza v24-23-g0520c7c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/nR5gDtchn5 line 1:␤------> [32mg; $a-bag ≼ $b-bag && $b-bag ≼ $a-bag; }[33m⏏[31m say 'hamburgers' ana 'shergar bum'[0m␤␤Parse failed␤␤»…

[21:29] <moritz> curtispoe: you could just add an UNKNOWN type, and two multis for each comparison operator

[21:29] <colomon> n: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag ≼ $b-bag && $b-bag ≼ $a-bag; }; say 'hamburgers' ana 'shergar bum'

[21:29] <p6eval> niecza v24-23-g0520c7c: OUTPUT«True␤»

[21:30] <colomon> n: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag ≼ $b-bag && $b-bag ≼ $a-bag; }; say 'hamburgers' ana 'shergar bu'

[21:30] <p6eval> niecza v24-23-g0520c7c: OUTPUT«False␤»

[21:30] <moritz> class UNKNOWN { }; multi infix:<==>(UNKNOWN, $) { False };

[21:30] <moritz> colomon: can't you compare bags with eqv?

[21:31] <colomon> moritz: only in theory, at least in niecza

[21:31] <moritz> and then do it with all operators, and the other way around too

[21:31] *** domidumont left
[21:31] <colomon> n: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag eqv $b-bag; }; say 'hamburgers' ana 'shergar bu'

[21:31] <p6eval> niecza v24-23-g0520c7c: OUTPUT«Unhandled exception: Parameter '' in 'Bag.gist' requires a defined argument␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Bag.gist @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3349 (infix:<eqv> @ 4) ␤  at /tmp/xN28TMG8_u line 1 (infix:<ana> @ 1…

[21:31] <colomon> r: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag eqv $b-bag; }; say 'hamburgers' ana 'shergar bu'

[21:31] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:31] <colomon> r: sub infix:<ana>($a, $b) { my $a-bag = $a.comb(/\w/).bag; my $b-bag = $b.comb(/\w/).bag; $a-bag eqv $b-bag; }; say 'hamburgers' ana 'shergar bum'

[21:31] <p6eval> rakudo d2795b: OUTPUT«False␤»

[21:31] <colomon> moritz: doesn't appear to work in rakudo?

[21:32] <moritz> probably NYI

[21:33] <dalek> nqp: 8740c50 | moritz++ | / (2 files):

[21:33] <dalek> nqp: remove pir::escape call

[21:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8740c506f0

[21:33] <colomon> moritz: TimToady had code for it in his initial version of Set, but it doesn't work with Niecza, alas.

[21:33] <colomon> it's in the code commented out.

[21:40] <curtispoe> Good night from Paris!

[21:40] *** curtispoe left
[21:42] <masak> ooh, bags.

[21:42] <masak> colomon++

[21:47] *** donaldh joined
[21:51] <jnthn> git st

[21:51] <jnthn> oops

[21:52] <dalek> nqp: 5265cf6 | jnthn++ | src/HLL/Compiler.pm:

[21:52] <dalek> nqp: Seems PGE/Dumper.pbc is not used.

[21:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5265cf6f31

[21:52] <dalek> nqp: 9c9d7bc | jnthn++ | src/QAST/Operations.nqp:

[21:52] <dalek> nqp: Another missing SC op mapping.

[21:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9c9d7bcda4

[21:52] <dalek> nqp: 77bd4eb | jnthn++ | src/NQP/World.pm:

[21:52] <dalek> nqp: Replace a couple of QAST::VM with QAST::Op.

[21:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/77bd4eb6fc

[21:52] <dalek> nqp: c484723 | jnthn++ | src/QAST/Operations.nqp:

[21:52] <dalek> nqp: A couple more coderef op mappings.

[21:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c48472343d

[21:52] <dalek> nqp: afbe2be | jnthn++ | src/NQP/World.pm:

[21:52] <dalek> nqp: Get rid of another QAST::VM.

[21:52] <dalek> nqp: 

[21:52] <dalek> nqp: Seems this is one of, if not the last QAST::VM node in code-gen that

[21:52] <dalek> nqp: should be portable. Of course, still a bunch of pir:: and Q:PIR uses

[21:52] <dalek> nqp: to go.

[21:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/afbe2be21c

[21:53] *** kaare_ left
[21:54] *** arlinius joined
[21:56] *** zby_home left
[22:00] *** donaldh left
[22:03] *** ElDiabolo left
[22:03] *** lustlife left
[22:10] *** donaldh joined
[22:17] *** dukeleto left
[22:17] *** dukeleto joined
[22:33] *** bluescreen10 joined
[22:37] <jnthn> pmichaud: About MARKED and MARKER, currently they are stored in a global. We get some bugs because an eval in a BEGIN block, for example, doesn't get a separate set of marks, or other such oddness. Any objections to storing the mark hash in ParseShared (and thus once per parse)?

[22:39] *** xinming left
[22:41] <felher> Oh, coool. A .combinations method. This will boost some of the RC examples, I bet.

[22:41] *** xinming joined
[22:41] <colomon> felher: once someone gets around to implementing it.

[22:42] <felher> colomon: right :)

[22:43] <dalek> nqp: 32a218b | jnthn++ | src/HLL/Grammar.pm:

[22:43] <dalek> nqp: Eliminate Q:PIR in starter/stopper.

[22:43] <dalek> nqp: 

[22:43] <dalek> nqp: Took a simpler approach than the kboga++ patches for these two.

[22:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/32a218b2c3

[22:43] <dalek> nqp: 98a623e | jnthn++ | src/HLL/Grammar.pm:

[22:43] <dalek> nqp: Port HLL::Grammar.O to NQP.

[22:43] <dalek> nqp: 

[22:43] <dalek> nqp: Mostly from kboga++'s pull request, with a few tweaks and some use of

[22:43] <dalek> nqp: native types.

[22:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/98a623e5c4

[22:44] *** donaldh left
[22:46] <felher> good night, #perl6 :)

[22:47] <colomon> \o

[22:50] <masak> jnthn++ # .O

[22:51] *** PacoAir left
[22:52] <masak> "He must, so to speak, throw away the ladder after he has climbed up it." -- the PIR->nqp conversions always remind me of https://en.wikipedia.org/wiki/Lie-to-children#Wittgenstein.27s_ladder

[23:00] <dalek> perl6-most-wanted: 63fd354 | (Geoffrey Broadwell)++ | tools/prettify-json:

[23:00] <dalek> perl6-most-wanted: Add a tools/ directory, containing a simple JSON prettifier to make it easier to look up details in the perl6-module-list

[23:00] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/63fd354744

[23:00] <dalek> perl6-most-wanted: 5166372 | (Geoffrey Broadwell)++ | most-wanted/modules.md:

[23:00] <dalek> perl6-most-wanted: Note that JSON handling has a partial implementation in JSON::Tiny

[23:00] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/5166372923

[23:02] <lue> std: say#`[]42;

[23:02] <p6eval> std 7551b8f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/APQv68VBpI line 1:␤------> [32msay[33m⏏[31m#`[]42;[0m␤Two terms in a row (listop with args requires whitespace…

[23:02] <lue> rn: say#`[]42;

[23:02] <p6eval> niecza v24-23-g0520c7c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/rBwXOXua6u line 1:␤------> [32msay[33m⏏[31m#`[]42;[0m␤␤Two terms in a row (listop with args requir…

[23:02] <p6eval> ..rakudo d2795b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/jsjAUwIf7M:1␤------> [32msay#`[][33m⏏[31m42;[0m␤    expecting any of:␤        argument list␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤        statement modif…

[23:03] <lue> That's interesting. (I was testing to see if #`[] would act like whitespace there, just ooc)

[23:04] <masak> lue: I can see the argument for that, yes.

[23:04] <masak> lue: and the implementations seem to disagree a bit on what went wrong.

[23:04] <masak> 'night, #perl6

[23:04] <lue> well, STD and Niecza agree with each other, at least.

[23:04] <jnthn> No, they both say ttiar

[23:05] <lue> knight, masak

[23:05] <lue> jnthn: std and niecza "bare say" in addition

[23:05] <jnthn> lue: Right

[23:05] <jnthn> But it's the ttiar that kills the parse in both, it seems

[23:06] <lue> rn: say() 42

[23:06] <p6eval> rakudo d2795b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/BsXStBXxgn:1␤------> [32msay() [33m⏏[31m42[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤        statement modifier␤        statement mo…

[23:06] <p6eval> ..niecza v24-23-g0520c7c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/hEtL28UANk line 1:␤------> [32msay() [33m⏏[31m42[0m␤␤Parse failed␤␤»

[23:08] *** lee_ joined
[23:09] <lue> Do you think #`[] should count as whitespace there? I personally don't see why not, but there might be a good reason against that which I'm missing.

[23:12] <jnthn> std: say\#`[]42;

[23:12] <p6eval> std 7551b8f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/6r3tVI8C8F line 1:␤------> [32msay[33m⏏[31m\#`[]42;[0m␤Two terms in a row (listop with args requires whitespac…

[23:13] <jnthn> ah, not that

[23:13] <jnthn> Well, not sure how it should be done. :)

[23:13] <jnthn> It seems all the implementations consistently treat it as not whitespace though.

[23:14] <lue> are you sure #`[] is the second term and not 42?

[23:16] <jnthn> Oh, I think the 42 is what it hits and gets confused over

[23:17] <jnthn> std: say#`[] 42;

[23:17] <p6eval> std 7551b8f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/becfNwccC3 line 1:␤------> [32msay[33m⏏[31m#`[] 42;[0m␤Two terms in a row (listop with args requires whitespac…

[23:17] <jnthn> oh, maybe not

[23:17] <jnthn> std: say #`[] 42;

[23:17] <p6eval> std 7551b8f: OUTPUT«ok 00:00 41m␤»

[23:17] <jnthn> std: say #`[]42;

[23:17] <p6eval> std 7551b8f: OUTPUT«ok 00:00 41m␤»

[23:17] <lue> r: say#`[] 42;

[23:17] <p6eval> rakudo d2795b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/SeMHRiQ_Lv:1␤------> [32msay#`[] [33m⏏[31m42;[0m␤    expecting any of:␤        argument list␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤        statement modi…

[23:18] <lue> rakudo gets confused on 42, it seems. (While everyone else trips on #`[])

[23:21] <jnthn> I have a slight suspicion that it's more a reporting issue 

[23:22] <lue> Makes sense.

[23:22] <jnthn> Hm, I thought it was gonna be that ws localized the highwater position and Rakudo doesn't

[23:24] *** rindolf left
[23:25] <lue> I wonder what about say#`[] 42 causes it to act like a combination of say; 42 and say() 42

[23:35] <dalek> perl6-roast-data: 9721f17 | coke++ | / (4 files):

[23:35] <dalek> perl6-roast-data: today (automated commit)

[23:35] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/9721f17b1c

[23:43] <dalek> rakudo/nom: 10dac76 | jnthn++ | src/Perl6/ (2 files):

[23:43] <dalek> rakudo/nom: Support for nqp::const.

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/10dac76d0f

[23:43] <dalek> rakudo/nom: b9ee89a | jnthn++ | / (9 files):

[23:43] <dalek> rakudo/nom: Some pir:: => nqp:: for the setting.

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9ee89a9e1

[23:45] <jnthn> sleep, 'ngiht

[23:47] <lue> knight jnthn o/

[23:51] *** dayangkun joined
[23:52] <dalek> perl6-most-wanted: f7d5012 | (Geoffrey Broadwell)++ | most-wanted/modules.md:

[23:52] <dalek> perl6-most-wanted: Clean up UI section of modules.md a bit

[23:52] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/f7d50129c1

[23:52] <dalek> perl6-most-wanted: 1712b68 | (Geoffrey Broadwell)++ | most-wanted/modules.md:

[23:52] <dalek> perl6-most-wanted: Start working through task-belike-* data-sources

[23:52] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/1712b6805c

[23:52] *** thou left
