[00:00] <sorear> [] is the old (?: ), it just groups without also making a numbered capture

[00:01] <sorear> also, .say for slurp.comb(/\S+/)

[00:01] *** berekuk left
[00:01] <sorear> or slurp.words

[00:01] <sorear> comb is probably the most underappreciated p6 addition

[00:02] <sorear> (you know you can't pre-tokenize forth right?)

[00:02] *** berekuk joined
[00:04] *** berekuk left
[00:18] *** sjohnson left
[00:19] *** tgt joined
[00:21] *** sjohnson joined
[00:32] *** tgt left
[00:36] *** raiph left
[00:36] <FROGGS> gnight ladies

[00:38] <tangentstorm> sorear: thanks for the tip on [].. i was misunderstanding what it meant.

[00:38] <tangentstorm> i'm not really trying to tokenize forth i just wanted to make a simple example. goal is really to tokenize java :D

[00:51] *** sqirrel left
[01:06] *** gdey left
[01:08] *** FROGGS_ joined
[01:12] *** FROGGS left
[01:13] *** kbenson left
[01:24] *** Psyche^ joined
[01:26] *** cooper left
[01:27] *** Patterner left
[01:27] *** Psyche^ is now known as Patterner

[01:31] *** raiph joined
[01:33] *** cooper joined
[01:39] <sorear> tangentstorm: I should warn you that the current perl 6 stuff is not totally suited for parsing lex+yacc style languages

[01:39] <sorear> you may be able to fake it and write an integrated parser (without lexing)

[01:40] <skids> tangentstorm: I don't think you have to instantiate actions; the methods are class methods.

[01:40] <sorear> but if you do lex, and then you want to parse, well - you can't parse a list of tokens with a grammar currently

[01:45] <tangentstorm> yeah PEGs don't really have tokens, do they?

[01:46] <tangentstorm> i'm not entirely clear what the difference between a rule and a token is, since tokens behave more like production rules than traditional tokenizers

[01:46] <tangentstorm> r: .say for slurp.comb /land/

[01:46] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/P32HiIuuIg:1␤------> .say for slurp.comb /land/⏏<EOL>␤    expecting any of:␤        argument list␤        postfix␤        infix stopper␤        infix or meta-infix␤»

[01:47] <tangentstorm> r: .say for slurp.comb( /land/ )

[01:47] <p6eval> rakudo f0aa5a: OUTPUT«land␤»

[01:48] <tangentstorm> r: .say for slurp.comb( /\S+/ )

[01:48] <p6eval> rakudo f0aa5a: OUTPUT«Land␤der␤Berge,␤Land␤am␤Strome,␤Land␤der␤Äcker,␤Land␤der␤Dome,␤Land␤der␤Hämmer,␤zukunftsreich!␤Heimat␤bist␤du␤großer␤Söhne,␤Volk,␤begnadet␤für␤das␤Schöne,␤vielgerühmtes␤Österreich,␤vielgerühmtes␤Österreich!␤Heiß␤umfehdet,␤wild␤umstritten␤liegst␤dem␤Erdteil␤du␤inmit…

[01:48] *** woosley joined
[01:49] <tangentstorm> r: .say for slurp.comb( /.and/ )

[01:49] <p6eval> rakudo f0aa5a: OUTPUT«Land␤Land␤Land␤Land␤Land␤land␤»

[01:49] <tangentstorm> ah case sensitive

[01:51] <tangentstorm> sorear: ANTLR3 has a feature where you can have data pass through without any changes, and just match a particular language feature

[01:52] <tangentstorm> like.. say you're coding in pascal and you want to convert all the keywords to lower case, but not inside a comment or string

[01:53] <tangentstorm> you could write a tokenizer, and then have it ignore strings but replace each keyword with its upper case equivalent.

[01:53] <sorear> r: .say for slurp.comb( /:i .and/ )

[01:53] <p6eval> rakudo f0aa5a: OUTPUT«Land␤Land␤Land␤Land␤Land␤land␤»

[01:53] <sorear> r: .say for slurp.comb( /:a .and/ )

[01:53] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Unrecognized regex modifier :a␤at /tmp/K54BOzEevN:1␤------> .say for slurp.comb( /:a⏏ .and/ )␤»

[01:53] <sorear> r: .say for slurp.comb( /:m .and/ )

[01:53] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Unrecognized regex modifier :m␤at /tmp/3mJ7i081rm:1␤------> .say for slurp.comb( /:m⏏ .and/ )␤»

[01:53] <sorear> oh well

[01:53] <tangentstorm> what's m?

[01:53] <sorear> tangentstorm: I see

[01:53] <tangentstorm> sorear: that's not a good example

[01:53] <tangentstorm> my example i mean ;)

[01:54] <tangentstorm> better example: say i want to translate c to python

[01:54] <tangentstorm> or python to c

[01:54] <tangentstorm> that's easier

[01:54] <sorear> :m = :ignoremark is supposed to do a comparison ignoring (real or precomposed) combining characters

[01:54] <sorear> so you can be sloppy and "Schöne" ~~ /:m Schone/

[01:54] <tangentstorm> argh. i know what i want but i can't really explain it.

[01:54] <sorear> rather fiddly to implement, I know niecza never implemented it

[01:55] <tangentstorm> i'm trying to translate java -> pascal

[01:55] <tangentstorm> i would like to start with this whitespace tokenizer, and just have everything pass through unchanged

[01:55] <tangentstorm> then i would like to start adding rules that modify the stream

[01:56] <sorear> unfortunately your rules need to be context dependant

[01:56] <tangentstorm> so like in perl5 i might say:   while (<>) { print } 

[01:57] <tangentstorm> and then step 2 would be  while (<>) { if (whatever) { blahblah } else { print } } 

[01:57] <sorear> after you've tokenized Java, how do you translate the token final to pascal?

[01:57] <tangentstorm> probably would just omit it. 

[01:57] <sorear> (note: the last pascal code I touched was written in I think 84, I imagine it has OO now but I have no clue what it looks like)

[01:58] <tangentstorm> it's not a general java -> pascal translator, it's a specific codebase that i wrote, so if i need to i can change it.

[01:59] <tangentstorm> sorear: it's not the rules that are a problem here... it's totally fine to match statement as /.* ';'/ and not worry about what's inside

[02:00] <tangentstorm> i  don't need to write a full parser.

[02:00] <tangentstorm> what i'm hung up on is how to make a catch-all action

[02:00] <tangentstorm> so that everything defaults to "print unchanged"

[02:00] <tangentstorm> unless i specify otherwise

[02:00] <tangentstorm> maybe some kind of magic auto-method in the action?

[02:01] <skids> classes can have default catch-all methods.

[02:01] <sorear> ehehehe

[02:01] <geekosaur> don't think standard pascal has oo still. if you see something that looks like oo pascal, it's probably delphi

[02:02] <sorear> niecza allows you to create an action named FALLBACK

[02:02] <sorear> this is nonstandard, but rather necessary for a bootstrapped compiler

[02:02] <skids> IIRC it is "standard" now.

[02:03] <skids> S12#FALLBACK_methods

[02:03] <tangentstorm> skids: my @tokens = Grammar.parse( slurp, :actions( Actions ));  works great. thank you :)

[02:03] <sorear> because the set of action names required in perl 6 is not a priori fixed

[02:04] <tangentstorm> geekosaur: yes, standard pascal is long dead... object pascal is alive and well though ( http://freepascal.org/ )

[02:04] <geekosaur> yes and IIRC they picked it up from delphi :)

[02:05] <tangentstorm> yeah, it started as a turbo pascal clone, and then lazarus is a delphi clone... but fpc actually has its own dialect now

[02:06] <tangentstorm> objfpc had generics before delphi, for example, and the syntaxes are not the same

[02:06] <tangentstorm> i will try the fallback thing. thanks.

[02:07] <skids> rn: class a { method FALLBACK { "OHAI".say } }; a.foo();

[02:07] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«OHAI␤»

[02:07] <p6eval> ..rakudo f0aa5a: OUTPUT«No such method 'foo' for invocant of type 'a'␤  in block  at /tmp/kOykBVot6b:1␤␤»

[02:07] <skids> rakudo does not have it yet.

[02:08] <skids> but maybe there is a prestandard equivalent.

[02:08] *** _jaldhar joined
[02:11] <skids> Ah, http://irclog.perlgeek.de/perl6/2013-03-08#i_6565799

[02:13] *** fgomez left
[02:14] <gtodd> skids: interesting ... so is the syntax of niecza "hack" becoming the "standard" ?  

[02:14] <tangentstorm> it's neat that methods act as both class and instance methods as long a you don't acces instance data

[02:15] <tangentstorm> r: class Fool { my method FALLBACK (|stuff) { say stuff }; Fool.^add_fallback(-> $, $ {True}, -> $, $name { &FALLBACK }) }; Fool.of_a_Took('Peregrine')

[02:15] <p6eval> rakudo f0aa5a: OUTPUT«Peregrine␤»

[02:16] <tangentstorm> okay rather than asknig what the | indicates in |stuff... where should i look to find out what the | indicates?

[02:16] <skids> Yes, FALLBACK is specced right above Class Methods in S12

[02:16] <gtodd> yeah that is neat but looks longer than 

[02:16] <gtodd>  rn: class a { method FALLBACK { "OHAI".say } }; a.foo();

[02:16] <p6eval> rakudo f0aa5a: OUTPUT«No such method 'foo' for invocant of type 'a'␤  in block  at /tmp/UYTWr1wBU0:1␤␤»

[02:16] <p6eval> ..niecza v24-37-gf9c8fc2: OUTPUT«OHAI␤»

[02:17] <gtodd> oops meant to skip the m: 

[02:18] <tangentstorm> hmm. that should be pretty trivial to add to rakudo

[02:18] <gtodd> skids: indulge my edification :-)  .... how/where will it get added to rakudo?

[02:19] <skids> gtodd: I'm not the one to ask :-)

[02:19] <gtodd> if it's possible to do it in some roundabout way does the syntax get changed in a grammar someway?

[02:19] <skids> tangentstorm: most such uses for | are in S06

[02:19] <gtodd> skids: ok understood :)

[02:20] <skids> I barely do anything here, just read the channel and occasionally have the wherewithall to remember a few things :)

[02:20] <tangentstorm> if there's a universal base class, it could just have this fallback set up in rakudo, and it's default behavior could be to raise the exception rakudo already raises.

[02:21] *** fgomez joined
[02:22] <gtodd> ha .. it's interesting how a "nonstandard, ... but  "necessary for a bootstrapped compiler" might make its way back in to the spec.  The diversity of perl6 "environments" seems to push the language to do interesting things

[02:23] <tangentstorm> perl5 had a feature like this too... Auto:: something

[02:23] <tangentstorm> i can't remember

[02:23] <skids> Autoloading.

[02:25] <tangentstorm> sounds about right :)

[02:25] <geekosaur> sub AUTOLOAD

[02:26] <tangentstorm> looks like porcupine is object pascal / delphi for parrot :)

[02:34] *** cognominal__ left
[02:34] *** cognominal__ joined
[02:37] *** woosley1 joined
[02:37] *** woosley left
[02:37] <BenGoldberg> Perl6 does have a universal base class.  It's called Mu

[02:37] *** PacoAir left
[02:38] <tangentstorm> of course it is. :D

[02:38] <tangentstorm> perl is fun.

[02:38] <tangentstorm> i forgot.

[02:40] <BenGoldberg> .ud perl6

[02:41] <yoleaux> ENOTFOUND

[02:41] <BenGoldberg> .ud perl5

[02:41] <yoleaux> ENOTFOUND

[02:41] <BenGoldberg> .ud perl

[02:41] <yoleaux> pur'-el (n)  1. Computer programming language used mostly by male virgins, between the ages of 17 and 35, who are also well versed in the Lord Of The Rings stories.Pratical Extraction and Reporting La

[02:41] <japhb> tangentstorm, -Ofun is more than just a slogan, it's a way of life.  :-)

[02:42] * tangentstorm left for python about ~12-15 years ago. :/

[02:43] <tangentstorm> i did write an assembler in perl not too long ago though.

[02:44] *** orafu left
[02:44] *** orafu joined
[02:46] <tangentstorm> hmm.. is cperl-mode the place to go for perl6 on emacs?

[02:47] *** preflex left
[02:47] *** preflex_ joined
[02:48] *** preflex_ is now known as preflex

[02:51] *** cooper left
[02:56] <raiph> .u 2C22

[02:56] <yoleaux> U+2C22 GLAGOLITIC CAPITAL LETTER SPIDERY HA [Lu] (Ⱒ)

[02:59] *** Chillance joined
[02:59] <lue> tangentstorm: yes, sadly (that reminds of something I might do over the weekend though)

[03:00] <sorear> gtodd: tbh I'd rather someone add the rakudo method to niecza

[03:01] *** cooper joined
[03:01] *** cooper left
[03:01] *** cooper joined
[03:03] <tangentstorm> looking at Mu.pm:     my $meth := $type.HOW.find_private_method($type, $name);

[03:04] <colomon> sorear: what method?

[03:04] <tangentstorm> i'm not seeing where HOW is defined yet though

[03:06] <gtodd> sorear: :-) I think I understand your preference ...

[03:07] <gtodd> colomon: class Fool { my method FALLBACK (|stuff) { say stuff }; Fool.^add_fallback(-> $, $ {True}, -> $, $name { &FALLBACK }) }; Fool.of_a_Took('Peregrine')

[03:07] <gtodd> the FALLBACK 

[03:08] *** BenGoldberg left
[03:09] <gtodd> it was longer and there was the "|stuff" bit so I instinctively liked the niecza approach ... then began to think a bit more

[03:10] <tangentstorm> it looks like rakudo uses add_fallback in several places

[03:10] <tangentstorm> traits.pm  uses it... not exactly sure what it's doing

[03:11] <tangentstorm> but it looks like fallbacks could be created as a trait...?

[03:11] <sorear> colomon: add_fallback

[03:12] <sorear> tangentstorm: HOW is special syntax, it's not actually a method call

[03:12] <sorear> it's defined in the computer to produce special ops

[03:12] <sorear> nqp::how IIRC for rakudo

[03:12] <tangentstorm> the reason pirate stalled in 2003 was lack of a usable object system for parrot. looks like it's pretty feature rich now.

[03:12] <colomon> sorear, gtodd: gotcha.  not something I can add in the ten minutes before bedtime, alas.

[03:12] <sorear> Op::Interrogative for niecza

[03:13] <tangentstorm> fair enough.

[03:14] <tangentstorm> my only issue is that i don't see any docs :/

[03:14] <tangentstorm> for add_fallback i mean

[03:15] <gtodd> (|stuff) 

[03:15] <gtodd> :)

[03:15] <sorear> hmm.  I would declare 117579 wrong

[03:15] <tangentstorm> src/gen/Metamodel.pm i guess

[03:16] <sorear> (labster)

[03:17] *** lopsoflove joined
[03:17] <lue> r: say "A" ne <A B C>.any

[03:17] <p6eval> rakudo f0aa5a: OUTPUT«False␤»

[03:18] <lopsoflove> k

[03:18] <lue> is ne supposed to do that?

[03:21] <tangentstorm> that looks sensible to me

[03:21] * tangentstorm doesn't know enough to guess why that wouldn't work.

[03:23] <geekosaur> any's a junction, no?

[03:23] *** rking left
[03:23] <tangentstorm> that's how i'd read it

[03:23] <tangentstorm> how would i say "typeof"?

[03:24] <geekosaur> r: my $a = "x"; say $a.WHAT

[03:24] <p6eval> rakudo f0aa5a: OUTPUT«(Str)␤»

[03:24] <lue> OK, my mind was trying to understand the negation is all. I get it now.

[03:24] <tangentstorm> .HOW .WHAT ... :D awesome.

[03:24] *** rking joined
[03:24] *** rking left
[03:24] <tangentstorm> r: <A B C>.any  # hoping for 'Junction' :)

[03:24] <p6eval> rakudo f0aa5a:  ( no output )

[03:24] <tangentstorm> r: say <A B C>.any  # hoping for 'Junction' :)

[03:24] <p6eval> rakudo f0aa5a: OUTPUT«any(A, B, C)␤»

[03:24] <tangentstorm> ok

[03:25] <geekosaur> r: say <A B C>.any.WHAT

[03:25] <p6eval> rakudo f0aa5a: OUTPUT«(Junction)␤»

[03:25] <lue> I believe .WHAT is the "typeof" you're looking for.

[03:25] <tangentstorm> details.

[03:25] <tangentstorm> sigh.. yeah, that's what i meant to type. thanks ;D

[03:25] *** rking joined
[03:26] <tangentstorm> so if it's a junction then ne makes perfect sense

[03:26] <tangentstorm> r: say "A" eq <A>

[03:26] <p6eval> rakudo f0aa5a: OUTPUT«True␤»

[03:27] <tangentstorm> therefore:

[03:27] <tangentstorm> r: say "A" eq <A>.any

[03:27] <p6eval> rakudo f0aa5a: OUTPUT«any(True)␤»

[03:27] <skids> Junctions stringify to Str, not to junctions of Str.  As of February.

[03:28] <tangentstorm> r: say "A" eq <A B>.any

[03:28] <p6eval> rakudo f0aa5a: OUTPUT«any(True, False)␤»

[03:28] <tangentstorm> r: say "A" ne <A B>.any

[03:28] <p6eval> rakudo f0aa5a: OUTPUT«False␤»

[03:28] <tangentstorm> now i understand.

[03:28] <lue> Like I said, I confused myself trying to understand the ticket sorear mentioned :)

[03:29] <tangentstorm> n: say "A" ne <A B>.any

[03:29] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«False␤»

[03:29] <tangentstorm> n: say "A" eq <A B>.any

[03:29] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«any(Bool::True, Bool::False)␤»

[03:29] <tangentstorm> n: say <True, False>.WHAT

[03:29] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«(Parcel)␤»

[03:29] <tangentstorm> n: say <True, False>.any.WHAT

[03:29] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«(Junction)␤»

[03:30] <tangentstorm> n: say ! <True, False>.any

[03:30] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«False␤»

[03:30] <tangentstorm> $a ne $b ->  ! ($a eq $b)

[03:30] <lue> is rakudo's REPL still considered unreliable? I suspect that may have caused labster's issues with the if statements. (The first part about 'ne' is correct behavior to my knowledge)

[03:35] <lue> (unless, "ne is a shortcut for !eq" is actually a hint to write ne as  sub infix:<ne>($a, $b) { $a !eq $b };  )

[03:37] <tangentstorm> the question is really about what sort of logical inferences you can make about Junctions.

[03:38] <tangentstorm> rn: say <True, False, True>.any

[03:38] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«any("True,", "False,", "True")␤»

[03:38] <p6eval> ..rakudo f0aa5a: OUTPUT«any(True,, False,, True)␤»

[03:38] <tangentstorm> rn: say <True False True>.any

[03:38] <p6eval> rakudo f0aa5a: OUTPUT«any(True, False, True)␤»

[03:38] <p6eval> ..niecza v24-37-gf9c8fc2: OUTPUT«any("True", "False", "True")␤»

[03:38] <lue> rn: say (True, False, False).any

[03:38] <p6eval> rakudo f0aa5a: OUTPUT«any(True, False, False)␤»

[03:38] <p6eval> ..niecza v24-37-gf9c8fc2: OUTPUT«any(Bool::True, Bool::False, Bool::False)␤»

[03:38] <lue> rn: say so (True, False, False).any

[03:38] <p6eval> rakudo f0aa5a, niecza v24-37-gf9c8fc2: OUTPUT«True␤»

[03:39] <tangentstorm> perldoc -f so  :)

[03:39] <tangentstorm> no magic bots do perldoc either hrm...

[03:39] <lue> tangentstorm: just so you know, the angle bracket lists are just a convenient way of writing lists of strings [ <a b c> looks better/is faster to type than ("a", "b", "c") ]

[03:40] <sorear> lue: labster shadowed a function in an outer scope, then got surprised when a different function in the outer scope didn't call it.  he seems to be confused about the concept of lexical scoping or the way in which perl 6 applies it

[03:41] <tangentstorm> thanks, lue

[03:41] <lue> I can see where Perl 6 is right then (although I too would've made labster's assumption as well)

[03:42] <tangentstorm> r: say ( True, False ).any

[03:42] <p6eval> rakudo f0aa5a: OUTPUT«any(True, False)␤»

[03:42] <tangentstorm> r: say so ( True, False ).any

[03:42] <p6eval> rakudo f0aa5a: OUTPUT«True␤»

[03:43] <tangentstorm> r: say so ( False ).any

[03:43] <p6eval> rakudo f0aa5a: OUTPUT«False␤»

[03:43] <tangentstorm> r: say so not ( False ).any

[03:43] <p6eval> rakudo f0aa5a: OUTPUT«True␤»

[03:43] <tangentstorm> r: say not so ( False ).any

[03:43] <p6eval> rakudo f0aa5a: OUTPUT«True␤»

[03:44] <tangentstorm> r: say( not so ( True, False ).any, so not ( True, False ).any )

[03:44] <p6eval> rakudo f0aa5a: OUTPUT«FalseFalse␤»

[03:44] <sorear> when I say that "so 2 is the same as not not 2", I am making a specific assertion about the implementations of so and not in the default setting

[03:44] <tangentstorm> wait what just happened.

[03:44] <sorear> this does not mean that if you add "say 'HERE';" to the implementation of not, so will print "HERE HERE"

[03:45] <tangentstorm> nm. confused myself.

[03:45] <tangentstorm> r: say X [True, False] [&so, &not]

[03:46] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/PewkP5TYoh:1␤------> say X [⏏True, False] [&so, &not]␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        bracketed infix␤»

[03:46] <tangentstorm> r: say X [True, False], [&so, &not]

[03:46] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/xYoprz7Xvi:1␤------> say X [⏏True, False], [&so, &not]␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        bracketed infix␤»

[03:46] <sorear> X does not work that way

[03:46] <sorear> r: say (True, False X &so, &not)

[03:46] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Undeclared names:␤    &not used at line 1␤    &so used at line 1␤␤»

[03:46] <sorear> n: say (True, False X &so, &not)

[03:46] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«True sub so(Any \v) { ... } True sub not(Any \v) { ... } False sub so(Any \v) { ... } False sub not(Any \v) { ... }␤»

[03:47] <sorear> X constructs a list of given items

[03:47] <sorear> it does not call functions or anything

[03:47] <sorear> also, it's an infix operator, not prefix

[03:47] <labster> hi, was I summoned?

[03:47] <sorear> also it requires bare lists, not lists boxed up in []

[03:47] <tangentstorm> cool

[03:47] <tangentstorm> [] isn't a list anymore?

[03:48] <sorear> r: my @foo = [1,2,3]; say @foo.elems

[03:48] <p6eval> rakudo f0aa5a: OUTPUT«1␤»

[03:48] <sorear> [1,2,3] is an anonymous scalar variable which holds a reference to a list

[03:49] <diakopter> r: my @foo := [1,2,3]; say @foo.elems

[03:49] <p6eval> rakudo f0aa5a: OUTPUT«3␤»

[03:49] <sorear> labster: i was just raising my objections to your !eq ticket

[03:49] <diakopter> nice! I think. :)

[03:50] <tangentstorm> := means flatten or something?

[03:50] <tangentstorm> like | ?

[03:50] <tangentstorm> "Capture"

[03:51] <tangentstorm> r: say ( True, False X so, not )

[03:51] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Bogus statement␤at /tmp/mDbwjiPqrk:1␤------> say ( True, False X so⏏, not )␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤        prefix or meta-prefi…

[03:51] <labster> sorear: lue: I can understand the scoping issue because you mentioned it, but if ne defined as !eq, shouldn't it work like a macro?

[03:51] <labster> ... though I'm probably wrong about this

[03:52] <tangentstorm> n: say [True, False], [False, True] X <so not>

[03:52] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«True False so True False not False True so False True not␤»

[03:53] <tangentstorm> n: say [True, False], [False, True] X <so not>, <not so>

[03:53] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«True False so True False not True False not True False so False True so False True not False True not False True so␤»

[03:53] <sorear> labster: I've always interpreted it to mean sub infix:<ne>($x,$y) { $x !eq $y }

[03:53] <sorear> labster: I've always interpreted it to mean sub infix:<ne>(Mu $x, Mu $y) { $x !eq $y }

[03:54] <sorear> labster: the essential part isn't the synonym, the essental part is the fact that it completely changes junctional behavior

[03:54] <tangentstorm> n: say [True, False], [False, True] X <SO NOT>, <TON OS>

[03:54] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«True False SO True False NOT True False TON True False OS False True SO False True NOT False True TON False True OS␤»

[03:55] <sorear> tangentstorm: it will make more sense if you wrap that in ().perl

[03:55] <tangentstorm> n: say [True, False], [False, True] X [<SO NOT>], [<TON OS>]

[03:55] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«True False SO NOT True False TON OS False True SO NOT False True TON OS␤»

[03:55] <tangentstorm> that's what i wanted.

[03:55] <tangentstorm> n: say ([True, False], [False, True] X <SO NOT>, <TON OS>).perl

[03:55] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«([Bool::True, Bool::False], "SO", [Bool::True, Bool::False], "NOT", [Bool::True, Bool::False], "TON", [Bool::True, Bool::False], "OS", [Bool::False, Bool::True], "SO", [Bool::False, Bool::True], "NOT", [Bool::False, Bool::True], "TON", [Bool::False, Bool::…

[03:56] <tangentstorm> n: say ([True, False], [False, True] X <SO NOT>, <TON OS>).perl.WHAT

[03:56] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«(Str)␤»

[03:56] <labster> sorear: Okay, then the question becomes -- does it make sense to define a different infix:<ne> (Cool, Cool) that uses isne_s for the speed?  So far as I can tell only junctions depend on the !eq behavior.

[03:56] <tangentstorm> like repr in python? $x = eval($x.perl) ?

[03:57] <sorear> labster: "!eq behavior" MEANS the junction behavior

[03:57] <sorear> tangentstorm: Yes

[03:58] <sorear> labster: sure, if you can show that the arguments aren't junctions, go ahead and use isne_s

[03:58] *** lopsoflove left
[03:58] <sorear> have you noticed yet that != has the same magic?

[04:01] <labster> yeah, but it doesn't affect my code right now so I haven't been paying attention to it :)

[04:01] <tangentstorm> n: for [True, False], [False, True] X "so not", "not so" -> $junc, $ops { say eval( $ops ~~ $junk.perl )}

[04:01] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Variable $junk is not predeclared at /tmp/g4CSZFx4fd line 1:␤------>  so" -> $junc, $ops { say eval( $ops ~~ ⏏$junk.perl )}␤␤Potential difficulties:␤  $junc is declared but not used at /tmp/g4CSZFx4fd line…

[04:01] <tangentstorm> n: for [True, False], [False, True] X "so not", "not so" -> ($junc, $ops) { say eval( $ops ~~ $junk.perl )}

[04:01] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Variable $junk is not predeclared at /tmp/Hq9luhZv0n line 1:␤------> o" -> ($junc, $ops) { say eval( $ops ~~ ⏏$junk.perl )}␤␤Potential difficulties:␤  $junc is declared but not used at /tmp/Hq9luhZv0n line…

[04:01] <tangentstorm> i'm probably annoying everyone. sorry :D

[04:02] <labster> tangentstorm: you can always /msg p6eval these

[04:02] <tangentstorm> oh nice

[04:02] <tangentstorm> thanks

[04:05] *** dmol1 joined
[04:06] *** dmol1 left
[04:07] <labster> I'm just wondering if there should be some deeper reasoning defining ne as !eq everywhere, because S03:4065, S03:1214 don't mention junctions.  Or is only an identical outcome important, because the only place !eq will every make a difference is junctions?

[04:07] <skids> It's in S03, look for "not raising" (quotes included)

[04:08] <skids> Which is what the behavior is probably called linguistically.

[04:08] *** kaare_ joined
[04:10] *** sftp joined
[04:11] *** adu_ joined
[04:11] *** sftp_ left
[04:20] *** sunnavy joined
[04:25] *** adu_ is now known as adu

[04:25] <adu> hi

[04:25] <skids> o/

[04:25] <sorear> hi

[04:27] <adu> my c stuff is kinda working

[04:27] <diakopter> oh?

[04:27] <adu> but I don't know how to write method or classes

[04:31] <adu> https://github.com/andydude/c2drox

[04:31] <adu> how does one write parser actions?

[04:33] <adu> I have a vague understanding of AST building: https://github.com/andydude/c2drox/blob/master/lib/C/StdC11Actions.pm6

[04:33] <adu> but other type of actions I'm a little lost

[04:33] <tangentstorm> you can just put anything you want in the method

[04:34] * tangentstorm learned this tonight :)

[04:34] <adu> what I'd like to do is this: https://github.com/andydude/c2drox/blob/master/lib/DROX/DROXActions.pm6

[04:35] <tangentstorm> what happens instead?

[04:36] <adu> well, it does run those actions, but I'm still not sure exactly how to navigate the match objects

[04:37] <adu> it's basically going to be a c to MathML+extra compiler

[04:38] <tangentstorm> can you ask a specific question? i'm pretty much a newbie, but i've been working with actions for a few hours :)

[04:38] <lue> adu: It's a couple years old, but I've referred to it quite a few times before: https://perl6advent.wordpress.com/2009/12/21/day-21-grammars-and-actions/

[04:38] <adu> lue: yeah, that helped a bit

[04:38] <tangentstorm> was using that too, earlier :)

[04:38] <skids> In theory the actions should build your own self-contained tree under the top level .ast.  But that tends to be tedious so many just build smaller subtrees and keep the Match objects for structure.

[04:40] <adu> skids: it seems daunting

[04:40] <adu> why so scary

[04:40] <tangentstorm> i just deleted the match rules for the things i didn't change

[04:41] <skids> Note the "say"s in DROXActions don't make anything

[04:41] <adu> which is good, right?

[04:41] <adu> maybe I do want an AST first

[04:41] <tangentstorm> you only need an ast if you're going to transform it

[04:41] <lue> for debugging reasons, say is perfectly fine in actions :)

[04:41] <adu> should I use QAST or my CAST?

[04:42] <tangentstorm> or want to look at it i guess :)

[04:43] <lue> QAST is an AST that NQP uses during its compilation. It has nothing to do with the ASTs you generate with your actions.

[04:43] <adu> tangentstorm: the transforms are really minor, like (a + b) becomes <apply><plus/><ci>a</ci><ci>b</ci></apply>

[04:43] <sorear> ow

[04:43] <lue> sorear: That's why I don't like MathML :)

[04:43] <tangentstorm> that's probably not really a transform

[04:44] <tangentstorm> well

[04:44] <tangentstorm> by transform what i meant is re-arrange 

[04:44] <adu> lue: I don't like reading MathML, but that's not why I'm doing this

[04:44] <tangentstorm> i would think your parse tree is going to look like that already, right?

[04:44] <adu> tangentstorm: yes, I think it does

[04:46] <tangentstorm> yeah so wherever you match binary-operation, that rule would be  something like: rule binex { $left=<expr> <op> $right=<expr> } ?

[04:46] <tangentstorm> i said it wrong

[04:46] <adu> alternatively I could build an XML AST, but so far as I know I wrote the only XML library for perl6

[04:46] <lue> unless you're doing it for debugging reasons, changing those "say"s to "make"s in DROXActions would probably be what you want.

[04:46] <tangentstorm> $<left>=<expr> i think.. crap. i  forgot, but however you name things

[04:47] <adu> o wait, exemel

[04:47] <tangentstorm> ah yeah... you cat just make "string"

[04:47] <adu> lue: I don't understand make

[04:47] <tangentstorm> def make(self, thing): self.ast = thing

[04:48] <skids> it just assigns to .ast of the corresponding Match object.

[04:48] * tangentstorm doesn't know the perl for that yet. sorry. ;)

[04:48] <adu> tangentstorm: how pythonic

[04:48] <adu> tangentstorm: then you might like another one of my projects: https://github.com/andydude/python2drox

[04:48] <tangentstorm> last time i used perl it was all blessed hash references :)

[04:49] <adu> tangentstorm: that's a fully functional converter

[04:49] <tangentstorm> i don't know what a drosera object xml is 

[04:50] <adu> tangentstorm: it's just MathML + some extra stuff

[04:50] <skids> adu: so if you want a fully connected tree under .ast then parents have to glue together their children with make.

[04:51] <adu> skids: so make [a, b] or something

[04:51] <skids> right.

[04:51] <adu> actually, I think I will go with the AST first

[04:51] <tangentstorm> drosoft isn't loading for me

[04:51] <adu> someone else might want to have an AST

[04:52] <adu> tangentstorm: really? I'll fix it

[04:52] <tangentstorm> it came up now.. i think it's my connection.

[04:52] <adu> tangentstorm: http://drosoft.org/tr/drox.html is the spec

[04:52] <tangentstorm> but if that's your site, http://drosoft.org/tr/dson-0.1.html has some kind of encoding issue

[04:52] <tangentstorm> that one too

[04:53] <adu> I'm planning on rewriting them to match the theme of the main site

[04:53] <tangentstorm> your table of contents is all:   Â Â Â Â 1.1 Scope

[04:53] <adu> that was inserted by xmlspec.xsl written by w3.org, which I'm scrapping in favor of scribble

[04:53] <tangentstorm> the racket thing?

[04:54] <adu> yes

[04:54] <tangentstorm> cool

[04:54] <adu> you can use it independantly, just run "scribble --html"

[04:54] <adu> I've already written my scribble.css to match the rest of the site, just need to rewrite the document now

[04:54] <tangentstorm> yeah. i mostly use org-mode for the moment but i looked at a lot of them

[04:56] <tangentstorm> so what would i use this for?

[04:56] <skids> adu: The other alternative is to try to keep cruft out of the Match objects and keep them structured close to the way you want them, and then offer methods that traverse just the .hash/.list

[04:57] <skids> I think that people will fight with those two approaches for a while and eventually patterns will emerge and will either become pretty core libs or result on a spec enhancement.

[04:58] <adu> skids: ok, I'll try using only match objects at first, and see how far I can go

[04:58] <adu> tangentstorm: lots of things

[04:59] <adu> tangentstorm: mostly things that already exist, like syntax highliters, automatic code checkers/formatters/debuggers, things that calculat cyclomatic complexity, dataflow analysis, static analysis

[04:59] *** rindolf joined
[05:00] <adu> tangentstorm: but it's mostly for people who are comfortable with xml

[05:00] <skids> .oO(xml makes my eyes bleed.)

[05:01] *** kaare_ left
[05:01] <adu> I've never really thought of xml as something to be read, I think of it as something to be stored and queried, and if your query returns too much data, then refine your query :)

[05:02] <tangentstorm> so like you're providing a cross-language parser kind of thing?

[05:02] <tangentstorm> like a single api to parsing multiple languages?

[05:02] <adu> probably

[05:02] <adu> yes

[05:02] <skids> My real problem with XML is the forcing of everything into a tree, even stuff that doesn't really fit.

[05:03] <adu> but I've been planning this for like 5 years, and the purpose is constantly shifting, but I've always seen the need people have for code analysis

[05:04] <tangentstorm> that's what rdf is for

[05:04] <lue> skids: I've always seen the problem more as people trying to fit non-tree data into XML (not that XML is the issue)

[05:04] <adu> tangentstorm: that's what I'm using for equivalence

[05:04] <tangentstorm> yeah i saw :)

[05:05] <adu> I've got cwm installed on the server-side, but I'm not sure how to use it yet

[05:05] <tangentstorm> i wish we had a unified set of tools that understood ASCII control codes for structuring data.

[05:05] <tangentstorm> then all this xml/yaml/json/whatever could just go away

[05:06] <adu> lue: actually, the best structure I've seen so far is Alexy Radul's cells and propagator model

[05:06] <adu> lue: which is non-tree

[05:06] <adu> http://web.mit.edu/~axch/www/phd-thesis.pdf

[05:07] <tangentstorm> ascii has a whole set of control codes for  tabular data, including separators for fields, rows, groups, and files

[05:07] <adu> tangentstorm: CSV without the commas

[05:07] <tangentstorm> as well as markers for start of a header, start of text, and end of text, which could be used to make nested structures.

[05:07] <tangentstorm> yeah

[05:08] <tangentstorm> they're just sitting there taking up space in the character table

[05:09] <adu> tangentstorm: that's similar to exi, and if you have an xmlschema, then exi could give you a lot of space savings vs. .xml.gz

[05:09] <adu> tangentstorm: need I remind you

[05:09] <adu> .u 1F4A9

[05:09] <yoleaux> U+1F4A9 PILE OF POO [So] (💩)

[05:10] <adu> there's a lot of characters just taking up space

[05:10] <tangentstorm> hrm.. i only just skimmed exi... it's a bit like what i'm talking about, but not really..

[05:11] *** xinming_ left
[05:11] <tangentstorm> this would still be meant to be human readable

[05:11] <sorear> tangentstorm: have you ever come in contact with the ASC X12 data system?

[05:11] <tangentstorm> nope

[05:12] <sorear> tangentstorm: it's basically a unified set of tools that's designed to use ASCII control codes for strucuting data.

[05:12] <tangentstorm> huh.

[05:12] <tangentstorm> by tools i was talking about:  grep, ls, sqilite, vim, emacs, perl :)

[05:12] <tangentstorm> like a userland

[05:13] <adu> xml has lots of userlang

[05:13] <adu> d

[05:13] <sorear> i wrote some stuff last month to implement that, because there's a computer in Memphis running COBOL on an AS/400 that doesn't speak anything else that my company needs to access

[05:13] <adu> my favorites are xsltproc, saxon, and xsh

[05:14] <adu> sorear: you should translate cobol2drox

[05:14] <tangentstorm> like all these tools understand "\n" and know how to work with word-wrapping and such, but that's all you really get out of them... lists of lines

[05:14] *** xinming joined
[05:14] <tangentstorm> :)

[05:14] <adu> tangentstorm: anyways, there is a few companies who make good money doing reengineering

[05:14] <tangentstorm> i'm looking at the ASC X12 site but it looks like a big industrial thing

[05:15] <adu> tangentstorm: http://www.semdesigns.com/products/DMS/DMSToolkit.html

[05:15] <tangentstorm> ah yeah.. i've seen these guys before.

[05:16] <tangentstorm> adu: i get it now... i was just thrown off by the mathml aspect :)

[05:16] <adu> I feel like I want to do that, only without the pressure, I just want to give it away

[05:16] <adu> whenever I charge for things it makes me feel bad

[05:16] <tangentstorm> step into my office... >:D

[05:17] * tangentstorm puts adu to work.. muahahaha

[05:17] <adu> maybe have a free drox interpreter, then charge $$$ for the JIT

[05:17] <adu> tangentstorm: I have a job, thanks

[05:17] <skids> charge for it and then give the money to some OSS project :-)

[05:18] <adu> skids: :)

[05:18] <tangentstorm> perl6 seems to attract a lot of people interested in cross language interop.

[05:18] <tangentstorm> which i guess makes sense.

[05:20] <lue> I created an example for grammar+actions, if you're interested: https://gist.github.com/lue/5377054

[05:20] <sorear> adu: Isn't that basically PHP's business model?  pay-for-compiler

[05:21] <tangentstorm> okay the java-parsing part of my compiler is done: grun Java compilationUnit -tree whatever.java :)

[05:22] <tangentstorm> using the java syntax that ships with antlr4 ... it basically dumps s-expressions... should be pretty doable to parse that with my minutes of perl6 expertise :)

[05:23] * lue would think the integrated grammar feature is what attracts the cross-language crowd

[05:23] <adu> sorear: I don't know, I thought php was free

[05:23] <tangentstorm> yeah. i kind of want to translate antlr grammars to perl6 now. :)

[05:23] <adu> tangentstorm: that's the spirit!

[05:23] <tangentstorm> the grammars and also parrot.

[05:24] <sorear> adu: the php *interpreter* is frew

[05:24] <sorear> free

[05:24] <tangentstorm> i mean the idea of running python on parrot is what attracted me originally.

[05:27] <tangentstorm> hmm... with this antlr approach, i don't think i even need the fallback.

[05:28] <adu> tangentstorm: I just updated http://drosoft.org/tr/drox.html

[05:28] <tangentstorm> wow, MUCH nicer.

[05:28] <adu> :) I rock

[05:28] <tangentstorm> have you seen candlescript?

[05:28] <adu> that's scribble :)

[05:29] <tangentstorm> http://www.candlescript.org/

[05:29] <adu> nope

[05:29] <adu> sounds like xml fun

[05:29] <tangentstorm> it's just one guy... hasn't been updated in a while, i guess.

[05:29] <tangentstorm> it takes all the xml tools and repackages them in a non-xml syntax

[05:30] <tangentstorm> it also has grammars and schemas and such.

[05:30] <tangentstorm> http://www.candlescript.org/doc/candle-markup-examples.htm

[05:31] <tangentstorm> kind of just an alternate, unified syntax for for xml/xpath/xquery/xslt + scripting

[05:31] <adu> tangentstorm: anyways, the core inspiration of drox is that 90% of MathML is centered around the <apply> element, but with most languages you need <stmt> and <decl> elements too, and in the spirit of MathML, you can come up with whatever first element suits your needs, like <go:defer/> or <java:synchronized/> or <perl6:grammar/> etc.

[05:33] <tangentstorm> candle also does what relax.ng does... it unifies pattern matching/parsing on strings, trees, and i guess graphs.

[05:33] <tangentstorm> not sure about graphs.

[05:33] *** raiph left
[05:34] <tangentstorm> (your relax ng usage just reminded me of it is all)

[05:34] <adu> that's one thing I never liked, relaxng is Great for schemas&type definitions, and xquery is Great for templates, but it's impossible to do the other thing in the other language

[05:35] <tangentstorm> weird: i can't click the top couple links in your table of contents.

[05:35] <adu> odd

[05:36] <adu> maybe its a browser thing, because the <a>s are there

[05:38] <tangentstorm> yeah your body tag seems to be covering it 

[05:38] <tangentstorm> not sure how that works, but that's what firefox is showing.

[05:38] <adu> tangentstorm: I'm seeing it in chrome, it might be a css issue

[05:39] <adu> I'll put it on my todo list

[05:40] <tangentstorm> i'm still not sure i understand exactly what your project does but i like it :)

[05:41] <tangentstorm> is there a  way i can use a file as both a module and a program?

[05:41] * tangentstorm vaguely remembers something about BEGIN from perl5

[05:41] <adu> tangentstorm: to start, I have pairs of transforms, i.e. python2drox, and drox2python

[05:42] *** rindolf left
[05:42] <adu> tangentstorm: and js2drox, drox2js, if you had some code that you want to try to port from javascript to python, you would connect js2drox | drox2python

[05:42] *** rindolf joined
[05:42] <adu> and if you got an error, or it looks funny, then try again :)

[05:43] <tangentstorm> ... oh

[05:43] <tangentstorm> OH

[05:43] <adu> and I haven't uploaded drox2* yet because they will have to be much more liberal

[05:43] <tangentstorm> i didn't pick that up at all from your site. :)

[05:43] <adu> reengineering :)

[05:44] <adu> tangentstorm: https://github.com/andydude/js2drox

[05:44] <tangentstorm> yeah i'm right this minute translating java -> object pascal

[05:45] <adu> tangentstorm: if I had those, that would be as simple as java2drox | drox2opascal

[05:46] <tangentstorm> there was another guy in here earlier talking about http://cdent.org/

[05:47] <adu> interesting

[05:48] <tangentstorm> but you're aiming for whole language translation right?

[05:48] <adu> yes

[05:48] <tangentstorm> the other project like this that i know of is haxe

[05:48] <adu> the Data part of the site is so you can browse language keywords, among other things

[05:48] <adu> I've seen haxe

[05:49] <tangentstorm> strictly one-way

[05:49] <adu> but it has a language and VM

[05:49] <tangentstorm> yeah

[05:49] <adu> I don't want either of those

[05:49] <adu> the world has enough languages

[05:49] <adu> we just need to convert between them

[05:49] <tangentstorm> :)

[05:49] * tangentstorm is working on a programming language

[05:49] <adu> me too

[05:49] <tangentstorm> :D

[05:49] <adu> I don't have a spec

[05:49] <adu> actually 2 languages

[05:49] <adu> droscheme, and droscript

[05:50] <adu> droscheme (compiler is about 70% done, library about 10% done, interpreter was 90% done)

[05:50] <adu> droscript (0% done)

[05:51] <adu> tangentstorm: what's your language called?

[05:51] <tangentstorm> wejal

[05:53] <tangentstorm> i don't have a good elevator pitch for it ;)

[05:53] <adu> pitches are for closed source loosers

[05:53] <tangentstorm> but it's kind of in the ballpark of what you're talking about

[05:54] <tangentstorm> it's sort of a dialect of forth that looks like a normal infix language.

[05:54] <tangentstorm> so there's no nailed down syntax

[05:54] <tangentstorm> https://github.com/sabren/b4/blob/master/b4a/b4a.wj <- this is a mockup

[05:56] <tangentstorm> so far i've been focused on a virtual machine called ngaro, but i'm kind of thinking of targeting parrot as well.

[05:56] <tangentstorm> ngaro is a stack machine with implementations in like 12 different languages

[05:57] <tangentstorm> maybe i'll start by porting it to perl :)

[05:58] <adu> parrot is interesting

[05:59] <adu> and the way that programs were compiled is interesting

[05:59] <tangentstorm> which part?

[05:59] <adu> iirc, they made a c file that said program = "..parrot bytecodes.."; then Parrot_exec(program);

[06:00] <adu> maybe its different now

[06:00] <tangentstorm> you mean compiling to an executable?

[06:00] <adu> yes

[06:01] <tangentstorm> kind of wondered where the rakudo perl6 binary was coming from :)

[06:01] <tangentstorm> i was working on a python -> parrot compiler in 2003 or so and it wasn't nearly that far along yet. i'm really impressed with what i'm seeing here.

[06:02] <adu> pynie?

[06:02] <adu> what I need to do is just make a few command-line tools in perl6 to get my barings, for example, I have no idea how to iterate a list

[06:03] <tangentstorm> no, it was called pirate it's not online anymore.

[06:04] <tangentstorm> for list { .say }

[06:04] <tangentstorm> will print every item in a list

[06:04] <tangentstorm> r: for 1..10 { .say }

[06:04] <p6eval> rakudo f0aa5a: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[06:04] <Timbus> ;

[06:05] <adu> r: for $x in 1..10 { say $x }

[06:05] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Variable '$x' is not declared␤at /tmp/1UtfCMK_BB:1␤------> for $x⏏ in 1..10 { say $x }␤    expecting any of:␤        postfix␤»

[06:05] <tangentstorm> r: for 1..10 -> $x { say $x }

[06:05] <p6eval> rakudo f0aa5a: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[06:06] <adu> omg I could write only again

[06:06] <tangentstorm> ?

[06:06] <adu> http://hackage.haskell.org/package/only

[06:07] <adu> it's a toy I made to learn Haskell

[06:07] *** rindolf left
[06:07] *** rindolf joined
[06:07] <adu> it would probably be a 1 liner

[06:08] <tangentstorm> r: for lines() { .say } 

[06:08] <p6eval> rakudo f0aa5a: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmi…

[06:09] <tangentstorm> r: my $x = 0; for lines() { if 3 < $x++ < 9 { .say } }

[06:09] <p6eval> rakudo f0aa5a: OUTPUT«Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤»

[06:10] <tangentstorm> r: my $x = 0; for lines() { if /das/ and 3 < $x++ < 9 { .say } }

[06:10] <p6eval> rakudo f0aa5a:  ( no output )

[06:10] <tangentstorm> r: my $x = 0; for lines() { if /das/ and ( 3 < $x++ < 9 ) { .say } }

[06:10] <p6eval> rakudo f0aa5a:  ( no output )

[06:10] <tangentstorm> r: my $x = 0; for lines() { if m/das/ and ( 3 < $x++ < 9 ) { .say } }

[06:10] <p6eval> rakudo f0aa5a:  ( no output )

[06:10] <tangentstorm> hrm

[06:10] <tangentstorm> r: my $x = 0; for lines() { if m/das/ && ( 3 < $x++ < 9 ) { .say } }

[06:10] <p6eval> rakudo f0aa5a:  ( no output )

[06:11] <tangentstorm> r: my $x = 0; for lines() { if .match(/das/) && ( 3 < $x++ < 9 ) { .say } }

[06:11] <p6eval> rakudo f0aa5a:  ( no output )

[06:11] <tangentstorm> back to the drawing board :)

[06:11] <adu> I don't think lines() works like that

[06:11] <adu> r: say "a\nb\nc".lines()

[06:11] <p6eval> rakudo f0aa5a: OUTPUT«a b c␤»

[06:12] <tangentstorm> r: say lines().perl

[06:12] <p6eval> rakudo f0aa5a: OUTPUT«("Land der Berge, Land am Strome,", "Land der Äcker, Land der Dome,", "Land der Hämmer, zukunftsreich!", "Heimat bist du großer Söhne,", "Volk, begnadet für das Schöne,", "vielgerühmtes Österreich,", "vielgerühmtes Österreich!", "", "Heiß umfehdet, wild umstritten"…

[06:12] <adu> where did that come from?!?

[06:12] <tangentstorm> it's a standard input file the bot is reading

[06:12] <tangentstorm> just so you have something to play with

[06:13] <adu> oh ok

[06:13] <adu> I thought p6eval was posessed by demons

[06:13] <tangentstorm> like if you'd said      perl6 -e"whatever you typed"  < whatever-that-file-is.txt

[06:13] <tangentstorm> german demons yeah

[06:13] <tangentstorm> gremlins ;)

[06:13] <adu> lol

[06:14] <adu> better than lorem ipsum

[06:15] <adu> or as I like to call it "pain itself"

[06:16] <adu> from Cicero's "The Purposes of Good and Evil"

[06:17] <tangentstorm> whoah. i always thought it was just gibberish.

[06:18] <tangentstorm> also i've heard people call it greeking :D

[06:18] <adu> tangentstorm: it is now because people use random latin generators

[06:19] <adu> it's not greek

[06:20] <adu> the full sentance that lorem ipsum comes from is "Nor again is there anyone who loves or pursues or desires to obtain pain of itself, because it is pain, but occasionally circumstances occur in which toil and pain can procure him some great pleasure."

[06:21] *** rindolf left
[06:22] *** rindolf joined
[06:28] <tangentstorm> yeah i know that's why the :D

[06:33] *** raiph joined
[06:38] <adu> good night

[06:38] *** Chillance_ joined
[06:38] *** adu left
[06:38] *** Chillance left
[06:44] <moritz> \o

[06:45] <FROGGS_> morning

[06:45] *** FROGGS_ is now known as FROGGS

[06:46] *** ilbot6 joined
[06:48] <moritz> r: sub f($x) { my $x }

[06:48] <p6eval> rakudo f0aa5a: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/Q5x1G3qAhF:1␤    ------> sub f($x) { my $x ⏏}␤»

[06:48] <moritz> r: sub f($x) { my $x }; say 'alive'

[06:48] <p6eval> rakudo f0aa5a: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $x␤    at /tmp/9TJLMeNhG5:1␤    ------> sub f($x) { my $x ⏏}; say 'alive'␤alive␤»

[06:57] *** woosley1 left
[06:57] <tangentstorm> how can i do:    `ls`    in perl 6?

[06:59] <moritz> r: say dir()

[06:59] <p6eval> rakudo f0aa5a: OUTPUT«star src .bashrc nom-inst1 toqast test3.pl .profile t nom-inst2 nom-inst toqast-inst toqast-inst2 examples Makefile .gitignore lib test2.pl .local bin rakudo p1 VERSION simple-tests .perlbrew std obj main.pl .lesshst nom niecza test.pl .cpanm log .bash_logout run T…

[06:59] <moritz> r: say dir()[0].perl

[06:59] <p6eval> rakudo f0aa5a: OUTPUT«IO::Path.new(basename => "star", directory => ".")␤»

[06:59] <tangentstorm> ah.. nm... can't do it.

[06:59] <tangentstorm> it's not the ls i want it's the input from the shell

[06:59] <moritz> qx/ls/

[06:59] <tangentstorm> or just any subprocess command

[07:00] <tangentstorm> qx doesn't work either

[07:00] <moritz> why/how not?

[07:00] <tangentstorm> because it isn't defined

[07:00] <moritz> erm, what?

[07:00] <tangentstorm> hm

[07:00] <moritz> moritz@jacq:~/p6/rakudo>./perl6 -e 'say qx/ls|head -n1/'

[07:00] <moritz> 2012.05.23.a4.pdf

[07:01] <FROGGS> $ perl6 -e 'say qx/ls -l/'

[07:01] <FROGGS> insgesamt 14220

[07:01] <FROGGS> -rw-rw-r-- 1 froggs froggs     3020 Feb  9 23:23 1.out

[07:01] <FROGGS> -rw-rw-r-- 1 froggs froggs     5433 Feb 21 20:13 201302212012.diff

[07:02] <FROGGS> has to work

[07:02] <moritz> it doesn't work on p6eval, for security reasons

[07:02] <FROGGS> ya, of course

[07:02] <tangentstorm> oh

[07:02] <tangentstorm> i was trying qx( whatever ) before

[07:02] <tangentstorm> which was working in perl5 ... ok. cool. thanks.

[07:02] <sorear> is it possible tangentstorm  is using qx( )

[07:02] <tangentstorm> qx/ls/ works in both perl 5 and perl 6

[07:02] <FROGGS> tangentstorm: no, something( is always a function call

[07:02] <sorear> ah

[07:02] <tangentstorm> qx(ls) works in perl 5 but not  perl 6

[07:03] <tangentstorm> and that's why i thought it wasn't defined.

[07:03] <FROGGS> r: sub if () { say 42 }; if( 7 == 0 ) { say "huh?" }

[07:03] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)␤at /tmp/8jaOCpBhfx:1␤------> sub if () { say 42 }; if( 7 == 0 ) ⏏{ say "huh?" }␤    expecting any of:␤        postfix…

[07:03] <FROGGS> r: sub if ($x) { say 42 }; if( 7 == 0 ) { say "huh?" }

[07:03] <p6eval> rakudo f0aa5a: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)␤at /tmp/_5vJN1bFu1:1␤------> sub if ($x) { say 42 }; if( 7 == 0 ) ⏏{ say "huh?" }␤    expecting any of:␤        postf…

[07:03] <moritz> tangentstorm: anything immediately followed by round parens is a subroutine call in Perl 6

[07:03] <sorear> tangentstorm: The rule here is: "Perl 6 has no keywords".  Anything that can be interpreted as a function call, will be.

[07:04] <FROGGS> tangentstorm: you can use all keywords as function names too

[07:04] <tangentstorm> so what is qx if it's not a keyword or or a function?

[07:04] <FROGGS> r: sub if ($x) { say 42 }; if( 7 == 0 )

[07:04] <p6eval> rakudo f0aa5a: OUTPUT«42␤»

[07:04] <moritz> tangentstorm: it's a quoting construct

[07:04] <moritz> just like "abc"

[07:05] <tangentstorm> fair enough ;)

[07:05] <tangentstorm> thanks

[07:05] <sorear> tangentstorm: also, qx () will work

[07:06] <tangentstorm> for qx/ls/ { say .uc }   # nice and DOSsy.. thanks :)

[07:06] <tangentstorm> interesting.

[07:06] *** sjohnson left
[07:06] <sorear> if you turn it around you can lose the braces

[07:06] <sorear> say .uc for qx (ls)

[07:06] <tangentstorm> say .uc ... cool 

[07:07] <sorear> in perl 5 you can do say uc for qx (ls), but we're more explicit about $_ usage

[07:08] <tangentstorm> so why isn't run implemented?   wouldn't it just be  sub run($cmd) { return qx/ $cmd / }  ?

[07:09] <sorear> run is implemented

[07:09] <tangentstorm> oh qx is quoting $cmd though.

[07:10] <sorear> also they're very different.  run lets STDOUT flow through, rather than collecting it

[07:11] <moritz> there's qqx// for a form of qx// that acts more like double quotes (interpolating)

[07:11] <sorear> how is run not working?

[07:11] <moritz> both run() and shell() are implemented in rakudo

[07:11] <moritz> though maybe not perfectly (error reporting is less than awesome)

[07:11] <tangentstorm> yeah

[07:11] <tangentstorm> it's there, sorry.

[07:12] <tangentstorm> i've got both the git version and the ubuntu package installed.

[07:12] <tangentstorm> the ubuntu version is lacking it.

[07:12] <sorear> they're also implemented in niecza, but only available if you have glib because the native C# process API sucks hard on unix

[07:12] <tangentstorm> i guess it's just behind

[07:12] <sorear> sucks so hard you can't even write shell()

[07:13] <sorear> how old is your ubuntu version?

[07:13] <tangentstorm> kubuntu 12

[07:13] <sorear> guessing more than a year if it's lacking run

[07:13] <tangentstorm> oh the actual package.. hang on

[07:13] <sorear> I meant ubuntoperl --version

[07:13] <tangentstorm> This is perl6 version 2012.04.1 built on parrot 4.3.0 revision 0

[07:16] <tangentstorm> okie doke, just won't use that. easy :)

[07:17] <tangentstorm> what are the chances my 10-year old compiler is going to work? :D

[07:18] <tangentstorm> j/k i already know it won't work.. the tests have been failing for years.

[07:19] <sorear> if it's 10 years old, it's not written in perl 6

[07:19] <sorear> (it may be written in an unrelated language with the same name and version number though :p/sigh)

[07:20] <tangentstorm> it's written in python of course

[07:20] <tangentstorm> i don't remember if it generates PIR or PASM

[07:21] <tangentstorm> http://pirate.he.sabren.com/viewvc.cgi/pirate/

[07:21] <tangentstorm> oh only 7 years? hmm.

[07:22] *** genehack left
[07:22] *** genehack joined
[07:24] <tangentstorm> http://pirate.he.sabren.com/viewvc.cgi/pirate/GUIDE?revision=1.7&view=markup  <- search for "while.py" ... what is this?

[07:25] <tangentstorm> i think maybe imc? to be fed into imcc ... intermediate code compiler?

[07:35] <sorear> that pirate is yours, eh?

[07:36] <tangentstorm> yeah

[07:36] <tangentstorm> another guy started it... i wrote most of the python, with lots of help (see credits) :)

[07:36] <sorear> I was thinking of a different pirate

[07:37] <sorear> bacek wrote a pirate a year or two ago, which was intended to replace IMCC

[07:38] <tangentstorm> yeah i saw it on the list of languages... also the original lua one was called pirate. :)

[07:50] *** raiph left
[08:00] *** berekuk joined
[08:02] *** berekuk left
[08:02] *** lizmat joined
[08:07] *** sjohnson joined
[08:07] *** lizmat left
[08:08] *** lizmat joined
[08:09] *** berekuk joined
[08:09] *** mj41 left
[08:10] *** mj41 joined
[08:10] *** berekuk left
[08:11] *** berekuk joined
[08:20] <lizmat> morning #perl6

[08:20] <FROGGS> morning lizmat 

[08:21] *** woolfy joined
[08:26] <moritz> \o *

[08:35] *** berekuk left
[08:40] *** wooden joined
[08:40] *** wooden left
[08:40] *** wooden joined
[08:42] *** berekuk joined
[08:48] <labster> o/ moritz

[08:51] <moritz> labster: fwiw I'm now spectesting a fix for RT #117583

[08:53] <sorear> o/ folks

[08:54] <moritz> s\orear

[08:54] *** berekuk left
[08:55] <dalek> rakudo/nom: 070f3a4 | moritz++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[08:55] <dalek> rakudo/nom: RT #117583: guard against NULL container spec

[08:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/070f3a4e94

[08:55] <dalek> roast: 2b710bd | moritz++ | S06-traits/is-copy.t:

[08:55] <dalek> roast: RT #117583: is copy param can be redeclared

[08:55] <dalek> roast: review: https://github.com/perl6/roast/commit/2b710bd01a

[08:56] <labster> cool.  not that I should have been using my there in the first place :/

[09:05] <masak> good forenoon, #perl6

[09:05] <masak> today's plan: t2 reviews :)

[09:05] <diakopter> luck++

[09:11] *** SamuraiJack joined
[09:14] <sorear> sleep.

[09:15] <masak> 'night, sorear.

[09:15] <moritz> labster: sure, but we take good error reporting seriously

[09:16] <labster> sorear++ is helping to improve my error reporting

[09:22] <sorear> just remember that I'm not always on the same side of the fence you are

[09:23] <sorear> i see things as "feature X has been implemented in way Y in every language ever and that's how I did it in niecza, so *of course* it behaves in way Z, that's just an obvious consequence of Y"

[09:25] <sorear> if you think that a feature could be changed to be less surprising to the majority of people, without causing other features to be more surprising at the same time (this is the case surprisingly often), speak up.  perl 6 is not targetted at compilers geeks

[09:25] <sorear> sleep for real now.  just had to challenge that ++. :D

[09:25] <diakopter> sorear-- ?

[09:26] <moritz> nah, sorear++ was appropriate :-)

[09:26] <diakopter> :)  sorear++ sorear++ for challenging it

[09:26] <masak> I think what sorear++ is saying makes sense.

[09:26] <masak> making compilers geeks happy should at best be a seconday concern ;)

[09:26] <diakopter> also, secondary

[09:27] <timotimo> "this is going to be secon ... wait for it ... dary!"

[09:28] <moritz> r: say 'a' ne 'a'|'b'

[09:28] <p6eval> rakudo 070f3a: OUTPUT«False␤»

[09:28] <moritz> n: say 'a' ne 'a'|'b'

[09:28] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«False␤»

[09:30] <masak> secondary*, yes.

[09:31] <moritz> > say 'a' ne 'a'|'b'|'c'

[09:31] <moritz> False

[09:31] <moritz> > if 'a' ne 'a'|'b'|'c' { say 42 }

[09:31] <moritz> 42

[09:31] <moritz> wtf? am I going insane now?

[09:31] <diakopter> http://www.yapcna.org/yn2013/talks/tag/%E8%9D%B6

[09:31] <timotimo> is this not how it's supposed to work?

[09:32] <masak> moritz: that looks... weird.

[09:32] <moritz> well, in a say() it returns False, but the body of the if-statement is executed anyway

[09:32] <moritz> I *hope* that's not as specced

[09:32] <moritz> oh, I have an idea

[09:33] <moritz> it's an optimization bug

[09:33] * moritz looks at timotimo accusingly

[09:34] *** dmol1 joined
[09:34] <tangentstorm> star: use Term::ANSIColor; say colored "or this ;-)", "blue";

[09:34] <p6eval> star 2013.02: OUTPUT«or this ;-)␤»

[09:34] <tangentstorm> r: use Term::ANSIColor; say colored "or this ;-)", "blue";

[09:34] <p6eval> rakudo 070f3a: OUTPUT«===SORRY!===␤Could not find Term::ANSIColor in any of: /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib, …

[09:34] <moritz> star: use Term::ANSIColor; say colored "or this ;-)", "blue";

[09:34] <tangentstorm> what is star?

[09:34] <p6eval> star 2013.02: OUTPUT«or this ;-)␤»

[09:34] <timotimo> moritz: oh my!

[09:35] <moritz> tangentstorm: a distribution of rakudo, docs, modules and module installer

[09:35] <timotimo> the tests didn't catch it! =o

[09:35] <tangentstorm> when i try to run this on rakudo perl6 from github it doesn't complain but nothing happens

[09:35] <timotimo> for the record, 'a' ne 'a'|'b'|'c' => False is correct, yes?

[09:35] <tangentstorm> i mean it does complain

[09:35] *** SamuraiJack left
[09:36] <moritz> tangentstorm: yes

[09:36] <moritz> timotimo: https://rt.perl.org/rt3/Ticket/Display.html?id=117579

[09:36] <tangentstorm> it says: Undeclared routine: colored

[09:36] <moritz> erm, meant timotimo 

[09:36] <moritz> tangentstorm: so it found the module, but didn't import the sub?

[09:36] <tangentstorm> i guess

[09:37] <tangentstorm> oddly the ==SORRY== is colored with ansi escape codes ;)

[09:37] <moritz> timotimo: the optimization should only rewrite the autothreading if the sub actually autothreads

[09:37] <moritz> tangentstorm: that's done by the compiler, without using the module :-)

[09:37] *** SamuraiJack joined
[09:37] <tangentstorm> hrm.. but if i say use Term::ANSIColoraoeuaeou; that works fine too

[09:37] <timotimo> moritz: ne does autothreading itself?

[09:38] <moritz> yes(ish)

[09:38] <labster> I guess I missed part of that discussion, but still, sorear++ anyway.

[09:38] <moritz> it redispatches to infix:<eq>, where the autothreading occurs

[09:38] <timotimo> or rather: it behaves differently if a junction is passed?

[09:38] <timotimo> oh! so that's why the not is moved outwards?

[09:38] <moritz> it has arguments with Mu type constraints (and not Any)

[09:38] <moritz> so no autothreading happens during the call itself

[09:40] <timotimo> so, since I already check if the operator comes from the setting, is special-casing this behavior acceptable? i fear not.

[09:40] <moritz> it might be

[09:40] <timotimo> i'll look at the code again

[09:40] *** domidumont joined
[09:41] <timotimo> i'll also write tests for this.

[09:41] <labster> I think that instead of defining ne and != as !eq and !==, we should just make that a special case for junctions.  Otherwise we'll just confuse people like me.

[09:41] <labster> Of course, confusion is pretty much a constant state around here, so it's not saying much.

[09:41] <labster> Also, pmichaud++ for pointing me towards that if/ne/junction bug.

[09:42] <timotimo> er, from what i gather the confusing thing is that 'a' ne 'b' | 'c' | 'd' is *not* the same as ('a' ne 'b' | 'a' ne 'c' | 'a' ne 'd')

[09:42] <timotimo> and that happens because ne and != already special-case junctions

[09:43] <labster> yeah, but that will pretty much always return true, so it's not useful

[09:43] <timotimo> hm. useful vs. least surprise?

[09:43] <tangentstorm> hmmm...  is a blank line required after a =cut ?

[09:44] <timotimo> hey wait

[09:44] <timotimo> there already are tests for this behavior. why aren't they complaining?

[09:45] <labster> tangentstorm: =begin pod, =end pod ?

[09:45] <timotimo> https://github.com/perl6/roast/blob/master/S03-junctions/autothreading.t#L294 - look here?

[09:46] <labster> I tend to prefer least surprise.   (not 'a' eq 'a'|'b' ) or ('a' !eq 'a'|'b') are always available

[09:46] <tangentstorm> =comment newline here -> \n use Term::ANSIColor; say colored "blue?", "blue";

[09:47] <timotimo> what i said above, about special casing and making sure things come from the core setting: that's not going to work, as i only check for the |, & and ^ operators

[09:47] <tangentstorm> :r =comment newline here -> \n use Term::ANSIColor; say colored "blue?", "blue";

[09:47] <moritz> timotimo: because the tests don't put the return value into the condition of an 'if', which is one of the few places where the optimization does its work

[09:47] <tangentstorm> :r =comment newline here -> ␤ use Term::ANSIColor; say colored "blue?", "blue";

[09:47] <tangentstorm> i can't demonstrate in here i guess

[09:48] <moritz> tangentstorm: use r: instead of :r

[09:48] <tangentstorm> gah

[09:48] <tangentstorm> r: =comment newline here -> ␤ use Term::ANSIColor; say colored "blue?", "blue";

[09:48] <p6eval> rakudo 070f3a: OUTPUT«===SORRY!===␤Could not find Term::ANSIColor in any of: /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib, …

[09:48] <tangentstorm> r: =comment newline here -> \n use Term::ANSIColor; say colored "blue?", "blue";

[09:48] <timotimo> moritz: m( of course you're right.

[09:48] <p6eval> rakudo 070f3a: OUTPUT«===SORRY!===␤Missing block␤at /tmp/oFiUFdaoTP:1␤------> =comment newline here -> \n ⏏use Term::ANSIColor; say colored "blue?"␤    expecting any of:␤        new term to be defined␤        constraint␤»

[09:49] <tangentstorm> r: =pod \n=cut \n say "this will not print"

[09:49] <p6eval> rakudo 070f3a: OUTPUT«===SORRY!===␤Undeclared routines:␤    cut used at line 1␤    n used at line 1␤␤»

[09:49] <tangentstorm> r: =pod␤=cut␤ say "this will not print"

[09:49] <p6eval> rakudo 070f3a: OUTPUT«this will not print␤»

[09:50] <tangentstorm> eh

[09:51] <tangentstorm> http://pastebin.com/tLWWSbaN

[09:51] <tangentstorm> whatever line is after the =cut is ignored

[09:51] <moritz> p6eval leaves \n alone, and only translates ␤ to newlines

[09:51] <timotimo> moritz: can i look up the chaining op in the @!block_stack and inspect its .signature and see if any of the types are Any or derived from Any with a simple smartmatch?

[09:51] <moritz> tangentstorm: =cut doesn't do what you think in Perl 6 pod

[09:52] <moritz> timotimo: yes, I think so

[09:52] <timotimo> i'll try that then :)

[09:52] <moritz> timotimo: you can look up the Any type object, and then simply use nqp::istype($type_constraint, $Any)

[09:52] <timotimo> great

[09:53] <timotimo> the Optimizer already has a $!Mu for the Mu type, so i'll duplicate that code to cache a $!Any, too

[09:53] <tangentstorm> r: =comment␤ say "this is line 2 but will not print"

[09:53] <tangentstorm> n: =comment␤ say "this is line 2 but will not print"

[09:53] <tangentstorm> <shrug>

[09:53] * tangentstorm gives up and adds the extra newline

[09:53] <tangentstorm> i don't know if it's a bug or if that's just how pod works

[09:54] <p6eval> rakudo 070f3a: OUTPUT«this is line 2 but will not print␤»

[09:54] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«this is line 2 but will not print␤»

[09:54] <tangentstorm> but you need a blank line after the =xxx line

[09:55] <moritz> tangentstorm: you should read the specs for Perl 6 pod some day :-)

[09:55] <tangentstorm> yeah.. it's been a long time

[09:56] <tangentstorm> but in any case i'm getting different behavior here and on my machine

[09:56] <tangentstorm> with the same code

[09:58] <tangentstorm> anyway that was why the ansi import failed for me

[09:58] <tangentstorm> or failed silently

[09:59] <tangentstorm> oh. perl6 doesn't use cpan?

[10:01] *** berekuk joined
[10:01] <timotimo> moritz: if there are multiple constraints on one of the parameters, i'll have to check that one of them matches against Any, right? because if i had Mu and Any, both constraints would have to match, do i understand correctly?

[10:02] <labster> tangentstorm: no, we use panda and http://modules.perl6.org/

[10:02] <tangentstorm> stackoverflow leads me to neutro, "which comes with the latest version of rakudo" but i don't have that either :/

[10:02] <moritz> timotimo: I think it's enough to check the nominal type

[10:02] <timotimo> hehe, that's a very old answer.

[10:02] <timotimo> tangentstorm: gimme the link and i'll add a comment

[10:03] <tangentstorm> http://stackoverflow.com/questions/3147776/is-there-a-working-cpan-cpan6-like-project-for-perl-6

[10:03] <tangentstorm> i searched for perl6 cpan

[10:03] <timotimo> moritz: thanks! my code is almost ready and i'll run a few tests on it

[10:04] <timotimo> yeah that's from 2010

[10:04] * moritz should edit his answer

[10:05] <tangentstorm> ==> Bootstrapping Panda    ... thanks :)

[10:06] <tangentstorm> perhaps i will port AI::Fuzzy at some point then :)

[10:06] <moritz> http://stackoverflow.com/a/3148098/14132 updated

[10:08] *** domidumont left
[10:09] <tangentstorm> thanks :)

[10:09] *** woosley joined
[10:09] *** domidumont joined
[10:13] <timotimo> and if the object isn't found in the lexical chain, i'll just abort the optimization

[10:18] <masak> so, who wants to release Rakudo on Thursday? I'm willing to do June if someone signs up for April.

[10:20] <timotimo> hm. now the optimization bails out for simple examples, too.

[10:34] *** cognominal__ left
[10:35] *** sjohnson left
[10:35] <Tene> timotimo: you volunteered for a release yet?

[10:36] *** cognominal joined
[10:38] <timotimo> Tene: timotimo isn't here at the moment, feel free to leave a message

[10:38] <Tene> timotimo: tell timotimo that he should volunteer for a release

[10:44] *** bonsaikitten is now known as DrEeevil

[10:45] <timotimo> hm, Signature.params creates a List. how do i iterate over such a List in nqp? something like p6decont?

[10:45] <timotimo> oh, probably just an integer index

[10:47] <tangentstorm> http://i.imgur.com/O2FkZDd.png yay :)

[10:48] <timotimo> could use some pretty-printing :D

[10:48] <timotimo> i mean whitespace

[10:48] <tangentstorm> that's what comes out of antr

[10:48] <timotimo> ah, ok

[10:49] <tangentstorm> antlr4 i mean ... you can either get that or a list of parse events, one per line

[10:49] <jnthn> timotimo: If you look up the attribute directly then I think it's just an NQP array at that level..

[10:49] <yoleaux> 12 Apr 2013 23:35Z <FROGGS> jnthn: that I can "require PATH" now (pushed), but can't import subs

[10:50] <yoleaux> 12 Apr 2013 23:35Z <FROGGS> jnthn: I've got this patch locally applied, test file is there too: https://gist.github.com/FROGGS/a9ef1432e1f9d37e9770

[10:50] <yoleaux> 12 Apr 2013 23:39Z <FROGGS> jnthn: won't write tests now, but will go deeper into the rabbit hole

[10:50] <tangentstorm> Is there a built-in system for tree transformation? I haven't seen anything like that yet.

[10:56] <timotimo> jnthn: oh, i forgot that i can just be naughty and look up private attributes on objects

[11:02] <timotimo> i don't know what i've done o_O   -   Code ref 'Bool' does not exist in serialization context

[11:04] <jnthn> Um.

[11:04] <jnthn> Something weird, that's for sure.

[11:05] <timotimo> oh, yes, my code is utterly wrong anyway :)

[11:06] <jnthn> I've never actually seen that error be produced before :)

[11:07] <timotimo> are you interested in the sillyness i wrote to cause it?

[11:07] <jnthn> Only mildly :)

[11:07] <timotimo> i'll not show my silly mistake in that case

[11:07] <jnthn> I know where it comes from, just not how to get there without doing something contrived :)

[11:07] <jnthn> I guess silly mistake could cut it though :)

[11:25] *** xinming left
[11:27] *** xinming joined
[11:30] *** pecastro joined
[11:34] *** cognominal left
[11:35] *** Celelibi left
[11:35] *** cognominal joined
[11:35] <timotimo> will target=optimize no longer output the result of optimisation?

[11:36] <timotimo> oh, it does

[11:48] *** BenGoldberg joined
[11:52] <timotimo> huh. i no longer think that the code i wrote is particularly silly

[12:07] <FROGGS> hi there

[12:09] *** PacoAir joined
[12:19] <masak> FROGGS! \o/

[12:19] <FROGGS> masak! \o/

[12:19] <FROGGS> :o)

[12:20] *** eiro left
[12:20] <FROGGS> masak: what's rin... err, what's up?

[12:26] <masak> well, since I'm in my kitchen, a rice paper lamp is up. it's currently on.

[12:27] <masak> (currently making lunch. after that, meaning to dive into t2 reviewing.)

[12:27] *** nebuchadnezzar left
[12:28] *** nebuchadnezzar joined
[12:29] <FROGGS> *g*

[12:30] <FROGGS> I'm not sure what I can do next... having problems to get `require PATH` to work, and this feature would help me pretty much right now

[12:31] <FROGGS> hmmm, maybe...

[12:31] * FROGGS has an idea

[12:32] *** Ben_Goldberg joined
[12:33] *** tgt joined
[12:33] *** berekuk left
[12:33] *** Ben_Goldberg left
[12:34] *** berekuk joined
[12:34] *** BenGoldberg left
[12:36] *** berekuk left
[12:36] *** lard joined
[12:45] *** crab2313 joined
[12:56] *** lard left
[12:56] *** crab2313 left
[12:58] *** rindolf left
[12:59] *** Vlavv` joined
[12:59] *** Vlavv left
[13:02] *** rindolf joined
[13:16] *** tgt_ joined
[13:26] *** tgt_ left
[13:38] *** lue left
[13:40] *** berekuk joined
[13:50] *** lue joined
[14:01] *** PacoAir left
[14:04] *** sjohnson joined
[14:12] *** gdey joined
[14:21] *** Exodist left
[14:21] *** Exodist joined
[14:35] *** gdey left
[14:41] *** woosley left
[14:56] *** jferrero left
[14:58] *** frd|afk left
[15:02] *** yeltzooo left
[15:03] *** cibs left
[15:04] *** yeltzooo joined
[15:08] *** asogani joined
[15:08] *** asogani is now known as anant__

[15:22] *** anant__ left
[15:24] *** anant__ joined
[15:24] *** raiph joined
[16:05] *** dmol1 left
[16:12] *** eiro joined
[16:17] *** domidumont1 joined
[16:17] <masak> I don't think we ever got an RT ticket for http://irclog.perlgeek.de/perl6/2012-12-12#i_6236512

[16:20] *** domidumont left
[16:22] <masak> rn: https://gist.github.com/masak/5379061

[16:22] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«Line 1␤Line 2␤Line 3␤Line 4␤␤»

[16:22] <p6eval> ..rakudo 070f3a: OUTPUT«Asked to remove 4 spaces, but the shortest indent is 0 spaces  in block  at /tmp/HZMtZbv4Ag:3␤␤Line 1␤Line 2␤Line 3␤Line 4␤␤»

[16:22] * masak submits rakudobug

[16:44] <colomon> masak: do you reckon niecza's behavior is correct?

[16:44] <masak> colomon: yes, I do.

[16:46] <masak> in effect, heredoc de-indentataion should be performed at the AST level.

[16:46] <masak> so that interpolated strings aren't de-indented.

[16:47] <lizmat> note, that even if you prefix {foo} with some more text

[16:48] <lizmat> like "Line 2{foo}

[16:48] <lizmat> it gives the same error, which is completely counterintuitive

[16:49] <masak> right.

[16:49] <masak> the problem right now is actually Line 3.

[16:50] <masak> which the de-indenter expects to be indented, but it isn't.

[16:50] <masak> and it shouldn't be.

[16:50] <lizmat> rn: https://gist.github.com/lizmat/5379159

[16:50] <p6eval> rakudo 070f3a, niecza v24-37-gf9c8fc2: OUTPUT«Line 1␤Line 2Line 3␤Line 4␤␤»

[16:50] *** anant__ left
[16:50] <lizmat> huh?

[16:50] <masak> lizmat: need a newline to expose the behavior.

[16:50] <masak> lizmat: "\nLine 3"

[16:50] <lizmat> ack, indeed

[16:51] <lizmat> then it's even more counterintuitive

[16:51] <lizmat> it shouldn't ever matter what is happening inside the sub, I would think

[16:51] <masak> that's what the RT ticket is all about.

[16:51] <masak> it shouldn't matter what is happening in interpolated strings.

[16:52] <masak> current Rakudo implementation does interpolation-then-indentation, because it's easier.

[16:52] <masak> it should do indentation-then-interpolation (like Niecza and STD.pm6), because it's intuitive to the user.

[16:53] <lizmat> is it not a compile time optimization that is biting us?

[16:53] <masak> no.

[16:53] <masak> it's easier than that.

[16:53] <masak> Rakudo is doing de-indentation of the heredoc and interpolation in the wrong order.

[16:54] <masak> see above explanation ;)

[16:54] <lizmat> ack, just verified it is not a compile time optimization :-)

[16:54] <masak> the trouble with doing de-indentation *before* interpolation is that the de-indent has to happen at compile time, basically.

[16:54] <masak> jnthn++ who gave us the current Rakudo implementation, balked a bit at that.

[16:55] *** gdey joined
[16:56] <lizmat> why would you do this at run time then?  I mean, every time you execute that say ?

[16:57] <masak> because each time, the interpolating things may differ.

[16:57] <masak> "a{foo()}b" is sugar for "a" ~ foo() ~ "b"

[16:58] <masak> also, jnthn invoked "easier to explain" as an advantage of the current model.

[16:58] <jnthn> I'm fine for it to be changed, it somebody has a patch :)

[16:59] <colomon> rn: https://gist.github.com/colomon/5379188

[16:59] * masak .oO( passive-cooperative )

[16:59] <p6eval> rakudo 070f3a: OUTPUT«Asked to remove 4 spaces, but the shortest indent is 0 spaces  in block  at /tmp/lILW1aFZME:3␤␤Line 1␤    Line 2␤Line 3␤Line 4␤␤»

[16:59] <p6eval> ..niecza v24-37-gf9c8fc2: OUTPUT«Line 1␤    Line 2␤Line 3␤Line 4␤␤»

[17:00] <jnthn> It already does de-indent at compile time for the non-interpolation case, iirc.

[17:01] <masak> oh, nice.

[17:02] <colomon> btw, de-indent was the #1 reason I initially got excited about p6 -- and yet I keep forgetting people have actually implemented it now!

[17:03] <masak> ;)

[17:04] * lizmat will think about her heredoc expectations over some Thai dinner

[17:05] *** woolfy left
[17:05] <colomon> Thai++

[17:05] *** lizmat left
[17:06] * colomon 's C++ generating p5 code will be much, much cleaner when he finally re-implements it in p6

[17:09] * masak has a great idea for an application written in Perl 6, but very few tuits

[17:13] *** erkan left
[17:15] *** cibs joined
[17:17] <japhb> moritz, dunno if someone has already mentioned this, but since I'm at 8:55 in the irclogs -- 'RT #123456:' is getting turned into 'RT :' in the logs.  I checked the page source and it's that way in the HTML, not just a display artifact.

[17:17] *** gdey left
[17:25] *** gtodd left
[17:35] <moritz> that kinda sucks

[17:40] <japhb> nodnod  :-(

[17:41] <moritz> the good news is that it's logged correctly, so no data lost

[17:43] <japhb> That's definitely a good thing.

[17:44] <dalek> nqp: 71fab2d | jnthn++ | src/core/ (3 files):

[17:44] <dalek> nqp: Clean up JVM/Parrot divergences in src/core.

[17:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/71fab2d059

[17:44] <dalek> nqp: 84d8cc0 | jnthn++ | src/how/RoleToClassApplier.pm:

[17:44] <dalek> nqp: Fix to role collision handling from NQP JVM.

[17:44] <dalek> nqp: 

[17:44] <dalek> nqp: The collisions list is just names, not code objects.

[17:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/84d8cc08f7

[17:45] <moritz> the offending commit to ilbot is 2e4526c85dbd3a8fa6943a2493e8863e08f1ca1d

[17:46] <moritz> ah, and I see why

[17:49] * moritz tries a fix

[17:49] <moritz> japhb: thanks, fixed

[17:50] <japhb> moritz++

[17:50] *** dukeleto joined
[17:50] <dukeleto> o/

[17:50] <japhb> o/

[17:50] <jnthn> o/

[17:51] * dukeleto got sick of all the "$project is dead" FUD : https://twitter.com/dukeleto/status/323116597575307264

[17:51] <FROGGS> o/

[17:52] <japhb> Good on ya, dukeleto

[17:53] <dalek> nqp-jvm-prep: ada971f | jnthn++ | nqp-src/NQPCORE.setting:

[17:53] <dalek> nqp-jvm-prep: Clean up JVM/Parrot divergence in NQPCORE.setting.

[17:53] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ada971fc1f

[17:56] <japhb> Catching up in the logs to where I first started talking that day always gives me a sense of temporal torque

[17:57] <jnthn> .oO( temporal talk )

[17:59] <japhb> .tell tangentstorm Since it looks like no one responded -- yes, it's intended that you can treat a file as both a module and a program.  MAIN should only be called when the file is being run as the top-level program, so you can define a MAIN in your module to allow it to do something useful when run directly.

[17:59] <yoleaux> japhb: I'll pass your message to tangentstorm.

[17:59] <dalek> nqp: dacc4d7 | jnthn++ | src/QAST/ (7 files):

[17:59] <dalek> nqp: Resolve divergence in QAST nodes.

[17:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dacc4d79e0

[17:59] <dalek> nqp-jvm-prep: ad1a19f | jnthn++ | nqp-src/QASTNodes.nqp:

[17:59] <dalek> nqp-jvm-prep: Resolve divergence in QAST nodes.

[17:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ad1a19fe4a

[17:59] <tangentstorm> i'm here ;)

[17:59] <yoleaux> 17:59Z <japhb> tangentstorm: Since it looks like no one responded -- yes, it's intended that you can treat a file as both a module and a program.  MAIN should only be called when the file is being run as the top-level program, so you can define a MAIN in your module to allow it to do something useful when run directly.

[18:00] <tangentstorm> awesome. thanks, japhb :)

[18:00] <japhb> np.  :-)

[18:01] <japhb> moritz, did you ever figure out what caused the "Failure at end of for loop" sink problem?

[18:01] <FROGGS> basically if one thinks .oO( can Perl 6 do it way A or way b? ) you can answer with: Yes! (both)

[18:02] <FROGGS> japhb: does this still happen? moritz made for loops eager ten days ago, you maybe want to re-check

[18:03] <japhb> FROGGS, this was more recent -- I came across it a couple days ago.

[18:04] <FROGGS> ahh, k

[18:04] <FROGGS> just wanted to mention

[18:05] <japhb> Good thought though -- always good to make sure a problem report is actually still relevant.  :-)

[18:19] *** erkan joined
[18:19] *** erkan left
[18:19] *** erkan joined
[18:31] <masak> yoleaux: isn't it that way already? https://rt.perl.org/rt3/Ticket/Display.html?id=114354 has been resolved.

[18:32] *** kaare_ joined
[18:32] <masak> yoleaux: (and I just tested locally and MAIN is only called if it's in the script file run, not if it's in a use'd module)

[18:33] *** lizmat joined
[18:33] <lizmat> ast: say 1

[18:33] <lizmat> rn: use foo

[18:33] <p6eval> rakudo 070f3a: OUTPUT«===SORRY!===␤Could not find foo in any of: /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib, /home/p6eval…

[18:33] <p6eval> ..niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: System.Exception: Unable to locate module foo in /home/p6eval/niecza/lib /home/p6eval/niecza␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/NieczaPathSearch.pm6 line 23 (NieczaPathSearc…

[18:33] <lizmat> rn: use "foo"

[18:33] <p6eval> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'use' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home…

[18:33] <p6eval> ..rakudo 070f3a: OUTPUT«===SORRY!===␤Undeclared routine:␤    use used at line 1␤␤»

[18:33] <japhb> masak, why are you talking to yoleaux?

[18:34] <masak> japhb: oops, level mixup ;)

[18:34] <masak> japhb: I see now that I really meant to be talking to you.

[18:34] <japhb> heh

[18:35] <lizmat> is this a bug?

[18:35] <lizmat> $ perl6 --target=ast -e 'use foo'

[18:35] <lizmat> ===SORRY!===

[18:35] <lizmat> Could not find foo in any of:

[18:35] <masak> japhb: now that I re-read what you wrote, I'm not sure you were implying "but it's NYI".

[18:35] <masak> lizmat: no, I don't think so.

[18:35] <masak> lizmat: you can't compile something without following module dependencies.

[18:36] <japhb> masak, Oh I see, you're confirming that it is implemented.  Yes, I was pretty sure it was, but not quite 100%, so thank you.  :-)

[18:36] <masak> lizmat: (because the use'd module may change what it means to parse things in the current compunit)

[18:37] <lizmat> ack, gotcha, so it bails before it can generate the AST output

[18:40] *** gdey joined
[18:43] <masak> yeah, it fails during compilation because it doesn't find foo.pm

[18:45] <dalek> rakudo/nom: b5bdbe4 | (Geoffrey Broadwell)++ | src/core/Str.pm:

[18:45] <dalek> rakudo/nom: Convert pir::const::CCLASS_PRINTING to nqp::

[18:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b5bdbe459f

[18:50] *** lizmat left
[18:52] <dalek> nqp-jvm-prep: d6101f5 | jnthn++ | nqp-src/QRegex.nqp:

[18:52] <dalek> nqp-jvm-prep: Remove commented pir:: and replace with nqp::.

[18:52] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/d6101f50bd

[18:52] *** lizmat joined
[19:05] <dalek> nqp: 49dd649 | jnthn++ | src/QRegex/NFA.nqp:

[19:05] <dalek> nqp: Remove some bogus type constraints.

[19:05] <dalek> nqp: 

[19:05] <dalek> nqp: Since we typically calculate with floats in NQP, we can't rely on the

[19:05] <dalek> nqp: arguments being int here. Somehow we get away with this on Parrot, but

[19:05] <dalek> nqp: NQP JVM enforces them more Perl 6-ishly. Also, they may have led to

[19:05] <dalek> nqp: reboxing, so we may be better off without them anyway.

[19:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/49dd649ba2

[19:05] <dalek> nqp: 008a923 | jnthn++ | src/QRegex/NFA.nqp:

[19:05] <dalek> nqp: Remove misleading commented out code and a hack.

[19:05] <dalek> nqp: 

[19:05] <dalek> nqp: The code explained what the C op it was replaced with at the point it

[19:05] <dalek> nqp: was translated. However, now things have evolved, so better to just

[19:05] <dalek> nqp: toss it.

[19:10] *** lizmat left
[19:12] *** lizmat joined
[19:12] *** lizmat left
[19:19] <dalek> nqp: b48d067 | jnthn++ | src/QAST/Operations.nqp:

[19:19] <dalek> nqp: Add nqp::setelems.

[19:19] <dalek> nqp: 

[19:19] <dalek> nqp: To abstract away pir::assign__0Pi.

[19:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b48d067581

[19:19] <dalek> nqp: d8426fc | jnthn++ | src/stage0/ (9 files):

[19:19] <dalek> nqp: Update bootstrap to get some nqp:: ops.

[19:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d8426fce7d

[19:19] <dalek> nqp: a3d1061 | jnthn++ | src/QRegex/Cursor.nqp:

[19:19] <dalek> nqp: Clean up Cursor and related classes.

[19:19] <dalek> nqp: 

[19:19] <dalek> nqp: Means that most code now matches the JVM version.

[19:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a3d106155f

[19:19] <dalek> nqp-jvm-prep: 57b51e0 | jnthn++ | nqp-src/QRegex.nqp:

[19:19] <dalek> nqp-jvm-prep: Updates to Cursor to sync with Parrot NQP.

[19:19] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/57b51e0540

[19:19] *** PacoAir joined
[19:20] <lue> hello world o/

[19:20] <lue> ( and jnthn++ )

[19:21] * jnthn is out of this world :P

[19:23] *** SamuraiJack left
[19:30] <masak> lue! \o/

[19:30] *** erkan left
[19:30] *** erkan joined
[19:30] *** erkan left
[19:30] *** erkan joined
[19:32] <dalek> nqp: 67270f7 | jnthn++ | src/QRegex/P6Regex/Grammar.nqp:

[19:32] <dalek> nqp: Add SC handle uniqueness fix from NQP JVM.

[19:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/67270f7475

[19:37] *** lue left
[19:37] *** lue joined
[19:41] <sorear> o/ all

[19:42] <japhb> o/

[19:42] <japhb> moritz, pull request for you for json.

[19:42] <jnthn> o/ sorear 

[19:42] <japhb> moritz, if you accept that one, I'll do a matching PR for panda's copy to get them back in sync.

[19:44] <dalek> nqp-jvm-prep: e2519bd | jnthn++ | / (2 files):

[19:44] <dalek> nqp-jvm-prep: Implement nqp::setelems, nqp::flip.

[19:44] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e2519bdc8f

[19:44] <dalek> nqp-jvm-prep: 8ecef05 | jnthn++ | nqp-src/NQPP6QRegex.pm:

[19:44] <dalek> nqp-jvm-prep: Bring in latest P6Regex fixes.

[19:44] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/8ecef052b8

[19:44] <sorear> I thought nqp already ran on the jvm

[19:45] <sorear> or is that a supposed to be "prepping nqp-jvm (for Rakudo)"

[19:45] <jnthn> sorear: Yeah. The nqp-jvm-prep repo has copies of lots of things that have diverged in various places.

[19:46] <jnthn> sorear: Currently I'm reconciling those, so I can get the JVM support into the main nqp repo

[19:46] <jnthn> And yes, this is in prep for Rakudo porting also.

[19:46] <sorear> jnthn: so presently nqp-jvm-prep is the only working nqp/jvm?

[19:46] <jnthn> sorear: Yeah. I did the port in a separate repo.

[19:46] <sorear> nifto anyway

[19:47] <jnthn> Now re-unifying.

[19:47] <moritz> grand unification \o/

[19:49] <dukeleto> jnthn++ # a pleasure to watch the magic from a distance

[19:52] * dukeleto reminds the locals that he is here to facilitate communication between parrot and anybody using parrot

[19:53] <dukeleto> please let me know if there are any parrot issues that are especially blocking anybody that don't have current forward momentum

[19:53] * dukeleto goes back in his cave

[19:57] *** domidumont1 left
[19:59] *** mtk left
[20:01] <dalek> panda: 2bec3b1 | (Geoffrey Broadwell)++ | ext/JSON__Tiny/ (6 files):

[20:01] <dalek> panda: Update JSON::Tiny to latest moritz/json

[20:01] <dalek> panda: review: https://github.com/tadzik/panda/commit/2bec3b1863

[20:01] <dalek> panda: b239b23 | japhb++ | ext/JSON__Tiny/ (6 files):

[20:01] <dalek> panda: Merge pull request #43 from japhb/master

[20:01] <dalek> panda: 

[20:01] <dalek> panda: Update JSON::Tiny to latest from moritz/json

[20:01] <dalek> panda: review: https://github.com/tadzik/panda/commit/b239b23448

[20:02] <masak> dukeleto: you said today that Parrot has excellent threading support. if that's so, then what's stopping us from having «+» et all hyper-thread on Rakudo?

[20:02] <masak> *et al.

[20:02] <dukeleto> masak: somebody with the tuits to make it happen, i guess

[20:03] <dukeleto> masak: i think making the simplest possible <<+>> that could work is a good goal

[20:03] <dukeleto> masak: i am willing to help with this effort, but unfortunately my time is split between many things right now

[20:03] <dukeleto> masak: it cannot be only me

[20:03] <dukeleto> masak: but i can help

[20:04] <dukeleto> masak: i need to leave very soon, but i would love to talk more about thi

[20:04] <dukeleto> this

[20:04] *** adu_ joined
[20:04] <masak> ok.

[20:04] <masak> just wondering.

[20:04] <moritz> iirc there was some issues with how rakudo and/or nqp handle lexicals that was incompatible with parrot threads

[20:04] * japhb removes another item from his mental clutter

[20:04] <dukeleto> masak: what can i do to help you? or somebody that you delegate to?

[20:05] <masak> dukeleto: I'm actually not much involved in threading, I'm just curious why there's a disconnect at present.

[20:05] *** mtk joined
[20:05] * adu_ wonders how lexical and threads could possibly interact

[20:05] <dukeleto> https://github.com/parrot/parrot/issues/936 is where things are

[20:05] <dukeleto> adu_: :)

[20:05] <dukeleto> adu_: in devious devious ways

[20:06] <dukeleto> parrot has insufficient docs

[20:06] <adu_> dukeleto: agreed

[20:06] <dukeleto> I can completely and truthfully admit that.

[20:06] <dukeleto> That is not because Parrot hates it's users. It is due to a lack of developer time*motivation

[20:07] <masak> *nod*

[20:07] <adu_> we need to throw some prize money at parrot developers

[20:08] <adu_> like $100 for whoever writes the thread docs

[20:08] <diakopter> I'll pay you $100 not to do that

[20:08] <dukeleto> https://www.gittip.com/on/github/parrot/

[20:08] <dukeleto> or gittip.com/dukeleto :)

[20:08] <adu_> diakopter: why?

[20:08] <dukeleto> but it is not $

[20:08] <dukeleto> it is time*motivation

[20:08] <dukeleto> $ helps some people make time, though

[20:09] <adu_> also, if history has proven anything, it's that money poorly spent generally makes the situation worse

[20:09] <diakopter> thank you

[20:10] <dalek> nqp: 08d0103 | jnthn++ | src/HLL/Actions.pm:

[20:10] <dalek> nqp: s/atkey/atpos/ fix from NQP JVM.

[20:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/08d0103677

[20:10] <dalek> nqp: ea56c24 | jnthn++ | src/ (3 files):

[20:10] <dalek> nqp: Various tweaks to HLL and NQP for JVM compat.

[20:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ea56c2433f

[20:10] <adu_> for example, the U.S. has spent trillions on the drug war over the past 10 years, and what did we get? face-eating-zombies...

[20:10] <dukeleto> adu_: wasting trillions of $ is not one of the problems of parrot developers

[20:11] <dukeleto> adu_: but i get your drift :)

[20:11] <dukeleto> i think a meatspace hackathon specifically between parrot + rakudo (+whoever else I don't know about) is needed to solve the problem.

[20:11] <dukeleto> it could be at YAPC::NA this year

[20:12] <diakopter> no one in parrot is going to yapc::na that I know of

[20:12] <dukeleto> diakopter: does that mean that no parrot devs will be there?

[20:12] <dukeleto> diakopter: i was planning on going, and there has been talk by Util++ to organize a hackathon

[20:13] <diakopter> okay, I didn't see you on the registered list

[20:13] <dukeleto> diakopter: cotto and chromatic will no doubt be there (dare I speak the name!)

[20:13] <dukeleto> diakopter: i am not

[20:13] <diakopter> chromatic is not going

[20:13] <dukeleto> oh really! What a heretic.

[20:13] <dukeleto> diakopter: i was busy and never submitted my talks or anything

[20:14] * dukeleto has had some stressful IRL events recently that have been serious time sinks

[20:14] <diakopter> there are plenty of folks committed to the hackathons before and after the conf

[20:14] <diakopter> onsite

[20:15] <dukeleto> so it sounds like just getting enough parrot people there will solve the problem

[20:15] <diakopter> cotto is not registered either

[20:16] <dukeleto> diakopter: he has been MIA lately

[20:16] <adu_> also, I think it would be super-amazing if each Parrot instruction had it's own page

[20:16] <dukeleto> adu_: define "parrot instruction"

[20:16] <adu_> for example, each x86 instruction has 2-3 pages describing it

[20:16] * diakopter has a conniption fit

[20:16] <adu_> dukeleto: for example, fdiv_*_*

[20:17] <dukeleto> adu_: i don't know what "x86 instruction" means in this context. Are you talking about parrot opcodes?

[20:17] <dukeleto> adu_: ah, opcodes

[20:17] <adu_> dukeleto: what's the difference between instructions and opcodes?

[20:17] <dukeleto> adu_: we call them opcodes in parrot :)

[20:17] <adu_> I call them instructions, regardless of VM/ real M

[20:17] <dukeleto> adu_: synonyms, as far as i know. parrot might call something else an instruction, though

[20:18] <dukeleto> adu_: parrot.github.com

[20:18] <dukeleto> adu_: if you would like to make a pull request against that, with your idea of what the page of fdiv_*_* would look like, that would help

[20:18] <adu_> I can see there being a difference between instruction *code* and instruction *usage*

[20:18] <dukeleto> adu_: https://github.com/parrot/parrot.github.com

[20:18] <adu_> oo

[20:19] <dukeleto> adu_: that is our experimental website repo, with the history of all parrot docs for every version of parrot

[20:19] <dukeleto> adu_: and various things not on parrot.org

[20:19] <adu_> one thing I would want to know is *if* you don't add any instructions, then what number would it be in the PBC file

[20:19] <dukeleto> adu_: these are good questions for parrot-dev. I must head out the door.

[20:20] <adu_> ok

[20:23] *** rindolf left
[20:33] <diakopter> dukeleto: yes, "getting enough parrot people there" would solve the problem.  but the room holds only 54 people...

[20:39] <diakopter> the only person still with the project who's contributed VM code in the past 6 months is you

[20:40] <diakopter> in the master branch, anyway

[20:40] <diakopter> (well, and the non-committer whose stuff you merged)

[20:48] <dalek> nqp-jvm-prep: 0888df0 | jnthn++ | / (2 files):

[20:48] <dalek> nqp-jvm-prep: Add a cheaty nqp::sprintf(...).

[20:48] <dalek> nqp-jvm-prep: 

[20:48] <dalek> nqp-jvm-prep: Based on code by thecabinet++. Mostly added so we can uncomment the

[20:48] <dalek> nqp-jvm-prep: couple of places NQP uses it, but should basically work. An NQP

[20:48] <dalek> nqp-jvm-prep: implementation of this would work even better, though.

[20:48] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/0888df02ab

[20:48] <dalek> nqp-jvm-prep: 140c9ba | jnthn++ | nqp-src/ (2 files):

[20:48] <dalek> nqp-jvm-prep: A little more syncing with Parrot NQP.

[20:48] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/140c9bab46

[20:49] *** raiph left
[20:53] *** raiph joined
[20:54] <dalek> nqp: d46b465 | jnthn++ | src/HLL/ (2 files):

[20:54] <dalek> nqp: Final couple of syncs with NQP JVM.

[20:54] <dalek> nqp: 

[20:54] <dalek> nqp: Remaining differences are bits that need to be backend specific.

[20:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d46b46539a

[20:56] *** kaare_ left
[20:57] *** adu_ left
[21:00] <lue> r: my @a = 1,2,3,2,1; say (@a,3).uniq

[21:00] <p6eval> rakudo b5bdbe: OUTPUT«1 2 3␤»

[21:00] <lue> r: my @a = 1,2,3,2,1; say (@a.uniq,3).uniq

[21:00] <p6eval> rakudo b5bdbe: OUTPUT«get_attr_str() not implemented in class 'Coroutine'␤current instr.: 'print_exception' pc 111608 (src/gen/CORE.setting.pir:50161) (src/gen/CORE.setting:9722)␤called from Sub '' pc 277567 (src/gen/CORE.setting.pir:121659) (src/gen/CORE.setting:5639)␤called from Sub '…

[21:00] <lue> any ideas as to why this fails?

[21:02] <sorear> pretty, secondary error

[21:02] <japhb> jnthn, does this mean that you will be able to merge the nqp and nqp-jvm-prep repos tonight, or is there still non-trivial effort in making the backend-specific bits share one repo?

[21:02] <jnthn> japhb: It's more work that I'll manage tonight.

[21:02] <labster> r: my @a = 1,2,3,2,1; say (@a.uniq.flat,3).uniq

[21:02] <p6eval> rakudo b5bdbe: OUTPUT«get_attr_str() not implemented in class 'Coroutine'␤current instr.: 'print_exception' pc 111608 (src/gen/CORE.setting.pir:50161) (src/gen/CORE.setting:9722)␤called from Sub '' pc 277567 (src/gen/CORE.setting.pir:121659) (src/gen/CORE.setting:5639)␤called from Sub '…

[21:03] <jnthn> japhb: But it means I can start with that process, yes

[21:05] <japhb> jnthn, cool beans.

[21:05] <japhb> jnthn++ and ++jnthn then.  :-)

[21:06] <lue> r: my @a = 1,2,3,2,1; say [@a.uniq,3].uniq

[21:06] <p6eval> rakudo b5bdbe: OUTPUT«1 2 3␤»

[21:09] *** dmol1 joined
[21:11] *** dmol1 left
[21:12] <diakopter> how the FFFFFFFFFFFFF did the parrot foundation get accepted to GSOC this year with a list of project ideas IDENTICAL to last year's?  Especially when the list still includes the 3 projects that were worked on last summer!????!??!!!!?!

[21:13] *** dmol1 joined
[21:13] <labster> r: sub not-foo ($foo) { !$foo }; not-foo(1)

[21:13] <japhb> Does Dalvik support invokedynamic?  Which is to say, could it run nqp-jvm?

[21:13] <p6eval> rakudo b5bdbe: OUTPUT«===SORRY!===␤Undeclared routine:␤    foo used at line 1␤␤»

[21:14] <labster> . o O (user error or parse error?)

[21:16] *** dmol2 joined
[21:16] *** dmol2 left
[21:16] <jnthn> japhb: Not yet, afaik.

[21:16] <diakopter> (and no, I'm not saying they're identical because both links point to the same place.  comparing revisions with the year-old one.

[21:16] <diakopter> )

[21:17] *** dmol1 left
[21:21] *** fgomez left
[21:24] *** dmol1 joined
[21:32] *** dmol1 left
[21:38] *** dmol2 joined
[21:43] <dalek> nqp/jvm-support: b7c2129 | jnthn++ | / (63 files):

[21:43] <dalek> nqp/jvm-support: Use .nqp extension consistently.

[21:43] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/b7c212948e

[21:43] <dalek> nqp/jvm-support: 491b38b | jnthn++ | 3rdparty/asm/ (2 files):

[21:43] <dalek> nqp/jvm-support: Add 3rdparty/asm from nqp-jvm-prep repo.

[21:43] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/491b38b533

[21:43] <dalek> nqp/jvm-support: a8721d5 | jnthn++ | / (123 files):

[21:43] <dalek> nqp/jvm-support: Move C code, ops and PMCs under src/vm/parrot/.

[21:43] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/a8721d5fb8

[21:43] <dalek> nqp/jvm-support: 669532a | jnthn++ | .gitignore:

[21:43] <dalek> nqp/jvm-support: Update .gitignore.

[21:43] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/669532a77b

[21:47] *** fgomez joined
[21:50] <lue> .oO(every JVM-related nqp commit makes me a little more excited. The src/vm/parrot commit doubly so.)

[22:13] <dalek> nqp/jvm-support: 48af6ff | jnthn++ | / (3 files):

[22:13] <dalek> nqp/jvm-support: ModuleLoader.nqp will be VM-specific.

[22:13] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/48af6ffeda

[22:13] <dalek> nqp/jvm-support: 7b9b760 | jnthn++ | src/Regex/constants.pir:

[22:13] <dalek> nqp/jvm-support: Toss dead code.

[22:13] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/7b9b760c4b

[22:13] <dalek> nqp/jvm-support: ba54813 | jnthn++ | / (7 files):

[22:13] <dalek> nqp/jvm-support: Parrot QAST backed moves under src/vm/parrot.

[22:13] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/ba54813b87

[22:15] *** kivutar joined
[22:41] *** sftp left
[22:41] <dalek> nqp/jvm-support: af466c8 | jnthn++ | / (3 files):

[22:41] <dalek> nqp/jvm-support: Split out HLL::Backend from HLL::Compiler.

[22:41] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/af466c8d3e

[22:41] <dalek> nqp/jvm-support: d6ff63d | jnthn++ | / (3 files):

[22:41] <dalek> nqp/jvm-support: NQP Ops.nqp is also VM-specific.

[22:41] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/d6ff63da09

[22:45] *** sftp joined
[22:46] *** dmol2 left
[22:54] *** _jaldhar left
[22:54] *** _jaldhar joined
[23:00] *** _jaldhar left
[23:00] <jnthn> 'night, #perl6

[23:01] <sorear> night

[23:03] *** jaldhar joined
[23:07] <tadzik> japhb++ # good job on panda

[23:08] <japhb> :-)

[23:20] *** tgt left
[23:25] *** berekuk left
[23:39] *** gtodd joined
[23:44] <masak> 'night, #perl6

[23:46] <colomon> \o

