[00:27] <adu> maybe it's not fixed

[00:36] *** thou joined
[00:40] *** rindolf joined
[00:45] *** adu left
[00:46] *** hlin_laptop joined
[01:13] <lue> rn: my @a = [1,2],[3,4]; say @a[0;0];

[01:13] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«1␤»

[01:13] <camelia> ..rakudo 71ea14: OUTPUT«WARNINGS:␤Useless use of constant integer 0 in sink context (line 1)␤1 2␤»

[01:29] *** thou left
[01:31] *** dayangkun joined
[01:38] *** FROGGS__ joined
[01:40] *** FROGGS_ left
[01:56] *** berekuk left
[02:22] *** lustlife joined
[02:31] *** frdmn joined
[02:39] *** orafu left
[02:39] *** orafu joined
[02:50] *** rindolf left
[04:01] *** toddr joined
[04:02] *** Ben_Goldberg left
[04:04] *** toddr_ left
[04:15] <gtodd> m: my @a = [1,2],[3,4]; say @a[0;0];

[04:18] <geekosaur> it's not "m", its "rn" (r, n; also "nr" will work, I think)

[04:19] *** kaare_ joined
[04:19] *** saxx joined
[04:19] <geekosaur> (you can also toss in 'p' to try it in pugs as well as rakudo and niecza, although at this point pugs is pretty far behind the others)

[04:22] <lue> .oO(Keming strikes again!)

[04:22] <geekosaur> they look remarkably similar in the font I use, actually; I had to select it to verify

[04:23] <gtodd> ha

[04:23] <gtodd> are: my @a = [1,2],[3,4]; say @a[0;0];

[04:23] <gtodd> doh! 

[04:23] <gtodd> autospellcheck

[04:24] <gtodd> r: my @a = [1,2],[3,4]; say @a[0;0];

[04:24] <camelia> rakudo 71ea14: OUTPUT«WARNINGS:␤Useless use of constant integer 0 in sink context (line 1)␤1 2␤»

[04:24] <gtodd> n: my @a = [1,2],[3,4]; say @a[0;0];

[04:24] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«1␤»

[04:24] *** Psyche^ joined
[04:25] <lue> looks to me like [0;0] is interpreted as a list of statements as opposed to a semicolon list like it should

[04:25] <TimToady> yes, rakudo doesn't implement slice syntax yet

[04:25] <TimToady> n: my @a = [1,2],[3,4]; say @a[1;*-1]

[04:25] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«4␤»

[04:26] <TimToady> well, multi-dim syntax really

[04:27] <lue> S09 has always been a weak point in rakudo :/

[04:28] *** Patterner left
[04:28] *** Psyche^ is now known as Patterner

[04:29] <TimToady> it probably wouldn't be too hard to at least do that, given rakudo already has ** binding

[06:17] *** SamuraiJack joined
[06:28] *** saxx left
[06:39] *** adu joined
[06:50] *** fgomez left
[07:11] <adu> jnthn: are you awake yet?

[07:12] <adu> it's not Str that's broken, it's try-CATCH that's broken

[07:12] <adu> nqp: try { nqp::die("hello"); CATCH { say("# ERROR: $_"); } }

[07:12] <camelia> nqp: OUTPUT«# ERROR: hello␤»

[07:12] <adu> nqp-jvm: try { nqp::die("hello"); CATCH { say("# ERROR: $_"); } }

[07:12] <camelia> nqp-jvm: OUTPUT«Exception in thread "main" ␤Exception: java.lang.NoClassDefFoundError thrown from the UncaughtExceptionHandler in thread "main"␤»

[07:18] <labster> adu: jnthn isn't usually awake until about 2am

[07:19] <adu> labster: well it's 3:20am for me

[07:19] <adu> labster: what timezone are you?

[07:19] <FROGGS__> it is 9:19 a.m. at jnthn place

[07:19] <labster> California.  12:20 here

[07:19] <adu> so 11 jnthn-time

[07:19] <labster> \o FROGGS__ 

[07:20] <FROGGS__> morning

[07:20] *** FROGGS__ is now known as FROGGS

[07:20] <adu> good morning

[07:20] <adu> jnthn sent me on a wild goose chase :)

[07:21] <FROGGS> adu: well, tracking it down to try+catch is good, you just need to fix that instead :P

[07:21] <adu> I have no idea where CATCH is implemented

[07:21] <FROGGS> well, grep for CATCH?

[07:22] <labster> that's what I tend to do.

[07:22] <FROGGS> it should be in the Actions and should produce some AST, maybe has its own op

[07:22] <FROGGS> and then you have to see how this op/AST is handled

[07:23] <FROGGS> i.e. to what it compiles to

[07:23] <adu> but nqp-jvm t/nqp/44-try-catch.t passes

[07:23] <adu> hmm

[07:23] <FROGGS> weird

[07:24] <FROGGS> maybe this try/catch isnt available at that time?

[07:26] <adu> I'm going to add some more test cases

[07:29] <adu> I really don't understand this test file

[07:29] <adu> try and catch are never used together

[07:29] <adu> I see try blocks in some test cases

[07:30] <adu> and I see CATCH handlers in other test cases

[07:30] <labster> sounds like an excellent idea, adu.

[07:30] <labster> Well, all of the fun stuff like IO::Path::Win32 is finally working in the core.

[07:31] <adu> but I mean every language I know of requires try is paired with catch

[07:31] <FROGGS> nqp-jvm: try { nqp::die("hello") }

[07:31] <camelia> nqp-jvm:  ( no output )

[07:31] <adu> and I think that anyone migrating from those languages is going to use both try & catch without thinking about it

[07:31] <FROGGS> nqp-jvm: CATCH { say($_); }

[07:32] <camelia> nqp-jvm:  ( no output )

[07:32] <FROGGS> I am a bit curious about that java.lang.NoClassDefFoundError

[07:32] <labster> > IO::Path::Win32.new("C:\\foo\\bar\\").parent    # yields  IO::Path::Win32<C:\foo>

[07:33] <FROGGS> labster++

[07:33] <FROGGS> that's is a great plus for rakudo

[07:34] <adu> t/qregex/01-qregex.t uses both try and CATCH, which is (I believe) why it's failing

[07:41] <adu> why is CATCH uppercase?

[07:44] <labster> it's a builtin block, like LAST or BEGIN

[07:46] <labster> I'm not entirely sure how to go about the testing for IO::Path, though.  The backend is all in IO::Spec now, which is ironically not specced.

[07:46] <adu> sounds awk-inspired

[07:47] <labster> I think I might need to add it into the spec, but I'm not sure.

[07:48] <labster> adu: who got awk in my perl?

[07:49] <adu> probably the designer

[07:50] <adu> are module, class, grammar blocks?

[07:52] <FROGGS> adu: CATCH is like a phaser, and all phasers are uc

[07:52] <labster> ah yes, phaser was the word

[07:54] <labster> r: my $g = anon grammar foo { }; say $g ~~ Block;

[07:54] <camelia> rakudo 71ea14: OUTPUT«False␤»

[07:54] <labster> I guess not.

[07:54] <adu> r: my $g = anon grammar foo { }; say $g ~~ CompUnit;

[07:54] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared name:␤    CompUnit used at line 1␤␤»

[07:54] <FROGGS> labster: does it matter that the backend isnt specced? if the "frontend" is specced then this must work as described

[07:55] <FROGGS> adu: these are packages

[07:55] <adu> r: my $g = anon grammar foo { }; say $g ~~ Package;

[07:55] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared name:␤    Package used at line 1␤␤»

[07:55] <FROGGS> grammar is more like a class then a module though

[07:55] <adu> r: my $g = anon grammar foo { }; say $g ~~ Module;

[07:55] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared name:␤    Module used at line 1␤␤»

[07:56] <labster> I suppose so, but all of the tests are written for File::Spec already :P

[07:56] <adu> labster: how can you use Block?

[07:56] <labster> r: use Block;

[07:56] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Could not find Block in any of: /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib, /home/p6ev…

[07:56] <FROGGS> adu: what do you mean by "use a block" ?

[07:56] <adu> r: my $g = anon grammar foo { }; say $g ~~ Block;

[07:56] <camelia> rakudo 71ea14: OUTPUT«False␤»

[07:57] <adu> like that

[07:57] <FROGGS> r: my $g = anon grammar foo { }; g.parse( "abc" )

[07:57] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Undeclared routine:␤    g used at line 1␤␤»

[07:57] <FROGGS> r: my $g = anon grammar foo { }; $g.parse( "abc" )

[07:57] <labster> r: my $g := { say 'hi there'; } ; say $g ~~ Block;

[07:57] <camelia> rakudo 71ea14: OUTPUT«No such method 'TOP' for invocant of type 'foo'␤  in method parse at src/gen/CORE.setting:11162␤  in block  at /tmp/sNBmcz3njr:1␤␤»

[07:57] <camelia> rakudo 71ea14: OUTPUT«True␤»

[07:58] <adu> my question stemed from the use of Block as some builtin type, but I can't find any builtin type for packages

[07:58] <labster> r: my $g := { say 'hi there'; } ; say $g ~~ Block;  $g();

[07:58] <camelia> rakudo 71ea14: OUTPUT«True␤hi there␤»

[07:58] <FROGGS> r: my $g := { say 'hi there'; }; $g()

[07:58] <camelia> rakudo 71ea14: OUTPUT«hi there␤»

[07:58] <FROGGS> right

[07:58] *** drbean left
[07:59] <FROGGS> adu: my $g = anon grammar foo { }; creates an anon object of grammar (like class) foo

[07:59] <FROGGS> so it isnt a block, it is an object

[07:59] <FROGGS> so you can call methods on it, like parse

[08:00] <adu> r: my $g = anon grammar foo { }; say $g ~~ Mu;

[08:00] <camelia> rakudo 71ea14: OUTPUT«True␤»

[08:00] <adu> yey it's a Mu

[08:00] *** drbean joined
[08:00] *** rindolf joined
[08:00] <FROGGS> if you have a real block, you have to call it, like $g(), you will see that in the AST often... ( :op('call'), $block )

[08:02] <FROGGS> adu: http://doc.perl6.org/images/type-graph-Cool.png

[08:03] <FROGGS> it doesnt tell you much that it is Mu

[08:03] <adu> I know it stands for "most undefined"

[08:04] <adu> what's Cool?

[08:05] <FROGGS> I guess doc.perl6.org can tell you more about that then I can :/

[08:07] <adu> ah, Cool is the supertype for magic conversions

[08:08] *** Chillance joined
[08:12] <labster> Mu stands for 無.

[08:13] *** sciurius joined
[08:22] *** crab2313 joined
[08:29] <cognominal> in nqp, what is the equivalent of  :  %h<+>  := &int-ctor; It say First child of a 'bind' op must be a QAST::Var

[08:29] <cognominal> what is the nqp:: pseudo function I should use?

[08:30] <diakopter> %h{'+'}

[08:30] <sorear> nqp: my %h; %h<+> := 2;

[08:30] <camelia> nqp:  ( no output )

[08:30] <sorear> nqp: my %h; %h{'+'} := 2;

[08:30] <camelia> nqp:  ( no output )

[08:30] <sorear> nqp: my %h; say(3) := 2;

[08:30] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op bind (source text: ":="): First child of a 'bind' op must be a QAST::Var␤current instr.: '' pc 48819 (src/stage2/QAST.pir:17874) (src/stage2/QAST.nqp:2988)␤»

[08:31] <sorear> cognominal: that ought to work...

[08:32] <cognominal> nqp: class A { my %h; %h{'+'} := 1 }

[08:32] <camelia> nqp:  ( no output )

[08:33] *** crab2313 left
[08:34] <cognominal> nqp: class A { my %h; %h{'+'} := -> $_ { $_ } }

[08:34] <camelia> nqp:  ( no output )

[08:40] <dalek> v5: 1b8439e | (Tobias Leich)++ | / (2 files):

[08:40] <dalek> v5: fixed q, qq and friends

[08:40] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/1b8439eab7

[08:44] <masak> antenoon, #perl6

[08:44] *** tgt joined
[08:46] *** adu left
[08:50] <FROGGS> hi masak 

[08:53] *** betterworld joined
[08:53] *** berekuk joined
[08:55] *** berekuk left
[08:55] *** berekuk joined
[08:56] <lizmat> good post morpheus, #perl6

[08:57] <masak> and what a morpheus it was!

[08:57] <FROGGS> ?

[08:57] <FROGGS> hi lizmat 

[08:58] <masak> FROGGS: "...is the god of dreams." https://en.wikipedia.org/wiki/Morpheus_(mythology)

[08:58] <FROGGS> ahhh, yeah, of course

[09:08] *** spider-mario joined
[09:11] *** dayangkun left
[09:14] *** kaare__ joined
[09:15] *** kaare_ left
[09:17] * lizmat wonders where .WHAT is really specced

[09:18] <lizmat> S06:2275

[09:18] <diakopter> at one point it described it as macro-y

[09:19] <lizmat> actually: S12:2275

[09:20] <lizmat> 2289: "These are all actually macros, not true operators or methods."

[09:22] <diakopter> yes

[09:22] *** sad joined
[09:22] *** sad left
[09:23] <lizmat> rn: { say $^x + $^x }(5)

[09:23] <diakopter> I bet you search the clogs for WHAT and macro using google you can find more context

[09:23] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«10␤»

[09:23] <FROGGS> std: use v5; require q(./test.pl) # :o(

[09:23] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Unable to parse parenthesized expression at /tmp/elsoYIAf1n line 1:␤------> use v5; require q⏏(./test.pl) # :o(␤Couldn't find final ')'; gave up at /tmp/elsoYIAf1n line 1:␤------> use v5; require q(⏏./t…

[09:26] <lizmat> would it make sense to add a pattern like "{ say $^x + $^x }(5)" as one of the examples at S04:693 ?

[09:27] <masak> lizmat: yes, think so.

[09:28] <masak> lizmat: re "These are all actually macros" -- I've yet to see exactly *how* they are macros. in some places in and outside the spec, "they are macros" means "they get special treatment during compilation, and have thunk-like behavior".

[09:29] <lizmat> I thought so, as macros aren't really implemented yet, right

[09:29] <lizmat> ?

[09:29] <diakopter> marco

[09:30] <lizmat> but if macro's would have been implemented, would they be macro's?  Or still something else?

[09:30] <dalek> perl6-examples: b3c75b3 | (L. Grondin)++ | rosalind/mmch-grondilu.pl:

[09:30] <dalek> perl6-examples: rename mmch

[09:30] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/b3c75b324a

[09:31] *** kaare__ left
[09:31] <diakopter> iirc, they were speculated as macros at the very beginning of designing 6model

[09:31] <dalek> v5: 8dcbdfa | (Tobias Leich)++ | / (2 files):

[09:31] <dalek> v5: we can haz summary!

[09:31] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8dcbdfa3cd

[09:31] <dalek> perl6-examples: d5f05a4 | (L. Grondin)++ | rosalind/grondilu-mmch.pl:

[09:31] <dalek> perl6-examples: remove grondilu-mmch

[09:31] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/d5f05a4e16

[09:32] <diakopter> I think the reasoning was so that the compiler could generate the right "WHAT" for things like primitive types

[09:32] <dalek> specs: 3acfeda | (Brent Laabs)++ | S32-setting-library/IO.pod:

[09:32] <dalek> specs: update IO::Path and IO::FileTests, OS-specific IO::Path::*

[09:32] <dalek> specs: add .parent and .child to IO::Path, clarify volume/directory/basename

[09:32] <dalek> specs: rm $.path from filetests and define modified/changed/created/accessed

[09:32] <dalek> specs: add IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin

[09:32] <dalek> specs: review: https://github.com/perl6/specs/commit/3acfeda811

[09:32] <diakopter> and exotic other things

[09:33] *** tgt left
[09:37] <lizmat> masak: +It's not an error to pass parameters to such a block either:

[09:37] <lizmat> +

[09:37] <lizmat> +    { say $^x + $^x }(5);

[09:37] <lizmat> +

[09:38] <masak> looks good.

[09:38] <FROGGS> { say $^x + $^x }(5, 6); # but they must be used

[09:38] <FROGGS> r: { say $^x + $^x }(5, 6); # but they must be used

[09:38] <camelia> rakudo 71ea14: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in block  at /tmp/STO4LxS8Ya:1␤␤»

[09:39] <masak> r: macro twice($stmt) { quasi { {{{$stmt}}}; {{{$stmt}}}; } }; twice say "OH HAI"

[09:39] <camelia> rakudo 71ea14: OUTPUT«OH HAI␤OH HAI␤»

[09:39] <masak> lizmat: macros are implemented, and work.

[09:39] <masak> lizmat: they're incomplete, and still buggy, but they're there.

[09:39] <diakopter> they do some things, but not all the things

[09:39] <masak> lizmat: to the extent *I* understand what macros are, I don't understand how .WHAT is a macro.

[09:40] <lizmat> hehe…  okokok  :-)

[09:40] <lizmat> I guess "aren't really implemented yet" was a gross overstatement

[09:40] <lizmat> my apologies

[09:40] <lizmat> FROGGS: good point

[09:40] <masak> as a lazy git, I'm insulted! :P

[09:41] *** tgt joined
[09:41] <masak> lizmat: srsly though, no worries. my point was more that we *do* have some understanding of macros already.

[09:41] <masak> lizmat: but the terminology in general, and the use of the term "macro" in particular, are sometimes very confusing.

[09:42] <lizmat> FROGGS: but isn't that a more general issue?

[09:42] <lizmat> masak: s/These are all actually macros/These actually all behave like macros/ ?

[09:43] <FROGGS> lizmat: yes, but it was a bit surprising to me when I first come to that

[09:43] <lizmat> ack

[09:44] *** berekuk left
[09:44] <masak> lizmat: I'd actually prefer if we left the word "macro" alone for that meaning.

[09:45] <masak> lizmat: something like "These all actucally have BEGIN-time semantics" seems to capture it just as well.

[09:45] <masak> (no-one goes around calling BEGIN {} a "macro", do they) :)

[09:45] <diakopter> agree ^^ "something like.."

[09:47] <masak> while we're on the topic, I think it's ridiculous to call infix:<&&> a "macro".

[09:47] <lizmat> well, the chapter "Introspection" at S12:2271 will need some rewriting then, as the word "macro" occurs a lot in there

[09:48] <masak> it's just a short-circuiting operator. if we start to call short-circuiting operators "macros", it's not because we understand macros well, it's because we understand short-circuiting operators badly :)

[09:50] <lizmat> I will keep that in mind when starting to grok S12

[09:50] <lizmat> meanwhile: masak/Froggs: +But as always, you must use them all:

[09:50] <lizmat> +

[09:50] <lizmat> +    # Syntax error: Too many positional parameters passed

[09:50] <lizmat> +    { say $^x + $^x }(5,6);

[09:50] <lizmat> +

[09:51] <masak> "These are all actually macros, not true operators or methods." -- this sentence reveals another confusion. "macro" and "(true) operator" are orthogonal concepts.

[09:51] <masak> r: say Macro.^mro

[09:51] <camelia> rakudo 71ea14: OUTPUT«(Macro) (Routine) (Block) (Code) (Any) (Mu)␤»

[09:51] <masak> r: say Sub.^mro

[09:51] <camelia> rakudo 71ea14: OUTPUT«(Sub) (Routine) (Block) (Code) (Any) (Mu)␤»

[09:51] <masak> r: say &infix:<+>.^name

[09:51] <camelia> rakudo 71ea14: OUTPUT«Sub+{<anon>}+{Precedence}␤»

[09:51] * lizmat likes introspection

[09:51] <masak> macros are routines. operators are subs are routines.

[09:52] <masak> macros can be operators.

[09:52] <masak> (hm, in which case they'd not be subs, but still routines) :)

[09:52] <masak> r: macro infix:<!+!>($a, $b) { quasi { 42 } }; say 4 !+! 2

[09:52] <camelia> rakudo 71ea14: OUTPUT«42␤»

[09:52] <masak> r: macro infix:<!+!>($a, $b) { quasi { 42 } }; say &infix:<!+!>.^name

[09:53] <camelia> rakudo 71ea14: OUTPUT«Macro+{Precedence}␤»

[09:53] <masak> r: macro infix:<!+!>($a, $b) { quasi { 42 } }; say &infix:<!+!>.^mro

[09:53] <camelia> rakudo 71ea14: OUTPUT«(Macro+{Precedence}) (Macro) (Routine) (Block) (Code) (Any) (Mu)␤»

[09:53] * masak had personally missed that '+{Precedence}' part

[09:53] <masak> interesting.

[09:54] <cognominal> In the doc, except in the macro section, macro seems to mean, "it looks like a method or a function but it is implemented otherwise"

[09:58] <masak> yeah. which is a pity.

[09:58] <masak> (because macros are fairly well-defined.)

[10:00] <masak> macros are routines that execute as soon as their argument list has been parsed. they accept ASTs or program strings as paramters, and they emit ASTs or program strings.

[10:00] *** berekuk joined
[10:01] <dalek> specs: 432411a | (Elizabeth Mattijsen)++ | S04-control.pod:

[10:01] <dalek> specs: Additional examples in "Statement-level bare blocks"

[10:01] <dalek> specs: review: https://github.com/perl6/specs/commit/432411af08

[10:03] <cognominal> masak: but I interpret that, maybe wrongly, as "they should have been written as macro, if macro were available at the time it was written."

[10:05] <masak> yes, and my point is that that's not true.

[10:05] <masak> or if that's true, the mechanism by which it is true eludes me.

[10:06] <masak> in some sense it feels like the burden of proof rests on the one claiming that .WHAT is a macro, to show an example implementation of it. because I don't see it.

[10:07] <diakopter> masak: my point above was that if the compiler knows the variable or expression results in a value of native type, then it can't have a 6model .WHAT method called on it, per se... if the compiler is treating it as a more ethereal "variable"/"memory location" and not a scalar container (if it's able to assume as such for optimization purposes)

[10:08] <diakopter> ... so the macro would generate the thing that returned the right type for that primitive type

[10:08] <diakopter> I suspect that was the motivation between the handwavey macroization

[10:09] <diakopter> er, *behind

[10:10] <lizmat> rn: my $a="WHAT"; say { 1 }.$a

[10:10] <camelia> rakudo 71ea14: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Str'␤  in block  at /tmp/i_vlrVN1ld:1␤␤»

[10:10] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Str␤  at /tmp/a2r78Stc2A line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583…

[10:10] <lizmat> according to spec, this should work.  Which also means to me that .WHAT is *not* a macro

[10:11] <lizmat> as this would be purely runtime, no?

[10:12] <diakopter> well there was always going to be a WHAT method behind the scenes anyway on things that could have methods

[10:14] <lizmat> rn: my $a="say"; { 1 }.$a

[10:14] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Str␤  at /tmp/zm2lCnveie line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583…

[10:14] <camelia> ..rakudo 71ea14: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Str'␤  in block  at /tmp/mrZvm7Q8cW:1␤␤»

[10:15] <lizmat> rn: { 1 }.say

[10:15] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«{ ... }␤»

[10:15] <camelia> ..rakudo 71ea14: OUTPUT«Block.new()␤»

[10:16] *** SamuraiJack left
[10:16] <lizmat> brb

[10:21] <FROGGS> hmmm, should be easy to fix that

[10:21] <FROGGS> rn: { 1 }."say"

[10:21] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Unsupported use of . to concatenate strings or to call a quoted method; in Perl 6 please use ~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses at /tmp/EUU2bnMD48 line 1 (EOF):␤…

[10:21] <camelia> ..rakudo 71ea14: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments. If you meant to concatenate two strings, use '~'.␤at /tmp/2w4O_MZmDP:1␤------> { 1 }."say"⏏<EOL>␤»

[10:25] *** hlin_laptop left
[10:25] <lizmat> rn: say { 1 }.WHAT; my $a="WHAT"; eval "say { 1 }.$a"

[10:25] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Block)␤(Int)␤»

[10:25] <diakopter> heh.

[10:26] <lizmat> even shorter:

[10:26] <lizmat> say { 1 }.WHAT; eval "say { 1 }.WHAT"

[10:26] <lizmat> rn: say { 1 }.WHAT; eval "say { 1 }.WHAT"

[10:26] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Block)␤(Int)␤»

[10:27] <lizmat> rn: say { 1 }.WHAT; eval 'say { 1 }.WHAT'

[10:27] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Block)␤(Block)␤»

[10:27] <lizmat> aha, interpolation, of course… :-)

[10:27] <jnthn> Afternoon, #perl6

[10:28] <lizmat> jnthn++ !

[10:29] <dalek> v5: 866a4aa | (Tobias Leich)++ | / (2 files):

[10:29] <dalek> v5: this should fix: require q("./test.pl")

[10:29] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/866a4aa3f5

[10:29] <jnthn> .WHAT is compiled go a low-level operation of the implementation's choosing. Same with .HOW. They aren't methods.

[10:30] <FROGGS> hi jnthn 

[10:30] <jnthn> They're handled inside of the compiler. Some may say that makes them macros. I don't care if you call them magical unicorn sugar puffs.

[10:30] <jnthn> o/ FROGGS, lizmat 

[10:31] <lizmat> ah, the infamous musp's !

[10:31] *** berekuk left
[10:31] <jnthn> I suspect if the spec says "macro" about them it doesn't literally mean the CORE.setting has a macro WHAT or so.

[10:31] <lizmat> jnthn: but they also exist as runtime method, no?

[10:31] <jnthn> No.

[10:32] <jnthn> Not at the moment, anyway. We could add them as methods but you'd barely reach them.

[10:32] <lizmat> so anything like: $a="WHAT", { 1 }.$a would never work?

[10:32] <jnthn> Well, that means "WHAT"({ 1 }) which means you're trying to invoke a string :)

[10:32] <lizmat> (the spec seems to imply that they would)

[10:33] *** woosley left
[10:33] <jnthn> $a = "WHAT"; { 1 }."$a"() could work if we did also put method WHAT etc. somewhere.

[10:33] <jnthn> Where does it say they should work, ooc?

[10:33] <jnthn> If they do then they'll be method WHAT() { self.WHAT } :)

[10:34] <lizmat> then I guess S12:2298 is in error

[10:34] <jnthn> looking

[10:35] *** tgt left
[10:35] <jnthn> lizmat: That bit of S12 is talking about how to bypass the fact that .WHAT and friends are treated specially.

[10:35] <jnthn> But I think that:

[10:35] <jnthn> And if you don't know the method name in advance, you'd be using the

[10:35] <jnthn> variable form anyway:

[10:35] <jnthn> $obj.$somemeth

[10:35] <jnthn> ...could be clarified as:

[10:36] *** tgt joined
[10:36] <jnthn> $obj."$somemethname"() # where $somemethname is a method name

[10:36] <jnthn> $obj.$somemeth # where $somemeth is a method object

[10:36] <jnthn> Or so

[10:37] <diakopter> rn: my $a="WHAT"; say { 1 }."$a"()

[10:37] <lizmat> hmmm… ok

[10:37] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Unable to resolve method WHAT in type Block␤  at /tmp/0lhf4RSQLo line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583) ␤  at /home…

[10:37] <camelia> ..rakudo 71ea14: OUTPUT«No such method 'WHAT' for invocant of type 'Block'␤  in block  at /tmp/slbEKeSkqY:1␤␤»

[10:37] <lizmat> I had it shorter:

[10:37] <lizmat> rn: say { 1 }."WHAT"()

[10:37] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«Unhandled exception: Unable to resolve method WHAT in type Block␤  at /tmp/blKnrV91Km line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583) ␤  at /home…

[10:37] <camelia> ..rakudo 71ea14: OUTPUT«No such method 'WHAT' for invocant of type 'Block'␤  in block  at /tmp/kMyWKBb4_u:1␤␤»

[10:38] <grondilu> rn: say join ",", (my @)[0] = [^2], [<foo bar>]

[10:38] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«0 1 foo bar␤»

[10:38] * lizmat wonders how to create a method object

[10:39] * grondilu was expecting "0 1,foo bar"

[10:39] <grondilu> rn: say join ",", [^2], [<foo bar>]

[10:39] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«0 1,foo bar␤»

[10:39] <grondilu> see?

[10:39] <diakopter> r: say (our method foo() { }).WHAT

[10:39] <camelia> rakudo 71ea14: OUTPUT«(Method)␤»

[10:39] <lizmat> rn: my $a= method { }; say $a.WHAT

[10:39] <lizmat> ack

[10:39] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«(Method)␤»

[10:40] <diakopter> r: say (our method foo() { }).name

[10:40] <camelia> rakudo 71ea14: OUTPUT«foo␤»

[10:40] <jnthn> r: say Int.^find_method('abs').WHAT.say

[10:40] <camelia> rakudo 71ea14: OUTPUT«(Method)␤True␤»

[10:41] <jnthn> hm, I said too much...

[10:42] <FROGGS> uhh, good that we arn't mafiosos :P

[10:42] <lizmat> for now I'll suggest this change to S12:

[10:42] <lizmat> -    $obj.$somemeth

[10:42] <lizmat> +    $obj."$methodname"()

[10:42] <lizmat> +

[10:42] <lizmat> +or:

[10:42] <lizmat> +

[10:42] <lizmat> +    $obj.$methodobject

[10:42] <jnthn> Speak for yourself

[10:42] <grondilu> perl6 flattens too much.  Everytime I try to use lists of arrays, I get troubles :(

[10:42] <jnthn> uh, wait, I mean... :)

[10:42] <FROGGS> hehe

[10:42] <jnthn> lizmat: +1

[10:43] <lizmat> actually, also:

[10:43] <lizmat> -    $obj."WHERE"

[10:43] <lizmat> +    $obj."WHERE"()

[10:43] <lizmat> right?

[10:43] <jnthn> Yes, pretty sure the () are mandatory

[10:43] <jnthn> std: my $obj; $obj."WHERE"

[10:43] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Unsupported use of . to concatenate strings or to call a quoted method; in Perl 6 please use ~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses at /tmp/aMvLxZvcte line 1:␤------> my $o…

[10:43] <jnthn> r: my $obj; $obj."WHERE"

[10:44] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments. If you meant to concatenate two strings, use '~'.␤at /tmp/SlDP2yHIhH:1␤------> my $obj; $obj."WHERE"⏏<EOL>␤»

[10:45] <dalek> specs: dd82127 | (Elizabeth Mattijsen)++ | S12-objects.pod:

[10:45] <dalek> specs: Clarafication/Expansion in examples of Introspection section

[10:45] <dalek> specs: review: https://github.com/perl6/specs/commit/dd8212738d

[11:05] *** kaare_ joined
[11:22] <masak> yes, used to be $obj."method" worked, but it was deemed to confusable with Perl 5 concatenation, so the () were added, and any $obj."method" without the () in the spec is a fossil.

[11:25] *** lustlife left
[11:30] *** greg____ joined
[11:34] <lizmat> S02:4215 probably needs this diff then:

[11:34] <lizmat> -    $foo $bar:          # ILLEGAL       -- use $bar.$foo for indirection

[11:34] <lizmat> +    $foo $bar:          # ILLEGAL       -- use $bar."$foo"() for indirection

[11:34] <lizmat> am not sure what to do with the next line though:

[11:34] <lizmat> (foo bar) baz: 1    # ILLEGAL       -- use $baz.$(foo bar) for indirection

[11:34] <grondilu> rn: say join(":", (my @)[0] = [^2], [<a b>]), " differs from ", ((my @)[0] = [^2], [<a b>]).join: ":"

[11:34] <camelia> rakudo 71ea14: OUTPUT«0 1 a b differs from 0 1:a b␤»

[11:34] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable @ (see line 1) at /tmp/f7f1xnreEu line 1:␤------> [^2], [<a b>]), " differs from ", ((my @⏏)[0] = [^2], [<a b>]).join: ":"␤␤0 1 a b differs from 0 1:a b␤»

[11:35] *** tgt left
[11:36] *** tgt joined
[11:36] <grondilu> rn: (my @a)[0] = [^2], [<a b>]; say @a[0].join(":"); say join ":", @a[0];

[11:36] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«0 1:a b␤0 1 a b␤»

[11:37] <grondilu> rn: my $a = [^2], [<a b>]; say $a.join(":"); say join ":", $a;

[11:37] <camelia> rakudo 71ea14: OUTPUT«WARNINGS:␤Useless use of "," in expression "my $a = [^2], [<a b>]" in sink context (line 1)␤0:1␤0 1␤»

[11:37] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«0:1␤0 1␤»

[11:37] <grondilu> rn: my $a = ([^2], [<a b>]); say $a.join(":"); say join ":", $a;

[11:37] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«0 1:a b␤0 1 a b␤»

[11:38] <grondilu> wtf

[11:38] <grondilu> isn't $x.join: $sep  supposed to be the same as join $sep, $x  ??

[11:42] <masak> good question.

[11:42] *** PacoAir joined
[11:42] <masak> there's different amounts of flattening going on there, but I'm still not convinced there should be a difference.

[11:43] <masak> specifically, I don't understand the result of the second join.

[11:46] <grondilu> rn: my $x = <foo bar>; say join ", ", $x; say $x.join: ", ";

[11:46] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foo bar␤foo, bar␤»

[11:46] <grondilu> hum, I think I get it.

[11:46] <grondilu> rn: my $x = <foo bar>; say join ", ", @$x; say $x.join: ", ";

[11:46] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foo, bar␤foo, bar␤»

[11:47] <grondilu> makes sense

[11:48] <grondilu> the method call version forces the evaluation as a list, while the function call version considers the argument as an array.  Or something like that.

[11:49] *** kaare__ joined
[11:49] *** kaare_ left
[11:50] *** greg____ left
[11:51] <grondilu> or in ther words, when writing join $sep, $x,   $x is only the first item of a list that could have had several.  Like join $sep, $x, $y.  In which we probably wanted $x ~ $sep ~ $y.   So it really has a different semantic than $x.join($sep)

[11:52] <grondilu> s/In which/& case/

[11:53] <masak> yeah.

[11:53] <masak> that does make sense.

[11:54] *** kaare__ is now known as kaare_

[11:54] <masak> rn: my $x = <foo bar>; say join(", ", |$x); say $x.join: ", ";

[11:54] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foo, bar␤foo, bar␤»

[11:54] <masak> there you go.

[11:54] <masak> I don't think | works without the parens, though.

[11:55] *** domidumont joined
[11:55] <masak> rn: my $x = <foo bar>; say join ", ", |$x; say $x.join: ", ";

[11:55] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foo, bar␤foo, bar␤»

[11:55] <masak> seems it does :)

[11:55] <grondilu> I don't see why it wouldn't have.

[11:56] <masak> sometimes I suffer from the ghosts of old NYI that have since gone away.

[11:59] <lizmat> rn: my $x = <foo bar>; say (|$x)

[11:59] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«\("foo", "bar")␤»

[11:59] <camelia> ..rakudo 71ea14: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (lines 1, 1)␤»

[11:59] <lizmat> feels like a rakudobug to me

[11:59] <lizmat> rn: my $x = <foo bar>; say |$x

[11:59] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foobar␤»

[12:00] *** rking left
[12:00] <lizmat> without parens it's ok

[12:00] <masak> yes, that's what I remember happening.

[12:00] *** woolfy joined
[12:01] <lizmat> seems you got it backward, though, cause it's working *without* the parens

[12:01] *** ozmq joined
[12:01] <lizmat> and it isn't *with* the parens

[12:01] <jnthn> Well, what do you expect it to do there?

[12:02] * jnthn isn't sure what the expected behavior of using | out of the context of an argument list is.

[12:02] <lizmat> well, in either case its a prefix |, is it not?

[12:03] <lizmat> I mean "say |$x" is a prefix |

[12:03] <lizmat> or am I missing something here?

[12:03] <jnthn> Yes, but it's not actually turned into a call to prefix:<|>. Rather, it's used by the thing constructing the AST for the call to know to mark the arg as flattening.

[12:04] <jnthn> So that it actually does get flattened.

[12:04] *** domidumont left
[12:04] <lizmat> so it's more like a macro in that context?

[12:04] <jnthn> If we're calling "soemthing the compiler handles" a macro, then I guess so :)

[12:05] *** domidumont joined
[12:05] <masak> lizmat: now you're just doing it to tease me.

[12:06] * lizmat pleads guilty

[12:06] <jnthn> :D

[12:06] * masak .oO( the whole bloody COMPILER is "more like a macro"! )

[12:06] <jnthn> masak: To be fair, a big thing that makes macros interesting is that the compiler invokes them ;)

[12:07] <masak> I'm not disagreeing about that.

[12:09] <GlitchMr> http://thedailywtf.com/Articles/Global_Spaces.aspx

[12:09] <GlitchMr> my @space-char := map " " x *, ^Inf; 1;

[12:09] <lizmat> rn: sub prefix:<|> { @_.join }; my $x = <foo bar>; say (|$x)

[12:09] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«foo bar␤»

[12:09] <GlitchMr> Reimplementing stuff from this website in Perl is so fun

[12:09] <GlitchMr> Perl 6*

[12:10] <lizmat> oddly enough, $x is already stringified before prefix:<|> is called

[12:12] <lizmat> afk for a few hours&

[12:15] <masak> lizmat: no, it's not. that's the wrong conclusion :)

[12:15] <masak> rn: sub prefix:<|> { say @_[0].^name; @_.join }; my $x = <foo bar>; say (|$x)

[12:15] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«Parcel␤foo bar␤»

[12:16] <masak> it gets stringified the moment you call .join on it. and because it's a Parcel, it gets a space in-between its elements.

[12:16] <cognominal> lizmat, jnthn, I am confused too about the not really a prefix:<|>. I remember trying using it outside arguments

[12:19] *** felher left
[12:35] *** ozmq left
[12:58] *** xinming left
[13:00] *** xinming joined
[13:00] *** pecastro left
[13:00] *** spider-mario left
[13:02] *** pecastro joined
[13:02] *** fgomez joined
[13:04] *** Chillance left
[13:10] *** Chillance joined
[13:40] *** saxx joined
[14:00] *** rking joined
[14:01] *** saxx left
[14:01] *** AMENDEES_ joined
[14:15] *** felher joined
[14:20] <dalek> v5: 1e60268 | (Tobias Leich)++ | lib/Perl5.pm:

[14:20] <dalek> v5: we dont need that

[14:20] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/1e60268615

[14:21] <FROGGS> jnthn: I'm in serious trouble atm. The way v5 inherits from Perl6::Grammar doesn't allow me to override the pod directives, this breaks everything that uses Perl 5 pod blocks... :o(

[14:22] <FROGGS> jnthn: Is there a better way to inherit from Perl6::Grammar?

[14:30] <jnthn> FROGGS: Inheriting from Perl6::Grammar sounds wrong.

[14:30] <jnthn> FROGGS: I'd expect inheriting from HLL::Grammar

[14:31] <FROGGS> that's what I do too, but if it doesnt inherit from Perl6::Grammar I end up: P6opaque only supports type changes where the MRO of the original type is a suffix of the MRO of the new type

[14:32] <jnthn> That sounds like you're trying to rebless the current cursor to do a language switch rather than just doing something like LANG does.

[14:32] <FROGGS> well, token statement has these reblessing

[14:33] <FROGGS> I can remove it for a test though

[14:33] <jnthn> I don't know you should be ending up in there.

[14:33] <jnthn> I'd expect after you see use v5 you do a langauge switch

[14:34] <jnthn> The statement rebless is when you tweaked.

[14:34] <jnthn> (e.g. added a new operator)

[14:35] <jnthn> The case you have is more like when we switch to the Q langauge to aprse a quote, or the Regex language to parse regexes.

[14:35] *** PacoAir left
[14:36] *** PacoAir joined
[14:37] <FROGGS> I'm commenting out the reblessing in rakudo and v5 and see what happens

[14:38] *** tgt left
[14:39] <FROGGS> when hitting a quote there is no real language switching too, it just nibbles/quibbles use a different language

[14:39] <FROGGS> but I cant do that

[14:42] <FROGGS> hmmm

[14:43] <FROGGS> after doing that it uses the P5Actions, but still Perl6::Grammar

[14:43] <jnthn> Regexes use a different langauge, though?

[14:43] <FROGGS> so setting %LANG<MAIN> alone has no effect

[14:44] <FROGGS> jnthn: but for regexes you still know the delims

[14:44] <FROGGS> so you can use sibble/tribble/...

[14:44] <jnthn> How do you know today when to stop parsing P5 and return to P6?

[14:45] <jnthn> Looking at STD, it declares a new %*LANG and sets it up.

[14:46] <FROGGS> well, use Module only affects the block it is in, so { perl6... { use v5; ... } } is just working

[14:46] <FROGGS> and if v5 is the top thing in a file we are clear too...

[14:46] * FROGGS is looking at STD now

[14:47] <jnthn> FROGGS: HLL::Grammar defines a <LANG(...)> which is used for language switching.

[14:47] <jnthn> Or is a way to do it

[14:47] <jnthn> That is much closer to what you want, I think.

[14:47] <FROGGS> hmmm, sounds good

[14:47] <FROGGS> :my %*LANG; <-- STD

[14:47] <FROGGS> and then it does a reblessing too

[14:48] <FROGGS> at least that is how I read line 1445

[14:48] <jnthn> yeah, we can't do it that way.

[14:48] <jnthn> It suspect it relies on a P5ish view of bless under the hood, given it's translating to P5.

[14:48] <jnthn> Or something like that.

[14:49] <jnthn> oh, in fact it's completely replacing the current curosr...

[14:49] <jnthn> Anyway, <LANG(...)> is probably the way to go.

[14:50] <FROGGS> ya, will test that now

[14:50] <FROGGS> thanks!

[15:05] *** bwk joined
[15:15] *** Bzek left
[15:17] *** bwk left
[15:17] *** bwk joined
[15:21] *** bwk left
[15:22] *** AMENDEES__ joined
[15:22] *** AMENDEES_ left
[15:29] *** tgt joined
[15:43] *** pecastro left
[16:14] <timotimo> should rakudo introspect comments to see if there are vim or emacs configs for tabstop size, so that $?TABSTOP can be set properly? :P

[16:15] <dalek> perl6-examples: 1c124a8 | (L. Grondin)++ | rosalind/eubt-grondilu.pl:

[16:15] <dalek> perl6-examples: (rosalind)  EUBT

[16:15] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/1c124a850e

[16:15] <grondilu> ^ this one was tough

[16:26] <FROGGS> jnthn: okay, so I put my v5 in %LANG<Perl5>, and added a <statementlist=.LANG('Perl5', 'statementlist')>, looks good so far

[16:27] <jnthn> FROGGS: Sounds righter :)

[16:27] <FROGGS> btw, if we had a $GRAMMAR (like $ACTIONS), it would help too

[16:28] <FROGGS> $*GRAMMAR that is

[16:28] <FROGGS> so the Perl5.pm just sets this

[16:41] *** SamuraiJack joined
[16:50] *** frdmn left
[16:56] <timotimo> grondilu: my @left = grep none(@picked), @species;  -  clever! surprised me that it would work tbh. grep does ~~ internally?

[16:58] *** cognominal left
[16:59] <colomon> timotimo: yes

[16:59] *** cognominal joined
[16:59] <colomon> timotimo: possibly not explicitly, but grep smartmatches.

[17:03] *** crab2313 joined
[17:05] <grondilu> timotimo: yes,  grep does ~~ internally.  I've been using this "grep none(@)" construct for a while now.

[17:07] <grondilu> Well, a junction is supposed to be exactly like any scalar, so I thought I should be able to do grep $junction, @array as I would do grep $scalar, @array.

[17:07] <colomon> r: (1..10).grep(3|4)

[17:07] <timotimo> it could theoretically have autothreaded the grep call and returned a junction of grep results for each of the junctionpars

[17:07] <camelia> rakudo 71ea14:  ( no output )

[17:07] <colomon> r: say (1..10).grep(3|4)

[17:07] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Unable to parse expression in argument list; couldn't find final ')'␤at /tmp/BLVZAbque0:1␤------> say (1..10).grep(3|4⏏)␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤»…

[17:08] <timotimo> r: say (1..10).list.grep(3|4\)

[17:08] <camelia> rakudo 71ea14: OUTPUT«===SORRY!===␤Unable to parse expression in argument list; couldn't find final ')'␤at /tmp/R_ZCAJqupm:1␤------> say (1..10).list.grep(3|4\⏏)␤    expecting any of:␤        postfix␤»

[17:08] <timotimo> r: say (1..10).list.grep(3|4)

[17:08] <camelia> rakudo 71ea14: OUTPUT«3 4␤»

[17:08] <timotimo> there we go

[17:08] <timotimo> r: say (1...10).grep(3|4) # should be the same

[17:08] <camelia> rakudo 71ea14: OUTPUT«3 4␤»

[17:08] * colomon must have stuck some sort of control characters in there.  Colloquy--

[17:08] <timotimo> i wonder if the 1..10.grep behavior is to spec

[17:09] <colomon> rn: say (1..10).grep(3|4)

[17:09] <timotimo> looks like an italic backslash to me

[17:09] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT«3 4␤»

[17:09] <colomon> there you go

[17:10] <geekosaur> my client shows a control character, FS (0x1c)

[17:12] <colomon> and mine shows nothing.  :\

[17:13] <geekosaur> (I use an xchat hook to make control characters visible)

[17:15] *** crab2313 left
[17:16] <timotimo> i should really get a compose combination for the ␤ character

[17:17] *** AMENDEES__ left
[17:24] *** tgt left
[17:28] *** gtodd left
[17:43] *** spider-mario joined
[18:10] *** census joined
[18:12] *** sftp left
[18:13] *** kaare_ left
[18:13] *** sftp joined
[18:32] *** grondilu left
[19:03] *** domidumont left
[19:15] *** sqirrel joined
[19:15] <cxreg> so, niecza does concurrency using the threads provided by the CLR?

[19:16] <cxreg> what is rakudo going to do on jvm in that space?  anything?

[19:17] <tadzik> I guess it'll use threads provided by JVM

[19:20] *** tgt joined
[19:22] <nwc10> cxreg: I know that jnthn has thought about how to do Rakudo concurrency on the JVM in some detail, but I don't know much more than that.

[19:23] <nwc10> but, first one needs Rakudo on the JVM :-)

[19:35] *** kaare_ joined
[19:57] *** kaare_ left
[20:03] *** berekuk joined
[20:07] <dmol> Why JVM, not Parrot?

[20:09] <FROGGS> dmol: what exactly do you mean?

[20:10] *** rindolf left
[20:10] <masak> I think the short answer is that exploring Perl 6 concurrency on Parrot isn't a priority for anybody right now.

[20:13] <nwc10> partly, if I understood what I've been told, because Parrot's threading model is very different from the JVM's (and JVM and .NET are fairly similar). And because Parrot's threading implementation is very new, and nothing (else) is using it

[20:14] <flussence> Threading is a solved problem on the JVM. It's easier to port Rakudo to that than to wait for Parrot to catch up.

[20:14] <lue> (nor is it, as I've heard, nearly as easy as it would be on JVM, a platform that has threads for a while)

[20:14] <nwc10> so, it's easier to do JVM first - you know that any bugs you find are going to be in the Rakudo code, because someon else has already hit the JVM bugs

[20:14] <nwc10> then, once Rakudo's threading support is solid, you come back and port it to Parrot

[20:17] <masak> there's a disconnect here between Rakudo and Parrot devs, I find. Parrot devs say "what are you talking about, Parrot has threads, they're awesome!". pmichaud has repeatedly said "if that's so, then please show me how we can do hyper addition, `@a >>+<< @b`, using Parrot's primitives."

[20:18] <lue> .oO("We're not rakudo programmers! How are we supposed to create an example like that?")

[20:20] * lue goes to actually read the PDD on threads, if it exists

[20:20] <dmol> Thanks for explanation. I'm just curious about p6 world, and try to understand it's tendency.

[20:21] *** sqirrel left
[20:23] <masak> dmol: it is a fair question.

[20:29] <lue> Parrot's ideas on concurrency are interesting (multiple concurrency models can be used at the same time), but I wonder how much of it is actually implemented.

[20:31] *** jnthn joined
[20:32] *** mathw left
[20:32] *** _sri joined
[20:32] *** mathw joined
[20:34] *** frdmn joined
[20:35] *** avar left
[20:37] *** yx joined
[20:37] *** Bucciarati joined
[20:41] <cxreg> masak: did parrot ever respond with some examples?

[20:41] <tadzik> rurban++ commited some code to nqp repo

[20:41] <tadzik> it was never fully implemented though, I think

[20:41] <tadzik> some things were lacking

[20:41] *** adu joined
[20:41] *** SamuraiJack left
[20:41] *** _sri left
[20:41] *** _sri joined
[20:41] *** avar joined
[20:41] *** avar left
[20:41] *** avar joined
[20:42] *** ilogger2 joined
[20:42] *** ChanServ sets mode: +v ilogger2

[20:49] <dalek> v5: 88cfd7d | (Tobias Leich)++ | / (5 files):

[20:49] <dalek> v5: instead of inheriting from Perl6:Grammar [...]

[20:49] <dalek> v5: 

[20:49] <dalek> v5: we just execute a statementlist in the given language.

[20:49] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/88cfd7dfb5

[20:50] *** p5eval joined
[20:54] <dalek> v5: f1e39fb | (Tobias Leich)++ | t/test_summary:

[20:54] <dalek> v5: strip backtrace

[20:54] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f1e39fbde4

[21:00] * [Coke] loses some backscroll, and can't hit the log website to find it! *sadface*

[21:00] <dalek> perl6-roast-data: 9af76ea | coke++ | / (3 files):

[21:00] <dalek> perl6-roast-data: today (automated commit)

[21:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/9af76ea4d0

[21:00] <dalek> perl6-roast-data: 4f577ad | coke++ | / (3 files):

[21:00] <dalek> perl6-roast-data: today (automated commit)

[21:00] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/4f577addbd

[21:01] <adu> hi all

[21:01] <masak> hi adu

[21:04] <adu> what's the difference between AST and QAST?

[21:05] <masak> AST is language-independent, QAST is what nqp is using.

[21:05] <[Coke]> AST is a generic ter.

[21:05] <timotimo> masak: when reviewing the t2 results, did you think the producing grammar for pieces of speech has been implemented in an optimal way? i thought it was pretty concise and good; did you see any obvious improvements?

[21:05] <[Coke]> m

[21:05] <timotimo> ter.m? :)

[21:06] <adu> http://doc.perl6.org/type/AST

[21:06] <masak> timotimo: I did, but I didn't put it in the review.

[21:06] <timotimo> give me the short version of what you thought could be done better? :)

[21:06] <masak> timotimo: it occurs to me that the grammar will not generate all possible trees with equal probability.

[21:07] <masak> timotimo: (because it works top-down, and so the distribution will be biased because of that)

[21:07] <timotimo> oh, that's a good point. reminds me of the time when the minichallenge to make random brace pairs was in the air

[21:07] <masak> yeah, that one is clearly related.

[21:08] <masak> random brace pairs and binary trees are equal up to isomorphism.

[21:08] <adu> random brace pairs?

[21:09] <dalek> roast: 48308c5 | coke++ | S12-construction/destruction.t:

[21:09] <dalek> roast: pugs fudge

[21:09] <dalek> roast: review: https://github.com/perl6/roast/commit/48308c54cb

[21:09] <timotimo> http://rosettacode.org/wiki/Balanced_brackets - i think this one

[21:09] <masak> yes, but that's one about verification, not random generation.

[21:09] <cognominal> can someone tell me the difference between LALR and operator precedence parsing? I think that LALR is faster because it is compiled into an automata but operator precedence is more general when combined with other engines like in Perl 6

[21:10] <cognominal> can someone correct me or elaborate?

[21:10] <masak> adu: https://gist.github.com/masak/5129165

[21:11] <masak> cognominal: "an automaton" ;)

[21:11] <masak> that was the correction -- hold on and I'll try to elaborate.

[21:13] <masak> cognominal: LALR seems more comparable to recursive descent than to operator precedence.

[21:13] <masak> cognominal: and Wikipedia's summary seems to be "LALR is hard to understand, recursive descent is easier".

[21:14] <cognominal> mask: well with recursive descendant parsing in Perl 6, once you start using procedural alternatives, there is so many of them

[21:15] <cognominal> I am writing material and I said that with reduce/reduce and shift/reduce conflicts, LALR was tricky to use.

[21:15] <masak> ah, ok.

[21:16] <masak> yes, maybe that's where the trickiness comes from. I can neither confirm nor deny.

[21:17] <cognominal> my understanding is that with recursive descendant parsing for handling || and && , operator precedence parsing for, well operator stuff and NFA for the rest. Perl 6 has found a sweet spot.

[21:20] <cognominal> the synopsis are silent about operator precedence. And I don't even think that rakudo implement that. It is just two stacks juggling (operators and operands) according to precedence.

[21:20] <cognominal> I think operator precedence means generating some kind of automata

[21:21] <masak> yes, Rakudo and nqp do operator precedence.

[21:21] <cognominal> or not, it seems that the juggling I describe is  http://en.wikipedia.org/wiki/Shunting_yard_algorithm

[21:21] <masak> and that's the only bit that *doesn't* involve generating some kind of automata.

[21:21] <cognominal> I must confuse with some automata based system to deal with operators.

[21:22] <masak> yes.

[21:22] <cognominal> Yes, I spent the afternoon reading the code. And I get the gist of it.

[21:22] <masak> I think the shunting yard algorithm is closely related but not identical.

[21:23] <cognominal> btw, I need the trick to use C<.method(args)> as postfix to avoid left recursion in my bast grammar.

[21:27] <cognominal> different things but the vocabulary is the same, so my confusion : http://en.wikipedia.org/wiki/Operator-precedence_grammar  http://en.wikipedia.org/wiki/Simple_precedence_grammar http://en.wikipedia.org/wiki/Operator-precedence_parser

[21:28] *** telex joined
[21:29] <adu> cognominal: I'm not a fan of LALR

[21:29] <adu> I am a big fan of PEG tho

[21:29] <cognominal> and packrat?

[21:29] <adu> cognominal: I guess

[21:30] <adu> what's the difference?

[21:30] <cognominal> not sure

[21:30] <cognominal> don't drink PEG, btw :)

[21:30] <adu> oh packrat = PEG + memoization

[21:30] <cognominal> ok

[21:31] <cognominal> I thought they were related

[21:31] <cognominal> I don't think there is a good book that is up to date with all these kind of grammar.

[21:31] <adu> PEG just requires an ordered '|', as opposed to longest-match '|'

[21:32] <cognominal> I was told that the last edition of the dragon book was not worth the price.

[21:33] <cognominal> 100$ is a total rip-off

[21:35] <cognominal> ingy is a big fan of PEGs, I think

[21:55] *** kurahaupo joined
[21:57] <pmichaud> expression parsing in NQP and Rakudo is a shift/reduce parser

[21:57] <pmichaud> with infinite levels of precedence available

[21:59] *** grondilu joined
[22:00] <cognominal> thx

[22:02] <pmichaud> or, more accurately, an "operator precedence parser".  

[22:06] *** tgt joined
[22:14] <grondilu> wow, there is a v5 module now, as specced.  Nice.

[22:22] *** felher joined
[22:29] *** Vlavv_ joined
[22:30] <masak> 'night, #Perl6

[22:30] <masak> #perl6*

[22:30] <lizmat> night masak, and #perl6

[23:10] <adu> cognominal: well I'm a big fan of PEGs because they're provably composable

[23:27] <adu> I have a question

[23:29] <adu> so Str has index and rindex methods, but instead of ltrim and rtrim there's trim-trailing and trim-leading?

[23:32] <[Coke]> masak: http://boingboing.net/2013/04/27/automated-constrained-poetry.html?utm_source=feedly

[23:44] *** crab2313 joined
[23:49] *** tgt left
[23:50] *** berekuk joined
