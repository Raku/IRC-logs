[00:00] <lue> xenoterracide: there's no such bad practice sentiment for P6 modules AFAIK. Even if, just because it's a bad idea doesn't mean no-one will do it :)

[00:01] <lue> FROGGS: ‚ò∫

[00:01] <xenoterracide> maybe a % modules hash would fix it though, then you see if you already have loaded a module, however that'd have to work otherwise

[00:01] <xenoterracide> me not being all that familiar with this multi authority / version thought

[00:02] <FROGGS> we have a %loaded_modules hash in our module loader

[00:02] <xenoterracide> so if you define something within the scope it's seen and doesn't try to laod it

[00:02] <xenoterracide> from an external file

[00:02] <lue> I think that ("one class per file" & "class name matches relative path + basename") matches a very small number of modules, both theoretically and practically.

[00:02] <lue> (or it will, in the asymptotic future)

[00:03] <FROGGS> the path won't matter in future

[00:03] <xenoterracide> lue: right but then how does use work? I'm not sure I see the problems this creates that use doesn't have a solution for?

[00:03] <FROGGS> it is all about the module name and the things which are inside

[00:03] <FROGGS> and you only import the stuff you request

[00:04] <xenoterracide> that brings another thought I had

[00:04] <xenoterracide> can you have a module that exports a simple class name? or the like?

[00:04] <FROGGS> so "use Foo" will locate a comp unit, and if there is a Foo package inside, it will import from it

[00:04] <FROGGS> (and it will ignore the rest)

[00:04] <lue> xenoterracide: my point is that implicitly loading Foo/Bar.pm6 when trying  class Baz is Foo::Bar  isn't a very useful feature.

[00:04] <xenoterracide> module MyAppliction::Model { class User is export { } } ?

[00:04] <xenoterracide> or the like

[00:05] <FROGGS> I think the MyAppliction::Model::User is already visible without the "is export", because it is not my-scoped

[00:05] <lue> p: module Foo::Bar { class Baz { method OK { say "hi" } }; Foo::Bar::Baz.OK

[00:05] <camelia> rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/PLfMkGY9iK‚ê§Unable to parse expression in block; couldn't find final '}' ‚ê§at /tmp/PLfMkGY9iK:1‚ê§------> [32mthod OK { say "hi" } }; Foo::Bar::Baz.OK[33m‚èè[31m<EOL>[0m‚ê§    expecting any ‚Ä¶¬ª

[00:06] <xenoterracide> lue: eh, I'm just all about reducing boilerplate where possible, I know in p5 I get annoyed at having to rename classes in 3 places because I renamed a namespace

[00:06] <lue> p: module Foo::Bar { class Baz { method OK { say "hi" } } }; Foo::Bar::Baz.OK

[00:06] <camelia> rakudo-parrot 53c60c: OUTPUT¬´hi‚ê§¬ª

[00:06] *** baest joined
[00:06] <xenoterracide> FROGGS: I'm more wondering if I can simplify to just using an object name User

[00:06] <lue> xenoterracide: modules != classes, at least not in Perl 6.

[00:06] <xenoterracide> lue: I know that

[00:06] <lue> that's why i object to the idea.

[00:07] *** go|dfish left
[00:07] <FROGGS> xenoterracide: you might want to use an EXPORT sub in the comp unit then...

[00:07] <xenoterracide> FROGGS: sounds evil

[00:07] <FROGGS> xenoterracide: that sounds as evil as en import sub in P5 :o)

[00:08] <lue> There's no guarantee class Foo::Bar exists in module Foo::Bar. Adding a feature in Perl 6 that assumes this is wrong. Allowing you to get away with not declaring a thing /somehow/ additionally makes it doubly wrong :)

[00:08] <xenoterracide> well assuming I'm exporting a sub that hides' the class name

[00:08] <FROGGS> but it would look like: sub EXPORT(|) { my %e; %e<User> := MyAppliction::Model::User; %e }

[00:08] *** spider-mario left
[00:09] <xenoterracide> wouldn't class Foo::Bar in module Foo::Bar be Foo::Bar::Foo::Bar ?

[00:10] <FROGGS> lue: if it loads a comp unit and there is no Foo::Bar that helps to solve the trait, it would explode at compile time

[00:10] <FROGGS> xenoterracide: I think so

[00:11] <FROGGS> p: module Foo::Bar { class Foo::Bar { } }; say GLOBAL::

[00:11] <camelia> rakudo-parrot 53c60c: OUTPUT¬´("Foo" => Foo).hash‚ê§¬ª

[00:11] <FROGGS> p: module Foo::Bar { class Foo::Bar { } }; say GLOBAL::Foo::Bar::

[00:11] <camelia> rakudo-parrot 53c60c: OUTPUT¬´().hash‚ê§¬ª

[00:11] <FROGGS> k, it is smart :o)

[00:12] <lue> FROGGS: yes, as it should. xenoterracide's suggestion would be to try and find the module that class is in before exploding (i.e. not having    use The::Class::Is::Here;    and having the compiler figure out and loading that module if a class from it is used.)

[00:13] <FROGGS> lue: I don't see a problem with that

[00:13] <xenoterracide> I'm having 2 different idea's

[00:13] <lue> use A::B; class D is C { };  ===  class D is C { };    , essentially.

[00:13] <FROGGS> it would just do two extra steps... need Foo::Bar and import Foo::Bar

[00:14] <xenoterracide> idea one  is that class Foo does Bar; is exactly the same as use Bar; class Foo does Bar; (except Bar should not be "globally scoped" or in that outer scope)

[00:14] *** PacoAir left
[00:14] <lue> FROGGS: but how would P6 find the module containing the class?

[00:14] <FROGGS> lue: exactly like it does with a use statement

[00:15] <lue> FROGGS: no, use finds a module, from which classes can be read. I'm talking about   find_module(:with_class<Foo::Bar>)

[00:15] <FROGGS> lue: there is no such thing

[00:15] <xenoterracide> 2) module MyApp::Model { class User is export } module MyApp::Controller { use MyApp::Model :all User.new } or some such

[00:15] <lue> FROGGS: exactly!

[00:15] <FROGGS> lue: so you say "use Foo; Foo.new" is illegal too?

[00:16] *** hoverboard is now known as CLIENTPOLICE

[00:16] <lue> My point is that trying to find the right class from a pool of indefinite numbers of modules is not useful.

[00:16] *** CLIENTPOLICE is now known as hoverboard

[00:16] <FROGGS> lue: it would not try to find a class like "use Foo" does not try to find a class

[00:17] <lue> FROGGS: I'm picturing a ~/.perl6/<ver>/lib/ with hundreds of modules. Find me the right Foo::Bar used in the statement   class Baz is Foo::Bar

[00:17] <FROGGS> nothing tries to find a class here --> "use Foo; Foo.new"

[00:18] <FROGGS> but we (the user) know that the Foo "module" provides a Foo class, so we can type a "Foo.new" afterwards

[00:18] <lue> FROGGS: xenoterracide's original suggestion was this: consider "class A is B" --- if there is no class B in the current compunit, load module B

[00:18] <FROGGS> which is the same for "Foo does Bar", we know that there is a "module" Bar that Foo can do

[00:18] <FROGGS> lue: correct

[00:19] <lue> ? does works on roles, not modules

[00:19] <FROGGS> true

[00:19] <lue> (the genericest term is "package", IIRC)

[00:19] <xenoterracide> would work on classes to

[00:19] <xenoterracide> too*

[00:19] <xenoterracide> should not import anything

[00:19] <xenoterracide> well

[00:19] * lue tries to surpass the limitations of one-line-at-a-time IRC

[00:19] <xenoterracide> anything additional

[00:20] <FROGGS> lue: "Foo does Bar" should only locate a comp unit that under the name Bar, then it would import from it like the use statement does

[00:21] <FROGGS> and if there happends to be a Bar role in it, we would be happy

[00:21] <FROGGS> that is exactly what "use Bar; Foo does Bar" does

[00:21] <lue> FROGGS: give me a minute, I'm writing a gist to better demonstrate the issues.

[00:21] <FROGGS> the "use Bar" does not search for a role either

[00:23] <lue> FROGGS: how else would you avoid unnecessarily loading modules in "Foo does Bar" situations?

[00:24] <FROGGS> unnecessarily? it would only load it once

[00:24] <FROGGS> and it would be satisfied if there is a role Bar after that or it would explode nicely

[00:25] <xenoterracide> searching % inc and the % modules or whatever

[00:25] <xenoterracide> before doing things

[00:25] * FROGGS .oO( loaded comp unit Bar does not provide a role Bar needed in "Foo does Bar‚èè" )

[00:25] <FROGGS> xenoterracide: that is the ModuleLoader's job

[00:26] <FROGGS> xenoterracide: we don't need to invent anything at that point since it does all that

[00:27] <xenoterracide> FROGGS: well yeah, I assumed so, I think I was trying to just point out to lue that I believe that is how it does that... 

[00:27] <xenoterracide> and of course if it wasn't found it'd die the same way use does or the same way a missing symbol or whatever does

[00:27] <xenoterracide> if you try to do Foo does Bar without importing Bar now

[00:28] <lue> FROGGS, xenoterracide: https://gist.github.com/lue/8d1bed521dd48b1a6dad

[00:28] *** go|dfish joined
[00:29] <lue> (updated for formatting)

[00:29] <FROGGS> lue: if you do a "use Baz; Foo is Bar { }" you will be lost too

[00:29] *** ajr_ left
[00:30] <xenoterracide> lue: what is the guarantee if I do use Bar; that module Bar contains a class Bar?

[00:30] <lue> FROGGS: I think you meant use Bar there. And in that case, you'd know exactly what things your loading into your compunit.

[00:30] <FROGGS> lue: 1) example "use Bar; Foo is Bar", if there is no Bar in Bar, you are lost too

[00:31] <FROGGS> lue: no, I dont

[00:31] <lue> xenoterracide: There isn't. /You have to know ahead of time, that's why implicit loading doesn't work/!

[00:32] *** hoverboard left
[00:32] <xenoterracide> no I don't understand the behavior is the same

[00:32] <FROGGS> lue: 3) to make S11 work, the installed modules provide a list of namespaces, that is what we use when we hit a use statement, and this is what we could use here

[00:32] <xenoterracide> there's no guarantee the programmer isn't an idiot and tried to load some bullshit

[00:33] <FROGGS> correct

[00:33] <FROGGS> you can use a package and hope there is a role with that name in it, and you can do a module an pray that there a role is in there...

[00:34] <FROGGS> if you guesses wrong, it will explode in the same way

[00:34] <xenoterracide> lue: I understand what you're saying, but I don't see how these problems aren't either already there or already addressed

[00:34] <FROGGS> (because the symbol you want to do is unknown)

[00:35] <lue> Mrf. Implicit loading demands an organizational scheme that many modules don't comply with, and there *will* be side effects if the scheme isn't complied with by the desired object's module.

[00:35] <lue> xenoterracide: The problem is that the programmer shouldn't have to contend with "waitaminute, Perl 6 just /assumed/ I forgot a use statement?"

[00:36] <lue> Implicit loading could work in C<no strict> I'll admit (in line with it allowing C<$a = 42> as a declaration), but /certainly/ not in the default modes.

[00:36] <xenoterracide> perl6 sometimes assumes a lot I think? also if it's understood that (and Moose does this) that the does/is/etc implies an attempt to import if not already, then, it'll be known it tries to import

[00:36] <FROGGS> lue: I am not fond of implicit loading either, but I can't agree to the points you made (in the gist for example)

[00:37] <xenoterracide> FROGGS: I'd be curious to know why you aren't fond of it?

[00:37] <xenoterracide> I mean maybe there's some downside that I've never thought of

[00:38] <FROGGS> xenoterracide: I'm not sure.... one thing is that we have statements for loading packages...

[00:38] <FROGGS> if we do autoloading we would need to do it in more places

[00:38] <FROGGS> basically everytime you use a bare name :P

[00:38] <lue> FROGGS: whatever similarities implicit loading shares with "use", IL adds the nice feature of "the programmer has *no control* over whether or not this happens, and *no control* over what gets loaded".

[00:39] <xenoterracide> FROGGS: I'm not sure I'd say in all places, just obvious ones... (presumably does and is would also attempt to load from what I've seen)

[00:39] <xenoterracide> hmm

[00:39] <FROGGS> lue: you have exactly the same control, you give it a name, and it starts searching for such a comp unit... and that name is identical in the use statement to the trait

[00:40] <lue> class Foo is Bar; sans IL will tell me I messed up if I mean 'Baz'. with IL that's not necessarily true.

[00:41] <lue> FROGGS: unless 'use strict' turns off IL, and 'no strict' turns it on, you really *don't* have control over it.

[00:41] <FROGGS> lue: how does it tell that you messed up?

[00:41] <lue> r: class Baz { }; class Foo is Bar { }

[00:41] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[00:41] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/4jV7EP48C9‚ê§'Foo' cannot inherit from 'Bar' because it is unknown.‚ê§Did you mean one of these?‚ê§    'Bag'‚ê§    'Baz'‚ê§‚ê§at /tmp/4jV7EP48C9:1‚ê§------> ‚ê§¬ª

[00:42] <FROGGS> ahh, that one

[00:42] <FROGGS> I've read a "use Baz; class Foo is Bar { }" there

[00:42] <xenoterracide> that's interesting, but why would the error be different?

[00:42] <FROGGS> lue: yes, I agree on this one

[00:43] <xenoterracide> why would IL not give that error?

[00:43] <FROGGS> the thing is, in one example you intended to load a module but not in the other

[00:43] <lue> xenoterracide: module Bar could have a class Bar

[00:44] <FROGGS> and then you would just inherit from a class Bar you don't even know :o)

[00:44] *** Ben_Goldberg is now known as BenGoldberg

[00:44] <xenoterracide> wouldn't I have to do Class Foo is Bar::Bar then?

[00:44] <FROGGS> no

[00:44] <lue> FROGGS: I don't see the 'is' trait and think 'loads modules', which is what IL thinks.

[00:45] <FROGGS> we've seen that it does not double up names... and it would never do that with comp unit names, because these are kinda invisible after loading

[00:45] <xenoterracide> module Bar { class Bar {} role Bar {} } < is this legal?

[00:45] <FROGGS> dont think so

[00:45] <xenoterracide> r: module Bar { class Bar {} role Bar {} }

[00:45] <FROGGS> p: module Bar { class Bar {}; role Bar {} } < is this legal?

[00:45] <FROGGS> p: module Bar { class Bar {}; role Bar {} }# < is this legal?

[00:45] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[00:45] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/1Eva_DFg_u‚ê§Two terms in a row‚ê§at /tmp/1Eva_DFg_u:1‚ê§------> [32mmodule Bar { class Bar {} [33m‚èè[31mrole Bar {} }[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        horizontal‚Ä¶¬ª

[00:45] <camelia> rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/0jeGX4ODiz‚ê§Redeclaration of symbol Bar‚ê§at /tmp/0jeGX4ODiz:1‚ê§------> [32mmodule Bar { class Bar {}; role Bar [33m‚èè[31m{} } < is this legal?[0m‚ê§    expecting any of:‚ê§        statemen‚Ä¶¬ª

[00:46] <camelia> rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CxtE6SXXG3‚ê§Redeclaration of symbol Bar‚ê§at /tmp/CxtE6SXXG3:1‚ê§------> [32mmodule Bar { class Bar {}; role Bar [33m‚èè[31m{} }# < is this legal?[0m‚ê§    expecting any of:‚ê§        stateme‚Ä¶¬ª

[00:46] <FROGGS> redecl

[00:46] <lue> and once again, basing IL's enabled-ness on the use/no-ness of 'strict' would be fine with me (though I object to the concept in general).

[00:46] <FROGGS> p: module Bar { class Bar {}; role Bar {} }; say GLOBAL::

[00:46] <camelia> rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Ve7lCxXUXM‚ê§Redeclaration of symbol Bar‚ê§at /tmp/Ve7lCxXUXM:1‚ê§------> [32mmodule Bar { class Bar {}; role Bar [33m‚èè[31m{} }; say GLOBAL::[0m‚ê§    expecting any of:‚ê§        statement l‚Ä¶¬ª

[00:46] <FROGGS> p: module Bar { class Bar {}; role Baz {} }; say GLOBAL::

[00:46] <camelia> rakudo-parrot 53c60c: OUTPUT¬´("Bar" => Bar).hash‚ê§¬ª

[00:46] <FROGGS> p: module Bar { class Bar {}; role Baz {} }; say GLOBAL::BAR::

[00:46] <camelia> rakudo-parrot 53c60c: OUTPUT¬´().hash‚ê§¬ª

[00:46] <FROGGS> p: module Bar { class Bar {}; role Baz {} }; say GLOBAL::Bar::

[00:46] <camelia> rakudo-parrot 53c60c: OUTPUT¬´("Bar" => Bar, "Baz" => Baz).hash‚ê§¬ª

[00:46] <FROGGS> there is a Bar::Bar

[00:47] <FROGGS> p: module Bar { class Bar {} }; say GLOBAL::Bar::

[00:47] <camelia> rakudo-parrot 53c60c: OUTPUT¬´("Bar" => Bar).hash‚ê§¬ª

[00:47] <lue> I vehemently object to the assumption of sloppyness when I'm using strict, and since no-one clarified if it happens during 'use strict', it felt like a 'always on' proposal.

[00:47] <xenoterracide> that was expected, but would you end up being able o have Foo extend just Bar then?

[00:47] <lue> (and perhaps I object to the concept in general because I never explicitly 'no strict' ‚ò∫)

[00:47] <xenoterracide> lue: is there a use strict in p6? I thought I once read some objection to that

[00:48] <lue> xenoterracide: there is, but it's on by default in most places, save for the perl6 -e IIRC

[00:48] <FROGGS> xenoterracide: strict is always on except -e

[00:48] <FROGGS> and if you do: "6; $x = 42" the 6 would turn on lax mode too

[00:49] <lue> IL fits perfectly with 'no strict', in my view. Just not 'use strict' :)

[00:49] <FROGGS> sure

[00:49] <lue> That way I can object to IL and solve my issue by not doing 'no strict' :) .

[00:49] <FROGGS> :o)

[00:50] <xenoterracide> dunno if p6 has the concept of feature, but I think I'd prefer the other way `no feature 'IL'` or whatever, it seems like, a "probably does the right thing most of the time" feature, IMO

[00:50] <xenoterracide> because I'm lazy

[00:50] <xenoterracide> and I'd rather explicitly turn off features

[00:50] *** hoverboard joined
[00:50] <xenoterracide> than enable them

[00:50] <xenoterracide> depending on the feature

[00:50] <lue> xenoterracide: I just lumped it with strict because it's soooo similar to   $a = 42;   in nature

[00:50] <xenoterracide> I don't know if I agree with that

[00:51] <lue> but there could be an IL pragma, by default 'no IL'

[00:51] <xenoterracide> I disagree with disabled by default in this case

[00:51] <xenoterracide> it would lose most appeal

[00:51] <lue> xenoterracide: I'm sure there are some features you'd rather not have enabled by default :)

[00:51] <xenoterracide> well some

[00:51] <xenoterracide> but p5 has turned into this, turn on everything modern

[00:52] <xenoterracide> boilerplate fest

[00:52] <xenoterracide> I want to remove useless boilerplate

[00:52] <lue> xenoterracide: I think IL has too many potential side-effects to leave it on by default.

[00:53] <xenoterracide> lue: possibly, though seems like maybe let an implementation vet that. As mentioned Moose does it without too many problems, though apparently Class::Load's way of doing that had some less than good side effects, but that's something to do with Class::Load

[00:53] <lue> if I somehow don't have a class Bar into my compunit, I'd much rather have    class Foo is Bar    break immediately, than to cause my code to behave in unexpected ways.

[00:54] <xenoterracide> anyways, beating the horse

[00:54] <lue> btw, I said "similar to $a = 42" because they both can wreak havoc if you're not careful.

[00:55] <lue> (in addition to giving you the benefit of the doubt on not-yet-declared things)

[00:55] <lue> summation of my view: if IL is turned off by 'use strict', I'm fine with it existing, despite my misgivings on the concept.

[00:57] <xenoterracide> btw, I think that having more than one class/role/module per file is a bit like $a = 42, finding where it began becomes a problem

[00:58] <lue> ? I'm not making the connection.

[00:58] *** Celelibi left
[00:58] <lue> It's very convenient to group small Grammar/Action combos in one file, for instance.

[00:59] <xenoterracide> curious could one do something like class Foo does require('Bar'):: # however that's done, I need to make a note of the way you can do the require( ).new, because I know that owrks now

[00:59] * lue --dinner &

[00:59] <xenoterracide> lue: well the thing I like about one package per file is it generally makes it easy to find the code I'm looking for

[01:00] <xenoterracide> I have a module name, and the code is in a matching file

[01:01] <xenoterracide> with lexical variables I always know where the variable began, with one module per "import statment" I always know where the module came from

[01:02] <xenoterracide> I don't care if that import is done via use/require/is/does

[01:02] <xenoterracide> I just want to know where it came from

[01:02] <xenoterracide> it either better be in the current file, or the import should be obvious

[01:02] *** Celelibi joined
[01:06] *** kurahaupo_mobile left
[01:16] *** Ben_Goldberg joined
[01:17] *** BenGoldberg left
[01:38] *** nebuchadnezzar joined
[01:41] *** kaare_ left
[02:05] <dalek> specs: bbebb37 | larry++ | S05-regex.pod:

[02:05] <dalek> specs: remove <prior> rule

[02:05] <dalek> specs: 

[02:05] <dalek> specs: This is a low-gain feature that penalizes everyone.

[02:05] <dalek> specs: review: https://github.com/perl6/specs/commit/bbebb3763a

[02:06] <colomon> TimToady++

[02:13] *** kaare_ joined
[02:15] *** abnorman joined
[02:19] *** BenGoldberg joined
[02:19] *** logie left
[02:20] *** Ben_Goldberg left
[02:45] <colomon> rakudo (parrot) build fails to produce a working perl6 for me on the smoke test machine.

[02:45] <colomon> Missing or wrong version of dependency 'src/Perl6/Actions.nqp'

[02:45] <colomon> current instr.: '' pc 938 (src/gen/perl6.pir:332) (gen/parrot/main.nqp:58)

[02:46] <TimToady> make clean?

[02:46] <colomon> can try that

[02:46] <TimToady> or p-clean

[02:50] <dalek> roast: b1ac97a | larry++ | S (2 files):

[02:50] <dalek> roast: remove tests for <prior>

[02:50] <dalek> roast: review: https://github.com/perl6/roast/commit/b1ac97a14d

[02:54] <colomon> make clean didn't help.

[02:54] <colomon> p-clean?

[02:56] <TimToady> just a subset for parrot

[02:57] <colomon> just blew away my rakudo directory.  

[03:06] *** abnorman left
[03:18] *** dayangkun left
[03:20] <colomon> TimToady++ # that did it

[03:26] *** abnorman joined
[03:27] *** raiph joined
[03:29] <BenGoldberg> Does anyone know if it would be possible to port the following: http://perl.plover.com/obfuscated/solution.html to perl6?

[03:31] *** dayangkun joined
[03:37] *** raiph left
[03:39] *** vinian joined
[03:39] *** vinian left
[03:41] <TimToady> you could maybe do it with channels

[03:41] <TimToady> (jvm only right now)

[03:42] <TimToady> we're a bit weak on pipes and forks at the moment

[03:43] <TimToady> but channels and start {} are much the same

[03:53] *** raiph joined
[03:57] *** vinian joined
[03:57] *** hoverboard left
[04:16] *** rurban1 joined
[04:19] *** raiph left
[04:24] *** hoverboard joined
[04:27] <BenGoldberg> std: sub infix:<foo> is assoc('list') { join ',', @_ }; say [Rfoo] 1..4

[04:27] <camelia> std 4731beb: OUTPUT¬´ok 00:01 131m‚ê§¬ª

[04:27] <BenGoldberg> rn: sub infix:<foo> is assoc('list') { join ',', @_ }; say [Rfoo] 1..4

[04:27] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[04:27] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´Too many positional parameters passed; got 4 but expected 2‚ê§  in block  at gen/parrot/CORE.setting:16558‚ê§  in sub  at gen/parrot/CORE.setting:16665‚ê§  in block  at /tmp/vgbOMbkp0q:1‚ê§‚ê§¬ª

[04:27] <camelia> ..niecza v24-108-g17d73e4: OUTPUT¬´Unhandled exception: Excess arguments to ANON, used 2 of 4 positionals‚ê§  at /tmp/lpSDJXBSiR line 0 (ANON @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2767 (reduceop @ 12) ‚ê§  at /tmp/lpSDJXBSiR line 1 (mainline @ 4) ‚ê§  at /home/p6eval/n‚Ä¶¬ª

[04:28] *** atroxaper joined
[04:29] <TimToady> rn: sub infix:<foo> is equiv(&infix:<X>) { join ',', @_ }; say [Rfoo] 1..4

[04:29] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[04:29] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Ke38POvEUp‚ê§Routine given to equiv does not appear to be an operator‚ê§at /tmp/Ke38POvEUp:1‚ê§------> ‚ê§¬ª

[04:29] <camelia> ..niecza v24-108-g17d73e4: OUTPUT¬´Unhandled exception: Excess arguments to ANON, used 2 of 4 positionals‚ê§  at /tmp/kkWOZIvTjL line 0 (ANON @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2767 (reduceop @ 12) ‚ê§  at /tmp/kkWOZIvTjL line 1 (mainline @ 4) ‚ê§  at /home/p6eval/n‚Ä¶¬ª

[04:30] <TimToady> rn: sub infix:<foo> is equiv(&infix:<X>) { '(' ~ @_.join(',') ~ , @_ }; say [foo] 1..4

[04:31] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[04:31] <camelia> ..niecza v24-108-g17d73e4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Preceding context expects a term, but found infix , instead at /tmp/Zmk_hQvdxN line 1:‚ê§------> [32mquiv(&infix:<X>) { '(' ~ @_.join(',') ~ [33m‚èè[31m, @_ }; say [foo] 1..4[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[04:31] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/PD4GqIQKIc‚ê§Preceding context expects a term, but found infix , instead‚ê§at /tmp/PD4GqIQKIc:1‚ê§------> [32muiv(&infix:<X>) { '(' ~ @_.join(',') ~ ,[33m‚èè[31m @_ }; say [foo] 1..4[0m‚ê§¬ª

[04:31] <TimToady> rn: sub infix:<foo> is equiv(&infix:<X>) { '(' ~ @_.join(',') ~ ')' }; say [foo] 1..4

[04:31] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[04:31] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CIY1QYI2dn‚ê§Routine given to equiv does not appear to be an operator‚ê§at /tmp/CIY1QYI2dn:1‚ê§------> ‚ê§¬ª

[04:31] <camelia> ..niecza v24-108-g17d73e4: OUTPUT¬´(1,2,3,4)‚ê§¬ª

[04:34] <BenGoldberg> n: sub infix:<foo> is equiv(&infix:<X>) { '(' ~ @_.join(',') ~ ')' }; say [Rfoo] 1..4

[04:34] <camelia> niecza v24-108-g17d73e4: OUTPUT¬´Unhandled exception: Excess arguments to ANON, used 2 of 4 positionals‚ê§  at /tmp/lu6wgtIIlv line 0 (ANON @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2767 (reduceop @ 12) ‚ê§  at /tmp/lu6wgtIIlv line 1 (mainline @ 4) ‚ê§  at /home/p6eval/n‚Ä¶¬ª

[04:35] <BenGoldberg> How do I test whether a specific operator "is assoc('list')"

[04:37] <BenGoldberg> In particular, whether Rfoo (when foo is assoc('list') is *also* assoc('list')... and what the prototype of Rfoo is (actually, I'm 99% certain that Rfoo's prototype is to take 2 positional parameters...)

[04:48] *** preflex left
[04:48] *** preflex_ joined
[04:48] *** ChanServ sets mode: +v preflex_

[04:49] *** preflex_ is now known as preflex

[04:57] *** atroxaper left
[04:57] *** atroxaper joined
[04:58] *** atroxaper left
[05:10] *** abnorman left
[05:14] <[Coke]> BenGoldberg: I don't see a way to get that from the sub itself.

[05:14] <[Coke]> digging through: say (&infix:<+>).^methods.sort>>.Str.squish

[05:14] <[Coke]> I think you'd have to introspect the grammar.

[05:17] *** BenGoldberg left
[05:32] *** grondilu joined
[05:40] *** hoverboard left
[05:41] *** daniel-s_ joined
[05:45] *** rurban1 left
[05:47] *** daniel-s_ left
[05:50] *** daniel-s_ joined
[06:06] *** atroxaper joined
[06:15] *** logie joined
[06:20] *** logie left
[06:21] *** grondilu left
[06:23] *** BAMbanda joined
[06:23] <BAMbanda> so how does one go from a newb to a mage?

[06:23] <BAMbanda> http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg

[06:31] <moritz> BAMbanda: with lots of practise :-)

[06:32] <BAMbanda> moritz, indeed. The humor and personality of the perl6 and perl community in general makes this language too hard to stay away from

[06:34] *** SamuraiJack_ joined
[06:42] *** kurahaupo joined
[06:42] *** kurahaupo left
[06:42] <moritz> \o/

[06:45] *** kurahaupo joined
[06:51] *** darutoko joined
[07:01] *** atroxaper left
[07:48] *** FROGGS[mobile] left
[07:52] *** FROGGS[mobile] joined
[08:06] *** logie joined
[08:13] *** atroxaper joined
[08:17] *** kurahaupo left
[08:22] *** BAMbanda left
[08:42] *** broquaint left
[08:43] *** broquaint joined
[08:45] *** SamuraiJack_ left
[08:45] *** SamuraiJack_ joined
[08:49] *** yogan joined
[08:52] *** SamuraiJack_ left
[09:05] *** atroxaper left
[09:06] *** atroxaper joined
[09:17] *** FROGGS[mobile] left
[09:23] *** xinming_ left
[09:27] *** daniel-s_ left
[09:27] *** daniel-s_ joined
[09:28] *** xinming joined
[10:07] *** xenoterracide left
[10:08] *** gfldex left
[10:08] *** kurahaupo joined
[10:10] *** gfldex joined
[10:13] *** kurahaupo_mobile joined
[10:26] *** daniel-s_ left
[10:31] *** kivutar joined
[10:37] *** PacoAir joined
[10:40] *** Rotwang joined
[10:53] *** zakharyas joined
[11:11] *** denis_boyun joined
[11:15] *** denis_boyun__ joined
[11:15] *** denis_boyun left
[11:20] *** atroxaper left
[11:20] *** atroxaper joined
[11:34] *** atroxaper left
[11:34] *** cognominal left
[11:34] *** atroxaper joined
[11:42] *** atroxaper left
[11:42] *** atroxaper joined
[11:46] *** spider-mario joined
[11:51] * masak suddenly resurfaces from celebrating Christmas

[11:51] *** kivutar left
[11:59] <masak> TimToady++ # "burying the bones of naysayers and yaysayers alike"

[12:03] <masak> that blog post was beautiful.

[12:04] <masak> (too bad the first comment by some guy talks about "PERL7" as if that were a solution to anything)

[12:05] * masak reads moritz++' Day 23 post

[12:08] *** gfldex left
[12:12] <timotimo> morning o/

[12:16] *** dmol left
[12:17] <masak> timotimo! \o/

[12:20] <moritz> \o *

[12:22] *** atroxaper left
[12:23] *** atroxaper joined
[12:23] *** denis_boyun joined
[12:24] *** denis_boyun__ left
[13:02] <timotimo> should this work?

[13:02] <timotimo> r: say "abc123" ~~ / <+alpha+ws>+ /

[13:02] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[13:02] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´ÔΩ¢abcÔΩ£‚ê§‚ê§¬ª

[13:02] <timotimo> rakudo-parrot infiniloops locally, it seems

[13:03] <timotimo> er. abc123 isn't the right string for that rule

[13:03] <timotimo> r: say "abc abc abc" ~~ / <+alpha+ws>+ /

[13:03] <timotimo> r: say "abc abc abc" ~~ / <+alpha+\s>+ /

[13:03] <timotimo> r: say "abc abc abc" ~~ / <+alpha+[\s]>+ /

[13:04] <camelia> rakudo-parrot 53c60c, rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[13:04] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[13:04] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/B4buqhU5Or‚ê§Unable to parse expression in metachar:sym<assert>; couldn't find final '>' ‚ê§at /tmp/B4buqhU5Or:1‚ê§------> [32msay "abc abc abc" ~~ / <+alpha+[33m‚èè[31m\s>+ /[0m‚ê§    expecti‚Ä¶¬ª

[13:04] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[13:04] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´ÔΩ¢abc abc abcÔΩ£‚ê§‚ê§¬ª

[13:04] *** atroxaper left
[13:05] *** atroxaper joined
[13:09] *** rindolf joined
[13:09] *** kivutar joined
[13:22] <timotimo> hm. now Nil.any_method returning nil becomes an itch i'd like to scratch :P

[13:24] <timotimo> r: say (try Nil.ast) // "foo"

[13:24] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[13:24] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´foo‚ê§¬ª

[13:24] <timotimo> IMO, that shouldn't throw; probably the // operator causing it?

[13:24] <timotimo> ... wait what?

[13:24] <timotimo> that fails locally :\

[13:25] <timotimo> oh, i was wrong it seems :)(

[13:38] *** filly joined
[13:44] *** FROGGS[mobile] joined
[13:53] *** Marverick joined
[13:53] *** Marverick left
[14:08] <masak> timotimo: I think <ws> will always loop infinitely if you quantify it with * or + (because it can match the empty string)

[14:10] <timotimo> ah, right

[14:26] <masak> you're not the first one around which that trap closes.

[14:26] <masak> who*

[14:28] <timotimo> i could go around and put round tuits that fit perfectly into power outlets on people's desks ... into them

[14:31] * masak .oO( these tuits are shocking! )

[14:33] <timotimo> oh damn

[14:33] <timotimo> installing Rakudo::Debugger with panda is currently broken

[14:33] <timotimo> and i have a grammar i want to debug

[14:40] *** Rotwang left
[14:42] <masak> why is it broken?

[14:42] <masak> "installing module X in panda is broken" feels like it deserves its own issue tracker.

[14:42] <masak> (probably panda's own)

[14:44] *** dayangkun left
[14:45] *** dayangkun joined
[14:49] *** Rotwang joined
[14:50] *** hoverboard joined
[14:52] *** Rotwang left
[14:52] *** Rotwang joined
[14:52] *** Rotwang1 joined
[14:56] *** lue left
[15:00] <timotimo> masak: it doesn't create a binary i could run

[15:02] <Rotwang> Is there some portable way to create shared libs to be used from NativeCall?

[15:03] <Rotwang> I want to bundle c source altogether with my module.

[15:03] *** raiph joined
[15:03] <Rotwang> the only sane thing I can think of is to use cmake/probably waf

[15:04] <Rotwang> any thoughts?

[15:04] *** kivutar left
[15:05] *** denis_boyun left
[15:07] *** kurahaupo_mobile left
[15:10] *** lue joined
[15:15] <timotimo> Rotwang: no clue :( :(

[15:16] <Rotwang> I'm leaning to cmake, but it sounds silly to add dependency on cmake to compile two c source files [;

[15:17] <timotimo> r: my %payers = timo => 10, rotwang => 5, masak => 4, everyone => 10; say %payers{bag * (-) "everyone"};

[15:17] <timotimo> i want this to work

[15:17] <timotimo> does it?

[15:17] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[15:17] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´(Any)‚ê§¬ª

[15:17] <timotimo> :\

[15:17] <timotimo> p: my %h = a => 1, b => 2; %h{-> $thing { say $thing } };

[15:17] <camelia> rakudo-parrot 53c60c: ( no output )

[15:18] <timotimo> it doesn't call closures that get passed to postcircumfix:<{ }>?

[15:18] <timotimo> that would be *so* neat, though

[15:19] <timotimo> ah, doh

[15:19] <colomon> isn't that a [ ] thing, not a { } thing?

[15:20] <timotimo> it's trying to access %payers{"set(timo, rotwang, masak)"}

[15:21] *** FROGGS[mobile] left
[15:27] *** kurahaupo left
[15:28] *** rurban1 joined
[15:31] *** rindolf left
[15:32] *** filly left
[15:42] *** thou joined
[15:46] *** filly joined
[15:50] *** filly left
[15:53] *** filly joined
[15:58] *** filly left
[16:00] *** filly joined
[16:10] *** filly left
[16:11] *** filly joined
[16:16] *** Rotwang left
[16:16] *** Rotwang1 left
[16:16] *** Rotwang joined
[16:16] *** Rotwang1 joined
[16:17] *** Rotwang left
[16:17] *** Rotwang1 left
[16:17] *** Rotwang joined
[16:17] *** Rotwang left
[16:17] *** Rotwang joined
[16:17] *** dayangkun left
[16:22] *** dmol joined
[16:24] <TimToady> wow, au++ translated Day 24 :)

[16:29] <dalek> rakudo-star-daily: 2d012be | coke++ | log/ (5 files):

[16:29] <dalek> rakudo-star-daily: today (automated commit)

[16:29] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/2d012be530

[16:29] <dalek> perl6-roast-data: 02b29b3 | coke++ | / (3 files):

[16:29] <dalek> perl6-roast-data: today (automated commit)

[16:29] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/02b29b3dcf

[16:29] <timotimo> was there some progress into making method calls to Nil return Nil for non-found methods?

[16:30] *** zaydon joined
[16:30] <TimToady> don't recall seeing any

[16:31] * timotimo just does it

[16:32] *** cognominal joined
[16:33] *** Celelibi left
[16:33] <timotimo> if i've done it correctly, this would have been a tiny amount of code :)

[16:33] <timotimo> hoping to find some test in roast now :P

[16:44] *** xenoterracide joined
[16:44] <TimToady> we've kinda let the backlinks from roast to specs rot a little

[16:45] *** denisboyun joined
[16:58] *** thou left
[16:59] *** atroxaper left
[17:01] *** thou joined
[17:01] *** kaare_ left
[17:11] *** thou left
[17:12] <moritz> p: say Nil.blerg

[17:12] <camelia> rakudo-parrot 53c60c: OUTPUT¬´No such method 'blerg' for invocant of type 'Nil'‚ê§  in block  at /tmp/To9nsAVl3t:1‚ê§‚ê§¬ª

[17:15] <moritz> should be as simple as Nil.^add_fallback(-> $, $ { True }, -> $, $, { -> |c { Nil } } );

[17:15] <FROGGS> s/simple/cryptic/ :o)

[17:16] <moritz> well, it's MOP :-)

[17:16] <moritz> the first argument to add_falback is a closure that determines whether the fallback succeeds

[17:16] <FROGGS> ahh

[17:17] <moritz> and the second argument is a closure that return the actual method object

[17:29] *** denisboyun left
[17:38] *** xinming left
[17:40] *** xinming joined
[17:40] *** colomon left
[17:47] *** xinming left
[17:48] *** xinming joined
[17:54] *** rurban1 left
[17:55] <masak> au++ # http://pugs.blogs.com/pugs/2013/12/advent-ventures.html

[17:58] *** isBEKaml joined
[17:59] <Rotwang> is there some fancy way to check if string is not empty?

[17:59] *** rurban1 joined
[18:00] *** colomon joined
[18:04] <Rotwang> r: " ".trim ~~ /^$/

[18:04] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[18:04] <camelia> ..rakudo-parrot 53c60c: ( no output )

[18:04] *** rurban1 left
[18:04] <Rotwang> I'd got ÔΩ¢ÔΩ£

[18:05] *** rindolf joined
[18:05] <Rotwang> U+FF62 and U+FF63

[18:05] <FROGGS> p: say " ".trim ~~ /^$/

[18:05] <camelia> rakudo-parrot 53c60c: OUTPUT¬´ÔΩ¢ÔΩ£‚ê§‚ê§¬ª

[18:05] <Rotwang> what is it supposed to mean?

[18:05] <FROGGS> that is what Match.gist shows you

[18:05] <FROGGS> braces that indicate a matched literal

[18:06] <FROGGS> err, parens

[18:06] <FROGGS> p: print " ".trim ~~ /^$/

[18:06] <camelia> rakudo-parrot 53c60c: ( no output )

[18:06] <Rotwang> I see

[18:07] *** isBEKaml left
[18:07] <Rotwang> ok, thanks

[18:07] <Rotwang> although my console font doesn't have ÔΩ¢ÔΩ£ :C

[18:08] <FROGGS> :/

[18:08] <FROGGS> sad

[18:09] <FROGGS> Monospace++

[18:24] *** Celelaptop joined
[18:33] *** Celelibi joined
[18:36] *** zby_home_ joined
[18:36] *** ajr joined
[18:37] *** ajr is now known as Guest40855

[18:37] *** Guest40855 is now known as ajr_

[18:39] *** vinian left
[18:44] *** logie left
[18:49] <timotimo> now i think i also have to write candidates that do postcircumfix:<[ ]> and :<{ }> on Nil to return another Nil

[18:49] <timotimo> because right now Nil.foo.bar.baz<quux>[12] gives (Any) whereas i think it should give Nil

[18:50] <TimToady> +1

[18:51] <timotimo> seems very easy, but i'm getting distracted by blinking things and nice people and music and everything

[18:56] *** vinian joined
[18:56] <dalek> specs: 49c25bf | larry++ | S02-bits.pod:

[18:56] <dalek> specs: subscripts also map Nil --> Nil

[18:56] <dalek> specs: 

[18:56] <dalek> specs: This used to fall out of the fact that subscripts were methods, but

[18:56] <dalek> specs: they aren't anymore, so we have to make this explicit.

[18:56] <dalek> specs: review: https://github.com/perl6/specs/commit/49c25bf6b6

[18:56] *** vinian left
[18:59] *** darutoko left
[19:01] <Rotwang> can I return a value from macro?

[19:01] *** psch joined
[19:02] <TimToady> er, you *must* return a value from a macro :)

[19:04] *** tomaw- left
[19:04] <Rotwang> it is not obvious from: http://perl6advent.wordpress.com/2012/12/23/day-23-macros/

[19:04] <Rotwang> (only resource I've found on macros [;)

[19:07] <TimToady> http://perlcabal.org/syn/S06.html#Macros

[19:08] <Rotwang> thanks

[19:12] *** tomaw_ joined
[19:29] <japhb> Who worked on the Rakudo implementation of #= (.WHY) comments?

[19:29] *** zaydon left
[19:29] <tadzik> me

[19:29] <japhb> tadzik: Is there any multi-line variant supported yet?  And what about #| ?

[19:30] *** denisboyun joined
[19:30] <tadzik> japhb: no, I tried to make it work, and for some reason I couldn't :(

[19:30] <japhb> Awww.  :-(

[19:30] *** zby_home_ left
[19:33] <psch> am i underestimating the complexity for the tests needed for bugs like rt #76368? it seems to me many missing tests would simply try to call the invalid statement and verify the error message, wouldn't they?

[19:33] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=76368

[19:34] <Rotwang> I've just segfaulted rakudo with macros ;C

[19:34] <psch> i guess i'm asking if these are low-hanging fruit people don't bother to implement because they're not interesting

[19:35] *** zby_home_ joined
[19:35] <moritz> psch: checking the error message is a bad approach, because the tests break when we improve the error message

[19:35] <moritz> psch: the proper approach is to throw exception objects of the right type, and test those

[19:36] <moritz> psch: see https://github.com/perl6/roast/blob/master/S32-exceptions/misc.t for many examples of how to do it right

[19:36] *** zby_home_ left
[19:36] <psch> thanks moritz, i'll have a look

[19:36] <masak> Rotwang: a macro returns a value, but the value can be Nil, and that (by convention) means "no AST".

[19:36] <moritz> psch: unfortunately, that sometimes means that writing a good tests blocks on throwing the right exception in the first place

[19:36] <masak> Rotwang: 'return;' returns Nil.

[19:37] <psch> i see

[19:38] <Rotwang> r: macro quux { quasi { my $foo = ""; $foo; }; }; constant bar = quux;

[19:38] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[19:38] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´(signal SEGV)¬ª

[19:38] <moritz> p: try eval 'sub foo(Str) {}; foo 42 '; say $!.perl

[19:38] <camelia> rakudo-parrot 53c60c: OUTPUT¬´X::AdHoc.new(payload => "CHECK FAILED:\nCalling 'foo' will never work with argument types (int) (line 1)\n    Expected: :(Str )")‚ê§¬ª

[19:38] * masak submits rakudobug

[19:39] <masak> (the 'constant' one)

[19:39] <Rotwang> http://www.angelfoodcomic.com/wp-content/uploads/I-have-no-idea-what-I-am-doing.jpg

[19:40] <masak> :)

[19:42] <masak> r: macro x { quasi {} }; constant y = x

[19:42] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[19:42] <camelia> ..rakudo-parrot 53c60c: ( no output )

[19:42] <masak> r: macro x { quasi {} }; constant y = x; say "alive"

[19:42] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[19:42] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´alive‚ê§¬ª

[19:43] <masak> r: macro x { quasi { my $foo = ""; $foo } }; constant y = x; say "alive"

[19:43] <camelia> rakudo-jvm 53c60c: OUTPUT¬´(timeout)¬ª

[19:43] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´(signal SEGV)¬ª

[19:43] <masak> oh, this one is already reported...

[19:43] <masak> r: macro x { quasi { my $foo = "" } }; constant y = x; say "alive"

[19:43] <camelia> rakudo-jvm 53c60c: ( no output )

[19:43] <camelia> ..rakudo-parrot 53c60c: OUTPUT¬´(signal SEGV)¬ª

[19:43] <moritz> j: say 42

[19:44] <camelia> rakudo-jvm 53c60c: OUTPUT¬´42‚ê§¬ª

[19:44] <psch> so the bug i linked would is blocked by a missing specific exception for "wrong argument type"

[19:44] <psch> s/would//

[19:45] *** hoverboard left
[19:46] <moritz> yes

[19:46] *** denisboyun left
[19:47] <masak> huh, apparently not separately reported.

[19:49] <masak> r: macro x { quasi { my $foo = "" } }; x; say "alive"

[19:49] <camelia> rakudo-parrot 53c60c: OUTPUT¬´(signal SEGV)¬ª

[19:49] <camelia> ..rakudo-jvm 53c60c: OUTPUT¬´java.lang.NullPointerException‚ê§‚ê§¬ª

[19:50] <masak> no, there it is.

[19:53] <Rotwang> btw. is there a portable line ending "macro"/constant like std::endl in c++?

[19:55] <TimToady> that's what \n is supposed to be; say \xA or so if you really want a linefeed

[19:56] *** jeffreykegler joined
[19:56] <Rotwang> nice, thanks

[19:57] <TimToady> that's how it was at the start, but subsequent history has obscured the fact that \n was name "newline" for a reason :)

[19:58] <TimToady> *named

[20:00] <jeffreykegler> I'd want to go back to the old docs, but I think ASCII "new line" meant a horizontal motion downward ...

[20:01] <jeffreykegler> that did not return to position zero.  They were thinking of teletypes, which were slow.

[20:02] <jeffreykegler> So from that point of view the folks who insisted that logical lines end with CR-LF were following ASCII more strictly

[20:04] <Rotwang> interesting, never thought of that

[20:04] *** benabik joined
[20:05] *** jeffreykegler_ joined
[20:09] *** jeffreykegler left
[20:09] <raiph> i've started a Rakudo contribution quest. "Make Rakudo's sort work with a keyextractor => comparator pair". http://questhub.io/realm/perl/quest/52bca72af6d329e15d0000ca I'd like feedback on comments I've added to the quest, especially the comment titled "The Plan". Tia.

[20:12] *** jeffreykegler_ left
[20:12] *** jeffreykegler_ joined
[20:13] *** FROGGS[mobile] joined
[20:14] *** jeffreykegler_ left
[20:15] *** jeffreykegler_ joined
[20:17] *** zakharyas left
[20:18] <TimToady> there is no ASCII "newline", but yeah, linefeed was just vertical motion, and carriage return, like, returned the carriage to the left margin

[20:18] *** FROGGS[mobile] left
[20:18] *** jeffreykegler__ joined
[20:18] <TimToady> Unix was a bit unusual in abstracting a physical CRLF to \n "newline"

[20:21] <jeffreykegler__> Iy'

[20:21] <jeffreykegler__> Iy'

[20:21] *** jeffreykegler_ left
[20:22] <jeffreykegler__> It's interesting that ASCII did not really have the abstract concept of logical lines -- the nearest thing was RS for record separator

[20:23] <jeffreykegler__> But instead of use RS, Unix decided to give LF an promotion

[20:23] <TimToady> was a bit of a design flaw to overload LF for that, in retrospect

[20:26] *** jeffreykegler_ joined
[20:26] <jeffreykegler_> and was mechanically hard on the teletype, so that you avoided them for speed and to save hardware replacement costs.

[20:26] <jeffreykegler_> So there was good reason to separate CR and LF and to do clever things about avoided CR when you could do so

[20:27] <jeffreykegler_> *avoiding

[20:29] *** jeffreykegler__ left
[20:32] <TimToady> not only that, but the tty driver had to pad with up to (iirc) 5 NUL chars, depending on how far the carriage had to travel

[20:33] <jeffreykegler_> That's right, now that you remind me, one of my early programming tasks was writing the logic for various TTY's and terminals ...

[20:34] <jeffreykegler_> and we had tables that specified how many nulls each one required to do a CR

[20:34] <japhb> Timbus: New Net--IRC PR waiting for you.  :-)

[20:34] <japhb> Help system via introspection FTW

[20:35] <jeffreykegler_> the downside was major, IIRC ... specify too few nulls and the TTY would starting printing the new line before the actual physical return to position 0

[20:50] *** tomaw_ left
[20:55] *** rindolf left
[21:15] *** denisboyun joined
[21:32] *** denisboyun left
[21:40] *** zakharyas joined
[21:45] <Rotwang> does it make sense to list core modules as dependencies of your module?

[21:46] <Rotwang> it doesn't make sense that panda installs already available modules, imo

[21:51] <lue> Rotwang: Only R* comes with core modules. People who use the compiler releases of Rakudo or git repos of a Perl 6 compiler won't necessarily have them.

[21:53] <lue> .oO(I personally blame the ASCII standard for not implementing a specific newline character. Surely, some systems had space concerns over speed concerns?)

[21:53] <colomon> Rotwang: though arguably Panda should be smart enough to know they are available already....

[21:54] <Rotwang> lue: I didn't think of that

[21:54] *** ajr_ left
[22:00] *** denisboyun joined
[22:03] *** logie joined
[22:18] *** zakharyas left
[22:34] *** kaare_ joined
[22:45] *** colomon left
[22:56] *** psch left
[23:02] *** pat_js joined
[23:09] *** colomon joined
[23:11] *** jeffreykegler_ left
[23:16] <jnthn> evening, #perl6

[23:16] <preflex>  jnthn: you have 1 new message. '/msg preflex messages' to read it.

[23:16] <jnthn> Only one? Phew!

[23:16] <colomon> jnthn: Have you finished everything yet?  ;)

[23:17] <jnthn> colomon: No, this glass still has whisky in it.

[23:17] <colomon> jnthn++

[23:17] * colomon has not poured a glass for himself yet.

[23:19] *** raiph left
[23:23] *** perigrin joined
[23:24] <segomos_> TimToady closing all kinds of issues on github

[23:25] <TimToady> no, only the kind I have answers to :)

[23:29] *** denisboyun left
[23:33] <dalek> rakudo/nom: d7bf821 | jonathan++ | src/core/Cursor.pm:

[23:33] <dalek> rakudo/nom: Remove <prior> implementation.

[23:33] <dalek> rakudo/nom: 

[23:33] <dalek> rakudo/nom: It was removed from the specification. No use in Star, likely no use

[23:33] <dalek> rakudo/nom: elsewhere, so not worth a deprecation note.

[23:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d7bf821868

[23:36] <TimToady> \o/

[23:38] <lue> (Waitaminute, there's was an old implementation of Perl 6 in the repo, and I didn't know about it‚ÄΩ)

[23:38] <lue> s/'s//

[23:45] <timotimo> \o/

[23:45] <timotimo> hey jnthn, nice to see you again :)

[23:46] <jnthn> o/ :)

[23:46] <jnthn> Just a short visit before sleep :)

[23:46] <jnthn> But still, I managed a patch :)

[23:46] <timotimo> i wish you a good night's rest :)

[23:47] <timotimo> when can we expect tuits to be spent on moarvm by you? :)

[23:47] <timotimo> nwc10++ # has been on fire finding really tricky problems

[23:47] <jnthn> Well, I'll try and at least look over the nwc10++ patches O(tomorrow) :)

[23:48] *** daniel-s_ joined
[23:49] <jnthn> I'm going to be doing family visiting/relaxing this next week. Flying home in a week's time, and will be properly back to things then :)

[23:50] <jnthn> But suspect I'll be around a little more this week than last week.

[23:54] <timotimo> i'm glad :)

