[00:01] <timotimo> r: my @res := (1, 2 ... *) »*» 2; say @res[^10].perl;

[00:01] <camelia> rakudo ebb29b: OUTPUT«()␤»

[00:01] <timotimo> huh?

[00:02] *** raiph left
[00:03] *** hypolin joined
[00:03] *** hypolin left
[00:04] *** dayangkun joined
[00:06] *** dayangkun left
[00:07] *** dayangkun joined
[00:08] <sorear> std: my @res := (1, 2 ... *) »*» 2; say @res[^10].perl;

[00:08] <camelia> std 85cf51d: OUTPUT«ok 00:00 46m␤»

[00:08] <sorear> r: my @res := ((1, 2 ... *) »*» 2); say @res[^10].perl;

[00:08] <camelia> rakudo ebb29b: OUTPUT«()␤»

[00:08] *** hypolin joined
[00:09] *** hypolin left
[00:09] *** dayangkun left
[00:10] *** dayangkun joined
[00:10] <timotimo> whoa, what happened to the irclog?

[00:10] <timotimo> (only the main page apparently?)

[00:13] <timotimo> huh, expecting a *hyperop* to be lazy is kind of stupid, isn't it?

[00:15] *** pmurias left
[00:17] <timotimo> hm. sort isn't really lazy, right? but it probably could be ...

[00:18] <timotimo> yay, triangle reduce is lazy :)

[00:18] <sorear> yes

[00:18] *** sivoais joined
[00:18] <sorear> feeding an infinite list to >>*>> *should* hang or die

[00:18] <sorear> returnign () is pretty bogus

[00:19] *** Maddingue joined
[00:22] *** BenGoldberg joined
[00:23] *** Maddingue left
[00:29] *** Ben_Goldberg joined
[00:31] *** BenGoldberg left
[00:33] *** sivoais left
[00:34] <[Coke]> how can sort be lazy? Don't you have to sort everything to know you're done?

[00:35] <timotimo> you are correct

[00:36] <sorear> for a comparison sort, you need O(n*log(n)) work to sort everything, but you can get the first element with O(n) work

[00:36] <timotimo> it can only be lazy if you merge multiple sorted lists

[00:36] <sorear> there are several sorting algorithms that can be lazy in the sense of returning the first element in O(n) time

[00:36] <timotimo> mymistake

[00:37] <timotimo> selectionsort comes to mind

[00:37] <sorear> heap sorts have that property naturally, and it's possible to build a quick sort that way

[00:37] <sorear> not sure about merge sorts

[00:39] <sorear> quicksort has the further interesting property that you can retrieve the kth result in O(n) time

[00:39] <sorear> you can for instance find the median of N numbers in O(N) time

[00:39] *** lue left
[00:45] *** crab2313 joined
[00:52] *** lue joined
[00:53] *** raiph joined
[01:04] *** crab2313 left
[01:04] *** Maddingue joined
[01:09] *** Maddingue left
[01:22] *** sivoais joined
[01:28] *** sivoais left
[01:38] *** sivoais joined
[01:44] *** FROGGS_ joined
[01:45] *** sivoais left
[01:48] *** FROGGS left
[01:49] *** Maddingue joined
[01:54] *** sivoais joined
[01:54] *** Maddingue left
[01:56] *** raiph left
[02:05] *** raiph joined
[02:07] *** sivoais left
[02:16] *** sivoais joined
[02:18] *** sivoais left
[02:35] *** Maddingue joined
[02:39] *** Maddingue left
[03:04] *** colomon joined
[03:15] *** Maddingue joined
[03:20] *** Maddingue left
[03:30] *** Ben_Goldberg left
[03:37] *** colomon left
[03:47] *** raiph_ joined
[03:48] *** raiph_ left
[03:55] *** preflex left
[03:56] *** preflex_ joined
[03:56] *** ChanServ sets mode: +v preflex_

[03:56] *** preflex_ is now known as preflex

[03:56] *** crab2313 joined
[04:05] *** Maddingue joined
[04:08] *** fridim_ joined
[04:09] *** Maddingue left
[04:19] *** fridim_ left
[04:23] *** dayangkun left
[04:26] *** crab2313 left
[04:29] *** Psyche^_ joined
[04:32] *** Psyche^ left
[04:38] *** cooper joined
[04:43] *** birdwindupbird joined
[04:45] *** konundra left
[04:50] *** sivoais joined
[04:51] *** domidumont joined
[04:55] *** sivoais left
[05:01] *** Maddingue joined
[05:06] *** Maddingue left
[05:10] *** sivoais joined
[05:15] *** domidumont left
[05:16] *** domidumont joined
[05:20] *** sivoais left
[05:30] *** sivoais joined
[05:30] *** sivoais left
[05:34] *** yash joined
[05:36] *** sivoais joined
[05:39] <moritz> \o

[05:39] <sorear> o/

[05:41] <sorear> moritz: any clue what happened to the irc.perlgeek.de main page around 5 hours ago?  it's fixed now, but it was coming up blank

[05:41] <diakopter> gremlibbles

[05:42] <moritz> sorear: nothing interesting in the log files :(

[05:44] <raiph> .

[05:45] <sorear> :(

[05:45] <diakopter> .tell raiph here you go :D

[05:45] <yoleaux> diakopter: I'll pass your message to raiph.

[05:46] *** Maddingue joined
[05:50] *** sivoais left
[05:50] *** ecocode joined
[05:51] *** Maddingue left
[05:55] *** sivoais joined
[05:56] *** ecocode` joined
[05:58] *** ecocode left
[06:00] <raiph> http://www.huffingtonpost.ca/2013/07/05/hollie-mcnish-breastfeeding_n_3552062.html?ncid=edlinkusaolp00000009

[06:00] <yoleaux> 05:45Z <diakopter> raiph: here you go :D

[06:03] *** FROGGS_ left
[06:04] *** ecocode`` joined
[06:05] <raiph> (just milking the . for all it was worth)

[06:06] *** sivoais left
[06:06] *** sqirrel joined
[06:07] <raiph> (giving gremlibbles a run for their money)

[06:07] *** ecocode` left
[06:10] *** sivoais joined
[06:10] *** sivoais left
[06:18] *** FROGGS_ joined
[06:20] *** baest joined
[06:21] *** SamuraiJack joined
[06:21] *** salv0 joined
[06:24] <raiph> 'gnite #perl6 http://coyot.es/crossing/2013/07/09/20-amazing-true-facts-about-introverts-and-extroverts/

[06:24] *** raiph left
[06:30] *** sivoais joined
[06:31] *** Maddingue joined
[06:36] *** Maddingue left
[06:40] *** domidumont left
[06:49] *** kaleem joined
[06:54] *** domidumont joined
[07:00] *** Grrrr joined
[07:04] *** cosimo joined
[07:06] *** domidumont1 joined
[07:10] *** domidumont left
[07:15] *** kaleem left
[07:17] *** Maddingue joined
[07:21] *** Maddingue left
[07:24] *** rindolf joined
[07:33] *** kaleem joined
[07:40] *** sqirrel left
[07:41] *** rindolf left
[08:02] *** Maddingue joined
[08:17] *** Stygia joined
[08:32] *** sqirrel joined
[08:43] *** sciurius left
[08:46] <labster> o/

[08:47] <FROGGS_> hi labster 

[08:48] <labster> hi FROGGS_ 

[08:48] *** daxim joined
[08:51] *** sciurius joined
[09:00] *** crab2313 joined
[09:08] *** dakkar joined
[09:11] *** kingbeast joined
[09:14] *** rainmaker_81 joined
[09:15] *** rainmaker_81 left
[09:31] *** Stygia left
[09:32] *** bruges left
[09:35] *** ecocode`` left
[09:38] *** fhelmberger joined
[10:07] *** ecocode`` joined
[10:09] *** Stygia joined
[10:15] *** grondilu joined
[10:15] *** grondilu left
[10:15] *** grondilu joined
[10:20] *** iSlug joined
[10:22] *** pmurias joined
[10:28] *** bruges joined
[10:33] *** bruges left
[10:47] *** crab2313 left
[10:50] *** ztt joined
[10:54] *** cognominal left
[10:56] *** cognominal joined
[10:57] *** lizmat left
[10:57] *** lizmat joined
[10:57] *** cognominal left
[10:58] *** rindolf joined
[11:00] *** cognominal joined
[11:05] *** sqirrel left
[11:05] *** colomon joined
[11:14] *** giri joined
[11:14] *** giri left
[11:14] *** sqirrel joined
[11:35] *** iSlug left
[11:37] *** iSlug joined
[11:42] <dalek> rakudo/nom: 9bdb5bc | (Elizabeth Mattijsen)++ | src/core/traits.pm:

[11:42] <dalek> rakudo/nom: Move definition of $/, $! and $_ so "is default" might actually work in the future.

[11:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9bdb5bc6a5

[11:53] <daxim> what's the perl6 equivalent of python/ecmascript yield?

[11:54] *** rindolf left
[11:56] *** skids_ left
[11:57] <FROGGS_> daxim: gather/take if I am not totally off

[11:57] <daxim> you're off

[11:57] <daxim> wait, no, I better test my assumptions first

[11:57] <lizmat> S17:558 describes yield as obsolete?  then again S17 is nod even sludgy

[11:57] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_558

[11:57] <lizmat> *not

[11:58] <moritz> basically lazy map is the equivalent of yield

[11:58] <ztt> pass a code ref?

[12:01] * moritz doesn't understand what ztt is trying to say

[12:03] <daxim> mls, please enable 12.2 / 12.3 -- https://build.opensuse.org/project/monitor/devel:languages:parrot

[12:03] <ztt> I think python/ruby yield is eq to pass a code ref

[12:03] *** ztt left
[12:05] *** iSlug left
[12:08] <moritz> passing a code ref to what?

[12:09] * moritz wonders if anybody has noticed the "Look for new lines" button in the IR clogs

[12:10] <FROGGS_> moritz: I've seen it now :o)

[12:11] <FROGGS_> ahh, cool

[12:11] <FROGGS_> moritz++

[12:15] *** yash left
[12:19] *** dayangkun joined
[12:19] <daxim> gosh

[12:20] <daxim> where's the __END__ token gone?

[12:20] <daxim> if I have to write =begin pod =end pod every time I want to bisect I'm gonna jump out of the window

[12:23] <FROGGS_> daxim: you only have to care about =end twice fwiw

[12:23] * diakopter closes the window

[12:24] <FROGGS_> daxim: btw, my editor (scite) allows block comments, so I press ctrl+q to toggle

[12:26] *** konundra joined
[12:28] *** benabik left
[12:31] *** ajr joined
[12:32] <mls> daxim: done, thanks for the hint ;)

[12:32] *** ajr is now known as Guest40120

[12:35] *** Guest40120 is now known as ajr_

[12:39] <tadzik> daxim: it's called =begin END or something

[12:51] <daxim> http://paste.scsys.co.uk/261897?tx=on   # can't make this translation work, please help

[12:52] *** colomon left
[12:53] *** PacoAir joined
[12:55] *** ztt joined
[12:57] <ztt> sorry i dropped line

[12:58] <moritz> daxim: what's the problem?

[12:58] <ztt> moritz: i want to express sub test(&code, $arg) { &code(do sth) } is eq yield

[12:58] <daxim> the problem is I can't program perl6

[12:59] <moritz> ztt: for a very, very loose definition of "equivalent"

[12:59] <moritz> daxim: I think you want 'gather for ...', not just 'gather ...'

[12:59] <ztt> moritz: :P

[12:59] <moritz> daxim: but if you get an error message or something, it would be helpful if you could tell us that

[13:00] <daxim> the error message was ===SORRY!=== Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at gen.pl:4 ------>     gather zip 1..*, $lines ⏏-> $lineno, $line { expecting any of: postfix infix stopper infix or meta-infix

[13:00] <daxim> gather for works

[13:00] <moritz> \o/

[13:00] <daxim> how do I check whether it's lazy?

[13:01] <moritz> you add a debugging say() or note() or so to it

[13:01] <moritz> and when all the debug statements are execute before all the other print statements, you know it's not lazy

[13:02] <moritz> or you use an infinite range as the argument

[13:02] <moritz> and if it prints at all, it's lazy

[13:02] <ztt> yeah perl6 has faq http://faq.perl6.org/

[13:03] <daxim> turns out, it's not lazy

[13:04] <ztt> hat's the perl6 equivalent of ruby method_missing?

[13:04] <daxim> where's the mistake?

[13:04] <moritz> ztt: what's ruby's method_missing?

[13:04] <daxim> AUTOLOAD

[13:06] <moritz> there'a a fallback mechanism in the MOP, but it's not yet nicely exposed to the user

[13:06] <ztt> moritz: oh it's really magic http://www.ruby-doc.org/core-2.0/BasicObject.html#method-i-method_missing

[13:07] <ztt> got it

[13:10] <ztt> daxim: how to test whether is lazy?

[13:11] <daxim> I tried both things; infinite input (variabl $i) blocks

[13:12] <daxim> rakudo: my $i = 1..*; for pager($i) -> $line { say $line }   # simple case runs as expected

[13:12] <camelia> rakudo 9bdb5b: OUTPUT«===SORRY!===␤Undeclared routine:␤    pager used at line 1. Did you mean '&eager'?␤␤»

[13:12] <daxim> oops

[13:12] <daxim> rakudo: my $i = 1..*; for $i -> $line { say $line }   # simple case runs as expected

[13:12] <camelia> rakudo 9bdb5b: OUTPUT«1..Inf␤»

[13:12] <daxim> ah well, damn this bloody contraption, just run the code yourself

[13:13] <ztt> daxi: range is lazy

[13:13] *** colomon joined
[13:15] <daxim> yeah, and the pager is not.  why? *that's* what I want to know

[13:18] *** bluescreen10 joined
[13:19] <ztt> rakudo: my $s = gather for 0..Inf { take $_**2 }

[13:19] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[13:20] <daxim> have you run my translated program?

[13:21] <[Coke]> daxim; isn't the syntax for zip: for zip(@names; @codes) -> $name, $zip ?? (S03)

[13:22] <daxim> well, is it? you're the expert, tell me

[13:22] <daxim> I can only find the Z operator in that document

[13:23] <[Coke]> I am only relatively the expert. I don't think you're going to get a direct line for line translation here. checking, as time permits.

[13:25] <daxim> but what good is the renouned flexibility of perl syntax if I can't translate a toy program? :(

[13:26] <moritz> daxim: have you tried infix Z instead of zip()

[13:26] <moritz> s/$/?/

[13:26] <ztt> Oh it is hard to translate in pythonic taste

[13:26] <[Coke]> daxim: you're not going to get a line by line translation from some arbitrary language, I wouldn't expect. you're going to have to translate the idiom in most cases.

[13:27] <daxim> and now we have arrived 40 minutes ago - what's the equivalent of yield, then?

[13:27] <daxim> infix Z also blocks

[13:28] <daxim> zip(1..*; $lines) changes the meaning of the expression, this can't help

[13:29] <moritz> 'take' is the closest equivalent to 'yield'.

[13:29] <moritz> summary: our tools for finding out where non-laziness comes from suck

[13:30] *** domidumont1 left
[13:30] *** skids_ joined
[13:31] *** domidumont joined
[13:31] *** daxim_ joined
[13:31] *** daxim left
[13:37] * colomon suspects this is just another case of for not being fully lazy

[13:46] <colomon> anyway, isn't the actual p6ish way of doing this to say gather for $lines.kv -> $lineno, $line ?

[13:46] <colomon> that gives you lineno minus one, but should work unless $lines is infinite

[13:47] <colomon> (Well, lineno starting from zero)

[13:48] <[Coke]> huh. that does work.

[13:49] <[Coke]> ... I wonder how many of my other variants worked because "\f" isn't doing anything in that terminal.

[13:50] <[Coke]> daxim_: https://gist.github.com/coke/6000078

[13:50] <colomon> enumerate probably most directly translates to .kv anyway, assuming I understand what it is doing.

[13:52] <colomon> I think the problem with the older one (assuming nothing has changed since the last time I ran into this) is that for gets the list to iterate over non-lazily unless it *knows* the list is infinite.  So 1..* it knows is infinite and treats lazily, but 1..* Z $lines it doesn't know, and it treats eagerly.

[13:54] *** fridim_ joined
[13:55] <[Coke]> colomon: but .kv isn't infinite, and it appears to DTRT.

[13:55] <ztt> http://paste.scsys.co.uk/261903 this is my view that code ref eq yield @daxim @moritz

[13:56] <colomon> .kv on a finite list is finte

[13:56] <colomon> self.keys.map: { ($_, self.at_pos($_)) }; # List.kv implementation

[13:56] <ztt> sorry i forget you want lazy

[13:57] <ztt> 1..100 range will be passed as lazy?

[13:57] <colomon> that depends on what you mean by "passed"

[13:59] *** rindolf joined
[14:00] <ztt> sub test(@a) { for @a -> $n

[14:01] <ztt> test 0..Inf # works

[14:01] *** fridim_ left
[14:03] <FROGGS_> the problem is:

[14:03] <FROGGS_> r: say (0..Inf).infinite

[14:03] <camelia> rakudo 9bdb5b: OUTPUT«True␤»

[14:03] <FROGGS_> r: say (0..Inf Z 0...4).infinite

[14:03] <camelia> rakudo 9bdb5b: OUTPUT«(Mu)␤»

[14:03] <FROGGS_> err, no, it isnt

[14:04] <FROGGS_> r: say (0..Inf Z 0..Inf).infinite # this is wrong IMO

[14:04] <camelia> rakudo 9bdb5b: OUTPUT«(Mu)␤»

[14:05] <FROGGS_> the second one isnt infinite, since Z is only as big as the shortest range

[14:07] <colomon> FROGGS_: it isn't *actually* infinite, but rakudo doesn't know that

[14:07] <ztt> in scalar context 0..9 range is a range object; in array context range will be a list

[14:07] <ztt> and it is lazy

[14:07] <colomon> Z isn't transmitting any info about whether or not it is infinite

[14:08] <colomon> r: say (0..4 Z 0..4).infinite

[14:08] <camelia> rakudo 9bdb5b: OUTPUT«(Mu)␤»

[14:08] <FROGGS_> r: say (0..4 Z 0..4).WHAT

[14:08] <camelia> rakudo 9bdb5b: OUTPUT«(List)␤»

[14:08] <FROGGS_> :/

[14:09] <FROGGS_> I see

[14:09] <colomon> it's a lazy list which is finite, but rakudo doesn't know it is finite

[14:09] *** SamuraiJack left
[14:09] *** sqirrel left
[14:09] <ztt> 0..Inf Z 0..Inf will time out

[14:09] <colomon> though this does raise the question of why 1..* Z $lines doesn't act finite.  

[14:10] <ztt> Nil.infinite is Mu

[14:10] *** kaleem left
[14:11] <colomon> nr: say (0..* Z 0..4).grep(*.is-prime)

[14:11] <camelia> rakudo 9bdb5b, niecza v24-86-g39ab531: OUTPUT«2 2 3 3␤»

[14:12] <colomon> nr: for (0..* Z 0..4) { .say if .is-prime }

[14:12] <camelia> rakudo 9bdb5b, niecza v24-86-g39ab531: OUTPUT«2␤2␤3␤3␤»

[14:15] <mathw> Sorry to go a bit off-topic but does anybody in here know if Perl 5 makes any promises about the order of evaluation of subroutine parameters?

[14:15] <ztt> OH finally I get it! thanks [coke]

[14:15] * moritz doesn't know it

[14:16] <mathw> ah, finally found the right google-fu

[14:16] <mathw> someone on perl monks says that because it's a list, it's down to the comma operator, and that's defined as left-to-right

[14:16] <mathw> just saw some code that set my C++-brain on fire

[14:19] <ztt> mathw: the order of evaluation of subroutine parameters? what that mean?

[14:20] *** [particle]1 is now known as [particle]

[14:20] <mathw> if you call a foo(bar(), baz()), does bar() or baz() get called first? Is there a defined order? Is it the same every time? In C, for example, the compiler can do whatever it likes and frequently you see right-to-left i.e. baz() is called first.

[14:24] <ztt> When I am child, I think gather/take is just another map. I am wrong. thank you [coke]++, very impressive!

[14:25] <daxim_> [Coke], change $i to 1..*  -  it will block, do you observe that too?

[14:26] <daxim_> and yes, kv is nicer than the zip.  I didn't expect that method works on lists

[14:28] <ztt> mathw: bar() first. I have tried

[14:30] <mathw> ztt: yes, I know that's what Perl 5 does now, but that's because I found the answer.

[14:30] <dalek> Perlito: 206defd | (Flavio S. Glock)++ | src5/lib/Perlito5/Grammar/Print.pm:

[14:30] <dalek> Perlito: Perlito5 - wip Perlito5/Grammar/Print.pm

[14:30] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/206defdb0a

[14:30] <mathw> but an experiment can't actually prove it, because C compilers might decide to use a different order for every function call (the language allows it, although that's not likely in the real world)

[14:31] <mathw> Fortunately Perl is a bit more predictable :)

[14:31] <ztt> mathw: a magic random

[14:32] *** ajr_ left
[14:33] *** kaare__ joined
[14:34] <ztt> r: for (1..9).kv -> $i, $v { say $i, $v }

[14:34] *** ajr joined
[14:34] <camelia> rakudo 9bdb5b: OUTPUT«01␤12␤23␤34␤45␤56␤67␤78␤89␤»

[14:34] <ztt> rakudo: for (1..Inf).kv -> $i, $v { say $i, $v }

[14:34] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[14:34] *** ajr is now known as Guest36310

[14:36] *** BenGoldberg joined
[14:37] <BenGoldberg> Good morning

[14:37] <moritz> good morning

[14:39] <colomon> nr: for (1..Inf).kv -> $i, $v { say $i, $v; last; }

[14:39] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[14:39] <camelia> ..niecza v24-86-g39ab531: OUTPUT«01␤»

[14:41] <ztt> what a fruitful day! good night~

[14:41] <BenGoldberg> nr: ((1..Inf).kv)[0].say

[14:41] <camelia> niecza v24-86-g39ab531: OUTPUT«0␤»

[14:41] <camelia> ..rakudo 9bdb5b: OUTPUT«0 1␤»

[14:43] <BenGoldberg> nr: ((1..Inf).kv)[5].say

[14:43] <camelia> rakudo 9bdb5b: OUTPUT«5 6␤»

[14:43] <camelia> ..niecza v24-86-g39ab531: OUTPUT«3␤»

[14:43] *** kivutar joined
[14:44] <BenGoldberg> Most peculiar

[14:44] <moritz> different flattening behavior

[14:45] <moritz> nr: say  ((1..Inf).kv.flat)[0]

[14:45] <camelia> rakudo 9bdb5b, niecza v24-86-g39ab531: OUTPUT«0␤»

[14:45] <moritz> nr: say  ((1..Inf).kv.tree)[5]

[14:45] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: Unable to resolve method tree in type List␤  at /tmp/_0zHVEnJGM line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /home/…

[14:45] <camelia> ..rakudo 9bdb5b: OUTPUT«5 6␤»

[14:45] <moritz> I don't think niezca implements LoLs

[14:46] <BenGoldberg> I don't think .kv produces a list of lists... it produces a list of Pair objects

[14:46] <BenGoldberg> Or at least, on rakduo it does

[14:47] <colomon> BenGoldberg: no

[14:47] <colomon> it produces a list of parcels, I believe

[14:47] <colomon> nr: ((1..Inf).kv)[0].WHAT.say

[14:47] <camelia> rakudo 9bdb5b: OUTPUT«(Parcel)␤»

[14:47] <camelia> ..niecza v24-86-g39ab531: OUTPUT«(Int)␤»

[14:47] <timotimo> is the thing with the pager still interesting?

[14:48] <colomon> and niecza is doing some sort of premature flattening in there

[14:48] <timotimo> i didn't backlog fully, but did seriously nobody notice the $ that should really have been an @ with a :=, or at least a .list for the zip metaop?

[14:49] *** Guest36310 is now known as ajr_

[14:50] * moritz seriosly didn't notice it

[14:52] *** benabik joined
[14:53] * timotimo caught up

[14:53] <timotimo> backlogging is so disempowering

[14:53] <arnsholt> Is there a simple way to get NQP/JVM to not catch Java exceptions?

[14:53] *** colomon left
[14:53] <daxim_> timotimo, put your words into code

[14:53] *** birdwindupbird left
[14:53] <arnsholt> Something's going wrong when JNA is loaded, so I actually do want the JVM stacktrace, rather than the NQP one

[14:54] <timotimo> like watching a horror film where that one person decides they really need some alone-time from the group because they were having some argument and they walk into that hallway without an escape or maybe a garage and you yell at the screen "there is a dollar sign! you need an @ instead!" and all the other people in the theater decide you're probably mentally ill

[14:55] <timotimo> r: my $i := 1 ... Inf; for $i { say $i } # no, this is *not* working as intended

[14:55] <timotimo> er, with the binding, though, it probably is

[14:55] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[14:55] <timotimo> r: my $i = 1 ... Inf; for $i { say $i } # no, this is *not* working as intended

[14:55] <camelia> rakudo 9bdb5b: OUTPUT«1␤»

[14:55] <timotimo> wait what? now i'm confused, too

[14:55] <daxim_> yeah.

[14:55] <timotimo> r: my $i = 1..*; for $i -> $line { say $line }   # simple case runs as expected  # line from before

[14:55] <camelia> rakudo 9bdb5b: OUTPUT«1..Inf␤»

[14:56] <timotimo> for $i say $i is of course not helpful :)

[14:56] <arnsholt> timotimo: That was a gloriously mixed metaphor =D

[14:56] <timotimo> it is really sufficiently late to expect me to be fully awake, but i'm not :P

[14:58] <daxim_> can you put this together with the sub pager?

[14:59] <timotimo> yeah, sure

[14:59] <timotimo> gimme a few seconds

[15:01] <timotimo> r: sub pager(@list, $lpp=5) { gather for @list.kv -> $lno, $line { take $line; take '-- More --' if $lno %% $lpp } }; my @data := 1...Inf; say pager(@data)[^31]

[15:01] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:01] <BenGoldberg> mathw: Perl5, unlike perl6, is definited by the imlementation... there is no formal perl5 specification.  In other words, for perl5, experimentation is in fact the only way to know.

[15:01] <timotimo> ah, did we find out that .kv will try to be eager?

[15:01] <timotimo> r: say (1..Inf).kv[^5]

[15:01] <camelia> rakudo 9bdb5b: OUTPUT«0 1 1 2 2 3 3 4 4 5␤»

[15:02] <timotimo> r: say (gather for (1..Inf).kv -> $no, $dat { say $no; say $dat })[^10]

[15:02] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:02] <timotimo> r: say (gather for 0..Inf Z 1..Inf -> $no, $dat { say $no; say $dat })[^10]

[15:03] <timotimo> that is weird indeed.

[15:03] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:03] <timotimo> oh, no it isn't

[15:03] <timotimo> when you say rather than take, of course it'll loop infinitely

[15:03] <timotimo> r: say (gather for (1..Inf).kv -> $no, $dat { take $no; take $dat })[^10]

[15:03] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:04] <timotimo> r: say (gather for (0...) Z (1...) -> $no, $dat { take $no; take $dat })[^10]

[15:04] <camelia> rakudo 9bdb5b: OUTPUT«===SORRY!===␤Bogus statement␤at /tmp/pWeHzMdl0t:1␤------> say (gather for (0...⏏) Z (1...) -> $no, $dat { take $no; take␤    expecting any of:␤        postfix␤        dotty method or postfix␤        prefix or term␤        prefix…

[15:04] <timotimo> r: say (gather for (0...*) Z (1...*) -> $no, $dat { take $no; take $dat })[^10]

[15:04] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:04] <arnsholt> timotimo: Well, when you only say there's never a take, so it'll loop forever while looking for the first takes

[15:04] <timotimo> yes

[15:05] <arnsholt> Not sure why the other one times out though

[15:05] * timotimo finds out he'd fare as badly in a horror film, too

[15:05] <timotimo> anyway, what i'd do is this:

[15:06] <BenGoldberg> for (1..Inf).kv { $_.say; last if $_ > 5 }

[15:06] <timotimo> r: my @paged <== map { ($line, ++(state $) %% 3 ?? '-- More --' !! ()) } <== 1...*; say @paged[^10]

[15:06] <camelia> rakudo 9bdb5b: OUTPUT«===SORRY!===␤Variable '$line' is not declared␤at /tmp/tq1ZlOqgos:1␤------> my @paged <== map { ($line⏏, ++(state $) %% 3 ?? '-- More --' !! ()␤    expecting any of:␤        postfix␤»

[15:06] <BenGoldberg> r: for (1..Inf).kv { $_.say; last if $_ > 5 }

[15:06] <timotimo> r: my @paged <== map { ($_, ++(state $) %% 3 ?? '-- More --' !! ()) } <== 1...*; say @paged[^10]

[15:07] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:07] <camelia> rakudo 9bdb5b: OUTPUT«===SORRY!===␤Unsupported use of $) variable; in Perl 6 please use $*EGID␤at /tmp/sLjAwBvOZz:1␤------> my @paged <== map { ($_, ++(state $)⏏ %% 3 ?? '-- More --' !! ()) } <== 1...*␤»

[15:07] <timotimo> r: my @paged <== map { ($_, ++(state $num) %% 3 ?? '-- More --' !! ()) } <== 1...*; say @paged[^10]

[15:07] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:07] <timotimo> aaw come on!

[15:07] <timotimo> what's wrong with you today?

[15:07] <timotimo> is it something i said, camelia? :[

[15:08] <BenGoldberg> r: my @p := map { ($_, ++(state $n) %% 3 ?? '--m--' !! ()) } <== 1..*; 'Alive'.say;

[15:08] <camelia> rakudo 9bdb5b: OUTPUT«===SORRY!===␤Sorry, do not know how to handle this case of a feed operator yet.␤at /tmp/JQpOeeEptj:1␤------> te $n) %% 3 ?? '--m--' !! ()) } <== 1..*⏏; 'Alive'.say;␤    expecting any of:␤        postfix␤»

[15:09] <BenGoldberg> r: my @p <== map { ($_, ++(state $n) %% 3 ?? '--m--' !! ()) } <== 1..*; 'Alive'.say;

[15:09] <camelia> rakudo 9bdb5b: OUTPUT«(timeout)»

[15:09] <BenGoldberg> Is the feed operator lazy, or eager?

[15:09] <timotimo> it's supposed to be lazy

[15:10] <timotimo> the map turns it eager for *some* reason, but i'm pretty sure it shouldn't do that

[15:10] * timotimo doesn't have the computing power to build an older rakudo

[15:10] <timotimo> it seems like a regression

[15:10] *** fhelmberger left
[15:11] *** woolfy left
[15:11] <timotimo> there ought to be spectests for lazyness of different constructs, too

[15:12] <timotimo> r: use Test; is (1..* Z** 1..*).[^5], (1**1, 2**2, 3**3, 4**4, 5**5), "power with lazy lists";

[15:12] <camelia> rakudo 9bdb5b: OUTPUT«ok 1 - power with lazy lists␤»

[15:15] <BenGoldberg> r: my @foo := gather { for (1..10) { $_.say; take $_; } }; @foo.kv.[5].say

[15:16] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤5 6␤»

[15:17] <BenGoldberg> r: my @foo := gather { for (1..10) { $_.say; take $_; } }; my @bar := @foo.kv; 'baz'.say

[15:17] <ztt> r: for 1..4 -> $n { say $n }

[15:17] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤baz␤»

[15:17] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤»

[15:17] <ztt> r: my $a = 1..4; for $a -> $n { say $n }

[15:17] <camelia> rakudo 9bdb5b: OUTPUT«1..4␤»

[15:18] <ztt> Range() in different context confuse me

[15:18] *** colomon joined
[15:20] <BenGoldberg> r: my $a = 1..4; for @$a -> $n { say $n }

[15:20] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤»

[15:20] <benabik> r: my @a := 1..4; .say for @a

[15:20] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤»

[15:20] <BenGoldberg> zzt, 'for' thought you were passing in a list of one element.

[15:20] *** baest left
[15:21] <benabik> r: .say for 1..4

[15:21] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤»

[15:23] *** ajr_ left
[15:24] <BenGoldberg> r: my $eager = False; gather { for (1..10) { $eager = $_ == 10; take $_; } }.kv; $eager.say

[15:24] <camelia> rakudo 9bdb5b: OUTPUT«True␤»

[15:26] <BenGoldberg> r: gather { for (1..10) { $_.say; take $_; } }.first(*>5);

[15:26] <camelia> rakudo 9bdb5b: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[15:38] <ztt> BenGoldberg: finally I understand. pass a Range() object is reasonable! thx!

[15:40] <timotimo> BenGoldberg: i think in that case the gather is getting sinked anyway, which makes it eager

[15:40] <timotimo> r: my $eager = False; my @result := gather { for (1..10) { $eager = $_ == 10; take $_; } }.kv; $eager.say

[15:40] <camelia> rakudo 9bdb5b: OUTPUT«True␤»

[15:40] <timotimo> oh, or maybe not.

[15:42] <benabik> r: my $eager = False; my @result := gather { for (1..10) { $eager = $_ == 10; take $_; } }; $eager.say; my @r2 := @result.kv; $eager.say

[15:42] <camelia> rakudo 9bdb5b: OUTPUT«False␤True␤»

[15:45] <timotimo> mhm

[15:46] <timotimo> interestingly, in List, kv is implemented as a map over self.keys and self.keys is (0..self.end).list

[15:46] <timotimo> not exactly sure which kv method is called there

[15:46] *** woolfy joined
[15:46] <timotimo> r: my $eager = False; my @result := gather { for (1..10) { $eager = $_ == 10; take $_; } }; $eager.say; say @result.DUMP;

[15:46] <camelia> rakudo 9bdb5b: OUTPUT«False␤List<1>(␤    :$!flattens(Mu),␤    :$!items(▶Mu),␤    :$!nextiter(ListIter<3>(␤        :$!list(=List<1>),␤        :$!reified(▶Mu),␤        :$!nextiter(▶Mu),␤        :$!rest(QRPA<4>(GatherIter<5>(␤            :$!reified(▶Any),␤            :$!coro(Coroutine<7>(.…

[15:46] <timotimo> apparently list

[15:46] <timotimo> so it has to be eager, because it calculates the length of the list

[15:47] <timotimo> in order for .kv to be lazy, .end must not be used

[15:50] *** ajr joined
[15:51] *** ajr is now known as Guest97202

[15:51] *** pmurias left
[15:52] *** vk_ joined
[15:55] *** sqirrel joined
[15:57] *** SamuraiJack joined
[16:00] <timotimo> alternatively, if finiteness cannot be established, it could fall back to a count-up thingie

[16:04] <moritz> maybe self.keys should be { my Int $c = 0; self.map: -> $ { $c++ } }

[16:04] *** bluescreen100 joined
[16:05] <moritz> and self.kv would similarly by  { my Int $c = 0; self.map -> $v { ($c++, $v) } }

[16:05] <moritz> anyone want to spectest that?

[16:07] *** prevost joined
[16:08] *** bluescreen10 left
[16:09] *** domidumont left
[16:11] *** _jaldhar_ left
[16:13] <ztt> OH my rakudo can not do ** say @result.DUMP; ** with 2013.02.1 version

[16:15] <moritz> 5 months is a lot of time in Perl 6 land

[16:16] <ztt> yes :)

[16:18] *** BenGoldberg left
[16:18] <timotimo> also, .DUMP isn't considered specced, right?

[16:20] <moritz> it's not

[16:21] <moritz> it's a purely internal debugging tool

[16:21] *** raiph joined
[16:23] *** domidumont joined
[16:23] <[Coke]> r: say &floor.DUMP

[16:23] <camelia> rakudo 9bdb5b: OUTPUT«Sub+{<anon>}<1>(␤    :$!dispatchees(Parcel<2>(:$!storage(OwnedResizablePMCArray<3>(...)))),␤    :$!dispatcher_cache(Mu),␤    :$!dispatcher(Mu),␤    :$!rw(0),␤    :$!inline_info(Mu),␤    :$!yada(0),␤    :$!package(GLOBAL<7>(...)),␤    :$!onlystar(1),␤    :$!dispatch…

[16:24] <[Coke]> ... I wonder what happens in rakudo-jvm land. shame I'm in the middle of a build and cannot test it. :)

[16:25] *** Stygia left
[16:26] *** konundra left
[16:31] <ztt> my $eager = False; test is really awesome! timotimo++

[16:31] *** benabik left
[16:31] *** kaleem joined
[16:32] *** kaleem left
[16:32] <ztt> good night really

[16:32] *** ztt left
[16:36] *** cooper left
[16:38] *** BenGoldberg joined
[16:46] *** zby_home_ joined
[16:47] *** FROGGS_ left
[16:48] <BenGoldberg> rn: gather { take $_ for 1..9; 'x'.say }.first(*>4).say

[16:48] <camelia> rakudo 9bdb5b: OUTPUT«x␤5␤»

[16:48] <camelia> ..niecza v24-86-g39ab531: OUTPUT«5␤»

[16:49] *** ecocode`` left
[16:49] <[Coke]> Anyone hacking on remaining rakudo.jvm failures? Or working on adding more features that aren't in rakudo.parrot yet?

[16:53] *** konundra joined
[16:53] *** stevan_ left
[17:01] *** dakkar left
[17:02] *** abnorman left
[17:04] *** FROGGS joined
[17:16] *** spider-mario joined
[17:17] *** stevan_ joined
[17:18] *** stevan__ joined
[17:20] * TimToady was also a bit horrified to see nobody noticing the 'for $i ->'

[17:20] <TimToady> maybe we should warn on that

[17:20] *** colomon left
[17:21] *** stevan_ left
[17:21] *** SamuraiJack_ joined
[17:22] *** abnorman joined
[17:22] <TimToady> it's not a mistake that a P5er would typically make, but it's an easy mistake coming from languages that don't make distinctions about list interpolation as Perl does

[17:22] *** SamuraiJack left
[17:23] *** colomon joined
[17:25] *** sqirrel left
[17:29] *** sqirrel joined
[17:36] *** daxim_ left
[17:41] <[Coke]> niecza has been dirty for 363 days. *sadface*

[17:42] <FROGGS> ohh, something to celebrate in two days

[17:45] <[Coke]> yah, not really. :|

[17:47] <dalek> perl6-roast-data: 12ea887 | coke++ | / (5 files):

[17:47] <dalek> perl6-roast-data: today (automated commit)

[17:47] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/12ea887d5c

[17:52] *** kaare__ left
[17:56] *** Rotwang joined
[17:57] *** ggoebel left
[17:58] *** Guest97202 left
[17:58] *** colomon left
[18:07] *** ggoebel joined
[18:18] *** sqirrel left
[18:22] <dalek> std: c2215f0 | larry++ | STD.pm6:

[18:22] <dalek> std: warn on for with single scalar variable

[18:22] <dalek> std: review: https://github.com/perl6/std/commit/c2215f042b

[18:25] *** ajr joined
[18:25] *** rindolf left
[18:26] *** ajr is now known as Guest21293

[18:26] *** Guest21293 is now known as ajr_

[18:33] *** kaare__ joined
[18:36] <jnthn> o/ from a train somewhere in Denmark :)

[18:36] <yoleaux> 06:49Z <diakopter> jnthn: as soon as you have 3 min, could you tersely explain how to call a 6model method from an op

[18:38] <jnthn> Don't think this connection will hold too well, but this station means I can push a few commits... :)

[18:38] <dalek> rakudo/nom: 37bf15c | jonathan++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[18:38] <dalek> rakudo/nom: Die on unexpected arguments.

[18:38] <dalek> rakudo/nom: 

[18:38] <dalek> rakudo/nom: Handles both positional and named case. This clears up many of the

[18:38] <dalek> rakudo/nom: remaining S06 test files with failures.

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/37bf15c2a1

[18:38] <dalek> rakudo/nom: 14c63bb | jonathan++ | src/vm/jvm/runtime/org/perl6/rakudo/RakOps.java:

[18:38] <dalek> rakudo/nom: Implement getThrower.

[18:38] <dalek> rakudo/nom: 

[18:38] <dalek> rakudo/nom: Means various error cases now through the correct typed exception.

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14c63bb6e4

[18:38] <timotimo> \o/

[18:38] <dalek> rakudo/nom: 961c030 | jonathan++ | src/ (4 files):

[18:38] <dalek> rakudo/nom: Abstract a Parrotism hit in backtrace gen.

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/961c03014f

[18:38] <dalek> rakudo/nom: 4ad1b8e | jonathan++ | src/core/Exception.pm:

[18:38] <dalek> rakudo/nom: Fix undeclared named reporting.

[18:38] <dalek> rakudo/nom: 

[18:38] <dalek> rakudo/nom: Makes S32-exceptions/misc.t get to the end, and a few other things

[18:38] <dalek> rakudo/nom: pass.

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4ad1b8ee09

[18:38] <jnthn> I see I missed today's run :)

[18:39] <jnthn> diakopter: context?

[18:40] <timotimo> jnthn: would looking at the implementation of "is rw" for classes be a good starting point for making "is nodal" on a class turn all the protos and methods defined in it "is nodal", too?

[18:40] <jnthn> timotimo: Perhaps, yes

[18:40] <jnthn> uh-oh, we're leaving the station :)

[18:41] <timotimo> ttyl :)

[18:41] <jnthn> well, it may hold... :)

[18:41] *** raiph left
[18:42] <jnthn> Seems like Buf and the LEAVE related stuff are two of the main reasons for the remaining failing tests.

[18:42] <PerlJam> It's really neat to see the p5-mop project slowly morph Perl 5 into something more Perl 6-y.

[18:42] * PerlJam just read some of stevan's posts

[18:43] <arnsholt> jnthn: Is there some bit of code I can twiddle to let Java exceptions percolate all the way to the top level?

[18:45] <arnsholt> (In NQP/JVM)

[18:50] <TimToady> std: my $foo; for $foo { .say }

[18:50] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  'for $foo' will never flatten a $ variable;␤      to force list interpolation, please use either 'for @$foo' or 'for $foo[]';␤    if you just want item topicalization, use 'given $foo' instead at /tmp/70_3l87OPl line 1:␤------> my $foo; for [3…

[18:51] <TimToady> std: my $foo; .say for $foo

[18:51] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  'for $foo' will never flatten a $ variable;␤      to force list interpolation, please use either 'for @$foo' or 'for $foo[]';␤    if you just want item topicalization, use 'given $foo' instead at /tmp/MR7t59MR4q line 1:␤------> my $foo; .say fo…

[18:53] *** SamuraiJack_ left
[18:53] <TimToady> std: for $_ {}

[18:53] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  'for $_' will never flatten a $ variable;␤        to force list interpolation, please use either 'for @$_' or 'for $_[]';␤        if you just want item topicalization, use 'given $_' instead at /tmp/ccD13ELMyR line 1:␤------> for ⏏$_

[18:53] <camelia> ..{}…

[18:55] *** SamuraiJack_ joined
[19:00] *** SamuraiJack_ left
[19:07] <jnthn> arnsholt: I tend to patch ExceptionHandler.java, in the dieInternal method that takes a throwable.

[19:07] <jnthn> arnsholt: Add e.printStackTrace()

[19:11] <arnsholt> jnthn: Brilliant!

[19:12] <jnthn> arnsholt: You can make nqp-runtime.jar and then just copy it to your install-jvm directory without rebulding anything else, btw.

[19:12] <jnthn> arnsholt: Or if you're already in NQP then you need not copy anything at all, just do the make :)

[19:12] *** kaare__ is now known as kaare_

[19:12] <arnsholt> Yeah, I'm doing the latter ATM

[19:12] <jnthn> k

[19:12] <arnsholt> This is all NQP hacking at the moment, so no need to install really

[19:14] *** colomon joined
[19:16] *** domidumont left
[19:16] *** SamuraiJack_ joined
[19:21] *** sqirrel joined
[19:24] <dalek> niecza: 1f87209 | larry++ | src/STD.pm6:

[19:24] <dalek> niecza: hack in STD's 'for $' warning

[19:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1f87209320

[19:25] * [Coke] hopes larry isn't still breaking niecza.

[19:26] *** sqirrel left
[19:26] * TimToady too

[19:27] <TimToady> that larry guy keeps trying to pick off all the LTA LHF...

[19:30] *** cooper joined
[19:31] *** crncosta joined
[19:35] *** kivutar left
[19:40] * jnthn blogged: http://6guts.wordpress.com/2013/07/15/rakudo-jvm-news-more-tests-plus-thread-and-promise-prototypes/

[19:42] *** Pleiades` left
[19:46] *** raiph joined
[19:47] <colomon> jnthn++

[19:50] *** SamuraiJack_ left
[19:54] *** Pleiades` joined
[19:57] <moritz> jnthn++ # blog, threads, promises

[19:59] *** kaare_ left
[20:01] *** vk_ left
[20:03] <labster> jnthn++ rakudo shows promise.

[20:05] <jnthn> ;)

[20:07] *** stevan__ left
[20:09] <jnthn> detrain &

[20:12] *** colomon left
[20:17] <tadzik> anybody planning to go to LPW?

[20:19] *** grondilu left
[20:19] *** colomon joined
[20:20] *** d4l3k_ joined
[20:20] *** dalek left
[20:20] *** spider-mario left
[20:20] *** d4l3k_ is now known as dalek

[20:20] *** spider-mario_ joined
[20:21] *** spider-mario_ is now known as spider-mario

[20:26] *** donaldh joined
[20:29] *** vk_ joined
[20:33] *** stevan_ joined
[20:41] <TimToady> jnthn: the combinator for waiting for any of them is called "race" :)

[20:41] *** konundra left
[20:42] *** zby_home_ left
[20:42] <TimToady> oh, I see you mentioned race later

[20:48] * TimToady assiduously avoids making a pun on race relations

[20:56] *** spider-mario left
[21:02] *** dayangkun left
[21:06] *** skids_ left
[21:06] *** notjack joined
[21:08] *** vaelxon joined
[21:15] *** kst left
[21:15] <notjack> if I craft a perl6 program using MONKEY_TYPING, spin up a million instances and let them run for a million years, do I have to share the book royalties with Larry?

[21:17] *** dayangkun joined
[21:17] <timotimo> m)

[21:23] *** prevost left
[21:24] <diakopter> notjack: but how would anyone know which book to read?

[21:29] <tadzik> a rege

[21:29] <tadzik> x

[21:33] <Ulti> http://blog.brentlaabs.com/2013/05/how-to-start-hacking-on-rakudo-perl-6.html  this might be worth advertising or markdownafying for the rakudo docs

[21:43] *** konundra joined
[21:43] *** ajr_ left
[21:45] *** PacoAir left
[21:49] *** vk_ left
[21:50] *** vk_ joined
[21:51] *** vk_ left
[21:58] * jnthn home

[21:59] <diakopter> tadzik: lolololol

[22:01] *** kst joined
[22:16] *** lue left
[22:25] *** bluescreen100 left
[22:28] *** lue joined
[22:46] *** lue left
[22:48] *** Rotwang left
[23:00] *** lue joined
[23:04] *** frdmn left
[23:05] *** lue left
[23:06] <timotimo> hmm. an example dataset to demonstrate feeds? :|

[23:07] *** raiph left
[23:09] *** donaldh left
[23:11] *** berekuk left
[23:14] *** raiph joined
[23:17] *** cognominal left
[23:17] *** cognominal joined
[23:17] *** berekuk joined
[23:19] *** lue joined
[23:21] *** raiph left
[23:26] *** lue left
[23:28] *** raiph joined
[23:28] *** crncosta left
[23:39] *** lue joined
