[00:02] *** Radvendii left
[00:31] *** stevan_ left
[00:32] *** stevan_ joined
[00:36] <timotimo> i'm now comparing run times for my brownian tree among jakudo and parakudo. even though those are both heavily RNG-dependent in run time, perhaps there will be a huge difference? i should probably run them at least thrice each, but they take upwards of 5 minutes

[00:36] <timotimo> i'll get memory usage stats from them, though, which is nice.

[00:36] *** btyler left
[00:37] *** betterworld left
[00:43] *** betterworld joined
[00:48] <timotimo> okay, the parrot version has now been running for 15 minutes, whereas the jvm version only took 6

[00:51] <timotimo> 5:25 vs 18:07, but interestingly parakudo only took 0.5x the memory; it's probably some "start with a gig of ram allocated" flag in the jvm-rakudo launch script?

[00:52] <timotimo> no, it is not. it starts with 100m.

[00:52] <timotimo> that's kinda crazy :|

[00:53] * timotimo runs a less random-influenced bit of code

[00:54] <timotimo> on my galton box code (pretty console-output-heavy), the jvm version takes 1 second longer, uses almost 2x as much ram.

[00:57] <timotimo> when taking out the actual output, but not the creation of the parts of the string that's to be output, as well as upping the loop count by a third, the jvm beats parrot 25 seconds to 28.6; takes almost 2x as much ram again, though.

[00:58] *** lue left
[00:59] *** betterworld left
[01:02] <[Coke]> labster: rt id?

[01:02] *** TimToady left
[01:02] *** berekuk_ joined
[01:02] *** TimToady joined
[01:02] *** xilo joined
[01:02] <timotimo> ah yes. galton box with 40 coins instead of 30 gives me 28s for jvm and 38s for parrot

[01:03] *** Shozan joined
[01:04] *** scottp_ joined
[01:04] *** ugexe_ joined
[01:04] <timotimo> 31s vs 49s at 50 coins, interesting.

[01:04] *** betterworld joined
[01:04] * timotimo plots

[01:05] *** gabriel_ joined
[01:05] *** itz_ joined
[01:05] *** Kelder joined
[01:07] <[Coke]> timotimo: are you using the eval server?

[01:07] *** simcop2387_ joined
[01:07] *** FROGGS_ joined
[01:09] <timotimo> no

[01:09] <timotimo> but the loops are inside the script

[01:10] <timotimo> so there's only one warmup and one startup for the jvm

[01:10] *** PZt left
[01:10] *** imarcusthis- left
[01:10] *** lue joined
[01:10] *** _jaldhar joined
[01:10] *** berekuk left
[01:10] *** ugexe left
[01:10] *** scottp left
[01:10] *** Ayiko left
[01:10] *** SHODAN left
[01:10] *** simcop2387_ is now known as simcop2387

[01:11] *** xilo left
[01:11] *** FROGGS left
[01:11] *** berekuk_ left
[01:11] *** jaldhar left
[01:11] *** sitaktif left
[01:11] *** genehack left
[01:11] *** mangala left
[01:11] *** genehack joined
[01:11] *** imarcusthis- joined
[01:12] *** mangala joined
[01:12] *** jfried left
[01:12] <colomon> hmmm, nap-jvm passes make test under my new OS X.

[01:12] <timotimo> with increasing coin count, jvm approaches and perhaps even surpasses 2x as fast

[01:13] * timotimo runs 200 coins

[01:13] *** jfried joined
[01:13] *** ruoso_ left
[01:14] *** TimToady left
[01:14] *** ruoso joined
[01:14] *** TimToady joined
[01:15] <timotimo> jvm is 1s faster for 200 coins than parrot is for 100 coins :)

[01:16] *** Pleiades` left
[01:17] *** betterworld left
[01:17] *** sitaktif joined
[01:18] *** masak left
[01:18] *** masak joined
[01:19] *** xilo joined
[01:20] <timotimo> http://imgur.com/16DfDbh - super scientific!

[01:20] *** xilo_ joined
[01:20] <colomon> and rakudo-jvm passes its tests!  \o/

[01:20] <timotimo> (lack of axis labels makesit even more scientific!)

[01:20] *** Pleiades` joined
[01:21] <benabik> Parrot is beating the JVM!  Yay!

[01:22] <benabik> It has bigger numbers.  Bigger is better.  ;-)

[01:22] <timotimo> benabik: unfortunately, Y is "seconds taken, less is better"

[01:22] <benabik> timotimo: I know.

[01:22] <colomon> not if you're trying to warm your house with the exhaust from your computer!

[01:22] <timotimo> ;)

[01:25] * colomon actually did that (by accident) back ten or so years ago

[01:26] * timotimo wonders what the time-of-implementation on slurp and MAIN will turn out to be

[01:28] <colomon> I'd be surprised if slurp took long at all

[01:29] <colomon> dunno what will be involved with MAIN

[01:30] *** betterworld joined
[01:31] <timotimo> "Callframe is NYI"

[01:33] *** stevan_ left
[01:34] *** stevan_ joined
[01:37] *** _jaldhar left
[01:37] <[Coke]> several spectests are blocked on that failure

[01:42] *** SamuraiJack_ joined
[01:43] *** btyler joined
[01:45] *** berekuk joined
[01:46] <labster> [Coke]: it's labster, unsurprisingly.

[01:56] *** SamuraiJack_ left
[01:57] *** SamuraiJack joined
[02:11] <[Coke]> done

[02:11] <timotimo> wait ... done what?

[02:14] <dalek> rakudo/nom: c83b634 | (Solomon Foster)++ | src/core/Str.pm:

[02:14] <dalek> rakudo/nom: Switch from sprintf to p6 interpolation.

[02:14] <dalek> rakudo/nom: 

[02:14] <dalek> rakudo/nom: Don't use sprintf (which doesn't work well yet in JVM) for something we can do with good old interpolation.

[02:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c83b634207

[02:15] <labster> https://rt.perl.org/rt3/Ticket/Display.html?id=118545  Resolved my first ticket!

[02:16] <colomon> \o/

[02:17] <timotimo> good! :)

[02:17] *** _jaldhar joined
[02:19] <timotimo> ah, that's what you've done i suppose

[02:19] <timotimo> good * #perl6!

[02:24] <labster> hi timotimo

[02:32] <JimmyZ> Good morning, #perl6

[02:33] <colomon> o/

[02:53] *** prevost joined
[02:55] <TimToady> I have some good news: my PSA reading is off the low end of the scale, so looks like I don't need any radiation or chemo, at least for now

[02:56] <TimToady> now I just have to keep it that way for five years or so...

[02:58] <TimToady> I realize this increases my chances of being run over by a bus... :)

[03:01] <colomon> \o/

[03:01] <colomon> (well, not the bus bit.)

[03:03] <colomon> That's great news!

[03:08] *** salv0 left
[03:10] *** ugexe_ is now known as ugexe

[03:11] *** atroxaper joined
[03:14] <dalek> std: 85cf51d | larry++ | STD.pm6:

[03:14] <dalek> std: simplify message on undef (also revert =:= patch)

[03:14] <dalek> std: review: https://github.com/perl6/std/commit/85cf51df88

[03:14] *** btyler left
[03:18] <labster> oh, that's really good news.  (that 0.1mm)++

[03:20] *** benabik left
[03:20] <TimToady> well, there could still be a singular cell or two that will eventually be bad news, but the odds seem to be in my favor at the moment

[03:20] <TimToady> course, it's still 50/50 :)

[03:21] <TimToady> or 100/0

[03:21] <TimToady> or 0/100

[03:21] <TimToady> but I'm pretty happy tonight :)

[03:25] *** salv0 joined
[03:34] <sorear> good * #perl6

[03:34] <yoleaux> 2 Jul 2013 18:37Z <raiph> sorear: is niecza's gather/take lazy?

[03:34] <yoleaux> 2 Jul 2013 22:23Z <raiph> sorear: is niecza's gather/take batched, or 100% lazy?

[03:35] <sorear> .tell raiph I have never heard of a perl6 implementation without 100% lazy gather/take.  Your questions are weird.

[03:35] <yoleaux> sorear: I'll pass your message to raiph.

[03:37] *** PZt joined
[03:38] *** gdey joined
[03:40] *** gdey left
[03:40] *** gdey joined
[03:49] *** preflex_ joined
[03:49] *** ChanServ sets mode: +v preflex_

[03:49] *** preflex left
[03:49] *** preflex_ is now known as preflex

[03:51] *** Chillance left
[03:56] *** jeffreykegler joined
[03:57] <jeffreykegler> Just popped in to say how that I am very happy to hear Larry's good news

[04:00] <TimToady> :)

[04:00] *** mtk left
[04:08] <PerlJam> TimToady: What's the good news?  (I'm on vacation and have been away from the internet for several days)

[04:08] <PerlJam> TimToady: Are you one of the lucky 12% or whatever it was from your talk?

[04:09] <PerlJam> ah ... (just read the scrollback)  Congrats TimToady!!

[04:10] *** jeffreykegler left
[04:10] <sorear> Congrats!

[04:15] *** benabik joined
[04:17] *** BenGoldberg left
[04:22] *** arlinius left
[04:36] <Woodi> hallo

[04:37] <sorear> o/ Woodi

[04:37] <Woodi> TimToady: it's St. Paul dillema but all will be good :)

[04:39] <TimToady> well, St Paul was a much better apostle to the gentiles than I've been to the hackers, but I feel privileged to have had the opportunity to try :)

[04:43] *** fridim__ joined
[04:46] *** birdwindupbird joined
[04:50] *** telex left
[04:51] *** telex joined
[04:53] *** xinming left
[04:55] *** prevost left
[04:55] *** xinming joined
[04:58] <sorear> what is St Paul's dilemma?  my ddg-fu is failing me

[05:00] <Woodi> sorear: St. Paul was apostole and he for some time expected to be sentenced to dr

[05:00] <Woodi> ...to death.

[05:01] <Woodi> but he belived that haven is better place so he wanted go there but staying HERE was good work for him and for others :)

[05:02] <Woodi> so we realy hope TimToady will help us with all that specifications :)

[05:04] <TimToady> http://www.biblegateway.com/passage/?search=phil%201:21-24&version=NIV is the specific passage in question

[05:05] <Woodi> r: sub basket( Str $f ) { my %fruits = ('apples', '4'); return %fruits{ $f } }; say basket( 'noexiranges' );

[05:05] <camelia> rakudo c83b63: OUTPUT«(Any)␤»

[05:05] <Woodi> Any not Nil returned ?

[05:07] <TimToady> well, Any is the default default, but lizmat++ is working on the ability to set other defaults

[05:08] <Woodi> but Nil means "there is no value here"...

[05:08] *** prevost joined
[05:09] <TimToady> well, but a default means "assume this value is there if there isn't one" :)

[05:10] <TimToady> arguably Nil would be a good default default too

[05:11] *** fgomez joined
[05:11] <TimToady> at the moment, however, we're leaning away from letting you put such "concepts" into array elements by default

[05:12] <TimToady> so we limit elements to type Any for now

[05:12] <TimToady> (by default

[05:12] <TimToady> )

[05:13] *** fridim__ is now known as fridim_

[05:18] <Woodi> r: sub basket( Str $f ) returns Int { my %fruits = ('apples', '4'); return %fruits{ $f } }; say basket( 'noexiranges' );

[05:18] <camelia> rakudo c83b63: OUTPUT«Type check failed for return value; expected 'Int' but got 'Any'␤  in sub basket at /tmp/9M8i3Wf8kE:1␤  in block  at /tmp/9M8i3Wf8kE:1␤␤»

[05:25] *** xinming left
[05:25] *** raiph left
[05:25] *** xinming joined
[05:31] <moritz> \o

[05:31] <sorear> o/ moritz

[05:33] *** FROGGS_ left
[05:42] *** prevost left
[05:42] *** fgomez left
[05:49] *** xinming left
[05:50] *** konundra left
[05:52] <FROGGS[mobile]> o/

[05:52] *** xinming joined
[05:53] *** Shozan left
[05:55] *** SHODAN joined
[06:01] *** xilo_ left
[06:04] <dalek> nqp: 56f116f | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/ (5 files):

[06:04] <dalek> nqp: Add a JavaWrap representation and associated code

[06:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/56f116f125

[06:04] <dalek> nqp: 32c67cd | sorear++ | src/vm/jvm/QAST/Compiler.nqp:

[06:04] <dalek> nqp: stub jvmbootinterop access

[06:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/32c67cd6c9

[06:05] *** ecocode joined
[06:12] *** PacoAir joined
[06:14] *** FROGGS joined
[06:16] *** havenwood joined
[06:19] *** ztt joined
[06:25] *** iSlug joined
[06:30] *** PacoAir left
[06:32] *** kaleem joined
[07:01] *** Rotwang joined
[07:01] *** Rotwang left
[07:01] *** Rotwang joined
[07:01] *** GlitchMr joined
[07:05] *** ztt left
[07:20] *** dmol joined
[07:32] *** domidumont joined
[07:34] *** domidumont left
[07:36] *** iSlug left
[07:39] *** havenwood left
[07:44] *** Rotwang left
[07:56] *** woosley joined
[07:56] <woosley> rakudo: my $a = [1,2,4]; $a.delete(1);say $a; say $a.elems

[07:56] <camelia> rakudo c83b63: OUTPUT«1 Nil 4␤3␤»

[07:57] <woosley> r: my $a = [1,2,4]; $a.delete(2);say $a; say $a.elems

[07:57] <camelia> rakudo c83b63: OUTPUT«1 2␤2␤»

[07:58] <FROGGS> use splice if you want to remove from the middle

[07:58] <FROGGS> r: my $a = [1,2,4]; $a.splice(1,1); say $a; say $a.elems

[07:58] <camelia> rakudo c83b63: OUTPUT«1 4␤2␤»

[07:59] <woosley> ah, I thought I could always delete at every position 

[08:07] <Woodi> aren't delete for hashes only ?

[08:08] *** dayangkun left
[08:08] *** dayangkun joined
[08:10] <moritz> https://github.com/blog/1547-release-your-software # looks like this might be interesting for rakudo and star releases

[08:11] *** grondilu joined
[08:11] *** markov left
[08:11] <grondilu> "CallCapture representation does not implement cloning"

[08:12] <grondilu> ^ while trying to compile rakudo on JVM

[08:12] <grondilu> in  (src/gen/BOOTSTRAP.nqp:1072)

[08:14] <grondilu> <-- $capture := nqp::clone($capture);

[08:16] <grondilu> http://paste.siduction.org/20130703081552  <- full error log

[08:25] *** markov joined
[08:31] *** dakkar joined
[08:40] <mathw> Good morning!

[08:43] <dalek> rakudo/nom: c929f04 | (Brent Laabs)++ | / (4 files):

[08:43] <dalek> rakudo/nom: Add IO::Spec::QNX to make Unix more efficient

[08:43] <dalek> rakudo/nom: QNX and Neutrino(nto) use //path special syntax, but there's no need

[08:43] <dalek> rakudo/nom: to penalize every other unix with extra operations in canonpath.

[08:43] <dalek> rakudo/nom: Plus it was never tested on qnx so it didn't even work... now fixed

[08:43] <dalek> rakudo/nom: Seriously, what bozo implemented this in the first place?

[08:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c929f048b8

[08:43] <dalek> rakudo/nom: 827bcc4 | (Brent Laabs)++ | src/core/IO (2 files):

[08:43] <dalek> rakudo/nom: Implement :parent for path cleanup (except Win).  Add IO::Path::QNX

[08:43] <dalek> rakudo/nom: Logical cleanup of parent directory option added to both of

[08:43] <dalek> rakudo/nom: IO::Path::Unix and IO::Spec::Unix -- which magically makes Cygwin

[08:43] <dalek> rakudo/nom: and QNX work too.  Physical cleanup (resolve) still NYI.

[08:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/827bcc468b

[08:43] <dalek> rakudo/nom: 174bf4f | (Brent Laabs)++ | / (7 files):

[08:43] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[08:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/174bf4f021

[08:44] <labster> good morning, *

[08:44] <mathw> hi labster

[08:45] *** cognominal joined
[08:46] <masak> good morning, #perl6

[08:47] <moritz> \o

[08:50] <mathw> \o/

[08:54] <masak> labster: have you discovered the full awesomeness of rebasing? they help reduce the number of zero-info merges like that last one.

[08:55] <labster> apparently not :P

[08:55] <masak> labster: in this particular case, it'd have been a question of 'git pull --rebase' instead of just 'git pull'.

[08:55] <nwc10> would be nice if github discovred the full awesomeness of rebasing too

[08:56] <timotimo> TimToady: (good news)++

[08:56] <masak> labster: and if you notice that the pull actually did a merge, you can quickly get back to pre-pull by doing 'git reset --hard HEAD{1}' and then do the 'git pull --rebase'

[08:56] * mathw likes rebasing

[08:57] <masak> labster: or, even better if you ask me, 'git config --global --add merge.ff=only' and then pull will refuse to add merges

[08:57] * mathw uses rebasing more often than is healthy

[08:57] <labster> sweet.  will do so from now on.

[08:57] <masak> TimToady: I'm very relieved about the news. here's to a long life, though maybe not as long as TheDamian suggests ;)

[08:58] <colomon> masak: my git required that be 'git config --global --add merge.ff only'

[08:59] <colomon> but definitely masak++ if that works!

[09:01] *** xinming left
[09:01] <dalek> specs: 2a08d8c | (Brent Laabs)++ | S99-glossary.pod:

[09:01] <dalek> specs: [S99] define thinko, request MRO

[09:01] <dalek> specs: review: https://github.com/perl6/specs/commit/2a08d8c741

[09:01] *** fhelmberger joined
[09:02] *** xinming joined
[09:03] <masak> oh, ok. yeah, sorry, I wrote that from memory :)

[09:04] <masak> it definitely works, to the point that it prevents you from doing local merges too if they produce a merge commit!

[09:06] <colomon> just went and added it to my linux box, too.

[09:10] *** daxim joined
[09:10] <mathw> I had a weird thing with git the other day, where 'git commit -a' didn't add any new files, but I'm sure that's what it's supposed to do. Am I wrong?

[09:10] *** dmol1 joined
[09:10] *** dmol left
[09:10] <hoelzro> git commit -a doesn't add new files

[09:11] <hoelzro> it commits all changes in any files already being tracked

[09:11] <hoelzro> git add -A will find new files

[09:12] <mathw> I'm wrong. Good.

[09:12] <mathw> I wouldn't like to think they'd changed something like that.

[09:13] <timotimo> "one of the major changes in this new git release is that mathw is no longer wrong"; < mathw> oh damn it!

[09:14] <mathw> immortality in git release notes

[09:14] <mathw> I could live with that

[09:17] * masak read that as "immutability" and went, "well, duh"

[09:17] <jnthn> morning o/

[09:17] <nwc10> jnthn++ # bloggage

[09:17] <jnthn> grondilu: It means your NQP build is out of date.

[09:17] <mathw> jnthn: nice interview

[09:18] <jnthn> grondilu: For now, NQP HEAD is always assumed for Rakudo on JVM.

[09:18] <masak> I really like how the model of git shows how immutable objects (commits) can be useful in a way that mutable objects can't. and how you're still not restricted in any significant way.

[09:18] <JimmyZ> TimToady: good news

[09:18] <jnthn> TimToady: Happy to hear the good news \o/

[09:19] <mathw> masak: I'm writing Haskell again. Immutability rocks.

[09:19] <JimmyZ> jnthn++ # blog and interview

[09:21] <masak> mathw: yes. but it's not just Haskell. I do a fair bit of immutability in my Perl 6 code.

[09:21] <jnthn> Immutability is one of the unchanging goodnesses. :)

[09:22] <colomon> There are some good uses in p6 for mutability, though.  I find myself making most, but definitely not all, classes immutable.

[09:22] * masak .oO( "immutability was good, is good, and will stay good until the end of time, forever and ever. amen." )

[09:23] <masak> yes, there are definitely good uses for mutability.

[09:23] <mathw> it's nice to have a lagnuage that supports immutability

[09:23] <mathw> it's one of the things that annoys me about C#

[09:23] <masak> I guess the point is that immutability subsumes it. you can fake mutability with immutability, but not really the other way around. and that's an interesting result because you'd expect kinda the opposite.

[09:23] <mathw> I can make an immutable class, but I can't make a method that declares "I will not mutate 'this'"

[09:24] <mathw> etc. etc.

[09:24] <jnthn> mathw: One of the simplest things they could do is provide "let" outside of linq expressions.

[09:24] <mathw> and immutability in C# is a convention, not something you can declare in the type system

[09:24] <jnthn> mathw: So you have a way to do single static assignment and the reader can know, "this thing won't be updated". Granted it'd only be "skin deep", but still... :)

[09:24] <mathw> yeah it'd be nice

[09:24] <mathw> it's something I miss from C++

[09:24] <jnthn> Should be easy too. :)

[09:25] <mathw> really need to write some C++ again, after I've finished with my writing some Haskell again thing

[09:25] * jnthn has managed to escape C++ so far. :)

[09:25] <mathw> I do find myself using a lot of readonly member variables in C#

[09:25] <mathw> but that just means you can't change the reference

[09:25] <jnthn> The C++ teacher at $dayjob has told me some horror stories, though. :)

[09:25] <mathw> the object itself can be mutated however it supports

[09:25] <mathw> heh there is some serious evil in C++

[09:25] <mathw> but I want to write something using all the new C++11 shiny move semantics and smart pointers and things

[09:26] <nwc10> have the C++ compilers caught up yet?

[09:26] * JimmyZ doesn't want to touch C++

[09:27] <colomon> gcc has, I think

[09:29] <mathw> g++ has support for most of it

[09:29] *** domidumont joined
[09:29] <mathw> including some of the really scary stuff like variadic templates

[09:29] <mathw> I haven't really tried to comprehend those yet

[09:30] <mathw> btw jnthn awesome work on Rakudo/JVM

[09:32] <jnthn> It's not just me :)

[09:34] <mathw> yeah but you're the person I know to point the finger at because you blogged it

[09:34] <mathw> everyone else who contributed: awesome work on Rakudo/JVM

[09:34] <nwc10> I blame TimToady. He started it, after all.

[09:35] <mathw> I'm looking forward to deliberately constructing a project that requires me to use Perl 6 to call a library written in Clojure

[09:35] <mathw> Because it's bound to be fiddly and awkward but it'll be awesome to see it work

[09:44] <JimmyZ> mathw: This's the start? https://github.com/perl6/nqp/commit/32c67cd6c9f4439bce89a4a31360e5bfd8addc63 

[09:44] * masak .oO( "interop ops"... "Bootstrap's bootstraps"... )

[09:48] <tadzik> I see what you did there

[09:48] <jnthn> :P

[09:49] <jnthn> JimmyZ: Yes, that looks to me very much like a start on Java object interop :)

[09:49] <tadzik> now I feel like some Hans Zimmer

[09:50] <timotimo> .o( Hansi Hinterzimmer, tee hee )

[09:51] *** cognominal left
[09:55] *** cognominal joined
[09:58] <woosley> what is the method to check if a element is in an Array in Perl 6? 

[09:59] <masak> r: my @a = 1, [2, 3], 4; say $_ ~~ Array for @a

[09:59] <camelia> rakudo 174bf4: OUTPUT«False␤True␤False␤»

[09:59] <masak> oh! *in* an array. sorry.

[09:59] <jnthn> mathw: in!

[09:59] <timotimo> hehe

[09:59] <jnthn> oops, masak 

[09:59] <masak> r: my @a = 1, [2, 3], 4; say so 4 ~~ any(@a)

[09:59] <camelia> rakudo 174bf4: OUTPUT«True␤»

[09:59] <timotimo> r: my @a = <a b c foo dog>; say any(@a) eq "dog";

[09:59] <camelia> rakudo 174bf4: OUTPUT«any(False, False, False, False, True)␤»

[09:59] <timotimo> yeah

[09:59] <JimmyZ> :D

[09:59] <timotimo> should have so'd that

[10:00] <jnthn> You so shoulda

[10:00] <masak> you so should... damn :)

[10:00] * JimmyZ decommutes

[10:03] <mathw> JimmyZ: jnthn: that's why I love #perl6.

[10:03] <mathw> wish I had time to contribute :(

[10:03] <mathw> Other stuff to do first

[10:03] *** domidumont left
[10:03] <mathw> along with $dayjob and teaching small children to beat each other up

[10:03] *** crab2313 joined
[10:04] *** domidumont joined
[10:04] <colomon> woosley: alternatively, 

[10:05] <colomon> r: my @a = <a b c foo dog>; say "dog" (elem) @a;

[10:05] <camelia> rakudo 174bf4: OUTPUT«True␤»

[10:05] <colomon> more elegantly (but doesn't work on Rakudo)

[10:05] <colomon> n: my @a = <a b c foo dog>; say "dog" ∈ @a;

[10:05] <camelia> niecza v24-86-g39ab531: OUTPUT«True␤»

[10:05] <masak> \o/

[10:05] *** cognominal left
[10:05] <woosley> crazy stuff !! 

[10:05] <masak> that's a really neat fall-out side effect of set ops :)

[10:06] <masak> hadn't thought of that. colomon++

[10:06] <colomon> no idea whether this is more efficient than so any(@a) eq "dog", mind you

[10:06] <masak> "efficient"? hahaha :)

[10:06] <jnthn> If it constructs a set, possibly not.

[10:06] <jnthn> If it's optimized to skip that, maybe it's faster.

[10:06] <colomon> it definitely constructs a set

[10:06] <jnthn> OK, then it's probably slower. :)

[10:06] <masak> maybe some far-future optimizer could efficientize it.

[10:07] <jnthn> Why does everyone assume optimizer stuff has to be in the far future? :)

[10:07] <masak> that's just the Baysean prior since it's never happened yet :)

[10:07] <jnthn> :P

[10:07] <colomon> jnthn: at the speed you work, everyone assumes the far future is sometime next year?  ;)

[10:07] <jnthn> :P

[10:07] <masak> ok, that is now officially my favorite way to check array membership.

[10:07] <mathw> mine too

[10:08] <masak> n: my %h = 1..6; say 3 ∈ %h; say 4 ∈ %h

[10:08] <jnthn> I wonder if Rakudo on JVM is free of the epic parsing slowdown that happens if we use operators in the setting that are outside of Latin-1...

[10:08] <camelia> niecza v24-86-g39ab531: OUTPUT«True␤False␤»

[10:08] <jnthn> It really should be.

[10:09] <mathw> well, to find out you first need to make it capable of compiling the setting

[10:09] <mathw> simple, right? a morning's work? :)

[10:09] <jnthn> It's been capable of that for ages. :)

[10:09] <colomon> masak: as you probably realize, if you construct a Set from a hash, it uses the keys only

[10:09] <jnthn> "ages" :)

[10:09] <mathw> five minutes?

[10:10] <jnthn> Reached compiling most of the setting around late May. Of course, most of that compiled output didn't actually work :P

[10:10] <woosley> r: my @a=[1,3,4]; say @a.push(<a b>); say @a[-1]

[10:10] <camelia> rakudo 174bf4: OUTPUT«1 3 4 a b␤Cannot use negative index -1 on Array␤  in method gist at src/gen/CORE.setting:10476␤  in method gist at src/gen/CORE.setting:913␤  in sub say at src/gen/CORE.setting:11377␤  in block  at /tmp/JIpQo3Ar0X:1␤␤»

[10:10] <jnthn> *-1

[10:10] <colomon> r: my @a=[1,3,4]; say @a.push(<a b>); say @a[*-1]

[10:10] <camelia> rakudo 174bf4: OUTPUT«1 3 4 a b␤b␤»

[10:10] <masak> colomon: right.

[10:11] <woosley> this syntax is a bit strange

[10:12] <masak> what syntax?

[10:12] <woosley> *-1

[10:12] <colomon> r: my @a=[1,3,4]; say @a.push(<a b>); say @a[*/2]

[10:12] <camelia> rakudo 174bf4: OUTPUT«1 3 4 a b␤a␤»

[10:12] <masak> woosley: -1 didn't work in the rest of the design in Perl 6.

[10:12] <masak> woosley: -1 means "the index minus one" in Perl 6, not "one from the end".

[10:12] <masak> woosley: I think you'd agree that's at least more consistent :P

[10:13] <jnthn> s/index/elems/

[10:13] <jnthn> Note that *-1 is more general syntax

[10:13] <jnthn> r: my $x = *-1; say $x(3)

[10:13] <camelia> rakudo 174bf4: OUTPUT«2␤»

[10:13] <jnthn> And so is passing a closure to an indexer

[10:13] <woosley> Ah, I think I get it, and suddenly it looks beautiful  :) 

[10:13] <jnthn> r: my @a = 1..5; say @a[-> $elems { $elems - 2 }]

[10:13] <camelia> rakudo 174bf4: OUTPUT«4␤»

[10:15] *** atroxaper left
[10:15] <masak> jnthn: no, "-1" in a .[] in Perl 6 means "the *index* [that is] minus one"

[10:15] <woosley> r: say [1,2,['a', 'b']]

[10:15] <camelia> rakudo 174bf4: OUTPUT«1 2 a b␤»

[10:15] <jnthn> masak: oh, I thought you were talking about what gets passed to the closure...sorry.

[10:16] <masak> right.

[10:16] <masak> no, I was talking about the reasons it can't be "-1" in Perl 6.

[10:16] <masak> when someone says "*-1" is ugly, you have to start by explaining why "-1" won't cut it.

[10:16] <woosley> wondering  why the output is flattened?  expecting something like 1,2, ["a", "b"] 

[10:17] <masak> woosley: no, then that'd be "[1, 2, [a, b]]"

[10:17] <timotimo> because it gistifies when you call say on it

[10:17] <timotimo> r: print [1,2,['a', 'b']]

[10:17] <camelia> rakudo 174bf4: OUTPUT«1 2 a b»

[10:17] <timotimo> r: print [1,2,['a', 'b']].perl

[10:17] <camelia> rakudo 174bf4: OUTPUT«[1, 2, ["a", "b"]]»

[10:17] <masak> woosley: because what timotimo said. arrays don't generally have a printed output, that'd be terribly distracting in most output.

[10:17] <masak> woosley: "what are those brackets doing in my salary report! get them outta there right away!"

[10:18] <woosley> \o/

[10:18] <masak> it's like printing a string doesn't usually surround the printed string with "" quotes ;)

[10:18] <masak> same thing.

[10:22] <woosley> well, I have to say for string you will not get an "string inside string", but for a list, there is "list inside list".   

[10:23] <mathw> this is true

[10:24] *** cognominal joined
[10:24] <jnthn> Well, it's easy to write something that will dump with your desired structure

[10:26] <jnthn> r: multi d(@a) { '(' ~ @a.map(&d) ~ ')' }; multi d($x) { $x }; say d [1, 2, [3, 4, [5]]]

[10:26] <camelia> rakudo 174bf4: OUTPUT«(1 2 (3 4 (5)))␤»

[10:27] *** cognominal left
[10:28] *** cognominal joined
[10:42] *** stevan_ left
[10:43] *** woosley left
[10:44] <lizmat> good *, #perl6!

[10:44] <lizmat> r: say 1.uniq # should this work?

[10:44] <camelia> rakudo 174bf4: OUTPUT«1␤»

[10:44] <moritz> yes

[10:45] <jnthn> *, lizmat. Yes, scalars can happily pun as a single element list on demand. :)

[10:45] * lizmat then adapts some tests in uniq.t

[10:46] *** mtk joined
[10:58] *** domidumont left
[10:59] <dalek> roast: abe3272 | (Elizabeth Mattijsen)++ | S32-list/uniq.t:

[10:59] <dalek> roast: cleanup in "uniq" tests

[10:59] <dalek> roast: review: https://github.com/perl6/roast/commit/abe32729ae

[10:59] <dalek> roast: 9885e8d | (Elizabeth Mattijsen)++ | S32-list/squish.t:

[10:59] <dalek> roast: Copy of "uniq" tests for "squish"

[10:59] <dalek> roast: review: https://github.com/perl6/roast/commit/9885e8d3a1

[11:03] <grondilu> jnthn: I still get "CallCapture representation does not implement cloning", and yet I'm pretty sure I have the latest nqp (2013.06)

[11:04] <jnthn> grondilu: I meant latest as in, HEAD of the NQP repo

[11:04] <tadzik> heh, python's range() doesn't work for strings. Maybe they should have strange()

[11:04] <jnthn> :D

[11:05] <grondilu> I don't know git very well, do you mean I must run "git pull origin HEAD" in the nqp directory?

[11:06] <dalek> roast: 98b0260 | (Elizabeth Mattijsen)++ | S32-list/squish.t:

[11:06] <dalek> roast: Transmogrified "uniq" tests to "squish"

[11:06] <dalek> roast: review: https://github.com/perl6/roast/commit/98b026014b

[11:07] <jnthn> git checkout master && git pull # should do it

[11:08] <dalek> rakudo/nom: f069282 | (Elizabeth Mattijsen)++ | / (3 files):

[11:08] <dalek> rakudo/nom: Implement squish() and .squish(), as per S32/Containers

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f06928290d

[11:08] <lizmat> .oO{ one less LHF }

[11:09] *** crab2313 left
[11:09] * colomon goes to look in S32-containers....

[11:10] <lizmat> it was pretty much a no-brainer

[11:10] <lizmat> with "uniq" as the template  :-)

[11:10] <colomon> why @secret?

[11:12] <lizmat> to make sure that the first test *never* matches

[11:12] <lizmat> Mu / Any / Nil would not work, if the first element would be Mu / Any / Nil

[11:15] <lizmat> @secret can never be the first element, as it is secret  :-)

[11:15] <colomon> r: sub colomon-squish(@a) { my $last; gather sink for @a { FIRST { $last = $_; next; }; take $_ if $_ !=== $last; $last = $_; }; say colomon-squish(<a a b c d d a e>)

[11:15] <camelia> rakudo 174bf4: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/INkPTn4EAR:1␤------> [32m}; say colomon-squish(<a a b c d d a e>)[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        statement end␤        statement …

[11:15] <colomon> r: sub colomon-squish(@a) { my $last; gather sink for @a { FIRST { $last = $_; next; }; take $_ if $_ !=== $last; $last = $_; };}; say colomon-squish(<a a b c d d a e>)

[11:15] <camelia> rakudo 174bf4: OUTPUT«b c d a e␤»

[11:16] *** pmurias joined
[11:16] <lizmat> huh?

[11:16] <lizmat> rakudobug?

[11:17] <colomon> no, colomonbug

[11:17] <pmurias> what does localifetime do?

[11:17] <colomon> r: sub colomon-squish(@a) { my $last; gather sink for @a { FIRST { take $_; $last = $_; next; }; take $_ if $_ !=== $last; $last = $_; };}; say colomon-squish(<a a b c d d a e>)

[11:17] <camelia> rakudo 174bf4: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/wJT4zzUqqp:1␤------> [32mor @a { FIRST { take $_; $last = $_; nex[33m⏏[31mt; }; take $_ if $_ !=== $last; $last =[0m␤    expecting any of:␤        argument list␤        postfix␤        infix stopper␤   …

[11:18] <colomon> that might be a rakudo bug? but I've got to run to the car dealership to get my VW's breaks worked on.

[11:19] *** arnsholt joined
[11:19] *** FROGGS[mobile] left
[11:20] *** mstefanko left
[11:20] <arnsholt> jnthn: Is it ok to add non-op functions to Ops.java, or should I factor those into a separate static class for native-related code reuse?

[11:22] <jnthn> arnsholt: Ops.java is getting kinda big. I'd put 'em elsewhere. Note that we can register nqp:: things that point to other classes too :)

[11:23] <arnsholt> Oh, right. I'll just put all the NativeCall things in a separate class, in that case

[11:24] <arnsholt> Relatedly, how does box_target stuff work on JVM?

[11:24] <pmurias> jnthn: what doe localifetime do?

[11:24] <arnsholt> On Parrot, we call box_funcs->get_boxed_ref to get the NativeCall thing, but I can't find an obvious counterpart to that on JVM

[11:25] *** mstefanko joined
[11:27] <colomon> arnsholt: There's been a single failing test in NativeCall under parakudo for the last couple of weeks.  Of course, that breaks at least a dozen other modules in the ecosystem.  Any chance you could take a look at that sometime?

[11:29] <colomon> afk # to bay city

[11:29] *** colomon left
[11:30] <arnsholt> *grumblegrumble*

[11:30] <arnsholt> Could you submit an issue on it?

[11:36] <lizmat> jnthn: I guess phasers don't work yet when src/core/List is added to settings ?

[11:41] <lizmat> rewrite of squish using FIRST and NEXT fails with https://gist.github.com/lizmat/5917225

[11:41] <lizmat> it works fine if written like that in another module on an installed rakudo

[11:42] <lizmat> so I guess we can't use phasers that early in the game, right?

[11:42] <jnthn> pmurias: Not sure exactly, but you can ignore it and just compile the 0th child of the node and things work. It's purely an optimization.

[11:42] <jnthn> lizmat: No, don't use phasers in the setting, aside from BEGIN...

[11:43] *** Radvendii joined
[11:43] <lizmat> too bad…  :-)  I guess we're back to using @secret to skip the first check

[11:43] <jnthn> I don't know exactly why it doesn't work, but I don't much care for making it do so either. It'll most likely be slower than the alternatives.

[11:43] <jnthn> arnsholt: There's no direct equivalent of that yet

[11:44] <lizmat> I thought "method squish() { my $last; gather sink for @.list { FIRST next; take $_ if $_ !=== $last; NEXT $last = $_ } } was rather elegant, colomon++ for inspiration

[11:45] <arnsholt> Right. I'll leave that as a stub, then

[11:49] <jnthn> lizmat: Yes, but when you're writing CORE.setting elegance is NOT your first priority!!

[11:50] <jnthn> Your priority is "implement this so it'll be efficient".

[11:50] *** pmurias left
[11:50] <jnthn> Using gather/take in the setting when it's not needed is a huge performance no-no.

[11:50] <lizmat> well, I was just replicating what "uniq" was doing, really

[11:50] <lizmat> so you'd rather just have it do a map ?

[11:50] <jnthn> Yes, well, maybe uniq could benefit from some speedup too ;-)

[11:51] <jnthn> lizmat: Yes :)

[11:51] <lizmat> ok, will do

[11:51] <jnthn> lizmat++

[11:53] <lizmat> grep actually, of course  :-)

[11:56] *** arnsholt left
[11:57] <jnthn> :)

[11:58] <JimmyZ> Good evening

[11:58] *** woosley1 joined
[12:02] *** Radvendii left
[12:07] *** stevan_ joined
[12:08] *** colomon joined
[12:09] <colomon> o/

[12:11] *** skids left
[12:12] <dalek> rakudo/nom: d2ee950 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[12:12] <dalek> rakudo/nom: Streamline "uniq" and "squish", suggested by jnthn++

[12:12] <dalek> rakudo/nom: 

[12:12] <dalek> rakudo/nom: See http://irclog.perlgeek.de/perl6/2013-07-03#i_7284148

[12:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2ee950b5c

[12:12] <colomon> grep makes sense with uniq, but it makes my head hurt for squish

[12:12] <colomon> ooo, code!

[12:12] <colomon> arg, VW dealership wi-fi will not let me look at github.

[12:12] <colomon> solution: use my phone.  ;)

[12:13] <lizmat> colomon: basically "grep { $grepped = $_ !=== $last; $last = $_; $grepped }, @.list;"

[12:13] <colomon> lizmat: oh, I can imagine it, I just think grep with side-effects borders on abomination.  ;)

[12:14] <lizmat> "[13:50:01] <jnthn>	 Your priority is "implement this so it'll be efficient"."

[12:14] <colomon> Yes, I saw (in backlog)

[12:15] *** chayin joined
[12:15] *** chayin_ left
[12:16] <jnthn> Well, grep is really just a nice way to write a loop and an if statement ;)

[12:16] <lizmat> but there is no performance penalty, I would hope?

[12:16] <jnthn> Should be pretty efficient.

[12:17] <jnthn> Better than gather/take :)

[12:17] <lizmat> pick / roll also use gather / take

[12:18] <lizmat> optimize?

[12:19] <colomon> can you, there?

[12:19] <colomon> those have to be lazy

[12:19] <colomon> and they're not returning elements in order

[12:19] *** stevan_ left
[12:20] * lizmat keeps her hands off pick / roll  :-)

[12:20] <JimmyZ> gather mostly meanst it's lazy

[12:20] <JimmyZ> *means

[12:21] * colomon is having a hard time getting used to using irssi this morning.

[12:22] <lizmat> "method pop() is rw"  is rw, does that make sense?   I mean, this is about using .pop as a left value, no?

[12:23] <JimmyZ> r: (1..60000000000000000000).pick.say

[12:23] <camelia> rakudo f06928: OUTPUT«48815951219828953769␤»

[12:23] <JimmyZ> it's fast!

[12:23] <colomon> lizmat: method pop changes the array it's called on, right?

[12:23] <tadzik> I optimized that :)

[12:23] <tadzik> may have been my first contribution

[12:23] <JimmyZ> :P

[12:24] <tadzik> I was furious that (1..100).pick was a bottleneck of my toy program

[12:24] <colomon> tadzik++

[12:25] *** atroxaper joined
[12:25] <colomon> rn: say "this is A test".tclc

[12:25] <camelia> rakudo f06928, niecza v24-86-g39ab531: OUTPUT«This is a test␤»

[12:25] <colomon> when do we get a camelia for jakudo?

[12:25] <colomon> p6eval, I mean

[12:26] <JimmyZ> r: (1..60000000000000000000).pick(10).say

[12:26] <camelia> rakudo f06928: OUTPUT«28487812125826846065 41742209814531995164 53207098133441548403 18843020627099168440 31025068939550976321 35864436322923804035 16164864358354258087 39209912430275720740 56666890291364813086 40325031511429966569␤»

[12:26] <tadzik> rakudo-jvm: say 1

[12:26] <tadzik> not sure if doesn't exist, or just slow

[12:26] <lizmat> r: my @a=1,2,3; @a.pop = 4; say @a

[12:26] <camelia> rakudo f06928: OUTPUT«1 2␤»

[12:26] <jnthn> Doesn't exist, afaik

[12:27] <masak> no, don't think it does.

[12:27] <lizmat> r: my @a=1,2,3; my $b = @a.pop = 4; say @a; say $b

[12:27] <camelia> rakudo f06928: OUTPUT«1 2␤4␤»

[12:27] <lizmat> I guess it makes *some* kind of sense

[12:28] <lizmat> but it feels more like an error to me that remains silent

[12:28] <colomon> lizmat: insane and wrong in my book

[12:28] <masak> correct in my book, but for obscure reasons.

[12:29] <masak> it's the container/decont thing.

[12:31] <lizmat> S12:564 says: Methods (and subs) may be declared as lvalues with C<is rw>.

[12:32] <lizmat> pop() is not an lvalue?

[12:32] <masak> I'm trying to think of a reason .pop *should* be lvalue and not rvalue.

[12:32] <masak> haven't found any yet. but that doesn't mean there isn't one.

[12:32] <masak> my suggestion: make it an rvalue and see if any spectests fail.

[12:32] * lizmat is already running spectest with pop() without "is rw"

[12:32] <colomon> seems like it is a thinko for "pop modifies the method it is called on"

[12:33] <lizmat> back in ~ 7 minutes

[12:33] * colomon wonders if it might be one of his own mistakes from years ago...

[12:33] *** pmurias joined
[12:33] <masak> lizmat++

[12:33] <colomon> lizmat++ indeed!

[12:36] <colomon> I'm looking at wordcase.  tclc works, so it seems like it must be subst or matching that isn't working?

[12:42] <colomon> anyone have a notion what / [<:L> \w* ] +% <['\-]> / is supposed to do?

[12:43] *** cognominal left
[12:43] *** cognominal joined
[12:48] <masak> yes.

[12:48] <masak> the fact that '+%' is a confusing way to write two operators aside...

[12:49] <masak> it means this: "a letter followed by zero or more word characters (letter, digit, underscore). make that into a group. accept one or more of that group, separated by single apostrophes or dashes."

[12:50] <colomon> "accept one or more of that group" is completely unnecessary, no?

[12:50] <moritz> no

[12:50] <moritz> not with the delimiter

[12:51] <colomon> moritz++

[12:51] <moritz> [<:L> \w*] matches 'A222' for example

[12:51] <moritz> repetition + delimiter make it also match A222-Bx'c3

[12:52] <colomon> the capitalize.t tests are thoroughly insufficient to test this stuff, as far as I can see.

[12:53] * colomon replaced that whole mess with w+ and it passes the same tests as the other one does.

[12:54] <moritz> <:L> doesn't match digits and _ 

[12:54] <moritz> yes, the tests aren't that thorough

[12:55] <colomon> moritz: no, I understand that.  and I mean the entire regex, so that internal - and ' weren't allowed any more.

[12:55] <colomon> No tests failed.

[12:55] <colomon> [<:L> \w*]+ % <[ \- ' ]> doesn't actually work on JVM

[12:55] <colomon> dunno why

[12:56] <colomon> nor [<:L> \w* ] +% <['\-]>

[12:56] <colomon> well, I can guess it might be the :L?

[12:58] <moritz> you can easily check that

[12:58] <colomon> just did, and it is

[13:00] <moritz> unicode properties might win us a few houndred to a few thousand tests :-)

[13:00] <jnthn> We already have them besides the derived.

[13:01] <colomon> huh

[13:01] <colomon> > "a" ~~ / <:L> /

[13:01] <colomon> ｢a｣

[13:01] <colomon> now I'm really confused

[13:02] <colomon> > "this is a test".subst(:g, / [<:L> \w*]+ % <[ \- ' ]> /, "---")

[13:02] <dalek> nqp: c8a6c01 | (Pawel Murias)++ | docs/serialization_format.markdown:

[13:02] <dalek> nqp: Document what a variant 12 means in the serialization format.

[13:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c8a6c01425

[13:02] <colomon> this is a test

[13:02] <masak> I'm confused too.

[13:02] * pmurias hopes he didn't break rakudo with his nqp commit ;)

[13:03] *** xinming left
[13:03] *** konundra joined
[13:04] *** xinming joined
[13:04] <FROGGS> pmurias: I'm running the stresstest just to be sure :P

[13:04] <colomon> I am completely mystified by this

[13:04] <colomon> ... and I cannot post gists here at the dealership.  :(

[13:05] <colomon> oh!

[13:05] <colomon> > "this is a test" ~~ / [<:L> \w*]+ % <[ \- ' ]> /

[13:05] <colomon> ｢t｣

[13:05] <[Coke]> minor update to https://gist.github.com/coke/5879701 which includes some commits from yesterday.

[13:05] <colomon> rn: say "this is a test" ~~ / [<:L> \w*]+ % <[ \- ' ]> /

[13:06] <camelia> rakudo f06928, niecza v24-86-g39ab531: OUTPUT«｢this｣␤␤»

[13:06] <lizmat> seems .pop needs to be "is rw" because of unshift

[13:07] <colomon> lizmat: huh?

[13:07] <lizmat> while @elems { nqp::unshift($!items, @elems.pop) }

[13:07] <lizmat> apparently the pushed element is not rw 

[13:07] *** benabik left
[13:07] <lizmat> *unshifter

[13:08] <lizmat> RT #69548

[13:09] <masak> lizmat: that... feels like a weird reason.

[13:09] <colomon> what masak said

[13:09] <masak> lizmat: my initial reaction is that that's not pop's fault. it's the fault of whatever happens before you pass the thing into unshift.

[13:10] <colomon> > "this is a test" ~~ / <:L> \w+ /

[13:10] <colomon> Nil

[13:10] <colomon> > "this is a test" ~~ / <:L> \w* /

[13:10] <colomon> ｢t｣

[13:10] <colomon> rn: say "this is a test" ~~ / <:L> \w+ /

[13:10] <lizmat> oddly enough, I get some todo's passed with this change

[13:10] <camelia> rakudo f06928, niecza v24-86-g39ab531: OUTPUT«｢this｣␤␤»

[13:10] * masak isn't sure whether to submit a rakudobug :/

[13:10] <colomon> jnthn: ^^^^^

[13:11] *** PacoAir joined
[13:11] *** not_gerd joined
[13:11] <not_gerd> o/

[13:12] <not_gerd> FROGGS: https://gist.github.com/FROGGS/836912b4855d6d9f05e1#comment-855950

[13:12] <jnthn> colomon: uh...wow, wtf... :)

[13:12] <jnthn> Nice golf.

[13:12] <masak> colomon++

[13:15] <lizmat> r: sub MAIN( $a = nosuchsub()) { }; sub USAGE { say 42 }

[13:15] <camelia> rakudo d2ee95: OUTPUT«===SORRY!===␤Cannot assign a non-Perl 6 value to a Perl 6 container␤»

[13:16] <jnthn> wat

[13:16] * masak submits rakudobug

[13:17] <lizmat> not sure if this is .pop is rw related

[13:18] <FROGGS> not_gerd: I answered :o)

[13:18] * masak tests locally

[13:18] <masak> lizmat: I can't reproduce your bug here.

[13:18] <masak> but I have an old rakudo. pulling and rebuilding.

[13:18] <masak> someone else is free to test locally, too.

[13:19] *** ajr joined
[13:19] <lizmat> this is probably just noise

[13:19] *** ajr is now known as Guest86710

[13:19] <lizmat> remaking without .pop change, and testing again

[13:20] <masak> who wants to release the Rakudo compiler in August?

[13:20] <masak> I'll make the usual trade -- if someone claims August, I will claim September :)

[13:20] <not_gerd> FROGGS: I've got a patch ready that does +1/shift/-1 that passes your test

[13:20] <moritz> masak: ok, I'll do August

[13:20] <not_gerd> shall I push that?

[13:22] <masak> moritz: shall I add you, or are you already on it?

[13:22] <lizmat> t/spec/S06-other/main-usage.t  fails, test #3

[13:23] <lizmat> apparently caused by something committed already

[13:23] <FROGGS> not_gerd: push if it does not break spectests

[13:24] <dalek> rakudo/nom: 5230d5a | masak++ | docs/release_guide.pod:

[13:24] <dalek> rakudo/nom: [docs/release_guide.pod] add moritz and me for Aug/Sep

[13:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5230d5ac69

[13:24] <masak> moritz++

[13:24] <lizmat> rerunning full spectest, just to be sure

[13:25] *** Chillance joined
[13:27] <lizmat> r: Module.new

[13:27] <camelia> rakudo d2ee95: OUTPUT«===SORRY!===␤Cannot assign a non-Perl 6 value to a Perl 6 container␤»

[13:27] <lizmat> huh?

[13:27] <lizmat> did I break that?

[13:28] <FROGGS> lizmat: locally I get: "undeclared name Module used"

[13:28] <FROGGS> but my rakudo is about 6 hours old

[13:29] <FROGGS> This is perl6 version 2013.06-111-g54b7dd5 built on parrot 5.5.0 revision RELEASE_5_5_0

[13:29] <lizmat> so it must have been something I did

[13:29] <not_gerd> Is it just me, or has Rakudo/Parrot performance regressed since March?

[13:30] <FROGGS> ohh, mine is a day old

[13:32] <lizmat> yup, it is my uniq/grep optimization that makes things fail

[13:33] *** kaare_ joined
[13:33] <not_gerd> yep, there's a massive slowdown in stage parse...

[13:33] <lizmat> that could be because there is more code to parse ?

[13:34] *** Guest86710 is now known as ajr_

[13:34] <[Coke]> not_gerd: is this during the build of ./perl6, or running arbitrary code?

[13:34] <FROGGS> yes, like IO::Spec and several other things

[13:34] <not_gerd> [Coke]: both

[13:34] <not_gerd> CORE.setting from ~100s to 140s

[13:35] <not_gerd> a test script I use to keep track of this went from 1.3s to 2s

[13:35] <moritz> that's not good :(

[13:35] *** bluescreen10 joined
[13:36] <not_gerd> note that I don't know yet if it's a change in Parrot or Rakudo that's responsible

[13:36] <not_gerd> heck, I even updated my gcc since then ;)

[13:36] * lizmat hopes it's not her hash/array slice adverb code that's to blame

[13:37] <jnthn> So much has happened since March, it could be a combination of many things rather than any one big thing.

[13:38] <jnthn> For compile time, it's also possible it's a change in NQP too.

[13:39] * moritz finds it hilarious and sad that bugs.otrs.org is powered by bugzilla, not otrs

[13:39] <tadzik> bootstraping problem? :P

[13:40] *** estrabd joined
[13:40] *** colomon left
[13:40] <moritz> hardly

[13:46] <nwc10> moritz: that's, just, um, what's the point of the product then?

[13:47] <nwc10> it's a pretty good "we don't think our product is good enough" anti-advert

[13:47] <moritz> nwc10: aye

[13:48] <dalek> rakudo/nom: ce8b5f6 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[13:48] <dalek> rakudo/nom: Restore "uniq" to unstreamlined form, it messes up odd things

[13:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce8b5f6b21

[13:49] *** skids joined
[13:50] <lizmat> afk for a few hours&

[13:58] <dalek> v5: 2965c89 | (Tobias Leich)++ | / (2 files):

[13:58] <dalek> v5: fixed warn/die, added directive "s" to pack/unpack

[13:58] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/2965c89576

[13:58] <dalek> v5: 8105c22 | (Tobias Leich)++ | rakudo.patch:

[13:58] <dalek> v5: update rakudo-patch

[13:58] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8105c22d28

[14:05] *** btyler joined
[14:05] <masak> lizmat: with Poznan-128-g5230d5a, I get your error locally.

[14:05] <masak> ah, but there's a new commit ;)

[14:09] *** fridim_ left
[14:23] *** colomon joined
[14:28] *** xilo_ joined
[14:29] <dalek> nqp: bfe5c17 | (Gerhard R)++ | src/vm/parrot/ops/nqp_bigint.ops:

[14:29] <dalek> nqp: Simplify conversion from sign-manitude to two's complement in nqp_bigint_shr()

[14:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bfe5c17dd7

[14:33] *** rindolf joined
[14:36] *** kaleem left
[14:41] <Util> rn: my %b = z => 26; my $b = %b; my @a =      $b; say @a.perl;

[14:41] <camelia> niecza v24-86-g39ab531: OUTPUT«[{"z" => 26}].list␤»

[14:41] <camelia> ..rakudo ce8b5f: OUTPUT«Array.new({"z" => 26})␤»

[14:41] <Util> rn: my %b = z => 26;             my @a = item %b; say @a.perl;

[14:42] <camelia> rakudo ce8b5f: OUTPUT«Array.new("z" => 26)␤»

[14:42] <camelia> ..niecza v24-86-g39ab531: OUTPUT«[{"z" => 26}].list␤»

[14:42] <Util> I expect the output to be identical. In Niecza, they match, but in Rakudo, item() is unwinding the hash into its .pairs .

[14:42] <Util> Is this a bug in Rakudo, or am I misunderstanding the C<item> contextualizer?

[14:43] <moritz> rakudobug

[14:44] <moritz> (and known by RT)

[14:44] *** birdwindupbird left
[14:45] <Util> moritz: Thanks

[14:46] <moritz> (and fixes would be very welcome indeed)

[14:47] <moritz> r: my %h = (z => 26); my $s = %h; my @a = $s; say @a.perl

[14:47] <camelia> rakudo ce8b5f: OUTPUT«Array.new({"z" => 26})␤»

[14:47] <moritz> oh, I think the problem might be that this

[14:48] <moritz> r: sub f(*@a) { say @a.perl }; f my % = a => 2

[14:48] <camelia> rakudo ce8b5f: OUTPUT«Array.new("a" => 2)␤»

[14:48] <moritz> I wonder if sub item can simply have the signature \a or so

[14:53] *** FROGGS left
[14:53] *** woosley1 left
[14:59] *** xilo_ left
[15:00] *** notjack joined
[15:13] <colomon> hmmm, zavolaj is failing very badly on OS X

[15:16] *** pmurias left
[15:16] <masak> thought you were gonna say it's failing very badly on the JVM... :)

[15:17] *** not_gerd left
[15:19] *** ecocode left
[15:25] <colomon> nope, that's parakudo

[15:27] <colomon> wouldn't be surprised if it has something to do with changing the compiler and OS version yesterday, mind you.

[15:28] *** SamuraiJack left
[15:29] <geekosaur> OS version will definitely break stuff

[15:29] *** vk joined
[15:35] <colomon> ugh, issues building parakudo from scratch  :\

[15:37] *** dmol1 left
[15:37] <dalek> rakudo-js: 964b229 | (Pawel Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[15:37] <dalek> rakudo-js: Insert vim folds into the output for easier debugging of the compiler.

[15:37] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/964b22911b

[15:37] <dalek> rakudo-js: a4dbf65 | (Pawel Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[15:37] <dalek> rakudo-js: Igonre localife time

[15:37] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/a4dbf654f5

[15:37] <dalek> rakudo-js: 4437535 | (Pawel Murias)++ | runtime/serialization.js:

[15:37] <dalek> rakudo-js: Fix typo in comment.

[15:37] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/4437535ae9

[15:37] <dalek> rakudo-js: 3c0edb1 | (Pawel Murias)++ | runtime/serialization.js:

[15:37] <dalek> rakudo-js: Remove dead code.

[15:37] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/3c0edb1692

[15:38] *** stevan_ joined
[15:41] <colomon> how did perlbrew get in /opt/local ?!?

[15:43] *** stevan_ left
[15:46] *** benabik joined
[15:48] <colomon> installed new perlbrew, hopefully actually local to my user id; now installing new perl on it.

[15:52] <pmichaud> TimToady++  # excellent news from the test results.  

[15:53] <lizmat> is that public already?

[15:53] <pmichaud> I saw it in the scrollback, I believe

[15:53] <moritz> http://irclog.perlgeek.de/perl6/2013-07-03#i_7283130

[15:53] *** daxim left
[15:53] <moritz> aye, TimToady++

[15:54] <lizmat> indeed, must catch up on today's backlog

[15:58] <lizmat> indeed, TimToady++

[16:04] <TimToady> well, it's not like I did anything, other than believe the doctor when he said "You have to have that out ASAP."

[16:07] *** fhelmberger left
[16:07] * TimToady wonders if we'd still have Steve Jobs if he'd let the doctors treat him earlier...

[16:09] <timotimo> many people who are opposed to the kind of treatment he got are - or at least seem to be - certain of that

[16:11] *** kaleem joined
[16:11] *** grondilu left
[16:13] <TimToady> I can guarantee to you that certainty is overrated.

[16:13] <timotimo> for sure.

[16:17] * colomon made the mistake of clicking the new "All My Files" in Finder hoping it was the way to get to his home directory.  It's now trying to (slowly) build a convenient list of all 1,000,000+ files on my system.  How clever, Apple!

[16:18] *** kaleem left
[16:27] <TimToady> timotimo: anyway, in my experience, the quacks err on the side of certainty much more often than the non-quacks

[16:28] <timotimo> they are probably all very, very convinced in the magical-healing-ability-du-joure(sp?) of their ... thing

[16:28] <TimToady> but alas, the medical profession is not the only profession in which people peddle certainty to people who crave certainty

[16:29] *** xilo_ joined
[16:29] <timotimo> when somebody needs a cure and there is apparently none (yet), they'll turn to anything that gives them hope and i certainly can't blame them.

[16:30] <timotimo> also, i don't feel i should continue talking about this; i've never had anything remotely life-threatening happen to me afaict

[16:34] <TimToady> sure, people will spend fortunes on slim chances, though usually we call this a gambling addiction

[16:34] <timotimo> hadn't thought of it that way

[16:34] *** vk left
[16:34] <timotimo> but i'd really rather blame the quacks than those who get tricked by them

[16:35] <timotimo> i suppose - without having any clue how it actually feels - that such life threatening situations can very well blow any last bit of capability for rational thought out of one's head

[16:36] <TimToady> there are far too many people in the world who are willing to collect blood money, and who work very hard to convince themselves that they aren't

[16:38] <TimToady> well, I suppose this is all rather OT here, where we only have the best of intentions :)

[16:38] <perigrin> timotimo: you're also arguing that rational thought is possible in a system riddled with unknowns.

[16:38] <timotimo> perigrin: to me, it seems like a not completely unimportant piece of the puzzle is vastly overestimating the powers of things that science deems "not yet fully understood"

[16:39] <perigrin> science vastly overestimates what it understands quite a lot of the time.

[16:39] <perigrin> this is why it's constantly surprising and amazing.

[16:39] <perigrin> And disappointing to many.

[16:39] <timotimo> "asian wasabi-coated nuts are not fully understood by science! so it's only sensible to believe this guy who claims it can cure baldness when snorted!"

[16:39] <TimToady> yes, but science also believes in falsifying itself when necessary

[16:40] <perigrin> TimToady: yeah, it sucks but not as much as all the alternatives I think is a fair description of my relationship with science. :)

[16:40] <timotimo> i think i need only point at the success of the anti-vaccination crowd to make clear that even if science is sufficiently sure about something, that doesn't matter to people who are scared.

[16:40] <TimToady> "Fear is the mind-killer."

[16:41] <timotimo> i think the instinctive drowning response or what it's called is a good example of "fear is the mind-killer", but it may be too literal ;)

[16:42] <perigrin> Science isn't sufficiently sure about the thing they're afraid of though.

[16:42] <timotimo> right, but that doesn't excuse going off into the craziest directions in the name of "hope that science is fundamentally wrong about moon light"

[16:43] <timotimo> but yeah, this is OT and we're all nice people who don't, at all, work on a secret healing product that's supposed to cure us and others of all ills ;)

[16:43] <timotimo> well, i suppose at least we're not charging people obscene amounts of money

[16:43] <perigrin> speak for yourself, I'm a consultant. 

[16:43] <timotimo> :D

[16:44] <perigrin> (one who probably should charge more though)

[16:46] *** ajr_ left
[16:52] *** dakkar left
[16:55] *** denny joined
[16:55] *** denny left
[17:10] *** atroxaper left
[17:10] *** notjack left
[17:11] *** FROGGS[mobile] joined
[17:13] *** vk joined
[17:14] <sorear> o/ in passing

[17:19] *** spider-mario joined
[17:20] <lizmat> sorear!

[17:22] <colomon> \o

[17:22] *** pmurias joined
[17:24] *** arnsholt joined
[17:25] *** Moukeddar joined
[17:25] *** Moukeddar left
[17:28] *** ajr joined
[17:28] *** ajr is now known as Guest66657

[17:29] <pmurias> pmichaud: I got confused and thought the parrot weekly report was due by today instead of yesterday :(

[17:30] <pmurias> s/parrot/gsoc/

[17:30] <arnsholt> Looks like my IRC machine should be more or less back now \o/

[17:32] <colomon> \o/

[17:32] <colomon> arnsholt: I should have said that the zavolaj bug I reported doesn't look to be a crazy c-side one.  It's something going wrong on the p6 side.

[17:33] <arnsholt> Oh, goody!

[17:33] <arnsholt> That should make it a bit easier to nail down

[17:33] <arnsholt> Thanks for the issue, I'll look into it as soon as I can

[17:34] <arnsholt> Somewhat relatedly, have any people found any good workflows for having a working Parrot Rakudo while also hacking on the JVM stuff?

[17:34] *** Guest66657 is now known as ajr_

[17:34] *** not_gerd joined
[17:34] <colomon> arnsholt: I've just made separate rakudo and rakudo-jvm directories on my Linux box.

[17:35] <arnsholt> Makes sense, I guess

[17:35] <colomon> It's less than perfect, though, because you can't easily spectest changes on both without pushing to github.

[17:36] <colomon> so I guess maybe I haven't found a good workflow.

[17:37] *** berekuk left
[17:37] <colomon> And I have yet to successfully build both parakudo and jakudo my OS X box at the same time.  :\

[17:37] <jnthn> You can always have a local bare copy of the repos and clone from those, then you can push between 'em.

[17:38] *** snoopy left
[17:38] <jnthn> Then push up to github when ready

[17:38] <not_gerd> what's the etiquette for adding test files that fail in Niecza due to lack of native types?

[17:38] <not_gerd> do I need to add some magic comments to https://gist.github.com/gerdr/5920705 ?

[17:38] <colomon> well, it's nice to fudge them:   #?niecza skip "Native types NYI"

[17:39] <TimToady> well, that one is a bit more complicated

[17:39] <TimToady> needs a multipler on the check routine

[17:39] <TimToady> *plier

[17:41] <arnsholt> jnthn: Yeah, that's probably the sanest way to go

[17:41] <TimToady> so needs a #?DOES 10 or some such on the check sub def

[17:42] <TimToady> plus a #?niecza skip on the calls to check

[17:42] * benabik is just using git clone -s rakudo rakudo.jvm.

[17:42] <colomon> benabik: -s ?

[17:43] <benabik> colomon: --shared.  It adds the original repository to the alternates list for the second, so it will search for objects in the original repository.

[17:43] <arnsholt> Oooh, neat

[17:43] <TimToady> The main problem with git is that there are these concepts, and there are these commands, and they seem to have very little to do with each other.  :)

[17:43] <not_gerd> TimToady: thanks

[17:44] <arnsholt> Git leaks abstractions all over the UI, sadly

[17:44] <benabik> colomon: There are warnings about rebasing/deleting branches/etc, but mostly rakudo.jvm is a throw-away since I don't (currently) plan on doing much dev there.

[17:44] <not_gerd> I'll see if they can split check into regular + native

[17:44] *** vk left
[17:44] <TimToady> not_gerd: for additional background, see README in roast

[17:45] <TimToady> fudge is one of the most useful utter hacks in existence :)

[17:46] <benabik> Hm.  Also need a nqp.jvm, I guess?

[17:46] <not_gerd> reading README before committing to a public repository: whoever heard of such a ludicrous thing ;)

[17:46] <masak> timotimo: well, I don't know about you, but I've been snorting wasabi for decades and I have lots of hair.

[17:46] <benabik> I'm going to guess that trying to have a nqp.parrot and nqp.jvm both installed is going to fail miserably.

[17:47] <masak> timotimo: :P

[17:47] <timotimo> :)

[17:47] <perigrin> TimToady: I didn't realize there was that much milk in fudge ... 

[17:47] *** arnsholt_ joined
[17:47] *** arnsholt_ left
[17:47] <TimToady> query: how do you *not* snort wasabi, other than not eating it?

[17:47] <colomon> benabik: clone it in the rakudo.jvm directory, install it into the rakudo.jvm directory.  see README

[17:47] <benabik> colomon: README?  Bah.  :-D

[17:48] <masak> TimToady: point.

[17:48] <jnthn> TimToady: tbh, I was kinda stuck on how to snort nuts...they seem a bit big for snorting...

[17:48] * TimToady wonders if naming it DON'T-README would cause more people to read it...

[17:49] <perigrin> jnthn: depends on the size of your nostrils ... also I point out that you can do anything potentially fatal at least once.

[17:49] <timotimo> commit a symbolic link to the readme file, commit "hopefully the people who don't read the readme read the don't-readme."

[17:49] <lizmat> .oO{ reminds me of that text-file called "secret", with as only contents the line "Access Denied" }

[17:50] *** grondilu joined
[17:51] <TimToady> in the old days, Configure might've said, "Hi, I see you've never accessed the README.  Let me just pop it up for you now."  :)

[17:51] <TimToady> then again, it might not've.

[17:52] <timotimo> aaw, that's awfully cute

[17:52] <timotimo> what happens on noatime systems? :)

[17:52] * TimToady believes that's the first time he's ever seen the word "not've".

[17:52] * masak .oO( I'd've'nt )

[17:52] <timotimo> i'd'ven'n ... yeah

[17:53] <perigrin> I'd've'nt Calendar.

[17:53] * timotimo imagines the perl6 advent calendar will be even more exciting this year

[17:53] <TimToady> maybe that's our problem, we keep counting up, when we should be counting down...

[17:53] <timotimo> afk&

[17:54] * TimToady has the problem of reading that as a'f'k now...

[17:57] *** not_gerd left
[18:02] *** grondilu left
[18:02] <TimToady> Fear may be the mind-killer, but lack of fear is the brain-killer.

[18:02] *** Timbus left
[18:04] *** Timbus joined
[18:04] <[Coke]> Only I will remain.

[18:04] <TimToady> [Coke] is it!

[18:05] <[Coke]> *bow*

[18:05] <TimToady> [Coke] is the real thing, it the back of your mind-killer.

[18:05] <TimToady> *in

[18:10] *** raiph joined
[18:10] <benabik> Parsing takes 1/5th the time on JVM as on Parrot?

[18:10] <benabik> ls

[18:11] <[Coke]> I am not looking forward to changing autounfudge to understand vm backends.

[18:14] <segomos> anyone know github::supernovus ?

[18:14] <timotimo> he's on this channel every once in a while i believe

[18:14] <segomos> thanks, i'll keep an eye out for him

[18:14] <[Coke]> LHF? test if things that are skipped to null PMC errors work on parrot.jvm and skip only the parrot version.

[18:14] <timotimo> last time on 2013-05-31

[18:16] <raiph> I'm being asked if gather/take is built on continuations, coroutines, or threads. I'm thinking coros for niecza and parakudo, and jakudo will use continuations. I'm poking around source, commits, irc logs, etc. But would really appreciate answers from others...

[18:16] <yoleaux> 03:35Z <sorear> raiph: I have never heard of a perl6 implementation without 100% lazy gather/take.  Your questions are weird.

[18:17] <jnthn> raiph: I believe Niecza does continuations, at lesat if sorear++ did them similar there to on Rakudo JVM. Rakudo Parrot uses coroutines.

[18:17] <raiph> .tell sorear I'm being harassed about P6. Fwiw I meant strictly lazy (100%) vs mostly lazy (batched).

[18:17] <yoleaux> raiph: I'll pass your message to sorear.

[18:17] <jnthn> raiph: The spec doesn't, iirc, mandate approach.

[18:17] <timotimo> harassed in a bad way or by friends who are interested to learn more?

[18:18] <jnthn> raiph: Which is a good thing imho, as it means different targets can pick the appropriate solution.

[18:18] <raiph> jnthn: right. but i'm trying to state which is currently being used by various implementations.

[18:19] <timotimo> what's the plan for gather/take on moarvm?

[18:19] <raiph> timotimo: it's being asked in a hostile way, but i want to give friendly answers

[18:20] <jnthn> timotimo: I'm inclined to supply the same nqp:: ops that sorear implemented on JVM.

[18:20] *** Rotwang joined
[18:20] <jnthn> timotimo: Though they can be implemented in a more efficient way in MoarVM. :)

[18:20] <pmurias> raiph: I have experimented with partialy implementing the ops required for gather/take on node.js with threads

[18:21] <jnthn> pmurias: OS threads or green threads?

[18:21] <pmurias> pthreads

[18:21] <pmurias> I played with using the fibers node module

[18:21] <pmurias> which implement coroutines with pthreads and a lot of locks

[18:21] <pmurias> * implements

[18:23] <raiph> jnthn, pmurias: thanks! :)

[18:23] <timotimo> raiph: good approach (kill them with kindness!)

[18:26] <jnthn> So, what shall I work on tonight... :)

[18:28] <timotimo> jnthn: can you get "callframe nyi" done easily? it seems to block a big amount of tests and it would make MAIN work :)

[18:28] <jnthn> ergh

[18:28] <jnthn> maybe

[18:28] <timotimo> just a suggestion

[18:29] <timotimo> otherwise, get "shell" running? that ought to be much easier /s

[18:29] <jnthn> Well, the main tests may well go on to block on shell...

[18:29] <jnthn> Depends how they're done I guess

[18:29] <Util> r:                      .say for <abc def ghi>.map({ ~$/[0]    if      /.(.)./ }); # 1. RE in-lined

[18:29] <camelia> rakudo ce8b5f: OUTPUT«b␤e␤h␤»

[18:30] <Util> r: my $re = rx {.(.).}; .say for <abc def ghi>.map({ ~$/[0]    if      /<$re>/ }); # 2. RE in separate var

[18:30] <camelia> rakudo ce8b5f: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/MkDfBQtl6f:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/MkDfBQtl6f:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/MkDfBQtl6…

[18:30] <Util> r: my $re = rx {.(.).}; .say for <abc def ghi>.map({ ~$/<X>[0] if /$<X>=<$re>/ }); # 3. Work-around for broken #2.

[18:30] <camelia> rakudo ce8b5f: OUTPUT«b␤e␤h␤»

[18:30] <Util> 1. Shouldn't the second version work, according to S05?

[18:30] <Util> 2. Is there a better work-around than #3?

[18:30] <jnthn> Util: You didn't capture anything in the second one

[18:30] <jnthn> (<$re>) would work

[18:31] <jnthn> <X=$re> is probably a neater way to do 3

[18:32] <timotimo> jnthn: you're probably right about the shell blocking; no use implementing something that won't give a boost in test results immediately! ;)

[18:32] <jnthn> Well, it will make callframe pass ;)

[18:32] * jnthn had hoped to troll sorear++ into doing shell :D

[18:33] <timotimo> :D

[18:34] *** berekuk joined
[18:35] <jnthn> oh...maybe CallFrame can be implemented with cunning use of what already exists...

[18:37] <Util> jnthn: I would think that #2 would capture, because the referenced RE has a capture in it.

[18:37] <Util> Even if that is wrong, then how do I navigate to the data element (middle character) captured in $re ?

[18:37] <Util> r: my $re = rx {.(.).}; .say for <abc def ghi>.map({ ~$/[0][0]    if      /(<$re>)/ }); # 4. Capturing #2

[18:37] <camelia> rakudo ce8b5f: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/U2BFmTRBba:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/U2BFmTRBba:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/U2BFmTRBb…

[18:42] <jnthn> r: my $re = rx {.(.).}; say 'abc' ~~ /(<$re>)/

[18:42] <camelia> rakudo ce8b5f: OUTPUT«｢abc｣␤ 0 => ｢abc｣␤␤»

[18:42] <jnthn> Um. What happened to the inner match...

[18:43] * masak submits rakudobug

[18:46] <masak> r: say 'abc' ~~ /(.(.).)/

[18:46] <camelia> rakudo ce8b5f: OUTPUT«｢abc｣␤ 0 => ｢abc｣␤  0 => ｢b｣␤␤»

[18:48] <colomon> errr…. 0 both times?

[18:48] <masak> yes.

[18:48] <masak> nested.

[18:48] <jnthn> Note the extra indentation on the second

[18:48] <masak> $/[0] and $/[0][0]

[18:48] <colomon> It doesn't really show up in my IRC client

[18:52] <masak> does here.

[18:53] <timotimo> does here, too. but it's just 1 space fo rthe outer and 2 spaces for the inner match

[18:59] <dalek> rakudo/nom: f60a2c1 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[18:59] <dalek> rakudo/nom: Optimize lexical out of hot loop in "uniq"

[18:59] <dalek> rakudo/nom: 

[18:59] <dalek> rakudo/nom: And I've now given up on using grep{} in uniq(), the tests succeeed, but strange

[18:59] <dalek> rakudo/nom: unrelated things change, like giving the wrong error message:

[18:59] <dalek> rakudo/nom: $ perl6 -e 'Module.new'

[18:59] <dalek> rakudo/nom: ===SORRY!===

[18:59] <dalek> rakudo/nom: Cannot assign a non-Perl 6 value to a Perl 6 container

[18:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f60a2c111e

[18:59] <TimToady> the problem with /(<$re>)/ is that the <> is still going to throw away the captured material inside because it doesn't start with alpha

[19:00] <jnthn> oh!

[19:00] <TimToady> r: my $re = rx {.(.).}; say 'abc' ~~ /<0=$re>/

[19:00] <camelia> rakudo ce8b5f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at /tmp/oELPklkKhF:1␤------> [32mmy $re = rx {.(.).}; say 'abc' ~~ /<[33m⏏[31m0=$re>/[0m␤Regex not terminated␤at /tmp/oELPklkKhF:1␤------> [32mmy $re = rx {.(…

[19:00] <pmurias> jnthn: how can I determin if a lexical is stored (and more importantly serialized) as a native int/str/num?

[19:00] <TimToady> hah

[19:00] <TimToady> r: my $re = rx {.(.).}; say 'abc' ~~ /$0=<$re>/

[19:00] <camelia> rakudo ce8b5f: OUTPUT«｢abc｣␤ 0 => ｢abc｣␤  0 => ｢b｣␤␤»

[19:00] <masak> \o/

[19:00] <masak> TimToady: so the rakudobug is a dud?

[19:00] <TimToady> arguably <0= should work

[19:01] <TimToady> /(<$re>)/ is behaving correctly

[19:01] <jnthn> pmurias: The static info associated with the lexical scope in question has that info.

[19:01] * masak marks the rakudobug 'rejected'

[19:01] <TimToady> n: my $re = rx {.(.).}; say 'abc' ~~ /<0=$re>/

[19:01] <camelia> niecza v24-86-g39ab531: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unrecognized regex assertion at /tmp/QWC1fmcv4d line 1:␤------> [32mmy $re = rx {.(.).}; say 'abc' ~~ /<[33m⏏[31m0=$re>/[0m␤␤Parse failed␤␤»

[19:02] <pmurias> jnthn: and in the QAST it's determined by the .returns on QAST::Var?

[19:02] * TimToady ponders making that work

[19:02] <jnthn> pmurias: Same thing that is used to implement nqp::lexprimspec(), fwiw

[19:02] <jnthn> pmurias: Yes

[19:02] <dalek> perl6-roast-data: 995b704 | coke++ | / (5 files):

[19:02] <dalek> perl6-roast-data: today (automated commit)

[19:02] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/995b704291

[19:03] <jnthn> pmurias: Using nqp::objprimspec on what's in .returns

[19:03] <masak> std: my $re = rx {.(.).}; say 'abc' ~~ /<0=$re>/

[19:03] <camelia> std 85cf51d: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex assertion at /tmp/6nyYNWTxAa line 1:␤------> [32mmy $re = rx {.(.).}; say 'abc' ~~ /<[33m⏏[31m0=$re>/[0m␤    expecting assertion␤Parse failed␤FAILED 00:00 45m␤»

[19:03] <jnthn> [Coke]++

[19:03] <jnthn> yay, we gained 69 tests :)

[19:04] <masak> '0=' feels a bit less clear to me than '$0='. but beyond that I'm not vested either way.

[19:05] * lizmat continues "what if Nil inherits from Mu" scenario

[19:05] <pmurias> jnthn: thanks

[19:06] <colomon> \o/

[19:12] <lizmat> looking for feedback: https://gist.github.com/lizmat/5921809

[19:12] <jnthn> timotimo: Think I may have got a CallFrame that works :)

[19:12] * jnthn pops it into the setting and tries to build it

[19:13] *** snoopy joined
[19:17] <jnthn> timotimo: oh, it did help those two MAIN tests :)

[19:17] <[Coke]> jnthn++

[19:18] *** dmol joined
[19:20] <masak> lizmat: looking at f60a2c1, I'm wondering if it's not a bit of a zero-sum thing.

[19:20] * timotimo didn't even see the commit that did anything

[19:20] <timotimo> oh, that's because you didn't commit it yet! never mind :)

[19:20] <timotimo> cool beans! :)

[19:21] <lizmat> masak: you mean it doesn't matter if the lexical gets created again and again inside the loop, or only once outside ?

[19:21] <masak> lizmat: yes, you save a lexical sitting in the pad of the loop body... but now the var lookup has to do an OUTER lookup with each access instead.

[19:21] <timotimo> huh? perl6-bench has niecza in the nqp list. does that even make sense?

[19:22] <dalek> rakudo/nom: 2208156 | jnthn++ | src/core/CallFrame.pm:

[19:22] <dalek> rakudo/nom: Implement CallFrame.

[19:22] <dalek> rakudo/nom: 

[19:22] <dalek> rakudo/nom: Seems line number is off by one, but works otherwise. Unbusts 3 test

[19:22] <dalek> rakudo/nom: files, two of which pass in full, one with one failure.

[19:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2208156056

[19:22] <masak> lizmat: a properly optimizing compiler, and maybe we even do this already, should realize that it can re-use the memory of the pad of the last loop iteration.

[19:22] <lizmat> $ time perl6 -e 'my $a; for ^1000000 { $a = 1 }'

[19:22] <lizmat> real	0m3.515s

[19:22] <lizmat> user	0m3.052s

[19:22] *** not_gerd joined
[19:22] <lizmat> $ time perl6 -e 'for ^1000000 { my $a = 1 }'

[19:22] <lizmat> real	0m4.491s

[19:22] <lizmat> user	0m3.990s

[19:22] <masak> ok, fair enough. that's a data point I can accept. :)

[19:23] <jnthn> Walking a frame up is not costly. :)

[19:23] <lizmat> once we're there, we can fix it, but as jnthn said earlier today

[19:23] <masak> ok.

[19:23] <lizmat> it better be fast if its in the setting

[19:23] <masak> aye.

[19:23] * timotimo tries to set up perl6-bench to clone and properly make rakudo-jvm

[19:24] <lizmat> but for the life of it, I still don't understand why I can't implement "uniq" with a grep instead of gather / take

[19:24] *** dmol left
[19:24] <jnthn> lizmat: I suspect changing Nil first depends on finding places Nil is used in ways incompatible with its new meaning...

[19:25] <lizmat> ok, I'll just search for Nil and make changes   :-)

[19:25] *** vk joined
[19:25] <not_gerd> question about Int semantics: should 17 +< -3 end up as 17 +> 3?

[19:27] <masak> not_gerd: the only two reasonable semantics I can think of are: (a) what you suggest, or (b) max($rhs, 0)

[19:27] <[Coke]> If you can't trick sorear into doing shell, I may be able to, depending on how tricky java makes it.

[19:29] <not_gerd> masak: Parrot does the former with its INTVAL type (and Rakudo will do the same after I'll submit a patch), whereas Niecza does the latter

[19:31] * TimToady has put Nil outside of Any in niecza and is now testing to see if there are any regressions

[19:31] <TimToady> (but niecza does dispatch to === differently, so is perhaps less sensitive to the change)

[19:31] <lizmat> TimToady: rakduo can't make settings with Nil in Mu

[19:31] <pmurias> jnthn: if I access a non static lexical from a code refs, that is declared in a scope which hasn't been initialized yet, what should happen?

[19:32] <TimToady> lizmat: well, so far it appears that niecza can :)

[19:32] <lizmat> grrrrrrrrrr  :-)

[19:33] <masak> pmurias: Any.

[19:33] <masak> pmurias: I've managed to create a few such situations. they're fun.

[19:33] *** dmol joined
[19:34] <masak> r: class Z { method foo { my $x = 42; method bar { say $x } } }; Z.new.bar

[19:34] <camelia> rakudo f60a2c: OUTPUT«(Any)␤»

[19:34] <masak> pmurias: like that, you mean?

[19:35] * TimToady wonders if a method defined inside another routine should be considered a method on the routine rather than on the outer class...

[19:35] <benabik> That's... curious.

[19:36] <jnthn> TimToady: Ouch!!!

[19:36] <benabik> Does that code replace bar every time foo is called?

[19:36] <masak> TimToady: that's... a bit too cute...

[19:36] <masak> benabik: let's find out!

[19:36] <benabik> .oO( 1... 2... 3... *segfault* )

[19:37] <masak> r: class Z { method foo { method bar { state $x = 0; say ++$x } } }; given Z.new { .bar; .foo; .bar }

[19:37] <camelia> rakudo f60a2c: OUTPUT«1␤2␤»

[19:37] <masak> benabik: ...no.

[19:37] <jnthn> pmurias: I think it ends up doing something auto-closely...

[19:37] <jnthn> *closey

[19:37] <jnthn> Which means it gets the static lexicals

[19:37] <jnthn> Or something like that :)

[19:38] <masak> aye.

[19:38] <arnsholt> [Coke]: Continuing from #parrot, there was a blog post from one of the JRuby folks about the pains of implementing Ruby subprocess stuff on JVM

[19:38] <masak> that's what happens in the first case above.

[19:38] <benabik> r: class Z { method foo { my $x = 42; method bar { say $x } } }; my $_=Z.new; .bar; .foo; .bar

[19:38] <camelia> rakudo f60a2c: OUTPUT«Potential difficulties:␤    Redeclaration of symbol $_␤    at /tmp/YpC8rIQHNf:1␤    ------> [32mx = 42; method bar { say $x } } }; my $_[33m⏏[31m=Z.new; .bar; .foo; .bar[0m␤(Any)␤42␤»

[19:38] <jnthn> masak: No, it won't replace the method every time. Once you install something in the meta-object, it stays there. And it happens at compile time.

[19:38] <masak> benabik: you don't do 'my $_'

[19:38] <benabik> arnsholt: Ah, yes, that was what I was thinking of.

[19:38] <benabik> r: class Z { method foo { my $x = 42; method bar { say $x } } };$_=Z.new; .bar; .foo; .bar

[19:38] <camelia> rakudo f60a2c: OUTPUT«(Any)␤42␤»

[19:38] <masak> jnthn: right.

[19:38] <masak> jnthn: that makes a whole lot of sense.

[19:39] <benabik> That one confuses me.  Does it just reassign the outer context of bar every time foo is called?

[19:39] * jnthn kills the "Too late to set file handle encoding" error

[19:39] <arnsholt> benabik: Might be, yeah

[19:40] <jnthn> benabik: Think that's what it does at the moment, at least.

[19:40] <benabik> n: class Z { method foo { my $x = 42; method bar { say $x } } };$_=Z.new; .bar; .foo; .bar

[19:40] <camelia> niecza v24-86-g39ab531: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Methods must be used in some kind of package at /tmp/wqxyqrjm2F line 1:␤------> [32mZ { method foo { my $x = 42; method bar [33m⏏[31m{ say $x } } };$_=Z.new; .bar; .foo; .ba[0m␤␤Unhandled exception: Check failed␤␤  at /h…

[19:40] <benabik> Well, niecza's response is unsurprising at least.  :-)

[19:41] <jnthn> In Rakudo, the current package is $*PACKAGE, so it really doesn't care what your nesting level is :)

[19:41] <lizmat> jnthn: I think I have the pb golfed down:

[19:41] <lizmat> $ perl6 -e 'sub a { say @_ }; a(Nil)'

[19:41] <lizmat> ===SORRY!===

[19:41] <lizmat> Odd number of elements found where hash expected

[19:41] <jnthn> (at compile time, that is)

[19:41] <jnthn> lizmat: If the setting won't start, doesn't everything fail with that? :)

[19:41] <jnthn> r: sub a { say @_ }; a(Nil)

[19:41] <camelia> rakudo f60a2c: OUTPUT«␤»

[19:42] <TimToady> looks like that wants to be () rather than Nil

[19:42] <lizmat> but there are many places in the setting where Nil is passed as a parameter

[19:43] <TimToady> which if fine as an item, but not fine when it wants to mean ()

[19:43] <lizmat> something like: nqp::ifnull($coro($block), Nil);

[19:44] <lizmat> or: my $parcel :=  &RETURN-PARCEL(nqp::p6parcel(nqp::p6argvmarray(), Nil));

[19:45] <masak> r: class Z { method x { my $x = "a man"; say $x; method y { my $y = "with a plan"; say "$x $y"; method z { my $z = "for a canal"; say "$x $y $z" } } } }; given Z.new { .x; .y; .z }

[19:45] <camelia> rakudo f60a2c: OUTPUT«a man␤a man with a plan␤a man with a plan for a canal␤»

[19:45] <masak> :D

[19:46] <pmurias> masak: yes

[19:46] <lizmat> or: THROW(Nil, nqp::const::CONTROL_PROCEED)

[19:46] <jnthn> r: say "amanaplanacanalpanama".flip # :P

[19:46] <camelia> rakudo f60a2c: OUTPUT«amanaplanacanalpanama␤»

[19:46] <timotimo> hm, the lack of make install is turning out to be a little obstacle.

[19:46] <pmurias> jnthn,masak: shouldn't that be an error?

[19:48] <jnthn> pmurias: What about it are you thinking should be one?

[19:48] *** gudahtt joined
[19:50] <masak> I also don't follow.

[19:51] <dalek> nqp: f8409e7 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/ (2 files):

[19:51] <dalek> nqp: Fix spurious "too late to set encoding" errors.

[19:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f8409e771e

[19:51] <masak> the nearest thing we have to "the lexpad of this slot was never even incarnated!" is... "(Any)"

[19:51] <not_gerd> TimToady: FROGGS and me are currently implementing numeric shift of Int with two's complement semantics (but generalized to arbitrary precision)

[19:51] <not_gerd> shifty by negative amount end up as shifts in opposite direction

[19:52] <not_gerd> should that be spec?

[19:52] <masak> r: for ^0 { my $x = 42; our sub foo { say $x } }; our &foo; foo()

[19:52] <camelia> rakudo f60a2c: OUTPUT«No such method 'Any' for invocant of type 'Parcel'␤  in block  at /tmp/0Pv3NsZCbd:1␤␤»

[19:52] <masak> hrm.

[19:52] <masak> r: for ^1 { my $x = 42; our sub foo { say $x } }; our &foo; foo()

[19:52] <camelia> rakudo f60a2c: OUTPUT«No such method 'Any' for invocant of type 'Parcel'␤  in block  at /tmp/Iqu1jPs7PZ:1␤␤»

[19:53] <timotimo> ooooh! good one, jnthn. does that make open/slurp/... work?

[19:53] <masak> seems to me 'our' grows more useless by the month.

[19:53] <jnthn> timotimo: Yes, slurp now works :)

[19:53] <jnthn> Except the Buf case

[19:53] <timotimo> that's pretty excellent! :)

[19:54] <not_gerd> TimToady: Rakudo used to implement sign-magnitude semantics, and Niecza uses C# semantics (with 32-bit overflow weirdness)

[19:54] *** kaare_ left
[19:55] <pmurias> jnthn: accessing a non existing variable

[19:55] *** stevan_ joined
[19:57] <jnthn> pmurias: Variable declarations are compile time, so it must at some level exist.

[19:58] <timotimo> i'm amused that the latest rakudo commit has 0815 in the first few hex-characters

[19:59] <timotimo> (and is otherwise digit-only for quite a bit)

[20:00] <masak> pmurias: what jnthn said. you essentially can't "fall out into the void". the worst thing that can ever happen is that you get a static lexpad.

[20:01] <timotimo> it seems like perl6-bench doesn't have a way to do cd at all in the build steps :o

[20:02] <Ulti> huwah http://www.rakudo.com

[20:02] <Ulti> o___O

[20:02] <timotimo> tee hee

[20:05] <Util> Thank you, to all who worked on /$re/ above. The <X=$re> and /$0=<$re>/ alternatives are both very helpful for my code today.

[20:05] <Util> Still, this leaves me worried. In Perl 5, a simple swap of a long inline /RE/ for /$re/ is a common use case.

[20:05] <Util> Do I understand correctly, that to do such a swap in Perl 6, one must either (a) rework the RE into a grammar (so <alpha> works),

[20:05] <Util> or (b) rework every access of a captured datum (e.g. $1 becomes $0.[1]) ?

[20:06] <lue> hello world o/

[20:06] <masak> I'm also surprised at whatever rule makes it not a clean substitution.

[20:06] <masak> seems to work against refactorability.

[20:07] <Util> masak: Yes, exactly

[20:07] *** stevan_ left
[20:07] <jnthn> Does anybody happen to know where derived unicode char properties like ASCIIHexDigit or IDSBinaryOperator are defined?

[20:08] <jnthn> Whenever I search for them, I find the Perl manpages :P

[20:09] <benabik> jnthn: ftp://www.unicode.org/Public/3.2-Update/DerivedProperties-3.2.0.html ?

[20:09] <benabik> No, that wasn't the right page.  I think they name it something odd.

[20:10] <jnthn> Yeah, already found that one. It doesn't contain the stuff properties-derived.t is testing.

[20:10] <benabik> I seem to remember a goodly-sized table on the unicode site with that stuff.

[20:11] *** stevan_ joined
[20:12] *** sftp left
[20:12] <jnthn> aha... http://www.unicode.org/Public/UNIDATA/PropList.txt

[20:13] *** sftp joined
[20:13] <Util> jnthn: Yes, PropList.txt is copied whole-cloth into Perl 5's lib/unicore/

[20:14] <[Coke]> ew.

[20:16] <timotimo> oh wow, i'm getting a segfault in the jvm while building stage1/gen/QAST.nqp

[20:16] <timotimo> JRE version: 7.0_21-b02 - that *is* new enough, yeah?

[20:17] <jnthn> update 21 is typically good :S

[20:17] <timotimo> huh, now it's getting past that

[20:17] <timotimo> should i be worried about my hardware?

[20:17] <[Coke]> jnthn: how evil will it be if we need to use JNI to implement shell() ?

[20:18] <timotimo> anyway, it seems like my efforts to put rakudo-jvm into perl6-bench are going to bear fruit

[20:19] *** bruges_ joined
[20:20] <jnthn> [Coke]: Sounds...evil.

[20:21] *** bruges left
[20:22] <pmurias> masak: I understand why that currently works, what I'm worried about is that something that we want to work, that is isn't that just masking an error?

[20:22] * timotimo benchmarks rakudo-jvm with japhb++ 's perl6-bench

[20:25] <masak> pmurias: your sentence does not fully parse for me.

[20:25] <masak> pmurias: yes, of course it is -- quite literally -- masking an error.

[20:26] *** Moukeddar joined
[20:26] <masak> pmurias: what I'm saying is that I prefer an "(Any)" in such a scenario to a Null PMC access.

[20:26] <masak> which was very much the norm in the pre-nom days.

[20:26] <masak> (or was it pre-b? I forget.)

[20:26] *** spider-mario left
[20:26] *** vk left
[20:27] <pmurias> retyped sentence: I understand why that currently works. What I'm worried about, is that something that we want to work? Isn't that just masking an error?

[20:27] <pmurias> masak: wouldn't an exception be even better?

[20:28] <masak> I dunno -- I think I've made peace with static lexpads.

[20:28] <masak> so I don't really see it as "we're hiding an error", even.

[20:28] <masak> just a very wacky case of "oops, you didn't properly initialize that variable! well, here you go, have an (Any)."

[20:28] <Moukeddar> o/ #perl6

[20:28] <Moukeddar> o/ masak

[20:29] <masak> Moukeddar! \o/

[20:29] <Moukeddar> miss you guys 

[20:30] <masak> if you were here more often, maybe you'd contribute to Perl 6 -- so we miss you too, I guess ;)

[20:30] <pmurias> masak: and what about assignment?

[20:31] <masak> pmurias: you can't assign to the static lexpad.

[20:31] <masak> it's static.

[20:32] *** dmol left
[20:33] <benabik> r: class Z { method foo { my $x = 0; method bar { $x = 1; say $x } } }; given Z.new { .bar; .foo; .bar }

[20:33] <camelia> rakudo 220815: OUTPUT«1␤1␤»

[20:33] <benabik> :-/

[20:34] <benabik> r: class Z { method foo { my $x = 0; method bar { print $x; $x = 1; say $x } } }; given Z.new { .bar; .foo; .bar }

[20:34] <camelia> rakudo 220815: OUTPUT«use of uninitialized value of type Any in string context  in method bar at /tmp/Wzs8sJnda_:1␤␤1␤01␤»

[20:34] *** stevan_ left
[20:34] <benabik> Oh, yes.  say ≠ print + "\n"

[20:34] <masak> no surprises there.

[20:34] <benabik> r: class Z { method foo { my $x = 0; method bar { say $x; $x = 1; say $x } } }; given Z.new { .bar; .foo; .bar }

[20:34] <camelia> rakudo 220815: OUTPUT«(Any)␤1␤0␤1␤»

[20:35] <timotimo> such a benchmark run is taking quite a lot of time! i hope i didn't do anything terribly wrong and waste all that time ...

[20:35] <benabik> masak: Is that not assigning to the static lexpad?

[20:36] <masak> benabik: no.

[20:36] <masak> benabik: what's static about it?

[20:36] <masak> or, hm.

[20:36] <masak> yes, I see what you mean.

[20:36] <jnthn> Note that static lexpad points to a scalar container

[20:37] <jnthn> Which itself is, well, a container. :)

[20:37] <masak> ok, so it all works out :)

[20:37] *** cognominal left
[20:37] *** drbean left
[20:37] *** lee_ left
[20:41] *** dmol joined
[20:42] *** cognominal joined
[20:42] *** drbean joined
[20:42] *** lee_ joined
[20:43] *** Drone[02] joined
[20:43] *** konundra left
[20:44] <Ulti> is there a way to use multi dispatch in a junction sort of way, so if I have for example  multi sub factorial (0|1) {1}  rather than factorial (0) {1} and factorial (1) {1}

[20:45] <jnthn> $ where 0|1 probably works

[20:45] <Ulti> aha 

[20:46] <benabik> Does multi foo(0|1) only get called via foo(0|1)?

[20:46] <Ulti> that's starting to feel like being clever for clever's sake rather than elegance though

[20:46] <Ulti> benabik it causes a parse error atm

[20:46] <Ulti> "Missing block"

[20:46] <benabik> ah

[20:47] <Ulti> but yeah that's what I was thinking its a junction literal, so kind of creates a quirky exception to the rule if it worked how I wanted

[20:48] <benabik> Depends on how literals in multi sigs match.  If they're smart matched, it would make perfect sense.

[20:48] <dalek> nqp: 324f6eb | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[20:48] <dalek> nqp: Handle a bunch of the derived properties.

[20:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/324f6eb168

[20:48] <Ulti> jnthn: that worked :)

[20:49] *** sdo joined
[20:49] <sdo> hello

[20:49] <masak> sdo: hello.

[20:49] <sdo> masak: hello

[20:49] <sdo> :)

[20:49] <masak> hello. :)

[20:49] * masak peers out of the web browser at sdo

[20:49] <jnthn> .oO( is this IRC or an SMTP handshake? )

[20:49] <timotimo> jnthn: that really ought to have been a binary search ;)

[20:50] <jnthn> timotimo: Not entirely sure it's worth it :)

[20:50] <sdo> Is there a difference wetween my $a=1; and my $b:=2; ?

[20:50] <[Coke]> NAK

[20:50] <Ulti> hmm though I think I'd have to do   Int $ where 0|1 to make sure the Int type is enforced, since it was implied with the literal value before

[20:50] <labster> hello?

[20:50] <sdo> Is there a difference between my $a=1; and my $b:=2; ?

[20:50] <timotimo> jnthn: not sure if it's ever not worth it, but what do i know about the jvm?

[20:50] <sdo> sorry about that

[20:50] <masak> sdo: yes, assignment and binding are different.

[20:50] <timotimo> perl6: my $a := 1; $a++; say $a;

[20:50] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/1YR5z5KSFU line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /home/p6eval/niecza/li…

[20:50] <camelia> ..rakudo 220815: OUTPUT«Cannot modify an immutable value␤  in sub postfix:<++> at src/gen/CORE.setting:3613␤  in sub postfix:<++> at src/gen/CORE.setting:2064␤  in block  at /tmp/QsYyem6Maq:1␤␤»

[20:50] <timotimo> perl6: my $a  = 1; $a++; say $a;

[20:50] <camelia> rakudo 220815, niecza v24-86-g39ab531: OUTPUT«2␤»

[20:50] <masak> what timotimo said.

[20:50] <jnthn> timotimo: It may be more efficient, but otoh the lists of numbers ain't that long.

[20:51] <timotimo> the last one is pretty huge

[20:51] <masak> sdo: it's the different between assignment's "here, let's put this value in this container pointed to by this variable" and bindings "here, let's *bind* this variable directly to this value"

[20:52] <jnthn> Unfortunately, this still doesn't quite nail properties-derived.t 

[20:52] <sdo> yes I guess it is kinda constant then.?

[20:52] <timotimo> but a few tests now pass, right?

[20:53] <jnthn> Gets us to 204 out of 256 though...

[20:53] <timotimo> sounds great! it was 0 before?

[20:53] <masak> sdo: yes. they fill different purposes.

[20:53] <jnthn> timotimo: yeah

[20:53] <masak> sdo: binding is the "unusual" one. but it turns up in routine signatures, for example.

[20:53] <sdo> masak: thanx a lot

[20:53] <[Coke]> timotimo: https://github.com/coke/perl6-roast-data/blob/master/rakudo.jvm_summary.out#L661

[20:53] <masak> sdo: yw

[20:54] <masak> you'll find we're helpful here ;)

[20:54] <timotimo> awesome! :)

[20:54] <masak> and a bit funny... :)

[20:54] <jnthn> Though of the non-skipped just need Math, ID_Start and ID_Continue

[20:55] *** sdo left
[20:57] *** skids left
[20:58] <TimToady> masak: the P5ish refactoring of regexen via variables depends crucially on the misfeature of treating regexes as strings.  In P6 this would be more in the province of textual macros.

[20:58] <timotimo> does turning $foo++ into ++$foo if the previous value was never used make sense as an optimization at the QAST level?

[20:59] <TimToady> what, he want to know sink context at *compile* time?  horrors...

[20:59] <timotimo> oh, sink context ...

[21:00] <TimToady> P5 does precisely that optimization

[21:00] <TimToady> only, of course, it's called void context there :)

[21:00] <timotimo> i thought it might be enough to check if the var that gets created to hold the temporary value gets used somewhere

[21:00] <timotimo> but yeah ...

[21:05] <dalek> nqp: 56e602e | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[21:05] <dalek> nqp: The rest we need for properties-derived.t.

[21:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/56e602e254

[21:05] <jnthn> OK, there's one more test file :)

[21:06] <nwc10> what were the most recent numbers for passing? and how many hours out of date are they? :-)

[21:07] <jnthn> The last run was before any of my work this evening.

[21:08] <[Coke]> I will probably not be updating anything else this evening.

[21:08] <jnthn> That's fine :)

[21:08] <[Coke]> but I am about to hit a 4 day weekend, which hopefully will have some hacking time.

[21:08] *** sdo joined
[21:08] <[Coke]> >> commute

[21:08] <jnthn> o/

[21:08] <jnthn> nwc10: grr, getting timeouts from github, so can't tell you the number :(

[21:09] <sdo> hello all my apologies for being rude with you :-(

[21:09] <timotimo> i had them open a few moments ago; it was like 92.58% or something

[21:09] <lizmat> 92.55%

[21:09] <jnthn> There we go.

[21:09] <timotimo> and both rakudo and rakudo-jvm went up ~100 tests since yesterday

[21:09] <lizmat> my make spectest is hanging on github

[21:09] <timotimo> 160?

[21:09] <TimToady> not_gerd: yes, negative shifts should probably be spec

[21:10] <tadzik> masak: something for you: https://twitter.com/brucel/status/352398305113817088

[21:10] *** benabik left
[21:10] <colomon> lizmat: I'm having trouble with github as well

[21:11] <masak> tadzik: hehe.

[21:11] <masak> tadzik: not an autopun, though. just a pun. :)

[21:12] <timotimo> just 9 benchmarks to go until i have some results for rakudo-jvm ... and then i'll need to do rakudo.parrot to compare :|

[21:12] <jnthn> tadzik: lol!

[21:12] *** sdo left
[21:12] <lizmat> (spectest running now after timeout)

[21:12] <jnthn> masak: Not an autopun, but I have no beef with it :P

[21:12] <tadzik> masak: yep :)

[21:12] <timotimo> "We are currently investigating problems accessing a number of GitHub services. We will update with more information as soon as we have it.

[21:15] <masak> tadzik: I'm smiling because I'm imagining that tweet being read to me in your amused voice, though :)

[21:15] <colomon> git pull just worked for me.

[21:16] <timotimo> The sites appear to have recovered from an upstream network outage. We will keep this status event open while we continue to investigate.

[21:16] <tadzik> :D

[21:16] <timotimo> okay, now that slurp and probably a few other open related things work ... how long until panda? tadzik? :)

[21:17] * masak .oO( "we have panda minus two days, three hours, thirty minutes" )

[21:17] <Ulti> how do you define the precedence of your own operators?

[21:17] <jnthn> is prec(...)

[21:17] <Ulti> thanks

[21:17] <jnthn> Or is tighter/is looser/is equiv is more convenient.

[21:17] <Ulti> take it thats not in S03 :S

[21:18] <masak> I would recommend the latter.

[21:18] <jnthn> S06 iirc

[21:18] <Ulti> k k

[21:18] * Ulti reads

[21:18] <Ulti> cool thanks

[21:18] <Ulti> this is easily becoming the most convoluted implementation of factorial :/

[21:19] <jnthn> r: sub postfix:<!>($n) { [*] 1..$n }; say 10!

[21:19] <jnthn> :P

[21:19] <camelia> rakudo 220815: OUTPUT«3628800␤»

[21:19] <tadzik> timotimo: how long until panda what? :)

[21:19] <tadzik> I know, I know

[21:19] <tadzik> I plan to take a Free Friday, so I may do some hacking

[21:19] <masak> r: sub p { [*] 1..$^n }; say p 10

[21:19] <camelia> rakudo 220815: OUTPUT«3628800␤»

[21:20] <lizmat> jnthn: it seems that .pop needs to be "is rw" because of .unshift: nqp::unshift($!items, @elems.pop)

[21:20] <lizmat> would it make sense to fix that, if so how?

[21:20] <timotimo> Useless use of "+" in expression "$i + $j" in sink context (lines 1, 1, 1, 1) - oh my

[21:21] <timotimo> ah

[21:21] <timotimo> yes, indeed

[21:21] <timotimo> is there a form of # OK that i can put in -e properly?

[21:22] <jnthn> lizmat: Why does that require it to be "is rw"?

[21:22] <lizmat> let me put it this way: if .pop is not marked "is rw", any unshifted values are ro

[21:22] <jnthn> r: my @a = 1,2,3; my @b; @b.unshift(@a); say @a; say @b;

[21:22] <camelia> rakudo 220815: OUTPUT«1 2 3␤1 2 3␤»

[21:23] <jnthn> r: my @a = 1,2,3; my @b; @b.unshift(@a); @a[2] = 4; say @a; say @b;

[21:23] <camelia> rakudo 220815: OUTPUT«1 2 4␤1 2 3␤»

[21:23] <jnthn> *phew*

[21:23] *** stevan_ joined
[21:24] <lizmat> indeed, that;s because I didn't commit the change yet

[21:24] <jnthn> lizmat: oh, I guess it's relying on .pop making containers for the things that get shoved into $!item

[21:24] <lizmat> yup

[21:24] <masak> that just feels like wrong reasoning to me.

[21:24] <colomon> +1

[21:24] <masak> for some reason.

[21:24] <jnthn> masak: What is?

[21:25] <masak> "because unshift" but it's not because of unshift.

[21:25] <masak> I'm not criticizing lizmat++ by the way. only the previous reasoning that led someone to believe unshift was involved.

[21:26] <jnthn> masak: unshift relies on .pop returning something with a scalar container; if .pop doesn't do that, unshift needs tweaking.

[21:26] <lizmat> no, unshift is relying on the "is rw" behavior of .pop

[21:26] <masak> r: my @a; @a.unshift(5); @a[0] = 77; say @a.perl

[21:26] <camelia> rakudo 220815: OUTPUT«Array.new(77)␤»

[21:26] <jnthn> masak: I'm not saying pop is the way it is because of unshift, just that unshift has a dependency on the way pop currently is.

[21:26] <masak> there, I just unshifted something decontainerized, no?

[21:27] <masak> it works.

[21:27] <lizmat> not if you take away "is rw" ffrom .pop

[21:27] <jnthn> multi method unshift(List:D: *@elems) {

[21:27] <masak> lizmat: I didn't even use pop!

[21:27] <masak> I just unshifted a 5

[21:27] <lizmat> you did, because unshift uses that

[21:27] <jnthn> masak: The IMPLEMENTATION of unshift uses .pop

[21:27] <masak> oh!

[21:27] <masak> ok, now I'm with you.

[21:27] <jnthn> :)

[21:27] <lizmat> *phew*  :-)

[21:28] <masak> why the heck does unshift use pop?! :)

[21:28] <jnthn>         while @elems {

[21:28] <jnthn>             nqp::unshift($!items, @elems.pop)

[21:28] <jnthn>         }

[21:28] <colomon> and doesn't just use .pop, but requires a weird version of .pop

[21:28] <masak> unshift and pop seem equally primitive to me.

[21:28] <jnthn> It's 'cus you can unshift multiple items.

[21:28] <masak> right. *that's* what's wrong.

[21:28] <masak> what colomon said.

[21:28] <jnthn> Note it's a slurpy.

[21:28] <jnthn> Yeah

[21:29] <masak> if unshift is the only thing that wants pop to be 'is rw', then unshift is weird and wrong.

[21:29] <lizmat> so far, that seems the only place

[21:29] <jnthn> Note that shift is also marked as "is rw"

[21:29] <jnthn> So it's not a weird accident just for pop.

[21:29] <colomon> what about something like for @elems.reverse { nap::unshift($!items, $_) } ?

[21:30] <timotimo> aaw, i get some stack overflow errors in the benchmarking and rc-forest-fire is dieing from not being able to call Numeric on something (perhaps in the MAIN?)

[21:30] *** konundra joined
[21:30] <masak> colomon: looks much saner to me.

[21:31] <jnthn> r: my @a = 1,2,3; my $x := @a.shift; $x = 4; say $x; say @a;

[21:31] <camelia> rakudo 220815: OUTPUT«4␤2 3␤»

[21:31] <jnthn> Does the spec rule either way on the above?

[21:31] <lizmat> r: my @a=1,2,3; my $b= @a.pop = 4; say $b

[21:31] <camelia> rakudo 220815: OUTPUT«4␤»

[21:31] *** Rotwang left
[21:31] *** PacoAir left
[21:31] <lizmat> r: my @a=1,2,3; my $b= @a.pop = 4; say $b; say @a

[21:31] <camelia> rakudo 220815: OUTPUT«4␤1 2␤»

[21:32] <jnthn> If we're gonna go changing pop, we'd better change shift too...

[21:32] <lizmat> doing some tests now

[21:32] <jnthn> TimToady: Opinion? :)

[21:32] <dalek> roast: c39a7ca | (Brent Laabs)++ | S (2 files):

[21:32] <dalek> roast: add canonpath :parent tests for unix

[21:32] <dalek> roast: review: https://github.com/perl6/roast/commit/c39a7ca340

[21:34] <lizmat> jnthn: wouldn't nqp::pop() as an alternative to .pop be sufficient ?

[21:34] <lizmat> fg

[21:35] <lizmat> oops, ww

[21:35] <jnthn> lizmat: No, 'cus we have a Perl 6 array

[21:37] <colomon> Trying to think like TimToady: why just shift and pop?

[21:37] *** census joined
[21:37] <masak> census! \o/

[21:38] <census> hi masak! :)

[21:38] <census> thanks for the friendly greeting :)

[21:38] <colomon> r: my @a = 1,2,3; my $x := @a.first(* %% 2); $x = 4;

[21:38] *** pmurias left
[21:38] <camelia> rakudo 220815: OUTPUT«Cannot assign to a readonly variable or a value␤  in block  at /tmp/ZPjiZIbKd5:1␤␤»

[21:39] <colomon> r: my @a = 1,2,3; my $x := @a.pop; $x = 4;

[21:39] <camelia> rakudo 220815:  ( no output )

[21:41] *** dmol left
[21:41] <masak> colomon: right. good one.

[21:41] <masak> I'd expect, intuitively, the .pop case to be equally as wrong as the .first case.

[21:42] <colomon> n: my @a = 1,2,3; my $x := @a.pop; $x = 4;

[21:42] <camelia> niecza v24-86-g39ab531:  ( no output )

[21:42] <colomon> n: my @a = 1,2,3; my $x := @a.first(* %% 2); $x = 4;

[21:42] <camelia> niecza v24-86-g39ab531:  ( no output )

[21:42] <colomon> on niecza it works in either case, I guess.  

[21:45] <colomon> hmm

[21:45] <colomon> rn: my $x := 4; $x = 5; say $x

[21:45] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/qOAoZOVLFn line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /home/p6eval/niecza/li…

[21:45] <camelia> ..rakudo 220815: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/eOH3POeSPr:1␤␤»

[21:51] *** btyler_ joined
[21:54] *** btyler left
[21:54] <lizmat> running spectest with a fix for .unshift

[21:54] <colomon> my test run just now shows an additional 220 tests passing since my last run 19 hours ago.  that actually sounds low to me...

[21:56] <colomon> hmmm… 169 passing tests from S05-mass/properties-derived.t.  Maybe it is right.

[21:56] <lizmat> I've added some tests for squish(), but that really shouldn't make that much of a difference

[21:56] *** BooK left
[21:56] *** bluescreen10 left
[21:56] <colomon> ah, lots of skips in S05-mass/properties-derived.t

[21:59] *** berekuk left
[22:01] *** berekuk joined
[22:01] *** dmol joined
[22:03] *** rindolf left
[22:08] *** pochi left
[22:08] *** pochi joined
[22:15] *** tomyan joined
[22:16] *** tomyan left
[22:19] <lizmat> what are the thoughts of unshifting or pushing an infinite list to an array?

[22:20] <lizmat> should that work assuming the reificiation will stop at some point?

[22:20] <masak> I don't see anything wrong with it.

[22:20] <timotimo> i made a comparison of perl5, rakudo and rakudo-jvm based on japhb's test suite

[22:20] <timotimo> er benchmark suite

[22:20] <masak> except that you'll never be able to .gimme the .push'd things because they are after infinitely many other things.

[22:21] <lizmat> masak: so it's ok that a program hangs until it has eaten all of memory?

[22:21] <masak> but that's a minor detail.

[22:21] <masak> lizmat: oh, I was assuming a model that doesn't hang on just pushing to an infinite list.

[22:21] <lizmat> r: my @a; @a.unshift( 1..Inf )  # is what I'm talking about

[22:21] <masak> doesn't look obviously hanging to me.

[22:21] <camelia> rakudo 220815: OUTPUT«(timeout)»

[22:22] <lizmat> (it does)  :-)

[22:22] <masak> sure, but that's just by current implementation.

[22:22] <masak> lizmat: you know as well as anyone that preventing all such hangs is a fool's errand. :)

[22:22] *** Moukeddar left
[22:23] <lizmat> I'm just thinking the obvious ones

[22:23] <masak> that's probably fine.

[22:23] <masak> but again, I don't see why .unshift( 1..Inf ) would be automatically outlawed.

[22:25] * timotimo throws nqp and nqp-jvm into the mix of benchmarked things

[22:25] <TimToady> a couple years ago we decided that push had to be eager or it would violate the expectations of P5 programmers

[22:25] *** Radvendii joined
[22:25] <TimToady> that's why there's supposed to be a .plan that is not eager

[22:25] <masak> right, but this is about pushing an infinite list, not pushing *to* an infinite list.

[22:26] <masak> but maybe that's what you mean, too. hm.

[22:27] <lizmat> r: my @a=1..Inf; push @a, 1 # teh latter is already outlawed

[22:27] <camelia> rakudo 220815: OUTPUT«Cannot .push to an infinite list␤current instr.: 'throw' pc 367293 (src/gen/CORE.setting.pir:158222) (src/gen/CORE.setting:9211)␤called from Sub 'sink' pc 400882 (src/gen/CORE.setting.pir:171118) (src/gen/CORE.setting:10496)␤called from Sub 'MAIN' pc 396 (src/gen/p…

[22:27] <lizmat> r: my @a; @a.push( 1.. Inf ) # should this fail in a similar manner?

[22:27] <jnthn> timotimo: Results anywhere?

[22:28] <camelia> rakudo 220815: OUTPUT«(timeout)»

[22:28] <timotimo> jnthn: i can surely upload the current results, hold on

[22:30] <colomon> TimToady: @a.plan is like @a.push but just adds the iterator it is passed to the end of @a's iterator, or something along those lines?

[22:30] <timotimo> http://t.h8.lv/p6bench/p5-rp-rj.html - there you go

[22:32] <timotimo> in a tight loop in NQP, wouldn't nqp::push(@a, $i) be a couple times faster than @a.push: $i?

[22:32] <timotimo> er, @a.push($i) rather

[22:33] <lizmat> timotimo: does nqp::push now about infinite arrays ?

[22:34] <masak> lizmat: the thing with outlawing the obvious cases is -- well, now you've forbidden something that is obviously stupid.

[22:34] <masak> lizmat: the subtly stupid things are still allowed.

[22:35] <jnthn> timotimo: yes

[22:35] <timotimo> i wonder if i should change the microbenchmark in japhb's perl6-bench suite to reflect that?

[22:35] <jnthn> timotimo: uh, I mean, thanks :)

[22:35] <dalek> nqp: 0ed0a48 | (Gerhard R)++ | src/vm/parrot/ops/nqp_bigint.ops:

[22:35] <dalek> nqp: Unify shift ops. Shifting by negative amounts flips direction.

[22:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0ed0a489b7

[22:35] <lizmat> so, is it the overhead of the extra check that you're worried about?  letting all suffer for those few dumbo's that might do something wrong ?

[22:35] <jnthn> oh wait, I meant yes too :)

[22:36] <jnthn> hah )

[22:36] <timotimo> :)

[22:36] <masak> lizmat: well, no, because it could be a compile-time check.

[22:36] <masak> lizmat: I'm just saying that while it'd be useful, it would have a very restricted use.

[22:36] <masak> lizmat: a bit like "oh, you tried to divide by the constant 0 here. that's not possible!"

[22:37] <lizmat> not really, as that will bomb immediately

[22:37] <masak> (which gets a little better with constant folding, granted, but I don't see constant folding giving us infinite lists to the same degree)

[22:37] <dalek> roast: 4c4395d | (Gerhard R)++ | S03-operators/numeric-shift.t:

[22:37] <dalek> roast: Check numeric shifts for two's complement semantics.

[22:37] <dalek> roast: review: https://github.com/perl6/roast/commit/4c4395de98

[22:37] <lizmat> these cases will eat up all resources that they can

[22:38] <masak> I guess what I'm saying is I don't know exactly what windmill it is you're trying to topple here, and why.

[22:38] *** xilo_ left
[22:38] <lizmat> well, I'm not sure anymore either: I just found some checks for infinite lists in the pop/push/shift/unshift area

[22:39] <lizmat> and realised there were 2 checks missing in the unshift/push case

[22:39] <lizmat> BTW: t/spec/S16-unfiled/rebindstdhandles.t seems to be failing now, unrelated to my changes afaics

[22:40] <lizmat> seems jnthn's last commit is to blame ?

[22:40] *** snoopy left
[22:41] *** not_gerd left
[22:41] <jnthn> lizmat: My last commit? Implementing CallFrame support for JVM? 

[22:41] <lizmat> ok, then it was my code, doublechecking

[22:41] <jnthn> I mean, it's possible, just feels...weird. :)

[22:42] <lizmat> Cannot use bind operator with this left-hand side

[22:42] <Radvendii> hey, sorry to bother y'all, but I have a question that doesn't appear to be answered online

[22:43] <Radvendii> can I disable necesity of declaring variables? I want to type '$var="foo"' without the 'my

[22:43] <Radvendii> '

[22:44] <lizmat> seems labster uncommented the fudge for that error today

[22:44] <masak> Radvendii: I believe Niecza supports that.

[22:44] <masak> n: 6; $var = 'foo'; say $var

[22:44] <camelia> niecza v24-86-g39ab531: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $var is not predeclared at /tmp/SlGEgHd7IP line 1:␤------> [32m6; [33m⏏[31m$var = 'foo'; say $var[0m␤␤Variable $var is not predeclared at /tmp/SlGEgHd7IP line 1:␤------> [32m6; $var = 'foo'; say [33m⏏[31m$var…

[22:44] <jnthn> Rakudo doesn't; I guess it's "no strict;" though.

[22:45] <masak> n: no strict; $var = 'foo'; say $var

[22:45] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <file…

[22:45] <masak> huh.

[22:45] <lizmat> no strict is NYI , isn''t it ?

[22:45] <jnthn> lizmat: In Rakudo it's NYI. I thought Niecza had it...

[22:45] <lizmat> .oO{ triple negation, wow}

[22:45] <masak> ISTR Niecza had it at some point...

[22:46] <Radvendii> Okay... I guess I'll wait for it. Funny though "no" is supposed to be *not* including a module. I would expect no strict to be implemented before use strict...

[22:46] <timotimo> http://t.h8.lv/p6bench/p5-rp-rj-np.html <- added nqp-parrot, nqp-jvm coming up some time after that

[22:48] <timotimo> (this is before the nqp::push replacement was made)

[22:48] <labster> oh, sorry about rebindstdhandles.t, that was a git thinko

[22:48] <dalek> roast: 6ef8223 | (Elizabeth Mattijsen)++ | S16-unfiled/rebindstdhandles.t:

[22:48] <dalek> roast: Restore fudge for binding to $:ERR

[22:48] <dalek> roast: review: https://github.com/perl6/roast/commit/6ef82236ba

[22:48] <masak> Radvendii: it's historical reasons. 'use strict' needs to be switched on in Perl 5. in Perl 6 it's "on by default".

[22:49] <lizmat> labster: ok, it just threw me off for a bit

[22:50] <Radvendii> masak: okay, thanks.

[22:50] <masak> 'night, #perl6

[22:50] <lizmat> night masak!

[22:50] <timotimo> night masak!

[22:51] <labster> night masak!!

[22:51] *** BenGoldberg joined
[22:51] <dalek> rakudo/nom: 25e2f6b | (Elizabeth Mattijsen)++ | src/core/List.pm:

[22:51] <dalek> rakudo/nom: Add some checks for dumbo's trying to unshift/push infinite lists

[22:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25e2f6b974

[22:54] *** Radvendii left
[22:58] <lizmat> goodnight #perl6!   sleep&

[22:58] <jnthn> Think I'll get some rest also. 'night, #perl6

[23:00] <timotimo> aaw

[23:00] <timotimo> was just about to post the results with nqp-jvm thrown into the mix

[23:01] <timotimo> (doing forest fire right now)

[23:02] *** BooK joined
[23:04] <timotimo> http://t.h8.lv/p6bench/p5-rp-rj-np-nj.html - here we go. benchmarks with rakudo-{parrot,jvm}, nqp-{parrot,jvm} and perl5

[23:09] *** Khisanth left
[23:15] <timotimo> http://t.h8.lv/p6bench/nqppush_fixed.html - this is with @a.push replaced with nqp::push(@a...) in the nqp microbenchmarks "while_push" and "while_push_join"

[23:16] <timotimo> the difference is noticable.

[23:18] <labster> It looks like P6 on most of these tasks are only O(100) times slower than P5 now.

[23:20] <timotimo> hm ... hooray?

[23:20] <timotimo> it is pretty cool that nqp-jvm beats perl5 at forest fire at the very highest number of iterations

[23:21] *** ajr_ left
[23:23] *** census left
[23:23] *** Khisanth joined
[23:23] <timotimo> ah, the forest fire might suffer from use of junctions

[23:25] <timotimo> nope, that's not it.

[23:27] <timotimo> hm, is === faster than == when comparing items from an enum?

[23:33] *** dmol left
[23:39] *** pochi left
[23:40] *** arnsholt left
[23:40] *** arnsholt joined
[23:41] * timotimo is not able to get faster code out of the forest fire

[23:42] <timotimo> or maybe i *am*!

[23:42] *** Chillance left
[23:43] *** Woodi left
[23:43] *** Woodi joined
[23:44] *** ajr joined
[23:44] *** ajr is now known as Guest39241

[23:44] *** frettled left
[23:45] *** frettled joined
[23:46] *** pochi joined
[23:46] *** Guest39241 left
[23:46] <timotimo> nope. nothing i can do here :|

[23:49] *** Chillance joined
[23:58] *** btyler_ left
[23:59] *** xilo_ joined
