[00:08] *** pmurias left
[00:16] *** FROGGS left
[00:17] *** raiph left
[00:19] *** raiph joined
[00:22] *** xenoterracide left
[00:33] <flussence> [Coke]: git describe --long should work

[00:49] *** cognominal left
[00:50] *** cognominal joined
[01:03] *** Nom- left
[01:11] *** Nom- joined
[01:14] *** woosley left
[01:16] *** woosley joined
[01:39] *** cognominal left
[01:46] *** lowpro left
[01:52] *** lowpro joined
[01:52] *** lowpro left
[02:00] *** lowpro joined
[02:08] *** BenGoldberg left
[02:11] *** BenGoldberg joined
[02:12] *** btyler_ left
[02:16] <BenGoldberg> rn: say ("O".."z").Str

[02:16] <camelia> niecza v24-88-g1f87209: OUTPUT«(timeout)»

[02:16] <camelia> ..rakudo 4a608a: OUTPUT«O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[02:17] <BenGoldberg> rn: "Oz".ords.say

[02:17] <camelia> rakudo 4a608a, niecza v24-88-g1f87209: OUTPUT«79 122␤»

[02:18] <timotimo> r: say("O".."z")[^20]

[02:18] <camelia> rakudo 4a608a: OUTPUT«"O".."z"␤»

[02:18] <timotimo> r: say("O".."z").map(*.Str)[^20]

[02:18] <camelia> rakudo 4a608a: OUTPUT«"O".."z"␤»

[02:19] <BenGoldberg> rn: .print for "O".."z"

[02:19] <timotimo> r: say ("O".."z")[^20]

[02:19] <camelia> niecza v24-88-g1f87209: OUTPUT«(timeout)OPQRSTUVWXYZAAABACADAEAFAGAHAIAJAKALAMANAOAPAQARASATAUAVAWAXAYAZBABBBCBDBEBFBGBHBIBJBKBLBMBNBOBPBQBRBSBTBUBVBWBXBYBZCACBCCCDCECFCGCHCICJCKCLCMCNCOCPCQCRCSCTCUCVCWCXCYCZDADBDCDDDEDFDGDHDIDJDKDLDMDNDODPDQDRDSDTDUDVDWDXDYDZEAEBECEDEEEFEGEHEIEJEKELEME…

[02:19] <camelia> ..rakudo 4a608a: OUTPUT«OPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz»

[02:19] <camelia> rakudo 4a608a: OUTPUT«O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b␤»

[02:19] <timotimo> (spacebaris a bit busted)

[02:19] <timotimo> ...

[02:19] <timotimo> r: say ("O".."z")[^30]

[02:19] <camelia> rakudo 4a608a: OUTPUT«O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l␤»

[02:19] <timotimo> r: say ("O".."z")[^100]

[02:19] <camelia> rakudo 4a608a: OUTPUT«O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[02:19] <BenGoldberg> n: .say for ("O".."z")[^20]

[02:19] <timotimo> r: say ("O".."z")

[02:19] <camelia> niecza v24-88-g1f87209: OUTPUT«O␤P␤Q␤R␤S␤T␤U␤V␤W␤X␤Y␤Z␤AA␤AB␤AC␤AD␤AE␤AF␤AG␤AH␤»

[02:19] <camelia> rakudo 4a608a: OUTPUT«"O".."z"␤»

[02:20] <timotimo> r: .say for ("O".."z")

[02:20] <camelia> rakudo 4a608a: OUTPUT«O␤P␤Q␤R␤S␤T␤U␤V␤W␤X␤Y␤Z␤[␤\␤]␤^␤_␤`␤a␤b␤c␤d␤e␤f␤g␤h␤i␤j␤k␤l␤m␤n␤o␤p␤q␤r␤s␤t␤u␤v␤w␤x␤y␤z␤»

[02:20] <timotimo> it does work

[02:20] <diakopter> .seen sorear

[02:20] <yoleaux> I saw sorear 21 Jul 2013 06:33Z in #perl6: <sorear> admittedly it's largely out of necessity

[02:20] <timotimo> oh, it was niecza who timeout'd

[02:20] <BenGoldberg> Why does niecza follow Z with AA, while rakudo follows Z with [

[02:20] <timotimo> well, because this:

[02:20] <timotimo> r: say ("a".."zz")[1, 5, 10 ... *]

[02:20] <camelia> rakudo 4a608a: OUTPUT«Unable to deduce sequence␤  in method sink at src/gen/CORE.setting:11241␤  in block  at src/gen/CORE.setting:14827␤  in any coro at src/gen/CORE.setting:6919␤  in method reify at src/gen/CORE.setting:6901␤  in method reify at src/gen/CORE.setting:6643␤  in method r…

[02:21] <timotimo> r: say ("a".."zz")[1, 5, 11 ... *]

[02:21] <camelia> rakudo 4a608a: OUTPUT«Unable to deduce sequence␤  in method sink at src/gen/CORE.setting:11241␤  in block  at src/gen/CORE.setting:14827␤  in any coro at src/gen/CORE.setting:6919␤  in method reify at src/gen/CORE.setting:6901␤  in method reify at src/gen/CORE.setting:6643␤  in method r…

[02:21] <timotimo> oh?

[02:21] <timotimo> r: say ("a".."zz")[0, 5, 10 ... *]

[02:21] <camelia> rakudo 4a608a: OUTPUT«(timeout)»

[02:21] <timotimo> huh.

[02:21] <timotimo> r: say ("x"..*)[^20]

[02:21] <camelia> rakudo 4a608a: OUTPUT«x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq␤»

[02:21] <timotimo> it's just that rakudo notices that O and z are not part of the same sequence

[02:21] <timotimo> r: say ("X"..*)[^20]

[02:21] <camelia> rakudo 4a608a: OUTPUT«X Y Z AA AB AC AD AE AF AG AH AI AJ AK AL AM AN AO AP AQ␤»

[02:25] <BenGoldberg> r: say ("a".."zz")

[02:25] <camelia> rakudo 4a608a: OUTPUT«"a".."zz"␤»

[02:25] <BenGoldberg> r: say ("a".."zz")[^*]

[02:25] <timotimo> i think we may have more luck with the ... operator

[02:25] <camelia> rakudo 4a608a: OUTPUT«(timeout)»

[02:25] <timotimo> r: say "a"..."z"

[02:25] <camelia> rakudo 4a608a: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[02:25] <timotimo> r: say "a"..."zz"

[02:25] <camelia> rakudo 4a608a: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn co cp cq cr cs …

[02:25] <timotimo> r: say +("a"..."zz")

[02:25] <camelia> rakudo 4a608a: OUTPUT«702␤»

[02:26] <timotimo> r: say ("a"..."zz")[^*]

[02:26] <camelia> rakudo 4a608a: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz ca cb cc cd ce cf cg ch ci cj ck cl cm cn co cp cq cr cs …

[02:26] <timotimo> r: say ("a".."zz")[{ say $^length }]

[02:26] <camelia> rakudo 4a608a: OUTPUT«702␤b␤»

[02:26] <timotimo> r: say ("a".."zz")[{ $^length }]

[02:26] <camelia> rakudo 4a608a: OUTPUT«Nil␤»

[02:26] <timotimo> r: say ("a".."zz")[^{ $^length }]

[02:26] <camelia> rakudo 4a608a: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Numeric at src/gen/CORE.setting:952␤  in sub prefix:<^> at src/gen/CORE.setting:6601␤  in block  at /tmp/wv2G6lakwA:1␤␤»

[02:26] <timotimo> er, haha

[02:26] <timotimo> r: say ("a".."zz")[{ ^$^lenger }]

[02:26] <timotimo> that's interesting.

[02:27] <camelia> rakudo 4a608a: OUTPUT«(timeout)»

[02:27] <BenGoldberg> r: say ("a".."zz")[{ ^$^foobar }]

[02:27] <camelia> rakudo 4a608a: OUTPUT«(timeout)»

[02:27] <BenGoldberg> r: say ("a".."b")[{ ^$^foobar }]

[02:27] <camelia> rakudo 4a608a: OUTPUT«a b␤»

[02:27] <timotimo> $^frobfrob is the syntax for an implicit signature's argument

[02:28] <timotimo> r: say ("a".."bz")[{ ^$^argh }]

[02:28] <camelia> rakudo 4a608a: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz␤»

[02:28] <BenGoldberg> r: say ("a".."b")[{ say ^$^foobar }]

[02:28] <camelia> rakudo 4a608a: OUTPUT«0..^2␤b␤»

[02:28] <BenGoldberg> r: say ("a".."b")[{ say ^$^length }]

[02:28] <camelia> rakudo 4a608a: OUTPUT«0..^2␤b␤»

[02:28] <timotimo> maybe a multi candidate for postcircumfix:<[ ]> would be in order that understands ranges

[02:28] <timotimo> r: say (^10).WHAT

[02:28] <camelia> rakudo 4a608a: OUTPUT«(Range)␤»

[02:29] <BenGoldberg> r: say ("a".."d")[{ say ^$^asdflkjwef }]

[02:29] <camelia> rakudo 4a608a: OUTPUT«0..^4␤b␤»

[02:29] *** xenoterracide joined
[02:42] <timotimo> why did a perl6 advent post just bubble up in my feed reader?

[02:47] *** lue joined
[02:50] *** lue left
[02:53] *** btyler joined
[02:53] *** ssutch left
[03:19] *** ssutch joined
[03:41] *** Ben_Goldberg joined
[03:42] *** BenGoldberg left
[03:45] *** btyler left
[03:47] *** Ben_Goldberg left
[03:48] *** BenGoldberg joined
[04:27] *** raiph left
[04:27] *** grondilu left
[04:30] *** konundra left
[04:31] *** konundra joined
[04:37] *** raiph joined
[04:38] *** BenGoldberg left
[04:39] *** djanatyn left
[04:39] *** djanatyn joined
[04:44] *** birdwindupbird joined
[04:45] *** konundra left
[04:52] *** xilo left
[05:12] *** SamuraiJack_ joined
[05:22] <moritz> \o

[05:37] <diakopter> o/

[05:41] <Woodi> hallo

[05:42] <Woodi> could someone give ~ info about what's broken in Star ATM ?

[05:42] *** ssutch left
[05:44] *** ssutch joined
[05:48] *** preflex left
[05:49] *** preflex joined
[05:49] *** ChanServ sets mode: +v preflex

[05:52] *** logie left
[05:52] *** logie joined
[06:03] <frettled> Good morning, #perl6 :)

[06:10] *** silug joined
[06:14] *** dmol joined
[06:15] *** lowpro left
[06:26] *** daniel-s__ joined
[06:32] *** huf joined
[06:35] *** robinsmidsrod joined
[06:47] *** zacts joined
[06:49] *** xinming left
[06:52] *** xinming joined
[06:53] <moritz> \o frettled 

[06:59] *** sidus joined
[07:04] *** FROGGS joined
[07:22] *** fhelmberger joined
[07:27] *** kaleem joined
[07:41] <lizmat> good *, #perl6

[07:49] <FROGGS> gmorning lizmat 

[07:49] <lizmat> morning FROGGS!

[07:52] <arnsholt> Woodi: I know that Zavolaj fails some tests

[07:52] <arnsholt> moritz: Incidentally, the Zavolaj fail is likely to impact DBIish I think

[07:54] <moritz> :/

[07:56] <arnsholt> It'll only fail when you use explicitly-manage() (which I'm looking forward to axing, BTW), but IIRC at least the Pg driver needs that

[07:59] <dalek> Perlito: 95e6b6c | (Flavio S. Glock)++ | TODO-perlito5:

[07:59] <dalek> Perlito: Perlito5 - TODO cleanup

[07:59] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/95e6b6cc90

[08:06] <lizmat> Q: is there an easy way to complete fudge a test file for niecza and pugs ?

[08:07] <arnsholt> Not sure what you want to do

[08:07] <lizmat> working on $var will foo {} tests, and these won't work on niecza nor pugs

[08:07] <arnsholt> If you want to run a single (fudged) test file you can make t/spec/path-to-file.t

[08:07] <lizmat> so all tests need to be fudged

[08:07] <arnsholt> At least on Rakudo

[08:08] <arnsholt> Oh, right. Mark the entire file as to be skipped should be possible

[08:08] <arnsholt> I've no idea how though, sorry

[08:08] <lizmat> :-(

[08:08] <lizmat> :-)

[08:09] <lizmat> hmmm… some conditional skip_rest. but what would the condition be?

[08:09] <lizmat> ah, fudge that line for rakudo  :-)

[08:10] <FROGGS> lizmat: if you dont want to run a single file, just remove it from spectest.data

[08:11] <lizmat> I don't want to run this for niecza and pugs

[08:11] <lizmat> they have their own "spectest.data", no?

[08:13] <FROGGS> they have

[08:13] <FROGGS> so if you add a new test file for example for rakudo, you are always safe

[08:14] <lizmat> for now, this seems to do the trick:

[08:14] <lizmat> #?rakudo 1 skip "don't skip on rakudo"

[08:14] <lizmat> BEGIN skip_rest( "can only do this on rakudo" );

[08:16] <masak> mornin', #perl6

[08:17] <lizmat> morning masak

[08:22] <lizmat> S04:1454 states "These have the advantage of passing the variable in question into the closure as its topic"

[08:22] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1454

[08:23] <lizmat> I wonder what that would mean for cases such as

[08:23] <lizmat> my @a will begin { say $_.WHAT }  # Array ?

[08:24] <masak> r: my @a; BEGIN { say @a.WHAT }

[08:24] <camelia> rakudo 4a608a: OUTPUT«(Array)␤»

[08:24] * masak nods

[08:25] <lizmat> r: my @a; $_ := @a; say $_.WHAT   # more like this, I guess

[08:25] <camelia> rakudo 4a608a: OUTPUT«(Array)␤»

[08:28] <lizmat> r: my @a will begin { say $_.WHAT }  # Array ?

[08:28] <camelia> rakudo 4a608a: OUTPUT«(Mu)␤»

[08:29] <masak> I don't see why it shouldn't be (Array)

[08:29] * masak submits rakudobug

[08:30] *** sqirrel joined
[08:30] <lizmat> masak: don't bother, it's NYI

[08:30] <lizmat> one of the blockers I'm banging my head against

[08:31] <masak> ok, submitting as [NYI] instead of [BUG] :)

[08:34] *** daxim joined
[08:35] <lizmat> r: my @a will begin { say @a.WHAT }  # the crux of the current problem

[08:35] <camelia> rakudo 4a608a: OUTPUT«===SORRY!===␤Variable '@a' is not declared␤at /tmp/psEdqWxtJ9:1␤------> my @a will begin { say @a.WHAT⏏ }  # the crux of the current problem␤    expecting any of:␤        method arguments␤        postfix␤»

[08:37] *** preflex left
[08:37] *** ecocode joined
[08:39] <masak> lizmat: now that *is* a bug.

[08:39] *** preflex joined
[08:39] *** ChanServ sets mode: +v preflex

[08:39] *** dakkar joined
[08:39] <masak> one I can partly explain, though, having dealt with macros.

[08:39] <lizmat> no, its's NYI

[08:39] *** rindolf joined
[08:39] <lizmat> when the code of the block gets executed, the variable has not been properly declared yet

[08:40] <masak> a variable is *always* declared as soon as the parser is past 'my @a'

[08:40] <masak> but I see what you're saying. it's an interesting edge case.

[08:41] <lizmat> that's the point: it only is declared, afaics, *after* the next ; or ,

[08:41] <masak> forget the connection to macros (and scopes), your explanation is simpler.

[08:41] <masak> r: my $x = $x

[08:41] <camelia> rakudo 4a608a:  ( no output )

[08:41] <masak> lizmat: then that wouldn't compile.

[08:42] <lizmat> hmmm…  add '=' to the list of boundaries  :-)

[08:42] <masak> you keep adding epicycles. :)

[08:42] <masak> just say it's after the 'my $x' :)

[08:43] <masak> because we also have cases like 'say (my $x) + $x'

[08:43] <lizmat> well, fwiw, the same probem we had with "is readonly"

[08:43] <masak> r: say my $x + $x ** $x

[08:43] <lizmat> it would mark the variable as readonly before it could get initialize

[08:43] <camelia> rakudo 4a608a: OUTPUT«use of uninitialized value of type Any in numeric context  in block  at /tmp/pvrQRsBJMv:1␤␤use of uninitialized value of type Any in numeric context  in block  at /tmp/pvrQRsBJMv:1␤␤use of uninitialized value of type Any in numeric context  in block  at /tmp/pvrQRs…

[08:43] <lizmat> d

[08:43] <FROGGS> I think the problems is that "declaring a var" has several steps

[08:43] <FROGGS> -s

[08:44] <FROGGS> when the parser spots my $x it is known to the parser, even if a trait is following

[08:44] <lizmat> masak: now that is interesting  :-)

[08:44] <FROGGS> but that is all that happened at that time

[08:53] <masak> lizmat: my point is that 'at the next boundary' is too late.

[08:53] <masak> lizmat: see also parameters: '$x where { $x == 7}'

[08:54] <lizmat> hmmm...

[08:54] <lizmat> first I'll write a large set of (todo/skip) tests, then I'll look at the "where" case

[08:56] <masak> r: sub foo($x, $y where { $y == $x + 2 }) { say "yep, $x and $y works!" }; foo(10, 12); foo(7, 8)

[08:56] <camelia> rakudo 4a608a: OUTPUT«yep, 10 and 12 works!␤Constraint type check failed for parameter '$y'␤  in sub foo at /tmp/n4M9QbAZAq:1␤  in block  at /tmp/n4M9QbAZAq:1␤␤»

[08:59] <lizmat> fwiw, jnthn++ spent only a few hours on this initial var trait implementation before he went on holiday

[09:00] <lizmat> I'm just trying to get the rough edges off, but my sander is definitely not strong enough yet

[09:00] <masak> lizmat++ # tuit source

[09:01] <masak> lizmat: as Head Bug Wrangler, I feed off people's attempts to make things work. the friction that causes drives the bug-filing metabolic cycle.

[09:01] <lizmat> wish I could spend my tuits more economically though, instead of head banging most of the time / waiting for make to finish

[09:12] <arnsholt> I think the problem is that traits are part of the variable_declarator token (Grammar.pm:2110) and the corresponding action method is where it's installed in the symbol table

[09:16] <masak> that doesn't sound insurmountable, though.

[09:16] <masak> that sounds like "oh bother" but not "I... see. back to the drawing board."

[09:17] <arnsholt> Yeah, shouldn't be completely crazy

[09:17] *** fridim__ left
[09:18] <arnsholt> From a skim of Actions.pm, looks like some of what happens in declare_variable() has to happen between the declaration of the name and the traits

[09:18] <lizmat> it's too crazy for me at the moment  :-(   but I will get there somehow

[09:18] <FROGGS> lizmat: that is why moarvm is so much fun, after changing stuff, it only takes a fraction of a minute to recompile and run the given test

[09:18] <arnsholt> Installing a stub container descriptor or something like that

[09:18] <FROGGS> arnsholt: that is what I tried to say earlier

[09:19] <arnsholt> Ah, right

[09:20] <lizmat> grrr… and now I find that "will end" should throw an exception, but doesn/t  :-(

[09:21] <lizmat> r: my $a will end { say "Goodbye" }

[09:21] <camelia> rakudo 4a608a:  ( no output )

[09:22] <lizmat> r: my $a will foo { say "Goodbye" }

[09:22] <camelia> rakudo 4a608a: OUTPUT«===SORRY!===␤Can't use unknown trait 'will foo' in a variable declaration.␤at /tmp/CR86bWmxRS:1␤------> my $a will foo { say "Goodbye" }⏏<EOL>␤    expecting any of:␤        begin check final init end␤        enter leave keep und…

[09:37] *** raiph left
[09:37] *** fhelmberger left
[09:49] <lizmat> hmmm… even a die() doesn't work in a "will foo {…}' trait mod

[10:02] <masak> I realized a couple of days back that a fairly essential part of the Nomic-in-p6 game would have to be a decent "Nomic simulator", in which a player could run his proposed patch offline with full mocking of other players, turns, voting, etc.

[10:04] *** ecocode left
[10:10] *** aindilis left
[10:14] <dalek> rakudo/nom: 59ec2d1 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[10:14] <dalek> rakudo/nom: Remove useless exceptions from variable "will" trait

[10:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59ec2d10b3

[10:19] *** sidus left
[10:24] <masak> std: say 00

[10:24] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that at /tmp/GUrPKFCnDV line 1:␤------> say 00⏏<EOL>␤ok 00:00 42m␤»

[10:24] <masak> std: say 00 #OK

[10:24] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[10:24] <FROGGS> r: say 00

[10:24] <camelia> rakudo 4a608a: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tmp/YF2NTpNjIs:1␤    ------> say 00⏏<EOL>␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tm…

[10:24] <FROGGS> r: say 00 #OK

[10:24] <camelia> rakudo 4a608a: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tmp/xaOcYwP1or:1␤    ------> say 00⏏ #OK␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tmp…

[10:24] <FROGGS> k

[10:28] <dalek> roast: 73f8c5b | (Elizabeth Mattijsen)++ | S04-declarations/will.t:

[10:28] <dalek> roast: Initial work on "will" variable trait tests

[10:28] <dalek> roast: review: https://github.com/perl6/roast/commit/73f8c5b1ba

[10:28] <dalek> rakudo/nom: bb86d1a | (Elizabeth Mattijsen)++ | t/spectest.data:

[10:28] <dalek> rakudo/nom: Add new "will" variable trait tests

[10:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bb86d1af1b

[10:34] *** sqirrel left
[10:37] * masak still thinks https://gist.github.com/masak/5237570 is a thing of beauty and hopes to find tuits to implement it during 2013

[10:38] <masak> I just went through it and found/fixed a bug or two.

[10:38] *** sidus joined
[10:38] <masak> programming mid-air is never a good idea ;)

[10:43] <masak> (by which I don't mean "programming in airplanes", which should be fine, but "programming without having runnable code to make sure it actually works")

[10:45] <masak> train &

[10:48] <FROGGS> I'm getting sick when hacking in airplanes :/

[10:50] <Teratogen> std: 1 while fork;

[10:50] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[10:50] <Teratogen> baw

[10:51] <FROGGS> Teratogen: what do you expect? blowing up a parser?

[10:52] <Teratogen> maybe "Out of memory"

[10:52] <Teratogen> std: @a=1..10000000000000000000000000000000000

[10:52] <camelia> std c2215f0: OUTPUT«===SORRY!===␤Variable @a is not predeclared at /tmp/V_aa8iRKks line 1:␤------> <BOL>⏏@a=1..1000000000000000000000000000000000␤Check failed␤FAILED 00:00 43m␤»

[10:52] <Teratogen> std: my @a=1..10000000000000000000000000000000000

[10:52] <camelia> std c2215f0: OUTPUT«ok 00:00 43m␤»

[10:52] <Teratogen> I give up

[10:53] <Teratogen> std: my @a=(1..10000000000000000000000000000000000)

[10:53] <camelia> std c2215f0: OUTPUT«ok 00:00 45m␤»

[10:53] <Teratogen> baw

[10:53] <Teratogen> std: $a = 1

[10:53] <camelia> std c2215f0: OUTPUT«===SORRY!===␤Variable $a is not predeclared at /tmp/_UNfVKgScL line 1:␤------> <BOL>⏏$a = 1␤Check failed␤FAILED 00:00 43m␤»

[10:53] <Teratogen> interesting, everything must be predeclared in Perl 6?

[10:53] <FROGGS> Teratogen: std is "just" a parser

[10:53] <Teratogen> ah

[10:54] <FROGGS> Teratogen: no, there is a "lax"-mode specced

[10:54] <FROGGS> std: v6; say $a # maybe NYI ?

[10:54] <camelia> std c2215f0: OUTPUT«===SORRY!===␤Variable $a is not predeclared at /tmp/6cMWmDHsZT line 1:␤------> v6; say ⏏$a # maybe NYI ?␤Check failed␤FAILED 00:00 42m␤»

[10:54] <FROGGS> right, NYI

[10:54] *** fgomez left
[10:54] <FROGGS> but is shouldnt be too hard to implement that fwiw

[11:00] *** leont joined
[11:00] <Teratogen> Did Perl 6 do away with typeglobs?

[11:01] <Teratogen> Typeglobs are so very very Perlish!

[11:01] <leont> They're also quite terrible ;-)

[11:06] <GlitchMr> Teratogen: yes

[11:06] <GlitchMr> But aliasing still exists if you need it.

[11:08] <GlitchMr> my $a = 42; my $b := $a;

[11:08] *** mj41 joined
[11:08] <Teratogen> It's just not the same!

[11:09] *** sqirrel joined
[11:09] * leont is coming to the perl 6 hackathon at YAPC::EU, but doesn't know what he's planning to do there yet􏿽x85

[11:10] <GlitchMr> What else typeglobs could be used for?

[11:11] <leont> filehandles of course :-(

[11:11] <leont> And the weirdest objects ever!

[11:11] <GlitchMr> Filehandles are proper objects in Perl 6.

[11:11] <Teratogen> a typeglob is just a structure of references.

[11:11] <Teratogen> It's not that big of a deal.

[11:12] <nwc10> leont: I was wondering about "drink!"

[11:12] <Teratogen> Going to Europe?  Try the absinthe!

[11:12] <leont> GlitchMr: that was sarcasm

[11:13] <GlitchMr> You can have bareword filehandles, but they are still proper objects.

[11:13] <GlitchMr> niecza> my \file = open 'file'

[11:13] <GlitchMr> TextReader.new(...)

[11:13] <GlitchMr> niecza> file

[11:13] <GlitchMr> TextReader.new(...)

[11:13] <GlitchMr> (it seems there is a bug in Rakudo with bareword filehandles, but in Niecza it works)

[11:14] <Teratogen> ack

[11:14] <Teratogen> Camelcase =(

[11:14] <Teratogen> text_reader <== I am Multics old school

[11:14] <Ulti> way of the camel case

[11:14] <GlitchMr> TextReader is class name.

[11:14] <Teratogen> why not text_reader

[11:14] <Teratogen> it's easier on the eyes

[11:15] <GlitchMr> In Perl 5, TextReader->new would be fine (if TextReader would be a package).

[11:15] <Ulti> I'm with GlitchMr on this one 

[11:15] <Teratogen> I don't get it!

[11:15] <Teratogen> text_reader->new

[11:15] <GlitchMr> Because packages and classes are important.

[11:15] <Ulti> JavaDoesThis variable_name

[11:15] <GlitchMr> Java actually does JavaDoesThis variableName

[11:16] <GlitchMr> Perhaps Python, or Ruby.

[11:16] <Ulti> types in Perl6 are capitalised already so why wouldnt you do the same with your own types

[11:16] <GlitchMr> Also, TextReader is a bug in Niecza.

[11:16] <GlitchMr> In Rakudo, it's IO::Handle object.

[11:16] <FROGGS> in Perl land packages (= types) were always PascalCased

[11:17] <GlitchMr> And, well, it's from Perl 5.

[11:17] <GlitchMr> There is nothing wrong IMO with CamelCaseClasses.

[11:18] <GlitchMr> Also, text_reader is ugly in Perl 6. Perhaps text-reader?

[11:18] *** pmurias joined
[11:18] <FROGGS> right

[11:18] <dalek> rakudo-js: d1204ad | (Pawel Murias)++ | run_tests:

[11:18] <dalek> rakudo-js: Add passing test 64 to run_tests.

[11:18] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/d1204addbb

[11:18] <GlitchMr> Underscores generally are avoided in Perl 6.

[11:18] <Ulti> $_ 

[11:19] <GlitchMr> $_ is exception.

[11:19] <FROGGS> s/avoided within names//

[11:19] <GlitchMr> $- would be ugly.

[11:20] <FROGGS> we basically have $_, $! and $/, and I love all three

[11:21] <GlitchMr> I'm not sure whatever Perl 6 needs $!, but it's still improvement compared to Perl 5.

[11:21] <Ulti> I kind of like Icon's take on magic variables they have their own sigil &

[11:21] <GlitchMr> With lots of global filehandle variables.

[11:21] * leont couldn't resist looking up $- in perl5, it's "The number of lines left on the page of the currently selected output channel.", thank goodness perl 6 doesn't have formats

[11:21] <GlitchMr> Perl 6 has formats, just that they are external module available in ecosystem.

[11:22] <GlitchMr> But Perl 6 formats don't depend on global variables and nonsense like that.

[11:22] <GlitchMr> https://github.com/mathw/form/

[11:23] <GlitchMr> The formats were going to be a part of Perl 6, but were moved to external module.

[11:23] <leont> They're not formats in the perl 5 sense, they're just a template system

[11:23] <GlitchMr> Formats in Perl 5 are templating system too.

[11:24] <GlitchMr> (well, yeah, formats in Perl 5 could only write to filehandles, but nothing stopped you from opening variable filehandle)

[11:25] <leont> But not "just one". Syntactically they're part of the language as much as subs are

[11:25] <leont> Down to little things like all globs having a FORMAT field􏿽x85

[11:25] <GlitchMr> True.

[11:26] <GlitchMr> Perl 5 formats need syntactical support from language itself.

[11:26] <GlitchMr> Perl 6 formats are just a function.

[11:27] <GlitchMr> But is there any difference between standard function call and special syntax?

[11:28] <GlitchMr> (also, Perl 6 modules can easily add special syntax, so well...)

[11:28] <leont> What do you mean?

[11:29] <GlitchMr> You can modify Perl 6 grammar from language itself.

[11:29] *** rindolf left
[11:29] <GlitchMr> r: sub infix:<!@#> { $^a * 2 + $^b * 3 }; say 7 !@# 3;

[11:29] <camelia> rakudo bb86d1: OUTPUT«23␤»

[11:29] <GlitchMr> Doing something like format would be more complex, but possible.

[11:30] <leont> Ah, like that

[11:30] <leont> Yeah, you don't really want that

[11:31] <GlitchMr> The Perl 6 grammar is written in Perl 6.

[11:31] <GlitchMr> https://github.com/perl6/std/blob/master/STD.pm6

[11:34] <leont> I meant, you don't want to recreate formats that way, you want to have a modifiable grammar, I agree on that!

[11:34] <GlitchMr> You can insert a token into grammar

[11:34] <GlitchMr> Something like 'format' <stuff>

[11:35] <arnsholt> (This is mostly not yet implemented, mind)

[11:35] <GlitchMr> I think it's possible in STD.pm6.

[11:35] <GlitchMr> Not sure about Rakudo or Niecza.

[11:35] <GlitchMr> By STD.pm6, I mean viv.

[11:36] <arnsholt> viv actually handles macros?

[11:36] <GlitchMr> No.

[11:36] <GlitchMr> But I guess it could parse the token added to grammar.

[11:36] <GlitchMr> viv is just a parser.

[11:37] <arnsholt> Oh, right. But that's not terribly useful for Rakudo/Niecza though

[11:38] <arnsholt> As long as we can't attach actions and generate AST for new syntax, we can't make it do anything

[11:38] <GlitchMr> STD.pm6 knows what is a 'macro'.

[11:38] <GlitchMr> But it doesn't run it...

[11:50] *** odoacre left
[12:03] *** mtk left
[12:12] *** mtk joined
[12:26] <Ulti> out of interest is there any difference between doing @list ==> map {$_+=3} ==> reduce {$^a+$^b}  and   map {$_+=3}, @list ==> reduce {$^a+$^b}

[12:26] <Ulti> in the first could the map be done in parallel as well as the reduce and the second the map is done sequentially?

[12:27] <Ulti> or is it all just sequential pipe style doing things

[12:27] <Ulti> as in its just a different process for each expression between ==>

[12:30] <GlitchMr> Ulti: it just looks differently

[12:30] <GlitchMr> ==> shows piping process.

[12:31] *** cognominal joined
[12:31] <GlitchMr> But IMO, mixing two styles is ugly.

[12:33] *** kingbeast joined
[12:34] <Ulti> so there is no practical difference between reduce {$^a+$^b}, map {$_+=3}, @list and the ==> form? as in I should expect something like forking with ==> ?

[12:34] <Ulti> *shouldn't

[12:35] <GlitchMr> ==> has nothing with forking

[12:35] <Ulti> GlitchMr: I like the ==> just because you can use left to right read order which is easier for non functional types to read

[12:35] <[Coke]> flussence: no, git describe --long also says "nothing to describe"

[12:36] <GlitchMr> I mean, you have @list in middle, not at beginning or end.

[12:37] <Ulti> huh?

[12:37] <Ulti> GlitchMr: the 'and' was english not Perl6 ;)

[12:37] <GlitchMr> I prefer something like @list ==> map { $_ += 3 } ==> reduce { $^a + $^b }

[12:38] <Ulti> so the feed operator does nothing apart from syntax sugar?

[12:38] <GlitchMr> But that is ugly in my opinion

[12:38] *** dmol left
[12:38] <GlitchMr> Rather, I would do [+] @list X+ 3

[12:39] <Ulti> yeah I know but it was just an example with the feed operator so I could talk about it

[12:39] <GlitchMr> And yes, feed operator is just a syntactic sugar.

[12:39] <GlitchMr> reduce {} is always confusing, by the way.

[12:39] <Ulti> really why?

[12:40] <GlitchMr> (when not used with simple infix operator)

[12:40] *** kingbeast left
[12:40] *** crab2313 joined
[12:40] <GlitchMr> And when you use it with infix operator, you have [] prefix operator anyway.

[12:40] <GlitchMr> Or reduce &[+], but that's more verbose.

[12:40] <[Coke]> Woodi: here's a list of everything failing in star: https://github.com/coke/rakudo-star-daily/blob/master/log/test-modules.log

[12:40] <mathw> that's a matter of opinion

[12:40] <[Coke]> (assuming we want to upgrade to latest module versions of rakudo+nqp+modules)

[12:41] * [Coke] wonders who updated https://perl6advent.wordpress.com/2012/12/10/day-10-dont-quote-me-on-it/

[12:41] <GlitchMr> There is a reason why reduce() is avoided in Python.

[12:42] <Ulti> Python avoids any functional trope as far as I can see

[12:42] <Ulti> like removing lambda in version 3

[12:42] <GlitchMr> lambda never was removed 

[12:42] <Ulti> orly

[12:42] <GlitchMr> lambda wasn't removed*

[12:43] <GlitchMr> >>> lambda: 42

[12:43] <GlitchMr> <function <lambda> at 0xf727c2ec>

[12:43] <Ulti> http://docs.python.org/3.3/faq/programming.html#is-it-possible-to-write-obfuscated-one-liners-in-python  its not advised either, and is picked on a lot

[12:44] <GlitchMr> Guido wanted to remove it, but there was no good alternative for it in many cases.

[12:44] <GlitchMr> http://mail.python.org/pipermail/python-dev/2006-February/060415.html

[12:44] <GlitchMr> But reduce() was moved to functools.

[12:45] <GlitchMr> He also wanted to remove map() and filter().

[12:45] <GlitchMr> http://www.artima.com/weblogs/viewpost.jsp?thread=98196

[12:45] <GlitchMr> Only reduce() was removed (or rather, moved to functools).

[12:45] <mathw> That's a Python decision though

[12:45] <mathw> It doesn't mean reduce is intrinsically bad

[12:46] <mathw> Functional programmers use it all the time

[12:46] <GlitchMr> sum() is still available in Python

[12:46] <GlitchMr> (even when it's just specific case of reduce)

[12:46] <mathw> this is why I don't like Python

[12:47] <mathw> why demote reduce in favour of, what, foreach loops?

[12:47] <leont> list comprehensions

[12:47] <Ulti> " filter(P, S) is almost always written clearer as [x for x in S if P(x)] "   wtf that makes no sense /unless/ you are already a Python programmer

[12:47] <leont> Yeah, they are powerful but not exactly obvious

[12:47] <Ulti> list comprehensions aren't exactly common everywhere but the word filter with two parameters I can have a good guess at

[12:48] <leont> Then again, we're talking about the people who make fun of perl's syntax, and then copy the very worst part of it (regexps) verbatim􏿽x85

[12:48] <Ulti> map reduce is also a lot more common an idea now thanks to BigData hype too

[12:48] <Ulti> leont: its more they use the actual implementation and feed it strings :)

[12:49] <GlitchMr> reduce with something other than { $^a + $^b }, { $^a * $^b } or { $^a lcm $^b } doesn't make much sense IMO.

[12:49] <mathw> I have no issue with list comprehensions, they can be a neat way to express things

[12:49] <GlitchMr> In Perl 6, also stuff like [>] are useful, except reduce cannot do it.

[12:50] <Ulti> mathw: neither do I, but arguing they are easier to read than a named function is a bit of a streth imho

[12:51] <Ulti> though calling grep filter might be a good plan ;)

[12:51] <Ulti> since windows people have no idea what grep is

[12:51] <GlitchMr> grep is part of Perl.

[12:51] <GlitchMr> It should stay grep.

[12:51] <mathw> I'm always wary of judgements about 'easy to read' because most languages are incomprehensible until you learn them

[12:52] <GlitchMr> With filter, Perl doesn't look Perl.

[12:52] <mathw> if you follow easy to read to its conclusion you end up with visual basic

[12:52] <leont> mathw: I think perl people tend to understand that a lot better than python people

[12:52] <Ulti> heh dont know about that, most VB I've had to look at wasnt readable lol

[12:52] <Ulti> readable has more to do with the developer than the language

[12:53] <mathw> obviously it's possible to write unreadable VB :)

[12:53] <mathw> just like you can also write readable Perl 5, much as it might shock some parts of the internet to say that

[12:53] <GlitchMr> If you don't know VB, it looks unreadable.

[12:53] * Ulti remembers thedailywtf.com exists

[12:53] <GlitchMr> Or even confusing.

[12:53] <GlitchMr> For example, & operator for concatenation.

[12:54] <GlitchMr> I mean, everybody (read; C-like languages) uses it as bitwise and.

[12:54] <Ulti> I never got why & isnt used for string concatenation WAY more

[12:54] <moritz> hardware upgrade&

[12:54] <Ulti> whats more intuitive & or ~ . +

[12:54] <Ulti> "hello" & "world"

[12:54] <GlitchMr> Ulti: ++

[12:54] <GlitchMr> Or // if you prefer that.

[12:55] <mathw> ++ works nicely in Haskell

[12:55] <Ulti> I guess its all a hangup on programming not being so much about strings, a legacy from computers being about logic and calculation

[12:55] <GlitchMr> Or strcat()

[12:55] <mathw> although for serious string handling you need something else, because you need the Text library and ++ is really list-append

[12:55] <GlitchMr> I mean, strcat() says what it does.

[12:56] <Ulti> really if two strings are next to each other with no op that should mean concatenation too

[12:56] *** sqirrel left
[12:56] <GlitchMr> (if you ignore lame, C-style name of function)

[12:56] <GlitchMr> Alternatively, there is AWK with it's concatenation operator.

[12:56] <mathw> heh, good luck writing the grammar for that one :)

[12:57] <GlitchMr> its*

[12:57] <GlitchMr> mathw: what is difficult with writing grammar for two strings next to each other

[12:58] <GlitchMr> rule concatenation { <string> <string> }

[12:58] <Ulti> make any amount of white space between stuff force a string interpretation and concatenate, doesnt sound too crazy

[12:58] <GlitchMr> ~ $ awk 'BEGIN { print 4 2 }'

[12:58] <GlitchMr> 42

[12:59] <GlitchMr> Sounds about right.

[12:59] <GlitchMr> Or shell scripts, where nothing is concatenation.

[12:59] <mathw> I don't think string concatenation is important enough to justify such a valuable place in the syntax

[13:00] <Ulti> the way you define rules in Perl6 is basically this anyway

[13:00] <GlitchMr> If I write $var$var2 in shell script, it's concatenation of $var and $var2.

[13:00] <GlitchMr> But if I write $var $var2, it isn't concatenation.

[13:01] <Ulti> yeah significant white space like that I draw the line at

[13:01] <Ulti> the no white space and any white space being concatenation I can get behind

[13:02] *** _ilbot joined
[13:03] *** moritz joined
[13:04] *** SamuraiJack_ left
[13:12] *** telex left
[13:13] *** telex joined
[13:14] *** konundra joined
[13:18] *** PacoAir joined
[13:22] *** xilo joined
[13:26] *** stevan_ joined
[13:37] <moritz> fwiw the machine behind irclog.perlgeek.de now has more ram, so with a bit of luck it's faster now

[13:37] <moritz> and with even more luck I can compile rakudo on it, and use the Perl 6 logging bot

[13:37] <[Coke]> moritz: MORITZ!

[13:39] * moritz has trouble upper-casing the [ and ] in [Coke] :-)

[13:40] <[Coke]> r: say '['.uc

[13:40] <camelia> rakudo bb86d1: OUTPUT«[␤»

[13:41] <PerlJam> moritz: the capslock key helps :)

[13:41] * [Coke] hates the []

[13:41] <moritz> PerlJam: :-)

[13:41] <[Coke]> ... people still have that wired to caps lock!? ;)

[13:42] <moritz> [Coke]: you could always do a /nick ]Coke[  :-)

[13:45] <mathw> do you have to have the ]

[13:45] <mathw> or the [

[13:49] *** rindolf joined
[13:52] *** PacoAir left
[13:53] *** PacoAir joined
[13:53] *** PacoAir left
[13:54] *** PacoAir joined
[13:54] <[Coke]> mathw: I can't have just Coke, is the problem.

[13:54] *** [Coke] is now known as Coke

[13:54] <Coke> ... I can't *register* Coke, is the problem. :)

[13:54] <yoleaux> 5 Apr 2013 14:55Z <[Coke]> Coke: hi.

[13:54] *** Coke is now known as [Coke]

[13:55] *** [Coke] is now known as Coke

[13:55] *** btyler joined
[13:57] *** Coke is now known as [Coke]

[13:57] *** dmol joined
[13:59] <mathw> ah

[13:59] <[Coke]> irc--

[14:00] <PerlJam> (dude who registered "Coke" before [Coke] was able to)--

[14:00] <PerlJam> :)

[14:00] *** kaare_ joined
[14:02] <mathw> specificity++

[14:04] <huf> isnt { the uppercase of [ ?

[14:05] <huf> or the other way around...

[14:05] <FROGGS> it is sort of () on my keyboard

[14:06] <huf> i dont dare look down because the painted layout will utterly confuse me 

[14:07] <FROGGS> moritz: can you give me a hint, where the code is for lazy evaluation in rakudo?

[14:07] <huf> () is particularly hard

[14:07] <GlitchMr> huf: { is lowercase of [

[14:07] <GlitchMr> (but I don't think it matters much)

[14:07] <huf> except for nicks, yeah

[14:08] <mathw> { is uppercase of [ on my keyboard

[14:08] <huf> i dont think i could be {coke}

[14:09] <GlitchMr> huf: I'm not talking about that.

[14:09] <GlitchMr> I'm talking it doesn't really matter whatever [ is lowercase, or { is lowercase.

[14:10] <huf> right

[14:10] <huf> mathw: sure, in reality it's that way on mine too, since us layout. but the paint is funny.

[14:10] <huf> but this is from the finnish layout originally...

[14:10] <huf> (what an odd way to choose upper/lowercase pairs)

[14:11] *** jaldhar joined
[14:11] <GlitchMr> {}| []\

[14:21] *** skids joined
[14:22] <moritz> FROGGS: lazy evaluation? in which context?

[14:23] <moritz> of lists? or of thunks?

[14:25] <GlitchMr> Lazy evaluation? my @array = map { do_something $_ }, @stuff

[14:26] <GlitchMr> I meant, my @array := map { do_something $_ }, @stuff

[14:26] <FROGGS> moritz: of lists

[14:26] <GlitchMr> Or gather { take }

[14:26] <GlitchMr> Or grep

[14:26] <GlitchMr> Or anything that returns iterator

[14:27] <FROGGS> like: my @b = ^9; my @a := map { say 1; $_ + 1 }, @b; say @a[2]

[14:27] <moritz> FROGGS: that's really in ListIter/MapIter, but also spread out all over the List code

[14:27] <FROGGS> I want to try to put the calculation in a thread

[14:27] <FROGGS> k, thanks

[14:27] *** xilo left
[14:27] *** sqirrel joined
[14:27] <moritz> FROGGS: that would be fine for feeds, for example

[14:27] <moritz> FROGGS: but lazy is really the opposite of parallel

[14:28] <FROGGS> but it shares some logic: you try to access @a[2], and for the multithreaded case it would wait for the thread at that point

[14:28] <FROGGS> at least that is my understanding

[14:29] <moritz> FROGGS: but when does it start evaluating?

[14:30] <moritz> compiling current NQP segfaults on my VM

[14:30] <moritz> the stage that creates src/stage2/QAST.pbc

[14:30] <FROGGS> I see two options here :o)

[14:30] <moritz> (and no, there isn't any cruft in $PATH; there was never another rakudo build on this machine)

[14:31] <FROGGS> This is nqp version 2013.07-25-g1541771 built on parrot 5.5.0 revision RELEASE_5_5_0 # this one built fine here

[14:36] *** dmol left
[14:37] *** Psyche^ joined
[14:37] * moritz tries with nqp master

[14:38] *** Psyche^_ left
[14:42] <FROGGS> okay, I found the right place to play with threads...

[14:43] <moritz> FROGGS: it would be nice to evaluate 'hyper' or hyper ops or feeds in parallel, but I don't think there is anything to gain with lazy lists

[14:44] <FROGGS> why not? what if you only use a fraction of the to-be-computet values of a list?

[14:45] <FROGGS> and, if at the point of creating such a lazy+multi-threaded thing, there maybe still run other parallel tasks from previous actions

[14:45] <moritz> then people will be very suprised that the side effects from creating the list items happen even for stuff that they never use

[14:46] <FROGGS> so, there could be a usecase IMO, but of course I'll try the other way first

[14:46] <FROGGS> what side effects?

[14:46] <moritz> stuff that happens in the loop body, for example

[14:47] <FROGGS> well, it will not happen for values which are never used, when you have a lazy list

[14:47] <moritz> like a die() or a say()

[14:47] <moritz> so you only want to start processing when you know the values will be used?

[14:47] <FROGGS> it would be nice to support both ways somehow

[14:48] <moritz> well, hyper() is meant to support the other way

[14:49] <FROGGS> what? immediate processing begin or delayed?

[14:49] <moritz> anyway, it's a rather hairy subject to parallelize lazy evaluation, which is why I'd rather go for the stuff that's specced to be (potentially) parallel

[14:49] <moritz> and junction evaluation, come to think of it

[14:50] <moritz> FROGGS: it executes as soon as you call the hyper()

[14:50] <moritz> which might on the same line as the definition of the list, or might not be.

[14:53] *** dmol joined
[14:55] <FROGGS> moritz: I'm just experimenting a bit, if I have something to show I will start reading the spec :o)

[14:55] <moritz> FROGGS++

[14:57] *** konundra left
[15:02] * masak doesn't understand what the commenter wants at https://perl6advent.wordpress.com/2012/12/10/day-10-dont-quote-me-on-it/

[15:03] <jercos> masak: view the source wordpress spits out. The heredoc was indented, and because of that, each line was preceeded by a tab character.

[15:04] *** ssutch left
[15:05] <masak> jercos: ah. thanks.

[15:05] <jercos> http://pastebin.com/cxGXLSEk reconstructed.

[15:05] <jercos> :)

[15:06] <timotimo> r: https://gist.github.com/timo/6132249

[15:06] <camelia> rakudo bb86d1: OUTPUT«Array.new("Superhero", "Identity", "Secret Superpower")␤Array.new(("The Bowler", "Carol Pinnsler", "Haunted bowling ball").list.item, ("The Bowler", "Carol Pinnsler", "Haunted bowling ball").list.item, ("The Bowler", "Carol Pinnsler", "Haunted bowling ball").list.i…

[15:07] <timotimo> a bit crufty still, but it seems to work and handle at least some wacky cases

[15:07] <masak> well, yes, actually.

[15:07] <masak> if I use tabs to indent everything, Rakudo doesn't remove the indent.

[15:07] <masak> hm, let me see if I can reproduce this nicely from within Rakudo...

[15:08] *** ssutch joined
[15:08] <masak> r: eval "say q:to/E/;\n\tfoo\n\tbar\n\tE"

[15:08] <camelia> rakudo bb86d1: OUTPUT«       foo␤       bar␤␤»

[15:08] * masak submits rakudobug

[15:09] <masak> probably a bug in .indent :/

[15:09] <masak> n: eval "say q:to/E/;\n\tfoo\n\tbar\n\tE"

[15:10] <camelia> niecza v24-88-g1f87209: OUTPUT«foo␤bar␤␤»

[15:11] <timotimo> oh, i recently touched that code and may have b0rked it :(

[15:11] <masak> if so, then we're missing at least one test.

[15:12] <timotimo> yes, it knows nothing about tabs

[15:12] <timotimo> it will just look at nqp::chars of the match of <ws>

[15:13] <timotimo> nqp: say(nqp::subst("\t", "\t", nqp::x(" ", 8)))

[15:13] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op call (source text: "nqp::subst(\"\\t\", \"\\t\", nqp::x(\" \", 8))"): Error while compiling op subst (source text: "nqp::subst(\"\\t\", \"\\t\", nqp::x(\" \", 8))"): No registered operation handler for 'subst'␤current in…

[15:14] <timotimo> nqp: "\t    \t" ~~ /(\t)/; say($/[0]);

[15:14] <camelia> nqp: OUTPUT«Null PMC access in get_pmc_keyed_int()␤current instr.: '' pc 134 ((file unknown):146774728) (/tmp/71CUNNSoMg:1)␤»

[15:14] <timotimo> nqp: "\t    \t" ~~ /(\t)/; say($/0);

[15:14] <camelia> nqp: OUTPUT«Confused at line 2, near "say($/0);"␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[15:14] <timotimo> nqp: "\t    \t" ~~ /(\t)/; say($0);

[15:14] <camelia> nqp: OUTPUT«Confused at line 2, near "say($0);"␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[15:14] <timotimo> hm.

[15:15] <timotimo> what's the sanest way to count occurences of a char in a string in nqp?

[15:16] <timotimo> nqp: for ^5 { say "a" }

[15:16] <camelia> nqp: OUTPUT«Confused at line 2, near "for ^5 { s"␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[15:16] <timotimo> nqp: for 1..5 { say "a" }

[15:16] <camelia> nqp: OUTPUT«Missing block at line 2, near "..5 { say "␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[15:16] <timotimo> right.

[15:17] <timotimo> rakudo: say $?TABSTOP;

[15:17] <camelia> rakudo bb86d1: OUTPUT«8␤»

[15:18] <timotimo> i'll have to look up that name in $*W, don't i?

[15:18] *** gtodd joined
[15:19] <masak> think so.

[15:19] *** birdwindupbird left
[15:30] *** jaldhar left
[15:30] *** xinming left
[15:32] *** xinming joined
[15:33] *** jaldhar joined
[15:34] <masak> "We have an employee whose last name is Null." http://stackoverflow.com/questions/4456438/how-can-i-pass-the-string-null-through-wsdl-soap-from-as3-to-coldfusion-web?rq=1

[15:35] <FROGGS> CDATA would work, no?

[15:35] <FROGGS> but it is funny anyway :o)

[15:35] <gtodd> wow

[15:35] <masak> there are so many ways to fail it.

[15:36] <masak> still, you should be allowed to have "Null" as a last name.

[15:36] <gtodd> Maybe change it to Nüll :)

[15:38] *** sqirrel left
[15:39] <timotimo> my patch seems to be working fine.

[15:42] <FROGGS> timotimo++

[15:44] *** isBEKaml joined
[15:45] <frettled> masak: brilliant :D

[15:46] <masak> gtodd: excellent süggestion! :)

[15:46] <frettled> I think he had a nice solution, given his constraints: «to resolve this I created a structure and passed the parms as part of that object»

[15:47] <frettled> It's similar to what I do with P5 when parameters spread forth and multiply; I go from list to hash.

[15:48] <masak> frettled: the problem feels like a kind of semipredicate problem to me.

[15:49] <isBEKaml> Nüll? Is that guy anywhere near scandinavian? :)

[15:49] <frettled> masak: there's an answer by Reboog711 further down that seems to explain why this is a problem.

[15:49] <arnsholt> Yeah, it's an easy problem to hit if your protocol is text-based

[15:49] <gtodd> Nułł

[15:52] *** kaleem left
[15:53] <masak> gtodd: Ñull

[15:54] <timotimo> nqp: say(nqp::substr("foo bar", 1))

[15:54] <camelia> nqp: OUTPUT«oo bar␤»

[15:54] <masak> frettled: found it. nice.

[15:54] <timotimo> that would explain why that didn't work out properly, heh.

[15:55] <isBEKaml> Funny, both Reboog711 and the op (bill) went AWOL after fiddling with it. Sick due to handling this issue, perhaps? :D

[15:57] *** cognominal left
[15:57] <mathw> I'm in awe of the wrongness in the encoding method

[15:57] <mathw> I think if I ran into that problem in my code I'd cry

[16:00] <dalek> roast: 978e4a8 | (Timo Paulssen)++ | S02-literals/heredocs.t:

[16:00] <dalek> roast: add tab tests for heredocs

[16:00] <dalek> roast: review: https://github.com/perl6/roast/commit/978e4a8ac1

[16:01] <timotimo> pull request'd at number 189

[16:02] <timotimo> the only failure mode i can think of now is when somebody sets $?TABSTOP to a ridiculous value, like -1 or 0

[16:03] *** xilo joined
[16:07] *** cognominal joined
[16:08] *** mj41 left
[16:08] *** isBEKaml left
[16:10] <masak> timotimo: DIHWIDT

[16:10] <timotimo> not quite sure what should be done at that point; it doesn't really make sense to me to allow a user to assign those weird kinds of values

[16:11] <timotimo> i don't know how to interpret that, masak :| (i do know what it expands to, though)

[16:11] <timotimo> oh wait

[16:11] <timotimo> yes, i do know how to interpret that

[16:11] <masak> timotimo: I mean, if someone does that, they had it coming.

[16:11] <masak> timotimo: we could be user-friendly about their stupidity, but that feels like a future concern.

[16:13] <[Coke]> r: $?TABSTOP = Inf;

[16:13] <camelia> rakudo bb86d1:  ( no output )

[16:13] <[Coke]> r: $?TABSTOP = NaN;

[16:13] <camelia> rakudo bb86d1:  ( no output )

[16:13] <[Coke]> r: $?TABSTOP = Int;

[16:13] <camelia> rakudo bb86d1:  ( no output )

[16:14] *** btyler left
[16:15] <moritz> somehow gists complain about a JS error in firefox

[16:16] <moritz> s/gists/pull requests/

[16:24] <masak> "For every benefit, there's usually a drawback." -- http://i.imgur.com/4JhVbiV.png -- sounds isomorphic to masak's law. :)

[16:24] *** btyler joined
[16:26] *** bluescreen10 joined
[16:29] <gtodd> masak:  I guess if people change their names to accomodate xml it's sort of like the way people's names get changed when they immigrate ...

[16:30] *** rindolf left
[16:30] <[Coke]> gtodd: that's how I got my last name, aye.

[16:30] <arnsholt> "Welcome to the Democratic Republic of XML. Here's your new XML-compliant name." ^_^

[16:32] <daxim> arnsholt =~ /$XML::RegExp::NCName/

[16:34] <moritz> so, what was the drawback of Hermione using the time turner?

[16:35] <timotimo> she got older too quickly?

[16:37] <moritz> that's not apparent from reading this blurb

[16:37] * timotimo didn't read the page at all

[16:40] * moritz has a working rakudo on irclog.perlgeek.de o/

[16:40] <FROGGS> cool!

[16:40] <moritz> seems that 2GB RAM on an otherwise pretty minimal system are enough

[16:42] <moritz> panda is next.

[16:46] <moritz> ... and now NativeCall bombs :(

[16:47] <[Coke]> is that the zavolaj bug?

[16:47] <[Coke]> https://github.com/jnthn/zavolaj/issues/28  ?

[16:47] <moritz> aye

[16:48] <masak> moritz: nono, the "drawback" was for JKR because she introduced a device into her universe which was too powerful and would disturb further plots too much. so she essentially killed off the device by smashing all time-turners in existence.

[16:48] <masak> (similarly, a WAT is something a user suffers from, but as language designers we're primarily interested in the language deisgner's suffering)

[16:49] <masak> perhaps most importantly, WATs tend to hinder feature composability.

[16:49] <lizmat> or other godlike suffering

[16:50] <arnsholt> moritz: You can force the install and most functionality will work. But the broken stuff remains broken, of course

[16:50] <masak> yes, godlike suffering is the common denominator between fiction devices and PL design.

[16:50] *** raiph joined
[16:51] <daxim> that reminds me to catch up with hpmor

[16:51] <arnsholt> Speaking of time-turners, I'm in principle opposed to any plot involving time travel

[16:51] <arnsholt> It's just too easy to mess up

[16:51] <moritz> arnsholt: me too, but IMHO it's still real fun in HPMoR

[16:51] <masak> arnsholt: do you say that as someone having read HPMoR or not?

[16:51] <arnsholt> Haven't read HPMoR =)

[16:51] <daxim> how did you like The City on the Edge of Forever?

[16:51] *** benabik left
[16:51] <masak> arnsholt: because IMO EY does a *really* good job of it.

[16:51] <arnsholt> Cool

[16:52] *** Mouq joined
[16:52] <arnsholt> Least messed up example I can think of right now is Babylon 5, and even that wasn't a highlight of the series

[16:52] <masak> arnsholt: this is the kind of author that asks (around chapter 7 or 8) what if I can use time-turners as a Turing oracle and *tests it*.

[16:52] <moritz> (and the time travel in HPMoR has clear limits, and the serious opponents understand them)

[16:52] *** benabik joined
[16:53] <dalek> ufo: 027fa5a | moritz++ | bin/ufo:

[16:53] <dalek> ufo: fix infinite recursion in dirwalk

[16:53] <dalek> ufo: 

[16:53] <dalek> ufo: also remove two redundant tests

[16:53] <dalek> ufo: review: https://github.com/masak/ufo/commit/027fa5a224

[16:54] <masak> moritz++

[16:54] <timotimo> thanks!

[16:57] <arnsholt> daxim: Haven't read that one either =)

[16:57] <daxim> it's an award winning star trek episode, find yourself a copy

[16:59] *** vk_ joined
[17:03] <arnsholt> Aha. I'll try to do that

[17:03] *** dakkar left
[17:04] <jercos> moritz: DO NOT MESS WITH TIME TRAVEL :p

[17:06] *** spider-mario joined
[17:11] <dalek> zavolaj/fix-rw-issues: c213a99 | moritz++ | lib/NativeCall.pm6:

[17:11] <dalek> zavolaj/fix-rw-issues: do not use autogenerated accessors of type CStr

[17:11] <dalek> zavolaj/fix-rw-issues: 

[17:11] <dalek> zavolaj/fix-rw-issues: they cause all sorts of weird issues.

[17:11] <dalek> zavolaj/fix-rw-issues: Now the error message changes :-)

[17:11] <dalek> zavolaj/fix-rw-issues: review: https://github.com/jnthn/zavolaj/commit/c213a9959a

[17:12] *** kaleem joined
[17:13] *** btyler left
[17:16] <colomon> didn't Harlan Ellison write that one?

[17:16] <colomon> (City on the Edge of Forever, that is)

[17:17] *** kaleem left
[17:18] <masak> hm. in Python, class definitions do not have BEGIN semantics.

[17:18] <moritz> in this branch in zavolaj, I now get

[17:18] <moritz> Cannot call 'AUTOGEN'; none of these signatures match:

[17:18] <moritz> :(CStr : Str:D $encoding, Mu *%_) in method AUTOGEN at src/gen/CORE.setting:510

[17:19] <moritz> which seems to be about auto-generating a proto

[17:20] <arnsholt> moritz: That's the new error message?

[17:23] <arnsholt> I've been meaning to bisect this, find out which commit is the culprit

[17:23] <arnsholt> It just takes so long, and I'm a bit tuit starved

[17:24] <huf> today i once again realized how incredibly awesome map and hashes are in perls :)

[17:24] <daxim> you're easily amused

[17:24] <huf> i'm writing js at the moment, so yes.

[17:25] <masak> JavaScript has both map and hashes.

[17:25] <moritz> our proto method AUTOGEN(::T $: |) { * }

[17:25] <moritz> why does that use a type capture?

[17:26] *** leont left
[17:26] <huf> masak: but you cant do the equivalent of my %hoh = map { $_->{foo} => $_ } @aoh;

[17:26] <lizmat> to be able to generate the right proto ?

[17:26] <Mouq> Are hashes actually distinct from objects?

[17:27] <huf> that is, you need some other special kind of map for this, one generic map wont do

[17:27] <moritz> lizmat: but where is that type capture used?

[17:27] <masak> huf: ah -- so you like the fact that arrays and hashes are plastically assignable to each other in Perl? :)

[17:27] <huf> masak: _definitely_

[17:27] <huf> i miss it every day in nonperls :)

[17:28] <lizmat> moritz: no idea, out of my league there

[17:29] <masak> huf: I kinda like that too.

[17:29] <masak> huf: granted, if you miss it in JS, you can probably create your own custom map that will do that for you.

[17:29] <moritz> or just a separate list-to-hash sub or method

[17:30] <huf> aye, if we agree on a what a pair is, sure

[17:30] <huf> and i can hide the loop 

[17:33] <Mouq> Yeah, trying to do it in console now. Not fun. Perl please

[17:33] <masak> huf: an [x, y] array could easily emulate a pair.

[17:34] <masak> and yes, the implementation of your alternative map would hide the loop, just as the normal map does.

[17:34] <dalek> perl6-roast-data: 9e49943 | coke++ | / (5 files):

[17:34] <dalek> perl6-roast-data: today (automated commit)

[17:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/9e499435d4

[17:35] <[Coke]> # of rakudo.parrot failures monotonically increasing. :|

[17:35] <daxim> shortest I could come up with:  var fnord = {};  [ { foo: 23}, { foo: 42 } ].map(function(h) { fnord[h.foo] = h })

[17:36] <daxim> types and mutating vars poo

[17:36] <huf> no i like the one with an extra function called pairlist_to_object()

[17:36] <huf> but i like it even better without! :)

[17:39] <masak> huf: Array.prototype.hashmap = function (fn) { var o = {}; for (var e in this) { if (!this.hasOwnProperty(e)) { continue }; var pair = fn(this[e]); o[pair[0]] = pair[1]; }; return o }

[17:39] <masak> huf: [1, 2, 3].hashmap(function(e) { return [ "A" + e, e ] })

[17:39] <masak> (returns {A1: 1, A2: 2, A3: 3} )

[17:40] <huf> yes, i know that works, but my original grief was the proliferation of slightly different maps :)

[17:40] <huf> oh well, js is what it is, at least it's fixable in a fairly painless manner 

[17:41] <masak> Mouq: no, hashes are not distinct from objects. that is, instances of the Object type in JS are all hashes.

[17:41] <masak> (but they are hashes with a prototype pointer, which makes quite a big difference for hash lookup)

[17:41] <lizmat> Red2&

[17:41] <masak> huf: sometimes it amazes me how fixable JavaScript is.

[17:41] <huf> :)

[17:42] <masak> I think that's part of its success.

[17:42] <huf> there's very little of it at heart, so yeah

[17:42] <GlitchMr> Objects as dictionaries are broken IMO in JS

[17:42] <huf> some of what's there is seemingly idiotic but the community's found ways around that :)

[17:42] <masak> I wonder if JavaScript isn't the metacirculariest of the mainstream languages, after all.

[17:42] <GlitchMr> To begin with, you cannot have __proto__ property in object used as dictionary.

[17:43] <masak> GlitchMr: that seems like a rather minor problem.

[17:43] <GlitchMr> (but that's issue with non-IE JS implementations)

[17:44] <masak> GlitchMr: that's like pointing to where the optical nerve meets the retina, and exclaiming "look! broken!"

[17:44] <masak> and yet the eye sees.

[17:44] <GlitchMr> Without strange issues

[17:44] <GlitchMr> --

[17:44] <GlitchMr> [19:44:06.078] ({__proto__: [1, 2, 3]}).length

[17:44] <GlitchMr> [19:44:06.081] 3

[17:44] <huf> it _is_ broken though!

[17:44] <masak> yes, of course it is.

[17:44] <huf> the fact that evolution forced a workaround that's fairly good is just our luck :)

[17:44] <GlitchMr> Workaround - define a hash object, with .set and .get methods.

[17:44] <masak> there are hundreds of eye designs out there. I don't know how many of them suffer from the optical nerve bug.

[17:45] <GlitchMr> When using these, they would prepend a character such as ~, to avoid any problems.

[17:45] <huf> octopus eyes are done the right way around iirc

[17:45] <huf> and yet, we hunt them :)

[17:45] <huf> (unless it's silly movie week)

[17:45] <masak> my point exactly.

[17:46] <GlitchMr> And if you set __proto__ property of object to something that isn't object, nothing happens.

[17:46] <masak> for the purpose of the discussion, let's assume it's not silly movie week.

[17:46] <GlitchMr> And by nothing, I mean that you don't get an exception, and property isn't assigned.

[17:46] <masak> GlitchMr: I'm not sure why you're upset at all this. it's a meta-thing, and you're kicking at it as if it were a thing.

[17:47] <masak> GlitchMr: it's also not news that JavaScript doesn't have a perfect design.

[17:47] <GlitchMr> It's an issue when you use keys from user.

[17:49] <GlitchMr> I'm not aware of any other language having such issues with dictionaries.

[17:49] <dalek> rakudo-star-daily: d6fc913 | coke++ | / (2 files):

[17:49] <dalek> rakudo-star-daily: log versions used in building this star candidate

[17:49] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/d6fc913c4d

[17:49] <GlitchMr> Also, `in` operator in JavaScript is useless because it also notices keys like... `constructor`.

[17:49] <GlitchMr> Oh, and __proto__ is magical, even with Object.create(null).

[17:50] <masak> still don't quite see your beef here.

[17:50] <masak> maybe I'm just too used to JavaScript at this point ;)

[17:50] <huf> GlitchMr: you know php demonstrates every problem like this...

[17:51] <GlitchMr> Actually, it seems that in Firefox, Object.create(null) doesn't have magical __proto__, but in V8, it does...

[17:51] <masak> if your need is so strong to store a '__proto__' property, then may I ask what your problem domain is? implementing JavaScript in JavaScript?

[17:51] <GlitchMr> Security, perhaps?

[17:52] <huf> unsanitized userinput in hashes? what could possibly go wrong :)

[17:53] <masak> what huf said.

[17:54] <masak> if user input is your concern, then you've got bigger problems to worry about.

[17:54] <huf> on the other hand, this is often done. as we saw with the slew of hashing related bugs found in various scriptlangs

[17:57] <GlitchMr> huf: https://github.com/joyent/node/issues/1707

[17:57] <GlitchMr> this could go wrong

[17:58] <GlitchMr> HTTP server in Node.js could be once crashed by /foo?hasOwnProperty=x

[17:59] <huf> :)

[18:00] *** daxim left
[18:01] <GlitchMr> Programming language should be safe by default

[18:02] <Mouq> Off topic; what does :fiddly mean? All I see is https://github.com/perl6/std/blob/master/STD.pm6#L3333

[18:02] <GlitchMr> It means it cannot be used with reduce if I remember correctly

[18:03] <Mouq> Huh. Okay thx

[18:04] <GlitchMr> [,] just wouldn't make much sense

[18:05] <Mouq> r: [,] 1,2,3

[18:05] <camelia> rakudo bb86d1:  ( no output )

[18:05] <GlitchMr> std: [,] 1, 2, 3

[18:05] <camelia> std c2215f0: OUTPUT«ok 00:00 43m␤»

[18:05] <Mouq> oh, duh

[18:06] <Mouq> r: say [,] 1,2,3

[18:06] <camelia> rakudo bb86d1: OUTPUT«1 2 3␤»

[18:06] <GlitchMr> std: 1 X, 2

[18:06] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[18:06] <GlitchMr> Perhaps I confused it with something else

[18:06] <GlitchMr> http://olive.undo.it/log?channel=perl6&search=fiddly

[18:06] <GlitchMr> Interesting.

[18:07] *** cognominal left
[18:07] <GlitchMr> rn: my $x; 5 R:= $x; say $x

[18:07] *** cognominal joined
[18:07] <camelia> rakudo bb86d1: OUTPUT«Nominal type check failed for parameter 'op'; expected Any but got Mu instead␤  in sub METAOP_REVERSE at src/gen/CORE.setting:15112␤  in block  at /tmp/ZMWM_C9Rzp:1␤␤»

[18:07] <camelia> ..niecza v24-88-g1f87209: OUTPUT«===SORRY!===␤␤Cannot reverse the args of := because list assignment operators are too fiddly at /tmp/R7iuezE3NV line 1:␤------> my $x; 5 R:=⏏ $x; say $x␤␤This macro cannot be used as a function at /tmp/R7iuezE3NV line 1…

[18:10] <Mouq> r: [??] 1, 2, [!!] 4, 5, 6  # heh

[18:10] <camelia> rakudo bb86d1: OUTPUT«===SORRY!===␤Bogus statement␤at /tmp/bWp7rDzpof:1␤------> [??⏏] 1, 2, [!!] 4, 5, 6  # heh␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        infix stopper␤        infix or m…

[18:11] <Mouq> I suppose that wouldn't work anyway

[18:11] <masak> nope.

[18:12] <Mouq> :p

[18:12] <masak> n: [==>] 1, 2, 3

[18:12] <camelia> niecza v24-88-g1f87209: OUTPUT«===SORRY!===␤␤Cannot reduce with ==> because sequencer operators are too fiddly at /tmp/1jZ0VIXEFK line 1:␤------> [==>]⏏ 1, 2, 3␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1…

[18:12] <masak> I don't really see why comma gets a :fiddly in STD, though.

[18:14] <Mouq> It doesn't even look like :pure is used

[18:14] <GlitchMr> :pure is optimization

[18:14] <GlitchMr> Not used by STD

[18:14] <GlitchMr> It means "no side effects".

[18:15] <Mouq> Ah, and here I was thinking it was to see if they got to go to op heaven

[18:16] <GlitchMr> By the way, "is pure" exists in Rakudo

[18:16] <GlitchMr> It means the function is allowed to be done compile time.

[18:17] <GlitchMr> r: sub magic is pure { say "Hello, world!" }; if False { my $magic = magic }

[18:17] <camelia> rakudo bb86d1: OUTPUT«Hello, world!␤»

[18:17] <masak> Mouq++ # "op heaven" :)

[18:17] <GlitchMr> (well, this is "is pure" abuse, but still)

[18:17] *** SamuraiJack_ joined
[18:17] <masak> GlitchMr: your examples are very confusing when they do the exact opposite of the thing you're showing.

[18:17] <GlitchMr> I mean, "magic" looks like a sheep, but is actually evil function with side effects.

[18:17] <Mouq> That's awesome

[18:18] <masak> r: my $global = 0; sub magic is pure { $global = 42 }; if False { magic }; say $global

[18:18] <camelia> rakudo bb86d1: OUTPUT«0␤»

[18:18] <masak> huh :)

[18:18] <GlitchMr> I lied the function doesn't have side-effects to show "pure" can be optimized during compilation.

[18:18] <GlitchMr> r: my $global = 0; sub magic is pure { $global = 42 }; if False { my $magic = magic }; say $global

[18:18] <camelia> rakudo bb86d1: OUTPUT«0␤»

[18:19] <GlitchMr> huh?

[18:19] <GlitchMr> Actually, that makes sense

[18:19] <GlitchMr> r: my $global; sub magic is pure { $global = 42 }; if False { my $magic = magic }; say $global

[18:19] <camelia> rakudo bb86d1: OUTPUT«42␤»

[18:19] <GlitchMr> $global = 0 is ran after $global = 42

[18:19] <masak> oh!

[18:19] <masak> yes.

[18:19] <masak> GlitchMr++

[18:19] <Mouq> GlitchMr++

[18:20] <GlitchMr> Still, "is pure" shouldn't be used for functions with side-effects.

[18:20] <masak> I wouldn't have been upset with the optimizer if it just winked the 'if False' block out of existence, though.

[18:20] <moritz> right, by saying "is pure" when it's not pure you're lying to the compiler

[18:20] <masak> right.

[18:20] <masak> so 'magic' should've been called 'DIHWIDT' ;)

[18:22] <GlitchMr> I guess I did something as evil as outputing text in object destructor.

[18:23] *** rindolf joined
[18:24] *** colomon left
[18:29] *** grondilu joined
[18:30] *** colomon joined
[18:30] <grondilu> what's this 'will' trait and where is it documented? (it's not an easy word to grep in the doc)

[18:32] <timotimo> http://perlcabal.org/syn/S14.html#Traits - i think

[18:32] <timotimo> actually http://perlcabal.org/syn/S06.html#Subroutine_traits

[18:32] <timotimo> http://perlcabal.org/syn/index_C.html <- found it here

[18:35] <masak> 'is pure' feels kinda like the opposite of 'is thunky' :)

[18:36] *** zby_home joined
[18:37] *** pnu left
[18:38] *** pnu joined
[18:42] <GlitchMr> r: sub destruction is destructive { 2 + 2 } say destruction

[18:42] <camelia> rakudo bb86d1: OUTPUT«===SORRY!===␤Can't use unknown trait 'is destructive' in a sub declaration.␤at /tmp/ZoPo9nS68X:1␤------> ␤    expecting any of:␤        rw parcel hidden_from_backtrace␤        pure default DEPRECATE inlinable␤        prec equiv tighter looser asso…

[18:42] <GlitchMr> r: sub destruction is DEPRECATE is hidden_from_backtrace { 2 + 2 } say destruction

[18:42] <camelia> rakudo bb86d1: OUTPUT«===SORRY!===␤Can't use unknown trait 'is DEPRECATE' in a sub declaration.␤at /tmp/5CCjaqyR_f:1␤------> ␤    expecting any of:␤        rw parcel hidden_from_backtrace␤        pure default DEPRECATE inlinable␤        prec equiv tighter looser assoc␤…

[18:42] <GlitchMr> r: sub destruction is hidden_from_backtrace { 2 + 2 } say destruction

[18:42] <camelia> rakudo bb86d1: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/CAttloC_zd:1␤------> tion is hidden_from_backtrace { 2 + 2 } ⏏say destruction␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modif…

[18:42] <GlitchMr> r: sub destruction is hidden_from_backtrace { 2 + 2 }; say destruction

[18:42] <camelia> rakudo bb86d1: OUTPUT«4␤»

[18:43] <GlitchMr> r: sub destruction is hidden_from_backtrace { 2 + 2; die "no" }; say destruction

[18:43] <camelia> rakudo bb86d1: OUTPUT«no␤  in block  at /tmp/EvMQLDgK8B:1␤␤»

[18:43] <GlitchMr> r: sub destruction{ 2 + 2; die "no" }; say destruction

[18:43] <camelia> rakudo bb86d1: OUTPUT«no␤  in sub destruction at /tmp/riatEaYh_b:1␤  in block  at /tmp/riatEaYh_b:1␤␤»

[18:44] *** fgomez joined
[18:50] *** konundra joined
[18:51] *** btyler joined
[19:00] <dalek> rakudo-star-daily: 28e7785 | coke++ | log/ (5 files):

[19:00] <dalek> rakudo-star-daily: today (automated commit)

[19:00] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/28e77857ff

[19:01] <[Coke]> whoever asked for the specific shas being used, see:

[19:01] *** Mouq left
[19:01] <[Coke]> https://github.com/coke/rakudo-star-daily/blob/master/log/version.log

[19:02] *** Mouq joined
[19:03] <masak> today's autopun spotting: https://twitter.com/bethcodes/status/362706081811673088/photo/1

[19:04] <Mouq> lol

[19:06] <PerlJam> masak: nice.

[19:06] *** huf left
[19:08] <FROGGS> hehe

[19:10] *** rindolf left
[19:15] *** SamuraiJack_ left
[19:25] *** lue joined
[19:25] <lue> hello! o/

[19:26] <FROGGS> hi lue

[19:31] * timotimo still fondly remembers the time where he thought it was called "the mythical man-moth"

[19:32] <Mouq> I'm not sure how useful I'll be, but if I'm a free hand, where should I apply myself (in #perl6's opinion)?

[19:32] <masak> lue! \o/

[19:33] <masak> Mouq: any non-negative contribution is useful, if you ask me.

[19:33] <moritz> Mouq: a good start would be to write code that you use regularly

[19:33] <moritz> Mouq: and if you discover that you need a module for that task which doesn't exist yet, write it

[19:34] <masak> Mouq: solve problems that interest you. learn things that interest you. find bugs along the way. publish modules.

[19:34] <diakopter> masak: how is "non-negative" different from "useful"

[19:34] <masak> Mouq: complain loudly when you fall down a hole due to missing documentation or bad error messages :)

[19:34] <moritz> diakopter: funny stuff is non-negative, but usually not useful

[19:34] <masak> contradicting my statement ;)

[19:35] <diakopter> .. but masak.. yeah

[19:35] <masak> I guess some negative things can be useful, too.

[19:35] <Mouq> Okay, will do :) Thanks

[19:35] <diakopter> Mouq: what kinds of things do you like to program

[19:37] <Mouq> I don't really have a focused direction that I'm aware of. Currently using perl to simulate some things

[19:37] *** kaare_ left
[19:40] *** zby_home left
[19:45] *** jaldhar left
[19:54] <masak> Mouq: we find the biggest determinant to positive contribution is if the contributor is happy. so do something you enjoy. :)

[19:54] <masak> I can almost guarantee we'll benefit from it, too.

[19:55] *** crab2313 left
[19:55] <diakopter> masak: so.. what are his choices? :)

[19:56] <masak> well, there are several places to start.

[19:56] <Mouq> Right now I'm looking into implementing Math::Vector::kdTree (I'm quite fond of SALVA's Math::Vector::Real modules)

[19:56] <masak> ooh

[19:56] <Mouq> Oop, go ahead :p

[19:57] <masak> small scripts. reading the spec. looking at RT tickets and trying to reproduce them. just talking about OO or something else on channel.

[19:57] <masak> turning a joke on-channel into code.

[19:57] <masak> (I've found dozens of rakudobugs that way!)

[19:57] <Mouq> diakopter: I saw your grant proposal on TPF. I wish you the best of luck!

[19:58] <masak> reading other people's module code, thinking of ways to either use that code, or improve it.

[19:58] <diakopter> cool; thanks. I hope there's no impediment to acceptance and completion

[19:58] <masak> reading the list of modules, thinking about what's missing.

[19:58] <diakopter> .. what's missing from what?

[19:58] <diakopter> what list of modules?

[19:59] <FROGGS> diakopter: our ecosystem

[20:00] <diakopter> .. we has an ecosystem?

[20:00] <lue> diakopter: https://github.com/perl6/ecosystem

[20:01] <FROGGS> diakopter: sort of :o)

[20:02] <diakopter> it was my impression that only a handful of the modules on modules.perl6.org still worked

[20:03] <FROGGS> that might be true

[20:03] <diakopter> [maybe I had a very wrong impression]

[20:03] <FROGGS> no, I think you are right

[20:04] *** raiph left
[20:06] <diakopter> Mouq: do you use the XS version of Math::Vector::Real?

[20:06] <Mouq> yup

[20:07] <diakopter> do you have an idea of how much slower the pure-perl one is? [I have no idea]

[20:07] <diakopter> [I also have no idea whether it matters]

[20:07] <Mouq> ...nope

[20:09] <[Coke]> we had a thing that would run once a day to report on whether or not it was passing tests, but it ... broke, I think.

[20:09] <[Coke]> s/it was /all of them were /

[20:11] <pmurias> diakopter: one question about the moarvm-perl5-interop-grant wouldn't it be better to first do the interop on the jvm and then port it to moarvm?

[20:11] <[Coke]> aside: it's not like the jvm port is that far ahead of the moarvm port.

[20:12] <pmurias> how much of the spectest does moarvm run?

[20:12] <[Coke]> I mean, sure, it's passing nearly 100% of the tests, but ... hurm, perhaps it really is that much further ahead. never mind. :)

[20:13] <[Coke]> as I understand it, though, moarvm is where the jvm port was about 2 weeks before it started passing spectests.

[20:15] <masak> last I heard, moarvm passes "most of the nqp tests".

[20:16] <FROGGS> it failes just a handfull nqp and hll test files AFAIK

[20:17] *** sidus left
[20:17] <pmurias> masak: bootstrapped?

[20:17] <FROGGS> pmurias: I'd say for p5interop it helps that you can design the needed primitives in C land

[20:18] <FROGGS> pmurias: that is the next big goal

[20:18] <masak> pmurias: I don't know. maybe ask on #moarvm?

[20:18] <masak> pmurias: or just wait till jnthn comes back ;)

[20:18] <benabik> It's not bootstrapped yet, although IIRC jnthn at least stubbed in the required bits before he left.

[20:18] <FROGGS> true

[20:19] <FROGGS> we are really just a few weeks away from that... (by 'we' I mean jnthn++ :o)

[20:20] * masak .oO( we all mean 'jnthn' by 'we'... ) :P

[20:21] <FROGGS> *g*

[20:22] <FROGGS> I hope he enjoys the Alps

[20:24] <masak> he deserves Alps...

[20:24] <grondilu> what are the prospects about MoarVM as far as speed is concerned?  How will it likely compare to parrot and JVM?

[20:24] *** BenGoldberg joined
[20:25] <benabik> There are definite advantages to having a VM designed for your purposes instead of having to deal with layers of interop.

[20:26] <FROGGS> grondilu: we all hope that it will be awesome fast, but I think it is too early to tell

[20:26] *** leont joined
[20:27] <BenGoldberg> In spite of having just joined today and not having looked at the irclog, my psychic powers are telling me that we're discussing moarvm?

[20:27] <BenGoldberg> :)

[20:27] <pmurias> yes

[20:27] <masak> it's too early to tell.

[20:27] <FROGGS> I mean, I've seen a microbenchmark diakopter++ did where you can see that it is more than four times faster than nqp@parrot, but I'd wait for rakudo@moarvm benchmarks

[20:27] <PerlJam> grondilu: my completely uninformed guess is that it will be mostly faster than parrot all around and initially slower than jvm for execution but faster than jvm on startup.

[20:27] <benabik> I would bet notably faster than Parrot...  JVM it's harder to tell.

[20:27] <masak> JVM is crazy optimized.

[20:27] <masak> not just Java, but the bytecode.

[20:28] <diakopter> FROGGS: well, to be precise, that microbenchmark (fib.) wasn't nqp-on-moarvm; it was handwritten moarvm bytecode essentially

[20:28] <benabik> But NQP/Rakudo also have to deal with extra layers for nearly everything AFAICT.

[20:28] <masak> the JIT has man-decades of effort poured into it.

[20:28] <diakopter> (analogous to pir)

[20:28] <diakopter> so, it was comparing the frontier of what you could expect an optimizer able to optimize to

[20:29] <FROGGS> diakopter: that makes it a single microbenchmark :o)

[20:29] <diakopter> (without any native machine code generation)

[20:29] <diakopter> obviously with machine code it could potentially outperform luajit^Wpotion

[20:29] <FROGGS> I know one killer feature MoarVM has and JVM has not... any guesses?

[20:30] <diakopter> hrm.

[20:30] <diakopter> C vs C++?

[20:30] <PerlJam> FROGGS: an awesome dev team?  ;)

[20:30] <FROGGS> no

[20:30] <FROGGS> hehe

[20:30] <FROGGS> no

[20:30] <masak> ponies?

[20:30] <FROGGS> no

[20:30] <masak> actually killers?

[20:30] <masak> actual*

[20:30] <FROGGS> almost

[20:30] <PerlJam> FROGGS: smaller footprint?

[20:30] <BenGoldberg> Why are there no ponies? :)

[20:30] <FROGGS> no

[20:30] <FROGGS> chdir()

[20:31] <FROGGS> how do we handle the lack of it @JVM?

[20:31] <diakopter> we talked about how to emulate it the other day

[20:32] <diakopter> it's not too hard, as long as you control every entry from bytecode to native libraries

[20:32] <grondilu> FROGGS: a meta model (sounds too easy)

[20:32] <grondilu> ?

[20:32] <BenGoldberg> JVM also doesn't have getpid(), iirc

[20:33] <[Coke]> there are java tools that can tell you that information, so it's doable, I think.

[20:33] <FROGGS> BenGoldberg: but I'd guess that chdir is used moar often

[20:33] <BenGoldberg> You can fake it in a platform dependent way, on some platforms

[20:33] <pmurias> wouldn't it be possible to implement this things by calling native code?

[20:33] <[Coke]> there's always JNI. *shudder*

[20:33] <pmurias> s/this/those/

[20:33] * grondilu finally notices the answr was chdir

[20:33] <FROGGS> [Coke]: I've heard about unreliable tricks... but something sane would be cool when we start caring about the modules

[20:34] <diakopter> thing is, if you're gonna load native code anyway, you're gonna want to use sun.misc.Unsafe all over the place for speed

[20:38] <diakopter> since you can get order of magnitude improvements in many cases

[20:38] <diakopter> *orders

[20:39] <FROGGS> and since we already do type checks and everything...

[20:39] <diakopter> yeah

[20:39] <pmurias> FROGGS: re unreliable tricks you mean JNI?

[20:40] <FROGGS> pmurias: no, it was something else but I dont remember anymore... I think it was something about a userdir or homedir, but I'm not a Java dev so it is likely that I am wrong

[20:42] *** konundra left
[20:42] <diakopter> FROGGS: did you guys make progress on that void return bug?

[20:43] <FROGGS> diakopter: no

[20:43] <Mouq> What's the standard way to run tests (i.e. in a t/ dir) with perl6? :p

[20:43] <FROGGS> we still just know that $*WANT is unset when it should not

[20:44] <spider-mario> Mouq : ufo is handy

[20:44] <spider-mario> it generates a makefile that has a test target

[20:44] <pmurias> once we have the p5 interop how will one specify if we want real of FROGGS perl5 for 'use v5'?

[20:44] <diakopter> pmurias: it won't use v5

[20:45] <diakopter> you won't use 'use v5' I mean

[20:45] <diakopter> besides, we won't have inline p5 for a long time anyway

[20:45] <FROGGS> well yes and no

[20:45] <diakopter> (that works with the embedded thing anyway, I mean)

[20:46] <pmurias> diakopter: why is inline p5 hard?

[20:46] <FROGGS> pmurias: at the end, you would have "my" grammar, combined with dispatches to the perl 5 interpreter, so there are no two things finally

[20:46] <Mouq> spider-mario: Okay, thank you. I was thinking more along the lines of p5's `prove`

[20:46] <spider-mario> it can be used

[20:46] <spider-mario> but you have to tell it to use perl6 (or rely on the shebang)

[20:46] <diakopter> well, to do it with the embedding thing, we'll need to set up phantom scalarish things to emulate all outer lexicals and namespaces that are visible to the p5 code

[20:47] <PerlJam> Mouq: prove -e perl6 # should do it.

[20:47] <pmurias> FROGGS: I didn't understand that

[20:48] <Mouq> PerlJam: Oh! 'k thx

[20:48] <FROGGS> pmurias: you need to parse the inlined code and do actions while you do that, like registering variables... and after that stage, the code snipped would be executed by libperl5 (or what it might be called)

[20:48] <PerlJam> Mouq: you might need to set PERL6LIB to contain your module's lib dir too 

[20:48] <diakopter> pmurias: he meant that 'use v5' will eventually use froggs' grammar to pre-parse as much as possible (including begin-time stuff perhaps), then call into the p5interop for the mainline

[20:49] <diakopter> pmurias: did you see what I meant about outer lexicals and namespaces?

[20:49] <pmurias> diakopter: yes

[20:49] <diakopter> they'd need to be thigs that, upon STORE and FETCH, actually fetched from the proper outer lexical slots

[20:50] <pmurias> diakopter: I had that problem when thinking about 'use v5' for mildew

[20:50] <FROGGS> if you just load a Perl 5 module like: use JSON::XS:from<Perl5>, then there is much less trouble

[20:50] <diakopter> pugs emulated this by wrapping with declared lexicals, then syncing upon return

[20:50] <diakopter> but for concurrent code, that doesn't work.

[20:50] <pmurias> diakopter: I didn't figure out a better solution then you are proposing

[20:50] <diakopter> pmurias: nope, I don't think there is a better one

[20:51] <diakopter> interestingly, if you set them up as tied variables in p5 that call into xsubs, they don't acdtually have to call into moarvm bytecode

[20:54] <diakopter> er.. pugs used arguments.. duhhhh

[20:54] <diakopter> er.  arguments assigned to lexicals.

[20:54] <diakopter> argh.

[20:57] <Mouq> PerlJam: Yup, thanks

[20:58] *** sidus joined
[21:03] <BenGoldberg> For embedded perl5, what about, instead of setting up (lots and lots of) fake scalarish scalars so that the perl5 code will see the surrounding perl6 variables correctly do the following... in the perl5 compiler, each time a dynamic variable is first used, tie() it, so it will see the appropriate perl6 outer lexical variable or whatever.

[21:04] <pmurias> BenGoldberg: you mean s/dynamic/lexical/

[21:04] <masak> 'night, #perl6

[21:05] <diakopter> BenGoldberg: yes; the problem is you want to be able to use strict

[21:05] <FROGGS> gnight masak 

[21:05] <pmurias> and there is no hook for missing lexical in the perl5 interpreter

[21:05] <pmurias> or at least there wasn't one last time I checked

[21:06] <pmurias> so unless we are using a custom patched version we can't do that

[21:06] <diakopter> pmurias: well, actually, a p5p person said they'd be glad to add whatever hooks we needed

[21:07] <pmurias> if we had such a hook then things should be easier

[21:07] <diakopter> I'm not sure of that particular one, actually.

[21:08] *** Mouq left
[21:08] <pmurias> normally an exception is thrown when no lexical is found

[21:08] <pmurias> so it shouldn't be a bottleneck place

[21:08] <pmurias> besides there shouldn't be a lot of lexicals

[21:08] <diakopter> well it's just you're gonna end up having to have the same sort of references to link names->slots

[21:09] <leont> BenGoldberg: instead of ties, you may want to use proper magic

[21:09] <diakopter> so those would have by-name lookups with each fetch and store

[21:09] <pmurias> well yes

[21:09] <diakopter> but with dedicated lexicals, you dont have by-name lookups at all

[21:10] <pmurias> what do you mean by dedicated lexicals?

[21:10] <diakopter> the scalars tied to p6 lexical slots in closures

[21:11] <pmurias> if we had a lexical hook it could create those scalars when needed

[21:11] <diakopter> but it still wouldn't be using the built-in portion of the p5 compiler that pre-resolves those

[21:12] *** bruges_ joined
[21:12] <pmurias> well those are optimalization matters

[21:13] <pmurias> anything else blocking us as opposed to making things slow?

[21:14] *** bruges left
[21:14] <diakopter> I think the "fake" lexical-scalars would be much easier to implement than an unknown hook that overrode use strict vars

[21:15] <pmurias> yes, emitting some ties seems easier than patching the perl5 interpreter and then making it insert ties at runtime ;)

[21:16] <diakopter> also, would work for everyone and not just bleaders

[21:17] <pmurias> diakopter: determining where the '{use v5;...}' block ends seems tricky but I have been able to do that with some XS

[21:18] <diakopter> pmurias: that's what FROGG's grammar is for, hopefully.

[21:18] <diakopter> hopefully it can run all the BEGIN-time stuff (also by sending those to libperl)

[21:18] <pmurias> that seems really crazy

[21:18] <diakopter> then replace any inner { use v6; ... } blocks with stubs to call them, then send it to libperl

[21:19] <pmurias> why parse the perl5 code twice?

[21:19] *** skids left
[21:19] <diakopter> b/c you really need to remove any inner use v6 blocks

[21:19] *** labster left
[21:20] <diakopter> [to make it work as specified in S01]

[21:20] <pmurias> hmm, we could always 'use v6-rakudo' ;)

[21:20] <diakopter> yeah, but it'd only work in perl >= 5.12

[21:20] <diakopter> er, 5.16

[21:21] <diakopter> which added the parser hooking

[21:21] <pmurias> use v6-rakudo as opposed to 

[21:21] <pmurias> use v6

[21:21] <pmurias> works in older perls

[21:22] <diakopter> but how would p5 parse the p6 code?

[21:22] <pmurias> 'use v6-rakudo;' vs 'use v6;'

[21:23] <pmurias> I don't remember the exact tricks but I made it work for 'use v6-mildew'

[21:23] <pmurias> on 5.10 or something like that

[21:24] <pmurias> https://metacpan.org/module/v6

[21:28] <diakopter> interesting, ok

[21:28] <diakopter> hopefully a source filter..

[21:28] <diakopter> .oO( if we're at position X in the file ..... )

[21:34] <grondilu> not programming to P6 or programming at all:  how do you say "moving forward by doing successive small jumps on a single foot"?

[21:34] <grondilu> s/not programming/not related to programming/

[21:35] <geekosaur> hopping?

[21:35] <grondilu> yes

[21:35] <lizmat> grondilu: variable trait "will foo {…} is described at S04:1454

[21:35] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1454

[21:35] <pmurias> diakopter: it might be possible to use Devel::Declare to support a bare 'use v6', but I need some sleep before I can deal with reading the horrible Devel::Declare documentation

[21:35] <diakopter> I looked at that

[21:36] <grondilu> geekosaur: thanks

[21:36] <diakopter> but really, it should be possible to track the number of { descended *before* reaching the use v6; then inject continuations to the rest of the blocks and } at the end of the srapper, then excise the entire rest of the compilation unit, deferring all of it

[21:36] <diakopter> ... using a source filter

[21:37] <lizmat> diakopter: please don't use a source filter, please

[21:38] <diakopter> yep; FROGGS' grammar would be .. better.

[21:38] <lizmat> please look up why source filters don't work in mod_perl

[21:38] <lizmat> I wouldn't be surprised if MoarVM wouldn't have the same problem

[21:39] <diakopter> lizmat: right, I wasn't serious

[21:39] <lizmat> *phew*

[21:39] <diakopter> well, I was serious it would work, but joking that it'd be a good idea

[21:41] <diakopter> fsvo work.

[21:42] <pmurias> diakopter: it's possible to make the perl 5 parse just return the info where it ended parsing the block, no need to do idiotic things like counting }

[21:43] <diakopter> well, counting { I meant

[21:43] *** spider-mario left
[21:49] *** konundra joined
[21:54] *** labster joined
[21:54] *** lue left
[21:58] *** raiph joined
[21:58] *** labster left
[22:01] <lizmat> r: for 1 { NEXT say "first"; NEXT say "second"} # is this expected behaviour ?

[22:01] <camelia> rakudo bb86d1: OUTPUT«second␤first␤»

[22:04] *** huf joined
[22:05] *** Ben_Goldberg joined
[22:07] *** lue joined
[22:08] *** BenGoldberg left
[22:08] <dalek> roast: 445c5a8 | (Elizabeth Mattijsen)++ | S04-declarations/will.t:

[22:08] <dalek> roast: More variable trait "will" tests

[22:08] <dalek> roast: review: https://github.com/perl6/roast/commit/445c5a819a

[22:09] <lizmat> I dropped the fudged "skip_rest" construct: it was confusing everything too much

[22:09] <lizmat> and on that thought, gnighT #perl6!

[22:10] *** pupoque_ left
[22:11] *** pupoque_ joined
[22:13] *** FROGGS left
[22:14] <timotimo> i was thinking about replacing the type on METAOP_ASSIGN_TEST to Mu instead of Any, so that this works:

[22:14] <timotimo> r: my Mu $foo; $foo //= 1;

[22:14] <camelia> rakudo bb86d1: OUTPUT«Nominal type check failed for parameter 'lhs'; expected Any but got Mu instead␤  in sub METAOP_TEST_ASSIGN:<//> at src/gen/CORE.setting:15104␤  in block  at /tmp/d2WCKcFLI6:1␤␤»

[22:14] <timotimo> but if i allow Mu, i'll break stuff like this:

[22:14] <timotimo> r: say ( 1 & 2 & 3 & Any & Mu ) //= 10

[22:14] <camelia> rakudo bb86d1: OUTPUT«Cannot assign to a readonly variable or a value␤  in sub METAOP_TEST_ASSIGN:<//> at src/gen/CORE.setting:15104␤  in sub thread_junction at src/gen/CORE.setting:2769␤  in block  at src/gen/CORE.setting:2790␤  in method AUTOTHREAD at src/gen/CORE.setting:2780␤  in su…

[22:14] <timotimo> oh?

[22:15] <timotimo> well, i'm not sure if i need to split it into a multi with Any and Mu:U rather than just one candidate with Mu

[22:15] *** labster joined
[22:16] <lizmat> TimToady: should "for 1..2 { my $a=once {$_}; say $a }" say "1 Mu", "1 1" or "1 Any" ?

[22:16] <lizmat> sleep&

[22:17] <lizmat> or even "1 Nil"

[22:17] <lizmat> really sleep&

[22:17] *** dmol left
[22:21] *** vk_ left
[22:30] *** PacoAir left
[22:30] *** sidus left
[22:38] *** raiph left
[22:42] *** btyler left
[22:43] *** skids joined
[22:48] *** jaldhar joined
[22:51] *** jaldhar left
[22:51] *** jaldhar joined
[22:51] *** lue left
[22:55] *** japhb joined
[22:55] <japhb> I'm baaaaaack ....

[23:00] <japhb> Sadly, apparently after everyone's gone to bed.  :-/

[23:01] <timotimo> japhb: i'm not yet in bed ;)

[23:01] <japhb> \o/

[23:01] <timotimo> your benchmark program/system is pretty darn cool :)

[23:01] <japhb> Thanks.  :-)

[23:01] <timotimo> i've made a few changes, but i'm not sure if i've pullrequested it yet

[23:01] <japhb> Finally got the authorization from the right people to get back to coding on that.

[23:01] <japhb> Yes, please do.

[23:02] <timotimo> one thing i didn't do yet is the trim_string benchmark; perl5 cheats on it and doesn't actually create the trimmed string

[23:02] <japhb> oh?

[23:02] <japhb> It notices a void context?

[23:02] <timotimo> not quite sure what exactly; it's just too darn fast and the performance grows too quickly i think

[23:03] *** raiph joined
[23:03] <japhb> o/

[23:04] <japhb> timotimo, have you dumped the opcode tree generated by Perl 5 for that one?

[23:05] <timotimo> no, i don't know anything about perl5 at all ;)

[23:05] <timotimo> and right now i'm about to go to bed because i have a headache; also the computer that has my most recent benchmark changes isn't up ATM

[23:06] <timotimo> http://irclog.perlgeek.de/perl6/search/?nick=timotimo&q=p6bench - here, have a few of my benchmark results :)

[23:06] <japhb> ah

[23:06] <japhb> Will check

[23:06] <japhb> perl -MO=Terse foo.pl

[23:06] <japhb> That's the trick, IIRC

[23:06] *** jaldhar left
[23:07] <timotimo> i'm quite sad that i haven't been able to get either rakudo-jvm or rakudo-parrot to do the forest fire benchmark with a workload of more than 8 :|

[23:08] *** bluescreen10 left
[23:09] <timotimo> but since rakudo-jvm is still lacking the trial bind operation that's used to compile-time-dispatch calls, i'm sure we'll get there some day

[23:09] <timotimo> no i'm off to bed :)

[23:09] <japhb> sleep well

[23:09] <japhb> and thanks

[23:09] *** jaldhar joined
[23:09] <timotimo> i have to thank *you*! :)

[23:09] <japhb> That's what pull requests are for.  ;-)

[23:10] <diakopter> japhb: howdy

[23:10] <japhb> Hey there!

[23:12] <timotimo> japhb: will you be online tomorrow? maybe a bit earlier than right now?

[23:12] <japhb> I will try to, yes.

[23:14] <timotimo> cool. i'll try to get a pull request formulated with good changes

[23:14] <japhb> *Excellent*

[23:15] <timotimo> the most prominent of the changes is probably adding the jvm port, for which there already is exactly one commit up on github:timo/perl6-bench - i'm not sure if it's correct yet.

[23:16] <timotimo> <- off

[23:16] <japhb> k

[23:22] *** jaldhar left
[23:22] <japhb> meeting &  # but bbiab

[23:23] *** benabik left
[23:36] *** Mouq joined
[23:37] *** jaldhar joined
[23:38] <Mouq> I had to go on an errand, but from a quick throw-together script, at least half the modules (96) pass their tests.

[23:39] <Mouq> I was not checking for dependencies or (as I should probably have been to begin with, but was too lazy) `make`ing and `make test`ing them

[23:40] <Mouq> plus I was, as I said, on an errand and did not have connectivity the entire time, so the Internet-based modules failed

[23:40] <Mouq> Anyway...

[23:41] *** jaldhar left
[23:42] *** jaldhar joined
[23:46] *** pmurias left
[23:58] *** leont left
