[00:02] <lizmat> r: say (1/3).perl  # this doesn't feel right

[00:02] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«<1/3>␤»

[00:03] <lue> r: say <1/3>.WHAT

[00:03] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Str)␤»

[00:03] <lue> rn: say <1/3>.WHAT

[00:03] <lizmat> r: say (1/3).gist  # this feels even worse

[00:03] <camelia> niecza v24-98-g473bd20: OUTPUT«(Rat)␤»

[00:03] <camelia> ..rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Str)␤»

[00:03] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«0.333333␤»

[00:04] <lue> lizmat: <1/3> is supposed to be a RatStr. Although it should perhaps be just a Rat coming out of .perl

[00:05] <lizmat> r: say (1/3).perl.eval  # oddly enough, this *seems* to round trip

[00:05] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«1/3␤»

[00:05] <lizmat> r: say (1/3).perl.eval.WHAT  # but alas, it is now a string

[00:05] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Str)␤»

[00:05] <lue> r: say <1/3>.perl; say +"1/3";

[00:05] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«"1/3"␤0.333333␤»

[00:06] <lue> r: say <1/3> + <2/3>

[00:06] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«1␤»

[00:06] *** synopsebot left
[00:07] <lizmat> r: say 1/3 + 2/3

[00:07] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«1␤»

[00:07] *** hugme left
[00:07] <lizmat> r: say 1 ÷ 3

[00:07] <camelia> rakudo-parrot 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/RhIwd_xm2g␤Two terms in a row␤at /tmp/RhIwd_xm2g:1␤------> say 1 ⏏÷ 3␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤…»

[00:07] <camelia> ..rakudo-jvm 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/rtJR9UfTUC␤Two terms in a row␤at /tmp/rtJR9UfTUC:1␤------> say 1 ⏏÷ 3␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤   …»

[00:07] <lue> I forgot why it's RatStr instead of just a Str.

[00:07] <lizmat> I don't thing we have any of the xxxStr thingies yet

[00:08] <lue> lizmat: yeah, I'm wondering why we have them spec'd. I'm sure S02 will remind me.

[00:09] <jnthn> val(...) is meant to produce them, iirc

[00:10] <lizmat> preflex: .u ÷

[00:10] <lizmat> alas :-(

[00:10] *** Juerd left
[00:11] <lue> yep. It seems the only value to the *Str types is to have a "true" literal for Rat and Complex, even though it and constant folding differ only by the brackets used.

[00:11] *** Juerd joined
[00:11] <jnthn> lue: Also, information preservation, iirc

[00:12] *** synopsebot joined
[00:12] <jercos> Can pass an IntStr as an Int, wheras you can't a Str?

[00:12] <lue> That could be. I think my point is that the *Str types are NYI possibly because coercion takes care of where it would otherwise be an issue :)

[00:12] <lue> (responding to jnthn)

[00:13] *** hugme joined
[00:13] *** ChanServ sets mode: +v hugme

[00:13] <jercos> programming: where coercion is considered better than inheritance.

[00:15] *** beastd left
[00:16] <lue> I'm not totally convinced that RatStr is better than Rat.Str when it comes to information preservation. But I can't say for sure the values of *Str (something to ask TimToady).

[00:16] <jercos> beats making everything a FatRat :|

[00:17] <lue> There's no FatRatStr though, AFAICT. If you really need a FatRat, it's gonna be a FatRat.

[00:17] <jercos> Well I mean there doesn't need to be a FatRatStr though, because Strs aren't inherently size-bounded

[00:18] <lue> The Str part of RatStr could handle a FatRat in string form, sure, but the Rat part couldn't.

[00:18] <jercos> A RatStr should be able to behave like a Rat, but then when cast to a FatRat, retain the precision of the original string.

[00:19] <lue> FatRats are already more precise than Rats, unless I'm misremembering.

[00:20] <jercos> exactly.

[00:21] <jercos> RatStr and FatRat both have infinite potential precision, but a RatStr will degrade to a Rat, while a FatRat will upgrade Rats.

[00:21] <lue> jercos: if the Str of RatStr is somehow more precise than the Rat part, that means the Str's contents don't fit in a Rat, thus a RatStr can't happen.

[00:21] <lue> jercos: RatStrs are limited by the Rat part.

[00:22] <lue> (because whatever value a potential RatStr is given must fit into both parts.)

[00:22] <jercos> http://perlcabal.org/syn/S02.html#Allomorphic_Rats seems to imply otherwise

[00:24] <lue> What the...?

[00:25] <lue> r: constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288; say pi.norm.nude; say pi.WHAT;

[00:25] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«19634954084936207740391521145496893 6250000000000000000000000000000000␤(Rat)␤»

[00:26] <lue> r: constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288; say pi.Str;

[00:26] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«3.14159265358979322257937383255921304␤»

[00:26] <lue> r: constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288; say pi.perl;

[00:26] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«3.14159265358979322257937383255921304␤»

[00:28] <lizmat> r: say 14/3.perl; say (14/3).perl  # should the () really make that difference ?

[00:28] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«4.666667␤<14/3>␤»

[00:28] <lizmat> n: say 14/3.perl; say (14/3).perl  # should the () really make that difference ?

[00:28] <camelia> niecza v24-98-g473bd20: OUTPUT«4.666667␤<14/3>␤»

[00:29] <lue> Rats (aka Rational[Int,Uint64]) can't overflow the numerator, right‽

[00:29] <jnthn> lizmat: Yes, 'cus method calls bind tighter

[00:29] <lue> r: my $a = 0xFFFFFFFF_FFFFFFFF; say $a.WHAT; $a++; say $a.WHAT;

[00:30] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Int)␤(Int)␤»

[00:30] <lizmat> jnthn: so it binds to the 3 ?

[00:30] <lue> jnthn: Ints don't overflow, right?

[00:30] <jnthn> it's doing 14/(3.perl)

[00:30] <jnthn> lue: Correct.

[00:30] <lizmat> jnthn: gotcha

[00:30] <lue> Which means this section of S02 never triggers: http://perlcabal.org/syn/S02.html#Allomorphic_Rats

[00:31] * lizmat wishes #perl6 a good *

[00:31] <lue> (Even if that "numerator" was supposed to be "denominator", I can't quite parse what the hell that section of S02 is trying to say)

[00:31] <jnthn> lue: Int doesn't overlfow, no. Though of course if you have a big enough number you can use all the RAM... ;)

[00:31] <lue> good ♞ lizmat o/

[00:32] <jnthn> No, the point of Rat is the numerator is ounboudned precision, but the denominator will never be more than a 64-bit int.

[00:32] <lue> :) Tell me jnthn, does the section I linked make much sense, even with s/numer/denomin/

[00:32] <lue> That is, too large Rats become *RatStr*s? Not FatRats or Nums?

[00:33] <jnthn> lue: It makes sense to me.

[00:33] <jnthn> lue: Correct, they become RatStr so you get the math performance you expect, but if you really meant to have all the precision and are willing to pay the performance penalty, you can recover the full precision of the constant.

[00:34] <lue> gaaaah. My concept of the Rat/FatRat divide has been broken. I only see that if a Str that contains a too-precise Rat gets passed through, say, MAIN($args), but in that case a FatRatStr would make more sense.

[00:34] <jnthn> FatRat can become *very* slow depending what you're doing.

[00:35] <jnthn> No, the idea is to default to (cheaper) Rats but keep enough info around to get a FatRat built if needed.

[00:35] * lue would muchly prefer it become a FatRat or a Num.

[00:35] <lue> If only to keep my sanity :)

[00:36] * lue fixes the "numerator" flub in any case.

[00:36] <jnthn> Um, I think it may be right?

[00:36] <jnthn> Though I find it weird

[00:36] <jnthn> I'd just keep the original number text as the string... :)

[00:37] <colomon> you can't overflow a numerator in a Rat

[00:37] <colomon> which I assume is what lue is fixing?

[00:37] <lue> That section never triggers if I don't change it.

[00:38] <Mouq> r: say (4/(2**64)).WHAT

[00:38] <Mouq> r: say (4/(2**64+1)).WHAT

[00:38] <jnthn> oh, I see what you mean...

[00:38] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Rat)␤»

[00:38] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Num)␤»

[00:38] <jnthn> Yeah, I misread how it was worded. Think I agree now :)

[00:39] <lue> I like what rakudo's doing right now :)

[00:39] <Mouq> r: say ((2**64+1)/5).WHAT

[00:39] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Rat)␤»

[00:39] <colomon> lue: what Mouq typed there isn't a literal.  the rules only apply to literals.

[00:39] *** bluescreen100 left
[00:39] <colomon> (the "allomorphic rats" rules, I mean.)

[00:40] * lue forgets that it doesn't count as a Num unless e gets involved.

[00:40] <dalek> specs: b44eb86 | lue++ | S02-bits.pod:

[00:40] <dalek> specs: [S02] Change numerator->denominator in Allomorphic Rats.

[00:40] <dalek> specs: 

[00:40] <dalek> specs: That way this section of the spec will ever do something, because you

[00:40] <dalek> specs: can't overflow a Rat's numerator.

[00:40] <dalek> specs: review: https://github.com/perl6/specs/commit/b44eb861e7

[00:41] <colomon> lue++

[00:41] <lue> colomon: then I like the way the constant-folding method does it :)

[00:42] <lue> rn: say RatStr;

[00:42] <camelia> rakudo-parrot 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/HB_OSPz_m1␤Undeclared name:␤    RatStr used at line 1␤␤»

[00:42] <camelia> ..rakudo-jvm 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/JidAHc69St␤Undeclared name:␤    RatStr used at line 1␤␤»

[00:42] <camelia> ..niecza v24-98-g473bd20: OUTPUT«(RatStr)␤»

[00:42] <colomon> rakudo doesn't know RatStr.

[00:42] <lue> n: say val("1/3").perl;

[00:42] <colomon> n: say 3.14159_26535_89793_23846_26433_83279_50288.WHAT

[00:42] <camelia> niecza v24-98-g473bd20: OUTPUT«val("1/3")␤»

[00:42] <camelia> niecza v24-98-g473bd20: OUTPUT«Num()␤»

[00:42] <colomon> huh

[00:42] <lue> n: say val("1/3").WHAT;

[00:42] <camelia> niecza v24-98-g473bd20: OUTPUT«(RatStr)␤»

[00:42] <colomon> n: say 3.14159_26535_89793_23846_26433_83279_50288

[00:42] <camelia> niecza v24-98-g473bd20: OUTPUT«3.1415926535897931␤»

[00:43] <colomon> n: say 3.14159_26535_89793_23846_26433_83279_50288.perl

[00:43] <camelia> niecza v24-98-g473bd20: OUTPUT«3.1415926535897931e0␤»

[00:43] <lue> n: say val("1/(2**64)").WHAT; say val("1/(2**64)")

[00:43] <camelia> niecza v24-98-g473bd20: OUTPUT«(Str)␤1/(2**64)␤»

[00:43] <lue> n: say val("1/{2**64}").WHAT; say val("1/{2**64}")

[00:43] <camelia> niecza v24-98-g473bd20: OUTPUT«Num()␤1/18446744073709551616␤»

[00:43] <lue> n: say val("1/{2**32}").WHAT; say val("1/{2**32}")

[00:43] <colomon> gack, guess it's another bug for me to fix on that far-off day when I have time to niecza-hack.

[00:44] <camelia> niecza v24-98-g473bd20: OUTPUT«(RatStr)␤1/4294967296␤»

[00:44] <jnthn> sleep time for me... &

[00:44] <lue> n: say val("1/{2**32+1}").WHAT; say val("1/{2**32+1}")

[00:44] <camelia> niecza v24-98-g473bd20: OUTPUT«(RatStr)␤1/4294967297␤»

[00:44] <lue> ♞ jnthn o/

[00:44] <colomon> \o

[00:45] <lue> I personally would prefer if too-big-for-Rat decimal literals were Num instead of FatRat. Because if you typed out a very big decimal number, chances are you're not thinking in fractions :)

[00:45] <lue> (nor RatStr, for that matter.)

[00:46] <colomon> but RatStr is the only choice that doesn't involve throwing away much of what you type

[00:46] <lue> there's also NumStr, no?

[00:46] <colomon> r: say 2**64

[00:46] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«18446744073709551616␤»

[00:47] <colomon> r: say (2**64).split

[00:47] <camelia> rakudo-jvm 874e35: OUTPUT«Cannot call 'split'; none of these signatures match:␤:(Cool : Regex $pat, $limit = { ... }, :all(:$all), Mu *%_)␤:(Cool : Cool $pat, $limit = { ... }, :all(:$all), Mu *%_)␤  in any  at gen/jvm/BOOTSTRAP.nqp:1201␤  in block  at /tmp/jJCLdNnYmr:1␤  …»

[00:47] <camelia> ..rakudo-parrot 874e35: OUTPUT«Cannot call 'split'; none of these signatures match:␤:(Cool : Regex $pat, $limit = { ... }, :all(:$all), Mu *%_)␤:(Cool : Cool $pat, $limit = { ... }, :all(:$all), Mu *%_)␤  in any  at gen/parrot/BOOTSTRAP.nqp:1218␤  in any  at gen/parrot/BOOTSTR…»

[00:47] <colomon> r: say (2**64).comb

[00:47] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«1 8 4 4 6 7 4 4 0 7 3 7 0 9 5 5 1 6 1 6␤»

[00:47] <lue> (Doesn't bother me too much either way, though.)

[00:47] <colomon> r: say +((2**64).comb

[00:47] <camelia> rakudo-parrot 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/d6plr6Rnic␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/d6plr6Rnic:1␤------> say +((2**64).comb⏏<EOL>␤    expecting any of:…»

[00:47] <camelia> ..rakudo-jvm 874e35: OUTPUT«===SORRY!=== Error while compiling /tmp/5_ERMeEiWn␤Unable to parse expression in parenthesized expression; couldn't find final ')' ␤at /tmp/5_ERMeEiWn:1␤------> say +((2**64).comb⏏<EOL>␤    expecting any of:␤…»

[00:47] <colomon> r: say +((2**64).comb)

[00:47] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«20␤»

[00:48] <colomon> what I was trying (unsuccessfully) to get at there is, unless your number starts with a load of zeros, Rat is actually more accurate than Num.

[00:49] <colomon> so RatStr gives you something reasonable to work with, and allows you to get at any other form you'd want, with the possibility of even more accuracy.

[00:49] <colomon> (for FatRat conversion.)

[00:50] <lue> Yeah, I just don't like how the Rat/FatRat divide I've always imagined gets utterly broken when it comes our ol' friend *Str.

[00:50] <lue> *friends rather

[00:53] <lue> I'd be stubborn and point out that FatRat supports the criteria of "precision" without allomorphic trickery, but I think its speed disadvantage has been stated well enough :)

[00:54] * lue &

[00:54] *** mschreck left
[00:55] *** mschreck joined
[01:01] <jercos> lue: clearly we should just eschew efficiency all together, and store all numbers as rationals made of products of prime powers. :p

[01:03] <Mouq> jercos: an to make things simple, we should store the primes using unary arithmetic, e.g., 5 gets 5 bits, 17 gets 17

[01:03] <Mouq> *and

[01:05] <jercos> ah, well, if you're storing prime powers, the primes themselves don't really get any representation in the stored form

[01:05] <jercos> just taxation

[01:07] <jercos> (3, 1, 1)/(0, 0, 0, 1) = 2 * 2 * 2 * 3 * 5 / 7 = 120/7 = ~17.142857

[01:07] <Mouq> oh, duh. but of course we still need the numbers to tell which number prime we're talking about. but our primes can get arbitrarily big! We should store the primes using the same PrimeRat class we're storing the primes in!

[01:08] <colomon> lue: just remember you *never* get a FatRat unless you explicitly ask for one.  or you have one already.

[01:12] <jercos> Mouq: I actually implemented that for laughs while playing around with dynamically generated arrays. I still don't have a good way to make a magic array of primes that continues extending indefinitely as it's accessed, without being at least as slow as testing is-prime for every number between the last known prime and the prime index requested. :|

[01:12] <jercos> For bonus points, the 0th prime number is taken to be -1, so negative numbers can be represented. >.>

[01:13] <Mouq> jercos: sieve?

[01:14] <jercos> a sieve would be nice, but that'

[01:14] <jercos> s rather hard to fit inside the closure for ...

[01:17] *** dwoldrich joined
[01:17] *** benabik joined
[01:17] *** benabik left
[01:17] <jercos> plus, I'd rather not take up n array elements to find a prime <= n.

[01:18] <jercos> memory is cheap, but not that cheap :|

[01:28] *** dayangkun joined
[01:34] <timotimo> rakudo is still pretty wasteful with regards to memory, it seems

[01:35] <timotimo> but when moarvm comes around, that may change

[01:35] <timotimo> also, sized arrays are in soon, after that we have native types as lvalues and then compact arrays

[01:39] *** mschreck_ joined
[01:40] <timotimo> that's the hope anyway :)

[01:40] *** mschreck left
[01:42] *** Grrrr joined
[01:44] *** MikeFair_ joined
[01:46] *** mschreck_ left
[01:55] *** JimmyZ_ joined
[01:55] *** JimmyZ_ left
[02:04] <lue> colomon: that's a good thing to keep in mind. I still don't like how RatStr is special from the other *Str types though :) .

[02:19] <colomon> lue: you wouldn't happen to remember how to pass a hash as a bunch of named arguments, would you?

[02:19] *** ggoebel110 left
[02:20] <lue> r: sub foo(:$bar, :$baz) { say "$bar $baz" }; my %h = <bar 1 baz 2>; foo(|%h);

[02:20] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«1 2␤»

[02:20] <colomon> brill!

[02:20] <colomon> lue++

[02:20] <lue> r: sub foo(:$bar, :$baz) { say "$bar $baz" }; my %h = <bar 1 baz 2>; foo(%h);

[02:20] <camelia> rakudo-jvm 874e35: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in block  at /tmp/X2wcpACsGg:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292␤  in any command_eval at gen/jvm/stage2/NQPHLL.nqp:1196…»

[02:20] <camelia> ..rakudo-parrot 874e35: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in sub foo at /tmp/UFpjckVPNI:1␤  in block  at /tmp/UFpjckVPNI:1␤  in any  at /tmp/UFpjckVPNI:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPH…»

[02:21] <lue> you're welcome :)

[02:22] *** mschreck joined
[02:23] *** xenoterracide left
[02:24] <colomon> not actually helping my code.  :\

[02:30] *** MikeFair_ is now known as MikeFair

[02:39] *** ggoebel110 joined
[02:44] *** mschreck left
[02:52] *** mschreck joined
[02:54] *** mschreck left
[02:54] *** mschreck joined
[02:57] <colomon> It's rapidly becoming apparent that when IO::Prompter last worked, Rakudo didn't actually check parameter types.

[03:00] *** mschreck left
[03:07] *** kaleem joined
[03:08] *** SevenWolf left
[03:08] <colomon> r: say $*IN.WHAT

[03:08] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(IO::Handle)␤»

[03:16] *** Grrrr left
[03:20] *** xenoterracide joined
[03:22] *** Grrrr joined
[03:31] <colomon> triumph!

[03:35] *** Rix joined
[03:36] *** mschreck joined
[03:44] *** mschreck_ joined
[03:44] *** mschreck left
[03:44] *** mschreck_ is now known as mschreck

[03:45] *** kaleem left
[04:01] *** mschreck left
[04:02] *** cxreg2 is now known as cxreg

[04:03] *** mschreck joined
[04:09] *** mschreck left
[04:49] *** ssutch joined
[04:52] *** zakharyas joined
[04:53] *** preflex left
[04:54] *** preflex joined
[04:54] *** ChanServ sets mode: +v preflex

[04:58] *** mschreck joined
[05:07] *** jlaire joined
[05:13] *** Mouq left
[05:14] *** ggoebel110 left
[05:26] *** mschreck left
[05:27] *** [Sno] left
[05:27] *** mschreck joined
[05:27] *** SevenWolf joined
[05:29] *** dayangkun left
[05:43] <TimToady> <1/3> is always just a Rat; the RatStrs don't show up unless there is whitespace

[05:43] <TimToady> numeric operations *never* produce RatStr

[05:44] <TimToady> if you overflow a denominator on a computation, you'll either get a rounded Rat or a Num

[05:45] <TimToady> IntStr, NumStr, and RatStr are there only for stuff that is ambiguous because it's coming through a text-only API, such as literal code, or command line, or terminal input

[05:46] <TimToady> and they are only for hedging your bets until the first numeric operation

[05:49] *** zakharyas left
[05:49] <lue> TimToady: that Allomorphic Rats example implied that a long decimal causes RatStr though.

[05:49] <lue> So is that section wrong no matter which half of the fraction is stated to overflow?

[05:51] <TimToady> your program is *text*

[05:51] <lue> (if overflow gets rounded Rat or Num, that is)

[05:51] <TimToady> it's not numeric unless something makes it numeric

[05:52] *** fridim__ left
[05:52] *** mschreck left
[05:52] <TimToady> nothing trying to make it overflow, that's just the defintion of the constant

[05:52] <TimToady> a RatStr

[05:52] *** mschreck joined
[05:53] <TimToady> the RatStr is the only conversion that doesn't lose precision

[05:53] <TimToady> s/RatStr/FatRat/

[05:53] <lue> .oO(The statement "your program is text" feels a lot like "you're surrounded by air", in that it's something you normally forget ☺)

[05:53] <TimToady> well, and .Str, but that's not really a conversion

[05:54] <lue> so that constant pi = <long decimal> is supposed to be a RatStr because the program itself is text, IIUC.

[05:54] <TimToady> yes

[05:55] <TimToady> it's one of those less obvious places where Perl 6 solves a problem with premature commitment by being a bit lazier than the average langauge

[05:55] <TimToady> *guage

[05:56] *** BenGoldberg left
[05:56] <TimToady> though MI is not the only way to solve this; we could say that all numeric types derive from Str instead, but that has its own issues

[05:57] <TimToady> violating Liskov, for one

[05:58] <lue> Now that I realize there's air surrounding me, the decision to make too-large-for-Rat literals be RatStr makes a bit more sense. /me imagines "+<large decimal>" would force that rounded Rat or Num condition

[06:00] *** mschreck left
[06:01] <TimToady> on the use of <1/3> for a literal notation, it just kinda falls out of wanting to represent a list of numbers inside <> anyway; also the precedence issue if you forget the parens around (1/3) are worse for complex literals, which use the looser +

[06:02] <TimToady> it just felt conceptually cleaner not to rely on constant folding for those kinds of literals

[06:02] *** mschreck joined
[06:02] <lue> Too bad there's nothing like 2.5 for Complex numbers though; 1i2 or something...

[06:02] <TimToady> once you have val() as a "safe" eval, it seems reasonable to use it

[06:03] <TimToady> n: say <1i2>.WHAT

[06:03] <camelia> niecza v24-98-g473bd20: OUTPUT«(Str)␤»

[06:03] <TimToady> n: say <1i+2>.WHAT

[06:03] <lue> .oO( eval == exciting val() )

[06:03] <camelia> niecza v24-98-g473bd20: OUTPUT«(Str)␤»

[06:03] <TimToady> n: say <1+2i>.WHAT

[06:03] <camelia> niecza v24-98-g473bd20: OUTPUT«(Complex)␤»

[06:03] <TimToady> 1i2 would be terribly ambigous; does the i go on the 1 or on the 2?

[06:04] <TimToady> and as long as <> was getting val semantics anyway, might as well use the spaceless form as a literal

[06:05] <TimToady> arguably, we're overloading brackets more than we ought, but there just aren't enough brackets in ASCII

[06:05] <lue> yeah. I was just lamenting mathematics in general for using operators as the most basic representation of a type of number. 'i' could be any kind of separator really. I've thought of 1;2 as that before too.

[06:05] <TimToady> we still haven't achieved the heights of Perl 5's overloading of {}

[06:05] <TimToady> which as I recall meant at least six different things

[06:07] *** mschreck left
[06:07] <diakopter> eval {}{}{}{}{}{}{}{}{}

[06:07] <diakopter> p5eval {}{}{}{}{}{}{}{}{}

[06:08] <TimToady> block, hash, "${foo}bar", \x{dead}, /x{1,2}/, q{}, and I think something in formats

[06:08] *** mschreck joined
[06:08] <TimToady> and probably a few other things I've forgotten

[06:08] <diakopter> lexical scope?

[06:08] <TimToady> block

[06:08] <diakopter> oh

[06:10] <TimToady> well, {} could also be literal in a regex if it didn't have numbers

[06:10] <TimToady> oh, duh, hash subscripts

[06:11] <diakopter> s{ }{ }

[06:11] <TimToady> that's a q{} variant in my head

[06:12] <TimToady> though it certainly pays attention to the bracketness on left

[06:12] <diakopter> what a head

[06:12] <TimToady> (as does p6, albeit differently)

[06:14] <TimToady> anyway, unoverloading {} is why we get things like "\x[dead] {$foo}" instead

[06:14] <TimToady> so ${foo} is no longer a special case, it's just a block in a funny spot

[06:14] <lue> we could always use a special literals bracket if you fear overloading. I'm partial to ⦃1/2⦄ (only because it's somehow my go-to "Unicode brackets"). Not ⟅1/2⟆, that's clearly for Bags :) .

[06:16] <lue> .oO(If they weren't generic brackets, I'd be even more partial to ☃1/2☄)

[06:16] *** darutoko joined
[06:16] <TimToady> there are lotsa lovely brackets in Unicode, but those seem like overkill for literals, especially when it already falls out of qw// semantics

[06:17] <TimToady> well, qw:v or whatever

[06:17] <lue> TimToady: I agree. But if you do someday fear <> overloading... :)

[06:17] <lue> (on the overkill that is)

[06:18] <TimToady> well, the main problem with our use of <> is that it requires space in front of binary infix <

[06:19] <TimToady> but we're not optimizing for golf anymore, so p6 doesn't mind enforced spacing in certain spots

[06:20] <lue> ‹› would be probably the least-shocking change-to I think. (Though it would interfere with if we want <quote word lists> and other <> bracketing uses to use ‹› as the non-Texas version someday.)

[06:20] <TimToady> well, huffman coding kinda applies, if you consider typing

[06:21] <TimToady> don't mind Unicode ops for sets, since those are much rarer than lists of numbers

[06:21] <TimToady> or literals

[06:23] <TimToady> using ‹› to indicate something like "always assume numeric types" might be a possibility, but while ‹› are a good choice for something like <>, they are also a bad choice because they're not quite visually distinctive enough

[06:24] <lue> TimToady: Just as a small confirmation, NFG ord() and chr() are supposed to deal in not-exactly-codepoint numbers, right? ord("a􏿽xCC􏿽x88") would be potentially 0x11_0001 in that case, for instance.

[06:25] <lue> That's why I prefer ‹› to be to <> what «» is to <<>> instead. But it was a thought that came to mind.

[06:25] <TimToady> ä has a precomposed form, so is always NFC

[06:26] <TimToady> (I think)

[06:26] <lue> Oh? P6 does forced NFC by default?

[06:26] <lue> (forced at time of string creation that is)

[06:26] *** [Sno] joined
[06:26] <diakopter> lue: yes

[06:26] <lue> In any case, that was just the fastest multi-codes grapheme I could reach for.

[06:27] <lue> (assume it represents a generic uncomposable grapheme :P)

[06:27] <TimToady> NFG is defined as NFC plus extra canonicalization of things that "ought" to have a precomposed codepoint

[06:27] <lue> diakopter: yes to which question? or both?

[06:28] * lue suspected NFG would prefer normal codepoints where possible.

[06:28] *** SamuraiJack__ joined
[06:29] *** SamuraiJack__ left
[06:30] <lue> Now I wonder if there's a NFDG, NFKG, and NFKDG :) . Also if we want to invent other NFs, like NFP (codePoints), NFU (code Units), and NFB or NFO (Bytes or Octets).

[06:30] <lue> At least I know now why you called in NFG instead of just, say, count-by-graphemes.

[06:31] <moritz> \o

[06:31] <TimToady> well, it's also a pun

[06:31] <lue> o/ moritz

[06:31] *** SamuraiJack joined
[06:32] <TimToady> oh, the made-up graphemes will always be negative, not > 0x110000.

[06:32] <lue> But... but... the ISO pledged to never go beyond 10_FFFF. Or are you suggesting they'll replace UTF-16 with a 16-bit version of UTF-8 someday? :)

[06:33] <TimToady> the symmetry around 0 makes it possible to use signed types like int8, int16 for strands of the rope that aren't too high up in U-land

[06:34] <lue> Honestly I just typed 0x11_0001 because I didn't feel like typing out enough bits for a negative number :P

[06:34] <TimToady> -1 is shorter :)

[06:35] * TimToady admits that -1 arguably depends on constant folding :)

[06:35] <TimToady> n: say <-1>.WHAT

[06:35] <camelia> niecza v24-98-g473bd20: OUTPUT«(Int)␤»

[06:35] <TimToady> n: say < -1 >.WHAT

[06:35] <camelia> niecza v24-98-g473bd20: OUTPUT«(IntStr)␤»

[06:35] <lue> unlike Rats, we don't need angle brackets for that literal. Just use ­APL's HIGH MINUS :)

[06:36] <TimToady> that was not just APL; they trying to foist that notation on us when I was in grade school :)

[06:37] <TimToady> thankfully it didn't stick

[06:37] <TimToady> *tried

[06:37] <TimToady> ah, the 60s...

[06:38] <jlaire> J uses _1, that's like LOW MINUS

[06:39] *** FROGGS[mobile] joined
[06:39] <TimToady> anyway, the intent of NFG is not to try to encode all the codepoints into the integer, but to synthesize a codepoint that can be used to lookup the NFD form in a table somewhere

[06:40] <lue> TimToady: would NFG and "str".decompose ever exist in the same space? I imagine issue would arise with things like  ord("ä".decompose)  (would ord NFG-ify its copy of the string?)

[06:40] <TimToady> you just get an NFD string out of it, is all

[06:41] <TimToady> if Str is really NFG, then what we have now is what we might end up calling Uni, where it's just known to be codepoints

[06:41] <TimToady> if we know the canonicalization, it might be a more specific type such as NFD or NFC

[06:42] <TimToady> but we make no guarantees about the operations available on those types, as of now.

[06:42] <TimToady> those types are more like utf8 in that respect

[06:43] * lue has been assuming NFG to be a fancy way of saying "count by graphemes" until now, so how NFG fits with the rest of NF* and all that is a bit fuzzy.

[06:43] <lue> If only there were a synopsis on Unicode that would clarify this... :)

[06:43] <TimToady> it really means "store by graphemes", so we avoid any hint of variable-width characters

[06:44] <TimToady> or surrogate monstrosities

[06:44] *** mschreck left
[06:44] <TimToady> nor does the concept of combining characters exist in NFG

[06:45] <TimToady> except insofar as we allow people to do matching on them in regex, but that will probably require a special notation

[06:45] <lue> So beyond storage, does NFG have any other effect on the basis of counting characters? That is, does NFG turn on count-by-graphemes, or is it that the count-by setting happens to correlate with the storage method by default?

[06:45] *** rurban2 left
[06:45] <TimToady> there's no "count by" needed when you basically have an array of integers, one per character

[06:46] *** mschreck joined
[06:46] <TimToady> not in the sense of "count by" meaning "cheat on a variable-width encoding"

[06:47] <TimToady> for regex we'll need a way of saying "match this base character where it also contains this set of one or more combining chars"

[06:47] <TimToady> we haven't specced that yet that I know of

[06:48] <lue> So pragmas controlling how to view strings make no sense (e.g.  use graphs; or use codes;). It'd be more useful to change the storage of the string's contents to change how you see things.

[06:48] <lue> (and things like $str.codes would act as if the string stored its contents as codepoints if not already.)

[06:48] <TimToady> that's the current way of looking at it; in any case, it's more type-based than having much to do with lexical scope

[06:49] <moritz> or to have separate types

[06:49] * moritz too slow

[06:49] <TimToady> that being said, different languages happen in different lexical scopes, and a different language might not support NFG

[06:50] <lue> pragmas would at least control the default storage. So things like use NFC; or use NFKD; or use NFG; (and perhaps other invented NFs like use NFP; to store by codepoints)

[06:50] <TimToady> our current Perl 6 language, for instance, is really in a 'use codepoints' kind of mental space

[06:50] * TimToady hopes we can switch over to NFG semantics without too much heartburn

[06:50] <TimToady> yes, defaults can certainly be the province of pragmas

[06:51] * lue wonders if at somepoint "str".ords is better written as "str".encode :)

[06:51] <TimToady> if you say "use NFD;' then presumably all your literal strings are stored as NFD, for instance

[06:52] <TimToady> but we need to work out the type system to say much beyond that

[06:53] <lue> I assume I can think of NFG as NFC++ then, right?

[06:53] *** logie_ joined
[06:53] <TimToady> does . always match a codepoint in a Uni string?

[06:53] <TimToady> that's how I think of it

[06:53] * moritz thought it always matched a grapheme

[06:53] <TimToady> supposed to, in NFG-land

[06:54] <TimToady> but all is fair if you predeclare

[06:54] <lue> for ^0x11_0000 { say chr($_) ~~ /./ ?? True !! False } should test it :)

[06:54] *** xenoterracide left
[06:55] * lue wouldn't be surprised if at some point Str becomes just a default form of String[things], like Rat is Rat64 is Rational[Int,UInt64]

[06:55] <TimToady> to take an extreme example, if you say 'use v5;' it is no longer the case that . matches a grapheme

[06:56] <TimToady> that might well happen for other languages, including non-NFG P6 variants

[06:56] <TimToady> but we really need to play with NFG first to see how non-NFG will work out

[06:56] <lue> Once NFG happens in an implementation, I predict a lot major and unsettling changes will occur to how we do strings.

[06:57] <TimToady> this seems likely

[06:57] *** mschreck left
[06:58] <TimToady> for instance, the need to treat individual characters as potentially complex entities

[06:58] <TimToady> (when matching)

[06:58] *** xenoterracide joined
[07:01] <TimToady> currently we have :m and :samemark, which are crude ways of saying 'ignore the combiners'

[07:01] <lue> Would it be right to think of codepoints and below as low-level enough that an invented NF* doesn't make the most amount of sense? Or have we generalized NF* as ways to store strings (from the Unicode meaning of "(de)composing characters", with potentially some transformations to the exact contents?

[07:01] <TimToady> they are basically pragmas writ small

[07:03] * TimToady doesn't quite understand the question

[07:04] <lue> TimToady: another way to put it is: in addition to things like "str".graphs, "str".codes, and so on, would we have "str".composeds and "str".decomposeds(:compatability) to go with NFC and NFKD ?

[07:04] <TimToady> at the Uni level, the meaning of the string is sufficiently characterized by Unicode properties that we could conceivably do some amount of autocoercion

[07:05] <lue> "would there be NFP (codePoints) and such in addition to NFG and NFKC?" is yet another form of the question.

[07:05] <TimToady> you can't make up information that isn't there though

[07:07] <TimToady> I don't understand what your NFP would do that an undifferentiated Uni string wouldn't

[07:09] <TimToady> NFC and NFD, as constrained variants of Uni, are measured in .codes

[07:09] <lue> NFP would store the strings much as they are now: by unicode codepoints. I don't know, my mind feels eager to blur the line between the meaning of NF* and what your idea of the base unit of a string some more it seems :) .

[07:10] <TimToady> just as utf8 is measured in bytes

[07:10] <TimToady> my mind is blurry enough without outside encouragement :)

[07:11] <lue> So NF[K]?[C|D] is effectively "codepoints" then. Then encoding forms would be how you count by "code units", and buf8 would be how you count by "bytes" or "octets" :)

[07:11] <lue> (and NFG of course is "graphemes")

[07:11] <TimToady> I wouldn't use "encoding" to talk about NF*

[07:12] *** kaleem joined
[07:12] <TimToady> in sense they are, but using that term for them will confuse people

[07:13] <TimToady> if I understand the unification you're going for, it's that NFG.codes is the same as NFG.chars

[07:13] <TimToady> a "codepoint" in NFG just happens to be grapheme

[07:14] <TimToady> you can't tell how many real codepoints it would produce if you converted to NFC or NFD, because those are fuzzy in the same way that, er, the number of seconds in a month is fuzzy...

[07:14] <TimToady> you must at least say "if it *were* converted to NFD, what would it be?"

[07:15] *** arcterus left
[07:15] <TimToady> much as with dates you have to say, "one month later, supposing today is Jan 31"

[07:15] <TimToady> though the metaphor is strained

[07:15] *** arcterus joined
[07:16] <lue> no, "Then encoding forms would be how you count by "code units"" refers to the UTF- family. A UTF-32 code unit is a 32-bit number, a UTF-16 code unit 16-bit, etc.

[07:17] <TimToady> you can't know the length in .codes without know the canonicalization, just as you can't know the length in .bytes without knowing whether it's going to be UTF-8 or UTF-16 or UTF-32

[07:17] <lue> So "default utf-8".units would be different that "default utf-8".convert-to(utf-32).units, assuming you had multi-unit characters in the UTF-8 string.

[07:17] <lue> bytes is where .encode() comes in :)

[07:18] <lue> TimToady: it's late here, so tomorrow I'll write what I'm thinking in pseudo-provisional-S15 kind of way, so I can explain myself more clearly than one-line-at-a-time IRC :)

[07:18] <TimToady> at this point, specifying either a default encoding or default normalization seems smelly to me

[07:18] *** ingy left
[07:18] <lue> But don't we do utf-8 and NFC++ by default? :)

[07:18] <lue> ♘ all o/

[07:19] <TimToady> o/

[07:19] *** berekuk joined
[07:32] *** darutoko- joined
[07:32] *** berekuk left
[07:33] *** darutoko left
[07:33] *** xenoterracide left
[07:33] *** xenoterracide joined
[07:41] *** FROGGS left
[07:47] *** berekuk joined
[07:55] *** markov joined
[08:10] *** darutoko- left
[08:10] *** darutoko joined
[08:11] *** dmol joined
[08:15] *** nnunley left
[08:18] <dalek> perl6-examples: a01a165 | electricface++ | 99-problems/P10-topo.pl:

[08:18] <dalek> perl6-examples: Update P10-topo.pl

[08:18] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/a01a1650c6

[08:18] <dalek> perl6-examples: 878d9f1 | moritz++ | 99-problems/P10-topo.pl:

[08:18] <dalek> perl6-examples: Merge pull request #13 from electricface/patch-1

[08:18] <dalek> perl6-examples: 

[08:18] <dalek> perl6-examples: Update P10-topo.pl

[08:18] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/878d9f1545

[08:35] *** FROGGS[mobile] left
[08:49] *** arcterus left
[08:49] *** Mouq joined
[08:50] *** arcterus joined
[08:53] *** Mouq left
[08:56] *** denis_boyun joined
[09:04] *** denis_boyun left
[09:10] *** [Sno] left
[09:12] *** nnunley joined
[09:13] *** denis_boyun joined
[09:17] *** Alina-malina left
[09:18] *** Alina-malina joined
[09:30] *** denis_boyun left
[09:32] *** denis_boyun joined
[09:38] *** woolfy joined
[09:40] *** berekuk left
[09:41] *** mschreck joined
[09:42] *** denis_boyun left
[09:47] *** hummeleB1 joined
[09:51] *** dakkar joined
[09:52] <lizmat> good *, #perl6!

[09:52] *** denisboyun joined
[09:53] * lizmat gives up on trying to use the hotel wifi to reach apparently blocked sites, such as github, or perl6's advent site, or any other number of sites

[09:54] <lizmat> I suspect some kind of IPv6 tunnel failure at either the hotel, or the hotel's provider

[09:54] <lizmat> instead, I'll just start our decommute a bit earlier

[09:55] *** fhelmberger joined
[09:56] *** tgt joined
[09:58] <hoelzro> lizmat: do you need a proxy?

[09:58] <hoelzro> I can lend you one

[10:00] *** denisboyun left
[10:06] *** lizmat left
[10:07] *** woolfy left
[10:09] *** denisboyun joined
[10:11] <jnthn> morning-ish... o/

[10:12] *** FROGGS[mobile] joined
[10:15] *** denisboyun left
[10:16] *** FROGGS[mobile] left
[10:17] *** nnunley left
[10:17] <nwc10> good UGT, jnthn 

[10:33] *** Mouq joined
[10:34] <masak> good antenoon, #perl6

[10:34] <preflex>  masak: you have 1 new message. '/msg preflex messages' to read it.

[10:34] <masak> ooh, a message!

[10:34] <masak> preflex: messages

[10:34] <preflex>  lue said 11 hours, 54 minutes and 22 seconds ago: https://gist.github.com/lue/7741574 has the same Temporal stuff, but in a less sensitive location :)

[10:36] <moritz> a masak!

[10:36] <masak> I suppose everything went well with the advent post?

[10:37] <masak> haven't looked yet :)

[10:37] <moritz> yes, it was published

[10:37] *** Mouq left
[10:37] <masak> \o/

[10:37] * masak is teaching

[10:38] <jnthn> masak: Hope it's not too testing a class...

[10:43] *** tipdbmp left
[10:44] <masak> jnthn: they are assertive but also responsive :)

[10:45] <jnthn> So long as they ain't mockists, or you'll have to send 'em to AAA for help... :P

[10:47] *** denisboyun joined
[10:50] <masak> none of them have shown any mockist bent yet. but it's early in the course still.

[10:50] * masak .oO( To Mock a Mockist Bird )

[10:51] *** dmol left
[10:53] *** denisboyun left
[10:59] *** fhelmberger left
[10:59] *** fhelmberger_ joined
[10:59] *** SamuraiJack_ joined
[11:00] *** SamuraiJack left
[11:04] *** tipdbmp joined
[11:08] *** mschreck left
[11:08] <masak> wow, Java is so inept.

[11:08] *** mschreck joined
[11:09] <jnthn> It has class...but not much else.

[11:11] <masak> Q: How do I sort an array of doubles in reverse order?

[11:11] <masak> A1: With difficulty.

[11:11] <masak> A2: Don't do that.

[11:12] <moritz> .sort.reverse ? :-)

[11:12] <jnthn> theArray = theArray.OrderByDescending().ToArray(); // C# answer ;)

[11:14] <masak> moritz: hahaha *sob*

[11:15] *** mschreck left
[11:15] *** SevenWolf left
[11:26] *** denis_boyun joined
[11:44] <colomon> Hmmm, DateTime::TimeZone and IO::Prompter both working with latest smoke test, but now Time::Duration has started failing.

[11:44] *** dmol joined
[11:45] *** dmol left
[11:46] *** dmol joined
[11:53] *** xinming left
[11:56] *** xinming joined
[11:57] *** dakkar_ joined
[11:57] *** silug_ joined
[11:57] *** atta_ joined
[11:57] *** dakkar left
[11:57] *** dylanwh left
[11:57] <hoelzro> I take it that command line switches are all loaded into %*COMPILING<%?OPTIONS>?

[11:57] <hoelzro> automatically?

[11:57] *** dylanwh joined
[11:57] *** silug left
[11:57] <hoelzro> I have a Perl6::Grammar object in NQP, and I'd like to tell it to use a NULL setting

[11:59] <moritz> hoelzro: just look at how rakudo does it

[11:59] <hoelzro> that's the thing; I'm trying

[12:00] <moritz> if %*COMPILING<%?OPTIONS><setting> eq 'NULL' {

[12:01] <moritz> is what Perl6::Grammar and Perl6::Actions use

[12:02] <moritz> which a git grep NULL found pretty much instantly in rakudo

[12:03] <jnthn> hoelzro: Gotta head out right now, but I'm curious what your "null setting" use case is...given that you in that case probably are compiling a setting.

[12:04] *** mschreck joined
[12:05] <jnthn> bbs &

[12:13] *** fridim__ joined
[12:16] *** dwoldrich left
[12:19] *** dmol left
[12:21] *** dmol joined
[12:21] *** Mouq joined
[12:23] *** dmol left
[12:25] *** Mouq left
[12:26] *** dmol joined
[12:27] <masak> lue: well, the problem with "humanistic counterpart" is this: Instant is well-defined, DateTime is well-defined (if you squint), Duration is well-defined (since Instant is), but Interval is not well-defined at all.

[12:28] <masak> lue: and just saying that we'll have such a type doesn't fix the problems of non-well-definedness. it pulls them up to the surface as puts them in the spec.

[12:28] <masak> lue: I suggest you start from three (or so) use cases, and we can discuss those, and how they are potentially problematic.

[12:29] <masak> lue: use cases, as in follow an Interval from beginning to end.

[12:29] <masak> lue: naming-wise, it bothers me that the pairing is Instant/Duration and DateTime/Interval. I/D and D/I makes less mnemonic sense than I/I and D/D. but that is a smaller point compared to the conceptual difficulties.

[12:36] *** FROGGS joined
[12:37] *** xenoterracide left
[12:39] *** araujo left
[12:42] <masak> lue: as to the week syntax in constructors, I simply disagree that we need it, just because ISO 8601 has it.

[12:42] <masak> lue: I invoke Postel's Law. recognizing many different input formats makes the class weaker, not stronger.

[12:43] *** dmol left
[12:43] <FROGGS> a clear design is worth much, yes

[12:44] <FROGGS> it will grow weak over time anyway

[12:44] *** dmol joined
[12:47] *** mberends joined
[12:54] *** araujo joined
[12:54] *** dmol1 joined
[12:54] *** dmol left
[12:56] *** rurban1 joined
[13:03] *** ggoebel110 joined
[13:05] *** SamuraiJack_ left
[13:05] *** SamuraiJack_ joined
[13:07] *** PZt left
[13:09] <hoelzro> moritz: right, but I want to set setting to 'NULL'

[13:09] <hoelzro> not ask if it is

[13:09] <hoelzro> jnthn: I doubt I'll be sticking with a NULL setting; I'm just playing around

[13:11] <moritz> hoelzro: my %*COMPILING; %*COMPILING<%?OPTIONS><setting> := 'NULL';

[13:11] *** SamuraiJack_ left
[13:11] <hoelzro> hmm

[13:11] <hoelzro> I didn't think it'd be that simple =/

[13:11] <moritz> well, that's the first thing I'd try

[13:11] <hoelzro> I was also curious to see if it was some magic populating %*COMPILING<%?OPTIONS>

[13:12] <hoelzro> or if something crawls over ARGV and populates it that I'm not seeing

[13:12] <moritz> yes, that happens

[13:13] <moritz> in HLL::Compiler.compile

[13:13] <hoelzro> ah ha

[13:13] <hoelzro> that's why I wasn't finding it

[13:14] <moritz> and method command_line  calls process_args which in turn delegates most of the wrok to HLL::CommandLine::Parser

[13:23] *** mschreck left
[13:24] *** denis_boyun left
[13:28] <hoelzro> hmm

[13:28] <hoelzro> my VM *really* doesn't want to compile CORE.setting

[13:30] <hoelzro> how much memory does it take to compile CORE.setting with nqp-p these days, anyway?

[13:31] <hoelzro> I have 2GB of RAM on this VM

[13:31] <hoelzro> but top reports that ./perl6-p is only taking 25% of that

[13:31] <hoelzro> of course I don't have the swap column toggled on =/

[13:33] *** denis_boyun joined
[13:35] <masak> FROGGS: well, especially in this case (with Interval) where there are *known* pitfalls that haven't been accounted for.

[13:35] <moritz> hoelzro: around 1.5GB, give or take

[13:36] <hoelzro> hmm

[13:36] <hoelzro> then I don't see why my VM is complaining

[13:36] <FROGGS> masak: yes, that I why I'd talk to drolsky first, and would ask him nicely for some kind of spec/design

[13:37] <masak> FROGGS: he has weighed in on exactly these issues on p6l at least once.

[13:37] <masak> FROGGS: his comments (and moritz++' work) were what led to a separate Date class.

[13:38] <masak> FROGGS: and it also made me aware of the subtleties involved in having a type representing a (human-datetime) interval.

[13:39] <FROGGS> well, we could have both, durations like humans think about it and durations like machines tend to think about it

[13:39] <FROGGS> but it is way more than that

[13:40] <FROGGS> don't know how his tuit supply is though, and if he is willing to invest more time

[13:42] <FROGGS> example: I use P5's spans and spansets a lot at work to calculate fees, so I know what I'd need for rewriting that in P6, but I guess I have not covered all absurdities that happen when it comes to times

[13:44] <masak> FROGGS: one well-known source of confusion in CPAN's DateTime::Duration is that it adds the units (IIRC) smallest-first.

[13:45] <FROGGS> that might be the reason why I only supply a single value

[13:45] <masak> so Feb 28 + (1 month, 1 day) is not Mar 29, but Apr 1.

[13:45] <masak> FROGGS: right, and "only supply a single value" is what .delta does!

[13:45] <masak> problem solved.

[13:45] <FROGGS> :o)

[13:45] *** kivutar left
[13:47] *** dmol1 left
[13:48] *** kaleem left
[13:49] <FROGGS> can we do spanset math already? I guess not

[13:50] <FROGGS> because that would be so much nicer as my well written P5 code

[13:50] * jnthn is back

[13:51] <FROGGS> welcome back, jnthn! \o/

[13:51] <jnthn> masak: Wouldn't Postel's Law mean being liberal in what you can pass in? ;)

[13:55] *** atroxaper joined
[13:55] *** rurban1 left
[13:58] * hoelzro shrugs

[13:58] <hoelzro> compiles fine when I turn off swap.

[13:58] <hoelzro> (don't try this at home, kids!)

[14:01] *** dakkar_ is now known as dakkar

[14:05] *** davecv joined
[14:05] *** dave1c joined
[14:05] *** nebuchadnezzar joined
[14:07] <Woodi> hallo :)

[14:07] *** kaare_ joined
[14:08] <Woodi> I think Duration and Interval are the same thing... Duration is just term more in Time department...

[14:09] *** Mouq joined
[14:09] <Woodi> some others here (clicking phase is nice):  https://translate.google.pl/?hl=pl&tab=wT#en/pl/interval

[14:10] <Woodi> but if we talk about human representations then chapter Builder from GangOfFour applies...

[14:11] <Woodi> (I openned it randomly yesterday @ caffeteria :)

[14:14] *** Mouq left
[14:15] <Woodi> btw. do Perl6 clousures are allowed to close any varible they can access during clousure creation or just values from function creating clousure ?

[14:16] <timotimo> i expect they close over everything they can access

[14:16] <jnthn> Anything visible

[14:16] *** pdurbin left
[14:17] <timotimo> right, because you can theoretically access more than is visible :P

[14:17] <Woodi> https://en.wikipedia.org/wiki/Closure_%28computer_science%29  shows just newly created me think... so we have better clousures ? :)

[14:18] *** rurban1 joined
[14:20] *** PacoAir joined
[14:29] *** kaleem joined
[14:31] *** lowpro30 joined
[14:32] *** PerlJam joined
[14:36] *** jnap joined
[14:46] *** berekuk joined
[14:48] *** lowpro30_ joined
[14:48] *** mtk left
[14:51] *** lowpro30__ joined
[14:51] *** lowpro30 left
[14:52] *** mtk joined
[14:54] *** lowpro30_ left
[14:59] <masak> jnthn: dangit! somehow I always get Postel's Law turned around! :(

[15:00] <jnthn> masak: Well, that's easily fixed. Just be more liberal about finding time to read about it, and conservative in how often you talk about it. :D

[15:01] <jnthn> The thing that always bothers me a tiny bit about Postel's Law is that it's kinda the opposite of what we learn from a security perspective: be picky about what you accept. :)

[15:01] <masak> yeah, I guess the assumption is something like "if the user is known-friendly"

[15:02] <masak> my current view of it (which may be what is confusing me) is "be picky about what you expect, but be hesitant in flagging user input as wrong"

[15:03] *** kivutar joined
[15:04] <jnthn> dalek: you working? :)

[15:05] <colomon> I believe in it very strongly for my $work.  Read any old crappy files written out by other CAD systems; always try to write out 100% correct files from ours.

[15:05] *** kaleem left
[15:06] *** kaare_ left
[15:08] <masak> it strikes me that the situation is very different depending on whether it's the one-and-only interaction between client and server, or whether we know that we are in an interactive, iterative environment like an event loop.

[15:09] <masak> I think Postel's Law applies best to the former.

[15:10] *** lowpro30__ left
[15:11] *** kaare_ joined
[15:11] <colomon> Which is my situation, I guess.  It's not like people trying to read a CAD file can go to the people who wrote the program that wrote the file and tell them to fix their bugs in a timely fashion.

[15:12] <colomon> "Dear AutoCAD.  You are incorrectly specifying the angles of cones in your STEP files.  Please get a fix by this afternoon to my friends that wrote this file for me."

[15:13] *** cognominal left
[15:14] *** cognominal joined
[15:16] <Woodi> tell that to photo camera manufacturers - everyone have it's own, secret RAW light catching format :)

[15:17] <colomon> (Note: I don't think that was the actual AutoCAD bug I ran into a couple of years back.  And luckily I do have contacts there that I could report the bug to.)

[15:17] <masak> colomon: interestingly, it also shows why XML's über-strictness in browsers is the wrong behavior.

[15:17] <masak> colomon: (because it is not the page visitor's fault that the page is faulty)

[15:17] <colomon> right

[15:21] *** arcterus left
[15:30] *** btyler joined
[15:32] * moritz founds strict XML parsing very helpful for the IRC logs, made my fix any possible cross-site scripting holes

[15:33] <masak> moritz: yes, but that's you as the author, not you as the visitor...

[15:34] <colomon> sure, and having a STEP file reader which complains at the slightest glitch is really handy for tuning my STEP file exporter to properly follow the (insanely complicated) spec.

[15:34] <moritz> masak: well, in some cases my visitors alerted my "page $url doesn't display here", and I fixed that too :-)

[15:37] <masak> moritz: I see. you have very nice visitors, then. :)

[15:39] <hoelzro> hmm

[15:39] <hoelzro> apparently you can't subclass Perl6::Grammar from within Perl 6 =/

[15:39] <hoelzro> I'm guessing that's because it's from NQP land

[15:41] * masak realizes he would like a super-easy way to mark a (user) class as being a value type in Perl 6

[15:43] <moritz> hoelzro: yes, jaffa4 recently had the same problem

[15:43] <moritz> masak: +1

[15:43] <masak> mainly to make them easily comparable with, hm, eqv, I guess.

[15:44] <hoelzro> moritz: do you know if they solved it?

[15:44] <moritz> with === I guess

[15:44] <moritz> hoelzro: no

[15:44] <hoelzro> hmm

[15:44] <masak> moritz: yeah, === is better.

[15:45] <moritz> and eqv already looks into the attributes by default, I believe

[15:45] <masak> r: class A {}; #`{magic invocation here}; say A.new === A.new # should print "True"

[15:45] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«False␤»

[15:45] <moritz> r: class A { has $.x }; given A.new(x => 42) { say $_ eqv A.new(x => 42); say $_ eqv A.new(x => 5) }

[15:45] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«False␤False␤»

[15:46] <moritz> hm, doesn't

[15:46] <masak> no, only array elements and hash entries, IIRC.

[15:49] <jnthn> As a thing to beat, .Net makes you inherit from ValueType...

[15:50] <hoelzro> hmm

[15:50] <hoelzro> well, my code *almost* works in NQP

[15:50] <hoelzro> but I get a null PMC access =/

[15:50] <hoelzro> and I've determined that it's trying to call unshift on @END_PHASERS

[15:51] <hoelzro> I take it I have to somehow set that up before calling Perl6::Grammar.parse?

[15:52] <masak> jnthn: that feels like a simple solution.

[15:53] <hoelzro> ah, I see it in main.nqp

[15:53] *** rurban1 left
[15:54] *** rurban1 joined
[15:57] *** Mouq joined
[15:58] *** denis_boyun left
[15:58] *** Psyche^ joined
[16:01] * masak decommutes

[16:01] *** Mouq left
[16:02] *** Psyche^_ left
[16:07] *** berekuk left
[16:09] *** berekuk joined
[16:24] <hoelzro> hmm

[16:24] <hoelzro> where does hll-config in main.nqp come from?

[16:25] <jnthn> Think it's generated 

[16:25] <hoelzro> grrr

[16:26] <jnthn> But I think you might get away with an empty one too...

[16:26] <hoelzro> I'm just trying to run main.nqp via nqp-p at the moment

[16:26] <hoelzro> (as a way of sanity checking things)

[16:26] *** PZt joined
[16:26] <hoelzro> it's proving...difficult.

[16:27] <hoelzro> hmm

[16:27] <hoelzro> my lack of --vmlibs is probably not helping =)

[16:28] <hoelzro> nope, that doesn't help either.

[16:35] <FROGGS> hoelzro: what do you wanna sanity check?

[16:35] <hoelzro> well, I'm trying to extend the Perl6::Grammar from an NQP program for an experiment I'm trying

[16:35] <FROGGS> r: say nqp::gethllsym('perl6', '$COMPILER_CONFIG')

[16:35] <camelia> rakudo-jvm 874e35: OUTPUT«("codename" => "", "name" => "rakudo", "release-number" => "", "build-date" => "2013-11-30T23:10:59Z", "version" => "2013.11-20-g874e358").hash␤»

[16:35] <camelia> ..rakudo-parrot 874e35: OUTPUT«("name" => "rakudo", "version" => "2013.11-20-g874e358", "release-number" => "", "codename" => "", "build-date" => "2013-12-01T00:20:06Z").hash␤»

[16:35] <hoelzro> I can't convince NQP to do what I want

[16:35] <FROGGS> do you want to access that?

[16:35] <hoelzro> so I'm just trying to get main.nqp to run atm

[16:35] <FROGGS> ahh, hmm

[16:36] <hoelzro> which it stubbornly refuses to do.

[16:37] <hoelzro> hmm

[16:37] <hoelzro> I may have figured it out

[16:37] <hoelzro> hmm

[16:37] *** fhelmberger joined
[16:37] <hoelzro> is there an nqp op for asking about an object's type?

[16:37] <hoelzro> like nqp::type(@args)?

[16:37] <moritz> I'd try nqp::what

[16:38] <moritz> nqp: my $x := nqp::what([]); say($x.HOW.name($x))

[16:38] <camelia> nqp-parrot: OUTPUT«Can only use get_what on a SixModelObject␤current instr.: '' pc 50 ((file unknown):43) (/tmp/eTdISkhp_s:1)␤»

[16:38] <camelia> ..nqp-moarvm, nqp-jvm: OUTPUT«NQPArray␤»

[16:38] <hoelzro> that angered NQP

[16:38] <moritz> jvm++

[16:38] <moritz> moar++

[16:38] * hoelzro cries

[16:39] <hoelzro> I can't wait for the Moar port to be done.

[16:39] <moritz> then don't wait; help!

[16:39] *** SamuraiJack_ joined
[16:41] <hoelzro> heh

[16:41] <jnthn> nqp-j: sub foo() { }; foo(1)

[16:41] <hoelzro> I'd like to

[16:41] *** fhelmberger_ left
[16:41] <camelia> nqp-jvm: OUTPUT«Wrong number of arguments passed; expected 0..0, but got 1␤  in foo (/tmp/CPPvYxcvRD)␤  in  (/tmp/CPPvYxcvRD:1)␤  in  (gen/jvm/stage2/NQPHLL.nqp:1100)␤  in eval (gen/jvm/stage2/NQPHLL.nqp:1086)␤  in evalfiles (gen/jvm/stage2/NQPHLL.nqp:1292)␤  in command_…»

[16:41] <hoelzro> learning more about moar is on my TODO list

[16:41] *** ajr joined
[16:41] * hoelzro decommute &

[16:41] *** ajr is now known as Guest68285

[16:42] *** Guest68285 is now known as ajr_

[16:42] *** fhelmberger left
[16:44] *** thou joined
[16:45] *** atroxaper left
[16:45] *** kaleem joined
[16:50] *** berekuk left
[17:01] *** berekuk joined
[17:09] *** salv0 left
[17:10] *** salv0 joined
[17:11] * hoelzro fg

[17:11] <perigrin> hoelzro: no.

[17:11] <perigrin> I refuse to be foregrounded by you.

[17:11] <perigrin> :)

[17:11] <hoelzro> =)

[17:12] *** dmol joined
[17:12] <timotimo> ohai

[17:13] <timotimo> what do i do today?

[17:13] <FROGGS> fix pow_I ?

[17:13] <timotimo> i feel like more sleep ...

[17:13] <FROGGS> :o)

[17:13] <timotimo> who, me?

[17:13] <FROGGS> ohh, well, that would work too

[17:13] <FROGGS> if you want to... should not take too long

[17:14] <timotimo> is that a moar problem?

[17:14] <FROGGS> yes

[17:14] <timotimo> i could certainly have a quick look

[17:14] <FROGGS> see the commit msg: https://github.com/MoarVM/MoarVM/commit/091a2369e

[17:14] <timotimo> but my head is kind of achy

[17:14] <FROGGS> it should return a num if it returns NaN or Inf, and int in all other cases I think

[17:15] <FROGGS> no problem, I can do that too later

[17:15] <hoelzro> so I'm looking at this conditional declaration of MAIN in main.nqp

[17:15] <hoelzro> sub MAIN(@args) for Parrot

[17:15] <hoelzro> sub MAIN(*@args) for !Parrot

[17:16] <hoelzro> what's the deal with that?

[17:16] <hoelzro> because I actually can't get it to work on Parrot unless I change it to slurpy args

[17:16] <timotimo> need to get home first

[17:16] <colomon> hoelzro: might indicate we need another test….

[17:18] <timotimo> what are you working on? workshop exercises?

[17:18] <jnthn> FROGGS, timotimo: There's a ticket also

[17:18] <jnthn> (about the pow_I issue)

[17:18] <hoelzro> timotimo: me?

[17:19] <jnthn> hoelzro: Some annoying oddity about pre-compiled vs run from command line also, iirc...

[17:19] <timotimo> I'd rather fix something that brings us closer to hello world :P

[17:19] <hoelzro> ah, that would do it

[17:19] <timotimo> yes you

[17:19] <hoelzro> I'm working on an idea I had over the weekend

[17:19] <hoelzro> I was trying to do it in Perl6 land, but I can't subclass Perl6::Grammar from there =/

[17:20] <hoelzro> so it's NQP land for me

[17:20] *** Mouq joined
[17:20] <timotimo> that is something i hope we can get to work, though

[17:21] <timotimo> either that or making rakudo self host on p6 :P

[17:21] <hoelzro> =)

[17:22] *** arcterus joined
[17:24] <arnsholt> hoelzro: If it's any consolation, eliminating that problem with arrays not being sixmodelobjects on Parrot is something we want to kill (there's even a bug for it), but it's a bit of a drudge to actually complete

[17:30] *** kaleem left
[17:32] *** Rotwang joined
[17:33] <hoelzro> I see

[17:36] <hoelzro> hmm

[17:36] <masak> interesting comment to my post: http://perl6advent.wordpress.com/2013/12/02/day-02-the-humble-type-object/#comment-3319

[17:36] <masak> (I don't agree, by the way)

[17:36] <hoelzro> now I'm getting a null PMC access in get_pmc_keyed

[17:36] <hoelzro> I discovered that it's trying to access %*COMPILING

[17:36] <hoelzro> but I already have a my %*COMPILING in my MAIN

[17:37] <hoelzro> (on a separate note, %*COMPILING just makes me think of "winning!")

[17:37] *** SamuraiJack_ left
[17:37] <hoelzro> masak: you could just use a pragma-like module to add that behavior if you wanted it, though

[17:38] <hoelzro> right?

[17:38] <hoelzro> (by you I mean the commenter)

[17:39] <hoelzro> oh, I see now

[17:39] <hoelzro> %*COMPILING<%?OPTIONS> must also be a hahs

[17:39] <hoelzro> seems reasonable.

[17:40] <jnthn> I think S12 or S06 already spec a pragma for that.

[17:43] <masak> hoelzro: yes, I guess so.

[17:45] <hoelzro> hmm

[17:45] <hoelzro> ok

[17:45] <hoelzro> so my basic NQP interpreter thingy works.

[17:45] <hoelzro> now I'm trying to extend Perl6::Grammar

[17:45] <hoelzro> and NQP yells at me

[17:45] <hoelzro> "P6opaque only supports type changes where the MRO of the original type is a suffix of the MRO of the new type"

[17:45] <hoelzro> any tips?

[17:45] *** zakharyas joined
[17:46] <hoelzro> I don't even know what types I'm changing

[17:47] <jnthn> hoelzro: The debugger manages to subclass Perl6::Grammar. I remember having that error somewhere along the way.

[17:47] <hoelzro> ok, I shall look

[17:47] <arnsholt> masak: Interesting comment, but I agree with you

[17:48] <arnsholt> Any method that requires a defined self will fail whenever it tries to do whatever it is that requires it to be defined. Perhaps a bit LTA, but one less thing to remember if you want a method callable on the type object

[17:49] <TimToady> the way to make a value type is to define .WHICH such that it returns the same identity for the same value

[17:50] <jnthn> Hm, that means if you want a generic solution, just write a module and then "does ValueTypeStuff" :)

[17:50] <jnthn> Where the role provides a WHICH

[17:51] <TimToady> sure, that's one way to do it :)

[17:51] *** arcterus left
[17:51] <jnthn> dalek: why u no report my commits? :P

[17:51] <jnthn> dalek: restart

[17:51] <TimToady> otoh, you also ought to worry about immutability if you have a value, so you can't just treat value-ness as a special sauce

[17:51] <jnthn> ?

[17:52] <jnthn> Hmm

[17:52] <jnthn> dalek: help

[17:52] <jnthn> Ah well...

[17:53] <TimToady> unless, of course, we have a generic way to disable all publicly-visible mutations (caches being a notable exception)

[17:53] <hoelzro> ah, got it

[17:53] <hoelzro> you have to override comp_unit

[17:53] <jnthn> Ah, seems nothing is responding on http://feather3.perl6.nl:5000/

[17:53] <hoelzro> and populate %*LANG

[17:53] <jnthn> hoelzro: Ah, yeah, 'cus that's the braid source 

[17:54] <hoelzro> this is proving to be quite a useful experiment =)

[17:55] *** dakkar left
[17:57] <masak> moritz: did you see the good hpmor news today? :)

[17:57] *** lumimies joined
[17:57] * TimToady sometimes wonders whether %*LANG is a hack to avoid doing the work of mixing in all your sublanguage switchers

[17:57] <hoelzro> mwahahaha

[17:58] <hoelzro> it works!

[18:00] <TimToady> or, to look at it another way, will %*LANG eventually prevent some optimizations that would be possible if you looked up sublanguages by method rather than by hash?

[18:01] <TimToady> or is the hash preventing a combinatorial explosion of lexers?  dunno offhand...

[18:03] <TimToady> well, not inclined to change anything until we run into a real problem, but just had to mention that I do wonder about that from time to time

[18:03] *** PerlJam left
[18:05] <hoelzro> how do you iterate over an NQP hash's keys, again?

[18:05] <masak> TimToady: flood filling demands we try both! :P

[18:06] <TimToady> that only works with a flood of volunteers :)

[18:07] <TimToady> doubtless someday there will be a huge east/west schism over this issue

[18:07] *** PerlJam joined
[18:08] <TimToady> since it's one of those "who's to master" issues :)

[18:12] <hoelzro> hmm

[18:12] <hoelzro> perl6.org is quite tempermental today.

[18:16] <[Coke]> I see dalek, but no commit messages?

[18:17] <jnthn> [Coke]: The thing that github should call in feather is down..

[18:17] <jnthn> [Coke]: Maybe not started again after a feather restart?

[18:18] <[Coke]> ah, probably didn't survive the reboot. danke.

[18:18] <[Coke]> :)

[18:19] <TimToady> actually, not being able to derive the Perl 6 grammar in P6-Land is a huge blocker to language mutability and sane macros; it negates our answer to Lisp's homoiconicity until we can actually parse Perl 6 in real Perl 6

[18:19] <[Coke]> regarding the java vs. parrot status in the advent article - java's been in the lead for weeks.

[18:19] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv

[18:20] <jnthn> [Coke]: Thanks, I'll need to work on that article soon, I guess. :)

[18:21] <[Coke]> jnthn: someone quoted the stats in the first article, I think.

[18:21] <[Coke]> I can't be here AND check that at the same time, stupid network.

[18:22] <TimToady> yes, I wondered about that 99.9% bit

[18:23] <[Coke]> if I want to play with moar on rakudo, it's the moar-support branch in rakudo? (should perl Configure.pl --gen-nqp --backends=moar work?)

[18:26] <FROGGS> hoelzro: grep for nqp::iter* in nqp

[18:26] <hoelzro> ah, thank you FROGGS 

[18:26] <jnthn> [Coke]: It doesn't work yet so there's not much to play with... :) Builds the setting, mind...

[18:27] <jnthn> shop; bbiab

[18:28] <[Coke]> jnthn: I can't even get it to build moar.

[18:28] <[Coke]> (or run Configure.pl without warnings). I'll see about adding some cleanups for that.

[18:29] <[Coke]> ... after $dayjob.

[18:30] <[Coke]> hoelzro: a doc patch adding iter to the docs/ops* would be most welcome.

[18:31] <hoelzro> I think that can be arranged =)

[18:33] *** sizz joined
[18:33] *** ashleydev joined
[18:34] *** sizz_ left
[18:35] <FROGGS> hoelzro++

[18:35] <hoelzro> hmm

[18:35] <hoelzro> I wonder if we should submit Perl 6 repos for the 24 PRs thing?

[18:36] *** colomon left
[18:36] <FROGGS> 24 PRs thing?

[18:37] *** pecastro left
[18:37] *** ajr_ left
[18:38] *** ajr joined
[18:38] *** colomon joined
[18:38] *** ajr is now known as Guest67784

[18:38] *** darutoko left
[18:39] *** Guest67784 is now known as ajr_

[18:39] *** denis_boyun joined
[18:40] *** pecastro joined
[18:48] *** Duchess joined
[18:49] *** ajr_ left
[18:51] *** Esylt left
[18:56] <hoelzro> http://24pullrequests.com

[18:59] *** berekuk left
[18:59] *** colomon left
[19:01] <FROGGS> that would be awesome!

[19:01] *** colomon joined
[19:01] *** berekuk joined
[19:07] <hoelzro> =(

[19:07] <FROGGS> ?

[19:07] <hoelzro> I said "Perl 6" as the programming language

[19:07] <hoelzro> invalid entry: "must be a programming language"

[19:07] <hoelzro> fools!

[19:07] <FROGGS> :(

[19:07] <hoelzro> I'll just say Perl

[19:08] <FROGGS> wait, maybe we can patch it :o)

[19:09] <hoelzro> hehe

[19:09] <hoelzro> good idea!

[19:11] *** ajr_ joined
[19:14] *** berekuk left
[19:16] <FROGGS> PR sent

[19:16] <Rotwang> is NativeCall broken in 2013 11 or is it just me?

[19:16] <FROGGS> what is wrong?

[19:16] <FROGGS> its tests pass on my box, and Inline::C which uses it works too

[19:18] <hoelzro> FROGGS: wow, nice!

[19:20] <hoelzro> PR sent for nqp =)

[19:21] <Rotwang> FROGGS: I'll try to make some minimal example

[19:21] <hoelzro> EXPR/OPER are special rules, right?

[19:22] <FROGGS> Rotwang: that would help

[19:22] <hoelzro> they're provided by some convenience routines or something?

[19:22] <FROGGS> hoelzro: they live in HLL::Compiler or so

[19:22] <hoelzro> ah ha

[19:22] <FROGGS> they are methods

[19:22] *** sqirrel joined
[19:23] <hoelzro> hmm

[19:23] <hoelzro> it looks like if I define OPER in my actions class, it doesn't get called =(

[19:24] <FROGGS> maybe it must go into your grammar?

[19:24] <FROGGS> that is what I would expect

[19:24] <jnthn> OPER?

[19:25] <FROGGS> because action methods are called when their grammar token/rulen has matched

[19:25] <hoelzro> OPER or EXPR

[19:25] <hoelzro> I only care about the former atm

[19:25] <hoelzro> but I could see myself caring about the latter

[19:25] <hoelzro> hmmm

[19:25] <hoelzro> since this is just a hack

[19:25] <hoelzro> I could override OPER in the grammar

[19:25] <hoelzro> good thinking FROGGS =)

[19:26] <FROGGS> hoelzro: PR merged!

[19:27] <FROGGS> hoelzro: both, the 24prs and the nqp one...

[19:27] <FROGGS> what happened to dalek?

[19:29] *** nnunley joined
[19:30] <Rotwang> FROGGS: > hai.c && gcc -shared -fPIC -o libhai.so hai.c; perl6 -e 'use NativeCall;sub hai() is native("./libhai.so") { * };hai'

[19:31] <Rotwang> this is what I get: http://paste.lisp.org/display/140342

[19:31] *** nnunley left
[19:33] <FROGGS> hmmm

[19:34] <FROGGS> Rotwang: can you paste hai.c too?

[19:34] <Rotwang> FROGGS: > hai.c

[19:34] <Rotwang> it is empty

[19:34] <FROGGS> > hai.c && gcc -shared -fPIC -o libhai.so hai.c; perl6 -e 'use NativeCall;sub hai() is native("./libhai.so") { * };hai'

[19:34] <FROGGS> Cannot locate symbol 'hai' in native library './libhai.so'

[19:34] <FROGGS> that is what I get

[19:34] <Rotwang> weir

[19:34] <Rotwang> d

[19:34] <FROGGS> yea

[19:34] <FROGGS> h

[19:35] <hoelzro> FROGGS: thanks!

[19:35] <FROGGS> hoelzro: pleasure!

[19:36] <FROGGS> Rotwang: and mine fails in line 124, while your fails in 120

[19:36] * rjbs has just parted company with diakopter, who left saying, "I should really move to Philadelphia."

[19:36] *** berekuk joined
[19:36] <Rotwang> FROGGS: yeah in your case it fails as it should it seems

[19:37] <FROGGS> Rotwang: https://github.com/jnthn/zavolaj/pull/30

[19:37] <FROGGS> Rotwang: do a panda update, and panda install NativeCall

[19:39] <Rotwang> FROGGS: ok good to know [;, thanks

[19:39] <FROGGS> I hope it helps

[19:41] <Rotwang> I should probably use it without extension anyway

[19:42] <FROGGS> yes, if you want it to be portable for example

[19:51] <TimToady> once again in the situation of having to blow away install and nqp and rebootstrap all nqp compilers, sigh...

[19:51] <hoelzro> gruuu

[19:52] <hoelzro> NQP doesn't support captures, does it?

[19:52] <hoelzro> ex. method EXPR(|args)

[19:55] <moritz> hoelzro: no, you have to use EXPR(|@pos, |%named)

[19:55] <hoelzro> ah ha

[19:58] *** dalek left
[19:58] *** dalek joined
[19:58] *** ChanServ sets mode: +v dalek

[19:59] * TimToady grumbles about not-quiteness

[19:59] <FROGGS> TimToady: what happened?

[20:01] <TimToady> same hangup trying to compile m-BOOTSTRAP, which no amount of submodule sync or remaking or git pulling would fix

[20:02] <TimToady> eventually I was in a state of having a gen/moar/.gitignore that something installed as a managed file, and git was very unhappy with me, so I gave up

[20:02] <lue> hello world o/

[20:02] <TimToady> but it's aggravating to have to regen parrot and jvm stuff in order to regen the moar stuff

[20:03] <TimToady> and from prior experience, just regenning moar means it thinks you want to throw away the parrot and jvm stuff, and it gets very confused

[20:04] <FROGGS> yeah

[20:04] <TimToady> this gen stuff is very all or nothing

[20:04] <FROGGS> :o(

[20:04] <TimToady> and very much against the spirit of 'make'

[20:04] <moritz> how about just running 'make m-clean' in nqp?

[20:05] <TimToady> didn't help

[20:05] <FROGGS> rp: say <.. .>.first( *.IO.w ) # <--- I love that btw

[20:05] <camelia> rakudo-parrot 874e35: OUTPUT«.␤»

[20:05] <FROGGS> I hope it gets better when we merge moar-support into nom

[20:05] <TimToady> thing is, a make m-clean can't fix a mis-gen

[20:06] *** zakharyas left
[20:07] <FROGGS> btw, you can be lucky that you don't add ops to moarvm... because there is a perl6 script that updates the op lists

[20:07] <TimToady> or two gens that get out of sync via git

[20:07] *** eiro left
[20:07] <FROGGS> which can be funny when you have no perl6 binary because you tried to build perl6-m

[20:10] <hoelzro> hmm

[20:10] <hoelzro> HLL::Actions and Perl6::Actions both hook into EXPR

[20:10] <hoelzro> but my EXPR method isn't getting called

[20:10] <FROGGS> and NQP::Actions to mention a third :o)

[20:10] *** dmol left
[20:11] <hoelzro> noted =)

[20:12] <hoelzro> hmm

[20:12] <FROGGS> hoelzro: do you have a EXPR token in your grammar=

[20:12] <FROGGS> ?

[20:12] <hoelzro> it's just inheriting from Perl6::Grammar

[20:13] <hoelzro> my EXPR method seems to be called, because adding make 5; to my EXPR method blows everything up.

[20:13] *** dmol joined
[20:13] <FROGGS> hmmm

[20:13] *** rurban2 joined
[20:13] <hoelzro> hmm

[20:13] <hoelzro> or not

[20:13] *** rindolf joined
[20:13] <hoelzro> (throwing an exception didn't work)

[20:14] <FROGGS> but your EXPR method is in your grammar now, right? like the one in Perl6::Grammar

[20:15] <hoelzro> oh, no

[20:15] <hoelzro> I removed it, considering that the other actions methods have EXPR methods

[20:16] *** rurban1 left
[20:17] <hoelzro> hmm

[20:17] <hoelzro> if I add EXPR to my grammar

[20:17] <hoelzro> I'm not sure how to populate $/

[20:18] <FROGGS> self.orig should do

[20:18] <FROGGS> err, no

[20:18] <FROGGS> I think you don't have that at that point

[20:18] <hoelzro> crap.

[20:18] * moritz tries to restart all of dalek

[20:19] *** dalek left
[20:19] <hoelzro> I think I'll take a break on this.

[20:19] *** dalek joined
[20:19] *** ChanServ sets mode: +v dalek

[20:21] *** eiro joined
[20:22] <moritz> wow, more than 800 page views on both days of the advent calendar

[20:23] <FROGGS> wow

[20:25] <dalek> nqp: 4128a67 | moritz++ | .gitignore:

[20:25] <dalek> nqp: .gitignore MANIFEST, which is ignored by the release process

[20:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4128a67c70

[20:26] <moritz> dalek works again \o/

[20:28] <moritz> FROGGS: two (iirc) years ago we were slashdotted and tweeted by tim o'reilly, and had 11k views on one day :-)

[20:28] <FROGGS> O.o

[20:29] <FROGGS> that is nice :o)

[20:34] <moritz> ah, it was 2010

[20:38] *** kst` is now known as kst

[20:42] <Rotwang> I've noticed that: say "foo" »~» "bar"».grep: { False };

[20:42] <Rotwang> runs with no end on my machine

[20:43] <jnthn> p: say "foo" »~» "bar"».grep: { False };

[20:43] <camelia> rakudo-parrot 874e35: OUTPUT«(timeout)»

[20:43] <jnthn> p: say "foo" »~» ();

[20:44] <camelia> rakudo-parrot 874e35: OUTPUT«(timeout)»

[20:44] <jnthn> Well, that golfed quickly...

[20:45] <Rotwang> so I guess it shouldn't happen?

[20:45] <lue> ooc, is "str".encode("UTF-32") supposed to return a utf32 object, or would I need to do type conversion, e.g. "str".encode("UTF-32").utf32 or "str".utf32 ?

[20:46] *** awwaiid joined
[20:46] <masak> we still have a big huge gap in the advent calendar on the 4th, 5th, 6th, 7th, and 8th.

[20:47] <masak> I refuse to believe that Perl 6 is in a less active state than last year. that doesn't accord with anecdotal evidence.

[20:47] <masak> I think there are volunteers out there that haven't stepped forward yet. :)

[20:47] <masak> jnthn: you're up for tomorrow. are you writing a post?

[20:48] <Rotwang> jnthn: should I make a bug report or something?

[20:48] <raydiak> perhaps perl 6 has become so useful that people are distracted by using it more than last year? :)

[20:50] <masak> raydiak: nice try :P

[20:51] <moritz> masak: for me it's mostly depletion of good ideas

[20:52] <moritz> many simple-to-explain ideas have already been covered on the advent

[20:52] <dalek> mu: b170e30 | lue++ | misc/perl6advent-2013/schedule:

[20:52] <dalek> mu: [advent-2013] Signup for Day 4, heredocs.

[20:52] <dalek> mu: review: https://github.com/perl6/mu/commit/b170e30439

[20:52] <moritz> ++lue

[20:54] <masak> lue++

[20:54] <lue> I should probably remove the heredocs idea from the brainstorm list, right?

[20:54] <masak> yeah.

[20:54] <masak> moar volunteers!

[20:55] <masak> moritz: I started skimming the synopses in order, looking for ideas for my posts. when I was done, I had gotten to mid-S03. ;)

[20:55] <dalek> mu: 0b818bb | lue++ | misc/perl6advent-2013/topic-brainstorming:

[20:55] <dalek> mu: [advent-2013] Remove heredocs from brainstorm list.

[20:55] <dalek> mu: 

[20:55] <dalek> mu: No sense making someone believe some topic's not be covered! :)

[20:55] <dalek> mu: review: https://github.com/perl6/mu/commit/0b818bbb0a

[20:56] *** zakharyas joined
[20:57] <jnthn> Rotwang: Yes, I'd file a bug report

[20:57] *** kaare_ left
[20:57] <Rotwang> ok

[20:57] <jnthn> masak: Yes, I'm working on my most rajt nau

[20:58] <jnthn> uh, post

[20:58] <jnthn> .oO( a bridge to fail... )

[20:58] <masak> how most appropriate. :)

[20:58] <moritz> .oO( bridge over troubled bytecode )

[21:00] <dalek> mu: c9e5e17 | moritz++ | misc/perl6advent-2013/ (2 files):

[21:00] <dalek> mu: [advent] claim day 7, with Date and maybe DateTime

[21:00] <dalek> mu: review: https://github.com/perl6/mu/commit/c9e5e17356

[21:03] <lue> Oh yeah! masak: does at least Instant.new($seconds) and Duration.new($seconds) sit right with you? :) [maybe some epoch issues, but aside from that...]

[21:04] *** kivutar left
[21:09] <moritz> 13 unclaimed slots

[21:11] <timotimo> oh lue, heredocs are cool :)

[21:11] <masak> lue: not sure there'll even be epoch issues -- need to think about that. but the immediate question becomes: why do you need *two* separate classes for that?

[21:12] <masak> lue: in fact, that's a good question anyway.

[21:12] *** stevan_ left
[21:12] *** ggoebel111 joined
[21:12] <lue> masak: yeah, I was thinking of "why isn't Duration just Instant.delta" as a counterargument to the "delta is good enough" for Interval the other day :)

[21:13] *** _thou joined
[21:13] *** ajr joined
[21:13] *** ajr is now known as Guest76769

[21:14] <nwc10> jnthn: is origin/indy-args supposed to work with current rakudo HEAD?

[21:15] <jnthn> nwc10: I've no idea how things work out with it and Rakudo.

[21:15] <nwc10> ah OK

[21:15] <jnthn> nwc10: It's in a branch for a reason ;)

[21:15] <jnthn> It's a fair upheavel.

[21:16] <nwc10> Stage start      :   0.000

[21:16] <nwc10> java.lang.NoSuchMethodError: 1B74F280B2FD5C2A2EDF6F91C8F3FCF2B7BE1643.qb_2(Lorg/

[21:16] <nwc10> perl6/nqp/runtime/CompilationUnit;Lorg/perl6/nqp/runtime/ThreadContext;Lorg/perl

[21:16] <nwc10> 6/nqp/runtime/CodeRef;Lorg/perl6/nqp/runtime/CallSiteDescriptor;Lorg/perl6/nqp/r

[21:16] <nwc10> untime/ResumeStatus$Frame;)V in trait_mod:<is> (gen/jvm/CORE.setting)

[21:16] <nwc10> [etc]

[21:16] <nwc10> gah, my terminal. Line breaks when I don't want them

[21:16] <nwc10> and not when they should be there.

[21:16] <jnthn> yeah, that

[21:16] <jnthn>  sucks

[21:16] <nwc10> anyway, goes boom like that currently.

[21:16] *** lowpro30 joined
[21:17] <jnthn> Not quite sure where that error comes from, but yes, it's the kind of error I can quite easily relate to what I'm doing. :)

[21:17] <jnthn> Which is making it so some common invocation patterns don't have to go playing with an Object[] arg array.

[21:18] *** dmol left
[21:19] *** dmol joined
[21:19] *** xenoterracide joined
[21:19] <FROGGS> r: my @a = regex { \w }, regex { \d }; say @a.first( 1 ~~ * ) # isn't that supposed to work?

[21:19] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«␤»

[21:20] *** ajr_ left
[21:20] *** thou left
[21:20] *** ggoebel110 left
[21:21] *** berekuk left
[21:21] <FROGGS> r: my @a = regex { \w }; say so @a.first( "a" ~~ * )

[21:22] <camelia> rakudo-jvm 874e35: OUTPUT«Cannot call 'match'; none of these signatures match:␤:(Cool:D : $target, *%adverbs)␤  in any  at gen/jvm/BOOTSTRAP.nqp:1201␤  in method Bool at gen/jvm/CORE.setting:12368␤  in block  at /tmp/s8bdpuZlUc:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:…»

[21:22] <camelia> ..rakudo-parrot 874e35: OUTPUT«Cannot call 'match'; none of these signatures match:␤:(Cool:D : $target, *%adverbs)␤  in any  at gen/parrot/BOOTSTRAP.nqp:1218␤  in any  at gen/parrot/BOOTSTRAP.nqp:1209␤  in method match at gen/parrot/CORE.setting:3435␤  in method Bool at gen/…»

[21:22] <Mouq> r: (1 ~~ *).say

[21:22] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«True␤»

[21:22] <Mouq> It doesn't doesn't code-ify

[21:23] *** lowpro30_ joined
[21:23] <lue> r: (1 ~~ *).WHAT.say

[21:23] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Bool)␤»

[21:23] <lue> r: {1 ~~ *}.WHAT.say

[21:23] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«(Block)␤»

[21:23] <FROGGS> r: my @a = regex { \w }; say so @a.first( *.ACCEPTS("a") )

[21:23] <Mouq> I think that's appropriate, that way you can say given $something { when * { ... }}

[21:23] <camelia> rakudo-jvm 874e35: OUTPUT«Cannot call 'match'; none of these signatures match:␤:(Cool:D : $target, *%adverbs)␤  in any  at gen/jvm/BOOTSTRAP.nqp:1201␤  in method Bool at gen/jvm/CORE.setting:12368␤  in block  at /tmp/AwuHnS454E:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:…»

[21:23] <camelia> ..rakudo-parrot 874e35: OUTPUT«Cannot call 'match'; none of these signatures match:␤:(Cool:D : $target, *%adverbs)␤  in any  at gen/parrot/BOOTSTRAP.nqp:1218␤  in any  at gen/parrot/BOOTSTRAP.nqp:1209␤  in method match at gen/parrot/CORE.setting:3435␤  in method Bool at gen/…»

[21:24] <jnthn> I think it's intentional that ~~ doesn't auto-curry

[21:24] <jnthn> Or auto-closure, or whatever we call it... :)

[21:24] <FROGGS> what about my last example?

[21:25] <FROGGS> r: my @a = regex { \w }; say [||] @a>>.ACCEPTS("a")

[21:25] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«｢a｣␤␤»

[21:25] <FROGGS> I thought it would do that

[21:26] <jnthn> FROGGS: Yes, was something odd about that .first one...not sure what's up there

[21:26] *** lowpro30 left
[21:30] <timotimo> FROGGS: my headache decided not to subside, so I haven't actually looked at pow_I. did you get a chance?

[21:31] <FROGGS> timotimo: no, still working on module installation...

[21:31] <FROGGS> timotimo: it is not pressing, so we don't have to do it today

[21:32] *** SevenWolf joined
[21:32] <timotimo> all right

[21:33] *** stevan_ joined
[21:37] <raydiak> is there a clean way to make a coercive type declaration like (MyClass(Hash) $obj) work, so you can optionally pass a hash instead of having to create an instance of MyClass manually?  or would I be better off writing it as a multi which instantiates MyClass and then passes it to the other multi?

[21:38] <jnthn> We don't have coercion types implemented yet anyway, I'm afraid...

[21:38] <jnthn> The multi approach sounds good.

[21:38] <raydiak> ah, thanks!  you may have just saved me a lot of frustration :)

[21:39] <jnthn> Note that a multi foo(%bar) { } will accept anything Hash-y rather than just a Hash (to be precise, anything Associative)

[21:40] *** Rix left
[21:42] <raydiak> if MyHash inherits from Hash, then will multi foo(MyHash %bar) be called in preference to multi foo(Hash %bar) if I pass a MyHash?  I'm still a bit fuzzy on exactly how it chooses which multi to call

[21:42] <timotimo> it should

[21:42] <timotimo> but isn't MyHash %foo something different from what you want?

[21:43] <timotimo> i remember there being some gotcha for @ and % when giving it a type annotation

[21:43] <jnthn> MyHash %foo means "%foo of MyHash" which is usually not what you mean.

[21:43] <raydiak> oh right...%foo is MyHash?

[21:44] <jnthn> Um...dunno. I'd just write a straight MyHash $bar in that case...

[21:44] <raydiak> on one side, it means the container...on the other, it means the contents...but I forget precisely how it goes

[21:45] <jnthn> After all, anything can go into a scalar and you always are talking about the exact type there...

[21:45] <jnthn> And yes, it respects subtyping.

[21:46] <raydiak> you're right...I played around with this for a while before I started Pray...ran in to weirdness with sigils and abandoned it in favor of a more simplistic model until I had a better hold on what I was doing

[21:47] <lue> raydiak: it is    %foo is MyHash    unless S02 is wrong, that is :)

[21:47] <raydiak> when coersion types work, will there be a simple way to do what I was talking about, without having to much about with the meta model to add a coercion routine to the Hash class?

[21:48] <jnthn> lue: Yes, but I tend to guide people wrt what I know works ;)

[21:49] <jnthn> lue: And I know for sure the "is" thingy doesn't :)

[21:49] <jnthn> raydiak: Yes, the way to do it is to override invocation on the type object...

[21:49] <lue> I suppose that is AReasonableWayToHelpPeople.

[21:49] <raydiak> s/much about/muck about/

[21:51] <raydiak> jnthn: I'm still trying to figure out what that means :)

[21:51] *** Ben_Goldberg joined
[21:51] <jnthn> r: class A { method &.(A:U: (%h)) { say 'here'; A.new } }; say A({}) # I think...

[21:51] <camelia> rakudo-parrot 874e35, rakudo-jvm 874e35: OUTPUT«here␤A.new()␤»

[21:52] <raydiak> ahhh, I'm starting to get it

[21:53] <raydiak> jnthn++ timotimo++ lue++ # slowly bringing clarity to my fuzzy understandings :)

[21:54] <raydiak> how does an advent post about building an array-based class sound?

[21:55] <raydiak> walk through creating a simple Vector class that can be used interchangably with and as Arrays

[21:56] <masak> sounds nice.

[21:56] <timotimo> yeah, i'd like to read that

[21:57] <raydiak> done deal, then, I'll go mark it down

[21:57] <masak> \o/

[21:58] * timotimo already has 3 paragraphs on his post, but it seems unnecessarily long and focused too much on me :P

[21:58] <jnthn> raydiak++

[21:58] <jnthn> My post is coming along.

[21:59] <masak> timotimo: add more kittens?

[21:59] <masak> :P

[21:59] <dalek> mu: b983ca2 | raydiak++ | misc/perl6advent-2013/schedule:

[21:59] <dalek> mu: claim day 8: Array-based objects

[21:59] <dalek> mu: review: https://github.com/perl6/mu/commit/b983ca261c

[22:02] <raydiak> left myself enough time for research and peer review since I'm still about chest-deep in ignorance

[22:03] *** airdisa joined
[22:05] <masak> 'night, #perl6

[22:05] <raydiak> \o

[22:05] *** airdisa_ joined
[22:07] *** lizmat joined
[22:07] * lizmat has decommuted for today

[22:08] <jnthn> lizmat: Hope it was a fine journey.

[22:08] *** airdisa left
[22:08] <lizmat> apart from needing 1.5 hours for the first 10 km., it was fine

[22:09] <lizmat> 45 minutes to spare was not enough, in the end we arrived 80+ minutes later than originally planned

[22:11] <jnthn> That's a slow first 10km...

[22:13] <lizmat> yeah, some accident on the outgoing road to Folkestone, percolated all the way down to the centre of London

[22:13] <lizmat> ah well, at least we had enough time to make nice pictures of the Tower Bridge complex

[22:13] <lizmat> :-)

[22:14] * lizmat continues to unpack and re-organize stuff

[22:14] <jnthn> :)

[22:19] *** Ben_Goldberg left
[22:20] *** BenGoldberg joined
[22:22] *** raiph joined
[22:24] <jnthn> http://perl6advent.wordpress.com/?p=1897&preview=true # help me review :)

[22:24] <FROGGS> jnthn: Error 404 - Not Found

[22:24] <FROGGS> well, at least spelled correctly :o)

[22:25] *** arcterus joined
[22:26] <nwc10> 404 here too. I like the way that the real URL is 404-or-not depending on logged-in-ness

[22:26] *** ggoebel111 left
[22:26] *** sqirrel left
[22:26] *** Ben_Goldberg joined
[22:26] *** BenGoldberg left
[22:27] *** [Sno] joined
[22:27] <FROGGS> hmmm, I thought I had write access.... apparently not

[22:27] <PerlJam> jnthn: your 3rd point under "Why the JVM?" almost says this but what about "every other major dynamic language has an implementation that targets the JVM except Perl"? 

[22:28] *** BenGoldberg joined
[22:29] <[Coke]> can someone invite me to the p6avent wordpress site? I have a login, but no privs.

[22:29] <FROGGS> same for me...

[22:30] <jnthn> PerlJam: Added "Furthermore, every other major dynamic language is on the JVM. So, why not Perl too?"

[22:31] <raiph> (same 4 me on advent site)

[22:31] *** Ben_Goldberg left
[22:32] *** lowpro30_ left
[22:32] <PerlJam> jnthn: I read the whole thing and didn't really see anything to comment on.  Looks good!  jnthn++

[22:33] <PerlJam> [Coke]: what's your login?

[22:33] <PerlJam> FROGGS: you too?  (or email0

[22:33] <FROGGS> PerlJam: tleich

[22:33] <[Coke]> PerlJam: will at coleda dot com

[22:34] <PerlJam> invitations send

[22:34] <PerlJam> er, sent

[22:34] * jnthn re-read it a couple of times and is happy, unless anybody else finds anything :)

[22:34] <jnthn> PerlJam: thanks for reading :)

[22:35] *** kivutar joined
[22:35] <PerlJam> jnthn: thanks for the advent article! :-)

[22:35] <jnthn> It's scheduled.

[22:35] <jnthn> Not sure what timezone this thing runs in... 

[22:35] <jnthn> Oh, looks like UTC...

[22:37] *** stevan_ left
[22:38] <[Coke]> jnthn++ looks good!

[22:38] <[Coke]> well, and so does the article.

[22:39] <[Coke]> PerlJam++ #ivite

[22:39] <[Coke]> invite, even

[22:40] <PerlJam> [Coke]: btw, I saw a guy that kinda looked like you in a leather jacket at DFW yesterday.  He was turned away from me and was thinking, "that's Coke!", then he turned completely facing me and he wasn't you.  :)

[22:40] <PerlJam> and *I* was thinking ...

[22:42] <[Coke]> if I ever head to DFW, I'll let y'all know here first. :)

[22:43] <[Coke]> ~~

[22:47] <lue> jnthn++ don't see any problems.

[22:48] *** rurban2 left
[22:49] *** arcterus left
[22:51] *** arcterus joined
[22:53] <lue> Buf isn't supposed to be a class, is it?  http://perlcabal.org/syn/S32/Containers.html#Buf

[22:59] *** PacoAir left
[23:03] <jnthn> Buf's a role, in Rakudo and by spec

[23:03] <jnthn> at least, in S002 it is ;)

[23:04] <jnthn> So yeah, I'd say S32 has it wrong there.

[23:05] <jnthn> Buf.new([127], :size(16)) # should be Buf[int16]([127]) or so

[23:09] *** jlaire left
[23:10] <lue> jnthn: I'm fine with using Buf.meth as a way to say "things that do the Buf role.meth" though

[23:10] <jnthn> Well, and if you Buf.new it just puns, too 

[23:14] <TimToady> sigh, after complete reconf, my compile still blows up in m-BOOTSTRAP with: Heap corruption detected: pointer 0x2aaaac255650 to past fromspace

[23:15] <jnthn> TimToady: Then that probably is memory corruption, or some similar GC-related nasty (most probably a missing mark or wb somewhere)

[23:16] <jnthn> TimToady: Which is sigh indeed, especially for me given I'm probably the one who'll be finding it...

[23:17] <jnthn> ...and made more fun given it doesn't happen here where I've got debugging tools to investigate :/

[23:18] *** rindolf left
[23:21] *** jlaire joined
[23:21] <TimToady> lemme see if I can reproduce it on my home machine, which I could give you a login on

[23:26] *** stevan_ joined
[23:29] *** xinming left
[23:30] *** xinming joined
[23:30] <TimToady> 'course, if the GC characteristics depend on available memory, that machine has more, so might not fail

[23:31] <lue> Does the <:UniProp> syntax function like <rule> or <.rule> ? /me is guessing you'd have to do <.:UniProp> for non-capture

[23:32] <TimToady> : doesn't capture

[23:32] <TimToady> only initial alpha captures

[23:32] <TimToady> the whole point of the . form is to remove the alpha from the front :)

[23:32] <TimToady> other than that, they're both method calls

[23:33] <lue> So you'd have to do (<:Prop>) or $<rule>=<:Prop> then.

[23:33] <TimToady> (well, without . it will check for a lexically scoped method first, but it's still a call to a method)

[23:33] <TimToady> <rule=:Prop> is fine

[23:34] <lue> $<rule>= keeps me from having to remember how b in <a=b> gets interpreted :P

[23:34] <jnthn> TimToady: No, it's not that smart yet, partly to try and make these things reproducable in the early days...

[23:34] <TimToady> exactly as if the a= weren't there, it's recursive

[23:35] <TimToady> jnthn: well, will still take a while to get to that point

[23:35] *** stevan_ left
[23:35] <jnthn> TimToady: No hurry, I'm not doing too well at staying concious here :)

[23:35] *** stevan_ joined
[23:35] <TimToady> figgered you'd pass out first :)

[23:37] <TimToady> could be a bad patch of memory on my laptop, for all that

[23:37] <lue> TimToady: good to keep in mind. I'll get more comfortable with <a=b> the less I see it as a simple <subrule> caller I'm sure.

[23:37] *** Rotwang left
[23:38] <TimToady> it's a recursive prefix, like <!...> or <?...>

[23:38] <diakopter> "every other major dynamic language"

[23:38] <diakopter> you can remove "major" and "dynamic" there

[23:39] <TimToady> well, Swahili is a major language

[23:39] <jnthn> Not sure I'm feeling dynamic enough for such a major change :P

[23:40] <TimToady> but he's trying to name our major "competetors" without naming them :)

[23:40] <TimToady> *competitors even

[23:40] <FROGGS> TimToady: try to rebuild moar only with --optimize=1, and then just make m-install in nom

[23:41] <FROGGS> thas does it for me

[23:41] <jnthn> FROGGS: Oh, you can reproduce the bug too?

[23:41] <jnthn> FROGGS: And it's optimization level related?

[23:41] <FROGGS> jnthn: yes, that is the bug from sunday or so

[23:41] <diakopter> .. but major dynamic languages aren't Perl 6's competitors...

[23:42] <TimToady> they think they are ;)

[23:42] *** btyler left
[23:43] <TimToady> no soap, still crashes

[23:44] <FROGGS> :/

[23:44] <jnthn> FROGGS: Did you think a certain change was to blame, or it "just started happening?"

[23:45] <jnthn> Sorry if I'm forgetting stuff. Brain is still an exhausted mess from November's $dayjob excesses...

[23:45] <FROGGS> jnthn: I dunno which commit did it

[23:45] <jnthn> k

[23:46] <FROGGS> but my gut feeling tells me that this is the memory corruption that I have for days when I do -O3, just that it fails slightly different now

[23:46] *** arcterus left
[23:46] *** xenoterracide left
[23:47] <jnthn> FROGGS: But there was a point we didn't reliably have the issue?

[23:47] <FROGGS> the day before I "stashed" the stdhandles

[23:47] <FROGGS> (or the commit before)

[23:47] <lue> Hey, I wrote a very rough first draft of S15!  →  https://gist.github.com/lue/7761244

[23:48] *** woolfy joined
[23:49] * jnthn git --grep=std

[23:50] <lue> (gah, I forgot the pragmas!)

[23:51] <TimToady> kaboom, reproduce it

[23:51] <TimToady> *ced

[23:51] *** kivutar left
[23:52] <FROGGS> jnthn: this breaks it: 05eaefe8431547a1b7eabfed44b959c3051ba4d2

[23:52] <TimToady> jnthn: what do you want for an account name on my machine?

[23:53] * FROGGS .oO( beer? )

[23:53] <FROGGS> maybe rootbeer :o)

[23:54] <jnthn> TimToady: jnthn? :)

[23:54] <jnthn> rootbeer is funny though :P

[23:54] <TimToady> I don't know if it allows questions marks :P

[23:54] <lue> .oO(do usernames allow a ? at the end)

[23:54] <lue> Bah, TimToady!

[23:55] <jnthn> Uh...is it me or does MVM_file_get_stdstream do something terrible with an interior pointer...

[23:55] <jnthn> oh hell, yes.

[23:56] <jnthn> MVMOSHandleBody * const body  = &result->body;

[23:56] <jnthn> That gets a pointer into the middle of a GC-managed thing

[23:56] <TimToady> cool!

[23:56] <jnthn> body->u.handle->data = body;

[23:56] <jnthn> That stores it.

[23:56] <FROGGS> ha!

[23:56] <jnthn> And later on, when the object moves...guess what... :)

[23:56] <FROGGS> and I did not even wrote that bit! \o/

[23:56] <jnthn> So yeah, that's sure fire memory corruption...

[23:56] <FROGGS> jnthn**10

[23:57] <jnthn> Me either. Wish I'd caught it in an earlier read-through of the code though.

[23:57] <jnthn> I guess I assumed it was held at an extra LoI, a bit like SCRef does...

[23:58] <jnthn> Of course, then it'd not need the &

[23:58] <jnthn> It happens for both the TTY and named pipe case, it seems

[23:58] <jnthn> But I wonder if other IO related things do it also...

[23:58] * TimToady guesses jnthn++ won't be wantin' that account... :)

[23:59] *** zakharyas left
[23:59] <TimToady> but it's there already, so anytime you want a Linux account on a 6-core machine...

