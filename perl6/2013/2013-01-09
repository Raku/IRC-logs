[00:00] *** mtk joined
[00:00] *** bitonic left
[00:21] <dalek> rakudo-js: 59ce22b | (Paweł Murias)++ | / (4 files):

[00:21] <dalek> rakudo-js: pass test 24

[00:21] <dalek> rakudo-js: fix the way dependencies are deserialized, add missing file

[00:21] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/59ce22b9bd

[00:23] *** [particle] joined
[00:29] *** [particle]1 joined
[00:30] *** [particle] left
[00:31] *** jokar left
[00:39] *** skids joined
[00:39] *** xinming_ joined
[00:39] *** xinming left
[00:47] *** [particle] joined
[01:15] *** ilogger2 joined
[01:15] *** ChanServ sets mode: +v ilogger2

[01:18] *** [particle] joined
[01:25] <timotimo> has $.URL       = die "Every project needs an URL"; - oooh, that's a clever trick!

[01:44] *** wooden joined
[02:01] <doy> it's a pretty common idiom in moose at least

[02:02] <Juerd> s/an URL/a URL/ though

[02:29] *** MikeFair_ joined
[02:30] *** alc joined
[03:23] *** Khisanth joined
[03:50] <stevan_> Larry++ ( #647: TimToady on https://gist.github.com/2657075 )

[03:51] *** orafu joined
[04:20] *** dayangkun joined
[04:25] <sorear> TimToady++

[04:43] <TimToady> that's very funny, considering I do next to nothing with github except download other people's stuff...

[04:45] *** slayer101_ joined
[04:51] *** slayer101_ left
[05:11] <Util> perl6: my $x = 2; my $y = 5; ($x,$y) .= reverse; say "$x $y";

[05:11] <p6eval> rakudo ffde43: OUTPUT«5 2␤»

[05:11] <p6eval> ..niecza v24-16-g89e47b6: OUTPUT«Unhandled exception: Unable to resolve method reverse in type Parcel␤  at /tmp/y1sjzBERoA line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4219 (module-CORE @ 580) ␤  at /…

[05:21] *** sisar joined
[05:22] *** telex joined
[05:28] *** Chillance joined
[05:35] *** telex left
[05:37] *** telex joined
[05:42] *** tokuhiro_ joined
[05:45] *** kaleem joined
[05:59] *** Chillance left
[06:05] *** jokar joined
[06:11] *** dayangkun left
[06:23] *** dayangkun joined
[06:33] <moritz> colomon: <!before '='> (in the case of ^^ it doesn't matter if you use before or after, since it's zero-width)

[06:33] <moritz> though before is probably faster than after

[06:41] <diakopter> Juerd: some people pronounce URL like 'earl'

[06:48] *** raiph_ joined
[06:49] *** raiph_ left
[06:51] *** slayer101_ joined
[06:54] *** jokar left
[07:05] *** tokuhiro_ left
[07:15] *** slayer101_ left
[07:18] *** jokar joined
[07:22] *** slayer101_ joined
[07:22] *** dayangkun left
[07:37] *** SamuraiJack joined
[07:40] *** dayangkun joined
[07:54] *** FROGGS joined
[07:54] <moritz> TimToady: you pushed a lot of commits to STD

[07:54] <moritz> TimToady: and roast

[07:54] <moritz> erm, s/roast/specs/

[08:06] <FROGGS> moritz: where do you see that?

[08:06] *** brrt joined
[08:06] <FROGGS> I cant see commits to specs lately

[08:10] <moritz> FROGGS: well, not this year so far

[08:10] <moritz> but dalek and perl6-language announce them

[08:10] <FROGGS> ahh

[08:10] <FROGGS> thats why he is on that list you mean

[08:13] *** dayangkun left
[08:22] <moritz> correct

[08:26] *** dayangkun joined
[08:40] *** slayer101_ left
[08:49] *** slayer102_ joined
[08:50] *** sqirrel joined
[08:54] *** slayer102_ left
[08:54] *** slayer101_ joined
[08:59] *** MikeFair_ left
[09:01] *** slayer101_ left
[09:05] *** MikeFair joined
[09:34] *** marloshouse_ joined
[09:35] *** anuby_ joined
[09:37] *** sqirrel_ joined
[09:37] *** stevan__ joined
[09:38] *** MikeFair__ joined
[09:41] *** bitonic joined
[09:42] *** Psyche^ joined
[09:42] *** MikeFair left
[09:42] *** sqirrel left
[09:43] *** cognominal joined
[09:45] <jnthn> morning o/

[09:45] *** Psyche^ is now known as Patterner

[09:45] <brrt> hi jnthn

[09:47] <cognominal> hi everyone

[09:47] <FROGGS> morning pals

[09:48] *** dakkar joined
[09:48] <moritz> \o

[09:48] *** am0c joined
[09:48] <hoelzro> o/ moritz 

[09:51] *** Pleiades` joined
[09:51] <FROGGS> r: module File; class File { }; say GLOBALish::File::

[09:51] <p6eval> rakudo ffde43: OUTPUT«("File" => File).hash␤»

[09:52] <FROGGS> r: module File::Spec; class File::Spec { }; say GLOBALish::File::Spec::

[09:52] <p6eval> rakudo ffde43: OUTPUT«().hash␤»

[09:52] <FROGGS> why are multipart names being treated differently?

[09:52] * moritz doesn't see why GLOBALish::File:: should contain an entry for 'File'

[09:53] <moritz> oh, because it's inside module File

[09:53] <FROGGS> right

[09:53] <FROGGS> so in the first case I get a File::File class

[09:53] <moritz> r: module File::Spec; class File::Spec { }; say GLOBALish::File::

[09:53] <p6eval> rakudo ffde43: OUTPUT«("Spec" => File::Spec).hash␤»

[09:53] <FROGGS> in the second one I would expect to get a File::Spec::File::Spec class

[09:54] *** SmokeMachine joined
[09:54] <FROGGS> since the whole file is within the File::Spec namespace

[09:54] <FROGGS> and other (class) definitions should be under that one

[09:54] <FROGGS> maybe the spec tells something else, dunno

[09:55] <FROGGS> but IMO this leads to bad code

[09:55] <moritz> FROGGS: it sounds like rakudo is buggy, but nested namespaces are *so* tricky to get right that I don't dare to pass judgement

[09:56] <jnthn> It's also probably the way it is to make some other thing work. :/

[09:58] <FROGGS> I just recognized it because I made a small module that dumps the namespace by a given file

[10:00] *** dayangkun left
[10:04] *** anuby_ left
[10:04] <moritz> whenever one changes a small detail of how nested namespaces are handled, the whole house of cards comes tumbling down

[10:09] <FROGGS> thats where you run the spectests and module tests...

[10:15] *** bapa joined
[10:26] *** cognominal left
[10:37] <dalek> nqp-jvm-prep: 9907c12 | jnthn++ | docs/ROADMAP:

[10:37] <dalek> nqp-jvm-prep: Remove completed items.

[10:37] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/9907c12fcd

[10:37] <dalek> nqp-jvm-prep: 5101317 | jnthn++ | docs/ROADMAP:

[10:37] <dalek> nqp-jvm-prep: Flesh out ROADMAP a bit more.

[10:37] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/5101317ff3

[10:39] *** sqirrel_ left
[10:41] <FROGGS> oh I really like the way slurp works

[10:47] <dalek> nqp-jvm-prep: 4e9bd18 | jnthn++ | t/qast_6model.t:

[10:47] <dalek> nqp-jvm-prep: Test for istrue/isfalse/setboolspec.

[10:47] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/4e9bd18eec

[10:47] <dalek> nqp-jvm-prep: 831921c | jnthn++ | / (3 files):

[10:47] <dalek> nqp-jvm-prep: Implement setboolspec.

[10:47] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/831921cf80

[11:01] *** brrt left
[11:10] *** not_gerd joined
[11:10] <not_gerd> hello, #perl6

[11:11] <GlitchMr> Hello

[11:11] <not_gerd> jnthn: bitrot/bug in Grammar::Tracer|Debugger - see https://gist.github.com/4492329

[11:12] <jnthn> Hmm

[11:12] <jnthn> Oddness

[11:13] <jnthn> Will investigate, thanks.

[11:16] <not_gerd> jnthn: You're welcome. I'll try to come up with a golfed grammar, but probably not until the evening

[11:22] *** bruges joined
[11:55] *** colomon joined
[11:59] <dalek> nqp-jvm-prep: 7171d73 | jnthn++ | src/org/perl6/nqp/ (6 files):

[11:59] <dalek> nqp-jvm-prep: Stub in VMIter, BOOTIter and HLL config for iters.

[11:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/7171d73396

[11:59] <dalek> nqp-jvm-prep: 46a2961 | jnthn++ | t/qast_aggregate.t:

[11:59] <dalek> nqp-jvm-prep: Tests for array/hash iter using nqp:: ops.

[11:59] <dalek> nqp-jvm-prep: 

[11:59] <dalek> nqp-jvm-prep: The approach taken means that we'll easily mimic the way array iters

[11:59] <dalek> nqp-jvm-prep: work today, but hashes are a bit different. Rather than the VM having

[11:59] <dalek> nqp-jvm-prep: a type with .key and .value methods, we just provide enough for NQP to

[11:59] <dalek> nqp-jvm-prep: implement that itself; only the NQP MOP will need tweaks that way.

[11:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/46a29610b4

[11:59] <dalek> nqp-jvm-prep: f3d5247 | jnthn++ | / (5 files):

[11:59] <dalek> nqp-jvm-prep: Get new iteration tests passing.

[11:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/f3d5247187

[12:06] <nwc10> at this rate there won't be any low hanging fruit left for anyone else :-)

[12:07] <jnthn> nwc10: Oh, I'm being careful not to do the stuff in LHF.md :)

[12:08] <nwc10> is the current aim to get to the point where this project can take (simple) trees from NQP-on-Parrot, and compile them to JVM bytecode?

[12:08] <nwc10> ie "hello world" and similar things

[12:12] <jnthn> Not really. The current focus is to get good coverage of compiling QAST trees and providing the nqp:: op set. 

[12:12] <jnthn> If I cared for having a shiny demo I could already probably find some way to get simplified NQP trees and pass them along to this.

[12:14] <not_gerd> is lexotic gather/take supposed to work in Rakudo?

[12:14] <jnthn> The first interesting NQP thing to compile will be https://github.com/perl6/nqp/tree/master/src/how

[12:15] <jnthn> not_gerd: I think it's probably just dynamic at the moment.

[12:15] <jnthn> Er, is it meant to be lexotic...

[12:15] <jnthn> ah, yes, it is

[12:16] <jnthn> Hm, and gather can be too

[12:16] <jnthn> Innerestin'

[12:16] <jnthn> Anyway, no, NYI.

[12:17] <timotimo> what exactly does lexotic gather/take mean?

[12:17] <not_gerd> jnthn: the rationale is so library code doesn't eat your take

[12:17] <jnthn> not_gerd: Yeah

[12:17] <jnthn> It's a good idea.

[12:17] *** alc left
[12:17] <not_gerd> timotimo: any take that can be lexically matched with a gather does so

[12:17] <jnthn> timotimo: S04 explains it pretty well under the "The C<gather> statement prefix" section

[12:18] <not_gerd> timotimo: my use case: Grammar.parse together with take in action methods

[12:18] <not_gerd> sadly, &parse eats some (but not all) of my takes :(

[12:21] <timotimo> thank you, i'll read that

[12:24] <timotimo> oh, that's curious

[12:24] <timotimo> so in gather { take "1"; my-sub(); } if my-sub has a take in it, it won't reach that gather?

[12:26] <jnthn> That's my reading of it too

[12:26] <jnthn> Unless my-sub is lexically inside the gather also, of course

[12:26] *** brrt joined
[12:27] <timotimo> i'll have to do some extra thinking to convince me that this is a good thing

[12:28] *** sftp joined
[12:37] *** bitonic left
[12:37] *** bitonic joined
[12:39] <not_gerd> bye, #perl6

[12:39] *** not_gerd left
[12:40] *** MayDaniel joined
[12:42] *** brrt left
[12:45] *** bitonic left
[13:26] *** SamuraiJack left
[13:41] *** cognominal joined
[13:59] *** kaleem left
[14:00] *** kaleem joined
[14:11] *** wk joined
[14:12] *** wk is now known as Guest61915

[14:16] <[Coke]> (that github list of biggest users starts with "most followed users", which is why it's skewed to include timtoady but not, e.g. jnthn)

[14:17] <moritz> well, anybody following jnthn++ wouldn't see much else in his feed :-)

[14:17] *** bitonic joined
[14:17] <jnthn> :P

[14:17] *** bluescreen10 joined
[14:17] *** dayangkun joined
[14:18] * jnthn tries to get QAST::Op :op('for') working

[14:21] *** hash_table joined
[14:23] *** spanner joined
[14:27] *** PacoAir joined
[14:31] *** SunilJoshi joined
[14:31] <[Coke]> moritz:  you've got commits on roast as both moritz & "Moritz Lenz"

[14:31] *** skids joined
[14:35] *** kaare_ joined
[14:37] <arnsholt> Probably not much to do about that

[14:37] <arnsholt> Fixing it would involve a massive rebase, and that's just mean with as public a history as roast

[14:42] <[Coke]> I think adding an email addy to your primary account might do it.

[14:42] <[Coke]> (for the web side, anyway)

[14:44] <FROGGS> I had the same thing... I had two different ssh-keys, one was connected to an already deleted useraccount

[14:44] <FROGGS> the github stuff fixed this for my

[14:44] <FROGGS> me

[14:44] *** sivoais joined
[14:46] *** stopbit joined
[14:46] *** hash_table left
[14:47] *** hash_table joined
[14:49] *** spanner left
[14:51] *** spanner joined
[15:01] *** kaleem left
[15:05] <dalek> nqp-jvm-prep: f2388e1 | jnthn++ | / (2 files):

[15:05] <dalek> nqp-jvm-prep: Correct an nqp:: op name.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/f2388e1c74

[15:05] <dalek> nqp-jvm-prep: a25dd96 | jnthn++ | src/org/perl6/nqp/runtime/ (4 files):

[15:05] <dalek> nqp-jvm-prep: Stub in some control exceptions.

[15:05] <dalek> nqp-jvm-prep: 

[15:05] <dalek> nqp-jvm-prep: We'll just use the JVM exceptions for these at the moment.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a25dd96f52

[15:05] <dalek> nqp-jvm-prep: 6fe3127 | jnthn++ | lib/JAST/Nodes.nqp:

[15:05] <dalek> nqp-jvm-prep: Fix JAST dump thinko.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/6fe3127020

[15:05] <dalek> nqp-jvm-prep: e2660ff | jnthn++ | t/qast_core.t:

[15:05] <dalek> nqp-jvm-prep: Add a test for QAST::Op 'for'.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e2660ff4e0

[15:05] <dalek> nqp-jvm-prep: a0466dd | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[15:05] <dalek> nqp-jvm-prep: Auto-boxing in return_o.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a0466dd763

[15:05] <dalek> nqp-jvm-prep: 1d1c9fd | jnthn++ | lib/QAST/JASTCompiler.nqp:

[15:05] <dalek> nqp-jvm-prep: Implement QAST::Op 'for'. Passes initial test.

[15:05] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1d1c9fd95b

[15:06] <nwc10> jnthn++

[15:06] *** wtw joined
[15:12] *** wtw left
[15:21] <timotimo> just for the record, S04 is a bit out of date, at least the section on gather/take. there's a "my |$c :=" and there's talk of Seq() objects.

[15:21] <timotimo> i don't dare edit the specs, though :P

[15:22] <jnthn> forgiveness > permission ;)

[15:23] <timotimo> oh well. maybe i'll do it once i'm on an actual internet connection again, rather than my phone :P

[15:24] *** SunilJoshi left
[15:24] *** SunilJoshi1 joined
[15:26] *** MikeFair__ left
[15:27] *** cedrvint joined
[15:27] <cedrvint> hello #perl6

[15:27] <cedrvint> std: my $foo; my $bar; my $x =  try { given $foo { when 1 {2} when 3 {4} } } + $bar

[15:27] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/CiYlH4ZAng line 1:␤------> [32m; my $x =  try { given $foo { when 1 {2}[33m⏏[31m when 3 {4} } } + $bar[0m␤    expecting horizontal whitespace␤Parse failed␤…

[15:28] <FROGGS> std: my $foo; my $bar; my $x =  try { given $foo { when 1 {2}; when 3 {4} } } + $bar

[15:28] <p6eval> std a8bc48f: OUTPUT«ok 00:00 45m␤»

[15:28] <dalek> specs: a0f87cf | (Cédric VINCENT)++ | S04-control.pod:

[15:28] <dalek> specs: Fix two terms in a row

[15:28] <dalek> specs: review: https://github.com/perl6/specs/commit/a0f87cf9f8

[15:28] <cedrvint> fixed :D

[15:29] *** PacoAir left
[15:30] <FROGGS> good catch

[15:36] *** SunilJoshi1 left
[15:37] <moritz> cedrvint++

[15:39] *** fgomez joined
[15:39] *** SunilJoshi joined
[15:39] <dalek> nqp-jvm-prep: 341d7ac | jnthn++ | t/qast_conditional.t:

[15:39] <dalek> nqp-jvm-prep: Tests for if with num, str and object.

[15:39] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/341d7ac9c2

[15:39] <dalek> nqp-jvm-prep: 4503610 | jnthn++ | / (2 files):

[15:39] <dalek> nqp-jvm-prep: Implement if/unless with str or obj condition.

[15:39] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/4503610644

[15:39] <dalek> nqp-jvm-prep: bbef46a | jnthn++ | lib/QAST/JASTCompiler.nqp:

[15:39] <dalek> nqp-jvm-prep: Factor out boolify code; will need it for loops.

[15:39] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/bbef46a3c6

[15:41] *** kivutar joined
[15:45] *** kaleem joined
[16:00] *** fgomez left
[16:01] * tadzik can has a whiteboard

[16:01] <tadzik> it's like a read-write wall. How could I have lived without this

[16:01] <timotimo> it's not only read-write, you can also attach things using magnets!

[16:02] <tadzik> magnets themselves are cool

[16:02] <timotimo> indeed they are

[16:02] <tadzik> I drew a calendar on mine, and how do I mark current day? Magnets!

[16:02] <timotimo> a full year calendar?

[16:03] <tadzik> yeah. Took me about 2 hors

[16:03] <tadzik> no, it's just one month :P

[16:03] <timotimo> http://t.h8.lv/magnets.mp4 :D

[16:05] <tadzik> :)

[16:06] <timotimo> is that the slow motion one or the one with sound?

[16:07] <tadzik> slowmo I guess

[16:07] *** FROGGS left
[16:07] <timotimo> ah. the sound in that video is quite nice i find, hold on, maybe i can find it.

[16:07] <tadzik> if it's with sound, then Korpiklaani is louder anyway :P

[16:08] <timotimo> http://t.h8.lv/VID_20121208_141224.mp4 - this is the one where it goes FLOP-KLOP

[16:09] *** thou joined
[16:09] <tadzik> hehe, nice

[16:09] *** FROGGS joined
[16:15] *** FROGGS left
[16:15] *** obra joined
[16:19] *** kaleem left
[16:24] *** FROGGS joined
[16:24] *** Chillance joined
[16:25] *** sqirrel joined
[16:27] *** cognominal left
[16:32] *** SunilJoshi left
[16:33] *** thou left
[16:35] *** MayDaniel left
[16:35] *** MayDaniel joined
[16:35] *** werwerwer joined
[16:38] *** FROGGS[mobile] joined
[16:38] *** FROGGS left
[16:44] *** jokar left
[16:48] *** skids left
[16:59] *** am0c left
[17:00] *** fgomez joined
[17:06] <masak> evenin', #perl6

[17:09] *** SamuraiJack joined
[17:10] <tadzik> masak! \o/

[17:11] <timotimo> masak: i'm considering looking at your druid again and try to make it run on current rakudo again. any objections? :)

[17:12] <masak> timotimo: no objections. I'm intrigued by this notion. I'm sorry I haven't been reviewing your work on this so far.

[17:15] <timotimo> oh, i'm probably going to throw away the work i've done so far, at least partially

[17:15] <timotimo> and resume work using your other update-branch (just 2 years old instead of 4!)

[17:16] <jnthn> Pro Tip: when compiling a loop, be sure that you actually compile the loop body, not the loop condition twice...

[17:17] <masak> timotimo: ;)

[17:17] <masak> timotimo: I seem to recall I got it working completely at the time.

[17:18] <timotimo> and then you decided not to merge it into master? ;)

[17:18] <timotimo> because i totally didn't see that branch until i've been hacking away at the code for at least two hours :D

[17:19] <timotimo> (well, mostly scratching my head, almost no real hacking)

[17:20] *** ismail_ joined
[17:23] * jnthn pokes dalek

[17:23] <masak> timotimo: though it feels very distant now, there was a long time even after Rakudo's ng branch merged into master, when I was still using the generation prior to that (alpha).

[17:23] <timotimo> oh, that's interesting. what was the big change from alpha to ng?

[17:25] <masak> the way I remember it, alpha contained features and ng contained pain.

[17:25] <masak> (then things improved, but in a rather asymptotic way.)

[17:25] <jnthn> Well, the big change was that alpha's grammar and parse engine were pre-STD

[17:25] <tadzik> (ng contained works, nom contained fast)

[17:25] <timotimo> and then ng was thrown over board and nop was born, right?

[17:26] <jnthn> It didn't use proto regexes and there OPP and recdescent stuff were separated out.

[17:26] <tadzik> OPP?

[17:26] <jnthn> Operator Precedence Parser

[17:27] <jnthn> Also a bunch of other bits were re-done righter; it got rid of a whole class of NPMCA issues, for example.

[17:27] <diakopter> neat http://blogs.msdn.com/b/zainnab/archive/2013/01/07/esoteric-programming-languages.aspx

[17:27] <masak> I'm not an opponent of progress, in any way. the ng->nom transition was overall very smooth, if a bit drawn out.

[17:29] <masak> diakopter: I hadn't heard about Velato and DNA# before. :)

[17:29] <diakopter> on that wiki there are hundreds of other languages

[17:30] <diakopter> .. including Perl?

[17:30] <diakopter> 763

[17:30] <dalek> nqp-jvm-prep: b23365f | jnthn++ | t/qast_core.t:

[17:30] <dalek> nqp-jvm-prep: Test for while.

[17:30] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b23365f4ed

[17:30] <dalek> nqp-jvm-prep: cd93d5b | jnthn++ | lib/QAST/JASTCompiler.nqp:

[17:30] <dalek> nqp-jvm-prep: Compile various QAST::Op loops.

[17:30] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/cd93d5b246

[17:31] *** kivutar left
[17:31] <jnthn> .oO( only jnthn would implement meta-programming before while loops... )

[17:31] <diakopter> heh, Parrot's on the joke language list

[17:32] <dalek> nqp-jvm-prep: 73ae977 | jnthn++ | t/qast_core.t:

[17:32] <dalek> nqp-jvm-prep: Also test repeat_until.

[17:32] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/73ae977b9b

[17:32] * timotimo idly wonders by how much the test suite for Sum would be sped up if one would throw lots of type definitions all over the place, maybe even native types

[17:32] <dalek> nqp-jvm-prep: b533790 | jnthn++ | docs/ROADMAP:

[17:33] <dalek> nqp-jvm-prep: Remove some completed items.

[17:33] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b533790416

[17:33] <timotimo> ISTR that native type containers are currently broken in rakudo? or is that only for "has"?

[17:33] <timotimo> r: my int $foo = 10; $foo += 100; say $foo;

[17:33] <p6eval> rakudo ffde43: OUTPUT«Cannot assign to a non-container␤  in block  at src/gen/CORE.setting:12569␤  in block  at /tmp/xOh3mfGuHK:1␤␤»

[17:33] <masak> diakopter: that's wrong. Parrot isn't a language. oh, *that* Parrot language. :)

[17:34] <jnthn> timotimo: They aren't very robust yet, but they're usable with care.

[17:36] *** wtw joined
[17:40] <tadzik> 1830 +dalek | nqp-jvm-prep: Test for a while.

[17:42] *** ismail_ left
[17:42] *** thou joined
[17:46] *** fgomez left
[17:49] *** sisar left
[18:01] <timotimo> jnthn: and of course there's no documentation on how exactly they can be carefully handled? ;)

[18:01] *** cognominal joined
[18:03] *** dakkar left
[18:04] <timotimo> r: my int $foo; $foo = 10; $foo = $foo + 1;

[18:04] <p6eval> rakudo ffde43:  ( no output )

[18:04] <jnthn> timotimo: Not really, but in short, anything that would rely on "is rw" to be implemented won't work out.

[18:04] <timotimo> so, there's a problem with +=, but = itself works no-problemo

[18:04] <timotimo> ah, that's quite a simple statement

[18:05] <jnthn> op= and ++/-- being the immediate ones

[18:05] <jnthn> There's some other issues here and there.

[18:05] <jnthn> But the rw one is what is mostly run into

[18:08] *** FROGGS[mobile] left
[18:08] *** PacoAir joined
[18:09] <jnthn> store &

[18:09] *** FROGGS joined
[18:11] *** Guest61915 left
[18:14] *** zby_home joined
[18:16] *** skids joined
[18:21] *** sqirrel left
[18:30] *** cognominal left
[18:31] *** PacoAir left
[18:32] *** PacoAir joined
[18:32] *** thou left
[18:35] *** cognominal joined
[18:41] *** SamuraiJack left
[18:43] *** orafu left
[18:44] *** orafu joined
[18:50] *** lichtkind joined
[18:54] *** cognominal left
[18:56] *** hash_table left
[19:06] *** hash_table joined
[19:07] <TimToady> for the record, Perl 6 grammar is not derived from the literature on "scannerless", it just falls out of the rest of the design as a requirement, so that's how we designed it; ergo it was independent invention

[19:08] <TimToady> that being said, "scannerless" is not how I think of it, in any case

[19:08] <TimToady> it's more like "autoscanning", in that it writes scanners for you automatically

[19:09] <masak> right.

[19:09] <TimToady> you can't do LTM if it were really "scannerless" because "token" would have no meaning

[19:10] * masak .oO( what is the sound of zero scanners lexing? )

[19:10] <jnthn> dinner &

[19:11] <TimToady> and you can tell how far back I am in backlogging since this was brought up at the end of November :)

[19:12] <arnsholt> Heh. So you'll be done backlogging in a week or so? =)

[19:12] <TimToady> I give the reboot several weeks :)

[19:12] <timotimo> arnsholt: shh, all of those lines you're writing right now are just adding to his backlog!

[19:12] <masak> TimToady: if you amass some speed as you approach us, you might ram straight through the now barrier and end up futurelogging! :P

[19:12] <TimToady> esp since I just came down with a cold

[19:13] <TimToady> masak: there's always hope

[19:13] * masak .oO( the best way to invent the future is to ram the present )

[19:16] <TimToady> In general, if the question is "Did literature X influence the design of Perl?", the answer is nearly always "Not directly, if at all."  The literature almost never has exactly what I want, so I don't usually bother reading it myself.  :-)

[19:17] <TimToady> This approach to design has its obvious plusses and minuses...

[19:22] <TimToady> "No clue about whether this is patentable" is both a plus and a minus in its own right

[19:22] *** cognominal joined
[19:24] <diakopter> Hm, I don't recall the topic

[19:25] <masak> I think we are talking about scannerless parsers.

[19:25] <TimToady> 18 minutes ago

[19:26] <diakopter> I mean from Nov

[19:27] <skids> Scannerless parsers are great.  All that printing out the code just to OCR it was a lot of work.

[19:27] <masak> I think we were talking about scannerless parsers then too :P

[19:28] <cognominal> An ubuntu phone… Someday, we will program our phone using Perl 6.  http://arstechnica.com/gadgets/2013/01/in-which-ars-is-allowed-to-see-but-not-touch-an-ubuntu-phone/

[19:28] <cognominal> skids++ # :)

[19:28] <masak> diakopter: if only there were some way to go back in time and find out what we were talking about in November.

[19:28] <TimToady> http://irclog.perlgeek.de/perl6/2012-11-30#i_6200746

[19:28] * jnthn back

[19:28] <nwc10> yay!

[19:29] <nwc10> however, I doubt that your return will immediately be followed by dalek announcing freshly pushed commits

[19:29] *** wk joined
[19:30] *** wk is now known as Guest99405

[19:30] <TimToady> jnthn didn't return, he merely invoked a continuation...

[19:30] <nwc10> if we invoke the same continuation a second time, in a new thread, will he become twice as productive?

[19:31] <skids> That would result in contention issues.  For beer.

[19:31] <doy> or if not contention, then memory corruption (also from beer)

[19:33] *** PacoAir left
[19:33] <TimToady> he's barley productive as it is

[19:34] * masak .oO( the glass is a half-full continuation )

[19:34] <skids> wheyt I'm not ready for puns that make me grain.

[19:34] *** PacoAir joined
[19:34] *** PacoAir_ joined
[19:35] <TimToady> well, then, hop to it!

[19:38] *** PacoAir left
[19:38] *** PacoAir_ is now known as PacoAir

[19:40] <jnthn> :P

[19:40] <[Coke]> jnthn: at yeast give them a chance. They're trying.

[19:41] <jnthn> It's OK, I'm not bitter.

[19:41] <jnthn> It doesn't ale me.

[19:41] <[Coke]> I always though you were stouthearted.

[19:42] <jnthn> Need to be if you're the JVM porter...

[19:43] <skids> That could malt even the most stout of hearts.

[19:45] <masak> I find this discussion high in calories but low in fiber.

[19:45] <jnthn> I'm sure it won't make you go...

[19:57] *** stevan__ left
[19:59] *** bro_grammer joined
[20:02] *** hash_table left
[20:03] *** fgomez joined
[20:11] <moritz> Compiling lib/LWP/Simple.pm

[20:11] <moritz> ===SORRY!===

[20:11] <moritz> When pre-compiling a module, its dependencies must be pre-compiled first.

[20:11] <moritz> NOT AGAIN

[20:13] <moritz> Please pre-compile /nocrypt-home/moritz/source/rakudo/install/lib/parrot/4.11.0-devel/languages/perl6/site/lib/MIME/Base64.pm6

[20:13] <moritz> installed with panda 

[20:14] <masak> :/

[20:14] <moritz> there's a .pir file, but it's one second older than the .pm file

[20:15] <tadzik> stupid panda

[20:15] <tadzik> it should know better

[20:18] <FROGGS> if it can print this message, why doesnt it recompile?

[20:19] <jnthn> phenny: tell not_gerd Grammar::Tracer issue fixed, and also added a test. Still gotta look at the Grammar::Debugger issue.

[20:19] <phenny> jnthn: I'll pass that on when not_gerd is around.

[20:20] <jnthn> tadzik: Is it harder than "install the .pm6, then the .pir", ooc?

[20:20] *** FROGGS left
[20:20] <tadzik> jnthn: I'm about to make it install .pirs first, then the rest of the stuff

[20:20] <jnthn> tadzik: The .pir needs to be newer

[20:20] <tadzik> oh

[20:20] <tadzik> the other way around then :P

[20:21] * moritz had already made it that way, once or twice :-)

[20:22] <tadzik> (:

[20:22] <tadzik> moritz, y u no submit patches :P

[20:22] <tadzik> moritz: any idea for a sensemaking test?

[20:23] <tadzik> we can't really depend on the order of files in the filesystem in any way

[20:23] <tadzik> oh, I know

[20:23] <tadzik> (I know, I know, oh-oh-oh!)

[20:25] *** SmokeMachine left
[20:29] <dalek> panda: dc81db8 | tadzik++ | / (2 files):

[20:29] <dalek> panda: Ensure that .pirs get installed last

[20:29] <dalek> panda: review: https://github.com/tadzik/panda/commit/dc81db8e46

[20:29] <tadzik> moritz: that should help

[20:30] <moritz> tadzik: thanks

[20:31] <tadzik> moritz++ # bugfinding

[20:33] <masak> tadzik++ # bugfixing

[20:37] *** fgomez left
[20:37] *** fgomez joined
[20:41] *** bro_grammer left
[20:48] <dalek> rakudo/nom: d2d2c85 | moritz++ | src/core/IO/Socket.pm:

[20:48] <dalek> rakudo/nom: RT #116288: $socket.read($bytes) now retruns $bytes btyes, if available

[20:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2d2c85079

[20:49] <tadzik> aww yiss

[20:51] <moritz> (I tried to build LWP::Simple to test that patch; that's where I found the panda bug :-)

[20:51] <sorear>    mangled before we migrated to a Unicode-capable DB.

[20:51] * jnthn is trying to fix the Grammar::Debugger bug

[20:51] <sorear> echan

[20:52] *** fgomez left
[20:54] <moritz> jnthn: use the debugger :-)

[20:54] <jnthn> :P

[21:00] *** cognominal left
[21:01] *** nyuszika7h joined
[21:04] *** Chillance left
[21:05] <jnthn> hmm, why on earth does changing nqp and make install'ing it give me a busted nqp afterwards...

[21:06] <jnthn> hm, going to the commit before my patch does so too...wtf

[21:06] *** fgomez joined
[21:09] *** cognominal joined
[21:10] <moritz> LWP::Simple is now down to two failing test files

[21:10] <moritz> sleep&

[21:10] <jnthn> moritz++

[21:12] *** fgomez left
[21:16] <jnthn> Oh...blech.

[21:17] <jnthn> Looks like it was just some zombie nqp instance meaning that copying a new nqp.exe in place fails

[21:17] <diakopter> ?

[21:17] <jnthn> ...silently. :/

[21:18] <diakopter> add a pskill call to the windows stuff?

[21:19] *** bbkr joined
[21:19] <diakopter> pslist to get the process ids?

[21:20] <bbkr> moritz++ # socket fix \o/

[21:20] <diakopter> (obviously runs only if sysinternals tools are on the path)

[21:22] <jnthn> diakopter: Probably is better if it fails to copy, but I don't wanna shave that yak right now...

[21:26] *** zby_home left
[21:36] <dalek> nqp: 6ca59c6 | jnthn++ | src/QAST/Operations.nqp:

[21:36] <dalek> nqp: Add nqp::attrinited.

[21:36] <dalek> nqp: 

[21:36] <dalek> nqp: Originally in Perl 6 ops, but is a general 6model thing.

[21:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ca59c6459

[21:36] <dalek> nqp: 8fc8891 | jnthn++ | src/stage0/ (9 files):

[21:36] <dalek> nqp: Update bootstrap to get nqp::attrinited.

[21:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8fc88919ed

[21:36] <dalek> nqp: da0668d | jnthn++ | src/QAST/Operations.nqp:

[21:36] <dalek> nqp: Fix a couple of op sigs.

[21:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/da0668d652

[21:36] <dalek> nqp: 0b83296 | jnthn++ | src/core/NQPMu.pm:

[21:36] <dalek> nqp: Extend NQP BUILDPLAN to handle build closure case.

[21:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0b83296a2e

[21:37] *** Janemba joined
[21:37] *** Janemba is now known as amkrankruleuen

[21:37] *** amkrankruleuen left
[21:37] *** amkrankruleuen joined
[21:38] <timotimo> what's the name for the inner things in "Array.new($(1, 10), $(2, 20))"? they were called Seq once. do i call them 'items' now?

[21:40] <tadzik> looks like a list in item context to me

[21:40] <tadzik> r: $(2, 20).WHAT.say

[21:40] <p6eval> rakudo d2d2c8: OUTPUT«Parcel()␤»

[21:41] <timotimo> i'm correcting the text on gather-take in S04 to replace a few things

[21:41] <tadzik> r: Array.new($(1, 10), $(2, 20)).perl.say; Array.new([1, 10].item, [2, 20].item).perl.say

[21:41] <p6eval> rakudo d2d2c8: OUTPUT«Array.new($(1, 10), $(2, 20))␤Array.new([1, 10], [2, 20])␤»

[21:41] <timotimo> such as my ($y) := take $_, $_ * 10; - i turned that into my $y := (take $_, $_ * 10).item;

[21:41] <tadzik> p6eval: pffft!

[21:43] <timotimo>     # @y contains 2 Seqs: Seq(1,10),Seq(2,20) sliced by binding to positional $y

[21:43] <timotimo> this "sliced by binding to positional $y" would have been the part where $y was written as ($y) instead of just $y, yes?

[21:44] <timotimo> at first attempt i tried writing my $y := \(take $_, $_ * 10); but that gave me a list of two captures that .perl'd into something rather big, so i thought that's not the right way to do it

[21:45] <timotimo> oh, i should have written my ($y) := \(take $_, $_ * 10); that comes closest to the original

[21:47] <timotimo>         my ($y) := \(take $_, $_ * 10);  # binding forces item context

[21:47] <timotimo> is this a correct comment now?

[21:47] <jnthn> think so

[21:48] <timotimo> i consider this at least not completely wrong as well:     # @y contains 2 Parcels: $(1,10),$(2,20) sliced by binding to positional $y

[21:50] <flussence> well... I tried golfing down this Bailador precompilation bug by removing unrelated bits of source and the bug stopped happening. I don't know where to look now, I give up.

[21:51] *** japhb_ joined
[21:51] <flussence> can I just have a way to turn precomp off entirely? That would've saved me months of frustration.

[21:52] <jnthn> Well, just don't ever install .pir files

[21:52] <japhb_> jnthn++ # Using the JVM porting work to fix places where ops and other abstractions where at the wrong level, so the next porter can retain more sanity

[21:52] <flussence> okay, so that's panda out the window...

[21:53] <jnthn> flussence: Yeah, but maybe panda can be configured in such a way

[21:53] <jnthn> flussence: I mean, it'd need patching panda, but it may be doable.

[21:53] <timotimo> panda already looks for a BUILD.pm, doesn't it?

[21:53] <diakopter> japhb_++

[21:53] <timotimo> maybe you can use that to configure

[21:54] <tadzik> I can hack up '--noprecomp' or something

[21:55] <dalek> rakudo/nom: 57989bc | jnthn++ | tools/build/NQP_REVISION:

[21:55] <dalek> rakudo/nom: Bump NQP_REVISION.

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/57989bcc4c

[21:55] <dalek> rakudo/nom: b36616b | jnthn++ | src/Perl6/Ops.pm:

[21:55] <dalek> rakudo/nom: Remove some ops that are now core ones.

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b36616b4fb

[21:55] <dalek> rakudo/nom: af76e6d | jnthn++ | src/ (2 files):

[21:55] <dalek> rakudo/nom: Some BUILDPLAN handling updates.

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af76e6d66d

[21:56] <timotimo> what's this about .get vs .getarg being used on the iterator returned by gather? doesn't seem like something i can manually do, is it something perl6 does for me depending on what context i iterate over the resulting list in?

[21:58] *** fgomez joined
[22:00] <dalek> specs: ba2d03a | (Timo Paulssen)++ | S04-control.pod:

[22:00] <dalek> specs: drafted some fixes for gather/take bitrot.

[22:00] <dalek> specs: review: https://github.com/perl6/specs/commit/ba2d03af90

[22:00] <timotimo> would appreciate a quick review. should i put tests for this exact code into integration/ or something?

[22:01] <jnthn> Probalby into S04 somewhere

[22:02] *** fridim_ joined
[22:02] <timotimo> i will do that then. with a notice to "fix S04-control.pod, too if those tests break" or something.

[22:04] *** MayDaniel left
[22:12] *** skids left
[22:13] *** thou joined
[22:15] <timotimo> one little mistake, but other than that the code seems to work.

[22:16] <dalek> roast: 948ffc3 | (Timo Paulssen)++ | S04-statements/gather.t:

[22:16] <dalek> roast: tests for S04-control.pod (gather/take)

[22:16] <dalek> roast: review: https://github.com/perl6/roast/commit/948ffc377d

[22:16] <dalek> specs: 96c45e7 | (Timo Paulssen)++ | S04-control.pod:

[22:16] <dalek> specs: fix a typo: Lol -> LoL.

[22:16] <dalek> specs: review: https://github.com/perl6/specs/commit/96c45e7c78

[22:23] *** kaare_ left
[22:24] *** fridim_ left
[22:29] <timotimo> masak: the biggest problems i had was with your test case generating stuff

[22:29] <masak> oh, I can imagine that!

[22:30] <masak> one of those "you think it's cute today" kind of ideas...

[22:30] <timotimo> ;)

[22:30] <timotimo> well, the big problem is bringing the names into the test library

[22:30] <timotimo> it tries to call functions &before and &after or something and all the names of the subs

[22:31] <timotimo> but i had problems getting to that, because how does it know where to look? how does the Ix get the foo.t when it says use Test::Ix in foo.t?

[22:31] <timotimo> in that situation i don't think there's something like OUTER:: or CALLER::

[22:31] <masak> I have no memory of how I implemented that.

[22:32] <masak> quite possibly it relied on some part of Rakudo that was broken but is now fixed.

[22:32] <masak> good ♞, #perl6

[22:32] <timotimo> good ℕight, masak 

[22:35] *** bluescreen10 left
[22:37] *** thou left
[22:42] *** bluescreen10 joined
[22:44] <dalek> rakudo/nom: b22982b | jnthn++ | src/ (3 files):

[22:44] <dalek> rakudo/nom: Fix $obj.Some::Role::meth(...).

[22:44] <dalek> rakudo/nom: 

[22:44] <dalek> rakudo/nom: Previously, it did not convey the correct self, since it relied on the

[22:44] <dalek> rakudo/nom: punning mechanism, which must invoke on the pun. Now it's fixed to do

[22:44] <dalek> rakudo/nom: the right thing.

[22:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b22982bb3e

[22:45] *** slayer101_ joined
[22:51] *** cibs joined
[22:56] <jnthn> pst

[22:56] <jnthn> oops, ww

[22:57] <diakopter> pst indeed

[23:00] <bbkr> sink content causes fallback to be executed on object instance creation. weird bug or expected behavior? 

[23:00] <bbkr> r: class A { }; A.^add_fallback(sub ( $object, $name ) { say $name }, sub ( $object, $name ) { return method {} }); A.new

[23:00] <p6eval> rakudo af76e6: OUTPUT«sink␤sink␤»

[23:01] <bbkr> and somehow it is called twice

[23:01] <bbkr> sink context*

[23:01] * bbkr reports just in case

[23:02] <jnthn> Neither are surprising, fwiw.

[23:03] <jnthn> It's called on the type object on the add_fallback line

[23:03] <jnthn> And then again on the A.new line

[23:03] *** bluescreen10 left
[23:03] *** cibs left
[23:04] <bbkr> but fallback should be called on nonexistent methods, I haven't used such

[23:05] <jnthn> Your type has no sink method

[23:05] <dalek> rakudo/nom: e267037 | jnthn++ | src/Perl6/Actions.pm:

[23:05] <dalek> rakudo/nom: Make try/CATCH exception case result in Nil.

[23:05] <dalek> rakudo/nom: 

[23:05] <dalek> rakudo/nom: This brings it in line with the try without explicit CATCH case.

[23:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e267037bb6

[23:05] <jnthn> fallbacks are just extra places to interrogate for extra methods.

[23:06] <jnthn> so when there's no normal sink method, it checks with the fallbacks to see if one of those wishes to provide a suitable method.

[23:07] *** stopbit left
[23:08] <bbkr> thats very counterintuitive. in previous version A.new.foo activated fallback mechanism for method named "foo" without need to provide any methods named "sink" (I don't even know how such method should look like)

[23:10] <jnthn> The reason add_fallback takes two things is so the first one can answer the "does this fallback know how to provide this method" question.

[23:10] <jnthn> So you don't have to provide it at all, just answer with something false in the first one.

[23:11] <jnthn> add_fallback exists for implementing stuff like has $!x handles <foo bar baz>

[23:11] <jnthn> Well, wildcard-ier forms actually

[23:11] *** cibs joined
[23:13] <bbkr> I know that, but take a look from users perspective. When I implement fallback I expect that A.new won't invoke fallback mechanism and A.new.foo will question fallback mechanism about handling "foo" method. And suddenly after changes some "sink" method pops which is just some special name to hardcode.

[23:14] <jnthn> r: class A { }; A.^add_fallback(sub ( $object, $name ) { say $name }, sub ( $object, $name ) { return method {} }); my $x = A.new

[23:14] <p6eval> rakudo e26703: OUTPUT«sink␤sink␤»

[23:14] <jnthn> Hm, wonder why the two calls there...

[23:15] <jnthn> Trouble with "user's perspective" here is that you're using .^add_fallback, which is part of the MOP. It's never been spec'd, it came to exist soley as a way to help implement the (user-facing) handles method.

[23:15] <jnthn> s/method/trait/

[23:18] <bbkr> I agree that it is not spec'd. Is there a way in handles trait to find out method name that was invoked?

[23:19] <jnthn> No; that's not really what handles is for.

[23:21] <jnthn> The way I expected method generation related things to happen is by doing a custom meta-class and overriding find_method.

[23:21] <jnthn> Of course, you'd still get sink that way so... 

[23:22] <timotimo> no matter how often i try, i don't seem to understand new, BUILD and bless :|

[23:22] <bbkr> this change wrecked JSON::RPC module :(

[23:23] <bbkr> and there is no nice way to fix it except hardcoding list of exceptions in first sub

[23:23] <jnthn> Well, the problem is that the mechanism was designed with the expectation of the first sub serving as a *whitelist*.

[23:24] <jnthn> And I'm guessing you actually are just taking any undeclared method name and turning it into a call elsewhere.

[23:25] <bbkr> yes

[23:27] <jnthn> Well, the other fix is just to write in the class you add the fallback to a method sink() { self }

[23:27] <japhb_> What does complex dispatch (multimethod, multisub, single method against multi inheritance, etc.) eventually bottom out to, implementation wise?  "Call this code with this flat list of positional arguments"?  Or is VM expected to handle named arguments and primitive method dispatch as well?

[23:28] <jnthn> multi is always a secondary dispatch, optimization aside

[23:28] <jnthn> and methods are late bound so it's only multi subs that get that

[23:28] * bbkr is curious why stuff like A.new.Str does not pop up in fallback but sinks do

[23:29] <bbkr> jnthn: should I report sink popping up twice?

[23:29] <jnthn> bbkr: Because you inherit a default Str method.

[23:29] <jnthn> You don't inherit a Sink

[23:29] <jnthn> *sink

[23:30] *** lue joined
[23:31] <japhb_> So let me turn that question around a bit: What does NQP need from the VM glue in terms of handling function calls in order to just basically function?

[23:31] <japhb_> s/basically function/handle its most basic functionality/

[23:32] <jnthn> Well, clearly the JVM does not handle named arguments, so I'm having to build that extra bit there.

[23:32] <jnthn> It'd probably be more efficient if it could natively describe a callsite's named/flattening aspects

[23:32] <japhb_> But it sounds like you do have to add that into the glue before you can get NQP operational.

[23:32] <jnthn> Yes

[23:32] <japhb_> gotcha.

[23:42] *** Guest99405 left
[23:42] <jnthn> Generally, it's good to keep dispatch (deciding what will be called) and invocation apart.

[23:43] <jnthn> The final invocation is about the same however we reached the decision.

[23:44] <bbkr> jnthn: adding "method sink { self }" fixed the module, thanks. not a pretty hack because it pollutes dispatch and creates one exception that will never work as expected when called.

[23:44] <jnthn> You already have a bunch, though.

[23:45] *** PacoAir left
[23:45] <jnthn> r: say Any.^methods, Mu.^methods

[23:45] <p6eval> rakudo e26703: OUTPUT«eager elems end classify uniq infinite flat hash list lol pick roll reverse sort values keys kv pairs Array grep first join map min max minmax push tree unshift postcircumfix:<[ ]> at_pos all any one none postcircumfix:<{ }> at_key reduce FLATTENABLE_LIST FLATTENAB…

[23:46] <bbkr> true

[23:47] <jnthn> I'm guessing you don't have a way to introspect the available methods remotely?

[23:47] <jnthn> .oO( if I understand the module at all... :) )

[23:48] <bbkr> no, JSON-RPC does not have any schema or self-discovery mechanisms

[23:49] <jnthn> OK

[23:49] <bbkr> ok, now that I have module fixed one question remains - is "sink" request appearing twice in fallback check a bug or not?

[23:50] <jnthn> It could be being placed in sink context somewhere inside of the new/bless/wherever. It may indicate somewhere we can optimize things, but it's not in itself a bug.

[23:50] <jnthn> imho anyway

[23:50] <jnthn> moritz: Second opinion on ^^ welcome.

[23:51] <bbkr> jnthn: thanks for help and patience to explain this to me

[23:52] <jnthn> np

[23:54] <timotimo> i need to get (or write!) an introduction to new, build, buildall and bless for dummies

[23:55] <jnthn> timotimo: I think there's a moritz blogpost that explains it somewhere, if you didn't already see that.

[23:55] <timotimo> i saw that, read it, thought i understood, and continued to not be able to use them properly

[23:57] <jnthn> Write a method new when you want to provide an interface to construction other than named parameters (e.g. if you want to take a positional parameter). Your new should just about always call bless, rearranging any positionals into nameds.

[23:58] <jnthn> Write a submethod BUILD when you want to control how those named parameters are mapped to attributes and/or do some initialization work.

[23:58] <timotimo> right. do i have to do any attribute setting in BUILD, if i have one?

[23:59] <jnthn> No, you don't have to.

[23:59] <jnthn> Well, depends what you mean by "have to" :)

[23:59] <timotimo> if i don't, will i get "can't look up methods on a type object" when i don't do anything about them in my BUILD?

