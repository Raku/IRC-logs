[00:04] *** tgt left
[00:28] *** lichtkind left
[00:43] <dalek> roast: 7df5f66 | (Brent Laabs)++ | S32-io/ (4 files):

[00:43] <dalek> roast: fix links to specs, change Path to IO::Path

[00:43] <dalek> roast: review: https://github.com/perl6/roast/commit/7df5f66a1a

[00:57] *** Yappo______ left
[00:58] *** FROGGS_ joined
[01:02] *** Yappo______ joined
[01:02] *** FROGGS left
[01:04] *** anuby joined
[01:06] *** berekuk left
[01:08] *** shachaf_ joined
[01:08] *** berekuk joined
[01:08] *** shachaf left
[01:08] *** shachaf_ left
[01:08] *** shachaf_ joined
[01:09] *** shachaf_ is now known as shachaf

[01:10] *** berekuk left
[01:10] <labster> well well, the recent changes to require broke File::Spec... and rightfully so, according to spec.  Ok, easy fix.

[01:14] *** berekuk joined
[01:16] *** berekuk left
[01:17] *** rking left
[01:17] *** rking joined
[01:27] *** Patterner left
[01:29] *** Psyche^ joined
[01:29] *** Psyche^ is now known as Patterner

[01:38] *** gdey_ left
[01:41] *** berekuk joined
[01:50] *** sftp left
[01:53] *** sftp joined
[01:58] *** FROGGS__ joined
[02:02] *** FROGGS_ left
[02:18] *** lustlife joined
[02:36] *** berekuk left
[02:38] *** berekuk joined
[02:47] *** berekuk left
[02:56] *** preflex_ joined
[02:57] *** preflex left
[02:57] *** preflex_ is now known as preflex

[02:58] *** gdey joined
[03:03] *** d4l3k_ joined
[03:03] *** dalek left
[03:03] *** GlitchMr left
[03:03] *** d4l3k_ is now known as dalek

[03:04] *** lestrrat left
[03:08] *** GlitchMr joined
[03:10] *** lestrrat joined
[03:16] *** xinming left
[03:18] *** xinming joined
[03:33] *** _jaldhar_ joined
[03:39] *** rindolf joined
[03:45] *** _jaldhar_ left
[03:49] *** _jaldhar_ joined
[04:00] *** ilogger2 joined
[04:00] *** ChanServ sets mode: +v ilogger2

[04:02] *** broquaint joined
[04:02] *** jfried joined
[04:04] *** avar joined
[04:05] <japhb> .ask timotimo What error are you seeing at http://irclog.perlgeek.de/perl6/2013-04-17#i_6713750 ?  Can you gist it for me?

[04:05] <yoleaux> japhb: I'll pass your message to timotimo.

[04:23] *** Gwyxx joined
[04:24] *** Chillance joined
[04:28] *** thou joined
[04:37] *** rindolf joined
[05:44] *** FROGGS__ joined
[05:44] *** FROGGS__ is now known as FROGGS

[05:45] <FROGGS> .ask timotimo Can't we just add a method .push to QRPA?

[05:45] <yoleaux> FROGGS: I'll pass your message to timotimo.

[05:47] <FROGGS> .tell labster Sorry that I broke "my own" module... Havn't thought of it.... glad you fixed it though. labster++

[05:47] <yoleaux> FROGGS: I'll pass your message to labster.

[05:57] *** frdmn joined
[05:59] *** Chillance left
[06:07] *** SamuraiJack joined
[06:22] <labster> FROGGS: Well, you wrote the code that broke, if you git blame back far enough.  Which is just as well, because I would have been completely  lost trying to figure out how to begin.

[06:22] <yoleaux> 05:46Z <FROGGS> labster: Sorry that I broke "my own" module... Havn't thought of it.... glad you fixed it though. labster++

[06:24] *** thou left
[06:27] *** thou joined
[06:29] <FROGGS> labster: ya, I know that I wrote that part :/

[06:29] * FROGGS cries about not having module tests

[06:30] <labster> Though I finally figured out why your handles branch didn't work -- you can't call access an attribute on a type object, and File::Spec are all used in undefined mode.

[06:31] <labster> I know.  I'm waiting for http://feather.perl6.nl/~sergot/modules/ to start getting up to speed.  Or tell me why something fails.

[06:32] <FROGGS> what 'handles branch'?

[06:33] <labster> https://github.com/FROGGS/p6-File-Spec/tree/handles

[06:34] <FROGGS> ahh, 7 months ago, I totally forgot :o)

[06:37] *** thou left
[06:39] *** kaleem joined
[06:52] *** rindolf left
[06:52] *** rindolf joined
[06:58] <labster> I have a working version of delegation with "handles" now:  https://github.com/labster/p6-File-Spec/blob/master/lib/File/Spec.pm

[06:59] *** rindolf left
[07:00] *** rindolf joined
[07:03] <FROGGS> cool

[07:06] *** domidumont joined
[07:07] *** SamuraiJack left
[07:10] <FROGGS> I'd like to see panda that clean how File::Spec is now^^

[07:10] <FROGGS> s/clean/readable/

[07:11] *** SamuraiJack joined
[07:11] *** takesako___ joined
[07:13] *** preflex joined
[07:15] *** sqirrel joined
[07:15] *** hlin_ joined
[07:17] *** rindolf left
[07:17] *** rindolf joined
[07:18] <tadzik> hehe

[07:19] <tadzik> me too

[07:21] *** domidumont left
[07:22] *** domidumont joined
[07:27] *** xinming joined
[07:32] *** kaleem left
[07:33] *** kaleem joined
[07:36] *** rindolf left
[07:36] *** rindolf joined
[07:48] *** wooden joined
[07:48] *** wooden left
[07:48] *** wooden joined
[07:54] <timotimo> good morning!

[07:54] <yoleaux> 17 Apr 2013 22:58Z <FROGGS> timotimo: I think the changes in QAST::Compiler about $ops.push might be wrong, because it a PIRT::Ops and might really have that method... (have a look at QAST::Operations #295)

[07:54] <yoleaux> 04:03Z <japhb> timotimo: What error are you seeing at http://irclog.perlgeek.de/perl6/2013-04-17#i_6713750 ?  Can you gist it for me?

[07:54] <yoleaux> 05:44Z <FROGGS> timotimo: Can't we just add a method .push to QRPA?

[07:55] <timotimo> FROGGS: that was the last thing i realized before i  went to bad that i should revert the $ops.push changes next time i'm conscious

[07:55] <timotimo> japhb: i was getting infinite recursions

[07:55] <hoelzro> morning #perl6!

[07:56] <timotimo> domo arigato mister rob

[07:56] *** rindolf left
[07:56] *** rindolf joined
[07:57] * hoelzro is building HTML Perl6 docs on his VPS

[07:57] <hoelzro> 50% memory atm =/

[07:57] <timotimo> this runs with a perl6 script?

[07:57] <hoelzro> yes

[07:57] <timotimo> that would explain it

[07:58] <hoelzro> it climbed to 48% really quicky, hung there, and slowly moved to 50

[07:58] <hoelzro> ugh

[07:58] <hoelzro> now it just failed with a "cannot allocate memory" error =/

[07:58] <moritz> hoelzro: I did warn you that it hogs resources

[07:58] <timotimo> aaw :(

[07:58] <hoelzro> I know, but I thought my VPS could handle it =/

[07:58] <timotimo> ooc, does parrot have a generational gc with a nursery and all that jazz?

[07:59] <moritz> yes

[07:59] <hoelzro> is it all Parrot's fault? or does Rakudo yes memory irresponsibly?

[07:59] <timotimo> and cycle detection, too?

[07:59] <timotimo> does perl6 maybe use hashmaps for all objects or something?

[08:00] <moritz> no

[08:02] * timotimo is already out of ideas

[08:03] *** daxim joined
[08:03] *** berekuk joined
[08:04] <diakopter> guessing game: match the # of distributions updated in <3yrs: 7,012 11,820 27,784 46,349 : GHC CPAN NPM JVM

[08:05] <diakopter> er s/JVM/MVN/

[08:05] <diakopter> without cheating by looking it up

[08:05] <arnsholt> timotimo: I think cycle detection happens by itself when you have generational/tracing

[08:06] <timotimo> that makes sense

[08:07] <hoelzro> I might try to trim htmlify.pl's memory usage

[08:09] <diakopter> no one has a guess?

[08:10] <sorear> hmm

[08:10] <sorear> NPM>CPAN>JVM>GHC

[08:10] <hoelzro> CPAN is 46K, GHC is 27K, NPM is 11.8K, JVM is 7K

[08:10] <sorear> is my guess

[08:10] * hoelzro shrugs

[08:11] <diakopter> I'll wait another few minutes to reveal

[08:11] *** rindolf left
[08:11] *** rindolf joined
[08:13] <diakopter> arnsholt?  timotimo?  moritz?  yoleaux? a guess?

[08:13] <diakopter> yoleaux: you know you want to guess

[08:14] <arnsholt> I think I'd put NPM at 7k, at least

[08:14] <timotimo> NPM is the node.js thing, right?

[08:14] <diakopter> yep

[08:14] <timotimo> it's the one with 46k.

[08:14] <arnsholt> NPM < GHC < CPAN < MVN perhaps

[08:15] <diakopter> heh, fairly different from sorear's

[08:15] *** woolfy joined
[08:15] <diakopter> and hoelzro's

[08:15] <nwc10> what's MVN?

[08:15] <diakopter> maven

[08:16] * diakopter waits 1 more min in case nicholas wants to guess

[08:17] <nwc10> my network is so slow I probably can't even type something in 1 min

[08:17] <nwc10> ad I don't want to guess

[08:17] <nwc10> and I'm not sure what maven is

[08:17] <diakopter> heh ok

[08:17] <diakopter> this is maven: http://search.maven.org/#stats and http://www.jarvana.com/jarvana/info/repository_statistics

[08:18] <diakopter> answer: they're in the right order already

[08:19] <diakopter> also, the mvn one is probably a huge underestimate since I was just able to measure the central repo

[08:19] <diakopter> well maybe not huge, but significant

[08:22] <diakopter> cpan by comparison: http://mirrors.cpan.org/stats/

[08:22] <diakopter> nwc10: another mvn site: has a pretty graph: http://mvnrepository.com/

[08:27] <diakopter> cpan grew 36% in 2 years in number of files; mvn grew 100%

[08:32] *** rindolf left
[08:32] *** rindolf joined
[08:33] <jnthn> morning, #perl6

[08:33] <diakopter> GUGT jnthn

[08:34] <diakopter> oh, I forgot to include the .NET package management system NuGet, which was only created a couple years ago, but already has 11,000 unique distributions

[08:35] <diakopter> er, 12,191 to be exact

[08:35] *** tangentstorm joined
[08:39] <timotimo> jnthn: does turning .push into nqp::push for nqp-level arrays (rpa and qrpa) help portability at all?

[08:41] *** FROGGS left
[08:41] <jnthn> timotimo: No.

[08:41] <jnthn> timotimo: Only in the MOP, where it's already been done.

[08:42] <timotimo> hm.

[08:42] <timotimo> so maybe adding a .push to qrpa would be a better idea?

[08:42] <timotimo> for now, i'll just sift through the rest of nqp ...

[08:45] *** fgomez joined
[08:46] *** dakkar joined
[08:52] *** cognominal joined
[08:52] *** kresike joined
[08:52] <kresike> hello all you happy perl6 people

[08:53] *** rindolf left
[08:54] *** rindolf joined
[08:55] <hoelzro> does the Perl 6 spec dictate what form of GC should be used? (ref counting vs mark and sweep)

[08:56] <diakopter> no, but once you handle cycle-detection fully in ref counting you've made a lot of progress toward a precise GC...

[08:58] *** berekuk left
[08:59] <diakopter> (sort of)

[09:01] <jnthn> timotimo: Oh, you're working on RPA => QRPA? Hm.

[09:01] <jnthn> timotimo: Well, the .push method isn't really a portability issue

[09:01] <jnthn> nqp-jvm: my @a; @a.push(42); say(@a[0])

[09:01] <camelia> nqp-jvm: OUTPUT«42␤»

[09:02] <diakopter> nqp-jvm: (my @a).push(42); say(@a[0])

[09:02] <jnthn> timotimo: I suspect adding the push method to QRPA (along with the 3 others) is the most expedient way.

[09:02] <camelia> nqp-jvm: OUTPUT«42␤»

[09:02] <jnthn> Nice try :P

[09:02] <diakopter> me?

[09:03] <tadzik> there was no try { } ;)

[09:03] <jnthn> :P

[09:03] *** fgomez left
[09:03] *** berekuk joined
[09:03] <tadzik> "do {} or Acme::Don't. There is no try { }"

[09:04] <timotimo> jnthn: it's too late for that now, i just compiled a complete nqp.

[09:04] <diakopter> nqp-jvm: (BEGIN my @a)(42); say(@a.elems)

[09:04] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1229)␤     at org.perl6.nqp.runtime.Ops.invoke(Ops.java:1200)␤     at 32E184A159F2AB2B80B927BE69AB29A193D0E286.qb_25(<generated>)␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1240)␤     at

[09:04] <camelia> ..…

[09:04] <timotimo> a few mistakes remain, though.

[09:04] <diakopter> ftw

[09:04] <timotimo> delete_keyed? what is that even?

[09:05] <tadzik> you know your code is broken when even camelia says "..."

[09:05] <jnthn> nqp: (BEGIN my @a)(42); say(@a.elems)

[09:05] <camelia> nqp: OUTPUT«Method 'elems' not found for invocant of class 'ResizablePMCArray'␤current instr.: '' pc 69 ((file unknown):154827407) (/tmp/4HDpv_PkE7:1)␤»

[09:05] <diakopter> nqp-jvm: BEGIN my @a

[09:06] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1229)␤     at org.perl6.nqp.runtime.Ops.invoke(Ops.java:1200)␤     at 32E184A159F2AB2B80B927BE69AB29A193D0E286.qb_25(<generated>)␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1240)␤     at

[09:06] <jnthn> Hm. :)

[09:06] <camelia> ..…

[09:06] <diakopter> golfed

[09:06] <jnthn> Oh...

[09:06] <jnthn> Yeah, and there's no tests for BEGIN either...

[09:07] <diakopter> nqp-jvm: my @a := 7; say(@a.WHAT)

[09:07] <camelia> nqp-jvm: OUTPUT«␤»

[09:07] <diakopter> orly

[09:07] <diakopter> nqp: my @a := 7; say(@a.WHAT)

[09:07] <camelia> nqp: OUTPUT«Can only use get_what on a SixModelObject␤current instr.: '' pc 52 ((file unknown):141407052) (/tmp/Cxi7VnLKEA:1)␤»

[09:08] * diakopter tries to remember what that nqp:: op is to get the parrot type

[09:09] <diakopter> nqp-jvm: BEGIN 1

[09:09] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1229)␤     at org.perl6.nqp.runtime.Ops.invoke(Ops.java:1200)␤     at 32E184A159F2AB2B80B927BE69AB29A193D0E286.qb_25(<generated>)␤ at org.perl6.nqp.runtime.Ops.invokeInternal(Ops.java:1240)␤     at

[09:09] <camelia> ..…

[09:09] <jnthn> There isn't an nqp:: op to do anything Parrot specific. :)

[09:09] <diakopter> "there's just ops that aren't necessary to implement on the others..."

[09:10] <jnthn> You use pir:: to get at those

[09:10] <jnthn> Also, NQP doesn't make a gist/Str distinction, and Str on a type object gives back the empty Str

[09:15] *** berekuk left
[09:15] *** fgomez joined
[09:16] <timotimo> what is delete_keyed for? seems like it would be for hashes

[09:16] <jnthn> Parrot calls everything keeyed

[09:16] <jnthn> *keyed

[09:16] <tadzik> keyed_int is for arrays, iirc

[09:16] <jnthn> *nod*

[09:17] <timotimo> oh, ok

[09:17] <timotimo> delete_keyed() not implemented in class 'QRPA'  <- this confuses me.

[09:18] <timotimo> there really is no delete_keyed in there. but why?

[09:18] <timotimo> if it's supposed to be a drop-in replacement for rpa, why not implement that? maybe because it is only used in test code?

[09:20] <timotimo> i'll be excited to see if rakudo compiles its setting faster with these nqp changes

[09:20] <timotimo> oh, i probably need to create lots and lots of nqp::push/pop/shift/unshift changes in rakudo, too :|

[09:21] * jnthn digs back into the NQP bootstrap on JVM stuff

[09:22] *** berekuk joined
[09:23] <timotimo> wise jnthn, how do i properly add those methods to the qrpa pmc?

[09:24] <timotimo> would it be sufficient to copy these following lines? https://github.com/parrot/parrot/blob/master/src/pmc/resizablepmcarray.pmc#L193

[09:24] *** census joined
[09:24] <jnthn> timotimo: I suspect delete_keyed should be delegating to delete_keyed_int. You may be able to steal directly from RPA

[09:24] *** census left
[09:24] <jnthn> shift_float?

[09:25] * jnthn gets curious where we hit that code path in NQP...

[09:25] <jnthn> Anyway, no, that's not sufficient. You'd be better delegating to shift_pmc and then doing get_number on the result in QRPA, if you have to implement shift_float...

[09:26] <timotimo> qrpa doesn't implement any method with "delete" in it

[09:26] <timotimo> but as i said: the only place that seems to hit that is the test code.

[09:28] <timotimo> wow, if i did this correctly, implementing .push and friends was super trivial

[09:28] *** rindolf left
[09:29] *** rindolf joined
[09:33] *** frdmn is now known as kalle

[09:33] *** kalle is now known as frdmn

[09:36] *** frdmn is now known as rnarius

[09:38] <timotimo> parsing wasn't any farster than it normally is, but maybe rakudo uses nqp::list in many places

[09:39] <timotimo> oh, the optimizer is quite a bit faster though

[09:39] <timotimo> er, at least i think so. i should do proper tests.

[09:39] * timotimo spectests

[09:40] *** rnarius is now known as frdmn

[09:42] *** berekuk left
[09:46] *** fgomez left
[09:46] <timotimo> ah, qrpa doesn't have a .sort method. makes one of the rakudo tests fail

[09:47] <timotimo> .sort being missing seems to cause a big part of all test failures so far

[09:49] *** fgomez joined
[09:49] *** terrencehan joined
[09:50] <timotimo> oh, whoops. these aren't supposed to be qrpa's. these are supposed to be List classes!

[09:50] <timotimo> maybe the p6list op needs to learn about qrpa

[09:51] <timotimo> $ops.add_hll_pirop_mapping('perl6', 'p6list', 'perl6_list_from_rpa', 'PPPP', :inlinable(1));

[09:51] <timotimo> yeah, that would be the problem

[09:55] <timotimo> hm.

[09:57] <timotimo> oh, that's not it. rakudo just delegates to the list to do the sorting

[09:57] *** tgt joined
[09:58] <timotimo> somehow qrpa is meant to inherit a sort method

[09:58] <timotimo> but all the sort tests are commented out

[10:07] *** baest joined
[10:19] *** rindolf left
[10:20] *** rindolf joined
[10:21] *** kshamen joined
[10:23] *** mtk joined
[10:24] *** kshamen left
[10:24] <timotimo> so, how do i make nqp link the parrot utils to my qrpa? perl6: symbol lookup error: /home/timo/build/rakudo/install/lib/parrot/5.2.0-devel/dynext/nqp_group.so: undefined symbol: Parrot_util_quicksort

[10:31] *** grondilu joined
[10:33] <grondilu> rn: say "a" .. "Z"

[10:33] <camelia> rakudo f3c3fe, niecza v24-37-gf9c8fc2: OUTPUT«"a".."Z"␤»

[10:33] <grondilu> rn: say list "a" .. "Z"

[10:33] <camelia> rakudo f3c3fe, niecza v24-37-gf9c8fc2: OUTPUT«␤»

[10:33] <timotimo> grondilu: do i remember correctly that you have some involvement in parrot?

[10:34] <grondilu> timotimo: no, I don't.

[10:34] <timotimo> hm, okay

[10:37] <timotimo> jnthn: is it sensible to try to use Parrot_util_quicksort in a pmc created inside the nqp tree, rather than in parrot proper?

[10:37] <timotimo> if i wanted to copypaste the implementation, i'd need to steal COMPARE, too and whatever hangs off of that :|

[10:38] <jnthn> timotimo: If it's marked PARROT_EXPORT then maybe...but also need to know that it doesn't poke into internals anywhere

[10:40] *** hlin_ left
[10:40] <timotimo> it is not marked export; i don't see it poke around in internals, though

[10:40] *** hlin_ joined
[10:40] <timotimo> oh, what is PARROT_NCI? perhaps that's internal-ish?

[10:40] <jnthn> Not sure

[10:42] <timotimo> well, now i've gotten it to work by copypasting lots of bits into the qrpa pmc; Parrot_NCI_attributes (and the above macro seems to be a cast to that) seems a little bit internaly in that it would probably change some time in parrots future

[10:43] <timotimo> can i implement a sort method for the pmc in nqp perhaps? that would be lovely. i don't have much experience with C :(

[10:43] <timotimo> it amuses me that no list is ever sorted in the building process of nqp :)

[10:48] <timotimo> more tests seem to pass now, i'll be excited to see the end result

[10:48] <timotimo> and do benchmarks of course

[10:52] <timotimo> THINE TESTS SHALL PASS

[10:55] <dalek> nqp/qrpa_experiment: b136109 | (Timo Paulssen)++ | src/pmc/qrpa.pmc:

[10:55] <dalek> nqp/qrpa_experiment: give qrpa the methods instead.

[10:55] <dalek> nqp/qrpa_experiment: review: https://github.com/perl6/nqp/commit/b13610905d

[10:55] <dalek> nqp/qrpa_experiment: 91353c0 | (Timo Paulssen)++ | src/pmc/qrpa.pmc:

[10:55] <dalek> nqp/qrpa_experiment: steal the quicksort implementation from parrot

[10:55] <dalek> nqp/qrpa_experiment: review: https://github.com/perl6/nqp/commit/91353c0caa

[10:55] <dalek> nqp/futile_qrpa: af36e92 | (Timo Paulssen)++ | src/ (12 files):

[10:55] <dalek> nqp/futile_qrpa: search&replace nqp::list -> nqp::qlist; change .push to nqp::push etc

[10:55] <dalek> nqp/futile_qrpa: review: https://github.com/perl6/nqp/commit/af36e9244e

[10:55] <dalek> nqp/futile_qrpa: 491eec9 | (Timo Paulssen)++ | src/ (6 files):

[10:55] <dalek> nqp/futile_qrpa: so many search and replace. probably too many.

[10:55] <dalek> nqp/futile_qrpa: review: https://github.com/perl6/nqp/commit/491eec9193

[10:55] <dalek> nqp/futile_qrpa: ccfaf88 | (Timo Paulssen)++ | src/ (7 files):

[10:55] <dalek> nqp/futile_qrpa: lots and lots of nqp::un/shift/push/pop.

[10:55] <dalek> nqp/futile_qrpa: review: https://github.com/perl6/nqp/commit/ccfaf8890f

[10:55] <dalek> nqp/futile_qrpa: be526ca | (Timo Paulssen)++ | src/NQP/World.pm:

[10:55] <dalek> nqp/futile_qrpa: final fixups

[10:55] <dalek> nqp/futile_qrpa: review: https://github.com/perl6/nqp/commit/be526ca829

[10:55] <dalek> nqp/futile_qrpa: 6c090d2 | (Timo Paulssen)++ | src/pmc/qrpa.pmc:

[10:55] <dalek> nqp/futile_qrpa: give qrpa the methods instead.

[11:01] *** grondilu left
[11:03] <timotimo> rakudo's setting compile step doesn't seem to become any faster with qrpa. i wonder if i did something wrong?

[11:10] <timotimo> oh, i think i compiled the "pure" rakudo with a qrpa-nqp

[11:13] *** fgomez left
[11:18] * timotimo is not sure how to have two different rakudos on the same machine without having multiple users

[11:19] <hoelzro> different prefixes?

[11:19] <hoelzro> you probably need two separate parrots as well, I'd guess

[11:21] * nwc10 would hope that if both use the same parrot, life gets easier

[11:22] * [Coke] yawns.

[11:27] <timotimo> hm, if i use two different versions of parrot - like just 5.3 and 5.3 - will that already be enough to allow me to have two different nqps and rakudos?

[11:29] <timotimo> now i made extra sure. there is 0 speed difference in my benchmarks between qrpa and rpa ... >_>

[11:29] <timotimo> but i've got to go now anyway

[11:31] <tadzik> that's weird

[11:31] <timotimo> yes, it is

[11:31] <tadzik> maybe it still uses the old RPA?

[11:31] <timotimo> my code is up on github in perl6/nqp and timo/rakudo if you want to see for yourself if i made any blatantly obvious mistakes

[11:32] <timotimo> when i still missed the .sort method in qrpa, i got errors in the spectests about it missing, so ... i don't think so. i'd be glad if someone proved me wrong.

[11:32] <timotimo> gotta run! ttyl

[11:32] *** Heather joined
[11:32] <Heather> hi!

[11:32] <jnthn> hi, Heather 

[11:33] <Heather> how to get file extension?

[11:35] <jnthn> Can always regex it... /'.'(\w+)$/ or so

[11:35] <[Coke]> r: say "coffee" or die;

[11:35] <camelia> rakudo f3c3fe: OUTPUT«coffee␤»

[11:35] <[Coke]> smart bot. :P

[11:35] <jnthn> tbh, if you said that to me, I'd say coffee as well...

[11:35] <jnthn> :P

[11:38] <Heather> )

[11:43] <Heather> jnthn thank you!

[11:44] *** rindolf left
[11:44] *** rindolf joined
[11:46] *** spider-mario joined
[11:47] <Heather> how to declare enum

[11:48] <Heather> I see

[11:48] <Heather> r: enum <a,b>

[11:48] <camelia> rakudo f3c3fe:  ( no output )

[11:48] <jnthn> Well, best give it a name

[11:48] <moritz> http://perlgeek.de/blog-en/perl-5-to-6/16-enums.html

[11:48] <jnthn> enum Drink <Tea Coffee>

[11:48] <Heather> r: enum x <a,b>; say x.a

[11:48] <[Coke]> also <a,b> is probably not quite what you meant.

[11:48] <camelia> rakudo f3c3fe: OUTPUT«No such method 'a' for invocant of type 'x'␤  in block  at /tmp/TNILTaVaRE:1␤␤»

[11:48] <[Coke]> Heather: no comma

[11:48] <moritz> oorks, that looks a bit out of date

[11:48] <moritz> I have to fix that, eventually

[11:48] <jnthn> And ::, not .

[11:49] <Heather> r: enum Drink <Tea Coffee>; say Drink::Tea

[11:49] <camelia> rakudo f3c3fe: OUTPUT«Tea␤»

[11:50] <Heather> thank you

[11:50] <[Coke]> r: enum Drink <Tea Coffee>; say Coffee; #ahhhh.

[11:50] <camelia> rakudo f3c3fe: OUTPUT«Coffee␤»

[11:50] <Heather> wait ) p6eval is not camelia )

[11:50] <[Coke]> she's a butterfly of many hats.

[11:50] <Heather> "of many hats." ?

[11:51] <[Coke]> colorful language for "she has many skills"

[11:52] <Heather> r: given "a" { when "b" |  "a" { say "a" } }

[11:52] <camelia> rakudo f3c3fe: OUTPUT«a␤»

[11:52] <Heather> sometimes perl pretty intuitive

[12:02] <Heather> when I get extension with $arg ~~ /'.'(\w+)$/ how can I get file name without extension ....

[12:02] <timotimo> tadzik: were you going to try out the code?

[12:02] <Heather> $arg - $/ ?

[12:02] <Heather> )

[12:03] <tadzik> timotimo: no, sorry, no tuits

[12:03] <moritz> Heather: $/.prematch iirc

[12:04] <moritz> r: 'abc.txt' ~~ /'.'(\w+)$/; say $/.prematch

[12:04] <camelia> rakudo f3c3fe: OUTPUT«abc␤»

[12:04] <moritz> aye

[12:05] <timotimo> tadzik: no problem

[12:05] <Heather> moritz works ! thank you

[12:11] <Heather> can I regex in given ?

[12:11] <timotimo> you mean with "when"?

[12:11] <Heather> yes or somehow alike

[12:11] <timotimo> given "foo" { when /.../ { say "at least three letters" }; when /../ { say "at least 2 letters" } }

[12:12] <Heather> r: given "foo" { when /.../ { say "at least three letters" }; when /../ { say "at least 2 letters" } }

[12:12] <camelia> rakudo f3c3fe: OUTPUT«at least three letters␤»

[12:12] <Heather> timotimo cool, thank you

[12:12] <timotimo> sorry my ssh is dying. may need rx/.../

[12:13] *** rindolf left
[12:14] *** rindolf joined
[12:16] <Heather> r: if "a.x" ~~ /z/ | /a/ { say "x" }

[12:16] <camelia> rakudo f3c3fe: OUTPUT«x␤»

[12:16] <Heather> r: if "a.x" ~~ /z/ | /y/ { say "x" }

[12:16] <camelia> rakudo f3c3fe:  ( no output )

[12:17] <Heather> well... it like you write random code and it works...

[12:17] <Heather> I wonder...

[12:18] *** domidumont left
[12:18] <Heather> r: if "a.x" !~~ /z/ | /y/ { say "x" }

[12:18] <camelia> rakudo f3c3fe: OUTPUT«x␤»

[12:18] <Heather> r: if "a.x" !~~ /z/ | /x/ { say "x" }

[12:18] <camelia> rakudo f3c3fe:  ( no output )

[12:19] <timotimo> it would appear the List class doesn't properly use qlist yet m(

[12:19] *** domidumont joined
[12:23] <timotimo> who ever has the tuits would be very welcome to correct nqp::p6list (apparently in rakudo rather than in nqp) to create qlist instead of list objects. i don't have the necessary overview to see what needs changing

[12:24] <Heather> strange

[12:24] <Heather> r: given "foo" { when /f/ { say "fffff" }; }

[12:24] <camelia> rakudo f3c3fe: OUTPUT«fffff␤»

[12:25] <timotimo> you seem to expect implicit ^^^H and $?

[12:25] <timotimo> oh. well that's interesting

[12:26] <timotimo> oh, Heather, that's a optimization bug

[12:26] <timotimo> i've already fixed it, but the fix hasn't been merged yet

[12:27] *** sqirrel left
[12:28] <timotimo> i seem to have forgotten to create a pull request

[12:28] <Heather> good.

[12:29] <timotimo> moritz: am i looking wrong or did you close the pullrequest without actually merging?

[12:29] <timotimo> at least github didn't write "branch was merged"

[12:29] <moritz> timotimo: I've done a fast-forward merge, which github didn't recognize

[12:30] <timotimo> it seems i must look closer.

[12:30] <moritz> timotimo: but commit 5122e2ead909c61ba2648023bb16f789d1389ac5 is in nom

[12:30] <timotimo> yes, it's there!

[12:30] <moritz> and in fact rakudo's behavior is correct

[12:31] <moritz> because !~~ is a negated operator, it desugars to    if !('a.x' ~~ /x/|/y/) { ... }

[12:32] <timotimo> my optimization doesn't touch it, either

[12:32] <timotimo> that would explain it

[12:32] * timotimo unpanics

[12:32] *** FROGGS joined
[12:32] <timotimo> FROGGS: hey!

[12:32] *** terrencehan left
[12:32] <FROGGS> \o/

[12:32] *** Nom- joined
[12:33] <timotimo> FROGGS: do you have a modicum of tuits for qrpa?

[12:33] * FROGGS google modicum

[12:33] <FROGGS> goodles*

[12:33] <FROGGS> timotimo: yes

[12:34] <timotimo> 'perl6_list_from_rpa' seems to need a fix tocreate qrpa instead of rpa

[12:34] <FROGGS> "give qrpa the methods instead." timotimo++

[12:34] <FROGGS> ahh, okay

[12:34] <timotimo> so far it seems to dispatch to a parrot op, so it probably needs to be newly implemented in the rakudo/src/perl6/ops or whereever you'll find that

[12:34] <FROGGS> timotimo: where is that?

[12:34] <FROGGS> k

[12:34] <timotimo> src/Perl6/Ops.pm

[12:35] <FROGGS> will give it a look

[12:37] <Nom-> Hey guys... stumbled accross http://rdstar.wordpress.com/2012/07/12/nqp-on-llvm-how-to-port/ earlier... was wondering if anyone knows anything about whether those efforts might have started at all?

[12:37] *** jtpalmer joined
[12:38] <moritz> Nom-: lue should know

[12:38] <[Coke]> though I imagine if lue is working on it without taking what jnthn is doing with nqp-jvm, that would be odd.

[12:39] <Heather> I want tool to convert batch to bash and backward :) https://github.com/Heather/script/blob/master/bin/script

[12:40] <Nom-> It's something that interests me is all :)

[12:40] <Nom-> I'm not very proficient with LLVM yet, but i'm learning

[12:41] <arnsholt> Since that blog post was written, jnthn++ has ported almost all of NQP to the JVM

[12:41] <arnsholt> How he did that would likely be a good guide for how to do a different backend

[12:41] <jnthn> The JVM provides significantly more runtime infrastructure than LLVM.

[12:41] <Nom-> Yeah, aware of that

[12:42] <arnsholt> Oh, definitely

[12:42] <jnthn> Which isn't really a VM in the same sense.

[12:42] <Nom-> I was actually toying with the idea of integrating it into the Rubinius VM

[12:42] <arnsholt> Troo, troo

[12:42] <arnsholt> Rubinius or PyPy would be more similar to JVM I think

[12:42] <jnthn> *nod*

[12:43] * jnthn is currently fighting separate compilation issues in the JVM port...

[12:43] <dalek> ecosystem: 42c80de | colomon++ | META.list:

[12:43] <dalek> ecosystem: Change XML (exemel) to point to my working fork

[12:43] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/42c80de0f4

[12:43] *** tgt left
[12:43] <Heather> Rubinius VM looks nice

[12:44] <FROGGS> colomon++ # resistance is futile

[12:44] <Nom-> Yeah, my experience with it has been quite positive... the startup time is slower than CRuby, but runtime performance is substantially faster now

[12:44] <Nom-> And they're continually improving it

[12:46] *** tgt joined
[12:47] *** brrt joined
[12:47] <timotimo> FROGGS: did you make any progress in understanding or implementing?

[12:51] *** rindolf left
[12:51] <FROGGS> timotimo: beeing at work, I'll let you know if I have something or when I get stuck

[12:51] <timotimo> ah, good. thank you!

[12:52] *** rindolf joined
[12:52] <timotimo> what, i seem to not be using nqp::qlist at all yet m)

[12:53] <timotimo> i must have reverted those changes some time and forgotten about it

[12:54] *** Heather left
[12:54] *** cognominal left
[12:55] *** crab2313 joined
[12:57] <Nom-> So if I follow this right... been a while since I knew this stuff... Parrot has a PIR language... there's a NQP compiler written in PIR

[12:58] <Nom-> Although, from what I'm seeing, the compiler is currently generated from...not sure... perl5 code?

[12:58] <jnthn> Nom-: NQP is written in NQP; it's bootstrapped.

[12:58] *** silug joined
[12:59] <Nom-> Ok, so phase 1 in any port is ultimately to rewrite that bootstrap I'm guessing...

[12:59] <timotimo> the nqp compiler is being generade from nqp code

[12:59] * Nom- looks back at the JVM code again

[13:01] <timotimo> FROGGS: feel free to sed nqp::list( to nqp::qlist in nqp/src/

[13:01] <jnthn> Nom-: I should write a "how to" doc on porting, but the overall approach is that you write a code generator for the backend, write the bits of runtime support, and then set things up as a cross-compiler. You then get to the point of cross-compiling/running/passing most of the NQP test suite. Then you use the cross-compiler to cross-compile NQP itself.

[13:01] * [Coke] wonders if the nqp repo is going to get a <vm> dir above the various stageN dirs now.

[13:01] <jnthn> [Coke]: See jvm-support branch in NQP for how I have it so far.

[13:03] <FROGGS> timotimo: k

[13:04] <jnthn> [Coke]: But short answer is that stage0 is per-vm, and stage1/stage2 are always generated (this second bit is already true)

[13:04] <timotimo> alternatively, maybe we should replace code like my @foo := nqp::q?list(); with my @foo; because there's the default_for thing anyway that will create a qlist or list

[13:04] <timotimo> jnthn: does that make sense to you?

[13:05] <jnthn> timotimo: Only if we were going to declare a variable anyway

[13:05] <timotimo> of course

[13:05] <jnthn> my @a := nqp::list() # is kinda a waste of code, for example

[13:05] *** domidumont left
[13:06] <timotimo> i was refering to only those kinds of list creation

[13:06] <jnthn> ah, then feel to clean them up

[13:07] <pmichaud> I'm worried about the autothreading commit in #128...   it checks explicitly for Any in the signature.  What about signatures that aren't Any, should they autothread?  Or is Junction defined to autothread only over the Any type?

[13:08] <timotimo> pmichaud: Junction derives from Mu, Any derives from Mu

[13:08] <pmichaud> timotimo: what about another class that derives from Mu

[13:09] <timotimo> oh. that's not a bad point actually.

[13:09] <timotimo> what reason is there to derive from Mu rather than Any?

[13:09] <moritz> r: class A is Mu { }; say A.^mro; sub f($x) { }; f A

[13:09] <camelia> rakudo f3c3fe: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (A) (lines 1, 1)␤    Expected: :($x)␤»

[13:10] <moritz> timotimo: if one doesn't want the gazillions of methods defined in Any

[13:10] <timotimo> mhm

[13:10] <timotimo> or even any of the gazillion 

[13:10] <timotimo> or even use any of the gazillion already existing subs :)

[13:10] *** Gwyxx left
[13:11] *** SamuraiJack left
[13:11] <pmichaud> the fact that there's at least one class outside of Any (Junction) means that there may be models in which there will be more.

[13:11] <timotimo> indeed. i will change the code. still curious ;)

[13:11] <pmichaud> for example, S02 currently says that Failure derives from Mu (could be fossil)

[13:11] <moritz> well, non-Any types don't autothread

[13:11] <timotimo> r: say Failure.^mro;

[13:11] <camelia> rakudo f3c3fe: OUTPUT«(Failure) (Any) (Mu)␤»

[13:12] <moritz> as demonstrated above

[13:12] <timotimo> pmichaud: i'll change that piece of spec for you :)

[13:12] <pmichaud> timotimo: no, don't just "change the spec"

[13:12] <pmichaud> there may be a good reason for Failure to derive from Mu and not Any

[13:12] <pmichaud> and rakudo might just have it wrongly placed.

[13:12] *** SamuraiJack joined
[13:12] <timotimo> mhm, right

[13:13] <pmichaud> moritz: do we know that non-Any types don't autothread?  I can't seem to find that anywhere in the spec.

[13:13] <dalek> nqp-jvm-prep: ddd73cb | jnthn++ | / (5 files):

[13:13] <dalek> nqp-jvm-prep: Fix HLL types seperate compilation leaks.

[13:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ddd73cb641

[13:13] <dalek> nqp-jvm-prep: 5559d13 | jnthn++ | / (4 files):

[13:13] <dalek> nqp-jvm-prep: More assorted separate compilation fixes.

[13:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/5559d13754

[13:13] <dalek> nqp-jvm-prep: 9f40bc8 | jnthn++ | nqp-src/NQPCORE.setting:

[13:13] <dalek> nqp-jvm-prep: Fix one more sep-comp leak.

[13:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/9f40bc8756

[13:13] <jnthn> pmichaud: Autothreading happens (in current impl, and afaik spec) as a binding failover.

[13:13] <pmichaud> jnthn: right

[13:13] <colomon> \o/

[13:14] <jnthn> pmichaud: The fact that Junction !~~ Any causes the failure.

[13:14] <jnthn> And then we say "oh, it's a Junction, let's autothread"

[13:14] <pmichaud> jnthn: what about Junction !~~ Foo where Foo isn't an Any

[13:14] <jnthn> So the auto-threader looks for the Junction type in particular.

[13:14] <pmichaud> jnthn: yes, that's my point.

[13:14] <pmichaud> the autothreader looks for Junction type, while the optimization added is looking for Any

[13:14] <moritz> so if you want your custom type to autothread, you have to subclass Junction

[13:15] <pmichaud> let me summarize it this way

[13:15] * moritz still doesn't see the case where the optimizer can cause wrong behavior

[13:15] *** domidumont joined
[13:15] <jnthn> r: class OutOfAny is Mu { }; sub x(OutOfAny $x) { }; x(all(OutOfAny, OutOfAny))

[13:15] <camelia> rakudo f3c3fe:  ( no output )

[13:15] <jnthn> r: class OutOfAny is Mu { say 'here' }; sub x(OutOfAny $x) { }; x(all(OutOfAny, OutOfAny))

[13:15] <camelia> rakudo f3c3fe: OUTPUT«here␤»

[13:16] <jnthn> oops

[13:16] <jnthn> r: class OutOfAny is Mu { }; sub x(OutOfAny $x) { say 'here' }; x(all(OutOfAny, OutOfAny))

[13:16] <camelia> rakudo f3c3fe: OUTPUT«here␤here␤»

[13:16] <jnthn> Yes, it works

[13:16] <jnthn> pmichaud++ # noticing things

[13:16] <pmichaud> does f3c3fe have the optimization applied?

[13:16] <pmichaud> here's the summary

[13:16] <pmichaud> the dispatcher is saying "autothread anything that isn't a Junction"

[13:17] <pmichaud> the optimizer is saying "autothread only those things with Any parameters"

[13:17] <pmichaud> the two are not equivalent.

[13:18] <moritz> "autothread only those things with Any parameters" is a subset of "autothread anything that isn't a Junction", no?

[13:18] <pmichaud> I didn't say that quite right.

[13:19] <pmichaud> but my point is that it's a subset.

[13:19] <pmichaud> which means that the optimizer won't autothread some things that it should.

[13:19] <moritz> when the optimizer doesn't autothreads it, the runtime can still do it

[13:20] <moritz> the optimizer looks for cases where it's safe to perform its operation

[13:20] <moritz> it's not a problem that it can't optimize all cases

[13:20] <pmichaud> hmmmm

[13:20] <moritz> at least not a problem with correctness

[13:20] *** cognominal joined
[13:20] <moritz> possibly one with performance

[13:20] <pmichaud> then at least the comment in the commit is wrong

[13:20] <pmichaud>        # only if a chain operator handles Any, rather than Mu, in its signature

[13:20] <pmichaud> +        # will autothreading actually happen.

[13:21] <pmichaud> and also

[13:21] <pmichaud> +    # And the Any type, important for being the "not junction" type.

[13:21] <pmichaud> +    has $!Any;

[13:21] <pmichaud> both of those comments are at least semantically misleading.

[13:22] <timotimo> ~i've changed it :)

[13:22] <jnthn> Woo, NQP hosted on the JVM can now spit out an NQP for the JVM.

[13:23] <jnthn> Now I "just" need to do the stage2 bit of the Makefile and hope it works... :)

[13:23] <pmichaud> there are other issues with the commit.  For example, the variable says $!SETTING but what it's really looking for is CORE

[13:24] <arnsholt> jnthn: We eagerly await news of how it goes =)

[13:24] <timotimo> my ssh connections are currently misbehaving, else i'd've already pushed the fixing commit

[13:24] <pmichaud> CORE is *a* setting, it's not *the* setting

[13:25] *** bluescreen10 joined
[13:25] <Nom-> Just to be sure I'm not going crazy, t/nqp/* is *actual* NQP code I need to parse, right?

[13:27] <pmichaud> moritz: I get your point about the optimizer only handling those it knows are safe... point well made.  Thanks for clarifying.

[13:27] *** nemesys left
[13:28] <jnthn> Nom-: I don't suggest porting be done by writing an NQP parser.

[13:29] <jnthn> Nom-: Things are factored so you can use the existing one and just write an extra backend, then plug your backend in. That way, you can focus just on cdoe generation at first.

[13:29] <jnthn> *code

[13:29] <pmichaud> more importantly, writing an NQP parser means writing a regular expression engine :-)

[13:29] <colomon> do install failures kill pandabrew's rebootstrap?

[13:30] <colomon> er, tadzik ^^^

[13:31] <arnsholt> A key point about NQP, is that there's more to it than the parser and code generation. It also depends on runtime support for the object model and grammar engine, for example

[13:31] <Nom-> hmmm

[13:31] <Nom-> jnthn: You've written a parser, or no?

[13:32] <jnthn> Nom-: I didn't write a parser for the JVM port, no.

[13:32] <jnthn> Nom-: I implemented regex/grammar compilation and the various other bits of infrastructure so that I could cross-compile the existing parser.

[13:33] *** kaare_ joined
[13:33] <dalek> nqp/jvm-support: 613ccd6 | jnthn++ | src/vm/jvm/stage0/ (10 files):

[13:33] <dalek> nqp/jvm-support: Update stage0 to get sep-comp fixes.

[13:33] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/613ccd69c9

[13:33] <dalek> nqp/jvm-support: a550ae8 | jnthn++ | / (8 files):

[13:33] <dalek> nqp/jvm-support: Bring in the various sep-comp fixes.

[13:33] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/a550ae8537

[13:33] <dalek> nqp/jvm-support: 08c8cb5 | jnthn++ | / (2 files):

[13:33] <dalek> nqp/jvm-support: Final tweaks to get a working stage1.

[13:33] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/08c8cb5985

[13:33] <jnthn> Nom-: The overall flow is source code => AST => code for the target VM

[13:34] <jnthn> Nom-: You don't need to re-write the source code => AST bit.

[13:34] <pmichaud> (You probably don't want to re-write the source code => AST bit :)

[13:34] <jnthn> :D

[13:34] <Nom-> Ok

[13:35] <dalek> ecosystem: 619f286 | colomon++ | META.list:

[13:35] <dalek> ecosystem: Switch Template6 and XML back to supernovus++

[13:35] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/619f286f70

[13:35] <Nom-> So ultimately you need parrot in order to build anything then?

[13:35] <Nom-> hmmmm i take that back.. i still don't understand this code et

[13:35] <Nom-> *yet

[13:36] <jnthn> Nom-: You need an existing NQP implementation while you build up your cross-compiler/runtime support, yes.

[13:36] <jnthn> Nom-: Then once you have that, you use it to compile NQP itself.

[13:36] <jnthn> Nom-: That gives you an NQP that is independent of Parrot.

[13:36] <Nom-> Ok, that's making more sense to me 

[13:36] <jnthn> NQP on the JVM doesn't need Parrot at all by now.

[13:37] <moritz> so you can bootstrap your own NQP backend from the JVM?

[13:40] <jnthn> moritz: Yeah, you could use NQP on JVM as your starting point, though it's not so battle-hardened/convenient as the Parrot impl yet. I'm getting there with the build... :)

[13:45] <dalek> nqp/jvm-support: 04782d5 | jnthn++ | tools/build/Makefile-JVM.in:

[13:45] <dalek> nqp/jvm-support: Add stage2 build to Makefile.

[13:45] <dalek> nqp/jvm-support: 

[13:45] <dalek> nqp/jvm-support: Works.

[13:45] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/04782d59ce

[13:47] <pmichaud> "Works."  jnthn++

[13:47] <timotimo> my simple fix make tests fail, great >_<

[13:49] <jnthn> pmichaud: For convenience I'm wondering about having an nqp.bat / nqp.sh that fires off the JVM with the appropriate class path arguments. For the "make install", these could contain the paths we install to, menaing running NQP looks a lot like today, but relocation is just a matter of fixing up paths in a .bat/.sh file (meaning we should get a way to do the relocatable install...)

[13:49] *** cibs_ joined
[13:49] <jnthn> pmichaud: Does that sound sane? I basically suck at install related things :)

[13:50] <[Coke]> jnthn: will perl ConfigureJVM eventually be perl Configure --jvm ?

[13:50] <arnsholt> No boom? Cool!

[13:50] <jnthn> Oh, that's another good question :)

[13:51] <jnthn> [Coke]: I'm wondering if Configure.pl is just a facade and it delegates to ConfigureParrot/ConfigureJVM etc.

[13:51] <[Coke]> if not, we might want to make it configureJVM.java

[13:51] *** skids joined
[13:51] <jnthn> [Coke]: Passing all arguments along except the --jvm or --parrot one

[13:51] <[Coke]> no need to make the JVM port depend on perl5.

[13:52] <pmichaud> jnthn: I'm not sure that .bat/.sh is the way to go in the long run, but it certainly should work out for the time being.

[13:52] <jnthn> pmichaud: OK

[13:52] <arnsholt> How much configuring does ConfigureJVM do ATM?

[13:52] <pmichaud> I suspect the configure/build system will need some love after this, and that's okay.

[13:52] <jnthn> arnsholt: Little.

[13:53] *** crab2313 left
[13:53] <arnsholt> Yeah, that's what I thought

[13:53] <jnthn> pmichaud: Yeah. I don't feel like the right person to do it, but I know how your tuit supply is...

[13:53] <[Coke]> jnthn: I need to make the nqpjvm generated makefile -j safe.

[13:53] <jnthn> [Coke]: Hm, I thought I'd got he deps right, but maybe not

[13:53] <[Coke]> make -j3 failed pretty quick.

[13:53] <[Coke]> waiting to see if single threaded fails.

[13:54] <jnthn> [Coke]: OK. :)

[13:54] <arnsholt> For the time being, I'd argue that consolidating everything into Configure.pl is probably the best solution

[13:54] <[Coke]> jnthn++ # this is so exciting. ;)

[13:54] <arnsholt> But I think pmichaud is right that the build system will likely need some polish now that we have several backends

[13:54] <pmichaud> s/polish/refactoring/  # I suspect

[13:55] *** cibs joined
[13:55] *** cibs_ left
[13:56] <pmichaud> anyway, I'll be willing to do the configure/build stuff when I get the tuits, but I don't really know when that will be.  Until then we can go with "good enough to work" or hope that someone else comes along and does it.  :)

[13:57] <jnthn> +1

[13:57] <pmichaud> since I'm giving a talk on p6/jvm at yapc::na, it's likely I'll try to make sure something happens before then :)

[13:57] <[Coke]> jnthn: single threaded works. I'll see if I can get some tuits tonight.

[13:57] * [Coke] still hasn't decided if he's going. :(

[13:57] <jnthn> [Coke]: OK. I'm still Makefile hacking at the moment, so I may catch it

[13:57] <pmichaud> [Coke]: lots of us are going to be there.. might be worth the trip.  :)

[13:58] <jnthn> [Coke]: Even I will be at YAPC::NA this year, for the first time... :)

[13:58] <pmichaud> just look at the talk schedule and then figure out how you can justify not coming :) :)

[13:59] <[Coke]> pmichaud: the toughest part (aside from self funding) is that I do perl for fun, not for work.

[13:59] <[Coke]> well, not directly for work, anyway.

[14:01] <jnthn> [Coke]: ah, I think I may have spotted it....

[14:01] * colomon is still hoping to go...

[14:03] * [Coke] has an nqp.jar, and tries to figure out how to run it.

[14:04] *** cibs_ joined
[14:04] * [Coke] could use that .sh file. ;)

[14:04] <pmichaud> [Coke]: yeah, I hear ya.  The decision is made a lot easier for me this year since yapc::na is within driving distance.  If I was having to fly in, it'd be a much harder call for me to make.

[14:05] <pmichaud> [Coke]: maybe   java -jar nqp.jar

[14:05] <jnthn> [Coke]: Gimme a few moments...

[14:07] *** cibs left
[14:08] * pmichaud decides he can wait no longer and has to attempt the nqp-jvm build.

[14:08] <jnthn> C:\consulting\rakudo\nqp>nqp -e "say('OH YEAH')"

[14:08] <jnthn> OH YEAH

[14:08] <jnthn> pmichaud: 2 minutes, I'll push something to make that easier... :)

[14:09] *** cibs joined
[14:09] <dalek> nqp/jvm-support: c321800 | jnthn++ | tools/build/Makefile-JVM.in:

[14:09] <dalek> nqp/jvm-support: Various Makefile additions.

[14:09] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/c321800615

[14:09] <dalek> nqp/jvm-support: 459c817 | jnthn++ | .gitignore:

[14:09] <dalek> nqp/jvm-support: Update .gitignore.

[14:09] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/459c817ce2

[14:10] <[Coke]> if I go, it'll be to catch up with my sixies! . o O (we need a better word for this. ;)

[14:10] *** cibs_ left
[14:10] <jnthn> [Coke]: Hopefully that may fix -j3 

[14:10] <jnthn> [Coke]: Not that a bootstrapped build is very parallelizable...

[14:11] <moritz> can't you compile Actions.pm and Grammar.pm in parallel?

[14:12] <jnthn> moritz: In NQP they go all into a single NQP.pm anyway

[14:12] <jnthn> moritz: But even in Rakudo you can't as the grammar mentions Perl6::Actions 

[14:14] <PerlJam> [Coke]: you should go to YAPC::NA

[14:15] <pmichaud> PerlJam: you are going, yes?

[14:15] *** xilo joined
[14:15] <PerlJam> I'm planning on it, yes.

[14:16] <colomon> BTW, the URI module worked fine yesterday but is broken today.

[14:16] <colomon> might have been day before yesterday.

[14:16] * colomon needs to get automatic smoke testing running instead of doing it manually every few days....

[14:16] <PerlJam> (I haven't yet registered or gotten a hotel room, but I've still got over a month, right?  :)

[14:17] <timotimo> i'd like to cut up a string into substrings for 1st, nth, 2nth, 3nth char, 2nd, 1+nth, 1+2nth, ... char etc etc; i thought to use classify, but that won't work properly like "foo bar baz".comb.kv.classify({$_.key % 4}) or something similar. advice?

[14:17] *** woolfy left
[14:17] <moritz> timotimo: small example of what you want to achieve?

[14:19] <[Coke]> jnthn++ #makefile fixes.

[14:19] <jnthn> [Coke]: It worked?

[14:19] <[Coke]> pmichaud: the -jar complains, basically, that the jar isn't runnable.

[14:20] * colomon hopes PerlJam is right about registering, etc....

[14:20] <[Coke]> that is fixable (so we could have that automatically run some class)

[14:20] *** PacoAir joined
[14:20] <gtodd> are the updates to nqp (ie. those in nqp/jvm-support) that appear in the rakudo repo's nqp "submodule"  enough for someone to try getting nqp running on the jvm? ... with presumably some manual hacking in nqp/ somewhere

[14:20] <[Coke]> gtodd: that branch is working right now, I think.

[14:21] <[Coke]> check it out, "perl ConfigureJVM.pl", you get a .jar file. shortly you'll have a .sh script that runs the jar file for you.

[14:21] <[Coke]> jnthn: what's the class to run for the command line?

[14:21] <gtodd> ok great ... I didn't see anything after git pull so will dig around a bit

[14:22] <timotimo> moritz: vigenere breaking. "barbarbar" op 3 => "bbb", "aaa", "rrr"

[14:23] <gtodd> hmm I guess it's because I'm not on a branch ... still learning git :-)

[14:23] <[Coke]> jnthn: at the end, you're copying a lot of .class files (3x each) to the top dir?

[14:23] <[Coke]> gtodd: git checkout -b jvm-support remotes/origin/jvm-support

[14:23] <dalek> nqp/jvm-support: 6918dfd | jnthn++ | / (5 files):

[14:23] <dalek> nqp/jvm-support: Add convenience .bat/.sh to run NQP on JVM.

[14:23] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/6918dfd1a5

[14:23] <moritz> r: say 'barbarbar'.comb.classify({$_}).perl

[14:23] <camelia> rakudo f3c3fe: OUTPUT«("b" => ["b", "b", "b"], "a" => ["a", "a", "a"], "r" => ["r", "r", "r"]).hash␤»

[14:24] <jnthn> [Coke]: Yeah, I didn't figure out why on earth it copies them multiple times...

[14:24] <jnthn> The .sh there is untested; the .bat is known to work.

[14:24] <moritz> r: say 'barbarbar'.comb.classify({$_}).map({ .key => +.value }).perl

[14:24] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'Any'␤  in block  at /tmp/D9tPDJzNuF:1␤␤»

[14:24] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map({ .key => +.value }).perl

[14:24] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'Any'␤  in block  at /tmp/TyvKh2fBNy:1␤␤»

[14:24] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.perl

[14:24] <camelia> rakudo f3c3fe: OUTPUT«("b" => ["b", "b", "b"], "a" => ["a", "a", "a"], "r" => ["r", "r", "r"]).list␤»

[14:25] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value })

[14:25] <camelia> rakudo f3c3fe: OUTPUT«b 3 a     3 r     3␤»

[14:25] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value }).invert

[14:25] <camelia> rakudo f3c3fe: OUTPUT«No such method 'invert' for invocant of type 'List'␤  in block  at /tmp/swsAQvgvvD:1␤␤»

[14:25] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value }).classify: *.key

[14:25] <camelia> rakudo f3c3fe: OUTPUT«("b" => ["b" => 3], "a" => ["a" => 3], "r" => ["r" => 3]).hash␤»

[14:25] <moritz> meh

[14:26] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value }).perl

[14:26] <camelia> rakudo f3c3fe: OUTPUT«("b" => 3, "a" => 3, "r" => 3).list␤»

[14:26] <moritz> r: say 'barbarbar'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value }).hash.invert.perl

[14:26] <camelia> rakudo f3c3fe: OUTPUT«(3 => "b", 3 => "a", 3 => "r").list␤»

[14:26] <moritz> timotimo: close enough? :-)

[14:26] <timotimo> oh, you already count the occurences?

[14:26] <gtodd> [Coke]: thanks

[14:26] <moritz> timotimo: yes

[14:27] <moritz> r: say 'barbarossa'.comb.classify({$_}).pairs.map(-> $p { $p.key => +$p.value }).hash.invert.perl

[14:27] <camelia> rakudo f3c3fe: OUTPUT«(2 => "b", 3 => "a", 2 => "r", 1 => "o", 2 => "s").list␤»

[14:27] <timotimo> neat. now let me try to understand it :D

[14:27] <colomon> r: say bag 'barbarbar'.comb;

[14:27] <camelia> rakudo f3c3fe: OUTPUT«bag("b" => 3, "a" => 3, "r" => 3)␤»

[14:27] <timotimo> i don't see where it gets sliced, though

[14:27] <moritz> ooh, colomon++

[14:27] <moritz> timotimo: .comb slices it in characters

[14:27] <colomon> bag: it's handy.  ;)

[14:27] <moritz> aye.

[14:28] <timotimo> i have to run now, but i'll explain better what i meant when i get back on the puter

[14:28] <colomon> rn: say 'barbarbar'.comb.bag

[14:28] <camelia> rakudo f3c3fe, niecza v24-37-gf9c8fc2: OUTPUT«bag("b" => 3, "a" => 3, "r" => 3)␤»

[14:29] <[Coke]> jnthn: it works. could use a chmod +x

[14:29] <[Coke]> jnthn++

[14:29] * moritz guesses that timotimo actually wants slicings of different lengths

[14:29] <[Coke]> gtodd: now when you build, you can do:

[14:29] <[Coke]> sh src/vm/jvm/nqp.sh -e "say(3)"

[14:29] <[Coke]> 3

[14:30] <pmichaud> pmichaud@kiwi:~/p6/nqp-jvm$ ./nqp.sh -e "say(3)"

[14:30] <pmichaud> 3

[14:30] <pmichaud> \o/

[14:30] <jnthn> [Coke]: Hm, I put the chmod +x in the Makefile, I thought.

[14:30] <pmichaud> no REPL?

[14:31] <[Coke]> (oh, does it install it? I just ran it directly without rebuilding)

[14:31] <[Coke]> jnthn: never mind. ;)

[14:31] <pmichaud> my nqp.sh is chmod +x already

[14:31] <jnthn> pmichaud: Didn't figure out why the REPL ain't quite working yet.

[14:31] <[Coke]> looks like parrot is winning on startuptime, but we knew that.

[14:31] <jnthn> pmichaud: Probably because I didn't properly implement fhreadline or so :)

[14:31] <pmichaud> something like that, probably.

[14:31] <pmichaud> probably won't be long to fix :)

[14:31] *** fgomez joined
[14:31] <jnthn> No...I've mostly focused on "critical path to bootstrap"

[14:32] <pmichaud> pmichaud@kiwi:~/p6/nqp-jvm$ make test

[14:32] <pmichaud> make: *** No rule to make target `test'.  Stop.

[14:32] <pmichaud> :-(

[14:32] <jnthn> pmichaud: Yes, got that locally :)

[14:33] <Nom-> jnthn: I feel like I'm missing an entire section of code on how you get from nothing to what's in the nqp repo... do I need to look at your other repo?

[14:34] <Nom-> Like I see all the code which parses these JAST statements, but I can't *yet* see what's generating them

[14:34] *** PacoAir left
[14:35] *** PacoAir joined
[14:37] <jnthn> Nom-: In the nqp repo (provided you're in jvm-support branch) it lives in src/vm/jvm/QAST/JASTNodes.nqp

[14:40] <alester> ack2 is out!  Whee!

[14:41] <pmichaud> https://gist.github.com/pmichaud/5413260 # lots of passing tests

[14:42] <pmichaud> alester++ # ack2

[14:42] <jnthn> pmichaud: Matches what I have here, yeah. 

[14:42] *** kaleem left
[14:42] <moritz> alester++

[14:42] <jnthn> pmichaud: deletepos is just an NYI, 24-modules.t is a but I need to hunt and squish. :)

[14:42] <pmichaud> jnthn: that's.... impressive.  Beyond impressive.

[14:42] <jnthn> *bug

[14:43] <moritz> alester: did you release it, or did it escape? :-)

[14:43] <pmichaud> I have to go do house-y things for a while... bbl

[14:43] <jnthn> o/

[14:44] *** frdmn left
[14:44] <colomon> well, in the module smoke test, things got better because of Template6 and XML, and worse because a ton of modules depend on URI.  :(

[14:47] <timotimo> moritz: i wanted to turn "abcdef" into "ace" and "bdf" when i supply 2 or "ad" "be" "cf" when i supply 3

[14:48] *** fgomez left
[14:49] <timotimo> the "barbarbar" example was dumb, because all the same letters ended up in the same string each.

[14:50] <colomon> r: say "abcdef".comb.kv.perl

[14:50] <camelia> rakudo f3c3fe: OUTPUT«((0, "a"), (1, "b"), (2, "c"), (3, "d"), (4, "e"), (5, "f")).list␤»

[14:50] <moritz> that's what we do with unpack in p5

[14:50] <timotimo> i got that far, but classify seems to break that

[14:50] <moritz> .comb breaks it

[14:51] <timotimo> oh, maybe i have to .lol.classify?

[14:51] <moritz> p5eval: [unpack '(A3)', 'barbarossa']

[14:51] <p5eval> moritz: ["bar"]

[14:51] <moritz> p5eval: [unpack '(A3)*', 'barbarossa']

[14:51] <p5eval> moritz: ["bar","bar","oss","a"]

[14:51] <colomon> r: say "abcdef".comb.kv.classify({ $_.key % 3 })

[14:51] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'Int'␤  in block  at /tmp/11ad1C8sIe:1␤␤»

[14:51] <moritz> camelia: .comb.pairs

[14:51] <moritz> erm, meant colomon 

[14:51] <timotimo> r: say "abcdef".comb.kv.lol.classify({ $_.key % 3 })

[14:51] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'ListIter'␤  in block  at /tmp/7S5lUtO7yX:1␤␤»

[14:52] <colomon> r: say "abcdef".comb.pairs.classify({ $_.key % 3 })

[14:52] <camelia> rakudo f3c3fe: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/iRkDrcxwwF:1␤------> say "abcdef".comb.pairs.cl⏏assify({ $_.key % 3 })␤    expecting any of:␤        method arguments␤        postfix␤        infix stopper␤        infix or meta-infix␤   …

[14:52] <timotimo> r: say "abcdef".comb.kv.lol.classify({ $_[0].key % 3 })

[14:52] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'ListIter'␤  in block  at /tmp/0pEFNm9PUV:1␤␤»

[14:52] <timotimo> r: say "abcdef".comb.kv.lol.classify({ $_[0] % 3 })

[14:52] <camelia> rakudo f3c3fe: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Real at src/gen/CORE.setting:870␤  in sub infix:<%> at src/gen/CORE.setting:2977␤  in sub infix:<%> at src/gen/CORE.setting:2974␤  in block  at /tmp/y6_6hTMd5M:1␤␤»

[14:52] <moritz> r: say "abcdef".comb.pairs.classify({ $_.key % 3 })

[14:52] <camelia> rakudo f3c3fe: OUTPUT«("0" => [0 => "a", 3 => "d"], "1" => [1 => "b", 4 => "e"], "2" => [2 => "c", 5 => "f"]).hash␤»

[14:53] <PerlJam> is this some kind of golf?

[14:53] <colomon> PerlJam: collaborative problem solving.

[14:54] <timotimo> ah, .pairs seems better

[14:54] <dalek> nqp/jvm-support: c422bb3 | jnthn++ | src/vm/jvm/QAST/JASTNodes.nqp:

[14:54] <dalek> nqp/jvm-support: Add forgotten JAST node construction opt.

[14:54] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/c422bb33b0

[14:54] <dalek> nqp/jvm-support: 0397e83 | jnthn++ | / (2 files):

[14:54] <dalek> nqp/jvm-support: Add testing targets.

[14:54] <dalek> nqp/jvm-support: 

[14:54] <dalek> nqp/jvm-support: Will need some triage.

[14:54] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/0397e83fad

[14:54] <moritz> r: sub splitchars($str, $chars) { gather for (0, *+$chars ...^ *>$str.chars) { $str.substr($_, $chars) } }; say splitchars('barbarossa', 3)

[14:54] <timotimo> i think i'll use something very much like classify, but for lists instead. that way i can just >>.value afterwards

[14:54] <camelia> rakudo f3c3fe: OUTPUT«␤»

[14:55] <moritz> r: sub splitchars($str, $chars) { gather for (0, *+$chars ...^ *>$str.chars) { take $str.substr($_, $chars) } }; say splitchars('barbarossa', 3)

[14:55] <camelia> rakudo f3c3fe: OUTPUT«bar bar oss a␤»

[14:55] <moritz> r: sub splitchars($str, $chars) { gather for (0, *+$chars ...^ *>$str.chars) { take $str.substr($_, $chars) } }; say splitchars('barbarossa', 3).classify({$_}).perl

[14:55] <camelia> rakudo f3c3fe: OUTPUT«("bar" => ["bar", "bar"], "oss" => ["oss"], "a" => ["a"]).hash␤»

[14:55] <moritz> r: sub splitchars($str, $chars) { gather for (0, *+$chars ...^ *>$str.chars) { take $str.substr($_, $chars) } }; say splitchars('barbarossa', 3).classify({$_}).pairs.map({ .key => +.value }).perl

[14:55] <camelia> rakudo f3c3fe: OUTPUT«No such method 'key' for invocant of type 'Any'␤  in block  at /tmp/MNnsf9Q1AM:1␤␤»

[14:56] <moritz> r: sub splitchars($str, $chars) { gather for (0, *+$chars ...^ *>$str.chars) { take $str.substr($_, $chars) } }; say splitchars('barbarossa', 3).classify({$_}).pairs.map({; .key => +.value }).perl

[14:56] <camelia> rakudo f3c3fe: OUTPUT«("bar" => 2, "oss" => 1, "a" => 1).list␤»

[14:56] <moritz> timotimo: like this?

[14:56] <timotimo> i'm not sure we're on the same page

[14:56] * moritz neither

[14:56] <timotimo> i'd like "barbarossa" to turn into "bboa", "aas", "rrs"

[14:56] <timotimo> each string only has every 3rd character

[14:56] <moritz> ah

[14:57] * timotimo fails epically at communicating today

[14:57] <spider-mario> r: ([Z~] 'barbarossa'.comb(/.**3/).map: {[.comb]}).perl

[14:57] <camelia> rakudo f3c3fe:  ( no output )

[14:57] <spider-mario> r: ([Z~] 'barbarossa'.comb(/.**3/).map: {[.comb]}).perl.say

[14:57] <camelia> rakudo f3c3fe: OUTPUT«("bbo", "aas", "rrs").list␤»

[14:57] <moritz> then I'm totally on the wrong track

[14:57] <PerlJam> timotimo: so,  foo("abcdefg",3), you'd want "adg", "be", "cf"  (assuming foo does whatever you wanted) >

[14:57] <PerlJam> er ?

[14:57] <moritz> spider-mario: swallows the last letter

[14:57] <spider-mario> I’m having trouble trying to interpolate a variable to replace the hard-coded 3 in the regexp

[14:57] <timotimo> yes, PerlJam 

[14:58] <timotimo> use eval to create the regexp :D

[14:58] <colomon> moritz: why?  seems like it's just a matter of transforming ("0" => [0 => "a", 3 => "d"], "1" => [1 => "b", 4 => "e"], "2" => [2 => "c", 5 => "f"]) into a series of strings.  Might not be the best golfed method, but will definitely work...

[14:59] <colomon> r: ([Z~] 'barbarossa'.comb(/.**1..3/).map: {[.comb]}).perl.say

[14:59] <camelia> rakudo f3c3fe: OUTPUT«("bboa",).list␤»

[14:59] *** kaleem joined
[14:59] <moritz> r: sub slice($str, $chars) { (^$chars).map: -> $m { $chars.comb.pairs.grep(*.key %% $chars == $m)>>.value.join } }

[14:59] <camelia> rakudo f3c3fe:  ( no output )

[14:59] <moritz> r: sub slice($str, $chars) { (^$chars).map: -> $m { $chars.comb.pairs.grep(*.key %% $chars == $m)>>.value.join } }; say slice 'barbarossa', 3

[14:59] <camelia> rakudo f3c3fe: OUTPUT« 3 ␤»

[15:00] <moritz> r: sub slice($str, $chars) { (^$chars).map: -> $m { $chars.comb.pairs.grep(*.key % $chars == $m)>>.value.join } }; say slice 'barbarossa', 3

[15:00] <camelia> rakudo f3c3fe: OUTPUT«3  ␤»

[15:00] <timotimo> you are combing chars

[15:00] <colomon> on URI failure: it looks like require %rfc_grammar_build{$rfc} is now doing require %rfc_grammar_build  ??

[15:00] <timotimo> comb $str instead

[15:00] <moritz> r: sub slice($str, $chars) { (^$chars).map: -> $m { $str.comb.pairs.grep(*.key % $chars == $m)>>.value.join } }; say slice 'barbarossa', 3

[15:00] <camelia> rakudo f3c3fe: OUTPUT«bboa aas rrs␤»

[15:00] <moritz> \o/

[15:00] <timotimo> neat!

[15:00] <moritz> timotimo: thanks

[15:01] <timotimo> still looks a bit ... bewildering :))

[15:01] <timotimo> but i still like it

[15:01] <timotimo> thank you!

[15:01] <moritz> well, it's a desperat-ish attempt to fit it all into a single expression

[15:01] *** kbenson joined
[15:01] <PerlJam> timotimo: that's why I asked about golf.  I would have done it a little more verbosely  :)

[15:02] <timotimo> right.

[15:02] <kresike> bye folks

[15:02] *** kresike left
[15:02] <PerlJam> moritz++ that's a nice solution though.

[15:02] <alester> moritz: I shoved it out because I knew if I didn't I never would. 

[15:03] <moritz> .oO( it wasn't released, it was rejected from dev )

[15:04] <dalek> nqp/jvm-support: 635e421 | jnthn++ | / (20 files):

[15:04] <dalek> nqp/jvm-support: Add bootstrap-files target; clean up.

[15:04] <dalek> nqp/jvm-support: 

[15:04] <dalek> nqp/jvm-support: The file names used for modules in the stage0 from nqp-jvm-prep were

[15:04] <dalek> nqp/jvm-support: not the same as those produced by the build; this gets things to be

[15:04] <dalek> nqp/jvm-support: consistent. Updates the bootstrap as part of doing so.

[15:04] <dalek> nqp/jvm-support: review: https://github.com/perl6/nqp/commit/635e421d36

[15:06] *** kaleem left
[15:10] <alester> moritz: I was tired of waiting on getting all the ducks in a row, mostly docs.  i just had to push it out and deal with docs after the fact.

[15:13] <moritz> alester: I think it's a good move

[15:16] *** kaleem joined
[15:16] *** sqirrel joined
[15:17] <timotimo> er, may i ask what alester has done?

[15:17] <alester> moritz: Thanks.  I'll make an announcement later in the day but right now I have work to do

[15:17] <alester> timotimo: Released ack 2.00 

[15:17] <alester> http://beyondgrep.com/ack20/

[15:18] <timotimo> oh! neat :)

[15:21] *** isBEKaml joined
[15:22] <PerlJam> alester: for me, the change in default search behavior will have the most impact.  I used -a all the time in ack1

[15:23] <alester> You and everyone else, PerlJam.  We just had to add other stuff to take into account those who rely on that old behavior.

[15:23] <alester> -k/--known-types puts you back to the ack 1.x behavior.

[15:24] *** domidumont left
[15:24] <gtodd> ack = killer app :-) 

[15:25] <gtodd> beyond its obvious reference, if I recall correctly, ack was the main spoken word of the bulbous green headed invaders in "Mars Attacks"

[15:27] *** brrt left
[15:30] * moritz thought they said something "nag nag" or "nack nack"

[15:30] <ggoebel> jnthn++

[15:31] <ggoebel> looking forward to the blog post on the jvm nqp bootstrap being merged 

[15:32] *** supernovus joined
[15:33] <supernovus> ping colomon

[15:33] <yoleaux> 16 Apr 2013 23:06Z <raiph> supernovus: i didn't see llamarider commit any TZ changes

[15:34] <[Coke]> r: for 1..2 -> $ack { say "alester++ # ack $ack" }

[15:34] <camelia> rakudo f3c3fe: OUTPUT«alester++ # ack 1␤alester++ # ack 2␤»

[15:36] <isBEKaml> r: 0 ...^ *>5  # that's what S02 says, but times out

[15:36] <isBEKaml> should that be <= or some such?

[15:36] <camelia> rakudo f3c3fe: OUTPUT«(timeout)»

[15:36] <isBEKaml> r: say 0 ... ^* <= 5

[15:36] <camelia> rakudo f3c3fe: OUTPUT«0␤»

[15:36] <isBEKaml> r: say 0 ... ^ <= 5

[15:36] <camelia> rakudo f3c3fe: OUTPUT«===SORRY!===␤Unable to parse expression in quote words; couldn't find final '>'␤at /tmp/_cXE889ZqZ:1␤------> say 0 ... ^ <= 5⏏<EOL>␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        …

[15:37] <timotimo> where would i get a value that makes sense in the same context as enum_class_ResizablePMCArray for a "custom" PMC? (qrpa in this case)

[15:37] <timotimo> something like Parrot_pmc_get_type_str(interp, Parrot_str_new(interp, "QRPA", 0));?

[15:38] *** simcop2387 joined
[15:38] *** FROGGS left
[15:38] <jnthn> timotimo: search for qrpa in perl6.ops; I think we have something in there for it.

[15:39] <timotimo> oh, yes nideed

[15:39] <timotimo> thank you :)

[15:42] <[Coke]> r: print "\x0B HI \x0B"

[15:42] <isBEKaml> r: say 0 ... ^*< 5

[15:42] <camelia> rakudo f3c3fe: OUTPUT« HI »

[15:42] <camelia> rakudo f3c3fe: OUTPUT«===SORRY!===␤Whitespace required before < operator␤at /tmp/v9wrTuM3aZ:1␤------> say 0 ... ^*< 5⏏<EOL>␤    expecting any of:␤        postfix␤»

[15:42] <timotimo> i'm starting small replacing ReziablePMCArray with qrpa_id and see when it breaks

[15:42] <isBEKaml> ^^ bug?

[15:42] <[Coke]> std: say 0 ... ^*< 5

[15:42] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Whitespace required before < operator at /tmp/TgSgZGq7wt line 1:␤------> say 0 ... ^*<⏏ 5␤    expecting escape␤Parse failed␤FAILED 00:00 42m␤»

[15:43] <[Coke]> probably not.

[15:43] <isBEKaml> std: say 0 ... ^*> 5

[15:43] <camelia> std 86b102f: OUTPUT«ok 00:00 42m␤»

[15:43] <isBEKaml> [Coke]: that. 

[15:44] <isBEKaml> This is from S02:1175

[15:44] <isBEKaml> This is from S02:1176

[15:44] <isBEKaml> r: say 0 ... ^* < 5

[15:44] <camelia> rakudo f3c3fe: OUTPUT«0␤»

[15:48] *** sqirrel left
[15:54] *** thou joined
[15:55] <colomon> supernovus: pong

[15:56] <supernovus> colomon: Thanks for the bug fixes on Template6 and XML, even if I messed up the XML one by updating it before I noticed there was a pull request. My bad. :P

[15:56] <colomon> isBEKaml: you can't put a space between the ... and the ^

[15:56] <colomon> supernovus: you're welcome.  I've been trying to get more of the modules working, and these things are really LHF

[15:59] <supernovus> I'm currently mucking with XML::Query to get it back into working order. It seems to have been affected by the change in how protos work.

[16:01] *** FROGGS joined
[16:04] <isBEKaml> colomon: sure, but that's not what the error message says? It seems to carp over the lack of space between * and < 

[16:06] <masak> oh hai, #perl6

[16:06] <isBEKaml> hello, masak

[16:07] <supernovus> Gah, this is some messed up stuff. "You cannot create an instance of this type". What kind of error message is that?

[16:07] <jnthn> An accurate one?

[16:07] <isBEKaml> supernovus: well, that's clear. :P

[16:07] <jnthn> Not all types can be instantiated.

[16:08] <jnthn> Granted it should probably metion the type name.

[16:08] <supernovus> Apparently XML::Query (a class) is no longer able to be instantiated... oO

[16:11] <supernovus> The weirdest part is, the tests work fine if the module is loaded from a .pm6 but fail if the module is loaded from a .pir file...

[16:13] <jnthn> Ugh. :/

[16:13] <jnthn> Not another one of those bloody problems.

[16:13] *** crab2313 joined
[16:13] <isBEKaml> precompilation? 

[16:13] <jnthn> Sounds like

[16:14] <jnthn> Well, hopefully it's the same as the not_gerd one I've got outstanding to look at.

[16:15] <supernovus> With precompiled modules, if I use one of the overridden new() methods, I get an error of "Default constructor for 'Query' only takes named arguments" and if I use the default new(), I get the "cannot create an instance" error. If I force it to load non-precompiled modules, there are no errors.

[16:15] <colomon> isBEKaml: *< may well be illegal as well.

[16:15] <colomon> std: *<

[16:15] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Unable to parse quote-words subscript; couldn't find right angle quote at /tmp/hexIN8CQft line 1:␤------> *<⏏<EOL>␤    expecting escape␤Parse failed␤FAILED 00:00 41m␤»

[16:15] <jnthn> supernovus: It tends to happen in certain icky arrangements of nested packages.

[16:16] <colomon> std: 1 *< 2

[16:16] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Unable to parse quote words at /tmp/sj6t7ne352 line 1:␤------> 1 *⏏< 2␤Couldn't find final '>'; gave up at /tmp/sj6t7ne352 line 1 (EOF):␤------> 1 *< 2⏏<EOL>␤Parse failed␤FAILED 00:00 42m␤»…

[16:16] <colomon> std: 1 ^*< 2

[16:16] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Whitespace required before < operator at /tmp/defmKMx7xW line 1:␤------> 1 ^*<⏏ 2␤    expecting escape␤Parse failed␤FAILED 00:00 42m␤»

[16:16] <colomon> okay, that's kind of weird 

[16:16] <isBEKaml> std: 0 ...^ *> 5 # is this a different case?

[16:16] <camelia> std 86b102f: OUTPUT«ok 00:00 42m␤»

[16:17] <isBEKaml> std: 0 ...^ *< 5 # this is weird. 

[16:17] <camelia> std 86b102f: OUTPUT«===SORRY!===␤Whitespace required before < operator at /tmp/3XRloPfE95 line 1:␤------> 0 ...^ *<⏏ 5 # this is weird.␤    expecting escape␤Parse failed␤FAILED 00:00 42m␤»

[16:17] <supernovus> jnthn: Well, I'll leave it alone for now, as I don't actually use XML::Query in any of my other projects.

[16:20] <jnthn> supernovus: Yeah. I'll get to it eventually. Such precomp bugs tend to be time consuming to hunt down, and that chunk of Rakudo has a bus number of 1 (me)...

[16:20] *** frdmn joined
[16:24] *** isBEKaml left
[16:28] *** Nom- left
[16:29] *** Nom- joined
[16:31] *** kaleem_ joined
[16:34] *** kaleem left
[16:37] <jnthn> At long last, I blogged: http://6guts.wordpress.com/2013/04/18/nqp-on-jvm-bootstrapped-soon-will-land-in-nqp-master/

[16:38] *** tgt left
[16:40] *** markov left
[16:40] *** markov joined
[16:42] <jnthn> afk for a bit

[16:52] <masak> jnthn++ # blug

[16:55] <colomon> jnthn++ # blug indeed!

[16:55] *** shinobicl joined
[16:55] *** supernovus left
[16:56] <daxim> keyboards and terminal applications are weird.  I press a keycap that triggers a switch that closes a circuit which is interpreted by a controller which transmits packets on the serial bus which has a hardware driver in the kernel which provides a scancode which is mapped by X to a keycode which is mapped by Xkb to a symbol which is mapped by Konsole to a vt escape sequence which is looked up by terminfo in some fashion *mumble* and finally 

[16:56] <daxim> is interpreted by Konsole again to cause a action, such as scrolling up one page

[16:56] <daxim> I don't quite understand what the decoupling at the terminfo step is good for, will someone educate me?

[17:00] *** salv0 joined
[17:06] *** isBEKaml joined
[17:09] *** dakkar left
[17:14] <ggoebel> jnthn++

[17:15] <geekosaur> daxim, while there is an ANSI standard for terminals now, originally there wasn't and terminfo was needed to deal with several hundred different kinds of terminals

[17:15] *** domidumont joined
[17:15] <dalek> roast: eba6362 | coke++ | S32-temporal/calendar.t:

[17:15] <dalek> roast: directly test .gist instead of going through say

[17:15] <dalek> roast: review: https://github.com/perl6/roast/commit/eba63623a7

[17:16] <geekosaur> also, that standard is (as a standard) somewhat limited and every termina/emulator has its own extensions, which often are intended to be compatible with others but sometimes have bugs...

[17:17] <geekosaur> terminfo means every program doesn't have to know exactly what function key escapes *this* terminal emulator supports and what the idiosyncrasies in its line wrap are

[17:17] <geekosaur> (since almost nobody gets the original vt100 algorithm right...)

[17:18] <geekosaur> (but xterm does...)

[17:18] <geekosaur> (and there are programs that Know That)

[17:19] *** isBEKaml left
[17:19] *** thou left
[17:25] *** tgt joined
[17:32] <PerlJam> jnthn: you realize it will be about 9 months between jvm-prep creation and merge into nqp repo?   Aside from being approximately the same gestation period as a human  :), that's a fairly amazing turn-around time.

[17:32] <PerlJam> jnthn++

[17:34] *** crab2313 left
[17:35] *** daxim left
[17:35] * masak .oO( did PerlJam just call jnthn fat? ) :P

[17:42] *** japhb_ joined
[17:45] <dalek> perl6-roast-data: 572d72e | coke++ | / (4 files):

[17:45] <dalek> perl6-roast-data: today (automated commit)

[17:45] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/572d72e97e

[17:48] <[Coke]> sorear: how would feel about nqp-mono ?

[17:52] <[Coke]> how are we going to deal with fudging once there are 2 rakudos? 

[17:54] <[Coke]> #?rakudo-jvm skip vs #?rakudo(-parrot)?         #?rakudo skip 'description' -jvm-only

[17:55] *** pupoque joined
[17:56] <[Coke]> (I'm leaning towards the latter - make fudge smart enough to deal with tags, then we can skip across the board (feature not even implemented), or for a particular variant (subtle bug on jvm version)

[18:08] <pmichaud> iirc, fudge was designed so that you could activate multiple tags

[18:09] <pmichaud> so it should be possible to do  #?rakudo   #?rakudo-jvm  and #?rakudo-parrot

[18:09] <pmichaud> when running tests for #?rakudo-parrot, it would activate those fudges marked #?rakudo and #?rakudo-parrot

[18:09] <japhb_> [Coke], I like that concept (though '-jvm-only' as an exact syntax is a tad limiting, if and when we get to 3 backend VMs) ... certainly we should put very gentle pressure on to keep Rakudo mostly self-compatible

[18:10] <pmichaud> checking

[18:10] <japhb_> Ah, pmichaud responded while I was distracted

[18:12] <pmichaud> oops, looks like fudgeall and fudge only handle one impl.

[18:12] <pmichaud> anyway, I'd be in favor of generalizing fudge/fudgeall to accept multiple impl specifiers on their command lines

[18:15] <jnthn> Sounds sane.

[18:15] <pmichaud> or, for real ickiness, treat whatever follows #? as a regex to be matched  :-P

[18:16] <pmichaud> then you could have   #?rakudoparrot, #?rakudojvm, and #?rakudo.*

[18:16] *** DreamingInCode joined
[18:16] <Tene> pmichaud: ITYM as a dns TXT record holding a regex

[18:16] <jnthn> I agree we should be aiming for mostly self-compatible; I'm also aware that as we work backends towards that the spectests that are passing could be valuable.

[18:17] <jnthn> (For knowing we aren't taking steps back as well as steps forward.)

[18:17] <diakopter> (that would hurt?)

[18:18] <pmichaud> I kind of like the regex approach, now that I think about it.

[18:18] <jnthn> pmichaud: It's evil :)

[18:18] <jnthn> pmichaud: But maybe good evil :D

[18:18] <pmichaud> #?rakudo(parrot|mono) skip "but it works on rakudojvm"

[18:19] <pmichaud> #?rakudo(?!jvm) skip "every platform but jvm"

[18:19] <FROGGS> #?rakudo(.+o.+) skip "but it works on rakudojvm"

[18:19] <FROGGS> :o)

[18:20] <[Coke]> pmichaud: +1 from me.

[18:20] <[Coke]> FROGGS: I will remove your commit access. :P

[18:20] <FROGGS> hehe

[18:20] <FROGGS> but ya, feels sane

[18:20] <FROGGS> (both the pattern and removing my commit access :P)

[18:21] <[Coke]> I would make it end with an implicit .*

[18:22] <pmichaud> might want to be sure to use the hyphen, then -- i.e.,   #?rakudo   #?rakudo-parrot   and #?rakudo-jvm

[18:22] <pmichaud> the hyphen makes a good separator

[18:22] <[Coke]> so that you can say #?rakudo and have it mean all rakudoshudo.

[18:22] <pmichaud> exactly.

[18:24] <pmichaud> looks like fudge:134 is the section that wants changing to use a regex match instead of eq

[18:28] *** Psyche^ joined
[18:28] *** Psyche^ is now known as Patterner

[18:32] <masak> today's autopun: "As I understand it, the claim is that the less you use Homeopathy, the better it works. Sounds plausible to me."

[18:32] <masak> -- David Deutsch

[18:32] <cognominal> jnthn++ # great blogging

[18:33] <timotimo> hehe.

[18:43] * pmichaud tweets.

[18:43] * moritz checks planetsix

[18:46] <moritz> jnthn++ # very nice blog post, and even better news :-)=

[18:47] <timotimo> so, uh ... perl6 sockets ... what blocks us?

[18:47] <timotimo> why are there dragons there in the spec?

[18:48] <moritz> because the spec hasn't been undragonified yet

[18:48] <timotimo> hm.

[18:50] <moritz> basically the old version of the IO spec contained so much bs, that I declared all the parts that I hadn't sanitized as "here be dragons"

[18:50] <jnthn> .oO( I'm thinking he's not talking about bounded serialization... )

[18:51] <moritz> if you review it, and find it to be sane, and loosly matches what's implemented, feel free to remove (or move) that marker

[18:51] <masak> moritz++ # dragon slayer

[18:55] <timotimo> well, there's not much in it yet. a readline method for instance would be neat

[18:56] <moritz> readline is called get

[18:56] <timotimo> oh, that's nice :)

[18:56] <timotimo> it would be good to have the spec say if the line terminators are returned, too

[18:57] <timotimo> No such method 'get' for invocant of type 'IO::Socket' - it's called get, but it isn't there yet :(

[18:57] <moritz> IO::Socket::INET has a method get

[18:58] <moritz> and I'm sure it can't be too broken, because Net::IRC::Bot and thus ilbot6 use it

[18:59] <timotimo> oooh, i need ::INET, duh

[19:09] *** SamuraiJack_ joined
[19:09] <timotimo> could it be that get stops too early?

[19:12] *** raiph joined
[19:12] *** SamuraiJack left
[19:14] *** SamuraiJack_ left
[19:17] *** lizmat joined
[19:18] <timotimo> it seems get stops before a newline actually happens, which is very unfortunate. my very own get implementation is so slow, that my client gets shot down by the server before it can even finish reading the message

[19:19] *** domidumont left
[19:20] *** frdmn left
[19:20] *** frdmn joined
[19:21] *** frd|afk joined
[19:23] <lizmat> hello #perl6 from the evening before the DPW

[19:23] <masak> hello lizmat

[19:25] * moritz idly wonders if lizmat strives for a world record in attending Perl conferences and workshops

[19:25] *** frdmn left
[19:25] <lizmat> not really, as we will miss the French Perl workshop this year

[19:25] <lizmat> :-)

[19:26] <moritz> :-)

[19:26] <moritz> I guess D is Dutch here?

[19:26] <lizmat> still, Perl Oasis, FOSDEM, Israeli PW, GPW, SPW, QA Hackathon, DPW, PLPW, YAPC::NA, OSCON, YAPC::EU, YAPC::Asia, LPW

[19:27] <lizmat> is the planning so far

[19:27] <lizmat> yes

[19:27] *** berekuk joined
[19:27] <lizmat> I think rafl did more last year

[19:28] <lizmat> oh, and the monthly NL.pm and Niederrhein.pm meetings :-)

[19:28] <cognominal> Perl Oasis?

[19:29] <lizmat> Florida Perl Workshop

[19:29] <cognominal> in Dubai? :)

[19:29] <lizmat> in Orlando

[19:29] <cognominal> we will miss you at fpw

[19:30] <lizmat> yes, but it is wedged between YAPC::NA and OSCON

[19:30] <rafl> Pretty sure I did fewer conferences than that last year

[19:31] <rafl> The most YAPCs a year record is all mine, though, I believe ;-) 

[19:32] *** kaleem_ left
[19:33] *** jdv79 joined
[19:33] <jdv79> jnthn: saw your update re nqp on jvm - nice

[19:34] <lizmat> argh, much less wedged than I thought

[19:35] <lizmat> suddenly the chance that we'll be at the FPW has significantly increased

[19:35] <timotimo> do i talk to the parrot people about this?

[19:37] <moritz> timotimo: make sure to try on a recent parrot first

[19:37] <timotimo> 5.2.0-devel, i'll retry with 5.3.0 now.

[19:39] *** ggoebel joined
[19:41] <jnthn> jdv79: Yes, things are moving along :)

[19:41] *** labster joined
[19:41] <timotimo> couldn't build a parrot from master, though

[19:44] <timotimo> what? ./include/parrot/platform_interface.h:212:59: error: expected declaration specifiers or ‘...’ before ‘Parrot_Stat_Buf’

[19:44] <timotimo> for the latest RELEASE as well as master

[19:46] <timotimo> oh, i accidentally pasted something in there and it didn't get cleaned or re-made

[19:56] <tadzik> good evening #perl6

[19:57] <lizmat> evening tadzik!

[19:58] <jnthn> o/ tadzik 

[19:58] <japhb_> o/

[19:58] <tadzik> colomon | do install failures kill pandabrew's rebootstrap?

[19:58] <tadzik> colomon: I suppose... do they? :)

[20:00] <japhb_> timotimo: HTTP::Client reveals some problems with the Socket API (it has bugs of its own too though)

[20:00] <tadzik> first bicycle day today. Feels good

[20:00] <masak> tadzik! \o/

[20:00] <tadzik> \o/

[20:00] <tadzik> and a new monitor at home. Choices, choices...

[20:01] *** TreyRust joined
[20:01] *** frd|afk left
[20:02] *** frdmn joined
[20:02] <japhb_> timotimo, for instance, trying to fetch the entirety of a large web page will reveal difficulty reaching (and discovering) end of input.  And the socket code does evil things to the network buffers when it comes to handling broken encoded character sequences

[20:02] <timotimo> same problem on parrot/master

[20:04] <japhb_> (Note BTW that when testing, the most annoying bug in HTTP::Client is that if there is no content in the outgoing request (headers only), it will forget to put an extra CRLF after the header block -- which will make some HTTP servers error or hang forever.  It's an easy fix though, just moving a line.)

[20:04] <timotimo> :(

[20:05] <japhb_> My conclusion is that the existing Rakudo socket code needs to sit down with the current Parrot socket code and a good mediator/coder to hash things out until sanity is achieved.

[20:08] <timotimo> may be.

[20:11] <japhb_> Will there be a new Rakudo release today?

[20:13] *** kaare_ left
[20:20] <[Coke]> tadzik: OOoh, bicyle day!

[20:20] <[Coke]> did we ever scam a volunteer for this month?

[20:20] <[Coke]> If not, I'll do it this evening.

[20:21] <tadzik> [Coke]++

[20:21] <masak> ok, then I'll do June.

[20:22] <dalek> rakudo/nom: 203e3aa | masak++ | docs/release_guide.pod:

[20:22] <dalek> rakudo/nom: sign up Coke and me

[20:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/203e3aa621

[20:27] *** pupoque left
[20:28] *** frd|afk joined
[20:32] *** frdmn left
[20:32] *** rindolf left
[20:36] <sorear> [Coke]: sounds like a great idea

[20:36] <timotimo> [Coke]: neat! :)

[20:37] <japhb_> sorear, which of [Coke]'s comments were you responding to?  nqp-mono?

[20:37] <sorear> japhb_: yes

[20:37] * moritz wants nqp in stereo

[20:38] <sorear> I don't read the whole backlog, just the "/lastlog sorear" parts

[20:38] <FROGGS> nqp-5.1

[20:38] <FROGGS> not-quiet-dolby surround

[20:46] <timotimo> :)

[20:47] <mathw> o/

[20:50] <dalek> nqp/qrpa_experiment: 7d9d1ec | (Tobias Leich)++ | src/ (10 files):

[20:50] <dalek> nqp/qrpa_experiment: FROGGS++ did all of the remaining things, like stage0

[20:50] <dalek> nqp/qrpa_experiment: review: https://github.com/perl6/nqp/commit/7d9d1ec79a

[20:54] *** rindolf joined
[20:57] <masak> mathw! \o/

[20:57] <masak> mathw: long time no see. :)

[20:58] <masak> ooh, nice. didn't know about /lastlog before. sorear++

[20:59] <shachaf> masak: Also useful: /last -clear

[20:59] <mathw> hi masak

[21:00] <masak> shachaf: ooh, yes. I see what you mean. :)

[21:01] <mathw> i thought I'd come by and say hello

[21:02] <masak> glad that you did :)

[21:02] <mathw> I'm trying to decide what to charge per hour for some consulting work with my old job, and it's harder than I thought. I obviously don't want to undervalue my skills but I also really don't want to rip them off.

[21:02] <timotimo> with froggs and mine work of welcoming qrpa to nqp and rakudo, my dumb benchmark now shows that list.join is faster than a naive loop with $foo ~= $_ for @pieces

[21:02] <mathw> \o/

[21:03] <Tene> qrpa?

[21:03] <felher> Good night, good people.

[21:03] <diakopter> o/

[21:03] <lee_> timotimo: thats exciting, any chance of it being merged? :D

[21:04] <Tene> mathw: Don't worry about ripping them off; they'll make a decision on whether it's worth it to them or not.  Charge them fairly for your time.

[21:04] <masak> Tene: Quantum <mumble> PMC Array.

[21:04] <masak> oh! Resizable.

[21:04] <timotimo> lee_: can't tell. others would have to do that. also, there's now stolen code from parrot to implement the .sort

[21:06] <mathw> Tene: okay, so what are gorgeous and talented programmers charging for random consulting these days? :)

[21:06] <mathw> masak: there are quantum data structures now? Do I need to buy another new computer or can I get a quantum USB 3 stick?

[21:07] <Tene> mathw: What rate would you be willing to pay for an extra few hours in a day?

[21:07] <Tene> Add some extra on top of that for taxes, etc.

[21:07] *** skids left
[21:07] <Tene> It depends on a lot of things, realistically; living costs in your area, what other work you have, etc.

[21:08] <tadzik> timotimo: yay! What was wrong with the morning patches?

[21:08] <masak> mathw: it's not the data structure that's quantum. it's pmichaud. we upgraded him to an entangled form of existence.

[21:09] <mathw> does that mean he's now capable of solving compiler problems in multiple universes simultaneously?

[21:09] <tadzik> he's _now_ capable?

[21:09] <mathw> I'm struggling to think of how pmichaud could become more awesome

[21:11] <mathw> Also struggling to stay awake, so goodnight all

[21:11] <mst> cyberisation.

[21:12] <masak> there are hypotheses that state that pmichaud was always quantum, but the rest of us weren't at a suffuciently high plane of existence to understand it until recently.

[21:12] <masak> mathw: 'night

[21:13] <masak> dream of being awesome in multiple universes simultaneously.

[21:14] <sorear> masak: there is some talk about quantum radix trees on page 7 of http://eprint.iacr.org/2013/199.pdf

[21:17] <timotimo> tadzik: i can't tell ;)

[21:20] <masak> sorear: nice.

[21:20] * masak doesn't feel at a sufficiently high plane of existence to understand that paper, though

[21:21] <masak> I'm still enjoying http://arxiv.org/pdf/1302.6946.pdf in my copious spare time, though.

[21:21] <masak> exactly what I needed to get deeper into that whole cat theory thing.

[21:26] *** DreamingInCode left
[21:28] *** spider-mario left
[21:28] *** bluescreen10 left
[21:29] *** bluescreen10 joined
[21:44] *** rindolf left
[21:46] <masak> 'night, #perl6

[21:46] <lizmat> night masak!

[21:48] <japhb_> o/

[21:52] *** kurahaupo joined
[21:55] *** pupoque joined
[21:57] *** DreamingInCode joined
[22:16] <timotimo> will adding "ratchet" to a rule cause speedups even if it wouldn't have backtracked any way?

[22:16] *** lizmat left
[22:16] <sorear> yes

[22:17] <sorear> adding ratchet tells perl that it's ok to not store backtrack points

[22:17] <sorear> also, a lot of stuff is specially optimized for the ratchet case

[22:18] *** lizmat joined
[22:19] *** lizmat left
[22:19] *** lizmat joined
[22:20] <timotimo> that's nice

[22:20] <timotimo> maybe i can add more ratchets to the json tiny grammar without breaking it

[22:27] *** snuffles joined
[22:29] <timotimo> i'm feeling tempted to write a one-off parser for this very special json format, just so i get a little bit of performance out of it :(

[22:29] *** skids joined
[22:31] <FROGGS> there is no libjson which can be used?

[22:31] <timotimo> hm.

[22:33] <timotimo> i can totally try that.

[22:35] <sorear> you'll lose 200% of the performance you gain when you try to convert the native lib objects into Rakudo objects

[22:36] <sorear> you need a C JSON library which directly constructs Rakudo objects

[22:36] <sorear> niecza has a C# JSON parser that's tightly integrated with the runtime, it's an order of magnitude faster than anything you could make with grammars

[22:37] <timotimo> sorear: all i want is not to take 1 second to parse a few lines of json.

[22:39] <sorear> n: use JSYNC; say from-json('{"foo":[1,2,3]}')

[22:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«{"foo" => [1e0, 2e0, 3e0]}␤»

[22:39] <timotimo> hm. does niecza have IO::Socket::INET?

[22:39] <lizmat> r: say 1e0

[22:39] <camelia> rakudo 203e3a: OUTPUT«1␤»

[22:39] <timotimo> kinda-sorta-working?

[22:39] <sorear> n: use JSYNC; my $t1 = times[0]; say times[0]-$t1  say from-json('[]')

[22:39] <timotimo> and kinda-sorta like rakudo does?

[22:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/9tSKUKXjWp line 1:␤------> C; my $t1 = times[0]; say times[0]-$t1  ⏏say from-json('[]')␤␤Parse failed␤␤»

[22:39] <sorear> n: use JSYNC; my $t1 = times[0]; say times[0]-$t1;  say from-json('[]')

[22:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«0␤␤»

[22:39] <sorear> timotimo: yes and yes

[22:39] <sorear> n: use JSYNC; my $t1 = times[0]; '[' x 1e6; say times[0]-$t1;  say from-json('[]')

[22:39] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«0␤␤»

[22:39] <timotimo> in that case, i have found out how to make my stuff fast.

[22:40] <sorear> n: use JSYNC; my $t1 = times[0]; '[' x 1e8; say times[0]-$t1;  say from-json('[]')

[22:40] <japhb_> timotimo, have you been able to test the QRPA change in Rakudo, or just NQP?

[22:40] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)»

[22:40] <FROGGS> japhb_: rakudo as well

[22:40] <japhb_> So ... did that make any difference to Grammar parsing speed?

[22:40] <FROGGS> no

[22:40] <FROGGS> ó.ò

[22:40] <japhb_> (I know he was testing with join)

[22:41] <sorear> n: use JSYNC; say times; from-json(('[' x 10000) ~ (']' x 10000)); say times;

[22:41] * japhb_ is somewhat surprised by that, unless QRegex was already using QRPA

[22:41] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«1.300081 0.064004 1.300081 0.064004␤1.308081 0.064004 1.308081 0.064004␤»

[22:41] <sorear> n: use JSYNC; say times; from-json(('[' x 1e5) ~ (']' x 1e5)); say times;

[22:41] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«1.480092 0.036002 1.480092 0.036002␤1.6081 0.040002 1.6081 0.040002␤»

[22:41] <sorear> n: use JSYNC; say times; from-json(('[' x 1e7) ~ (']' x 1e7)); say times;

[22:41] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)»

[22:42] <FROGGS> ENOTENOUGHMEMORY

[22:42] <sorear> n: use JSYNC; say times; from-json(('[' x 2e6) ~ (']' x 2e6)); say times;

[22:42] <timotimo> japhb_: in rakudo.

[22:42] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)5.880367 0.088005 5.880367 0.088005␤Stacktrace:␤␤  at (wrapper managed-to-native) object.__icall_wrapper_mono_object_new_fast (intptr) <0xffffffff>␤  at JsyncReader.GetFromJson (bool) <0x0003f>␤  at JsyncReader.GetFromJson (bool) <0x000bb>␤  at Js…

[22:42] <sorear> n: use JSYNC; say times[0]; from-json(('[' x 1e6) ~ (']' x 1e6)); say times[0];

[22:42] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(timeout)3.480217␤Stacktrace:␤␤  at (wrapper managed-to-native) object.__icall_wrapper_mono_array_new_specific (intptr,int) <0xffffffff>␤  at JsyncReader.GetFromJson (bool) <0x00057>␤  at JsyncReader.GetFromJson (bool) <0x000bb>␤  at JsyncReader.GetFromJso…

[22:43] <diakopter> sorear: stack overflow?

[22:43] <timotimo> sorear: i am satisfied with the performance.

[22:43] <timotimo> it takes 0.0005s instead of 1s per parse.

[22:43] <sorear> diakopter: unchecked malloc return

[22:43] <sorear> + total memory ulimit

[22:44] <timotimo> sorear: do you think putting rakudo onto the jvm will give a similar performance boost to random workloads? :|

[22:45] <labster> rn: class Foo is ::("Str") { }; say Foo.can('substr')

[22:45] <camelia> rakudo 203e3a: OUTPUT«===SORRY!===␤'Foo' cannot inherit from '::("Str")' because it is unknown.␤at /tmp/xPHkAyyzA7:1␤------> ␤»

[22:45] <camelia> ..niecza v24-37-gf9c8fc2: OUTPUT«True␤»

[22:46] <labster> quacks like a rakudobug.

[22:46] <japhb_> Something is wrong if timotimo's case takes 2000x as long to run under Rakudo-parrot.  (It's slow, sure -- but when it's more than 1.5-2 orders of magnitude, it almost always turns out to be hitting an outright performance bug, like one of the 10x or bigger improvements jnthn++ or pmichaud++ has found in the past.)

[22:46] *** lizmat left
[22:47] *** lizmat joined
[22:47] <sorear> timotimo: i think you'll get half of the perfomance boost that way

[22:47] <timotimo> that's excellent

[22:47] <timotimo> that's already a metric shit-ton

[22:48] <sorear> historically I've been much more prone to say "this needs to go into C# to be fast" while jnthn has been focusing efforts on the optimizer

[22:49] <sorear> which is probably going to pay off more in the long run, but less so in the past/present

[22:52] *** bluescreen10 left
[22:53] *** shinobicl left
[22:53] *** frd|afk left
[22:55] <lizmat> rn: say 10.WHAT; say 1e1.WHAT

[22:55] <camelia> niecza v24-37-gf9c8fc2: OUTPUT«(Int)␤Num()␤»

[22:55] <camelia> ..rakudo 203e3a: OUTPUT«(Int)␤(Num)␤»

[22:56] * lizmat wonders why 1e1 is a Num and not an Int?

[22:57] <japhb_> lizmat, using scientific notation explicitly requests Num treatment

[22:57] <japhb_> as per spec

[22:58] <lizmat> ah, ok, must have missed that

[22:59] <japhb_> Otherwise you'd have no way (other than Num.new()) to specify a Num that happened to be a rational or integer value

[23:01] <sorear> especially since *all* (finite?) Num values are rational

[23:01] *** xinming left
[23:02] <lizmat> S02:3307 seems to imply that if a number with e notation can be fit in an Int, it should

[23:02] *** xinming joined
[23:03] <japhb_> sorear, perhaps I should have said "happened to fit into a Rat" (as opposed to a FatRat, which must be explicitly requested).

[23:06] *** pupoque left
[23:10] *** dovahkin joined
[23:11] <lue> lizmat: what you referenced seems to be talking about the previous paragraph, which has nothing to do (directly) with 'e'

[23:12] <lizmat> it has to do with all string to number converters…  

[23:13] <lizmat> but I was just wondering, nothing to see here  :)

[23:14] <lue> [ besides, unless you're a scientist, you're unlikely to use 'e' for simple integers :) ]

[23:14] <lizmat> very true

[23:31] <sorear> ultimately, floating point *is* scientific notation

[23:31] <sorear> when a scientist writes 2.300e6, the semantics are that everything after the second 0 is unknown

[23:32] <sorear> this dovetails nicely with floats, though it would be better if we explicitly marked precision

[23:36] <jnthn> sleep; 'night, #perl6

[23:37] <lizmat> gnight jnthn!

[23:40] <dalek> v5: 50cdb0f | (Tobias Leich)++ | Makefile:

[23:40] <dalek> v5: make it installable via `make install`, even if the locations are not ideal

[23:40] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/50cdb0febe

[23:40] <FROGGS> gnight all

[23:41] <japhb_> o/

[23:44] *** berekuk left
[23:50] *** berekuk joined
[23:51] *** xinming left
[23:53] <lizmat> night #perl6!

[23:53] <labster> night lizmat 

[23:55] *** lizmat left
[23:55] *** xinming joined
