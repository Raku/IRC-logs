[00:00] <jnthn> Right

[00:00] <timotimo> OK.

[00:00] <jnthn> You probably want to avoid doing anything with those cases.

[00:00] <jnthn> The inliner doesn't dare touch them.

[00:00] <timotimo> OK.

[00:01] <jnthn> It is entirely possible that you should do your transform *before* the inliner does its work.

[00:01] <jnthn> Oh

[00:01] <jnthn> Yes, you totally should

[00:01] <jnthn> Because!

[00:01] <jnthn> Then we can inline the simple calls, possibly :)

[00:01] *** sftp left
[00:01] *** sftp joined
[00:01] <timotimo> sounds good to me. anything surprising i may end up finding when i try to do that?

[00:01] <jnthn> So if you do your transform and then run the optimizer on the QAST youv'e produced, the inliner can further optimize what you did :)

[00:02] <jnthn> You're hacking on the optimizer, be ready for anything :P

[00:02] <jnthn> I can't immediately think of anything terribly bad that you'll hit.

[00:02] <jnthn> What order to do optimizations in is a classic compsci problem :)

[00:02] <timotimo> thank you :)

[00:03] <jnthn> I think doing yours first and then considering inlining gets us by far the better chance of success.

[00:05] <jnthn> In "my int $a = ...; if $a == 1|2 { ... }" then we can actually turn that into something really cheap 

[00:05] <jnthn> (And will after your work, I expect.)

[00:09] *** hash_table joined
[00:10] <timotimo> should i turn a &infix:<|> into a &infix:<||> or into a &CORE::infix<||>?

[00:11] <timotimo> r: sub infix:<||> ($a, $b) { say "woop woop"; return CORE::<||>($a, $b) }; if 1|2|3 == 2 { say "yay" }

[00:11] <p6eval> rakudo 1553b1: OUTPUT«yay␤»

[00:12] <timotimo> apparently i should

[00:12] <timotimo> r: sub infix:<||> ($a, $b) { say "woop woop"; return CORE::<||>($a, $b) }; if 1 == 2 || 2 == 2 || 3 == 2 { say "yay" }

[00:12] <p6eval> rakudo 1553b1: OUTPUT«yay␤»

[00:12] <timotimo> er, wait, what? did i do that wrong?

[00:12] <jnthn> timotimo: It turns into a different op

[00:14] <jnthn> timotimo: No, || compiles into a QAST::Op with :op('unless')

[00:14] <jnthn> To give the short-circuit semantics.

[00:14] *** SHODAN joined
[00:14] <jnthn> See infix:sym<||> definition in Grammar.pm, of note the :pasttype

[00:15] <jnthn> (which really should be named something like :op these days...)

[00:15] <jnthn> Or qastop or so

[00:15] <timotimo> good to know.

[00:15] <timotimo> so i don't have to worry about overwritten infix:<||> or overwritten infix:<&&>

[00:15] <jnthn> The compiler today sure doesn't :)

[00:16] <jnthn> (we may need to fix that eventually, but it's not a show-stopper)

[00:19] <timotimo> so i can create one like that with QAST::Op.new("%tight_and", :pasttype<if>) or QAST::Op.new("%tight_or", :assoc<left>, :pasttype<unless>)?

[00:20] <jnthn> neither

[00:20] <jnthn> QAST::Op.new( :op('unless'), ... )

[00:20] <jnthn> Just that

[00:20] <timotimo> ah, ok

[00:20] <jnthn> The assoc and stuff are all about parsing

[00:20] <jnthn> You're at QAST level here

[00:21] * timotimo nods

[00:21] <timotimo> somewhat unfamiliar territory for me

[00:22] <timotimo> do you have a good suggestion for a check that would let me bail out if i'm going to be in danger of getting side-effects multiple times?

[00:22] <timotimo> check for call ops a few nodes down the tree?

[00:24] <jnthn> Don't detect them

[00:24] <jnthn> Just evaluate the thing once.

[00:25] <jnthn> And store bind it into a temporary

[00:25] <jnthn> s/store//

[00:25] <timotimo> should i treat the nodes as if they were immutable? or clone and change attributes? or just change?

[00:25] <jnthn> It's cleaner to go the immutable way

[00:25] <timotimo> good

[00:25] <jnthn> Technically you *can* do it by changing them, but I suspect the result will be harder to understand

[00:26] <jnthn> OK, I need rest

[00:26] <jnthn> happy hacking :)

[00:26] <timotimo> good night! i'll probably go to sleep soon-ish, too, though

[00:26] <timotimo> if i get too frustrated perhaps :D

[00:26] <jnthn> ;)

[00:26] <jnthn> o/

[00:43] <timotimo> ho-hum

[00:43] <timotimo> now i've rebuilt the if, but i get "use of initialized value of type Mu in string context" from somewhere and then it says "could not find sub cuid_7_.....", probably didn't copy the if's child node correctly?

[00:46] *** [particle] joined
[00:50] *** cognominal left
[00:53] *** japhb_ left
[00:55] *** Targen joined
[01:06] <timotimo> i've apparently created some sort of endless loop or recursion with my ast :|

[01:08] *** ashleydev joined
[01:08] <timotimo> that really seems like a useful optimisation.

[01:18] <timotimo> i may have made it! wow.

[01:18] <timotimo> now i've gotta get some rest, too >_<

[01:18] *** xinming left
[01:20] <timotimo> jnthn (and others): http://sprunge.us/EHUD  -  it looks kind of insane, code-style-wise, i'll clean it up tomorrow and then try to get it into rakudo proper. until then, that code example works and does what it's intended to do (also, right-hand-side expansion isn't in yet, but shouldn't be too hard)

[01:22] *** xinming joined
[01:23] <timotimo> but the local temporary var stashing is still missing

[01:23] *** hash_table left
[01:32] *** skids joined
[01:33] *** swarles left
[01:34] *** alec left
[01:36] *** wk_ left
[01:47] *** Chillance left
[01:52] *** Khisanth left
[01:59] *** LordVorp joined
[02:01] *** odoacre left
[02:02] *** odoacre joined
[02:14] *** Khisanth joined
[02:18] *** ifim left
[02:39] *** PacoAir left
[02:47] *** FROGGS_ joined
[02:51] *** FROGGS left
[03:06] *** LordVorp left
[03:15] *** am0c joined
[03:26] *** echowuhao joined
[03:27] *** echowuhao left
[03:27] *** am0c left
[03:45] *** alec joined
[03:53] <[Coke]> I am consistentingly segfaulting building 1553b11 (rakudo)

[03:59] *** orafu left
[04:12] <[Coke]> ... apparently consistently ws the wrong word. :P

[04:12] *** atrodo left
[04:14] *** Targen left
[04:17] *** preflex_ joined
[04:17] *** preflex left
[04:17] *** preflex_ is now known as preflex

[04:17] *** inverse joined
[04:21] *** fgomez left
[04:42] *** fgomez joined
[04:56] * lue just found wiki.perl6.org

[05:13] *** telex left
[05:14] *** nnunley left
[05:17] *** daniel-s_ joined
[05:20] *** daniel-s left
[05:23] *** telex joined
[05:33] *** telex left
[05:38] *** telex joined
[05:39] *** telex left
[05:40] *** nnunley joined
[05:41] *** telex joined
[05:54] *** SunilJoshi joined
[07:10] *** SunilJoshi left
[07:15] *** SunilJoshi joined
[07:21] *** zby_home joined
[07:34] *** kaare_ joined
[07:39] *** [particle]1 joined
[07:42] *** [particle] left
[08:00] *** SunilJoshi left
[08:05] *** daniel-s_ is now known as daniel-s

[08:21] *** swarles joined
[08:31] *** GlitchMr left
[08:33] <Su-Shee> good morning everyone

[08:33] *** GlitchMr joined
[08:45] *** swarles left
[08:48] *** FROGGS_ left
[08:54] *** SunilJoshi joined
[08:58] <sorear> o/ SunilJoshi 

[08:58] <sorear> o/ Su-Shee 

[09:00] *** GlitchMr left
[09:02] *** GlitchMr joined
[09:29] *** FROGGS joined
[09:36] <FROGGS> jnthn: about "abc" ~~ / $( $_.substr(1,2) ) /, I got the $(...) in rakudos Perl6::RegexGrammar, how do I make it literal within the regex?

[09:36] <FROGGS> jnthn: is it a regex subrule of some kind?

[09:36] <FROGGS> I tried make QAST::Regex.new( $<variable>.ast, :rxtype<literal> );

[09:37] <FROGGS> but I get no match...

[09:41] <timotimo> morning, people!

[09:42] <FROGGS> morning timotimo 

[09:44] <FROGGS> jnthn: with the original code of metachar:sym<rakvar> if get: No such method 'Any' for invocant of type 'Str'

[09:44] <FROGGS> where Str is the $( $_.substr(1,2) ) IMO

[09:47] *** Patterner left
[09:48] <FROGGS> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.pm#L5872-L5876

[09:49] *** Psyche^ joined
[09:49] *** Psyche^ is now known as Patterner

[09:53] <timotimo> i'm not quite sure how i can put the var in that's supposed to bind temporary values :|

[09:55] <FROGGS> timotimo: what are you talking about?

[09:56] <timotimo> i'm being incoherent again, sorry

[09:57] <timotimo> http://sprunge.us/EHUD - i'm building this AST transformation that turns a|b|c == 5 into a == 5 || b == 5 || c == 5, but i will have to bind a, b and c to local variables before i can finish this, so that side-effects will only get run once

[09:59] <timotimo> but until then i have plenty other things to worry about

[10:01] <moritz> timotimo: you can generate uniq names for that with $path.uniq('your_prefix')

[10:02] <moritz> you can declare them with  QAST::Var.new(:name($yourname), :scope<local>, :decl<var>)

[10:02] <moritz> see for example sub sink in Actions.pm for an example

[10:02] <timotimo> so i don't need an additional bind op for that?

[10:02] <FROGGS> timotimo: example: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.pm#L3975

[10:03] <moritz> yes

[10:03] <FROGGS> my example is better because of $comments

[10:04] <timotimo> but it does use the bind op ;)

[10:04] *** PacoAir joined
[10:04] <FROGGS> I wish there where more though

[10:04] *** wk joined
[10:05] <FROGGS> timotimo: what is the problem again with binding?

[10:06] <timotimo> oh there's no problem, i just don't quite know how it fits into the QAST. can i just put a Stmt wherever i want? i guess i can!

[10:07] <FROGGS> I think you can, yes

[10:08] <timotimo> is there an obligation that the var is on the same level or above from the var nodes that try to access it?

[10:10] <FROGGS> I'd say if you call $past.unique, it in in scope of $past

[10:10] <FROGGS> and that's good

[10:10] <timotimo> oh, that sounds good

[10:11] <FROGGS> but keep in mind, thats just what I learned by try&error from the last weeks

[10:12] <timotimo> i would probably have tried&errord about the same things as you, but would have probably taken longer doing it :D

[10:12] <timotimo> so thanks, that's quite excellent

[10:13] <timotimo> i guess at first i'll just bind every value and after that i'll make up some heuristic to see when a value needs to be bound away and when not

[10:15] <masak> good forenoon, #perl6

[10:18] <FROGGS> hi masak 

[10:20] <timotimo> huh, that was ten times more easy than i thought it would be!

[10:21] <timotimo> oh, here comes the catch already

[10:22] <timotimo> since i have to temporarily bind the right hand side, too, i'll lose the ability to easily see and disect a junction if one is there on the other side as well

[10:25] <timotimo> oh, but now i lose the short-circuiting nature of the side-effects :|

[10:26] <timotimo> i might have to put the bind in the first place it appears in the actual junction evaluation and then refer to it later in the evaluation :|

[10:27] <jnthn> morning o/

[10:27] <timotimo> morning jnthn

[10:27] <timotimo> this is kind of mindbendy at times

[10:28] <timotimo> it's time i put this under serious version control

[10:29] <FROGGS> hi jnthn 

[10:29] <jnthn> .oO( What does unserious version control look like? Oh...probably TFS... )

[10:30] <masak> jnthn: Excel files, in manually merged versions, send over email at the last minute.

[10:31] <jnthn> masak: No, that's lack of control :P

[10:32] * masak .oO( Version Chaos System )

[10:34] *** MayDaniel joined
[10:35] <timotimo> i think i'll have to do both left and right side in one pass, or even better, generalise it for any number of chains in a row

[10:35] <timotimo> that is, 1 | 2 | 3 == 2 & 3 should be handled by the same code that does 1 | 2 | 3 == 2 and the same code that does 1 | 2 | 3 == 2 & 3 == 1 ^ 2

[10:35] <timotimo> otherwise i'll end up in a whole lot of trouble, i think

[10:36] <timotimo> this is going to be ... fun

[10:38] <jnthn> I think that if you start multiplying out big junctions we'll end up with huge QAST trees

[10:38] <FROGGS> it is fun

[10:38] <jnthn> optimizing the "junction literal on one side" is probably enough.

[10:38] <timotimo> yes, but it will still be faster than creating the junction objects every time at run time and autothreading through them manually, no?

[10:39] <timotimo> hm, so if there's a junction on both sides, we'll still get the benefit of one unfolded junction and the drawback of one autothreaded junction?

[10:39] <jnthn> Perhaps; on the other hand, it's not like QAST nodes and the extra code you'll produce are totally cost-free...

[10:40] <timotimo> you may be right :|

[10:40] <timotimo> i wonder if i should check which one is the bigger junction if there's two :P

[10:42] <jnthn> Also, we could create junction literals at compile time

[10:42] <jnthn> Trouble is that we should do that after things like you're doing

[10:43] <jnthn> Otherwise we leave behind a tree that's just a QAST::WVal.

[10:44] <timotimo> yes

[10:44] <timotimo> that's not a very costly optimisation ; shouldn't the auto-inliner do that already anyway?

[10:45] <jnthn> No, it's not really an inlining optimizatin.

[10:45] <jnthn> It's more a "just construct this at compile time rather than runtime" one.

[10:46] <jnthn> We could do it for parcels too

[10:46] <timotimo> OK.

[10:46] <timotimo> how much would we win for parcels?

[10:46] <jnthn> Anyway, one opt at a time :)

[10:47] <jnthn> It's hard to say...if we did it to the parcel in for 1..10000 { my @a = @x[$_] Z (1,2,1,2); ... }

[10:47] <jnthn> Then we save creating 9999 extra parcel objects for example :)

[10:47] <jnthn> In other cases, probably it's not so different :)

[10:48] <jnthn> bbi10

[10:51] <timotimo> at least my "evaluate side-effect only once" code is now apparently correct

[10:55] * masak .oO( I vill only evaluate dis once )

[10:57] <timotimo> really, really enjoying the fact that i can just put subs into my innermost pieces of code and refer to the outer lexicals

[11:06] *** Su-Shee_ joined
[11:09] *** Su-Shee left
[11:11] *** wk left
[11:15] *** spider-mario joined
[11:16] *** MikeFair joined
[11:16] *** Su-Shee_ is now known as Su-Shee

[11:16] *** MikeFair__ left
[11:18] *** grondilu joined
[11:31] *** SunilJoshi left
[11:59] *** SunilJoshi joined
[12:13] *** SamuraiJack joined
[12:46] *** SamuraiJack left
[13:07] *** zby_home left
[13:18] *** Targen joined
[13:21] *** imarcusthis left
[13:24] *** imarcusthis joined
[13:33] <masak> r: given Date.today { if .month == 1 && .day-of-month == 26 { say "Happy birthday, jnthn!" } }

[13:33] <p6eval> rakudo 1553b1: OUTPUT«Happy birthday, jnthn!␤»

[13:37] <jnthn> :)

[13:39] <sjn> hey, happy b(eer|irth)day, jnthn! :)

[13:42] *** preflex left
[13:53] *** am0c joined
[14:01] *** am0c left
[14:06] <timotimo> oooh!

[14:06] <timotimo> jnthn: \o/ happy birthday

[14:20] <FROGGS> happy birthday jnthn!

[14:26] *** spider-mario left
[14:35] <masak> r: say ~("hip" xx 2, [].^name), "!"

[14:36] <p6eval> rakudo 1553b1: OUTPUT«hip hip Array!␤»

[14:43] *** swarles joined
[14:45] <swarles> r: my token test-token-name { . }; say "hello" ~~ /<test-token-name>/;

[14:45] <p6eval> rakudo 1553b1: OUTPUT«｢h｣␤ test-token-name => ｢h｣␤␤»

[14:45] <swarles> Wonderful

[14:47] *** zby_home joined
[14:59] *** PacoAir left
[14:59] *** PacoAir joined
[15:00] *** swarles left
[15:00] <swarley> r: say "hello" ~~ /<!l> e/

[15:00] <p6eval> rakudo 1553b1: OUTPUT«No such method 'l' for invocant of type 'Cursor'␤  in regex  at /tmp/sw6FifoJLA:1␤  in method ACCEPTS at src/gen/CORE.setting:10738␤  in block  at /tmp/sw6FifoJLA:1␤␤»

[15:00] <swarley> r: say "hello" ~~ /<! 'l'> e/

[15:00] <p6eval> rakudo 1553b1: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at /tmp/E5uXVFk6B1:1␤------> say "hello" ~~ /<!⏏ 'l'> e/␤Unrecognized regex metacharacter ! (must be quoted to match literally)␤at /tmp/E5uXVFk6…

[15:00] <swarley> r: say "hello" ~~ /<!before 'l'> e/

[15:00] <p6eval> rakudo 1553b1: OUTPUT«｢e｣␤␤»

[15:00] <swarley> r: say "hello" ~~ /<!before l> e/

[15:00] <p6eval> rakudo 1553b1: OUTPUT«｢e｣␤␤»

[15:02] <swarley> r: say "hello" ~~ /<![l]> e/

[15:02] <p6eval> rakudo 1553b1: OUTPUT«｢e｣␤␤»

[15:03] <swarley> r: say "hello" ~~ /<?before <-[l]>> e/

[15:03] <p6eval> rakudo 1553b1: OUTPUT«｢e｣␤␤»

[15:03] <swarley> I'm confused

[15:04] <Ayiko> r: say "hello" ~~ /e <!before 'l'>/

[15:04] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:04] <swarley> Oh

[15:04] <swarley> Whoops

[15:04] <masak> did your confusion lift?

[15:04] <swarley> Yup

[15:04] <masak> happy to hear that :)

[15:05] <swarley> I was still thinking pcre

[15:05] <swarley> /(?<=e)l/

[15:06] <Ayiko> should be same there?

[15:06] <swarley> [8] pry(main)> "hello" =~ /(?<=e)l/

[15:06] <swarley> => 2

[15:06] <Ayiko> r: say "hello" ~~ /<!after h> e/

[15:06] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:07] <masak> yeah, the principle is the same.

[15:07] <masak> (?<=e) is just a strange and ugly way to write <!after e>

[15:08] <swarley> Yeah, I was running that in a ruby repl

[15:08] <swarley> (The regex engine I'm most familiar with)

[15:08] <swarley> It uses the regex engine I'm most familiar with*

[15:08] <Ayiko> (?<!e) or <after e>  ? :)

[15:13] <masak> oh, right.

[15:13] *** SamuraiJack joined
[15:15] *** am0c joined
[15:16] <swarley> r: say 49.chr

[15:16] <p6eval> rakudo 1553b1: OUTPUT«1␤»

[15:16] <swarley> say "1" ~~ /\c[49]/

[15:17] <swarley> r: say "1" ~~ /\c[49]/

[15:17] <p6eval> rakudo 1553b1: OUTPUT«｢1｣␤␤»

[15:17] <swarley> k.

[15:17] <swarley> Does it have to be square brackets there?

[15:18] <swarley> r: say "1" ~~ /\c{49}/

[15:18] <p6eval> rakudo 1553b1: OUTPUT«===SORRY!===␤Unrecognized \\c character␤at /tmp/M5klW9R4az:1␤------> say "1" ~~ /\c⏏{49}/␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        prefix or term␤        prefix or meta-pref…

[15:18] <swarley> Yes.

[15:18] <swarley> Alright then

[15:27] <Ayiko> r: say "10" ~~ /\c49 0/

[15:27] <p6eval> rakudo 1553b1: OUTPUT«｢10｣␤␤»

[15:31] <swarley> How would I assert that if something is equal to something else, then the regex is false? like, a ~~ /b <{ if not a ~~ c }>/ but within a token

[15:31] <swarley> /c/*

[15:35] <Ayiko> I'm not sure I understand...

[15:35] <swarley> match "b but not c"

[15:36] <swarley> Assuming b is a superset of c

[15:36] <Ayiko> as character classes?

[15:36] <swarley> b and c are both tokens

[15:37] <Ayiko> or 'b' ~~ / b { fail if 'c'; } /

[15:38] <swarley> Is there a way to check it against a token? Well, I'm assuming there is a way so I suppose a better question would be, how would I do that?

[15:38] <Ayiko> r: say 'b' ~~ / b <!after a|b|c> /

[15:39] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:39] <masak> r: say 'b' ~~ / <+[\w] - [c]> /

[15:39] <p6eval> rakudo 1553b1: OUTPUT«｢b｣␤␤»

[15:39] <masak> r: say 'c' ~~ / <+[\w] - [c]> /

[15:39] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:39] <swarley> oh. That's really cool.

[15:39] <masak> that's one option.

[15:39] <Ayiko> r: say 'c' ~~ / <[\w]-[c]> /

[15:39] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:39] <masak> r: say 'b' ~~ / (\w) <!{ $0 eq 'c' }> /

[15:39] <Ayiko> oh, right

[15:39] <p6eval> rakudo 1553b1: OUTPUT«｢b｣␤ 0 => ｢b｣␤␤»

[15:39] <masak> r: say 'c' ~~ / (\w) <!{ $0 eq 'c' }> /

[15:39] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[15:39] <masak> that's another.

[15:40] <masak> swarley: if these things intrigue you, I'd recommend S05, where there's lots of this stuff.

[15:40] <swarley> Yeah, I'm reading through it

[15:40] <swarley> It's just somewhat massive

[15:40] <masak> yeah.

[15:40] <swarley> A little overwhelming

[15:40] <masak> Perl 6 -- a little overwhelming.

[15:40] <Ayiko> little?

[15:40] <swarley> I figure it's easier to get it from the horses mouth than it is to search through it to find out what I want

[15:41] <swarley> I mean, I did search before I asked

[15:41] <swarley> Don't get me wrong

[15:41] <swarley> But, failing to decipher it, I had to fall back to you all.

[15:41] <swarley> I went with

[15:41] <swarley> token multi-line-comment-line { <comment-line> <!after <multi-line-comment-end-line>> }

[15:41] <swarley>  , for what it's worth

[15:42] *** Chillance joined
[15:42] <swarley> Since the comment-line token isn't a range

[15:46] <swarley> ^^ is beginning of a line correct?

[15:46] <masak> oh, you're very welcome to fall back on #perl6.

[15:47] <masak> I just wanted to make sure you hadn't missed S05.

[15:47] <masak> swarley: '^^' is beginning of a line, correct.

[15:48] <swarley> \o/ wonderful

[15:55] <swarley> r: say "testing" ~~ /<lower>+/;

[15:55] <p6eval> rakudo 1553b1: OUTPUT«｢testing｣␤ lower => ｢t｣␤ lower => ｢e｣␤ lower => ｢s｣␤ lower => ｢t｣␤ lower => ｢i｣␤ lower => ｢n｣␤ lower => ｢g｣␤␤»

[16:02] *** PacoAir left
[16:03] <swarley> r: "hello" ~~ /[.]-< \> >/

[16:03] <p6eval> rakudo 1553b1: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at /tmp/iGaq0NLxE9:1␤------> "hello" ~~ /[.]⏏-< \> >/␤Unable to parse regex; couldn't find final '/'␤at /tmp/iGaq0NLxE9:1␤------> "hello" ~…

[16:03] <swarley> yeaj..

[16:03] <swarley> yeah*

[16:06] <swarley> r: "hello" ~~ /< hello >/

[16:06] <p6eval> rakudo 1553b1:  ( no output )

[16:06] <swarley> r: say "hello" ~~ /< hello >/

[16:06] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:07] <moritz> n: say "hello" ~~ /< hello >/

[16:07] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(5) text(hello) pos([].list) named({}.hash)>␤»

[16:07] <moritz> looks like a rakudo bug

[16:09] <jnthn> r: "hello" ~~ /< hello hi >/

[16:09] <p6eval> rakudo 1553b1:  ( no output )

[16:09] <jnthn> r: say "hello" ~~ /< hello hi >/

[16:09] <p6eval> rakudo 1553b1: OUTPUT«｢hello｣␤␤»

[16:09] <jnthn> r: say "hello" ~~ /< hello >/

[16:09] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:09] <jnthn> Huh

[16:09] <jnthn> weird.

[16:09] * swarley looks for a fly swatter

[16:09] <moritz> r: say "hello" ~~ / < hello hi > /

[16:09] <p6eval> rakudo 1553b1: OUTPUT«｢hello｣␤␤»

[16:09] <moritz> r: say "hello" ~~ / < hello > /

[16:10] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:10] <jnthn> It turns it into an alternation. Soemthing must be going wrong with the single item case.

[16:14] <FROGGS> r: say "hello" ~~ / '<hello>' /

[16:14] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:14] <FROGGS> r: say "hello" ~~ / '<hello' '>' /

[16:14] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:14] <FROGGS> r: say "hello" ~~ / '<' 'hello' '>' /

[16:14] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:14] <FROGGS> r: say "<hello>" ~~ / '<' 'hello' '>' /

[16:14] <p6eval> rakudo 1553b1: OUTPUT«｢<hello>｣␤␤»

[16:15] <FROGGS> r: say "<hello>" ~~ / <hello> /

[16:15] <p6eval> rakudo 1553b1: OUTPUT«No such method 'hello' for invocant of type 'Cursor'␤  in regex  at /tmp/tpF5R0KEEw:1␤  in method ACCEPTS at src/gen/CORE.setting:10738␤  in block  at /tmp/tpF5R0KEEw:1␤␤»

[16:15] <FROGGS> r: say "<hello>" ~~ / < hello > /

[16:15] <p6eval> rakudo 1553b1: OUTPUT«#<failed match>␤»

[16:15] <grondilu> weird

[16:15] * jnthn tries a fix locally

[16:16] <FROGGS> what should < String > do?

[16:16] <jnthn> Same as String.

[16:16] <grondilu> FROGGS: it's degenerate case of < foo bar giz >

[16:16] <grondilu> aka alternation, right?

[16:17] <moritz> correct

[16:18] <FROGGS> n: say "hello" ~~ / <hello> /

[16:18] <p6eval> niecza v24-18-gaf64300: OUTPUT«Unhandled exception: Unable to resolve method hello in type Cursor␤  at /tmp/ChmLXj7jTI line 1 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2901 (Regex.ACCEPTS @ 10) ␤  at /tmp/ChmLXj7jTI line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CO…

[16:18] <FROGGS> n: say "hello" ~~ / < hello > /

[16:18] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(5) text(hello) pos([].list) named({}.hash)>␤»

[16:18] <FROGGS> k

[16:19] <FROGGS> looks like we are missing a test case

[16:20] <timotimo> hurm. i think my additions to the optimiser that i just plopped into rakudo have made it impossible (or impossibly slow?) to compile the core setting :(

[16:20] <timotimo> how am i supposed to decide if it's just slow or broken?

[16:20] <jnthn> It's probably broken. 

[16:20] <timotimo> it would be nice if it threw an exception, though :(

[16:21] <jnthn> Tip: diddle your makefile to pass --optimize=off or so when compiling CORE.setting

[16:21] <timotimo> ah, so i can do lightweight tests with my optimizer?

[16:22] <swarley> r: say "00001_2422" ~~ /[0]* [ <.digit>+ ]+ % '_'/

[16:22] <p6eval> rakudo 1553b1: OUTPUT«｢00001_2422｣␤␤»

[16:22] <jnthn> timotimo: yeah

[16:22] <swarley> r: say "00001_2422" ~~ /0* [ <.digit>+ ]+ % '_'/

[16:22] <p6eval> rakudo 1553b1: OUTPUT«｢00001_2422｣␤␤»

[16:22] <swarley> r: say "00001_2422" ~~ /0* <.digit>+ % '_'/

[16:22] <p6eval> rakudo 1553b1: OUTPUT«｢00001_2｣␤␤»

[16:22] <swarley> k

[16:22] <swarley> r: say "00001_2422" ~~ /0* <.digit>+? % '_'/

[16:23] <p6eval> rakudo 1553b1: OUTPUT«｢00001｣␤␤»

[16:23] <swarley> Hm. So I had it the first time.

[16:23] <jnthn> r: say < hello >.perl

[16:23] <p6eval> rakudo 1553b1: OUTPUT«"hello"␤»

[16:23] <jnthn> r: say < hello >.WHAT

[16:23] <p6eval> rakudo 1553b1: OUTPUT«Str()␤»

[16:23] <jnthn> ah

[16:23] <flussence> swarley: the outermost + is the thing that has the % applied to it, if that helps to make sense of it

[16:24] <swarley> Oh, yes that makes more sense

[16:25] <swarley> r: say "00001_2422" ~~ /0* [+<.digit>+]+ % _/

[16:25] <p6eval> rakudo 1553b1: OUTPUT«===SORRY!===␤Quantifier quantifies nothing␤at /tmp/wIUzIqF8qP:1␤------> say "00001_2422" ~~ /0* [+⏏<.digit>+]+ % _/␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        prefix or term␤ …

[16:25] <swarley> err

[16:25] <swarley> r: say "00001_2422" ~~ /0* [<.digit>+]+ % _/

[16:25] <p6eval> rakudo 1553b1: OUTPUT«｢00001_2422｣␤␤»

[16:25] <timotimo> i think something else must be wrong.

[16:25] <timotimo> even with --optimize=0 it takes much longer than it usually does

[16:26] <jnthn> You can also try --optimize=off

[16:26] <jnthn> 0 means "do the analysis but don't optimize" 

[16:26] <jnthn> off means "don't run the optimizer at all"

[16:26] <timotimo> ah, ok

[16:26] <jnthn> Note this means you should pick a level for your optimization too :)

[16:27] <timotimo> good idea.

[16:27] <timotimo> what do you reckon, is this a level 3 optimisation? or just level 2?

[16:27] *** hash_table joined
[16:28] <jnthn> timotimo: 2 is the default

[16:28] <jnthn> timotimo: the idea is that we gradually move things that we consider stable and important downwards.

[16:29] <timotimo> good idea, so i'll put it in ... 4:)

[16:29] *** spider-mario joined
[16:29] <jnthn> well, 3 is the limit so far :)

[16:29] <jnthn> 1 = very safe things

[16:29] <jnthn> 2 = default

[16:29] <jnthn> 3 = include experimentals

[16:30] <timotimo> well, this goes to 4

[16:30] <jnthn> The setting is compiled with the maximum optimization level, because if we can't trust an optimization enough to work on something as well tested as the setting then we probably shouldn't trust it at all

[16:31] <jnthn> Feel free to put it at 4 during your development though :)

[16:31] <swarley> So, looking at proto tokens, could I do something like, proto token integer-literal:sym { [ <sym>+ ]+ % _ } ?

[16:31] <timotimo> hey, it seems to work after the setting is through

[16:32] <timotimo> whoops, there's a silly mistake in there somewhere.

[16:33] <swarley> So that I could do something like token integer-literal:<<[0..9]>>

[16:33] <jnthn> Got a fix for the / < hello > / thing...spectesting it.

[16:38] <dalek> rakudo/nom: c356d8e | jnthn++ | src/Perl6/Actions.pm:

[16:38] <dalek> rakudo/nom: Fix degenerate /< hello >/.

[16:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c356d8ef1d

[16:41] <dalek> roast: 645eda3 | jnthn++ | S05-metasyntax/angle-brackets.t:

[16:41] <dalek> roast: Test /< hello >/.

[16:41] <dalek> roast: review: https://github.com/perl6/roast/commit/645eda3227

[16:45] <timotimo> er, what's this? QAST::Op(p6mdthunk) - QAST::Var(lexical &infix:<==>)

[16:46] <timotimo> where'd that come from? that confuses my optimiser very much

[16:46] <jnthn> timotimo: Comes from the optimizer

[16:46] <jnthn> timotimo: It's the thing I talked about last night.

[16:46] <swarley> r: say "00.352" ~~ /[0 | <!before 0> [<digit>+]+ % _] '.' [<digit>+]+/

[16:46] <p6eval> rakudo 1553b1: OUTPUT«｢0.352｣␤ digit => ｢3｣␤ digit => ｢5｣␤ digit => ｢2｣␤␤»

[16:46] <jnthn> Why your opt should come first.

[16:46] <timotimo> ah

[16:46] <timotimo> it should come very first?

[16:46] <arnsholt> jnthn: Did you have any clues as to what bit of code tries to nqp::composetype a P6int REPR, BTW?

[16:46] * timotimo moves

[16:46] <jnthn> in visit_op

[16:47] <timotimo> how early exactly?

[16:47] <timotimo> before the self.visit_children($op)?

[16:47] <swarley> r: say "00.352" ~~ /[0 | { fail if $0 ~~ /^0/ } [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:47] <p6eval> rakudo 1553b1: OUTPUT«use of uninitialized value of type Any in string context  in any  at src/gen/BOOTSTRAP.pm:99␤␤｢00.352｣␤ digit => ｢0｣␤ digit => ｢0｣␤ digit => ｢3｣␤ digit => ｢5｣␤ digit => ｢2｣␤␤»

[16:47] <swarley> r: say "00.352" ~~ /[0 | <{ fail if $0 ~~ /^0/ }> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:47] <p6eval> rakudo 1553b1: OUTPUT«use of uninitialized value of type Any in string context  in any  at src/gen/BOOTSTRAP.pm:99␤␤Unexpected named parameter 'value' passed␤  in sub infix:<does> at src/gen/CORE.setting:12450␤  in sub MAKE_REGEX at src/gen/CORE.setting:10713␤  in regex  at /tmp/Te6vpLc…

[16:47] <jnthn> timotimo: Yes, because if you visit_children you'll transform the ==

[16:48] <swarley> r: say "00.352" ~~ /[0 | <{ fail if '0' }> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:48] <timotimo> OK.

[16:48] <p6eval> rakudo 1553b1: OUTPUT«Unexpected named parameter 'value' passed␤  in sub infix:<does> at src/gen/CORE.setting:12450␤  in sub MAKE_REGEX at src/gen/CORE.setting:10713␤  in regex  at /tmp/_O6Qs7IT5a:1␤  in method ACCEPTS at src/gen/CORE.setting:10738␤  in block  at /tmp/_O6Qs7IT5a:1␤␤»…

[16:48] <swarley> blah

[16:48] <jnthn> timotimo: I think you should construct your new QAST tree, then do a return.

[16:48] <timotimo> i call visit_op on the new-built qast

[16:48] <timotimo> hoping to get more optimisations in, too

[16:48] <swarley> r: say "hello" ~~ /<{ say $_ }>hello/

[16:48] <p6eval> rakudo 1553b1: OUTPUT«hello␤hello␤hello␤hello␤hello␤hello␤#<failed match>␤»

[16:48] <swarley> r: say "00.352" ~~ /[0 | <{ fail if $_ =~ /^0/ }> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:48] <p6eval> rakudo 1553b1: OUTPUT«===SORRY!===␤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~␤at /tmp/DHeMlZwxYx:1␤------> say "00.352" ~~ /[0 | <{ fail if $_ =~⏏ /^0/ }> [<digit>+]+ % _] '.' [<digit>+]␤»

[16:49] <swarley> r: say "00.352" ~~ /[0 | <{ fail if $_ ~~ /^0/ }> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:49] <p6eval> rakudo 1553b1: OUTPUT«␤  in method gist at src/gen/CORE.setting:10505␤  in sub say at src/gen/CORE.setting:7590␤  in block  at /tmp/kcMWhCMYqL:1␤␤»

[16:49] <swarley> o-o

[16:49] <moritz> swarley: don't ues fail() in a regex

[16:49] <jnthn> Right, but if you have it in a QAST::Stmts then it's not visit_op

[16:49] <swarley> Oh

[16:49] <moritz> it doesn't do what you think it would

[16:49] <swarley> 27<212326Ayiko27> or 'b' ~~ / b { fail if 'c'; } /

[16:49] <moritz> in fact, nobody knows for sure what exactly it should do

[16:49] <swarley> I thought it would based on that

[16:50] <swarley> r: say "00.352" ~~ /[0 | <!before ^0>[<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:50] <p6eval> rakudo 1553b1: OUTPUT«｢0.352｣␤ digit => ｢3｣␤ digit => ｢5｣␤ digit => ｢2｣␤␤»

[16:50] <swarley> hm..

[16:51] <timotimo> yes, that seems to work very much better

[16:51] <timotimo> jnthn: i ended up not putting it into a Stmts, because i wanted the short-circuiting nature of the || to still come through

[16:51] <jnthn> timotimo: That doesn't make sense

[16:51] <jnthn> timotimo: The Stmts is there so you can put a bind in place

[16:52] <jnthn> Granted you could do it without I guess...

[16:52] <timotimo> i can show how what the tree looks like right now

[16:52] <swarley> r: say "00.352" ~~ /[0 | <!before 0+> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:52] <p6eval> rakudo 1553b1: OUTPUT«｢0.352｣␤ digit => ｢3｣␤ digit => ｢5｣␤ digit => ｢2｣␤␤»

[16:53] <nwc10> Happy birthday jnthn (I gather)

[16:53] <swarley> r: say "00.352" ~~ /[0 | <!after 0> [<digit>+]+ % _] '.' [<digit>+]+ % _/

[16:53] <p6eval> rakudo 1553b1: OUTPUT«｢00.352｣␤ digit => ｢0｣␤ digit => ｢0｣␤ digit => ｢3｣␤ digit => ｢5｣␤ digit => ｢2｣␤␤»

[16:53] <swarley> whatever, i'll just use the long version

[16:53] <timotimo> i can't create gists any more?!

[16:54] <masak> how should we know?

[16:54] <masak> "try it and see"

[16:54] <timotimo> jnthn: http://paste.ee/p/nGrXk

[16:54] <masak> timotimo: maybe you've fallen victim to the weird "can't create a gist of just one file" bug.

[16:54] <jnthn> masak: "try it *to* see" :P

[16:55] <masak> jnthn: :P

[16:55] <masak> timotimo: solution: create a second file, create the gist, then remove the file.

[16:55] <timotimo> that's weird indeed!

[16:55] <timotimo> thanks for the hint

[16:55] <jnthn> timotimo: oh, you've done that trick

[16:56] <jnthn> timotimo: OK, then you don't need the stmts. :)

[16:56] <timotimo> "that" trick!? :)

[16:56] <jnthn> timotimo: The "bind on first use then mention next time" rather than pulling the bind out into a previous statement :)

[16:56] <jnthn> I've used it in a few places too :)

[16:57] <jnthn> nwc10: Thanks. Yes, it's birthday day :)

[16:57] <timotimo> yeah, it was even two times simpler to create than what i had before where i pushed all values into a stmts

[16:57] <jnthn> :)

[16:57] <jnthn> It looks good.

[16:57] <jnthn> timotimo: 

[16:57] <nwc10> jnthn: are you having the approriate amount of fun^Wbeer?

[16:58] <jnthn> timotimo++ # hacking the optimizer

[16:58] <jnthn> nwc10: Am heading out for Indian food followed by an appropriate amount of beer shortly :)

[16:58] * masak is going, too! o/

[16:58] <nwc10> are "Indians" there pretty much indistinguisable from "Indians" back home? They seem to be here

[16:59] <masak> I feel there's a difference.

[16:59] <masak> from my admittedly small experience of British ones, that is.

[16:59] <nwc10> actually, not sure if they have Cobra or Kingfisher here.

[16:59] <nwc10> That's no great loss

[16:59] <jnthn> masak: Masala Zone is not quite typical, fwiw. :)

[16:59] <nwc10> but something new popped up just before I left, called IIRC "Mongoose" and it was actually rather nice.

[17:01] <timotimo> yeah, my optimisation made it faster but wronger, just like you suspected :)

[17:01] <masak> jnthn: I wasn't thinking of Masala Zone (which is *awesome*)

[17:01] <masak> jnthn: I was thinking of the other one we went to.

[17:02] <masak> or was it two of them?

[17:02] <masak> there's something about Indian restaurants in .uk that feels more... qualitative/genuine.

[17:03] <masak> here in .se the things in the menu has the right names, but somehow it doesn't get all the way there.

[17:04] <jnthn> I think that's the whole "going to the Indian" thing is just much more integrated into the UK way of life than it is into the Swedish one 

[17:05] <jnthn> s/that's/that/

[17:05] <masak> yeah, that's probably it.

[17:05] <masak> here it feels more "ethnic". there, it feels more like an everyday thing.

[17:05] <timotimo> jnthn: could you review my before/after AST and tell me what's going wrong? :|

[17:06] <jnthn> timotimo: your || has too many children.

[17:06] <timotimo> http://sprunge.us/CDhO  -  as you can easily see from the code, the result should be 9 ($x and $y are fed from (-20..20)X(-20..20)

[17:07] <jnthn> It can only have two

[17:07] <jnthn> Then you need to nest them

[17:07] <timotimo> this && doesn't

[17:07] *** PacoAir joined
[17:08] <jnthn> I think the QAST::Op if is the wrong thing

[17:08] <timotimo> maybe i am not allowed to bind the right-hand-junction and reuse it?

[17:08] <jnthn> Try 2 == 1|2|3|4

[17:09] <timotimo> right-hand junction expanding seems to be nonfunctioning at the moment

[17:09] <jnthn> ok, then 1|2|3|4 == 2

[17:09] <jnthn> you probably will get an error

[17:09] <timotimo> you're right, i'm getting "Operation 'if' needs either 2 or 3 operands"

[17:10] <timotimo> i was certain i had written code to handle this case. thanks!

[17:10] <timotimo> i had deleted it in the mean time, i guess

[17:13] <jnthn> ok, going out for birthday :)

[17:13] <jnthn> bbl o/

[17:15] <timotimo> have a nice birthday!

[17:16] <timotimo> aaw, jnthn told me QAST::Op if is the wrong thing, but not what the right thing might be :|

[17:19] *** PacoAir left
[17:19] *** PacoAir joined
[17:22] * timotimo tries chain instead of if

[17:22] *** jerome left
[17:23] *** jerome joined
[17:24] <swarley> r: say "h3ll0" ~~ /(<alnum>)+/

[17:24] <p6eval> rakudo c356d8: OUTPUT«｢h3ll0｣␤ 0 => ｢h｣␤  alnum => ｢h｣␤ 0 => ｢3｣␤  alnum => ｢3｣␤ 0 => ｢l｣␤  alnum => ｢l｣␤ 0 => ｢l｣␤  alnum => ｢l｣␤ 0 => ｢0｣␤  alnum => ｢0｣␤␤»

[17:24] <swarley> r: say "h3ll0\n" ~~ /(<alnum>+<[\n]>)+/

[17:24] <p6eval> rakudo c356d8: OUTPUT«｢h3ll0␤｣␤ 0 => ｢h3ll0␤｣␤  alnum => ｢h｣␤  alnum => ｢3｣␤  alnum => ｢l｣␤  alnum => ｢l｣␤  alnum => ｢0｣␤␤»

[17:24] <timotimo> my silly benchmark goes from 6 seconds to 3.6 seconds with my optimisation \o/

[17:26] * timotimo tries building the setting with the optimisation on and then does a spectest

[17:32] <timotimo> doesn't seem like the setting will not go through with my optimisations on :(

[17:34] <swarley> So, not to be a bother but I never got an answer to my earlier question

[17:35] <swarley> Could  I use protos in the way that I would do something like proto token foo:arg { <arg> foo }

[17:35] <swarley> and do token foo:bar<baz> to get /baz foo/ in the token?

[17:39] * timotimo tries compiling the first half of the core setting

[17:43] *** Targen left
[17:44] <swarley> r: say "'1'" ~~ /\' ** 2 % 1/

[17:45] <p6eval> rakudo c356d8: OUTPUT«｢'1'｣␤␤»

[17:46] <timotimo> oh, that's bass ackwards :D

[17:47] <swarley> yeah, lol. It just looks neat

[17:49] <arnsholt> There's an op for that

[17:49] <swarley> r: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say "%q/foo/" ~~ /<test '/'>/

[17:49] <p6eval> rakudo c356d8: OUTPUT«Unmarshallable foreign language value passed for parameter '$i'␤  in method INTERPOLATE at src/gen/CORE.setting:10679␤  in regex  at /tmp/KL4fhQqUus:1␤  in method ACCEPTS at src/gen/CORE.setting:10738␤  in block  at /tmp/KL4fhQqUus:1␤␤»

[17:49] <arnsholt> swarley: The ~ operator is for surrounding stuff with other stuff

[17:49] <swarley> n: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say "%q/foo/" ~~ /<test '/'>/

[17:49] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(7) text(%q/foo/) pos([].list) named({"test" => #<match from(0) to(7) text(%q/foo/) pos([].list) named({}.hash)>}.hash)>␤»

[17:50] <swarley> oh. Nifty

[17:50] <arnsholt> r: say "(foo)" ~~ /\( ~ \) "foo"/ # I think

[17:50] <p6eval> rakudo c356d8: OUTPUT«｢(foo)｣␤␤»

[17:50] <timotimo> yes, indeed.

[17:50] <arnsholt> Note that you'll have to group the stuff inside if it's more than a simple thing

[17:50] <swarley> yeah

[17:52] <swarley> n: my token test($open!, $close=$open) { '%q' [ $open ~ $close foo ]}; say "%q<foo>" ~~ /<test('<','>')>/

[17:53] <p6eval> niecza v24-18-gaf64300: OUTPUT«===SORRY!===␤␤Non-literal closers for ~ NYI at /tmp/hgbyc6HsPT line 1:␤------>  $close=$open) { '%q' [ $open ~ $close f⏏oo ]}; say "%q<foo>" ~~ /<test('<','>')>␤␤Variable %q is not predeclared at /tmp/hgbyc6HsPT line 1:…

[17:53] <swarley> n: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say "%q<foo>" ~~ /<test('<','>')>/

[17:53] <p6eval> niecza v24-18-gaf64300: OUTPUT«===SORRY!===␤␤Variable %q is not predeclared at /tmp/ye5llZfgcm line 1:␤------> open) { '%q' $open 'foo' $close }; say "⏏%q<foo>" ~~ /<test('<','>')>/␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/li…

[17:53] <swarley> hrm

[17:54] <timotimo> it seems like nqp::die will just cause the application to hang, not even output the error message :(

[17:54] <swarley> Anyone spot something I'm doig wrong?

[17:54] *** adu joined
[17:54] <swarley> n: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say Q~%q<foo>~ ~~ /<test('<','>')>/

[17:54] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(7) text(%q<foo>) pos([].list) named({"test" => #<match from(0) to(7) text(%q<foo>) pos([].list) named({}.hash)>}.hash)>␤»

[17:54] <swarley> Ah, "" issue again

[17:54] <timotimo> nope, there's something really weird going on

[17:54] <swarley> n: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say Q~%q<foo>~ ~~ /<test '<' '>'>/

[17:55] <p6eval> niecza v24-18-gaf64300: OUTPUT«Match()␤»

[17:56] <swarley> as I expected.

[17:57] <timotimo> how do i compare two objects in nqp for being the same thing?

[17:58] <timotimo> eq seems to break in this little case. or maybe ... something ... don't really know :(

[17:58] <moritz> timotimo: try ===

[17:58] <timotimo> thanks

[17:58] <swarley> n: my token test($open!, $close=$open) { '%q' $open 'foo' $close }; say Q~%q>foo>~ ~~ /<test '>'>/

[17:58] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(7) text(%q>foo>) pos([].list) named({"test" => #<match from(0) to(7) text(%q>foo>) pos([].list) named({}.hash)>}.hash)>␤»

[17:58] <timotimo> nope, that causes the blockoid to fail parsing

[17:59] <timotimo> likewise for eqv

[17:59] <FROGGS> what about =:= ?

[17:59] <moritz> you can use =:=, though it's a bit cheaty, iirc

[17:59] <timotimo> huh?

[17:59] *** nyuszika7h left
[17:59] <moritz> it's meant for container equality testing in Perl 6

[17:59] <timotimo> OK

[18:00] <moritz> but it's sometimes abused for === testing in nqp

[18:00] <moritz> nqp: say(nqp::which(123))

[18:00] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op call: Error while compiling op which: No registered operation handler for 'which'␤current instr.: '' pc 46272 (src/stage2/QAST.pir:16100) (src/stage2/QAST.nqp:2434)␤»

[18:00] <swarley> So, can anyone tell me if there is a way to reduce the writing i'm doing here? Since I'm basically repeating myself over and over again for nothing

[18:00] <swarley> http://pastebin.com/UQvZZY78

[18:01] <timotimo> i am trying to use this to test if the &infix:<|> i got came from the CORE or not

[18:01] <timotimo> =:= seems to work!

[18:01] <timotimo> yes, indeed it does!

[18:01] *** nyuszika7h joined
[18:01] <timotimo> FROGGS, thank you!

[18:02] <FROGGS> swarley: you can use a character class and have just one token quoted-non-expanded-literal-string:sym

[18:02] <FROGGS> timotimo: pleasure ;o)

[18:02] <timotimo> does nqp have state variables?

[18:03] <moritz> we're always happy to help with nqp if there's the possiblity that it results in rakudo patches :-)

[18:03] <swarley> oh, really?

[18:03] <swarley> It will expand to all of them?

[18:03] <moritz> timotimo: doesn't look like

[18:03] <timotimo> i don't have to look through all blocks every time i see an infix:<|> or <&> to check where the CORE is

[18:03] <moritz> timotimo: just store it once in an outer lexical

[18:04] <timotimo> sure.

[18:04] <timotimo> er, nqp::defined will tell me if $!core_block has been set already, right?

[18:04] * arnsholt crosses his fingers

[18:04] <arnsholt> With a bit of luck I'm making progress on sized ints =D

[18:04] <FROGGS> swarley: token things { <[%-<>]> }; token quoted-non-expanded-literal-string:sym<things>  { <qlit <things>> }

[18:04] <arnsholt> But now I'm off to dinner with friends

[18:04] <swarley> Will it iterate?

[18:04] *** hash_table left
[18:04] <timotimo> arnsholt: that sounds great! :)

[18:05] <swarley> Because %q/bnub~ shouldn't work

[18:06] <FROGGS> swarley: it match whatever <things> is, can be a character class or something else

[18:06] <FROGGS> what is %q/bnub~ ?

[18:06] <moritz> FROGGS: but qlit, as written rigth now, expects a string as argument

[18:07] <swarley> Normal syntax would be either %q~foo~ or %q/foo/

[18:07] <FROGGS> ahh, I see what you mean

[18:08] <timotimo> it seems the setting has gotten a tiny improvement itself from my optimisation

[18:08] <swarley> could I so something like

[18:08] * timotimo runs a spectest to get some timing information

[18:09] <timotimo> and goes get some food :)

[18:09] <timotimo> (and hopes nothing broke)

[18:09] <swarley> token foo { (<[~/]>) <string-content> <{ case $1 ... }> } ?

[18:09] <moritz> swarley: if it doesn't have to be parametric, you could write   token qlit { 'q%' ( <[~/<>]> ) <string-content> $1 }

[18:10] <swarley> Well, the issue is that it's supposed to have smart delimiters

[18:10] <moritz> swarley: and then a second rule for when the opening and closing delimiter are different

[18:10] <swarley> %q<foo>

[18:10] <swarley> oh

[18:10] <swarley> Yeah that could work

[18:10] <swarley> Thank you

[18:11] <timotimo> oh no, one subtest failed in the angle brackets metasyntax test suite :|

[18:11] <timotimo> is that my fault? o_O

[18:12] <FROGGS> think so, yesterday at that time everything was fine on current nqp/master + rakudo/nom

[18:12] <moritz> what's the failing test?

[18:13] <timotimo> moritz: i'll know soon. also, the people here are urging me to get going ;)

[18:13] <timotimo> more failures :(

[18:14] <timotimo> socket-inet takes so darned long :(

[18:14] <FROGGS> it does, ya

[18:14] <FROGGS> :(

[18:15] <timotimo> http://paste.ee/p/vcSjQ - here's the preliminary results

[18:15] <timotimo> could it be they are fixed in nom already and i just need to rebase?

[18:15] <timotimo> anyway, i'll get going

[18:16] <FROGGS> timotimo: you need to pull, the calender stuff is already fixed by masak

[18:16] <FROGGS> and the date thingeny too

[18:16] <FROGGS> not sure about angle-brackets though

[18:25] <moritz> that's what jnthn++ fixed half an hour earlier

[18:25] <moritz> and added the new test for

[18:26] <swarley> || forces it to work in order of left to right, correct?

[18:27] <moritz> right

[18:27] <swarley> { '(' <nes> ')' || '[' <nes> ']' || '{' <nes> '}' || '<' <nes> '>' || [<source-character>-<alnum>] <nes> $1 } would work then yes?

[18:28] <swarley> hm. I guess I should still subtract them out

[18:29] <moritz> [] doesn't capture

[18:29] <moritz> so $1 will be empty

[18:29] <swarley> oh, right

[18:29] * swarley fixes

[18:30] <moritz> and <source-character>-<alnum> also looks vaguely wrong

[18:35] <swarley> r: say "hello world" ~~ /<[ \x0000 .. \xFFFF ]>-<alnum>/

[18:35] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Invalid character for UTF-8 encoding␤␤»

[18:35] <swarley> r: say "hello world" ~~ /<[ \x0005 .. \xFFFF ]>-<alnum>/

[18:35] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Invalid character for UTF-8 encoding␤␤»

[18:35] <swarley> r: say "hello world" ~~ /<[ \x0005 .. \xAE43 ]>-<alnum>/

[18:35] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at /tmp/3A8gLkq3ru:1␤------> "hello world" ~~ /<[ \x0005 .. \xAE43 ]>⏏-<alnum>/␤Unable to parse regex; couldn't find final '/'␤at /tmp/3A8gLkq3r…

[18:35] <moritz> note that the - must be inside the <[ ... ]>

[18:35] <moritz> so

[18:36] <swarley> r: say "hello world" ~~ /<[\x0005..\xAE43]-<alnum>>/

[18:36] <moritz>  r: say "hello world" ~~ /<[ \x0005 .. \xAE43 ]-<alnum>]>/

[18:36] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket␤at /tmp/seKfmexjfm:1␤------> say "hello world" ~~ /<[\x0005..\xAE43]-⏏<alnum>>/␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper…

[18:36] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket␤at /tmp/YQB43KhUUt:1␤------> "hello world" ~~ /<[ \x0005 .. \xAE43 ]-⏏<alnum>]>/␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stoppe…

[18:36] <swarley> r: say "hello world" ~~ /<alnum>-<digit>/

[18:36] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at /tmp/EYGFCQGubk:1␤------> say "hello world" ~~ /<alnum>⏏-<digit>/␤Unable to parse regex; couldn't find final '/'␤at /tmp/EYGFCQGubk:1␤------>…

[18:36] <swarley> n: say "hello world" ~~ /<alnum>-<digit>/

[18:36] <p6eval> niecza v24-18-gaf64300: OUTPUT«===SORRY!===␤␤Unrecognized regex metacharacter - (must be quoted to match literally) at /tmp/xgaQCwIxSP line 1:␤------> say "hello world" ~~ /<alnum>-⏏<digit>/␤␤Unable to parse regex; couldn't find final '/' at /tmp/xga…

[18:36] <moritz>  r: say "hello world" ~~ /<[ \x0005 .. \xAE43 ]-[\w]>/

[18:36] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block : Unrecognized subtype 'zerowidth' in QAST::Regex cclass␤»

[18:37] <moritz> now that surely is a rakudo bug :-)

[18:37] <moritz> r: say 'hello world' ~~ / <+alnum-digit> /

[18:37] <p6eval> rakudo c356d8: OUTPUT«｢h｣␤␤»

[18:37] <moritz> r: say 'hello world' ~~ / <+alnum-digit>+ /

[18:37] <p6eval> rakudo c356d8: OUTPUT«｢hello｣␤␤»

[18:37] <swarley> wait, +?

[18:38] <moritz> to indicate it's a charclass, not a normal subroutine call

[18:38] <moritz> r: say "hello world" ~~ /<[ \x0005 .. \xAE43 ]-alnum>/

[18:38] <p6eval> rakudo c356d8: OUTPUT«｢ ｣␤␤»

[18:38] <swarley> So, what do I do about my token having [] in it?

[18:38] <moritz> this seems to be what you wanted :-)

[18:38] <swarley> errr

[18:38] <swarley> -

[18:39] <moritz> r: say 'a- ' ~~ /<[ \x0005 .. \xAE43 ]-alnum-[\-]>/

[18:39] <p6eval> rakudo c356d8: OUTPUT«｢a-｣␤␤»

[18:39] <moritz> huh.

[18:39] <swarley> n: say "hello world" ~~ /<alnum - digit>/

[18:39] <p6eval> niecza v24-18-gaf64300: OUTPUT«===SORRY!===␤␤Unrecognized regex metacharacter - (must be quoted to match literally) at /tmp/FKdUT0RkQO line 1:␤------> say "hello world" ~~ /<alnum -⏏ digit>/␤␤Unhandled exception: Unable to resolve method ast in type …

[18:39] <FROGGS> swarley: you might wanna use a named capture, instead of referring to $1

[18:39] <swarley> n: say "hello world" ~~ /<+alnum - digit>/

[18:39] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(1) text(h) pos([].list) named({}.hash)>␤»

[18:40] <swarley> Okay, that's better

[18:40] <swarley> what if I want a variable to go down a few levels of token calls?

[18:40] *** adu left
[18:41] <swarley> Would I just assert it and then call it up in the later token?

[18:41] <swarley> <{ my $foo = 'bar' }> ?

[18:45] <swarley> r: my token first { $letter }; my token proxy { <{ my $letter = 'f'; }> <first> }; say "foo" ~~ /<proxy>/

[18:45] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Variable '$letter' is not declared␤at /tmp/MN7J0eSPj3:1␤------> my token first { $letter⏏ }; my token proxy { <{ my $letter = 'f'␤»

[18:45] <swarley> r: my token first { $letter }; my token proxy { <{ our $letter = 'f'; }> <first> }; say "foo" ~~ /<proxy>/

[18:46] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Variable '$letter' is not declared␤at /tmp/H5RiWnYwv8:1␤------> my token first { $letter⏏ }; my token proxy { <{ our $letter = 'f␤»

[19:04] <swarley> r: my token first { $<x> }; my token proxy { $<x>=. <first> }; say "foo" ~~ /<proxy>/

[19:04] <p6eval> rakudo c356d8: OUTPUT«#<failed match>␤»

[19:04] <swarley> r: my token first { <{ say $<x> }> }; my token proxy { $<x>=. <first> }; say "foo" ~~ /<proxy>/

[19:04] <p6eval> rakudo c356d8: OUTPUT«Any()␤Any()␤Any()␤#<failed match>␤»

[19:05] <timotimo> i'm still failing datetime and calendar tests :(

[19:05] <swarley> r: my token first { $<x> }; my token proxy { $<x>='o' <first> }; say "foo" ~~ /<proxy>/

[19:05] <p6eval> rakudo c356d8: OUTPUT«#<failed match>␤»

[19:05] <timotimo> i wonder if it's my afult

[19:05] <swarley> r: my token first { <{ say 'o' eq $<x> }> }; my token proxy { $<x>='o' <first> }; say "foo" ~~ /<proxy>/

[19:05] <p6eval> rakudo c356d8: OUTPUT«use of uninitialized value of type Any in string context  in regex first at /tmp/42ZbTt1iuQ:1␤␤False␤use of uninitialized value of type Any in string context  in regex first at /tmp/42ZbTt1iuQ:1␤␤False␤#<failed match>␤»

[19:05] <swarley> r: my token first { <{ say 'o' eq $<x> }> }; my token proxy { $<x>=<[o]> <first> }; say "foo" ~~ /<proxy>/

[19:05] <p6eval> rakudo c356d8: OUTPUT«use of uninitialized value of type Any in string context  in regex first at /tmp/CEMaE94Pd6:1␤␤False␤use of uninitialized value of type Any in string context  in regex first at /tmp/CEMaE94Pd6:1␤␤False␤#<failed match>␤»

[19:06] <swarley> r: my token first { <{ say $<x> }> }; my token proxy { $<x>=<[o]> <first> }; say "foo" ~~ /<proxy>/

[19:06] <p6eval> rakudo c356d8: OUTPUT«Any()␤Any()␤#<failed match>␤»

[19:06] *** arlinius joined
[19:06] <swarley> r: say "foo" ~~ /$x=. $x/

[19:06] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Variable '$x' is not declared␤at /tmp/bzAZvnJzqa:1␤------> say "foo" ~~ /$x⏏=. $x/␤»

[19:07] <swarley> r: say "foo" ~~ /$x=<.> $x/

[19:07] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Variable '$x' is not declared␤at /tmp/B9yivKFWlA:1␤------> say "foo" ~~ /$x⏏=<.> $x/␤»

[19:07] <swarley> r: say "foo" ~~ /$0=<.> $0/

[19:07] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter = (must be quoted to match literally)␤at /tmp/Jl8q_uZDS0:1␤------> say "foo" ~~ /$0=<.⏏> $0/␤Unable to parse regex; couldn't find final '/'␤at /tmp/Jl8q_uZDS0:1␤------> say "foo…

[19:07] <FROGGS> r: say "foo" ~~ /$<x>=<.> $<x>/

[19:07] <p6eval> rakudo c356d8: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter = (must be quoted to match literally)␤at /tmp/g73MUOFTIY:1␤------> say "foo" ~~ /$<x>=<.⏏> $<x>/␤Unable to parse regex; couldn't find final '/'␤at /tmp/g73MUOFTIY:1␤------> say …

[19:07] <swarley> r: say "foo" ~~ /$0=<(.)> $0/

[19:07] <p6eval> rakudo c356d8: OUTPUT«#<failed match>␤»

[19:07] <FROGGS> r: say "foo" ~~ /$<x>=[.] $<x>/

[19:08] <p6eval> rakudo c356d8: OUTPUT«｢oo｣␤ x => ｢o｣␤␤»

[19:08] <swarley> Oh, will that persist multiple levels of tokens?

[19:08] <FROGGS> no idea

[19:08] <swarley> r: my token first { $<x> }; my token proxy { $<x>=[.] <first> }; say "foo" ~~ /<proxy>/

[19:08] <p6eval> rakudo c356d8: OUTPUT«#<failed match>␤»

[19:09] <swarley> r: my token first { <{say $<x>}>}; my token proxy { $<x>=[.] <first> }; say "foo" ~~ /<proxy>/

[19:09] <p6eval> rakudo c356d8: OUTPUT«Any()␤Any()␤Any()␤#<failed match>␤»

[19:09] <swarley> grr

[19:10] <FROGGS> r: my $X; my token first { <{say $X}> }; my token proxy { $<x>=[.] { $X = $<x> } <first> }; say "foo" ~~ /<proxy>/

[19:10] <p6eval> rakudo c356d8: OUTPUT«｢f｣␤␤｢o｣␤␤｢o｣␤␤#<failed match>␤»

[19:10] * timotimo runs a spectest without his optimisations for comparison

[19:10] <FROGGS> r: my $X; my token first { <{say $X}> <{$X}> }; my token proxy { $<x>=[.] { $X = $<x> } <first> }; say "foo" ~~ /<proxy>/

[19:10] <p6eval> rakudo c356d8: OUTPUT«｢f｣␤␤｢o｣␤␤｢o｣␤␤#<failed match>␤»

[19:11] <timotimo> i'm expecting the startup time due to optimisations will make the tests pass slower, because junctions aren't used very often

[19:11] <FROGGS> r: my $X; my token first { <{say $X}> <{$X}> }; my token proxy { $<x>=[.] { $X = $<x> unless $X } <first> }; say "foo" ~~ /<proxy>/

[19:11] <timotimo> but who knows?

[19:11] <p6eval> rakudo c356d8: OUTPUT«｢f｣␤␤｢f｣␤␤｢f｣␤␤#<failed match>␤»

[19:11] <FROGGS> r: my $X; my token first { <{say $X}> <{~$X}> }; my token proxy { $<x>=[.] { $X = $<x> unless $X } <first> }; say "foo" ~~ /<proxy>/

[19:11] <p6eval> rakudo c356d8: OUTPUT«｢f｣␤␤｢f｣␤␤｢f｣␤␤#<failed match>␤»

[19:12] *** Exodist left
[19:12] <FROGGS> r: my $X; my token first { <{say $X}> <{~$X}> }; my token proxy { $<x>=[.] { $X = $<x> } <first> }; say "foo" ~~ /<proxy>/

[19:12] <p6eval> rakudo c356d8: OUTPUT«｢f｣␤␤｢o｣␤␤｢o｣␤␤#<failed match>␤»

[19:12] <FROGGS> bah

[19:14] <FROGGS> timotimo: do you know how long the testsuite takes, so you can compare?

[19:14] <timotimo> yes

[19:14] <timotimo> Files=722, Tests=26726, 1099 wallclock secs ( 4.20 usr  1.24 sys + 868.91 cusr 74.60 csys = 948.95 CPU)

[19:14] <timotimo> takes quite a while :(

[19:17] <FROGGS> at work I could do TEST_JOBS=16, but I've got no rakudo there :/

[19:17] <timotimo> i chose to use only 1 of 4

[19:17] <timotimo> may have been a bad idea

[19:20] *** SunilJoshi left
[19:31] <timotimo> without the optimisation: Files=722, Tests=26726, 1098 wallclock secs ( 4.32 usr  1.16 sys + 868.31 cusr 73.53 csys = 947.32 CPU)

[19:32] <timotimo> about 0.1% impact when not really used

[19:32] <timotimo> that seems decent.

[19:39] <timotimo> wait what. i'm confuse.

[19:39] *** SamuraiJack left
[19:39] <timotimo> perl6 junction_benchmark.p6  5.10s user 0.10s system 99% cpu 5.213 total  (unoptimised)  vs  perl6 --optimize=3 junction_benchmark.p6  3.06s user 0.14s system 99% cpu 3.217 total

[19:39] <timotimo> that seems like a decent win in a junction-heavy benchmark

[19:45] <FROGGS> ohh, ya

[20:01] *** tadzik left
[20:02] *** Util left
[20:02] *** Juerd left
[20:04] *** Juerd joined
[20:04] *** hugme left
[20:04] *** Util joined
[20:05] *** [Coke] left
[20:05] *** [Coke] joined
[20:05] *** hugme joined
[20:05] *** ChanServ sets mode: +v hugme

[20:18] <timotimo> maybe i can encourage perl6ers to use more junctions

[20:26] *** b1rkh0ff joined
[20:29] *** tadzik joined
[20:33] <timotimo> jnthn: i'd be interested to know how we could turn junctions into junction objects at optimizer time. could you explain that when you come back? maybe i can even implement it

[20:39] *** zby_home left
[20:44] <timotimo> also, my optimisation didn't bail out when faced with a custom infix:<|>. apparently my checks were not helpful :(

[20:45] <moritz> you call infix:<|>

[20:45] <timotimo> i did what?

[20:46] <moritz> you didn't. But that's how you'd create a Junction object

[20:47] <timotimo> ok, and then? can i just put it into the ast? just like that? or maybe in a QAST::Var?

[20:47] <moritz> you do $*W.add_object($junction)

[20:47] <moritz> and then QAST::WVal(:value($junction))

[20:48] <timotimo> that seems remarkably simple

[20:48] <moritz> timotimo: also of interest might be Perl6::World.compile_time_evaluate

[20:51] <timotimo> first, i need to figure out why it's nonfunctional at the moment :(

[20:56] <timotimo> http://paste.ee/p/zrKEL - can you see why it doesn't say woop?

[20:56] <timotimo> when i put 1 | 2 == 1 instead, it does

[20:56] <timotimo> that's what confuses me profoundly

[21:00] <moritz> what is this 'chain' thingy?

[21:03] <timotimo> er, i glomped it from context :|

[21:03] <moritz> timotimo: can you please nopaste the code that generated it?

[21:03] <timotimo> sure

[21:03] <timotimo> is a diff against current nom okay, too?

[21:04] <moritz> yes, that's what I wanted :-)

[21:05] <timotimo> http://sprunge.us/EDIZ

[21:10] <moritz> timotimo: do you know what :op<chain> does?

[21:11] <moritz> because I suspect it's something AND-like

[21:11] <moritz> but a |-Junction needs something OR-like

[21:12] <timotimo> i'm afraid not. but :op($juncop> seems to have been wrong

[21:14] <moritz> I'd try to compile   1 | 2  == $thing to a chain of 'unless' ops

[21:14] <moritz> and & to a chain of 'if' ops

[21:16] *** pupoque joined
[21:16] <timotimo> trying it now

[21:19] *** grondilu left
[21:22] <timotimo> yes, that works. great!

[21:23] <timotimo> moritz: can you tell why my "is_from_core" doesn't work properly? :(

[21:24] <timotimo> when i define a sub infix:<&>($a, $b) { say "$a, $b"; all($a, $b) } and do if 2 & 2 == 2 { say "woop" } i get "woop", but not "$a, $b"

[21:24] <timotimo> unless i turn off my optimization :|

[21:24] * moritz takes a look

[21:25] *** preflex joined
[21:25] <moritz> timotimo: where exactly is CORE_MARKER installed?

[21:25] <timotimo> allegedly in the block that contains all the things from CORE.setting

[21:26] <moritz> ok, two things

[21:26] <moritz> the first problem is that if you define your own infix:<|>, then it'll first find this one

[21:26] <moritz> then the code walks to the outer blocks too

[21:26] <moritz> und then finds the one from CORE, and returns 1

[21:27] <timotimo> wait, i had a return 0 there! where did it go?!

[21:27] <timotimo> i put it into the wrong function >_<

[21:27] <timotimo> i should not be surprised.

[21:29] <moritz> and secondly, shouldn't you be looking for !CORE_MARKER in $block instead of %sym?

[21:29] <timotimo> allegedly it's a lexical in the block

[21:30] <moritz> that's why I think it should be in $block, not in %sym

[21:30] <timotimo> before i had is_from_core like find_lexical, only that it returned the block instead of a lexical and then i compared the CORE::infix:<&> with the one find_lexical found

[21:30] <moritz> that would have been my approach too

[21:34] <timotimo> yaaaay, it works now/again

[21:34] <moritz> \o/

[21:34] <timotimo> i felt this approach would be more performant. also it's how jnthn suggested it at the start

[21:35] <timotimo> i should come up with a test suite that checks many different cases properly

[21:36] <timotimo> about the only place that uses junctions, ever, is masaks time code :)

[21:36] <timotimo> when second | seconds etc etc

[21:38] <moritz> timotimo: note that &infix:<|> and &any are basically the same thing

[21:38] <moritz> and that both can take more than two args

[21:40] <timotimo> yes. what exactly is this important for?

[21:40] <timotimo> do you think i should do the exact same with any, too?

[21:40] <moritz> yes

[21:41] <moritz> oh, and you should only do the transformation in boolean context

[21:41] <timotimo> i only do it if there's an if or unless directly outside

[21:41] <timotimo> so i already got that covered, i think

[21:41] *** quester joined
[21:42] <moritz> ah great

[21:42] <timotimo> actually, it seems to fire on "when", too, without me having to do anything special

[21:42] *** kaare_ left
[21:42] <moritz> a 'when' compiles to an 'if' (plus a bit stuff)

[21:43] <moritz> oh, and a 'while' or 'until' on the outside would als be OK

[21:43] <timotimo> i'll quickly check if that already happens

[21:44] <timotimo> doesn't seem so

[21:44] <timotimo> i'll try to remember that as a todo item

[21:45] <timotimo> is there a third junction that i can turn into a simpler logical thing? i don't think so

[21:46] <moritz> none()

[21:46] <moritz> is a negated all()

[21:47] <moritz> so you can do the same as for &, but switch the branches of the 'if'

[21:47] <moritz> (I think)

[21:47] <timotimo> ah, neat.

[21:47] <timotimo> so turn the if into an unless?

[21:48] <moritz> no, then you have the | 

[21:48] <timotimo> oh, indeed

[21:48] <timotimo> what do you mean switch the branches for if?

[21:48] *** pupoque left
[21:49] <moritz> QAST::Var.new(:op<if>, $a, $b) -> QAST::Var.new(:op<if>, $b, $a)

[21:49] *** pupoque joined
[21:49] <timotimo> wait, no, that's not right

[21:49] <moritz> erm wait

[21:50] <timotimo> $a, Nil, $b

[21:50] <timotimo> er, no still different

[21:50] * moritz watches a movie at the same time, so his brain is only half there

[21:50] <timotimo> $a, $b, $c turns into $a, $c, $b

[21:50] <timotimo> and if $c doesn't exist, what do i do then?

[21:50] <moritz> none($a, $b, $c) == 3    is the same as   prefix:<!>( all($a, $b, $c) == 3 )

[21:51] <timotimo> i can do that, too, sure

[21:51] <moritz> erm, still wrong

[21:51] <moritz> none = ! any

[21:51] <moritz> so s/all/any/ in the previous line

[21:51] <moritz> erm not quite previous

[21:52] <moritz> I hope you know what I mean :-)

[21:52] <timotimo> er, yes

[21:52] <timotimo> i do

[21:54] *** PacoAir left
[21:57] <timotimo> GlitchMr: you missed a few places where suggestions happen

[21:58] *** MayDaniel left
[22:02] <timotimo> namely in my *HERE* $foo;

[22:02] <timotimo> and, er, i think another place, too

[22:02] <swarley> Well.. Now that I have 330 lines of tokens

[22:03] <timotimo> but thanks for mentioning those things :)

[22:03] <swarley> I have no idea how to start working on the grammar

[22:04] <timotimo> hah :)

[22:04] <timotimo> well, you start with a TOP rule ;)

[22:04] <swarley> alright.. I suppose that's more than i had planned already

[22:05] * swarley is not even sure what would make up a program body in terms of grammar

[22:05] <swarley> I guess. <statement>* ?

[22:06] <moritz> swarley: what are you trying to parse?

[22:06] <swarley> Ruby, I've been working on the grammar for about two weeks now. I don't like the cardinal implementation so much

[22:07] <timotimo> are you implementing a ruby compiler in nqp?

[22:07] <timotimo> that will target QAST?

[22:07] <swarley> I'm using PCT

[22:07] <timotimo> maybe your implementation will get more popular than JRuby :)

[22:07] <timotimo> Perl6 Compiler Toolkit?

[22:07] <swarley> yes

[22:08] * swarley sighs

[22:08] <swarley> I've always had trouble with grammars

[22:08] <swarley> Lexing is alright

[22:08] <swarley> But grammars will be the death of me

[22:08] <timotimo> perl6 compiler toolkit is a thing?

[22:08] <moritz> don't worry, you'll get used to it :-)

[22:09] <timotimo> ah, parrot compiler toolkit, duh

[22:09] <swarley> whoops, I misread what you said

[22:09] <swarley> I didn't read closely enough

[22:09] <moritz> timotimo: it's the predecessor of NQP + QAST compiler

[22:09] <swarley> I'm behind again already? :(

[22:09] <swarley> Is there something new that I should be looking into using instead?

[22:09] <timotimo> swarley: yeah, parrot is being deprecated

[22:09] <timotimo> :P

[22:10] <swarley> asdfghjkl;

[22:10] <timotimo> well, maybe not yet

[22:10] <swarley> Alright, link me

[22:10] <moritz> swarley: nqp

[22:10] <moritz> https://github.com/perl6/nqp/

[22:10] <swarley> Ah. do they have a mk_language_shell.pl equiv?

[22:10] <moritz> I don't think so :(

[22:10] <timotimo> moritz: oh my, it seems like using any isn't quite as easy as just saying "do the stuff for any, too!"

[22:11] <moritz> timotimo: :(

[22:11] * moritz needs to get some sleep now

[22:11] <moritz> ciao

[22:11] <timotimo> because it has a Stmts with infix:<,> in it

[22:11] <timotimo> bye morits, and thanks for all the help!

[22:11] <swarley> Alright.. Well then, I'm going to need even more help, or some pointers to documentation on how I would go about this in NQP instead.

[22:11] * swarley clones

[22:12] <swarley> I thought reading the rakudo grammar would help. Nope :p still huge and beyond me

[22:13] <timotimo> heh

[22:13] <timotimo> the nqp grammar is a bit smaller

[22:13] *** pupoque left
[22:13] <swarley> Well, that may help then

[22:13] <swarley> Reading the cardinal grammar is just.. Not helpful at all really

[22:14] <timotimo> hehe :)

[22:14] <swarley> plus it's in perl-grammar

[22:15] <swarley> I'm not exactly sure how the whole proto 'infix:/' is equiv('infix:*')  { ... }

[22:15] <swarley>  works

[22:15] <swarley> Is that precendence at work?

[22:16] <colomon> yes

[22:16] <swarley> looking at the cardinal source though, I'm doing much more work than I need to

[22:17] <colomon> it's saying / has the same precedence as *

[22:17] <swarley> oh, okay, well what is the { ... } ?

[22:17] <swarley> Is that just a void block?

[22:17] <colomon> exactly

[22:17] <swarley> Alright then

[22:20] <swarley> I know I seem rather unqualified to be attempting this, but I promise I'll be more independent once I get out of the parsing stage >.>, it just seems like I'm learning 3 new languages to get this done.

[22:22] <timotimo> swarley: i'm doing the same thing, constantly asking dumb questions, but i'm slowly improving

[22:26] <flussence> if you've got this far, there are no dumb questions

[22:38] * swarley waits for rakudo to finish building

[22:38] <swarley> that "Stage start     :   0.000" is mocking me silently, I just know it

[22:39] <timotimo> :))

[22:40] <swarley> blah. Maybe I should go make a sandwich or something lol.

[22:42] <swarley> I wish I could see progress :(

[22:42] <swarley> It's just a lonely blinking prompt staring into my soul

[22:43] <flussence> `watch cat /proc/$(pidof parrot)/status` :D

[22:45] <swarley> welp, `ps aux | grep parrot' seems to have slowed down my machine a good amount

[22:45] *** aindilis left
[22:46] <timotimo> are you swapping massively?

[22:46] <swarley> 512mb swap

[22:46] * timotimo is doing all his rakudo coding on his desktop via SSH, because the desktop is almost 2x as fast when building rakudo

[22:46] <swarley> I'm doing it in a VM of gentoo

[22:47] <timotimo> oh, good idea, gentoo is very fast!

[22:47] <swarley> That was my though when I set it up.

[22:47] <swarley> I only planned on using the VM for ruby and perl6

[22:47] <swarley> So I wanted the speed more than anything

[22:50] <timotimo> not actually serious about that. i set up a vm with linux mint and saw it's nice, so now i've got a vm with mint and mint natively, too

[22:52] <swarley> I've got mint as my main OS on this computer

[22:53] <swarley> I'm in windows because I've been having to do some skype calls and I've been playing games with friends

[22:53] <swarley> Otherwise, I wouldn't be able to stand it

[22:55] * swarley hopes the build finishes within 10 minute

[22:55] <swarley> s

[23:04] <timotimo> what exactly are you building?

[23:04] <swarley> So, for the protos, i.e 

[23:04] <swarley> proto token infix { <...> }

[23:04] <swarley>     proto token prefix { <...> }

[23:04] <swarley> Do they just group names?

[23:05] <swarley> I just ran `make install` in rakudo/rakudo

[23:05] <timotimo> that takes 10 minutes?!

[23:05] <timotimo> you are on nom/ right?

[23:05] <swarley> Yes

[23:05] <swarley> It's not done yet

[23:05] <timotimo> wat.

[23:05] <tadzik> it may take time on slow machines

[23:06] <timotimo> takes only 2 minutes on my desktop, 4 minutes on my laptop

[23:06] * swarley ** WinSys ** Client: HexChat 2.9.1 (x64) ** OS: Microsoft Windows 7 Ultimate  ** CPU: AMD Phenom(tm) II P650 Dual-Core Processor (2.00 GHz) ** RAM: 3834 MB Total (1822 MB Free) ** VGA: ATI Mobility Radeon HD 4200 ** Uptime: 2.35 Hours **

[23:07] <timotimo> well, the build only uses one core anyway, so ...

[23:07] <timotimo> Intel(R) Core(TM)2 Duo CPU     L9400  @ 1.86GHz

[23:07] <timotimo> are you sure you're not running out of RAM in your virtual machine?

[23:07] <swarley> Pretty sure

[23:07] <swarley> It's allowed to use all of it

[23:07] <swarley> let me check

[23:08] <timotimo> and you turned on hardware virtualisation in your BIOS?

[23:08] <timotimo> i'm surprised. on your machine it should really not take that long

[23:09] <swarley> 4mb free

[23:09] <swarley> in ram

[23:09] <swarley> Tons of free swap

[23:09] <timotimo> wow, how can that be right?

[23:09] <swarley> No idea

[23:09] <timotimo> are you looking at free -m?

[23:09] <swarley> It did this when I tried to compile it natively too

[23:09] <swarley> yes

[23:10] <swarley> When I compiled it in mint it crashed my computer the first time

[23:10] <timotimo> you know you have to look into the line starting with "+/- cache/buffers"?

[23:10] <swarley> Yes

[23:10] <timotimo> that's weird :)

[23:11] <swarley> Yeah, when I tried to run it under mint natively it locked my computer up

[23:11] <swarley> I had to restart and try again

[23:11] <timotimo> maybe it hit some memory limit and died. the last time it called die during the CORE.setting compilation it just stopped executing, but did 100% cpu usage

[23:12] <swarley> 88% cpu usage when I just killed it

[23:13] <timotimo> unfortunately you can't see where it stopped when you killed it

[23:13] <timotimo> or even cause it to emit a stack trace at some point

[23:13] <swarley> :(

[23:13] <timotimo> i would love that feature :(

[23:13] <swarley> Yeah, I'm really not wanting to sit here all day and wait for this..

[23:15] <swarley> I'll just build NQP and play with that for now since it's all I really need

[23:15] <swarley> I'll get back to rakudo later

[23:15] <swarley> But yeah, what is the real purpose of proto?

[23:16] <swarley> It seems like a namespace as far as I can tell

[23:16] * timotimo doesn't really know either

[23:16] <swarley> I can't tell if infix:sym<blah> does magic or anything..

[23:26] <timotimo> i think the magic is that you can use <sym> to match "blah" in that token there

[23:36] *** spider-mario left
[23:41] <swarley> Like, what does this represent?

[23:41] <swarley>     token infix:sym<**>   { <sym>  <O('%exponentiation')> }

[23:45] *** quester left
[23:49] <timotimo> that means it matches a ** as an infix (like the proto prescribes) and creates a %exponentiation Op QAST node

[23:50] <timotimo> (at least i think it does!)

[23:50] <timotimo> the O is probably defined in one of the Action perl modules

[23:52] *** wrc joined
[23:52] <wrc> game pre pc

[23:52] <wrc> game per pc

[23:53] *** wrc left
[23:57] *** quester joined
[23:59] *** quester left
