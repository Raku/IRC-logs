[00:09] <dalek> rakudo/nom: 5a1e607 | jnthn++ | src/core/MapIter.pm:

[00:09] <dalek> rakudo/nom: Fast-path for common case in MapIter on JVM.

[00:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a1e607503

[00:09] <dalek> rakudo/nom: 76c3008 | jnthn++ | src/core/MapIter.pm:

[00:09] <dalek> rakudo/nom: A couple more MapIter optimizations.

[00:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/76c3008c51

[00:09] <dalek> rakudo/nom: f164c0f | jnthn++ | src/core/ (2 files):

[00:09] <dalek> rakudo/nom: A couple more buffer pre-size optimizations.

[00:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f164c0f776

[00:09] *** eternaleye left
[00:10] <jnthn> Those make a 30s thing into a 7s thing... :)

[00:10] *** eternaleye joined
[00:15] <jnthn> .tell sorear for ^64 X ^64 -> $i, $j { $i + $j } seems to generate a stack overflow, even though METAOP_CROSS (src/core/metaops.pm) is using an iterative, not recursive, algorithm. Could it be something with gather/take?

[00:15] <yoleaux> jnthn: I'll pass your message to sorear.

[00:17] *** eternaleye left
[00:18] <jnthn> .tell sorear it does appear to be a huge number of the block that does nqp::continuationinvoke piled up on the stack, having dug a little further.

[00:18] <yoleaux> jnthn: I'll pass your message to sorear.

[00:22] *** eternaleye joined
[00:29] <jnthn> 'night, #perl6

[00:31] *** colomon joined
[00:56] <TimToady> the use of $*FATAL in rakudo to define fail semantics looks a bit suspicious to me, unless every single dynamic scope sets it true or false according to its lexical context, which I doubt

[00:57] <Teratogen> kill it with fire!

[00:59] * TimToady shoots firewords sideways at the spectators

[00:59] <TimToady> *works

[01:00] * TimToady goes to fetch Pollo Loco &

[01:01] *** FROGGS_ joined
[01:19] *** raiph joined
[01:32] *** colomon left
[01:42] *** ztt joined
[01:54] *** colomon joined
[02:10] *** aindilis joined
[02:18] <timotimo> jnthn: http://t.h8.lv/p6bench/2013-07-05_mapiter_improv.html - you made it better!

[02:20] *** jaldhar joined
[02:30] *** SamuraiJack joined
[02:31] *** jaldhar left
[02:34] *** jaldhar joined
[02:46] <benabik> timotimo: That's a lot of graphs.

[02:49] <labster> it sure is a lot of them

[03:01] *** SamuraiJack left
[03:02] *** SamuraiJack joined
[03:03] <sorear> good * #perl6

[03:03] <yoleaux> 00:15Z <jnthn> sorear: for ^64 X ^64 -> $i, $j { $i + $j } seems to generate a stack overflow, even though METAOP_CROSS (src/core/metaops.pm) is using an iterative, not recursive, algorithm. Could it be something with gather/take?

[03:03] <yoleaux> 00:18Z <jnthn> sorear: it does appear to be a huge number of the block that does nqp::continuationinvoke piled up on the stack, having dug a little further.

[03:16] <JimmyZ> good * sorear 

[03:21] *** colomon left
[03:27] <sorear> o/, JimmyZ

[03:32] *** BenGoldberg left
[03:34] *** colomon joined
[03:37] *** xilo_ left
[03:39] *** xilo_ joined
[03:47] *** colomon left
[03:53] *** SamuraiJack left
[03:54] *** ztt left
[04:04] *** benabik left
[04:35] *** benabik joined
[04:39] *** benabik left
[04:39] *** benabik joined
[04:52] <labster> r: sub foo { foo(); }; my $a = try foo(); say "alive"; say $!;

[04:52] <camelia> rakudo f164c0: OUTPUT¬´(timeout)alive‚ê§¬ª

[04:53] <labster> is $! infinite looping there?

[04:55] *** crab2313 joined
[05:01] *** crab2313 left
[05:13] <TimToady> I doubt it, but it's probably got a huge stack trace to process

[05:15] <Teratogen> I've done a lot of perl 5 but very little perl 6

[05:15] <Teratogen> am I going to have to learn a whole new language?

[05:16] <sorear> really, Teratogen?  this again?

[05:16] *** kaare_ joined
[05:16] <sorear> it's not funny.

[05:19] <Teratogen> it was not meant to be funny

[05:19] <Teratogen> the more examples of perl 6 I see on this channel the more DIFFERENT it seems to be from perl 56

[05:19] <Teratogen> the more examples of perl 6 I see on this channel the more DIFFERENT it seems to be from perl 5

[05:20] <Teratogen> but... I am going to sleep

[05:20] <Teratogen> night all!

[05:20] <Teratogen> =D

[05:21] <geekosaur> apparently you've not done enough perl5 to understand its limitations

[05:37] *** mstefanko joined
[05:38] <labster> TimToady: Looking at S05:4618 - 4629.  Is cat supposed to be join there?

[05:39] <TimToady> no, cat is something that just pretends to be a string

[05:39] <TimToady> NYI

[05:39] <sorear> labster: cat is lazy join

[05:40] *** raiph left
[05:40] <labster> oh, hadn't seen it yet.

[05:41] <sorear> cat map { *~" " }, 1..* # returns a one-sided infinite rope of all the integers

[05:41] <sorear> NYI.

[05:41] <TimToady> supposed to make an array or list look like a string good enough to do matching on, without necessarily doing an actual join

[05:41] <sorear> will probably be easy enough to do once we have (strict) ropes

[05:41] <labster> Cool.  Then I can do Dog.cat

[05:42] <TimToady> gotta work a Rat in there too

[05:43] <sorear> we have Dogs in the spec now? o_O

[05:44] <TimToady> sure, but they're all meta-Dogs

[05:44] <labster> grep says Dog is in nine specs

[05:50] <TimToady> one might say they're all foo dogs..

[05:51] <sorear> metasyntactic dogs?

[05:52] <sorear> .oO( since orthosyntax stole ... ??? !!!, metasyntax has had to make do with Dog )

[05:52] *** xilo_ left
[05:53] <TimToady> std: .oO(...)

[05:53] <camelia> std 85cf51d: OUTPUT¬´ok 00:00 42m‚ê§¬ª

[06:01] * TimToady has to wonder, as a one-time organic chemist, what parasyntax would be...

[06:13] <labster> syntax for parakudo?

[06:18] *** jaldhar left
[06:19] *** jaldhar joined
[06:36] <sorear> that may have been the joke

[06:36] <moritz> good morning

[06:37] * moritz just had pancakes with ice cream and fresh strawberries for breakfast o/

[06:37] <sorear> good morning moritz \o/ yum

[06:40] * TimToady was referring to relative positions of two radicals on benzene rings: http://www.mhhe.com/physsci/chemistry/carey/student/olc/graphics/carey04oc/ch12/figures/omp.gif

[06:42] *** PacoAir joined
[06:43] <moritz> reading the postgres docs can be amusing, occasionally. For example http://www.postgresql.org/docs/9.1/static/datatype-character.html

[06:43] <moritz> An attempt to store a longer string into a column of these types will result in an error, unless the excess characters are all spaces, in which case the string will be truncated to the maximum length. (This somewhat bizarre exception is required by the SQL standard.)

[06:46] <sorear> mmm, punchcardisms?

[06:47] <JimmyZ> moritz: INSERT INTO test VALUES ('12345678'::varchar(5)); won't be in an error

[06:50] *** kaare__ joined
[06:51] <moritz> it is also slightly obscure that 'time' (time of day without date) takes up more storage space than 'timestamp' (time of day + date)

[06:53] *** cognominal joined
[06:53] <sorear> obscure, indeed...

[06:53] *** kaare_ left
[06:58] *** berekuk left
[06:59] *** Rotwang joined
[07:01] *** berekuk joined
[07:01] *** aindilis left
[07:01] <moritz> another gem from the pg docs: " conventions before the 19th century make for interesting reading, but are not consistent enough to warrant coding into a date/time handler."

[07:42] *** domidumont joined
[07:43] *** FROGGS_ is now known as FROGGS

[07:43] *** PacoAir left
[07:43] <FROGGS> gmorning

[07:44] <sorear> o/ FROGGS

[07:52] * sorear peeks in bin/org/perl6/nqp/runtime/ and realizes that all but one of the nested classes are his fault

[08:00] <dalek> roast: ec62150 | (Brent Laabs)++ | S05-match/capturing-contexts.t:

[08:00] <dalek> roast: RT #117461 Test for Match.lines (which really means Match ~~ Cool)

[08:00] <dalek> roast: review: https://github.com/perl6/roast/commit/ec62150af9

[08:02] *** domidumont left
[08:03] *** araujo joined
[08:19] <labster> rn: r: class A { state $x = 0; method inc { ++$x }; }; say A.inc, A.inc, (my $x = A.new).inc, A.inc, $x.inc;

[08:19] <camelia> niecza v24-86-g39ab531: OUTPUT¬´55555‚ê§¬ª

[08:19] <camelia> ..rakudo f164c0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/E2iHoBLE4K:1‚ê§------> [32mr[33m‚èè[31m: class A { state $x = 0; method inc { +[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        statem‚Ä¶

[08:19] <labster> rn: class A { state $x = 0; method inc { ++$x }; }; say A.inc, A.inc, (my $x = A.new).inc, A.inc, $x.inc;

[08:19] <camelia> rakudo f164c0: OUTPUT¬´12345‚ê§¬ª

[08:19] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´55555‚ê§¬ª

[08:21] <sorear> surprised rakudo gets that wrong:

[08:21] <sorear> rn: my $x = 3; (++$x) *= 2; say $x

[08:21] <camelia> niecza v24-86-g39ab531: OUTPUT¬´8‚ê§¬ª

[08:21] <camelia> ..rakudo f164c0: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in block  at src/gen/CORE.setting:14368‚ê§  in block  at /tmp/RNV3r6prvd:1‚ê§‚ê§¬ª

[08:22] <sorear> well, "wrong" is arguable I guess

[08:22] <sorear> but in niecza prefix:<++> has always returned a lvalue

[08:23] <sorear> because it doesn't allocate any containers - it modifies the argument in place and returns it

[08:23] <sorear> also it predates the read-only scalar container elision optimization

[08:24] <sorear> testing with perl5 seems to indicate that both prefix:<++> and postfix:<++> return lvalues o_O

[08:24] <labster> .oO ( kyrie containers )

[08:25] <labster> prefix:<++> as an lvalue seems sane enough.

[08:25] <sorear> anyway, lvalueness means that say() receives an argument list containing five of the same container

[08:25] <sorear> which of course all have the same value

[08:26] <labster> ah, indeed.

[08:27] <labster> the whole 'state $x' sharing a variable between instances -- that maybe should be documented :/

[08:27] <sorear> erm

[08:27] <sorear> rn: class A { my $x = 0; method inc { ++$x }; }; say A.inc, A.inc, (my $x = A.new).inc, A.inc, A.inc;

[08:28] <camelia> niecza v24-86-g39ab531: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/lDc2fPCk9b line 1:‚ê§------> [32m inc { ++$x }; }; say A.inc, A.inc, (my [33m‚èè[31m$x = A.new).inc, A.inc, A.inc;[0m‚ê§‚ê§55555‚ê§¬ª

[08:28] <camelia> ..rakudo f164c0: OUTPUT¬´12345‚ê§¬ª

[08:28] <sorear> you're not seeing any special behavior of state in this example.

[08:28] <sorear> it's shared between instances because *it's declared outside the method*

[08:29] <labster> S04: Separate clones of the closure get separate state variables. However, recursive calls to the same clone use the same state variable.

[08:29] <labster> classes aren't closures per se?

[08:29] <sorear> At no point do you clone the closure which owns "state $x"

[08:29] <sorear> which is the class body sub, which is executed only once in any event

[08:30] <sorear> s/sub/block/

[08:30] <labster> fairy nuff

[08:30] <sorear> also my/our/state/anon variables are completely orthogonal to the object system

[08:31] <sorear> if you want each instance of an object to have its own version of a variable, use "has"

[08:33] <labster> sorear++

[08:33] <labster> that needs to be explained more clearly somewhere

[08:49] <moritz> http://doc.perl6.org/language/objects#Attributes # like this?

[08:51] *** FROGGS left
[08:52] *** preflex joined
[08:52] *** ChanServ sets mode: +v preflex

[08:55] <labster> not exactly like that, because that doesn't say what happens with my/our/state in classes

[08:55] <labster> nor is http://perlcabal.org/syn/S12.html#Class_attributes all that clear on the subject

[09:01] <lizmat> good *, #perl6!

[09:01] <lizmat> (still checking on backlog)

[09:01] <lizmat> meanwhile: for is the same as map, right?

[09:01] <lizmat> r: sub a { for 1..3 { return $_ } }; say a  # works

[09:01] <camelia> rakudo f164c0: OUTPUT¬´1‚ê§¬ª

[09:01] <lizmat> r: sub a { (1..3).map( { return $_ } ) }; say a # doesn't work

[09:01] <camelia> rakudo f164c0: OUTPUT¬´Attempt to return outside of any Routine‚ê§  in block  at src/gen/CORE.setting:486‚ê§  in block  at /tmp/Yl0CJbNEKO:1‚ê§‚ê§¬ª

[09:02] <lizmat> is this a rakudobug?

[09:04] *** iSlug joined
[09:07] <sorear> it's a side effect of map being lazy

[09:07] <sorear> and return being lexotic and binding only to 'a'

[09:08] <sorear> error message is misworded

[09:08] <masak> good antenoon, #perl6

[09:08] <sorear> o/ masak!!!

[09:11] <lizmat> n: sub a { (1..3).map( { return $_ } ) }; say a

[09:11] <camelia> niecza v24-86-g39ab531: OUTPUT¬´Unhandled exception: Cannot unbox a Variable[] from an object of repr P6box[Int32]‚ê§  at <unknown> line 0 (KERNEL map @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2618 (GatherIterator.reify @ 6) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p‚Ä¶

[09:12] <lizmat> masak!

[09:12] *** spider-mario joined
[09:15] <dalek> rakudo/nom: 5c61f12 | (Elizabeth Mattijsen)++ | src/core/Nil.pm:

[09:15] <dalek> rakudo/nom: Add reference to BOOTSTRAP

[09:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5c61f12234

[09:18] <masak> so, 18:00Z tonight, then. some more sprintf hacking.

[09:18] <masak> I'll be away for a while. going to go attent a friend's wedding. but I'll be back in time for 18:00Z :)

[09:23] <masak> does Teratogen have a reset function which makes him come back and ask the same questions again and again?

[09:24] <masak> (re backlog)

[09:24] <masak> I'm not upset or irritated or anything. but if we understand Teratogen's reset function semantics better, maybe we can answer his personal FAQs better.

[09:25] <sorear> sorear$ ./nqp -e 'my %h := nqp::jvmbootinterop("java.lang.Thread"); say(%h<method:toString()Ljava/lang/String;>(%h<static_method:currentThread()Ljava/lang/Thread;>()))'

[09:25] <sorear> Thread[main,5,main]

[09:25] <sorear> clunky, but a start

[09:27] <dalek> nqp: f27b205 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/BootJavaInterop.java:

[09:27] <dalek> nqp: Java interop, part 2

[09:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f27b2059a1

[09:27] <dalek> nqp: 4f15d7b | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (2 files):

[09:27] <dalek> nqp: First working version of java interop coderef generator

[09:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4f15d7ba53

[09:29] <tadzik> wow

[09:29] <tadzik> sorear++

[09:30] <masak> sorear++!

[09:30] <masak> tadzik: hey hey

[09:31] <masak> tadzik: are you planning to forget about tonight's sprintf hacking, too? :P

[09:32] <tadzik> masak: oh, is there one tonight? :)

[09:33] <sorear> masak: you're planning to forget?  have fun at the wedding then.

[09:33] <tadzik> life pro tip: if you leave your balcony open, you're going to have a pidgeon's nest in it

[09:33] <sorear> next subgoal: callbacks!  then attempt to document what exists and how it's intended to be used.

[09:33] <tadzik> ...shit

[09:34] <sorear> tadzik: type error with sentence.  USese::Balcony does not do role "Closeable"

[09:35] <JimmyZ> sorear++

[09:35] <sorear> autopun?  02:04 < Cale> I tried teaching autodidactism, but it seems people just have to learn it for themselves.

[09:36] <lizmat> smells like one

[09:38] <masak> yes.

[09:38] <masak> sorear: also, http://bash.org/?3936

[09:38] <lizmat> TimToady: stopped trying to build Rakudo with Nil outside of Any

[09:39] <lizmat> oddly enough, it built the CORE.setting, but not the restricted one

[09:39] <lizmat> didn't get to spectest it at all

[09:41] <masak> I wonder if perhaps Perl 6 is the biggest spectest suite in history on which language experiments of this magnitude are performed.

[09:42] <masak> Perl 6's*

[09:42] <sorear> I doubt it

[09:43] * moritz wouldn't be surprised if for example Fortress had a test suite of similar size

[09:44] * sorear was thinking of C++

[09:44] <sorear> I know ginormous test suites exist for SQL, but I think SQL is more frozen than C++

[09:45] <lizmat> aha, the error "Odd number of elements found where hash expected" while trying to create restricted setting

[09:45] <lizmat> is not cause by the creation of the restricted setting, but simply by loading an apparenly incorrectly generated CORE.setting

[09:46] <sorear> sounds like a %hash = Nil thing

[09:46] <sorear> not being treated as %hash = ()

[09:46] <lizmat> yup, now to find that‚Ä¶  :-(

[09:46] <lizmat> probably not a single one either

[09:46] * lizmat goes spelunking

[09:47] <sorear> no backtraces?

[09:48] <lizmat> nope

[09:55] <masak> &

[09:55] <lizmat> happy wedding, masak!

[09:56] *** tomaw joined
[09:59] *** grondilu joined
[10:00] * grondilu is trying to compile rakudo-jvm again, this time with a fresh openjdk

[10:00] * grondilu managed to reach "stage jast" after about ten minutes of compilation

[10:02] <jnthn> lizmat: --ll-exception may get you something more helpful

[10:03] <sorear> grondilu: on my machine, rakudo-jvm compiles about three times faster than rakudo-parrot.

[10:03] <grondilu> it worked!

[10:03] * grondilu is about to run perl6 on JVM for the first time!

[10:03] <sorear> oh, wait... you said earlier you were on 32-bit D:

[10:04] <jnthn> ooh, I see sorear++ patches

[10:04] <sorear> nqp-jvm does not have 32-bit types

[10:04] <sorear> it does everything using 64-bit integers

[10:04] <sorear> which have to be emulated on 32-bit platforms

[10:04] <sorear> I suspect this plays some part in the slowness you see

[10:05] <dalek> rakudo/nom: ba7f78d | (Elizabeth Mattijsen)++ | src/core/control.pm:

[10:05] <dalek> rakudo/nom: Removed now superfluous class Nil {} definition (now done in BOOTSTRAP)

[10:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba7f78d39a

[10:05] * grondilu successfully ran "say "Hello, JVM!"

[10:05] <sorear> wait x2.  I thought jdk 1.7 dropped support for 32-bit CPUs

[10:05] <grondilu> jnthn: awesome work, sir

[10:06] <timotimo> jnthn: did you see the cool improvements your fast path caused?

[10:07] * grondilu tries 'my $sum; for ^10_000 { $sum += rand }; say $sum' and appreciates how fast this is

[10:07] <jnthn> timotimo: Not yet, still backlogging...

[10:08] <sorear> grondilu: wait, the setting compilation is several-x slower but that is faster?

[10:08] <jnthn> sorear: Looks like interop is going well ;)

[10:09] <grondilu> sorear: yes.  I've no idea why

[10:09] <lizmat> jnthn++, it does :-)

[10:09] * grondilu notices that the more perlish 'say [+] rand xx 10_000' is a bit slower (but still faster than rakudo)

[10:10] <jnthn> .oO( rakudo is faster than rakudo? :D )

[10:10] <jnthn> timotimo: Found the link; looking :)

[10:10] <grondilu> I meant parrot

[10:10] <grondilu> sorry

[10:11] * sorear thought thunky xx was a nieczaism

[10:12] <timotimo> no way

[10:12] <timotimo> thunky xx is crazy useful!

[10:13] <grondilu> any chance nqp-jvm supports 32-bit types in a near future?  Compilation worked but it was kind of a pain.

[10:13] <jnthn> iirc, thunky xx got spec'd and Rakudo changed to do it that way.

[10:13] <timotimo> what's the simplest way to get around the thunkyness? here's my first idea:

[10:14] <timotimo> r: my @a = (state $ = rand) xx 10; say @a;

[10:14] <camelia> rakudo ba7f78: OUTPUT¬´(Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any)‚ê§¬ª

[10:14] <timotimo> er, oops

[10:14] <jnthn> r: say rand xx 10

[10:14] <sorear> grondilu: I have no proof word size is the actual issue.

[10:14] <camelia> rakudo ba7f78: OUTPUT¬´0.126966395971493 0.108979036604193 0.941956717378112 0.661813663912728 0.517164013101123 0.674946465666235 0.892848095431951 0.793093453851188 0.0593905554276262 0.684856679539546‚ê§¬ª

[10:14] <jnthn> timotimo: Yes, the graphs seem better now :)

[10:15] * jnthn will have to optimize some more :)

[10:15] <timotimo> r: my $r = rand; my @a = $r xx 10; say @a; @a[2] = 100; say @a

[10:15] <camelia> rakudo ba7f78: OUTPUT¬´0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061 0.23256417466061‚ê§0.23256417466061 0.23256417466061 100 0.23256417466061 0.23256417466061 0.23256417466061 0.2325‚Ä¶

[10:15] <sorear> grondilu: diakopter thinks the OpenJDK optimizer is a joke compared to the one shipped in the closed-source releases.  He might be right.

[10:15] <grondilu> ahh.  too bad.

[10:16] <sorear> grondilu: since the oracle 1.7 releases are 64-only, the only way to test this is to set up a 64-bit openjdk and test performance

[10:16] <sorear> grondilu: do you have any idea how hard it would be to build a 64-bit openjdk on a 64-bit mac?

[10:17] <grondilu> sorear: no idea. sorry.

[10:18] <grondilu> but openjdk is easy to install, isn't it?

[10:18] *** colomon joined
[10:19] <sorear> o/ colomon

[10:19] <colomon> \o sorear

[10:19] <colomon> how goes it?

[10:20] <grondilu> me is trying http://rosettacode.org/wiki/SHA-256#Perl_6 on JVM

[10:20] <grondilu> ^ wow this actually worked!

[10:21] <grondilu> noooo

[10:21] * grondilu feels stupid

[10:21] <grondilu> I was actually still running perl6 on parrot.  Somehow the old executable was not replaced or something.

[10:22] * grondilu runs make install

[10:23] <colomon> java interop!  \o/

[10:24] * grondilu makes a jakudo link in /usr/local/bin 

[10:25] <timotimo> push @b, 0 until (8*@b-448) %% 512; - this seems very wasteful, wouldn't one rather push @b, 0 xx ((8 * @b - 448) % 512)?

[10:29] <lizmat> jnthn: could it be that a bare {} somehow would be generated as {Nil} and thus cause the odd number in hash error?

[10:29] <grondilu> ok now that I can really discriminate rakudo-parrot and rakudo-jvm, I can say that no, rakudo-jvm is not faster on my machine.  I tried 'my $sum; for ^10_000 { $sum += rand }; say $sum;'.  Got 4 seconds on parrot, 16 seconds on JVM.

[10:29] <sorear> jnthn++ # blogt and I missd it

[10:30] *** Rotwang left
[10:30] <colomon> Time::Duration went from passing to test failure overnight.

[10:31] <lizmat> colomon: i assume that's jakudo, right?  cause I haven't seen any here in any recent spectest on parakudo

[10:31] <jnthn> lizmat: Doesn't sound likely...

[10:31] <colomon> lizmat: that's parakudo, it's from the module smoke test

[10:31] <jnthn> lizmat: oh...maybe...

[10:32] <jnthn> colomon: Are the any details on the failure somewhere?

[10:32] <colomon> not stored, but I can try to install by hand...

[10:33] <lizmat> jnthn: src/core/operators has "    obj.HOW.mixin(obj, $role).BUILD_LEAST_DERIVED({});", note the {} at the end

[10:34] <lizmat> this winds up at "sub circumfix:<{ }>(*@elems) { my $x = Hash.new.STORE(@elems); }", and that bombs

[10:34] <jnthn> lizmat: hmm

[10:34] <jnthn> r: my $a = -> { }; say $a().WHAT

[10:34] <camelia> rakudo ba7f78: OUTPUT¬´Nil‚ê§¬ª

[10:34] <sorear> because inside the {} is an empty block, and empty blocks are Nil

[10:34] <jnthn> lizmat: Is ^ still meant to be the case?

[10:35] <lizmat> jnthn: good question

[10:37] <sorear> jnthn: Would it be appropriate to make a t/qast/01-qast test to ensure that the compiler can cope with QAST::SVal.new( :value( nqp::x("\x[3000]", 30000) ) ) ?

[10:37] <lizmat> r: say {}.WHAT # but isn't this what the {} is about in the BUILD_LEAST_DERIVED context?

[10:37] <camelia> rakudo ba7f78: OUTPUT¬´(Hash)‚ê§¬ª

[10:38] <lizmat> it's winding up at the circumfix {} code

[10:38] <jnthn> sorear: Yeah, should test it somewhere

[10:38] <jnthn> lizmat: The action method for circumfix:<{ }> is what decides if it's a block or a hash.

[10:39] <jnthn> lizmat: We always parse it as a block, and then look at it and decide if it should be a hash or not

[10:40] <sorear> lizmat: Moreover, the action method involves calling the generated block and passing whatever it returns to circumfix:sym<{ }>

[10:41] <lizmat> hmmm.. that's hidden from the stacktrace, then

[10:46] *** grondilu left
[10:49] <lizmat> put in a little check for @ being @=(Nil) in circumfix, and pop that, and now it builds  :-)

[10:50] <lizmat> running spectest now

[10:54] <sorear> there's probably a better way

[10:54] <sorear> (you probably think the same)

[10:54] *** rindolf joined
[10:55] <jnthn> Yeah, do it in Actions...

[10:57] <lizmat> spectest is definitely not clean  :-)

[10:57] <sorear> lizmat: how about the sanitytest?

[10:58] <lizmat> sanity test is ok

[10:58] <sorear> jnthn: I was thinking more along the lines of "empty block needs to be () in list context"

[10:58] <jnthn> sorear: Well, that's why I was asking what current spec says about what empty block means...

[10:59] <lizmat> r: my @a= ->{}; say @a.elems # should say 0, is what jnthn is saying?

[10:59] <camelia> rakudo ba7f78: OUTPUT¬´1‚ê§¬ª

[10:59] <jnthn> oh hah, just realized...I never ported compile time bind analysis, which means the inliner never inlines anything, such as the native types...

[10:59] <jnthn> (on JVM)

[11:00] <lizmat> hmm‚Ä¶ it also looks like t/spec/integration/99problems-21-to-30.rakudo.parrot infiniloops

[11:00] <sorear> jnthn: think we might get a small speedup from that?

[11:00] <timotimo> *small*? :D

[11:00] <jnthn> sorear: Um, it can turn a Perl 6 multi-dispatch into an ladd :)

[11:00] <timotimo> jnthn: i'm ready to fire you up ze benchmarks, but only if it's in about 1-2 hours

[11:01] <jnthn> timotimo: I'm gonna fix up nextsame et al. first.

[11:02] <jnthn> sorear: Probably means we do somewhat better on the native benchmarks...

[11:02] <jnthn> sorear: And in all the built-ins that use native types in their impl.

[11:05] <sorear> yeah, I kind of wonder if there are enough of those to make a difference

[11:05] *** woolfy1 joined
[11:05] <sorear> I don't actually know what kind of win the optimizer was when it first came it

[11:05] <sorear> in

[11:07] *** Bucciarati joined
[11:07] * [Coke] wonders where is_run is actually defined. Test/Util.pm has lots of protos, but no actual impl.

[11:08] <[Coke]> doh, it's there, just beyond my scroll.

[11:13] <sorear> jnthn: I'm pretty sure that the gather/take issue is because I stole a concept from Scheme and the papers I was basing it off of implicitly assumed proper tail recursion

[11:13] <sorear> I can see a couple ways to fix this, need to decide which is the most elegant

[11:13] <jnthn> sorear: ah..that explains it.

[11:14] <sorear> jnthn: every time you take() it seems to add a frame to the bottom of the saved stack fragment that does nothing

[11:17] <jnthn> sorear: Which nicely explains how things that take enough stack overflow...

[11:19] *** colomon left
[11:23] *** rindolf left
[11:28] *** preflex_ joined
[11:28] *** ChanServ sets mode: +v preflex_

[11:28] <lizmat> will look at stuff later, now cycling in the searing heat / sun&

[11:29] *** preflex left
[11:29] *** preflex_ is now known as preflex

[11:30] <[Coke]> java's exec doesn't handle shell redirection. Trying to figure out if I have to parse (at a minimum) > and 2> myself, or if I can cheat.

[11:31] <timotimo> https://gist.github.com/timo/2c85b3c62372b72468a3 <- link to source code in the description of the gist; does this ring a bell for any of our jvm-porters?

[11:31] *** colomon joined
[11:32] <jnthn> [Coke]: Well, I guess it's possible to invoke a shell...

[11:32] <jnthn> [Coke]: But that may cause other issues...

[11:32] *** berekuk left
[11:32] <jnthn> timotimo: There's a spectest that explodes that way, iirc

[11:32] <jnthn> timotimo: But it may be completely unrelated.

[11:33] <timotimo> fwiw, the == candidate is \a \b, probably comes from $n.Int, which in this case should totally be a valid integer. hm.

[11:34] *** berekuk joined
[11:34] <jnthn> timotimo: Does it do mixins?

[11:34] <jnthn> ### Cannot call 'Numeric'; none of these signatures match:

[11:34] <jnthn> * S14-roles/mixin.rakudo.jvm aborted 7 test(s)

[11:35] <jnthn> That's the spectest that fails in the same way

[11:36] <sorear> [Coke]: you're looking for java.lang.ProcessBuilder.

[11:36] <sorear> oh, you were doing shell, not ``

[11:36] *** colomon left
[11:37] <timotimo> i don't think it does

[11:37] <timotimo> i don't think it does, but could it have something to do with enums?

[11:37] <jnthn> Hm, maybe

[11:37] * timotimo is unable to reproduce it in golfed form so far

[11:37] <sorear> (you want ProcessBuilder anyway because exec() doesn't let you NOT automatically redirect output to pipes)

[11:37] <jnthn> enum spectests are in quite good shape, though...

[11:38] <timotimo> no luck so far.

[11:38] <[Coke]> I don't want processbuilder, but that means I have to parse out > and 2> myself.

[11:39] <[Coke]> s/but/because/

[11:39] <[Coke]> I think I have a *nix version working with exec(['sh', '-c', $cmd])

[11:40] <[Coke]> \o/

[11:41] <[Coke]> jnthn: mind if I commit the *nix only version to start?

[11:41] <dalek> nqp: 6602633 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/CallFrame.java:

[11:41] <dalek> nqp: CallFrame stashing space for args/csd.

[11:41] <dalek> nqp: 

[11:41] <dalek> nqp: Could do this always and save passing them around some, but for now

[11:41] <dalek> nqp: this is just for Rakudo's benefit. Saves us having to savecapture in

[11:41] <dalek> nqp: every frame just for the sake of nextsame et al.

[11:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6602633b14

[11:41] <sorear> [Coke]: note that if you don't use ProcessBuilder and inheritIO, *unredirected* output will go to the wrong place

[11:42] <[Coke]> sorear: where is "the wrong place"? Right now it goes nowhere.

[11:42] <timotimo> r: enum Frob <FOO BAR BAZ>; class Test { has Int $.w; has Int $.h; method foo() { [Frob.pick xx $!w] xx $!h } }; Test.new(:w(5), :h(5)).foo() # does not trigger the error

[11:42] <camelia> rakudo ba7f78:  ( no output )

[11:43] <dalek> rakudo/nom: cab99b2 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Ops.java:

[11:43] <dalek> rakudo/nom: Get nextsame, callsame etc. tests passing.

[11:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cab99b2e2c

[11:43] <sorear> [Coke]: into an anonymous pipe that you can read with proc.getOutputStream()

[11:43] <timotimo> .o( i think the implementation of xx could be factored out quite a bit )

[11:44] <[Coke]> sorear: is shell supposed to display or return any output?

[11:44] <[Coke]> I thought it discarded output and returned an exit status.

[11:45] <[Coke]> jnthn: what does "say $*OS" say for you?

[11:46] <jnthn> On JVM? "Windows 7"

[11:47] <sorear> [Coke]: It's supposed to allow the subprocess output to pass freely to the parent's standard IO

[11:47] *** berekuk left
[11:48] <[Coke]> r: shell('ls');

[11:48] <sorear> with no interaction from the parent, so you can do shell("vi", $file)

[11:48] <camelia> rakudo ba7f78: OUTPUT¬´shell is disallowed in restricted setting‚ê§  in sub restricted at src/RESTRICTED.setting:2‚ê§  in sub shell at src/RESTRICTED.setting:7‚ê§  in block  at /tmp/_yGLsYxjNx:1‚ê§‚ê§¬ª

[11:48] <sorear> shell(%*ENV<VISUAL> // %*ENV<EDITOR> // "vi", $file) :)

[11:48] *** berekuk joined
[11:49] <[Coke]> sorear: Ok. I give up, then.

[11:50] <timotimo> https://gist.github.com/timo/91483e54fa0b20173f5f <- ?

[11:51] <[Coke]> Here is the wrong version: https://gist.github.com/coke/5939689

[11:51] <[Coke]> to do it the write way, we need to be able to parse all the shell metacharacters ourselves. I suggest we find a third party library instead.

[11:52] <[Coke]> *right

[11:52] <sorear> Process proc = new ProcessBuilder("sh", "-c", cmd).inheritIO().start()

[11:52] <sorear> ought to work

[11:54] * sorear suspects jnthn++ can whip up an if statement involving cmd.exe

[11:54] *** PacoAir joined
[11:56] <jnthn> I guess by looking at System.getProperty("os.name") and then "cmd", "/c/" cmd

[11:57] * [Coke] wonders if we have any tests for sorear's case in roast.

[11:57] *** berekuk left
[11:57] <[Coke]> sorear++ # that worked.

[11:58] <sorear> jnthn: mainly that I don't know what %*VM<properties><os.name> is on windows, or what the proper syntax for cmd /c/ is

[11:59] *** berekuk joined
[11:59] <timotimo> oh, i may need to nqp::p6bool that ...

[12:01] <dalek> roast: 034ed21 | coke++ | packages/Test/Util.pm:

[12:01] <dalek> roast: workaround exec name issue on nqp-jvm

[12:01] <dalek> roast: review: https://github.com/perl6/roast/commit/034ed21214

[12:02] <dalek> nqp: ef6648d | coke++ | src/vm/jvm/ (2 files):

[12:02] <dalek> nqp: add (unix only) nqp::shell for jvm

[12:02] <dalek> nqp: 

[12:02] <dalek> nqp: sorear++

[12:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ef6648d57f

[12:03] <dalek> rakudo/nom: 0eab21a | coke++ | src/core/control.pm:

[12:03] <dalek> rakudo/nom: shell -> nqp::shell

[12:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0eab21a4d4

[12:03] <[Coke]> sorear: there, now it's jnthn++'s problem. :)

[12:03] <jnthn> :P

[12:04] <jnthn> [Coke]: Does that make spectests that depend on it run? :)

[12:04] <jnthn> If so, that's quite a few test files we win :D

[12:04] <[Coke]> jnthn: at least one runs to completion now, yes.

[12:05] <[Coke]> doing a rebuild with latest changes, spectesting.

[12:05] <jnthn> k

[12:07] * jnthn is looking into why installing a second categorical clobbers the first.

[12:09] <sorear> mixin funs?

[12:09] <jnthn> Could well be.

[12:11] <timotimo> my patch above seems to win us a tiny bit of performance

[12:11] *** berekuk left
[12:11] <timotimo> that's probably the jit figuring out everything by itself or something

[12:12] *** berekuk joined
[12:14] <jnthn> Hm, if it's mixin fun it's pretty weird mixin fun 'cus the mro length changes :)

[12:14] <jnthn> ohhh

[12:14] <jnthn> I bet I know.

[12:16] *** birdwindupbird joined
[12:17] <JimmyZ> [Coke]: https://github.com/clojure/clojure/blob/master/src/clj/clojure/java/shell.clj#L140 looks like support 1>&2

[12:18] <JimmyZ> JFYI

[12:18] <[Coke]> JimmyZ: I have something that looks like it works now. thanks for the pointer, though!

[12:21] <JimmyZ> :P

[12:21] *** berekuk left
[12:24] *** berekuk joined
[12:33] *** ztt joined
[12:35] *** berekuk left
[12:35] *** jferrero joined
[12:36] *** berekuk joined
[12:42] <[Coke]> r: say 24604 / 26108

[12:43] <camelia> rakudo 0eab21: OUTPUT¬´0.942393‚ê§¬ª

[12:43] <timotimo> sweet :)

[12:43] <[Coke]> r: say .942393-.9348

[12:43] <camelia> rakudo 0eab21: OUTPUT¬´0.007593‚ê§¬ª

[12:43] <timotimo> better than nothing ;)

[12:43] <[Coke]> I'll regen the gist again after the daily run today.

[12:44] <jnthn> How long until the daily run?

[12:45] <[Coke]> it's still manual. 3 kick off at about 12 eastern. rakudo-jvm I then have to run manually

[12:46] <timotimo> did that run already include the fixes to shell?

[12:47] <[Coke]> timotimo: ^^ one? yes. ran it by hand

[12:47] <jnthn> Not that far from 95% :)

[12:48] <[Coke]> r: 26108*.9 - 24604

[12:48] <dalek> nqp: 3fbb512 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (3 files):

[12:48] <camelia> rakudo 0eab21:  ( no output )

[12:48] <dalek> nqp: Implement implementClass / callback mechanism

[12:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3fbb512365

[12:48] <[Coke]> r: 2say 6108*.9 - 24604

[12:48] <camelia> rakudo 0eab21: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/grfwX2fFkW:1‚ê§------> [32m2[33m‚èè[31msay 6108*.9 - 24604[0m‚ê§    expecting any of:‚ê§        whitespace‚ê§¬ª

[12:48] <[Coke]> r: say 6108*.9 - 24604

[12:48] <camelia> rakudo 0eab21: OUTPUT¬´-19106.8‚ê§¬ª

[12:48] <[Coke]> r: say 26108*.9 - 24604

[12:48] <camelia> rakudo 0eab21: OUTPUT¬´-1106.8‚ê§¬ª

[12:48] <[Coke]> (oy)

[12:48] <sorear> https://gist.github.com/sorear/5939789

[12:49] <[Coke]> r: say 26108*.95 - 24604 #oy oy

[12:49] <camelia> rakudo 0eab21: OUTPUT¬´198.6‚ê§¬ª

[12:49] <sorear> sleep&

[12:49] <[Coke]> yes, excellent plan. see you post nap. :)

[12:49] <[Coke]> zzz

[12:49] <jnthn> sorear: !!! :D

[12:49] <jnthn> sorear++

[12:51] <timotimo> looking forward to when there's some sugar for that :3

[12:57] *** domidumont joined
[12:59] <timotimo> turns out the forest-fire benchmark was broken due to my dumbness.

[12:59] * masak is back from the wedding

[12:59] <jnthn> Hm, think I may have got us another 100+ passes

[13:03] <timotimo> i'm preparing for another benchmark run. are you going to commit something?

[13:03] <jnthn> yeah, but it ain't performance related

[13:03] <timotimo> ok

[13:04] <jnthn> I may do the compile time call analysis later

[13:04] <timotimo> at that time i'll be hanging around with my parents :)

[13:05] *** domidumont left
[13:10] <dalek> nqp: 445550b | jnthn++ | src/ (2 files):

[13:10] <dalek> nqp: Fix handling of generic method names.

[13:10] <dalek> nqp: 

[13:10] <dalek> nqp: On JVM (and MoarVM, for that matter) the name associated with a code

[13:10] <dalek> nqp: object is stored statically, not in the actual code ref itself like on

[13:10] <dalek> nqp: Parrot. This is generally more efficient (saves a field in closures),

[13:10] <dalek> nqp: but we relied on it. This prevented declaring more than one user

[13:10] <dalek> nqp: defined operator in Rakudo on JVM, which busted various tests. On

[13:10] <dalek> nqp: Parrot, we keep the same approach as today.

[13:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/445550b24d

[13:10] <jnthn> 100ish more for the run :)

[13:13] <jnthn> walk etc. &

[13:21] <timotimo> cool :)

[13:22] <tadzik> do we already have a perlbrew-like thing, which can do 'rakudobrew switch jvm' etc? :)

[13:22] <tadzik> I know the answer

[13:22] <timotimo> well volunteered :)

[13:23] <tadzik> aye :0

[13:23] <timotimo> fwiw, the perl6-bench infrastructure is cool. it allows you to specify exact revisions/tags of your stuff to be built on demand. maybe steal a bit of that?

[13:23] <tadzik> hacking in the garden, mm

[13:23] <tadzik> wow, I will look into it

[13:25] <tadzik> 1Mbit internet will be suboptimal for testing, heh

[13:25] <timotimo> at first, you "./bench setup" which will clone rakudo, nqp, perl5, moarvm for you, then you "./bench extract rakudo-jvm/some-branch-or-tag-or-commit rakduo/some-blah" and then you can "./bench time rakudo-jvm/foo rakudo/bar"

[13:26] <tadzik> hm

[13:27] <timotimo> make cloning all the shtuff at the beginning optional and it'll already come quite a bit closer

[13:29] *** berekuk left
[13:30] <tadzik> ah, but bench is all Perl 6

[13:30] <tadzik> ...it tok me 5 minutes to notice that :D

[13:32] *** berekuk joined
[13:32] <timotimo> no, it's a bit of perl5, too (timeall, analyze, ...)

[13:32] <timotimo> also, that's a good point :|

[13:32] <tadzik> well, the ./bench part

[13:32] <tadzik> where all the logic is

[13:32] <tadzik> although components.json itself is quite useful

[13:33] <timotimo> right.

[13:35] <timotimo> i will probably not be able to upload the benchmark results in time.

[13:36] *** mtk joined
[13:41] <tadzik> haha. Bash uses eq for numeric comparisons, = for string comparisons

[13:41] <tadzik> http://affordablehousinginstitute.org/blogs/us/wp-content/uploads/brilliant_cigar1.jpg

[13:44] <tadzik> r: say $?VM

[13:44] <camelia> rakudo 0eab21: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable '$?VM' is not declared‚ê§at /tmp/p2aep_TGFF:1‚ê§------> [32msay $?VM[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[13:44] <tadzik> jvm reacts in a more spectacular way :P

[13:45] <tadzik> but just in a repl

[13:46] <lee_> i've seen that a few times on the jvm repl (infinite scrolling errors)

[13:46] <tadzik> yeah

[13:47] <tadzik> maybe the jvm repl is not quite there :)

[13:47] <tadzik> say $?VM on rakudo-jvm just prints a newline

[13:48] <lee_> mine is a bit out of date, guess I should rectify that

[14:02] *** xilo_ joined
[14:09] <timotimo> gaaah i'll have to wait until late at night to check out jnthns probably to arrive soon patches for native compile-time dispatch (

[14:09] <timotimo> :(

[14:16] *** berekuk left
[14:18] <tadzik> https://gist.github.com/tadzik/5940022 seems to work :)

[14:18] <timotimo> looks good! :)

[14:18] <timotimo> gotta run now

[14:19] *** berekuk joined
[14:29] *** dmol joined
[14:54] *** dmol left
[14:59] *** rindolf joined
[15:00] *** berekuk left
[15:01] *** berekuk joined
[15:01] *** berekuk left
[15:21] *** konundra joined
[15:25] <TimToady> .tell masak I suspect it's some form of http://en.wikipedia.org/wiki/Anterograde_amnesia

[15:25] <yoleaux> TimToady: I'll pass your message to masak.

[15:26] <masak> ah.

[15:26] <TimToady> I believe this was even admitted at one point

[15:26] <TimToady> well, not with those words

[15:29] <TimToady> .oO(I keep forgetting that I have amnesia.)

[15:30] <masak> I can't seem to prod the irclogs into remembering, either.

[15:30] <masak> ah, found it.

[15:30] <masak> http://irclog.perlgeek.de/perl6/2012-02-10#i_5130347

[15:31] <masak> irclog++

[15:32] <TimToady> brainlogs++ :)

[15:32] <moritz> masak: you might want to use http://tina.perlgeek.de/perl6/search/ for searching. It's still in beta, and doesn't have quite up-to-date data, but the search should work much better

[15:33] <masak> ooh

[15:33] <masak> moritz++

[15:34] <moritz> (it's powered by Lucy)

[15:34] *** ajr joined
[15:34] <masak> tina powered by Lucy. gotcha.

[15:34] *** ajr is now known as Guest35475

[15:34] <moritz> :-)

[15:34] <moritz> "tina" is just the hostname, and I use that virtual host for experimental stuff

[15:35] <moritz> (under the hood I've mostly rewritten the IR clogs; now uses a partially normalized DB schema, Plack, and Lucy)

[15:35] *** benabik left
[15:35] <masak> nice.

[15:36] <JimmyZ> how was ibot6 runing?

[15:36] <moritz> JimmyZ: mostly stable

[15:36] *** Guest35475 is now known as ajr_

[15:36] <moritz> but the problem is that the new machine has too litle RAM to compile rakudo

[15:36] <JimmyZ> no memory overflow?

[15:36] <JimmyZ> :P

[15:37] <TimToady> I'm sure no one has ever told me I have amnesia.

[15:38] <moritz> someone told me I have amnesia, but I forgot who.

[15:38] <TimToady> Dr Who

[15:39] *** benabik joined
[15:40] <masak> there's nothing wrong with my memory; I've never forgotten anything, as far as I recall.

[15:45] <Teratogen> so a dyslexic walks into a bra...

[15:55] <TimToady> Lysdexic: someone who can't write due to a broken right hand.

[16:11] <masak> one of the funniest things I ever found in one of my old notebooks (that I had forgotten I had made) was a page with only big, messily scrawled letters spelling out the phrase "OBSERVE HOW I'M TRYING TO WRITE THIS WITH MY LEFT HAND".

[16:14] <TimToady> r: https://gist.github.com/anonymous/5940348

[16:14] <camelia> rakudo 0eab21: OUTPUT¬´1..1‚ê§open is disallowed in restricted setting‚ê§  in sub restricted at src/RESTRICTED.setting:2‚ê§  in sub open at src/RESTRICTED.setting:5‚ê§  in sub nonfatalscope at /tmp/CdaZH4SaGB:10‚ê§  in sub fatalscope at /tmp/CdaZH4SaGB:6‚ê§  in block  at /tmp/CdaZH4SaGB:13‚ê§‚ê§# Looks ‚Ä¶

[16:15] <TimToady> well, anyway, that gist is the rakudobug I was carping about last night, where $*FATAL doesn't turn off in non-fatal scopes

[16:17] * masak runs it locally

[16:17] * masak submits rakudobug

[16:20] *** lizmat joined
[16:22] *** dmol joined
[16:27] *** FROGGS joined
[16:33] * TimToady hates it when a language sets options using methods like .inheritIO

[16:33] <diakopter> .

[16:34] <masak> says the guy who invented $[    :P

[16:34] <TimToady> that's why I use the present tense :)

[16:35] <masak> ooh, it was deprecated in 5.12 -- I did not know that.

[16:36] <TimToady> and it was made lexically scope much earlier

[16:36] <TimToady> *scoped

[16:36] <masak> ooh, I did not know that either.

[16:36] <TimToady> in fact, I did that

[16:36] <masak> TimToady++ # atoning, partially

[16:37] <TimToady> and recall that $[ was really invented for Perl 0, so I could write a2p

[16:37] <masak> oh, because awk is 1-based?

[16:37] <TimToady> yup

[16:38] * masak wonders what Dijkstra thought of awk :)

[16:38] <TimToady> well, Henry Spencer though awk was perl without skin cancer :)

[16:38] <TimToady> *ght

[16:40] <TimToady> and Perl 0 had no notion of modules at that point (or of lexical scopes, for that matter, or even packages), so a global made sense

[16:40] <lizmat> good *, #perl6!

[16:40] <TimToady> because that's all we had...

[16:40] <lizmat> glad to be back in a cool place  :-)

[16:41] <TimToady> Q: Why are you banging your head against the wall?  A: Because it feels so good when I stop.

[16:41] <lizmat> r: my $a=Hash; say $a; $a<b>=1; say $a.perl  #  just before I left, I realized that this already works:

[16:41] <camelia> rakudo 0eab21: OUTPUT¬´(Hash)‚ê§{"b" => 1}‚ê§¬ª

[16:42] <lizmat> aka, somewhere a "new" is done

[16:42] <masak> lizmat! \o/

[16:43] <FROGGS> I should try banging my head against Wall next time :o)

[16:44] <jnthn> o/ lizmat 

[16:44] *** crab2313 joined
[16:44] <lizmat> so I decided to rig circumfix {} to do a Hash.new only if  parameters are specified

[16:45] <lizmat> otherswise, just assign the type

[16:45] <lizmat> s/assign/return

[16:45] <jnthn> Could we not rig it to just not pass Nil along? :)

[16:45] <TimToady> r: my $a; say $a; $a<b>=1; say $a.perl

[16:45] <camelia> rakudo 0eab21: OUTPUT¬´(Any)‚ê§{"b" => 1}‚ê§¬ª

[16:45] <TimToady> you don't need the Hash even

[16:45] <jnthn> lizmat: That feels kinda wrong, fwiw.

[16:46] <jnthn> r: say {}.WHAT

[16:46] <camelia> rakudo 0eab21: OUTPUT¬´(Hash)‚ê§¬ª

[16:46] <jnthn> r: say {}.DEFINITE

[16:46] <camelia> rakudo 0eab21: OUTPUT¬´True‚ê§¬ª

[16:47] <lizmat> I think the Hash makes it cleaner

[16:47] <lizmat> anyway, now I got the following behaviour:

[16:47] <lizmat> $ perl6 -e 'my $a={}; say $a.defined; $a<b>=1; say $a'

[16:47] <lizmat> False

[16:47] <lizmat> ("b" => 1).hash

[16:48] *** ztt left
[16:48] <lizmat> isn't that what we wanted for uninitialized hashes ?

[16:48] <TimToady> that's an empty hash, not an undefined hash

[16:48] <jnthn> {} is ...that.

[16:49] <lizmat> ok, so we don't want it there, but if we say: 'my %h", then the %h should not be defined, right?

[16:50] <jnthn> lizmat: All it needs, afaict, is setting a "it's empty" flag in the "elsif $stmts == 0 {" branch, then not looping over @children further down if that was the case.

[16:50] <timotimo> http://t.h8.lv/p6bench/2013-07-06.html more plots

[16:50] <lizmat> jnthn: will look for that

[16:52] <timotimo> weird, i think the trim_string benchmark b0rked again

[16:55] <masak> oh, how time flies. sprintf hackathon in 1h and a bit.

[16:55] <TimToady> timotimo: looks like

[16:55] *** atroxaper joined
[16:56] <FROGGS> ohh

[16:56] <FROGGS> masak: I'll join late

[16:56] *** atroxaper left
[16:56] <masak> ok.

[16:57] <TimToady> whoever wrote that blue-line program must have gone totally insane over performance and scaling...  :)

[16:58] <FROGGS> I've set up a new server for that blue-line program at work yesterday

[16:58] <dalek> nqp: 121892f | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/ (5 files):

[16:58] <dalek> nqp: Give in and move name into CodeRef itself.

[16:58] <dalek> nqp: 

[16:58] <dalek> nqp: After finding another obscure bug that boils down to the same issue,

[16:58] <dalek> nqp: and with the !reify_name fix feeling fragile if mixed with pre-comp,

[16:58] <dalek> nqp: it's much easier to go this way for now.

[16:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/121892f5b0

[16:58] <dalek> nqp: 8645a09 | jnthn++ | src/ (2 files):

[16:58] <dalek> nqp: Revert "Fix handling of generic method names."

[16:58] <dalek> nqp: 

[16:58] <dalek> nqp: This reverts commit 445550b24d7952a9a3ca440e76347474cf79715d.

[16:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8645a09d60

[16:58] <FROGGS> our other servers run 5.10 still :/

[16:59] <dalek> rakudo/nom: 4e86c80 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Ops.java:

[16:59] <dalek> rakudo/nom: Chase latest NQP change.

[16:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e86c80508

[16:59] <masak> I see three things we can focus on in today's sprintf hackathon: (a) dropping the our implementation into nqp-JVM. (b) figuring out what the spectests want that we don't have yet. (c) working on those missing features.

[17:00] <masak> (c) is fully dependent on (b). (b) is only sorta-kinda dependent on (a).

[17:00] <jnthn> That fixes S12-methods/multi.t...

[17:00] <masak> I'll work on (a) if nothing unexpected happens.

[17:00] <TimToady> jnthn: does/could the for ^$max {...} optimization figure out that ... doesn't use $_ and, say, substitute a countdown?

[17:00] <lizmat> masak: why nqp-JVM only ?

[17:00] <lizmat> why not nqp, period ?

[17:01] <TimToady> since 'while --$countdown' tends to be fast, especially in native types (assuming native decrement is available)

[17:01] <masak> lizmat: because I believe that'll lose us passing spectests on Parrot.

[17:01] <jnthn> TimToady: There's no optimization of that at present, and you'd need to be sure that $max is not bigint...

[17:01] <jnthn> lizmat: I think we should do that eventually, but it should handle everything we already do first.

[17:01] <lizmat> masak: isn't that the whole wrong reason, and a very short term as well?

[17:02] <lizmat> ok, as long as we see that's the end goal  :-)

[17:02] <jnthn> lizmat: Whereas with nqp-jvm we've nothing to lose by having a not-done-yet version.

[17:02] <jnthn> TimToady: Which makes it a bit harder to do static analysis of...

[17:02] <masak> lizmat: definitely the long term.

[17:02] <FROGGS> lizmat: I guess it is just an #?if jvm, and will be used for all backends when it supports all features

[17:02] <masak> lizmat: I'm just *very* against regressing on passing spectests.

[17:03] <masak> lizmat: that just isn't done. it hurts people. it hurts the ecosystem.

[17:03] <FROGGS> because no packend will ever support printing NaN in %d

[17:03] <FROGGS> (or what the rt report what about)

[17:03] <lizmat> ok ok ok  :-)  just wanted to make sure we're on the same page regarding the future here  :-)

[17:03] <TimToady> if $_ isn't used, then counting down from 2**64-1 will probably take a long time anyway, if you cap it at that

[17:04] <masak> no-one would be happier/prouder than me if sprintf were the standard across all backends. that's why I started implementing it in pure nqp.

[17:04] <masak> so yes, of course that's the long-term goal. ;)

[17:04] <TimToady> I'm guessing nobody would ever notice a cap at 2**64-1 :)

[17:04] <jnthn> timotimo: It appears that something I did unbusted S14-roles/mixin.rakudo.jvm

[17:04] <jnthn> TimToady: That's, uh, sick. But you're right. :D

[17:04] <jnthn> timotimo: Which is the test that exploded with the Numeric method error

[17:05] <jnthn> timotimo: You may want to try a forest fire again

[17:05] <TimToady> see earlier note about "insane"

[17:07] <jnthn> Hm, seems that fix I just did incidentally fixed a few things...

[17:08] <jnthn> aww, but not S06-multi/type-based.t

[17:11] <FROGGS> maybe next time *g*

[17:17] <lizmat> coming back to '{}' versus 'my %'   I don't really see a difference

[17:17] <lizmat> the fact that we see {} as an empty (defined) hash, feels like a p5ism to me

[17:18] <lizmat> .oO( wonder what TimToady's thoughts are on that )

[17:18] *** domidumont joined
[17:18] <TimToady> I already said, I thought.  {} and [] are simply empty, not undefined

[17:19] <lizmat> argh, yes, sorry for the noise

[17:20] <TimToady> r: say ().defined;  # this too

[17:20] <camelia> rakudo 4e86c8: OUTPUT¬´True‚ê§¬ª

[17:20] *** patspam joined
[17:20] <dalek> rakudo/nom: 4e9635e | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[17:20] <dalek> rakudo/nom: Remove superfluous call to STORE, "new" handles this also

[17:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e9635eab0

[17:20] <dalek> nqp: bc36181 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[17:20] <dalek> nqp: Make nqp::shell work on Windows.

[17:20] <dalek> nqp: 

[17:20] <dalek> nqp: Means that the spectests that spawn a sub-process can now be run on

[17:20] <dalek> nqp: Windows also.

[17:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bc36181ae1

[17:22] <jnthn> ...apart from they seem to fail under make spectest...

[17:23] *** patspam left
[17:24] *** patspam joined
[17:28] *** birdwindupbird left
[17:30] <masak> yes, there's a discontinuity there between item-size variables and container-size variables. 'my $s' starts out undefined until assigned to. 'my %h' starts out empty-but-defined.

[17:31] <masak> I guess it even makes sense in a way. there are no "empty scalars", so the only way they can show their emptiness is to be undefined. but with containers it doesn't make much sense to be undefined, only to then fill it with a container -- might as well start your existence as an empty container.

[17:31] <jnthn> oh, maybe it did.

[17:35] <TimToady> masak: it doesn't make sense to start with an empty container if you're immediately going to rebind it to something else; consider a function parameter like (@shaped[100][100]) that accepts an array of that shape, but it would not make sense to allocate @shaped and then bind over the top of that

[17:37] <TimToady> one could argue similarly for: my @shaped[100][100]; ...; @shaped := @some_100x100_array

[17:38] <TimToady> autoviv just becomes an all-or-nothing affair in that case

[17:39] <TimToady> this would eliminate the discontinuity, though it might make optimizing harder

[17:40] <masak> aye.

[17:40] <TimToady> s:g/'[100][100]'/[100;100]/

[17:41] <TimToady> we'd like 'my @shaped[100][100]' to make some static guarantees that the optimizer can depend on

[17:41] <masak> I wasn't thinking of shaped arrays at all -- just trying to rationalize the discontinuity between scalar containers and unshaped array/hash containers.

[17:41] <TimToady> or that we can at least point the finger back at the user if they violate it

[17:41] <masak> preferably at compile time.

[17:41] <TimToady> "static"

[17:42] <masak> *nod*

[17:42] <TimToady> though yes, we might not be able to detect the erroneous code at compile time

[17:42] <TimToady> darn it, I wrote [100][100] again :)

[17:43] * TimToady wonders if we should allow that in the declaration, or maybe we do

[17:44] <TimToady> std: my @shaped[100][100] is Blurfl;

[17:44] <camelia> std 85cf51d: OUTPUT¬´ok 00:00 43m‚ê§¬ª

[17:44] <TimToady> I guess we do

[17:44] <TimToady> std: my @shaped[100]{Bool}[42] is Blurfl;

[17:44] <camelia> std 85cf51d: OUTPUT¬´ok 00:00 44m‚ê§¬ª

[17:45] <TimToady> so we can intermix array and hash shapes

[17:49] <TimToady> std: my @shaped[*]{*}[*];  # probably see a lot of shaped arrays that merely do Array vs List like this

[17:49] <camelia> std 85cf51d: OUTPUT¬´ok 00:00 44m‚ê§¬ª

[17:50] <TimToady> in that case it's still autoviv at every level, arguably including @shaped itself

[17:50] *** mstefanko left
[17:50] <lizmat> jnthn: I guess this is *not* what we were going for: $ perl6 -e 'my @a=->{}; say @a[0]'

[17:50] <lizmat> Block.new()

[17:50] <lizmat> r: my @a=->{}; say @a[0]

[17:51] <camelia> rakudo 4e86c8: OUTPUT¬´Block.new()‚ê§¬ª

[17:51] <TimToady> looks correct to me :)

[17:51] <jnthn> lizmat: Looks fine

[17:51] <jnthn> lizmat: It's only the {} form that becomes hash

[17:51] <jnthn> *a

[17:52] <lizmat> r: my @a={}; say @a[0]

[17:52] <camelia> rakudo 4e86c8: OUTPUT¬´().hash‚ê§¬ª

[17:52] *** mstefanko joined
[17:52] <jnthn> Right.

[17:52] <TimToady> because why would you write an empty closure anyway?  maybe for a callback that does nothing, but {;} is not an onerous burden in that case

[17:54] <lizmat> hmmm‚Ä¶  seems I've lost the plot, then  :-(

[17:55] <lizmat> r: sub a {}; say a; my @a=a; say @a

[17:55] <camelia> rakudo 4e86c8: OUTPUT¬´Nil‚ê§‚ê§¬ª

[17:56] <lizmat> jnthn: then what did you mean by "[18:50:04] <jnthn>	 lizmat: All it needs, afaict, is setting a "it's empty" flag in the "elsif $stmts == 0 {" branch, then not looping over @children further down if that was the case." ?

[17:57] *** mstefanko left
[17:57] * [Coke] kicks off the rakudo.jvm run

[17:57] <masak> so, what is this new 'is Blurfl' trait I keep hearing about? :P

[17:58] <TimToady> it's a trait that fails if the thing to the left doesn't parse as a shaped array :)

[17:58] *** aindilis joined
[17:59] <TimToady> std: (my @shaped[*]{*}[*]) is Blurfl;

[17:59] <camelia> std 85cf51d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/NfepoOlEkG line 1:‚ê§------> [32m(my @shaped[*]{*}[*]) [33m‚èè[31mis Blurfl;[0m‚ê§    expecting any of:‚ê§    feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:00

[17:59] <camelia> ..4‚Ä¶

[17:59] <TimToady> std: my @shaped[*]{*}.[*] is Blurfl;

[17:59] <camelia> std 85cf51d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/iLisXTqOpK line 1:‚ê§------> [32mmy @shaped[*]{*}.[*] [33m‚èè[31mis Blurfl;[0m‚ê§    expecting any of:‚ê§     feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:00

[17:59] <camelia> ..46‚Ä¶

[18:00] <masak> ok. sprintf hackathon begins.

[18:00] <TimToady> ^^^ a place we distinguish [] from .[]

[18:00] <masak> TimToady: yes, and S09 mentions that, methinks.

[18:00] *** mstefanko joined
[18:04] <[Coke]> jnthn++ nqp:shell for win

[18:06] <tadzik> for the win!

[18:07] <TimToady> my @shaped[100;100] = 0 xx *;  # allowed?  or should we require something resembling (0 xx *) xx *

[18:07] <masak> QAST::OperationsJAST.map_classlib_core_op('sprintf', $TYPE_OPS, 'sprintf', [$RT_STR, $RT_OBJ], $RT_STR, :tc);

[18:07] <masak> jnthn: ^ guessing I want to do .add_core_op here instead?

[18:08] <masak> TimToady: the conservative thing to do is to require something of the same shape.

[18:08] <[Coke]> masak: instead of?

[18:08] <masak> [Coke]: instead of that line, which uses JVM's sprintf.

[18:08] <[Coke]> masak: (yes, you'll need that to put in a hook for nqp::sprintf

[18:09] <TimToady> I think there's some constraint that we initialize a multidimensional object with a LoL that every dimension must limit either in the decl or in the initializer, but both can't be *

[18:09] <[Coke]> masak: yes. though I only know how to point to a java method, not a perl6 one.

[18:09] <masak> it's implemented in nqp.

[18:09] <masak> and I see examples of .add_core_op in that file, don't worry.

[18:10] <TimToady> so my @shaped[100;100] = lol (0 xx *) xx * is allowed

[18:10] <masak> biggest question right now is where in the file hierarchy to place the sprintf code...

[18:10] <masak> std: lol 42

[18:10] <camelia> std 85cf51d: OUTPUT¬´ok 00:00 42m‚ê§¬ª

[18:10] <TimToady> but my @shaped[*;100] = lol (0 xx *) xx * is not allowed

[18:11] * masak wasn't aware 'lol' was a listop, too

[18:11] <TimToady> but my @shaped[*;100] = lol (0 xx *) xx 100 is allowed

[18:11] <masak> TimToady: makes sense.

[18:11] <TimToady> nr: say lol (0 xx 5) xx 5

[18:11] <camelia> niecza v24-86-g39ab531: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'lol' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 36) ‚ê§  at /home‚Ä¶

[18:11] <camelia> ..rakudo 4e86c8: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§    lol used at line 1. Did you mean '&log'?‚ê§‚ê§¬ª

[18:12] <TimToady> been specced for a long time

[18:12] <TimToady> nr: say ((0 xx 5) xx 5).lol

[18:12] <camelia> rakudo 4e86c8: OUTPUT¬´ListIter.new()‚ê§¬ª

[18:12] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´Unhandled exception: Unable to resolve method lol in type List‚ê§  at /tmp/xP4XcTkLzX line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ‚ê§  at /home/p‚Ä¶

[18:12] <lizmat> I guess that qualifies as LHF

[18:12] <TimToady> though the fact that we have to write the (0 xx *) xx 100 above probably means our xx operators are backwards

[18:13] <TimToady> you'd like to say 100 xx (* xx 0) instead

[18:14] <lizmat> maybe we need a reverse version of the "xx" operator, something like "xx" ?  

[18:14] <TimToady> :D

[18:14] <lizmat> :-)

[18:14] <TimToady> nr: say 'xx'.flip

[18:14] <camelia> rakudo 4e9635, niecza v24-86-g39ab531: OUTPUT¬´xx‚ê§¬ª

[18:14] <TimToady> there you go

[18:15] <TimToady> hmm

[18:15] <masak> r: say 5 Rxx "OH HAI"

[18:15] <camelia> rakudo 4e9635: OUTPUT¬´OH HAI OH HAI OH HAI OH HAI OH HAI‚ê§¬ª

[18:15] <TimToady> nr: say 3 Rxx 'It's true!' 

[18:15] <camelia> rakudo 4e9635: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/VXFljlRaKq:1‚ê§------> [32msay 3 Rxx 'It'[33m‚èè[31ms true!'[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        statement end‚ê§        statement modifier‚ê§      ‚Ä¶

[18:15] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Confused at /tmp/limiDH6GgD line 1:‚ê§------> [32msay 3 Rxx 'It'[33m‚èè[31ms true!'[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[18:16] <masak> I win.

[18:16] <TimToady> I said hmm first though

[18:16] <masak> ;)

[18:17] <TimToady> sometimes this language scares me :)

[18:17] <masak> fwiw, I did the apostrophe-inside-singlequote-string thing yesterday... :)

[18:17] <masak> (in code I was writing)

[18:17] <TimToady> it's one of the reasons I usually use "" instead

[18:17] <lizmat> but if we will revert 'xx's meaning, a *lot* will need to be changed around

[18:17] <masak> yes no please don't do that.

[18:17] <TimToady> lizmat: nobody is suggesting that :)

[18:18] <TimToady> notice me not suggesting it very hard

[18:18] <masak> panic oh noes aaaaaah oh ok. :P

[18:18] <lizmat> :-D

[18:18] * masak .oO( masak is only allowed to panic 255 times )

[18:18] *** pmurias_ joined
[18:18] <TimToady> 2**64-1

[18:18] <lizmat> after that, panic really strikes

[18:20] <TimToady> maybe Jesus really meant we should forgive our brother 70 ** 7 times

[18:20] <masak> "turn the 471st cheek"

[18:21] <masak> er, "490th"

[18:21] <TimToady> nr: say 70 ** 7; say 70 R** 7

[18:21] <camelia> rakudo 4e9635, niecza v24-86-g39ab531: OUTPUT¬´8235430000000‚ê§143503601609868434285603076356671071740077383739246066639249‚ê§¬ª

[18:21] <masak> oh, ** :)

[18:21] <TimToady> let's aim for 70 R** 7

[18:21] <timotimo> jnthn: i got the numeric thing in xx due to a sillyness i made mostly; forest fire actually does run

[18:21] <timotimo> just not very much

[18:22] <masak> TimToady: right, but after that, I think the brother's actual malice has been firmly established.

[18:22] <TimToady> let's hear it for Bayse

[18:23] * masak .oO( Bayes-less accusations )

[18:24] *** raiph joined
[18:24] <TimToady> no wonder I couldn't make Bayseian look right...

[18:24] <timotimo> forest fire is b0rked somehow. there's forest, but no fire

[18:25] <TimToady> does the forest grow?

[18:25] <raiph> <TimToady> but my @shaped[*;100] = lol (0 xx *) xx 100 is allowed

[18:25] <raiph> did you get that wrong?

[18:25] <TimToady> raiph: no, the order is backwards because xx varies in the opposite order of subscripting

[18:25] <TimToady> hence the remark about it being backwards

[18:26] <raiph> ah, gotchya

[18:26] <TimToady> we're supplying 100 to the * and * to the 100

[18:26] <TimToady> just can't do * in both places, unless we allow lazy dimensions somehow (brane asplodes)

[18:27] <lizmat> .oO( sixties colours abound )

[18:28] <TimToady> or we say that a coinciding * means that we must wait till one is autovivified to initialize the child

[18:28] <TimToady> maybe that works out

[18:29] <TimToady> but really, initializing only leaves is the bailiwick of 'is default' I suspect

[18:30] <raiph> what's the term for when there's an ideal (semantic+syntax) and something less than ideal but easier to implement that will be forward compatible?

[18:30] <TimToady> hack?

[18:30] <raiph> heh

[18:30] <TimToady> stopgap?

[18:31] <raiph> i meant something that's good planning

[18:31] <TimToady> a partial emulation?

[18:31] <TimToady> a subset?

[18:31] <moritz> incomplete implementation?

[18:31] <raiph> i don't like incomplete

[18:32] <TimToady> subset implementation then

[18:32] <lizmat> suboptimal

[18:32] <TimToady> a realistic implementation :)

[18:32] <raiph> eg, don't allow * for both decl and init in same dimension for now; but this is forward compatible with allowing it later

[18:33] <raiph> so we can formalize an approach toward 6.0.0

[18:33] <TimToady> a deconjectural implementation :)

[18:33] * lizmat now can build rakudo with Nil inheriting from Mu, thanks to jnthn++'s pointers

[18:33] <TimToady> a conservative implementation

[18:33] <moritz> Nil outside Mu?

[18:33] <TimToady> now that we've decided not to?

[18:33] <lizmat> hehe

[18:34] <lizmat> yes, I know we decided not to...

[18:34] <masak> yes, "conservative implementation"

[18:34] <lizmat> call me stubborn  :-)

[18:34] <masak> it's "conservative" because it hedges in such a way that switching to the better way won't break things.

[18:34] <lizmat> I just wanted it to at least build

[18:34] <raiph> yes, i like conservative

[18:34] <TimToady> we might still put Failure outside of Any, if the binding failure message can be taught to throw when it sees "got Failure, expected Any"

[18:35] <lizmat> so coming back to Nil, should it maybe inherit from Any then?

[18:35] <TimToady> that's what it does if you don't say "is Mu'

[18:35] <TimToady> *"

[18:36] <lizmat> I just want to run the spectest with Nil inherting from Mu just once, so I can gist it for future reference

[18:36] <TimToady> but putting Failure outside of Any also makes it impossible to say $x.WHAT === Failure

[18:37] <lizmat> to me, putting Failure outside of Any, doesn't make much sense

[18:38] <lizmat> as anything out of Any basically has different shades of nothingness

[18:38] <TimToady> well, it traps a lot more accidental uses than the method overrides that are currently supplied with Failure

[18:38] <lizmat> and a failure is something

[18:39] <TimToady> my $x = thisfails();  throws, while my Mu $x doesn't

[18:39] <lizmat> and I would consider that a feature

[18:39] <lizmat> just as, if Nil was outside of Any, 

[18:39] <TimToady> most attempts to bind Failure would cause a binding failure, hence the need for binding failure to notice Failure and throw it instead

[18:40] <lizmat> you could only store Nil if it was Mu

[18:40] <TimToady> same deal, but Nil is supposed to be failsofter than Failure

[18:40] <lizmat> as in: my $a=1; $a= Nil  # sets default

[18:40] <lizmat> my Mu $a=1; $a=Nil  # sets Nil

[18:41] <lizmat> please note that neither of the above fail

[18:41] <TimToady> if we wanted Nil to be failsoft outside of Any, we'd have to do things like the autothreader in Junction does to patch things up

[18:42] <TimToady> r: say Nil + 0

[18:42] <camelia> rakudo 4e9635: OUTPUT¬´use of uninitialized value of type Nil in numeric context  in block  at /tmp/vX0MZtiQYr:1‚ê§‚ê§0‚ê§¬ª

[18:42] <TimToady> this sort of thing becomes fatal if Nil is outside of Any, unless we "autothread" it to replace Nil with 0

[18:43] <lizmat> $ perl6 -e 'say Nil + 0'

[18:43] <lizmat> Nominal type check failed for parameter '$a'; expected Any but got Nil instead

[18:43] <lizmat> <Internal error while creating backtrace: Nominal type check failed for parameter 'lhs'; expected Any but got Nil instead   in sub METAOP_TEST_ASSIGN:<||> at src/gen/CORE.setting:14373

[18:43] <TimToady> yes, like that

[18:43] <TimToady> but Perl likes undefineds to warn and then convert to 0 or ''

[18:45] <TimToady> if Nil is outside of Any, does the dispatch failover automatically call Junction::AUTOTHREAD?

[18:45] <lizmat> for the record: diff and spectest result of Nil being outside of Any: https://gist.github.com/lizmat/5940829

[18:46] <lizmat> TimToady: I'm not deep enough in that to answer that yet

[18:46] <TimToady> how many extra spectests fail?  (niecza failed about 26 more)

[18:47] <TimToady> most of them in .trans

[18:49] <TimToady> but I think that's because Nil failsoft semantics are not well tested in roast

[18:49] *** colortiger joined
[18:50] <masak> colortiger: oh hai :)

[18:50] <lizmat> the last test infiniloops, so I had to abort it, hence no summaries

[18:50] <TimToady> well, one could kill the subprocess

[18:51] <TimToady> *kill only

[18:51] *** colortiger left
[18:51] <masak> bye bye, colortiger.

[18:51] <TimToady> Ëâ≤Ëôé, o/

[18:51] <dalek> perl6-roast-data: 2426ce4 | coke++ | / (5 files):

[18:51] <dalek> perl6-roast-data: today (automated commit)

[18:51] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/2426ce4d97

[18:52] <masak> TimToady: ÂëµÂëµ

[18:52] <lizmat> 94.68%

[18:52] <lizmat> TimToady: will rebuild and spectest again  :-)

[18:53] <masak> TimToady: it's kinda cool that we both studied different languages having the same half-impossible character set, and now I get (some of) your kanji jokes without having to go via Google Translate. :)

[18:54] <TimToady> we've long speculated other "autothread" semantics for the Each type; fallback recovery semantics for Nil and Failure are similarly possible

[18:55] <TimToady> masak: well, at this point I actually know more Chinese characters than Japanese

[18:55] <TimToady> I just don't know how to pronounce them

[18:55] <raiph> https://gist.github.com/TimToady/1828667 # is this the right OKness proposal for lizmat to read?

[18:56] <GlitchMr> fail 'Cannot .unshift an infinite list' if @elems.infinite; 

[18:56] <TimToady> she doesn't have to read it really; we're just coming at similar ideas from a different direction

[18:56] <GlitchMr> Why unshifting infinite list would fail.

[18:56] <GlitchMr> IMO, it should replace list with that infinite list.

[18:57] <TimToady> it should just unshift into the reified part, I suspect, and leave the infinite part alone

[18:58] <masak> TimToady: "I know more Chinese characters than Japanese; I just don't know how to pronounce them" -- that's how my knowledge of Chinese characters feels these days :/

[18:58] <GlitchMr> https://github.com/rakudo/rakudo/commit/68301a78dc644229fa747250d7119500103f2baa

[18:58] <GlitchMr> Seriously?

[18:58] <GlitchMr> pop() in like every programming language is RW.

[18:59] <masak> GlitchMr: that one was later reverted.

[18:59] <GlitchMr> ok

[18:59] <lizmat> indeed, and TimToady later specced "is parcel"

[18:59] <TimToady> but that's not what the 'is rw' means there anyway

[18:59] <masak> GlitchMr: and if you're saying pop() is rw in every programming language, I don't think you understand what it does.

[18:59] <TimToady> it's talking about the return value, not the array

[18:59] <GlitchMr> Oh, I see.

[19:00] <lizmat> but pop itself is not a left value, right?

[19:00] <TimToady> it's not 'self is rw'

[19:00] <GlitchMr> But not sure if I understand.

[19:00] <GlitchMr> Why `pop` `is rw` then.

[19:00] <TimToady> it's sort of assumed that an object is mutable anyway

[19:00] <GlitchMr> Why I would want to assign to return value of `pop`?

[19:01] <GlitchMr> (I'm not talking about @array.pop[0] = 42, that still should be fine)

[19:01] <TimToady> because it's like shift, and shift is what drives the mutability of 'for @x { s/foo/bar/ }'

[19:01] <GlitchMr> Oh, right

[19:02] <TimToady> I think that was the upshot of the conversation; correct me if I'm wrong

[19:02] <masak> no, that sounds right.

[19:02] <GlitchMr> With aliases it makes sense, I guess.

[19:03] <TimToady> presumably 'for reverse @x {}' could optimize to pops

[19:03] <masak> Perl 6 doesn't realy have the concept of aliases. it's just binding.

[19:03] <GlitchMr> @array[0] := $value

[19:04] <GlitchMr> Looks aliasy enough for me.

[19:04] <dalek> rakudo/nom: 6319760 | (Elizabeth Mattijsen)++ | src/Perl6/Actions.nqp:

[19:04] <dalek> rakudo/nom: Changes suggested by jnthn to make sure empty {} doesn't generate Nils

[19:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63197602f7

[19:04] <dalek> rakudo/nom: 4e29215 | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[19:04] <dalek> rakudo/nom: Slight cleanup for circumfix {}

[19:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e29215f6a

[19:07] <masak> QAST::OperationsJAST.add_core_op('sprintf', -> $qastcomp, $op { ... }); # what do I put inside the block to make it call the 'sprintf' logic?

[19:07] <masak> or is that the wrong question to ask? should I be using something other than .add_core_op for this?

[19:08] <lizmat> TimToady: wrt unshifting to infinite lists, should that be allowed?

[19:08] <TimToady> didn't I just say that?

[19:09] <masak> jnthn: ping

[19:09] <lizmat> [20:57:16] <TimToady>	 it should just unshift into the reified part, I suspect, and leave the infinite part alone

[19:09] <TimToady> r: my @array = 1..*; @array.unshift: 0; say @a[^5]

[19:09] <camelia> rakudo 4e9635: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable '@a' is not declared‚ê§at /tmp/s5fS7QCI07:1‚ê§------> [32may = 1..*; @array.unshift: 0; say @a[^5][33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modi‚Ä¶

[19:10] <TimToady> r: my @a = 1..*; @array.unshift: 0; say @a[^5]

[19:10] <camelia> rakudo 4e9635: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable '@array' is not declared‚ê§at /tmp/mCJsB4h5kw:1‚ê§------> [32mmy @a = 1..*; @array.unshift: 0[33m‚èè[31m; say @a[^5][0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[19:10] <TimToady> r: my @a = 1..*; @a.unshift: 0; say @a[^5]

[19:10] <camelia> rakudo 4e9635: OUTPUT¬´0 1 2 3 4‚ê§¬ª

[19:10] <lizmat> I guess the "I suspect" made it unsure for me

[19:10] <TimToady> seems like it works already :)

[19:11] <lizmat> r: (1..5).unshift: 0

[19:11] <camelia> rakudo 4e9635: OUTPUT¬´Cannot call 'unshift'; none of these signatures match:‚ê§:(Any:U \SELF: *@values, Mu *%_)‚ê§  in method unshift at src/gen/CORE.setting:1486‚ê§  in block  at /tmp/77RQQ034Ah:1‚ê§‚ê§¬ª

[19:12] <lizmat> r: (1..*).unshift: 0

[19:12] <camelia> rakudo 4e9635: OUTPUT¬´Cannot call 'unshift'; none of these signatures match:‚ê§:(Any:U \SELF: *@values, Mu *%_)‚ê§  in method unshift at src/gen/CORE.setting:1486‚ê§  in block  at /tmp/r1D3TN5vyM:1‚ê§‚ê§¬ª

[19:12] <TimToady> I doubt that Range has an unshift

[19:12] <lizmat> indeed

[19:12] <lizmat> r: (1..*).list.unshift: 0

[19:12] <camelia> rakudo 4e9635:  ( no output )

[19:12] <lizmat> r: say (1..*).list.unshift: 0

[19:12] *** crab2313 left
[19:13] <camelia> rakudo 4e9635: OUTPUT¬´(timeout)¬ª

[19:13] <TimToady> someone is being overly eager, seems

[19:13] <lizmat> r: my @a=1..*; say @a.infinite

[19:13] <TimToady> oh, the say is :)

[19:13] <camelia> rakudo 4e9635: OUTPUT¬´True‚ê§¬ª

[19:14] <TimToady> r: say ((1..*).list.unshift: 0)[^5]

[19:14] <camelia> rakudo 4e9635: OUTPUT¬´0 1 2 3 4‚ê§¬ª

[19:14] <TimToady> there you go

[19:14] <TimToady> so already works

[19:14] <lizmat> which is odd, as the code says:

[19:14] <lizmat>     multi method unshift(List:D: *@elems) {

[19:14] <lizmat>         fail 'Cannot .unshift an infinite list' if @elems.infinite;

[19:15] <TimToady> perhaps slurpy arrays don't know that

[19:15] <TimToady> oh the @elems is just the 0

[19:15] <TimToady> means you can't say [email@hidden.address] 1..*'

[19:16] <TimToady> since it would presumably have to prepend the reified list with something non-reified

[19:17] <TimToady> arguably it could be allowed if the reified portion were empty, but it seems of little utility to allow it

[19:18] * lizmat updated https://gist.github.com/lizmat/5940829 with complete test + summaries

[19:18] <TimToady> but it's perfectly okay to unshift real things into the reifiedlist

[19:19] <[Coke]> https://gist.github.com/coke/5879701 updated. yay, new errors.

[19:23] <lizmat> brb

[19:25] <[Coke]> jnthn: someone fixed a bunch of "Nominal type check failed"

[19:27] *** kaare__ left
[19:30] <[Coke]> r: say 12+68+1+123+56+30+131+130+22 # number of rakudo-jvm tests aborted due to sprintf

[19:30] <camelia> rakudo 4e2921: OUTPUT¬´573‚ê§¬ª

[19:31] <masak> ooh, that's an attractive prize.

[19:31] <masak> I'm currently blocking on not knowing enough about nqp internals.

[19:31] <FROGGS> masak: I'm making #-option of %X work right now

[19:31] <masak> FROGGS++

[19:32] <jnthn> [Coke]: Yes, that was me yesterday ;)

[19:33] *** domidumont left
[19:33] <[Coke]> the list of aborts is getting smaller!

[19:33] <[Coke]> I was able to generate it much quicker today.

[19:33] <dalek> rakudo/nom: 7d7df4a | (Elizabeth Mattijsen)++ | src/core/List.pm:

[19:33] <dalek> rakudo/nom: Remove useless fail in unshift

[19:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d7df4af01

[19:34] <[Coke]> here's a new one, jnthn : java.lang.RuntimeException: No such attribute '$!do' for this object

[19:35] <jnthn> masak: pong

[19:35] <jnthn> [Coke]: Is list updated?

[19:35] <[Coke]> jnthn: aye

[19:35] <jnthn> ah, I see it

[19:36] <jnthn> Yeah, though I don't think it's a regression, I think it's that we didn't get that far into that test before.

[19:36] <[Coke]> jnthn: right, yah. Fix one failure, get another.

[19:36] <masak> jnthn: see my question at http://irclog.perlgeek.de/perl6/2013-07-06#i_7298362

[19:37] <[Coke]> it used to block on shell()

[19:37] <jnthn> masak: Hmmm

[19:38] <jnthn> masak: I think the best bet is to install the sprintf implementation using nqp::bindhllsym('nqp', 'sprintf', ...)

[19:39] <jnthn> masak: And then make a QAST::Op.new( :op('call'), QAST::Op.new( :op('gethllsym'), nqp/sprint SVals here ), ...push children of op here... )

[19:40] <lizmat> WWZ&

[19:40] <masak> the 'and then make' part being the contents of that block?

[19:42] <jnthn> Of the add_core_op one? Yes

[19:42] <jnthn> Then the only question is where to put the sprintf impl :)

[19:42] <jnthn> Maybe in src/core/sprintf.nqp, and make sure it goes inside a block so that it doesn't leak out as a function.

[19:43] <jnthn> And then just include it in the JVM build for now.

[19:43] <jnthn> (by adding to Makefile-JVM.in or whatever it's called)

[19:45] <masak> *nod*

[19:45] <masak> requesting clarification on "make sure it goes inside a block so that it doesn't leak out as a function".

[19:46] <masak> how then will I be able to call it with the :op('call') thing?

[19:46] <jnthn> 'cus you're stashing it in the "secret" guts-y namespace thing

[19:46] <jnthn> That's what the gethllsym thing is for.

[19:48] <masak> could you link me to an example of this so I can see how it's done?

[19:49] <jnthn> I guess ModuleLoader.nqp uses the mechanism

[19:49] <jnthn> And then somewhere in NQP::World it does the other part (the lookup)

[19:50] <masak> oki

[19:50] <masak> that should be enough to get me started. thank you.

[19:50] <Teratogen> poor 777

[19:52] *** dmol left
[19:52] *** dmol joined
[19:55] <FROGGS> masak: I'm adding now (just locally) all sprintf tests from roast

[19:55] <FROGGS> but I guess next important things are %f and %e/%E

[19:58] <diakopter> Teratogen: a 777?

[19:58] *** berekuk joined
[19:59] <masak> FROGGS: yes, I think so.

[19:59] <masak> FROGGS: will be interesting to see the results of the sprintf/roast collision.

[19:59] <masak> FROGGS: you're essentially doing (b), then ;)

[20:00] <FROGGS> I'll gist it

[20:00] <FROGGS> right :o)

[20:00] <FROGGS> (a) is up to you :o)

[20:01] *** xilo_ left
[20:01] <masak> *nod*

[20:08] *** djanatyn joined
[20:09] <[Coke]> jnthn: I golfed the duplicate method error to this snippet:

[20:09] <[Coke]> 'a;b,c,' ~~ m/(<.alpha>) +%% (<.punct>)/;

[20:09] <[Coke]> seeing if I can further golf it.

[20:10] *** ajr_ left
[20:10] *** xilo_ joined
[20:12] * masak hopes juxtaposing '+' and '%%' like that doesn't become the norm

[20:12] <Teratogen> diakopter, 777 crashed at SFO

[20:15] <perigrin> Reports say most of the people are safe though.

[20:15] <diakopter> hunh; tail hit the rocky edge of the runway/shore

[20:17] * perigrin has never landed at SFO but can see how that could happen

[20:17] <[Coke]> jnthn:  '' ~~ m/'a' +%% ('b')/;

[20:17] <[Coke]> rn: say '' ~~ m/'a' +%% ('b')/;

[20:17] <masak> actually I think I'm less against juxtaposing '+' and '%%' than I am against introducing whitespace between the atom and the postfix '+'...

[20:17] <camelia> rakudo 7d7df4, niecza v24-86-g39ab531: OUTPUT¬´False‚ê§¬ª

[20:17] <sorear> good * #perl6

[20:18] <masak> sorear! \o/

[20:18] <[Coke]> sorear: ^^ there's the duplicate method culprit.

[20:18] <masak> [Coke]: why do you write `'a' +%%` and not `'a'+ %%` ?

[20:18] <masak> [Coke]: you must have a different mental model of what those operators do :)

[20:19] <jnthn> masak: I suspect [Coke]++ was golfing it from a test...

[20:19] <sorear> Teratogen: any survivors?

[20:19] <diakopter> sorear: seems all but two

[20:19] <Teratogen> there are reports of two deaths

[20:19] <Teratogen> but it is all up in the air right now

[20:19] <Teratogen> a lot of people were seen coming down chutes

[20:21] <jnthn> .oO( I'm pretty sure the plane is not still up in the air right now... )

[20:22] <FROGGS> masak: pasting the result of running roasts test too is sort of boring, the first 20 passes, then one kills the rest :o)

[20:23] <jnthn> [Coke]: Turns out it can be golfed to nqp -e "/'a' +%% ('b')/"

[20:25] <TimToady> masak: one writes it that way to allow whitespace after the left side in a rule

[20:25] <masak> FROGGS: could you maybe note down the killer in some list somewhere, and comment it out?

[20:26] <TimToady> doesn't matter otherwise

[20:26] <masak> TimToady: right. this isn't a rule.

[20:26] <FROGGS> it was %i, I post the out in a sec

[20:27] <TimToady> nevertheless, if people get used to +%%, they'll right it more correctly for rules, on average

[20:27] <TimToady> *write

[20:27] <jnthn> %% is the one that means "and we can match another one afterwards", right?

[20:27] <TimToady> it means they can come out even :)

[20:27] <jnthn> yeah

[20:27] * jnthn can see what's wrong but...hm, how to fix that...

[20:28] <FROGGS> masak: https://gist.github.com/FROGGS/0fdcdde74679e512f097

[20:28] * masak looks

[20:29] <FROGGS> masak: the commented out tests do not parse

[20:29] <FROGGS> (in the diff around line 100)

[20:29] <masak> FROGGS: wow, that still looks like really good news!

[20:29] <FROGGS> yes, indeed

[20:30] <masak> jnthn: could you please have a look at https://gist.github.com/masak/5a34e6893a80a5420c2d ?

[20:30] <FROGGS> mostly e, f, g

[20:30] <TimToady> also, since %% requires a quantifier, it's arguably better to put the quantifier with it, to avoid the \w+ %% ',' confusion

[20:30] <TimToady> with \w +%% ',' it's more obvious what's wrong

[20:30] <masak> FROGGS: e, f, g are challenging but by no means impossible.

[20:30] <FROGGS> yeah, I'm going for %f now

[20:31] <TimToady> so I think +%% is a good thing, on average

[20:31] <masak> TimToady: ok, you convinced me.

[20:31] <jnthn> masak: "nqp/sprint SVals here" was an instruction to you :P

[20:31] <TimToady> and I like it better than <foo> + %% <bar>

[20:31] <masak> jnthn: yes, I realize that :) just wondering what it should be :)

[20:31] <jnthn> two QAST::SVal nodes

[20:31] <masak> ok, hold on.

[20:31] <jnthn> (for nqp, then sprintf

[20:32] <sorear> rn: say 5 Rxx rand

[20:32] <camelia> rakudo 7d7df4: OUTPUT¬´0.70025693867089 0.70025693867089 0.70025693867089 0.70025693867089 0.70025693867089‚ê§¬ª

[20:32] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´0.77211467026365677 0.77211467026365677 0.77211467026365677 0.77211467026365677 0.77211467026365677‚ê§¬ª

[20:32] <FROGGS> no cookie for both

[20:33] <masak> jnthn: like this? https://gist.github.com/masak/5a34e6893a80a5420c2d

[20:33] <jnthn> masak: right

[20:33] <masak> hm, sorear++ just found a bug in two implementations ;)

[20:33] <masak> rn: say rand() xx 5

[20:33] <camelia> niecza v24-86-g39ab531: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unsupported use of rand(); in Perl 6 please use rand at /tmp/dnlJsPVO8F line 1:‚ê§------> [32msay rand[33m‚èè[31m() xx 5[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[20:33] <camelia> ..rakudo 7d7df4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of rand(); in Perl 6 please use rand‚ê§at /tmp/Y8U3jpzN6N:1‚ê§------> [32msay rand[33m‚èè[31m() xx 5[0m‚ê§¬ª

[20:33] <masak> rn: say rand xx 5

[20:33] <camelia> niecza v24-86-g39ab531: OUTPUT¬´0.62266399973196163 0.18375288144860086 0.37745106424086311 0.96518965482953456 0.73068906819945623‚ê§¬ª

[20:33] <camelia> ..rakudo 7d7df4: OUTPUT¬´0.181609341499524 0.340130289589194 0.252906549579116 0.617402868939354 0.385966828776859‚ê§¬ª

[20:34] <masak> right.

[20:34] * masak submits rakudobug

[20:34] <masak> I'm just assuming that if infix:<xx> thunks its lhs, then infix:<Rxx> should thunk its rhs.

[20:35] <sorear> masak: it's a very long-standing behavior of niecza that weakly macroey operators lose their macroness when metaopped

[20:35] <[Coke]> masak: jnthn is right, I don't expect that to do anything except not generatea  weird java bytecode issue.

[20:36] <sorear> masak: because metaops require a coderef

[20:36] <masak> sorear: that sounds like an argument against this being a bug.

[20:36] <sorear> strongly macroey operators like := can't be metaopped at all

[20:36] <sorear> rn: my $x;  5 R:= $x; say $x

[20:37] <camelia> rakudo 7d7df4: OUTPUT¬´Nominal type check failed for parameter 'op'; expected Any but got Mu instead‚ê§  in sub METAOP_REVERSE at src/gen/CORE.setting:14378‚ê§  in block  at /tmp/qy3FLcnjuj:1‚ê§‚ê§¬ª

[20:37] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Cannot reverse the args of := because list assignment operators are too fiddly at /tmp/zIuIfbFJwJ line 1:‚ê§------> [32mmy $x;  5 R:=[33m‚èè[31m $x; say $x[0m‚ê§‚ê§This macro cannot be used as a function at /tmp/zIuIfbFJwJ line ‚Ä¶

[20:37] * masak submits LTA rakudobug

[20:39] *** domidumont joined
[20:39] <sorear> done with backlog

[20:41] *** domidumont left
[20:43] <masak> jnthn: why the two SVals 'nqp' and 'sprintf', by the way?

[20:44] <jnthn> masak: They're the operands to look up the thing you installed with nqp::bindcurhllsym

[20:44] <FROGGS> like nqp::sprintf, no?

[20:45] <jnthn> masak: oh, wait

[20:45] <jnthn> You do need gethllsym, not getcurhllsym, there

[20:45] <masak> that sounds... circular.

[20:45] <masak> ok.

[20:45] <jnthn> And just sprintf

[20:45] <jnthn> uh, dammit

[20:45] <jnthn> You need both args

[20:45] <jnthn> But gethllsym

[20:45] <jnthn> Otherwise it won't work out in Rakudo...

[20:45] <masak> still 'nqp' and 'sprintf'?

[20:45] <jnthn> yes

[20:46] <masak> I confess to being utterly confused as to the distinction between gethllsym and getcurhllsym.

[20:46] <sorear> why are we using an op here and not a global function?

[20:47] <sorear> masak: do you remember how Parrot's namespace worked?

[20:47] <sorear> We're emulating that.

[20:47] <jnthn> sorear: Installing stuff with one of these is as close as you get to a global function.

[20:47] <jnthn> Well, but we don't have any nesting besides HLL name and symbol.

[20:47] <masak> sorear: my goal tonight is to bind nqp:sprintf (an op) to a global(-ish) function (on JVM only).

[20:47] <jnthn> masak: cur means "current HLL"

[20:48] <masak> I guessed that.

[20:48] <sorear> masak: the global namespace in parrot is segregated by HLL name

[20:48] *** pmurias joined
[20:48] <sorear> nqp;sprintf is a different symbol from perl6;sprintf

[20:48] <masak> ok.

[20:49] <jnthn> Grr. That %% bug is hard to fix by building a different AST...

[20:50] <sorear> today: document jvmbootinterop and/or explain the design principles to jnthn

[20:50] <jnthn> The easiest fix is to fiddle with QAST::Block code-gen to not spit out the same block twice...

[20:52] * TimToady is just a little distracted by the plane crash at SFO...

[20:55] <masak> aww. got 'Can not invoke this object' during compilation of NQPCORE.setting

[20:56] *** rindolf left
[20:56] <masak> that probably means I embedded things wrongly in src/core/sprintf.nqp

[20:59] <jnthn> [Coke]: Trying a patch for S05-capture/caps.rakudo.jvm now, looks promising...

[20:59] <jnthn> masak: prolly

[20:59] *** FROGGS left
[20:59] <jnthn> masak: Which compilation, ooc?

[21:00] <jnthn> stage1 or 2?

[21:00] <masak> stage1

[21:00] <jnthn> ok, then it almost certainly really is inside what you added

[21:00] <masak> would it help if I gisted it?

[21:01] <jnthn> I can look

[21:01] <masak> https://gist.github.com/masak/d04ffe773bdfdc07d7e3

[21:01] <cognominal> that would be nice, when  $<foo> is an array to have an array method .ast  that did :     .map: *.ast

[21:02] <cognominal> masak, what is knowhow?

[21:02] <dalek> nqp: ad036ee | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[21:02] <dalek> nqp: Don't spit out same QAST::Block twice.

[21:02] <dalek> nqp: 

[21:02] <dalek> nqp: Fixes S05-capture/caps.t in Rakudo; [Coke]++ for golfing.

[21:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ad036ee744

[21:03] <jnthn> masak: method sprintf($format, *@arguments) {

[21:03] <jnthn> Should that not be sub?

[21:03] <jnthn> masak: And then in the nqp::bindcurhllsym('sprintf', sprintf); in the same scope

[21:03] <jnthn> And should probably be &sprintf

[21:04] <dalek> rakudo-js: 643e321 | (Pawel Murias)++ | runtime/serialization.js:

[21:04] <dalek> rakudo-js: Closure deserialization without binding contexts.

[21:04] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/643e321abf

[21:04] <dalek> rakudo-js: 2bceb50 | (Pawel Murias)++ | / (2 files):

[21:04] <dalek> rakudo-js: What we call an outer context is really a caller context.

[21:04] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/2bceb50287

[21:04] <dalek> rakudo-js: 2c2c39c | (Pawel Murias)++ | / (4 files):

[21:04] <dalek> rakudo-js: Move out Ctx to a seperate file. Create closures with an outer lexical, static variables still missing.

[21:04] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/2c2c39cf11

[21:04] <dalek> rakudo-js: b9dc21c | (Pawel Murias)++ | / (4 files):

[21:04] <dalek> rakudo-js: Fix bugs.

[21:04] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/b9dc21caa6

[21:04] <jnthn> masak: I'd also make it a "my module sprintf..." or so and remove the sprintf:: on the grammar/actions decl

[21:04] *** FROGGS joined
[21:05] <sorear> TimToady: In what sense is .inheritIO like $[ ?  I see it as the Java named argument faking pattern

[21:05] <sorear> o/ FROGGS 

[21:06] <masak> jnthn: oki

[21:06] <FROGGS> hi sorear 

[21:06] * sorear wonders if jnthn has seen the thread-starting gist

[21:06] <masak> jnthn: ok, that makes more sense.

[21:06] <masak> jnthn: I changed 'sub' to 'method' because I was basing things off ModuleLoader.

[21:06] *** pmurias_ left
[21:07] <masak> cognominal: 'knowhow' is a low-level MOP object in nqp.

[21:07] <jnthn> sorear: Yes!

[21:07] <jnthn> masak: Ah...

[21:07] <jnthn> sorear: Didn't try running it though... :)

[21:09] <masak> wat, nqp, you don't know what a "modeul" is!? oh...

[21:09] <jnthn> :P

[21:10] * masak .oO( it's Korean! )

[21:10] <[Coke]> ah, we will probably also get the FormatConversionException errors with a working sprintf

[21:10] <jnthn> yeah

[21:10] <masak> we'll... get them?

[21:10] <jnthn> well, get rid of... :P

[21:10] <masak> yeah, that's the idea.

[21:10] *** bruges_ joined
[21:11] <masak> bruges_: aloha.

[21:12] <masak> jnthn: updated sprintf.nqp and with added stacktrace: https://gist.github.com/masak/d04ffe773bdfdc07d7e3

[21:12] <masak> seems it fails during parse.

[21:13] <jnthn> class sprintf::Actions # did you meant to keep the sprintf:: there?

[21:14] <jnthn> hmmm

[21:14] <jnthn> masak: Where did you add it, ooc?

[21:15] <masak> hm, no; I'll remove the sprintf:: there too.

[21:15] <jnthn> Near to the end?

[21:15] <masak> jnthn: I added a line in tools/build/Makefile-JVM.in

[21:15] <masak> yeah, after testing.nqp

[21:16] <jnthn> hmmm

[21:16] <masak> before YOUAREHERE.nqp

[21:16] <jnthn> Thing is that NQPRegex, the code objct for NQP regex-y things, is also declared in the NQP setting.

[21:17] <jnthn> Wondering if we're hitting a "can't do this yet" thing...

[21:17] <jnthn> Oh...

[21:17] <jnthn> ...we don't actually have QRegex compiled at this point either.

[21:17] <jnthn> That can't help...

[21:17] <jnthn> masak: Let's put it in the HLL lib instead.

[21:17] <jnthn> We know grammars/actions work in there :)

[21:18] <masak> ok.

[21:18] <masak> src/HLL/sprintf.nqp ?

[21:18] <jnthn> wfm

[21:21] <masak> seems to work much better :)

[21:21] <masak> jnthn++

[21:22] <jnthn> :)

[21:24] <jnthn> hm, think I may have figured out why version.t explodes...

[21:29] <masak> ok, I got all the way to stage2 this time ;)

[21:29] <jnthn> ooh

[21:29] <jnthn> And then? :)

[21:29] <masak> "Method 'jast' not found" during compilation of src/stage2/gen/QRegex.nqp

[21:30] <jnthn> ...what?!

[21:30] <jnthn> oh, OK, NFA.nqp mentions nqp::sprintf, so I guess that's our first use of it

[21:31] <jnthn> Can I see the QAST::CompilerJAST patch?

[21:31] <masak> https://gist.github.com/masak/5a34e6893a80a5420c2d

[21:32] <jnthn> woo, I have a passing verstion.t

[21:32] <jnthn> oh, oops

[21:33] <jnthn> yeah, you need to compile that QAST

[21:33] <jnthn> $qastcomp.as_jast(QAST::Op.new( ... ))

[21:33] <jnthn> Also, after :op('call'), add a :returns(str),

[21:34] <jnthn> The problem is that something registered with add_core_op needs to return JAST, not QAST, even if it is just desugaring.

[21:35] <masak> ah.

[21:36] <masak> :returns(str) like that? not :returns('str') or something?

[21:36] <jnthn> Like that; it expects a 6model obj

[21:36] <jnthn> Well, a real type

[21:37] <masak> I see :returns($TYPE_STR) elsewhere in that file.

[21:37] <jnthn> This is one of the places QAST and 6model intersect in a deeper way :)

[21:37] * jnthn looks

[21:37] <jnthn> JAST::Method.new( :name('hllName'), :returns($TYPE_STR), :static(0) )

[21:37] <jnthn> masak: That's a JAST node, not a QAST one ;)

[21:38] <FROGGS> masak: %f is working for the given tests... https://gist.github.com/FROGGS/0fdcdde74679e512f097

[21:39] <FROGGS> I wonder how we detect bigint stuff...

[21:40] <masak> FROGGS: nice!

[21:40] <masak> yes, I haven't dug into bigint matters at all.

[21:41] <FROGGS> I'm not sure we can say: hey, this arg is a bigint, lets use abs_I instead of abs_i

[21:41] <jnthn> I wonder if we should provide a way to configure the bigint types

[21:42] <jnthn> Then at some point in the setting nqp::gethllsym('nqp', 'sprintf_bigint_reg')(Int) or so

[21:42] <FROGGS> sounds nice... what does it do?

[21:43] <jnthn> I dunno, I ain't the one implementing sprintf :P

[21:43] <FROGGS> hehe

[21:43] <jnthn> Maybe you keep an array of known bigint types and just see if the thing you have matches that type...

[21:43] <masak> wat... build completed!

[21:43] <jnthn> Or just make it a scalar

[21:43] <jnthn> wat wat

[21:44] <masak> $ ./nqp

[21:44] <masak> > sprintf("OH HAI")

[21:44] <masak> java.lang.NullPointerException

[21:44] <masak> hehe.

[21:44] <FROGGS> hehe

[21:44] <jnthn> nqp::sprintf

[21:44] <masak> oh!

[21:44] <FROGGS> wait for it...

[21:44] <jnthn> Not sure if nqp's repl auto-prints...

[21:44] <masak> > say(nqp::sprintf("OH HAI"))

[21:44] <masak> OH HAI

[21:44] <masak> \o/

[21:44] <jnthn> \o/

[21:44] <FROGGS> \o/

[21:44] <jnthn> masak++

[21:44] <FROGGS> masak++

[21:44] <masak> I really didn't expect that.

[21:44] <masak> any test I can do to make sure it's really ours?

[21:45] <masak> I guess anything with %f...

[21:45] <FROGGS> %B?

[21:45] <masak> > nqp::sprintf("%f", 4.2)

[21:45] <masak> 'f' is not valid in sprintf format sequence '%f'

[21:45] <masak> yes, it's ours.

[21:45] <FROGGS> cool

[21:45] <masak> > say(nqp::sprintf("%B", 1000))

[21:45] <masak> 1111101000

[21:46] <masak> ok, so. I'll commit and push this, yes? :)

[21:46] <jnthn> go for it, imho

[21:46] <dalek> rakudo/nom: 516d49f | jnthn++ | src/vm/jvm/Perl6/Ops.nqp:

[21:46] <dalek> rakudo/nom: Fix // compilation, thus fixing version.t.

[21:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/516d49f504

[21:47] <jnthn> There's 35 more from version.t, and maybe a few more from elsewhere

[21:48] <dalek> nqp: 2057ed3 | masak++ | / (3 files):

[21:48] <dalek> nqp: add nqp-native nqp::sprintf for the JVM backend

[21:48] <dalek> nqp: 

[21:48] <dalek> nqp: The plan is to extend this implementation until it passes all of the

[21:48] <dalek> nqp: roast spectests that the Parrot backend passes. Until then, it's

[21:48] <dalek> nqp: JVM-specific, though, because currently the JVM implementation will

[21:48] <dalek> nqp: benefit from having this one rather than what it had before.

[21:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2057ed3b0d

[21:48] <masak> FROGGS: I didn't check whether you have pushed commits since I copy-pasted. checking now.

[21:49] <FROGGS> I have not I guess

[21:49] <masak> yes, it seems I missed 3b345540

[21:49] <masak> feel free to port it over.

[21:49] <FROGGS> ohh, k

[21:49] <masak> hm, any reason I should keep my github repo at this point?

[21:49] <masak> maybe I should delete it?

[21:49] <jnthn> masak++, FROGGS++, (others who helped)++

[21:49] <FROGGS> masak: go ahead

[21:50] * masak deletes

[21:51] <FROGGS> hmmm, is there a sprintf.t?

[21:51] <masak> FROGGS: nope.

[21:51] * jnthn installs the updated NQP and builds a Rakudo against it

[21:51] <masak> FROGGS: we might want to port that over, too.

[21:51] <masak> FROGGS: but my time is up for today, realistically.

[21:51] <FROGGS> yeah, makes sense if it is an nqp-native

[21:52] <FROGGS> I'll add it

[21:52] <masak> FROGGS++

[21:52] <FROGGS> :o)

[21:52] <masak> FROGGS: remember that it's JVM-only for now.

[21:52] <FROGGS> yeah...

[21:53] <jnthn> There's a t/jvm

[21:53] <jnthn> We can move the test file later when it comes standard on all impls

[21:54] <FROGGS> that was what I was looking for right now :o)

[21:54] <FROGGS> thanks

[21:54] <FROGGS> btw, how do I proper make clean?

[21:54] <jnthn> There's a make clean target, no?

[21:54] <FROGGS> yes, but it doesnt help

[21:55] <jnthn> if it's improper I suggest properizing it

[21:55] <masak> git clean -dfx, perhaps?

[21:55] <FROGGS> main class 'nqp' wasn't found or something like that

[21:55] <jnthn> Oh, did you re-Configure?

[21:55] <FROGGS> ahh, git clean.... I try that

[21:55] <jnthn> 'cus a file was added...

[21:55] <masak> yeah.

[21:55] <FROGGS> ohh, yeah, that too

[21:55] <masak> rakudo is better than nqp at detecting when you have an outdated Makefile

[21:55] <jnthn> masak: Did you trying building Rakudo against this?

[21:55] <jnthn> ...no, you didn't :(

[21:56] <FROGGS> :o(

[21:56] <jnthn> --stagestats uses nqp::sprintf.

[21:56] <jnthn> Apparently, a not-working feature of nqp::sprintf.

[21:56] <FROGGS> which one?

[21:56] <FROGGS> I'll add it :P

[21:56] <jnthn> Cannot stringify this in statement (src/stage2/gen/NQPHLL.nqp:2099)

[21:56] <FROGGS> hmmm

[21:56] <masak> oh, that's interesting.

[21:56] <masak> jnthn: doesn't Rakudo fix a version of nqp?

[21:57] <masak> and build against that?

[21:57] <jnthn> oh...nqp::join

[21:57] <jnthn> masak: For Rakudo JVM we're always doing HEAD 

[21:57] <masak> oh!

[21:57] <masak> sorry, I didn't realize.

[21:57] <jnthn> masak: Otherwise it'd be bump all the way...

[21:57] <jnthn> np

[21:57] <FROGGS> jnthn: we should use join() ?

[21:57] <masak> should I revert the nqp commit for now?

[21:57] <FROGGS> still compiling...

[21:58] *** spider-mario left
[21:58] <jnthn> masak: nah, let's fixing it

[21:58] <jnthn> @pieces.push: infix_x(padding_char($st), $st<size>.ast - nqp::chars($st.ast)) if $st<size>;

[21:58] <jnthn> ...huh, nqp supports that syntax?

[21:58] <jnthn> nqp: my @a; @a.push: 123; say(@a[0])

[21:58] <camelia> nqp: OUTPUT¬´123‚ê§¬ª

[21:58] <jnthn> wow!

[21:58] <jnthn> I didn't know that!

[21:58] <FROGGS> *g*

[21:59] <masak> NQP: Quiter than you'd think!

[21:59] * jnthn tries a fix

[22:04] <jnthn> dammit, no

[22:07] <jnthn> Stage %-11s: %7.3f

[22:07] <jnthn> That's the format

[22:07] <masak> oh, we don't do %f yet.

[22:07] <FROGGS> I can push %f support in a sec

[22:07] <jnthn> ok

[22:07] <masak> \o/

[22:07] <masak> feel free to take any action necessary to make Rakudo-JVM continue to build.

[22:07] <masak> I'm going to bed.

[22:07] <masak> 'night, #perl6

[22:08] <jnthn> FROGGS: Can test if it works with --stagestats fwiw

[22:08] <jnthn> FROGGS: Even with just nqp

[22:08] <FROGGS> k

[22:08] <FROGGS> gnight masak 

[22:09] <FROGGS> k, I see the fail on an unpatched sprintf

[22:10] <FROGGS> jnthn: so should I use join() instead of nqp::join()?

[22:10] <FROGGS> I remember that you mentioned it last week

[22:10] <sorear> masak++ FROGGS++ et-al++

[22:10] <jnthn> FROGGS: I'm not sure that's the actual problem here, though

[22:10] <jnthn> FROGGS: That explodes with a different error.

[22:10] <FROGGS> k

[22:11] <jnthn> Here it really is finding a something it doesn't know how to stringify.

[22:11] <jnthn> Meaning calling join(...) won't help as it just stringifies all the bits...

[22:12] <sorear> um

[22:12] <sorear> PIRT?  fresh_p()?  what is this

[22:12] <jnthn> huh? Where?

[22:12] * sorear looking at jnthn's defor patch

[22:12] <FROGGS> fresh prince?

[22:12] <jnthn> sorear: The -'s, removing commented out code?

[22:13] <sorear> yes

[22:13] <jnthn> sorear: The JVM Ops.nqp started out as a copy of the Parrot Ops.nqp all commented out

[22:13] <jnthn> sorear: And I uncommented/translated

[22:13] <sorear> what's that used for?  surely we couldn't have passed 92% without a working //

[22:13] <jnthn> This was one of the last pieces, if not the last one.

[22:13] <jnthn> It "worked"

[22:13] <jnthn> It was using isconcrete

[22:13] <jnthn> Which works for most cases

[22:14] <jnthn> But not for things you actually need to call .defined on. Like a Failure.

[22:14] <jnthn> btw, it's 94% now :P

[22:16] <sorear> jnthn: is PIRT QPOST?

[22:16] <jnthn> Yes

[22:16] <jnthn> Its main difference is it collapses to a string ASAP rather than keeping a gazillion nodes around in memory.

[22:16] <jnthn> Well

[22:16] <jnthn> "ASAP"

[22:17] <jnthn> Once a QAST::Block is done.

[22:17] *** iSlug left
[22:18] <FROGGS> ahh

[22:18] * jnthn suddenly wonders if the interop stuff is gonna be efficient enough to use ASM directly from QAST::Compiler ;)

[22:18] <jnthn> Though it may not be convenient :)

[22:18] <FROGGS> jnthn: in HLL::Compiler it gets an arrayref

[22:19] <jnthn> FROGGS: nqp::sprintf normally takes an array no?

[22:19] <jnthn> oh!

[22:19] <FROGGS> no

[22:19] <jnthn> sub sprintf($format, *@arguments)

[22:19] <jnthn> yeah :)

[22:19] <FROGGS> :o)

[22:19] <jnthn> It should be @arguments :)

[22:19] <jnthn> That's how the op is expected to be :)

[22:19] <FROGGS> k

[22:20] <FROGGS> then it should now be fine on my box... we'll see

[22:22] *** snoopy joined
[22:22] <FROGGS> This representation can not unbox to a native str

[22:23] <FROGGS> :/

[22:23] <sorear> jnthn: should be.  there's no reflection going on, it basically just generates sub foo($a,$b,$c) { nqp::box_j(whatever(nqp::unbox_j($a), ...)) }

[22:23] <jnthn> neat

[22:23] <jnthn> FROGGS: OK, *that's* the join/nqp::join error :)

[22:23] <FROGGS> yeah, already changed && compiling

[22:24] <jnthn> .oO( a much better approach than changed & compiling )

[22:24] * lizmat is back from WWZ

[22:24] <jnthn> There's a Zth world war?

[22:24] <lizmat> Brad Pitt's newest flick

[22:24] <jnthn> oh!

[22:24] * jnthn hadn't heard of it :)

[22:24] <perigrin> based on a book of the same title.

[22:25] * FROGGS haz kids, so no cinema for poor FROGGS

[22:25] <lizmat> the way I understand it, is that the movie has not a lot to do with the book anymore

[22:25] <perigrin> Kids enjoy seeing movies too.

[22:25] <FROGGS> jnthn: works

[22:25] <perigrin> lizmat: yeah I've heard it more as "based on the title of a book of the same name."

[22:25] <sorear> jnthn: OTOH, it would basically kill any chance of ever supporting cross compiling again :(

[22:27] <dalek> nqp: 74575f5 | (Tobias Leich)++ | src/HLL/sprintf.nqp:

[22:27] <dalek> nqp: impliment %f and changed param to be non-slurpy

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/74575f5e91

[22:28] *** dmol left
[22:29] <FROGGS> jnthn: "use Test" is implicit?

[22:30] <sorear> FROGGS: there's no Test in nqp,  ok() and plan() are in the setting

[22:30] <jnthn> sorear: oh, good point

[22:30] <FROGGS> sorear: k, thanks

[22:30] <jnthn> FROGGS: Does --stagestats work now?

[22:30] <FROGGS> jnthn: yes

[22:31] *** dmol joined
[22:31] <sorear> jnthn: that said, cross compile doesn't quite work at the moment anyway.  -target=jast output is missing the calls to nqp::deserialize - haven't looked closely.

[22:32] <jnthn> sorear: Probably that jast isn't recognized as a precomp target

[22:36] <timotimo> you people seem to be haling fun :)

[22:36] <timotimo> i'm glad

[22:36] <timotimo> jnthn: you didn't get around to making compile-time inlining yet afaict?

[22:39] <jnthn> timotimo: no

[22:39] <jnthn> Won't get to it today

[22:39] <jnthn> Did fix some tests though :)

[22:40] <timotimo> yeah, it's all good :)

[22:40] <timotimo> i'm just reasonlessly fixated on benchmarking and performance improvements for some reason ;)

[22:41] <jnthn> It's nice to make things faster, but also good to keep chewing through the spectest fails.

[22:42] <timotimo> has the 95% mark been reached in the mean time? last i saw we were a bit past 94%

[22:42] <jnthn> Though I said on my blog the aim was for 95% by the next Rakudo compiler release, and I think we're gonna make that.

[22:42] <timotimo> sounds doable indeed

[22:42] <jnthn> I'm not sure whether we've made it yet. We stand a good chance of doing so in the run tomorrow; if this sprintf stuff works then we'll certainly make it.

[22:43] <jnthn> We may even hit 96% or so

[22:43] <timotimo> that would be swell :)

[22:43] <jnthn> FROGGS: I'm...not sure it gives quite the right output ;)

[22:43] <jnthn> Stage start      :       0

[22:43] <timotimo> but the compiler release is still a week into the future, no?

[22:43] <jnthn> Not sure

[22:43] * jnthn checks

[22:43] <sorear> next rakudo compiler release?  I think we're likely to get to 95, yeah :)

[22:43] <jnthn> 2013-07-18   Rakudo #66                      tadzik

[22:43] <tadzik> yep

[22:44] <jnthn> Over 10 days

[22:44] <FROGGS> jnthn: what is the expected? 0.0?

[22:44] <timotimo> 0.001 or so i think

[22:44] <sorear> erp. I was thinking of Niecza Irregular Release Day (-29)

[22:44] <jnthn> FROGGS: I think it is meant to always get the same numbe of decimals.

[22:44] <FROGGS> okay, will check and fix

[22:44] <sorear> 15:07 < jnthn> Stage %-11s: %7.3f

[22:44] <jnthn> Anyway, confirm that Rakudo builds again now

[22:44] <jnthn> FROGGS++

[22:45] <FROGGS> ohh, that is good to know

[22:45] <sorear>      fF      The double argument is rounded and converted to decimal notation in the style [-]ddd.ddd, where the number of digits after the decimal-point character is equal to the

[22:45] <sorear>              precision specification.  If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears.  If a decimal point

[22:45] <sorear>              appears, at least one digit appears before it.

[22:45] <sorear> in %7.3f, the precision is 3

[22:45] <jnthn> Well, S02-literals/listquote-whitespace.rakudo.jvm passes :)

[22:45] <sorear> so \d+\.\d**3

[22:45] <timotimo> tadzik: is there something i can try to do to make this compiler release already be compatible with panda?

[22:45] <FROGGS> yeah, have to pad with 0s

[22:45] <timotimo> because that would be ridiculously cool

[22:46] <jnthn> And S02-literals/quoting-unicode.t

[22:46] <sorear> padding on the left with spaces to a minimum of 7 chars

[22:46] <timotimo> "remember last month when our jvm port could do nothing? this time we'll give you a module installer to go with your spiffy new rakudo-jvm"

[22:46] <sorear> FROGGS: If you're padding on the right with zeros, you're doing it wrong

[22:46] <jnthn> ok 71 - Can't quote a string with a snowman and comet (U+2603 and U+2604)

[22:46] <jnthn> bwahahah!

[22:46] <timotimo> :D

[22:46] <jnthn> That still goes down as one of the best Rakudo bugs ever. :)

[22:46] <FROGGS> sorear: yeah, need to think about it

[22:47] <timotimo> jnthn: it would be amazing if someone actually stumbled upon that bug by accidentally having a string where they expected ... what exactly?

[22:47] <tadzik> timotimo: is it not compatible in some way?

[22:47] <sorear> FROGGS: %f should basically do round($num * 10**$prec); format as %0{$prec+1}d; insert a . $prec spaces from the right if $prec > 0

[22:47] <timotimo> i dunno, there's probably something missing i guess?

[22:48] <dalek> nqp: 706fb51 | (Tobias Leich)++ | t/jvm/06-sprintf.t:

[22:48] <dalek> nqp: added tests for nqp::sprintf

[22:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/706fb51d6f

[22:48] <tadzik> timotimo: you mean on the jvm part?

[22:48] <jnthn> FROGGS: On https://gist.github.com/coke/5879701, first 3 test files that failed in sprintf now pass

[22:48] <FROGGS> awesome

[22:48] <jnthn> FROGGS: S32-str/sprintf.rakudo.jvm is the first that fails

[22:48] <jnthn> 'i' is not valid in sprintf format sequence '%i'

[22:48] <sorear> sorear$ ls t/jvm

[22:48] <sorear> 01-continuations.t 06-sprintf.t

[22:48] <sorear> what happened to 2 thru 5?

[22:48] <FROGGS> jnthn: that patch is in the queue

[22:49] <tadzik> timotimo: so far it's lacking %*CUSTOM_LIB, that's what I encountered

[22:49] <jnthn> asbra! S32-temporal/Date.t passes! :)

[22:49] <FROGGS> sorear, it will be moved to t/hll soonish

[22:49] <timotimo> tadzik: i mean anywhere i might be able to chop off a LHF ;)

[22:49] <FROGGS> so I took the named it would have in t/hll

[22:49] <jnthn> S32-temporal/DateTime-Instant-Duration.rakudo.jvm fails 1, which may or may not be sprintf related

[22:50] *** woolfy joined
[22:50] <sorear> .oO( Instant Perl 6! )

[22:50] <timotimo> just add jnthn

[22:50] <tadzik> timotimo: well, um, running rakudo-jvm from outside the source directory would be a astart :)

[22:51] <jnthn> S32-temporal/DateTime.rakudo.jvm passes now, S32-temporal/calendar.t also, S32-temporal/local.t too

[22:51] *** woolfy1 left
[22:51] <jnthn> !!

[22:51] <timotimo> hmm, don't really know how to do that

[22:51] <jnthn> So it's only sprintf.t left from that section that aborts

[22:51] <dalek> nqp: 3ad22fa | (Tobias Leich)++ | src/HLL/sprintf.nqp:

[22:51] <dalek> nqp: add %i, a synonym for %d

[22:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3ad22fadcb

[22:51] *** raiph left
[22:51] <FROGGS> jnthn: but sprintf.t fails because of bigints ant rats

[22:52] <sorear> jnthn: how many passes are we up to?

[22:52] <jnthn> And in other news, S02-names-vars/fmt.rakudo.jvm passes.

[22:52] <jnthn> FROGGS: integration/advent2009-day02.t is the other one needing sprintf attention.

[22:52] <FROGGS> k

[22:52] <jnthn> FROGGS: So, sprintf.t and that one are the ones to look at :)

[22:52] <jnthn> sorear: lemme check

[22:53] * sorear wonders if jnthn uses the t/spec/test_summary --archive

[22:53] <jnthn> sorear: I dunno about extra passes, but looking at Coke's gist, we're now running 470 tests we previously aborted.

[22:53] <sorear> \o/

[22:53] <jnthn> sorear: No, I just ran the ones from [Coke]++'s gist manually, out of curiosity how we did on them.

[22:53] <tadzik> timotimo: I suppose it's a matter of perl6.class looking for other classes

[22:53] <tadzik> so there's some CLASSPATH adjusting in order

[22:54] <jnthn> This could mean that we're going to, for the first time, fall below 1000 failing tests.

[22:54] <tadzik> at least that's my guess

[22:54] <timotimo> isn't that ... yeah classpath

[22:54] <sorear> there is no perl6.class

[22:54] <timotimo> perl6.jar then?

[22:54] <jnthn> (less than 1000 behind Rakudo on Parrot)

[22:54] <tadzik> well, whatever lives in ./perl6

[22:55] <timotimo> at the moment i'm very close to falling asleep unintentionally

[22:55] <jnthn> timotimo: Suggest finding a horizontal surface, preferably a padded one :)

[22:55] <sorear> right now, nqp-runtime.jar, rakudo-runtime.jar, asm-4.1.jar, jline.jar, and asm-tree-4.1.jar need to be in the application classpath for nqp/rakudo to function

[22:56] * timotimo looks at how intellij idea starts itself

[22:56] <sorear> all other files are searched for using @*INC, not the classpath

[22:56] <sorear> I've been planning to improve the classpath handling in nqp

[22:56] <timotimo> that seems a bit overkill.

[22:57] <sorear> in particular we're currently referencing the application class loader in quite a few places where we ought to be referencing the nqp-runtime.jar class loader

[22:58] *** raiph joined
[22:59] <timotimo> i don't even know what a classloader does

[23:01] <sorear> so what are *you* trying to accomplish, timotimo?

[23:02] <sorear> my goals for the classpath improvements are 1. one-jar deployment 2. applet mode

[23:02] <jnthn> I think timotimo wants a make install so he can then try and get Panda working ;)

[23:02] <sorear> oh

[23:02] <sorear> 15:50 < tadzik> timotimo: well, um, running rakudo-jvm from outside the source directory would be a astart :)

[23:02] <jnthn> I think you already can do that...

[23:02] <sorear> I thought we already had that?

[23:02] <jnthn> :)

[23:02] <tadzik> we do? :)

[23:02] <jnthn> 'cus the .bat/.sh has absolute paths. :)

[23:02] <tadzik> > .rakudobrew/jvm/perl6

[23:03] <tadzik> Error: Could not find or load main class perl6

[23:03] <tadzik> or am I missing something

[23:03] <sorear> sorear$ cat perl6

[23:03] <sorear> #!/bin/sh

[23:03] <sorear> exec java -Xms100m -Xbootclasspath/a:.:/Users/sorear/dl/rakudo-jvm/../nqp-jvm/install/nqp-runtime.jar:/Users/sorear/dl/rakudo-jvm/../nqp-jvm/install/asm-4.1.jar:/Users/sorear/dl/rakudo-jvm/../nqp-jvm/install/asm-tree-4.1.jar:/Users/sorear/dl/rakudo-jvm/../nqp-jvm/install/jline-1.0.jar:rakudo-runtime.jar:perl6.jar -cp /Users/sorear/dl/rakudo-jvm/../nqp-jvm/install perl6 "$@"

[23:03] <sorear> note the relative paths to rakudo-runtime.jar and perl6.jar

[23:03] <jnthn> ah

[23:03] <tadzik> it uses relative paths here

[23:03] <tadzik> exec java -Xms100m -Xbootclasspath/a:.:nqp/install/nqp-runtime.jar:nqp/install/asm-4.1.jar:nqp/install/asm-tree-4.1.jar:nqp/install/jline-1.0.jar:rakudo-runtime.jar:perl6.jar -cp nqp/install perl6 "$@"

[23:04] <jnthn> That is probably fixable

[23:04] <sorear> that's probably because you passed a relative path to --with-nqp

[23:04] <jnthn> ah

[23:05] <tadzik> yes

[23:06] <timotimo> ooooooh

[23:06] <timotimo> is it that easy to fix?

[23:08] <jnthn> mebbe :)

[23:08] <jnthn> sorear: I'm thinking about sleeping soon; anything you need from me before I go?

[23:09] * jnthn noted that "make jnthn understand X" was a goal ;)

[23:11] <dalek> specs: 47003e0 | (Elizabeth Mattijsen)++ | S99-glossary.pod:

[23:11] <dalek> specs: Add wfm

[23:11] <dalek> specs: review: https://github.com/perl6/specs/commit/47003e08f3

[23:16] <sorear> jnthn: nothing quick

[23:16] <jnthn> ok :)

[23:17] <sorear> jnthn: if you feel like reading a half-written infodump before bed, I can gist what I have...

[23:18] <jnthn> sorear: Nah, it'll likely make more sense to me when it's done and I've slept ;)

[23:19] <sorear> gnight then :D

[23:20] *** pmurias left
[23:20] <jnthn> 'night o/

[23:22] <lizmat> night jnthn!

[23:29] *** colomon joined
[23:33] *** dmol left
[23:34] <colomon> o/

[23:34] <colomon> anything exciting happen today opn #perl6?

[23:36] <sorear> colomon: masak's sprintf stuff was merged, and I committed java->p6 callback support

[23:36] <colomon> \o/

[23:36] <sorear> we're passing "a few hundred" more tests with sprintf and other misc fixes

[23:36] <sorear> I have a little nqp demo that subclasses java.lang.Thread, implements run, and starts it

[23:37] <colomon> \o/

[23:37] <colomon> sounds like a very good day

[23:37] <sorear> I'm not done.

[23:37] <colomon> \o/

[23:38] <sorear> Although you did just miss jnthn.

[23:38] <colomon> I may be just starting.  :)

[23:38] <colomon> don't really have anything else on for the night other than drinking wine with my uncle.

[23:44] <labster> sounds exciting today, sad I missed it.  I had to drive to $dayjob and pick up a new computer.  It's the same model as lizmat's new laptop, so I'm very happy with it.

[23:44] <labster> And hopefully, it will run the spectests faster

[23:45] <lizmat> spectest run a ~7 minutes

[23:45] <labster> nice

[23:46] <colomon> which one, jvm or parrot?

[23:46] *** thou joined
[23:48] <sorear> yow

[23:49] <sorear> my 1-year-old work laptop takes nearly half an hour at TEST_JOBS=4 for jvm

[23:49] *** augustus joined
[23:49] <colomon> started now

[23:49] * sorear remembers dons in #haskell purloining a 16-core work machine in 2007 for work on Data Parallel Haskell

[23:51] <lizmat> colomon: I only do parakudo for now

[23:51] <augustus> hello, I have some questions creating and using sub-languages, can anyone tell me if it still requires hacking the rakudo source as in this article: http://strangelyconsistent.org/blog/extending-the-syntax-of-perl6

[23:52] <FROGGS> augustus: yes, I think so

[23:52] <FROGGS> augustus: since you can't access %*LANG from perl6 land right now, if you could, you could mixin rules

[23:53] <sorear> r: say %?LANG.WHAT

[23:53] <camelia> rakudo 516d49: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable '%?LANG' is not declared‚ê§at /tmp/3aW7o0ysM7:1‚ê§------> [32msay %?LANG.WHAT[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        method arguments‚ê§¬ª

[23:53] <augustus> do you know if any work has been done in this area for common languages like SQL, XML, HTML etc? or is this work that needs to be done from scratch?

[23:53] <sorear> r: say nqp::getlex('%?LANG').WHAT

[23:53] <camelia> rakudo 516d49: OUTPUT¬´Can only use get_what on a SixModelObject‚ê§  in block  at /tmp/Qjb3ajFCps:1‚ê§‚ê§¬ª

[23:53] <sorear> r: BEGIN say %*LANG

[23:53] <camelia> rakudo 516d49: OUTPUT¬´===SORRY!===‚ê§Nominal type check failed for parameter '$got'; expected Any but got Perl6::RegexGrammar instead‚ê§¬ª

[23:54] <FROGGS> augustus: I am working on a Perl5 slang, but I think there is no SQL, XML or (X)HTML slang out there atm

[23:55] <FROGGS> a slang only makes sense if you perform action on the token you get IMO, so why make a HTML slang at all?

[23:55] <FROGGS> actions*

[23:55] <augustus> FROGGS: once I translate the standard grammars out there into Perl6 notation, how hard is it to make a "slang"

[23:55] *** lizmat left
[23:56] *** lizmat joined
[23:56] <FROGGS> augustus: not very hard, since my Perl 5 slang already is a module (just with minor rakudo-hacks)

[23:56] <sorear> augustus: a slang is only useful if you want to embed XML directly in your perl 6 code, without quotes

[23:56] <sorear> augustus: this seems marginally useful at best

[23:56] <augustus> FROGGS: yes I understand this.  I am interested in making a Perl6 version of JSP type stuff

[23:57] <FROGGS> ahh, and I should mention that the Perl 5 slang is actually a nqp-module, not Perl 6

[23:57] <augustus> I'm not sure how much of a difference there is with NQP, I haven't worked with it at all

[23:58] <FROGGS> well, when you think of the rakudo compiler, this sits on top of nqp

[23:59] <FROGGS> so if you have an nqp module, you dont have access to the high-level bits

[23:59] <augustus> meaning that "slangs" have only NQP not full perl6?

