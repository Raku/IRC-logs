[00:00] <lizmat> more like sleepcrawling  :-)

[00:00] <timotimo> :)

[00:01] *** telex left
[00:02] *** telex joined
[00:02] *** ajr_ left
[00:03] *** rurban1 left
[00:04] *** dmol left
[00:04] <timotimo> oh damn, i didn't map it properly :(

[00:07] *** jeffreykegler joined
[00:08] <timotimo> ah, i found where i had missed the mapping, in nqp itself!

[00:10] *** benabik joined
[00:10] *** benabik left
[00:17] *** lizmat_ joined
[00:17] *** lizmat left
[00:18] *** mtj_ joined
[00:24] *** jeffreykegler left
[00:26] *** adu joined
[00:40] *** Mouq joined
[00:42] *** jnap left
[00:46] *** dayangkun_ joined
[00:46] *** dayangkun_ left
[00:47] *** lowpro30_ joined
[00:50] *** lowpro30 left
[00:50] *** dayangkun left
[00:51] *** prevost left
[01:00] *** lowpro30_ left
[01:10] *** tgt left
[01:13] *** jnap joined
[01:14] *** raiph left
[01:15] *** Ben_Goldberg joined
[01:16] *** BenGoldberg left
[01:18] *** jnap left
[01:20] *** Ben_Goldberg left
[01:21] *** BenGoldberg joined
[01:21] *** kurahaupo_ left
[01:30] *** raiph joined
[01:33] *** adu left
[01:40] *** BenGoldberg left
[01:43] *** jnap joined
[01:44] *** dalek left
[01:44] *** dalek joined
[01:44] *** ChanServ sets mode: +v dalek

[01:45] *** BenGoldberg joined
[01:47] *** adu joined
[01:55] *** raiph left
[02:15] *** btyler left
[02:34] <colomon> building latest rakudo gives me a broken executable.  :(

[02:35] <colomon> Missing or wrong version of dependency 'gen/parrot/stage2/QRegex.nqp'

[02:35] <colomon> current instr.: '' pc 952 (src/gen/perl6.pir:336) (gen/parrot/main.nqp:58)

[02:47] *** thou left
[03:23] *** jnap left
[03:31] *** Mouq left
[03:31] <colomon> complete rebuild fixed it.

[03:33] *** cem_ joined
[03:36] *** cem_ left
[03:50] *** berekuk left
[03:51] *** dwoldrich joined
[03:51] *** adu left
[03:53] *** btyler joined
[04:02] *** rurban1 joined
[04:06] *** adu joined
[04:09] *** ssutch left
[04:13] *** jnap joined
[04:14] *** dwoldrich left
[04:17] *** rurban1 left
[04:18] *** jnap left
[04:27] *** benabik joined
[04:28] *** Mouq joined
[04:35] *** btyler left
[05:00] *** preflex_ joined
[05:00] *** ChanServ sets mode: +v preflex_

[05:01] *** xenoterracide left
[05:01] *** preflex left
[05:01] *** preflex_ is now known as preflex

[05:06] *** dwoldrich joined
[05:08] *** dayangkun joined
[05:19] *** fridim__ left
[05:20] *** PacoAir left
[05:25] *** [Sno] left
[05:29] <segomos> where is moarvm these days?

[05:33] *** kurahaupo joined
[05:34] *** kurahaupo left
[05:50] *** adu left
[05:55] *** SamuraiJack__ joined
[05:57] *** xinming left
[05:58] *** xinming joined
[06:07] *** sqirrel joined
[06:08] *** BenGoldberg left
[06:10] <FROGGS> segomos: pretty good on its way actually

[06:11] <FROGGS> segomos: when building rakudo it passes stage parse but explodes in the optimizer due to NYI ops

[06:15] *** sftp joined
[06:15] *** jnap joined
[06:17] *** benabik left
[06:19] *** jnap left
[06:22] *** SmokeMachine joined
[06:25] *** sqirrel left
[06:40] *** PacoAir joined
[06:41] *** [Sno] joined
[06:46] *** Mouq left
[07:02] *** xinming_ joined
[07:03] *** kaleem joined
[07:03] *** xinming left
[07:14] *** darutoko joined
[07:21] *** dmol joined
[07:22] *** raiph joined
[07:24] *** benabik joined
[07:24] *** FROGGS left
[07:25] *** bonsaikitten joined
[07:46] *** REPLeffect joined
[07:50] * jnthn yawns

[07:55] *** FROGGS joined
[07:55] <FROGGS> jnthn: what do you yawn for? :o)

[07:55] <FROGGS> good morning all

[07:56] <moritz> \o

[07:56] <jnthn> FROGGS: 'cus it's morning

[07:56] <FROGGS> ahh, I forgot :P

[07:56] <FROGGS> hi moritz 

[07:57] <jnthn> oh, THAT's why the 30 min walk to teaching felt chilly...

[07:57] <jnthn> it's -6

[07:57] <FROGGS> nice

[07:58] <jnthn> yes, though probably hat and gloves woulda been wise :)

[07:58] <FROGGS> -3 here

[07:58] <moritz> FROGGS: I've given you a rakudo.org account

[07:58] <jnthn> ok, gotta teach; bbl

[07:58] <FROGGS> ohh

[07:58] <FROGGS> jnthn: have fun

[07:58] <FROGGS> moritz: so I'd be able to fix the guide?

[07:58] <moritz> anybody else need one? (like, for publishing release announcements or fixing docs on rakudo.org)?

[07:58] <moritz> FROGGS: I dearly hope so :-)

[08:01] *** hummeleB1 joined
[08:14] *** zakharyas joined
[08:14] *** nnunley left
[08:15] *** yves_ joined
[08:17] *** jnap joined
[08:22] *** jnap left
[08:39] *** chturne left
[08:46] *** raiph left
[08:47] *** ssutch joined
[08:47] *** ssutch left
[08:52] *** kurahaupo_ joined
[08:59] <timotimo> o/

[09:00] <masak> good antenoon, #perl6

[09:01] <FROGGS[mobile]> morning

[09:02] <masak> good mobile morning to you, FROGGS.

[09:02] <timotimo> maybe i'll have a closer look at newexception on moarvm today

[09:02] <timotimo> skipping the optimizer gives clearer instructions on what's next.

[09:02] <masak> nice.

[09:02] <timotimo> though newexception being needed could hint at "something in the logic is going wrong, such that it wants to throw an exception"

[09:02] <masak> if I have time today, I will do either t4 reviewing, or start looking at the event framework needed to get Nomic off the ground.

[09:02] <timotimo> which could be benign, like a missing op causing not an ad-hoc exception, but a "real" exception this time

[09:03] <timotimo> cool :)

[09:03] <timotimo> and i'll go pick up my in-ear headphones

[09:03] <timotimo> i'm fed up with those hand-me-down ipod earplugs that keep falling out of my left ear every minute >_<

[09:04] *** dmol left
[09:18] *** denis_boyun joined
[09:20] <jnthn> timotimo: I expect somewhere uses nqp::newexception

[09:23] *** xinming_ left
[09:23] *** xinming joined
[09:27] *** denis_boyun left
[09:29] *** MikeFair left
[09:36] *** MikeFair_ joined
[09:37] *** kurahaupo_ left
[09:37] *** benabik left
[09:38] *** denis_boyun joined
[09:38] *** benabik joined
[09:39] <timotimo> jnthn: i expect that, too. the question is, is it an exception that points to a bigger problem than just ops missing, like some op misbehaving or even worse, or if it's totally benign ;)

[09:39] <timotimo> i guess i'll only find out once i implement it.

[09:41] *** dakkar joined
[09:41] *** kurahaupo joined
[09:43] *** benabik left
[09:46] *** denis_boyun left
[09:47] <jnthn> timotimo: What was the exact error?

[09:49] <timotimo> Error while compiling op newexception: MoarVM op 'newexception' is unknown as a core or extension op

[09:49] <timotimo>    at gen/moar/stage2/QAST.nqp:4105  (/home/timo/build/rakudo/install/languages/nqp/lib/QAST.moarvm:frame_name_1131:21)

[09:49] <timotimo>  from gen/moar/stage2/QAST.nqp:4103  (/home/timo/build/rakudo/install/languages/nqp/lib/QAST.moarvm:as_mast:70)

[09:50] <jnthn> Yeah, don't think it's trying to throw, just compile an nqp::newexception

[09:50] <timotimo> ah, sounds good

[09:50] <timotimo> now i'll just have to figure out how to work the hllconfig of moar

[09:50] <timotimo> is there another op that demonstrates?

[09:52] *** kurahaupo left
[09:53] *** MikeFair_ left
[09:53] <jnthn> hllboxtype maybe

[09:53] <jnthn> uh...or something like that

[09:53] <jnthn> of hllize

[09:55] <timotimo> thanks :)

[09:55] <timotimo> would the op go in core/exception.c?

[09:59] *** eiro left
[10:01] *** kurahaupo joined
[10:04] *** dmol joined
[10:07] *** pecastro left
[10:07] *** dmol left
[10:08] *** pecastro joined
[10:08] *** dmol joined
[10:09] *** denis_boyun joined
[10:13] <arnsholt> Do we have any tests, either in NQP or Rakudo, that exercise sockets?

[10:13] *** dmol left
[10:14] <timotimo> there's a test in rakudo, aye

[10:14] <FROGGS> arnsholt: S32-IO_Socket-INET.t?

[10:14] <timotimo> it is usually the test that takes the longest :|

[10:14] *** daxim left
[10:15] <FROGGS> preflex: tell ajr_ it works on my box: https://gist.github.com/FROGGS/7582ad250eaf37333855#file-install-txt-L349

[10:15] <preflex>  Consider it noted.

[10:15] *** dmol joined
[10:16] <FROGGS> jnthn: btw, you can merge cursor-mem-opts into master

[10:18] *** jnap joined
[10:18] *** dmol left
[10:19] *** dmol joined
[10:19] *** kurahaupo left
[10:20] *** kurahaupo joined
[10:22] <timotimo> i don't really understand how the concepts i see in the jvm implementation of newexception map to moarvm

[10:22] <timotimo> but if it calls newexception, it probably also directly calls setpayload and setmessage and friends

[10:23] *** jnap left
[10:24] <timotimo> huh, the line in question just calls "die"

[10:24] *** dmol left
[10:24] <timotimo> shouldn't that work already?

[10:24] <timotimo> oh, haha

[10:24] <timotimo> that part does work

[10:24] *** dmol joined
[10:25] <FROGGS> maybe it happens when creating the X::AdHoc?

[10:26] <timotimo> no, nqp::die works. it's just dieing with the message "unable to compile op 'newexception'"

[10:26] *** kurahaupo left
[10:27] *** kurahaupo joined
[10:28] *** daxim joined
[10:29] *** odoacre joined
[10:29] *** denis_boyun left
[10:35] *** dmol left
[10:36] *** kurahaupo left
[10:36] *** kurahaupo joined
[10:37] <hoelzro> morning #perl6

[10:37] *** dmol joined
[10:37] <hoelzro> I'm looking over http://jnthn.net/papers/2013-npw-conc.pdf

[10:37] <hoelzro> and trying to understand slide 25

[10:37] <hoelzro> (nth_or_timeout 4)

[10:37] <timotimo> i can help with that

[10:37] <hoelzro> I understand the bit about checking the timeout promise in the for loop

[10:38] <hoelzro> but after the check, I see $result = @source[$n]

[10:38] <hoelzro> and that line confuses me

[10:38] <timotimo> ah, easy enough

[10:38] <hoelzro> wouldn't that just fetch @source[$n] $n times?

[10:38] <timotimo> @source is supposed to be a lazy evaluated list that does some computation each time you get a new item

[10:38] <hoelzro> is it supposed to be @source[$_]?

[10:38] <timotimo> oh, hah

[10:38] *** kurahaupo left
[10:38] <timotimo> yeah, you're right

[10:38] *** kurahaupo_ joined
[10:39] <hoelzro> ok, I thought I was missing something!

[10:45] *** denisboyun joined
[10:46] *** kurahaupo_ left
[10:47] *** kurahaupo joined
[10:48] *** dmol left
[10:50] *** dmol joined
[10:51] *** tgt joined
[10:51] *** kurahaupo left
[10:58] *** denisboyun left
[10:58] *** dmol left
[11:00] *** dmol joined
[11:01] <jnthn> FROGGS: You can merge cursor-mem-opts into master too :P

[11:01] <FROGGS> jnthn: yes, now I can :o)

[11:02] <jnthn> ;)

[11:02] <dalek> nqp: 3b28064 | jonathan++ | src/QRegex/ (2 files):

[11:02] <dalek> nqp: Be more eager to throw out things we'll not need.

[11:02] <dalek> nqp: 

[11:02] <dalek> nqp: This saves memory and eases the GC's role, especially as we keep hold

[11:02] <dalek> nqp: of a lot less call frames.

[11:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3b280649c2

[11:02] <dalek> nqp: ef756d4 | (Tobias Leich)++ | src/QRegex/ (2 files):

[11:02] <dalek> nqp: Merge branch 'cursor-mem-opts' of github.com:perl6/nqp

[11:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ef756d4904

[11:04] <FROGGS>  - [deleted]         cursor-mem-opts

[11:04] *** dmol left
[11:07] *** denisboyun joined
[11:07] *** dmol joined
[11:16] *** eiro joined
[11:40] <masak> perl6: label1: say "OH HAI"; label1: say "OH NOES"

[11:40] <camelia> rakudo-parrot 60c8c1, rakudo-jvm 60c8c1: OUTPUT«OH HAI␤OH NOES␤»

[11:40] <camelia> ..niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Illegal redeclaration of symbol 'label1' (see line 1) at /tmp/jjMkfXZYjO line 1:␤------> label1: say "OH HAI"; label1: ⏏say "OH NOES"␤␤Unhandled exception: Check failed␤␤  at /home/p6ev…»

[11:41] * masak submits rakudobug

[11:41] <FROGGS> masak: I've fixed that in nqp in my branch fwiw

[11:41] <masak> what a wonderful coincidence.

[11:42] <masak> it's been too long since I submitted a good rakudobug.

[11:42] <masak> you guys need to put more bugs in the code so I can submit them! :P

[11:42] <FROGGS> :(

[11:42] <FROGGS> there are too many open bugs

[11:42] <masak> s/guys/guys, gals, and bots/

[11:42] *** denisboyun left
[11:42] <FROGGS> I'll introduce some when we have less then a hundred :o)

[11:42] *** denis_boyun joined
[11:43] <masak> deal.

[11:44] <masak> I wonder when we last had less than a hundred...

[11:44] <masak> sometime in 2008, I bet.

[11:49] *** rindolf joined
[11:50] <moritz> in the days before the masak

[11:52] *** carlin joined
[11:54] <carlin> hi all, I've been out of the perl6 loop for a while... is rakudo on parrot still the way to go?

[11:54] <moritz> carlin: depends on what you want to do :-)

[11:55] <moritz> carlin: rakudo-parrot still has the best module support, but rakudo-jvm now does proper threads and async stuff

[11:56] <moritz> the patch in RT 120630 has this hunk

[11:56] <moritz> -p-runner-default-install: p-all

[11:56] <moritz> +p-runner-default-install: p-all | $(DESTDIR)$(PARROT_BIN_DIR)

[11:56] <moritz> what does the | mean, and do non-gnu makes understand it?

[11:57] <carlin> I guess I'll go with parrot for now since it's what I was familar with

[11:58] <moritz> carlin: the good news is, you can now build rakudo-parrot and rakudo-jvm from the same source dir, and install them alongside

[11:59] <moritz> perl Configure.pl --backends=parrot,jvm --gen-parrot

[11:59] <timotimo> that's for nqp, though, right? or do you not have to --gen-nqp for that?

[12:01] <moritz> that's for rakudo

[12:01] <moritz> and gen-parrot implies gen-nqp

[12:01] <timotimo> that's good

[12:07] <arnsholt> moritz: | DEPS just makes sure that the DEPS exist, it doesn't check timestamps

[12:08] <arnsholt> Useful for creating directories and such

[12:08] <arnsholt> Probably a GNU extension

[12:09] <timotimo> does gdb offer something like time travel? regular checkpoints? so we could see what the last ops were that were called?

[12:09] <moritz> I wonder if we shouldn't just always create the directory in that target, and be done

[12:11] <arnsholt> timotimo: The GDB term for it is reverse debugging

[12:11] <arnsholt> It's supported, but logging all the required information takes up quite a bit of memory, so I doubt you'll be able to use it on a setting compilation

[12:12] <arnsholt> I had trouble using it on anything with Rakudo/Parrot

[12:12] <timotimo> mhm

[12:12] <timotimo> can it selectively be activated late-ish?

[12:13] <arnsholt> Not sure

[12:13] <arnsholt> But you can walk the stack in GDB

[12:13] <arnsholt> That can often help

[12:13] <timotimo> i know about that part

[12:13] <arnsholt> Sometimes knowing where the NULL pointer originates is an important clue

[12:29] *** geekosaur joined
[12:32] *** dylanwh joined
[12:35] *** jercos joined
[12:43] <timotimo> the advent calendar is going to start real soon

[12:43] <moritz> \o/

[12:44] <moritz> I could do the "State of Perl 6" post, or claim Dec 02 with a to-be-determined topic

[12:44] <moritz> what do you folks prefer?

[12:45] <tadzik> I think you're the right person to do the State of Perl 6 :)

[12:46] <moritz> thanks :-)

[12:46] *** atroxaper joined
[12:46] <dalek> mu: fe6fa2f | moritz++ | misc/perl6advent-2013/schedule:

[12:46] <dalek> mu: [advent] claim Dec 01, SoP6

[12:46] <dalek> mu: review: https://github.com/perl6/mu/commit/fe6fa2f85b

[12:48] * timotimo already wrote 0 bytes on my experiences of contributing during the first year

[12:51] <moritz> timotimo: then I recommend exponential progression :-)

[12:51] <diakopter> timotimo: better than 10000000000000000000000000000000000 bytes, I guess

[12:51] <diakopter> or negative byts.

[12:51] <timotimo> :)

[12:52] <diakopter> timotimo++ # moar progression

[12:52] <timotimo> (by a tiny bit)

[12:52] <timotimo> i don't see what i have to do to make newexception and friends work

[13:10] *** cognominal__ left
[13:10] *** cognominal__ joined
[13:12] *** jnap joined
[13:22] *** kaleem left
[13:23] <dalek> specs: 0f9df8a | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[13:23] <dalek> specs: Change the listless map into a Whatever map

[13:23] <dalek> specs: review: https://github.com/perl6/specs/commit/0f9df8a0f2

[13:27] *** ajr joined
[13:28] *** ajr is now known as Guest16419

[13:28] *** Guest16419 is now known as ajr_

[13:32] <dalek> rakudo/nom: b4cd1da | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[13:32] <dalek> rakudo/nom: Transmogrify listless map into Whatever map

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b4cd1dab0d

[13:34] <moritz> lizmat++ # epic commit messages

[13:35] *** lizmat_ is now known as lizmat

[13:35] *** jnap left
[13:39] *** denis_boyun left
[13:41] *** cognominal joined
[13:44] *** cognominal__ left
[13:46] *** araujo left
[13:47] *** araujo joined
[13:49] *** kaare_ joined
[13:59] <dalek> rakudo/nom: e5fd34e | (Elizabeth Mattijsen)++ | src/vm/jvm/core/Channel.pm:

[13:59] <dalek> rakudo/nom: Channel.list now uses Whatever map

[13:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5fd34e591

[14:05] *** berekuk joined
[14:08] <masak> +1 # moritz++ doing "State of Perl 6"

[14:23] <colomon> +1 indeed

[14:29] <arnsholt> Does anyone happen to know about how frequently donaldh stops by here?

[14:33] <lizmat> preflex: seen donaldh

[14:33] <preflex>  donaldh was last seen on #perl6 28 days, 2 hours, 23 minutes and 17 seconds ago, saying: does anyone know a FAX number for TPF ?

[14:34] <atroxaper> What is the magic        eval slurp($file.path) ~ "\n\$=pod";    ?   What is $=pod mean and how does it work?

[14:35] <arnsholt> Not very often then. In that case I'll try to decipher his readline code

[14:39] <masak> hehe, Crockford in http://www.youtube.com/watch?v=QgwSUtYSUqA demos "loop { ... }", and says it's a pity JavaScript doesn't have it. :)

[14:39] <masak> (he doesn't mention Perl 6 by name, but I haven't seen "loop { ... }" in any other language, I think)

[14:40] <moritz> atroxaper: slurp() just reads the whole file

[14:40] <moritz> atroxaper: and ~ "\n\$=pod" appends a newline, and then the string $=pod

[14:40] <moritz> atroxaper: and $=pod contains a data structure with the whole pod of this compilation unit

[14:42] <Woodi> hallo :)

[14:42] <masak> Woodi! \o/

[14:43] <lizmat> masak: FWIW, "loop" was in TenCORE, afair

[14:44] <atroxaper> moritz: thanks. I didn't know that $=pod can help eval to parse pod file. Are there another methods for making pod structure from file or is it good one?

[14:45] <Woodi> I wonder do Perl6 want to include "suspend to disk" feature.. something like Smalltalk: https://en.wikipedia.org/wiki/Smalltalk#Image-based_persistence

[14:46] <moritz> atroxaper: I didn't find a better way, which is why I wrote the line you quoted above

[14:46] <moritz> atroxaper: I don't find it very nice though

[14:47] *** bluescreen10 joined
[14:48] <atroxaper> moritz: ok. Just to know.

[14:48] <Woodi> and btw. can we have something like: class Object is frankenstained with Thread { ... } # :)

[14:50] *** jnap joined
[14:50] *** denis_boyun joined
[14:50] <FROGGS> Woodi: everything you put in a BEGIN block is "suspended to disk"

[14:51] <Woodi> I assume we can have thousands and thousands of VM threads like in Erlang or Go...

[14:51] <Woodi> FROGGS: precompiled ? right :)

[14:52] <FROGGS> Woodi: only when you compile it, correct

[14:54] <Woodi> but seems nice to have feature like: kill -SIGSUSPENS perl6prog

[14:55] *** denis_boyun left
[14:55] *** fridim__ joined
[14:57] *** rurban1 joined
[14:59] *** dwoldrich left
[14:59] <Woodi> "=date col1 col2 col3" ~~ m/^ '=date' [\s(\S+)]+/; say @$/.join(':');

[14:59] <Woodi> r: "=date col1 col2 col3" ~~ m/^ '=date' [\s(\S+)]+/; say @$/.join(':');

[14:59] <camelia> rakudo-parrot e5fd34, rakudo-jvm e5fd34: OUTPUT«col1:col2:col3␤»

[15:01] <Woodi> it works this way but can someone help me with grammar for that line format ? especially how to say @$result from grammar...

[15:02] <Woodi> I have something like this: http://pastebin.com/Dw6R7NuB

[15:03] <moritz> rule colname { $<colname>=(\S+) }

[15:03] <moritz> you can just write   token colname { \S+ }

[15:03] <moritz> and the mere fact that you call it as <colname> generates a named capture alreay

[15:03] *** benabik joined
[15:04] <FROGGS> rp: "=date col1 col2 col3" ~~ m:s/^ '=date' (\S+)+ % \s /; say @$/.join(':');

[15:04] <camelia> rakudo-parrot e5fd34: OUTPUT«col1:col2:col3␤»

[15:04] <Woodi> ok, I will try this

[15:06] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> $ }; rule cs { <cn>+ % \s }; rule colname { \S+ } }; say Header.parse("=date col1 col2 col3")

[15:06] <camelia> rakudo-parrot e5fd34: OUTPUT«#<failed match>␤»

[15:07] <FROGGS> :(

[15:07] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> $ }; rule cs { <cn>+ % \s }; rule cn { \S+ } }; say Header.parse("=date col1 col2 col3")

[15:07] <camelia> rakudo-parrot e5fd34: OUTPUT«#<failed match>␤»

[15:08] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> $ }; token cs { <cn>+ % \s }; rule cn { \S+ } }; say Header.parse("=date col1 col2 col3")

[15:08] <camelia> rakudo-parrot e5fd34: OUTPUT«#<failed match>␤»

[15:09] <FROGGS> arrgg!

[15:09] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> $ }; rule cs { <cn>+ % \s }; rule cn { \S+ } }; say Header.parse("=data col1 col2 col3")

[15:09] <camelia> rakudo-parrot e5fd34: OUTPUT«#<failed match>␤»

[15:10] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> }; rule cs { <cn>+ % \s }; rule cn { \S+ } }; say Header.parse("=data col1 col2 col3")

[15:10] <camelia> rakudo-parrot e5fd34: OUTPUT«｢=data col1 ｣␤ cs => ｢col1 ｣␤  cn => ｢col1 ｣␤␤»

[15:10] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> }; token cs { <cn>+ % \s }; token cn { \S+ } }; say Header.parse("=data col1 col2 col3")

[15:10] <camelia> rakudo-parrot e5fd34: OUTPUT«｢=data col1 col2 col3｣␤ cs => ｢col1 col2 col3｣␤  cn => ｢col1｣␤  cn => ｢col2｣␤  cn => ｢col3｣␤␤»

[15:11] <FROGGS> rp: grammar Header { rule TOP { '=data ' <cs> $ }; token cs { <cn>+ % \s }; token cn { \S+ } }; say Header.parse("=data col1 col2 col3")

[15:11] <camelia> rakudo-parrot e5fd34: OUTPUT«｢=data col1 col2 col3｣␤ cs => ｢col1 col2 col3｣␤  cn => ｢col1｣␤  cn => ｢col2｣␤  cn => ｢col3｣␤␤»

[15:11] <FROGGS> good, so I am not stupid :o)

[15:11] <FROGGS> sorry for the spam

[15:11] <Woodi> about frankenstaining objects :) : everyone is looking for composability in general case, for N threads, etc... I think we should start with 2 or 3 threads sharing memory/work. Boss is delegating work and shares documents with few assistants... Then we should make TEAM of objects/threads sharing data and threads outside of team should lock/be messaged... 

[15:12] <Woodi> thank you FROGGS, now I have my problem resolved :)

[15:13] <FROGGS> Woodi: yw, now you have to pick an RT ticket instead :P

[15:13] *** berekuk left
[15:14] <FROGGS> btw, the problem was the the *rule* cn  eats up whitespace

[15:14] <FROGGS> where a token does not

[15:15] <Woodi> becouse our programs emulate humanity :) human read book, human slurp coffe, human smokes... but computers (with many cores) are not humans, they are more like ZOO animals: they are all spawned at program start...

[15:15] *** kaleem joined
[15:15] <Woodi> EOSCIFI :), thinking on, dreaming off :)

[15:17] <Woodi> what % in  <cn>+ % \s means ?

[15:18] *** thou joined
[15:18] <FROGGS> look a the symbol %

[15:19] <FROGGS> it is a thing, divided by another thing

[15:19] <FROGGS> so it is: <cn> split by \s

[15:19] <Woodi> Perl6 grammar have split build in ? :)

[15:20] <FROGGS> and the + is just a quantifier like in other positions too

[15:20] *** atroxaper left
[15:20] <FROGGS> no, it is just about token repetition with a thing in between

[15:20] *** btyler joined
[15:21] *** atroxaper joined
[15:21] <FROGGS> rp: say "ababa" ~~ / a+ % b /

[15:21] <camelia> rakudo-parrot e5fd34: OUTPUT«｢ababa｣␤␤»

[15:21] <FROGGS> rp: say "ababa" ~~ / $<thing>=a+ % $<divider>=b /

[15:21] <camelia> rakudo-parrot e5fd34: OUTPUT«｢ababa｣␤ thing => ｢ababa｣␤ divider => ｢b｣␤ divider => ｢b｣␤␤»

[15:22] <FROGGS> rp: say "ababa" ~~ / [$<thing>=a]+ % $<divider>=b /

[15:22] <camelia> rakudo-parrot e5fd34: OUTPUT«｢ababa｣␤ thing => ｢a｣␤ divider => ｢b｣␤ thing => ｢a｣␤ divider => ｢b｣␤ thing => ｢a｣␤␤»

[15:26] *** kaleem left
[15:31] *** ajr_ left
[15:31] *** ajr joined
[15:31] *** ajr is now known as Guest1324

[15:31] *** Guest1324 is now known as ajr_

[15:33] *** nnunley joined
[15:33] *** rurban1 left
[15:37] *** atroxaper left
[15:41] *** xenoterracide joined
[15:42] <Woodi> hmm, is something like $r.perl.prettyprint available maybe ? :)

[15:49] *** FOAD joined
[15:53] *** rurban1 joined
[15:58] *** Psyche^_ joined
[16:00] <Woodi> rp: grammar Header { rule TOP { '=date ' <cn>+ % \s+ $ }; token cn { \S+ } }; my $r = Header.parse( '=date col1 col2 col3' ); say @(%$r{'cn'}).join(':');

[16:00] <camelia> rakudo-parrot e5fd34: OUTPUT«col1:col2:col3␤»

[16:00] <Woodi> this work but 'say @(%$r{'cn'}).join(':');' part is not nice...

[16:01] <FROGGS> rp: grammar Header { rule TOP { '=date ' <cn>+ % \s+ $ }; token cn { \S+ } }; my $r = Header.parse( '=date col1 col2 col3' ); say $r<cn>.values.join(':');

[16:01] <camelia> rakudo-parrot e5fd34: OUTPUT«col1:col2:col3␤»

[16:02] *** telex left
[16:02] <FROGGS> rp: grammar Header { rule TOP { '=date ' <cn>+ % \s+ $ }; token cn { \S+ } }; my $r = Header.parse( '=date col1 col2 col3' ); say @($r<cn>).join(':');

[16:02] <camelia> rakudo-parrot e5fd34: OUTPUT«col1:col2:col3␤»

[16:02] *** Psyche^ left
[16:02] <FROGGS> rp: grammar Header { rule TOP { '=date ' <cn>+ % \s+ $ }; token cn { \S+ } }; my $r = Header.parse( '=date col1 col2 col3' ); say join(':', @$r<cn>);

[16:02] <camelia> rakudo-parrot e5fd34: OUTPUT«postcircumfix:<{ }> not defined for type List␤  in method Str at gen/parrot/CORE.setting:12003␤  in method Str at gen/parrot/CORE.setting:996␤  in method join at gen/parrot/CORE.setting:1593␤  in sub join at gen/parrot/CORE.setting:1781␤  in su…»

[16:02] <FROGGS> err, ok

[16:04] *** xenoterracide left
[16:04] *** telex joined
[16:04] *** atroxaper joined
[16:09] *** dmol left
[16:12] *** benabik left
[16:12] <japhb_> Another variant use case for blobs: Blob.subbuf() should be a constant-time, memory sharing operation.

[16:12] *** thou left
[16:13] *** btyler left
[16:13] *** [Sno] left
[16:16] *** benabik joined
[16:22] *** FROGGS left
[16:28] *** SamuraiJack joined
[16:31] *** rindolf left
[16:31] *** atroxaper left
[16:32] *** SamuraiJack__ left
[16:33] *** SamuraiJack_ joined
[16:36] *** thou joined
[16:36] *** SamuraiJack left
[16:39] *** Gwyxx joined
[16:39] *** xenoterracide joined
[16:39] *** Gwyxx is now known as SL-RHanson

[16:43] *** FOAD left
[16:44] *** FOAD joined
[16:46] *** zakharyas left
[16:51] *** asyoulikeit joined
[16:52] *** Celelaptop left
[17:00] *** xenoterracide left
[17:00] *** asyoulikeit left
[17:02] *** Celelaptop joined
[17:06] *** jeffreykegler joined
[17:06] *** raiph joined
[17:06] *** rindolf joined
[17:07] *** dmol joined
[17:07] *** fridim__ left
[17:09] *** carlin left
[17:14] *** ssutch joined
[17:21] *** kaleem joined
[17:30] *** arnsholt left
[17:39] *** spider-mario joined
[17:42] *** kaleem left
[17:50] <dalek> p6-pb: 49074a5 | (Geoffrey Broadwell)++ | lib/Metamodel/Perlable.pm:

[17:50] <dalek> p6-pb: Only use .container_descriptor if method exists

[17:50] <dalek> p6-pb: review: https://github.com/samuraisam/p6-pb/commit/49074a5ee0

[17:50] <dalek> p6-pb: 5c7c5dd | (Geoffrey Broadwell)++ | lib/Metamodel/Perlable.pm:

[17:50] <dalek> p6-pb: Don't try to .perl a non-PerlableAttribute

[17:50] *** dalek left
[17:50] *** dalek joined
[17:50] *** ChanServ sets mode: +v dalek

[17:51] <TimToady> lizmat: I still don't see how "map {}, *" is better than just "{} xx *"

[17:52] <jnthn> TimToady: You can use "last" with map when you're done; how do you say you're done with {} xx * ?

[17:52] <TimToady> point

[17:52] <jnthn> TimToady: Also, does {} xx * not actually produced a bunc of closures? :)

[17:53] <jnthn> r: say ({ 42 } xx *)[^5].perl

[17:53] <camelia> rakudo-parrot e5fd34, rakudo-jvm e5fd34: OUTPUT«(Block.new(), Block.new(), Block.new(), Block.new(), Block.new())␤»

[17:53] <jnthn> Yeah...

[17:53] <jnthn> Though I dunno if that's spec or accident ;)

[17:53] <jnthn> I just know it's what it does :)

[17:53] <TimToady> seems rightish

[17:55] <TimToady> but then, of course, simply loop {} is specced to work like that in lazy context

[17:57] *** Entonian joined
[17:58] <jnthn> Um...it is?

[17:59] <jnthn> I knew, though never felt keen to implement, the thing where the loop keeps all its results...

[17:59] <jnthn> ...didn't really think that would need laziness to get involved too

[17:59] <jnthn> Feels like we're asking for the same trouble as for. Or maybe you need the parens around it like for?

[18:00] <TimToady> S04:371 has been in there from time immemorial

[18:00] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_371

[18:01] <TimToady> use at statment level just makes it eager, unless it's in sink context, in which case you can not produce any values

[18:01] <jnthn> Well, that doesn't say anything about laziness...

[18:02] <TimToady> all lists are lazy by default :)

[18:03] *** dakkar left
[18:03] <jnthn> Ugh. It's a good bit harder to efficiently implement these when they gotta deal with laziness

[18:04] <jnthn> Or maybe the insight is, if I'm going to code-gen the lazy case completely different from the sink case, I'll just got ahead and do that for "for" also :)

[18:04] <jnthn> *go

[18:07] <TimToady> that was the original idea; sink context is generally known at compile time

[18:11] <jnthn> OK. So seems like we just need loop { ... } up to spec

[18:12] * jnthn looks forward to working on this; also to doing great evil with for :P

[18:12] <jnthn> Which I hope will make most cases of it faster.

[18:13] *** Entonian_ joined
[18:14] <TimToady> loop in eager context probably deserves a warning, so maybe we end up with "lazy loop {...}" or an appropriately listy return type

[18:14] *** Entonian left
[18:14] *** Entonian_ is now known as Entonian

[18:15] <TimToady> I believe lazy is specced as a statement prefix...yeah

[18:15] *** kivutar joined
[18:18] *** Entonian_ joined
[18:18] *** Entonian left
[18:18] *** Entonian_ is now known as Entonian

[18:20] *** Entonian left
[18:21] * lizmat is back from cycling

[18:22] <lizmat> fwiw, map {} feels more natural to me than loop {}

[18:22] <lizmat> map means returning values to me, loop doesn't

[18:22] *** Entonian joined
[18:23] <TimToady> map is a correspondence, and you're missing one end of it

[18:24] <lizmat> that's why I respecced with Whatever, so there *would* something at the other end, at least conceptually

[18:24] <lizmat> *be

[18:26] <lizmat> sub foo { loop {} }; my @a=foo; foo; # how would we know at compile time whether or not to return values?

[18:27] <lizmat> composability would dictate that sub foo would be generated only in one way, with return values, to accommodate the first call, right?

[18:27] <benabik> You would always return values, just one of them would be discarded.

[18:27] *** Entonian left
[18:27] *** FROGGS joined
[18:27] <TimToady> statement level loops are never lazy now

[18:27] *** jnap left
[18:28] *** jnap joined
[18:28] <TimToady> we could either warn on a last-less loop, or make that one default to sink instead of eager

[18:28] <lizmat> so, in the case of Channel.list, you would use a loop {} instead of a map {} ?

[18:28] <TimToady> or "lazy loop {}"

[18:29] <TimToady> there's really not much use for an eager loop {} unless there's a last in it :)

[18:30] <TimToady> since it would chew up all your memory

[18:30] <moritz> or an exit, or a return

[18:30] <TimToady> but I'm inclined to change the default on statement loop from eager to sink

[18:30] <lizmat> well, I guess I'll have to reprogram my brain to look at "loop" as a thing returning values

[18:30] <timotimo> or a goto to an outer label

[18:31] <TimToady> well, any exception, really

[18:31] <TimToady> so changing the default looks saner

[18:32] <TimToady> you might be able to argue me into extending that to 'while', but probably not to 'for'  :)

[18:32] *** sizz_ joined
[18:33] <PerlJam> moritz++  (Advent day 1 :)

[18:33] <FROGGS> I just hope that this does not break too much code :o)

[18:36] *** yves_ left
[18:36] <TimToady> how many people are using 'while' loops to return values without gather/take?

[18:36] <TimToady> not many, I think

[18:37] <jnthn> TimToady: I'd really like it if for sunk by default in statementlist :)

[18:37] <moritz> well, people put while-loops as the last statement in a routine, and then expect to return() from it

[18:38] <jnthn> TimToady: I think that's better than eager + a warning.

[18:39] <jnthn> TimToady: It'd avoid memory-hungry accidents too

[18:39] <jnthn> TimToady: Personally I'd tend towards using map all the time I wanted to convey "I'm returning stuff"

[18:39] <moritz> +1

[18:40] <jnthn> TimToady: Or shove a "lazy for ..." in to be clear.

[18:40] *** sqirrel joined
[18:40] <moritz> we should just says that loop and while and for always return Nil by default

[18:40] <jnthn> *at statement level*, yes

[18:40] <moritz> aye

[18:40] <jnthn> statementlist, that is

[18:43] *** ajr_ left
[18:45] <dalek> specs: 2772066 | larry++ | S04-control.pod:

[18:45] <dalek> specs: all loops but 'for' default to sink

[18:45] <dalek> specs: 

[18:45] <dalek> specs: At statement level, all loops used to default to eager.  That behavior is

[18:45] <dalek> specs: now reserved to 'for' loops, and all other statement loops default to 'sink'.

[18:45] <dalek> specs: review: https://github.com/perl6/specs/commit/27720668ed

[18:45] <jnthn> Dang...so close... :(

[18:45] <TimToady> chaning for would break existing code :)

[18:45] <TimToady> *ng

[18:46] <jnthn> It'd probably bring down the memory use of even more code :P

[18:46] *** eternaleye left
[18:46] <PerlJam> .oO( Are we starting to worry about backcompat now?  ;-)

[18:47] <TimToady> well, I know changing 'for' would break some rosettacode entries...

[18:48] <jnthn> TimToady: At statementlist level?

[18:48] <jnthn> Hmmm

[18:49] <TimToady> might be worth it, but we'd also have to change eager into a statement prefix, to go with lazy

[18:49] <jnthn> It's not today?

[18:49] <jnthn> Just a function?

[18:50] <TimToady> r: say eager {...}.WHAT

[18:50] <camelia> rakudo-parrot e5fd34, rakudo-jvm e5fd34: OUTPUT«(Block)␤»

[18:50] <TimToady> just a function

[18:50] <TimToady> r: say lazy {...}.WHAT

[18:50] <camelia> rakudo-parrot e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/YOdEcqvZfz␤Undeclared routine:␤    lazy used at line 1␤␤»

[18:50] <camelia> ..rakudo-jvm e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/1F0ylWEpBt␤Undeclared routine:␤    lazy used at line 1␤␤»

[18:50] <TimToady> 'course, that's better than not existing at all :P

[18:51] *** eternaleye joined
[18:51] <FROGGS> I'd think we should care more about the few modules we have rather then rosettacode example we can edit

[18:51] <jnthn> FROGGS: True.

[18:52] <TimToady> I'd think we should care more about the millions of people who will write code someday, not the few who have done so already

[18:52] <FROGGS> that is true too

[18:52] <jnthn> I'm pretty sure none of the ones I've written depend on for returning a result, fwiw.

[18:52] <jnthn> 'cus I'm pretty sure I'd not write it like that...

[18:52] <jnthn> But that's just one data point :)

[18:52] <FROGGS> yeah

[18:52] <FROGGS> and a P5er would not do that either

[18:53] <jnthn> Well, it's not like we don't smoke the modules... :)

[18:53] *** dmol1 joined
[18:53] *** dmol left
[18:53] * jnthn puffs on Rakudo::Debugger, and takes a long draw on Bailador...

[18:54] <jnthn> .oO( I think this means I need dinner... :) )

[18:55] *** benabik left
[18:56] <dalek> specs: 96e17b9 | larry++ | S04-control.pod:

[18:56] <dalek> specs: add eager as a statement prefix

[18:56] <dalek> specs: review: https://github.com/perl6/specs/commit/96e17b9160

[18:57] <diakopter> keyword all the things

[18:57] <dalek> rakudo/moar-support: 826f2b3 | jonathan++ | src/Perl6/World.nqp:

[18:57] <dalek> rakudo/moar-support: Add a missing null check.

[18:57] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/826f2b3535

[18:58] * FROGGS .oO( Do we always have to call it "thing" Jim? )

[19:00] <diakopter> jnthn: theoretically, can NQP do this? (nqp::getattr($_, $code_type, '$!compstuff') || [])[0]

[19:00] <jnthn> diakopter: Not if it's null

[19:00] <jnthn> the boolification will choke on the null

[19:01] *** bluescreen10 left
[19:01] <diakopter> nqp-m: say($*h || [])

[19:01] <camelia> nqp-moarvm: OUTPUT«cannot stringify this␤frame_name_8␤»

[19:01] <diakopter> nqp-p: say($*h || [])

[19:01] <camelia> nqp-parrot: OUTPUT«0␤»

[19:01] <diakopter> nqp-j: say($*h || [])

[19:01] <jnthn> nqp-j: say($*h || [])

[19:02] <camelia> nqp-jvm: OUTPUT«Cannot stringify this␤  in  (gen/jvm/stage2/NQPCORE.setting:672)␤  in print (gen/jvm/stage2/NQPCORE.setting:671)␤  in say (gen/jvm/stage2/NQPCORE.setting:678)␤  in  (/tmp/_8zqD221xW:1)␤  in  (gen/jvm/stage2/NQPHLL.nqp:1100)␤  in eval (gen/jvm/stage2/NQPHL…»

[19:02] <camelia> nqp-jvm: OUTPUT«Cannot stringify this␤  in  (gen/jvm/stage2/NQPCORE.setting:672)␤  in print (gen/jvm/stage2/NQPCORE.setting:671)␤  in say (gen/jvm/stage2/NQPCORE.setting:678)␤  in  (/tmp/PVA4k1pxWM:1)␤  in  (gen/jvm/stage2/NQPHLL.nqp:1100)␤  in eval (gen/jvm/stage2/NQPHL…»

[19:02] <jnthn> There we go :)

[19:02] <diakopter> moar did that too

[19:02] <jnthn> Right :)

[19:02] <jnthn> JVM and Moar agree. Parrot is the odd one out.

[19:02] <FROGGS> yeah, why does the perl6-j actually build?!

[19:02] <diakopter> don't know why moar's stack traces sometimes are truncated to camelia

[19:02] <jnthn> How old is it?

[19:03] *** sahadev joined
[19:03] <jnthn> I fixed that bug a while back..

[19:03] <diakopter> dunno; I thought it was auto-updating, maybe it isnt

[19:03] <jnthn> Or a bug in that area

[19:03] <FROGGS> nqp-m: say(nqp::backendonfig<version>)

[19:03] <camelia> nqp-moarvm: OUTPUT«Error while compiling op backendonfig (source text: "nqp::backendonfig"): No registered operation handler for 'backendonfig'␤frame_name_1109␤»

[19:03] <FROGGS> nqp-m: say(nqp::backendconfig<version>)

[19:03] <camelia> nqp-moarvm: OUTPUT«2013.10-120-gb08a229␤»

[19:03] <dalek> specs: beef8e6 | larry++ | S04-control.pod:

[19:03] <dalek> specs: Okay, statement 'for' is now also sunk.

[19:03] <dalek> specs: 

[19:03] <dalek> specs: Now Perl 6 is perfect.

[19:03] <dalek> specs: review: https://github.com/perl6/specs/commit/beef8e630b

[19:03] <FROGGS> 2013.10-167-g0f2ec7

[19:03] <FROGGS> 47 commits behind

[19:04] <FROGGS> <dalek> specs: Now Perl 6 is perfect. \o/

[19:04] *** darutoko left
[19:04] <diakopter> std: lazy eager lazy eager lazy eager 3

[19:04] <camelia> std 8370f3f: OUTPUT«ok 00:01 123m␤»

[19:04] <jnthn> TimToady++ \o/

[19:04] *** yves_ joined
[19:04] <FROGGS> sad the he didn't meant the implementation *g*

[19:05] <diakopter> pugs: lazy eager lazy eager lazy eager 3

[19:05] <camelia> pugs: OUTPUT«*** Cannot cast from VList [VInt 3] to VCode (VCode)␤    at /tmp/7y33SDZ7iw line 1, column 23 - line 2, column 1␤»

[19:05] <diakopter> p: lazy eager lazy eager lazy eager 3

[19:05] <camelia> rakudo-parrot e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/UIefyVxOCF␤Undeclared routine:␤    lazy used at line 1␤␤»

[19:05] <diakopter> j: lazy eager lazy eager lazy eager 3

[19:05] <camelia> rakudo-jvm e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/TNXtlkQNfB␤Undeclared routine:␤    lazy used at line 1␤␤»

[19:05] *** bluescreen10 joined
[19:05] <jnthn> really dinner &

[19:06] <dalek> std: 3b262af | larry++ | STD.pm6:

[19:06] <dalek> std: add statement_prefix:eager

[19:06] <dalek> std: review: https://github.com/perl6/std/commit/3b262af3c6

[19:07] *** vky joined
[19:16] <dalek> nqp: c8b4012 | (Tobias Leich)++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[19:16] <dalek> nqp: mapped nqp::replace

[19:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c8b4012e15

[19:16] *** SamuraiJack_ left
[19:23] *** [Sno] joined
[19:23] <TimToady> j: $*POSIX.tap({ .say }); await start { alarm 1 }

[19:23] <camelia> rakudo-jvm e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/0RAnQaLPwS␤Undeclared routine:␤    alarm used at line 1␤␤»

[19:23] <TimToady> aww

[19:24] <TimToady> j: $*POSIX.tap({ .say }); kill 1, $*PID;

[19:24] <camelia> rakudo-jvm e5fd34: OUTPUT«===SORRY!=== Error while compiling /tmp/0ux4eOKUBU␤Undeclared routine:␤    kill used at line 1␤␤»

[19:24] <TimToady> aww

[19:25] <TimToady> j: $*POSIX.tap({ .say }); sleep 1

[19:25] <camelia> rakudo-jvm e5fd34: OUTPUT«Dynamic variable $*POSIX not found␤  in any find_method_fallback at gen/jvm/Metamodel.nqp:2607␤  in any find_method at gen/jvm/Metamodel.nqp:945␤  in block  at /tmp/ngk33UliQd:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at…»

[19:26] <itz_>  /last state

[19:26] <itz_> oops

[19:26] <TimToady> hmm, that traceback seems to be exposing a little more mechanism than the user is likely interested in

[19:27] <TimToady> well, better too much than too little, I suppose...

[19:29] <TimToady> but speaking of $*POSIX, we seem to need some mechanism for telling the system which signals we're really interested in, so that every process doesn't have to trap every signal

[19:29] <TimToady> oh, and the name "$*POSIX" is too general :)

[19:30] <FROGGS> what about $*POSIGNAL ? :o)

[19:30] * TimToady is grumpy today for some reason...

[19:30] *** jeffreykegler left
[19:30] <TimToady> you think that's cute today...

[19:30] <FROGGS> maybe more like POSIKNAL

[19:30] <FROGGS> k is a good compromise for X <=> G

[19:30] <TimToady> that's not even cute today :P

[19:31] <FROGGS> hehe, exactly

[19:32] * TimToady thinks that "signals" are entrenched enough in our culture that $*SIGNALS would work--except for the other problem I mentioned of need to register for specific signals

[19:32] <TimToady> *needing

[19:33] <FROGGS> like subscribing to the signals one is interested in?

[19:33] <FROGGS> use signal <...> # that feels like a workaround

[19:35] <TimToady> what you want is a tap on a specific set of signals

[19:35] *** sqirrel left
[19:35] *** rhr joined
[19:36] <TimToady> you might want a different tap on a different set of signals

[19:36] <TimToady> so we need a configurable signal supply

[19:36] <TimToady> a 'grep' is probably not good enough here

[19:37] *** rurban1 left
[19:39] <TimToady> not unless the supply can introspect the smartmatch to determine which signals it should sign up for

[19:41] <TimToady> but maybe smartmatch is overkill here

[19:41] <FROGGS> what if one would register some sort of callback function: signal-handler( Signal $s where ... } ?

[19:41] <TimToady> that's what .tap does

[19:41] <FROGGS> ahh, okay

[19:42] <TimToady> with supplies it's reactive all the way down

[19:42] <TimToady> 'reactive' being the fancy term for callbacks these days :)

[19:44] <TimToady> but in this case, partitioning a subset of the reactions is more like de-combinating than combinating...

[19:45] <TimToady> it's just we have a general problem of how do combinators push their optimizations up the supply chain?

[19:45] <TimToady> one could view not subscribing to all signals as a kind of optimization in that brainstate

[19:46] <TimToady> though in this case the semantics of signals change if you even observe them, so it's not just an optimization

[19:47] *** SL-RHanson left
[19:48] <TimToady> in addition to trapping or dying on a signal, presumably we also need a way to register that a signal should be ignored outright

[19:49] <TimToady> otoh, one could argue that one thread might choose to ignore a signal, while another might choose to trap it, so in that case you have to trap it and pretend to ignore it in the one thread, I suppose

[19:51] <TimToady> setting SIG_IGN then is just an upstream optimization of all taps wanting to ignore the signal, I guess

[19:52] * TimToady wonders how far we can drive this; we've been relatively successful at distributing other "process" concepts like $*CWD and %*ENV

[19:52] <FROGGS> mhm

[19:53] <TimToady> so maybe "temp $*SIGNALS;" lets us have a local signal feed that informs PROCESS::SIGNALS what it should collect all around

[19:54] <TimToady> (assumping "temp" clones the supply appropriately, and that we can then tailor it)

[19:54] <TimToady> well, maybe we just want "my $*SIGNALS = Signals.new(...)" instead

[19:56] <FROGGS> my $*SIGNALS = Signals.new( :subscribe([...]), :filter(...) )

[19:56] <TimToady> not sure how the local supply would coordinate with its parents, unless it went straight to PROCESS::SIGNALS

[19:56] <FROGGS> yeah

[19:56] <TimToady> maybe one level is sufficient here

[19:56] <TimToady> or two, depending on how you count :)

[19:56] <FROGGS> *g*

[19:57] <TimToady> hmm, but likely a multi-interpreter process will want a GLOBAL level too

[19:58] <FROGGS> what if you could say that you want to inherit the pre-filtered signals from the parent? and the default is not to do so?

[19:58] <TimToady> "yes, you can set a signal handler in your apache interpreter, but the other interpreters won't see it"

[19:59] *** vky left
[19:59] <FROGGS> like: my $*SIGNALS = OUTER::Signals.new...

[19:59] <FROGGS> (sort of)

[19:59] <lizmat> so what's wrong with the conceptual simplicity of $*POSIX handling *all* POSIX signals ?

[19:59] <TimToady> well, CALLER probley

[20:00] <TimToady> overhead to set up, distortion of the semantics

[20:00] <lizmat> you want to handle a particular signal, you $*POSIX.tap and ignore all the ones you don't want?

[20:00] <TimToady> many signals default to killing your process if you don't handle them; and are difficult to handle correctly when things are breaking badly

[20:00] <lizmat> hmmm... worrying about overhead now feels like a premature optimization

[20:01] <TimToady> and no way to say you want to ignore a signal

[20:01] <cxreg> do i remember right that moarvm uses libuv?

[20:01] <TimToady> it's startup time

[20:01] <lizmat> there should always be a POSIX.tap for SIGINT and the like

[20:01] <TimToady> likely, but what about SIGFPE

[20:02] <cxreg> if so, might be noteworthy that node.js had a usage bug that was causing memory leaks: http://www.joyent.com/blog/walmart-node-js-memory-leak

[20:02] *** beastd joined
[20:02] *** rindolf left
[20:03] <cxreg> the actual diff: https://github.com/joyent/node/commit/16934d9210546bf19d4af8d98652aa5d636ce693

[20:03] <lizmat> TimToady: maybe some signals aren't meant to be visible at the code level ?

[20:03] <TimToady> cxreg: you probably want to point that out on #moarvm

[20:03] *** FROGGS[mobile] left
[20:03] <cxreg> thanks just found that channel

[20:06] * TimToady reads 'man sigaction' and wonders how to shoehorn all that into a supply

[20:08] *** rurban1 joined
[20:10] * TimToady is starting to think that each signal gets its own supply, and the system just tracks which signals have been tapped and which haven't

[20:10] <TimToady> and if you want to trap a set, you write a combinator

[20:10] <TimToady> but maybe that's overkill

[20:12] <TimToady> for sure, any signal that might indicate low memory needs to have at least one event message of the appropriate type pre-allocated

[20:12] *** rurban1 left
[20:12] <TimToady> can we guarantee that a call to a tap routine allocates no memory for a simple supply/tap relationship?

[20:13] <TimToady> what the tap does from there is of course its own responsibility...

[20:13] <TimToady> signal handling is really, really, really tricky

[20:14] <TimToady> and oversimplifying usually ends up in greater pain downstream

[20:14] * japhb just discovered that <Ctrl> is a hotkey for "Look for new lines" in the irclogs, and LOVES THAT.

[20:14] <japhb> moritz++

[20:14] <jnthn> Moar lazily allocates frames at present so can't promise any invocation won't allocate righ tnow. We could do something about that (keep one in supply)...

[20:14] <preflex>  jnthn: you have 3 new messages. '/msg preflex messages' to read them.

[20:15] <jnthn> ...but harder to make promises on other backends. otoh, their signal support will vary too :)

[20:15] <TimToady> varying from the norm is okay, if we know what the norm should be :)

[20:16] *** stevan_ left
[20:17] *** jnap left
[20:18] *** rindolf joined
[20:18] *** stevan_ joined
[20:24] *** rindolf left
[20:26] <lizmat> perhaps it should be %*POSIX, a hash of signal taps ?

[20:26] *** stevan_ left
[20:27] <jnthn> I doubt it

[20:27] <jnthn> Well, could work I guess...

[20:28] <jnthn> But feels a little clumsy compared to the methods...

[20:28] <lizmat> possibly even auto-vivifying

[20:28] <lizmat> thing is, that different systems may have other keys in the %*POSIX hash, no?

[20:28] <jnthn> yes, some weird tying stuff is what I'm trying to avoid :P

[20:29] <jnthn> Auto-viv is a race condition, so mixing it with supplies feels odd ;)

[20:29] <lizmat> ok, I guess that's a premature optimisation thought  :-)

[20:40] <japhb> Why call something signals related POSIX?  That seems like a very broad term for such a specific use case.

[20:41] <japhb> s/use case/domain/

[20:42] <jnthn> .oO( POSIGS )

[20:42] <lizmat> %*SIG then ?

[20:47] <lizmat> FWIW, I didn't want to combine them with other signally things such as events on Win systems

[20:48] <lizmat> to me, the feel like different things, and should be handled differently

[20:48] <japhb> I always liked the $SIG{INT} syntax in Perl 5.  %*SIG<INT> works for me.

[20:49] <lizmat> if someone wants to merge them into a system-agnostic interface, they can write combinators on the taps  :-)

[20:49] <japhb> Yes, well, that would indicate calling the events thing something other than SIG.  ;-)

[20:49] <japhb> Nodnod

[21:00] *** jnap joined
[21:02] *** dayangkun left
[21:02] *** woolfy left
[21:03] *** stevan__ joined
[21:04] *** berekuk joined
[21:04] *** woolfy joined
[21:08] *** rurban1 joined
[21:09] <dalek> rakudo/moar-support: 2fa3cf8 | (Tobias Leich)++ | src/vm/moar/ (2 files):

[21:09] <dalek> rakudo/moar-support: stub p6routinereturn

[21:09] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/2fa3cf8516

[21:11] *** rurban1 left
[21:17] *** dayangkun joined
[21:18] *** xenoterracide joined
[21:19] *** btyler joined
[21:21] *** jnap left
[21:21] * colomon is confused by TimToady's latest changes to looping

[21:25] <lue> r: token FOO { \d \d \d }; say "333" ~~ /<FOO>/

[21:25] <camelia> rakudo-jvm e5fd34: OUTPUT«Useless declaration of a has-scoped method in mainline (did you mean 'my token FOO'?)␤No such method 'FOO' for invocant of type 'Cursor'␤  in method ACCEPTS at gen/jvm/CORE.setting:12325␤  in block  at /tmp/fM6IvXbRsg:1␤  in any eval at gen/jvm/stag…»

[21:25] <camelia> ..rakudo-parrot e5fd34: OUTPUT«Useless declaration of a has-scoped method in mainline (did you mean 'my token FOO'?)␤No such method 'FOO' for invocant of type 'Cursor'␤  in regex  at /tmp/aKqP54CUDC:1␤  in method ACCEPTS at gen/parrot/CORE.setting:12355␤  in method ACCEPTS at …»

[21:25] <lue> I need slangs, don't I? :(

[21:26] <FROGGS> r: regex FOO { \d \d \d }; say "333" ~~ /<FOO>/

[21:26] <camelia> rakudo-parrot e5fd34: OUTPUT«Useless declaration of a has-scoped method in mainline (did you mean 'my regex FOO'?)␤No such method 'FOO' for invocant of type 'Cursor'␤  in regex  at /tmp/FRToa8Sea8:1␤  in method ACCEPTS at gen/parrot/CORE.setting:12355␤  in method ACCEPTS at …»

[21:26] <camelia> ..rakudo-jvm e5fd34: OUTPUT«Useless declaration of a has-scoped method in mainline (did you mean 'my regex FOO'?)␤No such method 'FOO' for invocant of type 'Cursor'␤  in method ACCEPTS at gen/jvm/CORE.setting:12325␤  in block  at /tmp/mrTtUUqimY:1␤  in any eval at gen/jvm/stag…»

[21:26] <FROGGS> r: my regex FOO { \d \d \d }; say "333" ~~ /<FOO>/

[21:26] <camelia> rakudo-parrot e5fd34, rakudo-jvm e5fd34: OUTPUT«｢333｣␤ FOO => ｢333｣␤␤»

[21:26] <lue> o... k?

[21:27] <lue> r: my method bar { say "OK" }; say bar

[21:27] <camelia> rakudo-jvm e5fd34: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in block  at /tmp/japUNgY2RM:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292␤  in any command_eval at gen/jvm/stage2/NQPHLL.nqp:11…»

[21:27] <camelia> ..rakudo-parrot e5fd34: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in method bar at /tmp/rAu3ag2MQF:1␤  in block  at /tmp/rAu3ag2MQF:1␤  in any  at /tmp/rAu3ag2MQF:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2…»

[21:29] *** berekuk left
[21:32] <FROGGS> lue: a method gets its SELF as the first argument

[21:32] <FROGGS> r: my method bar { say self }; bar 42

[21:32] <camelia> rakudo-parrot e5fd34, rakudo-jvm e5fd34: OUTPUT«42␤»

[21:33] *** kivutar left
[21:37] <dalek> rakudo/moar-support: a32376d | (Tobias Leich)++ | src/vm/moar/ (2 files):

[21:37] <dalek> rakudo/moar-support: stub p6recont_ro

[21:37] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/a32376de3b

[21:38] <timotimo> hi

[21:39] *** berekuk joined
[21:39] <FROGGS> hi

[21:41] *** berekuk left
[21:41] <lizmat> S06:3377

[21:41] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_3377

[21:41] *** ssutch left
[21:41] <dalek> rakudo/moar-support: f38804e | (Tobias Leich)++ | src/vm/moar/Perl6/Ops.nqp:

[21:41] <dalek> rakudo/moar-support: remove already implemented op p6bindattrinvres

[21:41] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/f38804e2c6

[21:50] <timotimo> FROGGS: oops, i had  already made a commit to map nqp::replace, but i forgot to pullrequest it

[21:50] <FROGGS> timotimo: well, it is just a line :o)

[21:51] <FROGGS> timotimo: we pass the optimizer now btw

[21:51] <timotimo> \o/

[21:51] <timotimo> but that wasn't replace

[21:51] <timotimo> can you tell me what did it?

[21:52] <FROGGS> replace was one thing I think, the other was the explosion due to atpos_o on a NULL pointer

[21:52] <timotimo> no, replace was first needed after the optimizer because it was the first thing i hit when i ran --optimize=off

[21:53] <FROGGS> ahh, but it got us further at least :o)

[21:53] *** BenGoldberg joined
[21:53] <timotimo> well, not necessarily "no", but ... you know :)

[21:54] <jnthn> It was just a place that expected null to throw when it current explodes on Moar.

[21:54] <timotimo> ah!

[21:54] <jnthn> I tweaked it to check for that and things got better :)

[21:54] <timotimo> it's that easy :)

[21:54] <timotimo> thanks

[21:54] <jnthn> Commit is only one of mine today so should be easy to find 

[21:55] <dalek> rakudo/moar-support: 6c8adf4 | (Tobias Leich)++ | src/vm/moar/ (2 files):

[21:55] <dalek> rakudo/moar-support: stub p6finddispatcher

[21:55] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/6c8adf4faf

[21:56] *** PZt left
[21:56] <timotimo> and now we're just doing NYI-throwing ops?

[21:57] <FROGGS> well, I am unable to implement these, so I stub them which helps jnthn++ as he said :o)

[21:58] <timotimo> :D

[21:58] <timotimo> sounds good to me

[21:58] <FROGGS> if you want you could look into p6routinereturn, it is not too hard I think

[21:58] <timotimo> i should get into backlog reading for the evening

[21:58] *** PacoAir left
[21:59] <jnthn> p6shiftpush should at least be easy enough ;)

[21:59] <FROGGS> will that live in Ops.nqp directly?

[22:00] *** Pzter33-- joined
[22:02] *** Pzter33-- is now known as PZt

[22:02] <jnthn> No, can do it in perl6_ops.c

[22:02] <jnthn> It's just quite straightforward to do :)

[22:02] *** rurban1 joined
[22:06] <dalek> rakudo/moar-support: ee9a069 | (Tobias Leich)++ | src/vm/moar/ (2 files):

[22:06] <dalek> rakudo/moar-support: stub p6argsfordispatcher

[22:06] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/ee9a069ef8

[22:06] <dalek> rakudo/moar-support: bffdc26 | (Tobias Leich)++ | src/vm/moar/Perl6/Ops.nqp:

[22:06] <dalek> rakudo/moar-support: remove already implemented op p6inpre

[22:06] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/bffdc2695b

[22:07] <FROGGS> umm, now we're stuck at openpipe

[22:07] <timotimo> ah, not running, but compiling, right?

[22:07] <FROGGS> compiling, yes

[22:08] <FROGGS> I'll just comment it out to see what is next

[22:08] <FROGGS> dunno how much fun it is to implement openpipe O.o

[22:09] *** kaare_ left
[22:12] *** spider-mario left
[22:13] <FROGGS> w.r.t. S11: my CompUnitRepo implementation can locate and load modules as specced in S11, and sticks the CompUnitRepos in %*CUSTOM_LIB under their name... e.g. perl/vendor/site/home/usb-stick/...

[22:14] <lizmat> FROGGS++

[22:14] <FROGGS> so, next is that panda uses such a CUR if the destination path is under a CUR's control

[22:15] <japhb> Yes, FROGGS++

[22:15] <FROGGS> and to handle perl6 -ICompUnitRepo=/path/to/my/usb/stick -e ...

[22:15] <japhb> And ++FROGGS for the panda work

[22:15] <FROGGS> :o)

[22:15] *** btyler left
[22:15] <FROGGS> yeah, I hope it is not too painful

[22:16] <FROGGS> timotimo: xor is the next missing op after openpipe

[22:17] <timotimo> is it as easy as i think it is?

[22:17] <FROGGS> dont think so

[22:18] <jnthn> xor is a control flow op that needs interesting compilation

[22:18] <timotimo> that means i won't do it :D

[22:18] <jnthn> Needs doing it QASTOperationsMAST in the NQP repo

[22:19] <FROGGS> hmmm, maybe it is: https://github.com/perl6/nqp/blob/master/src/vm/parrot/QAST/Operations.nqp#L777

[22:21] <jnthn> It shooldn't be ofervder hard to port

[22:21] <jnthn> shouldn't, overly

[22:21] <jnthn> from the Parrot version, that is

[22:41] <dalek> nqp: a67cbd1 | dwarring++ | examples/rubyish/ (6 files):

[22:41] <dalek> nqp: improved rubyish method and var parsing.

[22:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a67cbd131e

[22:42] *** stevan__ left
[22:52] <FROGGS> I wonder why nobody is working on PHPish :o)

[22:54] <timotimo> hehe :)

[22:56] *** hummeleB1 left
[22:56] <jnthn> I dunno! It's not like there's many built-in functions to do...

[23:02] <FROGGS> the problem might be the implicit parameter mixup

[23:03] <FROGGS> and the minimum_function_name_length of 47 or so

[23:04] <jnthn> Or everybody is keen to escape parsing the namespace syntax...

[23:04] <FROGGS> we should stop ranting about the successor of Perl :P

[23:06] <jnthn> Well...sleep, I guess...

[23:06] <jnthn> 'night

[23:07] <FROGGS> gnight

[23:07] <timotimo> gnite :)

[23:08] *** prevost joined
[23:16] *** stevan_ joined
[23:16] *** vky joined
[23:23] *** ssutch joined
[23:30] <lue> Am I right in thinking that there's no alternative to DateTime.in-timezone() that let's me specify timezone as, say, "+0200" ?

[23:31] <timotimo> The general notation for the [offset] is +hhmm or -hhmm. The time zone of the new object is assumed to be a static offset equal to the [offset].

[23:32] <lue> timotimo: that refers to ISO 8601 strings though.

[23:34] <retupmoca> lue: https://github.com/supernovus/perl6-timezone/ has a tz-offset() that claims to parse the "+0200" format

[23:35] <timotimo> ah

[23:35] <retupmoca> I have a fork of that repo where I'm attempting to implement proper timezone support, but it's not really ready for use yet

[23:35] <lue> ah. Pulling in a module for one function seems a bit heavy-handed here though.

[23:36] <FROGGS> nqp: say(nqp::xor(1, 1))

[23:36] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤  in  (gen/jvm/stage2/NQPCORE.setting:672)␤  in print (gen/jvm/stage2/NQPCORE.setting:671)␤  in say (gen/jvm/stage2/NQPCORE.setting:678)␤  in  (/tmp/4ZrqzlF_FF:1)␤  in  (gen/jvm/stage2/NQPHLL.nqp:1100)␤  in eval (gen/jvm/sta…»

[23:36] <camelia> ..nqp-moarvm: OUTPUT«Error while compiling op xor (source text: "nqp::xor(1, 1)"): No registered operation handler for 'xor'␤frame_name_1109␤»

[23:36] <camelia> ..nqp-parrot: OUTPUT«␤»

[23:37] <FROGGS> nqp-m: say(nqp::null)

[23:37] <camelia> nqp-moarvm: OUTPUT«␤»

[23:37] <lue> r: say DateTime.new("2013-11-23T19:00Z")

[23:37] <camelia> rakudo-jvm e5fd34: OUTPUT«Invalid DateTime string '2013-11-23T19:00Z'; use an ISO 8601 timestamp (yyyy-mm-ddThh::mm::ssZ or yyyy-mm-ddThh::mm::ss+0100) instead␤  in method new at gen/jvm/CORE.setting:14391␤  in block  at /tmp/tlmM5xAgfL:1␤  in any eval at gen/jvm/stage2/NQPHLL…»

[23:37] <camelia> ..rakudo-parrot e5fd34: OUTPUT«Invalid DateTime string '2013-11-23T19:00Z'; use an ISO 8601 timestamp (yyyy-mm-ddThh::mm::ssZ or yyyy-mm-ddThh::mm::ss+0100) instead␤  in method new at gen/parrot/CORE.setting:14654␤  in method new at gen/parrot/CORE.setting:795␤  in block  at /tm…»

[23:37] <lue> well, that's wrong.

[23:38] <timotimo> you need :00 before your  Z

[23:38] <japhb> lue: The problem is that with timezones you should generally support either: A) full Olson TZ info, or B) UTC/TAI only.  If you support anything in between, you just guarantee a lot of code in the wild that Does It Wrong.  It's like partial locale support.

[23:39] <lue> timotimo: nope. https://en.wikipedia.org/wiki/ISO_8601

[23:40] <retupmoca> japhb: I'm (slowly) extending that module to parse the olson tzdata files

[23:40] <timotimo> oh

[23:41] <japhb> retupmoca, Good!  But I wasn't saying anything negative about the module, just that people plead for "Just give me offset, it's pretty easy and good enough!"  And they're usually wrong on both counts.  :-(

[23:41] <retupmoca> oh yeah, I agree on that point

[23:41] <japhb> Fixed offset notation was, I think, a major mistake of the otherwise decent ISO 8601 idea. 

[23:41] *** xenoterracide left
[23:42] <lue> timotimo: S32::Temporal, to be fair, ignores a majority of the ISO 8601 format. (And that's not even looking at the duration or interval notations)

[23:42] <timotimo> mhm :(

[23:43] <timotimo> if you have the necessary knowledge, why not patch the synopsis?

[23:43] <FROGGS> well, it is easily improvable

[23:43] <japhb> Time is one of the Humans Made It Painful portions of CS.  And unfortunately, attempts to make it less painful have the opposite effect in the long run. 

[23:43] <timotimo> :)

[23:44] <lue> timotimo: I probably should, although I don't know how much of a ISO 8601 primer that would require. :)

[23:45] <lue> japhb: in ISO 8601's defense, timezones on a strictly technical basis shouldn't need to know squiggly map lines :)

[23:46] <japhb> "shouldn't"   Oh, the pain that word has caused.  ;-)

[23:46] <timotimo> :D

[23:46] * lue personally has never really liked the location-based timezone specifiers anyway. Always felt too imprecise and redundant.

[23:49] <lue> I'll refrain from filing an IS0-8601 bug for the time being, seeing as the spec is lacking in the details.

[23:52] *** bluescreen100 joined
[23:52] <lue> (anyone else think it's a bad thing that S32::Temporal doesn't mention Duration objects at all?)

[23:55] *** bluescreen10 left
[23:56] <japhb_> lue: Kinda seems the right place for that, doesn't it?

[23:56] <lue> japhb_: a little bit :)

