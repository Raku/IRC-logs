[00:02] <masak> 'night, #perl6

[00:03] <FROGGS> gnight all

[00:05] <not_gerd> night

[00:05] *** not_gerd left
[00:05] <uvtc> ☾

[00:09] *** wk_ left
[00:15] *** uvtc left
[00:15] <[Coke]> is rakudo using any of the runtime modules provided by parrot?

[00:31] *** thou joined
[00:38] *** lue joined
[00:45] <dalek> rakudo-js: 96b8ae7 | (Paweł Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[00:45] <dalek> rakudo-js: mangle the new identifier

[00:45] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/96b8ae7f17

[00:49] <dalek> perl6-most-wanted: ee48cf8 | (Geoffrey Broadwell)++ | most-wanted/ (2 files):

[00:49] <dalek> perl6-most-wanted: Start filling out most-wanted files based on Perl 6 Ecosystem Most Wanted Modules list

[00:49] <dalek> perl6-most-wanted: review: https://github.com/japhb/perl6-most-wanted/commit/ee48cf80ea

[00:52] *** PacoAir joined
[01:26] *** PacoAir left
[01:27] <dalek> rakudo-js: b3325bc | (Paweł Murias)++ | run (2 files):

[01:27] <dalek> rakudo-js: Pass qast_stat.t.

[01:27] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/b3325bc51a

[01:29] *** PacoAir joined
[01:37] <dalek> roast: 3972c4d | (Solomon Foster)++ | S02-types/set.t:

[01:37] <dalek> roast: Some basic tests for .set method.

[01:37] <dalek> roast: review: https://github.com/perl6/roast/commit/3972c4df78

[01:38] <dalek> niecza: 81d9dca | (Solomon Foster)++ | lib/CORE.setting:

[01:38] <dalek> niecza: Add Hash.set and Hash.bag.

[01:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/81d9dca7c9

[01:38] *** jeffreykegler joined
[01:45] <TimToady> Yes, set should not flatten in list context, even though hash does

[01:45] <TimToady> otherwise it's nearly impossible to make a set of sets

[01:51] <colomon> rn: say 42.set

[01:51] <p6eval> rakudo a3869a, niecza v24-21-g4c8f264: OUTPUT«set(42)␤»

[01:51] <dalek> specs: 13a275e | larry++ | S32-setting-library/Containers.pod:

[01:51] <dalek> specs: sets and bags don't flatten in list context

[01:51] <dalek> specs: review: https://github.com/perl6/specs/commit/13a275ea39

[01:51] <TimToady> rn: say <a b c>.set

[01:51] <p6eval> rakudo a3869a, niecza v24-21-g4c8f264: OUTPUT«set(a, b, c)␤»

[01:51] <colomon> ?"

[01:52] <colomon>  sorry, was sorting socks on my keyboard.

[01:52] <TimToady> that's a new one

[01:52] * colomon hopes set(a, b, c) was the answer TimToady hoped to get.

[01:52] <TimToady> yes

[01:52] <colomon> \o/

[01:52] <TimToady> rn: (1,2,3).set

[01:52] <p6eval> rakudo a3869a, niecza v24-21-g4c8f264:  ( no output )

[01:53] <TimToady> rn: say (1,2,3).set

[01:53] <p6eval> rakudo a3869a, niecza v24-21-g4c8f264: OUTPUT«set(1, 2, 3)␤»

[01:53] <colomon> I haven't added it to the spec yet, but I added it to both rakudo and niecza and roast.  :)

[01:53] <TimToady> \o/

[01:53] <TimToady> thanks

[01:54] <colomon> I'd written a piece of code that looked like (set @hashes).map(*.Str).sort.join(",") || "<none>"; and it just seemed really stupid that I couldn't say @hashes.set.map(*.Str).sort.join(",") || "<none>";  And I remembered thinking that for something before, too.

[01:57] <TimToady> rn: say (1,2,3).Set

[01:57] <p6eval> niecza v24-21-g4c8f264: OUTPUT«Unhandled exception: Unable to resolve method Set in type Parcel␤  at /tmp/9cIkREXo2w line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4230 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4231 (module-CORE @ 580) ␤  at /home…

[01:57] <p6eval> ..rakudo a3869a: OUTPUT«No such method 'Set' for invocant of type 'Parcel'␤  in block  at /tmp/ryQh_CEK28:1␤␤»

[01:58] <TimToady> me wonders if it should be capitalized

[01:58] <TimToady> especially since there's another meaning to the word "set"

[01:58] <benabik> +1

[01:59] <benabik> One of these things are not like the others:  *.Int, *.Str, *.set

[01:59] <TimToady> well, there's .list

[01:59] <benabik> Does it return a List?

[02:00] <TimToady> though taking the .set method will discourage people from writing getters/setters :)

[02:00] <pmurias> TimToady: so what's the decision on Array.delete only exposing it on implementations which use sparse array internaly doesn't seem to portable

[02:01] <pmurias> s/Array.delete/Array.delete?

[02:01] <TimToady> the semantics should stay the same regardless of how it's implemented underneath

[02:02] <TimToady> if an implementation can't support NULL poking, then it should probably support it via a real sparse array instead

[02:02] <TimToady> otoh an argument could be made that this may negatively affect performance on non-sparse arrays

[02:04] *** jeffreykegler left
[02:05] <diakopter> what's a heuristic one could use to detect when to switch to a sparse backing array

[02:06] <TimToady> well, the first delete is a big clue :)

[02:06] <diakopter> ok, sounds good to me

[02:06] <benabik> @a[$x] = $y, when $x >> +@a

[02:07] <TimToady> but merely tracking how much wasted space there is would be a kloo

[02:07] <benabik> (Well, when $x >> @a.allocated_size)

[02:09] *** FROGGS_ joined
[02:10] <pmurias> TimToady: on the other hand we could have a sparse array which just avoids storing Mu, and exposes a regular interface

[02:10] *** FROGGS left
[02:12] <TimToady> we could, but non-sparse arrays would tend to go all n-log-n-y on access

[02:13] <TimToady> they might do that anyway if you're using a lockless structure, but it's really a choice of the implementor

[02:14] <TimToady> we just need to make sure the API is consistent, and hopefully provides sufficient info to optimize where that's important

[02:14] <TimToady> these are the sorts of implementation decisions that we should try to keep from leaking into our abstractions

[02:15] <pmurias> TimToady: n-log-n-y?

[02:15] <benabik> Non-sparse arrays go n-log-n on access?  Shouldn't non-sparse element access be O(1)?

[02:16] <diakopter> benabik: (that's what I would imagine)

[02:16] <diakopter> (based on my naive first guess at imagined implementation)

[02:16] <TimToady> yes, they *should* be O(1), that's my point :)

[02:16] <TimToady> but merely swapping in a sparse implementation might not do that

[02:17] <TimToady> I mean instead of having a flat implementation

[02:17] <TimToady> I was talking about an implementation that always uses a tree for arrays, which would be suboptimalish in that way

[02:18] <TimToady> P5 has done very well with a bias towards flat arrays, and emulating a bit of sparseness by null poking

[02:19] <diakopter> null poking?

[02:19] <TimToady> what P5 does on delete from array

[02:19] <TimToady> and exists just says whether there's a pointer at that index

[02:21] <TimToady> arrays and hashes are conceptually different, but in practice they mush into each other a bit, depending on the underlying container's semantics

[02:22] <TimToady> however, in P6, it's an absolute that .[] is always 0 based, and we use .{} aliasing (according to S09) if we want negative indices

[02:26] *** PacoAir left
[02:42] *** alec__ left
[02:43] <timotimo> i think tomorrow i shall play around with zmq :)

[02:43] <timotimo> see if i can get a simple connection working with ipython

[02:43] <timotimo> did not notice anything missing so far

[02:44] <timotimo> what are the deciding factors for what gets put into rakudo star?

[02:59] *** pmurias left
[03:04] <benabik> Actually, ideally a sparse array is no worse than log n on access.  (Not that it really matters, just occurred to me.)

[03:07] <timotimo> right, because that would be a tree, right?

[03:13] *** alec__ joined
[03:22] *** stevan__ joined
[03:25] *** stevan_ left
[03:25] *** stevan_ joined
[03:28] *** stevan__ left
[03:30] *** Chillance left
[03:55] <dalek> niecza: 0520c7c | (Solomon Foster)++ | lib/CORE.setting:

[03:55] <dalek> niecza: Add another to-set multi to resolve conflict.

[03:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0520c7c7a6

[04:01] *** swarley| left
[04:01] <dalek> roast: 38dd58f | (Solomon Foster)++ | S02-types/bag.t:

[04:01] <dalek> roast: Some tests for .bag.

[04:01] <dalek> roast: review: https://github.com/perl6/roast/commit/38dd58fedf

[04:17] *** happydude joined
[04:46] *** flussence left
[04:57] *** preflex left
[04:58] *** preflex joined
[05:22] *** xinming left
[05:33] *** xinming joined
[05:36] *** daniel-s joined
[05:52] *** happydude left
[06:03] *** preflex left
[06:05] *** preflex joined
[06:58] <dalek> specs: 3b88fdf | larry++ | S02-bits.pod:

[06:58] <dalek> specs: autopriming doesn't look inside metaops

[06:58] <dalek> specs: review: https://github.com/perl6/specs/commit/3b88fdfa31

[07:07] *** GlitchMr left
[07:11] *** GlitchMr joined
[07:14] *** quester joined
[07:22] *** ggoebel_ left
[07:23] *** proller joined
[08:07] *** pupoque joined
[08:30] *** bluescreen100 joined
[08:33] *** bluescreen10 left
[08:34] *** domidumont joined
[08:40] *** jaldhar left
[08:48] *** thou left
[08:51] *** domidumont left
[08:52] *** domidumont joined
[09:15] *** erkan joined
[09:19] *** immortal joined
[09:20] *** erkan left
[09:24] *** shevy joined
[09:24] *** shevy left
[09:26] <moritz> jnthn: rakudo/nom segfaults while compiling BOOTSTRAP

[09:26] <moritz> (on 64bit)

[09:29] *** quester left
[09:33] *** immortal left
[09:33] *** erkan joined
[09:33] *** wk_ joined
[09:35] *** FROGGS_ is now known as FROGGS

[09:35] <FROGGS> "morning"

[09:36] *** rindolf joined
[09:37] <FROGGS> moritz: I get a $past that has $past.isa(QAST::Op) && $past.op eq 'callmethod' && $past.name eq 'list', then I could wrap it in an QAST::Op that calls map, right?

[09:44] *** stevan_ left
[09:44] *** kaare_ joined
[09:45] *** Psyche^ joined
[09:48] *** Patterner left
[09:48] *** Psyche^ is now known as Patterner

[09:53] <moritz> FROGGS: you could, yes

[09:55] <FROGGS> k, thanks

[09:59] *** wk_ left
[09:59] *** snearch joined
[09:59] *** snearch left
[10:31] <nwc10> is Array.at_pos() part of the spec, or an implementation detail?

[10:32] <sorear> I think it's intended to be spec once there's consensus it's solid

[10:33] <nwc10> OK. It accepts negative indices. [] doesn't

[10:33] <sorear> ISTR jnthn talking about at_pos as being the preferred point for module authors to hook into indexing

[10:34] <arnsholt> Yep. There're some complicated bits like slicing that [] implements in terms of at_pos, so that other people don't have to

[10:38] <nwc10> next stupid question - is there a way to monkey-patch methods into Array, so that I can test them without recompiling the setting?

[10:39] <arnsholt> I think the usual way is to subclass it and test your implementation that way, before moving it into the setting

[10:39] <moritz> nwc10: sure, you can write   use MONKEY_TYPING; augment class Array { your methods here }

[10:40] <moritz> nwc10: and then run your tests with it from the same file

[10:40] <nwc10> thanks

[10:40] <moritz> that's how I developed many built-ins that ended up in the setting

[10:40] <nwc10> works on my machine

[10:40] <moritz> you just can't replace existing methods that way

[10:41] <moritz> (if the method isn't used for bootstrappy purposes, you can delete it once from the setting, recompile and them monkey-patch it in again)

[10:47] <nwc10> r: my @a = "Q"; my $b := @a.at_pos(-1); say @a; $b = "Pi"; say @a

[10:47] <p6eval> rakudo a3869a: OUTPUT«Q␤Pi␤»

[10:48] <nwc10> so, binding to -1 works, and can be assigned to. But direct assignement:

[10:48] <nwc10> r: my @a = "Q"; @a.at_pos(-1) = "Pi"; say @a;

[10:48] <p6eval> rakudo a3869a: OUTPUT«ResizablePMCArray: index out of bounds!␤  in block  at src/gen/CORE.setting:6312␤  in block  at /tmp/pVWoo4iDNp:1␤␤»

[10:49] <moritz> I think at_pos supporting negative arguments is a misfeature

[10:49] <nwc10> it's easier to reimplement if it doesn't

[10:50] <nwc10> and I'm out of my depth to explain why I can bind then assign, but can't assign directly

[10:50] <moritz> IMHO it's the job of postcircumfix:<[ ]> to make sure that sane arguments are passed to at_pos

[10:50] <nwc10> that, I think, already throws an exception for negative arguments

[11:06] <jnthn> morning o/

[11:07] <jnthn> Well, not quite, but...

[11:07] <jnthn> moritz: Odd about the SEGV...did you (or could you try) make realclean in NQP and Rakudo just in case?

[11:07] <jnthn> moritz: I note that p6eval seems to have managed to build it...

[11:13] *** geekosaur left
[11:15] *** geekosaur joined
[11:18] <masak> afty, #perl6

[11:20] <sorear> o/ masak

[11:26] *** wk_ joined
[11:31] *** not_gerd joined
[11:31] <not_gerd> o/

[11:32] *** pupoque left
[11:32] <masak> \o

[11:32] *** wk_ left
[11:33] <not_gerd> Is this correct: Rakudo depends on PCT via PAST/POST, but not on PGE and TGE

[11:33] <masak> Rakudo used to depend on PCT via PAST/POST.

[11:33] <jnthn> Not, it doesn't use PAST or POST any more.

[11:33] <masak> now nqp handles those bits, using QAST.

[11:33] <not_gerd> good

[11:34] <jnthn> Right, and POST was replaced with PIRT

[11:34] <jnthn> Which saved a good bit of memory :)

[11:34] <masak> it's correct that Rakudo doesn't use PGE anymore. nqp handles that, too.

[11:34] <masak> I'm not aware that Rakudo ever used TGE.

[11:34] <jnthn> Maybe it did before it was Rakudo.

[11:34] <jnthn> :)

[11:34] <masak> maybe.

[11:35] <masak> I've never seen TGE being used anywhere. my impression is that it was something XSLT-like. but I may be wildly wrong about that.

[11:35] <jnthn> Attribute grammar based, iirc

[11:36] * not_gerd is trying to rip out stuff from parrot

[11:36] <jnthn> moritz: Just done a fresh build of everything here and it worked. If it is still segfaulting for you, a bt would help.

[11:38] <nwc10> oh yes, worked on a complete clean fresh build for me on x86_64 Linux

[11:38] <nwc10> forgot to say

[11:40] <masak> jnthn: oh, right. attribute grammar rings a bell.

[11:40] <masak> which means, again IIUC, that values are calculated based on fairly fluid dependency relations up and down the tree.

[11:52] <nwc10> jnthn: if at_pos didn't accept negative indices, life would be easier

[11:52] <dalek> nqp: 6b358a3 | jnthn++ | src/core/NQPRoutine.pm:

[11:52] <dalek> nqp: Toss now-unrequired clone callback legacy code.

[11:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6b358a3dcc

[11:52] <dalek> nqp: f92cd68 | jnthn++ | src/QAST/Operations.nqp:

[11:52] <dalek> nqp: Add an nqp::escape that maps to pir::escape.

[11:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f92cd68130

[11:52] <dalek> nqp: 3f27005 | jnthn++ | src/stage0/ (9 files):

[11:52] <dalek> nqp: Update bootstrap.

[11:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3f27005e4c

[11:52] <dalek> nqp: 26d0d0f | jnthn++ | src/QAST/ (2 files):

[11:52] <dalek> nqp: Get QASTNodes free of pir::.

[11:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/26d0d0f9b7

[11:53] <jnthn> nwc10: I...wasn't terribly aware it did

[11:53] <nwc10> well, it passes them all through unchecked to Parrot

[11:53] <jnthn> nwc10: Oh, does it work because the underlying nqp::atpos call it makes will make it work?

[11:53] <nwc10> which does the Perl 5 thing

[11:53] <jnthn> Yeah

[11:53] <nwc10> there is no spec for at_pos, is there?

[11:53] <jnthn> r: my @a; @a[-1] = 42

[11:53] <p6eval> rakudo a3869a: OUTPUT«Cannot use negative index -1 on Array␤  in method <anon> at src/gen/CORE.setting:10518␤  in  at src/gen/Metamodel.pm:2488␤  in any find_method_fallback at src/gen/Metamodel.pm:2476␤  in any find_method at src/gen/Metamodel.pm:925␤  in block  at /tmp/WQ5CfdWT6J:1␤␤»…

[11:54] <nwc10> jnthn: this one seems a bit special:

[11:54] <nwc10> rn: my @a = "Q"; my $b := @a.at_pos(-1); say @a; $b = "Pi"; say @a

[11:54] <p6eval> niecza v24-23-g0520c7c: OUTPUT«Q␤Unhandled exception: Writing to readonly scalar␤  at /tmp/5VIpPlG9bW line 1 (mainline @ 7) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4233 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4234 (module-CORE @ 580) ␤  at /home/p6eval/niecza/…

[11:54] <p6eval> ..rakudo a3869a: OUTPUT«Q␤Pi␤»

[11:54] <nwc10> but if I assign directly:

[11:54] *** not_gerd left
[11:54] <nwc10> rn: my @a = "Q"; my $b := @a.at_pos(-2); say @a; $b = "Pi"; say @a

[11:54] <p6eval> niecza v24-23-g0520c7c: OUTPUT«Q␤Unhandled exception: Writing to readonly scalar␤  at /tmp/R97BJDqmX7 line 1 (mainline @ 7) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4233 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4234 (module-CORE @ 580) ␤  at /home/p6eval/niecza/…

[11:54] <p6eval> ..rakudo a3869a: OUTPUT«Q␤ResizablePMCArray: index out of bounds!␤  in block  at src/gen/CORE.setting:6312␤  in block  at /tmp/hf6AmK3vH1:1␤␤»

[11:54] <nwc10> oops

[11:55] <jnthn> at_pos ain't meant to be called directly really

[11:55] <nwc10> this one:

[11:55] <nwc10> rn: my @a = "Q"; @a.at_pos(-1) = "Pi"; say @a;

[11:55] <p6eval> niecza v24-23-g0520c7c: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/iUM6cmaxiq line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4233 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4234 (module-CORE @ 580) ␤  at /home/p6eval/niecza/li…

[11:55] <p6eval> ..rakudo a3869a: OUTPUT«ResizablePMCArray: index out of bounds!␤  in block  at src/gen/CORE.setting:6312␤  in block  at /tmp/ZaPQ0bu_mB:1␤␤»

[11:55] <jnthn> @foo[...] calls postcircumfix:<[ ]>

[11:55] <nwc10> so, direct assignment is a bounds failure, but I can bind to it and then assign without error

[11:55] <nwc10> I'd figured out that @foo[...] called that, by using ack to find the error message :-)

[11:56] <jnthn> Anyway, I suspect that the oddness is 'cus at_pos (the method) was written expecting to never be passed anything negative.

[11:56] <nwc10> ah OK.

[11:56] <jnthn> Which it never is in normal use thanks to postcircumfix:<[ ]>

[11:57] <nwc10> I shall try refactoring it to treat anything negative as, um, wrong-in-some-fashion

[11:57] <jnthn> Yeah, but if you do that let's consider moving the check out of postcircumfix maybe?

[11:57] <jnthn> Doing it twice over is wasteful.

[11:57] <nwc10> good point

[11:58] <nwc10> I might be abducted by the requirement to go out with the toboggan

[11:58] <jnthn> ;)

[11:59] <jnthn> The other thing is that we can easily make the JVM impl of nqp::atpos etc just reject negative indices rather than trying to make sense of them, and declare that as the expected behavior.

[11:59] <jnthn> (Then find a way to make it happen on Parrot.)

[11:59] <nwc10> My gut feeling is that negative indices (and sparseness, if desired) belong in the layer that implements the Perl 6 compiler

[12:00] <nwc10> and the NQP level should be non-negative non-sparse only

[12:00] <nwc10> but this is a gut feeling

[12:00] <jnthn> Well, you aren't allowed negative indices in Perl 6 really.

[12:00] <jnthn> @a[-1] is an error, you're meant to write @a[*-1]

[12:00] <nwc10> I sort of inferred that from Any.pm's grumpiness :-)

[12:06] *** not_gerd joined
[12:13] * moritz idly ponders an ORM where you have roles instead of result classes, and when you do a join, it mixes in the roles that correspond to each table

[12:15] * jnthn idly ponders than "ORM" is Swedish for "SNAKE" :)

[12:15] <jnthn> *that

[12:15] <moritz> .oO( pyhton ORM )

[12:18] <moritz> though I guess when most of your tables have a last_changed timestamp, you'd get either a silent overwrite or a coposition conflict

[12:18] <nwc10> OK, is this a rakudobug

[12:18] <nwc10> r: my @a = "Q"; @a.at_pos(-1) = "Pi"; say @a;

[12:18] <p6eval> rakudo a3869a: OUTPUT«ResizablePMCArray: index out of bounds!␤  in block  at src/gen/CORE.setting:6312␤  in block  at /tmp/pAjocXUetQ:1␤␤»

[12:18] <nwc10> r: my @a = "Q"; say @a; @a.at_pos(-1) = "Pi"; say @a;

[12:18] <p6eval> rakudo a3869a: OUTPUT«Q␤Pi␤»

[12:19] <nwc10> ie, adding say @a; makes everything peachy

[12:21] <jnthn> nwc10: It's just a consequence of nothing else downstream of at_pos expecting a -1

[12:22] <jnthn> nwc10: Of note, I suspect it's the "make sure we reified up to n elements" thing

[12:22] <jnthn> And reificiation is memoized, so the say makes it happen so it can output the array and then the data is luckily in the right place when the unexpected -1 indexing happens.

[12:23] <nwc10> OK. so this is all suggesting that life is simpler if at_pos does the negative index sanity check

[12:23] <jnthn> Anyway, I think the answer to all of this is "passing negative numbers to at_pos is a bad idea" :)

[12:23] <jnthn> Yeah.

[12:23] <nwc10> doctor doctor, it hurts if I do this

[12:23] <nwc10> well, don't do that then

[12:24] <jnthn> Right, it's one of those. Everyday use doesn't run into this since @a[-1] already catches it 

[12:32] *** jurosz joined
[12:43] <arnsholt> r: say "ø".bytes

[12:43] <p6eval> rakudo a3869a: OUTPUT«No such method 'bytes' for invocant of type 'Str'␤  in block  at /tmp/soOR_c1cPr:1␤␤»

[12:44] <arnsholt> Oh, durr. Of course there's no .bytes in Str

[12:44] *** jurosz is now known as mj41

[12:51] <arnsholt> moritz: I want a DB that is an object store, rather than a relational one =)

[12:57] <arnsholt> timotimo: You're just timo on GitHub right?

[12:58] <moritz> arnsholt: if that DB supports SQL-like queries, schemas and transactions, I'm all for it :-)

[12:59] <arnsholt> Yeah, that's always been the problem IIRC

[13:09] <moritz> I honestly don't understand the "schemaless" approach. For most applications the code has to make assumptions on the structure of the data (and if not, a simple key/value store is likely sufficient)

[13:10] <moritz> I mean, I like duck typing in my code, but in the data it always felt way more dangerous

[13:11] <moritz> if I have made a type error that wasn't caught due to duck typing, I fix it an recompile. Done. But when I made type errors in the data (that weren't caught because of lack of a schema), then recompiling my code isn't enough to rectify the problem

[13:13] <jnthn> I think having a schema *somewhere* is good, the issues arise when you end up with it in two places or zero places. If you're working in a language that guides you to specify types statically, then that serves as a kind of schema and thus keeping it sync'd with a SQL server's view of the schema is the pain point. In a more dynamic language, you don't get that duplication.

[13:14] <jnthn> In other words, if you have yoru schema defined/statically checked in code, then a schemaless store can still be pretty safe.

[13:14] <moritz> well, if your language is statically typed, and you change the types, you must still take care of migrating the data

[13:15] <jnthn> Sure, but you gotta take care of what when changing any schema :)

[13:16] <jnthn> Granted, if the same thing owns the data and the schema then that can make things easier. 

[13:17] <moritz> so we'd really need some way that the data store and the application can automatically sync or check their data models

[13:19] <jnthn> One approach (being used fairly well on some $dayjob client I sometimes do stuff with) is to specify the migrations in code. The database is given a version number; if at application startup the version is incorrect, it applies the changes.

[13:19] *** not_gerd left
[13:20] <moritz> that sounds sane

[13:20] <moritz> which basically means that the application has a model layer which is the only thing ever allowed to write to the database

[13:42] *** pupoque joined
[13:47] *** fijal joined
[13:51] <fijal> hi

[13:52] <arnsholt> 'lo fijal 

[13:53] <arnsholt> jnthn: I think that's the RoR way (or at least possible to do in RoR)

[13:54] <fijal> jnthn: hi, I think RaceConditions hinted me that you might want to have some questions about PyPy

[13:54] <jnthn> arnsholt: Perhaps so. This was a .Net shop. :)

[13:54] <fijal> but maybe I misunderstood

[13:58] <jnthn> fijal: Don't have anything just yet. At the moment I'm working on a JVM backend for NQP, but at least half the work is actually spotting the leftover places where things were coupled too tightly to Parrot. I'm interested in targeting more things in the future, I'm open to looking at PyPy, but my plate is a bit too full to think about that right now. :)

[13:58] <arnsholt> jnthn: Yeah, I figured they might be =)

[13:59] <jnthn> arnsholt: Yes, there's LOADS of .Net here in Sweden :)

[13:59] <jnthn> So I encounter it a lot.

[14:00] <fijal> jnthn: ok

[14:00] <fijal> jnthn: I can also tell you why JVM is a bad idea, but I'm not sure you're interested in hearing that

[14:01] <arnsholt> Yeah, I suspect there's a fair bit of .Net this side of the border as well, 'cept I don't see a lot of it, being in academia and all

[14:01] <jnthn> fijal: It's not really about good/bad ideas, it's about trade-offs.

[14:01] <fijal> well, JVM is a bad platform for dynamic languages

[14:01] <fijal> compared to e.g. writing an interpreter in C

[14:02] <jnthn> What makes it especially bad?

[14:02] <fijal> it's too tied to java

[14:02] <fijal> RPython is a much better choice (but you would expect me to say that)

[14:03] <jnthn> :)

[14:04] <fijal> but they told you a lot of lies

[14:04] <fijal> of course it always depends

[14:04] <fijal> but building stuff in RPython is both easier and gives you a better result

[14:05] <geekosaur> having been at least on the soutskirts of several projects trying to use the jvm for not-java, I can vouch for that to some extent; if it's not a java feature, it's porly supported and may require a lot of hackery

[14:05] <geekosaur> *poorly

[14:06] <jnthn> OTOH, Java doesn't do much, and as a result the JVM doesn't really do a great deal either. There is something to be said for having a small number of primitves and doing them really fast. OTOH, there are places where the fact the VM doesn't directly provide what's needed makes it hard to do well and/or impossible to get as fast as a VM that did offer the thing natively.

[14:06] <fijal> well

[14:06] <fijal> but I claim we solved this

[14:09] <fijal> and your performance expectations are a bit off probably

[14:09] <fijal> because say jruby puts lots and lots of effort working around java limitations

[14:09] <fijal> or JVM

[14:09] <jnthn> My performance expectations are "better than Parrot". I think we'll get that. :)

[14:10] <geekosaur> there is that...

[14:10] <fijal> hehe

[14:10] <fijal> ok

[14:10] <fijal> but then, why JVM?

[14:10] <fijal> and of course why not PyPy?

[14:11] <geekosaur> I think someone's poking at pypy (inspired by topaz) --- but the jvm is there and widely deployed

[14:12] <fijal> as is posix...

[14:12] <moritz> POSIX doesn't come with a GC and JIT compiler

[14:12] *** PacoAir joined
[14:12] <geekosaur> from my* pov there's a smallish gap petween parrot and pypy due to deployment issues, and a much larger gap between those and clr/jvm

[14:12] <fijal> moritz: pypy does

[14:12] <moritz> fijal: yes, but POSIX doesn't.

[14:12] <fijal> geekosaur: er, I think you're missing the point

[14:13] <jnthn> Partly familiarity, partly that I think there should be the option to use some kind of Perl on the JVM, partly because it has a real-world-tested threads implementation and we need to get our story straight on those.

[14:13] <geekosaur> and I hink *you* just missed the point

[14:13] <fijal> geekosaur: pypy does compile stuff to native executable

[14:13] <fijal> there is no "deployment problem"

[14:13] <geekosaur> oh, youre stuck on performance

[14:13] <moritz> fijal: parrot is also used on POSIX systems, but it's not widely deployed either

[14:13] <geekosaur> that's not the deployment problem

[14:13] <geekosaur> let me rephrase that:  how many people even know about pypy?

[14:13] <fijal> moritz: you need parrot to run stuff though, right?

[14:13] <geekosaur> vs. how many know about the jvm and use it daily?

[14:14] <fijal> geekosaur: why do you care?

[14:14] <geekosaur> ...

[14:14] <fijal> geekosaur: if you get an executable that's posix-compliant?

[14:15] <fijal> as in it's not the same

[14:15] <geekosaur> hello, perl6 is already seen as being backed into a pointless niche.  rebasing on *another* niche VM is not helpful

[14:15] <fijal> you don't write a compiler to pypy bytecode that requires deployment

[14:15] <fijal> you write an interpreter in RPython that's different

[14:15] *** PacoAir left
[14:16] *** erkan left
[14:16] *** PacoAir joined
[14:16] <geekosaur> there is a marketing issue here; I'm going to guess you don't see why that has any significance (and tbh that means you're part of the problem in some sense)

[14:16] <fijal> jnthn: I think perl on JVM is honestly not very helpful, but fair enough

[14:16] <moritz> why shouldn't it be helpful?

[14:16] <fijal> jnthn: as python on JVM for example has ever seen adoption from java programmers and not from python progammers

[14:17] <moritz> what's wrong with that?

[14:17] <fijal> geekosaur: you mean "wrote on JVM" adds you marketing boost?

[14:17] <jnthn> fijal: "only ever"?

[14:17] <fijal> jnthn: ?

[14:17] <geekosaur> perl6 needs any boost it can get.  seriously

[14:17] <moritz> and running on java-only mobile phones is certainly a big plus

[14:17] <jnthn> fijal: "python on JVM for example has ever seen adoption" - did you mean "only ever" or did you typo "never"? :)

[14:17] <fijal> ah

[14:18] <fijal> jnthn: only Java using people ever used python on JVM

[14:18] *** Gwyxx joined
[14:18] <fijal> as in, noone moved from CPython to Jython

[14:18] <fijal> but there are some users as a way to script JVM

[14:18] <fijal> sure

[14:18] <fijal> geekosaur: I'm not sure JVM is cool enough any more honestly, but well

[14:18] <geekosaur> "vm that everyone knows about and exists everywhere" is kinda necessary to counter the years of "parrot wtf".

[14:18] <geekosaur> cool doesn't really enter into it

[14:19] <_sri> JRuby is a better example for success with the JVM

[14:19] <geekosaur> you're thinking like a geek.  that's not sufficient

[14:19] <fijal> geekosaur: I personally think that building on a technology that's "cool" these days would give you some boost

[14:19] <fijal> but well

[14:19] <fijal> it'\s a matter of opinion

[14:19] <fijal> _sri: yes

[14:20] <geekosaur> again, you're thinking like a geek.  and again, that's not sufficient

[14:20] <moritz> also, scala and clojure

[14:21] <moritz> just to name two more non-java languages on the JVM

[14:21] <fijal> well yeah

[14:22] <fijal> aren't geeks the target audience?

[14:22] <fijal> anyway

[14:23] <fijal> of course I don't have any way to convince you what you should do in the free time

[14:23] <_sri> the JVM is as close to a "you won't get fired for choosing this" option for VMs as it gets

[14:23] <moritz> then please stop doing so

[14:23] <fijal> moritz: ok, goodbye

[14:23] *** fijal left
[14:23] *** Patterner left
[14:23] * moritz waves

[14:24] *** fijal joined
[14:24] *** fijal left
[14:24] <jnthn> Just to be clear: the way this is being done is *adding* the JVM support as an extra backend, just like we were able to add the debugger as a different frontend. It's not like I'm saying "we'll only run on the JVM forever" or even "we're going to now tie ourselves to the JVM". I'm saying the JVM is where we're going as the first non-Parrot thing.

[14:24] <jnthn> Unless pmurias beats me to it with the JS work ;)

[14:24] <jnthn> ah, he left.

[14:24] *** Psyche^ joined
[14:24] *** Psyche^ is now known as Patterner

[14:25] <moritz> sorry 'bout that. I thought he wanted to discuss technical merits, not just convince us

[14:25] *** stevan_ joined
[14:25] *** jaldhar joined
[14:26] <jnthn> Well, I'm mostly convinced by technical merit, so... :)

[14:29] *** stevan_ left
[14:31] <rindolf> Hi jnthn , moritz 

[14:31] <jnthn> o/ rindolf 

[14:32] <nwc10> bother, I missed fijal. I know I can /msg him

[14:32] <rindolf> jnthn: what's up?

[14:32] <jnthn> rindolf: Not much. It's the weekend, I'm trying to remember to relax as well as hack on stuff ;)

[14:39] *** Chillance joined
[14:40] *** fgomez left
[14:45] *** pmurias joined
[14:46] <[Coke]> (why the jvm) - because then I can run perl6 at a work, since I have to run things inside a j2ee container. :)

[14:48] <nwc10> it's that sort of thing that makes that JVM a politically useful target, even if it's not the best from a technical perspective

[14:49] *** erkan joined
[15:20] *** b1rkh0ff joined
[15:21] *** SunilJoshi joined
[15:22] <timotimo> arnsholt: i am indeed "timo" on github

[15:23] *** benabik left
[15:23] *** benabik joined
[15:27] <arnsholt> Excellent. I've added you as a collaborator to the repo =)

[15:29] <arnsholt> Hmm. ufo generates a circular dependency for Net::ZMQ

[15:30] <moritz> arnsholt: that usually happens if there's a "use"-statement in the pod

[15:30] <moritz> in one of the pods, at least

[15:31] <arnsholt> I don't have any POD

[15:32] <moritz> hm

[15:37] <arnsholt> Could be that I've actually put in a circular use chain

[15:37] <arnsholt> Indeed I have =D

[15:38] <arnsholt> Thought I'd tested that before running ufo

[15:38] <arnsholt> Oh, derp. Think I know what I did

[15:39] <moritz> ufo prevails!

[15:40] <arnsholt> Indeed =)

[15:46] <timotimo> so, is there a test suite that we can adapt from somewhere? i suppose a few simple tests can be written that create inproc sockets and send some stuff around?

[15:47] <arnsholt> In-process might work

[15:47] <arnsholt> I was going to see what ZMQ::LibZMQ2 on CPAN did for its testsuite to get inspiration

[15:48] <arnsholt> But I'm also dangerously close to doing some more NQP/dyncall hacking

[15:48] <arnsholt> Our string handling ATM kind of sucks

[15:51] *** marloshouse left
[15:54] <moritz> r: my int4 $x = 1; for 1..10 { $x = $x * 2; say $x }

[15:54] <p6eval> rakudo a3869a: OUTPUT«2␤4␤8␤16␤32␤64␤128␤256␤512␤1024␤»

[15:56] <moritz> have any of rakudo's small-int types adopted to benefit from the REPR changes?

[15:57] *** marloshouse joined
[15:57] <jnthn> Well, it's more that the lexical handling ain't updated yet

[15:58] <moritz> so it might work as an attribute?

[15:58] <jnthn> Yeah

[15:58] <arnsholt> It should work as an attribute I think

[15:58] <arnsholt> Or at least, it did work as an attribute at some point during my branch =)

[15:59] <moritz> r: class A { has int8 $.x; method doit { for ^16  { $!x = $!x * 2; say $!x } }; A.new(x => 1).doit

[15:59] <p6eval> rakudo a3869a: OUTPUT«===SORRY!===␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/GsjRTgfV_u:1␤------> $!x * 2; say $!x } }; A.new(x => 1).doit⏏<EOL>␤    expecting any of:␤        method arguments␤        postfix␤        infix o…

[15:59] <moritz> r: class A { has int8 $.x; method doit { for ^16  { $!x = $!x * 2; say $!x } } }; A.new(x => 1).doit

[15:59] <p6eval> rakudo a3869a: OUTPUT«Cannot assign to a non-container␤  in block  at src/gen/CORE.setting:769␤  in method BUILDALL at src/gen/CORE.setting:752␤  in method bless at src/gen/CORE.setting:742␤  in method new at src/gen/CORE.setting:727␤  in block  at /tmp/NMlB46N9AC:1␤␤»

[16:00] <moritz> r: class A { has int8 $!x = 2; method doit { for ^16  { $!x = $!x * 2; say $!x } } }; A.new(x => 1).doit

[16:00] <p6eval> rakudo a3869a: OUTPUT«Cannot assign to a non-container␤  in block  at src/gen/CORE.setting:797␤  in method BUILDALL at src/gen/CORE.setting:752␤  in method bless at src/gen/CORE.setting:742␤  in method new at src/gen/CORE.setting:727␤  in block  at /tmp/cAixnkgtbt:1␤␤»

[16:00] <moritz> r: class A { has int8 $!x = 2; method doit { for ^16  { $!x = $!x * 2; say $!x } } }; A.new.doit

[16:00] <p6eval> rakudo a3869a: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[16:00] <moritz> r: class A { has int8 $!x = 2; method doit { $!x = 1; for ^16  { $!x = $!x * 2; say $!x } } }; A.new.doit

[16:00] <p6eval> rakudo a3869a: OUTPUT«2␤4␤8␤16␤32␤64␤-128␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[16:01] <moritz> bumpy ride, but got there eventually :-)

[16:02] *** Energy joined
[16:02] <arnsholt> Yeah, the lack of containers on natives is a bit annoying as well

[16:05] *** Energy left
[16:07] *** stevan_ joined
[16:29] <arnsholt> timotimo: The API is ZMQ 2.x, BTW (since that's what my Ubuntu had on tap)

[16:31] *** Aka2 joined
[16:31] <timotimo> ah

[16:33] <arnsholt> Hopefully that's manageable

[16:33] <arnsholt> Or does ipython use ZMQ3?

[16:38] <timotimo> i think it supports both, but i'm not sure. let me have a look.

[16:39] <arnsholt> I want to support ZMQ3 as well, but the ZMQ2 API is smaller, so I'd like to get a handle on that first, and then start looking at ZMQ3

[16:40] <timotimo> mhm

[16:42] <timotimo> apparently they require >= 2

[16:42] <timotimo> 2.1.11 is their minimum version at this time

[16:43] <arnsholt> That's the the exact version Ubuntu ships, so excecllent =)

[16:45] <timotimo> coincidence? :)

[16:45] * timotimo builds a fresh rakudo

[16:47] <timotimo> with an nqp from master, hell yeah bleeding edge :))

[16:49] <jnthn> You should see how bleeding my local one is :P

[16:49] <timotimo> :3

[16:51] <timotimo> make: *** [NQPP5QRegex.pbc] Segmentation fault

[16:51] <timotimo> well, that was surprising

[16:51] <jnthn> Try a make clean :)

[16:51] <timotimo> sure

[16:53] <jnthn> I had to do that a couple of times yesterday. I suspect a missing Makefile dep somewhere, but didn't spot it.

[16:57] *** awwaiid left
[16:58] <timotimo> huh, make clean wasn't clean enough it seems

[16:58] <timotimo> maybe i need a newer parrot, too?

[16:58] <jnthn> No

[16:58] <moritz> rakudo compilation still segfaults for me :(

[16:59] * timotimo git clean'd

[16:59] <jnthn> :/

[16:59] <moritz> I've tried to run it under gdb, but it seemed to hang

[16:59] <moritz> I aborted after a few minutes

[17:03] *** uvtc joined
[17:03] <timotimo> git clean helped it seems

[17:03] <timotimo> er, no

[17:03] <timotimo> three seconds after i said that, it exploded :))

[17:06] <arnsholt> No segfault on NQP HEAD here

[17:07] <arnsholt> But failures in the test suite, it seems

[17:07] * timotimo deleted nqp, parrot and install folders

[17:08] <arnsholt> Segfault before first test but after plan in t/nqp/60-bigint.t and segfault after test 71 in t/qast/qast.t, as well as failure of test 19 (which is bigint-related)

[17:09] * arnsholt tries HEAD^

[17:11] <pmichaud> good morning, #perl6

[17:11] <arnsholt> 'lo pmichaud 

[17:11] <moritz> good am, pm

[17:11] <jnthn> arnsholt: That one I had to kill with a properly clean

[17:11] <jnthn> It's something to do with not getting a proper bigint ops rebuild.

[17:12] <jnthn> s/properly/proper/

[17:12] <jnthn> o/ pmichaud 

[17:12] <arnsholt> Aha

[17:14] <FROGGS> hi pmichaud, hi all

[17:15] <dalek> nqp/rx-portability: f5d0a8b | jnthn++ | / (5 files):

[17:15] <dalek> nqp/rx-portability: Stub in an NFA representation.

[17:15] <dalek> nqp/rx-portability: 

[17:15] <dalek> nqp/rx-portability: We'll keep it in the current form for construction; this is what we'll

[17:15] <dalek> nqp/rx-portability: feed to the executor and also serialize them as.

[17:15] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/f5d0a8bb2c

[17:15] <dalek> nqp/rx-portability: ecc5234 | jnthn++ | src/QAST/Operations.nqp:

[17:15] <dalek> nqp/rx-portability: Sketch in some nqp:: ops for NFA handling.

[17:15] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/ecc523421f

[17:15] <dalek> nqp/rx-portability: ce1308b | jnthn++ | src/stage0/ (9 files):

[17:15] <dalek> nqp/rx-portability: Update bootstrap to get nqp::ops.

[17:15] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/ce1308b279

[17:15] <dalek> nqp/rx-portability: b027079 | jnthn++ | src/ (3 files):

[17:15] <dalek> nqp/rx-portability: Implement various NFA ops.

[17:15] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/b0270790c4

[17:15] <dalek> nqp/rx-portability: 5980aa5 | jnthn++ | src/QRegex/NFA.nqp:

[17:15] <dalek> nqp/rx-portability: Start using new NFA REPR and ops.

[17:15] <dalek> nqp/rx-portability: 

[17:15] <dalek> nqp/rx-portability: Avoids doing a lot of v-table calls while evaluating the NFA (can do a

[17:15] <dalek> nqp/rx-portability: bit more improvement yet also). This should also help ease NFA porting,

[17:15] <dalek> nqp/rx-portability: plus it's good to get this cleared up before porting things.

[17:15] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/5980aa50aa

[17:15] <arnsholt> jnthn: Cheers. That fixed it

[17:16] <jnthn> moritz: Does make test in NQP look good to you?

[17:16] <moritz> jnthn: I'm rebuilding from scratch now, so will tell you when I get there again :-)

[17:16] <jnthn> ok :)

[17:17] <timotimo> hm, i wonder if i had been running parrot 5 at the time nqp segfaulted when trying to build

[17:18] <timotimo> because now it looks like i've gotten to rakudo, with --gen-parrot

[17:23] <uvtc> Oh, interesting. The Parrot history I was asking about last night was re-asked by cotto on #parrot, and allison had some comments on it.

[17:24] <pmichaud> I guess I should go read the logs.  :-)

[17:24] <uvtc> Oh, hi pmichaud .

[17:25] <timotimo> /home/timo/build/rakudo/install/bin/nqp --target=pir --output=src/gen/perl6-bootstrap.pir --encoding=utf8 \ --vmlibs=perl6_ops src/gen/BOOTSTRAP.pm

[17:25] <timotimo> get_pmc_keyed_str() not implemented in class 'ResizablePMCArray'

[17:25] <timotimo> is this known?

[17:26] <jnthn> No

[17:27] <jnthn> Can you gist me the entire output?

[17:27] <timotimo> sure

[17:27] <timotimo> http://paste.ee/p/kIgEB

[17:28] <timotimo> oh, hold on

[17:28] <timotimo> i think that got corrupted

[17:29] <pmichaud> moritz++ # comments on #parrot and rakudo/parrot merge

[17:30] <timotimo> http://paste.ee/p/Cehwq - there you go

[17:31] <jnthn> timotimo: Whoa

[17:31] <jnthn> timotimo: What Rakudo sha1 and what nqp sha1 are you building?

[17:32] <timotimo> Sonoma-93-g14c9305 - rakudo | nqp - 2013.01-143-g26d0d0f

[17:32] <jnthn> Because that looks exactly like a Rakudo speaking a previous version of the repr compose protocl...

[17:32] <jnthn> 2013.01-113-ga3869a0

[17:33] <jnthn> That is my Rakudo

[17:33] <timotimo> i *thought* i had git pull'd rakudo just before i did that.

[17:33] <timotimo> oh, yeah, i was on the constant-folding branch

[17:33] <timotimo> that was clever

[17:33] <jnthn> oops :)

[17:34] <jnthn> And also, phew. That error could have meant something a lot wrose if it had happened in a difference place.

[17:34] <timotimo> yes, excuse me for causing a state of nationwide panic in johnathantown :)

[17:34] <jnthn> np :)

[17:38] <jnthn> shop, dinner, etc :)

[17:40] <timotimo> rakudo succeeded to build now :)

[17:42] *** WAAMX10 joined
[17:46] <timotimo> arnsholt: any way to implement the ipython heartbeat socket? it's supposed to run asynchronous to the program. (except for of course q:x'ing another rakudo...)

[17:46] <arnsholt> Not really, I think

[17:46] <arnsholt> For that we really want threads

[17:46] <timotimo> yes, we do

[17:48] <arnsholt> jnthn: Using the set/get_int REPR hooks to deal with the length of a C string buffer: acceptably eww, or "don't go there" eww?

[17:56] *** ponbiki left
[18:00] *** SunilJoshi left
[18:02] <jnthn> arnsholt: That's...wrong.

[18:02] <arnsholt> Yeah, I know =)

[18:02] <jnthn> Those are for boxing/unboxing only :)

[18:02] <arnsholt> Won't do that, then

[18:03] <arnsholt> Doodling around with the best ways to implement a CStr REPR as outlined in the gist I made a while back

[18:07] *** ponbiki joined
[18:08] *** ponbiki is now known as Guest20810

[18:19] <moritz> jnthn: after git clean -dxf in both rakudo and nqp, nqp's 'make test' and rakudo's build succeeded again

[18:23] <jnthn> moritz: Phew. :) I wouldn't mind trying to figure out what we're missing.

[18:31] *** Aka2 left
[18:34] <nwc10> bother - does an "is rw" subroutine have to "fall off the end" to work? (ie, be able to assign to the returned lvalue)

[18:35] *** SunilJoshi joined
[18:36] <moritz> nwc10: no, you can return-rw

[18:37] <nwc10> excellent!

[18:37] <moritz> r: my $x = 42; sub f() is rw { return-rw $x };  f() = 23; say $x

[18:37] <p6eval> rakudo a3869a: OUTPUT«23␤»

[18:38] <moritz> it's kind of a design smell, to have both return and return-rw. But normal people(tm) exepct return to decontainerize

[18:46] *** ObseLeTe joined
[18:50] * colomon has never used return-rw

[18:51] <benabik> Why doesn't return just do return-rw inside sub is rw?

[18:51] <moritz> benabik: because return isn't simply lexically scoped

[18:51] <benabik> oy

[18:54] <benabik> ...  Wait

[18:54] <benabik> What kind of scoping does it use then?

[18:56] <benabik> Or is this "mostly lexically scoped, but can be altered because it's all exceptions"?

[19:00] <moritz> yes

[19:08] * jnthn back from le dinner :)

[19:08] <nwc10> was it good?

[19:09] <jnthn> It involved bacon. ;)

[19:09] <jnthn> And white wine.

[19:09] <jnthn> And cream and mushrooms and stuff. 

[19:09] <jnthn> So yeah, pretty good ;)

[19:10] <colomon> bacon++

[19:11] <moritz> sounds diverse and tasty :-)

[19:25] *** ObseLeTe left
[19:28] <alec__> spaghetti carbonara?

[19:33] <uvtc> alec__: Is that a pun about the old pre-Cocoa Mac OS interface? :)

[19:33] *** pyrimidine joined
[19:33] <jnthn> alec__: Not really...no eggs or cheese in what I did :)

[19:34] * alec__ has a policy of letting you believe he's clever whenever something he says happens to be funny like that, uvtc

[19:34] <alec__> i see, jnthn

[19:48] *** SunilJoshi left
[19:49] *** amkrankruleuen left
[19:59] <jnthn> We call the things CONTROL catches control exceptions...do we have a name for the non-control ones (besides non-control :))?

[20:03] <moritz> errors? :-)

[20:03] <moritz> ordinary exceptions?

[20:08] <nwc10> regular socials?

[20:20] *** brrt joined
[20:21] <colomon> they'd be more popular if they were ice cream socials.

[20:29] <masak> (by symmetry, they should be called 'catch exceptions'.)

[20:29] <masak> hi, #perl6

[20:30] *** fgomez joined
[20:31] *** domidumont left
[20:34] <brrt> hi masak

[20:39] *** kaare_ left
[20:48] <colomon> o/

[20:50] <moritz> \o masak 

[20:52] *** ggoebel_ joined
[20:54] *** spider-mario joined
[21:19] *** pyrimidine left
[21:20] *** pyrimidine joined
[21:27] *** thou joined
[21:29] *** brrt left
[21:40] *** xdbr left
[21:40] * [Coke] starts ripping things out at https://github.com/coke/parrot . only something small so far.

[21:40] <[Coke]> Every PMC I've tried so far is actually used internally somewhere. ;)

[21:53] *** lizmat is now known as Liz

[21:53] *** Liz is now known as lizmat

[21:56] <pmurias> [Coke]: what would be the benefit of that? easier maintenance?

[21:57] <[Coke]> pmurias: parrot has a lot of stuff rakudo isn't using. Maybe rakudo will go faster on a parrot that doesn't have them.

[21:57] <[Coke]> Or have a smaller footprint, or..

[21:57] <[Coke]> or, at least, build faster.

[21:58] *** dbr joined
[22:02] *** pupoque left
[22:03] *** dbr left
[22:03] *** dbr joined
[22:06] *** pupoque joined
[22:07] <uvtc> [Coke]++

[22:08] <masak> (build faster)++

[22:08] *** PacoAir left
[22:09] *** pyrimidine left
[22:09] *** pupoque left
[22:31] *** pyrimidine joined
[22:31] *** MikeFair_ joined
[22:32] *** rindolf left
[22:33] *** spider-mario left
[22:37] *** proller left
[22:44] *** bluescreen100 left
[23:02] <dalek> nqp/rx-portability: 5ecc011 | jnthn++ | src/ (3 files):

[23:02] <dalek> nqp/rx-portability: Add nqp::const mechanism.

[23:02] <dalek> nqp/rx-portability: 

[23:02] <dalek> nqp/rx-portability: Allows mapping constants in a backend-independent way.

[23:02] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/5ecc0110f6

[23:02] <dalek> nqp/rx-portability: b7756b5 | jnthn++ | src/stage0/ (9 files):

[23:02] <dalek> nqp/rx-portability: Update bootstrap.

[23:02] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/b7756b57f2

[23:02] <dalek> nqp/rx-portability: 081a30f | jnthn++ | src/QRegex/ (2 files):

[23:02] <dalek> nqp/rx-portability: Lots of pir:: => nqp:: in NFA and Cursor.

[23:02] <dalek> nqp/rx-portability: review: https://github.com/perl6/nqp/commit/081a30fde7

[23:06] *** pyrimidine left
[23:07] *** pjcj left
[23:09] *** pjcj joined
[23:12] *** alester joined
[23:32] <masak> 'night, #perl6

[23:37] *** MikeFair_ left
[23:38] *** pyrimidine joined
[23:42] *** alester left
[23:48] * jnthn rests also...'night

[23:49] <colomon> o/

