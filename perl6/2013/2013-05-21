[00:12] *** kurahaupo left
[00:13] *** btyler joined
[00:14] *** ccc joined
[00:17] *** rindolf left
[00:17] *** Chillance left
[00:19] *** kurahaupo joined
[00:23] *** nwc10 left
[00:26] *** arlinius left
[00:29] *** ajr joined
[00:30] *** ajr is now known as Guest87677

[00:30] *** xinming left
[00:31] *** adu joined
[00:32] *** xinming joined
[00:33] *** berekuk left
[00:34] *** nwc10 joined
[00:36] *** Guest87677 left
[00:38] *** skids left
[00:39] *** ajr_ joined
[00:42] *** ajr_ left
[00:46] *** Timbus|Away joined
[00:46] *** Timbus left
[00:46] *** Timbus|Away is now known as Timbus

[00:53] *** chrisdev_ left
[00:54] *** lustlife joined
[00:55] *** chrisdev joined
[00:55] *** chrisdev left
[01:00] *** skids joined
[01:02] *** japhb_ left
[01:08] *** anuby joined
[01:13] *** arlinius joined
[01:20] *** btyler left
[01:24] *** btyler joined
[01:41] *** tgt left
[01:52] *** FROGGS_ joined
[01:56] <ehouse> anyone around who could help me with my panda setup?

[01:57] *** FROGGS left
[02:02] <ehouse> I tried a setup with a local install of perl6 and still no luck. Still having issues with the .work file

[02:04] *** gdey left
[02:04] <timotimo> ehouse: how did you install perl6 system-wide? just set the prefix to / when configuring?

[02:05] <ehouse> timotimo: I meant to say it was install as a package instead of compiling in my homedir

[02:05] <timotimo> oh, a package?

[02:05] <timotimo> how recent was that package?

[02:06] <ehouse> perl6 version 2013.01 built on parrot 5.0.0 revision 0

[02:07] <ehouse> panda I pulled from github on both installs

[02:07] <timotimo> ah, that's kind-of-sort-of recent

[02:07] <timotimo> especially considering there were 2 months without releases i believe

[02:08] <ehouse> I also tried perl6 version 2013.04-74-g14e7d74 built on parrot 5.2.0 revision RELEASE_5_2_0. Same error from panda

[02:08] <timotimo> it seems like panda uses a temporary directory to do all its things before installing

[02:08] <timotimo> at what step does it fail?

[02:09] <timotimo> oh, i'm locally on the panda2 branch

[02:09] *** tgt joined
[02:10] <timotimo> ah, that's what .work is!

[02:10] <timotimo> the sub tmpdir is implemented thusly: ".work/{time}_{$i++}"

[02:10] <timotimo> it would seem like it tries to do its work under the CWD

[02:11] <ehouse> http://pastebin.com/v96rQ4cm

[02:11] <timotimo> ah, looked wrong.

[02:12] <timotimo> ah, yes

[02:12] <timotimo> it seems like that rm_rf is not proper.

[02:13] <timotimo> it will try to rm_rf .work in any case, even if it did nothing to provoke creation of such a folder (like display the usage or search for projects)

[02:13] *** prevost left
[02:14] <timotimo> ehouse: did you try actually installing something?

[02:15] <timotimo> i can reproduce the error, btw

[02:15] <ehouse> wow I feel like a derp

[02:16] <ehouse> well I can install packages fine. --list just doesn't work

[02:16] <timotimo> hehehe :)

[02:17] <timotimo> i'll look into fixing that problem

[02:17] <timotimo> probably will just have to check .work for existance before rm_rf-ing it

[02:17] <ehouse> should I submit a bug report on the github page?

[02:17] <ehouse> also should't rm -f swallow errors?

[02:18] <timotimo> i suppose it depends on what it tries to mimic

[02:19] <timotimo> oh, *weird*

[02:19] <timotimo> https://github.com/tadzik/perl6-File-Tools/blob/master/lib/Shell/Command.pm#L27 - it actually should only delete if the directory exists

[02:19] *** yoleaux left
[02:20] *** yoleaux joined
[02:20] <timotimo> oh, no

[02:20] <timotimo> it checks for directory-ness. if it's not a directory (i.e. if it doesn't exist) it just tries to unlink

[02:22] *** btyler left
[02:22] <timotimo> i made a pull request :)

[02:23] <ehouse> thanks timotimo 

[02:23] <timotimo> you're welcome

[02:24] <timotimo> are you new to perl6?

[02:24] *** chrisdev joined
[02:25] <ehouse> yeah

[02:25] <timotimo> welcome to perl6 then :)

[02:26] *** prevost joined
[02:26] <ingy> does p6rules allow (| a | b) to mean (a | b) ?

[02:26] <TimToady> yes

[02:26] <timotimo> same with ||, too i believe

[02:27] <ingy> cool, just added to Pegex. don't want to move away from p6rules :)

[02:27] *** tgt left
[02:29] <ingy> TimToady: headed to austin?

[02:29] <TimToady> planning to

[02:29] <ingy> great!

[02:29] *** hlin_ left
[02:29] <ingy> will be good to see you

[02:33] *** hypolin joined
[02:38] *** chrisdev left
[02:45] *** ifim joined
[03:01] *** btyler joined
[03:20] *** perigrin_ joined
[03:25] *** jlaire left
[03:37] *** daniel-s_ joined
[03:40] *** daniel-s left
[03:42] *** jlaire joined
[03:42] *** btyler left
[03:46] <dalek> roast: 3fe5dba | (Brent Laabs)++ | / (3 files):

[03:46] <dalek> roast: moved slurp.t to S32-io, more tests, remove request from TODO

[03:46] <dalek> roast: review: https://github.com/perl6/roast/commit/3fe5dba0f2

[03:48] *** SamuraiJack joined
[03:58] *** preflex left
[04:00] *** preflex joined
[04:06] *** SamuraiJack left
[04:08] *** Timbus left
[04:08] *** Timbus joined
[04:09] *** ccc left
[04:25] *** Psyche^ joined
[04:29] *** Patterner left
[04:29] *** Psyche^ is now known as Patterner

[04:34] *** ingy left
[04:34] *** ingy joined
[04:36] *** adu left
[04:37] *** adu joined
[04:49] *** gdey joined
[04:53] *** zby_home_ joined
[04:54] *** dayangkun joined
[04:54] *** dayangkun left
[05:11] *** ifim left
[05:15] *** xinming left
[05:16] *** xinming joined
[05:17] *** ifim joined
[05:17] *** ifim left
[05:22] *** kurahaupo left
[05:23] *** GlitchMr left
[05:23] *** bruges_ joined
[05:24] *** bruges left
[05:25] *** GlitchMr joined
[05:25] *** adu left
[05:26] <ingy> what is the compilation unit form of perl6?

[05:27] <ingy> is there a standard one?

[05:27] <ingy> the bytecode, as it were…

[05:27] *** nyuszika7h left
[05:28] <ingy> pir for rakudo?

[05:29] *** nyuszika7h joined
[05:32] *** kurahaupo joined
[05:39] *** domidumont joined
[05:43] *** dmol joined
[05:43] *** GlitchMr left
[05:47] *** Heather joined
[05:47] <Heather> tadzik hi

[05:48] <Heather> tadzik I saw some strange stuff in last commits

[05:48] *** GlitchMr joined
[05:56] <Heather> ah... it's panda 2...

[05:57] *** kurahaupo left
[05:58] *** kurahaupo joined
[05:59] *** domidumont left
[05:59] <Heather> I don't understand the code again

[06:00] *** domidumont joined
[06:01] <timotimo> in S06 it says my |retcap := MULTI-DISPATCH-CALLWITH(&?ROUTINE, cap);  -  i think it should be my $retcap := ... and then return |$retcap instead

[06:01] *** PacoAir joined
[06:02] *** FROGGS_ left
[06:12] *** FROGGS_ joined
[06:16] *** gdey left
[06:17] <timotimo> moritz: it seems like your irclog website is forbidding access to the actual logs :(

[06:17] <timotimo> but the little activity charts look nice :)

[06:17] <FROGGS_> ingy: rakudo compiles down to bpc, and parrot to pir

[06:18] <FROGGS_> timotimo: you say yuo cant see today's log?

[06:18] <timotimo> wow, that was quickly fixed!

[06:18] <timotimo> oooh, it colors days according to the amount of conversation in the calendar overview

[06:18] <FROGGS_> I believe he said he has an access violation rule which hits when you access the site more than 50 times a minute

[06:19] <TimToady> a $ would imply itemization that you don't want to do to a capture, whereas binding to |capture doesn't assume itemization

[06:20] <TimToady> and, of course, rakudo only uses pbc/pir on parrot, not on jvm

[06:20] <FROGGS_> of course

[06:20] <TimToady> it might be more accurate to say that it saves a serialization of its state after compiling a module

[06:21] <FROGGS_> good morning btw

[06:21] *** FROGGS_ is now known as FROGGS

[06:22] *** dmol left
[06:25] <FROGGS> r: say (my $x).^attributes; say (my $y).^methods

[06:25] <camelia> rakudo 14e7d7: OUTPUT«␤eager elems end classify uniq infinite flat hash list lol pick roll reverse sort values keys kv pairs Array grep first join map min max minmax push tree unshift postcircumfix:<[ ]> at_pos all any one none postcircumfix:<{ }> at_key reduce FLATTENABLE_LIST FLATTENA…

[06:25] <FROGGS> is there a way to get the variable name?

[06:30] <timotimo> r: my |foobar := (1, 2, :a(foo)); # TimToady

[06:30] <camelia> rakudo 14e7d7: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/3EoXE3NMeO:1␤------> my ⏏|foobar := (1, 2, :a(foo)); # TimToady␤    expecting any of:␤        scoped declarator␤»

[06:30] <timotimo> did you perhaps mean \foobar instead?

[06:31] <TimToady> std: my |foobar := (1, 2, :a(foo));

[06:31] <camelia> std 8850393: OUTPUT«===SORRY!===␤Malformed my at /tmp/TUQhKCFRw6 line 1:␤------> my ⏏|foobar := (1, 2, :a(foo));␤    expecting any of:␤    name␤   scoped declarator␤Parse failed␤FAILED 00:00 41m␤»

[06:31] <TimToady> std: my (|foobar) := (1, 2, :a(foo));

[06:31] <camelia> std 8850393: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'foo' used at line 1␤Check failed␤FAILED 00:00 46m␤»

[06:32] <TimToady> std: my (|foobar) := (1, 2, :a<foo>);

[06:32] <timotimo> oh?

[06:32] <camelia> std 8850393: OUTPUT«ok 00:00 46m␤»

[06:32] <TimToady> std: my (\foobar) := (1, 2, :a<foo>);

[06:32] <camelia> std 8850393: OUTPUT«ok 00:00 46m␤»

[06:32] <timotimo> r: my (|foobar) := (1, 2, :a<foo>);

[06:32] <camelia> rakudo 14e7d7:  ( no output )

[06:32] <timotimo> i can't tell why it would need that.

[06:32] <TimToady> \foobar only takes the first argument, while |foobar takes a snapshot of the current entire capture being boudn

[06:33] <TimToady> might make no difference in that case

[06:33] <timotimo> i mean the (...) around it

[06:33] *** Heather left
[06:33] <TimToady> |foobar is kind of a signature-level concept, not a parameter-level concept

[06:34] <FROGGS> r: say (my (|foobar)).WHAT

[06:34] <camelia> rakudo 14e7d7: OUTPUT«(Parcel)␤»

[06:34] <TimToady> it might require ::= instead of := to work right, as well

[06:34] *** zby_home_ left
[06:35] <TimToady> maybe not

[06:38] <TimToady> r: my \foo = (1, 2, :a<foo>); say foo.WHAT

[06:38] <camelia> rakudo 14e7d7: OUTPUT«(Parcel)␤»

[06:38] <TimToady> I suspect that's roughly equivalent

[06:39] <timotimo> should i change the spec document then? turn it into a \ or put (...) around it?

[06:39] <TimToady> r: my (|foo) ::= (1, 2, :a<foo>); say foo.WHAT

[06:39] <camelia> rakudo 14e7d7: OUTPUT«===SORRY!===␤Error while compiling block  (source text: "my (|foo) ::= (1, 2, :a<foo>); say foo.WHAT"): Error while compiling op call: Error while compiling block : Error while compiling op call (source text: "say foo.WHAT"): Error while compiling op what (source t…

[06:39] <TimToady> wow

[06:40] <timotimo> yeeks

[06:40] <TimToady> these days my \foo = is probably good enough to avoid spoiling a return value

[06:41] *** GlitchMr left
[06:43] <TimToady> sub foo { my \retval = (1, 2, :a<foo>); return retval }; say foo.item; say foo.list; say foo.hash

[06:43] <timotimo> but the return stays return |retcap, right?

[06:43] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return retval }; say foo.item; say foo.list; say foo.hash

[06:43] <camelia> niecza v24-51-g009f999: OUTPUT«1 2 "a" => "foo"␤1 2 "a" => "foo"␤{"1" => 2, "a" => "foo"}␤»

[06:43] <camelia> ..rakudo 14e7d7: OUTPUT«1 2 "a" => "foo"␤1 2 a    foo␤("1" => 2, "a" => "foo").hash␤»

[06:44] <timotimo> ah, i'll remove the | then.

[06:44] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return |retval }; say foo.item; say foo.list; say foo.hash

[06:44] <camelia> niecza v24-51-g009f999: OUTPUT«1 2 "a" => "foo"␤1 2 "a" => "foo"␤{"1" => 2, "a" => "foo"}␤»

[06:44] <camelia> ..rakudo 14e7d7: OUTPUT«1 2 "a" => "foo"␤1 2 a    foo␤("1" => 2, "a" => "foo").hash␤»

[06:44] <timotimo> uh, are both equally correct?

[06:44] *** GlitchMr joined
[06:45] <TimToady> it would appear that return doesn't turn the pair into a named argument anway

[06:45] <TimToady> *anyway

[06:45] *** domidumont left
[06:45] *** domidumont joined
[06:45] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return retval }; say (\foo).WHAT

[06:45] <camelia> rakudo 14e7d7, niecza v24-51-g009f999: OUTPUT«(Capture)␤»

[06:46] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return retval }; say (\foo).list

[06:46] <camelia> niecza v24-51-g009f999: OUTPUT«1 2 "a" => "foo"␤»

[06:46] <camelia> ..rakudo 14e7d7: OUTPUT«1 2 a     foo␤»

[06:46] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return |retval }; say (\foo).list

[06:46] <camelia> niecza v24-51-g009f999: OUTPUT«1 2 "a" => "foo"␤»

[06:46] <camelia> ..rakudo 14e7d7: OUTPUT«1 2 a     foo␤»

[06:46] <timotimo> does it make a difference that the example in the specs uses :=? probably not, since it calls a function on the right side of that, right?

[06:47] <TimToady> using \ on the left more or less forces binding anyway, since there's no container in the traditional sense

[06:48] <TimToady> nr: sub foo { my \retval = (1, 2, :a<foo>); return retval }; say (\|foo).list

[06:48] <camelia> niecza v24-51-g009f999: OUTPUT«1 2 "a" => "foo"␤»

[06:48] <camelia> ..rakudo 14e7d7: OUTPUT«1 2 a     foo␤»

[06:48] *** woosley joined
[06:48] <timotimo> i can't see a difference between return |retval and return retval; i suppose i'll turn the line into my \retval = ...; and return retval, if that seems right to you

[06:48] *** kurahaupo left
[06:49] <TimToady> I think that's probably okay till someone finds a problem with it :)

[06:49] <TimToady> and it's the simplest thing that (probably) works

[06:50] <dalek> specs: b9679d4 | (Timo Paulssen)++ | S06-routines.pod:

[06:50] <dalek> specs: make a proto example work again.

[06:50] <dalek> specs: review: https://github.com/perl6/specs/commit/b9679d4dbc

[06:51] *** kurahaupo joined
[06:51] *** GlitchMr left
[06:51] <timotimo> FROGGS: access violation rule which hits when you access the site more than 50 times a minute  -  guess how many little pictures there are in the list of channels? :D

[06:53] <timotimo> moritz: ^

[06:53] <moritz> how many? :/

[06:53] <timotimo> 51

[06:53] <moritz> :(

[06:53] <moritz> I really have to exclude them from the access limit

[06:54] <timotimo> btw, do those graphs have the same scaling factor?

[06:54] <moritz> only on the x axis

[06:54] *** GlitchMr joined
[06:54] <moritz> timotimo: please try again

[06:54] <moritz> access limit changed to 100 requests per 40 seconds

[06:55] <timotimo> indeed, now i full-refreshed the page twice and still got almost all the little pictures :)

[06:58] *** kaleem joined
[06:59] *** GlitchMr left
[07:00] <FROGGS> (little pictures)++

[07:02] * TimToady wanders off to watch the little pictures inside his eyelids

[07:03] <moritz> good night, and dream in little pictures :-)

[07:03] <dagurval> r: spurt("/tmp/asdf", "hello"); slurp("/tmp/asdf").say;

[07:03] <camelia> rakudo 14e7d7: OUTPUT«hello␤»

[07:04] <timotimo> ... spurt?

[07:04] <timotimo> wow.

[07:05] <timotimo> well, i guess it isn't much funnier than slurp is ...

[07:05] <dagurval> hehe

[07:05] *** ilbot6 joined
[07:06] <timotimo> moritz: ooc, how often do the little pictures regenerate?

[07:06] *** markov left
[07:06] <moritz> timotimo: currently once per week

[07:07] <timotimo> oh, how long is one pixel in the x coordinate then?

[07:07] * FROGGS .about

[07:07] <FROGGS> -.-

[07:08] *** ilbot6 left
[07:08] * FROGGS .oO( about 1/10th a millimetre? )

[07:08] <FROGGS> I'm too tired to type :/

[07:09] <moritz> r: say (Date.today - Date.new(2005, 2, 26)) / 100

[07:09] <camelia> rakudo 14e7d7: OUTPUT«30.06␤»

[07:09] <moritz> timotimo: about a month

[07:09] <timotimo> oh, wow. okay.

[07:10] <timotimo> fwiw, i could get the size of the first picture down by 60% just by calling optinpg -o7 on it and it took very little cpu time

[07:10] <timotimo> if you do that once per week, it may even pay off :)

[07:10] *** GlitchMr joined
[07:11] *** markov joined
[07:12] <moritz> I guess since it uses only one color, an optimizer can introduce a palette

[07:12] <timotimo> actually

[07:12] <timotimo> it seems like it was a palette before and the optimizer turned into greyscale

[07:13] <timotimo> interesting. i got a "all of these signatures match" from .gist-ing a Pod::Block; i think adding a proto to Pod::Block::Declarator would fix that issue.

[07:14] <timotimo> er

[07:14] <FROGGS> r: sub do_warn ($x) is hidden_from_backtrace { warn "uninitialized" if $x ~~ Any  }; do_warn(my $y)

[07:14] <camelia> rakudo 14e7d7: OUTPUT«uninitialized  in block  at /tmp/ynPhrL6O0i:1␤␤»

[07:14] <timotimo> hold on, why is the signature for Pod::Block::Declarator like this: multi method gist(Pod::Block:D) ... and not Pod::Block::Declarator:D?

[07:14] <FROGGS> how do I put the '$y' in that warning message?

[07:14] <timotimo> (another : at the end, though)

[07:14] <jnthn> That sounds...wrong.

[07:15] <moritz> timotimo: thinko, probably

[07:15] *** sqirrel joined
[07:15] *** GlitchMr left
[07:15] <timotimo> i don't feel like making a pull request. would someone do the honors?

[07:15] <moritz> FROGGS: you don't

[07:15] <jnthn> FROGGS: sub do_warm(\x) { x.VAR.name } # should get the name

[07:15] <moritz> warm? :-)

[07:15] <FROGGS> r: sub do_warn (\x) is hidden_from_backtrace { warn "uninitialized " ~ x.VAR.name if $x ~~ Any  }; do_warn(my $y)

[07:15] <camelia> rakudo 14e7d7: OUTPUT«===SORRY!===␤Variable '$x' is not declared␤at /tmp/X0xBLotdTb:1␤------> warn "uninitialized " ~ x.VAR.name if $x⏏ ~~ Any  }; do_warn(my $y)␤    expecting any of:␤        postfix␤»

[07:15] <jnthn> keys right next to each other...not enough coffee :P

[07:15] <FROGGS> r: sub do_warn (\x) is hidden_from_backtrace { warn "uninitialized " ~ x.VAR.name if x ~~ Any  }; do_warn(my $y)

[07:16] <camelia> rakudo 14e7d7: OUTPUT«uninitialized $y  in block  at /tmp/0yewYQpPbl:1␤␤»

[07:16] <FROGGS> cool

[07:16] <FROGGS> moritz: why not?

[07:16] <moritz> we had such code in the setting; it was a constant PITA, because it kept reporting the wrong variable names

[07:16] * jnthn arrived to teach today and was told "oh, we can't have the room for another half an hour" :)

[07:16] <moritz> like, variable names from within the setting

[07:16] <jnthn> So, more time to wake up...

[07:17] <FROGGS> moritz: hmmm, I want to fake p5's messages, so I'll give it a try

[07:17] <jnthn> Just use \x all over your Perl 5 built-ins :)

[07:18] <FROGGS> hmmm, sounds good

[07:18] *** GlitchMr joined
[07:20] *** fgomez left
[07:20] <dalek> rakudo/nom: 24538fd | (Brent Laabs)++ | t/spectest.data:

[07:20] <dalek> rakudo/nom: update spectest.data to reflect slurp.t file move

[07:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24538fdeb3

[07:22] <dalek> rakudo/nom: c52f15f | moritz++ | src/RESTRICTED.setting:

[07:22] <dalek> rakudo/nom: diasllow spurt in restricted setting, dagurval++

[07:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c52f15f0e2

[07:22] <dalek> rakudo/nom: ad0c3f0 | moritz++ | src/core/Pod.pm:

[07:22] <dalek> rakudo/nom: fix typo in Pod::Block::Declarator.gist signature, timotimo++

[07:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad0c3f07b8

[07:22] *** kurahaupo left
[07:23] *** GlitchMr left
[07:24] <timotimo> thanks moritz :)

[07:27] *** berekuk joined
[07:28] <timotimo> does it seem like a good idea to you to sprinkle the setting with Pod, so that .WHY works on mostly anything in the interpreter?

[07:29] <labster> r: say "/tmp/test3.pl".path.e; link("test3.pl", "/tmp/test3.pl"); say "/tmp/test3.pl".path.e; 

[07:29] <camelia> rakudo 14e7d7: OUTPUT«False␤True␤»

[07:29] *** berekuk left
[07:30] <lizmat> timotimo: sounds like a good idea to me

[07:30] <lizmat> and good morning #perl6!

[07:30] <timotimo> because i've always enjoyed being able to .__doc__ or help(...) stuff in the python repl and it's kind of sad that it's not done the same way in perl6 yet

[07:31] <timotimo> on that same note, how about including a semi-interactive help browser for the repl?

[07:31] <timotimo> pythons help() function is basically an object-or-module pretty-printer with a pager

[07:32] <labster> sounds great timotimo!  get tuit!

[07:32] *** berekuk joined
[07:32] <moritz> timotimo: no, iirc the plan was to not have pod inside the setting

[07:33] <moritz> timotimo: because of bootstrapping issues, and because we want to share documentation with other implementations

[07:33] <jnthn> I'm not sure if we can put Pod in CORE.setting due to bootstrap things. Also it'd make the parse time longer ;)

[07:33] <moritz> and longer compile times, yes

[07:33] <FROGGS> r: class A { method gist(A:U:) { say self.VAR.name } }; say my A $a # how to get the varname of self?

[07:33] <camelia> rakudo 14e7d7: OUTPUT«No such method 'name' for invocant of type 'A'␤  in method gist at /tmp/rSnsgIUVvW:1␤  in sub say at src/gen/CORE.setting:10935␤  in block  at /tmp/rSnsgIUVvW:1␤␤»

[07:33] <timotimo> yes, the parse time is already woefully long, i fear

[07:33] <jnthn> We could, however, load a module that mixes docs in to all the CORE setting things.

[07:33] <moritz> I think the "master plan" was to have some kind of include mechanism for POD

[07:33] <timotimo> there's external docs, right?

[07:33] <labster> that loads automatically in the REPL?

[07:34] <FROGGS> use Selfexplanatory;

[07:34] <jnthn> Well, the parse time is under half of what it is on Parrot on the JVM port, before I start optimizing... :)

[07:34] *** GlitchMr joined
[07:34] <timotimo> jnthn: could we use a jvm perl6 to build a parrot perl6 perhaps? :)

[07:34] <labster> the parse time is just under half on my new laptop, too :)

[07:35] <timotimo> oh wow, my laptop is melting from compiling rakudo

[07:35] <timotimo> 90 degC

[07:35] <FROGGS> wow

[07:35] <moritz> enough for pancakes \o/

[07:36] <FROGGS> and there is even no need for an usb-pan :o)

[07:36] *** ankit_ joined
[07:36] <labster> rakudo: now making your life more delicious, too

[07:36] <camelia> rakudo 14e7d7: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/yAvJUFTN9v:1␤------> now ⏏making your life more delicious, too␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        stateme…

[07:36] <timotimo> :)

[07:36] <jnthn> timotimo: That's probably a bit tricky to set up.

[07:36] *** ankit_ left
[07:36] <labster> oh, hi camelia++

[07:37] <timotimo> i think my laptop fan isn't powerful enough.

[07:38] <timotimo> i was idly thinking: how will turning lexical variables into local variables offer much optimisation when it's not being referred to in inner scopes?

[07:38] <labster> I recently went through an overheating thing with a skinny iMac, took the fans out, cleaned them really well, and it works fine now.

[07:38] <jnthn> timotimo: Cheaper to access, easier for runtimes to optimize with, shorter lifetime, and on the JVM port they live on the stack.

[07:39] <jnthn> (As in, the referencfes and any natives do.)

[07:39] <timotimo> oh. that does seem pretty nifty

[07:39] <timotimo> how far would the optimizer look to make sure the lexical won't actually be needed? how about OUTER:: and such?

[07:39] <jnthn> Yes, we should do it aggressively, but need to decide the fate of .eval

[07:39] <jnthn> And define carefully what the boundaries of it are

[07:40] <jnthn> Yeah, pseudo-packages would thwart it.

[07:40] *** PacoAir left
[07:40] <timotimo> so a function would have to be analysed to see if it uses pseudo-packages or eval or calls anything that uses pseudopackages or eval etc etc?

[07:40] <timotimo> or if it uses a named lookup, because it could look up a function that uses a pseudopackage

[07:41] <timotimo> hm. maybe in a first pass the optimizer could bail out if it sees any function call or operator invocation at all! m)

[07:42] <jnthn> And also we need to analyze lexical capture

[07:42] *** GlitchMr left
[07:42] <jnthn> By nested closures, etc.

[07:42] <jnthn> I think we should do it in NQP first.

[07:43] <timotimo> that seems kind of out-of-my-domain now

[07:43] <timotimo> but how about a function that introspects and pretty-prints packages and other stuff, like python's help function?

[07:43] *** domidumont left
[07:43] <timotimo> it could list members and display their Pods and so on

[07:44] <arnsholt> jnthn: In Zavolaj #23 the Parrot folks are terribly annoyed about something we do in native_call_build, but I'm not entirely sure what exactly. Are you able to shed some more light on it?

[07:45] <arnsholt> They don't like us reaching into the internals of the PMCs, but it's an object whose implementation we control...

[07:47] <jnthn> Um. Which PMCs?

[07:47] <jnthn> SixModelObject stuff?

[07:48] *** GlitchMr joined
[07:48] <jnthn> Everything 6model related reaches into there, and it's just a case of stuff hanging off a struct.

[07:48] <jnthn> uh, a struct of ours hanging off the PMC's data pointer, I mean.

[07:49] <timotimo> sigh. rakudo repl :|

[07:49] <timotimo> r: my $foo = 10; my $bar = "hello"; say ::.keys;

[07:49] <camelia> rakudo 14e7d7: OUTPUT«$=pod !UNIT_MARKER GLOBALish EXPORT $?PACKAGE ::?PACKAGE $_ $/ $! $foo $bar␤»

[07:49] <timotimo> $foo and $bar won't show up when the same code is entered in the repl

[07:50] * hoelzro didn't know about ::.keys

[07:50] <timotimo> UNLESS it's in one line. then it works fine.

[07:50] <hoelzro> timotimo: that's what I was about to ask =)

[07:50] <hoelzro> it's like local in Lua

[07:50] <arnsholt> jnthn: Yeah, that's what I'm thinking. I'll ask some more what they're annoyed about

[07:50] <hoelzro> the my is specific to the chunk being compiled

[07:50] * hoelzro still has to figure out a way to pluck locals out of an execution

[07:51] <timotimo> but you can still refer to those $foo and $bar in separate lines. they just won't show up in ::

[07:51] <hoelzro> oh, really?

[07:51] <hoelzro> curious

[07:51] <timotimo> yeah, it would be pretty terrible if you could define but not later use stuff in the repl

[07:52] <timotimo> and OUTER:: won't get me anywhere either

[07:54] *** pjcj left
[07:55] *** GlitchMr left
[07:56] *** pjcj joined
[07:57] *** GlitchMr joined
[07:57] <dalek> rakudo/nom: 362a098 | (Brent Laabs)++ | src/RESTRICTED.setting:

[07:57] <dalek> rakudo/nom: add link, symlink, and chmod to RESTRICTED.setting

[07:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/362a098be9

[07:57] <jnthn> arnsholt: gotta do teaching stuff now; bbl

[07:58] <arnsholt> 'k

[07:58] *** domidumont joined
[08:01] *** sciurius left
[08:03] *** domidumont left
[08:05] * lizmat is looking forward to the day that https://github.com/rakudo/rakudo#readme will be changed to include more VM's

[08:06] *** arlinius left
[08:09] <moritz> more VMs?

[08:09] <lizmat> more than just the one Parrot

[08:10] <moritz> ah, right

[08:11] * moritz currently manages some code at work where VM is really a vmware-instance, not a language runtime

[08:11] <moritz> thus my confusion

[08:11] <lizmat> hehe...

[08:11] *** berekuk left
[08:13] *** GlitchMr left
[08:13] *** GlitchMr joined
[08:17] <timotimo> hum. what type constraint would i give a multi that should be invoked when i pass a package?

[08:17] <timotimo> use Graphviz::Dot; help(Graphviz::Dot); # like this

[08:18] <hoelzro> Any:U?

[08:18] <moritz> r: package A; multi f(|) { 'default' }; multi f(A) { 'A' }; say f A

[08:18] <camelia> rakudo 362a09: OUTPUT«===SORRY!===␤This appears to be Perl 5 code. If you intended it to be Perl 6 code, please use a Perl 6 style package block like "package Foo { ... }", or "module Foo; ...".␤at /tmp/mdnOtcPX16:1␤------> package A; ⏏multi f(|) { 'defa…

[08:18] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(A) { 'A' }; say f A

[08:18] <camelia> rakudo 362a09: OUTPUT«===SORRY!===␤Type A cannot be used as a nominal type on a parameter␤at /tmp/tY2jX72F2c:1␤------> { }; multi f(|) { 'default' }; multi f(A⏏) { 'A' }; say f A␤    expecting any of:␤        postfix␤        statement end␤        sta…

[08:18] <timotimo> hehe.

[08:19] *** berekuk joined
[08:19] <timotimo> moritz: i want to specify "any package", rather than "a specific package"

[08:20] <timotimo> as in "call help on a package to get a list of all members that it exports and Pods for everything"

[08:20] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(Mu where { .HOW === Perl6::MetaModel::PackageHOW })) { 'A' }; say f A

[08:20] <camelia> rakudo 362a09: OUTPUT«===SORRY!===␤Cannot do non-typename cases of type_constraint yet␤at /tmp/UAHjQDa0Kg:1␤------>  .HOW === Perl6::MetaModel::PackageHOW }⏏)) { 'A' }; say f A␤    expecting any of:␤        argument list␤        postfix␤        state…

[08:21] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(Mu $ where { .HOW === Perl6::MetaModel::PackageHOW })) { 'A' }; say f A

[08:21] <camelia> rakudo 362a09: OUTPUT«===SORRY!===␤Missing block␤at /tmp/JduAWHGOOC:1␤------> .HOW === Perl6::MetaModel::PackageHOW })⏏) { 'A' }; say f A␤    expecting any of:␤        argument list␤        postfix␤        statement end␤        statement modifier␤   …

[08:21] <timotimo> ah, that's a clever idea.

[08:21] *** GlitchMr left
[08:21] <timotimo> one ) too many

[08:21] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(Mu $ where { .HOW === Perl6::MetaModel::PackageHOW }) { 'A' }; say f A

[08:21] <camelia> rakudo 362a09: OUTPUT«Could not find symbol '&PackageHOW'␤  in method <anon> at src/gen/CORE.setting:10042␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in sub f at /tmp/DGfoJXqEn8:…

[08:21] <timotimo> remove the Perl6::

[08:21] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(Mu $ where { .HOW === MetaModel::PackageHOW }) { 'A' }; say f A

[08:21] <camelia> rakudo 362a09: OUTPUT«Could not find symbol '&PackageHOW'␤  in method <anon> at src/gen/CORE.setting:10042␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in sub f at /tmp/_chWAPt9pJ:…

[08:21] <timotimo> oh, wait

[08:21] <timotimo> try Metamodel::ModuleHOW

[08:22] <moritz> r: package A { }; multi f(|) { 'default' }; multi f(Mu $ where { .HOW === Metamodel::PackageHOW }) { 'A' }; say f A

[08:22] <camelia> rakudo 362a09: OUTPUT«default␤»

[08:22] <moritz> r: package A { }; multi f(Mu $) { 'default' }; multi f(Mu $ where { .HOW === Metamodel::PackageHOW }) { 'A' }; say f A

[08:22] <camelia> rakudo 362a09: OUTPUT«default␤»

[08:22] <timotimo> r: package A { }; multi f(|) { 'default' }; multi f(Mu $ where { .HOW === Metamodel::PackageHOW }) { 'A' }; say f A; multi f(Mu $ where { .HOW === Metamodel::ModuleHOW }) { 'B' };

[08:22] <camelia> rakudo 362a09: OUTPUT«default␤»

[08:22] <moritz> r: package A { }; multi f(Mu $) { 'default' }; multi f(Mu $ where {say .HOW; .HOW === Metamodel::PackageHOW }) { 'A' }; say f A

[08:22] <camelia> rakudo 362a09: OUTPUT«Perl6::Metamodel::PackageHOW.new()␤default␤»

[08:22] <moritz> oh

[08:22] <timotimo> maybe ~~ instead of ===?

[08:22] <moritz> r: package A { }; multi f(Mu $) { 'default' }; multi f(Mu $ where {say .HOW; .HOW.WHAT === Metamodel::PackageHOW }) { 'A' }; say f A

[08:23] <camelia> rakudo 362a09: OUTPUT«Perl6::Metamodel::PackageHOW.new()␤Perl6::Metamodel::PackageHOW.new()␤A␤»

[08:23] <timotimo> oh, hehe.

[08:23] <moritz> .HOW is an instance, not the type object

[08:23] <timotimo> that would explain it, yes

[08:23] <timotimo> thanks! i'll start prototyping my help function. i guess it could totally be a panda-able module (although i'd love it to grow into a Star module, too)

[08:25] *** snoopy left
[08:26] <lizmat> afk for a few hours

[08:31] *** GlitchMr joined
[08:36] *** daxim joined
[08:36] *** GlitchMr left
[08:36] <timotimo> what's the sanest way to tell if my help sub has been recursively called?

[08:36] <timotimo> oh, maybe a state variable would be good.

[08:37] *** GlitchMr joined
[08:38] <moritz> don't do that kind of detection, if you can avoid it

[08:38] <moritz> it breaks composability

[08:38] <moritz> rather have a different function that you use for recursion

[08:38] <timotimo> i'd like to have the outermost call to help print out the result, but all inner calls should just do string concatenation

[08:38] <timotimo> hm, perhaps that's saner, indeed.

[08:40] <timotimo> oh, huh.

[08:41] <timotimo> r: multi help(Routine $foo) { say "routine" }; multi help(Mu $foo where { .HOW.WHAT === Metamodel::ClassHOW }) { say "class" }; help(Routine);

[08:41] <camelia> rakudo 362a09: OUTPUT«routine␤»

[08:41] <timotimo> that's amusing :)

[08:41] <timotimo> i suppose i have to check for the .HOW.WHAT there, too

[08:41] *** sciurius joined
[08:42] <moritz> or use Routine:D

[08:42] <timotimo> that seems much better

[08:43] *** GlitchMr left
[08:45] *** GlitchMr joined
[08:47] <timotimo> bbl

[08:49] *** arlinius joined
[08:50] *** sivoais left
[08:51] *** sivoais joined
[08:51] *** GlitchMr left
[08:53] *** GlitchMr joined
[08:54] *** sqirrel left
[08:55] *** dakkar joined
[08:56] *** sivoais left
[08:56] *** sivoais joined
[09:00] *** domidumont joined
[09:00] *** GlitchMr left
[09:04] *** sivoais left
[09:05] *** sivoais joined
[09:08] *** GlitchMr joined
[09:12] <masak> r: .say for (bag slurp.words).pairs.sort(*.value).reverse[^10] # see https://twitter.com/colomon/status/336582604583219200

[09:12] <camelia> rakudo 362a09: OUTPUT«"Land" => 5␤"der" => 4␤"Österreich!" => 3␤"Österreich," => 3␤"vielgeliebtes" => 2␤"und" => 2␤"in" => 2␤"vielgeprüftes" => 2␤"vielgerühmtes" => 2␤"du" => 2␤»

[09:13] <masak> good antenoon, #perl6

[09:14] *** sivoais left
[09:14] *** sivoais joined
[09:15] <masak> I was naturally inclined to do '.Bag' there instead of '(bag ...)'. I think the former reads better. but it's NYI.

[09:19] <moritz> \o masak

[09:23] *** sivoais left
[09:24] *** sivoais joined
[09:24] <dalek> v5: 261e15f | (Tobias Leich)++ | / (7 files):

[09:24] <dalek> v5: override Perl6's stringy-methods, add warnings.pm

[09:24] <dalek> v5: 

[09:24] <dalek> v5: This is a somewhat bigger commit, which lets you:

[09:24] <dalek> v5:   a) En-/disable warning categories, with defaults if arglist is missing.

[09:24] <dalek> v5:   b) Query these categories using warnings::enabled().

[09:24] <dalek> v5:   c) Override stringification by adding P5Str (and alike) methods.

[09:24] <dalek> v5:   d) Call these P5Str methods from the AST produced within v5 blocks.

[09:24] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/261e15f15c

[09:30] *** fhelmberger joined
[09:32] *** sivoais left
[09:33] *** sivoais joined
[09:33] * masak spectests a patch to add List.Bag

[09:36] <masak> ooh, Thursday is Rakudo release day.

[09:36] <hoelzro> \o/

[09:36] <masak> ++FROGGS

[09:38] <tadzik> oh, I can volunteer for some realease

[09:38] <tadzik> make it real

[09:38] <tadzik> putting real in realease

[09:39] <FROGGS> :o)

[09:39] <dalek> rakudo/nom: e782a0a | tadzik++ | docs/release_guide.pod:

[09:39] <dalek> rakudo/nom: Volunteer for #66

[09:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e782a0a9a5

[09:42] *** sivoais left
[09:42] *** sivoais joined
[09:48] *** arlinius left
[09:50] *** sivoais left
[09:51] *** sivoais joined
[09:58] *** snuffles left
[09:59] *** sivoais left
[09:59] *** berekuk left
[10:00] *** sivoais joined
[10:00] *** berekuk joined
[10:01] *** berekuk left
[10:09] *** sivoais left
[10:09] *** sivoais joined
[10:13] *** domidumont left
[10:17] *** sivoais left
[10:18] *** sivoais joined
[10:19] <colomon> masak: mono run/Niecza.exe -e ".say for slurp.words.Bag.pairs.sort(*.value).reverse[^10]" <words

[10:19] <colomon> "the" => 20 (etc)

[10:19] <colomon> locally

[10:20] <colomon> rn: https://gist.github.com/colomon/5618809

[10:20] <camelia> niecza v24-51-g009f999: OUTPUT«Land: 6.172840%␤der: 4.938272%␤Österreich!: 3.703704%␤Österreich,: 3.703704%␤vielgerühmtes: 2.469136%␤und: 2.469136%␤vielgeprüftes: 2.469136%␤vielgeliebtes: 2.469136%␤in: 2.469136%␤du: 2.469136%␤»

[10:20] <camelia> ..rakudo e782a0: OUTPUT«Land: 6.172840%␤der: 4.938272%␤Österreich,: 3.703704%␤Österreich!: 3.703704%␤du: 2.469136%␤vielgerühmtes: 2.469136%␤vielgeprüftes: 2.469136%␤in: 2.469136%␤und: 2.469136%␤vielgeliebtes: 2.469136%␤»

[10:22] <masak> colomon: nice.

[10:24] <masak> (both .Bag working on Niecza, and the gist)

[10:25] <colomon> .Bag doesn't work fully yet.  But it works some.  I'm holding off pushing the changes until I have more of the spec tests sorted.

[10:26] <colomon> (and I branched the spec tests so the changes don't slam rakudo all at once.)

[10:26] *** sivoais left
[10:27] *** sivoais joined
[10:27] <masak> colomon++

[10:28] <colomon> I'm still not at all sure what is supposed to happen in the Set/Bag constructors.

[10:28] <colomon> for instance:

[10:28] <colomon> rn: say bag a=>1, b=>20, c=>30000

[10:28] <camelia> rakudo e782a0: OUTPUT«3 unexpected named parameters passed (a, b, c)␤  in sub bag at src/gen/CORE.setting:13224␤  in block  at /tmp/QeMU07IHZu:1␤␤»

[10:28] <camelia> ..niecza v24-51-g009f999: OUTPUT«Unhandled exception: Excess arguments to bag, unused named a, b, c␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (bag @ 1) ␤  at /tmp/BTZ9YRuRC0 line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4331 (ANON @ 3) ␤  at /home/p6eval/nie…

[10:28] <colomon> rn: say bag { a=>1, b=>20, c=>30000 }

[10:28] <camelia> rakudo e782a0, niecza v24-51-g009f999: OUTPUT«bag("a" => 1, "b" => 20, "c" => 30000)␤»

[10:29] <colomon> should that still work as is, or does it need to be { a=>1, b=>20, c=>30000 }.Bag?

[10:31] <masak> I think the latter.

[10:31] <colomon> and how does one implemented that .Bag without similar functionality in in Bag.new?

[10:32] <masak> someone (maybe I) should totally make a table of the effects of 'bag', 'Bag.new', and '.Bag' on different things.

[10:32] <colomon> I mean, obviously you can do it with a hidden method of some sort.

[10:32] <colomon> but that's yuck.

[10:32] <masak> why is that yuck?

[10:33] <colomon> giving the implementor access to a clearly useful method that isn't available to the user

[10:36] *** sivoais left
[10:36] <moritz> maybe Bag just needs two (public) constructors

[10:37] *** sivoais joined
[10:37] *** anuby_ joined
[10:37] <colomon> related: the idea of a Set of Sets makes perfect sense.  the idea of a KeySet of KeySets seems really weird to me.  What does it mean to have mutable objects as your keys in a Set?

[10:38] *** anuby left
[10:38] <colomon> or even worse, I guess, a Set of KeySets.  

[10:38] *** domidumont joined
[10:39] *** rindolf joined
[10:40] <colomon> how can your set be immutable if its keys are mutable?

[10:41] <masak> if it were up to me, you should never be able to put mutable things as keys to any container.

[10:42] <masak> but Perl (5 or 6) was never keen on enforcing any stupid thing the programmer might do, so...

[10:43] <masak> and I guess it sort of works out, as long as the contained KeySet hashes on its reference, not on its contents.

[10:43] <masak> TimToady: what's KeySet.WHICH?

[10:45] *** sivoais left
[10:46] *** sivoais joined
[10:47] *** arlinius joined
[10:47] <colomon> masak: but we definitely want contained Sets to hash on their contents, not their reference, right?

[10:47] *** snuffles joined
[10:48] <moritz> a tuple of two integers, one identifying the type, one for the object

[10:49] <masak> colomon: I don't know. if we do, we want to be very careful about every using Sets (et al.) as hash keys. can't have the cake and eat it.

[10:49] <colomon> masak: I'd argue an array of mutable things makes perfect sense, even if it's not functional programming.  but a Hash keyed with mutable things?  That's kind of insane.

[10:49] <masak> agreed.

[10:49] *** snuffles left
[10:50] <masak> t/spec/S32-str/substr.rakudo aborts here with 'ICU not loaded'. is it wrongly catgegorized in spectests.data ?

[10:50] <masak> spectest*

[10:51] <masak> appears so. should I add an '# icu' comment?

[10:51] *** snuffles joined
[10:51] <moritz> yes

[10:51] * masak does so

[10:52] <dalek> rakudo/nom: ddaa3f6 | masak++ | t/spectest.data:

[10:52] <dalek> rakudo/nom: [spectest.data] mark t/spec/S32-str/substr.t as # icu

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ddaa3f6555

[10:55] *** sivoais left
[10:56] *** sivoais joined
[10:57] *** rindolf left
[10:57] *** rindolf joined
[11:01] <lizmat> after my pull request of last night, unifying the API of hash() and Hash.new, and the initial reaction to that here, I thought I'd make it an issue: https://github.com/perl6/specs/issues/43

[11:04] *** sivoais left
[11:05] *** sivoais joined
[11:10] *** PacoAir joined
[11:11] <masak> lizmat++

[11:11] *** gdey joined
[11:11] <lizmat> I was actually considering putting in a deprecation warning in hash() if called with only named params, not being "type" and/or "of"

[11:12] <lizmat> and then, for now, create the hash anyway

[11:12] <lizmat> in any case, with rakudo builds and spectests ok with this change to hash()

[11:13] <lizmat> (except for the 2 tests that actually test hash( a => 1 )

[11:14] *** sivoais left
[11:14] *** tgt joined
[11:15] *** sivoais joined
[11:15] *** rindolf left
[11:16] *** rindolf joined
[11:20] <colomon> masak: IMO, the entire point of allowing Sets of Sets is that it should be easy to do and by the value of the Set, not the particular object.

[11:21] <colomon> so set(1, 3) (elem) set(set(1,3), 1, 3) should work

[11:21] *** aindilis left
[11:21] *** cooper left
[11:23] *** sivoais left
[11:24] *** SamuraiJack joined
[11:24] *** cooper joined
[11:24] *** sivoais joined
[11:28] <masak> colomon: a very good point. aye.

[11:28] <masak> and with Set and Bag, which are immutable, there isn't really a problem.

[11:28] <masak> it's KeySet and KeyBag which will need attention.

[11:29] <masak> in my view, two questions:

[11:29] <masak> (a) do those still .WHICH on their contents?

[11:29] <colomon> If Set and Bag have mutable keys, it is a very big problem.

[11:29] <masak> (b) if so, should we issue a warning if someone tries to put them in a keying container?

[11:29] <lizmat> I'm still not sure what you mean with a "mutable container" ?

[11:30] <masak> colomon: yes, the general problem is indeed immutable containers with mutable keys.

[11:30] <masak> lizmat: who said "mutable container"? :)

[11:30] <lizmat> sorry, mutable key

[11:31] <masak> lizmat: the issue here is keys which can change in hashing/keying containers.

[11:31] <lizmat> so for instance:

[11:31] <masak> lizmat: like an Employee object, hashing on its contents, used as a key in a Set.

[11:32] <lizmat> the way I understand typed hashes, is that the actual key is the internal id of the container, and that *is* immutable afaik

[11:32] <masak> r: class Person { has $.name; method WHICH { "Person<$.name>" } }; say Person.new(:name<Berit>).WHICH

[11:32] <camelia> rakudo ddaa3f: OUTPUT«Person<Berit>␤»

[11:33] *** sivoais left
[11:33] <masak> r: class Person { has $.name is rw; method WHICH { "Person<$.name>" } }; my $p = Person.new(:name<Berit>).WHICH; my $set = set $p; $p.name = "Sofia"; say $set.keys[0].WHICH

[11:33] <moritz> r: class Person { has $.name; method WHICH { "Person<$.name>" } }; my %h{Person}; %h{Person.new(:name<Berit>)} = 1; say %h{Person.new(:name<Berit>)}

[11:33] <camelia> rakudo ddaa3f: OUTPUT«No such method 'name' for invocant of type 'Str'␤  in block  at /tmp/ZFbgpE8mcF:1␤␤»

[11:33] <camelia> rakudo ddaa3f: OUTPUT«1␤»

[11:33] <masak> hm.

[11:33] <masak> r: class Person { has $.name is rw; method WHICH { "Person<$.name>" } }; my $p = Person.new(:name<Berit>).WHICH; my $set = set $p; $p.name = "Sofia"; say $set{$p}.WHICH

[11:33] <moritz> currently set() still stringifies

[11:33] <camelia> rakudo ddaa3f: OUTPUT«No such method 'name' for invocant of type 'Str'␤  in block  at /tmp/5Wlr1DpI99:1␤␤»

[11:33] <colomon> lizmat: the problem here is basically a collision of ideas

[11:33] <masak> moritz: oh.

[11:34] *** sivoais joined
[11:36] <lizmat> r: class A {}; my $a=A.new; my %h{A}=$a=>1; say nqp::getattr( %h, EnumMap, '$!storage');

[11:36] *** rindolf left
[11:36] <camelia> rakudo ddaa3f: OUTPUT«("A|-480576731" => 1).hash␤»

[11:36] *** rindolf joined
[11:36] *** xenoterracide left
[11:37] <lizmat> so it's not a stringification of the hash that is the key, it's some internal ID

[11:37] <moritz> object hashes use the object's .WHICH as key

[11:37] <lizmat> or am I completely off the rails here?

[11:39] <colomon> is WHICH supposed to be smart enough to distinguish between mutable and immutable objects?

[11:39] <colomon> ie if I do set(1,3) twice, will they both have the same WHICH value?

[11:39] <lizmat> doesn't seem so

[11:40] <colomon> lizmat: ideally, not by current implementation.  :)

[11:41] <moritz> colomon: WHICH must be made smart enough manually

[11:42] <moritz> ie if you build a class of immutable objects, you write a WHICH which hashes the object

[11:42] *** sivoais left
[11:43] <colomon> then I guess that's the solution?

[11:43] *** sivoais joined
[11:43] *** domidumont left
[11:44] <moritz> for sets, yes

[11:45] <colomon> so Set.WHICH should be based on the values contained, and KeySet.WHICH should be a reference to the KeySet object.

[11:45] <moritz> yes

[11:45] <moritz> (though using mutable values as hash keys is still a call for trouble)

[11:46] <colomon> I suspect that will sometimes be confusing, but at least it's consistent and presumably implementable.  

[11:47] *** PacoAir left
[11:50] *** SamuraiJack left
[11:50] *** SamuraiJack_ joined
[11:51] *** tgt left
[11:51] *** rindolf left
[11:52] *** sivoais left
[11:52] *** PacoAir joined
[11:52] <colomon> set(set(1,3), set(1,3)) should have one elements.  set(KeySet.new(1,3), KeySet.new(1,3)) should have two.

[11:52] *** rindolf joined
[11:53] *** sivoais joined
[11:56] *** jest1 joined
[11:56] <jest1> hi guys

[11:56] <masak> jest1: hi!

[11:56] <jest1> I wanted to hack a bit on nqp on JVM, as generally JVM is my platform

[11:57] <masak> nice.

[11:57] <tadzik> hello jest1 :)

[11:57] <masak> colomon: so essentially what you're saying is that KeySet.WHICH should *not* be content-based.

[11:57] <jest1> ...of daily development. The problem is, I can't find a reasonable description of what nqp is

[11:58] <jest1> I know it is a proper subset of Perl6, but what I can read from t/ dir is not enough :)

[11:58] <moritz> jest1: it doesn't (yet?) have a formal specification, or extensive documentation :(

[11:58] <nwc10> jest1: you're in Poland?

[11:58] <moritz> jest1: we use it to bootstrap the Rakudo Perl 6 compiler, and give it all the features it needs for that

[11:58] <moritz> and not (much) more

[11:58] <jest1> is there any way I can semi-automatically parse/read source code to guess the existing subs?

[11:59] <jest1> nwc10: yep, Poznań, Poland :)

[11:59] *** fgomez joined
[11:59] <jest1> I want to learn something before PLPW in Warsaw in a week, so tadzik sent me here :)

[11:59] <nwc10> and you're aware of the Polish Perl workshop, and that (at least) jnthn is going? http://act.yapc.eu/plpw2013/

[11:59] <nwc10> aha.

[11:59] <nwc10> good :-)

[12:00] <tadzik> :)

[12:00] <nwc10> (just checking)

[12:00] <jest1> yea, I know, but wanted my hands a bit dirty before

[12:00] * masak afk for ~1h

[12:00] <jest1> just to ask a sensible questions :)

[12:00] <nwc10> yes, sensible questions. problem is I don't know the right answers. Or at least, the good short answers

[12:01] *** rindolf left
[12:01] <nwc10> jnthn is the best person to answer, but he's at an on-site teaching job today

[12:01] <jest1> I meant the questions to jnthn 

[12:01] <jest1> ok

[12:01] *** rindolf joined
[12:01] <nwc10> if pmichaud is around, he might be able to answer

[12:01] *** sivoais left
[12:02] <jest1> and how do I read NQP sources to see what's available? I guess Parrot/JVM makes difference here?

[12:02] <nwc10> I can't answer better than you said already

[12:02] <tadzik> jest1: ack '^\s*sub' is generally a good guess at existing subs :)

[12:02] *** sivoais joined
[12:02] <tadzik> jest1: but nqp has very little runtime stuff, you mostly use opcodes

[12:02] <nwc10> aha, I can answer that

[12:02] <nwc10> the source for NQP is git://github.com/perl6/nqp.git

[12:03] <nwc10> the source for Rakudo is git://github.com/rakudo/rakudo.git

[12:03] <nwc10> right now, you want the branch origin/rak-jvm-support in NQP (not master)

[12:03] <jest1> I got that, I compiled, tested (with errors) and run simple programs

[12:04] <nwc10> ah OK cool. I think you now know more than me. :-(

[12:04] <jest1> looked around in t/ subdirectory to have a feeling what a NQP program looks like, but I miss a lot, e.g. strings manipulation

[12:05] <moritz> well, nqp mostly has nqp::substr and regexes

[12:05] <moritz> and a few others, like nqp::split, nqp::join, nqp::index

[12:05] <nwc10> the lower level bits of Rakudo are written in NQP, so look for files named *.nqp in the Rakudo checkout for more examples

[12:05] <nwc10> but yes, that's not a spec

[12:05] <nwc10> or a tutorial.

[12:05] <jest1> for starter I wanted some anagrams-by-permutation (I'm doing it for my students in Java in parallel, so it would be a nice comparison), but couldn't find perl5's substr, length, etc.

[12:06] <jest1> ok, I'll see Rakudo

[12:06] <moritz> nqp::substr, nqp::chars

[12:06] <moritz> nqp: my $s := 'abc'; say(nqp::substr($s, 1));

[12:06] <camelia> nqp: OUTPUT«bc␤»

[12:06] <moritz> nqp: my $s := 'abc'; say(nqp::substr($s, 0, 1));

[12:06] <jest1> oh, that looks so... obvious :)

[12:06] <camelia> nqp: OUTPUT«a␤»

[12:06] <moritz> nqp: my $s := 'abc'; say(nqp::chars($s));

[12:06] <camelia> nqp: OUTPUT«3␤»

[12:07] *** btyler joined
[12:07] <moritz> jest1: feel free to ask in here if you need more stuff, and can't find it

[12:07] <jest1> nice, I thought they are internal somhow

[12:07] <jest1> ok, going hacking then

[12:07] <moritz> if you write NQP code, you need them

[12:07] <jest1> by the way, is it expected that nqp@jvm has so many failing tests?

[12:09] <jest1> Now that I know of nqp::substr, docs/nqp-opcode.txt contains some hints on more subs

[12:10] *** sivoais left
[12:11] *** sivoais joined
[12:12] <dalek> v5: 8a2baad | (Tobias Leich)++ | t/test.pl:

[12:12] <dalek> v5: many tests have no description, pass "" instead

[12:12] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8a2baad9b1

[12:12] <dalek> v5: 1e2611e | (Tobias Leich)++ | STATUS.md:

[12:12] <dalek> v5: update after test.pl changes

[12:12] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/1e2611e2a7

[12:13] *** skids left
[12:18] *** rindolf left
[12:19] *** rindolf joined
[12:20] *** sivoais left
[12:21] *** sivoais joined
[12:29] *** sivoais left
[12:29] *** btyler left
[12:30] *** sivoais joined
[12:33] <[Coke]> @in

[12:34] *** anuby_ left
[12:35] <pmichaud> good morning, #perl6

[12:35] *** rindolf left
[12:35] <pmichaud> fwiw, the :of and :type named argument additions to .hash() and Hash.new() feel wrongish to me.

[12:35] *** rindolf joined
[12:36] *** sqirrel joined
[12:36] *** PacoAir left
[12:36] *** PacoAir joined
[12:37] <FROGGS> :/

[12:38] <moritz> I'd prefer it if nqp::clone would reproduce the type of the argument, including mixed-in roles

[12:39] *** sivoais left
[12:40] *** sivoais joined
[12:41] *** rindolf left
[12:41] *** rindolf joined
[12:44] <colomon> rn: say 10.WHICH

[12:44] <camelia> rakudo ddaa3f: OUTPUT«Int|10␤»

[12:44] <camelia> ..niecza v24-51-g009f999: OUTPUT«10[1C381F00]␤»

[12:44] <colomon> rn: say (10/1).WHICH

[12:45] <camelia> niecza v24-51-g009f999: OUTPUT«10.0[-1B0B3B80]␤»

[12:45] <camelia> ..rakudo ddaa3f: OUTPUT«Rat|10/1␤»

[12:45] *** domidumont joined
[12:48] *** sivoais left
[12:49] *** sivoais joined
[12:50] *** tgt joined
[12:50] <moritz> n: say 10.WHICH, 10.WHICH

[12:50] <camelia> niecza v24-51-g009f999: OUTPUT«10[-1D780880]10[-1D780880]␤»

[12:50] <moritz> ah, I guess the hex thingy is a type ID

[12:50] <moritz> n: say 10.WHICH, Int.WHICH

[12:50] <camelia> niecza v24-51-g009f999: OUTPUT«10[1C381F00][1C381F00]␤»

[12:51] *** risou_awy is now known as risou

[12:56] *** SamuraiJack_ left
[12:57] *** SamuraiJack_ joined
[12:58] <colomon> n: say "Hello".WHICH

[12:58] <camelia> niecza v24-51-g009f999: OUTPUT«str|Hello[-2BC40200]␤»

[12:58] *** sivoais left
[12:58] *** Su-Shee joined
[12:58] <colomon> n: say "Hello".WHICH, "blue".WHICH

[12:58] <camelia> niecza v24-51-g009f999: OUTPUT«str|Hello[3D23B880]str|blue[3D23B880]␤»

[12:58] <Su-Shee> masak: so, I killed the productivity of 4 companies at least with it. ;) 

[12:59] <colomon> n: say "Hello".WHICH, "blue".WHICH

[12:59] <camelia> niecza v24-51-g009f999: OUTPUT«str|Hello[23A3880]str|blue[23A3880]␤»

[12:59] *** sivoais joined
[12:59] <colomon> n: say (1, 2, 3).WHICH, (1, 2, 3).WHICH

[12:59] <camelia> niecza v24-51-g009f999: OUTPUT«[6F654C00][-7BF4E200]␤»

[13:00] *** rindolf left
[13:00] <[Coke]> r: say "Sand".WHICH

[13:00] <camelia> rakudo ddaa3f: OUTPUT«Str|Sand␤»

[13:00] *** rindolf joined
[13:01] *** ajr joined
[13:01] <[Coke]> ~~ to pmichaud et al.

[13:01] *** ajr is now known as Guest28756

[13:04] *** bluescreen10 joined
[13:05] * pmichaud is glad the 2012 robotics season is finally over.  :)

[13:07] *** bluescreen100 joined
[13:07] <colomon> pmichaud: Our local high school team ended up going to the big tournament in St. Louis

[13:08] <pmichaud> colomon: coooool.

[13:08] <nwc10> pmichaud: when did the 2013 season start?

[13:08] *** sivoais left
[13:08] *** daniel-s__ joined
[13:08] <pmichaud> nwc10: 2013 season starts Aug 1.

[13:08] <pmichaud> (signups opened on May 6, our team is still discussing a new team name for 2013 :)

[13:09] <pmichaud> colomon: our region wasn't in the rotation this year for St. Louis, or we would've gone there instead.

[13:09] *** sivoais joined
[13:09] * colomon admits he has no idea how the system works.  :)

[13:09] <colomon> local coaches are friends of ours, though.

[13:09] <masak> Su-Shee: :)

[13:10] <pmichaud> the World event in St. Louis rotates among each of the regional championships.  North Texas went to St. Louis for the 2011 season, so we weren't in the rotation for this year.

[13:10] <pmichaud> Going to LEGOLAND Calif was a nice "consolation", though.  :)

[13:10] <colomon> LEGOLAND!

[13:10] *** bluescreen10 left
[13:12] *** daniel-s_ left
[13:15] <dalek> rakudo/nom: a134b18 | masak++ | / (3 files):

[13:15] <dalek> rakudo/nom: [src/core] add .Set and .Bag to List and Parcel

[13:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a134b18ca7

[13:16] <pmichaud> masak: why "Set" and "Bag" and not ".set" and ".bag", ooc?

[13:16] <moritz> it feels slightly dirty that we have to add most methods to both List and Parcel

[13:17] <moritz> sounds like we need a better place for them, like Iterable or Positional or so

[13:17] <pmichaud> Iterable, more likely.

[13:18] <pmichaud> then Hash would get them also.

[13:18] *** sivoais left
[13:18] *** sivoais joined
[13:18] <masak> feel free to refactor as you see fit.

[13:18] <colomon> pmichaud: I initially had it .set and .bag, but discussion with TimToady convinced me .Set and .Bag were better.

[13:18] <masak> pmichaud: why .Set and .Bag with capitals? because that's how TimToady always wrote it in emails to p6l etc.

[13:19] <masak> pmichaud: essentially "render as this type".

[13:19] <masak> coercion.

[13:19] <pmichaud> sure.

[13:19] <colomon> .list and .hash are the exceptions, most types coerce with cased typename

[13:19] <masak> pmichaud: actually, .list and .hash with lower-case letters are the ones I always feel uneasy about.

[13:19] <masak> pmichaud: I have no idea what they do, or why they're needed.

[13:20] <masak> well, I have some idea, but I'm never 100% sure.

[13:20] <pmichaud> .list and .hash correspond to @ and % modifiers.

[13:20] <masak> I have this permutation-programming cargo-cult thing I do where I sometimes just add .list to stuff when things don't listify properly.

[13:20] <masak> but I do it without much understanding.

[13:21] <moritz> the problem is really that .list serves two different purposes

[13:21] <moritz> 1) turn a non-list into a list

[13:21] <pmichaud> and, in the case of Match objects, .list and .hash are selectors more than coercers.

[13:21] <moritz> 2) turn a list-in-scalar into a list-that-will-flatten

[13:21] *** rindolf left
[13:21] <masak> so, three different purposes.

[13:22] <masak> should I come in again? :P

[13:22] <pmichaud> 3) select the "list" view of an object

[13:22] <masak> NOBODY EXPECTS THE PERL6 LISTIQUISION!

[13:22] <moritz> the distinction between 1) and 3) is often artificial

[13:22] <moritz> my formulation just wasn't great

[13:22] <colomon> OUR CHIEF WEAPON IS CONFUSION!

[13:23] <pmichaud> well, "turn a non-list into a list" sounds more like "create a new List" to me than "select the list view of an object"

[13:23] <pmichaud> in that sense, one would expect .List and .Hash to always construct a new List/Hash, as opposed to selecting the list form.

[13:23] <pmichaud> i.e.,  I'd expect   $/.List  to create a List of a single match object, whereas  $/.list would return the positional captures

[13:25] <dalek> v5: 5180822 | (Tobias Leich)++ | lib/Perl5/ (2 files):

[13:25] <dalek> v5: stringify arrays

[13:25] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/51808227a8

[13:25] <dalek> v5: 0baf9a4 | (Tobias Leich)++ | / (2 files):

[13:25] <dalek> v5: fixed: my($a, $b, $c) = ...

[13:25] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/0baf9a4e62

[13:25] * moritz would expect (nearly) everybody to be confused by having both .list and .List and having them do different things

[13:25] <pmichaud> if it wouldn't be so long, one could propose that  @(something)  should desugar to  something.positional  instead of something.list

[13:26] <pmichaud> then Match.positional would return the positional captures

[13:26] <pmichaud> and "@" would be the "positional sigil" instead of the "list sigil" or "array sigil"

[13:26] *** kaleem left
[13:26] <moritz> let's just shortend it to Match.pos... oh, wait! :-)

[13:26] *** sivoais left
[13:26] <pmichaud> same for % / .associative  instead of .hash

[13:26] <[Coke]> Match.@ ;)

[13:27] *** sivoais joined
[13:27] <colomon> .positional and .associative seem sensible to me.  If one feels they are too long, one can always use @() and %()

[13:27] <tadzik> haha

[13:29] *** telex left
[13:30] *** telex joined
[13:32] <masak> colomon: I thought you were going for "If one feels they are too long, one can always use .pos and .ass" :P

[13:32] <colomon> :p

[13:33] <masak> anyway, +1 to a rename a la .positional and .associative

[13:33] <pmichaud> also, why are .Set and .Bag defined only for List and Parcel?  Perhaps they should go on Any or Cool.

[13:33] <masak> though since those are actually types, maybe they should actually be .Positional and .Associative ?

[13:33] <pmichaud> since they appear to be acting in their "listy" forms.

[13:33] <masak> pmichaud: yes, probably.

[13:33] <colomon> pmichaud: they go everywhere

[13:34] <colomon> List and Parcel are just specific examples.

[13:34] <colomon> dunno why masak started there

[13:34] <masak> please feel free to improve on my patch.

[13:34] <PerlJam> good $localtime #perl6!

[13:34] <pmichaud> colomon: yes, and I try to keep the codebase clean of "specific examples"

[13:34] <colomon> masak: I'm working on the same thing in Niecza.

[13:34] <masak> with List and Parcel, it feels like an actual coercion. with Any or Cool, it feels like it's a composition.

[13:34] <pmichaud> colomon: having one or two general cases is a lot preferable to N special cases

[13:35] <colomon> pmichaud: unfortunately, N special cases is probably needed

[13:35] *** prevost left
[13:35] <pmichaud> colomon: why is that?

[13:35] *** sivoais left
[13:35] <pmichaud> (this is why I'm not simply refactoring masak++'s patch on my own; I don't understand the problem space well enough yet)

[13:35] <colomon> pmichaud: though you should feel free in joining me arguing the current "spec" is too complicated

[13:35] <colomon> ;)_

[13:35] <pmichaud> colomon: complicated in what manner?

[13:36] <colomon> pmichaud: different types have different ways of coercing to Set (etc)

[13:36] *** sivoais joined
[13:36] <pmichaud> colomon: okay, as I said, I don't understand the problem space well enough then.

[13:36] <pmichaud> I'd need examples.

[13:36] <pmichaud> is there a spec issue for this?

[13:37] <colomon> no spec issue so far as I know.

[13:37] <pmichaud> ah.

[13:37] <pmichaud> "arguing the current 'spec' is too complicated" probably implies "let's create an issue ticket for it"  :)

[13:37] <colomon> yes

[13:37] <colomon> well, it's somewhere between too complicated and under-specified

[13:37] <colomon> which is a bad combination.

[13:38] <moritz> reminds me of the IO specs :-)

[13:38] <pmichaud> so we need a ticket on which we can hang use cases and discussion

[13:38] <pmichaud> afk, kid to school

[13:38] <colomon> pmichaud: sounds reasonable to me.

[13:38] *** rindolf joined
[13:38] * colomon gets to making a ticket

[13:38] *** skids joined
[13:44] *** sivoais left
[13:45] *** sivoais joined
[13:47] *** crab2313 joined
[13:47] *** gudahtt joined
[13:49] *** SamuraiJack_ left
[13:50] <FROGGS> does somebody know how to do a post-modification-hook on a variable? is that somehow possible using an lvalue sub?

[13:50] <FROGGS> (instead of a variable)

[13:50] <masak> feels like a thing .STORE should be able to do, yes.

[13:50] <moritz> probably possible with a proxy

[13:50] <masak> (because .STORE does the modification, and you can put code after that)

[13:51] <moritz> (Proxy lets you write your own STORE)

[13:51] <FROGGS> \o/

[13:52] <masak> moritz: we should totally co-write a conf talk at some point :)

[13:52] <masak> I don't know why I thought about this now.

[13:52] <masak> probably be cause we both explained the same thing, in a way that made the totality exceed the sum of the parts. :)

[13:52] <PerlJam> masak: trying to increase the confusion that people seem to already have between the two of you?  ;)

[13:53] *** sivoais left
[13:53] <masak> *cackle*

[13:54] <moritz> confusion? who? where?

[13:54] <masak> PerlJam: no, I'm not. not really.

[13:54] <PerlJam> masak, moritz: there is always lightning talks.

[13:54] <masak> ooh

[13:54] *** sivoais joined
[13:54] <masak> moritz: confusion! even *I* confuse the two of us sometimes! :P

[13:54] *** Guest28756 is now known as ajr_

[13:54] <arnsholt> I think I need to figure out how to do Proxy stuff as well

[13:55] <masak> "...where was that post I wrote, that was so great? oh wait, I didn't write that one, moritz++ did..." :P

[13:55] <arnsholt> Probably the best way to hook into variables like errno for NativeCall

[13:56] <moritz> masak: seems you have a small identity crisis. Which means that I have a small identity crisis. :-)

[13:56] <masak> :P

[13:56] *** crab2313 left
[13:56] <masak> oh, the duality.

[13:56] <PerlJam> .oO( how to increase the size of your identity ... crisis )

[13:57] <Su-Shee> it's very simple, in any fairy tale you just put moritz' wife between them and et viola you will soon know who is who. done. 

[13:59] <masak> as long as you can keep us apart well enough to find out whose wife is moritz'...

[14:00] <Su-Shee> everybody who is sold to me as moritz' wife. ;) I believe anything. 

[14:00] <masak> that does simplify things.

[14:00] <PerlJam> I thought you needed some rope and a sword or something ...

[14:01] <PerlJam> maybe a baby

[14:01] *** rindolf left
[14:01] <masak> this is getting far too complicated.

[14:01] *** rindolf joined
[14:02] <masak> even my clones agree.

[14:02] <Su-Shee> PerlJam: re-read fairy tales, man.. 

[14:02] * moritz can serve with wife, child and rope, but has no sword at home :/

[14:02] *** sivoais left
[14:02] <FROGGS> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; lv() = 42

[14:02] <camelia> rakudo ddaa3f: OUTPUT«42␤»

[14:02] <FROGGS> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; lv()++

[14:02] <camelia> rakudo ddaa3f: OUTPUT«1␤»

[14:02] <Su-Shee> moritz: your wife should have one, from back in the day, being a viking shield maid and all...

[14:03] *** sivoais joined
[14:03] <moritz> Su-Shee: it was passed to her sister (oldest) or brother (male) :-(

[14:03] <Su-Shee> moritz: you should have married the sister then.. ;)

[14:04] <Su-Shee> moritz: sell masak to her sister. even better.

[14:04] *** kaleem joined
[14:04] * moritz was never good at selling

[14:05] <moritz> Su-Shee: maybe a blood feud for not inheriting the sword would fit better? :-)

[14:05] <Su-Shee> sure, works too. but you probably get a goat or two on the market for the masak.. he's young, he's able.. 

[14:06] *** btyler joined
[14:08] * masak backlogs the last few minutes, naturally not expecting discussion about him being bartered for goats

[14:08] <masak> hey wait

[14:09] <masak> was this an either-or sitation? marry moritz' sister OR being sold for two goats? or do I have to do both?

[14:09] <moritz> masak: not my suggestion :-)

[14:09] <pmichaud> but we now have a way to distinguish the two of you.  One of you isn't being sold for goats.  :)

[14:09] <masak> moritz: no, but it was suggested by someone whose nick almost sounds like "sudo" :P

[14:09] <Su-Shee> masak: that clearly depends on moritz' ability as a tradesman..

[14:09] <moritz> masak: :-)

[14:10] <masak> this is by far the silliest conversation I've had this week.

[14:10] <Su-Shee> don't be shy, folks, mr shee bought me on the internet for two goats and his little sister.. ;)

[14:10] <Su-Shee> masak: glad to please :)

[14:10] <moritz> masak: don't worry, the week's still young

[14:10] * masak throws a CoC at Su-Shee :P

[14:11] <masak> Su-Shee: you're offending people who were actually bought for two goats and a sister on the Internet!

[14:11] <Su-Shee> "section 3, paragraph 4, subsection 345234 clearly states that developers are not to be sold under price"

[14:11] <PerlJam> .oO( says the man who was talking about .pos and .ass earlier ;)

[14:11] <masak> PerlJam: .ass is in the Bible!

[14:11] <Su-Shee> masak: SO IS GOAT SELLING :)

[14:11] *** sivoais left
[14:12] <masak> ok, point.

[14:12] *** btyler left
[14:13] <colomon> is threatening to slice a child in half to determine parentage actually in the Bible, or just one of the legends attached to Solomon?

[14:13] *** bowtie joined
[14:13] <pmichaud> I've looked all through the Camel Book and haven't see anything about goat selling, .pos, or .ass

[14:13] <pmichaud> *seen

[14:13] <Su-Shee> colomon: be happy it's not attached to colomon.. 

[14:13] <Su-Shee> pmichaud: clearly, because it's a _camel_ book. 

[14:14] <colomon> .camelass

[14:14] <pmichaud> right.  You all must be using some non-standard Bible.

[14:14] <PerlJam> .oO( Is there an Ass book? )

[14:14] <Su-Shee> (sorry. I had too much black tea and staring at python :)

[14:14] <masak> colomon: it's actually in there.

[14:14] <tadzik> I'm sure there is one

[14:14] <masak> colomon: hold on, I'll get you chapter and verse ;)

[14:14] <masak> colomon: https://en.wikipedia.org/wiki/Judgment_of_Solomon

[14:15] <masak> 1Kings 3:16-28, apparently.

[14:15] <colomon> masak++

[14:15] <Su-Shee> .oO(now I see masak standing at the corner of the street, camel book in his hand, trying to convince people of the gospel of perl.. ;)

[14:16] <masak> THE END TIMES ARE NEAR! LEARN PERL 6 BEFORE PHP DESCENDS ON US ALL!

[14:16] <PerlJam> Apocalyptic ranting even!  ;)

[14:17] <FROGGS> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; my $s := &lv; $s = 1

[14:17] <camelia> rakudo a134b1: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/yJMvr1dweD:1␤␤»

[14:17] <masak> imagine 1000 years of PHP. and you have to tattoo "http://php.net" on your wrist.

[14:17] <FROGGS> masak/moritz: can I bind this proxy to a variable?

[14:17] <Su-Shee> didn't google just recently declare PHP the winner in the web race?

[14:17] *** sivoais joined
[14:18] <PerlJam> .oO( Are masak and moritz synoptic twins? )

[14:18] <FROGGS> ( I want to fake P5's $| )

[14:18] <moritz> FROGGS: sure

[14:18] <FROGGS> what have I done wrong?

[14:19] <pmichaud> lv never was invoked.

[14:20] <pmichaud> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; my $s := lv(); $s = 1;

[14:20] <camelia> rakudo a134b1: OUTPUT«1␤»

[14:21] <pmichaud> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; my $s := lv(); $s = 1; say $a;

[14:21] <camelia> rakudo a134b1: OUTPUT«1␤1␤»

[14:21] *** rindolf left
[14:21] <moritz> iirc FETCH and STORE have some weird argument counts

[14:21] *** rindolf joined
[14:21] <moritz> look for working examples in the setting

[14:21] <moritz> (they get an invocant, but it's usually ignored)

[14:23] *** btyler joined
[14:23] *** sivoais left
[14:23] *** sivoais joined
[14:23] <FROGGS> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; my $s := lv(); $s++

[14:23] <camelia> rakudo a134b1: OUTPUT«1␤»

[14:24] <FROGGS> r: my $a = 0; sub lv() is rw { Proxy.new: FETCH => method () { $a }, STORE => method ($n) { $a = $n; say $n } }; my $s := lv(); $s--

[14:24] <camelia> rakudo a134b1: OUTPUT«-1␤»

[14:24] <FROGGS> cool

[14:26] *** SmokeMachine left
[14:27] <colomon> pmichaud: https://github.com/perl6/specs/issues/44

[14:28] <lizmat> r: my %h=a =>1, b=>2; say %h<a b>.kv; say %h<a b>:kv  # confusion about .kv and :kv, .kv does not what you expect on slices

[14:28] <camelia> rakudo a134b1: OUTPUT«0 1 1 2␤a 1 b 2␤»

[14:29] <pmichaud> I can see why others would be confused, but .kv works on lists.

[14:29] <pmichaud> and %h<a b> returns a list.

[14:29] <pmichaud> I don't think the proposed patch "solves" the problem being identified here.

[14:30] *** SmokeMachine joined
[14:31] <lizmat> %h<a b> returns a Parcel

[14:31] <pmichaud> okay, Parcel then.

[14:31] <pmichaud> still, the proposed patch doesn't solve the issue, since it's not .kv on any of Int, Str, etc.

[14:31] *** sivoais left
[14:32] <lizmat> I think it is, by inheritance…  , let me check

[14:32] *** btyler left
[14:32] *** sivoais joined
[14:33] <lizmat> also: I have been looking at the one place to put this in, but couldn't find it.  So in that sense my patch is incomplete / incorrect

[14:33] <pmichaud> Parcel inherits from Any, and Any.kv is defined as { self.list.kv }

[14:33] <pmichaud> which returns to my original statement that .kv works on lists.

[14:34] <lizmat> r: say 1.kv; say "foo".kv

[14:34] <camelia> rakudo a134b1: OUTPUT«0 1␤0 foo␤»

[14:34] <pmichaud> r: say (1, "foo").kv

[14:34] <camelia> rakudo a134b1: OUTPUT«0 1 1 foo␤»

[14:35] <lizmat> it's *those* case, where I think calling .kv doesn't make any sense, and is potentially confusing, I want to die on

[14:35] <lizmat> r: my %h=a=>1; say %h<a>.kv; say %h<a>:kv

[14:35] <camelia> rakudo a134b1: OUTPUT«0 1␤a 1␤»

[14:35] <pmichaud> my point being that those cases have nothing to do with slicing.

[14:35] <moritz> there are lot of cases where we assume that single scalars can behave as lists

[14:35] <lizmat> a one element slice then

[14:36] <moritz> nr: say 42.join('blah')

[14:36] <camelia> rakudo a134b1, niecza v24-51-g009f999: OUTPUT«42␤»

[14:36] <moritz> this is intentional

[14:36] <lizmat> anyway, the confusion between ".kv" and ":kv" bit me, and I thought it could be prevented

[14:37] <PerlJam> lizmat: have you found any other listy methods whose behavior is surprising?  Maybe .kv is just a "special case" here and the right solution is just good documentation.

[14:37] <TimToady> possibly we could detect it syntactically rather than by dispatch

[14:37] <pmichaud> if you want to prevent .kv from working on built-in scalars, then the place to do it will be in either Any or Cool

[14:37] <pmichaud> as opposed to each individual type.

[14:37] <lizmat> well, in the case of .pairs and :p, there is a lot less confusion, as they are not named the same

[14:38] <pmichaud> I'm not opposed to removing method kv from Any.

[14:38] <pmichaud> then one would have to explicitly get a list-ish sort of thing to have it work.

[14:38] <pmichaud> i.e.,   1.list.kv

[14:38] <pmichaud> %h<a>.list.kv

[14:39] <lizmat> that would work also, but I felt that was too drastic a thing to propose  :-)

[14:39] <pmichaud> it's less drastic than sprinkling special-purpose kv methods all over the place :)

[14:40] <lizmat> perhaps, maybe I'm still a bad surgeon

[14:40] <pmichaud> in general, I feel that writing a method to "turn off" a behavior implies a probable misdesign higher in the hierarchy.

[14:40] <lizmat> another way could be to simply rename .kv to .keyvalue

[14:41] <pmichaud> or changing :kv to be :keyvalue

[14:41] <lizmat> adverbial pairs :p :k :v :p would then match .pairs .keys .values .keyvalue

[14:41] *** sivoais left
[14:41] <lizmat> :kv

[14:41] <pmichaud> I think that    for @list.kv { ... }    is a pretty common pattern, though.

[14:41] <pmichaud> I'd hate to de-huffmanize that one.

[14:41] <TimToady> it's bad huffman coding

[14:42] *** sivoais joined
[14:42] *** domidumont left
[14:42] <lizmat> :keyvalue then?  the difference with :p is lost on most people anyway 

[14:42] <lizmat> :-)

[14:43] <PerlJam> pmichaud: it'd just become  for @list[]:kv { ... } wouldn't it?  Not that much different.

[14:43] <PerlJam> :)

[14:43] <TimToady> :㎸

[14:43] <pmichaud> PerlJam: what if @list is actually a method chain producing a list

[14:44] <pmichaud> for $object.something.kv   becomes  for $object.something.list[]:kv       ick ick ick

[14:44] <moritz> please don't make the common use cases any more complicated

[14:44] <lizmat> .u ㎸

[14:44] <yoleaux> U+33B8 SQUARE KV [So] (㎸)

[14:44] <moritz> I use .kv on lists a lot

[14:44] <pmichaud> .kv works everywhere, .adverbial pairs only work on .[]

[14:44] <lizmat> but that's it: I'm not against using .kv on lists per se

[14:44] <Su-Shee> moritz: for the typical item, index pair?

[14:44] <TimToady> I think just disallowing .kv after a subscript syntactically might be the best

[14:44] <lizmat> maybe it *is* just a matter of documentation

[14:45] <moritz> Su-Shee: yes

[14:45] <pmichaud> TimToady: I'm not often fond of syntactic disallows, but I agree in this case.

[14:45] *** rindolf left
[14:45] <TimToady> or warning, with "insert <mumble> to disable this warning"

[14:45] <pmichaud> syntactic disallows get into all sorts of tokenization issues for us :)

[14:45] <Su-Shee> moritz: I _love_ that construct.

[14:45] *** rindolf joined
[14:45] <masak> want to see a C compiler in 728 lines of OCaml? http://c9x.me/qcc/ -- nice!

[14:46] <masak> Su-Shee: yes, me too. I use it all the time.

[14:46] <lizmat> please, please, I'm not against that

[14:47] <moritz> "Inner machinery

[14:47] <moritz> Disgusting. "

[14:47] <masak> :)

[14:47] <masak> the author has high standards.

[14:47] <moritz> :-)

[14:47] <masak> if you read on, he means that he doesn't have much architecture.

[14:47] <lizmat> as TimToady pointed out, that what I hadn't realized, is that it should not work after a subscript

[14:47] <masak> which may be a good thing or a bad thing.

[14:48] <moritz> yes :-)

[14:48] <pmichaud> one could likely use parens to disable the warning

[14:48] <pmichaud> (%h<a>).kv

[14:49] <TimToady> std: .<a>\.kv

[14:49] <camelia> std 8850393: OUTPUT«ok 00:00 41m␤»

[14:49] <TimToady> a method is a postfix, so you can use \

[14:49] <pmichaud> do we do the same for .keys and .pairs, ooc?

[14:49] <pmichaud> i.e.,  %h<a>.keys  warns ?

[14:49] <PerlJam> std: %h<a>().kv

[14:49] <camelia> std 8850393: OUTPUT«===SORRY!===␤Variable %h is not predeclared at /tmp/0idVLuJHSD line 1:␤------> <BOL>⏏%h<a>().kv␤Check failed␤FAILED 00:00 42m␤»

[14:50] <lizmat> perhaps, but the chance for confusion is less as the adverbial counterparts are named differently

[14:50] *** jest1 left
[14:51] *** sivoais left
[14:51] <TimToady> hmm, wonder if :k:v would work

[14:51] *** sivoais joined
[14:51] <lizmat> TimToady: it could

[14:52] <TimToady> since named args are unordered and taken as a lump

[14:52] <lizmat> ( at least the way I now understand )

[14:52] <pmichaud> that kind of implies a :v:k, though.

[14:52] <TimToady> huh? "unordered"

[14:52] <TimToady> :v:k and :k:v are entirely equivalent

[14:52] <pmichaud> well, the name "kv" implies to me  "key then value"

[14:53] <TimToady> I think :v:k would be Doctor it hurts when I think psychotically

[14:53] <TimToady> it's fine it it does the same thing, I think

[14:53] <TimToady> *if it

[14:54] <lizmat> :p:v:k for the truly disturbed ;-)

[14:54] <pmichaud> for %h{@slice}:kv -> $key, $value { ... }

[14:54] <pmichaud> for %h{@slice}:k:v -> $key, $value { ... }

[14:54] <pmichaud> for %h{@slie}:v:k -> $value, $key { ... }

[14:54] <TimToady> you can't suddently make named args have an order

[14:54] <pmichaud> I'm not saying it *should* work that way, just that it's where my mind naturally goes.

[14:55] <lizmat> btw, what's the rationale between having :p *and* :kv ?

[14:55] <lizmat> don't they coerce to the same in the above situation?

[14:55] <moritz> lizmat: both have their use cases

[14:55] <pmichaud> lizmat: it's hard to make the above for loops work with :p

[14:55] <lizmat> ok

[14:55] <moritz> for example :p lets you easily .sort afterwards

[14:55] <TimToady> because we don't have a good siggie unpacker for pairs yet

[14:55] <moritz> because cmp on Pairs compairs first by key, then by value

[14:55] <TimToady> but still thinking we should allow => in a sig

[14:56] <moritz> but unpacking is a bit nastier

[14:56] <moritz> TimToady: that would be nice, yes

[14:56] <TimToady> $head => @tail would become idiom for => lists

[14:56] <moritz> in general, pairs are easier if you have a longer pipe and don't want to separate key and value

[14:56] <lizmat> moritz: gotcha

[14:57] <FROGGS> damn it, now I have a working proxy to call $*OUT.autoflush when $| gets set, but IO::Handle has no autoflush anymore >.<

[14:57] <TimToady> especially if you happen to have stored the hash entries as pairs to begin with

[14:57] <moritz> I often work around the lack of firstidx with  @list.pairs.first(*.value ~~ $Matcher).?key

[14:57] *** REPLeffect joined
[14:57] <moritz> or something similar

[14:57] *** domidumont joined
[14:57] <TimToady> why was autoflush removed?

[14:58] <TimToady> it's a very useful thing

[14:58] <lizmat> r: my %h{Pair}; %h{ a => 1 }= 2; say %h   # ooh, wow

[14:58] <camelia> rakudo a134b1: OUTPUT«(("a" => 1) => 2).hash␤»

[14:58] <pmichaud> anyway, ":kv" and ".kv" have an implicit order in the name, breaking them apart means that some people will think of ".vk" and ":v:k".  Again, I'm not advocating for ":v:k" doing value, key order... but I can see people asking why it gets the order wrong.

[14:58] <TimToady> well, I'm still thinking a syntactic warning is best, and leave it at :kv for now

[14:59] <pmichaud> works for me.

[14:59] <TimToady> leaves open the possibility of .vk and :vk too

[15:00] <masak> +1 on all counts

[15:00] *** sivoais left
[15:00] <masak> I've sometimes felt the need for .vk

[15:00] <lizmat> I will close my pull request

[15:00] *** rindolf left
[15:00] <masak> it happens when you reverse lists.

[15:00] *** rindolf joined
[15:00] *** sivoais joined
[15:05] * PerlJam wonders what people will think of  :v:p:k  or :p:k:v

[15:06] <lizmat> rn: my %h=a=>1,b=>2; say %h<a b>:exists

[15:06] <camelia> niecza v24-51-g009f999: OUTPUT«True True␤»

[15:06] <camelia> ..rakudo a134b1: OUTPUT«Cannot use exists adverb with a slice␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1688␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1642␤  in block  at /tmp/M5Jztdk00E:1␤␤»

[15:06] <lizmat> rakudo dies for some reason, not according to spec

[15:07] <lizmat> fixed in pull #150, but that depends on #149, allowing for :!exists

[15:07] * masak looks at #149

[15:09] *** sivoais left
[15:09] <masak> haha, ':$delete! where so $delete' :)

[15:09] <lizmat> I didn't make that one up, pmichaud did!

[15:09] <lizmat> or was it jnthn?

[15:10] *** sivoais joined
[15:10] <lizmat> the "so" is needed, because for some reason :delete(0) was also handled by that candidate

[15:10] <masak> yes, of course.

[15:10] <masak> as long as you pass anything...

[15:10] <TimToady> PerlJam: if there are no candidates that accept multiple named args, the dispatch simply fails

[15:11] <masak> anyone oppoed to me merging https://github.com/rakudo/rakudo/pull/149 ?

[15:11] <masak> I've code-reviewed it and it looks good. I'm simply assuming lizmat++ has spectested it.

[15:11] <lizmat> I don't put in pull requests unless I spectested then

[15:11] <masak> right.

[15:11] <PerlJam> lizmat++

[15:12] <lizmat> I will mention that in the future

[15:12] <masak> lizmat: I won't ask "did you spectest" any more, since you seem to always do that.

[15:12] <dalek> rakudo/nom: 5e360a6 | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[15:12] <dalek> rakudo/nom: Make :exists and :delete up to spec

[15:12] <dalek> rakudo/nom: 

[15:12] <dalek> rakudo/nom: The :exists and :delete adverbial pairs on hash accesses were always

[15:12] <dalek> rakudo/nom: interpreted as "true".  Which makes constructs as :!exists or :delete($really)

[15:12] <dalek> rakudo/nom: not work.

[15:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5e360a6fa2

[15:12] <dalek> rakudo/nom: 8c30c2e | (Carl Mäsak)++ | src/core/Any.pm:

[15:12] <dalek> rakudo/nom: Merge pull request #149 from lizmat/adverbialexistsdelete

[15:12] <dalek> rakudo/nom: 

[15:12] <dalek> rakudo/nom: Make :exists and :delete up to spec

[15:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c30c2e295

[15:16] <FROGGS> looks like parrot has no autoflush either -.-

[15:16] <lizmat> I guess I'm doing too many pull requests: there's also #145..148, 150, 152  :-)

[15:16] <dalek> std: 0336087 | larry++ | STD.pm6:

[15:16] <dalek> std: add warning for .kv after subscript

[15:16] <dalek> std: review: https://github.com/perl6/std/commit/033608798d

[15:17] <moritz> lizmat: no, we are too slow to process them

[15:18] *** sivoais left
[15:19] <lizmat> while we were on the matter of combining adverbial pairs, what is the feeling about :p:delete actually deleting *and* returning pairs ?

[15:19] *** sivoais joined
[15:19] *** rindolf left
[15:19] *** rindolf joined
[15:20] <moritz> +1

[15:20] <masak> I have no qualms against any of those combinations between :delete and other things.

[15:20] <masak> :delete:exists can be useful, too.

[15:20] <lizmat> that would not work

[15:20] <masak> this is the nice thing about adverbial pairs. they can do many things at once. and quite readably/naturally, too, if you ask me.

[15:20] <masak> why not?

[15:20] <TimToady> as long as performance dosn't suffer, I'm okay with it

[15:21] <lizmat> :delete is specced to return the value (or the pair in case of :p) while :exists is specced to return boolean

[15:21] <masak> lizmat: oh, I was simply assuming that the :exists return value wins, but the deletion still happens.

[15:21] <TimToady> well, if it's dispatching to a different method, it can return something different too

[15:22] <masak> lizmat: similarly with :delete:p, the :p return value wins.

[15:22] <TimToady> we might want to relax the rule that there can only be one subscript on :exists though, if we wanted a vector of bools back

[15:22] <lizmat> that is what is specced: a vector of bools

[15:22] <lizmat> masak: good point

[15:22] <masak> TimToady: I thought that's... what lizmat said.

[15:22] <masak> Niecza already does that, fwiw.

[15:23] <moritz> .oO( lizmat lecturing TimToady about the specs! Yay! )

[15:23] <lizmat> #150 would bring it up to spec

[15:23] * masak looks at #150

[15:23] <TimToady> S02:2497 says :exists may not have multiple subscripts

[15:24] * masak looks

[15:24] <pmichaud> lizmat: just for clarification...   sub xyz(:$delete!) { ... }    means "is the delete adverb present"  without making any test of its boolean-ness.

[15:24] <masak> TimToady: oh, I wrote that.

[15:25] <masak> TimToady: https://github.com/perl6/specs/commit/3018ff242a8e8277d6acac365f875603922ebc96

[15:26] <lizmat> S32/Containers:680 "If a slice is specified by the subscript, a C<Parcel> of C<Bool> is returned, which can be processed using junctions."

[15:26] <pmichaud> heh.  Yes, we're now arguing for "slice semantics" for :exists :)

[15:26] <TimToady> the specs collapse into a black hole

[15:27] <masak> TimToady: I remember finding use cases where people assumed 'all' semantics, and use cases where people assumed 'any' semantics. and it all felt so weird because that's what we have junctions for.

[15:27] <pmichaud> as opposed to any or all semantics.

[15:27] <masak> TimToady: I think I still stand by that notion.

[15:27] <pmichaud>     (%h{@a}:exists).any   # any semantics

[15:27] *** sivoais left
[15:27] <pmichaud>     (%h{@a}:exists).all  # all semantics

[15:28] <pmichaud> or, even naturally as      all %h{@a}:exists

[15:28] <masak> *nod*

[15:28] <masak> yeah, that works.

[15:28] <masak> I'm for it, I think.

[15:28] <TimToady> well, a slice of two or more would always be true

[15:28] <TimToady> the Q is whether it should just be erroneous

[15:29] <TimToady> or whether we should hold their hand

[15:29] *** sivoais joined
[15:29] <pmichaud> TimToady: that confused me.

[15:29] <TimToady> if we want the chainsaw power, we have to allow people to saw off their limbs accidentally

[15:30] <TimToady> Texans should understand about chainsaws...

[15:30] <pmichaud> I don't understand "a slice of two or more would always be true"

[15:30] <TimToady> oh, wait, that was on purpose... :)

[15:30] <TimToady> r: say so (False,False)

[15:30] <camelia> rakudo a134b1: OUTPUT«True␤»

[15:30] <pmichaud> ah.

[15:31] <pmichaud> r: say so any (False,False)

[15:31] <camelia> rakudo a134b1: OUTPUT«False␤»

[15:31] <pmichaud> okay.

[15:31] <TimToady> .[@slice]:exists can return (False,False), basically

[15:31] <TimToady> if we allow slicing

[15:31] <pmichaud> thanks for the clarification, I understand now.

[15:31] <pmichaud> I'm still not fully into p6-think after the trip yet, and I'm several weeks out of discussions

[15:32] <TimToady> .oO(does the CoC say anything about Texas Chainsaws?)

[15:32] <pmichaud> .oO(and would it apply to conferences held in Texas?)

[15:32] <lizmat> only when threatened to be used

[15:32] <lizmat> on somebody else

[15:32] * pmichaud wonders what characters/glyphs should be used for the "chainsaw operator"

[15:32] <pmichaud> you know we have to have one, now.

[15:32] <TimToady> .oO(pmichaud is still thinking robotically...)

[15:33] <pmichaud> I'm thinking LEGO-ly.

[15:33] <dalek> rakudo/nom: 267c54c | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[15:33] <dalek> rakudo/nom: Allow slice with :exists adverb on hashes

[15:33] <dalek> rakudo/nom: 

[15:33] <dalek> rakudo/nom: For some reason a "die" was here, whereas the spec says it should return a

[15:33] <dalek> rakudo/nom: Parcel of Bool.

[15:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/267c54c11e

[15:33] <masak> lizmat: please check that; I had to do a local conflict resolve.

[15:33] <TimToady> pmichaud: then you must LEGO of your preconceptions

[15:34] <masak> free your MindStorm.

[15:34] <TimToady> don't be a brick

[15:34] <lizmat> the conflict is because #148 is not done yet...

[15:35] <masak> lizmat: oh! you said #149 :(

[15:35] <lizmat> 148 is something else  :-)

[15:35] <masak> anyway, I'm assuming I got it right unless you say otherwise.

[15:36] <arnsholt> It's good lizmat is hacking on Rakudo, 'cause I think the rest of us are busy making puns =D

[15:36] <pmichaud> https://picasaweb.google.com/lh/photo/c6ou2_XjmWqK0o2ibe9-8upyL0EFYZnLKar5NjDOAMY?feat=directlink

[15:36] <TimToady> lizmat: so it's okay to cut someone up with a chainsaw as long as they don't feel threatened? :)

[15:37] *** sivoais left
[15:38] *** gdey left
[15:38] <lizmat> TimToady: only if they consent

[15:38] *** sivoais joined
[15:38] <masak> chainsawing without asking is such a faux pas.

[15:39] *** rindolf left
[15:39] <arnsholt> Wow. Running a program in gdb with the record option is really, really, really slow

[15:39] * arnsholt idly wonders which is slower of gdb with record or valgrind

[15:39] *** rindolf joined
[15:42] *** domidumont1 joined
[15:43] *** kaleem left
[15:43] <TimToady> std: .[].kv

[15:43] <camelia> std 0336087: OUTPUT«Potential difficulties:␤  Suspicious .kv after subscript; to suppress this warning, use :kv or \.kv instead at /tmp/9LENy8Kvh2 line 1:␤------> .[]⏏.kv␤ok 00:00 42m␤»

[15:44] <arlinius> rss

[15:44] <lizmat> TimToady++

[15:44] <arlinius> oops, sorry

[15:44] * TimToady looks for that chainsaw glyph

[15:44] <TimToady> (to use on the backlog)

[15:46] <masak> arlinius: I hear it's all Atom these days, though. except that Google Reader is shutting down. :/

[15:46] *** domidumont left
[15:46] <moritz> and Germany shuts down its Atomkraftwerke :-)

[15:46] <Su-Shee> masak: I basically moved away from any google service.

[15:46] <Su-Shee> moritz: well if we've had RSSkraftwerke...

[15:47] <moritz> (for some stupid reason, Germans usually talk about 'atom' instead of 'nuclear' power plants)

[15:47] *** sivoais left
[15:47] <moritz> Su-Shee: :-)

[15:47] <lizmat> with :exists now returning a Parcel of Bool, I guess S02:2497 needs to be amended.  

[15:47] <lizmat> but I'm at a loss for a wording there

[15:47] <clkao> 0o^W^W^W/win 21

[15:48] *** sivoais joined
[15:48] <TimToady> lizmat: feel free to amend it

[15:48] <masak> clkao: thanks for stopping by! enjoy windows 21! :P

[15:48] <masak> window*

[15:49] <clkao> heh

[15:49] *** kaare_ joined
[15:49] <masak> afk &

[15:49] <lizmat> TimToady: will have a go at it

[15:50] *** domidumont1 left
[15:50] <TimToady> on users mis-inferring any/all, we have the same problem with 'when @foo', so I think people will just have to learn the hard way

[15:52] <PerlJam> heh.  "suspicious .kv"  I like that wording.  :)

[15:52] *** domidumont joined
[15:53] *** domidumont left
[15:55] *** risou is now known as risou_awy

[15:55] *** risou_awy is now known as risou

[15:56] *** domidumont joined
[15:56] *** sivoais left
[15:56] <lizmat> TimToady: I think I have to learn "when @foo" the hard way myself still

[15:57] *** sivoais joined
[15:59] <tadzik> Su-Shee: (google services), well, they're closing (closed?) xmpp recently, so probably gmail is going to be closed to other smtp servers soon too ;)

[16:01] *** rindolf left
[16:01] *** rindolf joined
[16:02] <Su-Shee> tadzik: I'm using gmail only for junk emailadresses anyways.

[16:05] <tadzik> I also have an account linked to android phone. I should really deprecate the regular gmail, since I have a separate (paid) account for over 2 years now

[16:05] *** hypolin left
[16:06] *** sivoais left
[16:06] *** daxim left
[16:06] *** saxx11 joined
[16:06] *** sivoais joined
[16:07] <Su-Shee> tadzik: well I started using my nokia N9 again and will buy a geekphone soon, so that's the android issue. :)

[16:07] <tadzik> Su-Shee: yeah, I know. It's just that I didn's see any smartphone I wanted on the market, so I bought a cheap android. "It can't be that bad!"

[16:07] <tadzik> well, it can.

[16:08] <tadzik> and since fx has this annoying "why turn off your apps?" trait too, I don't think I'd want it either

[16:08] <tadzik> I'll wait for jolla with hw keyboard :)

[16:09] <Su-Shee> tadzik: have you seen the new jolla?

[16:09] <tadzik> yes. It has no hw keyboard

[16:09] *** prevost joined
[16:09] <tadzik> which, by my standards, make it a pretty useless toy

[16:09] <Su-Shee> I'm pretty sure there won't be any phone with hw keyboards anymore ;)

[16:09] <tadzik> although the os is very nice

[16:09] <Su-Shee> the phone is beautiful. :)

[16:10] <tadzik> I think there will be, the old ceo of jolla implied that too

[16:10] <tadzik> "there's a market for business oriented phones" (speaking of hw keyboards)

[16:10] <tadzik> gosh, when did I become a business person

[16:10] <FROGGS> github is down

[16:10] <tadzik> https://status.github.com/

[16:12] <lizmat> that went from minor to major in 2 mins

[16:13] *** risou is now known as risou_awy

[16:14] *** zby_home_ joined
[16:15] *** sivoais left
[16:16] *** sivoais joined
[16:17] <lizmat> masak: seems sivoais needs to be kicked here as well

[16:18] *** ChanServ sets mode: +o masak

[16:19] *** hypolin joined
[16:19] *** masak sets mode: +b sivoais!~zaki@unaffiliated/sivoais

[16:19] *** sivoais was kicked by masak (sivoais))
[16:19] *** ChanServ sets mode: -o masak

[16:19] *** FROGGS left
[16:20] <lizmat> r: say any <a b c>

[16:20] <camelia> rakudo a134b1: OUTPUT«any(a, b, c)␤»

[16:21] <lizmat> r: say so any <a b c>  # does this make any sense at all?

[16:21] <camelia> rakudo a134b1: OUTPUT«True␤»

[16:21] <masak> TimToady: re 'the hard way': in some sense learning what the semantics should be for 'when @foo' was hard for Perl 6 the spec (and its authors) as well, not just the users. smartmatching was very helped by doing a few turns in the whirlpool.

[16:21] <masak> lizmat: sure it does.

[16:21] <masak> r: say so any (False, False, False)

[16:21] <camelia> rakudo a134b1: OUTPUT«False␤»

[16:22] <masak> lizmat: you just need to pass in values that can be falsy :)

[16:22] <lizmat> ok, maybe I wasn't clear

[16:22] <masak> r: say so "lizmat" eq any <moritz TimToady pmichaud>

[16:22] <camelia> rakudo a134b1: OUTPUT«False␤»

[16:22] <masak> r: say so "lizmat" eq any <moritz TimToady lizmat pmichaud>

[16:22] <camelia> rakudo a134b1: OUTPUT«True␤»

[16:23] <lizmat> I meant *exactly* "any <a b c>" as part of %h{ any <a b c> }:exists

[16:23] *** rindolf left
[16:23] *** rindolf joined
[16:24] <lizmat> I guess this means auto-threading the :exists on the given keys then

[16:24] *** Su-Shee left
[16:24] <lizmat> and "any %h<a b c>:exists" wouldn't do that ?

[16:25] <lizmat> well, I guess it would, but it would have had to look up all keys specified in the hash

[16:25] <lizmat> first before being able to auto-thread, right?

[16:25] *** REPLeffect left
[16:26] <PerlJam> Junction-as-subscript doesn't make sense to me, but I don't quite have the junction-fu that others have.

[16:28] <masak> lizmat: I think under the new spec (where :exists works on slices), both variants work.

[16:29] <masak> lizmat: the %h{ any <a b c> }:exists variant passes a junction to .{}, which promptly autothreads.

[16:29] <masak> lizmat: the any %h<a b c>:exists variant returns a vector of Bool, which gets stuffed in an any junction.

[16:29] <lizmat> but differently from other contexts, it would have to do *all* alternatives to be able to return a Parcel of Bool

[16:30] <masak> junctions always do.

[16:30] <masak> at least you're not allowed to assume they don't.

[16:30] <timotimo> tadzik: don't forget to pull in the newest File::Tools into panda and panda2

[16:30] <masak> junctions are hyper, not lazy.

[16:30] <dagurval> r: my %h = <a 1>; say ~%h<d>:delete;

[16:30] <camelia> rakudo a134b1: OUTPUT«Unexpected named parameter 'delete' passed␤  in sub prefix:<~> at src/gen/CORE.setting:1271␤  in block  at /tmp/KEJtJd7URf:1␤␤»

[16:30] <tadzik> timotimo: thanks, I'll try to remember :)

[16:31] <masak> hyper as in "1e6 computation nodes in hyperspace may distributedly handle this task" :P

[16:31] <lizmat> masak: I thought the idea of "any" would be that it could disregard any alternatives as soon as it found the first True one ?

[16:32] <masak> lizmat: no, you're thinking of something else.

[16:32] <masak> maybe reduction with [||], which shortcuts.

[16:33] <masak> short-circuits*

[16:33] <masak> lizmat: or, I should say, the optimizer is allowed to make the junction code as efficient as it pleases, including short-circuiting. (as long as it doesn't get caught.)

[16:34] <PerlJam> lizmat: that version of any sounds like what you'd get from List::MoreUtils.

[16:34] <masak> but there isn't the *assumption* in junctions that they will short-circuit.

[16:34] *** REPLeffect joined
[16:34] <lizmat> ok. so it is considered a compiler optimization...

[16:35] <lizmat> ok, I can live with that  :-)

[16:35] <timotimo> in very specific cases, junctions already will short-circuit

[16:35] <lizmat> (or rather, run-time optimization)

[16:36] <timotimo> r: sub gen() { say "generated a value"; True }; if True == gen | gen | gen | gen | gen { say "yay" };

[16:36] <camelia> rakudo a134b1: OUTPUT«===SORRY!===␤Missing block␤at /tmp/ENgjmJJpfZ:1␤------> en | gen | gen | gen | gen { say "yay" }⏏;␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modifier loop␤        ho…

[16:36] *** Chillance joined
[16:36] <timotimo> er, whoops?

[16:36] *** SmokeMac_ joined
[16:36] <timotimo> r: sub gen() { say "generated a value"; True }; if True == gen() | gen() | gen() | gen() | gen() { say "yay" };

[16:36] <camelia> rakudo a134b1: OUTPUT«generated a value␤yay␤»

[16:36] <timotimo> r: sub gen() { say "generated a value"; True }; if gen() | gen() | gen() | gen() | gen() { say "yay" };

[16:36] <camelia> rakudo a134b1: OUTPUT«generated a value␤generated a value␤generated a value␤generated a value␤generated a value␤yay␤»

[16:36] <timotimo> hm, actually that could be optimized, too

[16:37] *** rindolf left
[16:37] <ingy> r: a-b = 42

[16:37] <camelia> rakudo a134b1: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead␤at /tmp/KAo2Rda9e2:1␤------> a-b =⏏ 42␤»

[16:37] *** SmokeMachine left
[16:37] *** rindolf joined
[16:38] <timotimo> ingy: needs a "my"

[16:38] <timotimo> and a sigil

[16:38] <timotimo> or a-b must be a function that returns an lvalue

[16:38] <PerlJam> timotimo: but what would %h{any <a b c>}  mean?  is it the same as "any %h<a b c>" ?  If so, why evan allow the former?

[16:38] <ingy> r: my $a-b = 42

[16:38] <camelia> rakudo a134b1:  ( no output )

[16:38] <PerlJam> s/evan/even/

[16:38] <ingy> r: my $a-b = 42; say $a-b

[16:38] <camelia> rakudo a134b1: OUTPUT«42␤»

[16:38] <timotimo> PerlJam: it will compute to the same value, doesn't make it necessary to forbid one

[16:39] <timotimo> PerlJam: "what would 5 + 5 mean? is it the same as 10? if so, why even allow the former?" is almost the same statement

[16:39] <jnthn> evening, ##perl6

[16:39] * ingy just added - to pegex identifiers

[16:39] <PerlJam> timotimo: maybe.  Still, junctions-as-subscript seem ... weird.

[16:39] <ingy> they compile to _, which is necessary

[16:39] <jnthn> wow, this train wifi is dubious..

[16:39] <lizmat> PerlJam: the way I read it, "%h{ any <a b c> } :exists" in a boolean context, would allow the runtime to skip testing of existence for keys as soon as it found one

[16:40] <ingy> hi jnthn 

[16:40] <masak> jnthn! \o/

[16:40] <timotimo> i don't see why it would be weird. i can use junction as any value and it will hopefully autothread

[16:40] <lizmat> PerlJam: "any %h<a b c>:exists" would have to create a boolean for each key checked, and then autothread on that result

[16:40] *** spider-mario joined
[16:41] <lizmat> for large hashes, and large sets of keys, %h{ any <a b c> }:exists in boolean context, could be a big win

[16:41] <PerlJam> maybe I just have "junctions" somehow hard-wired to "boolean context" in my brain.

[16:42] *** GlitchMr left
[16:42] *** dmol joined
[16:42] <lizmat> PerlJam: well, yes, without the :exists adverb, it would presumably just check the key

[16:43] <timotimo> r: say ("PerlJam" | "Timo") ~ " loves junctions" == "Timo loves junctions"

[16:43] <camelia> rakudo a134b1: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏PerlJam loves junctions' (indicated by ⏏)␤  in method Numeric at src/gen/CORE.setting:10055␤  in sub infix:<==> at src/gen/CORE.setting:3023␤  in sub infix:<==> at src/gen/CORE…

[16:43] <timotimo> r: say ("PerlJam" | "Timo") ~ " loves junctions" eq "Timo loves junctions"

[16:43] <camelia> rakudo a134b1: OUTPUT«any(False, True)␤»

[16:43] <PerlJam> lizmat: what does "check the key" mean?

[16:43] <lizmat> check the existence of the key

[16:43] <PerlJam> lizmat: without the :exists?

[16:44] <lizmat> ah, no *with* the exists, without the :exists it would check booleannes of the key, presumably?

[16:44] *** GlitchMr joined
[16:44] <lizmat> which would not make a lot of sense

[16:44] <timotimo> r: say ("Perl Jam" & "Timo") ~ (" foo" | " bar") # :P

[16:44] <camelia> rakudo a134b1: OUTPUT«all(any(Perl Jam foo, Perl Jam bar), any(Timo foo, Timo bar))␤»

[16:45] <timotimo> hm, this could use some quotes

[16:45] <lizmat> r: say (("Perl Jam" & "Timo") ~ (" foo" | " bar")).perl

[16:45] <camelia> rakudo a134b1: OUTPUT«all(any("Perl Jam foo", "Perl Jam bar"), any("Timo foo", "Timo bar"))␤»

[16:45] <PerlJam> just %h{any <a b c>} by itself is just another junction.  The unobserved state of a maybe-dead/maybe-live cat.

[16:46] <lizmat> timtimo: that was just .gist

[16:46] <lizmat> "any <a b c>" with the exact string "<a b c>" would be an alive cat at compile time

[16:48] <lizmat> or am I wrong?

[16:48] * lizmat may have different ideas about junctions than what is implemented / specced in Perl 6

[16:49] *** gdey joined
[16:49] <timotimo> oke

[16:49] <PerlJam> I think the difficulty I'm having is that junctions require a verb to be "observed", but "subscript" or "slice", though verby, still doesn't produce an observation unless and until you add an adverb.

[16:49] <timotimo> lizmat: it could be compile-time-evaluated to Any(a, b, c, d), indeed

[16:49] <timotimo> PerlJam: it doesn't observe, it mutates, like any(...) + 5

[16:50] <timotimo> lizmat: if it's in boolean context, like if any(<a b c d>), it could be evaluated to True, sure

[16:51] <PerlJam> lizmat: any <a b c> is still a cat of indeterminant disposition.

[16:51] *** GlitchMr left
[16:54] *** ajr_ left
[16:54] *** sdgvf_ left
[16:55] <lizmat> timotimo, PerlJam: ok, you're right.  I was just thinking boolean context.  In any other context I guess you cannot tell whether the cat is alive or dead  :-)

[16:57] <timotimo> right, since the deadness/aliveness is actually a boolean value ;)

[16:57] <timotimo> at least definite deadness/aliveness is

[16:59] <PerlJam> so back to %h{any <a b c>}:exists  ...  to me the intent of "any %h<a b c>:exists" is clearer than the other

[16:59] *** dakkar left
[16:59] <masak> PerlJam: I can see that.

[16:59] <masak> PerlJam: would you be bothered by both working?

[17:00] <PerlJam> I dunno.   right now I seem to be bothered by junctions as subscripts

[17:00] <lizmat> then use that, by all means, but %h{any <a b c>}:exists may give better performance on large hashes / sets of keys

[17:00] <lizmat> potentially, if the runtime supports it

[17:00] *** GlitchMr joined
[17:00] <lizmat> at least the way I understand things  :-)

[17:02] <PerlJam> What would %h{ any <a b c> }:delete do? 

[17:02] <timotimo> it would autothread to delete each of the keys - but depending on the outer context, an optimizer might short-circuit after the first True it gets!

[17:02] <masak> but do not assume that an optimizer will do this.

[17:03] <lizmat> ah, but that would be catching the optimizer!

[17:03] <masak> and since this has a side effect, it's your fault, the user's, if it does.

[17:03] <lizmat> optimizer may only optimize when it doesn't get caught, right?

[17:03] <masak> Perl 6 does not have a notion of what has a side effect and what doesn't.

[17:03] <masak> and in either case, reasoning about such things is Halting Problem complete.

[17:04] <timotimo> indeed

[17:04] *** FROGGS joined
[17:04] <PerlJam> timotimo: and I suppose the same answer applies to %h{any <a b c>}:k  and  %h{any <a b c>}:v and  :p  ?

[17:04] *** rindolf left
[17:04] <timotimo> sure

[17:04] *** rindolf joined
[17:05] <timotimo> r: my %h = (1, 2, 3, 4) Z=> <a b c d>; say %h{any(1, 2, 3)}:k; say %h{any(1, 2, 3)}:v;

[17:05] <camelia> rakudo a134b1: OUTPUT«any(1, 2, 3)␤any(a, b, c)␤»

[17:07] *** GlitchMr left
[17:08] *** GlitchMr joined
[17:08] *** gdey_ joined
[17:11] <PerlJam> So ... if I reject the notion of the optimizer short-circuiting Junctions based on truthiness, I think I'm warming up to junctions as subscripts :)

[17:12] <masak> \o/

[17:12] <lizmat> fwiw, the examples in S02:2492 all are in a boolean context

[17:13] <masak> I basically only use junctions in a boolean, fairly static context.

[17:13] *** gdey left
[17:13] <masak> I only have one use case where I don't.

[17:13] <masak> (I once stored an and-junction of two regex objects in a hash table. easier than writing one single, more complicated, regex)

[17:16] *** ajr joined
[17:17] *** ajr is now known as Guest67735

[17:17] <PerlJam> I assume that junctionizes $/ and its captures when you use the junction of multiple regex.

[17:17] *** Guest67735 is now known as ajr_

[17:20] <timotimo> that would seem sensible at first glance at least

[17:20] <timotimo> hm, actually, no, how would that work?

[17:20] <dalek> v5: 7490b31 | (Tobias Leich)++ | lib/Perl5/Terms.pm:

[17:20] <dalek> v5: add infix ||=

[17:20] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/7490b31a5e

[17:20] <dalek> v5: f323dd8 | (Tobias Leich)++ | / (4 files):

[17:20] <dalek> v5: add (not yet working) autoflush $|

[17:20] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f323dd8b00

[17:20] <colomon> how would it .... what timotimo said

[17:20] <timotimo> i fear autothreading would just set $/ to the last thing that was evaluated

[17:20] * PerlJam notes that Junction does not appear in the table for the smart match op  :)

[17:20] <masak> PerlJam: I was only interested in the boolean value, so collapsed the junction.

[17:20] <timotimo> where is that?

[17:20] <masak> PerlJam: but it did work.

[17:21] <masak> ooh, I remembered where I used it even: http://strangelyconsistent.org/blog/some-perlmonks-password-statistics

[17:21] <masak> source code here: https://gist.github.com/masak/158336

[17:21] <masak> lines 15..22

[17:24] *** rindolf left
[17:24] *** rindolf joined
[17:26] <masak> they're used on L34, in an if statement which only cares about the boolean collapsed result.

[17:26] *** gudahtt left
[17:26] *** yoleaux left
[17:26] *** fhelmberger left
[17:26] * PerlJam lunch &

[17:27] <timotimo> that's a pretty simple solution actually. cool.

[17:27] *** prammer left
[17:27] <lizmat> seems network problems, we lost yoleaux

[17:27] *** GlitchMr left
[17:27] *** yoleaux joined
[17:27] *** dpk left
[17:28] <timotimo> [<alpha>*\d]**2 <alpha> - lines like these might have benefitted from the % operator, no?

[17:28] <colomon> rn: my $r = /<alpha>/ & /<digit>/; say "a" ~~ $r; say "a9" ~~ $r

[17:28] <camelia> rakudo 267c54, niecza v24-51-g009f999: OUTPUT«False␤True␤»

[17:29] <masak> timotimo: yeah. this is fours years ago.

[17:29] *** davidpk joined
[17:29] <timotimo> ah, ok :)

[17:30] *** s1n left
[17:30] <lizmat> dinner&

[17:30] *** gdey_ left
[17:31] *** gdey joined
[17:31] <masak> and, though infix:<**> filled that role back then, it appears I didn't see that option.

[17:31] <masak> maybe I was building things incrementally and this just made the most sense. I dunno.

[17:31] *** davidpk is now known as dpk

[17:33] <timotimo> i feel kind of like it would have been better to .comb for non-alnums and count the result than to make a regex that alternates non-alnums with alnums

[17:34] <masak> oh, feel free to write a better solution as you concieve it, and post it here. might be interesting.

[17:35] <colomon> would be interesting, definitely.

[17:36] <masak> in fact, I feel tempted to write a new version myself, too.

[17:36] <masak> of course, I no longer have the original data...

[17:40] *** yoleaux left
[17:41] <masak> nvm, found it.

[17:41] *** yoleaux joined
[17:42] *** gdey left
[17:43] *** stevan_ left
[17:44] *** rindolf left
[17:45] *** rindolf joined
[17:48] <dalek> perl6-roast-data: ed9214f | coke++ | p (2 files):

[17:48] <dalek> perl6-roast-data: today (automated commit)

[17:48] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ed9214fc70

[17:50] *** bowtie left
[17:50] *** gdey joined
[17:50] *** gudahtt joined
[17:53] *** gudahtt left
[17:57] *** gdey left
[17:58] *** stevan_ joined
[18:11] *** rindolf left
[18:11] *** rindolf joined
[18:12] *** stevan_ left
[18:12] *** GlitchMr joined
[18:14] <masak> rn: my $rx = 'a+'; say 'aaa' ~~ /^ $rx $/; say 'aaa' ~~ /^ <$rx> $/

[18:15] <camelia> rakudo 267c54, niecza v24-51-g009f999: OUTPUT«Nil␤｢aaa｣␤␤»

[18:15] <masak> ah.

[18:16] *** stevan__ joined
[18:17] *** grondilu joined
[18:21] <masak> modern version: https://gist.github.com/masak/5622039

[18:21] <masak> 10 lines shorter, and IMO more readable.

[18:21] <masak> doesn't run in Rakudo, though. :/

[18:23] <jnthn> Why not?

[18:24] <jnthn> oh, the ** {$n+1}  thing

[18:27] <masak> yeah, and the "get_attr_str() not implemented in class 'Coroutine'" error

[18:28] <masak> for some reason.

[18:30] *** japhb_ joined
[18:31] <sorear> o/

[18:31] <masak> sorear! \o/

[18:33] *** rindolf left
[18:33] <masak> sorear: all finitely generated abelian groups are products of cyclic groups Z_{p^n}, p prime, and at most one Z. that's freaky. :)

[18:33] *** rindolf joined
[18:33] <masak> I was idly doodling group structures today when I discovered it. "hey, wait a minute... they're all cycles!"

[18:35] *** stevan__ left
[18:35] <japhb_> "I was idly doodling group structures today"...

[18:35] <japhb_> :-)

[18:36] <masak> what? :P

[18:37] <masak> some of the p6cc problems have come about by me idly doodling at $work meetings... :)

[18:38] <jnthn> hah, I should pay moe attention to your doodlings :P

[18:38] <masak> :)

[18:39] <masak> when tadzik and I were vacationing in Białowieża two years back, I was doodling Platonic solids.

[18:41] <masak> jnthn: replaced {$n+1} with precalculated variable $n1. https://gist.github.com/masak/5622039 -- that should work already, no?

[18:43] <grondilu> camelia: multi postfix:<++>(int $n is rw) { $n = $n + 1 }; my int $n = 0; $n++; say $n;

[18:43] <grondilu> rn: multi postfix:<++>(int $n is rw) { $n = $n + 1 }; my int $n = 0; $n++; say $n;

[18:43] <camelia> rakudo 267c54: OUTPUT«0␤»

[18:43] <camelia> ..niecza v24-51-g009f999: OUTPUT«===SORRY!===␤␤In parameter declaration, typename 'int' must be predeclared (or marked as declarative with :: prefix) at /tmp/fSJmQ6iEYm line 1:␤------> multi postfix:<++>(int⏏ $n is rw) { $n = $n + 1 }; my int $n = ␤␤Pa…

[18:44] <masak> Niecza doesn't have 'int' yet.

[18:45] <jnthn> masak: It's any non-litreal with ** that is NYI. If we could support ** $n already, the closure form would be easy. 

[18:45] <jnthn> masak: It's extending the regex engine to handle not knowing those counts up front that is the tricky task.

[18:46] <masak> oh :/

[18:46] <masak> yeah, then that patch doesn't help.

[18:47] <PerlJam> masak: just use macros  ;)

[18:47] <masak> :P

[18:47] <moritz> I guess it has to delay the compilation until it knows the number of repetitions

[18:47] <masak> yeah.

[18:47] <masak> at least if we want it to be an NFA.

[18:48] <jnthn> I'm...not sure we can do that...

[18:48] <masak> and not, say, a <?{ ... }> condition.

[18:48] <jnthn> I wasn't thinking of it ever being declarative.

[18:48] <jnthn> Except perhaps in the case of compile time constants.

[18:48] <masak> no, maybe declarative is wishful thinking.

[18:49] <jnthn> It's just that the quant rule is already one of the most complex ones already, so adding a more dynamic version would be a little fun :)

[18:49] <masak> tell me about it.

[18:49] <masak> always the quant tests failed when I was implementing GGE. all. the. time.

[18:49] <jnthn> masak: It's just htat... :P

[18:50] <masak> [tell me about it] ** $n

[18:50] <jnthn> Well, could be a good hackathon task...

[18:50] * masak *grins*

[18:50] <sorear> masak: you can have more than one Z

[18:51] <masak> sorear: yeahbut. isn't Z^n isomorphic to Z?

[18:51] <nwc10> jnthn: total digression - as to "agressive" optimising of variables, and trying to put them on the stack - surely Perl 6 is a dynamic language, so it's just fine to have a guard clause to project the "fast" version of the code, and keep the slow version around and use it if "OUTER" (or whatever) has been seen. (Or some other flag for "privacy has been violated") 

[18:51] <sorear> https://en.wikipedia.org/wiki/Structure_theorem_for_finite_abelian_groups#Classification

[18:51] <sorear> masak: no.  Z^2 does not have a one-element generating set

[18:51] <masak> sorear: was just gonna send you that link.

[18:52] <masak> but yes, I see that you're right.

[18:52] <masak> ah, and I guess that's where all those funky lattices come from. I was wondering about them.

[18:52] <masak> sorear++

[18:53] <jnthn> nwc10: Perl 6 isn't really a dynamic language, it's a gradual one. So "don't be so aggresive" tends to be a pragmatic thing. Especially when it's a lexically scoped thing.

[18:53] <jnthn> nwc10: We can detect use of OUTER statically, so that's not an issue.

[18:54] <sorear> it's never possible to generate Z^j with i elements, i < j.  proof: extend Z^j to the vector space R^j.  your i elements span an i-dimensional subspace, so cannot include Z^j which spans the whole space

[18:55] <jnthn> nwc10: The question is if there's anything we can't detect up front that scuppers it.

[18:55] <masak> sorear: still, there's very "few" kinds of abelian groups. I guess the moral is that all the weird stuff is going on over by the non-abelian groups.

[18:55] <masak> s/abelian/finitely-generated abelian/

[18:55] *** berekuk joined
[18:56] <nwc10> jnthn: yes, but I was more meaning that if the code is purposefully compiled as two versions, you can also arrange for the things that you can't detect to always leave a "calling card" by notifiying routines that they need to behave "properly"

[18:57] <sorear> the corresponding proof for topological spaces is much, much harder.

[18:57] <nwc10> but I am arm waving from a position of (somewhat) ignorance here.

[18:58] <masak> sorear: oh, I am not going near topology yet.

[19:02] *** fhelmberger joined
[19:02] <colomon> masak: +1

[19:02] <sorear> it amuses me that "there is no continuous, injective function from R^x to R^y, x > y" is very obvious but has no elementary proof

[19:03] *** fhelmberger left
[19:04] <moritz> well, it's not obvious that such a function exists in injective but non-cotinuous

[19:04] <moritz> (until you learn about Peano curves)

[19:07] * colomon does not remember covering Peano curves in topology...  

[19:07] *** rindolf left
[19:08] <masak> sorear: that is kinda amusing.

[19:08] *** rindolf joined
[19:08] <moritz> I don't think I had them covered anywhere

[19:08] <moritz> just read about them somewhere

[19:08] <masak> sorear: the closest I've ever gotten to topology was starting in on a book about algebraic topology. nice stuff.

[19:10] *** bluescreen100 left
[19:12] *** fhelmberger joined
[19:12] *** fhelmberger left
[19:12] *** stevan_ joined
[19:13] * colomon 's brain melted in 500-level algebraic topology

[19:13] *** prammer joined
[19:14] * diakopter 's brain melted in big words

[19:16] <masak> rn: my $n = 2; say 'caaw' ~~ /a ** $n/

[19:16] <camelia> niecza v24-51-g009f999: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** $n as separator; nowadays please use atom+ % $n at /tmp/URsZSVaS3U line 1:␤------> my $n = 2; say 'caaw' ~~ /a ** $n⏏/␤␤｢a｣␤␤»

[19:16] <camelia> ..rakudo 267c54: OUTPUT«===SORRY!===␤Quantifier quantifies nothing␤at /tmp/As4PT3NJzx:1␤------> my $n = 2; say 'caaw' ~~ /a ** ⏏$n/␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤        p…

[19:16] * masak feels both those errors are bogus

[19:16] * masak peruses S05

[19:17] *** bluescreen100 joined
[19:17] <FROGGS> shouldnt be too hard to make ** $var work IMO

[19:18] <sorear> what makes the peano curve case so interesting is that they ARE continuous, just in the other direction

[19:18] <sorear> continuous surjection from R to R^2, say

[19:18] <sorear> (with no continuous inverse)

[19:19] *** jaldhar left
[19:19] <masak> oh, I'm wrong.

[19:19] <masak> see S05:1030

[19:19] <masak> so no, it shouldn't be too hard, but right now it's outlawed for backward-compatibility reasons.

[19:20] <masak> or perhaps backward-incompatibility reasons, rather.

[19:20] <masak> rn: my $n = 2; say 'caaw' ~~ /a ** {$n}/

[19:20] <camelia> rakudo 267c54: OUTPUT«===SORRY!===␤Quantifier quantifies nothing␤at /tmp/ueHJpM76tG:1␤------> my $n = 2; say 'caaw' ~~ /a ** ⏏{$n}/␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤       …

[19:20] <camelia> ..niecza v24-51-g009f999: OUTPUT«｢aa｣␤␤»

[19:20] <masak> niecza++

[19:20] <PerlJam> it's not outlawed; it just warns.

[19:20] <masak> PerlJam: but it doesn't mean what I want.

[19:21] <masak> PerlJam: it means %

[19:21] <PerlJam> well, that too  :)

[19:21] <masak> slight detail :P

[19:21] <FROGGS> nqp: my $n := 2; say('caaw' ~~ /a ** {$n}/)

[19:21] <camelia> nqp: OUTPUT«Quantifier quantifies nothing at line 2, near " {$n}/)"␤current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)␤»

[19:22] *** domidumont left
[19:22] <diakopter> camelia: *you* quantify nothing

[19:22] *** fhelmberger joined
[19:23] *** cooper left
[19:23] *** fhelmberger left
[19:23] <FROGGS> quantify my hat!

[19:24] *** cooper joined
[19:27] * masak read 'nqp:' and for one confused moment wondered what implementation 'q' is

[19:28] * colomon too!

[19:28] <masak> :D

[19:29] <masak> sorear: I have long since come to peace with the R <=> R^2 stuff. I just accept that my intuition will not be worth a lot for infinities. just as some intuitions break down for the number 0.

[19:32] *** fhelmberger joined
[19:32] *** fhelmberger left
[19:33] <lizmat> so, do we have a way now, conceptually or otherwise, to find out the type of a typed hash?

[19:33] <lizmat> I would really like to change the .perl of Hashes to include .hash( :keytype(Any), :of(Int) ) if the hash was created with "my Int %h{Any}"

[19:34] <dalek> rakudo-star-daily: 951a728 | coke++ | log/ (5 files):

[19:34] <dalek> rakudo-star-daily: today (automated commit)

[19:34] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/951a72828d

[19:34] <lizmat> so that we could start thinking of roundtripping typed hashes

[19:34] <[Coke]> modules/perl6-File-Tools now failing tests.

[19:35] <timotimo> oh no, the only change was the thing i did :o

[19:35] <timotimo> does it relate to rm_rf?

[19:35] <[Coke]> https://github.com/coke/rakudo-star-daily/blob/master/log/test-modules.log#L155

[19:35] <[Coke]> yup.

[19:35] <[Coke]> SMOKE!

[19:36] <timotimo> indeed, a .IO seems to be missing

[19:37] <timotimo> pullrequest'd

[19:37] *** tgt left
[19:37] <timotimo> thanks, coke

[19:39] <masak> [Coke]++

[19:39] <Util> #ps time; any p6'ers need to come for GSoC matters? Backlog: http://irclog.perlgeek.de/parrotsketch/2013-05-21

[19:40] *** SamuraiJack_ joined
[19:41] *** fhelmberger joined
[19:43] * arnsholt crosses his fingers

[19:43] <arnsholt> I may have discovered the absolutely bone-headed reason for the NativeCall callback segfaults

[19:43] <moritz> arnsholt: do tell

[19:44] <arnsholt> Too early to tell (compiling for test now), but it might be a non-zeroed array

[19:44] *** fhelmberger left
[19:44] <PerlJam> arnsholt++ (whether you found it or not, you've at least been looking :)

[19:44] <masak> hm, why have I never heard about https://en.wikipedia.org/wiki/Subject-oriented_programming before?

[19:45] <masak> I wonder how close this notion is to that of roles.

[19:45] <arnsholt> But the culprit may be essentially this: malloc(num_args > 0? num_args*sizeof(void *) : 1)

[19:45] * masak queues up the paper for his copious spare time

[19:45] <arnsholt> The 1 because malloc(0) is illegal

[19:45] <arnsholt> Of course that one pointer is never initialized

[19:46] <[Coke]> masak: now I just need to make it more automated. :P

[19:46] <PerlJam> seems like it would have been better to have left the pointer null than to malloc anything :)

[19:46] <arnsholt> It might be that we mark that uninitialized pointer as alive

[19:46] <arnsholt> I don't see why we should do that, but we might

[19:47] <arnsholt> Shouldn't happen, but it's worth looking into

[19:47] *** zby_home_ left
[19:48] <masak> actually, subjects seem like a notion dual to roles. interesting.

[19:49] *** andrew12 is now known as ANDREW12

[19:51] <lizmat> masak: thinking about :delete :exists, what would :delete :!exists mean, perhaps in combination with :!p

[19:52] <lizmat> or is this getting too magical at all and we shouldn't think about combining adverbs except in the case where they clearly make sense ?

[19:52] <lizmat> :!p returning pairs for *all* given keys, even if they don't exist

[19:52] <arnsholt> *sigh* No beans

[19:53] <lizmat> (:p filters out the ones that don't exist)

[19:53] <arnsholt> Back to debugging

[19:53] <PerlJam> lizmat: I tend to be conservative on these matters (if that counts for anything).  I'd like to be very explicit about what makes sense, what doesn't and what's been left for the future.

[19:54] *** fhelmberger joined
[19:56] <masak> lizmat: what PerlJam said. but I have no problem with immediately assigning meaning to :delete :!exists either.

[19:56] *** fhelmberger left
[19:57] <lizmat> I could actually see a use for :delete:k as well  :-)

[19:57] <masak> lizmat: it would simply mean "delete all the supplied keys. return whether they weren't there to begin with, as a vector of Bool"

[19:57] <masak> s/they weren't there/each wasn't there/

[19:58] <lizmat> so simple notting the bool values that would otherwise have been returned with :delete :exists ?

[19:59] <lizmat> this is starting to feel like smart match in p5 again   :-)

[19:59] <dalek> roast: f95307c | dagurval++ | S32-io/spurt.t:

[19:59] <dalek> roast: Added tests for spurt

[19:59] <dalek> roast: review: https://github.com/perl6/roast/commit/f95307c7f6

[19:59] <dalek> roast: a95a3c3 | dagurval++ | TODO:

[19:59] <dalek> roast: removed spurt from TODO

[19:59] <dalek> roast: review: https://github.com/perl6/roast/commit/a95a3c303c

[20:06] *** fhelmberger joined
[20:07] *** fhelmberger left
[20:08] * lizmat is glad to see masak on Hallway++ as well

[20:08] <colomon> masak: you coming to YAPC::NA

[20:08] <colomon> ?

[20:11] <lizmat> I hope so: http://www.yapcna.org/yn2013/talk/4774  :-)

[20:11] <colomon> \o/

[20:13] <colomon> Is the liz going to his talk you?

[20:13] <PerlJam> lizmat: he could be giving the talk via one of those telepresence robots   ;)

[20:13] * colomon is looking forward to meeting a bunch of p6ers he's not met in person before!

[20:13] <lizmat> or one of his clones

[20:13] <lizmat> although I'm pretty sure moritz is not coming to YAPC::NA

[20:14] <arnsholt> colomon: Likewise!

[20:14] * lizmat too

[20:14] <masak> colomon: I am coming. I am looking forward to meeting you also.

[20:14] <masak> and a bunch of other NAers I have never met in meatspace.

[20:15] <sorear> I'm coming

[20:15] <sorear> colomon: is this your first yapc?

[20:15] <colomon> sorear: my third

[20:15] <sorear> lizmat: wait, do I have to register for hallway++?

[20:16] <lizmat> registration was by putting a sticker on your shirt, at least last year

[20:16] <lizmat> mst will probably have stickers

[20:16] *** fhelmberger joined
[20:16] <lizmat> it's the second YAPC::NA for me, so I'm still a VIP  :-)

[20:17] <mst> sorear: wait, did you even read the blog post? :D

[20:17] <PerlJam> It'll be my second YAPC too.  (the first was 5 years ago)

[20:17] <colomon> The VIP thing was actually very confusing to me the first year.  :)

[20:17] <colomon> "Wait.  I'm a VIP but pmichaud isn't?!?"

[20:17] *** fhelmberger left
[20:18] <colomon> masak, lizmat, arnsholt, sorear, oh my!  :D

[20:19] <sorear> mst: I did, I got the impression that I "registered" by writing Hallway++ on my badge with a sharpie

[20:19] <mst> sorear: correct

[20:19] <mst> sorear: but there'll be stickers too

[20:19] <sorear> which made me wonder how lizmat *knew* masak was doing it

[20:19] <mst> err, because he mailed the list saying ++ to it

[20:19] <colomon> sorear: e-mail

[20:19] <sorear> then I saw his reply on the mailing list, which moots this

[20:19] <mst> and/or added himself to the HWPPPeople wiki page

[20:19] * colomon is kind of hoping for a Hallway++ he can turn off.  

[20:20] <PerlJam> colomon: put it on the back side of your badge.

[20:20] <lizmat> colomon: multiple stickers?

[20:20] <colomon> PerlJam: I was just thinking I needed a button

[20:24] <colomon> I'll figure something out to let me go introvert when/if needed.

[20:25] <tadzik> colomon: looking forward to meeting you too :)

[20:25] <colomon> tadzik!  \o/

[20:25] <PerlJam> Is there going to be a #perl6 BOF?  

[20:26] * colomon thought there was going to be a massive #perl6 hackathon...

[20:26] <tadzik> it's like a family reunion

[20:26] <tadzik> I only regret that I'll be there for such a short time

[20:27] * sorear imagines tadzik dropping by for a few seconds

[20:27] *** fhelmberger joined
[20:27] <Tene> Hmm.  I should try to work out a plan to go to yapc::na this year

[20:27] <dalek> roast: a00ed4d | dagurval++ | S32-io/spurt.t:

[20:27] <dalek> roast: re-wrote spurt tests, DRY

[20:27] <dalek> roast: review: https://github.com/perl6/roast/commit/a00ed4d22f

[20:28] <PerlJam> Tene: it's like in 2 weeks, better get crackin'

[20:29] <colomon> less than 2 weeks now

[20:29] <tadzik> sorear: I convinced the airline to lower me on a rope, so I'll say a quick "hi" and they pull me back to the clouds ;)

[20:29] <PerlJam> tadzik: but you'll be zipping by at a few hundred miles an hour

[20:30] <tadzik> PerlJam: yeah, that'll be a short visit

[20:30] *** fhelmberger left
[20:30] <tadzik> I'll have to resist high-fives, or I may harm someone

[20:30] <PerlJam> careful they don't smack you into a building

[20:31] <masak> Tene: yes, please work out a plan. would really like to meet you!

[20:31] <sorear> PerlJam: they can unspool the rope to lower the ground speed, or possibly fly as slow as possible against the jet stream

[20:31] <sorear> Tene: what masak said.

[20:32] <diakopter> re: jet stream, that'd be a long rope

[20:32] <PerlJam> yeah, I imagine that a good bit of the airplane would be taken up by the rope

[20:33] <PerlJam> (at least until they lext tadzik down to say "hi")

[20:33] *** kaare_ left
[20:33] <PerlJam> s/lext/let/

[20:33] <sorear> maybe tadzik's flight is a dirigible.

[20:34] <arnsholt> Zeppelins!

[20:34] <arnsholt> A fleet of Polish zeppelins crossing the Atlantic

[20:35] <tadzik> oh, you thought it'd be an airplane? No, heck, would that be dangerous...

[20:35] <arnsholt> Now -that's- going to YAPC in style =)

[20:35] <Tene> It's probably a bit too late for me to find something cheap enough, but I've actually been feeling well enough and don't have anything else planned then

[20:35] <PerlJam> until the US military shoots them down.

[20:35] <PerlJam> Tene: where are you travelling from?

[20:36] <Tene> PerlJam: Sunnyvale, California

[20:36] <sorear> hey, if they could reach the challenger deep with a sounding line in 1875, I'm sure they can do something today

[20:37] <sorear> probably closer to austin than I am

[20:40] *** saxx11 left
[20:44] *** tgt joined
[20:46] *** splitcells joined
[20:48] <splitcells> How good do you think the development of perl 6 is?

[20:49] *** estrabd left
[20:50] *** estrabd joined
[20:51] <diakopter> splitcells: well

[20:51] <splitcells> why?

[20:52] <dalek> specs: 7883bce | (Elizabeth Mattijsen)++ | S02-bits.pod:

[20:52] <dalek> specs: Some clarifications on using adverbs with subscripts

[20:52] <dalek> specs: 

[20:52] <dalek> specs: Please consider this a draft, a discussion piece if you will.  I simply

[20:52] <dalek> specs: got inspired by http://irclog.perlgeek.de/perl6/2013-05-21#i_7098764

[20:52] <dalek> specs: review: https://github.com/perl6/specs/commit/7883bce8e3

[20:53] <jnthn> If the majority of dev teams I went to did testing to the level Perl 6 dev does, cared for reviewing commits the same way, and dug deep into problems to get to the heart of them to the degree Perl 6 folks do, they'd probably be in a better place.

[20:56] *** wooden joined
[20:56] *** wooden left
[20:56] *** wooden joined
[20:56] <splitcells> What is the estimated time (or time range) until perl 6 specs, testsuite and a compiler gonna be 'ready' ?

[20:58] <lizmat> I think the standard answer is "Christmas"

[20:58] <splitcells> yeah

[20:59] <masak> splitcells: in some sense, we're all wanting to answer that question. a number of factors make it difficult to estimate.

[20:59] <splitcells> how about a time range ? 2-4 years? 5-10?

[20:59] <splitcells> 1-2?

[20:59] <masak> splitcells: it might be a consolation to know, though, that it feels like we are converging, and we're working actively to actually nail down the spec.

[20:59] <masak> splitcells: it depends on your definition of 'ready'.

[20:59] <jnthn> Depends what "ready" means, but realistically I feel we're still a couple of years from the point where I'll feel comfortable saying, "you can use this for most things you want to do now".

[21:00] <splitcells> ready ^= "you can use this for most things you want to do now"

[21:00] <colomon> and you can already use it quite nicely for some things.

[21:00] <masak> splitcells: I've been using Rakudo productively since 2008. it's rough sometimes, but it also works for a lot of things.

[21:01] <colomon> is some sense the biggest current limitation is that it is pretty slow.  for tasks which are small but twisty, it works quite nicely.

[21:01] <colomon> *in some sense

[21:02] <masak> there is already an expressivity which rivals Perl 5 in many respects. I love to think in Perl 6.

[21:02] <masak> and I'm talking about the implemented bits, not just the things that are still dreams in the spec.

[21:02] *** skids left
[21:03] <splitcells> whichcompiler do you use? rakudo?

[21:03] <masak> 99% of the time, yeah.

[21:03] <splitcells> is there thread support?

[21:03] * masak mumbles

[21:04] <masak> splitcells: see https://ttjjss.wordpress.com/2012/12/22/threads-for-rakudo-perl-6/

[21:05] <colomon> splitcells: for instance, I'm using it to process ABC music files.  I've got a 100-linep6 grammar which understands them, a series of classes to represent the musical notes, and several handy applications for it.  It's a natural fit for the language, and because *big* ABC files are measured in K, not M or G, both Rakudo and Niecza are more than adequately fast.

[21:05] <splitcells> ty

[21:06] * jnthn has high hopes for Rakudo getting good thread support on the JVM backend.

[21:06] <jnthn> 'cus threads there are very well exercised in the real world already.

[21:06] <colomon> splitcells: on the other hand, I've also got a grammar for parsing STEP CAD files.  It works well enough for 1M files, but is unusably slow on the 1G files I sometimes need to deal with.

[21:08] <masak> splitcells: I'm using Rakudo and a 256-line script to power my blog. have been since 2010.

[21:08] <masak> splitcells: this weekend, I'll be giving a talk about how to reduce the 256-script to 25 lines ;)

[21:09] <masak> 256-line script*

[21:09] <masak> (and increase readability significantly in the process)

[21:09] <splitcells> speed?

[21:10] <masak> it's a static web site. no dynamic content.

[21:10] <masak> my entire blog generates in ~4 minutes. but I seldom need to generate all of it. usually takes a minute or so to generate the new content.

[21:11] <splitcells> ~4 minutes on both scripts?

[21:11] <masak> oh, I don't have timing data on the new script yet.

[21:16] *** spider-mario left
[21:21] *** SamuraiJack_ left
[21:36] *** ANDREW12 is now known as andrew12

[21:45] <timotimo> 25 lines is kind of on the short side, isn't it?

[21:45] <lizmat> it's not a one-liner, that's for sure!

[21:46] *** SamuraiJack_ joined
[21:47] *** prevost left
[21:48] <timotimo> maybe it's now almost completely data driven?

[21:49] <timotimo> it will just eval each blog post in turn :P

[21:49] <dalek> specs: f868fd3 | (Elizabeth Mattijsen)++ | S02-bits.pod:

[21:49] <dalek> specs: Small clarification in subscript adverbs

[21:49] <dalek> specs: 

[21:49] <dalek> specs: After masak++ made me think about it more

[21:49] <dalek> specs: review: https://github.com/perl6/specs/commit/f868fd3462

[21:51] *** stevan_ left
[21:58] *** kurahaupo joined
[21:59] *** prevost joined
[22:03] *** lustlife left
[22:07] <lizmat> goodnight #perl6!

[22:08] *** REPLeffect left
[22:10] *** gtodd left
[22:11] *** bluescreen100 left
[22:12] *** dmol left
[22:13] <colomon> o/

[22:14] <splitcells> o\

[22:19] *** raiph left
[22:21] <jnthn> 'night o/

[22:22] <diakopter> o/

[22:24] <masak> 'night, #perl6

[22:28] *** stevan_ joined
[22:28] *** SamuraiJack__ joined
[22:29] *** SamuraiJack_ left
[22:34] *** rindolf left
[22:41] *** REPLeffect joined
[22:42] *** skids joined
[22:43] *** SamuraiJack__ left
[22:45] *** PacoAir left
[22:54] * [Coke] yawn

[22:54] <[Coke]> s

[22:57] *** tgt left
[22:58] *** SamuraiJack__ joined
[23:02] *** tgt joined
[23:03] *** BenGoldberg joined
[23:05] *** vm joined
[23:16] *** vm left
[23:19] *** PacoAir joined
[23:28] *** Chillance left
[23:31] *** tgt left
[23:39] *** gdey joined
[23:44] *** gdey left
[23:47] *** splitcells left
[23:52] *** BenGoldberg left
[23:53] *** SamuraiJack__ left
[23:54] *** SamuraiJack__ joined
[23:56] *** ajr_ left
