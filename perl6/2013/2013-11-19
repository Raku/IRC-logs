[00:00] *** telex joined
[00:00] *** rurban1 joined
[00:06] *** rurban1 left
[00:16] *** Psyche^ left
[00:17] *** Psyche^ joined
[00:32] *** btyler joined
[00:38] <[Coke]> lue: https://github.com/tadzik/Template-Mojo/issues/4

[00:39] <[Coke]> Anyone talk to supernovus outside of irc?

[01:02] *** ajr_ left
[01:03] *** rurban1 joined
[01:05] *** bbkr_ joined
[01:07] *** bbkr left
[01:07] *** rurban1 left
[01:11] *** genehack left
[01:23] *** leont left
[01:39] *** eternaleye left
[01:42] *** eternaleye joined
[01:55] *** araujo left
[01:56] *** tgt left
[01:56] *** araujo joined
[02:04] *** rurban1 joined
[02:07] <TimToady> should there be a Promise state of Unwanted that tells the code trying to fill a promise that it no longer needs to try?

[02:08] *** rurban1 left
[02:08] <TimToady> (my brother-in-law Mark asks: if you're racing a bunch of promises, and you only want the first one that finishes, how do you stop the others from wasting energy?)

[02:09] <btyler> SIGGIVEUPYOULOST :)

[02:10] <TimToady> one could, I suppose (with proper documentation) have an agreement that either the promiser or the user can get the vow and keep/break the promise, and if the promiser's promise is broken by the user, stop looping or whatever

[02:12] <TimToady> or the promiser gets the vow but puts it somewhere public, if it wants to be cancelable by the user

[02:15] <TimToady> on that subject, can the user of channel $c call $c.done?  I suspect the method (originally called .close iirc) was envisioned only for use by the sender, but can a channel be shut down by the reader?

[02:17] <TimToady> or do we need to have something corresponding to a vow for a channel (like maybe a "quest" object, sort of an extended vow :)

[02:21] *** genehack joined
[02:21] *** lue left
[02:22] *** colomon joined
[02:22] <BenGoldberg> What happens if there are two or more users of a channel, and only one of those users stops wanting it's output?  It would be bad to call $c.done too early, I think

[02:23] <TimToady> well, at some point civility is required

[02:24] <TimToady> but I wonder if we're setting ourselves up for a "core leak"

[02:24] <TimToady> how does Go handle this?

[02:27] <TimToady> obviously if you don't trust the code you're running, you shouldn't be allowing it to use up threads without resource limits of some kind, but even assumning non-malignant intent, you can get long-running promises started accidentally, and you'll like to have some way to deal with that maybe

[02:29] *** kurahaupo_ joined
[02:29] <TimToady> or do we just develop a culture of adding timeout promises to everything?  is there any way for an anyof to signal the "promise collector" that a "promise collection run" is desirable? :)

[02:31] *** [Sno] left
[02:31] *** [Sno]_ joined
[02:32] *** jnap left
[02:32] <TimToady> is there a need for some kind of fratrcidal anyof that breaks all the eggs that didn't hatch first?

[02:33] <TimToady> *tric

[02:35] <TimToady> energy usage is a concern to various companies running servers

[02:36] *** bloonix left
[02:37] <TimToady> I suppose you can do a "lazy race" with a bunch of channels, as long as they can exert backpressure and specify how much buffering they desire

[02:40] <TimToady> a certainly amount of speculative execution can speed throughput, but too much of it just runs up your electric bill, not to mention your air conditioning bill

[02:42] * TimToady imagines a Google barge in the Arctic that doesn't use much electricity to cool the servers, and then imagines a pun on "sunk cost"

[02:42] * TimToady probably needs to douse his head in some cold water...

[02:43] <TimToady> (or do a bit less speculative execution...)

[02:44] *** _ilbot left
[02:46] *** _ilbot joined
[02:50] *** lue joined
[02:51] <TimToady> ((it would seem post-headache branefuzz is not the best time to do design))

[02:53] <japhb_> It is certainly desirable to make M-of-N combinators that when satisfied stop the (M+1)..N work-in-progress.

[02:54] <TimToady> stop and/or suspend

[02:55] <TimToady> after the first page of results :)

[02:57] * TimToady takes pity on wife, who pitiously and/or pitilessly asks him to cook dinner

[02:59] *** raiph joined
[03:01] <japhb_> Sure.  Though I was thinking rather of managing latency long tail.

[03:01] <japhb_> (Without generating vast continuing load that is known to not affect results already decided._

[03:04] *** rurban1 joined
[03:09] *** rurban1 left
[03:13] *** kaleem joined
[03:29] *** fridim_ joined
[03:48] *** kaleem left
[03:49] *** guest313 joined
[04:05] *** rurban1 joined
[04:06] *** leont joined
[04:10] *** rurban1 left
[04:11] *** preflex_ joined
[04:11] *** ChanServ sets mode: +v preflex_

[04:13] *** preflex left
[04:13] *** preflex_ is now known as preflex

[04:25] *** guest313 left
[04:42] *** araujo left
[04:55] *** xinming left
[05:03] *** xinming joined
[05:06] *** logie left
[05:08] *** kurahaupo_ is now known as kurahaupo

[05:12] *** logie joined
[05:23] *** ponbiki left
[05:27] * kurahaupo tries to remember which bot does store-and-replay messaging (for the benefit of timezone outcasts) 

[05:34] <TimToady> preflex: help

[05:34] <preflex>  try 'help help' or see 'list' for available commands

[05:34] <TimToady> preflex: help list

[05:34] <preflex>  list - show available plugins

[05:34] <TimToady> preflex: list

[05:34] <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:

[05:34] <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]

[05:34] *** logie left
[05:37] <lue> preflex: zenc test

[05:37] <preflex>  test

[05:37] *** SamuraiJack__ joined
[05:46] *** jercos left
[05:46] *** jercos joined
[05:58] <moritz> good morning

[06:06] *** rurban1 joined
[06:11] *** rurban1 left
[06:16] *** BenGoldberg left
[06:19] *** xinming left
[06:19] *** xinming joined
[06:36] *** [Sno]_ left
[07:05] *** kaleem joined
[07:07] *** rurban1 joined
[07:10] *** SamuraiJack joined
[07:10] *** SamuraiJack__ left
[07:12] *** rurban1 left
[07:15] *** daveec left
[07:15] *** daveec joined
[07:23] *** sivoais left
[07:26] *** sivoais joined
[07:29] *** araujo joined
[07:33] *** fridim_ left
[07:45] *** dmol joined
[07:52] *** btyler left
[07:53] *** darutoko joined
[07:59] <GlitchMr> runsvdir -P /etc/service log: /run: line 2: cd: /data/svn/commitbit: No such file or directory ./run: line 2: cd: /data/svn/commitbit: No such file or directory

[07:59] <GlitchMr> hm

[08:08] *** rurban1 joined
[08:09] <moritz> GlitchMr: pasting some random command line and error message without any context into the channel is neither interesting for us, nor a good base for discussion

[08:09] *** zakharyas joined
[08:09] <GlitchMr> From ps aux.

[08:09] <moritz> ... on?

[08:10] <GlitchMr> I'm not sure if service running on feather should have error messages in arguments.

[08:10] <moritz> well, I'm sure

[08:10] <moritz> (that they shouldn't)

[08:10] *** Celelibi left
[08:12] *** thou left
[08:13] *** rurban1 left
[08:13] *** nnunley left
[08:14] <moritz> GlitchMr: now that you found it, what are going to do with it?

[08:41] *** FROGGS joined
[08:50] *** salv0 joined
[08:55] *** darutoko left
[08:58] *** hummeleB1 left
[09:09] *** rurban1 joined
[09:13] *** rurban1 left
[09:18] *** FROGGS[mobile] left
[09:21] *** grondilu left
[09:29] *** kivutar joined
[09:32] *** xinming left
[09:34] *** xinming joined
[09:36] *** dakkar joined
[10:01] *** darutoko joined
[10:04] *** tgt joined
[10:06] <jnthn> TimToady: Yes, we very much need a cancellation mechanism.

[10:07] *** ponbiki joined
[10:09] <jnthn> TimToady: Though, anyof should probably not use it. A combinator that explicitly races, along with a ..timeout one to factor out that very common idiom, would, though.

[10:10] *** rurban1 joined
[10:10] <moritz> A branch, a tag, and a reflog walk into a bar. The bartender says, "What is this, some sort of rebase?"

[10:10] *** kurahaupo is now known as kurahaupo_mobile

[10:14] <arnsholt> o/

[10:14] *** rurban1 left
[10:14] <moritz> arnsh\olt

[10:14] <arnsholt> ^_^

[10:15] <jnthn> arnsh\o/t

[10:15] <FROGGS> hi :o)

[10:15] <moritz> FRO/GGS!

[10:17] <colomon> \p

[10:17] <colomon> errr

[10:18] <moritz> c\olomo/n

[10:18] <jnthn> r: "\p"

[10:18] <camelia> rakudo-parrot 75c45f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/BsdHz5pnVm‚ê§Unrecognized backslash sequence: '\p'‚ê§at /tmp/BsdHz5pnVm:1‚ê§------> [32m"\[33m‚èè[31mp"[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix or term‚ê§        p‚Ä¶¬ª

[10:18] <camelia> ..rakudo-jvm 75c45f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ti0BmLVtsg‚ê§Unrecognized backslash sequence: '\p'‚ê§at /tmp/ti0BmLVtsg:1‚ê§------> [32m"\[33m‚èè[31mp"[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix or term‚ê§        pref‚Ä¶¬ª

[10:18] <jnthn> Thought so :)

[10:18] *** kivutar left
[10:19] <FROGGS> mo/ritz!

[10:24] *** darutoko left
[10:24] *** ponbiki left
[10:33] *** darutoko joined
[10:33] *** xenoterracide left
[10:35] *** ponbiki joined
[10:46] <FROGGS> jnthn: when storing modules in a sort-of database, do you have any wishes about precomp or extra information that should go along with it?

[10:46] <FROGGS> like, compiler version or something else?

[10:47] <jnthn> FROGGS: compiler version is one good one, 'cus if that changes the pre-comp is invalidated

[10:47] <FROGGS> for all backends?

[10:48] <jnthn> Yup

[10:48] <FROGGS> k

[10:48] <jnthn> It's 'cus of the BS

[10:48] <jnthn> You link against the setting.

[10:48] <FROGGS> ahh, yes

[10:48] <jnthn> Which links against the bootstrap and MOP, which in turn is against a particular NQP...

[10:49] *** dmol left
[10:52] *** fhelmberger joined
[10:53] *** berekuk left
[10:56] <FROGGS> lizmat: atm it tries site first: https://github.com/tadzik/panda/blob/master/lib/Panda/Installer.pm#L20

[10:58] <FROGGS> and for CompUnitRepo.install I think panda just calls its .install with: %dist-info, $from-path, $to-path-without-prefix

[10:59] <FROGGS> or maybe it just passes the %dist-info along will to-be-installed files along the "subdirectory" they should appear in

[10:59] <FROGGS> dunno how we're going to support Makefiles btw

[11:00] <FROGGS> maybe we need some sort of standalone installer that can be invoked like ExtUtils

[11:01] <FROGGS> still, you need to supply (trustworthy) information about the distribution that is going to be installed

[11:08] *** darutoko left
[11:10] *** cibs left
[11:10] *** rurban1 joined
[11:15] *** ssutch left
[11:15] *** rurban1 left
[11:20] *** [Sno] joined
[11:21] *** raiph left
[11:22] *** cibs joined
[11:40] *** dmol joined
[11:44] <timotimo> ohai

[11:55] *** hummeleB1 joined
[11:55] *** pernatiy left
[12:11] *** rurban1 joined
[12:16] *** rurban1 left
[12:27] <timotimo> i had a dream where some big news site showed a story about an open source developer from finland having the nickname "timotimo1" because obviously some horrible commoner has taken "timotimo"

[12:27] * moritz literally lols

[12:28] <jnthn> lol

[12:31] <tadzik> :D

[12:33] <timotimo> huh, it occurs to me, that that may very well be an expression of my imposter syndrome

[12:34] <tadzik> great. I got it and now everyone has it

[12:34] <tadzik> imposters!

[12:34] <timotimo> wow, vi hart's newest video about logarithms is pretty stunning

[12:38] <jnthn> bbl &

[12:43] <lizmat> FROGGS: wrt to standalone installer: that is what CompUnitRepo.install should do

[12:44] <lizmat> note that the first parameter to .install is the *source* to be installed

[12:44] <lizmat> *not* a filename

[12:45] <lizmat> .install should check the pod for module name / auth / version info and fail if it can't find the data it needs to install the module

[12:46] <lizmat> and create a pre-compiled version if it thinks that's necessary

[12:52] <FROGGS> lizmat: what if a distribution ships other data than source code too? how should a command line tool know which dist/auth/ver it is?

[12:53] <lizmat> hmmm... do you have examples ?

[12:54] *** dmol left
[12:54] <lizmat> just to be able to think of use cases

[12:54] <FROGGS> example: perl6-debug ships a batch file, so you can actually type `perl6-debug`

[12:54] <FROGGS> there is no pod :/

[12:55] <FROGGS> so, an "ExtUtils::CompUnitRepo --install" would need a hash of information directly from e.g. panda

[12:56] <lizmat> hmmm... maybe the source parameter could be a hash of some sort

[12:56] <FROGGS> like when the CompUnitRepo wants to store the source location of the distribution, only panda knows where it got the dist from

[12:56] <FROGGS> feels a bit icky

[13:00] <lizmat> I see panda as a thin client of CompUnitRepo

[13:00] <lizmat> so we need to put any needed functionality somehow in an API in CompUnitRepo

[13:01] <lizmat> maybe .install is a bit too simplistic

[13:01] <lizmat> ;-)

[13:02] *** dmol joined
[13:04] <FROGGS> depends on what it should install... it can either handle single files (of whatever type) or distros

[13:09] * lizmat is thinking

[13:09] <lizmat> .oO( what are you sinking about? )

[13:12] *** rurban1 joined
[13:13] <FROGGS> *g*

[13:13] <FROGGS> german cost guard :o)

[13:16] *** rurban1 left
[13:17] *** ajr joined
[13:17] *** ajr is now known as Guest74822

[13:17] *** Guest74822 is now known as ajr_

[13:20] *** tgt left
[13:32] <lizmat> ok, thought about it

[13:32] <lizmat> .install is simple enough

[13:32] <lizmat> it takes *one* file and installs that

[13:32] <lizmat> because that is what the system needs to know when it wants to -use- it

[13:33] <lizmat> the "database" in the top dir should only keep information that is needed to be able to *execute* the code

[13:34] <lizmat> that database needs to be lean and mean

[13:34] <lizmat> any additional introspection should be optional and probably live in a different database

[13:35] <lizmat> so the oneliner should only be used to install a single file

[13:35] <lizmat> if a distro needs to install multiple files, it should call the oneliner multiple times

[13:38] <FROGGS> sure, but the installer needs to know all about the distro it belongs to

[13:38] <FROGGS> even if it is a one-file-distro

[13:38] <FROGGS> and especially if not

[13:40] <lizmat> hmmm..   would we allow installation of pre-compiled bytecode ?

[13:40] <FROGGS> why not?

[13:40] <lizmat> I guess we would 

[13:40] <FROGGS> like perl6-debug compiles itself using a Makefile

[13:40] <lizmat> indeed... so .install can't in that case find out what it is it's installting

[13:40] <FROGGS> you would install the executable and the source then

[13:41] <FROGGS> maybe we would even install the needed things to rebuild it on demand

[13:41] *** tgt joined
[13:42] <lizmat> but we need to keep remembering this: CompUnitRepo is what is needed to be able to *find* code for execution

[13:42] <lizmat> nothing more

[13:42] <lizmat> and more specifically: find using the "use" command (and friends)

[13:42] <FROGGS> it is not that easy

[13:42] <lizmat> nothing else

[13:43] <lizmat> finding code to be executed ?

[13:43] <FROGGS> who is in charge to install other files that belong to a dist?

[13:43] <lizmat> not the CompUnitRepo, is what I just decided and will put into the spec  :-)

[13:43] <FROGGS> I am thinking about File::ShareDir now btw

[13:44] <FROGGS> you do: use Foo::Bar(v1.0.2..*), and somehow this must match a File::SharDir lookup

[13:44] <FROGGS> so an installed module can ask: Where is my stuff?

[13:45] <lizmat> indeed: a compunit should be able to tell where it came from

[13:45] <FROGGS> I don't wanna have two installers, one for source code, and another for bytecode and other shared files

[13:47] <lizmat> hmmm...

[13:47] <FROGGS> as I may have mentioned: IMO the CompUnitRepo is in charge to install a distribution (including (compiled) stuff from installation process)

[13:48] *** rindolf joined
[13:48] <lizmat> so your saying, it's the CompUnitRepo's responsability to make sure that the database for looking up -use- files is as lean as possible

[13:49] <lizmat> while granting it the possibility to have another database with much more information

[13:49] <lizmat> Hmmm.. I would think that the information the CompUnitRepo's database would live in memory anyway

[13:49] *** kivutar joined
[13:50] <lizmat> perhaps even preload all @*INC CompUnitRepo's at startup, as to provide a "frozen" image of the outside during execution

[13:50] *** kaleem left
[13:51] <lizmat> so maybe we should free up whatever parameters we thought about with .install

[13:51] <lizmat> because it's always going to be an "external" process doing the install

[13:53] <lizmat> so maybe we should just spec what is going to be needed for ::Installation

[13:53] <lizmat> aka, the "old" CPAN-like installation

[13:54] <lizmat> hmmm.. but would we allow modules to be installed by something like dpkg in the same directory as being serviced by ::Installation?

[13:54] <lizmat> I guess not, right ?

[13:56] <FROGGS> lizmat: we don't need to freeze anything during execution for -use-, since that is compile time...

[13:56] *** kaare_ joined
[13:57] <FROGGS> question is: if you require something, should that take the newest database there is? I'd say so

[13:57] <lizmat> indeed, a require should reload if it sees that the database in memory is out of date with the one on disk

[13:57] <FROGGS> lizmat: I'd give dpkg its own tree with its own database (maybe even with a debiadn specific database format)

[13:58] <lizmat> I guess even a -use- should do that

[13:58] <FROGGS> so you newer install to the debian tree (aka vendor) using panda

[13:58] <FROGGS> never

[13:58] <FROGGS> never*

[13:58] <lizmat> ah, ok

[13:58] <lizmat> *phew*

[13:58] <FROGGS> :o)

[13:59] <FROGGS> sorry, I am a bit distracted atm

[13:59] <lizmat> so am I, actually

[14:00] <FROGGS> the next thing is that we should spec that if a module installs a binary, it is not guaranteed that it will be the only version there is, and may get the version-number appended by default

[14:01] <FROGGS> our auth, for that matter

[14:01] <FROGGS> or just get a hash

[14:01] *** tgt left
[14:02] *** tgt joined
[14:02] <lizmat> well, -use- will just ask the CompUnitRepo for candidates matching the given longname/ver/auth/from

[14:02] <lizmat> so it's the CompUnitRepo's responsability to favour binary versions over source version or not

[14:02] <FROGGS> I am not talking about use, more about executing a program

[14:02] <FROGGS> like, perl6-debug, panda, ...

[14:03] <FROGGS> p6doc

[14:03] <FROGGS> if I install three versions of perl6-debug, clearly the best one should be in PATH (if that bin dir happens to be in path)

[14:03] <FROGGS> but what is the best one if they all come from different auths?

[14:03] <lizmat> in my view, that lies outside the responsability of CompUnitRepo, but in yours not, so I'm trying to adapt

[14:04] <FROGGS> yeah, I am thinking about the whole installer thing, maybe CompUnitRepo is just one part of it :o)

[14:04] <lizmat> I'm going to see sno this evening, at the Niederrhein.pm meeting

[14:04] <FROGGS> (an important one of course :o)

[14:05] <lizmat> well, as I said, I wanted to keep CompUnitRepo as simple as possible, to reduce RAM/CPU requirements

[14:05] <FROGGS> yes, we don't need to blow that up

[14:06] <FROGGS> we can have other parts that care about the rest

[14:06] <lizmat> otoh, loading a compilation unit may be such an intensive task, that we could actually be a lot fatter in CompUnitRepo before anybody starts to notice

[14:06] <lizmat> still, I think leaner from the start is nearly always better

[14:06] <FROGGS> yes

[14:08] <FROGGS> btw, I think we should split rip the install part out of the code that is active while locating modules to use them

[14:08] <FROGGS> s/split//

[14:08] *** tgt left
[14:08] <FROGGS> gah, my english is terrible :(

[14:09] <lizmat> well, that's another reason I wanted to keep that simple  :-)

[14:09] <lizmat> so it wouldn't be a lot of code

[14:10] <lizmat> .install could just be a stub that requires the necessary code and does the right thing

[14:10] <lizmat> away for half an hour&

[14:13] <FROGGS> jnthn: if we had a huge database of installed modules with a lot of information... I guess it would make sense to compile something for use/need/require?

[14:13] *** rurban1 joined
[14:13] <FROGGS> jnthn: so that we can just deserialize it and have a hash, only with the information we would need?

[14:14] <FROGGS> so we don't have to parse json or whatever at that point for example

[14:15] *** leont left
[14:17] *** rurban1 left
[14:21] *** colomon left
[14:26] *** iSlug joined
[14:29] *** smash_ is now known as smash

[14:32] *** PacoAir joined
[14:37] <jnthn> FROGGS: Perhaps, yeah. I guess that we get to keep this format under our control, rather than it being spec?

[14:38] <FROGGS> jnthn: that is an implementation detail, yes

[14:38] <FROGGS> it is even specific to a given module loader (aka CompUnitRepo)

[14:39] <jnthn> ok

[14:39] <FROGGS> but it would be nice if this format survives a rakudo upgrade/rebuild

[14:40] <FROGGS> hmmm

[14:40] <FROGGS> or we rebuild that cache when rebuilding racudo

[14:40] <FROGGS> rakudo

[14:41] <jnthn> Well, or it detects it's out-dated on first "use" it has to process and re-builds then or something.

[14:41] <FROGGS> that would work too

[14:43] <FROGGS> btw, I imagine that we put that CompUnitRepo in src/core along with the libraries.cfg in root dir, and include CompUnitRepo as the last thing in the setting

[14:44] *** kaleem joined
[14:47] *** btyler joined
[14:47] *** bluescreen10 joined
[14:48] <lizmat> FROGGS: agree with that last statement

[14:49] <FROGGS> k

[14:49] *** berekuk joined
[14:55] *** Gwyxx joined
[14:57] <lizmat> FROGGS: hmm... what's libraries.cfg ?

[15:02] *** jnap joined
[15:04] *** logie joined
[15:06] *** kaleem left
[15:07] <dalek> specs: 0dd084d | (Elizabeth Mattijsen)++ | S03-operators.pod:

[15:07] <dalek> specs: Small change in hash name to avoid confusion

[15:07] <dalek> specs: review: https://github.com/perl6/specs/commit/0dd084d2b5

[15:07] <lizmat> TimToady: been looking in the spec for the place where map { } is specified

[15:07] <lizmat> I can't find it  :-(

[15:08] <lizmat> method map, no problem

[15:09] <lizmat> hmmm. I guess S32/Containers:326 mentions it

[15:13] *** darutoko joined
[15:13] *** salv0 left
[15:13] *** rurban1 joined
[15:17] *** colomon joined
[15:18] *** rurban1 left
[15:18] *** nnunley joined
[15:20] *** ajr_ left
[15:21] *** ajr joined
[15:22] *** ajr is now known as Guest52379

[15:22] *** Guest52379 is now known as ajr_

[15:27] <FROGGS> lizmat: libraries.cfg is the resident version of -I/--install

[15:29] *** FROGGS left
[15:30] <dalek> specs: dabb21e | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[15:30] <dalek> specs: Spec the listless map { }

[15:30] <dalek> specs: review: https://github.com/perl6/specs/commit/dabb21e6e7

[15:31] <lizmat> FROGGS: but why can't I find that file anywhere on my system ?

[15:35] *** salv0 joined
[15:39] *** ajr_ left
[15:39] *** darutoko left
[15:42] *** woolfy left
[15:42] *** brrt joined
[15:44] *** dmol left
[15:45] *** scottp_ joined
[15:47] *** Ulti_ joined
[15:48] *** Juerd_ joined
[15:48] *** pmichaud_ joined
[15:48] *** masak_ joined
[15:48] *** zakalwe_ joined
[15:48] *** BooK joined
[15:48] *** zakalwe_ left
[15:48] *** zakalwe_ joined
[15:48] *** Hor|zon_ joined
[15:49] *** tgt joined
[15:51] *** darutoko joined
[15:51] *** sorear_ joined
[15:51] *** [Sno] left
[15:52] *** ivan``_ joined
[15:52] *** scottp left
[15:52] *** zakalwe left
[15:52] *** tadzik left
[15:52] *** pmichaud left
[15:52] *** masak left
[15:52] *** Juerd left
[15:52] *** ivan`` left
[15:52] *** BooK_ left
[15:52] *** Ulti left
[15:52] *** sjohnson left
[15:52] *** Yappo__________ left
[15:52] *** Hor|zon left
[15:53] *** Juerd_ is now known as Juerd

[15:53] <lizmat> Niederrhein.pm&

[15:53] *** lizmat left
[15:53] *** brrt left
[15:53] *** salv0 left
[15:56] *** thou joined
[15:57] *** kaare_ left
[15:59] *** prammer joined
[15:59] *** jeffreykegler joined
[15:59] *** sjohnson joined
[16:00] *** Yappo__________ joined
[16:00] *** tadzik joined
[16:01] *** salv0 joined
[16:03] *** fridim_ joined
[16:06] *** kaare_ joined
[16:09] *** sjohnson left
[16:09] *** sjohnson joined
[16:12] *** FROGGS[mobile] joined
[16:14] *** rurban1 joined
[16:15] <FROGGS[mobile]> lizmat: that file would be new when my changes get merged

[16:19] *** rurban1 left
[16:19] <timotimo> FROGGS[mobile]: are there long-term plans for rakudo-p5?

[16:20] <FROGGS[mobile]> timotimo: yes, there are

[16:20] <timotimo> you're doing S11 for now, and then back to p5?

[16:20] <FROGGS[mobile]> that is my plan, yes

[16:21] <jnthn> .oO( When somebody isn't trying to distract him with even moar to do... :) )

[16:21] <FROGGS[mobile]> I hope that the test cicle gets shorter when we have moar

[16:22] <FROGGS[mobile]> because after every change I often have to spectest, which takes 40min on four cores

[16:22] <timotimo> ouch :(

[16:24] <FROGGS[mobile]> and then at some point diakopter++ wants to have that parser

[16:24] <diakopter> o_O

[16:25] <timotimo> you mean the integration of perl5 into moarvm?

[16:25] <FROGGS[mobile]> :o)

[16:26] <timotimo> is any of you going to the chaos communication congress in hamburg this year per chance?

[16:26] <FROGGS[mobile]> timotimo: yes, when the first step (not inlined code) wollen probably not need it

[16:26] <FROGGS[mobile]> timotimo: no

[16:27] <jnthn> The first step is gonna be knitted? :D

[16:27] <FROGGS[mobile]> Bah!

[16:27] <FROGGS[mobile]> mobile phone typing sucks :p

[16:27] <jnthn> timotimo: Not me, my only two remaining events this year are Nordic Perl Workshop and Build Stuff

[16:28] <tadzik> not LPW?

[16:28] <FROGGS[mobile]> (Build Stuff)++

[16:28] <jnthn> tadzik: No, 'fraid not.

[16:29] <jnthn> tadzik: My work schedule is nuts. I'm only making NPW 'cus it's just a short train journey away.

[16:29] <tadzik> I see

[16:29] <jnthn> Woulda been fun to do LPW, though. It's always a great time.

[16:29] <jnthn> Ah well, it's yearly. :)

[16:29] <tadzik> I was considering going

[16:29] <FROGGS[mobile]> what is LPW again?

[16:29] <jnthn> FROGGS[mobile]: London ...

[16:29] <timotimo> london perl workshop

[16:29] <tadzik> that would've been like 12th flight this month though, I'm starting to hate those :P

[16:29] <FROGGS[mobile]> ahh yes

[16:30] <jnthn> tadzik: Yes, while I technically could squeeze it in, I'm feeling kinda the same about travel :)

[16:30] <FROGGS[mobile]> I always hate flighs

[16:30] <diakopter> EMOARFLIGHTSPLEASE

[16:31] <tadzik> I miss trains. Trains are so fun

[16:31] <jnthn> Yeah, I do train when I can.

[16:31] <tadzik> hah

[16:31] <tadzik> I see what you did there :P

[16:31] <jnthn> But not always practical.

[16:31] <timotimo> so what you're trying to say is ... "i like trains"?

[16:31] <jnthn> :D

[16:31] <tadzik> :D

[16:31] <tadzik> zzzzzzumm

[16:31] <jnthn> hah, I was thiking about "I like trains" :)

[16:32] <tadzik> now diakopter gets that joke too :P

[16:32] <diakopter> no, llama, no

[16:40] *** dmol joined
[16:42] *** kaleem joined
[16:42] *** FROGGS joined
[16:42] *** FROGGS[mobile] left
[16:42] * timotimo now can't get the thought of obama singing "i like change" out of his head

[16:43] * tadzik imagines obama with his head opening like that of canadians in South Park, so he can sing out of it

[16:44] *** zakharyas left
[16:45] <diakopter> PIE FLAVOR

[16:45] *** raiph joined
[16:46] <tadzik> isn't that Flavour? :P

[16:47] <diakopter> FEED ME PAPER

[16:47] <diakopter> THERE'S NO DOG THERE

[16:47] <diakopter> I AM YOUR SANDWICH

[16:47] <TimToady> and you pronounced PIE wrong

[16:48] *** fhelmberger_ joined
[16:48] <diakopter> oh wait, this isn't a camera

[16:50] <diakopter> WHY WAIT

[16:51] *** berekuk left
[16:51] <diakopter> hello mine turtle. hello.

[16:51] *** fhelmberger left
[16:51] <diakopter> no because I work at teh muffin factory

[16:53] <tadzik> funny, it always sounded like "ze muffin factory" to me

[16:53] *** fhelmberger_ left
[16:54] * TimToady shakes his head for various reasons

[16:55] * FROGGS thinks that music is one of the best

[16:55] <moritz> or drying your hair!

[16:55] <diakopter> I'm gonna do an internet ... MUSIC

[16:55] <moritz> ok, my hair isn't long enough for that to make any sense

[16:56] <diakopter> 3p6gXgiVEzY

[16:59] <FROGGS> hehe

[16:59] <FROGGS> moritz: mine almost is by now :o)

[16:59] *** ajr joined
[17:00] *** ajr is now known as Guest8089

[17:00] <TimToady> I believe the DSM-5 has a category for this channel...probably several categories...

[17:00] *** Guest8089 is now known as ajr_

[17:04] *** GlitchMr left
[17:07] <timotimo> lamecia pls

[17:09] <jnthn> Did we start on advent calendar signups yet?

[17:09] <tadzik> yes

[17:10] <tadzik> hurry up, while there are still some slots :)

[17:10] * jnthn tries to find it

[17:10] <jnthn> Oh...there it is

[17:11] <jnthn> uh, yeah, hot competition for slots here :P

[17:11] * jnthn wonders what he's done in the last year and could talk about... :)

[17:12] <FROGGS> humm

[17:12] <FROGGS> I should probably write about S11

[17:12] <FROGGS> and v5?

[17:12] *** kaleem left
[17:12] <jnthn> Good ideas.

[17:12] <jnthn> I guess I could do one about JVM.

[17:13] <jnthn> As in, Rakudo on JVM

[17:13] <FROGGS> and parallism

[17:13] <jnthn> Yes, that too

[17:13] <FROGGS> and one about moar perhaps

[17:15] <dalek> mu: 948d9d4 | jonathan++ | misc/perl6advent-2013/schedule:

[17:15] <dalek> mu: Take three slots.

[17:15] <dalek> mu: review: https://github.com/perl6/mu/commit/948d9d48bb

[17:16] *** fhelmberger joined
[17:16] <jnthn> FROGGS: There's moar moar hackers than me, so I think maybe somebody else might pick that up...

[17:16] <FROGGS> yeah, maybe somebody does :o)

[17:16] *** GlitchMr joined
[17:16] *** [Sno] joined
[17:16] <jnthn> If we were to put a Moar one towards the end of December we stand a good chance of having Rakudo on MoarVM running stuff by it.

[17:16] *** xinming left
[17:17] *** xinming joined
[17:17] <jnthn> oh, I shoulda maybe put my name on those entries, so folks know I'm on the hook for 'em...

[17:18] <dalek> mu: b64fb21 | jonathan++ | misc/perl6advent-2013/schedule:

[17:18] <dalek> mu: Mark who's doing my days.

[17:18] <dalek> mu: review: https://github.com/perl6/mu/commit/b64fb21e39

[17:19] <dalek> rakudo-star-daily: e25a847 | coke++ | log/ (5 files):

[17:19] <dalek> rakudo-star-daily: today (automated commit)

[17:19] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/e25a84724e

[17:19] <dalek> perl6-roast-data: 483c822 | coke++ | / (5 files):

[17:19] <dalek> perl6-roast-data: today (automated commit)

[17:19] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/483c822384

[17:20] *** Celelaptop joined
[17:20] <FROGGS> jnthn: I think that "we" are on a good trak about perl6-m :o)

[17:20] *** rurban1 joined
[17:21] <jnthn> I may well get an hour or two for it tonight. We'll see.

[17:22] <jnthn> Got ahead on the $dayjob stuff yesterday, but then lost a chunk of today to anesthetic and drilling...

[17:22] <jnthn> :/

[17:22] <[Coke]> Ow.

[17:22] <FROGGS> uhh :o/

[17:24] <FROGGS> youtube: "Larry Wall - That Goes Without Saying (or Does It?)"++

[17:25] <dalek> specs: c5b7d73 | larry++ | S17-concurrency.pod:

[17:25] <dalek> specs: winner ~~ s/nobody/wait 0/

[17:25] <dalek> specs: review: https://github.com/perl6/specs/commit/c5b7d733fb

[17:31] *** jnap left
[17:32] <jnthn> Hmm.

[17:32] <jnthn> Guess that works.

[17:32] <TimToady> the problem with using anyof is that the degenerate case of timeout isn't guaranteed to poll

[17:33] <jnthn> Poll?

[17:34] <TimToady> anyof($p1, $timer) can just give you the timer promise if it's 0 without checking $p1

[17:34] <jnthn> Ah, true.

[17:35] <TimToady> whereas winner's 'wait 0' guarantees to be checked last

[17:35] <jnthn> Well, it doesn't give you anything per se.

[17:35] <jnthn> anyof is just kept with True and it's up to you to go look at what that means.

[17:35] <TimToady> right, but it's a funny little race condition there

[17:36] <TimToady> might be harmless, might not

[17:36] <jnthn> The fact it doesn't give you back a promise and makes you decide what to check is part of what helps make it most likely harmless. :)

[17:36] *** fhelmberger left
[17:36] <TimToady> I thought it does give back a promise, just a different one

[17:37] <jnthn> Yeah, sorry, misspoke

[17:37] <jnthn> It gives you one, but when it's kept it's just kept with True.

[17:37] *** fhelmberger joined
[17:37] <TimToady> anyway, we need something like winner if we're going to set up gladiatorial winner semantics

[17:38] <jnthn> As opposed to giving you the promise/value that made it be considered as kept.

[17:38] <TimToady> which winner can do, but is not required to

[17:39] <TimToady> btw, I'm assuming we're demoting winner from statement_control to a mere (but fancy) term

[17:39] <jnthn> In general, though, I think anyof/allof are useful in the cases where you want to do something afterwards which is not based on the results of the input promises.

[17:39] <jnthn> As in, "once once of them has done it's thing then go on and do..."

[17:40] <jnthn> Typically you're probably doing something else with the rsult.

[17:40] <jnthn> So they're primarily useful for synchronization. rather than racing to a result like winner is good for.

[17:40] *** ssutch joined
[17:40] <dalek> std: d075830 | larry++ | STD.pm6:

[17:40] <dalek> std: demote winner/combine to term

[17:40] <dalek> std: review: https://github.com/perl6/std/commit/d075830f3f

[17:41] *** kaare_ left
[17:41] *** fhelmberger left
[17:43] <dalek> mu: 5f9d992 | (Tobias Leich)++ | misc/perl6advent-2013/schedule:

[17:43] <dalek> mu: took two slots

[17:43] <dalek> mu: review: https://github.com/perl6/mu/commit/5f9d992d20

[17:43] <TimToady> I think we don't need special syntax to implement gladiation; the winning entity has sufficient information to optionally kill the losers if the losers provide a passable (pun intended) api.

[17:46] *** jnap joined
[17:46] <TimToady> ESL lesson: "Elves are immortal, but passable."

[17:48] *** darutoko left
[17:48] <huf> TimToady: you'd need a very large intestine...

[17:49] <jnthn> We can write a timeout combinator for the simple cases too :)

[17:49] * TimToady revokes huf's pass.

[17:49] <geekosaur> well, we do use double colons for objects :p

[17:49] <TimToady> jnthn: treu

[17:49] <huf> TimToady: so i ... i cannot pass?

[17:50] <TimToady> I have a bridge to sell you.  It's not all it's cracked up to be...

[17:50] <jnthn> *lol*

[17:50] *** stevan__ joined
[17:51] <huf> heh :)

[17:51] <TimToady> you fell for it, did you?

[17:53] *** stevan_ left
[17:58] *** jeffreykegler left
[18:01] *** colomon left
[18:01] <dalek> roast: 259ed8d | coke++ | test_summary:

[18:01] <dalek> roast: FIX jvm fudgespec skip

[18:01] <dalek> roast: review: https://github.com/perl6/roast/commit/259ed8d39e

[18:03] *** dakkar left
[18:04] *** jeff_s2 joined
[18:05] *** jeff_s1 left
[18:09] *** baest left
[18:09] *** baest_ joined
[18:10] *** colomon joined
[18:15] *** mattp_ left
[18:18] * FROGGS .oO( say fast "fudgespec skip, fudgespec skip, fudgespec skip, fudgespec skip, fudgespec skip" )

[18:18] *** aindilis` joined
[18:18] *** aindilis left
[18:18] <TimToady> .oO( can I just think it fast? )

[18:19] <FROGGS> if you imagine saying it :o)

[18:19] <TimToady> I imagined saying it fast.  :P

[18:20] <timotimo> goalpost movement again, he?

[18:20] <timotimo> eh?

[18:20] <TimToady> just generalized the goalpost to a finish line :)

[18:21] <diakopter> wheh

[18:22] <TimToady> heh, pick two.

[18:22] * timotimo is not sure any more what exactly he has to change

[18:22] <timotimo> if i change winner to a term, i can keep more, done and later (albeit renamed) as statement_modifier?

[18:23] <TimToady> only winner and combine need to be terms

[18:23] <TimToady> so we don't have to keep putting 'do' in front of them

[18:24] <timotimo> i don't know about combine yet

[18:24] <timotimo> what does that do?

[18:24] <timotimo> is that for combining multiple channels into one?

[18:24] <TimToady> combinates taps rather than promises/channels

[18:25] <timotimo> ah, ok

[18:25] <TimToady> and a timeout probably doesn't make sense for it, unless it does.

[18:25] <jnthn> combine basically sets up an actor that is also tappable.

[18:26] <TimToady> but there's no polling, so 'wait 0' makes no sense

[18:26] <jnthn> And that taps many other supplies

[18:26] *** mattp_ joined
[18:26] <jnthn> The actor-ness needed 'cus you don't get to control when the supplies you tap throw stuff at you.

[18:26] <jnthn> But you do want to write code without having to lock everywhere.

[18:28] <jnthn> shop &

[18:28] <TimToady> channels are locking in the sense that if you exert any queing backpressure, the throwers have to stop throwing until you catch up

[18:28] <timotimo> jnthn: do you expect me to implement combine as well until your talk? :)

[18:28] <TimToady> it's probably easier than winner :)

[18:29] <TimToady> you don't worry about the scheduling, only composition of callbacks

[18:30] *** jeff_s2 left
[18:30] <jnthn> timotimo: Well, it's only syntaxing the "on" that I already implemented...

[18:30] <jnthn> I don't think it's undergone any big semantic changes.

[18:31] <TimToady> not really, though thinking about changing tap to take one positional and two named args rather than three positionals

[18:31] <timotimo> i don't know what the on thing is you're talking about :P

[18:31] *** jeff_s1 joined
[18:31] <timotimo> but i'll dive into my code again

[18:31] <TimToady> so the named args can look like they do in combine

[18:32] <TimToady> timotimo: it's just like .then on a promise, only more so :)

[18:32] <timotimo> ah

[18:32] <timotimo> that doesn't seem like a syntaxing thing to me. more like a method call

[18:33] <jnthn> TimToady: I think I'm good with the named args approach

[18:33] <TimToady> still not sure I want to call failure 'fail' though, since that conflicts with the builtin function

[18:34] <jnthn> Well, I named it "fail" on purpose to say "you're shoving an exception somewhere else"

[18:34] <jnthn> It felt strangely consistent.

[18:34] *** lizmat joined
[18:35] <jnthn> really shop &

[18:35] <TimToady> it is, but it prevents us from ever defining winner/combine like we do class bodies: run the non-declarative statements, then take the declarations and compose something

[18:36] <TimToady> in fact, winner/combine should probably be called declarators

[18:38] <ajr_> I just noticed the update to S32, about listless map {} - is that an especially lazy form of the instruction?

[18:39] <timotimo> no, it's just as lazy as map 0..* {}

[18:39] <lizmat> map {}, 0..* actually

[18:39] <timotimo> er, yes

[18:40] *** pecastro_ left
[18:40] <lizmat> but hopefully without the overhead of an actual counter going from 0 to Inf

[18:40] *** pecastro joined
[18:41] <timotimo> yup

[18:41] <timotimo> that wouldn't be much, but still.

[18:44] *** [Sno] left
[18:44] * timotimo chased the renames and turning winner into a term

[18:44] *** ggoebel joined
[18:44] *** [Sno] joined
[18:44] * TimToady is turning them into declarators now :)

[18:44] <timotimo> oh, but wait needs to take an xblock now, too

[18:44] <TimToady> yep

[18:44] <timotimo> do declarators already exist?

[18:44] <TimToady> hang on

[18:45] <diakopter> all the things to declarators

[18:46] <timotimo> there are many proto tokens something_declarator

[18:46] <dalek> std: 87ac055 | larry++ | STD.pm6:

[18:46] <dalek> std: add combinator_declarator

[18:46] <dalek> std: review: https://github.com/perl6/std/commit/87ac055582

[18:46] <timotimo> ah, indeed, there's a tokne declarator

[18:46] *** masak_ is now known as masak

[18:46] <masak> oh hai, #perl6

[18:46] <FROGGS> masak: \o/

[18:47] <diakopter> TimToady: but the marcos

[18:47] <timotimo> now we have catch and CATCH?

[18:47] <diakopter> ermasak, macros

[18:47] <masak> :P

[18:47] <FROGGS> masak: welcome back :o)

[18:47] <masak> thank you :)

[18:47] <moritz> masakro!

[18:47] <TimToady> catch is only for use inside 'combine'

[18:48] *** PZt left
[18:48] <timotimo> hi masak :)

[18:48] <TimToady> it's better than 'fail', and since the failure comes in as $_, it might end up looking a lot like a CATCH on the inside anyway

[18:48] <masak> "I love it when a unification comes together"

[18:48] <timotimo> how's life? how's t4? how's that super cool trick with feeds to implement your blog in only 5 lines of code?

[18:49] <masak> timotimo: thank you for asking.

[18:49] *** PZt joined
[18:50] <masak> timotimo: (a) life, of the kind that doesn't happen on #perl6 but happens out in Cartesian space, with other people, is catching up with me. it's great, but leads to little time for #perl6.

[18:50] <masak> timotimo: (b) t4 is standing still right now. it's at the top of my list, though.

[18:51] <masak> timotimo: (c) that super cool trick is still alive and well. stand by.

[18:51] <masak> man, I nees to backlog.

[18:51] <masak> need*

[18:52] <timotimo> sounds good, glad to hear :)

[18:53] <masak> how does 'done' as a combinator declarator rhyme with 'done;' as a Test.pm sub?

[18:55] *** prevost joined
[18:56] <dalek> rakudo/WINNER: 5ba95a7 | (Timo Paulssen)++ | src/vm/jvm/core/asyncops.pm:

[18:56] <dalek> rakudo/WINNER: a single named positional is fine for done/more, too.

[18:56] <dalek> rakudo/WINNER: review: https://github.com/rakudo/rakudo/commit/5ba95a7529

[18:56] <dalek> rakudo/WINNER: dcc8b05 | (Timo Paulssen)++ | src/ (5 files):

[18:56] <dalek> rakudo/WINNER: chase lots of changes to winner:

[18:57] <dalek> rakudo/WINNER: 

[18:57] <dalek> rakudo/WINNER: - all the statements are now in the new class "combinator_declarator"

[18:57] <dalek> rakudo/WINNER: - "later" is now called "wait" and always takes a parameter.

[18:57] <dalek> rakudo/WINNER: - "combine parses, but throws NYI for now.

[18:57] <dalek> rakudo/WINNER: review: https://github.com/rakudo/rakudo/commit/dcc8b05564

[18:59] <FROGGS> tadzik: there is a panda PR

[19:02] <timotimo> aaaand it doesn't compile

[19:02] <moritz> ‚ô™ the winner took it all ‚ô´

[19:02] <lizmat> masak: I guess it will confuse the fudger a lot

[19:02] <masak> not sure the fudger cares about 'done'

[19:02] *** rindolf left
[19:03] <masak> but I was thinking, how does the Perl 6 parser distinguish?

[19:03] <jnthn> r: sub when() { }; when;

[19:03] <FROGGS> you'd have to use done(), right?

[19:03] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: ( no output )

[19:03] <jnthn> Apparently it can there...

[19:03] <dalek> specs: d0fb631 | larry++ | S17-concurrency.pod:

[19:03] <dalek> specs: s/fail/catch/ on receiving end, tap has named args

[19:03] <dalek> specs: review: https://github.com/perl6/specs/commit/d0fb63154a

[19:04] <timotimo> i'm not sure why it's wrong ...

[19:04] <diakopter> masak: I'm afraid you'd never finish backlogging... it's grown tremendously lately

[19:04] * TimToady is tired of collisions with Test.pm

[19:04] <masak> "ypu'd have to use done()" sounds like a rather big change to the existing spectest suite.

[19:05] <TimToady> just a perl -i  :)

[19:05] <masak> and to the ecosystem in general.

[19:05] <timotimo> why would winner $self { more * { $_ }\ndone * { last } } give TTIAR?

[19:05] <FROGGS> masak: I didn't say that I would like or recommend it :o)

[19:05] <masak> big breaking change.

[19:05] <TimToady> timotimo: shouldn't, if that's parsed as a statement list

[19:06] <jnthn> masak: I think my example of when; above working shows that this may also not cause a problem.

[19:06] <timotimo> i implemented winner as <sym> <xblock> and more and friends as <sym> <xblock(1)>

[19:06] <timotimo> and combinator_declarator is inside declarator

[19:06] <masak> jnthn: indeed.

[19:07] <masak> r: sub when() { }; when

[19:07] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: ( no output )

[19:07] <FROGGS> rp: sub say () { say 42 }; say

[19:07] <TimToady> it could be forced with a dynvar

[19:07] <camelia> rakudo-parrot 75c45f: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Calling 'say' will never work with argument types (int) (lines 1, 1)‚ê§    Expected: :()‚ê§¬ª

[19:08] <TimToady> most keywords require a space after, so done; is fine

[19:08] <TimToady> fail "foo"; # not so much

[19:09] <timotimo> sadly, rxtrace is immensely unhelpful

[19:09] *** diakopter is now known as TimToTimTo

[19:10] <FROGGS> hmmm, I feel like panda needs to adjust its shebang line when it installs itself (or other executables for that matter)

[19:11] <TimToady> std: my $self; winner $self { more * { $_ }‚ê§done * { last } }

[19:11] <camelia> std d075830: OUTPUT¬´ok 00:01 125m‚ê§¬ª

[19:11] <FROGGS> maybe it should even create panda[-p|-j] variants

[19:11] <japhb> FROGGS: +!

[19:11] <japhb> FROGGS: +1

[19:11] <FROGGS> japhb: to which statement? :o)

[19:12] <timotimo> could it be declarator in rakudo is significantly different from the one in std?

[19:12] <japhb> There are some times when I want to install a module to All The Backends, but other times that I have a module that only works on a limited number of backends (and will fail tests on the others)

[19:12] <TimToady> did you add <combinator_declarator> as an alternate in declarator?

[19:12] <timotimo> yes

[19:13] <FROGGS> hmmm

[19:13] <japhb> Also, I am also +1 to adjusting shebang lines to match the backend a script is being "compiled" for.

[19:13] <TimToady> and added the syntax category?

[19:13] <TimToady> and didn't misspell anything?

[19:13] <timotimo> the ... syntax category?

[19:14] <FROGGS> japhb: well, that would introduce a problem actually

[19:14] <timotimo> i have a proto token if you mean that

[19:14] <japhb_> timotimo: See the beginning of TimToady's STD patch

[19:14] <japhb> FROGGS, oh?

[19:14] <FROGGS> japhb: maybe I can only solve it by S11 itself

[19:14] *** SamuraiJack left
[19:14] <TimToady> timotimo: yeah, the first green bit of https://github.com/perl6/std/commit/87ac055582

[19:14] *** TimToTimTo is now known as diakopter

[19:14] <timotimo> no, i did not do such a thing, i thought that was an std thing

[19:15] <TimToady> it's a Perl 6 thing :)

[19:15] <FROGGS> japhb: ahh, not sure, need to think more careful

[19:15] <japhb> Thinking: It's dangerous.

[19:15] <timotimo> huh, i don't see an equivalent in rakudo's grammar

[19:15] * TimToady wonders why the lexer generator didn't complain about a missing <combinator_declarator> method...

[19:16] <FROGGS> japhb: panda should get at least a --backends option

[19:16] <japhb> YES

[19:16] *** sqirrel joined
[19:16] <TimToady> timotimo: it's usually called a proto rule or some such in rakudo

[19:16] <FROGGS> otherwise you could only install modules for your default backend

[19:17] <timotimo> i have a proto token combinator_declarator { <...> }

[19:18] <lizmat> japhb: like p5, I think you should only be able to install for that version of perl you're currently running with

[19:19] <ggoebel> PO

[19:19] <japhb> lizmat: Sure, but in the current world, you can have perl6-p, perl6-j, perl6-m all in your path, and perl6 symlinked to one of them.  Panda should get the same treatment.

[19:20] <FROGGS> good point, so I#d have to: `which panda` and then `perl6-p /path/to/panda`

[19:20] *** fhelmberger joined
[19:20] <ggoebel> sorry... cat typing

[19:20] <diakopter> meow

[19:20] <FROGGS> cat++

[19:20] *** prevost left
[19:21] <TimToady> duck typing, monkey typing--what's cat typing?  ;)

[19:21] *** xinming left
[19:21] <TimToady> category theory, I suppose...

[19:21] *** xinming joined
[19:22] <geekosaur> cats do what they damned well please, therefore...

[19:24] <huf> "cat" and "ego" go well together

[19:24] <huf> and if you dont pay attention to that ego, things can get "gory"

[19:24] <huf> so this seems to fit

[19:25] <masak> * lizmat just realized that (+=) for atomic updates is bogus

[19:25] <TimToady> timotimo: do you need to insert <.end_keyword> to require the ' ' after the keyword?

[19:25] <timotimo> oh, i may

[19:25] <masak> lizmat: so, how about we revert 71fd6d3abb1c5b360eae4d424a342bc6a0cb03da?

[19:25] <TimToady> otherwise you tie with <ident>

[19:27] <lizmat> masak: no, not completely

[19:28] <diakopter> lizmat: you didn't reply to my question about that

[19:28] <timotimo> i'm still getting TTIAR

[19:28] <diakopter> how is it bogus

[19:28] * TimToady wonders why we don't just have a cas($var,$newvalue) function or macro

[19:28] <diakopter> lizmat: er, I didn't see a reply

[19:28] <timotimo> oh, i may have to remove the whitespace between <sym> and <.end_keyword>

[19:28] <TimToady> or make it a token, yes

[19:28] <masak> lizmat: well, it was worth a shot.

[19:29] <lizmat> why was it worth a shot?

[19:29] <masak> asking for it to be reverted.

[19:29] <timotimo> that seems to have fixed it, yay

[19:29] <timotimo> i spoke too soon

[19:29] <masak> lizmat: oh, "why", not "what"...

[19:29] <lizmat> but why would *you* want to have it reverted, and are ok with it staying ?

[19:30] <lizmat> why are you Dutch so suspicious?

[19:30] <masak> I don't believe that there is a sane connection between set operations and (+=)

[19:30] <PerlJam> The capitalization in S17:807 makes me think it should be ACS instead of CAS ... unless this is another one of those french things like UTC

[19:30] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_807

[19:30] <lizmat> .oO( why do you want to know ? )

[19:30] <TimToady> No true Scotsman is Dutch.

[19:30] <masak> I don't believe we should have operators for CAS things. at least not in core.

[19:31] <diakopter> but why wouldn't the operator just do the right thing for cas variables

[19:31] <TimToady> so what is += supposed to return?

[19:31] <dalek> specs: 73f60f7 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[19:31] <dalek> specs: Remove (+=) and friends cas operators

[19:31] <dalek> specs: review: https://github.com/perl6/specs/commit/73f60f728c

[19:32] <lizmat> yes, "is cas" makes much more sense

[19:32] <TimToady> CAS is all about known absolute values, not relative values

[19:32] <diakopter> why was the += bogus?

[19:32] <TimToady> ^^

[19:32] <lizmat> because then it would handle things hopefully correctly

[19:32] <lizmat> because CAS should be hooked to a variable, not to an operation

[19:32] * TimToady dislikes 'is cas' changing the return semantics of $var = $newvalue

[19:33] <lizmat> you want *all* accesses to a var to be CAS, not just some

[19:33] <diakopter> that's not true

[19:33] <diakopter> but you do want the defaults to be cas usually

[19:33] <jnthn> I think cas has to be about operations, not about variables...

[19:33] <TimToady> +1

[19:34] <TimToady> it's a very low-level operation

[19:34] <TimToady> there's very little point in trying to abstract it

[19:34] <jnthn> Well, also, it's kinda transaction-y

[19:34] <jnthn> Meaning you need to know the bounds of yoru transaction.

[19:34] <masak> I totally don't see why CAS can't just be, you know, a sub.

[19:35] <lizmat> " is cas" bounds the transaction to updates to a single variable ?

[19:35] <masak> trying to *design* it to be something else, without trying it practically in Perl 6, is premature to say the least.

[19:35] <TimToady> lizmat: what is the lifetime of that variable?  what if you return it?

[19:35] <masak> the only reason we should spec a thing like that is if we like spec that turns out wrong over time.

[19:36] <lizmat> TimToady: I see "is cas" hanging off of the containerdescriptor, like "is default"

[19:36] <diakopter> masak: it can't be a sub because the compiler needs to know how to get at the variables' memory directly

[19:37] * TimToady sentences everyone who is confused to reread http://en.wikipedia.org/wiki/Compare-and-swap

[19:37] <masak> diakopter: that sounds like 'is rw' semantics to me.

[19:37] <TimToady> that's why I said it might be a macro even

[19:37] <TimToady> or a built-in, I suppose I should say

[19:37] *** kurahaupo_mobile left
[19:37] <jnthn> masak: I did it as a sub in the spec, fwiw

[19:37] <TimToady> it can certainly parse like a sub :)

[19:37] <masak> I suppose I meant "look like a sub". it's fine if it's a built-in.

[19:38] <diakopter> jnthn: but that sub in the spec makes no sense

[19:38] <jnthn> diakopter: How so? :)

[19:38] <jnthn> diakopter: I didn't put anything into S17 that I didn't already know how to implement, or already had implemented :P

[19:38] <TimToady> diakopter: he said "something like", so it's fine :P

[19:39] <diakopter> jnthn: I'm thinking of the one that had the + operation in it

[19:39] <jnthn> diakopter: cas($a, { $_ + 1) # like this?

[19:39] <jnthn> uh, but with the }

[19:40] <diakopter> yes

[19:40] <diakopter> how does the compiler make that cas

[19:40] <TimToady> I don't see anything like that at S17:816

[19:40] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_816

[19:40] <masak> "using internals"

[19:40] <jnthn> diakopter: It doesn't need to, given $a is a scalar container, so we operate on updating its contents.

[19:40] <timotimo> i think it's parsing winner, then starts parsing an expression and then gets surprised by the {

[19:40] <jnthn> diakopter: But it's just a generalization of the usual CAS pattern.

[19:40] <timotimo> how do i make that work?

[19:41] <diakopter> jnthn: but how does the read of the prior value work with the +

[19:41] *** kivutar_ joined
[19:41] *** kivutar_ left
[19:41] <diakopter> (where does it inject the atomic cpu instruction)

[19:41] <TimToady> timotimo: s/block/xblock/ everywhere?

[19:42] <lizmat> I always interpreted S17:816 as pseudocode, to get the point across

[19:42] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_816

[19:42] *** colomon left
[19:42] <FROGGS> why does `time perl6-p panda` take 6.3s?

[19:42] <jnthn> loop { my \orig = nqp::decont($a); my \new = nqp::decont(the_block(orig)); last if cas_scalar($attr, new, orig) == orig; }

[19:42] <timotimo> TimToady: yes, i did that

[19:42] <TimToady> FROGGS: maybe it's calling out to perl6-j :)

[19:43] <FROGGS> TimToady: no, that'd only need 4.7s :o(

[19:43] <diakopter> jnthn: okay, but that eliminates the possibility of using the increment atomic op

[19:43] <diakopter> or the add atomic op

[19:44] <TimToady> that's a matter for the optimizer

[19:44] <jnthn> diakopter: Oh...then the real thing at issue is I wrote a crappy example that's better done with something else :)

[19:44] <FROGGS> the timomizer?

[19:44] <diakopter> jnthn: well, I'm sure it's possible to optimize to incr or add, but I can't see how yet

[19:45] <TimToady> maybe we should switch to the CAS style that returns success or failure

[19:45] *** woolfy joined
[19:45] <TimToady> rather than doing our own comparison

[19:46] <jnthn> The thing about all of this is that I see cas as a *low level* thing.

[19:46] <TimToady> metoo

[19:46] <TimToady> if an architecture needs a different primitive, we may be talking about conditional compilation

[19:46] <jnthn> The sugar form I suggested is just abstracting a common "read an immutable data structure, make a new one incorporating the change, and try to "commit" the reference update" pattern

[19:47] <TimToady> but most modern architectures support CAS now

[19:47] <TimToady> in some form or other

[19:48] <TimToady> albeit with a rather limited number of bits in some cases

[19:48] <TimToady> CAS on an int32 is a much different matter than CAS on an Int

[19:49] <TimToady> the latter is likely close to impossible without going toward STM

[19:49] <japhb_> ... and double-wide CAS

[19:49] <TimToady> still limited

[19:49] <diakopter> we have to do our own comparison on the CAS on the Int, and are updating pointers

[19:49] <diakopter> (and definitely can't do the atomic incr or add)

[19:49] <TimToady> the transaction becomes much larger

[19:49] <timotimo> TimToady: could there be a reason why combinator_declarator isn't the right category for something that takes an xblock?

[19:49] <FROGGS> ahh, the slow thing is probably that it checks for the first writeable diretory and does other setup tasks

[19:49] <lizmat> couldn't CAS just not work on an container descriptor attribute that gets incremented on every update ?

[19:49] <japhb_> ISTR that PowerPC has a different primitive than CAS that it prefers, but I don't recall what it is offhand.

[19:50] <timotimo> because it doesn't seem like the xblock will terminate the <EXPR> at the right moment for a block to be acceptable

[19:50] <TimToady> it shouldn't be any different from an ordinary xblock in a statement list in that regard

[19:51] * japhb_ wonders how many canon_path calls get done during panda startup

[19:51] <TimToady> but maybe rakudo adds more semantics to xblock that are interfering?

[19:51] <lue> I'm assuming compiling r-m, I should expect a bunch of "WARNING: nominal type check NYI" compiling CORE.setting, right? :)

[19:51] <TimToady> STD is just a parser, after all

[19:51] <timotimo> lue: yes

[19:51] <lizmat> jnthn, diakopter: couldn't CAS just not work on an container descriptor attribute that gets incremented on every update ?

[19:51] <diakopter> I don't know about such attributes

[19:52] *** fhelmberger left
[19:52] <japhb_> Actually FROGGS: I'd lay some odds it's either A) you're running an not-yet-installed panda, so no modules are compiled, or B) the cost of parsing the module list JSON

[19:52] <timotimo> TimToady: would it be terrible if i turned it into a term for the time being? because ISTR that worked

[19:52] *** kurahaupo joined
[19:52] <FROGGS> japhb: it is an installed panda

[19:52] *** fhelmberger joined
[19:52] * TimToady shrugs

[19:52] <lizmat> two threads update the same variable: each one checks the value of the container attribute before and after the change is completed:

[19:53] <timotimo> i'll try that again then.

[19:53] <diakopter> lizmat: well the low-level cas operation returns the orig value

[19:53] <TimToady> lizmat: you're starting to talk STM, not CAS

[19:53] <diakopter> so it doesn't/can't check it afterwards

[19:53] <lizmat> TimToady: perhaps, I still like STM  :-)

[19:53] <timotimo> though i think i can only change winner and combine into term and leave the others statement_control again

[19:54] <timotimo> because done, more, catch and wait wouldn't be wanted in expressions inside winner/combine blocks

[19:54] <TimToady> is fine for now

[19:57] *** fhelmberger left
[19:59] <diakopter> lizmat: the low-level cas operation (probably repr "method^Wsomething less inflammatory") returns the original, so that's the value that's checked to see whether it was successful

[20:00] <diakopter> (whether it's checked within the op or not - either way)

[20:01] <dalek> rakudo/nom: a7ae9a9 | (Elizabeth Mattijsen)++ | docs/release_guide.pod:

[20:01] <dalek> rakudo/nom: A friendly reminder that we have a release soon

[20:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a7ae9a90d5

[20:02] <diakopter> lizmat: oh now I see what you were suggesting with the incremented version number; that's a form of a lock

[20:03] <lizmat> indeed

[20:03] <timotimo> i can't seem to get it to work at all right now :o

[20:05] <FROGGS> japhb: 0.6s slurping a 35kb file, 4.5s spent on from-json for that file

[20:05] *** dwarring joined
[20:05] <diakopter> jnthn: OHHH you said "reference update"

[20:06] <diakopter> I thought we were talking about integer instructions.. didn't realize we were talking bout boxed thingsies

[20:06] <jnthn> diakopter: oh!

[20:06] <jnthn> :)

[20:06] <diakopter> jnthn: so yes, clearly no possibility for xincr or xadd there

[20:07] <jnthn> diakopter: Yeah, I shoulda spotted the mis-understanding when you said that. Sorry. Not at my sharpest today...

[20:07] *** sqirrel left
[20:07] <japhb> FROGGS, yeah, both of those numbers are horrid.

[20:07] <japhb> That's why https://github.com/japhb/perl6-bench/blob/master/perl6/parse-json

[20:08] <diakopter> jnthn: however, my question then is about primitive vars.. how to use the special syntax to do atomic incr/add

[20:08] <jnthn> diakopter: Yeah, I didn't try to attach either of those. :)

[20:09] <diakopter> attach?

[20:09] <diakopter> attack?

[20:10] <jnthn> uh, attack

[20:10] <jnthn> wtf :)

[20:10] <diakopter> i like trainses

[20:10] <lizmat> .oO( until your car detaches )

[20:10] <FROGGS> japhb: I see

[20:11] <diakopter> lizmat: it's an allusion to the asdfmovie 1-6 where the kid who likes trains get smushed by trains often

[20:11] <lizmat> fortunately we only get smashed

[20:11] <lizmat> by trains of thought here

[20:11] * masak is on a train

[20:12] *** dave1c_ joined
[20:12] <timotimo> wtf is this i don't even

[20:13] <lizmat> get cut short ?

[20:13] *** iSlug left
[20:13] * timotimo tries putting the rules someplace else

[20:13] <dalek> std: 8370f3f | larry++ | STD.pm6:

[20:13] <dalek> std: undo 87ac0555827223eec4da40c72dfeab90b996f525

[20:13] <dalek> std: review: https://github.com/perl6/std/commit/8370f3fc57

[20:14] *** dave1c left
[20:14] <timotimo> oh

[20:14] <timotimo> did my plight inspire pity in you?

[20:15] <masak> TimToady: when you undo commits, do you perchance use `git revert`?

[20:16] *** xenoterracide joined
[20:17] *** kurahaupo left
[20:18] <timotimo> i made it work >_<

[20:18] <timotimo> it was about a missing <.ws>

[20:18] <timotimo> i'm such a derp sometimes.

[20:18] <lizmat> r: (1).map: start {...}   # strange failure in the bowels of reification

[20:18] <camelia> rakudo-parrot 75c45f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/lvCNQE7osl‚ê§Undeclared routine:‚ê§    start used at line 1. Did you mean '&spurt', '&sqrt', '&sort'?‚ê§‚ê§¬ª

[20:18] <camelia> ..rakudo-jvm 75c45f: OUTPUT¬´Unhandled exception: Method 'count' not found for invocant of class 'Promise'‚ê§  in  (gen/jvm/CORE.setting:7210)‚ê§  in reify (gen/jvm/CORE.setting)‚ê§  in  (gen/jvm/CORE.setting:7122)‚ê§  in reify (gen/jvm/CORE.setting)‚ê§  in gimme (gen/jvm/CORE.setting:‚Ä¶¬ª

[20:19] <timotimo> r: (1).map: do start {...}

[20:19] <camelia> rakudo-jvm 75c45f: OUTPUT¬´Unhandled exception: Method 'count' not found for invocant of class 'Promise'‚ê§  in  (gen/jvm/CORE.setting:7210)‚ê§  in reify (gen/jvm/CORE.setting)‚ê§  in  (gen/jvm/CORE.setting:7122)‚ê§  in reify (gen/jvm/CORE.setting)‚ê§  in gimme (gen/jvm/CORE.setting:‚Ä¶¬ª

[20:19] <camelia> ..rakudo-parrot 75c45f: OUTPUT¬´[31m===[0mSORRY![31m===[0m Error while compiling /tmp/tvuzJQIX9y‚ê§Undeclared routine:‚ê§    start used at line 1. Did you mean '&spurt', '&sqrt', '&sort'?‚ê§‚ê§¬ª

[20:19] <lizmat> it's a runtime error, it compiles ok

[20:20] <timotimo> ah

[20:20] <timotimo> i see that now

[20:20] *** spider-mario joined
[20:21] <jnthn> lizmat: It's the same as if you pass map anything that's not a block.

[20:21] <jnthn> I'm surprised it lets you pass a non-callable at all..

[20:21] <lizmat> argh

[20:21] <lizmat> of course

[20:22] <timotimo> oh duh :D

[20:22] <timotimo> i'm not the only derp around today

[20:22] <jnthn> We can all derp together!

[20:23] <lizmat> j: my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen

[20:23] <camelia> rakudo-jvm 75c45f: OUTPUT¬´1379‚ê§¬ª

[20:23] <timotimo> depr yourself together, man!

[20:23] <lizmat> j: my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen

[20:23] <camelia> rakudo-jvm 75c45f: OUTPUT¬´3000‚ê§¬ª

[20:23] <lizmat> j: my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen

[20:23] <camelia> rakudo-jvm 75c45f: OUTPUT¬´2663‚ê§¬ª

[20:23] <lizmat> j: my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen

[20:23] <camelia> rakudo-jvm 75c45f: OUTPUT¬´3000‚ê§¬ª

[20:23] <lizmat> this worries me

[20:23] <timotimo> your point being? :)

[20:23] <lizmat> j: my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen

[20:23] <camelia> rakudo-jvm 75c45f: OUTPUT¬´1792‚ê§¬ª

[20:23] <jnthn> lizmat: *sigh*

[20:24] <jnthn> Yes, I know I owe you a blog post on why.

[20:24] <lizmat> I want to be able to say something about $seen to have it always be 3000

[20:24] <timotimo> by putting winner and combine as combinator_declarators, i get Unexpected block in infix position again!

[20:24] <timotimo> whyyyyyyy~

[20:25] <timotimo> it worked so flawlessly as statement_control :(

[20:25] <Util> #ps in 5m

[20:26] <timotimo> parsings are hard :(

[20:26] <lizmat> jnthn: I think I know why, but I'd like to see that blog post anyway

[20:27] <timotimo> it would be cool if target=parse could dump the innermost $/ before an error is thrown

[20:27] <lizmat> it's just that I'm *very* worried we wind up in Perl 5.005 threads land :-(

[20:28] *** colomon joined
[20:33] <timotimo> lizmat: parallelism in perl6 relies on composable thingies, which i don't think shared state counts as

[20:34] <lizmat> $seen++ seems pretty composable to me

[20:34] <lizmat> but really, this is about perception and previous experiences

[20:35] <lizmat> people will come to Perl6 and see promises, and start to use them like above

[20:35] <lizmat> and things will not always work

[20:35] <lizmat> and won't generate any errors either

[20:36] <timotimo> hrm

[20:36] <TimToady> why shouldn't reference to an unprotected external lexical cause an error?

[20:36] <timotimo> i'd say you could use a KeyReducer for this case :P

[20:36] <lizmat> it should!

[20:36] <timotimo> because that's totally composable :)

[20:36] <lizmat> but it doesn't

[20:37] <TimToady> I've said many times that lexicals outside of threads should have extra constraints

[20:37] <timotimo> that's acceptable.

[20:37] <lizmat> outside of threads?

[20:37] <TimToady> and that's the main reason almost everything is lexical in the first place, to automatically get thread-local storage for any internal lexicals

[20:38] <lizmat> so, every container remembers in which thread they're made

[20:38] <lizmat> and if they're changed from another thread, they should bomb?

[20:39] <TimToady> various semantic approaches are possible, once we notice the problem

[20:39] <timotimo> how do we notice if the user protected the lexicals with some locking scheme that we can't immediately see?

[20:39] <TimToady> we can force them to declare it so

[20:40] <jnthn> The challenge is distinguishing the cases we do want to allow it, like in combine, because we know that is safe.

[20:40] <timotimo> my $foo is protected_by($lock)?

[20:41] <jnthn> otoh, that's syntactic now :)

[20:41] * TimToady is inclined to make outside lexicals simply not visible to the inside of a start

[20:41] <diakopter> TimToady: but what about all the other lvalues, like array and hash slots

[20:41] <TimToady> s/lexicals/variables/

[20:42] * TimToady still likes single-owner semantics too

[20:42] <TimToady> but I recognize it's fraught

[20:42] <diakopter> -_-

[20:42] <lizmat> hmmm....  so a thread/promise starts with a fresh lexical stack

[20:43] <diakopter> but closures are essential in many cases..

[20:43] <TimToady> well, or just skips to SETTING

[20:43] <lizmat> indeed

[20:43] <lizmat> skip to SETTING

[20:43] <TimToady> for variables

[20:43] <TimToady> it's just an idea

[20:43] <lizmat> I guess that would stop all of the accidental accesses

[20:43] <lizmat> I like the idea

[20:43] <diakopter> okay, but you can still pass a closure value to one of these blocks and it'll still have access to its lexical scope

[20:43] <lizmat> it forces people to think about cocurrency

[20:44] <lizmat> yes, you still can

[20:44] <TimToady> anyway, I'm certainly not against imposing some kind of discipline on outer shared state

[20:44] <dalek> rakudo/WINNER: 7213c53 | (Timo Paulssen)++ | src/Perl6/ (2 files):

[20:44] <dalek> rakudo/WINNER: the previous attempt was intent on TTIAR'ing :(

[20:44] <dalek> rakudo/WINNER: review: https://github.com/rakudo/rakudo/commit/7213c5350a

[20:44] <dalek> rakudo/nom: b774722 | moritz++ | docs/ChangeLog:

[20:44] <dalek> rakudo/nom: [doc] extend ChangeLog a bit

[20:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7747227d6

[20:45] <lizmat> I wonder whether also keeping the creation thread ID with each container

[20:45] <timotimo> yay, a thing i made got mentioned in the changelog \o/

[20:45] <lizmat> and checking that on update, wouldn't fix the closure issue

[20:45] <jnthn> Maybe it's more about scope ownership.

[20:45] <jnthn> "Who created the invocation record"

[20:45] <lizmat> but scopes can leak, so we need to have something to catch that

[20:46] * TimToady doubts there is a perfect solution (outside of making everything immutable)

[20:46] <TimToady> but we can certainly decrease the likelihood of erroneous code

[20:46] <moritz> and making everything immutable isn't a perfect solution either :-)

[20:47] <lizmat> indeed, that is my main concern: code that doesn't complain, works ok most of the time, until we get a load on the system

[20:47] <jnthn> lizmat: That's kinda what I was trying to address. If a lookup in the thread running something crosses into a invocation record created by another thread to do a lookup...

[20:48] <TimToady> we can at least complain bitterly if we notice such a thing happening

[20:48] <lizmat> but wouldn't you need to be able to do that at container level, because of closures ?

[20:49] <masak> invocation records feel like exactly the right level for closures.

[20:50] <jnthn> lizmat: Closures are what I'm (badly :)) trying to address too. When you take a closure, it has an outer frame pointer. If we access soemthing that was closed over, then the lookup is crossing from an invocation record created by the thread (when the closure was invoked) to the outer one created by the original thread.

[20:50] <TimToady> the important thing about these shared things is not that they're shared, but that they're not transactional

[20:51] <jnthn> In generaly, my worry about making things like the "$a++" example just work is that as soon as it does, people will then start to write The Next Idiom

[20:51] <jnthn> for 1..4 { start while @foo { @foo.pop } } # race condition!

[20:51] <lizmat> indeed

[20:52] <lizmat> and we need to fail that before it starts

[20:52] <diakopter> why!??!!?

[20:52] <jnthn> And the problem here is that it's not obvious where the transaction starts/ends.

[20:52] <diakopter> how is that a race condition?

[20:52] <diakopter> (why does the user always need to care about the order of popping)

[20:52] <lizmat> because you would be getting the same value from the array twice or not

[20:52] <jnthn> diakopter: It's not about order

[20:53] <diakopter> what?!?!

[20:53] <jnthn> No, it's not about that either. Let's suppose pop is atomic.

[20:53] <lizmat> (it's not currently, afaik)

[20:53] <jnthn> It's still a race because @pop boolifies @foo to tell you if there's anything more

[20:53] <lizmat> but let's assume  :-)

[20:53] <jnthn> Then next you try to pop

[20:53] <jnthn> But somebody else might have beat you to pop the last thing.

[20:53] <TimToady> iow, it doesn't compose

[20:53] <jnthn> That's why things like the .Net concurrent collections don't have a Pop method

[20:53] <jnthn> They have a TryPop

[20:53] <diakopter> that's simply solved by adding a try

[20:54] <diakopter> yeah, that

[20:54] <jnthn> I guess this is all a "forgiveness > permission" thing :)

[20:54] <jnthn> In cncurrent situations you can't ask if you can, then do it, 'cus the answer may change underneath you.

[20:54] <TimToady> well, and making it likelier that they'll pick the composable primitives over the non-composable

[20:54] <diakopter> so why can't the while's block have a try

[20:55] <TimToady> we're starting to talk about STM again, here, basically--keep trying to do "this" until we succeed

[20:55] <TimToady> STM just has a funny way of defining "this"

[20:56] <diakopter> it's not talking about STM

[20:56] <jnthn> diakopter: My point wasn't that you can't find *some* way to fix these, though "just add a try" works in this case provided you only catch the appropriate kind of exception.

[20:56] <jnthn> diakopter: My point was that there's not a *general* approach.

[20:57] <diakopter> why would you need a general approach

[20:57] <TimToady> generality is generally...er...more general

[20:57] <jnthn> Because solving these problems case by case is *far too hard* for the typical programmer.

[20:58] <jnthn> Which is why .Net folks are pushed away from threads/locks and towards Tasks/TPL/Rx etc, for example.

[20:59] <jnthn> Which all revolve around breaking problems into manageable pieces and making synchronization happen in well-defined places.

[20:59] <lizmat> and threads are currently wide open on Perl6

[20:59] <lizmat> indeed

[20:59] <jnthn> lizmat: They are in Java and C# too, fwiw.

[20:59] <lizmat> but Perl6 should be better 

[20:59] <TimToady> threads are sort of the Ur-DIHWIDT

[20:59] <jnthn> lizmat: Not arguing that we should follow that. Just saying that it's a situation in languages where people actually do use threads day to day.

[21:00] <lizmat> experienced people

[21:00] <jnthn> No, most of them aren't, and most of them screw it up.

[21:00] <lizmat> well, there you go

[21:01] <lizmat> I don't want them to screw up, I want them to be steered into a direction that will do what they want

[21:01] <lizmat> just maybe not in the way they originally thought

[21:01] <jnthn> Me too, which is why I've been pushing the whole promise/channel/supply thing.

[21:01] <lizmat> and compile/runtime errors should lead them that way

[21:01] <diakopter> adding checks for thread parity everywhere can't be the right solution

[21:01] <jnthn> It's just that I've been focused on the carrot (hey look, nice primitive)

[21:01] <jnthn> And now we're discussing the stick. :)

[21:03] <jnthn> diakopter: Can't be as in, we can't afford to slow everything down with those?

[21:03] <diakopter> yes, but it also feels wrong just because it's checks the user has to imagine

[21:03] <lizmat> so each scope gets a thread ID ?

[21:03] <jnthn> diakopter: If so, I agree, but iiuc what TimToady is saying, the point of having things lexical is that we can know a lot of places we don't need to do any of this.

[21:04] <TimToady> it's just tilting the playing field, not necessarily blowing up the other guy's goal

[21:04] <jnthn> lizmat: fwiw, that already implicitly happens on both Moar and JVM, in that the scope gets a ThreadContext attached :)

[21:05] *** kurahaupo joined
[21:05] <TimToady> if we can detect hazardous sharing 50% of the time and slap the user's wrist, they'll tend to migrate over to the safer constructs, even if it's not perfect

[21:05] <TimToady> since perfect usually implies 'unusably slow'

[21:05] <diakopter> jnthn: I don't know what was meant by "having things lexical"

[21:06] <TimToady> this is in contrast to P5 where way too many vars are package/global

[21:07] <TimToady> it's the main motivation for making $*FOO work via search rather than "local $foo" as it is in P5

[21:07] <jnthn> diakopter: I mean that a lot of variable accesses, you can look between where the variable is mentioned and where it's declared and determine statically that it's impossible that access could be on a different thread, even accounting for closure semantics.

[21:07] *** hummeleB1 left
[21:08] <diakopter> alright, that optimizes for the single-threaded case

[21:08] <lizmat> my $seen; await( (1..3).map: { start { $seen++ for ^1000 }}); say $seen   # could be caught at compile time

[21:08] <diakopter> but what about when the user wants to parallelize things with shared data strutures

[21:08] <TimToady> most single threads are single threaded :)

[21:09] <lizmat> they're very singular about that :-)

[21:09] <TimToady> we slap their wrists when we notice them using non-sharable data structures for that

[21:09] <diakopter> lizmat: what would be caught there

[21:09] <diakopter> what's the problem with that

[21:10] *** sqirrel joined
[21:10] <TimToady> what's the problem with what?

[21:10] <jnthn> diakopter: Then the onus is on them to (a) say they're doing so, and (b) be extremely careful, just like you have to be in every other languages where you mutate data structures from multiple threads.

[21:10] <diakopter> what's the problem with liz's example

[21:10] <jnthn> diakopter: That's a "hard thing possible" rather than an "easy thing easy".

[21:11] <diakopter> I don't understand why making all the changes atomic doesn't solve it

[21:11] <diakopter> er, thread-safe.

[21:13] <diakopter> b/c if it's just "when you're popping from multiple threads, you need to handle for when pop fails" how is that a problem

[21:13] <diakopter> a problem for the user to remember/handle, I mean

[21:13] <TimToady> "all the changes" is transaction scoping, and users tend to think in transactions that are not atomic unless we warn them off of it where we can

[21:14] <TimToady> pragmatically, we admit the possibility of DIHWIDT, but we also vaccinate people and treat them when their sick

[21:15] <TimToady> dealing with users is sometimes more like being a doctor than like being a starship engineer :)

[21:16] <TimToady> so we need to say "Well then, don't do that." a little more often than we like

[21:16] <diakopter> I don't see how you can ever possibly detect that

[21:16] <TimToady> you can detect some of it

[21:16] <diakopter> with any reliability

[21:17] <diakopter> does anyone know what's the problem with liz' example?

[21:17] <jnthn> On "what can be detected", it may serve us well to look at things like TSAN, Go's race detector, etc.

[21:17] <lizmat> some is already good

[21:17] <jnthn> It's not like we're the first people looking at this problem.

[21:17] <lizmat> in any case, I think we need to make sure that multi-thread access to hashes, need to be protected

[21:18] <diakopter> I feel like we're not looking at the problem; we're launching nuclear missles at it from 3 feet away

[21:18] <lizmat> we don't want that to be able to corrupt a hash

[21:18] <lizmat> hhe

[21:18] <diakopter> that was never at issue

[21:18] <lizmat> ok, I'll go stand a little further away

[21:18] <TimToady> "I see you've used a single-threaded implemented of Scalar for variable $seen there, and referred to it from inside a thread.  Howsabout you declare it 'my $seen is threadsafe' to get a Scalar with atomic increment at line 42"

[21:18] <lizmat> which was "is cas" was all about

[21:19] <TimToady> cas is the wrong name for that

[21:19] <lizmat> granted

[21:19] <lizmat> it defines the implementation

[21:19] <lizmat> "is safe" maybe better ?

[21:20] <TimToady> well, that's a bit too general :)

[21:21] <diakopter> I don't understand what happened to the auto-upgrading threadsafe containers we've talked about in moar for ages (and that can be similarly done on jvm)

[21:21] <TimToady> but I could see requiring a user to declare a lock-free hash implementation is to be used for a shared hash, or an array that doesn't support pop

[21:21] <jnthn> "is cafe" :P

[21:21] <TimToady> diakopter: if we can do that, great

[21:21] <diakopter> when was there ever a question we could do that

[21:21] <diakopter> I thought that was the plan

[21:22] <TimToady> but it doesn't solve the boolean vs pop issue necessarily, from a transactional point of view, if you still support pop

[21:22] <TimToady> the whole problem with transactions is that they are not reductionistic

[21:23] <TimToady> just because all the operations are atomic doesn't make the composed operation atomic

[21:23] <jnthn> diakopter: That aspect solves the VM safety level problems, for certain, but the issues is...what TimToady just put better than I was going to.

[21:23] <TimToady> so lock-free structures are a good start

[21:23] <jnthn> diakopter: If your problem involves anything more than that single data structure, you're still left with a problem.

[21:24] <diakopter> jnthn: I think I was trying to express earlier that since you can't solve the general case (or come anywhere close, from what I can see), it seems trying to warn in particular other cases will just be confusing

[21:24] <diakopter> because you can't warn on the passing closures as parameters

[21:24] <diakopter> or lexicals

[21:25] <diakopter> or container slot values

[21:25] <TimToady> all-or-nothing is not PerlThink

[21:25] <jnthn> Lock free data structures are really useful *if* your problem reduces to things that they can do atomically, which sometimes hapens. A Channel is basically a lock free queue.

[21:25] <diakopter> or-anywhere-close

[21:25] <TimToady> well, you can block on backpressure, and have a cyle of that, which is a kind of deadlock

[21:26] <jnthn> True

[21:26] *** beastd joined
[21:27] * timotimo considers commuting home again

[21:27] <timotimo> yup, i'll do that.

[21:27] <TimToady> sounds like a complicated transaction :)

[21:28] <diakopter> jnthn: "you're still left with a problem" - no one has explained the problem except "I don't want to have to teach people to handle a failed pop, or I don't want pop to ever fail"

[21:29] <jnthn> diakopter: At this point I fear if I showed you 10 more cases where the race isn't immediately obvious, then we found a way to fix it, you'd still be telling me the same thing. :/

[21:30] <jnthn> Even though the fixes would likely be different each time.

[21:30] <lizmat> Niederrhein about to wrap up, decommuting soon

[21:30] <diakopter> I don't think it's a valid worry; I haven't understood the way to fix the first one yet

[21:31] <diakopter> I'm confused by various peoples' descriptions of what they're imagining/proposing because they all seem conflicting

[21:32] <diakopter> it's like, let's all throw word soup on the wall and see what sticks

[21:32] <diakopter> also, Wall

[21:33] <TimToady> the basic problem is threefold: 1) nobody understands how to scale up transactions, and 2) an all-or-nothing approach is doomed to fail, and 3) nobody is happy with a partial solution, but that's what we're *guaranteed* to end up with, so how can we best push the user toward enlightement?

[21:34] <lizmat> well, I think it's better than everybody being silent and ignoring the concurrent elephant in the room

[21:34] <diakopter> no one has answered why "+=

[21:35] <diakopter> "+= is bogus"

[21:35] <TimToady> it's fine, but I wouldn't call it CAS, is all

[21:35] <diakopter> since jnthn seemed to reply that it should be on the operations, not variables

[21:35] <TimToady> he was talking specifically about CAS I believe

[21:36] <TimToady> not about how to make += safe

[21:36] <TimToady> s/safe/atomic/

[21:36] <jnthn> Yes, I was talking about CAS on the operations not variables thing.

[21:36] <TimToady> the S stands for Swap, darn it, not increment :)

[21:37] <diakopter> okay, I was asking about the primitive case again

[21:37] <TimToady> asking what?

[21:37] <diakopter> (afaict there can be an atomic += for primitives)

[21:39] <lizmat> for natives you mean?

[21:39] * TimToady was just questioning how you signal failure on that

[21:39] <diakopter> yes

[21:39] <lizmat> int instead of Int

[21:39] <diakopter> atomic add or incr can't possibly fail

[21:39] <diakopter> it always succeeds

[21:40] <diakopter> that's the benefit

[21:40] *** sqirrel left
[21:40] <TimToady> but that's not how CAS works, hence the confusion

[21:40] <jnthn> Depends what hardware you have, mind...if it doesn't support doing that, then it'll have to be implemented out of something like CAS that can fail.

[21:40] <jnthn> And then emulate the "not fail" by retrying.

[21:40] <TimToady> which goes back to what I said about conditional compilation

[21:40] <TimToady> different arches have different primitives

[21:41] <TimToady> alas

[21:41] <TimToady> at some point it becomes less meaningful to talk about "primitives" and just talk about atomicity and/or transaction safety

[21:42] *** kurahaupo is now known as kurahaupo2

[21:43] <TimToady> and there's a bumpy transition from atomic to transactional, if atomic always succeeds, but a transaction has to be rollbackable

[21:43] <TimToady> atomic doesn't imply commit/rollback semantics

[21:44] *** lizmat left
[21:44] *** lizmat joined
[21:45] <TimToady> but all the the approaches I've seen to composing transactions involve either the possibility of deadlock/livelock, or the ability to just keep hammering on it till you get a commit to go through, √† la STM

[21:45] <TimToady> but even STM doesn't scale to disk or database transactions

[21:47] *** stevan__ left
[21:47] *** eternaleye left
[21:48] <TimToady> and if you compose transactions inside transactions, you find yourself in the odd position of having to rollback inner transactions that have been "committed"

[21:48] *** [Sno] left
[21:49] *** eternaleye joined
[21:49] <lizmat> decommiute&

[21:49] *** lizmat left
[21:50] *** woolfy left
[21:50] <masak> clearly the inner transactions need to have only been "speculatively committed" until the outer transaction is truly committed.

[21:50] <TimToady> .oO(The all-or-nothing never works out well because, while we all understand 'nothing' pretty well, nobody understands 'all'...)

[21:50] <TimToady> *approach

[21:51] <TimToady> masak: which means there can never be final commitment without someone say "That's all, folks!"

[21:52] <TimToady> *saying

[21:52] <masak> well, there can be an outermost transaction.

[21:52] <diakopter> masak: I can only hope you're tongue-in-cheek there

[21:52] <TimToady> gah, can't type to keep up with my brane today, gotta start thinking slower...

[21:53] <TimToady> masak: the question is, who's to be master, that's all.

[21:53] <diakopter> the outerost transaction is the big bang

[21:53] <masak> diakopter: no, it would be wise to assume ignorance rather than irony in my case right now.

[21:53] *** spider-mario left
[21:53] <masak> I seldom include the "big bang" abstraction in my programs.

[21:53] <TimToady> diakopter: how do you know that's the outer one?

[21:54] <diakopter> in that time dimension anyway..

[21:54] <masak> and yet they commit to things.

[21:54] <masak> &

[21:56] <TimToady> Maybe our entire universe is answering a what-if question, and once we get a result of 42, we're good to go.  :)

[21:57] *** rurban1 left
[21:59] *** colomon left
[21:59] <TimToady> Maybe our universe is being evaluated lazily, and we'll never actually get to the Big Rip, or Bound, or Whimper, because nobody will ask for the result...

[21:59] <TimToady> *Bounce

[21:59] *** rjbs joined
[21:59] <rjbs> Whoops, I didn't rejoin after my screen-to-tmux conversion!

[21:59] <diakopter> rjbs: HOW CUTE ARE YOU

[22:00] <nwc10> rjbs: you took the plunge?

[22:00] <rjbs> nwc10: Yes, a bit over a week now.

[22:00] <nwc10> not that I have the font for it locally, but I think my irssi is now not being stupid so I can send üê´

[22:01] <rjbs> Yes, tmux let me do that again, too. üê´

[22:02] *** stevan_ joined
[22:03] <TimToady> shouldn't that be üê™

[22:07] *** dmol left
[22:09] *** dmol joined
[22:27] *** [Sno] joined
[22:30] <dalek> panda: 8375930 | (Tobias Leich)++ | / (2 files):

[22:30] <dalek> panda: use $*EXECUTABLE_NAME instead of hard-coded 'perl6'

[22:30] <dalek> panda: 

[22:30] <dalek> panda: Because we now have perl6-p and perl6-j binaries.

[22:30] <dalek> panda: review: https://github.com/tadzik/panda/commit/837593022d

[22:30] <dalek> panda: 41a73f3 | tadzik++ | / (2 files):

[22:30] <dalek> panda: Merge pull request #60 from FROGGS/master

[22:30] <dalek> panda: 

[22:30] <dalek> panda: use $*EXECUTABLE_NAME instead of hard-coded 'perl6'

[22:30] <tadzik> FROGGS: thanks!

[22:30] <dalek> panda: review: https://github.com/tadzik/panda/commit/41a73f3e2a

[22:31] <FROGGS> tadzik: pleasure :o)

[22:35] <lue> preflex list

[22:35] <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:

[22:35] <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]

[22:36] *** dmol left
[22:38] *** dmol joined
[22:39] *** PacoAir left
[22:45] *** stevan_ left
[22:54] *** dmol left
[22:59] *** BenGoldberg joined
[23:01] *** colomon joined
[23:02] *** arnsholt_ joined
[23:03] *** arnsholt left
[23:08] *** stevan_ joined
[23:13] *** beastd left
[23:22] *** btyler left
[23:23] *** jnap left
[23:23] *** bluescreen10 left
[23:24] <japhb_> Is there a Perl 6-standard (as opposed to Rakudo-specific) way to refer to the argument capture of a routine that does not specifically specify a capture in the signature?  My immediate use case is being able to refer to the arguments of MAIN as a unit, instead of a bunch of named args (which the auto-USAGE code wants to see)

[23:36] *** lizmat joined
[23:39] <jnthn> japhb_: Is there a reason not to specify a capture in the siggy?

[23:39] <jnthn> Noting that you can do it *and* then write a normal signature too...

[23:40] <jnthn> I'm not aware of a way besides that, though...

[23:40] <jnthn> And I'd somewhat rather we keep it in the signature

[23:41] <jnthn> As it's easy to detect if we have to build it.

[23:41] <jnthn> And a raft of the opts I've got coming up to better use invokedynamic probably rely on knowing this...

[23:41] <japhb_> Ah, interesting, that's a really good data point.

[23:42] *** woolfy joined
[23:42] <japhb_> In that case, I guess the best option is to teach the USAGE generator to ignore the capture.

[23:46] *** ajr_ left
[23:55] *** PZt left
