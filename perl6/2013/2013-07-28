[00:11] *** benabik left
[00:18] *** pmurias left
[00:29] *** census joined
[00:32] *** benabik joined
[00:50] *** pupoque__ left
[00:50] *** pupoque_ left
[01:12] *** btyler left
[01:12] *** fgomez joined
[01:13] *** btyler joined
[01:15] *** fgomez left
[01:15] *** fgomez joined
[02:01] *** orafu left
[02:02] *** orafu joined
[02:09] *** census left
[02:41] *** kshannon left
[02:44] *** kshannon joined
[02:49] *** kshannon left
[02:49] *** kshannon joined
[02:54] *** kshannon left
[02:56] *** kshannon joined
[03:01] *** orafu left
[03:02] *** OuLouFu joined
[03:02] *** OuLouFu is now known as orafu

[03:20] *** colomon left
[03:21] <diakopter> .. I don't understand why there aren't 3d printers using liquid metal

[03:21] <diakopter> (or are there?)

[03:21] <geekosaur> clogs are *really hard* to clear

[03:22] <geekosaur> (ask anyone who's worked with old wax printers)

[03:22] <diakopter> or even large robots that auto-forge metal strips then bend into place

[03:27] <JimmyZ> gOOd nOOn :)

[03:29] *** preflex_ joined
[03:29] *** ChanServ sets mode: +v preflex_

[03:30] *** preflex left
[03:30] *** preflex_ is now known as preflex

[03:32] <benabik> diakopter: Metal tends to be done via laser sintering.

[03:34] <BenGoldberg> I don't understand why 3d printing with metal clay isn't more common...

[03:34] *** silug left
[03:35] *** adu joined
[03:35] *** adu left
[03:36] <BenGoldberg> After all, a clay printer requires much less energy (and is much less dangerous) than a laser sinterer

[03:36] *** adu joined
[03:36] <benabik> Then you end up with a metallic ceramic instead of pure metal?

[03:36] <adu> hey

[03:36] <adu> how is everyone?

[03:37] <benabik> Also laser sintering has very high precision.  Much easier to precisely point a laser than precisely move a print head.

[03:38] <BenGoldberg> Actually, when you bake it in a kiln, it somehow becomes solid metal, not a ceramic.

[03:38] <BenGoldberg> You've got a good point on the precision.

[03:38] <benabik> Generally if you want metal you want high precision metal.  :-)

[03:39] <benabik> I have yet to see a ABS system that gives actual smooth edges.  (Although I've only seen kit ones instead of a pro.)

[03:43] <BenGoldberg> I wanna see someone invent a 3d production system which can quickly alternate between additive and subtractive processes... first print part of a model, then automatically remove the excess, with a router or grinding point (or whatever), then print more of the model, and so on and so forth.

[03:43] *** adu left
[03:43] *** adu joined
[03:43] *** adu left
[03:44] <benabik> I think most models can be done as add then subtract.

[03:44] *** adu joined
[03:44] *** adu left
[03:44] *** adu joined
[03:44] <benabik> Really why add something you're only going to remove?  Only reason I can think of is to support something in deposition systems.

[03:45] <diakopter> geekosaur: but why wouldn't the whole length be heated

[03:46] <geekosaur> you don't keep it heated when it's not in use (it uses a lot of power). if the head isn't completely emptied before the power is shut off, you have a problem.

[03:47] <diakopter> well I'm saying why not have the whole length able to be heated enough to melt the contents

[03:47] <geekosaur> like I said, this is stuff that's been seen with wax printers; as long as everything works perfectly you're fine, but unexpected loss of power or other failures lead to rather expensive repairs

[03:47] <BenGoldberg> If your subtractive system has higher resolution than your additive system, then you print a coarser version than you really want (because your equipment isn't capable of doing it right the first time) then grind away the excess.

[03:48] <diakopter> benabik: then have a robot arm with a sander... :D

[03:48] <BenGoldberg> For example, try printing an engine block, with smooth polished cylinders ;)

[03:48] <geekosaur> and heating the whole thing to a sufficient level takes even more power, plus complicates e.g. supporting all that hot stuff

[03:49] * adu <3 Perl6

[03:49] <adu> I totally evangilized Perl6 to a Google employee yesterday

[03:49] <diakopter> hrm

[03:49] <BenGoldberg> :)

[03:49] <geekosaur> and since one of the main thrusts of 3d printing is reduced cost, and you aren't reducing costs much if you need to do that kind of thing...

[03:50] <BenGoldberg> adu, isn't Google's favorite fancy new language "Go" ?

[03:50] <adu> BenGoldberg: no, it's totally Python

[03:50] <diakopter> heh

[03:50] <adu> they use Go and Dart for marketing purposes

[03:51] <adu> but internally, it's all Python

[03:51] <diakopter> all the Google folks I know use C++

[03:51] <diakopter> and Java

[03:51] <BenGoldberg> Isn't go a really annoying name, since it's a p.i.t.a. to search for?

[03:51] <adu> I can see that

[03:51] <adu> BenGoldberg: everyone I know uses "golang" as a search term

[03:51] <diakopter> they coined "golang"

[03:54] <BenGoldberg> Hmm... how hard would it be to add .pyc as another target for rakudo? :)

[03:55] <diakopter> a lot harder than Rust VM or Dar VM

[03:55] <diakopter> Dart

[03:55] <diakopter> (which I'm considering doing next..)

[03:55] <adu> Rust doesn't use a VM, it compiles to native

[03:55] <diakopter> (after golang)

[03:56] <diakopter> adu: right; this would incorporate that compiler in the runtime

[03:56] <diakopter> (or not)

[03:56] <diakopter> (doesn't need it)

[03:56] <adu> well, Rust does use LLVM, which has a runtime component, but is mostly native

[03:56] <diakopter> well MoarVM is written in C, but it doesn't need a C compiler at runtime...

[03:57] <diakopter> yes, Rust has a VM runtime

[03:57] <diakopter> ish

[03:57] *** silug joined
[03:57] <adu> also, Go and Dart are Google-sponsored, Rust is Mozilla-sponsored

[03:57] <diakopter> that much I knew :P

[03:58] <adu> Perl6 is Larry Wall-sponsored

[03:59] <diakopter> anyway, my point was it would be easier to create the VM/runtime from scratch (like MoarVM) in Rust than to port to pythonc

[03:59] <BenGoldberg> Oh ok.

[03:59] <diakopter> at least with Dart you have the native types

[04:00] <diakopter> so you could still use its GC

[04:00] <diakopter> well, if it's still able to optimize them well enough to natives.

[04:00] <adu> I can help with Rust, I've been learning it and blogging about it

[04:01] <adu> http://straymindcough.blogspot.com/2013/06/rust-echo.html

[04:01] <BenGoldberg> You wanna port perl6 to Rust?

[04:02] <diakopter> well, after golang

[04:02] <JimmyZ> zero.rs - a stub that lets Rust programs run almost freestanding. https://github.com/pcwalton/zero.rs

[04:02] <adu> BenGoldberg: it would make more sense to port it to LLVM than Rust

[04:02] <diakopter> I don't know about that

[04:03] <adu> if we can get an NQP => LLVM compiler, we're mostly done right?

[04:03] <diakopter> no

[04:03] <diakopter> rakudo uses nqp:: opcodes that nqp doesn't use

[04:03] <adu> hrm

[04:04] <diakopter> nqp:: is kindof a misnomer

[04:04] <diakopter> in some cases

[04:04] <JimmyZ> vm:: ?

[04:05] <diakopter> dunno

[04:05] <adu> btw, I'm on #rust @irc.mozilla.org right now, I can discuss this with them

[04:05] <BenGoldberg> p6vm:: ?

[04:05] <diakopter> adu: discuss what?

[04:06] <adu> someone needs to decide which core instructions are requires and give them some name, whether it's nqp or parrot or whatever

[04:06] <diakopter> that's usually premature imho, considering it's years away; I forgot to mention I wanted to do mono/.net first

[04:06] <diakopter> [assuming no one else helps, I mean]

[04:06] <adu> what? isn't that what niecza is?

[04:06] <diakopter> also haskell :P

[04:07] <diakopter> no, niecza is not a rakudo backend

[04:07] <adu> oh

[04:07] <BenGoldberg> niecza is an implementation of perl6, but was written independently of rakudo

[04:07] <adu> you're saying that rakudo could target Haskell instead of Haskell's VM and Rust instead of LLVM?

[04:07] * adu is confused

[04:07] <geekosaur> I thought adu was respomnding to "I forgot to mention I wanted to do mono/.net first"

[04:08] <adu> geekosaur:  i was

[04:08] <diakopter> (I thought that too..)

[04:08] <geekosaur> otoh it is also true that niecza is not based on rakudo

[04:08] <geekosaur> (that is, it's not just rakudo-on-.net)

[04:08] <geekosaur> also haskell does not have a vm

[04:08] <diakopter> sigh.

[04:09] <adu> iirc Haskell's vm is called STM

[04:09] <geekosaur> no?

[04:09] <JimmyZ> stm?

[04:09] <geekosaur> you may be thinking of stg

[04:09] <BenGoldberg> Pugs (Yet Another implementation of perl6) is written in Haskell (I think)

[04:09] <JimmyZ> stm is another thing

[04:09] <geekosaur> but nobody actually targets stg as such

[04:09] <adu> STG, right

[04:09] <geekosaur> it's conceptually a vm, but not practically

[04:10] <diakopter> adu: no, I was saying target the Haskell VM

[04:10] <diakopter> and LLVM isn't a VM for the billionth time

[04:10] <adu> diakopter: oh ok

[04:10] <diakopter> I was saying "write a rakudo/nqp backend/VM in Rust"

[04:10] <adu> diakopter: it has an instruction set, and at least 2 instructions that handle GC, so why wouldn't it be a VM?

[04:11] <diakopter> they don't *do* GC

[04:11] <JimmyZ> these should be happened after jited moarvm ;)

[04:11] <diakopter> (the instructions)

[04:11] <adu> diakopter: also that's the first time you've said that to me, so it's the first time, not billionth time

[04:12] <adu> diakopter: right, but LLVM has mark and sweep instructions, so that helps with writing VMs

[04:12] <adu> i mean GCs

[04:12] <JimmyZ> Yeah, talking is cheap

[04:12] <diakopter> it doesn't "help with writing GCs"

[04:13] <JimmyZ> said linus

[04:13] <diakopter> it helps with teaching the llvm compiler that you are calling into your GC

[04:13] <benabik> LLVM is less "VM" and more "abstract assembly"

[04:13] <JimmyZ> like dynasm?

[04:14] <diakopter> http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20100524/101702.html

[04:15] <benabik> JimmyZ: It looks like dynasm is tied to x86 assembly specifically.  LLVM abstracts away actual registers and details of instruction types, etc etc.

[04:16] * benabik was less than impressed with VMKit.

[04:17] <diakopter> benabik: dynasm can write arm, mips, ppc, x86, x86-64

[04:17] *** raiph left
[04:17] <JimmyZ> benabik: you meant luajit 1.x, luajit 2.x is not 

[04:17] <benabik> diakopter: Okay, but you have to write arm, mips, etc assembly instead of one kind of assembly that works everywhere.

[04:17] <diakopter> eh?

[04:18] <benabik> diakopter: Or at least that's how their examples are.

[04:18] * benabik doubts `mov wax, foo+17` would work on ARM.

[04:18] <benabik> *eax

[04:19] <diakopter> benabik: what page are you looking at

[04:19] <benabik> diakopter: luajit.org/dynasm_examples.html

[04:19] <diakopter> I'm looking at http://luajit.org/dynasm_examples.html

[04:21] <JimmyZ> benabik: you don't have to do that much if you see arm, mips code in luajit soucre dir

[04:21] <JimmyZ> *source

[04:21] <benabik> diakopter: All those examples reference x86 specific things like eax, ecx.  So unless they map registers on other platforms to the funny Intel names.

[04:21] <JimmyZ> benabik: the dynasm alread does it much 

[04:22] <diakopter> the point of dynasm is that you are writing assembly templates

[04:23] <diakopter> that get preprocessed into calls that emit that code with the templates filled in

[04:23] <benabik> But you write one template per arch.  Whereas LLVM abstracts away the architectures.  One IR, many architectures.

[04:23] *** aindilis joined
[04:23] <diakopter> right

[04:24] <JimmyZ> LLVM is too big

[04:24] <benabik> "Tied to x86" was more "directly exposes the architecture" instead of "abstracts the architecture.

[04:24] <JimmyZ> if we can't moarvm to be another JVM

[04:24] <JimmyZ> s/can't/want/

[04:25] <JimmyZ> i.e: slow startup

[04:25] <benabik> LLVM has the nice advantage of coming with large piles of complex optimizations.  It's a production compiler toolkit, so it isn't going to be small.

[04:25] <JimmyZ> so we just need JVM

[04:25] <benabik> OTOH, their actual JIT support is... somewhat lacking.

[04:27] *** adu left
[04:34] *** aindilis left
[04:34] <diakopter> what?

[04:35] <diakopter> this conversation has been very difficult to keep sane

[04:35] <diakopter> er, non-delusional

[04:35] <diakopter> er, non-confused

[04:35] <diakopter> (my confusion)_

[04:35] <JimmyZ> :P

[04:37] <diakopter> this is just silly. the JVM doesn't have slow startup. it starts up in 60ms on my machine.

[04:37] <JimmyZ> http://luajit.org/dynasm_examples.html it too old, I can't find it luajit 2.x

[04:37] <diakopter> it had slow startup a decade ago

[04:37] <JimmyZ> maybe  the code is from luajit 1.x

[04:37] <diakopter> what do you mean you can't find it?

[04:38] <diakopter> that URL doesnt work for you?

[04:38] <JimmyZ> the code in #Advanced Features 

[04:38] <diakopter> there's no getLCL ?

[04:39] <JimmyZ> no in luajit 2.x

[04:40] <diakopter> why do you say the JVM has slow startup

[04:40] <JimmyZ> so that's why is a x86  example

[04:41] <diakopter> JimmyZ: why do you say the JVM has slow startup?

[04:41] <JimmyZ> it's slow than perl in my machine :P

[04:41] <diakopter> okay. I've seen time say perl took 0ms to -e ''

[04:41] <diakopter> er

[04:41] <diakopter> -e ';'

[04:42] * JimmyZ lunches

[04:42] <diakopter> I don't see your point. what's wrong with 60ms startup

[04:42] <diakopter> (okay, limit of 15 invocations/second)

[04:45] <diakopter> anyway, I don't understand what everyone's talking about w.r.t. LLVM. who cares that the rust compiler uses LLVM? how could that possibly affect a Perl 6 backend written in Rust?

[04:45] <diakopter> same for clang... who cares that clang uses LLVM - how could that affect moarvm, which is written in C

[04:46] <diakopter> LLVM is certainly not part of the Rust runtime... surely not...?

[04:46] <diakopter> benabik: 100% agree about VMKit

[04:47] <diakopter> vehicle for thesis.

[04:47] <benabik> diakopter: My advisor thought it was a rather poor thesis at that.  Mostly connecting existing bits together instead of doing something novel.

[04:53] *** raiph joined
[04:54] * TimToady is home to own bed o/

[05:00] *** crab2313 joined
[05:16] <TimToady> if it'd been spelled WOT instead of WAT, it could've been backronymed to "Who Ordered That?"

[05:17] <TimToady> WAT: Walk Away Time :)

[05:22] *** fridim_ joined
[05:24] *** crab2313 left
[05:49] <TimToady> Whimper At Terminal

[05:54] <TimToady> WAT AKA TLA

[05:56] <araujo> TimToady, o/

[05:57] <TimToady> Wherefore Art Thou?

[05:59] <TimToady> I think that's my favorite backronym for WAT so far...

[06:00] * araujo wonders if WAT will be some new perl6 constant name

[06:00] <TimToady> we could rename Nil to WAT

[06:00] <araujo> :D

[06:02] *** crab2313 joined
[06:03] <flussence> r: class WAT is Whatever; say WAT.perl # use lolcode;

[06:03] <camelia> rakudo 296da0: OUTPUT«WAT␤»

[06:04] * araujo checks and he still has some candy left

[06:04] <JimmyZ> r: constant WAT is default(Nil); say WAT

[06:04] <camelia> rakudo 296da0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing initializer on constant declaration␤at /tmp/Xcjq1kizBO:1␤------> [32mconstant WAT is default(Nil)[33m⏏[31m; say WAT[0m␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statemen…

[06:10] <masak> mornin', #perl6

[06:11] <araujo> masak, o/

[06:13] <araujo> diakopter, what is the plan?... to write a perl6 impl in rust?

[06:13] <araujo> :P

[06:14] *** kaare_ joined
[06:14] *** fridim_ left
[06:17] <TimToady> nr: constant WAT = Nil; say WAT

[06:17] <camelia> rakudo 296da0, niecza v24-88-g1f87209: OUTPUT«Nil␤»

[06:18] <masak> nr: constant WAT = Nil but role { method gist { "WAT" } }; say WAT

[06:18] <camelia> niecza v24-88-g1f87209: OUTPUT«Unhandled exception: No value for parameter '$obj' in 'infix:<but>'␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/3nFgToWtDY line 1 (WAT init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 75 (…

[06:18] <camelia> ..rakudo 296da0: OUTPUT«WAT␤»

[06:18] <masak> rakudo++

[06:23] *** crab2313 left
[06:26] <masak> I was inspired by http://straymindcough.blogspot.se/2013/06/rust-echo.html , so I ported echo to Perl 6:

[06:26] <masak> https://gist.github.com/masak/6097636

[06:27] <masak> I might be missing something, but my Perl 6 implementation makes the Rust implementation seem overly wordy ;)

[06:27] <masak> "Perl 6: ruthlessly practical"

[06:31] *** kingbeast joined
[06:34] <JimmyZ> :P

[06:37] *** kingbeast left
[06:38] <masak> haha -- CoffeeScript doesn't add syntactic sugar, it "removes syntactic vinegar"! :) http://raganwald.com/2013/07/27/Ive-always-been-mad.html

[06:50] <masak> that article seem to tl;dr down to "implicit globals suck, but implicit locals suck almost as much -- design your PL with variable declarations already".

[06:53] * JimmyZ wonders how macro goes about :P

[06:53] *** kingbeast joined
[06:56] *** SamuraiJack__ joined
[06:58] *** BenGoldberg left
[07:09] *** FROGGS joined
[07:15] <diakopter> araujo: no :P just kidding around, a bit teasing rGeoffrey for what he said at the SotO at Oscon - that we're busy trying to target every VM under the sun. ;)

[07:21] *** vaelxon joined
[07:25] *** FROGGS left
[07:30] *** rindolf joined
[07:40] *** Su-Shee joined
[07:40] <Su-Shee> good morning everyone.

[07:43] *** btyler left
[07:44] <masak> Su-Shee! \o/

[07:45] <Su-Shee> nice grant proposal of diakopter :)

[07:45] <masak> yeah!

[07:47] <diakopter> trying to temper my 2nd reply to the troll

[07:47] <diakopter> (raiph is, that is) ;)

[07:48] <diakopter> Su-Shee: thanks :)

[07:48] <Su-Shee> "are we there yet?" ;)

[07:48] <diakopter> seventy Christmases ago!

[07:49] <Su-Shee> I meant your proposal ;)

[07:54] *** kingbeast left
[07:57] <masak> I haven't written my support yet in a comment, but I will. my biggest blocker is that I need to phrase sufficiently well how much I like MoarVM and how important diakopter++'s work would be for it.

[07:58] <masak> today's autopun: "98% of the time I am right. Why worry about the other 3%."

[07:59] <JimmyZ> masak: I wonders what's plan about perl 6 macro :P

[08:01] <masak> JimmyZ: a fair question. I hope to get back to that work, hopefully shortly after YAPC::EU.

[08:02] <masak> JimmyZ: current status: just about to start in on the third milestone -- i.e. just after the half-point. need to trawl through lots of macro tickets in RT and see what I can do about them. need to sit down and do some design, too.

[08:03] <JimmyZ> masak: nice, I'm asking because I'm using Clojure macro and thinking it's really useful

[08:03] *** spider-mario joined
[08:03] <JimmyZ> masak: and I think back Perl6 macro

[08:03] <JimmyZ> :P

[08:11] <masak> JimmyZ: 我明白。

[08:12] <masak> JimmyZ: the latest thought that I had is that in the long run, I really want Perl 6 macros to be able to do a CPS transform on my code.

[08:12] <masak> if it can do that, then I'll consider the macros implementation a success.

[08:12] *** xinming left
[08:12] <masak> (but that is a more stringent criterion than those in the grant application.)

[08:13] <JimmyZ> masak: 是的

[08:14] <masak> why? because under the "generate, analyze and typecheck" definition of http://scalamacros.org/ , we have only really touched upon "generate" so far.

[08:14] <masak> but a macro *reading* code (needed for the "analyze and typecheck" parts) is a lot more interesting than a macro just *writing* code.

[08:15] <masak> the problem with reading code is that we immediately hit upon the question "so, what's the (implementation-independent) API for getting information out of an AST?"

[08:16] <masak> this is the question Lisp doesn't have to face, because homoiconicity. the source code is (isomorphic to) the AST.

[08:16] *** xinming joined
[08:27] <JimmyZ> masak: 很不错的想法

[08:30] <masak> we shall see.

[08:30] <masak> the measure of a 不错的想法 has to be if it can be realized or not ;)

[08:31] <JimmyZ> O(∩_∩)O哈哈~

[08:32] <JimmyZ> (*^__^*) 嘻嘻……

[08:33] <masak> anyway, I'm still dedicated to the macros grant. it's taking more time than I thought, but I don't see any direct blockers, unless you count "$dayjob is a linear combination of extremely rewarding and draining of residual hobby energy" as a blocker.

[08:36] *** wk joined
[08:36] *** wk is now known as Guest79805

[08:45] <raiph> r: sub infix:«==>» (\out, @in) { say 1 }; my (@a, @b); @a ==> @b

[08:45] <camelia> rakudo 296da0:  ( no output )

[08:47] <masak> raiph: good morning.

[08:47] <masak> raiph: I think any infix ==> operator will be shadowed by the statement separator ==>

[08:47] <raiph> hi, that was ww

[08:47] <masak> (and should)

[08:48] <raiph> i noticed that ==> was in the grammar as infix:

[08:49] * masak checks

[08:50] <masak> yes. you're right.

[08:50] <masak> and it seems that I'm misinformed there. I thought it was a terminator.

[08:51] <raiph> well i thought that too. it's what the spec suggests.

[08:51] <moritz> it used to be one

[08:51] <masak> instead, it seems to sort under its own precedence level, "sequencer", just tighter than "terminator".

[08:52] <raiph> r: sub infix:«~~» (\l, \r) { say 1 }; my (@a, @b); @a ~~ @b

[08:52] <camelia> rakudo 296da0:  ( no output )

[08:53] <masak> yup. "sequencer" was split off from "terminator" in S03 in commit 1506579c on 2009-01-16.

[08:54] <raiph> looks like there's four groups of "specials" that aren't overridable using the sub infix: thing

[08:54] <masak> apparently as part of TimToady++'s collusions with mtnviewmark++ (the periodic table guy).

[08:54] <raiph> feeds, assigns, smartmatches, flipflops

[08:55] <masak> all of which are sufficiently, hm -- I don't want to use the word "magical" here -- "invasive".

[08:56] <moritz> macro-ish

[08:56] <masak> in the sense that they cannot be reduced to just "the sum of their AST children", but contain something more.

[08:56] * masak bonks moritz with the "useless use of the word 'macro'" bat

[08:57] <masak> (don't worry, the bat is made of foam.)

[08:57] <moritz> masak: well, what term would you use to describe "the compiler has to do more than emit code for a simple infix here"?

[08:58] <masak> "invasive".

[08:58] *** Guest79805 left
[08:59] *** pmurias joined
[08:59] <masak> moritz: my first conclusion after surveying all the available content on macros before the grant was this: people like wishful thinking, and when pressed to provide examples, they will dream something up that looks like it will fly but will instead crash in the nearest ditch.

[08:59] <masak> including, surprisingly, TheDamian.

[08:59] <masak> since then I've been very wary of saying "macros can/will do this" of *anything* we don't already have an implementation for.

[09:00] <pmurias> diakopter: re Perl6 backend written in Rust, you want to compile code to Rust or write the interpreter in Rust?

[09:00] <masak> further strengthened by musings together with pmichaud when I was trying to actually "macro-ize" infix:<&&>.

[09:01] <masak> moritz: basically, I'm saying "here be dragons". macros are awesome, but they won't do all people say they will. specifically, I don't think the four groups of invasive ops raiph++ mentioned are necessarily macro-ish.

[09:02] <masak> in some other cases, "macro-ish" is used to simply mean "thunk-y".

[09:03] <raiph> .oO ( I get karma for talking about invasive ops? we will fight them on the beaches, we will ... )

[09:03] <masak> it's more clear to me that macros will be able to give you thunky behavior (and in some sense, that's what the LOG example does) -- but I think it's a waste of the term "macro-ish" to describe something as narrow as "thunk", especially since we have the more precise term "thunk" already.

[09:05] <masak> it's as if you observe the design of a light switch for the first time, and exclaim "it's quantum-mechanical!". well, yes, it is, but you can also use the much simpler laws of electromagnetism from the 19th century to describe the light switch.

[09:05] <masak> not doing so commits some kind of scientific error of, um, egress.

[09:06] <masak> "using a bigger tool to solve the problem than required."

[09:08] <moritz> which is a bit (but not quite) like Occam's razor

[09:08] <masak> aye.

[09:10] <masak> whether a proof, a subroutine, or a choice of words, you always want to provide the smallest amount of material to get the job done.

[09:10] <masak> that's where Strunk and White's "omit needless words" comes from.

[09:11] <masak> and mathematicians' frowing upon using a proof by contradiction where no contradiction needed to be shown.

[09:11] *** pupoque joined
[09:13] *** fgomez left
[09:23] <pmurias> masak: one thing that might be worth thinging about is how much of the proposed macro usage could be replace by a 'is thunky' parameter trait

[09:23] <masak> aye.

[09:23] *** dmol joined
[09:24] <pmurias> sub infix:<||>($a,$b is thunky) { if $a { $a } else { $b() } }

[09:25] *** crab2313 joined
[09:27] <masak> aye.

[09:28] <masak> r: sub trait_mod:<is>(Parameter $param, :$thunky!) { say "OH HAI" }; sub foo($x is thunky) {}

[09:28] <camelia> rakudo 296da0: OUTPUT«OH HAI␤»

[09:28] * masak thinks about what the next step is

[09:32] *** ppq_ joined
[09:33] *** ppq_ is now known as pupoque_

[09:33] <lizmat> goood *, #perl6!

[09:33] <lizmat> .oO( a lot to backlog )

[09:34] <masak> sorry... :P

[09:36] <masak> something feels wrong there -- we put the trait on the *parameter*, but what we really want to affect is the *evaluation* of the arguments on the caller side.

[09:38] <arnsholt> That won't work, will it? The second argument is going to be evaluated on invocation of the sub, no matter what you do

[09:38] <masak> I notice that I am confused.

[09:41] <dalek> specs: 2acbd58 | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[09:41] <dalek> specs: Elaborate on Hash.classify and Hash.categorize, suggested by masak++

[09:41] <dalek> specs: review: https://github.com/perl6/specs/commit/2acbd58518

[09:42] <masak> where, in practice, is an argument evaluated?

[09:42] <masak> we'd need to reach into that code path in the runtime and say "hold it! don't evaluate these arguments, just keep them at the AST level"

[09:43] <masak> hm, not runtime. that's probably not feasible (although I can't put my finger on why.)

[09:43] <lizmat> wrt to "will start", discussed this yesterday with TimToady, it was not in the spec anymore: instead "once" should be used

[09:43] <lizmat> also: "will start" afaik was a nolop before these changes

[09:43] <lizmat> noop

[09:44] *** crab2313 left
[09:44] <masak> probably need to reach into the caller at *compile time*, and re-write the way argument evaluation is done.

[09:44] <masak> which immediately raises two issues:

[09:44] <masak> (a) since subroutines can be post-declared, sometimes this needs to be done to calls that have already been parsed.

[09:45] <moritz> no

[09:45] <moritz> we simply declare that thunking routines must be pre-declared

[09:45] <masak> (b) if you're doing any kind of dynamic subroutine lookup, you're out of luck. the dynamic lookup happens at runtime, but the argument evaluation inhibition needs to be prepared at compile time.

[09:45] <moritz> correct

[09:45] <masak> moritz: I'll give you (a), though I do think we have an option there.

[09:46] <masak> moritz: we do other kinds of similar post-fixups.

[09:46] <masak> but your suggestion is the conservative option, so I'm fine with it.

[09:46] <masak> we can always do better later.

[09:48] *** pupoque_ left
[09:49] <raiph> masak++ # p6 echo to adu's rust

[09:49] *** pupoque left
[09:49] <hanekomu> (p6 newbie here) I'm just watching Patrick's talk on Lists from YAPC::NA 2012 and tried a line from that talk:    my @a = 1, 1, *+* ... *;     with the latest rakudo, built from source, and it hangs. How has the syntax changed?

[09:50] <moritz> r: my @a = 1, 1, *+* ... *; say "alive"

[09:50] <camelia> rakudo 296da0: OUTPUT«alive␤»

[09:50] <moritz> hanekomu: works here

[09:50] <masak> r: my @a = 1, 1, *+* ... *;

[09:50] <camelia> rakudo 296da0:  ( no output )

[09:51] <moritz> hanekomu: you just have to be careful not to it in the interactive environment, because it'll try to print the return value (ie the array)

[09:51] <hanekomu> ah

[09:51] <moritz> and printing an infinite array takes a long, long time

[09:51] <hanekomu> yes, that's from the prompt

[09:51] <moritz> you can do   my @a = 1, 1, *+* ... *; 1;   on one line of the prompt

[09:51] <hanekomu> It's just that Patrick's example also showed the prompt

[09:51] <hanekomu> moritz: ah

[09:52] <hanekomu> works, thanks

[10:01] *** raiph left
[10:02] <pmurias> masak: re implementing is thunky, the way I could imagine it being implemented is that it turns the'sub with 'is thunky' arguments into a macro

[10:03] *** pupoque_ joined
[10:04] <pmurias> masak: we could achive it by hooking into the sub keyword

[10:04] *** pupoque__ joined
[10:04] <masak> pmurias: certainly a possibility, but feels heavy-handed and a bit circular.

[10:04] <masak> wasn't the objective to replace some macro use cases with 'is thunky'?

[10:05] *** pjcj left
[10:06] <pmurias> yes, but 'is thunky' just introduces a macro only in a more limited manner

[10:08] <diakopter> masak: why, just the other day I proved that proofs by contradiction weren't valid... by contradiction.

[10:09] *** pmurias left
[10:09] <masak> diakopter: I tend to think of such reasoning as "setting your boat on fire" or "pulling the carpet out from under yourself". :)

[10:10] <masak> s/on fire/on fire while using it to cross a river/

[10:10] <diakopter> oh, I thought it was giving a virus to the first turtle below you

[10:10] *** pupoque_ left
[10:10] <masak> diakopter: have you seen http://qntm.org/responsibility ?

[10:11] <diakopter> probably in some universe

[10:11] <masak> :P

[10:12] <diakopter> (yes, you need to qualify every utterance with "in this universe")

[10:12] <lizmat> would that imply that a thunky sub doesn't have a scope of its own?

[10:13] <diakopter> "appallingly intelligent mathematical statisticians"

[10:14] <diakopter> masak: I hope I didn't feed the troll too much

[10:15] * masak looks

[10:15] <masak> lizmat: no, I don't think so. what makes you think so?

[10:16] <masak> lizmat: it's more like, the thunk makes sure to evaluate in its original environment.

[10:16] <lizmat> because of thunks like in ?? !!

[10:18] <masak> diakopter++ # factual, corteous, non-aggressive

[10:18] <masak> lizmat: or && or || or ^^ for that matter.

[10:18] <masak> lizmat: or ff and friends.

[10:18] <diakopter> raiph++ rescuing it

[10:19] <masak> lizmat: see my answer above about 'evaluate in its original environment'.

[10:19] <masak> lizmat: this, I believe, is necessary for a thunk.

[10:19] * lizmat is just trying to picture a thunky sub

[10:20] <masak> lizmat: consider, for example '$x && $y' in a world where infix:<&&> were successfully implemented in the setting.

[10:20] <masak> lizmat: $y binds to a thunky parameter, so its evaluation is inhibited.

[10:20] <masak> it will only ever actually be evaluated if $x is truthy -- right?

[10:21] <lizmat> yes

[10:21] <masak> now, at that point we're *in the setting*, in the infix:<&&> sub.

[10:21] <masak> different environment. $y is far away in the user's program.

[10:21] <masak> in a "lower scope", if you will. not visible in infix:<&&>

[10:21] <masak> so, the thunk needs to "remember its environment", just like a closure does.

[10:22] <diakopter> it makes all lexicals states?

[10:22] <masak> effectively it needs to run "as if it never moved" from the spot where it was written.

[10:22] <dalek> Perlito: 7012a50 | (Flavio S. Glock)++ | / (2 files):

[10:22] <dalek> Perlito: Perlito5 - compiler-in-browser - add missing Runtime module

[10:22] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/7012a508bc

[10:22] <masak> diakopter: I cannot map that to a set of facts. could you rephrase?

[10:23] <diakopter> you're a thunk?

[10:24] * masak ups the plonk prior on diakopter 

[10:24] <diakopter> it makes all "my" into "state" ?

[10:24] <masak> ah.

[10:24] <masak> no, I don't think that's it.

[10:24] <masak> (also, the terminology that confused me was calling "state variables" "states". never seen that before.)

[10:25] <diakopter> karma $i

[10:25] <diakopter> .karma $i

[10:25] <diakopter> ...

[10:25] <masak> diakopter: I don't think that's it, because the '$x && $y' could be in a for loop with 100 iterations, and each $y could be different (say, lexically defined in the loop body).

[10:25] <diakopter> !karma $i

[10:26] <diakopter> karma masak

[10:26] <diakopter> hrm

[10:26] <diakopter> Denny's seasoned fries aren't amazing

[10:26] <masak> diakopter: so it's still very much a 'my' variable -- it's just that the thunk knows it is *in* the loop body (and has its lexical environment), even when it's activated from somewhere else, like the infix:<&&> sub.

[10:27] <diakopter> what's the effect?

[10:28] <masak> could you be more specific?

[10:28] <masak> the effect is that running the thunk later sees the same lexicals as if it weren't a thunk.

[10:29] <diakopter> how is that different from a state

[10:29] <masak> r: for 1..10 { state $y = 0; $y++; say $y }

[10:29] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[10:29] <masak> r: for 1..10 { my $y = 0; $y++; say $y }

[10:29] <camelia> rakudo 296da0: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[10:30] <masak> that.

[10:30] <masak> I'm saying thunks *retain* (and respect) the latter behavior of lexical variables.

[10:30] <diakopter> right, what do you mean by "sees the same lexicals as if it weren't a thunk."

[10:30] <masak> no turning into state variables involved.

[10:31] <masak> r: 5 && my $y = 7; say $y

[10:31] <camelia> rakudo 296da0: OUTPUT«7␤»

[10:31] <masak> diakopter: the above wouldn't work if (say) the thunk had its own nested lexical scope.

[10:31] *** cognominal joined
[10:31] <masak> diakopter: the reason it works is that the thunk *shares* a lexical environment with its surrounding scope.

[10:32] <masak> diakopter: in that sense, thunks are "unhygienic closures".

[10:32] <diakopter> where's the thunk above

[10:32] <masak> 'my $y = 7'

[10:32] <masak> because

[10:32] <masak> r: 0 && my $y = 7; say $y

[10:32] <camelia> rakudo 296da0: OUTPUT«(Any)␤»

[10:32] <masak> now it never ran.

[10:33] <masak> so its being triggered is conditioned on runtime events.

[10:33] <diakopter> I don't get how that makes it a "thunk"

[10:33] <masak> that's what a thunk is.

[10:33] <masak> when the arguments/operands aren't evaluated before their function/operator is.

[10:33] <diakopter> how is that different from the area of a series of statements jumped over by a goto

[10:34] <masak> if it weren't a thunk 'my $y = 7' would happen before '&&'. now it happens after (or not at all).

[10:34] <masak> diakopter: I find it difficult to compare thunks and gotos. sorry.

[10:34] <diakopter> I'm just trying to get at the definition of a thunk

[10:35] <diakopter> so I'm asking whether the goto skipped area is one

[10:35] <masak> diakopter: in my mind, a thunk is this and this alone: take a closure, but lose its own scope, instead piggy-backing on (what would normally be) the OUTER scope.

[10:35] <masak> I don't know if that answers your question.

[10:36] <diakopter> okay, but I don't see how that's different from a section of code skipped by a conditional goto

[10:37] <diakopter> (how is there a closure in  5 && my $y = 7;  ?

[10:37] <diakopter> )

[10:37] <masak> let me try to answer your question, but bear in mind that I can't properly model what you're asking here, so my answer may be off.

[10:37] <masak> "a section of code skipped by a conditional goto" is functionally equivalent to an `if` statement.

[10:37] <masak> if you're asking whether such an `if` statement is involved, the answer is, it is. it's in the infix:<&&> implementation.

[10:38] <masak> (and that, in passing, was the philosophical difficulties pmichaud and I ran into. are `if` statements defined in terms of infix:<&&>, or vice versa?)

[10:38] <diakopter> right, so I didn't say "if statement" so as not to be confused with the lexical scope its block creates

[10:38] <diakopter> rn: my $y = 7 if $y; say $y

[10:38] <camelia> rakudo 296da0, niecza v24-88-g1f87209: OUTPUT«(Any)␤»

[10:39] <masak> right, in the above case '$y = 7' is also a thunk.

[10:39] <diakopter> who uses "thunk" like this?

[10:39] <masak> and similarly for statement_mod:<for>

[10:39] <masak> diakopter: TimToady, for sure.

[10:40] <masak> diakopter: 13 commits to the spec repo contain the word "thunk".

[10:40] <diakopter> I always thought it was where a closure was implied but without curlies

[10:40] <masak> 7 of them by TimToady.

[10:41] *** pupoque_ joined
[10:41] <masak> diakopter: yes, if by "without curlies" you also mean "without its own scope/environment".

[10:41] <diakopter> masak: oh, I see our confusion. :D

[10:41] <masak> thunks and closures are very similar. the only difference I know of is the "own scope" thing.

[10:41] <diakopter> I meant "state variable" in the *outer* scope

[10:42] <diakopter> you thought I meant in the inner scope

[10:43] <masak> I don't see how that helps at all.

[10:43] <masak> could you back this up with some code?

[10:43] <moritz> thunks are defined by the grammatical context, closures are explicit

[10:43] <masak> moritz: yes.

[10:44] <diakopter> masak: I didn't think I was saying anything that could be "backed up"

[10:44] <masak> moritz: and "grammatical context" could (hopefully) be reduced to "grammar rule or routine being used".

[10:44] <diakopter> I was asking a question, not making a claim

[10:44] <masak> diakopter: then my answer is still "no, I don't think so" :)

[10:44] <masak> at least I don't see it.

[10:44] <diakopter> it wasn't a rhetorical question

[10:45] <masak> I was just wondering whether you saw something I don't, and could show me code to convince me.

[10:45] <masak> apparently not :)

[10:45] <diakopter> no, I was just trying to understand what you were saying

[10:46] <masak> my understanding of thunks is totally not based on state variables.

[10:46] <masak> and trying to put them on that foundation only serves to confuse me.

[10:46] <diakopter> okay, but I still don't see how there's any distinction in the behavior

[10:46] <masak> which is a weaker statement than saying you're completely wrong.

[10:46] <diakopter> you haven't shown a distinction in the behavior

[10:47] <masak> diakopter: oh! the assignment in a 'state' declaration is also a thunk. so there is a connection.

[10:47] <diakopter> eh?

[10:47] <masak> diakopter: but I don't know if thunks could be completely defined in terms of state variables. that feels backward to me.

[10:47] <masak> diakopter: when you say 'state $s = 42', the '$s = 42' part is a thunk.

[10:48] <masak> that's why it doesn't run every time that statement is hit.

[10:48] * diakopter goes to look up how the rest of the world uses the word

[10:48] <masak> correct me if I'm wrong, but apart from that thunkishness, a 'state' variable is just a 'my' variable.

[10:48] <diakopter> er

[10:49] <diakopter> no

[10:49] <JimmyZ> it like my int $s = once { 42 }

[10:49] <moritz> masak: no, a 'state' variable also preserves state between subsequent calls to the same block

[10:49] <diakopter> yeah, that's not how the rest of the world uses the word at all

[10:50] <moritz> (well, it has to, in order to decide whether to evaluate the thunk)

[10:50] <moritz> but IMHO that's the bigger difference between 'my' and 'state' than whether the initialization thunks

[10:50] <masak> moritz: oh, true.

[10:50] <diakopter> a state variable is equivalent to this:

[10:51] <moritz> because you have 'state $s;' without any initialization too

[10:51] <diakopter>  { state $a; $a = 6; }    is the same as    { my $a; { $a = 6; } }()

[10:51] <masak> diakopter: as long as you hide the scope where the 'my' is declared, yes.

[10:51] <moritz> diakopter: isn't there a way that recursion distinguishes the two?

[10:51] <masak> oh! yes.

[10:52] <diakopter> what? why hide what scope?

[10:52] <masak> r: sub rec($n) { return unless $n; state $m = 0; $m++; say $m }; rec 5

[10:52] <camelia> rakudo 296da0: OUTPUT«1␤»

[10:52] <masak> r: sub rec($n) { return unless $n; state $m = 0; $m++; say $m; rec $n - 1 }; rec 5

[10:52] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤»

[10:52] <masak> diakopter's model doesn't explain this evaluation.

[10:52] *** pupoque__ left
[10:52] <diakopter> yes it does.

[10:53] *** pupoque_ left
[10:53] <diakopter> write it like I wrote mine

[10:53] <moritz> r: my $m = 0; sub rec($n) { return unless $n; state $m = 0; $m++; say $m; rec $n - 1 }; rec 5

[10:53] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤»

[10:53] <diakopter> eh

[10:53] <diakopter> no

[10:53] <masak> but there we didn't hide $m.

[10:53] <masak> so it's visible outside of &rev.

[10:53] <diakopter> you delcared an inner $m

[10:53] <masak> &rec*

[10:53] *** pupoque__ joined
[10:54] <diakopter> you forgot to remove the declaratio of hte inner $m

[10:54] *** pupoque_ joined
[10:54] <moritz> r: my $m = 0; sub rec($n) { return unless $n;  $m++; say $m; rec $n - 1 }; rec 5

[10:54] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤»

[10:54] <diakopter> r: my &rec = { sub ($n) { return unless $n; state $m = 0; $m++; say $m; rec $n - 1 } }(); rec 5

[10:55] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤»

[10:55] <masak> ok, diakopter++

[10:55] <diakopter> r: my &rec = { my $m = 0; sub ($n) { return unless $n; $m++; say $m; rec $n - 1 } }(); rec 5

[10:55] <camelia> rakudo 296da0: OUTPUT«1␤2␤3␤4␤5␤»

[10:55] <masak> that seems to correctly describe 'state' variables.

[10:55] <diakopter> that's what I meant

[10:55] <diakopter> (that last one)

[10:55] <masak> but I still don't see what this has to do (at all) with thunks.

[10:55] <moritz> S04 says

[10:55] <moritz> There is a new C<state> declarator that introduces a lexically scoped

[10:55] <moritz> variable like C<my> does, but with a lifetime that persists for the

[10:55] <moritz> life of the closure, so that it keeps its value from the end of one

[10:55] <moritz> call to the beginning of the next.  Separate clones of the closure

[10:55] <moritz> get separate state variables.  However, recursive calls to the same

[10:55] <moritz> clone use the same state variable.

[10:56] <diakopter> oh.

[10:56] <diakopter> that's what's so gosh-darn confusing.

[10:56] <moritz> so, the "Separate clones of the closure get separate state variables" needs to be modeled with the outer-lexical trick

[10:56] <masak> moritz: supposedly, 'clone' here means what I mean by 'incarnation'.

[10:56] <diakopter> TimToady uses "closure" and "clone of closure" to mean the same thing

[10:56] *** wk joined
[10:57] <masak> basically, in order to get a runtime environment out of a compile-time environment, you need to incarnate it.

[10:57] *** wk is now known as Guest31880

[10:57] <diakopter> masak: okay, so we're both wrong

[10:57] <moritz> are there still any open questions regarding thunks?

[10:57] <diakopter> moritz: no...

[10:57] <diakopter> I mean

[10:58] <diakopter> no to "so, the "

[10:58] <diakopter> the outer-lexical trick I showed is where they don't get copies

[10:58] <diakopter> er, don't get separate state variables

[10:59] <diakopter> er.

[10:59] <diakopter> oh wait, I see how it can be true.

[11:00] <diakopter> so anyway, yes, that shows that my model is right

[11:00] <moritz> no

[11:00] <masak> :)

[11:00] <diakopter> by "clone of closure" he means "time the code that creates the closure is run"

[11:01] <diakopter> (my assignment to &rec)

[11:01] <moritz> diakopter: when emulating state variables with outer lexicals, you can either set them up so that every closure clone gets a separate state variable, but then recursion does too, or you never get separate state variables

[11:01] *** rindolf left
[11:01] <diakopter> how does my example not do the former?

[11:02] <diakopter> (recursion there *doesn't* get a separate one)

[11:02] <moritz> diakopter: which example, exactly?

[11:02] <diakopter> the last one

[11:02] <diakopter> the one I said demonstrated what I was saying

[11:03] <moritz> diakopter: I'm trying to construct an example, hold on

[11:03] <diakopter> k

[11:04] <diakopter> (I still say the language there in the synopsis is absurdly esoteric, so much as to be absurdly confusing)

[11:05] <diakopter> because it uses "clone" to describe an implementation detail of the compiler that's not necessary

[11:05] <moritz> diakopter: no, you are right, it does work as specced

[11:05] <moritz> r: https://gist.github.com/moritz/6098219

[11:05] *** Su-Shee_ joined
[11:05] <camelia> rakudo 296da0: OUTPUT«1-1␤1-2␤1-3␤1-4␤1-5␤2-1␤2-2␤2-3␤2-4␤2-5␤»

[11:06] <moritz> each iteration of the outer loop creates a new closure, which gets a separate emulated state var. Everything fine.

[11:06] <diakopter> it's a trick everyone uses in JS all the time

[11:06] *** crab2313 joined
[11:07] <diakopter> moritz: heh, what if it was a state var? o_O

[11:07] <moritz> but come to think of it, I don't understand why it works

[11:08] <moritz> why do the recursive calls share the same $m?

[11:08] <diakopter> because there's only one $m per &rec

[11:08] <moritz> oh, I see

[11:09] <moritz> because &rec actually is the inner closure

[11:09] *** Su-Shee left
[11:10] <diakopter> rnp: https://gist.github.com/moritz/6098219

[11:10] *** pjcj joined
[11:10] <camelia> rakudo 296da0, niecza v24-88-g1f87209: OUTPUT«1-1␤1-2␤1-3␤1-4␤1-5␤2-1␤2-2␤2-3␤2-4␤2-5␤»

[11:10] <camelia> ..pugs: OUTPUT«*** Can't modify constant item: VStr "MkCode {isMulti = True, subName = \"&\", subType = SubPrim, subOuterPads = [], subInnerPad = MkPad (padToList []), subPackage = , subAssoc = AIrrelevantToParsing, subParams = [], subBindings = [], subSlurpLimit = [], subReturns = (mkTyp…

[11:10] <diakopter> eh

[11:11] <diakopter> why doesn't pugs like it?

[11:13] *** Su-Shee_ is now known as Su-Shee

[11:13] <diakopter> I use that exact trick in JS often to "capture" the value of a for loop variable inside a for loop when generating closures in a for loop

[11:14] <moritz> diakopter: for pugs you need to bind to &rec

[11:14] <diakopter> (and I've seen other people's code use it too)

[11:14] <moritz> r: for 1, 2 -> $x { my &rec := { my $m = 0; sub ($n) { return unless $n; $m++; say "$x-$m"; rec $n - 1 } }(); rec 5 }

[11:14] <camelia> rakudo 296da0: OUTPUT«1-1␤1-2␤1-3␤1-4␤1-5␤2-1␤2-2␤2-3␤2-4␤2-5␤»

[11:15] *** pupoque__ left
[11:15] <diakopter> I've also used that trick in C# to capture the same things for value to delegates generated in a loop

[11:16] <diakopter> C# is worse there because it *does* copy values of value types, but not reference.

[11:17] <diakopter> well, "worse" from a certain point of view

[11:19] <moritz> p: for 1, 2 -> $x { my &rec := { my $m = 0; sub ($n) { return unless $n; $m++; say "$x-$m"; rec $n - 1 } }(); rec 5 }

[11:19] <camelia> pugs: OUTPUT«1-1␤1-2␤1-3␤1-4␤1-5␤2-1␤2-2␤2-3␤2-4␤2-5␤»

[11:20] <moritz> it's fascinating how some concepts have converged to one clearly best model in several programming languages

[11:21] <moritz> like the lexicals and closures work

[11:21] <moritz> and the C3 MRO for languages with MI

[11:21] <dalek> roast: b595fce | (Elizabeth Mattijsen)++ | S04-declarations/state.t:

[11:21] <dalek> roast: Variable "will start {}" trait is no longer specced

[11:21] <dalek> roast: review: https://github.com/perl6/roast/commit/b595fce99a

[11:22] <moritz> it makes me want to search for more such patterns, and compile a list those successful elements of language design

[11:22] <diakopter> me2

[11:23] <moritz> our python and coffeescript folks will disagree, but I count "explicit declaration of symbols" among them

[11:23] <diakopter> sigils only made it to powershell.. javascript has just the 1 sigil, except it can be repeated.

[11:24] <diakopter> var $$$a = 33; console.log($$$a); /* prints 33 */

[11:25] <diakopter> right association for certain things

[11:26] <lizmat> on a slightly more mundane level:

[11:27] <lizmat> I'm trying to make the error on:

[11:27] <lizmat> r: my $a is foo

[11:27] <camelia> rakudo 296da0: OUTPUT«[31m===[0mSORRY![31m===[0m␤You cannot say 'is foo' in a variable declaration.␤at /tmp/b87MlFntkE:1␤------> ␤    expecting any of:␤        TypeObject␤        default␤        dynamic␤»

[11:27] <lizmat> also point to the location in the string where this occurs (like so many other errors)

[11:27] <masak> moritz: fully agree on "one clearly best model". and yes, a list would be kind of awesome.

[11:28] <lizmat> is this possible to do within the confines of the trait mod declaration, or do I need to get into the Actions to be able to do that?

[11:28] <masak> diakopter: '$' is not a sigil in JavaScript. it's just a valid character in identifiers.

[11:28] *** stevan_ left
[11:28] <masak> diakopter: soo 'foo$' is as valid as '$foo' or 'fo$o'.

[11:29] <masak> so*

[11:29] <diakopter> yeah

[11:30] <lizmat> in other words: can I get at the $/ of the outer scope, and if so, how?

[11:31] *** rindolf joined
[11:32] <moritz> well, $OUTER::('/') might work, but if you want to cross the nqp <-> rakudo boundary, probably not

[11:32] <lizmat> trying...

[11:33] *** pupoque__ joined
[11:39] <moritz> (but it sounds like intervention in the Actions is what you really want/should do)

[11:44] *** colomon joined
[11:47] *** ilogger2 joined
[11:47] *** ChanServ sets mode: +v ilogger2

[12:04] *** pupoque__ joined
[12:09] *** pupoque_ joined
[12:35] *** birdwindupbird joined
[12:37] *** pupoque_ left
[12:49] *** pupoque_ joined
[12:52] *** mtk joined
[13:08] *** crab2313 joined
[13:13] <dalek> rakudo/nom: 0543620 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[13:13] <dalek> rakudo/nom: We don't know the column, so don't pretend we do

[13:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0543620c5d

[13:13] <dalek> rakudo/nom: 5e6c759 | (Elizabeth Mattijsen)++ | src/ (2 files):

[13:13] <dalek> rakudo/nom: Expose NQP's $*W and $/ as attributes in Variable

[13:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5e6c75902c

[13:13] <dalek> rakudo/nom: cb7c22b | (Elizabeth Mattijsen)++ | src/Perl6/World.nqp:

[13:13] <dalek> rakudo/nom: Allow our own expectations to be passed to .throw

[13:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cb7c22ba34

[13:13] <dalek> rakudo/nom: 3328a1c | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[13:13] <dalek> rakudo/nom: Make exceptions for errors in variable traits show line and position

[13:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3328a1c3dd

[13:13] *** pupoque_ left
[13:14] *** pupoque__ left
[13:15] <lizmat> I could keep changes to Actions to a mimimum

[13:16] *** pupoque__ joined
[13:23] *** Vlavv_ joined
[13:23] <JimmyZ> :-)

[13:25] *** colomon joined
[13:26] *** celesta joined
[13:27] <celesta> hello. finally found irc ^^

[13:27] <dalek> rakudo/nom: 0818c24 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[13:27] <dalek> rakudo/nom: Remove variable traits "is readonly" and "is rw": they are not specced

[13:27] <dalek> rakudo/nom: 

[13:27] <dalek> rakudo/nom: Although there are spectests for "is readonly", I fail to see the use of

[13:27] <dalek> rakudo/nom: the attribute on a *variable* declaration.

[13:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0818c24cab

[13:27] <lizmat> hello celesta!

[13:34] <celesta> rakudo: say "hugs to every body"

[13:34] <camelia> rakudo 296da0: OUTPUT«hugs to every body␤»

[13:34] <lizmat> hugme hug celesta

[13:34] * hugme hugs celesta

[13:35] <dalek> roast: 253242f | (Elizabeth Mattijsen)++ | S06-traits/is-readonly.t:

[13:35] <dalek> roast: Remove now obsolete tests on variable trait "is readonly"

[13:35] <dalek> roast: review: https://github.com/perl6/roast/commit/253242f3dd

[13:38] <rindolf> celesta: hi.

[13:39] <celesta> rindolf: hello

[13:39] * tadzik hugs celesta himself

[13:40] <rindolf> celesta: welcome to IRC.

[13:45] <dalek> roast: ae81f8c | (Elizabeth Mattijsen)++ | S12-attributes/class.t:

[13:45] <dalek> roast: Remove unspecced 'is rw' atribute on variables

[13:45] <dalek> roast: review: https://github.com/perl6/roast/commit/ae81f8c188

[13:46] <dalek> roast: 2213769 | (Elizabeth Mattijsen)++ | S12-attributes/recursive.t:

[13:46] <dalek> roast: Remove unspecced 'is rw' atribute on variables

[13:46] <dalek> roast: review: https://github.com/perl6/roast/commit/2213769b48

[13:47] <masak> celesta: welcome, and hugs to you too! :)

[13:47] <masak> celesta: I was gonna ask if your nick was a MLP reference -- but I see now that's "Celestia". my bad. :)

[13:48] *** ppq_ joined
[13:48] <lizmat> r: my $x is default(42); say $x  # works fine

[13:48] <camelia> rakudo 296da0: OUTPUT«42␤»

[13:49] <lizmat> r: my $x is default (42); say $x # does something entirely different

[13:49] <camelia> rakudo 296da0: OUTPUT«True␤»

[13:49] <lizmat> .oO(what a difference a space makes)

[13:49] <masak> lizmat: that could well be the slogan of Perl 6 syntax. :)

[13:49] <lizmat> feels to me the latter should bomb somehow

[13:50] <masak> r: my $x (42); say "alive"

[13:50] <camelia> rakudo 296da0: OUTPUT«alive␤»

[13:50] <masak> I have no idea what's going on there.

[13:51] <masak> std: my $x (42);

[13:51] <camelia> std c2215f0: OUTPUT«ok 00:00 43m␤»

[13:57] <lizmat> rakudobug ? stdbug ?

[13:59] <masak> lizmat: I... I don't know.

[13:59] <masak> what does it mean? I don't even

[14:00] <masak> r: my $ (42); say "alive"

[14:00] <camelia> rakudo 296da0: OUTPUT«alive␤»

[14:00] <masak> that's the most meaningless line of code I've written all week.

[14:00] <lizmat> and yet it executes :-)

[14:02] <lizmat> r: my $x is default({ say "foo" }); say $x

[14:02] <camelia> rakudo 296da0: OUTPUT«Block.new()␤»

[14:02] *** crab2313 left
[14:02] <lizmat> or should it maybe execute the block ?

[14:03] <lizmat> could be argued either way, I guess

[14:03] <masak> executing the block would prevent setting &-sigil variables to blocks, perhaps.

[14:03] <lizmat> yes

[14:04] <lizmat> otoh, it would be a nice feature to have it call a block on (re-)initialization

[14:04] <masak> r: sub foo(:$) {}; say &foo.signature.perl

[14:04] <camelia> rakudo 296da0: OUTPUT«:()␤»

[14:05] <masak> lizmat: at that point, why not simply assign to it directly? 'my $x = "foo"'

[14:06] <lizmat> the point is that whenever the value is reinitialized (e.g. by assigning Nil to it) it would get the same value again

[14:06] <lizmat> r: my Int $x is default(42); $x = 1; say $x; $x=Nil; say $x

[14:06] <camelia> rakudo 296da0: OUTPUT«1␤42␤»

[14:06] <cognominal> r:  my @a = < 1 2 3 >;  for @a  -> $_ is ref { $_++ }; 

[14:06] <camelia> rakudo 296da0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Mu:U $child, Mu:U $parent)␤:(Mu:U $type, :rw(:$rw)!)␤:(Mu:U $type, :nativesize(:$nativesize)!)␤:(Mu:U $type, :unsigned(:$unsigned)!)␤:(Mu:U $type, :hidden(:$hidden)!)␤:(M…

[14:08] <cognominal> is there a way to iterate an array and modify in place?

[14:08] <masak> r: my @a = <1 2 3>; for @a <-> $_{ $_++ }; say @a

[14:08] <camelia> rakudo 296da0: OUTPUT«2 3 4␤»

[14:08] <masak> r: my @a = <1 2 3>; for @a { $_++ }; say @a

[14:08] <camelia> rakudo 296da0: OUTPUT«2 3 4␤»

[14:08] <masak> '<-> $_' is the default for for loops.

[14:09] <masak> r: my @a = <1 2 3>; for @a -> $_ is rw { $_++ }; say @a

[14:09] <camelia> rakudo 296da0: OUTPUT«2 3 4␤»

[14:09] <masak> and '<-> $_' is sugar for '-> $_ is rw'

[14:09] <lizmat> r: my @a = < 1 2 3 >;  for @a  -> $_ is rw { $_++ }; say @a  # if you want to be explicit,

[14:09] <cognominal> ho, that's right. I forgot

[14:09] <camelia> rakudo 296da0: OUTPUT«2 3 4␤»

[14:09] * masak is faster than lizmat :)

[14:10] <lizmat> :-)

[14:12] <cognominal> thx, masak, lizmat. Wish I could that in javascript/coffeescript but everything is passed by value. So doing it gets ugly very fast.

[14:13] <masak> cognominal: just wrap things in an object. the object references are also passed by value, but the extra layer of indirection can be used to simulate the "container" effect you want.

[14:14] <masak> i.e. `function foo(w) { w.x++ }; var my_w = { x: 0 }; foo(my_w); foo(my_w); console.log(my_w.x); # w`

[14:14] <masak> er, s/w`/2`/

[14:18] * lizmat wonders if S06:1922 is a remnant from days passed by

[14:18] * synopsebot Link: http://perlcabal.org/syn/S06.html#line_1922

[14:18] *** benabik joined
[14:18] <cognominal> I pass the structure and the key/index instead so that will buy me the potential of extra behavior that maybe someday offset the cost.

[14:19] <cognominal> that was a answer to masak suggestion.

[14:19] <cognominal> masak++, lizmat++

[14:20] *** ppq_ left
[14:22] <masak> synopsebot! \o/

[14:22] <masak> lizmat: no. there used to be another 'is ref', which got unspec'd, and some time later this one got spec'd again.

[14:23] <lizmat> but as yet unimplemented

[14:23] <lizmat> as the tests for it are marked "skip"

[14:23] <masak> lizmat: the newer one got spec'd sometime after I had spent quite some energy complaining loudly about the semantics of arrays being passed to .new methods.

[14:23] <masak> lizmat: it must've been, um, 2009.

[14:23] <masak> I remember sitting in the back seat talking with mberends and jnthn about it.

[14:23] <lizmat> :-)

[14:24] <masak> or was that 2010? I forget.

[14:24] <masak> I could dig up the backlog if you're interested.

[14:24] *** census joined
[14:24] <lizmat> nono, I was just looking for dead weed to be removed

[14:25] <lizmat> like "is start" I recently buried

[14:25] <tadzik> hmm, I didn't know that synopsebot uses /me

[14:25] <masak> yeah, March 2010.

[14:25] <tadzik> ah, it just repeated after lizmat :

[14:25] <tadzik> :)

[14:26] <lizmat> .oO( wonders what it will do with a synopsis ref in a /nick)

[14:27] *** rindolf joined
[14:27] <tadzik> it reacts on said() from Bot::BasicBot, so it may not do anything :)

[14:28] <lizmat> *phew*  :-)

[14:28] <masak> lizmat: ah, here: http://irclog.perlgeek.de/perl6/2010-03-07#i_2073494

[14:28] <lizmat> masak: thanks!

[14:35] *** ppq_ joined
[14:36] <perigrin> lizmat: 10:36 [freenode] S06:1922 Erroneous Nickname

[14:36] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_1922

[14:36] <perigrin> So you're partially safe :)

[14:36] <lizmat> :-)

[14:38] <timotimo> ohai #perl6

[14:39] <lizmat> timotimo o/

[14:39] <masak> timotimo! \o/

[14:40] <timotimo> out of nowhere, i'm now wondering if the automatically 'generated' BUILD methods are actually generated once per class or if there's a generic BUILD method that iterates through all things it needs to do to do them

[14:40] <timotimo> i wonder if that would give a speed boost to class instantiation if one would build a BUILD builder.

[14:41] <perigrin> timotimo: you'd have to name it Bob.

[14:41] <masak> timotimo: they have to be per-class, since they are submethods (which don't inherit).

[14:41] <benabik> Bob Bob the Build Builder.

[14:41] <benabik> Maybe Bo Bob?

[14:42] <perigrin> benabik: either way, as long as he can fix it ... we're good.

[14:42] *** Psyche^ joined
[14:42] <timotimo> BUILDALL isn't where i should be looking at, right? that just goes through all the necessary BUILD methods or something?

[14:42] <timotimo> i hear thunder! it will get cool today! \o/

[14:44] <masak> timotimo: mayhaps this will help? http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html

[14:45] <masak> timotimo: it seems to me from that diagram that whereas BUILD is a submethod, BUILDALL is not -- it's on Mu and inherits, and it's overridable.

[14:47] <timotimo> right. it seems like there's a thing called BUILDPLAN that's basically a "pregenerated to-do list" that describes how BUILD should behave on any given class

[14:47] <timotimo> so there's not much thoroughly obvious optimisation to be had there

[14:48] <timotimo> that article is more enlightening now than it was the last time i read it; i wonder if that's a flaw in me or in the article?

[14:51] <masak> sounds like a feature, not a flaw ;)

[14:51] <timotimo> rain \o/

[14:53] *** ppq_ left
[14:53] *** pupoque__ left
[14:54] <Su-Shee> timotimo: where?

[14:56] *** pupoque__ joined
[14:58] <dalek> specs: b7db6eb | (Timo Paulssen)++ | S26-documentation.pod:

[14:58] <dalek> specs: fix heading for :allow

[14:58] <dalek> specs: review: https://github.com/perl6/specs/commit/b7db6ebaf1

[14:58] <dalek> specs: 57f92fe | (Timo Paulssen)++ | S99-glossary.pod:

[14:58] <dalek> specs: S99: add "mumble"

[14:58] <dalek> specs: review: https://github.com/perl6/specs/commit/57f92fe2a0

[14:58] <dalek> specs: a5f83cf | (Timo Paulssen)++ | S99-glossary.pod:

[14:58] <dalek> specs: S99: add "6model"

[14:58] <dalek> specs: review: https://github.com/perl6/specs/commit/a5f83cf603

[14:58] <timotimo> Karlsruhe

[14:59] *** benabik left
[15:01] *** ppq_ joined
[15:04] <dalek> rakudo/nom: b9ac7a4 | (Elizabeth Mattijsen)++ | / (5 files):

[15:04] <dalek> rakudo/nom: Make CORE.setting's files' names a bit more descriptive at either end

[15:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9ac7a463d

[15:05] *** isBEKaml joined
[15:06] <dalek> rakudo/nom: 96776bb | (Elizabeth Mattijsen)++ | src/core/must_be_first.pm:

[15:06] <dalek> rakudo/nom: Well, we need this at the beginning, of course, oops

[15:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/96776bbec4

[15:08] <lizmat> cycling & dinner&

[15:09] <timotimo> .o(essen auf rädern?)

[15:10] <lizmat> no, just cycling to a restaurant (~25 km) and then have dinner there :-)

[15:11] <lizmat> and then cycle back  :-)

[15:12] <masak> sounds wonderful.

[15:12] *** benabik joined
[15:15] <timotimo> hmm. given how much more work needs to be done, i suppose this timing isn't terribly bad: creating 10000 simple objects (just has 4 attributes) takes 6.57 seconds (including parse&compile time) and 10000 parcels (as .item) with the same contents takes 2.62 seconds

[15:16] <timotimo> (--target=optimize takes 0.83 seconds)

[15:17] <timotimo> hm, so that takes it up to a difference between roughly 1.7 seconds and 5.6 seconds

[15:18] <timotimo> i know that the pypy people can make object creation about as fast as just creating a tuple ... i wonder how hard it will be for rakudo to do the same thing

[15:18] <timotimo> should probably be even easier, since objects i rakudo don't just "grow new attributes" all the time

[15:19] *** BenGoldberg joined
[15:20] <JimmyZ> --target=optimize? 

[15:21] <timotimo> basically "just compile and optimize, do not run"

[15:29] * masak .oO( I maded you an optimized program but I ate it )

[15:29] *** dmol joined
[15:31] <timotimo> hmm. if the optimizer knows for a fact that an object is "super simple" (no custom new, no custom BUILD, and derived from a "super simple" class), i wonder if it could use some super crazy fast nqp::createobject op instead of going through the BUILDPLAN and all that

[15:34] <flussence> it's worth trying even for a tiny speedup; everything's an object...

[15:34] <timotimo> yeah, but how many objects are "super sipmle"?

[15:35] <timotimo> what's with me and typos today?

[15:36] *** ppq_ left
[15:36] <BenGoldberg> Are Int and Real "super simple" by that reasoning?

[15:36] <flussence> yeah, looking at it at least a few of the numeric classes fit those criteria

[15:36] <flussence> Str isn't though, has a BUILD...

[15:37] <BenGoldberg> Even if it only sped up the numerics, it would likely be worth it.

[15:38] <timotimo> unless of course the optimizer learns to turn all numeric calculations into native calculations on its own ;)

[15:39] <timotimo> out of all these things 'on the table' right now, i wonder which would be low hanging enough for me to pick ...

[15:39] <flussence> Cursor also doesn't do any fance stuff... now that's one that might be worth optimising.

[15:39] <timotimo> oh, cursor!

[15:39] <timotimo> but that's already in nqp

[15:39] <timotimo> i don't think nqp has an optimizer

[15:40] <timotimo> i would very, very much like a faster parse stage during setting compilation, honestly

[15:40] <flussence> +1

[15:41] *** census left
[15:41] <BenGoldberg> preflex: ordinal 3

[15:41] <preflex>  3th

[15:42] <flussence> wat.

[15:42] * masak .oO( are you 3thsty? have a glass of ordinal water. )

[15:42] <timotimo> i wonder if rakudo will ever reach the state where my hypothetical immutable Point class with arithmetic operators defined on it will have code like "$new = $new + $another * 5" 'inlined' to not create intermediate objects, or perhaps even re-use the memory locations inside the old $new ...

[15:43] <BenGoldberg> Are Real objects immutable?

[15:43] <flussence> in a perfect world, that'd be condensed down to a single FMA CPU instruction :)

[15:43] <timotimo> i guess the compiler would have enough info on its hands, but probably not enough cleverness yet - by far

[15:43] *** SamuraiJack__ joined
[15:44] <timotimo> BenGoldberg: Real is just a role

[15:44] <timotimo> you want to ask about Num or Rat

[15:45] <timotimo> er, Rat doesn't do real

[15:45] <BenGoldberg> Oh

[15:45] <BenGoldberg> r: (3 + 2i).say

[15:45] <camelia> rakudo 96776b: OUTPUT«3+2i␤»

[15:45] <BenGoldberg> r: (3 + 2i).perl.say

[15:45] <camelia> rakudo 96776b: OUTPUT«Complex.new(3, 2)␤»

[15:45] <timotimo> Num already doesn't do complex BUILD or New stuff, it just boxes a numeric object "in itself"

[15:45] <BenGoldberg> Complex.  That's what I meant to say

[15:45] <timotimo> so that should be pretty fast

[15:46] <timotimo> complex does a little bit of complex setup in its construction

[15:46] <colomon> rn: say (2/3) ~~ Rat

[15:46] <camelia> rakudo 96776b, niecza v24-88-g1f87209: OUTPUT«True␤»

[15:46] <colomon> rn: say (2/3) ~~ Real

[15:46] <camelia> rakudo 96776b, niecza v24-88-g1f87209: OUTPUT«True␤»

[15:47] <timotimo> rn: say <2/3> ~~ Real

[15:47] <camelia> rakudo 96776b: OUTPUT«False␤»

[15:47] <camelia> ..niecza v24-88-g1f87209: OUTPUT«True␤»

[15:47] <timotimo> hehe.

[15:47] <colomon> rakudobug

[15:47] *** ppq_ joined
[15:47] <timotimo> i don't think rakudo (or perl6 in general) has a very clear definition of "immutable" yet

[15:47] <colomon> rn: say <2/3> ~~ Str

[15:47] <camelia> niecza v24-88-g1f87209: OUTPUT«False␤»

[15:47] <camelia> ..rakudo 96776b: OUTPUT«True␤»

[15:47] <timotimo> Complex has $.im and $.re defined as "ro" (by default), but that doesn't mean that the class can't $!re = 10 somewhere out of the blue

[15:47] <colomon> rn: say <2/3>.WHAT

[15:47] <camelia> niecza v24-88-g1f87209: OUTPUT«(Rat)␤»

[15:47] <camelia> ..rakudo 96776b: OUTPUT«(Str)␤»

[15:47] <timotimo> and you can probably still nqp::bindattr(...) or something?

[15:48] *** isBEKaml left
[15:48] <colomon> nieczabug too, joy

[15:48] <timotimo> well, isn't it NYI on rakudo?

[15:48] <colomon> you say tomato, I say tomato

[15:48] <timotimo> :)

[15:50] <colomon> anyway, my real point back there was that Rat does Real; if that's not obvious in Rakudo, it may be that it's doing Rational which itself does Real

[15:52] <pmichaud> instead of "must_be_first.pm" and "must_be_last.pm"  I propose "prologue.pm" and "epilogue.pm".  (in case nobody thought of those yet.)

[15:52] <pmichaud> or core_prologue and core_epilogue

[15:53] <pmichaud> afk again

[15:53] *** btyler joined
[15:53] <BenGoldberg> I wonder if at some point in the future, I could ask rakudo to always auto-unbox objects of a particular class into one or more variables, and to always inline methods of that class where possible (and re-box those variables into an object, if inlining is impossible).  Basically, each Rat, Complex, and Point would always get turned into a pair of Nums.  Kinda like structs in C

[15:54] <timotimo> sounds more like something a jit would do, i thik

[15:57] <masak> r: grammar G { rule TOP { ^ <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[15:57] <camelia> rakudo 96776b: OUTPUT«False␤»

[15:58] <masak> I was under the impression that the space between '^' and '<foo>' would eat the space at the beginning of " foo".

[15:58] <masak> what am I missing?

[15:59] <JimmyZ> token vs rule?

[15:59] <moritz> masak: I think there's a special case that leading whitespaces in rules aren't counted as <.ws>

[15:59] <masak> JimmyZ: well, 'rule' is the one that gives me whitespace significance.

[15:59] <masak> moritz: right, but this one isn't leading, it's after the '^'.

[16:00] <masak> r: grammar G { rule TOP { ^ <?> <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[16:00] <camelia> rakudo 96776b: OUTPUT«False␤»

[16:00] <masak> and putting more stuff in between doesn't help either...

[16:00] <masak> r: grammar G { rule TOP { ^ :: <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[16:00] <camelia> rakudo 96776b: OUTPUT«[31m===[0mSORRY![31m===[0m␤:: not yet implemented␤at /tmp/QVYdpUIFHv:1␤------> [32mgrammar G { rule TOP { ^ ::[33m⏏[31m <foo> }; rule foo { foo } }; say ?G.par[0m␤»

[16:00] <JimmyZ> oh, yes

[16:01] <moritz> r: grammar G { rule TOP { ^ <?> <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[16:01] <camelia> rakudo 96776b: OUTPUT«False␤»

[16:01] <masak> if no-one has an explanation I'm going to file a rakudobug.

[16:02] * masak makes a wide-eyed, maniac-looking face

[16:03] <masak> S03:330 has this to say:

[16:03] <synopsebot> Link: http://perlcabal.org/syn/S03.html#line_330

[16:03] <masak> "Only whitespace sequences immediately following a

[16:03] <masak> matching construct (atom, quantified atom, or assertion) are eligible."

[16:03] <masak> but at least <?> is an assertion, no?

[16:03] <moritz> it is

[16:04] <moritz> in the very least it's an atom :-)

[16:04] <masak> heh.

[16:04] * masak submits rakudobug

[16:04] *** fridim_ joined
[16:06] <BenGoldberg> r: my $x (Int); $x = 'alive'; say $x

[16:06] <camelia> rakudo 96776b: OUTPUT«alive␤»

[16:06] <BenGoldberg> r: my $x (Int 2); say $x

[16:06] <camelia> rakudo 96776b: OUTPUT«[31m===[0mSORRY![31m===[0m␤A parameter may only have one prefix type constraint␤at /tmp/sfM2O9lE5_:1␤------> [32mmy $x (Int 2[33m⏏[31m); say $x[0m␤    expecting any of:␤        scoped declarator␤        constraint␤»

[16:06] <BenGoldberg> r: my $x (Int(2)); say $x

[16:06] <camelia> rakudo 96776b: OUTPUT«[31m===[0mSORRY![31m===[0m␤coercive type declarations not yet implemented. Sorry. ␤at /tmp/LrvZ9daRiz:1␤------> [32mmy $x (Int(2)[33m⏏[31m); say $x[0m␤»

[16:07] <masak> r: grammar G { token TOP { ^ :s <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[16:07] <camelia> rakudo 96776b: OUTPUT«True␤»

[16:07] <masak> oh, so *that* works?

[16:07] <masak> r: grammar G { token TOP { :s ^ <foo> }; rule foo { foo } }; say ?G.parse(" foo")

[16:07] <camelia> rakudo 96776b: OUTPUT«False␤»

[16:12] *** dmol left
[16:16] *** dmol joined
[16:16] *** pjcj joined
[16:16] *** colomon left
[16:22] <pmichaud> note that rakudo still has the leading whitespace bug, iirc

[16:22] *** Vlavv_ left
[16:23] <pmichaud> (at least we still have the note about it in the star release notes)

[16:23] <pmichaud> afk again

[16:28] *** ppq_ left
[16:28] *** pupoque__ left
[16:30] <dalek> rakudo/nom: aca15ca | (Elizabeth Mattijsen)++ | / (6 files):

[16:30] <dalek> rakudo/nom: Make proper core_(pro|epi)logue, as suggested by pmichaud++

[16:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aca15caddb

[16:32] *** ppq_ joined
[16:34] *** Vlavv_ joined
[16:35] *** dmol left
[16:36] *** dmol joined
[16:38] *** colomon joined
[16:41] <lizmat> hmmm… it seems dalek is not picking up commits

[16:41] <lizmat> *sigh*  it is  :-)

[16:41] <lizmat> .o( scrolling down helps )

[16:42] <timotimo> can someone fix my entry in the CREDITS where it sys my github user name is "timotimo", but it really should be just "timo"?

[16:43] <timotimo> i guess when i put it in i though of irc nickname

[16:43] <moritz> lizmat: re commit 5e6c75902c, I'm not sure it's a good idea to let $*W into rakudo userspace

[16:43] <moritz> it's very much compiler internal, and should stay there if at all possible

[16:44] <dalek> rakudo/nom: c9c4387 | (Elizabeth Mattijsen)++ | CREDITS:

[16:44] <dalek> rakudo/nom: Fix timo's U

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c9c4387a26

[16:44] <lizmat> well, I only use it to call a compiler internal method on it  :-)

[16:45] <lizmat> World.throw basically has all the things we need to throw a correct compile error

[16:45] <lizmat> I would be all for exposing this to Perl6 in another way

[16:46] <moritz> I currently don't have the mental capacity to think of a better way

[16:46] <moritz> but if I do, I'll fix it for sure :-)

[16:46] <lizmat> :-)

[16:46] <lizmat> until then, it is only exposed in an internal Perl6 module anyway

[16:46] <lizmat> if anything, I would be more worried about GC issues actually

[16:47] <moritz> that's part of my worries too

[16:47] <moritz> $/ and $*W contain references to llots of things

[16:48] <timotimo> can't we just set a &*GRAMMAR_THROW (non-sic)?

[16:50] <masak> r: grammar G { token TOP { ^<foo>$ }; rule foo { foo } }; say ?G.parse(" foo")

[16:50] <camelia> rakudo 96776b: OUTPUT«True␤»

[16:50] <masak> r: grammar G { token TOP { ^<foo>$ }; rule foo {foo } }; say ?G.parse(" foo")

[16:50] <camelia> rakudo 96776b: OUTPUT«False␤»

[16:51] <masak> I thought rules ignored initial whitespace...

[16:51] <masak> I notice that I am confused.

[16:52] <dalek> rakudo/nom: bcfe199 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[16:52] <dalek> rakudo/nom: Make list of "will" suggestions take up less screen space

[16:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bcfe19999f

[16:53] <moritz> masak: it's fascinating how rakudo still parses so well, being built on Perl 6 rules... :-)

[16:57] <masak> heh.

[16:57] <masak> can I just file this one as a separate ticket?

[16:58] <masak> it's related to whitespace and rules just like the ticket I already filed, but this issue is sort of the opposite of that one...

[16:58] <masak> so they may not be related.

[16:58] * masak does a search through RT first

[17:01] <masak> here is some discussion in a rejected ticket: https://rt.perl.org/rt3/Ticket/Display.html?id=75668

[17:03] <masak> ah -- here: https://rt.perl.org/rt3/Ticket/Display.html?id=109874

[17:03] <masak> let's just add today's discussion to that one.

[17:20] *** birdwindupbird left
[17:23] <Ulti> parallelism in Perl6 is going to be so utterly great! I've been waiting for 8 hours for some bootstraps in R which could have been done in an hour on this desktop with trivial parallelism

[17:25] <Ulti> every language should really be getting keywords to prefix loops with if they can be parallel unrolled

[17:25] <spider-mario> OpenMP style

[17:26] <Ulti> yeah basically

[17:28] <Ulti> though I still think some pragma to alter the parallelism to be across many desktops would be good

[17:28] <Ulti> use hosts <pc1.domain.com pc2.domain.com pc3.domain.com>;

[17:29] <Ulti> though I guess looking at file handles and making sure they are copied over and stuff become incredibly hard to implement

[17:30] <Ulti> just doesn't feel impossible to make the magic though, something that is like GNU parallel but with most common use cases implemented for you

[17:44] *** grondilu joined
[17:58] *** SamuraiJack__ left
[18:02] *** rindolf left
[18:09] *** mathw joined
[18:11] <diakopter> ruoso: howdy :)

[18:12] *** colomon left
[18:25] *** dmol left
[18:27] *** dmol joined
[18:27] *** colomon joined
[18:28] *** Vlavv_ left
[18:30] *** kurahaupo joined
[18:39] *** kurahaupo_ joined
[18:40] *** kurahaupo left
[18:41] *** Vlavv_ joined
[18:54] <dalek> rakudo-star-daily: 0617542 | coke++ | log/ (4 files):

[18:54] <dalek> rakudo-star-daily: today (automated commit)

[18:54] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0617542370

[19:04] *** kurahaupo_ left
[19:06] *** Nom- joined
[19:08] *** jtpalmer joined
[19:08] <grondilu> r: say .WHAT given my Array of Int @ = (^100).roll(10);

[19:08] <camelia> rakudo bcfe19: OUTPUT«(Array+{TypedArray})␤»

[19:09] <grondilu> so this is implemented now.  Cool.

[19:10] *** abnorman joined
[19:27] *** rindolf joined
[19:28] <lizmat> yes, that should work now

[19:29] *** xinming joined
[19:30] <lizmat> r: say .WHAT given my Int Array @ = (^100).roll(10);  # didn't this work for a long time already as well ?

[19:30] <camelia> rakudo bcfe19: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet implemented. Sorry. ␤at /tmp/EXaamKCUMA:1␤------> [32msay .WHAT given my Int Array [33m⏏[31m@ = (^100).roll(10);  # didn't this work[0m␤    expecting any of:␤        scoped declarator␤»…

[19:31] <lizmat> I guess it didn't  :-)

[19:33] <masak> I don't know what you think that means.

[19:33] <masak> a Positional of Int Array hybrids?

[19:35] <masak> r: class IntArrayHybrid is Int is Array {}; my $iah = IntArrayHybrid.new; say $iah

[19:35] <camelia> rakudo bcfe19: OUTPUT«0␤»

[19:35] <masak> r: class IntArrayHybrid is Int is Array {}; my $iah = IntArrayHybrid.new; $iah.push(5, 2, 7); say $iah.elems

[19:35] <camelia> rakudo bcfe19: OUTPUT«3␤»

[19:35] <masak> that's... sick. and awesome. :P

[19:36] <masak> r: class IntArrayHybrid is Int is Array {}; my $iah = IntArrayHybrid.new; say $iah.^methods

[19:36] <camelia> rakudo bcfe19: OUTPUT«Int Num Rat FatRat abs Bridge chr sqrt base expmod is-prime floor ceiling round lsb msb sign conj rand sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh unpolar cis Complex …

[19:37] <masak> r: class IntArrayHybrid is Int is Array {}; my $iah = IntArrayHybrid.new; say +$iah.^methods, " ({+Int.^methods} + {+Array.^methods})"

[19:37] <camelia> rakudo bcfe19: OUTPUT«136 (64 + 72)␤»

[19:38] <masak> r: class IntArrayHybrid is Int is Array {}; my $iah = IntArrayHybrid.new; say +$iah.^methods, " ({+Int.^methods} + {+Array.^methods} - {$iah.^methods - Int.^methods - Array.^methods})"

[19:38] <camelia> rakudo bcfe19: OUTPUT«136 (64 + 72 - 0)␤»

[19:39] *** kurahaupo joined
[19:40] <lizmat> fwiw, I wasn't going for any hybrids…  I just misread the Array bit   :-)

[19:43] *** logie joined
[19:49] <masak> well, doing something like 'my Array[Int] @a' is one of the most common beginner blunders people make with Perl 6.

[19:49] <masak> I guess I'm just attuned to picking it out and pointing it out to people. :)

[19:50] <lizmat> hehe

[19:50] <lizmat> Q: how many CATCH blocks to a try {} ?

[19:50] <masak> slogan: "the sigil is a *type declaration*"

[19:50] *** logie left
[19:50] <lizmat> I think the spec says: 1

[19:51] <lizmat> how can we reconcile this with the "is catch {…}" variable trait?

[19:53] <celesta> goodbye. thank you masak

[19:53] *** celesta left
[19:55] <lizmat> *will catch

[19:55] <lizmat> will only 1 variable in a block be allowed to have the "will catch {…}" trait?

[19:55] <lizmat> and will this prohibit a "real" CATCH block ?

[19:56] <lizmat> same seems to apply to CONTROL blocks

[19:57] * lizmat is marking "will catch" and "will control" as NYI until further notice

[20:00] <dalek> rakudo/nom: 8a8048a | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[20:00] <dalek> rakudo/nom: General "will foo { ... }" cleanup

[20:00] <dalek> rakudo/nom: 

[20:00] <dalek> rakudo/nom: Marked as NYI: final init end catch control compose

[20:00] <dalek> rakudo/nom: Now also work: begin check

[20:00] <dalek> rakudo/nom: Todo: make $_ refer to the variable being defined

[20:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a8048a161

[20:01] <masak> celesta++ # one new RT ticket and one old

[20:01] <masak> on the first day!

[20:06] *** crab2313 joined
[20:06] *** colomon left
[20:07] <lizmat> hmmm…. have I broken rakudo's build with that last commit ?

[20:09] <spider-mario> I am a little confused by commit 0818c24cab5ccab3aba4858b6f5d09df12760738

[20:09] <dalek> rakudo/nom: 85b9234 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[20:09] <dalek> rakudo/nom: Oops, long live vim!

[20:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85b92348ff

[20:09] <spider-mario> https://github.com/rakudo/rakudo/commit/0818c24cab5ccab3aba4858b6f5d09df12760738

[20:10] <spider-mario> “Although there are spectests for "is readonly", I fail to see the use of the attribute on a *variable* declaration.”

[20:10] <spider-mario> wouldn’t it… make the variable read only?

[20:10] <spider-mario> what am I missing?

[20:10] <geekosaur> discussion yesterday

[20:10] <lizmat> please note, this is about *variables*, not about parameters or atrtibutes

[20:10] <lizmat> attributes

[20:11] <spider-mario> yes

[20:11] <lizmat> my $a is readonly=4

[20:11] <spider-mario> I thought of something like the effect of the Readonly module in Perl 5

[20:11] <lizmat> my $a := 4;

[20:11] <lizmat> this is not what "is readonly" is

[20:12] <lizmat> ReadOnly in p5 makes things readonly after the fact

[20:13] <lizmat> hmmm…. I guess, not, my recollection seems to be wrong

[20:13] <lizmat> guess I'm confusing it with Internals::READONLY or so

[20:14] <spider-mario> I was thinking about:

[20:14] <spider-mario> Readonly my $a = 4;

[20:14] <lizmat> r: my constant a = 4; say a

[20:14] <camelia> rakudo bcfe19: OUTPUT«4␤»

[20:14] <spider-mario> oh

[20:15] <spider-mario> so, is that different from constant without my?

[20:15] <spider-mario> I thought constant $a implied compile-time evaluation

[20:16] <lizmat> indeed it does

[20:16] <lizmat> hmmm....

[20:20] *** pmurias joined
[20:21] <lizmat> r: my $a=BEGIN 5; my constant b = $a; say $a; say b  # rakudobug?

[20:21] <camelia> rakudo bcfe19: OUTPUT«5␤(Any)␤»

[20:23] <pmurias> Ulti: re paralleism across multiple desktops isn't the sort of paralleism we would want to do across different machines different to the ones we want to do in different threads

[20:23] <pmurias> ?

[20:25] <lizmat> spider-mario: so maybe we need to spec "is readonly" for variables after all

[20:25] <lizmat> tricky bit is to actually allow one assignment

[20:26] <spider-mario> should we maybe make it mandatory that it takes place immediately after declaration?

[20:26] <lizmat> maybe would should have a phaser that fires at compile time whenever a block is completely compiled ?

[20:26] <Ulti> pmurias: nope not in bioinformatics, I usually want to go wide to around 100 cpus just to get everything done

[20:27] <Ulti> when the time taken for IO is way less than CPU you dont mind shuffling things over the network

[20:27] <spider-mario> rust doesn’t have that restriction but I’m not sure how they do it exactly

[20:27] <lizmat> Ulti: before long, you will have 100 CPU's on your desktop

[20:27] <Ulti> but what does take time is writing all that stuff yourself and doing it properly

[20:27] <lizmat> spider-mario: yes, but that doesn't make it easier at the implementation level

[20:27] *** bluescreen10 joined
[20:27] <Ulti> lizmat: yeah and at that point I will just do more and more ambitious analysis :) biotech is ahead of computational ability its growing faster than CPU power

[20:28] <lizmat> Need.   More.   Metal  :-)

[20:28] <Ulti> or clouds

[20:29] <Ulti> fluffy clouds made of carbon nano tubes and pulses of laser light or something

[20:30] <lizmat> .oO( I sing the cloud electric )

[20:32] * masak .oO( do cloud solutions dream of electric mapreduces? )

[20:38] <lizmat> .oO( or do they just fear the blade runner? )

[20:40] *** crab2313 left
[20:43] *** colomon joined
[20:44] * masak .oO( in their defense, that blade runner is kind of a Dick )

[20:45] <lizmat> .oO( privately, he seemed ok )

[20:45] <mst> roses are red, violets are glorious, don't surprise, oscar pistorious

[20:46] <lizmat> :-)

[20:46] <diakopter> :D

[20:47] <geekosaur> (Jaco Pastorius?)

[20:47] <lizmat> that dude played bass

[20:51] *** bluescreen100 joined
[20:51] * masak .oO( that dude played /Morone saxatilis/ )

[20:52] <masak> punning in Latin. that's the international sign that masak is too tired to be awake!

[20:53] <masak> 'night, #perl6

[20:54] *** bluescreen10 left
[20:55] <lizmat> gnight masak!

[20:59] *** kurahaupo left
[20:59] <timotimo> 22:52 < masak> punning in Latin. that's the international sign that masak is too tired to be awake!

[20:59] <timotimo> 22:53 < masak> 'night, #perl6

[20:59] <timotimo> er, apologies

[21:00] *** kurahaupo joined
[21:08] <diakopter> .seen sorear

[21:08] <yoleaux> I saw sorear 21 Jul 2013 06:33Z in #perl6: <sorear> admittedly it's largely out of necessity

[21:08] <preflex>  yoleaux: you have 1 new message. '/msg preflex messages' to read it.

[21:09] <diakopter> hee

[21:15] *** araujo joined
[21:16] *** rindolf left
[21:18] <dalek> rakudo/nom: 3257b05 | (Elizabeth Mattijsen)++ | src/Perl6/ (3 files):

[21:18] <dalek> rakudo/nom: Repurpose START phaser code to make once {} blocks work

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3257b05b0d

[21:18] <lizmat> now on to update some now failing tests

[21:29] *** bluescreen10 joined
[21:33] <dalek> roast: 84f18c8 | (Elizabeth Mattijsen)++ | S04-phasers/ (2 files):

[21:33] <dalek> roast: Remove tests for now defunct START phaser

[21:33] <dalek> roast: review: https://github.com/perl6/roast/commit/84f18c8c3d

[21:34] *** dmol left
[21:35] *** dmol joined
[21:40] *** ecocode joined
[21:40] <dalek> roast: a3782f8 | (Elizabeth Mattijsen)++ | S04- (2 files):

[21:40] <dalek> roast: Repurpose START phaser tests for once blocks

[21:40] <dalek> roast: review: https://github.com/perl6/roast/commit/a3782f84de

[21:41] <dalek> rakudo/nom: 5a49bbf | (Elizabeth Mattijsen)++ | t/spectest.data:

[21:41] <dalek> rakudo/nom: START phaser tests are now once statement block tests

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a49bbf9a9

[21:47] *** dmol left
[21:48] *** xenoterracide joined
[21:48] *** dmol joined
[21:53] *** dmol left
[21:55] *** dmol joined
[22:01] <pmurias> BenGoldberg: re difficulty compiling to .pyc, that depends how much performance we are willing to sacrifice

[22:05] *** dmol left
[22:05] *** dmol joined
[22:13] *** colomon left
[22:19] *** grondilu left
[22:21] *** colomon joined
[22:23] <dalek> roast: 03f1fee | (Elizabeth Mattijsen)++ | S04-statements/once.t:

[22:23] <dalek> roast: Transmogrified the START phaser tests to once block tests

[22:23] <dalek> roast: 

[22:23] <dalek> roast: Unfortunately, the block does not return its final value yet, so those two

[22:23] <dalek> roast: tests are now marked todo.  Will need some help with building the ops in:

[22:23] <dalek> roast:   method statement_prefix:sym<once>($/)

[22:23] <dalek> roast: in src/Perl6/Actions.nqp

[22:23] <dalek> roast: review: https://github.com/perl6/roast/commit/03f1fee4f9

[22:43] *** dmol left
[22:44] *** dmol joined
[22:50] *** fgomez joined
[22:51] *** fgomez left
[22:51] <lizmat> .tell moritz: wrt to $*W and $/ in Perl6 world: maybe we should add $*W and $/ to the trait mod signature?

[22:51] <yoleaux> lizmat: What kind of a name is "moritz:"?!

[22:52] *** fgomez joined
[22:52] <lizmat> .tell moritz wrt to $*W and $/ in Perl6 world: maybe we should add $*W and $/ to the trait mod signature?

[22:52] <yoleaux> lizmat: I'll pass your message to moritz.

[22:54] *** dmol left
[23:01] *** colomon left
[23:03] *** pupoque_ joined
[23:09] <dalek> rakudo/nom: d5523ba | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[23:09] <dalek> rakudo/nom: Add more sensible error messages for unknown attribute/parameter/routine traits

[23:09] <dalek> rakudo/nom: 

[23:09] <dalek> rakudo/nom: Need access to $*W and $/ to make the messages really come out right.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d5523ba9eb

[23:09] <lizmat> aka: $ perl6 -e 'class A { method a is foo {}  }'

[23:09] <lizmat> ===SORRY!===

[23:09] <lizmat> You cannot say 'is foo' in a method declaration.

[23:09] <lizmat> at -e:1

[23:09] <lizmat> ------> 

[23:09] <lizmat>     expecting any of:

[23:09] <lizmat>         rw parcel hidden_from_backtrace

[23:09] <lizmat>         pure default DEPRECATE inlinable

[23:09] <lizmat>         prec equiv tighter looser assoc

[23:10] <lizmat> and on that note, I bid you all a good night!

[23:12] <timotimo> :)

[23:13] *** colomon joined
[23:23] *** pmurias left
[23:26] *** kurahaupo left
[23:42] *** ecocode left
[23:43] *** ecocode joined
[23:47] *** ecocode left
[23:51] *** kurahaupo joined
