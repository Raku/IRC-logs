[00:08] *** vmspb left
[00:11] *** Tene_ joined
[00:11] *** Tene_ left
[00:11] *** Tene_ joined
[00:12] *** Tene_ left
[00:20] *** cognominal left
[00:22] *** cognominal joined
[00:27] *** mstwu00 joined
[00:30] *** cognominal left
[00:32] *** cognominal joined
[00:35] *** benabik left
[00:38] *** Vlavv_ left
[00:39] *** benabik joined
[00:41] *** crab2313 joined
[00:46] *** mstwu00 left
[00:51] *** Vlavv_ joined
[00:52] *** BenGoldberg joined
[01:03] *** xinming left
[01:04] *** xinming joined
[01:13] *** benabik left
[01:14] *** arcterus joined
[01:14] *** benabik joined
[01:20] *** arcterus left
[01:20] *** arcterus joined
[01:22] *** simcop2387 left
[01:23] *** simcop2387 joined
[01:24] *** btyler left
[01:27] *** arcterus left
[01:29] *** crazedpsyc left
[01:36] *** aindilis joined
[01:40] <timotimo> bleh. can't sleep.

[01:41] <timotimo> i wonder how much performance can be gained by making sure 'sub foo returns Int { 1 }; sub yoink returns Int { foo() }; my Int $a = yoink()' will only typecheck once (well, in this case it could just typecheck at compile-time, but you know what i mean ...)

[01:42] <timotimo> and i wonder how hard it is to optimize away return type checks in things like 'sub foo returns Int { my Int $a = something; return $a }; because there's crazy things like CALLER::return or something? not quite sure about that.

[01:43] <colomon> worrying about things like that disturbs your sleep, yup.

[01:43] <timotimo> yeah, it does, doesn't it :|

[01:44] <timotimo> also, how much sense does it make to consider making the optimizer add "returns Foo" to subs at optimize-time?

[01:44] <colomon> I was having that problem a few days when I was up north fishing, discovered reading a couple of chapters of Les Miz before bed turned off the busy part of my brain and let me sleep.  :)

[01:45] <timotimo> :)

[01:52] *** btyler joined
[01:53] *** arcterus joined
[01:58] *** kingbeast joined
[01:59] *** arcterus left
[02:06] *** btyler left
[02:26] *** mikemol joined
[02:42] *** fgomez joined
[02:42] *** fgomez left
[02:43] *** fgomez joined
[02:48] *** btyler joined
[03:05] *** raiph joined
[03:26] *** preflex_ joined
[03:26] *** ChanServ sets mode: +v preflex_

[03:28] *** preflex_ is now known as preflex

[03:29] *** BenGoldberg left
[03:35] *** btyler left
[03:45] *** crab2313 left
[03:48] *** btyler joined
[04:02] *** SamuraiJack joined
[04:03] *** xilo left
[04:04] *** cognominal left
[04:05] *** cognominal joined
[04:08] *** pupoque_ joined
[04:09] *** uvtc joined
[04:10] <uvtc> Wow. Exciting doings lately in the Perl 6 world. MoarVM sounds amazing enough, and then I read about plans for Perl 5 integration.

[04:12] <uvtc> Great name too (MoarVM).

[04:13] <TimToady> we're all pretty jazzed

[04:15] *** raiph left
[04:15] *** SamuraiJack left
[04:17] <uvtc> Of course, this is stating the obvious, but it's going to be a major coup when you can demo a Perl 6 program that can make use of a Perl 5 cpan module.

[04:18] <uvtc> Folks are gonna go bananas.

[04:18] <uvtc> IMO

[04:20] <uvtc> :)

[04:23] <mst> I'll go even more bananas when it works vice versa

[04:24] <mst> being able to write one class inside a perl5 program in perl6 would be very interesting as a means to experiment

[04:24] <bonsaikitten> mst: you sick puppy :D

[04:24] * mst is hoping we'll get MoarVM as a CPAN module for that purpose

[04:26] <diakopter> yah

[04:27] <diakopter> see my hague grant proposal for that

[04:27] <diakopter> oh wait, that's what you're talking about..

[04:27] <uvtc> diakopter++   # epic grant proposal

[04:27] <diakopter> well, to be fair, pugs could do a lot of it

[04:28] *** crazedpsyc joined
[04:31] <diakopter> mst: hrm, now I'm having trouble remembering where I detailed the .. oh yeah, my lightning talk at oscon last week

[04:32] <diakopter> it was quite ... lightning-y

[04:32] <mst> I remember us chatting about it in person

[04:32] <diakopter> my memory is so poor :(

[04:32] <mst> or possibly in /msg which I regard as mostly similar

[04:33] <mst> I ... don't really care if you remember when we had the conversation, the important thing is that I enjoyed said conversation and it seemed to be productive

[04:33] <uvtc> diakopter, is there a video of your lightning talk anywhere?

[04:34] <uvtc> (A bunch of those oscon 2013 talks went up very quickly on youtube. High-quality video too.)

[04:36] <diakopter> well, no one was recording them I think

[04:36] <diakopter> (same for Larry's SotO)

[04:36] <diakopter> there was an empty O'Reilly tripod in the center aisle

[04:37] <mst> assuming larry's was what he presented at ::NA it got videod there

[04:37] <diakopter> there was a bit of overlap

[04:37] <TimToady> it wasn't really the same talk, though there was overlap

[04:37] <TimToady> but you'll probably hear the new one in Kiev

[04:38] * diakopter goes to get plane tickets

[04:39] <uvtc> Oh! I'd heard that there was a SotO. AFAIK, there hasn't been one of those in quite a while (?). Is there a transcript of it anywhere? Failing that, are there any slides available?

[04:39] <TimToady> there's been one every year, but not all of them are the sort you put up, live demos and such...

[04:40] * diakopter finally thought of Perl 6's killer app

[04:42] <uvtc> diakopter: Whaddya think?

[04:42] <TimToady> a program for murderers?

[04:45] <diakopter> er

[04:45] <diakopter> oh, I get it.

[04:45] <diakopter> *headdesk*

[04:45] <uvtc> took me a minute too. :)

[04:48] *** fridim_ left
[04:48] *** birdwindupbird joined
[04:53] *** JimmyZ joined
[04:54] <uvtc> FWIW, I'm more interested in seeing a substantial tutorial than a "killer app". I'd think a "killer app" would come later.

[04:56] *** uvtc left
[05:11] *** abnorman left
[05:19] *** lestrrat joined
[05:19] <lizmat> good *, #perl6!   finally a night below 20 degrees (celsius)

[05:19] * lizmat likes shivering for a change, instead of sweating

[05:19] <JimmyZ> good morning, lizmat

[05:20] <lizmat> but later this week, this year's second heatwave :-(

[05:20] <mst> it's briefly hot stupidly hot here too

[05:20] <bonsaikitten> I've been slowly roasted over the last week or two

[05:22] <diakopter> there's zero things you can append to any list of computer-y things: off-by-one errors

[05:29] *** abnorman joined
[05:34] <diakopter> search for dead on http://act.yapc.eu/ye2013/schedule

[05:35] <diakopter> also the one below that one...

[05:35] <diakopter> and the one above it also

[05:35] <diakopter> 3 GFY Perl 6 talks

[05:40] <JimmyZ> http://act.yapc.eu/ye2013/user/1174 \o/

[05:40] <diakopter> heh 480 minute talk.

[05:40] <JimmyZ> 3 talks and 1 hackathon‚Äé

[05:40] <diakopter> lots o words

[05:41] <JimmyZ> Nicholas Clark will attend the hackathon

[05:50] *** rindolf joined
[05:56] <diakopter> heh SFO direct to Paris

[06:01] <TimToady> $ moarvm /dev/tty

[06:01] <TimToady> Could not map file into memory '/dev/tty': Invalid argument

[06:01] <TimToady> hah

[06:06] <TimToady> diakopter: that's 'cause nobody in their right mind flies through CDG :)

[06:06] <TimToady> expect to accidentally end up outside security at least once

[06:06] <lizmat> are things better at LHR ?

[06:07] <TimToady> dunno

[06:07] <bonsaikitten> TimToady: CDG is the better one in Paris

[06:07] <TimToady> that's...not a high recommendation for the other one :)

[06:07] <lizmat> at least at CDG, I can always dream I'm in an Alan Parsons Project album

[06:08] <TimToady> CDG has millions of signs, none of which tell you what you want to know...

[06:08] <diakopter> TimToady: lolz mmap

[06:08] <diakopter> you want to type bytecode?

[06:09] <TimToady> sure, I'm an old-school hacker :)

[06:09] <lizmat> http://en.wikipedia.org/wiki/I_Robot_(album)  "The album cover photo of the band members is of the criss-crossing escalator tubes in the circular Terminal 1 building of Charles de Gaulle airport outside Paris."

[06:10] *** btyler left
[06:10] <bonsaikitten> TimToady: Orly ... it's ... special

[06:10] * lizmat remembers the time she typed in 8086 code by hand

[06:10] <TimToady> one of those escalators silently takes you out of security--I know :)

[06:10] <bonsaikitten> triggers me into full angry german mode so easily!

[06:17] <arnsholt> CDG is a terrible, terrible (terrible!) airport, indeed

[06:17] <arnsholt> But the Alan Parson album is very cool

[06:19] *** FROGGS[mobile] joined
[06:19] <FROGGS[mobile]> o/

[06:22] <lizmat> FROGGS /o

[06:27] <dalek> rakudo/nom: 45e8c45 | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[06:27] <dalek> rakudo/nom: Implement multi-level Hash.categorize, as per spec

[06:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45e8c45735

[06:28] <lizmat> on to write more tests

[06:29] *** iSlug joined
[06:37] *** dmol joined
[06:39] *** raiph joined
[06:42] *** FROGGS[mobile] left
[06:42] *** FROGGS joined
[06:43] <FROGGS> hi lizmat 

[06:43] <lizmat> hi FROGGS!

[06:49] <dalek> roast: 408587e | (Elizabeth Mattijsen)++ | S32-list/classify.t:

[06:49] <dalek> roast: Added multi-level classify test

[06:49] <dalek> roast: review: https://github.com/perl6/roast/commit/408587e6bb

[06:52] *** sqirrel joined
[06:53] <moritz> \o

[06:53] <yoleaux> 29 Jul 2013 21:45Z <lizmat> moritz: 50% of the $*W & $/ problem solved

[06:53] <lizmat> moritz o/

[06:53] <FROGGS> morning moritz 

[06:53] <lizmat> moritz: $*W is already exposed in Perl6 space

[06:55] <moritz> lizmat: because it's a dynamic variable

[06:55] *** ecocode joined
[06:57] <lizmat> an unspecced, implementation dependent one, so I missed it before  :-)

[06:57] *** ecocode left
[07:01] <dalek> roast: e67cf45 | (Elizabeth Mattijsen)++ | S32-list/c (2 files):

[07:01] <dalek> roast: Add multi-level categorize test

[07:01] <dalek> roast: review: https://github.com/perl6/roast/commit/e67cf45c9f

[07:01] <lizmat> breakfast&

[07:13] <labster> o/ #perl6

[07:13] <FROGGS> hi labster 

[07:13] <FROGGS> labster: how are you?

[07:14] <labster> I'm confused... lost in $dayjob code.

[07:14] <FROGGS> lost.... ohh dear

[07:16] <labster> Not lost in any particular way, but well, the main object has 350 attributes in the $self hash.  At least it's a round number :)

[07:16] <bonsaikitten> at least it's not php ;)

[07:16] <labster> And thank goodness for that.

[07:17] <FROGGS> at least you dont have 350 misnamed variables for that

[07:17] * FROGGS hopes the attributes are well named

[07:22] <labster> they're reasonably well named.  It's a megaclass, for sure, but things are reasonably compartmentalized so I'm not too lost.

[07:24] <mst> labster: I tend to try and break things like that out into specific-purpose objects with delegation to maintain the old API

[07:31] *** kaleem joined
[07:44] *** effbiai joined
[07:48] *** crab2313 joined
[07:51] <masak> mornin', #perl6

[07:51] <masak> mst: sounds like the Facade pattern.

[07:51] <lizmat> morning masak!

[07:52] <labster> hi masak!

[07:52] <labster> hi lizmat!

[07:52] <lizmat> hi labster!

[07:53] *** sqirrel left
[07:53] <labster> While I've been distracted, my emails tell me that lizmat++ has been making a million commits lately.

[07:53] <lizmat> the last 30 or so are mine, yes

[07:54] <lizmat> several var traits workish now, once blocks, push slightly faster, classify/categorize much faster and expanded

[07:54] <lizmat> improved error messages

[07:55] <lizmat> weeding of now unspecced features

[07:55] <lizmat> that's what I remember  :)

[08:01] <masak> <diakopter> 3 GFY Perl 6 talks

[08:01] <masak> this may (or may not) mean that p5 people are largely done laughing at us, and are ready to fight us for a while.

[08:02] <masak> of course, you can't really fight people who hug you back all the time :P

[08:02] <hoelzro> morning #perl6

[08:03] <masak> hoelzro! \o/

[08:03] <labster> Well, if they're fighting us, it means they're taking us seriously, which is in a strange way a good sign.

[08:04] <masak> labster: that's what I was (obliquely) referring to.

[08:04] <lizmat> http://www.goodreads.com/quotes/4694-first-they-ignore-you-then-they-ridicule-you-then-they  # must be close to christmas

[08:04] * labster is uncultured.

[08:05] <hoelzro> so I have some...interesting code I would like to get working (based on my experiences with my coursera matrix course): https://gist.github.com/hoelzro/6111122

[08:05] <masak> labster: "First they ignore you. Then they ridicule you. And then they attack you and want to burn you. And then they build monuments to you."

[08:05] <hoelzro> I feel like this can be made to work in Perl 6

[08:05] <hoelzro> but my knowledge of sub circumfix:<...> and such is limited

[08:05] <masak> labster: apparently that is the real quote (according to wikiquote), and it was said by Nicholas Klein in 1918, not Gandhi.

[08:06] <moritz> =begin END

[08:06] <moritz> with that code, it'll compile :-)

[08:06] <JimmyZ> masak: Do you say Jesus?

[08:06] <lizmat> https://gist.github.com/lizmat/6111140  # could someone explain me why that optree is not returning the value of the block ?

[08:06] <hoelzro> moritz: heh

[08:07] <effbiai> masak: i'm "p5 people" and have never laught at you :)

[08:07] <masak> hoelzro: why use commas when you're switching modes completely anyway?

[08:07] <hoelzro> masak: oh, those are left over from an experiment I did

[08:07] <lizmat> FROGGS?  moritz?

[08:07] <masak> effbiai: so that smiley right there, what was that? :P

[08:07] <hoelzro> I would like to remove them if possible =)

[08:08] <masak> effbiai: alternatively, "then you're behind the curve, dude" :P

[08:08] <masak> hoelzro: it's possible.

[08:08] <hoelzro> cool =)

[08:08] <lizmat> context: Actions.nqp, lines 1232 and following

[08:08] <effbiai> well.. i've always wondered when p6 will be released and take over for p5 :)

[08:08] <hoelzro> I was thinking of using circumfix for the |-like characters

[08:08] <effbiai> but then p5 guys started backporting features.. :)

[08:09] <masak> effbiai: d'oh! they shouldn't have done that! :P

[08:09] <masak> effbiai: now there's less reason to switch...

[08:09] <hoelzro> but then I have the problem of "Two terms in a row" when I have a sequence of matrix rows

[08:09] <masak> we should have, I dunno, taken a patent or something.

[08:09] <effbiai> hehe

[08:09] <effbiai> a GPL patent! :>

[08:09] <labster> yes, more software patents are always the solution XD

[08:10] <effbiai> anyway.. is there a roadmap for the p6?

[08:10] <moritz> lizmat: does p6store return the stored value? or void?

[08:11] <lizmat> I have *no* idea, I cat-licensed the code from the former START phaser

[08:11] <labster> did that roadmap that we ever talked about at YAPC:NA ever make it online?

[08:11] <moritz> well, a way to find out is to look at the op definition of p6store, and see if the return value is 'v' or 'p'

[08:11] <lizmat> moritz++

[08:12] <effbiai> labster: oh, you p6 guys also do yet another perl conference? :) shouldn't it be YAP6C? ;)

[08:12] <moritz> effbiai: YAAPC, Yet Another Another Perl Conference :-)

[08:12] <labster> TIMTOWTDYAPC.

[08:12] <effbiai> hehe, that's right

[08:14] <effbiai> what i'd like to see (even if it's nearly impossible) is a module/script/program to translate p5 modules to p6 modules. the biggest reason to stick with p5 is the huge amount of modules

[08:14] *** salv0 joined
[08:14] <labster> The short of what I remember was: get the JVM working (which it does for the most part), and start getting threads flushed out.  And then buffers, and sockets.  While working towards an actual 6.0.0 spec.

[08:14] <mst> effbiai: MoarVM should do interop

[08:14] <labster> I don't know that a full translator will be possible, but through the 'v5' module, you can embed (non-XS) P5 code in Perl 6.

[08:15] <mst> effbiai: which honestly I think is more interesting than translation

[08:15] <moritz> effbiai: that's very utopic. It's much more viable to embed a Perl 5 interpreter in a Perl 6 runtime/compiler

[08:15] <labster> and MoarVM uses libperl and does XS.

[08:15] * moritz should blog about why automatic translation isn't viable

[08:15] <mst> I don't even see it as desirable

[08:15] <mst> an idiomatic perl6 implementation is likely to be noticeably different anyway

[08:16] <masak> aye.

[08:16] <masak> that said, translation would certainly be *possible*, just like PPI is possible.

[08:16] <effbiai> with a p5 interpreter in p6. does that mean p6 will be "backwards compatible"?

[08:16] *** dakkar joined
[08:16] <masak> it just doesn't have a champion.

[08:16] <masak> effbiai: no, just that it can do interop :)

[08:17] <effbiai> http://en.wikipedia.org/wiki/Interpreter_(computing)

[08:17] <effbiai> roger1 :)

[08:17] <effbiai> s/1/!

[08:17] <moritz> masak: I doubt that any translation (which isn't a compilation to perl 6 backend) will be correct enough to be useful

[08:18] <moritz> how would you even start to translate code that uses wantarray()?

[08:19] <masak> you would flag it and say "here, fix this" and give lots of links to how. :)

[08:20] <FROGGS> moritz / lizmat: IMO p6store does not return the value

[08:21] <moritz> then it explains why the block doesn't return a value

[08:21] <FROGGS> moritz / lizmat: that should do https://gist.github.com/FROGGS/6111211

[08:23] <lizmat> checking

[08:25] <FROGGS> lizmat: check the braces, I think I lost one before the QAST::Var that will be returned

[08:26] <lizmat> it compiled so far  :-)

[08:34] <lizmat> alas: Error while compiling block  (source text: "{ once { $var += $x } }"): Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Can only use get_how on a SixModelObject

[08:36] <FROGGS> lizmat: and the QAST::Var.new( :name($sym), :scope('lexical') ) is the last arg to QAST::Stmts and not to the if, right?

[08:37] *** sqirrel joined
[08:37] * FROGGS opens a proper editor

[08:37] <lizmat> the if takes 2, right?  the p6stateinit and the p6store one

[08:38] <lizmat> so yes, it is the last one

[08:38] <lizmat> (i think)

[08:38] <FROGGS> right, p6stateinit is the condition, then comes the statement when true, then optionally the else

[08:38] <hoelzro> masak: to implement my matrix literal, would I need to use a slang? or would infix:<...> and friends be sufficient?

[08:38] <lizmat> (compiling)

[08:38] <FROGGS> lizmat: then my gist is wrong, the QAST::Var should be moved one down

[08:39] <FROGGS> sorry for that

[08:39] <lizmat> ok, will try that  :-)

[08:41] <masak> hoelzro: you would need a slang the size of quoting.

[08:41] <hoelzro> ok

[08:41] * hoelzro needs to learn slangs

[08:42] <masak> they are mostly NYI.

[08:42] <masak> :/

[08:42] <hoelzro> =(

[08:42] <masak> maybe 2014 will see us getting there.

[08:43] <hoelzro> curses

[08:43] <lizmat> don't we consider v5 a slang ?

[08:43] <hoelzro> I was hoping that I could show this off to my coursera class =/

[08:43] <JimmyZ> use v6;

[08:43] <lizmat> hoelzro: seems to me you have an itch :-)

[08:44] <hoelzro> lizmat: I have so many itches, but not enough arms to scratch =)

[08:44] <lizmat> :-)

[08:44] <hoelzro> honestly, if I get some p6 tuits, they'll probably go into tooling/packaging/docs

[08:44] <masak> lizmat: I don't know whether v5 can be (currently) considered a slang. FROGGS may be able to answer that better.

[08:44] <hoelzro> there's a lot of talent going into the compiler

[08:45] <masak> I haven't looked at how it's all wired up. I suspect I'd find it's too "wired up" to be considered a slang.

[08:45] <masak> (as in, it requires internals knowledge you shouldn't needdlness of time)

[08:45] <lizmat> must admit, to think of Perl 5 as a slang of Perl 6, I like the idea

[08:48] <masak> in here, everything is a slang of Perl 6 ;)

[08:48] *** abnorman left
[08:48] <masak> and that's not even us being hubristic -- we're just ambitious.

[08:53] <FROGGS> I think we should discuss how to make slangs properly pluggable in the near future

[08:54] <FROGGS> v5 is a slang somehow, but it goes pretty deep (it is an NQP module that uses Perl 6 internals)

[08:55] <raiph> aiui, all a slang means is you recurse into a different grammar/actions pair with the same world, right?

[08:55] <FROGGS> and I'd think that slangs should be made possible in Perl 6, but this is a lot of work

[08:55] <raiph> and v5 goes beyond just being a slang

[08:55] <FROGGS> raiph: that is my understanding too

[08:55] <FROGGS> raiph: no, why?

[08:56] <FROGGS> it is exactly what you said

[08:56] <raiph> k

[08:56] <masak> I think what raiph and I means is that 'use v5;' currently is a slang through non-userspace means.

[08:57] <masak> in order for us to "have slangs", we should expose those same mechanisms in userspace.

[08:57] <FROGGS> true

[08:57] <FROGGS> but it feels like a slang :o)

[08:58] *** fgomez left
[09:02] <bonsaikitten> do I sense a python module in the near future? ;)

[09:04] <raiph> FROGGS: the slang switch mechanics are pretty much all in https://github.com/rakudo-p5/v5/blob/master/lib/Perl5.nqp right?

[09:04] <arnsholt> tadzik and I mused that an NQP-backed Python would be cool, but I can't think of anyone who'd implement it ATM =)

[09:04] <FROGGS> raiph: and in this hack: https://github.com/rakudo-p5/v5/blob/master/rakudo.patch

[09:05] <FROGGS> raiph: and I'd love to get rid of this hack

[09:06] <FROGGS> so, to make a slang, you make a grammar (already possible), register it, override $*MAIN (hack needed) and provide the actions as well (TBD, because you cant build QAST's right now)

[09:07] *** daxim joined
[09:08] <arnsholt> Macros need a standardised AST API as well, so I guess slangs could hook into the same API?

[09:08] <masak> indeed.

[09:09] <FROGGS> yeah

[09:10] <lizmat> FROGGS: no luck so far, will look at it again when beack from cycling&

[09:10] <FROGGS> lizmat: k, paste a diff if you want us/me to play with it

[09:12] <tadzik> arnsholt: surely someone who needs to learn python well, right? :)

[09:12] * tadzik hides

[09:15] <FROGGS> *g*

[09:16] <masak> heh.

[09:16] <masak> incidentally, I'm putting together a Python course for $dayjob as we speak.

[09:16] <masak> not willing to take on a Python implementation project, though ;)

[09:17] <FROGGS> ++masak, well volunteered :o)

[09:18] <tadzik> maybe just implement junctions?

[09:18] <masak> haha

[09:25] <nwc10> which version(s) of Python does $dayjob like to use?

[09:25] *** fhelmberger joined
[09:25] <raiph> masak: does it make sense to port your macro approach to NQP?

[09:27] <JimmyZ> NQP really needs constant 

[09:34] <masak> raiph: I'm pretty sure it's possible -- at least I don't see an actual technical blocker.

[09:34] <masak> raiph: I'm not so sure it's a good idea.

[09:41] <mathw> The idea of a Python-on-NQP is interesting, apart from it being Python :)

[09:41] <mathw> Not Quite Python?

[09:48] <tadzik> BRACES

[09:51] <masak> I just remembered a stray thought from the hazy hinterland between waking and sleep: we should totally refer to infix:<~> and prefix:<~> as "smooth operator" :P

[09:56] <arnsholt> =D

[09:58] *** raiph left
[10:16] <mathw> heh

[10:16] <mathw> I think my C#

[10:16] <mathw> compiler has a time machine in it

[10:17] <masak> oh?

[10:18] <mathw> Actually

[10:18] <mathw> I just figured out it doesn't

[10:18] <mathw> it's a bug in my code

[10:18] <masak> was gonna say.

[10:18] <mathw> weird interaction of two routines

[10:18] <masak> that sounded like a rather extraordinary claim.

[10:18] <mathw> thank goodness for that, I thought my understanding of the C# object model might've been completely wrong

[10:18] <masak> now, if you had said "GHC has a time machine in it"... :P

[10:19] <mathw> lol

[10:19] <mathw> you'd've believed me

[10:19] <mathw> yeah this is an algorithmic problem. The question is... how to fix it

[10:28] <colomon> masak++ # smooth

[10:39] *** crab2313 left
[10:45] *** pupoque_ left
[10:46] *** pupoque_ joined
[10:55] *** SamuraiJack joined
[11:03] *** kingbeast left
[11:03] *** SamuraiJack_ joined
[11:07] *** SamuraiJack left
[11:18] *** grondilu joined
[11:18] <grondilu> rn: say i**2

[11:18] <camelia> rakudo 45e8c4: OUTPUT¬´-1+1.22460635382238e-16i‚ê§¬ª

[11:18] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´-1+1.2246063538223773E-16i‚ê§¬ª

[11:19] * grondilu wonders why there is a floating point approximation here :/

[11:21] <moritz> in case of doubt, read the source

[11:22] <masak> grondilu: because exponentiation of complex numbers is kinda tricky, and even though in this case it could be reduced to repeated multiplication, currently it isn't?

[11:22] *** SamuraiJack_ left
[11:23] <moritz> ah right, it's implemented by going to polar coordinates, doing the exponentation on the magnitude and multiplying the angle, and going back to cartesian coordinates afterwards

[11:24] <moritz> (which is the only sane way to do it in the general case)

[11:24] <moritz> nr: say i * i

[11:24] <grondilu> masak, moritz: yes indeed it seems exponentiation is always treated as exp(n*log(x))

[11:24] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´-1+0i‚ê§¬ª

[11:25] <grondilu> multi postfix:<**>(Complex z, Int n) { [*] z xx n }  # maybe this would be better?

[11:25] <masak> grondilu: at least up to a certain N.

[11:26] <masak> at least for non-negative $n :)

[11:26] <moritz> grondilu: for small N, and it should use a more clever evaluation scheme

[11:26] <moritz> if you do  z ** 5, you can implement that as

[11:26] <moritz> z2 = z * z; z4 = z2 * z2; z**5 = z4 * z

[11:26] <grondilu> indeed

[11:27] <moritz> (don't know what it's called in the literature)

[11:27] <moritz> and you have to be careful not to introduce other floating-point inaccuracies

[11:29] * grondilu thinks it's called ethiopian multiplication

[11:29] <grondilu> http://rosettacode.org/wiki/Ethiopian_multiplication

[11:29] * grondilu is not sure it's exactly the same, though.

[11:30] <masak> I'm pretty sure Knuth spends some time on this in TAoCP.

[11:31] <moritz> well, Ethopian multiplication uses addition to implement multiplication

[11:31] <moritz> we want the same thing, but using multiplication to implement powers

[11:31] <grondilu> call it ethiopian exponentiation, then :-)

[11:31] <masak> yeah, see "4.6.3. Evaluation of Powers"

[11:32] <arnsholt> My lecturers called it fast exponentiation I think

[11:32] <masak> it's ancient: before A.D. 400, according to Knuth.

[11:33] <grondilu> so, would it add more floating-point inaccuracies?

[11:33] <moritz> who knows?

[11:33] <grondilu> isn't it discussed in Knuth's book?

[11:33] <arnsholt> Off the cuff, I'd argue for less, since there are fewer floating point operations involved

[11:38] <masak> grondilu: in your i**2 case above, it would be exact.

[11:38] <masak> grondilu: in the general case, I don't know.

[11:40] <grondilu> I very much think it would be exact for any z = a+b*i where a  and b are integers.

[11:41] <moritz> the more interesting question is usually what happens when one of the numbers is small compared to the other

[11:41] *** pmurias joined
[11:42] <arnsholt> Knuth doesn't seem to address the question of precision, nor really consider floating point at all

[11:42] <arnsholt> AFAICT all of his discussion is for ints

[11:42] <masak> arnsholt: Knuth considers precision at length in the first book.

[11:43] <arnsholt> Ah, right

[11:43] <arnsholt> That would explain the absence in the exponentiation bit

[11:44] <grondilu> precision is not really the issue here.  I mean, there should not be floating point approximation when exponentiation a complex with integer real and imaginary parts, with an integer exponent.  We should never have to use floating points for this.

[11:45] <grondilu> s/when exponentiation/when exponentiating/

[11:48] * grondilu just checked 1i**2 in octave and got an exact -1

[11:49] <grondilu> rn: say (7-6i)**5

[11:49] <camelia> niecza v24-88-g1f87209: OUTPUT¬´-61312.999999999978+26033.999999999993i‚ê§¬ª

[11:49] <camelia> ..rakudo 45e8c4: OUTPUT¬´-61313+26034i‚ê§¬ª

[11:49] *** dayangkun joined
[11:49] <grondilu> hum, for some reason rakudo gives the exact answer, here.

[11:50] *** dayangkun left
[11:50] <arnsholt> I think we'd have to add an "integral complex" type to be able to make the kind of distinction you want

[11:50] <arnsholt> Internally, Complex has $.re and $.im, both native nums

[11:51] <moritz> grondilu: maybe the stringification just rounds

[11:51] <moritz> r: printf '%25f', ( (7-6i)**5 ).re

[11:51] <camelia> rakudo 45e8c4: OUTPUT¬´            -61313.000000¬ª

[11:51] <moritz> r: printf '%.25f', ( (7-6i)**5 ).re

[11:51] <camelia> rakudo 45e8c4: OUTPUT¬´-61312.9999999999781721271574497¬ª

[11:52] <moritz> there you go

[11:52] <masak> grondilu: Rakudo shows slightly less precision, something like two decimals less. that seems to be the difference here.

[11:52] <grondilu> r: printf '%.25f', ( [*] (7-6i) xx 5 ).re

[11:52] <camelia> rakudo 45e8c4: OUTPUT¬´-61313.0000000000000000000000000¬ª

[11:53] <grondilu> I don't think the fact that $.im and $.re are natives is to blame.

[11:53] <moritz> no, it's the same thing as before

[11:53] <arnsholt> Not the native part, but the num part

[11:54] <arnsholt> It's not possible to tell whether the components are integral or not

[11:55] <grondilu> their value tells it, doesn't it?  I mean, I think what screws everything is the systematic use of the logarithm, that's all.

[11:56] <grondilu> the z**n = exp(n*log(z)), that is.

[11:57] <grondilu> we should not use this when n is integer.  Instead use ethiopian exponentiation.  It does not have to depend on $.im or $.re being integer or not.

[11:57] <moritz> grondilu: then please write the patch.

[11:57] <grondilu> ok I'll try

[11:58] <masak> I'm in http://act.yapc.eu/ye2013/t-shirt/index.html -- the obvious option is "Perl 6", but I'm wondering if I should pick any of the others... :)

[11:58] <masak> I'm not picking "Perl 7", JFYI.

[11:58] <nwc10> rn: use perl or die;

[11:58] <camelia> niecza v24-88-g1f87209: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'or' used at line 1‚ê§‚ê§Died‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/1ZWyWNkcGu line 1 (ANON @ 2) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0)  at /tmp/1ZWyWNkcGu line 1:‚ê§------> [32muse perl or die‚Ä¶

[11:58] <camelia> ..rakudo 45e8c4: OUTPUT¬´===SORRY!===‚ê§‚ê§¬ª

[11:58] <tadzik> too many choices

[11:58] <nwc10> it's a syntax error in perl 5 too

[11:58] <tadzik> actually, I think I'd prefer a t-shirt with nothing on the back

[11:59] <tadzik> http://what3words.com/ is so awesome

[11:59] <tadzik> and they have /api too :)

[12:00] * masak goes with an orange "Perl 6"

[12:00] <huf> hm... i'm not sure i find this easier to remember than my actual address

[12:00] <huf> slipped.harder.enhances doesnt exactly roll off the tongue :)

[12:01] <tadzik> it assigns shorter words for densely populated areas

[12:01] <huf> oh i got it wrong, it's actually suffix.resting.horizons

[12:01] <huf> i still prefer eromu u :)

[12:01] <tadzik> it may be LTA sometimes, consider "slipped" vs "slipping" for example

[12:01] <tadzik> and explaining to someone on the phone :)

[12:02] *** SamuraiJack_ joined
[12:02] <tadzik> gps aren't _that_ precise, so you should be able to pick some easy words from around your location

[12:02] <tadzik> esp. since your home is probably more than 9m¬≤ :)

[12:05] *** pupoque_ left
[12:10] <grondilu> rn:  sub f($n is copy where $n > 0) { $n-- }; my $n = 5; f($n); say $n;

[12:10] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´5‚ê§¬ª

[12:11] <grondilu> oh yeah, please ignore this^

[12:11] <masak> "[Git]'s an immensely capable tool, but it gives no guidance regarding the *right* way to do things." -- https://news.ycombinator.com/item?id=4612331 -- I think Perl and Git have this in common: for certain questions, the answer is "let me count the ways", and that really *is* the answer, rather that e.g. Python's "one-- and preferably only one --obvious way to do it".

[12:12] <masak> and that frustrates some people. a lot.

[12:12] <benabik> fish-shell devs linearize history by rebasing all merge requests.  Confuses the heck out of me, but it's a perfectly valid way to use git.

[12:13] <FROGGS> offering something to choose from is the Best Thing(tm), yeah

[12:15] <masak> FROGGS: I think when just learning something, you don't want The Full Story; you want One Way and simplicity.

[12:16] <masak> FROGGS: the second or third time one comes back to a topic, one might want The Full Story. so it's slightly more for experts.

[12:16] <masak> Python is slanted towards beginners. Perl is slanted towards experts.

[12:17] <masak> I often hear people express this as "Perl doesn't sweep complexity under the carpet". I've even said so myself sometimes.

[12:17] *** pupoque_ joined
[12:17] <FROGGS> masak: I'm just thinking about forums where a somebody asks: "how can I do X?", and you dont know if he/she is a n00b or a pro, so you can offer a simple solution, and more advanced ones (and stating them as such)

[12:19] <masak> right.

[12:19] <masak> and the n00b will take the solution above the fold and stop caring about the rest.

[12:19] <moritz> FROGGS: usually (but not always) the style in which the question is asked makes it possible to guess if somebody is familiar with the domain

[12:20] <masak> still, such a solution is "best" under some implied set of default assumptions.

[12:20] <moritz> compare "how do I revert a change" to "How do I revert a change that's {only in my private history,been published already}"

[12:20] <moritz> or even s:2nd/change/commit/

[12:21] <masak> moritz: if you do '!revert' in #git, you get five alternatives.

[12:21] *** skids left
[12:22] <moritz> masak: I know, I'm a #git regular these days

[12:22] <moritz> (and I really wish that channel was properly logged)

[12:23] <pmurias> masak: when comparing python/perl aren't a lot of the underlying differences dictated more by backwards compability rather then the zen of the language

[12:24] <pmurias> masak: especially perl5

[12:24] <nwc10> benabik: curiously, for the perl5 core git we're trying to rebase before merging

[12:24] <nwc10> and *not* doing that confuses me

[12:24] <nwc10> well, OK, I look at the big tangle of lines in git's graph output and think "this could have been simpler"

[12:24] <nwc10> and github is an offender here, by making messes easy, and tidiness harder

[12:26] <benabik> Rebasing puts conflict solving in the branch, instead of in the merge.  Makes it harder to see if someone got the conflicts right.

[12:27] <moritz> nwc10: there's a difference between "rebase before merging" and "only rebasing onto the master branch"

[12:27] <masak> "puts conflict solving in the branch, instead of in the merge"++

[12:27] <masak> benabik++

[12:27] <moritz> and I kinda understood "rebasing all merge pull requests" as the latter, though that might be wrong too

[12:28] *** colomon left
[12:28] <moritz> https://github.com/masak/ufo/pull/7.patch

[12:29] <moritz> wouldn't removing the :test(*) be enough?

[12:29] <moritz> then dir() doesn't return . and .. anymore

[12:29] <nwc10> benabik: I don't have enough direct examples to assess that either way, but I'm not convinced. In that, a merge is a single commit. Whereas resoving the conflicts by re-working the branch doesn't lump all the fixup into one place.

[12:29] <arnsholt> There was a git-power-tools presentation linked on HN last week or something that started with "Git [...] makes no goddamn sense"

[12:29] <benabik> I rebase my own branches a lot.  Breaking them into small units, collapsing together bits that fix earlier errors, etc.

[12:29] <nwc10> but, I don't have enough examples/experience to be sure I'm right or wrong.

[12:29] <arnsholt> Sums of part of my opinion of Git quite nicely =)

[12:29] <masak> pmurias: not sure what you mean by "dictated more by backwards compatibility".

[12:30] <masak> arnsholt: Git makes a whole lot of sense.

[12:30] <masak> arnsholt: that's not to say that the APIs or porcelain commands are always perfect. but the underlying model pretty much is.

[12:30] <timotimo> moritz: i think you're right

[12:30] <benabik> nwc10: Rebasing generally involves a lot of automatic conflict resolution, which is less obvious and not always right.  Granted, in this particular case there's generally nobody else working on that part of the code.

[12:30] <arnsholt> Well, the data model and functionality makes sense, yes. The UI that exposes it is largely a giant mess

[12:31] <nwc10> aha yes, automatic conflict resolution.

[12:31] <arnsholt> It seems we're more or less in agreement =)

[12:31] <pmurias> masak: a lot of things in perl5 are the way they are because of compability concerns

[12:31] <moritz> it's a jungle of hysterical raisins!

[12:31] <moritz> (I meant the git UI, but it also applies to p5 internals :-)

[12:33] <pmurias> masak: some of them were introduced when p5 was a different language, other are that way to work better with existing features

[12:33] <masak> moritz: actually, I think the git subcommands and their parameters have evolved quite nicely over the years. there are "old" and sometimes deprecated parameter names, but that's about it.

[12:33] <moritz> masak: IMHO they are too implementatio centric (more)

[12:33] <masak> pmurias: that's one reason there are many ways -- but I think TIMTOWTDI goes far beyond that reason.

[12:34] <moritz> masak: for example new users often expect to change branches with 'git branch'

[12:34] <pmurias> masak: aren't there also many ways in python?

[12:35] <moritz> masak: the fact that it's done with 'git checkout' is that happens to modify the working copy -- that's not a very user-centric approach IMHO

[12:38] <moritz> as is the fact that it's the default not to set the upstream when you push a new branch, so the next pull (without arguments) on that branch fails

[12:48] *** mikemol left
[12:48] <masak> pmurias: yes, of course there are many ways. the Zen maxim says "there *should* be one [...] *obvious* way".

[12:49] <masak> pmurias: meaning the ideal is to factor the language (and libraries, and tutorials, etc) so that the One Way is always close at hand.

[12:49] <masak> moritz: agreed, on both points.

[12:50] <masak> moritz: 'git branch NEW' should probably have been more like 'git checkout -b NEW'

[12:53] *** salv0 left
[12:57] <benabik> Well, `git branch NEW` is the degenerate case of `git branch NEW commit`.  And if that second one did a checkout, that would be annoying.

[13:00] <grondilu> well, since you're talking about git.  I've just written a modified version of Complex.pm in a new branch.  I've commited it.  How can how prepare a patch out of it?  I'm not sure how "git format-patch" works :/

[13:01] <benabik> git format-patch <base commit>

[13:01] * benabik often does `git format-patch @{u}`

[13:02] <timotimo> what does u stand for? "upstream"?

[13:02] <benabik> Yeah.

[13:02] <timotimo> cool!

[13:02] <benabik> @{u} is a useful new-ish bit of git syntax.

[13:02] <grondilu> I get no output when I try git format-patch <commit-number>

[13:02] <benabik> It should create 000N-subject.patch files.

[13:03] <grondilu> I don't see any such file :-(

[13:04] * grondilu must have done something wrong

[13:04] <benabik> Oh.  Don't give it the SHA of the commit you want a patch of.  If you give it one commit, it tries to create patches for everything *after* that commit.  (Which is why giving it @{u} is useful

[13:05] <grondilu> oh yeah that's what I was just thinking

[13:06] <benabik> That's definitely an odd one.

[13:07] *** SamuraiJack_ left
[13:08] <grondilu> I will test it a bit more before I post it but here is my first attempt for ethiopian exponentiation:  0001-first-attempt-of-ethiopian-exponentiation.patch

[13:08] <grondilu> oops

[13:08] <grondilu> I meant:  https://gist.github.com/grondilu/6112731

[13:10] <moritz> grondilu: using lazy lists like this is neat, but probably too slow for the setting

[13:10] <grondilu> yeah but it makes it so much easier to write

[13:11] <moritz> I know, but that's not what the setting is optimized for

[13:11] <grondilu> ok

[13:14] <masak> ha ha -- Python also has the "not because I have a shotgun meme", but they spell it "We're all consenting adults here" :D

[13:14] <masak> s/ meme"/" meme/

[13:14] *** PacoAir joined
[13:15] <moritz> so they don't welcome teenagers? :-)

[13:16] * timotimo is unaware of both of these memes

[13:17] *** pupoque_ left
[13:19] <masak> timotimo: you know how Perl 5 object attributes are simply key-value pairs in some blessed hash?

[13:19] <timotimo> mhm

[13:19] <masak> timotimo: that makes them very... writable.

[13:19] <timotimo> ah, hehe.

[13:19] <masak> by strangers.

[13:19] <masak> the two memes are basically saying "we're fine with that, as a community".

[13:20] <timotimo> good point

[13:20] <masak> instead of panicking and adding a "private" keyword.

[13:20] <masak> (which by the way doesn't fit very well with that model, of blessed hashes)

[13:20] <timotimo> .o(and rakudo has nqp:: ops that let you do such things, too ... :) )

[13:21] * timotimo decided to put a bunch of ;1 into the microbenchmarks that end in for loops

[13:21] *** pupoque_ joined
[13:21] <masak> timotimo: my conclusion from thinking this over the past couple years is that you can *get* completely water-tight privacy, kinda... but despite what people *think* they want, they don't actually *want* that.

[13:21] <timotimo> yeah, that's for very, very, very special cases, i think

[13:22] <timotimo> like you have to have really tight sandboxing or something?

[13:22] <timotimo> that kind of thing

[13:22] <masak> it's a constant tension between things like really tight sandboxing and security concerns on the one hand,

[13:23] *** bluescreen10 joined
[13:23] <masak> and things like serialization and initializing the bloody thing in the first place on the other.

[13:23] <masak> there's a p6l thread about this that's actually worth reading.

[13:23] <masak> also, haha:

[13:23] <masak> >>> from __future__ import braces

[13:24] <masak> SyntaxError: not a chance

[13:24] <moritz> just like the in a network, you get the best privacy by cutting that ehthernet cable

[13:24] <grondilu> I have two commits now.  How can I make a patch, "skipping" one of them?

[13:25] <grondilu> ah nevermind, I'll send both I guess.

[13:25] <timotimo> moritz: did you see the sponsored OHM ethernet cables with the builtin firewall?

[13:25] <[Coke]> I tried to duplicate the zavolaj errors in a standalone copy of rakudo yesterday, same box where the daily star build is happening - all of the tests from jnthn's zavolaj repo passed 100%.

[13:25] <masak> grondilu: you rebase interactively.

[13:25] <timotimo> grondilu: git rebase -i origin/foo

[13:25] <masak> grondilu: or you make a new branch and cherry-pick the second.

[13:25] <timotimo> then you can reorder the patches in your text editor, squash them into one or remove one completely

[13:25] <timotimo> get the previous state back with git reflog

[13:25] <moritz> timotimo: http://www.perlmonks.org/images/userincoming/Corion.jpeg?updated=20050708050152

[13:25] <masak> wow, and 'import antigravity' opens http://xkcd.com/353/ in the browser :P

[13:26] <timotimo> :D

[13:26] <grondilu> https://gist.github.com/grondilu/6112872

[13:26] <[Coke]> O_o

[13:27] <timotimo> *** Error in `perl6': free(): invalid pointer: 0x00000000047da650 ***

[13:27] <timotimo> \o/

[13:28] <timotimo> coming from the nqp bigint ops

[13:28] <FROGGS> :/

[13:29] <moritz> that's not too hard to do

[13:29] <moritz> just pass something in which isn't actually a bigint

[13:29] <timotimo> hmm

[13:29] <timotimo> fwiw, "./bench fetch" caused this when fetching perl5

[13:31] <masak> grondilu: nice.

[13:31] <masak> grondilu: I still think there's a danger in allowing arbitrarily large integers there, though.

[13:31] <masak> grondilu: imagine n being 1_000_000_000

[13:32] <masak> oh, I guess the log behavior makes that not as bad...

[13:33] <grondilu> yep, it should be fine as we do successive divisions by two

[13:33] <grondilu> should be tried, though.

[13:34] <grondilu> nobody wants to raise a complex number with integer real or imaginary parts to such a big exponant, anyway.

[13:34] <timotimo> wouldn't that quickly get into a range where floats are really, really imprecise?

[13:36] <timotimo> https://rt.perl.org/rt3//Ticket/Display.html?id=115390 - wow, this crash is *weird*

[13:39] <masak> Python's view on operator associativity has no notion of "chaining infix", and yet that's how it's == and < operators behave semantically.

[13:39] <timotimo> ah!

[13:39] <timotimo> i was able to golf it.

[13:40] <grondilu> a slightly shorter version (with $z is copy), and from the nom branch:  https://gist.github.com/grondilu/6112994

[13:40] *** sqirrel left
[13:41] <timotimo> https://rt.perl.org/rt3/Ticket/Display.html?id=115390 - what thinketh the experts?

[13:41] <masak> grondilu++

[13:41] <grondilu> masak: you're right, though.  For instance with (0.001+0.002i)**1000, it's definitely better to use exp(n*log(z))

[13:42] <masak> timotimo++ # nicely done.

[13:42] <timotimo> r: say (^20).map: { (^10).pick(3).min }

[13:42] *** sqirrel joined
[13:42] <camelia> rakudo 45e8c4: OUTPUT¬´2 4 1 1 1 1 0 1 1 0 1 0 1 0 1 1 2 0 1 1‚ê§¬ª

[13:42] <masak> timotimo: this tells me there's a memory leak/double free in 'but'

[13:42] <timotimo> is it in but, though? or maybe someone's being too clever with the Int and trying to treat Int+Bool as Int?

[13:43] <masak> maybe.

[13:43] <timotimo> r: for ^30 { 100 but True }

[13:43] <camelia> rakudo 45e8c4:  ( no output )

[13:43] <masak> I'd look at 'but', though :)

[13:43] <timotimo> r: for ^30 { 100 but True; 1 }

[13:43] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)¬ª

[13:43] <timotimo> r: for ^30 { 100 but "Hi"; 1 }

[13:43] <camelia> rakudo 45e8c4: OUTPUT¬´(signal SEGV)¬ª

[13:43] <timotimo> r: for ^30 { 100 but 100; 1 }

[13:43] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)¬ª

[13:43] <timotimo> r: 100 but "hundred"; 100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";100 but "hundred";

[13:43] <camelia> rakudo 45e8c4:  ( no output )

[13:44] <timotimo> can't seem to get it to crash without a for aroun dit

[13:44] <GlitchMr> but True?

[13:44] <masak> timotimo: that also doesn't surprise me.

[13:45] <GlitchMr> wow, and I through I won't crash Rakudo so stupidly.

[13:45] <benabik> r: for ^2 { 100 but 100; 1 }

[13:45] <camelia> rakudo 45e8c4:  ( no output )

[13:45] <timotimo> you?

[13:47] <benabik> r: for ^7 { 1 but 1; 1 }

[13:47] <camelia> rakudo 45e8c4:  ( no output )

[13:47] <benabik> r: for ^8 { 1 but 1; 1 }

[13:47] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)¬ª

[13:47] <grondilu> rn: say (1+2*pi/1000*i)**1000

[13:47] <GlitchMr> Why I haven't noticed that issue is with 'but'.

[13:47] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1.0199349143075758-8.4329693743204293E-05i‚ê§¬ª

[13:47] <camelia> ..rakudo 45e8c4: OUTPUT¬´1.01993491430758-8.43296937432043e-05i‚ê§¬ª

[13:47] <benabik> That seems to be the limit.  for ^7 succeeds, for ^8 fails.  8 manual iterations still works.

[13:48] *** konundra joined
[13:48] <grondilu> masak: (about ethiopian exp) I just checked and it seems to work just as well, actually

[13:48] <GlitchMr> 0 but True is valid Perl, right?

[13:48] <GlitchMr> Perl 6*

[13:49] <masak> grondilu: \o/

[13:49] <FROGGS> r: for ^8 { 1 but 1; 1 }

[13:49] <camelia> rakudo 45e8c4:  ( no output )

[13:49] <masak> GlitchMr: yes -- why do you ask?

[13:49] <FROGGS> r: for ^8 { 1 but 1; 1 }

[13:49] <camelia> rakudo 45e8c4: OUTPUT¬´(signal SEGV)¬ª

[13:49] <FROGGS> weird

[13:49] <GlitchMr> I was thinking I perhaps should've used something else while implementing run(), but...

[13:49] <FROGGS> a heisenbug -.-

[13:49] <FROGGS> at least something like that

[13:49] <GlitchMr> Actually, perhaps that's good. Otherwise, issue with 'but True' would be found way later.

[13:50] <timotimo> right.

[13:50] <timotimo> i don't think it's your fault at all

[13:50] <masak> GlitchMr: see https://perl6advent.wordpress.com/2010/12/19/day-19-false-truth/

[13:50] <masak> GlitchMr: yes, it's good that it was found.

[13:50] <timotimo> r: my $i = 0; while $i < 20 { 10 but "ten"; $i++; }

[13:50] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)¬ª

[13:50] <GlitchMr> It looked like "0 but true" (Perl 5) for me, and it worked, so I used it.

[13:52] <masak> GlitchMr: no-one is blaming you for using it :)

[13:53] <GlitchMr> I through run() was already fixed, but I guess not.

[13:54] <masak> though I may start to make you personally responsible for misspelling "I thought" as "I through" :(

[13:54] <timotimo> "fixed"? also, run says it's NYI on non-parrot, but shell below is implemented in terms of the new-ish nqp::shell; can that be made to work on jvm, too?

[13:54] <timotimo> no, probably really shouldn't be9~

[13:56] <GlitchMr> I don't understand how Perl 6 and NQP works, but it's surely some lowlevel issue.

[13:56] <GlitchMr> Except double free() would show *glibc detected double free or corruption() * with glibc, so probably not.

[13:57] <timotimo> *** Error in `perl6': free(): invalid next size (fast): 0x000000000fea6450 *** - i think it's memory corruption that shines through in a random error further down the line.

[13:57] <GlitchMr> *** glibc detected *** perl6: free(): invalid next size (fast): 0x0d1e1a38 ***

[13:57] <timotimo> perhaps casting a value to a wrong type and operating on that?

[13:58] <GlitchMr> 08ea6000-0c8ae000 rw-p 00000000 00:00 0                                  [heap]

[13:58] <GlitchMr> It seems that it always points to heap.

[13:58] <timotimo> how is that in that range?

[13:58] <GlitchMr> (not that it really matters)

[13:58] <timotimo> d comes after c :)

[13:58] <timotimo> r: say 0x0d1e1a38 ~~ 08ea6000..0c8ae000

[13:58] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/U7gQCF9cnW:1‚ê§------> [32msay 0x0d1e1a38 ~~ 08[33m‚èè[31mea6000..0c8ae000[0m‚ê§    expecting any of:‚ê§        whitespace‚ê§Other potential difficulties:‚ê§    Leading 0 does not indicate octal in Perl 6; please use 0o8 if y‚Ä¶

[13:58] <GlitchMr> Yeah, sorry, pasting different error messages

[13:59] <timotimo> er, oops

[13:59] <timotimo> r: say 0x0d1e1a38 ~~ 0x08ea6000..0x0c8ae000

[13:59] <FROGGS> #0  0x00007ffff7617037 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56

[13:59] <camelia> rakudo 45e8c4: OUTPUT¬´False‚ê§¬ª

[13:59] <GlitchMr> *** glibc detected *** perl6: free(): invalid next size (fast): 0x0c172a20 ***

[13:59] <GlitchMr> 08912000-0c322000 rw-p 00000000 00:00 0                                  [heap]

[13:59] *** skids joined
[13:59] <timotimo> that's better

[13:59] <FROGGS> that might be the same heisenbug [Coke] and me discovered in april on feather in S02-types/bool.t

[13:59] *** kaare_ joined
[14:00] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but !$val); 1 }

[14:00] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§¬ª

[14:00] *** dakkar left
[14:00] <FROGGS> timotimo: you get a backtrace when you do: gdb --args perl6 -e 'for ^3000 { 1 but 1; 1 }'

[14:00] <GlitchMr> for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but True); 1 }

[14:00] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but True); 1 }

[14:00] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§¬ª

[14:00] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but False); 1 }

[14:00] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§¬ª

[14:00] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but "42"); 1 }

[14:00] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§¬ª

[14:00] <timotimo> #5  0x00007ffff03e481f in gc_free (interp=0x60f050, obj=0xeb4e6e0) at P6opaque.c:908

[14:01] <GlitchMr> "42" doesn't look like boolean.

[14:01] *** dakkar joined
[14:01] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = (^10).pick(3).min but 88); 1 }

[14:01] <timotimo> so something's incorrectly marked or swept?

[14:01] <camelia> rakudo 45e8c4: OUTPUT¬´(signal SEGV)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§¬ª

[14:01] <GlitchMr> This isn't related to Bool type.

[14:01] <timotimo> yeah, seems to be just the but operator

[14:02] <GlitchMr> r: for 1..1000 -> $i { say $i; my $error = (my $val = 44 but 88); 1 }

[14:02] <timotimo> perhaps there's a reference to the thing that's but'd, but it's not being made clear to the gc?

[14:02] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§12‚ê§¬ª

[14:02] <GlitchMr> Or even it isn't related to .pick.

[14:02] <timotimo> it isn't related to pick, aye

[14:02] <GlitchMr> r: for 1..1000 -> $i { say $i; my $val = 44 but 88; 1 }

[14:02] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§¬ª

[14:02] <timotimo> it was to emulate run without running anything

[14:02] <GlitchMr> r: for 1..1000 -> $i { say $i; 44 but 88; 1 }

[14:02] <camelia> rakudo 45e8c4: OUTPUT¬´(signal SEGV)1‚ê§2‚ê§3‚ê§4‚ê§¬ª

[14:02] <timotimo> but clearly it doesn't have to have any special value at all

[14:03] <GlitchMr> It even can be in sink context.

[14:03] <GlitchMr> r: for 1..1000 -> $i { say $i; my @array = 44 but 88; 1 }

[14:03] <camelia> rakudo 45e8c4: OUTPUT¬´(signal SEGV)1‚ê§2‚ê§3‚ê§4‚ê§¬ª

[14:03] <GlitchMr> r: for 1..1000 -> $i { say $i; 44 but 88; }

[14:03] <camelia> rakudo 45e8c4: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§12‚ê§13‚ê§14‚ê§15‚ê§16‚ê§17‚ê§18‚ê§19‚ê§20‚ê§21‚ê§22‚ê§23‚ê§24‚ê§25‚ê§26‚ê§27‚ê§28‚ê§29‚ê§30‚ê§31‚ê§32‚ê§33‚ê§34‚ê§35‚ê§36‚ê§37‚ê§38‚ê§39‚ê§40‚ê§41‚ê§42‚ê§43‚ê§44‚ê§45‚ê§46‚ê§47‚ê§48‚ê§49‚ê§50‚ê§51‚ê§52‚ê§53‚ê§54‚ê§55‚ê§56‚ê§57‚ê§58‚ê§59‚ê§60‚ê§61‚ê§62‚ê§63‚ê§64‚ê§65‚ê§66‚ê§67‚ê§68‚ê§69‚ê§70‚ê§71‚ê§72‚ê§73‚ê§74‚ê§75‚ê§76‚ê§77‚ê§78‚ê§79‚ê§80‚ê§81‚ê§82‚ê§83‚

[14:03] <GlitchMr> ok

[14:03] * grondilu add written where n > 0:  https://gist.github.com/grondilu/6113160

[14:04] <grondilu> ahh I meant "had", not "add"

[14:06] *** pupoque_ is now known as pupoque

[14:07] <GlitchMr> I dunno about something else

[14:07] <GlitchMr> r: for 1..1000 -> $i { say $i; for 1 { 44 but 88 }; 1 }

[14:07] <camelia> rakudo 45e8c4: OUTPUT¬´(signal ABRT)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§¬ª

[14:07] <GlitchMr> r: for 1..1000 -> $i { say $i; for 1 { 44 but 88 } }

[14:07] <masak> grondilu: does your patch cover the case of n == 0 ? :)

[14:07] <GlitchMr> Interesting.

[14:07] <camelia> rakudo 45e8c4: OUTPUT¬´(timeout)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§12‚ê§13‚ê§14‚ê§15‚ê§16‚ê§17‚ê§18‚ê§19‚ê§20‚ê§21‚ê§22‚ê§23‚ê§24‚ê§25‚ê§26‚ê§27‚ê§28‚ê§29‚ê§30‚ê§31‚ê§32‚ê§33‚ê§34‚ê§35‚ê§36‚ê§37‚ê§38‚ê§39‚ê§40‚ê§41‚ê§42‚ê§43‚ê§44‚ê§45‚ê§46‚ê§47‚ê§48‚ê§49‚ê§50‚ê§51‚ê§52‚ê§53‚ê§54‚ê§55‚ê§56‚ê§57‚ê§58‚ê§59‚ê§60‚ê§61‚ê§62‚ê§63‚ê§64‚ê§65‚ê§66‚ê§67‚ê§68‚ê§69‚ê§70‚ê§71‚ê§72‚ê§73‚ê§74‚ê§75‚ê§76‚ê§77‚ê§78‚ê§79‚ê§80‚ê§81‚ê

[14:07] <masak> if not, I have a wonderful optimization to sell you.

[14:08] <FROGGS> five euros, that's all

[14:08] <huf> what is 44 but 88 supposed to be?

[14:11] <masak> Python also has a .perl equivalent, but it spells it circumfix:<` `>

[14:12] <PerlJam> .oO( Python will output Perl code?!? )

[14:12] <PerlJam> good morning all

[14:12] <PerlJam> (or whatever your local daylight/awakedness convention happens to be)

[14:13] *** pmurias left
[14:13] *** woosley left
[14:13] <FROGGS> hi PerlJam 

[14:14] <[Coke]> r: my $a = 44 but 88 ; say $a; say $a/2;

[14:15] <camelia> rakudo 45e8c4: OUTPUT¬´44‚ê§22‚ê§¬ª

[14:15] <[Coke]> huf: not much, apparently. :)

[14:15] <[Coke]> r: my $a = 44 but "88" ; say $a; say $a/2;

[14:15] <camelia> rakudo 45e8c4: OUTPUT¬´88‚ê§22‚ê§¬ª

[14:15] <masak> PerlJam! \o/

[14:16] <masak> PerlJam: I guess I'm getting so used to natural transformations that saying "equivalent" for that one doesn't even feel strange. ;)

[14:16] <timotimo> masak: people will tend to flip out at you if you write it as circumfix:<` `> though

[14:16] <timotimo> at least IME

[14:16] <masak> timotimo: I think it's a wonderful syntax.

[14:16] *** woosley joined
[14:16] <timotimo> me, too

[14:16] <timotimo> made me quite sad to hear people tell me to never do that again :(

[14:16] <masak> timotimo: if I use `...`, people won't know whether to look at the `` or the ...

[14:17] <masak> timotimo: I've never been told that.

[14:17] <PerlJam> timotimo: who are these "people" of which you keep referring?

[14:17] <masak> and if I were, I would likely not listen.

[14:17] <FROGGS> I understood circumfix:<` `> fwiw :o)

[14:17] <timotimo> PerlJam: don't remember who that was, pretty long ago

[14:18] <timotimo> masak: i meant to say "if you write `foo` instead of repr(foo)"

[14:19] <masak> timotimo: oh!

[14:20] <masak> timotimo: you were talking about the quotes themselves, not describing them with the 'circumfix:' syntax.

[14:20] <masak> timotimo: meh -- I don't care about that either.

[14:20] <timotimo> yes, i realize now how unclear i was being

[14:20] <masak> though maybe to be a functioning member of the Python community you have to listen to all the crap people say about your code.

[14:21] *** shinobicl left
[14:22] <tadzik> people are funny

[14:22] <PerlJam> When I hung out on #python regularly a decade or so ago, they were all really reasonable.  And oddly (to me), lisp/scheme seemed to have a strong influence there.

[14:23] <PerlJam> But then #python may not have been indicative of the "Python community" either

[14:24] <masak> hard to say.

[14:24] <hoelzro> you know what they say: a few bad apples spoil the bunch.

[14:25] <masak> r: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is not 42

[14:25] <camelia> rakudo 45e8c4: OUTPUT¬´True‚ê§¬ª

[14:25] <masak> \o/

[14:25] <masak> infix operators made of multiple words! how appaling! :D

[14:25] <timotimo> but "is" is something different from == in python

[14:25] <[Coke]> masak;... now extend that to support "5 is not null"! ;)

[14:25] <masak> timotimo: aye; just testing.

[14:25] <PerlJam> masak: the circumfix of that op is more linquistically interesting  :)

[14:25] <PerlJam> (assuming it works)

[14:26] <masak> r: sub circumfix:<is not>($x) { $x }; say is 42 not; say "alive"

[14:26] <camelia> rakudo 45e8c4: OUTPUT¬´42‚ê§alive‚ê§¬ª

[14:26] <masak> w... wow.

[14:26] <masak> r: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is‚ê§‚ê§‚ê§‚ê§‚ê§not 42

[14:26] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/F53gsZZTEL:1‚ê§------> [32mx:<is not>($l, $r) { $l !== $r }; say 5 [33m‚èè[31mis[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        statement end‚ê§        state‚Ä¶

[14:27] <timotimo> .u ‚ê§

[14:27] <yoleaux> U+2424 SYMBOL FOR NEWLINE [So] (‚ê§)

[14:27] <masak> apparently, arbitrary whitespace doesn't work too well.

[14:27] <[Coke]> wouldn't you need to escape it with a \ ?

[14:28] <FROGGS> r: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is  not 42 # looks like it must match exactly

[14:28] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/_lcw3pFrm2:1‚ê§------> [32mx:<is not>($l, $r) { $l !== $r }; say 5 [33m‚èè[31mis  not 42 # looks like it must match ex[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-inf‚Ä¶

[14:28] <FROGGS> r: sub infix:<is  not>($l, $r) { $l !== $r }; say 5 is  not 42 # looks like it must match exactly

[14:28] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/OqlaZ3pkKe:1‚ê§------> [32m:<is  not>($l, $r) { $l !== $r }; say 5 [33m‚èè[31mis  not 42 # looks like it must match ex[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-inf‚Ä¶

[14:28] <GlitchMr> Nope

[14:28] <FROGGS> ohh

[14:28] <GlitchMr> r: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is                  not 42

[14:28] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/kWAcO43JPJ:1‚ê§------> [32mx:<is not>($l, $r) { $l !== $r }; say 5 [33m‚èè[31mis                  not 42[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        sta‚Ä¶

[14:28] *** pupoque left
[14:28] <GlitchMr> Actually, that's strange.

[14:28] <GlitchMr> Last time I've done that, it worked.

[14:28] <FROGGS> r: sub infix:<is                     not>($l, $r) { $l !== $r }; say 5 is not 42 # looks like it must match exactly

[14:28] <GlitchMr> n: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is                  not 42

[14:28] <camelia> rakudo 45e8c4: OUTPUT¬´True‚ê§¬ª

[14:28] <camelia> niecza v24-88-g1f87209: OUTPUT¬´True‚ê§¬ª

[14:29] <GlitchMr> But perhaps it's because I checked it with Niecza

[14:29] <FROGGS> I believe it splits the name by space when declaring it, and joins it later by one when using it

[14:29] <GlitchMr> I know I once implemented <not in> operator in Perl 6, and it worked, even as '$elem     not           in        @array'

[14:30] <masak> there's a possible rakudobug in here, methinks.

[14:30] <masak> what *should* be the expected behavior?

[14:30] <GlitchMr> std: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is                  not 42

[14:30] <camelia> std c2215f0: OUTPUT¬´ok 00:00 48m‚ê§¬ª

[14:30] <GlitchMr> STD finds it fine

[14:30] <masak> I'm kinda partial to Niecza's behavior.

[14:30] <GlitchMr> std: ssay 5 is                  not 42

[14:30] <camelia> std c2215f0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/QizMY7oTfX line 1:‚ê§------> [32mssay 5 [33m‚èè[31mis                  not 42[0m‚ê§    expecting any of:‚ê§   feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Undeclared routine:‚ê§   

[14:30] <camelia> ..'ssay‚Ä¶

[14:30] <GlitchMr> std: say 5 is                  not 42

[14:30] <camelia> std c2215f0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/1rFvv3wCt2 line 1:‚ê§------> [32msay 5 [33m‚èè[31mis                  not 42[0m‚ê§    expecting any of:‚ê§    feed_separator‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:00

[14:30] <camelia> ..4‚Ä¶

[14:30] *** xilo joined
[14:30] <masak> r: sub infix:<is not>($l, $r) { $l !== $r }; say 5 is                  not 42

[14:30] <GlitchMr> is not is fine in STD

[14:30] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/bWaezNw5ua:1‚ê§------> [32mx:<is not>($l, $r) { $l !== $r }; say 5 [33m‚èè[31mis                  not 42[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        sta‚Ä¶

[14:30] * masak submits rakudobug

[14:30] <GlitchMr> So I assume STD is correct.

[14:31] *** pupoque_ joined
[14:32] <masak> yeah, me too.

[14:32] <GlitchMr> I still think that Niecza has better parsers.

[14:32] <GlitchMr> (but Rakudo has lots of improvements lately)

[14:34] *** kaleem left
[14:35] <masak> GlitchMr: Niecza's parser was closely based on STD.pm6 from the start.

[14:35] <masak> GlitchMr: Rakudo's parser is older than STD.pm6 -- at least in some sense.

[14:36] <GlitchMr> Makes sense.

[14:36] <masak> it has been converging as its grammar engine has evolved to support all the cool things STD.pm6 does.

[14:37] *** Psyche^ joined
[14:39] <dalek> features: 0fd8397 | (Konrad Borowski)++ | features.json:

[14:39] <dalek> features: Rakudo already has threads (but only in JVM)

[14:39] <dalek> features: review: https://github.com/perl6/features/commit/0fd8397404

[14:39] <grondilu> masak: (about the case n==0)  No it does not.  I assumed it was handled somewhere else.

[14:40] <grondilu> rn: say 0**0

[14:40] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´1‚ê§¬ª

[14:40] *** Psyche^_ left
[14:41] <GlitchMr> Why many programming languages define 0**0 to be 1?

[14:42] <grondilu> you think it should be 0?

[14:42] <GlitchMr> What about exception?

[14:42] <benabik> Wolfram says (indeterminate)

[14:42] <masak> it's not really well-defined, no.

[14:42] <masak> because x**0 and 0**x have different limits.

[14:43] <PerlJam> GlitchMr: Because anything raised to the 0th power is 1!  ;)

[14:43] <grondilu> Numberphile, "Problems with zero":  https://www.youtube.com/watch?v=BRRolKTlF6Q

[14:43] <GlitchMr> http://en.wikipedia.org/wiki/0%5E0#Zero_to_the_power_of_zero

[14:43] <GlitchMr> Actually, it seems that Wikipedia has some explanation.

[14:44] <PerlJam> GlitchMr: also, it's *way* simpler to pull that out than to explain why 0**0 is problematic

[14:44] <GlitchMr> Yeah, I know that 0 ** x = 0, and x ** 0 = 1.

[14:44] * masak likes the set-theoretic one

[14:44] <PerlJam> yeah!  See? Wikipedia agress with me  "interpreting 00 as 1 simplifies formulas and eliminates the need for special cases in theorems"

[14:44] <masak> I hadn't heard about that one before.

[14:45] <GlitchMr> What about 0**0 == 0&1 in Perl.

[14:45] <GlitchMr> Perl 6*

[14:45] <masak> "According to Knuth (1992), it '*has* to be 1'" -- that settles it.

[14:45] <masak> GlitchMr: no.

[14:45] <PerlJam> masak++ 

[14:49] <masak> rn: multi infix:<**>(0, 0) { 0 & 1 }; say 0 ** 0 + 5

[14:49] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´all(5, 6)‚ê§¬ª

[14:49] <masak> GlitchMr: if you want to, you can do that in your own code.

[14:49] <masak> GlitchMr: but I don't see why you went with '0 & 1' instead of, say '0 ^ 1'.

[14:50] <GlitchMr> Actually, that's interesting.

[14:50] <GlitchMr> Using multi infix:<**>(0, 0) to define what you want 0 ** 0 to be.

[14:51] <masak> that's why Perl 6 includes a pony.

[14:51] <masak> you get what you wish for.

[14:51] <masak> rn: multi infix:<+>(40, 2) { "SURPRIIIISE!" }; say 40 + 2

[14:51] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´SURPRIIIISE!‚ê§¬ª

[14:52] <grondilu> multi infix:<**>(0, 0) { NaN }  # I'd write it like this.

[14:52] <masak> grondilu: but it's two numbers! :P

[14:52] <GlitchMr> > multi infix:<**>(0, 0) { "forty two" }

[14:52] <GlitchMr> sub infix:<**>(Int , Int ) { ... }

[14:52] <GlitchMr> > 0 ** 0

[14:52] <GlitchMr> forty two

[14:52] <masak> oh, that's where my 42 went...

[14:52] <GlitchMr> It's undefined behavior.

[14:52] <GlitchMr> (in C)

[14:53] <masak> rn: multi infix:<**>(0, 0) { "monkeys fly out GlitchMr's nose!" }; say 0 ** 0

[14:53] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´monkeys fly out GlitchMr's nose!‚ê§¬ª

[14:53] <masak> sweet.

[14:53] <masak> you're right, that *is* pretty undefined.

[14:53] <GlitchMr> So it could as well return pointer to (const char*) "forty two"

[14:54] <GlitchMr> Or destroy memory. Or format your harddrive. Or do nothing.

[14:55] <masak> are we still talking about this? monkeys already flew out your nose.

[14:55] <PerlJam> r: multi infix:<**>(0, 0) { 1 but "it's complicated" }; say 0 ** 0;

[14:55] <camelia> rakudo 45e8c4: OUTPUT¬´it's complicated‚ê§¬ª

[14:55] <masak> PerlJam: :P

[14:55] <grondilu> multi infix:<**>(0, 0) { 0|1 } 

[14:55] <grondilu> :-)

[14:55] <masak> neither & | or ^ strike me as more attractive than the others.

[14:56] <GlitchMr> r: multi infix:<**>(0, 0) { 0 ** 0 }; say 0 ** 0

[14:56] <masak> junctions are simply the wrong tool here -- *again*.

[14:56] <camelia> rakudo 45e8c4: OUTPUT¬´(timeout)¬ª

[14:57] <masak> r: sub term:<‚ä•>() { ‚ä• }; multi infix:<**>(0, 0) { ‚ä• }; 0 ** 0

[14:57] <grondilu> seriously though, it should raise an error.  Just as with division by zero.

[14:57] <camelia> rakudo 45e8c4: OUTPUT¬´maximum recursion depth exceeded‚ê§current instr.: 'print_exception' pc 105635 (src/gen/CORE.setting.pir:46715) (src/gen/CORE.setting:10075)‚ê§called from Sub 'term:<‚ä•>' pc 13 ((file unknown):574) (/tmp/GJiSAlO_wC:358)‚ê§called from Sub 'term:<‚ä•>' pc 32 ((file unknown):5‚Ä¶

[14:57] <masak> grondilu: Wikipedia argues otherwise.

[14:59] <GlitchMr> NaN?

[15:00] <grondilu> been proposed above but people don't seem to like it

[15:00] <PerlJam> 0 ** 0 == 1 is the most useful interpretation

[15:03] *** konundra left
[15:07] <masak> GlitchMr, grondilu: oh, were you under the impression we were still discussing whether to change 0 ** 0 to be something else? sorry about that.

[15:07] <GlitchMr> But even when 0 ** 0 is defined, what about -0e0 ** -0e0?

[15:08] <masak> what about it?

[15:08] <masak> Perl 6 doesn't really have a notion of negative zero.

[15:08] <GlitchMr> rn: say -0e0 ** -0e0

[15:08] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´-1‚ê§¬ª

[15:08] <PerlJam> GlitchMr: precedence.

[15:08] <masak> rn: say (-0e0) ** -0e0

[15:09] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´1‚ê§¬ª

[15:09] <GlitchMr> Oh, right

[15:10] *** sqirrel left
[15:10] <PerlJam> I have a nice pavlovian response there, but I still can't seem to *anticipate* the precedence problem.  Maybe I just need to work with numbers in Perl 6 more.

[15:12] *** PacoLinux joined
[15:19] <moritz> fwiw perl 5 has the same relative precdences in these cases

[15:19] <grondilu> rn: my $n = 5000; say (1+2*pi/$n*i)**$n

[15:19] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1.0039556416172764-3.32041567015014E-06i‚ê§¬ª

[15:19] <camelia> ..rakudo 45e8c4: OUTPUT¬´1.00395564161728-3.32041567015014e-06i‚ê§¬ª

[15:19] *** FROGGS left
[15:22] <masak> PerlJam: the precedence problem isn't due to wrong design in the precedence table, it's due to conflicting use cases.

[15:22] <PerlJam> aye.

[15:26] *** colomon joined
[15:32] * TimToady blames the mathematicians, and the non-mathematicians

[15:33] * grondilu made his first pull request on rakudo :-) https://github.com/rakudo/rakudo/pull/188

[15:34] *** shinobicl joined
[15:38] <masak> grondilu: how about making a new pull request with one commit, instead of a commit and an oops commit? :)

[15:38] <masak> git makes this quite straightforward, when you know how.

[15:38] <TimToady> and quite crookedforward, when you don't :)

[15:39] <masak> (basically 'git rebase -i origin/nom', then squash the second commit into the first by changing s/pick/squash/ on the second line)

[15:40] <arnsholt> Or just commit --amend

[15:40] <grondilu> I've been doing this pull request from the github Web interface, for once.  So it's different.

[15:41] <grondilu> (but I guess I can clone it locally now)

[15:41] <colomon> masak: perl 6 certainly does have a notion of negative zero

[15:43] <colomon> I had to fix support for it in JVM a few weeks ago.

[15:44] <colomon> rn: say 1 / -Inf

[15:44] <camelia> rakudo 45e8c4: OUTPUT¬´-0‚ê§¬ª

[15:44] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´0‚ê§¬ª

[15:44] <colomon> ugb, nieczabug

[15:44] <colomon> ugh

[15:44] *** sidus joined
[15:45] *** kaleem joined
[15:47] <grondilu> there is no second line when I run git rebase -i origin/nom.  There's only a noop.  I don't understand this thing at all :/

[15:48] <moritz> is your local branch two commits ahead of origin/nom?

[15:51] * TimToady wonders whether ¬´...¬ª should be taught to recognize embedded [...] for subarrays...

[15:52] <masak> colomon: oh! this is news to me. could you point me to the relevant part of the spec where negative zero is introduced or mentioned?

[15:52] *** kaleem left
[15:52] <colomon> masak: dunno if it's mentioned in the spec at all, but it's part of the ISO standard floating point specification, which Num follows

[15:52] <colomon> it's definitely in roast

[15:52] <masak> TimToady: that feels too magical for me. what's your use case?

[15:53] <masak> colomon: ah, yes.

[15:53] <TimToady> support for things like http://irclog.perlgeek.de/perl6/2013-07-30#i_7387249

[15:53] <TimToady> only without the commas

[15:53] <masak> colomon: IEEE 754.

[15:53] <colomon> masak: that's the one

[15:53] <TimToady> actually, thinking more like a Q option

[15:54] <masak> colomon: then I see what you mean. and yes, then Perl 6 has a notion of negative zero.

[15:54] <TimToady> a literal form for matrices without commas

[15:55] <TimToady> though I don't think we should reuse the angles for that

[15:55] <TimToady> the corner angles, I mean, but I suppose you can say the same for the ¬´...¬ª etc

[15:57] <TimToady> should probably use the composing square bracket chars instead, starting at U+23A1

[15:57] <TimToady> .u ‚é°

[15:57] <yoleaux> U+23A1 LEFT SQUARE BRACKET UPPER CORNER [Sm] (‚é°)

[16:01] <masak> /o\

[16:01] * TimToady wonders if we can parse them a little like heredocs, to allow expressions containing matrices to continue on the same line

[16:02] <masak> IMHO, we're far beyong the line where returns have diminished and Perl 6 shouldn't provide this, modules should.

[16:02] <masak> beyond*

[16:02] <TimToady> sure, just thinking about how it would actually best fit into the language at that point

[16:02] <masak> ok, phew.

[16:02] * masak de-panics a bit

[16:03] <TimToady> mostly just thinking "are we missing something needed to support such things"

[16:04] *** pupoque_ left
[16:04] <colomon>  TimToady: only way to really know is to implement a module and see.  ;)

[16:05] <TimToady> the notion of multi-line objects embedded in single lines is...interesting...especially if you allow such an object to protrude in both directions, unlike heredocs, which only protrude downwards

[16:06] <TimToady> you'd need specialized characters like ‚é° to introduce such an object unambiguously

[16:06] <TimToady> "save this up for the corresponding object located below it"

[16:07] <TimToady> definition of "corresponding" being somewhat...negotiable...

[16:07] *** pupoque_ joined
[16:08] <TimToady> okay, I've got to the mental position of the mathematician in the burning bed who says "It can be proven" and falls back asleep.  :)

[16:08] <masak> :)

[16:08] <masak> for the record, that mathematician is also an idiot...

[16:08] <[Coke]> "was"

[16:09] <masak> :P

[16:09] <[Coke]> what, I'm agreeing with you! ;)

[16:09] <TimToady> .oO(No programming language ever failed by underestimating the intelligence of the general public of mathematicians...)

[16:10] <masak> [Coke]: oh, the ':P' was just "I thought was amusing", not "prrrrrrft!"

[16:11] <masak> in Python, loops can have 'else' clauses. what were they thinking?

[16:13] <masak> (the semantics being that if you exit the loop by falling out of the last iteration (rather than 'break'-ing out of the loop earlier), you end up in the 'else' clause.)

[16:13] <benabik> LAST phaser?

[16:13] <masak> hm, at first glance, yes.

[16:14] <[Coke]> r: for 1..10 -> $a { say $a } else { note "eek" };

[16:14] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/v9aCF7aaOs:1‚ê§------> [32mfor 1..10 -> $a { say $a } [33m‚èè[31melse { note "eek" };[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loop‚ê§        h‚Ä¶

[16:14] <flussence> The one time I've ever found a foreach/else useful is in HTML templates.

[16:14] <[Coke]> r: for 1..10 -> $a { say $a } or { note "eek" };

[16:14] <masak> rn: for reverse 1..10 { LAST { say "liftoff!" }; .say }

[16:14] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/iLMUClxBEV:1‚ê§------> [32mfor 1..10 -> $a { say $a } [33m‚èè[31mor { note "eek" };[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifier loop‚ê§        hor‚Ä¶

[16:14] <camelia> rakudo 45e8c4: OUTPUT¬´10‚ê§9‚ê§8‚ê§7‚ê§6‚ê§5‚ê§4‚ê§3‚ê§2‚ê§1‚ê§liftoff!‚ê§¬ª

[16:14] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method statement_prefix:LAST not yet implemented at /tmp/OHCpwFV1kE line 1:‚ê§------> [32m reverse 1..10 { LAST { say "liftoff!" }[33m‚èè[31m; .say }[0m‚ê§‚ê§Unhandled exception: Unable to resolve method statement_level i‚Ä¶

[16:14] <TimToady> historically, we do that with 'last OUTERLOOP;'--now is someone would only *implement* that...

[16:14] <masak> TimToady: 'OUTERLOOP'?

[16:15] <benabik> while/else makes more sense to me than for/else.  While/else is just an if that iterates until it hits the else branch.

[16:15] <TimToady> named loops

[16:15] <masak> ah.

[16:15] <masak> benabik: troo.

[16:15] <masak> benabik: it even reads well. kinda.

[16:16] <benabik> masak: "kinda reads well" sums up a lot of corners of Python

[16:16] <benabik> (IMNSHO)

[16:16] <masak> Python: it kinda reads well.

[16:16] <benabik> My biggest gripe with working with python was actually that I couldn't use % to jump to the end of blocks in Vim.

[16:17] <benabik> (Or to the top from the end.

[16:18] <masak> huh, 'try' has an 'else' too. like our 'default'.

[16:19] <moritz> in a completely unrelated matter, does anybody want a hotkey (like 'l' or 'r') for the "look for new lines" in the IR clogs?

[16:19] <TimToady> you could use 'orelse' on a try

[16:20] <TimToady> std: try { whatever() } orelse give'em-heck()

[16:20] <PerlJam> moritz: r for "reload" would be nice

[16:20] <camelia> std c2215f0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routines:‚ê§        'give'em-heck' used at line 1‚ê§  'whatever' used at line 1‚ê§Check failed‚ê§FAILED 00:00 44m‚ê§¬ª

[16:20] <TimToady> heh

[16:20] <diakopter> TimToady: I was griping the other day when having to use special return values (or special exception values) from subs in order to go to the next iteration of some loop a few calls back in the callstack. is there some other way to "next" to a named loop in the dynamic context?

[16:20] <moritz> should "work" the same without curlies, no?

[16:20] <diakopter> I've had to do that in every language I've used

[16:21] <moritz> huh? perl 5 does that

[16:21] <diakopter> orly

[16:21] <diakopter> <- pretty uninformed

[16:21] <moritz> in "next 'label'", the label is dynamically scoped

[16:21] <diakopter> O_O

[16:21] <geekosaur> labeled loops, next LABEL;

[16:21] <diakopter> same in p6?

[16:21] *** crab2313 joined
[16:21] <moritz> I've abused that to emulate non-local reeturns

[16:21] <TimToady> S04:70

[16:21] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_70

[16:22] <moritz> diakopter: I think so, but rakudo doesn't implement it

[16:22] <grondilu> weird:

[16:22] <diakopter> ohh

[16:22] <grondilu> rn: sub ethiop($z is copy, $n) { [*] gather for $n, * div 2  ...^ 0 { take $z unless $_ %% 2; $z *= $z } }; say ethiop(1i,  2);

[16:22] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1+0i‚ê§¬ª

[16:22] <camelia> ..rakudo 45e8c4: OUTPUT¬´-1+0i‚ê§¬ª

[16:22] <diakopter> TimToady: okay. actually, I've read this before, but didn't connect it with the actual use case I've needed for some reason. ergh.

[16:23] <TimToady> .u ·ç©

[16:23] <yoleaux> U+1369 ETHIOPIC DIGIT ONE [No] (·ç©)

[16:23] <TimToady> surely that should be using ethiopic digits...

[16:23] <masak> r: constant ·ç© = 1; say ·ç©i

[16:23] <camelia> rakudo 45e8c4: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing initializer on constant declaration‚ê§at /tmp/o9YjKqe5kq:1‚ê§------> [32mconstant [33m‚èè[31m·ç© = 1; say ·ç©i[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§¬ª‚Ä¶

[16:24] <masak> r: sub term:<·ç©> { 1 }; say ·ç© * i

[16:24] <camelia> rakudo 45e8c4: OUTPUT¬´0+1i‚ê§¬ª

[16:24] <masak> imaginary Ethiopian number.

[16:24] <grondilu> rn: sub ethiop($z is copy, $n) { [*] gather for $n, * div 2  ...^ 0 { take $z unless $_ %% 2; $z *= $z } }; say ethiop(1i,  2); # why do niecza return 1 here?

[16:24] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1+0i‚ê§¬ª

[16:24] <camelia> ..rakudo 45e8c4: OUTPUT¬´-1+0i‚ê§¬ª

[16:25] <grondilu> rn: say 2, * div 2 ...^ 0

[16:25] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´2 1‚ê§¬ª

[16:26] <grondilu> rn: say [*] -1

[16:26] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´-1‚ê§¬ª

[16:26] <grondilu> rn: sub ethiop($z is copy, $n) { [*] gather for $n, * div 2  ...^ 0 { say $z; take $z unless $_ %% 2; $z *= $z } }; say ethiop(1i,  2); # why do niecza return 1 here?

[16:27] <camelia> niecza v24-88-g1f87209: OUTPUT¬´0+1i‚ê§-1+0i‚ê§1+0i‚ê§¬ª

[16:27] <camelia> ..rakudo 45e8c4: OUTPUT¬´0+1i‚ê§-1+0i‚ê§-1+0i‚ê§¬ª

[16:27] *** PacoLinux left
[16:29] <moritz> grondilu: gather/take is one of the slowest control flow constructs in rakudo, and I'm rather sceptic against its use where it's not really required

[16:29] <grondilu> ok

[16:29] <moritz> you can at least make it a grep

[16:30] <moritz> or a while/loop

[16:32] * grondilu is rewriting the thing

[16:33] <moritz> grondilu++

[16:33] <moritz> PerlJam: 'r' for reload now works (after you've reloaded the page once, to get the new JS)

[16:34] <TimToady> 'course, I already have 'r' mapped to reload the whole page; I wonder who will win...

[16:34] <colomon> rn: say 1i * -1

[16:34] <camelia> rakudo 45e8c4: OUTPUT¬´-0-1i‚ê§¬ª

[16:34] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´0-1i‚ê§¬ª

[16:34] <colomon> rakudobug

[16:34] <grondilu> camelia: rn:  https://gist.github.com/grondilu/6114580

[16:34] <camelia> grondilu: niecza v24-88-g1f87209: gist not found

[16:34] <camelia> ..rakudo 45e8c4: OUTPUT¬´-1+0i‚ê§¬ª

[16:35] <colomon> or at least, rakudoweird

[16:35] <TimToady> say what?

[16:35] *** ggoebel joined
[16:36] <[Coke]> r: say 0 * -1;

[16:36] <camelia> rakudo 45e8c4: OUTPUT¬´0‚ê§¬ª

[16:36] <[Coke]> r: say 0+0i * -1;

[16:36] <camelia> rakudo 45e8c4: OUTPUT¬´0+-0i‚ê§¬ª

[16:36] <grondilu> rn: sub ethiop($z is copy, $n is copy) { my $p = 1; until $n == 0 { $p *= $z unless $_ %% 2; $z *= $z; $n div=2 }; return $p }; say ethiop(1i,  2); # why do niecza return 1 here?

[16:37] <camelia> rakudo 45e8c4: OUTPUT¬´use of uninitialized value of type Any in numeric context  in sub ethiop at /tmp/TRIY5DWKbE:1‚ê§‚ê§use of uninitialized value of type Any in numeric context  in sub ethiop at /tmp/TRIY5DWKbE:1‚ê§‚ê§1‚ê§¬ª

[16:37] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´Use of uninitialized value in numeric context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1384 (warn @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 297 (Any.Numeric @ 8) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.s‚Ä¶

[16:37] <grondilu> camelia rn: sub ethiop($z is copy, $n is copy) { my $p = 1; until $n == 0 { $p *= $z unless $_ %% 2; $z *= $z; $n div=2 }; return $p }; say ethiop(1i,  2);

[16:37] <camelia> grondilu: rakudo 45e8c4: OUTPUT¬´use of uninitialized value of type Any in numeric context  in sub ethiop at /tmp/buYyNfxWIr:1‚ê§‚ê§use of uninitialized value of type Any in numeric context  in sub ethiop at /tmp/buYyNfxWIr:1‚ê§‚ê§1‚ê§¬ª

[16:37] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´Use of uninitialized value in numeric context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1384 (warn @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 297 (Any.Numeric @ 8) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.s‚Ä¶

[16:37] <grondilu> sorry, forgot to use /msg

[16:38] <grondilu> rn: sub ethiop($z is copy, $n is copy) { my $p = 1; until $n == 0 { $p *= $z unless $n %% 2; $z *= $z; $n div=2 }; return $p }; say ethiop(1i,  2);

[16:38] <camelia> rakudo 45e8c4, niecza v24-88-g1f87209: OUTPUT¬´-1+0i‚ê§¬ª

[16:38] <grondilu> that's better

[16:39] *** xinming left
[16:40] * masak submits colomon's rakudoweird

[16:40] <masak> colomon: hm. wait.

[16:40] <masak> colomon: I don't see anything wrong with it, actually.

[16:41] <masak> oh, yes, I do.

[16:41] <colomon> well, maybe not

[16:41] <masak> the -0 makes sense for Num, but not for Int, right?

[16:41] *** xinming joined
[16:41] <colomon> masak: it's complex, both parts are num

[16:41] <masak> ok, then no RT ticket.

[16:41] <colomon> but yeah, I think it may well be weird but not wrong

[16:41] <masak> it most it's a bit ugly.

[16:42] <colomon> yeah

[16:43] <moritz> actually -0 makes a lot of sense in rakudo's Int implementation (at least the bigint part)

[16:44] *** dakkar left
[16:44] <diakopter> sigh http://act.yapc.eu/ye2013/t-shirt/index.html

[16:45] <moritz> as a Perl programmer you need to cope with choice :-)

[16:45] *** fhelmberger_ joined
[16:46] <masak> moritz++ # :)

[16:47] <masak> diakopter: I see what's happening as simply people getting fed up with waiting. I can understand that.

[16:48] <masak> diakopter: the "Perl 7" conversation may not be very fulfilling for us, but it's apparently something some people need to get out of their system.

[16:48] <masak> walk &

[16:48] *** fhelmberger left
[16:50] *** fhelmberger_ left
[16:58] *** hoelzro joined
[16:58] *** vk_ joined
[16:59] <grondilu> camelia: rn: sub ethiop($z is copy, $n is copy) { my $p = 1; until $n == 0 { $p *= $z unless $n %% 2; $z *= $z; $n div=2 }; return $p }; my $n = 1_000_000; say ethiop((1+2*pi/$n*i)**$n,  2);

[16:59] <camelia> grondilu: niecza v24-88-g1f87209: OUTPUT¬´1.0000394789777618-1.6537162918112419E-10i‚ê§¬ª

[16:59] <camelia> ..rakudo 45e8c4: OUTPUT¬´1.00003947942187-1.65371629254564e-10i‚ê§¬ª

[17:00] *** sqirrel joined
[17:01] *** sqirrel left
[17:01] *** konundra joined
[17:02] *** autumn left
[17:04] *** spider-mario joined
[17:05] <grondilu> rn: sub ethiop($z is copy, $n is copy) { my $p = 1; until $n == 0 { $p *= $z unless $n %% 2; $z *= $z; $n div=2 }; return $p }; my $n = 1_000_000; my $ethiop = ethiop(1+2*pi/$n*i, $n) ; say (($ethiop - (1+2*pi/$n*i)**$n) / $ethiop).abs

[17:05] *** autumn joined
[17:05] <camelia> rakudo 45e8c4: OUTPUT¬´1.23246311737701e-10‚ê§¬ª

[17:05] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´9.8798351056113124E-11‚ê§¬ª

[17:06] * grondilu is not sure this slight difference should matter^

[17:15] *** pecastro joined
[17:20] *** birdwindupbird left
[17:21] *** raiph joined
[17:34] *** daxim left
[17:36] <[Coke]> man, the jvm run seems slow. :|

[17:37] <[Coke]> wish I had been timing these.

[17:41] <grondilu> rn:  constant n = 1_000_000; say (1+2*355/113/n*i)**n

[17:41] <camelia> rakudo 45e8c4: OUTPUT¬´1.00001973951597+5.33456224443063e-07i‚ê§¬ª

[17:41] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´1.0000197392939187+5.3345622432461212E-07i‚ê§¬ª

[17:43] * grondilu is trying to compare this to https://www.wolframalpha.com/input/?i=%281%2B2*355%2F113%2F1000000*i%29**1000000 to see which method is more accurate.  It's not obvious.

[17:49] <grondilu> rn: constant n = 1_000_000; my $a = 2*pi/n; my $z = cos($a)+sin($a)*i; say $z**n 

[17:49] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1-2.4492127076447545E-16i‚ê§¬ª

[17:49] <camelia> ..rakudo 45e8c4: OUTPUT¬´1-2.44921270764475e-16i‚ê§¬ª

[17:49] <grondilu> ok, with the ethiopian method I get:

[17:49] <grondilu> 0.999999999990103+2.4980018054066e-16i

[17:52] <grondilu> and with n=1_000_000_000 I get:

[17:52] <grondilu> 1.00000004594005-1.38777878078145e-15i

[17:53] <grondilu> so it really does not seem as stable as using exp(n*log(z))

[18:02] <timotimo> is it faster though?

[18:05] *** SamuraiJack_ joined
[18:08] *** gfldex joined
[18:12] *** btyler joined
[18:16] <masak> I'd be surprised if it were.

[18:22] <dalek> perl6-roast-data: 3f05e0e | coke++ | / (5 files):

[18:22] <dalek> perl6-roast-data: today (automated commit)

[18:22] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/3f05e0ef41

[18:22] *** PacoLinux joined
[18:28] *** lawrmcfa joined
[18:31] <grondilu> timotimo: it is quite fast.  I haven't noticed much difference.  Remember that the loop divides $n by two everytime.

[18:32] <colomon> grondilu: if you haven't benchmarked it, all you're saying is it isn't pathetically slow

[18:32] *** PacoLinux left
[18:32] <grondilu> my $z = rand + rand*i; $z /= $z.abs; say $z**1_000_000_000;

[18:33] <grondilu> r:  my $z = rand + rand*i; $z /= $z.abs; say $z**1_000_000_000;

[18:33] <camelia> rakudo 45e8c4: OUTPUT¬´0.780231439064134-0.625490750891914i‚ê§¬ª

[18:35] * grondilu runs time perl6 -e 'my $z = rand + rand*i; $z /= $z.abs; say $z**1_000_000_000;'

[18:35] <grondilu> -0.188683823001716+0.982038021554442i

[18:35] <grondilu> real	0m2.991s

[18:35] <grondilu> user	0m2.688s

[18:35] <grondilu> sys	0m0.226s

[18:35] <grondilu> I can't do the same with nom, as I'd have to recompile

[18:35] <grondilu> realI0m2.991s is with my local modification. 

[18:35] <colomon> coerce 1_000_000_000 to Num.

[18:35] <grondilu> oh yeay

[18:35] <grondilu> real	0m2.924s

[18:35] <grondilu> user	0m2.658s

[18:35] <grondilu> sys	0m0.201s

[18:35] <colomon> but really, you need to do it at least a few hundred times in a loop to get a decent timing,.

[18:35] <grondilu> ok

[18:36] * grondilu runs time perl6 -e 'for ^1000 { my $z = rand + rand*i; $z /= $z.abs; say $z**1_000_000_000.Num; }'

[18:36] <grondilu> 7.679s

[18:36] * grondilu runs time perl6 -e 'for ^1000 { my $z = rand + rand*i; $z /= $z.abs; say $z**1_000_000_000; }'

[18:37] <grondilu> 24.668s  You win, guys :)

[18:37] <TimToady> moritz: re http://irclog.perlgeek.de/perl6/2013-07-30#i_7389078 no, it wouldn't work without the curlies, because try is defined as a statement prefix, and orelse is tighter than that; arguably this could become a FAQ unless we tweak something...

[18:38] <TimToady> but I suspect any tweaks would just move the wat around

[18:40] *** SamuraiJack_ left
[18:45] * lizmat is back from cycling, dinner and backlogging

[18:45] <colomon> o/

[18:45] <lizmat> Q: I'm looking in Grammar for the place it handles "my Int @a"

[18:45] <lizmat> suggestions anyone?

[18:48] <lizmat> or in Actions for that matter

[18:48] <masak> https://twitter.com/yapcrussia/status/362279298612199424 https://twitter.com/yapcrussia/status/362279474278039554

[18:49] <masak> three other "Perl 6" people and I lost out to "Perl 7" :P

[18:49] <masak> though if we can claim the "Rakudo Perl" person, it's actually a tie.

[18:50] <masak> and I suspect t's not over yet.

[18:50] <colomon> grondilu: while I don't think I'd seen this exact problem before, I've seen enough of this sort of thing before to have a feel for the performance characteristics.  ;)

[18:50] <lizmat> masak: since then, at least 2 Perl 6 shirts have been added

[18:50] <lizmat> which would put it in a tie with Future Perl

[18:51] *** crab2313 left
[18:51] *** crab2313 joined
[18:53] <masak> lizmat: \o/

[18:53] <masak> let's overtake "Future Perl". down with Future Perl! oh wait.

[18:57] <lizmat> :-)

[18:57] * masak .oO( "This, dear grand-daughter, is a 'Perl 7' tee from *2013*."  -- "But gramps, how is that possible? lue didn't throw his iPad X against the space elevator until 2040..." )

[18:59] <GlitchMr> http://www.perlmonks.org/?node_id=730203

[18:59] <GlitchMr> And this is from 2008.

[18:59] <PerlJam> masak: no, I think it would still be some sort of coffee recepticle, even in 2040  :)

[19:01] <masak> PerlJam: clearly you haven't seen the iPad X.

[19:02] <[Coke]> the stim patch is a pretty cool feature.

[19:02] <diakopter> "use perl or die" - "you, use perl now, or else I'll kill you" or "I would die if I couldn't use perl"

[19:03] <GlitchMr> irb(main):001:0> use perl or die

[19:03] <GlitchMr> NameError: undefined local variable or method `perl' for main:Object'

[19:03] <GlitchMr> I'm not sure whatever Ruby understands that.

[19:04] <masak> diakopter: given it's a Russian meme, I always assumed the former.

[19:05] <diakopter> hrm

[19:07] <masak> but reading it as actual Perl code (even though it isn't) would suggest the latter interpretation.

[19:07] <[Coke]> gah, everytime I try to use perlmonks I am reminded why I almost never use perlmonks.

[19:12] *** crab2313 left
[19:16] *** raiph left
[19:21] *** zwut00 joined
[19:21] *** zwut00 left
[19:21] *** rindolf left
[19:22] <Util_> #ps in 10m

[19:22] *** rindolf joined
[19:22] *** zwut00 joined
[19:22] *** zwut00 left
[19:23] *** zwut00 joined
[19:23] *** zwut00 left
[19:23] *** zwut00 joined
[19:23] <dalek> rakudo-star-daily: 5832145 | coke++ | log/ (4 files):

[19:23] <dalek> rakudo-star-daily: today (automated commit)

[19:23] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/583214544c

[19:23] *** vk_ left
[19:24] <[Coke]> no change in any of the failures/missing tests.

[19:24] <[Coke]> Is anyone planning an R* soon?

[19:25] * moritz tried the last two months, but never found the time to actually do it, and/or deal with the test failures

[19:26] *** vk_ joined
[19:29] *** aindilis left
[19:33] <[Coke]> moritz: I opened tickets with all the failing distros, fwiw.

[19:34] *** FROGGS joined
[19:36] *** rindolf left
[19:37] *** rindolf joined
[19:38] <labster> Where's my Perl 11 T-shirt?

[19:38] <diakopter> Perl 3 was a while ago

[19:39] <labster> And before that, Perl <3.

[19:47] * masak .oO( those who understand binary, 9 other types, and off-by-one errors )

[19:51] <dalek> rakudo/nom: 85971d0 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[19:51] <dalek> rakudo/nom: Restore List.STORE_AT_POS, because apparently LoL.pm needs that

[19:51] <dalek> rakudo/nom: 

[19:51] <dalek> rakudo/nom: Oddly enough, no tests in the spectest fired because of the absence of this

[19:51] <dalek> rakudo/nom: method.  Seems LoL is undertested.

[19:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85971d0f58

[19:52] <masak> time to write more tests!

[19:53] <frettled> masak++ :)

[19:55] *** kaare_ left
[19:55] *** rindolf left
[19:55] *** rindolf joined
[19:59] <moritz> lizmat: LoL is certainly undertested, because nobody understands it

[19:59] <lizmat> and I thought I was the only one  :-)

[19:59] <moritz> lizmat: maybe with the exception of TimToady and pmichaud, but I even doubt their interpretations match

[20:05] <timotimo> writing code to automate unicode box drawings *and* making sure double and single lines are in makes me very not happy :|

[20:05] <TimToady> LoL may not turn out to be a real type, but it's convenient for talking about the structure of multidimensional slice subscripts

[20:07] <TimToady> or what gets bound to a ** parameter

[20:08] <TimToady> admittedly it's a bit hard to grok, but then, so are surreal numbers, which have a similar structure

[20:08] <TimToady> we will see how this all plays out when S09 gets implemented

[20:09] * timotimo finds out he doesn't know anything about LoLs by thinking he knows enough about them and not being confused

[20:09] <TimToady> Ignorance used to be bliss.  :)

[20:10] <timotimo> "but LoL is just a list of lists! how could it be hard at all?"

[20:10] <moritz> TimToady: I think the "LoL may not turn out to be a real type" is what tripped me so far. It's perfectly find a bind a list of a list to a List, so in the back of my mind I always wondered why we need LoL at all

[20:10] <TimToady> implement List[List] and then we'll talk :)

[20:11] <TimToady> in my mind it's kind of a placeholder, or an alias for List[List] or some such

[20:11] <moritz> but that I don't understand either

[20:11] <moritz> I thought that **@a was just like *@a, except it doesn't flatten

[20:12] <moritz> but that implies that not every element of @a (in the ** case) needs to be a List

[20:12] <TimToady> it's more like Parcel[Parceloid]

[20:12] <TimToady> if a Parceloid is anything that can behave as a parcel, including an item

[20:12] <moritz> .oO( a LoL is actually a PoP! )

[20:12] <TimToady> I usually think of them as "args"

[20:13] <TimToady> since one "arg" is what gets bound to one positional

[20:13] <masak> 'night, #perl6

[20:13] <TimToady> o/

[20:13] * moritz should follow masak's example

[20:14] * TimToady too, but only for a siesta

[20:14] * TimToady wonders what "geezer" is in Spanish...

[20:15] <TimToady> zzz &

[20:16] <lizmat> gnight TimToday, masak!

[20:17] <PerlJam> TimToady: viejo (old man)

[20:18] <PerlJam> or perhaps "anciano"  (ancient man)

[20:27] *** konundra left
[20:28] <PerlJam> my spanish speaking friends sayd "viejito" would be appropriate  :)

[20:37] *** zwut00 left
[20:37] <lizmat> looking at BOOTSTRAP, I see that class ObjAt has no parent ??

[20:38] * lizmat adds Mu as parent

[20:46] *** zwut00 joined
[20:46] *** zwut00 left
[20:51] <lizmat> changes it to Any as parent and spectests again

[20:54] *** bluescreen100 joined
[20:55] *** bluescreen__ joined
[20:56] *** bluescreen10 left
[20:59] *** bluescreen100 left
[21:05] *** skids left
[21:05] <dalek> rakudo/nom: d2ae748 | (Elizabeth Mattijsen)++ | src/core/ (23 files):

[21:05] <dalek> rakudo/nom: Copy/Update class and attribute specification in BOOTSTRAP to each module as doc

[21:05] <dalek> rakudo/nom: 

[21:05] <dalek> rakudo/nom: I hate looking up these things in BOOTSTRAP all the time

[21:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2ae748fac

[21:05] <dalek> rakudo/nom: 92fde30 | (Elizabeth Mattijsen)++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:05] <dalek> rakudo/nom: Fix some documentation errors / missing documentation

[21:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92fde3021d

[21:05] <dalek> rakudo/nom: a7b8f9f | (Elizabeth Mattijsen)++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:05] <dalek> rakudo/nom: Add missing parent specification for ObjAt (now points to Any)

[21:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a7b8f9fb5b

[21:06] <lizmat> and with this, call it a night &

[21:13] * lizmat just notices that src/core/SubMethod.pm contains the class Submethod (not the lowercase m)

[21:13] <lizmat> I can't fix that on my case insensitive but case preserving file system

[21:13] <lizmat> sleep&

[21:18] *** vk_ left
[21:27] <lue> masak: Who decides it's a good idea to give me an Apple¬Æ‚Ñ¢ product in a space elevator in 2040?

[21:28] *** iSlug left
[21:30] *** pupoque_ left
[21:31] *** pupoque_ joined
[21:41] *** lawrmcfa left
[21:45] *** PacoAir left
[21:46] *** ecocode joined
[21:46] *** spider-mario left
[21:51] *** vk_ joined
[22:07] *** dmol left
[22:07] *** BenGoldberg joined
[22:19] *** vk_ left
[22:24] <diakopter> masak: rotfl

[22:29] *** benabik left
[22:39] *** xenoterracide left
[22:40] *** bluescreen__ left
[22:45] *** ecocode left
[22:52] *** benabik joined
[22:56] *** btyler left
[22:58] *** zwut00 joined
[23:08] *** btyler joined
[23:08] *** shinobicl left
[23:22] *** xenoterracide joined
[23:25] *** btyler left
[23:31] *** gfldex left
[23:31] *** gfldex joined
[23:45] *** sidus left
[23:56] *** sidus joined
