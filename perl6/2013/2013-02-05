[00:05] *** Chillance left
[00:19] *** cognominal left
[00:20] <skids> r: sub p (*@a) { a(@a); }; proto sub a (|c) { "dispatcher".say; {*} }; multi sub a (*@a) {sink for (@a) { a($_) }}; multi sub a (Int $i) { }; multi sub a ($a) { $a.perl.say; die("wantedInt"); };a(3); p(3);

[00:20] <p6eval> rakudo 935c90: OUTPUTÂ«dispatcherâ¤dispatcherâ¤[3]â¤wantedIntâ¤  in sub a at /tmp/X1ckBTjz1W:1â¤  in sub a at /tmp/X1ckBTjz1W:1â¤  in sub p at /tmp/X1ckBTjz1W:1â¤  in block  at /tmp/X1ckBTjz1W:1â¤â¤Â»

[00:22] *** Targen joined
[00:27] *** dayangkun joined
[00:42] *** krunen left
[00:43] *** krunen joined
[00:49] *** awwaiid left
[00:55] *** doomrobo joined
[00:56] *** awwaiid joined
[00:58] *** doomrobo left
[01:01] *** Subterra left
[01:05] *** Ayiko joined
[01:06] *** anuby joined
[01:11] <swarley> What is the build chain recommended to build parrot/nqp/rakudo natively under windows?

[01:12] <diakopter> what compiler would you like to use? microsoft?  msvc is the one jnthn and I use on Windows

[01:12] <diakopter> last time I tried gcc/strawberry, I couldn't get it to work for the life of me

[01:13] <diakopter> rurban maintains the cygwin parrot; I bet it works there

[01:19] *** atrodo left
[01:22] *** hypolin joined
[01:39] * benabik has used Strawberry Perl to build Parrot and Rakudo

[01:39] <benabik> (Although not terribly recently, I'll admit.)

[01:40] <skids> r: role A { method a {...} }; role B does A { }; role C does B { method a { "OHAI".say } }; class D does C { }; my D $f .= new(); # OK, as expected

[01:40] <p6eval> rakudo 935c90:  ( no output )

[01:40] <swarley> Im using strawberry perl right now

[01:40] <skids> r: role A { method a {...} }; role B does A { }; # Rakudo seems to want to pun this even when not used

[01:40] <p6eval> rakudo 935c90: OUTPUTÂ«Method 'a' must be implemented by B because it is required by a roleâ¤current instr.: '' pc 24148 (src/gen/perl6-metamodel.pir:10984) (src/gen/Metamodel.pm:2187)â¤called from Sub 'compose_method_table' pc 23943 (src/gen/perl6-metamodel.pir:10913) (src/gen/Metamodel.pâ€¦

[01:41] <swarley> I use strawberry on windows

[01:41] <swarley> I dislike activestate

[01:41] <skids> r: role A { method a {...} }; role B does A { }; 1; # ...but it seems to be due to the final sink context

[01:41] <p6eval> rakudo 935c90:  ( no output )

[01:42] *** mynameis joined
[01:43] <benabik> I think I just used Strawberry and msysgit.  I don't _think_ I needed anything else.

[01:44] <swarley> I'm using powershell and strawberry right now

[01:44] <swarley> lets see how it goes

[01:44] <swarley> tests for parrot seem to be passing

[01:44] <swarley> what is gmake by the way/

[01:45] <benabik> GNU make

[01:45] <swarley> ah

[01:45] <benabik> (usually)

[01:45] <swarley> I've never seen another make.. well cmake

[01:45] <swarley> But I rarely see that used

[01:47] <benabik> There's nmake on Windows and BSD Make.  I've seen other makes on things like Solaris (although they may use GNU now).

[01:47] <benabik> Generally there's no certainty what make is, but gmake is always GNU.

[01:55] <swarley> It fails to build nqp

[01:55] <swarley> /usr/bin/sh: line 0: cd: srcpmc: No such file or directory

[01:55] <swarley> gmake: *** [src\pmc\nqp_group.dll] Error 1

[02:01] <benabik> I'm guessing that the Makefile got src\pmc from somewhere, but Strawberry's make doesn't understand backslashes.

[02:08] <swarley> it works up until that specific one

[02:19] *** FROGGS_ joined
[02:22] *** FROGGS left
[02:48] *** szbalint joined
[02:50] *** Su-Shee left
[02:52] <swarley> Swarley@OcctaviasViolin /cygdrive/c/Users/Swarley/Documents/GitHub/rakudo/nqp/parrot

[02:52] <swarley> $ make install

[02:52] <swarley> ', needed by `src/pmc/addrregistry.o'.  Stop.rot/memory.h

[02:52] <swarley> What kind of error is that??

[02:53] <geekosaur> one with a control-m in the middle

[02:53] <geekosaur> something expecting unix style line endings got a dos line ending instead

[02:56] <swarley> i did `make distclean' and now i get this

[02:56] <swarley> CONST_STRING split across lines at 461 in src/string/api.c

[03:03] *** japhb_ left
[03:06] *** xinming_ left
[03:24] <swarley> nqp: say("hello" ~~ s/l/r/g);

[03:24] <p6eval> nqp: OUTPUTÂ«Divide by zeroâ¤current instr.: '' pc 114 ((file unknown):64) (/tmp/Wi6x2I0hGw:1)â¤Â»

[03:25] <TimToady> n: say("hello" ~~ s/l/r/g);

[03:25] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Unsupported use of suffix regex modifiers; in Perl 6 please use prefix adverbs at /tmp/YPgT99eXie line 1:â¤------> [32msay("hello" ~~ s/l/r/g[33mâ[31m);[0mâ¤Other potential difficulties:â¤  Unsupported use of /g; in Perl 6 â€¦

[03:26] <swarley> r: my $foo = "hello"; $foo ~~ s/l/r/g; say $foo; # Works in perl5 with the equivalent expressions

[03:26] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of /g; in Perl 6 please use :gâ¤at /tmp/5QCHSOy5bW:1â¤------> [32mmy $foo = "hello"; $foo ~~ s/l/r/g[33mâ[31m; say $foo; # Works in perl5 with the eq[0mâ¤Â»

[03:27] <swarley> So.. what should i use instead of /g?

[03:27] <swarley> oh

[03:27] <swarley> :g

[03:28] <swarley> uhm.. How do I use :g?

[03:29] <TimToady> nr: say("hello" ~~ s:g/l/r/);

[03:29] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«Unhandled exception: Writing to readonly scalarâ¤  at /home/p6eval/niecza/lib/CORE.setting line 593 (Cool.subst @ 88) â¤  at /tmp/uCSjS87C3G line 1 (mainline @ 3) â¤  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) â¤  at /home/p6eval/niecza/lib/Câ€¦

[03:29] <p6eval> ..rakudo 935c90: OUTPUTÂ«Cannot assign to a non-containerâ¤  in sub infix:<=> at src/gen/CORE.setting:12434â¤  in block  at /tmp/zpTeDrW8Hf:1â¤â¤Â»

[03:29] <TimToady> nr: $_ = "hello"; s:g/l/r/; .say

[03:29] <p6eval> rakudo 935c90, niecza v24-18-gaf64300: OUTPUTÂ«herroâ¤Â»

[03:30] <swarley> ah

[03:30] <swarley> nqp: my $test := "hello"; $test ~~ s:g/l/r/; say($test)

[03:30] <p6eval> nqp: OUTPUTÂ«Confused at line 2, near "$test ~~ s"â¤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[03:30] * swarley sighs

[03:31] <TimToady> nr: my $test := "hello"; $test ~~ s:g/l/r/; say($test)

[03:31] <swarley> I suppose I'll write my own gsub then

[03:31] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot assign to a non-containerâ¤  in sub infix:<=> at src/gen/CORE.setting:12434â¤  in block  at /tmp/scmR2cMj6Q:1â¤â¤Â»

[03:31] <p6eval> ..niecza v24-18-gaf64300: OUTPUTÂ«Unhandled exception: Writing to readonly scalarâ¤  at /home/p6eval/niecza/lib/CORE.setting line 593 (Cool.subst @ 88) â¤  at /tmp/onm5UnZxNK line 1 (mainline @ 4) â¤  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) â¤  at /home/p6eval/niecza/lib/Câ€¦

[03:31] <TimToady> nr: my $test = "hello"; $test ~~ s:g/l/r/; say($test)

[03:31] <p6eval> rakudo 935c90, niecza v24-18-gaf64300: OUTPUTÂ«herroâ¤Â»

[03:32] <TimToady> nqp doesn't have assignment, so can't actually set a mutable container

[03:32] <swarley> Well, I'm trying to change all occurances of ' (not \') to \'

[03:34] <TimToady> nqp: my $test := "hello"; say $test.subst(/l/, 'r', :g);

[03:34] <p6eval> nqp: OUTPUTÂ«Confused at line 2, near "say $test."â¤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[03:34] <TimToady> nqp: my $test := "hello"; say($test.subst(/l/, 'r', :g));

[03:34] <p6eval> nqp: OUTPUTÂ«Method 'subst' not found for invocant of class 'String'â¤current instr.: '' pc 117 ((file unknown):60) (/tmp/L3neICYvi9:1)â¤Â»

[03:35] * TimToady is not quite an nqp expert

[03:35] <swarley> I would understand if it didn't modify the value

[03:35] <swarley> but it seems odd to be missing to many standard functions

[03:35] *** hulu joined
[03:36] <benabik> NQP is the minimum needed to implement Rakudo, so it's 'missing' alot.

[03:36] <swarley> So I notice

[03:36] * TimToady prefers Perl 6 :)

[03:36] <hulu> helo

[03:36] <hulu> what does 'my @digits = roll 4, 1..9;' mean?

[03:37] <benabik> nqp: subst('hello', /l/, 'r', :global)

[03:37] <p6eval> nqp:  ( no output )

[03:37] <swarley> I like NQP, don't get me wrong. If it was a full implementation of the syntax handling, i'd reinvent the wheel each time i needed it if i needed to

[03:37] <benabik> nqp: say(subst('hello', /l/, 'r', :global))

[03:37] <p6eval> nqp: OUTPUTÂ«herroâ¤Â»

[03:37] <benabik> swarley: ^

[03:37] *** adu joined
[03:37] <swarley> oh thank you benabik 

[03:37] <benabik> ack is your friend.  (Found it with ack subst)

[03:38] <swarley> does that modify the value of the first argument or return a new value?

[03:38] <benabik> Appears to return a new value.

[03:38] <hulu> who can help me

[03:38] <swarley> nqp: my $foo = "bar"; subst($foo, /r/,'z'); say($foo)

[03:38] <p6eval> nqp: OUTPUTÂ«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " \"bar\"; su"â¤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[03:38] <benabik> r: my @digits = roll 4, 1..9; say @digits

[03:38] <p6eval> rakudo 935c90: OUTPUTÂ«3 7 9 5â¤Â»

[03:38] <swarley> nqp: my $foo := "bar"; subst($foo, /r/,'z'); say($foo)

[03:38] <p6eval> nqp: OUTPUTÂ«barâ¤Â»

[03:38] <swarley> Okay, just returns the value

[03:38] <swarley> I should have known that anyway

[03:39] <adu> omg, I just blew my mind

[03:40] <adu> the reason why closures are so powerful is that they're the procedural equivalent of XML

[03:40] <hulu> benabik: what does 'roll' mean?

[03:40] <benabik> hulu: roll is like rolling a die.  roll( N, @list ) returns N random selections from the list  (or more OO: @list.roll(N))

[03:40] <swarley> nqp: my $str = "'hello world'!"; say("'{subst($str, /<!after \\> \'/, "\\'", :global)}'")

[03:40] <p6eval> nqp: OUTPUTÂ«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " \"'hello w"â¤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[03:40] <swarley> nqp: my $str := "'hello world'!"; say("'{subst($str, /<!after \\> \'/, "\\'", :global)}'")

[03:40] <p6eval> nqp: OUTPUTÂ«Could not find sub cuid_1_1360035592.93306â¤current instr.: '' pc 653 ((file unknown):148248208) (/tmp/dtF26ZLVCc:1)â¤Â»

[03:41] <swarley> oh, i need to include QRegex for after i think..

[03:41] * swarley goes to msg

[03:42] <swarley> or maybe not

[03:45] <swarley> nqp: /<!after foo>/

[03:45] <p6eval> nqp:  ( no output )

[03:45] <swarley> okay, so that's not the issue

[03:47] <hulu> benabik: what does '?Exp24' mean?

[03:48] <benabik> hulu: Convert Exp24 to a boolean, although it seems like odd P6 code.

[03:49] *** diakopte1 joined
[03:54] *** wtw left
[03:55] *** xinming joined
[03:55] <swarley> x`Alright, I finally got an answer

[03:55] <swarley> nqp: my $old_str := "'hello \\\'world\\\'!\'"; my $str := subst(subst($old_str, /\\/, "\\\\", :global), /\'/, "\\'", :global); say("'{$str}'")

[03:55] <p6eval> nqp: OUTPUTÂ«'\'hello \\\'world\\\'!\''â¤Â»

[03:56] <swarley> 'hello \'world\'!

[04:06] *** preflex_ joined
[04:07] *** preflex left
[04:07] *** preflex_ is now known as preflex

[04:14] *** viewonly joined
[04:24] *** wtw joined
[04:29] *** sevin joined
[04:34] *** lorn left
[04:35] *** lorn joined
[04:35] *** diakopte1 is now known as diakopter

[04:42] *** lorn left
[04:43] *** lorn joined
[05:01] *** sevin left
[05:06] <hulu> grammar Exp24 {     token TOP { ^ <exp> $ }     token exp { <term> [ <op> <term> ]* }     token term { '(' <exp> ')' | \d }     token op { '+' | '-' | '*' | '/' } }

[05:06] <hulu> what's does '3 + 5' mean?

[05:09] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ }     token exp { <term> [ <op> <term> ]* }     token term { '(' <exp> ')' | \d }     token op { '+' | '-' | '*' | '/' } }; Exp24.parse('3+5');

[05:09] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a rowâ¤at /tmp/p8QSCCsI6F:1â¤------> [32mExp24 {     token TOP { ^ <exp> $ }     [33mâ[31mtoken exp { <term> [ <op> <term> ]* }   [0mâ¤    expecting any of:â¤        statement listâ¤        prefix or termâ¤        prefix orâ€¦

[05:09] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ }     token exp { <term> [ <op> <term> ]* }     token term { '(' <exp> ')' | \d }     token op { '+' | '-' | '*' | '/' } }; ?Exp24.parse('3+5');

[05:09] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a rowâ¤at /tmp/ESj0IW1Gg8:1â¤------> [32mExp24 {     token TOP { ^ <exp> $ }     [33mâ[31mtoken exp { <term> [ <op> <term> ]* }   [0mâ¤    expecting any of:â¤        statement listâ¤        prefix or termâ¤        prefix orâ€¦

[05:10] <hulu> benabik: why â€˜3+5â€™ not parse

[05:10] <mst> hulu: '3 + 5'

[05:10] <mst> perhaps

[05:10] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ }     token exp { <term> [ <op> <term> ]* }     token term { '(' <exp> ')' | \d }     token op { '+' | '-' | '*' | '/' } }; ?Exp24.parse('3 + 5');

[05:10] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a rowâ¤at /tmp/_8yY2nU7zX:1â¤------> [32mExp24 {     token TOP { ^ <exp> $ }     [33mâ[31mtoken exp { <term> [ <op> <term> ]* }   [0mâ¤    expecting any of:â¤        statement listâ¤        prefix or termâ¤        prefix orâ€¦

[05:10] <skids> hulu: when you put things all on one line, curly braces that normally end constructs need a ; after them.

[05:10] <geekosaur> you're not getting that far; it's throwing an error in the middle of your definitions

[05:11] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ } ;    token exp { <term> [ <op> <term> ]* } ;    token term { '(' <exp> ')' | \d };     token op { '+' | '-' | '*' | '/' } ;}; ?Exp24.parse('3 + 5');

[05:11] <p6eval> rakudo 935c90:  ( no output )

[05:11] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ } ;    token exp { <term> [ <op> <term> ]* } ;    token term { '(' <exp> ')' | \d };     token op { '+' | '-' | '*' | '/' } ;}; say ?Exp24.parse('3 + 5');

[05:11] <p6eval> rakudo 935c90: OUTPUTÂ«Falseâ¤Â»

[05:11] <hulu> skids: why not parse

[05:12] <mst> hulu: maybe take back out the spaces I suggested ?

[05:12] <hulu> r: grammar Exp24 {     token TOP { ^ <exp> $ } ;    token exp { <term> [ <op> <term> ]* } ;    token term { '(' <exp> ')' | \d };     token op { '+' | '-' | '*' | '/' } ;}; say ?Exp24.parse('3+5');

[05:13] <p6eval> rakudo 935c90: OUTPUTÂ«Trueâ¤Â»

[05:13] <mst> I misunderstood the problem before, sorry

[05:13] <hulu> thx

[05:13] <skids> tokens are not :sigspace

[05:13] <mst> skids: that was my fault, I misunderstood earlier and suggested the spaces in the string to parse

[05:14] <skids> ah

[05:16] *** adu left
[05:18] *** xinming_ joined
[05:21] *** xinming left
[05:22] *** sevin joined
[05:35] <hulu> repeat while --$b {     .say for "&b($b) on the wall",              b($b),              'Take one down, pass it around',              "&b($b-1) on the wall",              ''; }

[05:36] <hulu> what does '&b($b)' mean

[05:37] <hulu> sub b($b) {     "$b bottle{'s'.substr($b == 1)} of beer"; };repeat while --$b {     .say for "&b($b) on the wall",              b($b),              'Take one down, pass it around',              "&b($b-1) on the wall",              ''; }

[05:37] <hulu> mst: what does '&b($b)' mean?

[05:37] <benabik> hulu: Call sub b with argument $b.  & is the sigil for a function.

[05:38] <hulu> benabik: why not 'b($b)'

[05:38] <benabik> In code you don't generally need the &, but in a string you do.

[05:38] <hulu> benabik: ic

[05:38] <hulu> benabik: thx

[05:38] <benabik> hulu: np

[05:39] *** skids left
[05:46] *** colomon left
[05:57] *** marloshouse left
[05:57] *** marloshouse joined
[05:59] *** colomon joined
[06:05] *** SamuraiJack joined
[06:18] *** Patterner left
[06:19] *** Psyche^ joined
[06:19] *** Psyche^ is now known as Patterner

[06:26] *** FROGGS_ left
[06:26] *** krunen left
[06:37] *** sevin left
[06:38] *** sevin joined
[06:39] *** FROGGS_ joined
[06:39] *** am0c joined
[06:42] *** kaleem joined
[06:46] *** benabik left
[06:47] *** benabik joined
[06:47] *** domidumont joined
[06:51] *** FROGGS_ is now known as FROGGS

[06:52] <FROGGS> morning

[07:00] <moritz> \o morning

[07:00] <FROGGS> nr: my @var = <a b c>; say "b" ~~ / @var /

[07:00] <p6eval> rakudo 935c90: OUTPUTÂ«#<failed match>â¤Â»

[07:00] <p6eval> ..niecza v24-18-gaf64300: OUTPUTÂ«#<match from(0) to(1) text(b) pos([].list) named({}.hash)>â¤Â»

[07:00] <FROGGS> nr: my @var = <a b c>; say "abc" ~~ / @var /

[07:00] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>â¤Â»

[07:00] <p6eval> ..rakudo 935c90: OUTPUTÂ«#<failed match>â¤Â»

[07:01] <FROGGS> nr: my @var = <a b c>; say "abc" ~~ / @var+ /

[07:01] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«#<match from(0) to(3) text(abc) pos([].list) named({}.hash)>â¤Â»

[07:01] <p6eval> ..rakudo 935c90: OUTPUTÂ«#<failed match>â¤Â»

[07:01] <FROGGS> cool

[07:01] *** quester joined
[07:01] <FROGGS> nr: say "abc" ~~ / @( <a b c> )+ /

[07:02] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unrecognized regex metacharacter @ (must be quoted to match literally)â¤at /tmp/nGlhM5uDEJ:1â¤------> [32msay "abc" ~~ / [33mâ[31m@( <a b c> )+ /[0mâ¤Unable to parse regex; couldn't find final '/'â¤at /tmp/nGlhM5uDEJ:1â¤------> [32msaâ€¦

[07:02] <p6eval> ..niecza v24-18-gaf64300: OUTPUTÂ«#<match from(0) to(3) text(abc) pos([].list) named({}.hash)>â¤Â»

[07:03] <FROGGS> array interpolation still doesnt work locally with my changes to nom

[07:03] <FROGGS> only $( ... ) is working

[07:04] <FROGGS> dunno what %( ... ) should do

[07:04] *** alec left
[07:04] *** alec__1 joined
[07:05] <FROGGS> maybe ...

[07:05] <FROGGS> n:  my %var = ( a => b ); say "abc" ~~ / %var<a> /

[07:05] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Only $ and @ variables may be used in regexes for now at /tmp/hVtxku9evh line 1:â¤------> [32my %var = ( a => b ); say "abc" ~~ / %var[33mâ[31m<a> /[0mâ¤â¤Undeclared routine:â¤ 'b' used at line 1â¤â¤Potential difficulties:â¤  Aâ€¦

[07:05] *** domidumont left
[07:05] <FROGGS> n:  my %var = ( a => "b" ); say "abc" ~~ / %var<a> /

[07:05] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Only $ and @ variables may be used in regexes for now at /tmp/ZugQXJyYLI line 1:â¤------> [32m%var = ( a => "b" ); say "abc" ~~ / %var[33mâ[31m<a> /[0mâ¤â¤Potential difficulties:â¤  Apparent subscript will be treated as regeâ€¦

[07:06] <FROGGS> weird

[07:06] *** sevin left
[07:13] *** alec__1 is now known as alec

[07:13] *** sevin joined
[07:17] *** sevin_ joined
[07:18] *** sevin left
[07:21] *** alec is now known as ohrmazd

[07:27] *** xiaoyafeng joined
[07:35] *** ohrmazd is now known as alec

[07:35] *** xiaoyafeng left
[07:38] *** am0c left
[07:38] *** am0c joined
[07:47] <diakopter> .. .. .  ... .  . .  ....  . .  . .  .

[07:51] *** domidumont joined
[07:52] <moritz> iis se ee h e e e e e ?

[07:52] <tadzik> good morning

[07:53] <moritz> good morning tadzik 

[07:55] <sorear> mornign

[07:55] <FROGGS> o/

[07:58] *** krunen joined
[07:58] *** domidumont left
[07:59] *** domidumont joined
[08:05] *** dayangkun left
[08:06] *** dayangkun joined
[08:12] *** quester left
[08:19] *** sevin_ left
[08:20] *** sevin_ joined
[08:21] *** daxim joined
[08:31] *** bruges_ joined
[08:31] *** bruges left
[08:40] *** Pompel joined
[08:40] *** nebuchadnezzar joined
[08:41] *** sorear left
[08:45] *** s0rear joined
[09:01] <tadzik> for you, fellow vim-junkies: https://twitter.com/null

[09:01] <tadzik> er, what

[09:01] *** hoelzro|away is now known as hoelzro

[09:01] <tadzik> that was supposed to be http://valloric.github.com/YouCompleteMe/ :)

[09:04] <hoelzro> tadzik: ah, I saw that, but I haven't read about it yet

[09:06] <tadzik> it takes some effort to get running, but I'd say it's worth it

[09:06] <tadzik> vim could use some package manager that's not completely horrible :)

[09:08] *** fhelmberger joined
[09:09] <hoelzro> heh

[09:10] *** s0rear is now known as sorear

[09:15] *** am0c left
[09:23] *** krunen left
[09:26] *** sevin_ left
[09:34] *** mynameis left
[09:34] *** sqirrel joined
[09:35] *** xinming_ left
[09:35] *** xinming joined
[09:36] <tadzik> oh hm, my nqp-jvm patches are both wrong :|

[09:43] *** benabik left
[09:43] *** benabik joined
[09:44] *** Psyche^ joined
[09:48] *** Patterner left
[09:48] *** fgomez left
[09:48] *** Psyche^ is now known as Patterner

[09:54] *** dakkar joined
[09:55] *** sizz_ left
[09:56] *** sizz joined
[10:00] <masak> mornin', #perl6

[10:02] <tadzik> morning' masak'

[10:03] <hulu> @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *]

[10:03] *** hypolin left
[10:04] <hulu> benabik: what does '1 .. *' mean?

[10:05] <moritz> it's an infinite range starting from 1

[10:06] <hulu> moritz: what does 'infinite range' mean?

[10:06] *** szbalint left
[10:06] *** szbalint joined
[10:07] *** xinming left
[10:07] <moritz> hulu: which part are you having trouble with? 'infinite' or 'range'?

[10:07] <hulu> infinite

[10:07] <moritz> it doesn't have an end

[10:07] <moritz> it goes one forever

[10:08] <hulu> for @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *]     -> $a, $b, $c, $d, $e {     say "$a $b of beer on the wall";     say "$a $b of beer";     say $c;     say "$d $e of beer on the wall\n"; }

[10:08] <hulu> moritz: please look at this

[10:08] *** xinming joined
[10:09] * moritz looks at it

[10:09] <tadzik> masak: I have a shiny new rakudobug for you

[10:09] <masak> ooh

[10:09] <tadzik> r: sub prefix:<\o/>($) { }

[10:09] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/1ZhASdkYfl:1â¤â¤Â»

[10:09] *** kivutar joined
[10:09] <masak> when I make a language, I'm going to avoid the word "infinite". it's often more a question of "unbound".

[10:09] <masak> er, "unbounded".

[10:09] * masak submits rakudobug

[10:10] <masak> r: sub prefix:<\p>($) {}

[10:10] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/bUTogzfhSm:1â¤â¤Â»

[10:10] <masak> r: sub prefix:<\a>($) {}

[10:10] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/mgwCG0Vtyl:1â¤â¤Â»

[10:10] <masak> r: sub prefix:<\\>($) {}

[10:10] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/J8FFRNqtwK:1â¤â¤Â»

[10:10] <masak> r: sub prefix:<q>($) {}

[10:10] <p6eval> rakudo 935c90:  ( no output )

[10:10] <masak> ok, backslashes in preifx ops. got it.

[10:10] <masak> r: sub postfix:<\\>($) {}

[10:10] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/eWTbkYG8X8:1â¤â¤Â»

[10:10] <masak> r: sub infix:<\\>($) {}

[10:10] <p6eval> rakudo 935c90: OUTPUTÂ«Null PMC access in find_method('clone')â¤  in block  at /tmp/zadixk05uL:1â¤â¤Â»

[10:11] * masak submits rakudobug

[10:14] *** hulu left
[10:15] *** hulu joined
[10:16] *** anuby left
[10:18] <hulu> masak: 'Adding to an entry that is not in the hash yet will cause that entry to spring into existence just-in-time, with a value starting at zero.' è¿™å¥è¯ä¸­æ–‡æ€ä¹ˆè¯´ï¼Ÿ

[10:20] <masak> hulu: åšæŒä½ï¼Œæˆ‘å°†å®ƒç¿»è¯‘ã€‚

[10:21] <hulu> masak: è°¢è°¢

[10:21] <hulu> moritz: what does 'infinite range' mean?

[10:22] <FROGGS> r: say -Inf .. Inf

[10:22] <p6eval> rakudo 935c90: OUTPUTÂ«-Inf..Infâ¤Â»

[10:22] <moritz> hulu: didn't we have that discussion a while ago?

[10:22] <masak> moritz: I think hulu doesn't understand the word "infinite".

[10:22] <hulu>  for @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *]     -> $a, $b, $c, $d, $e {     say "$a $b of beer on the wall";     say "$a $b of beer";     say $c;     say "$d $e of beer on the wall\n"; }

[10:23] <hulu> masak: æˆ‘æ— æ³•ç†è§£è¿™å¥

[10:23] <masak> no no wait

[10:24] <masak> hulu: å¦‚æœä½ è¿™æ ·åš 'my %h; %h<foo> += 42', é‚£ä¹ˆè¿™ä¸ªå€¼ %h<foo> è¢«è‡ªåŠ¨è®¾ç½®ä¸º0å‰å¢åŠ äº†42

[10:25] <masak> hulu: ä½ æ˜ç™½å—ï¼Ÿæˆ‘æ˜ç™½çš„è¯´å—ï¼Ÿ

[10:25] <hulu> spring into existence just-in-time æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ

[10:26] <masak> hulu: å¼€å§‹å­˜åœ¨ï¼Œåœ¨æœ€åä¸€åˆ»

[10:27] <moritz> masak: which is why I've tried to explain it

[10:27] <masak> moritz: nodnod. it didn't stick.

[10:27] <masak> for whatever reason.

[10:27] <masak> communication is hard ;)

[10:28] <hulu> with a value starting at zero ä»€ä¹ˆæ„æ€

[10:28] <hulu> masak: è¯·çœ‹çœ‹æ˜¯ä»€ä¹ˆæ„æ€

[10:29] <masak> hulu: %h<foo> ä»0å¼€å§‹

[10:29] <hulu> æˆ‘è¯•ç€ç¿»è¯‘ä¸€ä¸‹

[10:29] <au> å¯¹å“ˆå¸Œè¡¨å†…çš„æŸä¸ªé¡¹ç›®è¿›è¡Œå¢å€¼ï¼Œå¦‚æœè¯¥é¡¹ç›®ä¸å­˜åœ¨ï¼Œå“ˆå¸Œè¡¨ä¼šå…ˆè‡ªåŠ¨å°†è¯¥é¡¹ç›®è®¾ä¸ºé›¶ã€‚

[10:29] <phenny> au: 15 Jan 18:50Z <[Coke]> tell au cleaned up pugs, we're back up to 38.55%

[10:29] <masak> au: thank you.

[10:30] <au> np :p

[10:30] <hulu> au: thx

[10:30] <masak> au: and now I feel a little embarrassed... I'm leaning heavily on GT here, and probably making a mess of word order and tone and word choice. *^_^*

[10:31] <hulu> au: that entry to spring into existence just-in-time ä»€ä¹ˆæ„æ€

[10:31] <sorear> au! \o/

[10:31] <arnsholt> masak: Still better than the rest of us =)

[10:31] <au> è¯¥é¡¹ç›®åœ¨ç”¨åˆ°æ—¶ï¼Œä¼šé¢„å…ˆè‡ªåŠ¨ç”Ÿæˆã€‚

[10:31] <masak> heh, hulu likes to make sure he really understood... :)

[10:31] <au> yeah, there's no easy zh equiv of just-in-time

[10:32] <masak> ah, there's the problem, then ;)

[10:32] <au> the literal rendering is probably ã€Œå€¼åˆ°ç”¨æ—¶æ–¹ç”Ÿæˆã€ after ã€Œä¹¦åˆ°ç”¨æ—¶ä¸Šç½‘æ‰¾ã€

[10:32] <masak> hulu: "just-in-time" means åœ¨æœ€åçš„æ—¶åˆ»

[10:32] <hulu> æˆ‘ä¸ç†è§£ spring into existence

[10:33] <au> except that, literally, means "at the armageddon"

[10:33] <masak> au: that's a bit too late :P

[10:33] <sorear> just in time is a bit of a funny idiom anyway.  I wonder if there are other common ways of handling things like that

[10:33] <masak> though kind of a nice feature...

[10:33] <au> hulu: spring = è·³, into = è¿›, existence = å­˜åœ¨

[10:33] <au> spring into existence = ç”Ÿæˆ

[10:33] <sorear> i wonder what they do with GÃ¶del's completeness theorem?

[10:34] <masak> sorear: what's the connection to just-in-time?

[10:35] <sorear> masak: every consistant set of axioms can be realized using a model (set of objects + relations), the basic idea is to lazily construct objects while taking a countable closure

[10:35] <sorear> it's interesting because it's not a temporal/dynamic process at all

[10:35] <sorear> but it has the same character of only caring about concepts which are in a sense accessible

[10:36] <masak> hm... never thought of it that way. nice.

[10:36] <masak> I've only recently started using "model" in that way, though. it feels very central to programming, somehow.

[10:37] <masak> where does "taking a countable closure" come in? when is that done?

[10:37] <hulu> au: æˆ‘è¯•ç€ç¿»è¯‘ä¸€ä¸‹ï¼šå‘å“ˆå¸Œç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªä¸å­˜åœ¨çš„é¡¹ç›®ï¼Œå°†å¯¼è‡´è¿™ä¸ªé¡¹ç›®åœ¨æœ€åæ—¶åˆ»ä»¥é›¶ä¸ºå€¼åˆ›å»º

[10:37] <sorear> masak: A countable closure covers all possible finite sequences of deductions.

[10:37] <masak> yes, I realize that.

[10:38] <masak> so it's what you construct when you somehow want to talk about the whole model...

[10:38] <sorear> unlike autovivification, which only closes over the single path which is taken

[10:38] <au> hulu: that's fine, except "add to an entry" here means "increment / å¢å€¼ / é€’åŠ  (+=, ++)" not "adding an entry "assignment / èµ‹å€¼ / æ·»åŠ "

[10:38] <masak> sorear: ah!

[10:38] <masak> there's the connection :)

[10:39] <hulu> au: è°¢è°¢

[10:39] <masak> au++

[10:39] <au> hulu: æ²¡äº‹å„¿ :)

[10:43] <hulu> au: for @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *]     -> $a, $b, $c, $d, $e {     say "$a $b of beer on the wall";     say "$a $b of beer";     say $c;     say "$d $e of beer on the wall\n"; }

[10:43] <hulu> au: è¿™æ®µç¨‹åºä¸­çš„ 1 .. * æ˜¯ä»€ä¹ˆæ„æ€

[10:44] <au> hulu: å»ºæ„ä¸€ä¸ª range åŒºé—´åºåˆ—ï¼Œä»¥ integer æ•´æ•°ä¸ºå€¼ï¼Œä¸‹é™ä¸º 1ï¼Œæ²¡æœ‰ä¸Šé™ã€‚

[10:44] <hulu> au: æ²¡æœ‰ä¸Šé™ï¼Œå¦‚ä½•åœæ­¢ï¼Ÿ

[10:45] <masak> moritz: <au> "...and there is no upper limit", <hulu> "if there's no upper limit, how to stop?" -- seems there was a conceptual difficulty in understanding.

[10:45] <au> å› ä¸ºæ˜¯ç”¨ä½œé˜µåˆ—ç´¢å¼•ï¼Œ@quantities å†…å…ƒç´ ç”¨å®Œæ—¶å°±ä¼šåœæ­¢ã€‚

[10:46] <masak> ...which ties nicely into what sorear said about finite deductions inside a countable closure. :)

[10:46] <au> yup.

[10:46] <hulu> au: ä»€ä¹ˆæ˜¯ é˜µåˆ—ç´¢å¼•

[10:47] <au> hulu: é˜µåˆ—ç»“æ„ä¸€èˆ¬ä»¥æ•´æ•°ä¸ºç´¢å¼•ï¼Œç›¸å½“äºå“ˆå¸Œç»“æ„çš„é”®ã€‚

[10:47] <masak> heh. I usually assume array knowledge and explain hashes using it, not the other way around. ;)

[10:47] * au assumes very little :)

[10:48] <masak> :P

[10:49] <masak> hulu: a range only specifies the two endpoints. it doesn't force you to count from one to the other.

[10:50] <masak> ...which would, indeed, take a very long time.

[10:52] <hulu> r: my @quantities = (99 ... 1), 'No more', 99; my @bottles = 'bottles' xx 98, 'bottle', 'bottles' xx 2; my @actions = 'Take one down, pass it around' xx 99,               'Go to the store, buy some more';say @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *];

[10:52] <p6eval> rakudo 935c90: OUTPUTÂ«99 bottles Take one down, pass it around 98 bottles 98 bottles Take one down, pass it around 97 bottles 97 bottles Take one down, pass it around 96 bottles 96 bottles Take one down, pass it around 95 bottles 95 bottles Take one down, pass it around 94 bottles 94 boâ€¦

[10:57] <sorear> A range is just a pair endowed with semantics.

[10:57] <sorear> r: my $r = 2 .. "green"; $r.end

[10:57] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot call 'Real'; none of these signatures match:â¤:(Mu:U \v: Mu *%_)â¤â¤  in method Real at src/gen/CORE.setting:872â¤  in method Real at src/gen/CORE.setting:2391â¤  in method new at src/gen/CORE.setting:5255â¤  in sub infix:<..> at src/gen/CORE.setting:5436â¤  in bloâ€¦

[10:59] <moritz> that's LTA

[10:59] <hulu> r: my @quantities = (99 ... 1), 'No more', 99; my @bottles = 'bottles' xx 98, 'bottle', 'bottles' xx 2; my @actions = 'Take one down, pass it around' xx 99, 'Go to the store, buy some more'; #for @quantities Z @bottles Z @actions Z #    @quantities[1 .. *] Z @bottles[1 .. *] #    -> $a, $b, $c, $d, $e { for @quantities Z @bottles Z @actions -> $a, $b, $c { say "$a $b of beer on the wall"; say "$a $b of beer"; say $c; #    say "$d $e of

[10:59] <p6eval> rakudo 935c90:  ( no output )

[11:00] <hulu> r: my @quantities = (99 ... 1), 'No more', 99; my @bottles = 'bottles' xx 98, 'bottle', 'bottles' xx 2; my @actions = 'Take one down, pass it around' xx 99, 'Go to the store, buy some more'; for @quantities Z @bottles Z @actions -> $a, $b, $c { say "$a $b of beer on the wall"; say "$a $b of beer"; say $c; }

[11:00] <p6eval> rakudo 935c90: OUTPUTÂ«99 bottles of beer on the wallâ¤99 bottles of beerâ¤Take one down, pass it aroundâ¤98 bottles of beer on the wallâ¤98 bottles of beerâ¤Take one down, pass it aroundâ¤97 bottles of beer on the wallâ¤97 bottles of beerâ¤Take one down, pass it aroundâ¤96 bottles of beer on theâ€¦

[11:01] <masak> hehe, I read sorear's "just a pair" comment, and then apparently thought exactly the same thing as moritz did. :P

[11:01] <moritz> hulu: do you know any other programming languages?

[11:01] <masak> surely the things in the pair need to be "on the same continuum" in some sense?

[11:01] <hulu> moritz: 3,5

[11:02] <moritz> hulu: which languages?

[11:02] <hulu> C

[11:02] <hulu> c++

[11:02] <hulu> python

[11:02] <hulu> ruby

[11:02] <hulu> java

[11:02] <masak> is Ruby the .5 ?

[11:02] <masak> oh wait, that's five languages.

[11:02] <au> it's a range :p

[11:02] <masak> :P

[11:03] <au> ...expressed as a pair, endowed with semantics

[11:04] <hulu> au: æˆ‘è¿˜æ˜¯ä¸ç†è§£ for @quantities Z @bottles Z @actions Z     @quantities[1 .. *] Z @bottles[1 .. *]

[11:06] <hulu> au: @quantitieså’Œ@quantities[1 .. *]æœ‰ä»€ä¹ˆä¸åŒ

[11:07] *** SmokeMachine joined
[11:07] <hulu> moritz: what diff between @quantities @quantities[1 .. *]

[11:08] <masak> I find the "endowed with semantics" much too weak. that could be either an ADT or an OO class.

[11:08] <moritz> hulu: @quantities[1 .. *] misses the first element (index 0)

[11:08] <masak> also, it correctly describes a complex number just as much as a range. and those are quite different.

[11:08] <moritz> my @quant = <a b c d>; say @quant; say @quant[1..*]

[11:09] <moritz> r: my @quant = <a b c d>; say @quant; say @quant[1..*]

[11:09] <p6eval> rakudo 935c90: OUTPUTÂ«a b c dâ¤b c dâ¤Â»

[11:09] <masak> moritz++ # pedagogic

[11:09] <moritz> r: my @quant = <a b c d>; say @quant Z~ @quant[1..*]

[11:09] <p6eval> rakudo 935c90: OUTPUTÂ«ab bc cdâ¤Â»

[11:10] * moritz kinda likes that idiom

[11:10] *** Su-Shee_ joined
[11:10] <moritz> masak: I hereby officially inform you that I'm impatient regarding the p6cc reviews

[11:10] <moritz> :-)

[11:10] <masak> noted.

[11:10] <hulu> moritz: thx

[11:11] *** Su-Shee_ is now known as Su-Shee

[11:11] <masak> moritz: FOSDEM/Brussels took too many cycles for me to look at it then. but I'll have some time today. will report progress later this evening.

[11:12] <masak> by the way, it was lovely to have a Perl 6 presence at FOSDEM. we should do that again.

[11:13] <masak> r: my @quant = <a b c d>; say @quant Z~ @quant.rotate

[11:13] <p6eval> rakudo 935c90: OUTPUTÂ«ab bc cd daâ¤Â»

[11:13] * masak likes that idiom ;)

[11:14] *** kivutar left
[11:15] *** marloshouse left
[11:15] <moritz> aye, that one is nice too

[11:15] *** marloshouse joined
[11:17] <masak> r: my @quant = <a b c d>; say @quant Z~ @quant.reverse

[11:17] <p6eval> rakudo 935c90: OUTPUTÂ«ad bc cb daâ¤Â»

[11:17] <masak> r: my @quant = <a b c d>; say @quant Z~ @quant.pick(*)

[11:17] <p6eval> rakudo 935c90: OUTPUTÂ«aa bc cd dbâ¤Â»

[11:18] <hulu> r: my @quantities = (99 ... 1), 'No more', 99; my @bottles = 'bottles' xx 98, 'bottle', 'bottles' xx 2; my @actions = 'Take one down, pass it around' xx 99, 'Go to the store, buy some more'; for @quantities Z @bottles Z @actions Z @quantities[1 .. *] Z @bottles[1 .. *] -> $a, $b, $c, $d, $e { say $a, $b, $c, $d, $e; }

[11:18] <p6eval> rakudo 935c90: OUTPUTÂ«99bottlesTake one down, pass it around98bottlesâ¤98bottlesTake one down, pass it around97bottlesâ¤97bottlesTake one down, pass it around96bottlesâ¤96bottlesTake one down, pass it around95bottlesâ¤95bottlesTake one down, pass it around94bottlesâ¤94bottlesTake one down, pâ€¦

[11:20] <Juerd> Nice.

[11:21] <hulu> my @quant = <a b c d>; say @quant Z @quant.reverse Z @quant

[11:21] <hulu> r: my @quant = <a b c d>; say @quant Z @quant.reverse Z @quant

[11:21] <p6eval> rakudo 935c90: OUTPUTÂ«a d a b c b c b c d a dâ¤Â»

[11:22] <hulu> r: my @quant = <a b c d>; say @quant Z @quant.reverse Z @quant:

[11:22] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a rowâ¤at /tmp/GM7Tmgz5Jz:1â¤------> [32md>; say @quant Z @quant.reverse Z @quant[33mâ[31m:[0mâ¤    expecting any of:â¤        postfixâ¤        infix or meta-infixâ¤        infix stopperâ¤        statement endâ¤        statemâ€¦

[11:22] <hulu> r: my @quant = <a b c d>; say @quant Z @quant.reverse Z @quant;

[11:22] <p6eval> rakudo 935c90: OUTPUTÂ«a d a b c b c b c d a dâ¤Â»

[11:22] <hulu> r: my @quant = <a b c d>; say @quant Z~ @quant.reverse Z~ @quant;

[11:23] <p6eval> rakudo 935c90: OUTPUTÂ«ada bcb cbc dadâ¤Â»

[11:26] <masak> hulu: Z makes a list of separate items, Z~ concatenates things.

[11:36] <hulu> masak: ic

[11:36] <hulu> masak: thx

[11:38] <masak> np :)

[11:42] <hulu> r: say [+] .words for lines

[11:42] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âLand' (indicated by â)â¤current instr.: 'throw' pc 332433 (src/gen/CORE.setting.pir:149253) (src/gen/CORE.setting:9296)â¤called from Sub 'Numeric' pc 363983 (src/gen/CORE.settingâ€¦

[11:45] <hulu> au: [+] <2 3 4>;[+] .words for <2 3 4> æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ

[11:45] <hulu> r: [+] .words for <2 3 4>

[11:45] <p6eval> rakudo 935c90:  ( no output )

[11:45] <hulu> r: say [+] .words for <2 3 4>

[11:45] <p6eval> rakudo 935c90: OUTPUTÂ«2â¤3â¤4â¤Â»

[11:46] <hulu> masak: what does 'say [+] .words for <2 3 4>' mean?

[11:51] <hulu> who can help me

[11:52] <hulu> what does 'say [+] .words for <2 3 4>' mean?

[12:01] <masak> hulu: let's look at '[+] .words for lines' instead. it makes more sense.

[12:02] <masak> hulu: it means "read all the lines of $*IN" (lines), "split each line into words" (.words for), and "convert all the words to numbers and sum them" ([+])

[12:03] <masak> r: say [+] 10, 2000, 4_000_000

[12:03] <p6eval> rakudo 935c90: OUTPUTÂ«4002010â¤Â»

[12:04] <masak> r: say "Beverly Hills", [+] <10 200 90_000>

[12:04] <p6eval> rakudo 935c90: OUTPUTÂ«Beverly Hills90210â¤Â»

[12:04] <masak> r: say "Beverly Hills, ", [+] <10 200 90_000>

[12:04] <p6eval> rakudo 935c90: OUTPUTÂ«Beverly Hills, 90210â¤Â»

[12:05] <masak> r: .say for "Observe how this sentence is split up into parts".words

[12:05] <p6eval> rakudo 935c90: OUTPUTÂ«Observeâ¤howâ¤thisâ¤sentenceâ¤isâ¤splitâ¤upâ¤intoâ¤partsâ¤Â»

[12:05] <masak> hulu: does that answer your question?

[12:09] *** dayangkun left
[12:10] <masak> today's autopun spotting: https://twitter.com/luqui/status/298739823492079616

[12:12] *** kresike joined
[12:12] <kresike> hello all you happy perl6 people

[12:20] *** kivutar joined
[12:22] *** dayangkun joined
[12:22] *** brrt joined
[12:26] <masak> kresike! \o/

[12:27] <kresike> masak, o/

[12:27] <kresike> long time no see !

[12:29] <hulu> r: [+] .words for lines

[12:29] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âLand' (indicated by â)â¤current instr.: 'throw' pc 332433 (src/gen/CORE.setting.pir:149253) (src/gen/CORE.setting:9296)â¤called from Sub 'Numeric' pc 363983 (src/gen/CORE.settingâ€¦

[12:30] <hulu> r: say [+] .words for lines

[12:30] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âLand' (indicated by â)â¤current instr.: 'throw' pc 332433 (src/gen/CORE.setting.pir:149253) (src/gen/CORE.setting:9296)â¤called from Sub 'Numeric' pc 363983 (src/gen/CORE.settingâ€¦

[12:30] <hulu> masak: why this not run

[12:36] *** shinobicl joined
[12:43] <moritz> it runs

[12:44] <moritz> but it dies when trying to convert the word 'Land' to a number

[12:44] <hulu> moritz: ?

[12:44] <moritz> as the error message tells you

[12:44] <FROGGS> r: say [+] .words for lines

[12:44] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âLand' (indicated by â)â¤current instr.: 'throw' pc 332433 (src/gen/CORE.setting.pir:149253) (src/gen/CORE.setting:9296)â¤called from Sub 'Numeric' pc 363983 (src/gen/CORE.settingâ€¦

[12:44] <FROGGS> r: say .words for lines

[12:44] <p6eval> rakudo 935c90: OUTPUTÂ«Land der Berge, Land am Strome,â¤Land der Ã„cker, Land der Dome,â¤Land der HÃ¤mmer, zukunftsreich!â¤Heimat bist du groÃŸer SÃ¶hne,â¤Volk, begnadet fÃ¼r das SchÃ¶ne,â¤vielgerÃ¼hmtes Ã–sterreich,â¤vielgerÃ¼hmtes Ã–sterreich!â¤â¤HeiÃŸ umfehdet, wild umstrittenâ¤liegst dem Erdteil du inmiâ€¦

[12:44] <FROGGS> you can't sum words

[12:45] *** benabik left
[12:45] <FROGGS> r: say 'Land' + 'der'

[12:45] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âLand' (indicated by â)â¤  in method Numeric at src/gen/CORE.setting:10508â¤  in sub infix:<+> at src/gen/CORE.setting:2834â¤  in sub infix:<+> at src/gen/CORE.setting:2834â¤  in blâ€¦

[12:45] <hulu> how to do

[12:45] <FROGGS> to do what?

[12:45] <hulu> [+]

[12:45] <FROGGS> well, it works on numbers

[12:46] <moritz> hulu: what do you want the output to be?

[12:46] <hulu> words of line

[12:46] <nwc10> masak: sorry if this is a FAQ - why thie *Austrian* national anthem?

[12:46] <FROGGS> you just want to split a line to a list of words?

[12:47] *** kaleem left
[12:47] <FROGGS> hulu^^

[12:47] <moritz> hulu: do you want to know the number of words per line?

[12:47] <moritz> nwc10: I think it's vaguely related to the YAPC::EU in Vienna

[12:48] <moritz> but the details are lost in the mists of time

[12:49] <hulu> moritz: http://rosettacode.org/wiki/A%2BB#Perl_6

[12:50] <moritz> hulu: well yes, you can sum them, but only if the words in the input are actually numbers

[12:50] <hulu> r: say [+] .words for "1 2"

[12:50] <p6eval> rakudo 935c90: OUTPUTÂ«3â¤Â»

[12:50] <FROGGS> r: say [+] .words for "1 2 3 4 5 6 7 8"

[12:50] <p6eval> rakudo 935c90: OUTPUTÂ«36â¤Â»

[12:51] <hulu> moritz: why lines not run

[12:52] *** shinobicl left
[12:52] *** shinobicl joined
[12:52] <moritz> hulu: lines() reads from standard input

[12:52] <moritz> hulu: and what it reads there aren't numbers

[12:52] <moritz> r: say [+] .words for "these are not numbers"

[12:52] <p6eval> rakudo 935c90: OUTPUTÂ«Cannot convert string to number: base-10 number must begin with valid digits or '.' in 'âthese' (indicated by â)â¤current instr.: 'throw' pc 332433 (src/gen/CORE.setting.pir:149253) (src/gen/CORE.setting:9296)â¤called from Sub 'Numeric' pc 363983 (src/gen/CORE.settinâ€¦

[12:53] <nwc10> moritz: mists of time, and incomplete version control history imports. But it was in 2009: http://irclog.perlgeek.de/perl6/2009-04-30#i_1108448

[12:54] <hulu> moritz: i c

[12:54] <nwc10> which is 1 month after the QA hackathon in Birmingham

[12:55] <moritz> nwc10: I must protest the "incomplete version control history imports": https://github.com/perl6/evalbot/commit/8e5c3db6b933102e1e513340b35612c9ccf90e37

[12:58] <nwc10> you got me there

[12:58] <nwc10> but the searches don't find that

[13:04] <hulu> moritz: sub accum ($n is copy) { sub { $n += $^x } };my $a = accum 5; $a(4.5); say $a(.5);

[13:04] <masak> nwc10: for a very silly reason: this blog post. http://strangelyconsistent.org/blog/the-totally-undeserved-fame-and-success-of-proto

[13:04] <hulu> why 10, not 5.5

[13:05] <nwc10> aha. :-)

[13:05] <TimToady> masak: "infinite" vs "unbounded": your precision is obscure and confusing to newbies, and if we're going to banish concepts like infinity because of mere physical limitations, our dictionary will be sadly depleted

[13:06] <hulu> who can help me

[13:06] <masak> TimToady: you have a point.

[13:07] *** sftp left
[13:07] <masak> hulu: because you initialize $n to 5, add 4.5 (so we're up to 9.5) and then add .5 (so we're up to 10). the 10 is returned.

[13:07] <FROGGS> hulu: 5 + 4.5 + 0.5

[13:08] <masak> hulu: your questions seem related less to how Perl 6 works and more to how programs work.

[13:09] <masak> TimToady: that said, many times it feels like what we want to say (especially when we do '*' and not 'Inf', which I think turned out to be more common that anticipated), is "just keep going", not "this one goes up to infinity".

[13:09] <hulu> masak: å“ªå¥æ˜¯åˆå§‹åŒ– $n

[13:09] <masak> hulu: ah, I see what's going on.

[13:09] <masak> hulu: you're confused as to the nature of closures.

[13:10] <masak> I have *no* idea how to explain closures to you across the very narrow inter-language bandwidth we've established. :/

[13:10] <masak> even though I understand them well at this point myself.

[13:12] <hulu> FROGGS: where initialize $n to 5

[13:12] <hulu> FROGGS: wher initialize $n to 5

[13:13] <masak> hulu: 'accum 5' and '$n is copy'.

[13:13] <FROGGS> right

[13:13] <masak> peeps, I'm watching http://www.infoq.com/presentations/Thinking-Parallel-Programming -- heartily recommended to anyone who's interested in parallelism.

[13:14] <FROGGS> sorry for the delay, I'm doing hundreds of things at once

[13:14] <masak> it's a Guy Steele talk.

[13:14] <hulu> masak: $n is copy æ˜¯äº§ç”Ÿæ‹·è´ï¼Œå¦‚ä½• èƒ½ç»§ç»­ +4.5+.5

[13:14] *** FROGGS left
[13:15] <masak> hulu: because closures.

[13:15] <masak> hulu: which I can't explain to you, because there is not enough bandwidth.

[13:16] <masak> I *can* show how they work empirically, but I can't explain.

[13:17] <hulu> masak: thx

[13:17] <masak> r: sub make-counter { my $i = 0; return { ++$i } }; my $c1 = make-counter(); say $c1(); say $c1(); say $c1()

[13:17] <p6eval> rakudo 935c90: OUTPUTÂ«1â¤2â¤3â¤Â»

[13:17] <masak> r: sub make-counter { my $i = 0; return { ++$i } }; my $c1 = make-counter(); my $c2 = make-counter(); $c1(); $c1(); $c2(); $c1()

[13:17] <p6eval> rakudo 935c90:  ( no output )

[13:17] <masak> r: sub make-counter { my $i = 0; return { ++$i } }; my $c1 = make-counter(); my $c2 = make-counter(); say $c1(); say $c1(); say $c2(); say $c1()

[13:17] <p6eval> rakudo 935c90: OUTPUTÂ«1â¤2â¤1â¤3â¤Â»

[13:18] <masak> hulu: study that. when you understand why that works, you'll understand closures, and your own example.

[13:18] <masak> hulu: it's also explained at the end of S04, but I wouldn't recommend that explanation. it's not for the faint of heart.

[13:19] <TimToady> .oO(The Zen master hit the student on the head with a closure, and then the student was enlightened.)

[13:19] <masak> :P

[13:19] <hulu> masak: closures çš„æ„æ€æ˜¯é—­åŒ…

[13:20] <masak> according to GT, yes.

[13:20] <masak> but I would need something au-complete to verify it for sure.

[13:21] <hulu> au: sub accum ($n is copy) { sub { $n += $^x } };my $a = accum 5; $a(4.5); say $a(.5); ä¸ºä»€ä¹ˆæ˜¯  10 

[13:22] <masak> hulu: here's the important bit: a closure *remembers its environment* and all the variables (like $n) that's in it, between calls.

[13:22] <masak> in the end that is ä¸ºä»€ä¹ˆæ˜¯ 10.

[13:23] <masak> if you want it to be 5.5, remove the '$a(4.5)' bit in the middle :P

[13:23] <hulu> masak: æˆ‘è¿˜æ˜¯çœ‹ä¸æ‡‚

[13:24] <hulu> masak: my $a = accum 5; æ˜¯ä»€ä¹ˆæ„æ€

[13:25] *** _jaldhar left
[13:27] <masak> hulu: 'accum 5' calls the subroutine &accum, passing in the value 5, which is then stored in $n. the 'is copy' means that it's a "new" 5 being stored in $n.

[13:27] <au> hulu: the ruby equivalent is

[13:27] <au> def accum n; lambda { |x| n += x }; end; a = accum 5; a.call 4.5; puts a.call 0.5

[13:27] <TimToady> masak: I usually say "an arbitrary number of" when I feel uncomfy with "infinite"

[13:28] <hulu> masak: æˆ‘è¿˜æ˜¯ä¸æ˜ç™½

[13:28] <TimToady> arbitrary is an arbitrary word, but at least it's un-self-negated as limitless or unbounded are

[13:28] <masak> TimToady: yes, that rings a little of induction, I guess.

[13:29] <masak> hulu: I told you we didn't have enough bandwidth for me to explaing this. :/

[13:29] <masak> explain*

[13:29] *** felipe joined
[13:30] <masak> there's something weird about closures, such that they go wildly against your intuitions as a BASIC or C or Assembly programmer, but they're actually fundamentally *simple*.

[13:31] <masak> people have to go through the same kind of trial by fire as with git, coming out the other end having essentially unlearned some stuff.

[13:32] <au> hulu: try http://tc.wangchao.net.cn/bbs/detail_69548.html

[13:33] *** lizmat left
[13:33] <masak> when I explain this in class, I usually go: "what's the shape of an array? it's a sequence of elements." -- "what's the shape of a hash? it's an unordered collection of key/value pairs".

[13:33] <masak> "what's the shape of a routine? it's a signature, a body, and *an environment*".

[13:33] <masak> that last bit is what makes closures work.

[13:34] <TimToady> a set of bindings, a set of not-yet-bound-ings, and the desired relationship between them :)

[13:35] <au> ((n)->(n+=)) 5 => .. 4.5; .. 0.5 |> console.log # livescript version, fwiw

[13:35] <masak> lambda calculus has made me a better programmer.

[13:36] * TimToady refrains from asking masak++ to define "better"

[13:37] <masak> ;)

[13:38] <masak> the axes I was thinking of were a linear combination of "able to design programs" and "able to reason about behavior".

[13:40] <TimToady> but perhaps not "able to explain your program easily to some person on IRC" :)

[13:40] <TimToady> ss/some person/some arbitrary person/  :)

[13:41] <hulu> au: æˆ‘æƒ³é—®ä¸€ä¸‹ $n æ˜¯å¦‚ä½•åœ¨ my $a = accum 6;$a(4.5); say $a(.5); ä¹‹é—´ä¼ é€’çš„ã€‚

[13:43] *** hoelzro is now known as hoelzro|away

[13:43] * TimToady has never seen someone try to learn programming by proceeding through an RC page in alphabetical order before

[13:43] <au> hulu: accum() è¿è¡Œæ—¶ï¼Œè®°ä½äº†å‚æ•° $n çš„å€¼ï¼Œå¹¶ä¸”ä¼ å›ä¸€ä¸ªæ–°å®šä¹‰çš„å‡½å¼ç‰©ä»¶ç»™ $aã€‚ä¹‹åå‘¼å« $a æ—¶ï¼Œè©²å‡½å¼å¯ä»¥ç›´æ¥å­˜å–å®šç¾©æ™‚çš„ $n è®Šæ•¸ã€‚é€™å€‹æ©Ÿåˆ¶ç¨±ç‚ºã€Œé–‰åŒ…ã€ã€‚è«‹è¦‹ä»¥ä¸Šç¶²å€ã€‚

[13:44] <TimToady> it's kinda refreshingly different

[13:44] <au> well, agentzh started by, iirc, transcribing Synopses to paper by hand

[13:44] <TimToady> in a difficult sort of way

[13:45] <masak> TimToady: I'm not sure closures can be explained. I teach them regularly, but I always get the impression that when people get it, they get it because of themselves, not because of me.

[13:46] <hulu> au: ä¹‹åå‘¼å« $a æ—¶ï¼Œè©²å‡½å¼å¯ä»¥ç›´æ¥å­˜å–å®šç¾©æ™‚çš„ $n è®Šæ•¸ ä»€ä¹ˆæ„æ€ï¼Ÿ

[13:47] <clkao> iirc SICP has pretty figures about closures

[13:47] <au> hulu: è«‹è¦‹ä»¥ä¸Šç¶²å€ http://wj.cnblogs.com/archive/2006/04/22/381851.html ... åœ¨æ„é€ å‡½æ•°å†…ï¼Œå†…éƒ¨å‡½æ•°æ€»æ˜¯å¯ä»¥è®¿é—®å‡½æ•°å¤–éƒ¨çš„å˜é‡å’Œå‚æ•°çš„ã€‚å°±ç®—åœ¨å†…éƒ¨å‡½æ•°returnåï¼Œé—­åŒ…å†…çš„æ‰€æœ‰å˜é‡éƒ½ä¼šè¢«ä¿å­˜èµ·æ¥ï¼Œå°±å¥½åƒä¸€ä¸ªä¸Šä¸‹æ–‡ä¸€æ ·ã€‚

[13:47] <brrt> closures kill the nice stack behavior that you would otherwise have in c-like-language

[13:47] <brrt> s

[13:47] <Juerd> TimToady: My most important resource when learning Perl was perlfunc.

[13:48] <TimToady> masak: all containers have to be elaborated/initialized, it's just that closure are inside out, and are elaborated/initialized with their outsides

[13:48] <au> hulu: è¿™æ¦‚å¿µç”¨ IRC è‘—å®æ²¡æ³•è®²æ¸…æ¥šï¼Œå¾ˆæŠ±æ­‰ã€‚

[13:48] <masak> TimToady: I guess that's why they're useful for IoC.

[13:48] <Juerd> TimToady: I simply started there, and read it from top to bottom, so in alphabetical order. After reading it, I had a HUGE list of things that I didn't understand, which I then looked up in other perldocs.

[13:48] <Juerd> TimToady: Then, I read perlfunc again and I could make a lot more sense of it.

[13:49] <masak> brrt: yes, they do. but the model they replace it with, while less simple, feels like "the next step up", and is occasionally *really* useful.

[13:49] <TimToady> Juerd: that's how I learned things when I was younger

[13:49] * au <- pretty much did the same thing as Juerd ... haven't read the Camel book until 2005 or so

[13:49] <masak> hm, would it be possible to create a lambda calculus without closure semantics? would it still be Turing complete?

[13:50] <Juerd> TimToady: I still learn like this, only now my primary focus is syntax, not functions.

[13:50] <Juerd> Perl's to blame for that, I'm sure.

[13:51] <brrt> masak, its true, i think closures are really useful and nice

[13:51] <brrt> but

[13:51] <brrt> they can be prohibitively painful

[13:52] *** kaleem joined
[13:52] <au> masak: sure, it's called Combinatory logic

[13:53] <au> (or, more specifically, SKI calculus)

[13:53] <masak> oh, right.

[13:54] <masak> and that feels equal in power. which makes sense, because the Turing machine doesn't think in closures either.

[13:54] *** atrodo joined
[13:57] *** sftp joined
[13:58] *** denisboyun joined
[13:59] *** domidumont left
[14:05] *** denisboyun left
[14:06] <masak> wonderful, Guy Steele defines algebraic properties in terms of what things don't matter.

[14:07] *** b1rkh0ff left
[14:07] <masak> "associative: grouping doesn't matter" -- "commutative: order doesn't matter" -- "idempotent: duplicates don't matter" -- "identity: this value doesn't matter" -- "zero: other values don't matter"

[14:07] <masak> very nice.

[14:08] <tadzik> curious

[14:08] *** denisboyun joined
[14:09] *** FROGGS joined
[14:09] *** PZt left
[14:15] *** denisboyun__ joined
[14:16] *** denisboyun left
[14:16] *** arnsholt left
[14:18] *** PacoAir joined
[14:19] *** b1rkh0ff joined
[14:20] *** denisboyun__ left
[14:21] *** xinming left
[14:21] *** FROGGS left
[14:21] *** xinming joined
[14:22] *** FROGGS[mobile] joined
[14:22] *** bluescreen10 joined
[14:23] <FROGGS[mobile]> airports are boring

[14:23] *** PacoAir left
[14:23] *** PacoAir joined
[14:23] *** domidumont joined
[14:26] <masak> FROGGS[mobile]: http://sethgodin.typepad.com/seths_blog/2013/01/ten-things-organizations-can-learn-from-airports-.html

[14:36] <masak> wow, someone should do http://search.cpan.org/dist/Acme-Pythonic/lib/Acme/Pythonic.pm as soon as we have savvy enough slangs, and then blog about why slangs are better than source filters ;)

[14:37] *** fgomez joined
[14:39] *** krunen joined
[14:41] *** kaare_ joined
[14:42] *** kivutar left
[14:45] *** denisboyun joined
[14:49] *** denisboyun left
[14:53] *** stopbit joined
[14:54] *** denisboyun_ joined
[14:58] <diakopter> masak: all Turing machines run on Chuck Norris' brain

[14:58] <brrt> chuck norris is the reference turing machine

[14:58] *** kaleem left
[14:58] <masak> :)

[14:59] <masak> Turing machines work because Chuck Norris allows them to do so.

[15:00] <brrt> turing completeness is a subset of norris-completeness

[15:02] *** denisboyun_ left
[15:11] <FROGGS[mobile]> :op

[15:13] *** arlinius joined
[15:13] *** kivutar joined
[15:15] *** FROGGS[mobile] left
[15:15] *** hoelzro|away is now known as hoelzro

[15:18] *** skids joined
[15:20] *** fgomez left
[15:22] *** tojatoja joined
[15:41] *** Targen left
[15:45] *** isBEKaml joined
[15:49] *** hulu left
[15:50] *** kresike left
[15:50] <isBEKaml> hello, #perl6!

[15:50] <masak> isBEKaml! \o/

[15:51] <masak> sorear: in the category of sets, why are singletons terminal objects?

[15:51] *** am0c joined
[15:51] <masak> more specifically, what is the unique morphism leading to a singleton object?

[15:54] <isBEKaml> Categorical greetings, masak! :)

[15:55] <hoelzro> greeting :: IO ()

[15:55] <masak> monomorphic salutations!

[15:56] <isBEKaml> .oO(Greetings are perpetually trapped in IO monad)

[15:57] *** steven__1 left
[15:58] *** steven__ joined
[15:58] *** tojatoja left
[16:03] <isBEKaml> http://acm.wustl.edu/functional/io-monad.jpg =)

[16:04] *** MAAHZSY joined
[16:08] <masak> aww

[16:09] <masak> yes, it's a little-known fact, that the inside of the IO monad looks like a shower.

[16:12] <isBEKaml> that's why people do unsafePerformIO? :P

[16:15] *** kivutar left
[16:16] <masak> I doubt that. under the analogy, unsafePerformIO needs to look like a shower with pipes exposed or something.

[16:20] <isBEKaml> I could pull in another analogy, but it won't be safe on IRC. :)

[16:21] <masak> unsafeAnalogyIO

[16:27] <isBEKaml> eggjactly

[16:37] *** MikeFair__ left
[16:37] *** MikeFair_ joined
[16:43] *** spider-mario joined
[16:43] *** domidumont left
[16:48] <jnthn> fail, I was reading day's hot shoe on the subway and I missed my stop...

[16:48] <phenny> jnthn: 04 Feb 22:52Z <tadzik> tell jnthn deletepos pullrequested as well :)

[16:49] <masak> jnthn: that's how interesting the backlog is! :P

[16:50] <isBEKaml> jnthn: day's hot "shoe" ? 

[16:51] *** Su-Shee left
[16:51] <masak> isBEKaml: IR clogs are warm, because infrared is warm.

[16:52] <masak> isBEKaml: "IR clogs", "IRC logs". bad pun.

[16:52] <masak> groan now.

[16:52] <hoelzro> haha, IR clogs

[16:52] * isBEKaml groans

[16:52] <hoelzro> nightvision clogs.

[16:53] <grondilu> r: say (pi+20)**i

[16:53] <p6eval> rakudo 935c90: OUTPUTÂ«-0.99999999924368-3.88926694022219e-05iâ¤Â»

[16:54] <isBEKaml> r: my $foo = 4.0 * atan(1.0); say $foo;

[16:54] <p6eval> rakudo 935c90: OUTPUTÂ«3.14159265358979â¤Â»

[16:55] *** FROGGS joined
[16:55] *** cognominal joined
[16:58] <FROGGS> masak: would it be possible to do Inline::C as a slang?

[16:58] <FROGGS> are there resources about slangs?

[16:58] <FROGGS> couldn't find any right now

[16:58] *** SunilJoshi joined
[16:59] <isBEKaml> r: my $foo = 4.0 * atan(1.0); say $foo; ($foo == pi).say

[16:59] <p6eval> rakudo 935c90: OUTPUTÂ«3.14159265358979â¤Trueâ¤Â»

[17:00] <masak> FROGGS: we don't know nearly enough about slangs yet.

[17:00] *** brrt left
[17:02] <FROGGS> k

[17:02] *** daxim left
[17:04] <GlitchMr-> .u Ä¯

[17:04] <phenny> U+012F LATIN SMALL LETTER I WITH OGONEK (Ä¯)

[17:04] <GlitchMr-> .u Ç«Ìˆ

[17:04] <phenny> U+01EB LATIN SMALL LETTER O WITH OGONEK (Ç«)

[17:04] <phenny> U+0308 COMBINING DIAERESIS (â—ŒÌˆ)

[17:04] <jnthn> FROGGS: Yes, if only we knew how slangs worked ;)

[17:05] *** SunilJoshi1 joined
[17:05] *** SunilJoshi left
[17:08] <FROGGS> no specs?

[17:08] <FROGGS> sounds like a job for TimToady++

[17:08] <FROGGS> :o)

[17:08] <GlitchMr-> .u ï¬

[17:08] <phenny> U+FB01 LATIN SMALL LIGATURE FI (ï¬)

[17:08] <GlitchMr-> rn: 'ï¬' ~~ m:i/ fi /

[17:08] <p6eval> rakudo 935c90, niecza v24-18-gaf64300:  ( no output )

[17:08] <GlitchMr-> rn: say 'fi' ~~ m:i/ ï¬ /

[17:08] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«Falseâ¤Â»

[17:08] <p6eval> ..rakudo 935c90: OUTPUTÂ«#<failed match>â¤Â»

[17:09] *** hoelzro is now known as hoelzro|away

[17:09] <GlitchMr-> rn: say 'ï¬' ~~ m:i/ fi /

[17:09] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«Falseâ¤Â»

[17:09] <p6eval> ..rakudo 935c90: OUTPUTÂ«#<failed match>â¤Â»

[17:09] <GlitchMr-> eval: use utf8; 'ï¬' ~~ m/fi/i ? 'true' : 'false'

[17:10] <GlitchMr-> rn: say uc 'ï¬'

[17:10] <p6eval> rakudo 935c90: OUTPUTÂ«FIâ¤Â»

[17:10] <p6eval> ..niecza v24-18-gaf64300: OUTPUTÂ«ï¬â¤Â»

[17:10] <GlitchMr-> niecza bug?

[17:12] <flussence> hard to tell... perl5 agrees with rakudo, but vim agrees with niecza :)

[17:14] <GlitchMr-> Unicode standards

[17:14] <flussence> .oO( the great thing about them is there's so much reading material! )

[17:15] *** domidumont joined
[17:15] *** FROGGS left
[17:29] *** Gruber is now known as Grrrr

[17:31] <jnthn> nom &

[17:31] *** domidumont left
[17:36] *** grondilu left
[17:37] *** grondilu joined
[17:37] *** isBEKaml left
[17:38] <[Coke]> anyone know who "sue spence" is?

[17:40] *** jerome left
[17:41] *** Vlavv_ joined
[17:44] *** SamuraiJack left
[17:44] *** rindolf joined
[17:44] <rindolf> Hi all.

[17:45] <rindolf> TimToady: hi, here?

[17:46] <masak> ho, rindolf.

[17:47] <masak> [Coke]: looks like a CPAN author (SUE) with two modules.

[17:47] <masak> [Coke]: first I thought it was a corny pun (something with "suspence")

[17:48] <masak> er, "suspense".

[17:48] <rindolf> SUE?

[17:48] <rindolf> Sue is short for Susan.

[17:48] <rindolf> Or an alternative word for litigate.

[17:49] <[Coke]> rindolf: yes, but neither of those are really helpful. :)

[17:49] <rindolf> [Coke]: ah.

[17:49] <[Coke]> Just wondering if she's lurking in here or perhaps she's linked-in-ing everyone with a pause account.

[17:50] <diakopter> oh, I got that too

[17:50] <rindolf> [Coke]: ah, oh.

[17:50] <rindolf> [Coke]: if she's indeed a she. ;-)

[17:51] <masak> [Coke]: hm, I'm on PAUSE but I don't have any CPAN modules. didn't get a LinkedIn invitation from any Sue.

[17:53] *** cognominal left
[17:54] <BinGOs> I doubt that Sue is aware that linkedIn is doing that

[17:55] <geekosaur> linkedin like to rifle your address book and invite everyone, yeh

[17:55] <cosimo> [Coke]: she's a London.pm member IIRC

[17:55] <nwc10> She has a daughter. And I think I've seen her husband

[17:55] <nwc10> s/seen/met/

[17:55] <nwc10> I've certainly seen pictures

[17:55] <nwc10> so I think the evidence is that she is a she :-)

[18:01] *** cognominal joined
[18:03] <masak> BinGOs, geekosaur: which is why you should never, as a general principle, allow a third-party service to log into your email account.

[18:04] <geekosaur> yep

[18:04] <geekosaur> unforutnately many third party services go to some effort to trick unsuspecting users into allowing it

[18:05] <rindolf> geekosaur: yes. :-(

[18:06] <geekosaur> and/or hide the opt-out

[18:06] <geekosaur> (and then there's the really evil ones; anyone remember spock.com?)

[18:07] *** cognominal left
[18:08] *** dakkar left
[18:09] *** cognominal joined
[18:18] *** xinming left
[18:18] *** kst` is now known as kst

[18:19] <moritz> http://www.perlmonks.org/?node_id=1017212 # Code golf with a readable and short-ish Perl 6 solution

[18:19] *** Chillance joined
[18:20] *** xinming joined
[18:21] <TimToady> masak: yes, GS's definitions are very like how we define our contexts by what we're promising we don't care about

[18:22] <TimToady> he and I have similar ideas on the way forward with parallelism, though obviously he expresses it much better than I do

[18:23] *** cognominal left
[18:23] <TimToady> kind of a shame they gave up on Fortress...

[18:27] <rindolf> TimToady: meow!

[18:27] *** xinming left
[18:28] <TimToady> rindolf: meow meow, meow...

[18:28] <rindolf> TimToady: so nice you have to meow thrice!

[18:29] <rindolf> TimToady: what's up?

[18:29] *** xinming joined
[18:30] <TimToady> I dunno, but whatever it is is stuck in the IO monad...

[18:32] <colomon> moritz++

[18:41] <masak> TimToady: programming seems to map well to a constructivist subset of mathematics, but not always so well to parts involving proofs or infinities. to me, the challenge of what Steele is talking about is to find nice models/isomorphisms that are pleasant to program with.

[18:42] <TimToady> my challenge is a step beyond that, to find models that *other* people find pleasant to program in :)

[18:42] <masak> moritz++

[18:42] <TimToady> in my experience, other people do not always take pleasure in the same things I do...

[18:43] <masak> moritz: I love how we folded the Schwartzian transform into the language, so that it really isn't a trick at all :)

[18:43] <TimToady> yes, moritz++, though I was trying to figure out what the +* prefix operator does...

[18:43] <masak> TimToady: heh.

[18:43] <masak> numify?

[18:43] <masak> oh, you read it as '+*', I see :P

[18:44] <colomon> numify whatever!

[18:44] <TimToady> if I were writing it in production, I'd probably do +(*.split...)

[18:44] * colomon agrees with TimToady 

[18:44] <masak> meh. just learn to read Perl 6 :P

[18:44] <colomon> I actually read it as (+*).split... then realized that didn't make sense

[18:45] <TimToady> there's a real weight problem between the methodcall postfix precedence level and the looser symbolic prefix level

[18:46] <TimToady> I keep wanting special parens that don't require a matching paren

[18:47] <TimToady> could even replace 'do' with the left version of that

[18:48] <moritz> or maybe even *.split(':')[2].Int

[18:48] <TimToady> or that

[18:49] *** arlinius left
[18:49] <masak> moritz: do you ever get chewed out for posting Perl 6 solutions to people's problems on PerlMonks?

[18:50] <TimToady> hope so

[18:50] <TimToady> 'cuz then it means we're to the "Then they fight you" stage

[18:51] <PerlJam> TimToady: but I want to be at the "then you win" stage!  :)

[18:51] <TimToady> we're still in the "ignore you" stage for most of the rest of the world

[18:52] <masak> the problem with the Ghandi model is that projects that ultimately fail also often go through "ignore" and "fight" stages...

[18:52] <masak> er, Gandhi

[18:52] <TimToady> PerlJam: the only thing that will get us there is cussed stubbornness

[18:52] <masak> *

[18:52] * masak .oO( don't let the bastards Gandhi you down )

[18:53] <moritz> masak: rarely. Sometimes people silently upvote it, sometimes they ask how a particular feature works

[18:54] <PerlJam> whenever I give a Perl 6 solution to some Perl 5 problem on #perl (granted, I haven't done that in a while), I get questions about the code or Perl 6 or whatever, but no one has been particularly upset about it

[18:55] *** SunilJoshi1 left
[18:55] <TimToady> in addition to being stuborn, I'm very good at tuning out most of the noise, including the entire maelstrom around forking Perl 5

[18:55] <TimToady> *stubborn

[18:56] <masak> I may have said it already, but my two impressions from talking about Perl 6 at FOSDEM (to mostly Perl 5 people) were similar: (a) people *like* Perl 6, overall, and (b) I had partly forgotten what an improvement it is, and the crowd's reaction reminded me.

[18:57] <rindolf> TimToady: can I PM you for a sec?

[18:57] <masak> both of these surprised me a little. guess using Perl 6 for all these years have gotten me used to how nice it is :)

[18:57] <PerlJam> masak: if only we had an implementation that hit the magic sweet spot of being featureful enough and fast enough  ;-)

[18:57] <rindolf> TimToady: I mean private msg.

[18:57] <masak> PerlJam: featureful, fast, threads, CPAN.

[18:57] <TimToady> darn, was hoping to be a prime minister

[18:58] <TimToady> rindolf: nobody else asks first :)

[18:58] <rindolf> TimToady: I think you should run for .us government.

[18:58] <rindolf> TimToady: OK.

[18:58] <rindolf> TimToady: well, it's common courtesy.

[18:58] <PerlJam> masak: why does everyone want threads?

[18:58] <rindolf> Nobody gets threads! Larry gets threads.

[18:59] <masak> PerlJam: (a) because we promised. (b) because "the free lunch is over" and "welcome to the jungle".

[18:59] <PerlJam> I think "threads" are the catchall for "doing multiple things simultaneously" even if/when we have ways to do that already.

[19:00] <PerlJam> I'm fairly sure many people say "threads" but are really thinking about async IO

[19:00] <PerlJam> (for instancE)

[19:00] <masak> PerlJam: yes, what I really mean is solid support for concurrent and parallel programming.

[19:01] <masak> but events and async sort of gets pulled into that model.

[19:04] <masak> by the way, if anyone likes such topics, check out the Rx framework and "LINQ to events". real cool stuff.

[19:13] *** fhelmberger left
[19:22] *** cognominal joined
[19:23] *** arnsholt joined
[19:23] *** colomon left
[19:24] <arnsholt> 'lo \o

[19:25] *** viewonly left
[19:25] *** Liz joined
[19:25] *** Liz is now known as Guest14460

[19:25] *** benabik joined
[19:27] <arnsholt> phenny: tell jnthn I think I give up this bootstrapping thing. Somehow, once I get NQP updated to the new stuff, I break Rakudo: "Method 'get_lex_type' not found for invocant of class 'Perl6LexPad'" something about "Cannot unbox argument to '$name' as a native str"

[19:27] <phenny> arnsholt: I'll pass that on when jnthn is around.

[19:33] *** geekosaur left
[19:34] *** geekosaur joined
[19:40] *** arlinius joined
[19:49] * masak looks at p6cc2012's t1

[19:53] <tadzik> jnthn: warning: apparently both of my patches to nqp-jvm are Rong :(

[19:53] <tadzik> I'll fix them soon

[19:57] <masak> tadzik: what happened to them why what why

[19:58] <tadzik> masak: they have the 'start' attribute, which I forgot to respect

[19:58] <tadzik> it's almost always 0, except when it's not, e.g. you shift() from the array

[19:58] <masak> ah.

[20:02] <tadzik> so you need specially crafted tests to catch that :)

[20:04] <masak> mmm, tests.

[20:06] <arnsholt> tadzik: What do you mean, tests don't automatically reveal every defect simply by virtue of existing?

[20:06] <arnsholt> I'm shocked, I tell you, shocked =)

[20:07] <masak> remember the lesson of the TDD Sudoku incident.

[20:07] <arnsholt> The TDD sudoku incident?

[20:07] <masak> the TDD Sudoku incident!

[20:07] <arnsholt> Is this like the Perl 6 noodle incident? =)

[20:07] * masak finds link

[20:08] <masak> http://ravimohan.blogspot.se/2007/04/learning-from-sudoku-solvers.html

[20:08] <masak> the takeaway from that post and subsequent discussion -- for me, anyway -- is that TDD is fine as a methodology, but nothing beats knowing what the heck you're doing. knowing APIs, algorithms, data structures.

[20:08] <tadzik> arnsholt: I'm offended

[20:09] *** SmokeMachine left
[20:09] <arnsholt> Indeed. If you're not actually sure what you're making, TDD is only so useful

[20:10] *** colomon joined
[20:10] <arnsholt> Which is why there are no tests yet for the project I started today. Still noodling around and prodding the problem space to see what happens

[20:10] *** bruges joined
[20:12] *** bruges_ left
[20:13] <arnsholt> Is there a Nordic Perl Workshop scheduled for 2013, a propos nothing?

[20:13] <masak> it's on its way, it seems.

[20:14] <masak> Copenhagen! \o/

[20:14] * moritz has fond memory of eating Japenese food and hacking Perl 6 in Copenhagen

[20:15] *** MikeFair_ left
[20:15] *** MikeFair__ joined
[20:15] <masak> moritz: just before the Japanese food, you and I were talking about Eiffel.

[20:15] <swarley> mmmm Eiffel

[20:16] <masak> (I have an episodic memory. when I remember places, soundbites pop up with them.)

[20:16] <moritz> masak: we were? I don't remember the particular details, but I talk about that language occasionally :-)

[20:16] * arnsholt has good memories of Copenhagen as well

[20:17] <masak> moritz: "variants", right? non-negative magnitudes that have to decrease with each loop iteration, proving that the loop terminates.

[20:17] <masak> TimToady: oh!

[20:17] <masak> TimToady: that's an *excellent* example of "comfortably mapping to a constructivist part of math".

[20:17] <moritz> masak: correct. Integers even.

[20:17] <masak> yes, 'course.

[20:18] <moritz> and I remember discussing macros at breakfast, when we both alternated between "oh, looks like closures" and "htf is anybody going to implement that?"

[20:20] *** rindolf left
[20:21] <masak> moritz: we were groping after all the problems I've now identified and solved.

[20:22] <masak> moritz: I distinctly remembered there was something that *bothered* us about the closure-like properties.

[20:22] <masak> like "wait, doesn't it all work out?" -- "hm, oh wait, no..." -- "now I don't even see a problem anymore..."

[20:23] *** Guest14460 left
[20:26] *** benabik left
[20:31] *** benabik joined
[20:32] *** [particle]1 is now known as [particle]

[20:32] *** Liz_ joined
[20:33] *** Liz_ is now known as lizmat

[20:35] <timotimo> masak: you did a talk at fosdem, right? will there be a recording?

[20:35] *** domidumont joined
[20:36] <lizmat> I've made the recording.  Not sure if it is good enough, or complete.

[20:37] <timotimo> fosdem is big, isn't it? why are there no proper recordings of all talks?

[20:37] <lizmat> In any case, it will need to be downgraded to something that is easily downloadable

[20:37] <masak> I think my prepared talk got recorded, but the battery was out by the second, impromptu one.

[20:37] <masak> lizmat! \o/

[20:37] <lizmat> yes, only the first one got recorded

[20:37] <masak> lizmat: thanks again for an awesome weekend. :)

[20:37] <timotimo> proper as in: taking the audio directly from the speaker's microphones

[20:38] <lizmat> masak: you're welcome, it was fun!

[20:38] *** FROGGS joined
[20:38] <masak> lizmat: I'm safely back home. a bit tired, but happy I went.

[20:38] <masak> lizmat: now the only problem is that I will want to do FOSDEM again ;)

[20:38] <tadzik> I'm jealous

[20:38] <lizmat> heheâ€¦  it is addictive, I know

[20:39] <lizmat> I just checked: I got the first 20 minutes, which is almost the whole presentation

[20:39] <lizmat> it is in HD and it is out of focus   :-(

[20:39] <masak> :/

[20:40] <tadzik> slides!

[20:40] <lizmat> but I think good enough to put out in the world

[20:40] <masak> tadzik: coming right up.

[20:40] <tadzik> \o/

[20:40] <tadzik> North, you mean

[20:42] <lizmat> but not today..  we're at the Amsterdam.pm meeting right nowâ€¦

[20:43] <FROGGS> lizmat: and after that you all join booking.com?

[20:43] <masak> tadzik: :P

[20:43] <masak> tadzik: http://masak.org/carl/fosdem-2013-flying-car/talk.pdf

[20:43] <lizmat> FROGGS: been there, done that

[20:43] <masak> *lol*

[20:43] <FROGGS> I've read yesterday they are hunting for 25 devs again

[20:43] <FROGGS> ahh

[20:43] <FROGGS> ;o)

[20:43] <masak> today's laugh. :)

[20:43] <tadzik> :D

[20:43] <tadzik> yeah, Warsaw.pm got the message too

[20:44] <tadzik> I wonder if that means they wish to sponsor PLPW

[20:44] <FROGGS> I guess they would

[20:44] <FROGGS> I'd love to work for them, but I dont wanna move :/

[20:46] <masak> not even... to Sweden? :P :P

[20:47] <masak> (guess who's also hunting for devs)

[20:47] <lizmat> FROGGS: FWIW, if you like working in a fast growing organization in the center of Amsterdam, Booking.com is the place to be

[20:48] *** slavik1 joined
[20:48] <lizmat> but don't expect too much time writing tests (at least not in most of the areas of Booking.com)

[20:49] <lizmat> you should realize that almost all coding at Booking.com is aimed at getting more reservations.

[20:49] <masak> ...which makes sense, since that's what they do ;)

[20:49] <FROGGS> masak++ # the cards example is very good

[20:49] <lizmat> if errors in the code cause more reservations (without causing more cancellations), then the code will stay, even if it was in error  :)

[20:49] <masak> pmichaud++, then :)

[20:49] *** domidumont left
[20:50] <FROGGS> lizmat: I can live with that, currently I have to care what tests I write and which not...

[20:50] <FROGGS> there is nobody who would care

[20:51] <FROGGS> masak: scotland is the only place I'd move to

[20:51] <FROGGS> .... except maybe risa

[20:52] <lizmat> masak: Wendy and I slept most of yesterday, after having brought back the van before 8am  :-)

[20:52] * geekosaur could see moving to sweden, aside from little issues like being able to afford it.  and being rather more sysadmin than dev

[20:52] * colomon would definitely consider moving to Newfoundland....

[20:53] <arnsholt> geekosaur: The main challenge there is getting the job in Scandinavia. The pay scales with the living expenses =)

[20:53] <arnsholt> (Also, greetings fellow XMonader =)

[20:53] <timotimo> i liked the slides already

[20:53] <FROGGS> spaces for free \o/

[20:53] <geekosaur> there's thre challenge of *getting* there...

[20:55] *** bluescreen10 left
[20:55] <FROGGS> the slides are very good, it covers it well

[20:55] <masak> \o/

[20:56] <masak> people were more positive about the live demo, though.

[20:56] <timotimo> what did you demo?

[20:56] <masak> I sat down and started implementing MineSweeper.

[20:56] <masak> TDD style.

[20:56] <timotimo> did you demo the enhanced error messages i recently made? :P

[20:56] <tadzik> cool

[20:56] <timotimo> oh, that's neat

[20:56] <masak> timotimo: oh!

[20:57] <masak> timotimo: I *totally* should've done that, and pretended I had made a typo :P

[20:57] <masak> photo: https://twitter.com/habanerd/status/297753325011628033

[20:57] <timotimo> there's really no need, though ;)

[20:57] <timotimo> i think i'll try to do moreinput today

[21:04] <lizmat> fwiw, Wendy uploaded some time lapse movies from FOSDEM to Youtube

[21:04] <lizmat> http://www.youtube.com/watch?v=5AOUpfAwmAA

[21:07] <skids> masak: why not wait until you do make a typo, and pretend you didn't :-)

[21:07] <cognominal> lizmat:  with some the usual [french] suspects at the left of the first frame (Maddingue, dolmen?, elbeho)

[21:07] <lizmat> indeedâ€¦.  :-)

[21:13] *** benabik left
[21:15] <tadzik> bah. I'm sure my deletepos is buggy, but I can't reproduce a bug :/

[21:16] <arnsholt> I hate those

[21:16] <masak> a... heisenbug?

[21:16] <tadzik> not really

[21:16] <tadzik> it makes me think I don't understand the problem

[21:16] <tadzik> masak, my dear bug wizard..

[21:17] <TimToady> nr: sub r2cf(Rat $x is copy) { gather $x [R/]= 1 while ($x -= take $x.floor) > 0 }; say r2cf(1.4142136)

[21:17] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Preceding context expects a term, but found infix = insteadâ¤at /tmp/WXbDH1h_R_:1â¤------> [32mb r2cf(Rat $x is copy) { gather $x [R/]=[33mâ[31m 1 while ($x -= take $x.floor) > 0 }; sa[0mâ¤Â»

[21:17] <p6eval> ..niecza v24-18-gaf64300: OUTPUTÂ«1 2 2 2 2 2 2 2 2 2 6 1 2 4 1 1 2â¤Â»

[21:17] <TimToady> dunno if you have that one yet

[21:17] *** benabik joined
[21:17] <tadzik> masak: if you could look at https://github.com/tadzik/nqp-jvm-prep/blob/deletepos/src/org/perl6/nqp/sixmodel/reprs/VMArrayInstance.java#L37

[21:17] <masak> don't think so.

[21:17] <FROGGS> TimToady: \o/

[21:17] * masak submits TimToady's rakudobug

[21:18] <tadzik> I think it's wrong 'cos it doesn't respect this.start

[21:18] <FROGGS> TimToady: do you have time to look at my pull request?

[21:18] <tadzik> so in my opinion, a following should trigger a bug:

[21:18] <masak> tadzik: sorry, a bit too distracted right now.

[21:18] <tadzik> oh, sure

[21:18] <masak> tadzik: if you could produce a golfed failing test... :)

[21:18] <tadzik> but that's the problem! :)

[21:18] <masak> yes, I know.

[21:19] <masak> no excuses. try it.

[21:19] <TimToady> FROGGS: I'll try to get to it

[21:19] <masak> if the bug escapes your grasp, it simply means that your net is too sparse.

[21:19] <FROGGS> thanks

[21:19] <FROGGS> :o)

[21:19] <tadzik> masak: that's the whole point. I can't write a failing test :P

[21:20] <raiph__> "Longest token match shouldn't make any difference on the speed of parsing"

[21:20] <raiph__> true? partly? false?

[21:20] <masak> tadzik: then what makes you think it's a bug?

[21:21] <masak> raiph__: compared to ordinary Recursive Descent? I think LTM performs better.

[21:21] <arnsholt> A big piece of code that fails, I guess

[21:21] <tadzik> masak: instinct and pencil+paper simulations

[21:21] <tadzik> and it makes me think I'm stupid :)

[21:21] <masak> tadzik: reduce, reduce, reduce.

[21:22] <masak> tadzik: inside every big interesting problem is a small interesting problem, fighting to get out.

[21:22] <tadzik> I got it reduced to 3 calls, still works

[21:22] <masak> r: my $x; $x [R/]= 1

[21:22] <p6eval> rakudo 935c90: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Preceding context expects a term, but found infix = insteadâ¤at /tmp/95XYnmRMtC:1â¤------> [32mmy $x; $x [R/]=[33mâ[31m 1[0mâ¤Â»

[21:24] <FROGGS> n: my $x; say $x [R/]= 1

[21:24] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«Use of uninitialized value in numeric contextâ¤  at /home/p6eval/niecza/lib/CORE.setting line 1287 (warn @ 5) â¤  at /home/p6eval/niecza/lib/CORE.setting line 294 (Any.Numeric @ 8) â¤  at <unknown> line 0 (ExitRunloop @ 0) â¤  at /home/p6eval/niecza/lib/CORE.sâ€¦

[21:24] <FROGGS> n: my $x = 0; say $x [R/]= 1

[21:24] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«Infâ¤Â»

[21:24] <FROGGS> n: my $x = 1; say $x [R/]= 1

[21:24] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«1â¤Â»

[21:24] <FROGGS> ahh

[21:24] <masak> n: my $x = 1; $x [R/]= 2, 3, 4; say $x

[21:24] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«2â¤Â»

[21:25] <masak> n: my $x = 1; $x [R/]= (2, 3, 4); say $x

[21:25] <p6eval> niecza v24-18-gaf64300: OUTPUTÂ«3â¤Â»

[21:26] <raiph__> masak: the longer comment (by someone else) was "NFA precomputation is constructing an lr-0 or lr-n automaton and using lookahead to eliminate states. Once you have the rule, you can order your backtracking search across the states. For packrat, it goes in left-to-right, for perl 6 rules, it goes by the length. The speed is relatively unchanged by order."

[21:28] <TimToady> .oO("but what's 3 orders of magnitude among friends")

[21:29] <masak> raiph__: ok, then it seems like it's comparing packrat (which I don't know) against LTM.

[21:29] <masak> s/LTM/Perl 6 LTM/

[21:30] <raiph__> masak: my intuition was that for many grammars/inputs LTM declarative prefixes make a good pragmatic match and *would* be significantly faster

[21:30] *** lizmat left
[21:31] *** kaare_ left
[21:31] <masak> raiph__: faster than *what*?

[21:31] <masak> you can't avoid scanning the source string once.

[21:31] <TimToady> well, P6 uses LTM to drive a recursive descent engine, so it really depends on how well we drive :)

[21:32] <masak> I mean, with Boyer-Moore, you can sometimes do good guesses and beat O(n), but...

[21:32] <TimToady> currently we do end up matching everything twice

[21:32] <masak> Recursive Descent is not well-known for being fast, IIUC.

[21:32] <TimToady> in the absence of captures or other side effects, we could optimize away some of the duplicate matching

[21:33] <sorear> masak: The unique morphism from a general set S to a singleton set {x} is... a constant function!

[21:33] <TimToady> masak: that's mostly the fault of precedence hierarchies, which we sidestep

[21:33] <TimToady> and secondarily the fault of making bad probes, which LTM bypasses

[21:35] <masak> sorear: oh urgh. that was too easy :P

[21:36] <TimToady> what you'd really like to do is cache activation records relative to the beginning of the token, then magically do a goto the middle of a matcher that is several levels down, where it will eventually be with the cursor at the end of the token

[21:37] <masak> sorear: does that mean that "doubleton sets" {x, y} are also terminal sets? I'm confuzzled again.

[21:37] <TimToady> but I don't think anyone has invented future continuations quite yet

[21:37] <masak> s/terminal sets/terminal objects/

[21:37] <sorear> masak: No, because there are two inequivalent functions from {x} to {x,y}

[21:38] <sorear> masak: The number of functions from S to T is #T ** #S.  It is 1 if #S == 0 or #T == 1

[21:38] <masak> gotcha.

[21:38] <masak> nice.

[21:38] <diakopter> TimToady: can you explain that more?

[21:39] <TimToady> when you match LTM, the returned "fate" determines the next one or several recursive calls and their associated decisions, until the RD parser catches up to the position that the LTM got to

[21:40] <diakopter> that's conceivably doable

[21:40] <TimToady> it would be nice to have a way to cache those activation records, and any associated new Cursors (they'd have to encode relative positions somehow), such that it looks after taking the "continuation" like you did all the code without doing it

[21:41] <TimToady> well, sure, I just conceived it, but that's not quite doing it  :P

[21:42] <diakopter> I would maintain a stack of descent commands while NFAing

[21:42] <TimToady> I suppose one approach would be to emulate recursive descent with your own stack, making sure that the "continuation" was self contained, then remembering it

[21:43] <TimToady> depending on what you mean by "commands", that's what STD did with its "fates"

[21:43] <TimToady> but that didn't prevent actually having to do the calls afterward

[21:43] <diakopter> which alternation to take

[21:43] <TimToady> that bit is a solved problem

[21:43] <TimToady> STD already did it

[21:44] <TimToady> (not sure if the current version still does though)

[21:45] *** arlinius left
[21:46] <TimToady> I'm talking about doing something a bit more stackless, that you could look at the set of pads and Cursors that would be created by a particular LTM, and somehow bundling that up to a reusable thing you just poke somewhere and you're magically already several levels deep in call, and at the correct cursor position to begin the non-declarative bits of the pattern

[21:47] <TimToady> (I'm not suggesting anyone try this soonish, it's just an idea for an eventual optimization)

[21:47] <TimToady> Cursors currently hold an absolute position, so could not be reused that way without relocation logic

[21:48] *** benabik left
[21:49] <diakopter> which alternation to take, also how many times each quant succeeded

[21:49] <TimToady> and the parser currently relies rather too heavily on dynamic variables, which would also have to be accounted for somehow

[21:49] <masak> TimToady: with enough effort, anything can be CPS-transformed into a state machine. then you can do the trick you mention.

[21:49] <masak> I'd certainly like to try it at some point.

[21:51] <raiph__> TimToady: thanks

[21:52] <TimToady> we're using recursive descent not because it's fast, but because mere mortals can understand it a little more easily; that doesn't preclude cheating^Woptimization, as long as we don't get caught

[21:53] <[Coke]> aloha, seen bacek? 

[21:53] <masak> ENOALOHA

[21:54] <[Coke]> masak: http://irclog.perlgeek.de/search.pl?channel=parrot&nick=bacek&q=aloha

[21:54] <dalek> std: 3725e26 | (Tobias Leich)++ | STD.pm6:

[21:54] <dalek> std: move $( ~ ) into variable token

[21:54] <dalek> std: 

[21:54] <dalek> std: This way contextualizers in code, quotes _and_ regexes behave the same.

[21:54] <dalek> std: review: https://github.com/perl6/std/commit/3725e264b9

[21:54] <dalek> std: da06458 | (Tobias Leich)++ | CORE.setting:

[21:54] <dalek> std: Merge branch 'master' of git://github.com/perl6/std

[21:54] <dalek> std: review: https://github.com/perl6/std/commit/da0645832d

[21:54] <dalek> std: 7551b8f | larry++ | STD.pm6:

[21:54] <dalek> std: Merge pull request #4 from FROGGS/master

[21:54] <dalek> std: 

[21:54] <dalek> std: move $( ~ ) into variable token

[21:54] <dalek> std: review: https://github.com/perl6/std/commit/7551b8f9d5

[21:54] <[Coke]> at a guess, we might have lost any data it had accumulated.

[21:55] <FROGGS> yay

[21:55] <TimToady> FROGGS++

[21:55] <raiph__> FROGGS++

[21:56] <FROGGS> thanks :o)

[21:56] <[Coke]> who maintains dalek on feather? can we run aloha next to dalek?

[21:56] <TimToady> FROGGS++  # for persistence

[21:56] <raiph__> TimToady++ # for persistence (25 years and counting)

[21:57] <TimToady> .oO("He was fishing with the persistence that many mistake for patience." --Field and Stream)

[22:00] *** benabik joined
[22:00] <TimToady> I remember reading that when I was a teenager.

[22:04] <masak> TimToady: Leslie Hawthorn's FOSDEM talk about community leaders made me ask myself whether you've ever had a burnout relating to the Perl venture.

[22:04] <raiph__> TimToady: what a striking quote

[22:06] *** skids left
[22:10] *** PacoAir left
[22:11] *** am0c left
[22:14] *** donaldh joined
[22:15] <TimToady> masak: as long as each burnout is matched by a subsequent burnin, nobody can tell the difference between that and bipolar disorder :)

[22:17] *** Juerd left
[22:17] *** Juerd joined
[22:17] *** spider-mario left
[22:19] <masak> I guess. :)

[22:20] <masak> TimToady: was there ever a point when you went, "hm, this Perl thing could turn out to be quite popular. maybe even dozens of users"? :)

[22:22] <TimToady> I never didn't think that.

[22:23] <TimToady> I'd already released several popular things.

[22:23] <TimToady> so Perl was born popular :)

[22:23] <masak> hehe.

[22:26] *** cognominal__ joined
[22:28] *** cognominal left
[22:30] <swarley> I wish I better understood how virtual machines work, I always day dream about having the know how to plan it out. I made my own tiny little vm once, but it was just like ObjC's retain/release, didn't really do much

[22:32] <masak> swarley: follow your dreams. learn by building stuff.

[22:32] <geekosaur> they execute code, they provide some way t evoke system services from the vmm (either via emulated hardware or special instructions)

[22:34] <swarley> well that I understand

[22:34] <geekosaur> and there are different varieties of virtual machine --- they can emulate hardware like vmware/parallels/virtualbox, or provide their own custom environment like the JVM/CLR/most Smalltalk VMs, or be something like LLVM which is sort of the latter but whose bytecode can be further "compiled" into optimized (if suitably annotated) native code

[22:34] <swarley> But there is much more theory to it than that, that i don't understand

[22:36] <dalek> nqp: 09bd1bc | (Tobias Leich)++ | src/QRegex/P6Regex/ (2 files):

[22:36] <dalek> nqp: removed metachar:sym<$( )>

[22:36] <dalek> nqp: 

[22:36] <dalek> nqp: Which was my first approach to support contextualizers.

[22:36] <dalek> nqp: Since this is not the way STD does it, and since it doesnt work right,

[22:36] <dalek> nqp: it gets reverted.

[22:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/09bd1bc7bc

[22:36] <dalek> nqp: 1fb778f | (Tobias Leich)++ | src/HLL/Grammar.pm:

[22:36] <dalek> nqp: move <sigil> and <twigil>

[22:36] <dalek> nqp: 

[22:36] <dalek> nqp: ... to HLL::Grammar since we are using it from NQP::Grammar

[22:36] <swarley> the main issue i have is  thinking of how to abstract types, like the idea of class inheritance is very blurry for me when i start thinking as to how it would be when everything is compiled

[22:36] <dalek> nqp: and Perl6::Grammar.

[22:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1fb778ff13

[22:36] <dalek> nqp: 2c13753 | (Tobias Leich)++ | src/NQP/ (2 files):

[22:36] <dalek> nqp: move $( ~ ) into variable token

[22:36] <dalek> nqp: 

[22:36] <dalek> nqp: This way contextualizers in code, quote and regexes do all the same,

[22:36] <dalek> nqp: and we can get rid of circumfix:sym<sigil>.

[22:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2c13753ac8

[22:37] <dalek> rakudo/nom: d77b765 | (Tobias Leich)++ | / (3 files):

[22:37] <dalek> rakudo/nom: move $( ~ ) into variable token

[22:37] <dalek> rakudo/nom: 

[22:37] <dalek> rakudo/nom: Contextualizers do work and litvar.t is parseable now.

[22:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d77b7656df

[22:37] <dalek> rakudo/nom: 0dda4c8 | (Tobias Leich)++ | tools/build/NQP_REVISION:

[22:37] <dalek> rakudo/nom: bump NQP revision

[22:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0dda4c8712

[22:38] <swarley> And prehaps more sophisticated garbage collection techniques

[22:39] *** cognominal__ left
[22:39] <benabik> GC is "exciting" to program, since errors express themselves as creeping memory corruption instead of big errors.

[22:40] *** cognominal__ joined
[22:42] <swarley> I really wish I had a better idea of how to implement a language like nqp. It's quite fascinating. I stopped development on the nqp-yarv because i benchmarked a large code sample and it's terribly inefficient.. I'd love to try it in llvm, but I really know next to nothing about llvm

[22:43] <benabik> NQP on LLVM would be interesting, but also painful.  LLVM provides _no_ language support, so you have to build everything from scratch.

[22:43] <benabik> Things like GC, objects, IO, etc.

[22:43] <swarley> ah

[22:44] <swarley> Well, I don't imagine it would be too terrible

[22:44] <benabik> It is a *low-level* virtual machine, after all.  :-D

[22:44] <swarley> I think the hardest part would just be learning llvm

[22:44] <swarley> I was trying to decide on a parser generator. I'm not sure if I want to go with flex/bison or ANTLR3

[22:45] <PerlJam> swarley: Perl 6  ;)

[22:45] <swarley> I want it output in C/C++ :p

[22:46] <swarley> I looked at lemon, and I thought it was neat, until I saw how terribly inconvenient it was

[22:46] <PerlJam> Using Perl 6 does not preclude outputting C

[22:46] <PerlJam> :-)

[22:46] <swarley> Oh, I suppose you're right..

[22:46] <tadzik> swarley: did you consider JVM?

[22:47] <swarley> We already have nqp-jvm, I believe jnthn is working on it

[22:48] <swarley> hm.. I wonder how I would output C++ with perl6

[22:48] <tadzik> yeah

[22:48] <tadzik> it's pretty nice, if you ask me :) nqp-jvm

[22:48] *** shinobicl left
[22:48] <tadzik> and performance is promising so far, even surpassing Perl 5

[22:48] <swarley> I guess I would create nodes and just have them dump to text?

[22:49] <benabik> swarley: You can skip the nodes if you don't intend to manipulate them.  Just have action methods that print code.

[22:50] <swarley> I'm not sure really. I need to learn more about llvm

[22:50] <swarley> I have __no__ idea how it does classes

[22:50] <benabik> It doesn't.

[22:50] <swarley> yeah, i know

[22:50] <swarley> I mean how it fakes them

[22:51] <swarley> Or how _you_ would fake them

[22:51] <swarley> Well, NQP isn't supposed to have dynamically generated methods is it?

[22:51] <benabik> Any way you want.  :-D  Learning LLVM is not so different from learning assembly.

[22:51] <swarley> You say that like it's not a bad thing :p

[22:52] *** shinobicl joined
[22:52] <benabik> I'm a big fan of learning how computers actually do their thing.  High-level languages are great, but if you don't know how it's put together you can create horrible code.

[22:53] <swarley> Yeah, I like assembly, but it's not a walk in the park to learn

[22:53] <timotimo> first attempt at "moreinput" handling in rakudo is compiling now :)

[22:53] <timotimo> i've got pretty much no idea how to properly test this short of running a perl6 interpreter and communicating with it, or writing a different frontend or something

[22:54] <dalek> roast: cdf2b0a | (Tobias Leich)++ | S05-metasyntax/litvar.t:

[22:54] <dalek> roast: first tests for contextualizer $( ), cleanup

[22:54] <dalek> roast: review: https://github.com/perl6/roast/commit/cdf2b0a3ec

[22:54] <benabik> To some extent, LLVM IR is assembly-lite.  It handles things like register allocation, calling conventions, etc.

[22:56] <timotimo> it seems like i broke it

[22:56] <swarley> Oh alright.. I see how you fake classes in llvm

[22:57] <benabik> s/fake/implement/

[22:57] <swarley> I prefer fake

[22:57] <swarley> Because it's not a class

[22:57] <swarley> It's a struct

[22:57] <geekosaur> how do you fake classes in x86 assembly?  much the same answer for llvm...

[22:57] <swarley> And then you just name the functions with a namespace

[22:57] <geekosaur> "class" is kinda at a diferent level of abstraction

[22:58] <geekosaur> whicg gets back to what I was saying about the different kinds of VMs

[22:59] <timotimo> i kind of dislike that rakudo signalises "wrong grammar" not by an error but by not terminating when trying to build the seting :(

[23:05] *** FROGGS left
[23:09] *** colomon left
[23:11] <timotimo> oh, *now* it compiles

[23:11] *** cognominal__ left
[23:12] *** cognominal joined
[23:12] *** pmurias joined
[23:12] <swarley> It would be neat to use the erlang vm as well. But I'm sure that, that is more hellish than llvm

[23:13] <pmurias> swarley: re terribly inefficient, yarv itself or the code nqp-yarv generated?

[23:13] <swarley> the way that you have to load the yarv sequence

[23:13] *** benabik left
[23:13] <swarley> it turns into a massive ruby data structure

[23:14] <swarley> There is no way to just use the yarv vm independently as of yet

[23:15] <pmurias> and creating the data structure is slow? or converting it to yarv bytecode?

[23:15] <swarley> It's just that once your program gets anywhere past a few tens of lines, you have a thousand element array

[23:16] <swarley> so, trying to run NQP would end up with a massive array sitting in memory

[23:17] <pmurias> shouldn't the number of opcodes for a line be relatively small?

[23:17] <pmurias> like 10x 

[23:19] *** donaldh left
[23:19] <swarley> well, each opcode is wrapped in an array

[23:19] <swarley> and each arg, if it's any sort of complex type

[23:20] <swarley> is wrapped in an array

[23:20] <swarley> I'll continue the project if they expose an API for compiling it to actual bytecode that doesn't require it to be in a ruby data structure

[23:20] <jnthn> phenny: tell me stuff

[23:20] <phenny> Hey, I'm not as stupid as Monty you know!

[23:21] <phenny> jnthn: 19:26Z <arnsholt> tell jnthn I think I give up this bootstrapping thing. Somehow, once I get NQP updated to the new stuff, I break Rakudo: "Method 'get_lex_type' not found for invocant of class 'Perl6LexPad'" something about "Cannot unbox argument to '$name' as a native str"

[23:21] *** cognominal left
[23:21] <jnthn> phenny: tell arnsholt I'll look at it once I'm home tomorrow, or maybe on Thursday when I don't have to care about anything other than Perl 6 stuff :0

[23:21] <phenny> jnthn: I'll pass that on when arnsholt is around.

[23:21] <timotimo> this moreinput stuff doesn't quite seem to work yet >_<

[23:22] *** cognominal joined
[23:22] <swarley> i dislike that the parsing method that llvm recommends is just creating your own

[23:23] <swarley> i can't imagine doing that for anything of scale

[23:23] <pmurias> you mean just creating your own parser?

[23:24] <pmurias> swarley: which ruby version do I need for RubyVM::InstructionSequenceâ€‹.load(iseq_structure) to work?

[23:25] <timotimo> not being able to debug the grammar rakudo uses to parse your code makes this a bit harder than i'd like :(

[23:26] <jnthn> swarley: The ONLY way that is sane to parse Perl 6 (NQP included) is to write the grammar in perl 6.

[23:27] <timotimo> (which is still better than how to parse perl5)

[23:27] <jnthn> Which menas you take an existing Perl 6 of NQP parser and write a backend.

[23:27] <timotimo> Error while compiling, type X::::::::C::o::m::p::::::::N::Y::I  feature: multi-dimensional indexes  -  lol wut?

[23:28] <diakopter> lol

[23:28] *** cognominal left
[23:29] <masak> something went wrong in that error message... :)

[23:29] <timotimo> can't hack on the grammar without weeeiird things happening

[23:30] <huf> still not as good as Error: Success (0)

[23:30] <timotimo> yeah, but at least that one's understood pretty well

[23:30] *** cognominal joined
[23:31] <pmurias> jnthn: what features of NQP make it diffcult to parse?

[23:32] <timotimo> did moreinput work in STD at all, ever?

[23:32] <swarley> pmurias, 2.0

[23:32] *** skids joined
[23:32] <pmurias> jnthn: it has a inmutable grammar, so any old tool (yacc, handcoded recursive descent) should be sane

[23:32] *** stopbit left
[23:32] <timotimo> it seems like a good idea to put an alteration into <ws> to match end-of-string and then grab more text, but it doesn't seem like it gets hit at all?!

[23:33] <swarley> jnthn, why is it insane to try something else?

[23:33] <pmurias> swarley: because the grammar in Perl6 is extendable

[23:34] <jnthn> OK, fine, do what you like. I don't care, I'll do it the way I've spent the last however meany yars figuring out.

[23:34] <swarley> i was just wondering

[23:34] <jnthn> Because it all hangs of protoregexes and they hang off LTM.

[23:35] <pmurias> jnthn: that was aimed at me?

[23:35] <jnthn> Doing a Perl 6 parser depends on being able to mix in to the grammar. The roles you mix in then in turn affect LTM.

[23:35] <masak> 'night, #perl6

[23:35] <diakopter> o/

[23:36] <jnthn> pmurias: Not aimed at anyone, just general frustration at trying to do stuff in ways I know won't lead to something viable to build a Perl 6 implementation on...

[23:36] <jnthn> anyways, sleep &

[23:36] <timotimo> night masak!

[23:36] <timotimo> night jnthn :)

[23:37] <pmurias> jnthn: night

[23:37] <swarley> so wait.. The language can change itself at compile time?

[23:37] <timotimo> sure, it's called Slangs

[23:37] <jnthn> swarley: Yes, and Perl 6 does every time you declare a custom operator.

[23:37] <timotimo> also, every time you add an operator it happens

[23:37] <timotimo> and macros can have "is parsed /regex/"

[23:38] <swarley> alright then..

[23:38] <swarley> that seems like it would make lexing terrible

[23:38] <pmurias> jnthn: re frustration, we should have an perl6-implementation-faq "why don't we use llvm?" ;)

[23:38] <timotimo> so, in a perl6 grammar, $ should match "end of string", right? and $( .meth ) should call .meth and try to parse the return value?

[23:38] <diakopter> what's this thing you call lexing

[23:39] <jnthn> That's why Perl 6 grammars generate the lexer rather than making he user do it ;)

[23:39] <jnthn> pmurias: Yes, probably :)

[23:39] <swarley> well then

[23:39] <pmurias> jnthn: elf had a grammar written in ruby (handcompiled from STD)

[23:39] <swarley> this sounds like i'm.. in for not having a fun time!

[23:40] <pmurias> jnthn: it was definitely insane

[23:40] <jnthn> Porting NQP is *hard*. But if it's ported and self-hosts then there's a good chance of running on Raudo.

[23:40] <timotimo> or should that really be { $Â¢.moreinput }

[23:40] <timotimo> like in STD? because that didn't seem to work in rakudos grammar at all :(

[23:40] <diakopter> jnthn: it's not hard; I ported 8 rakudos before breakfast

[23:40] <timotimo> jnthn: did you mean "running Rakudo"?

[23:40] <jnthn> timotimo: yes, sorry

[23:41] <jnthn> EVERYTIRED :)

[23:41] <diakopter> every tire what?

[23:41] <timotimo> man who runs in front of car gets tired, man who runs behind car gets exhausted

[23:41] <timotimo> it's as easy as that

[23:41] <jnthn> timotimo: *lol*

[23:42] <skids> :D

[23:42] <pmurias> jnthn: go to sleep, you can always backlog later ;)

[23:42] <timotimo> unfortunately you can't throw in remarks and comments into the backlog

[23:42] <jnthn> pmurias: Yes, I took your JavaScript effort much more enthusiasticly since I saw the bounded serialization stuff getting ported. A good port of that and 6model and the grammar engine = we can really get Rakudo on JavaScript :)

[23:43] <skids> .oO(MST6P?)

[23:45] <timotimo> https://github.com/perl6/std/blob/master/STD.pm6#L626 - would this even work in rakudo? i'm not even sure any more if it could, or why.

[23:45] *** thundergnat joined
[23:46] <jnthn> timotimo: Well, that's like { $/.CURSOR.moreinput }

[23:46] <jnthn> timotimo: The hard part is writing moreinput

[23:46] <jnthn> timotimo: Take a look at ParseCommon or something in src/nqp/Cursor.nqp

[23:47] <timotimo> it seemed like i would just have to return a string with more text, that's obviously wrong?

[23:47] <timotimo> the point is, moreinput isn't even being called when i write incomplete things

[23:47] <jnthn> timotimo: No, you need to diddle the orig and target in parsecommon :)

[23:47] <jnthn> m

[23:47] <jnthn> oops

[23:47] <timotimo> diddle, eh?

[23:47] <jnthn> timotimo: A few months ago we didn't even have the parse common thing, so this woulda been practically impossible to implement :)

[23:48] <timotimo> heh. all right

[23:48] <jnthn> I changed it partly for doing highwater stuff, but also for moreinput and for textual macros ;-)

[23:48] <timotimo> oh, textual macros, eh?

[23:48] <jnthn> Anyway, you can now change the target string the grammar is parsing.

[23:49] <timotimo> src/QRegex/Cursor, this one?

[23:49] <jnthn> aye

[23:50] <timotimo> i don't see a parsecommon in there :(

[23:50] <timotimo> maybe ParseShared?

[23:50] <jnthn> That's 'cus it's called ParseShared :)

[23:50] <jnthn> It's $!orig and $!target in there that need to change when there's more input.

[23:51] <timotimo> right. would i then restart the parse from the beginning, though?

[23:52] * lue wonders what moreinput is

[23:53] <timotimo> lue: when you type something like sub blubb() { and hit newline, in "good" repls, you're asked to enter another line

[23:53] <thundergnat> jnthn: Is there any way to manually refresh the method cache for augmented types? 

[23:53] <timotimo> rakudo will currently just say "there's stuff missing!" and you'd have to retype everything into one line

[23:53] <lue> ah, OK

[23:54] <timotimo> i see i bit off more than i can chew ... again

[23:55] <jnthn> thundergnat: It's the method cache of its subtypes that is the problem.

[23:55] <thundergnat> Yeah

[23:55] <jnthn> thundergnat: SubType.^publish_method_cache() # should do it

[23:56] <thundergnat> That has to be done for each subtype I want to see the method?

[23:56] <jnthn> thundergnat: Yeah. I need to fix it to actually do sub kinda publish/subscribe. Problem: anonymous subtypes (like mixins) need it to be a weak ref...

[23:56] <jnthn> Which is...fun ;)

[23:57] <thundergnat> Heh... I could imagine...

[23:58] <jnthn> It's on my todo list. But my todo list is like...well. :)

[23:58] <timotimo> i suppose i'll try to do i another time

[23:58] <moritz> jnthn: I tried to make variables in sink context warn, but the problem is that we introspect the LHS QAST tree for stuff like binding and assignment

[23:59] <thundergnat> jnthn: Yeah... I could imagine that too. Thanks. 

[23:59] <moritz> and also it immensely increased the size of the QAST tree when I wrapped each variable in a QAST::Want

[23:59] <jnthn> moritz: Yeah, but maybe the optimizer can track it.

[23:59] <moritz> jnthn: so my next idea: maybe we could set up a callback in QAST::Compiler that is called for each QAST node in void context that's not a QAST::Want

