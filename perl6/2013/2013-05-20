[00:03] *** census left
[00:10] *** chrisdev joined
[00:28] *** tgt left
[00:46] *** Chillance left
[00:48] *** kurahaupo left
[00:48] *** colomon joined
[00:53] *** kurahaupo joined
[00:58] *** raiph joined
[01:09] *** anuby joined
[01:26] *** [particle] joined
[01:27] *** woosley joined
[01:30] *** bonsaikitten is now known as AmazingPudding

[01:54] *** FROGGS_ joined
[01:58] *** FROGGS left
[02:02] *** lustlife joined
[02:15] *** chrisdev left
[02:16] *** chrisdev joined
[02:30] *** adu joined
[02:33] *** jaldhar joined
[02:35] *** chrisdev left
[03:24] *** btyler joined
[03:36] *** eternaleye left
[03:40] *** eternaleye joined
[03:58] *** btyler left
[03:59] *** cognominal__ joined
[04:00] *** preflex_ joined
[04:01] *** preflex left
[04:01] *** preflex_ is now known as preflex

[04:03] *** cognominal left
[04:09] *** kaleem joined
[04:19] *** raiph left
[04:22] *** raiph joined
[04:25] *** Psyche^ joined
[04:28] *** Patterner left
[04:28] *** Psyche^ is now known as Patterner

[04:29] *** AmazingPudding is now known as bonsaikitten

[04:38] *** adu left
[04:39] *** adu joined
[05:00] *** snoopy joined
[05:06] *** skids left
[05:07] *** SamuraiJack joined
[05:25] *** SamuraiJack_ joined
[05:27] *** SamuraiJack left
[05:28] *** SamuraiJack joined
[05:45] *** dmol joined
[06:02] *** dmol left
[06:13] *** PacoAir left
[06:16] *** kaare__ joined
[06:52] *** arlinius left
[07:13] *** celo joined
[07:14] <dalek> roast: fab6f8e | (Brent Laabs)++ | S02-names/bare-sigil.t:

[07:14] <dalek> roast: tests for RT #116521, bare sigils as placeholder variables

[07:14] <dalek> roast: review: https://github.com/perl6/roast/commit/fab6f8ed0d

[07:20] *** celo left
[07:23] *** cosimo left
[07:23] *** cosimo joined
[07:24] <dagurval> r: role B { }; class A does B { multi method new($x) { self.bless(*, { }) } }; A.new

[07:24] <camelia> rakudo 0c1499:  ( no output )

[07:24] <dalek> rakudo/nom: 8d2ec91 | (Brent Laabs)++ | t/spectest.data:

[07:24] <dalek> rakudo/nom: add S02-names/bare-sigil.t to spectest

[07:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d2ec912ca

[07:24] <dagurval> Is this a rakudobug right?

[07:24] <dagurval> It shouldt get the default constructor from role B

[07:25] <dagurval> r: class A { multi method new($x) { self.bless(*, { }) } }; A.new

[07:25] <camelia> rakudo 0c1499:  ( no output )

[07:25] <dagurval> oh, it's not the role. It's because of multi

[07:25] <dagurval> r: class A { method new($x) { self.bless(*, { }) } }; A.new

[07:25] <labster> it's a multi method, so it's still inheriting from Any

[07:25] <camelia> rakudo 0c1499: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in method new at /tmp/GhrSrsU4H1:1‚ê§  in block  at /tmp/GhrSrsU4H1:1‚ê§‚ê§¬ª

[07:27] <dagurval> how do I delete the default constructor?

[07:28] <sorear> don't use multi.

[07:29] <dagurval> that's not an answer. I may need multiple constructors, but not an empty one.

[07:29] <dagurval> for example, to fix this bug:

[07:29] <dagurval> r: DateTime.new.say

[07:29] <camelia> rakudo 0c1499: OUTPUT¬´use of uninitialized value of type Int in string context  in block  at /tmp/JFwMwXXfkV:1‚ê§‚ê§DateTime.new(year => , month => 1, day => 1, hour => 0, minute => 0, second => 0.0)‚ê§¬ª

[07:31] <labster> multi new () { fail "must provide arguments to DateTime.new()" };

[07:33] <labster> er, multi method new

[07:34] <dagurval> ok, needs to be explicit. I think it's weird behaviour to have a implicit empty new, if there exist others.

[07:34] <dagurval> At least from me, used to C++.

[07:34] <dagurval> s/from/for/

[07:35] <labster> Perl: DWIMing except when it doesn't.

[07:36] <dagurval> hehe :)

[07:36] <labster> once Europe wakes up, they may have better suggestions for you.

[07:37] * dagurval is in urope o/

[07:37] <dagurval> but I have a kid that drags me up at 06am, so I guess that doesn't count :)

[07:37] *** FROGGS_ left
[07:40] <labster> oh yeah, dagurval++ thanks for fixing my dir() bug, but I totally didn't notice your pull request until I had after I had submitted by own.

[07:40] * moritz is awake agion

[07:40] <moritz> *again

[07:41] *** FROGGS_ joined
[07:42] *** FROGGS_ is now known as FROGGS

[07:44] <dagurval> labster: no problem :) labster++ for nice new dir() roast tests

[07:44] <labster> I need to rewrite io-path.t too...

[07:51] *** arlinius joined
[07:59] *** rindolf joined
[08:03] *** adu left
[08:04] *** SamuraiJack__ joined
[08:04] *** SamuraiJack left
[08:16] *** kurahaupo left
[08:18] *** xilo left
[08:19] *** xilo joined
[08:20] <lizmat> morning #perl6!

[08:23] <sorear> o/ lizmat

[08:26] <labster> Hi lizmat!

[08:26] <lizmat> hi sorear, labster!

[08:32] *** salv0 left
[08:44] *** dakkar joined
[08:46] *** domidumont joined
[08:56] *** fgomez left
[08:57] <masak> good antenoon, #perl6

[08:59] <moritz> \o masak, labster, lizmat, *

[09:01] <lizmat> wrt to .hash(‚Ä¶), how can I check if a (named) parameter has been passed with "Any" ?

[09:02] <lizmat> r: sub a (:$type) { say "type=$type" }; a; a(type=>Any)

[09:02] <camelia> rakudo 8d2ec9: OUTPUT¬´use of uninitialized value of type Any in string context  in sub a at /tmp/mNmATtWDzJ:1‚ê§‚ê§type=‚ê§use of uninitialized value of type Any in string context  in sub a at /tmp/mNmATtWDzJ:1‚ê§‚ê§type=‚ê§¬ª

[09:02] <masak> ah, the old "how can I tell if a parameter has been passed" question? :)

[09:02] <masak> lizmat: you set it to an unpassable default, and test against that default ;)

[09:02] <masak> yes, it's a workaround, but it's what we have.

[09:03] * masak digs up the appropriate RT ticket

[09:03] <sorear> .oO(you set :opt_flag on the next parameter)

[09:03] <lizmat> my first guess was using Mu   , but that bombs

[09:03] <masak> tee hee

[09:03] <lizmat> r: sub a (Mu :$type Mu) { say "type=$type" }; a; a(type=>Any)

[09:03] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/oi0RLGu_yL:1‚ê§------> [32msub a (Mu :$type [33m‚èè[31mMu) { say "type=$type" }; a; a(type=>Any[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§        new nam‚Ä¶

[09:03] <masak> lizmat: yeah, that clashes with junctionality, methinks.

[09:03] <masak> lizmat: missing an '=' there

[09:04] <lizmat> r: sub a (Mu :$type= Mu) { say "type=$type" }; a; a(type=>Any)

[09:04] <camelia> rakudo 8d2ec9: OUTPUT¬´use of uninitialized value of type Mu in string context  in sub a at /tmp/r3Ad3DmKvq:1‚ê§‚ê§type=‚ê§use of uninitialized value of type Any in string context  in sub a at /tmp/r3Ad3DmKvq:1‚ê§‚ê§type=‚ê§¬ª

[09:05] <sorear> masak: You can't set an unpassable default

[09:05] <lizmat> except that we wanted Mu as well...

[09:05] <lizmat> only an improbably default

[09:05] <lizmat> *improbable

[09:05] <moritz> well, there's one way

[09:06] <moritz> r: my $a = []; sub f($d = $a) { say $a === $d }; f(); f([]);

[09:06] <camelia> rakudo 8d2ec9: OUTPUT¬´True‚ê§False‚ê§¬ª

[09:06] <lizmat> as long as $a is "secret", that should work...

[09:06] <moritz> if you make sure that $a doesn't leak to the outer scope, it's a unique object that a caller can't reproduce

[09:06] <moritz> exactly

[09:06] <masak> sorear: sure you can. just use a singleton object of an anonymous class.

[09:06] <lizmat> moritz++

[09:06] <sorear> moritz: isn't there a way to get at the default through the MOP?

[09:07] <masak> ah, moritz++ had the same idea but with an array.

[09:07] <moritz> sorear: through introspection, yes

[09:07] <moritz> but well, if the caller goes to *those* lengths to fool us, I guess he deserves to get the result of us being fooled :-)

[09:08] * masak .oO( you can always hack the system by bombarding the CPU with alpha particles )

[09:09] <sorear> r: sub a($x = ($*passed = True)) { my $*passed; say $*passed }; a(2); a()

[09:09] <camelia> rakudo 8d2ec9: OUTPUT¬´(Any)‚ê§True‚ê§¬ª

[09:09] <sorear> er, that logic is backward

[09:09] <moritz> s:g/passed/default/

[09:09] <moritz> sorear++

[09:10] <masak> najs.

[09:10] *** domidumont left
[09:11] <masak> r: sub a($x = (class { method gist { "DEFAULT" } }).new) { say $x }; a(42); a()

[09:11] <camelia> rakudo 8d2ec9: OUTPUT¬´42‚ê§DEFAULT‚ê§¬ª

[09:11] <masak> if you expect to be doing that a lot, but the anonymous class instantiation in a sub.

[09:12] * lizmat hopes for some less convoluted syntactic sugar

[09:13] *** domidumont joined
[09:13] <moritz> the usual approach is just to test .defined, and take an undefined value as a synonym for missing values

[09:13] <moritz> ater all, how often do you want undefined to behave differently than not-supplied?

[09:13] <masak> yeah, this is called the "predicate problem" IIRC. the LISP people were already well aware of it early on.

[09:14] <masak> it's one of those problems, it's only really problematic if you stop and think for a while :)

[09:14] <masak> take JavaScript's notion of "truthy" values, for example.

[09:14] <masak> you check if a function is defined by just checking the truthiness of a slot.

[09:14] <moritz> so the solution is not to stop and think about it? :-)

[09:14] <masak> yeah, basically.

[09:14] <masak> that works because functions are objects are always truthy by definition.

[09:15] * lizmat already stopped thinking about *that*

[09:15] <masak> now, *theoretically*, someone may have put a 0 or an "" in that slot.

[09:15] <masak> then it's their loss.

[09:15] <moritz> but in Perl 6, you'd better not do that (check the truthiness of code objects)

[09:15] <lizmat> I'm still not however sure how to introspect type from a given hash

[09:15] <masak> ah, https://en.wikipedia.org/wiki/Semipredicate_problem

[09:15] <masak> lizmat: finally found it: https://rt.perl.org/rt3/Ticket/Display.html?id=64928

[09:15] <moritz> because regexes are also code objects

[09:15] <moritz> and if you check their truthiness, they match against $_

[09:16] <masak> (RT croaked on me when I searched, but I found it through Gmail)

[09:16] <moritz> which... might not be what you expected

[09:16] <masak> moritz: ooh, that's a good point. dangerous.

[09:16] <moritz> (which happened to me once inside the backtrace printer; masak++ reported that shortly before the Oslo hackathon)

[09:16] <masak> moritz: that's what I mean by "equal and opposite WAT" :)

[09:17] <masak> afk &

[09:23] *** eternaleye left
[09:25] <sorear> allow me to bring up a different perspective

[09:26] * moritz allows it

[09:26] <sorear> in general, you write functions because you want them to be called

[09:26] <labster> o/ moritz, masak

[09:26] <sorear> when you're wrapping a function in another function, often you want to pass some subset of arguments straight through

[09:26] * tadzik got a US visa o/

[09:26] <FROGGS> morning @all

[09:26] <lizmat> tadzik++

[09:27] <sorear> if you distinguish "not passed" from "default", you're making it unnecesarilly difficult to make useful wrappers

[09:27] <lizmat> morning tadzik, FROGGS

[09:27] <moritz> tadzik: congratulations on you fooling them into believing you're not a terrorist

[09:27] <sorear> tadzik: grats!

[09:27] <tadzik> that was funny

[09:27] <moritz> sorear: I agree

[09:27] <tadzik> I had an appointment at 9. I had to wait 20 minutes in the first queue to be let into the second queue. In the second queue there were 60 people before me

[09:27] <FROGGS> lizmat: I think I solved my problem from yesterday

[09:27] <lizmat> r: my $d=[]; class A { method a( :$type ) { say $type === $d ?? "DEFAULT" !! "SPECIFIED" }}; my $a=A.new; $a.a  # seems the === trick is not working?

[09:27] <camelia> rakudo 8d2ec9: OUTPUT¬´SPECIFIED‚ê§¬ª

[09:28] *** spider-mario joined
[09:28] <sorear> lizmat: you forgot the = $d

[09:28] <lizmat> duh

[09:28] <lizmat> r: my $d=[]; class A { method a( :$type = $d) { say $type === $d ?? "DEFAULT" !! "SPECIFIED" }}; my $a=A.new; $a.a  # seems the === trick is not working?

[09:28] <camelia> rakudo 8d2ec9: OUTPUT¬´DEFAULT‚ê§¬ª

[09:28] <lizmat> sorear++ for the reality check

[09:28] <FROGGS> lizmat: I'm augmenting types like Str by adding methods like P5Stringy, and these will be used by the ast produced by Perl5::Actions

[09:29] <labster> tadzik: I apologize for my country's visa process.

[09:29] <lizmat> sounds cool

[09:29] <tadzik> labster: no need, I don't believe it's your fault

[09:29] <FROGGS> lizmat: this way, a variable defined in v6-land will behave fivy in v5, and sixy everywhere else

[09:29] <tadzik> the upside is that's it's valid 10 years

[09:29] <FROGGS> (and will do the same when declared in v5 land)

[09:30] <tadzik> hopefully in 10 years Poland will be considered civilized enough

[09:30] <sorear> 10 years is a long time.  10 years ago my politics were basically the diametric opposite of what they are now.

[09:31] <labster> Long enough to make a Perl 6, one would think :/

[09:31] * moritz must visit Poland to inspect if it's civilized enough :-)

[09:32] <tadzik> please do :)

[09:33] <tadzik> labster: or a C99 implementation... ;)

[09:34] <sorear> plenty of C99 implementations exist today.

[09:34] <tadzik> is any of them complete?

[09:34] <tadzik> at least gcc isn't

[09:35] <moritz> I thought most of them were, except for the microsoft compiler

[09:35] <tadzik> http://gcc.gnu.org/c99status.html has plenty fields Missing

[09:35] <tadzik> it's more complete than perl6.org compilers matrix, but still :)

[09:36] *** ChanServ sets mode: +o moritz

[09:36] <sorear> the missing parts of c99 are the parts nobody uses anyway

[09:36] *** moritz sets mode: -o moritz

[09:36] <sorear> getting ready to kick me? :p

[09:37] <moritz> sorear: no, accidentally op'ped me in the wrong channel

[09:37] <moritz> :-)

[09:37] * moritz wanted to set a /topic elsewhere

[09:38] <labster> masak: you mentioned here https://rt.perl.org/rt3/Ticket/Display.html?id=112276 that slurp to should default to $*IN, but the spec never got changed.  Would you like me to do it?

[09:38] <sorear> .oO( opt )

[09:38] <FROGGS> moritz: there are other channels than #perl6?? O.o

[09:38] <FROGGS> that doesn't feel right :P

[09:38] <sorear> are you being serious

[09:39] <moritz> FROGGS: #ilbot is much more quiet than #perl6, but I created it to be not so much off-topic in here

[09:39] <labster> masak: or was there a reason to keep it with $*ARGFILES

[09:40] <sorear> slurp totally should be $*ARGFILES, not $*IN

[09:40] <sorear> that's what P5 does with the <> magic, it works well and there's no reason to change it

[09:40] <FROGGS> moritz: does ilbot connect to irc.perl.org too? I'd like to have #sdl logged...

[09:41] <moritz> it isn't?

[09:41] <moritz> FROGGS: sure

[09:41] <sorear> $*ARGFILES is a relatively recent addition to Rakudo; defaulting to $*IN may be a fossil

[09:41] <moritz> FROGGS: do the other inhabitants of #sdl agree with that?

[09:41] <FROGGS> moritz++ # thanks, though it won't cost much traffic :o)

[09:42] <FROGGS> moritz: it once was logged, but the server where the bot was running well, got unmaintained... so there is an agreement about that

[09:43] <sorear> it should be prominently announced that the channel is now again being logged

[09:43] <FROGGS> I'll change the topic, and I could write a message to the mailing list

[09:43] <moritz> FROGGS: I dimly recall a channel that I once logged, and then deleted all the logs on request from one of the regulars, because he didn't realize *how* public it would be

[09:43] <moritz> but I'm not sure if that was #sdl or not

[09:43] <labster> I get where you're coming from sorear, but the discussion in the bug report went the opposite way.

[09:44] *** gaussblurinc1 joined
[09:44] <FROGGS> moritz: I know the logs where on 'our' server at sdlperl.ath.cx or so

[09:56] *** eternaleye joined
[10:00] *** tgt joined
[10:04] *** sqirrel joined
[10:04] <lizmat> isn't "my %h of Int" supposed to be an alternative to saying "my Int %h" ?

[10:05] <lizmat> r: my %h of Int; say %h.of; my Int %i; say %i.of

[10:05] <camelia> rakudo 8d2ec9: OUTPUT¬´(Mu)‚ê§(Int)‚ê§¬ª

[10:06] <lizmat> a case of NYI, I assume?

[10:07] *** gaussblurinc1 left
[10:19] *** eternaleye left
[10:22] *** eternaleye joined
[10:37] <arnsholt> lizmat: Most likely, yeah

[10:38] <arnsholt> It's implemented for return types on subs, so grepping for trait_mod:<is> in Rakudo should be helpful

[10:38] <lizmat> r: my Int %h{Any}; say %h.WHAT; say %h.of; my %i=%h.clone; say %i.WHAT; say %i.of  # .clone doesn't work on typed hashes   :-(

[10:38] <camelia> rakudo 8d2ec9: OUTPUT¬´(Hash+{TypedHash})‚ê§(Int)‚ê§(Hash)‚ê§(Mu)‚ê§¬ª

[10:39] <lizmat> rakudobug?  I think so  :-(

[10:40] <arnsholt> Certainly a bug, I'd say. Not sure if it's a NYI-bug or ordinary bug though

[10:41] <lizmat> it's bloody annoying, that's what it is‚Ä¶  this cost me the better part of this morning trying to allow .hash :type and :of named parameters

[10:42] *** anuby left
[10:42] <arnsholt> Anyways, it might be due to the TypedHash mixin

[10:42] *** woosley left
[10:43] <arnsholt> There's another annoying bug where Array[Int] !~~ Array[Int], which is due to mixins

[10:43] *** kaleem left
[10:51] <lizmat> I wonder whether the problem isn't really that we cannot have a binding return value.  Or can we?

[10:52] <lizmat> currently .hash is defined as "method hash { my %h = self }"

[10:52] <lizmat> so what happens, is that we create a hash inside the scope of the method, and then clone it on the way back

[10:53] *** sqirrel left
[10:54] <lizmat> whereas we might have well bound it: something like "my %i= <a 1 b 2>.hash" would in fact need to do "my %i := METHOD::%h" as it were

[10:55] <lizmat> masak, moritz, jnthn: am I making sense here, or is this a noob rambling  :-)

[10:55] <lizmat> afk for a few hours

[11:00] <masak> lizmat: re the NYI: you're trying something no-one's ever really done with Rakudo (cloning a typed hash). so yes, bugs fall out. frustration follows. the best (meta-)workaround I've found for that is to file rakudobugs. it helps, in the sense that lots of them get fixed, sometimes even relatively quickly.

[11:00] <masak> <lizmat> I wonder whether the problem isn't really that we cannot have a binding return value.  Or can we?

[11:00] <masak> I don't understand what you mean here.

[11:01] <masak> and that seems to be the core of your explanation, so maybe rephrase? :)

[11:02] <lizmat> sorry if I seemed annoyed, I was  :-)

[11:02] <dalek> roast: b9c3771 | dagurval++ | S32-temporal/DateTime.t:

[11:02] <dalek> roast: Added test for empty DateTime constructor

[11:02] <dalek> roast: review: https://github.com/perl6/roast/commit/b9c37710b0

[11:02] <dalek> roast: 200549a | dagurval++ | S32-temporal/calendar.t:

[11:02] <dalek> roast: remove newline from expected gist output

[11:02] <dalek> roast: review: https://github.com/perl6/roast/commit/200549a193

[11:03] *** gaussblurinc1 joined
[11:03] <lizmat> masak: sub a { my %h }; my %i= a  # this is in fact %i= %h.clone, I would like it to be %i := %h

[11:06] <masak> ah. now it's clear.

[11:07] <masak> that actually feels *more* right to me, at first blush.

[11:07] <masak> hm. I think.

[11:07] <masak> if the patch passes spectest, I'm all for it. I'd apply it.

[11:13] *** sciurius_ left
[11:13] * lizmat is intermittently at keyboard

[11:13] <lizmat> one could argue that what I propose is an optimisation

[11:14] <lizmat> so I will first focus on getting .clone to work on typed hashes

[11:14] <masak> here's how far I can see into the issue: arguments/parameters are bound by default, so it only makes sense that return values be, too.

[11:14] <lizmat> I have a patch for .hash( :type(Any), :of(Int ), but it doesn't work because .clone doesn't  :-(

[11:14] <masak> *but*, there *is* an assignment there, in '%i = a', and that bugs me a bit.

[11:15] <lizmat> hmmmm  good point

[11:15] <masak> but not too much, since (I think) '%h1 = %h2' also doesn't do a clone, just a reference copy.

[11:15] <masak> r: my %h1; my %h2 = %h1; say %h1 === %h2

[11:15] <lizmat> well, whatever, the effect is the same as clone

[11:15] <camelia> rakudo 8d2ec9: OUTPUT¬´False‚ê§¬ª

[11:15] <masak> hm.

[11:15] <masak> or not.

[11:15] <lizmat> r: my Int %h{Any}; say %h.WHAT; say %h.of; my %i=%h.clone; say %i.WHAT; say %i.of  # .clone doesn't work on typed hashes   :-(

[11:16] <camelia> rakudo 8d2ec9: OUTPUT¬´(Hash+{TypedHash})‚ê§(Int)‚ê§(Hash)‚ê§(Mu)‚ê§¬ª

[11:16] <masak> I notice that I am confused. I again defer you to the spectest, a better arbriter than I :)

[11:16] <lizmat> r: my Int %h{Any}; say %h.WHAT; say %h.of; my %i=%h; say %i.WHAT; say %i.of 

[11:16] <camelia> rakudo 8d2ec9: OUTPUT¬´(Hash+{TypedHash})‚ê§(Int)‚ê§(Hash)‚ê§(Mu)‚ê§¬ª

[11:16] <masak> I definitely agree that there's something in .clone of typed hashes that should be fixed.

[11:16] <lizmat> the reference copy doesn't copy the type or of either, I was assuming it was using .clone under the hood

[11:17] <masak> what I meant by "refernce copy" is disjunct from anything having to do with .clone

[11:17] <masak> after a reference copy, there is still only one hash object in play. not two.

[11:17] <FROGGS> nqp: say( 1 // 2 )

[11:17] <camelia> nqp: OUTPUT¬´1‚ê§¬ª

[11:18] <lizmat> r: my Int %h{Any}; say %h.WHAT; say %h.of; my %i:=%h; say %i.WHAT; say %i.of 

[11:18] <camelia> rakudo 8d2ec9: OUTPUT¬´(Hash+{TypedHash})‚ê§(Int)‚ê§(Hash+{TypedHash})‚ê§(Int)‚ê§¬ª

[11:18] <lizmat> afk again

[11:18] <masak> r: class O {}; my $o1 = O.new; my $o2 = $o1; say $o1 === $o2

[11:18] <FROGGS> nqp: my $x; $x //= 7; say($x); $x //= 8; say($x); 

[11:18] <camelia> rakudo 8d2ec9: OUTPUT¬´True‚ê§¬ª

[11:18] <camelia> nqp: OUTPUT¬´Confused at line 2, near "$x //= 7; "‚ê§current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)‚ê§¬ª

[11:18] <masak> that's a reference copy.

[11:23] *** betterwo1ld left
[11:26] *** betterworld joined
[11:27] *** tgt left
[11:28] *** patspam left
[11:33] *** patspam joined
[11:38] *** tgt joined
[11:50] *** kaleem joined
[11:50] *** tgt left
[11:52] <dagurval> r: Int.min.say; Int.max.say;

[11:53] <camelia> rakudo 8d2ec9: OUTPUT¬´Inf‚ê§-Inf‚ê§¬ª

[11:53] <dagurval> should it not be the other way around?

[11:54] <masak> I can see what set of expectations you're running under that'd make you think that ;)

[11:54] <masak> r: say ().min; say ().max

[11:54] <camelia> rakudo 8d2ec9: OUTPUT¬´Inf‚ê§-Inf‚ê§¬ª

[11:54] <spider-mario> r: Int.min.say

[11:54] <camelia> rakudo 8d2ec9: OUTPUT¬´Inf‚ê§¬ª

[11:54] <masak> Inf is the "identity value" of the min operator.

[11:55] <spider-mario> oh, ok

[11:55] <masak> -Inf is the "identity value" of the max operator.

[11:55] <masak> just like 0 and 1 are for addition and multiplication, respectively.

[11:55] *** crab2313 joined
[11:55] <masak> r: say [+](); say [*]()

[11:55] <camelia> rakudo 8d2ec9: OUTPUT¬´0‚ê§1‚ê§¬ª

[11:55] <masak> r: say [min](); say [max]()

[11:55] <camelia> rakudo 8d2ec9: OUTPUT¬´Inf‚ê§-Inf‚ê§¬ª

[11:56] <masak> dagurval: all that said, yes, I can definitely see your expectation being fairly widespread, and *not* honoring it being some kind of breaking Least Surprise.

[11:56] *** crab2313 left
[11:57] <masak> question is, which weighs more heavily here: consistency of .min and .max, or user expectations in this particular case?

[11:57] <dagurval> hehe, indeed

[11:58] <lizmat> this actually, to me, feels like an implementation detail leaking out

[11:58] <dagurval> what consistency whould be broken?

[11:59] <dagurval> I would rather not have .max .min on Int, than to have them behave like that.

[11:59] <dagurval> Instead perhaps have limits class like in c++, std::limits<int>::max()

[12:00] <dagurval> s/limits/numeric_limits

[12:01] <gfldex> r: say int.min;

[12:01] <camelia> rakudo 8d2ec9: OUTPUT¬´Inf‚ê§¬ª

[12:01] <gfldex> that's a lot of bits :)

[12:01] *** jest1 joined
[12:02] <masak> dagurval: I think the thing to understand is that type objects are a kind of instances of their type.

[12:03] <masak> so, if the Dog class has a .bark method, then the type object (also spelled 'Dog') has a .bark method.

[12:03] <masak> why Int has a .min and .max I don't know offhand, but probably because of the (intentional) confusion between items and lists in Perl 5 and 6.

[12:03] *** pjcj_ left
[12:04] <masak> r: class Dog { multi method bark() { say "called on an actual Dog" }; multi method bark(:U:) { say "called on a type object" } }; Dog.bark; Dog.new.bark

[12:04] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed parameter‚ê§at /tmp/BUUbnkYxML:1‚ê§------> [32mon an actual Dog" }; multi method bark(:[33m‚èè[31mU:) { say "called on a type object" } };[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifi‚Ä¶

[12:05] <masak> r: class Dog { multi method bark() { say "called on an actual Dog" }; multi method bark(Dog:U $self:) { say "called on a type object" } }; Dog.bark; Dog.new.bark

[12:05] <camelia> rakudo 8d2ec9: OUTPUT¬´Ambiguous call to 'bark'; these signatures all match:‚ê§:(Dog : Mu *%_)‚ê§:(Dog:U $self: Mu *%_)‚ê§  in method bark at src/gen/CORE.setting:440‚ê§  in block  at /tmp/pWHCFicdQ9:1‚ê§‚ê§¬ª

[12:05] <lizmat> in many contexts, an item is a one element list:

[12:05] <lizmat> r: my $a=1; say $a[0]

[12:05] <camelia> rakudo 8d2ec9: OUTPUT¬´1‚ê§¬ª

[12:05] <masak> hrm.

[12:05] <masak> r: class Dog { multi method bark(Dog:D $self:) { say "called on an actual Dog" }; multi method bark(Dog:U $self:) { say "called on a type object" } }; Dog.bark; Dog.new.bark

[12:05] <camelia> rakudo 8d2ec9: OUTPUT¬´called on a type object‚ê§called on an actual Dog‚ê§¬ª

[12:06] <dagurval> so that's what :D and :U are for :)

[12:07] <masak> there are two other letters, with slightly different meanings. they may or may not be more correct here, in fact. I haven't learned them yet.

[12:07] *** SamuraiJack_ left
[12:07] <masak> lizmat: the DWIM end of items-pretend-to-be-lists can be handy sometimes. the WAT end can be correspondingly horrible.

[12:13] *** census joined
[12:20] *** pjcj joined
[12:22] *** gaussblurinc1 left
[12:26] <lizmat> masak: agree, I was just elaborating for dagurval/gfldex

[12:26] *** muixirt joined
[12:26] <masak> aye. and I wasn't arguing against anything, just kvetching out loud :)

[12:28] <lizmat> masak: S12:1616 "Abstract vs Concrete Types"

[12:28] *** ajr joined
[12:29] *** ajr is now known as Guest64703

[12:29] <masak> aye. those are what I was thinking of.

[12:31] <masak> the need for both :U and :T is another instance of the semipredicate problem popping up ;)

[12:31] <masak> it's everywhere!

[12:31] *** arlinius left
[12:32] <lizmat> It's good that there is no :F, otherwise we could have called if :F:U:D  :-)

[12:35] <masak> I always feel sure what kind of smiley :D is, but I'm not really sure what emotions :U and :T represent...

[12:35] *** jest1 left
[12:35] <lizmat> :T is left headdesk?

[12:35] <lizmat> or right?

[12:37] * masak .oO( and if you combine an L-headdesk with an R-headdesk, you get a commutative bi-headdesk )

[12:38] <lizmat> r: sub a ( $a=1, --> Hash ) { say $a; my %h }; say a(2)

[12:38] <camelia> rakudo 8d2ec9: OUTPUT¬´2‚ê§().hash‚ê§¬ª

[12:38] <lizmat> r: sub a ( $a=1 --> Hash ) { say $a; my %h }; say a(2)

[12:38] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/NxD226NWlT:1‚ê§------> [32msub a ( $a=1 --> Hash [33m‚èè[31m) { say $a; my %h }; say a(2)[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        prefix or term‚ê§        ‚Ä¶

[12:38] *** kaare__ left
[12:38] <lizmat> for some reason, if we have a default, we need a comma there

[12:38] <lizmat> r: sub a ( $a --> Hash ) { say $a; my %h }; say a(2)

[12:38] <camelia> rakudo 8d2ec9: OUTPUT¬´2‚ê§().hash‚ê§¬ª

[12:39] <lizmat> r: sub a ( $a --> Hash is ref ) { say $a; my %h }; say a(2)

[12:39] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/eL4JExgq_z:1‚ê§------> [32msub a ( $a --> Hash [33m‚èè[31mis ref ) { say $a; my %h }; say a(2)[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§        new name‚Ä¶

[12:39] <lizmat> wouldn't that be a nice syntax for binding the return value, rather than cloning?

[12:40] <muixirt> hi, while compiling rakudo CORE.setting.pbc (9c5650b) I get a segfault

[12:41] <lizmat> I assume you're using the latest rakudo from HEAD ?

[12:42] <muixirt> lizmat: almost, 1 day old

[12:42] <gfldex> muixirt: what platform?

[12:42] <muixirt> linux amd64

[12:42] * masak submits rakudobug for the required comma

[12:43] <lizmat> hmmm‚Ä¶   fetching last changes to rakudo

[12:43] <lizmat> masak++

[12:44] *** MrMeek left
[12:45] <muixirt> I noticed that Rakudo got slower, is that temporary?

[12:45] <gfldex> that's the plan

[12:46] <muixirt> hmm, didn't segfault the second run

[12:46] <lizmat> muixirt: slower in building, or in execution generally ?

[12:47] *** chrisdev joined
[12:47] <muixirt> lizmat: startup time and execution time

[12:48] <muixirt> (compared to a Rakudo Star 2013.02.1)

[12:49] *** tgt joined
[12:50] * [Coke] realizes that the sixperl phone call is still on his favorite contacts list, and rectifies that.

[12:52] <diakopter> heh

[12:58] *** salv0 joined
[12:58] *** btyler joined
[12:58] *** Guest64703 is now known as ajr_

[13:01] *** arlinius joined
[13:13] *** usdmatt joined
[13:14] *** usdmatt left
[13:19] <muixirt> much of the slowness came from Parrot version 5.3.0-devel it seems

[13:19] <muixirt> oh no, i forgot --optimize 

[13:20] <muixirt> whatever that does in current parrot versions

[13:20] <muixirt> sorry for the noise

[13:21] <diakopter> :)

[13:22] *** kivutar joined
[13:24] *** bluescreen10 joined
[13:30] <masak> thank you, #perl6, for existing. it makes me happy, all the time :)

[13:30] <tadzik> \o/

[13:32] <masak> when I started getting involved in 2004-2005, I think I was suffering from the notion that most things had already been invented. that programming languages, the big ones out there, were basically the last word and there wasn't much left to do.

[13:32] <masak> but being part of a language design process quickly liberates you from that notion :>

[13:33] <masak> there is *lots* to do. we're only at the *start* of our very *understanding* of what computers and computing and programming *are*.

[13:33] <PerlJam> heh

[13:33] <yoleaux> 19 May 2013 03:56Z <[Coke]> PerlJam: about grammar-profiler-simple... the csv.t test has the plan commented out and no actual tests, which is why it's failing.

[13:34] <masak> the various sub-guilds, FPistas and reactive programmers and logic programmers, all have pieces of the puzzle. they're building and exploring a better world. the mainstream languages are boring and old. we can do better -- much better.

[13:34] <PerlJam> masak: Just keep in mind that computing is so very young.  Look how look it took math (for instance) to get interesting.

[13:34] <PerlJam> s/look/long/

[13:35] <masak> yes, that's what I mean. we're all *toddlers* when it comes to programming. there's some variance, but we're basically all setting out. in 20 years or so, we'll know a bunch more, have better tools, better reach, better understanding.

[13:35] <PerlJam> (and still be relative toddlers :)

[13:36] <arnsholt> I saw a video talk where the speaker (can't remember who it was, sadly) pointed out that there's a lack of historical knowledge as well

[13:37] <masak> you bet there is.

[13:37] <PerlJam> masak: I wonder if everyone has the same revelation at some point.   when I first started using unixen, tools like FTP and archie were important and looked like they'd always been there.  I found out later that they had just been invented a couple of years before I first heard of them.

[13:37] <arnsholt> There's a lot of really awesome stuff from the Lisp-machine and Smalltalk worlds of the early 80s that's been forgotten

[13:37] <masak> arnsholt: it's been forgotten because those languages didn't become mainstream.

[13:37] <arnsholt> Or is being rediscovered (like MVC, which goes back to Smalltalk)

[13:37] <ajr_> The lack of historical knowledge is the reason each generation keeps "solving" the same problems.

[13:38] <ajr_> (And announcing them as a wondrous new step inhuman progress.

[13:38] <ajr_> )

[13:38] <PerlJam> ajr_: in a way, that's okay because the context around the problems shifts.

[13:38] <arnsholt> Also, when you look at the kind of introspection and tweaking that was possible in Smalltalk and Lisp-machine systems you realize that modern OSes aren't all that awesome

[13:39] <masak> arnsholt: if you're wiped out by Worse is Better, you'll either spend the rest of your life being bitter about it, or (like Eirich Gamma et al.) you rebuild the tools in Java instead of Smalltalk. now, Eclipse is a weak ghost of what Smalltalk was, but at least it has the original ideals and it's being used a lot.

[13:39] *** PacoAir joined
[13:39] <PerlJam> .oO( Why are we talking about smalltalk in the past tense? )

[13:39] <ajr_> Reading "The Sciences of the Artificial" by Herbert Simon is very instructive

[13:40] <ajr_> The fundamental problem in computing isn't computers; it's people.

[13:40] <PerlJam> ajr_: truer words were never written  :)

[13:40] <arnsholt> masak: Yeah, I'm a bit ambivalent about Worse is better. On the one hand I see why it's like that, on the other hand I hate it =)

[13:40] <masak> ajr_: that's what I like about this channel. we do cross-generation right. it's happened half a dozen times that I've brought up a problem here, and the people with decades of experience just go "yeah, we did that back in <decade before masak was born>. it's called the lagging variable pattern."

[13:41] <ajr_> We can make computers faster and give them more peripherals, but the Mark I Cerebellum doesn't get updated.

[13:41] <masak> arnsholt: here in #perl6, we're in a Worse-Is-Better-free zone :P

[13:41] <arnsholt> Second system done right, indeed =D

[13:42] <ajr_> One of the most interesting consequences of computer development has been the revelation of how little we know about thinking processes.

[13:42] <ajr_> The history of AI is particularly valuable.

[13:42] <arnsholt> Definitely. I made that very point this semester

[13:43] <arnsholt> Moravec's paradox is very relevant

[13:44] <arnsholt> And the summary "Hard problems are easy and easy problems are hard" is very pithy (and with chiasmus, which I like)

[13:44] <masak> ajr_: http://www.ageofsignificance.org/ looks interesting and reminds me of what you're saying about thinking processes. I keep telling myself to read what's there already, but I always seem to get distracted. it's interesting, though.

[13:44] <ajr_> "Computers can do easily what PhD.s do, but not what toddlers do".

[13:45] *** pjcj left
[13:45] <arnsholt> Perhaps an even better summary =)

[13:45] <masak> arnsholt: doesn't Moravec's paradox simply mean that (since brains don't constantly blow a fuse when we're lifing a carton of mild) a lot of assumptions of the real world are hard-coded into a healthy adult brain?

[13:46] <masak> arnsholt: so we're not general computing devices; evolution has cut corners and cheated a lot on the way.

[13:46] <masak> milk*

[13:46] <arnsholt> I dunno. I see it more as a reflection of our lack of understanding of how certain fundamental tasks actually work

[13:46] <ajr_> "Mild" works too, but too much of it will disrupt the computation

[13:47] <arnsholt> The example I used with my students was walking. It's something we do without really thinking about it, yet making a walking robot is actually very hard

[13:47] <ajr_> (Mild is a kind of English beer.)

[13:48] *** pjcj joined
[13:49] <masak> arnsholt: bootstrapping the knowhow to walk takes O(year) for a "clean-slate" human.

[13:49] *** pjcj left
[13:49] <arnsholt> Yeah, which illustrates that it's really hard

[13:49] <masak> so arguably, it's not easy for us either ;) we just forget how hard it is.

[13:50] <arnsholt> Yeah

[13:50] <arnsholt> I segued into riding a bike after talking about walking

[13:50] <arnsholt> It's something we learn later in life, so we remember how hard it was to learn, while also doing it sub-conciously

[13:50] *** pjcj joined
[13:51] <arnsholt> People have also mentioned driving a car, but I don't have a licence, so I don't know =)

[13:51] *** pjcj left
[13:52] <masak> arnsholt: hilarious scene from some SF novel: friendly alien is an 8-legged spider. it watches its human friend stop and remove a stone from the sole of his shoe, balancing on one leg as he does so. alien almost faints out of surprise at this feat.

[13:52] *** kaleem left
[13:52] <arnsholt> Nice one!

[13:53] <masak> :)

[13:53] *** bluescreen10 left
[13:53] *** pjcj joined
[13:53] <ajr_> One vital lesson from the learning-to-walk process; you'll never make progress if you're afraid to make mistakes.

[13:54] *** risou_awy joined
[13:54] <arnsholt> Also an important theorem of machine learning theory: Most interesting classes of problems can't be learned accurately solely from positive examples

[13:54] <lizmat> and one wonders how much mind you need to learn to walk:

[13:54] <lizmat> http://www.extremetech.com/extreme/101525-bluebiped-a-human-like-walking-robot-that-requires-no-power-source

[13:54] <ajr_> I used to use that as a metaphor at the start of training courses.

[13:54] *** skids joined
[13:55] <ajr_> Adults are afraid of making mistakes, which inhibits their learning processes.

[13:56] *** risou_awy is now known as risou

[13:58] <masak> yeah. adults are weird that way. very risk-averse, at least when it comes to being wrong.

[13:58] * masak .oO( adults are obsolete children )

[14:01] <lizmat> aren't we all pretending to be adults ?

[14:05] *** ggoebel left
[14:10] <moritz> lizmat: part of me pretends to be adult, parts are (and some parts don't even try to pretend :-)

[14:10] *** xilo left
[14:11] *** ggoebel joined
[14:12] <lizmat> so, investigating where Hash.clone lives, I've come to the conclusion that that is just really nqp::clone in disguise

[14:13] <lizmat> jnthn: am I on the good track there?

[14:13] *** pjcj left
[14:15] *** pjcj joined
[14:15] <moritz> lizmat: sounds plausible

[14:16] <lizmat> which in turn seems to be just a wrapper around pir::clone__PP, at least in the parrot version of rakudo

[14:17] *** bluescreen10 joined
[14:20] <arnsholt> Sounds plausible as well

[14:22] <lizmat> because of this behaviour of clone, we cannot create any classes that return typed Hashes

[14:22] <lizmat> unless you tell the users to bind to the return value of .new, rather than just assign

[14:22] <arnsholt> Some limitation in what pir::clone does?

[14:23] <lizmat> I assume that nqp::clone doesn't know about typed hashes, that they only live in Perl 6 land proper

[14:27] <TimToady> dagurval: to hide parental multis you can just define your own proto

[14:28] <lizmat> hmmm‚Ä¶ I thought I could write a method clone for typed hashes, assuming that %i = %h would be syntactic sugar for %i = %h.clone

[14:29] <TimToady> we need to find a better name than "typed hashes", because they're all typed, both in key and value; it's just that some are more typed than others

[14:29] <lizmat> but it isn't: I guess it compiles into a direct call to nqp::clone for performance reasone

[14:29] <lizmat> KeyConstraint and ValueConstraint ?

[14:30] <TimToady> well, that's a bit of a mouthful, but I don't have a better idea yet

[14:30] <rjbs> Type-Refined Hashes, or "trashes"

[14:31] *** xilo joined
[14:31] <TimToady> rjbs: again, that also applies to my Thing %hash;

[14:31] <lizmat> TimToady: is there a way for a sub to specify that the "return" values should be bound, rather than returned?

[14:32] <lizmat> I was suggesting earlier something like "sub a ( $a --> Foo is ref ) { my %h }

[14:32] <TimToady> that's what "Parcel" means

[14:32] <lizmat> "my %i= a" would then actually be "my %i := a"

[14:33] <TimToady> except I don't think we should do that to assignment

[14:34] <lizmat> oooh, wow

[14:34] <TimToady> but my arguer hasn't woke up yet...

[14:35] <masak> lizmat: re being an adult: https://twitter.com/dresdencodak/status/335600597589962754

[14:35] *** MrMeek joined
[14:37] <lizmat> alas, for a moment I thought that (my %h,) would be a fix for binding

[14:37] *** spider-mario left
[14:37] <lizmat> would be a way to bind the %h to the outer %i

[14:38] *** crab2313 joined
[14:38] <GlitchMr> .u ·∫ó

[14:38] <yoleaux> U+1E97 LATIN SMALL LETTER T WITH DIAERESIS [Ll] (·∫ó)

[14:38] <GlitchMr> .u nÃà

[14:38] <yoleaux> U+006E LATIN SMALL LETTER N [Ll] (n)

[14:38] <yoleaux> U+0308 COMBINING DIAERESIS [Mn] (‚óåÃà)

[14:38] <diakopter> .u .u

[14:38] <yoleaux> U+002E FULL STOP [Po] (.)

[14:39] <yoleaux> U+0075 LATIN SMALL LETTER U [Ll] (u)

[14:39] <diakopter> .u yoleaux

[14:39] <yoleaux> No characters found

[14:43] <masak> a good read: http://www.yosefk.com/blog/what-worse-is-better-vs-the-right-thing-is-really-about.html -- speaking of "Worse Is Better".

[14:44] <masak> relating that to Perl 6, I see the design process of Perl 6 as starting out in a The Right Thing kind of place, and then trying to mix as much evolution into the thing as possible at each stage.

[14:45] <masak> and maybe Pugs partly taught us that, that you need the running implementation and the spectests and the feedback. I'm actually not sure, because I wasn't active enough before Pugs.

[14:46] <TimToady> I believe in Intelligent Design, except I happen to think that evolution is the most intelligent way to do that :)

[14:46] *** tgt left
[14:47] *** gaussblurinc joined
[14:48] *** gaussblurinc1 joined
[14:49] <masak> that sentence ended way better than it started. :P

[14:51] *** gaussblurinc left
[14:52] <TimToady> well, rhetorically speaking, it was designed to jerk you around, so I guess it worked.

[14:55] <TimToady> For all its faults, I like how the universe is put together, and many of the "improvements" people would make are not, in fact, better than what we have.

[14:55] <gtodd> evo still provokes awe and wonder for me ... ever since I ate that apple in that garden ...

[14:56] <tadzik> according to evolution a monkey ate that apple, no? ;)

[14:57] <TimToady> well, an ape

[14:57] * gtodd recalls it was a pomme de terre or ground apple ... they'll grow anywhere feed/free the poor ... they're like manna from heaven :P

[14:57] <TimToady> and we're still aping them

[14:57] <tadzik> . o O ( not enough manna )

[14:57] <TimToady> I like the theory that it was a watermelon

[15:05] <TimToady> but regardless of how literally/figuratively you take that story, it expresses something profound: when the ape became infected with memes ("the knowledge of good and evil"), we could no longer remain innocent like animals, but are cursed to keep thinking about our problems in memespace regardless of their immediacy.

[15:06] <TimToady> animals can live in the moment; when people do this, we call them "animals"

[15:07] <TimToady> well, that's a bit misstated; we can live in the moment too, but we also transcend that mode of operation

[15:07] <TimToady> occasionally

[15:09] <masak> aye. though we're still busy creating more problems (environmentally and ecologically) than we're solving, as we're cursed to do according to that story.

[15:09] *** kaare__ joined
[15:09] <masak> overall, humanity hasn't been a net good for Life on earth so far.

[15:10] <TimToady> well, but we might transport some portion of it to other planets eventually, which will be good in another way

[15:10] *** fgomez joined
[15:10] <TimToady> assuming there isn't native flora and fauna to wipe out

[15:11] <gfldex> .oO(if animals are innocent, why do cats avoid going to hell 7 times?)

[15:12] <TimToady> anyway, doing the Right Thing only works in memespace, and computer languages also exist in their own kind of meatspace, so both design and evolution are needful

[15:12] <moritz> gfldex: because they can :-)

[15:13] <masak> here's to populating other planets. or other places in general. putting all the humans in the same gravity well is a frightfully irresponsible case of monoculture.

[15:13] <gtodd> the ape was just a $variable and 'lo it became a %HoH

[15:13] <moritz> masak: ..or the only responsible thing to do, depending on how you see it :-)

[15:14] <gtodd> perl6 ... ready for mars

[15:15] <moritz> compiling rakudo probably requires more computing powers than the first space missions had available

[15:15] <Ulti> masak: don't worry give it enough time and humanity will fragment into myriad species populating all the niches

[15:15] <TimToady> well, depends on whether you include ground systems, I suppose, but even then, it depends on how you define "first"

[15:17] <gfldex> moritz: Sputnik don't got a computer nor did the folk who build it. So yes, you are right. :)

[15:17] <TimToady> is it a "mission" without people on it?

[15:19] <TimToady> if one were trying to keep the mission metaphor viable, it's not really a mission till you go far away, so arguable the first mission was to the moon, since LEO is so...well, low...

[15:19] *** tgt joined
[15:19] <moritz> OK, include the spectest run

[15:19] <TimToady> or maybe it's not a mission till we get out of the earth's gravity well, or maybe the sun's...

[15:19] <moritz> then rakudo needs more computing power than the first manned earth mission, or so :-)

[15:20] <TimToady> I suppose it depends on whether you include the compute power of wetware

[15:20] <moritz> I don't.

[15:21] <gfldex> it's going to be tricky to have a mission 13.7Bly away. Esp. since the gravity well of the sun grows with the speed of light. technically

[15:21] <TimToady> well, there is that

[15:22] <TimToady> and if you define it as "sphere of influence", we already got to the moon's gravity well

[15:22] *** btyler left
[15:23] *** kbenson joined
[15:23] *** kbenson left
[15:24] <masak> surely there must be some decent definition of "gettin gout of something's gravity well" that isn't limited by the fact that gravitation gravitational influence never really goes to 0.

[15:24] <TimToady> well, that's what "escape velocity" is going after, really

[15:25] <gfldex> apollo computer: "The computer had 2048 words of erasable magnetic core memory and 36 kilowords of read-only core rope memory. Both had cycle times of 11.72 micro-seconds. The memory word length was 16 bits: 15 bits of data and 1 odd-parity bit. The CPU-internal 16-bit word format was 14 bits of data, 1 overflow bit, and 1 sign bit (ones' complement representation)."

[15:26] <TimToady> and in the absence of escape velocity, an adequate means of acceleration

[15:26] *** btyler joined
[15:26] <TimToady> gfldex: most of the compute power was in ground systems, sure :)

[15:26] <TimToady> that's still the case

[15:27] <gfldex> i have seen laptops in the hand of kosmonauts on the ISS

[15:27] <masak> I mean, we can easily talk about the "size" of atoms, even though it's all really clouds of probability. stars and planets are more concrete than that.

[15:27] <TimToady> in fact, that case paid for much of the early development of Perl

[15:27] <gfldex> and singing, but no dancinge, likely due to a lack of a floor

[15:28] <TimToady> masak: we can easily talk about a lot of things we don't really understand :)

[15:29] <gfldex> hence this channel :->

[15:29] <masak> heh.

[15:29] <TimToady> That's the lovely thing about memes: there's so many to choose from.

[15:30] *** kaare__ left
[15:30] <masak> well, in some sense, that's what "separation of concerns" and "encapsulation" are all about. being able to focus on one thing without the interference of other things.

[15:31] * TimToady has so far been unsuccessful separating the concern of reading the backlog this morning, unless you count temporal separation...

[15:31] <TimToady> so stop saying interesting memes for a bit... :)

[15:33] *** kaare_ joined
[15:33] <lizmat> away for cycling and dinner

[15:37] <jnthn> evening, #perl6

[15:40] <colomon> \o

[15:42] <moritz> \o jnthn, colomon 

[15:42] <colomon> o/ moritz 

[15:42] <masak> jnthn! \o/

[15:44] *** kaare_ left
[15:45] *** kaare_ joined
[15:48] <tadzik> hello hello

[15:53] <masak> tadzik! \o/

[15:54] <TimToady> okay, you may talk about interesting things again

[15:54] <tadzik> what a day

[15:55] <GlitchMr> Just wondering, why forward gotos need to be more verbose than backward gotos? Backwards gotos are just bad, but sometimes forward gotos are good.

[15:55] <GlitchMr> When I have forward goto, I have to type goto "label".

[15:55] <GlitchMr> I don't have to do this with backward goto.

[15:56] <TimToady> because for backward goto the label is already declared as a term

[15:57] <TimToady> std: foo: say foo 42; sub foo {}

[15:57] <camelia> std 9906f18: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/AeEN6WHYI6 line 1:‚ê§------> [32mfoo: say foo [33m‚èè[31m42; sub foo {}[0m‚ê§    expecting any of:‚ê§        infix or meta-infix‚ê§    infixed function‚ê§       statement modifier

[15:57] <camelia> ..loop‚Ä¶

[15:57] <GlitchMr> Still, it seems backwards. Forward gotos are way more useful than backward gotos (where while {} could be easily used).

[15:57] <TimToady> that error is LTA

[15:58] <jnthn> Rakudo solves the whole thing by not implementing goto in any direction. :P

[15:58] <TimToady> are you suggesting goto should be a reserved word, and not just a function? :)

[15:58] <jnthn> We really should do the loop labels though. Just...tuits...

[15:59] <TimToady> std: constant foo = 42; say foo 43;

[15:59] <camelia> std 9906f18: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/_TcTUDpbqY line 1:‚ê§------> [32mconstant foo = 42; say foo [33m‚èè[31m43;[0m‚ê§    expecting any of:‚ê§     infix or meta-infix‚ê§    infixed function‚ê§       statement modifier

[15:59] <camelia> ..l‚Ä¶

[15:59] <nwc10> Rakudo - purer than PHP

[15:59] <TimToady> same LTAness

[15:59] <TimToady> it certainly shouldn't recommend whitespace when there *is* whitespace

[16:00] <TimToady> but the error should really know that foo is a term

[16:03] <TimToady> nr: constant foo = 42; say foo 43;

[16:03] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/Cl4fp2919d:1‚ê§------> [32mconstant foo = 42; say foo [33m‚èè[31m43;[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        statement end‚ê§        statement modifie‚Ä¶

[16:03] <camelia> ..niecza v24-51-g009f999: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/2vJECKeAWy line 1:‚ê§------> [32mconstant foo = 42; say foo [33m‚èè[31m43;[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[16:03] <TimToady> something is setting a bad listop memo for the error message

[16:04] <TimToady> but why would something parsed as a term be calling <args>?  and that's the only place (other than reduce) that sets it

[16:06] <TimToady> std: rand 42;

[16:06] <camelia> std 9906f18: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of rand(N); in Perl 6 please use N.rand or (1..N).pick at /tmp/MayKfot5GK line 1:‚ê§------> [32mrand[33m‚èè[31m 42;[0m‚ê§Parse failed‚ê§FAILED 00:00 41m‚ê§¬ª

[16:09] <TimToady> std: pi 42;

[16:09] <camelia> std 9906f18: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/6QDYFdmcAQ line 1:‚ê§------> [32mpi [33m‚èè[31m42;[0m‚ê§    expecting any of:‚ê§     infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED

[16:09] <camelia> ..‚Ä¶

[16:09] <TimToady> same issue

[16:15] *** gdey left
[16:17] <dalek> std: 52b6353 | larry++ | STD.pm6:

[16:17] <dalek> std: don't set listop memo on terms

[16:17] <dalek> std: review: https://github.com/perl6/std/commit/52b6353b81

[16:26] *** ajr_ left
[16:29] *** woosley1 joined
[16:29] *** woosley1 left
[16:42] *** tgt left
[16:44] *** SamuraiJack__ left
[16:45] *** SamuraiJack__ joined
[16:46] *** census left
[16:48] *** gdey joined
[17:12] <dagurval> TimToady: like this?

[17:12] <dagurval> r: class A { multi method new($x) { self.bless(*, { }); proto method new() { * } } }; A.new

[17:12] <camelia> rakudo 8d2ec9: OUTPUT¬´Cannot call 'new'; none of these signatures match:‚ê§:(A : $x, Mu *%_)‚ê§  in method new at /tmp/5TCx8vwhba:1‚ê§  in block  at /tmp/5TCx8vwhba:1‚ê§‚ê§¬ª

[17:12] *** berekuk left
[17:13] *** berekuk joined
[17:15] <jnthn> Just like that.

[17:16] <dagurval> nevermind, that was wrong :).

[17:16] <jnthn> It did what I expected :P

[17:17] *** dakkar left
[17:17] <jnthn> dinner, bbl

[17:17] <dagurval> r: class A { multi method new($x) { self.bless(*, { }); }; proto method new() {*} }; A.new

[17:17] <camelia> rakudo 8d2ec9: OUTPUT¬´Cannot call 'new'; none of these signatures match:‚ê§:(A : $x, Mu *%_)‚ê§  in method new at /tmp/YSF8GJ5jr_:1‚ê§  in block  at /tmp/YSF8GJ5jr_:1‚ê§‚ê§¬ª

[17:17] <dagurval> I'm trying to figure out this: 16:27 < TimToady> dagurval: to hide parental multis you can just define your own proto

[17:18] <dagurval> :)

[17:25] <masak> dagurval: visually at least, it's weird to me that you'd introduce a proto after the multi.

[17:26] <masak> dagurval: because the proto sort of pulls all its multis together, or contains them, or whatever.

[17:26] <masak> actually I'm surprised that's not a compile error.

[17:27] <masak> dagurval: also, as a rule, all the signatures of the multis should match (be a subset of) the signature of the proto.

[17:28] <masak> r: class A { proto method new($) {*}; multi method new($x) { say "OH HAI"; self.bless(*) } }; say A.new ~~ A

[17:28] <camelia> rakudo 8d2ec9: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in method new at /tmp/oFf5yAkYF_:1‚ê§  in block  at /tmp/oFf5yAkYF_:1‚ê§‚ê§¬ª

[17:28] <masak> r: class A { proto method new($) {*}; multi method new($x) { say "OH HAI $x"; self.bless(*) } }; say A.new("dagurval") ~~ A

[17:28] <camelia> rakudo 8d2ec9: OUTPUT¬´OH HAI dagurval‚ê§True‚ê§¬ª

[17:28] <masak> \o/

[17:28] <dagurval> yay! \o/

[17:29] *** dmol joined
[17:29] <masak> so the proto says "I handle routines of this name, and they all have this kind of signature". multis say "I answer to calls to the routine when the signature looks like... this!"

[17:29] <PerlJam> r: class C { proto method foo {};  proto method foo {}; };

[17:29] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Package 'C' already has a method 'foo' (did you mean to declare a multi-method?)‚ê§at /tmp/my1wqf2Itd:1‚ê§------> ‚ê§¬ª

[17:30] <PerlJam> r: class C { multi method foo {}; proto method foo []; }

[17:30] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/EBbo1U_SXS:1‚ê§------> [32m{ multi method foo {}; proto method foo [33m‚èè[31m[]; }[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        horizontal whitespace‚ê§        postfix‚ê§        statement end‚ê§        stat‚Ä¶

[17:30] <PerlJam> r: class C { multi method foo {}; proto method foo {}; }

[17:30] <camelia> rakudo 8d2ec9:  ( no output )

[17:30] <PerlJam> Hmm. that is weird.

[17:30] <masak> yeah, protos and onlys are the same "kind" of thing. and multis are subordinate to their proto, whether the proto is explicit or not.

[17:31] <dagurval> r: class A is DateTime { proto method new($) {*} }; A.new

[17:31] <camelia> rakudo 8d2ec9: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in method new at /tmp/9tdoeoTLEh:1‚ê§  in block  at /tmp/9tdoeoTLEh:1‚ê§‚ê§¬ª

[17:31] <dagurval> r: class A is DateTime { proto method new($) {*} }; DateTime.new

[17:31] <camelia> rakudo 8d2ec9:  ( no output )

[17:31] <dagurval> sweet

[17:31] <dagurval> r: class A is DateTime { proto method new($) {*} }; A.new(now)

[17:31] <camelia> rakudo 8d2ec9: OUTPUT¬´Null PMC access in get_pmc_keyed()‚ê§  in method new at /tmp/unWQf3YSyy:1‚ê§  in block  at /tmp/unWQf3YSyy:1‚ê§‚ê§¬ª

[17:32] <dagurval> ok, I still don't completely get it, but thanks masak. I'll wrap my head around it.

[17:32] <dagurval> that looks like implementation leak though

[17:35] <gfldex> Null PMC is parroty way to say segfault

[17:35] <masak> it's basically always wrong, unless you're doing weird MOP stuff.

[17:36] * masak submits rakudobug

[17:36] *** gaussblurinc1 left
[17:37] <arnsholt> I'd go so far as saying a Null PMC error is always a bug, unless you happen to know it's not =)

[17:38] <dagurval> r: use Test; class A {¬†multi method new($x) { } }; class B { method new($x) { } }; dies_ok { A.new() }; dies_ok { B.new(); }

[17:38] <camelia> rakudo 8d2ec9: OUTPUT¬´not ok 1 - ‚ê§ok 2 - ‚ê§¬ª

[17:38] <dagurval> all I want is for A to not have implicit new()

[17:39] <dagurval> (but still have multi)

[17:39] *** spider-mario joined
[17:39] <masak> r: class A is Any { proto method new($) {*} }; A.new(now)

[17:39] <camelia> rakudo 8d2ec9: OUTPUT¬´Null PMC access in get_pmc_keyed()‚ê§  in method new at /tmp/6ggP2nQoNi:1‚ê§  in block  at /tmp/6ggP2nQoNi:1‚ê§‚ê§¬ª

[17:40] <masak> ok, not related to DateTime. phew.

[17:40] <dagurval> :)

[17:42] <masak> https://rt.perl.org/rt3/Ticket/Display.html?id=118067

[17:44] *** Chillance joined
[17:44] <dagurval> r: proto sub a($) {*}; sub a(Int $x) { "yay" }

[17:44] <camelia> rakudo 8d2ec9: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Redeclaration of routine a‚ê§at /tmp/be1qqc_4fW:1‚ê§------> [32mto sub a($) {*}; sub a(Int $x) { "yay" }[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifie‚Ä¶

[17:45] <dagurval> shouldn't that work? from syn: ". A proto also adds an implicit multi to all routines of the same short name within its scope, unless they have an explicit modifier"

[17:51] * masak submits rakudobug for that

[17:52] <moritz> I think that's already (long) known

[17:53] <masak> yes, but I don't find it in RT.

[17:53] <masak> submitting Justin Case, and then we can merge if someone finds it.

[17:55] *** btyler left
[17:55] *** risou is now known as risou_awy

[17:55] *** risou_awy is now known as risou

[17:57] <dagurval> masak++

[17:58] <dalek> perl6-roast-data: acd6efa | coke++ | / (4 files):

[17:58] <dalek> perl6-roast-data: today (automated commit)

[17:58] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/acd6efa149

[17:58] *** cognominal__ left
[17:59] *** cognominal__ joined
[17:59] <[Coke]> rakudo still exploding.

[18:00] *** sciurius joined
[18:00] <dagurval> masak: I saw your talk(s) about perl6 on this years FOSDEM. They were inspiring

[18:00] <[Coke]> lizmat++ # only the exploding test is failing now.

[18:02] *** SmokeMachine left
[18:02] *** tgt joined
[18:03] *** japhb_ joined
[18:03] *** SmokeMachine joined
[18:08] <GlitchMr> http://planetsix.perl.org/

[18:08] <GlitchMr> oh, wow, I just have noticed issue with my RSS

[18:09] <GlitchMr> but... huh... it wasn't broken before

[18:10] <GlitchMr> Let me guess, the guys at GitHub have broken GitHub Pages again...

[18:10] <GlitchMr> ...

[18:12] *** btyler joined
[18:13] *** risou is now known as risou_awy

[18:14] <GlitchMr> Jekyll v1.0.0, I see...

[18:26] *** crab2313 left
[18:32] <jnthn> Note that the order of proto method and multi doesn't matter so much since it doesn't put all the pieces together until compose time.

[18:33] *** REPLeffect joined
[18:33] <PerlJam> jnthn: except that the language in the specs refers to the order.  "A C<proto> always functions as a dispatcher around any C<multi>s declared after it in the same scope"   (for instance)

[18:34] *** SamuraiJack joined
[18:34] *** census joined
[18:34] *** SamuraiJack__ left
[18:35] <jnthn> I suspect that language is in S06 and primarily thinking about subs, since "scope" tends to be about lexical scope and that's not really relevant for methods.

[18:35] <PerlJam> Sorry, that was quoted from S12:1093

[18:35] <jnthn> The reason we don't put all the bits together until compose time is 'cus you don't know what you're gonna be getting from a class.

[18:36] <jnthn> Ah.

[18:36] <jnthn> Then I'm gonna declare it over-specified. :P

[18:36] <PerlJam> wfm.

[18:36] <jnthn> Thing is that the proto is often auto-generated.

[18:37] <jnthn> But we don't know if we need to do that until we've seen what the roles want to bring in.

[18:37] <jnthn> And role comp certainly happens at compose time.

[18:38] <jnthn> Hm, I guess I can make it an error to write a proto after you wrote a multi in a class...

[18:38] <jnthn> ...by seeing if there's a non-multi already sat in the method table.

[18:39] <jnthn> But it'd be an error for the skae of wanting it to be one rather than out if needing to be one.

[18:39] <jnthn> *sake

[18:40] <jnthn> (Whereas with lexical multis it kinda has to be one.)

[18:44] <timotimo> hm, how does one properly make a custom short-circuiting operator? will the S metaop help? otherwise i suppose one would build a macro for it

[18:45] <moritz> macros, if it works

[18:45] <moritz> S won't work

[18:46] <pmichaud> good morning, #perl6

[18:46] <timotimo> i don't really understand how it'd achieve short-circuiting, but in the spec it says ¬ªThe 'S' can be thought of as standing for Sequential, Serial, Synchronous, Short-circuit, Single-thread, and Safe.¬´

[18:46] <moritz> \o pmichaud 

[18:46] <PerlJam> r: role R { multi foo { say "R-foo" } }; class C does R { method foo { say "C-foo" } }; C.new.foo;

[18:46] <camelia> rakudo 8d2ec9: OUTPUT¬´C-foo‚ê§¬ª

[18:46] <pmichaud> http://modelscoutrobotics.org/naopen-win/   # a successful weekend :)

[18:47] <PerlJam> r: role R { multi method foo { say "R-foo" } }; class C does R { method foo { say "C-foo" } }; C.new.foo;

[18:47] <camelia> rakudo 8d2ec9: OUTPUT¬´===SORRY!===‚ê§Cannot have a multi candidate for 'foo' when an only method is also in the package 'C'‚ê§¬ª

[18:47] <moritz> pmichaud: congratulations

[18:49] <masak> pmichaud++ pmichaud.kids++

[18:49] <PerlJam> moritz: But the kids did all the work!  :)

[18:49] <pmichaud> they did work hard, yes.  :)

[18:49] <timotimo> masak: shouldn't it be pmichaud.kids>>++ or something?

[18:49] <timotimo> ;)

[18:50] <jnthn> pmichaud: Congrats!

[18:50] <masak> timotimo: oh, absolutely, unless .kids have a special postfix:<++> defined on them.

[18:50] <masak> which they probably don't.

[18:50] *** zby_home_ joined
[18:50] *** kivutar left
[18:51] <jnthn> I dunno, they seem pretty successorful... 

[18:51] <moritz> :-)

[18:51] <masak> jnthn: that pun .succ

[18:51] *** s1n left
[18:51] <moritz> 's

[18:51] <tadzik> :D

[18:51] <timotimo> m)

[18:51] <masak> moritz: I'm torn. "succ" is short for "successor", so at least in the original context, the second "c" already has the "s" sound.

[18:52] <masak> moritz: but yeah, I did consider adding that "s".

[18:52] <lizmat> .hash( :type(Any, :of(Int) ) now for perusal at https://github.com/rakudo/rakudo/pull/155

[18:52] <masak> lizmat.rock's :P

[18:52] <lizmat> it needed string eval to work  :-(

[18:52] <masak> o.O

[18:53] <masak> sacrilege!

[18:53] <lizmat> eh, if life serves you lemons, you better make lemonade  :-)

[18:53] * masak looks for the torches and pitchforks...

[18:53] <pmichaud> can I make a lemon meringue pie, istead?

[18:54] <pmichaud> *instead?

[18:54] *** ggoebel left
[18:54] * lizmat needs additional ingredients

[18:54] <lizmat> but yes, sure

[18:55] <masak> lizmat: looks good, apart from the string eval ;)

[18:55] <lizmat> seriously though, there is to my knowledge currently no way of finding out what "type" a hash is

[18:55] <masak> anyone mind if I merge that?

[18:55] <masak> lizmat: I think we should take this pull request, and then find a better (spec'd) way to do it ASAP.

[18:55] <lizmat> fine by me‚Ä¶  :-)

[18:55] <jnthn> could add a way to give the type... :)

[18:56] <lizmat> I can do that, I think myself...

[18:56] *** kivutar joined
[18:56] <lizmat> if I knew how to get at the info, somewhere hidden in NQP's bowel, afaics

[18:57] <lizmat> but jnthn, don't let me stop you!

[18:57] <masak> lizmat: you've already spectust, of course?

[18:57] <lizmat> yes

[18:57] <jnthn> lizmat: Isn't it just the type arg?

[18:57] <lizmat> I have

[18:57] <dalek> rakudo/nom: 61db0e0 | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[18:57] <dalek> rakudo/nom: .hash now accepts optional :type and :of named parameters

[18:57] <dalek> rakudo/nom: 

[18:57] <dalek> rakudo/nom: So that we potentially can roundtrip .perl output, provided it can be

[18:57] <dalek> rakudo/nom: generated properly

[18:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/61db0e0134

[18:57] <dalek> rakudo/nom: 14e7d74 | (Carl M√§sak)++ | src/core/Any.pm:

[18:57] <dalek> rakudo/nom: Merge pull request #155 from lizmat/hashwithtypeandof

[18:57] <dalek> rakudo/nom: 

[18:57] <dalek> rakudo/nom: .hash now accepts optional :type and :of named parameters

[18:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14e7d74c85

[18:57] <lizmat> jnthn: wat?

[18:57] <jnthn> method ofkey() { TKey } or so in the TypedHash role?

[18:58] <masak> 'ofkey'!

[18:58] *** ggoebel joined
[18:58] <masak> that's what it's called!

[18:58] <jnthn> heh, well, the value one is .of :)

[18:58] <masak> right.

[18:58] <jnthn> I just strappolated :)

[18:58] <masak> 'ofcourse' :P

[18:58] <lizmat> $ ack -a ofkey

[18:58] <lizmat> lizypro:myrakudo liz$ 

[18:59] <lizmat> that string is not anywhere in the repo

[18:59] <jnthn> lizmat: Yes, I was suggesting adding it :)

[18:59] * masak .oO( the music your Hash produces sounds a little 'ofkey' )

[18:59] <lizmat> ah, ok

[18:59] <masak> jnthn: oh!

[18:59] <masak> yeah, I didn't get that either.

[18:59] <pmichaud> ofkey sounds reasonable to me

[18:59] <PerlJam> lizmat: looks like you need to upgrade your ack too  ;)

[18:59] <jnthn> Sorry, I'm trying to wrajt slajds :P

[18:59] <masak> that's OK.

[19:00] <lizmat> personally, I think they "keyof" and "valueof" feel better

[19:00] <lizmat> or "valof"

[19:01] *** rking1 is now known as rking

[19:01] <jnthn> Well, .of already exists

[19:01] <jnthn> r: my Int %h; say %h.of

[19:01] <camelia> rakudo 8d2ec9: OUTPUT¬´(Int)‚ê§¬ª

[19:01] <lizmat> yes, I know  :-)

[19:02] <jnthn> And matches the trait name.

[19:02] <pmichaud> and we also use "atkey" and "atpos"

[19:02] <lizmat> ok, you got me there  :-)

[19:02] <pmichaud> so "ofkey" seems to match the pattern better.

[19:02] <timotimo> hmm. i wonder how hard it could be to implement the ; operator for lists (lists of lists, more precisely?)

[19:03] *** rking left
[19:03] <lizmat> fwiw, I'm wondering why typed hashes aren't implemented as a subclass, rather than as a role

[19:03] <PerlJam> It's too bad you can't ask the hash to give you a prototypical key that you can just call .of on.

[19:03] <jnthn> lizmat: 'cus only roles are type parametric.

[19:04] <lizmat> you mean, they can MMD ?

[19:04] <jnthn> No, I mean they can have type parameters.

[19:04] <jnthn> role Foo[::T] { }

[19:04] <jnthn> You can't have a class Foo[::T] { }

[19:05] <lizmat> I guess I need to brush up on roles

[19:05] *** s1n joined
[19:05] <jnthn> I probably wrote a bunsj of slides about them at some point :)

[19:05] <jnthn> Talking of which...

[19:06] * jnthn hides IRC so he can try to get his $dayjob stuff rescued

[19:07] <lizmat> masak: and c.s. but just for the record, if I .clone a Typed hash, the clone should ofkeyed and ofed in the same way, right?

[19:07] <masak> lizmat: right.

[19:07] <lizmat> well, it isn't right now, so that's a rakudobug, I guess

[19:08] <masak> thought you filed that before.

[19:08] <masak> also, "c.s."?

[19:08] <lizmat> cum suis

[19:08] <masak> ah.

[19:08] <pmichaud> I'm afk, preparing to board flight

[19:08] <pmichaud> bbt

[19:09] <masak> lizmat: hah, a ddg search for the concept turns up a Dutch Wikipedia page: "Lijst van Latijnse spreekwoorden en uitdrukkingen" :P

[19:09] <masak> so I guess it's something used mostly in the Netherlands.

[19:10] <lizmat> r: my Int %h{Any}; say %h.of; say %h.WHAT; my %i= %h; say %i.of; say %i.WHAT   # should this also copy .ofkey and .of?

[19:10] <camelia> rakudo 8d2ec9: OUTPUT¬´(Int)‚ê§(Hash+{TypedHash})‚ê§(Mu)‚ê§(Hash)‚ê§¬ª

[19:10] <masak> (also, ddg made the initial search for just "suis" and asked if I wanted to turn off safe search. gee, computers are so stupid.)

[19:11] <arnsholt> "cum suis" would be something along the lines of "with its/their own"

[19:11] *** kivutar left
[19:12] <lizmat> in my mind, "cum suis" means "and the ones with you"

[19:13] <lizmat> translated to english, from the Dutch explanation: with supporters, the people who usually with him or her

[19:13] <masak> it's the same "suis" as in "sui generis" -- "of their own kind".

[19:14] <PerlJam> (or you could have just said exactly what you meant in english and avoided the length explanation of the latin  ;-)

[19:14] <lizmat> probably, my latin is not *that* good.  It's a standard Dutch idiom, for some reason

[19:14] <lizmat> huffman: cs is shorter

[19:14] <lizmat> :-)

[19:15] <arnsholt> suus is very generic, which makes it hard to translate in a fragment like this

[19:15] <arnsholt> It can be either be the third person possessive (singular or plural) or reflexive

[19:16] <lizmat> r: my Int @a; say @a.of; my @b=@a; say @b.of  # I guess just copying also loses .of

[19:16] <camelia> rakudo 14e7d7: OUTPUT¬´(Int)‚ê§(Mu)‚ê§¬ª

[19:16] <masak> arnsholt: oh, just like 'sig' in Swedish (and I guess Norwegian too).

[19:16] <masak> probably 'sej' or something in Norwegian.

[19:16] <lizmat> r: my Int @a; say @a.of; my @b=@a.clone; say @b.of  # I guess just copying also loses .of

[19:16] <camelia> rakudo 14e7d7: OUTPUT¬´(Int)‚ê§(Mu)‚ê§¬ª

[19:17] <arnsholt> "seg", actually =)

[19:17] <masak> close enough :P

[19:17] <lizmat> even cloning loses the .of.  Is that correct or a rakudobug?  feels wrong to me

[19:17] <arnsholt> But yeah, same etymology

[19:17] * masak .oO( what, do I look like a Norwegian? ) :P

[19:17] <arnsholt> sva in Sanskrit =)

[19:17] <masak> najs.

[19:17] <PerlJam> lizmat: looks like a bug to me.

[19:18] <lizmat> what me, German?  (about 50% actually  :-)

[19:18] <masak> Sanskrit always has the last laugh. (or first, actually)

[19:18] <masak> Sanskrit is the Lisp of spoken languages. they always did everything first.

[19:18] *** domidumont left
[19:18] <moritz> are they also smug about it? :-)

[19:18] <masak> exceedingly.

[19:18] <sorear> so much of linguistic history has been lost though

[19:19] <masak> "A written grammar? Yawn, we had that 3000 years ago."

[19:19] * lizmat hasn't seen any Sanskritians lately

[19:19] <masak> maybe not quite that long ago.

[19:19] <arnsholt> masak: Just 2000 and a bit, actually, but the point still stands =)

[19:19] <arnsholt> Not only a written grammar, but also a grammar that is a lot more formal than the Greco-Roman grammarians

[19:19] <masak> 8th century BC, according to Wikipedia.

[19:20] <masak> right, so the Lisp analogy is quite apt.

[19:20] <masak> "we were there before you, and we did it better, blogdangit!"

[19:20] <arnsholt> Oh, right. I keep forgetting that there's a grammatical tradition prior to Panini

[19:20] <masak> the guy who made flat breads with salad in them?

[19:21] <arnsholt> Exactly! =D

[19:21] * masak .oO( nono, Panini the violinist )

[19:22] <lizmat> wasn't Panini the guy who invented the single pan dish ?

[19:22] <timotimo> that was Panuno.

[19:22] <huf> guy? it's just a config file

[19:23] <masak> you're getting the hang of it now :)

[19:23] *** SamuraiJack_ joined
[19:23] *** SamuraiJack_ left
[19:23] <masak> "no no, 'Panini' means "a small pain", like in the lower back"

[19:25] *** SamuraiJack_ joined
[19:26] <lizmat> wasn't "pa" sanskrit for "knight" ?

[19:26] *** SmokeMachine left
[19:26] <arnsholt> Not AFAIK =)

[19:27] <masak> lizmat: hahaha

[19:27] * lizmat wonders how many people got the Monty Python reference

[19:27] * masak 

[19:27] <arnsholt> Not me, sadly =)

[19:27] <tadzik> ni!

[19:28] <arnsholt> Oh, right. I'm bad at puns =)

[19:29] <masak> I got it on the second read. felt a bit like being SQL injected :P

[19:29] <PerlJam> masak: did you suffer a flesh wound in the process?

[19:29] <lizmat> for the MP deprived: http://en.wikipedia.org/wiki/Knights_who_say_Ni

[19:31] * masak should re-watch "The Holy Grail"

[19:34] *** SamuraiJack left
[19:35] *** SamuraiJack joined
[19:40] <lizmat> after the latest mail on the YAPC mailing list, I'm seriously considering not attending the conference, but instead hack on Perl 6 while in Austin

[19:41] <lizmat> *sigh*

[19:43] * lizmat hopes coc mail was a fake

[19:43] <PerlJam> lizmat: why exactly?  Because you might run into rurban?

[19:43] <arnsholt> I intend to hack on Perl 6 while attending the conference

[19:43] <lizmat> I know Reini personally, I'm not afraid to run into him

[19:44] <PerlJam> lizmat: then what do you save yourself by not attending? 

[19:44] <arnsholt> Find a seat next to me and I can provide you with an infinite supply of useless historical linguistics trivia as well

[19:44] <lizmat> Reini has his faults, and actually many, but to get thrown from the mailing list like that for that

[19:44] <lizmat> arnsholt: I just might  :-)

[19:45] <PerlJam> I'd guess his removal is probably temporary

[19:46] <lizmat> it's the principle: the YAPC mailing list is *not* just for the YAPC::NA afaik

[19:46] *** SmokeMachine joined
[19:46] <lizmat> same as the #yapc channel

[19:46] <lizmat> and the conference hasn't even started yet

[19:47] *** bluescreen100 joined
[19:47] <masak> I also want to publicly announce that my strategy at YAPC::NA will be to explicitly *avoid* confrontations of any kind. I'm not interested in drama. I will leave a situation rather than be a participant or spectator of it.

[19:47] <masak> if I can, I will find lizmat and arnsholt and discuss linguistics with them ;)

[19:47] <lizmat> masak: good plan, let's hack!

[19:47] <PerlJam> masak: so ... no hugs?  ;)

[19:47] <masak> and hack, of course.

[19:47] <masak> PerlJam: no unannounced hugs.

[19:48] <lizmat> only with mutual consent!!!!!

[19:48] <PerlJam> <masak>  I wish to hug you, do you consent to this hug?

[19:48] <lizmat> hugme: hug masak

[19:48] * hugme hugs masak

[19:49] <lizmat> oops, that was without consent

[19:49] <lizmat> the motto of a good friend of mine; "arms are made

[19:49] <lizmat> for hugging"

[19:50] *** bluescreen10 left
[19:50] <PerlJam> "Breaking news ... pandemonium broke out in Austin today at a conference for Perl geeks when a series of unannounced hugs led to a large hug-pile that sent 4 people to the hospital."

[19:51] <PerlJam> .oO( panda-monium has some sixiness )

[19:52] <lizmat> "a spokespersons for the huggies said that all hugs were given with consent"

[19:52] <masak> lizmat: following Postel's Law, I accept hugs liberally, but emit hugs conservatively ;)

[19:54] *** sftp left
[19:54] <diakopter> yeah my mail was rejected

[19:54] <diakopter> removing him didn't need invoking the coc at all... just normal mailing list administration.  also, the coc doesn't mention anything about removal from mailing lists as a consequence.

[19:54] *** sftp joined
[19:54] <diakopter> ""

[19:56] <PerlJam> diakopter: um ... "any action they deem appropriate" is fairly broad. 

[19:56] <diakopter> oh

[19:56] <lizmat> this just in: Perl will have a booth and a devroom at the Froscon!

[19:57] <lizmat> http://www.froscon.de/en/home/

[19:57] <dalek> rakudo-star-daily: ccb6549 | coke++ | log/ (5 files):

[19:57] <dalek> rakudo-star-daily: today (automated commit)

[19:57] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/ccb65494c4

[19:58] <[Coke]> only real star module change is that panda dropped half its tests.

[19:58] <[Coke]> (but still passes them all)

[20:00] <tadzik> *relief*

[20:00] <tadzik> [Coke]++ for those tests

[20:01] <labster> good postnoon, #perl6

[20:02] <labster> The drama on the yapc list looks pretty minor compared to what I've experienced in student government conferences.

[20:02] <lizmat> hugme: hug labster

[20:02] * hugme hugs labster

[20:02] * labster is hugged

[20:02] <PerlJam> lizmat: A liberal reading of #2 in http://www.yapcna.org/yn2013/code-of-conduct.html could consider #yapc and the yapc mailing list be "conference-related social events"

[20:03] *** adu joined
[20:03] <labster> hi lizmat

[20:04] <lizmat> hi labster!

[20:04] <lizmat> PerlJam: topic in #yapc is "Topic is UNOFFICIAL channel for Various YAPCs"

[20:05] *** prevost joined
[20:06] <lizmat> PerlJam: that is *very* liberal

[20:06] <PerlJam> aye. the "UNOFFICIAL" was added in direct response to that other CoC fiasco.  Still doesn't mean that someone won't consider #yapc a "conference-related social event"

[20:09] <labster> r: my ($a, $c); ($a, $, $c) = 1..3;

[20:09] <camelia> rakudo 14e7d7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of $, variable; in Perl 6 please use .join() method‚ê§at /tmp/OlBWFcsobt:1‚ê§------> [32mmy ($a, $c); ($a, $,[33m‚èè[31m $c) = 1..3;[0m‚ê§¬ª

[20:09] *** SamuraiJack left
[20:09] <labster> http://perlcabal.org/syn/S02.html#Names says that line 'will result in the message, "Anonymous variable requires declarator".'

[20:10] <TimToady> std: foo: foo 42

[20:10] <camelia> std 52b6353: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row at /tmp/TNTRd1GJTA line 1:‚ê§------> [32mfoo: foo [33m‚èè[31m42[0m‚ê§    expecting any of:‚ê§ infix or meta-infix‚ê§    infixed function‚ê§       statement modifier loop‚ê§Parse failed‚ê§FAILED 00:00 42m‚ê§¬ª

[20:10] <labster> r: my ($a, $c); ($a, $ , $c) = 1..3; #added space

[20:10] <camelia> rakudo 14e7d7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Non-declarative sigil is missing its name‚ê§at /tmp/eFX9NIpWzs:1‚ê§------> [32mmy ($a, $c); ($a, $[33m‚èè[31m , $c) = 1..3; #added space[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix stopper‚ê§        infix or meta-infix‚ê§        ‚Ä¶

[20:10] <masak> labster: seems the error message is shadowed by rakudo thinking it's the $, variable

[20:11] <masak> ...or another error message is. :)

[20:11] <labster> so, theoretically a rakudobug, but do we really want exact wording for error messages defined by the spec?

[20:12] *** kaare_ left
[20:15] <masak> I think it's a rakudobug that it considers ($a, $, $c) as being the '$,' variable.

[20:15] <PerlJam> labster: The message in the spec at least points them in the direction that anonymous vars can only be used in declarators

[20:15] <masak> but I don't know what to do about it, really.

[20:18] <labster> Well really, the only place you should ever write $, is in a subroutine signature.

[20:19] * lizmat just got caught for the nth time doing a ternary with || rather than !!

[20:20] <PerlJam> labster: You don't think  "my ($a,$,$c) = $string.split(/\t/);" would ever happen?

[20:20] *** sftp_ joined
[20:20] <labster> oh... right

[20:20] <labster> I'm not thinking straight.

[20:21] <lizmat> r:my ( $a, Mu, $c )= <a b c>; say $a; say $c

[20:21] <lizmat> r: my ( $a, Mu, $c )= <a b c>; say $a; say $c

[20:21] <camelia> rakudo 14e7d7: OUTPUT¬´a‚ê§c‚ê§¬ª

[20:21] *** kivutar joined
[20:21] *** sftp left
[20:21] <labster> r: my ($a,$,$c) = "a b c".split(/\s/);

[20:21] <camelia> rakudo 14e7d7:  ( no output )

[20:22] <labster> hm

[20:27] <dalek> std: 8850393 | larry++ | STD.pm6:

[20:27] <dalek> std: only carp about P5 $, variable where it's obvious

[20:27] <dalek> std: review: https://github.com/perl6/std/commit/8850393dd7

[20:34] <masak> TimToady++

[20:35] <labster> okay, shall i submit a proper rakudobug then?

[20:35] <PerlJam> labster: can't hurt

[20:36] <jnthn> plz reference the STD commit TimToady++ just made too, so the fixer knows where to steal a fix :)

[20:37] * lizmat is feeling dense

[20:38] <lizmat> given a hash %h, I want to pass that to a sub and have the contents of the hash be interpreted as named parameters

[20:38] <lizmat> :%h is close, but not really what I want  :-)

[20:39] <timotimo> r: my %h = a=>1, b=>2; sub foo(:$a, :$b) { say "$a, $b" }; foo(\%h);

[20:39] <camelia> rakudo 14e7d7: OUTPUT¬´Too many positional parameters passed; got 1 but expected 0‚ê§  in sub foo at /tmp/j2LMZcc6XS:1‚ê§  in block  at /tmp/j2LMZcc6XS:1‚ê§‚ê§¬ª

[20:39] <masak> r: sub foo(:$named1, :$named2) { say "$named1 $named2" }; my %h = named1 => "OH", named2 => "HAI"; foo(|%h)

[20:39] <camelia> rakudo 14e7d7: OUTPUT¬´OH HAI‚ê§¬ª

[20:39] * labster submits rakudobug

[20:39] <lizmat> |  duh!

[20:39] <lizmat> masak++

[20:39] <masak> lizmat: prefix:<|> flattens arrays into positionals and hashes into nameds.

[20:40] * lizmat tests 2nd attempt at Hash.new accepting :type and :of parameters

[20:45] <lizmat> TimToady: should something like .ofkey be specced ?

[20:46] *** chrisdev_ joined
[20:48] <lizmat> If we're going to use .ofkey as the method to get the type of the typed hash, then maybe the :type parameter to .hash() should me also called ".ofkey" ?

[20:48] *** bruges left
[20:48] <lizmat> *maybe

[20:48] <masak> pending TimToady's answer to "should it be spec'd", my guess is on "yes" :)

[20:49] <TimToady> that's a misuse of "of", I think

[20:49] <TimToady> druther have something like .keytype

[20:49] *** chrisdev left
[20:49] <TimToady> or if "of" is what you get from a hash, the other is the "for" type or some such

[20:50] <masak> .keytype is the best I've heard so far.

[20:50] <masak> .for is cute, but less clear.

[20:50] *** bruges joined
[20:50] *** SamuraiJack_ left
[20:50] <TimToady> but I think the original idea was that you'd get these types by instantiating a role, and that role just instantiates to Str,Any by default

[20:51] <TimToady> doing it by attaching info to the constructor means you're always forced to do introspection to find out if two types are equal, and introspection is kinda smelly

[20:52] <TimToady> with classes you can use named equivalence sometimes

[20:54] <lizmat> so effectively you're saying they're *all* typed hashes

[20:54] <lizmat> the fact that the underlying implementation is Str,Any with other keytypes and .ofs bolted on top

[20:55] <lizmat> is now leaking out

[20:55] <TimToady> I said they were all typed last night, iirc

[20:56] <TimToady> when I carped about calling these "typed hashes" :)

[20:56] <TimToady> unlike in P5, where both computer and user are confused about the types, in P6 we only want the user confused :)

[20:57] <lizmat> hehe, mission accomplished !

[20:57] * masak helpfully links to http://irclog.perlgeek.de/perl6/2013-05-20#i_7092388

[20:59] <FROGGS> good evening

[20:59] <lizmat> evening FROGGS!

[21:00] <masak> FROGGS! \o/

[21:01] <FROGGS> :o)

[21:03] *** zby_home_ left
[21:05] *** skids left
[21:05] <labster> yo FROGGS 

[21:06] <FROGGS> o/

[21:06] <FROGGS> there are nice bur reports in my inbox

[21:06] <FROGGS> bug*

[21:07] <timotimo> hey froggs :)

[21:07] <timotimo> do you have an idea how to finish the ENTER/FIRST support?

[21:08] <FROGGS> timotimo: no

[21:08] <FROGGS> timotimo: I guess my approach isnt wrong at all, I'm just not sure why it is failing

[21:09] <FROGGS> maybe that indirect lookup does something wrong or the variable is declared in the wrong place

[21:09] <timotimo> what's the failure mode? i haven't tried it tbh

[21:09] *** alester joined
[21:09] <FROGGS> timotimo: there is a comment attached which shows the error

[21:10] *** spider-mario left
[21:12] <timotimo> ah, ok, let me see

[21:12] <timotimo> was it a secret gist?

[21:12] <timotimo> ah, here it is

[21:27] <lizmat> TimToady: isn't S04:1639 contradicting S06:3298  ??   The reason I'm asking is that I want to change "sub hash(*@a, *%h) { my % = @a, %h }" to "sub hash(*@a, *%h) { @a.hash(|%h) }" to allow for setting type and .of

[21:27] <lizmat> and the example at S04:1639 seems to make that impossible ( even though it is now implemented that way)

[21:27] * lizmat now running spectest with that change

[21:29] <colomon> lizmat++

[21:30] *** adu left
[21:32] *** kurahaupo joined
[21:38] *** kurahaupo left
[21:41] *** muixirt left
[21:41] *** erkan left
[21:50] <lizmat> r: sub a { say "Positional:"; say @_.perl; say "Named:"; say %_.perl }; a( "a" => 1 ); say "==="; a( a=>1 )   # un-autoquoted pairs become positional?

[21:50] <camelia> rakudo 14e7d7: OUTPUT¬´Positional:‚ê§Array.new("a" => 1)‚ê§Named:‚ê§().hash‚ê§===‚ê§Positional:‚ê§Array.new()‚ê§Named:‚ê§("a" => 1).hash‚ê§¬ª

[21:51] *** kurahaupo joined
[21:52] <timotimo> http://rosettacode.org/wiki/Galton_box_animation#Perl_6 - i RosettaCode'd :)

[21:52] <jnthn> lizmat: Yes.

[21:53] <lizmat> ok, well I was surprised to see t/spec/S04-statement-parsing/hash.t test 4+5 succeed, when I had expected them to fail

[21:54] <lizmat> which would make S04:1639 *not* contradicting S06:3298, as "a" => 1 is not a pair when specified as a parameter

[21:55] <lizmat> which means that tests 6+7 in  t/spec/S04-statement-parsing/hash.t are wrong according to spec

[21:55] <timotimo> oh, that's curious

[21:55] <lizmat> but right in the current implementation of hash()

[21:56] <timotimo> is that to do with only allowing identifiers to be passed as nameds or something?

[21:56] <lizmat> I have no idea‚Ä¶ I'm just the messenger in this

[21:56] <lizmat> :-)

[21:56] *** xilo left
[21:57] *** adu joined
[22:03] *** lustlife left
[22:07] *** dmol left
[22:08] *** prevost left
[22:08] *** bluescreen100 left
[22:09] <lizmat> spectest complete, only  t/spec/S04-statement-parsing/hash.t test 6+7 failed, as expected

[22:15] <lizmat> Hash.new() and hash() accept the same typed parameters as .hash() , see https://github.com/rakudo/rakudo/pull/156 for your perusal

[22:16] <jnthn> Does this break hash(a => 1, b => 2) ?

[22:16] <lizmat> yes

[22:16] <jnthn> I. Um. Don't think that'll fly...

[22:16] <lizmat> but that is not according to spec

[22:16] <jnthn> Hmm.

[22:16] <jnthn> I'm too tired to go look.

[22:17] <lizmat> it does not break hash( "a" => 1, "b" => 2 )

[22:17] <jnthn> It just feels wrong/surprising.

[22:17] <lizmat> well, to an extent I agree with you

[22:17] *** xilo joined
[22:17] <timotimo> r: hash( :foo<bar> ).perl.say

[22:17] <camelia> rakudo 14e7d7: OUTPUT¬´("foo" => "bar").hash‚ê§¬ª

[22:17] <timotimo> will this work?

[22:17] <lizmat> but that is the same as with Hash.new( a=>1 ) not working either

[22:18] <lizmat> timotimo: no

[22:18] <timotimo> mhm

[22:18] <lizmat> r: Hash.new( :foo<bar> ).perl.say

[22:18] <camelia> rakudo 14e7d7: OUTPUT¬´().hash‚ê§¬ª

[22:18] <lizmat> it would make it consistent with Hash.new

[22:19] <timotimo> sounds kind of sensible so far

[22:19] <lizmat> in the current implementation, Hash.new and hash() are not doing the same thing

[22:20] <timotimo> is that after your changes or before?

[22:20] <lizmat> as far as I'm concerned, this could go either way

[22:20] <lizmat> *before* my changes

[22:20] <lizmat> if this pull request is merged, they would do the same

[22:20] <lizmat> (as they both just call .hash)

[22:22] <timotimo> mhm

[22:22] <timotimo> i wonder how much existing code would be b0rked by the change?

[22:23] <timotimo> i think it would be kind of surprising that autoquoted and non-autoquoted would be treated differently, but at the same time treating "of" and "key" or so differently would be bad, too

[22:23] <lizmat> well, I was surprised by Hash.new( a => 1 ) not working, for sure

[22:24] <lizmat> the argument in that case was, that named parameters should be passable so alter the behaviour of Hash.new

[22:24] <lizmat> *to

[22:25] <timotimo> right

[22:25] <lizmat> and I think hash() is just short for Hash.new

[22:25] <timotimo> the form (...).hash seems most sensible, tbh

[22:26] <lizmat> well, I'll check further comments in the backlog tomorrow

[22:26] <lizmat> goodnight #perl6!

[22:26] <timotimo> good night :)

[22:28] *** REPLeffect left
[22:30] <jnthn> sleep &

[22:31] *** skids joined
[22:50] <timotimo> http://rosettacode.org/wiki/Galton_box_animation#Perl_6 - now with animated gif

[22:51] <masak> nice.

[22:51] *** kivutar left
[22:54] <masak> 'night, #perl6

[22:54] <colomon> \o

[22:54] <timotimo> why is the stray frame still in there? :(

[22:57] *** adu left
[22:57] * lue didn't notice a stray frame, even when knowing it was there

[22:58] <timotimo> it has a different background color and a different placement of the pegs and such

[22:58] <timotimo> i'm thoroughly confused

[23:01] <timotimo> the file i selected on disk doesn't have the frame, then i try to upload it and i end up with the version that has the frame. i can even wget it back down and it will have the stray first frame in there

[23:05] <lue> how different is the background color? (it's black the whole time for me)

[23:06] <timotimo> #000000 vs #161819

[23:06] <timotimo> also, the pegs are in different places

[23:07] <timotimo> http://rosettacode.org/wiki/File:Galton_Box_Perl_6.png - this frame ended up in the beginning by accident

[23:08] *** census left
[23:11] <lue> I'm afraid I don't see that stray frame :/

[23:12] <timotimo> can you reproduce the stray frame in the first version of the image?

[23:12] *** shinobicl joined
[23:14] <lue> Ah, it's in the first uploaded picture, easy to spot :) [didn't notice it in the second or the current one]

[23:14] <timotimo> what, weird!

[23:14] <timotimo> when i point wget at the url, i definitely get the stray frame

[23:14] <timotimo> ah, whatever, i'll just ignore it

[23:15] <lue> fwiw I didn't use wget to download the picture from rosettacode

[23:15] <timotimo> don't need to

[23:15] <lue> (the stray frame appeared neither in the download of the current one nor in viewing the second or last version in browser)

[23:17] <timotimo> thanks. my setup must be severely disturbed then

[23:17] <lue> But it was there at some point, at least your setup's not *that* disturbed :)

[23:29] *** btyler left
[23:40] *** ehouse joined
[23:46] <ehouse> does perl6 have to be installed in your homedir for panda to work?

[23:49] <ehouse> I have it installed system wide and panda can't find .work

[23:53] *** prevost joined
[23:54] *** shinobicl left
[23:58] *** PacoAir left
