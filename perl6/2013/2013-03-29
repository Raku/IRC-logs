[00:00] <pmichaud> looking

[00:01] <pmichaud> Iterable.Numeric has a :D invocant

[00:01] <pmichaud> so Range.Numeric probably should also.

[00:02] <[Coke]> adding.

[00:03] <pmichaud> [Coke]++   # ticket wrangler extraordinaire

[00:03] <[Coke]> eh. It's the easiest thing I can do. I tried several times this morning to pull at other threads, and it went nowhere.

[00:04] <thundergnat> pmichaud: at your convenience, could you take a peek at https://gist.github.com/thundergnat/5265633 and comment?

[00:04] <[Coke]> oh, right, I knew I was forgetting to ask him something!

[00:05] <pmichaud> thundergnat: I don't quite see why the infinite version is preferable.

[00:05] <thundergnat> ???

[00:06] <thundergnat> The version that returns in 5 vs 5000 seconds is preferable.

[00:06] <pmichaud> I don't see why the Any version takes 5000 seconds.

[00:06] <pmichaud> it shouldn't.

[00:08] <thundergnat> r: my @harshad := gather for 1 .. * { take $_ if $_ %% [+] .comb };  say @harshad.first: {$^_ > 1000}; # takes 5400 seconds locally to return an answer

[00:08] <p6eval> rakudo 25a9d6: OUTPUT«(timeout)»

[00:08] <pmichaud> right, so that tells me there's a bug somewhere in the list code.

[00:08] <pmichaud> and the way to fix that is by fixing the list code, not by patching around the bug.

[00:09] <thundergnat> Should I file a bug report then?

[00:10] <pmichaud> sure, that works.

[00:10] <thundergnat> Ok, thanks for looking.

[00:10] <pmichaud> the code in Any.first ought to be suitably lazy that it can find an element without racing too far afield in an infinite list.

[00:11] <dalek> v5: b597d4f | (Tobias Leich)++ | Makefile:

[00:11] <dalek> v5: set the deps right, so we just can type: make

[00:11] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/b597d4fc07

[00:11] <dalek> v5: 8d53962 | (Tobias Leich)++ | lib/Perl6/P5Actions.pm:

[00:11] <dalek> v5: add support for $^X

[00:11] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8d53962e2d

[00:11] <pmichaud> if it's not doing that, then there's a bug or incorrect optimization somewhere in the ListIterator code

[00:11] <[Coke]> r: say (6..6).list

[00:11] <p6eval> rakudo 25a9d6: OUTPUT«6␤»

[00:12] <[Coke]> r: say +(6..6)

[00:12] <p6eval> rakudo 25a9d6: OUTPUT«1␤»

[00:13] <dalek> Heuristic branch merge: pushed 23 commits to rakudo/extend-dump by japhb

[00:13] <FROGGS_> nr: say $*PROGRAM_NAME

[00:13] <p6eval> niecza v24-35-g5c06e28: OUTPUT«/tmp/_Ocji7ySdS␤»

[00:13] <p6eval> ..rakudo 25a9d6: OUTPUT«/tmp/9DKvxVfGZJ␤»

[00:13] <pmichaud> thundergnat: out of curiosity, is Any.first also slow for finite-but-large lists in your example?

[00:13] <FROGGS_> can this be right? I expect to get something with a leading 'perl6' for $*PROGRAM_NAME

[00:13] <FROGGS_> it is -e though on command line

[00:14] <pmichaud> i.e., is the slowness due to the infinite nature of the source list, or just because it's very large?

[00:14] <thundergnat> pmichaud: no, not particularly. At least nowhere near the same 

[00:15] <FROGGS_> ahh, hold on, I'm doing that wrong

[00:16] <thundergnat> pmichaud: It only seems to occur in lists created using gather take. I wonder if it is some weird interaction between GatherIter and ListIter?

[00:18] * [Coke] drinks a double agent ipl from sam adams.

[00:20] <pmichaud> oh, GatherIter is indeed suboptimal for a lot of stuff.

[00:20] <pmichaud> there definitely needs to be some improved communication between GatherIter and MapIter

[00:21] <pmichaud> I suspect that MapIter tries to go too far ahead when confronted with an infinite GatherIter

[00:21] <pmichaud> or, more likely...

[00:22] <pmichaud> the gather isn't able to signal that it's infinite, and that's causing MapIter to go too far ahead

[00:22] <thundergnat> That seems likely

[00:23] <thundergnat> It seems like it tries to reify 10000 elements before it starts to do comparisons.

[00:24] <pmichaud> yes

[00:24] <pmichaud> if we make that number smaller, however, than things like   for 1..10000 { ... }   will get significantly slower

[00:25] <thundergnat> yep

[00:25] <pmichaud> so there has to be some improved communication between the lists

[00:25] <pmichaud> which is something that I'm working on (and there are several other problems that need addressing)

[00:25] <pmichaud> unfortunately there's a lot of interrelated stuff in the waterbed of lists in Perl 6 that still needs to be worked out.  :)

[00:26] <thundergnat> I messed around with the .reify method to try to make it less excrucating but really just made other things worse.

[00:26] <pmichaud> yeah

[00:26] <pmichaud> and we're going to have to adjust a lot of the list code soon anyway because the value/container model that Rakudo uses needs some other changes (to bring it up to spec and to be usable on JVM)

[00:27] <thundergnat> Ah.

[00:27] <pmichaud> so, while I encourage experimentation here, just know that any patches might get ripped out soon :)

[00:28] <pmichaud> I do agree that .first as it exists now on the example you gave is not ideal.  I just don't think that having specialized version for infinite lists is the proper fix... the better fix is to make sure that for self.list { ... }  in Any.first can be appropriately lazy.

[00:28] <pmichaud> anyway, I have to run for a while 

[00:28] <thundergnat> Well, i was a nice learning experience / experiment for me at least. :) Thanks again!  

[00:28] <pmichaud> thank you for the bug report

[00:28] <pmichaud> it's _extremely_ helpful as an example.

[00:29] <pmichaud> coming up with good benchmark examples is one of the toughest parts of this :)

[00:29] <dalek> v5: 331adc7 | (Tobias Leich)++ | lib/Perl6/P5Actions.pm:

[00:29] <dalek> v5: $^X should be $*EXECUTABLE_NAME

[00:29] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/331adc76a1

[00:29] <pmichaud> note to channel:  I do expect to be able to produce a candidate Star release tomorrow (Fri), but may be sidetracked for the day again.

[00:30] <pmichaud> Will definitely let the channel know so that someone else can pick up the 2013.03 release if needed.

[00:30] <[Coke]> r: say +(1..10), +(1..^10), +(1^..10), +(1^..^10), +(10..10), +(10..9)

[00:30] <p6eval> rakudo 25a9d6: OUTPUT«1099810␤»

[00:31] <[Coke]> r: say (+(1..10), +(1..^10), +(1^..10), +(1^..^10), +(10..10), +(10..9)).join("|");

[00:31] <p6eval> rakudo 25a9d6: OUTPUT«10|9|9|8|1|0␤»

[00:40] <FROGGS_> does somebody know what this X< ... > is suppose to mean at there very end? http://doc.perl6.org/language/variables

[00:41] <chee> perl6 to  js compulller?

[00:41] <FROGGS_> chee: you are talking (weird) about Perlito6 ?

[00:44] <chee> 1i am  asking

[00:44] <chee> is it?

[00:44] <[Coke]> FROGGS_: there's a lot of ...'s in that document.

[00:44] <[Coke]> or are you referring to the X<> ?

[00:44] <FROGGS_> [Coke]: right, the X<> around the vars

[00:45] <[Coke]> oh, I see what you mean.

[00:45] <[Coke]> probably some 5pod that didn't get updated.

[00:48] <[Coke]> r: say +(1.2..4)

[00:48] <p6eval> rakudo 25a9d6: OUTPUT«3␤»

[00:49] <[Coke]> r: say +(1..^3.3)

[00:49] <p6eval> rakudo 25a9d6: OUTPUT«3␤»

[00:49] <[Coke]> r: say (1..^3.3).list

[00:49] <p6eval> rakudo 25a9d6: OUTPUT«1 2 3␤»

[00:56] <chee> ??/

[00:57] *** coas joined
[00:57] <coas> hi

[00:57] <FROGGS_> hi coas 

[00:57] *** coas left
[00:57] <FROGGS_> well, bye then

[01:02] *** thou left
[01:03] <FROGGS_> is there currently a way to get the output of a shell command? like: perl -e 'print 1 . `perl -e "print 2"` . 3' # 123

[01:03] <FROGGS_> run() and shell() only return the error code

[01:05] *** fgomez joined
[01:06] *** gdey left
[01:07] <FROGGS_> ohh there is an IO::Capture::Simple module \o/

[01:07] <FROGGS_> err

[01:19] <flussence> [Coke]: sounds like you might find this useful - https://gist.github.com/flussence/3007551

[01:21] *** am0c left
[01:21] <[Coke]> maybe 40m ago, yes. ;)

[01:21] <[Coke]> spectesting now.

[01:22] <flussence> I'm not sure it's optimal code anyway, it is half a year old... :)

[01:23] *** anuby joined
[01:25] *** gtodd joined
[01:27] *** adu_ joined
[01:28] <adu_> hey

[01:28] <adu_> so I'm getting errors I don't understand

[01:29] <FROGGS_> adu_: describe the problem and use paste-services to dump the code+error messages

[01:29] <adu_> will gist.gh.com work?

[01:29] <FROGGS_> yes

[01:31] <adu_> https://gist.github.com/andydude/5268163

[01:32] <FROGGS_> cool A C89 grammar

[01:32] <adu_> there error is "Undeclared routine: 'text-line' used at line 582"

[01:32] <adu_> it's a C11 grammar

[01:33] <gtodd> I've been trying to get bunches of perl5 scripts to run under perl6 ... 

[01:33] <adu_> I named the file before I decided which dialect I was writting

[01:33] <dalek> roast: 3e1d8bb | coke++ | S02-types/range.t:

[01:33] <dalek> roast: add more range numification tests

[01:33] <dalek> roast: review: https://github.com/perl6/roast/commit/3e1d8bb099

[01:33] <FROGGS_> adu_: looks like you're missing a $ there

[01:33] <dalek> rakudo/nom: 192b28f | coke++ | src/core/Range.pm:

[01:33] <adu_> I

[01:33] <dalek> rakudo/nom: RT#82312 - optimize size of numeric range.

[01:33] <dalek> rakudo/nom: 

[01:33] <dalek> rakudo/nom: Inspired by a patch from Gilbert Röhrbein [email@hidden.address]
[01:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/192b28fafd

[01:34] <FROGGS_> <group(text-line)> is a function call to group with text-line as param

[01:34] <adu_> FROGGS_: I've never written perl5, so I don't know how routine's without args (i.e. routine refs) are supposed to work

[01:34] <adu_> I'm moving from Haskell to Perl6

[01:34] <FROGGS_> forget about perl5, this is totally different :o)

[01:35] <adu_> so <group($text-line)>

[01:35] <adu_> or <group(&text-line)>

[01:35] <FROGGS_> $text-line

[01:35] <FROGGS_> ahh, hold on

[01:35] <adu_> ok, then when I want to use it <$text-line> or <($text-line)>?

[01:36] <FROGGS_> I have to read a bit more carefully

[01:36] <adu_> it's a regex parameter

[01:37] <FROGGS_> ya, but I'm not sure you can pass a reference to a sub (the token) just like that

[01:37] <adu_> hmm

[01:37] <FROGGS_> let me fork your gist

[01:37] <adu_> well, that was the beginning of my nonstandard extensions

[01:38] <adu_> I was hoping restrict the places that pp-includes could appear, surounding decls and surounding stmts, 

[01:39] <adu_> which is why I wanted to parameterize group

[01:39] <adu_> <group(/<text-line>/)> maybe?

[01:40] <FROGGS_> https://gist.github.com/FROGGS/5268178/revisions

[01:41] <FROGGS_> you have a proto group-part, and several rules/token attached to it

[01:41] <FROGGS_> if you say, you want to match one of the tokens (any of them), you just match against the proto's name

[01:41] <FROGGS_> like against <group-part>

[01:42] <FROGGS_> you dont need an parameter there

[01:42] <gtodd> FROGGS_:   since they are scripts they often work just fine with very few changes

[01:42] *** thundergnat left
[01:45] <adu_> FROGGS_: do you understand what I'm trying to do?

[01:45] <FROGGS_> adu_: I think so, yes

[01:45] <adu_> the line where it says "rule group-part:sym<text-line> { <text-line> }"

[01:46] <adu_> I'm trying to replace it with <decl>+ in some places and <stmt>+ in other places

[01:46] <adu_> I guess I could just make stmt-group and decl-group

[01:46] <adu_> but that would be in a separate file that subclasses this

[01:47] <adu_> FROGGS_: anyways, thanks for the help

[01:47] <[Coke]> f

[01:47] <colomon> rn: say 2i.conj

[01:47] <p6eval> rakudo 25a9d6, niecza v24-35-g5c06e28: OUTPUT«0-2i␤»

[01:47] <colomon> rn: say 2.conj

[01:47] <p6eval> rakudo 25a9d6, niecza v24-35-g5c06e28: OUTPUT«2␤»

[01:47] <FROGGS_> adu_: what will you get when you rename something to <decl>?

[01:48] <[Coke]> ... was it already in there after all these years?

[01:48] <FROGGS_> adu_: you won't fix the grammar if there are errors

[01:48] <colomon> rn: say conj 2+2i

[01:48] <p6eval> niecza v24-35-g5c06e28: OUTPUT«2-2i␤»

[01:48] <p6eval> ..rakudo 25a9d6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    conj used at line 1␤␤»

[01:49] <colomon> [Coke]: if you're talking to me, yes.

[01:49] <[Coke]> aye.

[01:49] <FROGGS_> gtodd: but perl 5 has no grammars...

[01:49] <adu_> so step 1 is unparameterize them

[01:49] <[Coke]> I just moved the ticket without checking.

[01:50] <[Coke]> rakudo: multi foo(:$a!, *%_) {}; multi foo(:$b, *%_) {}; foo(:a, :b)

[01:50] <p6eval> rakudo 25a9d6:  ( no output )

[01:50] <FROGGS_> adu_: well, you should at least not to try to pass tokens as params around

[01:50] <adu_> FROGGS_: but what if that's what I want to do?

[01:50] <FROGGS_> adu_: flags are okay, that happens in Perl6's grammar too

[01:50] <adu_> FROGGS_: but Haskell does it all the time

[01:50] <FROGGS_> then you have to explain what it should do with the given param

[01:51] <adu_> ok

[01:51] <FROGGS_> should it filter the list of dispatchers?

[01:51] <FROGGS_> like only the one token of the group should match?

[01:51] <colomon> [Coke]: it's in the spec as well, but it seems to be conjugate there.

[01:52] <adu_> as I said, I'm working on a nonstandard dialect of C in which CPP is not expanded, so I'd like to replace <text-line> with <declaration> in some places, and replace <text-line> with <statement> in other places, essentially to skip the preprocessing step

[01:52] <FROGGS_> I meant, what should 'passing a token around' do?

[01:54] <adu_> <group($text-line)> should pass it to <group-part> which would match { <declaration> } if $text-line = declaration

[01:55] <adu_> I suppose I could also make an enum

[01:55] *** gtodd left
[01:55] *** gtodd joined
[01:55] <FROGGS_> then you have to use the given param $text in this case, and match it literally

[01:56] <FROGGS_> but you are not using $text here: https://gist.github.com/FROGGS/5268178#file-stdc89parser-pm6-L584

[01:56] <dalek> specs: f348a0a | colomon++ | S32-setting-library/Numeric.pod:

[01:56] <dalek> specs: Update Numeric.pod

[01:56] <dalek> specs: 

[01:56] <dalek> specs: Change conjugate to conj.  (Another location in the spec, the compilers, and roast all had it as conj.)

[01:56] <dalek> specs: review: https://github.com/perl6/specs/commit/f348a0aa51

[01:56] <adu_> in haskell this would be ruleA p = between "(" ")" p; ruleB = …; ruleC = ruleA ruleB

[01:56] <pmichaud> [Coke]: the patch fails the following:

[01:57] <pmichaud> > say +(2.3 .. 3.1)

[01:57] <pmichaud> 2

[01:57] <pmichaud> rn: say +(2.3 .. 3.1)

[01:57] <dalek> roast: a2664ea | coke++ | S06-multi/syntax.t:

[01:57] <dalek> roast: Add test for RT #68528

[01:57] <dalek> roast: review: https://github.com/perl6/roast/commit/a2664ea786

[01:57] <p6eval> rakudo 25a9d6, niecza v24-35-g5c06e28: OUTPUT«1␤»

[01:57] <adu_> I'm trying to understand why this isn't working the same way in perl6

[01:58] <FROGGS_> adu_: feels a bit like like: rule A( $p ) { '(' ~ ')' <$p> }

[01:58] <adu_> rule ruleA($p) { '(' ~ ')' <$p> }; rule ruleB { … }; rule ruleC { <ruleA(&ruleB)> }

[01:58] <[Coke]> r: say (2.3..3.1).list

[01:58] <p6eval> rakudo 25a9d6: OUTPUT«2.3␤»

[01:58] *** tgt left
[01:58] <adu_> is that right?

[01:58] <[Coke]> r: say +(2.3..3.1)

[01:58] <p6eval> rakudo 25a9d6: OUTPUT«1␤»

[01:58] <FROGGS_> adu_: looks sane to me

[01:59] <adu_> FROGGS_: is the & right?

[01:59] <[Coke]> pmichaud: danke.

[01:59] <FROGGS_> adu_: think so, yes, since without it you would try to call that method

[01:59] <adu_> ok

[01:59] <FROGGS_> just try this one-liner

[02:01] <FROGGS_> r: grammar G { rule TOP { <A>+ }; rule A { <B(&C)> }; rule B($what) { <$what> }; rule C( 'test' ) }; G.parse('testtest')

[02:01] <p6eval> rakudo 25a9d6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$what' is not declared␤at /tmp/AgGnGKnN39:1␤------> [32mA { <B(&C)> }; rule B($what) { <$what> }[33m⏏[31m; rule C( 'test' ) }; G.parse('testtest'[0m␤    expecting any of:␤        postfix␤        infix stopper␤        hor…

[02:02] <adu_> per6: grammar G {rule rA($p) { '(' ~ ')' <$p> }; rule rB { '_' }; rule rC { <rA(&B)> }; }; G.parse("(_)")

[02:02] <adu_> r: grammar G {rule rA($p) { '(' ~ ')' <$p> }; rule rB { '_' }; rule rC { <rA(&B)> }; }; G.parse("(_)")

[02:02] <p6eval> rakudo 25a9d6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$p' is not declared␤at /tmp/QnnZN1swdB:1␤------> [32mrammar G {rule rA($p) { '(' ~ ')' <$p> }[33m⏏[31m; rule rB { '_' }; rule rC { <rA(&B)> };[0m␤    expecting any of:␤        statement list␤        prefix or term␤      …

[02:02] <FROGGS_> r: grammar G { rule TOP { <A>+ }; rule A { <B(&C)> }; method B($what) { <$what> }; rule C { 'test' } }; G.parse('testtest')

[02:02] <p6eval> rakudo 25a9d6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    &C used at line 1␤␤»

[02:05] <adu_> r: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <$what> }; regex C { 'test' }; regex A { <B(&C)> }; }; G.parse('testtest')

[02:05] <p6eval> rakudo 25a9d6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$what' is not declared␤at /tmp/uWUbOOVA_9:1␤------> [32mP {^ <A>+ $}; regex B($what) { <$what> }[33m⏏[31m; regex C { 'test' }; regex A { <B(&C)> [0m␤    expecting any of:␤        statement list␤        prefix or term␤   …

[02:09] <adu_> r: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::($what)> }; regex C { 'test' }; regex A { <B('C')> }; }; G.parse('testtest')

[02:09] <p6eval> rakudo 25a9d6: OUTPUT«No such method 'QAST::Var<1988309812>' for invocant of type 'G'␤  in regex B at /tmp/RtzoutigI0:1␤  in regex A at /tmp/RtzoutigI0:1␤  in regex TOP at /tmp/RtzoutigI0:1␤  in method parse at src/gen/CORE.setting:10941␤  in block  at /tmp/RtzoutigI0:1␤␤»

[02:09] <adu_> n: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::($what)> }; regex C { 'test' }; regex A { <B('C')> }; }; G.parse('testtest')

[02:09] <p6eval> niecza v24-35-g5c06e28:  ( no output )

[02:09] <[Coke]> r: say (2.3..4.1).list

[02:09] <p6eval> rakudo 25a9d6: OUTPUT«2.3 3.3␤»

[02:10] <adu_> n: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::($what)> }; regex C { 'test' }; regex A { <B('C')> }; }; say G.parse('testtest')

[02:10] <p6eval> niecza v24-35-g5c06e28: OUTPUT«｢testtest｣␤ A => ｢test｣␤  B => ｢test｣␤   ::($what) => ｢test｣␤ A => ｢test｣␤  B => ｢test｣␤   ::($what) => ｢test｣␤␤»

[02:10] <adu_> YES! it worked in niecza

[02:10] <adu_> you can pass method names

[02:10] *** Chillance left
[02:11] <FROGGS_> adu_: can you file a ticket for that please? -> [email@hidden.address]
[02:12] <adu_> don't tell me that I'm the first person to try symbolic indirect rules?

[02:12] <FROGGS_> well, you might the first one who opens a ticket :/

[02:16] *** gdey joined
[02:17] <adu_> sent

[02:17] *** lustlife joined
[02:19] <FROGGS_> r: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::C()> }; regex C { 'test' }; regex A { <B('C')> }; }; say G.parse('testtest')

[02:19] <p6eval> rakudo 192b28: OUTPUT«｢testtest｣␤ A => ｢test｣␤  B => ｢test｣␤   C => ｢test｣␤ A => ｢test｣␤  B => ｢test｣␤   C => ｢test｣␤␤»

[02:19] <FROGGS_> r: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::"$what"()> }; regex C { 'test' }; regex A { <B('C')> }; }; say G.parse('testtest')

[02:19] <p6eval> rakudo 192b28: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[02:19] <FROGGS_> r: grammar G { rule TOP {^ <A>+ $}; regex B($what) { <::"C"()> }; regex C { 'test' }; regex A { <B('C')> }; }; say G.parse('testtest')

[02:19] <p6eval> rakudo 192b28: OUTPUT«===SORRY!===␤ResizablePMCArray: Can't pop from an empty array!␤»

[02:22] <colomon> rn: say -i

[02:22] <p6eval> rakudo 192b28: OUTPUT«-0-1i␤»

[02:22] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«0-1i␤»

[02:22] <colomon> -0-1i?

[02:23] <pmichaud> rn: say (-i).re

[02:23] <p6eval> rakudo 192b28: OUTPUT«-0␤»

[02:23] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«0␤»

[02:23] <pmichaud> rn: say -0

[02:23] <p6eval> rakudo 192b28, niecza v24-35-g5c06e28: OUTPUT«0␤»

[02:23] <pmichaud> rn: say -0e

[02:23] <p6eval> rakudo 192b28: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/w60hxYhMdD:1␤------> [32msay -0[33m⏏[31me[0m␤    expecting any of:␤        whitespace␤»

[02:23] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Whitespace is required between alphanumeric tokens at /tmp/ojTwS_Ogbh line 1:␤------> [32msay -0[33m⏏[31me[0m␤␤Two terms in a row at /tmp/ojTwS_Ogbh line 1:␤------> [32msay -0[33m⏏[31me[0m␤␤Parse failed␤␤»…

[02:23] <pmichaud> rn: say -0e0

[02:23] <p6eval> rakudo 192b28: OUTPUT«-0␤»

[02:23] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«0␤»

[02:24] <pmichaud> looks like it's the Parrot/IEEE negative zero popping up.

[02:24] <pmichaud> (Parrot floats on some platforms accept the possibility of a signed zero value.)

[02:25] <colomon> makes sense

[02:25] *** daniel-s_ left
[02:29] *** thou joined
[02:32] <adu_> is that a problem?

[02:33] *** cognominal left
[02:34] *** FROGGS__ joined
[02:36] <skids> except for stuff like "int" that specs platform dependence, I would think perl6 would want to behave the same irrespective of platform.

[02:37] <lue> rn: say -0 == 0

[02:37] <p6eval> rakudo 192b28, niecza v24-35-g5c06e28: OUTPUT«True␤»

[02:37] <sorear> perl 6 *should* have negative zero on *all* platforms

[02:37] <sorear> IEEE 754 is not one of the "wheels that need reinventing"

[02:37] *** thou left
[02:38] *** thou joined
[02:38] *** FROGGS_ left
[02:38] *** cognominal joined
[02:38] <sorear> you're free to suppress the leading - in the printout if you want - I think niecza does that

[02:39] <skids> Hrm, then I may have  to amend my patches for fixing bigint bitops, ISTR neglecting that case.

[02:39] <skids> Well, actually calling them "patches" is generous

[02:39] *** gdey left
[02:40] <sorear> skids: we're only talking about the Num type here.  whether rakudo's bigints have -0 is a different question entirely

[02:40] <skids> Ah, OK.  I'll try to keep tabs on whether bigint is used in that capacity.

[02:41] *** census left
[02:41] <sorear> the Num type corresponds to IEEE 754(r) floating point numbers, typically 64 bits

[02:41] <sorear> bigints not involved at all

[02:42] <sorear> some bigint libraries use sign-magnitude representations and thus have an _internal_ -0, but AFAIK all bigint libraries do not expose -0 to the user

[02:42] <skids> So, if there's a conversion from Num(-0) to Int, what happens?

[02:42] <sorear> skids: Produces 0

[02:42] <skids> OK, then nevermind.

[02:43] *** census joined
[02:44] *** thou left
[02:44] *** thou joined
[02:45] *** xenoterracide joined
[02:47] *** cognominal left
[02:52] *** xinming_ joined
[02:54] <lue> ooc, is there a function in Perl 6 that gives you a character's unicode name (what you'd use with \c[] in a string)?

[02:54] *** xinming left
[02:57] *** thou left
[02:57] *** thou joined
[03:01] *** thou left
[03:02] *** orafu left
[03:02] *** orafu joined
[03:07] <dalek> roast: 13c6035 | coke++ | S02-types/range.t:

[03:07] <dalek> roast: add more range numification tests

[03:07] <dalek> roast: 

[03:07] <dalek> roast: pmichaud++

[03:07] <dalek> roast: review: https://github.com/perl6/roast/commit/13c603596a

[03:08] <[Coke]> pmichaud: fixed, thanks.

[03:08] <dalek> rakudo/nom: 9bf1806 | coke++ | src/core/Range.pm:

[03:08] <dalek> rakudo/nom: RT#82312 numeric value of numeric range

[03:08] <dalek> rakudo/nom: 

[03:08] <dalek> rakudo/nom: Fix another edge case. pmichaud++

[03:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9bf180636d

[03:12] *** cognominal joined
[03:15] *** preflex left
[03:16] *** preflex joined
[03:24] <adu_>  FROGGS__ what does this mean? "System.NullReferenceException: Object reference not set to an instance of an object"

[03:27] *** census left
[03:49] <adu_> does niecza support protos?

[03:50] <adu_> because my drilling indicates that niecza doesn't support protos

[03:54] *** cognominal left
[03:58] <adu_> I get that error for something as simple as <ident>

[03:59] *** cognominal joined
[04:04] <adu_> r: grammar G { token TOP {^ <id> $}; token ident { <.ident-first> <.ident-rest>* }; proto token ident-first {*}; token ident-first:sym<under> { '_' }; token ident-first:sym<alpha> { <.alpha> }; proto token ident-rest {*}; token ident-rest:sym<alpha> { <.ident-first> }; token ident-rest:sym<digit> { <.digit> }; }; G.parse('test')

[04:04] <p6eval> rakudo 192b28: OUTPUT«No such method 'id' for invocant of type 'G'␤  in regex TOP at /tmp/AWs9ZcjuqN:1␤  in method parse at src/gen/CORE.setting:10951␤  in block  at /tmp/AWs9ZcjuqN:1␤␤»

[04:04] <adu_> r: grammar G { token TOP {^ <ident> $}; token ident { <.ident-first> <.ident-rest>* }; proto token ident-first {*}; token ident-first:sym<under> { '_' }; token ident-first:sym<alpha> { <.alpha> }; proto token ident-rest {*}; token ident-rest:sym<alpha> { <.ident-first> }; token ident-rest:sym<digit> { <.digit> }; }; G.parse('test')

[04:04] <p6eval> rakudo 192b28:  ( no output )

[04:04] <adu_> r: grammar G { token TOP {^ <ident> $}; token ident { <.ident-first> <.ident-rest>* }; proto token ident-first {*}; token ident-first:sym<under> { '_' }; token ident-first:sym<alpha> { <.alpha> }; proto token ident-rest {*}; token ident-rest:sym<alpha> { <.ident-first> }; token ident-rest:sym<digit> { <.digit> }; }; say G.parse('test')

[04:04] <p6eval> rakudo 192b28: OUTPUT«｢test｣␤ ident => ｢test｣␤␤»

[04:04] <adu_> n: grammar G { token TOP {^ <ident> $}; token ident { <.ident-first> <.ident-rest>* }; proto token ident-first {*}; token ident-first:sym<under> { '_' }; token ident-first:sym<alpha> { <.alpha> }; proto token ident-rest {*}; token ident-rest:sym<alpha> { <.ident-first> }; token ident-rest:sym<digit> { <.digit> }; }; say G.parse('test')

[04:04] <p6eval> niecza v24-35-g5c06e28: OUTPUT«｢test｣␤ ident => ｢test｣␤␤»

[04:05] <adu_> ok

[04:05] <adu_> so that is working, but why is it not working for me?

[04:11] *** adu_ left
[04:12] *** kaleem joined
[04:25] <dalek> roast: 30ac27f | coke++ | S29-context/eval.t:

[04:25] <dalek> roast: add test for RT#115774

[04:25] <dalek> roast: review: https://github.com/perl6/roast/commit/30ac27fb69

[04:29] *** sdgvf joined
[04:31] <[Coke]> Where should a test for the ability to create a new twigil go?

[04:32] <[Coke]> rn: sub twigil:<∫>{}; say "alive"; #RT #73938

[04:32] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot add tokens of category 'twigil'␤at /tmp/_ey1Vc8j3A:1␤------> [32msub twigil:<∫>[33m⏏[31m{}; say "alive"; #RT #73938[0m␤    expecting any of:␤        colon pair␤        quote words␤»

[04:32] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot extend category:twigil with subs at /tmp/8UEFBBEXox line 1:␤------> [32msub twigil:<∫>[33m⏏[31m{}; say "alive"; #RT #73938[0m␤␤Potential difficulties:␤  &twigil:<∫> is declared but not used at /tmp/8UEFBBEXox line…

[04:32] <[Coke]> rn: sub twigil:<∫> {}; say "alive"; #RT #73938

[04:32] <p6eval> niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot extend category:twigil with subs at /tmp/lfM_Rep6js line 1:␤------> [32msub twigil:<∫> [33m⏏[31m{}; say "alive"; #RT #73938[0m␤␤Potential difficulties:␤  &twigil:<∫> is declared but not used at /tmp/lfM_Rep6js lin…

[04:32] <p6eval> ..rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot add tokens of category 'twigil'␤at /tmp/fMCnTCdtji:1␤------> [32msub twigil:<∫> [33m⏏[31m{}; say "alive"; #RT #73938[0m␤    expecting any of:␤        colon pair␤        quote words␤»

[04:32] <[Coke]> rn: sub twigil:<@> {}; say "alive"; #RT #73938

[04:32] <sorear> I...think rakudo is right?

[04:32] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot add tokens of category 'twigil'␤at /tmp/ahlR_BN_UA:1␤------> [32msub twigil:<@> [33m⏏[31m{}; say "alive"; #RT #73938[0m␤    expecting any of:␤        colon pair␤        quote words␤»

[04:32] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot extend category:twigil with subs at /tmp/V20tSCxbvM line 1:␤------> [32msub twigil:<@> [33m⏏[31m{}; say "alive"; #RT #73938[0m␤␤Potential difficulties:␤  &twigil:<@> is declared but not used at /tmp/V20tSCxbvM lin…

[04:33] <[Coke]> ugh. it changed since 2011 when no one wrote any tests. :P

[04:33] <hoelzro> ok, folks. I did it.

[04:33] <hoelzro> I found out how to invoke the underlying code object for Perl 6 subs

[04:33] <hoelzro> \o/

[04:34] <hoelzro> however, defining postcircumfix:<( )> for Code objects breaks Rakudo in quite a spectacular way =/

[04:34] <hoelzro> so now I'm kinda stumped.

[04:35] <[Coke]> rakudo: .say for map &sprintf.assuming("%x"), ^16;

[04:35] <p6eval> rakudo 9bf180: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤a␤b␤c␤d␤e␤f␤»

[04:40] *** dwoldrich joined
[04:40] <dalek> roast: 92f5587 | coke++ | S32-list/map.t:

[04:40] <dalek> roast: add test for RT#112596

[04:40] <dalek> roast: review: https://github.com/perl6/roast/commit/92f5587f33

[04:46] *** snarkyboojum left
[04:47] <hoelzro> what's the syntax for "capture anything and everything", again?

[04:47] <hoelzro> sub my-sub(|capture) { some-other-sub(|capture); } # ?

[04:49] <moritz> yes

[04:49] <hoelzro> hmm

[04:49] <hoelzro> does that not work in NQP?

[04:49] <moritz> no

[04:49] <moritz> you might need to use |$capture in nqp

[04:50] <moritz> nqp: sub s(|$c) { say(|$c) }; s(1, 2, 3)

[04:50] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "(|$c) { sa"␤current instr.: 'panic' pc 14698 (src/stage2/gen/NQPHLL.pir:5230) (src/stage2/gen/NQPHLL.pm:278)␤»

[04:50] <dalek> roast: 2dd229c | coke++ | S32-list/uniq.t:

[04:50] <dalek> roast: add test for RT #83454

[04:50] <dalek> roast: review: https://github.com/perl6/roast/commit/2dd229c237

[04:50] <moritz> or maybe you have to use *@pos, *%named

[04:50] <hoelzro> |$capture didn't work =/

[04:50] <hoelzro> *@pos, *%named didn't either

[04:51] <hoelzro> well, it complains about "Positional expected, got Array"

[04:58] <hoelzro> oh well, I'll work on this more tomorrow

[04:58] <hoelzro> big steps made today =)

[05:05] <dalek> rakudo/extend-dump: 3b876e2 | (Geoffrey Broadwell)++ | src/core/Mu.pm:

[05:05] <dalek> rakudo/extend-dump: Handle DUMP() of VM types that can't .DUMP() themselves

[05:05] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/3b876e273a

[05:05] <dalek> rakudo/extend-dump: 19ad263 | (Geoffrey Broadwell)++ | src/core/ (2 files):

[05:05] <dalek> rakudo/extend-dump: Improve .DUMP() of GatherIter and Parcel

[05:05] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/19ad263a29

[05:05] <dalek> rakudo/extend-dump: 2d738ce | (Geoffrey Broadwell)++ | src/core/ (2 files):

[05:05] <dalek> rakudo/extend-dump: Upgrade the .DUMP() method for ListIter and MapIter

[05:05] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/2d738ce38a

[05:05] <dalek> rakudo/extend-dump: cfbdeba | (Geoffrey Broadwell)++ | src/core/ (3 files):

[05:05] <dalek> rakudo/extend-dump: Move infinite marker to front of .DUMP for GatherIter, ListIter, and List

[05:05] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/cfbdebaa98

[05:11] *** dayangkun left
[05:12] *** kaleem left
[05:12] *** SamuraiJack joined
[05:15] *** Heather joined
[05:15] <Heather> Hello!

[05:15] <Heather> how check if string contains /

[05:16] <Heather> r: say 'a/b' ~~ /\//

[05:16] <p6eval> rakudo 9bf180: OUTPUT«｢/｣␤␤»

[05:17] <Heather> r: say 'a/b' ~~ /\/\/

[05:17] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Regex not terminated␤at /tmp/Bx4e7u9liH:1␤------> [32msay 'a/b' ~~ /\/\/[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤        prefix or meta-prefix…

[05:17] <Heather> r: say 'a/b' ~~ /(\/)/

[05:17] <p6eval> rakudo 9bf180: OUTPUT«｢/｣␤ 0 => ｢/｣␤␤»

[05:18] <Heather> r: say 'a/b' ~~ /\/|/

[05:18] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed␤at /tmp/3Ow3RTioBq:1␤------> [32msay 'a/b' ~~ /\/|[33m⏏[31m/[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤        prefix or meta-prefix␤»…

[05:18] <dalek> rakudo/extend-dump: b176ca8 | (Rob Hoelz)++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[05:18] <dalek> rakudo/extend-dump: More typo fixing

[05:18] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/b176ca8d09

[05:18] <dalek> rakudo/extend-dump: 25a9d6d | (Tobias Leich)++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[05:18] <dalek> rakudo/extend-dump: Merge pull request #119 from hoelzro/nom

[05:18] <dalek> rakudo/extend-dump: 

[05:18] <dalek> rakudo/extend-dump: More typo fixing

[05:18] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/25a9d6d4c5

[05:18] <dalek> rakudo/extend-dump: 192b28f | coke++ | src/core/Range.pm:

[05:18] <dalek> rakudo/extend-dump: RT#82312 - optimize size of numeric range.

[05:18] <dalek> rakudo/extend-dump: 

[05:18] <dalek> rakudo/extend-dump: Inspired by a patch from Gilbert Röhrbein [email@hidden.address]
[05:18] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/192b28fafd

[05:18] <dalek> rakudo/extend-dump: 9bf1806 | coke++ | src/core/Range.pm:

[05:18] <dalek> rakudo/extend-dump: RT#82312 numeric value of numeric range

[05:18] <dalek> rakudo/extend-dump: 

[05:18] <dalek> rakudo/extend-dump: Fix another edge case. pmichaud++

[05:18] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/9bf180636d

[05:18] <dalek> rakudo/extend-dump: bce3d7d | (Geoffrey Broadwell)++ | src/ (2 files):

[05:18] <dalek> rakudo/extend-dump: Merge branch 'nom' into extend-dump

[05:18] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/bce3d7de0d

[05:21] <Heather> r: say 'a/b' ~~ /\/|\(|\)/

[05:21] <p6eval> rakudo 9bf180: OUTPUT«｢/｣␤␤»

[05:22] <Heather> r: if 'a/b' ~~ /\/|\(|\)/ { say "A" }

[05:22] <p6eval> rakudo 9bf180: OUTPUT«A␤»

[05:22] <Heather> r: if 'a/b' ~~ /\// { say "A" }

[05:22] <p6eval> rakudo 9bf180: OUTPUT«A␤»

[05:22] <Heather> r: if 'ab' ~~ /\// { say "A" }

[05:22] <p6eval> rakudo 9bf180:  ( no output )

[05:39] *** cognominal left
[05:42] *** cognominal joined
[05:44] *** dmol joined
[05:50] <dalek> rakudo/extend-dump: 8d339e2 | (Geoffrey Broadwell)++ | src/core/Mu.pm:

[05:50] <dalek> rakudo/extend-dump: Use hex for WHERE info in DUMP() and .DUMP-ID()

[05:50] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/8d339e28c3

[05:54] *** lustlife left
[05:58] *** thou joined
[06:02] *** dmol left
[06:02] *** dmol joined
[06:15] <Heather> r: if IO.e '.bashrc' { say 'e' }

[06:15] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/llfY_Kf3q0:1␤------> [32mif IO.e [33m⏏[31m'.bashrc' { say 'e' }[0m␤    expecting any of:␤        method arguments␤        postfix␤        infix stopper␤        infix or meta-infix␤        parameterized block␤…

[06:16] <Heather> r: if IO:e '.bashrc' { say 'e' }

[06:16] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/MLaP0LeeJ2:1␤------> [32mif IO:e [33m⏏[31m'.bashrc' { say 'e' }[0m␤    expecting any of:␤        pair value␤        postfix␤        infix stopper␤        infix or meta-infix␤        parameterized block␤»…

[06:18] *** kaare_ joined
[06:22] *** cognominal left
[06:24] *** kaleem joined
[06:26] *** dmol left
[06:28] *** cognominal joined
[06:31] <Heather> how to get home directory

[06:35] <sorear> nr: say %*ENV<HOME>

[06:35] <p6eval> rakudo 9bf180, niecza v24-35-g5c06e28: OUTPUT«/home/p6eval␤»

[06:35] <Heather> sorear aha, thank you

[06:36] <sorear> r: if '.bashrc'.IO.e { say 'e' }

[06:36] <p6eval> rakudo 9bf180: OUTPUT«e␤»

[06:36] <sorear> r: if '/etc/foo'.IO.e { say 'e' }

[06:36] <p6eval> rakudo 9bf180:  ( no output )

[06:37] <sorear> r: if '/etc/passwd'.IO.e { say 'e' }

[06:37] <p6eval> rakudo 9bf180: OUTPUT«e␤»

[06:37] <Heather> ye ) solved it

[06:38] *** hypolin joined
[06:38] * Heather is reading How Perl 6 could kill us all from archive :)

[06:42] <cognominal> r: $_=2 ; when 1|2|3 { .say;  }

[06:42] <p6eval> rakudo 9bf180: OUTPUT«2␤succeed without when clause␤  in block  at src/gen/CORE.setting:452␤  in block  at src/gen/CORE.setting:530␤  in block  at /tmp/VCpsbtBTsM:1␤␤»

[06:42] <cognominal> WTF

[06:43] <moritz> a successful 'when' tries to exit its outer 'given'; might be related to this problem somehow

[06:45] <cognominal> I thought one could use 'when' without a surrounding 'given'

[06:45] <cognominal> r: given 2 { when 1|2|3 { .say;  }}

[06:45] <p6eval> rakudo 9bf180: OUTPUT«2␤»

[06:46] <cognominal> r: $_=2 ; when 2 { .say;  }

[06:46] <p6eval> rakudo 9bf180: OUTPUT«2␤succeed without when clause␤  in block  at src/gen/CORE.setting:452␤  in block  at src/gen/CORE.setting:530␤  in block  at /tmp/AF8wQJJ0va:1␤␤»

[06:49] *** kaare__ joined
[06:51] *** kaare_ left
[07:00] *** thou_ joined
[07:00] *** thou left
[07:03] *** kaare__ left
[07:03] *** cognominal left
[07:05] *** kaare__ joined
[07:10] *** rindolf joined
[07:10] *** cognominal joined
[07:13] <moritz> where is it specced that 'for' is an alias for 'map', and thus lazy?

[07:14] *** vaelxon left
[07:18] *** vaelxon joined
[07:18] *** kaleem left
[07:22] *** cognominal left
[07:22] *** rindolf left
[07:24] <labster> Heather: I read your Beauty and Freedom style guide.  Looks okay, but seeing prefix:<!> do something other than "not" is too surprising.  When you have all of unicode to work with, why not use ★, ☞, or ☺ as operators?

[07:25] <dalek> rakudo/extend-dump: faec85d | (Geoffrey Broadwell)++ | src/core/Mu.pm:

[07:25] <dalek> rakudo/extend-dump: Handle even more low-level types in Mu.DUMP

[07:25] <dalek> rakudo/extend-dump: review: https://github.com/rakudo/rakudo/commit/faec85d644

[07:28] *** kaleem joined
[07:29] *** cognominal joined
[07:30] *** kaleem left
[07:31] *** kaleem joined
[07:37] *** cognominal left
[07:40] *** sivoais left
[07:40] *** sivoais joined
[07:46] *** cognominal joined
[07:56] *** domidumont joined
[08:06] *** cognominal left
[08:09] *** domidumont left
[08:10] *** domidumont joined
[08:11] *** daxim joined
[08:13] *** cognominal joined
[08:17] <moritz> japhb: what does DUMP do?

[08:17] *** dwoldrich left
[08:31] *** SamuraiJack_ joined
[08:32] *** SamuraiJack left
[08:38] <FROGGS__> moritz: what do you say is the dba for perl 5's quote:sym<` `> ?

[08:39] *** FROGGS__ is now known as FROGGS

[08:41] <Heather> labster huh, agreed :)

[08:43] <Heather> labster I like variant with stars :) https://gist.github.com/Heather/5269530

[08:46] *** cognominal left
[08:46] *** vaelxon left
[08:46] <FROGGS> std: use v5; say `abc`

[08:46] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/J3N8j9ikSh line 1:␤------> [32muse v5; say [33m⏏[31m`abc`[0m␤    expecting any of:␤     argument list␤  p5infix␤        prefix or term␤ statement modifier␤Parse failed␤FAILED 00:01 52m␤»

[08:47] <FROGGS> \o/

[08:47] <Heather> ...?

[08:47] <dalek> v5: dbb1c14 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[08:47] <dalek> v5: implement shell executes `...`

[08:47] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/dbb1c1453f

[08:48] <FROGGS> Heather: see the commit, it just took 3 lines to implement that

[08:49] *** kaare__ left
[08:49] <lizmat> FROGGS++

[08:50] <labster> way to go FROGGS++.  Haven't seen rakudo beat std yet.

[08:51] <Heather> but parrot is slow? :)

[08:51] <labster> well yes, parrot is slow, but std is just a parser -- it doesn't actually run code

[08:53] <labster> I meant rakudo v5 knows perl 5 better than STD does.

[08:53] *** cognominal joined
[08:53] <FROGGS> labster: well, not quiet yet :o)

[08:55] <labster> ... if we define knowing perl 5 as the tiny subset which FROGGS's code does better.

[08:55] <FROGGS> hehe, ya >.<

[09:01] *** thou joined
[09:01] *** thou_ left
[09:03] *** kaare__ joined
[09:04] *** cognominal left
[09:04] *** census joined
[09:06] *** thou left
[09:07] *** thou joined
[09:13] *** cognominal joined
[09:15] *** census left
[09:22] *** census joined
[09:27] *** census_ joined
[09:28] *** woolfy joined
[09:28] *** census left
[09:28] *** kresike joined
[09:28] *** census_ left
[09:28] <kresike> hello all you happy perl6 people

[09:29] *** census joined
[09:29] <Heather> krunen welcome to our anime world again

[09:29] <labster> ^_^

[09:30] *** thou left
[09:30] *** thou_ joined
[09:31] <labster> kresike: I think Heather meant you (oh autocomplete).  anyway, hello.

[09:31] *** cognominal left
[09:32] <kresike> Heather, labster o/

[09:32] <census> labster++

[09:32] <labster> \o

[09:33] * kresike .oO(Anime world, now why didn't I think of that ? ☺)

[09:33] <Heather> oh -_-' true

[09:34] <kresike> it looks more like comic books, with weird superheroes 

[09:35] <kresike> no fancy clothing or masks, just huge brains full of knowledge

[09:35] <Heather> kresike well Perl is another kind of Manga, isn't it :P

[09:36] <kresike> Ok, masak++ does have a towel as a hat, but I don't think that qualifies as a costume ☺

[09:36] <kresike> Heather, Perl is another kind of everything ☺

[09:37] <Heather> kresike everything is not that objective and could be boring

[09:37] <kresike> and then Perl6 is another kind of Perl ... 

[09:39] <kresike> Heather, yes, but you can decide whether it _is_ boring or not !

[09:39] <labster> is code obfuscation a form of ninjutsu?

[09:40] <Heather> =)

[09:46] *** cognominal joined
[09:46] *** grondilu joined
[09:47] * grondilu is currently running cygwin on a temporary host

[09:47] <grondilu> how do I get a vim syntax file for perl6?

[09:47] <FROGGS> grondilu: why does someone still uses cygwin in the year 2013?

[09:48] <grondilu> FROGGS: because it's not my machine and I can't install linux on it

[09:48] <FROGGS> ahh, okay

[09:53] *** fhelmberger joined
[09:53] <moritz> FROGGS: :dba for ` should be 'backticks'

[09:53] <Heather> why cygwin then?

[09:54] *** cognominal left
[09:55] <FROGGS> moritz: thank you!

[09:58] <grondilu> Heather: I used to use it long ago and it used to work fine for me.

[09:59] <Heather> grondilu well but for what? what do you need from cygwin?

[09:59] *** arnsholt left
[09:59] <grondilu> Heather: I want to do some perl6 stuff

[09:59] <Heather> grondilu why not just on windows?

[09:59] <grondilu> I have no idea how to do programming on windows

[09:59] <Heather> )

[09:59] <grondilu> and especially perl6

[10:00] * Heather is windows user

[10:00] <labster> Cygwin is the least ancient of the archaic OSes I should probably port for File::Spec.  Unless someone has a request for me to do VMS or Epoc or MacOS sooner.

[10:00] <tadzik> it's great. We need you

[10:00] <Heather> tadzik me?

[10:01] <dalek> v5: 2178191 | (Tobias Leich)++ | lib/Perl6/P5Grammar.pm:

[10:01] <dalek> v5: rename `...` to backticks

[10:01] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/2178191ec3

[10:01] <tadzik> you, and all windows users :)

[10:01] <tadzik> you never have too many of them

[10:02] <Heather> tadzik why? :)

[10:02] <FROGGS> perl6 -e 'use perl5; say "[  $^X  ]"'

[10:02] <FROGGS> [  perl6]

[10:02] <FROGGS> ó.ò

[10:02] <Heather> wow :D

[10:02] <FROGGS> something eats up all the whitespace

[10:02] *** cognominal joined
[10:03] <FROGGS> okay, not all ...

[10:03] *** arnsholt joined
[10:03] <Heather> perl6 -e "say hi"

[10:03] <tadzik> Heather: because most of us program on unixes, with unix in mind, and things usually work a little bit differently on windows

[10:03] <tadzik> and then suddenly a windows user comes by, says "it doesn't work", and there's no one to help him

[10:03] <Heather> I'm unisex

[10:04] <Heather> e.g. use both in the same time XD

[10:04] <tadzik> hehe

[10:04] <FROGGS> tadzik: I am a windows user and dev too

[10:05] <FROGGS> (at least I have a windows box and did a lot with it in the past)

[10:06] <Heather> well I do horrible ASP.NET WCF things in most of my workday ...

[10:06] <FROGGS> but I have still no rakudo on it :/

[10:06] <FROGGS> ohh, poor Heather 

[10:06] <Heather> FROGGS want help? :P

[10:07] *** hypolin left
[10:10] *** vaelxon joined
[10:10] *** kaare__ left
[10:10] *** labster left
[10:11] <FROGGS> Heather: err, no, I dont like WCF much :o)

[10:11] <masak> good forenoon, #perl6

[10:13] <census> masak++

[10:14] *** cognominal left
[10:14] <Heather> masak*=2

[10:15] <moritz> good forenoon masak. Feel nagged about t2 reviews :-)

[10:15] <masak> aye. today is a good day to dive back into them.

[10:18] <moritz> is it a holiday in .se too?

[10:18] <grondilu> rn: say [^3].bag

[10:18] <p6eval> rakudo 9bf180, niecza v24-35-g5c06e28: OUTPUT«bag("0" => 1, "1" => 1, "2" => 1)␤»

[10:19] <masak> moritz: yes. even though we are mostly godless individualists.

[10:20] <moritz> masak: that's fine. If the christian god is really like most christians believe him to be, he'll love you for doing the right things, not for believing in him

[10:21] *** cognominal joined
[10:21] <tadzik> blasphemy! :P

[10:21] *** anuby left
[10:22] <masak> moritz: what I'm worried about is the bodily resurrection. what if I'm eaten by a cannibal, who finds Jesus and atones? who gets my molecules at the second coming?

[10:22] <masak> tadzik: (how's that for blasphemy?) :P

[10:23] <moritz> masak: science helps! atoms are indistinguishable.

[10:23] * masak .oO( but those were *my* atoms... )

[10:23] <moritz> so it there's no "your atoms" or "your molecules"

[10:23] <masak> I think I can recognize my own atoms, thank you very much!

[10:23] <masak> *you* might not be able to... :P

[10:24] * moritz bakes kanelboller

[10:24] * masak .oO( I guess to you, all atoms look just alike, huh? huh? )

[10:25] <masak> atomist!

[10:25] <masak> :P

[10:25] <tadzik> masak: better :>

[10:26] <Heather> rn: say [^10].bag

[10:26] <p6eval> rakudo 9bf180, niecza v24-35-g5c06e28: OUTPUT«bag("0" => 1, "1" => 1, "2" => 1, "3" => 1, "4" => 1, "5" => 1, "6" => 1, "7" => 1, "8" => 1, "9" => 1)␤»

[10:26] <Heather> ...

[10:26] <moritz> masak: even children are made of atoms!

[10:26] <moritz> Heather: !!!

[10:26] <Heather> moritz what?

[10:27] <moritz> Heather: just my standard response to bare '...'

[10:27] <masak> Heather: ???

[10:27] <moritz> or, "I could ask you the same" :-)

[10:27] <Heather> moritz is it anyhow logical response?

[10:27] <Heather> moritz ask what?

[10:27] <masak> Heather: the end point of this discussion is "please don't '...', it's annoying"

[10:28] <masak> Heather: we'd like to know what you think, not what you don't say.

[10:28] <Heather> masak so I was confused of .bag operation and don't understand what it makes

[10:28] <masak> Heather: '...' is so wildly uninformative that it frustrates those of us in search of all truths.

[10:28] <moritz> Heather: ask what the'...' is about

[10:29] <masak> Heather: it makes a bag. :)

[10:29] <Heather> a bag ...

[10:29] <masak> Heather: a bag is a set which can contain members twice or more times.

[10:29] <tadzik> argh

[10:29] <moritz> a bag !!!

[10:29] <grondilu> what's a difference between .bag and .Bag, btw?

[10:29] <masak> a bag ???

[10:30] <masak> grondilu: .bag needn't exist, if you ask me

[10:30] <moritz> masak: have you ever seen "The Gamers"?

[10:30] <masak> moritz: no.

[10:30] <Heather> ...

[10:30] <moritz> masak: you should. It's hilarious.

[10:30] <masak> Heather: you're not really using it as a bag there, though.

[10:30] <masak> r: say <h e a t h e r>.Bag

[10:30] <p6eval> rakudo 9bf180: OUTPUT«No such method 'Bag' for invocant of type 'Parcel'␤  in block  at /tmp/emQRlOmY4f:1␤␤»

[10:30] <masak> r: say <h e a t h e r>.bag

[10:30] <p6eval> rakudo 9bf180: OUTPUT«bag("h" => 2, "e" => 2, "a" => 1, "t" => 1, "r" => 1)␤»

[10:31] <masak> Heather: does that explain it?

[10:31] <Heather> so is it enum ut?

[10:31] *** Vlavv` joined
[10:31] <Heather> *it

[10:31] <Heather> split somehow and map by numbering ... ?

[10:31] <moritz> it's a data structure that counts for you how often an element is in it

[10:32] <moritz> like a hash with integer values, where setting the value to 0 deletes it

[10:32] <Heather> moritz Now I get it !!!

[10:32] <Heather> moritz thank you :P

[10:33] * Heather feels myself not that sober but sleepy when there is no water to make tea or coffee :(

[10:34] *** Vlavv left
[10:34] <Heather> r: ([^3],[^4]).bag

[10:34] <p6eval> rakudo 9bf180:  ( no output )

[10:34] <Heather> r: say ([^3],[^4]).bag

[10:34] <p6eval> rakudo 9bf180: OUTPUT«bag("0" => 2, "1" => 2, "2" => 2, "3" => 1)␤»

[10:35] <Heather> how to filter sequence?

[10:36] <Heather> r: say ([^3],[^4]).bag.filter({ $_[2] > 1 })

[10:36] <p6eval> rakudo 9bf180: OUTPUT«No such method 'filter' for invocant of type 'Bag'␤  in block  at /tmp/kOXOjkejsw:1␤␤»

[10:36] <moritz> Heather: .grep, not .filter

[10:37] <Heather> r: say ([^3],[^4]).bag.grep({ $_[2] > 1 })

[10:37] <p6eval> rakudo 9bf180: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Real at src/gen/CORE.setting:873␤  in sub infix:<>> at src/gen/CORE.setting:2935␤  in sub infix:<>> at src/gen/CORE.setting:2933␤  in block  at /tmp/i2aEDkcGue:1␤␤»

[10:37] <moritz> r: say ([^3],[^4]).bag.list.perl

[10:37] <p6eval> rakudo 9bf180: OUTPUT«("0", "1", "2", "3").list␤»

[10:37] <moritz> that's what you're iterstaing over

[10:37] <moritz> r: say ([^3],[^4]).bag.pairs.perl

[10:37] <p6eval> rakudo 9bf180: OUTPUT«("0" => 2, "1" => 2, "2" => 2, "3" => 1).list␤»

[10:38] <moritz> r: say ([^3],[^4]).bag.pairs.grep(*.value > 1)>>.key

[10:38] <p6eval> rakudo 9bf180: OUTPUT«0 1 2␤»

[10:38] <Heather> r: say ([^3],[^4]).bag.pairs.

[10:38] <p6eval> rakudo 9bf180: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/2OW2L7BLck:1␤------> [32msay ([^3],[^4]).bag.pairs.[33m⏏[31m<EOL>[0m␤    expecting any of:␤        dotty method or postfix␤»

[10:38] <Heather> r: say ([^3],[^4]).bag.pairs

[10:38] <p6eval> rakudo 9bf180: OUTPUT«0 2 1     2 2     2 3     1␤»

[10:38] <Heather> r: say ([^3],[^4]).bag.pairs.grep(*.value > 1)>>.key

[10:38] <p6eval> rakudo 9bf180: OUTPUT«0 1 2␤»

[10:53] <Heather> moritz good.

[10:56] <sergot> hi ! o/

[10:57] *** census left
[10:57] *** araujo left
[11:00] <sergot> [Coke]: it works. The only thing which has to be done is to set up cron jobs I think.

[11:00] <sergot> [Coke]: I mean http://feather.perl6.nl/~sergot/modules/http://feather.perl6.nl/~sergot/modules/ is all Perl 6

[11:00] <sergot> 14:35 < tadzik> sergot: ping

[11:00] <sergot> 14:35 < [Coke]> Is sergot's version going to become the main version at some

[11:00] <sergot>                 point? blocking on anything?

[11:00] <sergot> 18:10 < masak> sergot++ got something up and running.

[11:00] <sergot> 18:29 < [Coke]> arnsholt: I think the "selection of modules" testing is handled by sergot's emmentaler project.

[11:00] <sergot> 11:56 < sergot> hi ! o/

[11:00] <sergot> End of Lastlog

[11:00] <sergot> Oh, Im sorry

[11:01] *** census joined
[11:01] <masak> sergocie! \o/

[11:01] *** araujo joined
[11:02] <sergot> masaku ! \o/ :)

[11:02] <grondilu> the cygwin version of rakudo is too old, I'm trying to install rakudo star on windows now

[11:04] <grondilu> ok I'm told rakudo star has been installed, but how do I run it now?  I try "perl6" on cmd.exe but it can't find it.

[11:05] <sergot> r: use JSON::Tiny;

[11:05] <p6eval> rakudo 9bf180: OUTPUT«===SORRY!===␤Could not find JSON::Tiny in any of: /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/lib, /h…

[11:05] <sergot> It's why my modules.p6 doesn't work.

[11:06] <moritz> star: use JSON::Tiny;

[11:06] <p6eval> star 2013.02:  ( no output )

[11:06] <moritz> sergot: then install it. Or use star :-)

[11:07] <grondilu> ok there is a shortcut in the start menu, but it's only the REPL

[11:07] <sergot> Thanks, I'll. I just wanted to say why it didn't work. :)

[11:18] *** not_gerd joined
[11:18] <not_gerd> o/

[11:18] <not_gerd> grondilu: you need to set your PATH variable manually

[11:18] <not_gerd> and for the record, there's nothing wrong with using cygwin

[11:19] <not_gerd> imo it's a convenient way to fill your needs on windows: git, make, cmake, vim, mingw64 toolchain,...

[11:20] <Heather> hell no

[11:20] <Heather> cygwin is must die thing on windows

[11:20] <Heather> use mingw stuff instead

[11:21] <Heather> It's just few additional steps you need to setup all this things on windows

[11:21] <Heather> sometimes you even can get benefit

[11:21] <not_gerd> Heather: for mingw to be useful, you need MSYS, which is just an outdated cygwin fork

[11:21] <not_gerd> there's nothing wrong with using cygwin as your development environment

[11:21] <not_gerd> it comes with both mingw and mingw64 cross toolchains

[11:24] <Heather> not_gerd well, I'm not sure how MSYS is outdated but it works in-windows. Core difference and weird part of cygwin is some kind of environment separation. it's always better to use msisgit then cygwin git, it's better to use Strawberry perl then cygwin it's better to learn batch instead of using cygwin bash

[11:25] <not_gerd> MSYS *is* cygwin

[11:25] <not_gerd> you can invoke the mingw toolchain from cygwin the same way you can invoke it from MSYS

[11:26] <Heather> not_gerd well, it's part

[11:28] <not_gerd> Heather: all you need to do to make cygwin into a proper windows dev environment superior to msys is to install the cross toolchain and set your PATH correctly

[11:29] *** thou_ left
[11:29] <not_gerd> (actually, PATH and LIBRARY_PATH)

[11:31] <Heather> well

[11:31] <Heather> http://stackoverflow.com/questions/57627/msys-vs-cygwin

[11:31] <not_gerd> "The main difference between mingw and cygwin is that mingw builds win32 binaries that are free from any extra dependencies."

[11:31] <not_gerd> which is not the case if you use the cross toolchain

[11:32] <Heather> it's a case

[11:34] <Heather> not_gerd cygwin is always weird solution, at least for me because it's always trying to build unix environment and make all the relations with it

[11:35] <Heather> that is not what I want on windows, it's wrong way.

[11:35] <dalek> v5: 9932d3e | (Tobias Leich)++ | lib/ (3 files):

[11:35] <dalek> v5: nibble to the right quote-language

[11:35] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/9932d3ec85

[11:35] <FROGGS> Heather: well, that is the reason for using cygwin

[11:36] <FROGGS> to have the unix env under windows

[11:36] <not_gerd> Heather: again, only if you use the cygwin toolchain instead of the mingw cross toolchain

[11:36] <not_gerd> you can do windows development on cygwin, the same way you can also do it on linux if you set up a cross compiler

[11:37] <Heather> FROGGS no, I don't want to have separated unix env under windows, I want to add it's functional to windows env.

[11:37] <not_gerd> cygwin makes that trivial and has the benefit that you're actually on the platform you're developing for

[11:37] <not_gerd> granted, not everything works out of the box(I'm looking at you, parrot), but that's not cygwin's fault

[11:38] <not_gerd> basically, you can't cross-compile parrot

[11:38] <FROGGS> Heather: well, merging in the unix specific things is not possible IMO

[11:38] <Heather> FROGGS it's possible.

[11:38] <Heather> FROGGS not for all but at least for all I need I've got windows version.

[11:39] <FROGGS> well, since I dont know what you need I should believe you, ehh?

[11:39] <not_gerd> Heather: but it's a huge PITA to keep everything up-to-date without a package manager

[11:39] <Heather> FROGGS I use mingw ls, nano, emacs, msis git, whatever, NO CYGWIN mess, I used to use cygwin and I will Never use it again because it's separated

[11:39] <not_gerd> I've done the MSYS game (and fixed parrot to work there), but imo it's just not worth thy hassle

[11:40] <not_gerd> if you use MSYS, you use cygwin - just a crippled version thereof

[11:40] <Heather> not_gerd well it's windows way

[11:40] <not_gerd> the problem with MSYS is that every application using it will com with it's own version of it

[11:41] <Heather> not_gerd well it's not the same, at least they called different with the reason

[11:41] *** Chillance joined
[11:42] <Heather> not_gerd what do you mean with "com with it's own version of it" ?

[11:45] <dalek> perl6-examples: 668fa6f | grondilu++ | rosalind/grondilu-mmch.pl:

[11:45] <dalek> perl6-examples: Create grondilu-mmch.pl

[11:45] <dalek> perl6-examples: 

[11:45] <dalek> perl6-examples: (rosalind) MMCH

[11:45] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/668fa6f1db

[11:45] <not_gerd> every application that depends on MSYS normally ships with it's own version of it

[11:45] <Heather> not_gerd windows have no cygwin or msys by default - it's major True

[11:45] <not_gerd> install MSYS git, Strawberry perl, $foo and you'll get multiple copies of the toolchain

[11:46] <Heather> not_gerd that's how maintainers deploy it

[11:46] <FROGGS> std: use v5; open(try, "/dev/null")

[11:46] <p6eval> std 86b102f: OUTPUT«ok 00:01 53m␤»

[11:47] <FROGGS> std: use v5; öpen(try, "/dev/null")

[11:47] <p6eval> std 86b102f: OUTPUT«ok 00:01 53m␤»

[11:47] <FROGGS> damn, std is cheating here :/

[11:47] <not_gerd> my point is that you can do everything you can do with MinGW and MSYS with Cygwin as well

[11:47] <not_gerd> the latter comes with a usable package manager, the former does not

[11:48] *** rindolf joined
[11:51] *** grondilu left
[11:53] <FROGGS> I guess I have to ask in a perl 5 channel if I wanna know waht subs can take/declare sigilless variables?

[11:53] <moritz> FROGGS: all of them

[11:54] <moritz> $ perl -wE 'sub foo { }; foo(BAR)'

[11:54] <FROGGS> ya, if BAR is declared I can pass it to everything...

[11:54] <moritz> my example didn't declare BAR

[11:54] <FROGGS> but open() would declare BAR

[11:54] <moritz> no

[11:55] *** tgt joined
[11:55] <FROGGS> hmmm

[11:55] <FROGGS> what is BAR then?

[11:55] <FROGGS> $ perl -wE 'sub foo { print $_ }; foo(BAR)'

[11:55] <FROGGS> Use of uninitialized value $_ in print at -e line 1.

[11:55] <moritz> oh wait, I wasn't testing with "use strict"

[11:55] <FROGGS> perl -wE 'sub foo { print shift }; foo(BAR)'

[11:55] <FROGGS> BAR

[11:55] <moritz> it's a bareword

[11:55] <FROGGS> perl -wE 'sub foo { print shift }; foo(BAR)'

[11:55] <FROGGS> BARfroggs@TL02L-R8RXTCW-linux:~/dev/v5$ perl -wE 'use strict; sub foo { print shift }; foo(BAR)'

[11:55] <FROGGS> Bareword "BAR" not allowed while "strict subs" in use at -e line 1.

[11:55] <FROGGS> Execution of -e aborted due to compilation errors.

[11:55] <FROGGS> hmmm

[11:56] <FROGGS> so I have to allow barewords when strict isnt in use...

[11:56] <FROGGS> sounds doable

[11:56] <moritz> FROGGS: ah, all subs that have a * prototype accept barewords

[12:00] <FROGGS> moritz: and a bareword is more like a sub than a variable? since I cant assign to a bareword...

[12:01] <moritz> FROGGS: it's a glob

[12:01] * FROGGS will read some docs

[12:01] <moritz> perldoc perldata, "Typeglobs and Filehandles"

[12:01] <FROGGS> moritz: thanks again :o)

[12:02] *** sivoais left
[12:02] <moritz> kein problem :-)

[12:02] *** sivoais joined
[12:02] <FROGGS> *g*

[12:05] *** cognominal left
[12:08] <moritz> my newest idea: write an email reminder in perl 6

[12:08] <moritz> it works like this: you send somebody an email, and include a BCC: [email@hidden.address]
[12:09] <moritz> and then it will send you an email two month later, saying "two month ago, you asked me to remind you about this email"

[12:12] *** cognominal joined
[12:13] <Heather> moritz old idea... but I wonder if there are some implementations

[12:14] <Heather> moritz that could be just mail task for task manager but with easier interface to add

[12:16] <Heather> moritz I guess there are some ... https://www.google.ru/search?q=web+service+mail+reminders

[12:19] <moritz> Heather: I never claimed it was a new idea :-)

[12:21] *** skids left
[12:31] <masak> moritz: I like the idea. I would use such a thing.

[12:32] <masak> moritz: in fact, the module I'll be writing for Nomic and mishu could be used to implement that, too.

[12:32] <masak> I'm currently looking for a good name for that module. maybe someone here can help?

[12:32] <masak> should be something to do with observers.

[12:33] <masak> 'use Observer;' # hmm

[12:33] <moritz> Look.pm

[12:33] <masak> a bit too cute :)

[12:33] <moritz> Object::Watcher; # not quite serious either

[12:33] <masak> though I was toying with Observatory.pm myself

[12:34] <masak> Object::Observer might actually be nice.

[12:34] <Heather> O::O

[12:34] <masak> :)

[12:34] <masak> Heather++

[12:34] <moritz> adding 'Object::' to a module name rarely makes it clearer though

[12:34] <masak> Heather: that alone almost convinces me to go with that one.

[12:34] <Heather> masak >_<

[12:34] <masak> hm, is there any prior art on CPAN?

[12:34] <masak> Object::ID

[12:35] <masak> Object::KVC

[12:35] <masak> but most on page one were <something>::Object

[12:36] <masak> Reactive.pm could work too. more intentional, perhaps.

[12:37] <Heather> Octo::Cat

[12:37] * masak silently points to the "too cute" bucket ;)

[12:40] <Heather> Object::Inspector ?

[12:41] <masak> sounds too much like debugging.

[12:41] <masak> this is for a live, running application.

[12:41] <Heather> hm...

[12:41] <masak> maybe Reactionary.pm

[12:41] <Heather> not clear for me

[12:41] <masak> (because, you know, Perl 6 is disruptive)

[12:42] <masak> and it's a pun on "reactive programming"

[12:43] <masak> ok, #perl6, I'll be gone for a few hours. (socializing) see you this evening. :)

[12:43] <masak> &

[12:43] <Heather> &

[12:43] <Heather> ...

[12:44] <Heather> what & means

[12:45] <Heather> my imagination fails on it and you say that '...' is not clear after it.

[12:47] <lizmat> Heather: wrt to &, think shell and running programs in the background

[12:48] <hoelzro> goede morgen, #perl6

[12:48] <PerlJam> good morning #perl6

[12:48] <Heather> lizmat yes I use it ususally for editors but how to get it here...

[12:49] <Heather> hoelzro PerlJam hey !

[12:49] <PerlJam> greetings Heather 

[12:50] * Heather sometimes in the end of the week you really want to feel stupid...

[12:53] * Heather is planning to blog about my new Style Guide

[12:55] <hoelzro> Heather: you have a Perl 6 style guide?

[12:55] * hoelzro really wants to see one, since his own style has evolved =)

[12:56] <Heather> hoelzro yes )

[12:56] <Heather> hoelzro https://github.com/Heather/Beauty-and-Freedom

[12:56] <PerlJam> nice name

[12:56] <hoelzro> \o/

[12:57] <Heather> PerlJam thank you :P

[12:57] <Heather> name is very reasonable :D

[12:59] <Heather> star if you like :D

[13:00] *** kaleem left
[13:01] <Heather> see you

[13:01] *** Heather left
[13:16] *** not_gerd left
[13:16] *** mmcleric left
[13:17] *** crab2313 joined
[13:23] *** adu_ joined
[13:27] <adu_> still getting the error

[13:42] <hoelzro> how can I compare two objects by identity in NQP?

[13:43] <hoelzro> I'm still trying to figure out the best way to get callsame and Code objects working

[13:43] <hoelzro> because adding postcircumfix:<( )> to Code doesn't work =/

[13:45] <FROGGS> hoelzro: you tried =:= ?

[13:49] <adu_> FROGGS: I'm so close to isolating the issue

[13:49] *** skids joined
[13:50] <FROGGS> adu_++

[13:50] <adu_> I've gotten it down to 3 rules. If I put them in a file, then use FileA; FileA.parse() then it fails. If I run it in the same file, it succeeds. like this:

[13:51] <FROGGS> if I should have a look you might prepare a gist/repo including a file to parse and a test script to invoke etc

[13:51] <adu_> n: grammar G { token TOP {^ <ident> $}; token ident { <.ident-first> <.ident-rest>* }; proto token ident-first {*}; token ident-first:sym<under> { '_' }; token ident-first:sym<alpha> { <.alpha> }; proto token ident-rest {*}; token ident-rest:sym<alpha> { <.ident-first> }; token ident-rest:sym<digit> { <.digit> }; }; say G.parse('test')

[13:51] <p6eval> niecza v24-35-g5c06e28: OUTPUT«｢test｣␤ ident => ｢test｣␤␤»

[13:51] <adu_> that works

[13:51] <adu_> but not if you "use" the grammar

[13:51] <FROGGS> hmmm

[13:51] <adu_> and I can't figure out why

[13:53] <moritz> how does it not work?

[13:53] <FROGGS> adu_: it is working here

[13:54] <FROGGS> I made a G.pm, pasting the grammar there, then a test.pl, putting "use G; say G.parse('test')", and then executed: PERL6LIB=. perl6 test.pl

[13:54] <FROGGS> using rakudo that it

[13:54] <FROGGS> is*

[14:01] <adu_> ok

[14:01] <adu_> https://gist.github.com/andydude/5271051

[14:04] *** cognominal left
[14:05] <adu_> I haven't tested rakudo

[14:05] <adu_> rakudo doesn't seem to like protos either

[14:07] <FROGGS> PERL6LIB=. perl6 CTest.pl6 'test'

[14:07] <FROGGS> ｢test｣

[14:07] <FROGGS>  ident => ｢test｣

[14:07] <FROGGS> rakudo^^

[14:08] <adu_> FROGGS: the bug is with niecza

[14:08] <FROGGS> adu_: my niecza gives the same bug you posted

[14:08] <adu_> actually, if I run the same grammar in rakudo, I get "regex assertion not terminated by angle bracket at line 6, near "-first> <.""

[14:08] <FROGGS> adu_: I dont get an error with rakudo

[14:10] <adu_> but if I replace s/-/_/, and s/{*}/{ {*} }/, then it works in rakudo

[14:11] <FROGGS> adu_: how old is your rakudo?

[14:11] <adu_> This is Rakudo Perl 6, version 2010.11-15-gfedc117 built on parrot 2.10.1 RELEASE_2_10_1-679-g9bec614

[14:11] <FROGGS> perl6 --version

[14:11] <FROGGS> This is perl6 version 2013.02.1-164-gb972ca3 built on parrot 4.10.0 revision RELEASE_4_10_0

[14:11] <adu_> heh

[14:11] <colomon> the - character used to be illegal in grammars in rakudo, but it works fine now.

[14:11] <adu_> maybe I should upgrade

[14:12] <FROGGS> ohh yeah

[14:12] <adu_> well I'm using yesterday's niecza

[14:12] <adu_> but I don't intend on using rakudo, I was intending on using niecza

[14:12] <FROGGS> well, there is not so much development going on on niecza, which is sad

[14:12] <adu_> oh

[14:13] <adu_> I thought it was visaversa

[14:13] <FROGGS> no

[14:13] *** toddr__ joined
[14:14] <colomon> adu_: it was viceversa (sort of) about 18 months ago.

[14:14] <FROGGS> rakudo is the one which gets all the attention these days

[14:14] <colomon> Rakudo was in the middle of a major rewrite, and Niecza was under pretty active development.

[14:14] <colomon> but right now Rakudo gets more patches in a day than Niecza gets in a month.

[14:15] <colomon> rn: say +Range

[14:15] <p6eval> rakudo 9bf180: OUTPUT«use of uninitialized value of type Range in numeric context  in block  at /tmp/fiTHCUvguI:1␤␤0␤»

[14:15] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«Unhandled exception: Attempted to access slot $!min of type object for Range␤  at /home/p6eval/niecza/lib/CORE.setting line 1737 (List.gist @ 5) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3060 (Range.Numeric @ …

[14:15] <colomon> rn: say +Complex

[14:15] <p6eval> niecza v24-35-g5c06e28: OUTPUT«(Complex)␤»

[14:15] <p6eval> ..rakudo 9bf180: OUTPUT«use of uninitialized value of type Complex in numeric context  in block  at /tmp/pId3RpRP55:1␤␤0␤»

[14:15] <colomon> hurm

[14:16] <hoelzro> FROGGS: ah, good point!

[14:16] <adu_> colomon: apparently I'm behind the times

[14:17] <dalek> roast: 1006b9f | (Solomon Foster)++ | S02-types/range.t:

[14:17] <dalek> roast: Fudge for niecza.

[14:17] <dalek> roast: review: https://github.com/perl6/roast/commit/1006b9f3b1

[14:18] *** adu_ is now known as adu

[14:19] <adu> good to know

[14:19] <adu> upgrading now

[14:22] *** pjcj left
[14:22] <adu> what is the story behind the name "CORE.setting"

[14:23] <adu> becuase I would have use the name library, not setting

[14:23] *** Psyche^ joined
[14:23] <adu> s/use/used/

[14:23] <moritz> it's a special library

[14:23] <moritz> one that acts as an outer scope to your program

[14:23] <moritz> and we call that kind of library a "setting"

[14:24] <dalek> roast: 1afab0c | (Solomon Foster)++ | S06-multi/syntax.t:

[14:24] <dalek> roast: Fudge for niecza.

[14:24] <dalek> roast: review: https://github.com/perl6/roast/commit/1afab0c7f7

[14:26] <japhb> moritz, The best way to describe DUMP is by example.  I'd say build a Rakudo in that branch, and then do something like: perl6 -e 'my $map := (1 ... *).map: 2 + *; say DUMP($map);'

[14:26] *** Patterner left
[14:26] *** Psyche^ is now known as Patterner

[14:27] *** mmcleric joined
[14:28] <adu> moritz: its just that the word setting reminds me of boolean, and it seems silly to have an entire file devoted to a boolean

[14:28] <moritz> well, many words have more than one possible meaning

[14:29] <moritz> think of the setting in a theater play instead

[14:29] <adu> oh ok

[14:29] <adu> or "dinner setting"

[14:30] <adu> when I think of library, I think of Beauty and the Beast

[14:30] <adu> but that's a different story ;)

[14:30] *** tgt left
[14:31] *** tgt joined
[14:32] *** crab2313 left
[14:32] *** pjcj joined
[14:42] *** SamuraiJack_ left
[14:43] *** pjcj left
[14:44] *** pjcj joined
[14:44] *** pjcj left
[14:46] <adu> how do I add something to the path?

[14:46] <adu> for example, the current directory?

[14:46] <adu> oh PERL6LIB, n/m

[14:46] <FROGGS> right

[14:47] <adu> YEY

[14:47] <adu> rakudo works

[14:47] <adu> now for something more complicated than ident

[14:48] <moritz> or  -I. on the command line

[14:48] <moritz> or  use lib '.'

[14:49] <adu> moritz: rakudo doesn't like that option on it's --help

[14:49] <adu> s/like/list/

[14:49] *** crab2313 joined
[14:51] <dalek> rakudo/nom: 8976369 | moritz++ | src/Perl6/Compiler.nqp:

[14:51] <dalek> rakudo/nom: report -I and -M options in --help output

[14:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8976369101

[14:54] <japhb> moritz, did you give the branch a try?

[14:54] <moritz> japhb: no, distracted by other stuff

[14:55] <japhb> moritz, Ah, OK.

[14:56] <dalek> ecosystem: ff4c42b | tadzik++ | META.list:

[14:56] <dalek> ecosystem: Add File::HomeDir

[14:56] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/ff4c42b46e

[14:56] <tadzik> gosh, I was tired of reinventing it all the time

[14:57] <moritz> tadzik++

[14:57] * moritz is patching Email-Simple

[14:58] <tadzik> also, it just occured to me that panda could be nicely implemented in a git-like fashion

[14:58] <FROGGS> cool, file::homedir!

[14:58] <tadzik> so it's actually composed of tools like panda-fetch, panda-build, panda-test, panda-install

[14:58] <FROGGS> tadzik++

[14:58] <tadzik> then you could easily add to that, panda-create, to create a new module for example

[14:58] <adu> what does "Method 'ast' not found for invocant of class 'NQPMu'" mean?

[14:58] <tadzik> adu: that you're messing with internals, accidentally or not :)

[14:58] <tadzik> where did that happen?

[14:59] <adu> in my C lexer

[14:59] <tadzik> is there a code to look at?

[15:00] <adu> https://gist.github.com/andydude/5268163

[15:04] *** cognominal joined
[15:04] *** sftp left
[15:07] <adu> tadzik: ok, the line that if I comment, it removed the error has ":radix(10)" in it

[15:07] <adu> is that internals?

[15:08] <adu> I don't understand why that would cause an error

[15:08] <tadzik> hmm

[15:08] <tadzik> me neither

[15:08] <adu> but if i comment those lines (with :radix in it), then the error goes away

[15:09] <tadzik> puzzling :( I don't know

[15:09] <tadzik> r: sub say(*@a) { OUTER::say('Simon says: ', |@a) }; say "foo"

[15:09] <p6eval> rakudo 9bf180: OUTPUT«No such method 'Any' for invocant of type 'Parcel'␤  in sub say at /tmp/yQoVQMkGXl:1␤  in block  at /tmp/yQoVQMkGXl:1␤␤»

[15:09] <tadzik> what am I doing wrong?

[15:10] <adu> ooooo

[15:10] <adu> if I change :radix(10) to :radix<10> then it works

[15:10] <colomon> adu: was just going to suggest that.

[15:10] <colomon> :)

[15:10] <tadzik> huh

[15:10] <colomon> mind you, it was just asking "what's different about this bit?"

[15:10] <adu> so it must parse the parens as function arguments instead of pair-value

[15:11] <adu> I thought :radix(10) always meant pair

[15:11] <adu> good to know

[15:13] <colomon> adu: it might be a Rakudo bug, mind you.

[15:13] <adu> oh

[15:13] <adu> how do I tell?

[15:15] <moritz> the difference is that :radix<10> creates a Str as value

[15:18] *** sftp joined
[15:30] *** pjcj joined
[15:32] *** pjcj left
[15:32] *** pjcj joined
[15:35] *** cognominal left
[15:37] *** pjcj left
[15:37] *** pjcj joined
[15:37] *** immortal left
[15:38] *** erkan joined
[15:38] *** erkan left
[15:38] *** erkan joined
[15:38] *** cognominal joined
[15:39] *** juiko joined
[15:40] <dalek> roast: 8f16996 | coke++ | S04-phasers/enter-leave.t:

[15:40] <dalek> roast: add tests for RT #113548

[15:40] <dalek> roast: review: https://github.com/perl6/roast/commit/8f169962a0

[15:42] <tadzik> > pandabrew panda install Acme::Meow

[15:42] <tadzik> ==> You seem to have updated Rakudo, and panda is still built for the old one.

[15:42] <tadzik> Do you wish to rebootstrap panda now? [Y/n]

[15:42] <tadzik> this may come in handy :)

[15:43] <tadzik> so I only wrote File::HomeDir to realise that pandabrew needs to be dependency-free :/

[15:43] <daxim> bundle it

[15:43] <tadzik> yeah

[15:44] <tadzik> I'm now proceeding with App::FatPacker :)

[15:46] *** cognominal left
[15:47] *** juiko left
[15:48] *** pupoque joined
[15:49] <tadzik> ...for which the naive approach doesn't quite work :/

[15:49] *** bluescreen10 joined
[15:54] *** cognominal joined
[15:54] <mst> tadzik: failing tests, bugfixes, whatever, very welcome

[15:54] <mst> unless it's a port of fatpacker

[15:54] <mst> in which case I disclaim all knowledge of your mission :)

[15:56] *** domidumont left
[15:56] *** grondilu joined
[15:57] <grondilu> rn: sub foo { "bar" }; say foo xx 3;

[15:57] <p6eval> niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'xx' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/…

[15:57] <p6eval> ..rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    xx used at line 1␤␤»

[15:57] <grondilu> this is annoying

[15:57] <grondilu> rn: sub foo { "bar" }; say foo() xx 3;

[15:57] <p6eval> rakudo 897636, niecza v24-35-g5c06e28: OUTPUT«bar bar bar␤»

[15:58] <grondilu> I thought I wouldn't have to be explicit with a ()

[15:58] <tadzik> mst: naah, I meant App::FatPacker for Perl 6

[15:58] <tadzik> so yeah, a port

[15:59] *** thou joined
[15:59] <mst> right. no bloody idea then, 99% of fatpacker is VM specific magic I suspect

[16:00] <tadzik> I was merely looking for trivial solutions to trivial cases

[16:01] <dalek> ecosystem: 8f7b0a8 | tadzik++ | META.list:

[16:01] <dalek> ecosystem: Add pandabrew

[16:01] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8f7b0a8474

[16:01] <tadzik> testing welcome

[16:09] *** pupoque left
[16:21] <kresike> bye folks

[16:21] *** kresike left
[16:23] *** am0c joined
[16:29] <adu> r: grammar G {

[16:29] <adu> token TOP {^ <integer-constant> $};

[16:29] <adu> proto token integer-constant {*};

[16:29] <adu> token integer-constant:radix<8>  { <octal-constant> <integer-suffix>* };

[16:29] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/RrEboMbZum:1␤------> [32mgrammar G {[33m⏏[31m<EOL>[0m␤    expecting any of:␤        statement list␤»

[16:29] <adu> token integer-constant:radix<10> { <decimal-constant> <integer-suffix>* };

[16:29] <adu> token integer-constant:radix<16> { <hexadecimal-constant> <integer-suffix>* };

[16:29] <adu> token octal-constant { '0' <odigit>* };

[16:29] <adu> token decimal-constant { <nzdigit> <digit>* };

[16:29] <adu> token hexadecimal-constant { <.hexadecimal-prefix> <xdigit>* };

[16:29] <adu> token hexadecimal-prefix { '0' <[xX]> };

[16:29] <adu> token nzdigit { <[1..9]> };

[16:29] <adu> token odigit { <[0..7]> };

[16:29] <clkao> win 36

[16:29] <adu> }; say G.parse('0');

[16:29] <adu> oops sorry

[16:30] <adu> r: grammar G { token TOP {^ <integer-constant> $}; proto token integer-constant {*}; token integer-constant:radix<8>  { <octal-constant> <integer-suffix>* }; token integer-constant:radix<10> { <decimal-constant> <integer-suffix>* }; token integer-constant:radix<16> { <hexadecimal-constant> <integer-suffix>* }; token octal-constant { '0' <odigit>* }; token decimal-constant { <nzdigit> <digit>* }; token hexadecimal-constant { <.hexadecimal

[16:30] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤regex assertion not terminated by angle bracket␤at /tmp/6WYpRHDXh4:1␤------> [32moken hexadecimal-constant { <.hexadecima[33m⏏[31m<EOL>[0m␤    expecting any of:␤        pair value␤        quote words␤        infix stopper␤        …

[16:32] <adu> that's wierd, when I run that I get #<failed match>

[16:33] <colomon> adu: your paste got cut off

[16:33] *** daxim left
[16:33] <adu> oh

[16:34] <adu> r: grammar G { token TOP {^ <intc> $}; proto token intc {*}; token intc:radix<8>  { <octalc> <integer-suffix>* }; token intc:radix<10> { <decimalc> <integer-suffix>* }; token intc:radix<16> { <hexc> <integer-suffix>* }; token octalc { '0' <odigit>* }; token decimalc { <nzdigit> <digit>* }; token hexc { <.hex-prefix> <xdigit>* }; token hex-prefix { '0' <[xX]> }; token nzdigit { <[1..9]> }; token odigit { <[0..7]> }; }; say G.parse('0');

[16:34] <p6eval> rakudo 897636: OUTPUT«#<failed match>␤»

[16:34] <colomon> r: https://gist.github.com/colomon/5271962

[16:34] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus statement␤at /tmp/0S7Focy9bH:1␤------> [32m<BOL>[33m⏏[31mhttps://gist.github.com/colomon/5271962[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤»

[16:35] <colomon> r: https://gist.github.com/colomon/5271962

[16:35] <p6eval> rakudo 897636: OUTPUT«#<failed match>␤»

[16:35] <colomon> there you go

[16:35] <colomon> it's a lot easier to read that way.

[16:35] <adu> thats a neat trick

[16:35] <colomon> also, do you know about Grammar::Debugger and Grammar::Tracer?

[16:36] <adu> colomon: thanks

[16:36] <adu> nope

[16:36] <colomon> they are ESSENTIAL to this sort of work.

[16:36] <adu> ok

[16:36] <colomon> well, at least for the sake of your sanity.

[16:36] <adu> I lost my sanity awhile ago

[16:38] <colomon> adu: do you have panda working?

[16:38] <adu> what's panda?

[16:38] <adu> apparently i've been away since 2010

[16:38] <moritz> a module installer

[16:38] <colomon> tadzik++'s module installer

[16:38] <moritz> one that actually works most of the time :-)

[16:39] <adu> cool

[16:39] <adu> I have ufo

[16:40] <colomon> adu: https://github.com/tadzik/panda/

[16:41] <colomon> moritz: panda's actually not installing for me on Linux.  :(

[16:41] <moritz> :(

[16:42] <moritz> colomon: it usually works for me when there's no old installation lying around, and i ran 'git clean -xdf' in panda's source dir

[16:43] <colomon> https://gist.github.com/colomon/5272004

[16:44] <moritz> that's really weird

[16:44] <colomon> and (comment added to show) that path *is* in my $PATH

[16:46] <colomon> adu: while panda and the Grammar modules are very worthwhile, Grammar::Tracer is not particularly helpful in this case: https://gist.github.com/colomon/5272019

[16:49] *** toddr___ joined
[16:50] *** cognominal left
[16:51] <moritz> I believe the tokens of a proto token must be of the form   token integer-constant:sym<...>

[16:51] <moritz> not :radix<...>

[16:52] <colomon> moritz: std.pm has examples like  token statement_prefix:sink

[16:52] <colomon> but you're definitely right that that is the source of the problem here.

[16:52] <moritz> well, std != rakudo

[16:53] <colomon> moritz: true.

[16:53] *** toddr__ left
[16:53] *** japhb_ joined
[16:53] <colomon> and you're quite right, token integer-constant:sym<8> works in rakudo

[16:54] <colomon> radix<8> works in Niecza.  ;)

[16:54] <japhb_> moritz, I gist'ed the DUMP() effects for you: https://gist.github.com/anonymous/a55a413400a33cf13c45

[16:55] <colomon> r: https://gist.github.com/colomon/5271962 # adu, this works

[16:55] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/sleQZast0p:1␤------> [32mhttps[33m⏏[31m://gist.github.com/colomon/5271962 # adu[0m␤    expecting any of:␤        argument list␤        postfix␤        infix stopper␤        infix or meta-infix␤        st…

[16:56] <colomon> r: https://gist.github.com/colomon/5271962

[16:56] <p6eval> rakudo 897636: OUTPUT«｢0｣␤ integer-constant => ｢0｣␤  octal-constant => ｢0｣␤␤»

[16:56] <colomon> .... as long as I don't include the # adu, this works at the end!

[16:56] <moritz> p6eval is pretty restrictive when parsing gist URLs

[16:56] <FROGGS> colomon: in rakudo there is a pattern match for token <name>:sym<* for example, so it really requires :sym

[16:57] *** cognominal joined
[16:57] <colomon> n: https://gist.github.com/colomon/5271962/592137f992ae4303570af9e5ffa42ef15f362ce0

[16:57] <p6eval> niecza v24-35-g5c06e28: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/4cZZzCSwjE line 1:␤------> [32mhttps[33m⏏[31m://gist.github.com/colomon/5271962/59213[0m␤␤Undeclared routine:␤      'https' used at line 1␤␤Parse failed␤␤»

[16:58] <colomon> ah, so p6eval can't handle a specific revision.  pity.

[17:00] <moritz> [Coke]++ # going through RT, adding tests

[17:01] *** adu_ joined
[17:02] *** adu left
[17:04] <grondilu> rn: say 2 X* map &sqrt, ^5;

[17:04] <p6eval> niecza v24-35-g5c06e28: OUTPUT«0 2 2.8284271247461903 3.4641016151377544 4␤»

[17:04] <p6eval> ..rakudo 897636: OUTPUT«␤»

[17:04] <colomon> moritz: which perl6 executable am I supposed to add to my path?

[17:04] <grondilu> rakudobug?

[17:04] *** cognominal__ joined
[17:04] *** cognominal left
[17:05] <grondilu> rn: say 2 X* my @ = map &sqrt, ^5;

[17:05] <p6eval> niecza v24-35-g5c06e28: OUTPUT«0 2 2.8284271247461903 3.4641016151377544 4␤»

[17:05] <p6eval> ..rakudo 897636: OUTPUT«0 2 2.82842712474619 3.46410161513775 4␤»

[17:05] <colomon> grondilu: most likely yes

[17:06] <moritz> colomon: the installed one

[17:06] <moritz> (which looks fine in your gist)

[17:06] <colomon> rakudo/install/bin  ?

[17:06] <colomon> okay, so that's not my problem with panda

[17:06] <moritz> erm, what's the rakudobug?

[17:07] <moritz> r: say (map &sqrt, ^5) X** 2

[17:07] <p6eval> rakudo 897636: OUTPUT«0 1 2 3 4␤»

[17:07] <grondilu> r: say 2 X* map &sin, ^5;

[17:07] <p6eval> rakudo 897636: OUTPUT«␤»

[17:08] <grondilu> n: say 2 X* map &sin, ^5;

[17:08] <p6eval> niecza v24-35-g5c06e28: OUTPUT«0 1.682941969615793 1.8185948536513634 0.28224001611973443 -1.5136049906158564␤»

[17:08] <grondilu> see?

[17:08] <moritz> r: say 2 X* map( &sin, ^5 )

[17:08] <p6eval> rakudo 897636: OUTPUT«␤»

[17:08] <moritz> r: say map(&sin, ^5).perl

[17:08] <p6eval> rakudo 897636: OUTPUT«(0e0, 0.841470984807897e0, 0.909297426825682e0, 0.141120008059867e0, -0.756802495307928e0).list␤»

[17:08] <moritz> r: say (2 X* map( &sin, ^5 ))

[17:08] <p6eval> rakudo 897636: OUTPUT«␤»

[17:09] <colomon> bizarre. 

[17:09] <moritz> maybe sink bug

[17:09] <grondilu> r: say 2 X* my @ = map &sin, ^5;

[17:09] <p6eval> rakudo 897636: OUTPUT«0 1.68294196961579 1.81859485365136 0.282240016119734 -1.51360499061586␤»

[17:09] <grondilu> ^ that's a temporary fix

[17:10] <grondilu> r: say 2 X* eager map &sin, ^5;

[17:10] <p6eval> rakudo 897636: OUTPUT«0 1.68294196961579 1.81859485365136 0.282240016119734 -1.51360499061586␤»

[17:10] <grondilu> ^ or this

[17:10] <moritz> there's no mention of 'sink' in the generated PIR

[17:10] <moritz> so more likely some other list craziness

[17:13] <colomon> what I don't understand is how it can go that wrong.

[17:13] <tadzik> colomon: did you try rebootstraping panda?

[17:13] *** cognominal__ left
[17:13] <colomon> tadzik: I tried blowing it away entirely and grabbing it from github again.  same issue

[17:13] <tadzik> huh

[17:13] <tadzik> blowing away site/?

[17:13] <tadzik> the one it cannot load?

[17:13] <tadzik> also: try pandabrew :)

[17:13] <colomon> site/ ?

[17:14] <tadzik> in file '/home/colomon/tools/rakudo/install/lib/parrot/4.10.0-devel/languages/perl6/site/lib/Shell/Command.pir'

[17:14] <colomon> gotcha

[17:14] <tadzik> rebootstrap probably does that

[17:14] <tadzik> yeah, it should

[17:15] *** cognominal__ joined
[17:15] <colomon> \o/

[17:15] <colomon> blew it away, now apparently making progress again.

[17:15] *** japhb_ left
[17:17] <colomon> success!  tadzik++

[17:18] <tadzik> colomon: did you use pandabrew? :)

[17:18] <tadzik> use pandabrew

[17:18] <tadzik> I think it's awesome

[17:18] <colomon> tadzik: no, trying to find the repo now

[17:19] * colomon got sidetracked looking at his own open source contributions graph for the last year....

[17:19] <colomon> tadzik: needs a readme.

[17:20] *** cognominal__ left
[17:22] <colomon> trying now...

[17:23] *** fhelmberger left
[17:25] *** cognominal__ joined
[17:28] <dalek> roast: 7629622 | coke++ | S05-substitution/subst.t:

[17:28] <dalek> roast: add a test for RT #83484

[17:28] <dalek> roast: review: https://github.com/perl6/roast/commit/76296227af

[17:28] <colomon> tadzik: basics seem to work.

[17:30] *** rurban left
[17:32] *** am0c left
[17:33] *** domidumont joined
[17:37] *** gdey joined
[17:42] *** PacoAir joined
[17:42] <hoelzro> ok, I updated the callsame ticket with my findings: https://rt.perl.org/rt3/Ticket/Display.html?id=117377

[17:42] <hoelzro> hopefully someone more familiar with Rakudo can help now =)

[17:46] *** cognominal__ left
[17:48] *** rindolf left
[17:48] *** toddr___ left
[17:53] <moritz> retupmoca++ # Email::Simple, and being responsive to bug reports and pull requests

[17:54] *** cognominal__ joined
[17:57] * colomon remembers he meant to try Email::Simple, back before the whole thing where panda blew up for him.

[18:06] *** japhb_ joined
[18:09] <japhb_> moritz, did the DUMP gist make sense to you?

[18:10] <moritz> japhb_: kinda :-)

[18:11] <moritz> I think I now know its purpose

[18:12] <dalek> roast: 8c7a191 | coke++ | S04-phasers/enter-leave.t:

[18:12] <dalek> roast: add test for RT #115998

[18:12] <dalek> roast: review: https://github.com/perl6/roast/commit/8c7a1910d0

[18:12] <dalek> roast: b86ca3e | coke++ | S04-phasers/enter-leave.t:

[18:12] <dalek> roast: fix typo

[18:12] <dalek> roast: review: https://github.com/perl6/roast/commit/b86ca3ecec

[18:13] <japhb_> moritz, more interesting for some folks will be what it does for user-defined objects, because key to its design is exposing hidden attributes, unlike say .perl.

[18:13] <japhb_> I expect it will get much use in debugging.

[18:14] <[Coke]> moritz: why did you mark 77338 as testneeded?

[18:15] <japhb_> I still need to explore more of the built-in types to see if there are any the current code can't dump properly, though getting the various *Iter classes and Junction correct both involved a lot of subtle-bug-hunting.

[18:15] <japhb_> And Parcel v. RPA.  >.<

[18:16] <japhb_> The other big thing to do is teach it to automatically handle circular structures.  (Right now ListIter is special cased to break the loop with its associated List.)

[18:17] <[Coke]> r: say fail() ~~ Failure

[18:17] <p6eval> rakudo 897636: OUTPUT«No exception handler and no message␤␤current instr.: 'throw' pc 350791 (src/gen/CORE.setting.pir:153082) (src/gen/CORE.setting:9365)␤called from Sub 'sink' pc 382444 (src/gen/CORE.setting.pir:165429) (src/gen/CORE.setting:10630)␤called from Sub 'MAIN' pc 381 (src/g…

[18:17] <[Coke]> r: say (fail ~~ Failure)

[18:17] <p6eval> rakudo 897636: OUTPUT«use of uninitialized value of type Failure in string context  in block  at /tmp/jUomBZfSIX:1␤␤No exception handler and no message␤␤current instr.: 'throw' pc 350791 (src/gen/CORE.setting.pir:153082) (src/gen/CORE.setting:9365)␤called from Sub 'sink' pc 382444 (src/…

[18:17] <japhb_> Which reminds me -- is there any NQP or Perl 6 code out there right now which handles arbitrary directed object graph traversal?  (As opposed to C code in e.g. the serializer.)

[18:17] <[Coke]> how does one verify that one obtained a failure result?

[18:18] <moritz> [Coke]: ~~ Failure

[18:18] <moritz> [Coke]: it didn't work in your case because fail() tries to return from the outer routine

[18:18] <moritz> and returns a Failure in its place

[18:19] <moritz> so you have to do it like

[18:19] <moritz> r: say   (sub { fail('foo') })() ~~ Failure

[18:19] <p6eval> rakudo 897636: OUTPUT«True␤»

[18:20] <[Coke]> r: sub Int foo { fail() }; say foo ~~ Failure

[18:20] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/_Xyz0d06Ka:1␤------> [32msub Int [33m⏏[31mfoo { fail() }; say foo ~~ Failure[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be defined…

[18:20] <[Coke]> r: our Int sub foo { fail() }; say foo ~~ Failure

[18:20] <p6eval> rakudo 897636: OUTPUT«use of uninitialized value of type Failure in string context  in block  at /tmp/YA9ZDI8cgM:1␤␤Too many positional parameters passed; got 1 but expected 0␤  in sub foo at /tmp/YA9ZDI8cgM:1␤  in block  at /tmp/YA9ZDI8cgM:1␤␤»

[18:20] <[Coke]> r: our Int sub foo { fail('a') }; say foo ~~ Failure

[18:20] <p6eval> rakudo 897636: OUTPUT«use of uninitialized value of type Failure in string context  in block  at /tmp/Kr8Fxkhum2:1␤␤Too many positional parameters passed; got 1 but expected 0␤  in sub foo at /tmp/Kr8Fxkhum2:1␤  in block  at /tmp/Kr8Fxkhum2:1␤␤»

[18:21] <moritz> [Coke]: use foo()

[18:21] <moritz> otherwise it'll parse as  foo(~(~Failure)) or so

[18:21] <[Coke]> r: our Int sub foo { fail('a') }; say foo() ~~ Failure

[18:21] <p6eval> rakudo 897636: OUTPUT«a␤  in method sink at src/gen/CORE.setting:10630␤  in method BUILDALL at src/gen/CORE.setting:801␤  in method bless at src/gen/CORE.setting:743␤  in method new at src/gen/CORE.setting:728␤  in method new at src/gen/CORE.setting:726␤  in sub foo at /tmp/Uu3wdrYiKc:1…

[18:21] <moritz> sink bug

[18:21] <moritz> *sadface*

[18:22] <[Coke]> RT 64990 if you want to add the sink info.

[18:22] <[Coke]> actually, I will.

[18:23] <moritz> r: our Int sub foo() { fail 'a' }; my $x = foo()

[18:23] <p6eval> rakudo 897636: OUTPUT«a␤  in method sink at src/gen/CORE.setting:10630␤  in method BUILDALL at src/gen/CORE.setting:801␤  in method bless at src/gen/CORE.setting:743␤  in method new at src/gen/CORE.setting:728␤  in method new at src/gen/CORE.setting:726␤  in sub foo at /tmp/XQ1xSK6xqb:1…

[18:23] <moritz> r: our Int sub foo() { fail 'a' }; my $x = foo(); 1

[18:23] <p6eval> rakudo 897636: OUTPUT«a␤  in method sink at src/gen/CORE.setting:10630␤  in method BUILDALL at src/gen/CORE.setting:801␤  in method bless at src/gen/CORE.setting:743␤  in method new at src/gen/CORE.setting:728␤  in method new at src/gen/CORE.setting:726␤  in sub foo at /tmp/crSle3hirL:1…

[18:29] <colomon> moritz: wait, what does Email::Simple actually do?

[18:29] <dalek> v5: f0ba6e0 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[18:29] <dalek> v5: add stubs for all special variables

[18:29] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f0ba6e0ff2

[18:34] *** crab2313 left
[18:40] *** SamuraiJack_ joined
[18:43] <moritz> colomon: parse email headers, mostly

[18:43] <colomon> moritz: ah.  I was hoping for more.

[18:46] <dalek> v5: f44e1e3 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[18:46] <dalek> v5: add special var $0 (program name)

[18:46] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f44e1e3fb6

[18:48] *** cognominal__ left
[18:52] *** grondilu left
[18:54] *** cognominal__ joined
[19:03] *** rindolf joined
[19:17] * adu_ is installing panda

[19:18] *** adu_ is now known as adu

[19:18] *** camellove joined
[19:19] <adu> does TAP::Harness come with rakudo?

[19:20] *** camellove left
[19:21] <adu> which is more common extension? .pm or .pm6?

[19:23] <adu> I wish it would ask before installing

[19:24] <diakopter> star: use TAP::Harness;

[19:24] <p6eval> star 2013.02: OUTPUT«===SORRY!===␤Could not find TAP::Harness in any of: /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/site/lib, /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/vendor/lib, /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/lib, /home/p6eval/.perl6/2013.02.1/l…

[19:24] <adu> hmm

[19:24] * lizmat loves looking at FROGGS P5 commits

[19:25] <adu> the directory where panda installed to is 15 directories deep

[19:26] <adu> ok what was I supposed to use panda for?

[19:27] <adu> o right, the debugger

[19:29] <colomon> panda install Grammar::Debugger # Grammar::Tracer comes along with it

[19:30] <adu> Obsolete use of | or \ with sigil on param $args?

[19:32] <timotimo> where does that happen?

[19:32] <timotimo> nowadays you do |args instead of |$args

[19:32] *** rindolf left
[19:33] <adu> do I put use Grammar::Debugger; in the grammar or the test?

[19:33] * timotimo forgets

[19:34] <adu> timotimo: https://gist.github.com/andydude/5273055

[19:34] <timotimo> interesting. i guess i can try to fix that

[19:34] *** cognominal__ left
[19:34] <colomon> adu: in the grammar

[19:35] <adu> colomon: oh that explains why it's not working :)

[19:37] <adu> ok I did that and it says TOP

[19:37] <adu> what does that mean

[19:37] <moritz> Grammar::Tracer at east is lexically scoped

[19:37] <adu> is that the rule it's currently running?

[19:37] <timotimo> yeah, just replacing the |$args with |args twice seems to work (at least the tests pass. if it doesn't actually work, i blame the test cases)

[19:38] <colomon> adu: it should look something like this: https://gist.github.com/colomon/5273087  # my tweaked version of your grammar from earlier today

[19:38] <adu> colomon: o thank you

[19:39] <adu> where did you put the grammar?

[19:39] <adu> https://gist.github.com/colomon/5271962?

[19:40] <colomon> adu: yes

[19:40] <colomon> I think that's the same version.

[19:40] <timotimo> will take a bit for jnthn to apply the pullrequest, though, i think

[19:44] <adu> I keep getting "Cannot modify an immutable value"

[19:45] <colomon> adu: when you do what?

[19:47] <adu> when I try CInteger.parse('0')

[19:47] <adu> it just stops at TOP, then the next line whatever I enter it says that

[19:48] <adu> https://gist.github.com/andydude/5273148

[19:48] <adu> I tried modifying my grammar to look more like yours

[19:48] *** cognominal joined
[19:50] <adu> so I do perl6 -I. \n use C::CInteger; \n say C::CInteger.parse('0') \n

[19:50] <adu> then I see "TOP \n > " and a press enter, then get "Cannot modify an immutable value"

[19:52] <colomon> sounds like you're using Grammar::Debugger?  yes, I see that's what you've said above

[19:52] <colomon> I was showing you the output from Grammar::Tracer

[19:53] <adu> oh

[19:53] <adu> that's why its different

[19:53] <colomon> type h for the list of commands from the >

[19:53] <colomon> I've never really used Grammar::Debugger, I always just work from the Tracer.

[19:53] <colomon> though Grammar::Debugger is much more powerful.

[19:54] *** bluescreen100 joined
[19:54] *** bluescreen__ joined
[19:54] <adu> YEY now I get the tree with Tracer

[19:54] <adu> thanks :)

[19:54] *** bluescreen100 left
[19:54] *** bluescreen__ left
[19:54] *** bluescreen10 left
[19:56] <colomon> I'm getting the Cannot modify an immutable value error in the Debugger too, possibly a Grammar::Debugger bug?

[19:56] <adu> I dunno how it's supposed to work, its the first time I've used it :P

[19:56] * FROGGS .oO( Grammar::Bugger? )

[19:57] <colomon> looks to me like Grammar::Debugger may have been broken by recent changes to Rakudo.

[19:57] * colomon does not know which changes

[20:00] <lue> .oO(try running the Grammar::Debugger using script through perl6-debug)

[20:02] <FROGGS> r: "abc" ~~ /\w+/; say $/

[20:02] <p6eval> rakudo 897636: OUTPUT«｢abc｣␤␤»

[20:02] <FROGGS> r: "abc" ~~ /\w+/; say ~$/

[20:02] <p6eval> rakudo 897636: OUTPUT«abc␤»

[20:02] <japhb_> What's the sanest way to keep a key-value hash within the dynamic scope of a single call to a mutually-recursive set of routines, if the hash should be unique for each top-level call (i.e. each time control flow moves from outside the mutually-recursive set to inside, from any of the entry points into that mutually-recursive set)?

[20:03] <FROGGS> japhb: %*MY_HASH?

[20:03] <japhb_> FROGGS: Declared exactly how?

[20:03] <FROGGS> japhb_: within a grammar:   :my %*MY_HASH := ...

[20:04] <FROGGS> it will be available in token which are used by this token

[20:04] <FROGGS> should be the same with methods, just remove the : before 'my'

[20:04] <japhb_> FROGGS, I would think that only works when there's only one entry point into the mutually recursive set.

[20:05] <japhb_> i.e. that you can define a "topmost" member of the MRS.

[20:05] <FROGGS> hmmm, dunno how to handle that

[20:06] <dalek> v5: 3fae0b2 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[20:06] <dalek> v5: add some describtion to special vars

[20:06] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/3fae0b2cfe

[20:06] <dalek> v5: c30f586 | (Tobias Leich)++ | lib/Perl6/P5Actions.pm:

[20:06] <dalek> v5: implement $& ($MATCH)

[20:06] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/c30f586cbf

[20:07] * japhb_ is beginning to think he may have to force a single routine to be the sole entry point from the outside world (a sort of control flow choke point), and from there dispatch to the proper routine in the MRS.  :-/

[20:08] <japhb_> Gah, that's going to have crappy affordance.

[20:08] <japhb_> "There's a more obvious routine *right there*, why can't I just call it directly?"

[20:10] <lue> Are you sure you can't have the hash be outside any of the routines?

[20:10] *** SamuraiJack_ left
[20:11] <japhb_> lue: In theory it can be *declared* outside, it's trashing the contents upon crossing the outside/inside barrier that causes me trouble with that solution.

[20:12] <japhb_> (Without, that is, trashing the contents during mutual recursion as well.)

[20:12] <adu> colomon: FROGGS: thanks so much

[20:12] *** colomon left
[20:13] *** colomon joined
[20:13] <colomon> sorry 'bout that, Colloquy went all funny on me.

[20:13] *** cognominal left
[20:14] <japhb_> lue: The other problem (though of course farther out, given current implementations) is when you have multiple calls from the outside to the inside "live" at the same time, so they can't share the same copy of the hash.

[20:14] <japhb_> Essentially, it's a private cache for the MRS that I'm looking for.

[20:17] <lue> would  %hash is copy  help in any way if the hash were declared outside?

[20:18] <japhb_> Hmmm, that could possibly work actually.  I'd think you'd create a lot of GC pressure that way, though.

[20:18] <lue> I'd suggest %hash is rw to avoid all the copying, but you stated that destroying the outside hash is a Bad Idea.

[20:19] <japhb_> lue, if it's 'is rw', how does it get reset on first call to one of the routines?

[20:19] <lue> .oO(multi sub recurse1(%hash is copy) { ... }; multi sub recurse("internal", %hash is rw) { ... }; perhaps to avoid *all* the copying)

[20:20] <lue> s/recurse\(/recurse1(/

[20:20] <japhb_> Hmmmm

[20:21] * japhb_ begins to think evil thoughts about dispatcher overrides.

[20:21] <lue> And then perhaps a macro to avoid typing the same code twice in different places?

[20:21] <japhb_> nodnod

[20:22] *** felher left
[20:23] *** cognominal joined
[20:23] <lue> (whether this solves the second, "can't share same copy of hash" problem I do not know)

[20:25] <adu> YEY it can parse a primary-expression!

[20:26] <japhb_> r: sub r1 { my %*CACHE; %*CACHE{test} = "yay!"; r2(); }; sub r2() { r1() unless %*CACHE; say %*CACHE{test}; }; r2();

[20:26] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    test used at line 1␤␤»

[20:26] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { r1() unless %*CACHE; say %*CACHE<test>; }; r2();

[20:26] <p6eval> rakudo 897636: OUTPUT«yay!␤Dynamic variable %*CACHE not found␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:10633␤  in sub r2 at /tmp/tm_nIAcFb9:1␤  in block  at /tmp/tm_nIAcFb9:1␤␤»

[20:27] <japhb_> lue: I'm currently working through a combination of your idea and FROGGS's

[20:27] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { r1() unless try %*CACHE; say %*CACHE<test>; }; r2();

[20:27] <p6eval> rakudo 897636: OUTPUT«yay!␤Dynamic variable %*CACHE not found␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:10633␤  in sub r2 at /tmp/3amxXmNLQW:1␤  in block  at /tmp/3amxXmNLQW:1␤␤»

[20:27] <colomon> adu++

[20:27] *** cognominal left
[20:28] <FROGGS> japhb_: hehe, I dont know if it is the best advice to follow to directions at once *g*

[20:28] <japhb_> r: say %*FOO;

[20:28] <p6eval> rakudo 897636: OUTPUT«Dynamic variable %*FOO not found␤  in method gist at src/gen/CORE.setting:10622␤  in method gist at src/gen/CORE.setting:902␤  in sub say at src/gen/CORE.setting:7646␤  in block  at /tmp/oEyFo0fkpr:1␤␤»

[20:28] <japhb_> r: say try {%*FOO};

[20:28] <p6eval> rakudo 897636: OUTPUT«Dynamic variable %*FOO not found␤  in method gist at src/gen/CORE.setting:10622␤  in method gist at src/gen/CORE.setting:902␤  in sub say at src/gen/CORE.setting:7646␤  in block  at /tmp/5RILzHMYzD:1␤␤»

[20:28] <lue> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { r1() unless try %*CACHE; say %*CACHE<test>; CATCH { default { } }}; r2();

[20:28] <p6eval> rakudo 897636: OUTPUT«yay!␤»

[20:28] <moritz> r: say defined %*FOO

[20:28] <p6eval> rakudo 897636: OUTPUT«False␤»

[20:29] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { r1() unless defined %*CACHE; say %*CACHE<test>; }; r2();

[20:29] <p6eval> rakudo 897636: OUTPUT«yay!␤Dynamic variable %*CACHE not found␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:10633␤  in sub r2 at /tmp/60Y557wry4:1␤  in block  at /tmp/60Y557wry4:1␤␤»

[20:29] <lue> ah, that's what it was (I tried %*FOO.exists earlier :P)

[20:29] <japhb_> moritz, why doesn't the one I just tried work?

[20:30] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { r1() unless %*CACHE; say %*CACHE<test>; CATCH { default { } }}; r2();

[20:30] <p6eval> rakudo 897636: OUTPUT«yay!␤»

[20:30] <moritz> japhb_: because the 'my %*CACHE' in r1 goes away again once r1 terminates

[20:30] <moritz> so calling it from r2 doesn't define it in r2

[20:31] *** cognominal joined
[20:31] <dalek> v5: cbff4ad | (Tobias Leich)++ | lib/Perl6/P5Actions.pm:

[20:31] <dalek> v5: add more longnames to special vars

[20:31] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/cbff4adbee

[20:32] *** domidumont left
[20:32] <moritz> r: sub r1(&c?) { my %*C; %*C<test> = 'yay!'; c() if &c }; sub r2 {if %*C { say %*C<test> } else { r1(&?ROUTINE) } }; r2()

[20:32] <p6eval> rakudo 897636: OUTPUT«yay!␤»

[20:32] <japhb_> moritz, I'm being blind.  The first call to r2() should get defined %*CACHE is False, as you showed, and the second call (from within r1()) should work, no?

[20:32] <skids> r: perl6 -e 'sub a ($depth = 0) { CALLER::.say ; a($depth + 1) if $depth < 3 }; a()' # was thinking something fun with a where clause for japhb_'s problem but this...

[20:32] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/NAJGlVHLyY:1␤------> [32mperl6 -e [33m⏏[31m'sub a ($depth = 0) { CALLER::.say ; a($[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤      …

[20:33] <skids> erm

[20:33] <FROGGS> r: sub a ($depth = 0) { CALLER::.say ; a($depth + 1) if $depth < 3 }; a()

[20:33] <p6eval> rakudo 897636: OUTPUT«PseudoStash.new("!UNIT_MARKER", !UNIT_MARKER, "GLOBALish", GLOBAL, "EXPORT", EXPORT, "\$?PACKAGE", GLOBAL, "::?PACKAGE", GLOBAL, "\$_", Any, "\$/", Any, "\$!", Any, "\&a", sub a($depth = { ... }) { ... }, "\$=pod", Array.new(), )␤No such method 'perl' for invocant …

[20:34] <skids>  … of type 'CallContext'

[20:34] <skids> yet CALLER.WHAT is always PseudoStash.

[20:34] <lue> Apparently defining my %*DYNVAR; doesn't travel like you want it to? (it's the r2 call in r1 that prints "yay", by the way)

[20:36] <japhb_> lue, The part I'm confused about is how moritz got merely False with no error when he did: r: say defined %*FOO ... but when I did seemingly the same construct in r2(), it didn't work.

[20:36] <japhb_> (Or rather, it did print yay!, but it also threw the error instead of being silently False.)

[20:37] <lue> japhb_: I think it's the say %*CACHE from the initial r2 call that throws the error, *not* the definedness test

[20:37] <japhb_> *headdesk*

[20:38] <japhb_> Duh.  I wrote down a different control flow than I had in my head.

[20:38] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { return r1() unless %*CACHE; say %*CACHE<test>; CATCH { default { } }}; r2();

[20:38] <p6eval> rakudo 897636: OUTPUT«yay!␤»

[20:38] <japhb_> THERE WE GO.

[20:38] <japhb_> That's what I was *thinking*.

[20:38] <japhb_> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { return r1() unless %*CACHE; say %*CACHE<test>; }; r2();

[20:38] <p6eval> rakudo 897636: OUTPUT«yay!␤»

[20:39] <japhb_> Oooh, now we're getting somewhere.

[20:39] *** dmol joined
[20:39] <lue> (fwiw, I'm not sure creating a * twigiled variable is strictly necessary here)

[20:40] <japhb_> lue: Without it, how do you meet the original problem requirements?

[20:41] <lue> r: sub r1 { my %*CACHE; %*CACHE<test> = "yay!"; r2(); }; sub r2() { return r1() unless %*CACHE; say %*CACHE<test>; }; my %*CACHE = "test","woohoo!"; r2(); # this is what you mean?

[20:41] <p6eval> rakudo 897636: OUTPUT«woohoo!␤»

[20:42] <japhb_> Yeah, it didn't get a fresh hash

[20:43] <japhb_> But I think more I'm worried about something a bit different.  Let me see if I can express it.

[20:44] <japhb_> r: sub r1($s) { my %*CACHE; %*CACHE{$s} = $s; r2(); }; sub r2($s) { return r1($s) unless %*CACHE; say %*CACHE; }; r2("a"); r2("b");

[20:44] <p6eval> rakudo 897636: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'r2' will never work with no arguments (lines 1, 1)␤    Expected: :($s)␤»

[20:44] <japhb_> r: sub r1($s) { my %*CACHE; %*CACHE{$s} = $s; r2($s); }; sub r2($s) { return r1($s) unless %*CACHE; say %*CACHE; }; r2("a"); r2("b");

[20:44] <p6eval> rakudo 897636: OUTPUT«("a" => "a").hash␤("b" => "b").hash␤»

[20:44] <japhb_> I want to preserve that behavior.

[20:45] <japhb_> Meaning, I think that's why I need a 'my %*CACHE' declaration

[20:46] <lue> I was saying you might get away with just my %CACHE instead of %*CACHE

[20:46] <lue> r: sub r1($s) { my %CACHE; %CACHE{$s} = $s; r2($s); }; sub r2($s) { return r1($s) unless %CACHE; say %CACHE; }; r2("a"); r2("b");

[20:46] <p6eval> rakudo 897636: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '%CACHE' is not declared␤at /tmp/jz18OKNrFl:1␤------> [32msub r2($s) { return r1($s) unless %CACHE[33m⏏[31m; say %CACHE; }; r2("a"); r2("b");[0m␤    expecting any of:␤        postfix␤»

[20:46] <lue> ah. nevermind then.

[20:47] <japhb_> Yeah.  I thought you meant as opposed to doing 'my %CACHE' all the way outside.

[20:47] <skids> hmm... lift?  but NYI.

[20:47] <japhb_> .oO( Features you don't understand the need for until one day you hit that *one problem* .... )

[20:48] <japhb_> Thanks everyone for the brainstorming and good ideas.

[20:48] <lue> you're welcome :)

[20:49] *** FROGGS left
[20:50] *** FROGGS joined
[20:53] *** cognominal left
[20:53] <masak> rehi, #perl6

[20:54] <adu> and now it parsed "typedef int my_int;" as <declaration>

[20:56] <masak> I tweeted today that APIs should favor "do one thing well" and hookability. got back "composability trumps hookability". definitely an interesting point. I just wonder if composability is as universal as hookability. I'm not so sure.

[20:57] *** thou left
[20:57] <adu> wow it took 17 seconds to parse "typedef int my_int;"

[20:57] <geekosaur> composability is great if you can define what composing something means in all cases

[20:58] <geekosaur> sometimes you can't

[20:58] <geekosaur> and sometimes you can but ordinary humans can't understand the result

[20:58] <adu> masak: define both

[20:58] *** cognominal joined
[20:58] *** thou joined
[20:59] <masak> adu: "hookability" := "API allows you to inject your own code at pre-set points of usage". think Git hooks.

[21:00] <adu> I call that inversion of control

[21:01] <masak> adu: "composability" := "there's at least one operation which takes things of type A and produces a new thing of type A", with the assumption that A is a pretty central thing to the API. think operators acting on smaller expressions to make larger expressions, or widgets composing to form bigger widgets.

[21:01] <masak> adu: hookability is a form of inversion of control.

[21:01] <masak> adu: event loops are another.

[21:02] <masak> adu: reactive programming is yet another.

[21:02] <adu> composability is nice in theory, but I've given up on it in practice

[21:04] <adu> because no matter how nice a design is, there will always be assumptions, and where there are assumptions, there are violations

[21:04] <masak> do you have a concrete example?

[21:04] <adu> maybe I'm a pessimist

[21:05] <adu> yes

[21:06] *** dmol left
[21:06] <masak> I have a concrete example (beyond, you know, algebra and stuff) of where composability seems to work really well: jQuery. most jQuery methods take a selection object and emit a selection object. that's why you can chain them any which way you like. it's the "100 operations on 1 data structure beats 10 operations on 10 data structures" phenomenon at work.

[21:06] *** dmol joined
[21:06] <adu> HTTP, suppose a 12-year-old writes an HTTP server in ASM for example, and doesn't find out that the Date isn't ISO format, but funky Wed format until he tries to connect to it with a standard web browser and everything falls apart

[21:09] * _sri is a big fan of hookability, mojolicious is full of it

[21:09] *** cognominal left
[21:11] <masak> I agree with "composability > hookability" in theory, but I'm having trouble seeing how to apply the former in all cases where I would easily apply the latter.

[21:12] <masak> adu: I don't understand. how is that an example of anything except mis-implementing a standard?

[21:12] <masak> s/except/besides/

[21:12] <adu> masak: I think of everything like that

[21:12] <moritz> it shows that separation of concern is important, even if you are in charge of the whole system

[21:12] <adu> almost every piece of software could be construed as a mis-implementation of common lisp

[21:13] <moritz> one could also say that common lisp is a mis-implementation of almost every other software :-)

[21:14] *** cognominal joined
[21:14] <adu> moritz: true

[21:15] <adu> anyways, igtg

[21:15] *** adu left
[21:16] <_sri> combining composability and hookability is fun too, i think the node.js api is a good example for that

[21:17] *** skids left
[21:17] <dalek> v5: 2955581 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[21:17] <dalek> v5: move special-var-longnames into grammar tokens

[21:17] <dalek> v5: 

[21:17] <dalek> v5: This way we can use vars like $OSNAME directly, lizmat++.

[21:17] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/29555817ec

[21:18] *** cognominal left
[21:18] <_sri> http://nodejs.org/api/util.html#util_util_pump_readablestream_writablestream_callback # i think this counts as both

[21:18] <masak> adu: I don't get your example, or how it relates to composability.

[21:19] <_sri> (behind the scenes both stream objects are connected with events)

[21:20] *** bluescreen10 joined
[21:21] <_sri> oh wait, this is a better example :S http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options

[21:22] *** dmol left
[21:26] * _sri wonders how good pointy blocks will make evented stuff look in perl6

[21:28] <_sri> fat arrow functions in javascript win i guess ['caption', 'select', 'cite', 'article'].map(word => word.toUpperCase());

[21:28] *** gdey left
[21:30] *** gdey joined
[21:30] *** vami joined
[21:31] <masak> _sri: did you mean "coffeescript"? :)

[21:31] <masak> or is there some future addition to ECMAScript that I'm unaware of?

[21:31] <_sri> nope, it's part of javascript now

[21:31] <masak> oh, ok. which version?

[21:31] *** vami left
[21:32] <_sri> http://css.dzone.com/articles/javascript-fat-city

[21:32] <_sri> ES6

[21:32] <masak> ah, yes.

[21:33] *** thou left
[21:35] *** thou joined
[21:37] <_sri> oh, i always wanted to ask, are gather/take composable?

[21:37] *** gtodd left
[21:39] <dalek> v5: f3f0ff5 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[21:39] <dalek> v5: more longnames

[21:39] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f3f0ff54c0

[21:39] <moritz> _sri: what does that mean?

[21:39] <_sri> (as in pythons "yield from <expr>" http://www.python.org/dev/peps/pep-0380/)

[21:40] <moritz> "A Python generator is a form of coroutine, but has the limitation that it can only yield to its immediate caller. This means that a piece of code containing a yield cannot be factored out and put into a separate function in the same way as other code."

[21:40] <_sri> i've been looking into that recently because it's the foundation of pythons new core event loop (Tulip)

[21:40] <moritz> gather/take deosn't have that limitation

[21:41] <_sri> ah

[21:41] <_sri> neat

[21:41] <moritz> r: say gather { a(); b() }; sub a { take 42 }; sub b { take 23 };

[21:41] <p6eval> rakudo 897636: OUTPUT«42 23␤»

[21:43] <_sri> clear win for perl6 there i guess :)

[21:43] <_sri> javascript seems to follow python semantics too

[21:44] <moritz> (mostly unrelated) I also love that you don't need the curlies if there's just one expression

[21:44] <moritz> r: say gather a(), b(); sub a { take 42 }; sub b { take 23 }

[21:44] <p6eval> rakudo 897636: OUTPUT«42 23␤»

[21:44] <moritz> also in

[21:44] <moritz> r: try f(); sub f() { die "OH NOEZ" }; say 'alive';

[21:44] <p6eval> rakudo 897636: OUTPUT«alive␤»

[21:48] <_sri> is there a way to have a closure without curlies?

[21:48] <masak> _sri: that enters into macro land, I would say.

[21:49] <moritz> r: say map * + 1, <1 2 3>

[21:49] <p6eval> rakudo 897636: OUTPUT«2 3 4␤»

[21:49] <masak> _sri: but a lot of built-in constructs do that. think of the rhs of &&, for example.

[21:49] <_sri> ok, way over my head for now then :)

[21:49] <masak> also, what moritz++ said. but I supposed that's not what you wanted.

[21:49] <moritz> it doesn't work in the general case, but you can easily make closures of most infix operators, and of method calls

[21:50] <_sri> i was thinking about the generic javascript example above ['foo', 'bar', 'baz'].something(<closure>)

[21:50] <moritz> r: say map *.uc, <oh noez>;

[21:50] <p6eval> rakudo 897636: OUTPUT«OH NOEZ␤»

[21:51] <dalek> v5: 3922187 | (Tobias Leich)++ | lib/Perl6/P5 (2 files):

[21:51] <dalek> v5: add more longnames and make $* "no longer supported"

[21:51] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/3922187bfc

[21:53] <masak> I don't much mind the curlies there, though. they indicate to me the code isn't executed immediately.

[21:54] <moritz> whoa, $*. I totally forgot what that did.

[21:54] <moritz> and then there's $[, of which I want to forget what it did :-)

[21:55] <FROGGS> hehe

[21:55] <FROGGS> moritz: I never knew these vars... 

[21:55] <FROGGS> some are handy of course, like $NR

[21:56] <FROGGS> I might use it now I know that it exists

[21:56] <moritz> it's really scary how many special variables you have to set to make Perl 5 code do what you want, even if your caller messed with those vars

[21:56] <moritz> like, setting $\ if you need print()

[21:56] <moritz> and $" when interpolating arrays into strings

[21:57] <moritz> and $/ for <$filehandle> and chomp

[21:57] <lue> I only saw the P5 special vars once. I'm glad they don't exist here :)

[21:57] <FROGGS> lue: ohh, we have $/, $() and friends

[21:58] <moritz> and $^I is big fun too

[21:58] <moritz> FROGGS: well, we have $_, $! and $/ (and $¢, but you never see that)

[21:58] <moritz> those are the only ones that are really special, and present everywhere

[21:59] <moritz> three special vars ain't too bad

[21:59] <lue> at least we don't have annoyingly unbalanced-paren vars

[22:00] * lue kinda wishes ¢vars stayed, just because it makes P6 different

[22:01] <FROGGS> well, we have thousands of operators in exchange

[22:02] *** tgt left
[22:02] <moritz> oh, and I forgot $, when talking about print :-)

[22:03] <FROGGS> at least there are no <sigil> <ws> -special vars...

[22:03] <_sri> clearly perl needs a config file for all those special vars :)

[22:04] *** tgt joined
[22:05] <_sri> i hear the ini format is very popular

[22:05] <FROGGS> std: use v5; my @DATA = <DATA>;␤__DATA__␤test␤123

[22:05] <p6eval> std 86b102f: OUTPUT«ok 00:01 53m␤»

[22:06] <masak> moritz: hm, it seems that implicit in the term "composability" is "caller should not be able to mess with callee". but I fail to see why that is.

[22:08] <moritz> masak: example: the callee is a test function, and must produce valid TAP as output. It should do that even if the caller sets $, = '42';

[22:08] <moritz> but it won't, if it works along the lines of

[22:08] <moritz> sub ok { print $_[0] ? 'not ' : '', "ok\n"

[22:09] <masak> right. which leads to a lot of defensive programming.

[22:09] <moritz> or to a lot of bugs

[22:09] <masak> setting $, with local everywhere.

[22:09] <moritz> aye, and $/ and $\ and $@ and whatever

[22:10] <moritz> the problem isn't really that the caller can mess with the callee, but that the caller can *accidetally* mess with the callee

[22:10] <moritz> (as a side effect of doing something for a different purpose)

[22:11] *** Swarley_ joined
[22:11] <FROGGS> std: use v5; my @DATA = <DATA>;␤__DATA__␤$x

[22:11] <p6eval> std 86b102f: OUTPUT«ok 00:01 53m␤»

[22:13] <moritz> (there's a perlmonks discussion about this and other "defensive" stuff: http://www.perlmonks.org/?node_id=1026189 though not too much to see yet)

[22:14] <FROGGS> std: use v5; use Config; say $Config{ptrsize}

[22:14] <p6eval> std 86b102f: OUTPUT«ok 00:01 53m␤»

[22:16] *** thou left
[22:20] <FROGGS> std: use v5; use strict; my @DATA = <DATA>;␤__DATA__␤$x l $y

[22:20] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/pPjZn3CtEj line 3:␤------> [32m$x [33m⏏[31ml $y[0m␤    expecting any of:␤       p5infix␤        statement modifier␤Parse failed␤FAILED 00:01 53m␤»

[22:20] <FROGGS> as I said earlier, std is cheating :o)

[22:24] <masak> moritz: yes, that's what I meant. more like "caller should not accidentally pollute callee".

[22:24] <masak> (which is starting to sound a whole lot like lambda calculus. I guess because lambda calculus is essentially a calculus of composability.)

[22:25] *** labster joined
[22:31] <masak> dynamicals are a bit of a double-edged sword there. you gain the ability to pass information to your (transitive) callees through a convenient channel. but as composition goes to infinity, the chance that something, anything -- including re-entrancy -- will mess with that channel goes to 1.

[22:33] *** Bzek joined
[22:40] *** skids joined
[22:53] *** gdey left
[22:55] <FROGGS> Unable to parse expression in pseudo filehandle; couldn't find final "\n\n"

[22:55] <FROGGS> ------> <BOL>⏏<EOL>

[22:55] <FROGGS> moritz / masak: do you know how to match EOF ?

[22:56] <masak> FROGGS: with a dollar sign?

[22:56] <FROGGS> masak: no, have to pass a string to method nibble

[22:56] <masak> then I don't know.

[22:56] <FROGGS> hmmm

[22:57] *** pib1990 joined
[23:04] <masak> 'night, #perl6

[23:04] <FROGGS> gnight masak 

[23:07] <labster> good night masak, hello #perl6

[23:07] <FROGGS> hi labster 

[23:09] <lue> .u EOF

[23:09] <yoleaux> No characters found

[23:09] <labster> .u END OF FILE

[23:09] <yoleaux> No characters found

[23:10] <FROGGS> .u NEW LINE

[23:10] <yoleaux> No characters found

[23:10] <FROGGS> bah

[23:10] <japhb_> Is yoleaux a phenny replacement?

[23:10] <japhb_> And what happened to phenny, anyway?

[23:11] <flussence> .u U+0019

[23:11] <yoleaux> U+0019 END OF MEDIUM [Cc] (␙)

[23:11] <flussence> that's the closest to an actual "EOF" I know of... not many things use it these days, mostly DOS

[23:11] <labster> .u NEWLINE

[23:11] <yoleaux> U+2424 SYMBOL FOR NEWLINE [So] (␤)

[23:11] <FROGGS> .u ENDOFFILE

[23:11] <yoleaux> No characters found

[23:12] <japhb_> .u END OF

[23:12] <yoleaux> U+06DD ARABIC END OF AYAH [Cf] (<control>)

[23:12] <yoleaux> U+0700 SYRIAC END OF PARAGRAPH [Po] (܀)

[23:12] <yoleaux> U+1A1F BUGINESE END OF SECTION [Po] (᨟)

[23:12] <tadzik> isn't yoleaux pronounced "yolo"? :f

[23:12] <japhb_> .oO( Why those three? )

[23:13] <japhb_> You Obviously Like Owls

[23:13] <FROGGS> Unable to parse expression in pseudo filehandle; couldn't find final "␙"

[23:13] <FROGGS> at t/spec/bigmem/read.v5:26

[23:13] <FROGGS> ------> <BOL>⏏<EOL>

[23:14] <FROGGS> maybe I fiddle width method nibble, like an option that it should nibble to the end

[23:14] <labster> .u TRANSMISSION

[23:14] <yoleaux> U+2404 SYMBOL FOR END OF TRANSMISSION [So] (␄)

[23:14] <yoleaux> U+2417 SYMBOL FOR END OF TRANSMISSION BLOCK [So] (␗)

[23:15] <labster> I used to live in Yolo County.

[23:16] <lue> tadzik: that's one of my first thoughts on discovering yoleaux was the new phenny

[23:16] <lizmat> FROGGS: shouldn't a source file be "split" on the first \n__DATA__ or \n__END__ ?

[23:17] <japhb_> .chars END OF

[23:17] <yoleaux> <control> ܀ ᨟ ∎ ⋳ ⋴ ⋻ ⋼ ␃ ␄ ␗ ␙ 𝆨

[23:17] <FROGGS> lizmat: well, I'd like to use methods that are already there, and there is currently no "split"

[23:17] <lizmat> FROGGS: and anything after that be ignored?

[23:18] <lizmat> ack

[23:19] <lizmat> in any case, anything after __DATA__ or __END__ can be anything at all, so shouldn't be parsed

[23:19] * lizmat will sleep on it

[23:20] <FROGGS> that's why I try to nibble it like a single-quoted string

[23:21] <lizmat> but there may not be a ' at the end

[23:21] <lizmat> isn't that a problem?

[23:22] <FROGGS> no, you can give it different starters and stoppers

[23:22] <lizmat> ok, so you want EOF to be the stopper

[23:22] <FROGGS> but I think I just look at how it works, and do a simpler nibbler for these sections

[23:23] <FROGGS> because it dont has to look for a stopper, and it dont has to care about an escaped stopper

[23:23] <lizmat> indeed

[23:23] <FROGGS> maybe I just can move the cursor, but I'm not sure atm

[23:23] <lizmat> still, this doesn't feel right

[23:24] <lizmat> also: the DATA handle needs to be at the first line after __DATA__ at start of execution

[23:24] <FROGGS> right

[23:24] <lizmat> so you will need to remember a position somewhere

[23:24] <FROGGS> of course, one must be able to seek too

[23:24] <lizmat> okidoki…  wasn't sure how well you were versed in these Perl 5 peculiarites

[23:25] <lizmat> FWIW, I think Perl 5 on Rakudo can live with opening another handle for DATA

[23:25] <FROGGS> I know quiet a bit :o)    ... but as everyone, I can't know everything (and I surely does not), so, any help/input is welcome

[23:26] <lizmat> I'm off to bed now, but I definitely want to give input and help

[23:27] <lizmat> seeing your commits has made me feel I can actually contribute here  :-)

[23:27] <lizmat> but not tonight

[23:27] <lizmat> :-)

[23:27] <FROGGS> you can, it is quiet simple after the first days

[23:27] <FROGGS> ya :o)

[23:27] <lizmat> :-)  cool

[23:27] <lizmat> night #perl6!

[23:28] *** adu_ joined
[23:28] <FROGGS> night lizmat 

[23:39] *** cognominal joined
[23:41] *** rogorido joined
[23:49] <adu_> how do I do a heredoc?

[23:49] <adu_> q:to'EOS' isn't working

[23:50] *** Swarley_ left
[23:50] *** Swarley_ joined
[23:50] <flussence> std: q:to'EOS'␤a␤EOS

[23:50] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized quote modifier: to'EOS at /tmp/0bu4XInmdG line 1:␤------> [32mq[33m⏏[31m:to'EOS'[0m␤(Possible runaway string from line 1)␤Couldn't find terminator ' at /tmp/0bu4XInmdG line 3 (EOF):␤------> [32mEOS[33m⏏[31m<EOL>[0m␤…

[23:51] <flussence> std: q:to('EOS')␤a␤EOS

[23:51] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Alphanumeric character is not allowed as delimiter at /tmp/6PsrgKK3M5 line 2:␤------> [32m<BOL>[33m⏏[31ma[0m␤    expecting any of:␤      escape␤ statement modifier loop␤Parse failed␤FAILED 00:00 42m␤»

[23:51] <flussence> std: q:to('EOS');␤a␤EOS

[23:51] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤(Possible runaway string from line 1)␤Couldn't find terminator ; at /tmp/bHQg8OOE6K line 3 (EOF):␤------> [32mEOS[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:00 42m␤»

[23:51] <flussence> r: say q:to('EOS');␤a␤EOS

[23:51] <p6eval> rakudo 897636: OUTPUT«␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀S␀␀␀O␀␀␀R␀␀␀R␀␀␀Y␀␀␀!␀␀␀␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀␤␀␀␀C␀␀␀o␀␀␀u␀␀␀l␀␀␀d␀␀␀n␀␀␀'␀␀␀t␀␀␀ ␀␀␀f􏿽xE2􏿽x90

[23:51] *** ilbot6 left
[23:51] <flussence> whoops

[23:52] <flussence> r: say q:to<EOS>;␤a␤EOS

[23:52] <p6eval> rakudo 897636: OUTPUT«a␤␤»

[23:52] <adu_> ooh

[23:52] <adu_> ok

[23:52] <adu_> thanks

[23:53] <flussence> I don't know why the ('') version didn't work but there you go

[23:53] <diakopter> haha; you killed ilbot6

[23:56] *** rogorido left
[23:56] <diakopter> r: say q:to('');␤boo

[23:56] <p6eval> rakudo 897636: OUTPUT«===SORRY!===␤Cannot look up attributes in a type object␤»

[23:57] <flussence> .oO( I wonder if that ilbot crash is reproducible... )

[23:57] <flussence> r: say Buf.new('␀'.encode()[0,1]).decode('latin-1')

[23:57] <p6eval> rakudo 897636: OUTPUT«â␤»

[23:58] *** pecastro left
