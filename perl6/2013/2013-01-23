[00:00] <masak> so, I solved the Sierpinski mini-challenge: https://gist.github.com/4600143

[00:00] <masak> I'm pretty sure this is the trickiest recursion problem I've solved.

[00:01] <masak> it's not so much that it's *hard*, it's that there are many loose ends, and I ended up being very aware of both parameters and return values.

[00:01] <masak> if anyone spots any simplification, I'd be happy to hear it.

[00:02] <shachaf> What is the Sierpinski mini-challenge?

[00:05] <masak> http://irclog.perlgeek.de/perl6/2013-01-22#i_6364169

[00:07] *** orafu left
[00:07] *** orafu joined
[00:08] <lue> hello o/

[00:09] <masak> or, to put it differentely, the final solution consists of two mutually recursive routines, each with three inputs and two outputs, some of which are higher-order functions. :)

[00:09] <masak> lue! \o/

[00:09] <timotimo> http://philippe.bruhat.net/stuff/git-fractals/         whhhyyyyyyyyyyyyyy?

[00:09] <masak> yeah, that's the stuff.

[00:09] <masak> oh, 404 :/

[00:10] <masak> BooK: ping. see http://irclog.perlgeek.de/perl6/2013-01-22#i_6364169 and https://gist.github.com/4600143 :)

[00:10] <masak> BooK: (and if you don't pong, I'm going to mail you a summary) :)

[00:10] <timotimo> (archive org has it)

[00:10] <timotimo> http://web.archive.org/web/20120310215139/http://philippe.bruhat.net/stuff/git-fractals

[00:10] <timotimo> oh, but it doesn' thave the sierpinski yet at that date. hold on

[00:10] <lue> just read jnthn's gist earlier. It sounds like a nice idea.

[00:11] <timotimo> huh. it *does*!

[00:11] <timotimo> http://web.archive.org/liveweb/http://gg.jk.gs/git/sierp/ - here you can apparently find the implementation for git

[00:12] *** fgomez left
[00:12] *** fgomez joined
[00:13] <masak> timotimo: hm, that appears to be a recursive solution.

[00:13] <masak> if I'm reading it right, though, it creates somewhat different triangles.

[00:13] <masak> too tired to understand it in detail :)

[00:13] <lue> question: would jnthn's change remove the (imo weird) .[] forms?

[00:13] <masak> if my memory serves me, BooK couldn't figure out a recursive solution, and that's why I tried.

[00:14] <timotimo> you should publish a paper :)

[00:16] <masak> I might write it up as a blog post.

[00:16] <masak> lue: no.

[00:16] <masak> lue: what's weird about them? .[] is to $obj.[] as .method is to $obj.method (with the dot in '$obj.[]' being optional)

[00:17] <masak> lue: I like writing stuff like `say "%s-%s-%s", .[1], .[2], .[0] given @values`

[00:17] <lue> I guess I don't conceptualize [] and {} as method names

[00:18] <masak> er `say sprintf "%s-%s-%s", .[1], .[2], .[0] given @values`

[00:18] <lue> Ah. I was just about to say I can't recall ever seeing .[] be used, and thus if it's even necessary. Nevermind :)

[00:18] <masak> lue: they're not. postcircumfix:<[ ]> and postcircumfix:<{ }> are the method names.

[00:18] <masak> the .[] and .{} forms are sugar.

[00:19] <masak> anyway. past my bedtime.

[00:19] <masak> 'night, #perl6

[00:19] <timotimo> when exactly do you need the .[] and .{} forms?

[00:19] <timotimo> i think i've only seen that once so far

[00:19] <lue> good ‚ôû, masak o/

[00:19] <lue> timotimo: see masak above.

[00:20] <timotimo> oh, i get it

[00:20] <timotimo> that's kind of smart

[00:20] *** benabik joined
[00:21] <lue> But in the usual use of subscripts, @array.[0] is time wasted on another keypress :)

[00:21] <timotimo> right

[00:23] <lue> r: my @a = <a b c>; say sprintf "%s-%s-%s", @a[0] # haven't seen this in a while

[00:23] <p6eval> rakudo a26956: OUTPUT¬´Null PMC access in get_string()‚ê§  in sub sprintf at src/gen/CORE.setting:2429‚ê§  in block  at /tmp/g6gzDCvevT:1‚ê§‚ê§¬ª

[00:25] <timotimo> huh?

[00:25] <timotimo> oh, the null pmc access?

[00:27] <lue> yep. Can't remember that last time I ran across one myself.

[00:27] <lue> The cause is obvious, it just shouldn't be a Parrot message (at least I would think).

[00:27] <timotimo> why does --profile output no information whatsoever? :(

[00:28] <benabik> IIRC, it doesn't output on a non-zero exit.

[00:28] *** fgomez left
[00:29] <timotimo> aaaaaaw man

[00:29] *** Guest80864 left
[00:33] *** kivutar left
[00:35] <timotimo> trying to figure out what takes panda 3 seconds to start up in order to display the usage

[00:43] *** fgomez joined
[00:44] *** atrodo left
[00:49] *** atrodo joined
[01:03] *** alec__ is now known as alec

[01:05] *** anuby joined
[01:12] *** hypolin joined
[01:27] *** autumn is now known as subroutine

[01:29] *** aindilis` left
[01:29] *** subroutine is now known as autumn

[01:41] *** benabik left
[01:41] *** stevan_ joined
[01:42] *** stevan_ left
[01:44] *** dduncan joined
[01:44] *** dduncan left
[01:44] *** benabik joined
[01:45] *** araujo joined
[01:45] *** araujo left
[01:45] *** araujo joined
[01:52] *** dayangkun left
[01:56] *** stevan_ joined
[02:00] *** donghongbo joined
[02:29] *** aindilis joined
[02:36] *** xenoterracide left
[02:36] *** xenoterracide joined
[02:42] <timotimo> oh, the hmac specification is pretty short

[02:45] *** swarles joined
[02:45] <swarles> Can anyone tell me if I'm using the '!' negation correctly here? My comments should say what I'm trying to match well enough if the name of the token isn't already self explanatory. http://pastebin.com/2ZgYJJDn

[02:46] <timotimo> did you try the rakudo-debugger yet?

[02:47] <flussence> r: q{'\\'} ~~ / "'" [ [! [ "'" | "\\" ] ] | "\\" . ]* "'" /;

[02:47] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter ! (must be quoted to match literally)‚ê§at /tmp/jPqE_9AXEe:1‚ê§------> [32mq{'\\'} ~~ / "'" [ [[33m‚èè[31m! [ "'" | "\\" ] ] | "\\" . ]* "'" /;[0m‚ê§Unrecognized regex metacharacter [ (must be quoted to ma‚Ä¶

[02:47] <swarles> no, I'm under Windows. I need to get around to setting up an environment

[02:47] <flussence> computer says no

[02:47] <swarles> oh :(

[02:47] * timotimo is trying to install it right now

[02:47] <timotimo> flussence: :D

[02:48] <timotimo> there's also grammar::debugger i think

[02:48] <flussence> r: q{'\\ \n'} ~~ / \' ~ \' [ '\\' . | . ] /;

[02:48] <p6eval> rakudo a26956: OUTPUT¬´Unable to parse expression in ; couldn't find final \'‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1038‚ê§  in regex  at /tmp/BMaKlMLA2E:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10731‚ê§  in block  at /tmp/BMaKlMLA2E:1‚ê§‚ê§¬ª

[02:48] <flussence> hrm

[02:48] <flussence> r: q{'\\ \n'} ~~ / ' ~ ' [ '\\' . | . ] /;

[02:48] <p6eval> rakudo a26956:  ( no output )

[02:48] <flussence> r: say q{'\\ \n'} ~~ / ' ~ ' [ '\\' . | . ] /;

[02:48] <p6eval> rakudo a26956: OUTPUT¬´#<failed match>‚ê§¬ª

[02:48] <flussence> bah.

[02:48] <flussence> r: say q{'\\ \n'} ~~ / "'" ~ "'" [ '\\' . | . ] /;

[02:48] <p6eval> rakudo a26956: OUTPUT¬´Unable to parse expression in ; couldn't find final "'"‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1038‚ê§  in regex  at /tmp/oYbcitYAUY:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10731‚ê§  in block  at /tmp/oYbcitYAUY:1‚ê§‚ê§¬ª

[02:49] <swarles> r: "'hello \''" ~~ /"'"[<!['\\]>|"\\".]*"'"/

[02:49] <p6eval> rakudo a26956:  ( no output )

[02:49] <swarles> r: say "'hello \''" ~~ /"'"[<!['\\]>|"\\".]*"'"/

[02:49] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢''ÔΩ£‚ê§‚ê§¬ª

[02:52] <timotimo> the <!['\\]>|"\\".]* is skipping "hello" completely

[02:53] *** FROGGS_ joined
[02:53] <timotimo> i made an endless recursion i think

[02:53] <timotimo> r: say "'hello \''" ~~ /"'"[<![a..z A..Z]>|"\\".]*"'"/

[02:54] <p6eval> rakudo a26956: OUTPUT¬´(timeout)¬ª

[02:54] *** swarles left
[02:55] <timotimo> i don't know anything about perl6 regex syntax :|

[02:55] <flussence> okay, I think I'm going insane here... I'm getting an error that makes no sense

[02:55] <flussence> r: say q{'quoted string'} ~~ / "'" ~ "'" /

[02:55] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter ~ (must be quoted to match literally)‚ê§at /tmp/YcF8pog68P:1‚ê§------> [32msay q{'quoted string'} ~~ / "'" ~ "'" [33m‚èè[31m/[0m‚ê§Unable to parse regex; couldn't find final '/'‚ê§at /tmp/YcF8pog68P:1‚ê§------‚Ä¶

[02:56] <flussence> r: say q{'quoted string'} ~~ / "'" ~ "'" .* /

[02:56] <p6eval> rakudo a26956: OUTPUT¬´Unable to parse expression in ; couldn't find final "'"‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1038‚ê§  in regex  at /tmp/e5srqWSbow:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10731‚ê§  in block  at /tmp/e5srqWSbow:1‚ê§‚ê§¬ª

[02:56] <flussence> oh, that... doesn't make much more sense.

[02:57] <flussence> LTA on the first one though

[02:57] *** FROGGS left
[02:58] <benabik> LTA error on both, I think.

[02:59] <benabik> Well, especially since the second should succeed?

[02:59] <flussence> yeah... looks okay to me :/

[02:59] <benabik> NYI?

[02:59] <flussence> r: say q{'quoted string'} ~~ / \' ~ \' .* /

[02:59] <p6eval> rakudo a26956: OUTPUT¬´Unable to parse expression in ; couldn't find final \'‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1038‚ê§  in regex  at /tmp/lO60T6RbMC:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10731‚ê§  in block  at /tmp/lO60T6RbMC:1‚ê§‚ê§¬ª

[03:00] <flussence> don't think it's NYI; it was definitelyI last time I tried doing anything with it...

[03:01] <benabik> NLI, then, I guess.  ;-)

[03:03] <flussence> star: use JSON::Tiny; say from-json('{ "a": "abc\n" }')

[03:03] <p6eval> star 2012.12: OUTPUT¬´("a" => "abc\n").hash‚ê§¬ª

[03:03] <flussence> well that works fine...

[03:03] *** alec left
[03:04] <flussence> locally too...

[03:04] *** alec__ joined
[03:04] *** Swarley_ joined
[03:04] <benabik> star: say q{'quoted string'} ~~ / \' ~ \' .* /

[03:04] <p6eval> star 2012.12: OUTPUT¬´Unable to parse expression in ; couldn't find final \'‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1038‚ê§  in regex  at /tmp/40ecDBnVwk:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10531‚ê§  in block  at /tmp/40ecDBnVwk:1‚ê§‚ê§¬ª

[03:04] <benabik> huh.

[03:04] <colomon> n: say q{'quoted string'} ~~ / \' ~ \' .* /

[03:04] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´Unhandled exception: Unable to parse anonymous regex‚ê§Couldn't find final "'"; gave up‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1435 (die @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2753 (Cursor.FAILGOAL @ 6) ‚ê§  at /tmp/GYCdl2xWlq line 1 (ANO‚Ä¶

[03:05] <timotimo> what's the ~ syntax for?

[03:05] *** alec__ is now known as alec

[03:05] <flussence> S05:859

[03:05] *** dayangkun joined
[03:05] <timotimo> you're fast!

[03:05] <flussence> had it open that time :)

[03:05] <benabik> timotimo: / \' ~ \' .* /   is about the same as   / \' .* \' /   (the former can give better errors)

[03:06] <timotimo> oh, that's cute!

[03:06] <flussence> r: say q{'quoted string'} ~~ / \' ~ \' <-[']>* /

[03:06] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢'quoted string'ÔΩ£‚ê§‚ê§¬ª

[03:06] <flussence> there we go... user error :)

[03:06] <benabik> And I guess it backtracks differently.

[03:07] <timotimo>  <-[') looks funny. a bit like a duck's head

[03:08] <benabik> say 'quack!' ~~ / quack <-[']> /

[03:08] <benabik> r: say 'quack!' ~~ / quack <-[']> /

[03:08] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢quack!ÔΩ£‚ê§‚ê§¬ª

[03:08] <timotimo> ah, -[...] is an inverted character class

[03:08] <flussence> .oO( duck-typed regex )

[03:09] <flussence> still, I'd have imagined there to be an easier way to write what that's supposed to mean...

[03:10] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' <-['] | \\\' >* /

[03:10] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§regex assertion not terminated by angle bracket‚ê§at /tmp/DdPNOOHDSG:1‚ê§------> [32m'quoted \'string\''} ~~ / \' ~ \' <-['] [33m‚èè[31m| \\\' >* /[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopp‚Ä¶

[03:11] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' <-['] | "\'" >* /

[03:11] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§regex assertion not terminated by angle bracket‚ê§at /tmp/1NlvJu0UFm:1‚ê§------> [32m'quoted \'string\''} ~~ / \' ~ \' <-['] [33m‚èè[31m| "\'" >* /[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopp‚Ä¶

[03:11] <timotimo> er

[03:11] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' < <-[']> | <"\'"> >* /

[03:11] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quote words construct too complex to use in a regex‚ê§at /tmp/rGov6VfLjg:1‚ê§------> [32ming\''} ~~ / \' ~ \' < <-[']> | <"\'"> >[33m‚èè[31m* /[0m‚ê§¬ª

[03:11] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' < <-[']> | < \\\' > >* /

[03:11] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quote words construct too complex to use in a regex‚ê§at /tmp/r7R0whY_PJ:1‚ê§------> [32mg\''} ~~ / \' ~ \' < <-[']> | < \\\' > >[33m‚èè[31m* /[0m‚ê§¬ª

[03:11] <timotimo> i don't even know what i'm doing

[03:11] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' < <-[']> | \\\' >* /

[03:11] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quote words construct too complex to use in a regex‚ê§at /tmp/eo4YgNEFC8:1‚ê§------> [32mtring\''} ~~ / \' ~ \' < <-[']> | \\\' >[33m‚èè[31m* /[0m‚ê§¬ª

[03:11] <flussence> I think you meant [...]*

[03:12] <timotimo> so [...]* is not only for character classes?

[03:12] <timotimo> r: say q{'quoted \'string\''} ~~ / \' ~ \' [<-[']> | \\\']* /

[03:12] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢'quoted \'string\''ÔΩ£‚ê§‚ê§¬ª

[03:12] <benabik> <[ ]> is a character class.  [ ] is a non-capturing group

[03:12] <flussence> <[...]> is a character class

[03:12] <flussence> <...> in general means "weird thing here"

[03:12] <timotimo> what's the new meaning of ( ... )?

[03:12] <flussence> ( ... )

[03:12] <timotimo> "regular thing here"? "precedence clarification for you"?

[03:13] <timotimo> oh, so it matches literal braces?

[03:13] <flussence> no, it does the same as p5

[03:13] <benabik> It's a capturing group.

[03:13] <timotimo> ah. ( ) capturing group, [ ] non capturing group

[03:13] <timotimo> kind of like bars in a prison window

[03:13] <timotimo> if they're ( ), they'll still capture

[03:13] <timotimo> but if you bend them to look like [ ] you can escape

[03:14] <flussence> (?:people didn't like writing this all the time)

[03:14] <timotimo> i can see why

[03:16] <timotimo> hm. are perl6 regexes implemented as a grammar?

[03:16] <benabik> In that perl6 is implemented with grammars, yes.

[03:17] <timotimo> that breaks my head very slightly

[03:17] <benabik> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.pm

[03:18] *** Khisanth left
[03:18] <timotimo> may be too many meta-layers for this late time

[03:18] <benabik> Grammars are made of rules, not the other way around.

[03:19] <flussence> if you want to be horrified, there's also a grammar engine written entirely in perl6

[03:19] <timotimo> is that the glacier thingie?

[03:19] <flussence> yep

[03:19] <timotimo> glacier grammar engine i think

[03:21] <timotimo> why are there babble, quibble and nibble? where did those names come from? :D

[03:21] *** adu joined
[03:25] <sorear> The warped and twisted mind of TimToady, I think.

[03:27] *** donghongbo left
[03:32] *** Khisanth joined
[03:35] *** orafu left
[03:35] *** orafu joined
[03:41] *** s1n joined
[03:52] <Swarley_> r: "49494_4949" ~~ /[<[0..9]>|_<!before _>]*/

[03:52] <p6eval> rakudo a26956:  ( no output )

[03:52] <Swarley_> r: say "49494_4949" ~~ /[<[0..9]>|_<!before _>]*/

[03:52] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢49494_4949ÔΩ£‚ê§‚ê§¬ª

[03:52] <Swarley_> r: say "49494__4949" ~~ /[<[0..9]>|_<!before _>]*/

[03:52] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢49494ÔΩ£‚ê§‚ê§¬ª

[03:57] <timotimo> fwiw, the % operator is perhaps one of the greatest inventions in perl6 regex. feel free to amaze me further with other things

[04:05] *** atrodo left
[04:19] *** preflex left
[04:20] *** adu left
[04:20] *** preflex_ joined
[04:21] *** preflex_ is now known as preflex

[04:40] *** skids left
[04:59] *** kaleem joined
[05:08] *** jaldhar left
[05:11] *** kaleem left
[05:35] *** Swarley_ left
[05:48] *** fhelmberger joined
[05:51] *** erkan joined
[06:05] *** thou joined
[06:07] *** thou left
[06:12] *** SamuraiJack joined
[06:15] <lue> r: say "abc" ~~ /<!digit>+/

[06:15] <p6eval> rakudo a26956: OUTPUT¬´(timeout)¬ª

[06:16] <lue> oh, that thing.

[06:16] <lue> r: say "abc" ~~ /<!digit>/

[06:16] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢ÔΩ£‚ê§‚ê§¬ª

[06:16] <lue> r: say "abc" ~~ /<-digit>/

[06:16] <p6eval> rakudo a26956: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§‚ê§¬ª

[06:24] *** slavik1 left
[06:31] *** slavik1 joined
[06:41] *** sizz left
[06:44] *** kaleem joined
[06:45] *** sizz joined
[06:53] *** crazedpsyc joined
[06:59] *** sizz left
[07:14] *** quester joined
[07:32] *** FROGGS_ left
[07:47] *** vividsnow joined
[07:50] *** ermlich left
[07:54] *** vividsnow left
[08:04] *** quester left
[08:08] <BooK> masak: looking

[08:09] *** kaleem left
[08:10] *** vividsnow joined
[08:11] *** FROGGS joined
[08:11] <BooK> masak: some reference for the players: http://philippe.bruhat.net/stuff/git-fractals/

[08:12] <jnthn> morning, #perl6

[08:15] <moritz> \o

[08:20] <FROGGS> morning

[08:20] <jnthn> hi moritz, FROGGS 

[08:21] * jnthn waits patiently for his class to all show up :)

[08:21] * FROGGS .oO( glass? )

[08:23] <jnthn> :P

[08:24] <jnthn> no, sadly this is work, not drinking :)

[08:24] <jnthn> nice work though :)

[08:24] <arnsholt> o/

[08:25] <jnthn> o/ arnsholt 

[08:25] * arnsholt is preparing for his class

[08:25] <jnthn> :)

[08:25] <arnsholt> Teaching Python

[08:25] <jnthn> Advanced c# here 

[08:27] <sorear> o/

[08:27] <FROGGS> hi sorear 

[08:30] <sorear> hi FROGGS 

[08:30] <jnthn> o/ sorear 

[08:31] <FROGGS> jnthn: btw, I'm up to fixing:

[08:31] <FROGGS> rn: my $s = "abc"; say $s ~~ s[x] = "y"

[08:32] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´False‚ê§¬ª

[08:32] <p6eval> ..rakudo a26956: OUTPUT¬´True‚ê§¬ª

[08:32] <jnthn> ++FROGGS

[08:33] <FROGGS> I'm in the make_smartmatch in the Actions.pm, the ~$/[1] is 's[x] = "y"', how do I proper check for the quote:sym<s> here?

[08:33] <FROGGS> $/[1]<sym> is empty

[08:33] <jnthn> um, I'd have to look and gotta teach now, sorry

[08:34] * jnthn bbiab

[08:36] <FROGGS> ya, no hurry

[08:36] <FROGGS> just wanted to ask so I dont forget

[08:37] *** hoelzro|away is now known as hoelzro

[08:38] <moritz> FROGGS: maybe the easiest way is to tag the code as begin a substitution in method quote:sym<s> in Actions

[08:38] <moritz> e.g. something like  $past<is_subst> := 1;

[08:38] <moritz> and then check that flag in make_smartmatch

[08:39] *** MikeFair_ left
[08:39] <FROGGS> moritz: cool! will try

[08:44] *** vividsnow left
[09:01] *** kaleem joined
[09:03] *** sqirrel joined
[09:05] *** kresike joined
[09:06] <kresike> hello all you happy perl6 people

[09:06] <tadzik> hello hello

[09:06] <kresike> tadzik, o/ ‚ò∫

[09:10] <moritz> it's Wednesday. That means: new episode of HPMoR podcast, new podcastle episode \o/

[09:13] <tadzik> and another 2 exams to pass! \o/

[09:13] <tadzik> and then I'm free until monday

[09:13] <moritz> tadzik: good luck then!

[09:14] <tadzik> thanks, that'll come in handy :)

[09:14] *** alec left
[09:16] <FROGGS> moritz: HPMoR?

[09:21] <moritz> FROGGS: http://hpmor.com/

[09:21] <FROGGS> cool

[09:28] *** alec joined
[09:42] *** dakkar joined
[09:42] *** snearch joined
[09:43] *** Psyche^ joined
[09:46] *** snearch left
[09:46] *** Patterner left
[09:46] *** Psyche^ is now known as Patterner

[09:49] <jnthn> tadzik: good luck with exams :)

[09:53] *** dayangkun left
[10:04] *** snearch joined
[10:04] *** hypolin left
[10:06] <sjn> moritz: love the HPMOR podcast :)

[10:06] *** dayangkun joined
[10:07] *** dayangkun left
[10:08] *** dayangkun joined
[10:18] <masak> BooK: well, I believe I have solved the merge point problem once and for all. I will blog about it, explaining it in detail.

[10:18] *** snearch left
[10:23] *** b1rkh0ff joined
[10:32] <BooK> masak: cool. I'll link your post from the git-fractals page :-)

[10:32] <masak> something is rotten in the state of state.

[10:32] <masak> nr: sub f { say ++state $ ; }; f; f; f

[10:32] <p6eval> rakudo a26956: OUTPUT¬´1‚ê§1‚ê§1‚ê§¬ª

[10:32] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[10:32] * masak submits rakuobug

[10:32] <masak> what's worse:

[10:32] <masak> nr: sub f { say ++(state $ = 0); }; f; f; f

[10:32] <p6eval> rakudo a26956: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block f: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while compili‚Ä¶

[10:32] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[10:32] <masak> BooK: I will probably not have the focus and tuits to blog until Friday.

[10:33] <masak> BooK: after solving the problem, I had to tear myself from the screen and go to bed. for 30 minutes, my brain helpfully suggested improvements to the code instead of going to sleep. I'm not incorporating those improvements.

[10:44] <tadzik> oooh yeaah

[10:45] <tadzik> that feeling to be a part of 36% of people who passed monday's murderer-exam :)

[10:46] <BooK> usually, a good night of sleep lets the ideas sediment well, and the code flows better in the morning

[10:47] <masak> tadzik: I didn't realize your major was murder.

[10:47] <masak> BooK: yeah, but here it was more a matter of the hands leaving the keyboard, but the brain keeping at it :)

[10:47] <masak> (so far, all of the feverish brain optimization seem to hold up) :P

[10:48] <masak> I just eliminated the higher-order function, and stuff still works.

[10:48] <tadzik> masak: yeah, if I only knew... ;)

[10:48] <masak> now to eliminate all if statements.

[11:00] <masak> here, this sierpinski looks not so bad: https://gist.github.com/4600143

[11:00] <masak> removing all the comments actually makes the code fit on one screen :)

[11:00] <jnthn> masak: odd bug. wonder if it relates to my fixing the over-sharing bug.

[11:00] <jnthn> If so, it means we're missign some test coverage...

[11:00] <masak> yah.

[11:01] * jnthn is surprised we'd be missing it for anon state vars

[11:01] <masak> yes.

[11:01] <masak> me too.

[11:01] <masak> jnthn: when did you fix? I'd like to bisect.

[11:01] <jnthn> Not sure, recently

[11:01] <jnthn> It was the bug when my @ and a later my @ would share the value

[11:01] *** sivoais left
[11:01] <jnthn> I think the commit message said "over-sharing"

[11:02] <jnthn> don't have a repo here

[11:02] * masak goes looking

[11:03] <masak> 'Fix (my %) over-sharing.', perhaps?

[11:03] <masak> 2013-01-12.

[11:03] <masak> https://github.com/rakudo/rakudo/commit/bd9bc6ff017a78783a039282ae9e36f974af3d8a

[11:06] *** Su-Shee_ joined
[11:06] *** Su-Shee left
[11:06] *** Su-Shee_ is now known as Su-Shee

[11:07] *** dayangkun left
[11:13] <masak> jnthn: confirmed #1: in bd9bc6f^, 'state' works.

[11:19] <masak> jnthn: confirmed #2: in bd9bc6f, 'state' is b0rken.

[11:19] * masak adds this to the RT ticket

[11:24] <moritz> masak: re ticket subject, state + anon variable is broken

[11:24] <moritz> seems that state + named variables is just fine

[11:24] <moritz> otherwise we'd notice the test fallout

[11:25] <masak> oh!

[11:25] <masak> moritz: yes, that explains how this snuck under the radar.

[11:25] <masak> thing is, 'state $' is quickly establishing itself as a pattern.

[11:25] <moritz> nr: sub f { say ++state $a ; }; f; f; f # OK not used

[11:25] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/RxlEi_cDOk line 1:‚ê§------> [32msub f { say ++state [33m‚èè[31m$a ; }; f; f; f # OK not used[0m‚ê§‚ê§1‚ê§2‚ê§3‚ê§¬ª

[11:25] <p6eval> ..rakudo a26956: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[11:26] <masak> actually, there are two things I'd like to talk about there.

[11:26] <moritz> I'm not trying to downplay the problem, just narrowing it down

[11:26] <masak> r: sub f { say (state $)++ }; f; f; f

[11:26] <p6eval> rakudo a26956: OUTPUT¬´0‚ê§0‚ê§0‚ê§¬ª

[11:26] <masak> r: sub f { say ++state $; }; f; f; f

[11:26] <p6eval> rakudo a26956: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes‚ê§at /tmp/RIi6jfh778:1‚ê§------> [32msub f { say ++state $;[33m‚èè[31m }; f; f; f[0m‚ê§¬ª

[11:26] <masak> ah, there we go.

[11:27] <moritz> r: sub f { say ++state $ }; f; f; f

[11:27] <p6eval> rakudo a26956: OUTPUT¬´1‚ê§1‚ê§1‚ê§¬ª

[11:27] <masak> maybe there's nothing to be done about that, but I'm pretty sure I didn't mean '$;' the obsolete variable :P

[11:27] <moritz> std: ++ state $;

[11:27] <p6eval> std 7deb9d7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes at /tmp/3b6x5c9dzG line 1:‚ê§------> [32m++ state $;[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:00 41m‚ê§¬ª

[11:28] <moritz> well, one could always remove that case of obsoletion warning

[11:29] <masak> depends how strict is the rule of "sigil + punctuation mark always makes a variable, no matter how unsupported".

[11:42] <masak> &

[11:44] *** MayDaniel joined
[12:05] *** hoelzro is now known as hoelzro|away

[12:05] <dalek> rakudo/nom: 388c1bb | (Tobias Leich)++ | src/Perl6/Actions.pm:

[12:05] <dalek> rakudo/nom: proper return value for smartmatching against a substitution

[12:05] <dalek> rakudo/nom: 

[12:05] <dalek> rakudo/nom: We will return True if there was a match, otherwise False.

[12:05] <dalek> rakudo/nom: If the rhs is not a substitution, we still will call ACCEPTS

[12:05] <dalek> rakudo/nom: and return its result.

[12:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/388c1bbd38

[12:08] *** hoelzro|away is now known as hoelzro

[12:09] <dalek> roast: bd732d6 | (Tobias Leich)++ | S05-substitution/subst.t:

[12:09] <dalek> roast: no-match substitution returns false now

[12:09] <dalek> roast: review: https://github.com/perl6/roast/commit/bd732d6ae7

[12:10] <FROGGS> rn: my $s = "abc"; say $s ~~ s[x] = "y"

[12:10] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´False‚ê§¬ª

[12:10] <p6eval> ..rakudo a26956: OUTPUT¬´True‚ê§¬ª

[12:13] *** imyat joined
[12:14] <FROGGS> rn: my $s = "abc"; say $s ~~ s[x] = "y"

[12:14] <p6eval> rakudo 388c1b, niecza v24-18-gaf64300: OUTPUT¬´False‚ê§¬ª

[12:14] <FROGGS> rn: my $s = "abc"; say $s ~~ s[c] = "y"

[12:14] <p6eval> rakudo 388c1b, niecza v24-18-gaf64300: OUTPUT¬´True‚ê§¬ª

[12:14] <FROGGS> \o/

[12:24] *** vividsnow joined
[12:29] <masak> FROGGS++

[12:31] <FROGGS> rn: say ?(all() ~~ /^ \d+ $/)

[12:31] <p6eval> rakudo 388c1b: OUTPUT¬´False‚ê§¬ª

[12:31] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´True‚ê§¬ª

[12:31] <FROGGS> o.O

[12:32] <FROGGS> masak: which one is right?

[12:32] <FROGGS> niecza?

[12:33] <FROGGS> r: enum X <a b c>; say a ~~ Int; say True ~~ Int

[12:33] <p6eval> rakudo 388c1b: OUTPUT¬´True‚ê§False‚ê§¬ª

[12:33] <FROGGS> n: enum X <a b c>; say a ~~ Int; say True ~~ Int

[12:34] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´True‚ê§True‚ê§¬ª

[12:34] <masak> FROGGS: rn: say ?all()

[12:34] <masak> rn: say ?all()

[12:34] <p6eval> rakudo 388c1b, niecza v24-18-gaf64300: OUTPUT¬´True‚ê§¬ª

[12:35] <moritz> niecza is right

[12:35] <FROGGS> ahh, is it the same bug?

[12:35] <masak> rn: say all() ~~ /^ \d+ $/

[12:35] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´all()‚ê§¬ª

[12:35] <p6eval> ..rakudo 388c1b: OUTPUT¬´#<failed match>‚ê§¬ª

[12:35] <masak> yes, Niecza++ is right.

[12:35] <moritz> I think it's a known bug that ~~ doesn't autothread in rakudo

[12:35] <masak> seems rakudo collapses the junc... right.

[12:37] <FROGGS> rn: say [] ... []

[12:37] <p6eval> rakudo 388c1b: OUTPUT¬´(timeout)¬ª

[12:37] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´‚ê§¬ª

[12:37] <moritz> rn: say [] ~~ []

[12:37] <p6eval> rakudo 388c1b, niecza v24-18-gaf64300: OUTPUT¬´True‚ê§¬ª

[12:38] <masak> TimToady: remember back when '$/' in regexes meant "the $/ variable", but then STD changed because of real-world November code?

[12:38] <masak> TimToady: well, this '++state $;' thing feels a bit like that. what do you think?

[12:45] *** dayangkun joined
[13:00] *** imyat left
[13:07] *** kaleem left
[13:12] <FROGGS> n: '12'.subst(/(.)(.)/,{$()*2})

[13:12] <p6eval> niecza v24-18-gaf64300:  ( no output )

[13:12] <FROGGS> n: say '12'.subst(/(.)(.)/,{$()*2})

[13:12] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§¬ª

[13:12] <FROGGS> n: say '12'.subst(/(.)(.)/,{$(0)*2})

[13:12] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´0‚ê§¬ª

[13:13] <FROGGS> n: say '12'.subst(/((.)(.))/,{$()*2})

[13:13] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§¬ª

[13:13] <FROGGS> n: say '12'.subst(/(..)/,{$()*2})

[13:13] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§¬ª

[13:13] <FROGGS> n: say '1a'.subst(/(.)(.)/,{$()*2})

[13:13] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´Unhandled exception: Cannot parse number: 1a‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1435 (die @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3539 (ANON @ 10) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3541 (NumSyntax.str2num @ 5) ‚ê§  at /‚Ä¶

[13:13] <FROGGS> n: say '1a'.subst(/(.)(.)/,{$0*2})

[13:13] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´2‚ê§¬ª

[13:14] <FROGGS> n: say '12'.subst(/../,{$()*2})

[13:14] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§¬ª

[13:14] <FROGGS> n: say '12'.subst(/../,{$/*2})

[13:14] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§¬ª

[13:14] <FROGGS> r: say '12'.subst(/../,{$/*2})

[13:14] <p6eval> rakudo 388c1b: OUTPUT¬´24‚ê§¬ª

[13:14] <FROGGS> so $() is the same as $/, right?

[13:14] <FROGGS> r: say '12'.subst(/../,{$/*2}); say $()

[13:14] <p6eval> rakudo 388c1b: OUTPUT¬´24‚ê§‚ê§¬ª

[13:15] <FROGGS> n: say '12'.subst(/../,{$/*2}); say $()

[13:15] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´24‚ê§Unhandled exception: Unable to resolve method ast in type Any‚ê§  at /tmp/X1nre_sWh0 line 1 (mainline @ 6) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4219 (module-CORE @ 580) ‚ê§  at /home‚Ä¶

[13:15] <FROGGS> ... inside that closure

[13:17] <moritz> $() can also involved $/.ast somehow

[13:17] <moritz> it's in the specs somewhere

[13:19] <masak> S05:2883

[13:19] <masak> $($/.ast // ~$/)

[13:22] <FROGGS> interesting

[13:24] * moritz increases percentual test coverage at $work by deleting unused library functions

[13:24] <FROGGS> cheater!

[13:25] <jnthn> Deleting dead code isn't cheating :)

[13:25] <jnthn> There's plenty of reasons to do it besides "increase test coverage" though :)

[13:25] <masak> no, it's admirable.

[13:26] <masak> well, if the test coverage was the thing that discovered that the library functions were unused, then that's a good thing.

[13:26] *** kaleem joined
[13:26] <moritz> FROGGS: cheating is technique! :-)

[13:26] <FROGGS> that's my job too

[13:27] * FROGGS is calculating fees for 400 employees

[13:28] <Su-Shee> FROGGS: 401.. ;) my account number is.. ;)

[13:28] <FROGGS> ENOSUCHNUMBER

[13:28] <FROGGS> ;o)

[13:29] <FROGGS> r: $() = 42; say $()

[13:29] <p6eval> rakudo 388c1b: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in block  at /tmp/zoA_h1D1U5:1‚ê§‚ê§¬ª

[13:29] <FROGGS> r: $/ = 42; say $/

[13:29] <p6eval> rakudo 388c1b: OUTPUT¬´42‚ê§¬ª

[13:33] <moritz> $() isn't really a variale

[13:33] <moritz> it's more like a call

[13:35] <FROGGS> I try to find the code where that happens, but it looks like SciTE doesnt like dollars in search strings...

[13:35] <FROGGS> will grep for it

[13:35] <masak> r: $/ = (class { has $.ast is rw }).new; $() = 42; say "alive"

[13:35] <p6eval> rakudo 388c1b: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in block  at /tmp/lGRykrJX92:1‚ê§‚ê§¬ª

[13:36] <FROGGS> say $().WHAT

[13:36] <FROGGS> r: say $().WHAT

[13:36] <p6eval> rakudo 388c1b: OUTPUT¬´Parcel()‚ê§¬ª

[13:41] *** b1rkh0ff left
[13:55] *** b1rkh0ff joined
[13:59] *** vividsnow left
[14:01] *** hash_table joined
[14:01] <FROGGS> can you guide me where $() is declared?

[14:02] <tadzik> it's not a variable. It's just nothing in item context, methinks

[14:03] <tadzik> r: say $(5).WHAT

[14:03] <p6eval> rakudo 388c1b: OUTPUT¬´Int()‚ê§¬ª

[14:03] <tadzik> r: say $(Nil).WHAT

[14:03] <moritz> aye

[14:03] <p6eval> rakudo 388c1b: OUTPUT¬´Nil‚ê§¬ª

[14:03] <moritz> it's the same as (...).item

[14:03] <moritz> r: .say for $(1, 2, 3)

[14:03] <p6eval> rakudo 388c1b: OUTPUT¬´1 2 3‚ê§¬ª

[14:03] <moritz> only one iteration

[14:03] <FROGGS> right, so if there is no param it should give us $/.ast // ~$/

[14:04] * [Coke] shudders at the new list model.

[14:04] * [Coke] hasn't internalized it yet, so I keep doing things wrong with it.

[14:05] <tadzik> [Coke]: look for pmichaud's talk about them, it really clears things up

[14:05] <masak> [Coke]: I've been bitten by it too. I'd like to hear what trips you up.

[14:05] <masak> r: say <a b c d>.kv.reverse.perl

[14:05] <p6eval> rakudo 388c1b: OUTPUT¬´((3, "d"), (2, "c"), (1, "b"), (0, "a")).list‚ê§¬ª

[14:05] <masak> I'd really expect that to flatten.

[14:05] <masak> r: say <a b c d>.kv.flat.reverse.perl

[14:05] <p6eval> rakudo 388c1b: OUTPUT¬´("d", 3, "c", 2, "b", 1, "a", 0).list‚ê§¬ª

[14:05] <moritz> i guess it should

[14:06] * masak submits rakudobug

[14:06] <tadzik> wait, wfhy

[14:06] <tadzik> why do you expect a list of pairs to flatten?

[14:06] <masak> they're not pairs.

[14:06] <moritz> problem is, many of the methods were written by folk (including me) that didn't really understand the list model back then

[14:06] <masak> => makes pairs.

[14:06] <[Coke]> masak: mainly that sometimes I have to call .list when I'm really not expecting it. (bit me more than once on p6cc2012)

[14:06] <moritz> tadzik: .kv != .pairs

[14:06] <masak> this is just sublists.

[14:06] <tadzik> oh hm]

[14:06] <tadzik> sublists, not subarrays, aye?

[14:06] <masak> [Coke]: oh, that one I've internalized.

[14:07] <masak> [Coke]: basically when you get something out of a container, you might have to do that.

[14:07] <[Coke]> MIGHT?!? ;)

[14:07] *** hash_table left
[14:07] <tadzik> it's just that it's hard to predict until you run the code

[14:07] <tadzik> which is, what [Coke] said

[14:07] *** atrodo joined
[14:07] <masak> yeah, there should be a hard-and-fast rule.

[14:07] <masak> tadzik: yes, sublists, not subarrays.

[14:08] <tadzik> I see

[14:08] <tadzik> but honestly, I don't mind them in item context :)

[14:08] <tadzik> you can always call flat. If you don't want that, you can't call un-flat

[14:08] <[Coke]> I have a thing with a Str method. I have a @ of things. Is there a way to pretty print any array of things without having to make an explicit class? 

[14:09] * tadzik leaves to learn for the last-ish remaining exam

[14:09] *** PacoAir joined
[14:10] * [Coke] ponders a role.

[14:10] <moritz> [Coke]: say join ' ', @array.map: &pretty

[14:10] <masak> tadzik: yes, you can always call flat. but my expectation is that .kv gives me a flat list already. and then I'm surprised when .reverse reverses things pairwise.

[14:10] <moritz> and then a  multi pretty(YourType $x) { ... }

[14:11] <moritz> masak: it's right for .kv to give you a nested list, but .reverse should flatten

[14:11] <[Coke]> moritz: my $hand = .... but purty; where purty is my pretty printer. WFM.

[14:11] <masak> right.

[14:11] *** sivoais joined
[14:13] *** vividsnow joined
[14:16] <masak> (though I'm not 100% swayed by sublists yet. they haven't carried their weight so far in code I've written.)

[14:17] <[Coke]> r: // this is a bad comment.

[14:17] <p6eval> rakudo 388c1b: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/7JOja00g5Y:1‚ê§------> [32m//[33m‚èè[31m this is a bad comment.[0m‚ê§¬ª

[14:18] <[Coke]> r: // this is a bad comment.‚ê§say "hi"

[14:18] <p6eval> rakudo 388c1b: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null regex not allowed‚ê§at /tmp/6TYav28cEi:1‚ê§------> [32m//[33m‚èè[31m this is a bad comment.[0m‚ê§¬ª

[14:18] <[Coke]> I was getting an error on the . for string concat. arglebargle

[14:20] <FROGGS> r: 1 // this is a bad comment.‚ê§say "hi"

[14:20] <p6eval> rakudo 388c1b: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of . to concatenate strings; in Perl 6 please use ~‚ê§at /tmp/LFApPPwQdr:2‚ê§------> [32m<BOL>[33m‚èè[31msay "hi"[0m‚ê§¬ª

[14:22] *** bluescreen10 joined
[14:22] <[Coke]> Yes, that. :)

[14:23] <GlitchMr> http://docs.python.org/3.4/library/itertools.html

[14:23] <GlitchMr> accumulate(data, max)

[14:23] <GlitchMr> [\max] @data

[14:23] <[Coke]> so, if I have a $foo that contains a listy thing, and I want to have a role that operates on that, how can I refer to the thing itself in the role? "self" seems to be a Mu when I call it.

[14:23] <GlitchMr> So, Python has function for that and Perl 6 has operator for that.

[14:23] <masak> GlitchMr: quite a common situation.

[14:24] <pmichaud> Re   #116525    I'd be a little surprised if .kv returned a flat list.

[14:24] <masak> pmichaud: yes, and I'm not saying it should.

[14:25] <masak> I'm saying my expectation is that reverse should be reversing the keys and values.

[14:25] <pmichaud> I'm responding to...

[14:25] <pmichaud> 14:10 <masak> tadzik: yes, you can always call flat. but my expectation is that .kv gives me a flat list already. and then I'm surprised when  .reverse reverses things pairwise.

[14:26] <masak> yes, that was hastily worded, sorry.

[14:26] <pmichaud> okay, just checking

[14:26] <pmichaud> and obtw,  good morning #perl6

[14:26] <masak> .kv is free to do funny things with sublists if it wants.

[14:26] <masak> pmichaud! \o/

[14:26] <pmichaud> I'm only here for a couple of minutes, sadly

[14:26] <pmichaud> but as you can see, I do still follow things :)

[14:26] <masak> pmichaud: my point is more, if I want nothing to do with sublists, .reverse should make them invisible to me.

[14:27] <timotimo> hello butterfly friends

[14:27] <masak> pmichaud: whether it does this by flattening the sublists, or recursively reversing them, I don't really care.

[14:27] <masak> timotimo! \o/

[14:27] <pmichaud> masak: I'd expect reverse to act similarly to .sort, .join, etc.

[14:27] <masak> aye.

[14:27] <pmichaud> so if those flatten, then .reverse should flatten too

[14:27] <pmichaud> if they don't, it shouldn't

[14:28] <moritz> r: say (<b a>, <c d>).sort

[14:28] <p6eval> rakudo 388c1b: OUTPUT¬´b a c d‚ê§¬ª

[14:28] <masak> r: role Lolly { method foo { say "lol, I am a {self.^name}" } }; my $array = [1, 2, 3] but Lolly; say $array.foo

[14:28] <p6eval> rakudo 388c1b: OUTPUT¬´lol, I am a Array+{Lolly}‚ê§True‚ê§¬ª

[14:28] <moritz> r: say (<b a>, <c d>).join('|')

[14:28] <p6eval> rakudo 388c1b: OUTPUT¬´b|a|c|d‚ê§¬ª

[14:28] <masak> [Coke]: ^^

[14:28] <moritz> join flattens, .sort doesn't

[14:28] <masak> :/

[14:28] <moritz> r: say (<b a>, <c d>).map: *.chars

[14:28] <p6eval> rakudo 388c1b: OUTPUT¬´1 1 1 1‚ê§¬ª

[14:28] <masak> where's the logic in that?

[14:28] <moritz> .map flattens

[14:28] <pmichaud> .map explicitly flattens, yes

[14:29] <pmichaud> but it might be a special case

[14:29] <masak> I think .sort should flatten, too.

[14:29] <pmichaud> r:  say (<b a>, <c d>).sort.perl

[14:29] <p6eval> rakudo 388c1b: OUTPUT¬´(("b", "a"), ("c", "d"))‚ê§¬ª

[14:29] <pmichaud> r:  say (<e a>, <c d>).sort.perl

[14:29] <p6eval> rakudo 388c1b: OUTPUT¬´(("c", "d"), ("e", "a"))‚ê§¬ª

[14:29] <pmichaud> (just checking)

[14:29] <pmichaud> I'll let you folks hash it out from here, then :)

[14:30] <masak> pmichaud: thanks! enjoy $elsewhere! :)

[14:30] *** bluescreen10 left
[14:30] *** bluescreen10 joined
[14:35] <[Coke]> masak;my thing turns out to be a List, not an array.

[14:37] *** kaare_ joined
[14:37] <masak> [Coke]: well, I don't know what a List is in Perl 6. so cannot help you there ;)

[14:38] <masak> I only know about Arrays, and I'm vaguely familiar with Parcels.

[14:39] <moritz> an Array is simply a List where all elements are scalar containers

[14:39] <moritz> so you can do basically anything with a List that you can do with an array, except assigning to an element

[14:40] <moritz> (unless that element happens to be a container)

[14:43] <[Coke]> bah. I will try to cut this down to a simple failing example after work.

[14:43] <masak> oh, right.

[14:43] <masak> Lists are part of the Big Container-based Type Duplication. now I remember.

[14:45] <[Coke]> r: role c {}; my @a = 1,2,3,4; my $b = @a.pick(2) but c; say $b.WHAT; say $b;

[14:45] <p6eval> rakudo 388c1b: OUTPUT¬´List+{c}()‚ê§elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:6099‚ê§  in method reify at src/gen/CORE.setting:5496‚ê§  in method reify at src/gen/CORE.setting:5483‚ê§  in method gimme at src/gen/CORE.setting:5873‚ê§  in method eager at src/‚Ä¶

[14:45] <masak> interestin'

[14:45] <[Coke]> or I could get lucky.

[14:46] <masak> r: my @a = 1,2,3,4; my $b = @a.pick(2); say $b.WHAT; say $b;

[14:46] <p6eval> rakudo 388c1b: OUTPUT¬´List()‚ê§2 1‚ê§¬ª

[14:46] * masak submits rakuodbug

[14:46] <[Coke]> \o/

[14:47] <colomon> n: my @a = 1,2,3,4; my $b = @a.pick(2); say $b.WHAT; say $b;

[14:47] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´List()‚ê§2 3‚ê§¬ª

[14:48] *** stopbit joined
[14:48] <moritz> [Coke]++ # golfing the example

[14:49] *** Timbus left
[14:50] *** Timbus joined
[14:52] *** skids joined
[14:53] <[Coke]> r: role c {}; my @a = 1,2,3,4; my $b = @a but c; say $b.WHAT; say $b;

[14:53] <p6eval> rakudo 388c1b: OUTPUT¬´Array+{c}()‚ê§elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:6099‚ê§  in method REIFY at src/gen/CORE.setting:6364‚ê§  in method reify at src/gen/CORE.setting:5496‚ê§  in method reify at src/gen/CORE.setting:5483‚ê§  in method gimme at src‚Ä¶

[14:55] <arnsholt> r: class A { }; say Array[A] ~~ Array[A];

[14:55] <p6eval> rakudo 388c1b: OUTPUT¬´False‚ê§¬ª

[14:56] <FROGGS> uhh

[14:56] <arnsholt> Yeah, it's wrong =)

[14:57] <FROGGS> r: say Array[Int] ~~ Array[Int];

[14:57] <p6eval> rakudo 388c1b: OUTPUT¬´False‚ê§¬ª

[14:57] <arnsholt> It's a long-standing issue. I was just wondering if anyone had fixed it while I wasn't paying attention

[14:57] <arnsholt> And it applies to all parametrized classes, AFAIK, not just arrays

[14:58] <FROGGS> there is already a ticket for it?

[14:58] <moritz> yes

[14:58] <moritz> from around 2012-04

[14:59] <FROGGS> ohh, will be its first birthday soon

[15:11] <masak> similarly, the oldest open ticket, https://rt.perl.org/rt3/Ticket/Display.html?id=61602 , turned 4 not long ago.

[15:11] *** vividsnow left
[15:16] <moritz> right. That one depends on a still-open specbug

[15:17] <masak> well, it's a tricky corner case. Inf, as spec'd, is part Int, part Num, part Str, part (perhaps?) arbitrary object. we have no mechanism within our type system to make a type like that.

[15:17] <masak> I don't suppose we could hand-hack Inf.ACCEPTS somehow?

[15:17] *** Timbus left
[15:17] *** ph1ur3 joined
[15:18] *** Timbus joined
[15:18] <masak> r: class MyInf { method ACCEPTS($o) { $o ~~ Int || $o ~~ Num || $o ~~ Str } }; say MyInf ~~ Int; say MyInf ~~ Str; say MyInf ~~ Num

[15:18] <p6eval> rakudo 388c1b: OUTPUT¬´False‚ê§False‚ê§False‚ê§¬ª

[15:18] <masak> hrm.

[15:18] <masak> r: class MyInf { method ACCEPTS($o) { $o ~~ Int || $o ~~ Num || $o ~~ Str } }; say MyInf.new ~~ Int; say MyInf.new ~~ Str; say MyInf.new ~~ Num

[15:19] <p6eval> rakudo 388c1b: OUTPUT¬´False‚ê§False‚ê§False‚ê§¬ª

[15:19] <masak> it is a sad world where an honest guy like me isn't even allowed to cheat the type hierarchy a little... :P

[15:19] <moritz> r: class  MyInf is Int is Str is Num { method Str { 'Inf' } }; say MyInf ~~ Str; say MyInf ~~ Num; say MyInf.new.Str

[15:19] <p6eval> rakudo 388c1b: OUTPUT¬´True‚ê§True‚ê§Inf‚ê§¬ª

[15:19] <[Coke]> r: say Int ~~ Int

[15:19] <p6eval> rakudo 388c1b: OUTPUT¬´True‚ê§¬ª

[15:20] <moritz> masak: well, you're cheating the wrong method :-)

[15:20] <moritz> MyInf ~~ Int calls Int.ACCEPTS

[15:21] <masak> d'oh!

[15:22] <masak> moritz: I like your approach, though. it's direct. and a little MI never killed anyone, right? :)

[15:23] <masak> (except I guess now Inf can't be stored in a pure Int container...)

[15:24] *** bbkr left
[15:24] <[Coke]> r: class MyInf is Int is Str; my Int $a = MyInf.new;

[15:24] <p6eval> rakudo 388c1b:  ( no output )

[15:24] <[Coke]> r: class MyInf is Int is Str {}; my Int $a = MyInf.new;

[15:24] <p6eval> rakudo 388c1b:  ( no output )

[15:24] <[Coke]> "seems legit."

[15:25] <masak> hm, I guess.

[15:25] <masak> because Int+Str <: Int

[15:25] <masak> well, then, gentlemen. that's our solution, then.

[15:27] *** autumn left
[15:28] *** autumn joined
[15:31] <moritz> but there's a certain cost attached to it

[15:32] <moritz> for every operation that could produce a Num, you have to check if it's Int/-Int/NaN, and if yes, typecast

[15:32] <moritz> oh, and you need a name for the type

[15:34] *** SunilJoshi joined
[15:35] <moritz> by the way we've closed several very old tickets during the last months

[15:37] *** hash_table joined
[15:39] *** kaleem left
[15:45] <FROGGS> since when? october? :o)

[15:46] <FROGGS> was timotimo and me AFAIK

[15:47] <timotimo> i did a few, yes

[15:47] <timotimo> jumped onto a few "closable with test" tickets and looked at a few tickets that had already been fixed by someone else, but not closed

[15:47] <FROGGS> thats what I did too

[15:53] <timotimo> is a QAST::Want for putting a few possible alternatives into the AST and later checking which one is the most sensible?

[15:54] <timotimo> later apparently still refering to compile-time

[15:54] <jnthn> Yeah

[15:54] *** vividsnow joined
[15:54] <jnthn> It's when you don't know that kinda context you'll be in.

[15:54] <timotimo> ah, like string/numeric/bool?

[15:55] <jnthn> int, str, num, object, void

[15:55] <jnthn> The primitive native types, object and void basically]

[15:55] <jnthn> Sink context jsut cares for void and whatever

[15:56] <jnthn> If you do 123 then we emit a QAST::Want so it can act as a native int or the appropraite boxed integer constant

[15:56] *** fgomez left
[15:56] <jnthn> my int $x = 123; # uses the int branch

[15:56] <timotimo> the qast pretty printer doesn't seem to show what type it would be for what alternative of the want

[15:56] <jnthn> my $x = 123; # uses the boxed branch

[15:57] <jnthn> Then, patch the QAST pretty printer ;)

[15:57] <timotimo> sounds like a plan

[15:57] <jnthn> I almost never use it, tbh.

[15:57] *** autumn left
[15:57] *** FROGGS left
[15:58] <timotimo> well, *you* already know all there is to know about QAST :)

[15:58] <timotimo> before i try to patch the pretty printer, i'll write a short bit on QAST::Want in the document about qast, though

[15:58] *** autumn joined
[16:00] <timotimo> oh, the list of subnodes is prioritized, too! interesting

[16:01] <timotimo> the compiler would be a tiny bit faster, if the want subnodes were iterated over in reverse order and upon finding the first match it would break - is that sensible?  https://github.com/perl6/nqp/blob/master/src/QAST/Compiler.nqp#L652

[16:03] <timotimo> i should write a want-heavy benchmark and see if it makes any difference whatsoever.

[16:03] *** vividsnow left
[16:03] <timotimo> oh, compiling rakudo should do decently. it's sufficiently long-running to make a difference noticable, although most of the time is spent in parsing, not in compiling

[16:04] *** autumn left
[16:05] *** snearch joined
[16:06] <timotimo> jnthn: how come 123 doesn't emit a node for bool or string context, for instance?

[16:06] *** FROGGS[mobile] joined
[16:06] <jnthn> there's no bool context

[16:06] <jnthn> this is a very low level, code-gen centric view of context

[16:06] <timotimo> ah

[16:06] *** vividsnow joined
[16:07] <jnthn> if you did the str then you'd make my str $x = 42; work.

[16:07] *** autumn joined
[16:07] <jnthn> Which it should not

[16:07] <timotimo> oh, that makes sense

[16:08] <dalek> nqp: 82c2a06 | timo++ | docs/qast.markdown:

[16:08] <dalek> nqp: wrote a bit of text about QAST::Want.

[16:08] <dalek> nqp: review: https://github.com/perl6/nqp/commit/82c2a06372

[16:09] <timotimo> oh, i have a commit bit?

[16:10] <moritz> nqp commit bits are handed out fairly liberally

[16:10] <FROGGS[mobile]> btw, I fixed the $() thingy, so you can do m/{ make ... }/ now

[16:10] <moritz> \o/

[16:11] <FROGGS[mobile]> need to walk home and spectest though

[16:11] <FROGGS[mobile]> damn cold

[16:11] <moritz> or push to a branch, so that I can spectest it

[16:11] * moritz has a fairly speedy machine at $work

[16:12] <FROGGS[mobile]> my laptop is turned of atm

[16:12] <timotimo> what is the $() thing?

[16:13] <FROGGS[mobile]> but will do in a minute

[16:13] <moritz> timotimo: that's been explained in the backlog

[16:13] <timotimo> i'll have a look

[16:14] <FROGGS[mobile]> timotimo: it can give you the ast of a match if there is one

[16:14] <FROGGS[mobile]> see the link to S05

[16:15] <timotimo> ah, it's group match reference syntax thingie??

[16:15] <kresike> bye folks

[16:15] *** kresike left
[16:16] <timotimo> ah, not quite

[16:17] <masak> today's mini-challenge: what's the diameter of the smallest circle that can contain 3 non-overlapping circles of diameter 1? if that is too easy, generalize from 3 to N.

[16:18] *** am0c joined
[16:19] *** thou joined
[16:19] <timotimo> hm, reminds me of the "appolonian" xscreensaver :)

[16:20] <timotimo> doesn't seem super hard. i'll draw something clever-looking on my whiteboard

[16:20] <moritz> generalize to N is hard

[16:20] <moritz> because for large enough N, you need to go to hexagonal packing

[16:20] <jnthn> hotel &

[16:21] <skids> And 3 is too easy.

[16:21] <moritz> whereas for N = 4, you need quadratic packing

[16:21] <timotimo> right

[16:21] <timotimo> yeah, the radius of such a containing circle would be (1/2 the height of an euqilateral triangle with side-length 2) + 1

[16:22] <nwc10> I'm not convinced about how you pack 4

[16:22] <skids> + 0.5, side length 1

[16:23] <skids> Anything other than a square packing increases the cross section along an axis.

[16:23] <timotimo> oh, yes, the small circles have *diameter* 1, i missed that detail

[16:24] <timotimo> i used unit circles, like i was taught over and over in school :P

[16:28] *** FROGGS joined
[16:29] *** FROGGS[mobile] left
[16:30] <masak> you're free to use unit circles. then you can either s:g/diameter/radius/ in the problem, or divide your final result by 2 :)

[16:32] <dalek> rakudo/match_shorthand: 1ed6e51 | (Tobias Leich)++ | src/Perl6/Actions.pm:

[16:32] <dalek> rakudo/match_shorthand: allow the use of $()

[16:32] <dalek> rakudo/match_shorthand: 

[16:32] <dalek> rakudo/match_shorthand: ... which is a shorthand for $($/.ast // ~$/).

[16:32] <dalek> rakudo/match_shorthand: review: https://github.com/rakudo/rakudo/commit/1ed6e51fab

[16:32] <FROGGS> moritz: ^^

[16:32] <masak> FROGGS++

[16:35] <GlitchMr> How can I cast to integer in Perl 6?

[16:35] <GlitchMr> I guess it's "Int($number)

[16:35] <GlitchMr> "

[16:35] <timotimo> r: say Int(99.234)

[16:35] <p6eval> rakudo 388c1b: OUTPUT¬´99‚ê§¬ª

[16:35] <timotimo> r: say Int(99.9999)

[16:35] <p6eval> rakudo 388c1b: OUTPUT¬´99‚ê§¬ª

[16:36] <timotimo> that seems to be it, yes

[16:36] <masak> oh look, there's a Wikipedia article: https://en.wikipedia.org/wiki/Circle_packing_in_a_circle

[16:36] <masak> r: say 9.9999.Int

[16:36] <p6eval> rakudo 388c1b: OUTPUT¬´9‚ê§¬ª

[16:36] <FROGGS> r: say Int(-5.5)

[16:36] <p6eval> rakudo 388c1b: OUTPUT¬´-5‚ê§¬ª

[16:36] <skids> r: say int(99.9)

[16:36] <p6eval> rakudo 388c1b: OUTPUT¬´invoke() not implemented in class 'int'‚ê§  in block  at /tmp/8njAgjOgE0:1‚ê§‚ê§¬ª

[16:37] <masak> r: say 1 + 2/3 * sqrt 3

[16:37] <p6eval> rakudo 388c1b: OUTPUT¬´2.15470053837925‚ê§¬ª

[16:37] <masak> this seems to be the answer. (since the Wikipedia page uses 'radius' in both places)

[16:37] *** snearch left
[16:37] * masak is dissapoint there isn't a diagram for the N=1 case ;)

[16:38] *** vividsnow left
[16:38] *** am0c left
[16:38] <FROGGS> masak: that page is editable ;o)

[16:38] <masak> o.O

[16:38] <masak> :P

[16:38] <masak> also, why is N=4 trivially optimal, but N=5 needed to be proven?

[16:38] *** am0c joined
[16:38] * [Coke] ‚ô•'s the "vack" bash function from the ack users list. (puts you into vim with matching files, priming the search criteria so you can quickly jump to the matches)

[16:39] <hoelzro> [Coke]: link, please?

[16:39] <GlitchMr> "if that is too easy, generalize from 3 to N"

[16:39] <masak> [Coke]: ooh!

[16:39] <GlitchMr> looks like this part is impossible

[16:39] <masak> GlitchMr: oh, I wouldn't go that far.

[16:39] <skids> Or at least, challenging enough that it requires mathemeticians.

[16:39] <masak> just really, really, really, really, really, really hard.

[16:39] *** PacoAir left
[16:40] <[Coke]> https://groups.google.com/forum/?hl=en&fromgroups=#!topic/ack-users/izsucbau1Z0

[16:40] <[Coke]> there's a sack and  vack in that thread.

[16:41] <hoelzro> ah

[16:41] * masak .oO( 'sack' opens up sed, right? )

[16:42] * geekosaur would settle for a generalized cscope :)

[16:42] <geekosaur> but, that's kinda a different thing

[16:42] <hoelzro> it would be nice if vack put the entries in the error listing

[16:44] <FROGGS> moritz: the TODO in S05-match/make.t and the skipped one in S05-substitution/subst.t passed

[16:46] *** hoelzro is now known as hoelzro|away

[16:47] <moritz> FROGGS: \o/

[16:49] <dalek> rakudo/nom: 1ed6e51 | (Tobias Leich)++ | src/Perl6/Actions.pm:

[16:49] <dalek> rakudo/nom: allow the use of $()

[16:49] <dalek> rakudo/nom: 

[16:49] <dalek> rakudo/nom: ... which is a shorthand for $($/.ast // ~$/).

[16:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1ed6e51fab

[16:51] <dalek> roast: 9508fb8 | (Tobias Leich)++ | S05- (2 files):

[16:51] <dalek> roast: $() support added

[16:51] <dalek> roast: review: https://github.com/perl6/roast/commit/9508fb8a3f

[16:52] *** spider-mario joined
[16:52] *** rindolf joined
[16:54] <skids> https://gist.github.com/4609751  # my mini-challenge

[16:56] <skids> Actually that's not very fair.  Back when I solved that problem it took me days.  But then, I don't have a full CS training so...

[16:56] *** fgomez joined
[17:00] <masak> "You have an unlimited supply of black and red checkers." -- \o/

[17:01] <masak> that's *awesome*!

[17:01] <skids> Imagine the possibilities.

[17:01] <masak> do I keep the red checkers apart from the black ones, in different storage rooms?

[17:01] <masak> do I have a limited amount of one of the colors? :P

[17:02] * masak gets a feeling he should read on

[17:02] <skids> You keep the black checkers in storage rooms made out of red checkers, and visa versa.  Of course.  :-)

[17:03] <masak> skids: I have only thought about the problem for 30 seconds, but... is there a state machine involved in your solution?

[17:03] <skids> It can be solved recursively.

[17:03] <masak> oooh

[17:04] <masak> so, let me get this straight, the algorithm finishes by outputting True (when two black checkers are side-by-side), or (having looked through both piles) outputting False?

[17:05] <skids> You shouldn't have to look through the piles, but yes.

[17:05] *** hds_w joined
[17:06] <masak> oh wait!

[17:06] <skids> And any number of black checkers side-by-side yields True.  Not restricted to one pair.

[17:06] <masak> I see now, there's really only those eight integers involved. they completely specify the problem.

[17:06] <skids> Yes.

[17:06] <masak> right. at least one pair.

[17:07] <masak> yes, now I definitely see how we can do better than O(min(@stack_heights)).

[17:07] <masak> I'd need to develop a few tests, but... this feels solvable now.

[17:07] <masak> skids++ # challenge

[17:09] <skids> Actually you should also be able to do in in less than O(min(M,P,M',P')).

[17:11] *** hds_w left
[17:11] <masak> can N or N' be 0?

[17:11] <masak> (I am assuming all the other parameters need to be at least 1)

[17:12] <skids> Well, those cases are all trivial.

[17:13] * masak takes that as a "no" :)

[17:16] <skids> Take it as a yes.

[17:18] *** Chillance joined
[17:18] <masak> ok.

[17:21] <FROGGS> r: "foo".match(/{ make "bar" }/); say $()

[17:21] <p6eval> rakudo 1ed6e5: OUTPUT¬´bar‚ê§¬ª

[17:22] <FROGGS> r: "foo".match(/( \w+ { make "bar" })/); say $/; say $()

[17:22] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢fooÔΩ£‚ê§ 0 => ÔΩ¢fooÔΩ£‚ê§‚ê§foo‚ê§¬ª

[17:22] <FROGGS> r: "foo".match(/( \w+ { make "bar" })/); say $/.ast; say $()

[17:22] <p6eval> rakudo 1ed6e5: OUTPUT¬´Any()‚ê§foo‚ê§¬ª

[17:22] <FROGGS> r: "foo".match(/{ make "bar" }/); say $/.ast; say $()

[17:22] <p6eval> rakudo 1ed6e5: OUTPUT¬´bar‚ê§bar‚ê§¬ª

[17:22] <FROGGS> k

[17:25] <timotimo> is that correct?

[17:28] <FROGGS> yes

[17:28] <FROGGS> r: "foo".match(/\w+/); say $/; say $()

[17:28] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢fooÔΩ£‚ê§‚ê§foo‚ê§¬ª

[17:29] <FROGGS> it is useful to create object out of matches within the regex

[17:29] <timotimo> why didn't \w+ { make "bar } actually result in bar at all?

[17:33] *** vividsnow joined
[17:34] <FROGGS> because $() defaults to the ast, which is { ... }

[17:35] <timotimo> i must have misread the spec then

[17:35] <FROGGS> read http://perlcabal.org/syn/S05.html#line_2883

[17:35] <FROGGS> ;o)

[17:40] *** slayer101_ joined
[17:40] <timotimo> oh, so in /( \w+ { make "bar" })/ the ast has the matching group as the topmost node and the "bar" is attached to it?

[17:41] <timotimo> how come its AST stringifies to Any()? i thought a type object is "null value"?

[17:45] *** PacoAir joined
[17:45] *** fgomez left
[17:46] <skids> "Any()" is a Nil (empty list) cast to the Any type.

[17:46] *** donaldh joined
[17:46] *** slayer101_ left
[17:47] <timotimo> there seems something totally obvious that i'm missing

[17:47] *** slayer101_ joined
[17:49] <masak> r: "foo".match(/( \w+ { make "bar" })/); say $/[0].ast

[17:49] <p6eval> rakudo 1ed6e5: OUTPUT¬´bar‚ê§¬ª

[17:49] <skids> What, about undefined values, or about the .ast Match member?

[17:53] <timotimo> the ast match member, yes

[18:00] *** grondilu joined
[18:00] *** donaldh left
[18:00] *** dakkar left
[18:03] *** SunilJoshi left
[18:09] *** PABPV07 joined
[18:12] *** blublue joined
[18:12] *** blublue left
[18:21] *** telex left
[18:23] *** telex joined
[18:28] <dalek> perl6-roast-data: d8eee6f | coke++ | / (4 files):

[18:28] <dalek> perl6-roast-data: today (automated commit)

[18:28] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d8eee6fb47

[18:28] <[Coke]> rakudo still failing S12-methods/syntax.rakudo

[18:33] *** GlitchMr left
[18:34] *** GlitchMr joined
[18:56] <FROGGS> [Coke]: rakudo passes on my box

[18:57] <FROGGS> [Coke]: but maybe due to the fact that I use nqp in NQP_REVISION, not HEAD

[18:58] <[Coke]> seems to work when run from the command line  in the same build that had the test failure.

[18:58] <[Coke]> I'm using whatever the recommended version is.

[18:58] * [Coke] leaves it alone for now.

[18:59] *** orafu left
[18:59] *** orafu joined
[19:06] *** slayer101_ left
[19:06] <FROGGS> weird

[19:07] *** slayer101_ joined
[19:11] <TimToady> GlitchMr: note that you might want .floor instead Int() if you don't wan truncation semantics

[19:12] <TimToady> *want

[19:12] <GlitchMr> Well, in that certain case I wanted to use it on value I already used abs() on.

[19:12] <GlitchMr> But I guess that floor is better

[19:19] *** fgomez joined
[19:22] *** brrt joined
[19:27] *** benabik left
[19:38] *** brrt left
[19:43] *** swarles joined
[19:43] *** brrt joined
[19:47] <swarles> r: sub foo { /bar/ }; "hello bar" ~~ /<foo>/

[19:47] <p6eval> rakudo 1ed6e5: OUTPUT¬´No such method 'foo' for invocant of type 'Cursor'‚ê§  in regex  at /tmp/waornf05RF:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10731‚ê§  in block  at /tmp/waornf05RF:1‚ê§‚ê§¬ª

[19:49] *** sftp left
[19:51] <swarles> Can anyone point me to a reference that better explains how to create something like <before foo>?

[19:51] <swarles> Or if someone could explain it to me, that would be nice as well

[19:51] *** fgomez left
[19:51] <timotimo> i broke QAST/Compiler.nqp and the qast test suite didn't explode. hum.

[19:52] *** sftp joined
[19:52] <timotimo> fortunately, the other "test suite" exploded whole-heartedly :)

[19:53] <TimToady> nr: my token foo { bar }; say "hello bar" ~~ <&foo>

[19:53] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´Potential difficulties:‚ê§  &foo is declared but not used at /tmp/0xL46LqN3Y line 1:‚ê§------> [32mmy token foo [33m‚èè[31m{ bar }; say "hello bar" ~~ <&foo>[0m‚ê§‚ê§False‚ê§¬ª

[19:53] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´False‚ê§¬ª

[19:53] *** brrt left
[19:54] <TimToady> nr: my token foo { bar }; say "hello bar" ~~ /<&foo>/

[19:54] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(6) to(9) text(bar) pos([].list) named({}.hash)>‚ê§¬ª

[19:54] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´ÔΩ¢barÔΩ£‚ê§‚ê§¬ª

[19:54] <TimToady> swarles: ^^

[19:54] <TimToady> to get rid of the & you'd have to put the token into a grammar

[19:54] <swarles> oh, well how can I make it accept arguments? Are they passed in $_ like perl 5?

[19:55] <FROGGS> nr: my token foo ($s) { $s }; say "hello bar" ~~ /<&foo: "bar">/

[19:55] <TimToady> nr: my token foo($arg) { $arg }; say "hello bar" ~~ /<&foo bar>/

[19:55] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§regex assertion not terminated by angle bracket‚ê§at /tmp/7BiSO5lSYW:1‚ê§------> [32mo ($s) { $s }; say "hello bar" ~~ /<&foo[33m‚èè[31m: "bar">/[0m‚ê§¬ª

[19:55] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´Unhandled exception: WTF in ANON‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/NieczaPassSimplifier.pm6 line 161 (run_optree @ 6) ‚ê§  at /home/p6eval/niecza/src/NieczaPassSimplifier.pm6 line 166 (run_optree‚Ä¶

[19:55] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse metachar:sym<< >> at /tmp/AQZifbKOQ7 line 1:‚ê§------> [32moo($arg) { $arg }; say "hello bar" ~~ /<[33m‚èè[31m&foo bar>/[0m‚ê§Couldn't find final '>'; gave up at /tmp/AQZifbKOQ7 line 1:‚ê§------> [32mrg) { $arg ‚Ä¶

[19:55] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§regex assertion not terminated by angle bracket‚ê§at /tmp/rPLqKKmiUQ:1‚ê§------> [32marg) { $arg }; say "hello bar" ~~ /<&foo[33m‚èè[31m bar>/[0m‚ê§¬ª

[19:55] <FROGGS> O.o

[19:55] <TimToady> nr: my token foo($arg) { $arg }; say "hello bar" ~~ /<&foo('bar')>/

[19:55] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(6) to(9) text(bar) pos([].list) named({}.hash)>‚ê§¬ª

[19:55] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§regex assertion not terminated by angle bracket‚ê§at /tmp/TTrsWHW2Uq:1‚ê§------> [32marg) { $arg }; say "hello bar" ~~ /<&foo[33m‚èè[31m('bar')>/[0m‚ê§¬ª

[19:56] <TimToady> hmm

[19:57] <TimToady> nr: grammar G { token foo($arg) { $arg }; token TOP { <foo('bar')> } }; say G.parse("hello bar")

[19:57] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´Match()‚ê§¬ª

[19:57] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[19:58] <TimToady> nr: grammar G { token foo($arg) { $arg }; token TOP { .*? <foo('bar')> } }; say G.parse("hello bar")

[19:58] *** SamuraiJack left
[19:58] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢hello barÔΩ£‚ê§ foo => ÔΩ¢barÔΩ£‚ê§‚ê§¬ª

[19:58] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(9) text(hello bar) pos([].list) named({"foo" => #<match from(6) to(9) text(bar) pos([].list) named({}.hash)>}.hash)>‚ê§¬ª

[19:58] <TimToady> nr: grammar G { token foo($arg) { $arg }; token TOP { .*? <foo bar> } }; say G.parse("hello bar")

[19:58] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(9) text(hello bar) pos([].list) named({"foo" => #<match from(6) to(9) text(bar) pos([].list) named({}.hash)>}.hash)>‚ê§¬ª

[19:58] <p6eval> ..rakudo 1ed6e5: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$arg'‚ê§  in regex foo at /tmp/kc2aIJqSuK:1‚ê§  in regex TOP at /tmp/kc2aIJqSuK:1‚ê§  in method parse at src/gen/CORE.setting:10718‚ê§  in block  at /tmp/kc2aIJqSuK:1‚ê§‚ê§¬ª

[19:58] <swarles> o-o

[19:58] <TimToady> that's about as close as you can get to <before foo>

[19:59] <TimToady> but before itself is kind of a primitive

[19:59] <swarles> well, what I was trying to implement was this

[19:59] <masak> before is three primitives, last I counted ;)

[19:59] <swarles> token num_seq ($numbers) { $numbers+ [ $numbers | _ <!before _> ]* }

[20:00] <swarles> Because I have to repeat that patterns a lot.

[20:00] <timotimo> hm. i tried optimising QAST/Compiler.nqp: &want, but it appears i've made no change at all. probably all want nodes are already eliminated by the optimiser before the compiler gets to see them

[20:00] <masak> swarles: have you seen the % modifier?

[20:00] <masak> swarles: it might be useful to you here.

[20:00] <TimToady> that looks kind of like $numbers % '_' to me

[20:01] <swarles> I thought it was just a separator

[20:01] <TimToady> how are you defining "separator"?

[20:01] <masak> r: say "123_45_67_8" ~~ / ^ (\d+)+ % '_' $ /

[20:01] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢123_45_67_8ÔΩ£‚ê§ 0 => ÔΩ¢123ÔΩ£‚ê§ 0 => ÔΩ¢45ÔΩ£‚ê§ 0 => ÔΩ¢67ÔΩ£‚ê§ 0 => ÔΩ¢8ÔΩ£‚ê§‚ê§¬ª

[20:01] <swarles> r: "1__224" ~~ /[ <[ 1 .. 9 ]> % '_' ]/

[20:01] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter % (must be quoted to match literally)‚ê§at /tmp/jNibFrqMY9:1‚ê§------> [32m"1__224" ~~ /[ <[ 1 .. 9 ]> [33m‚èè[31m% '_' ]/[0m‚ê§Unrecognized regex metacharacter [ (must be quoted to match literally)‚ê§at /tm‚Ä¶

[20:02] <masak> swarles: see my example.

[20:02] *** blublue joined
[20:02] *** fgomez joined
[20:02] <masak> swarles: % needs to modify a quantifier.

[20:02] <TimToady> Yeah, I spelled it wrong

[20:02] * TimToady has an obsolescent brane

[20:03] <swarles> so, the example you provided prevents multiple '_' from being together?

[20:03] <TimToady> try it

[20:03] <swarles> r: "1__2" ~~ / ^ (\d+)+ % '_' $ /

[20:03] <p6eval> rakudo 1ed6e5:  ( no output )

[20:03] <timotimo> either the optimisation didn't do anything, or it shaved off 1 second of the 180 second build time

[20:03] <swarles> r: say "1__2" ~~ / ^ (\d+)+ % '_' $ /

[20:03] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:04] *** brrt joined
[20:06] <swarles> r: say "_1" ~~ / ^ (\d+)+ % '_' $ /

[20:06] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:06] <swarles> r: say "1_" ~~ / ^ (\d+)+ % '_' $ /

[20:06] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:07] <skids> r: say "1__2" ~~ / ^ (\d+)+ % '_'+ $ /; # unless you want that to be three values

[20:07] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢1__2ÔΩ£‚ê§ 0 => ÔΩ¢1ÔΩ£‚ê§ 0 => ÔΩ¢2ÔΩ£‚ê§‚ê§¬ª

[20:09] <masak> r: say "123_45_67_8" ~~ / ^ [\d+]+ % '_' $ / # I guess [] is better

[20:09] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢123_45_67_8ÔΩ£‚ê§‚ê§¬ª

[20:09] <masak> less submatch noise :)

[20:10] <skids> Match needs a built-in .svg method :-)

[20:12] <timotimo> maybe not built-in, but i totally see how you could build a module for that

[20:12] <timotimo> maybe combine it with the intelligence of the grammar debugger and you could be able to do some pretty cool visualisations

[20:13] * FROGGS thinks of visualisations of /(.)(.)/

[20:17] <skids> I was just joking that Match.perl tends to be rather ugly when you get into big nests.  But yeah, especially if you could make it look like the notes you'd make explaining what matched what on a whiteboard.

[20:17] <swarles> r: say "14e55" ~~ /[<digit> <digit>]<2> % 'e'/

[20:17] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter < (must be quoted to match literally)‚ê§at /tmp/LSHcYfdVtQ:1‚ê§------> [32msay "14e55" ~~ /[<digit> <digit>]<[33m‚èè[31m2> % 'e'/[0m‚ê§Unable to parse regex; couldn't find final '/'‚ê§at /tmp/LSHcYfdVtQ:1‚ê§--‚Ä¶

[20:18] * TimToady thinks that .perl should probably prettify large utterances by default

[20:18] <TimToady> IRC one-liners are not the interface we should be optimizing for here

[20:18] <swarles> r: say "14e55" ~~ /[<digit> <digit>] ** 2 % 'e'/

[20:18] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢14e55ÔΩ£‚ê§ digit => ÔΩ¢1ÔΩ£‚ê§ digit => ÔΩ¢4ÔΩ£‚ê§ digit => ÔΩ¢5ÔΩ£‚ê§ digit => ÔΩ¢5ÔΩ£‚ê§‚ê§¬ª

[20:18] <swarles> r: say "14e55" ~~ /[\d \d] ** 2 % 'e'/

[20:18] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢14e55ÔΩ£‚ê§‚ê§¬ª

[20:19] <swarles> r: say "14e55" ~~ /[ [\d \d] ** 2 ] % 'e'/

[20:19] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter % (must be quoted to match literally)‚ê§at /tmp/OkHGCM2LAj:1‚ê§------> [32msay "14e55" ~~ /[ [\d \d] ** 2 ] [33m‚èè[31m% 'e'/[0m‚ê§Unable to parse regex; couldn't find final '/'‚ê§at /tmp/OkHGCM2LAj:1‚ê§------‚Ä¶

[20:19] <masak> r: say "14e55" ~~ /[<.digit> <.digit>] ** 2 % 'e'/

[20:19] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢14e55ÔΩ£‚ê§‚ê§¬ª

[20:20] *** blublue left
[20:20] <masak> how come Rakudo reports four 'digit' keys, instead of one key and an array of four?

[20:20] <swarles> prehaps this should be removed

[20:20] <swarles> http://search.cpan.org/~dconway/Perl6-Rules-0.03/Rules.pm

[20:21] <swarles> r: say /"foo"<3>/

[20:21] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter < (must be quoted to match literally)‚ê§at /tmp/bgtmPPZAO1:1‚ê§------> [32msay /"foo"<[33m‚èè[31m3>/[0m‚ê§Unable to parse regex; couldn't find final '/'‚ê§at /tmp/bgtmPPZAO1:1‚ê§------> [32msay /"foo"<[33m‚èè‚Ä¶

[20:21] <swarles> r: say /foo<3>/

[20:21] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter < (must be quoted to match literally)‚ê§at /tmp/nOyPz2fioC:1‚ê§------> [32msay /foo<[33m‚èè[31m3>/[0m‚ê§Unable to parse regex; couldn't find final '/'‚ê§at /tmp/nOyPz2fioC:1‚ê§------> [32msay /foo<[33m‚èè[31m‚Ä¶

[20:21] *** benabik joined
[20:21] <TimToady> that does seem like a buglet to return four digit pairs

[20:22] <jnthn> good evening o/

[20:22] <TimToady> n: say "14e55" ~~ /[<digit> <digit>] ** 2 % 'e'/

[20:22] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(5) text(14e55) pos([].list) named({"digit" => (#<match from(0) to(1) text(1) pos([].list) named({}.hash)>, #<match from(1) to(2) text(4) pos([].list) named({}.hash)>, #<match from(3) to(4) text(5) pos([].list) named({}.hash)>, #<match fr‚Ä¶

[20:22] <moritz> \o jnthn 

[20:22] <FROGGS> r: say "14e55" ~~ /[ $<thing>= [<.digit> <.digit>] ] ** 2 % 'e'/;

[20:22] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢14e55ÔΩ£‚ê§ thing => ÔΩ¢14ÔΩ£‚ê§ thing => ÔΩ¢55ÔΩ£‚ê§‚ê§¬ª

[20:22] <TimToady> niecza seems to return a list of four

[20:23] <TimToady> masak: so I think you've got a bug

[20:24] <TimToady> converting niecza to the ÔΩ¢14e55ÔΩ£ notation would be a great service to humanity, and probably LHF as well

[20:24] <FROGGS> true

[20:25] <timotimo> is there any low hanging fruit that would accelerate parsing in perl6? (especially the parsing stage of compiling the core setting...)

[20:25] <swarles> Is there something like #region from C#, I suppose it's more of an editor thing, but I don't know if there is maybe a comment convention or something to separate sections of code

[20:25] <jnthn> timotimo: Not that I'm aware of, or I'd have done it already...

[20:25] <timotimo> heh, ok

[20:25] <TimToady> timotimo: the problem is that you don

[20:26] <timotimo> i seem to have improved build time by about 0.5 seconds, but the code got less pretty in the process

[20:26] *** fhelmberger left
[20:26] <TimToady> don't know whether you're reparsing because the setting changed or the compiler changed

[20:26] <TimToady> if it's just the setting changed, you could do incremental recompiles

[20:26] <timotimo> oh, i wasn't suggesting to only do parts of the parsing, i was actually thinking of making the parsing itself faster in some way

[20:26] <FROGGS> swarles: what is #region?

[20:27] <timotimo> getting incremental recompiles doesn't seem like a low hanging fruit at all

[20:27] <TimToady> "the next 582 characters are a class definition, and they didn't change, so just reuse from last time"

[20:27] <jnthn> We lost some speed when I put in highexpect handling.

[20:27] <swarles> It's like setting up a section of the source file, for things like jumping to that section in particular or code folding

[20:27] <jnthn> Not a *lol* but some.

[20:27] <jnthn> er, not a *lot*

[20:28] <FROGGS> swarles: I can't answer that question

[20:28] <jnthn> TimToady: Just in case you missed it, I highlighted you yesterday with a spec tweak proposal.

[20:28] <swarles> alrighty

[20:28] <TimToady> jnthn: was driving to the pacific northwet yesterday...

[20:28] <jnthn> TimToady: Not blocking on it Right Now, but I do want to look at compact arrays at some point in the not too distant future :)

[20:28] *** brrt left
[20:29] <jnthn> TimToady: Yeah, just wanted to make sure it didn't fall between the cracks. :)

[20:29] <swarles> r: "'hello \' \n\\ world'" ~~ /\' [ <!['\\]> | \\. ]* \'/

[20:29] <p6eval> rakudo 1ed6e5:  ( no output )

[20:29] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [ <!['\\]> | \\. ]* \'/

[20:29] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:30] <skids> swarles: could be a sidechannel use for pod.

[20:30] *** wk joined
[20:30] <swarles> r: "'hello \' \n\\ world'" ~~ /\' [ <!['\\]> | '\\' . ]* \'/

[20:30] <p6eval> rakudo 1ed6e5:  ( no output )

[20:31] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [ <!['\\]> | '\\' . ]* \'/

[20:31] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:31] <swarles> gah

[20:31] <swarles> r: say "'hello \' \n\\ world'" ~~ /^\' [ <!['\\]> | '\\' . ]* \'$/

[20:31] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:32] <swarles> r: say "'hello \' \n\\ world'" ~~ /^ "'" [ <!['\\]> | '\\' . ]* "'" $/

[20:32] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:32] <swarles> god, I thought I've used this regular expression before

[20:36] <TimToady> shouldn't that ! be a - instead?

[20:36] <swarles> r: say "'hello \' \n\\ world'" ~~ /^ "'" [ <-['\\]> | '\\' . ]* "'" $/

[20:36] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:36] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [ <-['\\]> | \\. ]* \'/

[20:36] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢'hello 'ÔΩ£‚ê§‚ê§¬ª

[20:37] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [ <-[\'\\]> | \\. ]* \'/

[20:37] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢'hello 'ÔΩ£‚ê§‚ê§¬ª

[20:37] <timotimo> S05 doesn't talk much about the actions object that you can pass to Grammar.parse. where do i need to look?

[20:37] <swarles> r: say "a" ~~ /<-[a]>/

[20:37] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:37] <swarles> r: say "A" ~~ /<-[a]>/

[20:37] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢AÔΩ£‚ê§‚ê§¬ª

[20:38] <TimToady> n: say "'hello \' \n\\ world'" ~~ /\' [ <-[\'\\]> | \\. ]* \'/

[20:38] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(8) text('hello ') pos([].list) named({}.hash)>‚ê§¬ª

[20:39] <TimToady> n: say "'hello \' \n\\ world'" ~~ /\' [ . | \\. ]* \'/

[20:39] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(18) text('hello ' ‚ê§\ world') pos([].list) named({}.hash)>‚ê§¬ª

[20:39] <TimToady> LTM for the win :)

[20:39] <TimToady> well, but maybe not for correctness...

[20:40] <TimToady> n: say "'hello \' \n\\ world'" ~~ /\' [ . | \\. ]*? \'/

[20:40] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(8) text('hello ') pos([].list) named({}.hash)>‚ê§¬ª

[20:40] <TimToady> right

[20:40] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [ <-[\'\\]> | \\. ]*+ \'/

[20:40] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Quantifier quantifies nothing‚ê§at /tmp/3Y7QWpf625:1‚ê§------> [32mn\\ world'" ~~ /\' [ <-[\'\\]> | \\. ]*+[33m‚èè[31m \'/[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        prefix or term‚Ä¶

[20:41] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' [[ <-[\'\\]> | \\. ]+]* \'/

[20:41] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢'hello 'ÔΩ£‚ê§‚ê§¬ª

[20:41] <swarles> gah. I wish I knew where I was going wrong

[20:41] * TimToady too

[20:42] <TimToady> n: say "'hello \' \n\\ world'" ~~ /\' [ \\. || . ]*? \'/

[20:42] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(8) text('hello ') pos([].list) named({}.hash)>‚ê§¬ª

[20:42] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' <-['\\]>

[20:42] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Regex not terminated‚ê§at /tmp/tMijC0ZGfx:1‚ê§------> [32m "'hello \' \n\\ world'" ~~ /\' <-['\\]>[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        prefix or term‚ê§       ‚Ä¶

[20:42] <swarles> err

[20:42] <TimToady> n: say "'hello \' \n\\ world'" ~~ /\' [ \\. || . ]:*? \'/

[20:42] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' <-['\\]>* [ \\. <-[

[20:42] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unrecognized regex metacharacter < (must be quoted to match literally)‚ê§at /tmp/HAh7dd1ixS:1‚ê§------> [32m' \n\\ world'" ~~ /\' <-['\\]>* [ \\. <-[33m‚èè[31m[[0m‚ê§Unrecognized regex metacharacter [ (must be quoted to match literally)‚ê§a‚Ä¶

[20:42] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unrecognized regex metacharacter : (must be quoted to match literally) at /tmp/Gak5722sdM line 1:‚ê§------> [32mllo \' \n\\ world'" ~~ /\' [ \\. || . ]:[33m‚èè[31m*? \'/[0m‚ê§‚ê§Unable to parse regex; couldn't find final '/' at ‚Ä¶

[20:43] <swarles> ... Curse the return key

[20:44] <TimToady> n: say "'hello \\' \\n\\\\ world'" ~~ /\' [ \\. || . ]*? \'/

[20:44] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´#<match from(0) to(21) text('hello \' \n\\ world') pos([].list) named({}.hash)>‚ê§¬ª

[20:44] <TimToady> " is eating your \s

[20:44] <TimToady> n: say "'hello \\' \\n\\\\ world'"

[20:44] <p6eval> niecza v24-18-gaf64300: OUTPUT¬´'hello \' \n\\ world'‚ê§¬ª

[20:45] <swarles> r: say "'hello \' \n\\ world'" ~~ /\' <-['\\]>* [ \\. <-['\\]>* ]* \'/

[20:45] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢'hello 'ÔΩ£‚ê§‚ê§¬ª

[20:45] <TimToady> so the problem is not in the //, but in the ""

[20:45] <TimToady> r: say "'hello \' \n\\ world'"  # see

[20:45] <p6eval> rakudo 1ed6e5: OUTPUT¬´'hello ' ‚ê§\ world'‚ê§¬ª

[20:45] <swarles> r: say 'hello \' \n\\ world'

[20:46] <p6eval> rakudo 1ed6e5: OUTPUT¬´hello ' \n\ world‚ê§¬ª

[20:46] <TimToady> r: say Q/hello \' \n\\ world'/

[20:46] <p6eval> rakudo 1ed6e5: OUTPUT¬´hello \' \n\\ world'‚ê§¬ª

[20:47] <TimToady> nr: say ÔΩ¢hello \' \n\\ worldÔΩ£

[20:47] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/a91ObsL9Pm:1‚ê§------> [32msay [33m‚èè[31mÔΩ¢hello \' \n\\ worldÔΩ£[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§        postfix‚ê§        infix or meta-infix‚Ä¶

[20:47] <p6eval> ..niecza v24-18-gaf64300: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/EWgyvAXLcb line 1:‚ê§------> [32msay[33m‚èè[31m ÔΩ¢hello \' \n\\ worldÔΩ£[0m‚ê§‚ê§Confused at /tmp/EWgyvAXLcb ‚Ä¶

[20:47] <swarles> r: say Q/'hello \' \n\\ world'/ ~~ /\' [ <!['\\]> | \\. ]* \'/

[20:47] <p6eval> rakudo 1ed6e5: OUTPUT¬´#<failed match>‚ê§¬ª

[20:47] <TimToady> that's NYI

[20:47] *** brrt joined
[20:47] *** am0c is now known as am0cd

[20:47] <TimToady> still want - instead of !

[20:47] *** am0cd is now known as am0c

[20:47] <swarles> r: say Q/'hello \' \n\\ world'/ ~~ /\' [ <-['\\]> | \\. ]* \'/

[20:47] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢'hello \' \n\\ world'ÔΩ£‚ê§‚ê§¬ª

[20:47] <jnthn> Is that meant to be a zerowidth?

[20:48] <swarles> Whoops, I pasted the earlier regular expression without changing that part

[20:48] <TimToady> ! is a short way to write <before>

[20:48] <TimToady> er, !befor

[20:48] <swarles> ah. I thought it was a negation.

[20:48] <jnthn> Thought so.

[20:48] <TimToady> - is negation :)

[20:51] <swarles> r: say "\\245" ~~ /\\[ <[ 0 .. 7 ]> ** 3 ]/

[20:51] <p6eval> rakudo 1ed6e5: OUTPUT¬´ÔΩ¢\245ÔΩ£‚ê§‚ê§¬ª

[20:51] <TimToady> jnthn: I'm fine with your postcircumfix proposal; I was a little bit surprised when they got implemented as methods in the first place, but wasn't smart enough to spot the performance issue

[20:51] *** kivutar joined
[20:52] <dalek> rakudo/nom: 7707e42 | (Tobias Leich)++ | src/Perl6/Actions.pm:

[20:52] <dalek> rakudo/nom: fix, so that $(0) isnt treated like $()

[20:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7707e421e1

[20:52] <TimToady> (unless I'm revising history again...)

[20:52] <jnthn> TimToady: Do my suggested changes to Positional and Associative make sense also?

[20:53] <jnthn> The other bit I'm really not sure what to do with is postcircumfix:<( )>

[20:54] *** fgomez left
[20:54] <TimToady> invocation is pretty fundamental too...

[20:55] <TimToady> naming it as a postcircumfix is probably wrongish as well

[20:55] <jnthn> Also, some want at_pos to be AT_POS ;)

[20:55] <TimToady> it's more like FETCH and STORE

[20:56] <TimToady> I'm fine with uppercase for primitives

[20:56] <jnthn> OK

[20:56] * FROGGS .oO( FINE )

[20:57] * FROGGS .oO( am I a primitive? )

[20:57] *** dduncan joined
[20:58] <TimToady> btw, a while ago you asked about Junction.Str, which is actually prohibited in S32/Containers:1215

[20:58] *** swarles left
[20:58] <skids> r: perl6 -e 'grammar f { token ohai { o \/ };}; class Actions { method ohai ($/) { make "OHAI!" }}; f.parse("o/", :actions(Actions), :rule<ohai>).ast.say; # working example for timotimo.

[20:58] <p6eval> rakudo 1ed6e5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/2KXOFESUWT:1‚ê§------> [32mperl6 -e [33m‚èè[31m'grammar f { token ohai { o \/ };}; clas[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        statement end‚ê§      ‚Ä¶

[20:58] <TimToady> I've speculated before that print should have a more primitive stringifier

[20:59] <skids> oh dear not so working heh

[20:59] <jnthn> It does compared to say ;)

[20:59] <skids> r: grammar f { token ohai { o \/ };}; class Actions { method ohai ($/) { make "OHAI!" }}; f.parse("o/", :actions(Actions), :rule<ohai>).ast.say; # working example for timotimo.

[20:59] <p6eval> rakudo 1ed6e5: OUTPUT¬´OHAI!‚ê§¬ª

[20:59] *** dduncan left
[21:00] <skids> timotimo: note also you can curry your actions into the grammar's parse method by defining your own w/ callwith.

[21:02] <masak> I found the bit about DateTime::Duration on CPAN adding things "in the wrong order". it's not as clear-cut as I thought: https://metacpan.org/module/DateTime#Adding-a-Duration-to-a-Datetime

[21:03] <masak> it says it does days, then months, then minutes, seconds, and nanoseconds.

[21:03] <masak> that feels like a very weird order to me. it's neither biggest-to-smallest nor vice versa.

[21:03] *** hash_table left
[21:04] <masak> but the documentation also contains a warning that this is the behavior. it doesn't say "oh well, it is the way it is and I can't break backwards compatibility".

[21:04] <timotimo> skids: do i really need callwith? shouldn't .given (or is it called .supposing?) be enough?

[21:04] <masak> ISTR autarch saying that, but I don't find it on the page, nor in my email archives.

[21:04] <masak> timotimo: .assuming?

[21:04] <timotimo> that's the one! :)

[21:04] <TimToady> I can see why it's that way; days are a fixed-width, compared to the others

[21:05] <TimToady> it's like counting codepoints before graphemes...

[21:05] <FROGGS> TimToady: a day can have 23 to 25 hours here

[21:06] <FROGGS> .oO( and 26 hours on Bajor )

[21:06] <TimToady> yes, but if you ask for the same time 3 days from now, that's what you get

[21:06] <FROGGS> thats the same when adding one month

[21:06] <TimToady> how long is one month?

[21:06] <FROGGS> I will get the first of march when adding 1 month to the 1st of feb

[21:06] <FROGGS> 28-31 days

[21:07] <masak> TimToady: yes, but wouldn't biggest-to-smallest make as much sense?

[21:07] * TimToady wonders what Dec 31 + 2 months comes out to...

[21:08] <masak> I'll try it with CPAN's DateTime.

[21:08] *** kaare_ left
[21:08] *** kaare_ joined
[21:09] <FROGGS> masak: a good test case would be to add two months to dec 31, then two days, and then vice versa as the second test

[21:09] <FROGGS> maybe the result is the same

[21:09] <FROGGS> and that is what I believe

[21:09] <skids> timotimo: .assuming might work.  I haven't taken that tool out of the dust cover yet :-)

[21:10] <FROGGS> because a month has no fixed width, it matters to what date you add it

[21:10] <masak> honestly I'd rather copy someone else's sane-ish date-adding semantics here than try to come up with my own.

[21:10] <masak> but I'm also interested in fixing known mistakes CPAN's DateTime made.

[21:10] <FROGGS> true, there is so much magic going on...

[21:11] <TimToady> well, to the extent that dates are insane, fixing one mistake will unfix a different mistake

[21:11] *** zby_home_ joined
[21:12] <FROGGS> I guess you will need a few thousand test cases to be on a fairly safe side

[21:12] <masak> $ perl -MDateTime -E 'my $dt = DateTime->new( year => 2012, month => 12, day => 31 ); $dt->add( months => 2 ); say $dt'

[21:12] <masak> 2013-03-03T00:00:00

[21:12] *** japhb_ joined
[21:12] <FROGGS> uhhh

[21:13] *** benabik_ joined
[21:13] *** benabik left
[21:13] *** benabik_ is now known as benabik

[21:13] <skids> .oO(adding months is a slightly insane thing to do anyway.  Or at least, subject to expressional ambiguity.)

[21:14] <FROGGS> perl -MDateTime -E 'my $dt = DateTime->new( year => 2013, month => 02, day => 28 ); $dt->add( months => 2 ); say $dt'

[21:14] <FROGGS> 2013-04-28T00:00:00

[21:14] <FROGGS> so it adds 2 to the month, and then tries to set the day

[21:15] <FROGGS> if the month has less, add these days

[21:15] <geekosaur> what happens if you add 1 month on 30 Jan? :)

[21:15] <FROGGS> so the first of a month will always be the first

[21:15] <FROGGS> depends on how many days the feb has

[21:16] <FROGGS> can be march the first or the second

[21:16] <masak> geekosaur: see my output above; very similar case.

[21:16] *** vividsnow left
[21:17] <masak> I appreciate your enthusiasm over the "impossible" situations. that's not what interests me right now, however. what interests me is finding sane semantics for a .delta(:months(2), :days(1), :minutes(40)) method for Perl 6's DateTime.

[21:18] <masak> in other words, please assume the "one month after 30 Jan" problem is solved.

[21:18] <masak> (because it is)

[21:18] <FROGGS> it is

[21:18] *** zby_home_ left
[21:18] * TimToady sees dead unicorns

[21:19] *** brrt left
[21:19] <FROGGS> masak: whats wrong with Perl 5's DateTime semantic?

[21:19] <FROGGS> I like the ->add and ->subtract methods

[21:19] <skids> How about just not allowing :months in deltas?

[21:21] <FROGGS> the same goes for years, days, minutes and so on... you cant disallow all ;o)

[21:21] <masak> skids: months aren't really a problem. forget about months.

[21:21] <skids> I suppose with leap seconds, yes

[21:21] <TimToady> do it all in seconds, with snap-to-grid semantics optional

[21:22] <masak> TimToady: yeah, but people like to say "a year later".

[21:22] <masak> TimToady: that's part of the reason we're introducing the method.

[21:22] <masak> of course, we could mandate only one named argument at a time... :)

[21:22] <TimToady> .oO(ordered named arguments...)

[21:22] <masak> so you'd have to write .delta(:months(2)).delta(:days(1)).delta(:minutes(40))

[21:23] <masak> kind of a weird requirement, though.

[21:24] <jnthn> yes, but an escape hatch if people find the default order unsuitable... :)

[21:26] <masak> I guess my question is whether there is an order that is somehow least unsuitable.

[21:27] <FROGGS> you could add a param that overrides the default order

[21:28] <masak> bzzt. wrong answer! :P

[21:28] <FROGGS> meh

[21:28] <masak> focus! we want simplicity, not complicatedness.

[21:28] <masak> :P

[21:28] <FROGGS> it is simple if one doesnt care

[21:28] <FROGGS> he will get what Perl 5's DateTime did

[21:29] <masak> all I'm saying is "add a parameter" is the refuge of cowards.

[21:29] <masak> be bold, and spec it right from the start!

[21:29] * skids does "man at" to see how it is handled there

[21:29] <masak> in other news, I don't like the :by parameter. :)

[21:29] <dalek> nqp-jvm-prep: 39a9db0 | jonathan++ | src/org/perl6/nqp/ (5 files):

[21:29] <dalek> nqp-jvm-prep: Add a REPR for context references.

[21:29] <dalek> nqp-jvm-prep: 

[21:29] <dalek> nqp-jvm-prep: We don't make contexts have to be GCable, 6model objects. But if we

[21:29] <dalek> nqp-jvm-prep: want to talk about them first class, they need objectifying. This will

[21:29] <dalek> nqp-jvm-prep: provide that wrapping.

[21:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/39a9db0ae3

[21:29] <dalek> nqp-jvm-prep: eb06569 | jonathan++ | / (2 files):

[21:29] <dalek> nqp-jvm-prep: Implement nqp::ctx, nqp::ctxouter, nqp::ctxcaller.

[21:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/eb06569bbd

[21:29] <dalek> nqp-jvm-prep: aadb6da | jonathan++ | / (2 files):

[21:29] <dalek> nqp-jvm-prep: Implement nqp::curcode() and nqp::callercode().

[21:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/aadb6da7e5

[21:29] <dalek> nqp-jvm-prep: 6228338 | jonathan++ | docs/ROADMAP:

[21:29] <dalek> nqp-jvm-prep: Update ROADMAP.

[21:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/622833848d

[21:30] <FROGGS> r: say (a => 2, c => 4, B => 7)

[21:30] <p6eval> rakudo 7707e4: OUTPUT¬´"a" => 2 "c" => 4 "B" => 7‚ê§¬ª

[21:30] <FROGGS> is the order guaranteed to be the way I declared it?

[21:30] <jnthn> Yes, because you just wrote a list of paris.

[21:31] <jnthn> Once you turn it into a hash, it's not guaranteed.

[21:31] <FROGGS> hmmm

[21:31] <FROGGS> but you can slurp it as a list of pairs?

[21:31] *** slayer101_ left
[21:31] <masak> sure.

[21:31] <jnthn> uh, not if you pass it as foo(a => 2, ...)

[21:31] <masak> no, of course not.

[21:32] <jnthn> Then they get passed as named, and the order is not preserved.

[21:32] <FROGGS> damn

[21:32] <skids> hah.  at dodged the question by only allowing one e.g. "+5 hours" field.

[21:32] <masak> but you *can* slurp it as a list of pairs :P

[21:32] <masak> I kinda like "only allow one".

[21:32] <masak> ooh!

[21:32] <masak> .delta(5, "days")

[21:33] <masak> always two positional parameters.

[21:33] <masak> I think we have a winner.

[21:33] <FROGGS> what about .delta(5, "days", 2, "months") ?

[21:33] <jnthn> urgh...strings?

[21:34] <diakopter> <gurgle>

[21:34] <FROGGS> calling .delta($$) plenty of times is weird

[21:34] <skids> Well, except then people are wondering why you won't eat your own dog food.

[21:34] <jnthn> .delta(5, "monkeys")

[21:34] <skids> .delta(5, "siestas")

[21:34] <jnthn> .delta(5, "lightyears")

[21:34] * masak .oO( U Y no like the winner, huh? ) :P

[21:34] <FROGGS> bah, lightyears -.-

[21:34] <jnthn> wait, that's a distance :P

[21:35] <masak> s/U Y/Y U/

[21:35] <FROGGS> *g*

[21:35] <jnthn> <-- failed physics :P

[21:35] <TimToady> + 2months + 5days

[21:35] <jnthn> postfixes? :)

[21:35] <TimToady> yep

[21:35] * masak decides to killfile #perl6 for a while for his blood pressure's sake

[21:35] <TimToady> just like 2i

[21:36] <jnthn> Will have to be $a\months though

[21:36] <skids> Actually that gives merit to the idea of DateTime literals.

[21:36] <jnthn> Which is a little...icky. :)

[21:36] <jnthn> I like it for the literal form, though.

[21:37] <FROGGS> I like the named params, if you specify more that one param to .delta, there is a default order, if you dont like it do it in sequences

[21:38] <TimToady> it's really verbose compared to the postfixes

[21:38] <FROGGS> the problem I see about +2months is that it looks ugly when using variables, and, this looks like a fixed-width duration when it isnt

[21:39] *** benabik left
[21:39] <FROGGS> or maybe it even is a fixed with duration

[21:40] <FROGGS> since +1months is always 31 days

[21:40] <FROGGS> no, wait

[21:41] <FROGGS> 1months is the same day-of-the-month from today to the same day of the month

[21:41] <FROGGS> 1months is the same day-of-the-month from today to the same day of the next* month

[21:42] <skids> +1months is .delta(+1months) :-)

[21:43] <FROGGS> thats the reason why DateTime::Span begins at a concrete timestamp and ends at a concrete one (or inf)

[21:43] <FROGGS> skids: right

[21:44] *** kivutar left
[21:44] <FROGGS> has somebody knowledge of DateTime modules in other languages?

[21:45] <FROGGS> I just know php's date and strftime, but that is crap ;o)

[21:46] <dalek> nqp-jvm-prep: ebc30a8 | jonathan++ | / (3 files):

[21:46] <dalek> nqp-jvm-prep: Implement compiler registry (getcomp/bindcomp).

[21:46] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ebc30a8066

[21:46] <jnthn> Time for some rest...'night

[21:46] <skids> o/

[21:46] <FROGGS> gnight

[21:48] *** rindolf left
[21:48] *** am0c left
[21:56] *** fgomez joined
[21:59] *** kaare_ left
[22:01] * skids hopes his car warms up fast.  it is cohwlduh.

[22:02] <skids> oh and I have to pump gas.  gah.

[22:07] *** skids left
[22:07] <lue> TimToady: I thought as well of postfixes (e.g. s for seconds, min for minutes, etc.)

[22:19] *** PacoAir left
[22:19] *** stevan_ left
[22:20] *** stevan_ joined
[22:20] <lue> How is the "one month after 30 Jan" solved? And what other issues are there?

[22:25] *** spider-mario left
[22:25] <FROGGS> lue: same math as Perl 5's DateTime. add one month, and if 30 > days-of-feb, then add 30 - days-of-feb to the date

[22:26] <FROGGS> dont know what other issues are there

[22:30] *** stevan_ left
[22:31] <lue> .oO(Why can't our timekeeping systems behave‚ÄΩ)

[22:39] *** kivutar joined
[22:39] *** kivutar left
[22:46] <masak> 'night, #perl6

[22:47] <tadzik> weekend!

[22:50] *** benabik joined
[22:53] *** Rix left
[22:57] <lue> g'night o/

[23:02] *** bluescreen10 left
[23:05] *** atrodo_ joined
[23:07] *** atrodo left
[23:07] *** atrodo_ is now known as atrodo

[23:09] *** Rix joined
[23:10] *** MayDaniel left
[23:22] *** b1rkh0ff left
[23:24] *** stopbit left
[23:27] *** Chillance left
[23:38] *** b1rkh0ff joined
[23:42] *** skids joined
[23:47] *** b1rkh0ff left
[23:52] *** jrockway joined
