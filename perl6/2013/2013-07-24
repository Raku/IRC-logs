[00:30] *** grondilu left
[00:39] *** logie joined
[00:44] *** lizmat_ joined
[00:44] *** lizmat left
[00:59] <ruoso> is there any suppotr for calling regular java classes from rakudo already?

[01:03] <timotimo> yeah, look into src/vm/jvm/core/Threading.pm for an example

[01:03] *** benabik left
[01:03] *** benabik joined
[01:04] <ruoso> timotimo: thanks...

[01:04] <timotimo> it'll probably get a layer of sugar on top some time.

[01:05] <ruoso> is there a way to implement a java interface?

[01:05] *** aindilis joined
[01:07] <ruoso> ah, I see... Threading.pm does that already by implementing Runnable

[01:08] <TimToady> though really, you'd like to be able to pull that in as a P6 role, I suspect

[01:09] <TimToady> that'll take a bit more meta-introspection at compile time though...

[01:09] <ruoso> I am not sure you would be able to call it a role

[01:09] <TimToady> well, it's a role that doesn't give you any default implementations

[01:09] *** ilbot_nextgen left
[01:11] <ruoso> but it also has to feed into the JVM type system as an implementation of a Java Interface, which I'm not sure would be equivalent to role composition...

[01:12] <TimToady> wasn't thinking it'd work in that direction

[01:13] <ruoso> well, but that'd be the reason to use it... for instance, implementing the Servlet interface to serve as a Tomcat application

[01:13] <TimToady> though there might eventually be some way of pulling the interfacey bits out of a role

[01:14] * TimToady waves hands; smart people are working on this :)

[01:15] *** ilbot_nextgen joined
[01:16] <ruoso> It probably makes sense to think of this as a JVM-specific "knowhow" (is that how it is still called?)

[01:16] <TimToady> yes

[01:17] <ruoso> something like: "use JVM::Interfaces; class Foo implements javax.servlet.Servlet { ... }"

[01:17] <TimToady> the right person to discuss this with is probably jnthn-when-he-is-awake

[01:18] * ruoso nod

[01:19] *** dayangkun_ left
[01:19] <TimToady> we might not let you use the dot for that though, unless javax has a servlet method :)

[01:20] <benabik> Something macro-ish?  Can you have is parsed on a trait?

[01:20] <TimToady> everything is possible, but not everything is expedient

[01:21] <ruoso> fair enough, converting the . into :: makes a lot of sense

[01:22] <ruoso> or even just take it as a lieteral

[01:43] <ruoso> or even just take it as a lieteral

[01:44] * ruoso reflex-typing uparrow-enter

[01:44] <TimToady> you can say that again

[01:47] * ruoso reflex-typing uparrow-enter

[01:48] <ruoso> hah... this is getting ridiculous... I will move this window to a different desktop

[01:59] <TimToady> hmm, still seems to be right here :)

[02:01] * TimToady will check to see if it's still here after dinner &

[02:01] *** athomason_ left
[02:13] *** abnorman left
[02:35] *** danaj left
[02:36] *** danaj joined
[02:40] *** danaj left
[02:46] *** lue left
[02:47] *** konundra left
[02:47] *** fridim__ joined
[02:48] *** lue joined
[03:23] *** clkao_ joined
[03:26] *** cognominal joined
[03:26] * flussence wrote... something. http://www.reddit.com/r/PHP/comments/1iw0cj/what_would_you_change_about_php_if_you_could/cb904kq

[03:33] *** eirini_k joined
[03:34] *** preflex_ joined
[03:34] *** ChanServ sets mode: +v preflex_

[03:34] *** preflex left
[03:34] *** preflex_ is now known as preflex

[03:34] *** eirini_k left
[04:11] *** xilo left
[04:15] *** arlinius left
[04:17] *** logie left
[04:42] *** raiph joined
[05:08] *** birdwindupbird joined
[05:10] *** SamuraiJack__ joined
[05:11] <lizmat_> good *, #perl6!

[05:11] <lizmat_> and flussence++

[05:18] *** fridim__ left
[05:25] <moritz> \o

[05:25] <lizmat_> o/

[05:26] <lizmat_> nick lizmat

[05:26] *** lizmat_ is now known as lizmat

[05:26] * lizmat is not awake yet

[05:26] <lizmat> breakfast&

[05:54] *** PacoAir joined
[05:55] *** abnorman joined
[05:59] *** iSlug joined
[06:02] *** smash___ joined
[06:03] *** ribasushi_ joined
[06:03] *** noxgirl joined
[06:04] *** ribasushi left
[06:04] *** autumn left
[06:04] *** FROGGS joined
[06:04] *** smash left
[06:04] *** ribasushi_ is now known as ribasushi

[06:06] <dalek> rakudo/nom: e9a8263 | jnthn++ | src/vm/parrot/guts/storage_spec.h:

[06:06] <dalek> rakudo/nom: Sync storage_spec.h with NQP one.

[06:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9a8263335

[06:11] *** wtw joined
[06:14] *** PacoAir left
[06:14] <FROGGS> flussence++ # reddit

[06:19] *** domidumont joined
[06:25] *** salv0 joined
[06:25] <lizmat> jnthn: attempting a clean build

[06:26] *** domidumont left
[06:27] *** domidumont joined
[06:28] *** spider-mario joined
[06:28] *** odoacre_ joined
[06:29] *** odoacre left
[06:35] <lizmat> jnthn: could it be that the "Stage parse" became slower since the Buf changes ? (looking at going from 115 seconds to 128 seconds on my machine)

[06:36] <lizmat> jnthn: build completes ok after your last fix, running spectest now

[06:36] *** spider-mario left
[06:44] <lizmat> jnthn: clean apart from the IO-Socket-INET fails

[06:47] *** wk joined
[06:47] *** wk is now known as Guest56637

[06:48] *** cognominal left
[06:48] *** kaleem joined
[06:51] <jnthn> lizmat: Well, we added a bunch of new types and roles...

[06:51] <yoleaux> 23 Jul 2013 22:57Z <lizmat> jnthn: after nuking nqp/parrot and install dir and rebuilding from that, I still get a segfault when building RESTRICTED.setting

[06:51] <yoleaux> 23 Jul 2013 23:02Z <lizmat> jnthn: seems to be changes in nqp that cause this, rolling back last 2 commits in nom doesn't fix the problem

[06:52] <lizmat> actually, it;s more like 115 -> 120

[06:52] <lizmat> so that could well explain

[06:56] *** wtw left
[06:58] <dalek> rakudo/nom: 340fc12 | (Elizabeth Mattijsen)++ | src/core/metaops.pm:

[06:58] <dalek> rakudo/nom: Make sure we don't flatten type objects on either side of a hyper

[06:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/340fc128ce

[07:13] <dalek> rakudo/nom: d12ecc5 | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[07:13] <dalek> rakudo/nom: Make .list, .flat, .eager & .hash type object aware.

[07:13] <dalek> rakudo/nom: 

[07:13] <dalek> rakudo/nom: If called on just a type object, they will all return an empty list/hash.

[07:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d12ecc5c8b

[07:21] <jnthn> lizmat: Should they perhaps not behave consistently with .[0] ?

[07:25] <lizmat> could you give me a more elaborate code example?

[07:27] <jnthn> r: 42.list.perl.say

[07:27] <camelia> rakudo 340fc1: OUTPUT«(42,).list␤»

[07:27] <jnthn> r: Int.list.perl.say

[07:27] <camelia> rakudo 340fc1: OUTPUT«(Int,).list␤»

[07:27] <jnthn> Those two look right to me

[07:29] <lizmat> the former I agree, the latter I'm not so sure

[07:30] <lizmat> the idea is that in situations like 'my Hash @a; say @a[0].keys' there will be no keys

[07:31] <lizmat> otherwise, in complex data structure, you will always first have to check whether something in a potentially unused slot, is actually defined

[07:32] <lizmat> before ascertaining that it has keys, or elems

[07:33] <lizmat> r: my Hash @a; say @a[0].keys  # currently fails for different reasons

[07:33] <camelia> rakudo 340fc1: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method keys at src/gen/CORE.setting:7564␤  in block  at /tmp/HhoTIiHTAu:1␤␤»

[07:37] <JimmyZ> r: my Hash @a; say @a[0]

[07:37] <camelia> rakudo 340fc1: OUTPUT«(Hash)␤»

[07:37] <JimmyZ> r: my Hash @a; say @a[0].?keys

[07:37] <camelia> rakudo 340fc1: OUTPUT«Invocant requires an instance, but a type object was passed␤  in method keys at src/gen/CORE.setting:7564␤  in block  at /tmp/2gpzG0_5N8:1␤␤»

[07:41] *** wtw joined
[07:42] *** sqirrel joined
[07:45] *** Guest56637 left
[08:10] *** domidumont left
[08:10] *** domidumont joined
[08:12] *** SamuraiJack joined
[08:12] *** dmol joined
[08:13] *** rindolf joined
[08:14] *** SamuraiJack__ left
[08:23] *** abnorman left
[08:30] *** ilogger2_ joined
[08:35] *** cognominal joined
[08:44] <dalek> rakudo/nom: c3a58f9 | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[08:44] <dalek> rakudo/nom: Other changes to make type objects appear as Nil in non-scalar contexts

[08:44] <dalek> rakudo/nom: 

[08:44] <dalek> rakudo/nom: This typically makes something like:

[08:44] <dalek> rakudo/nom:   my Hash @a; say @a[42].elems  # returns 0

[08:44] <dalek> rakudo/nom: instead of blowing up or saying there is 1 element with the type object.

[08:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3a58f998d

[08:50] *** snoopy left
[08:56] <lizmat> Note that in the simplest case, this will let Hash.elems also return 0

[08:56] <lizmat> Also note that at one point, if we agree this is a good thing, this will need to be implemented using MMD

[08:57] <lizmat> but that would slow down things too much now

[08:57] <lizmat> (or am I wrong about that?)

[08:57] <jnthn> :D vs :U in the multi-dispatcher is well optimized

[08:57] <jnthn> The multi cache knows about it

[08:59] <lizmat> jnthn: if there was already a multi, I used that

[08:59] <lizmat> if there wasn't, I didn't create one

[08:59] <lizmat> I assume un-multi methods still dispatch faster than multi's, no?

[08:59] <jnthn> yes, they do

[09:00] <jnthn> Though it may not always be a huge difference

[09:00] <jnthn> With multi subs, it can sometimes work out which candidate you're going to be calling at compile time

[09:00] <lizmat> these are all multi methods

[09:01] <jnthn> sure, just pointing out the trade-off is different.

[09:02] <tadzik> diakopter++ # grant application

[09:02] <lizmat> anyways, I'll do a spectest with these methods changed to multi-methods once we agree that this has been a sensible way forward

[09:02] <lizmat> or nobody raises any objections in the next week or so

[09:03] <lizmat> when I will take absence of comments as agreement  :-)

[09:03] <jnthn> Well, from Sautrday I won't be here to disagree with anything :P

[09:03] <lizmat> ah, but shortly thereafter masak will be back, right ?

[09:05] <lizmat> so far, it's only 2 commits to revert: c3a58f9 and 340fc12

[09:06] <lizmat> the other commits didn't change any behaviour, they only caused problems in combination with the these two commits

[09:06] <lizmat> (and they took a long time to figure out)

[09:06] <lizmat> also for clarity: these changes spectest clean, but do not have specific spectests for them yet

[09:07] <lizmat> I will add those again once we have agreement

[09:07] <JimmyZ> oh, diakopter++

[09:09] *** sqirrel joined
[09:10] *** dakkar joined
[09:10] <dalek> rakudo/nom: 9ba5dde | (Elizabeth Mattijsen)++ | t/spectest.data:

[09:10] <dalek> rakudo/nom: move INET tests to last, so we can see how much time they take

[09:10] <dalek> rakudo/nom: 

[09:10] <dalek> rakudo/nom: Oddly enough, moving this test to an earlier location, only had adverse

[09:10] <dalek> rakudo/nom: effects on the wallclock of spectest.  Grrr.  Wish I understood exactly what

[09:10] <dalek> rakudo/nom: is going on here.

[09:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ba5dded33

[09:22] *** crab2313 joined
[09:49] <lizmat> cycling&

[09:59] *** pmurias joined
[10:13] *** fhelmberger joined
[10:21] *** crab2313 left
[10:23] <pmurias> jnthn: do you think the op descriptions should be in qast.markdown or a seperate document?

[10:34] *** daxim joined
[10:37] *** crab2313 joined
[10:43] *** wk joined
[10:44] *** wk is now known as Guest9814

[11:14] *** sqirrel left
[11:18] *** crab2313 left
[11:24] * colomon has successfully parsed the 13M STEP file (using his 32G linux box) but creating the reverse lookup index using categorize is still running.  current stats are 37G memory used, 459 minutes.

[11:24] *** brrt joined
[11:24] <FROGGS> O.o

[11:27] <colomon> guess I might as well try a much smaller model on it under jakudo and see if it works

[11:30] <ruoso> jnthn: do you think that for Java Interfaces interoperability would it make sense to try to disguise them as roles? or should we go with a new knowhow that maybe introduces the class trait "implements", such as: use JVM::Interfaces; class Foo implements 'javax.servlet.Servlet' { ... } 

[11:31] <colomon> the good news is, once the reverse lookup index is created, the rest of the script should be pretty quick, I think

[11:32] <daxim> "get Damian to write Perl-7 which is Perl5+Moose-in-core"   http://anonymoushash.vmbrasseur.com/2013/07/22/the-rising-costs-of-aging-perlers-part-3-the-suggestions/#comment-2235

[11:32] <FROGGS> ruoso: maybe more like ... implements jvm('javax.servlet.Servlet') { ..., that would be like the existing is repr('...') or is symbol('...')

[11:32] <colomon> woah, jakudo did not do well on this test.  ran for a minute longer than the parrakudo version took to complete, and then died with "GC overhead limit exceeded"

[11:34] <colomon> (that's on the small model, obviously)

[11:36] <ruoso> FROGGS: jvm('javax.servlet.Servlet') makes some sense as well, maybe even more explicit jvm::type('javax.servlet.Servlet')

[11:40] *** sqirrel joined
[11:43] <ruoso> although it would probably make some sense to introduce a knowhow for build pure jvm classes without the wrapper

[11:49] *** SmokeMachine joined
[11:50] <colomon> 49.7G now

[11:59] <colomon> 53.6G.  Wonder if any practical p6 program has ever used this much memory before

[11:59] * colomon really needs this to work for $work

[12:03] <jnthn> pmurias: Maybe a separate doc; I think there already is some file that tries to list the nqp ops, but maybe it's easier to generate that from the actual set of them in the compiler...

[12:04] <jnthn> ruoso: There's no reason to write knowhow's for any of this, we can build them out of higher level things...

[12:04] <jnthn> ruoso: But yeah, I expect we'll want a meta-object type or two for representing the Java stuff.

[12:04] <jnthn> I can see a trait as a possibility too...

[12:05] <jnthn> Maybe overloading does there is icky-ish.

[12:06] <ruoso> that was my initial thought

[12:06] <ruoso> because the way the thing is composed is completely different

[12:06] <pmurias> jnthn: there exists a file, but seems to contain parroty and outdated stuff

[12:06] <jnthn> pmurias: Well, it probably describes the mappings, which are not so interesting in a way

[12:07] <jnthn> pmurias: They probably were then nqp:: ops were new and folks were used to the Parrot ops. These days, it's less that way :)

[12:07] <jnthn> s/then/when/

[12:08] <jnthn> colomon: You'll probably find that the memory limits for Rakudo on JVM are set quite low

[12:08] <pmurias> yes, that's that plus a long and detailed description of nqp::deb

[12:09] <pmurias> do we even use nqp::deb anymore?

[12:09] <daxim> diakopter, fix the goo.gl links in your application.  http://goo.gl/W5mI0 is access-restricted and http://goo.gl/WLJUQ is 404

[12:12] <colomon> jnthn: how to change that?

[12:14] <jnthn> colomon: Tweak the memory flags in the perl6.sh

[12:14] <jnthn> There's probably one which is setting a limiti of 2g or so

[12:14] *** benabik joined
[12:15] <jnthn> Hm, and it'd be good for me to run what you're doing under an allocation profiler at soem point to work out where on earth all the memory is going :)

[12:16] *** sqirrel left
[12:17] <colomon> the code's all up on github, I can easily get you the test file and run you through how to invoke it

[12:17] <colomon> 57.1G now

[12:17] <jnthn> OK...though teaching at the moment :)

[12:18] <colomon> -Xms100m  ?

[12:18] <jnthn> "teaching"...actually waiting while exercises get done :)

[12:18] <jnthn> no, that's starting size

[12:18] <jnthn> Is there a -Xmx option?

[12:19] <jnthn> I tink that's the one to set

[12:19] <colomon> no, not in perl6 the script

[12:19] <jnthn> OK, you can add one after the -Xms

[12:19] <colomon> RUN_PERL6 = $(JAVA) -Xms500m -Xmx2g in the Makefile....

[12:19] <jnthn> Yeah, so that means "max 2 gigs"

[12:19] <jnthn> So you can set it to whatever you think it'll need

[12:21] <colomon> trying....

[12:23] <diakopter> í'

[12:25] <colomon> woah, without the (default?) GC limit, jakudo performs much better

[12:26] <diakopter> daxim: actually I forgot to redact those links entirely

[12:28] <colomon> 1m11s under parrukdo, 46s under jakudo

[12:29] <jnthn> :)

[12:29] <jnthn> And this is before we start doing much optimization work :)

[12:30] <diakopter> daxim: oops

[12:30] <jnthn> (As opposed to Parrot where we've been trying to optimize stuff for a while...)

[12:31] <colomon> jnthn: better be pre-optimization, we still need a at least an order of magnitude improvement!  ;)

[12:32] <jnthn> colomon: Indeed.

[12:32] <jnthn> colomon: The optimizer isn't actually fully functional on JVM yet either...

[12:32] <colomon> I'm guessing there are some good Java profilers out there?

[12:33] <jnthn> yeah...

[12:33] *** domidumont joined
[12:34] <colomon> also, of course, I've made very little effort to optimize this script.  I'm pretty sure reducing the memory usage by 14% should be quite easy.

[12:35] *** logie joined
[12:35] <colomon> this is the point in the conversation when I need to start whispering to myself "First get it right…"

[12:36] <jnthn> Yes, that's what I keep reminding myself on the JVM port

[12:36] <jnthn> "we still aren't quite there on spectets yet" :)

[12:36] <diakopter> colomon: jvisualvm is quite good, but there are also some for-pay ones

[12:38] <diakopter> and then there are those of us who include "long term designed for optimized performance" in that "get it right" definition

[12:39] *** pmurias left
[12:40] <diakopter> (in other words, if you can't ignore performance at any stage, where do yoy draw the line?

[12:40] <diakopter> )

[12:41] <diakopter> *you

[12:43] <diakopter> my point is that you can't claim you are completely ignoring performance

[12:43] <diakopter> bbiab

[12:44] <timotimo> colomon: are you sure parrot isn't suffering heavily from GC sweeps when parts of your ram are swapped out?

[12:45] *** logie left
[12:46] <colomon> timotimo: I'd be surprised if that was the case on my tiny test model (which is what those timings correspond to)

[12:47] <timotimo> ah

[12:47] <colomon> diakopter: certainly, completely ignoring performance is a Very Bad Plan

[12:47] <timotimo> i was thinking about the one that's been growing to almost 2x your ram size ;)

[12:47] <timotimo> fwiw, i've just noticed a ridiculous ram usage for something not very big. perhaps you're being bitten by that, too.

[12:48] <colomon> timotimo: well, that one almost certainly is suffering from GC sweeps, but I'm not comparing that timing to anything else right now, I'm just praying it finishes correctly sometime in the next few hours

[12:48] <timotimo> (that was when running a recursive dir with a few maps and greps on the result and storing them into a list of pairs would take about 1.2 gb for ~150 files)

[12:48] <colomon> it's not actually twice my ram yet, but it will be there pretty soon at the current rate.

[12:48] <colomon> 59.6G virt, 32G actual

[12:49] <timotimo> ah, ok

[12:49] <timotimo> i don't think IO::Path objects are that big, so i'd call the memory usage ...

[12:49] <timotimo> *puts on sunglasses*

[12:49] <timotimo> pathological

[12:50] *** pmurias joined
[12:50] <tadzik> :D

[12:51] <pmurias> jnthn: what do we use the fates list in a NFA repr for? it's set, serialized and deserialize but doesn't seem to be used anywhere?

[12:54] *** crab2313 joined
[12:57] *** konundra joined
[13:02] *** logie joined
[13:02] *** rindolf joined
[13:05] <colomon> Arrrgh!  the script died.  :(

[13:09] <timotimo> aaw man :(

[13:09] <colomon> nothing for it but to try jakudo now

[13:10] <colomon> with -Xmx64g

[13:10] <timotimo> huh. i can't ConfigureJVM.pl --with-nqp=nqp/install/nqp, because it throws an NPE at org.perl6.nqp.runtime.Ops.invokeMain(Ops.java:1622) at org.perl6.nqp.runtime.CompilationUnit.enterFromMain(CompilationUnit.java:61) at nqp.main(src/stage2/gen/NQP.nqp)

[13:10] <timotimo> anyone seen this before?

[13:12] *** PacoAir joined
[13:13] *** kaare__ joined
[13:13] <colomon> woah, using -Xmx64g, java went right out and allocated 68G!

[13:13] <moritz> because you told it to!

[13:13] <moritz> or, something similar :-)

[13:14] <pmurias> that should be enough for even the most greedy of rakudos ;)

[13:18] <colomon> moritz: I thought I was telling it, "You can get this big", rather than "You MUST get this big!"

[13:19] *** ecocode joined
[13:21] *** ajr joined
[13:22] *** ajr is now known as Guest75637

[13:22] <Woodi> hallo :)

[13:24] <Woodi> in filesystems files have links counter and when counter hit zere file is deleted, GCed in some kind with nice optimization (NoOp :) ) for area cleaning...

[13:26] <Woodi> I wonder about objects and finalization... objects are like files visible in FS, when ref cound hit zero finalizers starts and memory is collected...

[13:26] *** Guest75637 is now known as ajr_

[13:27] <Woodi> but, for me, there are two kinds of "finishing" objects: low level memory GC and declared finalizers (eg. manual structure cleaning)

[13:28] <Woodi> I think declared finalizers can be fired just after reference counter hits zero and GC work can be postponed/run in paraller/ommited...

[13:29] <moritz> but Perl 6 doesn't mandate reference counting

[13:29] <moritz> refcounting has obvious problems with circular references, so the idea is to use "proper" GC instead

[13:30] <Woodi> but objects "disappear" from namespace probably is equal to 0 ref count...

[13:30] <Woodi> and in that time finalizers can be fired...

[13:31] <Woodi> and GC work is low level cleaning...

[13:31] <moritz> but we don't refcount.

[13:31] <moritz> doing refcounting AND gc is just wasteful

[13:32] <moritz> and '"disappear" from namespace' isn't well defined

[13:32] <Woodi> I say that becouse erlier talks goes straight from finalizers to memory gc...

[13:32] <Woodi> when in Perl 6 objects stops to be visible ?

[13:32] <colomon> okay, 13M STEP file read and parsed, took 24 minutes

[13:33] <colomon> so now it's doing the reverse lookup table

[13:33] * colomon is starting to suspect jakudo may crush parrakudo on performance here….

[13:33] <pmurias> jnthn: I figure out that on parrot .fates is used for determining the size of an array (while diagnosing a segfault ;)

[13:34] *** grondilu joined
[13:36] <colomon> crap, java run fails with java.lang.StackOverflowError

[13:36] <colomon> I guess at least it was fast

[13:37] <arnsholt> There's an -Xfoo option to increase the stack size like -Xmx does for the heap

[13:37] <colomon> -Xss

[13:37] <arnsholt> -Xms maybe?

[13:37] <arnsholt> Right, right

[13:37] <colomon> I'm trying to ponder why the stack would overflow before I just do that

[13:38] <arnsholt> Parsing perhaps?

[13:38] <colomon> the parsing stage is already done at that point.

[13:39] <arnsholt> In that case, I have no idea

[13:41] <Woodi> I think finalizers are important and need to fire them should be somehow detected earlier then full gc is fired becouse mem collection can be sometimes ommited...

[13:42] <Woodi> just naive thinking, of course...

[13:43] *** skids joined
[13:47] <crab2313> failed building nqp-cc using the latest nqp and parrot, https://gist.github.com/crab2313/6070706, anyone seen this before?

[13:48] *** xilo joined
[13:49] <FROGGS> crab2313: I can just say it works using parrot 5.2.0

[13:49] <FROGGS> never tested 5.6 though

[13:49] <FROGGS> brb

[13:50] <crab2313> FROGGS: thanks

[13:52] *** btyler joined
[13:59] *** dmol joined
[14:02] <dalek> nqp: 9e2d04c | (Pawel Murias)++ | t/nqp/74-nfa.t:

[14:02] <dalek> nqp: Add a very basic test for our NFA matcher.

[14:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9e2d04c972

[14:11] *** eirini_k joined
[14:11] *** orafu joined
[14:12] *** eirini_k left
[14:23] *** FROGGS joined
[14:30] <[Coke]> moritz: ping.

[14:32] *** woosley1 joined
[14:32] <moritz> [Coke]: pong

[14:33] *** kingbeast joined
[14:34] <[Coke]> moritz: we had the first Albany.pm meetin glast night in ages. Your name was dropped, and not by me.

[14:34] <pmurias> moritz: actually a lot of the reference counting implementations also do a gc run from time to time to collect cycles

[14:34] <[Coke]> Guy apparently "knows" you from your p5 (&p6) posts on perlmonks.

[14:36] <[Coke]> I disagree with RT #119001 - Main's arguments are *special*. if Rob doesn't want an Int, he should pick Any. meh?

[14:36] <[Coke]> Probably needs a documentation patch to make it more clear, I'd expect.

[14:37] *** stevan_ joined
[14:37] *** Psyche^_ joined
[14:37] <pmurias> Woodi: doing ref counting on some of the platform we target would be super inefficent (like on the JVM), so Perl 6 can't guarantee when the finalizers will run

[14:38] <moritz> [Coke]: nice to hear :-)

[14:38] <moritz> [Coke]: re Main, the spec says that the return values from val() (which MAIN_HELP should use) should still comply to type Str

[14:39] <hoelzro> [Coke]: I'm ok with that, as long as things are less surprising when developing =)

[14:40] <hoelzro> but it *is* a little misleading to users if they type an argument and Perl 6 says "hey, you need to provide an argument"

[14:40] <[Coke]> moritz: so it is just reduced to "we don't have IntStr yet?"

[14:40] <[Coke]> hoelzro: the error message shows the type, IIRC.

[14:41] <hoelzro> my example doesn't

[14:42] <[Coke]> hokay.

[14:44] <hoelzro> I think that converting arguments to sensible types makes sense, but if no candiates are found with the signature, there should be a fallbcak

[14:44] <hoelzro> *fallback

[14:47] *** cognominal left
[14:54] *** FROGGS left
[14:57] <moritz> [Coke]: yes

[14:57] *** JimmyZ joined
[15:02] *** kaare_ joined
[15:03] *** konundra left
[15:03] *** crab2313 left
[15:03] <dalek> roast: deadbef | coke++ | S32-io/slurp.t:

[15:03] <dalek> roast: refudge for rakudo.jvm

[15:03] <dalek> roast: review: https://github.com/perl6/roast/commit/deadbef167

[15:03] *** kaare__ left
[15:04] *** woosley1 left
[15:07] *** woosley1 joined
[15:07] *** woosley1 left
[15:10] *** Rix joined
[15:11] *** crab2313 joined
[15:12] *** rindolf left
[15:12] *** rindolf joined
[15:17] *** crab2313 left
[15:19] *** brrt left
[15:20] *** rindolf left
[15:21] *** rindolf joined
[15:21] *** ajr_ left
[15:21] <colomon> Huh.  It seems categorize is really slow?  

[15:23] *** ajr joined
[15:23] *** cognominal joined
[15:23] *** timotimo left
[15:23] *** ajr is now known as Guest54954

[15:23] <colomon> well, the operation I am doing with categorize.  might be something else in that line of code

[15:24] <colomon> even on the small model it takes longer to do my categorize call than it does to read the file and parse it completely

[15:26] *** Guest54954 is now known as ajr_

[15:26] <arnsholt> Yeah, that sounds wrong. Might be worth profiling it and see if there's something fishy in Rakudo's implementation?

[15:29] *** timotimo joined
[15:30] <colomon> arnsholt: yeah.  definitely seems like a priority.  but I don't know the right way to tackle profiling this.

[15:31] * colomon has developed a fear that it's iterators that are the problem here…

[15:31] *** rindolf left
[15:32] *** rindolf joined
[15:32] <arnsholt> First thing is probably to profile your code and see if the hotspot is actually in Rakudo rather than your code

[15:34] <arnsholt> Not sure how to best profile Rakudo itself though. But IIRC there're some Parrot-level tooling

[15:41] *** kaleem joined
[15:44] *** dmol left
[15:47] *** rindolf left
[15:47] *** rindolf joined
[15:47] <dalek> Perlito: a6bb050 | (Flavio S. Glock)++ | / (5 files):

[15:47] <dalek> Perlito: Perlito5 - fix strictness in eval() and require()

[15:47] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/a6bb050faa

[15:51] <perigrin_> I have a question ... is there a reference on attribute initialization somewhere I can see? (test are fine, I'm trying to sort out a syntax question for p5-mop-redux)

[15:54] <PerlJam> perigrin_: S12:762 maybe?

[15:54] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_762

[15:56] <perigrin_> PerlJam: thanks ... the links to the tests there helped I think.

[16:01] *** dmol joined
[16:03] *** rindolf left
[16:03] *** rindolf joined
[16:14] *** logie left
[16:14] *** pmurias left
[16:16] *** cognominal left
[16:16] *** kaleem left
[16:19] *** rindolf left
[16:19] *** rindolf joined
[16:20] *** domidumont left
[16:25] *** fhelmberger left
[16:25] <lizmat> colomon, jnthn: categorize is *dead* simple.  The only optimization I can think of there is to use postfix for

[16:26] <lizmat> but jnthn told me, that shouldn't make a difference if there are no lexicals inside the scope

[16:26] <lizmat> I wonder though whether each store in the hash creates a .WHENCE that doesn't get GC'd ?

[16:27] <colomon> lizmat: I understand it's dead simple.  That doesn't mean it's fast.

[16:27] <colomon> lizmat: I mean, I don't know where the problem lies here.

[16:27] <colomon> it could be for, it could be push, it could be something in the code block I pass in

[16:28] <lizmat> I wouldn't be at all surprised it's the .WHENCE that's causing the problem there

[16:28] <colomon> All I know is the performance is *terrible*

[16:28] <colomon> when it's slower than file I/O and parsing the entire file, you know something is up.

[16:28] <lizmat> I wonder: do you need all the categorized entries as well, or would a count do for you as well ?

[16:29] <colomon> I need them

[16:29] <colomon> The goal is basically to set up a bi-directional graph, so that given an entity I can find all the entities that reference it.

[16:29] <colomon> (and all the ones it references)

[16:30] <lizmat> also: in the current setup, the push() is *copying* values

[16:30] <lizmat> I wonder whether how the memory usage would be if we would bind instead

[16:30] <lizmat> possibly as an adverb on push as well ?

[16:31] <colomon> In this case, at least, the values being copied are just short (approx 7 characters on average) strings.

[16:31] <lizmat> @a.push(@b, :bind )

[16:31] <colomon> We really need to profile instead of guess, I just don't know the best approach for doing that currently.

[16:32] <lizmat> I think it's the number of containers with the associated .whences

[16:35] *** rindolf left
[16:35] *** rindolf joined
[16:41] <moritz> what do I use for === in NQP?

[16:44] <moritz> maybe =:=

[16:46] <lizmat> colomon: spectesting some performance tweaks on push()

[16:48] <colomon> lizmat++

[16:53] *** Guest1337 joined
[16:53] *** rindolf left
[16:53] *** rindolf joined
[17:02] *** rindolf left
[17:02] *** rindolf joined
[17:03] *** spider-mario joined
[17:12] *** SamuraiJack joined
[17:18] *** dakkar left
[17:18] *** xinming joined
[17:18] *** abnorman joined
[17:22] *** rindolf left
[17:22] *** ajr_ left
[17:22] *** rindolf joined
[17:23] *** ajr joined
[17:23] *** ajr is now known as Guest50979

[17:23] *** Guest50979 left
[17:27] *** ecocode left
[17:39] <lizmat> colomon: adding another candidate for .push for a single value, breaks the spectest massively

[17:39] <lizmat> I have no idea what's going on

[17:39] <colomon> lizmat: I'm trying a different approach here, to see if it helps.

[17:40] <lizmat> https://gist.github.com/lizmat/6072726 is what I've done so far

[17:40] <lizmat> I'm off to see a movie, will be back later&

[17:41] *** rindolf left
[17:41] *** FROGGS joined
[17:41] <colomon> lizmat++

[17:41] *** rindolf joined
[17:50] *** abnorman left
[17:50] *** rindolf left
[17:51] *** rindolf joined
[17:53] *** logie joined
[18:00] *** abnorman joined
[18:00] * colomon now has a significantly faster solution which uses sets instead of categorize.  :)

[18:07] *** Guest1337 left
[18:07] *** FOAD joined
[18:10] * colomon tries it on the 13M model

[18:11] *** rindolf left
[18:12] *** rindolf joined
[18:19] *** pochi joined
[18:21] <colomon> It's actually a really fun use of sets.  the original code took a given face in the file and followed the references until it had a list of all the face's edges.  The it started from each edge and used the reverse index (created by categorize) to walk back to the faces.

[18:21] <colomon> The new version just creates a set of edges for each face in the model, then looks for those sets that intersect the given face's set.

[18:26] <colomon> note that the jakudo version takes a crazy long time to start-up -- about ten seconds.  Must have something to do with module loading?

[18:27] <[Coke]> rakudo.jvm loading is slow to begin with.

[18:28] <colomon> right, but that's more on the order of 2 or 3 seconds, I think

[18:29] *** rindolf left
[18:30] *** rindolf joined
[18:30] *** daxim left
[18:31] *** bluescreen10 joined
[18:37] *** iSlug joined
[18:47] *** rindolf left
[18:48] *** rindolf joined
[18:52] *** rindolf left
[18:52] *** rindolf joined
[18:59] *** iSlug left
[19:01] <dalek> Perlito: f4ffaad | (Flavio S. Glock)++ | / (5 files):

[19:01] <dalek> Perlito: Perlito5 - indirect-object - all tests pass

[19:01] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/f4ffaadf90

[19:08] <jnthn> evening, #perl6

[19:10] <FROGGS> jnthn: o/

[19:10] <timotimo> heyo jnthn :)

[19:10] *** ajr joined
[19:11] *** ajr is now known as Guest6345

[19:11] *** Guest6345 is now known as ajr_

[19:12] *** logie left
[19:18] *** rindolf left
[19:29] *** konundra joined
[19:30] *** sqirrel joined
[19:34] <dalek> perl6-roast-data: 4f01b22 | coke++ | / (5 files):

[19:34] <dalek> perl6-roast-data: today (automated commit)

[19:34] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/4f01b22681

[19:35] <[Coke]> jnthn: the buf skip was still protecting a skippable offense.

[19:40] *** Guest9814 left
[19:44] <colomon> skips behind skips...

[19:45] <[Coke]> jnthn: https://gist.github.com/coke/6073852

[19:45] <[Coke]> different error, on the jvm. looks like $/ in an exception handler is wonky?

[19:51] <jnthn> [Coke]: Yeah, never got to the bottom of that one yet...

[19:55] *** eirini_k joined
[19:57] *** stevan_ left
[20:00] <eirini_k> \msg FROGGS

[20:01] *** kaare_ left
[20:07] *** logie joined
[20:12] <dalek> Perlito: bad489f | (Flavio S. Glock)++ | TODO-perlito5:

[20:12] <dalek> Perlito: Perlito5 - parser - TODO list

[20:12] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/bad489f63a

[20:20] <timotimo> i left my desktop in a state that doesn't seem to let me ssh toit:(

[20:21] <timotimo> all my recent work is on that computer :|

[20:22] *** iSlug joined
[20:31] <lizmat> Now You See Me

[20:32] *** zakalwe joined
[20:32] *** zakalwe left
[20:32] *** zakalwe joined
[20:32] <lizmat> .oO( teaches you all about preparation, like all the work that has been done that now allows VM's to be added to rakudo so easy)

[20:32] <lizmat> easily

[20:35] *** sqirrel left
[20:39] * grondilu suggested adding .entropy to Bag:  http://rosettacode.org/wiki/Entropy#Perl_6   Not that it'd be terribly useful, but it'd be cool.

[20:43] *** pmurias joined
[20:43] *** wk joined
[20:44] *** wk is now known as Guest94658

[20:46] <lizmat> jnthn, FROGGS: do I need to nqp::unbox_i() a native int, or is this just for Int ?

[20:47] <jnthn> lizmat: An int is already unboxed

[20:47] <jnthn> lizmat: That's almost the definition of a native type :)

[20:47] <lizmat> thought as much, :-)

[20:48] <jnthn> ffs, it's humid...

[20:48] <lizmat> Still 25+ here

[20:49] <jnthn> We're due some rain tomorrow, which I hope will cool things

[20:49] <lizmat> it did over here, but that was yesterday  :-(

[20:50] <lizmat> is there a way to select a MMD candidate depending on the value of a method call on that object?

[20:50] <dalek> rakudo-js: 4038197 | (Pawel Murias)++ | / (2 files):

[20:50] <dalek> rakudo-js: Implement nfafromstatelist and a partial nfarunproto.

[20:50] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/4038197180

[20:51] <lizmat> thinking maybe we should have a candidate for handling infinite lists, so self.infiinite would be true

[20:53] <jnthn> I guess you can do it in a where clause?

[20:53] <jnthn> where .infinite

[20:53] <jnthn> No promises on efficiency :)

[20:53] <lizmat> let's see how it works out  :-)

[20:55] <__sri> http://words.steveklabnik.com/beware-subclassing-ruby-core-classes # go home ruby, you're drunk!

[20:56] *** SamuraiJack left
[21:01] <lizmat> jnthn: Any contains a proto for push(), but List doesn't

[21:01] <lizmat> is the fact that List ~~ Any enough to "see" that prototype in List?

[21:02] <lizmat> I guess that makes sense, yes, forget it  :-)   argle bargle

[21:02] <lizmat> too much Baileys at the movies  :-)

[21:08] *** BenGoldberg joined
[21:13] *** skids left
[21:13] <BenGoldberg> rn: my @foo := 42 xx 1e5; @foo.Int.say

[21:13] <camelia> rakudo 9ba5dd: OUTPUT«(timeout)»

[21:13] <camelia> ..niecza v24-88-g1f87209: OUTPUT«100000␤»

[21:13] *** eirini_k left
[21:14] *** konundra left
[21:16] <jnthn> lizmat: Yes, it's enough.

[21:17] <jnthn> (Enough proto, and apparently enough Baileys :P)

[21:17] <lizmat> actually, they ran out of Baileys  :-(   and probably won't have any new tomorrow when we're going to see Wolverine

[21:18] <lizmat> fwiw, I never realized how important .push was in rakudo

[21:19] <lizmat> every sub call seems to do a .push on the stack

[21:19] *** donaldh joined
[21:22] *** spider-mario left
[21:22] <jnthn> Huh?

[21:23] <BenGoldberg> I've got a really silly question: How useful would it be (and how hard would it be to create) a Bool::Unknown object, which would throw a runtime exception whenever it's tested for truth (especially, when used in an if () or similar)

[21:24] <benabik> Nil?

[21:24] <jnthn> r: class Bool::Unknown { method Bool() { die "Can't test this" } }; my $a = Bool::Unknown.new; if $a { say 'hmm...' }

[21:24] <camelia> rakudo 9ba5dd: OUTPUT«Can't test this␤  in method Bool at /tmp/1VD46mboC1:1␤  in block  at /tmp/1VD46mboC1:1␤␤»

[21:24] <lizmat> Nil is False

[21:24] <BenGoldberg> rn: my $foo = Nil; if( $foo ) { say True } else { say False }

[21:24] <camelia> rakudo 9ba5dd: OUTPUT«===SORRY!===␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens␤at /tmp/cDgOd8L4Tx:1␤------> my $foo = Nil; if⏏( $foo ) { say True } else { say False }␤Unexpected block in infix position (two …

[21:24] <camelia> ..niecza v24-88-g1f87209: OUTPUT«===SORRY!===␤␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens at /tmp/_POK2gy_Vy line 1:␤------> my $foo = Nil; if⏏( $foo ) { say True } else { say False }␤Unexpected block in infi…

[21:24] <BenGoldberg> rn: my $foo = Nil; if ( $foo ) { say True } else { say False }

[21:25] <camelia> rakudo 9ba5dd, niecza v24-88-g1f87209: OUTPUT«False␤»

[21:26] <BenGoldberg> And the section part of my silly question?  For example, I definitely think .infinite should Bool::Unknown, rather than Nil or Mu

[21:27] <BenGoldberg> s/section/second

[21:27] <lizmat> how about Bool ?

[21:28] <lizmat> the type object ?

[21:28] <BenGoldberg> rn: my $foo = Bool; if( $foo ) { say True } else { say False }

[21:28] <camelia> niecza v24-88-g1f87209: OUTPUT«===SORRY!===␤␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens at /tmp/mtqAaOGinu line 1:␤------> my $foo = Bool; if⏏( $foo ) { say True } else { say False }␤Unexpected block in inf…

[21:28] <camelia> ..rakudo 9ba5dd: OUTPUT«===SORRY!===␤Word 'if' interpreted as 'if()' function call; please use whitespace instead of parens␤at /tmp/5_wW9_GqOp:1␤------> my $foo = Bool; if⏏( $foo ) { say True } else { say False }␤Unexpected block in infix position (two…

[21:28] <BenGoldberg> rn: my $foo = Bool; if ( $foo ) { say True } else { say False }

[21:28] <camelia> rakudo 9ba5dd, niecza v24-88-g1f87209: OUTPUT«False␤»

[21:28] <benabik> BenGoldberg: So that your code explodes if you try to find out if something is infinite?

[21:29] <lizmat> rn: my $foo = Bool; if $foo.defined { say "Dunno" } elsif $foo { say True } else { say False }

[21:29] <camelia> rakudo 9ba5dd, niecza v24-88-g1f87209: OUTPUT«False␤»

[21:29] <lizmat> rn: my $foo = Bool; if !$foo.defined { say "Dunno" } elsif $foo { say True } else { say False }

[21:29] <camelia> rakudo 9ba5dd, niecza v24-88-g1f87209: OUTPUT«Dunno␤»

[21:29] <BenGoldberg> So that your code explodes if you try to find out if something is infinite, and the answer is "I don't know" and you foolishly treat "I don't know" as a true or as a false

[21:31] <donaldh> correct me if I'm wrong but doesn't idiomatic Perl expect undefined values in Boolean context to return false?

[21:31] <lizmat> it does

[21:31] <donaldh> Kinda relied on for code like die "blah" unless $option;

[21:32] <donaldh> hence, if you care about definedness then you use .defined 

[21:33] <BenGoldberg> Basically, I'd like (1..Inf).infinite to return True, (1..5).infinite to return False, and (gather { ... }).infinite to return Bool::Unknown

[21:33] <lizmat> which is essentially Bool as a type object

[21:34] <benabik> Except that Bool is False.

[21:34] <BenGoldberg> r: if ( Bool ) { say "Foo!" } 

[21:34] <camelia> rakudo 9ba5dd:  ( no output )

[21:35] <BenGoldberg> I guess I'd like it to be class Bool::Unknown { method Bool() { die "Bool::Unknown is neither true nor false" } }; 

[21:36] <lizmat> the problem is that I don't think we actually have anything like a "Boolean" context

[21:36] <FROGGS> benabik: Bool::Unknown in boolean context can either be trueish or falseish, so if that tends to be falseish you can use Bool instead 

[21:36] <BenGoldberg> trueish falsish and dieish?

[21:37] <FROGGS> BenGoldberg: that should do

[21:38] *** donaldh left
[21:38] <BenGoldberg> It's too bad that none(True,False) doesn't do what I want :)

[21:38] <FROGGS> what if .infinite would return a Failure? would that get thrown?

[21:38] <benabik> FROGGS: I see how Unknown would work, which has nothing to do with what I said.  I said Bool::Unknown isn't Bool because Bool is false and Unknown is explodey.

[21:38] <jnthn> booleanization defuses fails

[21:38] <jnthn> uh, boolification

[21:39] <jnthn> lizmat: (boolean context) prefix:<?> is the boolean contextualizer, and calls .Bool

[21:40] <lizmat> but is that what happens inside of an if {} ?

[21:40] <FROGGS> benabik: yeah, I think I had put your sentence in the wrong context :o)

[21:40] *** fridim_ joined
[21:41] <FROGGS> lizmat: I think so

[21:41] <FROGGS> r: my class A { method Bool { say "what?" } }; my $a = A.new; say "uhh" if $a

[21:41] <camelia> rakudo 9ba5dd: OUTPUT«what?␤uhh␤»

[21:42] <FROGGS> r: my class A { method Bool { say "what?"; 0 } }; my $a = A.new; say "uhh" if $a

[21:42] *** PacoAir left
[21:42] <camelia> rakudo 9ba5dd: OUTPUT«what?␤»

[21:42] <FROGGS> r: my class A { method Bool { say "what?"; 0 } }; say "uhh" if A

[21:42] <camelia> rakudo 9ba5dd: OUTPUT«what?␤»

[21:43] <BenGoldberg> class B::U { method Bool() { die "neither true nor false" } }; my $foo = B::U; say "?" if $foo;

[21:43] <BenGoldberg> r: class B::U { method Bool() { die "neither true nor false" } }; my $foo = B::U; say "?" if $foo;

[21:43] <camelia> rakudo 9ba5dd: OUTPUT«neither true nor false␤  in method Bool at /tmp/D3UksPEygn:1␤  in block  at /tmp/D3UksPEygn:1␤␤»

[21:43] <pmurias> is there a common use for .infinite?

[21:44] <lizmat> it's used as a check on many list methods

[21:44] <lizmat> e.g., you cannot push onto an infinite list

[21:44] *** iSlug left
[21:44] <lizmat> nor can you pop from an infinite list

[21:46] <pmurias> and what happens if we pop from a list of unknown finiteness? we hope it's finite?

[21:46] <lizmat> it will then try to reify the list completely and hang if it turns out to be infinite after all

[21:48] <pmurias> so for our purposes the current semantics are optimal

[21:49] <BenGoldberg> That's what it does right now, because .infinite returns Nil (which acts like false) if a list is unknown finiteness.  If we treat lists whose finiteness is unknown *separately* from True and False, we could do something different... like reify the first few thousand elements, and if the list keeps going and going, throw an error.

[21:50] *** yoleaux joined
[21:50] *** ChanServ sets mode: +v yoleaux

[21:50] <BenGoldberg> Sort of like how perl5 produces a warning if you recurse too deeply

[21:50] <BenGoldberg> Naturally, since this is perl6, it would be a *resumable* error that gets thrown

[21:52] <lizmat> sounds like a plan to me, let's see what TimToady / pmichaud think about it (since pmichaud wrote most of the lazy list stuff, I believe)

[21:53] <lizmat> r: my %h=a=>1,b=>2; my $p=<a b>; say %h{$p}  # is this a rakudobug, or expected behaviour?

[21:53] <camelia> rakudo 9ba5dd: OUTPUT«(Any)␤»

[21:53] * jnthn waves at the halting problem

[21:53] <jnthn> lizmat: Yeah

[21:53] <jnthn> lizmat: We have a bug like that in the past.

[21:53] <pmurias> BenGoldberg: does the distinction between a list of unnknown finitneness and a fininite one offer us much?

[21:54] <jnthn> r: my @a = 1,2,3; say @a[[1,2]]

[21:54] <camelia> rakudo 9ba5dd: OUTPUT«3␤»

[21:54] <jnthn> That used to slice.

[21:54] <BenGoldberg> rn: gather { }.[0].say

[21:54] <camelia> niecza v24-88-g1f87209: OUTPUT«(Any)␤»

[21:54] <camelia> ..rakudo 9ba5dd: OUTPUT«Nil␤»

[21:54] <lizmat> jnthn: is that something I broke?

[21:54] <jnthn> Which is rather surprising if you don't expect an item to flatten ;)

[21:54] <jnthn> lizmat: The 3 there is correct.

[21:54] <jnthn> lizmat: It used to give back (2,3) I think

[21:55] <lizmat> then so the the Any in the "say %h{$p}" case ?

[21:55] <jnthn> lizmat: Yeah, $p is an item

[21:55] <jnthn> lizmat: So it's treated as a single thing, not as a list of elements to look up.

[21:55] <lizmat> so we use the stringification of the item as the key, and then don't find anything

[21:56] <pmurias> BenGoldberg: finite list could be so large that for practicall purposes it will be infinite (like a range)

[21:56] <BenGoldberg> pmurias: it could allow rakudo to avoid completely hanging, if an infinite list is mistaken for a finite one

[21:56] <benabik> r: my %h=a=>1,b=>2; my $p=<a b>; say %h{@$p}

[21:56] <camelia> rakudo 9ba5dd: OUTPUT«1 2␤»

[21:56] <jnthn> lizmat: correct

[21:57] <pmurias> BenGoldberg: but a very large one will also cause rakudo to hang

[21:57] <jnthn> lizmat: btw, the build problems you had last night are all gone now?

[21:57] <lizmat> jnthn: yes, they were all fixed by that one commit you did early this morning

[21:57] <jnthn> lizmat: OK, good

[21:58] <jnthn> Realized what it was while failing to sleep...

[21:59] <BenGoldberg> pmurias: Suppose I've got a finite list, and I .push an element onto the end.  No problem, you just do it.  Suppose I've got an infinite list, and I .push an element onto the end.  No problem, just die with an error.  Suppose I've got a list of unknown finite-ness... if we treat it as infinite, we could be wrong (dieing when we shouldn't), and if we treat it as finite, we could be wrong (hanging 

[21:59] <BenGoldberg> forever, when we should die).  By identifying it as unknown, and treating it sepearately, we can repeatedly reify $X elements, and die with a resumable exception, until the list runs out or the user chooses not to resume the exception

[22:00] *** bluescreen10 left
[22:00] *** logie left
[22:01] <lizmat> fwiw, makes sense to me

[22:02] <BenGoldberg> pmurias: Right now, lists of unknown-finiteness are treated as finite lists.  The get reified when you .push onto the end.  and, yes, sometimes it hangs :(

[22:05] <lizmat> r: my $p=<a b>; my @a; @a.push($p); say @a.perl

[22:05] <camelia> rakudo 9ba5dd: OUTPUT«Array.new($("a", "b"))␤»

[22:05] <pmurias> r: my $foo=1..(10**(10**10));say $foo[0];

[22:05] <camelia> rakudo 9ba5dd: OUTPUT«1␤»

[22:06] <BenGoldberg> r: my @foo := 1..1e99; @foo.push(42); say "Alive"

[22:06] <camelia> rakudo 9ba5dd: OUTPUT«Cannot call 'push'; none of these signatures match:␤:(Any:U \SELF: *@values, Mu *%_)␤  in method push at src/gen/CORE.setting:1448␤  in block  at /tmp/oqTt9RL_Le:1␤␤»

[22:06] <jnthn> YOu can't push to a range.

[22:06] <pmurias> BenGoldberg: There are lists that are finite but will cause as to hang forever when we reify

[22:06] <BenGoldberg> r: my @foo := gather { take for 1..1e99 }; @foo.push(42); say "Alive"

[22:07] <camelia> rakudo 9ba5dd: OUTPUT«(timeout)»

[22:07] <jnthn> .take

[22:07] <BenGoldberg> r: my @foo := gather { .take for 1..1e99 }; @foo.push(42); say "Alive"

[22:07] <jnthn> But yeah, will likely still time out :)

[22:07] <camelia> rakudo 9ba5dd: OUTPUT«(timeout)»

[22:07] <BenGoldberg> What does take with no args do?

[22:08] <jnthn> take an empty parcel, I guess...

[22:08] <lizmat> r: my @a; @a.push; say @a.perl  # what does .push without params do?

[22:08] <jnthn> yeah.

[22:08] <camelia> rakudo 9ba5dd: OUTPUT«Array.new()␤»

[22:08] <BenGoldberg> Seems kinda pointless :) but it's probably not worthwhile to make it illegal :)

[22:09] <jnthn> Well, it's the degenerate case of take $this, $that, $the-other

[22:09] <lizmat> r: my @a; @a.push(@a); say @a.perl  # what does .push without params do?

[22:09] <camelia> rakudo 9ba5dd: OUTPUT«Array.new()␤»

[22:09] <jnthn> Nice try ;)

[22:10] <jnthn> r: my $a = []; $a.push($a); say $a.perl # you wanted this :P

[22:10] <camelia> rakudo 9ba5dd: OUTPUT«(timeout)»

[22:10] <lizmat> jnthn: is it correct that the signature "multi method push(List:D: @values)" would accept a Parcel as @values ?

[22:11] <lizmat> getting "No such method 'shift' for invocant of type 'Parcel'"

[22:11] *** sqirrel joined
[22:11] <lizmat> on @values.shift

[22:12] <jnthn> lizmat: yes, but should it not have been *@values?

[22:12] <jnthn> r: my @a = 1,2,3; my @b; @b.push(@a); say @a

[22:12] <lizmat> well, that's the slurpy case

[22:12] <camelia> rakudo 9ba5dd: OUTPUT«1 2 3␤»

[22:12] <jnthn> Um, there must be a bit more to it...

[22:12] <jnthn> multi method push(List:D: *@values) {

[22:12] <lizmat> I'm trying other candidates to speed things up

[22:13] <lizmat> hmmm… let's try it without the @values candidate again

[22:13] <jnthn> *nod*

[22:13] <jnthn> That'll need a little care

[22:14] <jnthn> If you add a $foo candidate then a single array will bind to it, then not be flattened correctly.

[22:14] <lizmat> you mean like "multi method push(List:D: Mu $value)" ?

[22:14] <jnthn> yeah

[22:15] <jnthn> If you just add that, I bet it breaks stuff.

[22:15] <lizmat> yes, that's why I added the @values candidate

[22:16] <jnthn> yeah, but you can't just .shift that, as you'd mutate the original thing.

[22:16] <jnthn> it'll need iterating.

[22:16] <lizmat> indeed

[22:16] <lizmat> I'll do that

[22:23] <lizmat> ok, that seems to work, spectesting 

[22:27] <lizmat> still one spectest failing, will look at it tomorrow

[22:27] <lizmat> gnight, #perl6!

[22:29] *** pmurias left
[22:30] <jnthn> 'night, lizmat 

[22:30] *** Guest94658 left
[22:35] *** skids joined
[22:38] *** ajr_ left
[22:46] <jnthn> 'night, #perl6

[22:49] *** mtk joined
[23:19] *** btyler left
[23:41] *** stevan_ joined
