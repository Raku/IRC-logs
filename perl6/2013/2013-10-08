[00:05] *** jnap left
[00:06] *** rurban joined
[00:06] *** stevan_ joined
[00:06] *** ajr_ left
[00:07] *** stevan_ left
[00:08] *** stevan_ joined
[00:10] *** rurban left
[00:12] *** Psyche^ joined
[00:16] *** [particle] joined
[00:16] *** Psyche^_ left
[00:17] *** [particle]1 left
[00:25] *** imrudbu left
[00:26] *** imrudbu joined
[00:29] *** BenGoldberg left
[00:32] *** Guest18828 left
[00:35] *** BenGoldberg joined
[00:47] *** Guest18828 joined
[01:06] <japhb__> r:

[01:06] *** rurban joined
[01:06] <japhb__> r: my $f = "foo"; my $b = "BAR"; << $f is a $b >>.perl.say;

[01:06] <camelia> rakudo d7e5e1: OUTPUT«(("foo",).list, ("is", "a"), ("BAR",).list)␤»

[01:07] <japhb__> Is that ^^^ intended?

[01:07] <japhb__> I would have expected a flattened version.

[01:11] *** rurban left
[01:19] *** prevost joined
[01:24] *** benabik joined
[01:39] <dalek> perl6-roast-data: 16f58c2 | coke++ | / (5 files):

[01:39] <dalek> perl6-roast-data: today (automated commit)

[01:39] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/16f58c258e

[01:43] *** fridim_ joined
[01:44] *** _ilbot left
[01:45] *** _ilbot joined
[01:47] *** hypolin joined
[01:51] <Util> Looking for Camelia source art or stickers. Request did not make it to Perl 6 mailing list.

[01:51] <Util> In re: http://lists.parrot.org/pipermail/parrot-dev/2013-October/007592.html

[01:55] *** btyler_ left
[01:55] <geekosaur> um, I got it

[01:56] <Util> geekosaur: You got it via parrot-dev, or via perl6-users ?

[01:57] *** woosley joined
[01:57] <geekosaur> I am not on any parrot lists

[01:58] <Util> geekosaur: OK, then I was in error about it not making it to the Perl 6 list, probably because my ISP is non-optimal. Thanks!

[02:02] *** ssutch left
[02:02] <geekosaur> so checking headers, I (as I expected) got it via the perl6-all.perl.org list

[02:04] <geekosaur> I don't know how you read mail, but some mail systems (for example gmail and cyrus imapd) suppress duplicates in such a way that you don't get your own list messages back

[02:06] <geekosaur> (in the case of cyrus, only if you save outgoing messages; it considers that the master copy and drops the incoming list copies as duplicates of it)

[02:06] *** gyutyuglf joined
[02:07] *** rurban joined
[02:11] *** rurban left
[02:14] *** REPLeffect left
[02:22] <Util> geekosaur: Thanks for the info.

[02:25] *** gyutyuglf left
[02:34] *** REPLeffect joined
[02:46] *** rurban joined
[02:47] * [Coke] enjoys some perl(er) wine, lizmat++ woolfy++

[02:47] *** rurban left
[02:48] *** prevost left
[03:03] *** ssutch joined
[03:04] *** LlamaRider joined
[03:07] <LlamaRider> Hi. Some of my rakudo code has regressed. Turns out  the regex capture variables $0, $1 ... are now of type Match, rather than Str (which is what my old code assumed them to be).

[03:10] <LlamaRider> I take it I always have to explicitly say "$0.Str" now? I was doing an @array.push($0); where @array was of Str type, which no longer compiles. $0.Str compiles again of course.

[03:10] <[Coke]> ~$0 should do the trick.

[03:10] <[Coke]> or .Str, same thing.

[03:10] * [Coke] wonders how to iterate over the result of an opendir.

[03:10] <[Coke]> (in nqp0

[03:11] *** araujo left
[03:11] <LlamaRider> what is the point of the Match type? and shouldn't it be somehow more compatible with Str ? I need to find a resource to read on that. Will add a note to my P5-to-P6 porting guide.

[03:12] <[Coke]> the match is capturing all the information about the match.

[03:13] <[Coke]> r: ("asdf" ~~ "s"); say $0.perl

[03:13] <camelia> rakudo d7e5e1: OUTPUT«Any␤»

[03:13] <[Coke]> r: ("asdf" ~~ "s").perl.say

[03:13] <camelia> rakudo d7e5e1: OUTPUT«Bool::False␤»

[03:13] <[Coke]> ... I need sleep. ;)

[03:13] <LlamaRider> r: ("asdf" ~~ "s"); say $0.WHAT;

[03:13] <camelia> rakudo d7e5e1: OUTPUT«(Any)␤»

[03:13] <LlamaRider> r: ("asdf" ~~ /./); say $0.WHAT;

[03:13] <camelia> rakudo d7e5e1: OUTPUT«(Any)␤»

[03:15] <LlamaRider> of course, no capture

[03:16] <LlamaRider> r: ("asdf" ~~ /(.)/); say $0.WHAT;

[03:16] <camelia> rakudo d7e5e1: OUTPUT«(Match)␤»

[03:16] <LlamaRider> r: ("asdf" ~~ /(<[s]>)/); say $0.perl;

[03:16] <camelia> rakudo d7e5e1: OUTPUT«Match.new(orig => "asdf", from => 1, to => 2, ast => Any, list => ().list, hash => EnumMap.new())␤»

[03:16] <LlamaRider> better :)

[03:17] *** colomon joined
[03:17] <LlamaRider> what I am practically whining about is that  I was expecting " @string_array.push($0) " to just work, without an explicit cast to $0.Str. But anyway, thanks for the input :)

[03:19] *** dayangkun left
[03:20] <LlamaRider> And yay, my P6 port of Lingua::EN::Sentence has been successively built with Rakudo on JVM for the first time.

[03:21] <LlamaRider> [Coke]++

[03:21] <LlamaRider> successfully*  (I need sleep too)

[03:22] *** REPLeffect left
[03:33] *** cognominal left
[03:35] *** fridim_ left
[03:38] *** LlamaRider left
[03:43] *** havenwood left
[03:43] *** havenwood joined
[03:44] *** REPLeffect joined
[03:48] *** havenwood left
[03:55] *** preflex left
[03:56] *** preflex_ joined
[03:56] *** ChanServ sets mode: +v preflex_

[03:56] *** preflex_ is now known as preflex

[03:58] *** havenwood joined
[04:04] *** havenwood left
[04:21] *** [Sno] left
[04:23] *** ksh joined
[04:51] *** daniel-s_ joined
[04:54] *** daniel-s left
[05:06] *** ksh left
[05:07] *** zby_home_ joined
[05:07] *** zby_home_ left
[05:16] *** BenGoldberg left
[05:22] *** baest left
[05:27] *** logie left
[05:29] <moritz> \o

[05:29] <yoleaux> 7 Oct 2013 17:29Z <[Coke]> moritz: did you fix pugs on host07?

[05:29] <yoleaux> 7 Oct 2013 20:47Z <lizmat> moritz: simply adding "is default" didn't work (Could not find sub &infix:<does>).  too tired now to try doing mixins by hand

[05:29] <moritz> p: say 42

[05:29] <camelia> pugs: OUTPUT«42␤»

[05:29] <moritz> [Coke]: what exactly needs (or needed) fixing? I simply did a 'cabal install Pugs'

[05:30] *** xinming left
[05:31] *** [Sno] joined
[05:32] *** xinming joined
[05:34] *** FROGGS left
[05:37] *** SamuraiJack__ joined
[05:37] *** ssutch left
[05:53] *** xenoterracide_ left
[05:58] *** zakharyas joined
[06:09] *** kaleem joined
[06:11] *** jlaire_ is now known as jlaire

[06:13] *** imrudbu is now known as ivanshmakov

[06:14] <masak> mood gorning, #perl6

[06:16] <masak> oh, and @gitinfo over at git also responds to things such as 'man git push'.

[06:17] *** darutoko joined
[06:21] *** SamuraiJack__ left
[06:22] *** SamuraiJack joined
[06:25] <masak> the bug at http://irclog.perlgeek.de/perl6/2013-10-07#i_7684699 has been submitted years ago.

[06:25] <masak> it's the WAT part of unifying declarations and signatures.

[06:27] *** ssutch joined
[06:29] <masak> japhb__: I don't know if http://irclog.perlgeek.de/perl6/2013-10-08#i_7685424 is intended. would be interesting to have it flatten and see if any spectests break.

[06:30] <masak> LlamaRider: $0 did not become of type Match overnight -- it's been that way for... always.

[06:30] <masak> LlamaRider: something else must have changed from under you, not that.

[06:31] *** denis_boyun joined
[06:34] *** denis_boyun left
[06:36] *** denis_boyun joined
[06:42] *** xinming left
[06:43] *** xinming joined
[06:54] <moritz> I think what changed is that typed arrays are more strictly checked these days

[06:55] <moritz> there used to be many loophole through which you could add elements of the wrong type

[06:55] <moritz> lizmat++ fixed (nearly?) all of them

[07:05] <lizmat> good *, #perl6!

[07:05] <lizmat> pretty sure not all of them

[07:05] <lizmat> r: my Int @a=^10; @a[5]:delete; say @a

[07:05] <camelia> rakudo d7e5e1: OUTPUT«0 1 2 3 4 (Any) 6 7 8 9␤»

[07:06] <lizmat> r: my Int @a=^10; @a[5]:delete; say @a; say @a[5]

[07:06] <camelia> rakudo d7e5e1: OUTPUT«0 1 2 3 4 (Any) 6 7 8 9␤(Int)␤»

[07:06] <lizmat> iterating over deleted entries in an array, always returns Any atm

[07:08] *** pochi joined
[07:08] *** lizmat_ joined
[07:11] *** Timbus|Away joined
[07:11] *** __sri joined
[07:12] *** broquain1 joined
[07:13] *** nine_ joined
[07:15] *** yeltzooo6 joined
[07:15] *** denis_boyun left
[07:16] *** mtj_ joined
[07:17] *** lizmat left
[07:17] *** nine left
[07:17] *** Timbus left
[07:17] *** denysonique left
[07:17] *** Khisanth left
[07:17] *** broquaint left
[07:17] *** mtj_- left
[07:17] *** tipdbmp left
[07:17] *** yeltzooo left
[07:17] *** Timbus|Away is now known as Timbus

[07:23] <lizmat_> fwiw, it's not yet clear what the solution would need to be

[07:23] <lizmat_> my feeling is that if you're using :delete on an array, you're using it as a hash

[07:23] <lizmat_> and thus, when iterating over it, you would not see deleted elements

[07:24] <lizmat_> just like you wouldn't see deleted keys in a hash when iterating over the hash

[07:24] *** lizmat_ is now known as lizmat

[07:24] <lizmat> the coming days I will most likely be offline most of the time

[07:24] <lizmat> will attempt to backlog when connected

[07:24] *** lizmat left
[07:25] *** Khisanth joined
[07:35] <masak> the difference between the hash and the array, though, is that the array has an ordering.

[07:35] <masak> more exactly, the indices are always 0..N-1.

[07:35] <masak> a condition which has no correspondence in the hash case.

[07:35] <masak> which (IMO) explains why there's a "hole" left when you delete something.

[07:36] <masak> now, granted, there's a way to argue for :delete on arrays working more like .splice

[07:36] <masak> but that would be "extra semantics out of nowhere" if you ask me. the hole comes from the fact that non-last elements still need to have an index due to the 0..N-1 thing, even after being removed.

[07:44] *** araujo joined
[07:47] *** PZt left
[07:48] *** woolfy left
[07:49] *** PZt joined
[07:50] <masak> or, viewed from a slightly different angle: there are two behaviors here: leave a hole or don't leave a hole. reasonable use cases could be drawn up for both of these.

[07:50] <masak> .splice is what we use for the "don't leave a hole" use case.

[07:51] <masak> if :delete is made not to leave a hole, what operation will?

[07:52] *** sqirrel joined
[07:53] <moritz> assignment of Nil

[07:54] <moritz> or maybe the empty list

[07:54] <moritz> @a[1,3,5] = ()

[07:54] <hoelzro> ahoy #perl6

[07:54] <preflex>  hoelzro: you have 1 new message. '/msg preflex messages' to read it.

[08:00] *** berekuk left
[08:04] *** PZt left
[08:06] <masak> moritz: fair enough.

[08:06] <masak> but there's also the performance argument: "leave a hole" is cheap, collapsing is O(.elems)

[08:06] *** tipdbmp joined
[08:07] *** iSlug joined
[08:07] <moritz> agreed

[08:15] <masak> in our JavaScript course, I lightly ridicule 'delete somearray[5]' for the leaving-a-hole semantics. but after this discussion, it kind of makes sense.

[08:16] <masak> it's not that it's a useless operation. it's that it's an uncommon operation, and most of the time you want to splice.

[08:16] <masak> TimToady: http://www.bbc.co.uk/news/science-environment-24429621 # whoa, we'd better hurry! :P

[08:17] <masak> hehe, and on 

[08:17] <masak> first comment on HN: "It is an important milestone. But to have a commercially viable fusion reactor, you'll need a factor of 50-100 more energy [...]"

[08:17] <masak> that's exactly like Perl 6 :P

[08:19] *** xinming left
[08:19] *** donaldh left
[08:21] *** xinming joined
[08:23] *** donaldh joined
[08:26] *** FROGGS joined
[08:28] *** zakharyas left
[08:31] *** tipdbmp left
[08:33] *** tipdbmp joined
[08:42] *** denysonique joined
[08:42] *** zamolxes_ left
[08:49] *** zamolxes joined
[08:51] *** dakkar joined
[08:57] *** ivanshmakov left
[08:57] *** ivanshmakov joined
[08:59] *** gyutyuglf joined
[09:01] *** fhelmberger joined
[09:08] *** PZt joined
[09:12] *** xinming left
[09:13] *** xinming joined
[09:14] *** iSlug left
[09:31] *** zamolxes left
[09:34] *** zamolxes joined
[09:35] *** daxim joined
[09:37] *** zakharyas joined
[10:10] *** dmol joined
[10:13] *** stevan_ left
[10:14] *** sqirrel left
[10:14] *** wsri left
[10:15] *** wsri joined
[10:23] <mathw> It's interesting that someone bothered to comment with that, because I'm pretty sure the researchers know.

[10:24] <mathw> But then people seem to think that you guys don't know that Rakudo isn't fast enough yet, so...

[10:25] *** gyutyuglf left
[10:30] *** gyutyuglf joined
[10:48] *** gyutyuglf left
[10:55] <moritz> is david wheeler on irc, and if yes, does anybody know his nick?

[11:06] <hoelzro> moritz: Theory

[11:06] <hoelzro> or JustATheory

[11:06] <hoelzro> some variation on that theme

[11:07] <moritz> hoelzro: thanks

[11:10] *** grondilu joined
[11:27] *** sqirrel joined
[11:28] *** berekuk joined
[11:37] *** pmurias joined
[11:39] *** rindolf joined
[11:39] <pmurias> if I want to write a tool which bundles a bunch of modules (in node format) into a single script is there a good reason to write it in full Perl6 instead of NQP?

[11:39] <dalek> Perlito: ab2e61c | (Flavio S. Glock)++ | / (3 files):

[11:39] <dalek> Perlito: Perlito5 - perl6 - operators

[11:39] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/ab2e61ca34

[11:41] <timotimo> perl6 gives you simpler file i/o and string manipulation and handling of lists of things

[11:49] *** pmurias left
[11:56] *** pmurias joined
[12:11] *** denis_boyun joined
[12:15] *** denis_boyun left
[12:18] *** skids left
[12:20] *** sqirrel left
[12:20] <grondilu> r: class Foo { method postcircumfix:<( )>($i) { "ok" } }; say Foo.new()(pi)

[12:20] <camelia> rakudo d7e5e1: OUTPUT«ok␤»

[12:20] <grondilu> r: class Foo { method postcircumfix:<( )>($i, $j) { "ok" } }; say Foo.new()(pi, 1)

[12:20] <camelia> rakudo d7e5e1: OUTPUT«Not enough positional parameters passed; got 2 but expected 3␤  in method postcircumfix:<( )> at /tmp/uqBfHyo5Bt:1␤  in block  at /tmp/uqBfHyo5Bt:1␤␤»

[12:21] <grondilu> n: class Foo { method postcircumfix:<( )>($i, $j) { "ok" } }; say Foo.new()(pi, 1)

[12:21] <camelia> niecza v24-98-g473bd20: OUTPUT«Potential difficulties:␤  $i is declared but not used at /tmp/4R06k_JLJg line 1:␤------> [32mclass Foo { method postcircumfix:<( )>([33m⏏[31m$i, $j) { "ok" } }; say Foo.new()(pi, 1)[0m␤  $j is declared but not used at /tmp/4R06k_JLJg line 1…»

[12:21] <grondilu> n: class Foo { method postcircumfix:<( )>($i, $j) { "$i $j" } }; say Foo.new()(pi, 1)

[12:21] <camelia> niecza v24-98-g473bd20: OUTPUT«3.1415926535897931 1␤»

[12:21] <grondilu> rakudobug?

[12:25] <gfldex> grondilu: known rakudobug

[12:26] <grondilu> ok

[12:26] <pmurias> what is the recommened rakudo atm, the parrot or jvm one?

[12:27] *** pmurias left
[12:28] *** denis_boyun joined
[12:31] *** denis_boyun left
[12:32] *** denisboyun joined
[12:34] <nwc10> come back pmurias

[12:38] *** SmokeMachine left
[13:05] *** PacoAir joined
[13:06] *** zakharyas left
[13:09] *** kay joined
[13:09] *** kay is now known as Guest65723

[13:11] <dalek> Perlito: 5f06d56 | (Flavio S. Glock)++ | / (3 files):

[13:11] <dalek> Perlito: Perlito5 - perl6 - operators

[13:11] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/5f06d564db

[13:14] <arnsholt> [Coke]: Could you add some more in-depth comments to NQP #126?

[13:14] <arnsholt> The bug as it stands is a bit hard to decipher for those of us who didn't attend the workshop =)

[13:15] <arnsholt> timotimo: I've looked a bit at NQP #104, and it turns out NQP doesn't have temp at all. Do you mind if I close the bug?

[13:16] *** kaleem left
[13:17] <pmichaud> nqp will need :tmp

[13:17] <pmichaud> er, :temp

[13:17] <pmichaud> if only because STD.pm6 uses it.

[13:17] <nwc10> good *, pmichaud 

[13:17] <pmichaud> good morning, #perl6

[13:17] <moritz> \o *

[13:18] <FROGGS> hi pmichaud 

[13:19] <pmichaud> (so no, don't close #104)

[13:20] <timotimo> hi pm :)

[13:21] <arnsholt> That makes sense. In that case, I guess we'll also want temp for normal NQP code as well as regexes

[13:22] <pmichaud> no, not necessarily.

[13:22] <pmichaud> NQP's phillosophy is never "add a feature because we might want it"

[13:22] <arnsholt> Right

[13:23] <pmichaud> Also, I'm not sure that :temp and statement-level 'temp' do precisely the same thing.  (They might... I just would want to verify that before automatically conjoining them)

[13:24] <dalek> nqp/buglet: 90050fd | (Tobias Leich)++ | / (13 files):

[13:24] <dalek> nqp/buglet: buglet

[13:24] <dalek> nqp/buglet: review: https://github.com/perl6/nqp/commit/90050fd474

[13:25] *** hummeleB1 joined
[13:25] <arnsholt> S05 says :<scope declarator> is "parsed as normal Perl 6 code", so I think it should be identical

[13:26] <pmichaud> yeah, but NQP's grammar stuff is bootstrappy, so sometimes things end up being not exactly identical.

[13:26] <arnsholt> :my is parsed by delegating back to MAIN's statement as well, which is part of the reason I assumed we'd add temp to running code as well. Keeping :temp and :my the same

[13:27] <arnsholt> Yeah, that's true

[13:27] <arnsholt> Bootstrapping has bitten me a couple of times the last few days as I've tried to close various bugs

[13:29] <pmichaud> oooh, :my is implemented oddly in NQP's grammar.

[13:29] *** donaldh left
[13:30] <pmichaud> seems like it ought to be part of mod_ident:  instead of metachar:  (so that it matches :dba, :ratchet, :sigspace, etc.)

[13:30] <arnsholt> How so? Rakudo does the same thing, AFAICT

[13:31] *** lowpro30 joined
[13:31] <pmichaud> Rakudo could be wrong also.

[13:31] *** lowpro30_ joined
[13:32] <pmichaud> otoh, it looks like some chap named 'pmichaud' is the one that put the <:my> handling into metachar: ... so perhaps it's right.

[13:32] <pmichaud> it just strikes me as being inconsistent with the others somehow.

[13:33] *** denisboyun left
[13:34] *** kaare_ joined
[13:34] <arnsholt> Why is that? If it's supposed to be parsed the same as the corresponding declaration in non-regex code, it makes sense to use the same code path, no?

[13:35] *** lowpro30 left
[13:35] <pmichaud> I think we're talking about two different things now.

[13:36] <pmichaud> Yes, I'm fine with :my calling into the main language parser.

[13:36] <pmichaud> I'm pointing out an inconsistency with where <:my> itself is being handled, not the way in which it works.

[13:37] <arnsholt> Indeed. Turns out there's a line I missed in between your first comment about the oddness and my first reply

[13:37] <arnsholt> (My bad

[13:40] *** bluescreen10 joined
[13:44] *** benabik left
[13:59] *** grondilu left
[14:01] *** skids joined
[14:02] *** stevan_ joined
[14:04] *** ajr joined
[14:04] *** ajr is now known as Guest31368

[14:04] *** Guest31368 is now known as ajr_

[14:08] *** dmol left
[14:08] *** logie joined
[14:10] *** Guest18828 left
[14:15] *** btyler joined
[14:15] *** broquain1 is now known as broquaint

[14:21] *** cognominal joined
[14:26] <dalek> Perlito: 92acb9d | (Flavio S. Glock)++ | / (3 files):

[14:26] <dalek> Perlito: Perlito5 - perl6 - operators

[14:26] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/92acb9d4a6

[14:33] *** Guest18828 joined
[14:34] *** Guest18828 left
[14:34] *** denis_boyun joined
[14:42] *** PacoAir left
[14:42] *** denis_boyun left
[14:43] *** colomon left
[14:43] *** donaldh joined
[14:44] <dalek> Perlito: 1d2c1c6 | (Flavio S. Glock)++ | / (4 files):

[14:44] <dalek> Perlito: Perlito5 - perl6 - special vars

[14:44] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/1d2c1c65f7

[14:46] *** sqirrel joined
[14:47] *** xinming left
[14:48] *** xinming joined
[14:50] *** colomon joined
[14:55] *** dayangkun joined
[14:56] *** benabik joined
[15:01] *** xenoterracide_ joined
[15:04] <japhb__> r: say "foo".subst(/(o)/, "a"); for "foo" -> $l { say $l.subst(/(o)/, {"a" ~ $0}) }

[15:04] <camelia> rakudo d7e5e1: OUTPUT«fao␤faoo␤»

[15:04] <japhb__> r: say "foo".subst(/o/, "a"); for "foo" -> $l { say $l.subst(/(o)/, {"a" ~ $0}) }

[15:04] <camelia> rakudo d7e5e1: OUTPUT«fao␤use of uninitialized value of type Any in string context  in block  at /tmp/PbRK0SUjoF:1␤␤fao␤»

[15:04] <japhb__> Yeah.  There's a bug for ya.

[15:05] <diakopter> r: $11111111111111111111111111111111111

[15:05] <camelia> rakudo d7e5e1: OUTPUT«Cannot use negative index -9223372036854775808 on Nil␤current instr.: 'throw' pc 402455 (src/gen/CORE.setting.pir:169079) (src/gen/CORE.setting:10512)␤called from Sub 'sink' pc 438520 (src/gen/CORE.setting.pir:182308) (src/gen/CORE.setting:11902)␤called f…»

[15:05] <diakopter> that's still my fav

[15:05] * japhb__ hates "spooky action at a distance" bugs even more than localized bugs

[15:06] <japhb__> diakopter: although yep, that one is a crazy one.

[15:06] <TimToady> well, it's getting closer to Halloween...

[15:06] *** benabik left
[15:06] <diakopter> TimToady: note that now that camelia is using a 64-bit parrot, the number is negativer

[15:07] <JimmyZ> nqp-m: $11111111111111111111111111111111111

[15:07] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "$111111111"␤panic»

[15:07] <japhb__> I'm not even sure how the bug I posted *could* be happening

[15:07] <diakopter> it's thinking it's redeclaring $1, but not

[15:08] <timotimo> will Parrot_str_to_cstring stop after a nullbyte is encountered? will a STR register's ->strlen stop at the first nullbyte? is there a length that will not do so?

[15:08] <diakopter> oh, that's $l

[15:08] <diakopter> japhb__: it's confusing $1 and $l, like I did

[15:08] *** dayangkun left
[15:08] <JimmyZ> n: $11111111111111111111111111111111111

[15:08] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: weird object in sub_finish Int␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 242 (StaticSub.finish @ 11) ␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 4257 (NieczaActions.comp_unit @ 15) ␤  at /home/p6eval/…»

[15:09] <japhb__> Yeah, sorry about that confusion, diakopter.  The result of golfing the bug.

[15:10] *** jnap joined
[15:10] *** dayangkun joined
[15:10] <japhb__> But in any case, why would whether or not the left subst has a capture in its regex have any effect on the subst on the right?

[15:10] * diakopter blames the optimizer

[15:10] *** jnap left
[15:11] *** denis_boyun joined
[15:12] * masak .oO( spooky pumpkin at a distance )

[15:12] * japhb__ wonders how the hell to work around the bug in his current code

[15:14] <diakopter> probbaly putting it in an eval() would work. :)

[15:14] <japhb__> >.<

[15:15] <TimToady> use -> $/ { "a" ~ $0 }

[15:15] <japhb__> r: say "foo".subst(/o/, "a"); for "foo" -> $l { say $l.subst(/(o)/, -> $/ {"a" ~ $0}) }

[15:15] <camelia> rakudo d7e5e1: OUTPUT«fao␤faoo␤»

[15:15] <japhb__> ooh.

[15:15] <diakopter> mwahaha

[15:15] <TimToady> .subst doesn't set $/ for the RGH like s/// does

[15:15] <japhb__> But, um, WTF

[15:16] <TimToady> it's just a normal method

[15:16] <japhb__> Ah!

[15:16] *** cognominal left
[15:16] *** cognominal joined
[15:16] <japhb__> .oO( The problem with magic is you get used to it. )

[15:17] * colomon seems to recall a lot of debate about whether .subst should set $/

[15:17] * colomon is very happy if it doesn't.

[15:21] <diakopter> TimToady: are macro-methods spec'd?

[15:21] <TimToady> but it will be a FAQ if we leave it as is

[15:21] <timotimo> oh crap, now my nqp segfaults :o

[15:22] <TimToady> we already have some, like .VAR

[15:22] <diakopter> r: macro method marco { }

[15:22] <camelia> rakudo d7e5e1: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/mWeqoXVZWw␤Missing block␤at /tmp/mWeqoXVZWw:1␤------> [32mmacro method [33m⏏[31mmarco { }[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta…»

[15:23] <TimToady> .subst(...) could be parsed as a postcircumfix

[15:23] <yoleaux> TimToady: Sorry: that command is a web-service, but it didn't respond in plain text.

[15:23] <timotimo> haha, what

[15:23] <TimToady> yoleaux: you're out of your gourd

[15:23] *** [Sno] left
[15:24] <TimToady> r: say $_.VAR.WHAT

[15:24] <camelia> rakudo d7e5e1: OUTPUT«(Scalar)␤»

[15:24] *** xenoterracide_ left
[15:25] <diakopter> r: class Foo { macro marco { method boo { } }; method foo { marco() } }; Foo.foo()

[15:25] <camelia> rakudo d7e5e1: OUTPUT«===SORRY!===␤too few positional arguments: 2 passed, 3 (or more) expected␤»

[15:25] <TimToady> well, I guess .VAR can simply be a postfix, so it's not terribly macroey

[15:25] <timotimo> just adding a new function into nqp.ops shouldn't cause a segfault somewhere later in compilation, no?

[15:25] <diakopter> yeah if there's a missing Makefile dependency

[15:26] <timotimo> but i'm not using the op anywhere, and i make clean'd

[15:26] <diakopter> or you didn't do it right

[15:26] * timotimo stashed the changes and rebuilds nqp to make sure master does compile no-problemo

[15:26] <diakopter> but make clean might not be very cleanly

[15:26] <timotimo> weird, that helped.

[15:27] <timotimo> https://gist.github.com/timo/b69047cf2b97b7819f16 - anything very obviously wrong about this?

[15:27] * masak is still flummoxed/amused by the first comment on https://gist.github.com/masak/5768668

[15:29] <pmichaud> anyone know how long it takes email replies to github issues to show up on github?

[15:29] <timotimo> shouldn't take longer than a few minutes, eh?

[15:29] <pmichaud> I sent a reply 30 mins ago and it's still not there.  :-/

[15:29] <timotimo> huh.

[15:29] <pmichaud> I think I'll just post directly to github then... hopefully it won't end up there twice.

[15:30] <TimToady> masak: obviously you should've used .fmt intentionally to thwart such abuse :)

[15:30] <arnsholt> Better twice than no times =)

[15:31] <pmichaud> comment added.

[15:33] <masak> TimToady: I like sprintf on the statement level... :) it's a bit more up-front.

[15:33] <diakopter> masak: I don't know about that code.. :) the answer is plainly 2 hours.

[15:33] <masak> diakopter: :P

[15:34] <masak> TimToady: I found, to my surprise, that I really liked Python 3's formatting syntax.

[15:35] <masak> TimToady: the main reason being that you can "change your mind" mid-string and just start adding directives, and then "...".format() at the end.

[15:35] <timotimo> i can get no info whatsoever out of this core dump :(

[15:36] <diakopter> timotimo: I'm sure the problem is in the to_cstring calls

[15:36] <TimToady> masak: that's writer-centric, not reader-centric

[15:36] <diakopter> timotimo: wait.

[15:36] <diakopter> timotimo: why do you think going to cstrings is how to do it?

[15:37] <TimToady> most readers want to know what you're formatting; the actual format is kinda beside the point

[15:37] <timotimo> i looked at another function right next to it and that used that, so ...

[15:37] <timotimo> if you can tell me how to do it better, i will do it better instead :)

[15:37] <diakopter> well it's just the point is to do it without allocations

[15:38] <timotimo> well, i can do it on java and moarvm without extra allocations, i don't know how to do it on parrot

[15:38] <diakopter> show th ejava one?

[15:38] <timotimo> will do

[15:38] <timotimo> https://gist.github.com/timo/b69047cf2b97b7819f16#file-gistfile2-txt

[15:39] <masak> TimToady: granted, but the {} things stand out pretty well too.

[15:39] <diakopter> ok

[15:39] <timotimo> i don't know what interface the parrot string offers, so ...

[15:39] <masak> TimToady: I have long since concluded that no formatting language will ever make everyone happy, but py3k's is pretty non-bad. and it feels more modern than the old C one.

[15:39] <diakopter> commutestrationesquelism&

[15:39] <timotimo> where should i look to find out?

[15:40] *** benabik joined
[15:40] <TimToady> on reordering things from the reader's perspective, I wish Rxx reversed the thunkiness

[15:40] <timotimo> that would be amazing, but also pretty WAT, imo.

[15:40] <TimToady> r: say 10 Rxx rand

[15:40] <camelia> rakudo d7e5e1: OUTPUT«0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009 0.258589441280009␤»

[15:40] <TimToady> WAT

[15:41] <timotimo> wait. which way do you mean that?

[15:41] *** donaldh left
[15:41] <TimToady> I mean I want 10 different rands

[15:41] <arnsholt> masak: Based on that comment, I assume you frown upon things like %#5.4g? =)

[15:41] <timotimo> oh, that way

[15:41] *** sqirrel left
[15:42] *** jnap joined
[15:42] <masak> arnsholt: I... I don't find it as black-and-white as "frown upon". hm. I think dedicated DSLs definitely have their place. and it's hard to get more bang for the buck than '%#5.4g'.

[15:42] * TimToady wonders if we can get away with simply saying "this set of operators is thunky, so thunk all the arguments and let the operator sort it out"

[15:42] <masak> arnsholt: just... I feel we might no longer live in the world that spawned that syntax.

[15:42] <TimToady> so something like [||] would just thunk all the args

[15:43] <masak> TimToady: I thought the spec had wording saying something like "metaops de-magic some magic ops"

[15:43] <TimToady> that's just a "we haven't figured out how to de-WAT this yet"

[15:44] <masak> ok

[15:44] <TimToady> but maybe we're making it too hard

[15:44] <pmichaud> the spec's wording is to give implementor's cover so that users don't expect the WAT behavior :)

[15:44] <pmichaud> s/'s/s/

[15:44] <TimToady> if xx thunks both sides, and the xx op knows to eval its right side automatically first, it would just work out

[15:45] <TimToady> otoh, maybe it makes constant folding harder

[15:45] <TimToady> it's all very well to special case the ops we know are thunky, but it'd be nice if it generalized to user-defineds

[15:46] <TimToady> arguably xx is an infix macro

[15:46] <TimToady> and metaops of macros might make sense to keep macroey

[15:47] <arnsholt> masak: Yeah, you're probably right on this not being those same times. I've just learnt to do so many neat tricks like that

[15:47] <masak> arnsholt: sprintf syntax is the Makefile of formatting languages :P

[15:47] <TimToady> it's back to that notion of mixed-arg macros I was talking about the day--not every arg to a macro has to be an AST

[15:47] <TimToady> in the case of infix:<xx>, a thunk and a mundane would do it

[15:47] <masak> arnsholt: i.e. ugly/non-optimal, but Not Going Away Anytime Soon.

[15:48] <arnsholt> Incidentally, I have also learnt to do fun things with make =)

[15:48] <masak> TimToady: we're running up a huge stack of (recurring) wishlist items for macros and macro-like things.

[15:48] <masak> TimToady: I suggest we set aside half a day or so sometime to go through them and write them down.

[15:49] <TimToady> I just said this is pretty much the same wish I had the other day :)

[15:49] <masak> not anything as heavyweight as a *meeting*, mind. just an increased focus :)

[15:49] <masak> I'm very happy to have it here on #perl6, and act as a secretary.

[15:50] <masak> anyone who's interested is invited.

[15:50] * PerlJam hands masak a magnifying glass

[15:50] <masak> the goal isn't to propose solutions, just to enumerate the desires.

[15:50] <TimToady> For near-sighted people, a magnifying glass decreases focus. :P

[15:50] <PerlJam> are macros a blocker for 6.0.0 ?

[15:51] <pmichaud> macros have been one of those places where a lot of hand-wavy magic gets shuttled

[15:51] <GlitchMr> PerlJam, macros already are implemented in Rakudo Perl.

[15:51] <pmichaud> "...we don't know how to do this hard thing...it probably belongs in macros somewhere."  :-) :-)

[15:52] <GlitchMr> But yes, they are needed.

[15:52] <TimToady> PerlJam: let me make this argument: when 6.0.0 comes out, we're gonna have a lot of people saying "Ooh, macros!", and twisting them into brain pretzels--it would be nice if they didn't have the Wrong Semantics at that point.

[15:52] <japhb__> Is there any way to get an exit code from a read pipe?

[15:53] <TimToady> or from the other direction, if things like Rxx have the wrong semantics, it's gonna be terribly difficult to retrofit the correct semantics

[15:54] <PerlJam> GlitchMr: "implemented" is a strong word :)

[15:54] <GlitchMr> Sort of

[15:54] <TimToady> and I would like to carp a little bit about characterizing these as new-fangled ideas; I've been talking about infix macros for roughly a decade now

[15:54] <dalek> Perlito: b55f1ec | (Flavio S. Glock)++ | / (2 files):

[15:54] <dalek> Perlito: Perlito5 - perl6 - $# => .end

[15:54] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/b55f1ec403

[15:55] <TimToady> from the standpoint of normal macros, the only difference with an infix macro is that it can't retroactively change the parsing of the AST on the left

[15:57] *** sqirrel joined
[15:57] <TimToady> (ignoring the operational difference that the parse has to recognized that it has reduced a macro and do something about that immediately)

[15:58] <benabik> Macros can affect the parse of their arguments?  I thought they received ASTs as arguments, which means their arguments are already parsed.

[15:58] <TimToady> but if infix:<xx> is really a macro, I see no reason in principle that infix:<Rxx> is not also a macro

[15:58] <TimToady> benabik: with the NYI 'is parsed'

[15:59] <benabik> Using R with an infix macros means it can no longer affect the parse on the right.  Compile time error if is has an is parsed on the rhs, I guess?

[16:00] <TimToady> well, thunky macros like xx don't change the parse

[16:00] <TimToady> so yeah, R shouldn't work on a fancier macro

[16:00] <benabik> Heh.  I had parsed xx as a placeholder not as a concrete example.  D'oh.

[16:01] <TimToady> I dunno, maybe we want a term for thunky operators that is weaker than "macro"

[16:02] <TimToady> thunky ops just need to control time of evaluation, not AST restructuring

[16:03] <PerlJam> that sounds vaguely phaserish

[16:03] <timotimo> if i want to add another op to the nqp.ops, do i have to do something to another file, too?

[16:03] <TimToady> I don't think it has to be so inside-out as phasers

[16:03] <timotimo> i put in an op and i'm not even using it anywhere, yet it crashes

[16:03] <TimToady> it's just three types of arguments to an immediately called subroutine

[16:03] <benabik> Scala does that via "pass-by-name" parameters.  def lazyFunc(x : => Int) only evaluates x if it gets used.

[16:04] <TimToady> AST arg, thunk arg, normal pre-evaluated value

[16:04] <benabik> Although here I guess we want something that gets re-evaluated on each usage?

[16:04] <TimToady> but as I said the other day, if everything comes in as AST, you can emulate the others with methods to compile and eval an AST

[16:05] *** denis_boyun left
[16:05] <TimToady> BEGIN reduces to a macro that evaluates its AST immediately for a value

[16:05] <benabik> And can write a macro to simplify writing the other macros...

[16:07] *** denisboyun joined
[16:07] *** FROGGS left
[16:09] <masak> <TimToady> I dunno, maybe we want a term for thunky operators that is weaker than "macro"

[16:09] <masak> +1

[16:10] <timotimo> "thub"

[16:10] <timotimo> and "methub"

[16:10] <timotimo> "methud"?

[16:11] <TimToady> inthunk, postthunk...

[16:12] *** jnap1 joined
[16:12] *** jnap left
[16:13] <PerlJam> that wouldn't work better as a trait?   infix:<xx>($a,$b) is thunky { ... } 

[16:13] <masak> "thop"?

[16:13] <PerlJam> Or is that just too late in the parse

[16:13] <masak> but it'd be nice if the term worked for functions, too.

[16:13] <TimToady> the salient feature is that the parameters are not needing all the power of ASTs

[16:13] <moritz> thunky sub foo($x) { }

[16:14] <masak> moritz++ # nice!

[16:14] <moritz> (and needs to be declared befure usage

[16:14] <moritz> )

[16:14] <TimToady> and that the parameters can differ in that regard

[16:14] <masak> and we could have thunky macros.

[16:14] <masak> I'm sorry, I must &

[16:14] <masak> please don't say interesting things for an hour or so :P

[16:14] <TimToady> so attaching traits to the entire thing is hanging them on the wrong peg

[16:14] <masak> &

[16:14] <PerlJam> ok

[16:14] <benabik> more `sub infix:<xx>($a is thunky, $b)`?

[16:16] <TimToady> one could also view it on the laziness spectrum

[16:16] * TimToady goes back to backlogging so as not to violate masak++'s dictum

[16:18] <timotimo> what are the consequences of the "parsing nqp.ops" stage?

[16:18] <TimToady> (but I'm guessing this should be type-based, not trait-based)

[16:18] *** grondilu joined
[16:20] *** fhelmberger left
[16:21] <timotimo> oh damnit

[16:21] <timotimo> i think the segfault was because i was writing "invar INT" and "invar STR" rather than "in INT" and "in STR"

[16:21] <timotimo> great >_<

[16:22] <timotimo> i think i made this mistake at least once before

[16:22] <TimToady> .oO(an invariant mistake)

[16:23] <timotimo> oh, i was wrong

[16:23] <timotimo> it still segfaults even though it doesn't actually use my code at all

[16:23] <TimToady> \o/ oh wait

[16:25] <timotimo> parrot confuses me and my ignorance makes me mad at it.

[16:30] *** FROGGS joined
[16:36] *** [Sno] joined
[16:36] <timotimo> bah!

[16:36] <timotimo> even if the op contains nothing but $1 = 0

[16:36] <timotimo> it *still* causes trouble somewhere else

[16:39] <timotimo> FROGGS: you know a little bit about parrot, right?

[16:39] <timotimo> what's wrong with this: op nqp_string_equal_at(out INT, in STR, in STR, in INT) { $1 = 0; }

[16:41] <benabik> timotimo: looks okay to me...

[16:41] <timotimo> maybe the name collides and somebody already implemented that op? that might cause trouble

[16:41] <FROGGS> don't you have INTVAL at some point rather than INT?

[16:41] <FROGGS> or is this in C ?

[16:41] <timotimo> this is nqp.ops

[16:42] <benabik> Name collisions should cause compile or linker errors.

[16:42] <timotimo> didn't

[16:42] <FROGGS> no name collision

[16:42] <timotimo> it seems to cause nqp::exists to fail

[16:43] <timotimo> too few positional arguments: 0 passed, 1 (or more) expected

[16:44] <timotimo> which makes no bloody sense at all

[16:46] <diakopter> https://twitter.com/sheeshee/status/387513133134139393

[16:47] <timotimo> well, chromatic doesn't disappoint

[16:47] *** kaleem joined
[16:47] *** dmol joined
[16:48] *** sqirrel left
[16:49] <diakopter> timotimo: I thought chromatic's comment was plenty fair

[16:50] <timotimo> it is fair, yes.

[16:50] <timotimo> the eqat implementation on the jvm works

[16:51] <timotimo> and parrot just blows up completely when i try the simplest little bit of implementation of it

[16:52] *** fhelmberger joined
[17:00] <[Coke]> chromatic++

[17:02] *** PacoAir joined
[17:03] *** dakkar left
[17:04] <PerlJam> TimToady++ :-)

[17:06] *** havenwood joined
[17:08] <[Coke]> today's very slow rakudo.jvm will try without the eval server.

[17:12] <arnsholt> [Coke]: Could you flesh out NQP #126 a bit? So that those of us who didn't attend RaNOW know what's going on =)

[17:13] <[Coke]> saw that in backscroll. there were some magic constants.... I have to dig.

[17:23] *** Rotwang joined
[17:24] *** kaleem left
[17:24] <arnsholt> 'k

[17:25] <arnsholt> Also, I'm guessing we can close #114?

[17:25] *** denisboyun left
[17:26] <arnsholt> And what's the state of #129? AFAICT, there seems to be some kind of eval server stuff going on, but not sure whether that's what #129 is about or not

[17:26] *** ajr_ left
[17:27] <timotimo> our evalserver seems to only be for perl6, no?

[17:27] <moritz> I think there's one for nqp too

[17:27] <timotimo> then we can point it out in the bug and close it :)

[17:28] <moritz> but verify that first please :-)

[17:28] * [Coke] closed #114

[17:28] <moritz> hm

[17:28] <moritz> p6eval@host07:~$ find rakudo-jvm/ -name '*eval*' 

[17:28] <moritz> rakudo-jvm/bin/perl6-eval-server

[17:28] <moritz> rakudo-jvm/bin/eval-client.pl

[17:28] <[Coke]> 129 has had no discussion or work.

[17:28] <[Coke]> moritz: that's -rakudo-, not -nqp-

[17:28] <moritz> so if there is an nqp eval server, it's not being installed

[17:28] <arnsholt> \o/ # Single page of NQP bugs

[17:28] <moritz> [Coke]: that's what I was about to say

[17:28] <[Coke]> ah, we're agreeing.

[17:28] <FROGGS> arnsholt++

[17:29] <[Coke]> arnsholt: great, now I can open all my "this opcode needs a test" tickets. ;)

[17:29] <arnsholt> =ppppppppp

[17:29] <arnsholt> Although those sound like good, actionable tickets

[17:29] <[Coke]> arnsholt: https://github.com/perl6/nqp/issues/103 sounds familiar. worth a test.

[17:30] <arnsholt> Yeah, that one's on my hit-list

[17:30] <[Coke]> arnsholt++

[17:30] <arnsholt> Looks to be reasonably LHF

[17:30] <arnsholt> I'm not unhappy if people snipe the LHF though =)

[17:31] <FROGGS> can you tag it LHF if it is not already?

[17:31] <arnsholt> Good idea!

[17:33] *** daxim left
[17:33] *** FROGGS left
[17:33] <arnsholt> #110 is similar to some stuff I'd been pondering before I started bug-wrangling as well

[17:35] *** jeffreykegler joined
[17:35] <TimToady> .tell LlamaRider an array with a declared type of Str only takes strings; you're probably expecting semantics more like the specced but not-yet-implemented Str() type, which would coerce to Str

[17:35] <yoleaux> TimToady: I'll pass your message to LlamaRider.

[17:36] <timotimo> i bet this optimization i'm about to implement will not change a thing at all :)

[17:36] <timotimo> actually. i could just as well replace the few spots where nqp::substr($foo, $num, $num2) eq $otherstr appears with explicit nqp::eqat calls

[17:37] <timotimo> instead of teaching the optimizer to do the transformation

[17:37] <timotimo> opinions?

[17:37] <TimToady> (optimizer + pessimizer)/2 === nominalizer  :)

[17:38] *** jnap1 left
[17:40] *** xenoterracide_ joined
[17:43] <[Coke]> how does one check to see if something is a dir in nqp? we have "fileisreadable", etc., but no "fileisdir". is stat the only way

[17:43] <[Coke]> ?

[17:43] <TimToady> this is #perl6, you should ask on #nqp  :P

[17:44] <[Coke]> sadly, there's no one there.

[17:44] <TimToady> well, you could get back to yourself later when you know the answer... :)

[17:45] <TimToady> since there was at least one person there...

[17:46] <timotimo> [Coke]: perl6 does it somehow using nqp, you should look there for the answer

[17:47] * TimToady 's absurdity generator is today never the whatever against a frog beautifully sofa ungood

[17:47] <timotimo> hm. updating the bootstrap files in two branches will probably prove problematic ...

[17:47] *** havenwood left
[17:47] <[Coke]> stat is doable. just wondering if we need to cleanup nqp ops at some point.

[17:48] <diakopter> mm sofa frog

[17:50] <[Coke]> Oy, here's a fun error: use // Comment in nqp. :P

[17:51] <diakopter> std: // urp

[17:51] <camelia> std a0bcfb1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed at /tmp/lTUx60qD5s line 1:␤------> [32m//[33m⏏[31m urp[0m␤Two terms in a row at /tmp/lTUx60qD5s line 1:␤------> [32m// [33m⏏[31murp[0m␤    expecting any of:␤ feed_separator␤ infix or …»

[17:51] <[Coke]> esp. nice since it's highlighted by whatever syntax parser as a comment. :)

[17:51] <diakopter> std: {}␤// urp

[17:51] <camelia> std a0bcfb1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed at /tmp/C0UM1c1NCx line 2:␤------> [32m//[33m⏏[31m urp[0m␤Two terms in a row at /tmp/C0UM1c1NCx line 2:␤------> [32m// [33m⏏[31murp[0m␤    expecting any of:␤ feed_separator␤ infix or …»

[17:52] <diakopter> std: say {}␤// urp

[17:52] <camelia> std a0bcfb1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null regex not allowed at /tmp/JsNJiz9CV0 line 2:␤------> [32m//[33m⏏[31m urp[0m␤Two terms in a row at /tmp/JsNJiz9CV0 line 2:␤------> [32m// [33m⏏[31murp[0m␤    expecting any of:␤ feed_separator␤ infix or …»

[17:52] <diakopter> o_O

[17:52] <diakopter> I expected that to work

[17:53] <[Coke]> nqp: my $a := nqp::stat("/etc/motd",2); // Use a constant here.

[17:53] <camelia> nqp: OUTPUT«Null regex not allowed at line 2, near "/ Use a co"␤current instr.: 'panic' pc 14748 (src/stage2/gen/NQPHLL.pir:5229) (src/stage2/gen/NQPHLL.nqp:279)␤»

[17:53] <[Coke]> weird. not the error I'm getting locally. :)

[17:53] <diakopter> r: say {}␤// urp

[17:53] <camelia> rakudo d7e5e1: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/oguZx8esiQ␤Null regex not allowed␤at /tmp/oguZx8esiQ:2␤------> [32m//[33m⏏[31m urp[0m␤»

[17:53] <diakopter> o_O

[17:53] <TimToady> why?  line-ending } terminates as statement

[17:53] *** ajr joined
[17:53] <TimToady> *a

[17:53] <diakopter> n: say {}␤// urp

[17:53] <camelia> niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Null regex not allowed at /tmp/74CjDeoSu5 line 2:␤------> [32m//[33m⏏[31m urp[0m␤␤Action method quote:sym<//> not yet implemented at /tmp/74CjDeoSu5 line 2:␤------> [32m//[33m⏏[31m urp[0m␤␤Two…»

[17:53] <diakopter> really!!?!

[17:53] <diakopter> that's, um, news

[17:53] <TimToady> no it isn't

[17:53] <diakopter> I thought it was just for block declarations

[17:53] *** ajr is now known as Guest45348

[17:54] <TimToady> that is a block

[17:54] *** Guest45348 is now known as ajr_

[17:54] <diakopter> top-level block declarations, I mean

[17:54] <TimToady> no, it's never been like that

[17:54] <TimToady> the whole point is to allow user-defined constructs to parse the same way

[17:54] <diakopter> p5eval: {}␤// urp

[17:54] <p5eval> diakopter: ERROR: Unrecognized character \xE2; marked by <-- HERE after {}<-- HERE near column 3 at (eval 7) line 1.

[17:54] <diakopter> oh yeah :)

[17:55] <TimToady> *always been that way in p6

[17:55] <diakopter> oh yeah, p5eval doesn't translate newlines

[17:55] <timotimo> i'm using eqat in three places in QRegex/Cursor.nqp, so hopefully we gain a tiny shred of parsing performance by sometimes not having to do a substring allocation for some parsings

[17:55] <diakopter> mebbe

[17:55] <timotimo> 4 places actually

[17:58] *** rindolf left
[18:02] *** denisboyun joined
[18:04] *** LlamaRider joined
[18:04] *** bluescreen10 left
[18:05] <LlamaRider> moritz++ thanks for explaining the bug-as-feature situation with pushing Match objects in Str arrays. I'm still wondering if there shouldn't be some automagic type-casting that invokes the .Str method of an object if it is being pushed in a Str array.

[18:05] <yoleaux> 17:35Z <TimToady> LlamaRider: an array with a declared type of Str only takes strings; you're probably expecting semantics more like the specced but not-yet-implemented Str() type, which would coerce to Str

[18:06] <LlamaRider> oh, there you go. I probably do.

[18:07] *** fhelmberger left
[18:08] *** darutoko left
[18:11] <[Coke]> https://gist.github.com/coke/6888956 - documented ops that do not appear in the test suite

[18:11] <[Coke]> (nqp)

[18:11] <LlamaRider> .tell TimToady I guess the interesting question is which operations should do type-coercion by default (if any). In my example, @string_array.push($0) really feels like coercing to Str would be the DWIM behaviour.

[18:11] <yoleaux> LlamaRider: I'll pass your message to TimToady.

[18:11] <[Coke]> ^^ in case anyone is bored. :)

[18:12] <[Coke]> (very simplistic test which I will check in later)

[18:14] *** SamuraiJack left
[18:15] <LlamaRider> interesting soup of ops there :)

[18:18] <diakopter> [Coke]: which test suite?

[18:19] *** rurban joined
[18:20] <PerlJam> Higgs finally got a Nobel prize http://www.nobelprize.org/nobel_prizes/physics/laureates/2013/

[18:22] <pmichaud> well, if Higgs hadn't been hiding out for so long, it might've occurred sooner.  :-)

[18:22] <rurban> I'm working on https://github.com/perl6/nqp/pull/76  new-packfile-api. Can someone familiar with latest nqp rebase new-packfile-api? I'll merge parrot also then

[18:22] <pmichaud> I mean, how long did the search take? 

[18:22] <rurban> new parrot/new-packfile-api with old nqp/new-packfile-api passes all tests

[18:23] <rurban> There are several nqp conflicts which I feel not being able to merge

[18:26] *** not_gerd joined
[18:26] <not_gerd> o/

[18:27] <diakopter> o/

[18:27] <rurban> hi not_gerd: I just finished your parrot/new-packfile-api and am now waiting on an updated nqp/new-packfile-api rebase. Could you do that or should we wait for Pm?

[18:28] <pmichaud> I already said I would re-do the nqp version of the patch.

[18:28] <rurban> super

[18:28] <pmichaud> (so no, please don't merge the existing patch)

[18:29] <pmichaud> also, we need to coordinate any nqp patch with a parrot release

[18:29] <rurban> I'll wait a bit then. The nqp rebase looked too tricky to me. There are also unrelated g++ strictness issues

[18:29] <pmichaud> right.

[18:30] <pmichaud> I just needed an up-to-date parrot branch to work from.

[18:30] <not_gerd> I remember the bootstrapping being somewhat tricky

[18:30] <not_gerd> I did not really understand what I was doing at the time

[18:30] <pmichaud> the bootstrapping can indeed be tricky.

[18:30] <not_gerd> trial&error until it worked ;)

[18:31] <not_gerd> I think I finally succeeded by bootstrapping the bootstrap via whiteknight's bootrstrap files

[18:31] <not_gerd> or something along these lines

[18:32] <pmichaud> it's one of those things that requires getting all the way to a working Rakudo before we can fully commit

[18:32] <diakopter> ah, so that's how the backdoor-injector sneaked in...

[18:34] <pmichaud> was there a September (5.8.0) release?

[18:34] <timotimo> what's the benefits of the new packfile api?

[18:35] <not_gerd> it was the first step on whiteknight's internals refactor

[18:35] <pmichaud> timotimo: main benefit will be that we can compile hll source directly to .pbc without having to generate a separate .pir file

[18:35] <not_gerd> basically, less magic

[18:35] <pmichaud> (we still go through PIR internally, but don't have to save it to a separate file and then recompile that with Parrot to get a .pbc)

[18:35] <not_gerd> eg you can just annotate subs with arbitrary tags and let a higher layer decide what it wants to do with that information

[18:36] <not_gerd> I removed the ->pir->pbc as an indentive to get whiteknight'S work merged ;)

[18:37] <timotimo> that sounds nice

[18:39] *** benabik left
[18:39] *** sqirrel joined
[18:39] <not_gerd> personally, I always wodered why there weren't more complaints about the extremely unfriendly module build process

[18:39] <not_gerd> I guess everyone was happily using panda

[18:39] <pmichaud> We can create a nqp branch that works with the parrot/new-packfile-api branch, but I don't want nqp to merge that to master until after there's a parrot release with its branch merged.

[18:40] *** nyuszika7h left
[18:40] <pmichaud> not_gerd: I suspect it's a bizarre case where people that knew enough to complain didn't want the responsibility of having to do something about it :)

[18:40] *** nyuszika7h joined
[18:42] <timotimo> my eqat implementation seems to actually be slower than taking a substr and eq-ing it

[18:43] <TimToady> does substr know that strings are immutable and avoid copying?

[18:43] <yoleaux> 18:11Z <LlamaRider> TimToady: I guess the interesting question is which operations should do type-coercion by default (if any). In my example, @string_array.push($0) really feels like coercing to Str would be the DWIM behaviour.

[18:43] <TimToady> LlamaRider: not if you're expecting it to intuit that only from its name

[18:44] <TimToady> people seem to want to put numbers into their arrays occasionally too...

[18:45] <TimToady> so really only an explicit declaration can produce those results

[18:45] <timotimo> i think he means a my Str @string_array

[18:45] <pmichaud> TimToady: in Parrot the substr op knows that it can avoid copying, yes.

[18:46] <Util> pmichaud: There was *not* a September release. (My fault) There is an October release scheduled on the 15th. 

[18:46] <dalek> evalbot/host07: 5126e0a | moritz++ | evalbot.pl:

[18:46] <dalek> evalbot/host07: use evalserver for rakudo-jvm

[18:46] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/5126e0aaf7

[18:46] <pmichaud> timotimo: your eqat implementation is for Parrot or JVM or ... ?

[18:46] *** camelia left
[18:46] <timotimo> for parrot

[18:46] <timotimo> the jvm version uses regionMatches method of String objects

[18:47] <timotimo> and moarvm has its own implementation, which is the prior art for this

[18:47] <pmichaud> good for the jvm version

[18:47] <dalek> evalbot/host07: 7529097 | moritz++ | evalbot.pl:

[18:47] <dalek> evalbot/host07: fix string terminator

[18:47] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/7529097154

[18:47] <timotimo> where do i have to look for the eq implementation atop parrot?

[18:47] <moritz> r: say 1

[18:47] *** camelia joined
[18:47] <moritz> r: say 1

[18:47] <Util> pmichaud: If it follows the patten of last year, then it will be a Supported release.

[18:47] <pmichaud> I'd need to look at the parrot implementation a bit.  I worked on a version of eqat once before for Parrot but had to abort due to time constraints

[18:47] <pmichaud> Util: okay, good.

[18:47] *** ChanServ sets mode: +v camelia

[18:48] <camelia> rakudo d7e5e1: OUTPUT«1␤»

[18:48] <moritz> do we still care to pretend that some releases are more supported than others?

[18:48] <timotimo> pmichaud: my current version of eqat has two STRING_ITER's running at the same time and i'm just comparing the advance_and_get return values against each other

[18:48] <timotimo> and i'm short-circuiting on failure

[18:48] <moritz> rakudo-jvm: say 42

[18:48] <camelia> rakudo-jvm: OUTPUT«Can't exec "/home/p6eval/jvm-rakudo/eval-client.pl": Permission denied at lib/EvalbotExecuter.pm line 183.␤exec (/home/p6eval/jvm-rakudo/eval-client.pl /home/p6eval_eval/p6eval-token run -e /tmp/IBJYwuEISQ) failed: Permission denied␤»

[18:48] *** jnap joined
[18:49] *** camelia left
[18:49] <dalek> evalbot/host07: bea1487 | moritz++ | evalbot.pl:

[18:49] <dalek> evalbot/host07: need perl 5 to run the eval-client

[18:49] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/bea1487da6

[18:49] <pmichaud> I'll try to have an nqp branch with the new packfile api changes in the next couple of days, so that parrot can make a decision about merging its packfile api branch to master

[18:49] <moritz> nqp: say(42)

[18:49] *** camelia joined
[18:49] <pmichaud> timotimo: I think the STRING_ITERs might be a little on the slow side.  Also it's important to know what string encoding lies underneath.

[18:49] *** ChanServ sets mode: +v camelia

[18:50] <moritz> nqp: say(42)

[18:50] <camelia> nqp: OUTPUT«42␤»

[18:50] <moritz> rakudo-jvm: say 42

[18:50] <camelia> rakudo-jvm: OUTPUT«Error while reading '/home/p6eval_eval/p6eval-token': Permission denied at /home/p6eval/jvm-rakudo/eval-client.pl line 10.␤»

[18:51] <moritz> rakudo-jvm: say 42

[18:51] <camelia> rakudo-jvm: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling -e␤Two terms in a row␤at -e:1␤------> [32m/tmp/[33m⏏[31mMG_ENJRCWj[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤       …»

[18:52] *** camelia left
[18:52] <dalek> evalbot/host07: 2e7952d | moritz++ | evalbot.pl:

[18:52] <dalek> evalbot/host07: do not mix -e and file name

[18:52] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/2e7952df87

[18:52] <moritz> rakudo-jvm: say 42

[18:53] <moritz> rakudo-jvm: say 42

[18:53] *** camelia joined
[18:53] *** jeffreykegler left
[18:53] *** ChanServ sets mode: +v camelia

[18:53] <moritz> nqp: say(42)

[18:53] <camelia> nqp: OUTPUT«42␤»

[18:53] <moritz> rakudo-jvm: say 42

[18:53] <camelia> rakudo-jvm: OUTPUT«Could not open /tmp/IMTMMZn4mW. java.nio.file.AccessDeniedException: /tmp/IMTMMZn4mW␤»

[18:53] <pmichaud> timotimo: Parrot's version of testing for string equality is src/string/encoding/shared.c:149

[18:54] <timotimo> thank you

[18:54] <timotimo> i was trying to find that, but failing

[18:54] <pmichaud> it only falls back to STRING_ITER if the two encodings are different.

[18:54] <pmichaud> which means that for most comparisons, it just does a memcmp

[18:54] <timotimo> the memcmp is probably much faster, yeah

[18:55] *** camelia left
[18:55] <dalek> evalbot/host07: 17cda89 | moritz++ | lib/EvalbotExecuter.pm:

[18:55] <dalek> evalbot/host07: make temp files world-reable

[18:55] <dalek> evalbot/host07: 

[18:55] <dalek> evalbot/host07: they just contain code that codes through IRC anyway

[18:55] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/17cda89fb9

[18:55] <pmichaud> is your version checked in somewhere that I can look at it?

[18:55] <pmichaud> I might see something quick and obvious

[18:56] *** camelia joined
[18:56] <pmichaud> (if not, no biggie)

[18:56] <moritz> rakudo-jvm: say 42

[18:56] <timotimo> i can push it into a nqp branch right now, hold on a sec

[18:56] <LlamaRider> TimToady, as timotimo suggested I meant a predeclared "my Str @string_array"; Then the .push($0) could figure out to coerce to $0.Str

[18:56] *** ChanServ sets mode: +v camelia

[18:56] <camelia> rakudo-jvm: OUTPUT«Could not open /tmp/ZvCrQ8TnYT. java.nio.file.AccessDeniedException: /tmp/ZvCrQ8TnYT␤»

[18:56] <pmichaud> unless things have changed,  my Str @array   specifies a constraint, not a coercion

[18:56] <moritz> BUT I CHMOD'ed IT!

[18:57] <pmichaud> thus @array.push(42)  should throw an exception.

[18:57] <dalek> nqp/eqat_op: aa949a8 | (Timo Paulssen)++ | src/vm/ (4 files):

[18:57] <dalek> nqp/eqat_op: add nqp::eqat to jvm and parrot.

[18:57] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/aa949a8d92

[18:57] <dalek> nqp/eqat_op: d0a8aad | (Timo Paulssen)++ | src/vm/parrot/stage0/ (9 files):

[18:57] <dalek> nqp/eqat_op: update bootstrap files

[18:57] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/d0a8aad340

[18:57] <dalek> nqp/eqat_op: 9bbc310 | (Timo Paulssen)++ | src/ (5 files):

[18:57] <dalek> nqp/eqat_op: use the new nqp::eqat op in a couple of places

[18:57] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/9bbc31003d

[18:57] <lue> hello world o/

[18:58] <pmichaud> oh, ouch ouch ouch

[18:59] <pmichaud> -                    if nqp::substr($spec, $pos, 1) eq '!' {

[18:59] <pmichaud> that's much faster using ord, I suspect.

[18:59] <pmichaud> (as would any single-char comparison)

[18:59] <pmichaud> oh, but that's not on a hotpath. never mind.

[18:59] <timotimo> won't eqat give at least a bit of speedup there, though?

[19:00] <pmichaud> only if it's on a hotpath.

[19:00] <timotimo> it should be able to skip a bit of initialisation of string boxes

[19:00] <pmichaud> also, I would prefer any form of eqat to be able to handle case insensitivity

[19:00] <LlamaRider> pmichaud that's exactly what I meant by "the tricky part is to figure out when coercions are DWIM and when they're a problem". Never doing implicit coercion is certainly a nice purist position. But coercing a Match to a Str seems generally a DWIM behaviour.

[19:00] <timotimo> how does an implementation of eqat that can do that look like?

[19:01] <pmichaud> basically, I think that eqat ought to expose the same sorts of features that regionMatches does in java

[19:01] <moritz> LlamaRider: that's what coercion types (NYI) are for

[19:01] <moritz> LlamaRider: or more to the point, when you want coercion to Str, most likely what you actually want is a type constraint of Cool, not Str

[19:01] <timotimo> i can make a second op that is insensitive to case, that's no problem

[19:01] <timotimo> but how do i do it in one op without pessimizing every use of it?

[19:02] <pmichaud> I'm fine if they're separate ops for now.

[19:02] <LlamaRider> moritz: I have to learn what Cool is first, then I can grock what you've said :)

[19:03] <timotimo> very well

[19:03] <pmichaud> it's bugged me for a long time that Parrot doesn't offer a case-insensitive compare op

[19:03] <timotimo> how do i properly get the offset turned into whatever i need to add to ->strstart?

[19:03] <timotimo> i'll need some kind of skipping/scanning operation for that

[19:03] <pmichaud> timotimo: I don't know that part off the top of my head.  :-/

[19:04] <timotimo> that's all right, i'll look at the source code or pester #parrot :)

[19:04] <pmichaud> but that's where the eqat operation might want to go lower-level than a parrot op -- i.e., down to the string encoding level.

[19:04] <pmichaud> or, if you want to leave it at the level of a parrot op, then just optimize for known encoding types, such as ucs4

[19:05] <pmichaud> i.e., if the target strings are ucs4, then you can calculate the offset directly and call memcmp

[19:05] <timotimo> there seems to be something called STRING_scan

[19:06] <timotimo> it turns into a ->scan on the encoding

[19:06] <pmichaud> there is a way to advance STRING_ITER, yes, and it (should be) already optimized for fixed with encodings

[19:06] <pmichaud> *fixed width

[19:07] <dalek> evalbot/host07: 85fbf79 | moritz++ | lib/EvalbotExecuter.pm:

[19:07] <dalek> evalbot/host07: another chmod

[19:07] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/85fbf79c19

[19:07] <timotimo> that gives the number of codepoints in a string, that's not the right thing it seems

[19:08] <dalek> evalbot/host07: c4fb432 | moritz++ | build.pl:

[19:08] <dalek> evalbot/host07: no need to sync on host07

[19:08] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/c4fb432965

[19:08] *** camelia left
[19:08] <TimToady> r: say fc("foo") eq fc("FOO")

[19:08] <dalek> evalbot/host07: 7fb4b53 | moritz++ | lib/EvalbotExecuter.pm:

[19:08] <dalek> evalbot/host07: fix syntax error, moritz--

[19:08] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/7fb4b53bc2

[19:09] <TimToady> enobot

[19:09] <moritz> TimToady: sorry, I'm breaking camelia right now :-)

[19:09] *** camelia joined
[19:09] <TimToady> r: say fc("foo") eq fc("FOO")

[19:09] *** ChanServ sets mode: +v camelia

[19:09] <camelia> rakudo d7e5e1: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/P1ygZwbHJH␤Undeclared routine:␤    fc used at line 1. Did you mean '&lc', '&uc', '&tc'?␤␤»

[19:09] <timotimo> indeed, i can extract the bytepos of the iter and memcmp with that

[19:10] <moritz> rakudo-jvm: say 42

[19:10] <TimToady> that is the correct way to do caseless comparison, Unicodically speaking

[19:10] <camelia> rakudo-jvm: OUTPUT«42␤»

[19:11] <dalek> evalbot/host07: ed7a1ff | moritz++ | evalbot.pl:

[19:11] <dalek> evalbot/host07: rj as alias for rakudo-jvm

[19:11] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/ed7a1ff27f

[19:11] <timotimo> TimToady: all over the code i see comparisons that use lc and eq ...

[19:12] <TimToady> fc is S32/StA:96r

[19:12] <TimToady> bleh

[19:12] <TimToady> fc is S32/Str:96

[19:13] <timotimo> pmichaud: how do you feel about turning substr + eq/ne into eqat automatically using the optimizer?

[19:13] <timotimo> (that could also do the ordat + a number comparison at optimize time for single-character strings)

[19:14] <pmichaud> timotimo: I'm not too fond of that.

[19:14] <timotimo> roger

[19:14] <pmichaud> that feels like a little too much magic.

[19:14] <timotimo> i've replaced all instances that don't have an lc forced around it for now anyway

[19:14] <timotimo> so there'd only be wins from new code from here on out

[19:14] <pmichaud> now then, eqat could do the ordat optimization whenever the length is constant 1

[19:14] <timotimo> is that something the op would do or the optimizer?

[19:15] <pmichaud> either, although having the op do it seems straightforward enough.

[19:17] <timotimo> depends. that could very well cause a pessimization at run-time because it has to check all the time

[19:17] <timotimo> at least now i got a compile run where the time was slightly less than in the unmodified version

[19:18] *** havenwood joined
[19:18] <timotimo> nqp: say(nqp::ordat("hello", 1))

[19:18] <camelia> nqp: OUTPUT«101␤»

[19:18] <pmichaud> ...why would that be a runtime pessimization?

[19:18] <timotimo> r: say chr(101);

[19:18] <camelia> rakudo d7e5e1: OUTPUT«e␤»

[19:19] <pmichaud> eqat can do the ordat optimization whenever the length is *constant 1*

[19:19] <pmichaud> at compile time

[19:19] <timotimo> pmichaud: because a check if the string is length-1 could already have been done at compile-time

[19:19] <timotimo> oh? i don't have to do anything for that?

[19:19] <pmichaud> depends on how the nqp::eqat op is constructed.

[19:19] <timotimo> ah, you mean the part where i add_pirop_mapping?

[19:20] <pmichaud> right, it doesn't have to be a straight-to-pir-op.

[19:20] <pmichaud> although the check for length 1 could easily be done inside the Parrot op, too.

[19:20] <pmichaud> and that might be faster than anything else.

[19:20] <pmichaud> anyway, as long as the nqp::eqat API is sane, it's easy to move the optimizations around underneath.

[19:20] <dalek> evalbot/host07: 59088e0 | moritz++ | build-scripts/rebuild-rakudo-jvm.sh:

[19:20] <dalek> evalbot/host07: rebuild script for rakudo jvm

[19:20] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/59088e054c

[19:22] <timotimo> ord already knows stuff about encodings and byte lengths and such, right? so i wouldn't have to muck about with encodings manually?

[19:22] <timotimo> of course it does.

[19:25] *** LlamaRider left
[19:26] <pmichaud> 18:48 <moritz> do we still care to pretend that some releases are more supported than others?

[19:27] <pmichaud> Whether we pretend it or not, the Parrot website still discusses such things, and Debian packagers may still care about it -- which means we have to be aware of it.

[19:28] <pmichaud> We don't want to paint ourselves into a corner of having Rakudo releases for which a "supported Parrot" won't ever be available.

[19:33] <dalek> nqp/eqat_op: 4cc669c | (Timo Paulssen)++ | src/vm/parrot/ops/nqp.ops:

[19:33] <dalek> nqp/eqat_op: special case same-encoding strings, length-1 needles.

[19:33] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/4cc669c4ee

[19:33] <timotimo> pmichaud: could you look at the branch that starts with 0 && for the strlen == 1 thing? it caused a strange error to occur which tells me eqat was wrong somewhere and caused a bad decision to be made in a regex or something

[19:34] <timotimo> i wasn't sure if STRING_ord takes a byte or character index

[19:34] <pmichaud> character, almost certainly.

[19:34] <timotimo> good, in that case i don't have to do the iterator trick, but it was wrong before i added that as well

[19:34] <timotimo> oh, haha

[19:35] <timotimo> i didn't set the offset local variable.

[19:43] *** cognominal__ joined
[19:43] <dalek> evalbot/host07: 4c128a7 | moritz++ | runtime/run-rakudo-jvm-evalserver:

[19:43] <dalek> evalbot/host07: tool for running the rakudo-jvm evalserver

[19:43] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/4c128a7f14

[19:43] <moritz> can somebody with a bit of p5 fu tell me why this script produces a syntax error?

[19:44] <moritz> Scalar found where operator expected at run-rakudo-jvm-evalserver line 26, near "wait $pid" (Do you need to predeclare wait?)

[19:44] <moritz> but isn't wait a builtin?

[19:46] <pmichaud> I don't think the builtin wait takes an argument.

[19:46] <pmichaud> you might be looking for waitpid

[19:46] <moritz> oh right

[19:46] <moritz> pmichaud++

[19:46] *** cognominal left
[19:47] <dalek> evalbot/host07: 4e0ce55 | moritz++ | runtime/run-rakudo-jvm-evalserver:

[19:47] <dalek> evalbot/host07: fix run-rakudo-jvm-evalserver, pmichaud++

[19:47] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/4e0ce5538a

[19:49] <timotimo> pmichaud: from my current approach, i cannot get visible speed improvements in parsing the rakudo setting (which is my benchmark for this)

[19:49] <dalek> evalbot/host07: 761e5b9 | moritz++ | runtime/run-rakudo-jvm-evalserver:

[19:49] <dalek> evalbot/host07: need to delete cookie first

[19:49] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/761e5b943d

[19:50] <moritz> r-j: say 42

[19:50] <camelia> rakudo-jvm: OUTPUT«42␤»

[19:50] <moritz> \o/

[19:50] <pmichaud> timotimo: when I did my early experiments with eqat, I also wasn't seeing significant improvements.

[19:50] <timotimo> though, i could do the thing now that completely replaces the eqat code by an ordat

[19:50] <pmichaud> I suspect they exist... we just haven't found the magic place for the speedup.

[19:50] * TimToady still thinks that should just be j anymore, with p for parrot and m for moar

[19:51] <timotimo> heh :)

[19:51] <timotimo> pmichaud: should i leave the replacements in? i can revert the commit so that later it could be dug out again :)

[19:52] <lue> and N for NQP :)

[19:52] <pmichaud> timotimo: whatever you and/or jnthn++ think is best

[19:52] <dalek> evalbot/host07: fb918f7 | moritz++ | evalbot.pl:

[19:52] <dalek> evalbot/host07: report revision for rakudo-jvm

[19:52] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/fb918f721b

[19:52] *** camelia left
[19:52] <timotimo> at this point i'd just leave them in

[19:53] *** camelia joined
[19:53] *** ChanServ sets mode: +v camelia

[19:54] <moritz> j: say 'lot its me!'

[19:54] <camelia> rakudo-jvm d7e5e1: OUTPUT«lot its me!␤»

[19:55] <TimToady> .oO(LOTCATS THESE DAZE)

[19:55] *** sqirrel left
[19:55] <moritz> TimToady: they don't even both to shout anymore :-)

[20:00] <timotimo> okay, going to test my ordat replacement trick now ...

[20:01] <timotimo> oh, no return in the qastcomp

[20:01] <timotimo> er, rather, Operations.nqp

[20:01] <timotimo> er ...

[20:01] <moritz> s/both/bother/

[20:02] <timotimo> Error while compiling op eqat (source text: "nqp::eqat($name, '!', 0)"): Could not find sub RETURN  -  ...?!

[20:02] <timotimo> what might i have messed up there?

[20:03] <timotimo> source text: "return 0 if nqp::eqat($name, '!', 0)"  -  that may be more helpful

[20:04] <timotimo> not using return in the operation helped compiling, huh

[20:05] <moritz> enough camelia hacking for today, g'night everybody

[20:05] <TimToady> o/

[20:06] *** xinming left
[20:07] *** slava left
[20:08] *** xinming joined
[20:09] *** lowpro30__ joined
[20:12] *** lowpro30_ left
[20:18] <diakopter> pmichaud: right, the benefit of the eqat on moar is it knows the internals

[20:18] <diakopter> er, forgot I was backlogging

[20:19] <pmichaud> diakopter: yes, we should be able to do something similar for Parrot, but haven't found the magic place for it yet.

[20:20] <timotimo> huh, what

[20:20] <timotimo> i have a debug say($op.dump) in the beginning of the add_core_op code block for eqat, that is not getting executed

[20:21] <timotimo> oh!

[20:21] <timotimo> that gets executed *after* stage ast, of course

[20:21] <diakopter> er

[20:22] <diakopter> no, it gets executed in BEGIN of nqp... so it's already run when you launch nqp

[20:22] <dalek> nqp/eqat_op: ec7c8fc | (Timo Paulssen)++ | src/vm/parrot/ops/nqp.ops:

[20:22] <dalek> nqp/eqat_op: STRING_ord takes chars, not bytes. local var thinko.

[20:22] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/ec7c8fc048

[20:22] <dalek> nqp/eqat_op: d60ae78 | (Timo Paulssen)++ | src/vm/parrot/QAST/Operations.nqp:

[20:22] <dalek> nqp/eqat_op: replace some eqat with ordat at compiletime.

[20:22] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/d60ae7898a

[20:23] *** Timbus left
[20:23] *** Timbus joined
[20:24] *** berekuk left
[20:24] *** berekuk joined
[20:25] <dalek> nqp/eqat_op: 2c6e75b | (Timo Paulssen)++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[20:25] <dalek> nqp/eqat_op: fix comment.

[20:25] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/2c6e75bea7

[20:26] <timotimo> i'll run a spectest to see if anything b0rked

[20:31] *** lowpro30 joined
[20:33] *** lowpro30 left
[20:33] *** Rotwang left
[20:35] *** lowpro30__ left
[20:36] *** lizmat joined
[20:39] *** kaare_ left
[20:40] <timotimo> some tests are failing, but i'll go to bed in order to get a fresh look at all this tomorrow

[20:43] <timotimo> i'm guessing "Cannot get character past end of string" comes from the guts of parrot?

[20:45] <not_gerd> bye, #perl6

[20:45] *** not_gerd left
[20:45] <timotimo> probably just have to check for ranges and bail out if necessary

[20:46] <timotimo> nqp: nqp::ordat("hi", 100)

[20:46] <camelia> nqp: OUTPUT«Cannot get character past end of string␤current instr.: '' pc 40 ((file unknown):36113271) (/tmp/9pLSwLi6sM:2)␤»

[20:46] <timotimo> oh, that needs a range check now, too ...

[20:46] <timotimo> nqp: nqp::substr("hi", 100, 1)

[20:46] <camelia> nqp: OUTPUT«Cannot take substr outside string␤current instr.: '' pc 40 ((file unknown):55417111) (/tmp/3LEbFrm_g0:0)␤»

[20:46] <timotimo> nqp: nqp::substr("hi", 1, 100)

[20:46] <camelia> nqp: ( no output )

[20:46] <timotimo> hm.

[20:46] <timotimo> not as bad as i feared

[20:46] <timotimo> anyway. off to bed i go :)

[20:49] *** ssutch left
[20:52] *** PacoAir left
[20:59] *** donaldh joined
[21:04] *** btyler left
[21:06] *** bbkr_ left
[21:06] *** sivoais left
[21:06] *** skids left
[21:06] *** sivoais joined
[21:07] *** rom1504 joined
[21:10] *** lowpro30 joined
[21:12] *** FROGGS joined
[21:13] <FROGGS> o/

[21:14] <FROGGS> mental not: drinking beer with uk-ppl is challenging

[21:14] <FROGGS> note*

[21:15] *** lowpro30_ joined
[21:16] *** btyler joined
[21:19] *** LlamaRider joined
[21:19] *** lowpro30 left
[21:27] <lizmat> FROGGS: fwiw, I have the same with a lot of German beer drinking  :-)

[21:29] <donaldh> hmm, yes, culturally predisposed to volume drinking.

[21:29] *** stevan_ left
[21:36] <lizmat> zum Wohl!

[21:41] <lizmat> masak: re http://irclog.perlgeek.de/perl6/2013-10-08#i_7686276, :delete on an array should *not* be like splice, because that would be changing the "keys" on the array

[21:43] <lizmat> if you delete a key from a hash, the implementation might decide to keep the entry in place and just mark it as deleted

[21:43] <lizmat> I see doing :delete on an array as the same

[21:44] <lizmat> also: "normal" users of arrays, would never use :delete on an array, unless they would know what they're doing

[21:45] <lizmat> the question to me is, *if* iterating over an array with deleted elements would skip those, should .elems not be reflecting that as well?

[21:45] <lizmat> in other words: .elems would be the number of undeleted elements

[21:45] <lizmat> .end would still show the last element index

[21:46] <lizmat> and perhaps we should have a "is sparse" trait on arrays to allow :delete to work

[21:47] * donaldh is failing to grok the priorInvocation replacement in MoarVM. Or rather, failing to map it across to JVM.

[21:47] <rurban> The challenge with uk/us-ppl and beer is to avoid ale and stout. We germans are used to lager and pils

[21:48] <pmichaud> lizmat: the analogous case would be something like   my @a;  @a[3] = 'abc';    say @a.elems

[21:48] <pmichaud> I'd expect that to be 4, not 1.

[21:48] <pmichaud> (so no, don't skip over empty elems)

[21:49] <lizmat> r: my @a; @a[3]=1; say @a[1,2,3]:exists

[21:49] <camelia> rakudo d7e5e1: OUTPUT«False False True␤»

[21:49] <diakopter> donaldh: point me to the relevant diff(s) and I'll explain

[21:49] <lizmat> r: my @a; @a[3]=1; say @a[^3]:exists

[21:49] <camelia> rakudo d7e5e1: OUTPUT«False False False␤»

[21:49] <pmichaud> r: my @a; @a[3] = 1; say @a[^4]:exists

[21:49] <camelia> rakudo d7e5e1: OUTPUT«False False False True␤»

[21:50] <lizmat> pmichaud: hence maybe the "is sparse" trait ?

[21:50] <pmichaud> I think S09 already addresses something like this.

[21:50] <pmichaud> but I could be wrong about that.

[21:51] <donaldh> diakopter: tbh, I've run out of time before a week's vacation so will need to leave it 'til I return.

[21:51] *** sqirrel joined
[21:51] <donaldh> diakopter: unless someone else gets there first :-)

[21:53] *** ajr_ left
[21:56] *** lowpro30_ left
[21:58] <lizmat> pmichaud: S09:589 "The C<.keys> method also returns the keys of all existing elements."  

[21:58] <synopsebot> Link: http://perlcabal.org/syn/S09.html#line_589

[21:58] <lizmat> but that seems to apply to arrays with predefined element lists

[21:58] <lizmat> but I wonder why those should be different from "normal" arrays, really

[22:01] <lizmat> on the other other hand, I guess it's not too much problem to say "@a[]:v" instead of @a when iterating

[22:02] <lizmat> r: my @a; @a[3]=42; .say for @a[]:v

[22:02] <camelia> rakudo d7e5e1: OUTPUT«   42␤»

[22:02] <lizmat> r: my @a; @a[3]=42; .say for @a

[22:02] <camelia> rakudo d7e5e1: OUTPUT«(Any)␤(Any)␤(Any)␤42␤»

[22:05] <lizmat> r: my @a; @a[3]=42; .WHAT..say for @a   # whoa!

[22:05] <camelia> rakudo d7e5e1: OUTPUT«(timeout)␤␤␤␤use of uninitialized value of type Any in string context  in block  at /tmp/5yqRh05VK4:1␤␤»

[22:05] <lizmat> not sure this warrants a rakudobug

[22:05] * grondilu can not parse .WHAT..say for @a 

[22:06] <lizmat> it was a typo

[22:06] <lizmat> but the result parsed apparently in a way that hangs

[22:06] *** BenGoldberg joined
[22:06] <grondilu> std: .WHAT..say for my @

[22:06] <camelia> std a0bcfb1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/1IcZTrCCr2 line 1:␤------> [32m.WHAT..say[33m⏏[31m for my @[0m␤Check failed␤FAILED 00:01 124m␤»

[22:06] <lizmat> 100% CPU usage and slow memory growth

[22:07] <grondilu> std: .WHAT..say(Mu) for my @

[22:07] <camelia> std a0bcfb1: OUTPUT«ok 00:01 124m␤»

[22:07] <grondilu> std: .WHAT .. say(Mu) for my @

[22:07] <camelia> std a0bcfb1: OUTPUT«ok 00:01 124m␤»

[22:07] <grondilu> std: .WHAT .. say(Mu)

[22:07] <camelia> std a0bcfb1: OUTPUT«ok 00:01 123m␤»

[22:07] <grondilu> yeah, why not.

[22:09] <lizmat> the bar is closing, later&

[22:09] *** lizmat left
[22:12] *** denisboyun left
[22:17] *** LlamaRider left
[22:27] *** BenGoldberg left
[22:35] *** BenGoldberg joined
[22:37] <jnthn> evening, #perl5

[22:37] <yoleaux> 22:27Z <diakopter> jnthn: I saw this, which led me to notice that TCC is almost done switching its license from lgpl to mit-style...! easy assembler! http://blogs.perl.org/users/david_mertens/2013/08/ctinycompiler-a-just-in-time-c-compiler-for-perl.html

[22:37] <jnthn> uh

[22:37] <jnthn> #perl6

[22:38] *** pecastro_ joined
[22:38] *** jnap left
[22:39] *** lizmat joined
[22:41] *** pecastro left
[22:41] *** woolfy joined
[22:43] *** donaldh left
[22:46] *** jnap joined
[22:47] *** PZt left
[22:54] *** LlamaRider joined
[22:56] *** LlamaRider left
[23:01] *** btyler left
[23:02] *** sqirrel left
[23:08] * [Coke] waves.

[23:11] *** grondilu left
[23:16] *** grondilu joined
[23:18] <dalek> nqp: 4c66315 | coke++ | t/docs/opcodes.t:

[23:18] <dalek> nqp: remove unneeded use.

[23:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4c66315635

[23:18] <dalek> nqp: 23768fd | coke++ | t/docs/tests.t:

[23:18] <dalek> nqp: Add test to see if opcodes are tested

[23:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/23768fd8ed

[23:18] *** sqirrel joined
[23:23] <[Coke]> that new test is braindead, but an ok start. (many opcodes are untested)

[23:23] *** colomon left
[23:24] <dalek> nqp/eqat_op: 84eac7b | coke++ | docs/ops.markdown:

[23:24] <dalek> nqp/eqat_op: add docs for eqat opcode

[23:24] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/84eac7b181

[23:24] <[Coke]> ^^ there is also an "eqat_internal" op. what's up with that?

[23:25] *** woolfy left
[23:26] * jnthn has no idea...

[23:26] <TimToady> it's internal, so you're not supposed to know about it

[23:27] <[Coke]> it's just /called/ internal. :P

[23:28] *** havenwood left
[23:28] *** sqirrel left
[23:28] <[Coke]> I suspect we might want to rename the internal one "parroteqat".

[23:28] <[Coke]> to go along with the jvm* ones.

[23:28] <TimToady> The question is, who's to be encapsulated, that's all.  --The Encapsulated One

[23:29] <TimToady> </splat>

[23:30] <[Coke]> jnthn: when testing to see if an opcode is tested, I'm checking to see if "nqp::<op>" appears in t/ - would adding a check for ":op('<op>')" be a good second approximation?

[23:31] *** airdisa joined
[23:31] <jnthn> [Coke]: If we rely on it as part of the bootstrap then it's at least tested that way

[23:32] *** BenGoldberg left
[23:32] <[Coke]> sure, that's fine for this level of testing.

[23:33] <[Coke]> can you point me at a set of dirs to poke at for the bootstrap file? src/NQP?

[23:34] <jnthn> src/NQP, src/how, src/core, src/HLL, src/QRegex

[23:35] *** colomon joined
[23:37] *** slavik left
[23:38] *** BenGoldberg joined
[23:41] <[Coke]> jnthn++ #forgot to do it in the commit.

[23:41] <dalek> nqp: 3e2c825 | coke++ | t/docs/tests.t:

[23:41] <dalek> nqp: consider bootstrap and QAST as testing.

[23:41] <dalek> nqp: 

[23:41] <dalek> nqp: jnthn++

[23:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3e2c8255ab

[23:41] <[Coke]> (managed to sneak it in .)

[23:42] <jnthn> :)

[23:44] *** BenGoldberg left
[23:46] *** slavik joined
[23:47] <[Coke]> http://blogs.perl.org/users/blindluke/2013/10/spewing-sentences.html - waiting for the followup perl6 post

[23:53] <[Coke]> jnthn: are the boot* opcodes intended to be x-platform?

[23:53] <[Coke]> or jvm specific?

[23:54] <jnthn> [Coke]: No, Moar has them also

[23:55] <jnthn> [Coke]: Parrot doesn't however.

[23:56] * [Coke] ponders how to document that.

[23:57] <diakopter> [Coke]: actually

[23:57] <jnthn> [Coke]: "Should be provided by any non-Parrot backend" :P

[23:57] <diakopter> you can test if all the nqp ops are used in the --dump output of the *.moarvm in nqp

[23:58] <[Coke]> diakopter: that doesn't help running the tests on a parrot nqp.

[23:58] *** dayangkun left
[23:58] <[Coke]> (nor that that's not in master yet. ;)

[23:59] <[Coke]> I do like the idea of checking based on the executables, though.

[23:59] *** BenGoldberg joined
