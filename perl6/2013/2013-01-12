[00:07] <dalek> rakudo/nom: c3f565d | jnthn++ | src/Perl6/Metamodel/ParametricRole (2 files):

[00:07] <dalek> rakudo/nom: Add missing parameterize method.

[00:07] <dalek> rakudo/nom: 

[00:07] <dalek> rakudo/nom: Fixes bug with providing args to an imported parameteric role.

[00:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3f565deac

[00:08] <jnthn> sleep &

[00:08] <not_gerd> good night

[00:14] *** aindilis` left
[00:14] *** pmurias left
[00:14] *** aindilis` joined
[00:29] *** aindilis` left
[00:29] <TimToady> timotimo: note that Perl 5 supports two-level ^D

[00:37] <timotimo> not everything perl5 does, perl 6 has to do. but you would be in favor of having double layer \^D in perl6 too, yes

[00:37] <timotimo> missed a question mark there.

[00:39] <timotimo> just to be sure: zipping two infinite lazy lihsts with Z shpuld be lazy, too, roght?

[00:41] <colomon> timotimo: yes

[00:41] <colomon> rn: my @z := 1..* Z 2, 4, 8 ... *; say @z[^10]

[00:41] <p6eval> rakudo c3f565: OUTPUT«1 2 2 4 3 8 4 16 5 32 6 64 7 128 8 256 9 512 10 1024␤»

[00:41] <p6eval> ..niecza v24-17-gd343a2a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤"Z" and "..." are non-associative and require parens at /tmp/PFSGLM4AaQ line 1:␤------> [32mmy @z := 1..* Z 2, 4, 8 ... [33m⏏[31m*; say @z[^10][0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/COR…

[00:41] <timotimo> maybe i can figure 0ut whats wrong. probably not thpigh

[00:42] <colomon> err, that was not al all what I had expected.

[00:42] <colomon> rn: my @z := 1..* Z (2, 4, 8 ... *); say @z[^10]

[00:42] <p6eval> rakudo c3f565, niecza v24-17-gd343a2a: OUTPUT«1 2 2 4 3 8 4 16 5 32 6 64 7 128 8 256 9 512 10 1024␤»

[00:42] <colomon> rn: my @z := 1..* Z (2, 4, 8 ... *); say @z[^10].perl

[00:42] <p6eval> rakudo c3f565, niecza v24-17-gd343a2a: OUTPUT«((1, 2), (2, 4), (3, 8), (4, 16), (5, 32), (6, 64), (7, 128), (8, 256), (9, 512), (10, 1024))␤»

[00:43] <timotimo> r: for ((0 ... *) Z (5, 6, 7, 8)) -> $a, $b { say "$a, $b"; last if $b >= 6 }

[00:43] <p6eval> rakudo c3f565: OUTPUT«0, 5␤1, 6␤»

[00:44] <timotimo> phone keyboard no good for perl6 coding

[00:44] <timotimo> could you turn that second lost infinite for me please/?

[00:45] *** ServerSage left
[00:56] *** stopbit left
[00:59] <timotimo> r: for ((0, 2, 4 ... *) Z (0, 1 ... *)) -> $a, $b { say "$a, $b"; last if $b >= 6 }

[00:59] <p6eval> rakudo c3f565: OUTPUT«(timeout)»

[00:59] <timotimo> colomon: that's what i meant. why doesn't this behave lazily?

[01:01] <colomon> timotimo: I believe you will find that "for" is the problem there....

[01:01] <timotimo> r: map ((0, 2, 4 ... *) Z (0, 1 ... *)) -> $a, $b { say "$a, $b"; last if $b >= 6 }

[01:01] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/nGTrYkOf5x:1␤------> [32mmap ((0, 2, 4 ... *) Z (0, 1 ... *)) [33m⏏[31m-> $a, $b { say "$a, $b"; last if $b >= [0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤…

[01:01] <timotimo> r: map ((0, 2, 4 ... *) Z (0, 1 ... *)), -> $a, $b { say "$a, $b"; last if $b >= 6 }

[01:01] <p6eval> rakudo c3f565: OUTPUT«Cannot call 'map'; none of these signatures match:␤:(&code, *@values)␤␤  in block  at /tmp/rCJuvWmy2j:1␤␤»

[01:01] <colomon> n: for ((0, 2, 4 ... *) Z (0, 1 ... *)) -> $a, $b { say "$a, $b"; last if $b >= 6 }

[01:01] <timotimo> hah, wrong way

[01:01] <p6eval> niecza v24-17-gd343a2a: OUTPUT«0, 0␤2, 1␤4, 2␤6, 3␤8, 4␤10, 5␤12, 6␤»

[01:05] <colomon> rn:  ((0, 2, 4 ... *) Z (0, 1 ... *)).map(-> $a, $b { say "$a, $b"; last if $b >= 6 })

[01:05] <p6eval> rakudo c3f565: OUTPUT«(timeout)»

[01:05] <p6eval> ..niecza v24-17-gd343a2a:  ( no output )

[01:05] <colomon> errr, that's probably too lazy.

[01:05] <timotimo> does last even work with map? i suppose it should, but what do i know :P

[01:05] <colomon> rn: say ((0, 2, 4 ... *) Z (0, 1 ... *)).map(-> $a, $b { say "$a, $b"; last if $b >= 6 })

[01:06] <p6eval> rakudo c3f565: OUTPUT«(timeout)»

[01:06] <p6eval> ..niecza v24-17-gd343a2a: OUTPUT«0, 0␤2, 1␤4, 2␤6, 3␤8, 4␤10, 5␤12, 6␤␤»

[01:06] <colomon> okay, I can't explain what rakudo is doing there at all.

[01:07] <colomon> actually, I can't explain niecza either.  sigh.

[01:07] <timotimo> :D

[01:07] <timotimo> why can't you explain what niecza does? :| - because the .map seems to be lazy even though in void context? (or is this non-void context because it's the "last expression in the block"?)

[01:08] <timotimo> n: ((0, 2, 4 ... *) Z (0, 1 ... *)).map(-> $a, $b { say "$a, $b"; last if $b >= 6 }); say "woop woop";

[01:08] <p6eval> niecza v24-17-gd343a2a: OUTPUT«woop woop␤»

[01:08] <timotimo> n: my @l = ((0, 2, 4 ... *) Z (0, 1 ... *)).map(-> $a, $b { say "$a, $b"; last if $b >= 6 }); say "woop woop";

[01:08] *** not_gerd left
[01:08] <p6eval> niecza v24-17-gd343a2a: OUTPUT«Potential difficulties:␤  @l is declared but not used at /tmp/t6jbcINygd line 1:␤------> [32mmy [33m⏏[31m@l = ((0, 2, 4 ... *) Z (0, 1 ... *)).ma[0m␤␤0, 0␤2, 1␤4, 2␤6, 3␤8, 4␤10, 5␤12, 6␤woop woop␤»

[01:09] *** am0c joined
[01:10] <colomon> the problem with doing map this way is mixing laziness and side effects.

[01:11] <timotimo> it always is, isn't it? :)

[01:33] *** whiteknight left
[02:12] <skids> r: multi sub infix:<div> (Int $a, Int $b, :$rem! is rw) { $rem = $a % $b; $a div $b; }; my $r ; say 10..12 Xdiv 3 :rem($r); say $r;

[02:12] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤You can't adverb that␤at /tmp/DTqDGs4ip7:1␤------> [32mb; }; my $r ; say 10..12 Xdiv 3 :rem($r)[33m⏏[31m; say $r;[0m␤»

[02:12] <skids> Obviously we need a syntax for "hyper/meta adverbs"

[02:12] <skids> :-)

[02:14] *** PacoAir left
[02:15] *** FROGGS_ joined
[02:16] <skids> r: multi sub infix:<div> (Int $a, Int $b, :$rem! is rw) { $rem = $a % $b; $a div $b; }; my $r ; say (10..12) »div» 3 :rem($r); say $r; # Error message is less awesome than the previous error message, which was pretty awesome.

[02:16] <p6eval> rakudo c3f565: OUTPUT«Unexpected named parameter 'rem' passed␤  in block  at src/gen/CORE.setting:12784␤  in block  at /tmp/IWm1Lggos5:1␤␤»

[02:18] *** FROGGS left
[02:32] *** grondilu left
[03:22] *** wk_ left
[03:44] *** orafu left
[03:55] *** atrodo left
[04:21] *** aindilis joined
[04:33] *** preflex left
[04:35] *** preflex joined
[04:52] *** Pleiades` left
[04:57] *** Pleiades` joined
[05:32] *** benabik joined
[06:03] *** cognominal left
[06:21] *** cognominal joined
[06:35] *** am0c left
[06:36] *** Pleiades` left
[06:37] *** SunilJoshi joined
[06:39] *** Pleiades` joined
[07:13] *** _jaldhar joined
[07:22] *** aindilis left
[07:28] *** kaare_ joined
[07:36] *** am0c joined
[07:37] *** _jaldhar left
[07:46] <tipdbmp> What's the syntax for the Perl 5's: $var = $could_be_false || $not_false; and $var = $if_not_defined // $default_value;? Or in other words do the || and // operators exist / work in Perl 6?

[07:47] <PerlJam> yes

[07:47] <tipdbmp> r: say 0 || 1;

[07:47] <p6eval> rakudo c3f565: OUTPUT«1␤»

[07:48] <tipdbmp> r: my $var = '' || 4; say $var;

[07:48] <p6eval> rakudo c3f565: OUTPUT«4␤»

[07:49] <tipdbmp> I asked because I was getting: "Undefined routine '&prefix:<|>'", I guess I have an old perl6.

[07:53] <PerlJam> tipdbmp: I can imagine some weird spacing issue might cause that error

[07:56] <tipdbmp> perl6 -e 'my $var = '' || 4; say $var;' # This gives me the above error.

[07:56] <moritz> tipdbmp: because the shell swallows the ''

[07:56] <tipdbmp> Oh...

[07:57] <tipdbmp> Silly me..., tnx.

[07:58] *** am0c left
[08:06] *** kaare_ left
[08:29] *** FROGGS_ is now known as FROGGS

[08:29] <FROGGS> morning

[08:29] <phenny> FROGGS: 11 Jan 22:33Z <jnthn> tell FROGGS Multi merge stuff is merged. Thanks!

[08:30] <FROGGS> phenny: tell jnthn: thanks! ;o) \o/

[08:30] <phenny> FROGGS: I'll pass that on when jnthn is around.

[08:41] *** SunilJoshi left
[08:47] *** SunilJoshi joined
[09:03] *** SunilJoshi left
[09:04] <dalek> Heuristic branch merge: pushed 23 commits to rakudo/froggs_multibyte by FROGGS

[09:05] *** GlitchMr joined
[09:15] *** Chillance joined
[09:15] <moritz> r: sub f { @_ = (1, 2) }; f()

[09:15] <p6eval> rakudo c3f565:  ( no output )

[09:16] *** cognominal left
[09:25] <moritz> r: sub f($x is rw = 42) { }

[09:25] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot use 'is rw' on an optional parameter␤at /tmp/H21InfjDep:1␤------> ␤»

[09:25] <moritz> r: try eval q[ sub f($x is rw = 42) { }]; say $!.perl

[09:25] <p6eval> rakudo c3f565: OUTPUT«X::Comp::AdHoc.new(filename => "eval_0", line => 1, column => Any, modules => Array.new(), is-compile-time => Bool::True, pre => Any, post => Any, highexpect => Array.new(), payload => "Cannot use 'is rw' on an optional parameter")␤»

[09:29] <moritz> r: multi a($) { }; say &a

[09:29] <p6eval> rakudo c3f565: OUTPUT«sub a(Mu ) { ... }␤»

[09:29] <moritz> r: multi a($) { }; &a

[09:29] <p6eval> rakudo c3f565:  ( no output )

[09:31] <moritz> r: multi a($) { }␤ &a

[09:31] <p6eval> rakudo c3f565: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'a' will never work with no arguments (line 2)␤    Expected any of:␤    :()␤»

[09:31] <moritz> that's very weird

[09:31] * moritz submits rakudobug

[09:33] <moritz> r: multi a($) { };␤ &a

[09:33] <p6eval> rakudo c3f565:  ( no output )

[09:33] <FROGGS> r: sub a($) { }␤ &a

[09:33] <p6eval> rakudo c3f565: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'a' will never work with no arguments (lines 2, 2)␤    Expected: :()␤»

[09:36] *** SamuraiJack joined
[09:37] <moritz> oh, i guess it's just a parse error

[09:37] <moritz> it parses it as    (multi a($) { }) & a

[09:41] *** rhr joined
[09:42] *** Psyche^ joined
[09:44] * moritz unsubmits rakudobug

[09:44] <moritz> that one is already known

[09:44] <dalek> roast: aedecf7 | moritz++ | S06-advanced/wrap.t:

[09:44] <dalek> roast: failing test for RT #77472, wrap on a multi

[09:44] <dalek> roast: review: https://github.com/perl6/roast/commit/aedecf78a9

[09:46] *** Patterner left
[09:46] *** Psyche^ is now known as Patterner

[09:54] *** SamuraiJack left
[09:57] *** not_gerd joined
[09:57] <not_gerd> hello, #perl6

[09:58] <not_gerd> jnthn, masak: macro serialization fail https://gist.github.com/4517030

[09:58] *** SamuraiJack joined
[10:00] *** SamuraiJack left
[10:01] *** SamuraiJack joined
[10:02] <moritz> I think declarations in quasis are known to be not yet implemented

[10:04] <not_gerd> moritz: macro Foo { quasi { my $foo = 42 } }

[10:04] <not_gerd> ^ does compile

[10:04] <moritz> oh

[10:05] <moritz> just precompilation is affected

[10:05] <not_gerd> (didn't check if it actually works though ;))

[10:22] <moritz> r: my @a; @a.push(0) and say 42

[10:22] <p6eval> rakudo c3f565: OUTPUT«42␤»

[10:23] *** SunilJoshi joined
[10:28] *** PacoAir joined
[10:33] <dalek> roast: b1cba00 | moritz++ | S04-declarations/my.t:

[10:33] <dalek> roast: RT #102650: scoping bug in statement-modifying for-loops

[10:33] <dalek> roast: review: https://github.com/perl6/roast/commit/b1cba00c7a

[10:38] *** spider-mario joined
[10:42] <moritz> today's finding: I'd love to be able to use identifiers in regexes without quoting

[10:42] <moritz> nr: /foo-bar/

[10:42] <p6eval> niecza v24-17-gd343a2a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unrecognized regex metacharacter - (must be quoted to match literally) at /tmp/cQwijFVGB7 line 1:␤------> [32m/foo-[33m⏏[31mbar/[0m␤␤Unable to parse regex; couldn't find final '/' at /tmp/cQwijFVGB7 line 1:␤------> [32m…

[10:42] <p6eval> ..rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at /tmp/3pu5he0TuT:1␤------> [32m/foo[33m⏏[31m-bar/[0m␤Unable to parse regex; couldn't find final '/'␤at /tmp/3pu5he0TuT:1␤------> [32m/foo-[33m⏏[31mbar/[0…

[10:43] <masak> 'mornin', #perl6

[10:44] <tadzik> hello masak 

[10:44] <moritz> good antenoon, masak

[10:46] <dalek> roast: faa03a3 | moritz++ | / (2 files):

[10:46] <dalek> roast: RT #103034: correct file names in backtraces

[10:46] <dalek> roast: review: https://github.com/perl6/roast/commit/faa03a3e04

[10:47] <moritz> masak: though I've learned that the correct English word for antenoon is "forenoon"

[10:47] <moritz> that was a fun test to write

[10:47] <timotimo> apparently, wanting to draft/write the blog post on void context was not such a good idea. it would probably need someone who knows a lot more about that topic to do one.

[10:48] <masak> moritz: "forenoon", I like.

[10:50] <masak> n: package Foo; sub ucfirst($thing) is export(:DEFAULT) { 'overridden ucfirst' }

[10:50] <p6eval> niecza v24-17-gd343a2a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Semicolon form of package definition indicates a Perl 5 module; unfortunately,␤  STD doesn't know how to parse Perl 5 code yet at /tmp/DFDeCnHYp0 line 1:␤------> [32mpackage Foo[33m⏏[31m; sub ucfirst($thing) is export(:DE…

[10:50] <masak> oh :)

[10:50] <masak> n: module Foo; sub ucfirst($thing) is export(:DEFAULT) { 'overridden ucfirst' }

[10:50] <p6eval> niecza v24-17-gd343a2a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Export tags NYI at /tmp/tIzsO9lzpQ line 1:␤------> [32msub ucfirst($thing) is export(:DEFAULT) [33m⏏[31m{ 'overridden ucfirst' }[0m␤␤Potential difficulties:␤  $thing is declared but not used at /tmp/tIzsO9lzpQ line 1:␤--…

[10:51] <masak> oh, it's $thing that's declared but not used.

[10:51] <masak> I honestly think that warning is superfluous for parameters.

[10:52] <masak> there are many cases where I declare a parameter and then not bother to use it.

[10:52] <masak> could be multis, could be for consistency with other signatures.

[10:52] *** PacoAir left
[10:52] <masak> and we're discouraging giving variables self-explanatory names.

[10:52] *** PacoAir joined
[10:53] <masak> "oh, that variable is called $explanation and it's not used inside the function -- interesting"

[10:53] <masak> instead of "huh, wonder why we accept a $ here, better look elsewhere in the code for clues..."

[10:54] <timotimo> put "shift" all over the place in the method! in loops and conditional code!

[10:54] <masak> :)

[10:54] <masak> no use lingering on old sins.

[10:55] <masak> CPAN has had function/method signatures for ages.

[10:57] *** Tzimisces joined
[10:59] <masak> Tzimisces: welcome!

[11:12] <Tzimisces> masak: thanks. Bit new to IRC I'm afraid.

[11:12] <moritz> we all started out as newbies :-)

[11:13] <Tzimisces> That's a comforting thing to know :)

[11:15] <Tzimisces> I actually wondered how the "Perl 6" thing was going - having picked up "Perl 6 and Parrot Essentials" yesterday.

[11:16] <moritz> well, the first thing note is that "Perl 6 and Parrot Essentials" is hopelessly out of date

[11:16] <Tzimisces> .. having partially read that some years ago.

[11:16] <Tzimisces> I was afraid that that would be the case :)

[11:16] <moritz> it gives some good ideas about the underlying design principles, but most of the hard facts and the syntax is subtly to blatantly out of date

[11:17] <moritz> as for how it goes: we now have two compilers (Rakudo and Niecza) that have monthly releases

[11:17] <moritz> and there's a group of hackers in here which use them on a daily basis

[11:17] <moritz> reports of production usage are slowly trickling in

[11:17] <moritz> I find both compilers quite usable, though slow

[11:18] <moritz> oh, and you can ask them to execute code here on IRC

[11:18] <moritz> rn: my $name = 'Tzimisces'; greet($name); sub greet($x) { say "Hello, $x" }

[11:18] <p6eval> rakudo c3f565, niecza v24-17-gd343a2a: OUTPUT«Hello, Tzimisces␤»

[11:18] <Tzimisces> Nice :)

[11:18] <moritz> sometimes they produce different output

[11:18] <Tzimisces> I picked up Rakudo today. Not too much modules coming along with it. I assume they should be picked up using, ehm, Panda.

[11:19] <moritz> rn: say rand

[11:19] <p6eval> niecza v24-17-gd343a2a: OUTPUT«0.020615898547980887␤»

[11:19] <p6eval> ..rakudo c3f565: OUTPUT«0.307264634016068␤»

[11:19] <moritz> right

[11:19] <moritz> rakudo star comes with a few useful modules, and panda

[11:21] <Tzimisces> saw that. Is there any coordinated development to get to something like a "standard Perl 5 installation", with modules, manual pages?

[11:22] <not_gerd> r: my @foo = bar => 42, <a b>; say \(@foo).perl

[11:22] <p6eval> rakudo c3f565: OUTPUT«Capture.new( list => ("bar" => 42, "a", "b").list, hash => EnumMap.new())␤»

[11:22] <not_gerd> ^^  how do I get bar into hash?

[11:26] <moritz> r: say (bar => 42, <a b>).perl

[11:26] <p6eval> rakudo c3f565: OUTPUT«("bar" => 42, ("a", "b"))␤»

[11:27] <moritz> r: my @foo = bar => 42, <a b>; say \(|@foo).perl

[11:27] <p6eval> rakudo c3f565: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (lines 1, 1)␤»

[11:28] <moritz> not_gerd: I don't think so. The distinction if a parameter is named is syntactic. By the tiem you flatten it into an array, that information is gone.

[11:28] <moritz> s/so/you can/

[11:28] <not_gerd> moritz: that's pretty sad as it makes signatures far less useful for introspecting data structures :(

[11:29] <moritz> Tzimisces: star is such an effort; but mostly we still focus our efforts on the compiler, so star gets less attention

[11:29] <moritz> not_gerd: maybe there is such a way, and I simply don't know about it

[11:30] <moritz> or maybe there should be a way.

[11:31] <Tzimisces> okay, thanks. I'll give it a try then :)

[11:35] <dalek> roast: 7ec93a8 | moritz++ | S12-attributes/instance.t:

[11:35] <dalek> roast: RT #107232: shadowing an attribute with a lexical

[11:35] <dalek> roast: review: https://github.com/perl6/roast/commit/7ec93a816c

[11:38] <dalek> roast: 3582496 | moritz++ | S32-list/uniq.t:

[11:38] <dalek> roast: Test that List.uniq has === semantics

[11:38] <dalek> roast: review: https://github.com/perl6/roast/commit/358249616e

[11:48] *** bitonic joined
[11:50] <jnthn> afternoon o/

[11:50] <phenny> jnthn: 08:29Z <FROGGS> tell jnthn thanks! ;o) \o/

[11:51] <not_gerd> jnthn: \o

[11:51] <not_gerd> jnthn: macro serialization error with blocks: https://gist.github.com/4517030

[11:53] <jnthn> not_gerd: Declarations inside quasis are NYI, and it's quite probably the serialization error goes away once it is.

[11:54] <not_gerd> moritz already mentioned that, but if you replace { 42 } with 42, it does at least compile

[11:55] *** kaare_ joined
[12:03] *** Tzimisces left
[12:08] <moritz> r: macro a { quasi { my $x } }; { a }; { a }

[12:08] <p6eval> rakudo c3f565: OUTPUT«Null PMC access in find_method('sink')␤  in block  at /tmp/iaYUBrazBT:1␤␤»

[12:08] <moritz> r: macro a { quasi { my $x } }; { a }; 

[12:08] <p6eval> rakudo c3f565: OUTPUT«Null PMC access in find_method('sink')␤current instr.: 'MAIN' pc 451 (src/gen/perl6.pir:166) (src/main.nqp src/gen/main-version.nqp:41)␤called from Sub '' pc 97 (src/gen/perl6.pir:60) (src/main.nqp src/gen/main-version.nqp:1)␤»

[12:08] <moritz> it's rpetty easy to make a NYI-feature blow up

[12:10] *** SunilJoshi left
[12:20] <jnthn> nqp: say(+'abc')

[12:20] <p6eval> nqp: OUTPUT«0␤»

[12:30] *** SunilJoshi joined
[12:34] <FROGGS> r: say +'abc'

[12:34] <p6eval> rakudo c3f565: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏abc' (indicated by ⏏)␤  in method gist at src/gen/CORE.setting:10404␤  in sub say at src/gen/CORE.setting:7559␤  in block  at /tmp/fcFqUbjg_r:1␤␤»

[12:38] <dalek> nqp-jvm-prep: 45359ee | jnthn++ | t/qast_core.t:

[12:38] <dalek> nqp-jvm-prep: Tests for coercion between int/num/str.

[12:38] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/45359eeb0f

[12:38] <dalek> nqp-jvm-prep: 2214f2e | jnthn++ | / (2 files):

[12:38] <dalek> nqp-jvm-prep: Implement coercion between int/num/str.

[12:38] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/2214f2edfb

[12:51] *** SunilJoshi left
[12:54] *** SunilJoshi joined
[12:56] *** cognominal joined
[12:57] *** MayDaniel joined
[13:00] *** erkan left
[13:09] <dalek> nqp-jvm-prep: 68630b7 | jnthn++ | t/qast_core.t:

[13:09] <dalek> nqp-jvm-prep: Tests for automatic box/unbox.

[13:09] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/68630b7caf

[13:09] <dalek> nqp-jvm-prep: 43ac52b | jnthn++ | lib/QAST/JASTCompiler.nqp:

[13:09] <dalek> nqp-jvm-prep: Implement box/unbox.

[13:09] <dalek> nqp-jvm-prep: 

[13:09] <dalek> nqp-jvm-prep: Includes the HLL override support, plus some default HLL-less handling

[13:09] <dalek> nqp-jvm-prep: that just calls box/unbox ops with boot types.

[13:09] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/43ac52b986

[13:19] *** not_gerd left
[13:37] *** nyuszika7h left
[13:42] *** erkan joined
[13:44] *** Rotwang joined
[13:44] <Rotwang> hi, is there any editor with perl6 syntax highlighting?

[13:45] <Rotwang> except padre

[13:48] *** nyuszika7h joined
[14:08] <timotimo> vim has perl6 highlighting

[14:08] <timotimo> not terribly many bugs, too ;)

[14:08] <timotimo> sometimes "advanced" quoting and complicated regexes in grammars can make it misbehave, though

[14:09] <Rotwang> timotimo: except padre and vim [;

[14:11] <Rotwang> I'm using medit atm, but I use it with perl5 syntax highlighting

[14:14] *** wk joined
[14:14] *** wk is now known as Guest11514

[14:21] *** PacoAir left
[14:24] <tadzik> there's also hilighting for emacs :)

[14:24] <tadzik> and hoelzro is writing something related to something called "pygments", so it'll probably work with some python-powered tools

[14:25] <FROGGS> I'd like to see a syntax highligther for scintilla engine... any volunteers? :P

[14:25] <FROGGS> tadzik: that will work for the github pages too then

[14:25] <tadzik> yep

[14:25] <FROGGS> the pygments stuff

[14:26] <Rotwang> nice

[14:27] <FROGGS> a github IDE would be awesome, so that you have their look&feel, and that you can do everything from within one tool

[14:27] <FROGGS> I wouldn't  mind if it were web bases, as long as it is awesome

[14:27] <FROGGS> and the github guys know how to make awesome things

[14:34] <FROGGS> r: say so "a" ~~ /<[a..c]-[\n]>/

[14:34] <p6eval> rakudo c3f565: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block : Unrecognized subtype 'zerowidth' in QAST::Regex cclass␤»

[14:35] <FROGGS> r: say so "a" ~~ /<[\n]>/

[14:35] <p6eval> rakudo c3f565: OUTPUT«False␤»

[14:35] <FROGGS> r: say so "a" ~~ /<-[\n]>/

[14:35] <p6eval> rakudo c3f565: OUTPUT«True␤»

[14:35] <tipdbmp> What's the shortcut syntax for $var =$var.method(); or $var = function($var); Is there any?

[14:35] <FROGGS> $var.=method()

[14:36] <tipdbmp> Works only for methods?

[14:36] <FROGGS> I think so

[14:36] <tipdbmp> Okay.

[14:36] <FROGGS> TITS

[14:36] <FROGGS> (try it to see)

[14:36] <jnthn> o.O

[14:37] <jnthn> I, er, didn't get that acronym like I was meant to :P

[14:37] <FROGGS> r: class A ( method b { 42 } }; my $a = A.new; say $a.=b()

[14:37] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition␤at /tmp/9kcAaN6Ylz:1␤------> [32mclass A [33m⏏[31m( method b { 42 } }; my $a = A.new; say [0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤     …

[14:37] <FROGGS> r: class A { method b { 42 } }; my $a = A.new; say $a.=b()

[14:37] <p6eval> rakudo c3f565: OUTPUT«42␤»

[14:37] <FROGGS> jnthn: google told me that lately ;o)

[14:38] <FROGGS> and I am seeking for the right moment for days :P

[14:39] <FROGGS> tipdbmp: btw, you can have functions that modify the var/param in place

[14:40] <FROGGS> r: sub a ( $p is rw ) { $p = 42 }; my $i = 7; a( $i ); say $i

[14:40] <p6eval> rakudo c3f565: OUTPUT«42␤»

[14:41] <tipdbmp> Okay, thank you.

[14:43] <FROGGS> p6: say (^2**64).pick.fmt('%64b')

[14:43] <p6eval> niecza v24-17-gd343a2a: OUTPUT«1010011110011101111010111011101111000110110100001100111110000110␤»

[14:43] <p6eval> ..rakudo c3f565: OUTPUT«                                 1001000010101111011110000000000␤»

[14:43] <FROGGS> p6: say (^2**64).pick.fmt('%64b')

[14:43] <p6eval> niecza v24-17-gd343a2a: OUTPUT«1011111001101001100011010111101010100000100100101001010111101000␤»

[14:43] <p6eval> ..rakudo c3f565: OUTPUT«                                 1000010101111000100001111111010␤»

[14:45] <masak> oh, right!

[14:45] <masak> I meant to implement sprintf in nqp... :)

[14:45] <masak> ...and look at that, it's the weekend :D

[14:45] <FROGGS> :o)

[14:46] *** Targen joined
[14:46] <FROGGS> ++masak #  for implementing nqp::sprintf :P

[14:47] <FROGGS> masak: nqp would know if it gets Inf (type) or "Inf" (text) right?

[14:47] <masak> I imagine so,.

[14:47] <masak> s/,//

[14:47] <masak> they are very different in Perl 6, and they should be in nqp.

[14:48] <FROGGS> k, wouldn't be cool to treat "inf" text like a number...

[14:48] <FROGGS> Inf

[14:49] <FROGGS> r: my $i = 0; do { $i++ } while $ i < 42

[14:49] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/klfX7954a8:1␤------> [32mmy $i = 0; do { $i++ } while $[33m⏏[31m i < 42[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement…

[14:49] <FROGGS> r: my $i = 0; do { $i++ } while $i < 42

[14:49] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of do...while; in Perl 6 please use repeat...while␤at /tmp/6oX9ofV1kd:1␤------> [32mmy $i = 0; do { $i++ } while $i < 42[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        in…

[14:49] <masak> r: say Inf.fmt("%20s"); say Inf.fmt("%20f")

[14:49] <p6eval> rakudo c3f565: OUTPUT«                 Inf␤Inf␤»

[14:49] <masak> look, Rakudo already treats them differently :P

[14:56] *** Pleiades` left
[14:58] *** Pleiades` joined
[15:01] *** SunilJoshi left
[15:02] *** Pleiades` left
[15:03] *** SunilJoshi joined
[15:08] *** am0c joined
[15:08] *** zby_home joined
[15:08] *** Pleiades` joined
[15:10] <masak> when developing a piece of nqp functionality like this, should I aim at creating a new module?

[15:10] <masak> I don't see many uses of 'use X' in the nqp project itself.

[15:10] <masak> only 'use nqpmo', and it's not clear to me how that one works.

[15:11] <masak> seems the tests don't even 'use Test', but just get the assertion subs from somewhere.

[15:12] <masak> ah, they get them from src/core/testing.pm

[15:12] <masak> my, that's a cute little testing module. fits on one screen. :)

[15:12] <dalek> nqp-jvm-prep: 4f97253 | jnthn++ | t/qast_arguments.t:

[15:12] <dalek> nqp-jvm-prep: Test for flattening positional arg.

[15:12] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/4f97253566

[15:12] <dalek> nqp-jvm-prep: d04abf7 | jnthn++ | src/org/perl6/nqp/runtime/ (2 files):

[15:12] <dalek> nqp-jvm-prep: Implement flattening of positionals.

[15:12] *** dalek left
[15:12] <jnthn> oops...

[15:13] <jnthn> note to self: don't push 8 commits at once

[15:13] *** dalek joined
[15:13] *** ChanServ sets mode: +v dalek

[15:13] <jnthn> Anyway, flattening is now done.

[15:14] <jnthn> masak: What exactly are you planning to implement?

[15:15] <jnthn> Ah, sprintf...hm.

[15:15] <masak> aye.

[15:16] <jnthn> That's kinda interesting 'cus you want to implement something NQP and then arrange for an nqp:: op to map to it

[15:16] <masak> after giving it some thought, I'll just implement it as a sub in a .nqp file, and have the tests in le same file.

[15:17] <jnthn> Which is unusual in so far as nqp:: ops normally map to some QAST tree

[15:17] <masak> others can worry about the nqp:: mapping. :)

[15:17] *** SunilJoshi left
[15:17] <jnthn> I guess so long as it gets an object we can QAST::WVal it...

[15:18] <masak> so long as what gets an object?

[15:19] * masak decides not to worry about the intricacies and just solve the immediate problem of implementation for now

[15:19] *** SunilJoshi joined
[15:19] <jnthn> masak: We need the compiled output to refer to the thing you're implementing.

[15:20] <jnthn> masak: For that to happen it needs to be able to locate it somehow.

[15:21] <FROGGS> well, it returns a Str which is an object, right?

[15:21] <FROGGS> is that what you are talking about?

[15:21] <jnthn> I'm talking about the bit of code masak is going to write and wants wired up to an nqp:: op

[15:21] <jnthn> They don't typically work in that way.

[15:22] <jnthn> As in, "so far never have worked that way"

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[b]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[\h]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[\r]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[\N]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[0x0A]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:25] <FROGGS> r: say so "a" ~~ /<[a..c]-[0x0d]>/

[15:25] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:26] <FROGGS> say 0x.0d.chr

[15:26] <FROGGS> r:say 0x.0d.chr

[15:26] <FROGGS> r: say 0x.0d.chr

[15:26] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/PifTH2Jlu0:1␤------> [32msay 0[33m⏏[31mx.0d.chr[0m␤    expecting any of:␤        whitespace␤»

[15:26] <FROGGS> r: say 0x0d.chr

[15:26] <p6eval> rakudo c3f565: OUTPUT«

[15:26] <FROGGS> r: say 0x0a.chr

[15:26] <p6eval> rakudo c3f565: OUTPUT«␤␤»

[15:27] <FROGGS> r: say so "a" ~~ /<[a..c]-[0x0A]>/ # why does this work, but not \n ?

[15:27] <p6eval> rakudo c3f565: OUTPUT«True␤»

[15:27] <timotimo> how exactly do :exists and so on to the {} method of a hash for example?

[15:27] <timotimo> is it part of the signature somehow?

[15:28] <FROGGS> your question is missing a word... I dont get the sense

[15:28] <FROGGS> do you wanna check if a key is defined?

[15:28] <jnthn> %foo{'bar'}:exists

[15:30] <timotimo> no, i mean can i define an operator that behaves like it?

[15:31] *** zby_home left
[15:31] <masak> timotimo: yes, postcircumfix:<{ }> has a named parameter :$exists

[15:32] <FROGGS> timotimo: since operators are subs that get the operands as params you can almost do anything

[15:33] <masak> timotimo: the parsing of operator adverbs is... interesting. ask jnthn, he ported it from STD to Rakudo recently ;)

[15:33] <timotimo> ok

[15:34] <jnthn> There's a whole test file of adverby stuff somewhere in the S03 tests

[15:34] <jnthn> Showing defining operators which takes adverbs

[15:35] <jnthn> r: sub infix:<join>($a, $b, :$with = '') { "$a$with$b" }; say 'beer' join 'chips'; say 'beer' join 'chips' :with('and')

[15:35] <p6eval> rakudo c3f565: OUTPUT«beerchips␤beerandchips␤»

[15:37] <FROGGS> I dont like that syntax

[15:37] <jnthn> Then don't use it.

[15:37] <jnthn> Putting adverbs on operators is really a last resort anyway

[15:38] <jnthn> .. used to be spec'd with a :by(...). Later on, we ended up with ...

[15:38] <FROGGS> r: sub infix:<join>($a, $b, :$with = '') { "$a$with$b" }; say 'beer' join 'chips'; say 'beer' join:with('and') 'chips'

[15:38] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/dKgAl218th:1␤------> [32min 'chips'; say 'beer' join:with('and') [33m⏏[31m'chips'[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤        …

[15:38] <masak> FROGGS: no, it doesn't work that way.

[15:38] <jnthn> Adverbs are parsed as fake infixes.

[15:39] <FROGGS> k, just wanted to check

[15:42] * masak finds he enjoys programming in nqp

[15:43] <dalek> nqp-jvm-prep: 2b621fe | jnthn++ | src/org/perl6/nqp/runtime/CallSiteDescriptor.java:

[15:43] <dalek> nqp-jvm-prep: Eliminate a warning.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/2b621fe58c

[15:43] <dalek> nqp-jvm-prep: 2a9abb3 | jnthn++ | t/qast_arguments.t:

[15:43] <dalek> nqp-jvm-prep: Add test for argument auto-boxing.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/2a9abb30fd

[15:43] <dalek> nqp-jvm-prep: a4439e4 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[15:43] <dalek> nqp-jvm-prep: Implement argument auto-boxing.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a4439e4c37

[15:44] <jnthn> It's quite nice implementing something that ends up producing JVM bytecode in NQP :)

[15:45] <jnthn> Time to have a sift through nqp-mo.pm and see what it needs that I'm missing...

[15:47] <masak> jnthn: when I see nqp-mo.pm, I immediately think of https://www.google.com/search?q=mo+wall-e :)

[15:47] *** cognominal left
[15:48] <jnthn> :P

[15:49] <nwc10> jnthn++

[15:51] <masak> Q: Best manual for getting started with NQP? A: The t/nqp/ directory.

[15:52] *** cognominal joined
[15:55] <dalek> nqp-jvm-prep: c0afae2 | jnthn++ | docs/ROADMAP:

[15:55] <dalek> nqp-jvm-prep: Some missing things (ones nqp-mo.pm uses).

[15:55] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/c0afae2641

[15:56] <jnthn> To the degree I can compile NQP to QAST in my head, it's not looking too bad...

[15:56] <masak> :)

[15:57] <FROGGS> jnthn: I wouldn't be surprised if you could compile down to ASM ;o)

[15:59] *** SunilJoshi left
[16:00] *** SunilJoshi joined
[16:02] <masak> how does one check whether a variable is not the Null PMC in nqp, without triggering a Null PMC Access?

[16:02] <jnthn> nqp::isnull(...)

[16:03] <masak> gracias.

[16:03] <masak> I'm making my tests fail instead of blowing up ;)

[16:03] <jnthn> pzh

[16:06] *** wtw joined
[16:13] *** Pleiades` left
[16:14] *** SunilJoshi left
[16:14] <masak> nqp: sub foo() { nqp::die("ARGH!") }; foo(); CATCH { }; say("alive")

[16:14] <p6eval> nqp: OUTPUT«ARGH!␤current instr.: 'foo' pc 106 ((file unknown):63) (/tmp/canJsswzlT:1)␤»

[16:14] <nwc10> jnthn: when the ROADMAP gets to the empty file, does that mean that it's time to move onto the next stage?

[16:14] <masak> I don't think I understand how CATCH blocks work in nqp.

[16:15] *** diakopter joined
[16:15] *** wtw left
[16:16] <masak> jnthn: where is the $! from an exception visible in nqp? I have a try block in a subroutine, and $! is unset outside of that subroutine.

[16:17] <masak> hm, it appears to be unset inside too :/

[16:17] <masak> all I want to do is test the error message that was nqp::die'd from my sprintf routine. it is proving non-trivial.

[16:18] *** SunilJoshi joined
[16:18] *** stevan_ joined
[16:20] *** Pleiades` joined
[16:23] <moritz> inside a CATCH block, it's $_

[16:25] <jnthn> nwc10: The ROADMAP tries to collect together all the things that need to be implemented to get NQP fully cross-compiled and bootstrapped on the JVM.

[16:26] <jnthn> nwc10: However, nqp-mo.pm needs a subset of those things.

[16:27] <masak> moritz: would you mind demonstrating through a snippet of nqp code how to inspect the die message after doing an nqp::die?

[16:27] <nwc10> OK - so with the full ROADMAP done (including the as-yet unknown unknowns), it will be possible to take NQP and cross compile it

[16:27] <jnthn> nwc10: Once I feel I'm getting close to having that subset, I'll start looking at what you're probably thinking of as the "next phase" - that is, trying to cross-compile bits of NQP code (first, nqp-mo.pm)

[16:27] <nwc10> what dos the subset that nqp-mo.pm needs yet you?

[16:27] <nwc10> get you

[16:27] <jnthn> It gets me the ability to cross-compile nqp-mo.pm :)

[16:28] <jnthn> Which in turn means it's sensible to work on NQPCORE.setting

[16:28] <nwc10> aha. I can see that it's a generated file (in NQP)

[16:28] <jnthn> Once I can compile some amount of that, it makes sense to start attempting the NQP test sutie.

[16:29] <jnthn> Yes, nqp-mo.pm is src/how/*.pm concatenated in the right order.

[16:29] <nwc10> OK. So with that subset done, it's possible to parallelise work?

[16:29] <nwc10> in that, there's one task of "work on the setting" and a second of "work to getting all of NQP cross compilable?"

[16:29] <jnthn> Well, it's more "work on getting the setting to cross-compile"

[16:29] <jnthn> The work is already pretty parallelizable.

[16:30] <jnthn> It's just finding people to dig into stuff.

[16:30] <nwc10> aha yes. that perennial problem. finding volunteers

[16:30] <jnthn> Many of the ROADMAP tasks that exist now are not heavily dependent on others.

[16:30] <moritz> nqp: sub f() { CATCH { say("Error message: '$_'") }; nqp::die('foo') }; f()

[16:30] <p6eval> nqp: OUTPUT«Error message: 'foo'␤»

[16:30] <moritz> masak: see above

[16:30] <nwc10> specifically, finding volunteers who stay active

[16:31] <masak> moritz: thank you.

[16:31] <masak> I should be able to use that to make a global variable remember the error message, and then test it.

[16:31] <FROGGS> nqp: try { die("pups"); CATCH { say("huh? >" ~ $_ ~ "<"); }; }

[16:31] <p6eval> nqp: OUTPUT«huh? >Could not find sub &die<␤»

[16:31] <FROGGS> meh

[16:31] <FROGGS> too slow

[16:32] <jnthn> nwc10: Well, and finding volunteers who know one of QAST/6model or JVM, or are willing/able to learn both...

[16:33] <nwc10> the JVM *ought* to be easier

[16:33] <nwc10> dear refugees trapped in Java-land, please come back

[16:34] <tadzik> we have short method names

[16:35] *** stevan_ left
[16:39] <masak> it works.

[16:39] <masak> moritz++

[16:42] <masak> I feel I'm off to a great start.

[16:42] <masak> my sprintf implementation already does something the Parrot one never did: complains (at runtime) about too few or too many directives.

[16:43] <masak> r: say sprintf('%s %s', 'A', 'B', 'C')

[16:43] <p6eval> rakudo c3f565: OUTPUT«A B␤»

[16:43] <masak> r: say sprintf('%s %s %s', 'A', 'B')

[16:43] <p6eval> rakudo c3f565: OUTPUT«Null PMC access in get_string()␤  in sub sprintf at src/gen/CORE.setting:2414␤  in block  at /tmp/BtwgpEbJMj:1␤␤»

[16:43] <masak> my implementation catches both of these.

[16:43] *** stevan_ joined
[16:46] <masak> is %% the only sprintf directive that doesn't require an argument?

[16:47] <FROGGS> e: say sprintf('\%s')

[16:47] <FROGGS> r: say sprintf('\%s')

[16:47] <p6eval> rakudo c3f565: OUTPUT«Null PMC access in get_string()␤  in sub sprintf at src/gen/CORE.setting:2414␤  in block  at /tmp/1UKBVvYFNu:1␤␤»

[16:47] <FROGGS> r: say sprintf('\%')

[16:47] <p6eval> rakudo c3f565: OUTPUT«Cannot get character past end of string␤  in sub sprintf at src/gen/CORE.setting:2414␤  in block  at /tmp/O9007khE2I:1␤␤»

[16:47] <FROGGS> masak: looks like

[16:47] <FROGGS> %% is like escaping

[16:48] <masak> I know.

[16:48] <masak> I wasn't asking about %%. I was asking about any others like it.

[16:48] *** thou joined
[16:49] <FROGGS> since sprintf only cares about %'s and there is no other way to escape it, I'd say no, there are no others

[16:50] <masak> you may well be right, but I don't buy your reasoning. there may be other reasons not to require and argument than being able to represent '%'.

[16:50] <masak> an*

[16:51] <masak> I'm also interested in directives which require more than one argument.

[16:51] *** cognominal left
[16:51] *** pmurias joined
[16:52] <pmurias> jnthn: INTVAL is 64bit?

[16:52] <jnthn> pmurias: depends :(

[16:52] <jnthn> (on what platform you compile it on)

[16:52] <FROGGS> masak: I dont know about any directive that requires more than one, or zero except %%

[16:53] <FROGGS> masak: http://linuxcommandss.blogspot.de/2012/04/printf-format-directives.html

[16:53] <masak> r: printf "%vd", "AB\x{100}";

[16:53] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized backslash sequence: '\x'␤at /tmp/_Pp5yvSsBw:1␤------> [32mprintf "%vd", "AB\[33m⏏[31mx{100}";[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        prefix or term␤        p…

[16:53] <pmurias> jnthn: but Parrot_Int8 is 64bit

[16:53] <masak> r: printf "%vd", "AB" ~ chr(100);

[16:53] <p6eval> rakudo c3f565: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏ABd' (indicated by ⏏)␤  in method Int at src/gen/CORE.setting:10400␤  in method Int at src/gen/CORE.setting:3856␤  in any  at src/gen/BOOTSTRAP.pm:91␤  in sub sprintf at src/ge…

[16:53] <FROGGS> not the best resource I posted...

[16:54] <masak> FROGGS: I'm reading http://perldoc.perl.org/functions/sprintf.html -- it's quite good.

[16:54] <doy> the only weird one other than %% is %n, but doesn't look like that's intended to work according to the spec

[16:54] <masak> doy: ok, thanks.

[16:55] <masak> yeah, that's a weird one.

[16:55] *** cognominal joined
[16:55] <FROGGS> %n is such a special case as it seems

[16:55] <masak> man, the sprintf API is messed up.

[16:55] <masak> FROGGS: yes, doy already said.

[16:55] <FROGGS> ya, interesting one

[16:55] <Ayiko> r: printf '%d, %1$d', 5; # works for perl5

[16:56] <p6eval> rakudo c3f565: OUTPUT«'$' is not valid in sprintf format sequence '%1$'␤  in sub sprintf at src/gen/CORE.setting:2414␤  in sub printf at src/gen/CORE.setting:2419␤  in block  at /tmp/wMEjlxmEo3:1␤␤»

[16:56] <masak> Ayiko: right. I'm aware of format parameter indices. I think I intend to make them work, but not soon :)

[16:56] <pmurias> jnthn: I found out what was causing crazy results, I forgot about deserialising the boolification

[16:56] <jnthn> pmurias: Yes. But if INTVAL is 32-bit you can't but one of those in an I register...

[16:56] <FROGGS> masak: that pod gives a good test suite (in case the rakudo one isnt)

[16:57] <jnthn> pmurias: Ah!

[16:57] <jnthn> gotta go, bbl

[16:57] <moritz> what sprintf really misses is named params

[16:57] * pmurias hopes to deserialize P6opaque attributes today ;)

[16:58] <masak> FROGGS: aye.

[16:58] <moritz> sprintf '%:year:04d-%:month:02d-%:day:20d', :year(2013), :month(1), :day(12)

[16:58] <moritz> ok, that looks terrible too

[16:58] <FROGGS> moritz: what about printf("%10d=<number>", number => 7 ) ?

[16:58] <moritz> FROGGS: looks better

[16:58] <FROGGS> like the opposite of the regexes

[16:59] <timotimo> then you have to have escaping for < and >, which seems non-obvious

[16:59] <timotimo> or will only =<number> be meaningful, because you're only passing "number" as named argument?

[16:59] <FROGGS> well, I could imagine that it will print <number> if there is no such key in the arguments

[17:00] <moritz> timotimo: one could make <> only special after = and if it's inside a %..\w sequence

[17:00] <timotimo> mhm

[17:00] <moritz> FROGGS: or fail()

[17:00] <masak> if you ask me, you won't improve sprintf much by gradual updates.

[17:00] <moritz> masak: right

[17:00] *** cognominal left
[17:00] <masak> I'd prefer to see a revolution akin to grammars.

[17:00] <masak> let me format objects, doggonnit!

[17:00] <masak> it's 2013!

[17:00] <moritz> is anybody aware of a program that turns sprintf formats into regexes that parse the potential outputs?

[17:01] <timotimo> you know how python does it, right? %(foobar)10s and such. i like that, because it doesn't require special escaping at all, but the s goes at the end which makes it a little confusing

[17:01] <timotimo> moritz: what, like scanf?

[17:01] <masak> moritz: no, but the idea appeals to me.

[17:02] <moritz> timotimo: oh right :-)

[17:02] <moritz> though it doesn't quite return a regex

[17:03] *** SunilJoshi1 joined
[17:03] *** SunilJoshi left
[17:04] <masak> &

[17:04] <doy> masak: https://metacpan.org/module/String::Formatter::Cookbook may be reasonable prior art

[17:07] *** sundar joined
[17:13] *** SunilJoshi joined
[17:14] *** stevan_ left
[17:15] *** SunilJoshi1 left
[17:16] <dalek> nqp: 90ed4cc | (Paweł Murias)++ | docs/serialization_format.markdown:

[17:16] <dalek> nqp: Fix mistake in docs.

[17:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/90ed4cc6a5

[17:16] <dalek> nqp: e219a33 | (Paweł Murias)++ | src/6model/sixmodelobject.c:

[17:16] <dalek> nqp: Fix typo in comment.

[17:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e219a3371a

[17:16] <dalek> nqp: 397c0f9 | (Paweł Murias)++ | docs/serialization_format.markdown:

[17:16] <dalek> nqp: Document how NULL is serialized.

[17:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/397c0f9c4e

[17:23] *** thou left
[17:26] *** SunilJoshi1 joined
[17:26] *** SunilJoshi left
[17:35] *** erkan left
[17:35] *** pmurias left
[17:36] *** erkan joined
[17:36] *** erkan left
[17:36] *** erkan joined
[17:37] *** Moukeddar joined
[17:37] *** pmurias joined
[17:56] *** benabik left
[18:11] *** mtk left
[18:12] *** MikeFair_ joined
[18:17] *** Moukeddar left
[18:18] *** PacoAir joined
[18:20] *** Pleiades` left
[18:27] *** Pleiades` joined
[18:52] *** am0c left
[18:58] *** benabik joined
[19:12] <dalek> roast: 76c7334 | moritz++ | S06-operator-overloading/sub.t:

[19:12] <dalek> roast: RT #112870, LTM and user-defined operators

[19:12] <dalek> roast: review: https://github.com/perl6/roast/commit/76c733429b

[19:14] <moritz> r: sub f() { }; say f() === Nil

[19:14] <p6eval> rakudo c3f565: OUTPUT«True␤»

[19:15] <GlitchMr> https://github.com/rakudo/rakudo/commit/46913d6d9ffc973287cc4a8b2ea269db8f8dc8ac

[19:15] <GlitchMr> Those special cases

[19:15] <GlitchMr> I don't like them

[19:15] *** am0c joined
[19:16] <GlitchMr> But well, both interpretations make sense.

[19:16] <moritz> except that the old one broke everything that assumed that .Str returns a Str

[19:18] <dalek> roast: cbe1ad7 | moritz++ | S04-statements/try.t:

[19:18] <dalek> roast: explicitly test return value of try { }

[19:18] <dalek> roast: review: https://github.com/perl6/roast/commit/cbe1ad79ec

[19:20] *** cognominal joined
[19:21] *** am0c left
[19:23] *** Pleiades` left
[19:23] <timotimo> when do you use has $x instead of has $.x? is it for class attributesperhaps?

[19:24] <moritz> timotimo: no, it's just a question of style

[19:24] <timotimo> ah so its the same thiing. good to know.

[19:25] <moritz> well, it makes $x available as a lexical alias to $!x

[19:25] <timotimo> you will get an accessor along with it? will $!x still work?

[19:25] <timotimo> ah. right.

[19:28] *** Pleiades` joined
[19:36] *** benabik left
[19:36] *** benabik joined
[19:43] *** Chillance left
[19:43] <pmurias> sanity check: a 64bit little endian signed 1 is serialize the same as a 64bit unsigned 1

[19:43] <pmurias> ?

[19:52] <geekosaur> should be

[19:59] *** SamuraiJack left
[20:08] *** benabik left
[20:08] *** marolafm joined
[20:09] *** benabik joined
[20:11] *** marolafm left
[20:11] <timotimo> where does HLL::Compiler come from? is it a nqp thing or a parrot thing?

[20:13] *** SunilJoshi1 left
[20:17] *** Targen left
[20:20] <timotimo> oh, found it. should have known it was so easy to find.

[20:25] *** Targen joined
[20:27] *** bruges_ joined
[20:29] *** bruges left
[20:32] *** slayer101_ joined
[20:34] *** Pleiades` left
[20:40] *** Pleiades` joined
[20:43] *** MayDaniel left
[21:01] <dalek> roast: 510ae2a | moritz++ | S03-operators/short-circuit.t:

[21:01] <dalek> roast: RT #116230: //= with role type objects

[21:01] <dalek> roast: review: https://github.com/perl6/roast/commit/510ae2a0e9

[21:03] *** Rotwang left
[21:05] <moritz> r: say $_!X::a

[21:05] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot call private method 'a' on package X because it does not trust GLOBAL␤at /tmp/DjeUKtcZO2:1␤------> [32msay $_!X::a[33m⏏[31m<EOL>[0m␤    expecting any of:␤        method arguments␤»

[21:05] <moritz> r: try $_!X::a; say $!.perl

[21:05] <p6eval> rakudo c3f565: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot call private method 'a' on package X because it does not trust GLOBAL␤at /tmp/zR5YPJzbSx:1␤------> [32mtry $_!X::a[33m⏏[31m; say $!.perl[0m␤    expecting any of:␤        method arguments␤»

[21:06] <moritz> r: try eval ' $_!X::a'; say $!.perl

[21:06] <p6eval> rakudo c3f565: OUTPUT«X::Method::Private::Permission.new(method => "a", source-package => "X", calling-package => "GLOBAL", filename => "eval_0", line => 1, column => Any, modules => Array.new(), is-compile-time => 1, pre => " \$_!X::a", post => "<EOL>", highexpect => Array.new("method …

[21:07] *** PacoAir left
[21:08] *** PacoAir joined
[21:13] <dalek> roast: b111dae | moritz++ | S14-roles/parameterized-type.t:

[21:13] <dalek> roast: RT #114954: can export and import parameterized roles

[21:13] <dalek> roast: review: https://github.com/perl6/roast/commit/b111dae54a

[21:17] <dalek> nqp: 10dade9 | (Timo Paulssen)++ | src/HLL/Compiler.pm:

[21:17] <dalek> nqp: the check for ancient Test::Harness is no longer needed, methinks.

[21:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/10dade9fb0

[21:17] <timotimo> i hope this decreases the rakudo start time by a few nanoseconds! :)

[21:18] *** Rotwang joined
[21:20] <moritz> testneeded down to 68 tickets

[21:20] <diakopter> \o/

[21:22] <masak> moritz++

[21:23] *** slayer101_ left
[21:25] <moritz> though what I *should* have been doing was solving the remaining two p6cc tasks

[21:26] <masak> seldom have I been so tempted to remove a karma point that I just gave out. ;)

[21:27] <colomon> moritz++

[21:29] <masak> though if I don't get any more solutions sent to me than this, judging will be especially easy this year :P

[21:30] <moritz> masak: the winning set has one element?

[21:30] <masak> I'm not at liberty to say... :)

[21:30] <masak> as me again in a week.

[21:30] <masak> ask*

[21:31] <masak> but in any case -- contestants! send in your solutions to p6cc! send in early, send in often!

[21:34] <moritz> first come up with solutions, then send them in :-)

[21:37] <masak> well, I hesitate to mention this, but it's *tactically* correct to send in trivial programs (that only pass the base tests by brute force) on the first day of the contest.

[21:37] <masak> no-one's ever attempted this.

[21:37] <dalek> roast: b34a3de | moritz++ | S32-exceptions/misc.t:

[21:37] <dalek> roast: RT #112470, my ${a}

[21:37] <dalek> roast: review: https://github.com/perl6/roast/commit/b34a3de058

[21:37] <moritz> or maybe s/brute force/hard coding/

[21:38] <moritz> masak: I guess we all like the context too much to try to game it

[21:39] <masak> aye, "hard coding" was what I meant.

[21:40] <masak> people do seem to like the contest. I'm surprised every year at the effort that contestants put into it.

[21:40] <masak> everyone++

[21:43] * jnthn back

[21:47] *** kaare_ left
[21:50] *** slayer101_ joined
[21:54] *** Pleiades` left
[21:58] *** Pleiades` joined
[22:07] *** Moukeddar joined
[22:09] *** bapa_ joined
[22:10] *** bapa left
[22:13] *** xinming joined
[22:16] *** xinming_ left
[22:16] <jnthn> moritz++ # cutting down testneeded a bit

[22:16] <colomon> Is there a missing comma at line 31 of progname.t?

[22:17] <pmurias> masak: what would the gain of sending hard coded solutions be?

[22:17] <dalek> nqp-jvm-prep: c819b74 | diakopter++ | src/org/perl6/nqp/runtime/CallSiteDescriptor.java:

[22:17] <dalek> nqp-jvm-prep: mape typo map

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/c819b74d4a

[22:18] <jnthn> I accidentally mape a typo

[22:18] <jnthn> .oO( "How is the upside d written??!!" )

[22:19] <pmurias> masak: ah, anything that passes base tests counts as the solution?

[22:19] <masak> pmurias: right.

[22:23] *** grondilu joined
[22:30] *** snearch joined
[22:38] <pmurias> jnthn: how are native attributes stored in P6opaque? as PMCs?

[22:38] <jnthn> pmurias: Directly in the object body

[22:39] <jnthn> As natives

[22:41] <pmurias> they have an entry in flattened_stables which (de)serializes to the appropriate offset in the object?

[22:42] <jnthn> Yeah. Note the flattened STables is per type, not per instance

[22:42] <jnthn> That just says where to delegate to process that slot.

[22:43] <jnthn> This all centers around the storage_spec

[22:45] <dalek> nqp-jvm-prep: 3fee403 | jnthn++ | / (2 files):

[22:45] <dalek> nqp-jvm-prep: nqp::defined(...) and test.

[22:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/3fee403f07

[22:45] <dalek> nqp-jvm-prep: f31ea24 | jnthn++ | / (3 files):

[22:45] <dalek> nqp-jvm-prep: Implement and test nqp::eqaddr.

[22:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/f31ea24c88

[22:47] <pmurias> jnthn: I suppose just undoing all that and just storing everything as object properties would be the most efficient way in javascript

[22:47] <jnthn> pmurias: Probably, yes

[22:49] <jnthn> Particularly when v8 knows how to create the shadow classes behind the scenes...

[22:52] <pmurias> yes, and it is supposed to emit crazy self modifing code to read the properties efficently

[22:54] <pmurias> jnthn: what would be a good way of having nqp-jvm and nqp-js share test files?

[22:54] <pmurias> (I mean the low level qast ones)

[22:55] *** Moukeddar left
[22:57] <jnthn> pmurias: Copy-paste? ;)

[22:57] <jnthn> pmurias: I'm not sure how easy you'll find them to steal, fwiw

[22:58] <jnthn> pmurias: They expect the :main thing in CompUnit to work; if you have that, then just write a different helper.nqp

[23:01] *** snearch left
[23:02] <masak> 'night, #perl6

[23:03] *** slayer101_ left
[23:05] *** Rotwang left
[23:07] <pmurias> jnthn: I think I could steal (most of) them in unchanged form, what I'm unsure about is how to avoid duplicating files

[23:09] <pmurias> just like roast isn't copy-pasted into niecza,rakudo,pugs,etc

[23:11] *** spider-mario left
[23:12] <jnthn> pmurias: How soon do you want a better solution than "duplicate"?

[23:12] *** stevan_ joined
[23:12] <jnthn> pmurias: Right now, working with the tests in the repo I'm building stuff in and keeping all those I've got so far passing is working fairly nicely...

[23:12] <jnthn> pmurias: But I'll probably outgrow that approach in a bit.

[23:14] <jnthn> pmurias: I guess in the long run I'd like us to have an NQP repository structured in a way that means we can keep the various backends together.

[23:29] <pmurias> jnthn: re how soon, I'm ok with minor inconveniences in the near term, but would like to avoid both duplicating tests 3 times or the repos depending on each other in strange ways ;)

[23:30] <pmurias> I'll try to finish the serialisation refactor before making the lowlevel qast tests pass

[23:30] <jnthn> I guess I'll need to be tackling the serialization stuff on the JVM impl soon :)

[23:37] <pmurias> would it make sense to use something like protobuffers for the object serialization?

[23:37] <pmurias> http://en.wikipedia.org/wiki/Protobuffers

[23:40] <jnthn> I'm not sure it'd win us much over what we curerntly have.

[23:40] <pmurias> propably not worth the extra complexity of using an additional tool but that something that was in my mind while trying to read all the bytes correctly ;)

[23:41] <jnthn> It seems more aimed at RPC-like things.

[23:44] <pmurias> different reprs read things differently so we couldn't use that even if we wanted to ;)

[23:46] <jnthn> yeah, I fear we may end up working around its message format as much as making good use of it.

[23:47] * pmurias needs to sleep as he's getting silly ideas 

[23:49] <jnthn> 'night :)

[23:50] <dalek> rakudo-js: 2aec829 | (Paweł Murias)++ | / (2 files):

[23:50] <dalek> rakudo-js: avoid overiding an existing attribute of Object, deserialize WHAT and HOW

[23:50] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/2aec829fc8

[23:50] <dalek> rakudo-js: 6c3f91c | (Paweł Murias)++ | runtime.js:

[23:50] <dalek> rakudo-js: Deserialising a bunch of repr data for P6opaque.

[23:50] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/6c3f91cd0a

[23:54] <dalek> nqp-jvm-prep: 46cf0d7 | diakopter++ | / (2 files):

[23:54] <dalek> nqp-jvm-prep: typo and ignore test output

[23:54] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/46cf0d794c

[23:54] <dalek> nqp-jvm-prep: b0afafc | diakopter++ | / (3 files):

[23:54] <dalek> nqp-jvm-prep: map splice operation

[23:54] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b0afafc12f

[23:55] *** pmurias left
[23:57] *** stevan_ left
