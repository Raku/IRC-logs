[00:02] * timotimo tries a new configureJVM.pl

[00:06] <timotimo> i was wrong. it builds, but the execution raises an "representation cannot unbox to native int" where no int should be required

[00:10] <timotimo> rakudo-jvm: class Foo { has num $.a }; my Foo $f .= new(:a(0e0));

[00:10] <camelia> rakudo-jvm 1f77c4: OUTPUT«java.lang.RuntimeException: Cannot access a native attribute as a reference attribute␤  in block  at src/gen/CORE.setting:829␤  in method bless at src/gen/CORE.setting:797␤  in method dispatch:<.=> at src/gen/CORE.setting:1118␤␤»

[00:10] <timotimo> now the question is: is that an improvement? i don't think so.

[00:10] <timotimo> well, maybe tomorrow i'll get some help to fix this up for realsies

[00:13] *** Psyche^_ joined
[00:14] *** pecastro joined
[00:16] *** Psyche^ left
[00:16] <grondilu> .tell [Coke] changed my mind.  If not too late, please use grondilu instead of my real name

[00:16] <yoleaux> grondilu: I'll pass your message to [Coke].

[00:17] *** ajr_ left
[00:18] *** pecastro left
[00:26] <BenGoldberg> n: class Foo { has num $.a }; my Foo $f .= new(:a(0.0));

[00:26] <camelia> niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Malformed has at /tmp/lBWIpZJawr line 1:␤------> class Foo { has⏏ num $.a }; my Foo $f .= new(:a(0.0));␤␤Parse failed␤␤»

[00:26] <Mouq> n: my num $a # this works, right?

[00:26] <camelia> niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Malformed my at /tmp/6csn3unNi8 line 1:␤------> my⏏ num $a # this works, right?␤␤Parse failed␤␤»

[00:27] <BenGoldberg> Peculiar

[00:28] <Mouq> n: my int32 $a # this works, right?

[00:28] <camelia> niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Malformed my at /tmp/UP1Kz5mVGp line 1:␤------> my⏏ int32 $a # this works, right?␤␤Parse failed␤␤»

[00:36] *** jeffreykegler joined
[00:37] *** grondilu left
[00:38] *** jeffreykegler left
[00:49] *** zjmarlow left
[00:52] *** autark left
[01:01] *** xinming_ left
[01:02] *** xinming joined
[01:07] <dalek> specs: c251a84 | larry++ | S02-bits.pod:

[01:07] <dalek> specs: Some cleanups from hexcoder++

[01:07] <dalek> specs: review: https://github.com/perl6/specs/commit/c251a84ac7

[01:13] *** pdurbin joined
[01:16] *** berekuk left
[01:18] *** c1sung left
[01:18] *** c1sung joined
[01:35] *** mtj joined
[01:37] *** silug joined
[01:42] *** woosley joined
[01:43] *** jnap left
[01:45] *** _ilbot left
[01:46] *** _ilbot joined
[02:01] *** cognominal left
[02:01] *** cognominal joined
[02:04] *** LWA left
[02:20] <japhb__> masak, re: http://irclog.perlgeek.de/perl6/2013-10-17#i_7724545, man I like that syntax.  :-)

[02:24] *** benabik joined
[02:28] <japhb__> .tell timotimo re: slow dir (http://irclog.perlgeek.de/perl6/2013-10-17#i_7727089), see the discussion starting at http://irclog.perlgeek.de/perl6/2013-10-16#i_7719713 .  Go far enough down in a slow path/filesystem operation, and you'll probably end up at canonpath, which is very slow.

[02:28] <yoleaux> japhb__: I'll pass your message to timotimo.

[02:29] <japhb__> I think making it fast would be a big win for lots of path/filesystem operations.  Making the underlying substitution operations fast would be a win for all sorts of use cases.

[02:38] *** jnap joined
[02:38] *** xinming left
[02:38] *** jnap left
[02:40] *** xinming joined
[02:46] *** xinming left
[02:46] *** xinming joined
[03:09] *** aindilis joined
[03:43] *** preflex_ joined
[03:43] *** ChanServ sets mode: +v preflex_

[03:43] *** preflex left
[03:44] *** preflex_ is now known as preflex

[04:02] <moritz> \o

[04:10] *** xinming left
[04:12] *** xinming joined
[04:14] *** woosley left
[04:19] *** [Sno] left
[04:41] *** BenGoldberg left
[04:49] *** FROGGS left
[04:54] *** SamuraiJack joined
[05:08] *** woosley joined
[05:26] *** [Sno] joined
[05:28] *** silug left
[05:30] *** pecastro joined
[05:34] *** pecastro left
[05:35] *** btyler left
[05:36] *** FROGGS joined
[05:38] *** FROGGS left
[05:39] *** silug joined
[05:40] <dalek> nqp/unified-build: c6175b8 | moritz++ | tools/build/Makefile-Parrot.in:

[05:40] <dalek> nqp/unified-build: [Parrot] missing cleanup

[05:40] <dalek> nqp/unified-build: review: https://github.com/perl6/nqp/commit/c6175b889f

[05:57] *** denis_boyun joined
[06:01] <dalek> rakudo/nom: 150bdb3 | coke++ | docs/announce/2013.10.md:

[06:01] <dalek> rakudo/nom: grondilu++

[06:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/150bdb3676

[06:04] <[Coke]> grondilu++

[06:04] <yoleaux> 00:16Z <grondilu> [Coke]: changed my mind.  If not too late, please use grondilu instead of my real name

[06:18] *** woosley left
[06:20] *** woosley joined
[06:22] *** bloonix left
[06:23] *** bloonix joined
[06:41] <dalek> rakudo/nom: bba54af | coke++ | docs/ (2 files):

[06:41] <dalek> rakudo/nom: copy big ticket items to changelog.

[06:41] <dalek> rakudo/nom: 

[06:41] <dalek> rakudo/nom: Fix grammer-o; japhb++

[06:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bba54af084

[06:42] *** ssutch left
[06:47] <jnthn> Cool! The first freezing weather of the autumn for me :)

[06:48] <dalek> rakudo/nom: 853e255 | coke++ | tools/build/NQP_REVISION:

[06:48] <dalek> rakudo/nom: [2013.10] bump NQP revision

[06:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/853e2555dc

[06:48] <dalek> rakudo/nom: 39f4919 | coke++ | VERSION:

[06:48] <dalek> rakudo/nom: [2013.10] bump revision

[06:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39f491968d

[06:50] <[Coke]> jnthn: crap, are you awake already?

[06:52] <jnthn> [Coke]: Yeah. Gotta teach today...

[06:52] <jnthn> Otherwise I'd not be ;)

[06:55] <jnthn> teaching &

[06:58] <masak> morning, #p6

[07:02] *** bloonix left
[07:03] *** bloonix joined
[07:03] *** PacoAir left
[07:04] *** __sri left
[07:04] *** FROGGS joined
[07:05] *** bonsaikitten joined
[07:05] *** DrEeevil left
[07:06] *** _sri joined
[07:11] <masak> hah, and jnthn is happy about the cold in the backlog... probably means I should stay inside all morning :P

[07:17] <nwc10> I hope your house isn't in UGT, else you'll be trapped.

[07:20] *** darutoko joined
[07:21] <FROGGS> .tell [Coke] that the release announcements states it is the september release in the first line...

[07:21] <yoleaux> FROGGS: I'll pass your message to [Coke].

[07:21] <[Coke]> ah, crap stress test is failing.

[07:21] <yoleaux> 07:21Z <FROGGS> [Coke]: that the release announcements states it is the september release in the first line...

[07:21] <FROGGS> [Coke]: what exactly?

[07:22] <FROGGS> I would expect main-usage and another one to fail

[07:23] <masak> nwc10: I thought if I leave IRC, it'd be UGT night... :)

[07:27] <FROGGS> [Coke]: is it okay if I agg more to docs/ChangeLog?

[07:27] <FROGGS> add*

[07:28] *** rindolf joined
[07:28] <[Coke]> FROGGS: it's a little last minute, but sure.

[07:30] <dalek> rakudo/nom: d506b8d | (Tobias Leich)++ | docs/ChangeLog:

[07:30] <dalek> rakudo/nom: added some more items

[07:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d506b8d085

[07:30] <FROGGS> [Coke]: done, thank you

[07:32] <[Coke]> FROGGS++

[07:33] <[Coke]> JEZU it takes forever to cut a release.

[07:33] <FROGGS> yeah, it does :(

[07:34] <nwc10> can more of it be scripted/automated/pushed back earlier in the month?

[07:34] <nwc10> or is it now a mature project, like Perl 5? :-)

[07:34] <[Coke]> nwc10: "run the full test suite". "cut a release. build it and run the full test suite"

[07:34] *** dansamo joined
[07:34] <nwc10> aha. those seem sensible steps

[07:35] <masak> [Coke]: fwiw, I usually run the full test suite in parallel with a lot of the other steps.

[07:35] <masak> [Coke]: only going back if the test suite brings up problems.

[07:36] <[Coke]> ... guess what I'm doing. :P

[07:36] <[Coke]> rerunning the test suite. :(

[07:37] *** sqirrel joined
[07:37] <masak> :/

[07:38] <[Coke]> bah. it's 3:40 AM here. I may have to pass the torch

[07:38] <[Coke]> I did not plan this well.

[07:39] <moritz> [Coke]: do you want to do it tomorrow, or should I take over?

[07:39] <moritz> I have O(3h) of free time on my hand

[07:40] <[Coke]> eh. "nearly" done. I'll soldier on.

[07:40] <moritz> [Coke]++

[07:41] *** denis_boyun left
[07:45] <masak> [Coke]: in the interests of release manager management, what went wrong in planning, and what can we do about it next time?

[07:45] <masak> remind a few days earlier?

[07:46] * masak , release meta-manager

[07:47] <[Coke]> just need to remember that this isn't a quick thing. doesn't take a lot of eyeball time, but a LOT of clock time.

[07:47] <masak> so it does.

[07:47] <masak> I usually think of it as a ~4h thing.

[07:47] <bonsaikitten> at this point someone suggests a CI infrastructure ;)

[07:51] <dalek> rakudo/nom: 455467b | coke++ | docs/announce/2013.10.md:

[07:51] <dalek> rakudo/nom: Fix month. FROGGS++

[07:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/455467b8e3

[07:57] <masak> bonsaikitten: well, it *would* be an interesting thought experiment/hackathon to figure out how much of it could be reduced to just the push of a button.

[07:57] <masak> I for one consider the announcement writing to be a bit too error-prone and not automated enough.

[07:58] <masak> today's mini-challenge: make a script that produces a Rakudo announcement for the current month!

[07:58] <masak> preferably it should just run without interactivity and place a file in the right subdirectory in the rakudo directory.

[07:59] <masak> it may need to insert "[TODO]" markers for things like the current release name.

[07:59] <moritz> r: say nqp::readall(nqp::open('/home/p6eval/nom/docs/announce/2013.09', 'r'))

[07:59] <camelia> rakudo 39f491: OUTPUT«===SORRY!===␤Error while compiling block  (source text: "say nqp::readall(nqp::open('/home/p6eval/nom/docs/announce/2013.09', 'r'))"): Error while compiling op call: Error while compiling block : Error while compiling op call (source text: "say nqp::readall(n…»

[07:59] <moritz> r: say(nqp::readall(nqp::open('/home/p6eval/nom/docs/announce/2013.09', 'r')))

[07:59] <camelia> rakudo 39f491: OUTPUT«===SORRY!===␤Error while compiling block  (source text: "say(nqp::readall(nqp::open('/home/p6eval/nom/docs/announce/2013.09', 'r')))"): Error while compiling op call: Error while compiling block : Error while compiling op call (source text: "say(nqp::readall(…»

[08:00] <bonsaikitten> masak: I've been automating quite a bit, maybe I can take care of this "problem" too

[08:00] <bonsaikitten> cronjobs are infinite power ;)

[08:01] <masak> ++bonsaikitten

[08:02] <masak> also, why don't we have a Perl 6 script in the Rakudo repo that computes future Rakudo release dates?

[08:02] <masak> like "give me all the release dates in the interval 2013-01-01..2013-12-31"

[08:02] <masak> or "when's the October release?"

[08:02] <bonsaikitten> that sounds like a nice idea

[08:02] <masak> and then provide it as a bot on the channel, too ;)

[08:03] <moritz> masak: iirc we have such a script

[08:03] <moritz> tools/release-dates.pl

[08:03] <masak> oh! oh! also, "who's the October release manager?"

[08:03] <masak> moritz: oh, cool.

[08:04] <masak> masak-- # didn't know :)

[08:05] <moritz> r: say Date.today - Date.new('2013-02-03')

[08:05] <camelia> rakudo 39f491: OUTPUT«257␤»

[08:09] <JimmyZ> r: say Date.today - '2013-02-03'.toDate

[08:09] <camelia> rakudo 455467: OUTPUT«No such method 'toDate' for invocant of type 'Str'␤  in block  at /tmp/XeVDbKh32t:1␤␤»

[08:11] <JimmyZ> r: sub ToDate($date) { Date.new($date); }; say Date.today - '2013-02-03'.&toDate

[08:11] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/tLNmAC_PF5␤Undeclared name:␤    &toDate used at line 1␤␤»

[08:11] <moritz> it helps to use the same case for both declaration and use

[08:11] <JimmyZ> r: sub ToDate($date) { Date.new($date); }; say Date.today - '2013-02-03'.&ToDate

[08:11] <camelia> rakudo 455467: OUTPUT«257␤»

[08:12] <JimmyZ> I thought there was "Do you mean ..."

[08:12] <moritz> seems not to be used in all contexts

[08:13] *** donaldh joined
[08:17] *** woolfy left
[08:19] *** donaldh left
[08:21] <masak> moritz++ # Date

[08:22] <masak> dates are much more tractable than datetimes.

[08:29] <lizmat> [Coke]: fwiw, spectest is green on parakudo for me

[08:29] <[Coke]> lizmat++

[08:29] <lizmat> decommute continues with final leg: Ghent to Echt  :-)

[08:29] <[Coke]> it rang green with jobs=2 instead of 3 for me. at S14 on the stresstest via the tarball.

[08:30] <lizmat> Files=764, Tests=29694, 453 wallclock secs ( 9.72 usr  2.95 sys + 3049.92 cusr 336.60 csys = 3399.19 CPU)

[08:30] *** denysonique left
[08:31] *** gfldex left
[08:32] *** pernatiy joined
[08:33] <masak> the release guide still doesn't say "run the spectests on Rakudo Parrot *and* Rakudo JVM", does it?

[08:34] *** gfldex joined
[08:39] *** lizmat left
[08:39] <[Coke]> no, thank the great maker.

[08:41] * masak .oO( the great Makefile )

[08:42] *** mush joined
[08:42] <mush> hello

[08:43] <mush> where can i find some info on the current development status / change log for perl 6 ?

[08:44] <hoelzro> mush: hi!

[08:44] <hoelzro> rakudo.org has a bit of that information

[08:44] <hoelzro> although rakudo is just one of the implementations

[08:44] <FROGGS> if `git checkout HEAD^` let me step back one step into the past, how do I get into the future?

[08:44] <hoelzro> http://perl6.org/compilers/features is also handy

[08:44] <hoelzro> FROGGS: you don't =(

[08:44] <mush> nice, ty

[08:44] <FROGGS> meh

[08:44] <masak> mush: http://planetsix.perl.org/ is nice.

[08:44] <hoelzro> you can checkout master or branch

[08:45] <hoelzro> or you can use the reflog

[08:45] <hoelzro> FROGGS: you're not by chance an Hg user normally, are you?

[08:45] <FROGGS> no

[08:45] <mush> i've actually got an university coursework to do which involves using perl

[08:46] * masak hopes frettled is OK, http://planetsix.perl.org/ says his pipe "has been deleted" :/

[08:46] <mush> does netbeans know how to work with perl ?

[08:46] <masak> no idea.

[08:46] <masak> I know there is a Perl dev plugin for Eclipse.

[08:46] <[Coke]> done.

[08:46] <FROGGS> [Coke]++

[08:46] <masak> \o/

[08:46] <[Coke]> email sent, files uploaded, wikipedia edited.

[08:46] <masak> [Coke]++

[08:47] <[Coke]> welcome to "Roederbergweg" (closest to frankfurt that was unused)

[08:47] <[Coke]> I will celebrate i about 3 hours with a gallon of coffee.

[08:47] <[Coke]> Adios.

[08:48] <masak> o/

[08:48] <mathw> o/

[08:48] <[Coke]> \o

[08:48] <FROGGS> [Coke]: gulp well o/

[08:48] <mathw> o/ \o

[08:48] <mathw> \o/

[08:48] <masak> good UGT night, [Coke], hero of taken-by-relative-surprise release managers!

[08:48] <mathw> I like how "wikipedia edited" is on the list now :)

[08:49] <mathw> the central repository of all human knowledge, or something

[08:49] <masak> mathw: the cool thing is, "an encyclopedia" was among the suggested projects of TimBL's original vision for the Web.

[08:49] <mathw> It's kind of an obvious application of the web

[08:49] <mathw> or rather, a hypertext system

[08:50] <masak> troo.

[08:50] <mush> the mighty hypertext!

[08:50] <mathw> he might not have anticipated it being a wiki though...

[08:50] <masak> I've always considered TimBL's Web to be slightly cooler, though. I want to be able to PUT to web pages, darnit!

[08:50] <mathw> :)

[08:50] <mush> as in.. be able to edit them lively ?

[08:51] <mathw> yeah PUT kind of fell by the wayside until REST came along

[08:51] <masak> that would basically have made the wiki, a hack from the very start, unnecessary.

[08:51] <mathw> well you could write a wiki that accepts PUTs

[08:51] <mathw> you'd need to write a web browser that could send them, but...

[08:51] <masak> right.

[08:51] <masak> browsers are the bottleneck.

[08:52] <masak> Amaya does it.

[08:52] <masak> (and it's awesome)

[08:52] <mush> noes it's the format

[08:53] <mathw> Amaya is the only one that's ever likely to

[08:53] <mathw> it's the model web browser everyone else ignores

[08:53] <masak> Amaya is the Plan 9 of browsers.

[08:53] <mathw> ah Plan 9

[08:54] <mathw> my boss at my first job after university is a Plan 9 fan

[08:54] <mathw> he used to run it in a VM on his work machine

[08:54] <masak> "Look, *this* is how you should impl... guys? Guys?"

[08:54] <mathw> sometimes he'd write code in its environment, just because it was more fun

[08:54] <mathw> I, with more modest tastes, stuck to vim

[08:55] *** pernatiy left
[08:55] * mathw attempts to convince his brain that he's on $dayjob, so he should really be thinking in C# not Haskell

[08:55] <frettled> masak: Hum.  Maybe Yahoo! Pipes is defunct.

[08:56] <frettled> I think my feed was based on that.

[08:56] <masak> frettled: I was mostly concerned about your well-being. I had no idea what a destroyed pipe might imply. :P

[08:57] * masak .oO( Magritte: Ceci n'est pas une destroyed pipe )

[08:57] *** pecastro joined
[08:58] * masak .oO( well, it *is* a pipe, Magritte dear, if you're inside of the Art monad )

[08:58] <moritz> wouldn't that bee destroyée? :-)

[08:58] <moritz> *be

[08:59] * masak .oO( wouldn't that spelling bee destroyée? )

[08:59] *** dayangkun_ left
[08:59] <masak> moritz: yes, and most likely postfixed to "pipe".

[08:59] <moritz> http://www.perlmonks.org/?node_id=1058723 # another partially p6 reply to a p5 question

[08:59] * moritz simply can't resist

[08:59] *** dayangkun joined
[08:59] <masak> oh, "détruite", in fact.

[09:00] *** mush left
[09:00] *** donaldh joined
[09:00] <moritz> but that's actual French, not English made to look like French :-)

[09:00] <moritz> so, fail :-)

[09:01] <frettled> masak: well, thanks for your concern :)  I'm quite fine, thank you!  … and judging from your activity, I'd guess that you're doing okay, too.  Are you? :)

[09:01] <masak> ah non, le fail! quel dishoneur. :P

[09:01] <frettled> nous avons le fail grande

[09:01] <frettled> (important to use the wrong gender suffix for that)

[09:01] <masak> frettled: thank you, yes, very okay. I keep wishing I had more Perl 6 and #perl6 time... but apart from that, everything is a-OK.

[09:02] <masak> frettled: "des failes grandes" -- remember to pluralize :P

[09:02] <JimmyZ> You Will

[09:02] <frettled> I'm almost constantly trashing around in context switches, so I don't have the energy for much extra-curricular work.

[09:03] <frettled> But I _have_ noticed that Perl 6 seems to be stabilizing nicely, and might possibly be production ready for several use cases we have at work.

[09:03] <masak> meanwhile, all the actually French people on the channel are going "oh non, my yeux, they sont bleeding!"

[09:03] <frettled> :D

[09:03] <masak> frettled: yeah, the torch is being carried on.

[09:03] <moritz> masak++ # Frenglish punning

[09:05] * hoelzro loves interlingual puns

[09:05] <JimmyZ> 我的妈呀

[09:05] <masak> more like smashing the languages l'un into l'autre, in this case. :)

[09:06] <masak> JimmyZ: :)

[09:06] <masak> JimmyZ: 你的妈呀 ;)

[09:06] <moritz> .u 呀

[09:06] <yoleaux> No characters found

[09:06] <moritz> how fitting :-)

[09:06] <masak> haha

[09:06] <masak> yoleaux is without character.

[09:06] <bonsaikitten> dat is niet leuk!

[09:07] <moritz> it should answer with "你的妈呀" to unknown characters though

[09:08] <JimmyZ> it's 'My god' in english

[09:08] <masak> 对

[09:14] <masak> moritz: re http://www.perlmonks.org/?node_id=1058723 -- as cool as junctions are sometimes, I would *greatly* lean towards the hash variant in most scenarios.

[09:14] <masak> moritz: for maintainability.

[09:14] <moritz> masak: me too

[09:14] <moritz> which is why I put it first :-)

[09:15] <masak> nodnod

[09:15] <moritz> (actually a more 6ish approach would use given/when with junctions in the when clauses, and I'd *still* prefer the hashes)

[09:15] <moritz> [Coke]++ # Rakudo release

[09:16] <masak> it seems without realizing it, in the past few years when I program I always take the stance "how will I make this code easy to read/understand/change in the future?"

[09:16] <mathw> moritz: Junctions are indeed awesome

[09:16] <masak> and chained `if` statements lose to hashes most of the time.

[09:16] <mathw> for that problem, hashes are probably superior, but sometimes it's so nice to just say "if $thing == 1 | 2"

[09:18] <mathw> it's the little things, not just the big things

[09:20] <moritz> mathw: in fact I only use Junctions for the little things

[09:20] <moritz> whenever somebody uses them for the big things, I find it's an abuse of junctions, and quickly runs into their limitations

[09:21] <moritz> good that we now have sets, bags, keybags and all those other fancy thingies

[09:22] <Ulti> *HashBags ;P

[09:22] <moritz> HashTags

[09:22] <Ulti> I know it changed in my bones because I had to regex my code :]

[09:23] <masak> someone should blog about "all the nice things we have in Perl 6 that you thought you should use junctions for" :)

[09:25] <Ulti> wait are nested junctions meaningless

[09:27] <masak> Ulti: no, but they flatten into two levels.

[09:27] *** berekuk joined
[09:27] <masak> disjunctions (any/one) on the outside and conjunctions (all/none) on the inside.

[09:29] <masak> this is in line with (most) natural language: "did you wash your clothes and have a nap OR go to the movies and inadvertently cause the apocalypse"

[09:29] <masak> things naturally group into "(clothes && nap) || (movies && apocalypse)"

[09:30] <Ulti> might play with that later, certainly the most useful meaning not sure its obvious that's what would happen though

[09:31] <Ulti> I'd have expected it to just flatten completely into all or

[09:33] <masak> Ulti: as a rule, I play it safe and use junctions with as small a footprint as possible.

[09:33] <masak> if *I'm* uncertain of how a junction interacts with a negation... then I rephrase the expression.

[09:34] <Ulti> I've only used them in 'where' in multi methods so far

[09:34] <Ulti> which I think is really really powerful

[09:34] <masak> rn: my $x = 5; if $x != any(1, 2, 3) { say "it's not one of those, that's for sure" }

[09:34] <camelia> rakudo 455467, niecza v24-98-g473bd20: OUTPUT«it's not one of those, that's for sure␤»

[09:34] <masak> rn: my $x = 5; if not $x == any(1, 2, 3) { say "it's not one of those, that's for sure" }

[09:34] <camelia> rakudo 455467, niecza v24-98-g473bd20: OUTPUT«it's not one of those, that's for sure␤»

[09:34] <masak> rn: my $x = 5; if $x == none(1, 2, 3) { say "it's not one of those, that's for sure" }

[09:34] <camelia> rakudo 455467, niecza v24-98-g473bd20: OUTPUT«it's not one of those, that's for sure␤»

[09:34] <Timbus> you cant have junctions as hash keys?

[09:35] <Timbus> that would be neat :<

[09:35] <masak> rn: my %h; %h{3 | 4 | 5} = "OH HAI"; say %h.perl

[09:35] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/L0xcYQISXu line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4584 (module-CORE @ 576) ␤  at /home/p6ev…»

[09:35] <camelia> ..rakudo 455467: OUTPUT«No such method 'STORE' for invocant of type 'Any'␤  in sub AUTOTHREAD_METHOD at src/gen/CORE.setting:3189␤  in any  at src/gen/Metamodel.nqp:2675␤  in block  at /tmp/uzaV4j0IrO:1␤␤»

[09:35] <Ulti> Timbus: what happens when two junctions contain the same values

[09:35] <masak> Timbus: no, because hash keys are something like Str(Any).

[09:35] <masak> rn: say Junction ~~ Any

[09:36] <camelia> rakudo 455467, niecza v24-98-g473bd20: OUTPUT«False␤»

[09:36] <masak> what Ulti said.

[09:36] <masak> That Way Lies Madness.

[09:36] <Timbus> awesomeness, madness, eh

[09:36] <masak> Timbus: I s'pose you could init your own hash to be Str(Mu), and then it'd take Junction, too.

[09:37] <masak> but if I'm on your Perl 6 team and you do that, I'll report you to the (inherently junction-wary) middle manager :P

[09:38] <Timbus> would i get praised and punished for doing it

[09:38] *** daxim joined
[09:38] <masak> one(praised, punished) # :P

[09:39] <Timbus> also if it matches two junctions it should return both values. junctioned. "easy"

[09:39] *** fhelmberger joined
[09:40] * masak .oO( You have a problem, and you go "I know, I'll store junctions in a hash!" Now you h... Null PMC Access )

[09:40] <Ulti> :D

[09:41] <mathw> now you have one problem, or one problem, or one problem

[09:41] <Timbus> beat me to it

[09:41] <mathw> but you don't know which one

[09:42] <Timbus> i got 99 problems but i dont know which one

[09:42] <mathw> I've got a lot of problems, but I know one of them's my cat so that's a start

[09:43] * masak .oO( Schrödinger's cat had any(0, 1) problems )

[09:43] <mathw> no, he definitely had a problem

[09:43] <mathw> because some crazy guy in a thought experiment locked him in a box

[09:44] <mathw> or she

[09:44] <mathw> might have been a girl cat

[09:44] <mathw> one of my other problems is that nobody knows how to write good software yet

[09:45] <masak> mathw: at least it wasn't Einstein's cat. Einstein's thought experiment was to blow up the cat with gunpowder, rather than poison it.

[09:45] <mathw> another one of my problems is that some people know how to write not-quite-so-bad software but loads of other people who're writing software don't seem to be interested in learning

[09:45] <mathw> maybe einstein didn't like cats?

[09:46] <masak> I think he just confused Schrödinger's original description with a thought experiment of his own.

[09:47] <masak> both the cat and the powder keg were about translating uncollapsed quantum phenomena to the macroscopic world.

[09:47] <masak> and both (of course) were all about demonstrating the paradox that this is not how it actually happens in the macroscopic world.

[09:47] <mathw> indeed

[09:47] <masak> so there is some unknown factor that collapses the wavefunction on the way.

[09:47] <mathw> physics is weird :)

[09:48] <masak> seems to me, by what little I know about QM, that wavefunctions are really very unstable, and it's not so much about a conscious observer collapsing it, but almost *anything*.

[09:50] <mathw> I don't really know about that at all

[09:50] <mathw> I leave that to the physicists. Let them make my computer work, I'll write incomprehensible software for it

[09:51] <masak> no no, the physicists are clearly having too much fun with their models and their understanding of the world. I want in.

[09:56] <mathw> fine, go retrain as a physicist :)

[09:56] <mathw> get a job at CERN

[09:56] <mathw> make sure you figure out that everyone's been wrong about exceeding the speed of light though

[09:56] <mathw> either that or a clean, cheap energy source

[09:59] <moritz> or come up with a *simple* model of what's actually going on :-)

[09:59] <mathw> that'd be grand, but I don't think that's possible

[10:00] <mathw> it might be elegant, but it's not going to be simple

[10:00] <moritz> ok, come up with model that's as simple as possible (no artifical complexity added)

[10:02] <masak> currently struggling with this tension for writing a course: wanting to teach the theory, independent of any framework, but also the practice, in which case a choice of tools has to be made.

[10:02] <masak> the topic is "web applications", and the niche in question is in great flux. there are *lots* of solutions, all slightly different.

[10:13] *** berekuk left
[10:13] <moritz> re collapsing wave functions: the interesting part is that QM people says that wave functions collapse when a system is measured, and the measurement, by very definition, is coupling with a classical (non-QM) system

[10:13] <moritz> so QM needs non-QM systems to work :-)

[10:15] *** woosley left
[10:17] <moritz> which of course bothers the theory folks to no end

[10:24] *** denis_boyun joined
[10:25] *** berekuk joined
[10:27] <masak> it's a bit like how category theory claims to be more fundamental than set theory, and yet it uses sets all over the place :)

[10:27] <mathw> well as I understand it there arne't any non-QM systems - classical mechanics is an emergent property of a lot of quantum stuff going on underneath. Somehow.

[10:28] <mathw> category theory is more general than set theory

[10:28] <mathw> so it's got all of set theory in it

[10:28] * moritz automatically red-flags any sentence that contains "emergent"

[10:28] <mathw> plus some new headaches

[10:28] <mathw> lots of new headaches

[10:28] * mathw doesn't get category theory

[10:28] <mathw> I really started to tune out of it when I had to remember what a surjective functor is

[10:29] <moritz> it's on my list of things I'd really like to understand, but have been too scared/bored to really study it

[10:29] <felher> Is this supposed to work? :

[10:29] <felher> sub say-first(Str @array) { say @array[0]; }; say-first(<a b>);

[10:29] <felher> r: sub say-first(Str @array) { say @array[0]; }; say-first(<a b>);

[10:29] <camelia> rakudo 455467: OUTPUT«Nominal type check failed for parameter '@array'; expected Positional[Str] but got Parcel instead␤  in sub say-first at /tmp/8zQ9BMoHFI:1␤  in block  at /tmp/8zQ9BMoHFI:1␤␤»

[10:29] <moritz> also on that list: Haskell, Quantum Field Theory

[10:29] <felher> Or do I have to do something like: 

[10:29] <moritz> felher: no, it's not supposed to work, because <a b> isn't declared as Array[Str]

[10:29] <felher> r: sub say-first(Str @array) { say @array[0]; }; my Str @a = <a b>; say-first(@a);

[10:29] <camelia> rakudo 455467: OUTPUT«a␤»

[10:29] *** denysonique joined
[10:29] <mathw> moritz: Haskell worth learning, definitely. Just to twist your brain into a new shape and show you stuff that's interesting.

[10:30] <moritz> felher: or simply remove the type constraint from @array :-)

[10:30] <moritz> seriously, typed arrays aren't well done enough yet to be worth the trouble

[10:32] *** denis_boyun left
[10:32] <felher> moritz: okay. But they are supposed to be well done enough someday? Beause for me, one of the great things of Perl6 ist gradual typing. I do not use Types everwhere, but in the signatures of public-api functions/methods, I find them to be quite useful.

[10:33] *** denisboyun joined
[10:33] <moritz> felher: so far there's no spec that says passing <a b> to Str @ should ever work

[10:33] <felher> It's embarrassing how often I write 'ist' instead of 'is'. ;)

[10:34] <moritz> felher: so I'm not sure if that's a future extension just waiting to come up, or if it won't work

[10:34] <felher> moritz: okay, thanks :)

[10:51] <felher> r: sub say-first(Str @array) { say @array[0]; }; say-first(Array[Str].new(<a b>));

[10:51] <camelia> rakudo 455467: OUTPUT«a␤»

[10:52] <felher> I'll go with that for now. :) Seems concise enough :)

[10:53] *** risou_awy is now known as risou

[10:58] <FROGGS> moritz: using valgrind might be a better approach than bisecting it: https://gist.github.com/FROGGS/247efea9968aa9d70974#file-main-usage-bash-L689

[11:05] <FROGGS> moritz: updated, now: https://gist.github.com/FROGGS/247efea9968aa9d70974#file-main-usage-bash-L592

[11:05] <FROGGS> seems to a parrot internal bug/problem

[11:10] *** pdurbin left
[11:14] *** xdbr joined
[11:15] <moritz> FROGGS: did you manage to reproduce it with a single process?

[11:22] *** LWA joined
[11:27] *** denisboyun left
[11:30] <timotimo> felher: at least that error message is now non-unhelpful, thanks to me \o/

[11:30] <yoleaux> 02:28Z <japhb__> timotimo: re: slow dir (http://irclog.perlgeek.de/perl6/2013-10-17#i_7727089), see the discussion starting at http://irclog.perlgeek.de/perl6/2013-10-16#i_7719713 .  Go far enough down in a slow path/filesystem operation, and you'll probably end up at canonpath, which is very slow.

[11:31] <felher> timotimo++ then :)

[11:31] <timotimo> :D

[11:32] <timotimo> it used to not output the [Str] part in Positional[Str]

[11:32] <timotimo> so people got "expected Positional, but got Parcel/Array instead"

[11:32] <timotimo> and then they'd come here and write:

[11:32] <timotimo> r: say Array ~~ Positional

[11:32] <camelia> rakudo 455467: OUTPUT«True␤»

[11:32] <timotimo> and they'd be extra-confused

[11:33] <timotimo> r: for ^1000 { my $str = 'a||b'; $str ~~ s { '||' } = '|' }; say now - BEGIN now;

[11:33] <camelia> rakudo 455467: OUTPUT«5.06187182␤»

[11:33] <timotimo> r: for ^1000 { my $str = 'a||b'; $str.=subst('||', '|'); } say now - BEGIN now;

[11:33] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/T4Xo6ABTbj␤Confused␤at /tmp/T4Xo6ABTbj:1␤------> str = 'a||b'; $str.=subst('||', '|'); } ⏏say now - BEGIN now;␤    expecting any of:␤        postfix␤        statement end…»

[11:33] *** LWA left
[11:33] <timotimo> r: for ^1000 { my $str = 'a||b'; $str.=subst('||', '|'); }; say now - BEGIN now;

[11:34] <camelia> rakudo 455467: OUTPUT«4.9991899␤»

[11:34] *** LWA joined
[11:34] <timotimo> wow.

[11:34] <timotimo> r: for ^1000 { my $str = 'a||b'; $str.=subst(rx/'||'/, '|'); }; say now - BEGIN now;

[11:34] <camelia> rakudo 455467: OUTPUT«5.582004␤»

[11:38] *** grondilu joined
[11:39] <timotimo> maybe a pattern that identifies already-canonical paths could be put in the first line to do a quick return in "most" cases?

[11:43] <FROGGS> moritz: not yet

[12:01] *** pernatiy joined
[12:05] *** benabik left
[12:06] *** benabik joined
[12:07] *** benabik left
[12:10] <timotimo> i'm not sure what :parent is supposed to do in canonpath

[12:13] <FROGGS> moritz: the single test passes, even in valgrind

[12:13] <timotimo> my pattern for finding already-canonical paths didn't help performance at all :(

[12:14] <timotimo> now i'll see if it perhaps calls canonpath on the same path multiple times

[12:22] <timotimo> the pattern was apparently never matched? weird.

[12:28] <timotimo> ah, great

[12:28] <timotimo> even with debug output it's now 2x faster in the dir(...) case

[12:33] <timotimo> 3.2s down to 1.2s for dir('/etc'), which has almost 100 entries

[12:39] *** PacoAir joined
[12:46] *** ajr joined
[12:47] *** ajr is now known as Guest51652

[12:47] *** Guest51652 is now known as ajr_

[12:50] *** timotimo joined
[12:56] *** pernatiy_ joined
[12:56] <masak> rn: say <foo bar>[0] ~~ Str

[12:56] <camelia> rakudo 455467, niecza v24-98-g473bd20: OUTPUT«True␤»

[12:56] <masak> rn: my Str @strings = <foo bar>; say "alive"

[12:56] <camelia> rakudo 455467: OUTPUT«alive␤»

[12:56] <camelia> ..niecza v24-98-g473bd20: OUTPUT«Potential difficulties:␤  @strings is declared but not used at /tmp/vtrdWuV4jL line 1:␤------> my Str ⏏@strings = <foo bar>; say "alive"␤␤alive␤»

[12:56] *** xenoterracide left
[12:57] <masak> rn: sub foo(Str @values) { say @values.perl }; foo(<a b c>)

[12:57] <camelia> niecza v24-98-g473bd20: OUTPUT«("a", "b", "c")␤»

[12:57] <camelia> ..rakudo 455467: OUTPUT«Nominal type check failed for parameter '@values'; expected Positional[Str] but got Parcel instead␤  in sub foo at /tmp/1RCpdnBpv0:1␤  in block  at /tmp/1RCpdnBpv0:1␤␤»

[12:57] <masak> I think a very strong argument could be made for this to work.

[12:58] <masak> r: say Parcel ~~ Positional

[12:58] <camelia> rakudo 455467: OUTPUT«True␤»

[12:58] <masak> why shouldn't qw literals be typed with the type of their components?

[12:59] <timotimo> you mean for <> to create a Str @?

[12:59] <masak> yeah.

[12:59] <timotimo> yeah. that should also be easy to implement.

[12:59] <masak> and possibly an IntStr one, if all the components are Int-y.

[12:59] <masak> etc.

[12:59] *** pernatiy left
[12:59] <timotimo> that is not as easy :)

[12:59] <masak> it all takes place at compile time, so it's not a runtime cost.

[13:00] <masak> well, one step at a time :)

[13:00] <timotimo> bbl

[13:00] <masak> Str @ is fine for a start :)

[13:00] <dalek> Perlito: 52bf49a | (Flavio S. Glock)++ | / (4 files):

[13:00] <dalek> Perlito: Perlito5 - js - fix call with ampersand

[13:00] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/52bf49ace9

[13:01] *** berekuk left
[13:08] <mathw> masak: it seemed to me that it should probably work

[13:09] *** berekuk joined
[13:12] <masak> yeah. for literals, I don't think there should be any hesitation.

[13:12] <masak> literals should always be as narrowly typed as possible, up to and including generic types.

[13:13] *** benabik joined
[13:13] <masak> mathw: re category theory; the amazing thing isn't that it's more general than set theory and (trivially) contains it. the amazing thing is that it manages to do so and also (arguably) pose itself as more fundamental than set theory.

[13:15] <mathw> I tend to look at it as that it's a more general theory, therefore it's more fundamental because it describes mroe stuff

[13:15] <mathw> admittedly I have no idea what that other stuff actually is

[13:16] <mathw> I know you can use it to model types in programming languages, but I never really figured out how. I was a useless PhD student (which is why I haven't got one)

[13:16] <masak> in a sense, it's a "second system" compared to set theory.

[13:16] <mathw> aaaaaaaaaargh run away! Second system syndrome!

[13:16] <masak> set theory goes "it's all about the objects that are inside".

[13:16] <mathw> actually it's the language you write set theory's metaclass in :P

[13:17] *** denis_boyun joined
[13:17] <masak> category theory goes "that's all very well, but we keep talking about transformations between objects all the time. so why not model those, too?"

[13:17] <masak> and then, just like set theory, it does the trick of bootstrapping itself in itself.

[13:17] *** berekuk_ joined
[13:19] *** berekuk left
[13:20] *** prevost joined
[13:21] *** SamuraiJack left
[13:31] *** bluescreen10 joined
[13:32] <mathw> and then my head explodes

[13:35] <masak> mine melts, but YMMV.

[13:40] *** zakharyas joined
[13:40] <masak> fun fact: tab completion creates temporary files, so when you've filled a partition, tab completion fails.

[13:41] <FROGGS> good to know :o)

[13:44] <grondilu> well, when you've filled a partition, lots of things fail

[13:45] * grondilu knows that since he's using an USB key as main partition, and it is often full

[13:47] *** jnap joined
[13:52] *** jnap left
[13:53] *** jnap joined
[13:54] <mathw> tab completion creates temporary files????

[13:55] * mathw filled /var a few times, that was interesting

[13:55] *** rindolf left
[13:56] *** bluescreen10 left
[13:58] *** bluescreen10 joined
[14:02] *** jnap left
[14:03] *** jnap joined
[14:09] *** btyler joined
[14:10] *** jnap left
[14:10] *** jnap joined
[14:14] *** jnap left
[14:20] *** jnap joined
[14:22] *** skids joined
[14:23] *** kaare_ joined
[14:24] *** jnap left
[14:25] *** jnap joined
[14:31] <masak> mathw: actually, topos theory appears to be the language you write set theory's metaclass in.

[14:31] *** FROGGS left
[14:31] *** jnap1 joined
[14:31] <masak> topos theory seems like great fun. it looks like "The Atrocity Archives" for various approaches to logic from the 20th century.

[14:32] <masak> as in, "and in this universe, intuitonistic logic is true..."

[14:32] *** jnap left
[14:35] <mathw> umm

[14:36] <masak> intuitionistic*

[14:37] <TimToady> *expialidocious

[14:39] *** zakharyas left
[14:39] *** jnap1 left
[14:39] <frettled> In this universe, all absolutist statements are false.

[14:39] *** jnap joined
[14:40] * frettled loves the word "absolutist" :)

[14:40] <TimToady> Not on that, but in this universe we're all cretans.

[14:40] <mathw> In this universe, I'm still waiting for the vet to call

[14:41] *** benabik left
[14:41] <frettled> TimToady: not cretaceans?

[14:42] <TimToady> that's where the Elder Gods live

[14:43] <TimToady> I think I'd prefer to live in the world where we're all cetaceans.

[14:43] * masak .oO( "pizza delivery to one Cth... Cthl..." )

[14:43] <masak> TimToady: [cetacean needed]

[14:44] <japhb__> .ask timotimo Was your performance boost just from doing the "Is it already canonical?" check at the top of canonpath?

[14:44] <yoleaux> japhb__: I'll pass your message to timotimo.

[14:44] <TimToady> masak: I'll go ask Ahab for one.

[14:45] <mathw> cetaceans are cool

[14:45] *** benabik joined
[14:46] <japhb__> FWIW, I think something is seriously awry in whatever underlies subst/s{}= because nearly 50ms to make a single substitution in a 4 char string is crazy.

[14:47] *** jnap left
[14:48] * japhb__ thinks ruefully of the hundreds of millions of CPU ops spent doing that and gets all >.<

[14:49] *** jnap joined
[14:49] <TimToady> especially when you consider how fast Perl 5 can do that

[14:49] <japhb__> yeah

[14:49] <TimToady> but then, Perl 5 has mutable strings

[14:49] *** ajr_ left
[14:49] <masak> japhb__: and the same deal with .trans -- seems we need someone who will ruthlessly optimize those things to a polish. while not destroying the nice architecture in the process.

[14:50] <TimToady> Perl 5 goes to great pains to do a substitution in-place if it can

[14:51] <TimToady> or with at most one copy

[14:51] <frettled> masak: «Hello, this is Microsoft support calling, may I speak to Mr. Nyahrlo, eh, Nyalal, you about a virus on your computer?»

[14:51] <japhb__> I would volunteer, but A) it would be an enormous yak-shave for me, and B) I'm not sure I can string together a long enough block of hours to fully understand the necessary bits and implement the change correctly anyway.

[14:52] <TimToady> and it'll all probably change when we get NFG anyway...

[14:54] <TimToady> and I doubt we have any mechanism yet for knowing whether a variable is the sole owner of an immutable string such that it could temporarily cheat and treat it as mutable

[14:56] <mathw> you wouldn't want to get that wrong...

[14:56] *** araujo left
[14:57] *** araujo joined
[14:57] <japhb__> .oO( leaky broken abstraction )

[14:57] *** jnap left
[14:58] * japhb__ goes back to trying to fix panda on networked filesystems

[14:59] <masak> TimToady: re "any mechanism yet for knowing whether a variable is the sole owner of [...]" -- I think that's a *really* deep problem, like a research problem, of which iceberg escape analysis is but a tip.

[15:00] <TimToady> yes, we realized that when we moved from ref counting to normal gc

[15:01] <TimToady> I'd probably be pretty happy if we could get it down to a single copy

[15:02] <rurban> You'd need to add single-byte refcounts just for lock-free threading

[15:02] <TimToady> when you know the size of your original string, and the sizes of the old and new bits are fixed, you can calculate how much space you'll need

[15:02] <rurban> but not like p5p did it at the end of the string. it needs to be checked atomically

[15:04] <masak> TimToady: the state of the art of reference immutability that I've read is http://irclog.perlgeek.de/perl6/2013-09-26#i_7635049 -- but (a) such an explicit solution is not for mainline Perl 6, and (b) this solution, enticing as it is, doesn't seem "done" to me. notably, the need to forbid globals seems like a design smell.

[15:04] *** ajr joined
[15:04] *** ajr is now known as ajr_

[15:05] *** dmol left
[15:05] <benabik> Immutable strings basically inevitably leads to poor performance of string manipulation.  That's why most languages with them have a mutable version (i.e. Java StringBuilder).

[15:06] <rurban> If they are big use bytebuffers instead. if you need to share parts use tries (as clojure does)

[15:08] <benabik> If we have library methods that do a lot of string mania, we might want to convert it to some mutable format, do the manipulation, and then convert back.

[15:08] <TimToady> well, Buf[Grapheme] is not such a stretch for us

[15:09] <benabik> s/mania/manip/

[15:09] <TimToady> since buffers are mutable lists of integers, and NFG is a list of integers too

[15:10] <diakopter> string mania, too

[15:11] <masak> Perl 5 has string mania :)

[15:12] <benabik> Do Bufs work with things like s{}= ?

[15:24] *** [Sno] left
[15:24] <masak> not at present, no.

[15:25] <masak> I think S05 mumbles something about being able to do pattern matching on byte streams.

[15:25] <masak> but it's never been quite clear to me how.

[15:25] <benabik> We'll need Buf[Grapheme] to do so if we want to use it as a mutable string.

[15:27] <masak> or assume (or provide) an encoding, I guess.

[15:27] <TimToady> one can do pattern matching over any API that allows you to pull out characters at positions, even if the positions are fake, as they are in P5

[15:28] <TimToady> pattern matching in particular is mostly relative positioning, and UTF-8 isn't bad at relative movement

[15:28] *** jnap joined
[15:28] <benabik> Are there byte-string literals?

[15:29] <benabik> (well, buf8 literals, I guess)

[15:29] <TimToady> blob8

[15:29] <TimToady> if you want immutable

[15:29] <benabik> Good point.  Literals should be immutable.

[15:29] <benabik> (Otherwise things get funny in loops.)

[15:30] <diakopter> .oO( "we're not in canada anymore.." )

[15:31] <TimToady> eh?

[15:32] *** jnap left
[15:33] <TimToady> r: say Date.today - '2013-02-03'.Date

[15:33] <camelia> rakudo 455467: OUTPUT«No such method 'Date' for invocant of type 'Str'␤  in block  at /tmp/XoXSf7mThp:1␤␤»

[15:33] <TimToady> r: say Date.today - Date('2013-02-03')

[15:33] <camelia> rakudo 455467: OUTPUT«No such method 'Date' for invocant of type 'Str'␤  in block  at /tmp/N1jUAi612R:1␤␤»

[15:34] <TimToady> seems like a good place for a coercion

[15:34] <TimToady> function names that begin "To" are smelly to me

[15:34] <TimToady> to-ness is precisely what coercions are for

[15:35] <masak> +1

[15:35] *** pmurias joined
[15:36] <masak> I've never satisfactorily figured out where coercion logic "should" be: on the source type, on the target type, or somewhere global, maybe mediated by something adapter-y.

[15:36] <TimToady> in this case the coercion should be defined in Date and the .Date form should delegate to the .() form

[15:37] <benabik> .Foo automagically redirects to Foo() ?

[15:37] <benabik> Generally, or just lots of such methods on Cool?

[15:37] <TimToady> it should if Foo is a type

[15:38] <masak> TimToady: ah, so explicitly on the target type, and implicitly (unless overridden) on the source type? that sounds sane.

[15:39] <benabik> How do you define .() on a type?  method postcircumfix:<()> (Foo:T : ) ?

[15:39] <TimToady> one could go as far as to say that .Foo is really just a postfix, and you'd have to say .'Foo'() to get to a method of that name; my vaguely recalls that the specs had it that way at one point, but it could be a false memory

[15:40] <benabik> So you don't get the automagic behavior on lowercase types?

[15:40] <TimToady> not saying we should do it that way necessarily, since each type would add postfixes, which blows up the grammar

[15:40] <TimToady> a failover might be saner

[15:41] <TimToady> also, a failover allows the source type to define it simply as a method

[15:41] <benabik> Failover is probably saner.  Also allows types to define more specific conversions.

[15:41] *** ssutch joined
[15:42] <TimToady> also, if Foo occurs nowhere as method name, you can optimize away the method dispatch entirely

[15:42] * benabik wonders if many Type.() would include a $arg.^can('Type') as a first try.

[15:42] *** denis_boyun left
[15:43] <TimToady> it may already be this way: note how Date() and .Date produce identical messages

[15:44] <TimToady> except that Date.() seems to be delegating to .Date, and arguably the common case should go the other direction

[15:44] <masak> +1

[15:44] <masak> the target type is more likely to know how to convert to the target type :)

[15:45] * benabik can't find where Date.() is defined.

[15:45] *** denisboyun joined
[15:45] <masak> r: class A { method B { say "OH HAI" } }; class B {}; B(A.new)

[15:45] <camelia> rakudo 455467: OUTPUT«OH HAI␤»

[15:46] <masak> yep -- .() delegates to .Target()

[15:46] <masak> TimToady: if you change the spec, I'll submit a rakudobug ;)

[15:46] <TimToady> S13:171

[15:46] <synopsebot> Link: http://perlcabal.org/syn/S13.html#line_171

[15:47] *** FROGGS joined
[15:47] <TimToady> well, we really need to delegate in both directions, but catch infinite regress

[15:48] <masak> yes, please.

[15:48] <masak> r: say "yes, please" while True

[15:48] <yogan> Wasn't there a way to extend core classes with new methods? Something like: class Int { method foo() { 42 } } gives me "Representation must be composed before it can be allocated" when I try to call 1.foo() (with rakudo).

[15:48] <camelia> rakudo 455467: OUTPUT«(timeout)yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤yes, please␤…»

[15:49] <masak> yogan: `use MONKEY_TYPING`; augment class Int { ... }`

[15:49] <benabik> Type(foo) == foo.Type == foo.^can('Type') ?? foo.Type !! Type.(foo) #?

[15:49] <yogan> masak: Ah, that's it. Thanks!

[15:50] <TimToady> benabik: Type() tries the function first, .Type tries the method first

[15:50] <TimToady> S13:202

[15:50] <synopsebot> Link: http://perlcabal.org/syn/S13.html#line_202

[15:50] <masak> yogan: the `use MONKEY_TYPING` is upper-case because the act itself is anti-social and fairly incompatible with playing nicely in a module ecosystem.

[15:51] <benabik> TimToady: You're essentially expressing a preference, but the compiler should fall back to the other version?

[15:51] <yogan> masak: I see. What would be the cleaner way? Deriving from the class?

[15:51] <masak> yogan: I've always been partial to subroutines.

[15:52] <masak> r: sub foo(Int $x) { say "Look, it's a $x!" }; foo(42)

[15:52] <camelia> rakudo 455467: OUTPUT«Look, it's a 42!␤»

[15:52] <masak> yogan: beyond that, there's a "pretend that this subroutine is a method" option.

[15:52] <benabik> r: sub foo(Int $x) { say "Look, it's a $x!" }; 42.&foo()

[15:52] <camelia> rakudo 455467: OUTPUT«Look, it's a 42!␤»

[15:52] <yogan> masak: That was just the way I had it before. :-)

[15:52] <masak> ...like that.

[15:53] <masak> some languages call that "static methods" or something.

[15:53] <yogan> Ah, with the .&foo syntax. Didn't know that one.

[15:53] <masak> fun thing: it was *discovered*, not added to the language.

[15:54] <TimToady> yes, we add .$foo and .&foo came along for the ride :)

[15:54] <TimToady> *added

[15:54] <yogan> I'm pretty sure I don't want to know how that happened... ;-) (probably wouldn't even understand it)

[15:55] <masak> it happened like TimToady++ said. :)

[15:55] <yogan> What does .$foo do? Sorry, I'm really pretty new with Perl 6.

[15:55] <TimToady> it was simply a matter of writing code in a habitually generic style; used <sigil> to match the $, and & also happens to be a sigil :)

[15:55] <masak> r: 42.&foo() # does this give a compile-time error?

[15:55] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/iDB9G1caLq␤Undeclared name:␤    &foo used at line 1␤␤»

[15:55] <masak> \o/

[15:56] <masak> r: sub foo($a, $b, $c) {}; 42.&foo() # how about this?

[15:56] <camelia> rakudo 455467: OUTPUT«Not enough positional parameters passed; got 1 but expected 3␤  in sub foo at /tmp/8iCNaeLq_D:1␤  in block  at /tmp/8iCNaeLq_D:1␤␤»

[15:56] <TimToady> .$foo requires a hard reference to a routine that will serve as a "method"

[15:56] <masak> \o/

[15:56] <TimToady> just so happens that &foo also gives a hard ref to something Callable

[15:57] <yogan> So foo(42) and 42.&foo() are basically just different syntax for the same thing?

[15:58] <TimToady> pretty much

[15:59] <masak> I can't really think of a difference, semantically.

[15:59] <yogan> Alright, thanks.

[16:00] *** dansamo left
[16:00] *** denisboyun left
[16:01] *** daxim left
[16:01] *** woolfy joined
[16:04] *** benabik left
[16:05] <timotimo> japhb__: yes, the performance boost was only by adding a fast-succeed-path to canonpath.

[16:05] <yoleaux> 14:44Z <japhb__> timotimo: Was your performance boost just from doing the "Is it already canonical?" check at the top of canonpath?

[16:05] *** benabik joined
[16:15] <moritz> where's the patch?

[16:19] *** bluescreen100 joined
[16:20] <timotimo> not on the 'net yet. want it?

[16:20] <moritz> sure

[16:22] *** pmurias left
[16:23] <timotimo> https://github.com/timo/rakudo/tree/fastpath_haha_get_it

[16:23] <timotimo> git wouldn't let me put a ? in the branch name

[16:24] *** bluescreen10 left
[16:24] * masak gets it, after a few seconds

[16:24] <timotimo> :D

[16:25] <moritz> timotimo: just commit 76759b7, right?

[16:25] <timotimo> yes, that's all

[16:25] <timotimo> i haven't spectested it yet

[16:26] <moritz> I will, after the current run finishes

[16:26] <timotimo> thank you

[16:27] <timotimo> i haven't really analyzed that regex thoroughly, but i think it should fail quickly without backtracking much

[16:28] *** lizmat joined
[16:30] <timotimo> so it shouldn't add too much time to every run of canonpath, but if it's already canonical, it should be really quick

[16:31] *** mattp_ left
[16:33] *** mattp_ joined
[16:35] *** fhelmberger left
[16:36] <moritz> my @before = 1.1775159, 1.20721209, 1.15056118, 1.1735369, 1.18734222; say @before R/ [+] @before

[16:36] <moritz> r: my @before = 1.1775159, 1.20721209, 1.15056118, 1.1735369, 1.18734222; say @before R/ [+] @before

[16:36] <camelia> rakudo 455467: OUTPUT«1.179233658␤»

[16:37] <moritz> that's the time for a sink dir() in the source repo

[16:37] <timotimo> in the source repo? there aren't many files there, are there?

[16:37] *** ajr_ left
[16:37] *** denis_boyun joined
[16:37] <moritz> 43

[16:37] <timotimo> should still be a high enough n ...

[16:37] <moritz> (though there are a few processes running in paralle

[16:37] <moritz> l

[16:39] *** [Sno] joined
[16:39] <timotimo> ufo and panda should profit from the speedup of dir()

[16:44] <moritz> r: my @after = 1.32715440, 1.34506589, 1.24679486, 1.2795049, 1.309171; say @after R/ [+] @after

[16:44] <camelia> rakudo 455467: OUTPUT«1.30153821␤»

[16:44] <moritz> that's actually slower than before :(

[16:46] <masak> moritz++ # publishing the original data

[16:47] <timotimo> huh.

[16:48] <timotimo> that surprises me. i had speed improvements locally. let me re-measure

[16:49] * moritz re-measures without running other processes in parallel

[16:50] <timotimo> actually ... if my fast-path succeeds, none of the other substitutions should even do anything

[16:50] <TimToady> it's the mystery R/[+] operator

[16:50] <moritz> r: my @after = 0.70397300, 0.70647127, 0.7048678, 0.7070485, 0.7202731; say @after R/ [+] @after

[16:50] <camelia> rakudo 455467: OUTPUT«0.708526734␤»

[16:50] <moritz> *recompile*

[16:50] <timotimo> that's more in line with my findings

[16:51] <moritz> well, I haven't done the comparison measurement without parallel processes yet

[16:53] <masak> TimToady: with all the math-y junk we already have in the setting, I'm kinda surprized we don't have avg() and stddev() yet :)

[16:53] <TimToady> that's not math, that's just statistics :P

[16:53] <masak> fair point.

[16:54] <moritz> my @before = 0.73889503, 0.7367437, 0.7434040, 0.7421254, 0.7314602 ; say @before R/ [+] @before;

[16:54] <moritz> r: my @before = 0.73889503, 0.7367437, 0.7434040, 0.7421254, 0.7314602 ; say @before R/ [+] @before;

[16:54] <camelia> rakudo 455467: OUTPUT«0.738525666␤»

[16:54] <timotimo> *huh*

[16:54] <moritz> r: say (0.738525666 - 0.708526734) / 0.738525666 * 100

[16:54] <camelia> rakudo 455467: OUTPUT«4.0620026332␤»

[16:54] <timotimo> that's not nearly as slow as my local stuff.

[16:56] <timotimo> moritz: do the paths you create actually take my fast path?

[16:56] <timotimo> or do they have a . in them or something like that?

[16:57] <timotimo> say dir("/etc/") takes 3.2s here, but dir("/etc") takes only 0.9s

[16:58] <TimToady> sure that's not caching?

[16:58] <timotimo> i suppose the /etc/ version appends ./ at the end and that causes canonpath to run

[16:58] <timotimo> i re-ran it.

[16:58] <timotimo> the difference is true.

[16:59] <TimToady> maybe we should use a faster langauge for canonicalizing :)

[16:59] <timotimo> probably should strip / from the end of paths before running them through dir. running canonpath on it should do the trick

[17:03] <masak> wow, JavaScript ES6 and template strings: http://www.nczonline.net/blog/2012/08/01/a-critical-review-of-ecmascript-6-quasi-literals/

[17:05] *** vk joined
[17:06] <masak> I must say I like using the `` syntax for template strings.

[17:07] <PerlJam> even in Perl?

[17:08] <masak> well, "" already do most of the things in that article, whether you mean Perl 5 or Perl 6.

[17:08] <PerlJam> "template strings" sounds very much like simple macros, which is why I asked :)

[17:09] <masak> for Perl 6, I think the party line is to leave `` easily grabbable for eager slangers.

[17:09] <masak> PerlJam: AFAICS, it's simply qq strings + heredocs + filtering :)

[17:09] *** pernatiy_ left
[17:09] <benabik> r: say `echo hello`

[17:09] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/4EmlqBoUvo␤Two terms in a row␤at /tmp/4EmlqBoUvo:1␤------> say ⏏`echo hello`␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-p…»

[17:09] <benabik> std: say `echo hello`

[17:09] <camelia> std a0bcfb1: OUTPUT«===SORRY!===␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/00UJWerwM_ line 1:␤------> say⏏ `echo hello`␤Confused at /tmp/00UJWerwM_ line 1:␤…»

[17:10] *** vk is now known as vky

[17:10] <timotimo> r: say ‘hello’

[17:10] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/z2kj5utQnb␤Two terms in a row␤at /tmp/z2kj5utQnb:1␤------> say ⏏‘hello’␤    expecting any of:␤        argument list␤        prefix or term␤        prefix or meta-pr…»

[17:10] <timotimo> r: say q‘hello’

[17:10] <camelia> rakudo 455467: OUTPUT«hello␤»

[17:11] <timotimo> r: say q`hello`

[17:11] <camelia> rakudo 455467: OUTPUT«hello␤»

[17:11] <benabik> I somewhat expected an error telling me to use qx (or whatever quote that is.)

[17:12] <timotimo> no, qx is execute quoting

[17:12] <benabik> Right.  That's what `` used to be, no?

[17:12] <timotimo> oh, really?

[17:13] <benabik> In p5 anyway.

[17:13] <timotimo> may very well be

[17:13] <timotimo> in python `foo` meant repr(foo), which is basically our .perl

[17:13] <benabik> p5eval: print `echo hello`

[17:13] <p5eval> benabik: ERROR: Insecure $ENV{PATH} while running with -T switch at (eval 7) line 1.

[17:13] <benabik> Okay, yes, allowing arbitrary commands is somewhat insecure.

[17:17] <benabik> Yeah, Python's `` confused me after years of perl and shell.

[17:20] *** benabik left
[17:24] *** Rotwang joined
[17:27] *** vky left
[17:27] <masak> in python `foo` is discouraged these days. py3 removes it and looks meaningfully towards repr(foo)

[17:27] <masak> I guess two ways of doing it can't both be obvious :)

[17:27] <timotimo> yes

[17:28] *** vky joined
[17:32] *** benabik joined
[17:34] <timotimo> so, what's the proper way to make the performance good? just remove trailing /es from the path in the dir sub?

[17:40] <timotimo> but only on unix?

[17:43] <timotimo> (but that's only because i have no idea how it behaves on windows and other platforms)

[17:43] <timotimo> or maybe .child should know about trailing /es?

[17:47] *** ggoebel7 left
[17:49] *** ggoebel joined
[17:49] *** prevost left
[17:50] <timotimo> maybe catfile could be taught not to create //es?

[17:50] <timotimo> if it's so expensive to remove them again

[17:52] *** SamuraiJack joined
[17:56] *** ggoebel7 joined
[17:58] *** stevan_ left
[17:59] *** stevan_ joined
[18:01] *** ajr joined
[18:02] *** ajr is now known as Guest78383

[18:02] *** fhelmberger joined
[18:02] *** Guest78383 is now known as ajr_

[18:04] *** ggoebel7 left
[18:09] *** ggoebel7 joined
[18:18] *** bloonix left
[18:21] *** stevan_ left
[18:22] *** fhelmberger left
[18:29] *** cognominal left
[18:29] *** cognominal joined
[18:36] *** Sqirrel_ joined
[18:46] *** stevan_ joined
[18:47] *** stevan__ joined
[18:51] *** stevan_ left
[18:52] *** Sqirrel_ left
[18:55] *** xenoterracide joined
[18:56] *** ggoebel7 left
[18:57] *** darutoko left
[19:00] <moritz> p5eval: $ENV{PATH} = '/bin:/usr/bin'; `echo hello`

[19:00] <p5eval> moritz: interrupting, taking more than 5 second(s)

[19:00] <p5eval> moritz: No output

[19:14] *** dmol joined
[19:15] <moritz> ok, two weird ideas for regex optimizations

[19:15] <moritz> first, do we use the cursor's Bool method? If yes, we might speed up regexes matches with a custom boolification protocol

[19:16] <moritz> second: we could turn scan(literal) and scan(concat(literal, ...)) into something that uses index() to finds possible starting positions

[19:17] *** benabik left
[19:19] <PerlJam> that second one isn't so weird.

[19:19] * moritz looks at QAST::Copmiler and is scared

[19:19] <moritz> PerlJam: probably not

[19:20] <TimToady> p5 goes as far as to recognize that /...foo/ can index for 'foo' and then back off 3 chars

[19:20] <moritz> nqp: say(nqp::index('ababc', 'ab', 0)

[19:20] <camelia> nqp: OUTPUT«Confused at line 2, near "say(nqp::i"␤current instr.: 'panic' pc 14748 (src/stage2/gen/NQPHLL.pir:5229) (src/stage2/gen/NQPHLL.nqp:279)␤»

[19:20] <moritz> nqp: say(nqp::index('ababc', 'ab', 0))

[19:20] <camelia> nqp: OUTPUT«0␤»

[19:20] <moritz> nqp: say(nqp::index('ababc', 'ab', 1))

[19:20] <camelia> nqp: OUTPUT«2␤»

[19:21] <TimToady> (iirc)

[19:21] <moritz> TimToady: I know, but for that we'd have to track min and max length, and that would be a much more intrusive patch

[19:21] <frettled> TimToady: well, that's pretty nice.  And perhaps even an obvious optimization for what Perl 5 is :)

[19:21] <moritz> (especially considering that it mostly won't help with parsing at all, just with traditional regex matches)

[19:22] *** cognominal left
[19:22] *** cognominal joined
[19:23] <frettled> not that there's anything wrong with traditional regexp matches :)

[19:23] <frettled> I suppose it would be a pretty complicating factor to treat these things separately, too.

[19:23] <moritz> there isn't, but I don't want to slow down parse times of the rakudo setting

[19:24] <TimToady> I think a big optimization will be finding more ways to make use of what the DFA matched to figure out how to avoid rematching in the procedural bits

[19:25] * frettled waits for someone to step in from a side wing and fling the traditional insult of "get someone who knows compilers".  *snort*  *grumble*

[19:25] <TimToady> "we would have descended through these recursive nodes, so just wrap this in these bits of AST, which is what those nodes would have done if we'd called them"

[19:25] * frettled sees no fault in that part of P6 developer competence.

[19:26] <TimToady> well, we understand why bottom-up parsers are faster, and also why they're stupider

[19:26] <frettled> and quite a lot more :L)

[19:27] <TimToady> LALR!

[19:28] <frettled> Heeey, I'd repressed that.

[19:28] <TimToady> one possible optimization is recognizing when we have a large chunk of language that is not being mutated, and write a little LALR parser for it; if it gets into syntactic trouble, we just back up and retry with recursive descent to diagnose the problem better

[19:29] *** Rotwang left
[19:31] <frettled> That should be pretty quick.

[19:32] <frettled> I'm thinking of whether there is a way to program this that would take advantage of the extra registers in current x86 architecture, which seems rather dominant, as well as state-of-the-art ARM architecture.

[19:32] <frettled> That is a few layers removed, but perhaps, perhaps. …

[19:33] *** berekuk_ left
[19:36] *** denis_boyun left
[19:36] <lue> platform-specific advantage taking is in the domain of Parrot, the JVM, and MoarVM methinks

[19:39] <jnthn> evening, #perl6

[19:39] <moritz> \o jnthn 

[19:39] <frettled> Well, this is not just platform-specific, but about programming so that it's easy for the VM to understand that hey, these things here, they fit these registers that I have rather many of here.

[19:39] <TimToady> g'day

[19:39] <frettled> jnthn: yay! o/

[19:39] <colomon> \o

[19:39] * jnthn 's trip home from Oslo was thankfully less stressful than his trip to Oslo :)

[19:40] *** berekuk joined
[19:40] *** benabik joined
[19:40] <frettled> jnthn: was it nice?

[19:41] <TimToady> fewer terrorists?

[19:41] *** bluescreen100 left
[19:41] <moritz> ok, I have the detection in place for when we can do an nqp::index scan

[19:41] <moritz> now I "just" need to make the codegen work

[19:42] <jnthn> frettled: The time in Oslo was nice, though quite tiring as I was teaching :)

[19:42] <TimToady> moritz: have you tested index to see if it's actually faster than regex? :D

[19:42] <jnthn> The trip there was stressful 'cus I had to discover whether you can make it to your flight if you arrive at Copenhagen airport ~25 mins before it leaves :)

[19:42] <moritz> TimToady: I haven't, but I'm pretty sure it is :-)

[19:43] *** ggoebel7 joined
[19:44] <moritz> nqp: say(nqp::index("foo", "bar"))

[19:44] <camelia> nqp: OUTPUT«-1␤»

[19:44] *** Rotwang joined
[19:44] *** itz_ left
[19:45] *** itz joined
[19:45] <frettled> jnthn: well, knowing you, your pupils had a good time :)

[19:47] *** risou is now known as risou_awy

[19:50] * moritz has a 16-line patch that could conceivably work

[19:50] <frettled> worth testing?

[19:50] <moritz> worth compiling :-)

[19:51] * moritz wants a convenient way to run qregex tests with stage 1

[19:51] * jnthn wonders what moritz's 16 line patch does :)

[19:51] <jnthn> moritz: prove --exec "...the stage 1 invocation" t/qregex

[19:51] <jnthn> But maybe that's not convenient enough ;)

[19:51] <moritz> jnthn: it tries to implement rxtype<scan> with nqp::index scan

[19:51] <jnthn> But could always at it as a make stage1test :)

[19:51] <jnthn> moritz: ooh! :D

[19:52] <moritz> t/qregex/01-qregex.t .. ok     

[19:52] <moritz> All tests successful.

[19:52] <jnthn> Yes, that's worth it

[19:55] <moritz> after: 0.000600814819335938

[19:55] * moritz recompiles to check the "before" time

[19:56] <moritz> https://gist.github.com/moritz/7047280 # benchmark, totally artifical

[19:56] <frettled> :)

[19:57] <frettled> run 7 times, purge outliers, mean and distribution? :)

[19:57] <moritz> before: 0.00112199783325195

[19:58] <moritz> ok, I need to do statistics to actually find something out

[20:08] <moritz> gah, first check correctness, then check timings

[20:09] <moritz> I found that the timings are the same before and after

[20:09] <moritz> then I looked at the generated pir: no changes :(

[20:09] <moritz> so, the codegen didn't work the way I wanted it to

[20:11] *** lue joined
[20:11] <timotimo> that's why i always leave debug says in there until the very end, sometimes too long :P

[20:12] <moritz> ok, found at least one obvious bug by eyeballing

[20:13] <moritz> timotimo: committing debug code to production? happens to me all the time :/

[20:17] *** sqirrel left
[20:18] *** sqirrel joined
[20:22] <moritz> ok, now the codegen actually does stuff differently

[20:23] *** LWA left
[20:23] *** LWA joined
[20:24] * TimToady hopes it fails constructively, where success is construed as one form of constructive failure...

[20:27] <moritz> ok, significant faster now, but fails some qregex tests :/

[20:27] <moritz> though maybe that's due to the debug output

[20:29] <moritz> it's not :(

[20:29] *** sqirrel left
[20:30] <timotimo> significantly? maybe it just fails faster now :P

[20:30] <moritz> oh, because ignorecase

[20:31] <timotimo> oooooh

[20:31] <timotimo> along the same lines, did you make sure to handle zerowidth and such?

[20:32] <TimToady> nqp: say(nqp::index("", "bar"))

[20:32] <camelia> nqp: OUTPUT«-1␤»

[20:32] <TimToady> nqp: say(nqp::index("", ""))

[20:32] <camelia> nqp: OUTPUT«-1␤»

[20:32] <TimToady> nqp: say(nqp::index("foo", ""))

[20:32] <camelia> nqp: OUTPUT«-1␤»

[20:32] <TimToady> ooh, I'd say there's a bug

[20:33] <timotimo> finding nothing should always give you 0?

[20:33] <timotimo> because nothing can be found in every string?

[20:33] <TimToady> p5eval: say index("","")

[20:33] <p5eval> TimToady: 01

[20:33] <TimToady> p5eval: say index("","something")

[20:33] <p5eval> TimToady: -11

[20:33] <TimToady> p5eval: say index("something","")

[20:33] <p5eval> TimToady: 01

[20:34] <TimToady> yes, that's the correct degenerate case

[20:34] <TimToady> nrp: say index('','')

[20:34] <camelia> rakudo 455467, niecza v24-98-g473bd20, pugs: OUTPUT«0␤»

[20:35] <TimToady> looks like just an nqp bug

[20:35] <TimToady> or maybe a parrot bug?

[20:36] <TimToady> is correct on jvm

[20:37] <TimToady> nqp-jvm: say(nqp::index("", ""))

[20:37] <camelia> nqp-jvm: OUTPUT«0␤»

[20:38] <TimToady> nqp-moar: say(nqp::index("", ""))

[20:38] <TimToady> nqp-m: say(nqp::index("", ""))

[20:38] <camelia> nqp-moarvm: OUTPUT«0␤»

[20:38] <TimToady> how come we have nqp-jvm but nqp-m?

[20:39] <TimToady> oh, it's nqp-moarvm

[20:39] <TimToady> you can see how much I've already internalized that its name is "moar", not "moarvm"

[20:45] <jnthn> Well, its executable name is at least :P

[20:46] <moritz> jnthn: in a case insensitive match, is $*REG<tgt> already lower-cased?

[20:46] <jnthn> No

[20:46] <jnthn> Actually it's only literal rxtype that has ignorecase handling.

[20:46] <jnthn> We handle :i in charclasses in the action method

[20:47] <jnthn> And pass it along to a couple of the itnerpolaters

[20:47] <moritz> well, for making scan index()-based, I also need to handle that :/

[20:48] <jnthn> hmmm

[20:48] <jnthn> Or just don't do it for the :i case for now?

[20:48] <moritz> that's possible, yes

[20:48] *** kaare_ left
[20:49] <TimToady> in any case, lc() is unicodically incorrect, and you should be using fc()

[20:49] <jnthn> fc that!

[20:49] <jnthn> But yeah, Moar has supprot for fc :)

[20:49] <jnthn> Made sure of that :)

[20:49] *** donaldh_ joined
[20:50] <jnthn> So we can at least get it right there

[20:50] <moritz> Ceterum censeo Unicode esse delendam

[20:50] <TimToady> nqp-m: say(nqp::fc("Moar"))

[20:50] <camelia> nqp-moarvm: OUTPUT«No registered operation handler for 'fc'␤compile_op␤»

[20:50] <TimToady> nqp-m: say(fc("Moar"))

[20:50] <camelia> nqp-moarvm: OUTPUT«(signal SEGV)No lexical found with name '&fc'␤frame_name_0␤»

[20:51] <TimToady> nqp-m: say(("Moar").fc)

[20:51] <camelia> nqp-moarvm: OUTPUT«Missing method cache; late-bound dispatch NYI␤frame_name_0␤»

[20:51] <jnthn> SEGV?!

[20:51] <moritz> oooh, a segfault

[20:51] <TimToady> "supprot" indeed

[20:51] <jnthn> Oh, it's only as a VM-level op iirc

[20:52] <jnthn> oh, hmm

[20:52] <moritz> t/qregex/01-qregex.t .. ok

[20:52] <moritz> \o/

[20:53] <jnthn> moritz++

[20:55] <moritz> and here are the benchmarks

[20:56] <moritz> nqp::x('abc', 500) ~ 'def' ~~ /def/

[20:57] <moritz> before: 647 +- 28 us, after 161 +- 18 us

[20:57] <moritz> and with s/500/5000/:

[20:57] <jnthn> \o/

[20:58] <moritz> before: 5009 +- 275 us, after 486 +- 350 us

[20:58] <jnthn> Woo

[20:59] <moritz> 19 lines of patch

[20:59] <TimToady> do it again!

[21:00] <japhb__> Oooh, that ought to be visible in all sorts of places.

[21:00] <japhb__> moritz++

[21:00] <timotimo> holy crap, that could have happened earlier! :))

[21:01] *** stevan__ left
[21:02] *** SamuraiJack left
[21:02] *** stevan_ joined
[21:03] *** ggoebel7 left
[21:03] <moritz> ok, running a final test after a small cleanup

[21:03] *** colomon left
[21:04] <moritz> don't get too excited; it's a case that doesn't happen at all in grammar matches

[21:04] <timotimo> of course

[21:04] <timotimo> but it might still speed up bits and pieces here and there?

[21:05] <jnthn> It's a dramatic win for anything that would have to have scanned strings before

[21:06] <jnthn> moritz: Is that timing on the JVM or Parrot, ooc?

[21:06] <moritz> jnthn: parrot only

[21:06] <moritz> needs implementing in the JVM codegen too, I suppose

[21:07] <dalek> nqp: 71c142a | moritz++ | src/ (2 files):

[21:07] <dalek> nqp: regexes: speed up scanning for literal matches

[21:07] <dalek> nqp: 

[21:07] <dalek> nqp: if an unanchored regex (not ignoring case) starts with a literal,

[21:07] <dalek> nqp: we now use the "index" opcode (at least on parrot) to search for

[21:07] <dalek> nqp: the start position.

[21:07] <dalek> nqp: Speeds up the fairly artifical benchmark nqp::x(abc, 500) ~ def ~~ /def/

[21:07] <dalek> nqp: by a factor of 4

[21:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/71c142a34f

[21:07] <moritz> and JVM too

[21:07] *** ggoebel7 joined
[21:07] <jnthn> May be smaller win on JVM as it doesn't substr to compare. Similar for MoarVM

[21:07] <moritz> I factored it so that backends not doing the optimization shouldn't regress on it

[21:08] <Mouq> moritz++

[21:08] <moritz> though a good substring search can still be a lot faster than comparing position by position

[21:09] *** colomon joined
[21:09] *** benabik left
[21:10] <moritz> huh, I can't build nqp on the JVM :(

[21:10] <moritz> jar cf0 nqp-runtime.jar -C bin/ .

[21:10] <moritz> java.lang.UnsatisfiedLinkError: /usr/lib/jvm/java-7-oracle/jre/lib/amd64/libnio.so: /usr/lib/jvm/java-7-oracle/jre/lib/amd64/libnio.so: failed to map segment from shared object: Cannot allocate memory

[21:10] *** skids left
[21:11] <moritz> ok, going to bed now

[21:11] <timotimo> you may need to ... wait what

[21:11] <jnthn> wat

[21:12] <timotimo> i'll look if i can figure out how to make the same codegen changes on jvm or something

[21:12] <moritz> if anybody wants to follow up on that optimization: 1) the code from P6Regex/Actions.nqp needs porting to P5Rgex/Actions.nqp too (should be straight forward)

[21:12] <moritz> 2) JVM 3) MoarVM

[21:12] <moritz> ++timotimo

[21:13] *** donaldh_ left
[21:13] <moritz> sleep&

[21:13] *** donaldh_ joined
[21:14] *** btyler left
[21:16] *** ggoebel7 left
[21:16] *** donaldh_ left
[21:18] <timotimo> oh, the jvm codegen is ... completely different

[21:18] *** ggoebel7 joined
[21:18] <timotimo> i should have known

[21:18] <timotimo> oh, i was just looking at the completely wrong file :D

[21:23] <timotimo> yeah, i don't even know what i'm looking at here %)

[21:25] *** donaldh_ joined
[21:25] *** donaldh_ left
[21:27] *** ggoebel7 left
[21:31] *** ggoebel7 joined
[21:47] *** stevan_ left
[21:55] *** Rotwang left
[21:58] *** vky left
[22:04] *** vky joined
[22:18] *** deorritke joined
[22:26] *** stevan_ joined
[22:26] *** deorritke left
[22:26] <dalek> perl6-roast-data: cb8e1e5 | coke++ | / (3 files):

[22:26] <dalek> perl6-roast-data: today (automated commit)

[22:26] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/cb8e1e5e09

[22:27] *** stevan_ left
[22:27] *** stevan_ joined
[22:29] <timotimo> how did niecza reach 00.00%?

[22:30] <timotimo> ah, it did not build?

[22:31] <[Coke]> yes. seems fine today.

[22:32] *** BenGoldberg joined
[22:33] <timotimo> today?

[22:33] <timotimo> the today i'm looking at at the moment claims not so.

[22:33] <[Coke]> yes, that today was yesterday

[22:34] <[Coke]> "Coke authored a day ago"

[22:34] <timotimo> aah

[22:34] *** xenoterracide left
[22:39] <jnthn> bah, I read the headline "Swiss seize a million fake tablets" and thought it was, like, fake iPads or something...

[22:40] <jnthn> You know you read too much tech news when... :)

[22:40] <jnthn> Well, I have latest builds of stuff, and hopefully tomorrow will have some tuits to hack on stuff )

[22:40] <timotimo> looking for wardto it!

[22:42] <jnthn> Gotta go travel again on Sunday, though...

[22:47] *** grondilu left
[22:48] *** xenoterracide joined
[22:49] *** pecastro left
[22:59] *** vky left
[23:01] *** ajr_ left
[23:20] *** vky joined
[23:26] *** vky left
[23:29] *** xenoterracide left
[23:41] *** Mouq left
[23:50] *** xenoterracide joined
[23:51] *** pecastro joined
[23:57] *** Mouq joined
[23:59] <dalek> perl6-roast-data: 1d8fa71 | coke++ | / (2 files):

[23:59] <dalek> perl6-roast-data: today (automated commit)

[23:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1d8fa719ac

[23:59] *** dmol left
