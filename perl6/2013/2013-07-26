[00:03] <timotimo> i don't see what i did differently from colomon's initial posting

[00:03] <colomon> ?

[00:04] *** rGeoffreeey joined
[00:04] <timotimo> i have my @a; for (1 .. SCALE) { @a.push: $_ }

[00:05] <timotimo> it doesn't show the ridiculous difference in performance between before and after jnthn's for sink fix in my graphs: http://t.h8.lv/p6bench/for_push_sink.html

[00:06] *** PZt joined
[00:06] <colomon> timotimo: why doesn't it go out to the 16384 column?

[00:09] *** augustus joined
[00:09] <timotimo> colomon: there's a number called "enough time" or something in the benchmark framework

[00:10] <timotimo> it will double the scale until the test takes longer than enough time

[00:12] <augustus> So I read that work on the JVM has made a lot of progress.  Does it do enough to be worth playing with?  Are there any instructions on how to set it up?

[00:12] <yoleaux> 7 Jul 2013 04:01Z <raiph> augustus: example of grammar dynamically building grammar: http://rosettacode.org/wiki/Parse_EBNF#Perl_6

[00:12] <colomon> timotimo: I can't tell you exactly what is going on, but something is really, really wrong with that graph.

[00:13] <timotimo> augustus: it's fun to play with. our module installer doesn't work with it (to my knowledge), but it doesn't lack many features and it's got nice performance in many cases

[00:13] <timotimo> startup time is horrible, though

[00:13] <timotimo> but you can play with threads on it ;)

[00:13] <colomon> On my Mac, pushing 8192 values one by one takes 1 second total under the latest jakudo.

[00:13] <colomon> that's not counting startup time

[00:14] <colomon> 6.6s with startup time

[00:14] <colomon> so that's 

[00:14] <colomon> r: 8192 / 6.6

[00:14] <camelia> rakudo 117beb:  ( no output )

[00:14] <colomon> r: say 8192 / 6.6

[00:14] <camelia> rakudo 117beb: OUTPUT«1241.212121␤»

[00:14] <colomon> 1241 iterations per second

[00:14] <augustus> timotimo: So is it part of Rakudo, or is it a separate download/build?  I'm just unsure how to get started.

[00:15] <colomon> or 8192 per second not counting startup time

[00:15] <colomon> unless you're doing timings on a raspberry pi, I greatly doubt my system is actually 10x faster than yours

[00:16] <timotimo> you get the same repo, and then you use ConfigureJVM.pl in nqp/ and in / and then you get a "perl6" binary (shell script actually) that you can just run after you "make install"

[00:16] <timotimo> so basically you git clone github.com/rakudo/rakudo and inside you clone github.com/perl6/nqp and inside nqp you ConfigureJVM.pl, make, make install and in rakudo you ConfigureJVM.pl --with-nqp=nqp/install/nqp, make, make install

[00:16] <timotimo> that's all. you do need at least java7 to do it, though

[00:17] <timotimo> i have an idea why it may be wrong actually

[00:17] <augustus> timotimo: Ok, that sounds pretty easy then.  Once built, I can just run my scripts like nothing's different?

[00:17] <timotimo> yes, indeed

[00:17] <timotimo> well, that's the idea anyway

[00:17] <augustus> :)

[00:17] <timotimo> if you have trouble, you're probably running into some bug and should report that here, but so far things have been going great

[00:18] <timotimo> be sure to try the async sub :3

[00:18] <augustus> ok cool.  Do you have any idea whether anybody else is looking into running in a servlet environment?  eventually I want to go that direction

[00:20] <timotimo> i don't know of any such plans. if you experiment with that, i'd be interested to read your blog posts ;)

[00:20] <augustus> In general, how much work is involved "thunking" between p6 and java?

[00:21] <augustus> I would assume that I would make simple wrapper classes in java that call into simplified perl code since java obv won't understand p6 objects

[00:22] <timotimo> i can link you to code for both directions, hold on

[00:23] <augustus> cool

[00:25] <timotimo> huh, where is the evalserver at

[00:25] <timotimo> ah, in nqp

[00:26] <timotimo> https://github.com/perl6/nqp/blob/c154ef8da29e18393d6046d08ec42faf1166d33c/src/vm/jvm/runtime/org/perl6/nqp/tools/EvalServer.java - this is how you execute nqp-based code from java

[00:27] <augustus> ok lemme take a look

[00:27] <timotimo> https://github.com/rakudo/rakudo/blob/5cab6634ddfab82a00218800aafcee2f3ae73560/src/vm/jvm/core/Threading.pm - this is how you use java classes from inside perl6

[00:27] <timotimo> (the latter will get a layer of sugar coating at one point)

[00:29] <augustus> is it hooking up stdin and stdout to sockets, or is the socket part a superflous part of this example?

[00:30] <timotimo> the socket is to connect with the evalclient

[00:30] <timotimo> it's to get a spectest run through in less than 2 days ;)

[00:30] <timotimo> the startup time really is dreadful

[00:31] <augustus> just trying to understand the overall architecture here.  the nqp interpreter is being fired up in another thread, and then connected to with a socket?

[00:31] <augustus> in this example, where is the perl6 code that's being fed in?

[00:32] <augustus> hmm, it's being fed in as an arg?

[00:32] <timotimo> it's being fed in via the socket

[00:32] <timotimo> evalclient receives the code to be executed as a filename as well as the secret token

[00:33] <timotimo> it connects to the evalserver (the java code you have in front of you) and that in turn runs the code and then sends the output back to the eval client

[00:33] *** btyler left
[00:33] <timotimo> in fact, the evalclient seems to send over the args or something

[00:34] <timotimo> else if (cmdStrings[1].equals("run")) {  <- here begins the interesting part

[00:34] <augustus> I think i'm getting it, you pass in the name of the class that you want to run the main function of

[00:35] <augustus> yeah I see the Ops.invokeMain, trying to see where Ops gets initialized

[00:35] <augustus> hmm must be static function

[00:35] *** xinming left
[00:36] <timotimo> wait, class? main function of?

[00:36] <timotimo> are we talking about the same thing

[00:36] <timotimo> ?

[00:36] <augustus> well the "usage" indicates you provide a main class as I read it

[00:36] <augustus> via the --app

[00:37] <augustus> "Usage: %s [-bind-stdin] -cookie <name-for-access-token-file> -app <main-class>\n"

[00:37] <timotimo> oh?

[00:37] *** xinming joined
[00:37] <timotimo> that's weird. but i don't know java and haven't properly looked at that code yet

[00:37] <augustus> on a cursory reading it appears that it's searching for <main-class> and then running that, and compalins if it doesn't have an entry point?

[00:38] <timotimo> but that's not the interesting part anyway ;)

[00:38] <timotimo> and you're right, this Ops.invokemain comes from a class full of static methods

[00:39] <augustus> I see it setting up a compilation unit, but I can't tell if it is feeding it some code to compile or not

[00:40] <timotimo> colomon: http://t.h8.lv/p6bench/for_push_sink.html <- you were right. i forced it to not keep the stuff around, so that it properly syncs

[00:40] <colomon> that's crazy better, eh?

[00:41] <timotimo> yes! :)

[00:41] <timotimo> much better asymptotical behavior

[00:41] *** snoopy joined
[00:43] <augustus> aha, I think I'm starting to get it.  There's the startup command, which is what I was looking at, and then after startup, you send individual commands in the form of "run some-stuff ..."

[00:43] <augustus> so the actual code getting run is what gets parsed out from the socket in argv

[00:43] <augustus> and then passed in to invokeMain

[00:43] <snoopy> colomon: CSS::Grammar failures should be fixed - was misusing Buf

[00:44] <colomon> snoopy++

[00:45] *** rGeoffreeey left
[00:51] <augustus> timotimo: can you pass JAVA_HOME to ConfigureJVM.pl?  It seems to be using /usr/bin/java which is too old

[00:55] <timotimo> sorry, no clue :(

[00:55] <augustus> a quick examination of the source says no.  probably a good idea to add that, as lots of java people have lots of different java versions installed.

[00:57] <augustus> I can probably start a new shell, put the right java at the front of the path

[01:03] *** btyler joined
[01:07] <augustus> This may be a dumb question, but is the JVM restricted to NQP, or is it full perl6?  I'm still a little hazy on how much functionality is in NQP.

[01:09] <timotimo> rakudo is implemented in nqp. both work on jvm

[01:11] <augustus> ahh, ok.  You boostrapped nqp, and that allowed full Rakudo.  So I'm actually running Rakudo on JVM.  Somehow I thought Rakudo was like the compiler.  Is the perl6 code getting turned into byte code?

[01:12] *** ajr joined
[01:12] *** ajr is now known as Guest35762

[01:13] <timotimo> yes, it is

[01:13] <timotimo> you can generate your perl6 code into .jar files

[01:13] *** Guest35762 left
[01:14] <timotimo> you'll still need the runtime, which isn't small, and it seems like no matter wether or not you have any possibility at all to run eval from your script, you'll have to carry around the grammar and compiler

[01:14] <augustus> Ok, cool.  So Rakudo is like the implementation of the runtime?

[01:15] <augustus> just trying to understand which piece is the compiler, although in perl6 land that may be a fuzzy distinction because of eval capabilities?

[01:15] <timotimo> well, a part of the runtime functionality comes from nqp, a part comes from rakudo

[01:15] <timotimo> rakudo is "the compiler" + core setting ("standard library" if you will) and runtime stuff ("open this file", ...)

[01:16] *** Celelibi joined
[01:17] <timotimo> rakudo: my $foo := nqp::list(); nqp::push($foo, 1); say nqp::atpos($foo, 0);

[01:17] <camelia> rakudo 117beb: OUTPUT«1␤»

[01:17] <timotimo> as you can see, you still have nqp stuff available in your rakudo-based perl6 code

[01:17] <timotimo> so it's kind of intermingled

[01:18] <augustus> At some point I'd have to see a diagram I think.  I get the gist of most of it, but I feel some distinctions are eluding me.  ATM I don't think those dinstinctions are important (to me)

[01:18] <timotimo> i don't think they are, no

[01:20] <augustus> Ok, just got Hello World to run! Thanks for your help!

[01:20] *** stevan_ joined
[01:22] *** stevan_ left
[01:23] <augustus> hey, where the code says my \JVMThread, in p6, the \ no longer means reference right? Does it mean opaque or something similar?

[01:23] <timotimo> it means something like "no container for this", but i'm not sure about the specifics

[01:24] <timotimo> i interpret it as "pass this thing as raw as possible, don't make a container, i'll be careful with it"

[01:25] <augustus> k.  I'm gonna try and see if I can do a simple hello world by calling System.out.println.  That would probably be a good example.

[01:25] <timotimo> if you get a \ argument, you can use things like nqp::iscont to figure out if there's a container, for instance

[01:26] <PerlJam> I thought the important thing about \foo was that it didn't accidentally provide a context (like $foo provides and item context)

[01:26] <PerlJam> s/and/an/

[01:26] <timotimo> perhaps

[01:27] <augustus> also, := (with the colon) is creating an alias, kind of like a reference in C++? 

[01:28] <timotimo> that's comparable, yes

[01:28] <timotimo> its most common use case for me is preventing assignment to a list (on the left) to eagerly slurp up something that i want to be lazy

[01:28] <timotimo> r: say "begin"; my @lazy := 1..*; say "alive"; my @a = 1..*; say "never reached";

[01:28] <camelia> rakudo 117beb: OUTPUT«begin␤alive␤never reached␤»

[01:29] <timotimo> er, sorry :)

[01:29] <timotimo> r: say "begin"; my @lazy := 1..*; say "alive"; my @a = 1...*; say "never reached";

[01:29] <camelia> rakudo 117beb: OUTPUT«begin␤alive␤never reached␤»

[01:29] <timotimo> ... that's ... embarassing

[01:29] <timotimo> r: say "begin"; my @lazy := 1..*; say "alive"; my @a = for 1..* { $_ }; say "never reached";

[01:29] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'for' interpreted as a listop; please use 'do for' to introduce the statement control word␤at /tmp/4WfYfvI7E9:1␤------> [32m @lazy := 1..*; say "alive"; my @a = for[33m⏏[31m 1..* { $_ }; say "never reached";[0m␤Unexpected blo…

[01:29] <PerlJam> augustus: re \foo, see S06:1257

[01:29] <synopsebot> Link: http://perlcabal.org/syn/S06.html#line_1257

[01:29] <timotimo> well, you get the idea.

[01:30] <augustus> I think so :)

[01:31] <PerlJam> timotimo: p6 is far lazier than you give it credit for ;)

[01:31] <timotimo> :)

[01:32] <augustus> so I see stuff like \JVM."method/methodname()" so I'm guessing that's how I run a java method.  Any idea how I would access System.out, which is a static object?

[01:32] <timotimo> no :(

[01:54] *** jaldhar left
[01:55] <augustus> I'm not sure where to look for the logic that is parsing out 'method/methodname' to understand the syntax.  It must be different for static functions.  I tried accessing a static method of System rather than accessing out, but no dice.

[02:00] <timotimo> that's JVM internal i believe

[02:03] <augustus> hmm that never occurred to me lol

[02:04] *** orafu left
[02:04] *** OuLouFu joined
[02:04] *** OuLouFu is now known as orafu

[02:04] <augustus> also even though everything is static, I need to create a new object.  I see now that I have a TypeObject, but I probably need a JavaObjectWrapper to call functions

[02:05] <augustus> * I probably need to create a new object.  just guessing here

[02:07] *** Celelibi left
[02:12] *** raiph joined
[02:13] *** btyler left
[02:18] <raiph> augustus: aiui: nqp is a relatively small p6 subset (lang, compiler and runtime)

[02:18] <raiph> not a strict subset, but pretty close

[02:19] <raiph> rakudo is a full p6 (compiler and runtime) that is written in itself as far as possible and in nqp for most of the rest

[02:19] <augustus> raiph: unless I'm bootstrapping a new environment, I get the impression that I shouldn't have to use NQP directly

[02:19] <raiph> right

[02:20] *** benabik left
[02:20] <raiph> NQP is playing the role of C in perl5

[02:20] <augustus> right now I'm just trying to get a feel for how big of a challenge it will be to make some servlets (or similar) in perl6 and run them in Tomcat for example

[02:20] *** benabik joined
[02:21] <raiph> (one key advantage is that if you know P6, it's a lot easier to become a guts hacker)

[02:21] <augustus> yes, that seems nice

[02:21] <raiph> i think you're way early

[02:21] <diakopter> .. Larry's giving the SotO

[02:22] <diakopter> .. and they're not streaming it

[02:22] <diakopter> ........ and theyre not even recording it

[02:22] <diakopter> !!

[02:22] <raiph> that's bizarre

[02:23] <diakopter> well, I haven't seen a recording of it for 7 years

[02:23] <augustus> raiph: it seems like most of the hard bits are in place, but we're not to a point of having docs so if there's nobody online when I'm here, I'm left to dig around and guess and check ;)

[02:23] <raiph> augustus: yes. it's more extreme than usual too

[02:24] <raiph> cuz it's not even yet caught up with parrot

[02:24] <colomon> .tell jnthn … if gather / take on long lists is a problem, is it also affecting lines()?

[02:24] <yoleaux> colomon: I'll pass your message to jnthn.

[02:24] <raiph> augustus: and jnthn and sorear are the main guys to ask questions

[02:24] <raiph> and sorear has been away for a while

[02:25] <raiph> and jnthn is going away for a week

[02:26] <timotimo> diakopter: why isn't it like at a concert where every person holds up their phone and records?

[02:26] <augustus> well I'm certainly just fiddling around at this point

[02:26] *** jaldhar joined
[02:27] <augustus> well thanks everyone for the help, but it's closing time in these parts

[02:27] <timotimo> good night! :)

[02:27] *** augustus left
[02:28] <raiph> good night

[02:38] <raiph> diakopter: are you at oscon, or just in touch with folk in the room?

[02:40] *** colomon left
[02:42] *** PZt left
[03:00] *** lue joined
[03:17] *** fridim_ joined
[03:31] *** preflex left
[03:33] *** preflex joined
[03:33] *** ChanServ sets mode: +v preflex

[03:54] *** BenGoldberg left
[04:32] *** raiph left
[04:44] *** birdwindupbird joined
[04:47] *** xiaoyafeng joined
[04:47] *** crab2313 joined
[04:51] *** SamuraiJack joined
[04:51] *** xiaoyafeng left
[05:02] *** raiph joined
[05:04] *** cbk left
[05:45] *** hypolin joined
[05:51] <lizmat> good *, #perl6!

[05:52] <lizmat> jnthn: spectesting the var-traits branch, it seems to have broken "is dynamic"

[05:53] <lizmat> or alternately, "is dynamic" was a noop before, breaks now, and the tests in t/spec/S02-names/caller.t were bogus / are bogus now

[05:55] *** wtw joined
[05:58] <lizmat> also: "is TypeObject", e.g. as in "my %h is KeyBag", previously probably a noop, now breaks

[06:02] <lizmat> we seem to have an unspecced mention of "is context" in "t/spec/S03-binding/scalars.t", that previously appeared to pass

[06:04] <lizmat> "will start" now bombs, rather than being a noop

[06:05] *** hypolin left
[06:05] <lizmat> I guess this is generally for "will (phaser)"

[06:09] <lizmat> "is readonly" apparently is not specced as a variable trait, but is spectested as such in t/spec/S06-traits/is-readonly.t, and now bombs

[06:12] *** fridim_ left
[06:13] <lizmat> same applies for "is rw"

[06:13] *** iSlug joined
[06:14] <lizmat> This concludes my testing on the "var-traits" branch

[06:20] *** sqirrel joined
[06:22] *** raiph left
[06:26] *** raiph joined
[06:26] <lizmat> spectesting fixes for "is rw", "is readonly"

[06:30] *** raiph left
[06:32] *** FROGGS joined
[06:35] *** PZt joined
[06:36] *** vishal_ joined
[06:36] <vishal_> hii 

[06:37] <vishal_> whats new in perl .

[06:37] <vishal_> .6

[06:37] <lizmat> hi vishal_ , when was the last time you checked ?

[06:38] <vishal_> hi lizmat ...its my first time ....

[06:39] <lizmat> have you checked perl.org ?

[06:39] <lizmat> perl6.org rather

[06:40] <lizmat> if you're well versed in Perl 5, you might find http://perlgeek.de/en/article/5-to-6 an interesting read

[06:40] <vishal_> honestly speaking .. no 

[06:40] <vishal_> i chcked from other sites 

[06:41] *** cbk joined
[06:41] <vishal_> ok i 'll get through it .

[06:41] <FROGGS> vishal_: this might be a start too: http://en.wikipedia.org/wiki/Perl_6

[06:42] <vishal_> is it good to stick to perl .. and not to go after many languages ....

[06:42] <vishal_> just in regard to future prospect .

[06:42] <FROGGS> good question

[06:43] <lizmat> as we say in dutch: "We of WC-Duck recommend WC-Duck"

[06:43] <FROGGS> IMO you always benefit the more languages you know

[06:44] <dalek> rakudo/var-traits: c428a37 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[06:44] <dalek> rakudo/var-traits: Add "is readonly" and "is rw" traits on variables

[06:44] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/c428a378f8

[06:44] <lizmat> that was LHF

[06:44] <vishal_> guys i have started git too as a part of project ... @ rakudo 

[06:45] <vishal_> the link u share contains info. of git .....

[06:45] <lizmat> vishal_: you mean the link in the messages from dalek?

[06:46] <lizmat> those are simply references to changes to Perl 6 just made

[06:46] <FROGGS> vishal_: so a dev can review the commits of another, and everybody knows what's going on

[06:48] <vishal_> yes..

[06:51] <dalek> rakudo/var-traits: 7b901bd | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[06:51] <dalek> rakudo/var-traits: Add stubs for "is dynamic" and "is context", so at least they don't bomb like before

[06:51] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/7b901bd0b6

[06:58] <dalek> rakudo/var-traits: c73fd26 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[06:58] <dalek> rakudo/var-traits: Add "is TypeObject" and "of TypeObject" traits

[06:58] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/c73fd26a13

[07:02] <dalek> rakudo/var-traits: 17f6fe0 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[07:02] <dalek> rakudo/var-traits: Some code cosmetics and comments in variable traits

[07:02] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/17f6fe0490

[07:14] *** rindolf joined
[07:19] *** itz joined
[07:23] *** fhelmberger joined
[07:24] *** jlaire left
[07:25] *** kaleem joined
[07:25] *** jlaire joined
[07:26] *** domidumont joined
[07:28] <lizmat> breakfast&

[07:32] *** dayangkun joined
[07:32] *** dayangkun left
[07:37] <hoelzro> r: @*ARGS=('foo', '--type=value', 'bar') sub MAIN(*@args, *%kwargs) { say @args; say %kwargs; }

[07:37] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/zxdbCGbrsp:1␤------> [32m@*ARGS=('foo', '--type=value', 'bar') [33m⏏[31msub MAIN(*@args, *%kwargs) { say @args; [0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix…

[07:37] <hoelzro> =(

[07:37] <hoelzro> so, I think I found another bug with MAIN

[07:40] *** domidumont left
[07:40] *** domidumont joined
[07:43] *** rindolf left
[07:43] *** rindolf joined
[07:49] <lizmat> std: my $a will leave 42

[07:49] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/0Lp963n3G8 line 1:␤------> [32mmy $a will leave [33m⏏[31m42[0m␤Parse failed␤FAILED 00:00 42m␤»

[07:51] <dalek> rakudo/var-traits: f4b2ce4 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[07:51] <dalek> rakudo/var-traits: Stub phaser traits: alas, dispatch is not yet successful

[07:51] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/f4b2ce47d9

[07:52] *** xinming left
[07:53] *** xinming joined
[07:54] <lizmat> Is there a difference between "my Int $a", "my $a is Int" and "my $a of Int" ?

[07:55] <JimmyZ> I think Syn said it

[07:56] <GlitchMr> lizmat: Only 'my Int $a' works.

[07:57] <lizmat> well, currently, yes

[07:57] <GlitchMr> Two others are syntax errors.

[07:57] <GlitchMr> std: my $a is Int

[07:57] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[07:57] <GlitchMr> Or not

[07:57] <timotimo> hehe :)

[07:58] <GlitchMr> n: my $a is Int

[07:58] <camelia> niecza v24-88-g1f87209: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Trait name not available on variables at /tmp/HnYyj0a4bo line 1 (EOF):␤------> [32mmy $a is Int[33m⏏[31m<EOL>[0m␤␤Potential difficulties:␤  $a is declared but not used at /tmp/HnYyj0a4bo line 1:␤------> [32mmy [33m⏏[3…

[07:58] <JimmyZ> lizmat: search Container in S02

[07:58] <timotimo> can === cause "cannot look up attributes in a type object"?

[07:58] <GlitchMr> In Rakudo is/of means nothing.

[07:58] <GlitchMr> For simple scalar variables.

[07:58] <GlitchMr> In Niecza, it's an error.

[07:58] <GlitchMr> STD doesn't notice.

[07:58] <timotimo> r: class FooThing { has $.col; }; FooThing.new() === FooThing.new();

[07:58] <camelia> rakudo 117beb:  ( no output )

[07:59] <GlitchMr> "is" means the scalar itself is implemented by a class.

[08:00] <lizmat> ok, so "my Int $a" and "my $a of Int" is the same

[08:00] *** sqirrel left
[08:00] <timotimo> r: class FooThing { has @.foo; }; FooThing.new.foo.push(1)

[08:00] <camelia> rakudo 117beb:  ( no output )

[08:00] <GlitchMr> No

[08:00] <timotimo> ... huh

[08:00] <GlitchMr> Actually, let me check

[08:01] <lizmat> JimmyZ++

[08:02] * timotimo tries to modernize Druid

[08:02] *** rindolf left
[08:03] *** rindolf joined
[08:03] <GlitchMr> Actually, yes

[08:03] <GlitchMr> Sorry for confusion

[08:04] <JimmyZ> r: my Hash[Array] %book;

[08:04] <camelia> rakudo 117beb:  ( no output )

[08:07] *** daxim joined
[08:09] <dalek> rakudo/var-traits: fca7ef6 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[08:09] <dalek> rakudo/var-traits: Make variable "is" trait a stub again, it is not the same as "of"

[08:09] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/fca7ef6c83

[08:09] *** rindolf left
[08:09] <timotimo> apparently there once was a "defined"

[08:09] *** rindolf joined
[08:09] <timotimo> what's the modern equivalent? blah.defined, right?

[08:10] <GlitchMr> defined

[08:10] <GlitchMr> Or method

[08:10] <timotimo> # Looks like you failed 24 tests of 30

[08:10] <GlitchMr> rn: my Int $variable; say defined $variable; say $variable.defined;

[08:11] <camelia> rakudo 117beb, niecza v24-88-g1f87209: OUTPUT«False␤False␤»

[08:11] <GlitchMr> std: my Int $variable; say defined $variable; say $variable.defined;

[08:11] <camelia> std c2215f0: OUTPUT«ok 00:00 43m␤»

[08:11] <timotimo> r: my Int $var; say !defined $var;

[08:11] <camelia> rakudo 117beb: OUTPUT«True␤»

[08:11] <timotimo> huh?

[08:11] <GlitchMr> $var contains (Int), the class itself.

[08:11] <GlitchMr> So it isn't defined.

[08:12] <timotimo> right.

[08:12] *** bbkr joined
[08:12] *** bbkr left
[08:12] <timotimo> i was confused because i thought i had been getting an error from that syntax

[08:12] <timotimo> but that turns out not to be the case

[08:12] <GlitchMr> rn: say (9/7).new(7, 3)

[08:12] <camelia> rakudo 117beb, niecza v24-88-g1f87209: OUTPUT«2.333333␤»

[08:13] <GlitchMr> Interesting. I guess it's because instances of objects also have .new.

[08:13] <timotimo> an excellent way to not get the changes you expect is to forget make, but then use -Iblib/lib

[08:14] <arnsholt> timotimo: I do that with alarming frequency =)

[08:15] <GlitchMr> rn: say Date.new.new.new.new.new('2011-11-11')

[08:15] <camelia> niecza v24-88-g1f87209: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Date' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 36) ␤  at /home/p…

[08:15] <camelia> ..rakudo 117beb: OUTPUT«2011-11-11␤»

[08:17] <timotimo> aaaah, i get what caused the error

[08:17] <timotimo> it looked like ok defined foo, "some message"

[08:18] <timotimo> apparently the code at one point hoped for "defined" to not grab the "some message" as well

[08:19] <timotimo> r: use Test; my Int $a; ok !defined $a, "everything is okay";

[08:19] <camelia> rakudo 117beb: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling proto of 'defined' will never work with argument types (Int, Str) (lines 1, 1)␤    Expected: :(Mu )␤»

[08:19] <GlitchMr> The issue is that Perl 6 doesn't have prototypes (of course, you can use prefix:<defined>, but I don't think any builtin function does that).

[08:19] <timotimo> right

[08:19] <GlitchMr> Well, Perl 5 prototypes.

[08:21] <timotimo> yes

[08:21] <moritz> we had 'defined' as a prefix, and it was confusing as hell

[08:23] <timotimo> "result: PASS"

[08:23] *** rindolf left
[08:24] *** rindolf joined
[08:27] <dalek> rakudo/sized-arrays: cecbc1b | Arcterus++ | src/ (2 files):

[08:27] <dalek> rakudo/sized-arrays: Sized arrays now work for attributes

[08:27] <dalek> rakudo/sized-arrays: review: https://github.com/rakudo/rakudo/commit/cecbc1b757

[08:27] <dalek> rakudo/sized-arrays: 0ca221e | jonathan++ | src/ (2 files):

[08:27] <dalek> rakudo/sized-arrays: Merge pull request #185 from Arcterus/sized-arrays

[08:27] <dalek> rakudo/sized-arrays: 

[08:27] <dalek> rakudo/sized-arrays: Sized arrays now work for attributes

[08:27] <dalek> rakudo/sized-arrays: review: https://github.com/rakudo/rakudo/commit/0ca221e1d6

[08:27] *** cognominal__ left
[08:30] <timotimo> jnthn: good day :)

[08:31] <FROGGS> hi timotimo 

[08:31] <FROGGS> hi all

[08:32] <JimmyZ> hi

[08:32] <FROGGS> hi JimmyZ 

[08:32] <FROGGS> JimmyZ: what are your plan atm?

[08:33] <timotimo> heyo froggs

[08:33] <JimmyZ> FROGGS: waiting for bootstarp? I guess

[08:33] <JimmyZ> *bootstrap

[08:33] <FROGGS> yeah

[08:33] <FROGGS> that would be awesome

[08:34] <JimmyZ> the most blockers now are not that LHF

[08:34] <FROGGS> jnthn: if you can tell me something I could prepare/do for that to make it easier for you, please tell me :o)

[08:36] <FROGGS> I mean, there are still some ops missing (the ones without tests), but dont think they are immediately needed

[08:36] *** rindolf left
[08:37] *** rindolf joined
[08:37] *** ecocode joined
[08:44] *** kivutar joined
[08:49] *** rindolf left
[08:49] *** rindolf joined
[08:50] *** sqirrel joined
[08:53] <timotimo> oh wow!

[08:53] <timotimo> the text display for druid appears to be working again!

[08:53] <timotimo> the computer players like to build high, high towers it seems

[08:58] <jnthn> FROGGS: Well, one next step is getting the MAST nodes file to compile, and after that getting QAST -> MAST compiler also building on Moar

[08:58] <yoleaux> 02:24Z <colomon> jnthn: … if gather / take on long lists is a problem, is it also affecting lines()?

[09:00] *** rindolf left
[09:01] *** rindolf joined
[09:01] <FROGGS> jnthn: I'll look into that

[09:04] *** kivutar left
[09:05] <jnthn> yayz, vacation tomorrow

[09:05] <jnthn> lizmat: I suspect we'd find trait stuff missing all over teh place :)

[09:05] <FROGGS> :o)

[09:05] <jnthn> *suspected

[09:07] <jnthn> lizmat: I think is context and is dynamic may be "synonyms" (one is the old word for the other)

[09:08] <timotimo> well, there you have it: http://github.com/timo/druid/

[09:08] <jnthn> lizmat: Are all the var traits spec'd?

[09:11] *** SamuraiJack_ joined
[09:11] *** SamuraiJack left
[09:13] *** kivutar joined
[09:22] *** rindolf left
[09:22] *** rindolf joined
[09:23] <lizmat> jnthn: is context then probably is the older one, right?

[09:23] *** dmol joined
[09:23] <jnthn> lizmat: If it's not in spec, then I guess so...

[09:24] <lizmat> is context is not in the spec

[09:24] <jnthn> lizmat: Yeah, just searched and found the same...

[09:24] <jnthn> is dynamic is there

[09:24] <jnthn> And oes what I recall is context doing

[09:24] <lizmat> also, with regards to "of TypeObject"

[09:24] <jnthn> So I think "is dynamic" is the current name for that

[09:24] <lizmat> wouldn't that be as simple as doing TypeObject.new into the value of the variable ?

[09:25] <jnthn> Note .new

[09:25] <jnthn> *not

[09:25] <jnthn> It's also about setting the constraint I guess

[09:25] *** wk joined
[09:25] <jnthn> Needs .set_of or so, and then I guess set the value and perhaps default too.

[09:26] <jnthn> my $x of Int; should come out working like my Int $x;

[09:26] *** wk is now known as Guest50868

[09:28] <lizmat> I think we just established earlier todat that "my Int $x of Foo" is specced and not the same as my Foo $x;

[09:28] * jnthn does wonder a little if is and of should be handled specially inside the Actions...

[09:28] <jnthn> my Int $x of Foo should probably be an error.

[09:28] <jnthn> std: my Int $x of Foo;

[09:28] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid type name at /tmp/ZaBXEa5klx line 1:␤------> [32mmy Int $x of [33m⏏[31mFoo;[0m␤    expecting typename␤Parse failed␤FAILED 00:00 42m␤»

[09:28] <jnthn> std: my Int $x of Num;

[09:28] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Extra 'of' type; already declared as type Int at /tmp/FFqQAwo39x line 1:␤------> [32mmy Int $x of Num[33m⏏[31m;[0m␤Check failed␤FAILED 00:00 42m␤»

[09:28] <jnthn> Like that.

[09:29] <jnthn> They're saying the same thing.

[09:29] <dalek> rakudo/var-traits: 624a6e7 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[09:29] <dalek> rakudo/var-traits: "is context" is old for "is dynamic", so we don't need it

[09:29] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/624a6e7a37

[09:29] <jnthn> The other interesting one is "is"

[09:29] <JimmyZ> std: Class Foo {}; my Int $x of Foo;

[09:29] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/bgM9RJxqSV line 1:␤------> [32mClass [33m⏏[31mFoo {}; my Int $x of Foo;[0m␤    expecting any of:␤     feed_separator␤ infix or meta-infix␤    infixed function␤       statement modifier loop␤Parse failed␤FAILED 00:00

[09:29] <camelia> ..43…

[09:30] <timotimo> that depends on what your definition of 'is' is, jnthn 

[09:30] <jnthn> my int32 @x of Buf # probably wants to work...

[09:30] <jnthn> darnit

[09:30] <jnthn> my int32 @x is Buf # probably wants to work...

[09:30] <jnthn> Which is like

[09:30] <lizmat> S02:487

[09:30] <synopsebot> Link: http://perlcabal.org/syn/S02.html#line_487

[09:30] <jnthn> my @x is Buf of int32; # though I guess that may parse differently... 

[09:31] <jnthn> Yes, the spec seems to be agreeing with what I just said :)

[09:31] <jnthn> of means "what can we store in this container type"

[09:31] <jnthn> is means "what type of container is it"

[09:32] <jnthn> timotimo: It is what it is... :P

[09:32] <lizmat> of course

[09:32] <lizmat> .oO( what a nice name for a variable trait: "of course" )

[09:33] <jnthn> Anyway, I'm open to "is Type" and "of Type" being treated specially in Actions rather than being actual trait dispatches...

[09:34] <moritz> until somebody creates a class rw { } :-)

[09:34] <jnthn> :P

[09:34] <jnthn> yeah

[09:34] <jnthn> I'm fine with trying to figure out how to really implement them as traits too

[09:35] <jnthn> But if we do that, there will certainly be an ordering dependency.

[09:35] <jnthn> my $x is readonly is SomeOtherThing; # oops, set readonly too early

[09:35] <jnthn> That may work out depending how we do it, I guess...

[09:36] * jnthn guesses he should be wary of cheating, since cheating normally gets caught... :)

[09:36] <lizmat> why would order matter here, I mean they work on the same containerdescriptor?

[09:37] <lizmat> or do you mean the readonly will stop further changes to the variable?

[09:37] <jnthn> I guess it works in that case in so far as we can migrate the container descriptor to the new container type

[09:38] <jnthn> The tricky one really is "is"

[09:38] <jnthn> Because it's not tweaking, it's an entire replacement

[09:41] <lizmat> ok

[09:42] *** pmurias joined
[09:44] *** rindolf left
[09:44] *** rindolf joined
[09:44] *** rindolf left
[09:46] <lizmat> what's this syntax about ? "@$+arrayref"

[09:46] <lizmat> with "my $arrayref is dynamic = list(1,2,3);" before it

[09:46] *** crab2313 left
[09:47] <jnthn> o.O

[09:47] <jnthn> I have NO idea!!

[09:48] <lizmat> test was being marked for "is dynamic",  but was in fact testing @$+ syntax

[09:48] <jnthn> std: my $arrayref is dynamic = list(1,2,3); say @$+arrayref

[09:48] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name at /tmp/CYosDEEgBl line 1:␤------> [32m$arrayref is dynamic = list(1,2,3); say [33m⏏[31m@$+arrayref[0m␤Use of uninitialized value $first in string eq at STD.pm line 66215.␤Use of uninitializ…

[09:48] <lizmat> that's the error I get

[09:48] <jnthn> lizmat: I wonder if it's meant to be @$*arrayref, which is what would make sense given the "is dynamic"...

[09:49] <lizmat> ah, ok, maybe a leftover from the "is context" days

[09:49] <jnthn> perhaps

[09:49] <lizmat> std: my $arrayref is dynamic = list(1,2,3); say @$*arrayref

[09:49] <camelia> std c2215f0: OUTPUT«ok 00:00 45m␤»

[09:51] *** SamuraiJack__ joined
[09:52] <lizmat> tests pass if I change to @$*, so I assume that is what we want to test

[09:54] <jnthn> :)

[09:55] <lizmat> last test in t/spec/S04-statements/lift.t still fails

[09:55] *** SamuraiJack_ left
[09:55] <lizmat> this in conjunction with "lift"

[09:55] <lizmat> maybe "is context" *was* already working as it should?

[09:56] <jnthn> We don't implement lift, so I'd be very surprised if that test works... :)

[09:56] <lizmat> std: my $a is context

[09:56] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[09:56] <lizmat> std: my $a is foo

[09:56] <camelia> std c2215f0: OUTPUT«ok 00:00 42m␤»

[09:57] <lizmat> I guess the "eval_dies_ok" was failing for the wrong reason, and the change now but the breakage outside of the eval

[09:57] <lizmat> I'll put a skip around it

[09:58] <lizmat> shall I create a branch for these test fixes?

[09:58] <jnthn> lizmat: To merge when var-traits merges? Sounds sane.

[09:58] <lizmat> the only blocker I really see at the moment is "will leave BLOCK" not finding the trait mod

[09:59] <lizmat> and thus dieing (whereas it was silently failing before)

[09:59] <jnthn> Why can't we add a trait mod for it?

[09:59] <lizmat> multi trait_mod:<will>(Variable:D $v, Block:D :$begin ) {

[09:59] <lizmat> is what I have so far

[09:59] <lizmat> it won't find it

[09:59] *** pmurias_ joined
[09:59] <jnthn> That needs to be a required named arg

[10:00] <jnthn> As they are optional by default

[10:00] <jnthn> :$leave! should do it

[10:00] <lizmat> grrr

[10:00] <lizmat> lemme check

[10:00] <pmurias> jnthn: in nqp is it possible to declare a contextual without binding any value to it? (for testing purposes)

[10:01] <pmurias> that is avid my $*FOO binding a NQPMu to $*FOO?

[10:01] <jnthn> pmurias: Well, what are you expecting it to have?

[10:01] <lizmat> so, wrt to "will": I guess we need to create a closure with $_ being aliased to the variable, and add that to the appropriate phaser

[10:01] <jnthn> pmurias: You can always := nqp::null() I guess

[10:01] <jnthn> lizmat: I was trying to work out how to do those. It's really tricky.

[10:02] <jnthn> lizmat: Because of course there are gonna be *many* variables.

[10:02] <jnthn> lizmat: Oh, maybe it's OK though...'cus the block is in the right place....

[10:02] <jnthn> hmmm

[10:02] <jnthn> lizmat: The problem is how to get the variable passed into the block as its topic I guess.

[10:02] <lizmat> if you need better optimization, create a single phaser

[10:03] <lizmat> yes, that's one of the things I don't see right now

[10:03] <lizmat> the second one is adding the phaser: or is that as easy as doing Block.add_phaser?

[10:03] <jnthn> There's probably a decent solution, I just don't immediately have it.

[10:03] <jnthn> That second bit is easy enough, in theory

[10:04] <lizmat> let's start by adding the phaser

[10:04] <lizmat> I can fiddle with the rest next week

[10:04] *** pmurias_ left
[10:04] <jnthn> OK. I suspect it shall be non-trivial...

[10:04] <lizmat> adding the phaser?

[10:04] <jnthn> No, the other bit :)

[10:05] <lizmat> $ perl6 -e 'my $a will leave { .say }=42'

[10:05] <lizmat> ===SORRY!===

[10:05] <lizmat> Cannot call 'trait_mod:<will>'; none of these signatures match:

[10:05] <lizmat> :(Variable:D $v, Block:D :leave(:$leave)!)

[10:07] <jnthn> odd

[10:07] <jnthn> r: class A { has $!x will build { 42 } }

[10:07] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot call 'trait_mod:<will>'; none of these signatures match:␤:(Attribute $attr, Block :build(:$build)!)␤at /tmp/013PAOuwQz:1␤------> ␤»

[10:08] <jnthn> d'oh, that one doesn't work either...

[10:08] <jnthn> lizmat: Does trying Code instead of Block help?

[10:08] <lizmat> lemme check

[10:08] <jnthn> If so then (a) fine, maybe, and (b) something may have bitrat

[10:13] <lizmat> nope, same error, differen list of candidates

[10:13] <lizmat> s/Block/Code/

[10:13] *** colomon joined
[10:13] <lizmat> maybe it fails on the Variable:D match ?

[10:14] <jnthn> That'd be odd given the other traits work with that

[10:14] <jnthn> lizmat: Maybe take the second constraint off and see what you get passed?

[10:14] <lizmat> was just thinking that, checking

[10:18] <dalek> rakudo/sized-arrays: 1a8914a | Arcterus++ | src/Perl6/World.nqp:

[10:18] <dalek> rakudo/sized-arrays: Allow different values for attribute sizes

[10:18] <dalek> rakudo/sized-arrays: review: https://github.com/rakudo/rakudo/commit/1a8914ab72

[10:18] <dalek> rakudo/sized-arrays: 37246ac | jonathan++ | src/Perl6/World.nqp:

[10:18] <dalek> rakudo/sized-arrays: Merge pull request #186 from Arcterus/sized-arrays

[10:18] <dalek> rakudo/sized-arrays: 

[10:18] <dalek> rakudo/sized-arrays: Allow different values for attribute sizes

[10:18] <dalek> rakudo/sized-arrays: review: https://github.com/rakudo/rakudo/commit/37246ace82

[10:19] <lizmat> jnthn: even without constraint, it is not finding the traitmod

[10:20] <jnthn> lizmat: ohh

[10:21] <lizmat> is Perls/Actions, line 3634 correct ?

[10:21] <lizmat> Perl6

[10:21] <jnthn> yeah, that's what I was just looking at

[10:21] <jnthn> It calls it as trait_mod:<will>($declarand, $block, :leave) for example

[10:22] <jnthn> So that's why the dispatch fails

[10:22] <lizmat> it should be :leave($block) ?

[10:28] <jnthn> Good question... :)

[10:28] <timotimo> shouldn't it be :$leave?

[10:28] <timotimo> or that, yeha

[10:28] <jnthn> Well, the correct signature is

[10:28] <jnthn> multi trait_mod:<will>(Attribute:D $attr, $block, :$build!) { ... }

[10:28] <jnthn> for example

[10:29] <timotimo> "will build"?

[10:29] <jnthn> We could change the way we dispatch to trait_mod:sym<will> if the spec doesn't say one way or the other, I guess...

[10:29] <jnthn> timotimo: yes, it exists :)

[10:30] * timotimo reads spec

[10:30] *** cognominal joined
[10:30] <timotimo> cannot be found with google >_>

[10:35] *** cognominal left
[10:38] <lizmat> jnthn: apparently, doing .set_of on the ContainerDescriptor, is not enough to make it "stick" like specifying it with a type object as prefix

[10:38] <lizmat> aka: my Int $x, works, my $x of Int doesn't quite

[10:39] <jnthn> lizmat: "stick"?

[10:39] <lizmat> $ perl6 -e 'my $x of Int = 42'

[10:39] <lizmat> Type check failed in assignment to '$x'; expected 'Int' but got 'Int'

[10:39] <jnthn> lizmat: Missing nqp::decont somewhere, maybe

[10:39] <lizmat> trying

[10:44] <lizmat> indeed, missing decont

[10:46] *** colomon left
[10:46] <timotimo> àu contâiner

[10:47] <jnthn> :P

[10:47] <dalek> rakudo/var-traits: 9057f2d | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[10:47] <dalek> rakudo/var-traits: Make "will phaser {]' parameter mandatory

[10:47] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/9057f2da1d

[10:47] <dalek> rakudo/var-traits: 68ece49 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[10:47] <dalek> rakudo/var-traits: Make sure we decont the "of" so that it works, suggested by jnthn++

[10:47] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/68ece4978c

[10:47] <timotimo> oh god no mismatching braces

[10:48] <jnthn> omg...the world will end!

[10:48] <lizmat> oops

[10:48] <lizmat> what now? 

[10:48] *** Celelibi joined
[10:49] <jnthn> "will phaser {]'

[10:49] <jnthn> mismatched brackets AND quotes :P

[10:49] <lizmat> what can I say, I like to break things :-)

[10:50] <jnthn> ;-)

[10:50] <lizmat> and occasionally forget to press the shift key  :-)

[10:57] *** kivutar left
[10:58] <lizmat> hmmm….. "of" still has another problem:

[10:58] <lizmat> $ perl6 -e 'my %h of Int'

[10:58] <lizmat> ===SORRY!===

[10:58] <lizmat> Can not get attribute '$!descriptor' declared in class 'Scalar' with this object

[10:59] <jnthn> What's your of impl look like?

[10:59] <lizmat> nqp::getattr($v.var, $v.VAR.WHAT, '$!descriptor').set_of(nqp::decont($of));

[10:59] <jnthn> huh...

[10:59] <lizmat> I guess it needs to check for "meta" containers as hashes and arrays ?

[11:00] <jnthn> um, did you mean $v.var.VAR.WHAT?

[11:00] <jnthn> But yeah, probably...

[11:00] <lizmat> the line was really cat-licensed from your "is default: implementation

[11:00] <lizmat> .oO( oops, I did it again)

[11:01] <jnthn> I can't get everything right :P

[11:02] <jnthn> But yeah, is default will be wrong also then :)

[11:02] *** xenoterracide joined
[11:03] <lizmat> seems to work for single containers

[11:03] <lizmat> $ perl6 -e 'my $a is default(42); say $a'

[11:03] <lizmat> 42

[11:04] <lizmat> but indeed equally wrong for meta-containers:

[11:04] <lizmat> $ perl6 -e 'my @a is default(42)'

[11:04] <lizmat> ===SORRY!===

[11:04] <lizmat> Can not get attribute '$!descriptor' declared in class 'Scalar' with this object

[11:04] <jnthn> Right.

[11:05] <lizmat> will do some tests

[11:06] <dalek> rakudo-js: 3acc37a | (Pawel Murias)++ | runtime/ctx.js:

[11:06] <dalek> rakudo-js: Stop silently ignoring failed lookups and binds.

[11:06] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/3acc37a7fd

[11:06] <dalek> rakudo-js: 0fa2ec8 | (Pawel Murias)++ | / (3 files):

[11:06] <dalek> rakudo-js: Implement qastnode. Marke lexicals that are not explicitly bound to anything in the Ctx so that contextual lookup works correctly.

[11:06] <dalek> rakudo-js: 

[11:06] <dalek> rakudo-js: Pass test 34-rxcodeblock.t

[11:06] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/0fa2ec8ef1

[11:06] <jnthn> pmurias++

[11:09] *** mtk left
[11:09] *** jaldhar left
[11:12] *** mtk joined
[11:16] <lizmat> is default with $v.var.VAR.WHAT gives:

[11:16] <lizmat> $ perl6 -e 'my @a is default(42)'

[11:16] <lizmat> This type does not support elems

[11:17] *** colomon joined
[11:23] *** vishal_ left
[11:24] <lizmat> r: my @a:=42 # LTA error message ?

[11:24] <camelia> rakudo 117beb: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Int'␤  in block  at /tmp/QqFNGBXo9Y:1␤␤»

[11:26] <timotimo> r: my @old = "hello".comb; push @old, ' ' xx (15 - +@old); say @old;

[11:26] <camelia> rakudo 117beb: OUTPUT«h e l l o                    ␤»

[11:27] * timotimo clears up "RAKUDO: " naggings from druid

[11:27] <timotimo> rakudo surely has come a long way those four years

[11:28] <timotimo> r: my $subname = "foobar"; say "sub foobar" ~~ / 'sub ' $subname /

[11:28] <camelia> rakudo 117beb: OUTPUT«｢sub foobar｣␤␤»

[11:29] <dalek> rakudo/var-traits: 5204a3f | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[11:29] <dalek> rakudo/var-traits: Added additional dereference, as suggested by jnthn++

[11:29] <dalek> rakudo/var-traits: 

[11:29] <dalek> rakudo/var-traits: It doesn't break anything new, and makes some other errors messags more sane.

[11:29] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/5204a3f71c

[11:29] *** colomon left
[11:31] <FROGGS> nqp: say(nqp::objprimspec(42))

[11:31] <camelia> nqp: OUTPUT«0␤»

[11:31] <FROGGS> nqp-jvm: say(nqp::objprimspec(42))

[11:31] <camelia> nqp-jvm: OUTPUT«1␤»

[11:32] <lizmat> jnthn: looks like MetaModel::ArrayType only has a "array_type" attribute

[11:33] <jnthn> lizmat: ?

[11:33] <jnthn> lizmat: Why are you looking at that?

[11:33] <lizmat> well, to get "my @a is Int" to work

[11:33] *** crab2313 joined
[11:33] <jnthn> Ah

[11:33] <lizmat> well, to get "my @a of Int" rather

[11:33] <jnthn> That's something completely different :)

[11:33] <lizmat> sorry, I meant "my @a of Int"

[11:34] <lizmat> $ perl6 -e 'my @a of Int; say @a[0]'

[11:34] <lizmat> (Any)

[11:35] <lizmat> r: my Int @a; say @a[0]

[11:35] <camelia> rakudo 117beb: OUTPUT«(Int)␤»

[11:35] *** sqirrel left
[11:35] <jnthn> Yeah, best I can suggest is looking at how %container_info gets populated when it sets that stuff up

[11:36] <lizmat> ok, will do

[11:37] <lizmat> fwiw: I'm completely blocked on "will phaser {}"

[11:38] <lizmat> but I think we can merge the branch

[11:38] <lizmat> and unfudge some passing TODO's, and changes some "todo"s into "skip"s

[11:39] <jnthn> You managed to fix the trait signatures, though?

[11:41] <lizmat> you mean: $ perl6 -e 'my $a will leave { .say }'

[11:41] <lizmat> ===SORRY!===

[11:41] <lizmat> Cannot call 'trait_mod:<will>'; none of these signatures match:

[11:41] <lizmat> no

[11:41] <lizmat> :-(

[11:41] <jnthn> What did you change it to?

[11:41] <lizmat> back to Block, as Code or no constraint did not fix the problem

[11:41] <jnthn> oh, you didn't do the 3-arg way I said?

[11:42] <lizmat> did I miss something ?

[11:42] <lizmat> you mean in Actions?

[11:42] *** sqirrel joined
[11:42] <jnthn>  < jnthn> multi trait_mod:<will>(Attribute:D $attr, $block, :$build!) {

[11:42] <jnthn> Or Variable and :$leave! in your case.

[11:42] <lizmat> missed that  :-(

[11:43] <lizmat> will do now

[11:43] <jnthn> ah :)

[11:46] <lizmat> with regards to adding the phaser, I assume some call to Block.add_phaser () ?

[11:46] *** jaldhar joined
[11:46] <lizmat> for the block typy things ?

[11:46] <jnthn> Yeah

[11:46] <jnthn> You need to add it to the scope where the variable is being declared

[11:47] <jnthn> Which *should* be something like $var.block.add_phaser('LEAVE', $block) or so

[11:47] <lizmat> and how do I look up that scope?  &?BLOCK ?

[11:47] <lizmat> okidoki, will try

[11:47] <jnthn> No, it's meant to be supplied by the Variable instance you get

[11:47] <jnthn> I never tried it, but I put in code that should do it.

[11:47] <lizmat> will see

[11:48] <lizmat> signature dispatches now

[11:48] <jnthn> yay

[11:48] <FROGGS> jnthn: in nqp/parrot, smo_id is short for six model object... ?

[11:49] <dalek> rakudo/var-traits: a593d80 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[11:49] <dalek> rakudo/var-traits: Correct signature for "will phaser {}" dispatches, suggested by jnthn++

[11:49] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/a593d80469

[11:49] *** jaldhar left
[11:49] <jnthn> FROGGS: type ID

[11:49] <jnthn> FROGGS: Parrot gives all dynpmcs a unique ID

[11:49] <jnthn> FROGGS: So really any mention of it means "is this a 6model object"

[11:49] *** jaldhar joined
[11:49] <FROGGS> k

[11:49] <jnthn> FROGGS: Over on JVM, eveyrthing is one...on Parrot we have a frothy mix :)

[11:50] <FROGGS> yeah, right

[11:52] *** colomon joined
[11:54] <lizmat> working almost: $ perl6 -e 'my $a will leave { say $a }'

[11:54] <lizmat> ===SORRY!===

[11:54] <lizmat> Variable '$a' is not declared

[11:55] <lizmat> $ perl6 -e 'my $a will leave { say "Goodbye" }'

[11:55] <lizmat> Goodbye

[11:55] <lizmat> I guess the first can be fixed by having $_ aliased to the variable

[11:57] <jnthn> The first looks...tricky

[11:57] <jnthn> std: my $a will leave { say $a }

[11:57] <camelia> std c2215f0: OUTPUT«ok 00:00 44m␤»

[11:58] <jnthn> Hm

[11:58] <jnthn> Wonder how STD does it

[11:58] <jnthn> We register variables a little too late, it seems...

[12:00] <lizmat> maybe the mod_trait should pre-register the variable?

[12:00] <lizmat> traiit_mod

[12:01] <lizmat> .oO( shouldn't get up at 6:30 )

[12:03] <jnthn> No, I suspect it goes deeper than that :/

[12:10] <lizmat> I guess aliasing the variable to $_ will have the same probem?

[12:11] <lizmat> problem

[12:11] *** fridim_ joined
[12:12] <jnthn> There's a rather tricky compile time (when the trait applies) / runtime boundary issue here.

[12:12] <jnthn> I'll have to think for a bit how to solve it.

[12:12] <jnthn> It may need some kind of custom op...

[12:12] *** Celelibi left
[12:12] <lizmat> well, some of these now work

[12:12] <lizmat> which is a hell of a lot more than before

[12:13] *** bluescreen10 left
[12:13] <lizmat> and the syntax doesn't bomb anymore

[12:13] *** Celelibi joined
[12:13] *** skids left
[12:13] <jnthn> aye

[12:14] <dalek> rakudo/var-traits: 4856368 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[12:14] <dalek> rakudo/var-traits: First sort of functional phasers implementation with "will" variable trait

[12:14] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/4856368b68

[12:14] <lizmat> $ perl6 -e 'my $a will leave { say "Goodbye" }'

[12:14] <lizmat> Goodbye

[12:16] <lizmat> $ perl6 -e 'my $a will pre { say "Hello" }'

[12:16] <lizmat> Hello

[12:16] <moritz> \o/

[12:17] <lizmat> moritz!

[12:17] <moritz> lizmat!

[12:19] *** kivutar joined
[12:20] <dalek> roast: 2d48e36 | (Elizabeth Mattijsen)++ | S0 (3 files):

[12:20] <dalek> roast: Fix tests relating to "is context", which apparently now is "is dynamic"

[12:20] <dalek> roast: review: https://github.com/perl6/roast/commit/2d48e36257

[12:20] <moritz> and...

[12:20] <moritz> features!

[12:20] <lizmat> need to have some new things for next months changelog!

[12:21] <jnthn> Aye :)

[12:22] <jnthn> We Blob/Buf and related improvements also for this one :)

[12:23] *** PacoLinux joined
[12:25] <lizmat> S04:1457, shouldn't that be "will first" ?

[12:25] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1457

[12:26] <lizmat> there is no START phaser, is there ?

[12:26] <gfldex> r: say Array ~~ Positional; subset Foo of Int|Str; sub s(Foo @foos){}; my Foo @a = 1, 'a'; s(@a);

[12:26] <camelia> rakudo 117beb: OUTPUT«True␤Constraint type check failed for parameter '@foos'␤  in sub s at /tmp/TNqMfsEC9x:1␤  in block  at /tmp/TNqMfsEC9x:1␤␤»

[12:27] <gfldex> huh?

[12:27] <gfldex> r: say Array ~~ Positional; subset Foo of Int|Str; sub s(Foo @foos){}; my @a = 1, 'a'; s(@a);

[12:27] <camelia> rakudo 117beb: OUTPUT«True␤Nominal type check failed for parameter '@foos'; expected Positional but got Array instead␤  in sub s at /tmp/80tIdRmhAN:1␤  in block  at /tmp/80tIdRmhAN:1␤␤»

[12:27] *** dmol left
[12:27] <lizmat> Int|Str maybe coerced into an Array?

[12:28] *** Celelibi left
[12:28] <gfldex> What i want to do is to have a typed list of Int|Str. jnthn told me to have it as a subset. However, I fail to convince rakudo to accept it as a type constrain in a signature.

[12:29] *** Celelibi joined
[12:29] <gfldex> is there any spec test on subsets as type constrain in a signature?

[12:29] * gfldex goes have a look himself

[12:29] *** xinming left
[12:30] *** dmol joined
[12:33] <lizmat> apparently "is start" seems reserved for state variables

[12:33] *** xinming joined
[12:33] <moritz> gfldex: any reason not use Cool instead of Int|Str?

[12:33] *** sqirrel left
[12:33] *** daniel-s_ joined
[12:33] <moritz> I mean, what about Rat, Num and all other similar types?

[12:33] <gfldex> it's just some random types

[12:34] <moritz> r: subset Foo of Cool where Int|Str; sub f(Foo) { }; f(42); f([])

[12:34] <camelia> rakudo 117beb: OUTPUT«Constraint type check failed for parameter ''␤  in sub f at /tmp/KQQeYm92q9:1␤  in block  at /tmp/KQQeYm92q9:1␤␤»

[12:34] <gfldex> I actually have something reasonable (i hope) where it doesnt work. Little big that stuff for golfing.

[12:35] <moritz> gfldex: 'subset Foo of Int|Str' doesn't do what you want. 'subset Foo of <common base typ> where <contraint>' is what you need

[12:36] *** dmol left
[12:40] <gfldex> r: https://gist.github.com/gfldex/6088554

[12:40] <camelia> rakudo 117beb: OUTPUT«Nominal type check failed for parameter '@nodes'; expected Positional but got Array instead␤  in sub html at /tmp/K5pRZNM9QU:11␤  in block  at /tmp/K5pRZNM9QU:15␤␤»

[12:41] <gfldex> moritz: doesn't work for me either. Could you have a look at my gist?

[12:42] <dalek> rakudo/var-traits: 5622d4a | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[12:42] <dalek> rakudo/var-traits: Add provisional "will start" state variable trait

[12:42] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/5622d4affd

[12:42] <timotimo> that doesn't do what you want to; it'd only work if you have my HTML-nodes @foo and pass that

[12:42] <moritz> gfldex: the problem is that what you pass in is just a plain Array

[12:42] <moritz> gfldex: not an Array[HTML-nodes]

[12:42] <moritz> so, best not to use typed arrays at all for now

[12:43] <lizmat> moritz?  isn't that not eating our own dogfood?

[12:43] <pmurias> jnthn: would it be ok if I refactored out the code that serializes the sc into a seperate method?

[12:44] <pmurias> jnthn: that would allow me to monkey patch my serialization "caching" hack in without copy&paste

[12:44] <jnthn> pmurias: sounds ok to me

[12:45] <lizmat> jnthn: the Variable.$.block attribute: is that intend for "will start" ?

[12:45] *** dmol joined
[12:45] <jnthn> If you're going to use typed arrays, you simply have to pass an array declared with a type in the first place.

[12:45] <jnthn> It doesn't enforce it by checking all the elements of a (potentially lazy) thing, but by the declared type.

[12:46] <jnthn> lizmat: It's intended to let you get at the block where the variable is being declared.

[12:46] <lizmat> ah, ok

[12:46] <timotimo> r: my Int @foo := gather { take 1; take 2; take 3; take "oh god no!" }; say @foo[^2]; say "alive!"; say @foo[^10]; say "hopefully not alive?"

[12:46] <camelia> rakudo 117beb: OUTPUT«Type check failed in binding; expected 'Positional' but got 'List'␤  in block  at /tmp/0kHkC7NbQ_:1␤␤»

[12:46] <gfldex> jnthn: so a slurpy types array will never work in perl6?

[12:46] <timotimo> hmm.

[12:47] <timotimo> gfldex: i once proposed to have rakudo throw an error, but people warned me it might have ecosystem fallout

[12:47] <timotimo> r: sub foo(Int *@a) { say @a }; foo(1, 2, 3);

[12:47] <camelia> rakudo 117beb: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Array instead␤  in sub foo at /tmp/fIpfy_LAsw:1␤  in block  at /tmp/fIpfy_LAsw:1␤␤»

[12:47] <timotimo> right. i wanted to replace that with a specific error message

[12:48] <timotimo> https://github.com/timo/rakudo/compare/fail_typed_slurpy_early

[12:51] <gfldex> i would welcome such an error message

[12:51] <timotimo> sign the petition ;)

[12:51] *** PacoLinux left
[12:51] <moritz> gfldex: lists in general have the problem that they can be infinite, so you aren't allow to reify them to check the types of the contents

[12:52] *** PacoLinux joined
[12:52] *** sqirrel joined
[12:52] <moritz> either we need to find a good solution, or forbid typed arrays (except for primitive types)

[12:53] <timotimo> native arrays can't be infinite?

[12:53] <pmurias> what's the idiomatic way of returning two values from a method in nqp?

[12:54] <pmurias> [$first,$second]? and my $ret = ...;$first = $ret[0];$second = $ret[1] on the caller side?

[12:56] <gfldex> moritz: infinite lists come from a generator function with a gather/take. Would it not be possible to have a proper return type on the function and take check for that type?

[12:56] <JimmyZ> my ($1, $2) = $ret?

[12:57] *** dmol left
[12:57] <FROGGS> JimmyZ: not in nqp

[12:58] <jnthn> pmurias: That's about as good as you get

[13:00] <timotimo> gfldex: not really a generator function per se; sometimes it's not even a block

[13:00] <moritz> gfldex: infinite lists also come from the series operator, .map on inifinte ranges etc.

[13:00] <moritz> gfldex: and in some of these cases the error message would come from inside a core function, not from use-space code

[13:00] <moritz> that would be very, very weird

[13:00] * pmurias hopes when he actually gets to use full Perl 6 he won't be stuck in using the NQP subset ;)

[13:06] *** dmol joined
[13:16] *** dayangkun joined
[13:18] *** sqirrel left
[13:18] *** sqirrel joined
[13:20] <FROGGS> are these tests supposed to fail? t/spec/S03-operators/set.rakudo.parrot  and  t/spec/S06-other/main-usage.rakudo.parrot?

[13:22] <lizmat> not sure

[13:22] <FROGGS> hmmm, main-usage passes when I run it separately

[13:22] *** dmol left
[13:22] <lizmat> could it be that these are awaiting the var-traits branch merge ?

[13:23] *** dmol joined
[13:23] <gfldex> r: subset Foo of Cool where Int|Str; my Foo @a; say @a ~~ Foo;

[13:23] <camelia> rakudo 117beb: OUTPUT«False␤»

[13:23] <gfldex> bug?

[13:24] <FROGGS> lizmat: dunno about the set fails, but if it works when running directly it cant be because of newly added stuff

[13:24] *** PacoLinux left
[13:25] <colomon> gfldex: no, @a is an Array, not a Foo

[13:25] <moritz> gfldex: why would it be a bug?

[13:26] <gfldex> if i tell it to be a Foo with my Foo @a; I assume it would be a Foo

[13:26] <dalek> nqp: 1541771 | (Tobias Leich)++ | / (2 files):

[13:26] <dalek> nqp: fixed nqp::objprimspec

[13:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/154177153a

[13:26] <FROGGS> r: say my Int @a ~~ Int

[13:26] <camelia> rakudo 117beb: OUTPUT«False␤»

[13:26] <FROGGS> r: say my Int @a ~~ Array

[13:26] <camelia> rakudo 117beb: OUTPUT«True␤»

[13:26] <FROGGS> r: say my Int @a ~~ Array # <---- an array where there elements are Ints

[13:26] <camelia> rakudo 117beb: OUTPUT«True␤»

[13:27] <dalek> rakudo/var-traits: 367739f | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[13:27] <dalek> rakudo/var-traits: Make "my $a will foo" die with a more awesome error message

[13:27] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/367739fa6b

[13:27] *** jaldhar left
[13:27] <lizmat> $ perl6 -e 'my $a will foo {}'

[13:27] <lizmat> ===SORRY!===

[13:27] <lizmat> You can not 'will foo' on a variable

[13:28] * FROGGS .oO( "You shall not want foo on a variable!" )

[13:28] *** stevan_ joined
[13:28] <jnthn> lizmat: Hm, that looks unlike the normal trait mod dispatch errors?

[13:28] <lizmat> $ perl6 -e 'my $a will foo {}'

[13:28] <lizmat> ===SORRY!===

[13:28] <lizmat> Cannot call 'trait_mod:<will>'; none of these signatures match:

[13:28] <lizmat> :(Attribute $attr, Block :build(:$build)!)

[13:28] <lizmat> :(Variable:D $v, $block, @*huh)

[13:28] <lizmat> :(Variable:D $v, $block, :begin(:$begin)!)

[13:29] <lizmat> plus long list is what you would normally get on "will foo".  I found that LTA

[13:29] <gfldex> r: subset Foo of Cool where Int|Str; sub s(Foo @f){}; my Foo @a; s(@a); # why does that fails?

[13:29] <camelia> rakudo 117beb: OUTPUT«Constraint type check failed for parameter '@f'␤  in sub s at /tmp/Emyw_2MsdA:1␤  in block  at /tmp/Emyw_2MsdA:1␤␤»

[13:29] <jnthn> Yes, but hiding the list of options is LTA too...

[13:29] <dalek> nqp: ff5be6e | (Pawel Murias)++ | src/vm/parrot/QAST/Compiler.nqp:

[13:29] <dalek> nqp: Factor out the serialization into a seperate method for easier overriding.

[13:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ff5be6e074

[13:29] <lizmat> ah, ok, in that sense

[13:30] <jnthn> lizmat: Some combination of the two may we nice.

[13:30] <lizmat> yes, indeed

[13:30] <jnthn> lizmat: Like, we provide some context to say it was about the variable decl.

[13:32] <gfldex> std: subset Foo of Cool where Int|Str; sub s(Foo @f){}; my Foo @a; s(@a);

[13:32] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  @f is declared but not used at /tmp/_ME8z3xAGZ line 1:␤------> [32met Foo of Cool where Int|Str; sub s(Foo [33m⏏[31m@f){}; my Foo @a; s(@a);[0m␤ok 00:00 46m␤»

[13:32] <lizmat> so, how do I get to the dispatcher object so that I can call dispatchees on it?

[13:33] <jnthn> You should find that it's throwing a typed exception on dispatch failure

[13:33] *** daxim left
[13:33] <jnthn> I suggest looking specifically for that exception type and it should contain the stuff you need

[13:34] <lizmat> yes, but my error message is *before* we have an exception

[13:34] <jnthn> huh?

[13:34] <lizmat> multi trait_mod:<will>(Variable:D $v, $block, |c ) {

[13:34] <lizmat>     die "You can not 'will {c.hash.keys}' on a variable";

[13:34] <jnthn> oh...

[13:35] <jnthn> I thought you were doing it higher up, in World or so... 

[13:35] <jnthn> Well, &trait_mod:<will>.candidates would get you the list

[13:35] <lizmat> okidoki

[13:35] *** btyler joined
[13:36] <lizmat> seems lower in this case is better, so the error message can be more to the point, no?

[13:38] <jnthn> Well, maybe, but otoh we may be able to do better with a generaler solution

[13:38] <jnthn> r: sub foo() is barf { }

[13:39] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Mu:U $child, Mu:U $parent)␤:(Mu:U $type, :rw(:$rw)!)␤:(Mu:U $type, :nativesize(:$nativesize)!)␤:(Mu:U $type, :unsigned(:$unsigned)!)␤:(Mu:U $type, :hidden(:$hidden)!)␤:(M…

[13:39] <lizmat> ok, will look at that as well, but later

[13:39] <jnthn> Well, what I'm saying is that a solution that improves all of these may be possible

[13:39] <jnthn> Plus it could include a nice indication of where the error is.

[13:41] *** sqirrel_ joined
[13:41] *** [Coke]_ is now known as [Coke]

[13:41] *** sqirrel left
[13:42] <dalek> rakudo/var-traits: cbc2ce3 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[13:42] <dalek> rakudo/var-traits: Temporary more/less LTA error message for 'my $a will foo'

[13:42] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/cbc2ce3c7c

[13:42] <lizmat> ok, going off for some cycling & dinner

[13:42] <jnthn> ok :)

[13:43] <lizmat> jnthn: if I don't chat with you before you go, have a NICE holiday!

[13:43] <jnthn> lizmat: I'll be about this evening, I suspect...but thanks! :)

[13:43] <lizmat> the branch can be merged, as far as I'm concerned

[13:43] <lizmat> later!  &

[13:45] * [Coke] needs more coffee, some motivation, and perhaps a bottle of scotch.

[13:48] <colomon> jnthn: I haven't let it run fully yet, but jakudo seems to be completely outperforming parrakudo on my big task from yesterday.  (That is, I've let jakudo complete it in 11 minutes, and shut the parrakudo run off after a couple of hours.)

[13:48] <jnthn> colomon: wow

[13:49] <[Coke]> O_o

[13:50] <colomon> btw, jnthn did you see timotimo's push benchmark from yesterday?    massive, massive improvements.  :)

[13:50] <jnthn> yes :)

[13:52] *** skids joined
[13:52] <colomon> my son is showing me a map he drew from my tree (I am the Cheshire Cat, you see) to where he parked his X-wing.

[13:54] *** benabik left
[13:55] <FROGGS> *g*

[13:56] *** benabik joined
[13:56] *** benabik left
[14:02] <pmurias> jnthn: if I want to add a role to a class at runtime I should call HOW.add_role and then HOW.compose?

[14:03] *** yoleaux left
[14:03] *** yoleaux joined
[14:03] *** ChanServ sets mode: +v yoleaux

[14:04] *** SamuraiJack__ left
[14:04] *** benabik joined
[14:05] *** domidumont left
[14:05] *** fhelmberger left
[14:08] *** sqirrel_ left
[14:09] <jnthn> pmurias: To a class, rather than mixing into an object? I guess somehing like that, then, yes

[14:09] <jnthn> r: class A { }; role R { }; augment class A does R { }; say A ~~ R

[14:09] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤augment not allowed without 'use MONKEY_TYPING'␤at /tmp/nHglhLFwNe:1␤------> [32m{ }; role R { }; augment class A does R [33m⏏[31m{ }; say A ~~ R[0m␤    expecting any of:␤        scoped declarator␤        generic role␤»…

[14:10] <jnthn> r: use MONKEY_TYPING; class A { }; role R { }; augment class A does R { }; say A ~~ R

[14:10] <camelia> rakudo 117beb: OUTPUT«True␤»

[14:10] <jnthn> That's what's going on in this case.

[14:11] <pmurias> is there a sensible reason why mixing stuff into nqp::getcomp('QAST') gets ignored?

[14:11] <pmurias> the name returned by .HOW.name doesn't change and methods aren't added?

[14:12] <jnthn> You can't mix in to a type object; maybe that's the issue?

[14:13] <pmurias> http://pastie.org/8177996

[14:13] *** sqirrel joined
[14:14] <pmurias> jnthn: aha

[14:14] *** grondilu joined
[14:21] *** PacoAir joined
[14:24] *** fhelmberger joined
[14:24] <grondilu> How is the javascript backend going?

[14:24] <pmurias> jnthn: add_role/compose creates an ambigious dispatch exceptions from the multimethod

[14:25] <pmurias> grondilu: I'm working on grammars atm, it's passing a part of nqp tests, it can't still bootstrap itself

[14:26] <moritz> how does the performance feel, compared to nqp-on-parrot?

[14:27] <pmurias> I'm not running anything besides tests on it right now, so I only feel the startup

[14:28] <pmurias> which is dominated by the compilation speed

[14:28] *** fhelmberger left
[14:30] *** grondilu left
[14:30] <pmurias> moritz: but the performance right now should be pretty horrible as I'm doing things like emitting nqp.op.add_i(a,b) instead of a+b

[14:31] *** bluescreen10 joined
[14:32] <jnthn> r: say 141.base(16)

[14:32] <camelia> rakudo 117beb: OUTPUT«8D␤»

[14:35] *** btyler left
[14:35] *** sqirrel left
[14:37] *** Psyche^_ joined
[14:39] <[Coke]> :D

[14:40] *** Psyche^ left
[14:40] *** btyler joined
[14:43] * timotimo returns from a lengthy reading session in the shade of his balcony

[14:43] <pmurias> jnthn: is it possible to remove a method using the metamodel?

[14:43] <jnthn> pmurias: Not really

[14:43] <jnthn> pmurias: Though method_table gives you back the real hash

[14:44] <jnthn> pmurias: So if you remove the key from it you are manipulating the real table used to compute method caches, I guess :)

[14:44] *** benabik left
[14:44] <jnthn> It's a weird thing to want to do :)

[14:45] <pmurias> I want to override a method

[14:45] <pmurias> but removing the method using the method_table and add_method should work

[14:46] <pmurias> needless to say it's not very elegant

[14:46] <jnthn> Why can't you do it the normal way, using inheritance or something?

[14:46] <jnthn> Why change the thing nqp::getcomp returns, when you could just nqp::bindcomp an updated thing?

[14:47] <pmurias> hmm, I should try that

[14:53] <jnthn> r: say 149.base(16)

[14:53] <camelia> rakudo 117beb: OUTPUT«95␤»

[14:54] *** sqirrel joined
[14:56] *** avarab is now known as avar

[14:58] *** rindolf joined
[15:02] *** jaldhar joined
[15:03] *** Guest50868 left
[15:05] *** kaleem left
[15:12] *** jaldhar left
[15:13] *** xinming left
[15:13] *** wk joined
[15:14] *** wk is now known as Guest29595

[15:14] *** jaldhar joined
[15:15] *** xinming joined
[15:16] *** benabik joined
[15:17] *** cognominal joined
[15:19] *** kaleem joined
[15:24] *** wtw left
[15:25] <dalek> rakudo-js: 0ba95ba | (Pawel Murias)++ | / (4 files):

[15:25] <dalek> rakudo-js: Mix in a role with the single serialization "hack", instead of using a custom NQP branch.

[15:25] <dalek> rakudo-js: 

[15:25] <dalek> rakudo-js: Update the nqp submodule.

[15:25] <dalek> rakudo-js: Update the serialization format version to 6.

[15:25] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/0ba95baff4

[15:27] *** kivutar left
[15:29] <dalek> rakudo-js: f89475e | (Pawel Murias)++ | run_tests:

[15:29] <dalek> rakudo-js: Add passing test 69,71,73 to run_tests.

[15:29] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/f89475e4a4

[15:29] <pmurias> jnthn: we should propably delete the cached_serialization branch

[15:30] *** iSlug left
[15:33] *** logie left
[15:34] <jnthn> pmurias: sure...if it's never getting merged, etc.

[15:34] <jnthn> pmurias: You have a commit bit to do it, yes? :)

[15:38] <pmurias> it seems to be still visible on github

[15:38] <pmurias> I did git push origin --delete cached-serialization

[15:38] <pmurias> should I use the github "Delete branch" button?

[15:39] <FROGGS> git push origin :cached-serialization

[15:41] <jnthn> What FROGGS said. It's a weird syntax, but actaully a degenerate case of the more general refspec syntax.

[15:41] <jnthn> Same thing that lets you do git push origin HEAD~2:master to push all but the last two commits, for example.

[15:41] <benabik> --delete should do the same thing.

[15:42] <jnthn> Oh? :)

[15:42] <jnthn> benabik: How new is that, ooc?

[15:42] <pmurias> 1.7.0

[15:43] <pmurias> the github ui just seems to have a bug and hasn't noticed the branch is deleted yet

[15:47] <dalek> rakudo-js: 44fee2f | (Pawel Murias)++ | run (2 files):

[15:47] <dalek> rakudo-js: Implement nqp::atpos_i, pass test 74.

[15:47] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/44fee2f094

[15:50] *** jaldhar left
[15:55] <[Coke]> pmurias++

[15:58] *** Shozan is now known as SHODAN

[16:01] <[Coke]> OH NOES ITS SHODAN

[16:01] <[Coke]> ... I wonder if I still have a machine I can play that game on. hurm.

[16:01] *** ecocode left
[16:01] <SHODAN> B-b-b-e quiet, insect!

[16:02] <timotimo> [Coke]: i recently managed quite well with dosbox and the mouseview patch; even got it at a pretty high resolution :)

[16:02] <timotimo> "recently" is one or two years ago

[16:02] *** FROGGS[mobile] joined
[16:03] <SHODAN> yep works in dosbox

[16:04] <SHODAN> and if anyone is interested, you can help with sf.net/projects/abysmal :)

[16:05] *** FROGGS left
[16:07] *** pmurias left
[16:11] *** kaleem left
[16:14] *** shinobicl joined
[16:19] *** FROGGS joined
[16:19] <FROGGS> what are you talking about?

[16:22] <timotimo> shodan is the antagonist of critically acclaimed first-person action role playing game System Shock

[16:25] *** cognominal left
[16:31] <timotimo> oh, huh

[16:32] <timotimo> r: my @a = <a b c d e f g>; for @a -> $a, $b?, $c?, $d? -> $_ is copy { $_ //= ''; say "$a $b $c $d" };

[16:32] <camelia> rakudo 117beb: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/rO8LiRozjG:1␤------> [32mc d e f g>; for @a -> $a, $b?, $c?, $d? [33m⏏[31m-> $_ is copy { $_ //= ''; say "$a $b $c[0m␤    expecting any of:␤        postfix␤        infix stopper␤        parameterized block␤  …

[16:32] <timotimo> r: my @a = <a b c d e f g>; for @a -> $a, $b?, $c?, $d? { for $a, $b, $c, $d -> $_ is copy { $_ //= ''; say "$a $b $c $d" } }

[16:32] <camelia> rakudo 117beb: OUTPUT«a b c d␤a b c d␤a b c d␤a b c d␤use of uninitialized value of type Mu in string context  in block  at /tmp/HYiTzpfkew:1␤␤e f g ␤use of uninitialized value of type Mu in string context  in block  at /tmp/HYiTzpfkew:1␤␤e f g ␤use of uninitialized value of type Mu in …

[16:32] <timotimo> that's not the error i was getting. hold on.

[16:33] <timotimo> ... that's not the output i expect at all!

[16:35] <jnthn> timotimo: Did you mean to put that say outside of the inner loop?

[16:35] <timotimo> what i got was Nominal type check failed for parameter 'lhs'; expected Any but got Mu instead

[16:35] <timotimo> for the //=

[16:35] <timotimo> er, yes i totally did. thanks!

[16:36] <timotimo> it can be quite hard to do these one-liners properly in just an irc client

[16:36] <timotimo> r: my @a = <a b c d e f g>; for @a -> $a, $b?, $c?, $d? { for $a, $b, $c, $d -> $_ is copy { $_ //= ''; print "$_ " }; print "\n" }

[16:36] <camelia> rakudo 117beb: OUTPUT«a b c d ␤e f g Nominal type check failed for parameter 'lhs'; expected Any but got Mu instead␤  in sub METAOP_TEST_ASSIGN:<//> at src/gen/CORE.setting:14713␤  in block  at /tmp/XRK1XOPx2R:1␤  in method reify at src/gen/CORE.setting:6542␤  in method reify at src/gen…

[16:36] <timotimo> is that an "is copy" bug?

[16:37] <jnthn> r: my $x = Mu; say $x // 42

[16:37] <camelia> rakudo 117beb: OUTPUT«42␤»

[16:37] <jnthn> r: my $x = Mu; $x //= 42; say $x

[16:37] <camelia> rakudo 117beb: OUTPUT«Nominal type check failed for parameter 'lhs'; expected Any but got Mu instead␤  in sub METAOP_TEST_ASSIGN:<//> at src/gen/CORE.setting:14713␤  in block  at /tmp/own174feeY:1␤␤»

[16:37] <jnthn> There's the bug

[16:38] <timotimo> ah, pointy blocks have Mu instead of Any as their type, right?

[16:38] <jnthn> Right

[16:38] <timotimo> so in reality, metaop_test_assign should really just be able to handle undefined values of mu?

[16:38] <jnthn> It's od though, 'cus

[16:38] <jnthn> sub METAOP_ASSIGN(\op) { -> Mu \a, Mu \b { a = op.( a // op.(), b) }

[16:38] <jnthn> }

[16:38] <jnthn> oh, test assign!

[16:39] <jnthn> yes, should be Mu

[16:39] <timotimo> i can make a spectest and patch later

[16:39] <jnthn> Should take Mu \lhs

[16:39] *** vk_ joined
[16:44] <timotimo> r: say "    four".subst("   ", " ").perl

[16:44] <camelia> rakudo 117beb: OUTPUT«"  four"␤»

[16:44] <timotimo> r: say "        eight".subst("   ", " ").perl

[16:44] <camelia> rakudo 117beb: OUTPUT«"      eight"␤»

[16:44] <timotimo> huh. weird.

[16:44] <jnthn> Want :g?

[16:44] <timotimo> nope, but what i did want was min instead of max :)

[16:45] * timotimo is writing a short perl script to arrange words and numbers in columns of 20 and "compensate" for too long columns in the next column

[16:45] <timotimo> not really working though

[16:45] *** rindolf left
[16:45] <PerlJam> timotimo: use formats  ;)

[16:46] *** iSlug joined
[16:47] <timotimo> i was going to, but that would have been fiddly with compensation, too

[16:55] *** birdwindupbird left
[16:57] *** Guest29595 left
[17:00] <[Coke]> Did damian implement formats for six, or only five? 

[17:01] *** rindolf joined
[17:01] *** estrabd left
[17:03] <[Coke]> hopefully will be easier with sprintf fixes in the pipeline.

[17:11] *** spider-mario joined
[17:14] <colomon> pipeline?

[17:15] <[Coke]> ... or are you done now? ;)

[17:16] <pmichaud_> good afternoon, #perl6

[17:17] <jnthn> o/ pmichaud 

[17:17] <[Coke]> pmichaud: hio!

[17:17] <timotimo> huh.

[17:18] <timotimo> $=pod<dictionary>[0].content[0] works, but BEGIN { $=pod<dictionary>[0].content[0] } doesn't; do i have to use a later-but-still-compile-time phaser if i want to access pod because it's composed when parsing is finished?

[17:18] <jnthn> timotimo: Did you try CHECK?

[17:19] <timotimo> i will now

[17:19] <timotimo> i wasn't sure if check was compile time, but now i remember (impossible dispatches are check-time errors after all!)

[17:20] <colomon> [Coke]: I'm not done done, but most of the basic functionality is there.  The only issues I'm really aware of is returning unwanted zeros at the end with %g and not handling NQP bigints properly.

[17:20] <timotimo> postcircumfix:<{ }> not defined for type Array  :(

[17:20] <timotimo> oh, maybe i shouldn't use curlies?

[17:21] <timotimo> nope :(

[17:24] *** iSlug left
[17:27] *** rindolf left
[17:27] <timotimo> d'oh i think the error was coming from somewhere else. should have used --ll-exception to be sure

[17:44] <dalek> perl6-roast-data: dfdf4ee | coke++ | / (5 files):

[17:44] <dalek> perl6-roast-data: today (automated commit)

[17:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/dfdf4eedb6

[17:46] *** vk_ left
[17:46] <[Coke]> getting IO-Socket-INET failures on rakudo.pvm - "took too long"

[17:51] *** btyler left
[17:54] *** fridim_ left
[18:06] *** btyler joined
[18:08] *** crab2313 left
[18:26] *** SamuraiJack__ joined
[18:28] *** konundra joined
[18:33] *** Rix left
[18:34] *** lorn joined
[18:39] *** xenoterracide left
[18:39] *** xenoterracide joined
[18:46] <lizmat> [Coke]: wrt to IO-Socket-INET failures: I put in those checks

[18:47] *** wk joined
[18:47] <lizmat> that test is hanging 7 x 20 seconds on certain actions: this smells of a timeout / buffering issue that needs to be worked out before we can really start to use sockets in rakudo

[18:47] <[Coke]> ok. they're failing.

[18:47] *** wk is now known as Guest36807

[18:47] <lizmat> I put in 20 or so checks: each gets 5 seconds to complete.  If it takes more than 5 seconds, it's a fail

[18:48] <lizmat> all of the failing tests take exactly 20 seconds to run

[18:49] <lizmat> like the issues we found yesterday with push and sink context, there is something really wrong there!

[18:49] <lizmat> pmichaud o/

[18:50] *** Rix joined
[18:53] *** Guest36807 left
[18:59] <lizmat> [Coke] am I correct in seeing that the IO-Socket-INET errors don't occur on rakudo.jvm ?

[18:59] <lizmat> if so, is that because they pass, or because they aren't run?

[19:01] *** sqirrel left
[19:05] <jnthn> Aren't run; there are no sockets yet on JVM

[19:05] <timotimo> i don't think we have sockets on rakudo.jvm yet

[19:14] <TimToady> lizmat: yes, START is gone; START was renamed to statement_prefix:once

[19:14] <lizmat> but "is start" as a variable trait, is still supposed to be there, right ?

[19:14] <TimToady> because it's not really a phaser that changes time of execution, just whether it executes

[19:14] <TimToady> I don't know what it would mean

[19:15] <TimToady> state $x = 0; is really just: once my $x = 0;

[19:15] <lizmat> sorry, I meant "will start"

[19:15] <TimToady> there is no "start" time

[19:16] <lizmat> so S04:1457 is obsolete / bogus ?

[19:16] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1457

[19:16] <TimToady> it's just in the line of normal execution, only it just does it once

[19:16] <lizmat> as is S04:1480 ?

[19:16] <synopsebot> Link: http://perlcabal.org/syn/S04.html#line_1480

[19:16] <TimToady> yes, obsolete

[19:17] <TimToady> didn't see that when I made the START -> once transition, because it wasn't uppercase :)

[19:17] <dalek> rakudo/var-traits: 4c5a6c0 | (Elizabeth Mattijsen)++ | src/core/Variable.pm:

[19:17] <dalek> rakudo/var-traits: Make variable trait "is TypeObject" fail with a better message for now

[19:17] <dalek> rakudo/var-traits: review: https://github.com/rakudo/rakudo/commit/4c5a6c0ba3

[19:18] <TimToady> START was badly named anyway...

[19:20] <lizmat> well, it was a start :-)

[19:20] <lizmat> .oO( feelings of dëjà vu )

[19:24] <lizmat> I'm about to merge the var-traits branch

[19:24] <lizmat> after that, "is default" should work on typed scalars

[19:24] <lizmat> and "will phaser {}" will sort of work as well

[19:28] *** wk_ joined
[19:36] <dalek> roast: 2baf5cf | (Elizabeth Mattijsen)++ | S02-types/key (2 files):

[19:36] <dalek> roast: Hopefully correctly change "is KeyXxxx" to "of KeyXxxx", tests pass

[19:36] <dalek> roast: review: https://github.com/perl6/roast/commit/2baf5cffdf

[19:41] <moritz> fwiw I can confirm that the last two tests of t/spec/S32-io/IO-Socket-INET.t time out on parakudo

[19:46] <dalek> roast: a9ee8a3 | moritz++ | S32-io/IO-Socket-INET.sh:

[19:46] <dalek> roast: [sockets] report timeout when the server was actually killed

[19:46] <dalek> roast: review: https://github.com/perl6/roast/commit/a9ee8a3160

[19:47] *** athomason joined
[19:47] <moritz> r: say Buf.new().elems

[19:47] <camelia> rakudo 117beb: OUTPUT«0␤»

[19:50] <dalek> roast: c009fef | moritz++ | S32-io/IO-Socket-INET.pl:

[19:50] <dalek> roast: [sockets] do not hardcode length of buffer

[19:50] <dalek> roast: review: https://github.com/perl6/roast/commit/c009fefca8

[19:50] <moritz> all of this is just prettifying things, not actually fixing anything :(

[19:50] <dalek> roast: e23388c | (Elizabeth Mattijsen)++ | S02-types/key (2 files):

[19:50] <dalek> roast: Fudge keyset/keybag tests: the tests were for "is KeyBag/Set" after all

[19:50] <dalek> roast: review: https://github.com/perl6/roast/commit/e23388c7c8

[19:51] <dalek> Heuristic branch merge: pushed 20 commits to rakudo/nom by lizmat

[19:52] <moritz> r: say Buf.new() eqv Buf.new();

[19:52] <camelia> rakudo 117beb: OUTPUT«True␤»

[19:54] <moritz> lizmat, jnthn: the socket tests on parakudo hang here: say $binary eqv $recv ?? 'OK-7' !! 'NOK-7';

[19:54] <moritz> it's not the sockets that timeout, but the eqv

[19:55] <jnthn> wtf!

[19:55] <jnthn> Does Buf eqv somehow have crazy bad performance?

[19:56] <lizmat> and the watchdog makes it show up as 20 second timouts?

[19:56] <moritz> lizmat: correct

[19:56] * lizmat is glad she added the timeout tests :-)

[19:56] <moritz> I just did

[19:56] <moritz> my Buf $b1 = slurp('README', :bin);

[19:56] <moritz> my Buf $b2 = slurp('README', :bin);

[19:56] <moritz> say $b1 eqv $b2;

[19:56] <jnthn> [&&] $a.list Z== $b.list

[19:56] <moritz> and it exceeds my patience, nearly

[19:57] <moritz> jnthn: I guess I wrote that code, once :/

[19:57] <jnthn> It's cute ;)

[19:57] <timotimo> cute code, but probably abysmal performance :D

[19:57] <timotimo> does [&&] know how to short-circuit?

[19:57] <moritz> ok, 39s for comparing two Buf copies of the README

[19:58] <jnthn> timotimo: I sure hope so...

[19:58] <moritz> timotimo: I think so, but they actually are the same

[19:58] <timotimo> oh, right.

[19:58] <moritz> $ wc -c README 

[19:58] <moritz> 5052 README

[19:58] <moritz> so, the sockets test (4096 bytes) will probably take just as long

[19:59] <timotimo> r: [&&] (True xx 100, False, True xx 10000); say time - CHECK time

[19:59] <camelia> rakudo 117beb: OUTPUT«2␤»

[19:59] <timotimo> yeah, that seems good

[19:59] <timotimo> or maybe that didn't flatten.

[20:01] <jnthn> r: my $b = ('a' x 10000).encode; my $n = now; $b.list; say now - $n

[20:01] <camelia> rakudo 117beb: OUTPUT«0.80859796␤»

[20:01] <moritz> ok, eq is much faster than eqv

[20:01] <timotimo> is it also correct?

[20:01] <moritz> and eq just compares stringification of .list

[20:01] <timotimo> ah, that's how

[20:02] <moritz> so quite some potential for optimization still

[20:02] <jnthn> $a.list eq $b.list is not exactly fast either :)

[20:02] <moritz> aye

[20:02] <moritz> I'll do the coward's patch (change eqv to use eq), which will get the tests passing

[20:02] <timotimo> hey

[20:02] <timotimo> how about you eqv the .list's of both?

[20:02] <moritz> and let somebody else do the Real Work[tm]

[20:03] <dalek> roast: 9bdb8f9 | (Elizabeth Mattijsen)++ | S02- (2 files):

[20:03] <dalek> roast: Unfudge now passing tests after merge of var-traits branch

[20:03] <dalek> roast: review: https://github.com/perl6/roast/commit/9bdb8f979b

[20:03] <moritz> timotimo: probably slower than eq

[20:03] <timotimo> OK

[20:03] * timotimo imagines one could do something like memcmp by exposing a nqp op for buf equality

[20:04] <jnthn> moritz: I'm doing a better eqv patch here

[20:05] <jnthn> The README buf comp is 14s here o.O

[20:05] * jnthn builds the improvement

[20:05] <moritz> jnthn: great, then I can abort my slow-as-hell spectest here :-)

[20:06] <lizmat> that should take up to 2 minutes off the spectest, if run in parallel probably around 1 minute

[20:07] <lizmat> wallclock

[20:08] <moritz> because the inet tests don't time out anymore?

[20:08] <lizmat> indeed… in parallel test, the IO-Socket-INET was always the last to finish

[20:08] *** bruges joined
[20:08] <lizmat> about 1 minute *after* all the other tests finished

[20:10] <lizmat> TimToady: I wonder whether .push shouldn't have a ":bind" adverb, to bind the values to the list, rather than copying

[20:11] <lizmat> consequently, I think .classify and .categorize should have the same :bind adverb and pass that through to .push

[20:11] *** omeranon left
[20:11] <lizmat> TimToady: does that make sense?

[20:12] <lizmat> also, I think KeyBag might want to have a .classify and .categorize as well

[20:12] <lizmat> if you're just interested in counts

[20:15] <lizmat> r: my $x is readonly=5 # is this supposed to work?

[20:15] <camelia> rakudo 117beb:  ( no output )

[20:15] <lizmat> r: my $x is readonly=5; say $x # is this supposed to work?

[20:15] <camelia> rakudo 117beb: OUTPUT«5␤»

[20:15] <timotimo> lizmat: i believe so (i read it in an RT somewhere)

[20:15] <timotimo> "is readonly" shoud allow assignment exactly once

[20:15] <jnthn> Around 14 times faster

[20:15] <moritz> \o/

[20:16] <timotimo> ... it's a start ;)

[20:16] <jnthn> It'll deal with the spectest fallout at least.

[20:16] <moritz> though 1s for comparing 4k of buffer two ways still isn't too great

[20:16] <jnthn> yeah

[20:17] * lizmat is looking forward to spectest that!

[20:17] <moritz> push! push! push!

[20:17] <moritz> fwiw the speedup from my patch was only a factor 8

[20:19] <jnthn> oh, I was spectsting rather than pushing :P

[20:19] <timotimo> what speaks against doing it as a nqp op? at least for the native buffer objects it should be ridiculously fast with just a memcmp

[20:20] <jnthn> timotimo: Nothing other than not got time for that righ tnow

[20:20] <timotimo> cool. i could try it some time then :)

[20:20] <moritz> .oO( push or it didn't happen )

[20:22] <lizmat> .oO( it's not like it's a 6.1kg baby )

[20:24] <dalek> rakudo-star-daily: 0adb160 | coke++ | log/ (5 files):

[20:24] <dalek> rakudo-star-daily: today (automated commit)

[20:24] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0adb1602f3

[20:24] <dalek> rakudo-star-daily: 4f061b6 | coke++ | log/ (5 files):

[20:24] <dalek> rakudo-star-daily: today (automated commit)

[20:24] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/4f061b6cf5

[20:24] <dalek> rakudo-star-daily: 0a644e5 | coke++ | log/ (5 files):

[20:24] <dalek> rakudo-star-daily: today (automated commit)

[20:24] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0a644e5da7

[20:24] <dalek> rakudo-star-daily: f9c5066 | coke++ | log/ (5 files):

[20:24] <dalek> rakudo-star-daily: today (automated commit)

[20:24] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/f9c50667b3

[20:25] *** omeranon joined
[20:27] *** btyler_ joined
[20:30] *** btyler left
[20:33] *** wk_ left
[20:37] <moritz> anybody want to spectest https://gist.github.com/moritz/6092037 for me?

[20:38] * moritz -> sleep

[20:38] <lizmat> will do, moritz, and gnight!

[20:40] <lizmat> …. building

[20:41] <dalek> rakudo/nom: 35818f8 | jnthn++ | src/core/Buf.pm:

[20:41] <dalek> rakudo/nom: Optimize Buf.eqv a bit.

[20:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/35818f885b

[20:51] <lizmat> will spectest that in a few minutes  :-)

[20:52] * lizmat wishes for a phaser to be executed after a thunk has executed

[20:52] <lizmat> would be a nice way to solve the "my $x is readonly=5" problem

[20:55] <lizmat> jnthn: would you object if I changed the "rw" attribute in ContainerDescriptor to "readonly" and switch the meaning around?

[20:55] <jnthn> lizmat: We used to have it that way around and changed it.

[20:56] <lizmat> and the reason was?

[20:56] <jnthn> lizmat: Turns out readonly being the default tends to be righter in more cases.

[20:56] <jnthn> lizmat: Certainly we've had a bunch less bugs this way around...

[20:57] <lizmat> couldn't you set the default to 1?

[20:58] <jnthn> What problem would swapping it around solve?

[20:58] <lizmat> currently, this doesn't work:"my $x is readonly=5"

[20:58] <lizmat> because $x is readonly before the 5 is assigned

[20:58] <jnthn> Right.

[20:59] <jnthn> The solution to that is probably to treat initializers differently to normal assignments.

[20:59] <lizmat> but wouldn't that cause a lot of overhead?

[20:59] <lizmat> my idea was:

[20:59] <jnthn> Depends how you do it, but the parser already distinguishes the two

[21:00] <lizmat> ContainerDescriptor.readonly: possible values: 0 = rw, 1 = readonly, >1 readonly, but allow N-1 assignments

[21:00] <jnthn> That won't work

[21:01] <lizmat> then in rakudo_scalar_store update the readonly in the descriptor when needed

[21:01] <jnthn> You need one assignment per incarnation of the variable, not one i the lifetime of the program.

[21:01] *** SamuraiJack__ left
[21:01] <lizmat> ah, ok

[21:01] <lizmat> good point

[21:01] * lizmat scratches that idea

[21:02] <jnthn> I think it wants to be something related to the initializer, though.

[21:02] <lizmat> moritz: spectest is clean https://gist.github.com/moritz/6092037

[21:02] <jnthn> We already know that has to be special.

[21:02] <jnthn> In fact, we already do specail things there for state vars.

[21:02] <lizmat> ok, will check the parser for initializations, and state vars in particular

[21:03] <lizmat> now buiilding / spectesting jnthn's Buf optimization

[21:04] *** skids left
[21:04] *** dayangkun left
[21:05] *** pmurias joined
[21:05] <pmurias> pmichaud: ping

[21:05] *** konundra left
[21:08] *** Timbus joined
[21:08] *** colomon left
[21:12] *** sqirrel joined
[21:16] *** spider-mario left
[21:16] *** dayangkun joined
[21:19] <lizmat> jnthn/moritz: alas, no improvement in t/spec/S32-io/IO-Socket-INET.t, still 7 failures because of timeout after 20 seconds

[21:20] <jnthn> wtf

[21:21] <FROGGS> gnight o/

[21:21] <lizmat> wish I had better news

[21:21] <lizmat> gnight FROGGS!

[21:21] <lizmat> I assume moritz' patch was unrelated?

[21:27] *** sqirrel left
[21:28] *** grondilu joined
[21:29] <grondilu> While trying to rebootstrap panda:

[21:29] <grondilu> ==> Testing File::Tools

[21:29] <grondilu> t/01-file-find.t ...... Failed 1/10 subtests 

[21:29] <lizmat> jnthn: wrt to "my $x is readonly=5", I guess some magic would need to be added at Actions, around line 1792, right ?

[21:29] *** colomon joined
[21:30] <lizmat> $past := assign_op($/, $past, $<initializer>[0].ast);

[21:30] <jnthn> lizmat: yeah

[21:30] <jnthn> lizmat: We already have an nqp::assignunchecked op, which skips the rw check and the type check...

[21:30] <lizmat> aha, ok

[21:30] <jnthn> lizmat: But we kinda want the type check still...

[21:31] <jnthn> The idea is that the optimizer will rewrite assignments it proves are safe at some point in the future, though.

[21:31] * grondilu ran PERL6LIB=lib perl6 t/01-file-find.t

[21:31] <grondilu> not ok 10 - found one of two files due to X::IO::Dir

[21:31] <grondilu> #      got: '2'

[21:31] <grondilu> # expected: '1'

[21:31] <grondilu> # Looks like you failed 1 tests of 10

[21:32] *** FROGGS[mobile] left
[21:33] <lizmat> so line 4680, change 'p6store' to 'assignunchecked' depending on a condition ?

[21:35] *** athomason left
[21:40] <jnthn> Maybe something like it...suspect it may involve a little more than that.

[21:40] <lizmat> I think we're going about this the wrong way

[21:41] <lizmat> I think the "is readonly" trait needs to be applied after initialization

[21:41] <lizmat> *not* doing things unchecked

[21:41] <lizmat> otherwise, "my $a=42; my $b is readonly := $a" will still not create a readonly container

[21:42] <lizmat> so I'm wondering something in the form of a .whence?

[21:44] <grondilu> tadzik: in t/01-file-find.t the last test finds two files instead of one expected.  Yet in t/dir1 there are indeed two files named file.bar.  One in t/dir1/ and the other in t/dir1/another_dir/.

[21:44] <jnthn> lizmat: WHENCE is closer...

[21:44] <jnthn> lizmat: I think you're confusing things by talking about trait application as if it were a runtime thing, which it's not.

[21:45] <jnthn> However, the single assignment *is* a runtime thing.

[21:46] *** btyler_ left
[21:47] <lizmat> but each .WHENCE only gets executed once, no?

[21:47] <lizmat> and then gets nulliified

[21:48] <lizmat> the readonly trait needs to be applied after the first assignment?

[21:48] <lizmat> and the .WHENCE is basically just a closure, no?

[21:49] <lizmat> I know it was made to prevent auto-vivification, but this feels like a good re-purpose of that functionality

[21:50] <lizmat> this approach would not add any overhead to the current low level scalar_store code

[21:50] *** FROGGS left
[21:50] <lizmat> for all other assignment

[21:50] <lizmat> s

[21:51] <jnthn> WHENCE is currently quite high overhead, though.

[21:51] <lizmat> if (!PMC_IS_NULL(scalar->whence)) { ?

[21:52] <lizmat> or the Parrot_pcc_invoke_from_sig_object(interp, scalar->whence, cappy); ?

[21:52] <lizmat> the thing is, most other approaches would add overhead to *all* assignments

[21:52] <jnthn> The latter

[21:53] <jnthn> A p6storeevenifro wouldn't... :)

[21:53] <lizmat> well, it would only be done once

[21:53] <lizmat> but would that also solve the case for binding?

[21:53] <lizmat> my $a is readonly := $b ?

[21:54] <jnthn> Hm. I'd tended to see "is readonly" being about the container...

[21:54] <jnthn> Which you replace when binding... 

[21:54] <jnthn> otoh, we make sure type checks are enforced on binding

[21:55] *** bluescreen10 left
[21:55] <jnthn> That said, we can catch such cases statically... 

[21:55] <lizmat> so you're saying we can't have a "read only" and a "rw" view on the same container

[21:56] <lizmat> I mean, if we can't use "is readonly" with binding

[21:56] <lizmat> then we lose all use for "is readonly"

[21:57] <lizmat> because if we can only use that for right values, then we might as well die with a message "please bind to the right value"

[21:57] <lizmat> aka my $x := 42

[21:58] *** btyler joined
[22:02] *** bluescreen10 joined
[22:04] <lizmat> the more I think about it, the more it doesn't make sense to have "is readonly" on variables

[22:05] <lizmat> either you alias it to a literal, which makes it read-only

[22:05] <lizmat> or you alias it to another container, and get the same .rw status whether you want it or not

[22:06] <lizmat> add to that the fact that "is readonly" is not specced for variables

[22:06] * grondilu is confused by what lizmat says

[22:06] <lizmat> it is specced for subs and parameters

[22:06] <lizmat> afaik, but not for variables

[22:06] <grondilu> indeed

[22:07] <grondilu> oh ok

[22:07] *** colomon left
[22:07] <jnthn> Well, seems we're now looking at lang design, not impl :)

[22:08] <lizmat> well, remove implementation rather than change lang design

[22:08] *** colomon joined
[22:08] <lizmat> anyways, I'm gonna sleep over it, been a long. long day

[22:08] <lizmat> I shouldn't get up at 6:30 and then go on until after midnight

[22:09] <lizmat> so I'm going to catch some shuteye

[22:09] <lizmat> jnthn: have fun in Switzerland!  Come back safe!

[22:09] <lizmat> sleep&

[22:10] <jnthn> Will try to do so ;-)

[22:10] <jnthn> 'night

[22:10] * jnthn figures he should catch a few hours of rest sometime soon, given his early flight... :)

[22:12] *** benabik left
[22:14] *** census joined
[22:14] <census> hey!

[22:16] *** xinming left
[22:16] *** xinming joined
[22:18] *** FROGGS joined
[22:20] *** colomon left
[22:21] *** bluescreen10 left
[22:21] <jnthn> vacation; bbiaweek &

[22:53] *** shinobicl left
[22:58] *** BenGoldberg joined
[23:01] *** odoacre_ left
[23:08] *** pmurias left
[23:15] *** skids joined
[23:16] *** dmol left
[23:20] *** cbk left
[23:29] *** cooper left
