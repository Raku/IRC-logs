[00:00] <dalek> roast: 5a4c6b7 | (Tobias Leich)++ | S05-mass/rx.t:

[00:00] <dalek> roast: RT #115298, test for $( $_ )

[00:00] <dalek> roast: review: https://github.com/perl6/roast/commit/5a4c6b7c46

[00:00] <FROGGS> gnight

[00:01] *** FROGGS left
[00:23] *** swarles left
[00:29] *** atrodo left
[00:40] *** Pleiades` left
[00:45] *** Pleiades` joined
[00:47] *** am0c joined
[00:48] *** Swarley_ joined
[00:53] *** Pleiades` left
[00:57] *** Pleiades` joined
[01:00] *** Chillance left
[01:01] *** Swarley_ is now known as swarles

[01:05] *** Targen joined
[01:08] *** rindolf left
[01:09] *** benabik left
[01:09] *** hypolin joined
[01:14] *** anuby joined
[01:19] *** benabik joined
[01:33] <diakopter> :7

[01:43] *** MikeFair__ left
[01:49] *** MikeFair_ joined
[02:16] *** swarles left
[02:45] *** hash_table joined
[02:48] *** ph1ur3 left
[02:49] *** MikeFair_ left
[02:51] *** hash_table left
[02:54] *** MikeFair_ joined
[03:01] *** hlin_ joined
[03:04] *** hlin_ left
[03:11] *** skids joined
[03:14] *** balders_dod joined
[03:31] *** bluescreen__ joined
[03:35] *** bluescreen100 left
[03:37] *** MikeFair_ left
[03:37] *** MikeFair joined
[03:41] *** araujo left
[03:57] *** orafu left
[03:57] *** orafu joined
[04:06] *** fgomez left
[04:06] *** fgomez joined
[04:18] *** preflex left
[04:18] *** preflex_ joined
[04:18] *** preflex_ is now known as preflex

[04:20] *** aindilis left
[04:21] *** aindilis joined
[05:13] *** telex left
[05:16] *** telex joined
[05:25] *** telex left
[05:38] *** telex joined
[05:43] *** alec left
[05:50] *** alec__ joined
[05:51] *** alec__ is now known as alec

[05:54] <moritz> \o

[05:59] <sorear> o/ moritz 

[05:59] *** SamuraiJack joined
[06:02] *** balders_1od joined
[06:03] *** balders_dod left
[06:08] *** dayangkun joined
[06:18] *** balders_1od left
[06:26] *** erkan joined
[06:26] *** erkan left
[06:26] *** erkan joined
[06:51] *** kaleem joined
[06:55] *** daniel-s left
[06:56] *** daniel-s joined
[07:02] *** alec__ joined
[07:03] *** alec left
[07:14] *** wk_ joined
[07:18] *** wk left
[07:19] *** alec__ is now known as alec

[07:35] *** Swarley_ joined
[07:35] *** araujo joined
[07:36] <Swarley_> How would i express this, ( source-character+ ) but not ( source-character* line-terminator source-character* )

[07:36] <Swarley_> I'm sure I could figure out a way, but I thought that checking for a special perl 6 magic method would be easier

[07:38] <TimToady> we usually use \N+ for that

[07:38] <TimToady> negation of \n

[07:39] <TimToady> or do you mean something else by 'line-terminator'?

[07:39] <Swarley_> token TkLineTerminator { \x0D? \x0A }

[07:39] <Swarley_> Directly from an IPA draft of a language specification.

[07:40] <TimToady> \n is supposed to match any of the common line terminators in Perl 6

[07:40] <TimToady> r: say "foo\r\n" ~~ /\N+/

[07:40] <p6eval> rakudo d97ad4: OUTPUT«｢foo｣␤␤»

[07:40] <sorear> \n also matches some weird line terminators that I have never seen in the wild

[07:41] <TimToady> well, like PARAGRAPH SEPARATOR and such

[07:41] <sorear> if you have a need to include \u2028 as part of your logical lines, \N* is not for you.

[07:41] <Swarley_> Well, is there a way to do some actual and logic and just negate the second expression?

[07:42] <TimToady> there is a specced way that is probably not implemented, but you can always put an assertion of your own

[07:42] <sorear> I'd do [ <!TkLineTerminator> . ]*

[07:43] <TimToady> or possibly even <-TkLineTermator>*

[07:43] <Swarley_> Ah.

[07:43] <TimToady> only spelled rigth

[07:44] <sorear> what you wrote first is CYK-think and is less than optimal with the perl 6 grammar engine

[07:44] <sorear> although it can be written

[07:44] <sorear> A !~~ /B/ I think

[07:44] <Swarley_> r: say "hello world\r\n" ~~ /<-\x0D? \x0A>/

[07:44] <p6eval> rakudo d97ad4: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at /tmp/1zhLtaFy1M:1␤------> [32msay "hello world\r\n" ~~ /<-[33m⏏[31m\x0D? \x0A>/[0m␤Unrecognized regex metacharacter - (must be quoted to match literally)␤at…

[07:45] <Swarley_> er

[07:45] <sorear> r: my token nl { \x0D? \x0A }; say "hello world\r\n" ~~ /<-nl>/

[07:45] <p6eval> rakudo d97ad4: OUTPUT«No such method 'nl' for invocant of type 'Cursor'␤  in regex  at /tmp/2tOd5wM1uV:1␤  in method ACCEPTS at src/gen/CORE.setting:10733␤  in block  at /tmp/2tOd5wM1uV:1␤␤»

[07:46] <sorear> you can't just put random stuff between <- and >

[07:46] <Swarley_> Ah. Well, there is no immediate negation then?

[07:46] <sorear> it has to be a rule name (or something else that can match the "assertion" production)

[07:47] <sorear> Swarley_: you CAN do token line { [.*] !~~ /<nl>/ }

[07:47] <sorear> Swarley_: if you want your rules to take quadratic time, that is.

[07:47] <TimToady> I don't think the inner regex takes //

[07:47] <Swarley_> er no, i'd prefer that they didn't

[07:48] <sorear> <-nl>* will take linear time and I strongly recommend that you use it instead

[07:48] <Swarley_> Yes, I'll use that

[07:48] <sorear> this is not CYK

[07:51] <jnthn> morning

[07:51] <TimToady> o/

[07:55] * jnthn sips coffee and prepares for the day's teaching :)

[07:59] <moritz> o/

[07:59] <nwc10> ensuring a proper bootstrap?

[08:00] <jnthn> Something like :)

[08:00] *** Swarley_ left
[08:10] *** FROGGS joined
[08:12] <FROGGS> morning

[08:13] <FROGGS> is there a tool that let you calculate NQP_REVISION ?

[08:16] <moritz> git describe

[08:18] <FROGGS> cool

[08:18] <moritz> t/spec/S32-exceptions/misc.rakudo                       (Wstat: 0 Tests: 513 Failed: 1) Failed test:  492

[08:18] <FROGGS> moritz: thanks, so I dont have to count be myself :o)

[08:19] <FROGGS> hmmm, this https://github.com/perl6/roast/commit/b8320565e49e641b570fa10e66c399e5eb1ff478

[08:20] <FROGGS> I'm already running the spectests

[08:20] <moritz> I don't like the approach of X::Constructor::Positional

[08:21] <moritz> with .name, I mean

[08:21] <moritz> it should store the type object directly

[08:21] <moritz> and only .^name it for the message

[08:21] <moritz> that way less information is lost

[08:22] *** SamuraiJack left
[08:28] <FROGGS> # Exception message: Could not locate compile-time value for symbol Foo

[08:31] <FROGGS> moritz: I'm trying to fix this, k?  # not that be both spend time on it

[08:32] <moritz> FROGGS: +1

[08:33] *** fhelmberger joined
[08:34] <FROGGS> rn: say "foobar" ~~ m/$( $_ )/

[08:34] <p6eval> rakudo d97ad4: OUTPUT«｢foobar｣␤␤»

[08:34] <p6eval> ..niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(6) text(foobar) pos([].list) named({}.hash)>␤»

[08:34] <FROGGS> rn: say "foobar" ~~ m/f $( $_ )/

[08:34] <p6eval> niecza v24-18-gaf64300: OUTPUT«False␤»

[08:34] <p6eval> ..rakudo d97ad4: OUTPUT«#<failed match>␤»

[08:35] <FROGGS> good

[08:35] <FROGGS> rn: say "foobar" ~~ m/f $( $_.substr(1, Inf) )/

[08:35] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(1) text(f) pos([].list) named({}.hash)>␤»

[08:35] <p6eval> ..rakudo d97ad4: OUTPUT«␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀S␀␀␀O␀␀␀R␀␀␀R␀␀␀Y␀␀␀!␀␀␀␀␀␀[␀␀␀3␀␀␀1␀␀␀m␀␀␀=␀␀␀=␀␀␀=␀␀␀␀␀␀[␀␀␀0␀␀␀m␀␀␀␤␀␀␀U␀␀␀n␀␀␀r␀␀␀e␀␀␀c␀␀␀o␀␀␀g␀␀␀n␀␀␀i␀␀␀z

[08:35] <FROGGS> what the

[08:36] <FROGGS> rn: say "foobar" ~~ m/f { $_.substr(1, Inf) }/

[08:36] <p6eval> rakudo d97ad4: OUTPUT«｢f｣␤␤»

[08:36] <p6eval> ..niecza v24-18-gaf64300: OUTPUT«#<match from(0) to(1) text(f) pos([].list) named({}.hash)>␤»

[08:36] <moritz> FROGGS: known(-ish) problems with UTF-32 and error messages from qregex

[08:37] <FROGGS> moritz: looks good in my shell, is it a problem in p6eval?

[08:38] <moritz> FROGGS: no, your shell just ignores the extra zero bytes

[08:38] <FROGGS> good shell ;o)

[08:38] <FROGGS> a bit ignorant though

[08:38] <moritz> p6eval replaces them with ␀

[08:43] *** groky left
[08:53] *** hoelzro|away is now known as hoelzro

[08:54] *** sqirrel joined
[08:54] <timotimo> FROGGS: thanks for fixing my mistakes :)

[08:55] <timotimo> i thought i had tested the change, though. strange.

[08:55] *** groky joined
[09:00] *** kresike joined
[09:01] <kresike> hello all you happy perl6 people

[09:05] *** awwaiid left
[09:15] <dalek> rakudo/nom: 6b0cea6 | (Tobias Leich)++ | src/core/ (2 files):

[09:15] <dalek> rakudo/nom: pass type object to exception X::Constructor::Positional

[09:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b0cea6e48

[09:15] <moritz> FROGGS++

[09:17] *** rindolf joined
[09:17] <dalek> roast: 2018e14 | (Tobias Leich)++ | S32-exceptions/misc.t:

[09:17] <dalek> roast: X::Constructor::Positional's attribute is the type object

[09:17] <dalek> roast: review: https://github.com/perl6/roast/commit/2018e14b42

[09:22] <Harzilein> rindolf: interesting username... are you the java mikmod author?

[09:22] <masak> g'morn'n, #perl6

[09:22] <rindolf> Harzilein: yes, I am.

[09:22] <FROGGS> morning masak

[09:23] <Harzilein> rindolf: :D

[09:23] <rindolf> Harzilein: http://www.shlomifish.org/ - that's my home page.

[09:23] <FROGGS> .oO( do I need coffee when doing. mor<tab> morn<tab><tab> morni<tab> ? )

[09:24] <Harzilein> rindolf: i tried to make a sample extractor based on your code a while ago. haven't worked on it in a while though.

[09:24] <rindolf> Harzilein: ah, OK.

[09:24] <rindolf> Harzilein: the Java port ended up in some non-idiomatic Java.

[09:24] <rindolf> And it also used to be much slower than the C code.

[09:27] <Su-Shee> good morning everyone.

[09:28] *** rindolf left
[09:29] *** rindolf joined
[09:29] <FROGGS> morning Su-Shee 

[09:31] <masak> morning, Su-Shee 

[09:32] *** alec__ joined
[09:34] *** alec left
[09:41] *** alec__ is now known as alec

[09:46] *** Patterner left
[09:48] *** Psyche^ joined
[09:48] *** Psyche^ is now known as Patterner

[09:53] *** rindolf left
[09:53] *** rindolf joined
[10:00] *** dakkar joined
[10:01] *** rindolf left
[10:01] *** rindolf joined
[10:08] *** anuby left
[10:09] *** hypolin left
[10:12] *** SmokeMachine joined
[10:14] *** Tene joined
[10:14] *** Tene left
[10:14] *** Tene joined
[10:16] *** djanatyn joined
[10:19] *** xalbo joined
[10:43] *** kaleem left
[10:47] *** nuba left
[10:48] *** nuba joined
[11:06] *** Su-Shee_ joined
[11:08] *** Su-Shee left
[11:08] *** Su-Shee_ is now known as Su-Shee

[11:14] *** am0c left
[11:19] *** dayangkun left
[11:25] *** Targen left
[11:27] *** awwaiid joined
[11:28] *** jlaire left
[11:41] *** jlaire joined
[12:05] *** am0c joined
[12:26] <masak> wow, I really like the "can-cannot-must" format at the top of this page: http://www.tldrlegal.com/license/gnu-general-public-license-v2-(gpl-2)

[12:27] <masak> feels like that's a good format not just for exaplaining licenses, but to describe interfaces/software contracts as well.

[12:27] <FROGGS> indeed

[12:28] <FROGGS> feels like most of API documentation only covers 2/3

[12:31] <moritz> that's the beauty of design by contract

[12:31] <moritz> it makes it rather easy to formalize most of the pre- and postconditions of APIs

[12:34] <masak> I dunno, I can see the promise of it, but I haven't really seen it work well in practice yet.

[12:34] <masak> not saying it doesn't -- for all I know, it does -- but I haven't seen it.

[12:37] <moritz> I've had some positive experience with it with the Eiffel standard libraries

[12:38] <moritz> (oh, and I also think that one must support DBC to a level comparable to that of Eiffel for it to really make sense)

[12:42] *** alec left
[12:45] <jnthn> ugh, that $(...) regex fix looks wrong

[12:45] <moritz> (which in turn requires static typing, so nothing that Perl 6 will be able to do easily)

[12:45] <jnthn> I'm pretty sure in STD it falls out of the $ metachar rule

[12:45] <jnthn> r: /$(a+)/

[12:45] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/kmPXuAQl0x:1␤------> [32m/$[33m⏏[31m(a+)/[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤»

[12:46] <jnthn> r: / $( a+ ) /

[12:46] <p6eval> rakudo 6b0cea:  ( no output )

[12:46] <jnthn> std: / $( a+ ) /

[12:46] <FROGGS> jnthn: I'm working on it

[12:46] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/TyK9fOqN9Y line 1:␤------> [32m/ $( a+ [33m⏏[31m) /[0m␤Undeclared routine:␤   'a' used at line 1␤Parse failed␤FAILED 00:00 44m␤»

[12:46] <FROGGS> (right now)

[12:46] <jnthn> FROGGS: OK. Please see how STD does it.

[12:46] <jnthn> we should be staying as close to STD as reasonably possible.

[12:46] <jnthn> Apart from in the places STD is unreasonable :)

[12:47] <FROGGS> jnthn: ya, makes sense

[12:47] <moritz> masak: I also like the tldrlegal thing, but I can't help but notice that the most important difference between GPL v2 and v3 (patent stuff) doesn't show up in the summary

[12:51] <masak> hm, weird.

[12:51] <masak> maybe the most important difference is hard to summarize ;)

[12:53] <moritz> or maybe it's simply an omission

[12:56] <masak> by definition, yes ;)

[12:57] <jnthn> .oO( not so optimized for mission after all... )

[13:09] *** bluescreen__ left
[13:14] *** dayangkun joined
[13:26] *** Rix left
[13:27] *** Rix joined
[13:38] <masak> rn: class Greeter { has $.target; method greet { say "Hello $.target" } }; my $method = Greeter.can('greet')[0]; say $method.^name

[13:38] <p6eval> niecza v24-18-gaf64300: OUTPUT«Bool␤»

[13:38] <p6eval> ..rakudo 6b0cea: OUTPUT«Method␤»

[13:38] <masak> r: class Greeter { has $.target; method greet { say "Hello $.target" } }; my $method = Greeter.can('greet')[0]; say $method( Greeter.new(:target<World>) )

[13:38] <p6eval> rakudo 6b0cea: OUTPUT«Hello World␤True␤»

[13:38] <masak> r: class Greeter { has $.target; method greet { say "Hello $.target" } }; my $method = Greeter.can('greet')[0]; $method( Greeter.new(:target<World>) )

[13:38] <p6eval> rakudo 6b0cea: OUTPUT«Hello World␤»

[13:39] <moritz> "I think it is very interesting, but I don't have time to be interested in everything that's interesting"

[13:39] <masak> ;)

[13:40] <masak> I'm pondering which model I dislike the least, (1) a method can be unbound or bound, you can bind methods, and you can call bound methods, or (2) a method is a sub with one more parameter.

[13:41] <masak> both Python and Ruby have variants of (1), I believe.

[13:41] <masak> JavaScript has (2), except that the parameter is not a positional parameter.

[13:41] <masak> Perl 5 and Perl 6 have (2).

[13:42] <moritz> in javascript, the supplication of the invocant is somewhat magical, no?

[13:43] <masak> in JavaScript, every Function object has .apply and .call methods, with which you can supply the invocant manually.

[13:43] <masak> but usually, what you do is hide this with the obj.meth sugar.

[13:43] <masak> er, obj.meth()

[13:44] <masak> .apply and .call are only really necessary when you want to do library-internal "call the method on an unexpected object" magic.

[13:47] *** skids left
[13:56] *** Swarley_ joined
[14:00] *** bluescreen10 joined
[14:00] *** Swarley_ left
[14:01] *** hash_table joined
[14:07] *** hash_table left
[14:10] *** PacoAir joined
[14:12] *** atrodo joined
[14:15] *** PacoAir left
[14:15] *** PacoAir joined
[14:31] <[Coke]> I find myself using .apply/.call when construct jquery plugins.

[14:32] <[Coke]> (where 

[14:32] <[Coke]> oops

[14:34] <masak> essentially, because .apply does 'this' assignment and applies the function, .apply + anon function = .bind

[14:35] <masak> or, I should say function() { .apply } = .bind

[14:36] *** vividsnow joined
[14:36] *** SmokeMachine left
[14:39] *** SmokeMachine joined
[14:44] *** cog joined
[14:46] *** nyuszika7h left
[14:48] *** nyuszika7h_ joined
[14:49] *** nyuszika7h_ is now known as nyuszika7h

[14:52] *** cog left
[14:53] *** alec joined
[14:57] *** cog joined
[14:57] <cog> r: < a b >.WHAT

[14:57] <p6eval> rakudo 6b0cea:  ( no output )

[14:58] <PerlJam> cog: need a "say" in there.

[14:59] <cog> ho, I am so used to the shell that outputs the last expression result when nothing is explicitly printed

[14:59] <cog> r:  say < a b >.WHAT

[15:00] <p6eval> rakudo 6b0cea: OUTPUT«Parcel()␤»

[15:00] <cog> I wonder why this composer does not return a list.

[15:00] <moritz> why should it?

[15:01] <cog> well, why should not it?

[15:01] <moritz> you can push to a list, for example. What would be the sense in allowing  < a b >.push: 42  ?

[15:03] <moritz> http://doc.perl6.org/type/Parcel

[15:03] <moritz> http://doc.perl6.org/type/List

[15:03] <moritz> a Parcel is close to what other languages call a Tupel

[15:04] <cog> I did not realise how parcels are now everywhere in Perl  6

[15:07] *** stopbit joined
[15:10] *** skids joined
[15:15] *** cog left
[15:18] *** cog joined
[15:18] *** kaare_ joined
[15:22] *** cog left
[15:25] *** daniel-s left
[15:26] *** daniel-s joined
[15:28] *** hash_table joined
[15:30] *** SunilJoshi joined
[15:38] <jnthn> decommute &

[15:40] *** vividsnow left
[15:41] <masak> moritz: "tuple".

[15:42] <masak> cog: I see parcels as having to be there because in Perl 6, lists can either flatten or have fun with sublists and multidimensionality. as long as it is a parcel though, it's still in a superposition between these two states.

[15:43] *** mtk joined
[15:44] *** benabik left
[15:44] <[Coke]> masak... Great. I finally thought I was beginning to understand lists, and now this. :P

[15:45] <masak> :P

[15:46] <moritz> masak: but not all parcels flatten, a Parcel-in-an-Item does not

[15:46] <masak> the introduction of Parcels in S02 in fact very much supports this view. "not yet committed to flattening"

[15:46] <[Coke]> O_o;

[15:46] <moritz> [Coke]: don't let masak confuse you

[15:46] <masak> moritz: I thought that's what I said.

[15:46] <masak> moritz: it doesn't know yet whether it should flatten.

[15:46] <[Coke]> moritz:  you're not helping. :)

[15:47] <moritz> masak: oh, you're right

[15:47] * masak is right and the world is scary

[15:47] <moritz> masak: but the same is true for Lists and Arrays too

[15:47] *** arlinius joined
[15:47] <masak> fair enough.

[15:47] <moritz> masak: so we don't really need Parcels for the not-yet-committed-to-whether-we-flatten-or-not stuff

[15:48] <masak> oh! S02 also points out that the things in 'rhyme(1,2,3,:mice<blind>)' is syntactically a Parcel.

[15:49] <masak> (but the compiler collapses it down to a Capture)

[15:49] <masak> rn: my $args = \(1,2,3,:mice<blind>); say $args.^name

[15:49] <p6eval> rakudo 6b0cea, niecza v24-18-gaf64300: OUTPUT«Capture␤»

[15:59] *** fgomez left
[16:01] *** dayangkun left
[16:02] *** dayangkun joined
[16:04] *** fhelmberger left
[16:08] *** Pleiades` left
[16:11] <kresike> bye folks

[16:11] *** kresike left
[16:13] *** Pleiades` joined
[16:28] *** vividsnow joined
[16:29] *** FROGGS left
[16:29] *** FROGGS[mobile] joined
[16:31] *** Targen joined
[16:33] *** fgomez joined
[16:39] *** kaleem joined
[16:41] *** hoelzro is now known as hoelzro|away

[16:41] *** kivutar joined
[16:46] <japhb> masak, re: tldrlegal, I like the reverse search feature (though the UI needs a bit of tweaking), and the "click anywhere in background of front page to get a tour" feature.  I don't like the opening to this:  http://www.tldrlegal.com/license/artistic-license-2.0-%28artistic%29

[16:50] *** FROGGS joined
[16:51] *** Swarley_ joined
[17:02] *** Pleiades` left
[17:08] *** Pleiades` joined
[17:15] *** kaleem left
[17:23] <timotimo> what's weird about ti? :\

[17:28] *** SunilJoshi left
[17:29] *** Pleiades` left
[17:34] *** Pleiades` joined
[17:36] *** vividsnow left
[17:40] *** Chillance joined
[17:52] *** zby_home joined
[17:55] *** SamuraiJack joined
[18:01] *** vividsnow joined
[18:05] *** dakkar left
[18:08] *** MayDaniel joined
[18:09] *** am0c left
[18:16] *** vividsnow left
[18:19] <[Coke]> . o O (It's so quiet)

[18:19] <dalek> perl6-roast-data: e386aae | coke++ | / (4 files):

[18:19] <dalek> perl6-roast-data: today (automated commit)

[18:19] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e386aaec51

[18:20] *** arlinius left
[18:20] <[Coke]> sorear, colomon : S05-substitution/subst.niecza aborted 136 test(s)

[18:21] <timotimo> [Coke]: maybe you have an error that doesn't have enough information that i could improve? :P

[18:22] <timotimo> or i could really try to tackle the optimisation of the junction operators for constants+variables?

[18:23] <[Coke]> r: cool

[18:23] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    cool used at line 1␤␤»

[18:23] <[Coke]> r: cool $it

[18:23] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$it' is not declared␤at /tmp/HmvZBgIBG8:1␤------> [32mcool $it[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[18:23] <[Coke]> r: my cool $it

[18:23] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my␤at /tmp/NY49iPNMRw:1␤------> [32mmy [33m⏏[31mcool $it[0m␤    expecting any of:␤        scoped declarator␤»

[18:24] <[Coke]> timotimo: I have a recent RT that masak opened for me that could use some love.

[18:24] <[Coke]> other than that, I don't have any guidance for you atm.

[18:27] <[Coke]> r: given say take uc

[18:27] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/DH7UIbc212:1␤------> [32mgiven say take uc[33m⏏[31m<EOL>[0m␤    expecting any of:␤        argument list␤        postfix␤        infix or meta-infix␤        infix stopper␤        parameterized block␤»…

[18:29] <timotimo> improving those doesn't seem trivial enough for me :P

[18:30] <[Coke]> timotimo: eh, I'm just playing. "my cool $it" seems like the most likely to be improved by getting "Cool" suggested.

[18:30] <[Coke]> r: my Barf $it

[18:30] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my␤at /tmp/Zs8LQOzGNv:1␤------> [32mmy [33m⏏[31mBarf $it[0m␤    expecting any of:␤        scoped declarator␤»

[18:30] <[Coke]> r: my enum $it

[18:30] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my␤at /tmp/RS7ABPuOiv:1␤------> [32mmy enum $it[33m⏏[31m<EOL>[0m␤    expecting any of:␤        scoped declarator␤»

[18:34] *** SmokeMachine left
[18:45] *** jlaire left
[18:45] *** japhb_ left
[18:46] *** kivutar left
[18:47] *** fgomez left
[18:49] *** cog joined
[18:50] *** SamuraiJack left
[18:50] *** jlaire joined
[18:53] <timotimo> right, that should definitely happen.

[18:57] *** xinming left
[18:58] <timotimo> i wonder how i can handle that, though. from afar it looks like it's already happening in the parsing stage, before any action has been called, so i may have to plug in a closure before the "malformed my" gets emitted that checks if the type is typo'd

[18:59] *** SmokeMachine joined
[19:01] *** snearch joined
[19:03] *** xinming joined
[19:04] *** Swarley_ left
[19:07] *** benabik joined
[19:08] <timotimo> strangely, i can't seem to find the place where malformed my is thrown

[19:09] <timotimo> oh, it seems i can get a traceback for it, though

[19:11] <timotimo> r: my Foo $a; class Foo { };

[19:11] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my␤at /tmp/2Ol0MwAf_Y:1␤------> [32mmy [33m⏏[31mFoo $a; class Foo { };[0m␤    expecting any of:␤        scoped declarator␤»

[19:11] <timotimo> ah, so at that point, the type name must already be known. good to know.

[19:16] *** japhb_ joined
[19:17] * timotimo tests the first patch

[19:18] <mathw> Hello!

[19:18] <timotimo> std: my Foo $a; class Foo { };

[19:18] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤In my declaration, typename 'Foo' must be predeclared (or marked as declarative with :: prefix) at /tmp/ehex2PkHnA line 1:␤------> [32mmy Foo[33m⏏[31m $a; class Foo { };[0m␤Malformed my at /tmp/ehex2PkHnA line 1:␤------> [32mmy [3…

[19:18] <timotimo> i wonder if it would be okay to parse the future of the document to look for post-declared classes and suggest them?

[19:20] <TimToady> sure, all is fair in the quest for good error messages, once you know it's gonna blow up anyway

[19:20] <timotimo> the first idea that comes to mind is pretend we succeeded and use the mystery mechanism that's already in place

[19:22] <TimToady> might work

[19:22] <timotimo> first i'll have to get this typo_longname token to work properly, though

[19:22] <TimToady> or go ahead and introduce a poisoned symbol, then recall <scoped>

[19:23] <TimToady> by the end of the unit we can tell whether they typo'd or meant to postdeclare the unpostdeclarable

[19:24] <TimToady> as long as we don't accidentally accept the program, we're golden

[19:25] <TimToady> errand &

[19:25] <skids> What do we do if a user has put some IO work in a BEGIN block or whatnot?

[19:26] <TimToady> no compiler can fix or even detect all the erroneous code in the world

[19:27] <TimToady> that's why we have the category "erroneous" in the first place

[19:27] <skids> Ah so "don't do that".  Sounds fine.

[19:27] <timotimo> are BEGIN phasers run before the parse has finished?

[19:28] <TimToady> they are run the moment the BEGIN's code is done parsing

[19:28] <TimToady> obviously they cannot refer to anything postdeclared

[19:28] <timotimo> oh, ok

[19:29] <TimToady> likewise macro calls

[19:30] <skids> I guess now that pragmas and such are scoped to the unit we don't have to worry about use statements so much.

[19:33] <masak> mathw! \o/

[19:33] *** Chillance left
[19:34] *** Chillance joined
[19:36] *** MikeFair__ joined
[19:42] <timotimo> to be honest, i'm not quite sure how to work this :|

[19:42] <timotimo> i'm trying to maoh, maybe there's whitespace i should be matching!

[19:42] *** MikeFair left
[19:46] <timotimo> great! that fixed it and now suggestions are emitted if possible

[19:55] <[Coke]> maoh?

[19:55] *** bluescreen100 joined
[19:55] <timotimo> i think i was in the middle of typing "i'm trying to match longname", and then got the idea thet led me to the road towards victory! :)

[19:57] <[Coke]> oh!

[19:57] *** ifim joined
[19:58] <masak> mid-word insight. :)

[19:58] *** bluescreen10 left
[19:58] <timotimo> huh, this is strange. a call on nqp::join("\n    ", @.suggestions) in X::Undeclared.message fails with "elements() not implemented in class 'Array'", but the same code works no-problemo a few lines above it in my token typo_longname - probably because the one is actually nqp and the other one is perl6 code in the setting

[19:59] <timotimo> i wonder if other parts that sahre the undeclared exception and the suggest_* methods from World suffer from the same problem (and i also wonder how it should be fixed)

[19:59] <moritz> @.suggestions looks very much like Perl 6 to me, not nqp

[19:59] <timotimo> r: class C is cool { };

[19:59] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤'C' cannot inherit from 'cool' because it is unknown.␤Did you mean one of these?␤    'Cool'␤    'Bool'␤␤at /tmp/y9zneb_waZ:1␤------> ␤»

[19:59] <moritz> if that's the case, just use its .join method

[19:59] <timotimo> OK.

[20:02] <timotimo> ah, great!

[20:05] *** sqirrel left
[20:09] * timotimo spectests

[20:14] *** SmokeMachine left
[20:27] *** spider-mario joined
[20:28] *** benabik left
[20:30] *** benabik joined
[20:31] <timotimo> huh, whenever there are no suggestions, i seem to be getting "null pmc access in invoke()" when i do "if nqp::elems(@suggestions) > 0 { ... }" but i've tried to make sure @suggestions gets initialised to [] if nothing gets added to it

[20:32] <timotimo> r: class C is uideatrniudtraneudtrainedtriuane {};

[20:32] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤'C' cannot inherit from 'uideatrniudtraneudtrainedtriuane' because it is unknown.␤at /tmp/yE6hidtEWJ:1␤------> ␤»

[20:32] *** benabik left
[20:32] *** benabik joined
[20:33] <timotimo> but +@l seems to work. not sure why i didn't have that before.

[20:36] <timotimo> no, that doesn't actually help. now i'm confused :|

[20:36] <moritz> is @suggestions a nqp or a Perl 6 array?

[20:37] <timotimo> i created it inside nqp code, in a method of World, using my @suggestions; (and later: my @suggestions := [];)

[20:40] <timotimo> maybe i have to use nqp::elems in the grammar token that creates suggestions and wrap it into a perl6 list before throwing the Undeclared exception?

[20:41] *** FROGGS[mobile] left
[20:42] <moritz> now I'm confused

[20:42] <timotimo> as am i

[20:42] <moritz> at the point where you're writing nqp::elems(@suggestions), what is @suggestions?

[20:42] <moritz> is it an Array (Perl 6)?

[20:42] <moritz> or is it a ResizablePMCArray (nqp/parrot)?

[20:43] <timotimo> i think it's a ResizablePMCArray

[20:43] <timotimo> well, pretty sure, i saw an error about that class when i tried .elems()

[20:44] <moritz> and are you sure that the "null pmc access in invoke()" actually comes from the nqp::elems call?

[20:44] <moritz> and not from something inside the if block, for example?

[20:44] <timotimo> somewhat sure, but let me try something else real quick

[20:44] <timotimo> i may not even need the if statement

[20:44] <GlitchMr> masak: just wondering, when the "Tell knights from knaves based on what they say." task blog post will appear.

[20:45] <GlitchMr> I'm wondering what others have done (I already know my entries are bad)

[20:46] <masak> thank you for your interest.

[20:46] <masak> I'll start doing the reviewing in the weekend.

[20:46] <masak> we'll see how far I get. :)

[20:46] <timotimo> masak: i'm also interested! decided not to pester you ;)

[20:47] <masak> heh.

[20:47] <masak> GlitchMr: why do you say your entries are bad? didn't you say in one of the weekly updates that the p6cc problems were easy? :P

[20:47] <GlitchMr> I did?

[20:48] <masak> anyhoo, I'm happy there's general interest.

[20:48] <GlitchMr> Whatever.

[20:48] <masak> "By the way, if you don’t know about Perl 6 Coding Contest, check it out. The challenges are rather easy if you had any programming language experience"

[20:49] <masak> I read that and thought "...wut?" ;)

[20:49] <GlitchMr> They appeared to me to be easier than 2011 challenges.

[20:49] <GlitchMr> Or perhaps they are just more interesting.

[20:50] <timotimo> hm, are you aware of the "amb" operator? the one where you give a bunch of options and you get the right one out if there's a right answer?

[20:50] <masak> I believe they were a bit easier than the 2011 challenges.

[20:50] <timotimo> is that easily doable in perl6?

[20:50] <masak> timotimo: yes, I'm aware of it.

[20:50] <masak> timotimo: you should check out nothingmuch's implementation on CPAN.

[20:50] <masak> (and his blog posts about it)

[20:50] <masak> timotimo: no, there's no easy/nice way that I know of.

[20:51] <masak> timotimo: closest we've got is TimToady++ simulating amb through the backtracking of grammars ;)

[20:51] <GlitchMr> http://rosettacode.org/wiki/Amb

[20:51] <masak> GlitchMr++

[20:51] <moritz> I think that's on rosettac... what GlitchMr said

[20:52] <masak> "At some point we'll wrap this up in nice syntax to let people write in a sublanguage of Perl 6 that looks more like a logic language."

[20:52] <masak> promises, promises. ;)

[20:53] <masak> when is Perl 6 gonna be released already!? </troll>

[20:53] *** rindolf left
[20:55] <timotimo> :)

[20:55] *** bluescreen__ joined
[20:56] <timotimo> "all tests successful", I enjoy reading that

[20:57] * [Coke] hopes masak is checking for extensions of the grammar!

[20:57] <[Coke]> (for t1)

[20:57] * [Coke] does wish he had spent another hour cleaning up his t1 solution, but thinks it's "ok"

[20:59] <timotimo> huh, why does this already work?!

[20:59] <timotimo> that's pretty cool.

[20:59] *** bluescreen100 left
[20:59] <timotimo> r: sub foo(cool $a) { };

[20:59] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invalid typename 'cool' in parameter declaration. Did you mean 'Cool', 'Bool'?␤at /tmp/MbYJ1YhVWm:1␤------> [32msub foo(cool[33m⏏[31m $a) { };[0m␤»

[20:59] <GlitchMr> For some reason I bet that some code submitted to masak's contest will have code like if (...) { ... } and masak will complain about parens.

[20:59] <timotimo> oh, i already implemented this some time ago? or maybe someone else did.

[20:59] *** rindolf joined
[20:59] <GlitchMr> timotimo: You did

[21:00] <GlitchMr> http://glitchmr.github.com/helpful-error-messages.html

[21:00] <moritz> timotimo: I guess there's some special case about expecting a typename rather than a callable as the first thing in a parameter name

[21:00] <GlitchMr> I even wrote a blog post about that feature

[21:00] <timotimo> GlitchMr: :)

[21:00] <GlitchMr> r: sub a($CopyPasta) { $copyPasta }

[21:00] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$copyPasta' is not declared␤at /tmp/SY5Tr0VYZO:1␤------> [32msub a($CopyPasta) { $copyPasta[33m⏏[31m }[0m␤    expecting any of:␤        postfix␤»

[21:00] <timotimo> that's how you know that you're making an impact on the world

[21:01] <GlitchMr> r: sub a($CopyPastam) { my $CopyPasta = $CopyPastam; $copyPasta }

[21:01] <timotimo> ah, that doesn't work yet?

[21:01] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$copyPasta' is not declared. Did you mean '$CopyPasta'?␤at /tmp/J1qsScxR9U:1␤------> [32m my $CopyPasta = $CopyPastam; $copyPasta[33m⏏[31m }[0m␤    expecting any of:␤        postfix␤»

[21:01] <GlitchMr> timotimo: However, I would like the sub a($CopyPasta) { $copyPasta } to work.

[21:01] <GlitchMr> For some reason, your code doesn't see function arguments.

[21:01] <timotimo> yup, ditto

[21:01] <timotimo> maybe because they're incomplete at that time?

[21:02] *** nnunley joined
[21:05] <timotimo> r: sub foo(--> Strnig) { "a" }

[21:05] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/eT5GuJA09q:1␤------> [32msub foo(--> [33m⏏[31mStrnig) { "a" }[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be defined␤»…

[21:05] <timotimo> that still needs to be fixed, too. i'll do that first

[21:05] * jnthn is home :)

[21:05] <jnthn> evening o/

[21:05] <nwc10> yay!

[21:06] <moritz> \o jnthn 

[21:06] <jnthn> hi moritz :)

[21:06] <jnthn> timotimo: fwiw, I think the undeclared type thing you're looking at may be best handled through the MYSTERY mechanism.

[21:07] *** hash_table left
[21:09] <timotimo> jnthn: excuse me, which one exactly?

[21:10] <jnthn> I only implemented it, not remembered where it went :P

[21:10] <timotimo> i meant to ask, which undeclared type thing was i looking at?

[21:10] <jnthn> ah, yeah, search for %*MYSTERY

[21:10] <timotimo> i've seen MYSTERY, i've enhanced it with suggestion code, too ;)

[21:10] <jnthn> the "my Foo $x" one, I thought?

[21:10] <timotimo> ah, yeah i could certainly do that

[21:10] <timotimo> especially since it doesn't die instantly

[21:11] <jnthn> Yeah, for those things we can afford to just be sorry rather than panic :)

[21:13] * jnthn wonders why masak is so hysterical in rakudobugs these days :/

[21:13] <masak> I AM!?!?!

[21:14] <jnthn> "omgz it's 2013 and X broke!"

[21:14] <jnthn> "state variables are seriously broken 'cus a weird edge case doesn't work!"

[21:14] <masak> yes, let's rename that one.

[21:14] <timotimo> jnthn: what 'ctx' parameter should i pass? :\

[21:15] <jnthn> lemme remember what ctx is :)

[21:15] <timotimo> :D

[21:15] <timotimo> sometimes 'termish', sometimes 'var'

[21:16] <jnthn> yeah

[21:16] <masak> jnthn: it's now "[BUG] 'state' with anonymous scalars works more like 'my' in Rakudo"

[21:17] <masak> jnthn: thank you for your feedback. I'll try to be less alarmist next time something regresses in Rakudo.

[21:17] <jnthn> masak: I suspect it may be a one line fix or so

[21:17] <timotimo> is it only a use/declare distinction or something? to find out if the thing was post-declared?

[21:17] <jnthn> timotimo: I don't actually see it being used.

[21:17] <timotimo> that's right.

[21:18] <jnthn> Yeah, it looks unused to me. OK, next qestion...I copied it from STD, so what does STD use it for :)

[21:18] <jnthn> masak: Typically they mean "we're missing a test"

[21:19] <jnthn> timotimo: oh...

[21:19] <jnthn> timotimo: It's used in an error message we didn't implement yet.

[21:19] <jnthn> see infix:lambda in STD

[21:19] <jnthn> timotimo: The only think it cares about is whether it's ( or not :)

[21:20] <jnthn> Anyway, put the rule name in :)

[21:20] <jnthn> (scoped or so)

[21:20] <timotimo> OK

[21:20] <jnthn> *thing

[21:20] <timotimo> well, this time it's in a sub-rule, i made a token typo_typename

[21:21] <jnthn> timotimo: Is there a reason to do that and not the way STD does it, ooc?

[21:21] <jnthn> Looking at STD though, it doesn't use mystery for it.

[21:21] <jnthn> But it does call sorry

[21:22] <timotimo> er, dunno

[21:23] <timotimo> hm, throwing a X::Undeclared is worse than a sorry, right?

[21:23] <jnthn> std: my OMGBBQ $x;

[21:23] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤In my declaration, typename 'OMGBBQ' must be predeclared (or marked as declarative with :: prefix) at /tmp/P_V9hlirtc line 1:␤------> [32mmy OMGBBQ[33m⏏[31m $x;[0m␤Malformed my at /tmp/P_V9hlirtc line 1:␤------> [32mmy [33m⏏[31mO…

[21:23] <jnthn> timotimo: I'd rather not use $*W.throw directly, use .typed_sorry or so.

[21:23] <timotimo> right, sorry spits out an error, but continues parsing, isn't that right?

[21:23] <jnthn> Yes, but it's still fatal.

[21:23] <jnthn> That is, we keep parsing.

[21:24] <timotimo> i could surely do that. first i'll test if my use of the mystery mechanism was correct

[21:24] <jnthn> But we don't consider the program OK.

[21:24] <jnthn> If we panic we report the sorrows up to that point

[21:24] <jnthn> And if not we panic with the sorrows :)

[21:25] <japhb_> There's something very poetic about those last two statements, jnthn 

[21:25] *** skids left
[21:26] <PerlJam> japhb_: it reminded me of Metallica's  "Harvester of Sorrow"

[21:26] <jnthn> japhb_: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.pm#L727 :)

[21:26] *** swarles joined
[21:27] <swarles> LoL	􏿽xB1  ?

[21:27] <swarles> what is that feature?

[21:27] <japhb_> Oooh, Metallica.  I may have to listen to Map of Metal today

[21:27] <swarles> I would hope it's not "laughing out loud"

[21:27] <jnthn> List of List

[21:27] <japhb_> swarles, List of Lists

[21:27] <swarles> ah. So like, [[1,2,3],[1,2,3],[1,2,3]]?

[21:28] <japhb_> $*SORRY_LIMIT ... # when sorrow turns to panic

[21:28] <japhb_> very nice

[21:28] <swarles> And dare I ask what a shaped array is?

[21:28] <japhb_> swarles, when you know the size of every dimension

[21:28] <swarles> Oh.

[21:28] <japhb_> Er, to a first approximation

[21:28] <swarles>  Is that just an optimization thing?

[21:29] <swarles> Like, a tuple in a way. Just with variable size?

[21:29] <swarles> Err, not variable

[21:29] <swarles> Variable in the sense of the prefix to that word changes

[21:29] <japhb_> "multi-dimensional"?

[21:30] <PerlJam> swarles: my int @foo[42];   # shaped to suit the universe

[21:30] <swarles> ah

[21:30] <swarles> That makes sense.

[21:30] <timotimo> jnthn: the mystery mechanism doesn't seem to have worked, at least not the way i tried it

[21:30] <jnthn> timotimo: Yeah, now I see that STD already handles it with sorry, I think we stick with an approach like that. :)

[21:30] <PerlJam> timotimo: maybe you need to call in Shaggy and Scooby?

[21:31] <japhb_> swarles, search for 'shaped' in the specs.  :-)

[21:31] <timotimo> :)

[21:31] <swarles> Yeah, I found the spec page. I'm pretty sure I understand it now

[21:32] <japhb_> swarles, I recommend cloning the specs repo and using 'git grep' for great justice.

[21:32] <swarles> Impressive, rakudo seems a lot closer to complete implementation than the last time i checked if my memory served (Probably doesn't)

[21:32] <swarles> Oh right, that's what I was doing

[21:33] * swarles goes back to setting up gentoo in vmware

[21:33] <japhb_> <mr_burns>Excellent ...</mr_burns>

[21:33] <swarles> I lost track of time goofing off while stage-3 was extracting

[21:35] <swarles> -O2 -pipe -fomit-frame-pointer -march=native ... am I missing anything?

[21:37] <masak> japhb_: you're not supposed to use tags with style information. :P

[21:37] *** snearch left
[21:38] * masak ponders the semantic way of doing that

[21:39] <timotimo> i'm having trouble using typed_sorry :|

[21:40] <[Coke]> <i data-voice="Mr. Burns">Excellent &hellip;</i>

[21:40] <timotimo> i get a null pmc access in invoke() again when i use it. i'll revert to $*W.throw for the time being

[21:40] <timotimo> [Coke]: the i tag isn't better, try <emph>

[21:42] <[Coke]> timotimo: I will yield to practicality on that one, being able to use a one char tag.

[21:42] <masak> [Coke]++ # semantic

[21:44] * swarles waits for portage to update

[21:45] *** benabik_ joined
[21:45] *** benabik left
[21:45] *** benabik_ is now known as benabik

[21:46] * timotimo makes a clean build and spectests again

[21:47] *** benabik left
[21:49] *** kivutar joined
[22:00] *** fgomez joined
[22:11] <jnthn> Hm, why does Rakudo spectest take so long these days...

[22:11] <cog> r:  my  ($abe, $ba, $abc); $abd

[22:11] <p6eval> rakudo 6b0cea: OUTPUT«===SORRY!===␤elements() not implemented in class 'Array'␤»

[22:12] <jnthn> wtf

[22:12] <cog> :)

[22:12] <jnthn> r: $abd

[22:12] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$abd' is not declared␤at /tmp/z9dcbwFIBG:1␤------> [32m$abd[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[22:12] <jnthn> r: my $abc; $abd

[22:12] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable '$abd' is not declared. Did you mean '$abc'?␤at /tmp/f4G3CuM6e1:1␤------> [32mmy $abc; $abd[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤»

[22:12] * masak submits rakudobug

[22:12] <jnthn> r: my $abc; my $abe; $abd

[22:12] <p6eval> rakudo 6b0cea: OUTPUT«===SORRY!===␤elements() not implemented in class 'Array'␤»

[22:12] <jnthn> *sigh*

[22:12] <cog> problem is with many approximate candidates with the levenstein distance

[22:13] <cog> nice code btw. :)

[22:13] <masak> cog++

[22:13] *** cog is now known as cognominal

[22:14] <timotimo> jnthn: my suggestion code breaking?

[22:14] <jnthn> The rule is simple. If you're writing Perl 6 code and refer to something with an @, NEVER use nqp:: stuff on it!

[22:14] <timotimo> since i'm at it right now anyway, ...

[22:14] <jnthn> timotimo: I think so.

[22:14] <timotimo> works locally, so when my branch gets pushed to the next time, i'll send the pull-request

[22:14] <jnthn> OK

[22:15] <timotimo> spectesting at this precise moment

[22:16] <timotimo> r: Whaetver.new(); # fixed this locally, too

[22:16] <p6eval> rakudo 6b0cea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    Whaetver used at line 1␤␤»

[22:16] <timotimo> (fixed == added suggestions)

[22:16] <jnthn> We only ever invoke the levenstein to generate errors, yes?

[22:16] <timotimo> yes, that's right

[22:16] <jnthn> OK

[22:17] <timotimo> sigh, test failure

[22:17] <jnthn> I need to figure out where the performance regression has come from...

[22:17] <jnthn> spectest taking 30-40 seconds longer is a problem.

[22:17] *** MayDaniel left
[22:19] <timotimo> got rid of the last failure.

[22:23] *** zby_home left
[22:23] <timotimo> the pull request is up in case someone wants to review it

[22:24] *** kivutar left
[22:25] <jnthn> timotimo: oh, weird

[22:25] <jnthn> https://github.com/timo/rakudo/commit/9a889fdda2ecaa8058694cecf64fd53e10ad637a

[22:25] <jnthn> We have:

[22:25] <jnthn> $/.CURSOR.sorry("In \"$*SCOPE\" declaration, typename $t must be predeclared

[22:25] <jnthn> ...

[22:25] <jnthn> That should be catching the error you've added handling for

[22:26] <timotimo> yes, i wasn't sure why i didn't see that particular error at all

[22:26] <jnthn> I'd rather that was figured out before merging this

[22:26] <timotimo> ah, because it's missing the <.ws> at the beginning i bet

[22:26] <timotimo> i'll try that

[22:27] <jnthn> OK, we don't need both.

[22:27] <jnthn> And your suggest-y handling is nicer :)

[22:27] <timotimo> do you prefer mine? :)

[22:27] <jnthn> Kinda

[22:27] <jnthn> The suggestions are good

[22:27] *** raiph joined
[22:27] <jnthn> But I don't like it using $*W.throw

[22:27] <timotimo> should i add a <?before [A..Z]> for mine, too?

[22:27] <jnthn> Yes, it's a good heuristic.

[22:28] <timotimo> can you see how to properly throw a sorry using not $*W.throw?

[22:28] <jnthn> $/.CURSOR.typed_sorry should be possible instead of $*W.throw

[22:28] <timotimo> i tried self.typed_sorry, but that didn't work at all

[22:28] <timotimo> right, i'll try that

[22:28] <jnthn> sorry doesn't throw immediately

[22:28] <jnthn> It tries to parse a bit further

[22:28] <jnthn> Which can help us find other errors and tell the user about them together.

[22:30] <timotimo> yes, adding the <.ws> indeed makes that sorry happen

[22:30] <jnthn> OK :)

[22:30] <timotimo> should i add a <!>, too?

[22:30] <jnthn> 275278 doesn't have the performance regression

[22:30] <ifim> gklew

[22:31] <jnthn> timotimo: yes, plesae. Please try and keep us close to STD.

[22:31] <jnthn> timotimo: Being 100% matching with STD isn't a goal, but we should try and get the same parse that it does.

[22:35] <timotimo> wow, that was unhelpful

[22:35] <timotimo> immediately after the suggestion, it falls back into the "malformed my" error

[22:35] <timotimo> i wonder if it would continue a lot, though?

[22:36] *** kaare_ left
[22:36] <jnthn> std: my OMG $x;

[22:36] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤In my declaration, typename 'OMG' must be predeclared (or marked as declarative with :: prefix) at /tmp/j1PRILbzCm line 1:␤------> [32mmy OMG[33m⏏[31m $x;[0m␤Malformed my at /tmp/j1PRILbzCm line 1:␤------> [32mmy [33m⏏[31mOMG $x;…

[22:36] <timotimo> the new commit is there

[22:36] <jnthn> timotimo: That's what STD does.

[22:37] <timotimo> that's what rakudo does, now, too

[22:37] * timotimo runs spectests just to be extra sure

[22:37] <jnthn> Thanks :)

[22:38] <timotimo> sure, no worries (or sorrows or panics)

[22:42] <timotimo> did you check what test exactly takes longer? has S32-io/IO-Socket-Inet always been this slow?

[22:42] <jnthn> timotimo: My current hypothesis is that it's not the tests but a change in Rakudo

[22:43] <jnthn> (making all tests run a bit slower and thus the total time longer)

[22:43] <timotimo> mhm

[22:43] <jnthn> I'm curerntly trying to figure out if the repr compose stuff I changed is something to do with it.

[22:43] <jnthn> If it is, then I'm gonna be rather surprised.

[22:44] *** bluescreen__ left
[22:44] <jnthn> Will have the numbers on that soon

[22:45] * [Coke] wonders if he should think about trying to capture test run times in the daily roast run.

[22:45] * [Coke] imagines that's less than helpful, as both tests and impls are changing.

[22:45] * [Coke] heads home

[22:46] <jnthn> Hm, doesn't seem it was that

[22:49] *** stopbit left
[22:50] <timotimo> jnthn: the spectest succeeded without errors. i'll push new spectests after the pull request has been merged

[22:58] <jnthn> [ '-->' <.ws> <typename> || '-->' <.ws> <typo_typename> ]?

[22:58] <jnthn> I'm wondering if that shouldn't be

[22:58] <jnthn> [ '-->' <.ws> [ <typename> || <typo_typename> ] ]?

[22:58] <timotimo> i can easily change that. shouldn't make a difference

[22:58] <jnthn> I guess it's equivalent...

[22:59] <timotimo> if you want, i'll change it, test it quickly and commit again

[22:59] <jnthn> Don't worry about it, I think it'll be OK

[22:59] <timotimo> OK :)

[22:59] <jnthn> I mean, feel free to do it but it won't stop me merging this unless I find anything else wrong...

[23:00] <dalek> rakudo/nom: 014f8ca | (Timo Paulssen)++ | src/core/Exception.pm:

[23:00] <dalek> rakudo/nom: use @.suggestions.join instead of nqp::join.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/014f8ca25a

[23:00] <dalek> rakudo/nom: 9a889fd | (Timo Paulssen)++ | src/Perl6/Grammar.pm:

[23:00] <dalek> rakudo/nom: add a token typo_typename and use it in "my" declarations.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a889fdda2

[23:00] <dalek> rakudo/nom: 0ceef80 | (Timo Paulssen)++ | src/Perl6/Grammar.pm:

[23:00] <dalek> rakudo/nom: throw the sorry anyway, since we did match a longname.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ceef80c89

[23:00] <dalek> rakudo/nom: b97fb88 | (Timo Paulssen)++ | src/Perl6/Grammar.pm:

[23:00] <dalek> rakudo/nom: suggest names for --> Unknown, too.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b97fb88ecb

[23:00] <dalek> rakudo/nom: 25d87ef | (Timo Paulssen)++ | src/ (2 files):

[23:00] <dalek> rakudo/nom: suggest Types, too for Undeclared::Symbols.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25d87ef49c

[23:00] <dalek> rakudo/nom: 0ae1e8d | (Timo Paulssen)++ | src/Perl6/Grammar.pm:

[23:00] <dalek> rakudo/nom: throw a sorry instead of an exception, remove old error.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ae1e8d5f0

[23:00] <dalek> rakudo/nom: 1553b11 | jonathan++ | src/ (2 files):

[23:00] <dalek> rakudo/nom: Merge pull request #100 from timo/typename_suggestions

[23:00] <dalek> rakudo/nom: 

[23:00] <dalek> rakudo/nom: Typename suggestions: in signatures, declarations, return types, ...

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1553b11cb9

[23:00] <timotimo> heh, spammmmm :)

[23:00] <timotimo> thank you

[23:00] <timotimo> here's the corresponding spectests

[23:00] <jnthn> thanks for working on this :)

[23:01] <dalek> roast: 73618a5 | (Timo Paulssen)++ | S32-exceptions/misc.t:

[23:01] <dalek> roast: "my cool $a" -> X::Undeclared + suggestions

[23:01] <dalek> roast: review: https://github.com/perl6/roast/commit/73618a57ae

[23:01] <dalek> roast: cc878f5 | (Timo Paulssen)++ | S32-exceptions/misc.t:

[23:01] <dalek> roast: check for Type suggestions in Undeclared::Symbols.

[23:01] <dalek> roast: review: https://github.com/perl6/roast/commit/cc878f5b44

[23:01] <dalek> roast: b059711 | (Timo Paulssen)++ | S32-exceptions/misc.t:

[23:01] <dalek> roast: undeclared types in my are now Come::Group.

[23:01] <dalek> roast: review: https://github.com/perl6/roast/commit/b0597114b8

[23:02] <timotimo> hm, it would be nice if someone put more LHF into LHF.markdown, or give it a general work-over. the lines are from 2011-06 through 2011-07

[23:02] <timotimo> (although i don't very much care for the contents of that file)

[23:05] <jnthn> OK, b49cbe0 lacks the performance regression also

[23:06] *** kshannon joined
[23:07] <timotimo> huh, only commits from me remain :|

[23:07] <timotimo> or the nqp version bump perhaps

[23:08] <jnthn> oh, I've done all the tests against nqp master

[23:08] <timotimo> huh, strange.

[23:08] <jnthn> I'm wondering if somehow my system was highly loaded when I did the first test with some unkown process

[23:11] <timotimo> can i specifically refer to things from the setting? like a fully qualified name?

[23:11] *** cognominal left
[23:12] <jnthn> CORE:: 

[23:12] <jnthn> Or SETTING::

[23:12] <jnthn> Depending on how you define setting

[23:12] <timotimo> ah, indeed.

[23:12] <timotimo> i probably mean CORE, i think.

[23:13] <jnthn> It's starting to look like my extra-long spectest run was bogus. :(

[23:13] <jnthn> Well, :) in the sense we don't have a big performance regression though...

[23:14] <jnthn> There's only two of your commits and neither of them looks like it could possibly be to blame.

[23:14] <timotimo> those are the best kind of problems ;)

[23:15] <timotimo> so, i'm trying to get the optimiser to improve junctions where all values are known at compile time and i'm trying to identify if the | or ~ that's in use at that point is the one from CORE. i suppose find_lexical("CORE") was a foolish idea - what do i do instead?

[23:17] <jnthn> "~"? Did you mean "&"?

[23:17] <timotimo> er, yes

[23:17] <jnthn> phew :)

[23:17] <timotimo> or sometimes ^

[23:17] *** cognominal joined
[23:18] <timotimo> the qast that rakudo spits out when i write just CORE::infix<|>(1, 2, 3) is somewhat unhelpful somehow :|

[23:19] <jnthn> yes, I was just trying to figure out what we compile those forms too... :)

[23:19] <timotimo> :D

[23:19] <timotimo> glad to see i'm not the only one who's confused

[23:19] <timotimo> apparently it creates a new PseudoStash and looks it up in there? that's strange to me.

[23:20] <jnthn> ah, yeah

[23:20] <jnthn> Yeah, it makes sense. But it's not so helpful in the optimizer.

[23:21] <jnthn> Though you can potentially do it.

[23:21] *** LordVorp left
[23:21] <jnthn> find the PseudoPackage symbol

[23:21] <jnthn> oh wait

[23:21] <jnthn> That won't work at all :)

[23:21] <timotimo> it's good i didn't even try yet! :)

[23:22] * masak .oO( "Find the PseudoPackage symbol". boringest family game of 2012 )

[23:22] <timotimo> masak: for long car rides? :)

[23:22] <masak> "are we pseudo-there yet?"

[23:23] <jnthn> masak: tbh, pin that tail on the cons cell wasn't much more interesting...

[23:23] <masak> :D

[23:23] <timotimo> :D

[23:24] <masak> though even that was better than "replace the return trip with a continuation".

[23:24] <jnthn> timotimo: oh, I know

[23:24] <jnthn> timotimo: The CORE setting context has a magical lexical called "!CORE_MARKER" installed in it.

[23:25] <timotimo> ooooh

[23:25] <jnthn> timotimo: So if you find the QAST::Block with that in, then you can look at the &infix:<&> inside of that block.

[23:25] <timotimo> great!

[23:25] <jnthn> timotimo: Or you can write an "is_core_symbole"

[23:25] <jnthn> Which tries to find it, then checks the block it finds it in also has that marker.

[23:26] <timotimo> if i may, i'll enhance find_lexical with a :$must-be-core?

[23:27] <jnthn> timotimo: I think that may be more confusing :)

[23:27] <timotimo> hm, ok

[23:27] <jnthn> Just 'cus you *can* re-use code more doesn't always make it a good idea :)

[23:29] <masak> +1

[23:30] <masak> you want to braid code paths and responsibilities together, most of the time.

[23:30] <masak> of course, responsibilities keep changing with the design, so doing this right requires having perfect knowledge of the future.

[23:30] <jnthn> braids are awesome

[23:31] <masak> "dude, you had me at 'braids'"

[23:31] <jnthn> :P

[23:31] <timotimo> found the core! :)

[23:31] <jnthn> yay :)

[23:31] * masak .oO( zombie jnthn goes "braaaaaaaids" )

[23:31] <jnthn> :P

[23:32] <masak> 'night, #perl6

[23:32] <japhb_> He doesn't eat your brains, he ties them in corn rows?

[23:32] <japhb_> o/ masak

[23:32] <jnthn> OK, my performance regression test results were bogus 

[23:32] <jnthn> phew

[23:33] * timotimo phews, too

[23:33] * swarles swehp

[23:36] *** Targen left
[23:37] *** rindolf left
[23:39] <timotimo> mhhh tree-splicing

[23:40] <timotimo> don't quite know how to handle this properly in the code

[23:40] *** spider-mario left
[23:41] *** fhelmberger joined
[23:41] <timotimo> i wonder if throwing an exception is a good idea? :|

[23:42] <timotimo> using exceptions for control flow is ... o_O

[23:42] *** fhelmberger left
[23:42] <jnthn> Well, the reason I said make it a is_core_symbol is so you can use it to check if it is one

[23:42] <timotimo> i could put a closure into a dynamically scoped variable that does what's necessary at the right level. that sounds like a crazy hack

[23:43] <timotimo> oh, i wasn't being clear at all

[23:43] <jnthn> So you can write like if ...the qast looks right... && is_core_symbol('&infix:<|>') or so

[23:43] <timotimo> the thing is, i need to look two nodes down the tree for a &infix<|> for instance

[23:43] <jnthn> What are you trying to transform?

[23:44] <jnthn> You can use indexing to look at children.

[23:44] <timotimo> i can't look at parents, though, which would be more helpful

[23:44] <jnthn> What are you trying to transform?

[23:45] <jnthn> if $x == 1 | 2 style things?

[23:45] <timotimo> yes

[23:45] <timotimo> something like Op(if){ Op(chain ==){ Op(infix:<|>) { 1, 2, 3 }, 5 } } into Op(if){ Op(infix<||>) { ... } }

[23:45] <jnthn> OK

[23:45] <timotimo> looking two nodes deep for each Op i encounter seems like a big waste of time

[23:46] <jnthn> You need to be really careful because if you just do the naive thing, you evaluate the $x twice.

[23:46] <timotimo> ah, that's a good point.

[23:46] <jnthn> OK, but you know what only if and unless with a chain immediately below are interesting.

[23:46] <timotimo> hm, nothing else?

[23:46] <jnthn> And you can use a hash to check the name of the chain is something interesting.

[23:47] <jnthn> Well, it's better to start small.

[23:47] <timotimo> suret

[23:47] <timotimo> eeeeenh, my typing has been better :|

[23:47] <jnthn> In fact, I guess any chaining thing is probably interesting.

[23:48] <jnthn> I'd do it by looking down, though.

[23:48] <timotimo> OK

[23:48] <jnthn> Rather than trying to keep context around

[23:48] <jnthn> Trouble with keeping a dynamic around is you gotta reset it somewhere.

[23:48] <jnthn> And exceptions will be more costly too.

[23:48] <timotimo> OK

[23:48] <jnthn> nqp::istype($node, QAST::Op) is pretty cheap

[23:49] <jnthn> So it's almsot certainly the cheapest way.

[23:49] <jnthn> And safest.

[23:49] <jnthn> Inlining just goes of "is it a call op"

[23:49] <jnthn> *off

[23:49] <jnthn> The thing that will make it tricky is that for

[23:49] <jnthn> if $x == 1|2 { }

[23:49] <jnthn> You can't just duplicate the node that looks up $x

[23:50] <jnthn> Sicne it may be

[23:50] <jnthn> if foo() == 1|2 { }

[23:50] <jnthn> And you'd do the side-effects of foo twice.

[23:50] <timotimo> yes

[23:50] <timotimo> is that so very tricky?

[23:50] <jnthn> So you'll need to evaluate it and bind it into a temporary (a QAST::Var with local scope)

[23:50] <timotimo> that's what i figured

[23:50] <jnthn> It's not tricky to deal with.

[23:50] <jnthn> The main problem with working on the optimizer is knowing what you can get away with, tbh :)

[23:51] <jnthn> It's easy to be faster and wronger ;)

[23:51] <timotimo> hehe, yes indeed

[23:51] <jnthn> I think this is a pretty safe transformation overall.

[23:51] <timotimo> is there something like nqp::startswith?

[23:51] <jnthn> No

[23:51] <timotimo> (i've also checked the timings some time ago, it would also be very worthwhile)

[23:51] <timotimo> so i'll do substr(...) == 0?

[23:51] <jnthn> For which bit?

[23:52] <timotimo> that the op name starts with "chain"

[23:52] <jnthn> Oh

[23:52] <jnthn> No, it doesn't start with 

[23:52] <jnthn> .op eq 'chain'

[23:52] <timotimo> oh, that easy?

[23:52] <jnthn> Yeah

[23:52] <jnthn> .name is where the name of the chained thing is stored.

[23:52] <timotimo> good to know

[23:54] <jnthn> oh...

[23:54] <jnthn> Hm.

[23:54] <jnthn> no, you're fine

[23:54] <jnthn> There is the slight issue that your optimization may be "beaten"

[23:54] <jnthn> no, it won't be.

[23:54] <jnthn> Ignore me :)

[23:54] <jnthn> $a == $b *can* be inlined

[23:55] <jnthn> *but* not for the Junction variant

[23:55] <timotimo> pardon?

[23:55] <jnthn> So provided you put your stuff after that load of inlining code you're good.

[23:55] <jnthn> see visit_op

[23:55] <jnthn> (which is where in Optimizer you'd need to add code)

[23:55] <jnthn> Of note, around 140

[23:56] <timotimo> ah, the chain will be changed into a non-chain?

[23:56] <jnthn> Kinda

[23:56] <jnthn> It is detecting if it's simple enough to potentially do an inlining optimization.

[23:57] <jnthn> my int $a = 42; if $a == 42 { } 

[23:57] <jnthn> In that case it will inline the ==

[23:57] <timotimo> inlined in what way? the chain gets turned into a call, yes?

[23:57] <jnthn> No, it actually eliminates the call completely.

[23:57] <timotimo> oh, ok

[23:58] <jnthn> Simple enough subs have their QAST saved with them

[23:58] <jnthn> If we detect a call to something like that, we just shove the QAST directly in place of the call.

[23:58] <timotimo> mhm, ok

[23:58] <jnthn> We also resolve some multiple dispatches statically

[23:59] <jnthn> Anyway, in the junction case that does not happen.

[23:59] <jnthn> You *may* find that the inline code is eating your lunch though...

[23:59] <timotimo> a chain op can have as many children as it wants, right?

[23:59] <jnthn> No

[23:59] <jnthn> Two

[23:59] <jnthn> But it processes other children that are chains specially

[23:59] <jnthn> In QAST::Compiler

[23:59] <timotimo> ah, and the second one may be a chain op again, if we have something like 1 == 1 == 1?

