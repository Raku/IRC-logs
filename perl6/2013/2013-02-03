[00:04] *** spider-mario left
[00:06] *** kivutar left
[00:07] *** nebuchadnezzar left
[00:17] *** nebuchadnezzar joined
[00:22] *** drbean left
[00:40] *** pjcj left
[00:43] *** leprevost joined
[00:43] *** palakas__ joined
[00:44] *** Targen joined
[00:45] *** palakas_ left
[00:47] *** shinobicl joined
[00:51] <shinobicl> rakudo: Date.^methods.say;

[00:51] <p6eval> rakudo 6d5dc6: OUTPUT«get-daycount new-from-daycount today truncated-to delta clone succ pred is-leap-year days-in-month daycount-from-ymd ymd-from-daycount day-of-month day-of-week week week-year week-number weekday-of-month day-of-year check-value check-date truncate-parts new WHICH g…

[00:56] *** daniel-s left
[00:57] *** daniel-s joined
[01:01] *** MayDaniel left
[01:25] *** pjcj joined
[01:52] *** Su-Shee_ joined
[01:53] *** Su-Shee left
[01:53] *** zby_home_ left
[02:17] *** cognominal left
[02:22] *** cognominal joined
[02:23] *** FROGGS_ joined
[02:24] <diakopter> FROGGS_: `hi

[02:26] *** FROGGS left
[02:38] *** mikemol joined
[02:50] <stevan_> hello perl6ers!

[02:50] <stevan_> jnthn: moritz: masak: are you guys going to be at YAPC::EU?

[02:50] * stevan_ is trying to decide if he should come to EU or not

[02:56] <stevan_> also, how many of the p6ixers are planing to attend YAPC::NA? 

[03:01] <diakopter> jnthn plans to

[03:03] *** leprevost left
[03:18] <stevan_> excellent

[03:26] <swarley> converted most of HLL and QRegex into a ruby parsing grammar.. Working on NQP/Grammar.pm now.

[03:27] <timotimo> not long until rakudo can run on ruby as well!

[03:27] <swarley> timotimo, I'm working on compiling NQP to YARV bytecode

[03:30] <swarley> Well I've just wasted a long tome

[03:30] <swarley> time*

[03:31] <timotimo> oh, you are? wow.

[03:31] <timotimo> i didn't even know! :)

[03:31] <timotimo> yarv is "yet another ruby vm"?

[03:32] *** hulu joined
[03:32] <hulu> masak: helo

[03:34] <lue> Am I seeing that right? class Panda in lib/Panda.pm is passing more variables to self.bless than it has attributes.

[03:35] <timotimo> did you look at Pies, too?

[03:35] <timotimo> Pies has 4 more, with Panda's 5 attributes, it matches perfectly

[03:35] <lue> oh, duh. (I have Pies.pm on screen too, just didn't think of it)

[03:36] <timotimo> is it late at your place, too? ☺

[03:36] <lue> 19:35 right now.

[03:36] <lue> so no :)

[03:37] <lue> What's worse is, I figured out earlier that nextwith and nextsame were referring to Pies methods in Panda.resolve

[03:37] <timotimo> :))

[03:43] <diakopter> swarley: why wasted?

[04:01] *** Ayiko left
[04:08] *** preflex_ joined
[04:09] *** preflex left
[04:09] *** preflex_ is now known as preflex

[04:19] <TimToady> grondilu: .chars and * mean the same thing there in .substr, as it happens, and * is less error prone, since it doesn't reference outside the substr again

[04:19] <swarley> I lost track of what I wwas doing, and writing QAST for YARV turned into a NQP grammar in ruby

[04:20] <TimToady> grondilu++ for the RC entry, btw

[04:26] <swarley> You know, If I can correctly get this to work, NQP would be able to compile code that can access Ruby code

[04:26] <swarley> \o/

[04:26] <swarley> whoop

[04:27] <swarley> I wonder how I can add font-weight: 100000000000px; to "if" on that line..

[04:27] <timotimo> kind of makes me sad that there's only interop between perl6 and one of the languages, rather than perl6 and more than one other language

[04:28] <TimToady> we have to replace Java or C# before people will be interested in that

[04:28] <timotimo> do it like the north korea people: <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>if</strong></strong></strong></strong></strong></strong></strong></strong>[...]</strong>

[04:29] <lue> does absent in Pies::Project's State mean "not installed yet"? If so, L68-69 of Pies.pm is confusing me as to how it finds dependencies that need to be installed (unless I'm misinterpreting what the map statement's doing...)

[04:30] <timotimo> is there a statement for "installed, but no longer in the ecosystem"?

[04:30] <timotimo> bleh, i should really go to bed

[04:32] <lue> Well, I've so far added a "marked for installation" state, but because I'm bumbling around in code I don't know well, it won't do anything useful yet. :)

[04:33] <timotimo> what are you up to?

[04:34] <lue> Right now, adding a thing which tells you everything that's about to be installed before installing. Which means rearranging the order panda does things. (I'm working in a fork btw, so I'm not breaking any main code)

[04:37] <timotimo> that's cool :)

[04:37] <timotimo> i wish you the best of luck! and good night to anyone whom it might concern ;)

[04:38] <lue> I'd also like to give panda an update to new version of Perl 6 feature, but I have to be careful about that, as I can't just compile rakudo all the time.

[04:39] <lue> good knight, timotimo o/

[04:53] *** cognominal__ joined
[04:53] *** cognominal left
[05:01] <swarley> what does this mean? $!name ?

[05:02] * lue now sees that the build order is figured completely separate from the dependency resolution

[05:02] <swarley> has str $!name;

[05:02] <lue> $!name is a private attribute in a class or role

[05:02] <TimToady> swarley: that's a private attribute

[05:02] <swarley> ah

[05:02] <swarley> so <sigil>! is private?

[05:02] <TimToady> there is also a private attribute $!name lurking behind a public attribute of $.name, which is really an accessor for the private attribute

[05:03] <TimToady> <sigil>! really means object-local storage, known only to the class

[05:04] <TimToady> it's the absense of <sigi>. that makes it private from the standpoint of "you can't access it"

[05:04] <TimToady> but all attributes have the ! form, even if they have a public accessor

[05:05] <TimToady> well, a synthetic attribute would have only the accessor, I guess

[05:05] <TimToady> but the point is someone from outside doesn't need to know whether $.name maps directly to $!name or to something else

[05:06] <TimToady> this preserves the ability to change the implementation without changing the public API

[05:06] <lue> oh, looks like build-order in Panda::Builder is the order to compile files *within* one module. nvm then.

[05:12] *** alec left
[05:15] *** telex left
[05:17] *** telex joined
[05:21] *** xinming left
[05:23] *** xinming joined
[05:26] *** kaare_ joined
[05:26] <lue> *headdesk* C<next> means next iteration of loop, *not* next statement in the code. That completely changes the meaning of things.

[05:27] <lue> perl6-debug++

[05:30] <swarley> so, what is this

[05:30] <swarley> pir::escape__Ss

[05:32] *** alec__1 joined
[05:32] <lue> that is a PIR opcode that you can use outside of PIR. The part after the __ describes its arguments and what it returns, but I don't know what they mean.

[05:32] <lue> (I *think* s = takes a string and S = returns a string)

[05:33] <swarley> Well I assumed all of that much

[05:34] <swarley> I was more interested in the escape

[05:40] <swarley> Sorry, my computer lost connection and I detached from my BNC, did anyone say anything about my question while I was gone?

[05:40] <TimToady> nope

[05:41] <TimToady> but we'd all like to escape PIR...  :)

[06:02] *** MikeFair left
[06:02] *** benabik left
[06:09] *** benabik joined
[06:16] <TimToady> moritz: not, p5 does other compile-time optimizations as well, like turning $a++ into ++$a when in void context, and bypassing nops in the peephole optimizer, and turning @foo[1] into a faster instruction

[06:16] <TimToady> *no

[06:18] <TimToady> it turns "and not" into "or", and such

[06:19] *** shinobicl left
[06:24] <TimToady> it can turn a copying sort into an inplace sort

[06:25] *** sevin joined
[06:25] <TimToady> similarly can make @a = reverse @a into an inplace reverse

[06:27] <TimToady> it will also optimize iterators and reversed iterators

[06:28] <TimToady> and that's all just from the peephole optimizer

[06:28] <TimToady> propagating void context down the tree also suppresses a lot of computation

[06:29] <TimToady> and at least the propagation part is mostly compile-time, even if the suppression happens at run time

[06:37] <TimToady> perhaps the most important compile-time optimization is to not copy stuff back and forth when you have a sequence of concats

[06:38] <TimToady> so it's a lot more than just constant folding

[06:45] *** kaare_ left
[06:48] <TimToady> (was a question to nwc10 about p5 that I hijacked)

[07:35] <lue> Finally got panda to pretty-print a list of dependencies, but now that's all it does. (I pushed it to my fork ICUC). Anyway, good ♞ #perl6 o/

[07:43] <swarley> bah.. The only only way to do this would would be at least a little slow.. I'm not quite sure how it actually reduces the bytecode down from it's intermediate representation..

[07:50] *** am0c joined
[08:08] *** sevin left
[08:09] *** domidumont joined
[08:12] *** nnunley left
[08:30] <pmurias> swarley: you are not sure how QAST is turned into PIR?

[08:30] *** domidumont left
[08:31] <swarley> No, I'm talking about ruby's ISEQ to YARV

[08:31] *** domidumont joined
[08:33] *** sevin joined
[08:38] <pmurias> swarley: you could try generating ruby ;)

[08:47] *** Liz_ joined
[08:54] <pmurias> swarley: or does generating bytecode give you more flexibility?

[08:54] *** am0c left
[09:01] *** pmurias left
[09:05] *** Liz_ is now known as lizmat

[09:18] <eternaleye> timotimo: For 'installed but no longer in the ecosystem', perhaps 'orphaned' (based on rpm's terminology)? OTOH, some places use that to refer to ENOMAINTAINER

[09:19] <eternaleye> The amusing option would be 'pining'

[09:20] <eternaleye> ...On second thought, I *really* like 'pining' for that.

[09:20] <eternaleye> Because it's not dead.

[09:21] *** cognominal__ left
[09:23] *** sevin left
[09:42] *** Su-Shee_ is now known as Su-Shee

[09:45] *** Psyche^ joined
[09:48] *** Patterner left
[09:48] *** Psyche^ is now known as Patterner

[09:55] *** PacoAir joined
[09:59] *** spider-mario joined
[10:01] <masak> good forenoon, #perl6

[10:01] <masak> hulu: helo

[10:03] <masak> nwc10: I'm going to YAPC::EU. I know jnthn is, too.

[10:06] <jnthn> morning o/

[10:07] <jnthn> masak: It was stevan_ who asked, not nwc10, I think :)

[10:08] <diakopter> o/

[10:10] <masak> jnthn: oh! yes.

[10:11] <masak> stevan_: ^^^^

[10:14] *** lizmat left
[10:18] *** FROGGS_ is now known as FROGGS

[10:18] <masak> so, I've been thinking.

[10:18] <FROGGS> hi there

[10:18] <jnthn> uh-oh

[10:18] <masak> especially because of the historical overview lizmat gave yesterday abotu Perl 5 and Perl 6.

[10:19] <masak> but also because of the (unexpectedly) positive feedback I got from my live demo yesterday.

[10:19] <masak> it's like, I've been living in a little echo chamber of my own lately, not realizing how well we're doing on some counts with Perl 6, and how not-well we're doing with others.

[10:20] <masak> so I'm drafting a blog post, and I'd like early feedback on it. any feedback, really.

[10:20] <masak> here's the draft:

[10:20] <masak> https://gist.github.com/43f95c5ba980dfee8cee

[10:20] <masak> what I'm saying is in no way new.

[10:20] <masak> it's just a distillation of what should be our focus in the next 3-4 years.

[10:22] <FROGGS> jnthn: how can it be that nqp parses /$(1)/ as metachar:sym<nqpvar>($(1)), but under rakudo it will be treated as nqp's metachar:sym<$>($) and metachar:sym<( )>((1)) ?

[10:23] <FROGGS> since rakudo's metachar:sym<rakvar> is able to match it

[10:23] <FROGGS> it's a bit frustrating

[10:25] <jnthn> FROGGS: Does one have a longer longest prefix than the other?

[10:25] <FROGGS> what is a prefix?

[10:26] <FROGGS> the method name? or stuff like <?before ...

[10:26] <jnthn> What's in the rule

[10:27] <jnthn> The thing that determines what is called first is LTM

[10:28] <jnthn> masak: While on threads there's not much spec progress, there's a lot of spec'd features that allow parallelism.

[10:28] <jnthn> masak: That is to say, it's not like nobody has thought about it in the design at all.

[10:29] <FROGGS> https://gist.github.com/63fd03de7f3dec132dc9

[10:30] <masak> jnthn: oh. I consider that bit of the spec extremely slushy.

[10:30] <masak> jnthn: on the level of "it would be nice if X (but no-one's tried this)"

[10:30] <FROGGS> jnthn: <var> should be the longest token to match, no?

[10:31] <jnthn> FROGGS: Calls to LANG don't participate

[10:31] <jnthn> FROGGS: Thus the "before" stuff

[10:31] <FROGGS> damnit

[10:31] <jnthn> (in nqpvar)

[10:31] <FROGGS> k

[10:31] <FROGGS> learning++

[10:31] <FROGGS> thank you

[10:32] <jnthn> masak: At the level of "how do we start a thread", "how do we control degree of parallelism of a hyper", etc, it's very slushy. I just meant that >>+<< is already spec'd as parallelizable, feed operators are producer/consumer, the hyper/race context...

[10:34] <jnthn> Even if we don't know the API to the lower level bits, we've various bits of declarative parallelism written into the spec.

[10:34] <masak> jnthn: *nod*

[10:34] *** Liz__ joined
[10:34] *** Liz__ left
[10:35] <masak> jnthn: I agree that those three things you mentioned are well-spec'd. I think it's still debatable whether people who will use parallelism in Perl 6 will rely mainly on those constructs.

[10:35] <jnthn> masak: Well, it's not the 90s any more so we'd better have a better story than "well, you start a thread then..." :)

[10:36] <masak> jnthn: full ACK.

[10:36] <diakopter> HUP

[10:36] <masak> we need the higher-level building blocks.

[10:36] <dalek> nqp-jvm-prep: 02ad1da | (Gerhard R)++ | Makefile:

[10:36] <dalek> nqp-jvm-prep: Fix name of setting rule in Makefile

[10:36] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/02ad1da478

[10:36] <dalek> nqp-jvm-prep: 34bd10f | jonathan++ | Makefile:

[10:36] <dalek> nqp-jvm-prep: Merge pull request #11 from gerdr/master

[10:36] <dalek> nqp-jvm-prep: 

[10:36] <dalek> nqp-jvm-prep: Makefile fix

[10:36] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/34bd10f1de

[10:36] <masak> I'm just positing that it's hard to predict which ones will be popular/useful.

[10:37] <masak> &

[10:37] <diakopter> fg

[10:38] <jnthn> masak: indeed

[10:55] <arnsholt> jnthn: Unless you have any last minute comments, I'll merge my branch into master soonish

[10:59] <jnthn> arnsholt: No, I'm happy with it.

[11:00] <arnsholt> Excellent. Just gonna have breakfast first =)

[11:00] <jnthn> :)

[11:01] * jnthn is mostly tied up with pre-Stockholm-trip errands 

[11:04] <arnsholt> Usually good to get those out of the way

[11:04] <arnsholt> More teaching next week?

[11:05] *** MayDaniel joined
[11:06] <nwc10> moritz: also, constant folding isn't done by the peephole optimiser :-)

[11:06] <FROGGS> jnthn: is the <?before already a token? or do I need to capture things inside?

[11:07] <nwc10> Perl 5 does it at op construction time. If you ask to build the binary op for +, and give the constructor a constant op for the left argument, and a constant for the right argument, you don't get back an add op. You get back a constant for the result

[11:10] *** Su-Shee left
[11:11] <jnthn> FROGGS: Things in <?before ...>, provided they are themselves declarative, count as part of the declarative prefix for LTM

[11:12] *** Ayiko joined
[11:12] *** Su-Shee joined
[11:12] <jnthn> nwc10: I guess that means you don't have the problem of post-declared overloads... :)

[11:13] <jnthn> (we couldn't implement it like that in Perl 6 for that reason...)

[11:13] <nwc10> I didn't write it that way, and I'm not even aware of post-declared overloads :-)

[11:14] <jnthn> arnsholt: This time a mix of teaching and workshop for a single company, rather than an open classroom session. 

[11:14] <jnthn> errand, bbiab

[11:18] *** fgomez left
[11:19] <moritz> stevan_: I'm trying to convince my employer to send me to YAPC::EU. I think my chances are 80%.

[11:20] <moritz> TimToady, nwc10: thanks for the explanations

[11:22] *** sampo joined
[11:23] *** GlitchMr- joined
[11:24] <arnsholt> Gah. Updated bootstrap use the old REPR compose stuff, it seems

[11:27] *** GlitchMr left
[11:28] <arnsholt> jnthn: Halp?

[11:35] *** MayDaniel left
[11:39] *** PacoAir left
[11:40] <timotimo> good morning

[11:40] <timotimo> ish :)

[11:41] <FROGGS> morningish timotimo :o)

[11:43] <timotimo> in my between sleep and wake state, i wondered how hard it would be to build something like ikiwiki. also, how useful it would be to write a piece of perl code that outputs the same thing as pygmentize, but uses the official (or even STD) perl6 grammar for more accuracy whenever you can afford to run an actual perl6 interpreter (with, i guess, the restricted setting, so that BEGIN blocks won't kill you)

[11:43] *** sampo left
[11:48] <timotimo> hm, would using different Actions prevent evil code from hurting me?

[11:51] <jnthn> arnsholt: What's exactly wrong? Both branches did make bootstrap-files?

[11:51] <jnthn> Separately?

[11:53] <arnsholt> No, but since I last merged master, the bootstrap stuff has been updated, and it uses the intermediate REPR compose protocol it seems

[11:53] <jnthn> Ah...

[11:53] <arnsholt> I get the "get_pmc_keyed_str() not implemented in class 'ResizablePMCArray'" error

[11:54] <jnthn> Ah, and the updated again version lives in your branch?

[11:54] <arnsholt> No, I never updated the bootstrap files

[11:55] <arnsholt> Er, yes

[11:55] <jnthn> Yes, but I mean the updated repr_compose code.

[11:55] <arnsholt> Yeah, yeah

[11:55] <jnthn> OK

[11:55] <arnsholt> That's in my branch

[11:55] <arnsholt> (I misunderstood your question initially)

[11:55] <jnthn> Maybe the best way is to comment out the repr_compose code in master, do make bootstrap-files to get rid of it so everything falls back to the old way. Then merge.

[11:56] <arnsholt> Right. I'll try that

[11:57] <jnthn> The bootstrap-files update I did was for unrelated reasons, probably to get some nqp::ops

[11:58] <arnsholt> Aha

[12:00] <FROGGS> timotimo: what is ikiwiki about?

[12:05] <timotimo> FROGGS: it's a wiki engine that transforms markdown into html, at its most basic. it is usually backed by a VCS like git and most people deploy it with a cgi script that allows creating/editing/commenting. it has many neat plugins and special ikiwiki plugin syntax

[12:05] * timotimo just found out how to teach vim to treat $foo-bar as one keyword: set the iskeyword string to include -, too

[12:06] <timotimo> and that's all there is to it :)

[12:07] <FROGGS> I like the wikimedia wiki... we use it at work too

[12:07] <jnthn> Add ' too ;)

[12:07] <timotimo> ah, it's already in the perl6.vim ftplugin in the vim-perl repo

[12:07] <FROGGS> I should fiddle with the scite language files some day

[12:07] <timotimo> r: my $foo-bar'jnthn' = 10;

[12:07] <p6eval> rakudo 6d5dc6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/Pv1pJtSQf0:1␤------> [32mmy $foo-bar'jnthn[33m⏏[31m' = 10;[0m␤    expecting any of:␤        scoped declarator␤        constraint␤        postfix␤        infix or meta-infix␤        infix stopper␤        …

[12:07] <timotimo> ah, well, not at the end obviously

[12:08] <timotimo> r: my $foo-bar'jnthn = 10;

[12:08] <p6eval> rakudo 6d5dc6:  ( no output )

[12:08] <FROGGS> right

[12:08] <timotimo> i don't really think the iskeyword string encodes that difference, though

[12:08] <arnsholt> jnthn: Thanks for the help. Looks like things are back on track

[12:08] <jnthn> \o/

[12:08] <arnsholt> Or not. Hmm

[12:09] <FROGGS> r: my $o-'O'-o = "yay"

[12:09] <p6eval> rakudo 6d5dc6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix = instead␤at /tmp/Eb7OZh7JxM:1␤------> [32mmy $o-'O'-o =[33m⏏[31m "yay"[0m␤»

[12:09] <jnthn>  /o\

[12:09] <FROGGS> ohh

[12:09] <FROGGS> r: my $o-o'O'o-o = "yay"

[12:09] <jnthn> std:  my $o-'O'-o = "yay"

[12:09] *** PacoAir joined
[12:09] <p6eval> rakudo 6d5dc6:  ( no output )

[12:09] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix = instead at /tmp/QCfQMr8jkm line 1:␤------> [32mmy $o-'O'-o [33m⏏[31m= "yay"[0m␤Parse failed␤FAILED 00:00 43m␤»

[12:09] <jnthn> hm, I thought STD may do a better error :)

[12:09] <FROGGS> but it is cool to have ' too

[12:10] * FROGGS .oO( class Cat { * }; class Cat's-Ball { * } )

[12:11] * jnthn tries to read that class name the innocent way 

[12:12] <FROGGS> hehe

[12:22] *** MayDaniel joined
[12:26] <FROGGS> jnthn: is there a trick to debug LTM?

[12:27] *** Targen left
[12:27] <hulu> my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4; why not %scores

[12:28] <timotimo> well, what you have there is an ordered list of pairs

[12:28] <timotimo> a hash wouldn't be ordered, would it?

[12:30] <timotimo> r: my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4; say @scores.perl; say @scores.hash.perl

[12:30] <p6eval> rakudo 6d5dc6: OUTPUT«Array.new("Ana" => 8, "Dave" => 6, "Charlie" => 4, "Beth" => 4)␤("Ana" => 8, "Dave" => 6, "Charlie" => 4, "Beth" => 4).hash␤»

[12:30] <jnthn> Hash order is not reliable,no.

[12:30] <hulu> timotimo: what's means of "Perl 6’s precedence rules state that the in x => operator binds its arguments more tightly than the in x , operator, which in turn binds more tightly than the = assignment operator."

[12:30] <jnthn> FROGGS: Not really...you could try writing a small grammar with the kinds of things you're trying to do in and see how it works.

[12:31] <jnthn> FROGGS: Grammars written in Rakudo that do LTM use the same engine as NQP uses for the Perl 6 grammar itself.

[12:32] <timotimo> hulu: it means that if you write something like  $x = "foo" => 1, "bar" => 2  it will be parenthesized like this:  ($x) = (("foo" => 1), ("bar" => 2))

[12:32] <hulu> 优先级

[12:32] <timotimo> compare that with regular maths. = is like =, => is like * and , is like +

[12:33] <timotimo> $x = "foo" * 1 + "bar" * 2   ← same "structure"

[12:33] <hulu> i c

[12:33] <hulu> thx

[12:33] <timotimo> np :)

[12:34] <arnsholt> jnthn: Think I understood what I was actually supposed to do this time around

[12:34] <arnsholt> Making sure Rakudo isn't broken now

[12:37] <arnsholt> Which, in fact, it is

[12:41] <timotimo> moritz: in 5-to-6, it says "The answer is that Rakudo doesn't do longest token matching yet, but matches sequentially." in the XML example, that could use an update ;)

[12:41] <timotimo> (am i just stating the obvious?)

[12:42] *** vividsnow joined
[12:45] *** Targen joined
[12:45] *** not_gerd joined
[12:49] <jnthn> gotta head up to Stockholm &

[12:51] <hulu> timotimo: thx

[12:53] *** kaare_ joined
[12:55] *** kivutar joined
[13:01] <masak> hulu: yes, 优先级 is "precedence". which thing gets evaluated first.

[13:03] *** Chillance joined
[13:05] <sjn> masak: How's the Ada room? :)

[13:08] <timotimo> gentlemen, you can't code in here, this is the programming room!

[13:11] <sjn> timotimo: surely a scripted response, if I ever heard one! :)

[13:23] *** not_gerd left
[13:24] <moritz> timotimo: updated

[13:24] <moritz> good afternoon, #perl6

[13:24] *** vividsnow left
[13:24] <timotimo> cool, moritz :)

[13:28] *** tokomer joined
[13:28] *** Chillance left
[13:28] *** hulu left
[13:29] *** Chillance joined
[13:47] <timotimo> so, i've asked in #pypy if python bytecode would be a sensible target for nqp. fijal said it'd be easier to write a whole new VM in rpython than to try to shoehorn perl6 into python bytecode

[13:47] <timotimo> he also says when we target the jvm, we'll have to abstract away so much of the perl6 semantics, that we're basically "compiling to a garbage collected C" and performance will suck

[13:48] <moritz> garbage collected C is perfect.

[13:48] <shachaf> I hear the JVM is pretty awful as a compilation target for things that aren't Java.

[13:49] * timotimo is really not the right person to do that discussion

[13:49] *** kivutar left
[13:53] *** fijal joined
[13:53] <fijal> hi

[13:53] <timotimo> there he is :)

[13:53] <timotimo> moritz: do you know enough about nqp-jvm and parrot to explain/argue properly? i sure don't.

[13:55] <timotimo> and at just that moment, my modem decides to go belly-up

[13:56] <timotimo> so, fijal, your argument is that jvm has the absolute wrong semantics, so that mapping perl6 to jvm is a dumb idea and performance will suffer to a ridiculous degree, right?

[13:57] <timotimo> fijal: and that it would be easier to create a new, custom VM to run perl6 that uses, for example, pypys tracing jit generator technology to get good performance

[13:57] <moritz> timotimo: not really

[13:57] <moritz> (I don't really know enought about nqp-jvm)

[13:58] <fijal> it's definitely easier than on top of JVM

[13:58] <fijal> or comparabl;e

[13:58] <fijal> but it'll run faster

[13:58] <Su-Shee> well ruby and python managed to put themselves onto the jvm and clojure took it even further so I don't see why Perl6 can't do it.

[13:58] <moritz> fwiw we tried the approach with our own VM (parrot)

[13:58] <moritz> and it kinda works, but not fast

[13:58] <arnsholt> From what jnthn has blogged, JVM doesn't seem to be too much trouble so far

[13:59] <moritz> no good JIT compiler, for example

[13:59] <fijal> Su-Shee: well

[13:59] <fijal> Su-Shee: pypy is massively faster

[13:59] <fijal> Su-Shee: if you care

[14:00] <Su-Shee> I totally don't care. I want the clojure concept which means you have your favorite language AND can incoporate all kinds of existing java libraries which is insanely practical.. so speed? yeah, later. 

[14:01] <arnsholt> From a pub conversation with jnthn I think he's at least in partial agreement that the best of all worlds would be a VM specifically tuned for Perl 6 and its special things

[14:01] <arnsholt> But making a VM, including proper fast GC, JIT compilation and all the bells and whistles is a massive, massive undertaking

[14:02] <timotimo> (except with pypy you get the GC and JIT for free)

[14:02] <spider-mario> how hard do you think it would be to use JNI to make Perl 5 modules available to Perl 6-on-JVM?

[14:03] <arnsholt> spider-mario: Good question. There was a module that embedded a Perl 5 in Parrot, but can't remember the name off hand

[14:03] <moritz> blizkost

[14:03] <arnsholt> Right, blizkost

[14:03] <fijal> arnsholt: pypy is not python-specific

[14:03] <fijal> that'\s a difference

[14:03] <arnsholt> I know pypy isn't Python specific

[14:03] <fijal> Su-Shee: JVM libraries kinda suck, but yeah

[14:03] <arnsholt> How much typing does pypy do?

[14:04] <fijal> arnsholt: as in?

[14:04] <spider-mario> well, JVM libraries are often designed for Java

[14:05] <Su-Shee> fijal: not having any sucks even more ;)

[14:05] <fijal> Su-Shee: sure

[14:05] <arnsholt> fijal: Types of the "this variable is of type X" kind

[14:05] <moritz> static type information that the optimizer can use

[14:05] *** vividsnow joined
[14:06] <fijal> arnsholt: it happens automatically

[14:06] *** b1rkh0ff left
[14:06] <timotimo> no type annotations are written, only assertions. the whole program is globally type-inferred

[14:06] <arnsholt> Cause Python isn't really typed as such, isn't it?

[14:06] <fijal> arnsholt: you don't leave hints in the interpreter

[14:06] <fijal> timotimo: stop confusing people ok?

[14:06] <timotimo> i'll shut up

[14:06] <fijal> arnsholt: so you write an interpreter in RPython (a language)

[14:06] <fijal> that part is statically typed

[14:07] <arnsholt> Right

[14:07] <fijal> just like Java

[14:07] <fijal> however, the program you're interpreting is not statically typed at all

[14:07] <fijal> but the JIT is able to pick up the types

[14:07] <fijal> (and other information)

[14:07] <arnsholt> I see

[14:08] <fijal> pretty much the same as JVM will do escape analysis

[14:08] <fijal> except we are obviously more geared towards the use cases that are more common in writing interpreters

[14:08] <fijal> so we'll have the frame support that JVM lacks

[14:08] <fijal> does perl6 have frame support?

[14:08] <fijal> like "give me all local variables"

[14:08] <fijal> or so?

[14:09] <masak> sjn: Ada room was an interesting mixture of mundane and fascinating. :)

[14:09] <moritz> fijal: yes

[14:09] <moritz> you can introspect lexical pads

[14:09] <masak> I'm battery-bound here, but I have to dump a few things here from the "What's new in Ada 2012" talk :)

[14:09] <fijal> moritz: that kills JVM performance

[14:09] <fijal> because you cannot prove it does not escape usually

[14:09] <masak> first, nice to see that Ada is stealing the junction syntax for or junctions. (in a very delimited, statically-desugarable context, but still.)

[14:10] <masak> (also, this has happened before. Java 7 does the same for exceptions, IIRC)

[14:10] <moritz> fijal: well, in general lexicals have to be compiled to heap objects

[14:10] <masak> second, there is a thing that I would like Perl 6 to steal from Ada: subtype defaults. I hadn't really realized how much I had missed this.

[14:10] <moritz> (because of closures etc.)

[14:11] <masak> at first opportunity, I will spec subtype defaults. feel free to protest loudly before or after. I believe it will be a definite improvement.

[14:11] <masak> semantically, unassigned variables and unbound parameters of a subtype will get the default.

[14:12] <arnsholt> fijal: It's a shame jnthn isn't here. He's the one who actually knows these aspects of the compiler the best

[14:12] <masak> proposal: 'subset Odd of Int where { $_ % 2 } default 1'

[14:13] <masak> I also propose that defaults be optional, and that the default default be the default of the parent type.

[14:13] <fijal> arnsholt: ok, you can find me on #pypy if you want

[14:13] <timotimo> fijal: assuming someone were to write a VM using rpython so that nqp could translate rakudo to that VM and rakudo could emit that-vm-bytecode, would the jit still be able to get good performance, or would most of the compiler have to be in rpython, too?

[14:13] *** vividsnow left
[14:13] <masak> the only thing I'm not sure of is whether to die at parse time if the default is not provided and the default default doesn't comply -- like with Odd above.

[14:14] <moritz> masak: on a related topic, I once tried to implement  $var = Nil resetting to the default. In the end the problem was that we don't store the default value, and some variables are typed Mu but default to Any

[14:14] <fijal> timotimo: jit does not particularly care where did you take your bytecode from

[14:14] <fijal> timotimo: obviously if the parser and compiler is in perl too, you need more time to compile stuff

[14:14] <fijal> but of course you can serialize it too

[14:14] <masak> moritz: I'm too unfocused to analyze these things right now. consider me in dump mode, and I'll contemplate later. ;)

[14:15] <masak> moritz: but yes, that's interesting to hear.

[14:15] <moritz> masak: so we might need to store some defaults somewhere. But I'm not sure if it's per container or per type

[14:15] <timotimo> well, it's in nqp, so maybe nqp could be translated into rpython-compliant python bytecode?

[14:15] <masak> listening to the Ada talk, it was clear to me that we are missing defaults on subtypes.

[14:16] <masak> also, an interesting mini-insight on pre/postconditions: if a precondition fails, it's someone else's fault -- the user's or some consumer library's. if a postcondition fails, it's your fault.

[14:16] <masak> obvious but a nice way to phrase it.

[14:16] <masak> it shows how they're kinda different beasts.

[14:16] <moritz> that's well known in the DBC community :-)

[14:16] <masak> suspected that :)

[14:17] <fijal> timotimo: what's rpython-compliant python bytecode?

[14:17] <fijal> timotimo: why do you insist on python bytecode?

[14:17] <fijal> how is compiling anything to python bytecode easier than implementing it?

[14:17] <fijal> I fail to understand that

[14:17] <timotimo> you're right, there would still have to be the other VM, too.

[14:18] <timotimo> the thought was to put the resulting code into the rpython translation toolchain, too

[14:18] <fijal> why would you do that?

[14:18] <fijal> I think you're confusing various layers

[14:18] <timotimo> i probably am

[14:18] <fijal> you write code in RPython that interprets perl

[14:18] <fijal> this is simpler than you write a compiler from perl to JVM

[14:19] <fijal> or at least not worse

[14:19] <fijal> yes, you have to make a bytecode format, but it's nothing special

[14:19] <fijal> this is not the hard part

[14:19] <fijal> the hard part is getting all the details of the semantics right

[14:19] <timotimo> the format itself is less the problem than what bytecodes there should be and what they do

[14:19] <timotimo> yes

[14:19] <fijal> and it's easier with interpreter than compiler

[14:19] *** b1rkh0ff joined
[14:20] <fijal> especially if the language was designed with the interpreter in mind

[14:20] <masak> so, I've been to a Java talk, a Smalltalk talk, an Ada talk, and now I'm waiting for a SpiderMonkey talk. I feel very eclectic today. ;)

[14:21] <fijal> masak: :)

[14:21] <fijal> masak: what is it?

[14:21] <tadzik> eclanguic

[14:21] <masak> fijal: I'm at FOSDEM.

[14:22] <masak> fijal: dictionary.com says "eclectic" means "selecting or choosing from various sources"

[14:22] <masak> (just like Perl) :P

[14:22] <timotimo> i interpreted it as "what spidermonkey talk are you going to attend"

[14:22] <masak> it's the same root as for "select" and "elect".

[14:22] <masak> timotimo: oh!

[14:23] <fijal> masak: cool, I wish I was there

[14:23] <masak> it's about SpiderMonkey GC in Firefox.

[14:23] <fijal> masak: ask them if they managed to fix the leak if you have a cycle between JS and DOM objects

[14:23] <fijal> (evil laugh)

[14:23] <masak> dude, that was IE6 :P

[14:24] <fijal> masak: no, chrome was leaking such stuff recently

[14:24] <fijal> and ffox

[14:24] <masak> really? do you have an URL to back that up?

[14:24] <masak> that sounds awful.

[14:24] <fijal> well, how do you deal with it?

[14:24] <fijal> you have reference-counted C++ objects

[14:24] <masak> (and I'd very much like to troll the speaker that way) :)

[14:24] <fijal> and a real GC in the JS

[14:24] <moritz> GC

[14:24] <masak> fijal: surely Firefox doesn't do refcounting still?

[14:25] <tadzik> well, the talk is about GC, so...

[14:25] <masak> or do you mean the DOM needs to do refcounting?

[14:25] <fijal> masak: in C++?

[14:25] *** sizz left
[14:25] * masak still feels this would be so much easier to talk about with an URL to the incident

[14:26] <masak> a URL*

[14:26] *** sizz joined
[14:26] <fijal> masak: you can just ask him what happens if you have a reference to a DOM object from JS that references back to JS object

[14:26] <masak> I found this: http://stackoverflow.com/questions/6478864/updating-dom-via-javascript-causing-memory-leaks-only-in-firefox

[14:26] <masak> fijal: ok. will do.

[14:26] <fijal> it's kinda hard to find a reference

[14:26] <timotimo> fijal: tell me if i'm confusing layers again: if i were to write a VM using rpython and have NQP target that VM, would that be sensible performance-wise? this way, a rakudo could be compiled down to that VM at least.

[14:27] <fijal> timotimo: what's NQP?

[14:27] <tadzik> -_-

[14:27] <timotimo> it's kind of rpython-but-perl6

[14:27] <timotimo> simpler syntax, fewer built-ins, only := (binding) instead of = (assignment)

[14:27] <fijal> as in, is it statically typed perl or so?

[14:27] <masak> oh, this resource looks better: http://stackoverflow.com/questions/3750797/cyclic-adding-removing-of-dom-nodes-causes-memory-leaks-in-javascript

[14:28] <timotimo> not really

[14:28] <masak> fijal: it's a bootstrapping subset of Perl 6.

[14:28] <masak> fijal: desugared lowish-level base components to build a Perl 6 compiler.

[14:28] <fijal> http://stackoverflow.com/questions/10092619/precise-explanation-of-javascript-dom-circular-reference-issue

[14:28] <fijal> masak: 

[14:28] <masak> thank you. :?

[14:28] <masak> :>

[14:29] <fijal> timotimo: you can compile it to the VM of your choice, yeah

[14:29] <fijal> especially if it helps you bootstrap

[14:29] *** clkao left
[14:29] <masak> fijal: that makes the issue much clearer. now I can troll with good conscience :)

[14:29] <timotimo> oh, that's probably what you meant with "focus on the interpreter" all the time

[14:30] <timotimo> to use an existing compiler to target that VM+interpreter

[14:30] <fijal> timotimo: we actually moved pieces of pypy source code from RPython to Python

[14:30] <fijal> because it can be specialized better

[14:30] *** GlitchMr- left
[14:30] <fijal> masak: so IE6 is bad because it never does it

[14:30] <timotimo> i suppose in my head there was a bit of left-over concepts from when "interpreter" means "source code goes in, behavior comes out", rather than "bytecode goes in, behavior comes out"

[14:31] <fijal> masak: while chrome/ffox keeps it as long as you keep the website open

[14:31] <fijal> which is still bad, I keep my gmail open whole day

[14:31] <masak> fijal: right.

[14:31] <fijal> timotimo: oh ok

[14:31] <masak> I had no idea things are still this bad. for shame, browsers.

[14:31] <fijal> masak: I like trolling those people because they're so full of themselves and they have an awesome PR

[14:31] <masak> ok, battery low &

[14:32] <timotimo> ciao masak!

[14:32] <fijal> if you ask a random dude, v8 is definitely by far the fastest thing

[14:32] <timotimo> fijal: surely that problem would be better using a browser implemented completely in javascript, no?

[14:32] <fijal> timotimo: that precise one, yes

[14:33] <arnsholt> An all-JS browser would have to be careful to not let website JS modify the browser state, though

[14:34] <tadzik> and files on the filesystem, for example

[14:34] <timotimo> you should be able to handle that

[14:34] <timotimo> an interpreter/app level divide should be doable

[14:34] <tadzik> as in, a JS browser must be able to read and write stuff to disk

[14:34] <tadzik> and you can end up with funny situation, like on the KIndle

[14:34] <timotimo> well, you can certainly do that with node.js!

[14:35] *** SunilJoshi joined
[14:36] <timotimo> anyway, i know 0 about VM/interpreter design.

[14:39] <timotimo> it would certainly be better if someone with lots of experience with parrot came up with a more fitting VM design for perl6

[14:39] <timotimo> or maybe we'll just wait and see how potion turns out.

[14:40] <timotimo> *or* implement the backend for potion and just steal potion bytecode + semantics and implement that with rpython

[14:40] <timotimo> endless possibilities are endless.

[14:42] <timotimo> hell, even implementing a parrot bytecode compatible VM could give performance improvements when using rpython. who knows?

[14:42] *** shinobicl joined
[14:43] *** am0c joined
[14:44] *** SunilJoshi left
[14:51] *** GlitchMr joined
[14:58] <moritz> nqp: nqp::say(nqp::isinvokable(sub () { }) )

[14:58] <p6eval> nqp: OUTPUT«1␤»

[14:59] *** clkao joined
[15:00] <masak> ok, back up. found an outlet :)

[15:00] <masak> I did troll the speaker. he mumbled that they had some thing that would shuttle information from the GC to the C++ refcounter.

[15:00] <masak> didn't sound ideal.

[15:01] <moritz> so, has the problem been solved?

[15:01] <masak> more like subdued or ameliorated, seemedlike.

[15:01] <masak> after this talk, I'm left with this thought: why the heck do we GC on the process level? why not just institute an OS-wide GC, and have a good API into it?

[15:02] <moritz> loose coupling

[15:02] <masak> yeah, that's another thing. Firefox now has write barriers all over the place.

[15:03] <masak> that's hardly loose coupling. the whole application has to dance according to the music of the GC.

[15:03] <geekosaur> because an OS-wide GC forces everything to use the same GC strategy, when GC is unlikely to be one size fits all.  there's a paper out there which examined an OS-wide GC relative to the JVM, IRC

[15:04] <masak> hrm, good point.

[15:04] <moritz> masak: there are very few cross-process pointers, so there's not much gain in having a cross-process GC

[15:04] <moritz> also virtual memory makes such stuff decidedly non-trivial

[15:04] <geekosaur> and they were able to tune it so it worked about as well as the current behavior, but it took some work because even just considering the JVM different machines may have different needs

[15:06] <fijal> masak: we have the same

[15:06] <fijal> masak: but we don't write it by hand

[15:06] <fijal> masak: the problem is C++ is too low level

[15:07] <masak> *nod*

[15:08] <masak> any time you leave the cozy GC'd world of your scripting language to bridge/interface with C or C++, I guess you run into this.

[15:08] <fijal> well

[15:08] <fijal> bridge/interface is fine

[15:08] <fijal> because there are well defined semantics

[15:08] <fijal> of C

[15:08] <fijal> the problem is if you *write* your stuff in C

[15:08] <fijal> you end up needing to have a write barrier everywhere

[15:08] <fijal> it's a nightmare

[15:08] <masak> aye.

[15:08] <masak> cf Parrot.

[15:08] <masak> I'm currently in love with RIAA and C#'s IDisposable/using pattern.

[15:09] <fijal> RIAA is good

[15:09] <fijal> but solves 90% of the problem

[15:09] <fijal> 10% is still ugly

[15:09] <masak> granted.

[15:09] <masak> but as percentages go, 90% is pretty good going.

[15:09] <fijal> meh

[15:09] <masak> I'm saying it's something to consider.

[15:09] <fijal> masak: you know how we do it?

[15:09] <masak> not really.

[15:10] <masak> we currently do it with LEAVE, and mumble about macros to fold even those in.

[15:10] <fijal> we insert write barriers programatically

[15:10] <fijal> while compiling RPython

[15:10] <masak> makes sense.

[15:10] <fijal> essentially an equivalent of a non-sucky GCC plugin

[15:10] <masak> then you just need to get the codegen right :)

[15:10] *** benabik left
[15:10] <fijal> this is the whole reason of RPython existance

[15:10] <fijal> yeah

[15:10] <fijal> but there is one place

[15:10] <fijal> which is maybe hard, but limited in size

[15:10] <fijal> not a bit everywhere

[15:10] <fijal> it's much easier to reason about

[15:11] *** benabik joined
[15:11] <masak> aye.

[15:11] <fijal> I'm too dumb to remember to put write barrier everywhere

[15:11] <masak> "keep things together that belong together."

[15:11] <fijal> it's already hard enough in tests for the insertion :)

[15:11] <masak> keeping single concerns from being scattered -- one of the mantras of AOP :)

[15:11] <fijal> we have this and a handcoded assembler fast path

[15:11] <fijal> which is a bit ugly I agree

[15:12] <fijal> but very hard to do better

[15:12] <masak> *nod*

[15:12] <fijal> (wb ends up being 2-3 instructions in the good case)

[15:12] <masak> nice.

[15:12] <fijal> the same way malloc ends up being <1 cycle on average

[15:17] <fijal> timotimo: ok, I think I understand this now

[15:18] <fijal> timotimo: you would want an NQP interpreter on top of RPython

[15:18] <fijal> should be even relatively trivial to pull off

[15:22] <timotimo> i think the same bytecode that's used for the nqp interpreter must also be able to do all the things that rakudo-perl6 would want to emit, though, but i'm not quite sure :(

[15:22] <timotimo> masak: can you help lift my confusion?

[15:24] <timotimo> fijal: in what way do you consider it "relatively trivial"?

[15:24] <fijal> as in, much easier than compiling to JVM

[15:24] <fijal> or implementing in C

[15:24] <fijal> since you have quite a few cool data structures etc.

[15:24] <fijal> (like strings!)

[15:25] <timotimo> i understand why it would be easier to do than C :)

[15:26] <masak> timotimo: yes, basically Perl 6 doesn't do anything fundamentally new compared to nqp on the QAST level.

[15:26] <timotimo> well, that's a relief

[15:27] <timotimo> masak: you've got some insight into QAST. how complicated does a theoretical new just-for-perl6 VM have to become to be able to host nqp effectively?

[15:28] *** SunilJoshi joined
[15:30] <masak> I'm not sure what you're asking.

[15:31] <masak> I've touched QAST, yes. it seems a nice technology.

[15:31] <masak> nqp doesn't have very high demands on the VM, really.

[15:31] <masak> that's one of the nice things about it.

[15:31] <masak> of course, things like stack-based or register-based will affect how it's all implemented.

[15:31] <timotimo> i have absolutely no frame of reference in which to evaluate "no very high demands"

[15:32] <masak> what I mean is that nqp is quite a small language, with not too high demands on the VM.

[15:32] <masak> time to down scope again. gotta leave this room :)

[15:32] <masak> &

[15:32] <timotimo> have fun! :)

[15:32] * timotimo imagines masak as a little submarine

[15:39] *** daniel-s left
[15:39] * moritz has a too vivid mental image of masak as a person to imagine masak a submarine

[15:39] <moritz> but I can easily imagine a small submarines where all the masak clones travel together

[15:41] <timotimo> so, would the hypothetical vm have to supply lexical mechanisms? closures closing over things? classes? multiple dispatch? type checking? signature binding? tuples/lists/strings/hashes?

[15:42] <fijal> timotimo: who else?

[15:42] <timotimo> who else does what?

[15:43] <moritz> well, it's possible for the generated code (and not the VM) to do that

[15:43] <timotimo> fijal hinted that sometimes it's better for the generated code to do that when using rpython

[15:44] <timotimo> so, is going with the "bare minimum" a good choice? it would probably make the qast-hypoVM backend quite a bit bigger, isn't that right?

[15:44] <fijal> timotimo: who else implements that?

[15:45] <timotimo> oh, you meant my list of features? i don't really know

[15:45] <fijal> someone has to

[15:46] <timotimo> uh, i think i don't understand what you mean

[15:46] *** kaare__ joined
[15:47] <fijal> who implements a tuple?

[15:47] <fijal> yuo have to write it at some point

[15:47] <timotimo> of course. the VM's interpreter would have to, i imagine

[15:47] *** kaare_ left
[15:47] <timotimo> same as python, it has a create_tuple bytecode. i thought of that kind of thing

[15:47] <fijal> well

[15:47] <fijal> that's just a bytecode

[15:48] <fijal> there is a W_TupleObject

[15:48] <fijal> which is the actual implementation

[15:48] <fijal> timotimo: I suggest you walk around example_interpreter on the pypy's bitbucket website

[15:48] <timotimo> i'll have a look

[15:48] <benabik> You don't have to have create_tuple.  You can have 'new Tuple' instead.

[15:49] *** MayDaniel left
[15:49] <fijal> yeah whatever

[15:49] <FROGGS> yay, $(<code>) within regexes works now \o/

[15:50] <timotimo> right. all you need is a lambda and then you can make cons^H^H^H^Hintegers and cons cells

[15:50] <timotimo> bleh. my internet connection is getting flaky

[15:51] * benabik would not want to create REPRs in the pure lambda calculus.

[15:56] <timotimo> fijal: it does seem somewhat simple, yes

[16:07] *** fgomez joined
[16:07] <timotimo> FROGGS: what does that do?

[16:13] *** tokomer left
[16:13] <FROGGS> nr: sub abc($x) { $x * 2 - 1 }; say "1234" ~~ /$(abc("12").substr(1))/

[16:13] <p6eval> rakudo 6d5dc6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name␤at /tmp/D_wI2jx_SH:1␤------> [32mabc($x) { $x * 2 - 1 }; say "1234" ~~ /$[33m⏏[31m(abc("12").substr(1))/[0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix …

[16:13] <p6eval> ..niecza v24-18-gaf64300: OUTPUT«#<match from(2) to(3) text(3) pos([].list) named({}.hash)>␤»

[16:13] <FROGGS> it is a contextualizer

[16:13] <FROGGS> nr: sub abc($x) { $x * 2 - 1 }; say "1234" ~~ /$( abc("12") )/

[16:13] <p6eval> niecza v24-18-gaf64300: OUTPUT«#<match from(1) to(3) text(23) pos([].list) named({}.hash)>␤»

[16:13] <p6eval> ..rakudo 6d5dc6: OUTPUT«#<failed match>␤»

[16:14] <FROGGS> need to clean up, but then I can push to nom

[16:15] <FROGGS> n: say "abcd" ~~ / \w ** $( 1+1 ) /

[16:15] <p6eval> niecza v24-18-gaf64300: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** $( 1+1 ) as separator; nowadays please use atom+ % $( 1+1 ) at /tmp/sFZNl1U74R line 1:␤------> [32msay "abcd" ~~ / \w ** $( 1+1 )[33m⏏[31m /[0m␤␤#<match from(0) to(1) text(a) pos([].list) named({}.ha…

[16:15] <FROGGS> hmmm, dunno I this is supposed to work

[16:16] <FROGGS> std: say "abcd" ~~ / \w ** $( 1+1 ) /

[16:16] <p6eval> std 7deb9d7: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** $( 1+1 )  as separator; nowadays please use atom +% $( 1+1 )  at /tmp/uWQaSi4GGr line 1:␤------> [32msay "abcd" ~~ / \w ** $( 1+1 ) [33m⏏[31m/[0m␤ok 00:00 44m␤»

[16:17] <timotimo> what? :)

[16:17] <FROGGS> you can put variables inside a regex, and it will match

[16:17] <FROGGS> nr: my $x = "cd"; say "abcd" ~~ /$x/

[16:17] <p6eval> rakudo 6d5dc6: OUTPUT«｢cd｣␤␤»

[16:17] <p6eval> ..niecza v24-18-gaf64300: OUTPUT«#<match from(2) to(4) text(cd) pos([].list) named({}.hash)>␤»

[16:18] <FROGGS> but to insert code there, you need to wrap it inside <{ }> or $( )

[16:18] <Celelibi> I suppose that the C written modules are not compatible at all between perl5 and perl6. Right?

[16:18] <timotimo> oh okay

[16:20] <FROGGS> Celelibi: right, even if you could pure perl5 modules directly atm, perlxs modules wont work

[16:20] <Celelibi> k

[16:20] *** fijal left
[16:20] <FROGGS> there is NativeCall and Inline::C for that reason (to be able to port them)

[16:22] <timotimo> FROGGS: good work :)

[16:24] <FROGGS> timotimo: thanks

[16:25] <FROGGS> dunno what exactly you mean tbh

[16:25] <timotimo> to be honest

[16:26] <FROGGS> TimToady: is that supposed to work? say "abcd" ~~ / \w ** <{ 1+1 }> /   or   say "abcd" ~~ / \w ** $( 1+1 ) /

[16:27] <FROGGS> timotimo: "good work" <-- what do you mean?

[16:29] <timotimo> it's good that you did that :)

[16:30] *** cognominal joined
[16:30] *** SunilJoshi left
[16:35] <FROGGS> k :o)

[16:36] *** PacoAir left
[16:52] *** cognominal__ joined
[16:53] *** am0c left
[16:54] *** cognominal left
[17:04] <nwc10> is the levenshtein code that's tweaked to run under NQP-JVM available anywhere?

[17:08] *** SunilJoshi joined
[17:10] *** pmurias joined
[17:13] *** kaare__ is now known as kaare_

[17:18] *** shinobicl left
[17:19] <pmurias> timotimo: re creating yet another custom VM, I think it would be better to focus effort on existing nqp backends then create yet another one

[17:21] <timotimo> nwc10: it was a literal 1:1 copy of the levenshtein sub from World.pm in rakudo

[17:21] <timotimo> the only changes were to turn nqp::join into ~ and to turn the <= into < for the switch-letters code at the bottom

[17:25] <timotimo> pmurias: the pypy tracing jit and pluggable GC technology is darn nice, though.

[17:27] <swarley> Alright, just finished the Nodes for YARV QAST

[17:29] <pmurias> swarley: do you have that commited somewhere?

[17:29] <swarley> No, but it's pretty much the same as nqp-jvm's

[17:29] <swarley> Except without the opcodes

[17:30] <swarley> And it uses a YARV iseq skeleton subroutine at the bottom

[17:30] <swarley> which should just be a constant now that i think about it

[17:31] <swarley> well, does nqp/perl6 have something like dup in ruby?

[17:31] <swarley> Duplicates the object so that you don't modify the original

[17:32] * pmurias check how nqp::clone works

[17:32] <pmurias> * checks

[17:34] *** MikeFair joined
[17:37] <pmurias> swarley: there is pir::repr_clone__PP($obj)

[17:37] <pmurias> swarley: what do you want to clone?

[17:37] *** SunilJoshi left
[17:38] <TimToady> nqp: say(42.WHAT); say((42 but Real).WHAT)

[17:38] <p6eval> nqp: OUTPUT«Confused at line 2, near "say((42 bu"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[17:38] <TimToady> I guess nqp doesn't do "but"?

[17:39] <masak> correct.

[17:40] <nwc10> Mmm, that's interesting. I get different answers when running under NQP and NQP-JVM

[17:41] <pmurias> swarley: once you have something (semi) working I would be very interested at look at your code to see what approach are you using ;)

[17:44] <swarley> No, I don't really have anything working yet, I'm working on setting up the toplevel node right now. If I declare a nqp::hash() can I access it like a normal p6 hash, or do I use nqp methods?

[17:45] <pmurias> you mean my $foo := nqp::hash()?

[17:46] <swarley> yes

[17:46] <pmurias> nqp: my $foo := nqp::hash();$foo<bar> := 123;say($foo<bar>);

[17:46] <p6eval> nqp: OUTPUT«123␤»

[17:46] <swarley> oh good

[17:47] <pmurias> swarley: have you seen t/nqp in the nqp repo?

[17:47] <swarley> I haven't looked at it really

[17:50] <pmurias> it can be used for examples of what's valid in nqp ;)

[17:53] <swarley> I'll give the Nodes.nqp file out once I've finished RAST::Root

[17:54] <swarley> But like I said, I basically retyped jnthn's Nodes.nqp

[17:54] <swarley> RAST::Root is the  first thing I've really had to code myself

[17:55] <swarley> but then again, after retyping everything, i believe there are only a few ways to do what was done

[17:59] *** MikeFair left
[18:00] *** swarley| joined
[18:03] *** MikeFair joined
[18:09] <jnthn> o/ from Stockholm

[18:09] <timotimo> hey jnthn 

[18:09] <arnsholt> \o

[18:09] <timotimo> i bugged fijal from the pypy team to come over and rant about jvm a bit, hope you'll enjoy the backlog :)

[18:10] *** swarley- joined
[18:11] <jnthn> Yes, I kinda followed.

[18:11] <jnthn> From the irclog on the train :)

[18:11] <timotimo> oh, OK

[18:12] <jnthn> I think anybody considering porting NQP needs to remember that this involves (a) 6model, (b) the bounded serialization stuff, and (c) the grammar engine. :)

[18:13] <timotimo> i was afraid of that, especially the grammar engine part.

[18:13] <arnsholt> I seem to recall a conversation from the Oslo hackathon where you said something to the effect that Perl 6 ideally wants a VM with a bit less typing than JVM/CLR, but more than Perl/Python usually operate with

[18:13] <arnsholt> That right?

[18:13] *** swarley| left
[18:13] <jnthn> arnsholt: Something like. Really it boils down to, "understands 6model".

[18:13] <arnsholt> True, true

[18:13] <stevan_> jnthn: howdy

[18:13] *** swarley| joined
[18:14] * benabik has pondered welding together 6model + libgc + llvm.

[18:14] * benabik in his copious spare time...  :-/

[18:14] *** swarley- left
[18:14] <stevan_> jnthn: I recall at one point looking at an NQP implementation of 6model, but I can't seem to find it (at least not in the NQP repo), can you point me to the right place (assuming it still exists)?

[18:14] <arnsholt> The current NQP 6model is mostly in C, I think

[18:15] <arnsholt> src/6model/*

[18:15] <moritz> it's teh metamodel that's written in NQP

[18:15] <stevan_> yeah, thats what I found, but I know I saw one in NQP at one point when I was starting on the p5-mop project

[18:15] <stevan_> moritz: yeah, that :)

[18:16] <moritz> rakudo's metamodel is in src/Perl6/Metamodel/*.pm

[18:16] <moritz> in the rakudo repo. obviously :-)

[18:16] <stevan_> ah, thanks

[18:16] <stevan_> was looking in the entirely wrong place :)

[18:16] <moritz> and NQP's metamodel (which is much simpler) is in the nqp repo in src/how/*.pm

[18:16] <jnthn> stevan_: src/how/ in the NQP repo

[18:17] <moritz> where "how" stands for "higher order workings" or so :-)

[18:17] <jnthn> stevan_: The very core bootstrap is done in C (or Java on the JVM)

[18:17] <stevan_> k

[18:17] <jnthn> stevan_: Where "the very core" is...very primitive. :)

[18:17] <pmurias> or js on nqp-js (which is currently bitrotten) ;)

[18:17] <jnthn> src/how/ is where we then implement classes and roles.

[18:18] <jnthn> pmurias: You'll be glad to know that src/how/ is just about free of pir:: these days :)

[18:18] <jnthn> pmurias: Gimme another week or so and it'll be free of the v-table stuff too.

[18:18] <jnthn> OK, I should go join a copule of cow orkers for dinner... :)

[18:18] <jnthn> be back later on o/

[18:19] <arnsholt> jnthn: Speaking of NQP, I failed at fixing the bootstrap stuff. I got NQP compiling, but got some weird failure in Rakudo instead

[18:19] <moritz> \o

[18:19] <arnsholt> I'll give it another whack tomorrow

[18:19] <benabik> .oO( How do you ork a cow? )

[18:20] <pmurias> jnthn: nice, I'll get to work on nqp-js in a week or so after my exams end

[18:21] <nwc10> jnthn: NQP-JVM bug:

[18:21] <nwc10> $ nqp nqp-jvm-cc.nqp  -e 'nqp::say(nqp::substr("ABC", 2, 1));'

[18:21] <nwc10> output is just a newline

[18:21] <nwc10> not C

[18:32] *** palakas_ joined
[18:33] *** palakas__ left
[18:35] *** MikeFair__ joined
[18:35] *** MikeFair left
[18:38] <nwc10> jnthn: Fix, I believe: http://pasta.test-smoke.org/429

[18:39] <nwc10> timotimo: I think you had to replace <= with < due to a bug in substr3 in Ops.java

[18:41] <timotimo> not quite

[18:41] <timotimo> it was a bug in my code that was obscured by how substr3 works

[18:42] <nwc10> OK, I tried it with < and got a Java exception. Screenfuls about (I think) stack exhausted

[18:42] <nwc10> I think nqp::substr is buggy. I think I've fixed it locally.

[18:43] <nwc10> With that, I can run with <=

[18:43] <nwc10> but, if it's acutally a bug in your code, that's sort of interesting

[18:43] <nwc10> but it's nice, as it found a bug in the JVM bootstrap code

[18:43] <timotimo> it was a thinko i believe

[18:44] <timotimo> feel free to double check

[18:44] <moritz> if you get "javac: invalid source release: 1.7" on debian wheezy, install openjdk-7-jre  and run update-alternatives --config javac  and configure it to use the openjdk-7 one

[18:46] <timotimo> iirc i off by one'd that part

[18:46] <moritz> nqp nqp-jvm-cc.nqp --setting=NULL --target=classfile --output=nqp-mo.class nqp-src/nqp-mo.pm

[18:46] <moritz> Exception in thread "main" java.lang.UnsupportedClassVersionError: org/perl6/nqp/jast2bc/JASTToJVMBytecode : Unsupported major.minor version 51.0

[18:46] <moritz> grrr

[18:50] <masak> nwc10: nice catch.

[18:51] <nwc10> I hope I'm correct.

[18:51] <masak> nwc10: my first thought was that Java's .substring takes and 'end' parameter, not a 'length' parameter. but that doesn't seem to be the cause, given your fix.

[18:51] <masak> an*

[18:51] <nwc10> And I utterly slack, in that I didn't write (more) tests

[18:51] <masak> ;)

[18:54] <nwc10> The fine documentation at http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#substring%28int,%20int%29 says The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. Thus the length of the substring is endIndex-beginIndex. 

[18:54] <masak> aye.

[18:54] <masak> that was what I was referring to.

[18:54] <masak> whereas in Perl, we do $start, $length

[18:57] <moritz> I think I have implemented Perl 6 substr (or parts of it) at least twice, and usually had an offby1 bug somewhere

[18:58] * masak .oO( "offby1 bu" )

[18:59] <benabik> "offby1 bug\0" ?

[18:59] <huf> "offby2 bug" and repeat ad Inf

[19:02] <moritz> though I should add that the test suite usually caught them before I committed them

[19:03] <swarley> nqp: my @ary = ["foo","bar","baz"]; say(nqp::push(ary, "foobarbaz"))

[19:03] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " [\"foo\",\"b"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[19:03] <swarley> nqp: my @ary := ["foo","bar","baz"]; say(nqp::push(ary, "foobarbaz"))

[19:03] <p6eval> nqp: OUTPUT«push_pmc() not implemented in class 'NQPMu'␤current instr.: '' pc 107 ((file unknown):62) (/tmp/nN3E9L6AVT:1)␤»

[19:03] <swarley> nqp: my @ary := ["foo","bar","baz"]; say(nqp::push(@ary, "foobarbaz"))

[19:03] <p6eval> nqp: OUTPUT«4␤»

[19:03] <swarley> all sorts of typos

[19:03] <masak> swarley: you can make private experiments with p6eval by using /msg

[19:05] <swarley> Yeah, I just expected it to be a quick one

[19:05] <swarley> I would have queried it otherwise

[19:09] <moritz> happens to me too, occasionally

[19:09] * masak too

[19:11] <moritz> std: my ::&a &a

[19:11] <p6eval> std 7deb9d7: OUTPUT«ok 00:00 45m␤»

[19:11] * moritz doesn't even want to know how that's parsed

[19:12] <swarley> o-o

[19:12] <swarley> what the hell is that supposed to be

[19:13] <swarley> std: say "foo"

[19:13] <p6eval> std 7deb9d7: OUTPUT«ok 00:00 42m␤»

[19:13] *** Vlavv left
[19:13] <moritz> std just parses

[19:13] <swarley> oh

[19:13] <masak> moritz: it's not so strange. you can post-declare & vars (and subs).

[19:14] <masak> which is what you're doing there.

[19:14] <masak> r: &foo(); sub foo { say "OH HAI" }

[19:14] <p6eval> rakudo 6d5dc6: OUTPUT«OH HAI␤»

[19:14] <moritz> but aren't that two terms in a row?

[19:14] <masak> no, the first one is a type, methinks.

[19:14] <moritz> unless the ::&a is somhow parsed as a type constraint

[19:14] <masak> aye.

[19:14] <masak> that's how I read it :)

[19:14] <moritz> std: my ::&a $foo;

[19:14] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/KtH3T7dr8a line 1:␤------> [32mmy ::&a [33m⏏[31m$foo;[0m␤    expecting any of:␤       constraint␤     infix or meta-infix␤    infixed function␤       initializer␤    statement modifier loop␤        trait␤Parse

[19:14] <p6eval> ..failed␤FAILED 00:00 45m␤…

[19:14] <masak> and since you never run the thing, you don't get into trouble for it ;)

[19:15] <masak> hm.

[19:15] <masak> but there you didn't declare &a...

[19:15] <moritz> if it were a type, that would work for any variable

[19:15] <masak> std: my &a; my ::&a $foo

[19:15] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of routine 'a' (see line 1) at /tmp/Vdu3MPTJq_ line 1:␤------> [32mmy &a; my ::&a[33m⏏[31m $foo[0m␤Two terms in a row at /tmp/Vdu3MPTJq_ line 1:␤------> [32mmy &a; my ::&a [33m⏏[31m$foo[0m␤    expecting any…

[19:15] <masak> hrm.

[19:15] <masak> maybe it acts as a type capture...?

[19:15] <masak> in which case I'd expect a redeclaration error from STD.

[19:16] <moritz> and I'd expect it work with a $-variable too

[19:17] <masak> *nod*

[19:17] <masak> something is rotten in the STD of Denmark.

[19:20] <swarley> nqp: say(qw[foo bar]);

[19:20] <p6eval> nqp: OUTPUT«Confused at line 2, near "say(qw[foo"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[19:21] <flussence> rn: sub a { b }; sub b { warn 'c' }; my $*ERR = Nil; say a();

[19:21] <p6eval> niecza v24-18-gaf64300: OUTPUT«c␤  at /home/p6eval/niecza/lib/CORE.setting line 1287 (warn @ 5) ␤  at /tmp/36cBSGbmYV line 1 (b @ 4) ␤  at /tmp/36cBSGbmYV line 1 (a @ 4) ␤  at /tmp/36cBSGbmYV line 1 (mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ␤  at /ho…

[19:21] <p6eval> ..rakudo 6d5dc6: OUTPUT«c  in sub b at /tmp/ZnzWwyF4He:1␤␤0␤»

[19:21] <flussence> I want to screw around with $*ERR lexically but it won't let me :(

[19:21] <swarley> nqp: say(< a b >)

[19:21] <p6eval> nqp: OUTPUT«2␤»

[19:21] <swarley> oh alright

[19:22] <swarley> What is the difference between +< ... > and < ... ?

[19:22] <swarley> ?

[19:22] <swarley> err < ... >

[19:24] <swarley> because in the tests i see

[19:24] <swarley> ok( < a > eq 'a', 'spaces around individual element stripped');

[19:24] <swarley> ok( +< a b > == 2, 'angle quotes correctly produce list');

[19:24] <moritz> the + forces numeric context

[19:24] <moritz> just like

[19:24] <masak> <a> is just a weird way to write a string 'a'.

[19:25] <pmurias> nqp: my $a := <foo bar baz>;say($a[1]);

[19:25] <p6eval> nqp: OUTPUT«bar␤»

[19:25] <moritz> r: my @a = 'a', 'b', 'c'; say +@a

[19:25] <p6eval> rakudo 6d5dc6: OUTPUT«3␤»

[19:25] <masak> <a b>, however, is a list of strings.

[19:25] <masak> r: say <a b>.^name

[19:25] <p6eval> rakudo 6d5dc6: OUTPUT«Parcel␤»

[19:25] <masak> or a Parcel, whaddevuh.

[19:25] <swarley> o-o '^'?

[19:25] <moritz> .^method calls a method on a meta class

[19:26] <pmurias> meta class instance

[19:26] <swarley> Oh

[19:26] <masak> .^methods, even

[19:26] <swarley> Also, does < > interpolate?

[19:26] <masak> no.

[19:26] <masak> << >> does

[19:26] <moritz> nr: say so any(1,2) ~~  Int

[19:26] <p6eval> rakudo 6d5dc6, niecza v24-18-gaf64300: OUTPUT«False␤»

[19:26] <swarley> alright

[19:26] <masak> just like with ' and ", or q[] and qq[]

[19:26] <masak> strangely consistent ;)

[19:27] <swarley> Is it better to use the guillettes or the "texas" version?

[19:27] <swarley> err, sorry I may be using the wrong word

[19:27] <swarley> 􏿽xAB􏿽xBB

[19:27] <swarley> Those

[19:27] <moritz> it's mostly a matter of style and keyboard configuration

[19:27] <moritz> .u »

[19:27] <phenny> U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (»)

[19:27] *** cognominal__ left
[19:28] <masak> swarley: "better" is ill-defined in your question.

[19:29] <moritz> n: say (1|2).Str ~~ Str

[19:29] <p6eval> niecza v24-18-gaf64300: OUTPUT«True␤»

[19:31] <masak> dinner &

[19:31] <swarley> left pointing guillemet

[19:31] <swarley> that's what it's called

[19:31] <swarley> alright

[19:31] <swarley> Well, by better I mean, which is prefered style wise

[19:32] <masak> how do you mean? :)

[19:32] *** sevin joined
[19:32] <masak> who's doing the preferring here?

[19:32] <swarley> I suppose you all, since if something breaks i'll be crying somewhere and it seems that no one else but you all can help ;p

[19:35] <japhb> swarley, our only big preference right now is "Though shalt not put non-ASCII in the Rakudo setting", because that makes it compile really slowly.  And it's already one of the slowest parts of a Rakudo build.  :-/

[19:35] *** sizz left
[19:36] <swarley> Well, I'm dealing with nqp right now

[19:36] <japhb> People work around that by just specifying any needed Unicode by explicit codepoint, rather than putting the above-ASCII character directly in the code.

[19:36] *** sizz joined
[19:36] <swarley> I'll just use << >>

[19:36] <japhb> swarley: grep the existing source tree.  ;-)

[19:36] <swarley> Since vim syntax hilights it anyway

[19:37] <japhb> That's usually safest when you aren't sure.

[19:37] <swarley> it doesn't get the double angle

[19:44] *** sizz_ joined
[19:44] *** sizz left
[19:52] *** sizz joined
[19:52] *** sizz_ left
[19:54] *** adu joined
[19:57] *** pterygota joined
[19:58] *** sizz_ joined
[19:58] *** fijal joined
[19:58] <fijal> hi

[19:59] <fijal> so who's doing perl6 these days?

[19:59] *** sizz left
[20:01] <moritz> well, folks :-)

[20:01] <adu> hi moritz 

[20:01] <moritz> ih adu, fijal 

[20:01] <adu> Perl6 is so beautiful

[20:02] <lue> hello o/

[20:02] <arnsholt> fijal: Pretty good, I think =)

[20:02] <moritz> arnsholt: "who" not "how" :-)

[20:03] <arnsholt> Oh. Reading comprehension fail *facepalm*

[20:03] <moritz> unless I'm mixing up hvor and hvordan and whatever again :-)

[20:03] <arnsholt> =D

[20:04] <dalek> roast: b19c74d | moritz++ | S03-junctions/misc.t:

[20:04] <dalek> roast: RT #112392: Junction.Str should return a, well, Str

[20:04] <dalek> roast: review: https://github.com/perl6/roast/commit/b19c74d7d5

[20:04] *** pterygota left
[20:07] <fijal> heh

[20:07] <fijal> who's working on it

[20:08] <fijal> and also what are the directions

[20:08] <fijal> like, is parrot still the holy grail?

[20:08] <adu> fijal: the TODO?

[20:09] <adu> fijal: from what I hear, ppl are becoming increasingly unsatisfied with parrot

[20:10] <moritz> fijal: well, sorear and colomon are working on niecza, and jnthn, masak, timotimo, FROGGS, me and a few others are working on rakud (most of us on and off, jnthn rather constantly)

[20:10] <fijal> what's niecza?

[20:10] <fijal> or should I just read some docs?

[20:10] <adu> fijal: perl6 impl on CLI

[20:10] <moritz> fijal: and others like [Coke] are working on the tests, and occasinally patch some of the compilers to

[20:10] <fijal> oh ok

[20:11] <fijal> why do people believe in JVM/CLI so much?

[20:11] <moritz> and pmurias works on rakudo-in-javascript

[20:11] <adu> fijal: I don't believe in CLI, I believe in JVM tho

[20:11] <moritz> fijal: because quite some work has gone into them, and people hope to benefit from that work

[20:11] <moritz> fijal: and people want to be able to run Perl 6 on their phones, for example :-)

[20:12] *** sevin left
[20:12] <swarley> \o/ alright, if anyone is interested i just finished the code for the YARV root

[20:12] <pmurias> link to the repo?

[20:13] <swarley> Let me just gist the snippit, i don't have a full repo up yet

[20:13] <arnsholt> One interesting thing with JVM/CLI is language interop, which is something we want to do as well

[20:13] *** spider-mario left
[20:13] <swarley> http://pastebin.com/WfNviez9

[20:13] *** spider-mario joined
[20:14] <adu> was there a plan to support JVM?

[20:14] <adu> maybe it was just my plan

[20:14] <arnsholt> And as jnthn pointed out a little while back, no matter which backend we target, there's gonna be a whole pile of implementing to do (6model, metamodel, grammar engine)

[20:14] <moritz> adu: you should read http://planetsix.perl.org/ :-)

[20:14] <swarley> I can't believe that there is no perl6 hilighting for gist.github.com

[20:14] <arnsholt> s/metamodel/bounded serialization/ actually

[20:14] <swarley> but that there is on pastebin

[20:15] *** sevin joined
[20:15] <adu> swarley: Perl6 is difficult to highlight

[20:15] <pmurias> swarley: how do you plan to feed that into ruby?

[20:15] <moritz> swarley: hoelzro|away is working on Perl 6 syntax hilighting in pygments, which is what github uses

[20:15] <swarley> pmurias, MRI ruby has a new feature in 2.0 to load the data structure as an iseq

[20:16] <swarley> RubyVM::InstructionSequence.load(iseq_structure).eval

[20:16] <arnsholt> fijal: But if what you really want to know is why noone's doing it with Pypy, I'm not sure there's a very good answer beyond "noone went and did it"

[20:17] <adu> moritz: so jnthn is working on JVM

[20:18] <moritz> maybe one reason is that there isn't a particularly known track record of pypy used for languages other than python

[20:18] <moritz> *being used

[20:21] <fijal> arnsholt: oh I'm sure there is a bunch of good answers

[20:21] <fijal> arnsholt: I can provide you with a few if you're missing some

[20:21] <fijal> arnsholt: but seriously "cross language compatibility" and "access to JVM libs" seems very legit to me

[20:22] <tadzik> and the current Perl 5 experimentations are also happening around JVM

[20:23] <pmurias> fijal: a lot of the people

[20:23] <fijal> arnsholt: also RPython is an atrocious language

[20:23] <fijal> (still beats C++ though)

[20:24] <pmurias> fijal: seems to be interested in rakudo-jvm are using a lot of jvm stuff

[20:25] <fijal> pmurias: for example in python world jython has seen 0 interest from python people

[20:25] <fijal> (but quite a bit from java people)

[20:25] *** domidumont left
[20:26] <pmurias> fijal: re inspections of lexicals I think we can easily statically analyse that in Perl 6

[20:26] <swarley> Anyone have any comments on my code where it needs to be changed or fixed?

[20:28] *** MikeFair__ is now known as MikeFair

[20:29] <pmurias> swarley: seems ok, but I have zero YARV knowledge

[20:29] <fijal> pmurias: ok

[20:29] <fijal> pmurias: you can't do it in python or ruby

[20:29] <fijal> without cheating

[20:29] <adu> what's YARV?

[20:29] <fijal> the JVM and CLI implementations cheat

[20:30] <pmurias> adu: ruby vm

[20:30] <fijal> so is parrot seeing any development?

[20:30] <swarley> pmurias, I'm following the the output of RubyVM::InstructionSequence.compile("") exactly

[20:30] <adu> fijal: that last I heard was "slow"

[20:31] <pmurias> adu: it's much faster than the old one

[20:31] <adu> fijal: it's also in transition

[20:31] <fijal> from what to what?

[20:31] <adu> fijal: and while it's in transition, the documentation can appear out of date in some places

[20:31] <adu> fijal: from NQP to NQP

[20:31] <pmurias> adu: ?

[20:32] <adu> pmurias: perhaps I should explain myself better

[20:32] <FROGGS> adu; you're mixing up rakudo and parrot

[20:34] <adu> the compilers and libraries which are required to experiment with parrot, still use an older version of NQP, which makes it difficult to follow some parrot docs, such as the "getting started" docs

[20:34] <adu> FROGGS: how am I mixing them up?

[20:35] *** denisboyun_ joined
[20:35] <pmurias> fijal: there seem to be commits to the repo

[20:36] <FROGGS> adu: you answered that nqp is in transition, but the question was about parrots development state

[20:36] <pmurias> fijal: but one of the more active guys has started his own VM ;)

[20:36] <pmurias> (for Perl 5 and 6)

[20:37] <masak> are you referring to fglock's perlito?

[20:37] <moritz> rurban and potion, I think

[20:37] <pmurias> moritz: yes

[20:37] <FROGGS> there will be parrot 5.0 (or maybe is already released), so there is something going on, dont how how many devs are active

[20:38] <FROGGS> pmurias: another VM?

[20:39] <pmurias> http://perl11.org/p2/

[20:39] <FROGGS> can somebody please rum t/spec/S05-metasyntax/litvar.t and tell me if the array tests are ok? I'm not sure if I broke something or not

[20:40] <adu> FROGGS: my point is that many Parrot tools depend on NQP, the previous one, and so until it depends on the new NQP, Parrot is also in transition

[20:40] <moritz> FROGGS: no, it doesn't even parse

[20:40] <moritz> FROGGS: it's not run by 'make spectest'

[20:40] <FROGGS> moritz: I know that :o)

[20:40] * masak wonders if he has met the anonymous coward in the comments of http://6guts.wordpress.com/2013/02/02/a-look-at-the-preparations-behind-the-jvm-port-and-a-progress-update/

[20:41] <FROGGS> okay, so I maybe stash and uncomment the unparseable tests

[20:41] <FROGGS> or maybe ...

[20:42] <FROGGS> nr: my @var = <a b c>; say "a" ~~ /@var[0]/

[20:42] <p6eval> niecza v24-18-gaf64300: OUTPUT«Potential difficulties:␤  Apparent subscript will be treated as regex at /tmp/TUY2_0gp7v line 1:␤------> [32mmy @var = <a b c>; say "a" ~~ /@var[33m⏏[31m[0]/[0m␤␤Match()␤»

[20:42] <p6eval> ..rakudo 6d5dc6: OUTPUT«#<failed match>␤»

[20:42] <fijal> thanks guys

[20:42] *** fijal left
[20:44] <FROGGS> adu: I didnt know that there are parrot tools which need nqp, that explains it

[20:45] <adu> FROGGS: just read the Parrot "Getting Started" document: http://docs.parrot.org/parrot/devel/html/docs/book/pct/ch02_getting_started.pod.html

[20:46] <FROGGS> I see

[20:46] <adu> but that's just an example of it in documentation, I recall from past experience that you can't build parrot without it's nqp

[20:46] <dalek> rakudo/nom: 935c90c | moritz++ | / (2 files):

[20:46] <dalek> rakudo/nom: Calculate each year's Rakudo releases

[20:46] <dalek> rakudo/nom: 

[20:46] <dalek> rakudo/nom: also fill up the dates for 2013.

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/935c90cd44

[20:47] <FROGGS> pmurias: potion sounds good, but I tend to only believe stuff that I see ;o)

[20:47] *** sizz joined
[20:47] *** sizz_ left
[20:54] *** sizz left
[20:54] *** sizz joined
[20:58] <swarley> nqp: class Foo { has @.bar; method setup() { @.bar := [1,2,3] } }; say(Foo.new().setup().bar);

[20:58] <p6eval> nqp: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}' at line 2, near "has @.bar;"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[20:59] <swarley> nqp: class Foo { has @.bar; method setup() { @!bar := [1,2,3] } }; say(Foo.new().setup().bar);

[20:59] <p6eval> nqp: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}' at line 2, near "has @.bar;"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[21:00] * swarley floats to a query

[21:01] *** sizz_ joined
[21:02] *** sizz left
[21:03] <swarley> nqp: class Foo {has @.array}; say(Foo.new(:array([1,3,3])).array)

[21:03] <p6eval> nqp: OUTPUT«Unable to parse expression in blockoid; couldn't find final '}' at line 2, near "has @.arra"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[21:03] <swarley> r: class Foo {has @.array}; say(Foo.new(:array([1,3,3])).array)

[21:03] <p6eval> rakudo 6d5dc6: OUTPUT«1 3 3␤»

[21:03] <swarley> Why doesn't it work in nqp?

[21:03] <moritz> swarley: nqp doesn't support generation of accessors

[21:03] <swarley> oh

[21:04] <moritz> swarley: you can use private attributes with 'has @!bar;'

[21:04] <swarley> Why not?  That doesn't seem like that advanced of a feature

[21:04] <moritz> and writing your own   method bar() { @!bar }  as an accessor

[21:04] <swarley> Well that's what I have now, i was just trying to clean it up

[21:06] *** jasonmay joined
[21:06] <swarley> how would you say that a method requires at least one argument but can take many more?

[21:06] <swarley> *@args would allow for zero, i think

[21:08] <masak> swarley: the invocant is counted as a parameter to a method.

[21:08] <swarley> invocant?

[21:08] <masak> the object on which the method was called.

[21:09] <swarley> oh

[21:09] <masak> r: class C { has $.name; method foo { say self, " is the invocant" }; method gist { $.name } }; C.new(:name<Philip>).foo

[21:09] <p6eval> rakudo 935c90: OUTPUT«Philip is the invocant␤»

[21:10] <masak> r: class C { has $.name; method foo($usually-hidden-invocant: ) { say "$usually-hidden-invocant is the invocant" }; method gist { $.name } }; C.new(:name<Philip>).foo

[21:10] <p6eval> rakudo 935c90: OUTPUT«C<-45509055> is the invocant␤»

[21:10] <masak> o.O

[21:10] <swarley> wat

[21:10] * masak submits rakudobug

[21:10] <masak> r: class C { has $.name; method foo($x: ) { say "$x is the invocant" }; method gist { $.name } }; C.new(:name<Philip>).foo

[21:10] <p6eval> rakudo 935c90: OUTPUT«C<1645388291> is the invocant␤»

[21:11] <masak> .gist... stops working... when the method takes an explicit invocant!?

[21:12] <pmurias> swarley: re why not? because accessor are rw methods in Perl6 and nqp doesn't support assignment

[21:13] <swarley> ohh

[21:13] <masak> oh! notabug.

[21:14] <masak> since when things are interpolated in a string, .Str is called, not .gist

[21:14] <masak> if you ask me, I think we got one method too many there in the end :/

[21:14] <masak> r: class C { has $.name; method foo($x: ) { say "$x is the invocant" }; method Str { $.name } }; C.new(:name<Philip>).foo

[21:14] <p6eval> rakudo 935c90: OUTPUT«Philip is the invocant␤»

[21:18] <swarley> nqp: say(nqp::unshift([1,2,3], 0).join(' ,')

[21:18] <p6eval> nqp: OUTPUT«Confused at line 2, near "say(nqp::u"␤current instr.: 'panic' pc 13207 (src/stage2/gen/NQPHLL.pir:4680) (src/stage2/gen/NQPHLL.pm:328)␤»

[21:18] <swarley> nqp: say(nqp::unshift([1,2,3], 0).join(' ,'))

[21:18] <p6eval> nqp: OUTPUT«Method 'join' not found for invocant of class 'ResizablePMCArray'␤current instr.: '' pc 74 ((file unknown):47) (/tmp/V3PG7wCUYk:1)␤»

[21:18] <swarley> o-o

[21:18] * swarley floats back to query

[21:19] <pmurias> query?

[21:19] <masak> reply.

[21:19] <masak> enthusiastic reply!

[21:19] <FROGGS> nqp: say(nqp::join(', ' ,nqp::unshift([1,2,3], 0)))

[21:19] <p6eval> nqp: OUTPUT«0, 1, 2, 3␤»

[21:19] *** fijal joined
[21:19] <fijal> oh

[21:19] <fijal> and one more thing

[21:19] <swarley> yeah, i just figured that out

[21:20] <fijal> if you guys are moving to JVM, what about 1-liners?

[21:20] <masak> fijal: what about them?

[21:20] <fijal> well

[21:20] <fijal> startup is a mess

[21:21] *** aindilis joined
[21:21] <pmurias> fijal: we can use rakudo-js for 1-liners ;)

[21:21] <pmurias> fijal: or a persistent interpreter

[21:21] <swarley> are we using v8 for rakudo-js? :p

[21:21] <arnsholt> Well, we're not ditching Parrot

[21:21] <fijal> uh

[21:21] <fijal>  see

[21:22] <swarley> there is an interesting project called HotRuby

[21:22] <fijal> pmurias: is the JS for the web?

[21:22] <swarley> it's a ruby interpreter using ActionScript and JavaScript

[21:22] <fijal> how well it works?

[21:22] <swarley> it's fairly shitty

[21:22] <fijal> ok

[21:22] <swarley> Neat proof of concept though

[21:23] <swarley> Ruby embedded into html

[21:23] <fijal> there is like a billion of those for Python

[21:23] <swarley> where the user actually has python on their end?

[21:24] <swarley> yes, there are plenty of ruby embedders, but no others that allow for web browsers to evaluate the code themselves that i'm aware of

[21:25] <fijal> yeah

[21:26] <fijal> python interpreter in JS, python-to-JS translator, pick your poison

[21:26] <fijal> mostly shitty

[21:26] <pmurias> swarley: yes, I'm using v8 (through node)

[21:26] <swarley> sweet

[21:26] <swarley> I love v8 lol

[21:27] <pmurias> https://github.com/pmurias/rakudo-js but it's a bit bitrotten atm

[21:28] <swarley> I'm rewriting my Nodes right now that I have a better grasp on what I'm doing

[21:29] <arnsholt> fijal: Oh, one pretty awesome thing we have (I'm biased though), is the FFI module: https://github.com/jnthn/zavolaj/

[21:29] <swarley> Interesting

[21:29] *** PacoAir_ joined
[21:30] <fijal> arnsholt: have you seen cffi? ;-)

[21:30] <fijal> arnsholt: how do you deal with macros?

[21:31] <arnsholt> We don't deal with macros. Which is really annoying when dealing with ncurses

[21:32] <arnsholt> I've not looked a lot at other FFIs, but did look at a Common Lisp one (Allegro CL, if you care)

[21:32] <arnsholt> Allegro's FFI was quite similar to Zavolaj, TBH

[21:34] <fijal> arnsholt: we have soemthing that's based on luajit ffi + verifier

[21:34] <fijal> (which essentially elevates ABI to API)

[21:35] <arnsholt> Cool. Linky?

[21:35] <fijal> http://cffi.readthedocs.org/en/latest/

[21:37] <arnsholt> (Regarding macros, I have something resembling a plan, but no code yet)

[21:37] *** pmurias left
[21:38] <masak> I love it when a plan but no code yet comes together.

[21:39] <fijal> arnsholt: we essentially invoke C compiler

[21:39] <fijal> to figure out details

[21:39] <fijal> (you can do it on the setup step)

[21:40] <arnsholt> That works

[21:40] <arnsholt> We synthesise it from the subroutine signatures and use libdyncall to do the heavy lifting

[21:41] <fijal> ok

[21:41] <fijal> I think we use libffi

[21:42] <fijal> but we can use the JIT too

[21:42] <fijal> (libffi - not recommended)

[21:43] <arnsholt> star: use NativeCall; sub printf(Str) is native { * }; printf("Greetings from C") # Like so

[21:43] <p6eval> star 2012.12: OUTPUT«Greetings from C»

[21:44] <fijal> cool

[21:44] <masak> \o/

[21:45] <masak> star: use NativeCall; sub printf(Str) is native { * }; printf("%d", 42)

[21:45] <swarley> Alright, I'm rewriting Nodes.nqp. Partial file is here. Tell me if you guys see any blatant errors, if you could. https://github.com/swarley/nqp-yarv/blob/master/lib/RAST/Nodes.nqp

[21:45] <p6eval> star 2012.12: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'printf' will never work with argument types (Str, Int) (line 1)␤    Expected: :(Str )␤»

[21:45] <masak> star: use NativeCall; sub printf(Str, Int) is native { * }; printf("%d", 42)

[21:45] <p6eval> star 2012.12: OUTPUT«42»

[21:45] <arnsholt> jnthn++ implemented the hard parts, and then I've added more functionality

[21:45] <masak> star: use NativeCall; sub printf(Str $format, *@args) is native { * }; printf("%d", 42)

[21:45] <p6eval> star 2012.12: OUTPUT«Unknown type Positional used in native call.␤If you want to pass a struct, be sure to use the CStruct representation.␤If you want to pass an array, be sure to use the CArray type.␤  in sub type_code_for at /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/lib/Nati…

[21:45] <arnsholt> Yeah, varargs isn't implemented yet

[21:46] <masak> just testing :)

[21:46] <masak> step at a time. :)

[21:46] <arnsholt> Indeed

[21:47] <arnsholt> Not entirely sure how to do it, TBH. Have to see if there's something special for it in dyncall, or maybe I just pretend it's a normal sig

[21:47] <swarley> break out your handy dandy assembly ;p

[21:47] <swarley> pop the stack \o/

[21:48] <arnsholt> dyncall has taken care of the assembly, thankfully

[21:48] <arnsholt> I've never programmed in assembly, believe it or not =)

[21:49] <swarley> it's not fun

[21:49] <swarley> lol

[21:49] <swarley> believe me

[21:49] <swarley> https://github.com/swarley/ZerOS/tree/master/src/string

[21:49] <swarley> And I did most of that incorrectly, I'm sure

[21:50] *** kaare_ left
[21:50] <arnsholt> Sleepytime now, I think

[21:50] <arnsholt> o/

[21:51] * arnsholt &

[21:53] * lue has no aversion to assembler

[21:55] *** cognominal joined
[21:58] *** denisboyun_ left
[21:59] *** spider-mario left
[22:05] *** cognominal left
[22:06] <[Coke]> nwc10++

[22:12] *** Subterra joined
[22:13] *** PacoAir_ left
[22:13] *** Ayiko left
[22:16] *** cognominal joined
[22:17] <jnthn> That was more beer than expected... :)

[22:17] <jnthn> EBEERLIKINGCOWORKER :)

[22:18] *** fijal left
[22:20] *** shinobicl joined
[22:22] *** FROGGS left
[22:30] *** shinobicl left
[22:52] *** renormalist left
[22:52] *** renormalist joined
[22:54] *** adu left
[22:58] *** renormalist left
[22:58] *** renormalist joined
[22:59] *** sevin left
[23:04] *** sevin joined
[23:11] *** vmspb joined
[23:12] <jnthn> sleep...will probably bee offline until tomorrow evening &

[23:12] <jnthn> *be

[23:13] <masak> bzzz well, jnthn.

[23:13] <masak> 'night, #perl6

[23:14] *** cognominal left
[23:15] <lue> are repo-url and source-url synonyms?

[23:15] <lue> (in META.info files, that is)

[23:19] *** cognominal joined
[23:35] *** cognominal left
[23:35] *** cognominal__ joined
[23:39] *** shinobicl joined
[23:45] *** Pleiades` left
[23:49] *** shinobicl left
[23:50] *** Pleiades` joined
