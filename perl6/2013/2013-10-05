[00:00] <[Coke]> nqp: say(nqp::radix(12345678901234567890,22))

[00:00] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op call (source text: "nqp::radix(12345678901234567890,22)"): Error while compiling op radix (source text: "nqp::radix(12345678901234567890,22)"): Operation 'radix' requires 4 operands, but got 2␤current instr.: '' pc…»

[00:01] <[Coke]> nqp: say(nqp::base_I(12345678901234567890,22))

[00:01] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op call (source text: "nqp::base_I(12345678901234567890,22)"): Error while compiling op base_I (source text: "nqp::base_I(12345678901234567890,22)"): Cannot infer type from '-9223372036854775808'␤current instr.: '' pc…»

[00:01] <diakopter> [Coke]: not in nqp?

[00:01] <[Coke]> I just did an update of perl6/nqp - no moar stuff in srv/mv

[00:01] <[Coke]> *src/vm

[00:02] <[Coke]> nqp: say(nqp::base_I(123456780,22))

[00:02] <camelia> nqp: OUTPUT«(signal SEGV)»

[00:02] <diakopter> [Coke]: moarvm has its own NQP

[00:02] <diakopter> but it'll be integrated similar to the parrot backend once it's bootstrapped on there

[00:02] <dalek> Perlito: 0d9f88e | (Flavio S. Glock)++ | / (3 files):

[00:02] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - declarators, subroutines

[00:02] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/0d9f88e574

[00:02] <[Coke]> ok.

[00:02] <[Coke]> .to masak: nqp: say(nqp::base_I(123456780,22)) -- SEGV

[00:02] <yoleaux> [Coke]: What kind of a name is "masak:"?!

[00:02] <diakopter> nqp-jvm: say(nqp::base_I(123456780,22))

[00:03] <[Coke]> .to masak nqp: say(nqp::base_I(123456780,22)) -- SEGV

[00:03] <yoleaux> [Coke]: I'll pass your message to masak.

[00:03] <camelia> nqp-jvm: OUTPUT«P6int representation does not support natively typed attributes␤  in  (/tmp/dHGcM9J1tu:1)␤  in  (src/stage2/gen/NQPHLL.nqp:1091)␤  in eval (src/stage2/gen/NQPHLL.nqp:1077)␤  in evalfiles (src/stage2/gen/NQPHLL.nqp:1283)␤  in command_eval (src/stage2/gen/NQP…»

[00:03] <[Coke]> nqp-jvm: say(nqp::base_I(123456780,22))

[00:03] <camelia> nqp-jvm: OUTPUT«P6int representation does not support natively typed attributes␤  in  (/tmp/usvCPaArms:1)␤  in  (src/stage2/gen/NQPHLL.nqp:1091)␤  in eval (src/stage2/gen/NQPHLL.nqp:1077)␤  in evalfiles (src/stage2/gen/NQPHLL.nqp:1283)␤  in command_eval (src/stage2/gen/NQP…»

[00:03] <diakopter> nqp-m: say(nqp::base_I(123456780,22))

[00:03] <camelia> nqp-moarvm: OUTPUT«This representation (P6int) cannot unbox to other types␤   at /tmp/8qEdI36CYf:2  (<ephemeral file>:frame_name_0:4294967295)␤ from nqp-src/NQPHLL.nqp:1084  (./NQPHLLMoar.moarvm:frame_name_671:97)␤ from nqp-src/NQPHLL.nqp:1070  (./NQPHLLMoar.moarvm:eval:87)␤…»

[00:03] <diakopter> heh.

[00:03] *** Mouq left
[00:03] <[Coke]> guessing this opcode might be slightly undertested. :)

[00:03] <diakopter> I didn't even know moarvm had a base_I op

[00:04] *** Mouq joined
[00:04] <[Coke]> nqp: say(nqp::base_I(1,10));

[00:04] <camelia> nqp: OUTPUT«(signal SEGV)»

[00:06] <diakopter> nqp-m: say(nqp::base_I(1,10))

[00:06] <camelia> nqp-moarvm: OUTPUT«This representation (P6int) cannot unbox to other types␤   at /tmp/R9pXu7BbWl:2  (<ephemeral file>:frame_name_0:4294967295)␤ from nqp-src/NQPHLL.nqp:1084  (./NQPHLLMoar.moarvm:frame_name_671:97)␤ from nqp-src/NQPHLL.nqp:1070  (./NQPHLLMoar.moarvm:eval:87)␤…»

[00:06] <diakopter> [Coke]: you like how quickly nqp-m responds over irc? :)

[00:06] <diakopter> nqp: say(nqp::time_n - nqp::time_n)

[00:06] <camelia> nqp: OUTPUT«-1.19209289550781e-06␤»

[00:06] <[Coke]> it exploded right quick!

[00:07] <diakopter> nqp-jvm: say(nqp::time_n - nqp::time_n)

[00:07] <camelia> nqp-jvm: OUTPUT«0␤»

[00:07] <[Coke]> nqp: say(nqp::base_I(nqp::box_i(1),10));

[00:07] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op call (source text: "nqp::base_I(nqp::box_i(1),10)"): Error while compiling op base_I (source text: "nqp::base_I(nqp::box_i(1),10)"): Error while compiling op box_i (source text: "nqp::box_i(1)"): Operation 'box_i' re…»

[00:07] <diakopter> wow, nqp-jvm auto-parallelized that nicely. ;)

[00:07] <[Coke]> nqp: say(nqp::base_I(nqp::box_i(1,Int),10));

[00:07] <camelia> nqp: OUTPUT«This type cannot box a native integer␤current instr.: '' pc 93 ((file unknown):37544653) (/tmp/IKBYLkZ8mC:1)␤»

[00:07] <diakopter> nqp-m: say(nqp::time_n - nqp::time_n)

[00:07] <camelia> nqp-moarvm: OUTPUT«-0␤»

[00:07] <diakopter> hahahahaha

[00:07] <diakopter> that's awesome

[00:09] <diakopter> nqp: say(nqp::base_I((my $a := 1),(my $b := 10))

[00:09] <camelia> nqp: OUTPUT«Redeclaration of symbol $a at line 2, near ":= 1),(my "␤current instr.: 'panic' pc 14748 (src/stage2/gen/NQPHLL.pir:5229) (src/stage2/gen/NQPHLL.nqp:279)␤»

[00:09] <diakopter> haha that's even better

[00:09] <diakopter> nqp-jvm: say(nqp::base_I((my $a := 1),(my $b := 10))

[00:09] <camelia> nqp-jvm: OUTPUT«Redeclaration of symbol $a at line 2, near ":= 1),(my "␤  in panic (src/stage2/gen/NQPHLL.nqp:279)␤  in variable_declarator (src/stage2/gen/NQP.nqp:2493)␤  in !reduce (src/stage2/gen/QRegex.nqp:667)␤  in !cursor_pass (src/stage2/gen/QRegex.nqp:631)␤  in var…»

[00:09] <diakopter> nqp-m: say(nqp::base_I((my $a := 1),(my $b := 10))

[00:09] <camelia> nqp-moarvm: OUTPUT«Redeclaration of symbol $a at line 2, near ":= 1),(my "␤panic»

[00:09] <diakopter> <shrug>

[00:12] *** Psyche^ joined
[00:13] *** grondilu left
[00:13] *** raiph joined
[00:16] *** Psyche^_ left
[00:16] *** Mouq left
[00:17] *** pippo joined
[00:18] <pippo> r: my $m = mix <a foo a a a a b foo>; say $m.perl; say $m.kv;

[00:18] <camelia> rakudo 93c627: OUTPUT«Mix.new-fp("a"=>5,"foo"=>2,"b"=>1)␤0 a 1 foo 2 b␤»

[00:19] <pippo> r: my $m = mix <a foo a a a a b foo>; say $m.perl; say $m.hash.kv;

[00:19] <camelia> rakudo 93c627: OUTPUT«Mix.new-fp("a"=>5,"foo"=>2,"b"=>1)␤a 5 foo 2 b 1␤»

[00:20] <pippo> n: my $m = mix <a foo a a a a b foo>; say $m.perl; say $m.hash.kv;

[00:20] <camelia> niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'mix' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_un…»

[00:21] <pippo> n: my $m = mix <a foo a a a a b foo>; say $m.perl; say $m.hash.kv; say $m.pairs;

[00:21] <camelia> niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'mix' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_un…»

[00:21] <pippo> r: my $m = mix <a foo a a a a b foo>; say $m.perl; say $m.hash.kv; say $m.pairs;

[00:21] <camelia> rakudo 93c627: OUTPUT«Mix.new-fp("a"=>5,"foo"=>2,"b"=>1)␤a 5 foo 2 b 1␤"a" => 5 "foo" => 2 "b" => 1␤»

[00:21] <[Coke]> nqp: my @arr := 1,2,3; say(nqp::push_i(@arr,3));

[00:21] <camelia> nqp: OUTPUT«push_integer() not implemented in class 'Integer'␤current instr.: '' pc 70 ((file unknown):50876626) (/tmp/l5e6JyaL8R:1)␤»

[00:21] <[Coke]> nqp: my @arr := 1,2,3; say(nqp::push_i(3, @arr));

[00:21] <camelia> nqp: OUTPUT«push_integer() not implemented in class 'Integer'␤current instr.: '' pc 76 ((file unknown):46062836) (/tmp/2dWFLc7f9_:1)␤»

[00:22] *** pippo left
[00:22] <[Coke]> nqp: my @arr := nqp::split(' ', 'a b c'); say(nqp::push(@arr,"hi"));

[00:22] <camelia> nqp: OUTPUT«[ "a", "b", "c", "hi" ]␤»

[00:22] <[Coke]> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); say(nqp::push(@arr,"hi"));

[00:22] <camelia> nqp-jvm: OUTPUT«hi␤»

[00:23] <[Coke]> let's pick the sane behavior and fix that

[00:24] <[Coke]> (both of those are different from p5's behavior)

[00:33] <Ben_Goldberg> r: my @a = 1..3; say push @a, 4

[00:33] <camelia> rakudo 93c627: OUTPUT«1 2 3 4␤»

[00:34] <Ben_Goldberg> Is the return value of rakudo's push equal to the return value of nqp::push?

[00:36] <Ben_Goldberg> If not, and if nqp::push's return value is not used anywhere within rakudo, then perhaps it doesn't matter?

[00:37] <Ben_Goldberg> Obviously if nqp::push's return value *is* used, then nevermind :), and it obviously needs to be consistant across VMs. :)

[00:40] <Ben_Goldberg> nqp-m: my @a := 'a','b','c'; say(nqp::push(@a,'d');

[00:40] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say(nqp::p"␤panic»

[00:41] <Ben_Goldberg> nqp-m: my @a := nqp::split(' ', 'a b c'); say(nqp::push(@a,'d');

[00:41] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say(nqp::p"␤panic»

[00:41] <Ben_Goldberg> nqp-m: my @arr := nqp::split(' ', 'a b c'); say(nqp::push(@arr,"hi"));

[00:41] <camelia> nqp-moarvm: OUTPUT«hi␤»

[00:41] *** slavik left
[00:43] <Ben_Goldberg> nqp-m: my @arr := nqp::split(' ', 'a b c'); my $t1 = npq::time; nqp::push(@arr,"hi")); say( nqp::time - $t1 );

[00:43] <camelia> nqp-moarvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " npq::time"␤panic»

[00:43] <Ben_Goldberg> nqp-m: my @arr := nqp::split(' ', 'a b c'); my $t1 := npq::time; nqp::push(@arr,"hi")); say( nqp::time - $t1 );

[00:43] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "nqp::push("␤panic»

[00:44] * Ben_Goldberg is just plain confused.

[00:44] <Ben_Goldberg> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); my $t1 := npq::time; nqp::push(@arr,"hi")); say( nqp::time - $t1 );

[00:44] <camelia> nqp-jvm: OUTPUT«Confused at line 2, near "nqp::push("␤  in panic (src/stage2/gen/NQPHLL.nqp:279)␤  in comp_unit (src/stage2/gen/NQP.nqp:766)␤  in TOP (src/stage2/gen/NQP.nqp:663)␤  in parse (src/stage2/gen/QRegex.nqp:1190)␤  in parse (src/stage2/gen/NQPHLL.nqp:1369)␤  in…»

[00:44] <Ben_Goldberg> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); my $t1 := npq::time; nqp::push( @arr,"hi" ); say( nqp::time - $t1 );

[00:44] <camelia> nqp-jvm: OUTPUT«No registered operation handler for 'time'␤  in compile_op (src/stage2/gen/QAST.nqp:230)␤  in as_jast (src/stage2/gen/QAST.nqp:3682)␤  in as_jast (src/stage2/gen/QAST.nqp:2954)␤  in  (src/stage2/gen/QAST.nqp:329)␤  in  (src/stage2/gen/QAST.nqp:326)␤  in  …»

[00:45] <Ben_Goldberg> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); my $t1 := npq::time; nqp::push( @arr,"hi" ); my $t2 := nqp::time; say( $t2 - $t1 );

[00:45] <camelia> nqp-jvm: OUTPUT«No registered operation handler for 'time'␤  in compile_op (src/stage2/gen/QAST.nqp:230)␤  in as_jast (src/stage2/gen/QAST.nqp:3682)␤  in as_jast (src/stage2/gen/QAST.nqp:2954)␤  in as_jast_clear_bindval (src/stage2/gen/QAST.nqp:3993)␤  in  (src/stage2/gen/…»

[00:45] <Ben_Goldberg> nqp: my @arr := nqp::split(' ', 'a b c'); my $t1 := npq::time; nqp::push( @arr,"hi" ); my $t2 := nqp::time; say( $t2 - $t1 );

[00:45] <camelia> nqp: OUTPUT«Error while compiling block : Error while compiling op bind (source text: ":="): Error while compiling op time (source text: "nqp::time"): No registered operation handler for 'time'␤current instr.: '' pc 55082 (src/stage2/QAST.pir:20123) (src/stage2/QAST.nqp:3316)␤»

[00:48] *** PacoAir left
[00:55] *** slavik joined
[00:58] *** btyler joined
[01:12] *** [particle]1 joined
[01:35] *** stevan_ joined
[01:35] *** benabik joined
[01:40] *** FROGGS_ joined
[01:42] <diakopter> Ben_Goldberg: it's nqp::time_n

[01:44] *** FROGGS left
[01:48] <[Coke]> some things in nqp return -1 on error; others throw exceptions.

[01:49] <[Coke]> isfilelink vs. mkdir, e.g.

[01:53] *** stevan_ left
[02:00] <[Coke]> die & die_s have the same sig on jvm. why 2 ops?

[02:04] <diakopter> what is the signature

[02:04] <diakopter> oh, it's just because of the type system 6model places on top of the jvm type system

[02:05] <diakopter> it's only half-integrated

[02:06] <[Coke]> there we go, now have tests failing for ops missing from both jvm & parrot. (why do we even have these ops if they're not being used in nqp or rakudo?)

[02:06] <diakopter> which ops

[02:06] <[Coke]> (e.g. list_b is missing from the jvm. list_n is missing from parrot)

[02:07] <diakopter> just haven't needed them yet I'm sure

[02:12] *** colomon joined
[02:21] <dalek> nqp: f9a5c28 | coke++ | docs/ops.markdown:

[02:21] <dalek> nqp: add moar ops. cleanup array params.

[02:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f9a5c28ef8

[02:21] <dalek> nqp: 959d4c6 | coke++ | docs/ops.markdown:

[02:21] <dalek> nqp: Add moar ops, cleanups.

[02:21] <dalek> nqp: 

[02:21] <dalek> nqp: Add new type _b found in a parrot opcode

[02:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/959d4c6a1b

[02:22] *** araujo left
[02:22] <JimmyZ> moar or more?

[02:23] <[Coke]> more

[02:23] <JimmyZ> :-)

[02:23] <[Coke]> I'll test the moar (and js) ops once they migrate to the nqp repo itself.

[02:23] <JimmyZ> he

[02:27] <[Coke]> updated https://gist.github.com/coke/6799633 with opcode todos.

[02:28] <[Coke]> feel free to comment with a blurb about an opcode, and I can use that to throw in the docs if you don't want to have to edit the markdown in the repo.

[02:28] <[Coke]> x_posixerrno seems to violate our no underscores rule.

[02:29] <[Coke]> as do associative_bind, _get, and a few others.

[02:30] *** bluescreen10 left
[02:31] <dalek> perl6-roast-data: ec9cefc | coke++ | / (3 files):

[02:31] <dalek> perl6-roast-data: today (automated commit)

[02:31] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ec9cefcf2f

[02:40] *** xenoterracide left
[02:40] *** xenoterracide joined
[02:40] *** colomon left
[02:42] * lue wonders if four VMs is enough or if we need MoarVMs

[02:43] <TimToady> well volunteered!

[02:45] *** xenoterracide left
[02:50] <flussence> .oO( I wonder how mortified the world would be if an nqp-zend appeared )

[02:50] <lue> TimToady: well, I still have a latent idea for LLNQP and llakudo that I may feel like tackling someday :)

[02:52] <TimToady> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); nqp::push(@arr,"hi"); say(@arr);  # just checking

[02:52] <camelia> nqp-jvm: OUTPUT«Cannot stringify this␤  in  (src/stage2/gen/NQPCORE.setting:672)␤  in print (src/stage2/gen/NQPCORE.setting:671)␤  in say (src/stage2/gen/NQPCORE.setting:678)␤  in  (/tmp/JBPrl6W6Sl:1)␤  in  (src/stage2/gen/NQPHLL.nqp:1091)␤  in eval (src/stage2/gen/NQPHL…»

[02:57] <TimToady> nqp-jvm: my @arr := nqp::split(' ', 'a b c'); nqp::push(@arr,"hi"); say($_) for @arr;  # just checking

[02:57] <camelia> nqp-jvm: OUTPUT«a␤b␤c␤hi␤»

[02:57] <TimToady> okay, so it's not a busted split

[03:23] *** aindilis left
[03:24] *** aindilis joined
[03:25] *** aindilis left
[03:25] *** aindilis joined
[03:28] *** japhb left
[03:33] *** japhb joined
[03:40] *** japhb__ left
[03:40] *** japhb left
[03:43] *** aindilis left
[03:43] *** aindilis joined
[03:46] *** logie left
[03:51] *** japhb joined
[03:54] *** japhb__ joined
[03:59] *** preflex_ joined
[03:59] *** ChanServ sets mode: +v preflex_

[04:01] *** preflex left
[04:01] *** preflex_ is now known as preflex

[04:16] <Timbus> lue, i support llakudo 110%

[04:18] <diakopter> lue: just remember, LLVM doesn't have a GC (though you can emit hooks for your own), or any native system, so you'd have to duplicate essentially all of MoarVM, except for the interpreter, which is actually quite a small part of the VM/runtime system

[04:18] <diakopter> *native object system

[04:18] *** btyler left
[04:19] *** ivanshmakov left
[04:19] <diakopter> so if you want an llnqp, I recommend starting with MoarVM, and simply emitting the bytecode segments to LLIR

[04:20] <diakopter> I say "simply," because it really would be staggeringly simple

[04:22] *** [particle]1 left
[04:22] <lue> diakopter: I'll look into that whenever I regain interest in this idea. Sounds like it'd save me a bunch of time :)

[04:22] <diakopter> jnthn doesn't want to include C++ code or huge dependencies in moarvm's repo, so probably you'd be building from a fork of moarvm, but if you can get it *stupendously awesome* I'm sure jnthn would be okay with adding the necessary hooks to moarvm to plugin such alternative invocation semantics

[04:23] *** [particle] joined
[04:25] *** ivanshmakov joined
[04:36] <JimmyZ> C  always got karma from C++ here

[04:36] *** kay joined
[04:36] *** kay is now known as Guest83275

[04:37] <lue> diakopter: I was assuming I'd be forking it for such a project anyway.

[04:39] * lue imagines the compiler stack now: Rakudo -> NQP -> MoarVM -> LLVM -> C backend generated code -> gcc -> binary executable :P

[04:44] <Timbus> i would honestly like that

[04:45] <Timbus> minus the C stage

[04:52] *** raiph left
[04:56] *** darutoko joined
[05:00] *** Ben_Goldberg left
[05:00] <lue> Timbus: obviously you can just use LLVM's existing stuff to create the binary, but I figured the C backend and gcc were a couple of extra steps I could throw in. Anything more would be pushing it :) .

[05:00] <lue> (unless the "to binary executable" bit is purely within clang's domain, in which case it gets trickier.)

[05:01] * lue should update his LLVM sometime.

[05:01] *** raiph joined
[05:04] *** ponpon left
[05:10] *** ponpon joined
[05:10] *** ponpon is now known as Guest96073

[05:16] *** raiph left
[05:27] *** jnap left
[05:38] <moritz> \o

[05:48] *** stephenwan left
[06:11] *** SamuraiJack__ joined
[06:15] *** SamuraiJack__ left
[06:42] *** kaare_ joined
[06:42] *** xenoterracide joined
[06:48] *** rs0 left
[06:48] *** araujo joined
[06:56] *** araujo left
[06:58] *** araujo joined
[06:59] *** patspam left
[06:59] *** patspam joined
[06:59] *** PZt left
[06:59] *** cotto left
[07:00] *** cotto joined
[07:20] *** SamuraiJack_ joined
[07:29] *** SamuraiJack__ joined
[07:31] *** SamuraiJack_ left
[07:32] *** xenoterracide left
[07:33] <FROGGS_> moarning

[07:34] *** FROGGS_ is now known as FROGGS

[07:41] * moritz yawns

[07:42] <FROGGS> yeah

[07:51] <masak> MOARNING, lambdaparrotbutterflycamels.

[07:51] <yoleaux> 00:03Z <[Coke]> masak: nqp: say(nqp::base_I(123456780,22)) -- SEGV

[07:51] <masak> nqp: say(nqp::base_I(123456780,22))

[07:51] <camelia> nqp: OUTPUT«(signal SEGV)»

[07:51] <masak> cool.

[07:52] * masak submits nqpissue

[07:56] *** xinming_ joined
[07:59] *** xinming left
[08:07] <masak> today's autopun: "There are two kinds of people in this world: those who can extrapolate from incomplete data."

[08:12] *** Rotwang joined
[08:21] <lizmat> o/

[08:25] <lizmat> did anyone notice that https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv is broken ?

[08:25] <lizmat> "Hey, did you know this file could be beautiful and searchable if this error is corrected? It looks like row 6 should actually have 11 columns, instead of 10."

[08:26] *** SamuraiJack__ left
[08:27] <masak> yeah.

[08:27] <masak> '2013-10-03-74.93%' should actually be '2013-10-03,74.93%'

[08:28] <masak> I don't know if it's just a matter of committing a patch that fixes that. probably is.

[08:33] <lizmat> .oO( the automated committer made a typo ;-)

[08:34] * lizmat assumes it will be fixed with the next automated run

[08:34] <masak> maybe those early bits were written by hand.

[08:34] <masak> and maybe the file is just being appended at the end. (I find that quite likely.)

[08:34] <masak> &

[08:54] *** denisboyun joined
[08:55] *** ksh joined
[08:57] *** GlitchMr left
[09:00] *** xinming_ left
[09:01] <dalek> rakudo/nom: 694286b | (Elizabeth Mattijsen)++ | src/core/set_operators.pm:

[09:01] <dalek> rakudo/nom: Rename variables to more reflect what they are (KeyBag -> BagHash leftover)

[09:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/694286b2c1

[09:02] *** GlitchMr joined
[09:06] *** SamuraiJack__ joined
[09:10] *** GlitchMr left
[09:12] *** xinming joined
[09:15] *** GlitchMr joined
[09:19] *** logie joined
[09:21] *** GlitchMr left
[09:27] *** GlitchMr joined
[09:32] *** GlitchMr left
[09:37] *** darutoko left
[09:37] *** GlitchMr joined
[09:37] *** GlitchMr left
[09:38] <dalek> rakudo/nom: 1edf477 | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[09:38] <dalek> rakudo/nom: Hide .new-fp method from .perl output for Baggys (and Mixys currently)

[09:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1edf4778b6

[09:38] <lizmat> .new-fp is really an internal method in my book

[09:38] <lizmat> and this is also shorter  :-)

[09:39] <jnthn> new functional programming?

[09:39] <lizmat> r. <a b b c c c>.Bag.perl.say # becomes "(a=>1,b=>2,c=>3).Bag"

[09:39] <lizmat> r: <a b b c c c>.Bag.perl.say # becomes "(a=>1,b=>2,c=>3).Bag"

[09:39] <camelia> rakudo 694286: OUTPUT«Bag.new-fp("a"=>1,"b"=>2,"c"=>3)␤»

[09:39] <lizmat> new from pairs

[09:42] *** GlitchMr joined
[09:44] *** daniel-s__ joined
[09:45] *** grondilu joined
[09:46] <lizmat> errands&

[09:47] *** daniel-s_ left
[09:49] *** rindolf joined
[09:50] *** rindolf left
[10:11] *** GlitchMr left
[10:14] *** pippo joined
[10:15] <pippo> r: my $m = mix <a foo a a a a b foo>; say $m.perl;

[10:15] <camelia> rakudo 694286: OUTPUT«Mix.new-fp("a"=>5,"foo"=>2,"b"=>1)␤»

[10:17] *** PacoAir joined
[10:17] *** GlitchMr joined
[10:18] *** pippo left
[10:20] *** moukeddar joined
[10:47] *** darutoko joined
[10:50] *** dmol1 joined
[10:50] *** dmol left
[11:02] *** logie left
[11:10] * grondilu thinks total should be cached for immutable objects

[11:11] * grondilu thinks of http://rosettacode.org/wiki/Entropy#Perl_6 and how it computes the total several times

[11:12] <grondilu> like:  class Bag { has $total; method total { $total //= [+] self.values } }

[11:12] <grondilu> I mean:  class Bag { has $.total; method total { $.total //= [+] self.values } }

[11:12] <grondilu> ahh

[11:12] <grondilu> class Bag { has $!total; method total { $!total //= [+] self.values } }

[11:14] *** Rotwang left
[11:17] *** rindolf joined
[11:18] *** moukeddar left
[11:22] <grondilu> also, why is there no more List.bag?

[11:22] <grondilu> r: say (my @ = ^10).bag

[11:22] <camelia> rakudo 1edf47: OUTPUT«No such method 'bag' for invocant of type 'Array'␤  in block  at /tmp/EZ6EGTQXo3:1␤␤»

[11:23] <grondilu> n: say (my @ = ^10).bag

[11:23] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: Unable to resolve method bag in type Array␤  at /tmp/xeGG19tUN3 line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4584 (module-CORE @ 576) …»

[11:24] *** rindolf left
[11:24] *** rindolf joined
[11:27] <grondilu> r: sub talk($msg) { say $msg };  "Hi".talk

[11:27] <camelia> rakudo 1edf47: OUTPUT«No such method 'talk' for invocant of type 'Str'␤  in block  at /tmp/kd5Ug5rnXR:1␤␤»

[11:27] <grondilu> r: sub talk($msg) { say $msg };  "Hi".&talk

[11:27] <camelia> rakudo 1edf47: OUTPUT«Hi␤»

[11:28] <grondilu> wasn't the translation to .& automatic before?

[11:30] <grondilu> (well, maybe not.  It would be kind of too much magic.  I must be imagining things)

[11:30] * grondilu needs to re-read S05

[11:32] <moritz> grondilu: back in the days there was some mishmash between subs and methods. That was resolved maybe 5 years ago

[11:33] *** colomon joined
[11:38] *** rindolf left
[11:38] *** rindolf joined
[11:48] *** rindolf left
[11:49] *** sqirrel joined
[12:03] *** GlitchMr left
[12:05] *** rindolf joined
[12:09] *** GlitchMr joined
[12:15] *** rindolf left
[12:15] *** rindolf joined
[12:24] *** GlitchMr left
[12:25] *** stevan_ joined
[12:28] *** GlitchMr joined
[12:31] *** rindolf left
[12:32] *** rindolf joined
[12:33] *** stevan_ left
[12:36] *** SamuraiJack__ left
[12:38] *** Lorn left
[12:39] *** sqirrel left
[12:39] *** sqirrel joined
[12:39] *** Lorn_ joined
[12:51] *** rindolf left
[12:51] *** rindolf joined
[13:11] *** rindolf left
[13:12] *** rindolf joined
[13:24] *** rindolf left
[13:25] *** rindolf joined
[13:26] *** raiph joined
[13:27] *** dalek left
[13:28] *** sqirrel left
[13:28] *** dalek joined
[13:28] *** ChanServ sets mode: +v dalek

[13:37] *** rindolf left
[13:37] *** rindolf joined
[13:44] *** sisar joined
[13:55] *** stevan_ joined
[13:56] *** _ilbot joined
[14:01] *** _daniel-s__ joined
[14:03] *** rindolf left
[14:04] *** rindolf joined
[14:04] *** daniel-s__ left
[14:05] *** PZt joined
[14:10] *** benabik left
[14:13] *** benabik joined
[14:19] *** rindolf left
[14:19] *** colomon left
[14:20] *** rindolf joined
[14:21] *** KroKite joined
[14:21] *** KroKite left
[14:21] *** KroKite joined
[14:27] *** PacoAir left
[14:33] *** rindolf left
[14:34] *** raiph left
[14:37] *** KroKite left
[14:42] <dalek> nqp: 23985aa | jnthn++ | src/NQP/ (2 files):

[14:42] <dalek> nqp: Add :moar options to QAST::VM nodes.

[14:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/23985aa3ab

[14:42] <diakopter> wat.

[14:43] <diakopter> the first MoarVM commit on #perl6 ?

[14:43] *** isBEKaml joined
[14:44] <jnthn> It has begun...

[14:44] <jnthn> And yeah, this is probably the first directly-for-moar commit in the NQP repo

[14:44] <jnthn> Everything else is going in a branch for now, though.

[14:45] *** bruges left
[14:45] <timotimo> very nice :)

[14:45] *** bruges joined
[14:46] <isBEKaml> nice! How's MoarVM coming along? :)

[14:46] <TimToady> it's moar better

[14:46] <diakopter> it has moar sauce

[14:46] <isBEKaml> OKMOARPLZ!

[14:46] <jnthn> isBEKaml: It can self-host NQP fairly well now, next step is getting it bootstrapped and moving the backend support into the NQP repo

[14:47] <TimToady> nqp-m: say("MOAR BOOTSTRAPZ!!")

[14:47] <camelia> nqp-moarvm: OUTPUT«MOAR BOOTSTRAPZ!!␤»

[14:49] <isBEKaml> jnthn: that's great! I vaguely recall one of the goals for MoarVM being portability - is that still the case?

[14:49] <isBEKaml> I remember talk of making it more easier to port perl6 to other VMs, MoarVM being a step in the way. 

[14:50] <isBEKaml> TimToady: I saw nqp-m, but never made the connect to MoarVM. SHDBEMOARACTV! :)

[14:51] *** rindolf joined
[14:52] <grondilu>  It seems to me than the main goal of MoarVM is performance.  Designing a VM finely tuned for perl6 is the strategy adopted with MoarVM.

[14:54] <isBEKaml> grondilu: ah, parrot's last hurrah - yes, that too. I know I should not say 'last' - but heck, it's the only VM that can support perl6. :)

[14:54] <jnthn> isBEKaml: I guess you missed Niecza, and Rakudo's JVM port? ;-)

[14:56] <isBEKaml> jnthn: No, I did not :) Niecza and Rakudo JVM were later players. I should have stated it better as early support. 

[14:57] <isBEKaml> jnthn: I was more thinking of Allison's parrot-devel mail. 

[14:59] <dalek> perl6-roast-data: 5656a3b | coke++ | perl6_pass_rates.csv:

[14:59] <dalek> perl6-roast-data: fix date fix

[14:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/5656a3bb02

[15:02] *** stevan_ left
[15:06] *** stevan_ joined
[15:07] *** arnsholt left
[15:07] *** xenoterracide joined
[15:08] <[Coke]> nqp: my @a:=nqp::split(' ','a b c d'); say(nqp::existspos(@a,2));

[15:08] <camelia> nqp: OUTPUT«exists_keyed() not implemented in class 'ResizableStringArray'␤current instr.: '' pc 53 ((file unknown):57574396) (/tmp/8eRMqSQNHK:1)␤»

[15:08] <[Coke]> nqp-jvm: my @a:=nqp::split(' ','a b c d'); say(nqp::existspos(@a,2));

[15:08] <camelia> nqp-jvm: OUTPUT«1␤»

[15:08] *** [Sno] left
[15:08] <[Coke]> is that a bug?

[15:09] <TimToady> looks kinda copy/pastey to me

[15:11] *** xenoterracide left
[15:15] *** rindolf left
[15:15] *** rindolf joined
[15:16] <JimmyZ> nqp-m: say(nqp::base_I(123456780,22))

[15:16] <camelia> nqp-moarvm: OUTPUT«This representation (P6int) cannot unbox to other types␤   at /tmp/COZcsz3rRr:2  (<ephemeral file>:frame_name_0:4294967295)␤ from nqp-src/NQPHLL.nqp:1084  (./NQPHLLMoar.moarvm:frame_name_671:97)␤ from nqp-src/NQPHLL.nqp:1070  (./NQPHLLMoar.moarvm:eval:87)␤…»

[15:17] <diakopter> moritz: how to get npq-m in #moarvm

[15:17] <diakopter> nah, nm, here is good. :)

[15:18] <[Coke]> nqp's splice doesn't insert new elements, just removes old ones, yes?

[15:19] <diakopter> should insert

[15:19] <diakopter> if it doesn't it's broken

[15:19] <dalek> nqp/moarboot: 7399e16 | jnthn++ | src/vm/moar/HLL/Backend.nqp:

[15:19] <dalek> nqp/moarboot: Add a HLL::Backend file for MoarVM.

[15:19] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/7399e16205

[15:19] <dalek> nqp/moarboot: 0eda38b | jnthn++ | src/NQP/Compiler.nqp:

[15:19] <dalek> nqp/moarboot: We'll likely need a --bootstrap for MoarVM too.

[15:19] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/0eda38baf5

[15:21] *** stevan_ left
[15:21] *** stevan_ joined
[15:22] *** xenoterracide joined
[15:23] <[Coke]> ah, the args are not in the fiveish order.

[15:25] *** arnsholt joined
[15:26] *** bruges left
[15:26] * felher really sees forward to a moar-vm powered rakudo.

[15:27] <felher> I hope it will be especially good in the startup-time department.

[15:27] *** bruges joined
[15:29] <diakopter> it was my understanding that rakudo-parrot's startup time was at least acceptable

[15:29] *** ksh left
[15:32] <felher> diakopter: at may be for most people, and it is for me for a lot of tasks. But I currently don't write my below 50 lines little tiny commandline scripts in Perl6, because it takes a few seconds to start them.

[15:32] <felher> It's like waiting a few seconds after every 'cd', 'll', or whatever command :)

[15:33] <felher> Little scripts that update my commandline-prompt are totaly out of reach. :)

[15:34] <felher> I'm not complaining, btw. I think that Perl6 is great and a lot of people have done some really great work. So thanks for that :)

[15:34] <diakopter> felher: okay; you're referring to compile time of the input

[15:36] <felher> diakopter: yeah, I have included that. But even if I compile most parts of the programm down to pir it has a long way to go until it can be used to update my prompt :)

[15:37] <felher> Currently I use perl for a lot of that stuff. :)

[15:38] <felher> (And ZSH-Shellscripts)

[15:40] *** denisboyun left
[15:42] *** rindolf left
[15:47] *** isBEKaml left
[15:52] *** moukeddar joined
[15:54] *** [Sno] joined
[16:00] *** zakharyas joined
[16:02] <[Coke]> jnthn: Can you describe what, say "nqp::bootint" does?

[16:03] <[Coke]> is it: return the type object for a native int?

[16:03] <jnthn> [Coke]: Returns a type object provide by the VM that knows how to box a native int.

[16:03] <[Coke]> Danke.

[16:05] <[Coke]> and bootnumarray is the same for an array of native ints?

[16:05] <[Coke]> er, nums

[16:07] *** kaare__ joined
[16:07] *** benabik left
[16:07] <[Coke]> or is it a native array of native ints?

[16:07] <[Coke]> :) 

[16:08] <FROGGS> since there is a bootintarray the num one must be about nums :o)

[16:09] <[Coke]> yes, I keep saying ints there when I mean nums.

[16:09] *** kaare_ left
[16:10] <FROGGS> dunno about the nativeness of the array though, I just can guess that it is about native arrays...

[16:10] <jnthn> [Coke]: Well, if it's storing native ints directly it's by definition a native array I guess ;)

[16:10] <jnthn> [Coke]: Unless we're using the word differently :)

[16:10] <jnthn> Anyway, the native is referring to the fact there's no boxing

[16:11] *** stevan_ left
[16:12] *** stevan_ joined
[16:13] *** xenoterracide left
[16:14] *** ssutch left
[16:15] *** ssutch joined
[16:21] <[Coke]> for the arrays/hashs, is it about boxing still? or are you just returning the type of a native array (that is potentially just for ints)

[16:24] <jnthn> The type object for a native array

[16:24] *** xenoterracide joined
[16:24] *** PacoAir joined
[16:24] *** rindolf joined
[16:30] *** stevan_ left
[16:31] *** KroKite joined
[16:36] *** fridim_ joined
[16:37] *** KroKite left
[16:38] <dalek> nqp/moarboot: f90f0ae | jnthn++ | src/vm/moar/ModuleLoader.nqp:

[16:38] <dalek> nqp/moarboot: Pull in a ModuleLoader from Moar's nqp-cc.

[16:38] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/f90f0aee88

[16:38] <dalek> nqp/moarboot: c47fee1 | jnthn++ | / (2 files):

[16:38] <dalek> nqp/moarboot: Stub ConfigureMoar.pl and Makefile-Moar.in.

[16:38] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/c47fee1e6e

[16:40] <arnsholt> Holy docs, Batman!

[16:41] <arnsholt> [Coke]++ # docs/ops.markdown

[16:42] *** rindolf left
[16:42] *** rindolf joined
[16:43] <[Coke]> arnsholt: got a bit queued up, still. :)

[16:45] <arnsholt> jnthn: Should base_I throw an exception on a non-SMO argument, or convert it to something it can handle?

[16:46] <jnthn> exception

[16:48] *** SamuraiJack__ joined
[16:48] <JimmyZ> nqp-m: say(nqp::base_I(123456780,22))

[16:48] <camelia> nqp-moarvm: OUTPUT«This representation (P6int) cannot unbox to other types␤   at /tmp/Wfb5Kx_zBK:2  (<ephemeral file>:frame_name_0:4294967295)␤ from nqp-src/NQPHLL.nqp:1084  (./NQPHLLMoar.moarvm:frame_name_671:97)␤ from nqp-src/NQPHLL.nqp:1070  (./NQPHLLMoar.moarvm:eval:87)␤…»

[16:48] <JimmyZ> like this?

[16:49] <jnthn> The error condition can't occur on MoarVM

[16:49] <jnthn> 'cus everything is a 6model object

[16:50] <JimmyZ> good night

[16:50] *** logie joined
[16:50] <jnthn> o/

[16:50] *** xenoterracide left
[16:53] <[Coke]> jnthn: your notes for the workshop have a page on Conditional opcodes - where are those defined in the jvm? they're not showing up on my list of missing opcodes.

[16:54] <[Coke]> (if, unless)

[16:55] <[Coke]> nevermind, found it. it's programmatic, not a literal.

[16:55] <jnthn> [Coke]: Maybe 'cus if and unless (also some looping ones) are added pro...yes. :)

[16:55] *** logie left
[17:01] *** xenoterracide joined
[17:05] <japhb__> OK, I think I've come up with a new personal definition of "production ready" -- when I don't have to spend time yak-shaving around bugs, and can just write synopses-compliant code and know it will Just Work.

[17:05] <japhb__> *grumble*

[17:05] <timotimo> mind sharing with us?

[17:06] <japhb__> Type constraint issues.

[17:06] <timotimo> :(

[17:06] <japhb__> (That's today's annoyance, at least)

[17:06] *** xenoterracide left
[17:06] <timotimo> at the moment, type constraints almost make your code slower, because it spends so much time checking things over and over again, even if it could prove it doesn't need a typecheck

[17:07] <timotimo> but it does seem like typechecks are very cheap

[17:07] <jnthn> They're cheap

[17:07] <jnthn> For the common cases, anyway

[17:07] <jnthn> (a class, a role, etc.)

[17:07] <[Coke]> weird. the ice cream truck just drove by.

[17:07] <jnthn> For subset types it depends what you do int he subset

[17:07] <timotimo> of course

[17:07] <timotimo> and if we have subset types, we may not even be allowed to skip testing

[17:07] <jnthn> native types lead to better code-gen so are a win, also

[17:08] <japhb__> In this particular code, I think the original author would happily take a little performance loss, and wants the handcuffs.

[17:08] <timotimo> i understand that sentiment.

[17:09] <jnthn> japhb__: So what is the issue, ooc?

[17:09] <japhb__> sub test(Int $a, Str :$b!, Int :@c) { .WHAT.say for $a, $b, @c }; test(1, :b("bar"), :c(["foo"]))

[17:09] <japhb__> r: sub test(Int $a, Str :$b!, Int :@c) { .WHAT.say for $a, $b, @c }; test(1, :b("bar"), :c(["foo"]))

[17:09] <camelia> rakudo 1edf47: OUTPUT«Nominal type check failed for parameter '@c'; expected Positional but got Array instead␤  in sub test at /tmp/RiNVs6amZd:1␤  in block  at /tmp/RiNVs6amZd:1␤␤»

[17:09] <timotimo> ah, of course

[17:10] *** stevan_ joined
[17:10] <timotimo> there's a problem with type-constraining arrays for parameters like that

[17:10] <timotimo> it won't work with lazyness etc, because in that case it would have to reify the whole array before calling

[17:10] <japhb__> (Obviously, that's a snapshot from me being midway through nailing down the borders of the problem.)

[17:10] <timotimo> you'll have to pass it already-typed

[17:10] <timotimo> like this:

[17:11] *** stevan_ left
[17:11] <timotimo> r: sub test(Int :@c) { say @c.WHAT }; test(:c(my Int @a = 1, 2, 3))

[17:11] <camelia> rakudo 1edf47: OUTPUT«(Array[Int])␤»

[17:11] <timotimo> it will not infer "this array is full of ints, therefor it must be an Array[Int]!"

[17:12] *** moukeddar left
[17:12] <timotimo> japhb__: does that help at all?

[17:13] <jnthn> Array[Int].new(1,2,3) # should also work

[17:13] <japhb__> timotimo: I think I would have been OK with "Cannot infer type of untyped array" or "expected Positional[Int] but got Array instead", but the error message as written is incorrect.

[17:13] <jnthn> yes, the error reporting is unhelpful

[17:13] <timotimo> yes, it really should tell you the type constraint there

[17:13] <timotimo> not sure where to even start for a fix :(

[17:13] <jnthn> r: say Positional[Int]

[17:13] <camelia> rakudo 1edf47: OUTPUT«(Positional)␤»

[17:14] <jnthn> I think that golfs the issue

[17:14] <timotimo> r: given Positional[Int] { say .perl; say .Str; say .gist }

[17:14] <camelia> rakudo 1edf47: OUTPUT«Positional␤use of uninitialized value of type Positional in string context  in any  at src/gen/Metamodel.nqp:1469␤␤␤(Positional)␤»

[17:14] <timotimo> so the .perl of Positional should grow a bit of code to output its type, eh?

[17:14] <timotimo> i can try that

[17:15] <jnthn> no, it's the method name in CurriedRoleHOW I think

[17:15] *** rindolf left
[17:15] <timotimo> ... oh

[17:15] *** rindolf joined
[17:17] <timotimo> i'm not sure i follow; it seems to defer its work to the "actual HOW of the thing", so is that a ConcreteRoleHOW?

[17:17] <japhb__> r: sub test(Int :@c) { say @c.WHAT }; test(:c(my Int @ = 1, 2, 3))  # Can the array be anon?

[17:17] <camelia> rakudo 1edf47: OUTPUT«(Array[Int])␤»

[17:17] *** xenoterracide joined
[17:17] <timotimo> yes, it can

[17:18] <timotimo> jnthn: would i have to add output for @!pos_args and %!named_args into the method name of CurriedRoleHOW?

[17:20] <dalek> nqp: 28bf31b | coke++ | t/docs/opcodes.t:

[17:20] <dalek> nqp: Manually add these opcodes to the test

[17:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/28bf31b881

[17:20] <dalek> nqp: bea2f3b | coke++ | docs/ops.markdown:

[17:20] <dalek> nqp: Add many more docs.

[17:20] <dalek> nqp: 

[17:20] <dalek> nqp: jnthn++ for some clarifications.

[17:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bea2f3b2c2

[17:21] * timotimo is not sure how nameds work in CurriedRoleHOW

[17:23] <jnthn> timotimo: Well, or just take the @pos_args in the new_type method and construct the name at that point.

[17:23] <jnthn> timotimo: Can ignore nameds for now

[17:24] <timotimo> i've got some code ready now.

[17:27] <timotimo> doing a quick commute first, though

[17:30] <japhb__> r: Array[Int].new(1, 2, "three")

[17:30] <camelia> rakudo 1edf47: ( no output )

[17:30] <japhb__> r: my Int @ = 1, 2, "three";

[17:30] <camelia> rakudo 1edf47: OUTPUT«Type check failed in assignment to '@'; expected 'Int' but got 'Str'␤current instr.: 'throw' pc 401346 (src/gen/CORE.setting.pir:168706) (src/gen/CORE.setting:10470)␤called from Sub '' pc 138241 (src/gen/CORE.setting.pir:58818) (src/gen/CORE.setting:11793)…»

[17:30] <japhb__> OK, so that's the checked route

[17:31] * jnthn is kinda bothered the other way isn't...

[17:31] <jnthn> r: say Array[Int].new(1, 2, "three")

[17:31] <camelia> rakudo 1edf47: OUTPUT«1 2 three␤»

[17:31] <jnthn> bug

[17:31] <japhb__> Ditto, but trying desperately to avoid further yak shaving right now.  :-/

[17:31] <lizmat> grondilu: you're confusing bag() object creator function, with the .Bag coercion method

[17:32] <dalek> nqp: 2699523 | coke++ | docs/ops.markdown:

[17:32] <dalek> nqp: Add more control/loop opcodes

[17:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/26995239eb

[17:32] <lizmat> r: <a b b c c c>.Bag.perl.say

[17:32] <[Coke]> lizmat: fixed the cvs bug, thanks.

[17:32] <camelia> rakudo 1edf47: OUTPUT«("a"=>1,"b"=>2,"c"=>3).Bag␤»

[17:32] <jnthn> lizmat: The above Array[Int].new bug may be one you know how to fix... :)

[17:32] <lizmat> sorry, must have missed that while backlogging: what is the problem again?

[17:32] *** slavik left
[17:32] <jnthn> r: say Array[Int].new(1, 2, "three")

[17:33] <camelia> rakudo 1edf47: OUTPUT«1 2 three␤»

[17:33] <jnthn> lizmat: That "three" arg 

[17:33] <lizmat> r> say Array[Int].new(1, 2, "three").perl

[17:33] <lizmat> r: say Array[Int].new(1, 2, "three").perl

[17:33] <camelia> rakudo 1edf47: OUTPUT«Array[Int].new(1, 2, "three")␤»

[17:33] <lizmat> since when is a gist supposed to be producing valid perl code ?

[17:34] <[Coke]> anyone want to write up "handle" opcode? it's going to be the one opcode missing from the workshop op notes, i think.

[17:34] <jnthn> [Coke]: Is there not some text from the workshop op notes that explains it? :)

[17:34] <japhb__> lizmat: the problem is that "three" should be failing the type check

[17:34] <lizmat> r: <a b b c c c>.Bag.gist.say

[17:34] <jnthn> But anyway, something like...

[17:34] <camelia> rakudo 1edf47: OUTPUT«bag(a, b(2), c(3))␤»

[17:35] <lizmat> ah, ok,

[17:35] <lizmat> it's not the gist output you're worried about  :-)

[17:35] <japhb__> right.  :-)

[17:35] <Ulti> r: <a b b c c c>.Bag.perl.say

[17:35] <camelia> rakudo 1edf47: OUTPUT«("a"=>1,"b"=>2,"c"=>3).Bag␤»

[17:35] <jnthn> The first child of 'handle' is the code to protect with an exception handler. Remaining children come in pairs, the first naming the type of exception to handle and the second being a QAST node specifiying the handler. Valid names include CATCH, CONTROL, LAST, NEXT and REDO.

[17:36] <grondilu> lizmat: oh I can use .Bag ?  Didn't know.  That will do.

[17:37] <jnthn> dinner &

[17:37] <TimToady> grondilu: why are you avoiding .total?

[17:38] <grondilu> TimToady: because it's not cache.  But really I first meant that I should not redeclare it. 

[17:38] <grondilu> *cached

[17:39] <TimToady> that's up to the implementation whether it caches it, but using [+] yourself is sort of guaranteed pessimization, so I don't see the point

[17:39] <grondilu> and also because it has been recently been added, so not sure it's here to stay.

[17:39] <TimToady> well, that's why it's a wiki :)

[17:40] <[Coke]> jnthn: I mean, "missing from my conversion of the workshop notes to the docs", sloppy englishing.

[17:40] <grondilu> so you think I should put .total back?

[17:40] <[Coke]> why are 'ctx' and 'curlexpad' the same thing on the jvm?

[17:41] <[Coke]> (in nqp)

[17:42] <grondilu> r: say <1 2 2>.Bag.Int

[17:42] <camelia> rakudo 1edf47: OUTPUT«No such method 'Int' for invocant of type 'Bag'␤  in block  at /tmp/WBYo8KhadA:1␤␤»

[17:42] <dalek> rakudo/nom: ae27d10 | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[17:42] <dalek> rakudo/nom: Make Set|Bag|Mix.total caching, as suggested by grondilu++

[17:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ae27d10ad0

[17:42] * grondilu wonders if Bag could not cast to Int with the total of its values

[17:43] <lizmat> r: say +(<1 2 2>.Bag)

[17:43] <camelia> rakudo 1edf47: OUTPUT«3␤»

[17:43] *** ajr joined
[17:43] <lizmat> r: say <1 2 2>.Bag.Num

[17:43] <camelia> rakudo 1edf47: OUTPUT«No such method 'Num' for invocant of type 'Bag'␤  in block  at /tmp/6zO1ltZFUh:1␤␤»

[17:43] <timotimo> japhb__: i will have a fix for the lta error for the array thing in at most an hour :)

[17:43] <lizmat> hmmm….  odd

[17:43] *** ajr is now known as Guest67756

[17:43] *** Guest67756 is now known as ajr_

[17:43] <lue> hello world o/

[17:44] <lizmat> r: say <1 2 2>.Bag.Numeric

[17:44] <camelia> rakudo 1edf47: OUTPUT«3␤»

[17:44] <timotimo> maybe today i will also look at giving p6bench a setup for the crosscompiled mvmnqp

[17:45] <timotimo> though if that goes into the main nqp repo soon, i should wait.

[17:46] <grondilu> maybe +Bag should answer the question "How many things are there in the bag?"   Though I'm not sure if this means "How many kinds of things are there in the bag?" or "How many things are there in total in the bag?" 

[17:48] <timotimo> if it is hard to figure it which one it should be maybe we should do it like strings and give two specific methods

[17:48] <timotimo> as in we don't have strlen

[17:48] *** denisboyun joined
[17:49] <grondilu> though I tend to think +@a and +@a.Bag should return the same result

[17:49] <grondilu> you dont lose stuff when putting them in a bag :)

[17:50] <dalek> nqp: 928285d | coke++ | docs/ops.markdown:

[17:50] <dalek> nqp: doc Context opcodes

[17:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/928285d1c2

[17:50] <TimToady> well, that means returning .total

[17:50] <grondilu> indeed, that would have my preference

[17:50] <TimToady> r: my @a = <a a b>; say +@a; say +@a.Bag; say @a.Bag.total

[17:50] <camelia> rakudo 1edf47: OUTPUT«3␤3␤3␤»

[17:51] <TimToady> looks kinda like it is already doing that, but maybe by accident

[17:51] * grondilu is confused

[17:51] <TimToady> r: my @a = <a a b>; say +@a; say @a.Bag.perl

[17:51] <grondilu> oh yeah, I misinterpreted r: say <1 2 2>.Bag.Num earlier

[17:51] <camelia> rakudo 1edf47: OUTPUT«3␤("a"=>2,"b"=>1).Bag␤»

[17:52] <japhb__> timotimo: Excellent re: LTA fix.  As for perl6-bench, just throw me a pull request if you decide to do it; otherwise I was going to wait for the merge into the NQP repo.

[17:52] <grondilu> r: my @a = (^10).roll(20); say +@a, +@a.Bag

[17:52] <camelia> rakudo 1edf47: OUTPUT«2020␤»

[17:53] <grondilu> r: my @a = (^2).roll(100); say +@a.Bag

[17:53] <camelia> rakudo 1edf47: OUTPUT«100␤»

[17:53] <TimToady> my @a = :a(3), :b(0.14159625); say +@a.Mix

[17:53] <TimToady> r: my @a = :a(3), :b(0.14159625); say +@a.Mix

[17:53] <camelia> rakudo 1edf47: OUTPUT«3.1415963␤»

[17:53] <TimToady> \o/

[17:53] <grondilu> ok so that's fine

[17:53] <TimToady> .oO(Add supporting detail)

[17:54] *** rindolf left
[17:54] *** rindolf joined
[17:56] <sisar> r: for (1,2,3).Parcel { $_.WHAT.say; } # Why is the output not just a single "(Parcel)" ?

[17:56] <camelia> rakudo 1edf47: OUTPUT«(Int)␤(Int)␤(Int)␤»

[17:57] <lizmat> r: for ((1,2,3).Parcel) { $_.WHAT.say; }

[17:57] <camelia> rakudo 1edf47: OUTPUT«(Int)␤(Int)␤(Int)␤»

[17:57] <lizmat> hmmmm

[17:58] <lizmat> r: for (1,2,3).item { $_.WHAT.say; }

[17:58] <camelia> rakudo 1edf47: OUTPUT«(Parcel)␤»

[17:58] <lizmat> r: (1,2,3).WHAT.say

[17:58] <camelia> rakudo 1edf47: OUTPUT«(Parcel)␤»

[17:58] <timotimo> Nominal type check failed for parameter '@a'; expected Positional,[,Int,[ but got Parcel instead  <- not quite m)

[17:58] <lizmat> (1,2,3) is already a Parcel, which apparently for {} is flattening ?

[17:59] <TimToady> yes, parens flatten in list context

[18:00] <sisar> lizmat: What does .item do ? And shouldn't an explicit .Parcel force it to pass a Parcel ?

[18:00] <timotimo> i'll try to fix the Array[Int].new typecheck thing, too, if you don't mind

[18:02] <jnthn> [Coke]: There's no separate context and lexpad objects on the JVM impl, or Moar. On Parrot there are.

[18:02] <lizmat> timotimo: please do  :-)

[18:04] *** benabik joined
[18:04] <TimToady> r: my $m = Mix(:a(1.5), :b(-1.5)); say $m.elems; say $m.total; say +$m; say ?$m

[18:04] <camelia> rakudo 1edf47: OUTPUT«0␤0␤0␤False␤»

[18:04] * TimToady wonders whether a balanced mix should suddenly turn False like that

[18:05] <TimToady> I suppose it's useful as is, and you can always do .elems to get the the other

[18:06] *** stevan_ joined
[18:06] *** zakharyas left
[18:06] <grondilu> rn: say <foo bar bar>.Bag.elems  

[18:06] <camelia> rakudo 1edf47: OUTPUT«2␤»

[18:06] <camelia> ..niecza v24-98-g473bd20: OUTPUT«3␤»

[18:06] <grondilu> ahah

[18:07] <TimToady> r: my $budget = Mix(:credits(1.5), :debits(-1.5)); sub balanced($m) { not $m }; say balanced $budget

[18:07] <camelia> rakudo 1edf47: OUTPUT«True␤»

[18:07] <grondilu> here I could have expected 2

[18:07] <TimToady> that's probably the old autoflatten in list semantics

[18:08] <TimToady> so .elems implies .flat.elems

[18:08] *** rindolf left
[18:09] <lizmat> yup, elems is just that

[18:09] <TimToady> but bags don't flatten anymore

[18:09] <lizmat> because for Mixes, elems would otherwise become a non-Int value

[18:09] *** rindolf joined
[18:10] <TimToady> part of the reason for switching to .total is so that .elems could go back to integral

[18:10] <TimToady> so niecza++ is just a little behind the times there

[18:12] <TimToady> r: my $m = Mix(:a(1.5), :b(-1.5)); say $m.elems;  # shouldnt' this say 2?

[18:12] <camelia> rakudo 1edf47: OUTPUT«0␤»

[18:12] <lizmat> TimToady: checking why that happens

[18:13] <TimToady> and if we fix that, do we break ?$m

[18:13] <TimToady> well, arguably ?$m could be based on either elems or total

[18:15] <FROGGS> +1 for elems

[18:15] *** rindolf left
[18:15] <lizmat> hmmm… there is no "sub Mix" in the core

[18:15] <lizmat> how could that work?

[18:15] <TimToady> is it more useful for the Mix to go false when the last entry autodeletes, or when the Mix gets into balance?

[18:15] <TimToady> it's a type, so gets a coercion

[18:15] <lizmat> r: my $m = (:a(1.5), :b(-1.5)).Mix; say $m.elems

[18:15] <camelia> rakudo 1edf47: OUTPUT«2␤»

[18:15] <TimToady> arguable the elems-based approach is more intuitive

[18:15] <lizmat> the Mix() creates an empty Mix (silently)

[18:17] <TimToady> very interesting, but shtupid

[18:17] <lizmat> hmmm… intriguing

[18:17] <lizmat> so, Mix() is short for Mix.new() somehow ?

[18:17] <TimToady> maybe it thinks they're named args?

[18:18] <TimToady> r: my $m = Mix((:a(1.5), :b(-1.5))); say $m.elems;

[18:18] <camelia> rakudo ae27d1: OUTPUT«2␤»

[18:18] <lizmat> yup, that's it

[18:18] <TimToady> yeah

[18:18] * TimToady is not sure coercions should take named args

[18:18] <lizmat> .oO( good to see TimToady bitten by that one )

[18:19] * TimToady thinks coercions should just take a parcel, not a capture

[18:19] <lizmat> a few months back I was suggesting a lexical pragma for complaining about superfluous named parameters to .new

[18:19] <TimToady> we've been thinking about that in general for all methods, but it's a lot of overhead to track in the general case

[18:20] <TimToady> unless a capture provides a way to mark each arg as it's used

[18:20] <TimToady> you can't just delete them as you bind them, because some args want to bind multiple times

[18:22] <TimToady> I can assure you the topic has been on our minds for about ten years already :)

[18:22] *** stevan_ left
[18:22] <moritz> and I kinda fear that lexical scoping will interact weirdly with methods, because method lookup isn't lexical

[18:22] <dalek> rakudo/nom: 9f94b8c | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[18:22] <dalek> rakudo/nom: Make sure Int/Num/Numeric/Real work on QuantHashes

[18:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9f94b8c60a

[18:22] <TimToady> but arguments don't come with last access dates :)

[18:23] <dalek> evalbot/host07: 2105dc2 | moritz++ | freenode.org.conf:

[18:23] <dalek> evalbot/host07: send camelia to #moarvm

[18:23] <dalek> evalbot/host07: review: https://github.com/perl6/evalbot/commit/2105dc2796

[18:23] <TimToady> we can do some analysis on finalized classes to say "no method binds an argument of this name"

[18:24] <TimToady> that would catch some typos and accidental named args

[18:24] *** camelia left
[18:24] *** camelia joined
[18:24] <TimToady> but obviously Mix() is being treated with method semantics on some level to ignore :a(),:b()

[18:25] *** ChanServ sets mode: +v camelia

[18:30] <timotimo> r: my @a := 0, 1 ... *; @a[20]:delete; say @a[20];

[18:30] <camelia> rakudo ae27d1: OUTPUT«Invocant requires a type object, but an object instance was passed␤  in method delete_pos at src/gen/CORE.setting:1430␤  in block  at src/gen/CORE.setting:1818␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2269␤  in sub postcircumfix:<[ ]> at src…»

[18:31] <timotimo> what am i doing wrong?

[18:31] <lizmat> feels like a rakudobug to me

[18:32] *** stevan_ joined
[18:32] * arnsholt is really happy he learnt how to force ssh to disconnect

[18:32] <moritz> note that @a isn't an Array

[18:33] <moritz> and hence might not support :delete

[18:33] <moritz> may it's just an LTA error

[18:33] <moritz> afk

[18:33] <jnthn> No, deleting from a sequence doesn't make much sense.

[18:34] <arnsholt> masak: Incidentally "Can SEGV the thing [...]" is quite possibly the bestest subject ever =D

[18:35] <jnthn> hah

[18:36] <lizmat> ok, I guess I have a learning moment: Foo(bar) is the same as (bar).Foo ?

[18:36] <lizmat> assuming Any.Foo exists ?

[18:36] <lizmat> is that right ?

[18:36] <jnthn> lizmat: Yeah

[18:36] <lizmat> some indirect object syntax or something ?

[18:37] <jnthn> lizmat: I think the thingy that handles it lives in BOOTSTRAP.nqp

[18:37] <jnthn> lizmat: No, just invocation on a type object iirc

[18:38] <lizmat> aha, so there must be a class Foo in that case as well

[18:38] <lizmat> r: method Foo ( say "Foo" }; Foo(1)

[18:38] <camelia> rakudo ae27d1: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/9YXiOFo8qO␤Invalid typename 'say' in parameter declaration.␤at /tmp/9YXiOFo8qO:1␤------> [32mmethod Foo ( say[33m⏏[31m "Foo" }; Foo(1)[0m␤»

[18:38] <lizmat> r: method Foo { say "Foo" }; Foo(1)

[18:38] <camelia> rakudo ae27d1: OUTPUT«Useless declaration of a has-scoped method in mainline␤[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Ao45Vp_5X4␤Undeclared name:␤    Foo used at line 1␤␤»

[18:39] <jnthn> s/method/class ? :)

[18:39] <timotimo> r: my @a := gather { say "hi"; take 1; say "blubb"; take 2; say "trololo"; take 4; }; map { .say; say "--"; }, @a;

[18:39] <camelia> rakudo ae27d1: OUTPUT«hi␤blubb␤trololo␤1␤--␤2␤--␤4␤--␤»

[18:39] <lizmat> r: class Foo { say "Foo" }; Foo(1)

[18:39] <camelia> rakudo ae27d1: OUTPUT«Foo␤No such method 'Foo' for invocant of type 'Int'␤  in block  at /tmp/yoKwC70aBo:1␤␤»

[18:39] <timotimo> shouldn't this interleave hi, blubb and trololo between --'s?

[18:39] <timotimo> i thought map was supposed to be lazy?

[18:40] *** denisboyun left
[18:40] <lizmat> r: sub Foo { say "sub Foo" }; class Foo { say "Foo" }; Foo(1)

[18:40] <camelia> rakudo ae27d1: OUTPUT«Foo␤No such method 'Foo' for invocant of type 'Int'␤  in block  at /tmp/daF2nCZfG4:1␤␤»

[18:41] <lizmat> hmmm....

[18:43] <timotimo> r: my &b = (* + *); say b(1, 2);

[18:43] <camelia> rakudo ae27d1: OUTPUT«3␤»

[18:43] <timotimo> r: my &b = (* + *); say b(1);

[18:43] <camelia> rakudo ae27d1: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at /tmp/0r1B1g3zXN:1␤␤»

[18:43] <timotimo> r: my &b = (* + *); say &b(1);

[18:43] <camelia> rakudo ae27d1: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block  at /tmp/Rg8sSeyOYR:1␤␤»

[18:43] <timotimo> in the repl this is b0rked

[18:44] <jnthn> ?

[18:44] <lue> jnthn: any quick reason [i.e. without gisting any code :)] why my PHPish REPL can't echo variables, but using -e can? Just normal REPL weirdness?

[18:45] <dalek> nqp: 7d58a1e | (Arne Skjærholt)++ | src/vm/parrot/ops/nqp_bigint.ops:

[18:45] <dalek> nqp: Throw exception in bigint ops if we get passed something that isn't an SMO.

[18:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7d58a1e38b

[18:46] <lizmat> timotimo: re @a[20], the @a is a List, not an Array

[18:46] <lizmat> r: my @a := 0, 1 ... *; say @a.WHAT 

[18:46] <camelia> rakudo ae27d1: OUTPUT«(List)␤»

[18:46] <jnthn> lue: Does it make a difference if the echo is on the same line or a different line?

[18:46] <lizmat> I guess a proper "List.delete_pos" that will create a better error message, would be in order

[18:47] <jnthn> lizmat: Well, or just make the one in Any better :)

[18:47] <lizmat> ah, good point

[18:48] <lue> jnthn: hey, whaddya know, I should be more thorough in my testing :) . So it's just a result of me not doing the extra work to persist between REPL lines, ja?

[18:50] <jnthn> lue: Yeah, but I don't think it's terribly much work to make it happen

[18:50] <jnthn> lue: I think it's just calling a couple of different methods inherited from HLL::Actions and inserting the QAST they return into the right places

[18:52] <lue> I don't need it though, so don't feel obligated to write up a how-to on the matter at the moment :) . I just need to remember that the REPL is not always the most trustworthy execution method.

[18:56] *** darutoko left
[18:56] *** sisar left
[18:56] <lizmat> $ perl6 -e 'my @a := 0, 1 ... *; @a[20]:delete'

[18:56] <lizmat> Can not remove elements from a List

[18:57] <lizmat> timotimo: that better ?

[18:57] <GlitchMr> rn: (invert bag 1, 2, 3, 2, 1).perl.say

[18:57] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: Unable to resolve method invert in type Bag␤  at /home/p6eval/niecza/lib/CORE.setting line 2644 (invert @ 4) ␤  at /tmp/iqL7y9i_PF line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ␤  at …»

[18:57] <camelia> ..rakudo ae27d1: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/cLDL7snpZ1␤Undeclared routine:␤    invert used at line 1␤␤»

[18:57] <GlitchMr> rn: (bag(1, 2, 3, 2, 1)).invert.perl.say

[18:57] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: Unable to resolve method invert in type Bag␤  at /tmp/FWjFeVVPSD line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4584 (module-CORE @ 576) …»

[18:57] <camelia> ..rakudo ae27d1: OUTPUT«(2 => 1, 2 => 2, 1 => 3).list␤»

[18:59] <lizmat> r: (1=>2,2=>2,3=>1).hash.invert.perl.say   # not different from inverting a hash

[18:59] <camelia> rakudo ae27d1: OUTPUT«(2 => "1", 2 => "2", 1 => "3").list␤»

[19:01] <lizmat> S32/Containers:978 Produces a backmapping of values to keys, expanding list values into multiple pairs.

[19:05] <timotimo> where can i find masak's slides on the perl6 regexes?

[19:05] *** btyler joined
[19:10] <dalek> rakudo/nom: 11bada4 | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[19:10] <dalek> rakudo/nom: Make :delete give a better error message if not supported on the object

[19:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/11bada4fe1

[19:14] <arnsholt> jnthn: Any objections to closing NQP #7? PAST is a bit irrelevant these days, now that we have QAST

[19:22] <moritz> http://www.gnuplotting.org/klein-bottle/ # I want a Klein bottle 3D printed with Perl 6!

[19:23] *** logie joined
[19:23] *** stevan_ left
[19:25] <TimToady> http://www.bathsheba.com/math/klein/

[19:28] <TimToady> that's a 3D printed klein bottle (opener), but not with Perl 6, I don't think, but maybe I can ask her at the next Hackers Conference...

[19:29] * moritz adds it to his ever-growing wishlist

[19:29] * TimToady got one for his mathematician/physicist son a couple years ago for Christmans

[19:30] <TimToady> *mas

[19:31] <arnsholt> moritz: Ooooh, gnuplotting is very relevant to some of my $dayjobby things. Cheers!

[19:33] <moritz> :-)

[19:34] *** SamuraiJack__ left
[19:45] *** stevan_ joined
[19:47] *** japhb_ left
[19:48] *** logie left
[19:49] <lizmat> jnthn: still trying to grok the code path that "Mix(:a(5)).perl.say" takes

[19:49] <lizmat> afaics, it is *not* calling .new on the type object

[19:49] <jnthn> lizmat: No

[19:50] <moritz> it calls postcircumfix:<( )> on the type object

[19:50] <jnthn> lizmat: It's what I said, it invokes the type object, which is handled by some code in BOOTSTRAP.nqp that turns it into a .Mix method call on the thing inside 

[19:50] <moritz> aka invocation

[19:50] <lizmat> aha, ok

[19:50] <moritz> ignore me, listen to jnthn++ :-)

[19:50] <lizmat> ok, I see it now

[19:50] <jnthn> Well, moritz++ did give the method name to look for in BOOTSTRAP :)

[19:51] <jnthn> I think thre's some logic in one of the action methods that makes this happen too

[19:51] <jnthn> If it spots it's a type name

[19:54] *** atta_ is now known as atta

[19:54] <timotimo> https://github.com/rakudo/rakudo/pull/214 - finally finalised that pull request

[19:57] <dalek> rakudo/nom: 4f828fc | (Timo Paulssen)++ | src/Perl6/Metamodel/CurriedRoleHOW.nqp:

[19:57] <dalek> rakudo/nom: for parametric roles, output the parameters, too

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f828fc887

[19:57] <dalek> rakudo/nom: 0f0eba1 | lizmat++ | src/Perl6/Metamodel/CurriedRoleHOW.nqp:

[19:57] <dalek> rakudo/nom: Merge pull request #214 from timo/parameter_output_for_roles

[19:57] <dalek> rakudo/nom: 

[19:57] <dalek> rakudo/nom: for parametric roles, output the parameters, too

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f0eba171a

[19:59] *** japhb_ joined
[20:01] <arnsholt> jnthn: NQP has a multi-dispatch cache these days, no?

[20:01] <jnthn> yeah

[20:02] <jnthn> arnsholt++ # ticket cleanup

[20:03] <arnsholt> 15 more and we're down to a single page =)

[20:03] <timotimo> \o/

[20:05] *** colomon joined
[20:05] *** colomon left
[20:05] <arnsholt> jnthn: Oldest I've seen so far still relevant is #15

[20:05] *** hummeleB1 joined
[20:06] <arnsholt> nqp: sub foo() { my $old := $*VAR; my $*VAR := "new"; say($old); } my $*VAR := "old"; say("pre"); foo(); say("post"); # NQP #15

[20:06] <camelia> nqp: OUTPUT«Confused at line 2, near "sub foo() "␤current instr.: 'panic' pc 14748 (src/stage2/gen/NQPHLL.pir:5229) (src/stage2/gen/NQPHLL.nqp:279)␤»

[20:06] <jnthn> May be worth doing that

[20:06] <arnsholt> nqp: sub foo() { my $old := $*VAR; my $*VAR := "new"; say($old); }; my $*VAR := "old"; say("pre"); foo(); say("post"); # NQP #15

[20:06] <camelia> nqp: OUTPUT«pre␤␤post␤»

[20:06] <arnsholt> Presumably since all variable declarations happen first in a block

[20:07] <jnthn> yeah

[20:08] <arnsholt> Also, are submethods on the map for NQP?

[20:08] <arnsholt> If they're not, we can close #3 too

[20:09] <japhb__> ssutch: ping

[20:09] <jnthn> Hadn't planned on submethods unless somebody has a good reason to add them...

[20:12] * timotimo is now building typechecks for List.new

[20:13] <arnsholt> Right, I'll close #3 for now then

[20:19] *** kaare__ left
[20:19] <timotimo> r: Array[Int].new(1, 2, "foo");

[20:19] <camelia> rakudo 0f0eba: ( no output )

[20:19] <timotimo> r: List[Int].new(1, 2, "foo");

[20:19] <camelia> rakudo 0f0eba: OUTPUT«===SORRY!===␤Type List cannot accept type arguments␤»

[20:19] <timotimo> er ... huh?

[20:24] <jnthn> It's Array that is parametric, not List

[20:25] <timotimo> righto

[20:25] <jnthn> (for the time being, at least...)

[20:25] <timotimo> so, don't need that for List, yes?

[20:25] <timotimo> anyway, i moved the code to Array instead, and now i'll build and spectest that.

[20:25] <jnthn> right

[20:25] <jnthn> k

[20:26] <timotimo> oh. make spectest is a bad idea on jvm ... it is faster, but real/new failures are harder to spot :(

[20:26] <moritz> timotimo: last I did rakudo-jvm spectest, there was just one failure

[20:27] <dalek> nqp: 4bdbd01 | util++ | docs/serialization_format.markdown:

[20:27] <dalek> nqp: Fix unescaped special characters in Markdown text (GH #109)

[20:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4bdbd01add

[20:27] <jnthn> CurriedRoleHOW looks good, by the way

[20:27] *** hummeleB1 left
[20:28] <dalek> roast: 6a456ab | (Elizabeth Mattijsen)++ | integration/advent2009-day18.t:

[20:28] <dalek> roast: Unfudge 3 now passing tests, thanks to timotimo++

[20:28] <dalek> roast: review: https://github.com/perl6/roast/commit/6a456ab87b

[20:28] <timotimo> uh, i can't just move my code over, it's not as simple as i had hoped ;_;

[20:30] <timotimo> it seems i'll have to look at the descriptor stuff

[20:31] <dalek> nqp/moarboot: 6a251d9 | jnthn++ | src/vm/moar/stage0/ (9 files):

[20:31] <dalek> nqp/moarboot: Add selfhost output as stage0.

[20:31] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/6a251d92f0

[20:31] <dalek> nqp/moarboot: 3aac7cb | jnthn++ | src/vm/moar/ModuleLoader.nqp:

[20:31] <dalek> nqp/moarboot: Some uncommenting/tweaks in Moar module loader.

[20:31] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/3aac7cb153

[20:31] <dalek> nqp/moarboot: 386b361 | jnthn++ | tools/build/Makefile-Moar.in:

[20:31] <dalek> nqp/moarboot: Start fleshing out the bootstrap stage1 build.

[20:31] <dalek> nqp/moarboot: 

[20:31] <dalek> nqp/moarboot: The --stagestats on the last two mask a segfault, which annoyingly

[20:31] <dalek> nqp/moarboot: does not segfault under the debugger; maybe other platforms may offer

[20:31] <dalek> nqp/moarboot: more insight.

[20:31] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/386b3619a5

[20:31] <tadzik> aww yiss

[20:31] <timotimo> moar fucking bootcrumps

[20:32] <tadzik> :D

[20:33] <arnsholt> Oooooh

[20:33] * arnsholt is excited

[20:35] * lue feels an urge to update his MoarVM repo and start installin' :D :D :D

[20:35] <jnthn> Well, there's not much to do yet besides build the bootstrap to the half way point I've reached so far :)

[20:36] *** PacoAir left
[20:38] <lue> Well, it's about time I updated my MoarVM anyway :)

[20:38] <lue> by "the debugger", do you mean a general debugger (like gdb) or some MoarVM-specific thing?

[20:39] <jnthn> gdb

[20:41] <lue> OK. I actually just want to play around with moarboot so far, and see if I get the same segfault-masking and such in your last commit there.

[20:47] <timotimo> can a role give a class a different .new?

[20:47] <lizmat> I wouldn't know why not

[20:48] <timotimo> ok

[20:48] <timotimo> that makes the type checking for Array[Foo].new easier

[20:48] <jnthn> it's just a method

[20:48] <lizmat> Setty / Baggy / do it  :-)

[20:48] <timotimo> right.

[20:49] <lue> jnthn: Am I supposed to be seeing lines like "Stage start: 0.000021Stage start      :   0.000" at the moment?

[20:49] *** colomon joined
[20:49] <lue> (no changes to the moarboot branch's stuff, yet)

[20:50] <FROGGS> lue: we are hunting a heisenbug in #moamrvm atm

[20:50] <lue> So yes then. Just checking to make sure I didn't somehow blow things up on my own :) .

[20:51] <jnthn> lue: Yeah, the problem Ihave is that if I pull those out of my Makefile, I get a segfault.

[20:52] <FROGGS> and on my box it blows up with them, but not without :o)

[20:52] <jnthn> yeah, but blows up at exit

[20:52] <jnthn> here it blows up in the middle somewhere

[20:52] <lue> I was actually talking more about the duplicate "Stage start" (and duplicate other lines) rather than the appearance of stagestats, in case there's confusion.

[20:53] <jnthn> lue: yeah, that's broken but not the thing I'm hunting here

[20:53] <lue> Good. Again, just making sure I didn't discover a unique issue or anything.

[20:54] <lizmat> are we expecting coerces like Mix() to ever have named parameters ?

[20:54] * lue will join #moarvm momentarily to share something weird, based on jnthn's results.

[20:54] <timotimo> rakudo stage parse for the core setting is locally 106 instead of 120s by now. that's great! :)

[20:56] *** ajr_ left
[20:56] <timotimo> Type check failed in .new; expected 'Int' but got 'Str'

[20:56] <timotimo> yays :)

[20:56] * timotimo runs a spectest

[20:56] <jnthn> timotimo++

[20:57] <timotimo> t/spec/S02-lexical-conventions/unspace.rakudo.parrot ............ Dubious, test returned 1 (wstat 256, 0x100)

[20:57] <timotimo> :(

[20:57] <timotimo> but that's not my fault i'm sure

[20:57] <timotimo> wait, were our cursless changes merged to master yet or is my local master divergent from upstream master?

[20:58] <jnthn> They were merged...

[20:58] <timotimo> great

[21:12] *** denis_boyun joined
[21:14] <japhb__> Where do y'all generally put modules that are only needed for testing?  lib/Test/ or t/lib/Test/ ?

[21:15] *** logie joined
[21:15] *** donaldh joined
[21:16] <lizmat> t/spec  (in roast)

[21:16] <lizmat> TimToady: $ perl6 -e 'Bag(:a(3),:b(4))'

[21:16] <lizmat> Cannot coerce to Bag with named parameters

[21:17] <lizmat> $ perl6 -e '(:a(3),:b(4)).Bag.perl.say'

[21:17] <lizmat> ("a"=>3,"b"=>4).Bag

[21:18] <dalek> rakudo/nom: 7da6d0a | (Elizabeth Mattijsen)++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[21:18] <dalek> rakudo/nom: Make Type object coercer die if called with named parameters

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7da6d0a791

[21:19] <jnthn> Doesn't fix my SEGV, sadly

[21:20] <jnthn> uh, ww

[21:20] <lizmat> hehe

[21:20] <timotimo> is "ww" short for "wait what?"

[21:20] <lizmat> wrong window

[21:21] <timotimo> ah

[21:21] <timotimo> does S32-array/create.t sound right for Array[Int].new(...) tests?

[21:22] *** stevan_ left
[21:23] <dalek> specs: 97bcf7d | (Elizabeth Mattijsen)++ | S99-glossary.pod:

[21:23] <dalek> specs: Add "ww" for "wrong window"

[21:23] <dalek> specs: review: https://github.com/perl6/specs/commit/97bcf7dd89

[21:23] <lizmat> timotimo: sounds good to me

[21:23] <timotimo> great

[21:32] <dalek> roast: 4e793d0 | (Timo Paulssen)++ | S (2 files):

[21:32] <timotimo> here we go, tests!

[21:32] <dalek> roast: make sure Array[Type].new(NonType) dies with X::TypeCheck

[21:32] <dalek> roast: review: https://github.com/perl6/roast/commit/4e793d06e3

[21:32] *** logie left
[21:34] <lizmat> timotimo: t/spec/S02-lexical-conventions/unspace.rakudo.parrot ............ Dubious, test returned 1 (wstat 256, 0x100)

[21:34] <lizmat> Failed 5/78 subtests 

[21:35] <timotimo> https://github.com/rakudo/rakudo/pull/215 - here is my pull request

[21:36] <dalek> nqp: 21eee91 | coke++ | t/docs/opcodes.t:

[21:36] <dalek> nqp: Manually add these opcodes to the test

[21:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/21eee91cf7

[21:37] <donaldh> jnthn: Is the VTable in STable.java obsolete ?

[21:38] <jnthn> donaldh: Probably, yeah

[21:38] * donaldh can't spot it being referenced.

[21:39] <donaldh> which raises my next question; how to change the serialization format :-)

[21:39] <donaldh> i.e. remove the VTable serialization.

[21:40] <donaldh> my first naive attempt broke stage0 based bootstrap :D

[21:40] *** colomon left
[21:41] <dalek> rakudo/nom: 1405b6e | (Timo Paulssen)++ | src/core/ (2 files):

[21:41] <dalek> rakudo/nom: typecheck the arguments of Array[Type].new.

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1405b6e34c

[21:41] <dalek> rakudo/nom: c6d5c94 | lizmat++ | src/core/ (2 files):

[21:41] <dalek> rakudo/nom: Merge pull request #215 from timo/array_new_typecheck

[21:41] <dalek> rakudo/nom: 

[21:41] <dalek> rakudo/nom: typecheck the arguments of Array[Type].new.

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c6d5c94d15

[21:42] <timotimo> \o/

[21:42] <timotimo> thank you kindly

[21:43] <timotimo> okay, what now? :)

[21:44] <timotimo> sadly, this construction can't easily be changed back to "no type check needed" by the optimizer

[21:44] <timotimo> as in: the user wrote Array[Int].new(1, 2, 3); in that case no typecheck i sactually neaded :|

[21:44] <timotimo> oh well. typechecks are free anyway

[21:45] <lizmat> spectesting now

[21:47] *** pdurbin joined
[21:53] <lizmat> timotimo: seems test count is 6 instead of 8 in create.t

[21:54] <timotimo> er

[21:54] <timotimo> dangit, you're right

[21:54] <timotimo> i'll fix it, thanks

[21:55] <dalek> roast: b240fbf | (Timo Paulssen)++ | S32-array/create.t:

[21:55] <dalek> roast: fix plan

[21:55] <dalek> roast: review: https://github.com/perl6/roast/commit/b240fbfca0

[21:55] <lizmat> timotimo: also t/spec/S02-lexical-conventions/unspace.rakudo.parrot          (Wstat: 256 Tests: 73 Failed: 0)

[21:55] <lizmat>   Non-zero exit status: 1

[21:55] <lizmat>   Parse errors: Bad plan.  You planned 78 tests but ran 73.

[21:56] <timotimo> i thought this wasn't my fault?

[21:56] <timotimo> No such method 'id' for invocant of type 'Str' in block  at t/spec/S02-lexical-conventions/unspace.rakudo.parrot:287

[21:56] <timotimo> not sure what that is supposed to be

[21:57] <lizmat> well, it didn't fail before I merged  :-)

[22:03] <timotimo> huh

[22:03] <timotimo> r: say "foo".id

[22:03] <camelia> rakudo 0f0eba: OUTPUT«No such method 'id' for invocant of type 'Str'␤  in block  at /tmp/bZJaH4UCrh:1␤␤»

[22:03] <timotimo> ... this is supposed to work?

[22:04] * timotimo huhs

[22:04] *** colomon joined
[22:04] * lizmat is not sure

[22:04] <jnthn> I don't know of a .id method

[22:10] <timotimo> r: sub foo() { 'foo' }; is((foo\#`〝 comment 〞.id), 'a', 'unspace with U+301D/U+301E comment');

[22:10] <camelia> rakudo 0f0eba: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/nJHLDIANSs␤Undeclared routine:␤    is used at line 1␤␤»

[22:10] <timotimo> r: use Test; sub foo() { 'foo' }; is((foo\#`〝 comment 〞.id), 'a', 'unspace with U+301D/U+301E comment');

[22:10] <camelia> rakudo 0f0eba: OUTPUT«No such method 'id' for invocant of type 'Str'␤  in block  at /tmp/odDwksYxIs:1␤␤»

[22:10] <timotimo> that's the test that fails

[22:11] <timotimo> ... wat

[22:11] <timotimo> the test below that is the same with an eval_dies_ok

[22:11] <timotimo> oh, no, that's different unicode characters there

[22:12] <FROGGS> r: sub foo { }; say foo.id

[22:12] <camelia> rakudo 0f0eba: OUTPUT«No such method 'id' for invocant of type 'Nil'␤  in block  at /tmp/qxaIATudNL:1␤␤»

[22:12] <FROGGS> ahh, hmmm, w/e

[22:12] <lizmat> could it be a problem with fudging ?

[22:12] <FROGGS> n: use Test; sub foo() { 'foo' }; is((foo\#`〝 comment 〞.id), 'a', 'unspace with U+301D/U+301E comment');

[22:12] <camelia> niecza v24-98-g473bd20: OUTPUT«Unhandled exception: Unable to resolve method id in type Str␤  at /tmp/hOAeEzAvHl line 1 (mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4584 (module-CORE @ 576) ␤  …»

[22:13] <timotimo> it's only fudged for niecza with the same error on rakudo

[22:15] <FROGGS> it should get skipped: https://github.com/perl6/roast/blob/a299b31499c73bd7638790e585c9733b16bd83fe/S02-lexical-conventions/unspace.t#L281

[22:19] <FROGGS> and a .id method is not mentioned in the specs

[22:20] <timotimo> yeah

[22:21] <FROGGS> r: sub foo() { 'foo' }; is((foo\#`〝 comment 〞), 'foo', 'unspace with U+301D/U+301E comment');

[22:21] <camelia> rakudo c6d5c9: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/iUH4hkcZG1␤Unexpected closing bracket␤at /tmp/iUH4hkcZG1:1␤------> [32mb foo() { 'foo' }; is((foo\#`〝 comment 〞[33m⏏[31m), 'foo', 'unspace with U+301D/U+301E co[0m␤»

[22:21] <FROGGS> but this is a problem

[22:22] <FROGGS> r: sub foo() { 'foo' }; is((foo\#`〝 comment 〞`), 'foo', 'unspace with U+301D/U+301E comment');

[22:22] <camelia> rakudo c6d5c9: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/CUXgyv_ILA␤Confused␤at /tmp/CUXgyv_ILA:1␤------> [32mb foo() { 'foo' }; is((foo\#`〝 comment 〞[33m⏏[31m`), 'foo', 'unspace with U+301D/U+301E c[0m␤    expecting any of:␤        unspace…»

[22:22] <grondilu> you can't write \#, can you?

[22:22] <FROGGS> r: sub foo() { 'foo' }; is((foo#`〝 comment 〞`), 'foo', 'unspace with U+301D/U+301E comment');

[22:22] <camelia> rakudo c6d5c9: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/XVyQPFP6en␤Two terms in a row␤at /tmp/XVyQPFP6en:1␤------> [32mub foo() { 'foo' }; is((foo#`〝 comment 〞[33m⏏[31m`), 'foo', 'unspace with U+301D/U+301E c[0m␤    expecting any of:␤     …»

[22:23] <FROGGS> r: sub foo() { 'foo' }; is((foo#`〝 comment 〞), 'foo', 'unspace with U+301D/U+301E comment');

[22:23] <camelia> rakudo c6d5c9: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/mKGqnqw7Fr␤Undeclared routine:␤    is used at line 1␤␤»

[22:23] <dalek> roast: 5b439fa | (Elizabeth Mattijsen)++ | S02-lexical-conventions/unspace.t:

[22:23] <dalek> roast: Fudge parse error for now

[22:23] <dalek> roast: review: https://github.com/perl6/roast/commit/5b439faf84

[22:23] <FROGGS> r: use Test; sub foo() { 'foo' }; is((foo#`〝 comment 〞), 'foo', 'unspace with U+301D/U+301E comment');

[22:23] <camelia> rakudo c6d5c9: OUTPUT«ok 1 - unspace with U+301D/U+301E comment␤»

[22:23] <FROGGS> hmmm

[22:24] <timotimo> somebody must have unfudged it by accident?

[22:24] <FROGGS> ahh, the backslash might be a opy+pasto from the eval_dies_ok

[22:24] <FROGGS> timotimo: it is still fudged

[22:24] <timotimo> only for niecza

[22:26] <FROGGS> ahh, now I see it

[22:26] <lizmat> I just fudged it again

[22:26] <FROGGS> timotimo: you did https://github.com/perl6/roast/commit/4e793d06e3000bafad7ef49468dc9494e6a5a2f1

[22:26] <FROGGS> :o)

[22:27] <lizmat> hehe

[22:27] <FROGGS> r: use Test; sub foo() { 'foo' }; is((foo#`〝 comment 〞.Str), 'foo', 'unspace with U+301D/U+301E comment');

[22:27] <camelia> rakudo c6d5c9: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/4GK_1Fkxmm␤Two terms in a row␤at /tmp/4GK_1Fkxmm:1␤------> [32mub foo() { 'foo' }; is((foo#`〝 comment 〞[33m⏏[31m.Str), 'foo', 'unspace with U+301D/U+301[0m␤    expecting any of:␤     …»

[22:27] <lizmat> ok, I fudged it again

[22:27] <FROGGS> yeah

[22:27] <FROGGS> so we fail like niecza nowadays... not bad

[22:27] <lizmat> indeed

[22:27] <lizmat> and on that thought, I wish you all g;night!

[22:27] <jnthn> What would STD do?

[22:28] <lizmat> sleep&

[22:28] <jnthn> 'night, lizmat 

[22:29] <grondilu> wow, there has been more commits on P6 core than on P5 core in 2013:  https://groups.google.com/forum/#!topic/perl.perl6.compiler/LFsajeiZY-s

[22:31] <timotimo> ... waaaaaat

[22:31] <timotimo> how did i do that?!

[22:32] <timotimo> grondilu: we know :)

[22:32] <tadzik>  jnthn | What would STD do?

[22:32] <tadzik> lizmat | sleep&

[22:32] <tadzik> typical STD ;)

[22:32] <jnthn> :D

[22:33] *** denis_boyun left
[22:38] <dalek> nqp/moarboot: 4a3a97d | jnthn++ | src/NQP/World.nqp:

[22:38] <dalek> nqp/moarboot: Fix fossil found while porting.

[22:38] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/4a3a97df0c

[22:38] <dalek> nqp/moarboot: 9b5a875 | jnthn++ | tools/build/Makefile-Moar.in:

[22:38] <dalek> nqp/moarboot: Remove --stagestats workaround; correct backend.

[22:38] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/9b5a875c73

[22:45] *** grondilu left
[22:50] <dalek> nqp/moarboot: 9dbdb85 | jnthn++ | src/NQP/World.nqp:

[22:50] <dalek> nqp/moarboot: BEGIN fixes from Moar porting work.

[22:50] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/9dbdb85242

[22:52] *** donaldh left
[22:58] *** dwarring joined
[23:02] *** GlitchMr left
[23:03] <dwarring> dumb questions coming up...

[23:04] <dwarring> should nqp be available as a slang from perl6?

[23:04] <dwarring> i was thinking it could be used as a way of geting close to the 'metal' for critical code segments

[23:05] <FROGGS> should be Nearly Quite Possible to do anyway

[23:05] <lue> r: say "This is Perl 6!"; nqp::say("This is NQP!");

[23:05] <camelia> rakudo c6d5c9: OUTPUT«This is Perl 6!␤This is NQP!␤»

[23:05] <dwarring> heh!

[23:06] <jnthn> There's even the odd place this happens. The JVM MapIter impl is mostly expressed in NQP ops

[23:06] *** dmol1 left
[23:07] <dwarring> it's still be nice to be able to inline chunks of nqp code

[23:07] <FROGGS> if we had a clean way  of switching to a slang, it would be a matter of ~20 loc to switch to NQP::Grammar

[23:07] <dwarring> hang on a few secs I'll just gist some heavily optimised code...

[23:08] <dwarring> still might be worthwhile, say for a loop that needs to be heavily optimised

[23:08] <lue> .oO(Q:lang<NQP>" ... ")

[23:08] <dalek> nqp/moarboot: b3bcb84 | jnthn++ | src/vm/moar/stage0/ (9 files):

[23:08] <dalek> nqp/moarboot: Update MoarVM stage0.

[23:08] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/b3bcb84601

[23:08] <dalek> nqp/moarboot: def059e | jnthn++ | src/vm/moar/QAST/QAST (3 files):

[23:08] <dalek> nqp/moarboot: Add QAST -> MAST.

[23:08] <dalek> nqp/moarboot: 

[23:08] <dalek> nqp/moarboot: Mostly a direct steal from nqp-cc in the MoarVM repo.

[23:08] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/def059eb3a

[23:08] <TimToady> though one would hope that Perl 6 written in the NQP subset would just translate straight across

[23:09] <dwarring> heare's my gist, https://gist.github.com/dwarring/6847192

[23:09] <dwarring> not pretty!

[23:10] <lue> TimToady: Not Quite (compatible with) Perl (6) :)

[23:10] <TimToady> Fix it!  :)

[23:12] <dalek> nqp/moarboot: 55732de | jnthn++ | src/vm/moar/NQP/Ops.nqp:

[23:12] <dalek> nqp/moarboot: Add an NQP::Ops for MoarVM.

[23:12] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/55732de6dd

[23:12] <dalek> nqp/moarboot: 100ad78 | jnthn++ | tools/build/Makefile-Moar.in:

[23:12] <dalek> nqp/moarboot: Finish filling out stage1 Makefile for MoarVM.

[23:12] <dalek> nqp/moarboot: 

[23:12] <dalek> nqp/moarboot: We now make it through using NQP hosted on MoarVM to compile the NQP

[23:12] <dalek> nqp/moarboot: sources. Sadly, the output does not yet work.

[23:12] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/100ad783cd

[23:12] <dwarring> still does beat this running under nap https://gist.github.com/dwarring/6847212

[23:12] <timotimo> dwarring, does it actually make a difference if you use nqp::mul-n or just *?

[23:12] <timotimo> oh

[23:12] <timotimo> you are feeding this to rakudo

[23:14] <dwarring> yes

[23:14] <timotimo> you could comparebwhat both of them output with --targer=ast

[23:14] <TimToady> we probably shouldn't allow that unless you "use UNWARRANTED_CHUMMINESS_WITH_THE_COMPILER"

[23:15] <dwarring> both gists work on nqp and rakudo...

[23:15] <dwarring> rough order of performance (worst to best)...

[23:16] <lue> use MONKEY_WRENCH; for consistency :)

[23:16] <TimToady> lue++

[23:18] <dwarring> well nqp out-performs rakudo on both 

[23:18] <timotimo> have you tried it with all five versions of nqp and eakudo?

[23:19] <dwarring> no just on parrot

[23:20] <timotimo> ok

[23:21] <dwarring> I'll try jvm

[23:21] <TimToady> MONKEY_BUSINESS, MONKEY_SEE_MONKEY_DO, MONKEYING_AROUND, MONKEYSHINE...

[23:22] <TimToady> MONKEY_SEE_MONKEY_DO would have to enable some kind of cargo culting

[23:24] <dwarring> similar results on jvm

[23:24] <dwarring> the optimised example is about 3x faster on perl6

[23:25] <dwarring> but nqp beats rakudo

[23:26] <dwarring> these are rough timings, but the times between parrot & jvm appear similar

[23:27] *** Guest96073 is now known as ponbiki

[23:28] *** colomon left
[23:28] <dwarring> I guess the other way to go to write critical stuff in nqp is just put it in a separate source file

[23:29] <dwarring> guess I can do that now

[23:30] * dwarring but inlining nqp has it's attractions

[23:32] <timotimo> there is some work towards use blahblah:from<nqp>

[23:36] <timotimo> on my computer, the difference is much more pronounced

[23:36] *** GlitchMr joined
[23:36] <timotimo> between nqp and perl6; nqp is quasi-instantaneous (0.2s), perl6 takes its sweet time (1.5)

[23:36] <timotimo> there's probably some startup cost involved

[23:36] *** BenGoldberg joined
[23:37] <TimToady> that should be measurable

[23:37] * timotimo makes it compute pi 1000 times

[23:38] <dwarring> timotimo: how long for the optimised on rakudo?

[23:38] <dwarring> ok

[23:39] <timotimo> wow, this is sad!

[23:40] *** colomon joined
[23:41] <TimToady> 1000 times infinite is pretty long

[23:41] <timotimo> approximate*

[23:41] <timotimo> well, to be fair, we've seen that trend in the benchmarks since forever...

[23:41] <timotimo> that essentially the same code as perl6 takes a few orders of magnitudes more time than the nqp code does ...

[23:41] <timotimo> maybe we should just give up on perl6 itself and push nqp aggressively instead

[23:42] <dwarring> inlining!

[23:42] <timotimo> nqp doesn't do inlining yet, rakudo does ...

[23:42] <timotimo> rakudo takes like 1 second for each calculation, whereas nqp does 100 in less than one.

[23:42] <timotimo> less than half a second, actually

[23:43] <TimToady> what datatypes?

[23:43] <timotimo> native ints and nums

[23:43] <timotimo> (i made a version for perl6 that doesn't use nqp::bind, instead assigning to native variables)

[23:44] * dwarring meant inlining as in source code inlining

[23:46] <BenGoldberg> Source code inlining can only help with sub/method calls

[23:46] <BenGoldberg> Source code inlining can't help if [+] 1..10 in perl6 is 200x slower than the eqivilant nqp code

[23:47] <TimToady> obviously we aren't going to be depending on a single kind of optimization

[23:47] <timotimo> yes, yes. of course.

[23:48] <TimToady> though, in the case of [+] 1..10 it should just do constant folding at compile time :P

[23:48] <timotimo> ayup.

[23:51] <BenGoldberg> Well, [+] 1..$n, then, but you know what I mean :)

[23:52] <TimToady> that one would just be a template recognition with substitution of a simpler formula :)

[23:53] <TimToady> triangle-number($n) I suppose

[23:59] <timotimo> i don't think these simple pattern substitutions will get us far

