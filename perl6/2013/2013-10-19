[00:13] *** xenoterracide left
[00:16] *** Psyche^_ left
[00:16] *** Mouq left
[00:18] *** Psyche^ joined
[00:20] *** PacoAir left
[00:32] *** Mouq joined
[00:37] *** paxcoder joined
[00:39] <paxcoder> Hello. I asked people in #perl where I can learn  progressive ideas that are specific to perl. They suggested Moo and HOP. Can you perhaps suggest perl6-specific reading I should add to those?

[00:40] * japhb__ looks at his screen as if the computer has completely lost its mind.

[00:41] * paxcoder , who is not a computer is not sure that is directed at him

[00:41] <japhb__> It *appears* that sometimes IO::Path.copy() leaves the read handle open.

[00:43] <japhb__> So once in a while you copy a file, go to delete the original, and your network filesystem happily creates a .nfs000foobar file (or equivalent) for you.  Because you still wanted that file, right?  Otherwise, why are you holding it open?

[00:43] <japhb__> paxcoder: nope, not directed at you at all.  Just coincidence.  :-0

[00:43] <japhb__> er

[00:43] <japhb__> :-)

[00:45] <japhb__> paxcoder: Perl 6 is rather full of ideas, some of them progressive.  Other prefixes than 'pro' could also be used, and the sentence would still remain true.  :-)

[00:46] <japhb__> paxcoder: You might want to read the synopse on Grammars, for a start.

[00:46] <paxcoder> japhb, what's that?

[00:47] <japhb__> Actually, even better, see jnthn++'s courseware on building a simple compiler in NQP.

[00:48] <japhb__> paxcoder: http://perlcabal.org/syn/ is where the official spec documentation is held.  I was referring to chapter 5.

[00:48] * paxcoder sees a purple link right there :-)

[00:48] <paxcoder> (chapter 5)

[00:48] <japhb__> paxcoder: All of http://www.jnthn.net/articles.shtml is good too.

[00:49] <japhb__> paxcoder: His talk on Concurrency in Perl 6 (second from the top) is very forward-thinking.

[00:50] <paxcoder> japhb, can you explain the role of perlcabal? is it current?

[00:51] <japhb__> Where are you seeing that, paxcoder?

[00:51] <paxcoder> japhb, you just posted the link

[00:51] <paxcoder> chapter 5 thingy

[00:51] <japhb__> Ah, here's that compiler design course (meant to teach by example how Rakudo is built): https://github.com/edumentab/rakudo-and-nqp-internals-course

[00:52] <japhb__> paxcoder: Oh!  Funny, I never think of that domain being there.  I just think of it as the spec section of perl6.org.  :-)

[00:53] <paxcoder> so it's normative and up-to-date, eh?

[00:54] <japhb__> Yes.  If you want the raw files, they're at https://github.com/perl6/specs

[00:55] <japhb__> But yes, the perlcabal version is kept synced up.  It's the HTML-ified and otherwise reader-friendly-ified version, but it's otherwise the same.

[00:56] *** pecastro left
[00:57] *** pecastro joined
[00:57] <Mouq> paxcoder: Perl6 does have the idea of roles, which are similar to objects, but are meant to encapsulate functionality

[00:58] * japhb__ goes back to wondering how the heck he's going to find an intermittent failure to close the file in copy.  Looking at the source of the parrot file dynpmc, it *looks* like a fairly clear close after each open.  :-/ 

[00:58] <japhb__> Ah yes, Mouq++ is quite right.  That was a big deal.

[01:00] <paxcoder> Mouq, not sure what you mean. Surely, objects encapsulate functionality alongside data.

[01:01] <japhb__> paxcoder: Roles are a superset/generalization of what other languages call interfaces, traits, or mixins.

[01:01] <japhb__> They carry interface requirements, default implementations, type annotations, attribute declarations, and so forth.

[01:02] <paxcoder> interesting. So you suggest I look at Regexes, Rules, Roles, any other Rs?

[01:02] <japhb__> There are files in the Rakudo source tree that declare powerful classes almost entirely by composing a number of roles.

[01:04] <japhb__> paxcoder: The MOP is a big deal, because while historically related, Perl 6's MOP can do many things that the Moose MOP in Perl 5 cannot, because of the type system and internal design (6model) that Perl 6/Rakudo has.

[01:04] <japhb__> afk, bus stop &

[01:04] <Mouq> S14: "Depending on how you care to look at it, a role is like a partial class, or an interface with default implementation, or a set of generic methods and their associated data, or a class closed at compile time."

[01:05] <Mouq> And just before that: "Classes are primarily in charge of object management, and only secondarily in charge of software reuse. In Perl 6, roles take over the job of managing software reuse."

[01:05] <paxcoder> Mouq, sounds pretty straightforward, why is it revolutionary?

[01:07] <paxcoder> btw. if I learn 6's MOP, can I skip Moo then?

[01:07] <paxcoder> Mouq, ^,^^

[01:09] <Mouq> Heh. I'm pretty new the Perl 6 community myself. I don't think roles are particularly revolutionary, but they're very useful. Remember they're default implementations as well as interfaces, and they, I belive, leverage Perl 6's powerful method dispatch

[01:09] <Mouq> Which is another awesome thing.

[01:10] *** [particle]1 joined
[01:11] *** [particle] left
[01:12] <Mouq> I'm not sure, what you mean about Moo, since Moo is a Perl 5 module. If you're planning on using Perl 5, no. If you're planning on using Perl 6, that question doesn't apply. If you're planning on using both (which is the standard thing to do right now AFAICT), you need to know both.

[01:12] <paxcoder> Mouq, i'm planning on using none. I'm just here for ideas.

[01:12] <paxcoder> Yummy delicious perl ideas

[01:12] <Mouq> Oh, well, cool

[01:13] <Mouq> Like I said, I'm pretty far from a definitive nor completely trustworthy resource

[01:13] <paxcoder> ok, thanks for the disclaimers.

[01:15] <paxcoder> (will wait for) japhb ('s answer to): HOP and 6's MOP & ch5 should do it for me?

[01:15] *** xenoterracide joined
[01:16] <LWA> paxcoder: about Roles: Classes are nice, interfaces are useful. However, compositing behaviour is difficult with them (inheriting from two types). Multiple inheritance is ugly and has all kind of issues. Mixins are a step forward, Traits are a refinement (a trait is a type that provides and requires certain methods), Roles are an extension of Traits with associated data. Result: Extremely expressive object system

[01:17] <Mouq> .oO(Perl 6 refactoring of regexes/ideas for grammars is awesome, though. If you take anything away, take that, IMO)

[01:17] <paxcoder> LWA, but when you say MOP, you encompass Roles, right?

[01:18] <paxcoder> or perhaps you're sugesting I don't need to look at MOP and should only be concerned with Roles?

[01:18] <Mouq> paxcoder: Perl is not a language that you can cut up easily

[01:19] <LWA> paxcoder: I did not say anything about a meta-object protocol. Roles ⊥ MOP

[01:20] <paxcoder> LWA, i'm not sure you can use reverse tautology like that :-)

[01:21] <paxcoder> but got it

[01:22] <Mouq> Actually, I redact my statement (though don't negate it). I think one of the things that makes Perl 6 powerful is that it mixes many concepts, and it does so in a consistent and usable (and often pretty) way

[01:22] <paxcoder> Mouq, i actually like consistency

[01:22] <paxcoder> uniformity

[01:22] <paxcoder> ubiquity

[01:22] <paxcoder> you know what i mean

[01:24] <Mouq> Mmm.. not really. Uniformity sounds more like lisp

[01:24] <paxcoder> it does, yes

[01:24] <paxcoder> i meant to write "eg. lisp's homoiconicity"

[01:25] <paxcoder> but that's just syntax

[01:28] <Mouq> r: infix:<syntax> (Str $a, Regex $b) { $a ~~ $b }; say "a + b" syntax / [(\w+) <[+-/*]> (\w+)]* /

[01:28] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/mn2g_iiGl8␤Two terms in a row␤at /tmp/mn2g_iiGl8:1␤------> infix:<syntax> (Str ⏏$a, Regex $b) { $a ~~ $b }; say "a + b" ␤    expecting any of:␤        postfix␤        inf…»

[01:28] <Mouq> Hm?

[01:29] <Mouq> r: sub infix:<syntax> (Str $a, Regex $b) { $a ~~ $b }; say "a + b" syntax / [(\w+) <[+-/*]> (\w+)]* /

[01:29] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/Q44T_qldjL␤Unsupported use of - as character range; in Perl 6 please use .. for range, for explicit - in character class, escape it or place as last thing␤at /tmp/Q44T_qldjL:1␤------> ~ $b }; …»

[01:29] <Mouq> ._. almost

[01:29] <Mouq> r: sub infix:<syntax> (Str $a, Regex $b) { $a ~~ $b }; say "a + b" syntax / [(\w+) <[+\-/*]> (\w+)]* /

[01:29] <camelia> rakudo 455467: OUTPUT«｢｣␤␤»

[01:30] <Mouq> r: sub infix:<syntax> (Str $a, Regex $b) { $a ~~ $b }; say "a + b" syntax / :s (\w+)+ % <[+\-/*]> /

[01:30] <camelia> rakudo 455467: OUTPUT«｢a ｣␤ 0 => ｢a｣␤␤»

[01:30] *** BenGoldberg left
[01:32] <Mouq> r: sub infix:<syntax> (Str $a, Regex $b) { $a ~~ $b }; say "a + b" syntax / (\w)+ % [<.ws>(<[+\-/*]>)<.ws>] /

[01:32] <camelia> rakudo 455467: OUTPUT«｢a + b｣␤ 0 => ｢a｣␤ 1 => ｢+｣␤ 0 => ｢b｣␤␤»

[01:32] <Mouq> \o/

[01:34] <Mouq> Anyway,

[01:35] <Mouq> paxcoder: I think I kind of disagree with 'just syntax'. If syntax were really a trivial thing, we'd all be using some form of lisp

[01:36] <paxcoder> not that just

[01:40] <Mouq> p56: sub postfix:<!> (Int $n) { [*] 1..$n }; say 5!

[01:40] <camelia> p5-to-p6 : OUTPUT«syntax error at perlito5.pl line 874.␤»

[01:40] <Mouq> :) just curious

[01:40] <Mouq> Oh woops, wrong way around

[01:41] <Mouq> p56: say 'Laaaaaame'

[01:41] <camelia> p5-to-p6 : OUTPUT«say('Laaaaaame')␤»

[01:44] *** _ilbot left
[01:45] *** benabik joined
[01:45] <Mouq> p56: print "am I said?\n"

[01:45] <camelia> p5-to-p6 : OUTPUT«print('am I said?' ~ chr(10))␤»

[01:45] <Mouq> Nope

[01:46] *** _ilbot joined
[01:47] *** [particle]1 left
[01:54] *** xenoterracide left
[02:09] *** berekuk left
[02:21] *** berekuk joined
[02:26] *** FROGGS left
[02:27] *** berekuk left
[02:41] *** xenoterracide joined
[02:48] *** {amon} joined
[02:48] *** FROGGS joined
[02:51] *** LWA left
[02:53] <dalek> nqp: 2c393d3 | dwarring++ | examples/rubyish/ (6 files):

[02:53] <dalek> nqp: added bitwise ops, fixed precedence, etc

[02:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2c393d38c9

[03:14] *** risou_awy is now known as risou

[03:25] *** sniz joined
[03:42] *** preflex_ joined
[03:42] *** ChanServ sets mode: +v preflex_

[03:43] *** preflex left
[03:43] *** preflex_ is now known as preflex

[03:56] *** xenoterracide left
[03:59] *** paxcoder left
[04:07] *** xinming_ joined
[04:10] *** xinming left
[04:21] *** FROGGS left
[04:44] <moritz> \o

[05:04] <Mouq> o/

[05:16] <moritz> nqp-jvm fails tests in two files for me (19-file-ops.t, 02-pipes.t)

[05:17] *** SamuraiJack joined
[05:19] <Mouq> r: say ' a b c d ' ~~ m:s/ [\w ] + /

[05:19] <camelia> rakudo 455467: OUTPUT«｢ a b c d ｣␤␤»

[05:19] <Mouq> r: say ' a b c d ' ~~ m:s/ (\w ) + /

[05:19] <camelia> rakudo 455467: OUTPUT«｢ a b c d ｣␤ 0 => ｢a ｣␤ 0 => ｢b ｣␤ 0 => ｢c ｣␤ 0 => ｢d ｣␤␤»

[05:19] <Mouq> r: say ' a b c d ' ~~ m:s/ ( \w ) + /

[05:19] <camelia> rakudo 455467: OUTPUT«｢ a b c d ｣␤ 0 => ｢a ｣␤ 0 => ｢b ｣␤ 0 => ｢c ｣␤ 0 => ｢d ｣␤␤»

[05:19] <Mouq> n: say ' a b c d ' ~~ m:s/ ( \w ) + /

[05:19] <camelia> niecza v24-98-g473bd20: OUTPUT«｢ a b c d ｣␤ 0 => ｢a ｣␤ 0 => ｢b ｣␤ 0 => ｢c ｣␤ 0 => ｢d ｣␤␤»

[05:21] <Mouq> "Only whitespace sequences immediately following a matching construct (atom, quantified atom, or assertion) are eligible. Hence, initial whitespace is ignored at the front of any regex, to make it easy to write rules that can participate in longest-token-matching alternations."

[05:22] <moritz> r: say ~(' a b c d ' ~~ m:s/ ( \w ) + /)

[05:22] <camelia> rakudo 455467: OUTPUT« a b c d ␤»

[05:23] <moritz> Mouq: so it shouldn't match the initial space, right?

[05:23] <TimToady> only STD implements the correct semantics so far

[05:23] <Mouq> That's what I'm getting from it

[05:23] *** dansamo joined
[05:23] <moritz> nqp: say(~(' a b c d ' ~~ /:s  ( \w ) + /) )

[05:23] <camelia> nqp: OUTPUT« a b c d ␤»

[05:24] <moritz> Mouq: please submit an nqp bug for that

[05:24] * Mouq is trying to get /[ ]/ etc to fail properly, and the refactoring required may fix this too

[05:24] <Mouq> Okay

[05:24] <TimToady> std: /[ ]/  # as in this failure?

[05:24] <camelia> std a0bcfb1: OUTPUT«===SORRY!===␤Null pattern not allowed at /tmp/nH4zKrFueN line 1:␤------> /[ ⏏]/  # as in this failure?␤Parse failed␤FAILED 00:01 121m␤»

[05:25] <Mouq> r: /[ ]/ # Yup

[05:25] <camelia> rakudo 455467: ( no output )

[05:25] <Mouq> r: my regex :: { } # Also

[05:25] <camelia> rakudo 455467: ( no output )

[05:32] *** xenoterracide joined
[05:35] <benabik> Doesn't /:s ( \w ) + / become / ( \w <.ws> )+ <.ws> / ?

[05:36] <benabik> + is a quantifier

[05:36] <TimToady> yes, that seems right

[05:36] <Mouq> Yeah. "When we say sigspace can follow either an atom or a quantified atom, we mean that it can come between an atom and its quantifier:"

[05:37] <TimToady> oh, so it's not that

[05:37] <TimToady> it's / [( \w <.ws ) <.ws>]+ <.ws> /

[05:38] <Mouq> Oop

[05:38] <TimToady> er s:1st/'<.ws'/<.ws>/

[05:39] <Mouq> Updated

[05:39] <TimToady> this is why you can write 'foo' +% ',' and get whitespace after each foo

[05:41] <TimToady> it turns into ['foo'<.ws>]+ % [','<.ws>]

[05:42] <TimToady> benabik: the ( \w ) is also an atom, so has sigspace after it, before the +

[05:42] <benabik> Why does % grab the .ws?

[05:42] <TimToady> % doesn't grab any .ws

[05:43] <benabik> To the right of it?  [','<.ws>]

[05:43] <TimToady> I'm assuming a sigspace after it, just didn't bother writing the space /

[05:44] <TimToady> 'foo' +% ',' /

[05:44] <benabik> Well, yes.  But how far right does % go?  To the end of the rule?

[05:44] <TimToady> has a sigspace after each 'foo' and after each ','

[05:44] <TimToady> % only takes one atom to the right

[05:44] <TimToady> well, one quantified atom

[05:45] <benabik> The sigspaces attach themselves to the atoms, so get caught by the %?

[05:45] <TimToady> you can do 'foo' +% 'bar'+ and it would match "foo barbarbar foo"

[05:46] <benabik> It's the "takes one atom" and ending up with ','<.ws> that confuses me.  Is sigspace a quasi-quantifier?

[05:46] <TimToady> % is just a funny loop, and doesn't care whether the left or right atoms also match sigspace

[05:47] <TimToady> yes, in that sense the sigspace counts as part of the one atom

[05:48] <benabik> Okay.  I had been mentally translating sigspace into <.ws> rules, but it's actually more like ['atom' <.ws>] for every atom.

[05:48] <TimToady> yes

[05:49] <TimToady> except, of course, if you say ('foo') +% ',' it will only return the foo elements, not including the ws

[05:50] <TimToady> but I guess that follows from your rewrite anyway

[05:50] <TimToady> since the rewrite would be [('foo') <.ws>]

[05:50] <benabik> Right.

[05:51] <TimToady> I know if feels weird to write +% together like that, but I think people will get used to it as an idiom

[05:51] <benabik> That makes a lot of intuitive sense, but was hard to reason out.

[05:52] <benabik> +% feels like some kind of numeric operator.

[05:52] <TimToady> it's one of those strangely consistent thingies, or at least something that is almost strangely consistent :)

[05:54] <TimToady> only doing sigspace after atoms is another of those symmetry breaks that was not obvious except in retrospect

[05:54] <TimToady> just as we initially thought ~~ should be symmetrical, but that led to problems

[05:55] <benabik> But not before it was implemented in p5

[05:55] <TimToady> it also happens to make things more efficient, since you never have to match a ws unless there is a new one there to match

[05:56] <TimToady> benabik: alas, yes

[05:56] <TimToady> but the real problem with smartmatch in p5 is not even that, but the lack of a type system

[05:57] <TimToady> p5 is often confused about whether a particular scalar is a string or a number

[05:57] <benabik> Well because it's a any(str|num)

[05:57] <benabik> If I've been following the perlguts blog posts correctly.

[05:58] <TimToady> I also count the lack of junctions as part of the type deficit

[05:58] <TimToady> so too many p5 smartmatches have implicit junctional semantics; in p6 these must always be explicit

[06:24] *** kaare_ joined
[06:24] *** Rotwang joined
[06:55] * Mouq might have gotten it. Wasn't as significant as I had originally thought once TimToady++ pointed out the atom -> atom+sigspace thing

[06:56] *** darutoko joined
[07:00] <TimToady> the hard part is making sure "atom" doesn't include things like :foo

[07:01] <Mouq> TimToady: Can you show me an example?

[07:01] <TimToady> for instance, in / :s 42 / there is no sigspace after :s

[07:01] <TimToady> only after the 42

[07:02] <Mouq> Oh, okay. Thank you

[07:04] <TimToady> that's why STD.pm6 is playing with <.SIGOK> in various spots

[07:04] <TimToady> to mark which metachars are really matchers, and which are not

[07:09] <Mouq> Is :s [ <mumble> ] supposed to be just [ <mumble> <.ws> ] or [ <.ws> <mumble> <.ws> ]?

[07:10] <TimToady> the first, which is why STD says :my $*SIGOK = False; in quant_atom_list

[07:11] <TimToady> %RX<s> is set, but until <mumble> sets $*SIGOK it will treat whitespace as normal space

[07:13] <Mouq> TimToady: Okay, thank you.

[07:15] <TimToady> and as soon as <sigmaybe> finds a whitespace with $*SIGOK set, it immediately resets it, so any atom can only enable a single sigspace

[07:15] <TimToady> the STD algorithm isn't heavily tested, so there may be a bug or two, but by and large its heart is in the right place :)

[07:16] *** FROGGS joined
[07:17] <TimToady> I guess it's tested sufficiently well that viv can bootstrap on it to correctly bootstrap itself, when STD.pm6 is written assuming the correct sigspace rules :)

[07:17] *** kaare_ left
[07:19] <TimToady> so that, for instance, all the statement_control matchers can be written as rules

[07:19] <TimToady> they used to have to be tokens that switch to :s in the middle under the old rules

[07:20] <TimToady> with the new semantics rules can participate fully in LTM matchers

[07:21] <TimToady> gah, have to get up early to move 200 comic book boxes from my brother-in-law's condo to storage...

[07:21] * TimToady --> bed

[07:21] <moritz> sleep well, and dream of successfull LTM

[07:22] <Mouq> :) Thank you TimToady, and g'night

[07:23] *** isBEKaml joined
[07:35] *** Rotwang left
[07:35] *** muixirt joined
[07:39] <muixirt> https://jenkins.freenetproject.org/ --> Service Temporarily Unavailable

[07:40] <muixirt> oops wrong channel :-)

[07:44] *** sniz left
[07:47] *** risou is now known as risou_awy

[07:47] *** sniz joined
[07:56] *** isBEKaml left
[08:03] *** spider-mario joined
[08:13] *** denis_boyun joined
[08:19] *** donaldh left
[08:20] *** denis_boyun left
[08:23] *** donaldh joined
[08:28] <moritz> nqp: say(nqp::index('abc', 'a', 3)

[08:28] <camelia> nqp: OUTPUT«Confused at line 2, near "say(nqp::i"␤current instr.: 'panic' pc 14748 (src/stage2/gen/NQPHLL.pir:5229) (src/stage2/gen/NQPHLL.nqp:279)␤»

[08:28] <moritz> nqp: say(nqp::index('abc', 'a', 3))

[08:28] <camelia> nqp: OUTPUT«-1␤»

[08:28] <dalek> nqp: b8a7bbb | moritz++ | src/vm/parrot/QAST/Compiler.nqp:

[08:28] <dalek> nqp: [regex] avoid an unnecessary comparison

[08:28] <dalek> nqp: 

[08:28] <dalek> nqp: when the index is op is used, it always returns -1 for start indexes

[08:28] <dalek> nqp: beyond the string length

[08:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b8a7bbba70

[08:33] *** denis_boyun joined
[08:37] *** {amon} is now known as LWA

[08:38] *** SamuraiJack left
[08:44] * moritz blug: http://perlgeek.de/blog-en/perl-6/2013-a-regex-optimization.html

[08:45] <JimmyZ> It'll be nice to port to src/vm/moar/ too

[08:47] *** dansamo left
[09:07] <masak> good antenoon, #perl6 :)

[09:13] <frettled> my my

[09:22] <felher> moritz++ #interesting post, nice. :)

[09:23] <FROGGS> moritz++ # cool!

[09:24] <FROGGS> I think this improves user's regexes a lot, since this is a pretty common usecase

[09:31] *** rindolf joined
[09:32] *** zakharyas joined
[09:43] *** risou_awy is now known as risou

[09:44] *** zakharyas left
[09:45] *** Mouq left
[09:57] <jnthn> morning, #perl6

[09:57] <yoleaux> 08:03Z <FROGGS> jnthn: about the stagestats bug: it works when I close the handles after writing to it, but I am unable to close the ones that were written to in gc_free of MVMOSHANDLE or in tc_destroy

[09:57] <yoleaux> 08:04Z <FROGGS> jnthn: though I can walk the handles easily in tc_destroy fwiw

[10:02] <jnthn> moritz++ # great blog post!

[10:03] <moritz> thanks

[10:03] * moritz tries his hands on moarvm codegen

[10:03] <moritz> it looks nice enough

[10:04] <jnthn> Yeah

[10:04] <jnthn> It's just the JVM one that may feel a bit foreign

[10:04] <jnthn> 'cus yo're generating code for a stack machine there instead.

[10:06] <moritz> I noticed :-)

[10:06] <jnthn> moritz: The slightly more interesting thing we could do with the optimization is set the position directly to what index returns, in the success case :)

[10:06] *** berekuk joined
[10:06] <moritz> jnthn: I do, don't I?

[10:06] <jnthn> i dunno, I didn't drink enough coffee yet to read code proper :P

[10:06] <moritz> pos = index tgt, literal, pos

[10:07] <moritz> $ops.push_pirop('index', %*REG<pos>, %*REG<tgt>, self.rxescape($node[0]), %*REG<pos>);

[10:07] <jnthn> You are completely right. Sorry.

[10:08] <moritz> ... and it segfaults while building NQPP5QRegex.moarvm

[10:08] <moritz> no problem

[10:08] <jnthn> Oh...one other idea too...if the first thing in the regex is a ^ anchor (bos) then I think that means we can entirely skip emitting the scan?

[10:08] *** cognominal left
[10:09] <moritz> aye

[10:11] *** cfa joined
[10:13] *** risou is now known as risou_awy

[10:20] *** zakharyas joined
[10:21] *** PacoAir joined
[10:32] *** integral left
[10:35] *** muixirt left
[10:37] *** spider-mario left
[10:38] *** dmol joined
[10:39] *** xenoterracide left
[10:41] <BinGOs> ./win 58

[10:43] <jnthn> Congratulations! You have won 58!

[10:47] *** darutoko left
[10:49] *** zakharyas left
[10:53] <GlitchMr> sub MAIN(Int $argument) { say "Congratulations! You have won $argument!" }

[10:57] *** berekuk left
[11:00] <moritz> with http://moritz.faui2k3.org/tmp/moarvm-index-scan.patch I get "At Frame 23, Instruction 36, op 'index_s', operand 2, expected MAST::Local, but didn't get one"

[11:00] <moritz> how do I fix that?

[11:00] *** iSlug joined
[11:00] <moritz> do I first need to assign the sval to an register?

[11:05] *** darutoko joined
[11:05] <jnthn> Yes

[11:06] <jnthn> Which you can get with fresh_s or so

[11:08] <moritz> and what#s the op for setting it?

[11:08] <moritz> *what's

[11:08] *** dansamo joined
[11:08] <jnthn> set

[11:09] <moritz> takk

[11:09] <jnthn> oh, sorry

[11:09] <jnthn> const_s

[11:09] <jnthn> set is register => register

[11:09] <jnthn> And it's got a generic signature... set w(`1) r(`1) or so

[11:15] *** nyuszika7h left
[11:15] *** nyuszika7h joined
[11:17] *** berekuk joined
[11:20] *** denis_boyun left
[11:28] *** isBEKaml joined
[11:28] *** pippo joined
[11:33] *** sniz left
[11:36] *** hummeleB1 joined
[11:37] *** rindolf left
[11:38] *** Rotwang joined
[11:46] *** spider-mario joined
[11:48] *** LWA left
[11:49] *** iSlug left
[11:51] *** berekuk left
[11:56] <moritz> \o/ tests pass

[11:57] <jnthn> \o/

[12:00] <colomon> \o/

[12:00] <dalek> nqp: 8dacbf6 | moritz++ | src/vm/moar/QAST/QASTRegexCompilerMAST.nqp:

[12:00] <dalek> nqp: [MoarVM] use index to speed up scanning in regexes

[12:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8dacbf60a5

[12:02] <isBEKaml> moritz++!

[12:02] <isBEKaml> wait, nqp now has a moarvm backend? THAT's awesome!

[12:02] <isBEKaml> \o/

[12:02] <moritz> :-)

[12:02] *** grondilu joined
[12:02] <moritz> it is

[12:03] <jnthn> Yes, was in this month's NQP release :)

[12:04] <isBEKaml> jnthn: great news! 

[12:04] <jnthn> Yes, it's nice to be making progress :)

[12:04] <isBEKaml> how do I build it? as in, how do I turn it on? any specific configuration?

[12:05] <jnthn> At the moment, you build a MoarVM, configuring with some --prefix for installation, and make install it. Then run ConfigureMoar.pl with that same --prefix in the NQP repo.

[12:05] <jnthn> moritz++ is working on a more unified configure process at the moment :)

[12:05] <moritz> well, build process first ._)

[12:06] <jnthn> :)

[12:07] <isBEKaml> jnthn: I see, that's how I build parrot, nqp and rakudo on my linux vm. No biggie. :-)

[12:07] <grondilu> in https://github.com/edumentab/rakudo-and-nqp-internals-course/blob/master/src/slides-day1.md, section Roles (2), isn't there an infinite recursion?  method set_compile_time_value($value) { self.HOW.mixin(self, QAST::CompileTimeValue); self.set_compile_time_value($value);

[12:07] <grondilu> }

[12:08] <isBEKaml> grondilu: your text ran right off my screen. :)

[12:08] <jnthn> grondilu: Nope

[12:08] *** berekuk joined
[12:08] <jnthn> grondilu: QAST::CompileTimeValue mixes in a method set_compile_time_value

[12:08] <jnthn> grondilu: Which we then call

[12:09] <grondilu> ok

[12:16] <lizmat> github: 12:07 UTCMajor service outage.

[12:16] <arnsholt> Hello on a plane o/

[12:17] <lizmat> arnsholt o/

[12:18] <jnthn> o/ lizmat 

[12:19] <lizmat> jnthn /o

[12:19] <isBEKaml> lizmat: yeah, was just looking at it :(

[12:19] <lizmat> sort of back, but not in rhythm yet

[12:19] <isBEKaml> github.com/perl6 gave me a 500 error

[12:19] *** darutoko- joined
[12:19] * lizmat that is

[12:19] <jnthn> lizmat: I'm only back for a day...

[12:20] * lizmat had a much more stressful vacation to deal with :-)

[12:20] <lizmat> nothing as easy as teaching :-)

[12:21] <isBEKaml> lizmat: vacations are.... stressful? 

[12:21] *** darutoko left
[12:28] <jnthn> lizmat: Turns out the most stressful bit of it was nearly missing a flight. ;) Teaching went fine. ))

[12:28] *** denis_boyun joined
[12:28] <jnthn> 'tis tiring, though...

[12:31] <lizmat> isBEKaml: yes, very stressful  :-)

[12:37] *** dansamo left
[12:38] *** integral joined
[12:40] *** dansamo joined
[12:41] <lizmat> github seems up again

[12:41] *** denis_boyun left
[12:41] <jnthn> yeah, I just pash 

[12:42] <lizmat> .oO( past tense of push ?)

[12:43] <jnthn> Aye :)

[12:57] *** sftp left
[13:00] *** sftp joined
[13:01] <isBEKaml> lizmat: well, AFAIHS, you're the first person to say so. :-) I thought vacations were all about relaxing. 

[13:02] * lizmat is not the person to lay on the beach, that may have something to do with it  :-)

[13:03] *** LWA joined
[13:06] *** diakopter left
[13:11] *** denisboyun joined
[13:18] *** denisboyun left
[13:28] <dalek> nqp/ext: a27e079 | jnthn++ | src/vm/moar/stage0/ (9 files):

[13:28] <dalek> nqp/ext: Get a stage0 with extop support.

[13:28] <dalek> nqp/ext: 

[13:28] <dalek> nqp/ext: Bump really needed due to bytecode format change.

[13:28] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/a27e07986e

[13:28] <dalek> nqp/ext: 17304ea | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[13:28] <dalek> nqp/ext: First pass at QAST->MAST extop updates.

[13:28] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/17304ea245

[13:43] *** isBEKaml left
[13:45] *** berekuk left
[13:50] *** berekuk joined
[13:51] *** berekuk left
[13:52] *** anocelot joined
[13:52] *** diakopter joined
[14:21] *** rindolf joined
[14:27] *** cognominal joined
[14:27] *** FROGGS left
[14:35] *** colomon left
[14:42] *** FROGGS joined
[14:48] *** colomon joined
[14:52] *** LWA left
[14:57] *** pecastro left
[14:57] <pippo> r: say "one, two, three" ~~ /\w+ +% ','/

[14:57] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/1diO3UXr7b␤Quantifier quantifies nothing␤at /tmp/1diO3UXr7b:1␤------> say "one, two, three" ~~ /\w+ +% ','⏏/␤    expecting any of:␤        postfix␤        infix stopper…»

[14:58] <pippo> r: say "one, two, three" ~~ /(\w+) +% ','/

[14:58] <camelia> rakudo 455467: OUTPUT«｢one｣␤ 0 => ｢one｣␤␤»

[14:59] *** pippo left
[15:02] *** benabik left
[15:04] *** hummeleB1 left
[15:05] <dalek> nqp/ext: 1debcdc | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[15:05] <dalek> nqp/ext: Correct emit MAST::ExtOp where needed.

[15:05] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/1debcdc55d

[15:05] *** denis_boyun joined
[15:09] <masak> today's autopun spotting: https://twitter.com/geofft/status/391248386298753025

[15:10] <jnthn> :P

[15:10] *** denis_boyun left
[15:14] <dalek> nqp/ext: 8b420c8 | jnthn++ | src/vm/moar/QAST/QASTCompilerMAST.nqp:

[15:14] <dalek> nqp/ext: Pass MAST::ExtOp type to assembler.

[15:14] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/8b420c8987

[15:18] *** pippo joined
[15:18] <pippo> rn: say "foo, barbarbar, foo" ~~ /:s (\w+)+ % ','

[15:18] <camelia> rakudo 455467: OUTPUT«===SORRY!=== Error while compiling /tmp/pci67Hvoxl␤Regex not terminated␤at /tmp/pci67Hvoxl:1␤------> foo, barbarbar, foo" ~~ /:s (\w+)+ % ','⏏<EOL>␤    expecting any of:␤        postfix␤        infix stopper␤…»

[15:18] <camelia> ..niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Regex not terminated at /tmp/wDMe9AHQxd line 1 (EOF):␤------> foo, barbarbar, foo" ~~ /:s (\w+)+ % ','⏏<EOL>␤␤Parse failed␤␤»

[15:18] <pippo> rn: say "foo, barbarbar, foo" ~~ /:s (\w+)+ % ','/

[15:18] <camelia> niecza v24-98-g473bd20: OUTPUT«｢foo, barbarbar, foo｣␤ 0 => ｢foo｣␤ 0 => ｢barbarbar｣␤ 0 => ｢foo｣␤␤»

[15:18] <camelia> ..rakudo 455467: OUTPUT«｢foo｣␤ 0 => ｢foo｣␤␤»

[15:21] <dalek> rakudo/moar-support: 33ece31 | jnthn++ | src/vm/moar/Perl6/Ops.nqp:

[15:21] <dalek> rakudo/moar-support: Start filling out MoarVM's Perl6::Ops.

[15:21] <dalek> rakudo/moar-support: 

[15:21] <dalek> rakudo/moar-support: When build with ext branches of MoarVM and NQP, we now reach trying to

[15:21] <dalek> rakudo/moar-support: compile the MOP in the build.

[15:21] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/33ece31c71

[15:23] *** PZt left
[15:23] *** pippo left
[15:39] *** ajr joined
[15:39] *** ajr is now known as Guest82861

[15:40] *** Guest82861 is now known as ajr_

[15:42] *** kaare_ joined
[15:47] *** ajr_ left
[15:49] *** ajr_ joined
[15:51] *** colomon left
[15:51] <dalek> rakudo/moar-support: efc9a5b | jnthn++ | src/vm/moar/Perl6/Ops.nqp:

[15:51] <dalek> rakudo/moar-support: First pass at nqp::p6bool compilation.

[15:51] <dalek> rakudo/moar-support: 

[15:51] <dalek> rakudo/moar-support: Untested, but should be fairly close.

[15:51] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/efc9a5bfde

[15:51] *** PZt joined
[15:52] *** colomon joined
[15:52] *** PZt left
[15:54] <arnsholt> "Dealing internally with different time zones is like having some numbers represented internally as decimal and some as hex." -MJD, laying down the law =)

[16:01] *** ajr_ left
[16:01] *** ajr__ joined
[16:01] *** PZt joined
[16:03] <colomon> in the old days we used decimal and hex together and liked it. 

[16:04] <colomon> ;)

[16:07] *** denis_boyun joined
[16:09] <colomon> really BCD and binary, but whatever.

[16:10] *** raiph joined
[16:13] <arnsholt> Oh, right. I have actually heard about BCD, at least

[16:14] <arnsholt> But I was amused to see a link on HN where someone wondered what A: and B: on Windows were for, though =D

[16:14] <nwc10> and it all ends in tears^Wcode thinkg that 2010 is a leap tear.

[16:14] <geekosaur> COBOL DISPLAY >.>

[16:14] <nwc10> (ish-  this link is slow and laggy)

[16:15] <jnthn> Does a leap tear happen once every 4 times you cry?

[16:24] <timotimo> arnsholt: B: was for old-timey-floppies, right?

[16:25] <geekosaur> hey now, I have a machine with a floppy drive at my feet :p

[16:25] <timotimo> you rest your feet on it?

[16:25] <geekosaur> (granted, it's ancient hardware repurposed as a vpn appliance..)

[16:26] *** mtk left
[16:26] <timotimo> huh? vpn needs some crypto performance to work properly ... a device that features a floppy-floppy-disk-drive would be able to handle like 512 bytes per second ... or something?

[16:27] <geekosaur> it's nto quite *that* bad

[16:27] <timotimo> does it have three-digits megahertz speed?

[16:27] <arnsholt> timotimo: Well, A: for the first floppy drive and B: for the second one =)

[16:27] <geekosaur> haven't checked

[16:27] <geekosaur> as I said, "appliance" --- not supposed to be able to log in to it

[16:31] <nwc10> B: for the second, real or emulated.

[16:33] *** pmurias_ joined
[16:33] *** pmurias_ is now known as pmurias

[16:34] * jnthn never owned a machine with a B: :)

[16:34] <geekosaur> ok, managed to get at the model number without disconnecting anything from it or dropping the vpn; 2.6ghz

[16:34] * colomon did professional work on machines that had an A: and a B: but no C:

[16:34] <geekosaur> perhaps more telling is the front says "hp compaq" :p

[16:35] <dalek> nqp/ext: 59a4b99 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[16:35] <dalek> nqp/ext: Map nqp::settypecheckmode.

[16:35] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/59a4b9996f

[16:36] <pmurias> should the op docs from t/nativecall/01-basic.t be moved to docs/ops.markdown?

[16:36] *** mtk joined
[16:36] <jnthn> pmurias: That would seem reasonable.

[16:39] *** dmol left
[16:41] *** dmol joined
[16:55] *** dmol left
[16:56] *** mtk left
[16:57] <dalek> nqp/ext: b418626 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[16:57] <dalek> nqp/ext: Map nqp::setdispatcher for MoarVM.

[16:57] <dalek> nqp/ext: 

[16:57] <dalek> nqp/ext: nqp::takedispatcher needs more work; it's not a straight mapping.

[16:57] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/b41862674e

[17:02] <lue> hello world o/

[17:05] <jnthn> hellue! o/

[17:07] <dalek> rakudo/moar-support: a27e243 | jnthn++ | src/vm/moar/Perl6/Ops.nqp:

[17:07] <dalek> rakudo/moar-support: Add some more p6 op mappings.

[17:07] <dalek> rakudo/moar-support: 

[17:07] <dalek> rakudo/moar-support: Not implemented yet, just get us further into compiling BOOTSTRAP.

[17:07] <dalek> rakudo/moar-support: review: https://github.com/rakudo/rakudo/commit/a27e243936

[17:09] *** mtk joined
[17:11] *** sniz joined
[17:12] <arnsholt> jnthn: What's the JVM things to look up methods and such, corresponding to VTABLE_find_method on Parrot?

[17:12] *** dayangkun left
[17:13] <jnthn> Ops.findmethod or so

[17:15] <arnsholt> That looks promising, yeah. Cheers!

[17:20] <colomon> arnsholt++

[17:23] *** sniz left
[17:28] *** dansamo left
[17:33] <dalek> nqp/ext: aff0f08 | jnthn++ | src/vm/moar/QAST/QASTOperationsMAST.nqp:

[17:33] <dalek> nqp/ext: Map captureexistsnamed/capturehasnameds on MoarVM.

[17:33] <dalek> nqp/ext: review: https://github.com/perl6/nqp/commit/aff0f08b0a

[17:46] <FROGGS> ohh nice!

[17:46] <FROGGS> jnthn++ # :D

[17:46] *** rindolf left
[17:46] <jnthn> FROGGS: Oh hi...want a task? :D

[17:47] *** skids joined
[17:48] <FROGGS> jnthn: sure!

[17:50] <jnthn> FROGGS: We need to be able to build a so/dll for the Perl 6 ext ops

[17:50] <FROGGS> hmmm, okay

[17:50] <jnthn> FROGGS: That probably means we should install a thingy to do it...

[17:50] <jnthn> FROGGS: Or make the info available to do it

[17:50] <jnthn> FROGGS: Like, the cc and link invocation lines

[17:51] <FROGGS> so, we need something like moar-config --libs and --cflags?

[17:51] <jnthn> Well, don't think we need a separate app

[17:51] <jnthn> I mean, if we can make nqp --show-config spit out the right stuff...

[17:51] <FROGGS> right, just talking about what usually is there

[17:52] <jnthn> Then we can simply use that.

[17:52] <jnthn> Anyway, yeah, it's that kinda info

[17:52] <FROGGS> hmmm, interesting task

[17:53] <jnthn> I'm gonna be a bit occupied the next several days, but it's what Rakudo on Moar is blocking on 

[17:53] <jnthn> So it's a nice one to delegate :)

[17:54] <FROGGS> k

[17:54] <FROGGS> btw, nqp/ext is intended to be buildable?

[17:54] <jnthn> Yeah...needs moar/ext too though

[17:55] <FROGGS> ahh

[17:55] <FROGGS> 3rdparty/dyncall/dynload/libdynload_s.a(dynload.o): In function `dlLoadLibrary':

[17:55] <FROGGS> /home/froggs/dev/MoarVM/3rdparty/dyncall/dynload/dynload_unix.c:43: undefined reference to `dlopen'

[17:55] <FROGGS> looks like my submodules are busted

[17:56] <arnsholt> Actually, nwc10 reported that just now

[17:56] <arnsholt> Probably a missing -ldl in a Makefile

[17:57] <arnsholt> (Reported it over in #moarvm, that is)

[17:57] <jnthn> Yeah, looking at that...

[17:57] <jnthn> Wonder why it build for not_gerd...

[17:59] *** FROGGS left
[18:00] <moritz> heisen-ldl

[18:12] * lue read moritz++ 's blog post and refrains from making a useless comment to boot.

[18:15] <japhb__> moritz: in your scan blog post, the paragraph beginning "Inside the loop", there's a confusing typo: '%*REG<cur>' should be '%*REG<pos>'.  (Also, remove the fourth word of the paragraph, but I only noticed that because I reread the paragraph a couple times trying to figure out what I wasn't understanding.)

[18:17] *** FROGGS joined
[18:17] <moritz> japhb__: thanks, fixed

[18:18] <moritz> std: my $a .= ++; say $a

[18:18] <camelia> std a0bcfb1: OUTPUT«ok 00:01 123m␤»

[18:18] <moritz> n: my $a .= ++; say $a

[18:18] <camelia> niecza v24-98-g473bd20: OUTPUT«0␤»

[18:21] *** spider-mario left
[18:23] <grondilu> I'm surprised that my $a .= ++ is ok.  doesn't .= expect a term in the RHS?

[18:24] <grondilu> hum no, I get it. ignore this^

[18:26] <moritz> ftr .= accepts a postfixish, of which a method name is the most common case (and which rakudo implements)

[18:30] <lue> what was the method form for prefixes again?

[18:30] <lue> .:<++> right?

[18:32] <moritz> r: class A { has ($.x, $.y) }; say A.new(x => 1, y => 2).perl

[18:32] <camelia> rakudo 455467: OUTPUT«A.new(x => 1, y => 2)␤»

[18:33] <arnsholt> Arg, barg. I hate it when golfing a bug makes it go away

[18:36] <arnsholt> Hah. Intuition strikes gold :3

[18:40] *** darutoko- left
[18:42] <arnsholt> jnthn: Golfed version of the role mixin problem I talked about a while back: https://gist.github.com/arnsholt/7059777

[18:43] <arnsholt> For some reason the role having an attribute breaks things. The derived JVM type inheriting from the wrong type or something like that?

[18:45] <pmurias> japhb__: what does declaration_static do?

[18:46] <pmurias> japhb__: sorry meant jnthn

[18:46] <japhb__> pmurias: I had a feeling ... :-)

[18:46] <pmurias> jnthn: what does declaration_static do?

[18:47] <arnsholt> jnthn: Oh, and changing the order of the traits on the sub also fixes it

[18:53] * japhb__ tries yet another angle on fixing this panda NFS problem

[18:54] <japhb__> .oO( "Once more unto the breach ..." )

[18:54] <arnsholt> Oh, NFS. Joy =)

[18:55] <japhb__> Yeah, that's one way of putting it.  >.<

[18:58] <arnsholt> I've thankfully not had any problems with our University's home-directories, but I've a friend who is full of NFS-related rants =)

[19:10] <diakopter> .

[19:10] <yoleaux> 18 Oct 2013 18:30Z <PerlJam> diakopter: Stop twiddling the bot and get back to work!  :)

[19:11] <dalek> Heuristic branch merge: pushed 25 commits to evalbot by moritz

[19:12] *** xenoterracide joined
[19:12] <moritz> I've just merged host07 into master, and switched camelia to use that branch

[19:12] <moritz> no functional changes

[19:14] <diakopter> rm: say('hi from rakudo on moar')

[19:15] <moritz> rm -rf!

[19:21] <jnthn> arnsholt: I wonder if it's the JVM backing type caching going wrong.

[19:22] <jnthn> pmurias: It means that we capture the outer of the static code object.

[19:22] <jnthn> pmurias: As opposed to assuming a clone.

[19:23] <jnthn> pmurias: Used for methods, for example

[19:23] <arnsholt> Ah, right

[19:24] <arnsholt> I was really mystified when the test script for a similar bug in the Parrot backend worked as it was supposed to =)

[19:25] <jnthn> Take a look into inline_description and box_description

[19:25] <jnthn> I never quite grokked them but I would not be surprised if they need implementing properly somewhere...

[19:27] *** Rotwang left
[19:31] <diakopter> heh, extops with label operands

[19:31] <arnsholt> jnthn: I guess that makes it P6Opaque.installJVMType? {box,inline}_description themselves don't seem to do much

[19:31] <diakopter> *giggle*

[19:31] *** berekuk joined
[19:35] <jnthn> arnsholt: Well, I guess they get called?

[19:37] <arnsholt> Yeah, in installJVMType

[19:40] <diakopter> jnthn: line 82 of roots.c

[19:40] <arnsholt> Just your comment that you didn't grok them made me expect the methods to be something significant

[19:40] <diakopter> is that a pointer pointer?

[19:41] <diakopter> yes, nm.

[19:42] *** SamuraiJack joined
[19:43] *** Rotwang joined
[19:45] <diakopter> jnthn: where's the thing to register new reprs

[19:45] *** jeccer_ joined
[19:46] <jeccer_> is this a good channel for a perl beginner to ask a question?

[19:48] <diakopter> yes, but the answer to the question may be: "yes, but the answer to the question may be: "yes, but the answer to the question may be: "yes, but the answer to the question may be: "yes, but the answer to the question may be: "yes, but the answer to the question may be............

[19:48] <jeccer_> Interesting

[19:48] <arnsholt> Also, we talk about Perl 6

[19:48] <arnsholt> Which is probably not what you want

[19:49] <arnsholt> #perl is likely more relevant

[19:49] <jeccer_> Ok thanks, I'll look for the Perl channel then

[19:49] <jeccer_> ty

[19:49] *** jeccer_ left
[19:50] *** kurahaupo joined
[19:58] <jnthn> diakopter: in reprs.c prolly

[20:00] <diakopter> no I mean I thought gerd added something to do it at runtime or something

[20:05] *** raiph left
[20:06] <jnthn> Oh...I thouught there was a dyn repr thing too

[20:06] <jnthn> yeha, there it is.

[20:06] <jnthn> MVM_repr_register_dynamic_repr

[20:07] *** kurahaupo left
[20:09] <arnsholt> jnthn: I've no idea what's going on with my bug. I'll try to give it another whack tomorrow. But the methods associated with a class and its backing type are mostly separate, no?

[20:09] <jnthn> arnsholt: Correct

[20:09] <jnthn> arnsholt: The backing type is all about the attributes

[20:10] <arnsholt> Yeah, that's what I thought

[20:10] <arnsholt> Which piece of the puzzle keeps track of the methods?

[20:10] <jnthn> The method cache hanging off the STable initially

[20:10] <jnthn> er, typically I mean

[20:10] <jnthn> It may then fall back to calling find_method on the meta-object but that's unusual

[20:10] <jnthn> e.g. you gotta have a special situation for it.

[20:11] <jnthn> Like handle * or so

[20:11] <jnthn> *handles

[20:11] <arnsholt> Yeah

[20:11] <arnsholt> So in this case it'll be hanging off the STable

[20:11] <jnthn> method cahce does, yeah

[20:11] <jnthn> changetype switches the st

[20:12] <jnthn> That's the only place where an object ever changes its type.

[20:13] *** benabik joined
[20:13] <arnsholt> Excellent. Then I have a couple more places to pick at this problem tomorrow

[20:14] *** SamuraiJack left
[20:17] *** Mouq joined
[20:19] <arnsholt> Hah! Found it

[20:19] <arnsholt> Forcing P6Opaque.change_type to always create a delegate fixes the problem

[20:19] <arnsholt> Figuring out how to fix it can wait 'till tomorrow

[20:20] <TimToady> http://rosettacode.org/wiki/Zhang-Suen_thinning_algorithm#Perl_6

[20:21] <jnthn> arnsholt++

[20:23] <TimToady> gah, shoulda used gather/take; push is a smell

[20:24] <colomon> smells like victory!

[20:25] <jnthn> There's some meta-op use :)

[20:27] <TimToady> fixed

[20:27] <TimToady> r: my \neighbors = <a b c d e f g h>; say neighbors.rotate

[20:27] <camelia> rakudo 455467: OUTPUT«No such method 'rotate' for invocant of type 'Parcel'␤  in block  at /tmp/V7qktYmTaa:1␤␤»

[20:28] <TimToady> r: my \neighbors = <a b c d e f g h>; say neighbors[].rotate

[20:28] <camelia> rakudo 455467: OUTPUT«b c d e f g h a␤»

[20:28] <TimToady> a bug, methinks

[20:28] <TimToady> n: my \neighbors = <a b c d e f g h>; say neighbors.rotate

[20:28] <camelia> niecza v24-98-g473bd20: OUTPUT«b c d e f g h a␤»

[20:28] <TimToady> niecza can rotate a parcel

[20:28] <TimToady> n: my \neighbors = <a b c d e f g h>; say neighbors.rotate.WHAT

[20:28] <camelia> niecza v24-98-g473bd20: OUTPUT«(Parcel)␤»

[20:28] <TimToady> it even stays a parcel :)

[20:29] <TimToady> rakudo has to listify the Parcel before it can rotate it, which is suboptimal

[20:33] *** sizz_ left
[20:35] *** benabik left
[20:36] *** sizz joined
[20:38] *** Gothmog_ left
[20:38] *** Gothmog_ joined
[20:39] <Mouq> r: sub rotate(Positional \p) {(p.WHAT)( p[].rotate )}; my \neighbors = <a b c d e f g h>; say rotate(neighbors).WHAT

[20:39] <camelia> rakudo 455467: OUTPUT«(Parcel)␤»

[20:39] <Mouq> r: sub rotate(Positional \p) {(p.WHAT)( p[].rotate )}; my \neighbors = [<a b c d e f g h>]; say rotate(neighbors).WHAT

[20:39] <camelia> rakudo 455467: OUTPUT«(Array)␤»

[20:44] <japhb__> Oooh, I forgot about 'repeat while' together at the top of the loop

[20:53] *** kaare_ left
[20:54] *** ajr__ left
[20:59] *** berekuk left
[21:00] <japhb__> Is the logic in IO::Handle.close() at line 116 of src/core/IO.pm correct?  Instead of checking $!PIO with nqp::istrue, shouldn't it be checked with nqp::isconcrete?

[21:02] <japhb__> (For context, I'm tracking down a problem in which a filehandle is closed in Perl 6 code, but lsof shows the file is still open, sometimes.  My current reading is that sometimes line 116 decides not to nqp::closefh when it should, and then we fall back to when garbage collection gets around to closing the underlying PIO after it is turned into garbage by line 117.)

[21:05] <Mouq> japhb__: That's what it looks like to me too, considering that it's set to a type object right after that line. Other places do use nqp::isdefined in IO::Handle, although method opened(){} doesn't

[21:05] <Mouq> *nqp::isdefined($!PIO)

[21:06] <jnthn> japhb__: Hmm...

[21:06] <jnthn> japhb__: I know that on Parrot, true/false on a file handle PMC is open/closed

[21:06] <jnthn> japhb__: I wonder if that's also true of JVM.

[21:07] <jnthn> japhb__: Maybe that's the problem...

[21:07] <jnthn> (I'm assuming you're on the JVM here.)

[21:07] <jnthn> But if it sets it to the type object on closing then the test should still work

[21:07] <jnthn> since a type object is always false, an an instance is by default true...

[21:11] <lue> TimToady: I am shocked you didn't take advantage of a prime opportunity to use unicode. :)

[21:11] <japhb__> Hmmm.  jnthn, will trying to close an already-closed filehandle PMC blow up on parrot?

[21:11] <japhb__> Actually, will it on any backend?

[21:13] <japhb__> Then I'll just go with nqp::isdefined (nqp::isconcrete is only for SMOs, isn't it?), and risk sometimes telling the backend to close a file handle that had already been closed behind Rakudo's back.

[21:13] <japhb__> (And thanks Mouq++ for pointing out nqp::isdefined)

[21:14] <jnthn> japhb__: I dunno without trying it

[21:15] <japhb__> OK, I'm going to try that patch, rebuild and see if tests go kablooey.

[21:16] *** bruges joined
[21:17] *** ggoebel8 joined
[21:18] *** bruges_ left
[21:21] *** ggoebel7 left
[21:23] *** ggoebel9 joined
[21:27] *** pmurias left
[21:27] *** ggoebel8 left
[21:32] *** woolfy left
[21:34] *** woolfy joined
[21:52] *** raiph joined
[21:54] *** Rotwang left
[21:56] *** PacoAir left
[22:05] *** LWA joined
[22:07] *** grondilu left
[22:15] *** denis_boyun left
[22:20] <dalek> panda: d8b4f4f | (Geoffrey Broadwell)++ | lib/Panda/ (2 files):

[22:20] <dalek> panda: Make sure we .close after every open

[22:20] <dalek> panda: review: https://github.com/tadzik/panda/commit/d8b4f4f12d

[22:24] <dalek> rakudo/nom: e55c66b | (Geoffrey Broadwell)++ | src/core/IO.pm:

[22:24] <dalek> rakudo/nom: Fix intermittent delayed closure of the VM-level file handle in IO::Handle.close()

[22:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e55c66bc02

[22:35] <dalek> nqp: 1f1544a | dwarring++ | examples/rubyish/ (5 files):

[22:35] <dalek> nqp: add rubyish <=> cmp ops. refined .call syntax

[22:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1f1544a408

[22:50] <dalek> perl6-most-wanted: 1c5ba0b | (Andrew Egeler)++ | most-wanted/modules.md:

[22:50] <dalek> perl6-most-wanted: Update modules.md

[22:50] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/1c5ba0bd98

[22:57] <japhb__> \o/  With the above fixes, panda bootstraps and installs additional modules on NFS with both the parrot and jvm backends!

[23:00] <jnthn> \o/

[23:00] <jnthn> japhb__++

[23:05] *** dmol joined
[23:06] <japhb__> While I was debugging that on rakudo-parrot I noticed something suboptimal: rakudo leaks open filehandles to subprocesses (e.g. when I shelled out to an 'lsof | grep' variant, lsof showed that sh, grep, and sh all held open the same file that perl6 did).

[23:07] <japhb__> er: ... sh, grep, and lsof all ...

[23:07] <japhb__> Of course, sometimes you want to do that, but I don't think that should be the default.

[23:09] <jnthn> japhb__: What are the Perl 5 semantics / way of deciding, ooc?

[23:17] <retupmoca> r: say "asdf".encode("ascii") ~~ Buf

[23:17] <camelia> rakudo e55c66: OUTPUT«False␤»

[23:17] <retupmoca> isn't Str.encode supposed to return a Buf?

[23:17] <retupmoca> or am I misunderstanding things?

[23:18] *** BenGoldberg joined
[23:18] <timotimo> r: say "yoink".decode("utf8").WHAT

[23:18] <camelia> rakudo e55c66: OUTPUT«No such method 'decode' for invocant of type 'Str'␤  in block  at /tmp/iFLXpoP8O_:1␤␤»

[23:18] <timotimo> r: say "yoink".encode("utf8").WHAT

[23:18] <camelia> rakudo e55c66: OUTPUT«(utf8)␤»

[23:18] <timotimo> r: say "yoink".encode("utf8") ~~ Buf

[23:18] <camelia> rakudo e55c66: OUTPUT«False␤»

[23:19] <BenGoldberg> r: utf8.^methods.say

[23:19] <camelia> rakudo e55c66: OUTPUT«decode encoding new elems bytes chars Numeric Int list subbuf unpack contents of Str at_pos Bool Stringy gist perl␤»

[23:19] <retupmoca> r: my Buf $x = "asdf".encode("utf-8"); say 1;

[23:20] <camelia> rakudo e55c66: OUTPUT«Type check failed in assignment to '$x'; expected 'Buf' but got 'utf8'␤  in block  at /tmp/To3NBksbsL:1␤␤»

[23:20] <timotimo> r: say utf8.^mro

[23:20] <camelia> rakudo e55c66: OUTPUT«(utf8) (Any) (Mu)␤»

[23:21] <BenGoldberg> Peculiar, it's not related to either Str or Buf

[23:21] <BenGoldberg> r: say Buf.mro

[23:21] <camelia> rakudo e55c66: OUTPUT«No such method 'mro' for invocant of type 'Buf'␤  in block  at /tmp/mWeiEyQLex:1␤␤»

[23:21] <BenGoldberg> r: say Buf.^mro

[23:21] <camelia> rakudo e55c66: OUTPUT«(Buf) (Any) (Mu)␤»

[23:21] <BenGoldberg> r: say Str.^mro

[23:21] <camelia> rakudo e55c66: OUTPUT«(Str) (Cool) (Any) (Mu)␤»

[23:22] <Mouq> Buf.pm: "my class utf8 does  Blob[uint8] is repr('VMArray') {..."

[23:23] <Mouq> r: buf8.^mro

[23:23] <camelia> rakudo e55c66: ( no output )

[23:23] <Mouq> r: buf8.^mro.say

[23:23] <camelia> rakudo e55c66: OUTPUT«(Buf[uint8]) (Any) (Mu)␤»

[23:24] <japhb__> jnthn: OK, checking.  perl -e 'open my $fh, "<", "test"; system "lsof | grep test"' does not leak the FH.  On parrot, perl6 -e 'my $fh = open "test"; shell "lsof | grep test"' leaks, but on jvm it does not.

[23:25] <BenGoldberg> r: say utf8 ~~ buf8

[23:25] <camelia> rakudo e55c66: OUTPUT«False␤»

[23:26] <BenGoldberg> r: say utf8 ~~ Blob[uint8]

[23:26] <camelia> rakudo e55c66: OUTPUT«True␤»

[23:26] <BenGoldberg> r: say Buf ~~ Blob[uint8]

[23:26] <retupmoca> n: say "asdf".encode("ascii") ~~ Buf

[23:26] <camelia> rakudo e55c66: OUTPUT«False␤»

[23:26] <camelia> niecza v24-98-g473bd20: OUTPUT«True␤»

[23:27] <BenGoldberg> r: say "asdf".encode('ascii').WHAT

[23:27] <camelia> rakudo e55c66: OUTPUT«(Blob[uint8])␤»

[23:27] <BenGoldberg> n: say "asdf".encode('ascii').WHAT

[23:27] <camelia> niecza v24-98-g473bd20: OUTPUT«(Buf)␤»

[23:28] *** jamie21 joined
[23:28] <timotimo> ah, blob, yeah. blob is immutable, so that's what corresponds to strings

[23:28] <jamie21> Hey room 

[23:29] <jamie21> :)

[23:29] *** jamie21 left
[23:30] <BenGoldberg> Why do we use the name blob, anyway? :)  ISTR that it stands for Binary Large OBject... but most of our blobs seem to be fairly small ;)

[23:30] <timotimo> at least they are binary

[23:31] <geekosaur> SQL has that meaning for them, but well before SQL there was the usage for random binary data that most stuff didn't care about the internal structure of

[23:33] <jnthn> japhb__: Ah, so Parrot is the odd one out there...

[23:34] <jnthn> re Blob vs. Buf, Blob is immutable

[23:34] <jnthn> And if we let you mutate a utf8 then you might make it invalid utf8 :)

[23:34] <BenGoldberg> geekosaur: Doesn't "opaque" fit that meaning better?

[23:35] <TimToady> .oO(Binary Little Object)

[23:35] * BenGoldberg laughs

[23:36] <BenGoldberg> Binary L-ambiguously-sized OBject

[23:38] *** pdurbin joined
[23:38] <geekosaur> formally yes, blob is informal

[23:38] <Mouq> BLOB's, Like, an Object that's Binary

[23:38] <geekosaur> and those of us used to the original meaning found SQL's adoption of a formal BLOB type to be quite amusing

[23:40] <BenGoldberg> rn: say "".encode('ascii')

[23:40] <camelia> rakudo e55c66: OUTPUT«Buf:0x<>␤»

[23:40] <camelia> ..niecza v24-98-g473bd20: OUTPUT«Buf.new(...)␤»

[23:40] <BenGoldberg> rn: say "".encode('ascii').WHAT

[23:40] <camelia> niecza v24-98-g473bd20: OUTPUT«(Buf)␤»

[23:40] <camelia> ..rakudo e55c66: OUTPUT«(Blob[uint8])␤»

[23:41] <BenGoldberg> While I don't have an opinion of whether Buf or Blob is more appropriate, I do think that we need to use the same type for all implementations.

[23:42] <BenGoldberg> Err, Str.encode needs to return the same type, for all implementations

[23:42] <BenGoldberg> Or at least, a compatible type

[23:43] <timotimo> yes. either spec work is necessary, or one or both of our implementations is diverging

[23:44] <retupmoca> afk &

[23:45] <Mouq> S32 says it should return a Blob

[23:45] <Mouq> r: "abcd".encode('UTF-8').WHAT.say

[23:46] <camelia> rakudo e55c66: OUTPUT«(utf8)␤»

[23:46] <BenGoldberg> Which is ok, since

[23:46] <BenGoldberg> r: utf8 ~~ Blob[unit8]

[23:46] <camelia> rakudo e55c66: OUTPUT«===SORRY!=== Error while compiling /tmp/jyJg0ef0KZ␤Undeclared routine:␤    unit8 used at line 1. Did you mean '&uniq'?␤␤»

[23:46] <BenGoldberg> r: utf8 ~~ Blob[uint8]

[23:46] <camelia> rakudo e55c66: ( no output )

[23:46] <BenGoldberg> r: say utf8 ~~ Blob[uint8]

[23:46] <camelia> rakudo e55c66: OUTPUT«True␤»

[23:47] <BenGoldberg> So rakudo does return a blob, even when it's returning a utf8

[23:47] <Mouq> BenGoldberg: The spec says explicitly that's (utf8) what it should be

[23:47] <BenGoldberg> And it

[23:47] <BenGoldberg> And it's niecza that's wrong :)

[23:49] *** dmol left
[23:51] *** berekuk joined
[23:52] <jnthn> Yeah, spec says return narrowest

[23:52] <jnthn> Note that Blob is a role, which is why it doesn't show up in .^mro

[23:52] <jnthn> Again, by spec.

[23:56] *** grondilu joined
