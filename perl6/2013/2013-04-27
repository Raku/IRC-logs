[00:05] <adu> lue: I'm assuming europe

[00:06] <lue> that'd be a correct assumption. But still :)

[00:10] *** jac50 left
[00:12] *** ifimbres joined
[00:16] *** gabriel_ joined
[00:26] *** tgt left
[00:30] *** japhb_ left
[00:39] *** ifimbres left
[00:39] *** kbenson left
[01:40] *** xinming left
[01:41] *** FROGGS_ joined
[01:44] *** FROGGS left
[01:54] *** xinming joined
[02:05] *** thou left
[02:12] *** tangentstorm left
[02:28] *** census left
[02:29] *** grondilu joined
[02:35] *** BenGoldberg left
[02:36] <colomon> rn: my %hash = a => 10, b => 12; say %hash.perl; %hash = { }; say %hash.perl;

[02:36] <camelia> niecza v24-37-gf9c8fc2: OUTPUT¬´{"a" => 10, "b" => 12}.hash‚ê§{}.hash‚ê§¬ª

[02:36] <camelia> ..rakudo 71ea14: OUTPUT¬´("a" => 10, "b" => 12).hash‚ê§().hash‚ê§¬ª

[02:36] <colomon> wot

[02:36] <colomon> er, woot

[02:41] *** orafu left
[02:41] *** orafu joined
[02:44] *** thou joined
[02:58] *** grondilu left
[03:06] *** adu left
[03:06] *** sizz left
[03:07] *** sizz joined
[03:08] <colomon> r: say "" X 9

[03:08] <camelia> rakudo 71ea14: OUTPUT¬´ 9‚ê§¬ª

[03:08] <colomon> r: say "" xx 9

[03:08] <camelia> rakudo 71ea14: OUTPUT¬´        ‚ê§¬ª

[03:08] <colomon> r: say ("" xx 9).perl

[03:08] <camelia> rakudo 71ea14: OUTPUT¬´("", "", "", "", "", "", "", "", "").list‚ê§¬ª

[03:08] <colomon> r: say ("" X 9).perl

[03:08] <camelia> rakudo 71ea14: OUTPUT¬´(("", 9),).list‚ê§¬ª

[03:16] *** sizz left
[03:17] *** sizz joined
[03:20] *** sizz left
[03:22] *** sizz joined
[03:41] *** sizz left
[03:46] *** sizz joined
[03:54] *** Vlavv_ left
[04:14] *** sizz left
[04:20] *** sizz joined
[04:20] *** rindolf joined
[04:20] *** thou left
[04:24] *** Psyche^ joined
[04:28] *** Patterner left
[04:28] *** Psyche^ is now known as Patterner

[04:42] *** lustlife joined
[04:53] *** rindolf left
[04:54] *** rindolf joined
[04:59] *** drbean left
[05:01] *** drbean joined
[05:14] *** xinming left
[05:15] *** xinming joined
[05:36] *** SamuraiJack joined
[05:38] *** adu joined
[05:41] <adu> ok, it's morning in europe

[05:47] *** rindolf left
[05:56] *** kaare_ joined
[05:56] *** rindolf joined
[06:12] *** kaare_ left
[06:16] *** thou joined
[06:27] *** rindolf left
[06:28] *** rindolf joined
[06:29] *** raiph left
[06:31] *** rindolf left
[06:31] *** rindolf joined
[06:37] *** araujo left
[06:37] *** rindolf left
[06:38] *** rindolf joined
[06:49] *** adu left
[07:01] *** fhelmberger joined
[07:26] *** Chillance joined
[07:37] *** aindilis joined
[07:44] *** fhelmberger left
[08:14] *** domidumont joined
[08:27] *** berekuk joined
[08:28] <masak> good morning, #perl6

[08:28] *** berekuk left
[08:30] <lizmat> morning masak!

[08:30] <lizmat> rn: my $a="foo"; { let $a= "bar"; say $a; leave }; say $a

[08:31] <camelia> niecza v24-37-gf9c8fc2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'leave' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ‚ê§  at /ho‚Ä¶

[08:31] <camelia> ..rakudo 71ea14: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§    leave used at line 1‚ê§‚ê§¬ª

[08:31] <lizmat> is this NYI or am I misunderstanding the spec?

[08:31] <lizmat> rn: my $a="foo"; { let $a= "bar"; say $a; fail }; say $a

[08:31] <camelia> niecza v24-37-gf9c8fc2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'fail' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ‚ê§  at /hom‚Ä¶

[08:31] <camelia> ..rakudo 71ea14: OUTPUT¬´bar‚ê§No exception handler and no message‚ê§‚ê§current instr.: 'throw' pc 358449 (src/gen/CORE.setting.pir:156428) (src/gen/CORE.setting:9557)‚ê§called from Sub 'sink' pc 390631 (src/gen/CORE.setting.pir:168922) (src/gen/CORE.setting:10839)‚ê§called from Sub 'MAIN' pc 381 (s‚Ä¶

[08:32] <lizmat> r: my $a="foo"; { let $a= "bar"; say $a; fail }; say $a

[08:32] <camelia> rakudo 71ea14: OUTPUT¬´bar‚ê§No exception handler and no message‚ê§‚ê§current instr.: 'throw' pc 358449 (src/gen/CORE.setting.pir:156428) (src/gen/CORE.setting:9557)‚ê§called from Sub 'sink' pc 390631 (src/gen/CORE.setting.pir:168922) (src/gen/CORE.setting:10839)‚ê§called from Sub 'MAIN' pc 381 (s‚Ä¶

[08:32] <masak> lizmat: "leave" is NYI, and I don't really understand why at this point. probably nobody got to putting it in, simply.

[08:33] <masak> lizmat: you can't fail if you're not in a routine.

[08:33] *** berekuk joined
[08:33] <lizmat> intriguing, it works ok in -e mode  :-)

[08:33] <masak> probably shouldn't.

[08:34] <lizmat> $ perl6 -e 'my $a="foo"; { let $a= "bar"; say $a; fail }; say $a'

[08:34] <lizmat> bar

[08:34] <lizmat> foo

[08:34] <masak> though the error "No exception handler and no message" is kinda weird, too.

[08:34] <timotimo> the REPL may catch the exception?

[08:34] <masak> that's not the REPL.

[08:34] <masak> that's -e

[08:34] <masak> lizmat: confirmed, works here too.

[08:35] <lizmat> could it be that "leave" is NYI because we don't have goto either?

[08:36] <timotimo> oh, right

[08:41] <masak> lizmat: I don't really see the relation.

[08:42] <masak> lizmat: "leave" is a call stack operation. "goto" is more of an IP operation.

[08:42] <lizmat> IP?

[08:42] <masak> at least in its simplest forms.

[08:42] <masak> Instruction Pointer

[08:42] <masak> "leave" is like a "return light".

[08:43] <lizmat> I guess the answer to my question is "no"  :-)

[08:43] *** thou left
[08:43] <lizmat> I can't seem to find much specced about "let"

[08:43] <masak> and a block is like a "routine light" :)

[08:43] <masak> lizmat: "temp" and "let" are woefully underspec'd.

[08:44] <shachaf> They're called leaves because they leave the trees in the fall. Which is why it's called fall.

[08:44] <lizmat> specifically what happens if you "let" a filehandle, then read a line from it and fail from the  block

[08:44] <lizmat> will it seek back to the original position?

[08:44] <lizmat> if so, what magic will make that happen?

[08:45] <lizmat> I hadn't realised it until now, but "let" is getting us into STM land, no?

[08:47] <masak> not that I know of.

[08:47] <masak> 'maybe {}' was meant to get us into STM land.

[08:48] *** domidumont left
[08:49] <lizmat> "let" is the "restore to previous state" part of STM

[08:49] *** domidumont joined
[08:49] <lizmat> not being interrupted in a block, is another part

[08:50] <lizmat> looking at S17, maybe "defer" should just simply be "fail" ?

[08:50] <masak> yeah.

[08:50] <masak> I can see the connection between "let" and "maybe" too.

[08:51] <masak> maybe that's actually all it takes to do optimistic concurrency.

[08:53] * lizmat shelves these concurrency for now and continues trying to grok S04

[08:53] <lizmat> rn: my $a="foo"; { temp undefine $a; say $a }; say $a

[08:53] <camelia> niecza v24-37-gf9c8fc2: OUTPUT¬´(Any)‚ê§(Any)‚ê§¬ª

[08:53] <camelia> ..rakudo 71ea14: OUTPUT¬´(Any)‚ê§Cannot assign to a readonly variable or a value‚ê§  in block  at /tmp/zOhG_oJm6Q:1‚ê§‚ê§¬ª

[08:54] * lizmat thinks both get it wrong

[08:54] <lizmat> I would have expected (Any) foo

[08:54] *** trexy_ joined
[08:56] <lizmat> masak: wrt to goto just being in IP operation: it could also involve stack operations if the label is in an OUTER block

[08:58] <masak> yes.

[08:58] <masak> my point was really that "leave" and "goto" aren't all that similar.

[08:59] <masak> "leave" is more like "return".

[08:59] <masak> lizmat: I think you're confusing "set the value of $a to what it was previously" and "destruct the object that was in $a".

[08:59] <masak> 'temp' does the former. not the latter.

[09:00] <masak> the GC does the latter, in due time. not on anyone's schedule.

[09:00] *** MrMeek-afk joined
[09:04] *** MrMeek left
[09:07] <lizmat> https://gist.github.com/lizmat/5472425

[09:08] <lizmat> I would expect some methods being called on the object if "temp" is done on it, and also when the scope is left

[09:08] <lizmat> but that's not specced, let alone implemented

[09:08] <lizmat> or is it?  as it apparently already works on scalars?

[09:09] <masak> I never thought of 'temp' as having this kind of semantics.

[09:09] <masak> maybe it does. I don't know.

[09:09] <masak> ask TimToady.

[09:09] *** SamuraiJack left
[09:10] *** dmol joined
[09:16] <lizmat> .invoke TimToady

[09:16] <lizmat> seen TimToady

[09:17] <lizmat> .seen TimToady

[09:17] <yoleaux> I saw TimToady 26 Apr 2013 23:40Z in #perl6: <TimToady> ask jnthn, I suppose

[09:17] <lizmat> :-)

[09:19] <masak> hehe

[09:19] *** spider-mario joined
[09:19] *** flussence joined
[09:21] <lizmat> masak: isn't this a rakudo bug?

[09:21] <lizmat> r: my $a="foo"; { temp undefine $a; say $a }; say $a

[09:22] <camelia> rakudo 71ea14: OUTPUT¬´(Any)‚ê§Cannot assign to a readonly variable or a value‚ê§  in block  at /tmp/lGIFzmiUSK:1‚ê§‚ê§¬ª

[09:23] <masak> huh.

[09:23] <masak> I... don't know. I think so.

[09:23] <masak> but I can't internalize what happens there.

[09:23] <masak> where does the "readonly" come from?

[09:23] <lizmat> r: my $a="foo"; { temp $a= (Any); say $a }; say $a

[09:23] <camelia> rakudo 71ea14: OUTPUT¬´(Any)‚ê§foo‚ê§¬ª

[09:24] <lizmat> seems like "undefine" is maybe doing more than it should

[09:24] <masak> yeah.

[09:24] * masak submits rakudobug

[09:41] *** frdmn left
[09:51] <masak> 20 signups for the workshop on Wednesday! \o/

[09:51] *** rindolf left
[09:51] <lizmat> :-)

[09:52] <masak> it was 13 three days ago when I blogged about it.

[09:52] <labster> hello #perl6

[09:52] <masak> labster! \o/

[09:52] <lizmat> hello labster!

[09:53] <labster> I just got File::Spec integrated into core.  Yak is now clean-shaven.

[09:54] <lizmat> nothing like a clean Yak

[09:55] <lizmat> it's the equivalent of a bikeshed in the right color

[09:56] * masak .oO( yakshedding )

[09:56] <lizmat> alas, afk for most of the day &

[09:58] <masak> &

[10:03] *** tgt joined
[10:06] *** jerome_ left
[10:14] *** frdmn joined
[10:21] *** tgt left
[10:22] *** xinming left
[10:23] *** xinming joined
[10:24] *** tgt joined
[10:34] <nwc10> for my non-representitive not-a-benchmark (but it is the same code):

[10:35] <nwc10> nqp-jvm: 1.4725e+02 +/- 7.2e-01

[10:35] <camelia> nqp-jvm: OUTPUT¬´Cannot unbox a type object‚ê§  in !LITERAL‚ê§  in stopper‚ê§  in <anon>‚ê§  in before‚ê§  in termish‚ê§  in termconj‚ê§  in termalt‚ê§  in termconjseq‚ê§  in termaltseq‚ê§  in nibbler‚ê§  in LANG‚ê§  in quote:sym</ />‚ê§  in !protoregex‚ê§  in quote‚ê§  in value‚ê§  in term:sym<value>‚ê§  in !protoregex‚ê§‚Ä¶

[10:35] <nwc10> nqp-parrot: 2.0425e+03 +/- 1.9e+00 (0.1%)

[10:43] *** PacoAir joined
[10:43] <jnthn> afternoon, #perl6

[10:46] <jnthn> temp undefine $a # iirc, temp is just a prefix, you're almost certainly going to undefine $a and then temporize it afterwards

[10:46] <jnthn> nwc10: I was like "huh, only a little difference", then noticed the +02 vs +03 :)

[10:47] *** tgt left
[11:02] *** tgt joined
[11:03] *** frdmn left
[11:03] *** frdmn joined
[11:05] <cognominal> writing a presentation, I noticed there are two other ways to write   / a | b /, one with a multi rules and the other with a argumentful rule :  https://gist.github.com/cognominal/5472705

[11:05] <cognominal> TIMTOWTDI

[11:05] *** jerome_ joined
[11:06] <jnthn> < a b > / is anothe way

[11:06] <jnthn> Though it desugars to / a | b /.

[11:06] <cognominal> Nice :)

[11:07] <cognominal> But my purpose was to introduce protorules and argumentful rules with the simplest possible example

[11:10] *** araujo joined
[11:10] *** araujo left
[11:10] *** araujo joined
[11:17] *** pdurbin joined
[11:18] <cognominal> the  argumentful form should have been written :  token char($char) { $char } ;  <char(a)> | <char(b)>

[11:19] <cognominal> or

[11:19] <cognominal> oops

[11:19] <cognominal> the  argumentful form should have been written :  token char($char) { $char } ;  <char('a')> | <char('b')>

[11:19] <cognominal> or

[11:20] <cognominal> token char($char) { $char } ;  <char('a'|'b')> # is that possible? modulo a good enough Perl 6 implementation

[11:20] <timotimo> are they already in rakduo?

[11:21] <cognominal> yes, except for the last one.

[11:21] <timotimo> argumentful rules i mean

[11:21] <timotimo> cool :)

[11:21] <jnthn> Tokens/rules can take arguments, but you're in the main language when you're passing them, not regex langauge.

[11:22] <jnthn> Using that syntax, anyway

[11:22] <cognominal> it shows how well rules are integrated with the language

[11:22] <timotimo> so you'd get a junction. will that autothread?

[11:22] <jnthn> So I guess you pass a junction... :)

[11:22] <jnthn> No, it will probably explode. :)

[11:22] <jnthn> Oh wait

[11:22] <jnthn> It probably auto-threads

[11:23] <jnthn> But then the grammar engine gets a junction of cursors back at which point it is probably extremely sad. :)

[11:23] <cognominal> good luck for the other languages stealing them this time

[11:23] <timotimo> r: (grammar :: { token char($char) { $char }; rule TOP { char('a' | 'b') }; }).parse("b")

[11:23] <camelia> rakudo 71ea14:  ( no output )

[11:23] <timotimo> r: (grammar :: { token char($char) { $char }; rule TOP { char('a' | 'b') }; }).parse("b").perl.say

[11:23] <camelia> rakudo 71ea14: OUTPUT¬´Match.new(orig => "b", from => 0, to => -3, ast => Any, list => ().list, hash => EnumMap.new())‚ê§¬ª

[11:23] <timotimo> r: (grammar :: { token char($char) { $char }; rule TOP { char('a' | 'b') }; }).parse("a").perl.say

[11:23] <camelia> rakudo 71ea14: OUTPUT¬´Match.new(orig => "a", from => 0, to => -3, ast => Any, list => ().list, hash => EnumMap.new())‚ê§¬ª

[11:23] <timotimo> well, there's that!

[11:23] <timotimo> from 0 to -3, eh?

[11:24] <jnthn> timotimo: You need <char('a' | 'b')> to make a call :)

[11:24] <timotimo> uh, that's right

[11:24] <timotimo> r: (grammar :: { token char($char) { $char }; rule TOP { <char('a' | 'b')> }; }).parse("a").perl.say

[11:24] <camelia> rakudo 71ea14: OUTPUT¬´Can not get attribute '$!pos' declared in class 'Cursor' with this object‚ê§  in regex TOP at /tmp/SIUOHFu8ZR:1‚ê§  in method parse at src/gen/CORE.setting:11162‚ê§  in block  at /tmp/SIUOHFu8ZR:1‚ê§‚ê§¬ª

[11:24] *** pdurbin left
[11:24] <timotimo> "this" object being the junction object that gets passed perhaps?

[11:25] <jnthn> I expect so, yes

[11:26] <jnthn> r: (grammar :: { token char($char) { $char }; rule TOP { <char 'a' | 'b'> }; }).parse("a").perl.say

[11:26] <camelia> rakudo 71ea14: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$char'‚ê§  in regex char at /tmp/h1WhlQcmtB:1‚ê§  in regex TOP at /tmp/h1WhlQcmtB:1‚ê§  in method parse at src/gen/CORE.setting:11162‚ê§  in block  at /tmp/h1WhlQcmtB:1‚ê§‚ê§¬ª

[11:26] <jnthn> Whoa

[11:29] <lizmat> jnthn: temp undefine $x is directly lifted from spec

[11:29] <cognominal> anyway, nothing precludes in theory the grammar engine handling cursors junctions?

[11:29] <lizmat> rn: my $a="foo"; { undefine temp $a; say $a }; say $a

[11:29] <camelia> rakudo 71ea14, niecza v24-37-gf9c8fc2: OUTPUT¬´(Any)‚ê§foo‚ê§¬ª

[11:29] <lizmat> I guess we need to correct the example in the spec

[11:30] <cognominal> this way of meshing so different parts of the language is the proof how well it is thought out.

[11:30] *** FROGGS[mobile] joined
[11:31] <jnthn> lizmat: Oh, hmmm

[11:31] <FROGGS[mobile]> hi there

[11:31] <cognominal> hi FROGGS[mobile] 

[11:32] <FROGGS[mobile]> irclog is still teh borke?

[11:32] <lizmat> looks like it

[11:36] <timotimo> is there something like "literal_eval" for perl6 yet, and if not, is there interest in having something like that? (spec'd or panda'd)

[11:36] <jnthn> timotimo: val, maybe?

[11:37] <lizmat> val is NYI, afaik

[11:37] <lizmat> ah, duh

[11:37] <lizmat> :-)

[11:38] <timotimo> NYI, but specced? neat. i wonder how it can cleverly be implemented.

[11:38] <timotimo> iow: without reimplementing much of perl6s grammar

[11:38] <lizmat> S02:4461 Allomorphic value semantics (the "val" function)

[11:38] <jnthn> I think japhb++ was working on it at some point

[11:38] <timotimo> thanks

[11:40] <timotimo> hm. literal_eval also does data structures like lists, tuples and dicts in python. val only seems to do single simple literals

[11:40] <timotimo> or at least only those are discussed in that section

[11:40] <timotimo> ah, it's described further pu

[11:41] <lizmat> funny, is dalek down also?

[11:41] <lizmat> I just pushed:

[11:42] <lizmat> -    temp undefine $x;

[11:42] <lizmat> +    undefine temp $x;

[11:42] <lizmat> and haven't seen dalek reporting that yet

[11:43] <FROGGS[mobile]> hmmm, dalek was working yesterday when ilogger wasnt

[11:44] *** dmol left
[11:47] <lizmat> afk&

[11:48] <timotimo> oh perl6

[11:48] <timotimo> r: my $part = 55; say :100[0, '.', $part, 99]

[11:48] <camelia> rakudo 71ea14: OUTPUT¬´0.5599‚ê§¬ª

[11:48] <timotimo> this is amazing.

[11:52] <timotimo> "Also allowed in strings are [...] maybe a trailing Units type for an implied scaling" - this is not specced out yet?

[11:53] <cognominal> timotimo: where do you read that?

[11:54] <timotimo> http://perlcabal.org/syn/S02.html#Exponentials

[11:54] <timotimo> under the last :2<....> example

[11:54] <timotimo> be back in 30

[11:55] <cognominal> bb in an hour or so

[12:13] <dalek> nqp: 83fd61b | jnthn++ | src/vm/jvm/ (2 files):

[12:13] <dalek> nqp: Eliminate two instructions per QAST::WVal.

[12:13] <dalek> nqp: 

[12:13] <dalek> nqp: This passes the values directly to the indy bootstrap method, which we

[12:13] <dalek> nqp: didn't have the infrastructure to do when QAST::WVal stuff was first

[12:13] <dalek> nqp: switched over.

[12:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/83fd61bd8c

[12:14] <dalek> nqp: 1cc2d3e | jnthn++ | src/vm/jvm/ (2 files):

[12:14] <dalek> nqp: Reduce cost of immediate block invocation.

[12:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1cc2d3e101

[12:24] <cognominal> "indy bootstrap"  :)

[12:25] <timotimo> next up: hipster bootstrap?

[12:25] <timotimo> oh, that's what twitter made, no? ;))

[12:25] <jnthn> One gets tired of typing invokedynamic eventually :)

[12:26] * jnthn ponders whether $foo."$bar"() tends towards the megamorphic...

[12:27] <jnthn> Hm...the action method calling almost certainly is.

[12:28] <jnthn> (A megamorphic callsite is a polymorphic one where there's a huge number of potential places we could end up.)

[12:31] * lizmat wonders where this is going to

[12:32] <jnthn> lizmat: Just pondering the way I handle such call sites on the JVM

[12:32] <jnthn> lizmat: When it's $foo.bar() then it's unusual for their to be an insane number of possibilities.

[12:32] <timotimo> Seq was removed from the language, correct?

[12:33] <jnthn> lizmat: Moreover, you tend to know where you're going by class.

[12:33] <lizmat> jnthn: ack

[12:33] <lizmat> timotimo: not in the spec yet

[12:33] <timotimo> ah, ok

[12:33] <lizmat> not sure whether that is a problem of the spec or not

[12:33] <jnthn> lizmat: So I can tell the JVM to just stack up some guard clauses there, which makes things a win.

[12:34] <jnthn> lizmat: However, if you pile up too many of those, you're in bother.

[12:34] <lizmat> right, too many "likely"s to check

[12:34] <timotimo> if you care, here's another mention: http://perlcabal.org/syn/S02.html#Explicit_Parcel_construction  -  but if the decision to remove Seq is final, one can probably just as easily grep for "Seq."

[12:35] <jnthn> lizmat: A callsite with a LOAD of possible destinations, differentiated by name *and* invocant type, is probably going to turn nasty in plenty of common cases. So I think the answer for now is "don't be too clever" :)

[12:35] <lizmat> indeed, plenty of time ahead to put in cleverness

[12:35] *** frd|afk joined
[12:35] <lizmat> MIWN is much more important

[12:36] <timotimo> "Man I Wonder Now"?

[12:36] <lizmat> Make It Work Now

[12:36] <lizmat> :-)

[12:36] <timotimo> oh, sure

[12:36] <lizmat> a variation on DWIM

[12:36] <masak> sounds like "first, make it work"

[12:37] <timotimo> it's encouraging to see jnthn make the stuff faster, but it's also pretty nice to see jnthn make rakudo compile on the jvm ;)

[12:38] <jnthn> Well, invocant is kinda at the heart of a lot of things, so there's also part of me wanting to get it wired up through invokedynamic before I go piling Rakudo on top of all of this :)

[12:39] *** frdmn left
[12:39] <jnthn> *invocation

[12:39] <jnthn> The other piece of this is that the coroutine handling stuff requires that we have an empty stack besides the arguments at the point of each call.

[12:40] <jnthn> Which I'd not enforced up until now

[12:40] <lizmat> so, rakudo-jvm is getting more features than rakudo-parrot already?

[12:40] <jnthn> lizmat: No...what did I say to make you think so? :)

[12:41] <lizmat> "[14:40:04] <jnthn>	 Which I'd not enforced up until now"

[12:41] <jnthn> lizmat: Yes, this is a code-gen level thing, not a user level thing.

[12:42] <lizmat> gotcha

[12:42] <jnthn> I think http://cs.brown.edu/~sk/Publications/Papers/Published/pcmkf-cont-from-gen-stack-insp/paper.pdf is the relevant paper, for anybody who wants the gory details...

[12:44] <lizmat> eek  :-)

[12:45] * timotimo puts on his reading gloves

[13:01] <dalek> nqp: 20547c3 | jnthn++ | src/vm/jvm/ (2 files):

[13:01] <dalek> nqp: Send indirect calls through invokedynamic.

[13:01] <dalek> nqp: 

[13:01] <dalek> nqp: Not expecting a performance change from this, but it makes code gen a

[13:01] <dalek> nqp: bit simpler/better/uniformer.

[13:01] <dalek> nqp: review: https://github.com/perl6/nqp/commit/20547c318f

[13:07] *** FROGGS[mobile] left
[13:16] *** SmokeMac_ joined
[13:18] *** SmokeMachine left
[13:20] *** Bzek joined
[13:46] <dalek> nqp: a84eedf | jnthn++ | src/vm/jvm/ (2 files):

[13:46] <dalek> nqp: Send $foo."$bar"() calls through indy also.

[13:46] <dalek> nqp: 

[13:46] <dalek> nqp: Don't do much optimization here, this just simplifies code-gen and

[13:46] <dalek> nqp: brings it inline with that of normal method calls.

[13:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a84eedf683

[13:46] <dalek> nqp: 86c9a7f | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[13:46] <dalek> nqp: Remove now-unused code.

[13:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/86c9a7f5c8

[13:47] <dalek> nqp: 68405c9 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[13:47] <dalek> nqp: Update and simplify for loop code-gen.

[13:47] <dalek> nqp: 

[13:47] <dalek> nqp: It now desugars the calls through a QAST node, menaing we get rid of

[13:47] <dalek> nqp: the last use of building arg arrays and that such loops should now get

[13:47] <dalek> nqp: better code gen.

[13:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/68405c9e31

[13:47] <dalek> nqp: eaeda37 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[13:47] <dalek> nqp: Remove more dead code.

[13:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/eaeda3729f

[13:51] <timotimo> is .quoteharder an actual thing?

[13:53] *** woosley1 joined
[13:53] <jnthn> Doesn't sound familiar

[13:55] <timotimo> macro quote:<‚ù∞ ‚ù±> ($text) { quasi { {{{$text}}}.quoteharder } }  ‚Äî probably just another silly example :)

[13:56] *** grondilu joined
[13:59] <dalek> nqp: c7c2297 | jnthn++ | src/vm/jvm/ (2 files):

[13:59] <dalek> nqp: Make atkey and atpos on type objects give null.

[13:59] <dalek> nqp: 

[13:59] <dalek> nqp: This simplifies code-gen for array/hash access.

[13:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c7c2297b7e

[14:00] <jnthn> Recent code generation improvements means a full NQP is now around 4.1 MB worth of .class files rather than 5.4 MB.

[14:01] <masak> timotimo: yes, silly example.

[14:02] <masak> timotimo: it's just a method on whatever's in {{{$text}}} -- probably a Str, from the looks of it, but could be something else, too.

[14:07] *** sizz left
[14:10] *** gabriel_ left
[14:11] *** sizz joined
[14:17] *** gabriel_ joined
[14:18] *** isBEKaml joined
[14:20] <FROGGS_> jnthn++ # that's cool

[14:21] *** woosley1 left
[14:26] *** SmokeMac_ left
[14:30] *** SmokeMachine joined
[14:30] *** Bzek left
[14:33] *** mtk left
[14:41] *** fhelmberger joined
[14:44] <dalek> v5: f7d0e77 | (Tobias Leich)++ | / (2 files):

[14:44] <dalek> v5: make %ENV available when strict is in use

[14:44] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/f7d0e775dc

[14:44] <dalek> v5: 679269b | (Tobias Leich)++ | / (2 files):

[14:44] <dalek> v5: making "use integer" an noop for now

[14:44] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/679269b62d

[14:46] *** raiph joined
[14:49] <dalek> nqp: e610165 | jnthn++ | src/vm/parrot/ (2 files):

[14:49] <dalek> nqp: Move dispatcher set/take op into NQP itself.

[14:49] <dalek> nqp: 

[14:49] <dalek> nqp: This will let us do better code-gen with it on the JVM and also ease

[14:49] <dalek> nqp: keeping it per thread.

[14:49] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e6101657f6

[14:51] *** colomon left
[14:54] *** colomon joined
[14:54] *** aindilis left
[15:07] *** nyuszika7h joined
[15:09] *** tgt left
[15:09] *** tgt joined
[15:12] <dalek> rakudo/jvm-support: 4da9ebb | jnthn++ | tools/build/Makefile-Parrot.in:

[15:12] <dalek> rakudo/jvm-support: Unbust build on Parrot in this branch.

[15:12] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/4da9ebbaa7

[15:12] <dalek> rakudo/jvm-support: b179337 | jnthn++ | / (6 files):

[15:12] <dalek> rakudo/jvm-support: Dispatcher changes for portability improvements.

[15:12] <dalek> rakudo/jvm-support: 

[15:12] <dalek> rakudo/jvm-support: Gets rid of the remaining pir:: in the Metamodel code. Also uses a new

[15:12] <dalek> rakudo/jvm-support: op made available since the dispatcher code was written to avoid loads

[15:12] <dalek> rakudo/jvm-support: of copy arguments around, meaning that deferral becomes cheaper on

[15:12] <dalek> rakudo/jvm-support: Rakudo on Parrot also.

[15:12] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/b179337176

[15:17] *** fhelmberger left
[15:21] <timotimo> what does deferral refer to in this case? things like protos that do their own dispatching?

[15:24] <jnthn> nextsame and friends

[15:25] <timotimo> neat

[15:36] *** Bzek joined
[15:40] *** Targen joined
[15:41] *** Bzek left
[15:41] *** Bzek joined
[16:16] *** isBEKaml left
[16:24] *** flussence left
[16:26] *** flussence joined
[16:32] <dalek> nqp: 9d9a2af | jnthn++ | src/vm/jvm/ (3 files):

[16:32] <dalek> nqp: Implement setdispatcher/takedispatcher on JVM.

[16:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9d9a2af864

[16:32] <dalek> nqp: 3ca71af | jnthn++ | src/vm/jvm/ (2 files):

[16:32] <dalek> nqp: Add nqp::settypecheckmode for JVM.

[16:32] <dalek> nqp: 

[16:32] <dalek> nqp: Also, start to flesh out istype a little more, though it needs more

[16:32] <dalek> nqp: work to finish it.

[16:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3ca71af0d0

[16:33] <dalek> rakudo/jvm-support: b6b88bf | jnthn++ | src/vm/jvm/Perl6/Ops.nqp:

[16:33] <dalek> rakudo/jvm-support: First cut of nqp::p6bool compilation for JVM.

[16:33] <dalek> rakudo/jvm-support: 

[16:33] <dalek> rakudo/jvm-support: Actual thing it calls doesn't exist yet, though.

[16:33] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/b6b88bf352

[16:33] <dalek> rakudo/jvm-support: 82e9667 | jnthn++ | src/Perl6/Metamodel/ (2 files):

[16:33] <dalek> rakudo/jvm-support: Don't do Parrot interop role except on Parrot.

[16:33] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/82e966743b

[16:33] <dalek> rakudo/jvm-support: eb54676 | jnthn++ | tools/build/Makefile-JVM.in:

[16:33] <dalek> rakudo/jvm-support: Add Perl6::Metamodel to the JVM build.

[16:33] <dalek> rakudo/jvm-support: 

[16:33] <dalek> rakudo/jvm-support: Usual caveat applies: just 'cus it builds doesn't mean it all works.

[16:33] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/eb5467698e

[16:34] <nwc10> jnthn++ # steadily pushing the goalposts nearer to Christmas

[16:39] *** rking left
[16:45] <colomon> jnthn++ # maybe getting Rakudo JVM working fast enough to help out my ABC & Processing project

[16:47] <jnthn> Well, next comes BOOTSTRAP which is where the next batch of Hard Stuff starts.

[16:48] *** rking joined
[16:48] <jnthn> And beyond there, we're into the realm of the terrifying: starting to work little by little through getting CORE.setting to build.

[16:48] <masak> \o/

[16:48] <masak> that's the best definition of "terrifying" I've heard in quite a while.

[16:51] <jnthn> Time for a break, dinner, etc. bbl

[16:52] <flussence> did those efforts to split the setting up ever go anywhere?

[16:57] *** clkao left
[16:58] *** clkao joined
[16:59] *** jeffreykegler joined
[17:01] <cognominal> ho, I did not notice that jnthn jvm effort moved to rakudo

[17:02] *** fgomez left
[17:09] <masak> will Rakudo #64 be the first Rakudo release to run on the JVM?

[17:13] <flussence> .oO( we could do some horribly misleading marketing and call it Rakudo64 )

[17:13] <flussence> (in reference to the 90s console wars)

[17:14] <cognominal> an the FAQ will be :  does it also run on 32bits computers

[17:14] <cognominal> where can I find Rakudo32 ?

[17:33] *** fgomez joined
[17:37] *** adu joined
[17:48] <jeffreykegler> By the way, what does ".oO(" mean?  I've tried looking it up without avail.

[17:51] <masak> jeffreykegler: it's a thought bubble

[17:51] <masak> like in comics.

[17:51] <colomon> jeffreykegler: "I'm thinking"

[17:51] <masak> ...therefore I am.

[17:52] <jeffreykegler> So it's for something that is an "aside", for one degree or another.

[17:53] <jeffreykegler> I was trying to guess on the basis that it's an emoticon, but the emotions expressed were all over the map.

[17:57] *** kaare_ joined
[18:02] <masak> yes, "aside" covers it.

[18:02] <japhb> I saw I got highlighted regarding val(), but have not backlogged yet -- is there still an open question?

[18:06] <raiph> .oO( I opened the question and peered inside )

[18:07] *** adu left
[18:10] <jnthn> japhb: Somebody asked about it and I seemed to recall you were looking at it (or related things) at some point

[18:13] <japhb> jnthn, Yeah, I got about as far as I could without implementing dualvars.  And then realized I had to do Parrot-related hacking to make that possible.  And then, after a few abortive attempts to concentrate on said task, mysteriously found other things to work on.

[18:13] <japhb> Still bugs me that I didn't manage to close out that task, though.  :-(

[18:15] <jnthn> japhb: May be a good YAPC::NA hacking task when we can work together on it.

[18:15] <japhb> jnthn, hmmm, good point!

[18:20] *** kaare_ left
[18:21] *** SamuraiJack joined
[18:22] *** census joined
[18:23] *** frd|afk left
[18:23] *** fhelmberger joined
[18:23] *** frdmn joined
[18:27] *** tgt left
[18:40] *** xilo left
[18:45] <lue> hello world o/

[18:46] <jnthn> hellue o/

[18:47] *** xilo joined
[18:53] *** jeffreykegler left
[18:54] <dalek> nqp: 2883303 | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[18:54] <dalek> nqp: Fix a couple of op signatures.

[18:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/28833034cb

[18:54] <dalek> nqp: 176fa67 | jnthn++ | src/vm/parrot/ (2 files):

[18:54] <dalek> nqp: Add NQP op for checking if a capture has nameds.

[18:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/176fa67860

[18:56] *** snearch joined
[19:00] *** jeffreykegler joined
[19:00] *** census left
[19:00] *** trexy_ left
[19:01] *** jeffreykegler left
[19:04] *** tgt joined
[19:04] <dalek> rakudo/jvm-support: a25b65b | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[19:04] <dalek> rakudo/jvm-support: Remove/segregate some Parrotisms in BOOTSTRAP.

[19:04] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/a25b65be84

[19:04] <dalek> rakudo/jvm-support: 26d0a47 | jnthn++ | / (2 files):

[19:04] <dalek> rakudo/jvm-support: Eliminate one more of the pir:: in BOOTSTRAP.

[19:04] <dalek> rakudo/jvm-support: review: https://github.com/rakudo/rakudo/commit/26d0a47aaf

[19:25] <colomon> \o/

[19:39] *** domidumont left
[19:43] *** dmol joined
[19:44] *** SamuraiJack left
[20:00] *** telex left
[20:06] *** telex joined
[20:10] <cognominal> jnthn, nqp/master error messages are wrong on lion. They use backslash and state the wrong stage  https://gist.github.com/cognominal/5474507

[20:11] *** adu joined
[20:12] <jnthn> cognominal: Did you change something?

[20:13] <jnthn> cognominal: afaik you'd have to be (a) working on NQP, or (b) hit an error while building NQP to see that.

[20:14] <jnthn> It's an artefact of the bootstrap/self-hosting process.

[20:14] <cognominal> yes, that triggers the error but that's not my point

[20:14] <cognominal> my changes don't affect the build

[20:15] *** fhelmberger left
[20:17] *** berekuk left
[20:17] <jnthn> Updating the stage0 is done by taking a copy of the final build output (thus, stage2) and placing it in the stage0 directory. Thus you get (a) paths represented as they were by whoever did the last bootstrap update, and (b) they reference the place the build was done.

[20:18] <adu> jnthn: after I install java7, wanna chat about nqp?

[20:18] <dalek> v5: 9a693bc | (Tobias Leich)++ | / (2 files):

[20:18] <dalek> v5: parse pragma "open", need to set $*OPEN_DEFAULTS or similar

[20:18] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/9a693bc2c8

[20:18] <jnthn> adu: Can do. Did you get an NQP on JVM build?

[20:18] <adu> no, it says I need java7

[20:19] <jnthn> autumn: Oh...yes :)

[20:19] <jnthn> grr

[20:19] <jnthn> adu: ^^

[20:20] <cognominal> jnthn, thx for explaining the bootstrapping process

[20:22] <cognominal> bootstrapping is never pretty. I am happy that jnthn got past that stage with jvm

[20:27] *** berekuk joined
[20:28] <autumn> jnthn: oh...no

[20:28] <timotimo> r: say ("oh"..."no").list.perl

[20:28] <camelia> rakudo 71ea14: OUTPUT¬´("oh", "og", "of", "oe", "od", "oc", "ob", "oa", "nz", "ny", "nx", "nw", "nv", "nu", "nt", "ns", "nr", "nq", "np", "no").list‚ê§¬ª

[20:29] <masak> autumn: ;)

[20:32] <colomon> n: say ("oh"..."no").list.perl

[20:32] <camelia> niecza v24-37-gf9c8fc2: OUTPUT¬´("oh", "og", "of", "oe", "od", "oc", "ob", "oa", "nz", "ny", "nx", "nw", "nv", "nu", "nt", "ns", "nr", "nq", "np", "no").list‚ê§¬ª

[20:33] *** kaare_ joined
[20:38] <lue> r: say ("aa"..."zz").pick(2)

[20:38] <camelia> rakudo 71ea14: OUTPUT¬´tw yp‚ê§¬ª

[20:38] *** berekuk left
[20:39] <adu> yey java7 is finally installed

[20:41] <masak> I hear it's really secure and everything.

[20:41] *** cognominal left
[20:42] *** cognominal joined
[20:42] <geekosaur> Just Another Vulnerability Announcement

[20:42] <adu> geekosaur: lol

[20:43] <adu> masak: security is a statement about an organization, it's impossible to make that statement any particular software

[20:45] <masak> surely the software is what contains exploitable bugs, not the organization.

[20:45] <timotimo> the organization can, too. using these bugs is called "social engineering"

[20:46] <adu> masak: suppose you had perfect software, and gave out their password on national TV, then the organization is insecure, which has nothing to do with software

[20:47] <masak> I hear what you're saying, but I'm having trouble mapping this back to Java.

[20:47] <timotimo> if your software uses a password for critical stuff, rather than proper cryptographic keys and signatures and/or two-factor auth, then that's not perfect :P

[20:47] <masak> surely the repeated exploits of the JVM stack lately haven't been due to some Oracle employee leaking passwords on TV?

[20:48] <masak> saying "it's Oracle that's insecure, not Java -- software can't be insecure" sounds like nonsense to me.

[20:49] <masak> or at least something highly falsifiable and false.

[20:49] * lue thinks it's all a case of Sun > Oracle, at least to users' eyes (I wonder if they saw that coming?)

[20:50] <adu> masak: I suppose you're right, it's the transitivity I think is false

[20:51] <adu> software X is secure, software Y is secure, therefore (X+Y) is secure -- I think this is false

[20:51] * geekosaur thinks java's insecurity (and perception thererof) well predates oracle's involvement

[20:52] <geekosaur> but oracle does have something of a perception of unresponsiveness to security issues, because of their tendency to let known security issues in their database slide

[20:52] <adu> lue oh? are you saying oracle f***ed it up?

[20:52] <geekosaur> (which *also* predates their acquiring Sun)

[20:52] <lue> I haven't been following Oracle's adventures with Sun products, but from what little I know what they've done certainly wouldn't help matters.

[20:53] <lue> (to be honest I only know of somehow driving the creation of LibreOffice and the dissolution of the Java Community Board or whatever-twas-called)

[20:53] <adu> jnthn: it's on stage2

[20:54] <adu> jnthn: done!

[20:54] <geekosaur> sun owned openoffice (originally staroffice); people assumed oracle would either close source it or kill it off, and got surprised when they gave it to the apache foundation instead

[20:54] * lue 's first comment at :49 was supposed to contain an autopun, and is guessing it didn't get spotted

[20:55] *** berekuk joined
[20:55] * geekosaur did sort of spot it...

[20:55] <adu> lue: "saw"?

[20:55] <labster> good postnoon, #perl6

[20:55] <adu> lue: I still don't spot it

[20:55] <geekosaur> hard to see with the Sun in your eyes...

[20:56] <lue> "saw" meaning "I saw words describing it"

[20:56] <masak> it's a bit ironic that the flagship editor for Sun's language is called Eclipse...

[20:56] <adu> o hehe

[20:56] <jnthn> adu: yay :)

[20:57] <lue> autopun: I'd be surprised if Oracle couldn't prophetize backlash from the purchase

[20:58] <lue> (not a very good autopun, but still...)

[21:08] *** autumn left
[21:12] *** berekuk left
[21:16] <adu> jnthn: so what now?

[21:17] <jnthn> adu: What kinds of things do you wish to work on?

[21:17] <adu> whatever's missing

[21:17] <jnthn> adu: "make test" will show up some failures

[21:18] <jnthn> adu: One issue that I think is at the heart of various failures is

[21:18] <jnthn> if you run with something like: -e "sub foo() { "

[21:19] <jnthn> Instead of the correct error in FAILGOAL you get "Cannot stringify this". The qregex and p5regex tests fail in the same manner, so if that one can be worked out it may win quite a bit :)

[21:21] <adu> what is the correct error?

[21:21] <adu> "Incorrectly paired operators"?

[21:22] <jnthn> nqp: sub foo() {

[21:22] <camelia> nqp: OUTPUT¬´Unable to parse expression in blockoid; couldn't find final '}' at line 2, near ""‚ê§current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)‚ê§¬ª

[21:22] <jnthn> That one.

[21:22] <jnthn> It may just be that NQPRoutine or NQPRegex want a method Str that returns the name of the routine.

[21:23] <jnthn> nqp: sub foo() { }; say(&foo)

[21:23] <camelia> nqp: OUTPUT¬´foo‚ê§¬ª

[21:23] <jnthn> nqp-jvm: sub foo() { }; say(&foo)

[21:23] <camelia> nqp-jvm: OUTPUT¬´Cannot stringify this‚ê§  in <anon>‚ê§  in print‚ê§  in say‚ê§  in <anon>‚ê§  in <anon>‚ê§  in eval‚ê§  in evalfiles‚ê§  in command_eval‚ê§  in command_line‚ê§  in MAIN‚ê§  in <anon>‚ê§  in <anon>¬ª

[21:23] <jnthn> Ah, it may be that :)

[21:23] <adu> jnthn: :) thanks

[21:25] *** kaare_ left
[21:26] <masak> 'night, #perl6

[21:31] <labster> All right, I finally have a branch with working IO::Path for multiple OSes.

[21:34] <labster> Only had to add one tiny bit of pir to make it work.

[21:36] *** sizz left
[21:36] <lue> labster: that goes in CORE.setting, right?

[21:37] <adu> jnthn: so I added a Str method to src/core/NQPRoutine.nqp, and recompiled, and I'm still getting "Cannot stringify this", so that's not it

[21:38] <labster> yeah

[21:38] <adu> wait, foo is a Sub, not a Routine

[21:39] *** autumn joined
[21:40] <jnthn> adu: They're all NQPRoutine or NQPRegex

[21:40] <jnthn> (In NQP)

[21:40] <labster> lue: That was why I had to add the pir -- I wanted to get $*OS before it was actually defined in the setting.

[21:41] <lue> and there's no equivalent nqp:: op for what you needed? (Just wondering, because any pir:: will be replaced in CORE.setting sooner or later)

[21:42] <labster> well... I just copypasted from terms.pm.

[21:43] <labster> I suppose I should start helping with the hunt for pir in the core.

[21:45] <lue> Just thought I'd let you know in case you'd like to avoid putting more PIR in CORE.setting :) (but if there is no nqp:: op yet for what you need, then by all means leave the pir:: there)

[21:50] *** sizz joined
[21:51] *** berekuk joined
[21:53] <adu> what's the difference between QAST::Block and QAST::Stmts?

[21:53] *** berekuk left
[21:54] <adu> is one for packages and one for sub/methods?

[21:57] *** berekuk joined
[22:00] <jnthn> QAST::Block implies a lexical scope.

[22:01] <jnthn> QAST::Stmts is just a bunch of things to run in order, and evaluates by default to the last thing.

[22:02] *** berekuk left
[22:02] <adu> so Block is like ((lambda)) and Stmts is like (begin)

[22:04] *** lustlife left
[22:06] *** spider-mario left
[22:08] *** gem_ joined
[22:10] <adu> jnthn: where is nqp::print implemented?

[22:11] <jnthn> adu: It's mapped in src/vm/jvm/QAST/Compiler.nqp to a method in Ops.java

[22:11] *** gem_ left
[22:13] <adu> r: class C { sub Str() { "D" } }; say(C.new);

[22:13] <camelia> rakudo 71ea14: OUTPUT¬´C.new()‚ê§¬ª

[22:13] <adu> class C { sub Str() { "D" } }; say(C.new().Str());

[22:13] <jnthn> method

[22:14] <adu> r: class C { method Str() { "D" } }; say(C.new().Str());

[22:14] <camelia> rakudo 71ea14: OUTPUT¬´D‚ê§¬ª

[22:14] <adu> nqp-jvm: class C { method Str() { "D" } }; say(C.new().Str());

[22:14] <camelia> nqp-jvm: OUTPUT¬´D‚ê§¬ª

[22:14] <adu> hmm

[22:15] <adu> so for some reason obj.st.MethodCache.get("Str") isn't working

[22:21] *** jdv79 left
[22:21] <jnthn> Well, that's just a hash lookup

[22:22] <jnthn> Most likely there's nothing there for whatever thing it's doing the lookup on

[22:24] <jnthn> If NQPRoutine and NQPRegex both have Str methods, my only other guess is that it's a CodeRef, which is the low-level thing. If so, the right way to get a name out of one of those is to nqp::getcodename it...

[22:25] <jnthn> Time to sleep here, I think.

[22:25] <adu> jnthn: thanks for the help

[22:25] <jnthn> np, thanks for looking at this :)

[22:27] *** ruoso left
[22:27] *** ruoso joined
[22:33] *** tgt left
[22:36] *** snearch left
[22:37] *** tgt joined
[22:51] *** tgt left
[23:04] *** Chillance left
[23:07] <adu> jnthn: I fixed it

[23:21] *** BenGoldberg joined
[23:31] *** Ben_Goldberg joined
[23:31] *** berekuk joined
[23:34] *** BenGoldberg left
[23:37] *** frdmn left
[23:48] *** PacoAir left
