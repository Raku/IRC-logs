[00:00] <timotimo> in my opinion, there must be recognition of repetition and redundancy across sub/method call boundaries

[00:00] <timotimo> anything that'll fall out of data flow analysis, really

[00:00] <timotimo> anyway, since i really don't know nearly enough about this, i'll just go to bed and see what the next day will bring :)

[00:10] *** FROGGS left
[00:15] *** Psyche^ left
[00:17] *** Psyche^ joined
[00:44] *** dwarring left
[01:07] <japhb__> r: use Test; class A {}; multi infix:<eqv>(A $a, A $b) { True }; my A $one .= new; my A $two .= new; say $one eqv $two; is_deeply($one, $two);

[01:07] <camelia> rakudo c6d5c9: OUTPUT¬´True‚ê§not ok 1 - ‚ê§#      got: A.new()‚ê§# expected: A.new()‚ê§¬ª

[01:07] <japhb__> GAH.

[01:07] * japhb__ shakes his fist at Rakudo

[01:08] <colomon> why is deeply?

[01:08] <japhb__> colomon: That's the test to use when you want eqv comparison.

[01:08] <colomon> but they're not eqv

[01:09] <colomon> it's just the got / expected that are wrong.

[01:09] <japhb__> colomon: look at the code again.  ;-)

[01:09] <colomon> oh

[01:09] <colomon> :\

[01:09] <japhb__> Yeah.

[01:10] <japhb__> My best guess right now is that the infix:<eqv> cannot participate in the eqv multi used by the already-compiled Test class.

[01:10] <colomon> oh!

[01:10] <colomon> that's totally it

[01:11] <colomon> that's the way p6 is supposed to work

[01:11] <colomon> if you want to shake your fist, you need to shake it at TimToady++

[01:12] <colomon> r: sub check($a, $b) { say $a eqv $b; }; class A {}; multi infix:<eqv>(A $a, A $b) { True }; my A $one .= new; my A $two .= new; say $one eqv $two; check($one, $two)

[01:12] <camelia> rakudo c6d5c9: OUTPUT¬´True‚ê§True‚ê§¬ª

[01:12] <colomon> unless that's not it at alll...

[01:12] <japhb__> How in the world do you make use of multi candidates that aren't in the same compilation unit then?

[01:13] <colomon> that's what lift is supposed to be for

[01:13] <colomon> and I totally agree it kind of sucks

[01:14] <colomon> r: sub check($a, $b) { say $a eqv $b; }; class A {}; my A $one .= new; my A $two .= new; say $one eqv $two; check($one, $two)

[01:14] <camelia> rakudo c6d5c9: OUTPUT¬´False‚ê§False‚ê§¬ª

[01:14] <japhb__> 'git grep lift' in a rakudo checkout gives nothing of value.

[01:14] <colomon> japhb__: right, because lift is just hypothetical so far

[01:14] <TimToady> and likely to go away anyway

[01:14] <colomon> and may well not end up being named lift

[01:15] <colomon> TimToady! \o/

[01:15] <japhb__> Ah, language designer in da house.

[01:15] <TimToady> well, it's likelier to be macros that can implicitly carry down operators

[01:15] <TimToady> but is_deeply should probably be parameterized for comparison

[01:15] <japhb__> So: how do I fix my code at 18:07 such that Perl 6 will Do What I Want?

[01:16] <colomon> probably don't use is_deeply, I think.

[01:16] <TimToady> japhb__: well, one of the two things I just said

[01:16] <diakopter> how many timezones is that from me

[01:16] <japhb__> is_deeply is just an example of the broader problem.

[01:16] <TimToady> either is_deeply gets a :by parameter

[01:17] <TimToady> or we have macros that can do &infix:<cmp> = &CALLER:<cmp>

[01:18] <TimToady> well, maybe can get away without full macros there

[01:18] <TimToady> rather, &infix:<cmp> = &CALLER::infix:<cmp>

[01:18] <japhb__> eqv recurses through the proto at each level.  Do you mean that you would do :by(&infix<eqv>) and thus get the caller's view of the proto?

[01:18] <colomon> diakopter: I believe he means 9:07 Eastern

[01:19] <japhb__> diakopter: Are you not in your usual timezone?

[01:19] <TimToady> he's at ppw

[01:19] <japhb__> Ah!

[01:19] <japhb__> Are you also?

[01:19] <colomon> ppw++

[01:20] * colomon is in Chicago for Legoland

[01:20] <japhb__> Very cool.

[01:22] <diakopter> polish perl workshop is great

[01:24] <colomon> http://pghpw.org/ppw2013/talk/5091 

[01:24] <colomon> are you going to have slides online?

[01:24] <diakopter> heh

[01:24] <diakopter> considering I changed the topic today...

[01:25] <colomon> oh?

[01:26] <diakopter> yeah, to "WTFP6"

[01:27] <diakopter> or "P6WTF"; I haven't decided

[01:28] <colomon> moar bugs that bad today?  ;)

[01:28] <diakopter> no it's meant to identify with the audience

[01:30] <diakopter> and the first Sunday talk

[01:31] <colomon> diakopter++ # representing

[01:32] <TimToady> we all show our passion in different ways :)

[01:33] <diakopter> I'm not sure I'll actually be representing anyrhing

[01:33] <japhb__> r: class A {}; sub foo { say &CALLER::infix:<eqv>(A.new, A.new) }; multi infix:<eqv>(A $a, A $b) { True }; foo()

[01:33] <camelia> rakudo c6d5c9: OUTPUT¬´No such method 'dynamic' for invocant of type 'Sub+{Precedence}'‚ê§  in method at_key at src/gen/CORE.setting:9171‚ê§  in sub postcircumfix:<{ }> at src/gen/CORE.setting:2414‚ê§  in sub postcircumfix:<{ }> at src/gen/CORE.setting:2410‚ê§  in sub foo at /tmp/wc8‚Ä¶¬ª

[01:33] <japhb__> Now WTH does that mean?

[01:36] <TimToady> it means "Now WTH does that mean?"

[01:37] <japhb__> TimToady: OK ... so what did I not understand about your suggestion?  (Leaving aside the question of temporary assignment of &infix:<eqv>, I can't even *use* it right now)

[01:38] <diakopter> colomon: but no, jnthn and FROGGS seemed to make huge progress today on the moarqp bootstrap

[01:38] <colomon> \o/

[01:38] <TimToady> right, it will take either a compiler to allow infix:<eqv> to be accessed as a dynamic lexical, or it will take some kind of semimacro to tell the caller to pass it implicitly somehow, or enable it to show up in the current lexical scope in a dynamically visible fasion

[01:38] <colomon> very exiting.

[01:39] <diakopter> yes, exciting too

[01:39] <japhb__> hmmm

[01:39] <colomon> I'm sorry I've been so out of things lately.  And I'm going to keep being too busy to p6, I should be $working right now. 

[01:40] <diakopter> colomon: thumbs up 7up

[01:40] <diakopter> :D

[01:40] <japhb__> colomon: Seems to be the season for $day-job tuit constraint ....

[01:41] <diakopter> ,i

[01:42] <colomon> japhb__: for me it's as much life as $day-job, but yes, almost all my normally spare tuits are being funneled into contract $work right now.

[01:42] <japhb__> TimToady: in not treating infix:<eqv> as a dynamic lexical, is this a rakudobug or WAI?

[01:43] <TimToady> r: class A {}; sub foo { say CALLER::['&infix:<eqv>'](A.new, A.new) }; multi infix:<eqv>(A $a, A $b) { True };

[01:43] <camelia> rakudo c6d5c9: ( no output )

[01:43] <TimToady> r: class A {}; sub foo { say CALLER::['&infix:<eqv>'](A.new, A.new) }; multi infix:<eqv>(A $a, A $b) { True }; foo()

[01:43] <camelia> rakudo c6d5c9: OUTPUT¬´Cannot call 'Real'; none of these signatures match:‚ê§:(Mu:U \v: Mu *%_)‚ê§  in method Real at src/gen/CORE.setting:944‚ê§  in method Real at src/gen/CORE.setting:3422‚ê§  in method Real at src/gen/CORE.setting:944‚ê§  in sub infix:<<> at src/gen/CORE.setting:3‚Ä¶¬ª

[01:44] <japhb__> o.O

[01:44] *** cognominal left
[01:44] <TimToady> r: class A {}; sub foo { say CALLER::('&infix:<eqv>')(A.new, A.new) }; multi infix:<eqv>(A $a, A $b) { True }; foo()

[01:44] <camelia> rakudo c6d5c9: OUTPUT¬´No such method 'dynamic' for invocant of type 'Sub+{Precedence}'‚ê§  in method at_key at src/gen/CORE.setting:9171‚ê§  in sub postcircumfix:<{ }> at src/gen/CORE.setting:2414‚ê§  in sub postcircumfix:<{ }> at src/gen/CORE.setting:2410‚ê§  in sub INDIRECT_NAME_L‚Ä¶¬ª

[01:45] <TimToady> anyway, we need to be able to do something like that, one way or t'other

[01:46] * japhb__ wonders if jnthn++ got partway through implementing it, just based on the odd error message.

[01:47] <TimToady> r: class A {}; sub foo { say CALLER::myeqv(A.new, A.new) }; multi infix:<eqv>(A $a, A $b) { True }; my &myeqv = &infix:<eqv>; foo()

[01:47] <camelia> rakudo c6d5c9: OUTPUT¬´No such method 'Any' for invocant of type 'Parcel'‚ê§  in sub foo at /tmp/bykqP9x6HL:1‚ê§  in block  at /tmp/bykqP9x6HL:1‚ê§‚ê§¬ª

[01:47] <japhb__> TimToady: It feels to me that multis need to by default stay "open", because something like infix:<eqv> can work its way through multis in quite a few compilation units before bottoming out doing comparison of complex data structures.

[01:48] <TimToady> they do stay open, in a lexically scoped sense

[01:49] <TimToady> we're just trying to use CALLER to get at the lexically scoped definition at the point of the caller

[01:50] <TimToady> once it finds the right proto, it should happen right automatically

[01:50] <japhb__> I meant they'd need to stay open in a dynamic sense ... but maybe if every single eqv multi that wants to delegate always does CALLER::infix:eqv when it does so, the chain could be kept correct ...

[01:50] <japhb__> Yeah, I'm seeing a little more clearly what you're going for.

[01:51] <TimToady> whether we can get away with doing the completely dynamically, or need a bit of macroish help, I dunno

[01:51] <TimToady> it would be nice to have the compiler aware enough of it that, should it inline the call, it can just throw away all the linkage

[01:51] <japhb__> Well, every eqv multi would have to do: local infix:<eqv> = &CALLER::infix:<eqv>  before delegating

[01:51] <japhb__> hmmm

[01:52] <TimToady> that's why I'd like some syntactic relief in the signature, perhaps

[01:53] <TimToady> but we're moving away from the lift idea, insofar as that was going to auto-hoist every operator, but we really want a little better control

[01:53] <japhb__> signature of ... the eqv multi candidates?

[01:53] <TimToady> either in the proto sig, or in each multi

[01:54] <TimToady> not all multis want to lift

[01:54] <TimToady> eventually you find the multi that is the base case, and that wants the raw version of eqv

[01:54] <japhb__> 'proto infix:<eqv>(|) is lifted {*}' ?

[01:54] <TimToady> not that proto

[01:55] <TimToady> or not like that

[01:55] *** colomon left
[01:55] <TimToady> I think it's more likely that each multi has a way to talk about each operator as lifted or not

[01:56] <TimToady> which is why we were discussing a hook directly into the parser such as ¬§ might provide for ASTs

[01:56] <TimToady> but it's not an AST, it's just an implicit caller's operator

[01:56] <japhb__> That seems to put a lot of burden on the casual extender (by which I mean, person who just wants to add a multi candidate for their new class)

[01:57] <TimToady> so $a ¬© eqv $b or some such

[01:57] *** prevost joined
[01:57] <japhb__> And perhaps I'm thinking too narrowly about eqv, but I don't think that one bottoms out to "raw version of eqv", but rather bottoms out when the comparison begins to use other operators (eqv for Str, Str translating to eq)

[01:58] *** colomon joined
[01:58] <japhb__> In other words, you start looking at a different proto.

[01:58] <TimToady> eqv is perhaps a bad example

[01:59] <japhb__> yeah, perhaps

[01:59] <japhb__> I can see the value of a (c) meta-operator, though

[01:59] *** cognominal joined
[01:59] <TimToady> $a ¬©+ $b is perhaps a more likely lifted operator

[01:59] <TimToady> ¬© for CALLER of course

[02:00] <japhb__> I understood.  :-)

[02:00] <TimToady> the point of ¬© and ¬§ is to provide direct hooks into the parser to let them slip things into the parse in place of a syntactic category

[02:01] <TimToady> so there's be some kind of generic "caller infix" that this would pull in as a kind of metaoperator

[02:01] <japhb__> Under that scheme, would much of Any.pm, Cool.pm, Real.pm start needing their operations to use (c) metaops everywhere?

[02:01] <TimToady> much as we might have macros that can replace other things than just nouns, but we need to be explicit about exactly how much of the AST we're replacing

[02:02] *** logie joined
[02:02] <TimToady> so the type of the ¬§ needs to be either on the parameter or at the point of the "gnostic interpolation"

[02:03] <TimToady> well, at some point we'll need to control genericity, or we're just re-inventing BAL 360 :)

[02:03] <TimToady> but fershure you can't inline everything--that don't scale to good

[02:04] <TimToady> *too

[02:04] <TimToady> you'd like the modules that develop new ops to pay the price, not everyone else

[02:05] <TimToady> so yeah, we might need people to register their interest in genericity to avoid such problems

[02:08] *** mattp_ left
[02:09] <dalek> nqp/moarboot: fa5dcf2 | coke++ | t/docs/opcodes.t:

[02:09] <dalek> nqp/moarboot: test for MOAR opcodes, also

[02:09] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/fa5dcf22d1

[02:09] *** mattp_ joined
[02:13] *** FROGGS joined
[02:15] <benabik> TEST MOAR THINGS!

[02:17] <benabik> "¬§"?  

[02:17] <[Coke]> ?

[02:18] <[Coke]> .u ¬§

[02:18] <yoleaux> U+00A4 CURRENCY SIGN [Sc] (¬§)

[02:18] *** FROGGS left
[02:19] <benabik> [Coke]: TimToady was talking about ¬§ and ASTs, and I've never seen this symbol before.  Ack doesn't seem to find it in the specs, either

[02:20] <TimToady> 'tis an IRC speculation of long standing

[02:20] <benabik> Interesting that there is a generic currency symbol.  I had always just used ¬µ for "monetary unit"

[02:21] <benabik> Sadly the irclogs seem to use it as part of mojibake for the N/L symbol.

[02:21] <benabik> So it's fairly unsearchable.

[02:22] <TimToady> you'd wanna scan for me discussing macro parameters and syntax categories with masak++

[02:24] <TimToady> or scan for "CURRENCY" :)

[02:24] <benabik> As people go "what is that character"?  Good idea.

[02:25] <benabik> *blinks*  And now the irc logs are 403ing, which makes it even less searchable.  I'll assume moritz++ is doing something to them.

[02:25] <TimToady> not likely at this time of night...

[02:26] * japhb__ is thinking about 'class A { has Mu @.mus }; class B { has A @.as }; my @c := [1, "foo", B.new(as => [A.new(mus => ...)])];' where A, B, and @c are defined in separate compunits, and wondering how anything non-pessimizing could possible handle multi operations on @c correctly

[02:26] <TimToady> the logs themselves eem fine to me

[02:27] <benabik> Oh, it's not the newline character.  Maybe color codes?  It's in all the SORRY lines.

[02:27] <benabik> And they're back.  Probably cosmic rays

[02:27] <TimToady> someone needs to teach that program to understand color codes someday

[02:28] *** prevost left
[02:28] <japhb__> .oO( Rule 3: "Well volunteered!" doesn't work on Larry. )

[02:28] <TimToady> Not when I was told at the beginning of this that they didn't like my programming style... :)

[02:29] <lue> TimToady: what is the generic currency symbol proposed to mean? Or must we search the logs for an answer?

[02:29] <TimToady> of course, all the VMs start looking just the same, because portable C forces you to do macros that way

[02:30] <benabik> Searching for "currency sign" in the clogs seems to find it nicely.  TimToady++

[02:30] <TimToady> it's intended to signal the parser that it should immediately replace an alternative in the grammar with something of known category

[02:30] *** apejens joined
[02:30] <TimToady> so where it looks for a bunch of <infix> it would know that ¬§myoperator is an AST parameter declared somewhere as an infix

[02:31] <TimToady> or ¬§infix:myparameter or some such

[02:31] * lue imagines the texas version to be >()< based on his current font :)

[02:31] *** wsri joined
[02:31] <TimToady> the category could be marked on either the interpolation location or on the parameter decl

[02:31] <TimToady> this is intended to replace and generalize the {{{$myparam}}} monstrosity

[02:32] * benabik wonders if the texas version is "if you're mucking around with macros, you can figure out Unicode"

[02:32] <lue> Ah, so you keep the parser from trying to sift through alternatives by just giving it the answer right away, IIUC.

[02:32] <lue> .oO( "if you're mucking around with macros, you can figure out Unicode"infix:myparameter )

[02:32] <benabik> lue++

[02:32] <TimToady> yes, but masak++ was dubious

[02:33] <TimToady> when I floated that it should be difficult :)

[02:33] <benabik> masak++ is good at dubious.

[02:33] <TimToady> it needs to be something that highjacks the parser, so it needs to be rather unusual

[02:34] <TimToady> since there's be an implicit alternative to almost any rule in the grammar

[02:35] <lue> .oO(for unusual, perhaps a quaternary operator, just to show you mean it. <something> ? <something> : <something> | myoperator :P)

[02:35] <TimToady> that's not what I call "obvious"

[02:35] <TimToady> ¬§ is obvious :)

[02:36] <lue> .oO(And then maybe hide ¬§ behind a use MONKEY_SMARTS; if safeguards are desired)

[02:36] <TimToady> in the sense of giving the parser an immedate WTF moment

[02:37] <lue> ‚ÄΩ would nicely sum up the parser's feelings :) ‚ÄΩinfix:right_alternative

[02:38] <TimToady> well, we're still struggling feebly to stay in Latin-1, so that there's likely to be a compose key

[02:38] <TimToady> though I guess that one has a compose

[02:39] <TimToady> ‚∏òDoesn't it‚ÄΩ

[02:39] <lue> Don't be silly. I only needed to type <Menu Key> ? ! for that! There was no key labelled "compose key" involved :)

[02:39] <TimToady> :P

[02:39] <benabik> .u ‚∏ò

[02:39] <yoleaux> U+2E18 INVERTED INTERROBANG [Po] (‚∏ò)

[02:40] <benabik> Okay, while I'm not too surprised interrobang is popular enough to make Unicode...  Inverted Interrobang?

[02:40] <benabik> .u ‚ÄΩ

[02:40] <yoleaux> U+203D INTERROBANG [Po] (‚ÄΩ)

[02:40] <lue> TimToady: I think we're basically fine if we stay inside BMP for Core P6. ‚ò∫

[02:41] <TimToady> üò∫

[02:41] <lue> (if only because there's a font out that can act as an ultimate fallback for that range: unifont)

[02:44] * TimToady imagines that it gives you half the glyph for surrogates :)

[02:51] *** logie left
[02:53] <lue> Huh. For some utterly strange and weird reason my "print the BMP" one-liner fails on character D800 :)

[03:00] *** FROGGS joined
[03:06] *** FROGGS left
[03:08] *** FROGGS joined
[03:08] *** lizmat left
[03:13] *** lizmat joined
[03:14] *** woolfy joined
[03:15] *** prevost joined
[03:18] *** FROGGS left
[03:31] *** lizmat left
[03:32] *** woolfy left
[03:32] <japhb__> My current conundrum -- Sum.pm: 'module Sum; sub zip-sum(Mu @a, Mu @b) is export { @a Z+ @b }'  A.pm: 'class A {}; multi infix:<+>(A $a, A $b) is export { 42 }'  main: 'use Sum; use A; say zip-sum([A.new], [B.new]);'  How do you compile each of these files so they are default-efficient, but main still produces the correct answer?

[03:33] <japhb__> (Aside from B.new should be A.new, of course)

[03:34] *** lizmat joined
[03:36] *** logie joined
[03:37] *** woolfy joined
[03:44] <japhb__> .tell jnthn Thoughts on http://irclog.perlgeek.de/perl6/2013-10-06#i_7677518 through http://irclog.perlgeek.de/perl6/2013-10-06#i_7677853 very much appreciated.

[03:44] <yoleaux> japhb__: I'll pass your message to jnthn.

[03:46] <japhb__> .tell jnthn In particular, I *think* much of the problem in this space can be summarized by http://irclog.perlgeek.de/perl6/2013-10-06#i_7677850 .

[03:46] <yoleaux> japhb__: I'll pass your message to jnthn.

[03:53] <japhb__> TimToady: Do you consider the addition of new multi candidates to be a mutation of the language, or just the addition of new protos?  In other words, there a linguistic reason (as opposed to performance) reason why my example from 20 minutes ago shouldn't Just Work?

[03:54] <japhb__> *is there

[03:58] *** preflex_ joined
[03:58] *** ChanServ sets mode: +v preflex_

[03:58] *** preflex left
[03:58] *** preflex_ is now known as preflex

[04:03] *** finanalyst joined
[04:18] *** colomon left
[04:25] *** logie left
[04:26] <japhb__> Furthermore, given -- A.pm: 'use B; class A { has B @.b }'  B.pm: 'use C; class B { has C @.c }'  C.pm: 'class A {...}; class C { has A @.a }' -- How in the heck would you sanely define working infix:<eqv> multis for each of these?

[04:28] *** sisar joined
[04:33] *** logie joined
[04:48] *** fridim_ left
[05:16] *** xenoterracide left
[05:16] *** xenoterracide_ joined
[05:16] *** prevost left
[05:23] <moritz> \o

[05:28] *** rindolf joined
[05:29] *** xenoterracide_ left
[05:37] *** rindolf left
[05:45] *** logie left
[05:46] *** darutoko joined
[05:59] *** Celelibi joined
[06:02] *** BenGoldberg left
[06:10] *** logie joined
[06:20] *** btyler left
[06:20] *** FROGGS joined
[06:58] *** logie left
[07:23] *** FROGGS left
[07:51] *** dmol joined
[08:01] *** FROGGS joined
[08:07] <FROGGS> o/

[08:16] <arnsholt> Does anyone have access to a 32-bit Linux machine?

[08:16] <arnsholt> I'm pretty sure NQP #28 is fixed, but can't confirm since it's supposedly a 32-bit thing

[08:17] <FROGGS> arnsholt: I'm booting one atm

[08:18] <arnsholt> Oh, awesome. If the NQP test suite runs cleanly on it, you can close #28

[08:18] <FROGGS> k

[08:22] *** kaare__ joined
[08:22] *** kaare__ is now known as kaare_

[08:25] <FROGGS> t/nqp/46-charspec.t                 (Wstat: 256 Tests: 0 Failed: 0)

[08:25] <FROGGS>   Non-zero exit status: 1

[08:25] <FROGGS>   Parse errors: No plan found in TAP output

[08:26] <FROGGS> ahh, these are due to missing icu

[08:29] <arnsholt> FROGGS++ # Cheers!

[08:30] <FROGGS> :o)

[08:30] <dalek> Perlito: 875d2eb | (Flavio S. Glock)++ | / (3 files):

[08:30] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - statement modifier

[08:30] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/875d2ebc8c

[08:30] <FROGGS> arnsholt: btw, I'd like to keep #133 open until we actually have a parrot release that fixes it

[08:56] <arnsholt> Yeah, that's probably a good idea

[08:58] <bbkr__> indeed :) lizmat++ colomon++, thanks for instant help

[08:58] <arnsholt> And then we can both try to remember to close it when the next Parrot release is out

[08:58] <bbkr__> sorry

[08:58] <bbkr__> wrong widow :)

[08:58] <bbkr__> window*

[09:03] *** xinming left
[09:05] *** xinming joined
[09:09] *** KroKite joined
[09:14] *** spider-mario joined
[09:14] <arnsholt> bbkr__: Could you give the stuff in NQP #32-35 a whirl? Are those warnings still there, or can we close the bugs?

[09:17] *** yogan left
[09:17] *** yogan joined
[09:18] <bbkr__> arnsholt: sure, testing it right now...

[09:18] *** yogan left
[09:19] <arnsholt> Cheers!

[09:25] *** sisar left
[09:31] <bbkr__> so far 33, 32, 35 have popped in build messages :(

[09:33] <bbkr__> new one spotted: https://github.com/perl6/nqp/issues/136

[09:35] <arnsholt> Oh, that one looks legitimate

[09:36] <bbkr__> this compiler is way too oversensitive

[09:36] <jnthn> aye

[09:36] <jnthn> It is, but for once the prec warning has pointed out a problem :)

[09:37] <arnsholt> jnthn: What's your thoughts on NQP #46? Bug or WONTFIX?

[09:40] <arnsholt> bbkr__++

[09:40] <dalek> nqp: 8f719a5 | (Arne Skj√¶rholt)++ | src/vm/parrot/ops/nqp_dyncall.ops:

[09:40] <dalek> nqp: Fix precedence oops in dyncall ops. Fixes #136.

[09:40] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8f719a567c

[09:41] *** KroKite left
[09:42] <bbkr__> I've dumped all warnings to a single file: https://gist.github.com/bbkr/6851782

[09:42] <bbkr__> If someone wants OS X shell account to fix them please PM me

[09:44] <jnthn> arnsholt: Bug

[09:45] <arnsholt> Okies

[09:46] <bbkr__> I've closed #34

[09:46] <arnsholt> I tried to fix the contextual one, but the easy fix I tried didn't work

[09:47] <arnsholt> bbkr__: Many of those are artefacts of the C code being generated code, but the non-void ones sound legitimate as well

[09:48] <dalek> nqp/moarboot: c847d0e | (Tobias Leich)++ | tools/build/Makefile-Moar.in:

[09:48] <dalek> nqp/moarboot: whitespace cleanup

[09:48] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/c847d0eff4

[09:55] *** yogan joined
[09:56] *** grondilu joined
[09:58] <dalek> Perlito: 6f61350 | (Flavio S. Glock)++ | / (3 files):

[09:58] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - operators

[09:58] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/6f61350e60

[10:01] <arnsholt> bbkr__: Most of the non-void ones are due to clang not handling GCC's "doesn't return" annotations, but I've found a bug as well

[10:05] *** [Sno] left
[10:09] <dalek> nqp: b1acc0b | (Arne Skj√¶rholt)++ | src/vm/parrot/pmc/sixmodelobject.pmc:

[10:09] <dalek> nqp: Add a missing return.

[10:09] <dalek> nqp: 

[10:09] <dalek> nqp: bbkr__++ for finding this. Fixes #35.

[10:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b1acc0bbe8

[10:09] <FROGGS> ohh, nice one

[10:18] *** hexcoder joined
[10:25] <hexcoder> Hi, i have a stupid beginners question. When using latest rakudo in REPL mode (without args), how am i supposed to enter multi line snippets?

[10:27] <hexcoder> I tried pasting these 5 lines, but the block spanning 3 lines was not accepted.

[10:27] <hexcoder>     my @array = 1, 2, 3, 'foo';     my $sum = @array[0] + @array[1];     if $sum > @array[2] {         say "not executed";     }

[10:27] <hexcoder> Hm, here they are join into one line

[10:28] <hexcoder> Hm, here they are joined into one line

[10:28] <FROGGS> that might be due to your irc client

[10:28] <hexcoder> yes

[10:28] <FROGGS> i'm not a REPL user so I dunno if you can have multi-line statements at all

[10:28] <FROGGS> why not paste it as one line in the repl?

[10:29] <FROGGS> r: my @array = 1, 2, 3, 'foo';     my $sum = @array[0] + @array[1];     if $sum > @array[2] {         say "not executed";     }

[10:29] <camelia> rakudo c6d5c9: ( no output )

[10:29] <jnthn> It doesn't do multi-line statements

[10:29] <hexcoder> I thought for testing many small snippets , this was the way to go...

[10:29] <hexcoder> ok, thanks.

[10:29] <jnthn> Each line has to be valid syntax on its own

[10:29] <FROGGS> r: my @array = 1, 2, 3, 'foo';     my $sum = @array[0] + @array[1];     unless $sum > @array[2] {         say "not executed";     }

[10:29] <camelia> rakudo c6d5c9: OUTPUT¬´not executed‚ê§¬ª

[10:29] <jnthn> However, variables or functions declared on previous lines are visible to subsequent lines.

[10:30] <FROGGS> hexcoder: you can privmsg camelia and test there too if you want

[10:30] <hexcoder> So I would have to write scripts. This is the easiest way?

[10:30] <hexcoder> ok, will try camelia...

[10:32] <FROGGS> scripts have the benefit that you can change previous lines... that is sort of impossible with a REPL

[10:32] <arnsholt> jnthn: I think we can close NQP #66, but I'm not quite sure. Care to have a look?

[10:32] <arnsholt> Or maybe not close, but I think I found the issue at hand at least

[10:34] <jnthn> yeah. I bet that's gonna vary by platform too

[10:34] <hexcoder> r:     my @array = 1, 2, 3, 'foo';     my $sum = @array[0] + @array[1];     if $sum > @array[2] {         say "not executed";     }

[10:34] <camelia> rakudo c6d5c9: ( no output )

[10:34] <arnsholt> bbkr__: I'd love an OS X shell, BTW!

[10:34] <jnthn> On JVM, WVal lookups resolve once. Moar does them pretty efficiently too

[10:34] <jnthn> On Parrot I think it's actually a hash lookup...

[10:35] <arnsholt> My old Mac laptop has been retired, which makes it harder to test OS X specific things

[10:43] <dalek> Perlito: 66f5d76 | (Flavio S. Glock)++ | / (3 files):

[10:43] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - operators

[10:43] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/66f5d76dc8

[10:49] <bbkr__> arnsholt: did you get login info on private channel?

[10:57] *** [Sno] joined
[11:07] *** hummeleB1 joined
[11:13] *** ssutch left
[11:16] <lizmat> good *, #perl6!

[11:19] *** SamuraiJack__ joined
[11:25] <moritz> \o lizmat 

[11:28] *** finanalyst left
[11:30] *** finanalyst joined
[11:34] *** finanalyst left
[11:38] *** colomon joined
[11:38] <hexcoder> a question regarding read-only parameters for subs: sub try-to-reset($bar) { $bar = 2; }. Can this ever have a chance to succeed? If not, why let it compile?

[11:39] <jnthn> No, it won't, we just aren't doing the static analysis needed to rule it out at compile time yet.

[11:40] <jnthn> It'll probably be done in the optimization phase, when it's trying to prove other things about assignments.

[11:40] <hexcoder> great, thanks.

[11:40] <jnthn> Which is the same point it rejects sub calls with incorrect argument counts/types when it can.

[11:50] <lizmat> r: sub a ($a) {}; a()

[11:50] <camelia> rakudo c6d5c9: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Calling 'a' will never work with no arguments (lines 1, 1)‚ê§    Expected: :($a)‚ê§¬ª

[12:02] *** PacoAir joined
[12:22] *** lizmat left
[12:22] *** lizmat joined
[12:24] <dalek> Perlito: 413dc0d | (Flavio S. Glock)++ | / (3 files):

[12:24] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - number, apply

[12:24] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/413dc0d121

[12:24] *** lizmat left
[12:28] *** lizmat joined
[12:35] <timotimo> GlitchMr: i find it weird that you singled out heredocs allocating less cursors, when there were a whole bunch of commits removing all in all almost a million cursors (though some of those commits were in nqp)

[12:37] <timotimo> or was that half a million?

[12:40] <dalek> Perlito: f861f2b | (Flavio S. Glock)++ | / (2 files):

[12:40] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - number, apply (fix)

[12:40] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/f861f2bd75

[12:46] *** telex left
[12:52] *** aindilis left
[12:56] *** sisar joined
[12:58] <dalek> rakudo/nom: 889892a | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[12:58] <dalek> rakudo/nom: Simplify Bag.grab|pick|roll, they're really just the same

[12:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/889892abba

[12:58] <nwc10> good *, #perl6

[12:59] <timotimo> (* *, *)("good", Whatever.new, "#perl6")

[13:05] *** telex joined
[13:20] *** baest_ left
[13:28] <masak> good afty, #perl6

[13:28] <FROGGS> o/

[13:29] *** kathy joined
[13:29] *** kathy is now known as kathyz

[13:34] <dalek> rakudo/nom: c6b15dc | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[13:34] <dalek> rakudo/nom: Implement Bag|Mix.grabpairs, oddly enough exactly the same as Setty.grab

[13:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c6b15dc4d8

[13:36] <grondilu> maybe we need a PairContainer role or something?

[13:37] <moritz> Associative?

[13:37] <masak> r: say 40 + 2

[13:37] <camelia> rakudo 889892: OUTPUT¬´42‚ê§¬ª

[13:38] <masak> r: class Bird { method tweet { say "chirp!" } }; Bird.new.tweet

[13:38] <camelia> rakudo 889892: OUTPUT¬´chirp!‚ê§¬ª

[13:39] <jnthn> nqp-m: say('Moar frivolous evals!')

[13:39] <camelia> nqp-moarvm: OUTPUT¬´Moar frivolous evals!‚ê§¬ª

[13:39] <masak> nqp-moarvm! \o/

[13:40] <masak> m: say('does this work, then?')

[13:40] <masak> hm, I guess that should be reserved for Rakudo-on-Moar, anyway ;)

[13:40] <jnthn> Maybe we should save that one for Rakudo on Moar :)

[13:40] <masak> I think we should save that one for Rakudo on Moar.

[13:41] *** kathyz left
[13:41] <diakopter> let's save that one for Rakudo on Moar

[13:41] <diakopter> TimToady: you think we should save that one for Rakudo on Moar?

[13:42] <tadzik> we should save it for Rakudo/Moar

[13:42] <sisar> I've been out of the perl6 loop for some time. Any progress on S09 implementation on any VM?

[13:42] <masak> sisar: some, but not enough :)

[13:42] <masak> sisar: when it does progress, it will on all VMs, I wager.

[13:43] <masak> at least for Rakudo.

[13:43] <moritz> sisar: rakudo-jvm and rakudo-parrot now both support packed native lists, and Buf/Blob are implemented as those

[13:43] <jnthn> Well, Buf/Blob got improved which caused a bunch of the underlying work for native arrays to happen. And the postcircumfix changes happened which was also partly to help with native arrays :)

[13:44] *** baest joined
[13:44] * diakopter guesses who kathyz is

[13:44] <grondilu> r: my $b = Buf.new: (^10).roll(5);  $b[4] = 0;

[13:44] <camelia> rakudo 889892: OUTPUT¬´Cannot modify an immutable value‚ê§  in block  at /tmp/FwvL8Xd1s0:1‚ê§‚ê§¬ª

[13:44] <grondilu> n: my $b = Buf.new: (^10).roll(5);  $b[4] = 0;

[13:44] <sisar> masak, jnthn : i see.

[13:44] <camelia> niecza v24-98-g473bd20: OUTPUT¬´Unhandled exception: Cannot call new; none of these signatures match:‚ê§    Mu, *%_‚ê§  at /tmp/pQmkQy7rp5 line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4583 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4584 (m‚Ä¶¬ª

[13:44] <jnthn> diakopter: Given it ends in a z, I'd wager it's a Czech name :P

[13:44] <jnthn> uh, Polish

[13:44] <jnthn> argh ;)

[13:44] <grondilu> Buf is still not mutable, though

[13:45] <jnthn> grondilu: Yes, that's 'cus it needs the other piece we need for native arrays :)

[13:45] * diakopter guesses Chinese

[13:45] <sisar> Is there a major raodblock to S09 implementation or is it just simply lack of tuits ?

[13:47] <sisar> (of course, any major hurdle can be broken with enough tuits :p )

[13:48] <jnthn> I guess partly lack of tuits; various bits of it need work at quite a few different levels of the stack.

[13:48] <sisar> jnthn: ok

[13:48] <jnthn> From my perspective, some of S09 falls into "nice to have" rather than "priority" also.

[13:50] <jnthn> I suspect the native array stuff will happen in the not too distant future given most of the pieces are in place.

[13:50] <jnthn> The PDL stuff I'd say is rather further out unless somebody jumps up to work on it.

[13:52] <sisar> the R metaop, where is it _really_ useful ? Where does it really simplify an expression ? Can someone give a good example.

[13:54] *** stevan_ joined
[13:54] <moritz> sisar: usually for non-comunitative operators

[13:54] <moritz> r: say [R-] 1, 2, 10

[13:54] <camelia> rakudo 889892: OUTPUT¬´9‚ê§¬ª

[13:55] <moritz> uhm

[13:55] <moritz> r: say [-] 10, 2, 1

[13:55] <camelia> rakudo 889892: OUTPUT¬´7‚ê§¬ª

[13:55] <moritz> masak: wanna submit rakudobug? (at least I think that's one)

[13:55] <masak> moritz: I'm just looking at it.

[13:55] <masak> moritz: are you sure?

[13:56] <masak> does R reverse the associativity?

[13:56] <jnthn> not afaik

[13:56] <masak> r: say (1 R- 2) R- 10

[13:56] <camelia> rakudo 889892: OUTPUT¬´9‚ê§¬ª

[13:56] <sisar> no, S03 says associativity is not reversed

[13:56] <masak> r: say 1 R- (2 R- 10)

[13:56] <camelia> rakudo 889892: OUTPUT¬´7‚ê§¬ª

[13:56] <masak> moritz: so, non-bug.

[13:57] <jnthn> STD doesn't reverse it either

[13:57] <jnthn> sisar: Maybe it's useful in whatever-star cases

[13:58] <jnthn> * / * is fine, but what if the things come in the wrong order?

[13:58] <jnthn> * R/ * then does it

[14:00] <sisar> jnthn: sorry, i still don't see it :(

[14:00] <sisar> where would such a thing come up ?

[14:00] <grondilu> r: say 1 R- 2 R- 10

[14:00] <camelia> rakudo 889892: OUTPUT¬´9‚ê§¬ª

[14:01] <grondilu> r: say 10 - 2 - 1

[14:01] <camelia> rakudo 889892: OUTPUT¬´7‚ê§¬ª

[14:02] <grondilu> r: say 2 ** 3 ** 4

[14:02] <camelia> rakudo 889892: OUTPUT¬´2417851639229258349412352‚ê§¬ª

[14:02] <sisar> I'm looking at http://rosettacode.org/wiki/Runge-Kutta#Perl_6 , is using R at line 3 really helping/simplifying things ?

[14:03] *** spider-mario left
[14:03] <moritz> sisar: it means one doesn't need parens

[14:03] <sisar> (I know it is a subjetive thing, but still )

[14:03] <grondilu> sisar: I wrote this.  I often write $n R/ [+] ...  because this allows me to avoid using parens

[14:04] <lizmat> cycling&

[14:04] <sisar> moritz, grondilu : ok. I'll think about it. Thanks.

[14:05] * sisar wishes state scoped term definitions were implemented, then the Runge-Kutta code can have sigilless Œ¥y too

[14:05] <sisar> (at line 5 )

[14:06] <grondilu> can't do that.  Sigilless terms can not be rw variable

[14:06] <sisar> grondilu: oh

[14:07] <grondilu> you can write 'my \n = 42;' but then n is a constant.

[14:08] <grondilu> though I guess there has to be ways to cheat

[14:08] <grondilu> r: sub foo is rw { state $ }; foo = 4;

[14:08] <camelia> rakudo 889892: OUTPUT¬´===SORRY!=== Error while compiling /tmp/SBZE274VQq‚ê§Preceding context expects a term, but found infix = instead‚ê§at /tmp/SBZE274VQq:1‚ê§------> sub foo is rw { state $ }; foo =‚èè 4;‚ê§¬ª

[14:08] <grondilu> r: sub foo is rw { state $ }; foo() = 4;

[14:08] <camelia> rakudo 889892: ( no output )

[14:09] <grondilu> r: sub foo is rw { state $ }; say foo() = 4;

[14:09] <camelia> rakudo 889892: OUTPUT¬´4‚ê§¬ª

[14:09] <sisar> grondilu: btw, output is slightly different from what is given. The printf "y(%2.0f) now gives output like y(0.) and y(1.) etc.

[14:09] <grondilu> hum, let me check

[14:10] <grondilu> ahh, I need to recompile rakudo first

[14:12] <grondilu> r: printf("%d", pi)

[14:12] <camelia> rakudo 889892: OUTPUT¬´3¬ª

[14:13] <sisar> r: printf "%2.0f", 2.000

[14:13] <camelia> rakudo 889892: OUTPUT¬´2.¬ª

[14:13] <grondilu> maybe just replace %2.0f with %d

[14:13] <grondilu> of %02d

[14:13] <grondilu> I mean %2d

[14:14] <sisar> grondilu: yup, i'll do that

[14:14] * sisar changes rosettacode

[14:15] *** fridim_ joined
[14:15] <sisar> done

[14:17] <grondilu> sisar++

[14:18] *** stevan_ left
[14:20] <grondilu> r: sub foo() is rw { state $ }; say foo() = 4;

[14:20] <camelia> rakudo c6b15d: OUTPUT¬´4‚ê§¬ª

[14:21] <grondilu> r: sub foo() is rw { state $ }; say foo = 4;

[14:21] <camelia> rakudo c6b15d: OUTPUT¬´===SORRY!=== Error while compiling /tmp/JtiSdrO5M_‚ê§Preceding context expects a term, but found infix = instead‚ê§at /tmp/JtiSdrO5M_:1‚ê§------> sub foo() is rw { state $ }; say foo =‚èè 4;‚ê§¬ª

[14:22] <grondilu> r: sub term:foo() is rw { state $ }; say foo = 4;

[14:22] <camelia> rakudo c6b15d: OUTPUT¬´===SORRY!===‚ê§No such method 'ast' for invocant of type 'NQPMu'‚ê§¬ª

[14:22] <sisar> grondilu: what does it mean when a sub is rw ?

[14:23] <grondilu> it means that it returns a lvalue

[14:23] <diakopter> "Rakudo on JVM is passing 99.28% of the spectests that Rakudo on Parrot does"

[14:23] <grondilu> r: sub term:<foo>() is rw { state $ }; say foo = 4;

[14:23] <camelia> rakudo c6b15d: OUTPUT¬´4‚ê§¬ª

[14:23] <diakopter> what's the new number for this

[14:23] <sisar> grondilu: ok, thanks.

[14:23] <tadzik> we should change the remaning test descriptions to "I am the 1%"

[14:24] <diakopter> "down with the 99%"

[14:25] <grondilu> r: sub term:<foo>() is rw { state $ }; foo = 4; say ++foo

[14:25] <camelia> rakudo c6b15d: OUTPUT¬´5‚ê§¬ª

[14:25] <jnthn> diakopter: Don't know because something is wrong with the automated run

[14:25] <diakopter> boo

[14:25] <grondilu> sisar: so sigilless variables are possible, but it's a cheat

[14:25] <diakopter> well is it below or above 100%

[14:27] *** ajr joined
[14:28] *** ajr is now known as Guest42553

[14:28] <jnthn> diakopter: Probably a little below; once we start getting tests for the concurrency stuff I suspect it'll get ahead, though...

[14:29] <benabik> r: my \foo; foo = 4; say ++foo

[14:29] <camelia> rakudo c6b15d: OUTPUT¬´===SORRY!===‚ê§No such method 'ast' for invocant of type 'NQPMu'‚ê§¬ª

[14:29] <benabik> LTA error

[14:30] *** Guest42553 is now known as ajr_

[14:30] *** stevan_ joined
[14:32] <felher> r: enum E < a b c>; my E $e = E.enums.keys[0] 

[14:32] <camelia> rakudo c6b15d: OUTPUT¬´Type check failed in assignment to '$e'; expected 'E' but got 'Str'‚ê§  in block  at /tmp/pbHmOWiv0g:1‚ê§‚ê§¬ª

[14:32] <felher> How do I get all E constants from the enum? E.enums.keys returns strings, not Es

[14:33] <jnthn> r: enum E < a b c>; my E $e = E.enums.values[0]

[14:33] <camelia> rakudo c6b15d: OUTPUT¬´Type check failed in assignment to '$e'; expected 'E' but got 'Int'‚ê§  in block  at /tmp/w5ZLw4llOT:1‚ê§‚ê§¬ª

[14:33] <jnthn> ah, yeah

[14:34] <jnthn> r: enum E < a b c>; my E $e = E.^enum_value_list[0]

[14:34] <camelia> rakudo c6b15d: ( no output )

[14:34] <jnthn> But surely there's a better way... :)

[14:34] <jnthn> Oh, E::.values works too I guess

[14:34] <jnthn> r: enum E < a b c>; my E $e = E::.values[0]

[14:34] <camelia> rakudo c6b15d: ( no output )

[14:35] <felher> jnthn: okay, I'll use E::.values, thanks :)

[14:35] <jnthn> yeah, that's a better way that relying on the enum MOP...

[14:35] <jnthn> I wonder if there shouldn't be a better way though.

[14:37] <felher> jnthn: how does E::.values work anyway? because E ist a package?

[14:37] <jnthn> Yes

[14:37] <jnthn> E:: gets the stash

[14:38] <felher> jnthn: yeah, then I guess there ought to be a more explicit way. :)

[14:44] *** BenGoldberg joined
[14:47] <dalek> ecosystem: b2dc645 | (Pawel Pabian)++ | META.list:

[14:47] <dalek> ecosystem: Added Text::Markov

[14:47] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/b2dc64560d

[14:47] <dalek> ecosystem: e1158c6 | tadzik++ | META.list:

[14:47] <dalek> ecosystem: Merge pull request #27 from bbkr/master

[14:47] <dalek> ecosystem: 

[14:47] <dalek> ecosystem: Added Text::Markov

[14:47] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e1158c62a1

[14:47] <tadzik> bbkr__++

[14:50] <moritz> huh. 109s for rakudo-jvm to parse the setting

[14:50] <moritz> that's... SLOW

[14:50] <jnthn> huh, yes

[14:50] <moritz> considering that rakudo-parrot took only about 140s

[14:50] <jnthn> It normally comes out well ahead here

[14:51] <moritz> and that's a java-7-oracle JVM + javac

[14:51] <FROGGS> I have 65s ommpared to 140s

[14:52] <jnthn> 45s vs 100s here

[14:52] <FROGGS> compared*

[14:58] *** xenoterracide_ joined
[15:00] <dalek> Perlito: 46c565c | (Flavio S. Glock)++ | / (3 files):

[15:00] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - lookup, index

[15:00] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/46c565ca11

[15:10] * [Coke] yawns.

[15:10] <hexcoder> r: @@( <a b>, <c d> ) == @( <a b>, <c d> )

[15:10] <camelia> rakudo c6b15d: ( no output )

[15:10] <hexcoder> r: say @@( <a b>, <c d> ) == @( <a b>, <c d> )

[15:10] <camelia> rakudo c6b15d: OUTPUT¬´True‚ê§¬ª

[15:11] * jnthn tries to work out what hexcoder is expecting that to mean and fails :)

[15:11] <hexcoder> i am exploring slice context, but fail too.

[15:12] <hexcoder> :r my @a = @@( <a b>, <c d> ); say @a

[15:13] <FROGGS> r: my @a = 'a' .. 'z'; say @a[0; 2]

[15:13] <camelia> rakudo c6b15d: OUTPUT¬´WARNINGS:‚ê§Useless use of constant integer 0 in sink context (line 1)‚ê§c‚ê§¬ª

[15:13] <FROGGS> r: my @a = ^10; say @a[0, 2]

[15:13] <camelia> rakudo c6b15d: OUTPUT¬´0 2‚ê§¬ª

[15:13] <dalek> Perlito: 71da9bc | (Flavio S. Glock)++ | / (2 files):

[15:13] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - slices

[15:13] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/71da9bcdde

[15:14] <FROGGS> r: my @a = 'a'..'z'; say @a[0, 2] # that is what I meant

[15:14] <camelia> rakudo c6b15d: OUTPUT¬´a c‚ê§¬ª

[15:14] <hexcoder> no, i meant the slice contextualizer that moritz describes in his document Perl 5 to Perl 6 in chapter 'Context'

[15:15] <hexcoder> @() should flatten, and @@() should not.

[15:15] <FROGGS> r: say @( <a b>, <c d> )

[15:15] <camelia> rakudo c6b15d: OUTPUT¬´a b c d‚ê§¬ª

[15:15] <FROGGS> hexcoder: I think @@() is not yet implemented

[15:15] <FROGGS> r: say @( <a b>, <c d> ).perl

[15:16] <camelia> rakudo c6b15d: OUTPUT¬´(("a", "b"), ("c", "d")).list‚ê§¬ª

[15:16] <hexcoder> ah, and suddenly everything makes sense :-))) thanks!!

[15:16] <FROGGS> so, @() does the job of @@() atm

[15:16] <FROGGS> hexcoder: you're welcome :o)

[15:17] <hexcoder> I agree, I could not even find it in the Synopsis. Or is it in already?

[15:17] <dalek> perl6-roast-data: c35c60b | coke++ | / (5 files):

[15:17] <dalek> perl6-roast-data: today (automated commit)

[15:17] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c35c60b457

[15:17] <jnthn> I think @@ went away, fwiw

[15:19] <FROGGS> ahh, that explains it then :o)

[15:20] * masak greps the logs

[15:20] <masak> yeah. it was removed in Feb 2010.

[15:20] <masak> **@ is still alive and well, though.

[15:21] <hexcoder> Thanks folks. I will tell Moritz...

[15:21] <jnthn> yeah, but that ain't a conextualizer...

[15:21] <moritz> hexcoder: did you read it on one of my websites?

[15:21] <hexcoder> Yes

[15:21] <hexcoder> http://perlgeek.de/en/article/5-to-6

[15:22] <BenGoldberg> r: say ^'z'

[15:22] <camelia> rakudo c6b15d: OUTPUT¬´Cannot call 'Real'; none of these signatures match:‚ê§:(Mu:U \v: Mu *%_)‚ê§  in method Real at src/gen/CORE.setting:944‚ê§  in method new at src/gen/CORE.setting:6814‚ê§  in method new at src/gen/CORE.setting:6794‚ê§  in sub prefix:<^> at src/gen/CORE.setting:6‚Ä¶¬ª

[15:23] <hexcoder> moritz: I will sent all of my findings combined to you. Stay tuned...

[15:24] * moritz stays tuned, ++hexcoder

[15:25] * [Coke] tries to think of a good way to debug this stupid rakudo.jvm failure on the test box.

[15:25] * [Coke] supposes he could attach visualvm and sit around for 2 hours.

[15:26] <jnthn> [Coke]: Does it only happen under the eval server?

[15:31] *** rindolf joined
[15:37] *** kaare__ joined
[15:40] <[Coke]> jnthn: that's an excellent thing to to test.

[15:41] *** kaare_ left
[15:41] <[Coke]> aha!

[15:41] <[Coke]> looks like this time my "log the eval serve" thing worked.

[15:42] <[Coke]> https://gist.github.com/coke/6855515 - OOME

[15:42] <[Coke]> of course, it has no useful details. :)

[15:43] <BenGoldberg> r: my @a; say (@a xx *)[0];

[15:43] <camelia> rakudo c6b15d: OUTPUT¬´(timeout)¬ª

[15:43] <BenGoldberg> Should xx check if it's first argument is an empty list?

[15:49] *** araujo left
[15:49] *** araujo joined
[15:50] *** sisar left
[15:57] <moritz> [Coke]: you could check if t/spec/S02-types/array.t OOMs

[15:58] <moritz> [Coke]: that's the test file that causes problems on my boxes with parakudo

[16:18] *** stevan_ left
[16:22] *** xinming left
[16:25] *** xinming joined
[16:25] *** ssutch joined
[16:34] <masak> BenGoldberg: seems to me `(() xx *)[0]` falls within "doctor, it hurts when I do this" territory. just like `loop {}`

[16:36] <TimToady> r: say (() xx *).lol[^10].perl

[16:36] <camelia> rakudo c6b15d: OUTPUT¬´(ListIter.new(), Any, Any, Any, Any, Any, Any, Any, Any, Any)‚ê§¬ª

[16:36] <TimToady> lol should not flatten ()

[16:36] <moritz> r: say (() xx *).lol[^10].elems

[16:36] <camelia> rakudo c6b15d: OUTPUT¬´Inf‚ê§¬ª

[16:36] <moritz> r: say (() xx *).lol[^10].tree.elems

[16:36] <camelia> rakudo c6b15d: OUTPUT¬´Inf‚ê§¬ª

[16:37] <moritz> r: say (() xx 5).lol.perl

[16:37] <camelia> rakudo c6b15d: OUTPUT¬´LoL.new(ListIter.new())‚ê§¬ª

[16:37] <moritz> r: say (() xx 5).lol.elems

[16:37] <camelia> rakudo c6b15d: OUTPUT¬´1‚ê§¬ª

[16:37] <dalek> Perlito: 5a62cef | (Flavio S. Glock)++ | / (3 files):

[16:37] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - map

[16:37] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/5a62cefa11

[16:37] <TimToady> I'd think () xx 5 should return (),(),(),(),()

[16:38] <TimToady> and lol should turn that into [],[],[],[],[]

[16:38] * grondilu thinks about 'loop {}'   Something bugs him about it

[16:38] <TimToady> or something equivalently itemy

[16:39] <TimToady> loop is both a noun and a verb, so you can think of it either way

[16:40] <TimToady> r: (loop {})[^10].perl.say

[16:40] <camelia> rakudo c6b15d: OUTPUT¬´(timeout)¬ª

[16:40] <grondilu> currently, 'loop {}' hangs, right?  I wonder if, for a language that is supposed to allow parallelism, it is not a bad idea.  Maybe loop {} should do just nothing.

[16:40] <TimToady> the imperative mindset is difficult to subvert :)

[16:40] <grondilu> I guess it is

[16:40] <TimToady> it should do the same thing as () xx * :)

[16:41] <TimToady> by current spec, which people keep carping about :)

[16:41] * grondilu remembers that he once thought there should be an entire synopys dedicated to degenerate cases.

[16:42] <TimToady> we do probably need to exempt loops at statementlist level from being lazy though

[16:42] <masak> if you ask me, `loop {}` is behaving exactly as it should.

[16:42] <masak> you ordered an infinite loop? well, you have it.

[16:42] <TimToady> there's that imperative mindset again :)

[16:42] <grondilu> :)

[16:42] <TimToady> the question is not whether it's infinite, but whether it's lazy

[16:42] <jnthn> loops kinda are imperative... :)

[16:44] <grondilu> they are imperative 'inside' the loop.  But from an external point of view, they are a member of a program that does not have to be imperative.

[16:45] <jnthn> Maybe, but I think at least culturally loops are seen as an imperative construct, and the functional constructs are spelt more like "map" :)

[16:46] <masak> the fact that I have an imperative mindset (and that I consider it "correct" here) was my entire point.

[16:47] <jnthn> Heck, when I'm teaching Linq I even find myself saying "it's nice because we don't have a load of loops, just nice declarative code saying how to process the stream of things coming through the enumerable"...

[16:48] *** diakopter left
[16:49] <BenGoldberg> r: gather { loop {} };

[16:49] <camelia> rakudo c6b15d: OUTPUT¬´(timeout)¬ª

[16:49] <BenGoldberg> r: gather { loop {} }; 1;

[16:49] * grondilu wonders if loop {} is not the same kind of undefined notion as 0 * Inf

[16:49] <ingy> want to be a Perl 6 programmer? so how many mindsets do you have? 3? hmmmm... stick with Perl 5

[16:49] <camelia> rakudo c6b15d: OUTPUT¬´(timeout)¬ª

[16:49] <BenGoldberg> n: gather { loop {} }; 1;

[16:49] <camelia> niecza v24-98-g473bd20: ( no output )

[16:49] <benabik> Doesn't 0 * Inf = 0?

[16:50] <grondilu> benabik: no

[16:50] <benabik> r: print 0*Inf

[16:50] <camelia> rakudo c6b15d: OUTPUT¬´NaN¬ª

[16:50] <grondilu> 0 * Inf is undefined.

[16:50] <BenGoldberg> Why did gather { loop {} }; 1; hang in Rakudo?

[16:51] <BenGoldberg> rn: gather { die 'foo' }; 1;

[16:51] <camelia> niecza v24-98-g473bd20: ( no output )

[16:51] <camelia> ..rakudo c6b15d: OUTPUT¬´foo‚ê§  in block  at /tmp/lkkO7Msc9b:1‚ê§‚ê§¬ª

[16:52] <BenGoldberg> rn: gather { take 0; die 'foo' }; 1;

[16:52] <camelia> niecza v24-98-g473bd20: ( no output )

[16:52] <camelia> ..rakudo c6b15d: OUTPUT¬´foo‚ê§  in block  at /tmp/DlYXOBv0OP:1‚ê§‚ê§¬ª

[16:52] <BenGoldberg> rn: my @a := gather { take 0; die 'foo' }; @a;

[16:52] <camelia> niecza v24-98-g473bd20: ( no output )

[16:52] <camelia> ..rakudo c6b15d: OUTPUT¬´foo‚ê§current instr.: 'throw' pc 402312 (src/gen/CORE.setting.pir:169118) (src/gen/CORE.setting:10504)‚ê§called from Sub 'die' pc 42214 (src/gen/CORE.setting.pir:16280) (src/gen/CORE.setting:662)‚ê§called from Sub 'die' pc 42113 (src/gen/CORE.setting.pir:16224)‚Ä¶¬ª

[16:52] <BenGoldberg> rn: my @a := gather { take 0; throw 'foo' }; @a;

[16:52] <camelia> rakudo c6b15d: OUTPUT¬´===SORRY!=== Error while compiling /tmp/7HZWHGsU6d‚ê§Undeclared routine:‚ê§    throw used at line 1‚ê§‚ê§¬ª

[16:52] <camelia> ..niecza v24-98-g473bd20: OUTPUT¬´===SORRY!===‚ê§‚ê§Undeclared routine:‚ê§     'throw' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_‚Ä¶¬ª

[16:53] <BenGoldberg> EINSUFFICIENTCAFFIENE

[16:53] * grondilu is fine with gather { take 0; die }  dying.

[16:54] <BenGoldberg> grondilu: in sink context?

[16:54] <grondilu> yeah

[16:54] <grondilu> though I should check what sink contect means

[16:54] <BenGoldberg> Surely gather <anything> in sink context should be a no op.

[16:55] <BenGoldberg> It's like undef context in perl5

[16:55] <moritz> there might still be side effects

[16:55] <BenGoldberg> Err, !defined(wantarray) in perl5 :)

[16:55] <moritz> yes, void context

[16:55] <lue> hello world o/

[16:56] <BenGoldberg> rn: my @a := map { die if $_ > 0 } ^Inf; say @a[0];

[16:56] <camelia> rakudo c6b15d: OUTPUT¬´Cannot call 'map'; none of these signatures match:‚ê§:(&code, *@values)‚ê§  in sub map at src/gen/CORE.setting:1719‚ê§  in sub thread_junction at src/gen/CORE.setting:3123‚ê§  in method AUTOTHREAD at src/gen/CORE.setting:3151‚ê§  in sub map at src/gen/CORE.sett‚Ä¶¬ª

[16:56] <camelia> ..niecza v24-98-g473bd20: OUTPUT¬´(Any)‚ê§¬ª

[16:56] <BenGoldberg> rn: my @a := map { die if $_ > 0 }, ^Inf; say @a[0];

[16:56] *** zakharyas joined
[16:56] <camelia> rakudo c6b15d: OUTPUT¬´‚ê§  in block  at /tmp/VYAgyhd1Sq:1‚ê§‚ê§¬ª

[16:56] <camelia> ..niecza v24-98-g473bd20: OUTPUT¬´‚ê§¬ª

[16:57] <grondilu> rn: my @a := gather { take 1; say "bye" }; @a

[16:57] <BenGoldberg> rn: map { die if $_ > 0 }, ^Inf;

[16:57] <camelia> niecza v24-98-g473bd20: ( no output )

[16:57] <camelia> ..rakudo c6b15d: OUTPUT¬´bye‚ê§¬ª

[16:57] <camelia> niecza v24-98-g473bd20: ( no output )

[16:57] <camelia> ..rakudo c6b15d: OUTPUT¬´No exception handler and no message‚ê§‚ê§current instr.: 'throw' pc 402312 (src/gen/CORE.setting.pir:169118) (src/gen/CORE.setting:10504)‚ê§called from Sub 'die' pc 42298 (src/gen/CORE.setting.pir:16317) (src/gen/CORE.setting:665)‚ê§called from Sub '' pc 156 ((‚Ä¶¬ª

[16:58] <grondilu> rn: my @a := 1..*; @a

[16:58] <camelia> rakudo c6b15d, niecza v24-98-g473bd20: ( no output )

[16:59] <grondilu> rn: my @a := gather for 1..* { .take; say "." }; @a

[16:59] <camelia> niecza v24-98-g473bd20: ( no output )

[16:59] <camelia> ..rakudo c6b15d: OUTPUT¬´(timeout).‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§.‚ê§‚Ä¶¬ª

[17:00] <grondilu> BenGoldberg: you might be right.  There should not be evaluations in sink context.

[17:00] <moritz> grondilu: that's contrary to our current philosphy

[17:01] <moritz> which is: if you evaluate something in sink context, it's for its side effects, so it must be eagerly evaluated

[17:01] <grondilu> ok

[17:04] <dalek> Perlito: 2bdccfe | (Flavio S. Glock)++ | / (4 files):

[17:04] <dalek> Perlito: Perlito5 - perl5 - pretty-printer is the default perl5 backend

[17:04] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/2bdccfeedc

[17:21] <hexcoder> moritz: which of your email addresses should I use for feedback on 'Perl 5 to Perl6'?

[17:24] *** diakopter joined
[17:29] <moritz> hexcoder: [email@hidden.address]
[17:30] <dalek> Perlito: ac48c65 | (Flavio S. Glock)++ | / (2 files):

[17:30] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - more operators

[17:30] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/ac48c65ff9

[17:30] <dalek> Perlito: 8398d27 | (Flavio S. Glock)++ | / (2 files):

[17:30] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - tweak operators

[17:30] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/8398d27e48

[17:31] <hexcoder> :moritz done

[17:32] *** stevan__ joined
[17:33] *** btyler joined
[17:33] *** ajr_ left
[17:34] *** ajr joined
[17:35] *** ajr is now known as Guest44737

[17:35] *** Guest44737 is now known as ajr_

[17:58] *** araujo left
[17:59] *** araujo joined
[17:59] *** Rotwang joined
[18:02] *** ajr_ left
[18:04] *** Rotwang left
[18:20] *** SamuraiJack__ left
[18:27] <ingy> sorear: ping

[18:29] <dalek> roast: af7277f | (Elizabeth Mattijsen)++ | S02-types/ (3 files):

[18:29] <dalek> roast: Add tests for .grabpairs where they are not supposed to work

[18:29] <dalek> roast: review: https://github.com/perl6/roast/commit/af7277f102

[18:29] *** ajr_ joined
[18:30] *** darutoko left
[18:32] *** rindolf left
[18:38] <BenGoldberg> rn: my @a := gather { take 1; say 'bye' }; @a.eager;

[18:38] <camelia> rakudo c6b15d, niecza v24-98-g473bd20: OUTPUT¬´bye‚ê§¬ª

[18:42] <moritz> r: 'abcd'.substr(my @a = 1, 4).say

[18:42] <camelia> rakudo c6b15d: OUTPUT¬´cd‚ê§¬ª

[18:43] <FROGGS> ?

[18:43] <jnthn> that's like .substr(2) I guess 

[18:43] <lizmat> final value of the parcel ?  feels like a p5ism

[18:45] <lizmat> p5eval: my @a=(1,2,3,4); say $a[my @b=1,3]

[18:45] <p5eval> lizmat: 41

[18:45] <lizmat> p5eval: my @a=(1,2,3,4); $a[my @b=1,3]

[18:45] <p5eval> lizmat: 4

[18:46] <FROGGS> ahh, now I see it

[18:55] <xinming> I saw the methdo ucfirst is renamed to tc for Str, What does tc mean here please?

[18:56] <jnthn> xinming: title case

[18:56] <xinming> got it, thanks

[19:05] <dalek> Perlito: 18ea7c3 | (Flavio S. Glock)++ | / (2 files):

[19:05] <dalek> Perlito: Perlito5 - perl5 - pretty-printer - elsif

[19:05] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/18ea7c3f00

[19:09] <masak> lizmat: it's not final value of a parcel. it's its length.

[19:10] <lizmat> p5eval: my @a=(1,2,3,4); say $a[my @b=1,2]

[19:10] <p5eval> lizmat: 31

[19:10] <lizmat> ok, so it's not a p5ism

[19:13] <masak> I'm really glad we didn't inherit that one :)

[19:14] <masak> r: say 'abcd'.substr(my @a = 1, 4); say 'abcd'.substr(2)

[19:14] <camelia> rakudo c6b15d: OUTPUT¬´cd‚ê§cd‚ê§¬ª

[19:14] <masak> r: say [1, 4].elems

[19:14] <camelia> rakudo c6b15d: OUTPUT¬´2‚ê§¬ª

[19:14] <masak> r: say +[1, 4]

[19:14] <camelia> rakudo c6b15d: OUTPUT¬´2‚ê§¬ª

[19:14] <masak> r: say +my @a = 1, 4

[19:14] <camelia> rakudo c6b15d: OUTPUT¬´2‚ê§¬ª

[19:18] *** zakharyas left
[19:18] *** sisar joined
[19:32] *** Rotwang joined
[19:33] <lizmat> r: my $b=<a b b>.BagHash; $b.grab(*).say; $b.say

[19:33] <camelia> rakudo c6b15d: OUTPUT¬´b b a‚ê§BagHash.new(a(0), b(0))‚ê§¬ª

[19:34] <lizmat> oops, grab doesn't clean up

[19:35] <dalek> rakudo/nom: 08d0f14 | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[19:35] <dalek> rakudo/nom: Make sure Baggy.grab cleans up after itself

[19:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08d0f14e51

[19:38] <lizmat> TimToady: on the subject of typed Bag/Mix: the problem is that rakudo currently cannot serialize any typed hashes/arrays

[19:39] <lizmat> jnthn is aware of the pb, but for now is low on the list

[19:45] <jnthn> lizmat: We determiend it wasn't just about the setting also, iirc?

[19:47] <lizmat> jnthn is aware of the pb, but for now is low on the list

[19:47] <lizmat> Stage optimize   :  17.719

[19:47] <lizmat> Code ref 'Str' does not exist in serialization context

[19:47] <lizmat> so it happens in stage post

[19:48] <lizmat> you want me to try this with e.g. lib/Test.pm and see what happens ?

[19:49] *** japhb_ left
[19:50] <dalek> rakudo/nom: 2e2f5f0 | (Elizabeth Mattijsen)++ | src/core/Setty.pm:

[19:50] <dalek> rakudo/nom: Implement Setty.grabpairs for consistency

[19:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e2f5f0b0c

[19:50] <dalek> rakudo/nom: 7b98f86 | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[19:50] <dalek> rakudo/nom: Implement .grabpairs where they're *not* supposed to work

[19:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7b98f8698c

[19:52] <moritz> hexcoder++ # very good feedback on 5-to-6

[19:52] <japhb__> jnthn, did you have any thoughts on the multi problem I rambled about last night?

[19:52] <FROGGS> gnight

[19:53] <lizmat> jnthn: it *only* appears to be happening when compiling the setting

[19:53] <japhb__> gnight FROGGS 

[19:53] *** FROGGS left
[19:53] <lizmat> adding a typed hash spec to lib/Test.pm and doing a "./perl6 --stagestats --target=pir --output=lib/Test.pir lib/Test.pm" just works fine

[19:55] <jnthn> japhb__: Well, it's a language design issue rather than Rakudo not implementing current spec wrt multis, afaik. And yeah, it's a tricky issue...but multi-dispatch candidate lists being known lexically is *really* important for optimization, so we can't break that.

[19:55] <jnthn> japhb__: Which somewhat constrains the solution space...

[19:56] *** araujo left
[19:58] <ivanshmakov> S17 mentions continuations, but doesn‚Äôt seem to either describe them itself, or point to another document describing them.‚ÄÉWhere do I find more information on that?‚ÄÉhttp://perlcabal.org/syn/S17.html

[20:01] *** japhb_ joined
[20:02] <lue> ivanshmakov: unfortunately (if I remember correctly), S17 is severely undeveloped, so the stuff described inside is due for a lot more work.

[20:02] <lue> They do seem to be mentioned once in S09, and a few times in S04 however.

[20:03] <lizmat> indeed, S17 is mostly ~2005 ramblings, by yours truly among others  :-(

[20:03] *** araujo joined
[20:03] * lizmat is looking forward to get back to that once moarvm lands

[20:04] <jnthn> Well, S17 probably wants to become a description of the stuff that's actually implemented so far :)

[20:04] *** dmol left
[20:04] <jnthn> The answer on continuations, though, is that Perl 6 doesn't expose them at user level.

[20:05] <jnthn> The closest is gather/take, which is coroutine-powerful.

[20:05] <lizmat> jnthn: that's what I mean  :-)

[20:06] <jnthn> lizmat: Yeah, but no need to wait for MoarVM to evolve that. ;)

[20:06] <perigrin> ivanshmakov: the relatively ancient http://www.sidhe.org/~dan/blog/archives/000156.html helped me grasp the concept of continuations.

[20:07] *** dmol joined
[20:07] *** PacoAir left
[20:07] <arnsholt> jnthn: NQP inherits all of its CFLAGS from Parrot, right?

[20:08] <jnthn> yeah

[20:08] <jnthn> Believe so

[20:09] <arnsholt> 'Cause then I can punt #33 back to Parrot

[20:10] <lue> That reminds me, can anyone tell me why my long-ago change to syn_index.html to have a link to S99 still doesn't show up on either feather's or perlcabal's synopses indexes?

[20:10] <arnsholt> Not that compiler warnings are that big of a deal anyways

[20:12] <lue> (it should appear directly underneath the row for S33 fwiw)

[20:15] <japhb__> jnthn: How much does it weaken the multi optimizations if we drop from "absolute knowledge of all applicable candidates" to "the list of applicable candidates changes rarely"?

[20:18] *** araujo left
[20:18] *** araujo joined
[20:18] *** sisar left
[20:19] <lue> .oO(is it possible the index updater is not running? Both sites' indexes say they were last modified Wed 03 Apr 2013 02:01:04 AM PDT)

[20:19] <jnthn> japhb__: Means we can't inline at compile time.

[20:21] <jnthn> japhb__: So a $native_int + $native_int would have to compile down to a multi-dispatch and we are at the mercy of JIT compilers doing inlines to make adding two native integers together work out, rather than code-generating a simple add instruction, which is what happens today with compile-time inlining.

[20:22] <japhb__> jnthn: What about a fast generation check that fails out of the straight line path, and succeeds with fallthrough to code generated on the assumption that it hasn't changed?  Hmmm, come to think of it, for native ops, that's still a heckuva lot of overhead ...

[20:24] <japhb__> Kinda does assume the existance of a JIT that can hoist that check higher, though.

[20:31] <dalek> roast: 8379851 | (Elizabeth Mattijsen)++ | S02-types/ (3 files):

[20:31] <dalek> roast: Add tests for where .grabpairs *should* work

[20:31] <dalek> roast: review: https://github.com/perl6/roast/commit/8379851f16

[20:31] <lizmat> another ~70 tests or so

[20:32] <japhb__> TimToady: What are your thoughts on language decisions that penalize interpreters?  "Heck no!" ?  "It depends"?

[20:35] <jnthn> japhb__: Yeah, and while we *may* be able to use invokedynamic to each the JVM's JIT enough to actually do it with Perl 6 multi-dispatch...and of course we can do as we please in Moar...anything else is a bit more tricky

[20:36] *** PacoAir joined
[20:38] *** PacoAir left
[20:42] *** dmol left
[20:42] *** dmol joined
[20:45] *** stevan__ left
[20:46] <japhb__> Am I correct in assuming that no later-added multi candidate can contribute to an op that is *called* in the setting?

[20:48] <lizmat> depends, afaik: if you add a multi-method to Any, it will only work on objects that *are* Any, not on any of its subclasses

[20:48] <jnthn> The setting is the outermost lexical scope of the program, so what's visible there is what they see. Note that "later-added" doesn't actually add to the multi candidate lists of the operators as the setting sees them; rather, the dispatcher is derived...

[20:48] <jnthn> lizmat: We're doing multi subs here...

[20:49] <lizmat> ah, ok‚Ä¶   :-)  

[20:49] * lizmat goes back to lurk mode

[20:51] <japhb__> jnthn: Yeah, that's what I thought.  I just wanted to make sure I wasn't being pessimistic on account of an incorrect mental picture.

[20:54] *** ajr_ left
[20:59] <hexcoder> privmsg camelia

[21:02] <hexcoder> privmsg camelia :macro circumfix:¬´< >¬ª ($text) is parsed / <-[>]+> / {return $text.comb(rx/\S+/);}

[21:02] <grondilu> is parsed is NYI, isn't it?

[21:03] <grondilu> r: macro postfix:<????> is parsed { }

[21:03] <camelia> rakudo 7b98f8: OUTPUT¬´===SORRY!=== Error while compiling /tmp/C6Cr6Q03pm‚ê§Can't use unknown trait 'is parsed' in a macro+{precedence} declaration.‚ê§at /tmp/C6Cr6Q03pm:1‚ê§------> ‚ê§    expecting any of:‚ê§        rw parcel hidden_from_backtrace‚ê§        pure de‚Ä¶¬ª

[21:03] <hexcoder> might be, but rakudo expects a block after that, so I thought it understands it.

[21:04] *** skids left
[21:04] <grondilu> it doesn't, but it recognizes it as a trait

[21:04] <hexcoder> aha, I see.

[21:10] *** dmol left
[21:12] *** Rotwang left
[21:16] *** skids joined
[21:21] *** hummeleB1 left
[21:22] *** kaare__ left
[22:06] <dalek> rakudo/nom: d45e4da | (Elizabeth Mattijsen)++ | src/core/Backtrace.pm:

[22:06] <dalek> rakudo/nom: Add :named so that we can filter on named subs/methods

[22:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d45e4da126

[22:12] *** stevan_ joined
[22:31] *** hexcoder left
[22:36] *** stevan_ left
[22:52] <dalek> nqp/moarboot: 431c3b1 | jnthn++ | src/vm/moar/ (3 files):

[22:52] <dalek> nqp/moarboot: Properly handle --bootstrap on MoarVM backend.

[22:52] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/431c3b1af2

[22:52] <dalek> nqp/moarboot: 3f8a23c | jnthn++ | tools/build/Makefile-Moar.in:

[22:52] <dalek> nqp/moarboot: Correct backend name in Moar makefile.

[22:52] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/3f8a23c479

[22:52] <dalek> nqp/moarboot: ff77d36 | jnthn++ | src/vm/moar/stage0/ (9 files):

[22:52] <dalek> nqp/moarboot: Update stage0 for MoarVM to get various fixes.

[22:52] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/ff77d36708

[22:52] <dalek> nqp/moarboot: 78f4d64 | jnthn++ | src/NQP/Compiler.nqp:

[22:52] <dalek> nqp/moarboot: Tweak so that stage1 actually starts up.

[22:52] <dalek> nqp/moarboot: 

[22:52] <dalek> nqp/moarboot: Fails upon calling the first action method, however; some code-object

[22:52] <dalek> nqp/moarboot: related issue.

[22:52] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/78f4d649b0

[23:02] <dalek> rakudo/nom: 9947610 | (Elizabeth Mattijsen)++ | src/core/Backtrace.pm:

[23:02] <dalek> rakudo/nom: Add a .package method for convenience and abstraction

[23:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9947610458

[23:16] <lizmat> sleep&

[23:16] <timotimo> gnite lizmat 

[23:20] *** grondilu left
[23:33] *** JJesus joined
[23:41] *** cognominal left
[23:47] *** dwarring joined
[23:47] *** JJesus left
