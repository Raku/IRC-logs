[00:06] <ssutch> i am getting a right strange result from rakudo:

[00:06] <ssutch> https://gist.github.com/samuraisam/5778469

[00:13] *** Khisanth joined
[00:16] *** ggoebel left
[00:20] <colomon> ssutch: what code is generating that?

[00:21] <ssutch> the trace?

[00:21] <ssutch> it's Grammar::Tracer

[00:21] <colomon> the trace is from Grammar::Tracer

[00:21] <colomon> but the error message appears to be from your code after the match?

[00:21] <ssutch> no

[00:22] <ssutch> it's from the parse command

[00:22] <ssutch> if i put a single space " " in front of "ass" in that string, it parses just fine

[00:28] <ssutch> if i escape the opening bracket "{" then it merely fails to match

[00:28] <ssutch> dies: 'message fart {ass }'

[00:28] <ssutch> works: 'message fart { ass }'

[00:28] <ssutch> fails: 'message fart \{ass }'

[00:31] <ssutch> however, if i change message-body to the following, it works:

[00:31] <ssutch> token message-body { '{' [\s+]? <ident> [\s+]? '}' }

[00:33] *** adu left
[00:37] <ssutch> sorry, colomon, the file lines don't match up, this is copied from a file with a bunch of comments above 

[00:40] *** woolfy joined
[00:40] <ssutch> so this works, but my grammar is ugly as crap: https://gist.github.com/samuraisam/5778599 what can i do to clean it up (eg remove all the [\s+]?

[00:47] <colomon> is there some reason they can't just be \s*        

[00:47] <colomon> ?

[00:50] <colomon> or to put that another way: In general, I'd replace [<pattern>+]? with <pattern>*

[00:51] *** adu joined
[00:56] <sorear> ssutch: there's a standard rule <.ws> which does smart whitespace - \s* if punctuation on either side, \s+ if bracketed by word chars

[00:56] <sorear> ssutch: if you s/token/rule/, then all whitespace in the former token will implicitly become <.ws>

[00:57] <sorear>     token TOP { ^ [\s+]? <proto> [\s+]? $ }

[00:57] <sorear> can be rewritten as

[00:57] <sorear>     rule TOP { ^ <proto> $ }

[00:57] <ssutch> cooool

[00:57] <colomon> sorear++ # I was just looking that up, because I always forget which name means what in grammars.

[00:58] <sorear> this includes whitespace between the last token and the }, but does not include whitespace between the first token and the {

[00:58] <sorear> this behavior is used pervasively in parsing perl 6

[00:58] <ssutch> hmm, it doesn't work if i have a newline at the beginning of the file

[00:59] <ssutch>     rule TOP            { ^ <proto> $ }

[00:59] <sorear> you can override ws if you want to parse fancy forms of whitespace (like comments... and multiline comments... and Pod...)

[00:59] <sorear> hmm, might be rakudobug

[00:59] <ssutch> do i need to change my message to be something else then too?

[00:59] <sorear> r: (grammar G { rule TOP { ^ } }).parse("

[00:59] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Unable to parse expression in double quotes; couldn't find final '"'␤at /tmp/gzWfVpxMO7:1␤------> (grammar G { rule TOP { ^ } }).parse("⏏<EOL>␤    expecting any of:␤        method arguments␤        argument list␤   …

[00:59] <sorear> r: say (grammar G { rule TOP { ^ } }).parse("\n")

[00:59] <camelia> rakudo b2072f: OUTPUT«#<failed match>␤»

[01:00] <sorear> n: say (grammar G { rule TOP { ^ } }).parse("\n")

[01:00] <camelia> niecza v24-75-g480a062: OUTPUT«(Any)␤»

[01:00] <sorear> rr: say (grammar G { rule TOP {^ } }).parse("\n")

[01:00] <sorear> rn: say (grammar G { rule TOP {^ } }).parse("\n")

[01:00] <camelia> rakudo b2072f, niecza v24-75-g480a062: OUTPUT«｢␤｣␤␤»

[01:00] <sorear> ssutch: workaround: drop the space between { and ^

[01:00] <ssutch> doh

[01:01] <sorear> it's supposed to ignore that space, but apparently it's not

[01:01] <ssutch> yeah that works

[01:01] <ssutch> how can i fix that

[01:02] <sorear> ssutch: "how can i fix that" - you saying you want to hack rakudo itself now?

[01:02] <colomon> sorear: even if it didn't ignore that space, isn't <ws> zero or more whitespace characters?  is this a rachetting issue?

[01:02] *** fgomez joined
[01:02] <sorear> we're talking about the rakudobug now, yes?

[01:02] <sorear> colomon: rules always ratchet.

[01:02] <sorear> (as do tokens)

[01:02] <ssutch> sorear: yeah at least look at it

[01:02] <sorear> ssutch: hold on

[01:03] <colomon> rn: say (grammar G { regex :sigspace  { ^ } }).parse("\n")

[01:03] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤invoke() not implemented in class 'QAST::Op'␤»

[01:03] <camelia> ..niecza v24-75-g480a062: OUTPUT«===SORRY!===␤␤Colonpair traits NYI at /tmp/cmZTCEavEC line 1:␤------> say (grammar G { regex :sigspace  ⏏{ ^ } }).parse("\n")␤␤Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting …

[01:03] <sorear> S05:328 is the new rules

[01:03] <sorear> which aren't implemented in rakudo yet

[01:03] <ssutch> ah

[01:03] <sorear> (do you know Sxx:yyyy syntax?)

[01:04] <ssutch> do i? no

[01:04] *** anuby joined
[01:05] <colomon> ssutch: If you go to the irc log ( http://irc.perl6.org/) you'll find a link from the S05:328 to its position in the spec

[01:05] <ssutch> cool, thanks

[01:05] <colomon> xx is the synopsis number, yyy the line number in it.

[01:06] <colomon> but the link is the lazy man's way of finding it.  :)

[01:06] <ssutch> ah, i was figuring it was a perl construct

[01:06] <ssutch> but that makes sense, thanks

[01:06] <ssutch> https://github.com/perl6/roast/blob/master/S05-grammar/ws.t#L5-L34 ?

[01:06] <sorear> implementation seems to be https://github.com/perl6/nqp/blob/master/src/QRegex/P6Regex/Actions.nqp#L136

[01:08] *** adu left
[01:10] <ssutch> so the problem in this case is that S05:328 is not yet implemented in rakudo?

[01:11] <ssutch> or is it a bug when parsing "rule { ^"

[01:11] <ssutch> or the two are one in the same

[01:14] <sorear> well, the bug is that S05:328 is not implemented

[01:14] <sorear> there are at least two ways to go about fixing this

[01:15] <sorear> you can modify P6Regex::Grammar to gobble up irrelevant whitespace at the start of matches and alternatives;

[01:17] <sorear> or you can track the location of space fragments in P6Regex::Actions and remove the ones that shouldn't be used

[01:17] <sorear> you should also add better tests for this (ideally in S05-modifier/sigspace.t) because the current tests are quite incomplete

[01:27] <ssutch> damn, i don't think that i understand the stack well enough yet (eg how nqp relates to the rest of the parts) i understand that nqp is hosted on something (rakudo, rakudo-jvm, etc) and that in turn implements the language

[01:30] <ssutch> which is the more correct fix, to fix Actions or to fix Grammar?

[01:30] *** xenoterracide joined
[01:31] <colomon> n: say (grammar G { rule TOP { ^ } }).parse("\n")

[01:31] <camelia> niecza v24-75-g480a062: OUTPUT«(Any)␤»

[01:34] *** tgt left
[01:37] *** jlaire left
[01:37] *** jlaire joined
[01:41] <sorear> ssutch: I would try the grammar first

[01:46] <ssutch> how does this look for a test? https://github.com/samuraisam/roast/commit/c9d7034f6ed4ca825fe7c9cd7b03253f945d6c6a

[01:53] *** benabik left
[01:55] *** SamuraiJack joined
[01:56] *** bonsaikitten left
[01:56] <dalek> niecza: 3e65d84 | (Solomon Foster)++ | lib/CORE.setting:

[01:56] <dalek> niecza: Remove obsolete (I hope!) to-set coercion multis.

[01:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3e65d84576

[01:57] *** bonsaikitten joined
[01:59] <colomon> how does implicit anchoring work with something like TOP { ^ }  ?

[02:05] <sorear> ssutch: it's in the wrong file

[02:05] <ssutch> doh

[02:08] <ssutch> S05-modifier/sigspace.t? is it a decent test?

[02:08] <ssutch> i didn't see any other grammars in that file, so wasn't sure about it being the right place, or exactly how to explain its existence (sorry, im a newb here)

[02:14] <sorear> sigspace is the name of the feature by which whitespace matches whitespace

[02:14] <ssutch> ok, that makes sense

[02:14] <sorear> rule foo { ... } is similar to m :sigspace :ratchet /.../

[02:15] <ssutch> ah ok, thanks

[02:15] <lue> Can anyone tell me why S03/Adverbs is a head1, and in the middle of the sequence of precedence level head2's? It's always struck me as odd.

[02:18] <lue> (seems to me like it should be a =head2, if its location is due to the "at a pseudo-precedence level slightly tighter than item assignment" statement at the top of S03/Adverbs)

[02:23] *** SamuraiJack left
[02:25] *** SamuraiJack joined
[02:26] *** benabik joined
[02:31] <ssutch> sorear: this appears to work in rakudo: ok "\n\n\n" ~~ m:sigspace/^ $/, 'sigspace captures newline'

[02:31] <ssutch> however the rule one does not

[02:34] <sorear> ssutch: don't forget nok.  it's extremely important to test that things that shouldn't work don't

[02:34] <ssutch> ok

[02:35] <sorear> make sure you have tests that would fail if someone changed ws to .*

[02:35] <ssutch> so this: nok " " ~~ m:sigspace/^.*$/, 'sigspace should not capture .*'

[02:36] <sorear> ummmmm

[02:36] * sorear does not understand the confusion of ideas that could lead to such a test

[02:36] <ssutch> haha

[02:37] <ssutch> sorry

[02:37] <ssutch> yeah that's all confused

[02:39] <ssutch> sorear: what would be an example of what you meant?

[02:41] <ssutch> something more like: nok "asdf" ~~ m:sigspace/^ $/

[02:42] <sorear> any feature has certain limits of activity, and the tests need to constrain it from both sides

[02:42] <sorear> you need to make sure that spaces are not accepted where they shouldn't be

[02:42] <sorear> m:s/ foo / should match "foo " but not " foo"

[02:42] <sorear> :s is short for :sigspace

[02:44] *** atroxaper joined
[02:45] *** btyler joined
[02:46] *** _jaldhar_ joined
[02:46] <ssutch> ah ok

[02:47] <ssutch> ok, thank you so much for all the help (sorear, et al.)

[02:56] <diakopter> ssutch++ you rock

[03:13] *** Chillance joined
[03:20] *** ssutch left
[03:21] *** prevost joined
[03:22] *** geekosaur left
[03:29] *** mrallen1 joined
[03:36] *** Horace joined
[03:36] *** geekosaur joined
[03:37] *** Horace left
[03:39] <diakopter> so, I paid for the linkedin paid account, and now I get several times *more* spam from them

[03:41] <sorear> "let's milk the sucker"?

[03:43] <benabik> You obviously liked the service they were providing for free, so they gave you even more of it.

[03:47] <bonsaikitten> diakopter: funny thing - they offered me a 30-day free trial that expired

[03:47] <bonsaikitten> a day after it expired I got a totally new offer for a 30-day trial

[03:58] *** preflex_ joined
[03:58] *** ChanServ sets mode: +v preflex_

[04:00] *** preflex left
[04:00] *** preflex_ is now known as preflex

[04:23] *** btyler left
[04:26] *** sjn left
[04:28] *** raiph joined
[04:29] *** raiph left
[04:29] *** Patterner left
[04:31] *** Psyche^ joined
[04:31] *** Psyche^ is now known as Patterner

[04:37] *** sjn joined
[04:37] *** adu joined
[04:49] *** raiph joined
[04:50] <raiph> ssutch: fyi: http://rosettacode.org/wiki/Parse_EBNF#Perl_6

[04:53] *** birdwindupbird joined
[04:54] <sorear> trouble with EBNF is that there are quite a lot of variations

[04:55] *** btyler joined
[04:56] *** xenoterracide left
[05:20] *** raiph left
[05:45] *** mrallen1 left
[05:45] *** btyler left
[05:45] *** prevost left
[05:50] *** dmol joined
[05:50] *** dayangkun joined
[05:50] *** lustlife joined
[05:55] *** shachaf left
[06:00] *** dmol left
[06:02] *** dmol joined
[06:04] *** salv0 left
[06:05] *** shachaf joined
[06:07] *** salv0 joined
[06:27] *** PacoAir joined
[06:29] *** dmol left
[06:31] *** FROGGS joined
[06:34] *** PacoAir left
[06:35] *** xinming joined
[06:39] *** xinming_ left
[06:47] *** tomyan joined
[06:47] *** domidumont joined
[06:55] <FROGGS> o/

[06:55] *** domidumont left
[06:56] *** domidumont joined
[07:00] *** sjn left
[07:02] *** tomyan left
[07:06] *** woolfy left
[07:08] *** lizmat left
[07:11] *** adu left
[07:12] *** arlinius left
[07:18] *** dayangkun left
[07:27] *** sjn joined
[07:36] *** kresike joined
[07:36] <kresike> hello all you happy perl6 people

[07:38] <FROGGS> hi kresike 

[07:39] <kresike> FROGGS, o/

[07:41] *** arlinius joined
[07:42] *** GlitchMr left
[07:48] *** cognominal joined
[07:57] *** fhelmberger joined
[07:58] *** GlitchMr joined
[08:01] *** sjn left
[08:09] *** atroxaper left
[08:13] *** lizmat joined
[08:25] *** cibs_ left
[08:25] *** cibs joined
[08:27] <lizmat> morning #perl6!

[08:29] *** pochi joined
[08:30] *** pochi_ left
[08:38] *** rindolf joined
[08:42] <lizmat> r: my @a=0..Inf; @a.push(1)

[08:42] <camelia> rakudo b2072f: OUTPUT«.push on infinite lists NYI␤current instr.: 'throw' pc 347557 (src/gen/CORE.setting.pir:151689) (src/gen/CORE.setting:8887)␤called from Sub 'sink' pc 379739 (src/gen/CORE.setting.pir:164183) (src/gen/CORE.setting:10169)␤called from Sub 'MAIN' pc 381 (src/gen/perl6.…

[08:42] <lizmat> .push on infinite lists NYI ??  will that *ever* work?

[08:42] <moritz> no

[08:42] *** ssutch joined
[08:42] <moritz> feel free to update the error message

[08:42] <lizmat> :-)

[08:43] *** rindolf left
[08:48] <mathw> morning

[08:48] <lizmat> morning!

[08:49] <lizmat> r: my @a=0..Inf; @a.sort # huh?

[08:49] <camelia> rakudo b2072f: OUTPUT«Cannot index Array with 10 11 12 13 ...␤  in method at_pos at src/gen/CORE.setting:6638␤  in method at_pos at src/gen/CORE.setting:1618␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1540␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1489␤  in bl…

[08:49] <lizmat> feels like a similar message like the one for .push on infinite list is needed here ?

[08:50] <moritz> aye

[08:54] <lizmat> also for classify and categoriize  :-)

[08:55] <moritz> r: say (1..*).categorize({ last }).perl

[08:55] <camelia> rakudo b2072f: OUTPUT«No such method 'categorize' for invocant of type 'Range'␤  in block  at /tmp/diNjcPUeKw:1␤␤»

[08:55] <moritz> r: say (1..*).list.classify({ last }).perl

[08:55] <camelia> rakudo b2072f: OUTPUT«().hash␤»

[08:55] <lizmat> r: my @a=0..Inf; @a.classify( {$_} )  # timeouts

[08:56] <camelia> rakudo b2072f: OUTPUT«(timeout)»

[08:56] *** sjn joined
[08:56] <moritz> lizmat: the point I'm trying to make is that there are cases where .classify terminates

[08:57] <lizmat> ah, ok…  hmmmm….

[08:59] <moritz> maybe dying/failing is still the right thing to do, because last() in classify arguments isn't the normal use case

[08:59] <moritz> but that's a decision we need to make, not something automatic

[09:01] <lizmat> feels to me that it should fail, and one could consider the use of "last" or any other loop related statement to be a Bad Thing

[09:02] <lizmat> I'll make a spec issue out of category/classify's behaviour on infinite lists

[09:03] <lizmat> also: what is the difference between "$!nextiter.defined" and "self.inifinite".  is the latter just a newer form?

[09:10] *** drin_m joined
[09:13] <lizmat> also: .classify and .categorize are both specced to return Hash.  In fact, .classify returns %result, and .categorize returns %result.pairs.

[09:13] <lizmat> feels to me .categorize is wrong

[09:13] *** cognominal left
[09:15] <lizmat> r: say (^5).list.classify( {$_} ).WHAT, say (^5).list.categorize( {$_} ).WHAT # should be Hash,Hash

[09:15] <camelia> rakudo b2072f: OUTPUT«(List)␤(Hash)True␤»

[09:15] <lizmat> r: say (^5).list.classify( {$_} ).WHAT; say (^5).list.categorize( {$_} ).WHAT # should be Hash,Hash

[09:15] <camelia> rakudo b2072f: OUTPUT«(Hash)␤(List)␤»

[09:21] <lizmat> Behavior of .classify and .categorize on infinite lists: https://github.com/perl6/specs/issues/52

[09:37] *** daxim joined
[09:40] *** salv0 left
[09:43] *** salv0 joined
[09:51] *** sqirrel joined
[09:55] <dalek> rakudo/nom: 5b61bcc | (Elizabeth Mattijsen)++ | src/core/List.pm:

[09:55] <dalek> rakudo/nom: Make sure some list methods fail (early) on infinite list

[09:55] <dalek> rakudo/nom: 

[09:55] <dalek> rakudo/nom: I wonder whether "infinite" shouldn't become a true attribute on List, rather

[09:55] <dalek> rakudo/nom: than a method that calculates stuff.  And/or use MMD with a different candidate

[09:55] <dalek> rakudo/nom: for Infinite lists.

[09:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b61bccb32

[09:55] <lizmat> lunch&

[09:55] *** lizmat left
[10:18] *** anuby left
[10:40] *** eternaleye joined
[10:41] *** lizmat joined
[10:41] *** mtk left
[10:45] *** mtk joined
[10:46] *** woolfy joined
[10:46] *** GlitchMr left
[10:55] <lizmat> r: my %h; %h<a>.push(1); say %h  # I guess %h<a> //= [] isn't necessary anymore ?

[10:56] <camelia> rakudo b2072f: OUTPUT«("a" => [1]).hash␤»

[11:00] *** chutchut joined
[11:04] *** ssutch left
[11:04] * lizmat drops a pin

[11:04] <moritz> lizmat: it's probably from before autovivification

[11:05] * moritz catches the pin before it hits the floor

[11:05] <lizmat> :-)

[11:05] <moritz> in space, nobody can hear your pins!

[11:05] * moritz has to wait 30 minutes for a test run to finish :/

[11:06] * lizmat knows the feeling

[11:08] *** woolfy left
[11:10] <moritz> (not rakudo though; some accounting stuff at $work)

[11:11] <dalek> nqp: 72d5841 | sorear++ | src/vm/jvm/ (2 files):

[11:11] <dalek> nqp: Add nqp::continuation* to the compiler, stub runtime

[11:11] <dalek> nqp: review: https://github.com/perl6/nqp/commit/72d58413cb

[11:15] *** GlitchMr joined
[11:16] <dalek> rakudo/nom: 856bc55 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[11:16] <dalek> rakudo/nom: Remove unneccesary vivication, they autovivify now.

[11:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/856bc555dd

[11:16] <dalek> rakudo/nom: d412678 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[11:16] <dalek> rakudo/nom: Make .categorize return Hash rather than a Parcel of Pairs

[11:16] <dalek> rakudo/nom: 

[11:16] <dalek> rakudo/nom: To match S32/Containers:191

[11:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4126784b1

[11:19] *** GlitchMr left
[11:23] *** eternaleye left
[11:27] *** JimmyZ joined
[11:29] *** eternaleye joined
[11:33] <dalek> nqp: 948a2ce | sorear++ | docs/continuations.pod:

[11:33] <dalek> nqp: Initial documentation for the continuations feature

[11:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/948a2ce99a

[11:35] <sorear> After I add t/jvm, should I just add it to tools/Makefile-JVM.in or is there a better place?

[11:39] <JimmyZ> I guess Makefile-JVM

[11:48] *** tgt joined
[11:48] *** tgt left
[11:52] <dalek> rakudo/nom: ac36cac | (Elizabeth Mattijsen)++ | src/core/List.pm:

[11:52] <dalek> rakudo/nom: Add :keytype and :of named parameters to classify / categorize

[11:52] <dalek> rakudo/nom: 

[11:52] <dalek> rakudo/nom: So that we can return non-string values from test block if necessary.  This

[11:52] <dalek> rakudo/nom: is unspecced.  If this feels right for TimToady / pmichaud, it should be

[11:52] <dalek> rakudo/nom: specced.  If this doesn't feel right, then I'll revert this patch.

[11:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac36cacbb5

[11:52] <dalek> rakudo/nom: 5642f03 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[11:52] <dalek> rakudo/nom: Some more things needed to make :keytype and :of work on classify|categorize

[11:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5642f03e5e

[11:53] <sorear> sleep&

[11:54] <moritz> good night sorear 

[11:57] *** lizmat left
[12:00] *** kaleem joined
[12:01] *** Shozan is now known as SHODAN

[12:08] *** lizmat joined
[12:14] <lizmat> .(classify|categorize) specced as of Hash, but returns pairs  https://github.com/perl6/specs/issues/53

[12:16] *** bbkr joined
[12:16] * colomon tries to remember back to the days of implementing those....

[12:19] *** tgt joined
[12:19] *** _jaldhar_ left
[12:25] <lizmat> r: class A {}; my %h=A.new => 1; say %h; my %h2{Str}=A.new => 1; say %h2  # feels to me either both should fail, or both should work

[12:25] <camelia> rakudo b2072f: OUTPUT«("A<-465252350>" => 1).hash␤Nominal type check failed for parameter 'key'; expected Str but got A instead␤  in method STORE_AT_KEY at src/gen/CORE.setting:7122␤  in method STORE at src/gen/CORE.setting:7018␤  in block  at /tmp/Au8hPaHP4v:1␤␤»

[12:27] *** kivutar joined
[12:31] <colomon> n: class A {}; my %h=A.new => 1; say %h; my %h2{Str}=A.new => 1; say %h2  # feels to me either both should fail, or both should work

[12:31] <camelia> niecza v24-76-g3e65d84: OUTPUT«===SORRY!===␤␤Postconstraints, and shapes on variable declarators NYI at /tmp/Q3c0g4J0qV line 1:␤------> }; my %h=A.new => 1; say %h; my %h2{Str}⏏=A.new => 1; say %h2  # feels to me eith␤␤Unhandled exception: Check fail…

[12:31] <colomon> std: class A {}; my %h=A.new => 1; say %h; my %h2{Str}=A.new => 1; say %h2  # feels to me either both should fail, or both should work

[12:31] <camelia> std 6348f35: OUTPUT«ok 00:01 45m␤»

[12:37] *** lizmat left
[12:37] *** lizmat joined
[12:45] <moritz> colomon: the default %h is more like %h{Str(Any)} # though nobody implements that

[12:45] <moritz> or was it Any(Str)? I can never remeber which one is the type, and which one is the coercion

[12:45] <lizmat> %h{Str} of Any

[12:46] <lizmat> is the way I remember it

[12:48] <moritz> the 'of Any' is the type that values can have

[12:48] <colomon> I see.

[12:49] <moritz> what I meant is the types from which keys can be coerced to Str

[12:50] <colomon> lizmat: to take a simpler example, I know I certainly expect to be able to use Int keys in a normal hash, with the understanding they are implicitly converted to Str in the process.

[12:50] * colomon does that pretty routinely in p6

[12:51] <lizmat> I would probably do that too, but wonder whether that isn't too P5ish

[12:51] <colomon> At the same time, %h{A} probably shouldn't default to trying to convert whatever it gets to A.

[12:52] <lizmat> generally, in P5, using an object as a key was an error, unless you really knew what you were doing

[12:52] <moritz> but Int is a value type

[12:52] <moritz> not an object type

[12:52] <moritz> so Ints are fine

[12:52] *** konundra joined
[12:53] <colomon> moritz: I'm not sure I follow that distinction here?

[12:53] <moritz> 14:52 < lizmat> generally, in P5, using an object as a key was an error, unless  you really knew what you were doing

[12:53] <moritz> that's what I was commenting on

[12:53] <colomon> I see

[12:53] <lizmat> r: my %h{Str}= 1 => "a"

[12:53] <camelia> rakudo b2072f: OUTPUT«Nominal type check failed for parameter 'key'; expected Str but got Int instead␤  in method STORE_AT_KEY at src/gen/CORE.setting:7122␤  in method STORE at src/gen/CORE.setting:7018␤  in block  at /tmp/PrOCQUc6BA:1␤␤»

[12:53] <[Coke]> what is "value vs object" ? should that instead be "value vs. container" ?

[12:54] <lizmat> colomon: you expect that to work, right?

[12:54] <colomon> lizmat: I expect my %h = 1 => "a" to work.  

[12:54] <colomon> I dunno about %h{Str}

[12:55] <moritz> [Coke]: "contianer" has too many meanings in Perl 6 already

[12:55] <lizmat> well, by spec: %h is equivalent yo %h{Str}

[12:55] <moritz> *container

[12:55] <moritz> lizmat: that part is most certainly wrong

[12:55] <colomon> I kind of like the idea (which moritz seemed to imply) that default hash accepts anything but converts it to Str.

[12:55] <moritz> that's not just an idea; it's what's implemented right now

[12:55] <colomon> whatever the syntax for specifying that is

[12:56] <colomon> of course

[12:56] *** kresike left
[12:56] *** kresike joined
[12:57] <bbkr> https://gist.github.com/bbkr/5781598 - libresolv SegFault, known issue?

[12:57] <lizmat> colomon: do you expect "my %h= A.new => 1" to work?

[12:58] <moritz> bbkr: never seen it before

[12:58] <[Coke]> bbkr: me either.

[12:58] <moritz> fwiw I really think we should have a way to mark classes as being value types

[12:58] <bbkr> ah, it's not libresolv (this lib is just mentioned in memory map)

[12:58] <moritz> and if they aren't, refuse to let them work as hash keys

[12:59] <lizmat> but doing that check on untyped hashes, would slow things down significantly

[12:59] <lizmat> and would go against perl5 expectations

[13:00] <bbkr> I'll try extract minimum code required to reproduce this segfault, although it is random one.

[13:00] <lizmat> bbkr: doesn't ring a bell

[13:00] <moritz> lizmat: I meant at hash Hash.new time, not at insertion time

[13:00] <moritz> or rather at declaration time

[13:00] <moritz> class A { }; my %h{A.new()}  # dies

[13:01] <lizmat> why should that die?

[13:01] <lizmat> ah, of course

[13:01] <lizmat> are you sure you don't mean my %h{A} ?

[13:03] *** census joined
[13:04] <moritz> you're right, %h{A}

[13:05] <lizmat> why should that die?

[13:05] <moritz> because A isn't a value type

[13:06] <colomon> lizmat: I expect my %h= A.new => 1 to "work", in the sense that A gets stringified.

[13:06] <lizmat> moritz: why would that matter? 

[13:06] <colomon> shouldn't the hash be keyed on object identity in that case?

[13:07] <lizmat> colomon: but then, if you do keys(), you won't get the object back

[13:07] <colomon> (%h{A}, I mean)

[13:07] <colomon> lizmat: right, just like you get "1" instead of 1 if you use 1 as a key

[13:08] * colomon thought about these issues a couple of weeks ago with regard to Set (etc)

[13:08] <lizmat> not necessarily

[13:08] <lizmat> r: my %h{Int}= 1 => "a"; .WHAT.say for %h.keys

[13:08] <camelia> rakudo b2072f: OUTPUT«(Int)␤»

[13:08] <colomon> r: my %h= 1 => "a"; .WHAT.say for %h.keys

[13:08] <camelia> rakudo b2072f: OUTPUT«(Str)␤»

[13:08] *** dayangkun joined
[13:09] <lizmat> that's because %h is conceptually the same as %h{Str}

[13:10] <lizmat> only, in the current implementation %h and %h{Str} don't do the same thing

[13:10] <colomon> but it's not -- like moritz++ said, it's %h{Str(Any)} or however you notate that.

[13:10] *** ztt_ joined
[13:11] <colomon> ie the keys are Str, but we accept Any and stringify it

[13:11] *** ajr joined
[13:11] <lizmat> we accept Any for values, and stringify keys to Str

[13:11] *** JimmyZ left
[13:11] *** ajr is now known as Guest4600

[13:12] <lizmat> there is no accept logic in the codepath for untyped hashes

[13:12] <lizmat> s/accept/constrain/

[13:12] *** Gothmog_ left
[13:12] *** Gothmog_ joined
[13:13] <moritz> nr: my %h; %h{Mu.new} = 42;

[13:13] <camelia> niecza v24-76-g3e65d84:  ( no output )

[13:13] <camelia> ..rakudo b2072f: OUTPUT«Cannot call 'postcircumfix:<{ }>'; none of these signatures match:␤:(: Mu *%_)␤:(: :p(:$p)!, Mu *%_)␤:(: :k(:$k)!, Mu *%_)␤:(: :kv(:$kv)!, Mu *%_)␤:(: :v(:$v)!, Mu *%_)␤:(: :BIND(:$BIND)!, Mu *%_)␤:(\SELF: $key, Mu *%_)␤:(\SELF: $key, Mu \$BIND, Mu *%_)␤:(\SELF: $k…

[13:14] <moritz> well, rakudo doesn't accept Mu

[13:14] <moritz> so there's some constraint through the signatures

[13:14] *** JimmyZ joined
[13:17] *** xenoterracide joined
[13:17] *** Guest4600 is now known as ajr_

[13:18] <lizmat> well, when I was beginning to become more active in Perl 6, I found that I wanted to use Mu in many situations

[13:18] <lizmat> and ran into these cases that didn;t work

[13:18] <lizmat> some patches were done to make some of it work, but I reverted them because it became clear

[13:18] <moritz> Mu is something you really shouldn't be using most of the time

[13:19] <lizmat> that they would mess with a number of optimizations

[13:19] <moritz> Any is the new Mu

[13:19] <lizmat> indeed, that's what I learned

[13:19] <moritz> r: undef

[13:19] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤        Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  :!defined as a matcher,␤        Any:U as a type constraint,␤    Nil as the

[13:19] <camelia> ..absens…

[13:19] <moritz> we should recommend the use of Any in that error message

[13:20] <lizmat> r: my %h= Any.new => 1  # works without a hitch

[13:20] <camelia> rakudo b2072f:  ( no output )

[13:20] <lizmat> r: my %h= Any.new => 1; say %h  # works without a hitch

[13:20] <camelia> rakudo b2072f: OUTPUT«("Any<1768327221>" => 1).hash␤»

[13:21] <lizmat> *sigh* use dots bites the dust

[13:22] <lizmat> (in Perl 5)

[13:23] <nwc10> personally I was finding that the needed rules for interpolation changes were doing my head in

[13:23] <nwc10> qr/$a.[0-9]/; # What's this going to mean?

[13:24] <lizmat> I'm not saying that there wouldn't be problems

[13:24] <lizmat> but right now p5p is early in the 5.20 cycle: so plenty of time to find these problems and iron them out

[13:24] <lizmat> and then at the end, maybe decide they can't be fixed and pull "use dots" then anyway

[13:24] <nwc10> life doesn't seem to work like that. See smartmatch, and when in the 5.10 cycle it happened

[13:25] <lizmat> I'm not sure you can compare this to smart match

[13:25] <lizmat> anyways, I think it is a missed opportunity

[13:25] <lizmat> and go on with Perl 6

[13:26] <nwc10> lots of problems don't get spotted until after release

[13:26] <nwc10> sometimes several years

[13:27] <nwc10> because the deployment cycle lags the release cycle so badly

[13:27] *** adu_ joined
[13:28] <[Coke]> does nqp support file/line directives?

[13:29] <[Coke]> (since I am forced to combine files, it would be nice for the error messages to refer to the original files)

[13:29] <FROGGS> [Coke]: never seen it

[13:33] *** cosimo left
[13:35] *** fgomez left
[13:35] *** cosimo joined
[13:46] *** btyler joined
[13:47] <dalek> v5: 292b714 | (Tobias Leich)++ | t/test.pl:

[13:47] <dalek> v5: added fresh_perl_is and ~_like

[13:47] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/292b71489e

[13:47] <dalek> v5: c0ba047 | (Tobias Leich)++ | t/test_summary:

[13:47] <dalek> v5: changes since last run are displayed

[13:47] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/c0ba0473b2

[13:47] <dalek> v5: 1ad6318 | (Tobias Leich)++ | / (3 files):

[13:47] <dalek> v5: make heredocs work

[13:47] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/1ad6318d7c

[13:49] *** ironcamel left
[14:00] *** risou_awy is now known as risou

[14:00] *** fhelmberger left
[14:01] *** birdwindupbird left
[14:03] <dalek> v5: 87f9d7a | (Tobias Leich)++ | STATUS.md:

[14:03] <dalek> v5: dont encode <br />

[14:03] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/87f9d7a916

[14:06] *** tgt left
[14:07] *** ztt_ left
[14:08] <dalek> rakudo/nom: 5705c3d | (Elizabeth Mattijsen)++ | src/Perl6/Grammar.nqp:

[14:08] <dalek> rakudo/nom: Make the "undef" message refer to Any, rather than Mu

[14:08] <dalek> rakudo/nom: 

[14:08] <dalek> rakudo/nom: As suggested at http://irclog.perlgeek.de/perl6/2013-06-14#i_7197427

[14:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5705c3d86a

[14:10] *** btyler_ joined
[14:11] *** xilo left
[14:11] <lizmat> moritz: your wish is my command  :-)

[14:12] <lizmat> question at FPW: is anyone taking care of Advent calender examples being kept working ?

[14:12] <FROGGS> lizmat++ # awesome minion :P

[14:13] <tadzik> lizmat: some of them are in spectests, I think

[14:13] <lizmat> the 2009 ones

[14:13] <lizmat> only

[14:14] <moritz> std: undef

[14:14] <camelia> std 6348f35: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤  Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  :!defined as a matcher,␤        Any:U as a type constraint,␤    Nil as the absense

[14:14] <camelia> ..…

[14:14] <moritz> could also use the update :-)

[14:14] <moritz> lizmat++

[14:14] * lizmat is unsure where to do that

[14:15] *** PacoAir joined
[14:15] *** btyler_ left
[14:15] <FROGGS> lizmat: https://github.com/perl6/std/blob/master/STD.pm6#L3129

[14:15] <lizmat> ok, will clone that also when I have a better connection

[14:16] <lizmat> and then fix and push if a can

[14:17] <timotimo_> how hard would it be to make shaped arrays work in rakudo? :|

[14:17] <[Coke]> regarding the advent calendars posts - test what you can in the spectest, but we've already had issues where the spec has changed since the post. In that case, I think, we update the spectest. Be nice if the advent posts linked to their respective tests.

[14:17] <lizmat> if that would work at all like typed hashes, some work indeed

[14:20] <moritz> if shaped arrays worked like typed hashes, most of the work would be wasted, because that wouldn't give any boost in performance

[14:20] *** spider-mario joined
[14:21] <lizmat> are shaped arrays about performance ?  I thought they were more about making sure you don't put illegal elements into an array ?

[14:21] <lizmat> and hence the overhead of the checks needed, would make things slower always?

[14:21] <timotimo_> i *think* they are somewhat about not having boxed values in them?

[14:22] <moritz> well, there's the combination from typed and from shaped

[14:23] <moritz> if you have a shaped and natively-typed array, you can (and should) omit all the boxing

[14:23] <moritz> and then if you do stuff like @a >>+<< @b and both are natively typed, you can even try to use SIMD instructions to speed up the stuff

[14:26] <timotimo_> i'm thinking about implementing cellular automatons and such, wondering if they would benefit from shaped + native arrays

[14:26] <timotimo_> also thinking about the interplay of zavolaj/inline::c and shaped arrays

[14:27] <lizmat> I find the use of "shaped" here confusing, I'd consider them "native" arrays

[14:27] <timotimo_> from the spec it seemed to me that "shaped" means something like "with defined bounds in all the dimensions"

[14:27] <moritz> right

[14:28] <moritz> and "native" is about the contents being natives rather than objects

[14:28] <lizmat> timotimo_: and mapped as well, e.g. Jan..Dec mapping to 0 .. 11

[14:28] <timotimo_> so it could in theory be a shaped array that contains non-native things; perhaps even silly things like having a shaped array of non-shaped arrays

[14:28] <moritz> so the two are orthogonal in usage

[14:28] *** FROGGS left
[14:28] <moritz> but non-orthogonal in implementation

[14:28] <moritz> (unless you want to give up all the advantages you could have from them)

[14:29] <lizmat> I would say, "go native when you can, remain boxed if you must"

[14:29] *** PacoAir left
[14:30] <timotimo_> would i benefit from having a shaped + native array, if my step function will loop over each cell, grab every neighbour cell and do work on them? probably only if i can manage to only have native integer containers inside my stepfunc, right?

[14:30] *** cosimo left
[14:30] <lizmat> bounded / index mapped arrays I assume would remain boxed, unless you can resolve at compile time

[14:30] *** PacoAir joined
[14:30] <lizmat> s/resolve/go native/

[14:31] *** alester joined
[14:31] *** xilo joined
[14:32] *** cosimo joined
[14:32] <timotimo_> i'm not sure what you mean with index mapped; something like my @foo{Month}; @foo[Jan] = 100;?

[14:37] *** xilo left
[14:37] *** xilo joined
[14:37] *** risou is now known as risou_awy

[14:37] *** Vlavv left
[14:42] *** toebu left
[14:42] <lizmat> timotimo_: yes

[14:43] <timotimo_> that's pretty neat o_O

[14:43] <lizmat> actually, that would me @foo{Month}

[14:43] <timotimo_> but that's what i wrote?

[14:43] <lizmat> @foo{Jan} = 100;

[14:43] <timotimo_> ah, ok

[14:43] *** raiph joined
[14:43] <timotimo_> yeah, that makes sense

[14:48] *** bluescreen10 joined
[14:49] <[Coke]> Anything look squirrely here: https://github.com/partcl/partcl-nqp/blob/nqp2/src/Partcl/Actions.pm#L41

[14:49] <dalek> std: d4cc5ab | (Elizabeth Mattijsen)++ | STD.pm6:

[14:49] <dalek> std: Same change as in rakudo

[14:49] <dalek> std: review: https://github.com/perl6/std/commit/d4cc5abedf

[14:49] <[Coke]> anything run with proc ends up with: Cannot look up attributes in a type object in nqp's parsegrammar.

[14:50] <lizmat> it appears I can commit to std ;-)

[14:50] <timotimo_> science! :)

[14:50] <[Coke]> EEEK

[14:50] *** Vlavv joined
[14:50] <colomon> \o/

[14:51] <timotimo_> [Coke]: are you sure you can write :namespace(@*PARTCL_COMPILER_NAMESPACE) without the pir::find_dynamic_lex__PS?

[14:51] <timotimo_> that's the only point i can see where that message could originate

[14:51] <pmichaud> good morning, #perl6

[14:51] <colomon> \o

[14:51] <lizmat> good morning, pmichaud!

[14:52] <kresike> bye folks

[14:52] *** kresike left
[14:52] <nwc10> good moarning, pmichaud. Oh, wrong channel :-)

[14:53] <nwc10> (attribution - I believe that Pm was the first to pun that, at least on IRC)

[14:54] <timotimo_> *groan*

[14:57] *** woolfy joined
[14:57] <pmichaud> [Coke]: I'm not entirely sure we still have :namespace() stuff.

[14:58] <lizmat> pmichaud++ for pointing out the difference between %h{Str} and %h{Str(Any)}

[14:58] *** risou_awy is now known as risou

[14:59] <timotimo_> lizmat: the latter means you can supply any, but it will be coerced, the former means you actually have to pass a string? (as the key, iirc)

[14:59] <lizmat> yes, I know that (now)  :-)

[14:59] <[Coke]> timotimo_, pmichaud: that code is no doubt a holdover from the original port to nqp-rx.

[15:00] <lizmat> r: my %h{Int(Num)}  # NYI it seems  ;-(

[15:00] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[15:00] <[Coke]> pmichaud: any suggestion on a current-nqp improvement there?

[15:01] *** domidumont left
[15:01] <timotimo_> lizmat: i can try to at least turn that into a proper NYI error

[15:01] <timotimo_> std: my %h{Int(Num)};

[15:01] <camelia> std 6348f35: OUTPUT«ok 00:00 44m␤»

[15:02] <pmichaud> [Coke]: not at the moment, no.  I'm sure there *is* a solution, I'm just not sure what it is.  probably need some jnthn++ input.

[15:02] <pmichaud> or for me to have tuits to figure it out 

[15:02] <pmichaud> I think that rakudo doesn't understand  A(B) type syntax yet.

[15:03] <pmichaud> r: sub abc(Str(Any) $x) { say $x.WHAT; };  abc(3)

[15:03] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤coercive type declarations not yet implemented. Sorry. ␤at /tmp/ZdAYejqS_y:1␤------> sub abc(Str(Any)⏏ $x) { say $x.WHAT; };  abc(3)␤»

[15:03] * [Coke] whinges at jnthn++. :)

[15:03] <pmichaud> okay, it understands them _there_.

[15:03] * [Coke] will try to look at this after $DAYJOB

[15:03] <timotimo_> yeah, i'll put an nyi where the %h{Int(Num)} thing happens

[15:03] <pmichaud> timotimo_: I would've expected them to be in a similar location.

[15:03] <pmichaud> as in  the (Num) should be part of the typename

[15:04] <pmichaud> I wouldn't expect it to be in two different places.

[15:04] <pmichaud> otoh, follow whatever STD.pm6 is doing here.

[15:04] <timotimo_> sure

[15:08] <pmichaud> lizmat: ":keytype" and ":of" as named parameters feel like design smell to me.

[15:09] <[Coke]> :of(course they do)

[15:09] <pmichaud> in some sense, I'd prefer to simply pass a prototype object to be filled in by .classify

[15:09] <lizmat> open to suggestions: we also need some introspection on typed hashes to find out what the type of keys is

[15:09] <lizmat> there is already an .of method

[15:10] <lizmat> what would the other method be called: that would be a good candidate for the named parameter, no?

[15:10] <pmichaud> so...    .classify(:type(Hash[TVal,TKey]))

[15:10] <lizmat> or is it you don't like the named parameters in that context, period?

[15:10] <pmichaud> I don't like the named parameters

[15:10] *** ajr_ left
[15:11] <pmichaud> I like having the separate named parameters even less

[15:11] *** ajr joined
[15:11] *** ajr is now known as Guest87186

[15:12] <pmichaud> I'm not sure I can eliminate the named argument entirely, but I do think it's better to specify type information directly _as a type_ rather than have yet another syntax for specifying it

[15:12] <pmichaud> I wonder if it's worthy to consider     .classify(:into($obj))

[15:12] <pmichaud> which adds information to $obj, rather than creating a new one

[15:12] <lizmat> so, syntax should be hash[::TVal](@list) ?

[15:12] <pmichaud> the default can be     .classify( :into = Hash.new )

[15:13] <pmichaud> if someone wanted a typed hash, they would do    .classify(:into(Hash[TVal].new))

[15:13] <pmichaud> then .classify could also possibly put things into tied objects, or ... I dunno.

[15:13] <lizmat> that smells like needing syntactic sugar to me

[15:14] * moritz likes :into

[15:15] <pmichaud> or maybe .classify should be a method on a Hash instead of a List, then.

[15:15] <pmichaud> I'd have to review the use cases for that, though.

[15:15] <timotimo_> how do you people feel about a classify that works with lazyness? if there's only a finite amount of resulting categories (like True, False perhaps), it could return two lazy lists and cleverly generate results from there ...

[15:15] <pmichaud> i.e.,    Hash.new.classify(@list)  instead of   @list.classify()

[15:16] <pmichaud> timotimo_: hashes tend to want to be eager, in my experience

[15:16] * lizmat suddenly realizes this is not about hash( :keytype<Str>, :of<Int> ) but about classify  :-)

[15:16] <pmichaud> well, I don't like   hash( :keytype, :of )   either :-)

[15:16] <pmichaud> (for the same reasons)

[15:16] <pmichaud> hash is supposed to be a contextualizer, not a constructor.

[15:16] <lizmat> gotcha  :-)  I got the I don't like meme here :-)

[15:17] <timotimo_> mhm

[15:17] *** risou is now known as risou_awy

[15:17] <timotimo_> in that case, a tuple of lazy lists ;)

[15:17] <timotimo_> i recently saw a post about how to do it in python, which was a bit harder to do becaus python won't let you address older items that were generated easily

[15:17] <pmichaud> timotimo_: the thing is, I don't think you can know the hash keys without being eager on the list

[15:18] <timotimo_> right

[15:18] <pmichaud> anyway, just before yapc::na  jnthn++ speculated "ofkey" as the keyed counterpart to "of"

[15:18] <lizmat> thinking about it, .classify / .categorize make sense as hash methods (as well)

[15:19] <timotimo_> i'm trying to fix multi infix:<P5~>(*@a)     is export { [~] map { .P5Str }, @a } in v5 (when doing my $a = "o"; $a .= "k 5 - concat"; $a = "foo bar" i get "Cannot modify an immutable value")

[15:20] <pmichaud> http://irclog.perlgeek.de/perl6/2013-05-20#i_7093846   # "ofkey"

[15:20] <timotimo_> i tried to do my $ = [~] ..., but that doesn't seem to change anything

[15:21] <lizmat> pmichaud: a little later: http://irclog.perlgeek.de/perl6/2013-05-20#i_7094585

[15:22] <PerlJam> pmichaud: re, hash not a constructor, there are a few places in the synopses that talk about hash() as a "hash composer" (S03:174, S04:1660) which really seems to be the same thing as a hash constructor to me.

[15:22] *** btyler left
[15:23] <pmichaud> PerlJam: I think that's   hash()  and not  .hash()  :-P

[15:23] <PerlJam> oh, I guess I slipped some context.

[15:24] <pmichaud> lizmat: yes, in that later section TimToady echoes what I've been saying... key and value type information is done by instantiating a role

[15:25] <pmichaud> so, based on TimToady's comment, I'd go with a .keytype method on TypedHash

[15:25] <lizmat> to introspect, like .of, right?

[15:25] *** domidumont joined
[15:25] <pmichaud> yes

[15:26] <pmichaud> and while we're here (for the benefit of the irclogs), it might be worth re-mentioning that "TypedHash" in Rakudo itself might be a scaffolding anomaly and not a true implementation.

[15:26] *** tgt joined
[15:26] <pmichaud> i.e., TypedHash is just the way we simulate typed hashes while we're still getting all of the pieces into place, in reality all hashes are typed.

[15:27] <lizmat> gotcha

[15:27] <pmichaud> (there's a bit of a bootstrapping issue in that we can't parameterize Hash directly yet...)

[15:27] <lizmat> we can now with Hash.new

[15:28] <pmichaud> right, but....

[15:28] <pmichaud> r:  my %h;  say %h.of;

[15:28] <camelia> rakudo b2072f: OUTPUT«(Mu)␤»

[15:28] <pmichaud> oh, that works.

[15:28] <pmichaud> cool.

[15:28] <pmichaud> r:  my %h;  say %h ~~ TypedHash;

[15:28] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Undeclared name:␤    TypedHash used at line 1␤␤»

[15:28] <pmichaud> r:  my %h;  say %h ~~ Hash::TypedHash;

[15:28] <camelia> rakudo b2072f: OUTPUT«Could not find symbol '&TypedHash'␤  in method <anon> at src/gen/CORE.setting:10166␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in block  at /tmp/Xjm7zF_QgS:…

[15:28] <pmichaud> hmmm

[15:28] <pmichaud> rakudo++

[15:29] *** btyler joined
[15:29] <pmichaud> anyway, there's a circularity saw issue that may still need resolving.

[15:29] <pmichaud> (it may not; we just don't know entirely yet)

[15:30] <lizmat> so: .hash should just be a contextualizer that presumably should always do Mu %h{Str(Eny)} ?

[15:30] <lizmat> Any

[15:30] <pmichaud> it should be up to the invocant to decide what sort of hash-like entity should be returned.

[15:31] <pmichaud> if you're asking about List.hash or Any.hash, I think in general it should returned a standarad Hash

[15:32] <pmichaud> there may be an argument that it should return an (immutable)  EnumMap

[15:32] *** cognominal joined
[15:32] <pmichaud> oops, I context switched -- ignore that last statement.

[15:33] <lizmat> so: .hash could be reduced to "my % := nqp::create(self)"

[15:33] <pmichaud> uh, no.

[15:33] <pmichaud> 'self' in this case would be the List or Any object,  so nqp::create would give you one of those.

[15:34] <lizmat> wouldn't the % coerce it to hash then?

[15:34] *** xenoterracide left
[15:34] <pmichaud> not on a binding.

[15:34] *** xenoterracide|2 joined
[15:34] <lizmat> of course, duh  :-)

[15:35] *** kaleem left
[15:35] * pmichaud looks to see what .hash is now

[15:36] * lizmat covers her ears to not hear the screaming  :-)

[15:36] *** JimmyZ left
[15:36] <pmichaud> the old

[15:36] <pmichaud>     method hash() { my % = self }

[15:36] <pmichaud> ought to work :)

[15:37] <lizmat> I guess I changed that because Hash.new was calling .hash

[15:37] <lizmat> originally

[15:37] <pmichaud> yeah, which was backwards.  :)

[15:37] <lizmat> ok, I'll fix .hash now

[15:37] <pmichaud> slightly faster/better might be     method hash() { (my %).STORE(self) }

[15:38] <pmichaud> ...but I'd stick with the assignment for now.

[15:38] *** xinming left
[15:38] <lizmat> faster is better in these case, I think  :-)

[15:38] <pmichaud> well, I don't know that it'll be faster in reality.

[15:38] *** yoleaux left
[15:38] <pmichaud> it might end up being a premature opt

[15:38] <lizmat> I'll spectest to make sure we didn't break anytyhing

[15:38] *** xinming joined
[15:38] <lizmat> ok, fair enough  :-)

[15:39] <pmichaud> I have to check on family stuff for a bit... bbl

[15:39] <lizmat> pmichaud++

[15:43] *** shlomif joined
[15:47] *** daxim left
[15:47] *** dylanwh left
[15:47] *** daniel-s left
[15:47] *** labster left
[15:47] *** hoelzro_ joined
[15:47] *** atrodo joined
[15:47] *** daniel-s joined
[15:47] *** FROGGS joined
[15:50] *** bruges_ joined
[15:51] *** macgruber joined
[15:52] *** macgruber left
[15:52] *** itz__ joined
[15:53] *** FOAD_ joined
[15:53] *** pochi_ joined
[15:53] *** pochi left
[15:53] *** FOAD left
[15:53] *** awwaiid_ joined
[15:53] *** itz_ left
[15:53] *** FOAD_ is now known as FOAD

[15:53] *** bruges left
[15:55] *** geekosaur left
[15:55] *** cosimo left
[15:56] *** cognominal left
[15:57] *** awwaiid left
[15:57] *** daxim joined
[15:57] *** dylanwh joined
[15:58] <dalek> rakudo/nom: 693af19 | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[15:58] <dalek> rakudo/nom: Make .hash a contextualizer again

[15:58] <dalek> rakudo/nom: 

[15:58] <dalek> rakudo/nom: As discussed at: http://irclog.perlgeek.de/perl6/2013-06-14#i_7197917

[15:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/693af19379

[16:01] <lizmat> end of presentations at FPW, getting ready to go out

[16:01] *** geekosaur joined
[16:01] *** xenoterracide|2 left
[16:02] *** cosimo joined
[16:04] *** Guest87186 left
[16:06] *** dylanwh left
[16:06] *** dylanwh joined
[16:08] *** yoleaux joined
[16:08] *** ChanServ sets mode: +v yoleaux

[16:11] *** xilo left
[16:13] *** kivutar left
[16:13] <lizmat> .tell pmichaud Maybe it is an idea to have a 2nd optional parameter to .classify|.categorize to indicate the hash to classify/categorize into?

[16:13] <yoleaux> lizmat: I'll pass your message to pmichaud.

[16:14] <lizmat> dinner&

[16:14] *** woolfy left
[16:16] *** lizmat left
[16:17] *** shlomif left
[16:17] *** SamuraiJack left
[16:17] *** SamuraiJack joined
[16:18] *** rindolf joined
[16:30] *** raiph left
[16:35] *** chutchut left
[16:40] *** dmol joined
[16:46] *** ssutch joined
[16:52] *** tgt left
[16:57] *** zby_home_ joined
[16:58] *** tgt joined
[17:04] <timotimo_> the reason why the nyi coercive hash shape thingie doesn't work is because it's parsed as %foo{<semilist>} and inside the semilist there's just statements and those statements just have something in them like Str(Any)

[17:04] <timotimo_> r: say Str(Any)

[17:04] <camelia> rakudo b2072f: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/fDILKqZ7ru:1␤␤␤»

[17:05] <timotimo_> r: my %foo{Str;Str}

[17:05] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[17:05] <timotimo_> the check that fails here is probably that there's only one statement in the semilist

[17:09] *** fgomez joined
[17:10] *** risou_awy is now known as risou

[17:10] <timotimo_> std: my %h{say "what"};

[17:10] <camelia> std d4cc5ab: OUTPUT«ok 00:00 44m␤»

[17:11] <timotimo_> is that for calculating how big the dimensions are supposed to be?

[17:11] <timotimo_> r: my %h{say "what"};

[17:11] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[17:11] <timotimo_> wait, hashes don't have "dimensions"

[17:12] *** bluescreen10 left
[17:12] *** tgt left
[17:13] <timotimo_> std: my %foo{Str;Str};

[17:13] <camelia> std d4cc5ab: OUTPUT«ok 00:00 43m␤»

[17:18] <timotimo_> r: my %foo{};

[17:18] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[17:19] <timotimo_> i wish i could easily get a dump of the QAST that's below there without recompiling ;_;

[17:20] <timotimo_> i neglected to turn on my mighty desktop at home, so i'll have to wait ~300 seconds for a setting compile :(

[17:24] *** dayangkun_ joined
[17:25] *** twigel left
[17:26] *** btyler left
[17:27] *** dayangkun left
[17:29] *** risou is now known as risou_awy

[17:33] *** Khisanth left
[17:35] *** daxim left
[17:42] *** bluescreen10 joined
[17:44] <dalek> perl6-roast-data: b6cd7e0 | coke++ | / (4 files):

[17:44] <dalek> perl6-roast-data: today (automated commit)

[17:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b6cd7e03f4

[17:45] <[Coke]> niecza up to 17 failures from 16. rakudo failing a new test.

[17:47] *** Khisanth joined
[17:51] *** kaleem joined
[17:52] *** kaare_ joined
[17:52] *** SamuraiJack left
[17:52] <dalek> faq: 749d14c | GlitchMr++ | answers.md:

[17:52] <dalek> faq: This is HTML, not XHTML

[17:52] <dalek> faq: 

[17:52] <dalek> faq: Yes, it has XHTML doctype, but it means nothing. As it's HTML document

[17:52] <dalek> faq: with XHTML doctype, it should follow Appendix C in XHTML specification -

[17:52] <dalek> faq: http://www.w3.org/TR/xhtml1/#guidelines (one of rules is not to write

[17:52] <dalek> faq: `<p />`).

[17:52] <dalek> faq: review: https://github.com/perl6/faq/commit/749d14cedd

[17:55] *** colomon left
[17:58] <timotimo_> i can get the .value of a WVal containing, for instance Str and check if it's a type object with !nqp::isconcrete, right?

[18:01] *** kaleem left
[18:04] *** btyler joined
[18:05] <timotimo_> r: sub test(Str(Any) $bar) { $bar };

[18:05] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤coercive type declarations not yet implemented. Sorry. ␤at /tmp/_W5_QQyg2_:1␤------> sub test(Str(Any)⏏ $bar) { $bar };␤»

[18:08] *** xilo joined
[18:11] *** guru joined
[18:12] *** guru is now known as Guest40781

[18:12] <moritz> timotimo_: yes

[18:12] *** Guest40781 is now known as ajr_

[18:12] *** REPLeffect joined
[18:17] *** tgt joined
[18:17] *** itz__ left
[18:20] *** pochi_ left
[18:20] *** pochi joined
[18:21] *** itz joined
[18:23] <lue> hello world o/

[18:23] *** kaleem joined
[18:29] *** FOAD left
[18:30] *** FOAD joined
[18:30] *** FOAD left
[18:30] *** FOAD joined
[18:31] <ssutch> hola hay

[18:31] *** lustlife` joined
[18:33] <ssutch> what is the proper way to represent something like this 0[xX]([A-Fa-f0-9])+ in p6 (specifically, in a grammar, i want to identify hex integers) 

[18:34] *** lustlife left
[18:34] <ssutch> this: token hex-int       { '0'[xX](A..Fa..F0..9)+ }, just doesn't seem right

[18:37] <flussence> std: token hex-int { '0' <.[xX]> (<[A..Fa..f0..9]>+) }

[18:37] <camelia> std d4cc5ab: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'xX' used at line 1␤Potential difficulties:␤  'token' declaration outside of grammar at /tmp/aXF19OYy6B line 1:␤------> token hex-int ⏏{ '0' <.[xX]> (<[A..Fa..f0..9]>+) }␤Check failed␤FAILED 00:00…

[18:37] <flussence> std: token hex-int { '0' <[xX]> (<[A..Fa..f0..9]>+) }

[18:37] <camelia> std d4cc5ab: OUTPUT«Potential difficulties:␤  'token' declaration outside of grammar at /tmp/Ib4vr30k0i line 1:␤------> token hex-int ⏏{ '0' <[xX]> (<[A..Fa..f0..9]>+) }␤ok 00:00 43m␤»

[18:37] <flussence> meh, close enough

[18:38] <flussence> std: grammar foo { token hex-int { '0' <[xX]> (<[A..Fa..f0..9]>+) } }; foo.parse('0x2349fb1', :rule<hex-int>).say

[18:38] <camelia> std d4cc5ab: OUTPUT«ok 00:00 47m␤»

[18:39] <lue> std: token hex-int { 0 [x||X] <xdigit>+ }

[18:39] <camelia> std d4cc5ab: OUTPUT«Potential difficulties:␤  'token' declaration outside of grammar at /tmp/phRA7tAoJL line 1:␤------> token hex-int ⏏{ 0 [x||X] <xdigit>+ }␤ok 00:00 43m␤»

[18:39] <flussence> r: grammar foo { token hex-int { '0' <[xX]> (<[A..Fa..f0..9]>+) } }; foo.parse('0x2349fb1', :rule<hex-int>).say

[18:39] <camelia> rakudo b2072f: OUTPUT«｢0x2349fb1｣␤ 0 => ｢2349fb1｣␤␤»

[18:39] <flussence> r: grammar foo { token hex-int { '0' <[xX]> <xdigit>+ } }; foo.parse('0x2349fb1', :rule<hex-int>).say

[18:39] <camelia> rakudo b2072f: OUTPUT«｢0x2349fb1｣␤ xdigit => ｢2｣␤ xdigit => ｢3｣␤ xdigit => ｢4｣␤ xdigit => ｢9｣␤ xdigit => ｢f｣␤ xdigit => ｢b｣␤ xdigit => ｢1｣␤␤»

[18:39] <lue> r: say "0xDEADBEEF" ~~ /0 [x||X] <xdigit>+/

[18:39] <camelia> rakudo b2072f: OUTPUT«｢0xDEADBEEF｣␤ xdigit => ｢D｣␤ xdigit => ｢E｣␤ xdigit => ｢A｣␤ xdigit => ｢D｣␤ xdigit => ｢B｣␤ xdigit => ｢E｣␤ xdigit => ｢E｣␤ xdigit => ｢F｣␤␤»

[18:39] <flussence> r: grammar foo { token hex-int { '0' <[xX]> (<.xdigit>+) } }; foo.parse('0x2349fb1', :rule<hex-int>).say

[18:40] <camelia> rakudo b2072f: OUTPUT«｢0x2349fb1｣␤ 0 => ｢2349fb1｣␤␤»

[18:40] <ssutch> nice

[18:40] *** xenoterracide|2 joined
[18:40] *** kaleem left
[18:41] <ssutch> whoa i didn't now about .xdigit

[18:41] <flussence> r: grammar foo { token hex-int { :i '0x' (<.xdigit>+) } }; foo.parse('0X2349fb1', :rule<hex-int>).say

[18:41] <camelia> rakudo b2072f: OUTPUT«｢0X2349fb1｣␤ 0 => ｢2349fb1｣␤␤»

[18:41] <ssutch> 	 r: grammar foo { token hex-int { '0' <[xX]> <.xdigit>+ } }; foo.parse('0x2349fb1', :rule<hex-int>).say

[18:41] <camelia> rakudo b2072f: OUTPUT«｢0x2349fb1｣␤␤»

[18:45] <ssutch> why are you putting the :rule<hex-int>.say on there?

[18:45] <ssutch> (disregard the .say)

[18:47] <[Coke]> tells you which rule to use when parsing using that grammar.

[18:47] <[Coke]> as opposed to if you had a single regexp.

[18:47] <[Coke]> r: say / '0' <[xX]> <.xdigit>+ / ~~ '0x2349fb1'

[18:47] <camelia> rakudo b2072f: OUTPUT«False␤»

[18:47] <lue> (the default rule is one named TOP. If you don't want to use that one, then you use :rule)

[18:48] *** pjcj left
[18:49] *** konundra left
[18:50] *** btyler left
[18:51] <ssutch> ah ok, cool

[18:52] *** REPLeffect left
[18:57] <[Coke]> (my example above is reversed. put the string on the left)

[18:58] *** btyler joined
[18:59] <dalek> specs: e473973 | lue++ | S03-operators.pod:

[18:59] <dalek> specs: [S03] Remove extraneous commas from operator precedence table

[18:59] <dalek> specs: 

[18:59] <dalek> specs: Wouldn't want people thinking those commas are part of the example

[18:59] <dalek> specs: operators, now would we?

[18:59] <dalek> specs: review: https://github.com/perl6/specs/commit/e47397323f

[19:02] *** pjcj joined
[19:12] *** FOAD left
[19:14] <ssutch> does anyone know where the grammar for this talk is stored? https://www.youtube.com/watch?v=7nISwfLoAoU

[19:14] *** FOAD joined
[19:19] *** FOAD is now known as Guest25363

[19:19] <ssutch> (it is a basic SQL grammar)

[19:19] *** Guest25363 left
[19:20] <sorear> good * #perl6

[19:26] *** domidumont left
[19:40] *** REPLeffect joined
[19:40] *** xenoterracide|2 left
[19:47] *** labster joined
[19:53] *** FOAD joined
[19:56] <moritz> good * sorear 

[19:59] *** adu_ left
[20:01] *** census left
[20:05] *** xilo left
[20:06] *** xilo joined
[20:07] <timotimo_> how did i manage to get Missing or wrong version of dependency 'src/Perl6/Actions.nqp' directly after make install when i even made the setting without trouble? :|

[20:09] *** dukeleto joined
[20:09] <dukeleto> o/

[20:09] <timotimo_> hm, apparently my path is wrong

[20:10] *** FOAD left
[20:11] <dalek> v5: bbb8412 | (Tobias Leich)++ | t/test_summary:

[20:11] <dalek> v5: dont encode <br />

[20:11] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/bbb8412260

[20:11] <dalek> v5: b7b1eea | (Tobias Leich)++ | / (2 files):

[20:11] <dalek> v5: added skip_rest and skip_all_without_config

[20:11] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/b7b1eeaeb6

[20:11] <sorear> maybe I broke nqp.  I didn't make test before my last commit.

[20:11] *** FOAD joined
[20:13] *** arlinius left
[20:14] *** xenoterracide|2 joined
[20:16] <timotimo_> wha ... it does /usr/bin/perl -MExtUtils::Command -e cp     perl6        /home/timo/build/rakudo/install/bin, but perl6 in ./ and in ./install/bin/ have different sha1sums?!

[20:17] <timotimo_> oooh, text file busy!

[20:19] *** kaare_ left
[20:20] <moritz> file system full?

[20:20] <dalek> rakudo-star-daily: bc697b6 | coke++ | log/ (5 files):

[20:20] <dalek> rakudo-star-daily: today (automated commit)

[20:20] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/bc697b665f

[20:21] <timotimo_> moritz: no, i had a perl6 open at that time

[20:21] <timotimo_> make install didn't care to report the error

[20:24] <moritz> why would it be an error?

[20:24] <timotimo_> well, it caused the file not to be overwritten

[20:24] <timotimo_> and thus the new version not to be installed

[20:25] <moritz> afaict on linux systems you can delete and copy over a file that is opened and/or being executed

[20:25] <moritz> *open

[20:25] <timotimo_> yeah, but that command thingie doesn't like to do that

[20:26] <moritz> that is more than just a bit weird

[20:26] <timotimo_> [timo@lolcathost] $ cp     perl6        /home/timo/build/rakudo/install/bin

[20:26] <timotimo_> cp: cannot create regular file ‘/home/timo/build/rakudo/install/bin/perl6’: Text file busy

[20:26] <timotimo_> [timo@lolcathost] $ /usr/bin/perl -MExtUtils::Command -e cp     perl6        /home/timo/build/rakudo/install/bin    <- no output

[20:29] <moritz> http://askubuntu.com/questions/218129/text-file-busy-when-running-a-simple-script-on-bash

[20:29] <moritz> it seems that writing + executing do get in each other's way

[20:29] <moritz> ... under certain conditions and moon phases

[20:29] *** census joined
[20:29] <timotimo_> :)

[20:30] <moritz> anyway, time for sleep here

[20:31] <moritz> good night *

[20:33] *** mikemol joined
[20:37] <FROGGS> lolcathost *narf*

[20:39] <timotimo_> :)

[20:39] <timotimo_> why would an Smts have an Op directly inside it? o_O

[20:40] <FROGGS> why not?

[20:41] <timotimo_> i thought Stmts is there to have multiple Stmt's in it?

[20:42] <FROGGS> no, I have seen Op in there in several places

[20:42] <timotimo_> oke

[20:42] <FROGGS> and it just does them in order and return the value of the last

[20:44] <timotimo_> okay, this should get a proper NYI error for coercive types in hash declaration

[20:44] *** arlinius joined
[20:47] <ssutch> forgive me, in  <subrule>{1,2} in perl 6 is <subrule> ** 2

[20:47] <ssutch> ?

[20:47] <timotimo_> no, it would be <subrule> ** 1..2

[20:47] <ssutch> aye, thank you

[20:48] <timotimo_> you're welcome :)

[20:48] <ssutch> i have a near-functional protocol buffer grammar, just adding quoted strings and comments

[20:49] <ssutch> it's a great exercise to learn S05 in p6

[20:49] <timotimo_> cool :)

[20:55] * timotimo_ spectests his error message improvements

[20:55] <timotimo_> seems to be all i do these days

[20:58] *** benabik left
[20:59] *** benabik joined
[21:08] *** tomyan joined
[21:12] <sorear> nqp-jvm: sub foo() { 5; }; my int $pi := foo(); say $pi

[21:12] <camelia> nqp-jvm: OUTPUT«Confused at line 2, near "say $pi"␤  in panic␤  in comp_unit␤  in TOP␤  in parse␤  in parse␤  in <anon>␤  in compile␤  in eval␤  in evalfiles␤  in command_eval␤  in command_line␤  in MAIN␤  in <anon>␤  in <anon>»

[21:12] <sorear> nqp-jvm: sub foo() { 5; }; my int $pi := foo(); say($pi)

[21:12] <camelia> nqp-jvm: OUTPUT«5␤»

[21:13] <sorear> nqp-jvm: my $bob := 5; sub foo() { $bob; }; my int $pi := foo(); say($pi)

[21:13] <camelia> nqp-jvm: OUTPUT«5␤»

[21:19] <diakopter> nqp-jvm: my $bob := " 5 "; sub foo() { $bob; }; my int $pi := foo(); say($pi)

[21:19] <timotimo_> yays, i have found out how to turn my cpu fan all the way up

[21:19] <camelia> nqp-jvm: OUTPUT«5␤»

[21:19] <diakopter> sorear: ^

[21:19] <diakopter> nqp-jvm: my int $bob := " 5 "; sub foo() { $bob; }; my int $pi := foo(); say($pi)

[21:19] <camelia> nqp-jvm: OUTPUT«0␤»

[21:19] *** btyler left
[21:20] <diakopter> nqp-jvm: my int $bob := 5; sub foo() { $bob; }; my int $pi := foo(); say($pi)

[21:20] <camelia> nqp-jvm: OUTPUT«5␤»

[21:20] <sorear> diakopter: it's ok, I found my error

[21:20] <sorear> result_[ions] does coercion

[21:20] *** konundra joined
[21:22] *** colomon joined
[21:22] *** salv0 left
[21:27] *** salv0 joined
[21:28] *** dukeleto left
[21:32] *** tomyan left
[21:35] <timotimo_> https://gist.github.com/timo/4cd10faa0768e855df87 - are these fails known?

[21:35] <timotimo_> Missing or wrong version of dependency 'src/Perl6/Pod.nqp'  -  wtf? >:(

[21:35] <dalek> v5: c3ab678 | (Tobias Leich)++ | / (2 files):

[21:35] <dalek> v5: a more reliabe way for indirect object syntac with variable

[21:35] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/c3ab678b86

[21:36] <[Coke]> timotimo_: I occasionally get fails when I have a built, installed perl6, and then use the built, installed parrot to build a new NQP.

[21:36] <FROGGS> timotimo_: is it possible that you pass -j<something> to make install ?

[21:36] <timotimo_> no, i didn't, but perhaps my system did it for me

[21:36] <[Coke]> ... so I try to keep it completely separate - one tool chain that I install for doing development *in* perl6, and then one each for everything that involves hacking on perl6.

[21:36] <timotimo_> i'll re-run it with a clean build

[21:37] <[Coke]> FROGGS: not that that should fail.

[21:38] <ssutch> [^\0\n] in perl 6 = <[!\V!\\0]> ?

[21:39] <sorear> <-[\0\n]>

[21:39] <ssutch> r: 'omg\n' ~~ /<[!\V!\\0]>+/

[21:39] <camelia> rakudo b2072f:  ( no output )

[21:39] <sorear> there is no ! syntax

[21:39] <ssutch> oi, i was reading it wrong, thanks

[21:39] <ssutch> r: use Test; nok 'omg\n' ~~ /<-[\0\n]>

[21:40] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\0'␤at /tmp/Igg9Ifp7yM:1␤------> use Test; nok 'omg\n' ~~ /<-[\⏏0\n]>␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term␤…

[21:40] <ssutch> r: use Test; nok 'omg\n' ~~ /<-[\0\n]>/

[21:40] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\0'␤at /tmp/9MOx7HsvPF:1␤------> use Test; nok 'omg\n' ~~ /<-[\⏏0\n]>/␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        prefix or term…

[21:40] <ssutch> r: use Test; nok 'omg\n' ~~ /<-[\\0\n]>/

[21:40] <camelia> rakudo b2072f: OUTPUT«not ok 1 - ␤»

[21:41] <timotimo_> i don't udnerstand, what do you want to not match?

[21:41] <ssutch> any value besides a newline or a null byte

[21:41] <timotimo_> oh, i think you want something else then

[21:41] <timotimo_> r: use Test; nok 'omg\n' ~~ /<-[\x00\n]>/ # maybe

[21:41] <camelia> rakudo b2072f: OUTPUT«not ok 1 - ␤»

[21:41] <timotimo_> well, it will match the newline at the end

[21:42] <timotimo_> r: use Test; nok 'omg\n' ~~ /^<-[\x00\n]>/ # maybe

[21:42] <camelia> rakudo b2072f: OUTPUT«not ok 1 - ␤»

[21:42] <timotimo_> r: say "what" ~~ /<-[\x00]>/;

[21:42] <camelia> rakudo b2072f: OUTPUT«｢w｣␤␤»

[21:42] <timotimo_> r: say "what" ~~ /<-[\x00\n]>/;

[21:42] <camelia> rakudo b2072f: OUTPUT«｢w｣␤␤»

[21:42] <timotimo_> r: say "what" ~~ /<-[\x00\n]>+/;

[21:42] <camelia> rakudo b2072f: OUTPUT«｢what｣␤␤»

[21:42] <timotimo_> r: say "what\n" ~~ /<-[\x00\n]>+/;

[21:42] <camelia> rakudo b2072f: OUTPUT«｢what｣␤␤»

[21:42] <timotimo_> do you want every character to not have newlines and nullbytes or what?

[21:43] * sorear is writing continuation tests

[21:43] <ssutch> it needs to reject if it finds a newline

[21:43] <timotimo_> r: say "\x00what\n" ~~ /<-[\x00\n]>+/;

[21:43] <camelia> rakudo b2072f: OUTPUT«｢what｣␤␤»

[21:43] <ssutch> (or a null byte)

[21:43] <timotimo_> ah, then you will want ^^<-[...]>*$$

[21:43] <tadzik> dagurval, timotimo_: thanks for your pull requests!

[21:43] <timotimo_> or you will want to not-match /\n | \x00/

[21:44] <ssutch> whoa

[21:44] <timotimo_> tadzik: you're very welcome :)

[21:44] <tadzik> I only now managed to review some of them

[21:44] <tadzik> exam time is practically over :)

[21:45] <timotimo_> yays \o/

[21:45] <ssutch> r: say 'omg\n' ~~ /^^<-[\x00\n]>*$$/

[21:45] <camelia> rakudo b2072f: OUTPUT«｢omg\n｣␤␤»

[21:45] <timotimo_> i think you have a literal \ and n there

[21:46] <timotimo_> r: say 'omg\n'; say "ong\n";

[21:46] <camelia> rakudo b2072f: OUTPUT«omg\n␤ong␤␤»

[21:46] <ssutch> r: say "omg\n" ~~ /^^<-[\x00\n]>*$$/

[21:46] <camelia> rakudo b2072f: OUTPUT«｢omg｣␤␤»

[21:47] <timotimo_> r: say "ong\n" ~~ /\n/;

[21:47] <camelia> rakudo b2072f: OUTPUT«｢␤｣␤␤»

[21:47] *** ajr_ left
[21:47] <timotimo_> well, it does match the newline there

[21:47] <timotimo_> i wonder why it doesn't match the newline in your example

[21:47] <timotimo_> oh sill yme

[21:47] <timotimo_> i meant to tell you to use ^ and $

[21:47] <timotimo_> because the old ^ and $ are now ^^ $$ (beginning of line and end of line), but ^ and $ are now beginning of string and end of string

[21:48] <ssutch> i see

[21:48] <ssutch> r: say "omg\n" ~~ /^<-[\x00\n]>*$/

[21:48] <camelia> rakudo b2072f: OUTPUT«Nil␤»

[21:48] <ssutch> r: say "omg" ~~ /^<-[\x00\n]>*$/

[21:48] <camelia> rakudo b2072f: OUTPUT«｢omg｣␤␤»

[21:48] <timotimo_> yays! \o/

[21:48] <ssutch> huzzah!

[21:48] <timotimo_> i think the inverse may be easier:  say "omg\n" !~~ / \n | \x00 /

[21:49] <timotimo_> r: say "omg\n" !~~ / \n | \x00 /

[21:49] <camelia> rakudo b2072f: OUTPUT«False␤»

[21:49] <timotimo_> false as in: not okay

[21:49] <ssutch> yeah

[21:50] <timotimo_> ooooooooooooooh i know what i was doing wrong

[21:51] <timotimo_> i neglected to re-make-and-install v5

[21:51] <timotimo_> facepalm^10

[21:52] <timotimo_> FROGGS: i was trying to fix a little thing in v5, but it seemed to be a big thing in disguise or something

[21:52] <FROGGS> O.o

[21:52] <FROGGS> timotimo_: what are you up to?

[21:52] *** d4l3k_ joined
[21:52] <FROGGS> I am currently working on bless, dunno if you know what it does in P5

[21:52] <timotimo_> well, i just randomly picked out a test file (04-strings.t i think) and it failed 10 out of 15, because it was dieing fatally when trying to put a string into a variable

[21:53] <timotimo_> i have a basic idea, but i wouldn't be able to fix anything about it

[21:53] * masak waves from .uk

[21:53] <timotimo_> heyo masak :)

[21:53] <FROGGS> masak o/

[21:53] *** sergot left
[21:53] <masak> heyo! :)

[21:53] <FROGGS> hmmm, let me run that test

[21:53] *** pmichaud left
[21:53] *** pmichaud joined
[21:53] *** dalek left
[21:53] <masak> the sun never sets on the British empire. but it sure can rain now and then.

[21:53] <timotimo_> so what it was doing is this: my $o = "o"; $o .= "k 10 - concat"; $o = "new long string to use substr on";

[21:54] <timotimo_> and it gets "cannot change immutable value" when it tries to set $o to the new string

[21:54] *** tadzik left
[21:54] *** [Coke] joined
[21:54] *** tadzik joined
[21:54] *** sergot joined
[21:54] *** d4l3k_ is now known as dalek

[21:55] <masak> today when coding Perl 6, I was suffering from the complete lack of tie between a nested class and the class it's nested in. yes, I know Perl 6 doesn't do that kind of thing; I just think it's a bit of a pity.

[21:55] <tadzik> masak! \o/

[21:56] <masak> in the end, I used a dynamic variable to talk between them. which works, but is kind of inelegant.

[21:56] <masak> tadzik! \o/

[21:57] <timotimo_> oh no, i think i made something die ;_;

[21:57] <masak> my use case was this: the outer class was a (LaTeX) table. the inner class was a table row. the table row has a @.columns attribute with bits of text in it. the table has a @!columns_max_widths attribute. so far so good.

[21:57] <masak> each class is responsible for rendering itself (with .Str)

[21:58] <FROGGS> timotimo_: the .= operator is faulty as it seems

[21:58] <timotimo_> yes, but i don't understand why. i tried to turn P5~ to return my $ = ... instead and didn't help

[21:58] <masak> but at the time the table row needs to render itself, it needs the information about the max widths from its table.

[21:58] <FROGGS> you cant reassign to a var after that

[21:58] <masak> and there's no way to access that.

[21:58] <timotimo_> FROGGS: yeah, that's what i figured ;)

[21:58] <FROGGS> timotimo_: I guess $s contains an unboxed string afte the .= or something like that

[21:59] <timotimo_> oh! unboxed? whoops :)

[21:59] <timotimo_> but it just uses [~]

[21:59] <sorear> nqp-jvm: my $x=[]; say($x =:= $x)

[21:59] <camelia> nqp-jvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near "[]; say($x"␤  in panic␤  in infix:sym<=>␤  in !protoregex␤  in infix␤  in infixish␤  in EXPR␤  in statement␤  in statementlist␤  in comp_unit␤  in TOP␤  in parse␤  in parse␤  in <anon>␤  in compile␤…

[21:59] <timotimo_> i don't understand why it would break

[22:00] *** bluescreen10 left
[22:00] <FROGGS> timotimo_: maybe we have to make a new Str after the concat?

[22:00] *** Chillance left
[22:00] <timotimo_> should i try that?

[22:00] <FROGGS> yeah

[22:00] <sorear> nqp-jvm: my $x=[]; say(nqp::eqaddr($x,$x))

[22:00] <timotimo_> i'm currently fixing up my improved error messages for shaped hashes

[22:00] <camelia> nqp-jvm: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near "[]; say(nq"␤  in panic␤  in infix:sym<=>␤  in !protoregex␤  in infix␤  in infixish␤  in EXPR␤  in statement␤  in statementlist␤  in comp_unit␤  in TOP␤  in parse␤  in parse␤  in <anon>␤  in compile␤…

[22:01] <sorear> nqp-jvm: my $x:=[]; say($x =:= $x)

[22:01] <camelia> nqp-jvm: OUTPUT«1␤»

[22:01] *** alester left
[22:01] <FROGGS> timotimo_: searching for 'Str' should give you something to copy&paste

[22:01] <timotimo_> r: my %h{Str(Any)}; # says "coercive type declarations not yet implemented. Sorry." locally

[22:01] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[22:01] <timotimo_> r: my %h{Str;Str}; # says "Multidimensional hashes not yet implemented. sorry." locally

[22:01] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[22:03] *** rindolf left
[22:04] *** lustlife` left
[22:04] <FROGGS> r: class U { method new { self.HOW.^add_parent(Array) } };

[22:04] <camelia> rakudo b2072f:  ( no output )

[22:04] <timotimo_> i really wish there was a more helpful error message when the version of some module is "out of date"

[22:05] <FROGGS> yeah :/

[22:05] <timotimo_> i should try to hack on that, if that's anywhere in nqp at all

[22:05] *** MuRd0c_x01 joined
[22:06] <FROGGS> hmmm, could be nqp, there is some sha stuff for that iirc

[22:06] <FROGGS> r: class U { method new { self.HOW.^add_parent(Array) } }; my $uo = U.new; push $uo, 1 # this fails locally

[22:06] <camelia> rakudo b2072f: OUTPUT«NQPClassHOW does not support adding parents after being composed.␤  in any add_parent at src/stage2/gen/nqp-mo.nqp:767␤  in method new at /tmp/yacDiGG1_9:1␤  in block  at /tmp/yacDiGG1_9:1␤␤»

[22:06] <FROGGS> ahh

[22:08] <timotimo_> yay, i should try a new spectest now. i'm hopeful :)

[22:09] *** tomyan joined
[22:09] <FROGGS> :o)

[22:12] <FROGGS> r: class U { }; my $uo = U.new but Array.new; say $uo; say $uo.^methods # it is not that easy ehh?

[22:12] <camelia> rakudo b2072f: OUTPUT«U+{}.new()␤␤»

[22:13] * sorear has continuation tests

[22:13] <sorear> tonight: make them pass

[22:14] <timotimo_> ... continuations as in ... actual continuations?

[22:14] <timotimo_> for gather/take?

[22:14] <colomon> \o/

[22:14] <ssutch> just watched jnthn's "To the JVM and beyond!" talk. it was awesome.

[22:14] <timotimo_> yaaaaays

[22:14] *** tomyan left
[22:15] <diakopter> sorear: good luck :)

[22:15] <FROGGS> ssutch: do you have a link for me?

[22:15] <ssutch> FROGGS: https://www.youtube.com/watch?v=LHjF3WujAu8

[22:15] <FROGGS> thanks!

[22:16] <sorear> timotimo_: yes, actual continuations, for gather/take

[22:16] <ssutch> np!

[22:18] <ugexe> im trying to test a module but prove -e perl6 -l t/ but it isnt looking in /lib for the module (which isnt installed yet) so it fails during the first test. how do i do this without manually adding use lib 'lib' to everything?

[22:18] <timotimo_> that's cool :)

[22:18] <diakopter> Liz' talk: http://www.youtube.com/watch?v=P0pm5eUOhbY

[22:18] *** btyler joined
[22:19] <timotimo_> Too many positional parameters passed; got 2 but expected 0 in block  at t/spec/S02-names-vars/signature.rakudo:82

[22:19] <timotimo_> this fail for anyone else?

[22:20] <timotimo_> r: my @list = 1..4; my (:@even, :@odd) := classify { $_ %% 2 ?? 'even' !! 'odd' }, @list;

[22:20] <camelia> rakudo b2072f:  ( no output )

[22:20] <timotimo_> huh, did i break it?!

[22:21] <tadzik> This talk was given at the First Dutch Perl Workshop on 25 May 2013 in Warsaw

[22:21] <tadzik> wæt‽

[22:22] <diakopter> yah

[22:22] <diakopter> (and again in Austin)

[22:22] <sorear> that's....not a very Dutch city.

[22:22] <FROGGS> *g*

[22:23] <ssutch> i am stumped again: https://gist.github.com/samuraisam/5785740

[22:23] <ssutch> a grammar for a string literal

[22:24] <ssutch> you know, it occurs to me that TinyJSON probably addresses this

[22:24] <ssutch> only, json does not allow for single quotes

[22:24] <diakopter> regular char also needs to exclude double quotee

[22:24] <masak> ssutch: if you could provide some failing test input as well...?

[22:24] <FROGGS> ssutch: yours would allow: "abc'

[22:24] <timotimo_> watch out, you... yeah

[22:24] <ssutch> yeah

[22:24] <ssutch> masak: i can indeed

[22:25] * sorear will watch that later

[22:25] <timotimo_> you're matching \\ in regular-char

[22:25] <diakopter> also double quote

[22:25] <timotimo_> indeed

[22:25] *** dukeleto joined
[22:25] <FROGGS> you could do: :my $quote; <quote> { $quote := ~$<quote> } [<hex-escape> | <oct-escape> | <char-escape> | <regular-char>]+ $quote

[22:26] <diakopter> ssutch: remember those token alternations aren't in any order

[22:26] <timotimo_> why not <start=quote> ... $<start>?

[22:26] <ssutch> diakopter: their order is insignificant?

[22:26] <timotimo_> | is "longest token matching" semantics

[22:27] *** spider-mario left
[22:27] <FROGGS> timotimo_: I believe you have at least to put a { } in between for current rakudo

[22:27] <timotimo_> ok

[22:27] <ssutch> yeah, it pukes

[22:27] <diakopter> it takes the one that matches the most

[22:28] <ssutch> diakopter: ah, ok

[22:28] *** btyler left
[22:28] <ssutch> timotimo_ FROGGS rakudo actually accepts timotimo_'s suggestion

[22:28] <timotimo_> ooooh yay

[22:28] <timotimo_> rakudo++

[22:28] *** zby_home_ left
[22:29] *** dukeleto left
[22:29] *** dukeleto joined
[22:30] <FROGGS> cool

[22:30] <timotimo_> r: say "'balanced'" ~~ / $<quote>=[\" | \'] \w+ $<quote> /; say q{'balanced"} ~~ / $<quote>=[\" | \'] \w+ $<quote> /;

[22:30] <camelia> rakudo b2072f: OUTPUT«｢'balanced'｣␤ quote => ｢'｣␤␤Nil␤»

[22:30] <timotimo_> indeed. cool beans :)

[22:30] <ssutch> gist is updated with failing code: https://gist.github.com/samuraisam/5785740

[22:31] <ssutch> it actually goes into an infinite loop

[22:31] <FROGGS> r: say "'balanced'" ~~ / ([\" | \']) \w+ $0 /;

[22:31] <camelia> rakudo b2072f: OUTPUT«｢'balanced'｣␤ 0 => ｢'｣␤␤»

[22:31] <FROGGS> cool,

[22:31] <FROGGS> somebody fixed it :o)

[22:31] <timotimo_> er, there is no TOP rule there

[22:31] <ssutch> oh, right.. derp

[22:32] <ssutch> gist is updated :)

[22:33] <ssutch> it's not quite perfect

[22:33] <FROGGS> rn: say 1001110011 ~~ /^ (.+) $0+ @([\~] $0.comb)? $ / # RT 111518

[22:33] <camelia> niecza v24-76-g3e65d84: OUTPUT«｢1001110011｣␤ 0 => ｢10011｣␤␤»

[22:33] <camelia> ..rakudo b2072f: OUTPUT«No such method 'comb' for invocant of type 'Any'␤  in regex  at /tmp/QwWnmNJAY3:1␤  in method ACCEPTS at src/gen/CORE.setting:10509␤  in method ACCEPTS at src/gen/CORE.setting:683␤  in block  at /tmp/QwWnmNJAY3:1␤␤»

[22:33] <timotimo_> it gives me a failed match instead of an infinite loop

[22:33] <FROGGS> rn: say 1001110011 ~~ /^ (.+) $0+ $ / # RT 111518

[22:33] <camelia> rakudo b2072f, niecza v24-76-g3e65d84: OUTPUT«｢1001110011｣␤ 0 => ｢10011｣␤␤»

[22:33] <ssutch> yeah putting the TOP in there fixed the loop

[22:33] <timotimo_> :)

[22:34] <ssutch> [derp]

[22:34] <timotimo_> also, removing the ; should make it match

[22:34] <ssutch> i have, it doesn't

[22:34] <timotimo_> (actually not, no)

[22:34] <timotimo_> did you try the rakudo::debugger yet?

[22:34] <ssutch> i haven't, i should

[22:34] <timotimo_> i think '\\' would match two actual backslashes, hold on

[22:34] <ssutch> i have been using Grammar::Tracer successfully

[22:35] <timotimo_> r: "\\" ~~ / '\\' /

[22:35] <camelia> rakudo b2072f:  ( no output )

[22:35] <timotimo_> r: say "\\" ~~ / '\\' /

[22:35] <camelia> rakudo b2072f: OUTPUT«｢\｣␤␤»

[22:35] <timotimo_> r: say "\\\\" ~~ / '\\' /; say "\\\\"

[22:35] <camelia> rakudo b2072f: OUTPUT«｢\｣␤␤\\␤»

[22:35] <ssutch> in this case, <regular-char> matches the ending "

[22:35] <timotimo_> ah, ok

[22:35] <timotimo_> oooh, good point.

[22:35] <timotimo_> but shouldn't it backtrack?

[22:36] <timotimo_> and \' is nicer than '\''

[22:36] <timotimo_> </nitpick>

[22:36] <ssutch> right

[22:37] <ssutch> when it is functional, i am happy to pick it apart to learn more, but my goal now is focused on making it work at all

[22:38] <ssutch> it occurs to me that matching every character against 4 regex is probably not the most performant option

[22:38] <timotimo_> sure

[22:38] <ssutch> (using perl6-debug, wrock!)

[22:38] <timotimo_> :)

[22:39] <ssutch> it doesn't appear to do any backtracking

[22:39] <timotimo_> mhm

[22:39] *** Nom- left
[22:39] <timotimo_> oh yeah

[22:39] <timotimo_> token implies :ratchen

[22:39] <timotimo_> try rule instead of token

[22:39] <timotimo_> or regex perhaps? i would need to look up the difference again

[22:40] *** Nom- joined
[22:40] <ssutch> it says in rule and token that backtracking must be explicit

[22:40] <timotimo_> indeed

[22:40] <ssutch> how does one alter that behavior

[22:40] <FROGGS> rule is about matching whitespace implicitly

[22:40] <FROGGS> >>

[22:41] *** census left
[22:41] <timotimo_> ah, right

[22:41] <ssutch> so i should put a :? at the end of <regular-char>

[22:41] *** benabik left
[22:42] <ssutch> or on the $<start>

[22:43] *** abnorman left
[22:43] *** abnorman joined
[22:43] *** abnorman left
[22:45] <ssutch> stepping through the debugger, neither :? nor :! at the end of either <regular-char> or $<start> have an effect

[22:45] *** xenoterracide|2 left
[22:47] <timotimo_> tadzik: can you test if the select() function actually properly returns an array with three arrays inside?

[22:48] *** Rix left
[22:53] *** salv0 left
[22:54] <masak> 'night, #perl6

[22:54] <timotimo_> 'night masak

[22:54] <timotimo_> have fun in the uk :)

[22:56] *** Rix joined
[22:57] *** salv0 joined
[23:01] <dalek> v5: a9deae2 | (Tobias Leich)++ | lib/Perl5/ (2 files):

[23:01] <dalek> v5: treat packages like classes

[23:01] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/a9deae2618

[23:04] *** MuRd0c_x01 left
[23:04] <timotimo_> ugexe: somehow the -1 return value for the edistance if the limit was reached feels inelegant to me, but i don't know what's common to do the same thing

[23:07] <timotimo_> maybe Nil makes more sense? or perhaps Int

[23:07] <timotimo_> there's also a stray comma in your edistance signature, and if you're at it, could even add Int for the $edistance and Str for the source and target (unless it works on non-strings, too?)

[23:08] <dalek> ecosystem: f3d2ee0 | ugexe++ | META.list:

[23:08] <dalek> ecosystem: Add Text::Levenshtein::Damerau

[23:08] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/f3d2ee0634

[23:08] <dalek> ecosystem: e1d945f | (David Warring)++ | META.list:

[23:08] <dalek> ecosystem: Merge pull request #25 from ugexe/patch-1

[23:08] <dalek> ecosystem: 

[23:08] <dalek> ecosystem: Add Text::Levenshtein::Damerau

[23:08] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e1d945fff7

[23:16] <perigrin> Darmok and Levenshetin at The Library.

[23:17] <timotimo_> slaves to darmok: god of blood

[23:17] <timotimo_> chapter 2: dwarf levenshtein

[23:17] <FROGGS> Darmok, his hands wide...

[23:21] <sorear> timotimo_: Inf maybe?  or $limit+1?

[23:22] <diakopter> FROGGS: at Tinagra?

[23:22] <FROGGS> diakopter: I remembered something like Tenagra, but yes :o)

[23:22] *** s1n left
[23:23] <FROGGS> maybe this is due to the german translation

[23:23] <perigrin> Temba his arms wide ... 

[23:24] <perigrin> Darmok and Gilad at Tenagra.

[23:24] <FROGGS> perigrin++

[23:26] * sorear ponders nqp::dynamicwind

[23:27] * colomon ponders sailing the dynamic wind...

[23:28] <[Coke]> beats the static wind.

[23:29] <ssutch> aha! https://gist.github.com/samuraisam/5785740

[23:30] <ssutch> perhaps more verbose, but for my feeble abilities, appears to work

[23:31] <sorear> my mind translates 'dynamic wind' to 'apparent wind', interestingly

[23:32] <timotimo_> i broke a test with my "improvement" of the error message :(

[23:34] *** abnorman joined
[23:35] <ugexe> timotimo_: will do

[23:35] <timotimo_> i think i found out what happened, but i don't understand why it broke the test ... not at all :(

[23:35] *** lizmat joined
[23:36] <ssutch> Grammar::Tracer and perl6-debug do not like to play together

[23:37] <timotimo_> the debugger shouldn't step into the tracer, though, should it?

[23:37] <timotimo_> because the tracer was compiled without the debug hooks i think?

[23:43] <timotimo_> and now it works, but why? i'm confused, but i won't argue with the spectests

[23:43] <timotimo_> (40 minutes of spectests now :( )

[23:46] <timotimo_> i was testing the wrong test file >_>

[23:47] <timotimo_> can someone please check t/spec/S02-names-vars/signature.rakudo? because it gives me Too many positional parameters passed; got 2 but expected 0 for the 13th test, but i don't know if my changes caused that and i don't have the time to build another older rakudo >_>

[23:47] <lizmat> will do

[23:48] <lizmat> got the same error here

[23:48] <diakopter> lizmat: your talk is online

[23:50] *** woolfy joined
[23:51] <timotimo_> oh thank you so much, lizmat, i was going crazy

[23:51] *** lizmat left
[23:51] <timotimo_> because the same code on the evalbot doesn't error out >_<

[23:51] *** lizmat joined
