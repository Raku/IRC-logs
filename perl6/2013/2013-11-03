[00:02] <colomon> whats the reverse of ords?

[00:03] <benabik> sdro

[00:03] <Mouq> r: "abcd".ords.chrs.say

[00:03] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[00:03] <camelia> ..rakudo-parrot 3164ca: OUTPUT«abcd␤»

[00:03] <benabik> r: 'ords'.reverse.say

[00:03] <camelia> rakudo-parrot 3164ca: OUTPUT«ords␤»

[00:03] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[00:03] <colomon> Mouq++

[00:04] <colomon> I actually tried that, but it turns out...

[00:04] <benabik> Huh.  odds is the reverse of odds.  Weird.

[00:04] <colomon> rn: say (92,80,92,67).chrs

[00:04] <camelia> rakudo-parrot 3164ca, niecza v24-98-g473bd20: OUTPUT«\P\C␤»

[00:04] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[00:05] <Mouq> rn: 'ords'.flip.ords.reverse.chrs.say

[00:05] <camelia> rakudo-parrot 3164ca, niecza v24-98-g473bd20: OUTPUT«ords␤»

[00:05] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[00:05] *** ssutch left
[00:05] <lue> That's weird. My callmethod op comes out as QAST::Op(call &postfix:<>) . No clue if that's right or not.

[00:05] <colomon> huh.  here's what I get locally

[00:05] <colomon> > (92,80,92,67).chrs

[00:05] <colomon> Method 'chrs' not found for invocant of class 'Parcel'

[00:05] <benabik> nqp: say (92,80,92,67).chrs

[00:06] <camelia> nqp-jvm: OUTPUT«Confused at line 2, near "say (92,80"␤  in panic (gen/jvm/stage2/NQPHLL.nqp:379)␤  in comp_unit (gen/jvm/stage2/NQP.nqp:922)␤  in TOP (gen/jvm/stage2/NQP.nqp:820)␤  in parse (gen/jvm/stage2/QRegex.nqp:1247)␤  in parse (gen/jvm/stage2/NQPHLL.nqp:1378)␤  in…»

[00:06] <camelia> ..nqp-moarvm: OUTPUT«Confused at line 2, near "say (92,80"␤panic␤»

[00:06] <camelia> ..nqp-parrot: OUTPUT«Confused at line 2, near "say (92,80"␤current instr.: 'panic' pc 16305 (gen/parrot/stage2/NQPHLL.pir:6018) (gen/parrot/stage2/NQPHLL.nqp:426)␤»

[00:06] <Mouq> colomon: what's your version? as I recall, that was a recent thing

[00:06] <Mouq> well, like last month or so

[00:06] <colomon> 2013.08-99-ga13cec9

[00:06] <colomon> guess my Mac is way behind.

[00:07] <lue> Mouq++ for the parse/ast tip. I've been stuck in "you can use the grammar tracer" land for a while, and I forgot the other debugging methods :)

[00:08] <Mouq> lue: :)

[00:08] *** preflex left
[00:10] *** preflex joined
[00:10] *** ChanServ sets mode: +v preflex

[00:11] <lue> nqp seems to handle a callmethod correctly, so somehow NQP code is leaking into the AST of my stuff :/

[00:15] *** raiph left
[00:18] <Mouq> r-p: say '°•°•.•.•°•°•.•°•.•°'~~/\°+%\•+%\./

[00:18] <camelia> rakudo-parrot 3164ca: OUTPUT«｢°•°•.•.•°•°•.•°•.•°｣␤␤»

[00:22] *** risou_awy is now known as risou

[00:27] <jnthn> .tell jaffa4 because you didn't pass a :actions(...), which is required

[00:29] <jnthn> arnsholt: See docs/6model/repr-compose-protocol.markdown, the array section

[00:30] *** ssutch joined
[00:32] <jnthn> sleep &

[00:38] *** risou is now known as risou_awy

[01:05] *** raiph joined
[01:22] *** nnunley left
[02:00] <timotimo> r-j: say $*VM<name>

[02:00] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[02:01] <pdurbin> timotimo: how's perl6 on the jvm going?

[02:02] <timotimo> pretty good actually

[02:02] <timotimo> jnthn++ has been making pretty darn cool parallelism constructs for us

[02:03] <timotimo> and we have JVM interop, so that we can use classes from java and implement some interfaces like "runnable" (or something like that?) just by having a sub

[02:04] <pdurbin> somewhere on http://6guts.wordpress.com I looked at some pdf that gave a nice high level overview of perl6 on the jvm

[02:05] <timotimo> ah damn. we need a pbc_to_exe equivalent for the jvm so that we can build a binary from rakudo-debugger.

[02:05] <timotimo> yes, that would be his talk slides i'd bet

[02:05] <timotimo> http://jnthn.net/papers/2013-yapceu-jvm.pdf

[02:05] <pdurbin> it's was interesting to read how for certain workloads the jvm is much more efficient than parrot

[02:05] <timotimo> yes, truly

[02:05] <timotimo> the JIT is pretty darn good.

[02:06] <pdurbin> yeah, page 47. 11 minutes vs. 7 hours, 52 minutes

[02:06] <timotimo> and also the way our classes work is a bit nicer on the JVM than on parrot. and much nicer still on moarvm

[02:07] <pdurbin> timotimo: thanks

[02:07] <timotimo> you're welcome

[02:07] * lue idly considers Moar

[02:09] <pdurbin> a guy at work gave a talk on scala. who knows. maybe we'll consider languages besides java on the jvm some day :)

[02:09] <timotimo> :)

[02:10] <pdurbin> his slides: https://lists.iq.harvard.edu/pipermail/techtalkfollowup/2013-August/000006.html

[02:13] <pdurbin> timotimo: is there a place to check for general status of perl6 on the jvm? what's working, what's not working, etc.

[02:15] <timotimo> yeah, the perl6-roast-data repository on coke's github gives you the percentages of relative spectest success and details which spectests are skipped

[02:15] <timotimo> almost everything that works on parrot works on jvm. the one important thing that's missing before we make a Rakudo-jvm Star release is Native Call

[02:15] <timotimo> in that case, it means calling C code from a rakudo-jvm

[02:16] <timotimo> and the jvm has stuff that doesn't work on parrot. and now there's tests for the stuff that is not on parrot, so maybe rakudo-parrot will not stay the leader in the scoring :)

[02:16] * pdurbin looks at https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates.csv

[02:18] <pdurbin> wow, almost everything. so I see

[02:18] <timotimo> sometimes there's problems with the test runs, though, like it hanging in the middle

[02:18] <timotimo> yes, indeed :)

[02:18] <timotimo> but 100% doesn't mean 100% of tests succeed. lots of tests are skipped or todos

[02:19] <timotimo> i think that's the difference between the "spec" and "plan" columns

[02:20] <pdurbin> ah ha. but still, the "pass" numbers are very similar

[02:20] <timotimo> yes, indeed

[02:21] <timotimo> once you get to a compiling and running CORE.setting, you already have a big chunk of things covered

[02:22] <timotimo> aaw, i don't have a commit bit for rakudo-debugger

[02:23] *** risou_awy is now known as risou

[02:24] <pdurbin> "We hope to provide a JVM-based Rakudo Star release soon" -- http://rakudo.org/2013/10/29/rakudo-star-2013-10-released/

[02:25] <BenGoldberg> r-j: 1

[02:25] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[02:26] <BenGoldberg> Why is that happening?

[02:26] <pdurbin> timotimo: so nothing to download yet?

[02:30] <timotimo> right. i'm not sure if the compiler release has the backend "in it". i'm sure it should (also, it's just a source release)

[02:37] <pdurbin> ok

[02:38] <timotimo> what OS are you on? if you're interested in building one yourself, i can probably walk you through it. it's pretty easy nowadays

[02:39] <pdurbin> Fedora at home. Mac at work. Not sure I have time though :)

[02:40] *** risou is now known as risou_awy

[02:42] <pdurbin> but I appreciate the offer :) ... off to sleep

[02:42] *** pdurbin left
[02:52] *** REPLeffect left
[03:07] *** REPLeffect joined
[03:17] *** ssutch left
[03:56] *** xinming_ joined
[03:59] *** xinming left
[04:02] *** ssutch joined
[04:14] *** rurban joined
[04:19] *** risou_awy is now known as risou

[04:33] *** johnny5_ left
[04:35] *** johnny5_ joined
[04:51] *** BenGoldberg left
[04:51] *** preflex_ joined
[04:51] *** ChanServ sets mode: +v preflex_

[04:52] *** preflex left
[04:52] *** preflex_ is now known as preflex

[04:59] *** Karlo7 joined
[04:59] <Karlo7> rakudo

[05:01] <Karlo7> perl6:say rakudo

[05:02] <Karlo7> perl6:say rakudo;

[05:03] <Karlo7> perl6: rakudo;

[05:04] <camelia> niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'rakudo' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp…»

[05:04] <camelia> ..rakudo-parrot 3164ca: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/PnIEjmyufV␤Undeclared routine:␤    rakudo used at line 1␤␤»

[05:04] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[05:05] <Karlo7> perl6: say 3;

[05:05] <dalek> ecosystem: e72e6d7 | (Nick Patch)++ | META.list:

[05:05] <dalek> ecosystem: add CLDR::List

[05:05] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e72e6d7dcd

[05:05] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[05:05] <camelia> ..rakudo-parrot 3164ca, niecza v24-98-g473bd20: OUTPUT«3␤»

[05:09] *** Karlo7 left
[05:14] *** rurban left
[06:15] *** raiph left
[06:19] *** ingy1 joined
[06:20] *** rurban joined
[06:20] *** ingy1 left
[06:32] *** rurban left
[06:47] *** bbkr joined
[06:57] *** woolfy joined
[06:58] *** darutoko joined
[07:01] *** dansamo joined
[07:01] *** dansamo left
[07:02] *** dansamo joined
[07:03] *** lizmat joined
[07:11] *** k-ray joined
[07:12] *** bbkr left
[07:18] *** johnny5_ left
[07:20] *** johnny5_ joined
[07:25] *** tobyink joined
[07:33] *** rurban joined
[07:48] *** rurban left
[07:49] *** woolfy left
[07:51] *** tobyink left
[07:54] *** lizmat left
[07:55] *** hummeleB1 left
[07:58] *** dansamo left
[08:06] *** johnny5_ left
[08:07] *** johnny5_ joined
[08:08] *** ssutch left
[08:15] *** tobyink joined
[08:48] *** kaare_ joined
[08:51] *** rurban joined
[08:58] *** rurban left
[08:58] <FROGGS> morning

[09:06] *** lizmat joined
[09:09] <masak> o/

[09:10] <lizmat> masak: /o

[09:10] <FROGGS> morning lizmat 

[09:10] * lizmat is catching up on backlog

[09:10] <lizmat> the jnthn has not entered the building yet

[09:11] <FROGGS> :o)

[09:12] *** woolfy joined
[09:12] <lizmat> correction: jnthn has entered the building

[09:20] *** jaffa4 joined
[09:22] <woolfy> update: jnthn is in the building and standing next to our table and talking to Nick

[09:22] <woolfy> update: he still is talking...

[09:22] <woolfy> ...

[09:24] <lizmat> update: woolfy is taking pictures

[09:24] <FROGGS> hehe

[09:25] <FROGGS> I am feeling being involved :o)

[09:25] <lizmat> update: woolfy stopped taking photos

[09:25] * woolfy confirms lizmat's updates

[09:25] <jaffa4> what is going on?

[09:26] <FROGGS> jaffa4: they are at the perl workshop in Austria

[09:26] <woolfy> FROGGS: would be nice if you would be here too.  It's nice.  Nice office, nice people, nice city.  Already 14 people present in hackathon room.  Some of them are really hacking.

[09:26] <FROGGS> jaffa4: btw, jnthn replied to you in the backlog

[09:27] <jaffa4> What backdoor?

[09:27] <FROGGS> woolfy: yeah, I wanted to come, but my wife is getting a job as it seems (starting tomorrow)

[09:27] <jaffa4> And replies on what?

[09:28] <FROGGS> jaffa4: irc backlog, see http://irclog.perlgeek.de/perl6/search/?nick=jnthn&q=jaffa4

[09:29] <woolfy> FROGGS: wife's job is way more important. You did choose well.

[09:30] <jaffa4> not sure what his wife's job has to do anything

[09:30] <FROGGS> woolfy: yeah, especially when she had none since four years now :o)

[09:31] <FROGGS> jaffa4: I have two young kids, somebody has to care :o)

[09:31] <FROGGS> so I can't travel around

[09:33] <woolfy> Wife could have some moral (and household) support as well after first job in 4 years!

[09:33] <woolfy> I can't find the Camelia logo graphics file on www.perl6.org .  Anybody an idea where to find it?  The scalable version would be nice.

[09:33] <FROGGS> that too of course

[09:34] <FROGGS> woolfy: it is on wall.org I think

[09:35] <jaffa4> FROGGS: Austrlian workshops seems to be very small

[09:35] <woolfy> hmmm, not a very helpful url

[09:35] <FROGGS> woolfy: I am still searching

[09:35] <woolfy> jaffa4: the workshop had 22 attendees yesterday.  Today is hackathon and 14 people present, more coming in later.

[09:36] <FROGGS> woolfy: http://commons.wikimedia.org/wiki/File:Camelia.svg

[09:36] <FROGGS> jaffa4: and we are talking about Austria in Europe

[09:37] <jaffa4> so am I.

[09:37] <FROGGS> ahh,, k

[09:37] <woolfy> FROGGS: thanks, that's the one.

[09:37] <woolfy> jaffa4: quantity, not quality...  :-)

[09:37] <jaffa4> you mean the reverise

[09:37] <lizmat> "Austrlian" seems to be the love child of "Austrian" and "Australian"

[09:38] <jaffa4> I have typing difficulties

[09:38] <jaffa4> and I spend time in Autralia and I keep remembering I think

[09:40] <jaffa4> FROGGS: I need to pass :actions... so what do I need to do exactly?

[09:40] <FROGGS> jaffa4: something like: Perl6::Grammar.parse( $code, :actions(Perl6::Actions.new) )

[09:41] <jnthn> morning o/

[09:41] <arnsholt> 'lo

[09:42] <arnsholt> jnthn: Thanks for your reply last night

[09:43] <FROGGS> hi jnthn, arnsholt 

[09:43] <arnsholt> I've put the CArray refactor idea on the back burner for now, as I need to get a better grip on how parametric classes work first =)

[09:44] <jnthn> ok 

[09:45] <jnthn> .oO( me too! )

[09:45] <jnthn> arnsholt: Maybe look at how I did Buf

[09:45] <jnthn> arnsholt: And blob

[09:45] <jnthn> We can steal those improvements

[09:45] <jnthn> and use them for NativeCall

[09:50] <dalek> specs: 73b7398 | (Elizabeth Mattijsen)++ | S11-modules.pod:

[09:50] <dalek> specs: Some more on CompUnitRepo and CompUnit

[09:50] <dalek> specs: review: https://github.com/perl6/specs/commit/73b739897e

[09:53] <arnsholt> jnthn: Yeah, I looked at Buf and Blob last night

[09:53] <arnsholt> I'll probably steal much from there

[09:53] <arnsholt> But first, I'll get CArray working on JVM =)

[10:00] *** rurban joined
[10:09] <jaffa4> r: use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; say Perl6::Grammar.parse( 'my $b=4;', :actions(Perl6::Actions.new())  );

[10:09] <camelia> rakudo-parrot 3164ca: OUTPUT«No such method 'gist' for invocant of type 'NQPMatch'␤  in sub say at gen/parrot/CORE.setting:12843␤  in block  at /tmp/oK31MAmT0h:1␤  in any  at /tmp/oK31MAmT0h:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage…»

[10:09] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[10:10] <jaffa4> FROGGS: something is still wrong

[10:11] <jaffa4> r: use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; my $g =  Perl6::Grammar.parse( 'my $b=4;', :actions(Perl6::Actions.new())  );

[10:11] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[10:11] <camelia> ..rakudo-parrot 3164ca: OUTPUT«Nominal type check failed for parameter '$got'; expected Any but got NQPMatch instead␤  in block  at /tmp/WObpfq9ZTX:1␤  in any  at /tmp/WObpfq9ZTX:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:113…»

[10:11] <moritz> you'll get an NQP Match object back, not a Perl 6 Match object

[10:11] <moritz> so you have to be extra careful about what you do with it

[10:12] <jaffa4> I just put it into a variable

[10:12] <jaffa4> So what can I do with it?

[10:12] <FROGGS> jaffa4: this message is some sort of success: No such method 'gist' for invocant of type 'NQPMatch'

[10:13] <jaffa4> yes, look at my second attempt

[10:13] <FROGGS> it means that you get a Match back (from nqp land), but you can't gist it

[10:13] <jaffa4> I cannot put it into  variable

[10:13] <FROGGS> same thing, it is an nqp-object, not a perl6 one

[10:14] <FROGGS> r: use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; my Mu $g := Perl6::Grammar.parse( 'my $b=4;', :actions(Perl6::Actions.new())  );

[10:14] <camelia> rakudo-parrot 3164ca: ( no output )

[10:14] <camelia> ..rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[10:19] <FROGGS> rp: use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; say Perl6::Grammar.parse( 'my $b=4;', :actions(Perl6::Actions.new())  ).dump;

[10:19] <camelia> rakudo-parrot 3164ca: OUTPUT«- statementlist: my $b=4;␤  - statement: 1 matches␤    - EXPR: my $b=4␤      - scope_declarator: my $b=4␤        - sym: my␤        - scoped:  $b=4␤          - DECL: $b=4␤            - initializer: 1 matches␤              - sym: =␤      …»

[10:19] <FROGGS> rp: use Perl6::Grammar:from<NQP>; use Perl6::Actions:from<NQP>; say Perl6::Grammar.parse( 'my $b=4;', :actions(Perl6::Actions.new())  ).ast.dump

[10:20] <camelia> rakudo-parrot 3164ca: OUTPUT«- QAST::CompUnit␤  - QAST::Block my $b=4;␤    - QAST::Var(local __args__ :decl(param))␤    - QAST::Stmts␤    - QAST::Op(call)␤      - QAST::Block ␤        - QAST::Stmts␤          - QAST::Var(lexical GLOBALish :decl(static))␤          - QA…»

[10:20] *** rurban left
[10:25] <jaffa4> slooks good

[10:27] <FROGGS> you still have the problem with the nqp <-> perl6 boundary

[10:29] <jaffa4> How do I enumarate this?

[10:33] <FROGGS> do you mean iterate? there are ops for it, grep for nqp::iter* in nqp

[10:34] <jaffa4> yes

[10:36] * xenoterracide scratches head at the name `elems` why not `size` or `count`

[10:37] <moritz> xenoterracide: because 'size' could be anything

[10:37] <moritz> xenoterracide: storage size, display size when printed, whatever

[10:37] *** denisboyun joined
[10:37] <moritz> count is better, but *what* is counted? elems!

[10:38] <xenoterracide> List.elems makes me think I'm returning the elements... List.size or List.count would both make me think of a numeric context... idk, just a thought, I'd never guess what elems means

[10:39] <moritz> that is a disadvantage, yes

[10:39] <lizmat> xenoterracide: but, Perl6 doesn't return elemens: it returns a list or Parcel with elems

[10:40] <lizmat> therefore .elems returns the number of elements

[10:40] <lizmat> .list or .Parcel returns the list or a parcel with the elements

[10:41] <moritz> or if you have a list, it already *is* the list of elems :-)

[10:41] *** tobyink left
[10:41] <xenoterracide> of course, when everything is an object... I'm just saying if I read this code, without referencing the docs I wouldn't know what it was doing

[10:42] <xenoterracide> of course to be fair if I didn't know perl I'm not sure I'd innately know what shift/unshift did either

[10:43] * xenoterracide shrugs, not a language designer, going back to my corner

[10:45] <xenoterracide> well, ok, I'll say one last thing I guess... my thought on any api design is that you should, in most cases, be able to read the class and method name and guess what the purpose is without (too much) prior knowledge

[10:45] <xenoterracide> List.first is extremely obvious

[10:45] <moritz> which immediately rules out List.size

[10:57] *** cognominal__ joined
[10:59] <xenoterracide> afaik, that may be common to other implementations, python uses count, java size, ruby size or length, js length, (I think length is weirder than size, but all seems better than elem ) 

[11:01] *** cognominal left
[11:01] <xenoterracide> notes the only reason I brought this up is I'm poking around writing a perl 5 collection api

[11:01] <xenoterracide> and decided to somewhat base it off perl6's method naming

[11:02] <moritz> "length" is another example that lacks a unit

[11:02] <xenoterracide> yeah I don't like length either

[11:02] <moritz> lenght in bytes? in characters? Codepoints? display length?

[11:04] <xenoterracide> but with elem, what about it? is it returning an elem object that's another collection type? telling me what type of elem (what of() does), it's just something I have to look up (barring familiarity)

[11:04] <xenoterracide> I think for what I'm working on I'll go with count

[11:04] <xenoterracide> Collection.count doesn't seem ambiguous

[11:04] <moritz> what does Hash.count return?

[11:05] <moritz> number of keys? or number of elems of the hash table?

[11:06] <xenoterracide> what does Hash.elem return?

[11:06] <moritz> number of pairs

[11:06] <xenoterracide> why would I guess that anymore than I would Hash.count

[11:07] <moritz> because count doesn't say *what* is counted

[11:07] <xenoterracide> how does elem?

[11:07] <moritz> it counts *elem*s

[11:07] <xenoterracide> a pair is an elem?

[11:07] <moritz> yes

[11:08] <lizmat> r: my @a=([],[],[]); sat @a.elems

[11:08] <lizmat> r: my @a=([],[],[]); say @a.elems

[11:08] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[11:08] <camelia> ..rakudo-parrot 3164ca: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ge8VOTYfMw␤Undeclared routine:␤    sat used at line 1. Did you mean '&set', '&say'?␤␤»

[11:08] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[11:08] <camelia> ..rakudo-parrot 3164ca: OUTPUT«3␤»

[11:09] <moritz> p: set(<a b a c>).elems

[11:09] <camelia> rakudo-parrot 3164ca: ( no output )

[11:09] <moritz> p: say set(<a b a c>).elems

[11:09] <camelia> rakudo-parrot 3164ca: OUTPUT«3␤»

[11:09] <moritz> p: say bag(<a b a c>).elems

[11:09] <camelia> rakudo-parrot 3164ca: OUTPUT«3␤»

[11:10] <xenoterracide> well maybe it makes more sense in perl6 though not sure if it does in perl 5... 

[11:10] <xenoterracide> I'll think on it

[11:10] <xenoterracide> it's not like I'll release the library in a week

[11:12] <xenoterracide> though knowing that it's looking at elems I'd probably still guess count was counting elems just have to know that detail... (which also seems relevant to understanding the name .elem)

[11:13] <moritz> in the context of a Perl 5 library it might even make sense to call it length, simply because that's the p5 idiom

[11:14] <xenoterracide> true, heh, forgot that function exists

[11:15] <Juerd> "length" isn't a p5 idiom for lists or arrays.

[11:16] <Juerd> Unless, of course, you want to know the number of digits of the number of elements... :P

[11:16] <moritz> right, that would be 'scalar'

[11:16] <xenoterracide> I coerce to scalar context alot

[11:19] <xenoterracide> on more perl 6 notes... has any thought been given to a variance in Native backend, say wanting to use JDBC DBD vs C DBD

[11:20] *** denis_boyun joined
[11:21] *** denisboyun left
[11:21] <arnsholt> I think moritz has mentioned the possibility, but nothing concrete exists so far AFAIK

[11:22] <lizmat> p: say bag(<a b a c>).total

[11:22] <camelia> rakudo-parrot 3164ca: OUTPUT«4␤»

[11:25] *** denis_boyun left
[11:26] *** denis_boyun joined
[11:27] *** spider-mario joined
[11:29] <xenoterracide> what's the difference between Blob and Buf?

[11:30] <jnthn> Mutability...in theory :)

[11:31] <jnthn> Though currently Rakudo doesn't let you mutate either. But Buf should be mutable.

[11:31] *** denis_boyun__ joined
[11:33] *** denis_boyun left
[11:36] *** Rotwang joined
[11:37] *** denis_boyun joined
[11:37] *** fridim_ joined
[11:38] *** denis_boyun__ left
[11:39] <arnsholt> jnthn: There doesn't seem to be separate allocate and initialize steps in 6model on JVM, that right?

[11:40] <xenoterracide> well in backend thought, if given a little API could largely leave it up to a convention ::PP or ::JVM ::Native and prefer JVM over Native on the jvm

[11:41] *** rindolf joined
[11:41] *** Rotwang left
[11:43] *** denis_boyun left
[11:43] <xenoterracide> if I do multi new ($param ) { ... } will that work as expected? also on native... is there an API that allows me to find out what the current environment is?

[11:43] *** denis_boyun joined
[11:49] *** pmurias joined
[11:50] <pmurias> xenoterracide: re JDBC DBD vs C DBD, you mean on the NativeCall level or on the module naming level?

[11:51] <xenoterracide> module naming, unless there was actually a saner way to do it

[11:55] *** Rotwang joined
[11:57] *** telex left
[11:58] *** SmokeMachine left
[11:58] *** telex joined
[11:59] <lizmat> moritz: when wanting to run a single spectest file, I usually do "make t/spec/name/ofspectest.t"

[11:59] <lizmat> on a dual installation, this uses the parakudo

[12:00] <moritz> lizmat: it uses the first of the backends detected or passed --backends=

[12:01] <lizmat> aha, ok

[12:01] <moritz> lizmat: would you prefer some other semantics?

[12:07] * lizmat is looking

[12:18] *** denis_boyun__ joined
[12:19] <xenoterracide> equivalent to __PACKAGE__? and does that vary whether I'm in a class/role/module ?

[12:19] *** denis_boyun left
[12:20] *** denis_boyun__ left
[12:23] *** denis_boyun joined
[12:25] *** dansamo joined
[12:26] *** denis_boyun_ joined
[12:27] *** dansamo left
[12:27] *** dansamo2 joined
[12:29] *** denis_boyun left
[12:29] *** djanatyn left
[12:31] *** djanatyn joined
[12:31] *** denis_boyun_ left
[12:32] *** denisboyun joined
[12:34] <moritz> r: class A { say $?PACKAGE }

[12:35] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[12:35] <camelia> ..rakudo-parrot 3164ca: OUTPUT«(A)␤»

[12:36] <moritz> rj:  say 'alive?'

[12:36] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: java.lang.OutOfMemoryError: Java heap space␤  in  (src/Perl6/Grammar.nqp)␤  in  (src/vm/jvm/ModuleLoader.nqp:62)␤  in  (src/vm/jvm/ModuleLoader.nqp:52)␤  in load_module␤  in ␤␤»

[12:37] <xenoterracide> require( $class ).new (IIRC this is possible though I think my invocation is slightly off...

[12:37] <moritz> require $class; ::($class).new

[12:37] *** denisboyun left
[12:37] <moritz> rj: say 'alive';

[12:37] <camelia> rakudo-jvm 882e33: OUTPUT«alive␤»

[12:38] *** denis_boyun joined
[12:42] <moritz> currently I wonder if I should start one eval server, and then kill it and start a new one after it has been used

[12:43] <lizmat> fwiw, I just installed javac on my macbook

[12:43] <lizmat> and trying to do jvm spectest

[12:43] <lizmat> it starts failing after about 40 tests

[12:44] <lizmat> the error I've been able to get out of that is:

[12:44] <lizmat> Error in socket connection:Exception in thread "Thread-71"

[12:44] <lizmat> java.lang.OutOfMemoryError: GC overhead limit exceeded

[12:44] <lizmat> does that ring any bell with anyone

[12:46] <lizmat> according to jnthn, this appears to be the same pb that [Coke]  sees/ has seen

[12:47] *** xenoterracide left
[12:59] *** xenoterracide joined
[13:02] *** Rotwang left
[13:05] <xenoterracide> is it possible to have a class and a module of the same name and export subroutines from the module and the class?

[13:05] <timotimo> does somebody want to build something like "pbc_to_exe" for the jvm port? it could create a sh on linux and a .bat on windows and find the right libraries and classpaths and stuff

[13:06] <FROGGS> xenoterracide: it is specced to load a module/class under a different name (alias), that is what you want, but unfortunately NYI

[13:07] <FROGGS> like: use Foo:from<NQP>:name<Bar>; use Foo;

[13:08] <xenoterracide> hmmm

[13:08] <FROGGS> or you would load a Foo with a different version as the other Foo, and load one of them under an alias

[13:08] <jnthn> xenoterracide: Why put the subs in a module at all?

[13:08] <jnthn> xenoterracide: Just mark the class is export and then shove the subs after it and makr them as is export

[13:08] <jnthn> they're lexical so it's not like they pollute anything.

[13:09] <FROGGS> jnthn: yeah, if you have the modules/classes under control :o)

[13:09] <xenoterracide> jnthn: suppose I could do that, (goes back to refactoring Digest)

[13:10] <nwc10> Thing I mentioned earlier - Devil's dictionary of programming: http://programmingisterrible.com/post/65781074112/devils-dictionary-of-programming

[13:10] <nwc10> (from Peter da Silva from David Gerard)

[13:14] * xenoterracide trying to make Digest a little more ... Digestable heh. Make it more like the perl 5 version and allow algorithm selection

[13:18] *** Rotwang joined
[13:25] <xenoterracide> I suppose I could TIAS but if you're inside of a .pm ... but not inside of a "package scope" then what "package" are you in? do those subs auto end up in a lexical block of main or something?

[13:25] <arnsholt> jnthn: Given that most REPRs use the same class as REPRData all the time, d'you think it would make sense to make STable on JVM STable<T>?

[13:26] <arnsholt> And then REPR<T>. It'd kill some casts in various places I think

[13:34] <jnthn> Yeah, but since it's just type erasure it makes no differene at runtime anyway...

[13:34] <jnthn> afaik, anyway

[13:35] <arnsholt> Yeah, it'd be purely a convenience while coding

[13:39] *** Rotwang left
[13:41] <jnthn> ah, ok

[13:43] *** dmol left
[13:45] <arnsholt> I've noticed that uses of REPRData are always accompanied by casting stuff, and that'd be a way to get rid of that

[13:46] *** dansamo2 left
[13:53] *** tobyink joined
[13:54] *** Rotwang joined
[14:00] *** dmol joined
[14:03] *** Rotwang left
[14:08] *** raiph joined
[14:14] <lizmat> std: my $p = ==> { ... }

[14:14] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed initializer at /tmp/Z1Kg553PWI line 1:␤------> [32mmy $p [33m⏏[31m= ==> { ... }[0m␤Parse failed␤FAILED 00:01 122m␤»

[14:15] <lizmat> std: my $p ==> { ... }

[14:15] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix => instead at /tmp/T0aNKiGYxo line 1:␤------> [32mmy $p =[33m⏏[31m=> { ... }[0m␤Parse failed␤FAILED 00:01 123m␤»

[14:16] *** zakharyas joined
[14:17] *** Rotwang joined
[14:21] *** BenGoldberg joined
[14:22] *** denis_boyun left
[14:27] *** denis_boyun joined
[14:27] <lizmat> TimToady: instead of async { ... }, maybe vow { ... } ?

[14:28] *** rurban joined
[14:33] *** Rotwang left
[14:40] *** denis_boyun left
[14:40] *** denisboyun joined
[14:44] *** denis_boyun joined
[14:46] *** denisboyun left
[14:47] *** Rotwang joined
[14:49] *** denis_boyun left
[14:50] *** FROGGS left
[14:50] *** denis_boyun joined
[14:53] *** FROGGS joined
[14:56] *** BenGoldberg left
[15:01] *** denis_boyun left
[15:05] *** dmol left
[15:12] <FROGGS> k, I think I fixed run() so that it does not run the program via a shell

[15:14] <japhb__> lizmat: schedule {} ?

[15:15] <japhb__> task {} ?

[15:15] *** zakharyas left
[15:16] <FROGGS> I dont think a noun is preferable

[15:16] <TimToady> unfortunately the English verb is "extract a promise"  :)

[15:17] <japhb__> TimToady: Actually, in retrospect, I kinda like your todo {} suggestion.

[15:17] <FROGGS> ohh, task is a verb too

[15:17] <japhb__> Since you can 'todo' something.

[15:17] <FROGGS> that feels more like NYI

[15:17] <FROGGS> like stub code

[15:17] <japhb__> :-/

[15:18] <TimToady> but todo has strong overtones that I'm going to do it, not someone else

[15:18] <FROGGS> (to me)

[15:18] <japhb__> That's a fair point

[15:18] <TimToady> wish at least is what you do to a genie, which is a separate agency

[15:18] <japhb__> job {}

[15:18] <diakopter> .

[15:19] <FROGGS> steve { }

[15:19] <japhb__> FROGGS: .steve is clearly a method that gives you the current list of jobs.

[15:19] <FROGGS> or that gives you style, and shouts at you in another moment :o)

[15:20] <TimToady> unfortunately "delegate" is too long, and already means something else

[15:20] * japhb__ starts singing "Sailing the Wide Concurrency" to the tune of "Sailing the Wide Accountancy"

[15:20] <japhb__> (in his head)

[15:20] <FROGGS> *g*

[15:21] <japhb__> lazyperl {}

[15:21] <lizmat> TimToady: re "	 but todo has strong overtones that I'm going to do it, not someone else", that's why I propose "go do" aka "godo"

[15:21] <japhb__> lazy {}

[15:22] <TimToady> bikeshed {}

[15:22] <japhb__> blue {}

[15:22] <diakopter> _ {}

[15:22] <japhb__> no, green {}

[15:22] <lizmat> jim {}

[15:22] <FROGGS> besides { }

[15:24] <geekosaur> please {}

[15:25] <raiph> tia {} # green, light

[15:25] <japhb__> jnthn: So, while they continue bikeshedding ... can you explain why BOOTSTRAPATTR is used beyond building Attribute (or maybe scalar_attr)?

[15:26] <FROGGS> casual { } # my last one for today

[15:26] <japhb__> causal {}  # Now what does *that* mean in this context?

[15:27] <FROGGS> O.o

[15:28] <jnthn> japhb__: Not really :)

[15:28] <jnthn> japhb__: Maybe 'cus "that's how things ended up"

[15:29] <jnthn> japhb__: I guess scalar_attr just needs Attribute and Scalar to exist.

[15:29] <jnthn> And we can use it for the rest.

[15:30] <japhb__> OK, that makes sense to me.  I kept looking at the code going "Why are we using BOOTSTRAPATTR way down here?"  And then I wondered if there was some performance reason, or some extremely subtle detail somewhere I was missing.

[15:31] <jnthn> japhb__: Well, the other reason is that it doesn't not vivify a Scalar in the attribute

[15:31] <jnthn> Which can be important.

[15:31] <jnthn> But we can find a way to do that and use Attribute

[15:31] <japhb__> jnthn: Well, but that's true of a regular Attribute, right?

[15:33] <japhb__> I mean, I thought scalar_attr() was just a wrapper to weld Scalar viv to an Attribute, so if you just use Attribute by itself ...

[15:33] <jnthn> Right.

[15:33] <jnthn> So we can almost certainly reduce BOOTSTRAPATTR usage lots ;)

[15:33] <japhb__> \o/

[15:33] <jnthn> Just copy paste...

[15:35] *** spider-mario left
[15:37] <japhb__> lizmat: line 824 of https://github.com/perl6/specs/commit/73b739897e#diff-7ac286f4ce824e9b90b312e6b8a300e2R824 looks like you mixed languages.  :-)

[15:38] <lizmat> hehe

[15:38] <jnthn> japhb__: Good you pointyd that out... 

[15:39] <japhb__> >.<

[15:39] <dalek> specs: 327e599 | (Elizabeth Mattijsen)++ | S11-modules.pod:

[15:39] <dalek> specs: Mixed languages: bad girl!  spotted by japhb__++

[15:39] <dalek> specs: 

[15:39] <dalek> specs: Finally someone looks at this  :-)

[15:39] <dalek> specs: review: https://github.com/perl6/specs/commit/327e599866

[15:40] <japhb__> jnthn: That one hurt when I felt the point of your linguistic arrow ...

[15:44] * japhb__ wonders if everything currently in BOOTSTRAP.nqp still needs to be there

[15:45] *** ajr joined
[15:46] *** ajr is now known as Guest16834

[15:46] *** Guest16834 is now known as ajr_

[15:49] *** dansamo2 joined
[15:51] *** xenoterracide left
[15:54] *** raiph left
[15:54] <arnsholt> CArray tests: 3/26 \o/

[15:55] *** raiph joined
[15:57] *** denis_boyun_ joined
[15:57] <FROGGS> arnsholt++ # \o/

[16:02] *** woolfy left
[16:02] <lizmat> about to finish up the the APW Hackathon

[16:03] *** kaare__ joined
[16:03] <dalek> specs: 0b11765 | jonathan++ | S17-concurrency-jnthn.pod:

[16:03] <dalek> specs: Add a heretical S17, written from scratch.

[16:03] <dalek> specs: 

[16:03] <dalek> specs: This describes the current state of concurrency as found in Rakudo JVM

[16:03] <dalek> specs: as well as some other planned things. lizmat++ for review and much

[16:03] <dalek> specs: feedback. This is for discussion, and so we can start collectively

[16:03] <dalek> specs: working on better naming, API design, etc. where needed.

[16:03] <dalek> specs: review: https://github.com/perl6/specs/commit/0b11765d37

[16:03] <jnthn> TimToady: Docs!!! :)

[16:04] <lizmat> jnthn++

[16:04] <lizmat> offline&

[16:04] <jnthn> airport &

[16:04] *** lizmat left
[16:05] *** kaare_ left
[16:10] *** virtualsue joined
[16:11] <moritz> jnthn++

[16:12] *** tobyink left
[16:16] <moritz> whie PromiseStatus instead of Promise::Status?

[16:18] <moritz> also, IMHO async should be statement prefix, ie optionally taking a single statement

[16:18] <moritz> my $promise = async $object.meth();

[16:22] <dalek> perl6-roast-data: c1e65a6 | coke++ | / (5 files):

[16:22] <dalek> perl6-roast-data: today (automated commit)

[16:22] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c1e65a66bd

[16:25] <moritz> also I wonder if .subscribe should take named arguments for last/fail

[16:25] *** Rotwang left
[16:26] <FROGGS> pssst, just spec it while he is away

[16:31] *** tobyink joined
[16:34] <dalek> nqp: f42871d | (Tobias Leich)++ | src/vm/parrot/ops/nqp.ops:

[16:34] <dalek> nqp: let nqp::spawn don't use a shell to execute programs

[16:34] <dalek> nqp: 

[16:34] <dalek> nqp: This gives us the change to pass the argument array directly

[16:34] <dalek> nqp: to execvp on linux, saves stringifying it and avoids messing

[16:34] <dalek> nqp: with automatic quoting.

[16:34] <dalek> nqp: CreateProcess on windows however only takes a string.

[16:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f42871dfb8

[16:36] <dalek> rakudo/nom: 215ba6a | (Tobias Leich)++ | tools/build/NQP_REVISION:

[16:36] <dalek> rakudo/nom: bump nqp revision

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/215ba6ab0a

[16:38] *** Rotwang joined
[16:39] <FROGGS> btw, run('"cmd" /c dir') recolves cmd.exe correctly, while run('cmd /c dir') tries to resolv a dir.exe in the folder 'cmd /c' or so

[16:39] <Mouq> o/

[16:39] <Mouq> jnthn++ FROGGS++

[16:39] <FROGGS> hi Mouq 

[16:44] <timotimo> "flat =item grep =item map =item uniq =item squish"

[16:44] <timotimo> :(

[16:46] *** dansamo2 left
[16:46] <moritz> timotimo: I'm going to push some whitespace fixes soon

[16:46] <timotimo> cool

[16:50] <timotimo> i wonder: can optimisations like "i know this part of the regex is exactly of length 3, there's a constant after it, i can look for the constant and do an offset 3 backwards" implementable only on the QAST of the regex or does that kind of thing have to go into each backend's regex compiler?

[16:51] <dalek> specs: 7b0188b | moritz++ | S17-concurrency-jnthn.pod:

[16:51] <dalek> specs: [new 17] whitespace fixes

[16:51] <dalek> specs: 

[16:51] <dalek> specs: and close a dangling quote

[16:51] <dalek> specs: review: https://github.com/perl6/specs/commit/7b0188b633

[16:53] *** virtualsue left
[16:54] <moritz> timotimo: sounds like the detection of those properties could go into a module that works on QAST

[16:54] <moritz> timotimo: and sometimes special scan statements, early fails etc. could be inserted

[16:55] <moritz> but some usages certainly need backend support

[16:55] <timotimo> mhm

[16:55] <moritz> speaking of which: the scan using index() still isn't implemented in the JVM backend

[16:55] <timotimo> i'm not sure if that specific optimisation would help rakudo parse the setting faster

[16:55] <moritz> it doesn't

[16:55] *** denysonique_ joined
[16:55] <timotimo> that's what i feared

[16:56] *** SamuraiJack joined
[16:56] <timotimo> it seems like a good idea to do mostly things that help in the setting at this stage of rakudo

[16:56] <timotimo> because obviously if the developer turn-around time is halved, we'll have twice as many commits!

[17:00] *** denis_boyun__ joined
[17:01] *** denis_boyun_ left
[17:10] *** denysonique left
[17:13] *** denis_boyun__ left
[17:14] *** dmol joined
[17:20] *** johnny5_ left
[17:21] *** johnny5_ joined
[17:25] *** pmurias left
[17:25] *** tobyink left
[17:26] *** mtk left
[17:30] *** mtk joined
[17:32] <arnsholt> Is tc.native_type set before something like a bind_pos_native, or should I just assume the right one is set?

[17:33] <arnsholt> jnthn: That last one was supposed to be pinged at you

[17:33] *** samebchase joined
[17:36] *** Mouq left
[17:38] *** ssutch joined
[17:47] *** Mouq joined
[17:59] *** virtualsue joined
[18:01] <masak> jnthn++ # S17 herecy

[18:01] <timotimo> "heresy", no?

[18:06] <FROGGS> timotimo: that is so awesome about MoarVM... you can fix something in moar, recompile only that and install (<3s), then type `make` again in rakudo's source dir

[18:06] <FROGGS> that is a round-trip of a few seconds

[18:07] <diakopter> :D

[18:07] <FROGGS> which would be minutes (about 3) for parrot or jvm backend, because you usually recompile nqp

[18:08] <moritz> I'm pretty sure that if you fix something in the JVM, you don't have to rebuild NQP either

[18:09] <FROGGS> hehe, yeah, that might be true :o)

[18:10] <masak> timotimo: oh, ouch! yes, "heresy". I blame lack of dinner.

[18:10] <FROGGS> IIRC rebuilding nqp on jvm takes about 3min, on optimized moar only 1.2minutes

[18:10] <moritz> (though I'm pretty sure that build times for the JVM are higher than for MoarVM)

[18:15] <timotimo> hehe

[18:16] <timotimo> got any LHF for me? :\

[18:17] <timotimo> i feel like doing something today, but i don't know what

[18:17] <FROGGS> hmmm, you could skim through RT

[18:17] <timotimo> h

[18:18] <timotimo> i still don't know how to tell rt to never show me tickets from the perl5 queue

[18:18] <FROGGS> just click on the perl6 queue

[18:18] <FROGGS> https://rt.perl.org/Search/Results.html?Query=Queue%20%3D%20%27perl6%27%20AND%20(Status%20%3D%20%27new%27%20OR%20Status%20%3D%20%27open%27%20OR%20Status%20%3D%20%27stalled%27)

[18:18] <timotimo> r: our Int sub foo { fail('a') }; say foo() ~~ Failure

[18:18] <camelia> rakudo-jvm 882e33: OUTPUT«a␤  in block  at gen/jvm/CORE.setting:889␤  in method bless at gen/jvm/CORE.setting:805␤  in block  at /tmp/YRxSn91LD6:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292␤  in any command_eval a…»

[18:18] <camelia> ..rakudo-parrot 215ba6: OUTPUT«a␤  in method sink at gen/parrot/CORE.setting:11951␤  in method BUILDALL at gen/parrot/CORE.setting:892␤  in method bless at gen/parrot/CORE.setting:812␤  in method new at gen/parrot/CORE.setting:797␤  in method new at gen/parrot/CORE.setting:7…»

[18:19] <timotimo> maybe i can figure this out?

[18:19] <FROGGS> good luck :o)

[18:19] <FROGGS> should be at least interesting

[18:20] <timotimo> well, it's "just" that it's trying to sink something and causing the failure to be thrown

[18:20] <japhb__> FROGGS: re: https://github.com/perl6/nqp/commit/f42871dfb8#diff-3ca16c389358a0c5bf23896d29a6a1eeR3743 , can you narrow the #ifdef's at all?  e.g. in nqp_shell(), it looks like the two sides of the #ifdef can be narrowed to just 2-3 lines each.  Or am I missing something?

[18:21] <FROGGS> japhb__: no, the IMCC parser doesn't like it in any other way :(

[18:21] <japhb__> Oy vey.

[18:21] <FROGGS> well, I can try again...

[18:21] * japhb__ shakes his fist at the IMCC parser then.

[18:24] <FROGGS> humm, it seems to compile O.o

[18:29] <dalek> nqp: 044221b | (Tobias Leich)++ | src/vm/parrot/ops/nqp.ops:

[18:29] <dalek> nqp: #ifdef cleanup, japhb++

[18:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/044221bcf2

[18:29] <lue> hello world o/

[18:29] <FROGGS> that is way better :o)

[18:29] <FROGGS> hi lue 

[18:32] *** sunnavy left
[18:36] *** sunnavy joined
[18:36] *** SamuraiJack left
[18:36] <lue> anyone one here know why I get "Could not find sub &postfix:<>" after attempting Exercise 7.4 (jnthn's slides)? Do I need to do 7.5? Did I miss something in the Rubyish version?

[18:37] *** risou is now known as risou_awy

[18:37] *** dansamo2 joined
[18:38] *** risou_awy is now known as risou

[18:39] *** Timbus left
[18:41] *** Timbus joined
[18:42] *** sivoais joined
[18:43] *** tobyink joined
[18:43] <timotimo> i'm not sure why it sinks :\

[18:44] <timotimo> it blesses *some* object, then dies sinking something

[18:44] *** darutoko left
[18:45] <timotimo> but the most interesting line points into a block that'd die "invalid buildallplan"

[18:45] <timotimo> so that can't be it ...

[18:45] *** spider-mario joined
[18:45] *** rindolf left
[18:46] *** rindolf joined
[18:50] *** Mouq left
[18:50] <timotimo> i suppose sink works in mysterious ways?

[18:51] <timotimo> perhaps the return from the BUILDALL sinks the failure object that it just created and fails? but then you wouldn't be able to create any failures ever

[18:51] <timotimo> r: my $f = fail("why?");

[18:51] <camelia> rakudo-jvm 882e33: OUTPUT«Unhandled exception: why?␤  in throw (gen/jvm/CORE.setting)␤  in sink (gen/jvm/CORE.setting)␤  in MAIN (gen/jvm/main.nqp:47)␤  in  (gen/jvm/main.nqp:41)␤  in  (gen/jvm/main.nqp)␤␤»

[18:51] <camelia> ..rakudo-parrot 215ba6: OUTPUT«why?␤current instr.: 'throw' pc 403494 (src/gen/p-CORE.setting.pir:169509) (gen/parrot/CORE.setting:10561)␤called from Sub 'sink' pc 439547 (src/gen/p-CORE.setting.pir:182733) (gen/parrot/CORE.setting:11951)␤called from Sub 'MAIN' pc 399 (src/gen/p…»

[18:51] *** Mouq joined
[18:52] * timotimo realised he knows nothing about how sink works

[18:52] <timotimo> ah, right, there's sink calls added everywhere during compilation

[18:54] *** risou is now known as risou_awy

[18:57] *** zakharyas joined
[18:57] *** ajr_ left
[19:01] *** rindolf left
[19:03] *** raiph left
[19:04] *** raiph joined
[19:05] <moritz> well, every statement in sink context, hopefully

[19:07] <timotimo> er, yes

[19:07] <timotimo> std: my $foo="+";&infix:($foo)(3,4).say

[19:07] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'infix:($foo)' used at line 1␤Check failed␤FAILED 00:01 133m␤»

[19:08] <timotimo> this is supposed to work, right?

[19:10] <Mouq> I think it's usually more like

[19:11] <Mouq> std: my $foo="+";&infix:[$foo](3,4).say

[19:11] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'infix:[$foo]' used at line 1␤Check failed␤FAILED 00:01 133m␤»

[19:11] <Mouq> But I'm not sure

[19:11] <Mouq> std: &infix:['+'](3,4).say

[19:11] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'infix:['+']' used at line 1␤Check failed␤FAILED 00:01 131m␤»

[19:11] <Mouq> r: &infix:['+'](3,4).say

[19:12] <camelia> rakudo-parrot 215ba6, rakudo-jvm 882e33: OUTPUT«7␤»

[19:12] <moritz> p: my $op = '+'; say &::("infix:$op")(3, 4)

[19:12] <camelia> rakudo-parrot 215ba6: OUTPUT«No such symbol '&::infix:+'␤  in method <anon> at gen/parrot/CORE.setting:11948␤  in any  at gen/parrot/Metamodel.nqp:2691␤  in any find_method_fallback at gen/parrot/Metamodel.nqp:2679␤  in any find_method at gen/parrot/Metamodel.nqp:946␤  in …»

[19:13] <moritz> p: my $op = '+'; say ::("&infix:$op")(3, 4)

[19:13] <camelia> rakudo-parrot 215ba6: OUTPUT«No such symbol '&infix:+'␤  in method <anon> at gen/parrot/CORE.setting:11948␤  in any  at gen/parrot/Metamodel.nqp:2691␤  in any find_method_fallback at gen/parrot/Metamodel.nqp:2679␤  in any find_method at gen/parrot/Metamodel.nqp:946␤  in an…»

[19:13] <Mouq>  p: my $op = '+'; say &::("infix:<$op>")(3, 4)

[19:13] <camelia> rakudo-parrot 215ba6: OUTPUT«7␤»

[19:13] <moritz> Mouq++ # that would have been my next attempt

[19:13] *** grondilu joined
[19:13] <grondilu> rn: say Blob.new

[19:13] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[19:13] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Buf:0x<>␤»

[19:13] <camelia> ..niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Blob' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit…»

[19:16] *** virtualsue left
[19:22] *** ajr joined
[19:22] *** ajr is now known as Guest38100

[19:22] *** Guest38100 is now known as ajr_

[19:25] <jaffa4> Hi all I am trying to traverse a parse tree made npq Perl6 grammar

[19:28] <Mouq> jaffa4: can you be more specific?

[19:33] <jaffa4> thanks, something came up , I may be back

[19:40] <jaffa4> Moug: here?

[19:44] <grondilu> Do you guys know about OpenCog?  I've been reading about it lately, and I found a few concepts are related to Perl6 development, imho.  Here is for instance a blog article about hypergraphs and their relation to other stuff such as category theory (you guys love category theory, don't you?)  http://blog.opencog.org/2013/03/24/why-hypergraphs/ 

[19:45] * geekosaur suspects spelling their nick correctly would help

[19:47] <jaffa4> how to check if a method or property exists?

[19:47] <moritz> jaffa4: with can

[19:48] <jaffa4> an example?

[19:48] <moritz> r: if Int.^can('sqrt') { say "yes' }

[19:49] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[19:49] <camelia> ..rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZKsLgBr3g2␤Unable to parse expression in double quotes; couldn't find final '"' ␤at /tmp/ZKsLgBr3g2:1␤------> [32mif Int.^can('sqrt') { say "yes' }[33m⏏[31m<EOL>[0m␤    expecting any…»

[19:49] <moritz> p: if Int.^can('sqrt') { say "yes" }

[19:49] <camelia> rakudo-parrot 215ba6: OUTPUT«yes␤»

[19:49] <moritz> p: if Int.can('sqrt') { say "yes" }

[19:49] <camelia> rakudo-parrot 215ba6: OUTPUT«yes␤»

[19:50] *** REPLeffect left
[19:50] <jaffa4> What if it is from nqp?

[19:51] <jaffa4> No such method 'dispatch:<.^>' for invocant of type 'NQPMatch'

[19:51] <Mouq> Class.HOW.can(Class, 'method')

[19:52] <Mouq> Hypothetically…

[19:52] *** logie joined
[19:54] <Mouq> nqp: grammar A {}; say('Yup') if A.HOW.can(A,'parse')

[19:54] <Mouq> nqp: grammar A {}; say('Nope') if !A.HOW.can(A,'eat')

[19:54] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«Yup␤»

[19:54] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«Nope␤»

[19:55] <FROGGS> nqp: grammar A {}; say('Nope') if !nqp::can(A, 'eat')

[19:55] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«Nope␤»

[19:55] <FROGGS> nqp: grammar A {}; say('Yup') if nqp::can(A, 'parse')

[19:55] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«Yup␤»

[19:56] <jaffa4> I have a nqp object , I would like to know its type in Perl 6

[19:57] <moritz> $obj.HOW.name($obj)

[19:57] *** Khisanth joined
[19:59] <jaffa4> indeed

[20:00] <dalek> specs: b608ca3 | softmoth++ | S17-concurrency-jnthn.pod:

[20:00] <dalek> specs: Use Thread.start() consistently (vs. Thread.run())

[20:00] <dalek> specs: 

[20:00] <dalek> specs: Most examples use Thread.start(), but the early description uses Thread.run(). These should be consistent; since the method on a thread object is $thread.start(), it seems one less thing to remember to call the class method .start() as well.

[20:00] <dalek> specs: review: https://github.com/perl6/specs/commit/b608ca3f9d

[20:01] *** grondilu left
[20:05] *** REPLeffect joined
[20:07] <masak> data point: http://docs.python.org/2/library/threading.html has .start mean "start the thread's activity", while .run is a callback, meant to be overridden by the thread creator and contain the "thread code" to be run.

[20:15] *** woolfy joined
[20:17] *** REPLeffect left
[20:18] *** REPLeffect joined
[20:18] *** jnap joined
[20:22] * lue just had a vision of time-traveling thread( control)s. It was nonsensical.

[20:23] *** jnap left
[20:24] <masak> jnthn, lizmat, others: I like the .schedule/.schedule_in/.schedule_every troika. reminds me of Rx, and DOM's setTimer/setInterval.

[20:24] <masak> however, I wonder if those shouldn't be dashes: .schedule-in/.schedule-every

[20:25] <masak> the logic being that they are public and user-visible, not (socially) private and low-level.

[20:25] <masak> s/logic/rationale/

[20:25] *** virtualsue joined
[20:25] <moritz> +1

[20:25] <masak> ok, changing.

[20:26] <lue> masak: don't you mean "private and low_level" ? :P

[20:26] <masak> lue: I almost wrote that, yes :)

[20:26] <masak> also, a big +1 from me on making schedulers be the unifying abstraction for all event/thread/async stuffs.

[20:28] <lue> +1 as well. /me doesn't know too much about threading, though :)

[20:28] <masak> also, I vote to nuke S17 *now*, and squarely place S17-jnthn-heresy atop its smoldering ruins.

[20:28] <moritz> masak: +2 :-)

[20:29] <moritz> the old stuff is... LTU (less than useless)

[20:29] <lue> masak: +*

[20:30] <masak> ok, I'll do it.

[20:31] <lue> I'd like to hear from the guy who defends current S17, actually :)

[20:31] *** REPLeffect left
[20:32] <dalek> specs: b5099cb | masak++ | S17-concurrency-jnthn.pod:

[20:32] <dalek> specs: [S17-jnthn] dashes, sir.

[20:32] <dalek> specs: 

[20:32] <dalek> specs: Dashes look down on underscores, and thumb their noses at them.

[20:32] <dalek> specs: 

[20:32] <dalek> specs: Leaving .handle_uncaught for now, as that one does seem low-level.

[20:32] <dalek> specs: review: https://github.com/perl6/specs/commit/b5099cbfc6

[20:32] <dalek> specs: caa2b0a | masak++ | S17-concurrency.pod:

[20:32] <dalek> specs: [S17-old] *boom*

[20:32] <dalek> specs: review: https://github.com/perl6/specs/commit/caa2b0a2af

[20:32] <dalek> specs: 091aa78 | masak++ | S17-concurrency (2 files):

[20:32] <dalek> specs: [S17] jnthn's heresy is the new law

[20:32] <dalek> specs: review: https://github.com/perl6/specs/commit/091aa7872b

[20:32] <moritz> masak++

[20:33] <masak> jnthn: handle_uncaught vs uncaught_handler -- did you really intend to spec both, or is one of them a typo for the other?

[20:34] <nwc10> masak: I assume he's on a $dhh plane, or making a 50 minute connection in Tegel

[20:34] <dalek> specs: 644f6cb | masak++ | S17-concurrency.pod:

[20:34] <dalek> specs: [S17] oops, forgot a dash

[20:34] <dalek> specs: 

[20:34] <dalek> specs: Let me just dash back and fix that underscore.

[20:34] <dalek> specs: review: https://github.com/perl6/specs/commit/644f6cb4c2

[20:34] *** raiph left
[20:34] <masak> nwc10: oh, I was counting on him reading backlog. :)

[20:34] <masak> good to know, though.

[20:34] <nwc10> he probably will

[20:34] <lue> If only we had cyberman^W yoleaux back...

[20:34] <nwc10> but I think he arrives quite late tonight, so not sure when

[20:35] *** dmol left
[20:36] *** zakharyas left
[20:38] *** lizmat joined
[20:38] *** risou_awy is now known as risou

[20:38] *** REPLeffect joined
[20:42] *** REPLeffect left
[20:43] *** logie left
[20:44] *** REPLeffect joined
[20:45] <moritz> off-topic UNIX file system question: how many files would you put into a directory, at most, before you split it up into multiple directories?

[20:45] <lizmat> masak: I appreciate making jnthn S17 law, but the old S17 contains several things not yet covered by S17, such as signals, atomic / critical code blocks, STM

[20:45] <lizmat> moritz: a few thousand

[20:45] <moritz> lizmat: thanks

[20:45] <lizmat> e.g. when creating a log file for every second, put all logs of 1 hour in 1 directory (aka 3600 files)

[20:46] <lue> moritz: when I get tired of scrolling through ls (*not* ll) output :)

[20:47] <lue> (s/scrolling through/finding a file in the/ rather)

[20:48] *** REPLeffect left
[20:49] *** ajr_ left
[20:52] *** ajr joined
[20:53] *** ajr is now known as Guest33453

[20:53] *** Guest33453 is now known as ajr_

[20:54] <masak> lizmat: I know atomic and (maybe) STM have implementations in Pugs. the rest of the old S17 is pure pie-in-the-sky. like moritz said, LTU.

[20:55] <masak> lizmat: if, in the unlikely event, we need to specifically refer to details in the old S17, it's easy to find both through Git-on-the-CLI and Github.

[20:57] *** risou is now known as risou_awy

[21:03] *** REPLeffect joined
[21:04] * lizmat had no idea that S17 was so hated by masak, moritz c.s. to have it nuked at the first possible moment

[21:05] <masak> not so much hate as "it's still there if you need it, in the history where it belongs"

[21:05] <lizmat> as basically the only author of S17 still around here

[21:06] <lizmat> I'd rather have seen it stripped of all things we've covered now

[21:06] <lizmat> and the rest as a memo to look at later

[21:07] * lue is reminded of how masak similarly(?) nuked S32::Temporal

[21:07] <lizmat> fwiw, it feels un #perl6 like to me, to just have it nuked like that

[21:07] <lizmat> but I guess I will have to get used to that

[21:07] <masak> lizmat: what lue said.

[21:07] <masak> lizmat: we've done this before, and it came out all right.

[21:07] *** REPLeffect left
[21:07] <masak> lizmat: I disagree about it being un-#perl6.

[21:08] <lizmat> well, then we agree we disagree  :-)

[21:08] <masak> no, two rational agents can't agree to disagree :)

[21:09] <lizmat> who says I'm rational regarding this ?

[21:09] <masak> lizmat: I feel my reasons for nuking it still hold: I'd rather see a reality-based S17 in the official place than a pie-in-the-sky-based S17.

[21:09] <lue> .oO(If there wasn't already a replacement S17 (and the nuke would leave behind "S17 is currently under construction"), I'd've objected, despite old S17's not-aged-well-ness.)

[21:09] <masak> I didn't nuke the falsy S17 out of *history*, only out of the *present*.

[21:10] *** raiph joined
[21:11] <dalek> specs: 7fb7173 | masak++ | S17-concurrency-OLD.pod:

[21:11] <dalek> specs: [S17-OLD] resurrect

[21:11] <dalek> specs: 

[21:11] <dalek> specs: To make lizmat++ feel better. :)

[21:11] <dalek> specs: review: https://github.com/perl6/specs/commit/7fb7173d93

[21:11] *** lizmat left
[21:11] *** lizmat joined
[21:11] *** lizmat left
[21:11] *** lizmat joined
[21:12] <lizmat> even if you did do it out of the "present", it is hidden from all but the most ardent archivist now

[21:12] <lue> I will say we were probably a bit too abrupt in the vote for replacement. [ "Wanna replace S17?" parallel("YES", "YES", "YES") ]

[21:12] <masak> lizmat: see that last commit.

[21:12] <lizmat> and so we run the risk of making the same mistakes

[21:12] <masak> lizmat: you can stop arguing now ;)

[21:12] <moritz> the old mistake was waterfall methodology

[21:12] <masak> lizmat: I painted the bikeshed your favorite color.

[21:13] <masak> but seriously, I would advocate removing S17-OLD.pod at the earliest opportunity.

[21:13] *** REPLeffect joined
[21:14] <lizmat> first I'll strip out all of the things covered by the new S17

[21:14] <lue> Maybe we could put a link to *old* S17 on the synopsis index... if the index ever updated anymore.

[21:14] <masak> lue++ just provided another reason jnthn's version should be the official one.

[21:15] <lue> .oO(perlcabal.org/syn and feather.perl6.nl/syn *still* don't reflect my months-old "add a link to S99" change :/)

[21:16] <jaffa4> how to embed a variable in a string as in Perl 5: "${i}th"

[21:17] <moritz> "{$i}th"

[21:18] <masak> lue: clearly there is a script somewhere that needs to be run.

[21:19] <lue> masak: yep :) I just don't where it is (supposed to be), why it's not running anymore, and if I could start it back up again (likely no)

[21:20] <moritz> lue: seems that syn/index.html is still stuck in SVN land :(

[21:20] <lue> O.o

[21:20] <moritz> no, actually not

[21:21] <moritz> ... updated.

[21:22] <lue> \o/ moritz++

[21:22] <moritz> seems that the mu copy had some local modifications, which caused merge commits on 'git pull'

[21:22] <masak> oops

[21:22] * moritz would be happy if he weren't the only one taking care of such things on feather

[21:22] <dalek> specs: e3bc30c | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[21:22] <dalek> specs: Mangle the introduction into a "real" S17 intro

[21:22] <dalek> specs: review: https://github.com/perl6/specs/commit/e3bc30c8b2

[21:23] <masak> lizmat++

[21:26] <dalek> specs: 05b6aab | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[21:26] <dalek> specs: Clarify the $ex parameter on subscribe

[21:26] <dalek> specs: review: https://github.com/perl6/specs/commit/05b6aabca2

[21:27] *** kaare__ left
[21:30] *** denisboyun joined
[21:30] *** dansamo2 left
[21:32] <dalek> specs: efec538 | softmoth++ | S17-concurrency.pod:

[21:32] <dalek> specs: Fix minor typos and grammar

[21:32] <dalek> specs: review: https://github.com/perl6/specs/commit/efec538c78

[21:33] *** benabik left
[21:34] <jaffa4> for nqpmatch, should not there be a both list and hash property and should not not they be the same?

[21:34] <jaffa4> I mean if hash is not empty, then list is not empty

[21:35] <timotimo> you mean every entry should be duplicated?

[21:35] <moritz> it might be that NQP stores it all in a hash

[21:35] <jaffa4> I guess

[21:35] <moritz> and simply maps $/[0] to $/<0> internally

[21:35] <moritz> you'd have to look at the sources to find out

[21:36] <moritz> NQP isn't quite Perl 6, you know? :-)

[21:37] <jaffa4> because I managed to walk through the parse tree

[21:37] <jaffa4> but only the hash line returns something.

[21:39] <jaffa4> and some hash keys return the same underlying tree

[21:39] <eternaleye> lizmat: In the new S17, the "Grammar wise" bit in subscribables doesn't seem to match the text above it

[21:40] <lizmat> eternaleye: will look at that

[21:41] <eternaleye> lizmat: I parse the text above it as equivalent to either 'next [ last [ fail ]? ]?' or 'next [ [ last ]? fail ]?', but the last doesn't make sense with how optional arguments work.

[21:41] *** woolfy left
[21:42] <jaffa4> eg.level:0 use of uninitialized value of type Any in string context  in sub warn at src\gen\CORE.setting:663  entering by key: NQPMatch bool:1 Show would you compare if two npq object are the same?

[21:42] <eternaleye> lizmat: What'

[21:42] <eternaleye> gha

[21:42] <jaffa4> ow would you compare if two npq object are the same?

[21:43] <lizmat> =:=

[21:43] <eternaleye> lizmat: The grammar snip there instead seems to say there are zero-or-more next callables, and at-most-one-of last and fail may be specified

[21:43] <arnsholt> Same object is =:=, eq and == for string/numeric equality

[21:43] <lizmat> not sure that works in nqp thourgh

[21:44] <arnsholt> =:= is in the NQP grammar. I just checked =)

[21:44] *** virtualsue left
[21:44] <masak> nqp: say([] =:= [])

[21:44] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«0␤»

[21:44] <masak> \o/

[21:44] <masak> nqp: say(42 =:= 42)

[21:44] <camelia> nqp-moarvm, nqp-jvm, nqp-parrot: OUTPUT«0␤»

[21:44] <masak> #perl6 /o\

[21:44] <jaffa4> how would you comprare if two npq objects are the same in Perl 6?

[21:45] <masak> jaffa4: =:=

[21:45] <moritz> === I'd hope

[21:45] <masak> um, yeah.

[21:45] <masak> === does not work in nqp, though.

[21:45] <masak> I guess object equality is not necessary to implement Rakudo ;)

[21:46] <moritz> =:= is container equality, and its use in NQP is really a cheat/mistake/screwup

[21:46] <masak> jaffa4: define "the same" here.

[21:46] <jaffa4> same npq object

[21:46] <masak> jaffa4: is what you want really deep equality, not object identity?

[21:46] <jaffa4> same pointer

[21:46] <jaffa4> object identity

[21:46] <masak> ok.

[21:46] <masak> I don't know how to do that in NQP.

[21:47] <jaffa4> in Perl 6, I have nqp objects

[21:47] <masak> from an OO purist's perspective, you shouldn't really be asking that question, though :)

[21:47] <timotimo> .o( he was asking too many wrong questions ... )

[21:47] <masak> as in, who cares if it's the same instance? that's an implementation detail at best.

[21:47] <moritz> jaffa4: does === work?

[21:48] <masak> moritz: no, not in NQP.

[21:48] <moritz> masak: the question is about Perl 6, with objects leaked out from NQP

[21:48] <masak> oh!

[21:48] <jaffa4> The truth is put them into a hash... I would like to check if the object has been storedi in the hash. Should that work correctly?

[21:49] <masak> moritz: is there a way to test that on camelia?

[21:49] <moritz> masak: yes, but it's not trivial

[21:49] <moritz> p: my $x := nqp::list(); say $x === $x;

[21:49] <camelia> rakudo-parrot 215ba6: OUTPUT«False␤»

[21:50] <moritz> jaffa4: you could always just compare .from

[21:50] <moritz> we usually do not capture zero-width matches

[21:50] <jaffa4> from can be the same

[21:51] <moritz> or .from/.to combination

[21:52] <masak> moritz: I would almost consider the above a rakudobug.

[21:52] <moritz> masak: almost, yes :-)

[21:52] <masak> of the infix:<===> operator.

[21:53] *** avuserow joined
[21:53] <dalek> specs: a6275df | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[21:53] <dalek> specs: There is no event loop, only subscribables:$*POSIX

[21:53] <dalek> specs: review: https://github.com/perl6/specs/commit/a6275dfa82

[21:53] <jaffa4> almost??????

[21:53] <masak> jaffa4: yes, almost!!!!!!

[21:54] <jaffa4> Why?

[21:54] <masak> jaffa4: it's a "the question is who's to be master" situation.

[21:54] *** ajr_ left
[21:54] <jaffa4> masak: tell me more about this... who is who...

[21:55] <moritz> because it uses internals (nqp::), and thus it cheats

[21:55] <moritz> p: say nqp::null()

[21:55] <camelia> rakudo-parrot 215ba6: OUTPUT«(Mu)␤»

[21:55] <moritz> nqp: nqp::say(nqp::null())

[21:55] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤  in  (/tmp/vX2ecpthN6:1)␤  in  (gen/jvm/stage2/NQPHLL.nqp:1100)␤  in eval (gen/jvm/stage2/NQPHLL.nqp:1086)␤  in evalfiles (gen/jvm/stage2/NQPHLL.nqp:1292)␤  in command_eval (gen/jvm/stage2/NQPHLL.nqp:1196)␤  in command_line…»

[21:55] <camelia> ..nqp-parrot: OUTPUT«Null PMC access in get_string()␤current instr.: '' pc 42 ((file unknown):61133864) (/tmp/cw_xAb4tVJ:1)␤»

[21:55] <camelia> ..nqp-moarvm: OUTPUT«␤»

[21:55] <moritz> this isn't an NQP bug, even though it's a Null PMC access / Null pinter exception

[21:55] <masak> jaffa4: what wins, the fact that infix:<===> semantics should answer True on all X === X, or the fact that nqp:: are internals, and (a) fraught with bootstrapping problems even on a good day, and (b) not very highly prioritized to get perfect in these cases.

[21:57] <jaffa4> ok

[21:58] <jaffa4> what is the idea behidn this: %h1<a>:exist?

[21:59] <lizmat> jaffa4: you mean :exists ?

[21:59] <masak> r: my %h = a => 42; say %h<a> :exists; say %h<b> :exists;

[21:59] <camelia> rakudo-jvm 882e33: OUTPUT«(timeout)»

[21:59] <camelia> ..rakudo-parrot 215ba6: OUTPUT«True␤False␤»

[21:59] <jaffa4> I mean syntactilly what is :?

[21:59] <masak> jaffa4: it's an adverb.

[22:00] <masak> jaffa4: it modifies a preceding operator, in this case .<>

[22:00] <lizmat> it's a short way to write "exists => True"

[22:00] <timotimo> oh man r-j, you gotta step your game up

[22:00] <timotimo> lizmat: so i could write %h<a> exists => True, too?

[22:00] <lizmat> timotimo: jnthn is aware of the r-j problem

[22:00] <lizmat> timotimo: no, because that's not how the syntactic sugar works

[22:01] <timotimo> :)

[22:01] <lizmat> but for someone coming from p5, :foo is really foo => True, and :foo<bar> is really foo => 'bar', and :$foo is really foo => $foo

[22:02] <timotimo> yeah, but %h1<a>:exists isn't really %h1<a> exists => True

[22:02] <timotimo> i thought he was specifically asking for that

[22:02] <Mouq> p: my %h = a => 42; %h.&postcircumfix«< >»('a', exists => True).say

[22:02] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/Gnk2kSbwHN␤Undeclared name:␤    &postcircumfix used at line 1␤␤»

[22:02] <Mouq> p: my %h = a => 42; %h.&postcircumfix:«< >»('a', exists => True).say

[22:02] <avuserow> I've been reading the new S17, and was curious why there is a schedule_with_catch({...}, -> $ex {...}) when you (presumably) could just do schedule({...; CATCH { ... }})

[22:02] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/itEDjMm8PM␤Undeclared name:␤    &postcircumfix:<< >> used at line 1␤␤»

[22:02] <Mouq> Hurm

[22:03] <avuserow> rp: {say "alive"; die "foo"; say "ERR"; CATCH {say "got here";}}

[22:03] <camelia> rakudo-parrot 215ba6: OUTPUT«alive␤got here␤foo␤  in block  at /tmp/ZENS3Sn1j1:1␤  in any  at /tmp/ZENS3Sn1j1:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles at gen/parrot/stage2/NQPHLL.nqp:1339␤ …»

[22:03] <lizmat> p: my %h = a => 42; %h.&postcircumfix:«{ }»('a', exists => True).say

[22:03] <avuserow> rp: {say "alive"; die "foo"; say "ERR"; CATCH {default {say "got here";}}}

[22:03] <camelia> rakudo-parrot 215ba6: OUTPUT«===SORRY!===␤Null PMC access in get_bool()␤»

[22:03] <camelia> rakudo-parrot 215ba6: OUTPUT«alive␤got here␤»

[22:03] <Mouq> lizmat: Oh, duh

[22:04] <Mouq> p: my %h = a => 42; %h.&postcircumfix:<{ }>('a', exists => True).say

[22:04] <camelia> rakudo-parrot 215ba6: OUTPUT«True␤»

[22:04] <Mouq> The guillemets should work though…

[22:05] <lizmat> jaffa4: %h<a>:exists is syntactic sugar for what Mouq++ just showed

[22:06] <timotimo> to be honest, i find that a bit too magical; in a way the adverb seems too far removed from the circumfix to clearly be so directly influencing it

[22:06] <timotimo> traditionally it would look like the :exists would operate on the result of the postcircumfix

[22:07] *** gaussblurinc_ joined
[22:07] <Mouq> traditionally, it would be two terms in a row :p

[22:07] <jaffa4> IS there way to get integer address of an object?

[22:07] <lue> timotimo: I imagine it's the best way to provide other arguments to functions with funny syntax. And I do disagree with you on the too magical front :)

[22:08] <lue> jaffa4: http://perlcabal.org/syn/S02.html#The_ObjAt_Type (no, because 

[22:08] <lue> memory is a funny thing, cross-platform)

[22:09] <lue> r: say 42.WHICH; say 42.WHICH.WHAT;

[22:09] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:09] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Int|42␤(ObjAt)␤»

[22:10] <dalek> specs: e7a8d5a | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[22:10] <dalek> specs: Fix typo

[22:10] <dalek> specs: review: https://github.com/perl6/specs/commit/e7a8d5ab9e

[22:10] <dalek> specs: 74566e1 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[22:10] <dalek> specs: Stress that we're talking about invocations

[22:10] <dalek> specs: review: https://github.com/perl6/specs/commit/74566e19e8

[22:10] <jaffa4> ok, bue all

[22:10] <lizmat> eternaleye: hope that makes it clearer?

[22:10] *** jaffa4 left
[22:10] <Mouq> p: say 4\ .&[+]: 5

[22:10] <camelia> rakudo-parrot 215ba6: OUTPUT«9␤»

[22:11] <lue> p: my Int|Str $a; $a = 42; $a = "dna";

[22:11] *** lizmat left
[22:12] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m␤Type 'Int' is not declared. Did you mean 'int'?␤at /tmp/tzxBj8BQzl:1␤------> [32mmy Int[33m⏏[31m|Str $a; $a = 42; $a = "dna";[0m␤Malformed my␤at /tmp/tzxBj8BQzl:1␤------> [32mmy Int[33m⏏[31m|Str $a; $…»

[22:12] <lue> ...

[22:12] *** lizmat joined
[22:12] *** Rotwang left
[22:12] <lue> I was not expecting that error upon polymorphic types attempt.

[22:12] <Mouq> std: my Int|Str $a; $a = 42; $a = "dna";

[22:12] <camelia> std 8adbc60: OUTPUT«[31m===[0mSORRY![31m===[0m␤Multiple prefix constraints not yet supported at /tmp/mC93PTTzwZ line 1:␤------> [32mmy Int[33m⏏[31m|Str $a; $a = 42; $a = "dna";[0m␤Malformed my at /tmp/mC93PTTzwZ line 1:␤------> [32mmy Int[33m⏏[31m|Str $a; $a =…»

[22:13] <lue> P: my Int|Str $a; $a = 42; $a = "dna"; # just ooc

[22:13] <camelia> pugs: OUTPUT«Segmentation fault␤»

[22:13] <lue> n: my Int|Str $a; $a = 42; $a = "dna"; # just ooc

[22:13] <camelia> niecza v24-98-g473bd20: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed my at /tmp/rZuDdD7NlB line 1:␤------> [32mmy[33m⏏[31m Int|Str $a; $a = 42; $a = "dna"; # just[0m␤␤Parse failed␤␤»

[22:14] <masak> using junctions for ambiguous types like that has fallen out of fashion.

[22:15] <masak> please use subset types.

[22:15] <lue> r: class FooIntStr is Int is Str { }; my FooIntStr $a; $a = 42; $a = 'dna';

[22:15] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:15] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Type check failed in assignment to '$a'; expected 'FooIntStr' but got 'Int'␤  in block  at /tmp/O3hJzF4A03:1␤  in any  at /tmp/O3hJzF4A03:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in a…»

[22:15] * lue notes to self once more: always always always use p:

[22:15] <masak> lue: that trivially fails to typecheck.

[22:15] <eternaleye> lizmat: Ah, yes. That does make it clear.

[22:15] <lue> I could swear that's how RatStr and friends do it...

[22:16] <masak> lue: I meant 'subset IntOrStr of Any where { $_ ~~ Int || $_ ~~ Str }

[22:16] <masak> '

[22:16] <lue> r: class FooIntStr is Int is Str { }; my FooIntStr $a; $a = '42';

[22:16] <masak> lue: yes, but note that a RatStr is a Rat *and* a Str, not a Rat *or* a Str.

[22:17] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:17] <camelia> ..rakudo-parrot 215ba6: OUTPUT«Type check failed in assignment to '$a'; expected 'FooIntStr' but got 'Str'␤  in block  at /tmp/knTS_QnTkO:1␤  in any  at /tmp/knTS_QnTkO:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in a…»

[22:17] <lue> That has *got* to be wrong, though.

[22:17] <masak> lue: please stop and think.

[22:17] *** benabik joined
[22:17] <lue> (what I just did)

[22:17] <masak> instead of trying the same crazy twice.

[22:17] <lue> masak: http://perlcabal.org/syn/S02.html#Allomorphic_value_semantics

[22:17] <masak> r: class FooIntStr is Int is Str { }; say Str ~~ FooIntStr

[22:18] <lue> ( there are the ... in the class braces in that link, but that can't mean anything, right? :) )

[22:18] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:18] <camelia> ..rakudo-parrot 215ba6: OUTPUT«False␤»

[22:18] <masak> lue: there is the problem. you can't store a Str in a FooIntStr container.

[22:18] *** denisboyun left
[22:18] <lue> So does Allomorphic Value Semantics mean to say that the {...} is where P6 takes care of the problem?

[22:19] <lizmat> perl-j is a sick puppy atm: https://gist.github.com/lizmat/7295532

[22:19] <masak> lue: note that the spec you linked never tries to store a Str in a RatStr.

[22:19] <lizmat> jnthn: I hope this helps you

[22:20] <lizmat> the fact that it ran for 17 seconds wallclock, but burned 41+ seconds CPU, seems very suspect to me

[22:20] *** denisboyun joined
[22:20] *** spider-mario left
[22:21] <lue> r: class FooIntStr is Int is Str { }; my FooIntStr $a; $a = FooIntStr('42'); # me suspects the lack of a relevant 'new' breaks this.

[22:22] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:22] <camelia> ..rakudo-parrot 215ba6: OUTPUT«No such method 'FooIntStr' for invocant of type 'Str'␤  in any  at gen/parrot/BOOTSTRAP.nqp:1674␤  in any  at gen/parrot/BOOTSTRAP.nqp:1669␤  in block  at /tmp/4TncmJDov4:1␤  in any  at /tmp/4TncmJDov4:1␤  in any  at gen/parrot/stage2/NQPHLL.nq…»

[22:22] <lue> gah

[22:22] * lizmat wishes #perl6 a good night, long decommute coming up tomorrow

[22:22] <lue> p: class FooIntStr is Int is Str { }; my FooIntStr $a; $a = FooIntStr.new('42')

[22:22] <camelia> rakudo-parrot 215ba6: OUTPUT«Default constructor for 'FooIntStr' only takes named arguments␤  in method new at gen/parrot/CORE.setting:800␤  in method new at gen/parrot/CORE.setting:795␤  in block  at /tmp/j1syDCxYOE:1␤  in any  at /tmp/j1syDCxYOE:1␤  in any  at gen/parrot…»

[22:22] <Mouq> night lizmat 

[22:22] <lue> ♞ lizmat o/

[22:23] <lue> masak: I think my brain been thoroughly de-broken now in this regard :)

[22:23] <masak> 'night, lizmat 

[22:24] <masak> lue: the section in S02 hand-waves a working .new

[22:24] <lue> masak: yes. I noticed that when I notice the braces came with "more to come" ellipses :)

[22:24] <lue> *noticed

[22:25] <Mouq> Ohhhhhh!

[22:25] <Mouq> p: &circumfix:«{"{ }"}»(4,5).say # :D

[22:25] <camelia> rakudo-parrot 215ba6: OUTPUT«===SORRY!===␤Null PMC access in get_bool()␤»

[22:25] <Mouq> :(

[22:25] <Mouq> But, anyway, «» interpolate {}, so duh

[22:26] <lue> p: &circumfix:«\{ \}»(4,5).say # :D

[22:26] <camelia> rakudo-parrot 215ba6: OUTPUT«("4" => 5).hash␤»

[22:26] <lue> Mouq: you interpolated a block containing a string containing an interpolated block :)

[22:26] <Mouq> ._.

[22:26] *** kivutar joined
[22:27] <Mouq> p: &circumfix:«{'{ }'}»(4,5).say # ?

[22:27] <camelia> rakudo-parrot 215ba6: OUTPUT«===SORRY!===␤Null PMC access in get_bool()␤»

[22:27] <lue> p: &circumfix:«'{ }'»(4,5).say

[22:27] <camelia> rakudo-parrot 215ba6: OUTPUT«("4" => 5).hash␤»

[22:27] <Mouq> I think the problem besides my brainos is that {...} isn't the compile-time-value it needs

[22:29] *** avuserow left
[22:30] <masak> I think it's just a case of an empty string.

[22:31] <masak> p: &circumfix:«»(4,5).say

[22:31] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/H5MHAALPeA␤Undeclared name:␤    &circumfix:<> used at line 1␤␤»

[22:31] <lue> r: say «{4 + 2} 4+2»

[22:31] <camelia> rakudo-jvm 882e33: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤  in  (gen/jvm/CORE.setting)␤  in  (gen/jvm/ModuleLoader.nqp:349)␤  in load_setting (gen/jvm/ModuleLoader.nqp:340)␤  in  (src/Perl6/World.nqp:304)␤  in load_setting (src/Perl6/World.nqp:300)␤  in  (src…»

[22:31] <camelia> ..rakudo-parrot 215ba6: OUTPUT«64+2␤»

[22:31] <lue> p: say ‹{4 + 2} 4+2›

[22:31] <masak> p: &circumfix:« »(4,5).say

[22:31] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/cdXXaK171j␤Two terms in a row␤at /tmp/cdXXaK171j:1␤------> [32msay [33m⏏[31m‹{4 + 2} 4+2›[0m␤    expecting any of:␤        argument list␤        prefix or term␤        pref…»

[22:31] <camelia> rakudo-parrot 215ba6: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/WF_OkqNYsE␤Undeclared name:␤    &circumfix:<> used at line 1␤␤»

[22:31] *** tobyink left
[22:32] <lue> clearly, I think ‹› should be the single-quote form of «», and thus make <> the Texas equiv. ‹›/<> «»/<<>>  :)

[22:34] <dalek> nqp: e56b199 | (Tobias Leich)++ | / (2 files):

[22:34] <dalek> nqp: apped nqp::spawn, bumped moar revision

[22:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e56b19936d

[22:35] *** rurban left
[22:35] *** BenGoldberg joined
[22:38] *** FROGGS left
[22:39] *** risou_awy is now known as risou

[22:43] *** gaussblurinc_ left
[22:46] *** raiph left
[22:55] *** risou is now known as risou_awy

[22:56] *** raiph joined
[23:01] *** cognominal__ is now known as cognominal

[23:11] <dalek> roast: 476f04f | lue++ | S02-literals/quoting-unicode.t:

[23:11] <dalek> roast: Add test to ensure 「...」 is shortform for Q[...]

[23:11] <dalek> roast: 

[23:11] <dalek> roast: Currently skipped in rakudo to allow the test file to run.

[23:11] <dalek> roast: review: https://github.com/perl6/roast/commit/476f04ff23

[23:16] *** lizmat left
[23:22] *** dmol joined
[23:26] <masak> 'night, #perl6

[23:27] <lue> ♞ masak o/

[23:28] *** kivutar left
[23:36] *** [particle] joined
[23:38] *** dmol left
[23:46] * Mouq is trying to implement `is parsed`

[23:50] <Mouq> Aaaaaaannnd Null PMC access in get_string()

[23:55] <dalek> perl6-roast-data: 1867c22 | coke++ | / (3 files):

[23:55] <dalek> perl6-roast-data: today (automated commit)

[23:55] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1867c2206d

