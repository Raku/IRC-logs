[00:18] *** benabik joined
[00:22] *** SmokeMac_ left
[00:31] *** raiph left
[00:35] *** benabik left
[00:35] *** xilo_ left
[00:35] *** xilo_ joined
[00:36] *** xilo_ left
[00:36] *** xilo_ joined
[00:42] *** xilo_ left
[00:42] *** xilo_ joined
[00:48] *** benabik joined
[00:49] *** btyler joined
[00:58] *** raiph joined
[00:59] *** abnorman joined
[01:08] *** logie left
[01:08] *** FROGGS[mobile] left
[01:23] *** woosley joined
[01:23] *** woosley left
[01:27] *** woosley joined
[01:29] *** btyler left
[01:30] *** census joined
[01:31] *** fridim_ joined
[01:39] *** raiph left
[01:50] *** dayangkun left
[02:18] *** census left
[02:24] *** SamuraiJack joined
[02:56] *** Kutoo joined
[03:01] *** Kutoo left
[03:08] <dalek> roast: 0e0bc7d | (Solomon Foster)++ | S32-str/capitalize.t:

[03:08] <dalek> roast: Test wordcase with dashes and apostrophes.

[03:08] <dalek> roast: review: https://github.com/perl6/roast/commit/0e0bc7ddc0

[03:18] *** abnorman left
[03:20] *** BenGoldberg left
[03:25] *** Chillance left
[03:26] <sorear> good * #perl6

[03:26] <yoleaux> 3 Jul 2013 18:17Z <raiph> sorear: I'm being harassed about P6. Fwiw I meant strictly lazy (100%) vs mostly lazy (batched).

[03:37] <sorear> .oO( happy sorear-pmichaud-diakopter-japhb-et-al-get-the-day-off day, everyone )

[03:40] <labster> Happy Government Change Day to you too, sorear.  Even Egypt is celebrating this year.

[03:48] *** preflex left
[03:49] *** daniel-s_ joined
[04:35] *** _jaldhar left
[04:48] *** birdwindupbird joined
[05:02] <sorear> not_gerd: FROGGS: some members of the x86 family treat int >> 33 as int >> 1 (only use the low 5 bits), others treat it as >> 33 (set to 0).  I suspect that the former group would treat >> (-1) as >> 31.  In general, C uses the CPU's rules for invalid shifts, because it's low-level like that

[05:03] <sorear> the JVM specs the "& 31" interpretation

[05:06] *** logie joined
[05:09] <sorear> the CLR specifically says that int >> 33 is undefined, and is silent on >> -1.  the C# spec says it's preprocessed with & 31

[05:14] *** not_gerd joined
[05:14] <not_gerd> o/

[05:16] <not_gerd> sorear: correct, on x86 (and in Java), a >> b == a >> (b % 32)

[05:16] <not_gerd> however, Perl6 Int are semantically arbitrary-precision, so that doesn't make much sense

[05:17] <not_gerd> I believe the only choice that makes ense in that case is indeed flip direction on negative bit counts

[05:17] <not_gerd> ^sense

[05:18] <dalek> rakudo/nom: 9ece8b4 | (Brent Laabs)++ | src/core/IO/Spec/Win32.pm:

[05:18] <dalek> rakudo/nom: implement canonpath(:parent) for Win32, rm os-dependent '...' -> '../..'

[05:18] <dalek> rakudo/nom: this removes support for '...' double-parent on Symbian and NetWare,

[05:18] <dalek> rakudo/nom: both of which are no longer being updated by the OS owners.

[05:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ece8b45e4

[05:20] <labster> I assume no one here is plans to run rakudo on outdated smartphones, right?

[05:20] <sorear> that or die

[05:23] <sorear> not_gerd: just checked my copy of the intel software dev manual, the %32 was introduced in the 286

[05:23] <sorear> the 8086 did not do it, and the 80186 apparently never existed

[05:27] <not_gerd> it's also 'funny' that in constant expressions, gcc will flip shift direction on negative 2nd argument, whereas clang will just return garbage

[05:27] <not_gerd> both emit a warning, but neither falls back to CPU semantics

[05:29] *** xilo_ left
[05:30] *** FROGGS[mobile] joined
[05:34] <sorear> garbage as in rand() ?

[05:34] <sorear> presumably not system("nethack")...

[05:34] <sorear> o/ FROGGS[mobile]

[05:36] *** fridim_ left
[05:42] <not_gerd> sorear: I've no idea where it gets these values from

[05:42] <not_gerd> the first invalid shift returns a random value, all further ones -13096272

[05:46] *** FROGGS[mobile]2 joined
[05:48] *** FROGGS[mobile] left
[05:55] <FROGGS[mobile]2> morning

[05:57] *** djanatyn left
[05:57] *** djanatyn joined
[05:58] <not_gerd> FROGGS[mobile]2: good morning

[05:58] * not_gerd pushed his shift stuff last night

[06:02] *** PacoAir joined
[06:02] *** FROGGS[mobile]2 left
[06:08] *** FROGGS joined
[06:08] <FROGGS> not_gerd++

[06:08] *** logie left
[06:11] *** konundra left
[06:11] *** PacoAir left
[06:17] <sorear> two froggsmobiles!

[06:18] <sorear> or are they froggsesmobile, I can't tell

[06:18] <FROGGS> *g*

[06:19] *** dmol joined
[06:21] *** arnsholt left
[06:21] *** arnsholt joined
[06:24] *** daniel-s left
[06:28] *** dmol left
[06:28] *** amoe_ joined
[06:31] *** amoe left
[06:34] *** sqirrel joined
[06:37] *** kaleem joined
[06:39] *** SamuraiJack left
[06:42] *** iSlug joined
[06:43] *** SamuraiJack joined
[06:47] * [Coke] yawns.

[06:47] <sorear> o/ [Coke] 

[06:47] *** not_gerd left
[06:49] *** Vlavv_ left
[06:50] <[Coke]> sorear: \o

[06:53] *** Rix left
[07:01] *** Vlavv_ joined
[07:01] * sorear dives back into java interop

[07:03] <JimmyZ> sorear++

[07:15] *** logie joined
[07:15] <labster> hmm, what should I dive into?

[07:17] <nwc10> panda on the JVM?

[07:19] *** logie left
[07:21] *** Teratogen joined
[07:25] <[Coke]> jvm test aborts

[07:31] *** dmol joined
[07:31] * lizmat tries to drink another cup of tea

[07:32] * sorear imagines lizmat covered in tea, having failed

[07:32] <lizmat> .oO{ if it had been alcohol, it would have been alcohol abuse }

[07:33] <lizmat> now it is merely hot ;-)

[07:34] <labster> sorear has java all over him

[07:40] * labster ended up fixing a self-made parakudo test abort instead :/

[07:42] <dalek> rakudo/nom: 68301a7 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[07:42] <dalek> rakudo/nom: Remove .pop's "is rw" and fix the fallout from unshift's use of that

[07:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68301a78dc

[07:44] <dalek> rakudo/nom: c74287f | (Brent Laabs)++ | src/core/IO/Spec/Win32.pm:

[07:44] <dalek> rakudo/nom: fix thinko in Win32 canonpath

[07:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c74287fcf1

[07:44] <labster> masak: your git pull --rebase strategy seems to work :)

[07:46] <[Coke]>  https://gist.github.com/coke/5879701 is updated.

[07:47] <[Coke]> r: say 24355 / 26105 # intraday jvm standing.

[07:47] <camelia> rakudo 9ece8b: OUTPUT«0.932963␤»

[07:47] <[Coke]> r: say 26105*.95-24355

[07:47] <camelia> rakudo 9ece8b: OUTPUT«444.75␤»

[07:49] *** kivutar joined
[07:54] <lizmat> r: my @a=1; @a.pop; @a.pop; my @b; @b.pop  # [email@hidden.address] does not give an error while on empty array, while first pop on @b bombs?

[07:54] <camelia> rakudo 9ece8b: OUTPUT«Element popped from empty list␤  in method sink at src/gen/CORE.setting:10498␤  in block  at /tmp/brlzVdY1qO:1␤␤»

[07:54] <lizmat> r: my @a=1; @a.pop; @a.pop; say @a; my @b; say @b; @b.pop  # [email@hidden.address] does not give an error while on empty array, while first pop on @b bombs?

[07:54] <camelia> rakudo 9ece8b: OUTPUT«Element popped from empty list␤  in method sink at src/gen/CORE.setting:10498␤  in block  at /tmp/qubpv2xo7A:1␤␤»

[07:54] <lizmat> huh?

[07:56] <lizmat> r: my @a; say defined(@a.pop)  # seems that defined() is stopping pop from empty list from bombing?

[07:56] <camelia> rakudo 9ece8b: OUTPUT«False␤»

[07:57] <[Coke]> r: my @a=1; @a.pop; @a.pop; say @a; my @b; say @b; @b.pop; 1

[07:57] <camelia> rakudo 9ece8b: OUTPUT«Element popped from empty list␤  in method sink at src/gen/CORE.setting:10498␤  in block  at /tmp/l0mINE4XOE:1␤␤»

[07:57] <lizmat> r: my @a; say @a.pop.WHAT

[07:57] <camelia> rakudo 9ece8b: OUTPUT«(Failure)␤»

[07:58] <lizmat> it's an unthrown failure

[07:58] <lizmat> and apparently defined() doesn't throw?

[07:59] <moritz> defined() and truth tests don't throw

[07:59] <moritz> and mark a Failure as .handled

[08:00] <sorear> o/ moritz

[08:01] <sorear> Failure: it even confuses core hackers

[08:01] *** domidumont joined
[08:03] <labster> maybe I should start some sort of Failure Blog to document times when we have problems with Failure.

[08:05] *** daniel-s joined
[08:06] <moritz> my current approach would be to abolish Failure, sink context, and laziness of for-loops

[08:06] <moritz> it would solve so many problems, and with very little downside

[08:08] <JimmyZ> what's about for(1..*) ?

[08:08] <lizmat> r: say (1..*).WHAT 

[08:08] <camelia> rakudo 9ece8b: OUTPUT«(Range)␤»

[08:09] <sorear> moritz: +1

[08:10] <moritz> (and make 'map' and 'for' different things)

[08:10] <JimmyZ> it's time to add github issues?

[08:10] <JimmyZ> I mean github.com/perl6/spec

[08:11] <sorear> (maybe instead of just saying I don't want to go to Abilene I should try turning the figurative car around myself)

[08:11] <moritz> I'm not sure if that's the best place to discuss this

[08:11] <JimmyZ> perl6-lang mail list?

[08:11] <moritz> no, don't ever try to discuss anything important there

[08:11] <JimmyZ> or blog ?

[08:12] <moritz> maybe blog, maybe perl6/spec/issues, maybe here

[08:13] <sorear> if you go to p6l then instead of a day trip we'll be stuck there permanently >_>

[08:14] <JimmyZ> +1 to here

[08:14] <JimmyZ> with a gist

[08:16] <moritz> maybe I'll have time to write up my thoughts soonish

[08:17] * sorear wonders if the parable of the trip to Abilene is considered insulting by Abileners or Texans in general

[08:18] <lizmat> s/Abilene/Hooterville/ ?

[08:19] <lizmat> r: my @a; say not so @a.pop

[08:19] <camelia> rakudo c74287: OUTPUT«True␤»

[08:20] <sorear> lizmat: https://en.wikipedia.org/wiki/Abilene_paradox

[08:22] <masak> aloha, #perl6

[08:22] <sorear> yo, masak

[08:22] <masak> moritz: I kinda like the list results of statement_mod for. not saying it's worth keeping just for that... but we'd need a new way to do list comprehensions.

[08:23] <sorear> niecza treats statement_mod for differently depending on whether it appears at statment level or not

[08:23] <sorear> so far nobody has complained

[08:24] <sorear> and it's not without precedent, circumfix:<{ }> is magical in the same way

[08:24] <lizmat> sorear++ for the reference

[08:25] <masak> ooh

[08:25] <sorear> we could probably do the same thing with all loops

[08:26] <sorear> note that this would allow return (while { ... }) if you want to force listy semantics

[08:26] <sorear> masak: tomorrow is national sorear-gets-the-day-off-to-hack-perl6 day :)

[08:32] <lizmat> fitness&

[08:39] <masak> sorear: \o/

[08:39] *** dakkar joined
[08:44] <masak> oh wow two more HPMoR chapters! \o/

[08:47] <moritz> three, for me :-)

[08:54] *** yoleaux left
[08:59] <dalek> roast: ad806e0 | (Brent Laabs)++ | S32-io/io-spec-win.t:

[08:59] <dalek> roast: add Win32 canonpath parent tests

[08:59] <dalek> roast: review: https://github.com/perl6/roast/commit/ad806e085e

[09:00] <labster> I guess I need to read HPMoR.  For some reason, I'm more attracted to animefic than Potterfic, but everyone seems to like it.

[09:03] *** jlaire left
[09:06] *** berekuk left
[09:08] *** jlaire joined
[09:08] <sorear> labster: if you want to classify it, hpmor is probably more Yudkowsky than Potterfic...

[09:10] * moritz has no experience with potterfix except hpmor

[09:13] *** yoleaux joined
[09:13] *** ChanServ sets mode: +v yoleaux

[09:16] <moritz> *fic

[09:27] *** jnthn_ joined
[09:27] *** itz joined
[09:27] *** clkao_ joined
[09:27] *** integral_ joined
[09:27] *** integral_ left
[09:27] *** integral_ joined
[09:27] *** mst___ joined
[09:27] *** pmichaud_ joined
[09:29] <mathw> I started reading it, but it took too many liberties with the source material for my liking. It wasn't 'what if Harry was raised by...' it was 'what if Harry was raised by... AND all this other stuff was just completely different too'

[09:30] *** crazed- joined
[09:32] *** domidumont left
[09:32] *** iSlug left
[09:32] *** woosley left
[09:32] *** Khisanth left
[09:32] *** salv0 left
[09:32] *** itz_ left
[09:32] *** pmichaud left
[09:32] *** JoaquinFerrero left
[09:32] *** timotimo left
[09:32] *** tokuhirom left
[09:32] *** sjohnson left
[09:32] *** integral left
[09:32] *** crazedpsyc left
[09:32] *** clkao left
[09:32] *** jnthn left
[09:32] *** mst left
[09:32] *** eiro left
[09:32] *** camelia left
[09:32] *** timotimo joined
[09:33] *** crazed- left
[09:33] *** crazedpsyc joined
[09:35] *** tokuhirom_ joined
[09:37] <jnthn_> .nick jnthn

[09:37] <yoleaux> jnthn_: Sorry, this command is admin-only.

[09:37] <jnthn_> oops :)

[09:37] *** jnthn_ is now known as jnthn

[09:38] *** mst___ is now known as mst

[09:39] *** sjohnson joined
[09:39] *** salv0 joined
[09:40] *** woosley joined
[09:41] *** Khisanth joined
[09:41] <sorear> o/ jnthn

[09:41] <jnthn> hi, sorear 

[09:41] <jnthn> How goes?

[09:42] <sorear> jnthn: good!

[09:44] *** kivutar left
[09:44] *** kivutar joined
[09:45] *** camelia joined
[09:46] <jnthn> :)

[09:46] *** ChanServ sets mode: +v camelia

[09:49] <sorear> jnthn: and you?

[09:51] <dalek> nqp: a93b817 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (2 files):

[09:51] <dalek> nqp: Start stubbing in BootJavaInterop

[09:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a93b8171eb

[09:51] <dalek> nqp: 9ffa04d | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/GlobalContext.java:

[09:51] <dalek> nqp: GlobalContext.getCurrentThreadContext

[09:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ffa04d3aa

[09:53] <jnthn> sorear: Well, seems I got plenty of sleep... :)

[09:53] <jnthn> ooh! Java interop stuffs :)

[09:55] <sorear> jnthn: yep.  planning to do a lot with that tomorrow

[09:55] <jnthn> ooh :)

[09:55] <sorear> (I have the day off, you may be aware)

[09:56] <jnthn> Ah, national holiday?

[09:56] * jnthn somehow had that down as today

[09:56] <sorear> yeah.  commemorates my country declaring war on yours.

[09:57] <jnthn> .oO( But I saw the movie, and thought it was "defeating alien spaceships over TCP/IP" day... )

[09:57] <sorear> I prefer to celebrate sorear-gets-the-day-off-to-hack-perl6 day

[09:57] <jnthn> Works for me :D

[10:04] *** daxim joined
[10:08] <jnthn> bbi10

[10:11] <masak> cognominal: for you: http://xkcd.com/1232/

[10:12] *** pmurias joined
[10:15] *** rking1 joined
[10:15] *** rking1 left
[10:25] *** sciurius joined
[10:43] <sorear> I wonder how much it would hurt if we had to run JVM try.rakudo as a signed full trust applet

[10:44] <sorear> it looks like sun in their infinite wisdom has made loading classes directly from memory a privileged operation

[10:44] <jnthn> ...urgh!

[10:44] <sorear> as opposed to base64encoding the class file into a class name and feeding it off to a magic reflector on the web server

[10:44] <sorear> :)

[10:46] <jnthn> omg!

[10:46] <jnthn> That's *evil*. Is there a max class name length? :)

[10:46] <lizmat> as long as the lock on the frontdoor is good, we're safe  :-)

[10:48] <sorear> the security check is invoked in the constructor, so um I'm going to see if the spec verifier bug I mentioned the other day is fixed in the real verifier

[10:49] *** rindolf joined
[10:49] <jnthn> .oO( Thus triggering Oracle to issue a new security update... :D )

[10:50] *** Rix joined
[10:50] <sorear> this would not be the first security check I've found in the implementation that is omitted from the spec

[10:54] *** cognominal left
[10:54] *** mst left
[10:54] *** mst joined
[10:55] *** rindolf left
[10:55] <dalek> roast: 6bfa6b1 | (Elizabeth Mattijsen)++ | S32-array/pop.t:

[10:55] <dalek> roast: Add some more tests related to pop()/.pop error conditions

[10:55] <dalek> roast: review: https://github.com/perl6/roast/commit/6bfa6b1488

[10:58] *** eiro joined
[11:03] *** pecastro_ joined
[11:04] *** pecastro left
[11:13] <sorear> jnthn: There's URLClassLoader.newInstance which looks like a nonprivileged way.  Will investigate later.

[11:16] <jnthn> Cool

[11:16] <jnthn> sorear: Are you likely to do the pipe/shell stuff at all, or should I put it on my list of things to look at?

[11:16] <jnthn> sorear: It's the leading blocker of spectests by now...by some margin.

[11:17] <jnthn> By files, if not by number of tests.

[11:17] <sorear> jnthn: pipe/shell stuff is blocking on a resolution to the $*EXECUTABLE_NAME problem

[11:17] <jnthn> The others being sprintf support, and a bounded serialization repossession bug...

[11:17] <jnthn> sorear: Oh...

[11:17] <jnthn> sorear: The problem being, what do we put in there?

[11:18] <jnthn> sorear: 'cus "it depends" whether we're running on the eval client or not?

[11:18] <sorear> jnthn: 

[11:18] <sorear> jnthn: yes

[11:18] <sorear> jnthn: pipe/shell is practically useless if we don't have something sane in there

[11:18] <jnthn> Right.

[11:19] <lizmat> r: my @a=1; my $b:= @a.pop; $b=3  # this is a bug, I presums

[11:19] <camelia> rakudo c74287: OUTPUT«Cannot assign to a readonly variable or a value␤  in block  at /tmp/ycEHcPnN4C:1␤␤»

[11:19] <jnthn> sorear: I can think of solutions, but they're all a bit hack.

[11:19] <sorear> potentially worse than useless if it evals to the empty string and roast runs random shell commands

[11:20] <jnthn> sorear: Do we have an op that exposes if we're running under the eval server or not?

[11:20] <arnsholt> Right. Let's see if we can't add some C compilation to the JVM build process ^_^

[11:21] <lizmat> r: my @a=1; my $b:= @a.shift; $b=3 

[11:21] <camelia> rakudo c74287:  ( no output )

[11:22] <jnthn> sorear: Oh, we'd need to know the *token* as well as the path to eval client, wouldn't we...

[11:22] <sorear> yes

[11:22] <sorear> and the path to perl6.jar

[11:22] <sorear> er no

[11:23] <sorear> anyway many of the is_run tests want to change env vars or the current dir or stuff, so we probably *shouldn't* run them through eval server

[11:23] <jnthn> And the token goes in a file on the client side, so the eval server itself has no idea on the file?

[11:23] <jnthn> Ah.

[11:23] *** mstefanko left
[11:23] <jnthn> There is always the option of saying "oh, just spawn the normal runner"

[11:23] *** army joined
[11:23] *** army is now known as mstefanko

[11:23] <jnthn> It'll be safer, though slower...

[11:24] <dalek> rakudo/nom: 8a76baa | (Elizabeth Mattijsen)++ | src/core/List.pm:

[11:24] <dalek> rakudo/nom: Revert "Remove .pop's "is rw" and fix the fallout from unshift's use of that"

[11:24] <dalek> rakudo/nom: 

[11:24] <dalek> rakudo/nom: This reverts commit 68301a78dc644229fa747250d7119500103f2baa.

[11:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a76baae74

[11:25] *** brrt1 joined
[11:26] *** census joined
[11:26] <jnthn> sorear: I think let's have Configure.pl generate a .java that goes into rakudo-runtime.jar and provides a method returning the path to the runner.

[11:26] <jnthn> sorear: Which Configure.pl knows, naturally.

[11:26] <jnthn> sorear: Then map an nqp::p6executable to it.

[11:27] <pmurias> jnthn: would that work when the executables are moved?

[11:28] <jnthn> pmurias: It'd need re-generating for "make install", and yes, it means that particular feature won't re-locate.

[11:28] <jnthn> Oh...

[11:28] <jnthn> Hmm.

[11:28] * jnthn had another idea but it probably won't work. :)

[11:28] <sorear> jnthn: I was kind of thinking of baking a -Dorg.perl6.rakudo.runner=XXX into the runner

[11:29] <sorear> would need some kind of escaping

[11:29] <jnthn> sorear: Would the XXX be determined "dynamically"?

[11:30] <jnthn> http://stackoverflow.com/questions/343518/finding-out-the-file-name-of-the-running-batch-file

[11:30] <sorear> jnthn: well, tools/build/create-jvm-runner knows the full path of the file it's creating

[11:30] <sorear> since it's rerun at install time

[11:30] <jnthn> sorear: oh, point

[11:31] <jnthn> sorear: Doesn't get us relocatability for that one feature, but I guess we can live with it.

[11:31] <jnthn> Somebody clever can probably figure out a solution later if they care to... :)

[11:35] *** census left
[11:35] *** census joined
[11:37] *** not_gerd joined
[11:38] <sorear> jnthn: we fail relocatability in a lot of ways

[11:38] <not_gerd> personally, I think it would be really cool if Rakudo could be packaged in a single jar and some batch/shell scripts

[11:39] <not_gerd> both batch and shell scripts can find out their own path, and so can Java programs

[11:39] <jnthn> sorear: Oh? I'm sure nwc10++ copied a Rakudo build to another machine and had it run...

[11:39] <not_gerd> s/programs/classes/

[11:47] <dalek> rakudo-js: 12f3ac4 | (Pawel Murias)++ | / (2 files):

[11:47] <dalek> rakudo-js: Deserialize contexts.

[11:47] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/12f3ac4e5b

[11:47] *** bloonix left
[11:50] <nwc10> IIRC I did, but the paths were probably identical

[11:51] <jnthn> ah

[11:51] <nwc10> mostly because the shell script runners had paths embedded

[12:00] <arnsholt> jnthn: JNI C code in src/vm/jvm/native sound good to you?

[12:01] <jnthn> arnsholt: wfm

[12:01] <sorear> whaaaat?

[12:01] <sorear> arnsholt: what are you trying to do?

[12:01] <jnthn> arnsholt: Wait, what is the C code?

[12:01] <jnthn> arnsholt: To build JNI itself?

[12:02] <jnthn> arnsholt: Or some custom stuff for us?

[12:02] <arnsholt> Custom stuff for us

[12:02] <jnthn> Hm

[12:02] <arnsholt> NativeCall needs a bit of glue to talk to libdyncall

[12:02] <jnthn> Oh...we can't use JNI directly to implement the NativeCall APIs?

[12:03] <sorear> arnsholt: suggest you use https://en.wikipedia.org/wiki/Java_Native_Access

[12:03] <arnsholt> Well, JNI is the Java Native Interface. That is, "how to call C code from Java"

[12:03] <sorear> jnthn: JNI is an XS-like interface; C-side marshalling

[12:03] <arnsholt> sorear: I'm looking at that too, but it looks like it's more like our NativeCall

[12:04] <arnsholt> That is, it doesn't seem to be easy to define interfaces at run-time without generating Java classes and feeding those to JNA

[12:05] <jnthn> arnsholt: P6opaque is already doing that class generation thing, fwiw.

[12:05] <jnthn> I think I'd prefer that over having to build custom C code.

[12:06] <arnsholt> Yeah, I know. But I'm not sure if I can use that class directly with JNA

[12:06] <arnsholt> Okies. I'll look harder at JNA, in that case

[12:06] <jnthn> No, probably not directly...

[12:07] <sorear> arnsholt: http://twall.github.io/jna/3.5.2/javadoc/com/sun/jna/Function.html

[12:07] <jnthn> I wonder if JNA exposes any kind of "plumbing" layer that the interfaces are just sugar for

[12:07] <jnthn> If we can get at that...

[12:07] <arnsholt> Yeah, I think I found it

[12:07] <jnthn> what sorear++ just said :)

[12:07] <sorear> jnthn: it does, I'm looking at the docs for that now

[12:08] <arnsholt> Yeah, it seems to do the trick

[12:08] <jnthn> Yeah, feels like a betterer way :)

[12:09] <arnsholt> More betterer! =)

[12:10] <sorear> sleep&

[12:10] <jnthn> 'night, sorear 

[12:14] *** berekuk joined
[12:25] <colomon> o/

[12:28] *** rindolf joined
[12:34] *** yves left
[12:35] *** census left
[12:36] <timotimo> http://t.h8.lv/p6bench/native_fixed.html - i fixed the native benchmarks by replacing $i++ by $i = $i + 1 everywhere and now there's more results

[12:37] <timotimo> it's amazing how utterly slow concat seems to be on jvm

[12:40] *** kaleem left
[12:42] <timotimo> it's interesting to note that the jvm seems to reach the StackOverflowError really, really quickly in the man or boy test

[12:44] <jnthn> We're just using the default stack size

[12:45] <jnthn> Which is probably not all that big

[12:46] *** brrt1 left
[12:47] *** ajr joined
[12:47] *** ajr is now known as Guest45501

[12:48] *** Guest45501 is now known as ajr_

[12:48] <jnthn> timotimo++ # thanks, those are interesting

[12:49] <arnsholt> The slow concat on JVM might be alleviated by using string builders

[12:49] <tadzik> timotimo: I think the usual thing one does to avoid the slow concat is using StringBuffers (or whatsitsname) all the time

[12:49] <tadzik> yeah, string builders

[12:50] <arnsholt> IIRC that was an important optimization in Java previous years, but I think the Java optimiser does it automagically these days

[12:50] <timotimo> arnsholt: i looked at the code. there's already string builders involved.

[12:50] <jnthn> Yeah, but not in that concat example, I doubt

[12:53] <timotimo> huh.

[12:53] <timotimo> i can investigate a bit more.

[12:53] <timotimo> oh, yes, of course

[12:54] <timotimo> that is actually concat with the ~ operator

[12:54] <colomon> right

[12:54] <timotimo> while_push uses the join method which uses string builders

[12:54] <colomon> which even if it uses string builder internally, is going to convert to string after each application, I'm betting.

[12:54] *** berekuk left
[13:02] <arnsholt> Right. Time to look at this Zavolaj issue

[13:04] <arnsholt> colomon++ # Bug report

[13:04] *** berekuk joined
[13:05] *** mdxi left
[13:16] *** iSlug joined
[13:18] *** clkao_ is now known as clkao

[13:19] *** xilo_ joined
[13:21] *** PacoAir joined
[13:22] *** konundra joined
[13:22] *** kaare_ joined
[13:25] *** not_gerd left
[13:41] <masak> I wish I could remember more often than even when I'm in the middle of a project and about to make some change, starting with something ridiculously small and making that work is usually a very good idea.

[13:41] <masak> for some reason I have this kind of behavior down pat when it comes to fresh projects. but not so much with mature projects.

[13:41] <colomon> sprintf?

[13:42] <jnthn> masak: Do the mature projects tned to have good test coverage?

[13:42] <masak> colomon: I wasn't thinking of anything in particular. this just struck me as something I'm bad at.

[13:43] <masak> jnthn: it varies. but I see what you're getting at.

[13:43] <jnthn> 'cus that can infuence feedback cycle cost, I guess...

[13:43] <jnthn> *influence

[13:43] <masak> yes, it can.

[13:43] *** woosley1 joined
[13:43] <masak> I think I've fallen into the trap I've described even with good test coverage.

[13:43] <jnthn> ah

[13:44] <colomon> masak: actually, what is the state of sprintf?  there are a bunch of tests blocking on it jvm, I'd be willing to help get it going.

[13:44] <masak> colomon: I think the state is pretty good. actually, I could spend some time tonight reviewing the state and getting back to you.

[13:44] <colomon> k

[13:44] <masak> a bunch of people made lots of good commits.

[13:46] <jnthn> Could be a good time to get it in.

[13:46] <jnthn> It's gotta be an improvement on the current state for JVM.

[13:47] <masak> well...

[13:47] <masak> it'd be integrated on the nqp level, I guess.

[13:47] *** cognominal joined
[13:48] <masak> and that would probably create quite a few regressions on Rakudo Parrot.

[13:48] <colomon> #ifdef it in?

[13:48] <masak> *possibly* that's where to start on the next sprint -- improving things so that the Rakudo Parrot spectests still pass.

[13:48] <jnthn> I was only gonna do it for JVM

[13:48] <masak> ok.

[13:48] <masak> that works, too.

[13:48] <jnthn> Which means it can be improved there

[13:48] <jnthn> And then we can swtich Parrot over too

[13:48] <colomon> and fix it there… right

[13:50] <masak> sounds good.

[13:50] *** benabik left
[13:50] <masak> hm, it only now strikes me that knowing which test files in roast target sprintf/fmt would be a good thing.

[13:50] <masak> that would give some roadmap-like guidance for what to do next with sprintf.

[13:50] *** benabik joined
[13:53] <colomon> fmt.t

[13:53] <colomon> sprintf.t

[13:53] <colomon> :)

[13:54] <colomon> but the date / time stuff rely on it a bunch as well

[13:54] <colomon> (both of those are S32-str, I think

[13:54] <colomon> )

[13:55] <masak> colomon++

[13:55] <colomon> it wasn't exactly rocket science.  ;)

[13:55] <jnthn> [Coke]++'s magical list of explosions is a good source

[13:56] <colomon> my guess is getting just a bit more sprintf in jvm would be a good thing

[13:56] <jnthn> https://gist.github.com/coke/5879701

[13:56] *** berekuk left
[13:56] <colomon> argh, idiot IRC client has started autocorrecting my spelling, and it doesn't know diddly about programming.

[13:57] <jnthn> hehe!

[13:59] *** woosley1 left
[13:59] <mst> < jnthn> autocorrect makes me sound regarded

[13:59] <colomon> it's the entire operating system doing it?

[13:59] <colomon> http://osxdaily.com/2011/07/28/turn-off-auto-correct-in-mac-os-x-lion/

[14:00] <geekosaur> native programs inherit autocorrect from the OS, yes

[14:00] <colomon> now I can type jvm without it turning into jam

[14:01] <mst> mmm ... jam ...

[14:02] *** Chillance joined
[14:02] <geekosaur> sticky autocorrect

[14:03] <colomon> masak: anyway, the executive summary of [Coke]++'s list is getting a more functional sprintf would be a big help in getting us 500+ more tests running (though perhaps not passing)

[14:04] <jnthn> Hm, that may get us to 95%...

[14:05] <FROGGS> looks like we need another sprintf evening

[14:05] *** daniel-s__ joined
[14:06] <masak> yeah.

[14:06] <masak> I have time this weekend.

[14:06] <FROGGS> me too I guess

[14:07] <jnthn> sounds like a sage use of time...

[14:08] <TimToady> you're parsely correct

[14:08] <colomon> I will be heading to the Great White North.   Though I guess I will probably have internet access until I leave Michigan, and then at the hotel in White River.  (May be driving the car, however, which would make hacking difficult.)

[14:08] *** logie joined
[14:09] <colomon> is there a repo for what you guys have gotten done already?

[14:09] *** daniel-s left
[14:12] <colomon> http://www.nagagamilodge.com/lake.php # they do have internet access at the lodge, so I won't disappear completely.  :)

[14:13] <FROGGS> colomon: https://github.com/masak/sprintf

[14:13] <colomon> FROGGS++

[14:14] *** cognominal left
[14:15] *** cognominal joined
[14:22] *** yves joined
[14:26] *** pjcj left
[14:28] *** pjcj joined
[14:42] <lizmat> cycling&

[14:42] *** raiph joined
[14:43] *** Pleiades` left
[14:45] *** mtk left
[14:48] *** Pleiades` joined
[14:48] *** ajr_ left
[14:49] *** ajr joined
[14:49] *** ajr is now known as Guest53985

[14:53] <colomon> "This representation can not unbox to a native str"

[14:54] *** Guest53985 is now known as ajr_

[14:54] <jnthn> Tends to be accurate :)

[14:54] <colomon> woof, sprintf.nqp is not terribly happy under JVM

[14:54] <jnthn> How'd you get it?

[14:55] <colomon> make nqp::join('', @pieces) (in sprintf)

[14:55] <jnthn> Is it using nqp::join on an array of things, some of which are not strings?

[14:55] <jnthn> OK, either make sure everything going into pieces is actually a string, or use join(...) instead of nqp::join.

[14:56] <colomon> looks like the pieces consist of the output of another nqp::join call and some asts.

[14:56] <colomon> I assume the latter are where I should be looking?

[14:56] <jnthn> Sounds like

[14:59] <colomon> oh, wow, switching it to join not only got around the crash, it made the two (pre-crash) failing tests work

[14:59] <colomon> with that change, it passes all tests on nqp-jvm

[14:59] <jnthn> \o/

[15:00] <FROGGS> O.o

[15:01] <FROGGS> and I thought nqp::join is the same as join when invoked by nqp

[15:02] <tadzik> same

[15:03] <benabik> I think if join() in NQP was the same as nqp::join, it wouldn't exist.

[15:03] <JimmyZ> o.O

[15:04] <jnthn> On Parrot they appear to be the same. Unfortunately, if you do use nqp::join on non-string things, then it results a  bunch of v-table calls back into Perl 6 code, which is slow.

[15:04] <jnthn> Under the JVM and Moar, it's simply an error to have something that won't unbox as a string in the thing given to nqp::join

[15:04] <FROGGS> so I should stick to join() in all cases?

[15:05] <jnthn> Depends what you know

[15:05] <FROGGS> k

[15:05] <jnthn> If you know you just constructed an array of strings...

[15:06] <FROGGS> so join() does more checks and is therefor a bit slower in general?

[15:06] <jnthn> It does the equivalent of nqp::join($joiner, @stuff.map(~*))

[15:06] <FROGGS> ahh

[15:06] <jnthn> Or *.Str, or whatever :)

[15:21] *** Timbus left
[15:23] *** sivoais left
[15:24] *** autumn left
[15:30] *** konundra left
[15:31] *** FROGGS left
[15:32] *** Timbus joined
[15:32] *** autumn joined
[15:35] <TimToady> sorear: http://irclog.perlgeek.de/perl6/2013-07-04#i_7287899 is incorrect; the loop would still be at statement level

[15:37] *** konundra joined
[15:38] <TimToady> moritz: and your "with very little downside" is, I believe, a conjecture that will be difficult to demonstrate

[15:38] * TimToady would welcome a well-thought-out proposal, being just a bit tired of the continual cheerleading approach...

[15:39] <TimToady> I tried making 'use fatal' the default earlier today, and ran into all sorts of problems, for instance

[15:41] <TimToady> and regardless of the Failure and loop discussions, I think that sink context is a crucial concept that is unlikely to go away

[15:41] <masak> sorry about contributing to the cheerleading. I agree fully about presenting well-thought-out proposals.

[15:41] <TimToady> it's almost like asking Haskell to throw out their IO monad

[15:41] <masak> it would be a big change.

[15:45] <jnthn> I don't personally have a problem with Failure so long as it doesn't cheat the type system, which we already had a good discussion on and I think concluded that at least Int:D bars Failure. The one that worries me is what happens when we made "for" mean map, and tripped a lot of people up. I don't (yet) have a proposal I can't shoot down 'cus it breaks another desirable thing, though...

[15:45] <jnthn> s/happends/happened/

[15:46] <masak> in fact, the only thing that has really pained me about lazy for loops is that adding or removing a statement *after* them can have a semantic effect on the for loop. each time it felt so illogical (once I tracked down the reason) that I immediately turned to raging on the channel, for the sake of future generations.

[15:46] <TimToady> and I've personally had to work around niecza's limitations in various rosettacode examples, so it's not fair to say that the current semantics went unnoticed

[15:47] <masak> I don't think I've claimed that they went unnoticed. just saying they felt really wrong.

[15:47] <TimToady> I wouldn't mind adding extra gather/takes if they were more efficient

[15:47] <jnthn> masak: I think 'sub foo () { try { for @a { ... } } }' was one of the trippiest ones. But I think we may have spec'd that try sinks?

[15:48] * diakopter awakens, sort of

[15:48] <TimToady> try is currently specced to turn on 'use fatal'

[15:48] <masak> jnthn: oh, that one. that was just a whole *different* sort of fail.

[15:48] <TimToady> as well as be eager

[15:48] <masak> jnthn: you know you're on the wrong track, design-wise, when you're throwing an error to the user that the user doesn't even understand, much less cares about.

[15:49] *** pecastro_ left
[15:49] <diakopter> .throw(:wolves)

[15:49] <masak> but yes, making try eager would fix that.

[15:49] <TimToady> and one can get around eager try with gather/take if the necessity arises

[15:50] <pmichaud_> good morning, #perl6

[15:50] <TimToady> do we really want to kill the "open file or next" kind of idiom?

[15:50] <TimToady> that's what 'use fatal' by default would do

[15:51] *** pmichaud_ is now known as pmichaud

[15:51] <TimToady> if we want to force people to sprinkle try everywhere, we probably have to change the syntax of try to make it more conducive to use inside an expression somehow

[15:51] <pmichaud> lizmat: ping

[15:51] <masak> pmichaud! \o/

[15:52] <jnthn> o/ pmichaud 

[15:52] <masak> pmichaud: lizmat is currently cycling, I believe.

[15:52] <TimToady> currently it's a statement prefix, so "try open $file or die" won't work

[15:52] <pmichaud> what's the reason for removing the 'is rw' from List.pop ?

[15:52] <pmichaud> oh, nevermind, I see it was reverted.

[15:52] <TimToady> I believe it got reverted

[15:52] <pmichaud> okay, good.

[15:52] <masak> pmichaud: I think the current sentiment is more like "what was the reason to have it there in the first place?"

[15:52] <jnthn> pmichaud: I think the question lizmat would ask is, "why is it there"? :) I didn't have a good answer.

[15:53] <masak> but I maybe insufficiently backlogged.

[15:53] <pmichaud> it's there because Lists are lists of containers

[15:53] <jnthn> pmichaud: Though can imagine there being one.

[15:53] <masak> may be*

[15:53] <pmichaud> or, more to the point, may be lists of containers

[15:53] <pmichaud> so if you pop a container from a List, you should be dealing with the container, not its value

[15:53] <jnthn> OK

[15:53] <jnthn> So it was intentional, not accidental. I suspected so, given it is the same way with shift.

[15:54] <pmichaud> just like if you say   .[3]   on a List, you're dealing with any container in the List, not with just the values

[15:54] <jnthn> *nod*

[15:54] <masak> pmichaud: I still don't quite see it. maybe all I need is a use case that obviously shows that pop should be 'is rw'.

[15:54] <masak> to me it feels intuitively like I pop values, not containers.

[15:54] <pmichaud> what is it being removed from the List?

[15:55] <pmichaud> you're not just removing the value, you're removing the container holding the value

[15:55] <masak> granted.

[15:55] <masak> that doesn't mean you're returning the container, though.

[15:55] <masak> with .[3] you can both read or assign to the thing. with .pop, all I imagine doing is read.

[15:55] <pmichaud> No.

[15:55] <pmichaud> No nonono

[15:55] <pmichaud> that's wrong.

[15:55] <pmichaud> with .[3] you can assign to the thing *if it's a container* in that slot.

[15:56] <pmichaud> we're talking about Lists, not Arrays

[15:56] <masak> fair enough.

[15:56] <masak> I don't see how it changes my point, though.

[15:56] <pmichaud> .[3] returns the thing in the slot.

[15:56] <pmichaud> .pop should return the thing in the last slot

[15:57] <masak> many other operations decontainerize the thing they return. why not .pop, too?

[15:57] <pmichaud> because .pop is primarily a thing used to manipulate a List.

[15:57] <pmichaud> and Lists are all about keeping track of containers and values.

[15:58] <masak> r: my @a = 1, 2, 3; my $b = @a.pop = 4; say $b

[15:58] <camelia> rakudo 8a76ba: OUTPUT«4␤»

[15:58] <masak> maybe because this is the only use case I've seen yet, I'm biased against this ;)

[15:58] <pmichaud> that's an Array.

[15:58] <masak> which also has an 'is rw' pop!

[15:59] *** pecastro joined
[15:59] <jnthn> Array ~~ List

[15:59] <pmichaud> if you have a Parcel, and then you want to manipulate the Parcel, you first convert it to a List.

[15:59] <masak> pmichaud: *you're* the one talking about Lists here. :)

[15:59] <pmichaud> you don't want that conversion to a List to suddenly start decontainerizing things when you manipulate it

[15:59] <masak> jnthn: welcome to Perl 6. Liskov does not always apply :/

[16:00] <jnthn> masak: Um. If you want Array to not have the "is rw" pop like List, then no, it won't. :P

[16:00] <pmichaud> and it really is analogous to shift, in many ways.  When shifting from a List or an Iterator, you don't want to automatically decontainerize whatever you're getting

[16:00] <jnthn> afaik, pop is inherited from List, though.

[16:01] <masak> pmichaud: usually I immediately store the shifted thing in a variable. and then it's no big deal because the variable has a container.

[16:01] <pmichaud> because if you do that, then things like   ($a,$b,$c).grep(    )    don't let you assign to $_

[16:01] <masak> ok, that's the first good use case I've seen.

[16:01] <jnthn> pmichaud: pop behaving like shift feels right, and the container argument for shift is a LOT stronger.

[16:01] <masak> that makes sense, I think.

[16:01] <jnthn> pmichaud++

[16:02] <masak> pmichaud++

[16:02] <pmichaud> masak: "I store the shifted thing in a variable"  means you're focusing on the value returned and not the container-ness of the thing that was in the List.  Sometimes you need the latter, though.

[16:02] <colomon> …. honestly, that still doesn't feel like a proper explanation to me.  I'm sure pmichaud has a good point, I just don't understand what it is.

[16:03] *** kivutar left
[16:03] <pmichaud> colomon: when iterating over a List, you're dealing with the elements of the List.  Sometimes those things are containers that you expect to be able to assign to.

[16:03] <masak> pmichaud: the ($a,$b,$c).grep(    ) and assigning to $_ did it for me. I see it now.

[16:03] <colomon> but… it's binding to $_ that's the issue, right?  If it were assigning, it would just work.

[16:04] <colomon> is $_ rw by default?

[16:04] <pmichaud> colomon: I don't understand the question.

[16:04] <colomon> r: my @a = 1,2,3; for @a { $_++ }; say @a

[16:04] <camelia> rakudo 8a76ba: OUTPUT«2 3 4␤»

[16:04] <masak> in for loops, it is.

[16:04] <masak> like an invisible '<-> $_'

[16:04] <colomon> don't think I knew that

[16:05] <masak> Juerd++ # <->

[16:05] <pmichaud> r: my $a = 1;  my $b = 2;   for ($a,$b) { $_++ };  say $a; say $b;

[16:05] <camelia> rakudo 8a76ba: OUTPUT«2␤3␤»

[16:05] <Juerd> \o/

[16:05] <Juerd> I like "my" operators, <-> and .=

[16:05] <masak> oh, you suggested .= too?

[16:05] <pmichaud> r: my $a = 1;  my $b = 2;   for ($a,$b,3) { $_++ };  say $a; say $b;

[16:05] <camelia> rakudo 8a76ba: OUTPUT«Cannot modify an immutable value␤  in sub postfix:<++> at src/gen/CORE.setting:3613␤  in sub postfix:<++> at src/gen/CORE.setting:2064␤  in block  at /tmp/fhlLJAhiT9:1␤␤»

[16:05] <masak> Juerd++ # .=

[16:06] <colomon> Juerd++ # .=

[16:06] <dalek> specs: 0d3a8a9 | larry++ | S02-bits.pod:

[16:06] <dalek> specs: failure must respect return type, if any

[16:06] <dalek> specs: review: https://github.com/perl6/specs/commit/0d3a8a974e

[16:07] <pmichaud> wait.... what?!

[16:08] * pmichaud is confused by 0d3a8a9

[16:08] <TimToady> fail inside a --> Int function throws regardless of 'use fatal' setting, per discussion with jnthn++

[16:08] <Juerd> masak: Almost a decade ago! https://groups.google.com/forum/#!topic/perl.perl6.language/bBEXULCoCjs

[16:09] <Juerd> IIRC, that was after a discussion on IRC

[16:09] * pmichaud thinks about that.

[16:09] <colomon> I think I understand why .[3] should return a container.  For me, uniformity with that is the best argument I've heard for pop is rw.  But it still seems a bit weird to me.

[16:10] <pmichaud> colomon: you have to think about it in terms of what a List holds and the way that Lists can act as mutable Parcels

[16:10] <pmichaud> not in terms of what someone would do with the value returned from List

[16:10] * Juerd rereads the thread and enjoys reading TimToady's stream of thoughts.

[16:11] <pmichaud> maybe it helps to think of it this way....

[16:11] <pmichaud> @a[*]   returns a Parcel containing all of the elements of @a

[16:11] <pmichaud> note that those elements are the containers in @a

[16:12] <pmichaud> Because it's a Parcel of containers, if I do    @a[*].pop   I would expect to get back the last container of @a -- i.e., assigning to it should change the corresponding value in the array.

[16:12] <masak> Juerd: me too.

[16:13] <masak> Juerd: I love the sense in that thread (mainly thanks to luqui) that Perl 6 is something you extend gramatically just by building grammars.

[16:13] <masak> I really really hope we get to that point.

[16:13] <colomon> pmichaud: that makes sense, but seems very very odd, somehow.

[16:13] <masak> pmichaud: yes, that also helps.

[16:14] <masak> pmichaud: (why I would ever do that... but, it makes sense that it works.) :)

[16:15] <TimToady> but you can't pop a Parcel

[16:15] <pmichaud> .list.pop then

[16:15] <colomon> does this imply we should have (for instance) first-rw, which returns the container of the first value that smartmatches?

[16:16] <colomon> or perhaps more interestingly, grep-rw?

[16:16] <pmichaud> I think that .first perhaps ought to be "is rw"

[16:16] <pmichaud> grep is already rw-like, or should be.

[16:16] <pmichaud> grep returns the elements maching a criteria,  not just the values matching a criteria

[16:17] <pmichaud> just like .map returns the elements matching a criteria, not just the values

[16:17] <pmichaud> er, I said that wrong.

[16:17] <colomon> r: my @a = 1..10; @a.grep(* %% 2) >>*>> 2; say @a

[16:17] <camelia> rakudo 8a76ba: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[16:17] <colomon> r: my @a = 1..10; @a.grep(* %% 2) >>++; say @a

[16:17] <camelia> rakudo 8a76ba: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing << or >>␤at /tmp/BltHUIMjrh:1␤------> [32mmy @a = 1..10; @a.grep(* %% 2) >>+[33m⏏[31m+; say @a[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤»

[16:18] <pmichaud> dot or unspace

[16:18] <colomon> r: my @a = 1..10; @a.grep(* %% 2) >>.++; say @a

[16:18] <camelia> rakudo 8a76ba: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix > instead␤at /tmp/EsrZBlNuza:1␤------> [32mmy @a = 1..10; @a.grep(* %% 2) >>[33m⏏[31m.++; say @a[0m␤»

[16:18] <colomon> r: my @a = 1..10; @a.grep(* %% 2).>>++; say @a

[16:18] <camelia> rakudo 8a76ba: OUTPUT«1 3 3 5 5 7 7 9 9 11␤»

[16:18] * colomon 's head explodes

[16:19] <TimToady> brunch &

[16:19] <colomon> n: my @a = 1..10; @a.grep(* %% 2).>>++; say @a

[16:19] <camelia> niecza v24-86-g39ab531: OUTPUT«1 3 3 5 5 7 7 9 9 11␤»

[16:19] <masak> if .grep works like that, surely .first should as well :)

[16:19] <masak> r: my @a = 1..10; @a.first(* %% 2).>>++; say @a

[16:20] <camelia> rakudo 8a76ba: OUTPUT«Cannot modify an immutable value␤  in sub postfix:<++> at src/gen/CORE.setting:3613␤  in sub postfix:<++> at src/gen/CORE.setting:2064␤  in sub hyper at src/gen/CORE.setting:14570␤  in sub hyper at src/gen/CORE.setting:14525␤  in sub METAOP_HYPER_POSTFIX at src/gen…

[16:20] *** ajr_ left
[16:20] * masak submits rakudobug

[16:20] <pmichaud> note that grep works like that in p5 as well

[16:21] * colomon is split between one side that says "THAT'S AWESOME!" and another that says "That's a grotesque distortion of what should be a nice functional method."

[16:21] <pmichaud> https://gist.github.com/pmichaud/5928913

[16:22] <pmichaud> in some sense, it *is* a functional method in this form.  It's returning exactly the elements that matched (the containers), without imposing a decontainerize operation on them

[16:22] <colomon> rn: my @a = 1..10; my $b := @a.grep(* %% 2); say @a.shift; $b.>>++; say @a;

[16:22] <pmichaud> if you decontainerize, you're not getting the elements that matched, you're getting the values of the elements that matched.

[16:22] <camelia> rakudo 8a76ba, niecza v24-86-g39ab531: OUTPUT«1␤3 3 5 5 7 7 9 9 11␤»

[16:23] <pmichaud> and again, Lists need to be able to keep track of containers, unlike Arrays which always supply their own containers

[16:23] <colomon> rn: my @a = 1..10; my $b = @a.grep(* %% 2); say @a.shift; $b.>>++; say @a;

[16:23] <camelia> rakudo 8a76ba, niecza v24-86-g39ab531: OUTPUT«1␤3 3 5 5 7 7 9 9 11␤»

[16:23] <masak> colomon: the fundamental problem really is that we allow all this mutation all the time. and that's not going to change, so we may as well go with it.

[16:24] <colomon> rn: my @a = 1..10; my @b = @a.grep(* %% 2); say @a.shift; @b.>>++; say @a;

[16:24] <camelia> rakudo 8a76ba, niecza v24-86-g39ab531: OUTPUT«1␤2 3 4 5 6 7 8 9 10␤»

[16:25] <pmichaud> okay, I think I understand the rational for fail inside of --> Int now.

[16:25] <pmichaud> r: sub xyz() { 3 };  say &xyz.of

[16:25] <camelia> rakudo 8a76ba: OUTPUT«(Mu)␤»

[16:25] <pmichaud> wfm.

[16:25] <colomon> I don't know if I'm against it or for it (though if I were against it, I think I'd insist we'd rename what we have grep-rw).  I do know my understanding of how this stuff works just got shattered.

[16:26] <pmichaud> if you're against it, a lot of other stuff likely breaks.

[16:26] <pmichaud> or has to be re-thought as well

[16:27] <masak> I despair at the proliferation of '-rw' constructs. it feels a bit like "let's add checkboxes for options!" design.

[16:27] <pmichaud> I agree.

[16:27] * diakopter had no former understanding of how all that works, so that's a good thing, I guess. Also, it is even less clear now

[16:27] <masak> diakopter: :)

[16:28] <diakopter> <- wasn't joking

[16:28] <masak> didn't think you were.

[16:28] <masak> but "even less clear now" is funny-'cus-it's-true, I guess.

[16:29] <diakopter> (even less clear than zero understanding, I guess)

[16:30] <diakopter> I mean, it's plausible [to me] that I'm not tryig hard enough

[16:30] <diakopter> *trying

[16:33] <diakopter> I'm beginning to think I'll never understanding anything HLLer than NQP

[16:35] <benabik> It feels a bit like P6 distinguishes between C++ references and values, but completely invisibly.

[16:36] <benabik> Some things are a reference, some things are a value, and you really only know when you try to modify it.  :-/

[16:37] <diakopter> I can never tell what "container" means - does that always mean IT (the result of the expression that returns it? or the variable that holds IT?) can be an lvalue? Or can be bound to?

[16:37] <diakopter> (can a container hold a container?)

[16:37] <timotimo> you can use binding to that effect, no?

[16:37] <diakopter> to what effet

[16:37] <diakopter> effect

[16:39] <timotimo> changing containers that "are somewhere else"

[16:39] <timotimo> as if having a pointer to a pointre

[16:39] <diakopter> see, I don't even know what that question means

[16:39] <diakopter> "changing containers"

[16:39] <timotimo> i'm not entirely sure myself ...

[16:39] <benabik> It feels to me like container == lvalue.

[16:40] <benabik> It's just that P6 has first-class-ish lvalues.

[16:41] <benabik> And variables aren't necessarily lvalues, if you bound it to a non-container.

[16:41] *** nyuszika7h left
[16:41] <diakopter> not only *whoosh*, 'asplode.

[16:42] *** SamuraiJack left
[16:42] <diakopter> the problem is the fact you find it necessary to preface that with "It feels to me"

[16:42] <benabik> Because I'm not completely familiar with the spec.

[16:43] <benabik> i.e. I think about it like this, but I lack the experience to be certain.

[16:44] * diakopter moves your messages from "trying to help me understand" to "comiserating with quagmire of ambiguity"

[16:44] <masak> diakopter: I think you might simply have very high standards of understanding.

[16:45] <masak> which, I might add, is not necessarily a bad thing.

[16:45] <masak> I sometimes wish I had higher standards of understanding.

[16:45] <benabik> diakopter: "Trying to help you reach my level of understanding"

[16:45] *** FROGGS joined
[16:46] <diakopter> masak: I agree that is a possibility, but if so, I don't know how to quantify or measure it

[16:46] * benabik feels like he has a decent understanding, but doesn't actually spend the time with P6 to be certain about it.

[16:47] <diakopter> benabik: I've had that sensation dashed too many times to enjoy it

[16:48] <diakopter> masak: perhaps more likely is I'm very bad at assuming in presence of ambiguity

[16:48] <benabik> I only dislike discovering I'm wrong if I don't get new knowledge to replace it.

[16:49] <pmichaud> p6 is trying to support both functional and stateful programming paradigms, and "containers" is where we get a lot of the stateful part.  

[16:54] <benabik> Is there a way to determine if a variable holds a container or a value?

[16:56] *** dakkar left
[16:56] <masak> benabik: more interestingly, in what realistic situation would you ever be unsure? :)

[16:56] <masak> nr: my $a; say $a.VAR

[16:56] <camelia> rakudo 8a76ba: OUTPUT«Any␤»

[16:56] <camelia> ..niecza v24-86-g39ab531: OUTPUT«Scalar.new(...)␤»

[16:56] <benabik> masak: Binding to the result of a variable function?

[16:57] *** nyuszika7h joined
[16:57] <benabik> masak: Introspecting a passed-in List?

[16:58] <masak> benabik: ...to either modify or not modify its contents?

[17:00] <pmichaud> sub xyz(\v) { ... }     # no way to know if 'v' is a container

[17:00] <pmichaud> well, there might be one, but I don't remember what it is at the moment :)

[17:01] <benabik> masak: Sure, why not?  A function that you can pass an array to and it will modify in-place or pass something immutable and it will return the new versions.  Maybe not the friendliest API, but I can see it existing.

[17:01] <masak> heh, the eternal dance of adding powerful features on the one hand, and introspecting the results of those powerful features on the other :P

[17:02] <masak> it reminds me of the "how can I distinguish whether someone didn't pass a value to this parameter, or whether they passed something but it was undefined?" discussion

[17:02] <jnthn> r: sub foo(\v) { v.VAR.isa(Scalar) }; say foo(1); say foo(my $a)

[17:02] <camelia> rakudo 8a76ba: OUTPUT«False␤True␤»

[17:02] <pmichaud> jnthn++

[17:03] *** birdwindupbird left
[17:03] <benabik> Maybe a more friendly way to word that:  Soft-failing a function that does modifications.  Perhaps the user passed something immutable but wants the side effects anyway.

[17:03] <benabik> jnthn++

[17:04] <masak> r: sub foo(\v) { return unless v.VAR.isa(Scalar); say "modification!" }; say foo(1); say "no modification"; say foo(my $)

[17:04] <camelia> rakudo 8a76ba: OUTPUT«Nil␤no modification␤modification!␤True␤»

[17:04] <masak> \o/

[17:04] <masak> r: sub foo(\v) { return unless v.VAR.isa(Scalar); say "modification!" }; foo(1); say "no modification"; foo(my $)

[17:04] <moritz> oh, one more poiint about the 'rw' debate

[17:04] <camelia> rakudo 8a76ba: OUTPUT«no modification␤modification!␤»

[17:05] <moritz> 'is rw' on return stuff seems to be used inconsistenly with 'is rw' in signatures otherwise

[17:05] <benabik> Although I guess you could have a non-Scalar that can FETCH and STORE, no?

[17:05] <benabik> Eh.

[17:05] <moritz> sub f($x is rw) { }; f 42; # is supposed to die, because it's not a container

[17:05] <moritz> I know rakudo doesn't implement it

[17:05] <moritz> (and the \ syntax for stuff that could or could not be a container)

[17:05] <diakopter> being able to tell whether something is a scalar at runtime wasn't my problem and isn't helpful to me; my problem is being able to tell what code does/creates

[17:06] <moritz> but we seem to use return-rw as if it was supposed to simply not strip the container

[17:06] <moritz> which isn't what 'is rw' in signatures does

[17:07] <moritz> so, it's either buggy too, and most useless when implemented correctly, or very wrongly named

[17:08] <diakopter> masak: did you mean to say it's more interesting to be able to tell whether something is that, at code-time, or run-time?

[17:21] <masak> diakopter: I was subtly implying that if you don't know it at code-time, you have bigger problems.

[17:22] <diakopter> okay. :) so we're in agreement. :)

[17:23] *** ajr joined
[17:24] *** ajr is now known as Guest87194

[17:24] *** Guest87194 is now known as ajr_

[17:40] <TimToady> the return meaning is more like the old "is parcel", before we had \x parameters

[17:41] <dalek> perl6-roast-data: 8353212 | coke++ | / (5 files):

[17:41] <dalek> perl6-roast-data: today (automated commit)

[17:41] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/83532126ec

[17:42] <TimToady> but the \ doesn't work symmetrically on the return value, unless we allow it in the --> \$x slot

[17:42] <TimToady> and I'm not sure that works right either

[17:42] <pmichaud> yeah, that would seem funny.

[17:43] <TimToady> and --> \x doesn't work either, since SSA says that has to be initialized at the point of declaration

[17:43] <TimToady> unless maybe we allow x := later on somehow

[17:44] *** rindolf left
[17:44] *** rindolf joined
[17:45] <TimToady> nr: my \x = my $x; x := 42; say x;

[17:45] <pmichaud> I've forgotten what the use case for return-rw is, though.

[17:45] <camelia> rakudo 8a76ba: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot use bind operator with this left-hand side␤at /tmp/dQ45hKRdFu:1␤------> [32mmy \x = my $x; x := 42[33m⏏[31m; say x;[0m␤    expecting any of:␤        postfix␤»

[17:45] <camelia> ..niecza v24-86-g39ab531: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/nreWiHumoU line 1:␤------> [32mmy \x = my [33m⏏[31m$x; x := 42; say x;[0m␤␤42␤»

[17:45] <TimToady> nr: my \x = my $x; x := 42; say $x;

[17:45] <camelia> niecza v24-86-g39ab531: OUTPUT«(Any)␤»

[17:45] <camelia> ..rakudo 8a76ba: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot use bind operator with this left-hand side␤at /tmp/WahaDTaIKN:1␤------> [32mmy \x = my $x; x := 42[33m⏏[31m; say $x;[0m␤    expecting any of:␤        postfix␤»

[17:47] <[Coke]> rakudo.jvm up to 93.46%

[17:48] <pmichaud> afk, lunch

[17:49] <jnthn> r: say 26097 - 24391

[17:49] <camelia> rakudo 8a76ba: OUTPUT«1706␤»

[17:52] *** rindolf left
[17:53] *** rindolf joined
[17:55] *** rindolf left
[17:55] *** rindolf joined
[18:01] *** rindolf left
[18:01] <timotimo> rakudo fails went up, though; is that from the .pop changes? were they reverted after the test run started?

[18:04] <colomon> rn: say 2**68 + 2**54 + 2**3

[18:04] <camelia> rakudo 8a76ba, niecza v24-86-g39ab531: OUTPUT«295165919577862307848␤»

[18:04] *** daxim left
[18:09] <colomon> wait, does nqp have native bigints?

[18:10] <moritz> yes-ish

[18:10] <colomon> > say(2**68 + 2**54 + 2**3)

[18:10] <colomon> 2.951659195778623E20

[18:10] <moritz> it has bigint ops

[18:10] <colomon> > say(295165919577862307848)

[18:10] <colomon> 9223372036854775807

[18:10] <moritz> but integer literals aren't bigints

[18:11] <colomon> ah

[18:11] <moritz> so you need a class with a bigint repr, make instances of that class and work with them

[18:11] <colomon> then my latest push to colomon/sprintf is all wrong

[18:11] <colomon> moritz: are there examples somewhere?

[18:11] * colomon needs to brush up on his NQP

[18:11] <colomon> afk # late midday noms

[18:14] <moritz> colomon: there are some bigint tests in the nqp repo

[18:19] *** berekuk joined
[18:19] *** raiph left
[18:29] *** snoopy joined
[18:40] <arnsholt> colomon: It's a weird bug you've reported =)

[18:48] *** berekuk left
[18:53] * masak .oO( better than in Soviet Russia, where that's a weird bug who reported YOU )

[18:53] *** berekuk joined
[18:56] <arnsholt> =D

[18:57] *** Timbus left
[18:58] *** Timbus joined
[18:58] *** autumn left
[18:58] *** sivoais joined
[19:00] *** autumn joined
[19:00] *** rindolf joined
[19:00] <lizmat> pmichaud: ping

[19:00] * jnthn back

[19:05] <lizmat> wrt "why do pop and shift have "is rw"

[19:05] <lizmat> it is simply I think because otherwise:  "my $a := @a.shift; $a = 1" would die because $a is marked read-only then

[19:06] <lizmat> as a side effect of course, "my $b = @a.pop = 3" becomes valid

[19:07] <lizmat> well, maybe not "of course", empirically that is what bhappens then

[19:08] <arnsholt> jnthn: Has there been any reworkings of how "does" does its work recently?

[19:09] *** mtk joined
[19:10] <arnsholt> Weeeeeird. "sub foo() is symbol(...) is native(...) { * }" works, but "sub foo() is native(...) is symbol(...)" doesn't

[19:11] *** Del_Monte joined
[19:11] <jnthn> arnsholt: Not that I can immediately think of.

[19:12] <jnthn> arnsholt: Last person to touch it was FROGGS iirc

[19:12] <FROGGS> I did what?

[19:12] <jnthn> git log src/Perl6/Metamodel/Mixins.nqp will tell all

[19:12] <jnthn> FROGGS: Touched mixins ;)

[19:12] <FROGGS> I did

[19:12] <arnsholt> Any idea how the above situation could arise?

[19:12] <jnthn> FROGGS: I don't know how what you did could cause what arnsholt is seeing though...

[19:14] <FROGGS> hmmm, if my patch did in one could comment out line nine here: https://github.com/rakudo/rakudo/commit/9009440

[19:15] <FROGGS> and maybe line 770 here too: https://github.com/perl6/nqp/commit/33a807fb537ed863c750b02accb7251ecd2f24c1

[19:16] <FROGGS> arnsholt: I can try that if you want

[19:16] <arnsholt> I'll give that a whack

[19:16] <FROGGS> I'd just need some code snippet to test ist

[19:16] <FROGGS> -s

[19:16] <FROGGS> k

[19:20] *** sqirrel left
[19:25] <sorear> good * #perl6

[19:25] <FROGGS> sorear o/

[19:28] <masak> sorear! \o/

[19:30] *** Rix left
[19:30] <arnsholt> FROGGS: Commenting out those lines doesn't seem to fix the bug, so not your fault =)

[19:32] <masak> lizmat: well, 'my $a := @a.shift; $a = 1' is not a strong enough use case for me either.

[19:32] <masak> lizmat: but ($a, $b, $c).map(     ) is.

[19:32] <jnthn> o/ sorear 

[19:34] <lizmat> reading the backlog, I think the argument to me is not whether .pop should return the actual container / make it rw.  It's really about .pop being a left value

[19:34] <lizmat> aka: my $b := @a.pop; $b =2   should work, but my $b = @a.pop = 3 should not

[19:34] *** Gruber joined
[19:35] <lizmat> returning a left value and being a left value, are not the same thing to me

[19:36] <lizmat> otoh, I can live with the current situation, now I understand why it is there

[19:36] *** bonsaikitten joined
[19:36] <jnthn> So, what should I do with this evening's tuits... :)

[19:37] *** BinGOs_ joined
[19:37] *** Juerd_ joined
[19:37] <lizmat> make a method that returns the "keyof" of a typed Hash

[19:37] <lizmat> so I can update .perl for typed hashes

[19:37] <jnthn> method keyof() { TKey }

[19:37] <jnthn> Next!

[19:37] <lizmat> that's it?

[19:37] *** smash joined
[19:37] *** mls_ joined
[19:37] <jnthn> well, lemme check the code...

[19:37] *** Hor|zon joined
[19:38] <jnthn> yeah

[19:38] <jnthn> my role TypedHash[::TValue, ::TKey] does Associative[TValue] {

[19:38] *** sunnavy_ joined
[19:38] <lizmat> consider that implemented and tested then  :-)

[19:38] *** Rix joined
[19:38] <jnthn> So a method in there like I showed will do it. Then one in EnumMap or so that returns...hm, well, Any for now I guess, thuugh should be Any(Str) in the end.

[19:38] *** broquain1 joined
[19:39] <jnthn> uh, sorry

[19:39] <jnthn> Str(Any)

[19:39] *** Util_ joined
[19:39] <lizmat> ok

[19:39] <jnthn> But we don't have coercion types yet.

[19:39] *** bakedb joined
[19:39] *** ponbiki_ joined
[19:39] <lizmat> the other thing that's stumped me, is the default value for assigning Nil

[19:39] *** awwaiid_ joined
[19:40] <lizmat> r: my Int $a=1; $a=Nil; say $a

[19:40] <camelia> rakudo 8a76ba: OUTPUT«No such method 'gist' for invocant of type 'NQPMu'␤  in sub say at src/gen/CORE.setting:11384␤  in block  at /tmp/ECwtz6loY2:1␤␤»

[19:40] *** telex left
[19:40] <lizmat> somehow "the_default" is not set in the ContainerDescription

[19:40] *** telex joined
[19:40] <jnthn> Hm, didn't that work?

[19:40] *** sunnavy left
[19:40] *** eiro left
[19:40] <jnthn> hm

[19:41] *** PZt left
[19:41] *** Juerd left
[19:41] *** BinGOs left
[19:41] *** broquaint left
[19:41] *** Grrrr left
[19:41] *** Del_Monte left
[19:41] *** Hor|zon_ left
[19:41] *** bakedb_ left
[19:41] *** smash_ left
[19:41] *** ponbiki left
[19:41] *** Util left
[19:41] *** DrEeevil left
[19:41] *** mls left
[19:41] *** awwaiid left
[19:41] *** Juerd_ is now known as Juerd

[19:41] <jnthn> lizmat: Where is it meant to be set?

[19:42] <jnthn> lizmat: I don't see anything in install_lexical_container setting it

[19:42] <lizmat> well, that may be the pb then...

[19:42] <jnthn> no, wait, not there

[19:42] <jnthn> create_container_descriptor

[19:42] *** BinGOs_ is now known as BinGOs

[19:43] *** BinGOs left
[19:43] *** BinGOs joined
[19:43] *** Del_Monte joined
[19:43] <lizmat> so that would need a :$default parameter ?

[19:43] <lizmat> (optional)

[19:43] *** eiro joined
[19:45] *** kaare_ left
[19:46] <lizmat> r: sub a () { (1,2,3).map({ return $_ }) }; a # wonders about the correctness of the error message

[19:46] <camelia> rakudo 8a76ba: OUTPUT«Attempt to return outside of any Routine␤current instr.: 'throw' pc 367455 (src/gen/CORE.setting.pir:158274) (src/gen/CORE.setting:9213)␤called from Sub '' pc 109440 (src/gen/CORE.setting.pir:48642) (src/gen/CORE.setting:10440)␤called from Sub '' pc 36590 (src/gen/…

[19:47] <jnthn> Well, or do $default = $of at the end, perhaps

[19:47] *** mls_ left
[19:47] *** gudahtt left
[19:47] *** segomos left
[19:47] *** mls joined
[19:47] *** segomos joined
[19:48] *** gudahtt joined
[19:48] <lizmat> ah, gotcha, yeah, that would work for now

[19:48] <lizmat> testing that now

[19:49] <sorear> jnthn: how would you feel about a gimme_v bit in the call frame that propagates down, though?

[19:49] <jnthn> well, breaks for the default case

[19:49] <jnthn> That'll want a fix somewhere in Actions.pm

[19:50] * jnthn digs into a tricky problem he's put off for a while

[19:51] <arnsholt> jnthn: https://gist.github.com/arnsholt/5929886

[19:51] <arnsholt> Looks like a Sub-specific issue with role mixins?

[19:51] <FROGGS> arnsholt: \o/

[19:51] <FROGGS> arnsholt: though that doesnt help you :/

[19:52] *** estrabd_ joined
[19:52] *** estrabd left
[19:52] <sorear> FROGGS: how does v5.pm handle wantarray?

[19:53] <FROGGS> sorear: it does not

[19:53] <FROGGS> (yet)

[19:53] *** moritz_ joined
[19:53] *** xinming_ joined
[19:54] *** gabriel joined
[19:54] *** BooK_ joined
[19:54] *** BinGOs_ joined
[19:54] <lizmat> jnthn: success!

[19:54] <lizmat> perl6 -e 'my Int $a=1; $a=Nil; say $a'

[19:54] <lizmat> (Int)

[19:55] <lizmat> running spectest now

[19:56] *** TimToady_ joined
[19:56] <masak> lizmat++

[19:57] *** hlin_ joined
[19:57] *** xinming left
[19:57] *** lestrrat left
[19:57] *** renormalist left
[19:57] *** BinGOs left
[19:57] *** sftp left
[19:57] *** hypolin left
[19:57] *** moritz left
[19:57] *** gabriel_ left
[19:57] *** BooK left
[19:57] *** TimToady left
[19:57] *** lestrrat joined
[19:58] *** sftp joined
[19:58] *** BinGOs_ is now known as BinGOs

[19:58] *** BinGOs left
[19:58] *** BinGOs joined
[20:01] *** zby_home joined
[20:04] *** ssutch joined
[20:05] <jnthn> sorear: I guess it's do-able...

[20:06] <ssutch> hallo everyone 

[20:06] <masak> hi, ssutch!

[20:06] <ssutch> it's been too long

[20:07] * masak .oO( /join #perl6 early, /join #perl6 often )

[20:08] <sorear> o/

[20:08] <FROGGS> hi ssutch 

[20:09] <ssutch> \o

[20:11] <rindolf> ssutch: hi.

[20:13] *** spider-mario joined
[20:14] <lizmat> jnthn, masak: I guess this is a bug, right?  We would expect Any

[20:14] <lizmat> $ perl6 -e 'my $a=1; $a=Nil; say $a'

[20:14] <lizmat> Nil

[20:15] <jnthn> Lookslike.

[20:16] <masak> aye.

[20:16] <lizmat> trying to fix

[20:18] <ssutch> whatever happened to sprintf implementation in NQP?

[20:19] <jnthn> ssutch: Ongoing. :)

[20:19] <FROGGS> it is still in masak's repo, and their are plans for another hackathon this weekend

[20:20] <ssutch> neato, now it's a grammar

[20:20] <FROGGS> but feel free to do things before then :o)

[20:20] <FROGGS> I hope it easier to read that way

[20:20] <FROGGS> specially when having many different rules with different options

[20:20] <labster> o/ #perl6

[20:21] <FROGGS> hi labster 

[20:21] <FROGGS> labster: how is $work going?

[20:21] <ssutch> darn someone did right justification

[20:21] <ssutch> :p

[20:21] <FROGGS> *g*

[20:21] <jnthn> Better than them doing wrong justification...

[20:21] <FROGGS> >.<

[20:22] <ssutch> badump *sshhh*

[20:22] <FROGGS> hehe

[20:22] <labster> FROGGS: I'm still getting set up with the paperwork, and today is a national holiday

[20:22] <FROGGS> k

[20:23] <labster> but for right now I believe I am getting paid to do nothing, so that's good

[20:23] <FROGGS> well, then there is room for improvement at $work

[20:25] <masak> ssutch: there are still things left to do :)

[20:25] <ssutch> indeed!

[20:25] <masak> and yes, feel free to join Saturday, or before that, or after that :)

[20:25] <masak> I'll try to provide some basis for a direction by Saturday,

[20:25] <ssutch> what GMT saturday?

[20:26] <masak> let's say 18:00Z.

[20:26] <masak> I think we did last time.

[20:26] <ssutch> derp, im backpacking saturday

[20:26] <masak> oh noes

[20:27] <dalek> nqp: 6ff98f6 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/SerializationWriter.java:

[20:27] <dalek> nqp: Sanity check in serialization writer.

[20:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ff98f6949

[20:27] <dalek> nqp: dfeac2b | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/SerializationContext.java:

[20:27] <dalek> nqp: Another sanity check in repossession.

[20:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dfeac2b1e9

[20:27] <ssutch> when not hacking: https://secure.flickr.com/photos/samsutch/8872674511/in/set-72157633773325225/

[20:27] <masak> well, as I said, we're distributed in time as well as geographically. :)

[20:28] <ssutch> indeed :)

[20:28] <lizmat> bit of an NQP question: I would like to do something like "$of ~~ Mu ?? Any !! $of"

[20:28] <masak> so feel free to chip in on non-Saturday if that works better.

[20:28] <sorear> jnthn: having problems with repo conflicts?

[20:28] <lizmat> but I get "Cannot type check against type variable TValue" error

[20:28] <jnthn> ssutch: Ooooh! Pretty!

[20:28] <sorear> lizmat: nqp::istype($of, Mu) might work better

[20:28] <TimToady_> um $of ~~ Mu is always true

[20:29] <sorear> unless $of is a foreign object

[20:29] <dalek> rakudo-js: f687267 | (Pawel Murias)++ | / (2 files):

[20:29] <dalek> rakudo-js: Add licence file.

[20:29] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/f6872674a7

[20:29] <masak> ssutch: that mountainside looks impressive.

[20:29] <jnthn> lizmat: I...think if you're writing that line of code, you're solving it wrong. :)

[20:29] <jnthn> Though yeah, the error happens when you try to use a type variable as if it were a real type.

[20:29] <lizmat> well, I need to handle the case of an untyped container

[20:29] <TimToady_> introspection is usually a code smell, though of course Mu is always close to bootstrappy issues

[20:30] <lizmat> you're saying I should havndle that in BUILD ?

[20:30] <jnthn> lizmat: Yes, but that has already been computed

[20:30] <lizmat> of the ContainerDescriptor

[20:30] <ssutch> masak, jnthn: yosemite, in california, US

[20:30] <jnthn> lizmat: No, I'm saying that you should already have the correct thing to pass when calling install_lexical_container.

[20:30] <jnthn> lizmat: sorry

[20:30] <jnthn> lizmat: No, I'm saying that you should already have the correct thing to pass when calling create_container_descriptor

[20:30] <TimToady_> iow, we shouldn't have places where objects are created without the of type already

[20:30] <lizmat> well, if I just pass :default($of)

[20:31] <lizmat> I get "$ perl6 -e 'my $a=1; $a=Nil; say $a'" saying Nil instead of Any

[20:31] <sorear> ssutch: o/ CAfolk

[20:32] <lizmat> it works fine for typed containers, but not for untyped ones: in that case, $of appears to be Mu rather than Any

[20:32] <sorear> ssutch: north or south?  any chance of dragging you to sandiego.pm?

[20:32] <jnthn> lizmat: Moment, lemme find the bit of code we need to look at

[20:32] <ssutch> sorear: SF, but yeah maybe, i'd like to get to SD again

[20:32] <jnthn> lizmat: In sub declare_variable in Actions.pm

[20:32] <TimToady_> btw, moving Nil outside of Any in niecza breaks 26 tests; didn't do it right to decide which 26 it broke though...

[20:32] <jnthn> There are these two lines:

[20:33] <jnthn> my %cont_info := container_type_info($/, $sigil, $*OFTYPE ?? [$*OFTYPE.ast] !! [], $shape);

[20:33] <jnthn> my $descriptor := $*W.create_container_descriptor(%cont_info<value_type>, 1, $name);

[20:33] *** zby_home left
[20:33] <jnthn> that %conf_info contains the key default_value, which is what you want to pass co create_container_descriptor

[20:33] <jnthn> *to

[20:33] <TimToady_> also note that if Nil means "no argument", we can't use === Nil to test Nilness

[20:34] <lizmat> TimToady: no argument there  :-)

[20:34] <jnthn> sorear: Well, I've got some of the write barriers missing at the moment, but when I first added them Weird Things happened. So taking a step back and trying again :)

[20:34] <TimToady_> but =:= is also problematic when you want to say $x =:= Nil

[20:34] <jnthn> sorear: This time with some more sanity checks. :)

[20:35] <TimToady_> so I think we really need a .is-Nil method or some such

[20:36] <lizmat> ok, that means create_container_descriptor needs another (optional) parameter

[20:36] <jnthn> lizmat: Yes; I thought we'd established that? :)

[20:36] <lizmat> then I must have misread you

[20:36] <lizmat> ok, going ahead with thah

[20:36] <lizmat> that

[20:37] <jnthn> Oh :)

[20:37] <jnthn> OK. Well, I think it can default to $of. $default = $of. And then pass it in the places we know better :)

[20:38] <lizmat> indeed

[20:39] *** rindolf left
[20:39] *** bloonix joined
[20:40] <TimToady_> or make defined return Nil for Nil instead of True/False, and then we can test it with .defined.defined :)

[20:42] <TimToady_> or distinguish Nil the singleton value from Nilness the role, so ~~ Nilness works

[20:42] <TimToady_> (that one's a serious suggestion)

[20:42] <TimToady_> Nillity?

[20:43] <TimToady_> or make nil the value, and Nil the type

[20:43] <lizmat> Nihil?

[20:43] *** moritz_ is now known as moritz

[20:43] <TimToady_> :)

[20:43] * geekosaur was trying to type Nihily when something stole focus///

[20:43] *** BenGoldberg joined
[20:44] <TimToady_> the advantage of using a type rather than a method is that we'd have to define the method in Mu to return False for everything, plus people might be tempted to override it

[20:44] * masak prefers 'nil' the value and 'Nil' the type so far

[20:45] <TimToady_> whereas a .does test is pretty static

[20:46] <lizmat> so would undefine() we equivalent to x = nil or x = Nil ?

[20:46] <TimToady_> the first

[20:48] <lizmat> that would be a spec change then, as it is specced to be x = Nil

[20:48] <TimToady_> right

[20:49] <lizmat> would we need a type Nil then ?

[20:49] <TimToady_> yes, to do things like ~~ Nil

[20:49] <lizmat> I guess we do, because nil would be of type Nil, right?

[20:49] <lizmat> right

[20:49] <lue> .oO(my Nil \nada;)

[20:49] <TimToady_> or .what === Nil

[20:49] <TimToady_> er .WHAT

[20:51] <TimToady_> hmm, I seem to have a tail

[20:51] *** TimToady_ is now known as TimToady

[20:51] <TimToady> that's better

[20:52] <TimToady> one argument against nil the value is that Nil stands out more visually

[20:53] <TimToady> but I don't suppose that's a strong argument

[20:54] <lizmat> (running spectest)

[20:54] <TimToady> we also have various enums that have uppercase values, like True

[20:54] <TimToady> a minor consideration is that switching Nil the type/value to Nil the value only is much easier than switching to nil the value

[20:55] *** PZt joined
[20:56] <lue> In the case of True/False (and possibly nil), I think of those as not holding much more information than a type object, so their type-like capitalization is fine.

[20:56] <TimToady> so I'm more inclined to put Nil into the "singleton enum" camp, and come up with a name for the class and/or role

[20:57] * lue would suggest the type be named Undef were he feeling bolder

[20:58] <FROGGS> I like Nil the value... it doesnt feel like a type anyway. True/False is of type Bool, but Nil what is Nil?

[20:58] <TimToady> then, of course, everyone will wonder why the value isn't 'undef'...

[20:58] <TimToady> if $x.does(Nothing)

[20:58] <lizmat> especially since undefine() assigns that value   :-)

[20:59] <sorear> jnthn: I see

[21:02] *** preflex joined
[21:02] *** ChanServ sets mode: +v preflex

[21:02] <lue> I think I like Nothing as the type name. .oO(my @data is Nothing;)

[21:03] <lue> (alternatively, remembering Mu means everything, Nil's type could be Um)

[21:04] <pmurias> rakudo: Foo::sayfoo();module Foo { my $foo=123;our sub sayfoo {say $foo} };Foo::sayfoo()

[21:04] <TimToady> I was thinking we'd reserve Um for the bottom type, if we ever get one :)

[21:04] <camelia> rakudo 8a76ba: OUTPUT«(Any)␤123␤»

[21:04] <pmurias> TimToady: ^^ have you considered if code like that is something we should allow?

[21:04] <TimToady> since Nil means something that isn't there that should be, maybe we should name the type Bummer

[21:04] <TimToady> $x ~~ Bummer

[21:05] * FROGGS .oO( $x ~~ Money )

[21:06] <lizmat> jnthn: could it be that "                %info<default_value>   := $*W.find_symbol(['Any']);" fails ?

[21:06] <TimToady> pmurias: looks like it works correctly to me, and I see no reason to disallow it

[21:07] <TimToady> if we did rename Nil, I'd be tempted to make it oops and Oops :)

[21:07] <lue> .oO(What's the most derived type you could possibly have in Perl 6? Um...)

[21:07] <lizmat> TimToady: but $foo is assigned before the first call to sayfoo?

[21:08] <TimToady> no, it's not

[21:08] <TimToady> package guts are executed inline

[21:08] <jnthn> lizmat: Very unlikely.

[21:08] <lizmat> .oO ( Um = Unaccompanied Minor )

[21:09] <geekosaur> unfortunate mishap

[21:09] <lue> $x ~~ Whoops

[21:09] <TimToady> Um is of type Err  :)

[21:10] <TimToady> then we derive failure from it too

[21:10] <FROGGS> I'd say Ohh is of type Err too

[21:10] <lue> class Um is Err { }; class Human is Err { };

[21:11] <TimToady> class Moo is Bovine {}

[21:11] * geekosaur was trying to decide whether that was to be parsed err as in erroneous, or err as in the schwa-ish  vocalization

[21:11] <geekosaur> :)

[21:11] <TimToady> geekosaur: what makes you think it was intended as "or" rather than "and"?

[21:12] <geekosaur> ...or indeed that

[21:12] <geekosaur> (which I was typing rather more verbosely when you said that)

[21:13] <lizmat> .oO ( unfortunate mishap: what a way to describe your offspring )

[21:13] <lue> Err I don't think is a good choice, too many people might mistake it as a verb. How's about Hmm ?

[21:13] <masak> yes, "Bummer" is the clear winner for a name for a bottom type :)

[21:14] <geekosaur> $x ~~ Wat

[21:17] * lue likes Um for the (theoretical) most-derived type.

[21:17] *** Del_Monte left
[21:18] <lue> Since Nil is what Perl 6 gives you as a consolation prize if what was supposed to be here isn't, maybe the type should be Sorry.

[21:19] <TimToady> sorry

[21:22] <TimToady> maybe Nil and Failure are derived from Bogus

[21:23] <TimToady> I kinda like ~~ Bogus

[21:26] <lue> we would need an C<is_totally> synonym for C<is> then. my class Foo is_totally Bogus { ... }  :)

[21:27] <dalek> v5: 4596875 | (Tobias Leich)++ | t/test.pl:

[21:27] <dalek> v5: hide warning for undefined third arg of is()

[21:27] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/4596875e4e

[21:27] <dalek> v5: 2cf7715 | (Tobias Leich)++ | lib/Perl5/Actions.nqp:

[21:27] <dalek> v5: implicit param in blocks, like in grep

[21:27] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/2cf77153f8

[21:27] <dalek> v5: 02219af | (Tobias Leich)++ | lib/Perl5/Grammar.nqp:

[21:27] <dalek> v5: closures dont get implicit $_ as iterator

[21:27] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/02219afab7

[21:27] <dalek> v5: e86dd41 | (Tobias Leich)++ | / (2 files):

[21:27] <dalek> v5: refactor pack/unpack a "bit", add some directives

[21:27] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/e86dd41e0b

[21:28] <TimToady> 'course, if the type is Bogus, maybe the particle has to be a bogon

[21:28] <TimToady> but that's a bit long

[21:28] <TimToady> we were trying for something shorter than undef

[21:29] <dalek> rakudo/nom: 6c4c901 | (Elizabeth Mattijsen)++ | src/Perl6/World.nqp:

[21:29] <dalek> rakudo/nom: Make $a=Nil work

[21:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c4c901777

[21:29] <dalek> rakudo/nom: 677e0ed | (Elizabeth Mattijsen)++ | src/Perl6/ (2 files):

[21:29] <dalek> rakudo/nom: Make Nil work for typed containers, alas not for untyped containers

[21:29] <dalek> rakudo/nom: 

[21:29] <dalek> rakudo/nom: Suggestions welcome.

[21:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/677e0ed74f

[21:30] <TimToady> all containers are typed, even if the user doesn't think so

[21:30] <lizmat> ok, without explicit type definition

[21:30] <lizmat> :-)

[21:33] <lue> You could remove the u and have the n mean "not" ^U How about No, or Oops, or Um, or Nothing, or ...

[21:33] <benabik> my \Nil is Nothing;

[21:35] *** Guest1337 joined
[21:35] <TimToady> more like my \Nil = Nothing.new;

[21:35] <benabik> hah.

[21:35] *** spider-mario left
[21:35] <TimToady> or constant Nil = Nothing.new;

[21:35] *** PacoAir left
[21:35] <lue> my class Act { has Nothing $to-lose; }

[21:38] <lizmat> jnthn: I found the problem: in rakudo_scalar_store we only do the default assignment if the typecheck fails

[21:39] <lizmat> if the typecheck doesn't fail, we do not test for Nil, and thus we never replace it with the default value before putting it into the container

[21:39] <lizmat> so the only way to fix this, is to check for Nil for *every* rakudo_scalar_store action

[21:41] <masak> r: my @a; say @a[3]

[21:41] <camelia> rakudo 8a76ba: OUTPUT«(Any)␤»

[21:41] <masak> r: my @a; say @a[0..3]

[21:41] <camelia> rakudo 8a76ba: OUTPUT«(Any) (Any) (Any) (Any)␤»

[21:41] <sorear> aren't untyped containers Any/

[21:41] <masak> how do I produce a Nil in the rhs, apart from writing it literally?

[21:42] <masak> sorear: yes.

[21:42] <sorear> isn't Nil outside Any?

[21:42] <lizmat> masak,sorear: this is cm/parrot/guts/container.c

[21:42] <lizmat> *vm

[21:44] <lizmat> the implementation so far was base on the typecheck failing when assigning Nil to (x)

[21:44] <lizmat> based

[21:44] *** dmol left
[21:45] <lizmat> after a fail, the value to be assigned would be checked for Nilness, and if so, replaced by the default value

[21:45] <jnthn> ah...

[21:45] <jnthn> Yeah, I guess that won't cut it :/

[21:45] <lizmat> spectesting now with *first* a check for Nilness, and *then* a typecheck if it was not Nil

[21:45] <lizmat> $ perl6 -e 'my $a; say $a; $a=Nil; say $a'

[21:45] <lizmat> (Any)

[21:45] <lizmat> (Any)

[21:46] <lizmat> better: $ perl6 -e 'my $a=1; say $a; $a=Nil; say $a'

[21:46] <lizmat> 1

[21:46] <lizmat> (Any)

[21:46] <lizmat> $ perl6 -e 'my Int $a=1; say $a; $a=Nil; say $a'

[21:46] <lizmat> 1

[21:46] <lizmat> (Int)

[21:47] <masak> \o/

[21:48] <lizmat> (seeing some test failures ;-(  )

[21:50] <lizmat> does this ring a bell? "sh: mono: command not found"

[21:51] <lizmat> mono???

[21:51] <lizmat> in parakudo?

[21:51] <jnthn> what?

[21:52] <sorear> I think you managed to confuse Test/Util.pm into thinking it's running on niecza

[21:52] <lizmat> oddly enough, it generates rakudo.parrot fudged files

[21:53] <lizmat> quite a few tests fail  :-(

[21:54] <lizmat> .oO( trying to get rakudo.jvm 95%+ ;-)

[21:54] <lizmat> several TODO's passed as well, so it is not all bad

[21:55] <diakopter> sorear: Hi :D

[21:55] <diakopter> lizmat: howdy

[21:55] <diakopter> jnthn: ahoy

[21:55] <lizmat> diakopter: hoi!

[21:55] <jnthn> hi diakopter 

[21:56] <sorear> o/

[21:56] <masak> diakopter! \o/

[21:56] <lizmat> jnthn: does ->type_check have some side effects?

[21:56] <jnthn> lizmat: Hopefully not

[21:57] <lizmat> this is the diff: https://gist.github.com/lizmat/5930464

[21:59] <jnthn> argh, make bootstrap-files in NQP is broken 

[22:00] <lizmat> did I break something?

[22:01] <jnthn> lizmat: no, that ain't you ;)

[22:01] <lizmat> *phew*

[22:01] <jnthn> lizmat: The diff doesn't look wrong at first glance

[22:03] *** cognominal left
[22:03] *** cognominal joined
[22:04] <sorear> jnthn: what needs to be bootstrapped?

[22:05] <lizmat> something seriously broken with the patch to always check for Nil:

[22:05] <lizmat> $ perl6 -e 'say $*EXECUTABLE_NAME; say $*EXECUTABLE_NAME ~~ m:i/niecza/'

[22:05] <lizmat> perl6

[22:05] <lizmat> True

[22:05] <lizmat> *sigh*

[22:05] <sorear> jnthn: and can we develop something that will reduce the need to bootstrap?  'cause I'm not fond of bloating the repo >_>

[22:08] <jnthn> sorear: Me either, but a premature opt I did in the Cursor role is causing some...fun :/

[22:09] <jnthn> It actually breaks our ability to do parsing in different threads too, once we get them...

[22:09] <lizmat> jnthn: I guess somewhere in the regex engine, Nil is being returned and it gets Any in there or something

[22:09] <jnthn> lizmat: Probably not in the regex engine itself, but somewhere in one of the regex related bits of code, probably

[22:10] <jnthn> lizmat: We may be relying in some places on being able to keep Nil in a scalar.

[22:10] <jnthn> sorear: Will look at it some more tomorrow, anyways...

[22:11] <sorear> we use Nil for not present captures, right?

[22:11] <sorear> jnthn: bootstrap-files, or the Cursor thign?

[22:11] <pmurias> would github releases be suitable for keeping the binary version for bootstraping ? (If we want to avoid bloating the repo) ;)

[22:12] <jnthn> sorear: Well, I need bootstrap-files to verify the Cursor thing is causing the issue I believe it is...

[22:12] <jnthn> sorear: bootstrap-files doesn't look hard to fix, though...

[22:12] <jnthn> Just class/jar confusion.

[22:18] <sorear> jnthn: curious what the cursor thing is.  are you saying you want me to fiddle with bootstrap-files?

[22:19] <jnthn> sorear: No, I can fix it, just too tired to do it today.

[22:19] <jnthn> sorear: The thing is that !cursor_start_all returns an array of things.

[22:20] <jnthn> sorear: And a single, shared, my @start_result; was declared outside of the method.

[22:20] <jnthn> Which is bad for threading, but it turns out that it's bad in another way too

[22:20] <masak> 'night, #perl6

[22:20] <jnthn> Since when a role is serialized, its outer context is serialized, that array too gets serialized...

[22:20] <sorear> reposession eh?

[22:20] <lizmat> night masak!

[22:21] <jnthn> Meaning that we end up trying to repossess it when parsing, when I put the wb into bindpos...

[22:21] <jnthn> But yeah, it clearly would break doing any kind of parsing (of perl 6 or user grammars) on different threads.

[22:23] <jnthn> The problem we're getting showing up in Rakudo is that setting compilation repossesses some meta-objects created in BOOTSTRAP

[22:23] <jnthn> A bunch, if not all, of the "nominal type check failed" errors happen because that isn't getting caught

[22:24] <lizmat> gnight #perl6!

[22:24] <jnthn> So we lose the fact that some classes gained extra roles, for example.

[22:24] <jnthn> 'night, lizmat 

[22:24] <jnthn> augment Hash { } immediately shows it up, by re-generating the type check cache, which is then built out of an incomplete roles list.

[22:24] <jnthn> So yeah, ugh. :)

[22:26] <sorear> Isn't reposession supposed to handle that?

[22:26] <sorear> the setting repossesses the stables

[22:26] <jnthn> Yes, the problem is that repossession isn't being triggered.

[22:26] <jnthn> Or rather, isn't being triggered in all the places it should be.

[22:26] <sorear> the array in NQPCursorRole causes reposession to not be triggered? o_O

[22:27] <jnthn> Currently it's not triggered

[22:27] *** raiph joined
[22:27] <jnthn> When I make it be triggered, we start trying to repossess the array.

[22:27] * sorear is probably keeping jnthn up past his bedtime D:

[22:27] <jnthn> That's when I noticed something was wrong

[22:27] <sorear> jnthn: repossessing the array sounds harmless though

[22:27] <jnthn> Nah, not going to sleep just yet...got an email to answer first... 

[22:27] <sorear> since we currently ignore reposession conflicts

[22:28] <jnthn> Right, but it's rather inefficient...

[22:28] <jnthn> My problem really, though, is not that (afaik). It's that *something* getting repossessed is causing invalid class files to be generated. O.O

[22:29] <jnthn> I didn't get to the bottom of that yet, I just found this issue along the way, and realized it's (a) problematic anyway, and (b) making it harder for me to get to the bottom of the real problem.

[22:30] <sorear> let me guess, it manifests as a "ClassFormatError: you have two methods named qb_22(LCompilationUnit;LThreadContext;LCallSiteDescriptor;[LObject;)V, doofus" ?

[22:30] <jnthn> No.

[22:31] <jnthn> Lemme get it, it's really weird

[22:31] <sorear> oh interesting

[22:31] <sorear> because I've seen the duplicate method ClassFormatError, and decided it was probably related to reposession but didn't investigate further

[22:32] <jnthn> Oh, I haven't figured that out yet, but my gut feeling was that the same QAST::Block is ending up in the tree in two places.

[22:32] <jnthn> hah, here we go

[22:32] <sorear> also a plausible interpretation

[22:32] <jnthn> Exception in thread "main" java.lang.ClassFormatError: Unknown constant tag 100

[22:32] <jnthn> in class file nqp

[22:33] <sorear> WAT

[22:33] <jnthn> It happens when it tries to run the generated NQP from stage 1.

[22:33] <jnthn> Yes, WAT indeed!!

[22:33] <sorear> that's like um

[22:33] <jnthn> Right. :/

[22:33] <sorear> "asm shouldn't even be capable of generating a class with an unparsable constant pool"

[22:34] <sorear> semantically invalid, sure.  but surely all output from ASM should conform to the context-free grammar of a class file

[22:34] <jnthn> Can't even disassemble the thing with javap -c

[22:34] <jnthn> Gives same kinda thing

[22:34] <jnthn> Error:  error while reading constant pool for src\stage1\nqp.class: unexpected t

[22:34] <jnthn> ag at #9552: 100

[22:35] <sorear> If you send me the class or the patch I can poke at it

[22:35] *** FROGGS left
[22:36] <jnthn> sorear: Maybe if I push a branch its' easier than patches?

[22:38] <dalek> nqp/repo-bug: fef0565 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/ (3 files):

[22:38] <dalek> nqp/repo-bug: Get serialized object ownership model in place.

[22:38] <dalek> nqp/repo-bug: 

[22:38] <dalek> nqp/repo-bug: For historical reasons, some things are not handled as direct objects,

[22:38] <dalek> nqp/repo-bug: but rather as special cases in the serializer. This gets support for

[22:38] <dalek> nqp/repo-bug: that handling in place, in hope of using it to resolve some of the

[22:38] <dalek> nqp/repo-bug: remaining serialization/repossession issues.

[22:38] <dalek> nqp/repo-bug: review: https://github.com/perl6/nqp/commit/fef0565793

[22:38] <dalek> nqp/repo-bug: 837aed8 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[22:38] <dalek> nqp/repo-bug: Add missing repossession barriers.

[22:38] <dalek> nqp/repo-bug: 

[22:38] <dalek> nqp/repo-bug: Makes the build explode by generating an invalid class file.

[22:38] <dalek> nqp/repo-bug: review: https://github.com/perl6/nqp/commit/837aed8146

[22:38] <sorear> jnthn: wfm

[22:38] <jnthn> sorear: Just build that branch, it should explode the way I said.

[22:40] <sorear> rep(r)o-bug

[22:40] <sorear> :D

[22:41] *** amoe joined
[22:42] <sorear> Exception in thread "main" java.lang.ClassFormatError: Unknown constant tag 100 in class file nqp

[22:43] * sorear starts poking at nqp.class with hexedit

[22:43] *** ajr_ left
[22:43] *** amoe_ left
[22:43] <jnthn> sorear++

[22:44] <jnthn> This is either gonna be awful or hilarious...

[22:45] <sorear> here's my methodology: bisect the file location of the corruption by introducing garbage and seeing whether javap sees the old error or the new one

[22:46] <jnthn> I dunno if the offset javap gives is of any help?

[22:48] <sorear> What is a string like '$!regexsub'~"\x[08]"~'$_' used for?

[22:51] <jnthn> Um

[22:51] <jnthn> 08? hm

[22:51] * jnthn fails to guess :S

[22:52] <jnthn> At first I wondered if it was the list of lexical names but that wouldn't have a $!foo (attribute) name in it...

[22:53] <sorear> OH

[22:53] *** pmurias left
[22:56] <sorear> jnthn: At the failing offset in nqp.class there is a copy of src/stage1/gen/NQP.nqp as a string constant

[22:57] <sorear> jnthn: it's larger than 65536 bytes, so the length is stored incorrectly and the parser getws confused

[22:57] <jnthn> huh, I thought QAST::SVal was smart about that...

[22:57] <jnthn> Darn, that means we repossessed a cursor somewhere...

[22:58] <jnthn> which is...wtf...

[22:58] <jnthn> oh...

[22:58] <jnthn> @cursor_start will end up containing a cursor, of course!

[22:58] <jnthn> And then when it repossess it...yeah.

[22:59] <jnthn> sorear++

[23:01] *** amoe_ joined
[23:03] *** Guest1337 left
[23:04] *** amoe left
[23:05] *** Guest1337 joined
[23:14] *** Guest1337 left
[23:15] *** Drone[02] left
[23:17] <sorear> jnthn: I'm not sure what's up with strings not being split

[23:17] <sorear> It might be a stage0-specific bug

[23:17] <jnthn> sorear: If stage0 pre-dates the splitting logic, maybe...

[23:17] <jnthn> I've no idea on heir relative ages

[23:17] <jnthn> *hair

[23:17] <jnthn> wtf

[23:17] <jnthn> *their

[23:23] <sorear> jnthn: ooh

[23:23] <sorear> nqp-jvm sorear$ perl -MEncode -CSDL -E 'undef $/; $x=<STDIN>; say ((length Encode::encode_utf8 substr($x,0,65535)) % 65536)' < src/stage1/gen/NQP.nqp

[23:23] <sorear> 34

[23:23] <sorear> the first 65535 *characters* of NQP.nqp produce 0x10022 bytes of utf8-encoded text

[23:24] <sorear> this nicely dovetails with the "00 22" I saw in the classfile

[23:24] <jnthn> sorear: oh...

[23:24] <sorear> (followed by way more than 34 bytes of text)

[23:24] <sorear> seems we're splitting by characters instead of bytes

[23:24] <jnthn> d'oh

[23:24] <sorear> works fine for giant base64 strings though :p

[23:25] <jnthn> I think 'cus I originally did it to cope with the serialization blob, which of ocurse is base64, where they match... :P

[23:25] <jnthn> hah!

[23:25] <jnthn> I'm still rather bemused it produced invalid bytecode file rather than whining about string size...

[23:26] <sorear> I'm slowly coming to expect the worst of asm for error checking

[23:27] <jnthn> I remember an error about string length

[23:27] <jnthn> I'm wondering if it was before the BCEL -> asm switch...

[23:31] <sorear> the quick annd dirty fix is to limit string chunks to 21845 nqp::chars units

[23:31] <jnthn> *nod*

[23:31] <sorear> I wonder if the logic should be pushed down a level or two, to JAST::PushSC or .push_sc

[23:32] <jnthn> Hm, we could actually UTF-8 encode it and check it more carefully...

[23:32] <sorear> because currently we use JAST::PushSC in a lot of places, bypassing the split code entirely...

[23:32] <jnthn> +1

[23:32] <sorear> jnthn: fiddly (and slow! in nqp) logic required to not split in the middle of characters

[23:33] <sorear> maybe not too slow since it would only be checking breakpoints, not every character

[23:33] <jnthn> I meant utf8-encode it in JAST -> bytecode compiler

[23:33] <jnthn> (was agreeing with pushing it down a level)

[23:33] <sorear> people probably shouldn't be using 100kb method names, but we shouldn't generate invalid bytecode for them either :)

[23:33] <sorear> ok.

[23:33] <sorear> I can do that.

[23:33] <sorear> also run/shell stuff

[23:34] <jnthn> OK...going with -D... in the runner for the executable name?

[23:35] <sorear> Yes

[23:35] <jnthn> ok, wfm :)

[23:35] <sorear> probably going to do something crazy like base64 the path so I don't need to think about quoting rules in the shell du jour

[23:36] <jnthn> heh, I'd thought of base64-ing it, then was like, "nooo, sorear will be like, 'jnthn, why u base64 all the things?'" :D

[23:36] <jnthn> .oO( If two people think of it, it's not crazy, right? )

[23:38] <sorear> Mass hallucination?

[23:40] <jnthn> That's what happens when you take drugs in a church...

[23:40] <jnthn> OK, sleep time...

[23:40] <jnthn> Happy hacking

[23:40] <jnthn> o/

[23:50] *** BenGoldberg left
[23:58] <colomon> arnsholt: If the bug had been non-weird, I'd probably have figured it out myself.  ;)

