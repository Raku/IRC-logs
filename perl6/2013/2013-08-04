[00:02] *** sidus left
[00:11] *** arcterus_ left
[00:13] <BenGoldberg> rn: say 1...87

[00:13] <camelia> rakudo 5d9f71, niecza v24-88-g1f87209: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87‚ê§¬ª

[00:13] <BenGoldberg> rn: say 1...88

[00:13] <camelia> niecza v24-88-g1f87209: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88‚ê§¬ª‚Ä¶

[00:13] <camelia> ..rakudo 5d9f71: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88‚ê§¬ª

[00:14] <BenGoldberg> Camelia bug?

[00:14] <timotimo> maybe

[00:14] <geekosaur> someone did an rnp: earlier today and only got the rakudo and niecza responses

[00:15] <BenGoldberg> rnp: say 1...88

[00:15] <camelia> pugs: OUTPUT¬´*** ‚ê§    Unexpected "88"‚ê§    expecting operator, ":", "," or term postfix‚ê§    at /tmp/n8ncdXMzhN line 1, column 9‚ê§¬ª

[00:15] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88‚ê§¬ª‚Ä¶

[00:15] <camelia> ..rakudo 5d9f71: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88‚ê§¬ª

[00:15] <BenGoldberg> rnp: print 1..88

[00:15] <camelia> rakudo 5d9f71, niecza v24-88-g1f87209, pugs: OUTPUT¬´12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788¬ª

[00:15] <BenGoldberg> rnp: print 1..200

[00:15] <camelia> rakudo 5d9f71: OUTPUT¬´1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241‚Ä¶

[00:15] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211‚Ä¶

[00:15] <camelia> ..pugs: OUTPUT¬´1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271‚Ä¶

[00:16] *** xinming left
[00:18] *** xinming joined
[00:22] <BenGoldberg> This might be a bit of an odd idea, but how hard would to be to create a "lazy" hash?

[00:22] <timotimo> quite.

[00:23] <timotimo> if you access a key, you cannot determine if it'll never be there or if you just haven't looked long enough

[00:23] <timotimo> unless the set of keys can be known before

[00:24] <BenGoldberg> Obviously, it wouldn't always be useful :)

[00:25] <BenGoldberg> But, my %h = LazyHash.new(1..Inf); .say for %h.keys; would work 

[00:27] <timotimo> would that give 1 => 2, 3 => 4, 5 => 6, ...?

[00:27] <BenGoldberg> Right

[00:28] <timotimo> that would be easier to solve with an accessor that generates the values on-demand if they're missing from the "backing store" hash

[00:31] *** census joined
[00:33] *** dmol left
[00:45] *** census left
[01:07] *** btyler joined
[01:32] *** coax75ohm joined
[01:39] *** btyler left
[01:40] *** lizmat left
[01:40] *** lizmat joined
[01:45] *** cognominal left
[01:52] *** xinming left
[01:56] *** xinming joined
[02:04] *** raiph left
[02:23] *** PacoAir left
[02:33] *** coax75ohm left
[02:45] *** arcterus joined
[02:50] *** Aww left
[02:51] *** Aww joined
[03:14] *** cognominal joined
[03:17] *** stevan_ left
[03:24] *** stevan_ joined
[03:25] *** stevan_ left
[03:26] *** stevan_ joined
[03:31] *** BenGoldberg left
[03:38] *** mstwu00 left
[03:43] <sorear> good * #perl6

[03:45] *** preflex left
[03:45] *** preflex_ joined
[03:45] *** ChanServ sets mode: +v preflex_

[03:45] *** preflex_ is now known as preflex

[03:52] *** cognominal left
[03:54] *** strider42 joined
[03:57] <labster> o/ sorear

[04:05] <sorear> o/ labster

[04:05] <sorear> how goes

[04:06] <labster> pretty good, busy with $work lately, trying to figure out exactly how to balance my time.

[04:06] <labster> .oO (Another day, another user privilege escalation bug)

[04:08] <sorear> in p6, or in $work?

[04:08] <sorear> what is $work these days?

[04:08] <sorear> last I heard you were looking

[04:09] <labster> perceptyx.com

[04:10] <labster> A lot of legacy Perl code driving their website, which is most of what they do.  Which is employee surveys.  The website is laden with managementspeak, so that might be confusing.

[04:11] <labster> not in p6, RESTRICTED.setting is kind of a joke, we all know it doesn't really stop anything except accidental writes.

[04:11] <sorear> 4?  5.00x?  5.LATEST?  6?

[04:12] <labster> 5.12.4

[04:13] <flussence> .oO( my last job had stuff running on 5.006... )

[04:13] <labster> which is pretty good compared to other places I'd interviewed...

[04:13] <sorear> by 5.00x I meant pre-vstring perls

[04:14] <flussence> I took that to mean "not 5.01x" :)

[04:14] * sorear still isn't quite sure whether 21:06 < labster> .oO (Another day, another user privilege escalation bug)  refers to the known sieveness of RESTRICTED.setting or stuff with perceptyx

[04:14] <sorear> and heya flussence 

[04:14] <labster> No, not in Perl 6.

[04:15] <flussence> I've not been paying enough attention to stuff here lately, did I miss anything exciting?

[04:15] <labster> Does P6 even have a concept of user privilege?

[04:16] <labster> At some point in the future, we ought to consider making RESTRICTED.setting into a proper sandbox, but that seems pretty low priority to me.

[04:20] <flussence> I'd like to see something using libseccomp, but that's a nasty non-portable thing...

[04:27] <dalek> rakudo-star-daily: 459e93b | coke++ | log/ (5 files):

[04:27] <dalek> rakudo-star-daily: today (automated commit)

[04:27] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/459e93b18d

[04:27] <dalek> rakudo-star-daily: a7c24f9 | coke++ | log/ (5 files):

[04:27] <dalek> rakudo-star-daily: today (automated commit)

[04:27] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/a7c24f9976

[04:29] <dalek> perl6-roast-data: ee9c2ab | coke++ | / (5 files):

[04:29] <dalek> perl6-roast-data: today (automated commit)

[04:29] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ee9c2ab5cb

[04:31] *** lizmat left
[04:33] *** lizmat joined
[04:34] <labster> coke++ gaining karma

[04:46] <moritz> \o

[04:48] <sorear> o/ moritz

[04:48] <sorear> flussence: me neither

[05:11] *** mstwu00 joined
[05:12] *** mstwu00 left
[05:14] *** fridim_ left
[05:23] *** lue left
[05:26] *** strider42 left
[05:29] *** kaare_ joined
[05:35] *** lue joined
[05:49] *** FROGGS joined
[05:54] *** FROGGS left
[06:00] *** FROGGS joined
[06:01] *** ilbot_nextgen joined
[06:02] * moritz idly wonders why pressing the home key in the browser usually doesn't bring me to the top of the document

[06:03] <moritz> given the name, it should take me ~ :-)

[06:04] <moritz> .oO( take me ~, country road )

[06:07] *** FROGGS left
[06:13] <diakopter> moritz: 0_0

[06:13] <diakopter> ... "west virginia..."

[06:14] <diakopter> decommunistize & bbiab

[06:26] *** arcterus left
[06:28] *** arcterus joined
[06:31] *** crab2313 joined
[06:56] *** ilbot_nextgen left
[07:01] *** ecocode joined
[07:05] *** ecocode left
[07:08] *** FROGGS joined
[07:28] *** FROGGS left
[07:58] *** moritz is now known as moritz_

[07:58] *** moritz_ is now known as moritz

[08:08] *** Guest87971 is now known as ponbiki

[08:41] *** arcterus left
[08:42] *** dmol joined
[08:53] <masak> mornin', #perl6

[08:57] *** sidus joined
[09:01] <moritz> \o masak 

[09:17] * masak reviews t3 solutions

[09:17] <moritz> \o/

[09:26] *** FROGGS[mobile] joined
[09:32] <jnthn> morning, all

[09:32] <moritz> \o jnthn 

[09:33] <nwc10> [A

[09:36] * jnthn tries to parse nwc10's greeting as some kind of drawing

[09:36] <nwc10> it's coincidence. And irssi being a bit daft

[09:37] <nwc10> in that, if the characters ESC, [ and A arrive with the wrong timing, it *doesn't* interpret them as cursor up

[09:40] <masak> wow, my guess was "cursor up"!

[09:40] <masak> clearly I've spent too much time with computers.

[09:45] *** spider-mario joined
[09:55] *** rindolf joined
[09:56] <jnthn> Well, the [ coulda been "on the phone"... :)

[09:59] <masak> jnthn: http://knowyourmeme.com/memes/sidetalking-n-gage :)

[10:06] <FROGGS[mobile]> I get a 503

[10:09] *** arcterus joined
[10:17] *** arcterus left
[10:21] *** ecocode joined
[10:21] <jnthn> https://github.com/rakudo/rakudo/commit/296da02886c011114b43eb49e5eb0cc482003201 # looks odd, the $?FILE and $?LINE refer to the setting, not current compile position..

[10:29] *** iSlug joined
[10:40] <jnthn> Hm, it seems at some point some change hurt the optimizer's ability to inline stuff, even on Parrot.

[11:08] *** BenGoldberg joined
[11:10] *** arcterus joined
[11:14] *** arcterus left
[11:14] <FROGGS[mobile]> jnthn: how do you see that?

[11:15] <jnthn> FROGGS[mobile]: Looking at the AST from --target=optimize

[11:15] <jnthn> Though I've hunted it down some more now

[11:15] <jnthn> I was wondering why infix:<+> doesn't get inlined

[11:15] <jnthn> Turns out its proto is:

[11:15] <jnthn> proto infix:<+>($a?, $b?) is pure   { * }

[11:16] <jnthn> And the compile time bind analysis doesn't know what to do with optionals.

[11:29] <jnthn> FROGGS[mobile]: Why was 1541771 in nqp needed?

[11:29] *** kaare_ left
[11:31] *** iSlug left
[11:33] *** rindolf left
[11:49] *** pmurias joined
[11:50] <pmurias> jnthn: while compiling QAST, if I encounter a QAST::Block how should I determine if I should generate the block or if the block is only refered to?

[11:51] *** FROGGS[mobile] left
[11:52] <pmurias> jnthn: like if it's mentioned in nqp::setcodeobj it's only used as a reference

[11:53] <jnthn> pmurias: References are always through a QAST::BVal

[11:53] <jnthn> The QAST::Block should really only appear in the tree once.

[11:54] <jnthn> uh, aside from any QAST::BVal references.

[11:54] <jnthn> And those shouldn't compile the block, just refer to it

[11:55] <pmurias> jnthn: so a QAST::BVal always should refer to the block?

[11:56] <jnthn> pmurias: Yes

[11:56] <jnthn> pmurias: Anything mentioned inside a QAST::BVal should appear somewhere else in the tree 

[11:57] <pmurias> thanks

[11:59] <dalek> rakudo/nom: a04ebf2 | jnthn++ | src/Perl6/Optimizer.nqp:

[11:59] <dalek> rakudo/nom: Some optimizer code cleanups, commenting.

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a04ebf2bf4

[11:59] <dalek> rakudo/nom: c2ef115 | jnthn++ | src/vm/parrot/guts/bind.c:

[11:59] <dalek> rakudo/nom: Compile-time analysis of sigs with opt params.

[11:59] <dalek> rakudo/nom: 

[11:59] <dalek> rakudo/nom: This means the optimizer doesn't trip up on protos like ($a?, $b?),

[11:59] <dalek> rakudo/nom: meaning we can inline +, < and so forth for natives again.

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2ef115875

[12:00] <colomon> oh, lizmat++ will be happy

[12:01] <colomon> jnthn++ # back at it

[12:02] <dalek> roast: 585d3d9 | jnthn++ | S02-types/nil.t:

[12:02] <dalek> roast: todo => skip, due to stricter compile time checks.

[12:02] <dalek> roast: review: https://github.com/perl6/roast/commit/585d3d9456

[12:02] <dalek> roast: 6f39558 | jnthn++ | S32-io/IO-Socket-INET.bat:

[12:02] <dalek> roast: Make socket tests run less annoyingly on Win32.

[12:02] <dalek> roast: 

[12:02] <dalek> roast: They could pop up windows before; this prevents it.

[12:02] <dalek> roast: review: https://github.com/perl6/roast/commit/6f3955815d

[12:02] <jnthn> I broke her streak? :)

[12:07] *** dmol left
[12:41] <timotimo> i thought more about optimizing perl6 last night and the massive dynamicism that can take place is kind of frustrating. a type restriction on "Foo" hardly means a thing when you can freely derive from Foo after the optimizer had a chance to do things, so even if we have a "link-time" optimization in place, it still can't look at the whole program and say "this Foo class here is never derived anywhere", because what if MOP?

[12:41] <timotimo> sigh. i know so pitifully little about optimising :|

[12:49] <masak> timotimo: it's much easier to optimize at the "lexical lookup" end of things, rather than the OO/MOP end.

[12:50] <jnthn> Well, also keep in mind that a 6model-aware JIT will be able to have some fun too

[12:51] <timotimo> yeah, this is probably JIT territory

[12:51] *** rindolf joined
[12:52] <timotimo> speaking of OO/MOP ... recently i mused about an optimization that could perhaps turn the creation of "super simple" objects into a super fast low-level op, so that creating an object without custom BUILD or new would be just as simple as creating a parcel or hash or something; someone mentioned that Cursor (even in nqp) could benefit from that, because cursors keep being created and destroyed all over the place. thoughts?

[12:52] <jnthn> We already did customize Cursor creation quite a bit

[12:53] <timotimo> ah, that's good then

[12:53] <timotimo> although every optimization that i think of that then gets shot down as "already done" makes me a tiny bit sad, too. as in "aaw, we can't make that any faster this way? :("

[12:56] *** xinming left
[12:58] *** xinming joined
[12:59] *** pupoque_ is now known as euge

[13:06] *** euge is now known as eugene

[13:06] *** eugene is now known as eugenius

[13:06] *** eugenius is now known as eugeniuss

[13:06] *** eugeniuss left
[13:12] * lizmat does a git pull and does not see "branch nom is up to date" :-)

[13:14] <jnthn> lizmat: Figured you'd done enough streaking :)

[13:14] <lizmat> jnthn++

[13:15] <lizmat> I wouldn't have minded so much if I hadn't been blocking on so many things

[13:16] <lizmat> jnthn: if you have time, I'd like your ear on a couple of things

[13:16] <jnthn> lizmat: Sure.

[13:16] <jnthn> I'm not yet really caught up on all that happend while I was gone, besides reading the GlitchMr++ post :)

[13:17] <lizmat> adding the $.slash attribute in Variable, and passing $/ from nqp into it, how bad is that ?

[13:17] <lizmat> I needed it to be able to get proper compile time errors

[13:17] *** coax75ohm joined
[13:17] <jnthn> Sounds odd

[13:18] <lizmat> is there another way of getting at $/ in Variable, so I can use it to throw compile time exceptions properly ?

[13:18] <jnthn> The proper way is to:

[13:18] <lizmat>     submethod throw ( |c ) { $*W.throw( self.slash, |c )}

[13:18] <jnthn> 1) Have the exception type do X::Comp

[13:19] <lizmat> check

[13:19] <jnthn> oh, hm :)

[13:19] * jnthn sees what lizmat means...

[13:19] *** gesh joined
[13:20] <jnthn> hmm

[13:20] <jnthn> Do we do treat applications through $*W.apply_trait?

[13:20] <jnthn> 'cus it does it through ex-handle

[13:20] <jnthn> That in turn goes through rethrow method in world, which fills in the file and line

[13:21] <jnthn> That's the "right way" to do it

[13:21] <jnthn> And means $/ doesn't need to be passed

[13:21] <jnthn> (into the Variable object)

[13:21] <lizmat> it is currently in Actions.declare_variable

[13:22] <lizmat> *not* through apply_trait

[13:22] *** gesh left
[13:25] * lizmat tries to adapt code to use apply_trait

[13:25] <jnthn> yeah, but wait

[13:25] <jnthn> where does the $applier come from?

[13:26] <lizmat> traitlist -> $_.ast

[13:26] <jnthn> Right, which is a closure that does invoke the thing through apply_trait

[13:26] <lizmat> /

[13:27] <jnthn> will is doing it also

[13:27] <jnthn> 3664 or so

[13:27] <lizmat> well, perhaps, I don't see that, but in either way, without my hack, it wouldn't show the line in which the error occurred

[13:28] <lizmat> which raises one other point: exceptions thrown from trait_mod will, are not rrethrown

[13:29] <jnthn> oh?

[13:29] <jnthn> That's very odd

[13:29] <lizmat> frustrating as hell more like it  :-)

[13:29] <jnthn> Given it looks like it *should* be working 

[13:29] <jnthn> Heck, it even tries to mix in X::Comp

[13:29] <lizmat> well, I'll give it another go

[13:30] <jnthn> Which exception type, btw?

[13:31] <ruoso> Hmmm... The fact that ThreadContext pre-initializes a few exceptions make debugging slightly harder, because the stack trace will point to the stack that created the exception, not the point that threw it...

[13:31] <lizmat> X::Comp::NYI

[13:31] * ruoso trying to fix t/spec/S04-statements/loop.t

[13:32] <benabik> Did the advent calendar start really early this year?  *stares at Planet Perl Six*

[13:32] <jnthn> ruoso: Yeah, not doing that gets insanely costly

[13:32] * lizmat wonders what's wrong with loop.t

[13:33] <ruoso> gather/take seem to be broken

[13:33] <jnthn> Oh, is it the same failure mode as the failing gather/take tests?

[13:33] <benabik> Huh.  Showed up in my feed reader, but it's not on the page.  Strange.

[13:33] * lizmat is doing the first build of the day and hasn't seen any problems yet

[13:33] <jnthn> lizmat: Failure is on JVM

[13:34] <ruoso> jnthn: yep

[13:38] *** dmol joined
[13:39] <lizmat> jnthn: it does throw again from within the trait_mod spec

[13:39] <jnthn> Hm. I got the trail bind stuff ported to JVM. It seems to work, it choses the candidate at compile time, but seems unwilling to inline. Oddness...

[13:39] <lizmat> $ perl6 -e 'my $a will init { say "Hello" }'

[13:39] <lizmat> ===SORRY!===

[13:39] <lizmat> Variable trait "will init {...}" not yet implemented. Sorry. 

[13:39] <lizmat> at -e:1

[13:39] <lizmat> ------> 

[13:40] <jnthn> lizmat: That has a line number, no?

[13:40] <lizmat> yes, but want more:

[13:40] <lizmat> $ perl6 -e 'my $a is foo'

[13:40] <lizmat> ===SORRY!===

[13:40] <lizmat> Can't use unknown trait 'is foo' in a variable declaration.

[13:40] <lizmat> at -e:1

[13:40] <lizmat> ------> my $a is foo‚èè<EOL>

[13:40] <lizmat>     expecting any of:

[13:40] <lizmat>         TypeObject

[13:40] <lizmat>         default

[13:40] <lizmat>         dynamic

[13:41] <jnthn> The expecting any of comes through highexpect though... :)

[13:41] <lizmat> the part after the ------> is only possibly if I have $/

[13:41] <jnthn> That sounds fixable.

[13:41] <lizmat> it's about "my $a is foo‚èè<EOL>"

[13:41] <jnthn> Yeah, that bit we should be able to manage

[13:41] <jnthn> SET_FILE_LINE should also learn to take the stuff to put in the ---> line I guess

[13:42] <jnthn> lizmat: See method locprepost

[13:42] <lizmat> looking

[13:44] *** xinming left
[13:46] *** xinming joined
[13:47] *** dmol1 joined
[13:47] *** dmol left
[13:52] <jnthn> oh...I know why it won't inline...

[13:54] *** telex left
[13:56] *** telex joined
[13:57] <jnthn> nqp: sub foo(:$a) { say($a) }; foo(:!a)

[13:57] <camelia> nqp: OUTPUT¬´0‚ê§¬ª

[14:08] <moritz> and named params don't inline?

[14:11] <jnthn> moritz: Correct, but there I was just checking if NQP supports :!a syntax :)

[14:12] <jnthn> yay, think I've got it to do it

[14:19] *** birdwindupbird joined
[14:20] *** leont joined
[14:33] <lizmat> jnthn: trying to remove Variable.slash as a first step

[14:34] <lizmat> but it appears I also need that for registering global phasers, such as CHECK, INIT, END

[14:34] <lizmat> suggestions?

[14:35] <lizmat> currently: $*W.add_phaser($v.slash, 'CHECK', $block)

[14:37] *** Psyche^_ joined
[14:38] <jnthn> Doing stuff with $*W in trait mods sounds...odd

[14:38] <jnthn> What on earth does "will check" even mean?

[14:39] <jnthn> I mean, what's it operating on...

[14:39] <lizmat> it's basically a CHECK block, with $_ as the variable on which it is defined

[14:39] <jnthn> yeah. hm.

[14:39] *** FROGGS joined
[14:41] *** Psyche^ left
[14:41] <lizmat> jnthn: there are only 2 add_phaser methods, one on Block, and on in WOrld

[14:42] <FROGGS> jnthn: re https://github.com/perl6/nqp/commit/1541771 - it always returned 'obj', even when it was not... so I made it behave like nqp@JVM

[14:42] <lizmat> CHECK INIT END clesrly do not belong on the block

[14:42] * FROGGS .oO( Y U SCREAM? )

[14:42] <lizmat> and fwiw, my hack with Variable.slash mate CHECK work

[14:43] <lizmat> *made

[14:43] <jnthn> FROGGS: Hm, I don't see why it always did that, is all...

[14:45] *** crab2313 left
[14:45] <FROGGS> jnthn: well, before it checked whether var->vtable->base_type is smo_id, and returned zero otherwise ( == obj)

[14:46] <FROGGS> and since there are other base types, these need to be checked

[14:46] <jnthn> well, we can try to pretend Parrot things are native types, but it's probably not a good idea.

[14:47] <FROGGS> hmmm

[14:48] <FROGGS> jnthn: should I revert it?

[14:49] <jnthn> oh, actually, that wasn't what really bothered me

[14:49] <jnthn> This is

[14:49] <jnthn> -        $1 = ss.inlineable ? ss.boxed_primitive : STORAGE_SPEC_BP_NONE;

[14:49] <jnthn> +        $1 = ss.boxed_primitive;

[14:50] <jnthn> It's completely legit for boxed_primtive to contain complete junk if inlineable is false.

[14:50] <FROGGS> ahh, okay

[14:50] <jnthn> I'm not sure if anything tries to get away wiht that, but it's entirely possible.

[14:53] <jnthn> oh wow...JVM port just caught a bug that probably leads to reading random memory on Parrot.

[14:53] <FROGGS> O.o

[14:53] <jnthn> (in a strange edge-case involving return type checks and inlining)

[14:54] <masak> r: my @a = [1,2,3], [4,5,6], [7,8,9]; say ([Z,] @a).perl

[14:54] <camelia> rakudo c2ef11: OUTPUT¬´((1, 4, 7), (2, 5, 8), (3, 6, 9)).list‚ê§¬ª

[14:54] <masak> is there a way to "harden" those lists into arrays?

[14:54] <masak> r: my @a = [1,2,3], [4,5,6], [7,8,9]; say ([Z,] @a).tree.perl

[14:54] <camelia> rakudo c2ef11: OUTPUT¬´([1, 4, 7], [2, 5, 8], [3, 6, 9]).list‚ê§¬ª

[14:54] <masak> ah.

[15:03] *** crab2313 joined
[15:04] *** grondilu joined
[15:05] <grondilu> rn: my @a = 1 .. 5; say @a[0,2...*]

[15:05] <camelia> niecza v24-88-g1f87209: OUTPUT¬´(timeout)¬ª

[15:05] <camelia> ..rakudo c2ef11: OUTPUT¬´1 3 5‚ê§¬ª

[15:07] <grondilu> I used ^this in http://rosettacode.org/wiki/Fast_Fourier_transform#Perl_6 but I'm afraid Niecza is right here:  we can't use a infinite list as subscript range and expect a finite output, can we?

[15:07] <moritz> we can expect a lot of things to happen :-)

[15:08] <moritz> but yes, that's a place where rakudo's array indexing breaks the Liskov substitution principle

[15:08] <moritz> (Array is a subclass of List, and List truncates at the end, but Array doesn't)

[15:17] *** ecocode` joined
[15:19] *** benabik left
[15:19] <lizmat> Q: is there a way to "connect" an array lazily to the return value of a method ?

[15:20] <lizmat> *inside* the method ?

[15:20] <tadzik> connect?

[15:20] <lizmat> well, I have a lazy map {} pushing to an array

[15:20] <lizmat> the array should be returned lazily

[15:21] *** ecocode left
[15:21] <lizmat> if I just say "return @array" it would be eager, no?

[15:21] <jnthn> Where is the lazy map?

[15:22] <lizmat> inside the method (trying for a naive implementation of uniq(:with)

[15:22] *** ecocode` left
[15:22] <jnthn> pushing sounds odd

[15:23] <jnthn> gather/take sounds more appropriate.

[15:23] <masak> lizmat: just return a gather?

[15:23] <jnthn> Or just a straight map

[15:23] <lizmat> straight map it is then

[15:23] <masak> yeah, even a straight map'd work.

[15:23] <masak> but it'd likely have side effects :)

[15:23] <jnthn> only do gather/take when a map can't work, fwiw. :)

[15:23] <jnthn> (mapiter is cheaper)

[15:24] *** benabik joined
[15:24] <masak> indeed.

[15:24] *** cognominal joined
[15:24] <masak> and even perf considerations aside, gather/take is the heavyweight and map is easier on the eye.

[15:25] <jnthn> aye

[15:25] <benabik> The PicoLisp "implementation" of FFT is just calling libfftw3?

[15:26] *** PacoLinux joined
[15:28] <diakopter> what exactly about gather/take makes it slow

[15:28] <dalek> nqp: 8e8ae36 | (Tobias Leich)++ | src/vm/parrot/QAST/Compiler.nqp:

[15:28] <dalek> nqp: we cant trust boxed_primitive when inlinable is false, jnthn++

[15:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8e8ae369ad

[15:29] <jnthn> diakopter: The fact that under the hood it's a coroutine/continuation, whereas a straight map only needs closures.

[15:29] <diakopter> right, but why is that slower

[15:30] <diakopter> on parrot I mean

[15:30] <diakopter> clearly it could be slower on jvm b/c of the stack saving/restoring

[15:31] *** leont left
[15:31] * masak has some fun running the t3 submissions against various inputs

[15:32] *** mtk left
[15:32] * jnthn wonders if masak ran any of them on Rakudo JVM :)

[15:35] *** mtk joined
[15:39] <masak> ooh, no I didn't :)

[15:39] <masak> but that's a fine idea.

[15:52] <lizmat> .oO( oh how I *hate* it when something works, but not in the CORE.setting )

[15:57] * moritz hopes masak++ doesn't find input where his t3 submission recurses infinitely

[16:03] <masak> moritz: why, are you aware of such input? :>

[16:04] <masak> moritz: one contestant actually does recurse infinitely... :/

[16:05] <moritz> masak: no, but before I got the algorithm into its current form, it would loop all the time

[16:05] <moritz> it felt very haskellish: either infinite loop, or correct :-)

[16:06] <masak> heh.

[16:06] *** FROGGS left
[16:07] <moritz> go++ # not whining when I include trailing newlines

[16:07] *** FROGGS joined
[16:10] *** arcterus joined
[16:11] <lizmat> masak: wondering about .uniq: maybe it would be handier if you could specify a :normalize parameter, possibly as well

[16:12] <masak> lizmat: I was thinking about that yesterday too.

[16:12] <masak> lizmat: in some sense it feels right, in another sense it feels like adding that one bell-and-whistle too many.

[16:12] <jnthn> Why is it not :by?

[16:13] <lizmat> instead of :normalize ?

[16:13] <lizmat> good point, :by makes sense

[16:13] <moritz> fwiw there's nothing wrong with giving uniq a transformation function

[16:13] <moritz> but I don't think we should give it a comparison function

[16:14] <moritz> because that would make the algorithm O(n¬≤), when somebody with knowledge of the comparison function might do much better

[16:14] <moritz> and I don't think the setting should contain such "surprisingly" slow methods

[16:15] <masak> moritz: you mean the comparison function I spec'd yesterday?

[16:15] *** arcterus left
[16:15] <moritz> masak: correct

[16:15] <masak> yes, we can revert it.

[16:15] <masak> and I think your argument carries some weight.

[16:15] <lizmat> so :by it is going to be ?

[16:16] <masak> though the fact remains that I *did* have a need for :with(&[eqv])

[16:16] <masak> even though it's slow.

[16:16] <lizmat> why not have both ?

[16:16] <moritz> masak: you should get that with :as(*.perl), no?

[16:16] <masak> though, hm, a :by transformation function would have been enough in that case.

[16:16] <masak> moritz: yes, just realized.

[16:16] <lizmat> :as ??

[16:16] <masak> moritz: as long as .perl promises to be canonical enough.

[16:17] <moritz> lizmat: I'd name the transformation function :as

[16:17] <masak> lizmat: transformation function.

[16:17] <moritz> because :by still sounds like comparison

[16:17] <lizmat> ah, ok

[16:17] <masak> I'm now 100% with moritz. we should unspec :with and spec :as.

[16:17] <masak> and always do === semantics.

[16:17] <lizmat> ok, then I'll ditch my :with implementation

[16:17] <masak> I'll reverse the spec and write some new one.

[16:18] * moritz feels bad for lizmat, who recently has implemented several things only to have them reverted/removed in the specs

[16:18] <lizmat> that's life, and it's also about the travel, not just about the goal

[16:19] <moritz> wise words

[16:20] <dalek> specs: f6aa7f8 | masak++ | S32-setting-library/Containers.pod:

[16:20] <dalek> specs: Revert "[S32/Containers] specify :with for .uniq/.squish"

[16:20] <dalek> specs: 

[16:20] <dalek> specs: This reverts commit ec1b7c619dec5b6d7b779c97bfefc4e2285e72f6.

[16:20] <dalek> specs: 

[16:20] <dalek> specs: Conflicts:

[16:20] <dalek> specs: 	S32-setting-library/Containers.pod

[16:20] <dalek> specs: review: https://github.com/perl6/specs/commit/f6aa7f8cb9

[16:21] <masak> conflicts because of some improvements that snuck in after the reverted commit :)

[16:24] *** PacoLinux left
[16:26] <dalek> rakudo/nom: fe0813a | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/ (2 files):

[16:26] <dalek> rakudo/nom: Implement compile time bind analysis on JVM.

[16:26] <dalek> rakudo/nom: 

[16:26] <dalek> rakudo/nom: Gets compile time multiple dispatch analysis working. For some reason,

[16:26] <dalek> rakudo/nom: inlining doesn't happen yet, though.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe0813a201

[16:26] <masak> does .perl guarantee that hash keys are ordered?

[16:26] <moritz> I don't think so

[16:27] <masak> dang, then .perl is not a good supplement for infix:<eqv>

[16:27] <moritz> but that's about the only case where it's not

[16:27] <masak> rn: say [{ :a(1), :b(2) }, { :b(2), :a(1) }].perl

[16:27] <moritz> maybe we should simply make Hash.perl order the keys, and be don with it

[16:27] <camelia> rakudo c2ef11: OUTPUT¬´[{"a" => 1, "b" => 2}, {"b" => 2, "a" => 1}]‚ê§¬ª

[16:27] <camelia> ..niecza v24-88-g1f87209: OUTPUT¬´[{"a" => 1, "b" => 2}, {"a" => 1, "b" => 2}]‚ê§¬ª

[16:27] <masak> rn: say [{ :a(1), :b(2) }, { :b(2), :a(1) }].gist

[16:27] <camelia> niecza v24-88-g1f87209: OUTPUT¬´{"a" => 1, "b" => 2} {"a" => 1, "b" => 2}‚ê§¬ª

[16:27] <camelia> ..rakudo c2ef11: OUTPUT¬´("a" => 1, "b" => 2).hash ("b" => 2, "a" => 1).hash‚ê§¬ª

[16:27] <masak> moritz: I think so.

[16:28] <masak> moritz: though it does feel "extra" compared to the original roundtripping criterion.

[16:29] <timotimo> jnthn: is there any speed improvement to compile-time bind analysis if there's no inlining?

[16:30] <moritz> the bind checks can be skipped at runtime?

[16:31] <jnthn> For multi dispatch, it can choose the candidate at compile time

[16:31] <jnthn> And then just index into the candidates list, rather than hitting the dispatch cache or, worse, the dispatcher itself

[16:32] <timotimo> ah, good

[16:33] <timotimo> want me to run the benchmarks?

[16:33] <jnthn> Well, I'm still working on the inlining bit. I got it all happy on JVM

[16:33] <jnthn> Then an on-the-side cleanup I needed to do is somehow breaking setting building on Parrot

[16:34] <timotimo> righto, i'll wait for that then :)

[16:34] <moritz> Ronja just plays "eating icecream" with some color pens. But she doesn't quite get the predending part yet, so the pens leave colorful traces in her face :-)

[16:36] <timotimo> hooray for nontoxic pens!

[16:37] <masak> I have a patch for :as, but I'm kind of put off by the fact that we don't have a replacement for the infix:<eqv> use case.

[16:38] <lizmat> so maybe we still need both?

[16:38] <moritz> masak: that's because some other bits and pieces are missing, not because .uniq(:as) is somehow flawed

[16:39] <moritz> masak: nobody yet relies on .uniq(:with), so you aren't breaking anybody's code

[16:40] <lizmat> except for some spectests  :-)

[16:41] <moritz> :-)

[16:41] <masak> moritz: yes, but I started out with a real-world use case, and right now we don't have a good answer to it.

[16:41] <masak> moritz: I can also see :as being part of that answer; I'm just missing the other part.

[16:43] <FROGGS> jnthn: I've played with parrot's thread while you had fun without us... https://gist.github.com/FROGGS/0cfae647d28c493df73e

[16:43] <FROGGS> jnthn: I just wonder why the add-i-mt.t script uses my cpus so well while the other does not

[16:44] <FROGGS> I asked in #parrot, but, well... I guess it might be better to append my questions to an existing issue...

[16:45] <FROGGS> jnthn: have an idea about something I should try?

[16:45] <jnthn> FROGGS: Gotta run for a train now...ask me again later :)

[16:45] <jnthn> &

[16:45] <moritz> masak: so, what kind of data structures are you uniq()ing?

[16:45] <FROGGS> I guess the gazillion small tasks, are waiting for the main thread b/c they access lexicals

[16:45] <FROGGS> jnthn: sure :o)

[16:46] *** jaldhar left
[16:48] <dalek> specs: c313c29 | masak++ | S32-setting-library/Containers.pod:

[16:48] <dalek> specs: [S32/Containers] spec :as for uniq/squish

[16:48] <dalek> specs: review: https://github.com/perl6/specs/commit/c313c2918e

[16:48] <masak> moritz: in my real-world use case? oh, just an array of hashes of simple values.

[16:49] <moritz> masak++ # specs commit

[16:53] <dalek> rakudo/nom: 59e521e | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[16:53] <dalek> rakudo/nom: Make List.(uniq|squish) up to spec

[16:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59e521ecb2

[16:53] <lizmat> 5 mins between spec and implementation change, a new record ?

[16:55] <moritz> lizmat: we've had stuff that has first been implemented, and then specced :-)

[16:56] <masak> depends if negative times count... right :)

[16:56] <masak> &

[16:56] <lizmat> negative times don't count

[16:56] <lizmat> :-)

[16:57] *** celesta joined
[16:57] <celesta> ahoi #perl6

[16:58] <lizmat> ahoi celesta!

[17:00] <dalek> roast: 70ed9dc | (Elizabeth Mattijsen)++ | S32-list/squish.t:

[17:00] <dalek> roast: Spectests for List.squish adapted to new :as functionality

[17:00] <dalek> roast: review: https://github.com/perl6/roast/commit/70ed9dc5e3

[17:02] *** jaldhar joined
[17:04] <dalek> roast: 3dd1995 | (Elizabeth Mattijsen)++ | S32-list/ (2 files):

[17:04] <dalek> roast: Add tests for List.uniq(:as)

[17:04] <dalek> roast: review: https://github.com/perl6/roast/commit/3dd1995a97

[17:05] <lizmat> $ perl6 -e 'say <a bb aa ccc b dd>.uniq( :as({substr($^a,0,1)} ) )'

[17:05] <lizmat> a bb ccc dd

[17:06] <lizmat> too bad you can't specify that as :as( substr *,0,1 )

[17:06] <moritz> lizmat++

[17:06] <moritz> lizmat: *.substr: 0, 1

[17:06] <lizmat> ah, duh

[17:10] <dalek> roast: f22dd02 | (Elizabeth Mattijsen)++ | S32-list/ (2 files):

[17:10] <dalek> roast: Simplify :as specification, suggested by moritz++

[17:10] <dalek> roast: review: https://github.com/perl6/roast/commit/f22dd02aaa

[17:11] <lizmat> cycling&

[17:11] *** ggoebel left
[17:13] *** dmol1 left
[17:13] *** dmol joined
[17:14] <lizmat> moritz: about using *.perl, apart from it not working currently because .perl is not doing the right thing everywhere

[17:14] <lizmat> is that for each comparison, the complete ..perl string would need to be buiilt

[17:15] <lizmat> whereas with <eqv>, it could very early fail without having to traverse the whole structure being checked

[17:15] *** birdwindupbird left
[17:16] <lizmat> for big structures, I guess wouldn't make O(n¬≤) so bad

[17:16] <lizmat> especially since .perl at the moment is already *really* slow

[17:17] <moritz> lizmat: good point that I hadn't considered so far

[17:18] <lizmat> so I guess a case could be made for both

[17:20] * moritz wonders which version of rakudo he should use when he needs nativecall

[17:21] <moritz> 2013.06 should be fine, right

[17:23] <arnsholt> I think latest monthly should be ok

[17:28] <timotimo> r: say "foo bar" ~~ / ' ' <?before <alpha>>/

[17:28] <camelia> rakudo 59e521: OUTPUT¬´ÔΩ¢ ÔΩ£‚ê§‚ê§¬ª

[17:28] <timotimo> r: say "foo bar" ~~ / ' ' <?before <foo=alpha>>/

[17:28] <camelia> rakudo 59e521: OUTPUT¬´ÔΩ¢ ÔΩ£‚ê§‚ê§¬ª

[17:28] <timotimo> interesting

[17:49] *** imarcusthis- joined
[17:50] * ruoso trying to find himself in debugging the rakudo jvm runtime... the gather/take problem seems to be caused by the control exception placed by "take" not being caught properly... 

[17:55] *** Rotwang joined
[17:56] <ruoso> Aha! the problem is when there is no explicit block, then the gather is not creating a block for the code to be invoked...

[17:58] *** sqirrel joined
[18:01] *** rindolf left
[18:08] *** sidus left
[18:09] *** colomon left
[18:10] <ruoso> Actually, that's not it... the problem in that test is with the "last".

[18:19] *** jaldhar left
[18:30] <ruoso> r: say gather for loop { take 1; last };

[18:30] <camelia> rakudo 59e521: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/YsYWgDkVdF:1‚ê§------> [32msay gather for loop { take 1; last }[33m‚èè[31m;[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifi‚Ä¶

[18:30] <ruoso> r: say gather loop { take 1; last };

[18:30] <camelia> rakudo 59e521: OUTPUT¬´1‚ê§¬ª

[18:43] *** coax75ohm left
[18:54] <dalek> rakudo-star-daily: 0faf9ba | coke++ | log/ (5 files):

[18:54] <dalek> rakudo-star-daily: today (automated commit)

[18:54] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/0faf9ba7a1

[19:10] *** sqirrel left
[19:10] * [Coke] hurls http://www.darthsanddroids.net/episodes/0918.html for the harry potter fans.

[19:19] <timotimo> D&D is pretty excellent.

[19:19] <timotimo> this one, i mean

[19:20] *** iSlug joined
[19:25] <timotimo> hm, having slurpy LoL was the blocker for turning ~ into a list precedence operator, yes?

[19:25] *** Rotwang left
[19:29] *** iSlug left
[19:39] *** Rotwang joined
[19:43] <timotimo> either implementing ~ properly or turning interpolation into calls with join("") would give a decent speed boost i think

[19:44] *** Bzek left
[19:45] <diakopter> it's worth trying

[19:46] <timotimo> hm, my current implementation of trim_heredoc relies on infix:<~> calls

[19:50] <sorear> o/

[19:50] <diakopter> sorear: howdy :) how goes?

[19:57] <sorear> busy

[20:09] *** grondilu left
[20:11] *** bluescreen10 joined
[20:21] *** jaldhar joined
[20:22] *** jaldhar left
[20:22] *** BenGoldberg left
[20:22] *** jaldhar joined
[20:24] *** fridim_ joined
[20:30] <arnsholt> [Coke]: Oh, that was mean. I'd forgotten about that webcomic

[20:31] <arnsholt> Now I've got lots and lots of catching up to do =)

[20:37] *** Rotwang left
[20:43] *** arcterus joined
[20:45] *** colomon joined
[20:59] *** bruges_ joined
[21:00] *** bruges left
[21:05] *** crab2313 left
[21:05] *** crab2313 joined
[21:08] *** Ulti left
[21:08] <pmurias> timotimo: it's possible to close classes so the optimizer can know more

[21:09] *** Ulti joined
[21:09] *** leont joined
[21:09] <timotimo> pmurias: like "is closed"?

[21:10] <pmurias> use oo :closed;

[21:10] <lizmat> I thought all classes were closed unless use MONKEY_TYPING was seen ?

[21:11] *** crab2313 left
[21:11] <pmurias> assuming I don't have an old version of the spec the default is open and non-final

[21:12] <lizmat> spec is not necessarily equal to the implementation  :-)

[21:12] <lizmat> moritz, masak, jnthn, TimToady would be able to tell you for sure, but I guess they're all away

[21:12] <pmurias> currently we don't do much optimalisation

[21:13] * ruoso still kind of lost on how to debug rakudo on the jvm

[21:13] <colomon> ruoso: "say" is your friend.  ;)

[21:14] <pmurias> lizmat: https://github.com/perl6/specs/blob/master/S12-objects.pod#closed-classes

[21:14] *** grondilu joined
[21:14] <ruoso> colomon: heh... I don't mean debugging perl code in rakudo, I mean debugging rakudo itself

[21:15] <pmurias> lizmat: so according to spec they are open and non-final by default, but it's possible to change the default for the whole up with 'use oo :final,:closed;'

[21:15] <colomon> ruoso: then say is all the more necessary.  ;)

[21:15] <ruoso> colomon: fair enough... I guess I just need a better understanding on the transition between rakudo, nqp and jvm

[21:16] <lizmat> pmurias: $ perl6 -e 'use oo :final,:closed'

[21:16] <lizmat> ===SORRY!===

[21:16] <lizmat> Could not find oo in any of: 

[21:16] <lizmat> so, NYI

[21:16] <diakopter> pmurias: where in the spec is that

[21:16] <colomon> it's simple: if you're in rakudo, you use say.  If you're in nqp, you use say().  If you're in jvm you have to use some acursed 40 character long Java think to get the effect of say.

[21:16] <lizmat> S31:73

[21:16] <synopsebot> Link: http://perlcabal.org/syn/S31.html#line_73

[21:17] <pmurias> diakopter: https://github.com/perl6/specs/blob/master/S12-objects.pod#open-vs-closed-classes

[21:17] <lizmat> S12:2189

[21:17] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_2189

[21:17] <ruoso> like... is there a way to dump the intermidiate states? like the parse tree, then the op tree, then the generated jvm code?

[21:17] <pmurias> ruoso: for nqp there's --target=ast

[21:17] <ruoso> ah... that may help

[21:17] <pmurias> ruoso: which could work for rakudo

[21:17] <diakopter> I thought it was --target=qast

[21:18] <FROGGS> diakopter: that changes a few months ago

[21:18] <FROGGS> s/s\b/d/

[21:19] <ruoso> ast is recognized, qast isn't... but ast fails with "cannot stringify this"

[21:19] <ruoso> (at least in rakudo...)

[21:20] <pmurias> and jast?

[21:20] <pmurias> ruoso: nqp --target=ast -e 'say(1)'

[21:20] <pmurias> for nqp

[21:20] <pmurias> I should check for rakudo

[21:20] <ruoso> I tried with rakudo, not nqp

[21:21] <pmurias> maybe something is broken

[21:22] <pmurias> ruoso: does --target=jast work?

[21:22] <grondilu> me notices that '.say for open("someverylongASCIIfile.txt").lines' doesn't seem to display anything until the whole file is in memory.  Which is not great.

[21:23] * ruoso looking

[21:23] * grondilu noticed that while trying to run http://rosettacode.org/wiki/Anagrams#Perl_6

[21:23] <ruoso> jast does work

[21:24] <colomon> grondilu: that's the "for isn't lazy about getting the data to loop over" thing again

[21:25] <grondilu> r: my @a := 1 .. *;  for @a { last if $_ > 10; .say }

[21:25] <camelia> rakudo 59e521: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§¬ª

[21:26] <grondilu> ^seems lazy enough

[21:26] <colomon> grondilu: yes, unless it's known infinite

[21:26] <grondilu> r: my @a := 1 .. 100000000000000;  for @a { last if $_ > 10; .say }

[21:26] *** FROGGS left
[21:26] <camelia> rakudo 59e521: OUTPUT¬´(timeout)¬ª

[21:26] <grondilu> indeed

[21:26] <grondilu> good to know

[21:27] * colomon doesn't know what that will do

[21:27] <ruoso> jast works, but is very cryptic, any docs on how to read it?

[21:28] <grondilu> isn't there a way to coerce lazyness in a for loop?

[21:28] <grondilu> (just curious)

[21:30] <colomon> it should just automatically happen, as far as I know.

[21:30] <ruoso> std: my @a = lazy for (1..10) { say $_ }

[21:30] <grondilu> ok

[21:30] <camelia> std c2215f0: OUTPUT¬´ok 00:00 46m‚ê§¬ª

[21:31] <ruoso> I think you can force "strict lazyness" with the "lazy" operator (but my reading of the spec is very very old)

[21:31] <ruoso> r: my @a = lazy for (1..10) { say $_ }

[21:31] <camelia> rakudo 59e521: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)‚ê§at /tmp/2VK44lAZwn:1‚ê§------> [32mmy @a = lazy for (1..10) [33m‚èè[31m{ say $_ }[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix‚Ä¶

[21:33] <grondilu> td: my @a := gather .take for ^10;

[21:34] *** Ulti left
[21:35] <grondilu> ruoso: where is this documented?  I don't find it in S07

[21:36] *** Ulti joined
[21:37] <ruoso> http://perlcabal.org/syn/S07.html#Levels_of_laziness , but it has DRAFT status

[21:41] <lizmat> r: my str @a; @a.push: "foo"  # huh, no push for "str" ?

[21:41] <camelia> rakudo 59e521: OUTPUT¬´Cannot call 'push'; none of these signatures match:‚ê§:(Any:U \SELF: *@values, Mu *%_)‚ê§  in method push at src/gen/CORE.setting:1508‚ê§  in block  at /tmp/ioECPFhKAU:1‚ê§‚ê§¬ª

[21:42] <timotimo> for loops are currently always eager, iirc

[21:42] <timotimo> due to a rakudobug

[21:42] <ruoso> lizmat: did you mean "my Array of Str @a"?

[21:42] <ruoso> r: my Array of Str @a; @a.push: "foo"

[21:42] <camelia> rakudo 59e521: OUTPUT¬´Type check failed in .push; expected 'Array+{TypedArray}' but got 'Str'‚ê§  in block  at src/gen/CORE.setting:7198‚ê§  in method push at src/gen/CORE.setting:7181‚ê§  in method push at src/gen/CORE.setting:1508‚ê§  in block  at /tmp/Lvo2Zn72v_:1‚ê§‚ê§¬ª

[21:42] <lizmat> no, lowercase str

[21:43] <lizmat> r: my Str @a; @a.push: "foo"  # works fine

[21:43] <camelia> rakudo 59e521:  ( no output )

[21:43] <timotimo> why is the signature just Any:U \SELF? there ought to be a second one i feel

[21:44] *** BenGoldberg joined
[21:45] <lizmat> ruoso: that syntax is wrong

[21:45] <lizmat> it is either my Type @a, or my @a of Type

[21:45] <lizmat> the latter doesn't work yet, is on my list though

[21:59] *** frdmn joined
[22:00] *** colomon left
[22:10] *** arcterus_ joined
[22:11] *** arcterus left
[22:13] * masak .oO( it's on my array though )

[22:15] <timotimo> .o( he's making an array, checking it twice ... )

[22:15] * masak .oO( Franz Array )

[22:16] <lizmat> .oO( Schindler's Array )

[22:17] <timotimo> .o( Hans Arraiy )

[22:41] *** Marlene joined
[22:44] <ruoso> hmm... so something in the ast is not stringifiable, so the entire thing blows up, now I have no idea how to discover what is failing

[22:46] <ruoso> hmm... and when I attach the debugger it works... 

[22:46] <ruoso> actually, it's something to do with parsing file vs inline in the repl

[22:52] <ruoso> ok, now I nailed it down, if I have an enclosing anon block, it fails... such as  ./perl6 --target=ast -e '{ my @x = 1..9 }'

[22:54] *** spider-mario left
[23:01] <jnthn> ruoso: I can reproduce that here too. Huh...

[23:01] <ruoso> is there some doc on the different QAST types and what they're for?

[23:02] <jnthn> in docs/ in NQP I think is some

[23:02] <jnthn> I think I see the problem...

[23:04] *** jaldhar left
[23:06] <pmurias> ruoso: docs/qast.markdown has some info on the QAST types

[23:06] *** pmurias left
[23:08] <ruoso> I am slightly surprised by the number of QAST::Want nodes

[23:09] <ruoso> maybe I am just looking too early in the process

[23:09] *** frdmn left
[23:11] *** frdmn joined
[23:12] *** frdmn left
[23:12] *** frdmn joined
[23:14] *** frdmn left
[23:15] *** frdmn joined
[23:16] *** Marlene left
[23:21] *** frdmn left
[23:21] *** frdmn joined
[23:21] *** PacoAir joined
[23:22] *** fgomez left
[23:23] *** frdmn left
[23:24] *** frdmn joined
[23:31] *** benabik left
[23:31] *** benabik joined
[23:35] *** arcterus_ left
[23:36] <dalek> nqp: d6f0f6f | jnthn++ | src/QAST/BVal.nqp:

[23:36] <dalek> nqp: Fix QAST::BVal dumping; ruoso++.

[23:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d6f0f6fdee

[23:37] <dalek> rakudo/nom: 8d851b7 | (Elizabeth Mattijsen)++ | src/core/List.pm:

[23:37] <dalek> rakudo/nom: Reimplement :with for List.(uniq|squish) (keep :as available)

[23:37] <dalek> rakudo/nom: 

[23:37] <dalek> rakudo/nom: Yes, it was removed from the spec, but the alternative for doing [eqv] based

[23:37] <dalek> rakudo/nom: uniqueness using *.perl is 1. still not possible now (because .perl doesn't

[23:37] <dalek> rakudo/nom: always give an accurate representation), and 2. very resource intensive,

[23:37] <dalek> rakudo/nom: because a whole structure needs to be stringified first before being able to

[23:37] <dalek> rakudo/nom: find out that they're different.  Whereas [eqv] is very quickly able to find

[23:37] <dalek> rakudo/nom: out whether two structures are different.

[23:37] <dalek> rakudo/nom: 

[23:37] <dalek> rakudo/nom: So, do I believe it belongs in the spec?  Yes!  :-)

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d851b7831

[23:38] <dalek> roast: 0f0ea4c | (Elizabeth Mattijsen)++ | S32-list/ (2 files):

[23:38] <dalek> roast: Added tests for :with for List.(uniq|squish)

[23:38] <dalek> roast: review: https://github.com/perl6/roast/commit/0f0ea4c054

[23:39] <lizmat> and on that thought, calling it a day again‚Ä¶   sleep&

[23:40] <jnthn> 'night, lizmat 

[23:51] *** benabik left
[23:57] *** dmol left
[23:57] *** benabik joined
[23:57] *** odoacre_ left
[23:58] *** ggoebel joined
[23:58] *** odoacre_ joined
