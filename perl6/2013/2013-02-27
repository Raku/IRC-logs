[00:04] *** sftp joined
[00:05] *** preflex left
[00:06] *** preflex joined
[00:20] *** LordVorp joined
[00:32] <TimToady> nr: my $x; BEGIN $x = 42; say $x;

[00:32] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«42␤»

[00:32] <TimToady> nr: our $x; BEGIN $x = 42; say $x;

[00:32] <p6eval> rakudo b10e2b: OUTPUT«===SORRY!===␤Cannot modify an immutable value␤»

[00:32] <p6eval> ..niecza v24-24-gbdc3343: OUTPUT«42␤»

[00:33] <diakopter> r: my $*a = 33; BEGIN { say($*a); $*a = 44; }; say $*a

[00:33] <p6eval> rakudo b10e2b: OUTPUT«===SORRY!===␤Dynamic variable $*a not found␤»

[00:33] <diakopter> r: my $*a = 33; BEGIN { $*a = 44; }; say $*a

[00:33] <TimToady> try the our in the repl and it coredumps

[00:33] <p6eval> rakudo b10e2b: OUTPUT«===SORRY!===␤Dynamic variable $*a not found␤»

[00:34] <diakopter> the repl's antimatter containment is very weak

[00:34] <TimToady> sure, that's fine, since there's no dynamic context yet

[00:35] <TimToady> doesn't blow up till you exit though, oddly

[00:36] <TimToady> (if you exit with ^D)

[00:39] *** lustlife joined
[00:48] *** benabik joined
[00:56] *** fgomez left
[00:57] *** anuby joined
[01:04] *** fgomez joined
[01:09] *** hypolin joined
[01:17] *** cognominal joined
[01:17] *** benabik left
[01:23] *** cognominal left
[01:29] *** uvtc joined
[01:30] *** cognominal joined
[01:30] <uvtc> TimToady: thanks for trying to help earlier with your examples using .list, .tree, and .lol , though I don't think I understand what you were trying to illustrate.

[01:33] <TimToady> mostly I was just trying to understand how much of .tree was implemented :)

[01:33] <uvtc> What should .tree do?

[01:33] <TimToady> r: say (<a b c>, (<d e f>, <g h i>)).tree(*.Array,2).perl

[01:33] <p6eval> rakudo b10e2b: OUTPUT«Cannot call 'tree'; none of these signatures match:␤:(Any:U : Mu *%_)␤:(Any:D : Mu *%_)␤:(Any:D : &c, Mu *%_)␤:(Any:D : Cool $count, Mu *%_)␤␤  in method tree at src/gen/CORE.setting:1366␤  in block  at /tmp/sAzmCQh4zz:1␤␤»

[01:34] <TimToady> it's supposed to transform a structure of parcels into something more solid

[01:34] <uvtc> Parcels.

[01:34] <TimToady> r: say <a b c>.WHAT

[01:34] <p6eval> rakudo b10e2b: OUTPUT«(Parcel)␤»

[01:34] <TimToady> r: say (<a b c>, (<d e f>, <g h i>)).tree(*.Array)[0].WHAT

[01:34] <p6eval> rakudo b10e2b: OUTPUT«(Array)␤»

[01:34] <TimToady> like that

[01:35] <TimToady> it's supposed to be able to turn all the leaf nodes into arrays too, but it can't do that yet

[01:35] <uvtc> r: my @a = ('a', 'b', 'c'); say @a.WHAT; say ('a', 'b','c').WHAT;

[01:35] <p6eval> rakudo b10e2b: OUTPUT«(Array)␤(Parcel)␤»

[01:35] <TimToady> as someone was mentioning, assignment is not binding

[01:36] <TimToady> r: my @a := ('a', 'b', 'c'); say @a.WHAT; say ('a', 'b','c').WHAT;

[01:36] <p6eval> rakudo b10e2b: OUTPUT«(Parcel)␤(Parcel)␤»

[01:36] <uvtc> That sounds deep. To me, assignment *is* binding.

[01:36] <TimToady> no, binding is assignment of references rather than values

[01:36] <TimToady> do you know C

[01:36] *** cognominal left
[01:36] <TimToady> ?

[01:36] <uvtc> Oh, yes. Right. A container is involved.

[01:36] <geekosaur> roughly: in perl 6, assignment assigns into a container bound to a name; binding binds a container to a name

[01:37] <TimToady> assignment is *destination = *source, while binding is destination = source

[01:37] <uvtc> So `:=` is the binding operator, correct? It binds the parcel ('a', 'b', 'c') to the name `@a`?

[01:37] <TimToady> yes

[01:37] <TimToady> whereas assignment copies the values into the container

[01:37] <uvtc> I used C years ago.

[01:37] <TimToady> that is initialized to be an Array because of the @

[01:38] <TimToady> it's the list assignment to the array that, er, turns it into an Array

[01:38] <TimToady> r: my $item = (1,2,3); say $item.WHAT

[01:38] <p6eval> rakudo b10e2b: OUTPUT«(Parcel)␤»

[01:38] <uvtc> I'd thought "binding" was just a generic term to mean "this name refers to this cubby hole (memory)".

[01:38] <TimToady> assignment to a scalar container doesn't do list assignment, so it just copies in the parcel ref

[01:39] <TimToady> yes, but when you do assignment, you aren't doing that, unless you happen to be assigning a reference

[01:39] <TimToady> in particular, list assignment doesn't do that

[01:39] <TimToady> it copies the values of the list into the (existing) array

[01:40] * uvtc steeples fingers in deep thought...

[01:40] <TimToady> mostly, assignment is there to preserve the sense of value semantics that a Perl 5 programmer wants

[01:40] <TimToady> binding is what a Python programmer is taught to expect

[01:40] <TimToady> (when they say =)

[01:42] <TimToady> if a programmer wants to program pythonically in p6, they just need to use $vars and := consistently

[01:43] <TimToady> then no copying of anything except pointers ever happens without an explicit .clone

[01:44] <TimToady> basically, = is value semantics rather than pointer semantics, how your C program manages to actually set an int location in memory to 42

[01:44] <TimToady> (but as in C, sometimes pointers can be treated as native values too)

[01:44] <TimToady> that's what happened when I assigned a parcel to $item

[01:45] <TimToady> it ignored the ref-ness of it and just poked it into the scalar container currently bound to $item

[01:45] <TimToady> however, since all scalar containers automatically deref that for you, you can think of it as just putting the object into the variable

[01:46] <TimToady> (if you admit that an object can be in more than one place at the same time)

[01:46] <TimToady> which is how value objects work anyway; 42 is the same value in $foo as in $bar

[01:47] *** cognominal joined
[01:47] <TimToady> it's just that normal objects take their identity from their location rather than their value

[01:47] <TimToady> so when you copy around object identities, you're just copying pointers to locations, really

[01:48] <TimToady> most of the time all this referencing and dereferencing 'cancels out' so you can just ignore it

[01:57] *** fgomez left
[01:58] <uvtc> `my $x = ...` and `my @a = ...` make containers and then copy values into them. `=` is "value semantics" (like C and Perl 5 (when not using references in Perl 5)).

[01:58] *** fgomez joined
[01:59] * uvtc is still here. Thanks so much for your help, TimToady.

[01:59] <TimToady> also like refs in P5, except in P6 you never have to use \ to make a ref explicitly

[01:59] <TimToady> since everything makes a ref automatically

[02:00] <TimToady> r: my $ref = &die; &die.("Something to die for")

[02:00] <p6eval> rakudo b10e2b: OUTPUT«Something to die for␤  in block  at /tmp/xvq2Kw6sVs:1␤␤»

[02:00] <TimToady> &die creates a ref, and .() automatically derefs it

[02:00] <TimToady> @foo creats a ref, and .[] derefs it

[02:01] <TimToady> %foo creates a ref and .{} derefs it

[02:01] <TimToady> so mostly we just got rid of the backslashes in P6

[02:01] <TimToady> assignment stayed much the same, and we added binding so we didn't have to play with typeglobs anymore ever again

[02:02] <[Coke]> r: my \atnight = "mostly"; say atnight;

[02:02] <p6eval> rakudo b10e2b: OUTPUT«mostly␤»

[02:02] <TimToady> that's a pseudoassignment really, and notices that it's really supposed to bind

[02:03] <uvtc> Does the `:=` explicitly cause a ref to be taken of the rhs?

[02:03] <TimToady> nope

[02:03] <TimToady> it merely treats it differently on the left

[02:03] <TimToady> the RHS has no clue it's inside a := or a =

[02:04] <TimToady> it just does its think of always making a ref to something

[02:04] <TimToady> *thing

[02:04] *** Vlavv joined
[02:04] <uvtc> Sounds like we're saying the same thing: `:=` makes sure a ref is assigned to the LHS.

[02:05] <TimToady> was just quibbling with "cause a ref to be taken", when it just uses the ref that's there, it doesn't cause it, except insofar as it simply evaluates the RHS

[02:07] *** Vlavv_ left
[02:07] *** cognominal left
[02:11] <uvtc> TimToady: re `my $item = (1,2,3);` above, you wrote, "assignment to a scalar container doesn't do list assignment, so it just copies in the parcel ref". But, why is ref copying happening ("binding"), if the assignment operator is being used?

[02:12] <TimToady> it's copying the ref as a value into the container, it's not replacing the container as := would

[02:13] <TimToady> r: my $item = (1,2,3); $item = 42; say $item

[02:13] <p6eval> rakudo b10e2b: OUTPUT«42␤»

[02:13] <TimToady> r: my $item := (1,2,3); $item = 42; say $item

[02:13] <p6eval> rakudo b10e2b: OUTPUT«Cannot modify an immutable value␤  in method STORE at src/gen/CORE.setting:5186␤  in block  at /tmp/eqxv8WxF7A:1␤␤»

[02:13] <uvtc> `:=` replaces the container of the object on the RHS with that of the LHS?

[02:13] <TimToady> yousaid that backwards

[02:13] <uvtc> ! :)

[02:13] <uvtc> `:=` takes what's on the RHS and puts it into the container on the LHS?

[02:14] <uvtc> Oh, that's worse.

[02:14] <uvtc> `:=` takes what's in the container on the RHS and puts it into the container on the LHS?

[02:14] *** cognominal joined
[02:14] <TimToady> no

[02:15] <TimToady> := merely changes the meaning of the name on the left to refer to whatever reference there was on the right

[02:15] <TimToady> there isn't necessarily a container on either side

[02:15] <TimToady> (except insofar as a name can refer to something else)

[02:16] <uvtc> Would you say, "$x, @y, and %z are names which refer to containers"?

[02:16] <TimToady> by default, yes

[02:16] <TimToady> unless you bind something else to them

[02:17] <uvtc> And then what would you call them?

[02:17] <uvtc> (instead of names which refer to containers)

[02:17] <TimToady> when you say: my @y;  it's equivalent to my @y := Array.new;

[02:17] *** AigleNoir is now known as ericg

[02:17] <uvtc> Makes sense.

[02:17] <TimToady> the @ merely claims that the objects supports .[] style subscripting

[02:17] *** ericg left
[02:18] <TimToady> and @ and % tend to "autovivify" whatever it is you expect to be there

[02:18] <uvtc> Oh, and when you use `:=`, you're saying, "don't create a new object, just binding to <this> one"

[02:18] <TimToady> an array or hash in this case

[02:18] <TimToady> yes

[02:18] <uvtc> s/binding/bind/

[02:19] <TimToady> name -> container -> value(s) is the default, but you can override it to name -> whateveryoulike

[02:20] <uvtc> Thanks so much for the help, TimToady. I'm going to let this stew simmer just a bit longer. Which Synopsis would you say covers this particular topic?

[02:21] <uvtc> TimToady++ # sitting down at the chalkboard after hours

[02:21] <TimToady> um, that topic tends to be distributed over many synopses

[02:21] <TimToady> anyway, you're welcome--I need to figure out the best way to explain it in a book soon in any case

[02:22] <uvtc> Very well. {tips hat} :)

[02:23] *** cognominal left
[02:32] *** mjreed joined
[02:33] <mjreed> perl6: sub fib($n) { state @fib := 0,1,*+*...*; @fib[$n]; }; fib(0); fib(0);

[02:33] <p6eval> niecza v24-24-gbdc3343: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot use bind operator with this LHS at /tmp/PUCoYjKDaH line 1:␤------> [32msub fib($n) { state @fib := 0,1,*+*...*[33m⏏[31m; @fib[$n]; }; fib(0); fib(0);[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza…

[02:33] <p6eval> ..rakudo b10e2b:  ( no output )

[02:33] <mjreed> sub fib($n) { state @fib := 0,1,*+*...*; @fib[$n]; }; fib(0); say fib(0);

[02:34] <mjreed> perl6: sub fib($n) { state @fib := 0,1,*+*...*; @fib[$n]; }; fib(0); say fib(0);

[02:34] <p6eval> rakudo b10e2b: OUTPUT«(Any)␤»

[02:34] <p6eval> ..niecza v24-24-gbdc3343: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot use bind operator with this LHS at /tmp/AW4jBzc4RL line 1:␤------> [32msub fib($n) { state @fib := 0,1,*+*...*[33m⏏[31m; @fib[$n]; }; fib(0); say fib(0);[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/ni…

[02:37] *** mjreed left
[02:38] *** mjreed joined
[02:43] <[Coke]> aw, panda install NativeCall barfs.

[02:43] <[Coke]> is NativeCall expected to work on OS X?

[02:46] <mjreed> binding `state` variables - valid per the spec?   current rakudo allows it but the binding doesn't actually persist..

[02:51] <skids> r: sub OHAI0 { "OHAI".say; 0 }; sub fib($n) { state @s = (OHAI0(),1,*+* ... *); @s[$n] }; fib(13).say; fib(8).say # is the binding needed?

[02:51] <p6eval> rakudo b10e2b: OUTPUT«OHAI␤233␤21␤»

[03:03] <skids> (S04 'state automatically applies "start" semantics to any initializer')

[03:08] <mjreed> hm.  thought that assignment would evaluate the list, and therefore was a no-no for infinite ones.

[03:10] <colomon> mjreed: I believe Rakudo is doing some sort of magic to make infinite list assignment work *if* it knows the list is infinite.

[03:11] <[Coke]> r: (say 1,1,*+*...*)

[03:11] <p6eval> rakudo b10e2b: OUTPUT«1 1 2 3 ...␤»

[03:17] <skids> What magic is required seems to be specced out in S03 at the end of the sequence operator text.

[03:20] <skids> r: sub OHAI0 { "OHAI".say; 0 }; sub fib($n) { START { OHAI0(),1,*+* ... * }[$n] }; fib(13).say; fib(8).say;

[03:20] <p6eval> rakudo b10e2b: OUTPUT«OHAI␤233␤21␤»

[03:23] *** orafu left
[03:23] <TimToady> perl6: sub fib($n) { constant @fib = 0,1,*+*...*; @fib[$n]; }; fib(0); say fib(0);

[03:23] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«0␤»

[03:23] <TimToady> perl6: sub fib($n) { constant @fib = 0,1,*+*...*; @fib[$n]; }; say fib(^10); say fib(^10);

[03:23] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«55␤55␤»

[03:24] <skids> .oO(It's all fun and games until someone loses half their RAM to cached fib values)

[03:24] <TimToady> perl6: sub fib(\n) { constant @fib = 0,1,*+*...*; @fib[n]; }; say fib(^10); say fib(^10);

[03:24] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«0 1 1 2 3 5 8 13 21 34␤0 1 1 2 3 5 8 13 21 34␤»

[03:25] <TimToady> skids: in which case the compiler can notice it's a constant, and deduce that it could reconstruct the values if it needed to :)

[03:25] *** orafu joined
[03:26] *** mjreed left
[03:27] * TimToady can see that it will take some persuading to get people to think of an infinite series as a constant...

[03:27] *** aindilis joined
[03:27] <TimToady> it's just a very Large constant

[03:28] <TimToady> s/series/sequence/

[03:31] <skids> Not really that difficult once you teach them that code can be a constant.

[03:35] <diakopter> all deterministic pure code is a constant... with a very big range

[03:38] <japhb> timotimo, Some time ago I believe you pasted this link: https://github.com/timo/iperl6kernel/blob/master/bin/iperl6kernel.nqp#L156 ... it occurs to me that lines 153..157 put @ARGS into the wrong order.

[03:39] <japhb> I'm guessing you instead wanted just: @ARGS.unshift('-MIPerl6::ZMQ'); @ARGS.unshift('-Ilib');

[03:41] <japhb> Though come to think of it, this is NQP, so I guess you do still need the $pname movement.  So really, just swapping lines 155 and 156 ought to correct things.

[03:53] *** Guest10382 left
[03:53] *** mberends left
[03:53] *** tipdbmp left
[03:53] *** cosimo left
[03:53] *** odoacre left
[03:53] *** TimToady left
[03:53] *** kcwu left
[03:53] *** Juerd left
[03:53] *** Ayiko left
[03:55] *** Guest10382 joined
[03:55] *** mberends joined
[03:55] *** tipdbmp joined
[03:55] *** cosimo joined
[03:55] *** odoacre joined
[03:55] *** TimToady joined
[03:55] *** kcwu joined
[03:55] *** gfldex joined
[03:55] *** Juerd joined
[03:55] *** Ayiko joined
[03:58] *** rindolf joined
[04:17] *** kaleem joined
[04:22] *** rindolf left
[04:23] *** rindolf joined
[04:25] *** mjreed joined
[04:25] *** xinming_ joined
[04:28] *** xinming left
[04:35] *** rindolf left
[04:35] *** rindolf joined
[04:38] *** preflex_ joined
[04:38] *** preflex left
[04:39] *** preflex_ is now known as preflex

[04:39] *** Chillance joined
[04:41] *** uvtc left
[04:42] *** rindolf left
[04:42] *** rindolf joined
[04:44] <TimToady> http://rosettacode.org/wiki/File_modification_time#Perl_6

[04:48] *** anuby left
[04:48] *** anuby joined
[04:50] <labster> TimToady++  Shouldn't that be in a module?

[04:53] *** kaleem left
[04:53] <TimToady> well, eventually; at the moment it's in the category of difficult but possible

[04:56] *** mjreed left
[04:58] <TimToady> and I'm trying to pass up Mathematica :)

[04:58] <TimToady> 3 to go...

[05:01] *** SamuraiJack joined
[05:19] *** rindolf left
[05:20] *** rindolf joined
[05:32] *** odoacre left
[05:32] *** odoacre joined
[05:34] *** searcher-perl joined
[05:35] *** raiph left
[05:35] <searcher-perl> hi all

[05:36] <diakopter> hi

[05:37] <searcher-perl> I study perl6 again

[05:37] <searcher-perl> But I read parrot has gone

[05:37] <searcher-perl> Is that trueX

[05:37] <searcher-perl> ?

[05:37] <diakopter> parrot hasn't gone

[05:38] <diakopter> rakudo has been transitioning to use multiple backends/VMs for years now

[05:38] <searcher-perl> I know that

[05:38] <diakopter> ok :)

[05:39] <searcher-perl> When I use perl6 binary, it's too late. So I searched some news for perl6.

[05:40] <searcher-perl> Someone said Parrot will or may stop.

[05:40] <diakopter> well, all the active developers are otherwise occupied, generally

[05:41] <sorear> why do you care?  what are you trying to do?

[05:42] <searcher-perl> I wonder I can use perl6 for production program

[05:42] <diakopter> depends for what purpose

[05:43] <diakopter> it's sufficient for some things; not ready for other things

[05:44] <searcher-perl> sorry, I'm not English native speaker. So I can't understand nuiance very well

[05:45] <diakopter> okay.  What kind of production program do you want to try?

[05:47] <searcher-perl> I knew about parrat long time ago, so now I'm thinking parrot can substitute Java.

[05:48] <searcher-perl> perl6 was too late so something was wrong.

[05:48] <geekosaur> that's one of the active projects, yes

[05:48] <diakopter> the JVM is one the VMs to which rakudo is being ported

[05:49] <geekosaur> mostly what was wrong was people got so busy working on features and forgot to tell the world they were still there...

[05:49] <sorear> searcher-perl: "production" is too vague to say anything.  What, specifically, do you want to use perl 6 for?

[05:50] <searcher-perl> I mean general purpose like perl5.

[05:51] <searcher-perl> perl6 is very late than my expect.

[05:51] <diakopter> your expectation were set incorrectly :)

[05:54] <searcher-perl> I studied groovy. It's later than perl5 very much. perl6 is later than groovy.

[05:56] <searcher-perl> So I want to ask something about perl6. It's fit for general purpose language now.

[05:58] *** Chillance left
[05:59] <diakopter> searcher-perl: most of the implementations are Turing complete, so...

[06:00] <searcher-perl> visual basic also say so :)

[06:02] <searcher-perl> I think perl6 is enough then study perl6 or use perl.

[06:02] <searcher-perl> of course v5.

[06:03] <TimToady> study many languages, including p6 :)

[06:03] *** anuby left
[06:04] *** raiph joined
[06:04] <searcher-perl> Thank you. I thought perl6 is complete. But still has long way.

[06:04] <sorear> do we have any regulars from .kr?

[06:04] <searcher-perl> I met Seoul.pm members in 2008.

[06:05] <searcher-perl> But I don't know about them.

[06:05] <TimToady> well, you are very welcome here

[06:06] <searcher-perl> Thank you. They say about perl5 not so much perl6. I don't know why.

[06:07] <TimToady> perl5 started earlier :)

[06:07] <TimToady> but perl6 will end later

[06:07] <searcher-perl> Good.

[06:07] <searcher-perl> I learned perl in 2002.

[06:08] <TimToady> you will like Perl 6 even better

[06:08] <TimToady> when we get it to run faster, it will become a lot of people's favorite language

[06:09] <searcher-perl> Grammar is good, it's more like functional.

[06:09] <TimToady> more functional, and more OO too

[06:09] <searcher-perl> true.

[06:09] <TimToady> and quite a bit more powerful

[06:09] <searcher-perl> Perl5 has some obfuscating things.

[06:10] <TimToady> we've fixed most of those things

[06:10] <searcher-perl> So I consider Perl6.

[06:10] <TimToady> nr: say "Welcome searcher-perl!" for ^10;

[06:10] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤Welcome searcher-perl!␤»

[06:11] <TimToady> see, both rakudo and niecza agree that you are welcome

[06:11] <searcher-perl> Time to learn again perl6. But too late as I thought. Interating.

[06:11] <searcher-perl> what is nieczaX

[06:11] <searcher-perl> ?

[06:11] *** dayangkun joined
[06:12] <TimToady> it's an implementation that runs on .NET or mono

[06:12] <TimToady> I use it in production :)

[06:12] <TimToady> (because it's faster than rakudo, so far)

[06:12] <searcher-perl> Sorry, Microsoft platform is not my destiny.

[06:13] <TimToady> mono is not on Microsoft platform :)

[06:13] <searcher-perl> Is that soX

[06:13] <TimToady> well, you can soon run on JVM instead if you like

[06:13] <diakopter> it does have decent chunks of MS-PL code

[06:13] <searcher-perl> mono is porting of .Net.

[06:13] <diakopter> not really porting; more like clean-room reimplementation

[06:14] <TimToady> yes, but just because it has the same API does not mean that it belongs to Microsoft

[06:14] <searcher-perl> No licence problem?

[06:14] <TimToady> anyway, Perl 6 will run on many platforms in the future

[06:14] <TimToady> so you will be able to pick

[06:15] <TimToady> rakudo: < mono .NET JVM Parrot llvm Haskell Go C>.pick.say

[06:15] <p6eval> rakudo b10e2b: OUTPUT«Go␤»

[06:15] <TimToady> ooh, it picks Go :)

[06:16] <Timbus> rakudo on llvm would be amazing

[06:16] <Timbus> you could call it lakudo

[06:17] <searcher-perl> :)

[06:20] <TimToady> llakudo, surely

[06:20] <searcher-perl> Is it possible socket, db in perl6?

[06:21] <TimToady> yes, though it is not as developed as p5 yet

[06:22] <searcher-perl> How can it be connect to C library like xs in perl5?

[06:22] <TimToady> currently through the NativeCall interface

[06:23] <TimToady> for an example, see http://rosettacode.org/wiki/Call_a_function_in_a_shared_library#Perl_6

[06:24] <searcher-perl> good.

[06:25] <searcher-perl> Difficult.

[06:25] <TimToady> people will write modules that make it easy

[06:32] <searcher-perl> Ok. I'll read perl6 book first. Thank you for your kind answers. Bye!

[06:33] *** searcher-perl left
[06:38] <grondilu> yeah!  I'm now officially a perl monk:  http://perlmonks.org/?node_id=946047

[06:42] *** quester joined
[06:48] *** xinming_ left
[06:54] *** xinming joined
[07:06] *** odoacre left
[07:06] *** odoacre joined
[07:11] *** FROGGS joined
[07:14] *** odoacre left
[07:15] *** odoacre joined
[07:38] * FROGGS wants to do Gokudo soon

[07:46] <FROGGS> mathw: you are the one who wants to port NQP to Go, right?

[07:46] <diakopter> swarley was working on it last week

[07:46] <moritz> wouldn't that be Ragodu?

[07:46] <FROGGS> ahh, k, thanks

[07:47] <FROGGS> hehe, ragodu .oO( ragodü? ) sounds like a saxonian name to me :P

[07:50] *** quester left
[08:13] *** domidumont joined
[08:20] *** kaare_ joined
[08:20] *** wk joined
[08:25] *** rindolf left
[08:25] *** rindolf joined
[08:29] *** sqirrel joined
[08:30] *** domidumont left
[08:31] *** domidumont joined
[08:33] *** domidumont left
[08:34] *** domidumont joined
[08:34] <FROGGS> awww ó.ò

[08:34] <FROGGS> gccgo test.go 

[08:34] <FROGGS> test.go:21:16: Fehler: import file »./src/sixModel« not found

[08:35] *** ObseLeTe joined
[08:36] *** rindolf left
[08:36] *** rindolf joined
[08:37] <moritz> swarley: ^^ seems you forgot to commit a file

[08:39] *** daxim joined
[08:43] <tadzik> RaGodost maybe :)

[08:43] <tadzik> hello #perl6

[08:44] <moritz> \o tadzik 

[08:44] *** salv01 joined
[08:45] <sorear> sounds like a slavik adjective

[08:45] *** am0c joined
[08:45] <sorear> glasnost, blizkost

[08:45] <sorear> or was that the point

[08:45] <sorear> hello tadzost

[08:48] <FROGGS> is that morally reprehensible if I have to think of blitzkrieg now?

[08:48] * FROGGS .oO( RATZKRATZNFATZ! )

[08:48] *** rindolf left
[08:49] <sorear> blizkost means 'togetherness, closeness' IIRC

[08:49] <sorear> not related to Blitzkrieg

[08:49] *** rindolf joined
[08:49] <sorear> Blitz referring to speed, or lightning specifically

[08:49] <sorear> Kugelblitz

[08:50] <FROGGS> I know, it is a german word :o)

[08:50] <sorear> ... now that I think about it, aren't you kind of a person who speaks both german and polish

[08:50] <sorear> why am I telling you about those languages

[08:51] <sorear> I must be tired

[08:53] <FROGGS> I dont speak polish, older east-germans usually speak +russian, older west-germans usually +french, junger germans mostly +english and +french

[08:53] <moritz> s/junger/younger/ :-)

[08:54] <FROGGS> IMO polish ppl speak german and english too, but germans dont tend to learn polish language

[08:54] <FROGGS> thanks moritz

[08:54] <sorear> FROGGS: I thought you were specically polish, living in germany

[08:54] <FROGGS> when creating another sentences in my head I tend to write german words ó.ò

[08:54] <FROGGS> sorear: no

[08:55] <nwc10> straw poll of one day visiting Bratislava - older people we interacted with were more comfortable with German. Younger with English.

[08:56] <sorear> was everyone comfortable with Slovak, though? :)

[08:56] <FROGGS> in school we had russian language for 3 years or so but I only can read the letters now, we had english for seven years, but no polish or other languages

[08:57] <sorear> FROGGS: was this before or after reunification

[08:57] <moritz> I think there's a deep racist current against eastern european countries in the west of germany

[08:58] <FROGGS> sorear: after

[08:58] <sorear> interesting.  did not expect that

[08:58] <sorear> is russia considered part of eastern europe, or its own thing

[08:59] <FROGGS> I went to school (with age of seven) 1989

[08:59] <sorear> ooh, exciting times

[09:00] <moritz> the fall of the Berlin wall is the first political event that I remember

[09:00] <FROGGS> moritz: it is not only in the west of germany, since generations ago the eastern ppl had "contact" with russian soldiers... and these impression stay long

[09:01] <FROGGS> moritz: I dont even remember that

[09:01] <moritz> though at that time I didn't quite understand why my parents were so excited, and how one country can be two countries or not

[09:01] *** rindolf left
[09:02] *** rindolf joined
[09:03] <sorear> moritz: where were you living at the time?  (west, east exclusive of berlin, east berlin, west berlin, other)

[09:04] <moritz> sorear: west

[09:04] <moritz> sorear: though my faster came from the east, and "lost" his father by the division

[09:05] <sorear> erlangen?

[09:05] <FROGGS> I lived in thuringia, pretty in the center of germany, but still "east"

[09:05] <moritz> yes

[09:05] *** cibs left
[09:06] <nwc10> sorear: we didn't speak any Slovak, so we couldn't test this :-)

[09:15] *** rindolf left
[09:15] *** rindolf joined
[09:19] *** donaldh left
[09:19] *** cibs joined
[09:21] <jnthn> morning, #perl6 o/

[09:21] <FROGGS> hi jnthn 

[09:21] <jnthn> nwc10: dobre rano # two words you can test with next time ;)

[09:22] <FROGGS> guten morgen?

[09:22] <FROGGS> err, good morning?

[09:22] <jnthn> yes :)

[09:22] <FROGGS> dobre, means good at least

[09:22] <FROGGS> :o)

[09:22] * jnthn despairs at how quickly language knowledge rust

[09:23] <jnthn> *rusts

[09:23] <nwc10> Pivo!

[09:23] *** donaldh joined
[09:24] <FROGGS> nqp: say("[" ~ ("ab123c" ~~ /<-[\w]>+/) ~ "]")

[09:24] <p6eval> nqp: OUTPUT«[]␤»

[09:24] <FROGGS> nqp: say("[" ~ ("ab123c" ~~ /<-[abc]>+/) ~ "]")

[09:24] <p6eval> nqp: OUTPUT«[123]␤»

[09:24] <FROGGS> -.-

[09:24] <moritz> \w matches digits too

[09:24] <jnthn> nwc10: That's a useful word :)

[09:24] <FROGGS> ahh, of course

[09:24] <FROGGS> thanks, that saves me hours >.<

[09:24] <nwc10> jnthn: visit Bratislava. Or visit Vienna, and we can make a day trip there

[09:25] * jnthn should do that sometime :)

[09:26] *** rindolf left
[09:27] <nwc10> currently the car actually has enough fuel to get to Croatia

[09:27] <FROGGS> nwc10: and to get back too?

[09:27] *** rindolf joined
[09:27] <nwc10> no.

[09:27] <nwc10> but in Croatia, they took more credit cards than I was aware existed

[09:28] <nwc10> FROGGS: actually, might be able to make a round trip to the nearest part of Croatia

[09:28] *** fhelmberger joined
[09:28] <nwc10> but the car thinks its range is about 850km when full

[09:28] <nwc10> we've not tried driving slowly to see if we can up that number. :-)

[09:28] <dalek> nqp: 906d7fa | jnthn++ | src/HLL/Compiler.pm:

[09:28] <dalek> nqp: Remove some dead code.

[09:28] <dalek> nqp: 

[09:28] <dalek> nqp: Couldn't possibly have worked, since it calls a method that doesn't

[09:28] <dalek> nqp: exist.

[09:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/906d7fa121

[09:28] <dalek> nqp: a93281b | jnthn++ | src/HLL/Compiler.pm:

[09:28] <dalek> nqp: Elimiante Parrot-hash-specific .update.

[09:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a93281b691

[09:29] *** lizmat left
[09:29] <FROGGS> I once was able to drive more than 1100km with a renault trafic, but then you can't drive faster than 80-100km/h

[09:30] <nwc10> anyway, we're out of pelinkovac and pruscht, and low on olive oil and olives, so we have a shopping list

[09:39] *** aindilis left
[09:54] <Ulti> just tried building R* on my windows machine, I get a make error just after parrot gets compiled

[09:55] <Ulti> Command failed (status 65280): C:\Dwimperl\perl\bin\perl.exe Configure.pl --with-parrot=C:/rakudo-star/install/bin/parrot.exe --make-install

[09:55] *** SamuraiJack_ joined
[09:55] <Ulti> I dont have ICU in the build path atm so I need to do that anyway

[09:55] *** SamuraiJack left
[09:56] <moritz> Ulti: it would help if you could nopaste output above that error

[09:57] <Ulti> k

[09:57] <Ulti> just running that command I get that it doesn't like the --with-parrot flag

[09:58] <nwc10> jnthn: still works on my machine

[09:58] *** dakkar joined
[09:58] <Ulti> oh man cmd.exe is so lame

[09:59] <daxim> kill it with fire, then replace it

[09:59] <daxim> http://stackoverflow.com/questions/440269/whats-a-good-alternative-windows-console

[10:00] <FROGGS> daxim: well, if you want to test things on windows you dont have many choices

[10:00] <daxim> I recently tried a few, and they all suck compared with konsole, which isn't available for windows

[10:00] <FROGGS> what about powershell? never used it though

[10:01] <daxim> CMIIW, but isn't powershell just a shell?

[10:05] <BinGOs> shell and .NET-ish scripting environment

[10:05] <Ulti> daxim: thanks for the link

[10:06] *** hypolin left
[10:11] <sorear> reminder that cmd.exe and conhost.exe are different things

[10:12] <sorear> last time I was on windows I used the version of bash.exe that came with msysgit.  it's good

[10:12] <Ulti> http://nopaste.info/9e0bbcac4e.html  <-- output from perl Configure.pl --gen-parrot 

[10:12] <sorear> conhost is icky but it's much harder to replace, it's somewhat more integrated with system

[10:12] <sorear> it can probably be done but I haven't tried

[10:13] <moritz> Ulti: you got a warning "Warning: Building a shared parrot library may conflict with your previously-installed C:rakudobinlibparrot.dll "

[10:14] <moritz> Ulti: maybe remove that, and try to buld nqp again?

[10:14] <moritz> cd nqp

[10:14] <moritz> gmake install

[10:14] <Ulti> k

[10:14] <sorear> C:rakudobinlibparrot.dll is kind of red flaggy

[10:21] *** lue left
[10:26] <timotimo> somebody used backslashes without escaping them or osmething?

[10:26] <dalek> nqp: 1c6c851 | jnthn++ | src/ (3 files):

[10:26] <dalek> nqp: Eliminate use of Parrot dumper.

[10:26] <dalek> nqp: 

[10:26] <dalek> nqp: We didn't use it for --target=ast, but --target=parse relied on it. The

[10:26] <dalek> nqp: output was incredibly verbose, so replace it with something that does

[10:26] <dalek> nqp: not rely on the Parrot dumper and gives more compact, and hopefully

[10:26] <dalek> nqp: more useful, output. Tweaks welcome.

[10:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1c6c85141e

[10:27] *** kresike joined
[10:27] <kresike> hello all you happy perl6 people

[10:27] <Ulti> hmmm its flaking out on compiling libtommath or at least between there and nqp_group.c

[10:28] <Ulti> also I think the previous problem was that I had R* installed elsewhere so parrot was in my path I assume

[10:30] <Ulti> I should probably head to day jerb now, sorry :( I'll try properly later tonight to build a .msi as my gf is away playing with clay for three hours...

[10:32] <timotimo> r: use Test::More; throws_like q{class Foo { method bar { Quux.parse('OH HAI'); } }; grammar Quux { rule TOP { .* } }; Foo.bar;}, X::Undeclared::Symbols, post_types => "Quux" => *;

[10:32] <p6eval> rakudo b10e2b: OUTPUT«===SORRY!===␤Could not find Test::More in any of: /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/lib, /h…

[10:32] *** proller joined
[10:33] <timotimo> oh

[10:33] <timotimo> star: use Test::Util; throws_like q{class Foo { method bar { Quux.parse('OH HAI'); } }; grammar Quux { rule TOP { .* } }; Foo.bar;}, X::Undeclared::Symbols, post_types => "Quux" => *;

[10:33] <p6eval> star 2013.02: OUTPUT«===SORRY!===␤Could not find Test::Util in any of: /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/site/lib, /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/vendor/lib, /home/p6eval/star/lib/parrot/4.10.0/languages/perl6/lib, /home/p6eval/.perl6/2013.02.1/lib…

[10:33] <FROGGS> it is not part of anything ó.ò

[10:33] <timotimo> right, this is not going to work

[10:34] <timotimo> so, uh, the problem i'm getting is that i get a SORRY outputted from that eval and the $! seems to be Nil and i'm confused.

[10:34] *** lue joined
[10:35] <moritz> timotimo: first, put the string declaration outside the throws_like, and print it, and see if it's what you expected

[10:36] <moritz> second, try some parens in post_types => "Quux" => *;

[10:42] *** spider-mario joined
[10:50] *** dayangkun left
[10:51] <mberends> does p6 LWP::Simple support https? Here on Linux it dies "could not parse headers" in parse_response in Simple.pm. cosimo? anyone? It's a total blocker :(

[10:54] <cosimo> mberends: it doesn't afaik

[10:55] <mberends> cosimo: thanks

[10:55] * mberends thinks about an ugly workaround shelling wget on Windows

[10:57] *** ObseLeTe left
[11:00] <timotimo> moritz: haha, get this: i was adding this to the S32-excepitons/misc.t and moving it all the way up makes it work. looks like the evals were all in the same scope and there were name clashes or something

[11:01] *** proller left
[11:03] <dalek> roast: 7d2d272 | (Timo Paulssen)++ | S32-exceptions/misc.t:

[11:03] <dalek> roast: add a test for RT #69760

[11:03] <dalek> roast: review: https://github.com/perl6/roast/commit/7d2d2720f9

[11:03] <nwc10> jnthn: still "works" on "my" machine

[11:06] <jnthn> nwc10: I've no "beef" with that.

[11:07] <timotimo> may i change the gistification or whatever it is in the Whatever object? i get ok 521 - .post_types matches Quux => Whatever<-4272955866496737429> for one of my tests and likely that number is going to change every test run, so it will be in each and every diff in roast-data :(

[11:08] <FROGGS> change it to what?

[11:08] <jnthn> r: say *

[11:08] <p6eval> rakudo b10e2b: OUTPUT«*␤»

[11:08] <jnthn> r: say *.Str

[11:08] <p6eval> rakudo b10e2b: OUTPUT«WhateverCode.new()␤»

[11:08] <jnthn> r: say (*).Str

[11:08] <p6eval> rakudo b10e2b: OUTPUT«WhateverCode.new()␤»

[11:09] <timotimo> oh, weird. apparently it's the fault of dies_like

[11:09] <jnthn> I think it's more likely to be Str rather than gist, fwiw

[11:12] <timotimo> doesn't need to be fixed right away anyway

[11:14] <moritz> timotimo: just don't do a string comparison

[11:15] <moritz> the right of the => is used for smart-matching

[11:15] <moritz> so you can write  post_types => { .value ~~ Whatever }   or so

[11:15] <timotimo> not sure what type exactly that is, but i can look. it's the line information from the exception

[11:16] <timotimo> oh, it's just a list of line numbers

[11:17] *** Guest10382 is now known as ponbiki

[11:17] *** ObseLeTe joined
[11:19] <FROGGS> nqp: say("[" ~ ("ab123c" ~~ /<-[a]+[b]>+/) ~ "]")

[11:19] <p6eval> nqp: OUTPUT«[b123c]␤»

[11:19] <FROGGS> nqp: say("[" ~ ("ab123c" ~~ /<-[b]>+/) ~ "]")

[11:19] <p6eval> nqp: OUTPUT«[a]␤»

[11:20] <FROGGS> does that make sense?

[11:20] <dalek> rakudo/nom: c2910e2 | jnthn++ | src/Perl6/ (4 files):

[11:20] <dalek> rakudo/nom: Be sure to use line info cache.

[11:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2910e23bc

[11:20] <dalek> nqp: 6613df0 | jnthn++ | src/ (2 files):

[11:20] <dalek> nqp: Move compilation unit handling to backend class.

[11:20] <dalek> nqp: 

[11:20] <dalek> nqp: This should also help make the addition of --target=pbc a bit cleaner.

[11:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6613df0bc5

[11:20] <dalek> nqp: 9acc219 | jnthn++ | src/HLL/Compiler.pm:

[11:20] <dalek> nqp: Eliminate getprop/setprop usage.

[11:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9acc219edd

[11:21] <timotimo> oh, my test match is actually borked

[11:22] <moritz> is this actually something you want to test?

[11:23] <timotimo> # Got:      PostDeclaredGrammar 1   /   # Expected: PostDeclaredGrammar 1

[11:23] <timotimo> great, i love this kind of error :(

[11:23] <moritz> :(

[11:24] <timotimo> what i would like to test is that "PostDeclaredGrammar" shows up as a key in the %.post_types hash

[11:25] <timotimo> currently i'm trying to match against post_types => (PostDeclaredGrammar => 1).hash or without .hash

[11:25] *** mjreed joined
[11:26] <moritz> pass a closure and do   say .perl;  in the closure, for debugging

[11:27] <timotimo> oh, that sounds like a good idea

[11:27] <timotimo> didn't know i could do that

[11:28] <timotimo> Method 'perl' not found for invocant of class 'Integer'  -  er ... ?

[11:29] *** robinsmidsrod left
[11:29] *** robinsmidsrod joined
[11:30] <dalek> nqp: 3b3d8bb | jnthn++ | src/QAST/Operations.nqp:

[11:30] <dalek> nqp: Add nqp::getcodecuid and nqp::forceouterctx.

[11:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3b3d8bbba2

[11:30] <dalek> nqp: f5648cd | jnthn++ | src/stage0/ (9 files):

[11:30] <dalek> nqp: Update bootstrap to get added nqp:: ops.

[11:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f5648cda5e

[11:30] <dalek> nqp: 0968572 | jnthn++ | src/ (2 files):

[11:30] <dalek> nqp: Use new nqp:: ops in HLL::Compiler.

[11:30] <dalek> nqp: 

[11:30] <dalek> nqp: With this, it should now be fairly generic, with all VM-specifics in

[11:30] <dalek> nqp: either the backend object or behind nqp:: ops.

[11:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0968572b05

[11:38] <FROGGS> n: say("[" ~ ("ab123c" ~~ /<-[a]+[b]>+/) ~ "]")

[11:38] <p6eval> niecza v24-24-gbdc3343: OUTPUT«[b123c]␤»

[11:38] <FROGGS> okay, then maybe it should be "everything but a, plus b

[11:39] <FROGGS> "

[11:39] *** SmokeMachine joined
[11:40] <jnthn> iiuc, when you start with - you're subtracting from everything

[11:40] <jnthn> rn: say("[" ~ ("ab123c" ~~ /<-[ab]+[b]>+/) ~ "]")

[11:40] <FROGGS> k, well, makes sense somehow

[11:40] <p6eval> rakudo b10e2b, niecza v24-24-gbdc3343: OUTPUT«[b123c]␤»

[11:47] *** gcole left
[11:59] *** mjreed left
[12:02] *** ObseLeTe left
[12:16] *** kaleem joined
[12:22] *** brrt joined
[12:29] *** shinobicl joined
[12:35] <shinobicl> rakudo: my @a = ('A' ... 'N'), 'Ñ' ,( 'O' ... 'Z'); for @a {print $_}

[12:35] <p6eval> rakudo c2910e: OUTPUT«ABCDEFGHIJKLMNÑOPQRSTUVWXYZ»

[12:35] <shinobicl> rakudo: my @a = <A .. N>, 'Ñ' ,<O .. Z>; for @a {print $_}

[12:35] <p6eval> rakudo c2910e: OUTPUT«A..NÑO..Z»

[12:35] <shinobicl> rakudo: my @a = <A ... N>, 'Ñ' ,<O ... Z>; for @a {print $_}

[12:36] <p6eval> rakudo c2910e: OUTPUT«A...NÑO...Z»

[12:37] <jnthn> Note .. is sufficient in this case

[12:37] <jnthn> And you can probably drop the parens if you usethat

[12:37] <shinobicl> and how i do it with < and > ?

[12:37] <shinobicl> < and > does interpolate too?

[12:38] <jnthn> No

[12:38] <shinobicl> thanks

[12:38] <jnthn> << and >> do, but not ranges, afaik

[12:46] *** mtk left
[12:51] *** mtk joined
[12:56] *** wingfold joined
[12:57] *** wingfold left
[12:57] *** wingfold joined
[13:05] *** moritz joined
[13:11] *** SamuraiJack_ left
[13:24] <dalek> nqp-jvm-prep: d6a55c4 | jnthn++ | / (9 files):

[13:24] <dalek> nqp-jvm-prep: Implement the various nqp:: IO ops.

[13:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/d6a55c4f41

[13:24] <dalek> nqp-jvm-prep: bc0b098 | jnthn++ | nqp-src/NQPCORE.setting:

[13:24] <dalek> nqp-jvm-prep: Include I/O subs in the setting.

[13:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/bc0b0988da

[13:24] <dalek> nqp-jvm-prep: 084eb8b | jnthn++ | nqp-jvm-cc.nqp:

[13:24] <dalek> nqp-jvm-prep: Chase latest HLL backend API.

[13:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/084eb8b065

[13:24] <dalek> nqp-jvm-prep: b52d132 | jnthn++ | t/nqp/63-slurp.t:

[13:24] <dalek> nqp-jvm-prep: Now pass 63-slurp.t.

[13:24] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b52d1324fd

[13:31] <arnsholt> japhb: Looking at the most-wanted, we have basic DB interaction via https://github.com/perl6/DBIish

[13:32] <arnsholt> Mostly moritz++'s work I think

[13:32] *** skids left
[13:32] <moritz> and I mostly build on the work of mberends++ and arnsholt++

[13:32] <moritz> and jnthn++

[13:39] <arnsholt> Oh, and I see that you want unsigned native types. I'm not entirely sure how we'd do that, since both JVM (IIRC) and Parrot don't really have those concepts

[13:41] <moritz> newer java verisions have support for unsigned operations

[13:41] <arnsholt> Ah, spiffy

[13:41] <moritz> and if we nicely ask the parrot folks, maybe they add some too

[13:42] <arnsholt> Troo, troo

[13:47] *** benabik joined
[14:00] *** odoacre left
[14:14] *** PacoAir joined
[14:21] *** thou joined
[14:21] *** odoacre joined
[14:21] *** Patterner left
[14:23] *** PacoAir left
[14:23] *** PacoAir joined
[14:25] *** thou left
[14:26] *** Psyche^ joined
[14:26] *** Psyche^ is now known as Patterner

[14:28] *** PacoAir left
[14:28] *** PacoAir joined
[14:29] *** am0c left
[14:29] *** bluescreen10 joined
[14:40] *** xinming left
[14:42] *** xinming joined
[14:45] <dalek> nqp-jvm-prep: fb2d288 | jnthn++ | nqp-src/QRegex.nqp:

[14:45] <dalek> nqp-jvm-prep: Uncomment !reduce methods.

[14:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/fb2d288ba3

[14:45] <dalek> nqp-jvm-prep: 37e267c | jnthn++ | / (2 files):

[14:45] <dalek> nqp-jvm-prep: Support long string literals.

[14:45] <dalek> nqp-jvm-prep: 

[14:45] <dalek> nqp-jvm-prep: Turns out the serialization blob hit the limit.

[14:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/37e267c438

[14:45] <dalek> nqp-jvm-prep: 6b1059f | jnthn++ | nqp-src/NQPHLL.pm:

[14:45] <dalek> nqp-jvm-prep: Add HLL::Compiler and partial HLL::Backend.

[14:45] <dalek> nqp-jvm-prep: 

[14:45] <dalek> nqp-jvm-prep: HLL::Compiler has just two lines commented out; HLL::Backend has some

[14:45] <dalek> nqp-jvm-prep: methods that need implementing.

[14:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/6b1059fc8f

[14:45] <dalek> nqp-jvm-prep: dcdf4a1 | jnthn++ | / (2 files):

[14:45] <dalek> nqp-jvm-prep: Start cross-compiling the P6 regex compiler.

[14:45] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/dcdf4a1d08

[14:56] <[Coke]> Is there a sixier way to write this:

[14:56] <hoelzro> haha

[14:57] <hoelzro> "sixier"

[14:57] <hoelzro> I love it

[14:57] <[Coke]> (@a.pairs.sort:{$^a.value <=> $^b.value}).map:{$^a.key} # return positional keys in order by ascending value

[14:58] <colomon> +*.value should work with the sort, right?

[14:58] *** drKreso joined
[14:58] <moritz> you can even do @a.pairs.sort(+*.value).map: *.key

[14:58] <moritz> or @a.pairs.sort(+*.value)>>.key

[14:58] <drKreso> Hi I am having problems with Bailador

[14:58] <moritz> colomon++ was faster :-)

[14:58] <moritz> hi drKreso 

[14:58] <[Coke]> moritz: is >>. guaranteeing ordering?

[14:59] <drKreso> moritz: hi

[14:59] <moritz> [Coke]: return order, yes.

[14:59] <drKreso> ./panda/bin/panda install Bailador ==> t/03-response-content.t .. 2/7 Not enough positional parameters passed; got 0 but expected 1   

[14:59] <moritz> [Coke]: not execution order though

[14:59] <moritz> drKreso: looks like https://github.com/tadzik/Bailador/issues/5

[14:59] <moritz> drKreso: I'm not very familiar with Bailador, so I don't know if that's a real problem or not

[15:00] <drKreso> can i skip it somehow?

[15:00] <moritz> drKreso: I think you can do a   panda --notest install Bailador   or so

[15:01] *** wingfold left
[15:02] <nwc10> jnthn: the usual.

[15:02] *** _jaldhar left
[15:03] <drKreso> moritz: Thanks.

[15:03] *** wingfold joined
[15:08] <colomon> wow, Bailador has a lot of dependencies

[15:08] <colomon> hmmm, all tests pass for me.

[15:10] <drKreso> Maybe I have older rakudo

[15:10] *** skids joined
[15:12] <moritz> I doubt it; the first report of that issue is with a pretty new rakudo (2013.02.1 release)

[15:12] <colomon> hmmm, that's a bit newer than mine, maybe.  update rakudo...

[15:15] <drKreso> I have it installed, I can see Bailador in lib folder... but how to run "site" wizard something like "dancer -a MyWeb::App" 

[15:16] <moritz> drKreso: there doesn't seem to be one yet

[15:17] <drKreso> Hm ,so how do I use it?

[15:18] <mberends> regarding an improved DBI for Perl 6, I am very impressed with Java Data Objects (JDO).  The abstractions are very well thought out and portably cover both relational and non relational stores (eg Google AppEngine).  The code is implemented as Aspect Oriented Programming which Perl 6 could also do very nicely.

[15:19] <arnsholt> Cool! Have you mentioned this to tbunce?

[15:21] <mberends> No, haven't contacted him for a few months. He is also interested in making Perl's database object hierarchies analogous to Java's but he was thinking of only JDBC so far.

[15:24] <arnsholt> Yeah, mostly JDBC was my impression as well

[15:27] <moritz> drKreso: you look at how the examples work, and at the documentation, and go from there

[15:28] * colomon 's Linux box shut down compiling rakudo again.  :(

[15:29] <hoelzro> =(

[15:30] <colomon> the new box cannot get here soon enough.

[15:31] <moritz> colomon: happens my laptop too :(

[15:32] <moritz> and ENOFUNDSFORNEWONE

[15:32] <drKreso> moritz: Thanks. 

[15:40] *** FROGGS left
[15:43] <dalek> nqp-jvm-prep: 85bea4b | jnthn++ | / (2 files):

[15:43] <dalek> nqp-jvm-prep: Implement nqp::getcodecuid.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/85bea4bb65

[15:43] <dalek> nqp-jvm-prep: 1bd3f65 | jnthn++ | nqp-src/NQPCORE.setting:

[15:43] <dalek> nqp-jvm-prep: Fix thinkos.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1bd3f658d2

[15:43] <dalek> nqp-jvm-prep: d1de3ee | jnthn++ | src/org/perl6/nqp/runtime/ (2 files):

[15:43] *** benabik left
[15:43] <dalek> nqp-jvm-prep: Implement providing argv to the entry point.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/d1de3ee4f3

[15:43] <dalek> nqp-jvm-prep: e58be0c | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[15:43] <dalek> nqp-jvm-prep: Fix index out of range SC bug.

[15:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e58be0c942

[15:49] *** drKreso left
[15:49] *** gcole__ joined
[15:59] *** robinsmidsrod left
[16:00] *** robinsmidsrod joined
[16:02] *** wingfold left
[16:03] *** FROGGS joined
[16:04] <FROGGS> home sweet home \o/

[16:08] <sergot> hi o/

[16:08] *** wingfold joined
[16:08] <FROGGS> hi

[16:08] <nwc10> jnthn: breaks on my machine :-(

[16:09] <nwc10> http://pasta.test-smoke.org/451

[16:09] <nwc10> looks to be all the same: Exception in thread "main" java.lang.RuntimeE

[16:09] <nwc10> xception: Wrong number of arguments passed; expected 0..0, but got 1

[16:09] <nwc10>        at org.perl6.nqp.runtime.Ops.checkarity(Ops.java:722)

[16:09] *** kresike left
[16:10] <jnthn> nwc10: Does nqptest work, just not test?

[16:11] <nwc10> looks like it

[16:11] <nwc10> pass-so-far

[16:13] <[Coke]> masak?

[16:14] <nwc10> yes, passes all but the test that needs ICU

[16:18] *** wingfold left
[16:20] *** kaleem left
[16:21] <dalek> nqp-jvm-prep: be4c3da | jnthn++ | src/org/perl6/nqp/sixmodel/reprs/ContextRefInstance.java:

[16:21] <dalek> nqp-jvm-prep: Implement existskey in ContextRef.

[16:21] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/be4c3dae26

[16:21] <dalek> nqp-jvm-prep: 3651628 | jnthn++ | src/org/perl6/nqp/sixmodel/KnowHOWMethods.java:

[16:21] <dalek> nqp-jvm-prep: Ensure KnowHOWs get a .WHO set up.

[16:21] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/36516286b7

[16:21] <dalek> nqp-jvm-prep: 923bfe8 | jnthn++ | / (4 files):

[16:21] <dalek> nqp-jvm-prep: Make nqp::list and nqp::hash consider HLL config.

[16:21] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/923bfe8e03

[16:21] <dalek> nqp-jvm-prep: 0d59dca | jnthn++ | nqp-src/NQPCORE.setting:

[16:21] <dalek> nqp-jvm-prep: Make sure .push etc. always work on an @foo.

[16:21] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/0d59dca486

[16:21] <dalek> nqp-jvm-prep: 76a5199 | jnthn++ | nqp-src/QRegex.nqp:

[16:21] <dalek> nqp-jvm-prep: Sync with nqp QRegex (for %!marks).

[16:21] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/76a51994ac

[16:23] *** brrt left
[16:26] <jnthn> nwc10: None of those fix the busted make test...I'll get there in a bit.

[16:32] *** zby_home_ joined
[16:34] *** daxim left
[16:37] *** tokuhiro_ joined
[16:41] *** spanner left
[16:42] *** SunilJoshi joined
[16:49] *** robinsmidsrod left
[16:50] *** shinobicl left
[16:50] *** SamuraiJack_ joined
[16:51] *** robinsmidsrod joined
[16:52] *** odoacre left
[16:54] *** odoacre joined
[16:59] *** robinsmidsrod left
[16:59] *** SunilJoshi left
[17:00] *** tokuhiro_ left
[17:00] *** robinsmidsrod joined
[17:03] *** SunilJoshi joined
[17:06] *** steven__ left
[17:17] <colomon> huh.  updated my rakudo, and now I do get the failure in Bailador.  Must be a very recent change.

[17:22] <colomon> has there been a recent change to Match.list?

[17:30] <japhb> arnsholt: I did link DBIish in most-wanted, as the WIP for the DBI-like interface style.

[17:30] <japhb> *did already

[17:30] <moritz> the most recent change in src/core/Match.pm was 2012-10-10

[17:32] <japhb> arnsholt, mberends, is Tim Bunce still interested in working on DB modules for Perl 6?  I thought he'd gone off to other pastures ....

[17:32] *** Chillance joined
[17:40] <mberends> japhb: I think he was disappointed by the orders-of-magnitude difference in efficiency between p6 implementations and p5 (he wrote https://metacpan.org/module/Devel::NYTProf) and seems to want to provide overall direction to volunteers who will the heavy lifting.

[17:40] <mberends> *who will do

[17:41] <japhb> Ah, but he is still interested in having at least that much connection to it still ... good.

[17:43] *** fhelmberger left
[17:45] <mberends> Tim Bunce sent a very upbeat message to the Perl Reunification Summit (http://mdk.per.ly/2012/08/20/prs2012-perl5-perl6-reunification-summit/ and http://blogs.perl.org/users/liz/2012/08/as-some-of-you-may.html) because he regretted being unable to attend.

[17:51] <PerlJam> you could always email him

[17:51] <PerlJam> or talk to him in real time on #p5p

[17:52] <mberends> oh. silly /me

[17:55] *** donaldh left
[17:56] <PerlJam> (well, he's not active on #p5p just now, but he was about 19 hours ago)

[17:57] <diakopter> is that magnet or freenode

[17:58] <PerlJam> magnet

[17:58] <diakopter> or twitter hashtag >.<

[18:00] * moritz hopes that some engineer at twitter changes all HASH tags to their sha1 hash on April 1st

[18:01] <jnthn> Talking of hash...

[18:01] * jnthn just discovered an accidental reliance on hash ordering... :/

[18:01] <jnthn> Hopefully easy to fix.

[18:01] <jnthn> In the NQP MOP of all places...

[18:02] <diakopter> mop it up...

[18:06] *** fgomez left
[18:06] *** dakkar left
[18:07] <arnsholt> japhb: Yeah, I noticed afterwards. I was looking at library wrappers first, and then modules =)

[18:09] *** yves_ joined
[18:13] *** kivutar joined
[18:14] <mberends> Talking of hash... jnthn++ is already handling all this well, it's a good explanation of the pitfalls of hashes in language implementation: http://blog.headius.com/2012/09/avoiding-hash-lookups-in-ruby.html (posted by scrottie in magnet:perl11 http://irclog.perlgeek.de/perl11/2012-11-08#i_6137030)

[18:15] *** fgomez joined
[18:25] <moritz> mberends: the interesting thing about your link is that it talks (among other things) about invalidating method caches of subclasses, which Rakudo doesn't do yet

[18:26] <moritz> and which is why this example here fails:

[18:26] <moritz> r: use MONKEY_TYPING; augment class Any { method flurb() { } }; "foo".flurb()

[18:26] <p6eval> rakudo c2910e: OUTPUT«No such method 'flurb' for invocant of type 'Str'␤  in block  at /tmp/2jILNgbo21:1␤␤»

[18:26] <moritz> r: say Str ~~ Any

[18:26] <p6eval> rakudo c2910e: OUTPUT«True␤»

[18:27] *** gcole__ left
[18:31] *** benabik joined
[18:43] <arnsholt> timotimo: Possibly relevant to your interests: https://github.com/arnsholt/Net-ZMQ/commit/97a9c6dfb62bd1c632c32dd54044ba801ef220eb

[18:43] *** SunilJoshi left
[18:44] *** fgomez left
[18:44] *** steven___ joined
[18:44] <arnsholt> timotimo++ # figuring out how to do basic testing

[18:46] <dalek> nqp: 361feca | jnthn++ | src/how/NQP (3 files):

[18:46] <dalek> nqp: Attribute ordering matters; don't use a hash.

[18:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/361feca4ac

[18:48] <dalek> nqp-jvm-prep: 4b71902 | jnthn++ | nqp-src/QRegex.nqp:

[18:48] <dalek> nqp-jvm-prep: ParseShared is no longer lexical.

[18:48] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/4b71902f5f

[18:48] <dalek> nqp-jvm-prep: 2fe1938 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[18:48] <dalek> nqp-jvm-prep: Basic support for iterating scopes.

[18:48] *** dalek left
[18:48] <jnthn> :/

[18:49] *** dalek joined
[18:49] *** ChanServ sets mode: +v dalek

[18:49] <arnsholt> Heh. I suspect dalek only remembers one floodlimit parameter, or something like that

[18:50] <japhb> jnthn, looking at that nqp commit, it appears correct behaving code was actually shorter and more efficient too.  Pretty much all win.  :-)

[18:51] <jnthn> indeed.

[19:04] *** Liz joined
[19:05] *** Liz is now known as lizmat

[19:10] <arnsholt> jnthn: Nothing actually using VMArray in Parrot NQP/Rakudo yet, right?

[19:11] <jnthn> arnsholt: Correct, they are but stubs.

[19:12] <arnsholt> Cool. I'll look into extending it so that Buf can be VMArray REPRed then

[19:12] *** SamuraiJack_ left
[19:15] *** Chillance left
[19:15] <arnsholt> I suspect it'll involve either a new HOW or modifying ClassHOW, that make sense?

[19:16] <jnthn> I've somewhat expect we'll end up with some kinda primitve array meta-object at some point.

[19:16] <jnthn> *expected

[19:17] <arnsholt> Right. I'll give that a whack as well, then

[19:20] *** lichtkind__ joined
[19:22] *** alester joined
[19:23] *** lichtkind_ left
[19:23] <nwc10> jnthn: nqptest passes (except for the ICU one)

[19:27] *** sqirrel left
[19:29] <dalek> nqp-jvm-prep: 81e35e7 | jnthn++ | / (2 files):

[19:29] <dalek> nqp-jvm-prep: Implement nqp::getmessage.

[19:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/81e35e795f

[19:29] <dalek> nqp-jvm-prep: 2219d82 | jnthn++ | src/org/perl6/nqp/ (2 files):

[19:29] <dalek> nqp-jvm-prep: Fix various buffering issues, so we get output.

[19:29] <dalek> nqp-jvm-prep: 

[19:29] <dalek> nqp-jvm-prep: Need to revisit this area later.

[19:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/2219d8208d

[19:29] <dalek> nqp-jvm-prep: 49b84c9 | jnthn++ | nqp-src/QRegex.nqp:

[19:29] <dalek> nqp-jvm-prep: Add parse tree dumper, from NQP repo.

[19:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/49b84c9425

[19:29] <dalek> nqp-jvm-prep: 7775882 | jnthn++ | nqp-src/NQPHLL.pm:

[19:29] <dalek> nqp-jvm-prep: Use nqp::getmessage rather than stringification.

[19:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/7775882621

[19:29] <dalek> nqp-jvm-prep: 458254f | jnthn++ | nqp-src/QASTNodes.nqp:

[19:29] <dalek> nqp-jvm-prep: Missing null check.

[19:29] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/458254fb15

[19:31] <alester> masak: I still haven't forgotten you.

[19:31] <phenny> alester: 25 Feb 01:36Z <[Coke]> tell alester to check out http://www.warrenellis.com/?p=14655

[19:31] <alester> This work project is just killing me.

[19:31] <alester> We roll tonight.

[19:31] *** benabik left
[19:31] <alester> phenny: Tell Coke thanks for the ack-ack link

[19:32] <diakopter> probahly phenny wants [Coke]

[19:32] <alester> I usually do in the afternoon, too.

[19:33] <alester> phenny: Tell [Coke] thanks for the ack-ack link

[19:34] *** domidumont left
[19:34] <japhb> Heh, I bet phenny is case-sensitive WRT commands -- and it wants lowercase.  :-)

[19:36] <diakopter> phenny: tell alester see

[19:36] <phenny> diakopter: I'll pass that on when alester is around.

[19:37] <nwc10> jnthn: nqptest still passes (except for the ICU one)

[19:37] *** gcole joined
[19:37] <alester> I give up w/phenny.

[19:37] <phenny> alester: 19:36Z <diakopter> tell alester see

[19:39] *** wingfold joined
[19:42] *** gcole left
[19:42] *** FROGGS left
[19:42] *** am0c joined
[19:55] *** wingfold left
[19:55] *** uvtc joined
[19:58] *** fgomez joined
[19:59] *** census joined
[20:10] <uvtc> What exactly is meant by "container" in Perl 6? From previous discusssions, I see that $s, @a, and %h may or may not refer to containers... Are scalars, arrays, and hashes containers?

[20:12] <uvtc> I see that there's a "Containers" doc, http://perlcabal.org/syn/S32/Containers.html , but

[20:12] <uvtc> no intro there.

[20:13] <PerlJam> uvtc: those are all containers to me.

[20:14] <PerlJam> mostly you talk about containers when you're concerned about operations that happen on the container vs. operations that happen on the value that's in the container

[20:14] <uvtc> r: my @a; say @a.WHAT; my $x; say $x.WHAT; #<--- Scalar?

[20:14] <p6eval> rakudo c2910e: OUTPUT«(Array)␤(Any)␤»

[20:14] <uvtc> Is a Parcel a container?

[20:14] <moritz> uvtc: Scalar is a container type. You basically never see it

[20:14] *** gcole joined
[20:15] *** benabik joined
[20:17] <uvtc> I think Perl 6 may use the term "container" in a slightly different sense than, say, Java (where a container is a class that like the ones in java.util).

[20:18] <rindolf> Hi all.

[20:18] <rindolf> Is TimToady here?

[20:19] <moritz> rindolf: this is not we-contact-TimToady-here channel. If you want to do that, please take it private message

[20:19] <PerlJam> rindolf: depends on what you mean by "here"  :-)

[20:19] <timotimo> for 1..* -> $i { 1; } # making this not use up a crazy amount of space is how hard? could rakudo see that the early parts of the list are not used any more at all?

[20:19] <rindolf> moritz: OK, sorry.

[20:19] <moritz> timotimo: in sink context? or other context?

[20:20] <timotimo> perl6 -e that code gives me steadily growing memory consumption

[20:20] <rindolf> PerlJam: http://www.youtube.com/watch?v=9m-kbBamg_U - that's what I mean - excerpt from Sesame Street.

[20:20] <timotimo> i believe this is in sink context then?

[20:20] *** kivutar left
[20:20] <skids> Well, test with "sink for"

[20:21] <moritz> timotimo: doesn't seem to grow all that much for me

[20:22] <moritz> in relation to typical Rakudo memory consuption, that is

[20:22] <timotimo> oh?

[20:23] <moritz> but still grows

[20:23] <timotimo> i like those bugs that just end in coke asking "can this be closed" and followed by silence for 1 to 2 years

[20:23] <moritz> timotimo: it might not be rocket science to improve it.

[20:24] <moritz> timotimo: the list iteration code in sink context isn't particularly optimized, iirc

[20:24] <uvtc> How do I create a list in Perl 6? I see that `<foo bar baz>` gives me a Parcel. If I assign it to an array, as in `my @a = <foo bar baz>`, I get an array. So far, I haven't see a "List" obect, afaik.

[20:24] <timotimo> would it be acceptable to special-case ranges?

[20:24] <moritz> uvtc: try <a b c>.list

[20:24] <timotimo> r: <foo bar baz>.list.perl.say

[20:24] <p6eval> rakudo c2910e: OUTPUT«("foo", "bar", "baz").list␤»

[20:25] <uvtc> r: say <a b c>.list.WHAT

[20:25] <p6eval> rakudo c2910e: OUTPUT«(List)␤»

[20:25] <moritz> timotimo: it would, as long as it's not done inside any tight loop

[20:25] <uvtc> Thanks. Though, what is the purpose of .list? Where would I need (or, where would I end up with) a list?

[20:25] <moritz> timotimo: src/core/MapIter.pm, method reify($n = 1, :$sink)

[20:26] <moritz> timotimo: that's what might need optimizing

[20:26] <timotimo> what do you mean "not done inside any tight loop"?

[20:26] <moritz> uvtc: it's used for lazy, sequential containers where the items aren't necessarily assignables

[20:27] <PerlJam> uvtc: .list is useful when you only want the positional bits of a parcel  :)

[20:27] <moritz> timotimo: if you want to special-case ranges, don't do the check if something is a range inside the loop that does the actual iteration

[20:27] <uvtc> PerlJam: So, when you have a Parcel in-hand and want to turn it into a list?

[20:28] <moritz> another use casaes for .list:

[20:28] <timotimo> oh my. suddenly: PIR code

[20:28] <moritz> r: my $a = (1, 2, 3); my $c = 0; $c++ for $a; say $c

[20:28] <p6eval> rakudo c2910e: OUTPUT«1␤»

[20:28] <uvtc> I see at doc.perl6.org , about Array it says, "An Array is a List which forces all its elements to be scalar containers, which means you can assign to array elements." but am trying to make sense of that.

[20:28] <moritz> r: my $a = (1, 2, 3); my $c = 0; $c++ for $a.list; say $c

[20:28] <p6eval> rakudo c2910e: OUTPUT«3␤»

[20:29] <moritz> r: my @a := <a b c>; @a[0] = 3; # you can't assign here, because @a[0] isn't a container

[20:29] <p6eval> rakudo c2910e: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/fMGh8Vmfaa:1␤␤»

[20:29] <moritz> r: my @a := <a b c>.list; @a[0] = 3;

[20:29] <p6eval> rakudo c2910e: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/OLsOP8M3ov:1␤␤»

[20:29] <moritz> but

[20:30] <moritz> my $scalar = 0; my @a := ($scalar, 1, 2); @a[0] = 42; # should work, because the first element is a Scalar container

[20:30] <moritz> r: my $scalar = 0; my @a := ($scalar, 1, 2); @a[0] = 42; # should work, because the first element is a Scalar container

[20:30] <p6eval> rakudo c2910e:  ( no output )

[20:32] <uvtc> Why would I want to do: `my @a := (1, 2, 3)`? It looks like I'm creating an array, but then assigning a Parcel to it. ... Yet it seems to work like an array, regardless.

[20:32] <uvtc> r: my @a = <foo bar baz>; say @a.WHAT;  # Parcel?

[20:32] <p6eval> rakudo c2910e: OUTPUT«(Array)␤»

[20:32] <moritz> uvtc: := doesn't assign

[20:32] <PerlJam> uvtc: := is binding

[20:33] <moritz> assignment to an array empties it, and then re-fills again

[20:33] <uvtc> moritz: Well, `:=` assigns a reference, correct? Which is referred to as "binding", correct?

[20:33] <moritz> binding to an array variable replaces the array with whatever is on the right

[20:33] <moritz> uvtc: I tend to avoid that phrasing, because it's quite ambiguous, IMHO

[20:35] <uvtc> moritz: FWICT, $s, @a, and %h are all references, but they're automatically dereferenced when you use them, so folks tend not to even notice. Is that right?

[20:36] <moritz> uvtc: what do you mean by "are all references"?

[20:37] <uvtc> They are names that refer to objects. That is, even though folks tend to say, "$x is 5", what's really going on under the hood is that "$x refers to an Int object who's value is 5, but it's automatically dereferenced so you won't even notice". Right?

[20:38] *** PacoAir left
[20:38] <uvtc> Reference == "pointer"

[20:38] <moritz> there's no difference between "5" and "an Int object who's value is 5"

[20:38] <uvtc> (Though I seem to recall, in C++ there's a difference between references and pointers, in Perl 6 they seem to be general descriptive terms which are synonyms.)

[20:39] <moritz> let my try it this way

[20:39] <moritz> my $x = 42; # $x is a variable, which is bound to a Scalar, which contains the 42

[20:39] <dalek> nqp-jvm-prep: 9a5e5a5 | jnthn++ | nqp-src/QASTNodes.nqp:

[20:39] <dalek> nqp-jvm-prep: Do some null checks correctly.

[20:39] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/9a5e5a5e1f

[20:39] <dalek> nqp-jvm-prep: 9fb6e7e | jnthn++ | / (2 files):

[20:39] <dalek> nqp-jvm-prep: Some small tweaks towards getting backend working.

[20:39] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/9fb6e7e19b

[20:40] <uvtc> "bound to" == "refers to" == "points to" .Correct?

[20:40] *** PacoAir joined
[20:40] <moritz> so you can assign to $x, $x = 23

[20:40] <moritz> which in turn calls the STORE method on the scalar

[20:40] <moritz> yes

[20:40] *** SmokeMachine left
[20:40] <moritz> but you can also say

[20:40] <moritz> my $x := 42;

[20:40] *** thou joined
[20:41] <moritz> in which case the variable $x contains the Int directly, without a Container

[20:41] <moritz> which means you cannot assing to it, because Int has no .STORE method

[20:41] * PerlJam reads an interview of moritz

[20:43] *** PacoAir left
[20:43] *** PacoAir joined
[20:43] * moritz feels famous, in this small echo chamber

[20:43] <PerlJam> oh.  Hmm.  this is a redux of some earlier interview.

[20:43] * uvtc is currently interviewing moritz , live!

[20:43] <PerlJam> uvtc++

[20:44] <moritz> PerlJam: yes, there's a link to the original one at the bottom

[20:44] * jnthn waits for the cross-compiler to cross-compile the compiler...

[20:44] <PerlJam> moritz: I want to know more about this "People of Perl 6 club"  ;)

[20:45] <nwc10> jnthn: it's getting that close?

[20:45] <timotimo> jnthn: that sounds like we are getting dangerously close to a fully cross-compiled nqp on jvm :)

[20:45] <uvtc> moritz: I think I'm having some basic misunderstanding of terminology here. I think of "$x" as a name (an identifier). It may refer to something, or may not. But you're calling it a *variable*. And theres also a container involved sometimes as well. Hm.

[20:46] <uvtc> s/theres/there's/

[20:46] <moritz> uvtc: $x is a variable, which means it's an entry in some lexpad. It's name is '$x'

[20:47] <moritz> uvtc: the entry in the lexpad is basically a pointer to an object

[20:47] <uvtc> There's that word again: "lexpad". I don't know what that is. It haunts me. :)

[20:47] <moritz> uvtc: and usually that object is a container, for $x is Scalar

[20:48] * uvtc dreams (neigh, a nightmare) that he's in a cornfield, late at night, searching for the lexpad where the helipod can land so he can get out...

[20:48] <moritz> uvtc: the compiler keeps track of all the known variables for each scope. The runtime representation of this tracking is a lexpad

[20:48] <uvtc> (ouch. s/neigh/nay)

[20:48] <PerlJam> uvtc: you can think of a lexpad as a per-scope symbol table.

[20:48] <moritz> long name "lexical pad"

[20:48] <PerlJam> (sorta)

[20:49] <moritz> note that there two sorts of tracking of variables

[20:49] <moritz> the one is inside the compiler, so that we know if a variable is declared or not, and if yes, where it was declared, what's its type etc.

[20:50] *** kaare_ left
[20:50] <moritz> and then there's a runtime structure, which contains pointers to the values stored in the variables. That runtime structure is commonly called "lexical pad" or "lexpad"

[20:50] <moritz> and the reason you can't optimize out the lexpads (in the general case) is closures

[20:50] *** thou_ joined
[20:51] *** thou left
[20:51] <moritz> my $closure = do { my $x = 42; sub () { say 42 } }; $closure()

[20:51] <moritz> nr: my $closure = do { my $x = 42; sub () { say 42 } }; $closure()

[20:51] <PerlJam> moritz: careful ... you'll have covered an entire CS curriculum if you keep going  :

[20:51] <p6eval> niecza v24-24-gbdc3343: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/wtA5wBMaNF line 1:␤------> [32mmy $closure = do { my [33m⏏[31m$x = 42; sub () { say 42 } }; $closure()[0m␤␤42␤»

[20:51] <p6eval> ..rakudo c2910e: OUTPUT«42␤»

[20:51] <PerlJam> er :)

[20:51] <moritz> nr: my $closure = do { my $x = 42; sub () { say $x } }; $closure()

[20:52] <p6eval> rakudo c2910e, niecza v24-24-gbdc3343: OUTPUT«42␤»

[20:52] <uvtc> (Curious about the name "pad". "pad" ~~ "paddock"? Or maybe like a pad of paper on which to write notes about lexicals.)

[20:52] <moritz> uvtc: pad of paper

[20:52] <PerlJam> uvtc: like a pad of paper

[20:52] <PerlJam> uvtc: "scratch pad"

[20:52] <uvtc> Ok.

[20:52] <moritz> so, $closure must know somethough about $x

[20:53] <moritz> which the compiler achives by sticking a pointer the lexpad and to the actual code object into a common structure, and calls it $closure

[20:53] <uvtc> moritz: Right. The sub was declared when $x was in scope, so it knows about it. A closure.

[20:54] * uvtc is rereading what's been written above...

[20:54] <uvtc> PerlJam: Yes, I don't have a CS education. Did physics instead.

[20:55] <moritz> uvtc: me too

[20:55] <uvtc> And now, here I am, up the creek without a lexpaddle.

[20:55] *** kivutar joined
[20:55] <nwc10> jnthn: nqptest still passes (except for the ICU one)

[20:56] <moritz> so, if you do

[20:56] <moritz> my $x = 42;

[20:56] *** fgomez left
[20:56] <moritz> then the lexpad entry for $x is a pointer to a Scalar object

[20:56] *** zby_home_ left
[20:56] <uvtc> yup

[20:57] <moritz> and that Scalar object has another pointer, which points to an Int

[20:57] <moritz> so, that allows you to do 

[20:57] <moritz> sub f($a is rw) { $a = 18 }; f($x)

[20:58] <moritz> so that passes the Scalar object (which we usually just call "the container") to function f

[20:58] <dalek> nqp-jvm-prep: fd60679 | jnthn++ | src/org/perl6/nqp/ (4 files):

[20:58] <dalek> nqp-jvm-prep: Primitives for in-process JAST => JVM bytecode.

[20:58] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/fd606798c0

[20:58] <dalek> nqp-jvm-prep: 9819d20 | jnthn++ | / (2 files):

[20:58] <dalek> nqp-jvm-prep: Flesh out backend compilation stages.

[20:58] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/9819d20826

[20:58] <moritz> which means that if f() modifies $a, then $x also changes

[20:59] <moritz> note that we don't only just need that for 'rw' arguments

[20:59] <moritz> but also for things like

[20:59] <moritz> my @a; @a[0] = 42;

[20:59] <uvtc> Ok. So, when you call `f($x)`, it's changing the Scalar to point to a different Int.

[20:59] <moritz> uvtc: that's what the assignment inside of f does, not the call itself (just want to make sure we don't conflate stuff here)

[21:00] <uvtc> yup

[21:00] <moritz> ok, back to  my @a; @a[0] = 42;

[21:00] <moritz> that only works because indexing into an array returns a Scalar

[21:00] <moritz> otoh if you do

[21:00] <moritz> r: (0, 1, 2)[0] = 42

[21:00] <p6eval> rakudo c2910e: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/ZJz_IK2Vrc:1␤␤»

[21:01] <moritz> here the [0] indexes into a Parcel

[21:01] *** lustlife left
[21:01] <moritz> and indexing into the Parcel just returns whatever is there

[21:01] <moritz> and that's not a Scalar, it's an Int

[21:01] <moritz> you can't assing to it

[21:01] <uvtc> Gotcha.

[21:01] <moritz> but if it happens to be a Scalar, it works again

[21:01] <uvtc> Ok.

[21:02] <moritz> r: my $s = 42; ($s, 1, 2)[0] = 23; say $s

[21:02] <p6eval> rakudo c2910e: OUTPUT«23␤»

[21:02] <moritz> so, a List is like a Parcel in that regard

[21:02] <moritz> the difference is that a List has more magic that makes it lazy

[21:02] <moritz> which is why the return value from a .map is a List

[21:03] <uvtc> So this comes back to the difference between List and Array, where the docs say, "An Array is a List which forces all its elements to be scalar containers, which means you can assign to array elements."

[21:03] <moritz> r: say (0..*).map(*+1).WHAT

[21:03] <p6eval> rakudo c2910e: OUTPUT«(List)␤»

[21:03] <moritz> uvtc: right

[21:03] <uvtc> Wait. Why would `map` return a List? I may want to save what it returns and assign to its elements later on.

[21:03] *** lustlife joined
[21:04] <raiph> heh. if i were to claim that P6 is parsed by a single P6 regex, what would that regex be?

[21:04] <uvtc> Oh, I see. `my @a = map ...` would give me an array in @a.

[21:04] <moritz> uvtc: correct

[21:04] <moritz> uvtc: what doesn't work is    (0..*).map(...)[2] = 42

[21:04] <PerlJam> moritz: I know others (and probably you too) have written about Lists and Parcels and such in the past, but you're doing an excellent job explaining it right now.   Maybe you should consider another post on the subject.  Just take the last several minutes of IRC and munge it into an article.  

[21:05] <uvtc> Thanks, moritz . Going to go back and read again what you've told me (above).

[21:05] <moritz> PerlJam: I thought the same, basically :-)

[21:05] <PerlJam> moritz++

[21:05] <skids> definitely one of the clearer and less cluttered explanations which I have seen.  moritz++

[21:06] <uvtc> PerlJam: Good idea. I'm trying to understand it so I can put an article together, but I've only got this so far: https://github.com/uvtc/compact-perl6-tut/blob/master/docs/assignment-and-binding.md and it's not yet correct.

[21:06] <PerlJam> raiph: complicated.  :)

[21:06] <nwc10> jnthn: nqptest still passes (except for the ICU one)

[21:06] <raiph> PerlJam: heh. I'm thinking rule comp_unit

[21:07] <moritz> TOP

[21:07] <moritz> :-)

[21:07] <dalek> rakudo/nom: f4e96b0 | moritz++ | README:

[21:07] <dalek> rakudo/nom: README: update download location for star packages

[21:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4e96b0904

[21:08] <timotimo> https://rt.perl.org/rt3/Ticket/Display.html?id=76928  -  is this closable? it looks that way to me.

[21:09] *** fgomez joined
[21:10] * moritz takes a look

[21:10] <moritz> yes, closable with tests

[21:12] <timotimo> i will think about adding a test for that tomorrow. need to be up early and still got stuff to pack :)

[21:13] <moritz> note that you'll want to use .HOW.gist instead of say .HOW

[21:13] <moritz> and now it's bed time for me

[21:14] <jnthn> 'night, moritz

[21:14] <timotimo> sure

[21:15] <timotimo> good night, happy perl (not only) 6 people!

[21:19] *** spider-mario left
[21:20] *** rindolf left
[21:22] *** thou_ left
[21:29] *** am0c left
[21:42] *** benabik left
[21:52] *** bluescreen10 left
[21:54] *** bluescreen10 joined
[21:59] *** skids left
[22:03] *** DrPete joined
[22:04] *** lustlife left
[22:06] *** kivutar left
[22:06] *** spider-mario joined
[22:08] *** TheVenetianMask left
[22:22] *** drKreso joined
[22:31] *** wk left
[22:31] <jnthn> Must doesn't work yet, but:

[22:31] <jnthn> $ java -cp 3rdparty/bcel/bcel-5.2.jar;.;bin NQPJVM -e "say('omgz nqp running on jvm')"

[22:31] <jnthn> omgz nqp running on jvm

[22:31] <colomon> \o/

[22:32] <colomon> "Must"?

[22:33] *** drKreso left
[22:33] <diakopter> o_O

[22:33] <diakopter> "Much?"

[22:33] <diakopter> "Much"?

[22:33] <jnthn> *most

[22:33] <jnthn> Or much

[22:33] <jnthn> I dunno how much yet or how many root causes :)

[22:34] <diakopter> what's bin

[22:34] <diakopter> oh I see

[22:36] <dalek> nqp-jvm-prep: a63c38b | jnthn++ | nqp-src/ (3 files):

[22:36] <dalek> nqp-jvm-prep: Use high-level join and fix some op usages.

[22:36] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a63c38ba9a

[22:36] <dalek> nqp-jvm-prep: b93079a | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[22:36] <dalek> nqp-jvm-prep: Disable colliding fate sorting for now.

[22:36] <dalek> nqp-jvm-prep: 

[22:36] <dalek> nqp-jvm-prep: Seems it's not quite right...and we get righter results without it.

[22:36] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b93079a196

[22:36] <dalek> nqp-jvm-prep: 266da05 | jnthn++ | / (2 files):

[22:36] <dalek> nqp-jvm-prep: Start cross-compiling NQP itself.

[22:36] <dalek> nqp-jvm-prep: 

[22:36] <dalek> nqp-jvm-prep: We now survive "say('hello world')" running entirely on the JVM, with

[22:36] <dalek> nqp-jvm-prep: NQP's grammar/actions parsing and building the AST, the QAST -> JVM

[22:36] <dalek> nqp-jvm-prep: bytecode happening in-process and then evaluating the result. Much to

[22:36] <dalek> nqp-jvm-prep: bug hunt, but very simple things work. Note, -e and file input work

[22:36] <dalek> nqp-jvm-prep: but the REPL does not yet.

[22:36] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/266da055d8

[22:42] <dalek> nqp-jvm-prep: ce56d86 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[22:42] <dalek> nqp-jvm-prep: Fixed fate sort, hopefully.

[22:42] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ce56d86e41

[22:45] *** spider-mario left
[22:46] *** pmurias joined
[22:47] <pmurias> jnthn: re new backend API will that enable -Cjvm and -Cjs options?

[22:49] <jnthn> pmurias: Not directly I think, but it's a move towards providing that if we want to try and support cross-compilation generally.

[22:50] <pmurias> jnthn: the way I support having common sc ids in nqp-js it that rather than having a stable ids option after parsing I convert the same ast to both pbc and js

[22:59] *** alester left
[23:01] *** araujo left
[23:08] *** snearch joined
[23:10] *** snearch left
[23:11] <census> Hi!  nonperl5 q.  Does anybody know fortran?

[23:11] <census> I would like to translate some fortran code between fortran and perl.

[23:11] <census> But I don't know a lick of fortran, unfortunately

[23:12] <census> http://scsys.co.uk:8002/232718?ln=on&tidy=on&hl=on&submit=Format+it!

[23:12] <census> thank you! :)

[23:12] <sorear> i know some of it

[23:12] <sorear> mostly from trying to read ADVENT

[23:15] <census> i see

[23:15] *** PacoAir left
[23:16] <census> sorear: what do you think of that code i posted?

[23:20] <diakopter> in Soviet Russia, formulas translate you

[23:21] <uvtc> census: maybe try the #fortran channel

[23:21] <census> uvtc: yes i have tried :)

[23:21] <census> it is a small channel.

[23:21] <census> diakopter: in soviet union, you drink vodka.  and when you are done, you drink some more vodka

[23:23] <ggoebel> jnthn++: self-hosting nqp on jvm

[23:23] <jnthn> It'll be better when I figure out why \h+ matches 123...

[23:33] <tadzik> oh oh

[23:33] <tadzik> ooossom!

[23:35] *** bapa_ joined
[23:35] *** bapa left
[23:38] <pmurias> jnthn++ # self hosting nqp on the jvm

[23:40] *** arlinius joined
[23:55] <dalek> nqp-jvm-prep: 289ad59 | jnthn++ | lib/JAST/Nodes.nqp:

[23:55] <dalek> nqp-jvm-prep: Avoid nqp::escape for SVal encoding.

[23:55] <dalek> nqp-jvm-prep: 

[23:55] <dalek> nqp-jvm-prep: It does all sorts of things that need all sorts of untangling...

[23:55] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/289ad59d3c

[23:55] <dalek> nqp-jvm-prep: e556c3d | jnthn++ | nqp-src/NQPHLL.pm:

[23:55] <dalek> nqp-jvm-prep: Fix an atkey that shoulda been an atpos.

[23:55] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e556c3d573

