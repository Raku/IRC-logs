[00:04] *** bearman joined
[00:07] *** benabik left
[00:17] *** cooper joined
[00:17] *** cooper left
[00:17] *** cooper joined
[00:18] *** benabik joined
[00:20] *** sidus left
[00:29] *** grondilu left
[00:36] *** fridim_ joined
[00:46] *** zwut00 left
[01:12] *** FROGGS_ joined
[01:16] *** FROGGS left
[01:22] *** xenoterracide left
[01:28] *** xenoterracide joined
[01:31] *** bearman left
[01:39] *** ggoebel left
[02:13] *** btyler joined
[02:49] *** xenoterracide left
[02:53] *** fridim_ left
[03:08] *** xenoterracide joined
[03:25] *** preflex_ joined
[03:25] *** ChanServ sets mode: +v preflex_

[03:27] *** preflex left
[03:27] *** preflex_ is now known as preflex

[03:45] *** crab2313 joined
[03:57] *** crab2313 left
[03:59] *** crab2313 joined
[04:02] *** btyler left
[04:03] <moritz> \o

[04:06] *** pupoque_ left
[04:07] *** pupoque_ joined
[04:12] *** fridim_ joined
[04:19] *** btyler joined
[04:20] *** BenGoldberg left
[04:26] *** xilo left
[04:32] *** hanekomu_ joined
[04:33] *** Khisanth joined
[04:43] *** btyler left
[04:45] *** birdwindupbird joined
[05:43] <lizmat> good *, #perl6!

[05:43] *** fridim_ left
[05:49] *** SamuraiJack_ joined
[05:52] *** fgomez joined
[05:52] *** dmol joined
[06:15] *** iSlug joined
[06:20] *** ssutch joined
[06:23] *** crab2313 left
[06:31] *** kaleem joined
[06:56] <Woodi> hallo :)

[06:59] <Woodi> I just discovered what that MoarVM is :) however google was trying to distract a little: search for moarvm resulted in search for moar with <small> link to moarvm... looks google starts to be language procesing engine and not precise searching engine... 

[07:00] <bonsaikitten> Woodi: we now watt u wand!

[07:00] <Woodi> watt ? :)

[07:00] <bonsaikitten> google is now interpreting so much that I have no idea how to search for some specific terms

[07:02] <Woodi> yea, they do to much services for CIA and Co :) first proces words, check "correctness" then, eventually, delegate to searching subsystem ;)

[07:04] <Woodi> but on the topic: ~13 years after Perl6 announcement we have threads, promises and othere goodies :) still, for me, one more thing left for Perl family: good GUI construction set...

[07:06] <Woodi> about 'killer app' from backlog: I think CGI was efficient such app for Perl :)

[07:12] <labster> Yeah, maybe I should port it.  Anyone else here looking forward to CGI.pm6?

[07:13] <Woodi> labster: I do not think API porting is needed, especially as one big module...

[07:15] <Woodi> but would be nice to have something interaction with FCGI, maybe even with that forgotten multiplexing feature...

[07:15] *** rindolf left
[07:16] <labster> I think if I ever did port CGI, the description would have to be "don't use this module, please don't.  okay, you asked for it..."

[07:19] <JimmyZ> or port dancer

[07:19] <JimmyZ> :P

[07:19] <JimmyZ> or mojo

[07:19] <labster> we have that, it's called Bailador.

[07:20] *** FROGGS_ left
[07:20] <JimmyZ> or give some loves to Bailador

[07:20] <labster> Well yeah, that could be done.

[07:22] <labster> Actually, that might be a good Perl 6 project for me, I have a toy website that could afford to be ported to Perl 6.

[07:23] <Woodi> any new work on NativeCalls ? I was trying to wrap OpenLDAP API few months ago but something was exploding constantly...

[07:25] *** sqirrel joined
[07:25] *** FROGGS[mobile] joined
[07:31] <moritz> Woodi: arnsholt did some stability improvements a month or two ago

[07:31] <moritz> Woodi: but sadly new rakudo changes broke some nativecall stuff again :/

[07:32] <Woodi> thanx moritz++ and arnsholt++ :) I use Star distros so I need to wait anyway :)

[07:36] <labster> Ah, I remember those days of only using Rakudo *.  They were what, 4 months ago?

[07:42] *** FROGGS joined
[07:44] *** FROGGS[mobile] left
[07:44] <dalek> rakudo/nom: b159716 | (Elizabeth Mattijsen)++ | src/core/HashIter.pm:

[07:44] <dalek> rakudo/nom: Start of work to give HashIter its own file

[07:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b15971647c

[07:45] <Woodi> anyway, any idea how to do modern website with static pages ? :) I think dynamic content should be integrated into that not the other way... "*/contacts.html" is a valid url for me, I do not want to call '/' always any fire any code doing route processing...

[07:45] <lizmat> grrrr, why didn't git see that I made a copy of EnumMap ???

[07:46] <Woodi> s/any/and/

[07:47] <dalek> rakudo/nom: 847fb55 | (Elizabeth Mattijsen)++ | src/core/HashIter.pm:

[07:47] <dalek> rakudo/nom: I don't want to be the git blame of this file :-)

[07:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/847fb55c52

[07:47] *** sidus joined
[07:51] <moritz> lizmat: git log and blame have options for detecting copies and moves, iirc

[07:52] <lizmat> I'm pretty sure when I used git at $work, it was smart enough to see I made a copy of a file

[07:52] <lizmat> and keep its history

[07:53] *** Rix joined
[07:53] <lizmat> pretty sure it was some environment variable or setting

[07:54] <masak> mornin', #perl6

[07:56] <moritz> \o masak 

[07:56] <lizmat> masak, moritz o/

[07:57] <dalek> rakudo/nom: 5d66563 | (Elizabeth Mattijsen)++ | src/core/HashIter.pm:

[07:57] <dalek> rakudo/nom: Second try, if this doesn't work, I guess I *will* be its git blame

[07:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5d66563188

[07:58] <FROGGS> gmorning @all

[07:59] <lizmat> morning FROGGS!

[08:00] <masak> lue: it was your iPad X. you're allowed to bring it up the space elevator, as long as you keep it in "space elevator mode" and only use it to drink coffee.

[08:03] <masak> lizmat: detect renames: -M50% -- detect copies: -C50%

[08:04] <masak> lizmat: the long options are called --find-renames and --find-copies, respectively.

[08:04] <masak> lizmat: the percentages are a similarity cutoff at which point Git no longer considers the files "similar".

[08:06] <dalek> rakudo/nom: 32e055e | (Elizabeth Mattijsen)++ | src/core/HashIter.pm:

[08:06] <dalek> rakudo/nom: There we go again

[08:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32e055e8c5

[08:07] <lizmat> masak: is that with git commit ?

[08:07] <lizmat> or with git add ?

[08:07] <masak> git-diff and git-log

[08:07] <masak> it's a visualization thing, not a storage thing.

[08:07] <masak> in its object model, git doesn't give a flying care about moves and copies. :)

[08:08] <masak> oh, and git-blame, according to #git.

[08:08] <lizmat> I must be going crazy: at $work I have seen commit messages where git automagically knew a file was copied

[08:09] <masak> I don't see those flags on git-status.

[08:09] <lizmat> ok, then I give up

[08:09] <masak> but it would at least be theoretically possible to detect that in the staging area, I guess.

[08:09] <masak> I see moves quite often (by default).

[08:11] *** fhelmberger joined
[08:11] <Grrrr> lizmat: I dunno, really  :)

[08:14] *** dmol left
[08:14] <moritz> lizmat: 'git show --stat' does the same rename detection

[08:14] *** dmol joined
[08:15] <masak> (but not copy detection)

[08:18] <lizmat> ok, too bad then, I must have been delusional at $work  :-)

[08:22] <masak> nice! http://worrydream.com/dbx/

[08:22] <moritz> masak: also read the first comment on https://news.ycombinator.com/item?id=6129148

[08:23] *** dmol left
[08:25] <moritz> the critisms might be a bit over the top too, but it captures some of my worries with the worrydream articles and talks which I haven't really been able to put into words before

[08:28] <moritz> that said, it's nice to have some really-advanced vision of how programming could look like

[08:28] <moritz> even if it doesn't end up looking like it, it's still very healthy to look at other ideas at all

[08:29] *** labster joined
[08:31] *** dakkar joined
[08:32] <dalek> rakudo/nom: b52153a | (Elizabeth Mattijsen)++ | src/core/HashIter.pm:

[08:32] <dalek> rakudo/nom: Copy of EnumMap, to give HashIter its own file, as per jnthn++ request

[08:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b52153ab9b

[08:32] <dalek> rakudo/nom: 92a2b85 | (Elizabeth Mattijsen)++ | / (4 files):

[08:32] <dalek> rakudo/nom: Give the HashIter class its own file

[08:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92a2b85d44

[08:35] <lizmat> oo, wow: http://bitsavers.informatik.uni-stuttgart.de/pdf/univOfIllinoisUrbana/plato/

[08:37] <masak> moritz: aye, I read it. I think the core of the important thing is this: "we're not at the pinnacle yet. far from it."

[08:37] <masak> Alan Kay has a talk "The Computer Revolution Hasn't Happened Yet"

[08:37] <masak> lizmat: I thought you might like that :)

[08:38] <lizmat> http://bitsavers.informatik.uni-stuttgart.de/pdf/univOfIllinoisUrbana/plato/X-26_Digital_Data_Transmission_Via_CATV_May72.pdf  describing how to feed data to up to 32 terminals using an analog TV signal  :-)

[08:39] <lizmat> those were the days  :-)

[08:39] <arnsholt> Another good Alan Kay talk is "'Normal' considered harmful"

[08:40] <masak> lizmat: https://github.com/perl6/specs/commit/2acbd585188c80e48727bc92b0f8a7a10466cee3 shows good will, but I still don't understand. :/ could you maybe explain to me directly? I'm missing something here.

[08:41] <lizmat> masak: first of all, this describes of what is currently already implemented

[08:42] *** dmol joined
[08:42] <lizmat> when I implemented classify / categorize (or was it re-implemented?)

[08:42] <lizmat> I found it made more sense to make them methods on Hashes, rather than lists.  Because they return a Hash

[08:42] <masak> *nod*

[08:43] <lizmat> also, in my experience, these types of actions sometimes need to be done more than once on a given Hash

[08:43] <masak> I usually pick up fairly rapidly on statements of the form "A basically works like B".

[08:43] <lizmat> e.g. by a daily run on a Hash that is deserialized and serialized again after

[08:43] <masak> but in this case -- what does it *mean* for Hash.classify to "basically work the same as" List.classify!?

[08:43] <moritz> so Hash.classify doesn't classify the hash, it classes the arguments and adds the information to the invocant

[08:44] <masak> lizmat: your latest spec commit doesn't clarify that.

[08:44] <moritz> correct?

[08:44] <masak> lizmat: and my experiments with camelia didn't clarify *anything*. :/

[08:44] <arnsholt> Oh, so it's like "multi classify ( %mapper, *@values --> Hash )"?

[08:44] <masak> lizmat: could you or someone else show me, *really* simply, with camelia, what the thing actually does? I'm so curious.

[08:45] <lizmat> cooking up a simple example

[08:45] * masak will at some point create a course called "Semantics: what does stuff actually *do*?"

[08:46] <moritz> r: my %h = (a => 2, b => 5); say %h.classify(*.key, (a => 3, b => 4, c => 5)).perl

[08:46] <camelia> rakudo 32e055: OUTPUT«Can not get attribute '$!items' declared in class 'List' with this object␤  in method classify at src/gen/CORE.setting:8195␤  in method classify at src/gen/CORE.setting:8175␤  in block  at /tmp/XRGydi7XIG:1␤␤»

[08:46] <moritz> whatever that means, I don't think I should get that here.

[08:47] <FROGGS> I'd love to attend a course called: What are some of my colleagues actually doing?

[08:47] <lizmat> r: my %h; %h.classify( { m/^(.)/ }, 1..100 ); say %h

[08:47] <camelia> rakudo 32e055: OUTPUT«("1" => [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 100], "2" => [2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], "3" => [3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39], "4" => [4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49], "5" => [5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59],…

[08:48] <masak> lizmat: thirdly or fourthly, "but called as a method on the Hash that is also returned". are you saying that the input Hash is also the output Hash? the fact that it gets put in the same sentence as "basically has the same functionality as L<List>'s C<classify>" confuses me greatly.

[08:48] <masak> lizmat: what. WHAT.

[08:48] <lizmat> r: my %h; %h.classify( { m/^(.)/ }, 1..100 ); say %h; %h.classify( m/^(.)/, 101 .. 200 ); say %h

[08:48] <camelia> rakudo 32e055: OUTPUT«("1" => [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 100], "2" => [2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], "3" => [3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39], "4" => [4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49], "5" => [5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59],…

[08:48] <masak> lizmat: since when is .classify a *mutating* method!?

[08:49] <masak> that does not make sense at all.

[08:49] <arnsholt> I'm confused now, too

[08:49] <lizmat> and I'm confused at your confusion :-(

[08:49] <masak> lizmat: before your example, I was curious and thought I was missing something. now I'm a bit peeved and think that *you're* missing something.

[08:50] <lizmat> well, that could all well be true  

[08:50] <masak> lizmat: are you aware of Perl 6's tendency to have non-mutating methods?

[08:50] <lizmat> so what am I missing?  are mutating methods not allowed?

[08:50] <lizmat> ah

[08:50] <masak> like .subst and .rotate and stuff.

[08:50] <masak> .classify is one of those.

[08:50] <lizmat> .classify on list is non-mutating

[08:50] <masak> you do mutation through .=classify

[08:51] <lizmat> .classify and .categorize on List return a new hash

[08:51] <masak> ...yes...

[08:52] <masak> a *new* Hash.

[08:52] <lizmat> method classify ($test) { {}.classify( $test, @.list ) }

[08:53] <lizmat> by consequence of that, you can call .classify on an existing hash

[08:53] <masak> I see.

[08:53] <masak> if that's how it's implemented internally, then that internal .classify shouldn't be exposed.

[08:53] <masak> conversely, if we want to expose .classify on Hash, it shouldn't work like that.

[08:54] <lizmat> ok

[08:54] <masak> sorry for being a bit harsh. :/ it's just very very wrong.

[08:54] <masak> I'm glad I persisted in seeking clarity to my confusion.

[08:54] <lizmat> ok, fixing now

[08:55] <masak> lizmat++

[08:56] <dalek> specs: 48def95 | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[08:56] <dalek> specs: Remove confusing spec, until we know what we want to do here

[08:56] <dalek> specs: review: https://github.com/perl6/specs/commit/48def95b7b

[09:03] *** rindolf joined
[09:04] <dalek> roast: 5c6aee2 | (Elizabeth Mattijsen)++ | S32-list/c (2 files):

[09:04] <dalek> roast: Remove tests for Hash.classify and Hash.categorize

[09:04] <dalek> roast: review: https://github.com/perl6/roast/commit/5c6aee2945

[09:15] <masak> lizmat: fwiw, I envisioned a .classify on hashes that did some "second-order" classifying, a bit like a stable .sort can do second-order sorting. but I couldn't quite fit it together in my mind.

[09:16] <dalek> rakudo/nom: 4a608a7 | (Elizabeth Mattijsen)++ | src/core/ (3 files):

[09:16] <dalek> rakudo/nom: Remove Hash.(classify|categorize), as it is no longer specced

[09:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4a608a700f

[09:16] <dalek> roast: 9a9e72e | (Elizabeth Mattijsen)++ | S32-list/c (2 files):

[09:16] <dalek> roast: Further fixes for Hash.(classify|categorize) departure

[09:16] <dalek> roast: review: https://github.com/perl6/roast/commit/9a9e72e543

[09:17] <moritz> lizmat: would a List.classify(:into(%existing_hash), $classifier, @list) work for your use case?

[09:18] <lizmat> I've renamed Hash.(classify|categorize) to Hash.(classify_list|cateforize_list)

[09:18] <lizmat> and adjusted references accordingly, removed tests as these are now internal methods

[09:19] <lizmat> I am told that adding named parameters is smelly, so I don't think that is a good idea, but it would serve my purpose, yes

[09:19] <masak> moritz: why is there both a List. and a @list ?

[09:19] <lizmat> it would feel unnatural to me

[09:19] <moritz> masak: uhm, my error

[09:20] <moritz> should be just List.classify(&classifier, :%into)

[09:20] <masak> moritz: it seems to me that if you want to .classify "into" a hash, you just .classify and then .push

[09:20] <masak> moritz: no need to re-invent .push as a named parameter in .classify

[09:21] <lizmat> cycling&

[09:24] <masak> hm, I had heard of "waterfall" and "whirlpool" before, but http://www.techopedia.com/definition/26121/synchronize-and-stabilize was new to me.

[09:27] <moritz> "The synchronize and stabilize life cycle model defines an approach helping to balance flexibility and structure in software product development."

[09:27] <moritz> so, what's the approach?

[09:31] <masak> I read it as "do things separately in smaller teams, then deal with the inevitable fallout when the software needs to integrate".

[09:34] *** daxim joined
[09:45] *** crab2313 joined
[09:46] <mathw> morning o/

[09:48] <masak> mathw! \o/

[09:49] <mathw> hi masak

[09:49] <mathw> that was enthusiastic

[09:49] <masak> yes :)

[09:49] <masak> happy to see you :)

[09:50] <mathw> aaaw

[09:51] <masak> happy #perl6 exists, after all these years, and is still the best place to learn and grow, and still pulls in all these awesome people.

[09:51] *** rindolf left
[09:52] <mathw> It is a good place

[09:52] <mathw> and although I don't really do Perl 6 stuff these days, I still like being here, because Perl 6 is still awesome

[09:53] <mathw> thinking of going to LPW this year

[09:54] <masak> ooh

[09:54] <masak> would be great to finally meet in R**3.

[09:55] <mathw> yes that's what I was thinking

[09:55] <mathw> I might even be using Perl professionally again by then

[09:55] <masak> cool.

[09:55] <mathw> might

[09:56] <mathw> it relies on me yelling at people about money though

[09:57] * masak tries to picture that and fails

[09:57] <mathw> heh

[09:58] <mathw> okay I don't really mean yelling

[09:58] <mathw> salary has to be negotiated

[09:58] <masak> ah, yes.

[09:59] <mathw> so I might just stay put, but we'll see

[09:59] <mathw> out of interest, what would you write a high-performance web service in?

[10:01] <masak> define "high-performance".

[10:02] <arnsholt> If the performance needs are truly ridiculous, probably something like Erlang with a web frontend in whatever suits the rest of the circumstances =)

[10:03] <mathw> masak: good reply :)

[10:04] <masak> I was thinking Erlang, too.

[10:04] <mathw> Erlang certainly goes further than I actually need

[10:05] <masak> and if we're talking high-performance as in "real-time trading", I'd reccomend looking into the state of the art, which is impressive in what it does.

[10:05] <mathw> might be a hard sell too, the guy I have to run this by is wary of using Perl because he doesn't think there are any Perl programmers, so I'm sure he's never heard of Erlang

[10:05] <mathw> and no, it's not a real-time trading system

[10:07] <mathw> It's basically somewhere to put msot of the business logic so that disparate interfaces to it don't have to implement it all three or four times, slightly differently.

[10:07] <mathw> I think you'd agree that would be bad.

[10:09] *** xinming left
[10:11] *** xinming joined
[10:13] <masak> sounds like something approaching "creating a service" thinking.

[10:18] <tadzik> Go? :)

[10:18] *** yoleaux left
[10:18] *** crab2313 left
[10:21] <mathw> I looked at Go a few weeks ago

[10:21] <mathw> something about it feels a bit wrong to me

[10:21] <mathw> like, it's got some good stuff

[10:22] <mathw> but it's so resolutely... normal

[10:22] <masak> heh.

[10:22] <hoelzro> I know what you mean

[10:22] <masak> probably a good thing for the systems programming niche.

[10:22] <hoelzro> it just seems...boring?

[10:22] <mathw> yes, boring

[10:22] <mathw> I'd actually rather use C++11

[10:22] <masak> it's what you get when you start with "let's make things really easy for the compiler so it can be fast!"

[10:23] <mathw> yeah and there's always a place for that I guess maybe

[10:24] <mathw> I'll admit to seriously considering Haskell

[10:24] <mathw> that can go pretty scarily quick if you're careful

[10:25] <mathw> certainly quick enough, and I am a fan of strong type systems :)

[10:25] <mathw> again might be hard to run it past the 'who can look after it if I leave' test...

[10:27] <mathw> oh and then there's the part of my brain that whispers "do it in Lisp, you know you want to"

[10:29] <masak> if you want FP and performance, maybe look into Ocaml?

[10:30] <mathw> good point

[10:31] <mathw> and from there one could go to F# if I get stuck on a Microsoft server platform, but I have no intention of doing that.

[10:32] *** sqirrel left
[10:34] *** crab2313 joined
[10:40] *** pmurias joined
[10:42] *** sqirrel joined
[10:44] <pmurias> 2hi

[10:44] <pmurias> * hi

[10:45] <pmurias> what's the difference between using nqp::getlexdyn('$*FOO') and $*FOO (in nqp)

[10:48] <Ulti> arnsholt: have you seen this erlang video? http://www.youtube.com/watch?v=xrIjfIjssLE

[11:00] *** yoleaux joined
[11:00] *** ChanServ sets mode: +v yoleaux

[11:27] *** rindolf joined
[11:27] *** sqirrel_ joined
[11:43] *** sqirrel left
[11:56] *** crab2313 left
[12:05] *** sqirrel joined
[12:05] *** benabik left
[12:06] *** benabik joined
[12:34] *** rindolf left
[12:39] *** sqirrel_ left
[12:40] *** btyler joined
[12:50] *** shinobicl joined
[12:57] *** stevan__ left
[12:59] *** btyler left
[13:04] *** konundra joined
[13:06] *** SamuraiJack_ left
[13:10] *** sqirrel_ joined
[13:13] *** ggoebel joined
[13:14] *** kaare_ joined
[13:15] *** PacoAir joined
[13:15] *** sqirrel left
[13:17] * masak looks for a .classify equivalent in Python, but finds none

[13:19] <arnsholt> It's probably one of those things that's just a bit too small to end up in a library somewhere

[13:20] <masak> well, an obvious candidate was itertools, which contains lots of stuff like that: http://docs.python.org/2/library/itertools.html

[13:23] <moritz>  /w 15

[13:23] <moritz> sorry

[13:23] * masak hugs moritz 

[13:23] <masak> good irssi user! :)

[13:27] *** mu joined
[13:27] *** mu is now known as Guest75569

[13:28] <Guest75569> what ? why i cant take name "Mu" ?

[13:28] <Guest75569> you failed to identify ?

[13:28] *** Guest75569 left
[13:29] <FROGGS> no u

[13:30] <masak> Guest75569: come back so we can explain it to you!

[13:30] <[Coke]> short version: irc sucks. :P

[13:30] <masak> heh, Python adopted Perl 6's 0o123 syntax :)

[13:30] <[Coke]> r: say 0o123;

[13:30] <camelia> rakudo 4a608a: OUTPUT«83␤»

[13:31] <FROGGS> Python: \o/ improve with us!

[13:32] <FROGGS> this syntax really is like sane**sane

[13:32] <mathw> much better than C's, that's for sure

[13:32] <masak> that's Python 3, to be exact.

[13:32] <masak> Python 2 does 0123.

[13:32] <masak> str: 0123

[13:32] <masak> std: 0123

[13:32] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  Leading 0 does not indicate octal in Perl 6; please use 0o123 if you mean that at /tmp/05psoupjia line 1:␤------> [32m0123[33m⏏[31m<EOL>[0m␤ok 00:00 41m␤»

[13:32] <masak> std: 0123 #ok

[13:32] <camelia> std c2215f0: OUTPUT«Potential difficulties:␤  Leading 0 does not indicate octal in Perl 6; please use 0o123 if you mean that at /tmp/abmVSsmClC line 1:␤------> [32m0123[33m⏏[31m #ok[0m␤ok 00:00 41m␤»

[13:32] <corecatcher> short q: What are these dba() calls? e.g. dba('horizontal whitespace'), looked them up in nqp, but didnt really got it

[13:32] <masak> std: 0123 #OK

[13:32] <camelia> std c2215f0: OUTPUT«ok 00:00 41m␤»

[13:33] <masak> corecatcher: they set a context for better error messages.

[13:33] <FROGGS> they are used in error messages instead of the method name

[13:33] <masak> corecatcher: the TLA expands to "doing business as".

[13:33] *** bluescreen10 joined
[13:33] <corecatcher> ah, so the error msg is generated for the given "context" ?

[13:34] <FROGGS> r: 1 1

[13:34] <camelia> rakudo 4a608a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/RLs46RQ3bu:1␤------> [32m1 [33m⏏[31m1[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement modifier␤        statement modifie…

[13:35] *** kaleem left
[13:36] *** sqirrel_ left
[13:36] <corecatcher> so where shall I look into to see what errormsg is given for "horizontal whitespace"? or is the errormsg a bit more complex, like analysing lots of contexts and printing sth human-readeable for it?

[13:37] <FROGGS> corecatcher: the list of "expecting any of" you see above is generated from the dba's of the tokens that are valid at that parsing point

[13:37] <FROGGS> corecatcher: I don't understand your last question

[13:39] <corecatcher> FROGGS: nvm got it - my thought was that one can pin down the error to a specific one by analsying lots of contexts which were set or unset

[13:39] *** btyler joined
[13:39] <corecatcher> just like a lookup table: "oh a b and c were set and d not, so it must be error: foo"

[13:40] *** bluescreen10 left
[13:40] <FROGGS> well no, it really is just the human readable form of the method name, that will be put in a backtrace

[13:41] <corecatcher> hmkay :) thx

[13:41] <masak> heh, I implemented classify as an 8-line function in Python ;)

[13:41] <FROGGS> 8-)

[13:43] <masak> https://gist.github.com/masak/6122083

[13:44] <lizmat> fwiw, that is only 1 of the MMD candidates, and does not do multi-level classification

[13:44] <masak> troo.

[13:45] <moritz> r: say (0, 1, 2).classify(* %% 2).perl

[13:45] <camelia> rakudo 4a608a: OUTPUT«("True" => [0, 2], "False" => [1]).hash␤»

[13:45] <masak> I tellya, the instinct to end everything with a semicolon is intense.

[13:45] <mathw> free yourself from the tyrrany of the semicolon

[13:46] <lizmat> masak: also I wished you had chimed in on http://irclog.perlgeek.de/perl6/2013-06-14#i_7197911

[13:46] <mathw> bask in the sanity of a syntax that pays attention to newlines

[13:46] * mathw might not like Python, but does like its syntax

[13:46] <lizmat> masak: or here http://www.pmichaud.com/2010/pres/yapcna-perl6/slides/slide24c.html

[13:47] <masak> lizmat: first time I see either.

[13:47] <masak> lizmat: but at first glance, neither of them intimates that we're dealing with a mutating method.

[13:48] <lizmat> neither of them disallow it either

[13:48] <lizmat> anyways, you're made your point clear

[13:48] <masak> yes, pmichaud's slide if I read it correctly.

[13:48] <lizmat> no mutating methods

[13:48] <masak> "returns a list of pairs where..."

[13:48] <masak> well, very few mutating methods.

[13:48] <masak> we still have .push and .pop and similar :)

[13:49] <masak> but .classify is decidedly not a mutating method. to the extent that Perl 6 carries the FP banner, .classify being mutating goes straight against that.

[13:49] <lizmat> r: my %h; %h.push( 1, (a => 2), 3 ); say %h # rakudobug ?

[13:49] <camelia> rakudo 4a608a: OUTPUT«Trailing item in Hash.push  in block  at /tmp/Nlbd2p_W4f:1␤␤("1" => "a" => 2).hash␤»

[13:50] <arnsholt> masak: You can end your statements with a ; in Python, but it's not really useful =)

[13:50] <masak> n: my %h; %h.push( 1, (a => 2), 3 ); say %h

[13:50] <camelia> niecza v24-88-g1f87209: OUTPUT«{"1" => "a" => 2}␤»

[13:50] <masak> lizmat: I don't like Niecza's behavior better :(

[13:50] <masak> arnsholt: oh gosh you're right!

[13:50] <lizmat> basically because they are both implemented right

[13:51] <masak> oh, Rakudo also outputs that, but only after complaining.

[13:51] <lizmat> r: my %h; %h.push( 1, (a => 2) ); say %h # doesn't complain, but is wrong as well

[13:51] <camelia> rakudo 4a608a: OUTPUT«("1" => "a" => 2).hash␤»

[13:52] <masak> lizmat: wrong according to some bit of spec or other, I guess?

[13:52] <masak> lizmat: usually putting () around a pair in a siggie means "yeah, I really want that pair".

[13:52] <masak> (and so it looks right to me at first blush)

[13:53] <masak> meh, it's humbling to be a newcomer in some channel. the #python people aren't interacting with me at all.

[13:54] <arnsholt> Yeah, I've noticed that a few times myself

[13:54] *** crab2313 joined
[13:55] <PerlJam> masak: Are they interacting with others?

[13:55] <masak> PerlJam: yes, a few conversations ongoing, as far as I can see.

[13:55] *** shinobicl left
[13:56] <corecatcher> is there anything that can parse the S26 specs pod? :P

[13:56] <corecatcher> AND give me a nice output? 

[13:56] <jercos> Your mind?

[13:56] <PerlJam> corecatcher: Rakudo can parse most (if not all) of it with the --doc option

[13:56] * masak doubts it can parse it all

[13:56] <masak> that said, it'd be interesting to see a list of what it doesn't parse

[13:57] <corecatcher> okay, so pod is a niche to work on *check*

[13:57] <PerlJam> yeah, that would be good to add to the POD feature matrix

[13:57] *** xinming left
[13:59] <moritz> and --doc=html uses Pod::To::html to generate HTML from it

[14:00] <moritz> not perfect, but much better than nothing

[14:01] *** xinming joined
[14:08] <moritz> nwc10++ # http://news.perlfoundation.org/2013/07/improving-perl-5-grant-report-18.html longest grant report I've ever skimmed

[14:09] *** bluescreen10 joined
[14:12] <nwc10> got chewed by the site's blog formater (again)

[14:13] <masak> ok, I've broken through the isolation barrier in #python ;)

[14:14] <masak> they gave me a 5-line classify: https://gist.github.com/epsy/6122272

[14:14] *** xilo joined
[14:14] <benabik> masak: defaultdict?

[14:15] * flussence still feels like a newcomer in this channel most of the time...

[14:15] <tadzik> ah, defaultdict. I used that recently too :)

[14:16] <tadzik> googling for "python dict autovivication"

[14:16] <benabik> Oh, a dict that returns a list for something that isn't there?

[14:16] <mathw> that is neat

[14:17] <tadzik> yeah

[14:17] <tadzik> before that, I tried using .get() as an lvalue :)

[14:17] <masak> yeah.

[14:18] <tadzik> funny enough, I had a similar problem with Go recently

[14:18] <tadzik> if you have a map[string]struct{ ... }, it doesn't auto-allocate struct when you access map["x"]

[14:19] <tadzik> (which is fair enough)_

[14:20] <masak> heh, Go signatures still look to me like "this is the standard way to write things... now mess it all up and backwards and stuff!"

[14:22] <tadzik> heh, it's not that bad :)

[14:22] <tadzik> see also: scala

[14:23] <tadzik> one of the excuses is "it's now sane to write a function type"

[14:23] <tadzik> in C it was, well, quirky

[14:23] <masak> RT #38812 is the lowest RT number I've seen fixed. nwc10++

[14:24] <masak> tadzik: granted.

[14:24] <masak> nwc10++ # http://news.perlfoundation.org/2013/07/improving-perl-5-grant-report-18.html

[14:25] <benabik> #38812 created 7yrs ago.

[14:26] <PerlJam> man have I been out of touch!

[14:26] * PerlJam just read the commentson diakopter's hague grant app

[14:31] * masak notes that reini can't spell 'blizkost'

[14:31] <FROGGS> masak: that is just germish :o)

[14:32] <frettled> blokschnitzel?

[14:32] <FROGGS> >.<

[14:32] <FROGGS> *g*

[14:33] <masak> FROGGS: I realize that.

[14:33] <FROGGS> 'course

[14:33] <masak> in fact, my instinct is to spell it with 'tz' as well.

[14:34] <masak> the only reason I don't is I know how it's actually spelled ;)

[14:34] <masak> though the clogs say I've misspelled it twice, so...

[14:35] <FROGGS> HA!

[14:35] <masak> (against spelling it right 28 times)

[14:35] <FROGGS> *g*

[14:35] <tadzik> *tz*

[14:36] * masak .oO( tazik )

[14:36] <FROGGS> I don't wanna know how often I missspel something

[14:36] <masak> FROGGS: :P

[14:36] <FROGGS> that is clearly not my strength :o)

[14:37] *** Psyche^_ joined
[14:39] *** wtw left
[14:41] *** Psyche^ left
[14:42] *** _jaldhar left
[14:44] *** daxim_ joined
[14:44] *** daxim left
[14:44] *** lowpro30 joined
[14:45] *** Bzek joined
[14:46] *** rindolf joined
[14:50] <masak> wow. not only does my Mint install have python3 installed, it also has the 2to3 tool. I had no idea. :)

[14:52] <nwc10> pypy's Python 3 support has reached beta: http://morepypy.blogspot.co.uk/2013/07/pypy3-21-beta-1.html

[14:55] <masak> whoa. Python has the ternary operator infix:<?? !!>, but they spell it infix:<if else>.

[14:55] <masak> that's not just Python 3, that's 2 as well.

[14:55] <masak> and of course, the first and second operands are reversed compared to infix:<?? !!>

[14:56] <masak> >>> x = 7 if 2 + 2 == 5 else 9

[14:56] <masak> >>> x

[14:56] <masak> 9

[14:56] *** konundra left
[14:57] <masak> since 2.5, according to StackOverflow.

[14:58] *** lowpro30 left
[14:58] <FROGGS> that's not so bad

[14:58] <masak> well, whatever happened to "one-- and preferably only one --obvious way to do it"?

[14:59] <masak> this is clearly a second way, after the ordinary 'if'.

[14:59] <tadzik> 'tis just marketing bullshit ;)

[15:00] <masak> clearly!

[15:00] <arnsholt> masak: There's also an idiom involving the short-circuiting behaviour of || and &&

[15:01] <nwc10> surely it's still true, as infix:<if else> is not obvious :-)

[15:01] <arnsholt> "cond && iftrue || iffalse" IIRC

[15:01] <masak> nwc10: haha!

[15:02] <benabik> arnsholt: only works if `iftrue` is true.  ;_0

[15:02] <masak> explanations from #python: Guido doesn't like infix:<if else>, but he added it because the things people made as workarounds were much, much worse!

[15:02] <[Coke]> r: True && say 3, False || say 4

[15:02] <masak> that's wonderful. :>

[15:02] <camelia> rakudo 4a608a: OUTPUT«4␤3True␤»

[15:02] <benabik> hm, My nose appears to have relocated to the side of my face.  Should get that looked at.

[15:02] <masak> arnsholt: yes, that.

[15:02] * [Coke] mutters something about parens

[15:02] <masak> arnsholt: the "and-or" trick.

[15:04] <tadzik> masak: there should be more Perlists programming in Python, doing the Much Much Worse things so Python may end up being civilized ;)

[15:04] <arnsholt> Yeah. As someone used to Perl and Lisp it only made me wrinkle my nose a bit, not recoil in horror as it seems some Pythonistas do =)

[15:04] <masak> tadzik: challenge accepted!

[15:05] *** jeff_s1 joined
[15:05] <arnsholt> I wonder what hilarious things mst would do to Python. Also how the Python community would react ^_^

[15:07] <masak> right. not "do with", "do to" :P

[15:08] <tadzik> I've seen slides "Don't do that in Python" recently. I was like "phew, amateurs"

[15:08] <tadzik> although the q module is something I might steal for Perl

[15:09] <arnsholt> masak: I find that a bit of anthropomorphisation improves the turn of phrase every now and then =)

[15:11] *** sqirrel joined
[15:13] <masak> tadzik: the q module transcends space and time and likes to play tricks on puny humans?

[15:15] <ssutch> good $timeofday

[15:15] <tadzik> masak: no, and it's a huge disappointment :P

[15:22] <FROGGS> hi ssutch 

[15:23] <arnsholt> tadzik: Ooooh, that q module sounds pretty darn clever!

[15:23] <masak> jnthn++ # http://www.josetteorama.com/all-about-perl-6-interview-of-jonathan-worthington-part-3-of-3/

[15:24] <tadzik> arnsholt: yep :)

[15:24] <tadzik> I mean, it's quite simple and all

[15:24] <tadzik> but it's _so_ useful

[15:24] <masak> tadzik: do you have a url for the q module?

[15:25] <arnsholt> masak: https://pypi.python.org/pypi/q

[15:25] <tadzik> arnsholt clearly has faster internets :)

[15:26] <arnsholt> I was reading the docs, to see what kind of module it was

[15:26] <arnsholt> So I just had to go over to the browser workspace and copy the URL =)

[15:26] <tadzik> pip install --user q; pydoc q :)

[15:26] <masak> oh, cute.

[15:28] <arnsholt> I know, right?

[15:29] <arnsholt> I think it even uses operator overloading

[15:32] <masak> "Don’t try this at home, kids!" -- http://docs.python.org/3.3/faq/programming.html#is-it-possible-to-write-obfuscated-one-liners-in-python -- why not? it looks like great fun!

[15:33] *** kaleem joined
[15:34] <arnsholt> Yeah, sometimes Python makes me want to go "Why so serious?" =)

[15:34] *** kaleem left
[15:35] * masak .oO( and Python goes "I'm Batman" )

[15:35] *** daxim_ left
[15:36] <[Coke]> No, Mr. Keaton. No you're not.

[15:39] * masak idly wonders if that's Keaton 2.7 or Keaton 3.3

[15:44] <geekosaur> this is more bemusing if you misread Keaton as kitten

[15:46] *** ssutch left
[15:48] <timotimo> corecatcher: hey, you still there? i can talk to you about Pod6 :)

[15:49] *** fhelmberger left
[15:49] <timotimo> http://perlcabal.org/syn/S26.html - this is the current "state of the art" parsing + Pod::To::HTML which i added a bunch of fixes to recently, but there's still lots missing

[15:49] <timotimo> i was considering a half-rewrite of the pod parsing to make some stuff work properly, but that may not be needed after all

[15:51] <timotimo> i think i have *some* idea how to rewrite the table parser to honor formatting codes

[15:52] *** grondilu joined
[15:52] <timotimo> is there a clever way to say "the cursor inside this here group may not proceed more than $maxnum characters forwards" and have the backtracker aware of that properly?

[15:52] *** vmspb joined
[15:52] <timotimo> a way that would also work recursively?

[15:53] <arnsholt> The and operator perhaps?

[15:54] <masak> timotimo: I don't think so.

[15:54] <arnsholt> <subrule> & [.**100] # Or however many characters you want

[15:54] <timotimo> ... that works?

[15:54] <masak> oh, that would do it, I guess.

[15:55] <timotimo> r: say "foo" ~~ / [...] & ["f"..] /

[15:55] <camelia> rakudo 4a608a: OUTPUT«｢foo｣␤␤»

[15:55] <timotimo> r: say "boo" ~~ / [...] & ["f"..] /

[15:55] <camelia> rakudo 4a608a: OUTPUT«Nil␤»

[15:55] <masak> r: "foooooooooo" ~~ / [foo] & [.*3] /

[15:55] <camelia> rakudo 4a608a:  ( no output )

[15:55] <timotimo> oh wow, that is glorious!

[15:55] *** grondilu left
[15:55] <timotimo> one more *

[15:55] <masak> r: say "foooooooooo" ~~ / [fo*] & [.*3] /

[15:55] <camelia> rakudo 4a608a: OUTPUT«Nil␤»

[15:55] <timotimo> also, why did i quote the f? well ...

[15:55] <masak> hrm.

[15:56] <timotimo> r: say "foooooooooo" ~~ / [fo*] & [.**3] /

[15:56] <camelia> rakudo 4a608a: OUTPUT«｢foo｣␤␤»

[15:56] <arnsholt> I'm not 100% sure it'll work, mind

[15:56] <masak> argh, tes,

[15:56] <masak> timotimo++

[15:56] <timotimo> :)

[15:56] <timotimo> that's absolutely amazing

[15:56] <arnsholt> But the & operator is a really nice addition in Perl 6

[15:56] <arnsholt> It really should be in normal regexes as well, IMO

[15:56] <masak> by the way, the & operator makes so much more sense if you're a Thompson engine. come to my YAPC::EU talk for more.

[15:56] <timotimo> i'll have some balconytime now and think about things.

[15:57] <arnsholt> FSAs are closed under intersection, and it's not always trivial to express using the other regex primitives

[15:57] <masak> arnsholt: if you're not a Thompson engine, the & operator is "quadratic" in the sense that it multiplies together all the backtracking alternatives of both sides.

[15:58] <arnsholt> I guess, but that potential is in the intersection operator anyways, isn't it?

[15:58] * masak has a category theory moment when he realizes that & and | are just *another* example of products and coproducts

[15:58] <masak> arnsholt: well, the point is that it's not quadratic under Thompson-engine semantics.

[15:59] <arnsholt> Oh, that's interesting

[15:59] <masak> (because there's no backtracking)

[15:59] <arnsholt> I'm not really familiar with how the Thompson engine works, unfortunately

[16:00] <masak> arnsholt: http://swtch.com/~rsc/regexp/regexp1.html has some sweet diagrams and nice, clear code.

[16:00] <masak> alternatively, cometomytalk. :P

[16:00] <timotimo> ah dang, thinking about it some more tells me: since we can't interpolate numbers on the right side of ** yet, it won't be of terribly much help; although i can be cleverer about it.

[16:00] <arnsholt> Not going to Kiev, sadly =)

[16:00] <masak> arnsholt: aaaaw

[16:01] <arnsholt> Going to an academic conference next week (in Bulgaria, even), so Kiev two weeks after is a bit inconvenient

[16:01] <masak> arnsholt: we'll miss you!

[16:02] <arnsholt> I'll miss you too =)

[16:04] *** ssutch joined
[16:10] <timotimo> if there'll be another GPW in the future that's comfortable for me to reach, i'll try to attend and maybe i'll even meet a sufficiently big subset of <masak moritz jnthn tadzik lizmat>.assume-missing()

[16:13] *** sqirrel_ joined
[16:16] <moritz> timotimo: next year is in Hannover

[16:19] <timotimo> that's only barely closer to me than berlin is ...

[16:19] <timotimo> but if i go spend a few days with my parents in my old home, it won't be quite as far i think

[16:19] * timotimo mumbles something about google maps and lack of built-in measurement tools

[16:20] <timotimo> do we already know what month, or even calendarweek, it'll happen on?

[16:21] <arnsholt> ACT says 26 to 28 March

[16:21] <arnsholt>  

[16:21] <arnsholt> http://act.yapc.eu/gpw2014/

[16:22] <timotimo> during exam time, eh?

[16:27] <masak> Python got a MOP in 2001, with Python 2.1.

[16:28] <masak> sorry, 2.2.

[16:29] *** xabbu42 joined
[16:29] *** xabbu42 left
[16:30] *** xabbu42 joined
[16:30] *** xabbu42 left
[16:32] *** fgomez left
[16:32] <moritz> the rubyists sometimes also claim to have a MOP, but so far I haven't see the evidence for that

[16:32] *** sqirrel_ left
[16:34] <masak> moritz: eigenclasses!

[16:34] <benabik> I think Object and Class provide basic methods that can be used to create new classes.

[16:34] <timotimo> masak: eigenclasses means "do it yourself"? ;)

[16:35] *** FROGGS left
[16:37] *** colomon left
[16:40] <masak> timotimo: "eigenclass" was _why's name for "class metaobject", IIUC.

[16:42] <moritz> wie eigentümlich.

[16:42] <masak> :)

[16:43] <moritz> masak: so you're learning python these days?

[16:43] *** vk_ joined
[16:46] <masak> moritz: yes. I've always been watching Python from a distance, sometimes reading lots of it, sometimes writing smaller things in it. but I've never dug into Python before.

[16:47] <masak> moritz: now I'm writing a Python course, for the simple reason that I want to deliver more courses that are similar to the Perl course we have, because there does not seem to be a very high demand for the Perl course. :)

[16:47] *** kaleem joined
[16:47] <masak> (there is a demand, it's just not very high. the demand for the JavaScript course is just ridiculous, for example.)

[16:48] * moritz could use a js course too

[16:49] *** crab2313 left
[16:49] <PerlJam> does the JS course include jQuery, underscore, coffeescript, or other such things?

[16:50] <masak> PerlJam: aye.

[16:50] <arnsholt> From what I've been able to make out, the most unusual thing about JS is the prototype based OO

[16:50] <arnsholt> Most of the rest of it seems to be relatively manageable from a Perl programmer's perspective

[16:50] <moritz> arnsholt: and typically when you need JS, you also need the DOM

[16:50] <PerlJam> arnsholt: that's only unusual if you come from class-based object systems.

[16:50] <PerlJam> :)

[16:51] <arnsholt> What can I say, I come from a class-based background =)

[16:51] <arnsholt> Perl and Java, mostly, with bits of Python and C# thrown in

[16:56] <masak> we already have a request for this Python course. it's some clever people I taught JavaScript this spring. so I have a very concrete audience to write for. I like that.

[16:56] * timotimo is thinking about type inference on QAST trees

[16:58] <timotimo> there's a way to return a random value from a caller if you're called from it, right? CALLER::return('my value') or something?

[16:59] *** dakkar left
[16:59] <timotimo> r: sub evil() { CALLER::return(42); say "what" }; sub benign() { evil(); 99; }; say benign;

[16:59] <camelia> rakudo 4a608a: OUTPUT«No such method 'Any' for invocant of type 'Int'␤  in sub evil at /tmp/UHtO_F8VDh:1␤  in sub benign at /tmp/UHtO_F8VDh:1␤  in block  at /tmp/UHtO_F8VDh:1␤␤»

[16:59] <timotimo> r: sub evil() { CALLER::return; say "what" }; sub benign() { evil(); 99; }; say benign;

[16:59] <camelia> rakudo 4a608a: OUTPUT«what␤99␤»

[17:00] <masak> timotimo: seems like a weird feature to want. :)

[17:00] <timotimo> if it isn't in there, i'll be happy

[17:00] <masak> timotimo: but with the cooperation of &benign, it can at least be emulated.

[17:00] <timotimo> because otherwise every last bit of type inference-ability goes down the drain

[17:01] <masak> oh, ok.

[17:01] <masak> then "no, you can't do that. that's crazy!" :P

[17:01] *** Bzek left
[17:01] *** xinming left
[17:02] <timotimo> good

[17:03] <timotimo> i'm thinking if i start annotating returns Foo for subs that clearly only have one return point, i could get quite a bit of the setting annotated with returns values automatically

[17:03] *** xinming joined
[17:03] <timotimo> and then if benign assignments between containers carry on that information through the optimizer, further subs could get return type annotations etc etc

[17:05] <timotimo> and at some point, if $var ~~ Type could eliminate type check necessity down the tree and so on and so forth

[17:06] <timotimo> i think qast is a nice format to try these kinds of transformations on

[17:07] *** konundra joined
[17:12] *** sqirrel left
[17:16] *** rindolf left
[17:16] *** rindolf joined
[17:16] *** birdwindupbird left
[17:18] * timotimo is not sure what point (actually range) between "real possibility" and "pipe dream" all this inhabits

[17:19] <benabik> Data-flow Analysis

[17:21] <timotimo> i was vaguely aware of that

[17:27] *** rindolf left
[17:27] *** spider-mario joined
[17:31] <timotimo> thanks, benabik :)

[17:33] <benabik> timotimo: It is a bit more complicated than simply traversing trees, but if you set up a good framework for it (ref: Hoopl, if you don't mind Haskell) you can get a _lot_ of optimization that way.

[17:34] <benabik> timotimo: Dataflow will get you a lot more of the "I assigned things so I know its type", especially across conditionals.

[17:35] <benabik> Propigating up/down trees does get you a lot, but traversing across Stmts nodes is probably more valuable.  The tricky part is conditionals and the _really_ tricky part are loops.

[17:35] <timotimo> yeah, for now i wasn't even going to touch loops ;)

[17:36] <timotimo> and lists of things for that matter.

[17:36] *** kaleem left
[17:37] <timotimo> i think there's some things to be done before actually setting up a proper framework, like a sub that is defined to return Foo would get a type check and when you assign the return value to a my Foo $foo, you'll get another typecheck; those redundancies shouldn't be terribly hard to remove and will probably speed up code that makes heavy use of type annotations quite a bit.

[17:37] *** sqirrel joined
[17:37] *** aindilis joined
[17:40] <benabik> Using annotations like that is a good idea.  I mention it due to "annotating return types automatically".  Gets complex for any non-trivial code.

[17:42] <timotimo> one target i think would be worthwhile is box_n, box_i and box_s; they take the type to box it in as a parameter and the optimizer could get special knowlegde of that and a piece of the setting may get faster

[17:43] * diakopter thinks optimizing effort should saved for a full-blown comprehensive optimizer

[17:43] <timotimo> diakopter: could you elaborate a little bit?

[17:43] *** census joined
[17:44] *** btyler left
[17:45] <timotimo> diakopter: do you mean you'd prefer starting directly with a proper flow analysis framework?

[17:45] <diakopter> well, just tons and tons more thought/planning/analysis/research, yes

[17:47] <timotimo> i read the wikipedia page on data flow analysis and reaching definition, that ought to be enough to turn me into an expert!

[17:47] <timotimo> ;)

[17:48] <masak> I dunno, I appreciate planning and research, but I'm not against short-term benefits, either.

[17:48] <timotimo> i see the situation thusly: i'm not getting paid to do this and i've got a bit of curiosity for the subject. if i do implement a few optimisations, they'll most probably be really, really easy to rip out again once someone comes along to plug in a proper framework

[17:48] <benabik> Really good analysis needs things like SSA, so....  yeah.

[17:48] <timotimo> this is a bit like the "zero sum game" argument for "perl6 is destroying perl!"; it's not like i have the patience to read through fifty papers, become an expert and then write a proper optimization framework on the first try

[17:49] <timotimo> i know i lose interest in such things too quickly much of the time

[17:49] <timotimo> benabik: single static assignment, yes?

[17:49] <benabik> timotimo: Yes.

[17:50] *** vmspb left
[17:50] <timotimo> a friend of mine is doing his bachelor's thesis on something regarding SSA, i've talked to him about it a bit

[17:51] <benabik> Trees are nice for AST, but I've always disliked that trees persisted for so long in HLLcompiler.  Even without SSA, most optimizations deal with blocks not trees.

[17:52] <moritz> http://stackoverflow.com/questions/805107/creating-multiline-strings-in-javascript/15558082#15558082 # crosspost from p5p

[17:52] <benabik> "Wow. That's, uh, creative. :)"

[17:53] <diakopter> 50 papers? I was thinking 500 or so

[17:54] <benabik> I think just two books would be enough.  Dragon covers some basic optimization stuff, and....  shoot, forgot the name of the optimization one. 

[17:55] <masak> moritz: I like that one. not sure I'd use it in production code, as it relies on the serialization details of functions, but...

[17:55] <timotimo> diakopter: that does not change the point, at least in my case

[17:56] <diakopter> oops, I left a ;) out of that

[17:56] <timotimo> me, too ;)

[17:56] <clkao>  40

[17:56] *** census left
[17:56] <timotimo> if somebody wants to go ahead and become an expert, or if someone who's already sufficiently experted in that, wants to go ahead and implement the stuff for our optimizer.nqp, sure, i'd love that person to bits, but i don't see that happen soon enough for my tastes ;)

[17:56] <[Coke]> moritz++ That is awesome.

[17:57] *** SamuraiJack_ joined
[17:57] <timotimo> i have yet to measure it, but i fear we're diminishing the speed benefits we're getting from being able to compile-time dispatch subs by doing far too many type checks at run time when we're playing with typed containers

[17:58] <diakopter> timotimo: that's what I was hoping to devote the next NN years to..

[17:58] <masak> moritz: it would be a bit safer if it didn't hard-code the indices, but used regexes to trim away function and comment markers.

[17:58] * benabik would love to do it, but would need to convince his advisor it's valuable research.

[17:59] <timotimo> r: sub rec(Int $n) returns Int { return $n <= 0 ?? 1 !! rec($n-1) + 1 }; rec(50) + rec(50); # i don't really want to know how much time is wasted on return-type-checking here!

[17:59] <camelia> rakudo 4a608a:  ( no output )

[17:59] <frettled> masak: the response from Jan Dvorak links to a higher rated response to the question, where this (and a minifier issue) is addressed: http://stackoverflow.com/questions/805107/creating-multiline-strings-in-javascript/5571069#5571069

[17:59] <timotimo> (but i can measure it!)

[18:01] * timotimo fails to come up with a big difference

[18:02] <pmurias> benabik: re SSA seems to be aimed at doing a resonably good job quickly, a fix point data flow style of doing things like ghc does (in it's hoopl library) seems like something that would give better quality

[18:02] <frettled> Also, slightly off-topic (but on-topic for modern programming), and I suspect very much of interest to geeks such as masak++: http://vimeo.com/71278954 (A talk from Dropbox's DBX conference, as if it was made in 1973)

[18:02] *** cibs joined
[18:02] <benabik> pmurias: Would probably still be easier to deal with blocks, even if you don't go full SSA.

[18:02] <frettled> … that link will take 32 minutes out of your lives ;)

[18:03] <pmurias> benabik: by block you mean turning things like loops into primitive jumps?

[18:03] <masak> frettled: I linked to accompanying http://worrydream.com/dbx page earlier today ;)

[18:03] <frettled> masak: ah!

[18:04] <benabik> pmurias: Flat blocks of operations instead of nested trees.  Loops are connections to a block.

[18:04] <masak> but yes, I probably should watch the video as well.

[18:04] <benabik> pmurias: Basically a connected string of non-branching operations.

[18:04] *** xinming left
[18:04] <masak> benabik: um... would that form a graph in the general case?

[18:04] <pmurias> yes

[18:04] <benabik> masak: Yes.

[18:04] <masak> benabik: the links between blocks, I mean.

[18:04] <pmurias> a basic block graph

[18:05] <masak> ok.

[18:05] <diakopter> .. which is the 32 min link?

[18:05] <masak> diakopter: http://vimeo.com/71278954

[18:05] <frettled> timotimo: that was a naugty example, BTW :)

[18:05] <timotimo> naughty in what way?

[18:05] <pmurias> and with everything potentially throwing an exception all of our blocks would contain one operation each ;)

[18:05] <benabik> masak: But it's easier to convey data flow information along graph edges than via arbitrarily complex rules on various tree types.

[18:05] <masak> sounds like the basic block graph is pretty much what you need to do a CPS transform.

[18:05] *** grondilu joined
[18:05] <frettled> timotimo: evil recursive code :)

[18:05] <timotimo> i was hoping i could get the return value checks to increase run time sufficiently to be measurable, but apparently it's quite fast either way.

[18:06] <benabik> pmurias: exceptions are... exceptional. ;-)

[18:06] <frettled> timotimo: I suspect you might need to concoct a different example, perhaps with a more complex return type than Int.

[18:06] <pmurias> masak: the basic block graph is basically converting structured control flow into goto/conditional goto

[18:06] *** xinming joined
[18:07] <timotimo> frettled: that may very well be the case, but i fear object creation costs will dominate or something

[18:07] <timotimo> anyway, afk for a bit.

[18:07] <frettled> timotimo: I think you're right.

[18:07] <moritz> calls used to be quite expensive

[18:07] <moritz> I think they still are

[18:08] <timotimo> =time ./perl6 -e 'sub rec(Int $n) returns Int { return $n <= 0 ?? 1 !! rec($n-1) + 1 }; my Int $foo = rec(9999) + rec(9999) * rec(9999) - rec(9999) + rec(9999); say $foo'  -  this only takes 1.48 seconds.

[18:09] <timotimo> that should be 50000 calls

[18:09] <timotimo> 3e-5 seconds per call apparently

[18:09] <frettled> So if this is changed to something that does something with strings … hmm …

[18:09] <diakopter> hm, maybe I would understand this video better if I had audio

[18:09] <frettled> diakopter: yep, somewhat :D

[18:09] <pmurias> benabik: re hoopl, I played a bit with writing a hoopl optimiser for niecza, and I'm planning to do something like that in the future for rakudo

[18:10] *** btyler joined
[18:10] <pmurias> benabik: so I can infer enough info to emit efficient code in my javascript backend ;)

[18:10] <frettled> timotimo: I can't quite wrap my head around how to distinguish call and return costs by looking at the command line.  I think you'd need to use a process tracer or something.

[18:10] <benabik> pmurias: I had planned to do something similar for Parrot, but now it looks like grad school will not leave me enough time.

[18:11] <frettled> There is a fairly decent one built-in to OS X, but, eugh.

[18:12] <pmurias> benabik: is it worth doing anything for Parrot nowdays?

[18:13] *** cibs left
[18:14] *** cibs joined
[18:16] <pmurias> benabik: at least untill they do their grand change of focus

[18:16] <benabik> pmurias: Well, when I was making those plans there were still several active developers.

[18:18] *** sqirrel_ joined
[18:21] *** FROGGS joined
[18:24] *** sqirrel left
[18:24] *** SamuraiJack_ left
[18:28] <pmurias> benabik: what I'm not sure if having a haskell part in the compiler is a good idea

[18:28] <pmurias> s/if/is if/

[18:29] <benabik> pmurias: Don't use Hoopl, use it a basis for design.

[18:32] <pmurias> yes that would be propably what should be done as it would avoid having to convert the QAST between haskell/Perl6

[18:34] *** dmol left
[18:39] <diakopter> pmurias: I thought it was C--

[18:39] <benabik> diakopter: Hoopl is a data-flow analysis library in Haskell, not used by Haskell (that I know of)

[18:40] <diakopter> oh

[18:47] *** dmol joined
[18:52] <masak> wow, Python 2.2 seems to have been a big improvement in many senses. not just the new object model, but also real closures.

[18:56] <[Coke]> time taken to build rakudo-jvm and run the spectests: 79m50.815s

[18:56] <arnsholt> Backscrolling a bit, but regarding CPS and SSA, aren't they a bit similar?

[18:56] <arnsholt> I seem to remember something about that

[18:56] <[Coke]> I really need to time a version from a few weeks ago, that seems much slower to me.

[18:57] <timotimo> i forget what CPS refers to, arnsholt 

[18:57] <arnsholt> Continuation Passing Style

[18:57] <diakopter> 2.2?

[18:57] <timotimo> ah. i don't know why you think they're similar; i don't really see it

[18:58] <arnsholt> I can't remember what it was. It's a dim memory

[18:59] <arnsholt> Anyways, optimisation experimentation gets a +1 from me =)

[18:59] *** sqirrel joined
[18:59] <dalek> perl6-roast-data: 18f59cb | coke++ | / (5 files):

[18:59] <dalek> perl6-roast-data: today (automated commit)

[18:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/18f59cb3b0

[19:00] <dalek> rakudo-star-daily: b4aafce | coke++ | log/ (4 files):

[19:00] <dalek> rakudo-star-daily: today (automated commit)

[19:00] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/b4aafce71e

[19:05] <[Coke]> no change on rakudo-star-daily. hey, tadzik?

[19:06] <[Coke]> .to tadzik https://github.com/tadzik/perl6-File-Tools/issues/14

[19:06] <yoleaux> [Coke]: I'll pass your message to tadzik.

[19:06] <preflex>  yoleaux: you have 1 new message. '/msg preflex messages' to read it.

[19:06] <[Coke]> preflex: help?

[19:06] <[Coke]> preflex: help

[19:06] <preflex>  try 'help help' or see 'list' for available commands

[19:06] <[Coke]> preflex: list

[19:06] <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:

[19:06] <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]

[19:06] <masak> arnsholt: CPS and SSA seems like two almost completely different things.

[19:07] <[Coke]> who owns preflex and can we clear that message?

[19:07] *** telex left
[19:07] <masak> arnsholt: CPS is the idea that there is no 'return' and no call stack as such. only going from one block to another. SSA is the idea that every variable is only assigned to once in each block, and if they're assigned more times, you re-arrange things behind the scenes so they're assigned only once.

[19:10] *** fgomez joined
[19:10] <nwc10> CPS is fun because it effectively means that your control flow within a non-leaf function is completely screwball

[19:10] <nwc10> at least, any optimiser has to be aware that any function might return 0, 1, or many times

[19:10] *** telex joined
[19:11] <nwc10> and any function it calls into might return from any other function

[19:11] <nwc10> actually, that's not CPS. That's just continuations

[19:12] <arnsholt> Yeah, continuations are more than a little weird

[19:12] <hoelzro> is a new NQP/Rakudo * release going out anytime soon?

[19:12] <frettled> [Coke]: unaffiliated/mauke/bot/preflex – maybe it's mauke's?

[19:12] <arnsholt> But I loved how they made it super simple to implement the core bits of a Prolog

[19:13] <nwc10> hoelzro: I think thath rought answer is "well volunteered", or alternatively "no-one has had enough time to fix all the bugs in bundled distros"

[19:13] <arnsholt> [Coke]: You're the 

[19:13] <arnsholt> Stu: Any other comments or observations on the experience?

[19:13] <arnsholt> Malcolm: Has it given me sleepless nights, yes. Has it nearly driven me insane, yes. Would I do it again... in an instant!

[19:13] <arnsholt> Blarg. Fat fingers >.<

[19:14] <hoelzro> nwc10: I'm just wondering if I should build a new Arch package against Parrot 5.6 right now or if I should wait a few day s=)

[19:14] *** btyler_ joined
[19:16] <arnsholt> [Coke]: Do you store the commit IDs for Rakudo/NQP you use to generate the reports in rakudo-star-daily somewhere?

[19:17] *** btyler left
[19:23] <masak> I used to really want continuations natively in Perl 6. now I find I am content with being able to write an interpreter (in Perl 6) that can emulate them when I need them. :)

[19:23] *** jeffreykegler joined
[19:25] *** Guest1337 joined
[19:26] *** jeffreykegler left
[19:29] <arnsholt> Heehee =)

[19:29] <arnsholt> I wonder if I could implement my Prolog purely in NQP, just pushing closures onto the stack...

[19:30] <arnsholt> masak: Incidentally, that's very lispy I think. "$language doesn't have the feature I want? I'll just DSL my way around it!"

[19:30] *** vk_ left
[19:30] <masak> aye.

[19:31] <arnsholt> Incidentally, I read Steve Yegge's "Lisp is not an acceptable Lisp" today. Couldn't help thinking that I hope Perl 6 will be an acceptable Lisp

[19:32] * masak .oO( Perl 6 is not an acceptable Perl 6! )

[19:32] <arnsholt> =D

[19:33] <[Coke]> arnsholt: no, right now it's just "whatever the latest was when the run started."

[19:34] <[Coke]> should be pretty easy to throw them in a log somewhere, though.

[19:35] <[Coke]> arnsholt: 

[19:35] <[Coke]> whoops.

[19:36] <arnsholt> 'k. It'd be great if you put that in somewhere

[19:36] <arnsholt> I sort of wanted it to pre-prune the Rakudo bisect it looks like I can't avoid =)

[19:41] <pmurias> benabik: hoopl is used by ghc

[19:41] <[Coke]> ok. I'm just doing it going forward.

[19:41] <[Coke]> it'll end up in log/version.log

[19:42] <pmurias> masak: rakudo-on-jvm has support for continuations (at least on the nqp level)

[19:45] <arnsholt> [Coke]: Spiffy!

[19:48] <masak> pmurias: ooh -- would be a nice module to expose that... :)

[19:49] *** kaare_ left
[19:52] *** not_gerd joined
[19:52] <not_gerd> o/

[19:52] <not_gerd> https://mail.mozilla.org/pipermail/rust-dev/2013-July/005042.html # everyone wants the colon

[19:52] *** kaare_ joined
[19:52] *** sqirrel_ left
[19:53] <not_gerd> masak: CPS can be used as an intermediate representation in compilers, similar to SSA

[19:53] <not_gerd> wikipedia links to http://dl.acm.org/citation.cfm?doid=202530.202532

[19:55] *** preflex left
[19:56] <pmurias> masak: the ops are well documented so there should be nothing besides tuits stopping you

[19:57] *** preflex joined
[19:57] *** ChanServ sets mode: +v preflex

[19:57] <pmurias> masak: https://github.com/perl6/nqp/blob/master/docs/continuations.pod

[20:03] <masak> pmurias: neat.

[20:03] <masak> not_gerd: yes, this seems to be what benabik and pmurias said above, about the block graph thing.

[20:06] *** grondilu left
[20:06] <masak> not_gerd: I hadn't thought of Miranda, Hope, Clean, Haskell, ML, Ocaml, F# as "the ISWIM languages" before. that's very cute.

[20:07] <masak> 'night, #perl6

[20:09] <pmurias> masak: 'night

[20:09] *** kaare_ left
[20:12] *** colomon joined
[20:14] <dalek> rakudo-js: 141cc9c | (Pawel Murias)++ | nqp:

[20:14] <dalek> rakudo-js: Update nqp submodule.

[20:14] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/141cc9c8c6

[20:14] <dalek> rakudo-js: 1d5f616 | (Pawel Murias)++ | runtime (2 files):

[20:14] <dalek> rakudo-js: Fix nqp::isinvokable.

[20:14] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/1d5f61627a

[20:14] <dalek> rakudo-js: ba2d738 | (Pawel Murias)++ | runtime.js:

[20:14] <dalek> rakudo-js: nqp::iscclass handles matching alphanumeric characters. Implement getlexdyn.

[20:14] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/ba2d7383e1

[20:14] <dalek> rakudo-js: 18ad8b7 | (Pawel Murias)++ | run_tests:

[20:14] <dalek> rakudo-js: Add passing test 61 to run_tests.

[20:14] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/18ad8b7dd7

[20:14] *** not_gerd left
[20:14] *** sqirrel left
[20:19] *** zwut00 joined
[20:19] *** FROGGS left
[20:20] *** FROGGS joined
[20:22] *** Timbus left
[20:23] *** Timbus joined
[20:30] *** raiph joined
[20:39] *** benabik left
[20:40] <timotimo> r: say "foo barf bazump a" ~~ /[$<foo>=[\w+] { say $<foo>.from } \h+]+/

[20:40] <camelia> rakudo 4a608a: OUTPUT«No such method 'from' for invocant of type 'Parcel'␤  in block  at /tmp/skKtldcx9d:1␤␤»

[20:40] <timotimo> r: say "foo barf bazump a" ~~ /[$<foo>=[\w+] { say $<foo>[*-1].from } \h+]+/

[20:40] <camelia> rakudo 4a608a: OUTPUT«0␤4␤9␤16␤｢foo barf bazump ｣␤ foo => ｢foo｣␤ foo => ｢barf｣␤ foo => ｢bazump｣␤␤»

[20:40] <timotimo> not bad.

[20:41] *** lowpro30 joined
[20:42] *** benabik joined
[20:43] <timotimo> r: say "foo bar foo" ~~ /$<foo>=[\w+] .* $<foo>/

[20:43] <camelia> rakudo 4a608a: OUTPUT«｢foo bar foo｣␤ foo => ｢foo｣␤␤»

[20:45] *** benabik left
[20:48] *** benabik joined
[20:53] *** dmol left
[20:58] *** konundra left
[21:06] *** dmol joined
[21:13] *** spider-mario left
[21:20] *** konundra joined
[21:30] *** sqirrel joined
[21:34] <timotimo> how do i splice stuff into lists in perl6 and in nqp? is "nqp::splice" a thing?

[21:34] <timotimo> nqp: my @a; nqp::splice(@a, 1, 1, 1);

[21:34] <camelia> nqp: OUTPUT«elements() not implemented in class 'Integer'␤current instr.: '' pc 49 ((file unknown):43) (/tmp/krZa98dp2o:1)␤»

[21:34] <timotimo> .o(don't know how that works)

[21:37] <timotimo> nqp::splice(@params, [%param_info], $insert_at, 0); - i guess that says it all

[21:37] <timotimo> r: say [1, 2, 3].splice([99], 2)

[21:37] <camelia> rakudo 4a608a: OUTPUT«␤»

[21:37] <timotimo> r: my @a = [1, 2, 3]; @a.splice([99], 2); say @a;

[21:37] <camelia> rakudo 4a608a: OUTPUT«1 2 3␤»

[21:37] <timotimo> r: my @a = [1, 2, 3]; @a.splice([99], 1); say @a;

[21:37] <camelia> rakudo 4a608a: OUTPUT«1 2 3␤»

[21:38] <timotimo> er, huh? hm.

[21:39] *** lowpro30 left
[21:41] <timotimo> r: my @a = [1, 2, 3]; @a.splice(1, 0, [99]); say @a;

[21:41] <camelia> rakudo 4a608a: OUTPUT«1 2 3 99␤»

[21:42] <timotimo> r: my @a = 1, 2, 3; @a.splice(1, 0, [99]); say @a;

[21:42] <camelia> rakudo 4a608a: OUTPUT«1 99 2 3␤»

[21:42] <timotimo> now it makes sense.

[21:45] *** grondilu joined
[21:48] *** PacoAir left
[21:49] *** BenGoldberg joined
[21:52] *** Guest1337 left
[21:58] *** zwut00 left
[21:58] *** benabik left
[21:59] *** raiph left
[22:00] <timotimo> great, now i may try to make code that gives me the current column, not position-in-all-of-the-string ...

[22:01] *** sqirrel left
[22:02] *** konundra left
[22:05] *** grondilu left
[22:07] *** dmol left
[22:09] <timotimo> r: "foo bar baz\nbaz baz baz\nquux uuu quux" ~~ / [ \N*? \h { say $/.CURSOR.pos } ... { say $/.CURSOR.pos } \N*? ]+ /

[22:09] <camelia> rakudo 4a608a: OUTPUT«4␤7␤8␤11␤»

[22:09] <timotimo> hmm

[22:09] <timotimo> ooooh, facepalm-time ...

[22:09] *** bluescreen10 left
[22:11] *** benabik joined
[22:14] *** raiph joined
[22:23] <BenGoldberg> r: "a".ord.say

[22:23] <camelia> rakudo 4a608a: OUTPUT«97␤»

[22:23] <BenGoldberg> r: "ab".ord.say

[22:23] <camelia> rakudo 4a608a: OUTPUT«97␤»

[22:23] <timotimo> r: "ab".ords.say

[22:23] <camelia> rakudo 4a608a: OUTPUT«97 98␤»

[22:24] <BenGoldberg> Ahh.

[22:24] <timotimo> r: "foo     bar     baz" ~~ /^ [\S [\S|\h\S]*]+ % [\h\h+] $/

[22:24] <camelia> rakudo 4a608a:  ( no output )

[22:24] <timotimo> r: say "foo     bar     baz" ~~ /^ [\S [\S|\h\S]*]+ % [\h\h+] $/

[22:24] <camelia> rakudo 4a608a: OUTPUT«｢foo     bar     baz｣␤␤»

[22:24] <timotimo> r: say "foo     bar     baz" ~~ /^ (\S [\S|\h\S]*)+ % [\h\h+] $/

[22:24] <camelia> rakudo 4a608a: OUTPUT«｢foo     bar     baz｣␤ 0 => ｢foo｣␤ 0 => ｢bar｣␤ 0 => ｢baz｣␤␤»

[22:24] <timotimo> whhyyyyyyy

[22:27] *** Guest7049 joined
[22:30] *** Seganku joined
[22:31] *** grondilu joined
[22:32] *** Guest7049 left
[22:32] * grondilu has colors when I type 'git log' now.  Cool.

[22:32] <BenGoldberg> r: say $_ for "foo     bar     baz" ~~ /^ (\S [\S|\h\S]*)+ % [\h\h+] $/

[22:32] <camelia> rakudo 4a608a: OUTPUT«｢foo     bar     baz｣␤ 0 => ｢foo｣␤ 0 => ｢bar｣␤ 0 => ｢baz｣␤␤»

[22:32] <BenGoldberg> r: say "$_" for "foo     bar     baz" ~~ /^ (\S [\S|\h\S]*)+ % [\h\h+] $/

[22:32] <camelia> rakudo 4a608a: OUTPUT«foo     bar     baz␤»

[22:33] * BenGoldberg blinks

[22:34] <grondilu> BenGoldberg: what are you trying to do?

[22:34] <BenGoldberg> Why does the return value of ~~ gets stringified one way with "" and another way without?

[22:35] <BenGoldberg> And I've no idea what the regex is supposed to do, I'm just copying what timotimo wrote

[22:35] <grondilu> r: say $_ given foo => "bar"

[22:35] <camelia> rakudo 4a608a: OUTPUT«"foo" => "bar"␤»

[22:35] <grondilu> r: say "$_" given foo => "bar"

[22:35] <camelia> rakudo 4a608a: OUTPUT«foo       bar␤»

[22:35] <grondilu> hum

[22:35] <[Coke]> BenGoldberg: difference between .Str & .gist

[22:36] * timotimo is making progress on table parsing

[22:36] <grondilu> BenGoldberg: [Coke] nailed it

[22:36] <BenGoldberg> r: say $_.gist given foo => "bar"

[22:36] <camelia> rakudo 4a608a: OUTPUT«"foo" => "bar"␤»

[22:36] <BenGoldberg> r: say $_.Str given foo => "bar"

[22:36] <camelia> rakudo 4a608a: OUTPUT«foo       bar␤»

[22:37] <colomon> .gist versus .Str, I thuink

[22:37] <BenGoldberg> ++[Coke]

[22:37] <colomon> doh, beat to the punch!

[22:38] <[Coke]> say $foo - calls .gist ; "$foo" - .Str-ifies. the .gist of a .Str is the .Str

[22:40] <BenGoldberg> r: .perl.say for "foo     bar     baz" ~~ /^ (\S [\S|\h\S]*)+ % [\h\h+] $/

[22:40] <camelia> rakudo 4a608a: OUTPUT«Match.new(orig => "foo     bar     baz", from => 0, to => 19, ast => Any, list => ((Match.new(orig => "foo     bar     baz", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new()), Match.new(orig => "foo     bar     baz", from => 8, to => 11, ast =…

[22:43] <BenGoldberg> [Coke]++ colomon++ (preflex only sees NICK++, not ++NICK)

[22:44] <corecatcher> :q

[22:44] * hugme hugs corecatcher, good vi(m) user!

[22:44] <diakopter> ++BenGoldberg++

[22:44] <corecatcher> :(

[22:45] <diakopter> what? :D

[22:48] *** fridim__ joined
[22:51] *** konundra joined
[22:55] <grondilu> rn: say my Buf $ .= new: ^10;

[22:55] <camelia> rakudo 4a608a: OUTPUT«Cannot modify an immutable value␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in any  at src/gen/Metamodel.nqp:1461␤  in block  at /tmp/3t7SjCBEi8:1␤␤»

[22:55] <camelia> ..niecza v24-88-g1f87209: OUTPUT«Unhandled exception: Cannot call new; none of these signatures match:␤    Mu, *%_␤  at /tmp/gBFI1ogRYl line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @…

[22:55] <grondilu> wasn't that the proper syntax for initializing a Buffer?

[22:56] <grondilu> r: class Foo { my $.name }; my Foo $x .= new: "foooo"; say $x;

[22:56] <camelia> rakudo 4a608a: OUTPUT«Default constructor for 'Foo' only takes named arguments␤  in method new at src/gen/CORE.setting:816␤  in method new at src/gen/CORE.setting:811␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in block  at /tmp/IKKvb9BPF_:1␤␤»

[22:57] <grondilu> r: class Foo { my $.name }; my Foo $x .= new: name => "foooo"; say $x;

[22:57] <camelia> rakudo 4a608a: OUTPUT«Foo.new()␤»

[22:57] <tadzik> yoleaux: any messages for me?

[22:57] <yoleaux> 19:06Z <[Coke]> tadzik: https://github.com/tadzik/perl6-File-Tools/issues/14

[23:00] <grondilu> guys?  no comment on why 'my Buf $x .= new: @integers' does not work anymore?

[23:01] <grondilu> r: say Buf.new: ^10

[23:01] <camelia> rakudo 4a608a: OUTPUT«Buf:0x<00 01 02 03 04 05 06 07 08 09>␤»

[23:01] <grondilu> r: say my $ = Buf.new: ^10

[23:01] <camelia> rakudo 4a608a: OUTPUT«Buf:0x<00 01 02 03 04 05 06 07 08 09>␤»

[23:01] <grondilu> r: say my Buf $ = Buf.new: ^10

[23:01] <camelia> rakudo 4a608a: OUTPUT«Buf:0x<00 01 02 03 04 05 06 07 08 09>␤»

[23:01] <grondilu> r: say my Buf $ .= new: ^10

[23:01] <camelia> rakudo 4a608a: OUTPUT«Cannot modify an immutable value␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in any  at src/gen/Metamodel.nqp:1461␤  in block  at /tmp/8pKg1hhg8q:1␤␤»

[23:02] * grondilu suspects this is a regression

[23:02] <benabik> r: say my Buf $ .= new(^10)

[23:02] <camelia> rakudo 4a608a: OUTPUT«Cannot modify an immutable value␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in any  at src/gen/Metamodel.nqp:1461␤  in block  at /tmp/k85QiZUVGw:1␤␤»

[23:02] <benabik> r: say my Buf $a .= new(^10)

[23:02] <camelia> rakudo 4a608a: OUTPUT«Cannot modify an immutable value␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in any  at src/gen/Metamodel.nqp:1461␤  in block  at /tmp/p8WSlIX9BC:1␤␤»

[23:03] <grondilu> I've been using this idiom quite a lot.  I guess most of my code is broken now.

[23:07] <grondilu> r: class Foo { my @.a; method new(@a) { self.new: a => @a } }; say my Foo $x .= new: ^10;

[23:07] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/4s2M9l8kFX:1␤  in method new at /tmp/4s2M9l8kFX:1␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in block  at /tmp/4s2M9l8kFX:1␤␤»

[23:08] <grondilu> r: class Foo { my @.a; method new(@a) { self.new: :@a } }; say my Foo $x .= new: ^10;

[23:08] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/2LkjHpOxnk:1␤  in method new at /tmp/2LkjHpOxnk:1␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in block  at /tmp/2LkjHpOxnk:1␤␤»

[23:08] <grondilu> :/

[23:09] <grondilu> why doesn't this work?

[23:09] <grondilu> r: class Foo { my @.name; method new($name) { self.new: :$name } }; say my Foo $x .= new: "john";

[23:09] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/kpuDjCttOX:1␤  in method new at /tmp/kpuDjCttOX:1␤  in method dispatch:<.=> at src/gen/CORE.setting:1145␤  in block  at /tmp/kpuDjCttOX:1␤␤»

[23:09] <grondilu> r: class Foo { my @.name; method new($name) { self.new: :$name } }; say Foo.new: "john";

[23:09] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/LnIRRn9e4Z:1␤  in method new at /tmp/LnIRRn9e4Z:1␤  in block  at /tmp/LnIRRn9e4Z:1␤␤»

[23:10] <grondilu> r: class Foo { my $.name; method new($name) { self.new: :$name } }; say Foo.new: "john";

[23:10] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/mNXNEQvumC:1␤  in method new at /tmp/mNXNEQvumC:1␤  in block  at /tmp/mNXNEQvumC:1␤␤»

[23:10] <grondilu> damn it

[23:11] *** benabik left
[23:11] <grondilu> r: class Foo { my $.name; method new($name) { self.new: name => $name } }; say Foo.new: "john";

[23:11] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/cTo136oWk0:1␤  in method new at /tmp/cTo136oWk0:1␤  in block  at /tmp/cTo136oWk0:1␤␤»

[23:11] <grondilu> :-(

[23:11] <grondilu> oh

[23:11] <grondilu> r: class Foo { has $.name; method new($name) { self.new: name => $name } }; say Foo.new: "john";

[23:11] <camelia> rakudo 4a608a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/fSiu69mwTp:1␤  in method new at /tmp/fSiu69mwTp:1␤  in block  at /tmp/fSiu69mwTp:1␤␤»

[23:12] <grondilu> I guess I need to reread S12

[23:13] *** benabik joined
[23:14] <grondilu> n: class Foo { has $.name; method new($name) { self.new: name => $name } }; say Foo.new: "john";

[23:14] <camelia> niecza v24-88-g1f87209: OUTPUT«(timeout)»

[23:14] <grondilu> n: class Foo { has $.name; multi method new($name) { self.new: name => $name } }; say Foo.new: "john";

[23:14] <camelia> niecza v24-88-g1f87209: OUTPUT«Unhandled exception: Cannot call new; none of these signatures match:␤    Foo, Any␤  at /tmp/XfJ6_asQQq line 1 (Foo.new @ 4) ␤  at /tmp/XfJ6_asQQq line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niec…

[23:14] <grondilu> r: class Foo { has $.name; multi method new($name) { self.new: name => $name } }; say Foo.new: "john";

[23:15] <camelia> rakudo 4a608a: OUTPUT«Foo.new(name => "john")␤»

[23:15] <grondilu> here we go

[23:15] <grondilu> r: class Foo { has $.name; multi method new($name) { self.new: name => $name } }; say my Foo $ .= new: "john";

[23:15] <camelia> rakudo 4a608a: OUTPUT«Foo.new(name => "john")␤»

[23:15] <grondilu> r: class Foo { has $.name; multi method new($name) { self.new: :$name } }; say my Foo $ .= new: "john";

[23:15] <camelia> rakudo 4a608a: OUTPUT«Foo.new(name => "john")␤»

[23:16] *** sidus left
[23:25] <timotimo> r: my @things; push @things[1], 10; say @things;

[23:25] <camelia> rakudo 4a608a: OUTPUT«(Any) 10␤»

[23:25] <timotimo> r: my @things; push @things[1], 10; say @things.perl;

[23:25] <camelia> rakudo 4a608a: OUTPUT«Array.new(Any, [10])␤»

[23:26] <timotimo> r: my @a = 1, 2, 3; say @a.perl; @a = Nil; say @a.perl;

[23:26] <camelia> rakudo 4a608a: OUTPUT«Array.new(1, 2, 3)␤Array.new()␤»

[23:27] <FROGGS> https://github.com/parrot/parrot/issues/889 # comments welcome

[23:32] <grondilu> 'my Buf $ .= new: @a' does not work anymore, is it because Buf is now a role?

[23:33] <FROGGS> I think so

[23:33] <FROGGS> you can try 'utf8' instead

[23:36] <[Coke]> I need something more reliable than "git describe".

[23:37] <[Coke]> (no names found, cannot describe anything)

[23:37] <timotimo> table parsing is driving me insane :)

[23:37] * [Coke] goes with "git log HEAD^..HEAD"

[23:41] <grondilu> r: say my $ = Buf.new: ^10

[23:41] <camelia> rakudo 4a608a: OUTPUT«Buf:0x<00 01 02 03 04 05 06 07 08 09>␤»

[23:41] <grondilu> ^so I guess this is the new correct syntax?

[23:46] <grondilu> why making it a role anyway?

[23:50] *** lowpro joined
[23:51] * grondilu notices that in t/spec/S32-io/spurt.t there is a 'my Buf $buf = Buf.new(...' and he doesn't like the fact that we have to repeat the word Buf in such an initialization.

[23:51] <grondilu> I very much preferred 'my Buf $ .= new: ...'

