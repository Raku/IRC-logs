[00:03] *** pdcawley left
[00:10] *** xinming left
[00:16] *** raiph joined
[00:19] <Ben_Goldberg> rn: ((map { $_ }, ^Inf) but role {})[0].print

[00:19] <camelia> niecza v24-88-g1f87209: OUTPUT«0»

[00:19] <camelia> ..rakudo aab3d7: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/CORE.setting:7492␤  in method reify at src/gen/CORE.setting:6718␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_pos at src/gen/CORE.setting:…

[00:20] <Ben_Goldberg> rn: ((^Inf) but role {})[0].print

[00:20] <camelia> niecza v24-88-g1f87209: OUTPUT«0»

[00:20] <camelia> ..rakudo aab3d7: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in method reify at src/gen/CORE.setting:6581␤  in method reify at src/gen/CORE.setting:6705␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_…

[00:22] <Ben_Goldberg> rn: (^Inf).BUILD

[00:22] <camelia> niecza v24-88-g1f87209: OUTPUT«Unhandled exception: Unable to resolve method BUILD in type Range␤  at /tmp/exY_i8Kn4Z line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /hom…

[00:22] <camelia> ..rakudo aab3d7: OUTPUT«Not enough positional parameters passed; got 1 but expected 5␤  in submethod BUILD at src/gen/CORE.setting:6476␤  in block  at /tmp/bznIq3s7Ez:1␤␤»

[00:22] <Ben_Goldberg> rn: (^Inf but role {}).BUILD

[00:22] <camelia> rakudo aab3d7: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in block  at /tmp/SoyKi2NooD:1␤␤»

[00:22] <camelia> ..niecza v24-88-g1f87209: OUTPUT«Unhandled exception: Unable to resolve method BUILD in type Range+ANON␤  at /tmp/BDvaIqqfSa line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at…

[00:27] <diakopter> anyone know where in Frankfurt the symposium will be

[00:29] *** pdcawley joined
[00:32] *** pdcawley left
[00:55] *** berekuk left
[01:09] <[Coke]> colomon, sorear: what's the plan for niecza in re: spec tests?

[01:10] <colomon> [Coke]: I'm not sure there is a plan.  

[01:10] <colomon> I'd like to fix things up when I get the chance.

[01:10] <colomon> But I feel that working on Rakudo JVM is higher priority at the moment.

[01:10] <colomon> And I'm not even finding time to do that.

[01:11] * colomon may be excessively vacationing this summer.

[01:11] <[Coke]> would you be averse to fudging things that are currently failing if we added issues for them?

[01:12] <[Coke]> or do you want to just leave it?

[01:13] <[Coke]> (I am offerring to do the fudging here.)

[01:36] *** xenoterracide left
[01:36] *** FROGGS_ joined
[01:40] *** FROGGS left
[01:45] <dalek> roast: d6c9458 | coke++ | / (7 files):

[01:45] <dalek> roast: refudge for pugs

[01:45] <dalek> roast: review: https://github.com/perl6/roast/commit/d6c945881f

[01:54] *** go|dfish joined
[01:54] *** xenoterracide joined
[01:55] *** colomon left
[01:56] *** EvanTeitelman joined
[02:06] <dalek> roast: b41523a | coke++ | S32-list/squish.t:

[02:06] <dalek> roast: small fudge for rakudo.jvm

[02:06] <dalek> roast: review: https://github.com/perl6/roast/commit/b41523ac06

[02:09] *** PacoAir joined
[02:12] *** PacoAir left
[02:12] *** FROGGS_ left
[02:36] *** raiph left
[02:57] *** raiph joined
[03:01] *** colomon joined
[03:19] *** colomon left
[03:27] *** preflex_ joined
[03:27] *** ChanServ sets mode: +v preflex_

[03:27] *** preflex left
[03:27] *** mauke left
[03:27] *** mauke joined
[03:27] *** preflex_ is now known as preflex

[03:48] *** grondilu joined
[03:59] *** EvanTeitelman left
[04:03] *** xenoterracide left
[04:08] *** xenoterracide joined
[04:24] <grondilu> check this out:  http://rosettacode.org/wiki/Longest_increasing_subsequence#Perl_6

[04:27] <mauke> heh. is that the equivalent of $l[$i] = [ @{$l[$j]} ] in perl5?

[04:30] <grondilu> yep but th perl5 version is actually the translation from Perl6

[04:32] <grondilu> I don't understand why I could not have written @l[$i] = @l[$j].clone, but maybe I misunderstand what .clone means?

[04:37] <sorear> clone is evil; it's always either deeper or shallower than the user expects

[04:44] <grondilu> ok

[04:46] *** Ben_Goldberg left
[04:48] <moritz> \o

[04:48] <sorear> o/

[04:52] <grondilu> maybe I can write @l[$i] = @l[$j].Array   It's not shorter, but it looks cleaner.

[04:53] <grondilu> and it works (just checked)

[05:06] *** Urchin[emacs] left
[05:19] *** Urchin[emacs] joined
[05:20] <dalek> rakudo/nom: 63a865a | moritz++ | ConfigureJVM.pl:

[05:20] <dalek> rakudo/nom: [configure] fix help text

[05:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63a865aa43

[05:30] *** raiph left
[05:55] <timotimo> grondilu: i suspect .item would have helped, too

[05:57] *** SamuraiJack__ joined
[06:04] <grondilu> timotimo: nope, item does not work actually

[06:10] *** |ChErOkY| left
[06:20] <timotimo> strange

[06:22] <timotimo> oh it's because you're accessing the same list on both sides, eh? hm.

[06:23] *** araujo left
[06:24] *** araujo joined
[06:36] *** kaare_ joined
[06:51] *** raiph joined
[06:56] *** lizmat joined
[07:22] * lizmat is catching up on backlog

[07:22] <yoleaux> 17 Aug 2013 06:42Z <FROGGS> lizmat: please read http://irclog.perlgeek.de/perl6/2013-08-17#i_7462070

[07:24] <lizmat> FROGGS: I'm not sure how that can have broken the build, as I have spectested it and it came out ok ?

[07:24] <lizmat> .oO( Heisenbug? )

[07:26] <timotimo> may very well be one :(

[07:27] <timotimo> the only thing i can think of is you changed the Makefile*.in files, in which case you could only see the bug if you had run Configure.pl

[07:27] <lizmat> that patch most definitley did not change .in files

[07:27] <lizmat> it's been a while since I did that

[07:28] <moritz> lizmat: afaik the patch broke the build only on jvm

[07:28] <lizmat> aha!

[07:28] <moritz> (while compiling the setting, iirc)

[07:28] <lizmat> ok, that makes some sort of sense then

[07:28] <lizmat> but then it's a .JVM problem  :-)

[07:29] <lizmat> there *is* someting spooky about that code, as I have tried to abstract the code that lives in 7 places into an internal method

[07:29] <lizmat> and with that, it just simply did not work

[07:30] <lizmat> guess I'll rework it to using an internal method, and have jnthn++ and others figure out why it doesn't work

[07:31] *** Urchin[emacs] left
[07:32] <masak> good morning, #perl6

[07:33] <moritz> lizmat: that's what branches are good for :-)

[07:33] <moritz> good morning masak

[07:34] <moritz> masak: t3?

[07:35] <masak> moritz: $work deadline.

[07:35] <masak> moritz: maybe, um, Friday.

[07:36] * moritz has high hopes

[07:36] <masak> :)

[07:37] <masak> thanks for caring. it warms.

[07:37] <moritz> .oO( we thank you for you're patients )

[07:38] *** locsmif left
[07:39] <lizmat> .tell jnthn trying to fix "is default" trait mod with $what.^mro.first( { !nqp::p6bool(.HOW.is_mixin($_)) } ), does not work  :-(

[07:39] <yoleaux> lizmat: I'll pass your message to jnthn.

[07:42] <sorear> o/ masak

[07:43] <masak> sorear! \o/

[07:43] <masak> sorear: I'm progressing in my category theory madn^Wknowledge.

[07:43] <masak> sorear: mostly by explaining stuff to jnthn.

[07:43] <moritz> we have sore(ar)ly missed you at YAPC::EU

[07:43] <masak> sorear: most recently: products are terminal objects in a (specially-made) category of spans.

[07:44] *** FROGGS_ joined
[07:45] *** FROGGS_ is now known as FROGGS

[07:45] <FROGGS> o/

[07:45] <masak> FROGGS! \o/

[07:45] <FROGGS> :D

[07:47] <sorear> mmm, universal properties

[07:47] <masak> indeed!

[07:47] *** thou left
[07:48] <masak> learning about products and coproducts is like waking up and realizing that all your life, people have been telling you exactly two things, but they sounded like 1024 things because the words were slightly different.

[07:50] <lizmat> r: my %h is dynamic=a=>1; say %h<a>.VAR.dynamic # I guess this should be 1

[07:50] <camelia> rakudo 63a865: OUTPUT«0␤»

[07:51] <lizmat> r: my %h is dynamic=a=>1; say %h.VAR.dynamic # as is this

[07:51] <camelia> rakudo 63a865: OUTPUT«No such method 'dynamic' for invocant of type 'Hash'␤  in block  at /tmp/RvNxncwyrH:1␤␤»

[07:51] <lizmat> huh?

[07:52] <masak> jnthn (and others): http://www.cis.upenn.edu/~stevez/papers/LZ06b.pdf -- "A Language-based Approach to Unifying Events and Threads"

[07:52] <lizmat> ah, that was part of the patch that FROGGS reverted  :-(

[07:53] <FROGGS> lizmat: yeah :o(

[07:53] <FROGGS> lizmat: did you know what went wrong?

[07:54] <lizmat> well, on parakudo it works fine

[07:54] <lizmat> spectest and all

[07:54] <FROGGS> right, but something on the jvm breaks the build

[07:55] <lizmat> yes, something: what was the error message?

[07:56] <FROGGS> an UnwindException

[07:56] * FROGGS is searching for a gist

[07:59] <FROGGS> lizmat: I only can provide this right now: http://irclog.perlgeek.de/perl6/2013-08-16#i_7459060

[08:00] <lizmat> ok, thanks1

[08:01] <masak> nice article about a bootstrapping compiler: http://blog.rzimmerman.me/how-kal-compiles-itself/

[08:01] <masak> looks quite a lot like nqp.

[08:08] *** pernatiy joined
[08:34] <FROGGS> nqp: say( nqp::objprimspec( nqp::knowhow().new_type(:name("TestBigInt"),:repr("P6bigint")) ) ) # jnthn, should this return 0 ?

[08:34] <camelia> nqp: OUTPUT«1␤»

[08:36] <masak> what does nqp::objprimspec do?

[08:42] *** dmol joined
[08:44] <FROGGS> 0 = non-native/obj/PMC, 1 = int, 2 = num, 3 = str

[08:50] <masak> well, I guess then it comes down to whether P6bigint pretends (enough) to be an int, or whether the fact that it's actually not takes precendence.

[08:52] *** spider-mario joined
[09:04] *** Rotwang joined
[09:05] <FROGGS> how can I check that something is a 6model object? in nqp?

[09:08] <lizmat> hmmm… it seems that in src/core/terms, line 19: %ENV{$key} = nqp::p6box_s(nqp::atkey($env, nqp::unbox_s($key)));

[09:08] <lizmat> is *not* using the at_key method provided in the role at line 31

[09:09] <lizmat> jnthn: any idea what could be going on there ?

[09:09] <lizmat> I assume that that is what was breaking the build on the JVM

[09:09] <lizmat> and was causing the method approach I had not to work on parakudo

[09:12] *** rindolf joined
[09:23] *** SamuraiJack__ left
[09:27] *** raiph left
[09:29] <GlitchMr> std: (1 + 2) / (3 / 4))

[09:29] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected closing bracket at /tmp/t9qqZVS9UV line 1:␤------> [32m(1 + 2) / (3 / 4)[33m⏏[31m)[0m␤Parse failed␤FAILED 00:00 43m␤»

[09:31] <GlitchMr> std: class Test { for ^5 { .say } }

[09:31] <camelia> std c2215f0: OUTPUT«ok 00:00 43m␤»

[09:32] <masak> I'm confused. https://twitter.com/YoshuaDavis/status/367747879147827200/photo/1

[09:32] <masak> I don't think that's an autopun... o.O

[09:33] <masak> ...but I'm not sure...

[09:47] * jnthn ain't sure either

[09:47] <yoleaux> 07:39Z <lizmat> jnthn: trying to fix "is default" trait mod with $what.^mro.first( { !nqp::p6bool(.HOW.is_mixin($_)) } ), does not work  :-(

[09:48] <jnthn> FROGGS: Yes, P6bigint does not inline as a native int

[09:49] *** kaare_ left
[09:58] *** iSlug joined
[10:07] *** crab2313 joined
[10:11] *** crab2313 left
[10:11] *** xinming joined
[10:16] <lizmat> jnthn: in src/core/tems, the local %ENV is bound to %*ENV with "nqp::bindkey(nqp::who(PROCESS), '%ENV', %ENV);"

[10:17] <lizmat> could you think of any reason why that would fail ?

[10:17] *** berekuk joined
[10:18] <lizmat> I've basically conflated the role of %ENV into "my %ENV does role {", as apparently the Hash.at_key was being called instead of the role's

[10:19] <lizmat> I've verified that the hash is filled correctly, and that the role's "at_key" is used, but now %*ENV is empty

[10:20] <jnthn> lizmat: Hmm...

[10:21] <jnthn> lizmat: Dunno how well that'd work out on JVM...

[10:21] <lizmat> the filling of the hash is the only part that is currently VM dependent

[10:23] * jnthn wonders how that trait_mod looks

[10:23] <jnthn> Before it just used the does operator, no?

[10:23] <lizmat> before it said "my %ENV" and then later "%ENV does role {...}

[10:23] <jnthn> Right, looking at the code that seems correct.

[10:24] <lizmat> but then, the at_key of the role was *not* used

[10:24] <jnthn> We populate it cheaply, then attach the extra magic for the future.

[10:24] <lizmat> it would use the Hash.at_key

[10:24] <jnthn> Was not used when? In the initial population?

[10:24] <lizmat> yup

[10:24] <jnthn> Right, that looks deliberate and good to me.

[10:24] <lizmat> ok

[10:25] * lizmat reverts local commit

[10:25] <jnthn> No point creating all those Proxy objects on the initial population 

[10:26] <lizmat> ok, but then I get "cannot assign to read only value: error on line 19: %ENV{$key} = nqp::p6box_s(nqp::atkey($env, nqp::unbox_s($key)));

[10:26] <lizmat> *that* is the top of the stack

[10:27] <lizmat> so I don't know where it is going wrong in "at_key" or CLONE_ELEMENT

[10:28] *** berekuk left
[10:28] <jnthn> CLONE_ELEMENT is that thing I'm about to make redundant by adding the scalarfromdesc op, I guess?

[10:28] <lizmat> yes

[10:32] * jnthn is working on the op now

[10:34] <lizmat> jnthn++

[10:35] <jnthn> r: my %h; say %h<a> + 1

[10:35] <camelia> rakudo 63a865: OUTPUT«use of uninitialized value of type Any in numeric context  in block  at /tmp/_aNlwoZ0at:1␤␤1␤»

[10:35] <lizmat> jnthn: also make sure that "dynamic" flag is cloned

[10:36] <jnthn> lizmat: That flag is in the descriptor, iirc?

[10:36] *** berekuk joined
[10:36] <jnthn> lizmat: We're not cloning, just attaching.

[10:36] <lizmat> r: my %h is dynamic=a=>1; say %h<a>.VAR.dynamic  # to handle this

[10:36] <camelia> rakudo 63a865: OUTPUT«0␤»

[10:36] <jnthn> (to a new container)

[10:36] <lizmat> yes, it's in the descriptor

[10:36] <jnthn> ok, then it'll be fine

[10:38] <jnthn> btw, I noticed the patch also added a .descriptor; that object wasn't designed to leak out into Perl 6 space.

[10:38] *** grondilu left
[10:39] <lizmat> that was only to make CLONE_ELEMENT work

[10:39] <jnthn> ok, good

[10:39] <lizmat> I'll unleak it  :-)

[10:40] <jnthn> It already was when FROGGS's reverted the patch

[10:40] <lizmat> indeed

[10:41] *** leont joined
[10:42] <leont> How do I do mkpath in perl6? It seems rmdir is documented but its opposite not

[10:43] <lizmat> fwiw, mkdir exists

[10:46] *** jaffa4 joined
[10:46] <jaffa4> hi

[10:46] <jaffa4> what is the scope of label in Perl6?

[10:47] <lizmat> apart from it being NYI, afaik, it's supposed to be lexotic?

[10:48] <jaffa4> NYI?

[10:48] <jaffa4> it is possible to reference it from an outer scope ?

[10:49] <GlitchMr> I've a problem. I tried everything, but I cannot use IPv6 in Perl 6.

[10:49] <GlitchMr> getaddrinfo failed: ipv6.google.com: Success

[10:49] <jaffa4> everything? It looks like a big word too me....

[10:49] <GlitchMr> $ perl6 -e 'my $sock = IO::Socket::INET.new(host => "ipv6.google.com", port => 80); $sock.send("GET /lol HTTP/1.1\r\n\r\n"); say $sock.recv'

[10:49] <lizmat> Not Yet Implemented

[10:50] <GlitchMr> This doesn't work. I also tried using IPv6 address, instead of host.

[10:50] <GlitchMr> But it doesn't work too.

[10:54] <jaffa4> $/.CURSOR,,,, where is it defined?

[11:01] *** donaldh joined
[11:01] *** grondilu joined
[11:03] <dalek> nqp: 9706494 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/CompilationUnit.java:

[11:03] <dalek> nqp: Avoid UnwindException reports in load failures.

[11:03] <dalek> nqp: 

[11:03] <dalek> nqp: This prevents the real error from being obscured when e.g. a failure

[11:03] <dalek> nqp: occurs during setting loading.

[11:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9706494b05

[11:03] <lizmat> jnthn++ for allowing people to find out what I broke  :-)

[11:03] *** berekuk left
[11:04] <jnthn> It's allowing me to find out what I'm breaking too :)

[11:04] <donaldh> hi o/

[11:04] <jaffa4> break dance

[11:04] <jnthn> oh, duh, I did something retartet

[11:05] <jaffa4> jnthn: how would you add a label to the symbol table?

[11:05] <jnthn> jaffa4: The .CURSOR method is defined in the NQPMatch or Match objects, i suspect

[11:05] <jnthn> o/ donaldh 

[11:06] <jnthn> jaffa4: $*W.install_lexical_symbol is the usual way to put something there

[11:06] <donaldh> is it okay for rakudo to share NQP_REVISION between jvm and parrot ?

[11:06] *** berekuk joined
[11:06] <jnthn> donaldh: I think so

[11:07] *** rindolf left
[11:07] <jnthn> donaldh: If we find it's causing too many bumps we can undo it

[11:07] <jnthn> donaldh: uh, split it

[11:07] <jnthn> donaldh: But as JVM stabalizes as a backend, I suspect it won't be an issue.

[11:07] * donaldh imagines the confusion of two different NQP_REVISIONs

[11:07] <jnthn> Yeah, I think that'd be icky too :)

[11:07] <donaldh> okay, bumping NQP_REVISION to, well, about now.

[11:07] <donaldh> :)

[11:08] *** berekuk left
[11:11] *** sarah1981 joined
[11:11] <sarah1981> hi

[11:11] *** sarah1981 left
[11:19] * lizmat catches up on some sleep again&

[11:21] <dalek> rakudo/scalar-from-desc: 7f1cd51 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakOps.java:

[11:21] <dalek> rakudo/scalar-from-desc: Ensure gcx.Nil gets initialized.

[11:21] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/7f1cd514ce

[11:21] <dalek> rakudo/scalar-from-desc: 1964396 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakudoContainerSpec.java:

[11:21] <dalek> rakudo/scalar-from-desc: Correct Nil handling.

[11:21] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/1964396953

[11:21] *** kaare_ joined
[11:22] <masak> hello from a train! :)

[11:22] <jnthn> Is it running late?

[11:22] <jnthn> :P

[11:22] <masak> not yet.

[11:25] <mathw> hello from my house!

[11:26] <masak> r: for <masak train mathw house> -> $user, $location { say "$user says hello from a $location!" }

[11:26] <camelia> rakudo 63a865: OUTPUT«masak says hello from a train!␤mathw says hello from a house!␤»

[11:37] <jaffa4> r: 

[11:37] <jaffa4> masak: where are you going?

[11:41] *** jeff_s2 joined
[11:41] *** jeff_s1 left
[11:41] <masak> jaffa4: sometimes $work sends me to different cities to teach.

[11:42] <jaffa4> masak: what do you teach?

[11:43] <FROGGS> jnthn: is a bigint inlineable? https://github.com/perl6/nqp/blob/master/src/vm/parrot/6model/reprs/P6bigint.c#L145

[11:43] <masak> jaffa4: software development.

[11:44] <masak> jaffa4: this week, I'll be teaching the general stuff (software architecture) and then the more specific stuff (Python).

[11:44] <FROGGS> *lol*

[11:44] <FROGGS> :P

[11:44] <FROGGS> (that is an insider)

[11:45] <jnthn> FROGGS: Yes

[11:45] <FROGGS> hmmm, then I am missing a piece of my puzzle

[11:46] <donaldh> hmm. Long test cycle for --gen-nqp on JVM, regression testing all the gen/with parrot/jvm prefix/noprefix combinations

[11:46] <FROGGS> jnthn: if it is inlineable, and objprimspec and isint tell it is an int, how can I know it is not a native int already?

[11:47] <jnthn> objprimspec thinks it's an int?

[11:47] <FROGGS> it returns one

[11:48] <masak> jaffa4: to answer your earlier question: yes, you can reference labels from an outer scope. but you can't jump into a scope that require parameters, because those parameters would not be present and That Would Be Bad.

[11:48] <masak> though as I think about it, I think even that restriction is a bit too narrow.

[11:49] <FROGGS> jnthn: so, I remember that you said that I change nqp.ops to this again: $1 = ss.boxed_primitive == STORAGE_SPEC_BP_INT ? 1 : 0;

[11:49] <FROGGS> err, wrong paste

[11:49] <masak> because, for example, a closure is not really part of the control flow of its OUTER. so if you goto'd it and it exited, where would you end up?

[11:49] <FROGGS> jnthn: to this: $1 = ss.inlineable ? ss.boxed_primitive : STORAGE_SPEC_BP_NONE;

[11:50] <FROGGS> jnthn: but since it is inlineable the result is still 1

[11:50] <jaffa4> I managed to add the labels to the grammar along with the message  they are not implemented

[11:51] <jnthn> oh, wait...maybe it claims to be an int since you can nqp::unbox_i on it...

[11:51] <FROGGS> jaffa4: and the spectests stil pass?

[11:51] <FROGGS> jnthn: yeah

[11:51] <jaffa4> they have not passed all before thay

[11:52] <FROGGS> jnthn: but in nqp::sprintf I actually need to know whether to unbox or not, and I dont know how to get that information

[11:52] <FROGGS> jaffa4: I mean, are there any regressions due to your patch?

[11:52] <jaffa4> How would I know that?

[11:52] <masak> jaffa4: 'make test'

[11:52] <FROGGS> and you compare the result

[11:52] <masak> jaffa4: if the spectests all pass, the next step would be sending a patch (to RT) or a pull request (to github's rakudo/rakudo)

[11:53] <jaffa4> then I have to make it twice before and after

[11:53] <FROGGS> yes

[11:55] <masak> jaffa4: most of us pull/build/make test daily. since we're in the habit, we only need to make test once, afterwards :)

[11:56] <jaffa4> what tests do you perform? full scale?

[11:58] <masak> jaffa4: 'make test' runs the spectest suite. if that didn't answer your question, please rephrase.

[11:59] <jaffa4> you mean coretest

[11:59] <jaffa4> test    : coretest <<<<<

[11:59] <jaffa4> fulltest: coretest stresstest <<<<

[11:59] <masak> no, I mean https://github.com/perl6/roast

[12:00] <masak> also known as 'the spectest suite'.

[12:00] <masak> the fact that it's called 'roast' is because TimToady found it annoying that the 'spec/' and 'spectest/' directories clashed when tab-completing.

[12:01] <jaffa4> I think when I use nmake fulltest it uses roast

[12:02] <masak> I think so too.

[12:05] <jaffa4> this takes a while

[12:06] <masak> yes.

[12:07] <masak> on the other hand, we don't have many regressions.

[12:09] <jaffa4> that is how I do myself with some of my software

[12:11] <jaffa4> Are the tests stored anywhere?

[12:11] <FROGGS> nmake spectest <---

[12:11] <FROGGS> in t\spec

[12:11] <jaffa4> the test results

[12:12] <FROGGS> no, these are just displayed

[12:12] <FROGGS> but you can set a tap harness environment variable to capture it

[12:12] <FROGGS> though it will be overwritten by next run

[12:13] <FROGGS> I usually just copy&paste the test summary to a new file, before applying a patch and after

[12:14] <FROGGS> jnthn: and in order to supply an argument handler I'd need to know if the variable I got is a 6model obj

[12:15] <FROGGS> jnthn: and I dont know how to do that either :o)

[12:15] <FROGGS> (my knowless is great)

[12:15] *** colomon joined
[12:23] <colomon> [Coke]: fudge ==> issues sounds good to me

[12:35] *** bearman joined
[12:35] <jnthn> FROGGS: What's the actual thing you're trying to work out?

[12:36] <FROGGS> jnthn: getting t/jvm/06-sprintf.t to work under nqp@parrot

[12:37] <JimmyZ> .oO(It works on MoarVM, but not on parrot)

[12:39] <jnthn> It probably works anywhere where everything is a 6model object :P

[12:39] <JimmyZ> :P

[12:41] *** birdwindupbird joined
[12:42] <jnthn> FROGGS: Can you show me the code that fails?

[12:49] <FROGGS> sure, need to recompile though

[12:50] <jnthn> np; busying myself with some hash/array stuff

[12:51] <FROGGS> dev/nqp$ nqp -e 'my $kh := nqp::knowhow().new_type(:name("TestBigInt"), :repr("P6bigint")); my $i := nqp::pow_I(nqp::box_i(33, $kh), nqp::box_i(21, $kh), $kh, $kh); nqp::say(nqp::sprintf("<%d>", [$i]));'

[12:51] <FROGGS> get_integer() not implemented in class 'TestBigInt'

[12:51] <FROGGS> current instr.: 'intify' pc 50329 (src/stage2/gen/NQPHLL.pir:19453) (src/stage2/gen/NQPHLL.nqp:2130)

[12:51] <FROGGS> jnthn: ^^

[12:52] <jnthn> Does pow_I actually take two bigints?

[12:53] <FROGGS> you can ask questions :P

[12:54] <FROGGS> I'd think so # QAST::Operations.add_core_pirop_mapping('pow_I', 'nqp_bigint_pow', 'PPPPP', :inlinable(1));

[12:56] <FROGGS> and in bigint_ops it calls get_bigint on the args

[12:56] <jnthn> hm, core setting agrees in its usage too

[12:56] <jnthn> Oh, but it's somewhere in nqp::sprintf that it explodes?

[13:00] <FROGGS> jnthn: yes, I believe it explodes when calling nqp::box_i on it (which is there because it thinks it is a native int)

[13:01] *** pmurias joined
[13:23] *** colomon left
[13:34] <dalek> rakudo/scalar-from-desc: 4d160b3 | jnthn++ | src/vm/jvm/ (2 files):

[13:34] <dalek> rakudo/scalar-from-desc: Add nqp::p6scalarfromdesc op on JVM backend.

[13:34] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/4d160b3c7b

[13:34] <dalek> rakudo/scalar-from-desc: d3bd8df | jnthn++ | src/Perl6/ (2 files):

[13:34] <dalek> rakudo/scalar-from-desc: Tease apart scalar init and default value.

[13:34] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/d3bd8dfbfe

[13:34] <dalek> rakudo/scalar-from-desc: 2d6e418 | jnthn++ | src/core/ (2 files):

[13:34] <dalek> rakudo/scalar-from-desc: Start switching over to nqp::p6scalarfromdesc.

[13:34] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/2d6e4185a3

[13:34] *** ivanoff joined
[13:43] *** stevan_ joined
[13:43] <FROGGS> jnthn: do you think you have time later to have a look at the from_nqp branches later?

[13:47] *** BenGoldberg joined
[13:48] <FROGGS> the problem was that nqp does stuff that rakudo should do: https://github.com/perl6/nqp/commit/ab98aad041055eda5d5d898584f794081253e15a#L2L89

[13:48] <FROGGS> but I was/am unable to fix it

[13:48] *** telex joined
[13:50] <BenGoldberg> rn: (^Inf but role {})[0].print

[13:50] <camelia> niecza v24-88-g1f87209: OUTPUT«0»

[13:50] <camelia> ..rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in method reify at src/gen/CORE.setting:6581␤  in method reify at src/gen/CORE.setting:6705␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_…

[13:51] <masak> I'm almost tempted to report that one as a rakudobug.

[13:51] <jnthn> Weird error.

[13:51] * masak submits rakudobug

[13:52] <FROGGS> rn: (^3 but role {})[0].print

[13:52] <camelia> niecza v24-88-g1f87209: OUTPUT«0»

[13:52] <camelia> ..rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in method reify at src/gen/CORE.setting:6581␤  in method reify at src/gen/CORE.setting:6705␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_…

[13:52] <masak> Niecza's result looks perfectly reasonable to me.

[13:52] *** ajr joined
[13:53] *** ajr is now known as ajr_

[13:53] *** fridim__ left
[13:53] <FROGGS> r: say (^3 but role {}).^methods # it even says it has a method BUILD

[13:53] <camelia> rakudo 63a865: OUTPUT«new flat infinite iterator list bounds reify at_pos roll pick of ACCEPTS perl Numeric <anon> <anon> <anon> <anon> BUILD elems infinite item fmt Int Num chrs Numeric Str␤»

[13:53] <TimToady> it's a submethod, so cannot be used by a subclass

[13:54] <jnthn> ah, yes.

[13:54] <FROGGS> yeah, seen that too right now

[13:54] <TimToady> guessing the generic BUILD method then can't handle the difference

[13:55] <dalek> rakudo/scalar-from-desc: 1c86f71 | jnthn++ | src/Perl6/Actions.nqp:

[13:55] <dalek> rakudo/scalar-from-desc: Fix a thinko to blame for most regressions.

[13:55] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/1c86f71ec1

[13:55] <masak> still, an error seems a bit harsh.

[13:55] *** EvanTeitelman joined
[13:56] <TimToady> maybe some types need to supply a method rather than a submethod BUILD, if they are fiddly to derive from

[13:57] <masak> r: say (1..1 but role {})[0]

[13:57] <camelia> rakudo 63a865: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/MEMHJML4vP␤Operators '..' and 'but' are non-associative and require parenthesis␤at /tmp/MEMHJML4vP:1␤------> [32msay (1..1 [33m⏏[31mbut role {})[0][0m␤    expecting any of:␤        postfix␤        infix …

[13:57] <TimToady> though in this case, it seems as though it's a missing Mu.BUILD

[13:57] <BenGoldberg> Here's a similar problem:

[13:57] <BenGoldberg> rn: my @a := gather { .take for ^Inf } but role { method infinite() { True } }; say @a[^10];

[13:57] <masak> r: say ((1..1) but role {})[0]

[13:57] <camelia> niecza v24-88-g1f87209: OUTPUT«0 1 2 3 4 5 6 7 8 9␤»

[13:57] <camelia> ..rakudo 63a865: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/CORE.setting:7492␤  in method reify at src/gen/CORE.setting:6718␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_pos at src/gen/CORE.setting:…

[13:57] <camelia> rakudo 63a865: OUTPUT«1␤»

[13:57] <masak> o.O

[13:58] <masak> r: print ((1..1) but role {})[0]

[13:58] <camelia> rakudo 63a865: OUTPUT«1»

[13:58] <TimToady> or the submethod is blocking inheritance of the generic Mu.BUILD

[13:58] <masak> why does *that* work?

[13:59] <BenGoldberg> r: Mu.^methods.say

[13:59] <camelia> rakudo 63a865: OUTPUT«ACCEPTS WHERE WHICH take WHY Bool so not defined new CREATE bless BUILDALL BUILD_LEAST_DERIVED Numeric Real Str Stringy item say print gist perl DUMP DUMP-PIECES DUMP-OBJECT-ATTRS isa does can clone Capture Method+{<anon>}.new() dispatch:<::> Method+{<anon>}.new() …

[13:59] <masak> r: print ((0..^3) but role {})[0]

[13:59] <camelia> rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in method reify at src/gen/CORE.setting:6581␤  in method reify at src/gen/CORE.setting:6705␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_…

[14:00] <masak> r: print ((0..3) but role {})[0]

[14:00] <camelia> rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Range+{<anon>}'␤  in method reify at src/gen/CORE.setting:6581␤  in method reify at src/gen/CORE.setting:6705␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_…

[14:00] <masak> r: print ((3..3) but role {})[0]

[14:00] <camelia> rakudo 63a865: OUTPUT«3»

[14:00] <masak> ah.

[14:00] <masak> needs to have different endpoints.

[14:00] <masak> r: print ((3..0) but role {})[0]

[14:01] <jnthn> I guess it's on creation of the next iterator

[14:01] <camelia> rakudo 63a865:  ( no output )

[14:01] <jnthn> Which makes sense given BUILD is complained about.

[14:01] <masak> needs to have start smaller than end, even.

[14:01] <masak> jnthn: aye.

[14:01] <TimToady> r: say ((0..3) but role { submethod BUILD(|c) { Mu.BUILD(c) } })[0,1]

[14:01] <camelia> rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Mu'␤  in submethod BUILD at /tmp/CX8cckAm6b:1␤  in method BUILD_LEAST_DERIVED at src/gen/CORE.setting:915␤  in sub infix:<but> at src/gen/CORE.setting:14967␤  in sub infix:<but> at src/gen/CORE.setting:14962␤  in block  …

[14:02] <TimToady> r: say ((0..3) but role { submethod BUILD(|c) { self.Mu::BUILD(c) } })[0,1]

[14:02] <camelia> rakudo 63a865: OUTPUT«No such method 'BUILD' for invocant of type 'Mu'␤  in any find_method_qualified at src/gen/Metamodel.nqp:956␤  in method dispatch:<::> at src/gen/CORE.setting:1135␤  in submethod BUILD at /tmp/Do71SurzaD:1␤  in method BUILD_LEAST_DERIVED at src/gen/CORE.setting:915…

[14:02] <TimToady> hmm

[14:03] <TimToady> oh, it said BUILD_LEAST_DERIVED, not BUILD

[14:03] <BenGoldberg> r: (gather {} but role {})[0]

[14:03] <camelia> rakudo 63a865: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/CORE.setting:7492␤  in method reify at src/gen/CORE.setting:6718␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_pos at src/gen/CORE.setting:…

[14:04] <BenGoldberg> A range produces one type of error, and a gather a different type of error?

[14:04] <TimToady> so how *does* rakudo handle missing BUILD submethods, anyway?

[14:05] * masak .oO( badly )

[14:05] <BenGoldberg> n: (gather {} but role {})[0]

[14:05] <camelia> niecza v24-88-g1f87209:  ( no output )

[14:05] <TimToady> S12:667 seems to indicate there should be a Mu.BUILD

[14:05] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_667

[14:06] *** crab2313 joined
[14:06] *** domidumont joined
[14:07] <TimToady> not to mention S12:866

[14:07] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_866

[14:08] <jnthn> TimToady: Calling a BUILD that actually does introspection etc. turned out to be incredibly slow. BUILDALL actually executes a class-compose-time assembled "plan" for how to do the object construction. Thus the lack of "need" for a Mu.BUILD.

[14:09] <TimToady> ok, but the plan in this case seems...lacking...

[14:09] <jnthn> TimToady: Thanks to all the named arg passing around, it's rather hard to get object construction to perform decently...

[14:09] *** crab2313 left
[14:10] <jnthn> TimToady: I think that the range "make a next iterator" code is cheating and doing a .BUILD call directly on a .CREATE'd object...

[14:10] <jnthn> Which I guess is an OK cheat, expect it's also marked as a submethod

[14:11] <TimToady> so maybe it should be a normal method?

[14:11] <TimToady> or would that break differently? :)

[14:11] <jnthn> That would seem to fix this particular issue, yes.

[14:11] <jnthn> I can't immediately think of anything else it'd break

[14:12] <TimToady> well, it'd be nice to have a better story than Ruby on derivation from built-in types :)

[14:12] *** stevan_ left
[14:12] <TimToady> but one also wants speed

[14:12] <jnthn> The real pain I find with trying to get object construction to perform is that new gets a named slurply, which it then flattens to pass to bless, which in turn creates a new named slurpy

[14:12] *** colomon joined
[14:13] <jnthn> You can't just re-use the capture because bless wants one extra arg, *

[14:13] <TimToady> right

[14:13] <jnthn> For the thingy to bless.

[14:14] <TimToady> maybe default bless doesn't take an arg, and we add a bless_this or some such

[14:14] <TimToady> and default bless can do its own create

[14:14] <TimToady> names negotiable, of course

[14:15] <jnthn> What role does bless actually fill today?

[14:15] <jnthn> Here's how it looks in Rakudo:

[14:15] <jnthn>     method bless(Mu \candidate, *@autovivs, *%attrinit) {

[14:15] <jnthn>         # If we were passed *, then need to create a candidate.

[14:15] <jnthn>         my $cand := nqp::istype(candidate, Whatever) ??

[14:15] <jnthn>             nqp::create(self) !!

[14:15] <jnthn>             candidate;

[14:15] <jnthn>         $cand.BUILDALL(@autovivs, %attrinit);

[14:15] <jnthn>     }

[14:16] <TimToady> well, we don't want people putting nqp::create into their constructors, at least

[14:16] <jnthn> Just allowing for a candidate created with a different representation to be passed in?

[14:17] <jnthn> Sure, though I guess the .CREATE macro-ish thing maps down to it.

[14:18] <jnthn> But yeah, a normal new shouldn't have to call that, I don't think.

[14:18] <TimToady> rename BUILDALL to bless, then let them call either Type.bless or Type.create.bless, and dispatch on :D ?

[14:19] <jnthn> Could work

[14:19] <TimToady> and .create by default assuming *

[14:19] <ruoso> jnthn: where can I find the docs for the mangling of the java method names? 

[14:20] <TimToady> but you could create the candidate any other way, as long as you pass a $cand.bless that bless can handle

[14:20] <jnthn> ruoso: For the method signatures? It's the same syntax JVM method descriptors use

[14:21] <ruoso> ah... cool

[14:21] <TimToady> otoh, $type.create.bless assumes you can pass the type through the candidate, which might be problematic for some kinds of candidate?

[14:22] <TimToady> thinking about why .HOW requires the object as well as the metaobject

[14:22] <jnthn> To allow prototype OO

[14:22] <TimToady> just wondering if Type.create.bless can always work

[14:24] <TimToady> can a candidate dispatch to its .bless without properly knowing its original Type, I guess I'm asking myself

[14:24] <TimToady> seems like not, but it's still too early in the morning

[14:25] <TimToady> also, it'd be nice if the BUILD plan could just inline whether to do the create or not, and maybe the create/no-create distinction more declarative

[14:25] <TimToady> s/maybe/make/

[14:26] <TimToady> well, shower &

[14:27] <TimToady> like, a CREATE phaser if you want to override the default, say, which would be known at composition time

[14:27] <TimToady> assuming most classes don't want to have it both ways

[14:27] <TimToady> afk really &

[14:28] <TimToady> .oO(afkr)

[14:28] <TimToady> afkr &

[14:28] * masak .oO( afkr really )

[14:29] <TimToady> afkrr &

[14:29] <BenGoldberg> Is this the same bug as the other one?

[14:29] <BenGoldberg> n: (gather {} but role {})[0]

[14:29] <camelia> niecza v24-88-g1f87209:  ( no output )

[14:29] <BenGoldberg> rn: (gather {} but role {})[0]

[14:29] <camelia> niecza v24-88-g1f87209:  ( no output )

[14:29] <camelia> ..rakudo 63a865: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/CORE.setting:7492␤  in method reify at src/gen/CORE.setting:6718␤  in method gimme at src/gen/CORE.setting:7138␤  in method exists at src/gen/CORE.setting:7126␤  in method at_pos at src/gen/CORE.setting:…

[14:33] *** Rotwang left
[14:35] *** colomon left
[14:35] *** bearman left
[14:36] *** domidumont left
[14:36] *** bearman joined
[14:36] *** domidumont joined
[14:38] <leont> Does rakudo do any sort of stat caching?

[14:38] <masak> Python considering strings to be sequences (and the programmer errors that causes) does not sell me on the idea of strings as sequences :)

[14:38] *** benabik left
[14:39] *** Psyche^_ joined
[14:40] <jnthn> leont: Don't believe Rakudo itself does; guess it's possible the underlying VM may...

[14:42] *** Psyche^ left
[14:43] *** SamuraiJack__ joined
[14:43] * ruoso wonders if there is a handy tool to generate the descriptor string from a java method declaration syntax...

[14:43] *** benabik joined
[14:44] *** colomon joined
[14:46] <jnthn> ruoso: Well, you can write an NQP program like this:

[14:46] <jnthn> my %h := nqp::jvmbootinterop().getInterop('java.lang.String');

[14:46] <jnthn> for %h { say($_.key); }

[14:46] <jnthn> If you just want a listing of all the things you can call on a given class

[14:48] <dalek> rakudo/scalar-from-desc: db2330c | jnthn++ | src/vm/parrot/ (2 files):

[14:48] <dalek> rakudo/scalar-from-desc: Parrot implementation of nqp::p6scalarfromdesc.

[14:48] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/db2330cfcb

[14:48] <jnthn> .tell lizmat scalar-from-desc branch is ready for triage :)

[14:48] <yoleaux> jnthn: I'll pass your message to lizmat.

[14:51] <masak> if someone++ is willing to code-review jaffa4's https://rt.perl.org/rt3/Ticket/Attachment/1245331/649971/0001-added-recognizing-labels.patch , I'm willing to apply and push it.

[14:52] <masak> jaffa4: oh, one thing: why is the "Illegal redeclaration" thing commented out?

[14:52] *** ivanoff left
[14:52] <jaffa4> the code did not compile

[14:52] <masak> heh.

[14:53] <jaffa4> need to start small

[14:53] <jaffa4> with such a complex environment

[14:53] <masak> also, what's the harm of parsing labels without panicking about them not being implemented? we just can't use them for anything yet.

[14:53] <masak> jaffa4: I generally don't like to commit commented-out code -- or, at the very least, not without a comment explaining why the code is commented out.

[14:54] <jaffa4> it panicks

[14:54] <jnthn> Indentation looks a little off too

[14:54] <jnthn> Also, there's a <.nyi(...)> or so that is a better way to die

[14:55] <masak> yes, but do we really need an error at all?

[14:55] <masak> I mean labels can be parsed, and that's it -- we implement them.

[14:55] <jnthn> masak: Well, but you can't do anything with 'em yet... :)

[14:55] <jaffa4> it iis clearer than giving back some error message

[14:56] <jaffa4> it is called stepwise development

[14:56] <masak> jnthn: I know that.

[14:56] <masak> jnthn: but you can write programs with them in that compile.

[14:56] <masak> jnthn: it'd be a kind of documentation. "we intend to 'last' to this label when it's possible"

[14:57] <tadzik> tabfail :)

[14:57] <jaffa4> what is tabfail?

[14:58] <masak> tadzik: sorry, what?

[14:58] <tadzik> or mybe not

[14:58] <tadzik> nv

[14:58] <tadzik> *nevermind

[14:58] <masak> no, don't think so.

[14:58] <jnthn> masak: OK, fine, we can just parse 'em for now then :)

[14:59] <jaffa4> I cannot make as big as steps as you jnthn

[14:59] <jnthn> jaffa4: I'm not worried about step size, just making sure the small steps are on the right path.

[15:00] <jaffa4> and is it not?

[15:00] * [Coke] wonders if jnthn++ & lizmat++'s discussion in backscroll about %*ENV will fix his issue about shell()ing out on the jvm.

[15:00] <FROGGS> jaffa4: btw, it wouldn't panic if Perl6::Actions method statement had an elsif $<statement> {  make $<statement>.ast }

[15:01] <jaffa4> ????

[15:01] <jnthn> jaffa4: Well, I prefer not to commit commented out code in general, and I agree with masak that it's best to parse them and not die...it's things like goto that should fail with "no, not yet implemented"

[15:02] <masak> jaffa4: fix this: (1) remove the commented-out code. (2) remove the panic. resubmit the patch. then I can apply.

[15:02] *** birdwindupbird left
[15:02] <jaffa4> it wont work then

[15:03] <jaffa4> I tried that

[15:03] <masak> no, not "uncomment". "remove"

[15:03] <masak> remove the lines.

[15:03] <jaffa4> if panic is removed, the code does not run properly

[15:03] <jaffa4> I tested it

[15:03] <jnthn> How did it fail?

[15:04] <jaffa4> it did not execute the statement belonging to it

[15:04] <jaffa4> there was no error

[15:04] <jaffa4> I used JVM

[15:05] <FROGGS> jaffa4: I suggested a fix

[15:06] <jaffa4> http://pastebin.com/mEcynhW5

[15:07] <jaffa4> QAst is not generated correctly

[15:10] <jaffa4> FROGGS: where exactly?  what line?

[15:10] <FROGGS> <FROGGS> jaffa4: btw, it wouldn't panic if Perl6::Actions method statement had an elsif $<statement> {  make $<statement>.ast }

[15:10] <FROGGS> ten minutes ago

[15:11] <jnthn> FROGGS: Huh, the error was in the parse code, htough?

[15:11] <dalek> rakudo/scalar-from-desc: 1b69661 | jnthn++ | src/core/Variable.pm:

[15:11] <dalek> rakudo/scalar-from-desc: Missing decont; gets is_default.t passing.

[15:11] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/1b69661962

[15:11] <jaffa4> FROGGS: which line should | modify?

[15:12] <FROGGS> jnthn: I thought it panics when he removes the .panic

[15:13] <jaffa4> no, it does not panic

[15:13] <FROGGS> jaffa4: I'd add it right before the line starting with: elsif $<statement_control>

[15:14] <FROGGS> jaffa4: because when you match another statement-rule inside statement, you have to do something with it when building the ast

[15:16] <jaffa4> you mean after <label> <statement> , there should be  {make $<statement>.ast }

[15:16] *** skids joined
[15:17] <FROGGS> jaffa4: no, the <label> ... is in Perl6::Grammar, the other part needs to go in Perl6::Actions

[15:18] <dalek> rakudo/nom: 8203477 | (Tobias Leich)++ | src/Perl6/World.nqp:

[15:18] <dalek> rakudo/nom: protect the substr (for varnames shorter than 2 chars)

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/82034779b5

[15:22] <jaffa4> FROGGS: ok  I try that

[15:24] <jaffa4> FROGGS: should it be $past := $<statement>.ast instread of  make $<statement>.ast?

[15:25] <FROGGS> jaffa4: right

[15:28] <dalek> rakudo/scalar-from-desc: 0fae92b | jnthn++ | src/ (2 files):

[15:28] <dalek> rakudo/scalar-from-desc: Clean up variable traits.

[15:28] <dalek> rakudo/scalar-from-desc: 

[15:28] <dalek> rakudo/scalar-from-desc: This avoids trying to parse type name stringification!

[15:28] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/0fae92b877

[15:29] <jnthn> .tell lizmat Think scalar-from-desc is good to merge now; will let you give it a look/spectest also

[15:29] <yoleaux> jnthn: I'll pass your message to lizmat.

[15:34] <jaffa4> ok, it compiles labels now and executes statements in the same line properly

[15:37] <FROGGS> cool

[15:42] *** thou joined
[15:45] <jaffa4> it confused me that there are actions in grammar and in actions as well

[15:47] <FROGGS> jaffa4: that is because something really has to happen when parsing code, other (most) stuff can wait until later

[15:47] <dalek> rakudo/scalar-from-desc: 2f1efb8 | jnthn++ | src/core/Array.pm:

[15:47] <dalek> rakudo/scalar-from-desc: Fix some missing type-checking in typed arrays.

[15:47] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/2f1efb81e2

[15:48] <jnthn> What happens in the grammar is not so much actions doing AST construction, but more symbol registration, etc.

[15:49] <jaffa4> in yacc ,they were called actions I think

[15:51] <masak> in Perl 6 they are called "code".

[15:52] <jaffa4> Perl6::Actions implies someone knew the same terminology

[15:52] *** ajr_ left
[15:52] *** ajr joined
[15:53] *** ajr is now known as Guest88304

[15:55] <masak> jaffa4: quite likely. yacc tends to be on the radar of language implementors.

[16:02] *** colomon left
[16:03] *** crab2313 joined
[16:15] *** Guest____ joined
[16:18] *** rindolf joined
[16:24] *** Guest____ left
[16:25] *** Guest1337 joined
[16:27] * ruoso may have a prototype for the handling of blocked threads...

[16:27] <Guest1337> Hi! Just wanted to ask what do you guys think about this http://lafo.ssw.uni-linz.ac.at/papers/2013_JVMLanguageSummit_OneVMToRuleThemAll.pdf . Is it of any relevance to the Rakudo on JVM?

[16:28] * lizmat just checked jnthn's scalar-from-desc branch and found 7 TODO's now passing!

[16:28] <yoleaux> 14:48Z <jnthn> lizmat: scalar-from-desc branch is ready for triage :)

[16:28] <yoleaux> 15:29Z <jnthn> lizmat: Think scalar-from-desc is good to merge now; will let you give it a look/spectest also

[16:28] <dalek> rakudo/scalar-from-desc: 65d5fcd | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[16:28] <dalek> rakudo/scalar-from-desc: Remove dead code

[16:28] <dalek> rakudo/scalar-from-desc: review: https://github.com/rakudo/rakudo/commit/65d5fcd1c8

[16:29] <dalek> rakudo/nom: 7f1cd51 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakOps.java:

[16:29] <dalek> rakudo/nom: Ensure gcx.Nil gets initialized.

[16:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7f1cd514ce

[16:29] <dalek> rakudo/nom: 1964396 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakudoContainerSpec.java:

[16:29] <dalek> rakudo/nom: Correct Nil handling.

[16:29] *** dalek left
[16:30] *** dalek joined
[16:30] *** ChanServ sets mode: +v dalek

[16:30] <jnthn> Guest1337: yes :)

[16:30] <jnthn> Guest1337: Well, interesting for Rakudo on whatever anyway... :)

[16:32] <lizmat> I think we just stopped dalek from seeing some pushes

[16:33] <lizmat> actually, from reporting some pushes here

[16:34] <jnthn> lizmat: It just flooded, left and rejoined :)

[16:34] <jnthn> lizmat: YOu merged the branch, I take it?

[16:34] <lizmat> ye

[16:34] <lizmat> s

[16:34] <jnthn> yay

[16:34] <jnthn> Simpler code AND more passing todos :)

[16:34] <jnthn> And should be faster to boot

[16:35] <lizmat> well, yes  :-)

[16:36] <lizmat> but I think there is something still missing:

[16:36] <lizmat> $ perl6 -e 'my %h is dynamic=a=>1; say %h<a>.VAR.dynamic'

[16:36] <lizmat> 0

[16:36] <lizmat> I would think that would need to be 1

[16:36] <jnthn> Hmm...I'd have expected it to be also.

[16:37] *** rindolf left
[16:37] <lizmat> db2330cfcb7a212d1faf94e88ea1d50dc8a0d417 doesn't say anything about dynamic

[16:37] <jnthn> > my %h is dynamic; say %h<a>.VAR.dynamic

[16:37] <jnthn> 1

[16:38] *** rindolf joined
[16:38] <lizmat> on parakudo ?

[16:38] <jnthn> yeah

[16:38] <lizmat> I think I can fix it

[16:38] <lizmat> huh?

[16:38] <jnthn> Note I didn't assign anything

[16:38] <jnthn> Yes, I know what's wrong

[16:38] <jnthn> STORE_AT_KEY is wrong

[16:38] *** mauke left
[16:39] <jnthn> Note it does the $x is copy trick, when it should be doing \x and then assigning it to a container created with the new op

[16:39] <lizmat> so replacing it by \x should do the trick?

[16:40] <lizmat> ok, will do

[16:42] <dalek> v5: 8e29495 | (Tobias Leich)++ | / (2 files):

[16:42] <dalek> v5: added curr_test and next_test

[16:42] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8e2949594d

[16:43] *** rindolf left
[16:44] *** rindolf joined
[16:48] *** crab2313 left
[16:48] *** crab2313 joined
[16:49] *** PacoAir joined
[16:50] <lizmat> jnthn: my tentative change:

[16:50] <lizmat>     method STORE_AT_KEY(\key, Mu $x) is rw {

[16:50] <lizmat>         my \v := nqp::p6scalarfromdesc($!descriptor);

[16:50] <lizmat>         nqp::findmethod(EnumMap, 'STORE_AT_KEY')(self, key, v = $x);

[16:50] <lizmat> is that sane ?

[16:51] <jnthn> lizmat: yes, though writing \x in the signature and then v = x is even cheaper

[16:51] <lizmat> ok, but then I get "Odd number of elements found where hash expected"

[16:51] <lizmat> seems the v is a hash

[16:51] <jaffa4> I made one regression test

[16:51] <lizmat> ?

[16:51] <jaffa4> one subtest of sleep falied

[16:52] <FROGGS> jaffa4: what test file?

[16:53] <jaffa4> HOw can I know that?

[16:53] <jaffa4> t\spec\S29-context\sleep.t

[16:53] <jnthn> lizmat: oh...

[16:53] <jnthn> lizmat: Yeah, OK, you probably need the $x after all then

[16:54] <lizmat> and a $v then

[16:54] <jnthn> um, you're binding so that should make no difference?

[16:54] <FROGGS> jaffa4: which test failed? https://github.com/perl6/roast/blob/master/S29-context/sleep.t

[16:54] <FROGGS> jaffa4: I dont see a connection to labels...

[16:54] <lizmat> jnthn: hmmm… true

[16:54] <jaffa4> it means the test is not stable on itself I guess

[16:55] <FROGGS> jaffa4: are you testing inside a virtual machine?

[16:55] <jaffa4> in jvm

[16:55] <FROGGS> jaffa4: no, I mean are you using virtualbox or vmware player?

[16:55] *** dmol left
[16:56] <jaffa4> no

[16:56] *** dmol1 joined
[16:57] <lizmat> jnthn: oddly enough, making it bind to $v works

[16:57] <FROGGS> jaffa4: does it fail when you re-run that single test file?

[16:57] <ruoso> hmm... i think the nqp jvm interop fails to call methods on a private class that implements a public interface

[16:57] <FROGGS> brb, dinner

[16:58] <jaffa4> FROGGS: no

[17:00] <ruoso> is there a lower-level nqp op to call a java method without trying to resolve it first?

[17:02] *** bearman left
[17:03] *** Guest1337 left
[17:03] *** fridim__ joined
[17:10] <ruoso> hmm.. I guess I would need to add a directInstanceMethodCall to BootJavaInterop

[17:17] <japhb> o/

[17:18] <japhb> Good *, everyone!

[17:18] <jnthn> o/ japhb 

[17:18] <japhb> jnthn!  How goes it?

[17:20] <lizmat> japhb: /o

[17:20] <FROGGS> jaffa4: then it is unrelated, go ahead

[17:20] <japhb> Hey lizmat!

[17:20] <jaffa4> FROGGS: I added a new path

[17:28] <jnthn> japhb: Not bad, thanks :)

[17:28] <jnthn> japhb: How's things for you?

[17:29] *** BenGoldberg left
[17:30] <japhb> So I'm considering the merits of implementing Google protocol buffers for Perl 6.  This would require easily packing and unpacking binary buffers in and out of hierarchical structures (preferably, typed objects).  Plus I'd need to be doing a lot of socket IO to actually make use of them for RPCs -- double points if I can do multiple RPCs concurrently (triple for asynchronously as well).  Is rakudo-jvm up for all that?

[17:31] <japhb> jnthn, Doing pretty good, actually.  Kids back in school, new home actually in our name, work going decently well.  Can't complain (too much).  :-)

[17:33] <jnthn> japhb: tadzik++ did, I think, get the JVM socket stuff in place. I did a big cleanup of Bufs recently also, so those now work better (on JVM too). No asynchronous socket IO just yet, but there are threads so you can do multiple things concurrently... :)

[17:35] <japhb> Oooh, I'll take it.  :-)

[17:36] *** celesta joined
[17:36] <nwc10> japhb: he's a bit to modest. There's a heck of a lot more than threads: http://jnthn.net/papers/2013-yapceu-conc.pdf

[17:36] <celesta> ahoi #perl6

[17:36] <dalek> roast: a30383c | (Elizabeth Mattijsen)++ | S (3 files):

[17:36] <dalek> roast: Unfudge/correct now passing tests

[17:36] <dalek> roast: review: https://github.com/perl6/roast/commit/a30383ce59

[17:39] <lizmat> Q: sanity check: 'my KeyBag %h" and "my %h of KeyBag" are equivalent: they indicate a hash of KeyBags, right?

[17:39] <jnthn> Should be

[17:39] <jnthn> shop &

[17:39] <japhb> nwc10: Yeah, saw that, was highly impressed -- it's why I thought the time might be right.  But IIRC the slides were unclear on the state of socket IO, and without proper Buf handing it would have been a non-starter, so ....

[17:39] <japhb> Oh, which reminds me:

[17:39] <japhb> jnthn++  # THANK YOU FOR THE EASY CONCURRENCY.

[17:49] <lizmat> jnthn++ # seconded!

[17:50] <celesta> r: my @foo = "one", "two"; say "found" if "one" ~~ @foo

[17:50] <camelia> rakudo 3e7b2a:  ( no output )

[17:50] <celesta> i hoped smart match would find "one" in the list

[17:51] <moritz> r: my @foo = "one", "two"; say "found" if "one" ~~ any(@foo)

[17:51] <camelia> rakudo 3e7b2a: OUTPUT«found␤»

[17:51] <moritz> celesta: don't hope; be explict in what you ask for.

[17:51] <celesta> alright :) thank you

[17:51] <jaffa4> otherwise, is it all?

[17:52] <celesta> moritz++

[17:52] <lizmat> r: my @foo = "one", "one"; say "all one" if "one" ~~ all(@foo)

[17:52] <camelia> rakudo 3e7b2a: OUTPUT«all one␤»

[17:52] <jaffa4> my @foo = "one"; say "found" if "one" ~~ @foo

[17:53] <jaffa4> r: my @foo = "one"; say "found" if "one" ~~ @foo

[17:53] <camelia> rakudo 3e7b2a: OUTPUT«found␤»

[17:53] <moritz> jaffa4: S03 has the smartmatch table

[17:56] *** crab2313 left
[17:58] *** rindolf left
[18:02] <donaldh> https://github.com/rakudo/rakudo/pull/193

[18:03] <dalek> rakudo/nom: 47d2d7e | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[18:03] <dalek> rakudo/nom: Make sure my %h is dynamic=a=>1; say %h<a>.VAR.dynamic works

[18:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/47d2d7eebe

[18:04] * timotimo caught up with backscroll

[18:06] *** crab2313 joined
[18:07] * moritz tests donaldh++'s pull request

[18:08] <jnthn> moritz++

[18:08] <jnthn> And donaldh++ for the pr

[18:08] <jnthn> This will make it easier for folks to get a Rakudo JVM up and running :)

[18:09] <donaldh> Hopefully it helps towards a JVM * too

[18:09] *** spider-mario left
[18:14] <timotimo> once nativecall is on jvm, it will be an amazing time for p6

[18:15] *** spider-mario joined
[18:15] *** Guest88304 left
[18:17] <timotimo> and i think cruft-free JVM interop

[18:18] <moritz> somehow I'm feeling dumb

[18:18] <moritz> $ which javac

[18:18] <moritz> /home/moritz/tmp/jdk1.7.0_25/bin/javac

[18:18] <moritz> $ /home/moritz/tmp/jdk1.7.0_25/bin/javac

[18:18] <moritz> bash: /home/moritz/tmp/jdk1.7.0_25/bin/javac: No such file or directory

[18:19] <dalek> roast: 29ae9f5 | (Elizabeth Mattijsen)++ | S02-types/keybag.t:

[18:19] <dalek> roast: Fudge questionable KeyBag tests for now

[18:19] <dalek> roast: review: https://github.com/perl6/roast/commit/29ae9f5458

[18:19] <moritz> and 'ls' says it exists

[18:19] <lizmat> moritz: permissions ?

[18:20] <lizmat> moritz: symlinks ?

[18:20] <timotimo> could be a broken link

[18:20] <geekosaur> use ldd on it? sometimes that actually means the executable "interpreter" is missing (meaning, it's for the wrong linux version)

[18:21] <moritz> ordinary files, permissions look OK

[18:21] <moritz> $ ldd /home/moritz/tmp/jdk1.7.0_25/bin/javac not a dynamic executable

[18:21] <geekosaur> hm

[18:21] <dalek> rakudo/nom: 9ecd996 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[18:21] <dalek> rakudo/nom: Allow .VAR.dynamic introspection on Hash / Array

[18:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ecd99654e

[18:22] <geekosaur> what does `file` say about it?

[18:22] <moritz> /home/moritz/tmp/jdk1.7.0_25/bin/javac: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped

[18:22] <geekosaur> which contradicts ldd, which makes me think again it's a missing ELF interpreter

[18:23] <timotimo> 32 vs 64 bit?

[18:24] <moritz> it's a 64 bit system

[18:25] <moritz> ... and the oracle website said "Linux x64"

[18:25] <moritz> unless I managed to click the wrong link

[18:27] <timotimo> well it doesvsay 32

[18:32] <moritz> ok, seems that was the real problem

[18:32] <masak> r: say "bash: $*PROGRAM_NAME: No such file or directory" # the first thing I thought when backlogging over moritz' troubles

[18:32] <camelia> rakudo 47d2d7: OUTPUT«bash: /tmp/V9zzcSaRoB: No such file or directory␤»

[18:32] <moritz> thanks everybody for the help

[18:34] <timotimo> scalar-from-desc is not really ready to be merged?

[18:34] <lizmat> r: my $h is default(42)= Hash[Int].new; say $h<a>.VAR.default  # would expect 42

[18:34] <camelia> rakudo 47d2d7: OUTPUT«(Any)␤»

[18:34] <jnthn> lizmat: That's never gonna work

[18:34] <jnthn> lizmat: You've confusing the levels

[18:34] <jnthn> *you're

[18:35] <jnthn> Here, $h is a scalar that defaults to 42, which just had a hash assigned into it

[18:35] <jnthn> r: my $h is default(42)= Hash[Int].new; $h = Nil; say $h;

[18:35] <camelia> rakudo 47d2d7: OUTPUT«42␤»

[18:35] <masak> japhb: I'm interested in hacking protocol buffers too. if you get started at it, I might help.

[18:36] *** crab2313 left
[18:36] <lizmat> jnthn++ for the sanity check

[18:36] *** crab2313 joined
[18:37] *** ssutch joined
[18:37] <masak> celesta: "one" ~~ @foo works fine in Perl 5 -- but only because Perl 5 stole Perl 6's semantic before it settled into its current, nicer form.

[18:38] <celesta> masak: thank you

[18:38] <masak> semantics*

[18:39] <masak> celesta: the rule-of-thumb is this: infix:<~~> asks the right-hand side what type it is and how it looks inside, and that governs how the match is done.

[18:39] <masak> r: say <foo bar baz> ~~ { foo => 1, bar => 2, baz => "mwhaha" }

[18:39] <camelia> rakudo 47d2d7: OUTPUT«True␤»

[18:40] <masak> r: (1, 2, 3) ~~ <1 2 3>

[18:40] <camelia> rakudo 47d2d7:  ( no output )

[18:40] <masak> r: say (1, 2, 3) ~~ <1 2 3>

[18:40] <camelia> rakudo 47d2d7: OUTPUT«False␤»

[18:40] <masak> r: say <1 2 3> ~~ (1, 2, 3)

[18:40] <camelia> rakudo 47d2d7: OUTPUT«False␤»

[18:40] <masak> hrm :)

[18:40] <japhb> masak, Oooh, very good.  Right now I'm trying to get a good rakudo-jvm build on this low-RAM machine, so I can actually get started.  :-)

[18:40] <masak> r: say [1, 2, 3] ~~ [1, 2, 3]

[18:40] <camelia> rakudo 47d2d7: OUTPUT«True␤»

[18:40] <masak> r: say [1, 2, 3] ~~ [1, *, 3]

[18:40] <camelia> rakudo 47d2d7: OUTPUT«True␤»

[18:41] <masak> r: say [1, 2, 3] ~~ [1, *]

[18:41] <camelia> rakudo 47d2d7: OUTPUT«True␤»

[18:41] <masak> r: say [1, 2, 3] ~~ [*]

[18:41] <camelia> rakudo 47d2d7: OUTPUT«False␤»

[18:41] <celesta> masak: thanks for explaining

[18:41] <lue> r: say [1, 2, 3] ~~ [**]

[18:41] <camelia> rakudo 47d2d7: OUTPUT«False␤»

[18:44] <dalek> rakudo/nom: 3d59402 | (Donald Hunter)++ | / (3 files):

[18:44] <dalek> rakudo/nom: Resurrected --gen-nqp for JVM.

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3d594027fe

[18:44] <dalek> rakudo/nom: 9d38802 | (Donald Hunter)++ | ConfigureJVM.pl:

[18:44] <dalek> rakudo/nom: Always realpath-ify

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d38802711

[18:44] <dalek> rakudo/nom: 66a73a9 | (Donald Hunter)++ | ConfigureJVM.pl:

[18:44] <dalek> rakudo/nom: Check for mandatory options

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/66a73a9a93

[18:45] <timotimo> yays :)

[18:45] <moritz> donaldh++ # that was your pull request, though rebased over lizmat++'s latest commits

[18:45] <masak> rebase++

[18:45] <masak> moritz++ # rebase

[18:46] <timotimo> masak++ # moritz # rebase

[18:46] <donaldh> moritz++

[18:47] <FROGGS> free hugs \o/

[18:47] <japhb> After that I see a few major things to do next:  * Parse the protocol buffer definitions.  * Create a PB parser from the parsed definition.  * Implement pack/unpack from binary buffers into a hierarchy of message nodes.  * Implement a network client working against existing PB RPC servers.  * Implement a PB RPC server.  * Do it all with concurrency.  * Do it all with asynchrony too.

[18:47] *** domidumont left
[18:47] <donaldh> r: for <masak moritz rebase> -> $x { say "${x}++" }

[18:47] <camelia> rakudo 47d2d7: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/ZXvkiYCLjk␤Unsupported use of ${x}; in Perl 6 please use {$x}␤at /tmp/ZXvkiYCLjk:1␤------> [32m <masak moritz rebase> -> $x { say "${x}[33m⏏[31m++" }[0m␤»

[18:47] <masak> japhb: cool.

[18:48] <masak> japhb: github early, github often. I'll try to keep up, and help when I have the tuits.

[18:48] <donaldh> r: for <masak moritz rebase> -> $x { say "{$x}++" }

[18:48] <camelia> rakudo 47d2d7: OUTPUT«masak++␤moritz++␤rebase++␤»

[18:48] <masak> donaldh: was '${x}' p5 damage? :)

[18:49] <masak> TimToady: maybe there should be a STD warning for that one? :)

[18:49] <donaldh> yes, if you mean Did I have that expectation from p5 ?

[18:49] <japhb> masak, You probably won't have too hard a time keeping up.  My time is freeing up slowly, but it's still relatively limited right now.

[18:49] <donaldh> Also from other scripting langs

[18:50] <celesta> about grammars, is it ever necessary to create action methods for proto rules?

[18:50] <donaldh> masak: the message was pretty helpful. Maybe already covered.

[18:51] <masak> donaldh: oh! yes.

[18:51] <timotimo> hm, somebody already built a protocol buffers grammar a month or so ago

[18:51] <masak> "read the error message. read the error message." # I should do this :/

[18:51] <masak> japhb: likewise.

[18:52] <masak> celesta: it's never necessary to create action methods. if you create them, they get called, even for proto rules.

[18:52] <celesta> masak++: thank you

[18:53] <japhb> timotimo, ah, where is that?  I was away during that time frame.

[18:53] <lizmat> is .VAR already working on jakudo ?

[18:53] <timotimo> it was ssutch 

[18:54] <timotimo> https://github.com/samuraisam/p6-pb

[18:54] <timotimo> ssutch++

[18:54] <ssutch> wat?

[18:54] <masak> ssutch++ :)

[18:54] <ssutch> ah, it's not finished sadly

[18:54] <ssutch> too much work-work

[18:54] <ssutch> the grammar and some actions work

[18:55] <masak> do unit tests cover what works so far?

[18:55] <ssutch> and the grammer can handle all official spec files

[18:55] <timotimo> good enough to me :]

[18:55] <japhb> ssutch, where is it?  I don't see a repo for it in your github account ...

[18:55] <timotimo> i linked to it above ^

[18:55] <ssutch> japhb: https://github.com/samuraisam/p6-pb

[18:55] <japhb> DOH

[18:55] <japhb> Sigh

[18:55] <timotimo> :)

[18:55] <japhb> ETOOMANYWINDOWS

[18:56] <timotimo> japhb: you were going to try to integrate my changes into perl6-bench; what stopped you? not enough time or did i screw something up? :)

[18:57] <japhb> timotimo, Oh, just ran out of time last weekend trying to build rakudo-jvm so I could actually be sure my merges *worked*.  Trying again this weekend.

[18:57] <timotimo> jvm::runtime.jars value not available from nqp/install/nqp --show-config. - what might i have done wrong?

[18:57] <timotimo> just ping me if you have any questions, i can't tell if i'll be available, though

[18:58] <japhb> (Builds like a charm at $work when I fix the configure tests ... hmmm, need to send that patch ... but that's a much bigger machine than I have at home.)

[18:58] <japhb> timotimo, roger that.

[18:58] <japhb> ssutch, thank you, I'll be reading that with great interest.  :-)

[18:58] <dalek> rakudo/nom: e35e1fd | (Marton Papp)++ | src/Perl6/ (2 files):

[18:58] <dalek> rakudo/nom: added labels

[18:58] <dalek> rakudo/nom: 

[18:58] <dalek> rakudo/nom: removed comments and panic

[18:58] <dalek> rakudo/nom: 

[18:58] <dalek> rakudo/nom: added recognizing labels

[18:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e35e1fd201

[18:59] <ssutch> cool

[18:59] <masak> jaffa4++

[18:59] *** SamuraiJack__ left
[18:59] <FROGGS> we just need to make them work now :o)

[18:59] <ssutch> ignore PB::Model::Generator… i was in the process of trying to gen packages at runtime

[18:59] *** colomon joined
[18:59] <FROGGS> and I#d like to be the first one who makes use of it

[18:59] <FROGGS> jaffa4++

[19:00] <japhb> ssutch, ah, gotcha

[19:00] <lizmat> could we first try to handle all cases where the goto/next/last can be resolved at compile time ?

[19:00] <timotimo> gaaah. install/nqp doesn't support --show-config and ./nqp can't be run from outside the installation path

[19:01] <timotimo> what could i have done wrong?

[19:01] <FROGGS> timotimo: maybe install/bin/nqp ?

[19:01] <moritz> timotimo: mixing up install-jvm/bin/nqp vs install-jvm/nqp vs install/bin/nqp

[19:02] <moritz> ?

[19:02] <timotimo> ah indeed

[19:02] <timotimo> install/bin/nqp must be new?

[19:02] <dalek> roast: b337aa4 | (Elizabeth Mattijsen)++ | S02-names/is_dynamic.t:

[19:02] <dalek> roast: Add tests for .VAR.dynamic introspection

[19:02] <dalek> roast: review: https://github.com/perl6/roast/commit/b337aa497f

[19:03] *** berekuk joined
[19:03] <FROGGS> timotimo: yeah, recognized it an hour ago

[19:03] <arnsholt> Heh, perl6-language gets some seriously weird email

[19:04] <timotimo> you mean "reorganized"?

[19:04] <dalek> rakudo/nom: ce2453d | (Elizabeth Mattijsen)++ | t/spectest.data:

[19:04] <dalek> rakudo/nom: Make sure the spectest runs the .VAR.dynamic introspection tests

[19:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce2453d935

[19:05] <FROGGS> timotimo: no

[19:05] <FROGGS> :o)

[19:05] <masak> arnsholt: jnthn and I went to DDDx this year. there was a guy there who had a few war stories from the oil drilling industry.

[19:06] <masak> arnsholt: one thing he said was that they had tried units analysis as part of their software, but the users revolted against that.

[19:06] <arnsholt> What's DDDx?

[19:06] <masak> arnsholt: turns out users have excellent reasons for wanting to compare values that "don't typecheck" from a units perspective.

[19:07] <masak> arnsholt: a yearly meeting for people doing DDD -- Domain-Driven Design.

[19:07] <arnsholt> Ah, cool

[19:07] <masak> arnsholt: DDD focuses on putting domain thinking directly into the software.

[19:07] <masak> and into the vocab being used to develop and talk about the software.

[19:10] <timotimo> yeah, sometimes you have a relation that doesn't make much sense, but you could always make up a crazy type

[19:10] <timotimo> like the "rule of thumb" for drivers that determines how far you travel before you come to a halt is based on dividing the speed on your speedometer by a fixed number and reinterpreting it as meters

[19:10] <masak> conceptually it feels a bit like C's "pointer to void" freedom. sometimes that's needed.

[19:10] <timotimo> reinterpret_cast :)

[19:12] <masak> I think units should definitely be explored in Perl 6.

[19:12] *** crab2313 left
[19:12] <masak> (but I think it should be explored as a module)

[19:12] <timotimo> yes.

[19:12] <timotimo> perl6 is sufficiently flexible that that doesn't need to go into the core

[19:13] <timotimo> if you have it in a module, you'll even get "gradual uniting"

[19:15] <lizmat> .oO(funny how the PLATO system always comes back to haunt you :-)

[19:16] <timotimo> is that a pun or are did you have some experience with PLATO in the past?

[19:16] *** donaldh left
[19:17] *** cognominal left
[19:21] <masak> timotimo: the latter.

[19:21] <lizmat> timotimo: it was the system on which I really did my first software development

[19:21] <lizmat> from late 1977 to 1983ish

[19:21] <timotimo> was it terrible?

[19:22] <timotimo> well, it seems like you stuck to software development

[19:22] <timotimo> so it must have been survivable

[19:22] <lizmat> yes, I did

[19:22] <lizmat> it was great compared to the FORTRAN I did on punched cards before that

[19:22] <lizmat> on PLATO I could type in my program on a termain, press SHIFT-STOP and it ran

[19:23] <lizmat> *terminal

[19:23] <FROGGS> shift-stop to run it?

[19:23] <timotimo> that's a step forward i agree

[19:23] <lizmat> SHIFT-STOP, yes

[19:23] <timotimo> yeah, shift shifts it from stop to go :)

[19:23] <FROGGS> that is like pressing the start button to shut down a windows pc -.-

[19:23] <lizmat> it was the untrappeble exception for non-system developers

[19:24] <lizmat> you also had to press SHIFT-STOP to login

[19:24] <timotimo> FROGGS: except having to right-click it to stop it d)

[19:24] <timotimo> :)

[19:24] <lizmat> the reason was that some jokers had created fake login screens to capture login/password combinations

[19:25] <timotimo> wow, phishers go way back

[19:25] <lizmat> by using SHIFT-STOP to login, you were sure you weren't in a fake login screen

[19:25] <FROGGS> wow, indeed

[19:25] <timotimo> that's the same reason windows pcs sometimes require you to hit ctrl-alt-del to login

[19:25] <lizmat> of course, this all became moot when you could intercept keys in the smart terminals using 8080 assembly code

[19:25] <timotimo> yowch :)

[19:26] <lizmat> so 8080 assembly code was outlawed for non-system developers as well  :-(

[19:26] <lizmat> which killed my slot machine  :-(

[19:26] <timotimo> oh ... oh no ...

[19:26] <lizmat> as that was using 8080 assembly to rotate the wheels

[19:27] <timotimo> i think i turned on my computer but it got a different ip or something

[19:27] <timotimo> can't seem to reach it :o

[19:28] <timotimo> how am i supposed to benchmark stuff? my laptop would immediately go up to 90 degrees and clock down >_>

[19:28] <lizmat> I think ribasushi had some ideas about that at the YAPC::EU

[19:29] <lizmat> if I remember correctly: make sure the CPU is locked in the lowest performance mode

[19:29] <timotimo> is 2a02:8071:2909:7b00:5604:a6ff:fe93:d1a6 unreachable for you, too?

[19:30] <lizmat> so that it doesn't have to start cooling / clocking down

[19:31] <lizmat> wrt to clocking down, after starting my 3rd box of tissues since I got back from Kiev, I think I'll clock down a bit myself&

[19:32] <FROGGS> lizmat: get well soon

[19:34] <timotimo> well, in this case i'll just implement the optimisation first, then see later in what cases it's not optimal to do the transformation

[19:36] <timotimo> hm. do it in nqp first or in rakudo? that's the question

[19:37] <timotimo> rakudo it is.

[19:37] <moritz> timotimo: I can't ping6 that address either

[19:37] <timotimo> annoying :(

[19:46] *** araujo left
[19:47] *** araujo joined
[19:52] * timotimo turns rows of &infix:<~> into join('', ...)

[19:55] <jnthn> wait isn't infix:<~> meant to be list infix?

[19:55] <timotimo> yes, at one point

[19:55] <timotimo> last time i tried it seemed like LoL slurpies were blocking us or something

[19:55] <timotimo> in any case, i wasn't able to tame the prototypes for any other case

[19:59] <timotimo> oh that's the one with the cool shoe shine?

[20:00] <timotimo> that's an amusing mischan right there

[20:00] *** jeffreykegler joined
[20:00] *** jeffreykegler left
[20:01] *** jeffreykegler joined
[20:01] <timotimo> yay, null pointer exception when dumping a qast node \o/

[20:01] *** colomon left
[20:01] <celesta> perl is so much fun :)

[20:02] <timotimo> i put the value directly into the SVal node, which is of course wrong, because it belongs into the :value slot

[20:03] <masak> celesta: it has been theorized that the purpose of the entire universe is fun. :)

[20:05] *** TimK1 joined
[20:10] * ruoso really lost trying to understand why an object returned from a native jvm call is not able to call other methods

[20:10] <timotimo> japhb: i don't know if you noticed, but we were able to trace the crash when using the shell command inside a loop

[20:10] <timotimo> it's caused if you use anything with "but" inside a loop

[20:10] <diakopter> ruoso: have to cast it to something?

[20:11] <ruoso> the specific case here is of $reentrantLock.newCondition()

[20:12] <ruoso> which returns a $condition object, but I cannot call the actual method in it

[20:12] <diakopter> did you try casting the returned object to the condition class?

[20:12] <ruoso> Well, Condition is an interface

[20:13] <diakopter> *interface

[20:13] <ruoso> and the specific class is private

[20:13] <ruoso> and I am on perl-land... not Java

[20:13] <diakopter> ohhh

[20:13] <diakopter> *that* kind of native method

[20:13] *** kaare_ left
[20:14] *** Rotwang joined
[20:14] <diakopter> dunno. put it in a Condition scalar?

[20:15] <ruoso> I can't, because Condition is not defined at compile time

[20:15] <diakopter> eww

[20:16] <jnthn> Don't think that'd help anyway

[20:16] <jnthn> I wonder if it just doesn't somehow quite handle an interface return type...

[20:19] <ruoso> that's my guess...

[20:19] <timotimo> jnthn: are you going to go ahead with the bless simplification?

[20:20] <ruoso> but I am failing to understand where in the code it chooses how to represent the return type

[20:20] <jnthn> timotimo: hehe. The interop code took me a little figuring and I think I forgot it again... :)

[20:20] <jnthn> uh, ruoso ^^^

[20:20] <jnthn> timotimo: Will let TimToady++ ponder it some more first. :)

[20:21] <timotimo> if it gets object creation faster on all backends, i'd be for it ;)

[20:26] *** raiph joined
[20:27] <raiph> http://queue.acm.org/detail.cfm?id=2513575 # ACM article: "The Balancing Act of Choosing Nonblocking Features"

[20:33] *** dalek left
[20:34] *** donaldh joined
[20:34] *** dalek joined
[20:34] *** ChanServ sets mode: +v dalek

[20:37] <raiph> "Prior to Java 5 (2004) and C11/C++11, these languages could not be reliably used ... to fully express the required memory ordering" of a CAS

[20:37] *** jeffreykegler left
[20:39] <timotimo> https://github.com/timo/rakudo/tree/tilde_to_strjoin i'd be glad if somebody could time some string interpolations with this version vs current nom, but i'll probably go to bed soon, so it can wait until tomorrow

[20:40] <timotimo> i just don't have reliable hardware to run it on

[20:44] <japhb> timotimo, Oooh, interesting about the "but" inside a loop.

[20:44] <japhb> Is it now solved?  Or just identified?

[20:44] * leont managed to make his first perl6 module pass all of its tests :-)

[20:44] <masak> \o/

[20:45] <masak> leont: does it have a positive number of tests? :P

[20:45] <timotimo> just identified

[20:45] <timotimo> we don't know yet why it happens

[20:45] <donaldh> Are modifications to %*ENV normally visible to shell "…" processes?

[20:46] <japhb> If I'm getting a no such file or directory on 'install-jvm/bin/nqp' while building rakudo-jvm, what do I need to do to my tree to correct it?  Do I need to nuke rakudo/nqp/ and let it pull again?

[20:46] <donaldh> I'm guessing this doesn't happen on JVM because the JVM says the environment is immutable.

[20:47] <donaldh> japhb: are you trying latest ?

[20:47] <japhb> donaldh, the environment of the current process, or the environment handed to children?  I would think the latter would be a non-starter.

[20:47] <donaldh> try using --gen-nqp 

[20:47] <japhb> I just did a pull of nom, and then started using the usual build process.

[20:47] <japhb> Ah, OK, will try that.

[20:48] <leont> masak: Yes, though I still have to port the documentation from pod5 to pod6

[20:48] <donaldh> It will reuse the nqp checkout but the install layout has changed, so I guess it will clean and rebuild nqp

[20:50] <donaldh> japhb: I can arrange to use the contents of $*ENV on JVM but it won't happen automatically, which I guess does happen on parrot.

[20:50] <japhb> donaldh, OK, so instead of '( cd nqp && perl ConfigureJVM.pl --prefix=../install-jvm && make install ) || exit; perl ConfigureJVM.pl && make || exit' I should instead do 'perl ConfigureJVM.pl --gen-nqp && make' ?  Do I need to move the --prefix line on to the top level Configure as well?

[20:51] <ruoso> ah... wait... I think I stumbled upon something interesting.. when using the trick jnthn showed me to describe all methods of a class, I realized that for that class the method I was calling was not listed as a short version, but only in the mangled version

[20:51] <donaldh> japhb: yes we committed --gen-nqp support to rakudo today. the default prefix is rakudo/install-jvm

[20:51] <ruoso> is the name "await" special in some way?

[20:51] <japhb> Woot!

[20:51] <donaldh> japhb: --gen-nqp does the right thing

[20:51] <japhb> Thanks, donaldh 

[20:51] <donaldh> so perl ConfigureJVM.pl --gen-nqp is all you need.

[20:53] <jnthn> ruoso: It's just a sub

[20:54] <ruoso> for some reason .getInterop is not listing the "await" method on the condition interface

[20:55] <donaldh> jnthn: How do I look up %*ENV from Ops.java

[20:56] <timotimo> r: my @v; @v[10] := Nil; say @v;

[20:56] <ruoso> now I am getting a more reasonable error: Unhandled exception: java.lang.IncompatibleClassChangeError: Found interface java.util.concurrent.locks.Condition, but class was expected

[20:56] <camelia> rakudo ce2453: OUTPUT«(Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any)␤»

[20:56] <timotimo> r: my @v; @v[10] := Nil; say @v; say +@v;

[20:56] <camelia> rakudo ce2453: OUTPUT«(Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any)␤11␤»

[20:56] *** raiph left
[20:57] <jnthn> ruoso: oh...different await... :)

[20:58] <jnthn> donaldh: There's an nqp::getenvhash op; think we miss something to update it though...

[20:58] <donaldh> jnthn: JVM env is immutable afaik

[20:59] <ruoso> now the problem is that it is taking the type it received instead of the actual type of the object

[20:59] <ruoso> so it is trying to invoke a method in an interface

[21:07] <donaldh> jnthn: I see, changes to %*ENV modify the underlying hash returned by Ops.getenvhash

[21:08] *** BenGoldberg joined
[21:08] <donaldh> jnthn: Is it okay to keep a reference to that hash in Ops.java

[21:08] <timotimo> r: 1 cmp 1

[21:08] <camelia> rakudo ce2453:  ( no output )

[21:08] <timotimo> r: say 1 cmp 1

[21:08] <camelia> rakudo ce2453: OUTPUT«Same␤»

[21:08] <jnthn> donaldh: Well, hang it off GlobalContext rather than putting it in a static

[21:09] *** cooper joined
[21:13] <masak> "I'll just make a small change that I *know will work* without running the tests." # <-- this never works

[21:13] <jnthn> What have you broke now? :P

[21:14] *** panchiniak_ joined
[21:16] *** panchiniak_ left
[21:19] <masak> exercise instructions.

[21:20] <masak> (for $dayjob)

[21:20] <timotimo> that's why you have some file watcher do it in the background :)

[21:20] <timotimo> so the effort to not test is bigger than the effort to test

[21:22] <BenGoldberg> How much time passes between rakudo being updated, and camelia the irc bot getting the new version of rakudo?

[21:23] <FROGGS> BenGoldberg: I think camelia rebuilds every hour, starting 10 past

[21:24] <timotimo> hm, i thought it was twice per hour

[21:25] <BenGoldberg> rn: (gather {take 2} but role {})[0].print

[21:25] <camelia> niecza v24-88-g1f87209: OUTPUT«2»

[21:25] <camelia> ..rakudo ce2453: OUTPUT«This type does not support elems␤  in method REIFY at src/gen/CORE.setting:7494␤  in method reify at src/gen/CORE.setting:6720␤  in method gimme at src/gen/CORE.setting:7140␤  in method exists at src/gen/CORE.setting:7128␤  in method at_pos at src/gen/CORE.setting:…

[21:25] <masak> timotimo: troo. file watchers are awesome.

[21:25] <donaldh> jnthn: Can the env SixModelObject get added to an existing GlobalContext hash or does it need to be a new member?

[21:25] <masak> timotimo: http://strangelyconsistent.org/blog/helpfully-addictive-tdd-on-crack

[21:25] <timotimo> masak: and it's so easy to do with the inotify console tools

[21:26] <masak> funnily enough, the py2-py3 compatibility layer is called "six": http://pythonhosted.org/six/

[21:26] <timotimo> yeah, because 2 * 3 = 6 :)

[21:28] <pmurias> masak: tote is only a description not actuall code?

[21:28] <jnthn> donaldh: I'd just add another field to GlobalContext for it.

[21:28] <ruoso> I am starting to think that this problem is harder than it might look. I think the interop is trying to pre-evaluate the st for the return type of a method beforehand, which breaks down when the return type is an interface

[21:29] <ruoso> it was supposed to use the concrete type of the object to dispatch the method

[21:29] <ruoso> but the st is pre-cached with the inteface type

[21:29] <ruoso> which is not legal to perform the actual invocation

[21:29] <donaldh> jnthn: okay. do we care about initialisation races? i.e. this will not be set until Ops.getenvhash gets called.

[21:29] <jnthn> ruoso: Maybe worth leaving a message for sorear++ to see if he has some thoughts, since he did most of the interop stuff so far.

[21:30] <masak> pmurias: no, it's actual code.

[21:30] <jnthn> donaldh: It seems rather unlikely to happen

[21:30] <masak> pmurias: but it never was more than a script -- I never fleshed it out into a program.

[21:30] * donaldh notes it down as the next most likely thing to happen now.

[21:30] <pmurias> masak: it's hasn't been released?

[21:30] <jnthn> :P

[21:31] <ruoso> tell sorear please see http://irclog.perlgeek.de/perl6/2013-08-18#i_7467343

[21:31] * ruoso bot command fail

[21:31] <jnthn> .tell, I think

[21:31] <ruoso> .tell sorear please see http://irclog.perlgeek.de/perl6/2013-08-18#i_7467343

[21:31] <yoleaux> ruoso: I'll pass your message to sorear.

[21:32] <masak> pmurias: only as a gist somewhere.

[21:32] <masak> pmurias: and the gist was called "some kind of mini-tote" or something.

[21:33] <sorear> hi

[21:33] <yoleaux> 21:31Z <ruoso> sorear: please see http://irclog.perlgeek.de/perl6/2013-08-18#i_7467343

[21:33] <pmurias> sorear: hi

[21:33] <sorear> ruoso! long time no see!

[21:33] <pmurias> masak: the big problem with something like tote for nqp-js is that running all the tests takes a long while

[21:34] <pmurias> masak: and compiling isn't exactly instant also

[21:34] <masak> pmurias: "running all the tests takes a long time" was my problem too.

[21:34] <masak> pmurias: I ended up manually narrowing down the test suite to what I was working at.

[21:34] <ruoso> sorear: indeed... i have been too deep into $dayjob... trying to get back to activity...

[21:34] <masak> this was back in 2009 when Rakudo was even slower.

[21:35] <sorear> ruoso: how does it break down?

[21:35] <timotimo> now we can start running tests in parallel ;))

[21:35] <sorear> you should be able to use interface-shaped wrappers just like class-shaped ones

[21:35] <ruoso> sorear: since the method has an interface as return type, it assumes that the concrete type of the returned object is the interface...

[21:35] <ruoso> which is not legal for actual method calling

[21:36] <sorear> oh, I know what might be the problem... I think the wrapper generation is using invokevirtual when it should be using invokeinterface for interface wrappers

[21:36] <sorear> ruoso: it's deliberate that we don't ask the returned object what its concrete type is

[21:37] <ruoso> oh, I wasn't aware that there was a specific API for call as the interface

[21:38] <pmurias> masak: so what are you using now instead of tote?

[21:38] <ruoso> sorear: so it should be just a matter of changing createAdaptorMethod to use one or the other

[21:38] <sorear> ruoso: i think so, yeah

[21:39] <ruoso> ok... now I just need to find out a way to distinguish a class from an interface

[21:40] <masak> pmurias: nothing, right now. :/

[21:40] <masak> pmurias: I just run my tests manually.

[21:40] <masak> would like to get back to something tote-like, though.

[21:40] <masak> thing is, I haven't had a big tested project for a while.

[21:42] *** TimK1 left
[21:42] * timotimo now has "inotifywait"

[21:43] <timotimo> but it takes 5 seconds to tell me if it's wrong or right ... with just one single test case

[21:44] <sorear> ruoso: I think there's an isInterface method on j.l.Class or so

[21:45] <timotimo> r: given Same { when Decreasing { say "ah" }; when Same { say "oh" }; when Increasing { say "wow!" } }

[21:45] <camelia> rakudo ce2453: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/yrwP4aEnBP␤Missing block␤at /tmp/yrwP4aEnBP:1␤------> [32miven Same { when Decreasing { say "ah" }[33m⏏[31m; when Same { say "oh" }; when Increasin[0m␤    expecting any of:␤        postfix␤        statem…

[21:45] <timotimo> why is that a missing block?

[21:45] <timotimo> regression?

[21:46] <jnthn> I think you meant Decrease and Increase

[21:46] <timotimo> oh?

[21:46] <FROGGS> yeah

[21:47] <timotimo> seems so

[21:47] <timotimo> LTA error, imo

[21:47] <sorear> std: given Same { when Decreasing { say "ah" }; when Same { say "oh" }; when Increasing { say "wow!" } }

[21:47] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'Decreasing' needs parens to avoid gobbling block at /tmp/Kar1FMmtTV line 1:␤------> [32mgiven Same { when Decreasing[33m⏏[31m { say "ah" }; when Same { say "oh" }; w[0m␤Missing block (apparently gobbled by 'Decreasing') at…

[21:48] <jnthn> Guess we didn't nab that from STD yet :)

[21:49] <sorear> ruoso: (dayjob stuff) same here pretty much for the last couple weeks

[21:49] <timotimo> i think a unix command for "run for 10 seconds at most, kill if necessary"

[21:51] <timotimo> because ^c now kills my inotifywait, too :(

[22:00] <sorear> help ulimit

[22:01] <timotimo> oooh!

[22:01] <timotimo> of course.

[22:02] *** spider-mario left
[22:03] <geekosaur> mm, that's cpu time, not wall clock time

[22:03] <timotimo> well, rakudo's all cpu time ...

[22:04] *** aindilis` left
[22:05] <timotimo> i shall go to bed now and feast on some dreams

[22:05] <timotimo> good night!

[22:07] *** donaldh left
[22:09] *** jaffa4 left
[22:10] *** leont left
[22:11] *** donaldh joined
[22:12] <celesta> good night #perl6

[22:12] *** celesta left
[22:17] <masak> 'night, celesta

[22:17] <masak> ...and timo

[22:19] <japhb> Can someone with a 64-bit JVM please try to do a rakudo-jvm build with the following patch?  https://gist.github.com/japhb/a23966e0921558396ba6

[22:20] *** PacoAir left
[22:20] *** Rotwang left
[22:21] <japhb> That diff made the build work for me on a 32-bit, 2 GB RAM linux laptop (which means it was competing for RAM with desktop, xchat, etc.)

[22:23] <sorear> japhb: ooc, how long did it take?

[22:23] <japhb> I want to know if it will work exactly as is on 64-bit JVMs, or if the numbers have to be increased to account for larger pointers -- and if so, whether the increase can be small enough that the 64-bit values can be used as-is for 32-bit.

[22:23] <sorear> pointers aren't larger on small 64-bit 

[22:24] <sorear> JVMs, I beleeeive -X:+UseCompressedOops is enabled by default

[22:24] <donaldh> japhb: I can't look today but could tomorrow

[22:24] <masak> 'night, #perl6

[22:24] <japhb> sorear, I didn't time it end-to-end; building the setting took a bit under 6.5 minutes

[22:25] <donaldh> japhb: my guess is that as the setting grows, that number will grow too.

[22:25] <japhb> sorear, "small 64-bit"?  You mean, the 64-bit JVM will act like it has a 32-bit memory space if possible?  Wild.

[22:26] <sorear> oh, apparently not

[22:26] <japhb> donaldh, sure, but at least there will be an explicit number that we can point people to, and know it will work for 2 GB RAM setups out of the box.

[22:27] *** Mouq joined
[22:27] <japhb> And as we optimize rakudo and NQP, it may end up needing *less* space.

[22:28] <sorear> japhb: with -XX:+UseCompressedOops enabled, the VM allocates the heap as a contiguous span of up to 32 Gb and then represents pointers as indexes into the heap, multiplying by 8

[22:28] <sorear> apparently this is not the default, so ignore me

[22:28] <sorear> I thought it was

[22:28] <japhb> Interesting idea though.

[22:29] <[Coke]> donaldh: known issue on rakudo-jvm that shell doesn't propagate env changes (failing spec test for it)

[22:30] <donaldh> [Coke]: thx. currently fixing that, hopefully.

[22:30] * [Coke] thinks the nqp opcode mentioned will help, though.

[22:30] <[Coke]> donaldh: ah, excellent.

[22:31] <[Coke]> last time I tried, the ENV I was iterating over was the original one, not the changed one.

[22:31] <[Coke]> donaldh++ if you can get that working.

[22:31] <donaldh> [Coke]: it's needed for panda, so I thought I'd tackle it.

[22:32] *** pmurias left
[22:37] <jnthn> Need sleep; 'night 

[22:44] <sorear> gn jnthn 

[22:46] *** donaldh left
[22:47] *** FROGGS left
[22:47] *** dmol1 left
[22:51] *** donaldh joined
[22:53] *** xinming left
[22:55] *** donaldh left
[22:55] *** xinming joined
[23:08] *** pdurbin joined
[23:13] *** benabik left
[23:14] *** benabik joined
[23:15] *** slavik left
[23:26] *** colomon joined
[23:30] *** berekuk left
[23:32] *** berekuk joined
[23:47] *** berekuk left
[23:52] *** colomon left
[23:55] *** alexghacker joined
