[00:03] <masak> 'night, #perl6

[00:03] <rjbs> Ummm.  I ran "perl Configure.pl --gen-parrot

[00:03] <rjbs> and after doing some "make stuff" I eventually end up in less, showing the document "src/packfile.c - Parrot PackFile API"

[00:04] <rjbs> If I quit that, I get into an ops document.  I quit that, then: Cannot chmod 0644 ops/bit.pod:No such file or directory at /Users/rjbs/perl5/perlbrew/perls/19.0/lib/5.19.0/ExtUtils/Command.pm line 274.

[00:04] <rjbs> and the whole thing fails.

[00:05] <sorear> Ummm. indeed

[00:06] <sorear> rjbs: in parrot/docs/Makefile, what is the PERLDOC variable set to?

[00:07] <rjbs> PERLDOC = /Users/rjbs/perl5/perlbrew/perls/19.0/bin/perldoc

[00:07] <sorear> do you have a PERLDOC environment variable?

[00:08] <sorear> the makefile is using perldoc -ud to extract pod from files

[00:08] <rjbs> -n/opt/local/bin/groff

[00:09] <sorear> perhaps you have an environment variable that tells perldoc to do something interesting

[00:09] *** potatogim joined
[00:09] <sorear> or perhaps perldoc5.19.0 behaves in a novel way

[00:16] <dalek> rakudo/nom: af50a6e | pmichaud++ | src/core/Str.pm:

[00:16] <dalek> rakudo/nom: Add Str.succ for codepoints \x2581..\x2588 (RT #118519).

[00:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af50a6ecfa

[00:21] *** grondilu left
[00:33] <rjbs> Worked okay once I unset PERLDOC.

[00:35] *** robinsmidsrod left
[00:37] *** robinsmidsrod joined
[00:39] * rjbs has a perl6 again!

[00:40] <rjbs> Given an object, I can get methods with .^methods.  How do I see from where each method has come?

[00:41] <rjbs> .HOW?

[00:42] <sorear> look over .^mro / .^methods(:local) will definitely work

[00:42] <sorear> there might be a better way

[00:44] <rjbs> Huh.  enum surprises me

[00:44] <rjbs> (everything surprises me)

[00:45] <rjbs> r: enum X <1 2 3>; X ~~ Enum

[00:45] <camelia> rakudo b2072f:  ( no output )

[00:45] <rjbs> r: enum X <1 2 3>; say X ~~ Enum

[00:45] <camelia> rakudo b2072f: OUTPUT«False␤»

[00:45] <rjbs> which means that X.roll's source is local and Enum isn't in the mro for X

[00:46] <sorear> Enum is the type of immutable key/value pairs.

[00:46] <sorear> Don't ask me why.

[00:46] <sorear> Enumeration is a role which is mixed into all enum objects

[00:47] <sorear> r: enum X <x1 x2 x3>; say X ~~ Enumeration

[00:47] <camelia> rakudo b2072f: OUTPUT«False␤»

[00:47] <sorear> r: enum X <x1 x2 x3>; say X.^does(Enumeration)

[00:47] <camelia> rakudo b2072f: OUTPUT«False␤»

[00:47] <sorear> hmm

[00:47] *** abnorman left
[00:48] <sorear> r: enum X <x1 x2 x3>; say X.^find_method("roll") === Enumeration.^find_method("roll")

[00:48] <camelia> rakudo b2072f: OUTPUT«False␤»

[00:48] <sorear> r: enum X <x1 x2 x3>; say X.^find_method("roll")

[00:48] <camelia> rakudo b2072f: OUTPUT«roll␤»

[00:48] <sorear> r: enum X <x1 x2 x3>; say X.^find_method("roll").perl

[00:48] <camelia> rakudo b2072f: OUTPUT«method roll(X : *@pos, *%named) { ... }␤»

[00:48] <sorear> r: enum X <x1 x2 x3>; say Enumeration.^find_method("roll").perl

[00:48] <camelia> rakudo b2072f: OUTPUT«method roll(Enumeration : *@pos, *%named) { ... }␤»

[00:48] <sorear> oh right, ::?CLASS genericity

[00:49] *** abnorman joined
[00:56] *** benabik left
[00:57] *** benabik joined
[01:00] *** fgomez left
[01:12] *** BenGoldberg left
[01:18] *** ldthien0 joined
[01:46] *** ldthien0 left
[01:52] *** fgomez joined
[01:56] *** betterworld left
[01:58] *** FROGGS left
[02:03] *** betterworld joined
[02:08] <labster> r:  < . 0 >».ord.say

[02:08] <camelia> rakudo b2072f: OUTPUT«46 48␤»

[02:08] <labster> r: say eager ".".."0"

[02:08] <camelia> rakudo b2072f: OUTPUT«(timeout)»

[02:09] <labster> yeah, that would still be a bug.

[02:10] <labster> n: say eager ".".."0"

[02:10] <camelia> niecza v24-77-g2b14288: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'eager' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 36) ␤  at /ho…

[02:10] <labster> n: say (".".."0").join

[02:10] <camelia> niecza v24-77-g2b14288: OUTPUT«.␤»

[02:13] *** FROGGS joined
[02:21] *** dayangkun_ joined
[02:22] *** dayangkun_ left
[02:22] *** mrallen1 joined
[02:25] *** dayangkun left
[02:41] *** bonsaikitten left
[02:41] *** atroxaper joined
[02:41] *** bonsaikitten joined
[02:58] *** SamuraiJack joined
[03:22] <colomon> rn: say ((set <a b c>), (bag <a b c>)).grep(* ~~ Baggy)

[03:22] <camelia> rakudo b2072f, niecza v24-77-g2b14288: OUTPUT«␤»

[03:23] <colomon> rn: say ((set <a b c>), (bag <a b c>)).grep({$_ ~~ Baggy})

[03:23] <camelia> niecza v24-77-g2b14288: OUTPUT«bag("a" => 1, "b" => 1, "c" => 1)␤»

[03:23] <camelia> ..rakudo b2072f: OUTPUT«␤»

[03:23] <colomon> errr.... what am I missing with the first one?  and rakudobug?

[03:25] <lue> .tell jnthn nqp-moar-cc.nqp:68 and MASTTesting.nqp:11 seem to be using a Windows specific command (the same one) without some OS-based conditional, leading to "sh: del: command not found" occurring in temp.output

[03:25] <yoleaux> lue: I'll pass your message to jnthn.

[03:26] <lue> .tell jnthn I'm still able to use nqp-moar-cc.nqp though, so it doesn't seem to immediately break things, at least to me.

[03:26] <yoleaux> lue: I'll pass your message to jnthn.

[03:32] *** preflex_ joined
[03:32] *** ChanServ sets mode: +v preflex_

[03:33] *** preflex left
[03:33] *** preflex_ is now known as preflex

[04:00] *** raiph joined
[04:27] *** potatogim left
[04:29] *** potatogim joined
[04:30] *** Patterner left
[04:32] *** Psyche^ joined
[04:32] *** Psyche^ is now known as Patterner

[04:32] *** Ayiko joined
[04:54] *** birdwindupbird joined
[04:55] *** araujo left
[04:59] *** havenwood joined
[05:03] *** ldthien0 joined
[05:18] *** tomyan joined
[05:24] *** potatogim left
[05:25] *** potatogim joined
[05:31] *** ssutch left
[05:36] *** twigel joined
[05:37] *** REPLeffect left
[05:41] *** dmol joined
[05:47] <skids> star: https://gist.github.com/skids/5802914

[05:47] <camelia> star 2013.02: OUTPUT«1 2 3 4␤1 2 3 4␤»

[05:48] <skids> hmmm.  Oh it isn't 05.

[05:48] <skids> r: https://gist.github.com/skids/5802914

[05:48] <camelia> rakudo b2072f: OUTPUT«1 2 3 4␤1Block.new()␤No exception handler and no message␤␤current instr.: 'throw' pc 347557 (src/gen/CORE.setting.pir:151689) (src/gen/CORE.setting:8887)␤called from Sub 'sink' pc 379739 (src/gen/CORE.setting.pir:164183) (src/gen/CORE.setting:10169)␤called from Sub…

[05:55] *** PacoAir joined
[05:56] *** raiph left
[05:59] *** PacoAir left
[06:02] *** FROGGS left
[06:18] *** dmol left
[06:18] *** domidumont joined
[06:19] *** domidumont left
[06:36] *** PZt left
[06:41] <dalek> nqp: ca52770 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[06:41] <dalek> nqp: Add a nqp::debugnoop opcode, which does nothing but you can put a breakpoint on it.

[06:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca52770a14

[06:41] <dalek> nqp: c9738ae | sorear++ | src/vm/jvm/ (3 files):

[06:41] <dalek> nqp: Multi cache should decontainerize before taking the type for JVM/Parrot consistency.  Still a little dodgy because it assumes hashCode values are unique.

[06:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c9738ae075

[06:42] <sorear> sorear$ ./perl6 -e 'use v6; say "hi"'

[06:42] <sorear> hi

[06:42] *** tomyan left
[06:43] <moritz> \o/

[06:44] *** havenwood left
[06:48] *** ldthien0 left
[06:49] *** domidumont joined
[06:50] <labster> good morning

[06:51] <labster> r: "eighty" <= 80

[06:51] <camelia> rakudo b2072f: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Real at src/gen/CORE.setting:870␤  in method Real at src/gen/CORE.setting:2596␤  in method Real at src/gen/CORE.setting:870␤  in sub infix:<<=> at src/gen/CORE.setting:3104␤  in sub …

[06:52] <sorear> labster: hey, I thought you were in my time zone

[06:52] <labster> it's morning in 10 minutes :P

[06:52] <labster> and it's always morning in UGT

[07:01] *** mrallen1 left
[07:08] *** domidumont left
[07:09] *** domidumont joined
[07:12] <moritz> labster++ # UGT

[07:24] *** FROGGS joined
[07:24] *** kaleem joined
[07:41] <TimToady> .oO(The two hardest problems in Computer Science are indirection coherence, and off-by-one levels of indirection...)

[07:42] <TimToady> I suppose a cache is an off-by-one level of indirection, so maybe they're the same problem...

[08:02] *** araujo joined
[08:02] *** araujo left
[08:02] *** araujo joined
[08:03] *** domidumont left
[08:06] <dalek> roast: 0b9ec37 | (Elizabeth Mattijsen)++ | S32-list/categorize.t:

[08:06] <dalek> roast: Added some typed hash tests to categorize

[08:06] <dalek> roast: review: https://github.com/perl6/roast/commit/0b9ec37c29

[08:15] *** kresike joined
[08:15] <kresike> hello all you happy perl6 people

[08:15] *** domidumont joined
[08:30] <sorear> o/ kresike 

[08:33] *** pochi left
[08:38] <dalek> rakudo/nom: 9fae045 | (Brent Laabs)++ | src/core/IO.pm:

[08:38] <dalek> rakudo/nom: add IO::Path methods rename, chmod

[08:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9fae045fa6

[08:38] <dalek> rakudo/nom: 74ddcd4 | (Brent Laabs)++ | src/core/IO.pm:

[08:38] <dalek> rakudo/nom: move dir()'s logic into IO::Path.contents; it's working with paths already

[08:38] <dalek> rakudo/nom: change IO::Path.resolve to a proper X::NYI

[08:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74ddcd4eed

[08:38] <dalek> rakudo/nom: 0c78d26 | (Brent Laabs)++ | src/core/IO.pm:

[08:38] <dalek> rakudo/nom: add IO::Path.succ and .pred

[08:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0c78d26c03

[08:38] <dalek> rakudo/nom: 92c09eb | (Brent Laabs)++ | src/core/IO.pm:

[08:38] <dalek> rakudo/nom: undo rename for now

[08:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92c09eb21a

[08:38] <dalek> rakudo/nom: c90fcf7 | (Brent Laabs)++ | src/core/IO.pm:

[08:38] <labster> sorry dalek

[08:39] <dalek> nqp: fff73cf | sorear++ | src/NQP/Actions.nqp:

[08:39] <dalek> nqp: Need to use savecapture when calling MMD dispatcher for reentrancy on JVM

[08:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fff73cfa6e

[08:46] *** dakkar joined
[08:50] *** kaleem left
[08:51] *** brrt joined
[08:51] <brrt> hi all

[08:51] <yoleaux> 10 Jun 2013 15:35Z <diakopter> brrt: frankly, I think those project types are actually superhuman, at least in the attention to detail and skill and training required, if not actual code size

[08:51] <brrt> wow

[08:52] <brrt> old discussion :-) 

[08:53] *** kaleem joined
[08:53] <brrt> .tell diakopter again, they are hard, like surgery is hard, but it is doable

[08:53] <yoleaux> brrt: I'll pass your message to diakopter.

[08:54] <brrt> for the record, i don't intend to knock people who do spend their time writing efficient compilers / vm *at all* 

[08:54] <brrt> i wish to knock down the conception that anything which isn't RoR autogenerated CRUD is superhuman, because I believe it holds us down

[08:55] <brrt> and articles like the wired' one - which idolize the developers that do harder work - reinforce the conception

[08:57] <bonsaikitten> brrt: looking at really "hard" problems like compilers - most are incomplete / crap

[08:57] <bonsaikitten> that suggests that either people lack the attention span for it or settle for a "good enough" solution

[08:57] <brrt> thats a possibility

[08:58] <tadzik> most are crap? Most of everything is crap, but there are good compilers around

[08:58] <tadzik> as compared to, say, email clients, which _all_ suck

[08:58] <sorear> CLA is in the outbox

[08:58] <brrt> lol :-) the other possibility is that outsiders such as you and i do not understand the same problems the authors do

[08:58] <bonsaikitten> tadzik: I've not been able to find a reliable C compiler that can be built with only a C compiler

[08:59] <brrt> i.e. 'why does GCC does X?' well, probably there is a good reason

[08:59] *** pr_ joined
[08:59] <sorear> 1..1

[08:59] <sorear> ok 1 - hi

[08:59] <sorear> this is promising

[09:00] *** fhelmberger joined
[09:01] <moritz> sorear: is this rakudo?

[09:03] *** pr_ left
[09:04] <sorear> moritz: yes

[09:04] <moritz> \o/

[09:05] *** domidumont left
[09:06] <sorear> trouble is it only wants to look for modules in . and blib

[09:06] <sorear> while test.pm lives in lib

[09:06] *** domidumont joined
[09:07] <sorear> r: use Bob

[09:07] <camelia> rakudo b2072f: OUTPUT«===SORRY!===␤Could not find Bob in any of: /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib, /home/p6eval…

[09:07] <sorear> r: say %*ENV.keys

[09:07] <camelia> rakudo b2072f: OUTPUT«PERLBREW_VERSION MAIL USER SHLVL HOME OLDPWD PERLBREW_ROOT PERLBREW_MANPATH LOGNAME _ TERM PATH PERLBREW_HOME PATH_WITHOUT_PERLBREW PERLBREW_BASHRC_VERSION LANG LS_COLORS PERLBREW_PATH SHELL PERLBREW_PERL PWD MANPATH MANPATH_WITHOUT_PERLBREW␤»

[09:08] <sorear> r: say @*INC

[09:08] <camelia> rakudo b2072f: OUTPUT«/home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/site/lib /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/vendor/lib /home/p6eval/nom-inst/lib/parrot/5.2.0-devel/languages/perl6/lib /home/p6eval/.perl6/2013.05-30-g9557da2/lib␤»

[09:10] <moritz> sorear: that's why Tests are run with PERL6LIB=lib or -Ilib

[09:13] <sorear> moritz: PERL6LIB is being ignored

[09:14] <sorear> as is -Ilib

[09:16] <moritz> :(

[09:19] <nwc10> sorear: when does the USPS empty the outtray? "Tomorrow" morning?

[09:20] <sorear> nwc10: I think so, but I'm not actually sure

[09:21] <sorear> not at 2am, that's for sure :)

[09:24] <sorear> r: say nqp::cwd()

[09:24] <camelia> rakudo b2072f: OUTPUT«/home/p6eval␤»

[09:39] *** daxim joined
[09:49] *** atroxaper left
[09:52] *** atroxaper joined
[09:59] <dalek> v5: 8221c3a | (Tobias Leich)++ | t/test_summary:

[09:59] <dalek> v5: print summary when tests are done too

[09:59] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/8221c3ae5e

[09:59] <dalek> v5: 42ba0fa | (Tobias Leich)++ | / (3 files):

[09:59] <dalek> v5: make `time` an identifier with proto (), rather than a term

[09:59] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/42ba0faeec

[10:00] *** rindolf joined
[10:00] *** brrt left
[10:01] <daxim> lang designers, have you seen <http://philsturgeon.co.uk/blog/2013/01/php-6-pissing-in-the-wind>?

[10:02] <daxim> this is not the un-php6 from <http://schlueters.de/blog/archives/128-Future-of-PHP-6.html> and <http://lwn.net/Articles/379909/>

[10:06] <masak> good midday, #perl6

[10:07] <sorear> o/ masak

[10:07] *** daxim left
[10:07] <sorear> masak: I've convinced rakudo-jvm to accept both use v6 and use Test.  also, my CLA is in the mail.  kind of.

[10:08] *** daxim joined
[10:09] <nwc10> but, presumably, unabmigiously CLA-enabled Rakudo committers could merge your work right now?

[10:09] <nwc10> just like any regular pull request

[10:09] <masak> sorear: nice.

[10:09] <nwc10> that too :-)

[10:10] <masak> nwc10: oh yes. I am sure of that.

[10:16] <sorear> masak: how much time do I have left to surprise jnthn++ with a clean spectest run?

[10:18] *** jaldhar left
[10:20] <FROGGS> where is he anyway?

[10:27] <lizmat> I think jnthn++ is spending some well earned days afk

[10:28] <masak> teaching.

[10:28] <masak> sorear: you can expect him to resurface in about 28 hours.

[10:35] <sorear> excellent

[10:40] <masak> sorear++

[10:41] <dalek> nqp: 9625921 | sorear++ | src/vm/jvm/ (2 files):

[10:41] <dalek> nqp: Add jvmgetproperties op for access to JVM VM info

[10:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9625921dc0

[10:41] <dalek> nqp: 9acdf7a | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[10:41] <dalek> nqp: Implement CCLASS_PRINTING on jvm

[10:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9acdf7ac25

[10:50] *** snearch joined
[11:02] <dalek> rakudo/nom: 6620d3b | (Elizabeth Mattijsen)++ | src/core/Hash.pm:

[11:02] <dalek> rakudo/nom: Get rid of unneeded local lists in categorize

[11:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6620d3b16d

[11:05] <moritz> who does the star modules smoking on current rakudo?

[11:05] <moritz> was that [Coke]?

[11:05] <lizmat> I think so, yes

[11:11] <sorear> https://gist.github.com/sorear/5804522

[11:15] <sorear> (that's for everyone :D)

[11:18] <moritz> that's quite impressive

[11:19] <sorear> btw, -Ilib works now

[11:19] <FROGGS> cool!

[11:20] <sorear> and on that note, sleep&

[11:20] <lizmat> goodnight sorear++

[11:21] <sorear> i've pushed everything to sorear/rakudo/nom; beware that I haven't tested the changes on parrot

[11:22] *** atroxaper left
[11:23] <dalek> rakudo/nom: 003f346 | (Timo Paulssen)++ | src/Perl6/Grammar.nqp:

[11:23] <dalek> rakudo/nom: allow a dot before hyper postfix (also unspace).

[11:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/003f346cd0

[11:23] <dalek> rakudo/nom: 2765030 | moritz++ | src/Perl6/Grammar.nqp:

[11:23] <dalek> rakudo/nom: Merge branch 'add-dotty-hyper-postfix' of https://github.com/timo/rakudo into nom

[11:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/27650306fc

[11:24] *** benabik left
[11:24] <dalek> roast: 629ff33 | moritz++ | S03-operators/set.t:

[11:24] <dalek> roast: fudge set.t for rakudo

[11:24] <dalek> roast: review: https://github.com/perl6/roast/commit/629ff33dc1

[11:26] <woolfy> sorear++

[11:38] *** pr_ joined
[11:39] <pr_> Hi, is the :nl parameter in IO::Handle::open not functional? eg, open $file, :w, :enc<Latin-1>, :nl<"\r\n\r\n">

[11:41] *** yves left
[11:42] <moritz> pr_: seems it isn't

[11:43] <moritz> pr_: the proper way to supply it would be :nl("\r\n\r\n")

[11:43] <moritz> :nl<...> already implies quoting, so the double quotes would be part of the string passed to the function -- not what you want

[11:43] <moritz> (but it's not yet implemented)

[11:45] <pr_> When nl("\r\n\r\n") is implemented, will this be the best way to specify Windows line endings?

[11:46] <masak> pr_: I should think in the ordinary case, Windows line endings will be handled correctly by default.

[11:46] <masak> pr_: what you want to do looks like a combination of that and paragraph breaks.

[11:47] <pr_> masak: it seems a bit complicated. I miss :crlf :-)

[11:48] <masak> again, Windows line breaks Should Just Work without you doing anything. just like in Perl 5.

[11:48] <masak> I don't think that seems complicated ;)

[11:50] <pr_> masak: understood. But I was thinking of writing to Unix/Mac files on Windows, and vice-versa. I will just have to practice the new technique.

[11:53] <lizmat> r: my $a=1; my @a; @a.push($a); say $a === @a[0]; $a=2; say $a; say @a[0]  # apparently a===b is not enough to check for bound variables

[11:53] <camelia> rakudo b2072f: OUTPUT«True␤2␤1␤»

[11:54] *** yves joined
[11:54] <lizmat> Q: how would I check whether two values are bound to the same container?

[11:54] <lizmat> Q: how can I push a bound value onto a list

[11:54] <FROGGS> I thought arrays dont do binding

[11:55] <FROGGS> r: my $a=1; my @a; @a.push($a); say $a === @a[0]; $a=2; say $a; say @a[0] # hmmm

[11:55] <camelia> rakudo b2072f: OUTPUT«True␤2␤1␤»

[11:56] <FROGGS> r: my $a=1; my @a; @a.push($a); say $a === @a[0]; $a=2; say $a; say @a[0] # this is hmmm

[11:56] <camelia> rakudo b2072f: OUTPUT«True␤2␤1␤»

[11:56] <FROGGS> damn it

[11:56] <FROGGS> r: my $a=1; my @a; @a[0] := $a; say $a === @a[0]; $a=2; say $a; say @a[0]

[11:56] <camelia> rakudo b2072f: OUTPUT«True␤2␤2␤»

[11:57] <FROGGS> r: my $a=1; my @a; @a[0] = $a; say $a === @a[0]; $a=2; say $a.WHERE; say @a[0].WHERE

[11:57] <camelia> rakudo b2072f: OUTPUT«True␤-1160124824␤-1174207627␤»

[11:57] <FROGGS> r: my $a=1; my @a; @a[0] := $a; say $a === @a[0]; $a=2; say $a.WHERE; say @a[0].WHERE

[11:57] <camelia> rakudo b2072f: OUTPUT«True␤-581111009␤-581111009␤»

[11:57] <FROGGS> that is the answer to Q1

[11:58] <lizmat> $a.WHERE ~~ $a[0].WHERE you mean?

[11:58] <lizmat> or $a.WHERE == $a[0].WHERE ?

[11:59] <FROGGS> ==

[11:59] <moritz> =:= checks for container equivalence

[12:00] <moritz> r: my $x = 3; my @a; @a[0

[12:00] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in subscript; couldn't find final ']'␤at /tmp/6_bV39Wdq4:1␤------> [32mmy $x = 3; my @a; @a[0[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤     …

[12:00] <lizmat> r: my $a=1; my $b:=$a; say $a =:= $b  # indee

[12:00] <camelia> rakudo b2072f: OUTPUT«True␤»

[12:00] <lizmat> d

[12:00] <FROGGS> r: my $a=1; my @a; @a[0] = $a; say $a =:= @a[0];

[12:00] <camelia> rakudo b2072f: OUTPUT«False␤»

[12:00] <moritz> r: my $a=1; my @a; @a[0] := $a; say $a =:= @a[0];

[12:00] <camelia> rakudo b2072f: OUTPUT«True␤»

[12:01] <FROGGS> answer to Q2: bind_pos might what you want

[12:02] <lizmat> moritz++, FROGGS++ thanks for the pointers

[12:04] * masak .oO( "thanks for the pointers", said the http://c2.com/cgi/wiki?ThreeStarProgrammer )

[12:05] <lizmat> I'm so glad I don't have to program in C

[12:06] <lizmat> masak: our as the previous pope would say "denk you four ze blumen"

[12:08] * masak .oO( "Did Beethoven compose eight symphonies?" -- "Nein!" )

[12:09] * moritz groans

[12:09] <tadzik> ehehe

[12:09] <masak> mission accomposed :)

[12:10] * lizmat goes out to cool down

[12:12] <masak> ...something that's not possible in Austin, Texas... :)

[12:12] <nwc10> not very possible in Vienna currently

[12:17] <lizmat> well, that was the dead pan part of my joke: it's 31 celsius in the shade outside now

[12:18] <masak> :)

[12:18] <masak> sorry for being so slow. it must be the heat.

[12:22] *** JimmyZ joined
[12:23] <lizmat> I wonder how the description of pop at S32/Containers:697 can be combined with the reverse example at S32/Containers:386

[12:24] <lizmat> in other words: 697 describes as pop failing on an empty array, while the reverse example seems to assume it will not?

[12:26] *** atroxaper joined
[12:28] *** Kelder joined
[12:28] *** Ayiko left
[12:29] <masak> rn: say (my @a).pop ~~ Failure

[12:29] <camelia> niecza v24-77-g2b14288: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Failure' used at line 1␤␤Potential difficulties:␤  @a is declared but not used at /tmp/5Kj7kwG9_c line 1:␤------> [32msay (my [33m⏏[31m@a).pop ~~ Failure[0m␤␤Unhandled exception: Check failed␤␤  at /ho…

[12:29] <camelia> ..rakudo b2072f: OUTPUT«True␤»

[12:29] <masak> r: my @a = 1, 2, 3; say "yay" while @a.pop; say "alive"

[12:29] <camelia> rakudo b2072f: OUTPUT«yay␤yay␤yay␤alive␤»

[12:30] <masak> lizmat: no, the reverse example only seems to assume that 'pop @values' will return something falsy.

[12:30] <lizmat> so the while eats the failure and interpretes it as false 

[12:30] <lizmat> so it never gets thrown?

[12:30] <masak> right.

[12:30] <masak> that's Failures for you.

[12:30] <masak> lizmat: which works (see above) but is stupid for a different reason -- it would stop on 0 and "" and empty arrays.

[12:31] <masak> I dislike pseudocode like this in the spec. it almost always turns out to be too naïve.

[12:31] <lizmat> or if there is any other (internal) failure in pop, one would never know

[12:32] <masak> right.

[12:32] <lizmat> hmmmm....

[12:33] <masak> worse, code like that in the spec makes it seem like that's how the routine *should* be implemented (instead of just providing a hopefully useful hint on how it could be implemented)

[12:33] <lizmat> well, that could be fixed with a "For example"

[12:33] <masak> it's a *spec*. it should be conservative about what it specs.

[12:34] <lizmat> so why couldn't pop return Mu on an empty array

[12:34] <lizmat> and have it throw any Failures?

[12:34] <masak> er. you throw Exceptions, not Failures.

[12:35] <moritz> if you do nothing with the returned Failure, it blows up

[12:35] <masak> and Failure seems to be the right thing to return from a pop on an empty array.

[12:35] <moritz> so the chances of hiding a bug are smaller when returning a Failure

[12:35] <lizmat> r: my @a; say pop @a

[12:35] <camelia> rakudo b2072f: OUTPUT«Element popped from empty list␤  in method gist at src/gen/CORE.setting:10161␤  in method gist at src/gen/CORE.setting:893␤  in sub say at src/gen/CORE.setting:11047␤  in block  at /tmp/_boKEm_mAL:1␤␤»

[12:35] <timotimo> isn't a Nil more appropriate for pop on an empty array?

[12:35] <lizmat> so I guess "say" is stringifying the Failure

[12:35] <moritz> .gist actually

[12:36] <lizmat> ack

[12:36] <moritz> and it blows up, because it's not yet handled

[12:36] <timotimo> r: my @a; print pop @a

[12:36] <camelia> rakudo b2072f: OUTPUT«Element popped from empty list␤  in method Str at src/gen/CORE.setting:10160␤  in method Str at src/gen/CORE.setting:876␤  in method print at src/gen/CORE.setting:11231␤  in method print at src/gen/CORE.setting:11225␤  in sub print at src/gen/CORE.setting:11041␤  i…

[12:36] <lizmat> and "while" is silently "handling" failure

[12:36] <moritz> right

[12:37] <moritz> testing truthiness and .defined-ness on a Failure sets its 'handled' bit

[12:37] * moritz is not a big fan of that one

[12:37] <lizmat> for now, I tend to agree

[12:37] <lizmat> with not being a big fan of that

[12:38] <lizmat> .oO{wish we had a fan now}

[12:38] *** konundra left
[12:38] <FROGGS> gah, don't make so much wind about it

[12:38] <nwc10> don't worry, it will all blow over soon

[12:40] * timotimo lets out a big sigh

[12:40] <[Coke]> sorear++ #cla

[12:41] <masak> so, I caught wind of these air-based puns you guys are doing.

[12:41] <masak> frankly, I think the whole thing is a bit overblown.

[12:41] <[Coke]> Anyone wants rakudo-jvm smoked for star (needs more infrastructure) or for the spec tests, we need a box we can run java on. feather1 is out, per Juerd.

[12:42] <lizmat> can one create a MMD candidate depending on the value of a method / attribute of the object?

[12:43] <lizmat> [Coke]: am about to retire my 3 year old 17" MacBook Pro, with 8G of RAM, would that be able to do this?

[12:43] <[Coke]> lizmat: aside from the difficulty of building pugs the first time, likely.

[12:43] <masak> r: class C { has $.attr is rw = 5; multi method foo($x where { $x == $.attr }) { say "OH HAI" }; multi method foo($x) { say "OH default" } }; given C.new { .foo; .attr = 42; .foo }

[12:43] <camelia> rakudo b2072f: OUTPUT«Cannot call 'foo'; none of these signatures match:␤:(C : $x, Mu *%_)␤:(C : $x, Mu *%_)␤  in method foo at src/gen/CORE.setting:440␤  in block  at /tmp/AvLKXp2MGv:1␤␤»

[12:43] * moritz would be very happy with such a machine :-)

[12:44] <masak> r: class C { has $.attr is rw = 5; multi method foo($x where { $x == $.attr }) { say "OH HAI" }; multi method foo($x) { say "OH default" } }; given C.new { .foo(5); .attr = 42; .foo(5) }

[12:44] <moritz> [Coke]: where are the star-on-current-rakudo smoke results?

[12:44] <camelia> rakudo b2072f: OUTPUT«OH HAI␤OH default␤»

[12:44] <masak> lizmat: like that? :)

[12:44] <[Coke]> https://github.com/coke/rakudo-star-daily/blob/master/log/test-modules.log

[12:44] *** pr_ left
[12:44] <lizmat> how would that work performance wise?  Thinking about adding MMD candidates for so List.infinite 

[12:45] <moritz> [Coke]: thanks

[12:45] <[Coke]> lizmat: if you'd be willing to leave the lights on, I would definitely be happy to give the box a whirl. 

[12:45] <lizmat> [Coke]: not yet, I still need to order the new one (delivery should be 1-3 working days)

[12:46] <[Coke]> (or I could host it somewhere.)

[12:46] <[Coke]> lizmat: no rush.

[12:46] <lizmat> so sometime next week

[12:46] *** domidumont left
[12:46] <moritz> the only test failing in star with current rakudo is perl6-File-Tools:t/01-file-find.t test 10

[12:47] <[Coke]> so, I'm wondering if it make sense to have the daily rakudo star builds always go for latest rakudo and latest modules.

[12:48] <[Coke]> (as opposed to the versions marked in the repo)

[12:48] <lizmat> I would think so…  that was the whole idea, no?

[12:48] <moritz> and panda fails to bootstrap :(

[12:48] <tadzik> :|

[12:48] <lizmat> so that problems are found early, rather than at Rakudo release time?

[12:48] <[Coke]> lizmat: when we started it a few weeks ago, even the selected versions of everything failed to work.

[12:48] <moritz> ==> Bootstrapping Panda

[12:48] <moritz> ==> Fetching File::Tools

[12:48] <moritz> Failed to remove the file '.work/1371559686_1': unlink failed: No such file or directory

[12:48] <tadzik> fff

[12:49] <dagurval> ._.

[12:49] <tadzik> easy to fix at least

[12:49] <dagurval> test 10 is the one I just added ._.

[12:49] <tadzik> I'll look at it after $job

[12:52] *** konundra joined
[12:53] * lizmat seemed to have introduced a recursion while saving the restricted settings  :-(

[12:53] *** Timbus left
[12:54] * FROGGS .oO( s.o.s - save our setting )

[12:56] *** panchiniak_ joined
[12:56] *** Timbus joined
[12:57] *** ajr joined
[12:57] *** ajr is now known as Guest4236

[12:58] *** Guest4236 is now known as ajr_

[12:59] <JimmyZ> :D

[13:01] *** domidumont joined
[13:05] <lizmat> r: class C { has $.attr = 5; multi method foo($x where { $.attr == 5 }) { say "OH HAI" }; multi method foo($x) { say "OH default" } }; given C.new { .foo(5); .attr = 42; .foo(5)

[13:05] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/TU2gMDHRY6:1␤------> [32mven C.new { .foo(5); .attr = 42; .foo(5)[33m⏏[31m<EOL>[0m␤    expecting any of:␤        postfix␤        statement end␤        statement …

[13:05] <lizmat> excuse, ww  :-)

[13:06] <timotimo> https://github.com/rakudo/rakudo/pull/160 - is there something wrong with this that prevents merging?

[13:08] <lizmat> spec changes generally need to be looked over by pmichaud / TimToady ?

[13:08] <lizmat> <plug> a bit like https://github.com/perl6/specs/issues/54 </plug> ?

[13:09] <timotimo> oh, i forgot.

[13:09] *** atroxaper left
[13:09] <timotimo> in that case: is there something wrong with it that prevents a discussion from taking place? :)

[13:10] <moritz> timotimo: nothing wrong, just that nobody has looked over it yet, it seems

[13:10] <moritz> timotimo: and I'd like to wait until after the release, for fear that it might break some module and thus star

[13:11] <timotimo> S06 at least doesn't mention types on slurpies

[13:12] *** PZt joined
[13:13] <timotimo> it doesn't seem like the spec says anything about typed slurpy arguments; so there should be an addition somewhere that says "you can't do that."

[13:14] <timotimo> so not really a spec change per se

[13:14] <moritz> sure, but it still might be used somwhere

[13:14] <timotimo> also, if it does break modules, it would only mean they were broken already, just waiting for compile time to actually explode :)

[13:14] <moritz> maybe even in a multi candidate that is never reached

[13:14] <timotimo> should i perhaps just merge locally and run a full star test run?

[13:14] <moritz> so the code might work right now, even for the wrong reasons

[13:16] <timotimo> actually, i could even just grep this

[13:24] *** tidux joined
[13:24] *** PacoAir joined
[13:25] <tidux> so is there any big software that's been built in perl6 yet?

[13:25] <JimmyZ> how big is big?

[13:25] <dalek> niecza: 9f58f84 | (Solomon Foster)++ | lib/CORE.setting:

[13:25] <dalek> niecza: Rewrite infix:<∪> and infix:<∩> to take arbitrary inputs.

[13:25] <dalek> niecza: 

[13:25] <dalek> niecza: Previous versions of these all took two arguments, but they are list-ops, and so may be passed any number of arguments.

[13:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9f58f842d8

[13:25] <tidux> bigger than simple scripts and the usual perl fare

[13:26] <tidux> not necessarily Frozen Bubble :P

[13:26] <JimmyZ> how simple is simple?

[13:26] <tidux> <500 lines

[13:26] <JimmyZ> rakudo is big enough? it's written in Perl 6

[13:26] <tidux> lol

[13:27] <tidux> point taken

[13:27] *** tidux left
[13:27] <dalek> roast: ee5778e | (Solomon Foster)++ | S03-operators/bag.t:

[13:27] <dalek> roast: Fudge for Niecza.

[13:27] <dalek> roast: review: https://github.com/perl6/roast/commit/ee5778e247

[13:29] <colomon> tidux: ABC module is 1600+ lines at the moment, not counting test files.

[13:30] <masak> the biggest I ever wrote is probably GGE...

[13:35] <daxim> http://www.ibiblio.org/pub/linux/search/keeper-1.54.tar.gz   # behold! I bring you code from that last millenium!

[13:36] <JimmyZ> hmm, looks like mbc file is half size of the pbc one 

[13:37] <FROGGS> mbc is moarvm bytecode?

[13:38] <timotimo> it probably doesn't store all the line numbers in 64bit integers :P

[13:38] <dagurval> r: use MONKEY_TYPING; augment class Cool { method bark() { say "woof!" } }; 5.bark

[13:38] <camelia> rakudo b2072f: OUTPUT«No such method 'bark' for invocant of type 'Int'␤  in block  at /tmp/sKY0qVp_fw:1␤␤»

[13:38] <dagurval> shouldn't my Int bark since Int is Cool?

[13:38] <timotimo> isn't cool a role, though?

[13:38] <JimmyZ> yes, but after to mbc.zip, mbc file is 9/10 of the pbc.zip one

[13:38] <moritz> it's not

[13:38] <timotimo> i think retroactively enhancing roles won't do it

[13:38] <moritz> dagurval: yes, known bug

[13:38] <timotimo> mhm

[13:38] <dagurval> moritz: ok

[13:39] <FROGGS> dagurval: inherited classes are not affected yet

[13:39] <moritz> the problem is that method caches are wrote at class composition time

[13:39] <dagurval> I see :)

[13:39] <moritz> but a class can't just keep a reference to all subclasses, because then anonymous subclasses wouldn't be garbage-collected

[13:40] <moritz> so how should a class know which method caches from subclasses need to be invalidated?

[13:40] <timotimo> r: say dir()

[13:40] <camelia> rakudo b2072f: OUTPUT«IO::Path<star> IO::Path<src> IO::Path<.subversion> IO::Path<.bashrc> IO::Path<nom-inst1> IO::Path<toqast> IO::Path<test3.pl> IO::Path<.profile> IO::Path<t> IO::Path<nom-inst2> IO::Path<nom-inst> IO::Path<toqast-inst> IO::Path<toqast-inst2> IO::Path<examples> IO::Pa…

[13:40] <moritz> r: say ~<<dir()

[13:40] <camelia> rakudo b2072f: OUTPUT«star src .subversion .bashrc nom-inst1 toqast test3.pl .profile t nom-inst2 nom-inst toqast-inst toqast-inst2 examples Makefile .gitignore lib test2.pl .local bin rakudo p1 VERSION simple-tests .perlbrew std obj main.pl .lesshst nom niecza test.pl .cpanm log .bash_…

[13:41] <timotimo> having a bit of trouble with panda at the moment

[13:41] <timotimo> rather, with file::tools

[13:42] <timotimo> File::Find::Result is cool, but doesn't implement .path, just .Str, so the dir function breaks; perhaps dir should call $thing.Str.path instead of $thing.path?

[13:42] * timotimo investigates

[13:42] *** brrt joined
[13:42] <tadzik> I think F::F::Result is mostly obsolete, since we have now a sensemaking Path objects

[13:43] <tadzik> I thought there's even a patch for it

[13:43] <timotimo> ah. cool doesn't prescribe a .path to exist, so dir() isn't actually correct.

[13:44] <timotimo> thoughts? should Cool get a .path that runs .Stringy.path?

[13:45] <moritz> aye

[13:47] * timotimo prepares a patch & PR

[13:50] *** btyler joined
[13:52] * timotimo runs spectests

[13:54] *** bluescreen10 joined
[13:59] *** ajr_ left
[14:00] *** ajr joined
[14:00] *** ajr is now known as Guest78348

[14:01] *** Guest78348 is now known as ajr_

[14:04] *** kaleem left
[14:05] *** fgomez left
[14:08] <dalek> rakudo/nom: 5feb260 | (Timo Paulssen)++ | src/core/Cool.pm:

[14:08] <dalek> rakudo/nom: give Cool a path method to run self.Stringy.path

[14:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5feb260a33

[14:08] <dalek> rakudo/nom: 8bbebc9 | moritz++ | src/core/Cool.pm:

[14:08] <dalek> rakudo/nom: Merge pull request #167 from timo/give-cool-path-method

[14:08] <dalek> rakudo/nom: 

[14:08] <dalek> rakudo/nom: give Cool a path method to run self.Stringy.path

[14:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8bbebc9512

[14:15] *** domidumont left
[14:16] *** domidumont joined
[14:17] <dalek> roast: b5485fa | (Timo Paulssen)++ | S0 (2 files):

[14:17] <dalek> roast: unfudge now-passing unspace and dotty hyper tests

[14:17] <dalek> roast: review: https://github.com/perl6/roast/commit/b5485faddb

[14:19] *** gabriel__ joined
[14:32] *** konundra left
[14:32] *** mrallen1 joined
[14:34] *** p5eval left
[14:38] *** p5eval joined
[14:46] *** araujo left
[14:49] *** mrallen1 left
[14:54] *** araujo joined
[14:55] *** konundra joined
[14:55] *** JimmyZ left
[14:56] *** kaare_ joined
[14:56] *** ajr_ left
[14:58] <kresike> bye folks

[14:58] *** kresike left
[14:58] *** ajr_ joined
[15:00] *** brrt left
[15:01] *** panchiniak_ left
[15:10] *** potatogim_ joined
[15:14] *** btyler left
[15:20] *** potatogim_ is now known as potatogim_H

[15:20] *** potatogim_H is now known as potatogim_LT

[15:25] *** konundra left
[15:25] *** konundra joined
[15:31] *** bruges left
[15:32] *** dmol joined
[15:33] *** btyler joined
[15:33] *** bruges joined
[15:39] *** REPLeffect joined
[15:39] *** potatogim_LT left
[15:41] *** SamuraiJack left
[15:42] *** FROGGS left
[15:42] *** domidumont left
[15:56] *** konundra left
[16:04] *** vk joined
[16:04] *** vk left
[16:04] *** spider-mario joined
[16:06] <daxim> r: sub by(Int $n, @a) {  my @r; push @r, splice @a, 0, $n; return @r;  };  by(5, [1..15]).perl.say;

[16:06] <camelia> rakudo b2072f: OUTPUT«Array.new(1, 2, 3, 4, 5)␤»

[16:06] *** FROGGS joined
[16:06] <daxim> r: sub by(Int $n, @a) {  my @r; while (@a) { push @r, splice @a, 0, $n;  }; return @r;  };  by(5, [1..15]).perl.say;

[16:06] <camelia> rakudo b2072f: OUTPUT«Array.new(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)␤»

[16:06] <daxim> r: sub by(Int $n, @a) {  my @r; while (@a) { push @r, [splice @a, 0, $n];  }; return @r;  };  by(5, [1..15]).perl.say;

[16:06] <camelia> rakudo b2072f: OUTPUT«Array.new([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15])␤»

[16:08] <masak> r: sub infix:<by>(@a, Int $n) { my @r; while (@a) { push @r, [splice @a, 0, $n];  }; return @r }; .say for [1..15] by 5

[16:08] <camelia> rakudo b2072f: OUTPUT«1 2 3 4 5␤6 7 8 9 10␤11 12 13 14 15␤»

[16:08] <masak> \o/

[16:09] <daxim> that's neat.  can you do method "by" on List literals, too?

[16:10] <masak> if you're up for MONKEY_TYPING, sure.

[16:10] <daxim> I'm always up for it

[16:10] <perigrin> how do you think we write our code *now*?

[16:10] <masak> :)

[16:10] <FROGGS> r: sub by(Int $n, @a) {  gather { take [splice @a, 0, $n] } xx +@a/$n };  by(5, [1..15]).perl.say;

[16:10] <camelia> rakudo b2072f: OUTPUT«([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]).list␤»

[16:10] <masak> I forgot you are Perl 5 people :P

[16:10] <daxim> "we need typewriters.  lots of typewriters."

[16:11] <colomon> perigrin++

[16:12] <[Coke]> "THIS IS PERL 5!!!" -khan

[16:12] <perigrin> daxim++

[16:12] <masak> r: use MONKEY_TYPING; augment class Range { method by(Int $n) { my @a = self; my @r; while (@a) { push @r, [splice @a, 0, $n] }; return @r } }; .say for (1..15).by(5)

[16:12] <camelia> rakudo b2072f: OUTPUT«1 2 3 4 5␤6 7 8 9 10␤11 12 13 14 15␤»

[16:13] <perigrin> masak: worse, increasingly I am business people.

[16:13] <masak> r: say Range.^mro; say Array.^mro; say List.^mro

[16:13] <camelia> rakudo b2072f: OUTPUT«(Range) (Iterable) (Cool) (Any) (Mu)␤(Array) (List) (Iterable) (Cool) (Any) (Mu)␤(List) (Iterable) (Cool) (Any) (Mu)␤»

[16:13] <masak> hm, should probably go on Iterable.

[16:13] <perigrin> I happen to write code because I can't afford programmer people to do it for me at the moment.

[16:13] <daxim> is Iterable something concrete or just dangling in there for abstraction?

[16:13] *** domidumont joined
[16:14] <masak> r: use MONKEY_TYPING; augment class Iterable { method by(Int $n) { my @a = self; my @r; while (@a) { push @r, [splice @a, 0, $n] }; return @r } }; .say for (1..15).by(5)

[16:14] <camelia> rakudo b2072f: OUTPUT«No such method 'by' for invocant of type 'Range'␤  in block  at /tmp/IJcgrBhBZZ:1␤␤»

[16:14] <masak> :(

[16:14] <masak> r: class A {}; class B is A {}; use MONKEY_TYPING; augment class A { method foo { say "OH HAI" } }; B.new.foo

[16:14] <camelia> rakudo b2072f: OUTPUT«No such method 'foo' for invocant of type 'B'␤  in block  at /tmp/eSG1qAjhpW:1␤␤»

[16:14] <masak> shouldn't this trivially work?

[16:14] <masak> is this a known bug?

[16:15] <masak> daxim: Iterable is a concrete class in the CORE setting.

[16:15] *** ajr_ left
[16:16] <daxim> I'm having fun already

[16:16] <daxim> http://doc.perl6.org/type/Iterable#gist is delightful

[16:17] <[Coke]> masak: I can't say I'm surprised that you're not seeing a change in your already instantiated class.

[16:17] <[Coke]> I can see where we'd want it to work, though.

[16:17] <[Coke]> r: class A {}; class B is A {}; use MONKEY_TYPING; augment class A { method foo { say "OH HAI" } }; A.new.foo;

[16:17] <camelia> rakudo b2072f: OUTPUT«OH HAI␤»

[16:19] <FROGGS> r: List.HOW.add_method( List, sub ($self, $n) { gather { take [splice $self, 0, $n] } for ^3 } );  [1..15].by(5).perl.say;

[16:19] <camelia> rakudo b2072f: OUTPUT«too few positional arguments: 3 passed, 4 (or more) expected␤  in any add_method at src/gen/Metamodel.nqp:391␤  in block  at /tmp/DEdlWqEz0i:1␤␤»

[16:19] <FROGGS> meh

[16:19] <masak> [Coke]: class wasn't already instantiated.

[16:19] <masak> at least not according to the normal definition of "instantiate".

[16:19] <FROGGS> masak: that is the caching bug mentioned earlier this day, no?

[16:20] <masak> [Coke]: it feels like a fairly standard assumption that deriving class see new methods. I realize it takes some kind of method cache update, which takes some kind of "backlinks" from ancestor classes to descendant classes, which is conceptually problematic.

[16:20] <FROGGS> r: List.HOW.add_method( List, 'by', sub ($self, $n) { gather { take [splice $self, 0, $n] } for ^3 } );  [1..15].by(5).perl.say;

[16:20] <camelia> rakudo b2072f: OUTPUT«No such method 'by' for invocant of type 'Array'␤  in block  at /tmp/LvaAvwy5t6:1␤␤»

[16:20] <masak> but Perl 6 doesn't shy away from conceptually problematic things :)

[16:20] <masak> FROGGS: oh, most likely.

[16:20] * masak goes hunting through the backlog

[16:20] <FROGGS> r: Array.HOW.add_method( Array, 'by', sub ($self, $n) { gather { take [splice $self, 0, $n] } for ^3 } );  [1..15].by(5).perl.say;

[16:20] <camelia> rakudo b2072f: OUTPUT«([1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]).list␤»

[16:20] <FROGGS> \o/

[16:21] <masak> FROGGS: I don't find it in the backlog. url?

[16:21] <FROGGS> masak: maybe search for moritz + cache

[16:21] <FROGGS> hold on

[16:21] <masak> ok

[16:22] <masak> found some joking about caching yesterday, but it doesn't seem related.

[16:22] *** diederich joined
[16:22] <FROGGS> http://irclog.perlgeek.de/perl6/2013-06-18#i_7211743

[16:23] <masak> yes, moritz correctly identifies the problem.

[16:23] <masak> ISTR that jnthn has a solution in mind, though.

[16:23] <FROGGS> cool

[16:23] <FROGGS> that would be sweet

[16:24] <masak> "how can anonymous classes be GC'd?" -- seems to me like a classic use case for weak references.

[16:25] <masak> but then TimToady would point out that weak references are a design smell. :)

[16:25] <daxim> good enough

[16:25] <masak> dangit, I've spent so much time here that I can basically enact people's replies without them actually being around! :P

[16:26] <masak> anyway, I don't see an insurmountable conceptual problem there.

[16:27] <flussence> aw crap, rakudo-parrot isn't compiling for me today. (https://gist.github.com/anonymous/5806904)

[16:28] <masak> conceptually, it feels to me like deriving classes:base class :: consumers:producer, and as long as subscriptions are set up as weak references, there are no GC issues.

[16:28] <FROGGS> hmmm, I guess it would help if I knew what weak refs are...

[16:28] <masak> FROGGS: it's like a normal reference, except that the GC chooses to ignore it in counts.

[16:29] <masak> FROGGS: with the effect that the reference may at any point become invalid because the pointee was GC'd.

[16:29] <FROGGS> ahh

[16:29] <masak> FROGGS: basically, it's a way for someone to say "I point to these things, but I don't care *enough* to keep them alive".

[16:29] *** kaleem joined
[16:30] <FROGGS> but that doesnt sound too good

[16:30] <masak> which helps prevent cycles (and thus memory leaks) sometimes.

[16:31] <masak> well, you'd better have a story for what happens when something disappears. :) most of the time it's "meh, who cares?", though.

[16:32] *** kaleem_ joined
[16:32] <masak> the reason it's a design smell is that you need the opt-in from the GC to do this. so it's user code instrumenting the GC; that's a dependency going very much the wrong way.

[16:32] <FROGGS> well, if I have a class in a scalar, and want to use it later, and it is gone... I think I would care it it got GC'd already

[16:32] <masak> yeah. which is why you wouldn't use a weak reference for a scalar :)

[16:32] <FROGGS> ahh, I see

[16:32] *** kaleem left
[16:33] <masak> "doctor, it hurts when I do this"

[16:33] <FROGGS> I said pretty much that last wednesday

[16:34] *** daxim left
[16:34] <FROGGS> ( tendinitis )

[16:34] <[Coke]> I apologize for basically re-asking my last tcl question each day, but:

[16:34] <[Coke]> (wait, let me check the test suite)

[16:36] *** stevan_ left
[16:36] <[Coke]> does anyone have an example of nqp's lexdyn? nqp has it in nqp's own source, but not as QAST.

[16:37] <masak> I'm not sure it's a big problem that anonymous classes wouldn't get GC'd. I should think they're often quite long-lived anyway.

[16:38] <FROGGS> dinner &

[16:38] <masak> r: my @a; for ^2 { push @a, Any.new but role {} }; say @a[0].WHAT === @a[1].WHAT

[16:38] <camelia> rakudo b2072f: OUTPUT«True␤»

[16:38] *** benabik joined
[16:38] <masak> there you go. that anonymous class in there is program-wide, not scope-wide.

[16:39] <masak> thinking about scopes during compilation and runtime has been one of the most interesting things for me in the past year or two.

[16:39] <masak> hm, maybe call it "lexical-scope-wide" for clarity.

[16:39] <moritz> http://www.perlmonks.org/?node_id=1039484

[16:40] *** fhelmberger left
[16:41] <masak> moritz: I half-expected some insightful reply by you in that thread.

[16:42] <moritz> masak: I'm now thinking about writing one

[16:43] *** ajr joined
[16:43] <masak> I hadn't really thought of () and [] being the "wrong" syntax match for that semantics.

[16:43] <masak> it still feels pretty right to me.

[16:43] *** ajr is now known as Guest7443

[16:43] *** konundra joined
[16:44] <masak> &

[16:49] *** kaleem_ left
[16:49] <moritz> http://www.perlmonks.org/?node_id=1039484 # my reply

[16:51] *** Guest7443 is now known as ajr_

[16:52] *** Chillance joined
[16:55] <dalek> v5: ba34a16 | (Tobias Leich)++ | / (4 files):

[16:55] <dalek> v5: better handling for ord/chr

[16:55] <dalek> v5: 

[16:55] <dalek> v5: This also handles sub call with parens better.

[16:55] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/ba34a16af3

[16:56] *** dakkar left
[16:58] *** domidumont left
[16:59] *** domidumont joined
[17:03] *** twigel left
[17:04] *** birdwindupbird left
[17:28] <[Coke]> next qast question past had a :scope<keyed> for Var's - what's the equivalent for QAST?

[17:33] *** xenoterracide joined
[17:35] <xenoterracide> so I was wondering... is it possible to provide a grammar and then reverse it? so I provide the perl6 equivalent of the grammar and then I want to output that as the grammar could read it back in (if that makes remote sense)

[17:35] <[Coke]> ah. perhaps an atkey call on a Var.

[17:35] <[Coke]> Didn't jnthn just demo something like that at YAPC?

[17:36] <xenoterracide> possibly but I missed half of that talk

[17:37] *** stevan_ joined
[17:37] *** vk_ joined
[17:41] <lizmat> jnthn's talk at YAPC::NA had this new concept of "backtions"

[17:41] <lizmat> but I don't think it did what you're describing here

[17:42] * lizmat must admit it was going over her head  :-)

[17:43] *** vk_ is now known as vk

[17:45] <[Coke]> lizmat: I feel like that often when sixperling.

[17:46] <[Coke]> invoke() not implemented in class 'QAST::SVal'f.. hurm.

[17:47] <moritz> [Coke]: QAST::SVal() vs. QAST::SVal.new()

[17:47] <moritz> [Coke]: you typed the former, the latter is correct

[17:48] <moritz> (most likely)

[17:48] <colomon> actually, I think what xenoterracide describes is pretty much exactly what jnthn++ did

[17:49] <masak> yeah.

[17:49] <[Coke]> wow, moritz++'s builtin qast compiler is prety accurate.

[17:49] <lizmat> see, I didn't get it at all then

[17:49] <colomon> https://github.com/jnthn/grammar-generative

[17:50] <masak> lizmat: conceptually, a grammar is a function that takes a string and returns a match-tree. jnthn wrote some stuff to also make a grammar conceptually into a function that takes a match-tree and returns a string.

[17:51] <moritz> [Coke]: I've made the same error more than once

[17:51] <moritz> (which is an euphemism for "many times")

[17:52] <masak> oh, *that* error.

[17:52] <masak> yes, me too.

[17:52] <masak> it's very tempting, especially when you're writing big nested things.

[17:52] <[Coke]> I feel like I am blindly hacking at this half baked nqprx->nqp code. "what did this do? eh, just droip it. maybe it's the default"

[17:53] <lizmat> looking at jnthn's grammar-generative: "sub" is by default "our", is it not?   wondering why the "sub collect" doesn't have a "my" in front of it

[17:55] <[Coke]> gah. this is such a pita. 

[17:55] *** abnorman left
[17:56] <masak> lizmat: 'sub' is by default 'my'.

[17:56] <masak> ...in Perl 6.

[17:56] <masak> in Perl 5, it is certainly by default 'our'.

[17:56] <lizmat> ok, another false friend bites the dust

[17:56] *** stevan_ left
[17:56] <masak> lizmat: the rationale here is something like this: lower-case-letter things, like variables and sub names and keywords, are lexically scoped.

[17:57] <lizmat> I was thinking of adding some more tests for the Hash[TValue,TKey].new format

[17:57] <[Coke]> 20e

[17:57] *** lucasb joined
[17:57] <lizmat> and realize there is still no way to find out the TKey of an existing hash  :-(

[17:57] <masak> whereas upper-case things, like classes and grammars and roles, are package-scoped by default.

[17:57] <lizmat> masak++

[17:58] <masak> lizmat: having worked with lexically scoped subs for several years, I guarantee it's the right default :>

[17:58] *** stevan_ joined
[17:58] <masak> I'm not as sure about classes being 'our'-scoped by default, but hey.

[17:58] <lizmat> I think I agree with that

[17:59] <lizmat> but that is mainly an implementation problem right now

[17:59] <lizmat> class Foo { class Bar } }

[18:00] <lizmat> the Foo::Bar doesn't really exist (yet), if I remember jnthn correctly, and Bar doesn't know it has a "parent" class Foo

[18:01] <lizmat> r: class A { class B {} }; say A::B.new

[18:01] <camelia> rakudo b2072f: OUTPUT«B.new()␤»

[18:01] <lizmat> ok, it can find A::B, but since B doesn't know it lives inside of A, the object is blessed with the wrong package

[18:01] <lizmat> *name

[18:02] <masak> well, right and wrong...

[18:02] <masak> r: class A { class B {}; method foo { B.new } }; say A.foo

[18:02] <camelia> rakudo b2072f: OUTPUT«B.new()␤»

[18:02] <masak> that's completely right, IMO.

[18:02] <masak> it created a B, because "B" is what it's called inside of that package.

[18:03] <lizmat> r: class A { class B {} } say B.new

[18:03] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/JkJH9jqVtG:1␤------> [32mclass A { class B {} } [33m⏏[31msay B.new[0m␤    expecting any of:␤        statement list␤        horizontal whitespace␤        postfix␤        statement end␤        statement mo…

[18:03] <lizmat> r: class A { class B {} }; say B.new

[18:03] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    B used at line 1␤␤»

[18:03] <masak> ...but not outside of it.

[18:03] <masak> cf. relative file paths.

[18:03] <lizmat> r: class A { class B {} }; say A::B.new  # created outside

[18:03] <camelia> rakudo b2072f: OUTPUT«B.new()␤»

[18:04] <masak> *nod*

[18:04] <masak> thing is, it's the same class both time.

[18:04] <[Coke]> ok. have partcl so that it can get through test_more.tcl again - have to put the lexical handling for variables back together, but this is progress.

[18:04] <lizmat> on the other hand, it shouldn't make a difference where an object is created, or should it?

[18:04] <masak> feels weird to have stringification of the name depend on the caller's position in the code...

[18:04] <masak> lizmat: right.

[18:05] <lizmat> and I guess it doesn't for execution right now.  It's just a problem for introspection, I guess

[18:05] <masak> it feels like a conceptual problem to me.

[18:05] <masak> what *is* the right answer?

[18:06] <lizmat> I feel that it should always be A::B, regardless where the object is created

[18:07] <lizmat> class A { class B {}} # B feels like syntactic sugar for A::B to me

[18:08] <masak> ok, yes. at least that's a consistent answer.

[18:08] <lizmat> r: class A { class B {}}; class Z { class B {}; say A::B.new; say Z::B.new

[18:08] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/2UXSclFl2U:1␤------> [32m{ class B {}; say A::B.new; say Z::B.new[33m⏏[31m<EOL>[0m␤    expecting any of:␤        method arguments␤        postfix␤        stateme…

[18:08] <lizmat> r: class A { class B {}}; class Z { class B {}}; say A::B.new; say Z::B.new

[18:08] <camelia> rakudo b2072f: OUTPUT«B.new()␤B.new()␤»

[18:10] <masak> lizmat: I spoke with TimToady about this once, and he pointed me to S10:145.

[18:10] <masak> ...yes, S10. a very uncommon synopsis :)

[18:11] <xenoterracide> colomon:  thanks for the link, basically seems like an awesome idea

[18:12] <lizmat> masak: I don't think this is about globalness, because the classes are in OUR:: anyway

[18:14] * xenoterracide returns to the dark, musing about how much better and easier it woud have been to solve this problem in p6

[18:15] <lizmat> xenoterracide: take care!

[18:19] <masak> lizmat: hm, maybe.

[18:20] <lizmat> to me, it feels like a NYI…  because B still does not have a link back to A internally (jnthn told me), it can not tell the world it is actually A::B yet

[18:21] <lizmat> although practically, it already is

[18:22] *** REPLeffect left
[18:22] *** MrMeek-afk left
[18:22] *** cosimo left
[18:22] *** dalek left
[18:22] *** kst left
[18:22] *** Woodi left
[18:22] *** jferrero left
[18:22] *** simcop2387 left
[18:22] *** jferrero joined
[18:22] *** Woodi joined
[18:22] *** cosimo joined
[18:22] *** Rotwang joined
[18:22] *** MrMeek joined
[18:22] *** panchiniak joined
[18:22] *** dalek joined
[18:22] *** ChanServ sets mode: +v dalek

[18:22] *** logie joined
[18:23] *** logie_ left
[18:23] *** kst joined
[18:23] <masak> lizmat: yes, you might be right.

[18:23] <masak> lizmat: it would certainly be clearer if it said A::B.

[18:23] <masak> lizmat: I'm not as sure about this case, though:

[18:24] <masak> r: class A { my class B {}; method foo { B.new } }; say A.foo

[18:24] <camelia> rakudo b2072f: OUTPUT«B.new()␤»

[18:24] <masak> because the '::' should mean "it's in the 'our' scope of the package".

[18:25] <lizmat> even with the my, it should report as being A::B, I think

[18:25] <lizmat> the my is just so that outside, you shouldn't be able to make that object

[18:25] <lizmat> because A::B doesn't exist outside

[18:26] <lizmat> r: class A { my class B {} }; say A::B.new  # should fail

[18:26] <camelia> rakudo b2072f: OUTPUT«Could not find symbol '&B'␤  in method <anon> at src/gen/CORE.setting:10166␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in block  at /tmp/cD3ImzFIg0:1␤␤»…

[18:26] <lizmat> r: class A { my class B {}  say A::B.new } # should work

[18:26] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/JSl5tAtjfp:1␤------> [32mclass A { my class B {}  [33m⏏[31msay A::B.new } # should work[0m␤    expecting any of:␤        statement list␤        horizontal whitespace␤        postfix␤        infix stopper…

[18:26] <lizmat> r: class A { my class B {} ; say A::B.new } # should work

[18:26] <camelia> rakudo b2072f: OUTPUT«Could not find symbol '&B'␤  in method <anon> at src/gen/CORE.setting:10166␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in block  at /tmp/EiEJbwgu72:1␤␤»…

[18:26] <lizmat> hmmm….

[18:26] *** simcop2387 joined
[18:26] <lizmat> r: class A { my class B {} ; say B.new } # should work

[18:26] <camelia> rakudo b2072f: OUTPUT«B.new()␤»

[18:27] <masak> lizmat: no, I disagree. 'A::B' literally means "an our-scoped B package inside an A package".

[18:28] <masak> lizmat: note that back around 2008, the Perl 6 design was confusing our-scope and has-scope, using '::' for both. that was a bad idea.

[18:28] <masak> I think it's a bad idea to muddle 'our' scope and 'my' scope, too.

[18:28] <masak> '::' means 'our' scope.

[18:29] *** sqirrel joined
[18:29] <lue> couldn't my class B just be invisible from the outside? (That code example would work but an additional A::B.new on the outside wouldn't)

[18:29] <lizmat> ah, in that sense…    then it should be specced like that ?

[18:29] <lizmat> lue: indeed, that was my point

[18:30] <lizmat> but I can live with :: in a name indicating ourness

[18:30] <masak> lue: yes, it's already that way.

[18:30] <masak> lue: question is about how to stringify the class name.

[18:30] <lizmat> r: class A { my class A::B {} }  # does this bomb?

[18:30] <camelia> rakudo b2072f:  ( no output )

[18:31] <lue> masak: OK. I thought your disagreement was about something else.

[18:31] <lizmat> r: class A { my class A::B {} } ; say A::B.new  # does this work?

[18:31] <camelia> rakudo b2072f: OUTPUT«A::B.new()␤»

[18:31] <lizmat> intriguing, I guess the "my" is superseded by the ourness of ::

[18:32] <masak> I'd consider that a bug.

[18:32] <PerlJam> that looks like a bug to me

[18:32] * masak submits rakudobug

[18:32] <lue> r: class A { my class B {}; say B.WHAT}

[18:32] <camelia> rakudo b2072f: OUTPUT«(B)␤»

[18:34] <masak> lizmat: in a sense '::' is the ourness accessor. '.' is for has-scoped methods. '!' (within the same class) is for attributes and private methods. we have no twigil/separator for lexical access... maybe because as a rule, looking into other lexical scopes than one's own suggests a gross misunderstanding of lexical scoping, to a first approximation.

[18:35] *** census joined
[18:35] <masak> lizmat: there's an exciting special syntax: $object.MyRole::foo() where '::' doesn't mean "our-scoped". but it's clearly a special case, and quite a forgivable one, IMO.

[18:35] <masak> (it's for disambiguating when several methods with the same name might have been mixed into a class)

[18:35] <PerlJam> masak: ::($foo) doesn't imply "our" either.

[18:36] <masak> PerlJam: no, but that's prefix '::' ;)

[18:36] <masak> I was talking about infix '::'

[18:36] <PerlJam> $::($foo) then.

[18:36] <PerlJam> Looks infix to me :)

[18:36] <masak> that's a twigil :P

[18:36] <census> twigil sigil ... aaah

[18:37] <masak> census: "twigil" is short for "secondary sigil".

[18:37] <masak> census: the sigils are the one you're used to by now: $ @ % and to a lesser extent &

[18:37] <PerlJam> masak: I wonder if the specs say as clearly as you did that ":: is the ourness accessor"  ?  If not, it probably should.

[18:37] <census> i know.  i get excited when i see all of these new words to learn :)

[18:37] <masak> PerlJam: it probably doesn't.

[18:37] <census> you taught me sigil so i know that word :)

[18:38] <masak> \o/

[18:38] <pmichaud> I never thought of it as being strictly "ourness"; it just refers to the B symbol in the A package.  (I guess that's "ourness".)

[18:38] <lue> .oO(I do believe $::($foo) contains a sigil, twigil, and the elusive trigil)

[18:38] <masak> pmichaud: yes :)

[18:38] <pmichaud> I think of :: as a postfix operator at times....    A::  is A's package.

[18:38] <pmichaud> thus   A::B  is "B within A's package"

[18:39] <lizmat> pmichaud: but does that constitute "ourness" ?

[18:40] <pmichaud> well, symbols within a package are "our"

[18:40] <pmichaud> or, put another way,  "our" says that a symbol is to be defined within a package, iiuc.

[18:42] *** kaleem joined
[18:44] <lizmat> but if we don't specify "our", but *do* specify an infix :: such as A::B, would *that* make it our, or just the fact that it is a symbol defined inside a package

[18:44] <pmichaud> it makes it "our" with respect to "A"

[18:45] <pmichaud> i.e., it's the same as an "our" declaration within A's package scope.

[18:45] <pmichaud> well, an "our declaration of B"

[18:46] <pmichaud> in the case of:

[18:46] <pmichaud> 18:31 <lizmat> r: class A { my class A::B {} } ; say A::B.new  # does this work?

[18:46] <masak> oh!

[18:46] <pmichaud> I think Rakudo has it right.

[18:46] <masak> yes, so notabug.

[18:46] * masak unsubmits rakudobug

[18:46] <pmichaud> you created a class B, but you specified that it should be installed in package "A" by using "A::B"

[18:46] <PerlJam> Hmm.

[18:46] <pmichaud> thus  A::B.new works, because there's a B class inside of A's package scope.

[18:47] <nwc10> gosh, masak has backtions too

[18:47] <lizmat> r: class A { my class B {} } ; say A::B.new  # but this doesn't work

[18:47] <camelia> rakudo b2072f: OUTPUT«Could not find symbol '&B'␤  in method <anon> at src/gen/CORE.setting:10166␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in block  at /tmp/xOrWFC9S4p:1␤␤»…

[18:47] <pmichaud> correct, that doesn't work because nothing was installed in A's package.

[18:47] <pmichaud> s/installed/bound/  # more accurately

[18:48] <lizmat> ok, I think I get it now…  you need to think of classes as objects   ;-)

[18:48] <masak> nwc10: "undo" != "reverse" :P

[18:48] *** kaleem left
[18:48] <pmichaud> lizmat: yes.

[18:48] <masak> lizmat: definitely.

[18:48] <pmichaud> and also note that each class has a separate "package" component, accessed via '::'

[18:49] <pmichaud> thus  "A" is the class, while "A::" is the package associated with the class.

[18:49] <masak> r: sub are-you-an-object($o) { "yes" }; class SomeClass {}; say are-you-an-object SomeClass

[18:49] <camelia> rakudo b2072f: OUTPUT«yes␤»

[18:49] <masak> :)

[18:49] *** lucasb left
[18:50] <pmichaud> well, "SomeClass" in this instance is really a type object.  :)

[18:50] <pmichaud> we used to call them protoobjects :)

[18:50] * moritz accidentally his lilbc6

[18:50] <lizmat> his what, where, why, how?

[18:51] <moritz> I installed valgrind

[18:51] <moritz> and didn't notice I had 'testing' in my sources.list

[18:51] <moritz> so it took a new valgrind from testing, and the libc6 along with it

[18:52] <moritz> and now my perlbrew'ed perls don't work anymore

[18:52] <moritz> oh, and locales and stdio.h were missing too, for some reason

[18:52] <masak> r: sub are-you-a-type-object($o) { !$o.defined }; say are-you-a-type-object class SomeClass {}

[18:52] <pmichaud> I'm afk again a while.

[18:52] <camelia> rakudo b2072f: OUTPUT«True␤»

[18:53] <lizmat> pmichaud++

[18:53] <masak> there's supposed to be a newer way to test for type-object-ness, but I've forgotten what it is exactly.

[18:53] <pmichaud> DEFINED

[18:53] <pmichaud> I think

[18:53] <pmichaud> mebbe not

[18:53] <lue> :D and :U, perhaps?

[18:54] *** ssutch joined
[18:54] <lizmat> .DEFINITE

[18:54] <pmichaud> .DEFINITE is it.

[18:54] <pmichaud> lizmat++

[18:54] <pmichaud> afk

[18:55] <masak> r: sub are-you-a-type-object($o) { !$o.DEFINITE }; say are-you-a-type-object class SomeClass {}

[18:55] <camelia> rakudo b2072f: OUTPUT«True␤»

[18:55] <masak> \o/

[18:58] <ssutch> got some actions that work w/ my protobuf grammar! https://github.com/samuraisam/p6-pb/blob/master/lib/PB/Actions.pm

[19:03] <diakopter> ssutch: lolwut

[19:03] <yoleaux> 08:53Z <brrt> diakopter: again, they are hard, like surgery is hard, but it is doable

[19:03] *** pochi joined
[19:03] <ssutch> diakopter: ?

[19:04] *** rindolf left
[19:04] <diakopter> ssutch: just quoting from your link :)

[19:05] *** rindolf joined
[19:05] <ssutch> ah, my debug code is not very elegant with any language

[19:14] *** tomyan joined
[19:17] <dalek> specs: dc6770f | (Elizabeth Mattijsen)++ | S10-packages.pod:

[19:17] <dalek> specs: Perl 5 now *does* allow packages with block scoping

[19:17] <dalek> specs: review: https://github.com/perl6/specs/commit/dc6770f257

[19:20] <PerlJam> "Perl 5"?!?

[19:20] <PerlJam> oh

[19:20] <PerlJam> so strange to be talking about perl 5 stuff here :)

[19:22] *** rindolf left
[19:22] *** rindolf joined
[19:22] *** snearch left
[19:23] <timotimo> is it sacrilegious to drill a hole through a round tuit?

[19:23] <masak> you did WHAT?!

[19:23] <masak> :P

[19:23] *** domidumont left
[19:23] <timotimo> not yet

[19:24] <lizmat> it's fine as long as you keep the tuits rolling  :-)

[19:24] *** xenoterracide left
[19:24] <tadzik> timotimo: to carry it as a necklace?

[19:25] <timotimo> would attach it to my rucksack

[19:25] *** tomyan left
[19:25] *** stevan_ left
[19:26] <PerlJam> timotimo: The wooden nickel company sells them with holes already drilled.  You could order some like that :)

[19:26] *** DarthGandalf left
[19:27] <timotimo> i gotmine as a present though ;)

[19:27] *** DarthGandalf joined
[19:28] <masak> lizmat: would it be OK to file off the edges of a tuit, making it square?

[19:29] <lizmat> as I said, as long as you keep them rolling  :-)

[19:30] <masak> ok, so a square is out, then, I guess. :)

[19:30] <masak> but a https://en.wikipedia.org/wiki/Reuleaux_triangle should be OK...

[19:30] <lizmat> yup, that should work

[19:31] *** panchiniak left
[19:31] <timotimo> k :)

[19:34] *** vk left
[19:35] <Util> FYI, #ps meeting has started

[19:36] <labster> saw your commit, thanks timotimo++

[19:37] *** vk joined
[19:38] <timotimo> er, which?

[19:38] <labster> Cool.path

[19:38] <timotimo> oh yeah :)

[19:38] <labster> the other ones are good too

[19:38] <labster> all of them

[19:38] <timotimo> i love pleasing people with little bits of work

[19:40] <timotimo> thanks

[19:40] *** xenoterracide joined
[19:43] *** tgt left
[19:43] *** rindolf left
[19:43] *** rindolf joined
[19:45] <dalek> perl6-roast-data: dfead28 | coke++ | / (4 files):

[19:45] <dalek> perl6-roast-data: today (automated commit)

[19:45] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/dfead28350

[19:46] <[Coke]> S02-lexical-conventions/unspace.rakudo 15 - unspace with postfix pre-dot hyperops

[19:47] <timotimo> [5~compiler release is in a few days, right?

[19:47] <sorear> good * #perl6

[19:47] <[Coke]> niecza has climbed back to > 100 failures.

[19:48] <[Coke]> looks like most of the new ones are related to classify & categorize

[19:49] <dalek> rakudo-star-daily: b072e16 | coke++ | log/ (5 files):

[19:49] <dalek> rakudo-star-daily: today (automated commit)

[19:49] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/b072e16cb0

[19:49] <moritz> not surprising, since lizmat++ has cleaned up some tests there

[19:50] <timotimo> i am confused. what hyperopp test fails? i only see it in the summary not on the diff above?

[19:52] <[Coke]> timotimo: not ok 15 - unspace with postfix pre-dot hyperops

[19:52] <[Coke]> #      got: '3 4 5'

[19:52] <[Coke]> # expected: '7 8 9'

[19:52] <colomon> [Coke]: yes, lizmat thoroughly broke the classify and categorize tests for niecza

[19:53] <colomon> I started to fudge it, then decided it would probably be easier just to implement the missing functionality.

[19:54] <colomon> as I result, you should expect them to be broken for a few days.

[19:54] <colomon> :)

[19:54] <[Coke]> niecza has been dirty for 336 days. No rush. :)

[19:54] <[Coke]> coming up on a year.

[19:55] * colomon is pondering taking this, but has no idea where he'd find the time: https://www.coursera.org/course/optimization

[19:55] <masak> timotimo: yes, Rakudo release is on Thursday.

[19:56] <[Coke]> is there a planned star release, to quiet the people who expect such things?

[19:57] <timotimo> what a silly mistake

[19:57] <timotimo> i will fox it in about fifteen minutes

[19:59] * masak .oO( because the most important reason we make R* releases is to keep people quiet? ) :P

[20:01] <lue> .oO( "Is Perl 6 ready in this R* release?" )

[20:04] <huf> spec an is-ready? sub that shall forever return false

[20:04] <ssutch> is there somewhere that describes how string escapes work in perl 6

[20:04] <moritz> ssutch: http://perlcabal.org/syn/S02.html#Literals

[20:05] <masak> huf: '?' is not valid in an identifier.

[20:05] <huf> _damn_

[20:05] <masak> also, *hug*.

[20:05] <huf> i'll have to look for another character that is, and resembles ? :)

[20:05] <huf> hug?

[20:05] <moritz> ssutch: perlcabal.org/syn/S02.html#" is probably the better link

[20:06] * masak hugs huf 

[20:06] <huf> :)

[20:06] <moritz> hugme: hug masak and huf

[20:06] * hugme hugs masak

[20:06] <huf> incidentally, "hug" means "younger sister" in hungarian, and i happen to have one :)

[20:06] * masak .oO( hugarian notation )

[20:06] <huf> :)

[20:06] <huf> also <3

[20:07] <PerlJam> so ...  "hugme sisters masak"?  That's some interesting verbing

[20:08] * lue wishes git had a "timeline" command of some sort, where you could easily get the repo as it was in any commit without a series of "git checkout <hash>;git checkout master;git checkout <other hash>;..."

[20:08] <masak> r: class HeartFactory { method make { "<3" } }; loop { say HeartFactory.make }

[20:08] <flussence> er... bisect?

[20:08] <camelia> rakudo b2072f: OUTPUT«(timeout)<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤<3␤

[20:09] <huf> looks like your heart will go on

[20:09] <masak> forreva

[20:09] <huf> not 5?

[20:09] <masak> 5 is right out.

[20:09] <benabik> lue: Why are you git checkout-ing master between hashes?

[20:10] <lue> because you can't go forward in time in a detached HEAD, so far as I could tell :(

[20:10] <moritz> sure you can

[20:10] <moritz> you can just 'git log master' to find the hashes

[20:10] <lue> (without keeping a copy of `git log` from master on hand to get the SHA1 hashes)

[20:10] <masak> sure you can :)

[20:10] <masak> just go 'master~10' or whatever.

[20:11] <moritz> or you can git checkout master~15, master~10 etc.

[20:11] <lue> I think what I'd like is the opposite of HEAD^, perhaps HEAD$ :)

[20:11] <moritz> masak++ is faster :-)

[20:11] * masak .oO( master++ is fasak )

[20:11] <tadzik> :D

[20:11] <ssutch> what is .oO()

[20:11] <moritz> if git history was always linear, going ahead could work.

[20:11] <masak> ssutch: thoughts.

[20:11] <moritz> ssutch: comic thought bubbles

[20:11] <ssutch> aha

[20:11] <diakopter> fastak is maser. mastak is faser.

[20:12] <PerlJam> git is .oO( what shoud we use for serious thought bubbles? )

[20:12] <masak> lue: problem is, "first parent" is highly meaningful in git. "first child", not so much.

[20:13] <masak> r: .say for <m f> X~ <ast as> X~ <ak er>

[20:13] <benabik> master~N, master~N-1, etc is probably the best option.

[20:13] <camelia> rakudo b2072f: OUTPUT«mastak␤master␤masak␤maser␤fastak␤faster␤fasak␤faser␤»

[20:13] <lue> (it would appear to me the best option for what I want is gitk :/ . I guess I'm just being too lazy to want to count commits from master when I want to start from commit 1, or to look up SHA1 hashes)

[20:13] <benabik> Although if you're trying to find some kind of bug, git bisect is really your friend.

[20:13] <ssutch> whoa X~

[20:14] <masak> ssutch: :D

[20:14] *** twigel joined
[20:14] <moritz> the only thing where I need repeated checkouts is chasing through git blames

[20:14] <masak> ssutch: you can do Xop for any op.

[20:14] <masak> ssutch: any infix op, that is.

[20:14] <ssutch> dashot

[20:14] <masak> yah

[20:14] <moritz> r: say (1, 2, 3) X* (10, 11, 12)

[20:14] <camelia> rakudo b2072f: OUTPUT«10 11 12 20 22 24 30 33 36␤»

[20:14] <masak> r: .say for 1 X+ 100 X+ 10_000

[20:14] <camelia> rakudo b2072f: OUTPUT«10101␤»

[20:14] <masak> er :)

[20:15] <masak> r: .say for 1, 2, 3 X+ 100, 200, 300 X+ 10_000, 20_000, 30_000

[20:15] <camelia> rakudo b2072f: OUTPUT«10101␤20101␤30101␤10201␤20201␤30201␤10301␤20301␤30301␤10102␤20102␤30102␤10202␤20202␤30202␤10302␤20302␤30302␤10103␤20103␤30103␤10203␤20203␤30203␤10303␤20303␤30303␤»

[20:15] <masak> \o/

[20:15] <ssutch> hehehe

[20:15] <diakopter> r: say (my $a = 4 X= 5); say $a

[20:15] <camelia> rakudo b2072f: OUTPUT«5␤4␤»

[20:15] *** benabik left
[20:15] <diakopter> masak: ^

[20:15] <masak> diakopter: um.

[20:15] <flussence> that looks evil

[20:15] <masak> diakopter is evil. :)

[20:16] <masak> diakopter: I think it's a precedence thing.

[20:16] <masak> diakopter: = is item is tighter than X= is list.

[20:16] <masak> so, notabug.

[20:16] <flussence> n: say (my $a = 4 X= 5); say $a # I half-expect this one to explode...

[20:16] <camelia> niecza v24-78-g9f58f84: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot cross with = because list assignment operators are too fiddly at /tmp/uCi_u1U6Gw line 1:␤------> [32msay (my $a = 4 X=[33m⏏[31m 5); say $a # I half-expect this one to [0m␤␤Unhandled exception: Check failed␤␤  at /…

[20:16] <moritz> r: say (my $a = 4) X= 5; say $a

[20:16] <camelia> rakudo b2072f: OUTPUT«5␤4␤»

[20:16] <flussence> .oO( 50% of the time, I'm 100% right )

[20:16] <moritz> r: say (my $a = 4) = 5; say $a

[20:16] <camelia> rakudo b2072f: OUTPUT«5␤5␤»

[20:16] <masak> diakopter: unless you wanted that to say 5 twice...

[20:16] <moritz> just plain old rw-ness not being carried correctly

[20:16] <diakopter> r: say (my $a = (4 X= 5)); say $a

[20:17] <camelia> rakudo b2072f: OUTPUT«5␤5␤»

[20:17] <masak> so, yesabug?

[20:17] <moritz> yes

[20:17] <masak> but filedalready?

[20:17] <moritz> r: 4 X= 5

[20:17] <sorear> pmichaud: The CLA has been picked up

[20:17] <camelia> rakudo b2072f:  ( no output )

[20:17] <moritz> masak: I'm nearly sure :-)

[20:17] <moritz> iirc with X+= or so

[20:17] <masak> ok, good.

[20:17] *** tgt joined
[20:19] <diakopter> r: 4 X:= 5

[20:19] <camelia> rakudo b2072f: OUTPUT«Nominal type check failed for parameter 'op'; expected Any but got Mu instead␤  in sub METAOP_CROSS at src/gen/CORE.setting:13994␤  in block  at /tmp/cz8I3OQI1e:1␤␤»

[20:19] <nwc10> sorear: yay! http://www.collectgbstamps.co.uk/images/gb/1996/1996_1098_l.jpg

[20:19] <colomon> \o/

[20:20] *** stevan_ joined
[20:22] <dalek> roast: e121e0e | (Timo Paulssen)++ | S02-lexical-conventions/unspace.t:

[20:22] <dalek> roast: fix tests for unspace/postfix-hyper.

[20:22] <dalek> roast: review: https://github.com/perl6/roast/commit/e121e0e2de

[20:23] *** vk left
[20:28] <masak> I'd like to make y'all aware of http://mathwithbaddrawings.com/2013/06/16/ultimate-tic-tac-toe/

[20:28] <masak> for kicks, today's mini-challenge: implement this game in Perl 6.

[20:28] <masak> HN discussion: https://news.ycombinator.com/item?id=5898506

[20:28] *** tgt left
[20:30] *** preflex left
[20:31] <lue> .oO(The markers alternated *almost* every time in those 9 first pictures)

[20:31] *** preflex joined
[20:31] *** ChanServ sets mode: +v preflex

[20:33] <timotimo> so, afaict "☀".succ isn't specced to be "☁", right?

[20:34] <timotimo> rn: "☀".succ

[20:34] <camelia> rakudo b2072f, niecza v24-78-g9f58f84:  ( no output )

[20:34] <timotimo> rn: "☀".succ.say

[20:34] <camelia> niecza v24-78-g9f58f84: OUTPUT«WTF␤»

[20:34] <camelia> ..rakudo b2072f: OUTPUT«☀␤»

[20:35] <FROGGS> WTF?

[20:35] <[Coke]> niecza++

[20:35] <lue> what happened to niecza? o.o

[20:35] <flussence> it became sentient

[20:36] <tadzik> :D

[20:36] <tadzik> this is awesome

[20:37] <tadzik> niecza: do something funny

[20:37] <camelia> niecza v24-78-g9f58f84: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routines:␤    'funny' used at line 1␤ 'something' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 …

[20:37] <moritz> masak: nice game :-)

[20:38] <timotimo> r: "f".ord.say

[20:38] <camelia> rakudo b2072f: OUTPUT«102␤»

[20:38] <timotimo> r: "f".ord.succ.chr

[20:38] <camelia> rakudo b2072f:  ( no output )

[20:38] <timotimo> r: "f".ord.succ.chr.say

[20:38] <camelia> rakudo b2072f: OUTPUT«g␤»

[20:43] <timotimo> r: "foo9".succ.say

[20:43] <camelia> rakudo b2072f: OUTPUT«fop0␤»

[20:43] * [Coke] ponders a MathSymbols library that makes ÷ etc. work.

[20:44] <[Coke]> r: "÷".succ

[20:44] <camelia> rakudo b2072f:  ( no output )

[20:44] <[Coke]> r: "÷".succ.say

[20:44] <camelia> rakudo b2072f: OUTPUT«÷␤»

[20:45] * masak writes the simulation scaffolding for ELEVATOR

[20:47] <lue> Ah, just when I thought cperl-mode was manageable, it throws a lisp error when I try to type a colon (something about electric terminators, it seems)

[20:48] *** tomyan joined
[20:50] * FROGGS .oO( ecleptic you say? with a plug? )

[20:51] *** araujo left
[20:52] *** araujo joined
[20:52] *** araujo left
[20:52] *** araujo joined
[20:52] <ssutch> how is it again that you tell Grammar.parse to start from a single rule? is it Grammar.parse($text, :rule(name))

[20:52] <masak> ssutch: yeah, where name is a string.

[20:53] <masak> r: grammar G { rule foo { { die "it worked!" } } }; G.parse("", :rule<foo>)

[20:53] <camelia> rakudo b2072f: OUTPUT«it worked!␤  in regex foo at /tmp/cTkz_7LFCr:1␤  in method parse at src/gen/CORE.setting:10493␤  in block  at /tmp/cTkz_7LFCr:1␤␤»

[20:54] *** bluescreen10 left
[20:58] <ssutch> r: "\0xc3".perl

[20:58] <camelia> rakudo b2072f:  ( no output )

[20:58] <ssutch> r: "\0xc3".perl.say

[20:58] <camelia> rakudo b2072f: OUTPUT«"\x[0]xc3"␤»

[20:59] <ssutch> r: "\0xc3".gist

[20:59] <camelia> rakudo b2072f:  ( no output )

[20:59] <ssutch> r: "\0xc3".gist.say # derp

[20:59] <camelia> rakudo b2072f: OUTPUT«␀xc3␤»

[20:59] <timotimo> i have a local patch that makes diverse ranges-with-unicode-things work

[20:59] <timotimo> will do another spectest run.

[20:59] <sorear> r: say "\xC3"

[20:59] <camelia> rakudo b2072f: OUTPUT«Ã␤»

[20:59] <sorear> r: say "\x[C3]"

[20:59] <camelia> rakudo b2072f: OUTPUT«Ã␤»

[20:59] <sorear> r: say "\c[0xC3]"

[20:59] <camelia> rakudo b2072f: OUTPUT«Ã␤»

[20:59] *** tgt joined
[21:00] <ssutch> just trying to get a string literal with unicode/octal escapes from my grammar into the same thing in perl

[21:00] *** Rotwang left
[21:01] <timotimo> ssutch: i suggest "eval"

[21:02] <sorear> ssutch: i suggest "chr"

[21:02] <masak> rn: sub normal { ([+] rand xx 12) - 6 }; say normal

[21:02] <camelia> niecza v24-78-g9f58f84: OUTPUT«-0.25535927119448765␤»

[21:02] <camelia> ..rakudo b2072f: OUTPUT«0.0460164515684127␤»

[21:02] <lue> r: say "octal: \o[52] unicode char: \c[ASTERISK] or \c[42] (decimal number)"

[21:02] <camelia> rakudo b2072f: OUTPUT«octal: * unicode char: * or * (decimal number)␤»

[21:03] <ssutch> this is what im doing: make chr(:16($<xdigit>.join));

[21:03] *** pmurias joined
[21:03] <masak> this is how Wikipedia suggests I generate (an approximation of) normally distributed values.

[21:03] <pmurias> pmichaud: ping

[21:03] <ssutch> and this is what im doing for oct: make chr(:8($<digit>.join));

[21:03] <masak> easier than I thought.

[21:03] <timotimo> seriously, you have already established the text is harmless and correctly escaped. eval it to get the actual string from it

[21:03] <sorear> timotimo: except that eval is slow as hell

[21:03] <timotimo> oh?

[21:03] <timotimo> well, yeah, that's true.

[21:04] <lue> are the escape sequences the same as in P6 though?

[21:04] <sorear> and leaks memory

[21:04] <ssutch> lue: no

[21:04] <sorear> because packfile objects can't be garbage collected

[21:04] <sorear> ever

[21:04] <lue> so eval() wouldn't help too much anyway.

[21:04] <ssutch> right

[21:05] <timotimo> i'm sorry in that case

[21:05] <timotimo> carry on :)

[21:05] <ssutch> heh

[21:06] <sorear> r: grammar G { token char { <[0..7]>+ { make chr(:8($/)) } } }; say G.parse("176").ast

[21:06] <camelia> rakudo b2072f: OUTPUT«No such method 'TOP' for invocant of type 'G'␤  in method parse at src/gen/CORE.setting:10493␤  in block  at /tmp/uFjTnb7NT1:1␤␤»

[21:06] <sorear> r: grammar G { token char { <[0..7]>+ { make chr(:8($/)) } } }; say G.parse("176", :rule<char>).ast

[21:06] <camelia> rakudo b2072f: OUTPUT«Nominal type check failed for parameter '$str'; expected Str but got Match instead␤  in sub unbase at src/gen/CORE.setting:5164␤  in regex char at /tmp/mFeP4yBvYh:1␤  in method parse at src/gen/CORE.setting:10493␤  in block  at /tmp/mFeP4yBvYh:1␤␤»

[21:06] <sorear> r: grammar G { token char { <[0..7]>+ { make chr(:8(~$/)) } } }; say G.parse("176", :rule<char>).ast

[21:06] *** konundra left
[21:06] <camelia> rakudo b2072f: OUTPUT«~␤»

[21:06] <sorear> what's not working?

[21:07] <ssutch> it's working, far as i can tell

[21:09] *** sqirrel left
[21:12] *** spider-mario left
[21:15] *** zby_home joined
[21:18] *** woolfy left
[21:20] *** woolfy joined
[21:22] <ssutch> ah, so i was doing make $<str-contents-double>>>.flat.join; but i needed make $<str-contents-double>>>.flat>>.ast.join;

[21:22] *** kaare_ left
[21:24] <timotimo> i shattered one of my tuits with a prick punch ~_~

[21:26] <[Coke]> awl hell.

[21:28] <timotimo> i was told to apply a bit of a hit with a prick punch before applying the drill. turns out the grain was very unfortunately aligned with the surface

[21:29] <timotimo> n: say '▁' ... '█'  # works locally on rakudo as well

[21:29] <camelia> niecza v24-78-g9f58f84: OUTPUT«▁ ▂ ▃ ▄ ▅ ▆ ▇ █␤»

[21:30] <FROGGS> masak: not many attendees tmw :/

[21:30] <FROGGS> timotimo++

[21:30] <timotimo> https://github.com/rakudo/rakudo/pull/168 - this is the corresponding pullrequest

[21:30] <timotimo> FROGGS: i didn't notice there was different kinds of tuits so i shattered the "perl community" tuit ... very symbolic :(

[21:30] <FROGGS> hehe

[21:31] <FROGGS> timotimo: np, I maybe have spare tuits :o)

[21:32] <timotimo> s/3/2/ in my zip code, btw ~_~

[21:32] <timotimo> s:g/3/2/ even

[21:32] <FROGGS> ohh

[21:32] <masak> FROGGS: I guess most people got their fill the first time :)

[21:32] <masak> FROGGS: also, we didn't pull the reddit lever this time around.

[21:33] <masak> FROGGS: I think tomorrow will be very nice, though.

[21:33] <FROGGS> masak: yeah, I recognized

[21:33] <masak> all the more attention for those who'll show up ;)

[21:33] <FROGGS> true

[21:34] <masak> right now, I have an elevator which completely refuses to pick people up, so they all take the stairs :)

[21:34] <sorear> ach sentient elevators

[21:35] <sorear> I read a book about those once D:

[21:35] <FROGGS> okay, so it is at 8pm in our tz?

[21:35] *** pecastro joined
[21:35] <masak> like this: https://gist.github.com/masak/3ca7e6d6b06c325bdf03 :)

[21:35] <masak> FROGGS: aye. till midnight.

[21:35] <masak> hm, person Y does get tired a lot. that doesn't look right :)

[21:36] *** pecastro_ left
[21:36] <sorear> floor 0? o_O

[21:36] <masak> ah, that's better. :)

[21:36] <sorear> oh, right

[21:37] <masak> sorear: no, not sentient elevator. I simply haven't implemented the elevator yet, so conceptually it's just an empty elevator shaft.

[21:37] <lue> masak: may I ask what you're working on?

[21:37] <dalek> rakudo/nom: f0ff25b | (Timo Paulssen)++ | src/core/operators.pm:

[21:37] <dalek> rakudo/nom: implement sequences between 1-codepoint strings

[21:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f0ff25bb2c

[21:37] <dalek> rakudo/nom: ce5be8f | (Tobias Leich)++ | src/core/operators.pm:

[21:37] <dalek> rakudo/nom: Merge pull request #168 from timo/one-codept-str-sequences

[21:37] <dalek> rakudo/nom: 

[21:37] <dalek> rakudo/nom: implement sequences between 1-codepoint strings

[21:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce5be8ffea

[21:37] <masak> lue: https://github.com/masak/workshop/issues/16

[21:37] <mst> sorear: .uk does 'ground floor, 1st floor, 2nd floor' where .us does '1st floor, 2nd floor, 3rd floor'

[21:37] <sorear> mst: yeah, I remember that now (.de, but same principle)

[21:38] <masak> mst: weirdly, though, the floor numbering in my stairwell is: -1, 0, 2..6

[21:38] *** rindolf left
[21:38] <timotimo> does anyone else remember some LHF i could try to shove into the next compiler release?

[21:39] <perigrin> mst: there is one building here in town that has 1st floor, ground floor, 3rd floor ... 

[21:39] <perigrin> but it sank after they built it so ... it's unique.

[21:39] *** tomyan left
[21:39] <masak> timotimo: maybe https://rt.perl.org/rt3/Ticket/Display.html?id=118339 ?

[21:39] <sorear> how are we going to handle compiler releases with jvm?

[21:40] <sorear> '1 eqv 3' # works

[21:40] <sorear> 'use v6; 1 eqv 3' # dies in eqv

[21:41] <masak> timotimo: or https://rt.perl.org/rt3/Ticket/Display.html?id=118325 , or https://rt.perl.org/rt3/Ticket/Display.html?id=118231 , https://rt.perl.org/rt3/Ticket/Display.html?id=118063 , or https://rt.perl.org/rt3/Ticket/Display.html?id=117997

[21:41] <FROGGS> hehe

[21:41] <masak> I could go on.

[21:41] <masak> but at least one of those ought to be LHF.

[21:41] <timotimo> thank you, masak :)

[21:41] * masak kowtows

[21:43] <[Coke]> sorear: I'd like to imagine the jvm and parrot releases are cut at (near) the same time.

[21:45] <masak> me too.

[21:54] *** vk joined
[21:56] <sorear> i'm going to blame the multi dispatch cache again

[21:56] <FROGGS> :/

[21:56] <labster> timotimo is fixing all my bugs

[21:56] <sorear> yeppp

[21:56] <sorear> and it's a bug I introduced, too

[21:57] <labster> rn: say "あ" ... "お"

[21:58] <camelia> niecza v24-78-g9f58f84: OUTPUT«あ ぃ い ぅ う ぇ え ぉ お␤»

[21:58] <camelia> ..rakudo b2072f: OUTPUT«(timeout)»

[21:58] <timotimo> what does it mean for an operator that its .prec<prec> has @ or : in it?

[21:58] <FROGGS> sorear: ohh, so you are the one who does bugs?? :P

[21:58] <sorear> .oO( use iroha; )

[21:59] *** vk left
[21:59] <sorear> FROGGS: i've been fixing bugs in rak-jvm

[21:59] <FROGGS> timotimo: example?

[21:59] <FROGGS> sorear: I know, t'was a joke

[21:59] <timotimo> FROGGS: i have none, that's my problem :)

[22:00] <dalek> nqp: f3c828f | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/MultiCacheInstance.java:

[22:00] <dalek> nqp: Multi cache should be remembering the definedness of the value, not its container

[22:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f3c828f7d7

[22:00] <sorear> that fixes t/01-sanity/06-eqv.t

[22:00] <timotimo> yays! :)

[22:01] <timotimo> FROGGS: i'm not sure why i got moarvm tuits from you; were you gently nudging me in the direction of moarvm work? :3

[22:01] <FROGGS> *g*

[22:02] <FROGGS> timotimo: I just gave you one from every kind

[22:02] <timotimo> oke :)

[22:02] <timotimo> actually, two moarvm, two rakudo :)

[22:03] <FROGGS> true

[22:04] <timotimo> i don't understand how the prec thing works, why it would replace = with @= for tighter and = with := for looser

[22:04] *** pjcj left
[22:04] <sorear> nqp: my $int := 1; say(nqp::isnanorinf($int))

[22:04] <camelia> nqp: OUTPUT«0␤»

[22:04] <sorear> timotimo: because '@' lt '=' and ':' gt '=', or maybe the other way around

[22:04] *** pmurias left
[22:04] <sorear> timotimo: precs are compared as strings

[22:05] <masak> r: say sort * leg *, '@=', '=', ':='

[22:05] <camelia> rakudo b2072f: OUTPUT«:= = @=␤»

[22:05] <timotimo> oh, okay

[22:06] <sorear> nqp: my $int := 1; nqp::unbox_n($int)

[22:06] <camelia> nqp: OUTPUT«Can only use repr_unbox_num on a SixModelObject␤current instr.: '' pc 53 ((file unknown):169684796) (/tmp/8Cmdy3NYj3:1)␤»

[22:06] *** census2 joined
[22:08] <timotimo> i'd like to make div 0 create a Failure object instead of dieing, but it comes from C code and uses Parrot_ex_throw_from_c_args and I don't know about it

[22:13] <FROGGS> r: try nqp::div_i(42, 0)

[22:13] <camelia> rakudo b2072f:  ( no output )

[22:14] <sorear> just pushed a fix for array indexing.  we are now successfully running all of the files in t/01-sanity, and failing only four tests all in 99-test-basic.t

[22:14] <FROGGS> r: my $value = try nqp::div_i(42, 0); say "alive"; say $value

[22:14] <camelia> rakudo b2072f: OUTPUT«alive␤Nil␤»

[22:14] <sorear> all related to eval

[22:14] <sorear> suspect eval is broken, will investigate later

[22:14] <timotimo> r: say &infix:<%>.pred; multi infix:<%>($lhs, Str $rhs) is looser(&infix:<xx>) { $lhs.join: $rhs }; say &infix:<%>.pred;

[22:14] <camelia> rakudo b2072f: OUTPUT«No such method 'pred' for invocant of type 'Sub+{<anon>}+{Precedence}'␤  in block  at /tmp/m6bsiqZ1s7:1␤␤»

[22:15] <timotimo> r: multi infix:<%>($lhs, Str $rhs) is looser(&infix:<xx>) { $lhs.join: $rhs }; say &infix:<%>.pred;

[22:15] <camelia> rakudo b2072f: OUTPUT«No such method 'pred' for invocant of type 'Sub+{<anon>}+{Precedence}'␤  in block  at /tmp/Ow7R6fA_Tz:1␤␤»

[22:15] <FROGGS> r: my $value = (try nqp::div_i(42, 0)) || $!; say "alive"; say $value # timotimo, something like that?

[22:15] <camelia> rakudo b2072f: OUTPUT«alive␤Divide by zero␤  in block  at /tmp/EFc61I6Nm7:1␤␤»

[22:15] <timotimo> sounds like a good idea.

[22:15] <FROGGS> dunno if it is

[22:16] <FROGGS> that is some quick hack where a little pmichaud-ish voice in the back of my head screams words I dont understand

[22:16] *** zby_home left
[22:17] <timotimo> heh.

[22:17] <labster> looking at the IO stuff, it looks there is usually a catch block to produce a typed error.

[22:17] <timotimo> a spectest shall show.

[22:17] <timotimo> ah, a typed exception may be cleverer.

[22:18] <timotimo> r: my $value = (try nqp::div_i(42, 0)) || $!; say "alive"; say $value.WHAT;

[22:18] <camelia> rakudo b2072f: OUTPUT«alive␤(X::AdHoc)␤»

[22:18] <timotimo> should it do the same for /, too?

[22:18] <timotimo> r: 10 / 0;

[22:18] <camelia> rakudo b2072f:  ( no output )

[22:18] <timotimo> no, of course not. that just gets NaN

[22:19] <FROGGS> r: 10.1 / 0 # there was another issue

[22:19] <camelia> rakudo b2072f:  ( no output )

[22:19] <FROGGS> hmmm

[22:19] <labster> r: 10.1 / 0.0

[22:19] <camelia> rakudo b2072f:  ( no output )

[22:19] <FROGGS> r: 10.1 / 0e0 # there was another issue

[22:19] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:</> at src/gen/CORE.setting:3892␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in sub infix:</> at src/gen/CORE.setting:3242␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in block  at /tmp/oP5GddVEuy:1␤␤»

[22:20] <timotimo> r: try 10.1 / 0e0; say $!.WHAT

[22:20] <camelia> rakudo b2072f: OUTPUT«(X::AdHoc)␤»

[22:20] <timotimo> now i get a type check for return value

[22:21] <timotimo> because the div is written to "returns Int"

[22:21] <FROGGS> from a performance perspective: is it wiser to check for zeroness and create the failure instead on try-ing?

[22:21] <timotimo> hm, you think try is too much overhead?

[22:21] <labster> X::Numeric::DivideByZero ?

[22:22] <FROGGS> timotimo: I'd think so when looking at its ast

[22:22] <timotimo> maybe try with $! ~~ "Divide by zero" is indeed less performant than checking for 0

[22:22] <labster> I thought Failure was allowed to pass those type checks.

[22:22] <timotimo> yeah, apparently not :(

[22:23] <FROGGS> r: sub a returns Int { die "abc" }; say a.WHAT

[22:23] <camelia> rakudo b2072f: OUTPUT«abc␤  in sub a at /tmp/fUuvoyzCZQ:1␤  in block  at /tmp/fUuvoyzCZQ:1␤␤»

[22:23] <sorear> nqp::if, nqp::eq_i

[22:23] <timotimo> oh, i'll have to die $! instead of returning $! perhaps?

[22:23] <FROGGS> r: sub a returns Int { Failure.new }; say a.WHAT

[22:23] <camelia> rakudo b2072f: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at src/gen/CORE.setting:10138␤  in sub a at /tmp/c5J5M2FBkL:1␤  in block  at /tmp/c5J5M2FBkL:1␤␤»

[22:23] <sorear> actually just nqp::if

[22:23] <sorear> wait.  this will break inlining, won't it.

[22:23] <timotimo> sorear: don't i have to nqp::decont, too?

[22:24] <timotimo> is nqp::if and nqp::decont faster than just == 0?

[22:24] <sorear> timotimo: the binder automatically decontainerizes your arguments

[22:24] <sorear> unless they're marked rw, \, or copy

[22:24] <timotimo> in this case, they are \

[22:25] <timotimo> how do i nqp::if?

[22:25] <timotimo> nqp::if(b, {}, { die "foo" }); ?

[22:26] <FROGGS> r: nqp::if( 1, say(42) )

[22:26] <camelia> rakudo b2072f: OUTPUT«42␤»

[22:26] <FROGGS> r: nqp::if( 0, say(42) )

[22:26] <camelia> rakudo b2072f:  ( no output )

[22:26] <labster> sorear:  does that mean that this line has redundant unboxing: nqp::copy(nqp::unbox_s($from), nqp::unbox_s($to));

[22:26] <timotimo> r: nqp::if( 0, say(42), say("what") )

[22:26] *** dmol left
[22:26] <camelia> rakudo b2072f: OUTPUT«what␤»

[22:26] <timotimo> neat.

[22:26] <timotimo> r: nqp::if( 0, 0, say("what") )

[22:26] <camelia> rakudo b2072f: OUTPUT«what␤»

[22:27] <sorear> labster: no, boxing and containerization are different

[22:28] <labster> Huh.  I was trying to figure out why nqp::mkdir doesn't unbox its arguments, and yet still works.

[22:28] <labster> Well, maybe it does in nqp, but I mean in mkdir() in rakudo.

[22:29] <sorear> QAST automatically adds unbox opcodes when necessary for type control

[22:29] <sorear> so I guess technically you can do nqp::copy($from, $to)

[22:29] <sorear> but the generated code contains calls to Ops.unbox_s()

[22:29] <sorear> ...I'm talking about the JVM version of QAST::Compiler, take this with a grain of solt

[22:29] <sorear> salt

[22:31] <sorear> sure enough, eval("2") dies on jvm

[22:31] <timotimo> hm

[22:33] <sorear> huh.  eval is failing for the same reason the backtraces are failing: CodeRef not getting hllized

[22:34] <timotimo> r: say 10.1 / 0.0

[22:35] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:<div> at src/gen/CORE.setting:3431␤  in sub infix:<div> at src/gen/CORE.setting:3059␤  in method floor at src/gen/CORE.setting:7981␤  in method Str at src/gen/CORE.setting:7999␤  in method Str at src/gen/CORE.setting:876␤  in method gi…

[22:35] <timotimo> r: my $val = 10.1 / 0.0; say $val.WHAT; say "alive"

[22:35] <camelia> rakudo b2072f: OUTPUT«(Rat)␤alive␤»

[22:35] <timotimo> r: my $val = 10.1 / 0e0; say $val.WHAT; say "alive"

[22:35] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:</> at src/gen/CORE.setting:3892␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in sub infix:</> at src/gen/CORE.setting:3242␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in block  at /tmp/9t914SYaRH:1␤␤»

[22:35] <timotimo> ah, ok, that's because 0.0 is a Rat, but 0e0 is a Num, yes?

[22:35] <sorear> yes

[22:38] <timotimo> i can't find a test file where that could fit

[22:38] <timotimo> there isn't even a DivideByZero exception

[22:39] <FROGGS> well, you can add one

[22:39] <timotimo> sure

[22:39] <FROGGS> ahh, you mean the text you get now?

[22:39] <FROGGS> this can be in nqp or parrot

[22:39] *** pjcj joined
[22:40] <timotimo> i didn't mean that. that comes from nqp.ops, which is C/parrot code aiui

[22:44] <FROGGS> I'm sorry, I'm almost sleeping

[22:45] <timotimo> FROGGS: how much did shipping the tuits cost you btw?

[22:45] <FROGGS> I dont know, 1.45€ ? something like that

[22:46] <timotimo> hm. that's not much for deutsche post i believe

[22:47] <dalek> v5: d1ae650 | (Tobias Leich)++ | / (3 files):

[22:47] <dalek> v5: refactor identifier's ast

[22:47] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/d1ae650203

[22:47] <FROGGS> well, it is just a letter

[22:47] <timotimo> how do i return a Failure from an exception? Failure.new(X::Numeric::DivideByZero.new)?

[22:47] <timotimo> oh, with fail it seems

[22:48] <FROGGS> r: say 78900 / 40451

[22:48] <camelia> rakudo b2072f: OUTPUT«1.950508␤»

[22:48] <FROGGS> r: sub a { X::AdHoc.new( :payload<test> ) }; say a.WHAT

[22:48] <camelia> rakudo b2072f: OUTPUT«(X::AdHoc)␤»

[22:48] <FROGGS> r: sub a { X::AdHoc.new( :payload<test> ) }; say a

[22:48] <camelia> rakudo b2072f: OUTPUT«test␤␤Error while creating backtrace: No such method 'backtrace' for invocant of type 'Any'␤  in method new at src/gen/CORE.setting:8731␤  in method new at src/gen/CORE.setting:8728␤  in method backtrace at src/gen/CORE.setting:8865␤  in code  at src/gen/CORE.setti…

[22:49] <timotimo> r: sub a { fail X::AdHow.new( :payload<test> ) }; say a

[22:49] <camelia> rakudo b2072f: OUTPUT«Could not find symbol '&AdHow'␤  in method <anon> at src/gen/CORE.setting:10166␤  in any  at src/gen/Metamodel.nqp:2504␤  in any find_method_fallback at src/gen/Metamodel.nqp:2492␤  in any find_method at src/gen/Metamodel.nqp:939␤  in sub a at /tmp/aJ_tV7Gcuu:1␤  i…

[22:49] <timotimo> r: sub a { fail X::AdHoc.new( :payload<test> ) }; say a.WHAT

[22:49] <camelia> rakudo b2072f: OUTPUT«(Failure)␤»

[22:49] <timotimo> r: sub a { fail X::AdHoc.new( :payload<test> ) }; say a

[22:49] <camelia> rakudo b2072f: OUTPUT«test␤  in method gist at src/gen/CORE.setting:10161␤  in method gist at src/gen/CORE.setting:893␤  in sub say at src/gen/CORE.setting:11047␤  in block  at /tmp/ePH1OeQI22:1␤␤»

[22:49] <timotimo> r: sub a { fail X::AdHoc.new( :payload<test> ) }; say a; say alive

[22:49] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    alive used at line 1␤␤»

[22:49] <timotimo> r: sub a { fail X::AdHoc.new( :payload<test> ) }; say a; say "alive"

[22:49] <camelia> rakudo b2072f: OUTPUT«test␤  in method gist at src/gen/CORE.setting:10161␤  in method gist at src/gen/CORE.setting:893␤  in sub say at src/gen/CORE.setting:11047␤  in block  at /tmp/A8Svh5MpFw:1␤␤»

[22:49] <timotimo> mhm.

[22:53] <dalek> nqp: 6a5fb75 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[22:53] <dalek> nqp: foreign_transform_code was omitted from hllconfig setup, fixed.

[22:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6a5fb757bc

[22:53] <sorear> unless I've broken something new, we are now passing all of t/01-sanity/*.t

[22:53] <timotimo> oh yeah! :)

[22:53] <timotimo> and backtraces will now work, too?

[22:53] <FROGGS> wow, sorear++

[22:53] <sorear> timotimo: testing now

[22:53] <sorear> no.

[22:54] <timotimo> aaw. well, still impressive :)

[22:55] <FROGGS> gnight all

[22:55] *** FROGGS left
[22:56] *** btyler left
[23:00] <pmichaud> was there discussion on pull request 168?

[23:00] <timotimo> pmichaud: only on irc

[23:00] <pmichaud> looking

[23:01] <timotimo> well, only about the things it should do; yesterday at about the same time as now today

[23:01] <timotimo> not between my proposing the PR and it being merged

[23:01] <pmichaud> I had already fixed it.

[23:01] <timotimo> you ... had?

[23:02] * timotimo looks

[23:02] <pmichaud> well, I had fixed the block case.

[23:02] <timotimo> ah

[23:02] <pmichaud> The single-character case... I want to see the spec for it.

[23:03] <timotimo> ah, my pull request was about any-one-codepoint-unicode-strings for both endpoints

[23:03] <timotimo> i'll dig it up for you real quick

[23:03] <timotimo> there are test cases for it, fwiw

[23:03] <pmichaud> looking

[23:04] <pmichaud> okay, found the spec instance

[23:04] *** fgomez joined
[23:04] <timotimo> ah, good

[23:04] <sorear> pmichaud: hi

[23:04] <pmichaud> I don't like the "unisuccpred" method, though.

[23:04] <pmichaud> seems like the sequence operator ought to just use the closure directly.

[23:05] <pmichaud> for that matter, I'm not a fan of 'succpred' either.

[23:05] * pmichaud looks

[23:05] <timotimo> it's definitely not optimized (it shouldn't go through .ord.succ.chr

[23:05] <timotimo> but it does use the closure that's returned from succpred

[23:05] <timotimo> rather than go through it on every iteration

[23:05] <timotimo> if i understand you correctly

[23:05] <pmichaud> hmmmm

[23:06] <pmichaud> okay, I read it wrong the first time.

[23:06] <pmichaud> still looking.

[23:07] <pmichaud> okay, on re-look I can accept this patch.

[23:07] <pmichaud> still might want some refactoring but it'll work for now :)

[23:08] <timotimo> do you have an intuition where the "current" ordinal value could be stored, so that internally it can just increase the ords and create the chrs only each step of the way?

[23:08] *** ajr_ left
[23:08] <timotimo> that's the refactoring that would be obvious to me

[23:10] <timotimo> is there a way in perl6 to specify "when decoding this file using utf8, please insert the replacement character on error rather than exploding"?

[23:11] <pmichaud> (current ordinal value)   at the moment I think that'd be a premature optimization

[23:11] <timotimo> OK

[23:11] <pmichaud> the sequence operator needs some reworking anyway, and perhaps we need to refactor given/take, so I'd not put too much effort into making it overly efficient.

[23:12] <pmichaud> but clearly the closure that is returned by unipredsucc can reference any local variable it wants :)

[23:13] <timotimo> i'm confused about my failure things. if i call fail from a sub, it should return from the sub, giving a Failure object as result, yes?

[23:14] <sorear> pmichaud: how paranoid should I be about not breaking the parrot build while I hack jvm?

[23:14] *** census2 left
[23:14] <timotimo> could "returns Int" cause a Int.new to be called on the return value?

[23:14] <sorear> should I make a jvm branch and merge it daily after testing on parrot, or so?

[23:14] <timotimo> r: sub foo returns Int { fail "what" }; foo;

[23:14] <camelia> rakudo b2072f: OUTPUT«what␤  in method sink at src/gen/CORE.setting:10169␤  in method BUILDALL at src/gen/CORE.setting:801␤  in method bless at src/gen/CORE.setting:743␤  in method new at src/gen/CORE.setting:728␤  in method new at src/gen/CORE.setting:726␤  in sub foo at /tmp/DzU42RSGh…

[23:14] <timotimo> r: sub foo { fail "what" }; foo;

[23:14] <camelia> rakudo b2072f: OUTPUT«what␤current instr.: 'throw' pc 347557 (src/gen/CORE.setting.pir:151689) (src/gen/CORE.setting:8887)␤called from Sub 'sink' pc 379739 (src/gen/CORE.setting.pir:164183) (src/gen/CORE.setting:10169)␤called from Sub 'MAIN' pc 381 (src/gen/perl6.pir:147) (src/main.nqp …

[23:15] <timotimo> yeah, that seems to be it

[23:15] <timotimo> i don't want to get rid of "returns Int" :(

[23:15] <pmichaud> sorear: be fairly paranoid about breaking the parrot build.

[23:17] <pmichaud> timotimo: there's a (known) bug there.  Type checking return values is supposed to be transparent to failure objects.

[23:17] <timotimo> mhm

[23:17] <timotimo> should i remove the "returns" and add an # XXX?

[23:17] <pmichaud> if you like.

[23:17] <sorear> pmichaud: mmk

[23:17] <timotimo> does it seem like a big undertaking to fix the return value typechecks?

[23:17] <pmichaud> (parrot build)  we have to make sure that that the compiler continues to pass spectests on parrot; i.e., we don't want any regressions in the main branch

[23:18] *** konundra joined
[23:19] <timotimo> unfortunately i have no idea where to look >_>

[23:22] <sorear> will TPF tell me when they get the CLA?

[23:22] <sorear> pmichaud: does it seem reasonable to make a jvm-bugfixes branch, then spectest it and merge it every day or so?

[23:25] <timotimo> what is 0/0 and 0 div 0 supposed to give?

[23:25] <timotimo> rn: say 0/0;

[23:25] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:<div> at src/gen/CORE.setting:3431␤  in sub infix:<div> at src/gen/CORE.setting:3059␤  in sub DIVIDE_NUMBERS at src/gen/CORE.setting:8088␤  in sub infix:</> at src/gen/CORE.setting:8220␤  in sub infix:</> at src/gen/CORE.setting:3054␤ …

[23:25] <camelia> ..niecza v24-78-g9f58f84: OUTPUT«0␤»

[23:25] <timotimo> rn: say 0 div 0;

[23:25] <camelia> niecza v24-78-g9f58f84: OUTPUT«Unhandled exception: System.DivideByZeroException: Division by zero␤  at Builtins.divop (Niecza.Constants c, Int32 opc, Niecza.Variable a1, Niecza.Variable a2) [0x00000] in <filename unknown>:0 ␤  at CORE.cbe06ccd-d537-4516-b9ac-0ee3fe3f1675.C1472infix:<di…

[23:25] <camelia> ..rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:<div> at src/gen/CORE.setting:3431␤  in sub infix:<div> at src/gen/CORE.setting:3059␤  in block  at /tmp/i3yfqxPuaw:1␤␤»

[23:27] <sorear> timotimo: how about 31415926

[23:27] *** benabik joined
[23:28] <sorear> hmm, small problem with the lexotics.  they get null stables, so decontainerization blows up when you try to call one

[23:31] <timotimo> i wonder if it would be beneficial to add multi candidates where the second argument is fixed at 0

[23:31] <timotimo> rather than check for 0 inside the body of the sub

[23:32] <sorear> no

[23:32] <timotimo> oke

[23:32] <sorear> that would completely disable the multidispatch cache :/

[23:32] <timotimo> well, anyway... that's what my code does now and i'm ready to issue a PR

[23:32] <pmichaud> sorear: (jvm-bugfix-branch)   sure, branch+merge is generally a sound strategy

[23:33] <timotimo> i'd be interested for someone to tell me where exactly to place tests for that exception & behavior

[23:33] <timotimo> is it okay to use X::Numeric::DivisionByZero for both div and /? because one is for Num and the other for Int ...

[23:35] <sorear> pmichaud: TPF-CLA-feedback?

[23:35] <sorear> timotimo: yes, imo

[23:35] <sorear> actually I'd kind of prefer dividing a Num by zero to return Inf

[23:35] <sorear> in accordance with the standard IEEE 754 semantics

[23:36] <timotimo> r: say 10 / 0.Num;

[23:36] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:</> at src/gen/CORE.setting:3892␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in sub infix:</> at src/gen/CORE.setting:3242␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in block  at /tmp/KfqEoXKkaR:1␤␤»

[23:36] <timotimo> i can make it do that, sure. +Inf and -Inf i suppose?

[23:36] <timotimo> r: say (-0).perl

[23:36] <camelia> rakudo b2072f: OUTPUT«0␤»

[23:36] <timotimo> r: say (-0e0).perl

[23:36] <camelia> rakudo b2072f: OUTPUT«-0e0␤»

[23:36] <sorear> r: say 1 / 1e-309

[23:36] <camelia> rakudo b2072f: OUTPUT«Inf␤»

[23:36] <sorear> r: say 0

[23:36] <camelia> rakudo b2072f: OUTPUT«0␤»

[23:36] <sorear> r: say 1 / 0

[23:37] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:<div> at src/gen/CORE.setting:3431␤  in sub infix:<div> at src/gen/CORE.setting:3059␤  in method floor at src/gen/CORE.setting:7981␤  in method Str at src/gen/CORE.setting:7999␤  in method Str at src/gen/CORE.setting:876␤  in method gi…

[23:37] <timotimo> 0 is a Rat though

[23:37] <sorear> r: say 1 / 0e0

[23:37] <camelia> rakudo b2072f: OUTPUT«Divide by zero␤  in sub infix:</> at src/gen/CORE.setting:3892␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in sub infix:</> at src/gen/CORE.setting:3242␤  in sub infix:</> at src/gen/CORE.setting:3054␤  in block  at /tmp/sPwuYk4Ne5:1␤␤»

[23:37] <sorear> / already returns Inf if you overflow a Num

[23:37] <timotimo> indeed. it would be sensible.

[23:37] <sorear> (see what I did there, passing a denormal? >_>)

[23:38] <pmichaud> sorear: there's not normally direct feedback from TPF to you, but they'll often tell me when a CLA arrives and update the shared spreadsheet, so I'll let you know when it comes in.

[23:38] <pmichaud> (assuming I hear about it)

[23:38] <timotimo> pmichaud: ideas about division by num-0?

[23:38] <sorear> pmichaud: great

[23:38] <ssutch> r: say -Inf

[23:38] <camelia> rakudo b2072f: OUTPUT«-Inf␤»

[23:38] <timotimo> should it also return Inf if i divide by rat-0?

[23:38] <pmichaud> timotimo: I think the spec indicates it returns failure.

[23:38] <ssutch> r: say Nan

[23:39] <camelia> rakudo b2072f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    Nan used at line 1␤␤»

[23:39] <ssutch> r: say NaN

[23:39] <camelia> rakudo b2072f: OUTPUT«NaN␤»

[23:39] <pmichaud> actually, the spec is somewhat specific here.

[23:40] <timotimo> do you have a linky for me?

[23:40] <pmichaud> http://perlcabal.org/syn/S03.html#Multiplicative_precedence

[23:41] *** mrallen1 joined
[23:41] <pmichaud> if either arg is Num, then a divisor of zero results in +/- Inf or NaN

[23:41] <timotimo> ah, good.

[23:41] <timotimo> i need to handle +/-0 there specifically?

[23:41] <timotimo> i mean, 1 / +0 vs 1 / -0?

[23:42] <pmichaud> from S03:  "Note however that these are not actually the native IEEE non-numbers, they are undefined values of the "unthrown exception" type....

[23:42] <timotimo> r: say NaN ~~ Failure;

[23:42] <camelia> rakudo b2072f: OUTPUT«False␤»

[23:42] <timotimo> so ... fail NaN?

[23:42] <sorear> bah Failure

[23:42] * sorear puts the jvm stuff on hold for today

[23:43] <pmichaud> r: say NaN.defined

[23:43] <camelia> rakudo b2072f: OUTPUT«True␤»

[23:44] <timotimo> how about i inch the implementation a bit closer to the spec now by turning the div by zero into a soft exception and later (probably tomorrow, perhaps after the compiler release) turn it into proper +/-Inf and NaN?

[23:44] *** mrallen1 left
[23:44] *** cooper left
[23:44] <pmichaud> soft exception is okay

[23:44] <pmichaud> not exactly sure what a "proper +/-Inf and NaN" are, or if Rakudo has those yet :)

[23:45] <pmichaud> r: say -Inf.defined

[23:45] <camelia> rakudo b2072f: OUTPUT«-1␤»

[23:45] <timotimo> wait what? :)

[23:45] <pmichaud> uhhhhhhhhhh

[23:45] <timotimo> hahaha :)

[23:45] <timotimo> r: say (-Inf).defined

[23:45] <camelia> rakudo b2072f: OUTPUT«True␤»

[23:45] <pmichaud> thus my point :)

[23:45] <pmichaud> ah, yes.

[23:45] <timotimo> r: say (-1...1).perl

[23:45] <camelia> rakudo b2072f: OUTPUT«(-1, 0, 1).list␤»

[23:45] <timotimo> mhm, mhm.

[23:46] <pmichaud> anyway, there's still some slushiness in the implementation and definition of Inf and NaN that needs some freezing up

[23:48] <masak> 'night, #perl6

[23:49] <timotimo> mhm

[23:50] <sorear> o/ masak

[23:53] <timotimo> looking forward to coming home to an apartment heated up by the repeated compiles and spectests run on the machine in it >_<

[23:55] <timotimo> now i get a division by zero when building the RESTRICTED.setting m)

[23:56] *** risou_awy is now known as risou

