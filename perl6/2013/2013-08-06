[00:00] <japhb_> Sweet.

[00:01] <timotimo> in^H^H^H^Hindeed it is!

[00:01] <japhb_> Looking through those graphs, I was going "so where does it differ?"  And then I came to postwhile_nil_native ...

[00:02] <diakopter> where does it differ from what

[00:02] <diakopter> oh, the previous build

[00:02] <japhb_> Holy crap, trim_string got a lot better!

[00:03] <japhb_> Tight native loops makes sense, but that's a nice improvement on something "larger"

[00:03] <diakopter> I don't see man-or-boy on there

[00:03] <segomos> IO::Socket::INET differs for jvm vs parrot?

[00:03] <diakopter> oh there's man-or-boy

[00:03] <diakopter> segomos: I don't see a socket test

[00:04] *** dayangkun joined
[00:04] <segomos> diakopter: sorry i didn't mean to type that here, i'm getting .send method not available errors and trying to track down if it's the way that i built rakudo or actually a bug ;)

[00:04] <diakopter> likely a bug.

[00:04] <jnthn> segomos: Unless somebody sneaked it in, sockets ain't in place on JVM yet.

[00:05] <segomos> jnthn: ahh, okay thanks

[00:05] <jnthn> segomos: I may get to that in the next days...

[00:05] <timotimo> japhb_: i have no sensible explanation for for trim_string getting better

[00:05] <timotimo> u

[00:05] <segomos> jnthn: if you point me in the right direction on where to even start i wouldn't mind submitting some stuff

[00:08] <japhb_> timotimo: Improvement in just this line? https://github.com/rakudo/rakudo/blob/nom/src/core/Str.pm#L767

[00:11] <timotimo> oh. yes, could be.

[00:17] <grondilu> std:  use java::lang::System:from<java>;

[00:17] <camelia> std c2215f0: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot locate module java::lang::System at /tmp/Cd5PUUKuR6 line 1:␤------> [32muse java::lang::System:from<java>[33m⏏[31m;[0m␤Check failed␤FAILED 00:00 41m␤»

[00:18] *** logie left
[00:21] *** xinming left
[00:21] *** fridim_ joined
[00:25] *** xinming joined
[00:28] *** Rotwang left
[00:35] <ruoso> hey

[00:35] <yoleaux> 5 Aug 2013 07:37Z <jnthn> ruoso: the next/last handlers for while loop are emitted as part of code generation, that is a QAST::Op while (and until, repeat_while and repeat_until) gets them "for free". MapIter handles them for for loops and contains a Parrot-specific version as well as a generic version of the looping code that JVM uses.

[00:37] <ruoso> jnthn: so, from my experiments, it seems that "take" changes something in the state of the control exception such that a "last" after a "take" make the exception to leak to main

[00:37] <ruoso> but I have to admit that I haven't still find a proper way to debug this

[00:39] <jnthn> ruoso: Well, I guess there is a continuation take/resume between the two

[00:40] <ruoso> yeah... sure...

[00:40] <ruoso> but it seems that last behaves strangely only after a take/resume

[00:40] <ruoso> r: say gather loop { take 1; last }

[00:40] <camelia> rakudo df814a: OUTPUT«1␤»

[00:41] <ruoso> that simple test breaks in the jvm rakudo

[00:42] <ruoso> I if try the take without a last and a last without a take, they work fine

[00:45] <ruoso> but what is really blocking me is that I haven't found a productive way of debugging it...

[00:48] *** LlamaRider joined
[00:49] <LlamaRider> holla #perl6

[00:49] <jnthn> ruoso: I'm afraid I've not got many hints there...I'm not that familiar with the inner workings of the continuation bits yet

[00:51] *** arcterus joined
[00:51] <dalek> nqp: c9a07ec | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/BootJavaInterop.java:

[00:51] <dalek> nqp: Support loading classes from an explicit JAR.

[00:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c9a07ec3f8

[00:51] <LlamaRider> I am trying to get NQP on JVM going for the first time and sadly my "make test" failed on what seem two easy tests (passing a large bunch of tests beforehand).

[00:51] <LlamaRider> where should I seek help? :)

[00:51] *** hypolin joined
[00:52] <ruoso> jnthn: it would probably be easier if there was a way to (maybe as a compile-time-switch) revert to generating the exceptions lazily...

[00:52] <jnthn> LlamaRider: Here; which test file was it? 

[00:52] <LlamaRider> t/jvm/06-sprintf.t

[00:52] <jnthn> Ah...

[00:52] <dalek> rakudo/use-from-java: 73b6583 | jnthn++ | src/vm/jvm/Perl6/JavaModuleLoader.nqp:

[00:52] <dalek> rakudo/use-from-java: Give :from<java> support for a :jar<...> also.

[00:52] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/73b6583d96

[00:53] <jnthn> I think FROGGS or colomon are most likely to know about that...I highly doubt that it means you'll have problems overall, though.

[00:53] <LlamaRider> one of the failures looks harmless the other however...

[00:55] *** cognominal left
[00:55] *** thou joined
[00:55] <LlamaRider> https://gist.github.com/dginev/6161094

[00:55] <LlamaRider> the first error looks troubling

[00:57] <LlamaRider> I will brave a make install and expect meeting dragons on Rakudo's make test =)

[00:58] *** [particle]1 joined
[01:06] <jnthn> sleep time; 'night

[01:07] <LlamaRider> g'night jnthn! Rakudo's make test just passed, things are looking up :)

[01:15] *** segomos left
[01:15] *** segomos joined
[01:16] *** grondilu left
[01:19] *** Mouq left
[01:20] *** LlamaRider left
[01:21] *** raiph left
[01:23] *** benabik joined
[01:30] *** cooper left
[01:38] *** cooper joined
[01:38] *** cooper left
[01:38] *** cooper joined
[01:49] *** arcterus left
[01:53] *** raiph joined
[01:56] *** LlamaRider joined
[01:59] *** logie joined
[02:00] <timotimo> my laptop likes to freeze and reboot when it experiences shaking :|

[02:01] * timotimo hopes an interrupted yum update doesn't do damage

[02:04] <timotimo> apparently it didn't damagy my system in any obvious way

[02:10] <LlamaRider> You were lucky no kernel updates were being performed

[02:10] <timotimo> er ... actually no.

[02:10] <timotimo> i do believe i have two kernels to choose from in my grub

[02:12] <LlamaRider> what I meant is that the interrupt wasn't in the middle of a kernel upgrade

[02:12] <LlamaRider> then the newer one would've ended up broken

[02:12] <LlamaRider> it's nothing lethal in any case, but you would have had to manually clean up after it

[02:13] *** Vlavv left
[02:15] *** jaldhar joined
[02:18] <timotimo> probably would have been enough to just reinstall the kernel

[02:18] *** cognominal joined
[02:31] *** logie left
[02:41] *** fridim_ left
[02:42] *** LlamaRider left
[02:47] *** pecastro left
[02:52] *** pecastro joined
[02:58] *** berekuk left
[03:10] *** wtw_ joined
[03:13] *** wtw left
[03:20] *** colomon left
[03:21] *** preflex_ joined
[03:21] *** ChanServ sets mode: +v preflex_

[03:22] *** preflex left
[03:22] *** preflex_ is now known as preflex

[03:42] *** raiph left
[03:52] *** arcterus joined
[04:07] *** raiph joined
[04:12] *** logie joined
[04:24] *** BenGoldberg left
[04:25] *** Mouq joined
[04:29] <moritz> \o

[04:29] <yoleaux> 5 Aug 2013 21:56Z <lizmat> moritz: please check df814a2, it was needed to fix many spectests, but fear it is not the solution you had in mind

[04:29] <moritz> wtf

[04:32] *** jaldhar left
[04:33] <moritz> what makes X::Comp fatal where Exception isn't fatal?

[04:35] *** jaldhar joined
[04:41] *** Mouq left
[04:51] *** birdwindupbird joined
[05:02] *** logie left
[05:09] *** zby_home_ joined
[05:23] *** raiph left
[05:23] *** SmokeMac_ left
[05:27] *** zby_home_ left
[05:28] *** raiph joined
[05:29] *** benabik left
[05:30] *** benabik joined
[05:36] *** konundra left
[05:36] *** arcterus left
[05:42] *** SmokeMachine joined
[05:47] *** dayangkun left
[05:49] *** zby_home_ joined
[05:52] *** konundra joined
[05:58] <moritz> r: 1 1

[05:58] <camelia> rakudo df814a: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/B1LeJFRLFF␤Two terms in a row␤at /tmp/B1LeJFRLFF:1␤------> [32m1 [33m⏏[31m1[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statem…

[05:59] <moritz> I don't understand how that can still work after lizmat++'s patch

[05:59] <JimmyZ> hi

[05:59] <moritz> $r ~= "$red==={$clear}SORRY!$red===$clear Error while compiling $.filename\n";

[06:00] <moritz> but $.filename comes from X::Comp

[06:00] <moritz> and this is X::Comp::Group, which no longer does X::Comp

[06:00] <moritz> hi JimmyZ 

[06:00] *** grondilu joined
[06:00] <moritz> oh, there are two instances that generate the SORRY

[06:13] *** JimmyZ left
[06:13] *** JimmyZ joined
[06:15] *** Mouq joined
[06:17] <dalek> rakudo/nom: f5bfa78 | moritz++ | src/core/Exception.pm:

[06:17] <dalek> rakudo/nom: remove one usage of $.filename that now might not work anymore

[06:17] <dalek> rakudo/nom: 

[06:17] <dalek> rakudo/nom: but the usual code path seems to go through X::Comp.sorry_heading anyway

[06:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5bfa78268

[06:19] *** SmokeMachine left
[06:22] *** SmokeMachine joined
[06:34] *** grondilu left
[06:36] *** grondilu joined
[06:37] *** konundra left
[06:37] *** zby_home_ left
[06:50] *** dmol joined
[07:24] *** crab2313 joined
[07:25] *** dmol left
[07:30] *** Bucciarati left
[07:33] *** leont joined
[07:34] *** crab2313 left
[07:35] *** crab2313 joined
[07:36] *** Bucciarati joined
[07:36] *** avar joined
[07:37] *** groky joined
[07:40] *** ssutch left
[07:46] <lizmat> github down ?

[07:46] <lizmat> oh, eh, good *, #perl6!

[07:47] <lizmat> indeed: https://status.github.com

[07:57] *** sqirrel joined
[07:59] *** crab2313 left
[08:04] *** fhelmberger joined
[08:11] *** crab2313 joined
[08:13] *** xinming left
[08:15] *** xinming joined
[08:16] *** dmol joined
[08:17] *** leont left
[08:19] *** kaleem joined
[08:32] <jnthn> morning o/

[08:33] <JimmyZ> morning, jnthn

[08:34] *** Mouq left
[08:41] *** dakkar joined
[08:47] *** sqirrel left
[08:48] <dalek> Perlito: 21f1282 | (Flavio S. Glock)++ | t5/01-perlito/ (80 files):

[08:48] <dalek> Perlito: Perlito5 - renumber tests

[08:48] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/21f128253b

[08:52] *** iSlug joined
[08:56] *** iSlug left
[08:56] *** Vlavv joined
[08:58] *** jeff_s1 left
[09:00] *** jeff_s1 joined
[09:05] *** pmurias joined
[09:05] *** daxim joined
[09:05] <dalek> rakudo-js: 1c4c59d | (Pawel Murias)++ | / (3 files):

[09:05] <dalek> rakudo-js: Handle QAST::BVal properly by always making it emit a reference.

[09:05] <dalek> rakudo-js: 

[09:05] <dalek> rakudo-js: Create all the cuids as empty code refs before deserializing objects.

[09:05] <dalek> rakudo-js: Fill them in with static versions and update when possible.

[09:05] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/1c4c59d2c5

[09:10] <mathw> morning #perl6

[09:10] <masak> antenoon, #perl6

[09:11] <frettled> Github claims to be in working order now.

[09:11] <jnthn> antomorn, masak

[09:11] <frettled> good $timeofday everyone :)

[09:13] *** FROGGS joined
[09:14] * mathw wonders how long before the cleverness in greetings gets completely out of hand and destroys the universe

[09:15] <FROGGS> hi all

[09:15] <mathw> FROGGS++ # saved the universe

[09:15] <FROGGS> :o)

[09:17] <frettled> mathw: given that cleverness in greetings on #perl6 is at the same level as in 2007 or so, I think we don't need to worry for a long, long time :)

[09:20] <mathw> yeah maybe, I tend to be over-dramatic when I'm hungry

[09:20] <masak> frettled: well, that's the deviousness of exponentially worsening cleverness.

[09:21] <frettled> masak: it's becoming clever so fast that it seems ordinary!

[09:21] <masak> frettled: eventually we'll hit a hard-takeoff greeting cleverness singularity, and... foom.

[09:21] <frettled> any sufficiently advanced cleverness is indistinguishable from stupidity

[09:22] <nwc10> has anyone made greeting obfuscations and fed them to the evalbot?

[09:22] <FROGGS> jnthn: how do you implement it, use ... :from<java> or .... :from<Java> ?

[09:23] <jnthn> FROGGS: use java::lang::System:from<java>

[09:23] <FROGGS> jnthn: I'm asking because I'd prefer :from<Perl5> instead of the lc version, and I'd prefer :from<PHP> over :from<php>

[09:23] <FROGGS> because this is more about that language rather than the interpreter-binary

[09:24] <jnthn> hmm

[09:24] <jnthn> Does the spec have an opinion? :)

[09:24] * jnthn somehow prefers it in lowercase...

[09:24] <FROGGS> lemme check

[09:24] <FROGGS> hmmm, S11 has :from<perl5> but :from<C>

[09:25] <jnthn> bah

[09:25] <jnthn> We could just make it case insensitive :S

[09:25] <jnthn> *:D

[09:25] <FROGGS> >.<

[09:26] <FROGGS> *shudder*

[09:26] <jnthn> .oO( my hands know better than my head on that idea, apparently :P )

[09:26] <FROGGS> hehe

[09:26] <FROGGS> (jnthn's-hands)++

[09:28] * masak .oO( you case insensitive clod! )

[09:29] <mathw> case-insensitivity makes me unhappy

[09:29] * moritz read "case insensitive cloud"

[09:29] <mathw> too many bad memories of dealing with the filesystem on Windows

[09:29] <jnthn> mathw: I think case-insensitivity is the last of its problems :P

[09:30] <jnthn> *least

[09:30] <FROGGS> meh, somewhere in the spec was an example ov eval() where one could pass the language... can't find it now

[09:31] *** iSlug joined
[09:31] <mathw> jnthn: that was the one that always annoyed me though, largely due to what happens when string comparison inside your code meets user expectations of case-insensitivity

[09:31] <FROGGS> just this: S29-functions.pod: multi eval ( Str|Buf $code, Grammar :$lang = CALLER::<$?PARSER>)

[09:31] <jnthn> mathw: ah :)

[09:34] *** araujo left
[09:39] *** Rotwang joined
[09:39] <masak> FROGGS: interesting how it always supplies a Grammar, and thinks that that's the whole language.

[09:39] <FROGGS> true

[09:39] <masak> (you'd need at least an Actions and a World to parse Perl 6)

[09:40] <FROGGS> same goes for setting $~LANG (or was it $~MAIN?), which refers to a grammar and hoping that is it...

[09:41] <FROGGS> that is why I am proposing setting %*LANG{ $name } and %*ACTIONS{ $name }, and set $*MAIN to your slang in your slang module

[09:42] <FROGGS> the other thing is, do other slangs want to just nibble to their statementlist too when switching to it?

[09:42] *** iSlug left
[09:44] <FROGGS> otherwise we should invent a Slang class, which has an action- and grammar-attribute

[09:44] <FROGGS> (for the first issue)

[09:44] <FROGGS> sorry, my thoughts are stored in a hash

[09:45] <FROGGS> lunch &

[09:46] *** celesta joined
[09:46] <pmurias> jnthn: case insensitivity seems like a bad idea

[09:46] <celesta> ahoi  #perl6

[09:47] <pmurias> hello

[09:52] *** crab2313 left
[09:52] *** crab2313 joined
[09:58] *** crab2313 left
[09:59] *** crab2313 joined
[09:59] <mathw> who invented ORMs?

[09:59] <mathw> And is there a better way?

[10:01] *** fhelmberger left
[10:01] *** fhelmberger joined
[10:02] <jnthn> mathw: The better way probably involves not having a rdbms be The Only Option for persisting stuff, but picking something that fits the domain :)

[10:03] <mathw> See that's odd, because often I find the rdbms fits the domain very nicely but the ORM then prevents me from using it properly.

[10:06] <jnthn> Well, I guess the Obvious Alternative is to keep any DB-related logic out of the code and do everything through SPs, table-value functions, etc.

[10:06] <mathw> yeah

[10:06] <jnthn> ORMs are a weird thing anyway.

[10:07] <jnthn> The point of a relational database is that you know the fields and write queries over them

[10:07] <mathw> I don't think there are any truly good answers, and I may be more annoyed with ORMs than usual due to having to compromise my schema for NHibernate's sake

[10:07] <jnthn> The point of an object is you encapsulate the fields and expose behavior

[10:07] <dalek> Perlito: 17fd35a | (Flavio S. Glock)++ | t5-bug/410-ampersand.t:

[10:07] <dalek> Perlito: Perlito5 - tests

[10:07] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/17fd35aabc

[10:07] <jnthn> So they're not really *object* relational mappers at all, but DTO relational mappers...

[10:07] <jnthn> Or struct relational mappers. Or whatever. :)

[10:08] <mathw> yeah

[10:08] <masak> yes, it's a misnomer.

[10:08] <masak> Fowler points this out as well.

[10:08] <masak> the challenge isn't mapping objects, the challenge is mapping *things in memory*.

[10:08] <mathw> well, it's nto really because it turns them into objects, they're just not very good ones :)

[10:09] *** araujo joined
[10:09] *** ssutch joined
[10:10] <jnthn> Yeah, the thing is that in many systems, the fact that these ORM-centric objects look this way tends to lead to all objects in the system looking that way. Most business systems I see are procedural code in OO disguise.

[10:11] <jnthn> "Why do the OO textbooks say dog.bark(), but all our code is dogController.bark(dog)?" # real question I got recently at $dayjob client

[10:11] <mathw> It does tend to contaminate things. One of my colleagues is very big on domain-driven design done in a way that attempts to alleviate the problem

[10:11] <mathw> Personally I just end up hating OOP

[10:13] <jnthn> The irony is that languages various primarily OO languages, like Java and, to a lesser degree, C#, force an OO perspective on *everything*, which as a result devalues OOP.

[10:13] <jnthn> s:1st/languages//

[10:14] <mathw> everything has to be inside a class

[10:15] <mathw> that is one thing that really, really bugs me

[10:15] *** ssutch left
[10:15] <daxim> HEY USER, I HAVE AN AXE TO GRIND WITH YOU. GRIND GRIND. USE OOP. OR ELSE.

[10:16] <daxim> why is that not acceptable in the real world, but when a language designer does it, he's like buddha on the mountain?

[10:16] <masak> yeah; one is a sin of commission (making everything OOP), the other a sin of omission (eschewing OOP because the ORM sits on it).

[10:16] <masak> daxim: because none of us have much of an idea of what we're doing.

[10:16] <mathw> this is all too new still

[10:16] <masak> daxim: and people with axes to grind often sound really convinced, which tends to attract followers.

[10:16] <mathw> quite exciting, we really still have no idea how to write software

[10:16] <masak> almost not clue at all

[10:17] <daxim> I'm gonna quote you on that.

[10:18] <mathw> one of my colleagues now informs me that NHibernate can in fact do what I want

[10:18] <ruoso> on the topic of ORM, I think DBIx::Class offers an interesting perspective by not trying to make the simplistic "table is class, row is object" approach, and making it a much more open-ended "we have result sources, result sets and rows. some result sources have predefined types"

[10:19] <mathw> ruoso: I've not used it extensively, but I've been very interested in what I have seen.

[10:19] <moritz> ruoso: aye, DBIx::Class seem to have found a sweet spot

[10:22] <ruoso> Yeah, I would personally just port DBIx::Class pretty much as-is to Perl6 (maybe adding a custom grammar for the result source declaration)... It already heavily uses roles and traits and stuff...

[10:22] *** effbiai left
[10:23] *** berekuk joined
[10:25] <FROGGS> .tell TimToady should the name of a slang be lowercase in general? like in use A:from<perl5>, use B:from<java>, eval( "\t\s\n", :lang<bf> ) ? I think the name of the slang is about the language, not the interpreter/binary, and should there be like Perl5, Java, C, ...

[10:25] <yoleaux> FROGGS: I'll pass your message to TimToady.

[10:25] <preflex>  yoleaux: you have 1 new message. '/msg preflex messages' to read it.

[10:25] <FROGGS> preflex: you are weird

[10:26] <jnthn> oh no...did somebody use one message bot to message another? :P

[10:27] <masak> bots are bad at checking their messages.

[10:27] <mathw> $me.laugh;

[10:28] *** fhelmberger left
[10:28] *** fhelmberger joined
[10:29] *** hypolin left
[10:42] *** crab2313 left
[10:43] *** crab2313 joined
[10:43] *** fridim__ joined
[10:46] <masak> .tell yoleaux I'd sure like to get my hands on IRC bot technology clever enough to read its messages.

[10:46] <yoleaux> masak: Thanks for the message.

[10:46] <masak> heh.

[10:47] <masak> oh, the '.tell' command goes to yoleaux.

[10:47] <masak> preflex: help?

[10:47] <masak> preflex: help

[10:47] <preflex>  try 'help help' or see 'list' for available commands

[10:47] <masak> preflex: list

[10:47] <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; excuses: [excuse]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st, ordinal]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version:

[10:47] <preflex>  [version]; XSeen: [xseen]; ZCode: [zdec, zenc]

[10:47] <masak> preflex: tell yoleaux you have another message!

[10:47] <preflex>  Consider it noted.

[10:48] <masak> yoleaux: now check your inbox.

[10:48] <lizmat> .tell masak yoleaux will tell you now

[10:48] <yoleaux> lizmat: I'll pass your message to masak.

[10:50] <FROGGS> preflex: karmatop

[10:50] <FROGGS> O.o

[10:51] <preflex>  c: 200815; g: 9840; ##c: 7841; c/c: 7011; whiteknight: 4931; moritz: 4875; bacek: 4624; notepad: 4280; jnthn: 4095; #c: 3762

[10:52] <FROGGS> thank you sir

[10:53] <lizmat> a QAST question: looking at https://gist.github.com/lizmat/6163530

[10:53] <lizmat> I understand that it creates an if on a state variable that only runs once

[10:53] <lizmat> and that it stores the result of the block execution in that variable

[10:54] <lizmat> the final line returns the value of that variable, right ?

[10:54] <masak> wow, that c/c thing is more popular than whiteknight :)

[10:54] <yoleaux> 10:48Z <lizmat> masak: yoleaux will tell you now

[10:54] <FROGGS> lizmat: I'm not sure if QAST::Ops do that, but QAST::Stmts certainly do

[10:55] <FROGGS> hmm, I think that QAST::Var gets passed to the op rather than returned from it

[10:55] <jnthn> lizmat: if takes cond/then/else

[10:55] <FROGGS> so the line 9 is the else

[10:55] <jnthn> lizmat: The else branch (third kid) just returns the thing in the variable, yes

[10:55] <jnthn> Right.

[10:55] <FROGGS> yeah, of course

[10:56] <jnthn> it's-our-first-time ?? $secret-var = blorst() !! $secret-var

[10:56] <lizmat> well, then why doesn't this work:

[10:57] <lizmat> r: for ^2 { say once { say "hello"; 42 } }

[10:57] <camelia> rakudo f5bfa7: OUTPUT«hello␤Nil␤Nil␤»

[10:57] <lizmat> it *is* executed once, but the value of the block is never returned

[10:57] <FROGGS> lizmat: that QAST::Var $sym is declared somewhere?

[10:57] <lizmat> $*W.install_lexical_container($pad, $sym, %info, $descriptor, :scope('state'));

[10:58] <FROGGS> hmmm, I would do: make QAST::Stmts.new( QAST::Var.new( :name($sym), :scope('lexical'), :decl('var') ), <--- op goes here ---> )

[10:58] <lizmat> It's in Actions, line 1245 and following

[10:58] <lizmat> method statement_prefix:sym<once>($/) {

[10:58] <FROGGS> instead of the lexical, but jnthn can tell if I am wrong :o)

[10:58] <FROGGS> lizmat: in nom?

[10:58] <lizmat> in nom indeed

[10:58] <FROGGS> so I can play with it

[10:59] <FROGGS> k

[10:59] <lizmat> r: for ^2 { say once { say "hello"; 42 } }  # should say hello,42,42 according to spec

[10:59] <camelia> rakudo f5bfa7: OUTPUT«hello␤Nil␤Nil␤»

[11:00] <FROGGS> lizmat: what about line 1247?

[11:01] <FROGGS> ahh, no, you're not using $past

[11:02] <lizmat> dead code indeed...

[11:07] <lizmat> removing the dead code fixed it

[11:07] <lizmat> FROGGS!

[11:07] <FROGGS> does it?

[11:07] *** colomon joined
[11:07] <FROGGS> ahh well, it binds to $past...

[11:08] <tadzik> a link to the $past

[11:08] <dalek> rakudo/nom: fe939be | (Elizabeth Mattijsen)++ | src/Perl6/Actions.nqp:

[11:08] <dalek> rakudo/nom: Make "once" block *really* work, FROGGS++ for extra pair of eyes!

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe939bed52

[11:08] <FROGGS> #perl6, where time machines happened

[11:09] <FROGGS> remember the days when stage parse took <80s? ó.ò

[11:09] * FROGGS 's machine takes 133s now

[11:09] <tadzik> yeah, early nom :)

[11:09] <tadzik> when the setting was 8x shorter

[11:09] <dalek> roast: 970bc4b | (Elizabeth Mattijsen)++ | S04-statements/once.t:

[11:09] <dalek> roast: Unfudge now passing once block tests

[11:09] <dalek> roast: review: https://github.com/perl6/roast/commit/970bc4be46

[11:09] <FROGGS> so it is about 5min all in all

[11:09] <FROGGS> tadzik: well, last year in october or so

[11:10] *** konundra joined
[11:11] * FROGGS lurks at #moarvm :P

[11:19] *** fridim__ left
[11:22] <lizmat> .oO( wasn't it the Dobby den ? )

[11:27] <masak> ww?

[11:28] <lizmat> hehe, indeed…  :-)

[11:31] <dalek> rakudo/nom: 6a65441 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[11:31] <dalek> rakudo/nom: Reduce core setting size by simplifying (classify|categorize)-list

[11:31] <dalek> rakudo/nom: 

[11:31] <dalek> rakudo/nom: Too bad that nextwith() doesn't work, or I don't know how to use it.

[11:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a6544145a

[11:32] *** PacoLinux joined
[11:33] <lizmat> afk

[11:35] *** arcterus joined
[11:36] <jnthn> Given it has a bunch of passing tests... :P

[11:39] *** arcterus left
[11:41] <JimmyZ> good evening

[11:41] <FROGGS> hi JimmyZ 

[11:42] *** konundra left
[11:42] <JimmyZ> hello FROGGS 

[12:00] *** ggoebel joined
[12:05] *** konundra joined
[12:10] *** skids left
[12:12] <lizmat> jnthn: if I replace self.classify-list() with nextwith() in 6a65441, I always only get Nil as the result

[12:13] <lizmat> will add that case as a test, and see where it will take us  :-)

[12:13] <jnthn> ok :)

[12:15] *** sqirrel joined
[12:23] *** dakkar left
[12:24] * masak is surprised at how much Guido keeps referring to Perl 6 in http://www.youtube.com/watch?v=UIDdgeISLUI

[12:24] <masak> (it's a Python 3000 talk from July 2006)

[12:26] <dalek> Perlito: 64cca22 | (Flavio S. Glock)++ | / (5 files):

[12:26] <dalek> Perlito: Perlito5 - more special variables

[12:26] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/64cca22b09

[12:26] *** rindolf joined
[12:27] <FROGGS> masak: is it worth watching for somebody that has prejudices about python?

[12:29] <masak> FROGGS: possibly. it gives some insight in the py3k process, which is a nice contrast to the p6 process.

[12:29] <FROGGS> k

[12:29] <masak> FROGGS: you'll also be watching it with 7 years of hindsight.

[12:29] <nwc10> from both projects

[12:29] <masak> as in, py3k hasn't taken over the world yet.

[12:29] <FROGGS> btw, I have no knowledge of python whatsoever

[12:31] <masak> FROGGS: the past week-or-so of studying it closely has convinced me that the Perl-Python differences are more in the slogans, syntax, and other surface details, than in pragmatics, community dynamics, etc

[12:32] <FROGGS> I think I care about the syntax mostly when looking at new languages

[12:32] <pmurias> masak: does it refer to Perl 6 other than as a thing to avoid py3k ending up as?

[12:35] <FROGGS> "... and Perl 6" ['laughter from audience']

[12:37] <lizmat> jnthn: failing tests https://gist.github.com/lizmat/6164076

[12:39] <dalek> roast: f3f049b | (Elizabeth Mattijsen)++ | S12-methods/defer-next.t:

[12:39] <dalek> roast: Added extra "nextwith()" tests, that are failing for now

[12:39] <dalek> roast: review: https://github.com/perl6/roast/commit/f3f049b3d3

[12:40] <masak> pmurias: I think he's mentioned Perl 6 three times. but it's always in that context, as something to avoid.

[12:40] *** colomon left
[12:41] <masak> pmurias: the third time he says (paraphrasing) "really though, Perl 6 is fine. it's just [extremely ambitious and] taking very long."

[12:42] <masak> "...and the Perl 5 people are for the most part ignoring it" which was true in 2006 because people weren't talking about Perl 7 then :P

[12:42] <dalek> roast: 12cad1a | (Elizabeth Mattijsen)++ | S12-methods/defer-next.t:

[12:42] <dalek> roast: Fudge failing tests for now

[12:42] <dalek> roast: review: https://github.com/perl6/roast/commit/12cad1a7b3

[12:42] <lizmat> jnthn: so am I expecting the wrong thing from nextwith() ?

[12:43] <FROGGS> and he says he doesnt want open discussions about al parts of the new languages, since this eats up time as we see

[12:43] <jnthn> lizmat: Your expectations are off

[12:43] <masak> FROGGS: right. everything is *not* up for discussion.

[12:43] <jnthn> lizmat: You're iterating over a *predetermined* candiate list.

[12:44] <jnthn> lizmat: Which contains a single item.

[12:44] <masak> FROGGS: in my view, we've also progressed away from the total free-for-all we had on p6l at some point.

[12:44] <masak> FROGGS: as in, at this point, there is some "inviolable" part of Perl 6.

[12:44] <lizmat> jnthn: but should that fail silently?

[12:44] <FROGGS> masak: absolutely

[12:44] <masak> FROGGS: and the only one that goes changing those bits (very occasionally) is TimToady.

[12:44] <masak> (which always makes me nervous) :)

[12:44] <jnthn> lizmat: nextwith is spec'd to return Nil if there's nowhere to go, iirc

[12:45] <jnthn> lizmat: Though there's been tests that wanted it the other way... 

[12:45] <lizmat> so there is no alternative but to repeat the name of the candidate as in self.foo()

[12:45] <jnthn> Right, if you want to dispatch over again, that's what you need to do.

[12:46] <masak> FROGGS: interestingly, the community even overruled TimToady's OKness proposal, partly because of technical concerns, but to a great extent for backwards-compat reasons.

[12:46] <masak> FROGGS: you will still hear TimToady mumble sometimes that "OKness would have fixed this..."

[12:46] <FROGGS> OKness?

[12:46] <lizmat> so there is no easy way to do this without explicitely calling the same method name ?

[12:47] <jnthn> lizmat: no

[12:47] *** PacoLinux left
[12:47] <jnthn> lizmat: You can write &?ROUTINE.dispatcher(...) I guess.

[12:47] <jnthn> lizmat: I'm not sure I'd consider that easier :)

[12:48] <lizmat> seems to me then something would need to be specced, as this is a pattern that I have used a lot in the past

[12:48] *** PacoLinux joined
[12:48] <jnthn> um, that'd need to be 

[12:48] <masak> FROGGS: https://gist.github.com/TimToady/1828667

[12:48] <jnthn> &?ROUTINE.dispatcher()(...)

[12:50] *** genehack joined
[12:52] <dalek> rakudo/nom: 07a57ba | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[12:52] <dalek> rakudo/nom: Remove derogatory comments

[12:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07a57ba9e5

[12:52] <FROGGS> masak: thanks

[12:53] *** ruoso joined
[12:53] * mathw mumbles something about monads

[12:54] <jnthn> .oO( kick in the monads )

[12:56] *** daniel-s__ left
[12:57] *** daniel-s__ joined
[12:57] <mathw> One thing I'm really enjoying in Haskell is mucking about with the fact that Maybe is an instance of Monad, as is Either.

[13:00] *** crab2313 left
[13:02] <dalek> roast: 7bf6bb8 | (Elizabeth Mattijsen)++ | S12-methods/defer-next.t:

[13:02] <dalek> roast: Put jnthn's trick instead: this works, but I feel this needs syntactic sugar

[13:02] <dalek> roast: review: https://github.com/perl6/roast/commit/7bf6bb898b

[13:02] <masak> at this point in my spiritual development, I just automatically went "well of course Maybe is a monad, just look at it!"

[13:02] <masak> :)

[13:02] <lizmat> on our way to the Amsterdam.pm meeting&

[13:03] *** lizmat left
[13:08] <masak> rn: my $x = 0 but True; if $x { say "T" } else { say "F" }

[13:08] <camelia> rakudo 6a6544, niecza v24-88-g1f87209: OUTPUT«T␤»

[13:08] <masak> ok, so that bit of https://gist.github.com/TimToady/1828667 isn't an issue anymore, for some reason

[13:09] <FROGGS> masak: and a failed Match is Nil now, no?

[13:11] <masak> think so.

[13:14] *** ajr joined
[13:15] <mathw> doesn't bool-ness override everything else in if's checks or something? #outoftouch

[13:15] *** ajr is now known as Guest86080

[13:15] *** Guest86080 is now known as ajr_

[13:16] <masak> rn: my $b = True but False; if $b { say "T" } else { say "F" }

[13:17] <camelia> rakudo 07a57b, niecza v24-88-g1f87209: OUTPUT«F␤»

[13:17] <masak> mathw: seems the role always wins, yes.

[13:17] *** PacoLinux left
[13:27] <dalek> nqp: b4a38bb | (Pawel Murias)++ | t/nqp/75-curcode.t:

[13:27] <dalek> nqp: Add test for nqp::curcode();

[13:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b4a38bbddb

[13:33] *** skids joined
[13:34] <FROGGS> okay, looks like I don't need to switch over to Python :o)

[13:39] <mathw> no, you don't

[13:39] <FROGGS> Python 3000 from that presentation feels more like Perl 5.10 than Perl 6

[13:42] *** bluescreen10 joined
[13:47] <tadzik> that's correct

[13:53] <masak> yes, and it was never meant to be anything else.

[13:53] *** wtw_ left
[13:53] <masak> Guido just wants to fix up some very early mistakes once and for all, because doing so down the road would be more difficult.

[13:55] <FROGGS> masak: sure, I understand that, and I think that this is needed to ship it within less than a decade

[13:56] <pmurias> jnthn: what does usecapture, savecapture do?

[14:00] <jnthn> pmurias: Gets hold of the argument capture passed to the current block. save commits to doing enough copying that the list is valid any amount of time, while use doesn't promise that.

[14:00] <jnthn> (a future usecapture may invalidate it)

[14:00] <jnthn> It's valid to implement them exactly the same way if there's no performance benefit to be had in a split.

[14:01] <jnthn> The multi-dispatcher makes use of these.

[14:02] <masak> FROGGS: probably.

[14:03] <masak> FROGGS: I guess the big difference between supporters and detractors isn't "is it taking a long time?" -- which it is, objectively -- but "is it worth it?"

[14:03] <FROGGS> I think Perl 6 is worth its time fwiw

[14:04] <jnthn> The fact you're contributing does suggest so ;)

[14:07] <FROGGS> :o)

[14:08] <FROGGS> well, I started to contribute in october last year, but I still think Perl 6 needs to take the years and years it took before

[14:08] *** bluescreen100 joined
[14:09] <dalek> nqp: ae34e49 | (Pawel Murias)++ | docs/opcodes.markdown:

[14:09] <dalek> nqp: Start documenting opcodes. Explanations taken from an irc explanation by jnthn++.

[14:09] <dalek> nqp: 

[14:09] <dalek> nqp: Could use some editing but it's better than nothing.

[14:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ae34e494df

[14:09] <pmurias> jnthn: ^^

[14:09] <timotimo> hm, "opcodes"?

[14:09] <pmurias> should be ops ;)

[14:10] <jnthn> ^∵^ .oO( meow )

[14:10] *** xinming left
[14:10] <pmurias> as I mentioned in the commit log it could use some editing

[14:10] <jnthn> I'm pretty sure the e shouldn't be after the . :P

[14:11] *** logie joined
[14:11] *** xinming joined
[14:12] *** bluescreen10 left
[14:13] <dalek> nqp: 05296fe | (Pawel Murias)++ | docs/op (2 files):

[14:13] <dalek> nqp: Rename the "operations" docs.

[14:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/05296fe15f

[14:21] *** PacoLinux joined
[14:21] *** sqirrel left
[14:24] *** jaffa4 joined
[14:29] <[Coke]> pmurias++ # getting that doc started!

[14:32] *** btyler joined
[14:34] <pmurias> jnthn: http://pastie.org/8211657 - this test fails on nqp-parrot and passes on nqp-jvm

[14:36] *** colomon joined
[14:37] <masak> "When Python 3 finally gets released..." -- "Python 3 has already been released." -- http://stackoverflow.com/questions/170921/should-i-learn-python-2-before-3-or-start-directly-from-python-3

[14:37] <masak> so nice to see that problem occur in another community too! :)

[14:38] *** Psyche^_ joined
[14:39] <mathw> There's not really any questiona bout the releasedness of Python 3 I would have said

[14:39] *** rindolf left
[14:39] <pmurias> masak: the "Perl 6 has already been released multiple times" argument while technically correct seems a bit misleading

[14:39] *** jaffa4 left
[14:40] <[Coke]> scotsman - that's not a REAL release.

[14:40] <tadzik> 'fcours not. 'tis just a person

[14:40] *** |newbie| joined
[14:40] <[Coke]> which, while normally a fallacy, still seems allowable in this context.

[14:41] <[Coke]> tadzik: (I was referring to the "true scotsman" logical fallacy)

[14:41] *** Psyche^ left
[14:41] *** jaffa4 joined
[14:42] <tadzik> I see

[14:44] <masak> pmurias: yes. if someone seems intent on talking about "released" or "ready", the focus should instead be on what level of stability/polish that person associates with those concepts.

[14:46] <timotimo> indeed, there isn't a "true scotsman" because what defines a scotsman is different for everybody in this case and nobody should assert global scotsman/nonscotsmanship

[14:46] <timotimo> of course people will say "it's ready when it's good enough for everyone" and then someone will complain about the kitchen sink missing

[14:47] <jnthn> Good job we did spec KitchenSink...

[14:47] <daxim> my $ORK[-1] computer was named notruescotsman

[14:50] <[Coke]> daxim++

[14:50] <pmurias> jnthn: have you seen my tests which find a bug in nqp::savecapture() on parrot?

[14:53] *** PacoLinux left
[14:53] *** PacoLinux joined
[14:54] <pmurias> jnthn: the bug illustrated http://pastie.org/8211737

[14:55] *** kaare_ joined
[14:55] <masak> today's autopun spotting: https://twitter.com/peterritchie/status/364751444353617920

[14:58] <daxim> for the hackathon at yapc, I want to package rakudo-jvm and nqp-jvm, the bug I filed yesterday is one prereq   https://github.com/perl6/nqp/issues/110

[14:59] <daxim> installations must work from system install targets, /usr/share/java and the like

[15:01] *** raiph left
[15:02] <jnthn> pmurias: I'm confused, what is that void use of nqp::savecapture() doing?

[15:06] <jnthn> pmurias: That is, I'm not sure it makes sense...

[15:14] *** konundra left
[15:14] <pmurias> jnthn: if you comment the call to inner the bug remains

[15:15] <pmurias> jnthn: what I wanted to illustrate is the nqp::savecapture saves the capture but only while the sub it was taken in is on the call stack

[15:16] <moritz> r: constant a = 42; say (:a).perl;

[15:16] <camelia> rakudo 07a57b: OUTPUT«"a" => Bool::True␤»

[15:16] <pmurias> jnthn: the empty nqp::savecapture was meant to fetch a new capture

[15:16] <jnthn> pmurias: OK,, that's...odd.

[15:17] <jnthn> pmurias: Though, given we use it for multi-dispatch, perhaps not the end of the world...

[15:19] *** btyler left
[15:19] <pmurias> hmm, it seems that something bad happens to the CallContext on parrot

[15:19] * FROGGS .oO( not the end of the $*W? )

[15:20] *** simonl13 joined
[15:20] *** FROGGS left
[15:21] *** fhelmberger left
[15:23] *** sqirrel joined
[15:26] <pmurias> jnthn: it could be reused somewhere, intentionally crippled to reduce memory use or we have a garbadge collector bug

[15:26] <pmurias> jnthn: hopefully it's not the last things ;)

[15:26] *** btyler joined
[15:27] <pmurias> jnthn: the other suspicious thing is the comment in our op claims that CallContext is immutable, but it has a .clone method

[15:32] <pmurias> jnthn: I could check if inserting a clone there fixes the bug

[15:42] *** colomon left
[15:47] <dalek> nqp: c4d04bb | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/B (2 files):

[15:47] <dalek> nqp: Fix class loader visibility issue in JAR loading.

[15:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4d04bb261

[15:49] *** zb joined
[15:49] <jnthn> It ain't pretty but I just got a hello world SWT thing working: 6e5b82c4b70fd6592841

[15:49] <jnthn> oops

[15:49] <jnthn> https://gist.github.com/jnthn/6e5b82c4b70fd6592841

[15:49] <jnthn> pmurias: Could, but...do we need to fix this?

[15:50] <pmurias> we could skip the test on parrot

[15:51] *** PacoLinux left
[15:51] <masak> jnthn++

[15:52] <jnthn> It opens a GUI thingy :)

[15:52] <masak> jnthn: it feels a bit redundant that SWTJAR has to be passed every time. also, it's the first time I see the :jar parameter.

[15:52] <pmurias> jnthn: how should I determine if we are running on parrot in the nqp code?

[15:53] <jnthn> pmurias: nqp::getcomp('nqp').backend.name maybe

[15:54] <jnthn> masak: The colonpairs just get passed down to the module loader to interpret

[15:54] *** PacoLinux joined
[15:54] <jnthn> masak: And just liek the Perl 6 one knows how to interpret (in theory) auth and ver, so the java one knows how to interpret :jar :)

[15:55] <jnthn> masak: It's a bit redundant, but I don't immediately know what to do about it. Of course, you could find a way to include the thing in the default class path and then not need it.

[15:56] <timotimo> jnthn: maybe something like "use lib" for jars?

[15:56] <timotimo> "use jar 'D:\...'"

[15:56] <timotimo> it's kind of the same principle, seems to me.

[15:57] <diakopter> masak: segomos and ugexe showed me their new p6 package manager tool yesterday

[15:58] <timotimo> why can you sometimes write just Text.new and sometimes you have to take the long way with the string? is that when there's exactly one candidate?

[15:58] <jnthn> timotimo: Yeah

[15:58] <timotimo> all right

[15:58] <jnthn> timotimo: It's on my todo list to get something smart in place there.

[16:02] *** sqirrel left
[16:03] <masak> diakopter: oh? those names are new to me, and I didn't know someone was working on a p6 package manager tool.

[16:03] <diakopter> ditto, and me too

[16:06] *** simonl13 left
[16:07] <diakopter> masak: oh, it's still a private repo

[16:08] <diakopter> it has a server component too (rakudo-parrot, currently, but worse-than-dog slow, of course)

[16:08] <masak> ok.

[16:08] <diakopter> it's running at zef.pm

[16:08] *** xinming left
[16:09] <diakopter> sorta

[16:10] *** xinming joined
[16:11] <masak> that page doesn't tell me much.

[16:13] *** pmurias left
[16:16] *** [particle]1 left
[16:18] *** Ulti left
[16:20] *** dmol left
[16:22] *** kaleem left
[16:24] *** xinming left
[16:25] *** xinming joined
[16:28] *** PacoLinux left
[16:31] *** vk_ joined
[16:31] *** sqirrel joined
[16:33] *** FROGGS joined
[16:33] *** [particle] joined
[16:34] *** spider-mario joined
[16:39] *** kaleem joined
[16:45] *** kingbeast joined
[16:47] *** kaleem left
[16:47] *** kaleem joined
[16:48] *** camelia joined
[16:48] *** domidumont joined
[16:49] *** konundra joined
[16:49] *** ajr_ left
[16:49] *** synopsebot joined
[16:49] *** ChanServ sets mode: +v camelia

[16:49] *** kaleem left
[16:50] <grondilu> Is hash(%h.keys Z=> %h.values) guaranted to be the same as %h?

[16:50] <grondilu> I mean does .values uses the same order as .keys?

[16:51] <jnthn> Doesn't feel wise to rely on that.

[16:51] <grondilu> ok

[16:51] <jnthn> %h.pairs may be useful

[16:52] *** ajr joined
[16:52] *** ajr is now known as Guest90993

[16:57] *** MayDaniel joined
[16:59] <masak> I think the spec has some wording that guarantees it, yes.

[16:59] <masak> as long as you don't mutate the hash in-between the calls, successive .keys and .values calls will yield the same order.

[17:00] *** stevan_ left
[17:01] * jnthn suspects it does work out on all implementations today, but would still be a little wary of writing it :)

[17:01] <jnthn> Not least 'cus it creates two hash iterators going over the same thing :)

[17:03] <masak> yes, that latter reason would make me suspect there's a better way to do it.

[17:03] <masak> in the above case, %h.clone, for example.

[17:04] *** domidumont left
[17:07] *** dmol joined
[17:13] <grondilu> to tell you everything, I was reading http://rosettacode.org/wiki/Probabilistic_choice#Perl_6, and I thought about writing:  %ps.keys Z=> [\+] %ps.values

[17:13] <grondilu> that would be quite an elegant way to compute the cumulated probabilitie

[17:13] <grondilu> s

[17:13] *** birdwindupbird left
[17:15] <grondilu> rn: my %h = 'a'..'e' Z=> ^5; say .perl given hash %h.keys Z=> [\+] %h.values

[17:15] <camelia> niecza v24-88-g1f87209: OUTPUT«{"a" => 0, "b" => 1, "c" => 3, "d" => 6, "e" => 10}.hash␤»

[17:15] <camelia> ..rakudo 07a57b: OUTPUT«("a" => 0, "b" => 1, "c" => 3, "d" => 6, "e" => 10).hash␤»

[17:17] *** fgomez joined
[17:21] *** sqirrel left
[17:23] <dalek> Perlito: d02186c | (Flavio S. Glock)++ | / (5 files):

[17:23] <dalek> Perlito: Perlito5 - js - '&subroutine' tests pass

[17:23] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/d02186c509

[17:25] *** simonl13 joined
[17:25] <grondilu> rn: say .perl given map {$^w => $^n}, (^2 Z <foo bar>);

[17:25] <camelia> rakudo 07a57b, niecza v24-88-g1f87209: OUTPUT«("foo" => 0, "bar" => 1).list␤»

[17:26] * grondilu expected this to fail:  shouldn't number be on the right side of the zip?

[17:27] <timotimo> n comes before w

[17:27] <timotimo> rn: say .perl given map {$^a_w => $^b_n}, (^2 Z <foo bar>);

[17:27] <camelia> rakudo 07a57b, niecza v24-88-g1f87209: OUTPUT«(0 => "foo", 1 => "bar").list␤»

[17:27] <grondilu> oh I did not know alphabetic order matters

[17:28] <timotimo> that's "the neat feature" for implicit signatures :)

[17:28] <grondilu> can be useful indeed

[17:30] <timotimo> for simple cases, R is always there for you as well

[17:31] *** bluescreen100 left
[17:31] *** bluescreen__ joined
[17:43] *** ggoebel left
[17:45] <dalek> Perlito: bba555b | (Flavio S. Glock)++ | / (3 files):

[17:45] <dalek> Perlito: Perlito5 - parser - error message

[17:45] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/bba555b845

[17:46] *** btyler left
[17:48] *** Guest90993 left
[17:51] *** simonl13 left
[17:54] *** zwut00 joined
[17:54] <slava> zwut00: how big is uc davis?

[17:55] *** btyler joined
[17:56] <diakopter> o_O

[17:57] <zwut00> slava: it takes about 20 minutes to walk from one side of campus to the other

[17:57] *** stevan_ joined
[17:57] <masak> sure, but it could still be very long and narrow.

[17:58] <zwut00> its about 7300 acres

[17:59] *** Chat9593 joined
[17:59] <Chat9593> Dao

[17:59] <Chat9593> Noæ

[17:59] <dalek> perl6-roast-data: d36dba3 | coke++ | / (5 files):

[17:59] <dalek> perl6-roast-data: today (automated commit)

[17:59] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d36dba3dfd

[17:59] <dalek> rakudo-star-daily: 7d2dd11 | coke++ | log/ (5 files):

[17:59] <dalek> rakudo-star-daily: today (automated commit)

[17:59] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/7d2dd11124

[17:59] <Chat9593> 2222212-55

[17:59] <diakopter> Chat9593: bye bye

[17:59] <flussence> yay it's keyboard cat!

[18:00] *** Chat9593 left
[18:01] *** ssutch joined
[18:01] *** simonl13 joined
[18:01] <masak> hi keyboard cat!

[18:01] *** zby_home_ joined
[18:02] <masak> oh, gone already.

[18:03] *** daxim left
[18:04] <geekosaur> that showed up in #haskell yesterday. I'm wondering if there's a botnet c&c sleeper in these channels

[18:04] <geekosaur> never says anything, just listens for commands phrased as that noise from random ephemeral accounts

[18:05] <flussence> no, it's just some stupid "free chat" phone app that apparently displays a list of channels from IRC networks sorted by user count

[18:07] <timotimo> this channel has only .. oh wow, 210 isn't even that small

[18:08] *** stevan__ joined
[18:10] *** Mouq joined
[18:11] *** ajr joined
[18:12] *** stevan_ left
[18:12] *** ajr is now known as Guest19992

[18:14] *** simonl13 left
[18:14] *** bluescreen__ left
[18:30] *** preflex left
[18:31] *** preflex joined
[18:31] *** ChanServ sets mode: +v preflex

[18:32] *** lizmat joined
[18:32] *** Mouq left
[18:36] *** Mouq joined
[18:39] <dalek> rakudo/use-from-java: 3ffc247 | jnthn++ | src/ (5 files):

[18:39] <dalek> rakudo/use-from-java: Prepare for Rakudo-specific tweaks to JVM interop.

[18:39] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/3ffc247b3c

[18:45] *** pecastro left
[18:47] *** pecastro joined
[19:02] <timotimo> jnthn: i'm not sure why the data structure for poison information should be "like the current @!BLOCKS, but with a pointer to each block's parent"; when do we need to know a block's parent, but not have it readily available on the BLOCK stack?

[19:04] <jnthn> timotimo: Just thinking if some transformations are going to happen once we decide they are safe, and at that point we may have poppoed the block off the stack...

[19:05] <timotimo> hm, but when are we in a different block from the one we're trying to do the transformation on? at least for the "this container never gets poisoned by a bind" case that was my first use case for this it looks like it could just go through its children and afterwards have all the info it needs on hand

[19:05] <timotimo> as in: the poison information is local to the block that has the poisoned lexical, not the block that poisons the lexical

[19:06] <jnthn> Yes, but the assignments to tweak are all over the place.

[19:06] <timotimo> i think the simplest thing i can start with is annotate each lexical with a flag that tells how far down the block stack it gets referred to

[19:06] <jnthn> Which in *this* case doesn't matter.

[19:06] <jnthn> But in other cases may

[19:06] <timotimo> mhm, that makes sense

[19:08] <timotimo> okay, need to go catch a tram now :)

[19:09] <dalek> Perlito: 174d943 | (Flavio S. Glock)++ | / (5 files):

[19:09] <dalek> Perlito: Perlito5 - parser - declaration attributes

[19:09] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/174d9438be

[19:11] <diakopter> is it a tramedy or tramesty

[19:18] *** ggoebel joined
[19:21] <timotimo> a tramway car

[19:24] <geekosaur> just trameling?

[19:25] <diakopter> tramping about

[19:25] *** Rotwang left
[19:27] *** colomon joined
[19:28] <lizmat> allee, da's veel trammelant!

[19:28] <lizmat> (flemish for: well, that's a lot of noise)

[19:28] * masak .oO( I think you're all just trolleying )

[19:28] <jnthn> *groan* :P

[19:29] <diakopter> do kmart and walmart use tramlaws and tramks?

[19:32] <jnthn> r: module Foo { }; say Foo ~~ Foo

[19:32] <camelia> rakudo 07a57b: OUTPUT«True␤»

[19:35] <dalek> rakudo-star-daily: 92bbc11 | coke++ | log/ (5 files):

[19:35] <dalek> rakudo-star-daily: today (automated commit)

[19:35] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/92bbc11c55

[19:35] <[Coke]> jnthn: ^^ are you aware of the zavolaj failure?

[19:35] <[Coke]> I think arnsholt was looking at it.

[19:36] <jnthn> [Coke]: Hm, I thought the last one arnsholt++ was looking into got fixed?

[19:37] <dalek> rakudo/use-from-java: 381e7e6 | jnthn++ | / (4 files):

[19:37] <dalek> rakudo/use-from-java: Give objects from Java a JavaHOW REPR.

[19:37] <dalek> rakudo/use-from-java: 

[19:37] <dalek> rakudo/use-from-java: This will enable us to get them to behave a bit 6ier.

[19:37] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/381e7e6551

[19:37] <dalek> rakudo/use-from-java: b4c8f67 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[19:37] <dalek> rakudo/use-from-java: Objects from Java pretend to be Any and Mu.

[19:37] <dalek> rakudo/use-from-java: review: https://github.com/rakudo/rakudo/commit/b4c8f67e16

[19:39] <dalek> Perlito: c2716c0 | (Flavio S. Glock)++ | / (6 files):

[19:39] <dalek> Perlito: Perlito5 - parser - subroutine attributes

[19:39] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/c2716c02af

[19:39] <[Coke]> this one has been failing for a while.

[19:39] <diakopter> 6ier.

[19:40] <timotimo> jnthn: so i was thinking on the tram - as my internet connection died - that there may be trouble keeping the poison-information-blocks around if they only have parent-links and no child-lists

[19:40] *** Rotwang joined
[19:41] <timotimo> but if our transformations do things like inline blocks, these child infos could get out of sync, so i suppose it all should happen on several steps, globally

[19:44] *** raiph joined
[19:58] *** daxim joined
[19:58] <dalek> nqp: b6257b3 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/BootJavaInterop.java:

[19:58] <dalek> nqp: Enable HOW computation to be overridden.

[19:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b6257b39a9

[19:58] <dalek> nqp: 9d33bb1 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/BootJavaInterop.java:

[19:58] <dalek> nqp: Decontainerize on marshal out of objects.

[19:58] <dalek> nqp: 

[19:58] <dalek> nqp: Means that we can use assignment as well as binding when using Java

[19:58] <dalek> nqp: objects in Perl 6.

[19:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9d33bb194d

[20:05] <dalek> Perlito: c2c07f3 | (Flavio S. Glock)++ | TODO-perlito5:

[20:05] <dalek> Perlito: Perlito5 - TODO update

[20:05] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/c2c07f3c51

[20:12] *** xenoterracide left
[20:16] *** pmurias joined
[20:16] *** _jaldhar joined
[20:17] <pmurias> jnthn,masak: re keys and values order it's guaranteed by the spec

[20:17] <lizmat> fwiw, there are several spectests depending on that behaviour as well, afaik

[20:19] *** jaldhar left
[20:19] *** xenoterracide joined
[20:22] <jnthn> fairy nuff :)

[20:23] <timotimo> how much improvement can be expected at all by turning lexicals into locals?

[20:23] <jnthn> Potentially a lot

[20:24] <timotimo> oh really? wow

[20:24] <jnthn> However, it may not be completely trivial

[20:24] <timotimo> my thoughts were: if there's only usages of the lexical from within the block it's declared in, it should be safe

[20:24] <jnthn> Remember that lexicals can be declared to initialize the slot in a certain way, and locals don't support that yet.

[20:25] <timotimo> oh, that was news to me

[20:25] <jnthn> Yeah

[20:25] <jnthn> That in theory doesn't affect doing it to native types, though, so you could just start there

[20:26] <timotimo> "native type" means "i want this to be fast!" anyway, so that's a good starting point :P

[20:26] <timotimo> since they are restricted in many ways already

[20:28] <pmurias> jnthn: what I would like to have when I get round to optimising rakudo-js is to have dynamic variables marked in the AST

[20:29] <pmurias> lexicals and locals don't make much difference for targeting js, as v8 handles lexical scopes

[20:31] <pmurias> and one related TODO we should s/contextual/dynamic in QAST

[20:31] *** sqirrel joined
[20:31] <timotimo> can you tell me what "contvar" means?

[20:31] <timotimo> as in: what's the difference between :decl<contvar> and :decl<var>?

[20:33] <pmurias> I haven't encontered that yet

[20:33] <pmurias> I would guess it's container var

[20:34] *** _jaldhar left
[20:34] *** _jaldhar joined
[20:34] <timotimo> i could also imagine that i can remove $_ and $/ in many pieces of code?

[20:34] <jnthn> timotimo: cont is for container

[20:34] <jnthn> timotimo: It means that we need to initialize a container in that slot

[20:36] <timotimo> ah. that also means if it's decl(var) it's safe to turn into a local (given it's not used in any blocks further down the line)

[20:36] <slava> moritz: will the next rakudo star use parrot 5.5?

[20:36] *** rindolf joined
[20:36] <lizmat> travelling back home&

[20:36] *** lizmat left
[20:38] <masak> slava: yes, looks like.

[20:38] <masak> slava: the NQP that Rakudo currently depends on already uses Parrot 5.5

[20:38] *** _jaldhar left
[20:39] <pmurias> timotimo: looking at the code the lexical declared as a contvar get's assigned a cloned copy of a value

[20:39] <pmurias> timotimo: as opposed to a static which get's just a value

[20:40] <pmurias> timotimo: re turning decl(var) into a local how do you determine if something is a dynamic variable?

[20:40] *** wtw joined
[20:41] *** kaare_ left
[20:42] <pmurias> timotimo: $_ and $/ are dynamic variables, so if there is a call to a unknown sub you can't remove them

[20:42] <pmurias> timotimo: as the mysterious sub could be putting something into them using CALLER

[20:43] <dalek> v5: 98becd8 | (Tobias Leich)++ | / (4 files):

[20:43] <dalek> v5: add an implicit `is copy`-trait

[20:43] <dalek> v5: 

[20:43] <dalek> v5: This is needed when iterating over `keys %hash` for example.

[20:43] <dalek> v5: Honestly, I have no idea how on earth this was working before.

[20:43] <dalek> v5: review: https://github.com/rakudo-p5/v5/commit/98becd817c

[20:43] <slava> masak: ty

[20:44] <masak> phz

[20:44] <timotimo> oh, didn't see them defined as dynamic

[20:45] <pmurias> in QAST everything is defined as dynamic

[20:45] <slava> I assume threads in rakudo-parrot are still a bit off?

[20:46] <pmurias> timotimo: but $_ and $/ are defined as dynamic in the spec

[20:46] <FROGGS> slava: needs to be properly implemented, yes

[20:46] <FROGGS> slava: I played with parrot-threads the last week

[20:47] <timotimo> ... everything is defined as dynamic? huh?

[20:48] *** araujo left
[20:48] <slava> FROGGS: cool, I am definitely looking forward to threads :)

[20:48] <slava> I am wondering what would happen if there were calls to pthreads the C library using NativeCall

[20:49] <FROGGS> slava: we need to find out :o)

[20:49] <benabik> You'd probably corrupt memory rather rapidly.

[20:50] <FROGGS> I'm unable to predict anything when threads are involved, that is something I have learned several times

[20:50] *** araujo joined
[20:55] <jnthn> slava: If you want to play with threads in Rakudo, Rakudo on JVM is a better bet

[20:57] <timotimo> oh wow. i see now that that's true

[20:59] <pmurias> timotimo: well, nothing is defined as dynamic so we have to assume everything is ;)

[21:00] <jnthn> It's not really a property of QAST itself, though

[21:00] <arnsholt> slava: Terrible, terrible things, most likely

[21:00] <jnthn> It's for the language optimizer to know what it can simplify

[21:00] <arnsholt> Since the threads would trample each other's (Parrot) interpreter state

[21:03] <pmurias> jnthn: the QAST represents 'my $foo is dynamic' and 'my $foo' the same

[21:03] <benabik> is dynamic?

[21:04] <pmurias> things like my $*foo

[21:04] <jnthn> pmurias: yes, though "is dynamic" hasn't really been implemented yet :)

[21:04] <pmurias> if a var doesn't have 'is dynamic' the compiler can hide it from CALLER

[21:05] <pmurias> jnthn: we have $*foo

[21:06] <jnthn> pmurias: Yes, I think those may end up marked as contextual in the QAST tree already

[21:08] <timotimo> the more i try to move around, the more often i have to struggle against the constraints of NYI that rakudo puts on me :|

[21:08] *** skids left
[21:09] <pmurias> jnthn: how are those marked?

[21:10] <slava> jnthn: tbh, I am not a giant proponent of the jvm. I spent 3 years support java webapps ... it is horrible

[21:10] <jnthn> pmurias: contextual scope

[21:12] *** konundra left
[21:12] <pmurias> jnthn: it's marked on access only

[21:13] <pmurias> jnthn: we could look at the twigil but that sucks

[21:13] <timotimo> if you, in theory, have to mark variables "is dynamic" to make them available to CALLER, it should be okay if the optimizer sometimes turns those variables unreachable, because you're relying on undefined behavior

[21:13] <[Coke]> slava: one of the goals is to be able to implement perl6 web apps on the JVM>

[21:13] <timotimo> or, rather, wrong behavior

[21:13] <[Coke]> then you can support perl6 instead. :)

[21:13] <jnthn> pmurias: Ah... I'm pretty sure the QAST emitter knows what the decl of a contextual is, so we could do it that way.

[21:14] <jnthn> timotimo: It's a little stronger than that. In fact, we should not expose anything not dynamic through caller

[21:14] <jnthn> timotimo: Which makes me suspect this info may want to be a flag in the container descriptor.

[21:14] <slava> [Coke]: I am definitely looking forward to that

[21:14] <pmurias> we *can* but do not *have* to expose anything not dynamic

[21:15] <[Coke]> I would love to be able to rewrite some of my work projects in perl. especially the text munging ones.

[21:15] <slava> [Coke]: I was thinking of having a perl container of sorts

[21:16] <pmurias> hmm, I'm not so sure of that

[21:18] <pmurias> jnthn: declaring them as 'contextual' in the decl node instead of 'lexical' would work

[21:18] <pmurias> jnthn: what would be even better if we declared them as 'dynamic' ;)

[21:20] <pmurias> sleep&

[21:20] *** pmurias left
[21:24] *** jaffa4 left
[21:24] *** |newbie| left
[21:24] *** raiph left
[21:29] *** BooK joined
[21:30] *** benabik left
[21:33] <timotimo> i guess i could look for how CALLER:: is handled and see if i can whip something very simple up for the time being

[21:34] *** stevan__ left
[21:34] *** raiph joined
[21:34] *** sqirrel left
[21:37] *** ggoebel left
[21:39] *** konundra joined
[21:39] *** zb left
[21:46] *** spider-mario left
[21:47] *** zby_home_ left
[21:49] *** dmol left
[21:52] *** ggoebel joined
[21:53] *** stevan_ joined
[21:54] <timotimo> when a key isn't in a PseudoStash, it should give a message like "$key is not in pseudoers. This incident will be reported"

[21:54] *** sqirrel joined
[21:56] <celesta> good night #perl6

[21:56] *** celesta left
[21:56] *** raiph left
[22:01] *** raiph joined
[22:05] *** dmol joined
[22:08] *** sqirrel left
[22:11] <masak> 'night, #perl6

[22:13] *** Mouq left
[22:14] *** Mouq joined
[22:17] *** daxim left
[22:21] *** Guest19992 left
[22:28] *** zby_home_ joined
[22:29] *** zby_home_ left
[22:30] *** sjohnson left
[22:30] *** sjohnson joined
[22:33] <FROGGS> jnthn: how do I get the RPMCA of an array? I was hoping nqp::getattr($op[0], List, '$!items') does the trick when $op[0] is an array :/

[22:36] <jnthn> FROGGS: What if the array has lazy/unevaluated bits?

[22:37] <FROGGS> boom?

[22:37] <FROGGS> say it has no such things, how would i get the RPMCA efficiently?

[22:38] *** xinming left
[22:38] <jnthn> Well, the FLATTENABLE_ARRAY method will do it, iirc

[22:39] *** thou left
[22:40] <FROGGS> awesome, thanks

[22:41] *** dmol left
[22:41] *** skids joined
[22:42] *** xinming joined
[22:48] *** rindolf left
[22:50] *** Mouq left
[22:51] <dalek> rakudo/nom: 572c45d | jnthn++ | src/vm/jvm/core/Threading.pm:

[22:51] <dalek> rakudo/nom: Generalize Promise a little.

[22:51] <dalek> rakudo/nom: 

[22:51] <dalek> rakudo/nom: They can still be about a piece of code, but it's now also possible to

[22:51] <dalek> rakudo/nom: create an empty promise, which can either be kept or broken from the

[22:51] <dalek> rakudo/nom: outside. Needs some extra error handling/safety work, but seems to do

[22:51] <dalek> rakudo/nom: about the right thing.

[22:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/572c45da3b

[22:51] <dalek> rakudo/nom: 6b386a7 | jnthn++ | src/vm/jvm/core/Threading.pm:

[22:51] <dalek> rakudo/nom: Fix off-by-one in threadpool growth handling.

[22:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b386a75a2

[22:51] *** thou joined
[22:54] *** lizmat joined
[22:59] *** MayDaniel left
[23:03] *** thou left
[23:07] *** colomon left
[23:08] *** benabik joined
[23:33] *** colomon joined
[23:37] *** fridim__ joined
[23:39] *** colomon left
[23:41] *** BenGoldberg joined
[23:42] *** Ben_Goldberg joined
[23:45] *** BenGoldberg left
[23:46] *** btyler left
[23:59] *** _jaldhar joined
