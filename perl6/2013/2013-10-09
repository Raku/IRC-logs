[00:00] <[Coke]> https://gist.github.com/coke/6893912 - that look ok for annotation of what goes on what vm?

[00:00] <[Coke]> no annotation, assumed cross platform?

[00:02] <diakopter> timotimo@host07:~/nqp$ install/bin/moar --dump nqp.moarvm >foo.out

[00:02] <diakopter> Segmentation fault

[00:02] <diakopter> apparently the bytecode dumper has bitrotted.

[00:02] <diakopter> also, why am I suddenly timotimo

[00:02] <[Coke]> hacxksz0r

[00:08] <jnthn> sleep &

[00:11] *** dayangkun joined
[00:12] *** Psyche^_ joined
[00:14] *** PZt joined
[00:15] *** grondilu left
[00:15] *** Psyche^ left
[00:17] *** prevost joined
[00:31] *** prammer left
[00:31] *** prammer joined
[00:38] *** skids joined
[00:48] *** xenoterracide_ left
[01:00] *** logie left
[01:00] *** logie joined
[01:15] *** benabik joined
[01:16] *** jnap left
[01:19] <pmichaud> r: say $*VM

[01:19] <camelia> rakudo d7e5e1: OUTPUT«("name" => "parrot", "config" => {"git_describe" => "RELEASE_5_5_0", "sha1" => "9c5c7927a9aa6e3a949a83a5d13efb88101b8c02", "a" => ".a", "ar" => "ar", "ar_extra" => "", "ar_out" => "", "archname" => "x86_64-linux-gnu-thread-multi", "arflags" => "cr", "as" => "as…»

[01:22] *** jnap joined
[01:25] <dalek> nqp: 3e8834f | coke++ | / (2 files):

[01:25] <dalek> nqp: Add vm-specific opcode information

[01:25] <dalek> nqp: 

[01:25] <dalek> nqp: Now vm specific ops will not complain they are not defined

[01:25] <dalek> nqp: on a non-targeted backend. (e.g "bootint")

[01:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3e8834fd94

[01:32] <[Coke]> only 196 more ops to document for the jvm. If 10 people did one a day...

[01:39] *** prevost left
[01:43] *** btyler joined
[01:43] <dalek> nqp/pm-packfile-api: cbd4843 | pmichaud++ | src/vm/parrot/HLL/Backend.nqp:

[01:43] <dalek> nqp/pm-packfile-api: Update HLL::Backend::Parrot to use new EvalPMC/PackfileView API.

[01:43] <dalek> nqp/pm-packfile-api: 

[01:43] <dalek> nqp/pm-packfile-api: Resolves issue #76, but requires a Parrot newer than

[01:43] <dalek> nqp/pm-packfile-api: RELEASE_5_7_0-20-g07dfdb4.  See issue #76 for more details.

[01:43] <TimToady> j: say $*VM

[01:43] <dalek> nqp/pm-packfile-api: review: https://github.com/perl6/nqp/commit/cbd4843043

[01:43] <dalek> nqp/pm-packfile-api: 4aedfed | pmichaud++ | src/vm/parrot/stage0/ (9 files):

[01:43] <dalek> nqp/pm-packfile-api: Update bootstrap for use with new PackfileView API.

[01:43] <dalek> nqp/pm-packfile-api: review: https://github.com/perl6/nqp/commit/4aedfed571

[01:43] <camelia> rakudo-jvm d7e5e1: OUTPUT«("name" => "jvm", "properties" => {"java.vm.version" => "24.0-b56", "sun.jnu.encoding" => "UTF-8", "java.vendor.url" => "http://java.oracle.com/", "java.vm.info" => "mixed mode", "user.dir" => "/home/p6eval_eval", "sun.cpu.isalist" => "", "java.awt.graphics…»

[01:45] *** zakharyas joined
[01:46] <pmichaud> anyone going to mind if I bump NQP_REVISION ?

[01:47] <pmichaud> sorry

[01:47] <pmichaud> rephrase:   anyone going to mind if I bump PARROT_REVISION ?

[01:47] <pmichaud> currently it's at REVISION_5_5_0

[01:47] <pmichaud> I'll take answers in scrollback

[01:52] *** stevan_ joined
[01:54] <[Coke]> pmichaud: bump away.

[01:54] <[Coke]> nqp-jvm: class A { method barf() } ; say(nqp::can(A, "puke"));

[01:55] <camelia> nqp-jvm: OUTPUT«Routine declaration requires a signature at line 2, near "() } ; say"␤  in panic (src/stage2/gen/NQPHLL.nqp:279)␤  in method_def (src/stage2/gen/NQP.nqp:1117)␤  in routine_declarator:sym<method> (src/stage2/gen/NQP.nqp)␤  in !protoregex (src/stage2/gen/QRegex…»

[01:55] <[Coke]> nqp-jvm: class A { method barf() {} } ; say(nqp::can(A, "puke"));

[01:55] <camelia> nqp-jvm: OUTPUT«0␤»

[01:55] <[Coke]> weird. from reading the code I'd expect that to throw an exception.

[01:56] <[Coke]> nqp-jvm: class A { method barf() {} } ; say(nqp::findmethod(A, "puke"));

[01:56] <camelia> nqp-jvm: OUTPUT«java.lang.NullPointerException␤  in  (src/stage2/gen/NQPCORE.setting:672)␤  in print (src/stage2/gen/NQPCORE.setting:671)␤  in say (src/stage2/gen/NQPCORE.setting:678)␤  in  (/tmp/CGjQpjKx5o:1)␤  in  (src/stage2/gen/NQPHLL.nqp:1098)␤  in eval (src/stage2/…»

[02:02] <diakopter> nqp-m: class A { method barf() {} } ; say(nqp::findmethod(A, "puke"));

[02:02] <camelia> nqp-moarvm: OUTPUT«Method puke not found in cache, and late-bound dispatch NYI␤   at /tmp/vxY1ToM6Nt:2  (<ephemeral file>:frame_name_0:4294967295)␤ from nqp-src/NQPHLL.nqp:1084  (./NQPHLLMoar.moarvm:frame_name_671:97)␤ from nqp-src/NQPHLL.nqp:1070  (./NQPHLLMoar.moarvm:eval:87…»

[02:02] <diakopter> moar++

[02:02] <dalek> nqp: 96ac0ce | coke++ | docs/ops.markdown:

[02:02] <dalek> nqp: document more ops

[02:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/96ac0ce2e4

[02:18] *** jnap left
[02:28] <dalek> nqp/pm-packfile-api: 465b6e4 | pmichaud++ | tools/build/PARROT_REVISION:

[02:28] <dalek> nqp/pm-packfile-api: Bump PARROT_REVISION to require packfile api for EvalPMC.  (Issue #76)

[02:28] <dalek> nqp/pm-packfile-api: review: https://github.com/perl6/nqp/commit/465b6e4395

[02:40] *** BenGoldberg left
[02:46] *** odoacre_ left
[02:58] *** odoacre joined
[03:04] <[Coke]> nqp-jvm: my @a := nqp::split(" ", "a b c"); say(nqp::reprname(@a));

[03:04] <camelia> nqp-jvm: OUTPUT«VMArray␤»

[03:05] *** BenGoldberg joined
[03:06] <JimmyZ> nqp-m: my @a := nqp::split(" ", "a b c"); say(nqp::reprname(@a));

[03:06] <camelia> nqp-moarvm: OUTPUT«VMArray␤»

[03:07] *** ggoebel5 joined
[03:08] *** ggoebel4 left
[03:13] *** d4l3k_ joined
[03:14] <[Coke]> nqp-*: my @a := nqp::split(" ", "a b c"); say(nqp::reprname(@a));

[03:15] *** DrEeevil joined
[03:16] *** Lorn joined
[03:17] *** frettled_ joined
[03:17] *** japhb___ joined
[03:17] *** orevdiabl joined
[03:17] *** larks_ joined
[03:18] *** bloonix_ joined
[03:18] *** ugexe_ joined
[03:18] *** airdisa left
[03:22] *** prammer left
[03:22] *** dalek left
[03:22] *** Lorn_ left
[03:22] *** japhb__ left
[03:22] *** larks left
[03:22] *** hugme left
[03:22] *** ugexe left
[03:22] *** frettled left
[03:23] *** d4l3k_ is now known as dalek

[03:23] *** fgq611 joined
[03:24] *** prammer joined
[03:24] <fgq611> hi

[03:24] *** hugme joined
[03:24] *** fgq611 left
[03:24] *** ChanServ sets mode: +v hugme

[03:27] *** eternaleye left
[03:27] *** eternaleye joined
[03:28] *** BenGoldberg left
[03:30] *** PZt left
[03:42] * [Coke] could use a help on why we have associative_get vs. atkey opcodes (same in jvm)

[03:54] *** preflex_ joined
[03:54] *** ChanServ sets mode: +v preflex_

[03:55] *** preflex left
[03:55] *** preflex_ is now known as preflex

[04:10] <dalek> nqp: 0d90396 | coke++ | docs/ops.markdown:

[04:10] <dalek> nqp: minor formatting updates

[04:10] <dalek> nqp: 

[04:10] <dalek> nqp: mark async* as jvm only for now.

[04:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0d9039674a

[04:10] <dalek> nqp: 5543a71 | coke++ | docs/ops.markdown:

[04:10] <dalek> nqp: doc more ops

[04:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5543a713e6

[04:10] <[Coke]> 169 JVM ops left to document... 

[04:12] <diakopter> [Coke]: moarvm remaps associative_get to atkey_o

[04:13] <[Coke]> what does _o mean?

[04:13] <lue> Is there an easily obtainable list of camelia's compiler: commands?

[04:14] <diakopter> camelia: halp

[04:14] <diakopter> camelia: help

[04:14] <camelia> diakopter: Usage: <(rakudo-jvm|nqp-jvm|star|pugs|nqp|std|niecza|rakudo|b|nqp-moarvm|nom|r|j|nqp-m|nqp-mvm|pnr|p6|nr|npr|n|perl6|rj|prn|rn|r-j|r-jvm|p|rnp|nrp|rpn)(?^::\s) $perl6_program>

[04:15] <lue> duuur :)

[04:16] * [Coke] updates https://gist.github.com/coke/6799633 with a list of nqp ops needing docs or possible implementations on other vms.

[04:16] *** xenoterracide_ joined
[04:16] <[Coke]> -> sleep

[04:17] <lue> .oO(Do we still need b: on the list?)

[04:18] <[Coke]> b: say "I will cut you."

[04:18] <camelia> b : OUTPUT«sh: 1: install/bin/perl6: not found␤»

[04:20] <diakopter> [Coke]: _o means it grabs an object

[04:21] <diakopter> (its output register is an object register)

[04:23] *** [Sno] left
[04:24] *** PZt joined
[04:40] <japhb___> To any jakudo hackers:  Pretty please can I have pipe open?  :-)

[04:51] *** btyler left
[04:57] *** SamuraiJack joined
[05:17] *** sftp_ joined
[05:21] *** sftp left
[05:22] *** Vlavv` left
[05:25] *** sftp joined
[05:26] *** [Sno] joined
[05:27] *** Vlavv` joined
[05:29] *** sftp_ left
[05:34] <moritz> \o

[05:34] <moritz> r: subset Even of Int where * %% 2; multi f(Int) { 'Int' }; multi f (Even) { 'Even' }; say f 42

[05:34] <camelia> rakudo d7e5e1: OUTPUT«Even␤»

[05:42] *** FROGGS left
[05:47] *** xenoterracide_ left
[05:51] *** xenoterracide_ joined
[06:07] *** kaleem joined
[06:14] <masak> mng, #perl6

[06:14] <masak> r: subset Even of Int where * %% 2; subset Quaddy of Int where * %% 4; multi f(Even) { 'Even' }; multi f(Quaddy) { 'Quaddy' }; say f 42

[06:14] <camelia> rakudo d7e5e1: OUTPUT«Even␤»

[06:15] *** japhb__ joined
[06:15] <masak> r: subset Even of Int where * %% 2; subset Quaddy of Int where * %% 4; multi f(Even) { 'Even' }; multi f(Quaddy) { 'Quaddy' }; say f 44

[06:15] <camelia> rakudo d7e5e1: OUTPUT«Even␤»

[06:15] <masak> huh. I thought it would ambiguous-dispatch on me.

[06:16] *** japhb___ left
[06:16] *** jnthn left
[06:16] <masak> r: subset Even of Int where * %% 2; subset Quaddy of Even where * %% 4; multi f(Even) { 'Even' }; multi f(Quaddy) { 'Quaddy' }; say f 44

[06:16] <camelia> rakudo d7e5e1: OUTPUT«Even␤»

[06:16] <masak> :/

[06:16] *** sciurius_ joined
[06:17] *** sciurius left
[06:18] <arnsholt> For a second I was worried you wanted it to infer that Quaddy was stricter. Good that I was mistaken =)

[06:18] *** bloonix_ left
[06:18] *** bloonix joined
[06:20] <masak> arnsholt: no, I'm aware of the depth+epsilon semantics.

[06:20] *** jnthn joined
[06:20] <masak> arnsholt: I'm just not seeing it here as I expect.

[06:22] <masak> TimToady: re http://irclog.perlgeek.de/perl6/2013-10-08#i_7688648:

[06:23] <masak> TimToady: Has Anyone Really Been Far Even as Decided to Use Even Go Want to do Look More Like?

[06:24] <diakopter> masak: 

[06:26] *** darutoko joined
[06:26] *** go|dfish left
[06:26] <masak> LlamaRider: re http://irclog.perlgeek.de/perl6/2013-10-08#i_7688805

[06:27] <masak> LlamaRider: your wish is a common one, but generally it's not a good idea to add arbitrary automatic typecasting rules on top of a type system.

[06:27] *** baest joined
[06:27] <masak> LlamaRider: the WAT makes the DWIM not worth it, most of the time.

[06:27] <masak> baest! \o/

[06:28] <baest> masak: :) \o

[06:31] <masak> LlamaRider: `my Str(Match) @results;` should do what you want.

[06:33] <masak> LlamaRider: you don't need to know what Cool is to understand the above.

[06:35] *** Lorn left
[06:36] *** Lorn joined
[06:36] *** xenoterracide_ left
[06:39] *** prammer left
[06:39] *** prammer joined
[06:40] <masak> j: say 'oh wow'

[06:40] <camelia> rakudo-jvm d7e5e1: OUTPUT«oh wow␤»

[06:40] <masak> j: say $*PERL.perl

[06:40] <camelia> rakudo-jvm d7e5e1: OUTPUT«{"name" => "rakudo", "compiler" => {"codename" => "", "name" => "rakudo", "release-number" => "", "ver" => "2013.09-146-gd7e5e1d", "build-date" => "2013-10-08T19:30:31Z"}}␤»

[06:41] <masak> j: say $*OS.perl

[06:41] <camelia> rakudo-jvm d7e5e1: OUTPUT«"Linux"␤»

[06:41] <masak> j: say $*VM.perl

[06:41] <camelia> rakudo-jvm d7e5e1: OUTPUT«{"name" => "jvm", "properties" => {"java.vm.version" => "24.0-b56", "sun.jnu.encoding" => "UTF-8", "java.vendor.url" => "http://java.oracle.com/", "java.vm.info" => "mixed mode", "user.dir" => "/home/p6eval_eval", "sun.cpu.isalist" => "", "java.awt.graphics…»

[06:41] <masak> awesome.

[06:42] <masak> moritz++

[06:43] *** Lorn left
[06:43] *** xenoterracide_ joined
[06:45] <masak> lizmat: we agree on the expected semantics of :delete, nice.

[06:45] <masak> lizmat: re array slots existing, we don't agree until you say <lizmat> and perhaps we should have a "is sparse" trait on arrays to allow :delete to work

[06:46] <masak> lizmat: basically, I feel that the case for outright removing array slots is much, much weaker for arrays because of their ordering/0..N-1 semantics.

[06:46] *** Lorn joined
[06:47] <masak> lizmat: that is, if all :delete ever did was restore that slot to Any (or whatever default of the array), that would not be surprising to me.

[06:47] <masak> lizmat: the slot winking out of existence would be surprising to me. .elems not returning N would be *very* surprising to me.

[06:48] <masak> lizmat: but most of all, I don't see a use case for that behavior. IMO, sparse arrays in that sense shouldn't be the default. what people want from arrays most of the time is push/pop/shift/unshift, indexing, and maybe slicing/splicing. sparse arrays come very far down on the wishlist.

[06:50] <masak> r: my @a; @a[3] = 1; say @a[^4]:exists

[06:50] <camelia> rakudo d7e5e1: OUTPUT«False False False True␤»

[06:50] <masak> in summary, I'd expect that to say "True True True True".

[06:51] <lizmat> good morning, masak

[06:52] <masak> morning :)

[06:52] <masak> I don't know if that's current consensus semantics -- probably not. and I might change my mind based on more discussion. but talking about array elements "not existing" doesn't seem useful to me.

[06:52] <masak> now, granted, you've been delving deeper into the internals of these things than I have...

[06:53] <masak> ...so you might have some extra insight in it that I'm missing.

[06:53] <moritz> \o

[06:53] <masak> o/

[06:53] <lizmat> If you want those semantice, then :delete would not make an array element unexits

[06:53] <masak> correct.

[06:53] <lizmat> it would merely set it to the default value

[06:53] <masak> right.

[06:53] <masak> that's what I'm arguing for.

[06:53] <masak> same as assigning Nil, then.

[06:53] <lizmat> that was my oriignal avenue of implementation

[06:54] <lizmat> which was vetoed by jnthn

[06:54] <masak> did it run into trouble?

[06:54] <masak> oh!

[06:54] <masak> interesting.

[06:54] <masak> jnthn: ping :)

[06:55] <lizmat> I think the point of :delete is that it well free up the element

[06:55] <lizmat> anyway, first breakfast &

[06:55] *** xenoterracide_ left
[06:56] <lizmat> well, maybe not: 

[06:56] <lizmat> Perl6 makes hashes and arrays a bit more the same

[06:57] <lizmat> hashes have .elems

[06:57] <lizmat> arrays have keys

[06:57] <lizmat> all the adverbs you can use on slices, work on both in a similar way

[06:57] <masak> agreed.

[06:57] <lizmat> if you use arrays just for push/pop/shift/unshift

[06:57] <masak> only question is where the divergence happens. because it does happen.

[06:58] <lizmat> you will never run into the "problem" of missing elements

[06:58] <masak> arrays in Perl 6 are decidedly *not* sparse, like they are in JavaScript.

[06:59] <lizmat> what makes them sparse in JS?  if you iterate over them, the absent elements don't show ?

[06:59] <masak> jnthn and diakopter will know more, but I suspect making the assumption that on a low level they are (or may be) has un-funny performance characteristics.

[06:59] <lizmat> on a low level, something needs to be done anyway

[07:00] <lizmat> if an element is bound to nqp::isnull, you would have to go chase the default value anyway

[07:00] <lizmat> so the performance penalty is already there, really

[07:00] <lizmat> removing absent elements from iterations would actually increase efficiency, I think

[07:01] <masak> lizmat: in JS, arrays are slightly modified hashes/objects. biggest difference is that keys that intify are presented in incresing order.

[07:01] <lizmat> well, fwfw, I can see value in those semantice  :-)

[07:01] *** FROGGS joined
[07:02] <masak> r: my @a; @a[5] = 'hi'; .say for @a

[07:02] <camelia> rakudo d7e5e1: OUTPUT«(Any)␤(Any)␤(Any)␤(Any)␤(Any)␤hi␤»

[07:02] <masak> this is *very* much what I expect as a user.

[07:02] <masak> for the elements to be *iterated* over, even though I didn't fill them with anything.

[07:02] <moritz> agreed

[07:02] <masak> from my perspective, they *exist*.

[07:03] <masak> any notion that says they don't is a *distraction*.

[07:03] <FROGGS> except when they were explicitly deleted?

[07:03] <masak> FROGGS: in my view, that only resets them.

[07:03] <masak> in arrays.

[07:03] <masak> FROGGS: it's really the same situation as the above.

[07:04] <masak> FROGGS: "never filled" vs "just deleted"

[07:04] <FROGGS> yeah, makes sense

[07:04] <masak> if jnthn comes with a bulldozer wanting to tear down my .elems house, I will simply lie down here in the mud, in my bathrobe, until we've talked this through :)

[07:05] <lizmat> I'll stick up my thumb for you

[07:05] <masak> ;)

[07:08] *** denisboyun joined
[07:09] <FROGGS> masak: how do you think about that? https://gist.github.com/rjbs/9cbd2f1841bb8f26faf6

[07:10] <moritz> formats 2.0!

[07:15] <lizmat> really breakfast&

[07:18] * masak looks

[07:19] <masak> honest opinion? it breaks too many parser assumptions in favor of visual cuteness.

[07:19] <timotimo> ohai

[07:19] <masak> timotimo! \o/

[07:20] * moritz doens't reall think that was a serious proposal

[07:20] <FROGGS> masak: do you think so? I think the opener is rather unique

[07:20] <timotimo> the "eqat_internal" op only exists because i don't know how to properly emit a call directly into a pir-bound op when all i have is the $qastcompiler

[07:20] <FROGGS> moritz: but I like it

[07:21] <masak> FROGGS: here's what the parser sees: OPENER string CLOSER LISTOP OPENER string CLOSER SEMICOLON OPENER string CLOSER

[07:21] <FROGGS> because: when you have a block-form-class (in contrast to semicolon form), and your methods are indented, then using heredocs or "abc\n" \n ~ "abc\n" is just ugly

[07:21] <FROGGS> masak: we would just need the lhs

[07:22] <masak> FROGGS: also, I wouldn't want to maintain that code. give me heredocs any day -- they are nicely separated and easy to edit.

[07:22] <masak> that proposal isn't.

[07:22] <FROGGS> but but

[07:22] <masak> :)

[07:22] <FROGGS> I want indentable heredocs!

[07:23] <masak> you have them.

[07:23] <FROGGS> I really don't like this 'END' at the very left

[07:23] <FROGGS> I have?

[07:23] <masak> complaining about the 'END' in heredocs sounds more like misunderstanding heredocs than anything else.

[07:24] <masak> FROGGS: yes, if you indent the 'END', that amount of indentation is removed in the heredoc.

[07:24] <masak> FROGGS: see S02.

[07:24] <FROGGS> ohh, is that so?

[07:24] <FROGGS> hmmm

[07:24] <masak> just so.

[07:25] <timotimo> it used to be slightly crappy with regards to interpolating values, but i made it work superbly!

[07:25] <masak> timotimo++ \o/

[07:25] <timotimo> one of the few of (hopefully many more to come of) my achievements

[07:26] <masak> that's an interesting parenthetical construction.

[07:27] <FROGGS> r: r: say q:to 'END'␤        hallo␤    END␤# so, why do I argue at all?

[07:27] <camelia> rakudo d7e5e1: OUTPUT«    hallo␤␤»

[07:28] <masak> right.

[07:28] <masak> r: we_have_labels: say "yay!"

[07:28] <camelia> rakudo d7e5e1: OUTPUT«yay!␤»

[07:29] <masak> r: one_label: two_labels: say "does this work, then?"

[07:29] <camelia> rakudo d7e5e1: OUTPUT«does this work, then?␤»

[07:29] <masak> huh.

[07:29] <masak> std: one_label: two_labels: say "does this work, then?"

[07:29] <camelia> std a0bcfb1: OUTPUT«ok 00:01 121m␤»

[07:29] <masak> weeeeyrd.

[07:30] <moritz> why does that surprise you?

[07:31] <masak> I guess I mentally have 'statement := label the_rest', not as 'statement := label statement'

[07:32] <masak> does the same hold in Perl 5, ooc?

[07:32] <moritz> p5eval: bla: blub: '42'

[07:32] <p5eval> moritz: 42

[07:32] <masak> seemingly.

[07:32] <moritz> looks like it, yes

[07:32] <masak> ok, I fold on that one, and adjust my expectations :)

[07:38] <timotimo> seems like putting the bounds check where it will always run causes the eqat op to behave correctly in all cases ... who would have thought %)

[07:40] <masak> something making sense? heaven forbid!

[07:44] <FROGGS> timotimo: btw, I moved the bounds check to interp.c, so index(n)at can return -1 for both, "out of bounds" and "not found", and I can properly check that something is not in the string

[07:44] *** daniel-s_ is now known as daniel-s

[07:51] *** sqirrel joined
[07:59] *** fhelmberger joined
[08:03] <dalek> nqp/eqat_op: e77d5ba | (Timo Paulssen)++ | src/vm/parrot/ops/nqp.ops:

[08:03] <dalek> nqp/eqat_op: fix eqat bounds check for good.

[08:03] <dalek> nqp/eqat_op: review: https://github.com/perl6/nqp/commit/e77d5ba584

[08:08] <arnsholt> timotimo: "For good" sounds very definitive =)

[08:10] <masak> maybe it's part of the new "stable spec" regime? :P

[08:10] <moritz> bounds checking of stable spec regions?

[08:10] <timotimo> :)

[08:18] *** go|dfish joined
[08:29] <lizmat> commuting&

[08:29] *** lizmat left
[08:34] *** daxim joined
[08:39] <timotimo> unless somebody teaches me how to emit a QAST that directly calls a pir-based op, i'd put my eqat_op branch up for review & merging

[08:41] <moritz> timotimo: QAST::VM.new(:pirop(...))

[08:41] <timotimo> oh, that seems easy enough

[08:42] <JimmyZ> I thought it's :parrot(...)

[08:42] <moritz> JimmyZ: that's just what a quick 'git grep pirop' in rakudo revealed

[08:50] <masak> ooh, 'git grep'

[08:56] *** woosley left
[08:56] <moritz> seen on twitter: "There are two kinds of people in the world: those who can extrapolate from incomplete data."

[08:57] <timotimo> that was the autopun of the day a few days ago i believe

[08:57] <nwc10> seen on #perl6: http://irclog.perlgeek.de/perl6/2013-10-05#i_7674854

[08:57] <nwc10> so, where did it start?

[08:58] <masak> I saw it on Twitter, too.

[08:58] <nwc10> great Ms think alike?

[08:58] <masak> probably the same tweet.

[08:58] <masak> nwc10: moritz and I are known to be attuned to an unscientific degree. :P

[08:59] <timotimo> note to future and/or past self: "cannot shift from empty array" means: put a second underscore into your pirop

[08:59] <masak> moritz: #58392!

[08:59] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=58392

[08:59] <masak> :)

[08:59] <masak> I can't believe I still remember that ticket number...

[09:00] <moritz> masak: :-)

[09:00] <masak> ah, memories...

[09:00] <dalek> rakudo/nom: 06556e9 | moritz++ | src/core/ (2 files):

[09:00] <dalek> rakudo/nom: get "is default" working in the setting

[09:00] <dalek> rakudo/nom: 

[09:00] <dalek> rakudo/nom: and use it to get rid of some postcircumfix:<[ ]> candidates.

[09:00] <dalek> rakudo/nom: Adventurous minds can get rid of many more

[09:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/06556e9e1b

[09:01] *** donaldh joined
[09:01] <moritz> ok, I'm kinda scared. Rakudo spectest has 5 failing test files

[09:01] <moritz> that's... way more than usual

[09:01] <masak> :/

[09:01] *** dakkar joined
[09:03] <moritz> and they all die the same that Mu.[0] does on my machine (OOM + attempted coredump)

[09:04] <DrEeevil> ... ulimit to the rescue!

[09:04] <DrEeevil> (srsly)

[09:04] <timotimo> that's not the rescue, to be honest

[09:04] <moritz> DrEeevil: yes, I have a ulimit of 2GB virtual memory set

[09:04] <DrEeevil> well, it avoids OOM-killer and associated pain

[09:04] <moritz> DrEeevil: which is good, because otherwise it'd kill my desktop

[09:04] <DrEeevil> ah :)

[09:04] <moritz> DrEeevil: BUT IT DOESN'T MAKE THE TESTS PASS

[09:04] <DrEeevil> :(

[09:08] <dalek> nqp/moarboot: da02211 | (Tobias Leich)++ | / (12 files):

[09:08] <dalek> nqp/moarboot: un-hang qregex tests due to indexnat op

[09:08] <dalek> nqp/moarboot: 

[09:08] <dalek> nqp/moarboot: Test is not clean though. There seems to be three issues:a) a heisenbug

[09:08] <dalek> nqp/moarboot: b) an issue resolving frame labels and c) a problem with "baabbbb" ~~ /a**2..4/

[09:08] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/da02211e19

[09:09] <moritz> we do NAT for indexes?

[09:10] <timotimo> i wish we had instruction pointer v6

[09:10] *** darutoko- joined
[09:10] <FROGGS> moritz: yes, unless you bridge' it :o)

[09:11] * moritz wants VLANs too

[09:11] <FROGGS> hmmm, so we need to tag our strings

[09:11] <JimmyZ> NAT vs Bridge?

[09:13] *** darutoko left
[09:14] <moritz> JimmyZ: aye

[09:15] <masak> interesting reading: http://www.oftenpaper.net/sierpinski.htm -- more about the Sierpinski triangle than I've ever seen in one place.

[09:15] <masak> too much to take in in one reading.

[09:16] <masak> HN comments: https://news.ycombinator.com/item?id=6516114

[09:16] <masak> "There's so much in here, they even have a cow which fires lasers being dropped from a space shuttle."

[09:20] *** pecastro_ is now known as pecastro

[09:21] * moritz thinks he found a bug in the rakudo multi dispatcher

[09:23] *** zakharyas left
[09:24] <moritz> I have

[09:24] <moritz> multi sub postcircumfix:<[ ]>( \SELF, $pos ) is rw is default {

[09:24] <moritz> and

[09:24] <moritz> multi sub postcircumfix:<[ ]>( \SELF, $pos, *%adv )

[09:24] <moritz> and it complains   Unexpected named parameter 'exists' passed

[09:24] <moritz> with the line number of the first candidate

[09:25] <moritz> OH

[09:25] * moritz finds his error, and stops blaming the good ol' dispatcher

[09:25] <moritz> erm, not

[09:25] * moritz confused

[09:26] <masak> moritz: did you see http://irclog.perlgeek.de/perl6/2013-10-09#i_7691647 ? do you agree that's a rakudobug? do you know if it's filed already?

[09:30] <moritz> r: subset Even of Int where * %% 2; subset Quaddy of Int where * %% 4; multi f(Quaddy) { 'Quaddy' }; multi f(Even) { 'Even' }; say f 44

[09:30] <camelia> rakudo 06556e: OUTPUT«Quaddy␤»

[09:31] <moritz> masak: it prefers the textually first

[09:31] <moritz> masak: which I dimly recall being intentional, but I'm not sure at all

[09:33] <masak> yeah, I thought it would be something like that.

[09:33] *** bbkr joined
[09:33] *** bbkr left
[09:34] *** bbkr joined
[09:34] <masak> I've heard arguments for that behavior. in this situation, it feels like a fairly crappy failure mode.

[09:35] <moritz> iirc it being used for regexes

[09:36] <moritz> S05: "If the alternatives are in the same grammar file, the textually earlier alternative takes precedence"

[09:36] <masak> yes, S12:1238 discusses exactly this.

[09:36] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_1238

[09:37] <masak> it's because Even and Quaddy both have constraints that they are preferred in textual order.

[09:37] <masak> but it's weird to me. intuitively, it feels to me that basing Quaddy on Even should make it strictly more narrow.

[09:38] <masak> i.e. in a way that the "epsilon" model doesn't catch.

[09:38] <moritz> so, if two multis come from the same source file, you never get an ambiguous dispatch?

[09:38] <moritz> masak: yes, that would require counting epsilons, not just boolean presence of epsilons

[09:41] <masak> no, I'm not talking about counting epsilons. having to do that would be bad, I agree.

[09:41] <masak> but a type match consists of a "nominal" part and a "procedural" (?) part.

[09:42] <masak> to me, saying `subset Quaddy of Even` makes Even part of the nominal part, and so its epsilon "disappears", and we can say "Quaddy is narrower than Even" without having to resort to epsilons.

[09:42] <moritz> yes, but the Even isn't a nominal type

[09:42] <moritz> because you have to run Perl 6-level code to type-check it

[09:43] <masak> what I want to say is that for the purposes of narrowness checking between Even and Quaddy, it ought to be a nominal type.

[09:43] <masak> i.e. it would make us type things better with no negative side effects.

[09:43] <moritz> but it can't be, because nominal types are always types that can topo-sorted

[09:44] <moritz> *can be

[09:44] <moritz> maybe they could be, if one was sufficiently clever

[09:45] *** grondilu joined
[09:45] <masak> I posit that they can be, in this case.

[09:45] <masak> because we're explicitly *saying* "Quaddy is based on Even".

[09:45] <masak> there's no guessing needed.

[09:45] <moritz> S06/Signature Introspection/ talks about that, fwiw

[09:47] <masak> moritz: the 'Odd of Int' part?

[09:52] <masak> I don't see it as talking about that in particular. if we went on to do 'VeryOdd of Odd', it would be talking about that.

[09:53] <masak> to be clear, I don't exclude the possibility that there is a very good reason not to treat 'Even' as a nominal type in this case. if there is, jnthn will probably point it out to me in excruciating clarity. :)

[09:54] <masak> but I don't buy "we just don't treat subtypes as nominal types" as a strong enough reason.

[09:56] *** sqirrel left
[09:58] <masak> btw, s/procedural/constraint/ in what I said above.

[10:08] *** FROGGS left
[10:14] *** sqirrel joined
[10:17] *** woosley joined
[10:18] <moritz> masak: well, the 'Odd of Int' part talks specifically about Odd not being a nominal type

[10:30] *** FROGGS joined
[10:33] <masak> moritz: yes, but in the context of deconstructing it in a signature.

[10:33] <masak> moritz: I'm talking in the context of asserting type narrowness.

[10:34] <masak> though, hm.

[10:34] <masak> I do see that they're related.

[10:35] *** ivanshmakov left
[10:35] <moritz> type narrowness is nominal ordering + epsilons

[10:35] <moritz> and both 'Odd' and 'Quad' are nominal Int + epsilon

[10:38] *** ivanshmakov joined
[10:38] *** lichtkind joined
[10:44] <masak> yeah.

[10:44] <masak> thinking some more of it.

[10:44] <masak> I don't think I'll be able to change that...

[10:45] *** sqirrel left
[10:46] <dalek> nqp: 7d220ef | moritz++ | tools/build/Makefile-JVM.in:

[10:46] <dalek> nqp: give JVM Makefile an optional DESTDIR

[10:46] <dalek> nqp: 

[10:46] <dalek> nqp: ... as proposed by (Gerd Pokorra)++

[10:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7d220efaf1

[10:48] *** stevan_ left
[10:49] *** stevan_ joined
[11:04] *** dansamo joined
[11:05] *** salv0 left
[11:06] *** salv0 joined
[11:06] *** ggoebel6 joined
[11:09] *** ggoebel5 left
[11:09] *** FROGGS left
[11:25] *** FROGGS joined
[11:38] *** hummeleB1 left
[11:44] *** FROGGS left
[11:53] *** Rotwang joined
[11:56] <masak> only nominal types get storted into the type DAG, once and for all at, hm, CHECK time, I guess.

[11:56] <masak> sorting constraint types into the DAG doesn't make sense, because they have a runtime component.

[11:57] *** risou_awy left
[11:58] <masak> the talk about epsilon is kind of about giving the constraint types a placeholder place in the DAG.

[11:58] <masak> so 'Even' and 'Quad' would both hang off of 'Int', in a conceptual sense.

[12:02] <japhb__> (Specifically without looking at the spec, to keep an innocent mind) I don't buy that.  Your argument that "subset" is defining an ordering relationship between two types makes way more intuitive sense.

[12:05] <japhb__> I can see that defining Even and Quaddy as subsets of Int would make Even and Quaddy non-comparable, but if Quaddy is a subset type of Even, then it doesn't make sense for them *not* to be comparable.

[12:08] <moritz> japhb__: currently we have the nice design property that everything that can be ordered at compile time can also be check at compile time

[12:08] <masak> japhb__: yes, the intuitive line is what I'm arguing here.

[12:08] <moritz> we'd lose that if started with relative ordering of subset types

[12:08] <masak> moritz: and my argument hinges on this being possible at compile time.

[12:08] <arnsholt> moritz: That patch aboe is related to #110, right?

[12:09] <masak> moritz: it's just... it would be different than what we currently have. whether that would break anything we like, is the important question.

[12:09] <moritz> arnsholt: it's first of all related to an email that gerd sent me

[12:09] <masak> what I'm arguing could be framed as a slightly later binding of some things (but still compile time), or, equivalently, retaining some more information that makes intuitive sense for the developer.

[12:10] *** darutoko joined
[12:10] <moritz> masak: I'm sure it would make the dispatcher more complex. No idea if that's worth it

[12:11] <masak> *nod*

[12:11] <masak> I guess my fundamental issue is that I don't like the tiebreaking mechanism for multi subs, whether or not it makes sense for grammars.

[12:12] <masak> and being slightly smarter with subtypes would fix that for this case, at least.

[12:13] *** darutoko- left
[12:15] *** skids left
[12:16] <japhb__> Is rakudo-jvm fully supported by panda at this point?

[12:22] <donaldh> japhb__: It should be. Unless something has regressed in the last month.

[12:24] <japhb__> donaldh: OK, thanks.

[12:24] *** nyuszika7h left
[12:24] <pmichaud> good morning, #perl6

[12:24] <japhb__> o/

[12:24] <moritz> good am, pm

[12:25] <pmichaud> anyone have an objection to bumping PARROT_REVISION?  It's currently set to REVISION_5_5_0 .

[12:25] *** nyuszika7h joined
[12:26] <masak> no objection.

[12:27] <masak> let's just hope there's an October Parrot release, otherwise the NQP release process will enter an impossible state :)

[12:27] *** nyuszika7h left
[12:27] <pmichaud> I've been assured there will be an October Parrot release.

[12:27] <pmichaud> I'm okay with waiting for it to occur to bump PARROT_REVISION, though.

[12:28] <masak> doesn't preclude testing Rakudo/NQP before that, of course.

[12:28] *** nyuszika7h joined
[12:28] <japhb__> Who could I bribe to implement read pipes in rakudo-jvm?  I've got a use case involving concurrency and read pipes that is enough on my mind to wake me up at 4 AM.

[12:29] <hoelzro> pipes++

[12:29] <japhb__> (I'm not sure whether I care about this more because I want the program to work, or because I want to sleep through the night ....)

[12:30] <masak> :)

[12:37] <arnsholt> japhb__: Have we made any real progress on NQP #101?

[12:37] <donaldh> japhb__: the primitives are there, just no pipe implementation in rakudo yet.

[12:38] *** zakharyas joined
[12:39] <donaldh> japhb__: when you say read pipes, do you mean openpipe('cmd') then read...

[12:40] <japhb__> arnsholt: 1) Link?  2) I'm the wrong person to ask.  I've only recently gotten perl6-shaped tuits back.

[12:40] *** pmurias joined
[12:40] <pmurias> hi

[12:41] <japhb__> donaldh: Well, 'my $pipe = open $command, :w, :p; my @lines = $pipe.lines;', but yeah.

[12:41] <arnsholt> japhb__: https://github.com/perl6/nqp/issues/101

[12:41] *** nyuszika7h left
[12:41] <arnsholt> I'm asking because you're the submitter =)

[12:42] *** denisboyun left
[12:42] *** nyuszika7h joined
[12:43] <donaldh> japhb__: yep, NYI in rakudo, but the nqp::openpipe op is available on JVM.

[12:43] <japhb__> Oh, you're asking if I can add that test to perl6-bench?  Yeah, I could find some tuits for that.

[12:43] <japhb__> donaldh: ooh, that's tantalizingly close.

[12:44] <arnsholt> A test in perl6-bench would be cool. I was mostly asking in case you knew if we had made progress or not

[12:44] <japhb__> When I did pipe-open for rakudo-parrot, it was pretty much exposing already-existing functionality then, too.

[12:44] <arnsholt> I'm doing some autumn cleaning in the NQP issues queue =)

[12:45] <japhb__> arnsholt++ # cleaning the queue

[12:46] <japhb__> No, I don't happen to know, but that would be very worth investigating.

[12:46] <donaldh> japhb__: fwiw, qx{$cmd} works on JVM.

[12:46] <japhb__> I wonder how much could be gained by applying the same sort of transforms done recently to the Perl6 grammar.

[12:47] <japhb__> donaldh: hmmm.  I suppose I could split the lines myself ....

[12:47] *** Rotwang left
[12:48] <japhb__> That would only help me for the subprocesses that follow the "think think think ... produce all output at once" model, rather than the "think, partial output, think, partial output" model

[12:49] <donaldh> indeed.

[12:50] <pmichaud> 12:28 <masak> doesn't preclude testing Rakudo/NQP before that, of course.

[12:50] <pmichaud> well, the reason for bumping PARROT_REVISION would of be to introduce a backwards-incompatible change in NQP :-/

[12:50] <pmichaud> s/of//

[12:51] <pmichaud> I suppose I could do the bump without introducing the nqp change and have it tested that way.

[12:51] <pmichaud> I'll do that.

[12:52] * donaldh just completed panda bootstrap on rakudo JVM # it still works

[12:54] <japhb__> donaldh: Yeah, once you said it works, I did that, did some searches, and installed a couple modules.  Looked to be working.  I haven't actually tested that the installed modules were working properly, mind ... but I'm hopeful.  :-)

[12:55] <dalek> nqp: 1441a25 | pmichaud++ | tools/build/PARROT_REVISION:

[12:55] <dalek> nqp: Bump PARROT_REVISION to prepare for pm-packfile-api merge.

[12:55] <dalek> nqp: 

[12:55] <dalek> nqp: Parrot will be switching from EvalPMC to PackfileView; for testing

[12:55] <dalek> nqp: we'll go ahead and bump PARROT_REVISION to get some testing of

[12:55] <dalek> nqp: nqp/rakudo prior to merging the pm-packfile-api branch that can

[12:55] <dalek> nqp: handle the switch.

[12:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1441a25cf2

[12:55] *** lizmat joined
[12:56] *** benabik left
[12:57] *** benabik joined
[12:58] * donaldh remembers why he didn't finish implementing IO::Pipe.

[12:58] <japhb__> donaldh: oh?

[12:58] * donaldh wanted Rakudo::Debugger and got distracted by that. And then got distracted by performance and heap usage on JVM.

[12:59] <japhb__> heh

[12:59] * donaldh is still distracted by peformance.

[13:00] <japhb__> It's a good thing to be spending time on ....

[13:00] <donaldh> oh, jnthn++ fixed Rakudo::Debugger on JVM. 

[13:00] * donaldh ==> Successfully installed Rakudo::Debugger

[13:00] * lizmat is just distracted while gazing at the Irish Sea

[13:03] <japhb__> Looks like it tried to run parrot while installing Rakudo::Debugger for JVM, huh.

[13:07] *** hummeleB1 joined
[13:09] * masak read that as "while grazing at the Irish Sea"... o.O

[13:15] *** SamuraiJack left
[13:15] <donaldh> yeah, it's not quite there. It does compile CommandLine.pm to jar but there's no easy mechanism to compile perl6-debug.nqp and no magic shell script wrapper to give a handy perl6-debug 

[13:16] <jnthn> afternoon, #perl6

[13:16] <yoleaux> 09:14Z <FROGGS> jnthn: the indexnat op is now in master/moarboot, if you want to uncover the gc-bug just strip the "# heisenbug!!!" comments

[13:16] <lizmat> .oO( why am I reminded of Copy On Write ?)

[13:17] <jnthn> donaldh: I hand-hacked the perl6-debug build while getting it working

[13:18] <jnthn> Still needs build stuff doing for JVM

[13:18] <jnthn> But I fixed the other bits, at least.

[13:18] <dalek> perl6-roast-data: 188539e | coke++ | bin/rakudo.jvm.sh:

[13:18] <dalek> perl6-roast-data: Don't use eval server for rakudo.jvm

[13:18] <dalek> perl6-roast-data: 

[13:18] <dalek> perl6-roast-data: Avoids condition where the invocations using the same server would start

[13:18] <dalek> perl6-roast-data: to fail at some point, with occasional information about an OOME.

[13:18] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/188539e959

[13:18] <dalek> perl6-roast-data: ba6d5f7 | coke++ | / (3 files):

[13:18] <dalek> perl6-roast-data: today (automated commit)

[13:18] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ba6d5f7c1b

[13:18] <jnthn> Basically, you need to compile perl6-debug.nqp using nqp but run with the same settings as perl6 is

[13:19] <jnthn> And then make a runner that looks similar 

[13:19] *** PacoAir joined
[13:20] <jnthn> [Coke]: wow, JVM at 99.90% :D

[13:22] <Ulti> up from 61.42% two days ago impressive! 

[13:23] <timotimo> jnthn must have done something while we weren't looking

[13:23] *** pmurias left
[13:24] <jnthn> No, [Coke]++ switched it over to not use the evalserver 

[13:27] <jnthn> masak: The "don't go for textually first match" with multis has already been argued against; I had Rakudo try them all and complain on ambiguity. I lost that argument. So, we've already done this design decision, I think.

[13:28] <jnthn> masak: So, textually first matching constraint wins.

[13:28] <masak> aye :/

[13:29] <jnthn> If you're struggling to express what you want in multi-dispatch rules, you probably should just use a different language construct.

[13:30] <lizmat> r: my @a=^10; say @a[my int $a=4]:kv   # moritz, your patch broke stuff, which apparently isn't picked up by the spectest

[13:30] <camelia> rakudo 06556e: OUTPUT«Unexpected named parameter 'kv' passed␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2243␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2240␤  in block  at /tmp/2WtH4D8yHN:1␤␤»

[13:30] *** bluescreen10 joined
[13:30] <lizmat> apparently, [4] does not select the [int $pos] candidate

[13:30] <masak> jnthn: not struggling; just seeing how it could have ever so slightly better reach if it worked differently.

[13:31] <jnthn> masak: Yeah, but the more complex we make the dispatch rules, the harder it is to understand/teach/explain/debug.

[13:32] <jnthn> The fact that *I* can't tell you what the exact arity-related rules are right now 'cus they've evolved out of people's ideas of what should work, is probably already enough reason to worry. :)

[13:33] <dalek> rakudo/nom: dfe582d | pmichaud++ | tools/build/NQP_REVISION:

[13:33] <dalek> rakudo/nom: Bump NQP_REVISION to get PARROT_REVISION update.

[13:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dfe582d964

[13:34] <pmichaud> feel free to revert that commit if things go bad.

[13:35] <lizmat> moritz:I reverted your patch locally, but cannot push while at sea (apparently)

[13:35] <lizmat> I guess the satellite doesn't want to know github  :-)

[13:37] <jnthn> pmichaud: That's for the "just spit out a PBC" change/

[13:37] <jnthn> ?

[13:37] <lizmat> jnthn: if I say @a[0] (using a literal integer number as an index), shouldn't that select the native int $pos candidate in src/core/array_slice ?

[13:37] <pmichaud> jnthn: eventually, yes.

[13:38] <jnthn> lizmat: Not sure

[13:38] <pmichaud> jnthn: more importantly, it (along with the pm-packfile-api branch in nqp) future-proofs us for whenever Parrot makes the switch to PackfileView

[13:38] <jnthn> lizmat: We have to be careful with those things.

[13:38] <jnthn> pmichaud: ah, ok

[13:38] <jnthn> lizmat: If somebody passes something declared as a native int we're all good

[13:38] <pmichaud> if Parrot makes that switch before we're ready, then nqp/parrot bootstrap gets really complicated

[13:38] *** lowpro30 joined
[13:39] <jnthn> lizmat: If we just assume it's good to pass things native, we might end up with huge overhead it we're passing it to a thing that boxes

[13:39] <jnthn> lizmat: 'cus it'd then go and box it on every single call

[13:39] <lizmat> but this is about a *candidate* that uses native int as a parameter

[13:39] <jnthn> lizmat: So at present things tend to lean in a "pass the boxed thing from the constant pool"

[13:39] <jnthn> lizmat: Right, which means that compile-time analysis isn't smart enough to pick the native candidate yet.

[13:40] *** benabik left
[13:40] <jnthn> lizmat: I'll have to spend some time looking at why that is. I thought we'd followed enough of the "rules" wrt to the named params for it to get it already...

[13:40] <lizmat> ah, so you're saying, once we start optimizing [] access calls, *then* the candidate with the native int would be selected

[13:40] <pmichaud> jnthn: if you could briefly review https://github.com/perl6/nqp/commit/cbd4843043c3466421b0ca4d81ff9c4076994ed7 and let me know if you see a problem with it.

[13:40] <jnthn> lizmat: Yes, then we can certainly do it. 

[13:41] <masak> jnthn: "death by a thousand good ideas", yes, sure.

[13:41] <lizmat> the thing is, that the current spectests are *not* checking the native int candidate at oresent

[13:41] <pmichaud> the .all_subs() and .is_initialized() methods were added to EvalPMC yesterday.

[13:41] <jnthn> lizmat: Does my int $x = ...; @a[$x] hit them?

[13:41] <lizmat> present, which is why moritz didn't see he broke things

[13:42] <lizmat> yup

[13:42] <jnthn> pmichaud: I assume "load" is still triggered automatically by loadbytecode?

[13:42] <lizmat> r: my int $x=4; my @a=^10; say @a[$x]:kv

[13:42] <camelia> rakudo 06556e: OUTPUT«Unexpected named parameter 'kv' passed␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2243␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2240␤  in block  at /tmp/40DCAjRktq:1␤␤»

[13:42] <pmichaud> afaik, yes.

[13:42] <jnthn> pmichaud: anyway, looks like the right change in the right place

[13:42] <pmichaud> I did test the packfile branch of Parrot and all Rakudo spectests pass.

[13:42] <pmichaud> (with these patches in place)

[13:43] *** btyler joined
[13:43] <jnthn> And you didn't need to change NQP and Rakudo anywhere, just HLL::Backend::Parrot?

[13:43] *** kaleem left
[13:43] <pmichaud> HLL::Backend::Parrot, and updated nqp stage0 files

[13:43] <jnthn> Great, that's how I thought it'd be

[13:43] <jnthn> Better than before, when both NQP and Rakudo needed identical changes :)

[13:44] <pmichaud> yeah, I didn't change anything in Rakudo.

[13:44] <pmichaud> well, other than NQP_REVISION :-P

[13:44] <jnthn> ;)

[13:44] *** lowpro30_ joined
[13:47] <jnthn> pmichaud: Think we're on course for MoarVM backend support in this month's NQP release too :)

[13:48] *** lowpro30 left
[13:48] <hoelzro> happy birthday to October birthday-having Perl 6 enthusiasts, then =)

[13:48] *** darutoko left
[13:48] *** kaare_ joined
[13:48] <donaldh> jnthnL I ain't going to get to priorInvocation before the 18th Oct.

[13:48] <donaldh> jnthn: even

[13:49] *** SmokeMachine joined
[13:49] <jnthn> donaldh: np

[13:50] <donaldh> jnthn: I've not figured out how the Moar priorInvocation removal would translate across to JVM and I go on vacation tomorrow.

[13:50] <jnthn> donaldh: Well, plus we have the added fun that after removing it, we need to work out how that affects Rakudo too :)

[13:51] *** ajr joined
[13:51] *** ajr is now known as Guest87327

[13:51] <PerlJam> greetings #perl6 people

[13:52] *** Guest87327 is now known as ajr_

[13:52] <donaldh> jnthn: I reckon it is beyond my current skill level in NQP guts.

[13:53] <masak> PerlJam! \o/

[13:53] *** darutoko joined
[13:54] <PerlJam> masak!  :)

[13:59] <dalek> Perlito: a64c91d | (Flavio S. Glock)++ | / (3 files):

[13:59] <dalek> Perlito: Perlito5 - grammar - optimizer fix

[13:59] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/a64c91d312

[14:01] <jnthn> donaldh: It is kinda fiddly.

[14:08] *** prevost joined
[14:12] <pmichaud> o/ PerlJam

[14:14] *** bluescreen100 joined
[14:15] <donaldh> japhb__: This was my previous hack on IO::Pipe https://gist.github.com/donaldh/6901992

[14:17] <PerlJam> pmichaud: greets! 

[14:17] <donaldh> japhb__: I realised that to align with the spec would require a refactor of IO to some extent.

[14:18] <diakopter> I think that was the longest 8 hour backlog ever, by a few multiples

[14:18] <yoleaux> 09:14Z <FROGGS> diakopter: the indexnat op is now in master/moarboot, if you want to uncover the gc-bug just strip the "# heisenbug!!!" comments

[14:18] *** bluescreen10 left
[14:19] <pmichaud> 13:47 <jnthn> pmichaud: Think we're on course for MoarVM backend support in this month's NQP release too :)

[14:19] <pmichaud> wow.

[14:19] <pmichaud> won't the nqp release be a week from tomorrow?

[14:20] <jnthn> Sounds about right

[14:20] <diakopter> pmichaud: did you see the camelia nqp-mvm target? :)

[14:21] <diakopter> (moritz++)

[14:21] <jnthn> We could in theory merge moarboot now, though probably good to fix the heisenbug first...

[14:22] <diakopter> heisenbug(s) of course

[14:22] <diakopter> (my name is legion, for we are many)

[14:23] <pmichaud> diakopter: I didn't see the nqp-mvm target yet, no.  I'm still waaaay behind on a lot of things.

[14:23] <diakopter> nqp-m: say('hi pmichaud it is moar');

[14:23] <camelia> nqp-moarvm: OUTPUT«hi pmichaud it is moar␤»

[14:24] <pmichaud> moar roars

[14:24] <pmichaud> Let's hear it for the Mother of All Runtimes!   :-P

[14:24] <lizmat> nqp-m: say("moar") xx 10

[14:24] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say(\"moar\""␤panic»

[14:25] <lizmat> :-(

[14:25] <lizmat> nqp-m: say("moar") for ^10

[14:25] <camelia> nqp-moarvm: OUTPUT«Confused at line 2, near "say(\"moar\""␤panic»

[14:25] <pmichaud> nqp is not quite Perl.

[14:25] <jnthn> lizmat: *nqp* :P

[14:25] <PerlJam> .oO( with a rebel yell, she cried, "moar! moar! moar!" ;-)

[14:25] <grondilu> xx is not defined in NQP, is it?

[14:25] <jnthn> pmichaud: Gah, that backronym :P

[14:25] <pmichaud> PerlJam: you're my idol.

[14:25] <lizmat> nqp-m: for 0..9 { say('moar') }

[14:25] <camelia> nqp-moarvm: OUTPUT«Missing block at line 2, near "..9 { say("␤panic»

[14:26] <pmichaud> no xx, no ..

[14:26] <lizmat> nqp-m: for 0,1,2,3,4,5,6,7,8,9 { say('moar') }

[14:26] <camelia> nqp-moarvm: OUTPUT«moar␤moar␤moar␤moar␤moar␤moar␤moar␤moar␤moar␤moar␤»

[14:26] <lizmat> *phew*

[14:26] <PerlJam> perhaps nqp should be called "impoverished perl"

[14:26] <pmichaud> PerlJam: not quite.

[14:26] * masak googles and gets "Billy Idol"

[14:26] <masak> TIL. :)

[14:27] * pmichaud wonders what google query produced "Billy Idol"  :-)

[14:27] <PerlJam> probably "with a rebel yell" would be enough

[14:27] <pmichaud> yeah

[14:27] <masak> pmichaud: actually it was duckduckgo, and "with a rebel yell she cried"

[14:29] *** skids joined
[14:29] <pmichaud> masak: wfm

[14:29] <pmichaud> I guess PerlJam and I are showing our age with that one.

[14:30] <PerlJam> speak for yourself old man  

[14:31] <masak> :)

[14:31] * lizmat mumbles "eyes without a face"

[14:31] <masak> or I should just listen to more Billy Idol.

[14:33] * lizmat considers copying ~200 tests just to make sure the native int candidates for [] and {} are tested

[14:33] <pmichaud> lizmat: +1

[14:33] <PerlJam> lizmat: Can't hurt ... much.

[14:33] <jnthn> tests++

[14:33] <pmichaud> if they can (should) take different code paths, worth testing.

[14:33] <jnthn> Well, adding tests for something we *know* got accidentally regressed certainly sounds a good idea.

[14:34] <arnsholt> pmichaud: Do you have any thoughts on NQP #110? IIRC you wrote most of the config stuff, no?

[14:34] * pmichaud looks.

[14:34] *** zakharyas left
[14:34] <lizmat> .oO( would be nice if I could use macro's for that )

[14:35] <diakopter> nqp-m: my$a:=1000000;say('foo')while $a--

[14:35] <camelia> nqp-moarvm: OUTPUT«foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤…»

[14:35] <diakopter> nqp-m: my$a:=500000;say('foo')while $a--

[14:35] <camelia> nqp-moarvm: OUTPUT«foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤…»

[14:35] <diakopter> nqp: my$a:=500000;say('foo')while $a--

[14:35] <camelia> nqp: OUTPUT«foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤f…»

[14:35] <diakopter> d'oh. was trying to find where each times out

[14:35] <pmichaud> arnsholt: my plan for the summer was to fix up the entire build/config subsystem

[14:36] <pmichaud> but my summer got hosed

[14:36] <lizmat> r: my int $x=4; say $x.WHAT  # Int??? not int ?

[14:36] <camelia> rakudo dfe582: OUTPUT«(Int)␤»

[14:36] *** blah joined
[14:36] <jnthn> lizmat: .WHAT forces boxing.

[14:36] <lizmat> is that because .WHAT will coerce the int 

[14:36] <lizmat> ok

[14:36] <pmichaud> r: my int $x=4; say WHAT($x); # curious

[14:37] <camelia> rakudo dfe582: OUTPUT«(Int)␤»

[14:37] *** blah left
[14:37] <jnthn> I think that just becomes .WHAT in the end

[14:38] <lizmat> sub WHAT(\x) { x.WHAT }

[14:39] <japhb__> masak: Yes, more Billy Idol is the appropriate response.  :-)

[14:40] <pmichaud> arnsholt: my thoughts on #110 are essentially that I hope the entire rakudo/nqp configure+build system will get a substantial refactor, but I don't know exactly when that will take place.

[14:40] <PerlJam> WHAT boxing is just an implementation detail that'll go away once WHAT becomse a macro, right?

[14:41] <pmichaud> things become even more interesting when we add moarvm to the mix.

[14:41] <jnthn> PerlJam: It already is macro-like

[14:41] <jnthn> PerlJam: That doesn't change the fact that WHAT is an object-model operation.

[14:41] <jnthn> PerlJam: Meaning that it needs an object

[14:41] <PerlJam> okay, that's why I was asking.

[14:42] <japhb__> donaldh: Can you explain what you mean by needing to refactor IO to align IO::Pipe with spec?

[14:43] <masak> japhb__: understood. will fix.

[14:43] *** pmurias joined
[14:43] *** benabik joined
[14:44] <pmurias> pmichaud: re build system, having a unified build system for nqp would be helpfull for nqp-js

[14:44] *** rindolf joined
[14:44] <japhb__> donaldh: Does nqp::openpipe always open a R/W pipe?

[14:45] <pmichaud> pmurias: yes, that also -- thanks for reminding me.

[14:45] *** jnap joined
[14:46] *** kaleem joined
[14:47] <lizmat> so what *is* the shortest way to force '4' to a native int?

[14:47] <pmurias> work on nqpjs should resume once I get an internet access in my room instead of having to hang around in the university corridors for free wifi ;)

[14:47] <lizmat> the shortest I could come up with, was "my int$=4"

[14:48] <diakopter> tha'ts the only one I knew of

[14:48] <masak> std: my int$=4

[14:48] <camelia> std a0bcfb1: OUTPUT«ok 00:01 123m␤»

[14:49] <jnthn> lizmat: Think that's it

[14:50] <TimToady> I know, let's define a postfix i for that :P

[14:50] <lizmat> Wouldn't that make things very complex ?

[14:51] <TimToady> so I imagine

[14:51] <jnthn> bah, the parser can just read the programmer's mind, right?

[14:52] <diakopter> if we're dumb enough

[14:52] *** darutoko- joined
[14:53] * masak .oO( new advances in artificial stupidity )

[14:55] <lizmat> r: ub postfix:<n> (\x) { my int $ =x }; my @a=^10; say @a[my int $=4]:kv   # sigh, returns a boxed int, so no error

[14:55] <camelia> rakudo dfe582: OUTPUT«===SORRY!=== Error while compiling /tmp/tlTv47TNiv␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)␤at /tmp/tlTv47TNiv:1␤------> ub postfix:<n> (\x) ⏏{ my int $ =x }; my @…»

[14:55] <lizmat> r: sub postfix:<n> (\x) { my int $ =x }; my @a=^10; say @a[my int $=4]:kv   # sigh, returns a boxed int, so no error

[14:55] <camelia> rakudo dfe582: OUTPUT«Unexpected named parameter 'kv' passed␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2243␤  in sub postcircumfix:<[ ]> at src/gen/CORE.setting:2240␤  in block  at /tmp/hIgf71uvuo:1␤␤»

[14:55] *** darutoko left
[14:55] <lizmat> ah?

[14:55] <lizmat> r: sub postfix:<n> (\x) { my int $ =x }; my @a=^10; say @a[4n]:kv   # sigh, returns a boxed int, so no error

[14:55] <camelia> rakudo dfe582: OUTPUT«4 4␤»

[14:56] <diakopter> nqp subs in moarvm can return native ints but I don't think anything else can

[14:56] <jnthn> They can on other platforms to, but whether they do or not is another matter

[14:56] <jnthn> Oh...

[14:56] <jnthn> On Parrot it forces boxed return

[14:57] <jnthn> On JVM I think it doesn't

[14:57] <jnthn> But if the sub gets inlined it'll probably undo the boxing...

[14:57] <jnthn> lizmat: try putting "returns int" on that postfix

[14:58] * diakopter wonders where to put "returns int"

[14:58] <jnthn> in the cloud!

[14:58] <lizmat> r: sub postfix:<n> (\x) returns int { my int $ =x }; my @a=^10; say @a[4n]:kv  # nope, no diff

[14:58] <camelia> rakudo dfe582: OUTPUT«4 4␤»

[14:58] <jnthn> aww

[14:59] <diakopter> jnthn: I thought jvm always transparently boxed/unboxed returns

[14:59] <diakopter> er, at least Java

[14:59] <jnthn> diakopter: I think it will avoid boxing if the QAST:Op node that makes the call has a :returns(...) set

[14:59] <jnthn> No, you can return natives in Java

[14:59] <TimToady> j: sub postfix:<n> (\x) returns int { my int $ =x }; my @a=^10; say @a[4n]:kv

[14:59] <pmurias> pmichaud: in what direction do you want to bring the build system?

[15:00] <camelia> rakudo-jvm dfe582: OUTPUT«(timeout)»

[15:00] <TimToady> heh

[15:00] <diakopter> d9es n stand for native there?

[15:01] <lizmat> diakopter: yes, that would be the idea

[15:01] <jnthn> lizmat: Why not just declare a my int $x = 4; or so and then use it in the various tests? :)

[15:02] <lizmat> jnthn: I would that for 5, 6 , 7, 8, etc as well

[15:04] *** xenoterracide_ joined
[15:04] <pmichaud> pmurias: not quite sure how to answer that yet

[15:05] <donaldh> japhb__: IO::Handle does IO::FileTestable which does not make a lot of sense for pipes, or sockets for that matter.

[15:06] *** benabik left
[15:06] *** kaleem left
[15:07] <japhb__> donaldh: Ah yes, I see.  So it wasn't a JVM issue, more of a general "this needs refactoring"

[15:07] <donaldh> yep.

[15:08] <donaldh> and, yes, nqp::openpipe opens a rw pipe at the moment.

[15:10] <donaldh> need to explicitly divert in, out, err when using  java.lang.ProcessBuilder.

[15:11] * grondilu notices that 1, [*] ...  appears both in http://rosettacode.org/wiki/Hamming_numbers#Perl_6 and http://rosettacode.org/wiki/Factorial#via_Memoized_Constant_Sequence   He wonders if [*] should not include the degenerate case  [*](),  so that [*] @a would be ([*]()), ([*]@a[0]), ([*]@a[0..1]), ... 

[15:12] *** pmurias left
[15:13] <TimToady> it would be harder to teach

[15:13] <TimToady> and there are probably cases where you don't want it

[15:13] <TimToady> and it's easier to add values than to take them away

[15:14] <grondilu> yeah the third point it the most convincing indeed

[15:17] *** Rotwang joined
[15:18] *** jnap left
[15:19] *** benabik joined
[15:20] <grondilu> I also wonder why we don't have the equivalents of lisp's car and cdr 

[15:20] <TimToady> we do

[15:20] *** jnap joined
[15:20] <grondilu> do we?

[15:20] <TimToady> but you have to cons using =>

[15:20] <TimToady> .key is car, .value is cdr

[15:20] <dalek> roast: 18ff411 | (Elizabeth Mattijsen)++ | S32-array/delete-adverb-native.t:

[15:20] <dalek> roast: Add [] tests for single int candidate and :delete adverb

[15:20] <dalek> roast: review: https://github.com/perl6/roast/commit/18ff4115c6

[15:21] <hoelzro> sub 🚓 (Pair $p) { $p.key }

[15:21] <grondilu> yeah but as you say we have to do the conversion

[15:21] <PerlJam> hoelzro: heh!

[15:21] <lizmat> +138 tests, and that's only for @a[int]:delete and friends

[15:21] *** [Sno] left
[15:21] <grondilu> r: sub cdr(@a) { @a[1..@a.end] }  # I was thinking of this

[15:21] <camelia> rakudo dfe582: ( no output )

[15:21] <jnthn> lizmat: I like how you're pushing up the Rakudo JVM percentage without us actualy fixing anthing :P

[15:22] <lizmat> seems the other []:adverb tests need some flesihng out first

[15:22] <TimToady> grondilu: Lisp lists are not conducive to parallelism

[15:22] <lizmat> jnthn: yw  :)

[15:22] <lizmat> at the expense of niecza and pugs, I might add :)

[15:22] <TimToady> r: my \list = [=>] 1,2,3; say list.value.perl

[15:22] <camelia> rakudo dfe582: OUTPUT«2 => 3␤»

[15:23] <grondilu> oh yeah, I forgot that the conversion is quite easy thanks to [=>]

[15:24] <TimToady> the whole point of making => right associative was to make sure it worked like . in Lisp

[15:24] <grondilu> and how do you do the inverse conversion?

[15:24] <grondilu> r: say flat [=>] 1, 2, 3

[15:24] <camelia> rakudo dfe582: OUTPUT«1 => 2 => 3␤»

[15:25] <jnthn> r: say ([=>] 1, 2, 3)>>.value # maybe, depends on nodal stuff I guess

[15:25] <camelia> rakudo dfe582: OUTPUT«("1" => 3).hash␤»

[15:25] * grondilu thinks and does not see any simple way

[15:25] <jnthn> oh, wait...no

[15:26] <dalek> rakudo/nom: 2df2426 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[15:26] <dalek> rakudo/nom: Revert "get "is default" working in the setting"

[15:26] <dalek> rakudo/nom: 

[15:26] <dalek> rakudo/nom: This breaks the @a[my int $a=4]:adverb case  :-(

[15:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2df2426417

[15:26] <dalek> rakudo/nom: 50cecfd | (Elizabeth Mattijsen)++ | t/spectest.data:

[15:26] <dalek> rakudo/nom: Also test @a[int]:delete

[15:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/50cecfdffe

[15:26] <TimToady> grondilu: see http://rosettacode.org/wiki/Singly-linked_list/Traversal#Perl_6

[15:26] <lizmat> eh, the satellite worked  :-)

[15:26] *** jnap left
[15:26] <moritz> dammit, I was too slow

[15:27] <TimToady> lizmat: and you've now probably used up your bandwidth quota :)

[15:27] <moritz> I wanted to revert only the part of the patch that touches postcircumfix:<[ ]>

[15:27] <lizmat> not a lot of people in the lounge here

[15:27] <TimToady> what is the name of the water under you?

[15:27] <lizmat> so plenty of bandwidth  now

[15:28] <lizmat> Irish Sea

[15:28] <jnthn> Does it have whisky in, like an Irish coffee?

[15:28] <masak> whisky and lots of salt.

[15:28] <lizmat> no, but it glows in the dark

[15:28] <masak> oh, lots of seas do that... :)

[15:29] <lizmat> the Irish Sea is supposed to be the most radio-active sea in the world, thanks to UK's Sellafield

[15:29] <lizmat> of course, this was all pre-Fukushima

[15:29] <PerlJam> hopefully it's glowing from phosphorescent algae

[15:30] <lizmat> it's still daylight here, not much glowing to see just yet  :-)

[15:31] <lizmat> http://en.wikipedia.org/wiki/Irish_sea#Radioactivity

[15:31] *** jnap joined
[15:32] <TimToady> maybe the sun's light is really from glowing algae

[15:32] <hoelzro> is "sym" the only thing that come after "token my-token:"? or are there other "token my-token:widget<thing>" things?

[15:33] <PerlJam> .oO( I didn't know Whitman did Perl 6! )

[15:33] *** rindolf left
[15:33] <TimToady> other names are well-formed, but sym is magical in setting up <sym> and other internal things

[15:34] <hoelzro> TimToady: so anything's legal, but sym is special?

[15:34] <diakopter> it says eating the most seafood from that area of anybody only increases your radiation consumption 10%

[15:34] <TimToady> nr: sub foo:bar<baz> ($x) { $x.say }; foo:bar<baz>(42)

[15:34] <camelia> niecza v24-98-g473bd20: OUTPUT«42␤»

[15:34] <camelia> ..rakudo dfe582: OUTPUT«===SORRY!=== Error while compiling /tmp/sF8lEi4PpL␤Cannot add tokens of category 'foo'␤at /tmp/sF8lEi4PpL:1␤------> sub foo:bar<baz> ⏏($x) { $x.say }; foo:bar<baz>(42)␤    expecting any of:␤        pair value␤ …»

[15:35] <TimToady> niecza++

[15:36] *** jnap left
[15:38] <TimToady> according to STD, extended names are not just for syntactic categories, so rakudo is making an unwarranted assumption there

[15:38] <timotimo> my eqat_op branch is not behaving right in the jvm version :|

[15:38] <PerlJam> r: sub infix:bar<baz> ($x) { $x.say }; infix:bar<baz>(42);   # can it do one of the know *fixes ?

[15:38] <camelia> rakudo dfe582: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&infix' called (lines 1, 1)␤»

[15:39] <TimToady> not after walking into a bar

[15:40] *** jnap joined
[15:40] *** rindolf joined
[15:40] <TimToady> 'sym' is magical, and '' is differently magical

[15:41] <TimToady> nr: sub foo:<baz> ($x) { $x.say }; foo:<baz>(42);  # curious

[15:41] <camelia> niecza v24-98-g473bd20: OUTPUT«===SORRY!===␤␤Cannot extend category:foo with subs at /tmp/hdU32wWA3X line 1:␤------> sub foo:<baz> ⏏($x) { $x.say }; foo:<baz>(42);  # curio␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/nie…»

[15:41] <camelia> ..rakudo dfe582: OUTPUT«===SORRY!=== Error while compiling /tmp/AVUmQvmyxk␤Cannot add tokens of category 'foo'␤at /tmp/AVUmQvmyxk:1␤------> sub foo:<baz> ⏏($x) { $x.say }; foo:<baz>(42);  # curio␤    expecting any of:␤        colon pair…»

[15:41] <masak> I gotta say. this Billy Idol fellow is pretty smooth.

[15:41] <TimToady> the implementations agree when the key of the pair is ''

[15:43] <TimToady> pugs: sub foo:<baz> ($x) { $x.say }; foo:<baz>(42);  # curious

[15:43] <camelia> pugs: OUTPUT«*** ␤    Unexpected ":<baz"␤    expecting "::", "handles", "is", bare trait, subroutine parameters, trait or block␤    at /tmp/uA3Bdi7mPT line 1, column 8␤»

[15:43] <TimToady> well, most of 'em

[15:46] *** jnap left
[15:46] *** jnap joined
[15:47] *** Rotwang left
[15:49] <grondilu> TimToady: what would you think of this instead?  https://gist.github.com/grondilu/6903405

[15:51] * grondilu realizes there's no need for gather/take there :/

[15:51] *** jnap left
[15:51] *** jnap joined
[15:51] <TimToady> grondilu: most VMs are not friendly to tail recursion

[15:51] *** ajr_ left
[15:52] <grondilu> :/

[15:52] * grondilu thought Perl was a functional language :/

[15:52] *** ajr joined
[15:52] <TimToady> it is, among other things, which includes portability to many VMs

[15:52] <geekosaur> tail recursion is not the essence of functional programming

[15:52] *** ajr is now known as Guest29035

[15:53] <geekosaur> it's the essence of one particular approach to it

[15:54] <TimToady> we can probably get the optimizer to fix some tail recursion, but maybe it'll take a hint or two

[15:55] *** jnap left
[15:56] <masak> grondilu: there's less consensus of the positive aspects of tail recursion than you might currently believe.

[15:56] <masak> grondilu: I used to think it was a 100% good thing too... but there are tradeoffs involved.

[15:56] <TimToady> it is not yet clear whether most ports of Perl 6 will end up with continuations underneath, so we're reserving judgment on how aggressive we can be on various FPish optimizations

[15:57] <grondilu> ok

[15:57] <masak> grondilu: as a first step of explanation, tail-recursion elimination isn't completely orthogonal to introspection. and Perl 6 does like its introspection.

[15:58] *** jnap joined
[15:58] *** darutoko- left
[15:58] <TimToady> see also much of Guy Steele's writings on why Lisp-style lists are bad for parallel processing

[15:59] <TimToady> though we'll hope we're more successful there than Fortress...

[16:01] <moritz> didn't Fortresses parallelism work out?

[16:02] <TimToady> I think that's the part that worked out well; it was the rest of the language that didn't :)

[16:02] *** Rotwang joined
[16:03] *** xalbo joined
[16:04] <masak> Fortress managed to avoid success at all costs. I don't think it's more complicated than that.

[16:04] <TimToady> but mostly, they went the funding route, and then ran out of funding

[16:05] *** jnap left
[16:05] <TimToady> if you think your language depends on funding, then it does :)

[16:05] <masak> yeah, we're not making *that* mistake! :P

[16:05] *** jnap joined
[16:05] <TimToady> fast, good, pick one

[16:05] <TimToady> cheap is assumed

[16:07] <TimToady> masak: dunno if anyone answered you, but constrained multis are always evaluated in order, so it's always going to pick Even there

[16:08] <TimToady> so you'd have to reverse them to get them to pick Quaddy

[16:08] <masak> TimToady: yeah, we had a long, sad discussion about it after that point. you'll get to it.

[16:08] <TimToady> okay

[16:08] <lizmat> on that note: is a multi *without* named parameters narrower than one with only optional named parameters ?

[16:09] <TimToady> not by current spec

[16:09] <lizmat> I'm not sure I grok why

[16:09] *** jnap left
[16:10] <lizmat> because of this, there is now a candidate for each possible named parameter in array/hash sliices

[16:10] <lizmat> instead of one that handles all

[16:10] <jnthn> iirc, the presence of named parameters counts as a constraint

[16:10] <TimToady> then maybe it's just a bug :)

[16:10] <moritz> r: multi a(:$b) { 1 }; multi a() {2}; say a()

[16:10] <camelia> rakudo dfe582: OUTPUT«1␤»

[16:11] <jnthn> that's consistent with what I said about them being constraint-y

[16:11] <moritz> it takes the first, not the one without named ones

[16:11] *** jnap joined
[16:11] <jnthn> Thus making them epsilon tigheter.

[16:11] <jnthn> *tighter

[16:11] <jnthn> r: multi a() { 1 }; multi a(:$b) { 2 }; say a()

[16:11] <camelia> rakudo dfe582: OUTPUT«2␤»

[16:11] <lizmat> well, the reason for my asking, is that I think the candidate that handles the no frills [] and {} access, should be the first and simplest

[16:11] <lizmat> (it now is)

[16:12] <jnthn> No, it's not ordering, it consistently picks the one with the optional named arg

[16:12] <jnthn> lizmat: I presumre that each of the other candidates has at least one *required* named argument?

[16:12] <xalbo> Does that make the one with no args unreachable?

[16:12] <lizmat> at the moment, yes

[16:12] <lizmat> no, it's reachable

[16:12] <jnthn> lizmat: Because that's what the static dispatcher needs.

[16:13] <lizmat> please look at the yuckiness that src/core/array_slice.pm is

[16:14] *** xinming left
[16:14] <lizmat> for each set of candidates, I would like to collapse the last 6 into one

[16:15] <jnthn> lizmat: What's yucky?

[16:15] *** xinming joined
[16:16] <jnthn> lizmat: Yes but if you do that we can't rule out the named-param-taking candidate statically and inline the simple one :/

[16:16] <lizmat> anybody in the future wanting to handle multiple adverbs, will need to expand each candidate with at least one obligatory named param

[16:17] <lizmat> let me put it this way: *I* can live with the yuckiness in array_slice.pm

[16:17] <lizmat> but I feel it is a deficiency in the language that such a setup is needed

[16:17] <lizmat> anyways, land ahoy!

[16:18] <lizmat> will be commuting to the Limerick Open Source Meetup, hosted by Tim Bunce, shortly

[16:18] <jnthn> enoy :)

[16:18] <jnthn> *enjoy

[16:19] <TimToady> Open Source Limericks, yum!

[16:19] <TimToady> say hi to M Bunce for us

[16:19] <lizmat> we will probably spec Perl6 DBI when we're there

[16:19] <lizmat> :-)

[16:19] <lizmat> will do

[16:19] *** jnap left
[16:20] <moritz> and the commit the introduced it causes it to bomb out on certain tests on my machine

[16:21] * moritz replied to stale backscroll

[16:21] *** jnap joined
[16:21] <moritz> that was about the src/core/array_slice.pm yuckiness

[16:21] <TimToady> I'm sure you can find some staler backscroll than that to reply to :)

[16:22] <lizmat> moritz: sorry for any miscommunication

[16:23] <lizmat> commuting&

[16:23] *** lizmat left
[16:23] <TimToady> just don't miscommute

[16:24] <TimToady> I guess that counts as stale frontscroll...

[16:25] *** dwarring left
[16:27] *** jnap1 joined
[16:28] *** jnap left
[16:32] *** jnap1 left
[16:32] *** jnap joined
[16:37] *** jnap left
[16:37] *** jnap joined
[16:38] <[Coke]> pugs: use Test; ok(1 eq "1", "does this work?");

[16:38] <camelia> pugs: OUTPUT«pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/MhXvkSkqeM line 1, column 1␤»

[16:38] <[Coke]> pugs: say [+] 1..100;

[16:38] <camelia> pugs: OUTPUT«5050␤»

[16:41] *** [Sno] joined
[16:41] *** jnap left
[16:42] <dalek> nqp/moarboot: 85ab267 | jonathan++ | src/vm/moar/QAST/QASTRegexCompilerMAST.nqp:

[16:42] <dalek> nqp/moarboot: Fix x**0 compilation for MoarVM backend.

[16:42] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/85ab267a09

[16:46] *** jnap joined
[16:49] *** segomos left
[16:50] *** ugexe_ left
[16:51] *** ssutch joined
[16:51] <TimToady> jnthn: perhaps there's a good static model where mandatory parameters are considered tigher but optional parameters are considered looser than the no-param case

[16:52] <TimToady> *tighter

[16:53] *** jnap left
[16:53] <jnthn> TimToady: Perhaps so...I seem to recall that last time I tried to work out such a model I couldn't get it. I forget why. :(

[16:53] *** Rotwang left
[16:53] <jnthn> TimToady: Maybe I was just having a not-very-smart day :)

[16:53] <jnthn> .oO( that'd be most of 'em... )

[16:54] * TimToady gets one of those from year to year

[16:54] *** jnap joined
[16:54] <jnthn> At the moment we have just one epsilon for all the things

[16:54] <jnthn> (nameds, unpacks, constraints, etc.)

[16:55] *** darutoko joined
[16:55] <jnthn> I *think* what I might have run into is combinatorics...somehow.

[16:55] <moritz> maybe we also need ἕ

[16:56] <jnthn> Or some kind of "what's the pecking order" thing

[17:01] *** jnap left
[17:04] *** dakkar left
[17:05] *** jnap joined
[17:09] *** jnap left
[17:10] *** jnap joined
[17:12] <TimToady> we already have +Inf and -Inf, so ±ε should be trivial :)

[17:15] *** jnap left
[17:16] *** jnap joined
[17:19] <sjn> .u HEBREW LETTER ALEPH

[17:19] <yoleaux> No characters found

[17:19] <sjn> .u HEBREW LETTER ALEF

[17:19] <yoleaux> U+05D0 HEBREW LETTER ALEF [Lo] (א)

[17:20] <sjn> TimToady: How about the Aleph numbers? :)

[17:21] <jnthn> ooh, sjn

[17:21] <sjn> (perhaps of limited usefulness, but if Inf is in, why not Aleph null, one, etc. :)

[17:21] <jnthn> sjn: I will be in Oslo next week. :)

[17:21] <sjn> hey, cool!

[17:22] <sjn> when?

[17:22] <jnthn> I'm free on Thursday evening with the caveat that I'll have to get up early the next morning.

[17:24] *** jnap left
[17:24] *** jnap joined
[17:26] * sjn has no plans for next thursday, it seems o/

[17:27] <jnthn> Cool. I won't be able to stay out until midnight doing beer, but can happily have some dinner and a couple of pints :)

[17:28] <sjn> sounds good

[17:28] <dalek> nqp/moarboot: c204a57 | jonathan++ | src/HLL/Grammar.nqp:

[17:28] <dalek> nqp/moarboot: Fix starter/stopper contextual check.

[17:28] <dalek> nqp/moarboot: 

[17:28] <dalek> nqp/moarboot: It was always not checking for the right thing. Somehow we got away

[17:28] <dalek> nqp/moarboot: with it on Parrot and JVM, but Moar tripped. So, correct it. It will

[17:28] <dalek> nqp/moarboot: save some spurious calls to !LITERAL on all backends.

[17:28] <dalek> nqp/moarboot: review: https://github.com/perl6/nqp/commit/c204a57d24

[17:29] *** jnap left
[17:33] *** jnap joined
[17:33] <diakopter> jnthn: heh.

[17:33] <diakopter> how many of those "moar is moar strict" things have we encountered? :)

[17:34] <jnthn> fewer than I encountered with JVM :)

[17:35] <diakopter> oh, heh.

[17:35] <TimToady> how much fewerness is because you encountered the JVM first? :)

[17:36] *** PZt left
[17:37] <jnthn> TimToady: Probably most of them :)

[17:37] <jnthn> TimToady: JVM also has a "pure" 6model factoring of things

[17:37] *** jnap left
[17:37] <jnthn> Though built atop of other things rather than native like in Moar...

[17:37] *** jnap joined
[17:38] <diakopter> nativer, anyway

[17:38] <jnthn> Anyway, if the JVM port hadn't come first then we'd have found a bunch more in Moar.

[17:38] <diakopter> .oO( or given up in horror at encountering so many... )

[17:38] <jnthn> We're already getting huge benefit from the porting work that already took place :)

[17:39] *** Guest29035 left
[17:40] <jnthn> We're 73 tests in 5 test files from NQP on MoarVM passing all the things

[17:40] <jnthn> I may be able to get than down to 10ish later this evening...

[17:41] <jnthn> But first, dinner &

[17:42] *** jnap left
[17:44] *** jnap joined
[17:50] *** prevost left
[17:51] *** jnap left
[17:51] *** jnap joined
[17:55] *** jnap left
[17:55] *** jnap joined
[17:59] *** SamuraiJack joined
[18:01] *** daxim left
[18:02] *** jnap left
[18:03] *** jnap joined
[18:10] *** jnap left
[18:13] *** jnap joined
[18:21] *** jnap left
[18:23] *** jnap joined
[18:25] *** jnap left
[18:27] *** jnap joined
[18:28] <diakopter> .

[18:30] *** darutoko left
[18:33] *** jnap left
[18:36] *** jnap joined
[18:37] *** PZt joined
[18:42] *** jnap left
[18:47] *** xinming left
[18:50] *** rindolf left
[18:53] <lue> hello world o/

[18:54] *** fhelmberger left
[18:54] *** xinming joined
[19:02] *** jnap joined
[19:06] *** jnap left
[19:06] *** jnap joined
[19:07] *** lizmat joined
[19:08] <lizmat> decommute

[19:08] <lizmat> landed at the LOSMU

[19:10] <lizmat> Tim Bunce is saying high back!

[19:13] *** jnap left
[19:14] *** jnap joined
[19:15] *** dansamo left
[19:21] *** grondilu left
[19:21] *** ajr joined
[19:21] *** ajr is now known as Guest68482

[19:22] *** jnap left
[19:23] *** jnap joined
[19:27] *** Guest68482 is now known as ajr_

[19:29] * jnthn returns

[19:29] *** jnap left
[19:29] *** jnap joined
[19:31] <lizmat> hello from Limerick 

[19:32] *** SamuraiJack left
[19:33] <nwc10> lizmat: just curious - how did you get from whereever the ferry landed to Limerick?

[19:34] <jnthn> .oO( I hope the ferry docked rather than landed :P )

[19:36] *** jnap left
[19:38] <lizmat> nwc10: just followed the navigator, on the highway from Dublin to Limerick

[19:39] <lizmat> (yes, there is one nowadays)

[19:39] <lizmat> and yes, the ferry docked....

[19:39] <lizmat> on the way back, we'll take the one that sort of flies 1m above water…..  sort of  :-)

[19:39] *** jnap joined
[19:40] <jnthn> oh my...

[19:40] <jnthn> I hope the sea ain't rough if you're taking one of those :)

[19:41] <lizmat> we'll find out next week  :-)

[19:42] <lizmat> it's a catamaran, not a hovercraft  … hovercrafts are worse: they're the worst of both worlds

[19:43] <jnthn> I've never done a hovercraft

[19:43] <jnthn> I did have a bad experience with a catamaran on the English channel...

[19:44] *** jnap left
[19:44] <diakopter> my last hovercraft was full of eels

[19:44] *** jnap joined
[19:45] <jnthn> oh reely?

[19:47] <diakopter> http://www.omniglot.com/language/phrases/hovercraft.htm

[19:48] *** jnap left
[19:49] *** jnap joined
[19:53] *** jnap left
[19:53] *** jnap joined
[19:54] *** DarthGandalf joined
[19:54] *** jnap left
[20:17] *** araujo left
[20:17] *** araujo joined
[20:21] *** stevan_ left
[20:24] *** SmokeMachine left
[20:33] <ajr_> A hovercraft at speed on a rough sea feels like a Land-Rover being driven across a ploughed field, (at right angles to the furrows).

[20:39] *** hummeleB1 left
[20:40] <japhb__> jnthn: Just wanted you to know -- rakudo-jvm concurrency is now actively saving me time in my dayjob.  Being able to run multiple (high timing variance) data-gathering tasks concurrently greatly reduces the time I need to gather data for a common task.  So, thanks.  :-)

[20:41] <japhb__> (Other Googler: "How are you doing that?  Python can't do that ...."  "It's Perl 6 on JVM."  "Oooooh, that's cool!")

[20:42] <jnthn> japhb__: Wow :)

[20:42] *** dmol left
[20:43] <jnthn> japhb__: I have a chunk of time allocated at the end of the month to work on further Rakudo JVM concurrency improvements :)

[20:43] <japhb__> Thank you Thank you Thank you Thank you.  In advance.  ;-)

[20:43] <jnthn> :)

[20:43] <jnthn> I'm happy to see it being used to good effect.

[20:44] *** PZt left
[20:44] <jnthn> Please do let me know where the most noticable rough edges are.

[20:45] <japhb__> Well, pipes were one problem, but thanks to the donaldh hint I worked around it with qqx// and File::Temp.

[20:45] <jnthn> ah, ok. Not a concurrency issue per se, but a missing bit of IPC support.

[20:45] <japhb__> I know I need sockets and good buffer handling (the latter is there already, yes?)

[20:46] <jnthn> Sockets are too, providing you don't need non-blocking yet.

[20:46] <jnthn> But yeah, Buf got a bunch of work not so long ago. I won't claim it's perfect, but at least types like buf8 exist now..

[20:46] <japhb__> Well, I can fake that with concurrency, though you made a mildy hand-wavey comment about filling the thread pool that way.

[20:47] <jnthn> Yeah

[20:47] <japhb__> How big is the thread pool?

[20:47] <jnthn> 16 by default 

[20:47] <jnthn> But you can do as you wish

[20:47] <japhb__> Right now I'm at <10 concurrency, but I expect I'll want more than that sooner rather than later.

[20:47] <japhb__> How do you expand the pool?

[20:47] <jnthn> The current design is that the effective scheduler is in $*SCHEDULER

[20:48] <jnthn> So at the start of your program just re-bind that.

[20:48] <japhb__> How complex is it?  Big pain or copy/pasta to override?

[20:49] <jnthn> my $*SCHEDULER = ThreadPoolScheduler.new(initial_threads => 4, max_threads = 128); # or whtaever you like)

[20:49] <japhb__> If it's non-trivial, having some basic tunables for it would be nice, so that overriding $*SCHEDULER becomes rarer.

[20:49] <Ulti> hey has anyone tried playing with this since 2002??? http://www.perlmonks.org/?node_id=179755

[20:49] <japhb__> Oh, that's easier, gotcha.

[20:50] <Ulti> someone made an XML grammar from the EBNF spec

[20:50] <jnthn> Yeah, it's easy. *but* I don't promise to keep the scheduler API as it is today.

[20:50] <japhb__> The value I'm getting is worth some bitrot risk,

[20:50] <japhb__> s/,/./

[20:50] <jnthn> Promise and Channel are, API wise, fairly OK.

[20:51] <jnthn> Scheduler I *know* is not what I want, but it's the least user exposed bit and I was tied for time.

[20:51] <jnthn> And yes, I may well make it so you can just tune it

[20:52] <japhb__> What about talking to Java or C++ libraries?  I vaguely recall the first being doable, and arnsholt tanking on the second ....

[20:53] <jnthn> First is doable, but you'll find caveats

[20:53] <japhb__> (First Rule of Crypto: Don't write your own crypto.)

[20:53] *** kaare_ left
[20:54] <jnthn> rj: say('is this it?')

[20:54] *** cognominal__ left
[20:54] <japhb__> What kind of caveats are we looking at?

[20:54] <camelia> rakudo-jvm 50cecf: OUTPUT«is this it?␤»

[20:54] <jnthn> rj: use java::util::zip::CRC32:from<java>; my $crc = CRC32.new(); for 'Hello, Java'.encode('utf-8') { 

[20:54] <camelia> rakudo-jvm 50cecf: OUTPUT«===SORRY!=== Error while compiling /tmp/eUDavU250J␤Unable to parse expression in block; couldn't find final '}'␤at /tmp/eUDavU250J:1␤------> w(); for 'Hello, Java'.encode('utf-8') {⏏<EOL>␤    expecting any of:…»

[20:54] <jnthn> oops

[20:54] <jnthn> rj: use java::util::zip::CRC32:from<java>; my $crc = CRC32.new(); for 'Hello, Java'.encode('utf-8') { $crc.'method/update/(B)V'($_) }; say $crc.getValue();

[20:54] <camelia> rakudo-jvm 50cecf: OUTPUT«No such method 'method/update/(B)V' for invocant of type 'Scalar'␤  in block  at /tmp/OhlA2Bdyu2:1␤  in block  at src/gen/CORE.setting:7151␤  in block  at src/gen/CORE.setting:7015␤  in method gimme at src/gen/CORE.setting:7433␤␤»

[20:55] <jnthn> well, oops

[20:55] <jnthn> rj: use java::util::zip::CRC32:from<java>; my $crc := CRC32.new(); for 'Hello, Java'.encode('utf-8') { $crc.'method/update/(B)V'($_) }; say $crc.getValue();

[20:55] <camelia> rakudo-jvm 50cecf: OUTPUT«No such method 'method/update/(B)V' for invocant of type 'java.util.zip.CRC32'␤  in block  at /tmp/70GIANduRP:1␤  in block  at src/gen/CORE.setting:7151␤  in block  at src/gen/CORE.setting:7015␤  in method gimme at src/gen/CORE.setting:7433␤␤»

[20:55] <japhb__> ... and is there a guide somewhere for how to do the translation to get that funky method invocation syntax?

[20:55] <diakopter> just make it up; rakudo figures out what you want

[20:55] * jnthn wonders why that ain't working...

[20:55] <jnthn> diakopter: wtf :)

[20:55] <jnthn> japhb__: I normally just dump them

[20:55] <lue> Ulti: wh-wh-what is this? Why are there \s* everywhere in a *rule* ? Why are there unescaped = signs that can't be assigning anything (\s* = \s*). What is (?: trying to do? blurghghgh

[20:56] <jnthn> japhb__: Moment, lemme figure it out...

[20:58] <japhb__> jnthn: What's the command that would dump them?  Then I can just use that output and the docs and hack until happy, I suppose.

[20:59] <jnthn> nqp-jvm: my $interop := nqp::jvmbootinterop(); my %h := $interop.getInterop($interop.typeForName('java.util.zip.CRC32')); for %h { say($_.key) } # something like this

[20:59] <camelia> nqp-jvm: OUTPUT«Cannot unbox a type object␤  in callout org.perl6.nqp.runtime.BootJavaInterop method/getInterop/(Lorg/perl6/nqp/sixmodel/SixModelObject;)Lorg/perl6/nqp/sixmodel/SixModelObject;␤  in  (/tmp/Mdz7VEmHKO:1)␤  in  (src/stage2/gen/NQPHLL.nqp:1098)␤  in eval (src/st…»

[21:00] <jnthn> hmm

[21:00] <japhb__> Something done got broke?

[21:00] <Ulti> heh lue no idea but this was 11 years ago :] the idea of translating from EBNF to Perl6 grammars is kind of a good one though!

[21:00] <jnthn> I just got a new laptop and don't have a JVM build here nor my cheat file :)

[21:02] <jnthn> nqp-jvm: my $interop := nqp::jvmbootinterop(); my %h := $interop.getInterop('java.util.zip.CRC32'); for %h { say($_.key) } # something like this

[21:02] <camelia> nqp-jvm: OUTPUT«getValue␤method/wait/(J)V␤method/notifyAll/()V␤method/getValue/()J␤method/hashCode/()I␤hashCode␤method/update/([B)V␤method/toString/()Ljava/lang/String;␤method/reset/()V␤method/getClass/()Ljava/lang/Class;␤/box/␤isinst␤notify␤reset␤/TYPE/…»

[21:02] <jnthn> There we go

[21:02] <jnthn> I misread :)

[21:02] <japhb__> Nice when the fix is to remove some code ....

[21:04] <japhb__> I'm assuming this mangle encoding is a JVM spec?

[21:04] <jnthn> The rule basically is that it will give you the short name when it's unambig.

[21:04] *** dayangkun left
[21:04] <jnthn> Yeah

[21:04] <japhb__> OK, I'll look for that.

[21:04] <jnthn> It's the same type name codes and format that class files have

[21:04] <jnthn> The eventual goals is to implement something so that if it is ambig we calcuate a dispatcher )

[21:05] <jnthn> Which is just a little fiddly to write ;))

[21:05] <japhb__> heh

[21:07] *** lichtkind left
[21:07] <japhb__> Ulti: I suspect that when Perl 6 starts going more mainstream, a bunch of grammar translators will pop up, to do the grunge work of rote conversion so humans can just tune the results.

[21:07] * jnthn has pondered how a Grammar::Infer could work...

[21:08] <jnthn> (Infer a grammar from example data...somehow :))

[21:09] * jnthn saw a cool talk once about using I think it was dependent types to infer a database schema...

[21:09] <japhb__> There must be some corpus of research on this ...

[21:09] <Ulti> http://rosettacode.org/wiki/Parse_EBNF#Perl_6 this is really cool

[21:09] <jnthn> japhb__: Surely :)

[21:10] *** denisboyun joined
[21:10] *** lowpro30__ joined
[21:10] <jnthn> You tend to need some kind of underlying formalism to attack such things, or at least it helps

[21:11] <japhb__> Ulti: wow, that is indeed quite cool.

[21:11] <jnthn> Grammar::Generative was based on a handwavey understanding of mathematical duals, for example :)

[21:12] *** lowpro30_ left
[21:13] *** skids left
[21:15] *** grondilu joined
[21:17] *** dayangkun joined
[21:20] *** airdisa_ joined
[21:22] <felher> r: say [[1, 2], [2, 3]]>>.[0];

[21:22] <camelia> rakudo 50cecf: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Int'␤  in sub METAOP_HYPER_CALL at src/gen/CORE.setting:16516␤  in block  at /tmp/tA5RKhJHyC:1␤␤»

[21:22] <felher> Shouldn't that give something like "1 2"

[21:23] <felher> Ah, is this that nodal-thingy, that is NYI?

[21:23] <Ulti> Not Yet Implemented

[21:24] <Ulti> oh it was a question if its implemented sorry

[21:24] <Ulti> :Z

[21:26] <felher> Ulti: yeah, well, I phrased that kinda bad. "Is this that nodal-thingy which is NYI?" would have been better :)

[21:29] <timotimo> sorry about the nodal nyiness

[21:29] <timotimo> i kind of have been working on that

[21:29] <timotimo> never gotvaround to finishing it

[21:30] <jnthn> nyin nyin nyin # reminds me of nyan cat :)

[21:30] *** BenGoldberg joined
[21:30] <felher> r: say [[1, 2], [2, 3]].map: *.[0]; # timotimo : np, this should do the job :)

[21:30] <camelia> rakudo 50cecf: OUTPUT«No such method 'count' for invocant of type 'Whatever'␤  in method reify at src/gen/CORE.setting:7113␤  in method reify at src/gen/CORE.setting:7030␤  in method reify at src/gen/CORE.setting:7030␤  in method reify at src/gen/CORE.setting:7030␤  in met…»

[21:31] <timotimo> on my branch that circumfix hyper usedbtobwork but that was before the switch from method to sub

[21:31] <timotimo> hmm that does not properly curry

[21:32] <felher> r: say [[1, 2], [2, 3]].map: { .[0] }; # next try...

[21:32] <camelia> rakudo 50cecf: OUTPUT«1 2␤»

[21:33] <felher> here we go :)

[21:33] <felher> i'll use that for now. :)

[21:37] *** ajr_ left
[21:38] *** lowpro30__ left
[21:38] <BenGoldberg> r: say $_.[0] for [1,2], [3,4];

[21:38] <camelia> rakudo 50cecf: OUTPUT«1␤3␤»

[21:38] <BenGoldberg> r: say *.[0] for [1,2], [3,4];

[21:39] <camelia> rakudo 50cecf: OUTPUT«*␤*␤»

[21:39] <BenGoldberg> n: say *.[0] for [1,2], [3,4];

[21:39] <camelia> niecza v24-98-g473bd20: OUTPUT«{ ... }␤{ ... }␤»

[21:40] <grondilu> r: say *.[0]() for [1,2], [3,4];

[21:40] <camelia> rakudo 50cecf: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Whatever'␤  in block  at /tmp/SlyTsE4pHK:1␤␤»

[21:40] <grondilu> r: say *().[0] for [1,2], [3,4];

[21:40] <camelia> rakudo 50cecf: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Whatever'␤  in block  at /tmp/CPPQV19y_z:1␤␤»

[21:41] <grondilu> r: say (*.[0])() for [1,2], [3,4];

[21:41] <camelia> rakudo 50cecf: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Whatever'␤  in block  at /tmp/dilbiWDya8:1␤␤»

[21:41] <grondilu> r: say (*.[0])($_) for [1,2], [3,4];

[21:41] <camelia> rakudo 50cecf: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Whatever'␤  in block  at /tmp/LGyeUb6aCG:1␤␤»

[21:41] * grondilu gives up

[21:43] *** dayangkun_ joined
[21:44] <lizmat> commuting again&

[21:44] *** lizmat left
[21:46] *** donaldh left
[21:47] *** dayangkun left
[21:49] *** bluescreen100 left
[21:49] *** Pzt33 joined
[21:50] *** Pzt33 is now known as PZt

[22:01] *** dmol joined
[22:01] *** ssutch left
[22:11] *** ssutch joined
[22:12] *** denisboyun left
[22:13] *** dmol left
[22:21] *** PacoAir left
[22:23] *** BenGoldberg left
[22:32] *** airdisa_ left
[22:53] *** fridim_ joined
[23:19] <dalek> perl6-roast-data: ec21c8d | coke++ | / (5 files):

[23:19] <dalek> perl6-roast-data: today (automated commit)

[23:19] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/ec21c8d182

[23:20] *** xinming left
[23:22] *** xinming joined
[23:23] *** cognominal joined
[23:36] <dalek> Pugs.hs: cf3f65b | coke++ | t/spectest.data:

[23:36] <dalek> Pugs.hs: deleted file ; file we can no longer pass

[23:36] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/cf3f65b66e

[23:42] *** stevan_ joined
