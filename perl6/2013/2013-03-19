[00:05] *** ruoso joined
[00:14] *** aindilis joined
[00:16] *** jerome left
[00:28] <jnthn> 'night, #perl6

[00:37] *** Entonian left
[00:39] *** grondilu joined
[00:40] <grondilu> Hello #perl6

[00:44] <colomon> \o

[00:48] *** erkan left
[00:49] *** erkan joined
[00:49] *** erkan left
[00:49] *** erkan joined
[00:49] *** jerome joined
[00:54] *** Chillance left
[00:59] *** fgomez left
[01:04] *** anuby joined
[01:04] *** gdey left
[01:13] *** fgomez joined
[01:26] *** hypolin joined
[01:43] *** lichtkind joined
[01:44] <lichtkind> can it bee that rules are allowed to overwrite methods?

[01:47] <diakopter> example?

[01:48] <lichtkind> sure but i tried nearly everything

[01:48] <lichtkind> i cant come up with example where roles throw exception

[01:50] <diakopter> wait, roles or rules?

[01:50] <grondilu> r: role R { method talk { say "I'm a role" } }; class Foo does R { method talk { say "I'm Foo" } }; Foo.new.talk

[01:50] <p6eval> rakudo 2a41b3: OUTPUT¬´I'm Foo‚ê§¬ª

[01:50] <diakopter> ok; the question said rules :)

[01:50] <grondilu> typo I guess

[01:52] <lichtkind> r:role R { method reset {$.d = 0; self} } class A does R { has $.d is rw = 2; method reset {$.d = 1}  }; say B.new(:d(3)).reset.d

[01:52] <grondilu> lichtkind: you need a space after 'r:'

[01:52] <lichtkind> home it says 0

[01:53] <lichtkind> r: role R { method reset {$.d = 0; self} } class A does R { has $.d is rw = 2; method reset {$.d = 1}  }; say B.new(:d(3)).reset.d

[01:53] <p6eval> rakudo 2a41b3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/1Mj73nR5RR:1‚ê§------> [32mrole R { method reset {$.d = 0; self} } [33m‚èè[31mclass A does R { has $.d is rw = 2; meth[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifie‚Ä¶

[01:53] <diakopter> need a semi

[01:53] <lichtkind> r: role R { method reset {$.d = 0; self} }; class A does R { has $.d is rw = 2; method reset {$.d = 1}  }; say B.new(:d(3)).reset.d

[01:53] <p6eval> rakudo 2a41b3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared name:‚ê§    B used at line 1‚ê§‚ê§¬ª

[01:53] <lichtkind> yes

[01:53] <diakopter> HONK SCREECH CRUNCH

[01:53] <diakopter> ^^ semi

[01:54] <lichtkind> r: role R { method reset {$.d = 0; self} }; class A does R { has $.d is rw = 2; method reset {$.d = 1}  };  say B.new(:d(3)).reset.d;

[01:54] <p6eval> rakudo 2a41b3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared name:‚ê§    B used at line 1‚ê§‚ê§¬ª

[01:54] <grondilu> r: role R { method reset {$.d = 0; self} }; class A does R { has $.d is rw = 2; method reset  {$.d = 1}  };  say A.new(:d(3)).reset.d

[01:54] <p6eval> rakudo 2a41b3: OUTPUT¬´No such method 'd' for invocant of type 'Int'‚ê§  in block  at /tmp/voCg8NUqGu:1‚ê§‚ê§¬ª

[01:54] <lichtkind> yes that should be the output

[01:55] <lichtkind> but here it is 0

[01:55] <lichtkind> no

[01:55] <lichtkind> allright but still no exception

[01:56] <grondilu> r: role R { method reset {$.d = 0; self} }; class A does R { has $.d is rw = 2; method reset  {$.d = 1}  };  my $a = A.new: :d(3); $a.reset; say $a.d

[01:56] <p6eval> rakudo 2a41b3: OUTPUT¬´1‚ê§¬ª

[01:56] <diakopter> r: role R { method reset {$.d = 0; self} }; class A does R { has $.d is rw = 2; method reset  {$.d = 1; self}  };  say A.new(:d(3)).reset.d

[01:56] <p6eval> rakudo 2a41b3: OUTPUT¬´1‚ê§¬ª

[01:57] <grondilu> lichtkind: you sure you get 0 with the above?

[01:58] <diakopter> (either one)

[02:01] *** kurahaupo left
[02:04] <lichtkind> no i dont get 0

[02:04] <lichtkind> was my fault

[02:04] <lichtkind> juggling with too much example code in one file

[02:04] <lichtkind> but still wondering where exception is

[02:05] <diakopter> where would the exception be?

[02:13] <lichtkind> in the output last time i read synoses role conflict throws one

[02:15] *** kurahaupo joined
[02:25] *** japhb_ left
[02:38] *** LlamaRider left
[02:42] *** lichtkind left
[02:46] *** grondilu left
[02:48] *** adu_ joined
[02:52] *** lustlife joined
[02:54] *** sizz_ joined
[02:54] *** sizz left
[02:55] *** FROGGS_ joined
[02:58] *** lustlife left
[02:58] *** FROGGS left
[03:02] *** orafu left
[03:02] *** orafu joined
[03:04] *** lustlife joined
[03:04] *** uasi joined
[03:05] *** adu_ is now known as adu

[03:11] *** sizz joined
[03:12] *** sizz_ left
[03:12] *** uasi left
[03:12] *** uasi joined
[03:21] *** jaldhar_ joined
[03:35] *** jaldhar_ left
[03:36] *** jaldhar_ joined
[03:50] *** araujo left
[03:50] *** uasi left
[03:50] *** Tabrenus joined
[03:51] *** Tabrenus left
[03:53] *** jerome left
[03:56] *** fgomez left
[03:59] *** orafu left
[03:59] *** OuLouFu joined
[03:59] *** OuLouFu is now known as orafu

[04:02] *** sftp_ joined
[04:03] *** fgomez joined
[04:03] *** sftp left
[04:07] *** jerome joined
[04:13] *** bonsaikitten joined
[04:42] *** preflex left
[04:42] *** preflex_ joined
[04:43] *** preflex_ is now known as preflex

[05:01] *** Cynede joined
[05:01] <Cynede> good morning

[05:02] <Cynede> what is @rem = '--*-Perl-*-- in bash?

[05:02] <Cynede> I see it in panda.bat file but it doesn't work for me, just interesting what is it o_O

[05:05] *** sizz_ joined
[05:05] *** sizz left
[05:10] *** adu left
[05:11] *** baest joined
[05:14] <lue> Cynede: beats me. Aren't .bat files Windows batch files though?

[05:14] <apejens> @rem is a comment I think, the rest looks like a modeline for an editor

[05:15] <lue> (If it is a modeline, it's surely for emacs)

[05:15] <Cynede> lue: it is

[05:16] <Cynede> for win

[05:16] <lue> you said "in bash" earlier, so I was curious.

[05:16] *** uasi joined
[05:17] <Cynede> ah... fault. It's in batch

[05:17] <perigrin> what apejens said ... REM is the comment and the @ squashes output

[05:17] <perigrin> er REM is the comment signifier

[05:17] <perigrin> and @ squashes the prompt output

[05:18] *** fgomez left
[05:21] *** kurahaupo left
[05:23] <Cynede> so...

[05:23] <Cynede> anyways it doesn't work

[05:24] <Cynede> says Variable @rem is not declared

[05:27] *** labster joined
[05:29] *** fgomez joined
[05:29] <apejens> Cynede: and you are running panda.bat with what program?

[05:30] <Cynede> apejens you mean I need powershell?

[05:38] <diakopter> Cynede: are you in bash?

[05:38] <diakopter> oh

[05:38] <diakopter> batch

[05:38] <diakopter> what is your prompt

[05:51] <labster> r: if 0 { use MONKEY_TYPING; augment class Str { method Int { 'foo';}; };

[05:51] <p6eval> rakudo 2a41b3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Package 'Str' already has a method 'Int' (did you mean to declare a multi-method?)‚ê§at /tmp/2LEn69rlRY:1‚ê§------> ‚ê§¬ª

[05:51] *** SamuraiJack joined
[05:53] <labster> huh.  that conditional didn't help at all.

[06:00] *** Harzilein left
[06:02] *** Jimmy_ joined
[06:03] <Cynede> diakopter usual windows prompt

[06:04] *** Cynede is now known as Heather

[06:05] *** Jimmy_ left
[06:05] * Heather wonders about Google Drive https://gist.github.com/Heather/5194008

[06:06] *** bonsaikitten left
[06:06] *** DrEeevil joined
[06:23] *** ilogger2 joined
[06:23] *** ChanServ sets mode: +v ilogger2

[06:25] <diakopter> p5eval: eval 'print '.('BEGIN { ' x 100 ).' 55 '.('}' x 100))

[06:25] <p5eval> diakopter: ERROR: syntax error at (eval 7) line 3, near "))"

[06:25] <diakopter> erm

[06:26] <diakopter> p5eval: eval('BEGIN { ' x 100 ).' print 55 '.('}' x 100))

[06:26] <p5eval> diakopter: ERROR: syntax error at (eval 7) line 3, near "))"

[06:26] <diakopter> p5eval: eval(('BEGIN { ' x 100 ).' print 55 '.('}' x 100))

[06:26] <p5eval> diakopter: 55

[06:27] <diakopter> p5eval: eval(('BEGIN { ' x 1000 ).' print 55 '.('}' x 1000))

[06:27] <p5eval> diakopter: 55

[06:27] <diakopter> p5eval: eval(('BEGIN { ' x 10000 ).' print 55 '.('}' x 10000))

[06:27] <p5eval> diakopter: 55

[06:27] <diakopter> p5eval: eval(('BEGIN { ' x 100000 ).' print 55 '.('}' x 100000))

[06:27] <p5eval> diakopter: Out of memory!

[06:27] <diakopter> oo

[06:28] <diakopter> p5eval: eval(('BEGIN { ' x 50000 ).' print 55 '.('}' x 50000))

[06:28] <p5eval> diakopter: Out of memory!

[06:28] <diakopter> p5eval: eval(('BEGIN { ' x 25000 ).' print 55 '.('}' x 25000))

[06:28] <p5eval> diakopter: 55

[06:29] <diakopter> rnp: eval("say {'BEGIN { ' x 25000 } 5 {'}' x 25000 }")

[06:29] <p6eval> rakudo 2a41b3, niecza v24-35-g5c06e28, pugs: OUTPUT¬´(timeout)¬ª

[06:30] <diakopter> rnp: eval("say {'BEGIN { ' x 12500 } 5 {'}' x 12500 }")

[06:30] <p6eval> rakudo 2a41b3, niecza v24-35-g5c06e28, pugs: OUTPUT¬´(timeout)¬ª

[06:30] <diakopter> rnp: eval("say {'BEGIN { ' x 6250 } 5 {'}' x 6250 }")

[06:31] <p6eval> rakudo 2a41b3, niecza v24-35-g5c06e28, pugs: OUTPUT¬´(timeout)¬ª

[06:31] <diakopter> rnp: eval("say {'BEGIN { ' x 3125 } 5 {'}' x 3125 }")

[06:32] <p6eval> rakudo 2a41b3, niecza v24-35-g5c06e28, pugs: OUTPUT¬´(timeout)¬ª

[06:32] <diakopter> rnp: eval("say {'BEGIN { ' x 1562 } 5 {'}' x 1562 }")

[06:33] <p6eval> rakudo 2a41b3: OUTPUT¬´(timeout)¬ª

[06:33] <p6eval> ..pugs: OUTPUT¬´5‚ê§¬ª

[06:33] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT¬´(timeout)5‚ê§¬ª

[06:33] <diakopter> niecza?

[06:33] <diakopter> timeout and 5?

[06:33] <Heather> where are this bot's sources?

[06:35] <diakopter> https://github.com/perl6/evalbot

[06:36] <Heather> diakopter thanks

[06:36] <diakopter> although..

[06:36] <diakopter> hm I never pushed the nqp-jvm thing

[06:38] *** araujo joined
[06:38] <diakopter> oh well, I'll leave it to someone more diligent

[06:41] <Heather> diakopter how nqp generate makefile?

[06:41] *** sftp_ joined
[06:41] <diakopter> what do you mean

[06:42] <diakopter> when building nqp?

[06:42] <Heather> with use NQP::Configure ...

[06:42] <Heather> yes I need to track PERL variable path generation

[06:44] <sorear> diakopter: print 5, then timeout.  (timeout) and (signal FOO) are deemed important enough to promote to the front.

[06:44] <sorear> even though semantically they happen after all output...

[06:45] <sorear> n: say "hi"; sleep 1000

[06:45] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´(timeout)hi‚ê§¬ª

[06:45] <Heather> does someone know how Configure.pl is getting $(PERL)  e.g. perl5 path

[06:47] <Heather> because after last perl update this path there is still being old :S so I want to know why

[06:49] <Heather> that will be sane if it somehow check which perl is running this configure.pl but it's not

[06:54] <Heather> what is @perl@

[06:56] <tadzik> Heather: I think it gets perl from parrot_confi

[06:56] <tadzik> g

[06:56] <tadzik> (hello #perl6)

[06:56] <Heather> tadzik hi

[06:57] <Heather> tadzik parrot config?

[06:57] *** uasi joined
[06:58] *** kaleem joined
[06:58] <Heather> and parrot is setting it during building?

[06:59] <Heather> then I will try to rebuild parrot

[07:01] <tadzik> yeah, that sounds right

[07:02] *** daniel-s_ joined
[07:04] <Heather> tadzik then it's rule that we must rebuild parrot after perl5 update

[07:04] <Heather> yes... seems like you're right it's building now

[07:07] <tadzik> well, I updated to 5.16.3 and didn't notice :)

[07:07] <tadzik> presumably because path is /home/tadzik/perl5/perlbrew/perls/perl-5.16.0/bin/perl

[07:07] <tadzik> so 5.16.0, no matter what minor version

[07:08] <Heather> I don't like to work in user environment )

[07:08] <tadzik> I do :) I like to pretend that I'm not the only user of this machine

[07:10] <Heather> tadzik I like to pretend that I'm not the only user of my distribution ^__^

[07:10] <tadzik> hehe

[07:12] <Heather> tadzik by the way I hate to work from user -_-' it's KDE affected me to.

[07:12] <Heather> usually I use root and user's stuff is mess for me

[07:13] <Heather> with next setup I'm gonna pick something lighter even if I love KDevelop I will try to bring it to some openbox or... something else

[07:13] <tadzik> I moved from KDE to i3 few months ago

[07:14] <Heather> tadzik tiling?

[07:14] <tadzik> yes

[07:14] <tadzik> KDE dropped tiling in some release, which made it completely useless for me

[07:14] <tadzik> not that it was particularly good before anyway

[07:14] <Heather> I don't like tiling

[07:15] <Heather> offtopic but I don't understand for what it can be useful

[07:15] <tadzik> I don't like using mouse, and it's non-trivial to manage windows without mouse and without tiling

[07:15] <tadzik> it's useful for not wasting screen space

[07:16] <Heather> tadzik so... what can you use w/o mouse at all?

[07:16] <Heather> tadzik instead of terminal

[07:16] <tadzik> Heather: web browser, email client, music player

[07:17] <Heather> -_-' and use open website and make tab -> tab -> tab ...

[07:17] <tadzik> hehehe, no

[07:17] <tadzik> welcome to XII century

[07:18] <tadzik> er, wait, no

[07:18] <tadzik> anyway

[07:18] <Heather> -_-'

[07:18] <tadzik> you press [f], and suddenly every link on the page is hilighted, like 'fxca'

[07:18] <tadzik> when I type 'fxca', it presses this link for me

[07:18] <tadzik> it's faster than aiming at it, even with a trackpoint

[07:19] <Heather> nah ! I can headshot you faster

[07:19] <Heather> but ... agreed about trackpoint

[07:19] <tadzik> try me

[07:19] <tadzik> I used to defeat people in nexuiz online playing without mouse, trackpoint only

[07:20] <Heather> I used to play with keyboard only when I was 5... or... nevermid :) I just don't get tiling

[07:21] <tadzik> nothing to get, I guess. I just don't like overlapping windows :)

[07:23] <Heather> matter of taste. some people say that they like tiling but they are working with terminals only. so I wonder why they need xorg. I see you're different kind :P

[07:27] <tadzik> hehe

[07:27] <tadzik> naturally, tiling WMs are better than managing terminals than non-X environments :)

[07:28] <tadzik> although I've seen tiling "WMs" being non-X apps themselves, what was the name of this...

[07:28] <tadzik> dvtm, that's the thing

[07:28] <Heather> I use tmux and emacs and I don't need some multi-terminals to work this way

[07:29] <tadzik> http://www.brain-dump.org/projects/dvtm/

[07:30] <tadzik> I guess tmux is capable of this too

[07:30] <Heather> tadzik https://github.com/Heather/dotfiles/blob/master/.tmux.conf this is much better though :)

[07:31] <Heather> tadzik and sure emacs... emacs in tmux is tiling in tiling... I really don't need another wm level tiling XD

[07:32] *** kivutar joined
[07:33] <Heather> tadzik but I need remove KDE monster -_-'

[07:35] <DrEeevil> Heather: and replace it with gnome3? ;)

[07:35] <Heather> DrEeevil I need own WM with blackjack and google reader

[07:42] *** domidumont joined
[07:56] * masak .oO( does the KDE monster eat kookies all the time? ) :P

[07:57] <masak> morning, #perl6

[07:57] <moritz> good morning, masak, *

[07:57] * masak is honored not to be in the globbed part :)

[07:58] <Heather> morning masak

[07:59] <moritz> masak: oh, whatever :-)

[07:59] <masak> :P

[08:00] <labster> morning (Whatever)

[08:00] <hoelzro> ahoy #perl6 o/

[08:00] <hoelzro> I pushed some new stuff to my NQP fork

[08:00] *** wtw joined
[08:00] <hoelzro> if someone could take a look at it =)

[08:00] <moritz> URL?

[08:01] <hoelzro> https://github.com/hoelzro/nqp

[08:02] <labster> Hey, is anyone here on windows?  If so, I'd like to see what the results of this is:  say nqp::p6box_i(nqp::stat(nqp::unbox_s('..'), pir::const::STAT_PLATFORM_INODE))

[08:02] <labster> I think I saw that parrot had some custom code for getting file IDs on windows, but I was wondering if it actually worked.

[08:02] <Heather> hoelzro a lot commits :(

[08:02] <hoelzro> =)

[08:03] <hoelzro> it's a lot of stuff on top of a lot of other stuff; I'll clean it up pre-merge

[08:03] <Heather> hoelzro you made work for maintainers -_-'

[08:03] <hoelzro> commute &

[08:08] <Heather> hoelzro https://github.com/hoelzro/useful-scripts/blob/master/tmux-compact.pl - what it makes?

[08:10] <diakopter> labster: "STAT_PLATFORM_INODE not supported"

[08:11] <labster> diakopter: guess not!  thanks.

[08:15] <labster> I've been thinking about a .inode method for IO, because it would be pretty useful for a couple of the things I've worked on.  But if it's not going to work on all platforms, it might not be such a bright idea.

[08:17] <moritz> do you want it to uniquely identify files?

[08:17] *** domidumont left
[08:17] <moritz> if so, you also need to know which mount point you're under

[08:17] *** domidumont joined
[08:41] *** fhelmberger joined
[08:46] <labster> Well, device is in the stat array as well, for identifying files.  Though so far, I've been looking at things in the same folder.  But we don't have a function to access the stat array as a whole yet, so I'm getting it piecemeal.

[08:51] *** wtw left
[08:57] *** wk joined
[08:59] *** kivutar left
[09:00] *** kivutar joined
[09:03] *** salv0 joined
[09:06] <hoelzro> has anyone had a chance to check out my NQP changes?

[09:06] *** wtw joined
[09:09] *** kivutar left
[09:09] *** wtw left
[09:09] *** wtw joined
[09:12] <masak> Heather: if you were to participate in a 4-hour Perl 6 course, (a) what time of the week would you prefer? and (b) what topics would you like to see?

[09:13] <Heather> masak depends course format

[09:14] <hoelzro> in token something:sym<{ }>, is 'sym' special, or can anything follow the colon and sym is used by convention?

[09:15] *** kivutar joined
[09:17] <moritz> sym is special

[09:21] <Heather> masak (a) for casual course format it will be Mon->Fri from 9->17 in UTF+4 timezone (b) in topic I will discover something that can help me in production alike if I can use it in embedded systems, also parser writing, compiler and core modules infrastructure, and many more...

[09:26] <hoelzro> ok, good to know!

[09:26] <hoelzro> I'll create a special case for it in the pygments lexer

[09:30] *** rindolf joined
[09:38] *** kresike joined
[09:38] <kresike> hello all you happy and/or unhappy perl6 people

[09:40] *** dakkar joined
[09:43] <Heather> I have a suggestion!

[09:43] <Heather> let keep all the stuff in /usr/lib/perl6 by default? :)

[09:49] <tadzik> 1) what's "all the stuff"?

[09:50] <tadzik> 2) I think everyone loves the fact that installing stuff without root Just Works

[09:50] <hoelzro> I *definitely* think you should be able to install modules/applications as a regular user

[09:50] <hoelzro> even if your installation is system-wide

[09:51] <Heather> tadzik examine some real software for all users, how will you install it?

[09:51] *** daxim joined
[09:52] <tadzik> Heather: with a system package manage

[09:52] <tadzik> which, as you probably know, almost never uses default settings anyway

[09:52] <Heather> hoelzro no, for secure reason you should not be able to install secure-wide stuff without some privilegies, and that's security feature

[09:52] <masak> Heather: thank you. that is valuable. I will try to accomodate that.

[09:52] <tadzik> you're missing the point, Heather 

[09:53] <hoelzro> right, if you want to install a module or application system-wide, you should need priviledges

[09:53] <tadzik> the point is: make it easy for the user to install module X

[09:53] <hoelzro> but if I want to install a module or application for my personal use, I should be able to do it

[09:53] <tadzik> and it has nothing to do with system-wide

[09:53] <hoelzro> kind of like a personal local::lib that's active by default

[09:53] <Heather> then panda does it well

[09:53] <Heather> I talk about /usr/lib/parrot/5.1.0/languages/perl6/site/

[09:54] <Heather> which is part of default path

[09:55] <hoelzro> oh, so /usr/lib/perl6 as opposed to that long path? I'm behind that

[09:55] <hoelzro> I think the way parrot lays things out might make that tricky, though

[09:56] <hoelzro> but I'm not an expert

[09:56] * hoelzro defers to an expert

[09:56] <tadzik> ah well, I don't care :)

[09:56] <tadzik> (about the system path)

[09:56] <tadzik> what we use now is mostly what Parrot conventions dictated

[09:56] <tadzik> (I think)

[09:56] <Heather> Panda overrides it -_-' to add home folder

[09:56] <tadzik> not really

[09:56] <Heather> adds to it

[09:57] <Heather> more correct

[09:57] <tadzik> panda uses the directory that is writable for it

[09:57] <tadzik> if /usr/lib/ was writable for bootstrap.pl, it'd use /usr/lib

[09:57] <Heather> tadzik let separate root level and usr level stuff :)

[09:59] <tadzik> of course

[09:59] <Heather> so ... all I need is to add /usr/lib/perl6 to PERL6LIB defaults...

[10:00] <Heather> or... /usr/lib/perl6/lib ... which looks some more weird :)

[10:01] <Heather> so for now I can say that it's to complex, unclear for me to setup everything there

[10:04] *** Rix joined
[10:05] <Heather> tadzik must be nooby question but why I can't see echo ${PERL6LIB}

[10:06] <hoelzro> Heather: it's probably empty

[10:06] <hoelzro> env | grep PERL6

[10:06] <Heather> nothing

[10:06] <hoelzro> right, so it's not set

[10:06] <hoelzro> PERL6LIB isn't always set; it's a way of adding to the defaults

[10:06] *** wtw left
[10:07] <Heather> I see...

[10:09] <hoelzro> do the characters following :sym have to be < and >? or any bracketing chars?

[10:19] *** pjcj left
[10:20] *** BooK joined
[10:20] *** bruges_ joined
[10:20] *** baest_ joined
[10:20] *** pjcj_ joined
[10:20] *** rjbs- joined
[10:20] *** djanatyn joined
[10:20] *** betterworld joined
[10:21] *** chee joined
[10:21] *** s0rear joined
[10:21] *** baest_ is now known as baest

[10:22] *** s0rear is now known as sorear

[10:25] *** am0c joined
[10:27] *** wtw joined
[10:28] <jnthn> Hello, #perl6

[10:28] <hoelzro> ahoy jnthn 

[10:43] <colomon> o/

[10:47] <dalek> nqp: 87b52fb | jnthn++ | src/QAST/Operations.nqp:

[10:47] <dalek> nqp: Avoid a circularity; pmichaud++ for noticing.

[10:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/87b52fb7a1

[10:48] <nwc10> jnthn: worked on my machine prior to that commit. Probably still does. Let's find out ...

[10:48] <hoelzro> jnthn: I updated my NQP fork to use nqp::x_posixerrno and pir::const::POSIX_E*

[10:48] <hoelzro> (if you feel like having a look)

[10:48] <Heather> r: say %*ENV<PERL6LIB>

[10:48] <p6eval> rakudo 2a41b3: OUTPUT¬´(Any)‚ê§¬ª

[10:51] <moritz> jnthn: what's wrong with that circularity?

[10:52] <jnthn> moritz: If the values Parrot used for those things were to change, we'd not follow them, iiuc.

[10:52] <moritz> ah

[10:52] <moritz> right

[10:52] <moritz> they'd better not change :-)

[10:53] <jnthn> ;)

[11:21] *** sizz joined
[11:41] <Heather> damn!

[11:41] <Heather> I can't use PERL6LIB as global variable

[11:41] <masak> why not?

[11:42] <masak> or, maybe rather, what do you mean?

[11:42] <Heather> masak I've got PERL6LIB set to /usr/lib (for example)

[11:43] <Heather> but panda (for example) don't care about it

[11:43] <Heather> doesn't

[11:43] <Heather> only if I do inline PERL6LIB=XXX panda then it works

[11:43] <moritz> stupid question, did you export PERL6LIB?

[11:43] <masak> are you using `export` when you set the env variable?

[11:44] <moritz> hah, masak had the same idea

[11:44] <Heather> masak I'm using env files, but it works same way as export

[11:44] *** erkan joined
[11:44] *** erkan left
[11:44] *** erkan joined
[11:45] <Heather> I need to set custom path for it forevA

[11:45] <Heather> not everytime :(

[11:45] <moritz> panda manipulates PERL6LIB

[11:45] <Heather> markov yes

[11:45] <Heather> moritz ^

[11:45] <moritz> but I don't think it touches RAKUDOLIB

[11:47] <Heather> can I echo this variable?

[11:47] <Heather> like it's added /root/.perl6/2013.02.1/lib but echo ${PERL6LIB[@]} says nothing about it

[11:48] <Heather> mystic :(

[11:48] <moritz> Heather: erm, I think you might misunderstand something

[11:48] <moritz> Heather: PERL6LIB *adds* paths to @*INC

[11:48] <Heather> moritz inc?

[11:48] <moritz> Heather: but of course there paths in @*INC that aren't in PERL6LIB

[11:48] <moritz> r: say @*INC.perl

[11:48] <p6eval> rakudo 2a41b3: OUTPUT¬´Array.new("/home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/site/lib", "/home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/vendor/lib", "/home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/lib", "/home/p6eval/.perl6/2013.02.1-147-g‚Ä¶

[11:48] <moritz> Heather: the list of paths used by the module loader to locate modules

[11:49] <Heather> right .... so if i run something that is not panda then I will not see this added path?

[11:50] <moritz> define "see"?

[11:50] <Heather> it will not be in INC

[11:50] *** xinming_ joined
[11:50] <moritz> if you add a path to PERL6LIB, it will show up in @*INC

[11:51] <Heather> once

[11:51] <Heather> right?

[11:51] <Heather> not forever stay there

[11:51] <moritz> it's added to @*INC every time you start the 'perl6' binary

[11:52] <moritz> so it's a matter of how long-lived the enviroment variable is

[11:52] <Heather> it confuses me even more...

[11:52] <moritz> let me try again

[11:53] <moritz> rakudo itself doesn't keep any state between invocations

[11:53] <moritz> so

[11:53] <moritz> when you run

[11:53] <moritz> perl6 -e '.say for @*INC'

[11:53] <moritz> before the program is parsed, rakudo reads the environment

[11:53] <Heather> I see path added by panda...

[11:53] <moritz> and adds paths to @*INC from PERL6LIB and from RAKUDOLIB

[11:54] <moritz> Heather: panda doesn't add any paths

[11:54] <Heather> ah

[11:54] <Heather> true

[11:54] <Heather> it's default one...

[11:55] <Heather> moritz and is there way to change default path?

[11:55] <moritz> yes, by patching rakudo

[11:55] <moritz> src/core/terms.pm

[11:56] <moritz> search for INC

[11:57] <Heather> I see...

[11:58] <Heather> I feel that I'm going to do something wrong now

[11:58] <moritz> what are you trying to do?

[11:59] <Heather> moritz install anything to root level

[11:59] <Heather> moritz in current state it's hell complicated

[11:59] <moritz> but for that you don't need to remove paths from @*INC, no?

[11:59] <moritz> afk

[12:00] <Heather> moritz I just need to add some env variable to defaults so I can setup stuff to /usr/lib/perl6 or to /usr/lib

[12:01] <Heather> I can count other ways of making job done, there are several ways but this one is most clear for me personally

[12:07] <Heather> wait...

[12:07] <Heather> @INC.push(%ENV<PERL6LIB>.split($VM<config><osname> eq 'MSWin32' ?? ';' !! ':')) if %ENV<PERL6LIB>;

[12:07] <Heather> it pushes PERL6LIB ENV here

[12:07] <Heather> I just need to use this env before installation...

[12:09] <Heather> I'll try

[12:14] *** shlomif joined
[12:15] *** rindolf left
[12:15] *** shlomif is now known as rindolf

[12:22] *** wtw left
[12:25] *** LlamaRider joined
[12:30] *** LlamaRider left
[12:30] *** SmokeMachine joined
[12:31] *** LlamaRider joined
[12:31] <Heather> Attempting to get PIR backtrace.  No guarantees.  Here goes... make: *** [NQPP5QRegex.pbc] Error 1

[12:32] <Heather> oh :(

[12:32] <[Coke]> (don't have the posix file generate posix.pasm - have it generate posix.pir but put the same constants in it.)

[12:36] <hoelzro> [Coke]: I take it this is regarding my work?

[12:37] <[Coke]> It's from about 12 hours ago. if you're generating a file of parrot constants, please use pir instead of pasm. (the generated file is exactly the same, just has a .pir extension)

[12:37] <[Coke]> (when pasm goes away, this will be one less thing that needs changing.)

[12:38] <hoelzro> [Coke]: and that PIR would be checked in?

[12:38] <[Coke]> whatever you would have done with the constants.

[12:38] <[Coke]> if posix constants are the same everywhere, sure. If there is some change per-machine, then I imagine each builder would need to generate their own.

[12:39] <Heather> it was bug of rebuilding

[12:39] <Heather> I need to uninstall and install again

[12:39] <hoelzro> ok, so I should build PIR instead of PASM, then?

[12:39] <[Coke]> Yes. again, it's the same file, just call it .pir

[12:40] <hoelzro> ok

[12:40] <hoelzro> I'll try that when I get home =)

[12:41] <[Coke]> Danke.

[12:56] *** woosley1 joined
[12:58] <Heather> m... I should specify both, perl6lib and rakudolib

[13:00] *** LlamaRider left
[13:05] *** domidumont left
[13:14] *** rindolf left
[13:16] *** rindolf joined
[13:17] *** jaldhar joined
[13:18] *** xinming joined
[13:18] *** bluescreen10 joined
[13:19] *** cognominal joined
[13:21] *** xinming_ left
[13:21] <dalek> nqp/cont: 3c65140 | jnthn++ | src/ (2 files):

[13:21] <dalek> nqp/cont: Toss current container spec config op.

[13:21] <dalek> nqp/cont: 

[13:21] <dalek> nqp/cont: Not used in NQP itself, and we'll be changing how container stuff is

[13:21] <dalek> nqp/cont: handled.

[13:21] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/3c65140996

[13:21] <dalek> nqp/cont: 11b1430 | jnthn++ | src/ (6 files):

[13:21] <dalek> nqp/cont: Start replacing container spec approach.

[13:21] <dalek> nqp/cont: 

[13:22] <dalek> nqp/cont: This is the minimum needed to get NQP to build and pass its tests again

[13:22] <dalek> nqp/cont: with the data structure updates. Still needs some more infrastructure

[13:22] <dalek> nqp/cont: before we can start updating Rakudo to use this new approach.

[13:22] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/11b1430080

[13:26] <arnsholt> Containers!

[13:26] <nwc10> twenty foot units?

[13:27] <nwc10> oh, not *that* sort of container

[13:28] <jnthn> arnsholt: Doing a re-work of the container spec stuff.

[13:28] <jnthn> arnsholt: It's partly portability related, partly related to fixing the whole "natives and is rw don't end well" thing.

[13:31] <arnsholt> Yeah, I figured. Which is awesome! =)

[13:33] *** PacoAir joined
[13:46] *** amkrankruleuen joined
[13:46] *** amkrankruleuen left
[13:46] *** amkrankruleuen joined
[13:46] *** amkrankruleuen left
[13:48] *** Kuss joined
[13:48] *** kaleem left
[13:49] *** Kuss left
[14:00] <nwc10> jnthn: I assume that it is totally expected that the new nqp/cont branch breaks nqp-jvm with a load of: Unhandled exception: java.lang.RuntimeException: Unknown serialization format version 4

[14:00] <nwc10> (which looks like a sanity test that is working as designed)

[14:04] *** woosley1 left
[14:05] <jnthn> nwc10: Yes

[14:21] <dalek> nqp/cont: 564d659 | jnthn++ | src/6model/sixmodelobject.h:

[14:21] <dalek> nqp/cont: Don't decontainerize type objects.

[14:21] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/564d6595de

[14:21] <dalek> nqp/cont: d5acd05 | jnthn++ | / (5 files):

[14:21] <dalek> nqp/cont: Add container spec registry and code_pair spec.

[14:21] <dalek> nqp/cont: 

[14:21] <dalek> nqp/cont: The registry keeps track of different containerization strategies we

[14:21] <dalek> nqp/cont: have. Implemented one that relies on a pair of code objects (a fetch

[14:21] <dalek> nqp/cont: and a store), which provides one aspect of the previous functionality.

[14:21] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/d5acd054bc

[14:21] <dalek> nqp/cont: 6037461 | jnthn++ | src/6model/serialization.c:

[14:21] <dalek> nqp/cont: Deserialization for new container support.

[14:21] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/60374611c6

[14:23] *** Psyche^ joined
[14:23] *** FROGGS joined
[14:24] *** SmokeMachine left
[14:26] <dalek> doc: 4774f93 | (Gabor Szabo)++ | lib/IO.pod:

[14:26] <dalek> doc: a few entries in IO

[14:26] <dalek> doc: review: https://github.com/perl6/doc/commit/4774f93634

[14:26] *** Psyche^ is now known as Patterner

[14:26] <dalek> nqp/cont: 7ca7a40 | jnthn++ | src/ (2 files):

[14:26] <dalek> nqp/cont: Add new nqp::setcontspec and an nqp::assign op.

[14:26] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/7ca7a40b91

[14:26] <dalek> nqp/cont: 61011ea | jnthn++ | t/nqp/67-container.t:

[14:26] <dalek> nqp/cont: Some tests for the new container stuff.

[14:27] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/61011ea701

[14:27] <dalek> nqp/cont: 8e570d8 | jnthn++ | src/6model/containers.c:

[14:27] <dalek> nqp/cont: Fix a replace-o.

[14:27] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/8e570d8ca5

[14:27] *** domidumont joined
[14:30] *** xilo joined
[14:31] *** SmokeMachine joined
[14:32] *** xilo left
[14:33] <jnthn> FROGGS: In docs/ROADMAP in Rakudo, you may want to review it - think you may have completed the array interpolation in regexes item in there?

[14:34] *** xilo joined
[14:35] <FROGGS> jnthn: well, it does it almost right... should I remove that item?

[14:36] <hoelzro> are Str:D/Str:U special, or are they just general adverbs applied to types?

[14:36] <pmichaud> good morning, #perl6

[14:37] <FROGGS> r: class XXX { }; say XXX:D

[14:37] <p6eval> rakudo 2a41b3: OUTPUT¬´(XXX)‚ê§¬ª

[14:37] <FROGGS> hoelzro: ----^

[14:37] <hoelzro> FROGGS: right, but can you do XXX:FooBar?

[14:37] <jnthn> FROGGS: How almost is almost? :)

[14:37] <jnthn> o/ pmichaud 

[14:37] <FROGGS> hoelzro: dont think so, D is for defined, U for undefined

[14:37] <hoelzro> ok

[14:37] <hoelzro> cool

[14:38] <FROGGS> jnthn: well, almost means that pmichaud pointed out a few things that are bugs (regexes within arrays)

[14:40] <FROGGS> jnthn: well, I would consider it done

[14:40] <jnthn> FROGGS: OK, I leave it up to you :)

[14:40] <FROGGS> :o)

[14:41] <jnthn> May want to update the features page too since it claims we only can interpolate scalars. :)

[14:43] *** cognominal__ joined
[14:45] *** cognominal left
[14:47] <FROGGS> jnthn: where is that feature page? do you mean that webpage?

[14:48] <jnthn> yeah

[14:48] <jnthn> on perl6.org

[14:48] <jnthn> There's a repo which contains a JSON file that you twiddle

[14:48] <jnthn> features under the perl6 org, iirc

[14:49] *** kivutar left
[14:49] <FROGGS> ahh, here it is https://github.com/perl6/features/blob/master/features.json

[14:53] <moritz> "This page is generated by process.pl from template.html and features.json, all of which can be found in the perl6/features repository. The canonical location for this page is at http://perl6.org/compilers/features and is updated at least hourly."

[14:53] <pmichaud> moritz: nobody sees that... it looks too much like a README entry.  :-P

[14:53] <FROGGS> hehe

[14:54] <moritz> pmichaud: I should start that section with "Secret, hacker-only knowledge ahead" or so :-)

[14:54] <pmichaud> moritz++

[14:54] <[Coke]> oh, too complicated, I can't read that.

[14:56] <dalek> nqp/cont: 335e5c9 | jnthn++ | src/ (4 files):

[14:56] <dalek> nqp/cont: Add nqp::assignunchecked(...).

[14:56] <dalek> nqp/cont: 

[14:56] <dalek> nqp/cont: Used for the case when the compiler (probably the optimizer) already

[14:56] <dalek> nqp/cont: concluded that the assignment is safe.

[14:56] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/335e5c9c9d

[14:56] <dalek> nqp/cont: 92f47c4 | jnthn++ | t/nqp/67-container.t:

[14:56] <dalek> nqp/cont: Test nqp::assignunchecked op.

[14:56] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/92f47c4e7d

[14:57] <dalek> rakudo/nom: b3b5f8e | pmichaud++ | docs/ChangeLog:

[14:57] <dalek> rakudo/nom: Update ChangeLog with Range as Range endpoint error.

[14:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b3b5f8e95d

[14:58] *** kaare_ joined
[14:58] *** benabik joined
[15:00] <cognominal__> reading Operations.nqp, I can't find the documentation for the strings describing the registers. Not the first time I ask, but I keep forgetting. Sorry

[15:01] *** xilo left
[15:03] <cognominal__> I see that it is treated by the sub pirop_mapper

[15:04] *** xilo joined
[15:10] *** d4l3k_ joined
[15:11] *** bruges joined
[15:13] <moritz> what do you mean by "strings describing the registers"?

[15:14] <moritz> a register is either named $P1, $S42 etc., or as an identifier if it's pre-declared

[15:14] *** xinming_ joined
[15:14] *** integral joined
[15:14] *** integral left
[15:14] *** integral joined
[15:14] *** Util_ joined
[15:15] *** SmokeMachine left
[15:16] *** `patch` joined
[15:17] <cognominal__> moritz, for example, in QAST::Operations.add_core_pirop_mapping('bindcurhllsym', 'set_hll_global', '1sP'), '1SP' describes the type of the registers

[15:18] *** xorp_ joined
[15:18] <cognominal__> I search the doc that describes the convention for building that string

[15:18] <pmichaud> it describes the types of the arguments

[15:19] <pmichaud> 's' means string register or string constant

[15:19] <pmichaud> 'P' means PMC register

[15:19] <pmichaud> '1' means that the result of the operation is whatever one of the arguments evaluated to

[15:19] <pmichaud> (since set_hll_global doesn't return a value itself)

[15:20] <cognominal__> there is also a 'Q' somewhere

[15:20] <moritz> '1' means that argument with index 1 (so the second argument) is returned

[15:20] <cognominal__> but I know there is a doc for that

[15:20] <moritz> at least there was a doc for that :-)

[15:20] <pmichaud> yes, in PCT

[15:20] <cognominal__> ha!!

[15:20] <pmichaud> I don't know that it's ever been put into nqp

[15:20] <moritz> ah, so parrot repo

[15:20] *** SmokeMachine joined
[15:20] <pmichaud> it needs to be.

[15:21] <jnthn> Go for it, but remember that what is supported now probably differes from in PCT.

[15:21] *** xinming left
[15:21] *** bruges_ left
[15:22] *** d4l3k_ is now known as dalek

[15:22] <moritz> cognominal__: Q has something to do with the Key syntax in PIR

[15:22] <moritz> like ["foo";1]

[15:22] <pmichaud> actually, like  $P0["foo"]

[15:23] *** grondilu joined
[15:23] <arnsholt> cognominal__: sub pirop_mapper in Operations.nqp is the bit of code that does the transformation

[15:23] <moritz> pmichaud: no, that can be mapped with a simple nqp::atkey

[15:23] <pmichaud> Q indicates a keyed PMC, with the next character indicating the type of key

[15:23] <moritz> oh

[15:23] <moritz> ok

[15:24] <pmichaud> thus   Qs   indicates something of the form  $P0[str]

[15:24] <moritz> then probably not used very often in modern nqp :-)

[15:24] <cognominal__> ok. this is so strange to see high level stuff the functionnal style encouraged by nqp when usual perl stuff like vivification is missing :)

[15:24] <cognominal__> *stuff like the

[15:25] <cognominal__> Also is there a doc about the way nqp is bootstrapped? I don't get it.

[15:25] <pmichaud> QAST::Operations.add_core_pirop_mapping('positional_get', 'set', 'PQi', :inlinable(1));

[15:25] <pmichaud> QAST::Operations.add_core_pirop_mapping('positional_bind', 'set', '1QiP', :inlinable(1));

[15:25] <pmichaud> QAST::Operations.add_core_pirop_mapping('associative_get', 'set', 'PQs', :inlinable(1));

[15:25] <pmichaud> QAST::Operations.add_core_pirop_mapping('associative_bind', 'set', '1QsP', :inlinable(1));

[15:25] <arnsholt> moritz: FWIW, atkey uses Q =)

[15:25] <pmichaud> and all of the atkey/bindkey etc operations use the Q type

[15:26] <moritz> ok, I stand corrected

[15:26] <pmichaud> indeed, Q is how they're able to work :-)

[15:26] <cognominal__> btw, I have a pull request for nqp which is probably harmless

[15:26] <pmichaud> cognominal__: I don't know if there's a doc about it.

[15:27] <pmichaud> cognominal__: essentially, there are PIR files in src/stage0 that build an instance of the nqp compiler.  That nqp compiler is then used to build a "real" nqp compiler from the nqp sources.

[15:28] <pmichaud> since the nqp sources are "official"

[15:28] *** xilo left
[15:29] *** xilo joined
[15:31] *** cognominal joined
[15:31] *** cognominal__ left
[15:33] <cognominal> thx, my connection is unstable but I am reading the irc log

[15:35] <cognominal> I guess I understand the principle but not the ultimate magic. How this stage0 pir files were generated?

[15:36] <pmichaud> from a previous compilation of nqp

[15:36] <cognominal> is that just an historical process that could not be repeated ?

[15:36] <pmichaud> it is repeated

[15:36] <pmichaud> after we build an "official" nqp from the nqp sources, we can copy its .pir files into the stage0 directory and update the repo with them

[15:36] <cognominal> but the original nqp must come from somewhere

[15:37] <jnthn> The stage0 is that somewhere :)

[15:37] <moritz> the original nqp was bootstrap with nqp-rx

[15:37] <moritz> which again was bootstrapped from the original nqp

[15:37] <moritz> which was bootstrapped from PCT, iirc

[15:37] <moritz> which was written in PIR

[15:37] <cognominal> moritz++ 

[15:37] <pmichaud> well, the original nqp-rx was bootstrapped with some manual help

[15:38] <moritz> cognominal: it's a bit like with a C compiler: you need to compile it with some C compiler first

[15:38] <moritz> either with an earlier version, or with a different compiler

[15:38] <cognominal> so nqp-rx has still some utility at the bootstrapping stage

[15:38] <pmichaud> no.

[15:38] <moritz> no

[15:38] <moritz> cognominal: the first version of nqp was bootstrapped with nqp-r

[15:38] <pmichaud> forget nqp-rx, it's not important except for historical value.

[15:38] <moritz> *nqp-rx

[15:38] <moritz> now nqp bootstrapps itself

[15:38] <nwc10> and that gets you to http://cm.bell-labs.com/who/ken/trust.html

[15:39] <pmichaud> cognominal: once we have a built copy of 'nqp', the "make bootstrap" target copies its files into src/stage0

[15:39] <pmichaud> in particular, it copies its .pir files into src/stage0

[15:39] <pmichaud> if we then check those .pir files into the repo, that instance of nqp becomes the new stage0 for building future instances of nqp

[15:40] <pmichaud> er, "make bootstrap-files" it looks like.

[15:41] <arnsholt> Yeah, bootstrap-files

[15:42] <nwc10> self hosted bootstrapping compilers, and separating out the front and back ends so that cross compiling is possible, are awesome. Someone explained it to me 20 years ago, and after I digested it, it was "wow"

[15:42] <nwc10> as in "very worth it, for the flexibility"

[15:43] *** orafu joined
[15:43] *** cognominal left
[15:45] *** cognominal joined
[15:46] <dalek> rakudo/cont: b17ffa8 | jnthn++ | src/ (28 files):

[15:46] <dalek> rakudo/cont: Eliminate nqp::p6decont for plain nqp::decont.

[15:46] <dalek> rakudo/cont: 

[15:46] <dalek> rakudo/cont: We'll attach the Rakudo semantics/optimization directly to the type

[15:46] <dalek> rakudo/cont: using the new container spec handling.

[15:46] <dalek> rakudo/cont: review: https://github.com/rakudo/rakudo/commit/b17ffa86bd

[15:46] <dalek> rakudo/cont: a5aa552 | jnthn++ | src/binder/sixmodelobject.h:

[15:46] <dalek> rakudo/cont: Get latest 6model header file.

[15:46] <dalek> rakudo/cont: review: https://github.com/rakudo/rakudo/commit/a5aa55295d

[15:46] <dalek> rakudo/cont: c7911a2 | jnthn++ | src/ (6 files):

[15:46] <dalek> rakudo/cont: Eliminate p6store op in favor of nqp::assign.

[15:46] <dalek> rakudo/cont: 

[15:46] <dalek> rakudo/cont: Note some more work needed before this will work.

[15:46] <dalek> rakudo/cont: review: https://github.com/rakudo/rakudo/commit/c7911a2084

[15:46] <dalek> nqp/cont: 80f6d1a | jnthn++ | src/6model/ (2 files):

[15:46] <dalek> nqp/cont: Provide a way for libs to register containers.

[15:46] <dalek> nqp/cont: 

[15:46] <dalek> nqp/cont: This means that Rakudo will be able to set up its scalar handling.

[15:46] <dalek> nqp/cont: review: https://github.com/perl6/nqp/commit/80f6d1a1e2

[15:48] <dalek> nqp: efb432b | pmichaud++ | src/QAST/Operations.nqp:

[15:48] <dalek> nqp: Add some documentation about signature argument to pirop_mapper.

[15:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/efb432bd9d

[15:48] <cognominal> thx

[15:48] <[Coke]>  pmichaud++ cognominal++ # i remember having to find those in parrot more than once.

[15:49] <pmichaud> it still needs better documentation elsewhere, but at least it's now in the nqp repo

[15:49] <[Coke]> (or their cousins, anyway)

[15:51] <cognominal> pmichaud++

[15:51] <dalek> rakudo/cont: 8b49b7a | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[15:51] <dalek> rakudo/cont: Update nqp::setcontspec usages for new protocol.

[15:51] <dalek> rakudo/cont: review: https://github.com/rakudo/rakudo/commit/8b49b7afd3

[15:51] <dalek> rakudo/cont: 044f377 | jnthn++ | src/core/ (2 files):

[15:51] <dalek> rakudo/cont: A couple of stray nqp::p6decont => nqp::decont.

[15:51] <dalek> rakudo/cont: review: https://github.com/rakudo/rakudo/commit/044f377dd2

[15:52] <jnthn> pmichaud: The good news: Rakudo now builds with the new container stuff

[15:52] <jnthn> pmichaud: The bad news: we relied on a failover of "this isn't a scalar but we're trying to assign to it" to call a .STORE method, for array assignment.

[15:52] <jnthn> And hash, and parcel...

[15:53] <pmichaud> I thought you knew that already. 

[15:53] <jnthn> I'd...forgot ;/

[15:53] <jnthn> Grrrrrr.

[15:53] <jnthn> That's a pain.

[15:53] <pmichaud> well, how should it be done, then?

[15:53] <jnthn> Good question.

[15:54] <jnthn> Maybe just by making it explicit in the code-gen.

[15:54] *** chinaXing joined
[15:54] <jnthn> Rather than trying to have it fail over at C level

[15:54] <pmichaud> I kind of figured you had already taken that into account with "Rakudo can just register its functions for this"

[15:55] <jnthn> Yeah but...

[15:55] <jnthn> Those are for if we've already decided it's a container.

[15:55] <moritz> we know at compile time whether an = is list assignment or item assignment, right?

[15:55] <jnthn> moritz: In many cases.

[15:56] <jnthn> Today we actually try to optimize a bunch of those.

[15:56] <jnthn> The failover is not idea 'cus it happens in C code, which means it's an inferior runloop whenever we do it.

[15:56] <pmichaud> hold that thread for a second

[15:56] <jnthn> *ideal

[15:56] <pmichaud> there's a related question of   "what should C<my @a> do in the first place?"

[15:57] <pmichaud> Rakudo has always had it vivify an array.  There's an argument to be made that @a should not vivify to an array until something is put into it.

[15:57] <pmichaud> I don't know what the official spec position is on that, thesedays.

[15:57] <pmichaud> at one point it was "fall back to p5 behavior", which would have @a be undef

[15:58] *** renormalist joined
[15:58] <pmichaud> thus, for a while we had a "we need to change @a to be a container" todo item that we never acted on because it was too disruptive to the codebase

[15:59] <jnthn> I think the problem with that is we'd have to have some kind of container around the Array type object, so when you pass it it can update the container with the vivified thing.

[15:59] <jnthn> And that is indeed disruptive because today "is a container" is really "is a *scalar* container"

[16:00] <jnthn> Plus it's rare you'd declare an array and then never use it, so it is mostly just a promise of another level of indirection.

[16:00] <jnthn> The only reason to do it would be if there's some correctness that depends on it, imho.

[16:00] <pmichaud> such as "an array is undefined until something is put into it"

[16:01] <moritz> iirc the spec requires this at two points

[16:01] <moritz> one of them is   sub f(@a?) { } leaving @a undefined if it's not filled

[16:01] <pmichaud> istr there's even an RT ticket with a complex problem that is supposedly solved by undefined aggregate definitions.  I'll see if I can find it.

[16:02] <jnthn> .oO( This is not the can of worms I was looking for :/ )

[16:04] <jnthn> https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.pm#L4482 is the opt I was mentioning, fwiw.

[16:05] <jnthn> r: my @a; my $x := @a; $x = (1,2,3); say @a

[16:05] <p6eval> rakudo b3b5f8: OUTPUT¬´1 2 3‚ê§¬ª

[16:05] <kresike> bye folks

[16:05] *** kresike left
[16:05] <jnthn> Dunno if the above eval is considered correct

[16:06] <jnthn> prn: my @a; my $x := @a; $x = (1,2,3); say @a

[16:06] <p6eval> pugs: OUTPUT¬´123‚ê§¬ª

[16:06] <p6eval> ..rakudo b3b5f8: OUTPUT¬´1 2 3‚ê§¬ª

[16:06] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT¬´Unhandled exception: Writing to readonly scalar‚ê§  at /tmp/j60RB3Iu39 line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583) ‚ê§  at /home/p6eval/niecza/li‚Ä¶

[16:06] <pmichaud> note that rakudo still has a scalar binding discrepancy from last summer that has yet to be resolved, also.

[16:07] <pmichaud> (discrepancy with niecza, that is)

[16:07] <pmichaud> (and niecza's interpretation was deemed 'more correct')

[16:07] <jnthn> Note that in my cont branch, we now actually give the same answer as Niecza

[16:07] <jnthn> Because we don't even attempt the fallback now.

[16:08] <pmichaud> just a sec, let me find the other change that we'd have to make from last summer, as it obviously is implicated in these changes also

[16:08] <jnthn> *nod*

[16:09] *** tokuhiro_ joined
[16:09] <pmichaud> rn: my @a = 1,2,3;  my $s := @a;  say $s =:= @a;

[16:09] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´False‚ê§¬ª

[16:09] <p6eval> ..rakudo b3b5f8: OUTPUT¬´True‚ê§¬ª

[16:10] <moritz> nr: my @a = 1, 2, 3; my $s := @a; my $cnt; $cnt++ for $s; say $cnt

[16:10] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´1‚ê§¬ª

[16:10] <p6eval> ..rakudo b3b5f8: OUTPUT¬´3‚ê§¬ª

[16:10] <pmichaud> niecza is correct here.

[16:11] <jnthn> pmichaud: In *both* of the above?

[16:11] <pmichaud> in at least the second one.

[16:11] *** cognominal left
[16:11] <jnthn> I struggle to see how to make the second one happening without making the first one happen.

[16:12] *** cognominal joined
[16:12] <pmichaud> iirc, when confronted with   my $s := @a,  niecza sees that @a isn't a scalar container and therefore makes one for it.

[16:12] <pmichaud> the interesting case is:

[16:12] <pmichaud> rn:  my @a = 1,2,3;  my $s := @a;  my $t := @a;  say $s =:= $t;

[16:12] <p6eval> rakudo b3b5f8, niecza v24-35-g5c06e28: OUTPUT¬´True‚ê§¬ª

[16:12] <pmichaud> in other words, $s and $t both end up with the same scalar container

[16:12] <jnthn> ...huh.

[16:13] * moritz is baffled

[16:13] <pmichaud> neither of which are @a

[16:13] <jnthn> Or =:= is doing magic...

[16:13] <pmichaud> rn:  my @a = 1,2,3;  my $s := @a;  my $t := @a;  say $s =:= $t;;  say $s =:= @a;  say $t =:= @a;

[16:13] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´True‚ê§False‚ê§False‚ê§¬ª

[16:13] <p6eval> ..rakudo b3b5f8: OUTPUT¬´True‚ê§True‚ê§True‚ê§¬ª

[16:14] *** domidumont left
[16:15] <pmichaud> well, the second one could happen if we separated the notion of 'flattening' from 'scalar container'.  There's nothing in the spec that yet requires it.

[16:15] <pmichaud> ...except that it then becomes a weirdly syntactic issue.

[16:16] <pmichaud> which is somewhat implied in the notion of "if you see a '$' it doesn't flatten", which is obviously syntactic.

[16:16] <arnsholt> jnthn: Which REPR method should get_number() dispatch to, in your opinion?

[16:16] <jnthn> It...shouldn't...

[16:16] * pmichaud shudders at the notion of "get_number"

[16:17] <pmichaud> s/notion/mention/

[16:17] <jnthn> Parrot confused coercion (a HLL concept) and unboxing (a representation concept) for ages.

[16:17] <pmichaud> and also tried to treat "num" as the type that could hold all numeric representations.

[16:18] <arnsholt> Right

[16:18] *** am0c left
[16:18] <jnthn> I don't really know how to deal with this too well. 

[16:18] <arnsholt> Aha. It's my latest error on the vmarray branch

[16:19] <arnsholt> It's +@array which becomes set $N..., $P...

[16:19] <arnsholt> Which in turn calls the get_number VTABLE

[16:20] <jnthn> Yeah. On the JVM it hits a smart_numify op that is too clever for its own good.

[16:20] <pmichaud> arnsholt: in qrpa, get_number just gets forwarded to elements

[16:20] <jnthn> Rakudo doesn't ahve the issue because +@array boils down to a call to .Numeric.

[16:20] <hoelzro> when writing an EXPORT for a module, how does one inject values into the calling context? Something with CALLER, I presume?

[16:22] <arnsholt> pmichaud: There is that. But now it's a sixmodel object, so the fix is going to impact all sixmodel objects, not only the VMArray stuff

[16:22] <pmichaud> jnthn: so, it sounds like to continue progress on the container branch, we need to flesh out exactly what should happen for binding/assignment of aggregates

[16:23] <jnthn> pmichaud: Yes.

[16:23] <pmichaud> jnthn: when shall we do that?

[16:24] <jnthn> pmichaud: Well, it's kinda a blocker for this branch :)

[16:24] <jnthn> pmichaud: I can look at it now

[16:24] <pmichaud> I guess I'm asking "today" versus "tomorrow"  :)

[16:24] <jnthn> But dunno if you've other stuff you should be doing

[16:24] <jnthn> Tomorrow I have some $dayjob stuff to attend to. Today I don't. )

[16:24] <pmichaud> okay

[16:25] <pmichaud> arnsholt: sorry, I haven't been following VMArray enough to know how that should be.

[16:25] <arnsholt> Oh, right

[16:25] <pmichaud> arnsholt: other than to suggest that perhaps  +@array should throw an exception, and that the correct nqp code is   nqp::elems(@array)

[16:26] <pmichaud> similarly   @array + 1  would need to be   nqp::elems(@array) + 1

[16:26] <arnsholt> Hmm, that's not a bad idea, methinks

[16:26] <jnthn> arnsholt: The problem is messy enough in general that it had made me wonder if I could put of ever having to resolve these issues with the Parrot backend...

[16:26] <jnthn> *put off

[16:26] <pmichaud> right now nqp relies on Parrot's  get_number polymorphism to get prefix:<+> and infix:<+> to work on arays.

[16:26] <pmichaud> *arrays

[16:27] <jnthn> On NQP JVM, nmumification calls an op called smart_numify

[16:27] <jnthn> It basically says, "does this thing have a Numeric method", and if so it calls it.

[16:27] <jnthn> Otherwise it does a few bits of case analysis.

[16:27] <jnthn> It's not particularly wonderful.

[16:28] <jnthn> But for NQP it's sufficient.

[16:28] <jnthn> And for Rakudo the problem doesn't exist 'cus everything has a Numeric method :)

[16:30] <arnsholt> Right. So it might be just as good to kill off all uses of implicit numification of lists?

[16:30] <pmichaud> jnthn: okay, I think I need a bit more understanding about how the new container stuff should work.

[16:32] <jnthn> pmichaud: OK. I'll start off with what is the same.

[16:33] <jnthn> STables have a container_spec slot. It's NULL for non-containers (which means non-scalars to date)

[16:33] <jnthn> nqp::setcontspec(SomeType, ...) hangs some stuff off container_spec indicating "this type serves as a scalar container"

[16:34] <jnthn> Before, we always specified enough information to do a decontainerization. However, it was inflexible. You could either (a) specify what attribute held the value, or (b) specify an invokable thing (which handled the Proxy case)

[16:35] <jnthn> Now, rather than configuring attributes, or code refs, or whatever, the form is always

[16:35] <jnthn> nqp::setcontspec(SomeType, 'some_name', nqp::hash(...))

[16:36] *** census joined
[16:36] <jnthn> some_name specifies a kind of container configuration, the hash is optional and is used of the container configuration needs some more info

[16:36] *** gdey joined
[16:36] *** betterwo1ld joined
[16:36] *** betterworld left
[16:36] <jnthn> For example, Proxy does this:

[16:36] <jnthn>     nqp::setcontspec(Proxy, 'code_pair', nqp::hash(

[16:36] <jnthn>         'fetch', $PROXY_FETCH,

[16:36] <jnthn>         'store', $PROXY_STORE

[16:36] <jnthn>     ));

[16:37] <jnthn> Rakudo registers its own rakudo_scalar configuration, which just knows about the layout of the Scalar type and pokes the value into he right place, or retrieves it from the right place. It needs no configuration hash.

[16:37] <jnthn> (that registration/lookup being done in C land)

[16:37] <jnthn> Before, the only thing we had that wasn't Rakudo specific was was nqp::decont

[16:38] <jnthn> However, it was a slow path, 'cus it always went through the attribute lookup. We had a fast-pathed p6decont

[16:38] <jnthn> Now, p6decont is gone, and we can hang the fast-path right off the container_spec.

[16:38] <jnthn> Meaning we save doing any kind of type check there too

[16:39] <jnthn> There was no generalized notion of assign before. Now there is an nqp::assign op, which boils down to a "is this a container" check and then just STABLE(cont)->container_spec->store(interp, cont, decont_value)

[16:40] <jnthn> Thing is, before Rakudo had its own opcode for assigning.

[16:40] *** domidumont joined
[16:40] <jnthn> The bit I'd forgot is that op didn't just check "is this a container" and then did its work.

[16:40] <jnthn> It had an "else" there that instead of complaining, said "oh, so does it have a FETCH method"

[16:40] <jnthn> uh, sorry, STORE.

[16:40] <jnthn> And called it. In an inferior runloop.

[16:41] <jnthn> We avoided many of those by the sigil analysis I linked to earlier.

[16:41] *** census_ joined
[16:42] *** domidumont left
[16:42] *** mikemol joined
[16:42] *** census left
[16:42] <jnthn> That's the story so far, I think.

[16:43] <pmichaud> got it, thinking and researching a bit

[16:43] <jnthn> OK

[16:43] *** census_ left
[16:43] <jnthn> I'm trying one possible "easy fix" to see if it's viable in any sense.

[16:43] *** census joined
[16:43] <pmichaud> okay.  I'm thinking we're at the point where we need to look at all of these related issues in terms of a unified whole.

[16:44] <pmichaud> n:  my @a;  say @a.defined;   # curious

[16:44] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´True‚ê§¬ª

[16:44] *** kivutar joined
[16:44] <pmichaud> n:  sub foo(@a?) { say @a.defined };  foo()

[16:44] <p6eval> niecza v24-35-g5c06e28: OUTPUT¬´True‚ê§¬ª

[16:45] *** domidumont joined
[16:48] <pmichaud> I'm trying to find the ticket that wanted @a to be undef

[16:48] *** cognominal__ joined
[16:48] <nwc10> defined on arrays and hashes turned out to be a bad thing in Perl 5

[16:48] <pmichaud> nwc10: I think it was the fact that they would return to undef status at some point

[16:49] <pmichaud> not that they were initially undefined

[16:49] *** cognominal left
[16:49] <nwc10> I'm not sure if I'm missing your point, but it got painful once we wanted to change things so that some things were never undef (eg symbol tables)

[16:49] <geekosaur> the problem is that defined on either actually refers to whether there has been memory allocation for the container or not, not whether it has values or not

[16:49] <FROGGS> for me @arr+@arr

[16:49] <FROGGS> err

[16:49] <FROGGS> for me @arr.defined is more like +@arr

[16:49] <nwc10> because a bunch of code was assuming that a symbol table you hadn't yet populated was undef

[16:50] *** Celelibi joined
[16:50] * nwc10 is summoned for food

[16:50] <cognominal__> salut, Celelibi 

[16:52] <jnthn> pmichaud: https://rt.perl.org/rt3/Ticket/Display.html?id=64928 maybe

[16:52] <pmichaud> yes, that's it.

[16:54] <pmichaud> let me see if I can enumerate the issues we have

[16:54] *** rafl joined
[16:54] <pmichaud> 1.  we need to have a way to distinguish $x and @x, even when bound (:=) to the same object

[16:54] <pmichaud> 2.  we need a way of handling array, hash, parcel, and list assignment

[16:55] <pmichaud> 3.  we need support for Proxy-like objects

[16:55] * FROGGS .oO( an enum starts with 1 these days? )

[16:55] <pmichaud> 4.  we may need to have the capability to have @a and %h to be undefined, e.g. as optional parameters

[16:56] <pmichaud> 5.  our scalar containers need to be able to perform type-checking

[16:56] <pmichaud> 6.  including the scalar containers in aggregates such as Array and Hash

[16:57] <pmichaud> any others?

[16:58] <jnthn> I think 5 isn't a problem (we've got that solved), but 6 is (though perhaps more NYI than anything)

[16:58] <jnthn> But yes, it's a good summary I think.

[16:59] <jnthn> I'd maybe add 7. we don't want nested runloops

[16:59] <pmichaud> well, "issues" should be "things that a solution has to accommodate"

[16:59] <jnthn> Ah, then in that case yes

[17:00] <jnthn> on 7 though I'd say maybe Proxy can cope with having 'em, but in general...

[17:01] <pmichaud> is there anywhere other than flattening that having "container" mean "scalar container" is important?

[17:01] <jnthn> The other thing is that we need to be able to pass native things as rw

[17:01] *** SunilJoshi joined
[17:01] <pmichaud> 7.  pass native things as rw values

[17:01] <jnthn> Which really means taking a reference to them, which is technically doable with a Proxy but we want something more efficient.

[17:02] <pmichaud> I'm not entirely comfortable with Proxy, fwiw.

[17:02] <jnthn> But that falls out of the other bits I've been doing so it's not a "new problem"

[17:02] *** chinaXing left
[17:03] <jnthn> Well, the way I was planning to do it was to have some notion of reference there

[17:03] <pmichaud> where "it" is...?

[17:03] *** chinaXing joined
[17:03] *** chinaXing left
[17:04] <jnthn> The "passing native things as rw"

[17:04] <pmichaud> okay

[17:04] <jnthn> I can't think of anything other than flattening where that is the case.

[17:05] <pmichaud> I think I need to take a short walk to re-orient my head around these things again.

[17:06] <jnthn> ok

[17:06] <pmichaud> I should note that as far as I'm concerned there's nothing locking us into the current way that assignment is handled for lists/arrays/hashes

[17:06] <pmichaud> it's just the way things were

[17:06] <pmichaud> oh

[17:06] <jnthn> *nod*

[17:07] <pmichaud> 8.  handle autovivification on assignment

[17:07] <jnthn> Hm, that's done with the whence thingy today...oh, which is also a nested runloop

[17:07] <pmichaud> and there's an issue with that also

[17:08] <pmichaud> whence and proxy seems to me like they're two solutions to the same problem.

[17:09] <pmichaud> (where there perhaps should be only one really fast solution)

[17:09] *** mls joined
[17:09] <jnthn> Hm, perhaps.

[17:11] <pmichaud> rn:  my @x = 1, 2, [3,4,5], 6;   for @x[2] { .say }

[17:11] <p6eval> rakudo b3b5f8, niecza v24-35-g5c06e28: OUTPUT¬´3 4 5‚ê§¬ª

[17:15] <pmichaud> okay, taking a walk -- bbi15

[17:25] *** tokuhiro_ left
[17:28] *** cognominal__ left
[17:29] *** SHODAN joined
[17:32] *** census left
[17:33] *** cognominal joined
[17:34] *** census joined
[17:36] <pmichaud> back again

[17:36] <jnthn> wb

[17:37] <pmichaud> right now, is there an implicit assumption that any Proxy object won't flatten?

[17:39] <jnthn> It counts as a container, which I think we use to mean "don't flatten"

[17:39] <pmichaud> (since it has its own setcontspec)

[17:39] <pmichaud> hmmm

[17:39] <jnthn> But we hardly use Proxy afaik.

[17:39] <jnthn> checking

[17:39] <pmichaud> we use it in Str and Bag and a few places

[17:39] <pmichaud> which I think to be fundamentally wrong -- a code-around for a more correct solution

[17:39] <jnthn> Oh, I'm wrong

[17:39] <jnthn> yeah

[17:39] <jnthn> Bag, Set, Str, terms

[17:40] <jnthn> Str for substr-rw

[17:40] <pmichaud> it's either fundamentally wrong and needs a more correct solution, or it's fundamentally right and we should be using it in a lot more places.

[17:42] <jnthn> One notable difference between it and the $!whence mechanism is that a $!whence is on a normal scalar, whereas when you use Proxy it's a different container type

[17:42] <arnsholt> jnthn: Oh, this is a fun one. foo(|@a) is broken now

[17:42] <jnthn> And we probably want %h<some_key_to_autoviv> to use Scalar

[17:43] <pmichaud> well, $!whence is also a coarse approximation of the WHENCE spec

[17:43] <pmichaud> what we have now are coarse approximations to various pieces of the spec that are likely waiting for implementations to figure out how it should be done

[17:43] <pmichaud> our Proxy is a coarse approximation of the mention of Proxy in S06 :-)

[17:45] <TimToady> probably what we should be asking ourselves is whether we really need a separate object, or just some role mixin that can intercept fetches and stores

[17:45] *** wk left
[17:46] <pmichaud> "role mixin that can intercept fetches and stores" implies some way of quickly detecting that there's an intercept, I think.

[17:46] <jnthn> Role mixin to what, exactly?

[17:46] <pmichaud> well, in the substr-rw example, it'd be a mixin to a Str value

[17:46] <TimToady> to the type of an attribute somehow, is what I was thinkin'

[17:47] <TimToady> not claiming to be thinking straight...

[17:48] * TimToady realizes that fetches and stores are kinda subterranean to normal Perl 6

[17:48] <jnthn> pmichaud: Today we've carefully separated out containers and values.

[17:48] <pmichaud> except where they appear in the spec as things like C<Proxy> and C<WHENCE>  :-)

[17:48] *** kivutar left
[17:49] <jnthn> pmichaud: That would seem to confuse them a little I guess. But maybe it's OK for that particular case.

[17:49] <pmichaud> jnthn: I'm not sure what you mean by "separated out containers and values"

[17:49] <jnthn> pmichaud: Scalar and Proxy are containers.

[17:49] <jnthn> Str is a value.

[17:49] <pmichaud> yes, but what does that have to do with Proxy, WHENCE, FETCH, etc?

[17:50] <pmichaud> are you saying that we can never STORE to a value?

[17:50] <jnthn> I'm saying that so far as Scalar things go today, we never do.

[17:50] <pmichaud> well, in some sense it has an implicit STORE operation

[17:51] <TimToady> store is kind of a native concept, where memory cells are containers

[17:51] <pmichaud> what we have for Scalar is an assignment operation that avoids the overhead of finding and invoking a STORE method

[17:51] <PerlJam> Am I the only one who wants some hungarian way to distinguish value types and container types?

[17:51] <pmichaud> I like the notion of "store as a native concept"

[17:51] <jnthn> Yes, that's exactly the thing I've been cleaning up today.

[17:52] <jnthn> So we can cleanly have additional native concepts like "this native int lexical here"

[17:52] <PerlJam> (or at least some sort of decoration on container types)

[17:53] <TimToady> thing is, we have varying abstraction levels of "container", some of which can support dynamic typing, and some of which can't

[17:53] <TimToady> natives generally can't

[17:53] <jnthn> To me "native concept" feels like REPR level things, where there's no way you should ever be going and calling back into code.

[17:53] <TimToady> so any typing information has to ride either with the container/pointer or with the static type system

[17:54] <jnthn> But it seems that we need things to be hookable (run this FETCH/STORE) in some cases too.

[17:54] <pmichaud> yes, in that sense Scalar is like int, num, str, etc.

[17:54] <pmichaud> so perhaps it should be "scalar" with a lowercase 's'

[17:55] <pmichaud> in that sense, 'scalar' acts like a native.

[17:56] <TimToady> to me, the 'scalar' is the actual pointer, while the surrounding Scalar provides the extra type info needed to box/unbox

[17:56] <pmichaud> that's possible too.

[17:56] <TimToady> but that's just the C programmer coming out in me, I suspect :)

[17:56] <jnthn> That bitis kinda how we have it now, apart from we kep the extra type info a level of indirection away

[17:56] <PerlJam> TimToady: quick! put it back in before it escapes!

[17:56] <jnthn> *keep

[17:56] <TimToady> in C, the compiler itself would know the type of the 'scalar'

[17:57] <jnthn> Is that kinda what the Container Types bit of S02 is saying?

[17:57] <pmichaud> well, in REPR we know the 'type' of the 'scalar' as well, I think.

[17:58] *** cognominal left
[17:58] *** cognominal__ joined
[17:58] <pmichaud> TimToady: one quick question that will likely clear a lot of things up.... (apologies if you've answered this before)

[17:58] <pmichaud> what should happen with:

[17:58] <pmichaud>     sub foo(@a?) { say @a }    or   sub xyz(@b?) { say @b.defined }

[17:59] <pmichaud> where we invoke using foo() and/or xyz() ?

[17:59] <pmichaud> similarly:   my @a;   say @a.defined;

[18:00] *** dakkar left
[18:01] <TimToady> that probably depends on whether we decide that Nil is a true 'bottom' type, or we stick with (Array) for that purpose

[18:01] <TimToady> we haven't yet pushed Nil to be a true bottom

[18:01] <TimToady> (that is, make it validly the subtype of every other type)

[18:01] <pmichaud> can I assume from your answer that the result is undefined, though?

[18:01] <pmichaud> as opposed to being simply a defined-but-empty array?

[18:01] <TimToady> certainly .defined should return False

[18:01] <pmichaud> okay.

[18:01] <jnthn> What about .DEFINITE?

[18:02] <TimToady> I'd tend to think that should be false too

[18:02] <jnthn> (Which is really asking, is it that we really have a type object there?)

[18:02] <pmichaud> I think he's saying we have either a type object or Nil

[18:02] <pmichaud> but not an Array.

[18:03] <pmichaud> but not an Array:D

[18:03] <jnthn> Well, an Array type object :)

[18:03] <jnthn> I guess Nil is going to be something we always refer to by its type object...

[18:03] <pmichaud> Nil in rakudo is a singleton, yes :)

[18:03] <TimToady> r: say Nil ~~ Array

[18:03] <p6eval> rakudo b3b5f8: OUTPUT¬´False‚ê§¬ª

[18:03] <pmichaud> r:  say Nil.new

[18:03] <p6eval> rakudo b3b5f8: OUTPUT¬´Nil‚ê§¬ª

[18:03] <TimToady> that would be true if Nil were truly a bottom type

[18:04] <PerlJam> Given pmichaud's subs above, foo(Nil) and xyz(Nil)  would be the same as foo() and xyz(), correct?

[18:04] <pmichaud> jnthn: anyway, I think TimToday's answer is indicative that we have to change the way we handle Array declarations

[18:04] <TimToady> at the moment we don't ever bind Nil though, by spec, but say that it sets to default (Array) in this case

[18:05] <jnthn> pmichaud: Yes, seems so.

[18:06] <TimToady> yes, by current spec binding Nil is supposed to be the same as omitting the argument entirely

[18:06] *** daxim left
[18:06] <moritz> woah, that means we can use it for missing arguments in currying

[18:06] <jnthn> TimToady: um, so you could call an arity-2 thing as foo($a, Nil, $b) ?

[18:06] <TimToady> yes, that is part of the intent

[18:07] <TimToady> jnthn: that is not the intent :)

[18:07] <jnthn> oh, phew

[18:07] <arnsholt> jnthn: How do you handle the foo(|@a) thing in NQP/JVM?

[18:08] <jnthn> arnsholt: By pulling the things out of the array using the REPR API when I need to flatten.

[18:09] <TimToady> (also, I think an implication of what I'm thinking is that the only way to pass a Nil in as an argument is to bind it to \foo, that is, do no binding work)

[18:09] <jnthn> arnsholt: May be worth seeing how Parrot handles such things; it may be enough to throw "does array does hash" onto the SixModelObject PMC

[18:09] <arnsholt> Good point

[18:10] <pmichaud> jnthn: okay, so perhaps "my @a;"  causes @a to be bound to a Proxy of some sort.

[18:10] <pmichaud> which then causes the STORE method to come into play

[18:10] <TimToady> it needs to be able to spring into existence in a whence-like way,yes

[18:11] <jnthn> Does this have semantics along the lines of, a fetch is always a cheap pointer follow, but a store implies a method call?

[18:12] <jnthn> I guess it means that Array isn't the thing with the STORE method any more, in that case.

[18:12] <pmichaud> well, it may still be

[18:12] <pmichaud> perhaps in that sense Proxy is more like a role than an object

[18:12] <pmichaud> it's a container that says "if you STORE to me, do it via method"

[18:12] *** cognominal__ left
[18:13] <pmichaud> I suppose we can move STORE out of Array, but we'd need to do the same for Hash too

[18:13] <pmichaud> and List

[18:13] <pmichaud> and Parcel

[18:14] * TimToady has to run some errands, alas...hope you figger it all out while I'm gone... :)

[18:14] <TimToady> afk &

[18:14] <jnthn> I guess I'm trying to work out if we have lexpad -> container -> Array type object, and the initial STORE replaces the type object with a real array

[18:14] <jnthn> Is that what you were thinking?

[18:14] <pmichaud> it might be an initial $!whence

[18:15] <pmichaud> which is then what the STORE gets invoked on

[18:15] <pmichaud> that's kinda what happens with array elements now

[18:15] <pmichaud> except the STORE is native instead of a method

[18:16] <jnthn> It's native and then has to invoke the $!whence

[18:16] <jnthn> Which is icky

[18:16] <pmichaud> well, it's a separation of vivification and STORE

[18:17] *** cognominal joined
[18:18] <jnthn> Hm, yes. They are different things

[18:19] <FROGGS> TimToady: is there a way to build a ./viv script that shows the STD_P5 parse tree?

[18:20] <PerlJam> jnthn: for natives, could the $!whence be invoked at compile time?

[18:23] <moritz> FROGGS: use viv, and start the input with 'use v5;' ?

[18:25] *** Chillance joined
[18:25] <moritz> though I guess that viv just calls a $someGrammar.parse method at some point

[18:25] <moritz> and if you replace that with the p5 grammar, you're done too

[18:27] <moritz> FROGGS: replacing STD->parsefile with STD5->parsefile (and loading it first, of course) you get you going

[18:29] *** cognominal left
[18:29] <FROGGS> moritz: thanks!

[18:34] *** SunilJoshi left
[18:34] *** japhb_ joined
[18:37] *** cognominal joined
[18:38] *** wk joined
[18:42] *** cognominal left
[18:47] *** cognominal joined
[18:53] <pmichaud> errands... bbl with more container discusion later

[18:58] *** fhelmberger left
[19:10] *** stevan_ joined
[19:11] *** cognominal left
[19:11] *** Gruber joined
[19:19] *** cognominal joined
[19:25] *** cognominal left
[19:33] *** kivutar joined
[19:33] *** cognominal joined
[19:35] *** jferrero joined
[19:35] <dvj> topic

[19:44] *** LlamaRider joined
[19:50] <FROGGS> jnthn: is there a trick to localte things like this? Method 'ast' not found for invocant of class 'NQPMu'

[19:51] <FROGGS> hmmm, can I add a fallback to NQPMu?

[19:52] <jnthn> FROGGS: Normally, the stack trace tells you

[19:52] <FROGGS> I have none

[19:53] <jnthn> Huh?

[19:53] <jnthn> That error would typically occur inside the actions, though?

[19:54] <FROGGS> right

[19:54] <FROGGS> I get that for: use v5; 1

[19:54] <FROGGS> I've skimmed through all methods which are in use for it but can't see an error

[19:55] <FROGGS> jnthn:  this happens within P5Actions btw

[19:55] <FROGGS> which is a modified copy of Perl6::Actions

[19:56] <jnthn> Can always try --trace=4

[19:56] <jnthn> Which tells you all the things that get invoked

[19:56] <FROGGS> ohh nice

[19:57] <jnthn> may be a lot of output

[19:57] <FROGGS> hmmm, I get output for 'use v5;' but not for 'use v5; 1'

[19:59] <timotimo> did you try --ll-exception?

[19:59] <timotimo> it usually gives me stacktraces

[20:00] <FROGGS> timotimo: I'll try in a bit (recompiling)

[20:02] *** zby_home_ joined
[20:05] <FROGGS> Method 'ast' not found for invocant of class 'NQPMu'

[20:05] <FROGGS> current instr.: 'integer' pc 22479 (src/stage2/gen/NQPHLL.pir:8433) (src/stage2/gen/NQPHLL.pm:742)

[20:05] <FROGGS> timotimo++

[20:05] <timotimo> you're welcome :)

[20:05] <FROGGS> why do I get stacktraces all the time but not this time?

[20:06] <PerlJam> FROGGS: the bug you're twiddling clobbered the stack?  :)

[20:06] <timotimo> good question

[20:07] <FROGGS> PerlJam: I added about 6k lines of code, no idea what effects this has :o)

[20:08] *** spider-mario joined
[20:12] *** guest0 joined
[20:17] *** guest0 left
[20:22] *** kivutar left
[20:24] *** cognominal left
[20:29] *** cognominal joined
[20:30] *** kaare_ left
[20:41] *** uasi left
[20:44] *** rindolf left
[20:44] *** kurahaupo joined
[20:47] <hoelzro> NQP fork update!

[20:47] <hoelzro> I think this should do it; if this set of changes looks good, I'll push to perl6/nqp

[20:55] *** cognominal left
[20:55] <hoelzro> also, new improvements to the pygments lexer!

[20:55] <hoelzro> \o/

[21:01] *** cognominal joined
[21:05] *** zby_home_ left
[21:06] *** cognominal left
[21:11] <FROGGS> hoelzro++

[21:12] <FROGGS> so, I can expect to have Perl 6 highlighting on github soon?

[21:12] *** cognominal joined
[21:13] <hoelzro> well, I think I have two issues left before I push it upstream

[21:13] <hoelzro> token something(@params) doesn't work

[21:13] <hoelzro> and language detection

[21:13] <hoelzro> hopefully the pygments folk accept my changes =)

[21:18] *** aindilis joined
[21:22] *** bruges left
[21:23] *** spider-mario left
[21:24] *** bruges joined
[21:33] *** SmokeMachine left
[21:36] *** cognominal left
[21:41] *** domidumont left
[21:42] *** cognominal joined
[21:54] *** LlamaRider left
[22:05] *** xilo left
[22:09] <dalek> features: 06e7d10 | (Tobias Leich)++ | features.json:

[22:09] <dalek> features: array interpolation is supported too

[22:09] <dalek> features: review: https://github.com/perl6/features/commit/06e7d10e28

[22:11] <hoelzro> does multi dispatch of private methods count as a feature?

[22:11] <dalek> rakudo/nom: e0ce08f | (Tobias Leich)++ | docs/ROADMAP:

[22:11] <dalek> rakudo/nom: array interpolation is supported now

[22:11] <dalek> rakudo/nom: 

[22:11] <dalek> rakudo/nom: Even if there are issues like that we're using eval.

[22:11] <dalek> rakudo/nom: See http://irclog.perlgeek.de/perl6/2013-03-11#i_6574722

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e0ce08f48e

[22:12] *** colomon joined
[22:13] <FROGGS>  hoelzro: well, multi dispatch is listed, no?

[22:13] <hoelzro> it is

[22:13] <hoelzro> I didn't know if private dispatch is considered separately

[22:14] <FROGGS> I can't imagine a reason to do that

[22:14] *** PacoAir_ joined
[22:15] <hoelzro> ok

[22:16] *** PacoAir left
[22:16] *** PacoAir_ is now known as PacoAir

[22:16] <jnthn> The pair don't currently work together

[22:16] *** xilo joined
[22:20] *** cognominal left
[22:26] <dalek> nqp: 5400ed8 | jnthn++ | / (2 files):

[22:26] <dalek> nqp: Store REPR data offset in STables data also.

[22:26] <dalek> nqp: 

[22:26] <dalek> nqp: This makes it much easier for anything that wants to try and work out

[22:26] <dalek> nqp: sizing/layout before deserializing objects.

[22:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5400ed89d3

[22:29] *** cognominal joined
[22:29] *** bluescreen10 left
[22:45] *** census left
[22:47] *** PacoAir left
[23:11] <pmichaud> release note item:  LWP::Simple fails with rakudo master/parrot master

[23:13] *** benabik left
[23:15] <pmichaud> https://github.com/cosimo/perl6-lwp-simple/issues/20

[23:31] *** LlamaRider joined
[23:37] *** FROGGS left
[23:41] *** Chillance left
[23:45] <jnthn> 'night, #perl6

[23:47] <colomon> \o

[23:49] *** bbkr joined
