[00:00] *** lue joined
[00:01] *** __rnddim__ joined
[00:02] *** fgomez left
[00:03] *** __rnddim__ left
[00:04] *** __rnddim__ joined
[00:04] *** gdey left
[00:12] *** cognominal left
[00:16] *** fgomez joined
[00:20] *** cognominal joined
[00:25] *** Targen joined
[00:46] *** Gwyxx left
[00:54] *** gdey joined
[00:55] *** anuby joined
[01:11] *** cognominal left
[01:17] *** cognominal joined
[01:18] *** hypolin joined
[01:32] *** gdey left
[01:51] *** clkao left
[01:56] *** clkao joined
[02:00] *** fgomez left
[02:08] *** xenoterracide left
[02:10] *** swarley-freenode is now known as swarley

[02:10] *** xenoterracide joined
[02:12] *** fgomez joined
[02:17] *** hypolin left
[02:22] *** lustlife joined
[02:24] *** skids left
[02:40] *** japhb_ left
[02:45] *** census left
[02:50] *** bruges joined
[02:54] <colomon> tadzik, et al: current panda builds with rakudo c2910e23bc66610d7a91036da67b365eb4cb1c25.  It does not build with the current rakudo.  I think it did not work with rakudo token string {

[02:54] <colomon>     \" ~ \" ( <str> | \\ <str_escape> )*

[02:54] <colomon> }

[02:54] *** bruges_ left
[02:54] <colomon> boo

[02:54] <colomon> token string {

[02:54] <colomon>     \" ~ \" ( <str> | \\ <str_escape> )*

[02:54] <colomon> }

[02:54] <colomon> is where it is failing

[02:55] <colomon> continuing my thought before my cut-n-paste error there, I think it did not work with rakudo c2910e23bc66610d7a91036da67b365eb4cb1c25 and the current rakudo's parrot; however, that might have been a weird artifact of my build process.

[02:56] <colomon> I'm guessing this may be because of a recent change to NQP?  It seems like there have been a ton of them recently...

[02:58] *** dayangkun left
[03:03] <colomon> trying to bisect now, but since it needs to do a full rakudo rebuild from scratch every time, this will be pretty slow

[03:15] *** orafu left
[03:15] *** orafu joined
[03:18] *** kst left
[03:18] *** kst` is now known as kst

[03:24] *** dayangkun joined
[03:36] *** Gwyxx joined
[03:49] *** hypolin joined
[03:57] <colomon> actually completely failing to even get panda started on just the first step of the bisect, without any hint that it's the same as the bug.  sigh.

[03:57] <colomon> bedtime, I think.

[04:01] <sorear> night colomon

[04:03] *** Harzilein left
[04:11] *** SamuraiJack joined
[04:32] *** benabik joined
[04:35] *** SamuraiJack left
[04:38] *** uvtc joined
[04:41] *** adu joined
[04:46] <uvtc> phenny: tell moritz Nice job getting a draft of containers.pod written. Makes it clear that assignment is about filling containers, whereas binding is about connecting a variable to a container or value. Might be instructive to add an explanation of what `my @a := <1 2 3>` is/does (and how it's different from `my @a = <1 2 3>`). moritz++

[04:46] <phenny> uvtc: I'll pass that on when moritz is around.

[04:47] *** SamuraiJack joined
[04:47] *** __rnddim__ left
[04:53] <adu> hi all

[04:54] <adu> perl6: say <:Letter> ~~ "a"

[04:54] <p6eval> rakudo ce1827, niecza v24-28-g2a7e0fd: OUTPUT«False␤»

[04:54] <adu> perl6: say "a" ~~ <:Letter>

[04:54] <p6eval> rakudo ce1827, niecza v24-28-g2a7e0fd: OUTPUT«False␤»

[04:55] <lue> perl6: say "a" ~~ /<:Letter>/

[04:55] <p6eval> rakudo ce1827, niecza v24-28-g2a7e0fd: OUTPUT«｢a｣␤␤»

[04:55] <adu> lue: thanks

[04:55] <lue> np

[04:56] <adu> i have occasional bouts of stupidity

[04:57] <dalek> doc: ba2960a | (John Gabriele)++ | lib/containers.pod:

[04:57] <dalek> doc: minor grammar/punctuation tweaks

[04:57] <dalek> doc: review: https://github.com/perl6/doc/commit/ba2960a26d

[04:57] *** preflex_ joined
[04:57] *** preflex left
[04:57] *** uvtc left
[04:58] *** preflex_ is now known as preflex

[04:59] *** yakshavr joined
[05:00] *** rindolf joined
[05:10] *** adu_ joined
[05:12] *** adu left
[05:12] *** adu_ is now known as adu

[05:15] *** quester joined
[05:28] *** anuby left
[05:28] *** anuby joined
[05:36] *** kaleem joined
[05:36] *** crab2313 joined
[05:43] *** immortal left
[05:43] *** erkan joined
[05:43] *** erkan left
[05:43] *** erkan joined
[05:51] *** SamuraiJack left
[05:52] *** simcop2387 left
[05:53] *** adu_ joined
[05:54] *** simcop2387 joined
[05:55] *** adu left
[06:06] *** wk left
[06:15] *** lue left
[06:32] *** denisboyun joined
[06:35] *** denisboyun left
[06:36] *** denisboyun joined
[06:42] *** denisboyun left
[06:45] *** denisboyun joined
[06:46] *** salv01 left
[06:47] *** xinming left
[06:48] *** xinming joined
[06:49] *** adu_ left
[06:52] *** salv0 joined
[06:56] <dalek> nqp: e7b8577 | (Arne Skjærholt)++ | src/6model/reprs/VMArray.c:

[06:56] <dalek> nqp: Fix brainos spotted by kboga++.

[06:56] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e7b857752d

[06:56] *** cognominal left
[06:58] *** denisboyun left
[07:00] <arnsholt> Does kboga usually hang around here any?

[07:02] *** Targen left
[07:02] *** avi_ left
[07:03] <diakopter> arnsholt: http://irclog.perlgeek.de/search.pl?channel=perl6&nick=kboga&q=

[07:04] *** cognominal joined
[07:05] <arnsholt> Oh, the clogs. Good idea =)

[07:13] *** rhinux joined
[07:17] *** FROGGS joined
[07:18] *** dayangkun left
[07:30] *** dayangkun joined
[07:37] *** SamuraiJack joined
[07:38] *** crab2313 left
[07:47] *** cognominal left
[07:53] *** crab2313 joined
[07:57] *** cognominal joined
[08:09] *** quester left
[08:11] <FROGGS> star: use JSON::Tiny; say from-json( '{ "a" : 1 }' );

[08:11] <p6eval> star 2013.02: OUTPUT«("a" => 1).hash␤»

[08:13] <FROGGS> locally I get:

[08:13] <FROGGS> Unable to parse expression in string; couldn't find final \"

[08:13] <FROGGS>   in any FAILGOAL at src/stage2/QRegex.nqp:1094

[08:13] * FROGGS investigates

[08:14] *** fhelmberger joined
[08:15] <FROGGS> r: say "abc" ~~ /<-["\\\t\n]>+/

[08:15] <p6eval> rakudo ce1827: OUTPUT«#<failed match>␤»

[08:15] <FROGGS> r: say "abc" ~~ /<-["\\]>+/

[08:15] <p6eval> rakudo ce1827: OUTPUT«｢abc｣␤␤»

[08:15] <FROGGS> r: say "abc" ~~ /<-["\\\t]>+/

[08:15] <p6eval> rakudo ce1827: OUTPUT«#<failed match>␤»

[08:15] <FROGGS> ohh, that was quick

[08:15] <FROGGS> (and my fault I guess)

[08:16] <FROGGS> r: say "abc" ~~ /<-[\t]>+/

[08:16] <p6eval> rakudo ce1827: OUTPUT«(timeout)»

[08:16] <FROGGS> r: say "abc" ~~ /<-[\n]>+/

[08:16] <p6eval> rakudo ce1827: OUTPUT«｢abc｣␤␤»

[08:17] <FROGGS> nqp: say("abc" ~~ /<-[\t]>+/)

[08:17] <TimToady> n: say "abc" ~~ /<-["\\\t\n]>+/

[08:17] <p6eval> nqp: OUTPUT«(timeout)»

[08:17] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«｢abc｣␤␤»

[08:17] <TimToady> niecza doesn't have a problem with it

[08:17] <FROGGS> moritz: I've broken your JSON::Tiny

[08:18] <FROGGS> I patched nqp recently to handle stuff like <[\w]-[\D]>+ right

[08:18] <diakopter> o_O

[08:18] <TimToady> nr: say "abc" ~~ /<-[ " \\ \t \n ]>+/

[08:18] <FROGGS> I guess it is something about -[\t]'s zerowidth

[08:18] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«｢abc｣␤␤»

[08:18] <p6eval> ..rakudo ce1827: OUTPUT«#<failed match>␤»

[08:19] <TimToady> why would that have a zerowidth?

[08:19] <TimToady> + and - never have zerowidth, only ! and ?

[08:19] <diakopter> nqp-jvm: say("abc" ~~ /<-[\t]>+/)

[08:20] <p6eval> nqp-jvm: OUTPUT«(timeout)»

[08:20] <FROGGS> TimToady: that explains it

[08:22] <moritz> FROGGS: then please unbreak it :-)

[08:22] <phenny> moritz: 04:46Z <uvtc> tell moritz Nice job getting a draft of containers.pod written. Makes it clear that assignment is about filling containers, whereas binding is about connecting a variable to a container or value. Might be instructive to add an explanation of what `my @a := <1 2 3>` is/does (and how it's different from `my @a = <1 2 3>`). moritz++

[08:22] <FROGGS> moritz: already doing

[08:22] <grondilu> how would you go about a function that displays a number with its decimals in slightly vanishing shades of gray?  I mean, the second decimal being lighter than the second, and so on? 

[08:23] <grondilu> .oO(maybe that's too much to ask and not Perl6 specific enough) 

[08:23] *** Ovidius left
[08:24] <moritz> grondilu: which output medium?

[08:24] <grondilu> X terminal

[08:24] * grondilu sucks at using escape sequences

[08:25] <moritz> use Term::ANSIColor;

[08:25] <grondilu> oh, good idea.

[08:26] <TimToady> you aren't going to get shades of gray from that though

[08:26] *** m0li left
[08:26] <TimToady> at best you get bright and dim of each color

[08:30] *** ObseLeTe joined
[08:36] <sorear> on many terminals you can get 4 shades of gray with SGR sequences

[08:39] *** wk joined
[08:40] *** hoelzro|away is now known as hoelzro

[08:43] *** salv0 left
[08:43] *** salv0 joined
[08:48] *** kivutar joined
[09:06] *** woosley joined
[09:07] *** sqirrel joined
[09:11] *** kaleem left
[09:12] *** ozmq joined
[09:12] *** kivutar left
[09:12] *** kivutar joined
[09:17] *** am0c left
[09:18] *** Moukeddar joined
[09:19] <masak> good morning, #perl6

[09:20] <tadzik> hello masak

[09:20] <Moukeddar> good morning all \m/

[09:21] <Moukeddar> or is it \o/ ?  both are good i guess

[09:23] <masak> \m/ work well with Moukeddar (or masak), I guess ;)

[09:23] <masak> maybe it's someone cheering with very long hair, that hangs over their eyes.

[09:24] <Moukeddar> \n/ , this would be it

[09:24] <Moukeddar> i believe \m/ is related to rock

[09:24] <Moukeddar> how are you doing btw ?

[09:24] <dalek> nqp: 2694596 | (Tobias Leich)++ | src/QRegex/P (2 files):

[09:24] <dalek> nqp: remove zerowidth for things which have no zero width

[09:24] <dalek> nqp: 

[09:24] <dalek> nqp: I added this previously because I though that negations

[09:24] <dalek> nqp: automagically should force zerowidth. This patch unbreaks

[09:24] <dalek> nqp: JSON::Tiny.

[09:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2694596344

[09:24] <masak> Moukeddar: me? fine. busy.

[09:25] <masak> have to use two clones just to do dayjob right now.

[09:25] <dalek> rakudo/nom: c315c8b | (Tobias Leich)++ | tools/build/NQP_REVISION:

[09:25] <dalek> rakudo/nom: bump nqp revision, this unbreaks JSON::Tiny

[09:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c315c8b839

[09:25] <tadzik> yay

[09:25] <Moukeddar> aw wouldn't that be slaving ? although, good to hear from you again :)

[09:25] <tadzik> FROGGS++

[09:26] <FROGGS> FROGGS--

[09:26] <FROGGS> breaking and then unbreaking things is not that good :o)

[09:27] <masak> it's not slavery. we're on a rolling schedule of chairmanship.

[09:28] <masak> FROGGS++ # progress in the long run

[09:28] <FROGGS> ohh thanks

[09:28] <masak> this is what eventual consistency is all about. "we'll get there"

[09:28] *** cognominal left
[09:30] <Moukeddar> hope all goes well, right now i'm passing my internship :)

[09:31] <dalek> roast: 7fba797 | (Tobias Leich)++ | S05-metasyntax/charset.t:

[09:31] <dalek> roast: add another charset subtraction test

[09:31] <dalek> roast: review: https://github.com/perl6/roast/commit/7fba797f6d

[09:32] <TimToady> http://rosettacode.org/wiki/Maze_solving#Perl_6  <-- why I am not in bed yet

[09:32] <TimToady> feel free to improve

[09:33] * TimToady improves by going to bed...

[09:33] *** dakkar joined
[09:34] <FROGGS> TimToady: that's not A*, right?

[09:35] *** cognominal joined
[09:37] *** simcop2387 left
[09:37] *** daxim joined
[09:39] *** simcop2387 joined
[09:40] <masak> FROGGS: no, it looks more like "keep your right hand on the wall" with backtracking.

[09:41] <masak> I guess A* is possible (though I'm still not used to thinking in terms of it), at least if you know where the exit is located.

[09:41] <masak> nowadays I basically see A* as an optimization of breadth-first. breadth-first is a bit tricky/wasteful to do if you're a mouse in a maze ;)

[09:43] <FROGGS> okay ya, if you dont know where the exit is located that you can't use A*

[09:43] *** kivutar left
[09:45] <masak> TimToady: what's with all the magic numbers in @maze? :)

[09:46] <Ulti> http://upload.wikimedia.org/wikipedia/commons/c/cf/MAZE.png  wat

[09:46] <FROGGS> Ulti: wow, nice desktop wallpaper :o)

[09:47] <masak> ...if you like headaches.

[09:48] * masak fondly remembers coding recursive maze solvers in Turbo BASIC, and blowing the stack in the process

[09:48] <Moukeddar> Migraine guaranteed 

[09:48] <Ulti> now I know what to hand to bored children

[09:48] <FROGGS> hehe

[09:48] <tadzik> a piece of paper with "see the other side" on both sides? :)

[09:48] <Moukeddar> that'll blow the poor kid's stack too 

[09:49] <sorear> I prefer BFS for maze solvers because it uses O(sqrt n) memory

[09:50] <Ulti> tadzik thats a test for science aptitude to see if they cobble together a microscope to check the other four sides right?

[09:50] <masak> sorear: I *prefer* solving a maze on a quantum computer, because it gives a quadratic speedup :P

[09:51] <Moukeddar> hehe, when they're available 

[09:51] <masak> oh, they exist.

[09:51] <masak> they just don't do very many qubits yet.

[09:53] * masak recommends http://www.cs.berkeley.edu/~vazirani/algorithms.html for anyone who's interested

[09:54] <sorear> oh hey umesh vazirani I know that name

[09:54] <masak> Aaronson's former mentor.

[09:54] <Moukeddar> they do ?

[09:54] <Moukeddar> how their speed is measured ?

[09:54] <Moukeddar> *is their speed

[09:55] <sorear> yes.

[09:55] <Ulti> http://arxiv.org/abs/quant-ph/0205095   need quite a lot of qbits to do anything useful :)

[09:55] <sorear> masak: given vazirani's background I'm shocked that there's only one quantum chapter

[09:56] <masak> I dunno. I think some pretty cool stuff can be made with 16 qubits.

[09:56] <masak> sorear: yeah. but it's a good chapter :)

[09:56] <sorear> The fundamental problem with quantum computing is, in an acronym, TEMPEST.

[09:56] <masak> do expand.

[09:56] <sorear> oh, apparently it's not an acronym

[09:56] <Moukeddar> i believe this is all lab-grade installments , is it practical ?

[09:57] <sorear> masak: CIA codename for technologies which study the internal state of a computer via leaked electromagnetic radiation.

[09:57] <masak> Moukeddar: it's on the Babbage stage, clearly. but there's nothing in principle to stand in the way of its eventual practicality.

[09:57] <sorear> *enemy computer

[09:57] <Moukeddar> So, Singularity is near ?

[09:58] <sorear> Moukeddar: I don't see any reason why AGI and QC should be deeply connected

[09:58] <masak> sorear: so you're saying, it's intractably difficult to keep states un-collapsed long enough?

[09:59] <sorear> masak: yes, because the expanding shell of radiation coming off your computer contains an indelible record of the history of every calculation it does

[09:59] <masak> hehe, "Tiny ElectroMagnetic Particles Emitting Secret Things"

[09:59] <sorear> quantum computing requires interference between multiple paths to the same final world-state

[09:59] <Ulti> Moukeddar http://www.nicolelislab.net/?p=369

[10:00] <sorear> but if the final world-state contains a record of the computation history, there can be no interference.

[10:00] * masak quietly wonders if QC could generate a uniformly random balanced-brackets string in O(n) time

[10:01] *** hypolin left
[10:01] <masak> sorear: I bet you're aware of Aaronson's bet?

[10:01] <sorear> the CIA is happy with a computer that has "very low" emissions, but for QC you need *zero*.

[10:01] <sorear> masak: Yes.

[10:01] <masak> sorear: I'm also pretty sure you know about the results around error-correction.

[10:02] <sorear> Yes.

[10:03] <masak> so -- trying to construct a consistent world view around your statements -- you believe error-correction is not enough to make QC feasible, but you're too nice to take Scott's money.

[10:03] *** simcop2387 left
[10:04] <sorear> masak: Error correction is not enough, you also need working qubits.  I don't think Scott would disagree with this :)

[10:04] *** simcop2387 joined
[10:05] <sorear> You need qubits that have a 97% chance of not radiating anything.

[10:05] <Ulti> people just need to get into bio computing then classical computing becomes cheap and powerful

[10:05] <sorear> Unless the threshold was improved again in the last few months.

[10:06] <masak> I just can't help picturing a Babbage-age detractor saying "you need transistors of impossible accuracy!"

[10:07] <sorear> masak: The accuracy bar is high, but I'm sure it will be reached within my lifetime.

[10:08] <sorear> it's also going to be very interesting to see the YEAR * QBITS -> COST function.

[10:09] <sorear> are we ever going to have handheld nanokelvin cryostats, or room temperature qbits?

[10:10] <masak> nodnod

[10:10] *** Moukeddar_ joined
[10:10] <masak> ok, so you're not a detractor, you're just saying "we ain't there yet".

[10:11] <sorear> right.

[10:12] <masak> then we are in violent agreement.

[10:12] <sorear> I'm also saying that it's going to be a _while_

[10:13] <Moukeddar_> sorry, the connection is breaking, i'm on a free wifi network, but the article is awesome, it's mind blowing, how long would it take to do that to the human brain

[10:13] <masak> that's OK. we're still doing useful QC research in the meantime ;)

[10:13] <sorear> we may have net energy production from fusion first.

[10:13] <Ulti> http://www.jbioleng.org/content/3/1/11 I'd rather see the fruition of this sort of computation in my life time, mostly because it solves robotics at the same time. You just put your computer in the body of an animal that already exists.

[10:14] *** Moukeddar left
[10:14] <sorear> Moukeddar: i'm sure it could be done today if there weren't huge safety issues

[10:14] *** Moukeddar_ left
[10:14] <sorear> the thing about rats is that if you kill them as part of an expirement, that's usually considered OK

[10:14] *** anuby left
[10:15] *** Moukeddar_ joined
[10:15] <sorear> Moukeddar: i'm sure it could be done today if there weren't huge safety issues

[10:15] <sorear> the thing about rats is that if you kill them as part of an expirement, that's usually considered OK

[10:15] <sorear> there's very little you can do to a human brain that won't cause it to fall apart in short order

[10:15] <Ulti> yeah if humans werent at all ethical there is an awful lot you could do with humans already

[10:15] <sorear> scar formation in brain tissue works very weirdly

[10:15] <Ulti> genetic engineering in human cells is easier than say plants

[10:16] <Ulti> there isnt a cell wall in the way and there are lots of viral vectors for human cells known

[10:16] <sorear> but if you do the experiments quickly you don't need to think about scarifcication

[10:16] <Ulti> sorear yeah also who is going to say yes to invasive surgery

[10:17] *** Moukeddar_ left
[10:17] <Ulti> maybe for someone in a coma or something you can imagine some use case

[10:17] *** Moukeddar_ joined
[10:18] <Ulti> they've already done single electrode interfaces for people who can't move their bodies

[10:18] <sorear> Ulti: can't do anything with people in comas, informed consent blah blah blah

[10:18] <Ulti> dunno you could sign a piece of paper /before/ the coma

[10:18] <sorear> but there are plenty of people who do "blink once for yes, twice for no"

[10:18] <Ulti> if I can give my organs away....

[10:18] *** Moukeddar__ joined
[10:19] * Ulti wonders how long until NQP is ported to E. coli VM

[10:19] <Ulti> shouldn't be too hard... >:3

[10:19] *** ObseLeTe left
[10:20] <sorear> I think the main categories are 1. people with severe disabilities investing personally in bionic eye, etc research 2. self-experimentation

[10:20] <masak> I thought we all agreed not to say "bionic" :P

[10:21] <Ulti> yeah but that also means research is always focussed on replacing broken parts rather than doing something simple to improve working bits of your body

[10:21] <Ulti> like why not have an implant in your lens so you can do wacky things like have telephoto zoom

[10:21] <sorear> I wonder if it would be possible to modify neurons via gene therapy to add an optical interface

[10:22] <Moukeddar__> basic maintenance 

[10:22] <Ulti> even if you botch that artificial lens' are actually not as hard to fix than say screwing up your retina

[10:22] *** Moukeddar_ left
[10:22] <sorear> hack the voltage-gated sodium channel to be florescent

[10:22] <masak> six million rupee man: http://www.youtube.com/watch?v=dzcC4VwFm3A

[10:22] <Moukeddar__> wouldn't that torch your brain ?

[10:23] <sorear> I know they did some very cool stuff recently with C.elegans mutants where all of the neurons are photosensitive like rods, and they can use a laser to modify the worms' behavior

[10:24] <sorear> up to "lay eggs on command"

[10:24] <Moukeddar__> wow, if this is public i wonder what's confidential !

[10:24] <masak> nematodes with frikkin' lazers on their neurons.

[10:25] <Ulti> Moukeddar__: they use your own tooth to reduce the amount of maintenance needed http://en.wikipedia.org/wiki/Osteo-odonto-keratoprosthesis

[10:25] *** neilb_ joined
[10:25] <Ulti> thats the thing artificial doesnt need to mean artifice like silicon and terminator esk read outs

[10:25] <Ulti> its not that hard to grow your tissue in a lab and do something with it

[10:26] <Moukeddar__> duct tape for humans :

[10:26] <Ulti> and with stem cell reprogramming you can even take skin and get out some neuronal tissue

[10:26] <sorear> that's just because neurons are modified skin cells

[10:26] <sorear> embryology is weird

[10:26] <Ulti> swab your cheak grow some culture, reprogram to neurones, put in some artificial neural circuits

[10:27] <Moukeddar__> embryo ?

[10:27] <sorear> ?

[10:27] <masak> ¿

[10:28] * Ulti wanders off to the office

[10:31] <sorear> what I think is going to happen in the next 10-20 years is that we're going to have viable neuron-level simulations of the rodent brain, and that is going to be a game-changer in too many ways to count

[10:32] <sorear> because for all the things you *can* do to mice, there are even more you can't

[10:32] <Moukeddar__> only for rats ?

[10:32] <sorear> I say mice because they have smaller brains

[10:36] *** labster left
[10:37] * sorear points at https://en.wikipedia.org/wiki/Protein_kinase_M%CE%B6 for an example of state of the art research in whole animals

[10:40] <masak> how do I go from a Date object to the last day in the same month?

[10:40] <masak> r: my $today = Date.today; say $today

[10:40] <p6eval> rakudo c315c8: OUTPUT«2013-03-06␤»

[10:41] <masak> r: my $today = Date.today; say $today.clone(:day( $today.days-in-month ))

[10:41] <p6eval> rakudo c315c8: OUTPUT«2013-03-31␤»

[10:41] <sorear> masak: I would go to the next month, then the first day of the same month, then the previous day

[10:41] <masak> this seems to work.

[10:41] *** rindolf left
[10:41] <sorear> actually it would work better to swap steps 1 and 2

[10:41] *** rindolf joined
[10:42] <masak> r: my $today = Date.today; say $today.clone(:day(1)).delta(:month(1)).delta(:day(-1))

[10:42] <p6eval> rakudo c315c8: OUTPUT«Not enough positional parameters passed; got 1 but expected 3␤  in method delta at src/gen/CORE.setting:11881␤  in block  at /tmp/Hslac8tQGM:1␤␤»

[10:42] <masak> oh!

[10:42] <sorear> so it's now quite clear that long-term memory is an active process: long-term memories can be erased by inhibiting a "refresh" enzyme

[10:42] <masak> r: my $today = Date.today; say $today.clone(:day(1)).delta(1, month).delta(-1, day)

[10:42] <p6eval> rakudo c315c8: OUTPUT«2013-03-31␤»

[10:42] <masak> \o/

[10:42] *** sqirrel left
[10:43] <sorear> but we still know pretty much nothing about how the memories are *encoded*

[10:43] <sorear> how does the mouse's brain go from PKM\zeta to "yellow things will shock me and I need to avoid them"?

[10:44] <FROGGS> nr: say "abc" ~~ /<-[ " \\ \t \n ]>+/

[10:44] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«｢abc｣␤␤»

[10:44] <p6eval> ..rakudo c315c8: OUTPUT«#<failed match>␤»

[10:45] <FROGGS> nr: say "abc" ~~ /<-["\\\t\n]>+/

[10:45] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«｢abc｣␤␤»

[10:45] <p6eval> ..rakudo c315c8: OUTPUT«#<failed match>␤»

[10:45] <FROGGS> why

[10:45] *** Moukeddar__ left
[10:46] <sorear> I'm going to blame miscompilation of some kind

[10:46] <FROGGS> damn, nqp revision

[10:46] *** pmurias joined
[10:47] * masak already loves the .delta method

[10:47] <masak> constant last-month = Date.today.delta(-1, month).month;

[10:47] <dalek> rakudo/nom: fec64aa | (Tobias Leich)++ | tools/build/NQP_REVISION:

[10:47] <dalek> rakudo/nom: bump NQP revision

[10:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fec64aa014

[10:47] <colomon> has anyone gotten panda to actually work?  I just built rakudo.... hurm

[10:47] <FROGGS> colomon: pull again

[10:48] <colomon> yes, saw the dalek message in the middle of typing that last message.

[10:48] <FROGGS> ya, sorry for that ó.ò

[10:48] <FROGGS> looks like I need to pull before getting the right nqp revision

[10:49] <dalek> rakudo-js: 5659fa7 | (Pawel Murias)++ | runtime (6 files):

[10:49] <dalek> rakudo-js: Move STables, Hash and the object model bootstrap into seperate modules.

[10:49] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/5659fa7c52

[10:50] *** rindolf left
[10:50] *** rindolf joined
[10:51] <masak> I submit this cute little helper program to you for review: https://gist.github.com/masak/5098506

[10:52] <colomon> FROGGS: do we have tests in roast for this issue?

[10:52] <masak> for two years now, I've re-implemented that one as a one-liner in Rakudo every new month when I needed it (for my work hour reports).

[10:52] <masak> now I finally wrote it down as a permanent solution.

[10:52] <masak> pretty satisfied with how it turned out ;)

[10:58] <pmurias> masak: the only possible change would be to use Date.new($year,$month,$first.day-in-month) instead of $first.clone( :day($first.days-in-month))

[11:04] *** crab2313 left
[11:04] *** rindolf left
[11:04] *** rindolf joined
[11:05] <FROGGS> colomon: we have since an hour or so

[11:06] <colomon> glad to hear it.

[11:07] *** pmurias left
[11:08] <masak> pmurias: good suggestion. I'll do that.

[11:10] *** rhinux left
[11:12] *** rindolf left
[11:12] *** rindolf joined
[11:12] <masak> pmurias: updated https://gist.github.com/masak/5098506 :)

[11:20] *** rindolf left
[11:20] <masak> (creating very small, local subs)++

[11:20] *** rindolf joined
[11:21] *** kaleem joined
[11:26] *** donaldh joined
[11:30] <FROGGS> nr: say "abc" ~~ /<-["\\\t\n]>+/ # \o/

[11:30] <p6eval> rakudo fec64a, niecza v24-28-g2a7e0fd: OUTPUT«｢abc｣␤␤»

[11:30] <masak> \o/

[11:31] *** woolfy joined
[11:33] *** rindolf left
[11:34] <masak> r: my $today = Date.today; say ($today ... *).first(*.month != $today.month).delta(-1, day)

[11:34] <p6eval> rakudo fec64a: OUTPUT«2013-03-31␤»

[11:34] *** rindolf joined
[11:34] <masak> heh. a bit wasteful, I guess ;)

[11:36] <sorear> r: say (Date.today, *.delta(1,day) ...^ { .day == 1 })[*-1]

[11:36] <p6eval> rakudo fec64a: OUTPUT«2013-03-31␤»

[11:36] <sorear> Why does $today ... * work?

[11:37] <sorear> I thought that was only for numbers.

[11:38] <sorear> Also why is the Gregorian calendar built in to a universal language?

[11:38] <sorear> r: say Date.new('2000-02-29')

[11:38] <p6eval> rakudo fec64a: OUTPUT«2000-02-29␤»

[11:38] <sorear> r: say Date.new('2000-02-28').succ

[11:38] <p6eval> rakudo fec64a: OUTPUT«2000-02-29␤»

[11:38] <sorear> r: say Date.new('1990-02-28').succ

[11:38] <p6eval> rakudo fec64a: OUTPUT«1990-03-01␤»

[11:38] <sorear> r: say Date.new('1900-02-28').succ

[11:38] <p6eval> rakudo fec64a: OUTPUT«1900-03-01␤»

[11:39] <sorear> r: say Date.new('1752-09-02').succ

[11:39] <p6eval> rakudo fec64a: OUTPUT«1752-09-03␤»

[11:41] <masak> as to "Why is the Gregorian calendar...", I don't see a contradiction there.

[11:41] <sorear> r: say Date.new('1300-02-28').succ

[11:41] <p6eval> rakudo fec64a: OUTPUT«1300-03-01␤»

[11:41] <masak> the Gregorian calendar is as near to an international date standard as we have.

[11:42] <masak> and yes, Date works with infix:<...> because (a) it's immutable, and (b) it has .succ

[11:43] <masak> r: say Date.today.delta(Date.today.days-in-month - Date.today.day, day)

[11:43] <p6eval> rakudo fec64a: OUTPUT«2013-03-31␤»

[11:43] <sorear> r is using gregorian dates for days before Pope Gregory IX was even born

[11:43] <sorear> XIII

[11:43] <masak> r: say .delta(.days-in-month - .day, day) given Date.today

[11:43] <p6eval> rakudo fec64a: OUTPUT«2013-03-31␤»

[11:44] <masak> sorear: sure. it's called "proleptic Gregorian calendar".

[11:44] <masak> it's a thing.

[11:52] <masak> I don't think "being universal" means "not being opinionated" or "not betting on widespread standards".

[11:52] <colomon> rn: grammar A { token a { "a"+ } }; say A.parse("ab");

[11:52] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«Unhandled exception: Unable to resolve method TOP in type A␤  at /home/p6eval/niecza/lib/CORE.setting line 2965 (Grammar.parse @ 5) ␤  at /tmp/LONVrZ8JHz line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4274 (ANON @ 3) ␤  at /home/p6ev…

[11:52] <p6eval> ..rakudo fec64a: OUTPUT«No such method 'TOP' for invocant of type 'A'␤  in method parse at src/gen/CORE.setting:10788␤  in block  at /tmp/p8ndci5_uh:1␤␤»

[11:52] <masak> Swatch Internet Time is a pretty neat standard with some distinct advantages. it's just that no-one uses it.

[11:53] <colomon> rn: grammar A { token a { "a"+ } }; say A.parse("ab", :rule<a>);

[11:53] <p6eval> rakudo fec64a: OUTPUT«｢a｣␤␤»

[11:53] <p6eval> ..niecza v24-28-g2a7e0fd: OUTPUT«#<failed match>␤»

[11:53] <colomon> is there any easy way to get Rakudo's parse to fail if the entire source string does not match?

[11:54] <sorear> add ^ and $

[11:54] <sorear> pretty sure rakudo's behavior is to spec; I just really don't like that part of the spec

[11:54] <colomon> sorear: but that involves changing the grammar, yes?

[11:54] <sorear> now that I'm not involved feel free to make things consistent

[11:55] *** ozmq left
[11:55] <colomon> sorear: the problem here is that I really need Niecza's behavior

[11:55] <sorear> n: grammar A { token a { "a"+ } }; say "ab" ~~ / ^ [ :lang(A) <TOP> ] $ /

[11:55] *** rindolf left
[11:55] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«Unhandled exception: Unable to resolve method TOP in type A␤  at /tmp/UqjypqYKzw line 1 (ANON @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2957 (Regex.ACCEPTS @ 10) ␤  at /tmp/UqjypqYKzw line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.sett…

[11:55] <sorear> n: grammar A { token a { "a"+ } }; say "ab" ~~ / ^ [ :lang(A) <a> ] $ /

[11:55] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«#<failed match>␤»

[11:55] <masak> I'm not so sure about "to spec". ISTR there being different opinions about whether ^ .. $ should be implied or not. and if so, which part should magically imply it.

[11:55] <sorear> r: grammar A { token a { "a"+ } }; say "ab" ~~ / ^ [ :lang(A) <a> ] $ /

[11:55] <p6eval> rakudo fec64a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex modifier :lang␤at /tmp/XGRXburMhI:1␤------> [32men a { "a"+ } }; say "ab" ~~ / ^ [ :lang[33m⏏[31m(A) <a> ] $ /[0m␤»

[11:55] <sorear> bah

[11:55] *** rindolf joined
[11:56] <sorear> sleep&

[11:56] <colomon> there's a parsefile method?!!

[11:57] <masak> yeah.

[11:57] <masak> for those who are too lazy to do .parse($file.slurp) ;)

[11:57] <masak> walk &

[11:57] * colomon is quite possibly too lazy to do .parse($file.slurp)

[11:58] * colomon is also not seeing anything in the spec which suggests to him that Rakudo's behavior is in the spec

[11:59] <sorear> well, one of the things I was going to do with niecza before I lost interest was add the capability to parse files *without* reading the whole thing

[12:00] <sorear> there's no reason in principle why GState has to point to a string, and not, say, a small portion of the data + a function for getting other parts on demand

[12:00] <sorear> could even be non-character data at that point

[12:01] <sorear> and we can discard segments in response to <cut>

[12:01] <colomon> which would also allow you to parse Cats, right?

[12:01] <sorear> would also be very important for <.moreinput>

[12:01] *** sqirrel joined
[12:01] <sorear> sleep for real&

[12:03] <colomon> night

[12:09] *** shinobicl joined
[12:22] *** SmokeMachine joined
[12:28] <colomon> rn: grammar A { token a { "a"+ } }; say A.parse("bab", :rule<a>);

[12:28] <p6eval> rakudo fec64a, niecza v24-28-g2a7e0fd: OUTPUT«#<failed match>␤»

[12:31] <FROGGS> rn: grammar A { token a { "a"+ } }; say "ab" ~~ A.parse("ab", :rule<a>);

[12:31] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«False␤»

[12:31] <p6eval> ..rakudo fec64a: OUTPUT«｢a｣␤␤»

[12:31] <FROGGS> rn: grammar A { token a { "a"+ } }; say "ab" ~~ ~A.parse("ab", :rule<a>);

[12:31] <p6eval> rakudo fec64a, niecza v24-28-g2a7e0fd: OUTPUT«False␤»

[12:38] *** sizz_ joined
[12:38] *** sizz left
[12:48] *** cognominal left
[12:54] *** rindolf left
[12:55] *** cognominal joined
[12:57] *** kaleem left
[13:01] *** kaleem joined
[13:04] <colomon> loliblogged: http://justrakudoit.wordpress.com/2013/03/06/philosophical-issues-with-rakudos-parse/

[13:08] *** cognominal left
[13:10] <FROGGS> colomon: what if you have a rule TOP { ^ <something> $ } ? will <[^$]> be ignored when doing all(0) ?, what if in TOP is only one of <[^$]> ?

[13:11] <FROGGS> I think the best would be to inherit from the grammar you can't/won't modify, and overwrite TOP

[13:11] <colomon> parse already does ^ by default on both Rakudo and Niecza.

[13:12] <colomon> and TOP is sort of the least interesting case

[13:13] *** SmokeMachine left
[13:14] *** SmokeMachine joined
[13:16] <masak> colomon++ # blag

[13:19] <masak> colomon: IMNSHO, .parse (and .parsefile) should auto-anchor the ends of the string.

[13:19] * colomon hopes that's Humble and not Honest.  ;)

[13:19] <masak> yeah :)

[13:19] <masak> colomon: what I *don't* know is whether it should be that way becuase (a) .parse contains some magic or (b) TOP contains some magic.

[13:19] <masak> and honestly/humbly, I can't say I see the repercussions of it.

[13:20] <masak> but hey, that's what the spectest suite is for, neh? :)

[13:20] <colomon> masak: the thing is, as often as not I'm not parsing against TOP

[13:20] <colomon> and I still always want auto-anchoring

[13:21] *** SamuraiJack left
[13:23] * colomon is not sure if he has ever used TOP, actually.

[13:24] *** jaldhar_ left
[13:27] <colomon> For instance, the ABC grammar has two rules that abc2ly parses against: tune_file (which would be TOP if I had TOP, I guess) and key.   It would also be very reasonable to parse against tune.

[13:28] <colomon> And for testing purposes I directly parse against many of the rules.

[13:30] <[Coke]> (maze.png) gah, my brain is looking for the hidden 3d picture.

[13:32] <dalek> rakudo/nom: 90bd93d | pmichaud++ | src/core/Rat.pm:

[13:32] <dalek> rakudo/nom: A better factoring of Rat.perl.

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90bd93d2d7

[13:36] <masak> colomon: then I suggest the default of .parse be "anchor both ends of string", no matter what :rule. and there should be a :substr (modulo name bikeshedding) option.

[13:37] <colomon> masak: That would be my preference as well.  (:partial maybe?)

[13:38] <masak> yeah, I was sniffing around in the vicinity of :part, too.

[13:38] <masak> :anywhere

[13:39] <masak> :unanchored

[13:41] *** simcop2387 left
[13:42] *** simcop2387 joined
[13:42] *** simcop2387 left
[13:42] *** simcop2387 joined
[13:44] <nwc10> stealth Pm at work

[13:46] <masak> is a "stealth Pm" like a hidden prime minister?

[13:48] *** ObseLeTe joined
[13:49] <pmichaud> I think that the default of .parse is currently "anchor one end of string", since that's what normally happens with a subrule match.

[13:49] <pmichaud> good morning, #perl6

[13:49] <pmichaud> oops, have to take $kid to $school.  bbiab

[13:52] * masak .oO( have to anchor one end of $kid to $school )

[13:53] <masak> with grammar G { regex TOP { 'ab' } }; who expects G.parse("abc") to fail, and who expects it to succeed?

[13:54] <masak> rn: grammar G { regex TOP { 'ab' } }; say so G.parse("abc")

[13:54] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«False␤»

[13:54] <p6eval> ..rakudo fec64a: OUTPUT«True␤»

[13:54] <masak> :)

[13:54] * masak , fwiw, is with Niecza

[13:55] <masak> *this*, gals and bots, is why we have implementation*s*, plural ;)

[13:55] <masak> it's healthy.

[13:55] <arnsholt> I'd agree with .parse requiring a match from 0 to the end of the input

[13:56] * masak submits rakuodbug

[13:57] *** kaleem left
[13:57] *** Liz joined
[13:57] *** kaleem joined
[13:57] *** Liz is now known as Guest8042

[14:00] *** Gwyxx left
[14:07] *** cognominal joined
[14:08] *** FROGGS left
[14:10] <pmichaud> leading-edge anchoring for .parse is typically controlled by the :c and :p options

[14:11] <pmichaud> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc');

[14:11] <p6eval> rakudo fec64a: OUTPUT«False␤»

[14:11] <pmichaud> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc', :c(0));

[14:11] <p6eval> rakudo fec64a: OUTPUT«False␤»

[14:11] <pmichaud> hmmmm

[14:11] <pmichaud> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc', :continue(0));

[14:11] <p6eval> rakudo fec64a: OUTPUT«too many named arguments: 1 passed, 0 used␤  in any !cursor_init at src/stage2/QRegex.nqp:560␤  in method parse at src/gen/CORE.setting:10788␤  in block  at /tmp/1p7EGkkfML:1␤␤»

[14:12] <colomon> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc', :c(1));

[14:12] <p6eval> rakudo 90bd93: OUTPUT«False␤»

[14:12] <pmichaud> maybe nyi?

[14:13] *** kaleem left
[14:13] <colomon> is it spec'd?

[14:13] *** kaleem joined
[14:13] <pmichaud> The :c and :p modifiers are spec'd, yes.

[14:14] <pmichaud> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc', :p(1));

[14:14] <p6eval> rakudo 90bd93: OUTPUT«False␤»

[14:14] <colomon> I mean for parse, particularly.

[14:14] <pmichaud> I *know* that worked at one time.

[14:14] <masak> I've never seen them in connection with .parse

[14:14] <pmichaud> r: grammar G { regex TOP { 'abc' } };  say so G.parse('bc', :pos(1));

[14:14] <p6eval> rakudo 90bd93: OUTPUT«too many named arguments: 1 passed, 0 used␤  in any !cursor_init at src/stage2/QRegex.nqp:560␤  in method parse at src/gen/CORE.setting:10786␤  in block  at /tmp/AHeA4xxQpZ:1␤␤»

[14:14] <masak> I know they're there for m//

[14:15] <pmichaud> r:  say 'abc' ~~ m:p(1)/bc/;

[14:15] <p6eval> rakudo 90bd93: OUTPUT«｢bc｣␤␤»

[14:15] <pmichaud> r:  say 'abc' ~~ m:p(0)/bc/;

[14:15] <p6eval> rakudo 90bd93: OUTPUT«#<failed match>␤»

[14:15] <pmichaud> r:  say 'abc' ~~ m:c(0)/bc/;

[14:15] <p6eval> rakudo 90bd93: OUTPUT«｢bc｣␤␤»

[14:15] <pmichaud>     method !cursor_init($orig, :$p = 0, :$c, :$shared) {

[14:15] <pmichaud> So, cursor_init knows about :p and :c

[14:16] <pmichaud> and .parse just calls cursor_init, passing along any options

[14:16] <pmichaud>             self."!cursor_init"($target, |%opt)."$rule"().MATCH;

[14:16] <colomon> there are no spectests for :c or :p on parse

[14:18] <pmichaud> anyway, I think .parse should continue to act like a subrule match; defaulting to "anchor at pos 0".  We could have an option that requires the end anchor also.  (more)

[14:20] <pmichaud> note that smartmatching against a regex/token/rule is supposed to automatically match both ends.

[14:22] <pmichaud> thus     $string ~~ regex { \d+ }     anchors while    $string ~~ /\d+/   does not anchor.

[14:22] <pmichaud> (nyi in rakudo, I think, but spec'd)

[14:22] *** PacoAir joined
[14:25] <colomon> pmichaud: I'm not trying to say that both forms are not useful.  Just that it feels like the wrong default has been chosen for parse and parsefile.

[14:25] *** Patterner left
[14:26] <pmichaud> r:  grammar G { regex TOP { 'abc' } };  say G.parse('bc')

[14:26] <colomon> imagine trying to explain to a user that we have MyGrammar.parsefile, but if you actually want to parse the entire file, you need to say $file.slurp ~~ MyGrammar.

[14:26] <p6eval> rakudo 90bd93: OUTPUT«#<failed match>␤»

[14:26] <pmichaud> .parse already anchors to the beginning by default

[14:27] <colomon> of course, MyGrammar.parsefile(:all) wouldn't be too bad

[14:27] *** Psyche^ joined
[14:27] *** Psyche^ is now known as Patterner

[14:28] <pmichaud> please, no.  since we already have :c and :p, I think we should have an orthogonal option for end-anchoring.

[14:28] *** Guest8042 is now known as lizmat

[14:28] <pmichaud> don't add another option to control anchor-at-the-beginning

[14:28] <pmichaud> r:  grammar G { regex TOP { 'abc' } };  say G.parse('abcdef')

[14:28] <p6eval> rakudo 90bd93: OUTPUT«｢abc｣␤␤»

[14:29] <colomon> not trying to control anchor-at-the-beginning, I'm worried about anchor-at-the-end

[14:30] <pmichaud> right, I understand that.  I'm just saying we already have anchor-at-beginning controls, don't muck with them too much.

[14:30] <pmichaud> the current .parse default most closely resembles what happens on a subrule match

[14:31] <colomon> as implemented in rakudo -- not as spec'd in any way that I can see

[14:31] <pmichaud> well, also as discussed on #perl6 over many years :)

[14:34] <masak> yeah. this comes up now and again.

[14:34] <masak> I remember thinking about it while walking the streets of Lisbon ;)

[14:34] <arnsholt> What does parse(:c) specify?

[14:35] <arnsholt> Looking at the code in NQP I'm not entirely sure

[14:35] <masak> continue from last match position?

[14:35] <masak> last :to position, even.

[14:35] <arnsholt> Ah, right

[14:36] <pmichaud> no

[14:36] <pmichaud> :c(3)  means "scan starting at position 3"

[14:37] <masak> and :p means?

[14:37] <pmichaud> :p(3) means "scan anchored at position 3"

[14:37] <pmichaud> er, "match anchored at position 3"

[14:37] *** skids joined
[14:37] <arnsholt> Right, right. That makes sense

[14:38] <masak> ah, so :c means "it's ok to match :from something later in the string", while :p means "try only this :from"?

[14:38] <pmichaud> r:  say 'abcdabcd' ~~ m:c(2)/a.*/

[14:38] <p6eval> rakudo 90bd93: OUTPUT«｢abcd｣␤␤»

[14:38] <pmichaud> r:  say 'abcdabcd' ~~ m:c(0)/a.*/

[14:38] <p6eval> rakudo 90bd93: OUTPUT«｢abcdabcd｣␤␤»

[14:38] <arnsholt> A similar option to force anchoring to the end of the string (and optionally some other offset would make sense, I guess) would make me just as happy as .parse always matching to end

[14:38] <pmichaud> r:  say 'abcdabcd' ~~ m:p(2)/a.*/

[14:38] <p6eval> rakudo 90bd93: OUTPUT«#<failed match>␤»

[14:38] <arnsholt> In fact, given :c/:p it makes more sense to add such an option than changing how .parse should work

[14:39] <pmichaud> S05:287

[14:39] <masak> clearly if :p forces anchoring of the beginning of the regex, the option that forces anchoring at the end should be... :q

[14:39] <masak> :)

[14:40] *** dayangkun left
[14:40] <pmichaud> note that :p forces anchoring at a position.

[14:40] <pmichaud> :p(0) forces anchoring at the beginning.

[14:40] <colomon> :q(0)  ?

[14:40] * hugme hugs colomon, good vi(m) user!

[14:40] <masak> hugme: hush, grownups are talking :)

[14:40] * colomon is sooooo not a good vi(m) user

[14:40] <skids> masak++ but why not :d ?

[14:41] <masak> skids: because the string flips, it doesn't rotate.

[14:41] <pmichaud> I suspect that :p would be the same as :p(1).

[14:41] <masak> pmichaud: I guess :q could take a position too, but I don't really see a strong use case.

[14:41] *** bluescreen10 joined
[14:41] <pmichaud> masak: yeah, I see that it's not entirely orthogonal there.

[14:42] <masak> "strangely consistent" often implies "not entirely orthogonal".

[14:42] *** lizmat left
[14:42] <pmichaud> in some sense I think that by trying to modify .parse we may be looking at the problem wrong.

[14:42] <skids> masak: I guess that depends on whether you read left to right or top to bottom :-)

[14:44] <masak> skids: if you read vertically, it's more like :℺ :)

[14:48] <colomon> rn: my @a; say @a.perl

[14:48] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«[].list␤»

[14:48] <p6eval> ..rakudo 90bd93: OUTPUT«Array.new()␤»

[14:48] <colomon> rn: my @a; sub blue(@a) { say @a.perl; }; blue(@a)

[14:48] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«[].list␤»

[14:48] <p6eval> ..rakudo 90bd93: OUTPUT«Array.new()␤»

[14:52] <colomon> rn: say $*EXECUTABLE_NAME

[14:52] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«/home/p6eval/niecza/run/Niecza.exe␤»

[14:52] <p6eval> ..rakudo 90bd93: OUTPUT«./nom-inst/bin/perl6␤»

[14:53] <pmichaud> okay, thinking about it a bit more....

[14:54] <pmichaud> to me, ".parse" implies "do what one would do for parsing", which would be to match as much as possible but don't fail outright if we don't reach the end of the string.

[14:54] <pmichaud> matching an entire string would be some form of .match

[14:55] <colomon> why?

[14:55] <pmichaud> because it fails to match exactly

[14:55] <colomon> or it fails to parse exactly

[14:55] <pmichaud> look throughout the spec, and it's very rare that we use the word "parse" to mean "match the entire thing"

[14:56] <pmichaud> or, more to the point, "be sure to reach the end of the string"

[14:57] <pmichaud> the only place we do explicit end-anchoring is when doing smart*matching*

[14:58] <pmichaud> s/explicit/implicit/

[14:59] <pmichaud> when we say "parse an expression", we generally mean "match as much of the string as follows the expression pattern"

[14:59] <masak> train &

[14:59] *** FROGGS joined
[15:00] <pmichaud> I fully agree we need a good way to mean "match a subrule with implicit end-anchor"... I'm just not sure what it is, nor that it should be the default for .parse

[15:02] *** kaleem left
[15:02] <dalek> nqp: 783e7b8 | (Arne Skjærholt)++ | src/6model/reprs/VMArray.c:

[15:02] <dalek> nqp: Implement bind_pos_boxed in VMArray.

[15:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/783e7b89a8

[15:02] <dalek> nqp: 8d7829f | (Arne Skjærholt)++ | src/6model/reprs/VMArray.c:

[15:02] <dalek> nqp: Implement bind_pos_native and at_pos_native in VMArray.

[15:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8d7829f6b9

[15:08] * FROGGS is hacking, the son is dancing to FROGGS's favourite music and the sun is shining

[15:08] <FROGGS> life can be good

[15:09] <hoelzro> =)

[15:11] <dalek> niecza: 4aabeb2 | (Solomon Foster)++ | lib/CORE.setting:

[15:11] <dalek> niecza: Restore previous infix:<cmp> sorting on different types.

[15:11] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4aabeb2117

[15:16] *** wk left
[15:19] *** kaare__ joined
[15:21] *** ObseLeTe left
[15:26] *** thou joined
[15:38] *** jeffreykegler joined
[15:38] <PerlJam> < pmichaud> I suspect that :p would be the same as :p(1).

[15:38] <PerlJam> that would be surprising.

[15:38] <PerlJam> (to me anyway)

[15:40] <jeffreykegler> I hope the channel won't mind a comment from an outsider re the meaing of "parse"

[15:40] <PerlJam> jeffreykegler: you're hardly an "outsider"  (at least IMNSHO)

[15:40] <jeffreykegler> In olden days we used to strictly distiguish parsing from lexing

[15:41] <jeffreykegler> I hasten to add language evolves and I am not saying the expanded usage is wrong

[15:41] <FROGGS> nr: sub a ( :$p ) { say $p }; a( :p )

[15:41] <p6eval> rakudo 90bd93, niecza v24-28-g2a7e0fd: OUTPUT«True␤»

[15:42] <jeffreykegler> But "parse" in the old sense meant apply a structure, and to an entire string, as per its basis in language theory

[15:42] *** Targen joined
[15:42] <dalek> roast: bf130cd | (Solomon Foster)++ | S03-operators/assign.t:

[15:42] <dalek> roast: Fix new tests to not rely on particular Rakudo semantics.

[15:42] <dalek> roast: review: https://github.com/perl6/roast/commit/bf130cd18c

[15:43] <jeffreykegler> Regular expressions think in terms of partial strings, and for them parsing the entire string is a special case: anchoring

[15:43] <jeffreykegler> For a "parser" in ye olde sense, insisting that the entire string be in the language was very much standard ...

[15:44] <jeffreykegler> ... and a "partial parse" was in the strict sense a failure

[15:45] <pmichaud> PerlJam: okay, :p would be the same as :p(True)

[15:45] <pmichaud> rn:  say :p

[15:45] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«Unhandled exception: Excess arguments to gistcat, unused named p␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (gistcat @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1341 (say @ 7) ␤  at /tmp/yzl6qKQcUp line 1 (mainline @ 3) ␤  at /home/p6eval/ni…

[15:45] <p6eval> ..rakudo 90bd93: OUTPUT«␤»

[15:45] <pmichaud> rn:  say (:p)

[15:45] <p6eval> rakudo 90bd93, niecza v24-28-g2a7e0fd: OUTPUT«"p" => Bool::True␤»

[15:45] <pmichaud> rn:  say +(:p)

[15:45] <p6eval> niecza v24-28-g2a7e0fd: OUTPUT«Unhandled exception: Cannot use value like Pair as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 293 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/mGd48BVrCc line 1 (mainline @ 3) ␤…

[15:45] <p6eval> ..rakudo 90bd93: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤␤  in method Numeric at src/gen/CORE.setting:865␤  in sub prefix:<+> at src/gen/CORE.setting:2693␤  in block  at /tmp/utcFcaba8q:1␤␤»

[15:50] *** cognominal left
[15:50] <PerlJam> jeffreykegler: so ... you would advocate .parse have implicit anchors for beginning and end of string?   What would then do partial parsing?  Would you call it .lex or something else?   :-)

[15:51] <pmichaud> jeffreykegler: you're correct on the olden usage of parse; which is why I looked at how we tend to use "parse" in the synopses.

[15:51] <FROGGS> PerlJam: fwiw: I'd like to have implicit anchors for .parse too

[15:51] <jeffreykegler> Perljam: yes

[15:52] <jeffreykegler> My own perspective comes from having spent years work on the problem of parsing in the strict sense, assuming a prior lexer phase

[15:52] <FROGGS> if I'd be satisfied with getting just a part then I would *match* it, dunno if this is the best term

[15:53] <jeffreykegler> If you define parsing as lexing, the problem I was working on was defined out of existence, 1984-style

[15:54] <jeffreykegler> Again, I acknowledge that language evolves and don't assert other uses of the work "parsing" are wrong

[15:54] <pmichaud> I suspect this is one of those decisions that TimToady will end up resolving.  :)

[15:54] <pmichaud> I suspect this is one of those decisions that TimToady++ will end up resolving.  :)

[15:54] <jeffreykegler> * work -> word

[15:55] <pmichaud> (sorry for double-paste there... didn't switch out of "editor" mode back into "irc" mode :)

[15:56] <dalek> perl6-roast-data: b89079c | coke++ | / (3 files):

[15:56] <dalek> perl6-roast-data: today (automated commit)

[15:56] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b89079c918

[15:56] *** isomorphisms left
[15:57] <jeffreykegler> Re how'd you handle partial parsing as special case, I deal with the issue in Marpa, but don't know enough about Perl 6 to comment

[15:57] <[Coke]> niecza down to 164 failures from 203 (but that was almost a day ago)

[15:57] <pmichaud> "partial parsing" isn't really a "special case" in Perl 6, though.  Or in Perl 5, either -- partial parsing tends to be the default case.

[15:58] <jeffreykegler> pmichaud: you are right about Perl 5, and I have to assume you're right about Perl 6 as well

[16:00] <pmichaud> the classical language theory meaning of "parse" is more akin to a purely declarative/functional language form, as opposed to the mixed declarative/procedural form that Perl 6 tends to use :)

[16:01] <jeffreykegler> In the Perl 5 case, "parsing" == "lexing", which is how the terms have evolved, and Perl probably played a big role in that evolution

[16:03] *** bluescreen10 left
[16:03] *** bluescreen100 joined
[16:03] <jeffreykegler> pmichaud: I want to emphasize I am not insisting the newer meaning is wrong, but I think you can see how if you are trying to talk about parsing (in ye olde strict sense) to someone for whom "parse" and "lex" are synonyms -- well, it's hard

[16:04] <pmichaud> jeffreykegler: understood, and agreed.

[16:05] <jeffreykegler> pmichaud: Perl 6 will do what it has to do consistent with its traditions, and I will live with that

[16:05] <pmichaud> I think we're trying to ferret out the true Perl 6 meaning, and it's one of those areas where TimToady++ (the linguist) will have to make the call :)

[16:05] <pmichaud> we currently have a bit of messiness in the way we use "parsing", "matching", and "anchoring", and it may want some tidying up.

[16:06] <pmichaud> I only hope this version of "tidy up" doesn't lead to large spec changes... :) :)

[16:09] <PerlJam> if "partial parsing" is the norm, then maybe .parse() and .match() should be unified.

[16:09] <pmichaud> PerlJam: perhaps, although they're slightly different.    "str".match(regex)   versuse Grammar.parse

[16:09] <pmichaud> Grammar.parse("str")

[16:10] <pmichaud> in some sense .match is the misnomer here, too, as "match" puns a bit with "smart matching"

[16:11] <[Coke]> pmichaud: I can't believe you'd poke TimToady with a stick when he's near the spec. That way lies madness.

[16:11] <dalek> rakudo-js: 921d2a7 | (Pawel Murias)++ | runtime/serialization.js:

[16:11] <dalek> rakudo-js: Remove obsolete comment.

[16:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/921d2a7064

[16:11] <dalek> rakudo-js: 44e9dea | (Pawel Murias)++ | runtime/serialization.js:

[16:11] <dalek> rakudo-js: Reorder code and add docs to BinaryCursor methods.

[16:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/44e9dea523

[16:12] <pmichaud> [Coke]: yes, I know, but I've been somewhat resigned to it :)

[16:12] <PerlJam> "str".match(Grammar) doesn't seem like too much of a stretch and then the difference between "str".match(Grammar) and Grammar.parse("str") is about who controls the execution, either the string or the grammar.

[16:12] * TimToady has already been poked with to many sticks a couple weeks ago... :)

[16:12] <TimToady> *too

[16:13] <PerlJam> I guess .match() still allows for study()-like things to happen, but that could be a modifier on .parse() too

[16:13] <pmichaud> ISTR that there was a time that ".match" acted much like ".parse" (including having the :rule and :action arguments), and then it was decided they needed to be split.  But I could be very much mistaken on that memory.

[16:14] <pmichaud> anyway, for all my comments, I don't feel I have a strongly held opinion, I'm fine with whatever the result ends up being.

[16:14] <pmichaud> I'll just have to adjust my mental model a bit again.

[16:31] *** hoelzro is now known as hoelzro|away

[16:32] *** benabik left
[16:34] *** census joined
[16:35] *** gdey joined
[16:35] <TimToady> sorear: re Gregorian calendar, the 'P' still stands for Practical

[16:35] <TimToady> speaking of which, anyone want to work on date parsing?

[16:36] *** SunilJoshi joined
[16:36] <TimToady> http://rosettacode.org/wiki/Date_manipulation is kinda waiting on it

[16:46] <pmichaud> date parsing sounds like fun

[16:46] <pmichaud> I probably won't have tuits for it, though :-/

[16:48] <TimToady> btw, the main motivation for parsefile is not laziness, but error messages containing the current filename

[16:49] *** salv0 left
[16:53] *** salv0 joined
[16:53] *** Chillance joined
[16:55] <dalek> rakudo/nom: 11157e9 | pmichaud++ | src/core/Rat.pm:

[16:55] <dalek> rakudo/nom: Rat.perl should provide angle brackets around fractional forms.

[16:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/11157e90f3

[16:55] <dalek> roast: 3f50980 | pmichaud++ | / (3 files):

[16:55] <dalek> roast: Unfudge now-passing TODO tests after more Rat.perl changes.

[16:55] <dalek> roast: review: https://github.com/perl6/roast/commit/3f509809f5

[16:55] <pmichaud> moritz:  We can fix S32-num/stringify.t  after making fixes to Rational.Str

[16:56] <pmichaud> nr: say (1/(2**7)).Str    # both rakudo and niecza get this wrong

[16:57] <p6eval> rakudo 90bd93, niecza v24-30-g4aabeb2: OUTPUT«0.007813␤»

[16:57] *** LlamaRider joined
[16:57] <pmichaud> masak: ^^^

[16:57] *** LlamaRider left
[16:58] <TimToady> nr: say 1/128

[16:58] <p6eval> rakudo 90bd93, niecza v24-30-g4aabeb2: OUTPUT«0.007813␤»

[16:58] <TimToady> er, how is it wrong?

[16:58] <pmichaud> should be 0.0078125

[16:58] <TimToady> ah

[16:58] <pmichaud> rakudo doesn't check for a number to be representable as a decimal

[16:58] <dalek> rakudo-js: 92a08dc | (Pawel Murias)++ | runtime/serialization.js:

[16:58] <dalek> rakudo-js: Refactor readHeader into BinaryCursor.header

[16:58] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/92a08dc09e

[16:58] <dalek> rakudo-js: 8efe3df | (Pawel Murias)++ | runtime/serialization.js:

[16:58] <dalek> rakudo-js: Refactor more functions into BinaryCursor methods.

[16:58] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/8efe3dfec8

[16:58] <pmichaud> (I suspect niecza does similar)

[16:59] <pmichaud> so it goes ahead and rounds instead of continuing out to the full decimal representation

[16:59] <TimToady> I think I wrongly asserted to colomon++ that my algorithm would get that right :)

[16:59] <pmichaud> the test that exposes things is

[16:59] <pmichaud> say (4.5**60).perl

[17:00] <pmichaud> rn: say (4.5**60).perl

[17:00] <p6eval> rakudo 90bd93: OUTPUT«1558657976916843360832062017400788597510.05883495394563551060␤»

[17:00] <p6eval> ..niecza v24-30-g4aabeb2: OUTPUT«1558657976916843360832062017400788597510.058834953945635510598466400011830046423710882663726806640625␤»

[17:00] <pmichaud> Rakudo sends this to Rational.Str, which does the incorrect rounding.  Niecza++ gets this one right.

[17:00] *** LlamaRider joined
[17:00] <pmichaud> however, niecza doesn't get

[17:00] <pmichaud> rn: say (1/(2**60)).perl

[17:00] <p6eval> rakudo 90bd93: OUTPUT«0.00000000000000000087␤»

[17:00] <p6eval> ..niecza v24-30-g4aabeb2: OUTPUT«0.000000000000000000867361737988403547205962240695953369140625␤»

[17:00] *** LlamaRider left
[17:00] <pmichaud> oh, hmm, it does get that one.

[17:01] <TimToady> probably because there is a big enough denominator for my algo

[17:01] <TimToady> but it's just scaling it by size, not by 2's and 5's

[17:01] <pmichaud> yeah, Rakudo's new Rat.perl is checking for 2's and 5's

[17:01] <pmichaud> but .Str isn't doing that

[17:02] <pmichaud> anyway, nieczabug and rakudobug :)

[17:02] *** neilb_ left
[17:02] <pmichaud> nr: say (1/65536).Str

[17:02] <p6eval> rakudo 90bd93, niecza v24-30-g4aabeb2: OUTPUT«0.000015␤»

[17:02] * masak submits pmichaud's rakudobug

[17:02] *** donaldh left
[17:03] <pmichaud> have to go do errands... bbiaw

[17:03] * TimToady wonders if it might be more efficient to wait until we run out of digits with the current algo and then check the remaining number for 2's and 5's, since it's likely to be be smaller than the original number

[17:03] *** dreamweaver joined
[17:03] *** dreamweaver left
[17:04] *** LlamaRider joined
[17:06] *** SamuraiJack joined
[17:07] *** daxim left
[17:07] <jnthn> evening o/

[17:08] <masak> jnthn! \o/

[17:20] *** cognominal joined
[17:23] <dalek> niecza: 7d73dd1 | larry++ | lib/CORE.setting:

[17:23] <dalek> niecza: Extend Rat.Str to emit exact decimal when possible.

[17:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7d73dd195b

[17:23] <TimToady> jnthn: you'll like that one for style points :)

[17:23] <FROGGS> hehe

[17:24] <FROGGS> TimToady++

[17:24] <TimToady> evalbot rebuild niecza

[17:24] <p6eval> OK (started asynchronously)

[17:24] <jnthn> :D

[17:24] <pmichaud> that looks a lot like the solution I drafted, but I was trying to make a private method so it could be reused in both Rat.perl and Rational.Str

[17:24] <pmichaud> really gone

[17:25] <TimToady> n: say 1/128

[17:25] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«0.0078125␤»

[17:25] <TimToady> n: say 1/65536

[17:25] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«0.0000152587890625␤»

[17:25] <TimToady> n: say <1/65536>.Str

[17:26] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«0.0000152587890625␤»

[17:26] <TimToady> (just checking)

[17:32] <TimToady> would be nice to find a way to optimize $den /= 5 if $den %% 5 to avoid double division

[17:32] *** jeffreykegler left
[17:32] *** SunilJoshi left
[17:35] <masak> pmichaud: let me politely disagree that "parse an expression" means "match as much of the string as follows the expression pattern".

[17:36] <masak> pmichaud: if I have a string starting with something matched by a grammar, followed by some garbage, I want the garbage to cause a failure. whether I then add the :part/:start option, I will be thankful the defaults caught the garbage for me.

[17:38] <masak> rn: grammar Formula { method TOP { \d '+' \d } }; say ?Formula.parse("1+7and I am a martian banana spiced with freshly mowed grass")

[17:38] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/koIrTo1_99 line 1:␤------> [32mgrammar Formula { method TOP { \d '+' [33m⏏[31m\d } }; say ?Formula.parse("1+7and I am [0m␤␤Undeclared routine:␤   'd' used at line 1␤␤Parse failed␤␤»…

[17:38] <p6eval> ..rakudo 11157e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/rR_KOezO_h:1␤------> [32mgrammar Formula { method TOP { \d '+' [33m⏏[31m\d } }; say ?Formula.parse("1+7and I am [0m␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper…

[17:38] *** jeffreykegler joined
[17:38] <masak> oops.

[17:38] <masak> rn: grammar Formula { regex TOP { \d '+' \d } }; say ?Formula.parse("1+7and I am a martian banana spiced with freshly mowed grass")

[17:38] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«False␤»

[17:38] <p6eval> ..rakudo 11157e: OUTPUT«True␤»

[17:38] <jnthn> That was some garbage :P

[17:39] <TimToady> well, people have been "parsing" since middle english (the term predates CS by centuries, anyway), and pragmatically speaking we do it on continuous input all the time

[17:39] <TimToady> which is why people are allowed to add to sentences

[17:39] <TimToady> like this one

[17:40] <masak> well, look what we did with numbers.

[17:40] <masak> rn: +"42martian banana"

[17:40] <p6eval> rakudo 11157e: OUTPUT«Cannot convert string to number: trailing characters after number in '42⏏martian banana' (indicated by ⏏)␤current instr.: 'throw' pc 333965 (src/gen/CORE.setting.pir:149807) (src/gen/CORE.setting:9298)␤called from Sub 'sink' pc 365862 (src/gen/CORE.setting.pir:1625…

[17:40] <p6eval> ..niecza v24-31-g7d73dd1: OUTPUT«Unhandled exception: Cannot parse number: 42martian banana␤  at /home/p6eval/niecza/lib/CORE.setting line 1489 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3605 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3607 (NumSyntax.str2nu…

[17:41] <masak> it's another instance of the same issue.

[17:41] <TimToady> I'm not saying we shouldn't have a way to anchor a parse easily, but claiming "parse" has always meant that isn't gonna stick :)

[17:42] <masak> the conversion fails, not because there wasn't a proper number there to be parsed, but because there was garbage.

[17:42] <TimToady> sure, but +'s mandate is to parse the whole thing

[17:42] <diakopter> gigo

[17:42] * masak places the consistency card on the table :)

[17:42] <TimToady> whereas grammars are supposed to be slightly composable

[17:43] <masak> TimToady: I argue Least Surprise is "parse the whole thing, or fail".

[17:43] <TimToady> I'm not even arguing against that

[17:43] <masak> colomon's blog post is one big, real-world example of that.

[17:43] <TimToady> one solution is to just provide a subparse method

[17:44] <TimToady> well, I'm not sure that isn't just a bug in the grammar...

[17:44] <masak> oh, ok.

[17:45] <TimToady> don't have the whole grammar in the article, but it probably shouldn't be backtracking somewhere anyway, if you want to know the high water

[17:45] *** am0c joined
[17:45] <TimToady> anyway, I'm much more into grammars that have a lot of || <.panic: Good error message>

[17:46] <jnthn> TimToady: Have you considered spec'ing a way to get at the highwater, ooc?

[17:46] <TimToady> it's not clear how much of that can be intuited by the failure of an entire grammar

[17:46] *** fgomez left
[17:46] <jnthn> TimToady: Though...I don't do it by the contextual and don't want to for performance reasons...

[17:46] <jnthn> So don't spec it that way :P

[17:47] <jnthn> Just thinking it's useful information to have when reporting an error

[17:47] <TimToady> maybe we could have a <hw> thingy you can put in various places

[17:48] <masak> ooh

[17:48] <TimToady> or maybe we could have a cockpit record of some sort for commits

[17:50] *** cognominal left
[17:55] <moritz> masak: I've just quoted your law of unintended consequences in a $work conversation :-)

[17:57] <TimToady> jnthn: if contextuals make algorithms slow, then we need to fix contextuals to cache better locally

[17:59] *** ObseLeTe joined
[17:59] *** wk joined
[17:59] *** cognominal joined
[17:59] *** fgomez joined
[18:00] *** rindolf joined
[18:05] *** fgomez left
[18:05] <moritz> r: say eval( (1.2).perl ).WHAT

[18:05] <p6eval> rakudo 11157e: OUTPUT«(Rat)␤»

[18:06] <TimToady> r: say eval 1.2.WHAT

[18:06] <p6eval> rakudo 11157e: OUTPUT«Cannot call 'eval'; none of these signatures match:␤:(Str $code, :lang(:$lang) = { ... }, PseudoStash :context(:$context))␤␤  in block  at /tmp/7AAcpiGZaE:1␤␤»

[18:06] <TimToady> r: say eval 1.2.WHAT.name

[18:06] <p6eval> rakudo 11157e: OUTPUT«No such method 'name' for invocant of type 'Rat'␤  in block  at /tmp/sM4hIw9AWU:1␤␤»

[18:07] <TimToady> r: say eval 1.2.WHAT.gist

[18:07] <p6eval> rakudo 11157e: OUTPUT«(Rat)␤»

[18:07] *** cognominal left
[18:07] *** Liz joined
[18:07] <TimToady> :)

[18:07] <TimToady> r: say eval ~1.2.WHAT

[18:07] <p6eval> rakudo 11157e: OUTPUT«use of uninitialized value of type Rat in string context  in block  at /tmp/aCnisA1Soi:1␤␤Nil␤»

[18:07] *** Liz is now known as Guest86894

[18:07] <TimToady> right

[18:07] *** Guest86894 is now known as lizmat

[18:08] <moritz> TimToady: have you seen my questions about Nil in the backlog?

[18:08] <TimToady> I answered some of 'em

[18:08] <moritz> ok, great

[18:08] * moritz backlogs

[18:08] *** dakkar left
[18:11] <moritz> still quite a few questions to go :-)

[18:12] *** cognominal joined
[18:13] <TimToady> Oh, missed one.  Nil is distinguished from Failure in not throwing an exception in sink context

[18:13] <TimToady> as well as not having a payload

[18:16] *** lichtkind_ joined
[18:18] <moritz> is Nil still some kind of () ?

[18:18] <moritz> and there was the one about whether Nil.Str actually fails or warns

[18:19] *** lichtkind left
[18:20] <moritz> (or does both :-)

[18:21] <TimToady> no, Nil is just like () insofar as both represent that there are no values

[18:21] <TimToady> but differently

[18:22] <TimToady> thinking about Nil.Str

[18:22] *** SamuraiJack left
[18:24] <dalek> specs: 3dd0a22 | larry++ | S03-operators.pod:

[18:24] <dalek> specs: Include Failure in smartmatch passthroughs

[18:24] <dalek> specs: 

[18:24] <dalek> specs: Only actual failure objects pass through.  You can match against Failure

[18:24] <dalek> specs: as a literal type.  Presumably this can be distinguished by Failure.ACCEPTS.

[18:24] <dalek> specs: review: https://github.com/perl6/specs/commit/3dd0a22eb1

[18:27] *** benabik joined
[18:29] <jnthn> dinner, bbl

[18:29] <dalek> specs: e89ca67 | larry++ | S02-bits.pod:

[18:29] <dalek> specs: Loosen perceived relationship of Nil and ()

[18:29] <dalek> specs: review: https://github.com/perl6/specs/commit/e89ca6704b

[18:31] *** xilo joined
[18:31] <TimToady> moritz: I think I still like what the spec says about Nil.Str.  One may always change to the other policy application-wide by fatalizing the warning.

[18:32] <TimToady> if we default it the other way, people are forced to scatter catches all over, it seems to me

[18:33] <[Coke]> ZOMG did I see a timtoady implementation commit?

[18:33] <TimToady> and trying to resume a normal exception just seems dicier than fatalizing a warning

[18:35] <TimToady> my cat would rather starve than eat her food with the medicine mixed in, sigh...

[18:35] <TimToady> so much for subterfuge

[18:36] <TimToady> now she'll just hate me for the rest of her and/or my life for forcing it down her throat...

[18:37] <TimToady> maybe programmers are too much like cats...

[18:40] * [Coke] vomits on TimToady's carpet.

[18:41] <geekosaur> cats can be patient, though...

[18:45] *** am0c left
[18:47] <TimToady> trouble is, it takes about 3 hands to wrap an unwilling cat into a towel, and I don't have quite that many...

[18:48] <TimToady> a gripping hand would be perfect for kitty

[18:50] <dalek> perl6-roast-data: 3d5b057 | coke++ | / (4 files):

[18:50] <dalek> perl6-roast-data: today (automated commit)

[18:50] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/3d5b05753e

[18:54] *** banisterfiend joined
[18:55] <banisterfiend> this made me lol http://otierney.net/images/perl6.gif   (sry:P)

[18:58] <moritz> "Nil.Numeric likewise fails with resumable warning that returns 0 on resumption."

[18:58] <moritz> that sounds like

[18:58] <moritz> method Numeric { warn "Used Nil in numeric context"; fail 0; }  # or so

[18:58] <moritz> which seems like overkill

[18:59] <moritz> (for me "fails" means "return a Failure object", and "with a warning" means warn(). Combining both seems... overwarnkill)

[18:59] <moritz> same with .Str

[19:00] *** tokuhiro_ joined
[19:00] *** fgomez joined
[19:05] <dalek> specs: 6bb5a41 | larry++ | S02-bits.pod:

[19:05] <dalek> specs: don't say "fails" unless you mean it

[19:05] <dalek> specs: review: https://github.com/perl6/specs/commit/6bb5a4105b

[19:06] <dalek> Perlito: a78d702 | (Flavio S. Glock)++ | / (4 files):

[19:06] <dalek> Perlito: Perlito5 - js - move the whole eval() compilation to "perl5-land"

[19:06] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/a78d702cb6

[19:06] *** benabik left
[19:09] *** supernovus joined
[19:09] <supernovus> ping masak

[19:14] *** benabik joined
[19:15] <supernovus> phenny: tell masak I'd like to discuss with him a complete overhaul of the "Web" project.

[19:15] <phenny> supernovus: I'll pass that on when masak is around.

[19:16] *** jeffreykegler left
[19:19] *** sqirrel left
[19:19] <banisterfiend> supernovus: isn't part of the problem with perl6 (and the reason it's vaporware) is everyone keeps trying to "overhaul" everything all the time? 

[19:19] *** zby_home joined
[19:22] <TimToady> kinda surprising for vaporware to have more working solutions on rosettacode than Perl 5, dontcha think?

[19:23] <[Coke]> (web) Keep me in mind for that. That's my most likely production use of perl6, web on rakudo on jvm.

[19:23] <TimToady> and the "Web" project isn't exactly Perl 6...

[19:25] *** isomorphisms joined
[19:26] <supernovus> banisterfiend: The "Web" project is currently in a state of abandonment, serving as a home to some incompleted incubation projects. In its current form, it is not useful. I have a proposal, to discuss with masak, to make Web useful again, and to make it the de facto starting point for anyone planning to build web applications with Perl 6.

[19:26] <banisterfiend> fair enough

[19:26] <banisterfiend> sorry :)

[19:27] <arnsholt> banisterfiend: You've been reading too much chromatic ;)

[19:27] <banisterfiend> yeah, that's true

[19:27] <Ulti> from having built each release of Rakudo* since it was created its p. obvious the performance and feature set is really progressing every month, not sure how that would fit any sort of vaporware scenario.... 

[19:27] <TimToady> well, it's easy to start using fightin' words just for the fun of it, but we usually try to de-escalate around here...

[19:29] *** xilo left
[19:31] <masak> supernovus: pong

[19:31] <phenny> masak: 19:15Z <supernovus> tell masak I'd like to discuss with him a complete overhaul of the "Web" project.

[19:31] <Ulti> one day all cpan authors will wake up and simultaneously decide to port their module to Perl6, and in one 24 hour period Perl6 will become "production ready"

[19:31] <supernovus> [Coke]: I will certainly keep you in mind. I'm planning to use a refactored version of my WWW::App library set as a starting point, split off all of the incubator projects as separate github projects, and turn over the main Web portion to the perl6 github group for a more open development process.

[19:31] <masak> supernovus: sounds interesting. I'm listening.

[19:32] *** isomorphisms left
[19:33] <masak> moritz: I should've made the law "...a corresponding WAT, you're just not aware of it yet."

[19:33] *** census left
[19:34] <supernovus> masak: As you may know, WWW::App started out as a way to rebuild the Web::Request and Web::Response libraries, and add some optional candy coating. Now I'm proposing moving them back into the Web namespace, and spinning off each of the current incubator projects as separate projects on Github, and refactoring them to use the new Web "core library".

[19:34] <masak> banisterfiend: no, I don't think that's part of the problem.

[19:34] <masak> supernovus: ooh.

[19:35] <supernovus> As everyone elses tuits are current focused elsewhere, I'd be willing to do the body of the work, but as you current own the 'web' project, and likely the many incubator projects within it, the whole "splitting off" part must be done together with you. If you agree with the proposal.

[19:35] <masak> supernovus: I'm no longer sold on the idea of doing everything under one roof. the idea was risky and met with skepticism back then, and nowadays it doesn't even have me to champion it. so "spinning off as separate projects" sounds nice.

[19:35] *** xilo joined
[19:36] <masak> supernovus: yes, I agree with the proposal.

[19:36] <masak> supernovus: but let me also propose that spinnings-off shouldn't be done just because.

[19:36] <masak> they should be done because some rubber-meets-road project is using them.

[19:36] *** jeffreykegler joined
[19:36] *** census joined
[19:36] <masak> the project I believe would most benefit from being spun off is Hitomi.

[19:37] <masak> feel free to rename it while you're at it, so jnthn will stop teasing me about the name :P

[19:38] <masak> supernovus++

[19:39] <Ulti> lol at google image search for Hitomi

[19:39] * masak doesn't think he wants to know :)

[19:39] <Ulti> thats almost as bad as my machine naming convention

[19:40] *** benabik left
[19:40] <supernovus> masak: That was a big part of my idea. Keep each project separate, so users can mix and match the components they want to use. Astaire may be best merged with my own WWW::App::Ballet, which could get a new name. I have to take a closer look at Squerl. I wrote DB::Model::Easy to be a "simple" ORM layer. Ratel and Hitomi would make nice additions to Template6, Flower::TAL, HTML::Template, Plosurin, and Template::Mojo.

[19:40] <masak> oh my :(

[19:40] <masak> yeah, change the name...

[19:40] <Ulti> >:3

[19:41] <Ulti> I love how its not just a girls name, but specifically a smutty girls name

[19:41] <masak> supernovus: I consider Bailador to be a successful web project, filling the vacuum left by Web collapsing. it has its own Request/Response too.

[19:41] <masak> Ulti: no, it means "beautiful", IIRC.

[19:41] <PerlJam> supernovus: I think masak is just saying to be sure there's someone who wants to mix-n-match before you start splitting things up  :)

[19:41] <tadzik> supernovus: I'd love a decent web-base for Bailadancer

[19:42] <Ulti> masak yeah but in japanese any word can essentially be a name.. so its like a porn name

[19:42] <supernovus> Well, I could look at merging Bailador's Request/Response with the new Web ones, and refactoring it to use the new version, then dropping Astaire and WWW::App::Ballet entirely.

[19:42] <tadzik> well, um, this image search makes me thing that Web.pm could use a better logo on m.p.o ;)

[19:42] <masak> Google Translate says it means "pupil".

[19:42] <Ulti> why no school girls

[19:43] <PerlJam> supernovus++

[19:43] <TimToady> it also means "body"

[19:43] <TimToady> that's "pupil" as in eye, by the way, not as in student

[19:43] <Ulti> all three of these word meanings combined is bad news

[19:43] <masak> supernovus: sounds great.

[19:43] <supernovus> If Astaire/WWW::App::Ballet have any features that Bailador doesn't, I could port them over as well.

[19:43] <masak> TimToady: yeah. forgot to say that.

[19:43] <Ulti> TimToady: ahh ok 

[19:44] <masak> TimToady: I've never reflected on "pupil" meaning both "part of eye" and "young student".

[19:44] <tadzik> supernovus: I wonder if there's point in having those projects separated

[19:44] <masak> join forces, methinks.

[19:44] *** lue joined
[19:44] <tadzik> or maybe Bailadancer could just be a different frontend to www-app-ballet

[19:44] <lue> hello o/

[19:44] <tadzik> maybe that'd make sense

[19:45] <Ulti> homonyms are annoying

[19:45] <Ulti> cant we just get rid of them

[19:46] <TimToady> their two important

[19:46] <Ulti> only if you like poetry :P

[19:46] <supernovus> Hmm, I guess in a refactored form, Ballet could be a "base" for subroutine based Web dispatch, and Bailador a "higher level" framework with all of the bells and whistles.

[19:46] <Ulti> or jokes

[19:47] <tadzik> supernovus: sounds good

[19:48] <PerlJam> supernovus: perhaps I'm suffering a failure of imagination,  but could you distinguish Ballet and Bailador a little more ... what bells and whistles are you talking about?

[19:48] <masak> Ulti: Esperanto is better than most languages at orthogonalizing meanings into different words. I could riff off a dozen examples offhand. but, importantly, it still falls short. language seems to thrive on polysemy.

[19:49] <PerlJam> masak: and crazy people.  you need lots of crazy people.

[19:49] <masak> PerlJam: Ballet has tight pants. Bailador has a cape and a rose. :P

[19:50] * [Coke] swings a dead cat in #perl6 to satisfy PerlJam's request.

[19:50] <supernovus> PerlJam: I'm not entirely sure yet. Ballet is very much incomplete, it simply does dispatch based on the HTTP Method and URL, and currently doesn't have any support for placeholders or whatnot. I'm not entirely sure there is any need for separate versions, but I'll know better when I "dig in" to the code. :-)

[19:50] *** fhelmberger left
[19:53] *** fgomez left
[19:54] <supernovus> Apparently I don't have permission to create new projects under the "perl6" group, does it matter if I create it as my own user then "hand it over" (or perl6 just forks it?)

[19:56] <masak> actually, I don't think any of what we've talked about should be under the perl6 organization.

[19:57] <masak> sorry, that's part of what I learned when doing Web.

[19:57] <masak> we need the darwinian aspect of it all, the one that doesn't bless a particualar module or set of modules.

[19:58] <supernovus> Okay, then I'll just create it under my own. Is there a way to grant the "perl6" group commit rights to a personal project? Or do I have to just grant user-by-user?

[19:59] <dvj> r: my $a;  "$a(?:\";

[19:59] <p6eval> rakudo 11157e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of ?: for the conditional operator; in Perl 6 please use ??!!␤at /tmp/9QG_vvM8YM:1␤------> [32mmy $a;  "$a(?[33m⏏[31m:\";[0m␤»

[19:59] <dvj> Is it supposed to interpret ? as a operator?

[20:00] <dvj> n: my $a;  "$a(?:\";

[20:00] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Prefix requires an argument at /tmp/ZZs4DZSaqz line 1:␤------> [32mmy $a;  "$a(?[33m⏏[31m:\";[0m␤␤Parse failed␤␤»

[20:00] <TimToady> yes, it is

[20:01] *** FROGGS left
[20:01] *** prammer_ is now known as prammer

[20:01] <TimToady> it commits to a postcircumfix as soon as it sees the opener

[20:01] <PerlJam> That's a LTA message though.

[20:02] <dvj> is ( the opener?

[20:02] <PerlJam> dvj: yes

[20:02] <dvj> ok

[20:02] *** fgomez joined
[20:02] <TimToady> you could have 5000 lines of code before the )

[20:03] <TimToady> at some point you just have to treat it as code, not as maybe a messed up interpolation

[20:05] <PerlJam> It's too bad we don't have a quoter that disregards postcircumfixes.

[20:05] <TimToady> I'd also point out that our awesomely dwimmy messages tend to result in a WAT at the startup times :)

[20:05] *** xilo left
[20:06] <PerlJam> (I mean other than the obvious non-interpolation ones :)

[20:08] <PerlJam> I suppose the cost of some {} is cheap enough if you really want to juxtapose values from variables and postcircumfixes.

[20:08] <TimToady> well, you just have to always interpolate using qc/ {stuff} /

[20:09] <TimToady> or ' \qq[$stuff] '

[20:10] <TimToady> nr: my $x = 'stuff'; say 'It\'s \qq[$x] and nonsense.'

[20:10] <p6eval> rakudo 11157e, niecza v24-31-g7d73dd1: OUTPUT«It's stuff and nonsense.␤»

[20:15] *** bapa left
[20:16] *** cognominal left
[20:22] <supernovus> So, for incubator projects, Squerl and Hitomi seem like the only ones I could see being used in a real world application (when finished I could use Squerl within DB::Model::Easy instead of its own home-brewed SQL abstraction layer.) Astaire will be replaced by Bailador, and Ratel has a lot of more complete competition in the template department.

[20:23] *** jeffreykegler left
[20:24] *** cognominal joined
[20:30] *** ObseLeTe left
[20:30] <masak> oh right, Squerl.

[20:31] <masak> I have no idea how I ended up working on that within the Web umbrella.

[20:31] <masak> it has some nice ideas in it, yes. and quite a number of tests.

[20:31] *** banisterfiend left
[20:33] * lue would like the *CGI modules working again

[20:33] <supernovus> lue: What aspect of CGI are you looking for?

[20:33] <dalek> nqp: 7148fa7 | (Arne Skjærholt)++ | src/6model/reprs/VMArray.c:

[20:33] <dalek> nqp: Make VMArray's {bind,at}_pos_{native,boxed} respect the body->start parameter.

[20:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7148fa7d69

[20:33] <dalek> nqp: f0816ff | (Arne Skjærholt)++ | src/6model/reprs/VMArray.c:

[20:33] <dalek> nqp: First implementations of push, pop, shift and unshift for VMArray.

[20:33] <dalek> nqp: 

[20:33] <dalek> nqp: Most of the groundwork is in place now. Next: Fixing the bugs.

[20:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f0816ff423

[20:34] <masak> lue: and how can we talk you out of it? :)

[20:34] <lue> I liked SCGI the best (don't remember why), but the input when I debug-printed it was cut off every time

[20:35] <supernovus> Oh, I see, the connector libraries, not the request. I was going to say, Web::Request or better yet, Web::App replaces the need for the old CGI interface. As for SCGI, it should be working again shortly with some bug fixes to Rakudo.

[20:36] <lue> My guess is it read too little because of some socket reading limit I remember hearing about a while back (only return the first 0x100 bytes even if more requested IIRC)

[20:36] *** jeffreykegler joined
[20:37] <supernovus> I will do some testing on SCGI and see if I can get it working with the current Rakudo. Unlike HTTP::Easy, it doesn't depend on the IO::Socket::INET.get() method working.

[20:37] *** jeffreykegler left
[20:42] *** SmokeMachine left
[20:43] <arnsholt> A philosophical question: Is it still yak-shaving when shaving a particular yak turns out to be fun work after all?

[20:45] <masak> yes.

[20:45] <masak> fun doesn't make yak shaving not yak shaving. rather the reverse, I'd say.

[20:47] *** xilo joined
[20:50] *** xilo left
[20:51] *** lizmat left
[20:55] *** fgomez left
[20:58] <supernovus> Any suggestions for a new name for Hitomi?

[20:59] <tadzik> Cutegirl? :>

[20:59] <tadzik> will yield better google images search, maybe :P

[21:00] <supernovus> Ha! Hitomi yields some interesting results as it is...

[21:00] *** xilo joined
[21:03] *** fgomez joined
[21:05] <tadzik> hmm

[21:05] <tadzik> any reason why .prompt cannot be a method on IO?

[21:05] <tadzik> that'd be nice

[21:05] <tadzik> I just used that in Quest and was surprised that it doesn't DWIM :)

[21:06] <jnthn> tadzik: Trouble is, I think, that prompt involves two handles.

[21:06] <tadzik> oh, it needs both $*IN and ... right

[21:06] <tadzik> well, I can easily workaround that :)

[21:08] <masak> ($*IN & $*OUT).prompt # *evil grin*

[21:09] <arnsholt> jnthn: I think I've imported most of QRPA into VMArray now. Not quite all there yet, but getting close to the point where I can poke it and see what goes boom

[21:11] <jnthn> masak: I...how...what... :P

[21:11] <jnthn> I guess this is "everything can be done with Junctions" revenge for "everything can be done with macros" ;)

[21:12] <jnthn> arnsholt: nice! :)

[21:12] *** shinobicl left
[21:13] *** census left
[21:15] <masak> jnthn: the "everything can be done with Junctions" misunderstanding is doing fine without me exacting any revenge for anything ;)

[21:16] *** zby_home left
[21:17] <dalek> ecosystem: e353234 | (Timothy Totten)++ | META.list:

[21:17] <dalek> ecosystem: Web framework restructuring has begun.

[21:17] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e35323493a

[21:17] <tadzik> drum roll

[21:18] *** LlamaRider_ joined
[21:18] *** xilo left
[21:18] <lue> r: my $a = [1,2,3]; my $b = $a; say $a === $b;

[21:18] <p6eval> rakudo 11157e: OUTPUT«True␤»

[21:19] <lue> Is that right?

[21:19] *** LlamaRider_ left
[21:19] *** LlamaRider left
[21:19] <jnthn> Looks right to me.

[21:19] *** LlamaRider joined
[21:19] *** cognominal left
[21:20] <masak> lue: yeah, I'd say so.

[21:20] <masak> lue: the assignment is basically assigning a reference from one variable to another.

[21:20] *** Chillance left
[21:21] <lue> OK. Somehow I thought assignment would create an object with a different WHICH value

[21:21] *** donaldh joined
[21:22] <masak> it does if you do '@b = @a', because then you're like pouring values over from one array into another.

[21:22] *** xilo joined
[21:22] <masak> but here you're not creating anything new.

[21:22] *** spider-mario joined
[21:22] <masak> you're just saying "this $b thing? yeah, assign the referent from $a to it, too".

[21:22] <masak> same with other objects, not just arrays.

[21:23] <masak> r: class Dog {}; my $woof = Dog.new; my $roof = $woof; say $roof === $woof

[21:23] <p6eval> rakudo 11157e: OUTPUT«True␤»

[21:23] <masak> note; only one Dog.new

[21:23] <masak> so it basically has to be the same reference.

[21:24] <masak> similarly, you have only one []

[21:24] <masak> (but the whole thing is complicated a bit by things like '@b = @a')

[21:25] <lue> Alright. I was probably thinking about @ when trying that.

[21:26] <masak> r: my @a; my @b; say @a === @b

[21:26] <p6eval> rakudo 11157e: OUTPUT«False␤»

[21:26] <donaldh> jnthn: I gave up with BCEL for invokedynamic. It looks like BCEL still requires enhancements to support it.

[21:26] <masak> in a way, declaring a @-sigil variable is like having a hidden [] in your code.

[21:27] <donaldh> jnthn: I am part way through an experimental ASM port.

[21:30] <dalek> ecosystem: 72153fe | (Timothy Totten)++ | META.list:

[21:30] <dalek> ecosystem: Added Squerl as a standalone project.

[21:30] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/72153fe119

[21:31] <donaldh> jnthn: I have completed P6opaque with all tests passing, so now on to JASTToJVMBytecode

[21:31] <jnthn> donaldh: I'd largely expected to have to throw together a few classes if it was done with BCEL

[21:31] <jnthn> Oh wow, that's awesome progress

[21:31] <jnthn> Are you pushing this somewhere?

[21:31] <donaldh> It's on the asm_port branch of my fork.

[21:31] <donaldh> On github

[21:33] <jnthn> OK. You have a commit bit to The Repo too if you want to work on it in a branch there :)

[21:33] *** Chillance joined
[21:33] <donaldh> JASTToJVMBytecode looks like it will be a bit harder for me to grok. I'm guessing you had to do a lot to track jump targets. ASM does that with Labels so might even simplify the logic.

[21:34] <jnthn> My logic basically implements labels :)

[21:35] <jnthn> The whole thing is, well, an assembler :)

[21:35] <jnthn> You may be better off just starting over.

[21:35] <donaldh> jnthn: Good point. I could switch to a branch in The Repo now. I am at a good point to switch.

[21:35] <jnthn> And working through making t/jast/jast.t pass.

[21:36] <jnthn> The entire language it spits out is done by dump methods in lib/JAST/Nodes.nqp

[21:36] <jnthn> If it makes your life easiesr there's no reason you can't change exactly what it emits too

[21:36] <jnthn> Be a bit careful around string literals, is all :)

[21:37] *** xilo left
[21:37] <donaldh> jnthn: thanks.

[21:38] <jnthn> Thanks for working on this. I did a bunch of the refactors to the calling stuff in preparation for invoke dynamic already, so it's good timing that you're tackling it from the code-gen side. :)

[21:40] <TimToady> masak: http://rosettacode.org/wiki/Maze_solving#Perl_6   # better? :)

[21:42] <jnthn> donaldh++ # writes prettier Java than me :)

[21:42] <donaldh> :)

[21:42] * donaldh writes Java for a $dayjob

[21:43] * donaldh would love to use Perl 6 as a scripting language on JVM for $dayjob :)

[21:46] * tadzik dreams of releasing his Perl6 adventure game as an android app

[21:51] <[Coke]> donaldh: that's pretty much my path to using perl6, aye.

[21:52] * jnthn has final day of teaching this week tomorrow, and then will have plenty of Perl 6 tuits on Friday. :)

[21:52] *** xilo joined
[21:55] <dalek> ecosystem: bf59ff4 | (Timothy Totten)++ | META.list:

[21:55] <dalek> ecosystem: Added Hinges, formerly Hitomi, as standalone project.

[21:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/bf59ff40a9

[21:57] <masak> TimToady: immesurably better. also, cool trick.

[21:57] <masak> TimToady: you keep surprising me with how much computation can actually be done at "constant declaration time".

[21:59] <TimToady> unfortunately, breaks rakudo

[22:00] <masak> anything submittable?

[22:01] *** xilo left
[22:01] <LlamaRider> I never understood the exact view on backwards compatibility for perl6-to-p5. I see there is a "most wanted list" of CPAN modules in Perl6, does that mean all of CPAN will need to be reimplemented?

[22:01] <TimToady> r: enum WAT (<a b c>);

[22:02] <p6eval> rakudo 11157e: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Parcel'␤»

[22:02] <TimToady> masak: ^^

[22:02] <TimToady> n: enum WAT (<a b c>); say c;

[22:02] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«c␤»

[22:02] <TimToady> n: enum WAT (<a b c>); say +c;

[22:02] <jnthn> TimToady: Is there *any* restriction at all on what you can put in an enum declarator?

[22:02] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«2␤»

[22:03] <masak> TimToady: I think that one is known.

[22:03] <TimToady> sure, value has to be available at compile time

[22:03] <jnthn> TimToady: 'cus I'm Rakudo it's been treated as syntactic and we try to pick it apart.

[22:03] *** lustlife left
[22:03] <masak> jnthn: yeah, the valu... what TimToady said.

[22:04] <jnthn> yes but...how to know all the things are available without actually (a) running it, or (b) analysing the AST?

[22:04] <jnthn> And if you do (a) how do you know?

[22:04] <TimToady> well, the parens are supposed to be vaguely reminiscent of, like, an expression or something... :)

[22:04] <masak> LlamaRider: currently, there's no p6-to-CPAN connection. until there is, important CPAN modules need to be reimplemented in Perl 6.

[22:05] *** xilo joined
[22:05] <TimToady> if the values aren't there, then the programmer has written something erroneous, and likely to cause subsequent compilation to fail

[22:05] <jnthn> TimToady: Is there any reason I should not just do something like run the thing in the parens as an eval and expect a pair or hash or parcel back?

[22:05] *** xilo left
[22:05] <jnthn> er, as a BEGIN I mean...

[22:06] <lue> LlamaRider: but we definitely don't want to port every CPAN module to Perl 6

[22:06] <TimToady> I suspect that is more or less what niecza is doing to make it work

[22:06] <tadzik> r: say so any(Int, Str) ~~ Int

[22:06] <p6eval> rakudo 11157e: OUTPUT«False␤»

[22:06] <tadzik> that's puzzling

[22:06] <TimToady> it's that WAT of allowing you to check something to see if it ~~ Junction

[22:06] <jnthn> TimToady: Right. I'm asking this as a more general question when we have non-trivial values needed at compile time.

[22:06] *** kaare__ left
[22:07] <jnthn> n: enum Foo ((say 'omg'))

[22:07] <tadzik> WAT?

[22:07] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«omg␤»

[22:07] *** xilo joined
[22:07] <jnthn> n: my $x; enum Foo ($x)

[22:07] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1341 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[22:07] *** skids left
[22:07] <tadzik> hm, wrong side

[22:07] <LlamaRider> masak: Is there an active effort for a connecting p6 to CPAN? If yes, why bother reimplementing? If not, why not outright confess all of CPAN needs redoing?

[22:07] <jnthn> TimToady: My question is mostly about things like that.

[22:07] <masak> LlamaRider: yes, several. but it's *hard*.

[22:07] <masak> LlamaRider: not all of CPAN needs redoing.

[22:07] <TimToady> I see no reason not to let the programmer shoot themselves in the noose there

[22:07] <masak> LlamaRider: allegedly, much of it is crap :)

[22:08] <LlamaRider> :D

[22:08] <TimToady> 111% of CRAP is cpan

[22:08] <masak> hee hee... enough gun to shoot yourself in the noose. :P

[22:09] * lue puts TimToady's "noose" sentence in a safe place

[22:09] <masak> Perl 6 gives you enough dada to duck yourself in the sauce.

[22:10] <jnthn> TimToady: OK. I'd somewhat got the impression that there might want to be this kinda half-way house betewen expecting a simple syntactic value thing and full-blown BEGIN. I'm kinda happy enough if there isn't anything in that space, though... :)

[22:10] <TimToady> why make extra work? :)

[22:10] <jnthn> Well, val is sorta kinda in that space, ish :)

[22:10] <TimToady> it's not like you're allowed to do much with it till CHECK time anyway...

[22:11] <jnthn> True :)

[22:11] <jnthn> rn: enum Foo (1,2,3)

[22:11] <p6eval> niecza v24-31-g7d73dd1:  ( no output )

[22:11] <p6eval> ..rakudo 11157e: OUTPUT«===SORRY!===␤This type cannot unbox to a native string␤»

[22:11] *** mikemol left
[22:11] <jnthn> n: enum Foo (1,2,3); say 2.WHAT

[22:11] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«(Int)␤»

[22:11] <jnthn> phew :)

[22:11] <jnthn> n: enum Foo (1,2,3); say Foo::.keys

[22:11] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«0␤»

[22:12] <jnthn> n: enum Foo (1,2,3); say Foo::.perl

[22:12] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«Stash.new(...)␤»

[22:12] <jnthn> n: enum Foo (1,2,3); say Foo::<0>

[22:12] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«(Any)␤»

[22:12] <TimToady> n: enum Foo (1,2,3); say Foo.enums.perl

[22:12] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«EnumMap.new(...)␤»

[22:12] <TimToady> :P

[22:12] <LlamaRider> masak: So, say I decide I want to port my favorite CPAN module to p6. Would I be expected to copy it verbatim (pass the same test suite, have the same features). More importantly, should I expect my work will go to waste when/if a CPAN connection is achieved?

[22:12] <TimToady> n: enum Foo (1,2,3); say Foo.enums.pairs.perl

[22:13] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«("1" => 0, "2" => 1, "3" => 2).list␤»

[22:13] <jnthn> n: enum Foo (1,2,3); say ::MY.keys.grep(/\d+/)

[22:13] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«Unhandled exception: Unable to resolve method keys in type MY␤  at /tmp/P0IIcYmEXU line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4284 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4285 (module-CORE @ 581) ␤  at /home/p6…

[22:13] <jnthn> n: enum Foo (1,2,3); say MY::.keys.grep(/\d+/)

[22:13] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«0␤»

[22:14] <jnthn> Hm :) Seems it's not keen to install non-string keys

[22:14] <TimToady> you mean non-identifier maybe

[22:14] <masak> LlamaRider: re verbatim, that's a matter of taste and purpose. jnthn and I ported a module recently-ish, and kept the API but replaced the innards with something nicer.

[22:15] <jnthn> TimToady: uh, yes

[22:15] * jnthn blames teaching and too little sleep :)

[22:15] <masak> LlamaRider: re wasted work, if there's a *need* for the module now, it's not a waste if we have the module now.

[22:16] <masak> LlamaRider: also, it's a matter not just of time, but of risk. who knows how long until we have a working CPAN connection?

[22:20] <LlamaRider> masak: Is there an easy way of reusing test suites by now? Would be nice to have everything up to Test::More before I even think of porting something.

[22:20] <LlamaRider> but I do feel itchy to do something meaningful in p6 and learn some more of it in the process.

[22:21] <masak> porting test suites is usually fairly straightforward.

[22:22] <masak> we have a Test::More, included in both Rakudo and Niecza.

[22:22] <masak> but we just call it Test :)

[22:24] <tadzik> https://gist.github.com/tadzik/5103684

[22:24] <tadzik> ...now, that was dramatic

[22:25] <tadzik> I didn't want "game over" to be so terminal

[22:25] <TimToady> there was definitely a lot of terminal there...

[22:25] <masak> tadzik: boy did that troll kill you hard!

[22:26] <masak> went through the ground, the floor, the fourth wall, and the VM.

[22:26] <tadzik> boy, isn't that a big club

[22:26] <tadzik> The troll is big and ugly, and carrying a club that's at least as wide as the Rakudo memory management stack

[22:26] * masak .oO( or is the troll just happy to see you )

[22:26] * TimToady was trying to visualize a memory management stick

[22:27] <tadzik> masak: I lol'd

[22:27] <lue> (that troll really... RAMmed you into the ground, eh?)

[22:27] <masak> tadzik: I pondered whether to write that out loud.

[22:27] <tadzik> that's what you get, playing the warrior in Perl 6 MMORPG

[22:28] <tadzik> I should've surrendered 

[22:28] <TimToady> we should rewrite git using an adventure API, it would be much more accessible

[22:29] <tadzik> Tony the Thief vanishes, along with your revision history. Better luck next time

[22:29] <tadzik> worthy of the name of a GC bug, it's of course not reproducible :)

[22:29] <masak> catch him in the reflog!

[22:30] <tadzik> Tony the Thief uses rebase. It's super-effective!

[22:30] <lue> You are in a maze of twisty branches, all alike.

[22:31] <tadzik> $ git-yarn unroll

[22:31] <geekosaur> git fetch kitten?

[22:31] <TimToady> What, with your bare hands?!?

[22:32] <TimToady> as it happens, I used a towel...

[22:32] <tadzik> fatal: 'kitten' does not appear to be a git repository

[22:32] <tadzik> http://24.media.tumblr.com/tumblr_m51r74hgKe1r2u6pao1_500.jpg

[22:32] *** labster joined
[22:32] <masak> November was almost named 'kittens'.

[22:33] <TimToady> I dunno, "You naughty November" just doesn't quite have the same ring to it

[22:33] *** Chillance left
[22:33] <lue> .oO(git help would suddenly be completely unhelpful half the time)

[22:34] <geekosaur> ...wouldn't that be an improvement?

[22:34] <TimToady> Nothing happens.

[22:34] <tadzik> geekosaur: haha

[22:34] <TimToady> sometimes nothing is an improvement

[22:34] <lue> I'm thinking of Invisiclues and their fake hints

[22:35] <jnthn> sleep attempt...'night &

[22:35] <TimToady> o/

[22:35] <supernovus> So, HTTP::Easy is still holding out for the IO::Socket::INET.get() bug fix, but I can happily say that the SCGI library has been updated and works properly again (and is still the fastest adapter for deploying web applications.)

[22:36] *** PacoAir left
[22:36] <TimToady> xyzzy &

[22:36] <labster> good *, #perl6

[22:37] <labster> r: say join '-', ('a', Nil, 'b')

[22:37] <p6eval> rakudo 11157e: OUTPUT«a-b␤»

[22:37] <labster> rn: my $x = Nil; say join '-', ('a', $x, 'b')

[22:37] <p6eval> niecza v24-31-g7d73dd1: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1341 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[22:37] <p6eval> ..rakudo 11157e: OUTPUT«a--b␤»

[22:39] * lue will muck around with his apache setup later then

[22:40] *** rindolf left
[22:40] <labster> Well... it's not as if Nil is well defined right now

[22:40] <labster> But I would definitely use KittenWiki.

[22:40] <lue> labster: I was referring to supernovus' comment about SCGI

[22:41] <labster> lue: I was referring to to my p6evals

[22:42] <lue> OK. Seemed like you responded to me :P

[22:43] <labster> I'm responding to you now :P

[22:45] <labster> Oh, since you're here lue, I ended up rewriting the Lingua::Number thing entirely.  I realized that Unicode CLDR folks had already put together a numbering system, so I decided to implement that instead.

[22:46] <lue> Ah. /me looks up CLDR

[22:46] <labster> Less learning foreign language for me, but more than 60 languages supported.

[22:47] <supernovus> So, Web::App with the SCGI adapter is confirmed to be working. Let the Perl 6 web app extravaganza begin! ;-)

[22:47] <labster> RBNF (rule-based number formatting) in particular is what I'm using.  I mean, I could just ask ICU to do it, but where's the fun in that?

[22:47] <labster> \o/

[22:54] <masak> supernovus++ # "hinges", I get it ;)

[22:54] <masak> 'night, #perl6

[22:55] <labster> night masak

[22:55] <supernovus> night masak!

[22:58] <supernovus> Well, I'm off, have a good * #perl6 :-)

[22:59] *** supernovus left
[22:59] *** araujo left
[23:00] *** donaldh left
[23:03] *** fgomez left
[23:09] *** xilo left
[23:13] *** grondilu left
[23:22] *** mikemol joined
[23:25] *** raiph left
[23:26] *** xilo joined
[23:28] *** bluescreen100 left
[23:29] *** woolfy left
[23:34] *** tokuhir__ joined
[23:34] *** tokuhir__ left
[23:35] *** Liz joined
[23:35] *** Liz is now known as Guest63792

[23:35] *** Guest63792 is now known as lizmat

[23:36] *** skids joined
[23:36] *** Ulti joined
[23:37] *** tokuhiro_ left
[23:37] *** mberends left
[23:37] *** mberends joined
[23:42] *** cognominal joined
[23:51] *** spider-mario left
