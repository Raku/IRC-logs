[00:04] *** LlamaRider left
[00:05] *** davidagain_ left
[00:29] *** japhb_ left
[00:38] *** Liz_ joined
[00:38] *** Liz_ is now known as lizmat

[00:39] *** Chillance left
[00:40] <timotimo> what would be a performant way to have a map of tiles that are either occupied or not and i want to set and check single tiles

[00:40] <timotimo> at the moment i have a hash of "$x|$y" strings as keys and bools as values. that doesn't seem optimal

[00:41] <diakopter> how big can the dimensions get

[00:42] <timotimo> like http://rosettacode.org/wiki/Brownian_tree - trying to implement this, the other implementations have 400x400

[00:43] <diakopter> a 400-item array of 50-byte bufs where each bit is a cell?

[00:44] <diakopter> er, whatever the mutable int array is

[00:44] <timotimo> isn't that a bit unwieldy?

[00:44] <timotimo> don't really want to do bitwise operations like shifts and masks

[00:44] <diakopter> a byte unwieldy, maybe

[00:44] <timotimo> :D

[00:45] <diakopter> then just use a 400 item array of 400 int arrays :P

[00:45] <diakopter> I was merely suggesting saving space

[00:47] <diakopter> I mean, 160,000 * 8 bytes isn't too huge.  if your dimensions were 40000x40000, on the other hand...

[00:48] <diakopter> oh, and, your mom is a bit unwieldy.  not to mention she's a Brownian tree.

[00:49] <diakopter> .. that was a silly joke, for anyone who might've thought otherwise.

[00:51] <diakopter> .. that it wasn't a joke, not that it wasn't silly.. *facepalm*

[00:51] <timotimo> i've tried that, but i can't assign to it :(

[00:51] <diakopter> eh?

[00:51] <timotimo> it works with :=, though

[00:52] <timotimo> doesn't make it very much faster. weird.

[00:52] <diakopter> r: my Array[Array[int]] @a; @a[399][399] := 1;

[00:52] <p6eval> rakudo 1c9939: OUTPUT«Cannot look up attributes in a type object␤  in method gimme at src/gen/CORE.setting:5897␤  in method bind_pos at src/gen/CORE.setting:6351␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1407␤  in block  at /tmp/chpr3el86Z:1␤␤»

[00:52] <timotimo> at least for niecza

[00:52] <diakopter> erm

[00:53] <diakopter> n: my Array[Array[Int]] @a; @a[399][399] := 1;

[00:53] <p6eval> niecza v24-34-g4f8f894: OUTPUT«Unhandled exception: Cannot use hash access on an object of type Array␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 355 (Any.bind_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at <unknown> line 0 (KERNEL An…

[00:53] <diakopter> erm

[00:53] * diakopter fails at life

[00:53] *** toddr_ left
[00:54] <timotimo> rn: my @a; @a[$_] = 0 xx 400 for ^400; @a[50][50] = 1;

[00:54] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[00:54] <p6eval> ..niecza v24-34-g4f8f894: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/qVg2AtKmzV line 1 (mainline @ 9) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583) ␤  at /home/p6eval/niecza/li…

[00:54] <timotimo> rn: my @a; @a[$_] = 0 xx 400 for ^400; @a[50][50] := 1;

[00:55] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[00:55] <p6eval> ..niecza v24-34-g4f8f894:  ( no output )

[00:55] <timotimo> >_<

[00:55] <timotimo> rn: my @a; @a[$_] = 0 xx 100 for ^100; @a[50][50] := 1;

[00:55] <diakopter> lolz.

[00:55] <p6eval> niecza v24-34-g4f8f894:  ( no output )

[00:55] <p6eval> ..rakudo 1c9939: OUTPUT«No such method 'bind_pos' for invocant of type 'List'␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1407␤  in block  at /tmp/fPrFzkVlDn:1␤␤»

[00:55] <timotimo> rn: my @a; @a[$_] = 0 xx 100 for ^100; @a[50][50] = 1;

[00:55] <p6eval> rakudo 1c9939: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/xGv4xqqChJ:1␤␤»

[00:55] <p6eval> ..niecza v24-34-g4f8f894: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/zUSheFaZnl line 1 (mainline @ 9) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4300 (module-CORE @ 583) ␤  at /home/p6eval/niecza/li…

[00:55] <diakopter> we can't win.

[00:55] <timotimo> nope, can't

[00:56] <diakopter> p: my @a; @a[399][399] := 1; say @a[399][399]

[00:56] <p6eval> pugs: OUTPUT«1␤»

[00:56] <timotimo> mhm

[00:57] <diakopter> p: my @a; @a[399][399] := 1; say @a[399]

[00:57] <p6eval> pugs: OUTPUT«                                                                                                                                                                                                                                                                                  …

[00:57] * diakopter squints

[00:57] <timotimo> it's too small!

[00:57] <diakopter> p: my @a; @a[399][399] := 1; say @a[399].perl

[00:57] <p6eval> pugs: OUTPUT«\\(undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef, undef…

[00:57] <diakopter> your mom is undef

[00:58] <timotimo> that is a non-insult

[00:58] <diakopter> r: my @a; @a[399][399] = 1; say @a[399][399]

[00:58] <p6eval> rakudo 1c9939: OUTPUT«1␤»

[00:58] <timotimo> r: oh? interesting!

[00:58] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/DuPXRyW1XP:1␤------> [32moh[33m⏏[31m? interesting![0m␤    expecting any of:␤        argument list␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement…

[00:58] <timotimo> ... :D

[00:58] <diakopter> r: term term

[00:59] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    term used at line 1␤␤»

[00:59] <diakopter> r: .term .term

[00:59] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row␤at /tmp/CAfb1PgmuN:1␤------> [32m.term [33m⏏[31m.term[0m␤    expecting any of:␤        method arguments␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statement m…

[00:59] <diakopter> there

[00:59] <timotimo> :D

[01:01] <diakopter> r: my @a; @a[0][1][2][3][4][5][6][7][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say @a

[01:01] <p6eval> rakudo 1c9939: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/1ejPZTUhEN:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/1ejPZTUhEN:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/1ejPZTUhE…

[01:01] <diakopter> r: my @a; @a[0][1][2][3][4][5][6][7] = 1; say @a

[01:02] <p6eval> rakudo 1c9939: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/IHqmZy4XWp:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/IHqmZy4XWp:1␤␤use of uninitialized value of type Any in string context  in block  at /tmp/IHqmZy4XW…

[01:02] <diakopter> *sigh*

[01:02] <timotimo> p: my @a; @a[0][1][2][3][4][5][6][7] = 1; say @a

[01:02] <p6eval> pugs: OUTPUT«                            1␤»

[01:02] <TimToady> r: my @a = [0 xx 400] xx 400; say @a[399][399].WHAT

[01:02] <colomon> n: my @a; @a[0][1][2][3][4][5][6][7] = 1; say @a

[01:02] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[01:02] <p6eval> niecza v24-34-g4f8f894: OUTPUT«(Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) (Any) 1␤»

[01:03] <TimToady> n: my @a = [0 xx 400] xx 400; say @a[399][399].WHAT

[01:03] <p6eval> niecza v24-34-g4f8f894: OUTPUT«(Int)␤»

[01:03] <diakopter> r: my @a; @a[0][1][2][3][4][5][6][7] = 1; say @a.perl

[01:03] <p6eval> rakudo 1c9939: OUTPUT«Array.new([Any, [Any, Any, [Any, Any, Any, [Any, Any, Any, Any, [Any, Any, Any, Any, Any, [Any, Any, Any, Any, Any, Any, [Any, Any, Any, Any, Any, Any, Any, 1]]]]]]])␤»

[01:03] <TimToady> timotimo: ^^

[01:03] <timotimo> using just @map and setting values on it un-pre-initialised will give me like 20 seconds speed-up

[01:04] <TimToady> that works too

[01:04] <timotimo> (still takes 180 seconds)

[01:04] <TimToady> boolean tests work find on undefineds :)

[01:04] <TimToady> *fine

[01:04] <diakopter> r: my @a; @a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say @a.perl

[01:04] <p6eval> rakudo 1c9939: OUTPUT«Array.new([[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]])␤»

[01:04] <diakopter> hee

[01:05] <TimToady> so why is only the outermost one Array.new()

[01:05] <diakopter> r: my $a; $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say $a.perl

[01:05] <p6eval> rakudo 1c9939: OUTPUT«[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]␤»

[01:05] <diakopter> no idea

[01:06] *** am0c joined
[01:06] <diakopter> r: my $a = []; $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say $a.perl

[01:06] <p6eval> rakudo 1c9939: OUTPUT«[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]␤»

[01:06] <TimToady> trying to indicate flattenable, I guess

[01:06] <timotimo>  r: my $a; $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][1][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say $a.perl

[01:06] <p6eval> rakudo 1c9939: OUTPUT«[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1]]]]]]]]]]]]]], [[[[[[[[[[[[[[1]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]␤»

[01:06] <timotimo> no longer an array.new

[01:07] <diakopter> r: my $a = (); $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say $a.perl

[01:07] <p6eval> rakudo 1c9939: OUTPUT«Cannot modify an immutable value␤  in sub infix:<=> at src/gen/CORE.setting:12590␤  in block  at src/gen/CORE.setting:1533␤  in sub infix:<=> at src/gen/CORE.setting:12590␤  in block  at src/gen/CORE.setting:1533␤  in sub infix:<=> at src/gen/CORE.setting:12590␤  i…

[01:07] <timotimo> that does make some sense

[01:08] <diakopter> r: my $a = \[]; $a[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0] = 1; say $a.perl

[01:08] <p6eval> rakudo 1c9939: OUTPUT«Capture.new( list => ([[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],).list, hash => EnumMap.new())␤»

[01:08] <diakopter> r: my $a = \$a; $a[0] = 1; say $a.perl

[01:08] <p6eval> rakudo 1c9939: OUTPUT«Cannot assign to a readonly variable or a value␤  in block  at /tmp/u7QSE5HcUT:1␤␤»

[01:09] <diakopter> whatevs

[01:10] <diakopter> r: my $a = \(); $a[0] = 1; say $a.perl

[01:10] <p6eval> rakudo 1c9939: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/hIlrbbcUnp:1␤␤»

[01:12] <diakopter> r: my $a = \$a; say $a.perl # why does it timeout before recurse overflow

[01:12] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[01:12] <timotimo> tail call optimisation? ;))

[01:12] <timotimo> nope.

[01:13] <diakopter> hm, I guess it could make its own stack

[01:13] <diakopter> np: my $a = \$a; say $a.perl # haha

[01:14] <timotimo> haha?

[01:14] <diakopter> oh. apparently pn: and np: don't work

[01:14] <diakopter> pn: die

[01:15] <diakopter> p: my $a = \$a; say $a.perl

[01:15] <p6eval> pugs: OUTPUT«\undef␤»

[01:15] <diakopter> n: my $a = \$a; say $a.perl

[01:15] <p6eval> niecza v24-34-g4f8f894: OUTPUT«(timeout)»

[01:15] <diakopter> pugs++

[01:15] <timotimo> so i'm not likely going to get something more performant without compromising code legibility

[01:17] <TimToady> huh, I was gonna wait on http://rosettacode.org/wiki/24_game/Solve#Perl_6 till there was .permutations built-in, but I see thundergnat went ahead and did it anyway :D

[01:17] <diakopter> I don't think a bit array [nicely abstracted] would make it less legible. also, I have no idea whether it would be more efficient.

[01:18] <TimToady> my bit @a[400][400] is specced, just not implemented

[01:19] <diakopter> how about unary represented in binary?

[01:19] <timotimo> may be more efficient. may not be faster. who knows that now :(

[01:19] <timotimo> n: my Array of Array of Int @map;

[01:19] <p6eval> niecza v24-34-g4f8f894: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Coercive declarations NYI at /tmp/QAFsg7zB8v line 1:␤------> [32mmy Array of Array of Int[33m⏏[31m @map;[0m␤␤Potential difficulties:␤  @map is declared but not used at /tmp/QAFsg7zB8v line 1:␤------> [32mmy Array of Arr…

[01:20] <timotimo> :(

[01:20] <diakopter> p: my unary $stuff; say $stuff.perl

[01:20] <p6eval> pugs: OUTPUT«\unary()␤»

[01:20] <diakopter> o_O

[01:20] <TimToady> r: my $b = Buf.new(0 xx 40); $b[20] = 1; say $b

[01:20] <p6eval> rakudo 1c9939: OUTPUT«Cannot modify an immutable value␤  in block  at /tmp/xmBeqPnP00:1␤␤»

[01:20] <TimToady> ooh, rakudobug

[01:20] <diakopter> someone said Buf was immutable?

[01:20] <diakopter> or was that buf

[01:20] <TimToady> Bufs are supposed to be mutable

[01:21] <diakopter> which one is fixed-size?

[01:21] <diakopter> either?

[01:21] <diakopter> r: my $b = Buf.new(0 xx 0); $b[20] = 1; say $b

[01:22] <p6eval> rakudo 1c9939: OUTPUT«Cannot take substr outside string␤  in method at_pos at src/gen/CORE.setting:7358␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1403␤  in block  at /tmp/Qd9Af9yFAr:1␤␤»

[01:22] <diakopter> ...

[01:22] <diakopter> r: my $b = Buf.new(0 x 0); $b[20] = 1; say $b

[01:22] <p6eval> rakudo 1c9939: OUTPUT«This type cannot unbox to a native integer␤  in method set_codes at src/gen/CORE.setting:7350␤  in method new at src/gen/CORE.setting:7342␤  in block  at /tmp/orWNkDB0f_:1␤␤»

[01:22] <diakopter> *headdesk*

[01:23] <diakopter> r: my $b = Buf.new(-1); $b[20] = 1; say $b

[01:23] <p6eval> rakudo 1c9939: OUTPUT«Invalid character for UTF-8 encoding␤␤  in method set_codes at src/gen/CORE.setting:7350␤  in method new at src/gen/CORE.setting:7342␤  in block  at /tmp/BKa8CvABEx:1␤␤»

[01:23] <diakopter> *headfloor*

[01:24] <TimToady> UTF-8?!?!

[01:24] * diakopter tries to stop rotfl

[01:25] * geekosaur wonders if it's trying to print it as bytes or something

[01:26] <TimToady> r: my $b = Buf.new(-1);

[01:26] <p6eval> rakudo 1c9939: OUTPUT«Invalid character for UTF-8 encoding␤␤  in method set_codes at src/gen/CORE.setting:7350␤  in method new at src/gen/CORE.setting:7342␤  in block  at /tmp/j_tvgAP6K5:1␤␤»

[01:26] <TimToady> no

[01:26] <diakopter> r: my $b = Buf.new(0-(2**63 - 1)); say $b.elems

[01:26] <p6eval> rakudo 1c9939: OUTPUT«1␤»

[01:27] * diakopter gasps for air

[01:27] <TimToady> r: my $b = Buf.new(255);

[01:27] <p6eval> rakudo 1c9939:  ( no output )

[01:27] <timotimo> i don't know what's what any more

[01:34] * geekosaur eyes latest "bug"

[01:35] <diakopter> oh.

[01:35] <diakopter> the args to Buf.new are the elements..

[01:35] <diakopter> ergh

[01:36] <timotimo> yeah, i was confused about your confusion

[01:37] <diakopter> r: my $a = []; $a[999999999] = 1; my $b = Buf.new(|$a); say $b.elems

[01:37] <p6eval> rakudo 1c9939: OUTPUT«(signal SEGV)»

[01:37] <diakopter> finally... a real bug

[01:38] <diakopter> r: my $a = []; $a[999999999] = 1; my $b = Buf.new(|$a);

[01:38] <timotimo> hehe

[01:38] <p6eval> rakudo 1c9939: OUTPUT«(signal SEGV)»

[01:38] <timotimo> so, craptons of zeros, then a one

[01:38] <timotimo> and it'll break

[01:38] <diakopter> r: my $a = []; $a[2**31 - 1] = 1; my $b = Buf.new(|$a);

[01:39] <p6eval> rakudo 1c9939: OUTPUT«ResizablePMCArray: Can't resize!␤  in block  at src/gen/CORE.setting:6335␤  in block  at /tmp/r8IBzgCpKj:1␤␤»

[01:39] <diakopter> oh dear.

[01:39] <diakopter> I sense another fuzzing attack coming on.

[01:42] <TimToady> well, Buf is really only about half implemented, so it's kinda unfair...

[01:42] <diakopter> actually the Buf golfs away

[01:44] *** lizmat left
[01:45] *** Liz_ joined
[01:59] *** sqirrel_ joined
[02:02] *** sqirrel__ left
[02:18] <diakopter> r: my $a = []; $a[240731133] = 1;

[02:18] <p6eval> rakudo 1c9939: OUTPUT«(signal SEGV)»

[02:18] <diakopter> r: my $a = []; $a[240731132] = 1;

[02:18] <diakopter> golfed

[02:18] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[02:19] * diakopter has no clue about the significance of that threshold, and I'm too braindead to imagination anything

[02:20] <diakopter> r: my Array[0] $a;

[02:20] <p6eval> rakudo 1c9939: OUTPUT«Cannot look up attributes in a type object␤current instr.: 'gimme' pc 262278 (src/gen/CORE.setting.pir:119028) (src/gen/CORE.setting:5897)␤called from Sub 'sink' pc 270805 (src/gen/CORE.setting.pir:122461) (src/gen/CORE.setting:6180)␤called from Sub 'MAIN' pc 381 (…

[02:21] <diakopter> ok that's just incomprehensible

[02:21] <sorear> i would guess rakudo is allocating slightly more memory than it needs to, to avoid reallocations

[02:22] <sorear> and 240731133 is just the point where some internal variable goes negative

[02:22] <sorear> since the underlying objects in a QRPA are pointers, and p6eval runs on an I32LP64 machine

[02:22] <pmichaud> TimToady: shall I submit the "Parallelism in Perl 6" talk to yapc::na?  Want me to include your name on it?

[02:23] <sorear> r: 2**31 / 8 # number of pointers needed to overflow an int

[02:23] <p6eval> rakudo 1c9939:  ( no output )

[02:23] <sorear> r: say 2**31 / 8 # number of pointers needed to overflow an int

[02:23] <p6eval> rakudo 1c9939: OUTPUT«268435456␤»

[02:23] <diakopter> p: my $a = []; $a[240731133] = 1;

[02:23] <p6eval> pugs: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[02:24] <sorear> pmichaud: isn't qrpa yours?  can you comment on my theory?

[02:24] <pmichaud> sorear: I wrote qrpa, yes... but a lot of it is cargo-culted from RPA

[02:24] <pmichaud> your theory is very sound to me, though.

[02:25] <pmichaud> it wouldn't surprise me if large arrays fail in bad ways at this point

[02:26] <TimToady> pmichaud: yes, please, and yes, please, and thank you

[02:26] <pmichaud> TimToady: will do, ty!

[02:26] <pmichaud> sorear: on the other hand, RPA doesn't seem to have a problem with that.

[02:26] <pmichaud> oh, wait, I might've entered it wrong

[02:28] <pmichaud> https://gist.github.com/pmichaud/5174660

[02:28] <diakopter> p: my $a = []; $a[1016809] = 1;

[02:28] <p6eval> pugs: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[02:29] <diakopter> p: my $a = []; $a[1016808] = 1;

[02:29] <p6eval> pugs:  ( no output )

[02:29] * diakopter doesn't know why it uses the stack

[02:30] <diakopter> sorear: could ghc be recursing for each item? o_O

[02:30] <pmichaud> nqp:  my @a := [];  @a[240731133] := 1;  say('alive');

[02:30] <p6eval> nqp: OUTPUT«(timeout)»

[02:30] <diakopter> heh

[02:30] <pmichaud> nqp: my @a := [];  @a[20] := 1;  say('alive');

[02:30] <p6eval> nqp: OUTPUT«alive␤»

[02:31] <pmichaud> nqp: my @a := [];  @a[2407311] := 1;  say('alive');

[02:31] <p6eval> nqp: OUTPUT«alive␤»

[02:31] <pmichaud> nqp: my @a := [];  @a[240731133] := 1;  say('alive');

[02:31] <p6eval> nqp: OUTPUT«(timeout)»

[02:31] <pmichaud> we're probably pounding on poor feather[0-9] a fair bit  :-/

[02:31] <diakopter> nqp-jvm: my $a := [];  $a[240731133] := 1;  say('alive');

[02:32] <p6eval> nqp-jvm: OUTPUT«java.lang.OutOfMemoryError: Java heap space␤    at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.set_size_internal(VMArrayInstance.java:83)␤     at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.bind_pos_boxed(VMArrayInstance.java:102)␤       at

[02:32] <p6eval> ..org.perl6.nqp.runtime.Ops.bindpos(Ops.jav…

[02:32] <diakopter> nqp-jvm: my $a := [];  $a[240731133000000000] := 1;  say('alive');

[02:32] <p6eval> nqp-jvm: OUTPUT«java.lang.NegativeArraySizeException␤   at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.set_size_internal(VMArrayInstance.java:83)␤     at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.bind_pos_boxed(VMArrayInstance.java:102)␤       at

[02:32] <p6eval> ..org.perl6.nqp.runtime.Ops.bindpos(Ops.java:1541)…

[02:32] <diakopter> haha

[02:33] <diakopter> uints anyone?

[02:33] <geekosaur> I don't think java has unsigned types?

[02:33] *** davidagain joined
[02:34] <diakopter> geekosaur: you're right

[02:34] <timotimo> hehe whoops

[02:35] <lue> Apparently the solution is "use a bigger integer type"

[02:36] <diakopter> nqp-jvm: my $a := [];  $a[0.Int] := 1;  say('alive');

[02:36] <p6eval> nqp-jvm: OUTPUT«Invocant must be an object␤  in <anon>␤  in process_args␤  in <anon>␤  in <anon>␤  in compile_op␤  in as_jast␤  in as_jast␤  in <anon>␤  in <anon>␤  in <anon>␤  in compile_op␤  in as_jast␤  in as_jast␤  in as_jast_clear_bindval␤  in compile_var␤  in as_jast␤  in as_jast␤…

[02:36] <diakopter> nqp: my $a := [];  $a[0.Int] := 1;  say('alive');

[02:36] <p6eval> nqp: OUTPUT«Method 'Int' not found for invocant of class 'Integer'␤current instr.: '' pc 62 ((file unknown):44) (/tmp/kMM1zv4CQx:1)␤»

[02:36] <diakopter> nqp-jvm compiler bug

[02:39] <diakopter> nqp-jvm: my $a := [];  $a[9**9**2] := 1; say(nqp::elems($a))

[02:39] <p6eval> nqp-jvm: OUTPUT«java.lang.NegativeArraySizeException␤   at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.set_size_internal(VMArrayInstance.java:83)␤     at org.perl6.nqp.sixmodel.reprs.VMArrayInstance.bind_pos_boxed(VMArrayInstance.java:102)␤       at

[02:40] <p6eval> ..org.perl6.nqp.runtime.Ops.bindpos(Ops.java:1541)…

[02:40] <diakopter> nqp-jvm: my $a := [];  $a[9**9**9] := 1; say(nqp::elems($a))

[02:40] <p6eval> nqp-jvm: OUTPUT«VMArray: Can't resize to negative elements␤  in <anon>␤  in <anon>␤  in eval␤  in evalfiles␤  in command_eval␤  in command_line␤  in MAIN␤  in <anon>␤  in <anon>»

[02:40] <diakopter> O_O

[02:40] * diakopter clueless, yet again

[02:41] <pmichaud> TimToady: submitted talk... will keep you posted on developments.

[02:41] <pmichaud> I'm afk again for a while.

[02:42] <pmichaud> a reminder that we'd really like to see more p6 talks at yapc... please submit if you haven't already :)

[02:42] <diakopter> nqp: my $a := [];  $a[FFFFFFFFFFFFFFFFFFF] := 1; say(nqp::elems($a))

[02:42] <p6eval> nqp: OUTPUT«1␤»

[02:44] <lue> I found that JDK 8 is going to have unsigned int arithmetic (but not actual separate types), and there's also this implementation of unsigned ints: https://github.com/jOOQ/jOOU (in case an nqp-jvm dev is interested)

[02:45] <diakopter> nqp: say($_[FFFFFFFFFFFFFFFFFFFFFFFFFFF])

[02:45] <p6eval> nqp: OUTPUT«Null PMC access in get_pmc_keyed_int()␤current instr.: '' pc 108 ((file unknown):166648018) (/tmp/Uko6rmQ45u:1)␤»

[02:45] <diakopter> a roll is beneath me

[02:45] <diakopter> nqp: say($_[0])

[02:45] <p6eval> nqp: OUTPUT«Null PMC access in get_pmc_keyed_int()␤current instr.: '' pc 52 ((file unknown):43) (/tmp/7eRK01Rl6r:1)␤»

[02:46] <diakopter> nqp: say($_.WHAT)

[02:46] <p6eval> nqp: OUTPUT«Can only use get_what on a SixModelObject␤current instr.: '' pc 43 ((file unknown):39) (/tmp/xdCEgNK6OP:1)␤»

[02:46] <diakopter> oh.

[02:46] <diakopter> whatevs...

[02:47] <diakopter> nqp-jvm: say($_.WHAT)

[02:47] <p6eval> nqp-jvm: OUTPUT«Lexical '$_' not found␤  in <anon>␤  in <anon>␤  in eval␤  in evalfiles␤  in command_eval␤  in command_line␤  in MAIN␤  in <anon>␤  in <anon>»

[02:47] <diakopter> \o/  <-- that's exasperation, not celebration, in this case

[02:48] <diakopter> nqp-jvm: say(_.WHAT)

[02:48] <p6eval> nqp-jvm: OUTPUT«␤»

[02:48] <diakopter> wat.

[02:48] <diakopter> nqp: say(_.WHAT)

[02:48] <p6eval> nqp: OUTPUT«␤»

[02:48] <diakopter> well, at least they're consistent

[02:59] *** vaelxon joined
[03:00] *** sqirrel__ joined
[03:04] *** sqirrel_ left
[03:04] *** rindolf joined
[03:05] *** orafu left
[03:05] *** OuLouFu joined
[03:05] *** OuLouFu is now known as orafu

[03:13] *** araujo left
[03:25] *** census joined
[03:27] <diakopter> bought my ticket to yapc;;na: submitted a talklet

[03:27] <census> diakopter++

[03:29] <raiph> diakopter++ # that's some "talklet" ;) (i'm subscribed to yapcna planning list so saw your submission)

[03:34] * colomon needs to accomplish a lot of contract work in the next few weeks to have a hope of affording YAPC::NA.

[03:41] <sorear> how soon do I need to buy a ticket?  i'm sure I can afford it but I am in a huuuge time crunch right now

[03:41] * colomon has no idea.

[03:41] <diakopter> the current "early bird" price is $80. dunno when it rises

[03:42] <diakopter> flights from SFO are pretty cheap right now, it seems

[03:42] <sorear> i'll assume that was directed at me

[03:43] <sorear> SAN-SFO-Austin is a fairly substantial detour

[03:43] <sorear> oh wait, you live around SFO yourself

[03:43] <diakopter> yes and no; I wasn't suggesting you go through SFO :P

[03:56] *** xinming_ joined
[03:59] *** xinming left
[04:00] *** am0c left
[04:01] <census> diakopter: SFO is the best, isn't it? :)

[04:02] <diakopter> eh...

[04:02] <diakopter> #@(@*@%%^$%*(#@(@$*%(@#*   Facebook, Google, and Apple have driven up rents $1000/mo in the past 4 years

[04:03] <diakopter> ...not to mention buying up all the commercial real estate in that region; grrr

[04:03] <sorear> diakopter: are you describing SFO or San Francisco?

[04:03] <diakopter> oh.  heh, oops.

[04:04] <census> I did not say bay area!  I said SFO airport!!

[04:04] <diakopter> I guess I assumed census was talking about the area 'cuz I couldn't imagine anyone saying the airport is the best

[04:05] <census> i love the international terminal

[04:05] <census> don't you?

[04:05] <diakopter> oh; that's swank, yes

[04:05] <census> sfo >> oakland!

[04:05] <census> geez

[04:05] <census> but are you telling me that you are a bay area resident who does not think that the bay area is the best place in the entire world??

[04:06] <diakopter> uhm. 

[04:07] <diakopter> :) I grew up in Houston

[04:09] <sorear> haven't been to SFO.  int'l airports, by how pleasant my terminal stays were: LUX > FRA > SAN > ORD > LHR > LAX > TXL

[04:10] *** census left
[04:10] <diakopter> tip: if you're driving to SFO, always enter through the international terminal then walk to whatever terminal you need, 'cuz the security line there is always nonexistent compared to hours everywhere else

[04:13] *** PacoAir left
[04:16] *** census joined
[04:24] *** _jaldhar joined
[04:25] *** _jaldhar is now known as jaldhar

[04:29] *** stevan joined
[04:30] * sorear just checked email.  Um.

[04:31] *** stevan_ left
[04:33] <diakopter> census: are you in the bay area too?

[04:33] <census> NO

[04:33] <diakopter> ah, New Orleans

[04:33] <census> that is not what i meant

[04:33] <census> i meant capital n o

[04:33] <diakopter> I know :P

[04:33] <census> as in no way

[04:36] <census> i just thought everybody in the world loved bay area

[04:38] <sorear> where are you?

[04:42] <census> working on a perl script :)

[04:45] *** preflex_ joined
[04:47] *** preflex left
[04:47] *** preflex_ is now known as preflex

[04:52] *** vaelxon left
[05:16] *** ggoebel_ left
[05:16] *** ggoebel_ joined
[05:17] *** kivutar joined
[05:48] *** isBEKaml joined
[05:50] <isBEKaml> OHHAI, #perl6!

[05:51] *** mavcunha left
[05:52] *** renormalist joined
[05:52] <diakopter> isBEKaml: 'sup

[05:53] *** kaare__ joined
[05:54] *** mavcunha joined
[05:54] <isBEKaml> diakopter: Currently wrestling with an R* build for slackware for lack of proper destdir support. :)

[05:56] <isBEKaml> what I have works, but module installs are F'ed up. :/

[05:56] <diakopter> via panda?

[05:56] <isBEKaml> no, via makefile after rakudo-install step. 

[05:56] <diakopter> or the ones bundled?

[05:57] <isBEKaml> (the ones bundled) - library locations are hardcoded into parrot-config which is looked up by modules-install(IIUC)

[05:58] <isBEKaml> so, I'm thinking of fiddling with configure step or break the installs into two steps, one for the compiler and another for modules. 

[06:00] *** skids left
[06:09] <isBEKaml> Okay, the installs themselves are fine, it's @*INC :|

[06:09] <isBEKaml> http://sprunge.us/gDZV

[06:11] <isBEKaml> the /tmp/package-rakudo-star is the sandbox folder used for building the R* slackware package.

[06:15] <isBEKaml> Output from parrot_config --dump: http://sprunge.us/jERb

[06:15] <isBEKaml> library install locations are all wrong. :/

[06:16] <isBEKaml> /tmp/SBo/ should never be seen. I'm not sure how to proceed from here. 

[06:19] <isBEKaml> tadzik, moritz: please backlog. If you know of a solution, please let me know. 

[06:20] <diakopter> is it correct that $(PERL) appears in tht output?

[06:21] <isBEKaml> diakopter: I see the same on cygwin install too. 

[06:27] <isBEKaml> Here's my script so far: https://raw.github.com/svatsan/RakudoStar-SlackBuilds/master/rakudo-star/rakudo-star.SlackBuild

[06:27] *** isomorphisms left
[06:29] <diakopter> anyone around here a node user?

[06:32] <sorear> meee

[06:32] <sorear> hi isBEKaml

[06:32] <isBEKaml> hello, sorear 

[06:32] <diakopter> sorear: have you looked at the new Streams api in 0.10?

[06:37] <sorear> no.

[06:38] <sorear> 2/3 of our code is streams definitions, so i'm going to conjecture that we'll be on 0.9 forever

[06:38] <diakopter> the announcement blog entry talks it up quite a lot; sounds impressively improved

[06:38] <diakopter> it has a backcompat shim

[06:46] * diakopter stumbles across Microsoft's node.js hosting cloud thing; the pricing is nothing short of absurd

[07:06] *** census left
[07:14] *** spider-mario joined
[07:30] *** rindolf left
[07:30] *** rindolf joined
[07:47] *** rindolf left
[07:47] *** araujo joined
[07:47] *** araujo left
[07:47] *** araujo joined
[07:47] *** SamuraiJack joined
[07:47] *** rindolf joined
[07:52] *** mberends joined
[07:52] *** SamuraiJack_ joined
[07:53] *** SamuraiJack left
[07:59] *** rindolf left
[07:59] *** rindolf joined
[08:09] *** FROGGS joined
[08:43] <isBEKaml> Anyone here a list admin on p6c?

[08:47] *** xinming_ left
[08:49] *** xinming joined
[08:52] *** je joined
[08:53] *** je left
[08:59] *** isBEKaml left
[09:01] *** xinming left
[09:05] *** xinming joined
[09:19] <jnthn> morning o/

[09:19] <FROGGS> morning jnthn 

[09:20] <jnthn> FROGGS: Your NFA usage causes the NFA evaluator to buffer overflow. ;) I fixed it yesterday :)

[09:20] <jnthn> *caused

[09:20] <FROGGS> ohh, wow

[09:20] <FROGGS> thanks, will pull in a sec

[09:20] <jnthn> FROGGS: Surprised you didn't see heap corruption though... :)

[09:21] <jnthn> It expected that [0] of @!states had as many elements as you have fates.

[09:21] <FROGGS> jnthn: I dont the a commit in nom

[09:21] <jnthn> FROGGS: The NFA evaluator is in the NQP reop

[09:21] <FROGGS> ahh, I see

[09:22] <jnthn> Anyway, nothing needs doing, unless you want to review it. :)

[09:22] <jnthn> Mostly noting it in case you'd been trying to play hunt the SEGV

[09:22] <FROGGS> surely I wanna see what you did :o)

[09:25] <sorear> morning jnthn

[09:27] <jnthn> ohhai

[09:31] *** isBEKaml joined
[09:31] <diakopter> jnthn: did you see the segv in the backlog?

[09:32] <jnthn> > my $a = []; $a[240731133] = 1;

[09:32] <jnthn> 1

[09:32] <jnthn> Is p6eval on a 32-bit machine?

[09:32] <diakopter> think so

[09:35] <jnthn> heh, the process where I did that has now allocated 2 gigs :)

[09:36] <jnthn> .oO( did it quickly at least )

[09:37] <FROGGS> jnthn: btw, that are my local changes https://gist.github.com/FROGGS/d2c01ff6ada9efe61e07 (still need to switch to Perl6::P6Regex, and have a nicer way for :i)

[09:37] <FROGGS> jnthn: you said I need something like Compiler.eval but jump into regexes instead of comp_unit?

[09:39] <jnthn> I guess what I'm curious about is exactly what the language is meant to be 

[09:40] <jnthn> r: my $x = 'abc { say 42 } def'; say 'abcdef' ~~ /<$x>/

[09:40] <p6eval> rakudo 1c9939: OUTPUT«42␤｢abcdef｣␤␤»

[09:40] <jnthn> I wonder if the spec agrees that should work

[09:41] <FROGGS> :/

[09:42] <jnthn> If so then yeah, what we're doing is really parsing Perl 6, just starting out in the regex slang. But in that case we still need all the usual setup in place to handle nested blocks.

[09:43] <jnthn> I don't immediately find and S05 ruling on that

[09:43] <jnthn> *an

[09:44] <jnthn> bbi10

[09:45] *** Liz_ left
[09:46] *** Liz_ joined
[09:46] *** Liz_ is now known as lizmat

[09:47] *** lizmat left
[09:47] *** spider-mario left
[09:49] <dalek> panda/p6prove: e9d6331 | tadzik++ | / (7 files):

[09:49] <dalek> panda/p6prove: First shot at own-dogfooding prove

[09:49] <dalek> panda/p6prove: review: https://github.com/tadzik/panda/commit/e9d6331a64

[09:50] <tadzik> testing welcome

[09:50] <isBEKaml> hello, tadzik 

[09:50] <tadzik> hello isBEKaml 

[09:51] <isBEKaml> did you see the backlog about issues in packaging R* (with modules)?

[09:51] <tadzik> yeah. I don't know where did this sbo come from

[09:51] <tadzik> are you using some external installer, like your linux distro package manager?

[09:52] <isBEKaml> This is for building R* packages on Slackware.

[09:53] <tadzik> is it possible that this tool invents this path?

[09:53] <isBEKaml> It goes like this: Slackware uses makepkg for generating packages - simply copying over all files from a predefined sandbox location(or folder), using relative path mechanisms to compress all files into a final .txz or .tgz package. 

[09:54] <isBEKaml> My problem is, the library installation paths are all absolute paths - they all point to temporary sandbox locations, which is wrong. 

[09:54] <isBEKaml> I got all of that info from parrot_config --dump

[09:55] *** davidagain left
[09:56] <isBEKaml> o.O(If I'm incoherent, this is not the first time :| )

[09:58] <tadzik> yeah, that's one of the problems; the installation is not relocatable

[09:58] <tadzik> so you can't install it in one location and then move it elsewhere

[09:58] <tadzik> unless you're in fakeroot, maybe

[09:59] <isBEKaml> tadzik: this explains the build and install process: http://www.slackwiki.com/Building_A_Package

[10:01] <isBEKaml> tadzik: IOW, doesn't respect --prefix and --destdir? :)

[10:01] <tadzik> it's possible

[10:08] <isBEKaml> It's all hardcoded in parrot_config :(

[10:11] <sorear> isBEKaml: are you still looking for a mailing list admin?

[10:12] <isBEKaml> sorear: no, it's handled. 

[10:25] <isBEKaml>  /quit

[10:25] *** isBEKaml left
[10:52] <masak> good noon, #perl6

[10:52] <FROGGS> hi masak 

[10:54] <jnthn> o/ masak

[10:55] <jnthn> r: (1..16).grep({last if $_ % 5 == 0; $_ % 2 == 0});

[10:55] <p6eval> rakudo 1c9939:  ( no output )

[10:55] <jnthn> Does anybody get a segfault at exit running the above?

[10:55] *** nyuszika7h left
[10:55] * jnthn is guessing it's just in md-nqp that it's happening...

[10:56] <masak> sorry for spamming RT with private mail. :( I was tired, and the brain was apparently running on autopilot, picking the most common recipient I type into Gmail.

[10:56] <FROGGS> jnthn: no

[10:56] <jnthn> OK

[10:56] <jnthn> Hmmm.

[10:57] <jnthn> .oO( an unexpected downside of being Rakudo's leading bug filer... )

[10:59] <FROGGS> masak: is it something interesting that I have to read? :P

[11:01] <masak> no, it's just an email that should have gone to my wife, not to RT. :(

[11:01] <masak> please ignore.

[11:01] <FROGGS> will do

[11:05] *** nyuszika7h joined
[11:06] <sorear> good morning masak.

[11:06] <sorear> masak: diakopter was very proactive and has already gotten it purged from nntp.perl.org and rt.perl.org

[11:09] <sorear> I however received a prompt copy, and not being in the best mental state myself spent a not insignificant amount of time trying to interpret the message as an allegory for some Rakudo problem

[11:18] *** Chillance joined
[11:20] *** FROGGS left
[11:22] * jnthn accidentally fixes a Rakudo bug while trying to hunt down the exit segfault...

[11:24] *** sqirrel__ left
[11:24] *** kivutar left
[11:27] *** kivutar joined
[11:31] <sorear> sleep&

[11:39] *** sjn joined
[11:44] *** kivutar left
[11:45] *** kivutar joined
[11:50] <jnthn> walk &

[11:54] <mberends> transatlantic sleepwalk!

[11:56] *** kurahaupo joined
[11:59] *** kivutar left
[12:02] *** kurahaupo left
[12:03] *** kivutar joined
[12:04] <hoelzro> ahoy #perl6 fork

[12:04] <hoelzro> *folk

[12:05] <hoelzro> so I'm trying to write a Perl 6 POSIX module, and I'm not sure how to call my module's functions

[12:05] <hoelzro> I have module POSIX { sub getuid() is native { ... } } in POSIX.pm

[12:06] <hoelzro> and if I add is export, I can call getuid()

[12:06] <hoelzro> but POSIX::getuid() doesn't work. Did the syntax for calling subs in modules change?

[12:18] <colomon> I can verify that behavior.   but I don't think I ever tried to use a full path for an exported sub before.  hmm...

[12:21] *** not_gerd joined
[12:21] <not_gerd> o/

[12:21] * not_gerd hands hoelzro an 'our'

[12:21] * not_gerd leaves again

[12:21] *** not_gerd left
[12:21] <moritz> what not_gerd said. Subs are lexical by default in Perl 6.

[12:22] <hoelzro> ahhhhh

[12:22] <hoelzro> thank you!

[12:22] <hoelzro> can there be an analysis tool that detects when a my sub is never called?

[12:23] <hoelzro> also, is there a metamethod for iterating over a module's contents? like $obj.^methods?

[12:23] <hoelzro> I looked in ModuleHOW, but to no avail

[12:27] <jnthn> ModuleName.WHO gets you a Stash

[12:27] <hoelzro> ah ha

[12:28] <jnthn> ModuleName::foo() is really ModuleName::<&foo>() which is really ModuleName.WHO<&foo>

[12:28] <hoelzro> so let's say I want to throw exceptions on failure for my POSIX calls.  Should I call my exception class X::POSIX, POSIX::X::Something, ?

[12:28] <jnthn> X:: first seems to be the trend, afaict

[12:29] <hoelzro> ok

[12:33] * hoelzro has working fork o/

[12:34] <jnthn> fork yeah!

[12:35] <hoelzro> what would be "Perl 6"-y? returning an error value, or throwing an exception on failure?

[12:36] <jnthn> Using fail(...)

[12:37] <hoelzro> so much to re-learn =(

[12:38] *** SamuraiJack_ left
[12:38] *** SamuraiJack_ joined
[12:44] *** snuffles left
[12:44] *** snuffles joined
[12:45] *** snuffles left
[12:46] *** snuffles joined
[13:02] *** PacoAir joined
[13:10] <masak> sorear: hm, I didn't intent it as an allegory. but when you put it like that, that wouldn't have been completely unlike me.

[13:12] <grondilu> rn: my (\k, \n) = 1, 2; say n-k;

[13:12] <p6eval> niecza v24-34-g4f8f894: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'n-k' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home…

[13:12] <p6eval> ..rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤    n-k used at line 1␤␤»

[13:12] *** domidumont joined
[13:12] <grondilu> rn: my (\k, \n) = 1, 2; say n - k;

[13:12] <p6eval> niecza v24-34-g4f8f894: OUTPUT«1␤»

[13:12] <p6eval> ..rakudo 1c9939: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling op call: Error while compiling op call: Null PMC access in find_method('handle')␤»

[13:12] <jnthn> RT'd already

[13:13] <jnthn> I don't actually know how to fix that

[13:13] <jnthn> Because I'd understood my \foo = blah; to be an initilization/declaration

[13:13] <jnthn> And you bind the name directly

[13:13] <jnthn> There's no container

[13:14] <jnthn> And we compile ($foo, $bar) = ... down to normal list assignment iirc.

[13:15] <jnthn> I was about to catch/forbid it, and then I saw Niecza actually makes it work.

[13:15] <jnthn> n: my ($a, $b) = (my (\k, \n) = 1, 2);

[13:15] <p6eval> niecza v24-34-g4f8f894: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/iDbVY6YNXH line 1:␤------> [32mmy [33m⏏[31m($a, $b) = (my (\k, \n) = 1, 2);[0m␤  $b is declared but not used at /tmp/iDbVY6YNXH line 1:␤------> [32mmy [33m⏏[31m($a, $b) = (my (\k, \n) = 1…

[13:16] <jnthn> n: my ($a, $b) = (my (\k, \n) = 1, 2); say k; $a = 42; say k;

[13:16] <p6eval> niecza v24-34-g4f8f894: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/RC6hMHbIPE line 1:␤------> [32mmy [33m⏏[31m($a, $b) = (my (\k, \n) = 1, 2); say k; [0m␤␤1␤1␤»

[13:16] <jnthn> n: my $a := (my (\k, \n) = 1, 2)[0]; say k; $a = 42; say k;

[13:16] <p6eval> niecza v24-34-g4f8f894: OUTPUT«1␤42␤»

[13:17] <jnthn> ...oops. :)

[13:17] <jnthn> n: my $a := (my (\k, \n) = 1, 2)[0]; say k; k = 42; say k;

[13:17] <p6eval> niecza v24-34-g4f8f894: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/BGV0866aOw line 1:␤------> [32mmy [33m⏏[31m$a := (my (\k, \n) = 1, 2)[0]; say k; k [0m␤␤1␤42␤»

[13:17] * jnthn needs to re-read the spec...

[13:19] <jnthn> hm, hm, it doesn't say in the bit on it in S06...

[13:19] <jnthn> Am I justly wildly misremembering that it has SSA-ish semantics?

[13:21] * masak .oO( wildly disremembering )

[13:21] <masak> jnthn: well, it does in the sense of "can only assign once".

[13:22] <jnthn> masak: So it's nieczabug that I was able to assign to it a second time?

[13:22] <jnthn> masak: Do you have a spec ref that actually says that, 'cus it's my recollection but I can't find the spec actually saying it...

[13:26] <masak> hold on, lemmecheck.

[13:26] * masak .oO( be of some use for once )

[13:26] <masak> :P

[13:26] <masak> me, that is. :)

[13:30] <jnthn> I had a panic at systemet today

[13:31] <jnthn> uw, ww 

[13:31] <masak> you're just doing that to be nice :P

[13:31] <jnthn> *uh. :)

[13:31] <masak> S06:1250: In any case, it's a raw reference to whatever was passed, with no commitment

[13:31] <masak> to structure or mutability.

[13:31] <jnthn> No, but anyway, I went to buy stout and it was all gone.

[13:31] <masak> so I guess \ vars aren't immutable.

[13:31] <jnthn> But turns out they'd just moved it :)

[13:31] <masak> oh phew :)

[13:32] <jnthn> I guess it is on-topic here given I turn beer into (Perl 6 implementation) code :P

[13:32] * masak .oO( "not one of my stoutest moments" )

[13:32] <masak> guess we'll have to explain "Systemet" to non-Swedes, too.

[13:32] <masak> see, we lock our alcohol into a special place.

[13:33] <jnthn> It's this place where you can buy beer at times the government see fit.

[13:33] <jnthn> To be fair, it has a good selection.

[13:34] <masak> yeah, it's not that bad actually.

[13:34] <masak> and what they don't have, you can usually order.

[13:34] <jnthn> I've lived in places where you could buy beer at any time of day, but if it's watery lager then, well, it's not quite such a win. :)

[13:34] * jnthn crosses his fingers and hopes he's about to find he has killed off the exit segfaults

[13:34] <masak> except for the Westvleteren, which listerally sold out in *7 seconds*!

[13:35] <jnthn> They had a HUGE yeti there today...aged in barrels. It was tempting but it cost 90 SEK for a pint bottle!

[13:35] <masak> I'd have bought that one :)

[13:36] <jnthn> I'm still thinking I shoulda

[13:36] <jnthn> Ah well, I don't think it'll disappear right away.

[13:36] * masak .oO( Yetis tend to stick around... oh wait )

[13:38] <dalek> nqp: 4fd9292 | jnthn++ | src/ (2 files):

[13:38] <dalek> nqp: Change the way we do invokewithcapture.

[13:38] <dalek> nqp: 

[13:38] <dalek> nqp: This avoids a bunch of nested runloops and all the problems that come

[13:38] <dalek> nqp: with them. Re-working this, once a tweak is done in Rakudo, gets rid

[13:38] <dalek> nqp: of the couple of exit-time SEGVs in the md-nqp branch.

[13:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4fd9292015

[13:39] <dalek> rakudo/md-nqp: ba99183 | jnthn++ | src/core/MapIter.pm:

[13:39] <dalek> rakudo/md-nqp: Fix LEAVE not firing on next/last in MapIter.

[13:39] <dalek> rakudo/md-nqp: 

[13:39] <dalek> rakudo/md-nqp: Done as an attempted/failed fix for something else.

[13:39] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/ba99183f75

[13:39] <dalek> rakudo/md-nqp: 706b65e | jnthn++ | src/binder/bind.c:

[13:39] <dalek> rakudo/md-nqp: Fixes to work with the invokewithcapture changes.

[13:39] <dalek> rakudo/md-nqp: 

[13:39] <dalek> rakudo/md-nqp: With this, there's just one spectest (not file, just test) that seems

[13:39] <dalek> rakudo/md-nqp: to be broken in this branch over nom.

[13:39] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/706b65e037

[13:40] <jnthn> r: multi foo() { LEAVE { say 'bye' }; say 'x' }; foo()

[13:40] <p6eval> rakudo 1c9939: OUTPUT«x␤»

[13:40] <jnthn> That's fixed in the branch too.

[13:41] <dalek> rakudo/md-nqp: 103481f | (Timo Paulssen)++ | src/core/Exception.pm:

[13:41] <dalek> rakudo/md-nqp: raise X::Method::NotFound even for '' methods.

[13:41] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/103481fff6

[13:41] <dalek> rakudo/md-nqp: 1c99395 | jonathan++ | src/core/Exception.pm:

[13:41] <dalek> rakudo/md-nqp: Merge pull request #117 from timo/typed_exc_empty_method

[13:41] <dalek> rakudo/md-nqp: 

[13:41] <dalek> rakudo/md-nqp: raise X::Method::NotFound even for '' methods.

[13:41] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/1c993950b9

[13:41] <dalek> rakudo/md-nqp: 539d953 | jnthn++ | src/core/Exception.pm:

[13:41] <dalek> rakudo/md-nqp: Merge branch 'nom' into md-nqp

[13:41] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/539d9536d3

[13:42] <jnthn> .oO( Good teamwork by jonathan++ and jnthn++! )

[13:44] <jnthn> Left to do: port the compile time multi-dispatch analysis to NQP, rip out remaining C-based multi-dispatch code, hunt the one remaining, evil, spectest regression.

[13:52] <jnthn> Also, while you can't quite do anything useful with this yet, it's still funny: https://gist.github.com/jnthn/5176489

[13:54] <arnsholt> That's fantastic! =D

[13:55] *** LlamaRider joined
[14:03] <masak> jnthn: you're our best dispatchee! :D

[14:06] *** Heather joined
[14:06] <jnthn> ;)

[14:06] <Heather> hi

[14:06] *** Chillance_ joined
[14:06] <jnthn> The missing thing to make it useful is a way to get ahold of the capture and so forth.

[14:06] <Heather> how to pass arguments to run ?

[14:07] <Heather> r: run <ls .>

[14:07] <p6eval> rakudo 1c9939: OUTPUT«run is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:2␤  in sub run at src/RESTRICTED.setting:8␤  in block  at /tmp/VQXXo_nCQI:1␤␤»

[14:07] <jnthn> run('notepad', 'README')

[14:07] <Heather> ah it is )

[14:08] <Heather> < > works fine here

[14:08] <jnthn> That did the Right Thing for me here

[14:08] <jnthn> As right as using Notepad ever is, anyway ;)

[14:10] *** Chillance left
[14:10] <Heather> I forget how to write not_ok in test

[14:11] <jnthn> nok I think.

[14:11] <jnthn> r: use Test; nok(1)

[14:11] <p6eval> rakudo 1c9939: OUTPUT«not ok 1 - ␤»

[14:11] <jnthn> yeah

[14:16] <Heather> ok

[14:18] <jnthn> .oO( was that a subtle pun... :) )

[14:23] *** Psyche^ joined
[14:26] *** Patterner left
[14:26] *** Psyche^ is now known as Patterner

[14:30] <Heather> tadzik: added simple test https://github.com/Heather/ignore/blob/master/t/01-ignore.t :)

[14:36] <LlamaRider> r: class A{}; class B { use A; };

[14:36] <p6eval> rakudo 1c9939: OUTPUT«===SORRY!===␤Could not find A in any of: /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/site/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.10.0-devel/languages/perl6/lib, /home/p6eva…

[14:36] <LlamaRider> Is that intended ? Is there a "one class per file" policy?

[14:37] <jnthn> use always means "load a module"

[14:37] <jnthn> You can have as many classes as you want in it.

[14:38] <jnthn> It's up to you if the path/filename of the module (as in, file of code) and the classes etc declared inside of that file are in any way related.

[14:39] <jnthn> So use A really means "look for an A.pm, load it, and import anything that it exports by default into the current lexical scope"

[14:40] *** SamuraiJack__ joined
[14:41] <hoelzro> I'm continuing work on my POSIX module; how can I set it up so that nothing is imported with 'use POSIX', but you can import functions like so: 'use POSIX <fork>'

[14:41] *** kivutar left
[14:41] <hoelzro> I currently have our sub fork() returns Int is export(:ALL) { ... }

[14:41] <jnthn> You can make your own tags with things like is export(:mything)

[14:42] <LlamaRider> jnthn++ ok, I see. Will need to refactor things more sanely then. And I guess putting class A::B in A/B.pm  and having a one class per file policy would induce sanity.

[14:43] <hoelzro> jnthn: but you can't import them one-by-one?

[14:43] *** SamuraiJack_ left
[14:44] <jnthn> hoelzro: Hm, good question. use Foo <bar> passes it as a positional argument to some custom EXPORT sub

[14:44] <hoelzro> is 'use Foo <bar>' not Perl 6-y?

[14:44] *** SamuraiJack__ left
[14:45] *** SamuraiJack__ joined
[14:46] <jnthn> So far as I can see from what's implemented, it isn't doing anything that lets you list the symbols you want, at least...

[14:46] <jnthn> If it were you'd probably have to say &bar anyway

[14:47] <hoelzro> I see

[14:47] <jnthn> oh, hmm

[14:48] <hoelzro> so for now I should implement EXPORT myself?

[14:50] * hoelzro will return later

[14:50] * jnthn wonders if moritz++ knows a bit more about how this works/should work :)

[14:54] <Heather> r: my $o = [2, 2]; $o >> { say . }

[14:54] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of >> to do right shift;  in Perl 6 please use +> or ~>␤at /tmp/2YmdznwQQk:1␤------> [32mmy $o = [2, 2]; $o >>[33m⏏[31m { say . }[0m␤»

[14:55] <Heather> r: my $o = [2, 2]; $o>> { say . }

[14:55] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of >> to do right shift;  in Perl 6 please use +> or ~>␤at /tmp/URs35nWPlh:1␤------> [32mmy $o = [2, 2]; $o>>[33m⏏[31m { say . }[0m␤    expecting any of:␤        postfix␤»

[14:55] <Heather> r: my $o = [2, 2]; $o>>{ say . }

[14:55] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~␤at /tmp/GUGa802n9J:1␤------> [32mmy $o = [2, 2]; $o>>{ say . [33m⏏[31m}[0m␤»

[14:55] <jnthn>  r: my $o = [2, 2]; $o>>.say

[14:55] <p6eval> rakudo 1c9939: OUTPUT«2␤2␤»

[14:55] <Heather> r: my $o = [2, 2]; $o>>.=1

[14:56] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing << or >>␤at /tmp/LXKYJw9k7K:1␤------> [32mmy $o = [2, 2]; $o>>.=[33m⏏[31m1[0m␤    expecting any of:␤        dotty method or postfix␤»

[14:56] <Heather> jnthn: thanks how to override them?

[14:56] <jnthn> What exactly does "override" mean?

[14:56] <Heather> jnthn: make [1, 1]

[14:58] <jnthn> Oh, assign to all of the things in the array?

[14:59] <jnthn> = is an infix so it needs to be inside a hyper

[14:59] <jnthn> r: my $o = [2,2]; $o >>=>> 1;

[14:59] <p6eval> rakudo 1c9939: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing << or >>␤at /tmp/HwiOta0Xfq:1␤------> [32mmy $o = [2,2]; $o >>=>[33m⏏[31m> 1;[0m␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤»

[14:59] <jnthn> hmm

[14:59] <jnthn> r: my $o = [2,2]; $o >>[=]>> 1;

[14:59] <p6eval> rakudo 1c9939:  ( no output )

[14:59] <jnthn> std: my $o = [2,2]; $o >>=>> 1;

[14:59] <p6eval> std 86b102f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing << or >> at /tmp/GpOeO2CRi0 line 1:␤------> [32mmy $o = [2,2]; $o >>=>[33m⏏[31m> 1;[0m␤    expecting infix_circumfix_meta_operator␤Parse failed␤FAILED 00:00 45m␤»

[15:00] <jnthn> r: my $o = [2,2]; $o >>[=]>> 1; say $o

[15:00] <p6eval> rakudo 1c9939: OUTPUT«1 1␤»

[15:00] <jnthn> The [...] go around the = to disambiguate here

[15:00] <jnthn> I think it's parsing => inside of there

[15:01] <arnsholt> That'd be the longest token, I guess

[15:01] <jnthn> yeah

[15:01] <arnsholt> Once again clear and unambiguous rules fall flat in the face of something that's obvious to people =)

[15:02] <masak> LlamaRider: 'use A' goes looking for an A.pm somewhere

[15:02] <masak> oops, replied to backscroll.

[15:04] <LlamaRider> masak: Thanks anyway, I'm writing this up in my porting repo now. To me it is a P6 gotcha.

[15:05] <masak> p5 works the same.

[15:05] <LlamaRider> then I got used to a P5 bug and thought it was a feature.

[15:06] <masak> files are orthogonal to packages. and 'use' loads files.

[15:06] *** census joined
[15:07] <LlamaRider> the example I made comes from XML::LibXML and I've written code like that myself, where I never cared about use-ing something multiple times. Maybe P5 just ignores a file if already loaded?

[15:07] <LlamaRider> or alternatively the code is a bug waiting to happen

[15:07] <census> llamarider++

[15:08] <masak> yes, p5 (and p6) won't care about an already loaded file.

[15:08] <LlamaRider> well p6 does, it gave me a circular load error

[15:08] <masak> also, 'if $cond { use SomeModule; }' will always load SomeModule.pm -- if you're unsure why, consider when the module is loaded, and when the if statement runs :)

[15:09] <masak> LlamaRider: there should never be any circular load errors.

[15:09] <masak> that sounds like an error in the implementation.

[15:09] <jnthn> Huh.

[15:09] <Heather> ingy: jnthn: oh, thank you )

[15:09] <jnthn> If you use A; in a module B and you use B inside of a module A, that won't work out.

[15:10] <jnthn> We don't reload from disk already loaded things.

[15:10] <geekosaur> perl5 also has some interesting behaviors with circular imports, although it doesn't throw errors (warnings though...)

[15:10] <jnthn> Well, in Perl 6 we simply can't do it 

[15:10] <LlamaRider> ===SORRY!===

[15:10] <LlamaRider> Circular module loading detected involving module 'XML::LibXML'

[15:10] <jnthn> Right.

[15:10] <jnthn> Maybe the message should be a bit more like "you can't do this"

[15:11] <jnthn> Rather than "oh, I noticed that..." :)

[15:14] <LlamaRider> p5eval: package A; 1; package B; use A; 1; 

[15:14] <p5eval> LlamaRider: ERROR: Can't locate A.pm in @INC (@INC contains: /lib) at (eval 7) line 1.BEGIN failed--compilation aborted at (eval 7) line 1.

[15:14] <geekosaur> right, use doesn't work that way in p5

[15:15] <LlamaRider> but but...

[15:15] <LlamaRider> $ perl -e 'package A; 1; package B; use A; 1; print "Works!\n"; '

[15:15] <LlamaRider> Works!

[15:15] <geekosaur> what I got with my inadvertent circularity is it loaded them, but the second load got a bunch of "Sub ... already defined"

[15:15] <LlamaRider> it works on my machine... somehow

[15:15] <geekosaur> different version? I was using whatever perl is on centos6.3

[15:15] <geekosaur> I think that's 5.10.mumble

[15:16] <LlamaRider> I have 5.14 here

[15:17] <geekosaur> and I know for certain it didn't work in 5.8.8

[15:17] <geekosaur> so apparently that got fixed at some point

[15:17] <jnthn> LlamaRider: Do you happen to have some kind of A.pm hanging around?

[15:18] * LlamaRider hides

[15:18] <LlamaRider> I did

[15:18] <LlamaRider> now it breaks again. Sorry

[15:18] * LlamaRider silently goes back to porting

[15:19] <jnthn> np )

[15:21] <masak> jnthn: is there any reason we don't just silently ignore module circularities in Perl 6, like we do in Perl 5?

[15:22] <geekosaur> p5 is not silent (you get a bunch of sub redefined warnings), and you can get weird behavior if any of the modules do tricky stuff in BEGIN blocks

[15:23] <jnthn> masak: Because you're almost certainly doomed to parse fail as soon as you mention any symbol form the other module, 'cus we didn't parse it yet.

[15:23] <nwc10> jnthn: selftest passes

[15:23] *** am0c joined
[15:23] <masak> jnthn: oh, and Perl 5 relies more heavily on strings there. I see.

[15:28] * LlamaRider wows at the P5 idioms in XML::LibXML

[15:28] *** census left
[15:33] *** census joined
[15:38] *** timotimo joined
[15:39] *** xenoterracide joined
[15:42] *** pmurias joined
[15:51] <jnthn> timotimo: ping

[15:52] <dalek> rakudo/md-nqp: fbf17f1 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[15:52] <dalek> rakudo/md-nqp: Port compile-time dispatch analysis to NQP.

[15:52] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/fbf17f18e6

[15:52] <dalek> rakudo/md-nqp: 8d0bb45 | jnthn++ | src/Perl6/Optimizer.pm:

[15:52] <dalek> rakudo/md-nqp: Get optimizer using NQP-based dispatch analysis.

[15:52] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/8d0bb45665

[15:52] <dalek> rakudo/md-nqp: fdc0c2f | jnthn++ | / (5 files):

[15:52] <dalek> rakudo/md-nqp: Finish eliminating C-based multi-dispatcher.

[15:52] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/fdc0c2f3e7

[16:13] *** wk_ left
[16:17] *** wk_ joined
[16:22] <nwc10> does this really work?

[16:22] <nwc10> p5eval: CORE::dump

[16:22] <p5eval> nwc10: No output

[16:22] *** cogno joined
[16:23] <nwc10> is it patched for CVE-2013-1667 ?

[16:23] <masak> works locally.

[16:24] <diakopter> au++ obra++ ask++

[16:25] <TimToady> masak: when you use a module, you're assumed to be mutating your language.  a circular use structure would then imply that you're new language is determined by a module that you didn't really know the language of when you used it.  hence it is considered undefined, and pink zebras will fly out of your nose

[16:25] * nwc10 is wondering just how pwnable it is

[16:25] <TimToady> s/you're/your/

[16:26] <TimToady> .oO(what's black and white and pink all over?)

[16:26] <geekosaur> um, isn't that expected?

[16:27] <geekosaur> ("dump" is a p5 builtin which used to be used with undump to create "preloaded perls")

[16:27] * jnthn read that as "pink zebras will fly out of your mom" :P

[16:28] <geekosaur> as such, if there is a bug, it's that (a) it still exists (b) someone, somewhere, is still using undump

[16:29] <pmurias> TimToady: shouldn't we detect that instead of crazy thing happening?

[16:29] *** cogno left
[16:29] <jnthn> pmurias: Rakudo does already :)

[16:29] <jnthn> Though they error may want some wordsmithing.

[16:30] <nwc10> p5eval: print unpack "P1", ("\xFF"x8)

[16:30] <p5eval> nwc10: No output

[16:31] *** cognominal joined
[16:32] <masak> TimToady: does that mean that p5 was confused about the "a module mutates your language" bit?

[16:32] <masak> s/was/is/

[16:32] <geekosaur> p5 had no such concept

[16:33] <geekosaur> packages are packages, semantics kinda just grew around them without much regard for the notion of language

[16:35] *** pmurias left
[16:35] <masak> TimToady: when I re-read your reasoning, it seems to me that the rationale somehow misses the common case, namely "oh, the user wants this module included, but it's already included. ignore"

[16:35] <dalek> rakudo/md-nqp: c57f0d5 | jnthn++ | src/Perl6/World.pm:

[16:35] <dalek> rakudo/md-nqp: Don't re-link already compiled blocks.

[16:35] <dalek> rakudo/md-nqp: 

[16:35] <dalek> rakudo/md-nqp: This loses lexical chain information they are carrying. A test for

[16:35] <dalek> rakudo/md-nqp: traits/wrapping/multi interaction (yes, we have one :-)) seems to have

[16:35] <dalek> rakudo/md-nqp: been somehow magically working before, for mysterious reasons. This

[16:35] <dalek> rakudo/md-nqp: change makes it work for a better understood reason, and with the NQP

[16:35] <dalek> rakudo/md-nqp: based multi-dispatcher. Fixes the remaining regression in this branch,

[16:35] <dalek> rakudo/md-nqp: and introduces no more spectest regressions.

[16:36] <dalek> rakudo/md-nqp: review: https://github.com/rakudo/rakudo/commit/c57f0d5d04

[16:36] <masak> TimToady: there might even be *legitimate* cases of mutual inclusion (and ignoring one of the inclusions to avoid a circularity): when you have different roots in the inclusion hierarchy, for example.

[16:37] <jnthn> masak: Isn't the previous comment a contradiction?

[16:37] *** mavcunha left
[16:37] <jnthn> masak: It can't be "already included" if it has a circular dependency because we never got to the point of having "included" it

[16:38] <masak> hm, it seems to me there are two different cases there.

[16:38] <jnthn> The point we consider a module loaded is after we have parsed it. At that point, we enter its UNIT into the "stuff we loaded" table.

[16:39] <masak> let's say A has a 'use B'. if we encounter 'use A' while before finishing processing B.pm, then that's probably an error.

[16:39] <masak> of the kind TimToady describes.

[16:40] <jnthn> Agree so far.

[16:40] <masak> but we could also have a situation where 'use A' happens after we've finished processing B.pm.

[16:40] <masak> I suppose that's not a problem at all, and that case gets ignored.

[16:41] <jnthn> We don't reload things a second time if they're already loaded. But that's not circular, that's just multiple things having a "use"

[16:41] <jnthn> Really it's the "need"'s work that is cached

[16:41] <jnthn> It's the import part of the "use" that needs doing each time.

[16:42] <jnthn> OK, my branch seems to be working nicely :)

[16:43] *** cognominal left
[16:43] <masak> hm. yes. maybe that *is* the best we can hope for.

[16:43] <TimToady> circular needs are probably okay, since they don't mutate the language

[16:43] <masak> "Perl 6: it mutates your language"

[16:43] <masak> this is true on so many levels. :)

[16:44] <jnthn> 26 files changed, 1158 insertions(+), 1669 deletions(-)

[16:44] <jnthn> You can write a multi-dispatcher in less lines in NQP than in C. :)

[16:44] <colomon> \o/

[16:44] <TimToady> I should hope so

[16:44] <TimToady> now make it run faster :)

[16:45] <jnthn> "Don't be a load slower" has been some work :)

[16:45] <masak> wow, cool. we should have this: https://metacpan.org/module/PerlIO::http :)

[16:45] <jnthn> But yes, more optimization needed/to come :)

[16:45] <jnthn> It's not far off the C version though, and it fixes some bugs.

[16:46] <nwc10> cool

[16:46] <jnthn> And gets rid of a load of places we did nested runloops

[16:52] <dalek> roast: bbe88fe | jnthn++ | integration/weird-errors.t:

[16:52] <dalek> roast: Correct an expected exception type.

[16:52] <dalek> roast: 

[16:52] <dalek> roast: After timotimo++ fixed things to throw the correct one.

[16:52] <dalek> roast: review: https://github.com/perl6/roast/commit/bbe88fe6e6

[16:53] *** cognominal joined
[16:56] *** SamuraiJack__ left
[16:58] *** SamuraiJack joined
[16:58] <colomon> TimToady: have you taken a look at the spectest issues I found with niecza yesterday? 

[16:59] <colomon> in particular, 

[16:59] <colomon> rn: say ($_ * 2 if $_ ** 2 > 3 for 0 .. 5)

[16:59] <nwc10> panda requires prove at the moment? If so, how SMOP is it to re-implement prove in Perl 6? Seems like a useful task

[16:59] <p6eval> niecza v24-34-g4f8f894: OUTPUT«() () 4 6 8 10␤»

[16:59] <p6eval> ..rakudo 1c9939: OUTPUT«4 6 8 10␤»

[16:59] <jnthn> nwc10: tadzik++ has already started working on doing that :)

[16:59] <colomon> tadzik++ indeed!

[17:00] <nwc10> excleent

[17:00] <nwc10> tadzik++

[17:01] <dalek> Heuristic branch merge: pushed 47 commits to rakudo/nom by jnthn

[17:01] <nwc10> is that the goalposts moving again? and roughly in the direction of Christmas?

[17:02] <jnthn> nwc10: That's one big piece of Rakudo just becoming a huge amount easier to port. Plus fixing some bugs for a more immediate win :)

[17:03] <nwc10> yay \o/

[17:03] <nwc10> jnthn++

[17:04] <colomon> btw, the STEP script is still running, with several STEP files reading in successfully after 10+ hours of processing.  so it's way too damned slow, but given enough memory resources it seems pretty robust!

[17:04] <colomon> jnthn++

[17:04] <colomon> current STEP file has been processing for 

[17:05] <colomon> r: 983/60

[17:05] <p6eval> rakudo 1c9939:  ( no output )

[17:05] <colomon> r: say 983/60

[17:05] <p6eval> rakudo 1c9939: OUTPUT«16.383333␤»

[17:05] <timotimo> jnthn: pong

[17:05] <colomon> sixteen hours, and is currently using 25 gigs of memory.

[17:05] <cognominal> jnthn, can you blog your wonderful work? It is so nice to understand what you are up to.

[17:05] <jnthn> timotimo: I was gonna ask about a test, but I've sorted it out.

[17:05] <jnthn> timotimo: One of your improvements caused a test to fail, but it was the test to blame

[17:05] <jnthn> timotimo: See my last roast commit to know which one :)

[17:06] <pmichaud> good afternoon, #perl6

[17:06] <diakopter> o/

[17:06] <timotimo> ah, what a relief

[17:06] <masak> pmichaud! \o/

[17:06] <colomon> o/

[17:07] <jnthn> o/ pmichaud 

[17:07] <jnthn> uh-oh...I merge a big branch and Pm shows up :)

[17:07] <masak> nwc10: I think we should definitely try to implement 'prove' in Perl 6.

[17:08] <pmichaud> jnthn: my appearance has nothing to do with the branch merge :)

[17:08] <jnthn> pmichaud: phew ;)

[17:08] <nwc10> and once it works for tests one at a time, parallel tests...

[17:08] <jnthn> pmichaud: It didn't do much. Just re-wrote the multi-dispatcher from C into NQP :)

[17:09] <nwc10> which will be "fun" on Win32 thanks to Microsoft's utter [censored] w.r.t. the behaviour of sockets on close()

[17:09] <pmichaud> jnthn: yes, I've been following the commit logs :)

[17:09] <timotimo> jnthn: the rewrite is complete?

[17:10] <jnthn> timotimo: Yes, and merged

[17:10] <jnthn> One more bonus: we now have typed exceptions for multi-dispatch failures.

[17:12] <timotimo> that is very nice

[17:12] <timotimo> what's the next target on the road to rakudo on the jvm?

[17:13] <cognominal> why the C based dispatcher was an hindrance for rakudo on the jvm?

[17:13] <timotimo> i guess it was very parrot-centered?

[17:14] <nwc10> the C based dispatcher was in C

[17:14] <jnthn> cognominal: Because it'd have had to be ported to something that runs on the JVM, and then we'd have had to maintain two implementations of it into the future.

[17:14] <nwc10> NQP runs on the JVM

[17:14] <nwc10> C doesn't

[17:14] <jnthn> cognominal: And when one of those things can be NQP, which runs on both... :)

[17:14] <nwc10> "the C based <mumble> is in C" is the problem, for all values of <mumble>

[17:15] <timotimo> oh, there's a perl mongers group in my home town

[17:15] <nwc10> where in the world are you (or them)?

[17:15] <timotimo> karlsruhe, both me and them

[17:15] <nwc10> aha

[17:15] <timotimo> in baden-württemberg of germany

[17:15] <jnthn> Oh, I changed train in Karlsruhe twice last year

[17:16] <nwc10> it's on TGV Ost, isn't it?

[17:16] <timotimo> i think a TGV goes by there, too

[17:16] <timotimo> but i've never seen or rode a TGV

[17:17] <jnthn> Yeah, I was heading to last year's FPW

[17:17] <timotimo> that is the french perl workshop?

[17:17] <jnthn> ja

[17:18] <timotimo> i wonder if they would be welcoming someone who has only very basic experience with perl 6 and none with perl 5

[17:18] <timotimo> i would certainly not enjoy bringing a 5 vs 6 flame war into a group of people

[17:18] <dalek> niecza: 5c06e28 | larry++ | lib/CORE.setting:

[17:18] <dalek> niecza: make Empty gist to '' like normal ()

[17:18] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5c06e28216

[17:18] *** Heather left
[17:19] <cognominal> the FPW is in Nancy this year, north east of France, like last year.  http://journeesperl.fr/fpw2013/    Perl6 speakers are welcome

[17:20] <cognominal> beside the usual Perl6 speakers, having lizmat and wendy was nice, last year

[17:21] <masak> "north east of Paris"?

[17:21] <cognominal> to restate it, fpw : June 14-15, 2013 in Nancy

[17:22] <cognominal> masak++  # so true

[17:22] <masak> aww, I can't on those dates. and neither can jnthn. :/

[17:23] <masak> woulda been nice to show up.

[17:23] <nwc10> jnthn: all tests and all spectests other than t/spec/S26-documentation/09-configuration.t pass

[17:23] <nwc10> the failures are all like this:

[17:23] <nwc10> ok 1 - The object is-a 'Pod::Block::Code'

[17:23] <nwc10> not ok 2 -

[17:23] <nwc10> #      got: '1'

[17:23] <nwc10> # expected: 'B'

[17:23] <nwc10> got '1' instead of the thing expected

[17:24] <nwc10> (apparently it is now tea time)

[17:24] <jnthn> nwc10: Yeah, that's not a regression due to the branch, it was an issue in nom too. I've currently compiling a patch...I think some of my earlier work busted it 

[17:24] <jnthn> masak: DDDx?

[17:25] <moritz> lib/lib.pm6 has a custom EXPORT sub

[17:25] <masak> jnthn: ayup.

[17:25] <masak> \o/

[17:25] <jnthn> Nice :) Though pity we miss FPW.

[17:26] <jnthn> moritz: I don't think it actually installs symbols, though? :)

[17:26] <jnthn> moritz: Or it wasn't obvious to me how it would...

[17:27] <jnthn> Yay, I got a fix for that Pod test. :)

[17:27] <jnthn> Maybe now Rakudo can haz clean roast runs again

[17:30] <masak> \o/

[17:31] <pmichaud> I get a build failure in nom  :-/

[17:32] <jnthn> Congrats!

[17:32] <jnthn> What's it look like?

[17:32] <jnthn> oh...argh

[17:32] <pmichaud> it's been a while since I last built... starting with clean checkouts

[17:32] <pmichaud> (restarting)

[17:33] <dalek> rakudo/nom: 52f04a7 | jnthn++ | src/Perl6/Pod.pm:

[17:33] <dalek> rakudo/nom: Fix Pod configuration regression.

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/52f04a7830

[17:33] <dalek> rakudo/nom: fd5d929 | jnthn++ | tools/build/NQP_REVISION:

[17:33] <dalek> rakudo/nom: Bump NQP_REVISION.

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd5d929e40

[17:33] <jnthn> pmichaud: I think I forgot to bump NQP_REVISION recently enough.

[17:33] <pmichaud> looked like that might've been it

[17:40] <pmichaud> running 'make' now

[17:41] <grondilu> rn: .say for 1 .. ^"foo".chars

[17:41] <p6eval> rakudo 1c9939, niecza v24-34-g4f8f894: OUTPUT«1␤2␤3␤»

[17:41] <grondilu> rn: .say for ^("foo".chars)

[17:41] <p6eval> rakudo 1c9939, niecza v24-34-g4f8f894: OUTPUT«0␤1␤2␤»

[17:41] <grondilu> rn: .say for ^"foo".chars

[17:41] <p6eval> rakudo 1c9939, niecza v24-34-g4f8f894: OUTPUT«0␤1␤2␤»

[17:42] <timotimo> ^"foo" is evaluated as ^+"foo"" no?

[17:42] <pmichaud> rakudo:  say ^"foo"

[17:42] <p6eval> rakudo 1c9939: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤␤  in method Real at src/gen/CORE.setting:873␤  in method new at src/gen/CORE.setting:5281␤  in sub prefix:<^> at src/gen/CORE.setting:5474␤  in block  at /tmp/1AIqgfkj0c:1␤␤»

[17:43] <pmichaud> no.

[17:43] * grondilu understood his mistake

[17:43] <grondilu> I meant:

[17:43] <grondilu> rn: .say for 1 ..^ "foo".chars

[17:43] <p6eval> rakudo 1c9939, niecza v24-34-g4f8f894: OUTPUT«1␤2␤»

[17:43] <grondilu> yep

[17:43] <grondilu> better

[17:44] <timotimo> oh, duh, that's obvious

[17:44] <grondilu> though I'm not sure what 1 .. ^"foo".chars means and why it returns 1, 2, 3

[17:45] <pmichaud> ^"foo".chars is a Range

[17:45] <grondilu> rn: .say for 1 .. (^3)

[17:45] <p6eval> rakudo 1c9939, niecza v24-34-g4f8f894: OUTPUT«1␤2␤3␤»

[17:45] <grondilu> ^ guess that's it

[17:46] <grondilu> pmichaud: yep, ^"foo".chars is a range, converted in integer by '..'

[17:46] *** cognominal left
[17:46] <pmichaud> istr that we were going to fail with Range arguments to infix:<..>

[17:46] * pmichaud checks the spec

[17:47] <timotimo> jnthn: did you manage to find out why the nqp md was slower than the c md?

[17:48] <jnthn> timotimo: It isn't by terribly much any more.

[17:48] <timotimo> nice :)

[17:48] <pmichaud> as a general rule of thumb I'd expect nqp <mumble> to be slower than C <mumble>

[17:48] <timotimo> sure

[17:48] <jnthn> Yeah

[17:48] <jnthn> Well, there's "slower" and there's "omg we can no way merge this" slower :)

[17:49] <pmichaud> right

[17:49] <timotimo> can you decide at compile time if you go with C md or nqp md? or was C md removed altogether?

[17:49] <jnthn> Removed

[17:49] *** cognominal joined
[17:49] <timotimo> hm, i can see why you would do that.

[17:51] <pmichaud> yes, S03:3365 says it's illegal to use a Range as an endpoint of infix:<..>.  I guess that needs a multisub entry... will work on it after I get Rakudo running :)

[17:51] <pmichaud> what's the standard process for identifying and/or creating an exception, ooc?

[17:52] <pmichaud> is there an article somewhere?

[17:52] <timotimo> is ooc "out of curiosity"?

[17:52] <pmichaud> I'm assuming that    fail "string describing failure"   is no longer acceptable  :-)

[17:52] <pmichaud> ooc == "out of curiosity", yes

[17:52] <moritz> pmichaud: you create one, document it in S32::Exceptions, test it (in case of doubt t/spec/S32-exceptions/misc.t)

[17:53] * jnthn missed two of those steps...d'oh :)

[17:53] <pmichaud> moritz: any other guidelines or rules of thumb?

[17:53] <jnthn> While we're on the topic, though...

[17:53] <moritz> and if you are motivated, also document it in the perl6/doc repo

[17:53] <moritz> pmichaud: use common sense

[17:53] <moritz> and compile time exceptions should do X::Comp

[17:54] <jnthn> https://rt.perl.org/rt3/Ticket/Display.html?id=114204 suggests that we should include info on what arguments you tried to pass in the case of a failed multi-dispatch.

[17:55] <jnthn> Do we want that?

[17:55] <moritz> +1

[17:55] <jnthn> If so I can bundle the info into the exception objects and then it should be easy to stringify...

[17:55] <moritz> aye

[17:55] <moritz> maybe jut the types, and names in case of named arguments

[17:56] <jnthn> *nod*

[17:56] <pmichaud> so, in the case of   1 .. ^10    what sort of exception would be expected?  Message is something like "Ranges are not allowed as endpoints to &infix:<..>"

[17:57] <pmichaud> X::RangeOp::InvalidArg ?

[17:57] <moritz> X::Range::InvalidArg I'd say

[17:57] <jnthn> When the error is clearly related to the type it tends to be X::TypeName::Something

[17:58] <pmichaud> oh, so   Range.new(1, ^10) would be an error.  okay.

[17:58] <jnthn> X::Buf::AsStr for example

[17:58] <moritz> pmichaud: yes, I don't see how Range.new(1, ^10) makes more sense than 1..(^10)

[17:59] <pmichaud> okay, makes sense to me

[18:00] <jnthn> On the FooOp pattern though, we do have a X::HyperOp::NonDWIM

[18:00] <moritz> but we don't have a Hyper type

[18:00] <pmichaud> right, I was looking for an op pattern.

[18:00] <jnthn> aye :)

[18:00] <pmichaud> I agree it makes sense to do it in Range here.

[18:01] <pmichaud> indeed, Range.new already has an unconverted  fail "message"  that I'll also take care of.

[18:01] *** cognominal left
[18:01] <pmichaud> r:  say Range.new(*,*)

[18:01] <p6eval> rakudo 1c9939: OUTPUT«*..* is not a valid range␤  in method gist at src/gen/CORE.setting:10555␤  in sub say at src/gen/CORE.setting:7614␤  in block  at /tmp/fXUM4HaHTm:1␤␤»

[18:02] <pmichaud> running spectest now of rakudo with new dispatch :)

[18:02] <nwc10> jnthn: works on my machine (spectests)

[18:02] <pmichaud> no failures thus far... up to S04

[18:02] <jnthn> yay :)

[18:05] <masak> heh, why isn't *..* a valid range?

[18:05] * grondilu failed to solve yet another rosalind problem because perl6 is too slow

[18:05] <masak> r: say 5 ~~ *..*

[18:05] <p6eval> rakudo 1c9939: OUTPUT«False␤»

[18:05] <masak> n: say 5 ~~ *..*

[18:05] <p6eval> niecza v24-35-g5c06e28: OUTPUT«True␤»

[18:05] <masak> hah! :D

[18:05] <moritz> which one is right?

[18:06] * masak tentatively argues Niecza is right and *..* is valid

[18:06] <jnthn> Wait, how come Range.new(*,*) doesn't work, but *..* does?

[18:06] *** cognominal joined
[18:06] <pmichaud> masak: *..* isn't valid because S03:3468 says it's Illegal.

[18:06] <jnthn> rn: for *..* { .say }

[18:06] <masak> pmichaud: fair enough :)

[18:06] <p6eval> rakudo 1c9939: OUTPUT«*..* is not a valid range␤current instr.: 'throw' pc 334686 (src/gen/CORE.setting.pir:150131) (src/gen/CORE.setting:9331)␤called from Sub 'gist' pc 366646 (src/gen/CORE.setting.pir:162889) (src/gen/CORE.setting:10555)␤called from Sub 'say' pc 80552 (src/gen/CORE.se…

[18:06] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«(timeout)-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-I…

[18:06] <grondilu> http://paste.siduction.org/20130316180629   <<  how could I improve the speed of this program?

[18:07] <pmichaud> S03:3463 says it also :)

[18:07] <masak> aye.

[18:07] <pmichaud> grondilu: removing the 'return's would speed things up

[18:08] <moritz> grondilu: 'return [+] gather' looks scarily slow

[18:08] <moritz> grondilu: instead declare a variable and use it to sum up stuff

[18:08] <masak> rn: my $counter = 0; for *..0 { .say; last if $counter++ == 10 }

[18:08] <TimToady> r: say -Inf .. Inf

[18:08] <grondilu> ok

[18:08] <pmichaud> return $rna eq any(<AU UA CG GC>) ?? 1 !! 0   is much faster as   +($rna eq any(<AU UA CG GC>))

[18:08] <p6eval> rakudo 1c9939: OUTPUT«(timeout)»

[18:08] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤-Inf␤»

[18:08] <p6eval> rakudo 1c9939: OUTPUT«-Inf..Inf␤»

[18:08] <pmichaud> well, maybe not _much_ faster, but faster.

[18:09] <masak> both Rakudo and Niecza seem wrong here.

[18:09] <TimToady> -Inf .. Inf is acceptable

[18:09] <jnthn> But useless for iterating :)

[18:10] <TimToady> it's not for iterating, but then nothing with * on the left is either

[18:10] <TimToady> it's for range matching

[18:10] <pmichaud> jnthn: all spectests passed here

[18:10] <jnthn> \o/

[18:10] <TimToady> especially if something requires a Range, but you want to match everything, then -Inf .. Inf can be useful

[18:10] <masak> rn: say 5 ~~ -Inf .. Inf

[18:10] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«True␤»

[18:10] <masak> rn: say 5 ~~ * .. Inf

[18:11] *** cognominal left
[18:11] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«True␤»

[18:11] <masak> rn: say 5 ~~ * .. *

[18:11] <p6eval> rakudo 1c9939: OUTPUT«False␤»

[18:11] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«True␤»

[18:12] <TimToady> two bugs for the price of one

[18:12] <grondilu> rn: say +("foo" eq any(<foo bar>));

[18:12] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«any(1, 0)␤»

[18:12] <grondilu> pmichaud: ^

[18:12] <pmichaud> grondilu: oh

[18:12] <pmichaud> rn: say +?("foo" eq any(<foo bar>))

[18:12] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«1␤»

[18:13] <TimToady> rn: say +so "foo" eq any <foo bar>

[18:13] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«1␤»

[18:13] <pmichaud> rn: say True * False   # curious

[18:13] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«0␤»

[18:14] *** Sifr joined
[18:14] <pmichaud> rn: say True * True

[18:14] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«1␤»

[18:14] * grondilu retries with suggested modification and full data

[18:14] <pmichaud> might not need the + :-)

[18:15] <timotimo> how hard would it be to optimise things like ([+] gather) or for ..Inf -> $x { ... } where a lazy list is generated but the earlier pieces of the list can be discarded immediately

[18:15] <timotimo> is this something the programmer should be aware of and avoid actively, or should the compiler notice what's going on and cleverly deallocate the early parts of the list?

[18:15] <pmichaud> rn: say True +^ False

[18:15] <p6eval> rakudo 1c9939, niecza v24-35-g5c06e28: OUTPUT«1␤»

[18:16] <moritz> timotimo: it's at least not trivial to optimize

[18:16] <pmichaud> timotimo: "cleverly deallocate" is really hard at the moment.

[18:16] <pmichaud> I need to get back to my list updates :-/

[18:16] <timotimo> i feared as much

[18:17] <pmichaud> bbiab

[18:18] <dalek> rakudo/nom: ce914fc | jnthn++ | src/Perl6/ModuleLoader.pm:

[18:18] <dalek> rakudo/nom: Some pir:: => nqp:: in Perl6::ModuleLoader.

[18:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce914fcb3c

[18:19] <jnthn> ye shoppe &

[18:19] <nwc10>  1 files changed, 5 insertions(+), 8 deletions(-)

[18:19] <nwc10> not only pir:: => nqp::, but also net code removal

[18:20] <grondilu> six minutes and still running :(

[18:21] * grondilu interrupts the program

[18:21] <moritz> grondilu: you can substitute .match($regex, :g) with .comb($regex)

[18:21] <moritz> which returns Str, not Match objects, so uses less memory

[18:22] <grondilu> ok

[18:22] <grondilu> I doubt it will help much though, as this line only reads the input

[18:23] <grondilu> anyone has a fast machine and would like to give it a go?

[18:23] <timotimo> Q:PIR { $P0 = find_lex '$block'; $P1 = find_lex '$coro'; $P1($P0) };  -  is this just basically "$coro($block)"?

[18:24] <grondilu> Here is the code:  http://paste.siduction.org/20130316182329

[18:24] <grondilu> and here is the input:  http://paste.siduction.org/20130316182413

[18:25] *** LlamaRider left
[18:30] *** cogno joined
[18:32] *** FROGGS joined
[18:35] *** cogno left
[18:36] <jnthn> grondilu: Guess I can feed it through the profiler while I cook :)

[18:36] <timotimo> grondilu: how does the "bag max :by(*.chars) thing work? i'm confused

[18:37] <grondilu> timotimo: it checks that there are as many A as U and C as G.  I'm currently trying to avoid doing this check

[18:37] <timotimo> i don't even get how it parses

[18:37] <pmichaud> timotimo: ( $coro($block) )    Yes, that's what it basically is, but it goes through the Parrot dispatcher and not the Rakudo one.

[18:37] <timotimo> is :by a named parameter to the max function?

[18:37] <grondilu> timotimo: yes

[18:38] <timotimo> pmichaud: so i should replace it with the appropriate nqp ops? (i think if i ask one more question, you'll have done 100% of the work >_>)

[18:38] <grondilu> rn: say max :by(*.chars), <foo bar longstring>;

[18:38] <p6eval> rakudo fd5d92, niecza v24-35-g5c06e28: OUTPUT«longstring␤»

[18:38] <timotimo> i see

[18:39] <pmichaud> timotimo: if there are appropriate nqp ops, then yes.

[18:39] <pmichaud> note that $coro is probably not a Code object.

[18:39] <pmichaud> that's the part to be aware of.

[18:40] <timotimo> at this point, the $coro is a Mu that was nqp::clone'd from nqp::getattr(&coro, Code, '$!do'), so it seems like it really is a Code object

[18:40] <timotimo> oh, no, hold on

[18:41] <timotimo> the second argument is probably the class from which the attribute comes, right?

[18:41] * timotimo doesn't know how to continue

[18:44] <pmichaud> timotimo: yes, Core is the class defining the attrib ute

[18:44] <pmichaud> for any Code object, $!do is the low-level subroutine thingy to be invoked

[18:46] <pmichaud> I'm assuming you're working in GatherIter

[18:47] <pmichaud> if so, then $coro is the Parrot Coroutine PMC to be invoked for this particular GatherIter

[18:47] <timotimo> i just quickly grepped for PIR and this was the first result ;)

[18:49] *** MayDaniel joined
[18:59] * grondilu has translated in P5 and even then it is slow.  The code is probably wrong.

[19:05] * grondilu realizes he forgot to translate a if case

[19:07] *** wk_ left
[19:07] <arnsholt> o/

[19:07] <masak> \o

[19:16] *** cognominal joined
[19:16] <pmichaud> okay, I'm having trouble understanding the dispatcher

[19:16] <pmichaud> or, at least, what I'm doing wrong, if anything

[19:17] <pmichaud> https://gist.github.com/pmichaud/5177871   # code added to src/core/Range.pm

[19:18] <pmichaud> this adds a .new candidate that throws an exception if the second argument is a Range

[19:18] <pmichaud> but when I run it, it continues to call the existing candidate

[19:18] <pmichaud> (the one without type constraints)

[19:19] <pmichaud> > say Range.new(0, ^10)

[19:19] <pmichaud> 0..10

[19:19] <pmichaud> what am I overlooking?

[19:22] <timotimo> r: my ($a, $b, $c, $d) = <a b c d>; ($a, $b, $c, $d) .= pick(4); say "$a, $b, $c, $d";

[19:22] <p6eval> rakudo ce914f: OUTPUT«c, d, b, a␤»

[19:22] <timotimo> r: my ($a, $b, $c, $d) = <a b c d>; ($a, $b, $c, $d) .= pick(4); say "$a, $b, $c, $d";

[19:22] <p6eval> rakudo ce914f: OUTPUT«d, a, c, b␤»

[19:22] <timotimo> this amuses me

[19:22] *** spider-mario joined
[19:24] <pmichaud> ...and apparently it matters _where_ I put the method.

[19:25] <arnsholt> jnthn: Does https://gist.github.com/arnsholt/5177904 look like a reasonable translation of bootType from NQP/JVM?

[19:26] <pmichaud> If I put it first or second, then .new(0,^10) triggers the method.  If it goes after method new(Real, Any, ...)   then it never gets selected.

[19:27] *** am0c left
[19:28] <pmichaud> oh, I see why.  I think.

[19:28] <pmichaud> .new(0,^10)   chooses  whichever comes first from   new(Real,Any)   and new(Any,Range)

[19:29] <jnthn> Those would be tied

[19:29] <pmichaud> right.

[19:30] <jnthn> And then the presence of named args is enough to throw the binder into "first that binds" mode.

[19:30] <pmichaud> okay, that's the piece I was missing then.

[19:31] <jnthn> sorry, named params

[19:33] <mberends> .oO(named parens)

[19:34] *** kurahaupo joined
[19:34] <pmichaud> so, what's the best approach here?  create sufficient candidates to make sure there aren't any ties, or order the methods in terms of preference?

[19:34] <jnthn> Unicode probably knows hundreds of different named kinds of parens... :)

[19:34] * jnthn checks what candidates we have already

[19:34] <arnsholt> I was thinking that's what happens when you program too much in Lisp. Every paren gets a name ^_^

[19:35] <mst> I shall call mine ... timmy!

[19:35] <mst> this is your parenthesis ... there are many others like it, but this one is yours ...

[19:35] *** quester joined
[19:36] <mberends> like Nemo's 400 siblings

[19:37] <jnthn> pmichaud: Alternatively, you could check $max ain't a Range in the BUILD submethod.

[19:37] <hoelzro> so I'd like to define a custom EXPORT routine for my module.  I thought that required me to do something like this: module POSIX { our sub EXPORT(*args) { ... } }, but that doesn't work

[19:37] <hoelzro> (that doesn't work -> "no EXPORT sub, but you provided positional argument in the 'use' statement")

[19:37] <jnthn> pmichaud: Which covers all of the bases

[19:37] <jnthn> hoelzro: I think it may be looked up in UNIT

[19:38] <pmichaud> jnthn: yeah, I thought about that a bit also.

[19:38] <jnthn> It kinda cross-cuts the other candidates.

[19:38] <pmichaud> that seems a bit too low-level to me somehow, but I'll go ahead and do it that way for now.

[19:38] <hoelzro> jnthn: tried that too; "Merging GLOBAL symbols failed: duplicate definition of symbol &EXPORT"

[19:38] <hoelzro> I'm guessing it doesn't play nice with 'is export'?

[19:39] <jnthn> hoelzro: I don't think you're meant to export your EXPORT :)

[19:39] <jnthn> pmichaud: I suspect putting the candidate after the first Any,Any one would do the trick.

[19:39] <hoelzro> right, but I also have our sub getuid() returns Int is native is export

[19:40] <moritz> hoelzro: note that sub EXPORT must be outside the module

[19:40] <hoelzro> right, I'm doing that

[19:40] <pmichaud> yeah, putting it after the first Any,Any seems to work, but also seems fragile.

[19:41] <pmichaud> is the "first that binds" rule in the spec anywhere?

[19:41] *** wk__ joined
[19:42] <jnthn> Yeah, S12

[19:42] <pmichaud> didn't see it there but will look again

[19:42] <jnthn> yes, just pulling latest 

[19:42] <timotimo> so, since junctions are already implemented in perl5, can someone tell me how the "leftmost and is autothreaded first" rule intermingles with named arguments? i'd like to write some tests for that and maybe implement it in rakudo as well

[19:43] <pmichaud> okay, found it.

[19:43] <pmichaud> "for tiebreaker B the candidates are simply called in the order they were declared"

[19:44] <jnthn> 1235

[19:44] <hoelzro> this might shed some light on the subject: https://gist.github.com/hoelzro/5177985

[19:44] <jnthn> oh, you meat me to it :)

[19:44] <pmichaud> seems like the Any,Any candidate ought to be last, then, under the theory of proceeding from "most constrained" to "least constrained"

[19:44] <pmichaud> (in the source, that is)

[19:44] <jnthn> I suspect that Any,Any will be nominally looser though.

[19:44] <pmichaud> I know it doesn't matter in reality, but it might be easier to read/understand if the candidates were ordered that way in the source.

[19:45] <jnthn> Yes, that is true

[19:45] <pmichaud> I'll try that.

[19:45] <jnthn> (Any,Any) is looser than both of (Real, Any) and (Any, Range).

[19:45] <jnthn> But the latter two are tied.

[19:45] <jnthn> So we fall back to bindability

[19:45] <jnthn> With nameds counting as a constraint

[19:46] <jnthn> Most common place nameds constrain is in trait mods.

[19:46] *** Kurahaupo_ joined
[19:46] <pmichaud> I suspect reordering will mean I can eliminate the Real,Whatever case, too.

[19:47] <jnthn> arnsholt: Not SC_repossess_object. That's for something else

[19:47] <jnthn> arnsholt: It's not owned at all, you just need to add it

[19:47] <jnthn> arnsholt: Like is done with KnowHOW

[19:48] <arnsholt> Thanks!

[19:48] <arnsholt> That's probably why I get a segfault =)

[19:48] <jnthn> arnsholt: Also confused about the "don't have a name" comment. KnowHOWREPR.h shows a STRING *name to me :)

[19:51] <hoelzro> would anyone mind taking a look at my gist?

[19:51] <arnsholt> Indeed it does. I'm still a bit foggy on what types all the things actually are, so I was only looking at stuff common to all 6model objects =)

[19:52] <jnthn> hoelzro: I'd expect that to give some error about EXPORT not expecting any args, but getting one

[19:52] <jnthn> oh no

[19:52] <jnthn> YOu put a |

[19:53] <hoelzro> I thought that meant "take any args"?

[19:53] <jnthn> yeah

[19:53] <jnthn> I missed it on first read

[19:53] <hoelzro> oh, ok

[19:53] <hoelzro> well, here's the error I'm getting:

[19:53] <hoelzro> Merging GLOBAL symbols failed: duplicate definition of symbol &EXPORT

[19:54] <arnsholt> jnthn: Anyways, from looking at knowhow_bootstrapper.c all I have to do is set the ->sc member, no functions to call?

[19:54] <jnthn> hoelzro: Try not making it "our"?

[19:54] <hoelzro> jnthn: there we go!

[19:55] <jnthn> hoelzro: ah, I thought I explained that and now I realize my explanation is useless without saying what UNIT is. 

[19:55] <jnthn> hoelzro: UNIT is the outermost lexical scope of something

[19:56] <jnthn> It's what the module loader gets hold of when it loads a module, and it uses it to resolve things

[19:56] <jnthn> Including finding your &EXPORT

[19:56] <jnthn> arnsholt: No, there's pairings of lines:

[19:56] <jnthn> VTABLE_set_pmc_keyed_int(interp, sc, 0, knowhow_pmc); SC_PMC(knowhow_pmc) = sc;

[19:56] <hoelzro> alright

[19:57] <hoelzro> when I read that, I'd assumed that it mean the top level "chunk" of a file

[19:57] <arnsholt> jnthn: Oh, right. I see, I see

[19:57] <jnthn> arnsholt: The first of those puts the object into the SC. The 0 is the index.

[19:57] *** SamuraiJack_ joined
[19:58] <arnsholt> Yeah, so I'll probably want to VTABLE_push, rather than use a hardcoded index, right?

[19:58] *** SamuraiJack left
[19:58] <hoelzro> well, now that my EXPORT is being called...how do I inject routines into the calling context?

[20:00] <timotimo> will i even be able to differentiate the positions of nameds between non-nameds from inside rakudo when i'm given a capture? :|

[20:02] <moritz> timotimo: no

[20:03] <jnthn> arnsholt: No becuase (1) I'm pretty sure the SCs don't work with that, and (b) we need to try and make the indexes match up between implementations in __6MODEL_CORE__ or we get problems.

[20:04] <hoelzro> crap, now I need to figure out how to get errno via NativeCall =/

[20:05] <timotimo> moritz: in that case, should i write in the specs that all non-nameds and then all nameds will be considered separately, no matter if they are mixed? or should rakudo instead be able to differentiate those?

[20:05] <arnsholt> hoelzro: I know the answer to that (unfortunately): You don't =(

[20:05] <hoelzro> damn

[20:05] <hoelzro> I figured

[20:05] <arnsholt> Unless there's a function that returns it, no way to get to global variables yet

[20:05] <hoelzro> I'm guessing there's no Inline::C for Perl6?

[20:05] <FROGGS> hoelzro: there is

[20:05] <hoelzro> oh, good

[20:05] <moritz> timotimo: the specs need to be adapted in some way

[20:06] <hoelzro> I feel like I should just write a dynext for Parrot or something

[20:06] <hoelzro> but using NativeCall is probably "friendlier" to other impls

[20:06] <pmichaud> I'd not be opposed to an errno opcode :)

[20:07] <pmichaud> ETOOMANYNEGATIONS    "I think an errno opcode would be an okay shim for the time being, since it keeps coming up."

[20:07] <hoelzro> pmichaud: should I add that to NQP? I was thinking of just writing a separate dynext that Rakudo could load

[20:08] <pmichaud> hoelzro: I'd verify with jnthn first, but "add to NQP" is what I would think, yes.

[20:08] <hoelzro> mkay

[20:08] <pmichaud> nqp::posixerrno  or something like that

[20:09] <arnsholt> jnthn: Aha. So I need to be careful about the ordering of the boot_types

[20:10] <timotimo> moritz: indeed. i opened a spec ticket a week ago or so and i'd like to advance that towards a solution. that's why i'm asking ;)

[20:11] <jnthn> One thing with errno is we need to be careful about what may change it.

[20:12] <pmichaud> jnthn: agreed, but I figure opening up the minefield will help us find out where the mines are.

[20:12] <pmichaud> or for a less gruesome analogy -- one way of finding the holes in the cheese is to let people start slicing it open :)

[20:13] <jnthn> True :)

[20:13] <jnthn> Was just wondering about making the native call stuff itself stash it away somewhere after each call

[20:14] <pmichaud> right, we may end up wanting to do exactly that

[20:14] <jnthn> And we expose an nqp::lasterrno() or so

[20:14] <jnthn> Or something that makes clear the native call link

[20:14] *** cognominal left
[20:14] <pmichaud> or  nqp::ncerrno

[20:14] <moritz> which sounds decidedly non-threadsafe

[20:14] <jnthn> +1

[20:15] <jnthn> moritz: errno is thread safe itself afaikl; if our storage of it were to be thread local too it should be OK

[20:15] <hoelzro> well, isn't errno already thread-specific?

[20:15] <pmichaud> rn: say RangeIter

[20:15] <p6eval> niecza v24-35-g5c06e28: OUTPUT«(RangeIter)␤»

[20:15] <p6eval> ..rakudo ce914f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    RangeIter used at line 1␤␤»

[20:17] <jnthn> RangeIter vanished from Rakudo as part of the immutable iterator changes, iirc?

[20:17] <moritz> aye; Range became its own iterator

[20:18] *** dvj joined
[20:19] *** domidumont left
[20:21] <jnthn> pmichaud: At some point in the not too distant future, it'd be interesting to discuss how to integrate the NQP JVM work into the nqp repo itself, and how we want to organize those kinds of things.

[20:21] <jnthn> pmichaud: Not suggesting now, but I think we'll want it to happen in April.

[20:21] <jnthn> pmichaud: So thought it'd be good to push it onto your mental stack :)

[20:22] <grondilu> rn: .say for "AUAU".match: /^ A .* U .* /, :g

[20:22] <p6eval> rakudo ce914f: OUTPUT«｢AUAU｣␤␤»

[20:22] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«Unhandled exception: Excess arguments to Cool.match, unused named g␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Cool.match @ 1) ␤  at /tmp/gM_RHAptut line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6…

[20:22] *** cognominal joined
[20:24] <grondilu> rn: say .[0, 1] for "ACUGACU".match: /^ A (.*) U (.*) /, :g

[20:24] <p6eval> rakudo ce914f: OUTPUT«｢CUGAC｣␤ ｢｣␤␤»

[20:24] <p6eval> ..niecza v24-35-g5c06e28: OUTPUT«Unhandled exception: Excess arguments to Cool.match, unused named g␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Cool.match @ 1) ␤  at /tmp/OUfloAX4JJ line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4299 (ANON @ 3) ␤  at /home/p6…

[20:24] *** Rix joined
[20:25] <grondilu> r: say .[0, 1].join: ":" for "ACUGACU".match: /^ A (.*) U (.*) /, :g

[20:25] <p6eval> rakudo ce914f: OUTPUT«CUGAC:␤»

[20:25] * grondilu was expecting two matches

[20:26] <moritz> the .* gobbles up everything

[20:26] <jnthn> Try .*?

[20:26] <dalek> rakudo/nom: ff346ad | pmichaud++ | src/core/ (2 files):

[20:26] <dalek> rakudo/nom: Throw exception when Range endpoint is used to create a Range.

[20:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ff346adf59

[20:26] <dalek> roast: 01d1162 | pmichaud++ | S03-operators/range (2 files):

[20:26] <dalek> roast: Update spectests for Range endpoint exceptions.

[20:26] <dalek> roast: review: https://github.com/perl6/roast/commit/01d1162538

[20:26] <grondilu> r: say .[0, 1].join: ":" for "ACUGACU".match: /^ A (.*) U (.*) /, :overlap

[20:26] <p6eval> rakudo ce914f: OUTPUT«CUGAC:␤»

[20:27] <grondilu> r: say .[0, 1].join: ":" for "ACUGACU".match: /^ A (.*?) U (.*?) /, :overlap

[20:27] <p6eval> rakudo ce914f: OUTPUT«C:␤»

[20:27] <moritz> grondilu: and with ^ you can only ever get one match

[20:27] <moritz> (except with :exhaustive)

[20:28] <grondilu> r: say .[0, 1].join: ":" for "ACUGACU".match: /^ A (.*?) U (.*?) /, :exhaustive

[20:28] <p6eval> rakudo ce914f: OUTPUT«C:␤C:G␤C:GA␤C:GAC␤C:GACU␤CUGAC:␤»

[20:28] <dalek> specs: 2be5306 | pmichaud++ | S32-setting-library/Exception.pod:

[20:28] <dalek> specs: (S32/Exceptions)  Add X::Range::InvalidArg exception.

[20:28] <dalek> specs: review: https://github.com/perl6/specs/commit/2be530687e

[20:30] <pmichaud> jnthn: (nqp jvm) I figure you've given some thought to it already, so I'm fairly willing to follow your lead.  By then I hope to be regularly building (and maybe hacking) on the jvm stuff, so I may be of more help then.

[20:31] *** kurahaupo left
[20:32] <jnthn> pmichaud: OK. Mostly just knowing things you consider desirable/unwanted in what I do there is what I'm after.

[20:33] <jnthn> pmichaud: My current thought is to try and segregate backend-specific stuff into some src/backend/

[20:33] <jnthn> pmichaud: Thought maybe we want backend/jvm/... 

[20:33] <jnthn> So we can have src/, t/ (to segregate the tests also specific to each)

[20:36] <pmichaud> segregate backend stuff +1

[20:36] <hoelzro> if I were to add nqp_posix_errno, what would it do on Windows?

[20:37] <pmichaud> hoelzro: whatever other languages/systems do for errno under windows

[20:37] <jnthn> hoelzro: http://msdn.microsoft.com/en-us/library/5814770t.aspx

[20:37] <hoelzro> got it

[20:37] <pmichaud> also, prefer  nqp_posixerrno  for the Parrot opcode name, to correspond with nqp::posixerrno

[20:38] <pmichaud> (underscore consistency)

[20:38] <jnthn> and perhaps more helpfully, http://msdn.microsoft.com/en-us/library/t3ayayh1.aspx

[20:38] <hoelzro> ok, sounds good!

[20:42] <pmichaud> I'm afk again... bbl or bbt

[20:44] <jnthn> o/

[20:46] *** grondilu left
[20:53] *** wk__ left
[20:58] <masak> Rakudo release is on Thursday. we haven't assigned a release manager.

[20:58] <masak> in fact, there aren't any release managers assigned for the upcoming releases.

[20:59] <masak> let's make the regular deal -- I'll sign up for a release, if someone else steps forward and signs up for one. ;)

[20:59] <jnthn> Sign up, sign up! You, yes you, could be the person who gets to relesae the first Rakudo release with JVM support!

[20:59] <masak> I'll take it! :D

[21:00] * masak signs up for March

[21:00] <jnthn> But you don't know which one it is!

[21:00] <jnthn> Uh. :P

[21:00] <jnthn> That's the gamble. You gotta pick a month. :)

[21:00] <hoelzro> I assume NQP has a parallel release?

[21:00] <masak> jnthn: I'm picking March!

[21:00] <jnthn> Yes.

[21:00] <jnthn> masak: :)

[21:01] <hoelzro> is there a cut-off date for this month's release?

[21:01] <dalek> rakudo/nom: a323a31 | masak++ | docs/release_guide.pod:

[21:01] <dalek> rakudo/nom: [docs/release_guide.pod] grab March

[21:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a323a31ccb

[21:01] <jnthn> masak: That's especially silly given you know that I have one week of Rakudo time before I have a week's mostly afk vacation :)

[21:01] <masak> hoelzro: it's always on the Thursday after the third Tuesday on the month.

[21:01] <masak> jnthn: what are you still doing standing here talkin'? get to work! :P

[21:02] <hoelzro> masak: so as long as the change is in Git on Thursday, it goes out?

[21:02] <jnthn> You want MOAR COMMITS from me?!

[21:02] <jnthn> :P

[21:02] <masak> jnthn: dude, I'm not asking you to do more than you're already doin'... :)

[21:03] <masak> we're all so excited about the JVM, is all.

[21:03] <masak> still no volunteer for April? sheesh, lurkers.

[21:03] <colomon> \o/  \o/  \o/

[21:04] <dalek> rakudo/nom: c22a391 | jnthn++ | src/Perl6/ModuleLoader.pm:

[21:04] <dalek> rakudo/nom: More pir:: => nqp:: in ModuleLoader.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c22a3913f3

[21:04] <dalek> rakudo/nom: d00a575 | jnthn++ | src/Perl6/World.pm:

[21:04] <dalek> rakudo/nom: A couple of pir:: => nqp:: in Perl6::World.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d00a57513f

[21:04] <dalek> rakudo/nom: e7f9bdd | jnthn++ | src/Perl6/Compiler.nqp:

[21:04] <dalek> rakudo/nom: Last pir:: in Perl6::Compiler.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e7f9bdd141

[21:04] <dalek> rakudo/nom: d98dd54 | jnthn++ | src/Perl6/Metamodel/ (7 files):

[21:04] <dalek> rakudo/nom: Some pir:: => nqp:: in the MOP.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d98dd54f01

[21:04] <arnsholt> I'm not gonna sign up for April =)

[21:04] <arnsholt> It'd be cool, but with teaching duties and article deadline in late April, I don't think it'd be prudent =)

[21:04] * masak .oO( un-vol-teer )

[21:04] <arnsholt> Neat one!

[21:05] <masak> I'll etym your ology!

[21:05] <sorear> good *

[21:05] <arnsholt> =D

[21:05] <arnsholt> 'lo sorear

[21:05] <nwc10> how much pir:: is left in Rakudo? And how much C?

[21:06] <masak> sorear! \o/

[21:06] <arnsholt> Not a lot of PIR I think

[21:06] <arnsholt> IIRC most of the C code was multi-dispatch as well =)

[21:07] * arnsholt makes a pot of tea

[21:07] <jnthn> nwc10: Sadly, numerical metrics aren't too infornative here.

[21:07] <jnthn> nwc10: Some things are much easier to make portable than others.

[21:08] <jnthn> One big problem that arnsholt is about to run straight into, that also needs solving for the JVM stuff, is that we've used "that's a Parrot type, not a 6model one" to differentiate the NQP/Rakudo boundary in a bunch of places.

[21:08] *** wk_ joined
[21:08] <arnsholt> Oh. That's no fun =/

[21:08] <jnthn> And over in JVM land, every object we touch is a 6model one. And NQP on Parrot is getting more that way once we do the NQPArray thing.

[21:09] <jnthn> So that needs solving properly before the serious porting efforts go on.

[21:09] <arnsholt> Yeah. I'm hoping once I get this VMArray stuff working, moving over the rest of the NQP* stuff wil mostly be a question of implementing the REPRs

[21:10] <jnthn> Container stuff needs a look, but that's been the case for a long while, not just because of the JVM stuff. Of note, the whole "is rw" with natives interaction.

[21:11] <jnthn> gather/take needs a LOT of distilled alco^W^W^W^Wbit of careful effort to do the rest of the continuations through exceptions as a stack iterator mechanism.

[21:11] <jnthn> And there's still small matter of the binder and how the heck we can try to organize things there to be able to take advantage of invokedynamic.

[21:12] <jnthn> The last one of those aside, neither of these equate to huge numbers of pir:: or lines of C code, but they're the conceptually tricky areas.

[21:14] *** MayDaniel left
[21:15] <nwc10> yes. they sound it. thanks for that explanation

[21:15] <jnthn> np :)

[21:15] <jnthn> None of them are things I look at and think "omg, how on earth can it be done". :) But none of them are "yeah, I'll nail it in an afternoon" either :)

[21:16] <nwc10> yes, they all sound do-able. But big

[21:18] *** Kurahaupo_ left
[21:18] *** kurahaupo joined
[21:20] <arnsholt> jnthn: Does that mean the vmarray stuff should live in its branch until you figure that stuff out properly?

[21:21] <arnsholt> Oooh, this time the compilation gets to stage2 before crapping out \o/

[21:25] <jnthn> arnsholt: I suspect at least the NQPArray aspects of it will have to

[21:25] <arnsholt> Right, right

[21:26] <arnsholt> Any pointers on how to track down a Parrot-level ("Null PMC access in assign_pmc()") error, BTW?

[21:27] <jnthn> Not besides looking at the stack trace.

[21:27] <jnthn> That's a slightly unusual thing to be doing, though.

[21:27] <jnthn> (Not many things do the assign PMC thing0

[21:28] <arnsholt> Thinking for a bit I think it's in my new nqp::list, since it does: $ops.push_pirop('assign', $list_reg, $arr);

[21:28] <arnsholt> Of course, that may be entirely the wrong thing

[21:28] <jnthn> Should be set

[21:29] <jnthn> not assign

[21:29] <arnsholt> Right. I wasn't quite sure which one was right from looking at the opcode descriptions

[21:29] <jnthn> well, I'm guessing without context, but it seems a decent guess :)

[21:30] <arnsholt> Now that you mention set I remember being unsure about the two, so it seems a plausible option

[21:31] <arnsholt> Any objections to removing qlist entirely, BTW?

[21:31] <dalek> perl6-examples: 9ae6e4c | (L. Grondin)++ | rosalind/dna-grondilu.pl:

[21:31] <dalek> perl6-examples: [rosalind] DNA

[21:31] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/9ae6e4ca4e

[21:32] <arnsholt> It's not used at all in NQP AFAICT, and only two occurences (in one file) in Rakudo

[21:36] *** grondilu joined
[21:36] <jnthn> I suspect its usage in those places is important for efficiency.

[21:37] <jnthn> I'd leave it for now and we remove it once we get NQPArray in place; VMArray uses the QRPA storage strategy so it should be fine for all the usages.

[21:37] <arnsholt> Yeah, that's what I thought

[21:38] <arnsholt> I figured I'd remove it once I get the nqp::list stuff working (since then nqp::list will operate like a QRPA)

[21:39] <arnsholt> But first, figure out why I get Null PMC in push

[21:40] *** bruges left
[21:40] * arnsholt tells the compiler to insert some print statements

[21:41] *** bruges joined
[21:43] *** quester left
[21:43] <arnsholt> jnthn: It seems my nqp::list returns a null PMC

[21:45] <jnthn> Do you set a .result on the PIRT::Ops at some point?

[21:46] <arnsholt> Oh, that's probably what I'm doing wrong

[21:47] <arnsholt> I do "$ops.push_pirop('set', $list_reg, $list);", but list is just "$qastcomp.as_post(QAST::Op.new(:op('list')));"

[21:47] <arnsholt> I guess it should be $list.result?

[21:49] <jnthn> The result is the register that the overall set of operations should evaluate to

[21:51] <arnsholt> Hang on, lemme paste you the code

[21:52] *** domidumont joined
[21:53] *** kaare__ left
[21:53] <arnsholt> jnthn: https://gist.github.com/arnsholt/5178485

[21:53] <arnsholt> nqp::hlllist just returns the BOOTArray type for the time being

[21:54] <arnsholt> The Null PMC is in the push in list_b

[21:55] <jnthn> arnsholt: You never do $ops.push($arr)

[21:55] <jnthn> At least, not before you try to use the result

[21:55] <arnsholt> Oh, derp

[21:55] <jnthn> :)

[21:56] <arnsholt> Won't work unless I actually execute it, will it? =D

[21:56] <jnthn> Suspect not ;-)

[22:02] <arnsholt> "elements() not implemented in class 'SixModelObject'" \o/

[22:03] <arnsholt> Right. About time to make some sort of commit, I think

[22:05] <arnsholt> jnthn: Do you have any specific wants for how sethllconfig should be implemented on NQP/Parrot, BTW?

[22:06] <jnthn> arnsholt: I think there needs to be a similar mechanism to on the JVM. The subtlety in it all is really timing, I discovered...

[22:07] <jnthn> arnsholt: You only want to create the underlying state for a HLL once. Even if that first time is a request for it.

[22:07] <jnthn> arnsholt: So the sethllconfig may be updating something already existing.

[22:07] <jnthn> arnsholt: That's 'cus other things may take direct references to it.

[22:08] <arnsholt> Right

[22:08] <pmichaud>  /msg p6eval r: say 1 .. ^10

[22:08] <jnthn> arnsholt: The stuff I've got sketched in my notebook (but I need to sanity review it) was that we'll let STables carry a "which HLL owns this type" and that we'll use that 

[22:08] <jnthn> pmichaud: fail!

[22:08] <pmichaud> fail :-)

[22:09] <pmichaud> r: say 1 .. ^10

[22:09] <p6eval> rakudo d98dd5: OUTPUT«Range objects are not valid endpoints for Ranges␤  in method new at src/gen/CORE.setting:5297␤  in method new at src/gen/CORE.setting:5289␤  in sub infix:<..> at src/gen/CORE.setting:5480␤  in block  at /tmp/CrPoRAfcBQ:1␤␤»

[22:09] <pmichaud> \o/

[22:09] <jnthn> pmichaud++

[22:09] <jnthn> arnsholt: uh, that we'll use that for answering the questions we answer with "it's a non-6model thing" today.

[22:10] <arnsholt> Right, right. That sounds like it makes sense

[22:10] <masak> pmichaud++

[22:10] <jnthn> This should also help me deal with the various other nasties when NQP objects leak into Rakudo land.

[22:10] <jnthn> r: say Sub.^methods

[22:10] <p6eval> rakudo d98dd5: OUTPUT«No such method 'gist' for invocant of type 'Sub'␤  in method gist at src/gen/CORE.setting:5165␤  in method gist at src/gen/CORE.setting:902␤  in sub say at src/gen/CORE.setting:7634␤  in block  at /tmp/oov_9VMT9t:1␤␤»

[22:10] <jnthn> That one, for example.

[22:11] <arnsholt> Yeah, explicitly keeping track of that sounds like a good idea

[22:13] <jnthn> pmichaud: One interesting consequence of developments in the last few months is that we can make Parcel know to delegate positional operations to an underlying storage

[22:14] <jnthn> pmichaud: So we'll be able to nqp::atpos(...) directly on the Parcel, which'll clean up some code.

[22:14] *** SamuraiJack_ left
[22:23] *** domidumont left
[22:27] *** Exodist joined
[22:27] *** census left
[22:29] *** census joined
[22:30] <arnsholt> jnthn: Is there a principle which decides which vtables in sixmodelobject.pmc need to decontainerize their SELF first?

[22:30] *** rindolf left
[22:31] <jnthn> arnsholt: All but those doing attribute lookup/binding.

[22:31] <jnthn> (get_attr/set_attr)

[22:32] <arnsholt> Excellent. Thanks!

[22:32] <masak> just to repeat: 'decontainerize' means "strip away the container and look at the underlying value"?

[22:32] <jnthn> Yes

[22:33] <jnthn> Spoiler: I'm going to incorporate the assignment bit of things into the protocol container spec stuff too.

[22:33] <jnthn> s/protocol //

[22:34] <arnsholt> I must admit decontainerization is still somewhat magical to me, still. I just know it's important to do =)

[22:34] <jnthn> r: my $a = 42; my $b := 42;

[22:34] <p6eval> rakudo d98dd5:  ( no output )

[22:34] <jnthn> In the above, $a in the lexpad contains a Scalar, which we put at 42 in

[22:35] <jnthn> By contrast, $b points straight to 42

[22:35] <jnthn> When we do $a.sin, we mean the thing inside of the container.

[22:36] <jnthn> Decontainerization makes sure we remove the container.

[22:39] *** yoleaux left
[22:39] *** yoleaux joined
[22:39] <arnsholt> That's odd. It says that "get_bool() not implemented in class 'SixModelObject'", but it's clearly there...

[22:41] <arnsholt> Unless that's the error you get if the 6model thingy does say how to be boolified

[22:41] <masak> I've always felt there's something odd about the word "Scalar" there. seems like a category error of sorts.

[22:42] <masak> now I think I know what it is. it should be called "Item" or "Container".

[22:42] <masak> the scalar (a string or a number or a reference to something) is what you store *inside* the container.

[22:43] <arnsholt> jnthn: Next time we meet, remind me to buy you a beer =)

[22:47] <dalek> perl6-roast-data: 1d939a0 | coke++ | / (4 files):

[22:47] <dalek> perl6-roast-data: today (automated commit)

[22:47] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1d939a0a82

[22:49] * masak .oO( The Perl 6 community is a machine that turns volunteers into beer for jnthn, who turns it into commits )

[22:49] <arnsholt> Indeed

[22:49] <jnthn> .oO( I thought beer was made out of malt and hops and stuff... )

[22:50] <arnsholt> jnthn++ # Commits and stuff

[22:50] <arnsholt> Soylent beer is people!

[22:51] <dalek> perl6-most-wanted: 6bf2646 | (Pawel Pabian)++ | most-wanted/bindings.md:

[22:51] <dalek> perl6-most-wanted: Added GeoIP.

[22:51] <dalek> perl6-most-wanted: 

[22:51] <dalek> perl6-most-wanted: Supports paid and free Geo City databases from MaxMind. Tested under OS X and Ubuntu Linux.

[22:51] <dalek> perl6-most-wanted: review: https://github.com/perl6/perl6-most-wanted/commit/6bf2646416

[22:51] <arnsholt> Only tangentially related to anything, I love how git makes it easy to speculatively hack away on something, and then pack it into sensible commits later

[22:55] <masak> git packages the insight that learning happens during development into commands that help you factor that learning into (private) history.

[22:55] <masak> 'night, #perl6

[22:55] <jnthn> Git is very good at letting you bring order to naturally messy/explorative development :)

[22:56] <arnsholt> 'night masak

[22:56] <arnsholt> See you tomorrow

[22:56] <jnthn> o/ masak

[22:56] * masak .oO( not if I accidentally mail you private correspondence first! )

[22:57] <masak> zzz &

[23:06] *** PacoAir left
[23:06] <jnthn> [Coke]: I'm curious about the two new failures

[23:10] *** yoleaux left
[23:10] *** yoleaux joined
[23:10] *** yoleaux left
[23:11] *** yoleaux joined
[23:12] *** spider-mario left
[23:18] <arnsholt> jnthn: "get_iter() not implemented in class 'SixModelObject'", I guess this means I get to implement VMIter as well? =)

[23:18] <jnthn> Oh my... :)

[23:19] <jnthn> Well, things are certainly all set up so doing things that way will work, thanks to the fact NQP-JVM does that.

[23:20] <arnsholt> Except VMIter might not speak the same iteration protocol as Parrot expects?

[23:20] <jnthn> It's close enough

[23:21] <jnthn> Note that NQPCORE in JVM defines a little glue to make things work out, especially for the Hash iteration

[23:21] <jnthn> And the MOP is factored in terms of ops that don't expect that sugar

[23:21] *** cognominal left
[23:23] <arnsholt> The stuff in NQPCORE being ArrayIter and HashIter?

[23:23] <jnthn> yes

[23:24] <jnthn> Essentailly, the stuff over in NQPJVM defines a 6model factoring of pretty much everything NQP uses

[23:26] <arnsholt> Which makes sense, now that we're targeting multiple backends

[23:28] *** diakopter joined
[23:28] <jnthn> Yeah. It's very much closer to "how to do it".

[23:28] <jnthn> I'm happy to have NQP on Parrot converge that way.

[23:29] *** cognominal joined
[23:30] *** diakopter left
[23:30] *** diakopter joined
[23:32] <arnsholt> So, this is fun. parrot/src/pmc/arrayiterator.c claims to be generated from parrot/src/pmc/arrayiterator.pmc. Of course, that file doesn't exist

[23:33] <jnthn> huh, it does here...

[23:35] <arnsholt> Maybe I did something weird

[23:36] *** jaldhar left
[23:36] <arnsholt> Apparently git has never heard of the file...

[23:36] *** _jaldhar joined
[23:37] <jnthn> arnsholt: Knowte that the parrot dir is a different repo

[23:37] <arnsholt> Maybe I've done something odd to my parrot tree

[23:37] <jnthn> uh, note

[23:37] <jnthn> ...weird typo

[23:37] <arnsholt> Yeah, this is while inside the Parrot repo

[23:37] <jnthn> oh. Then...weird

[23:38] <arnsholt> I think I'll try with a fresh checkout

[23:38] <arnsholt> Whoa, that was quick. rm -rf parrot/ install/ usually takes a while. Yay SSD! =)

[23:41] <arnsholt> jnthn: NQP/JVM has an op called iter, while NQP/Parrot has iterator. Intentional or typo?

[23:42] <jnthn> QAST::OperationsJAST.map_classlib_core_op('iterator', $TYPE_OPS, 'iter', [$RT_OBJ], $RT_OBJ, :tc);

[23:42] <jnthn> It ended up getting called iter in Ops.java somehow

[23:42] <jnthn> But it's exposed as nqp::iterator

[23:42] <arnsholt> Oh, right. Never mind me, then =)

[23:43] <jnthn> Feel free to consistentize it. :)

[23:43] *** cognominal left
[23:43] <arnsholt> It's consistent with Parrot though =)

[23:43] <arnsholt> The native pirop is called iter, after all

[23:44] <jnthn> ah, and if I added it when porting 'for'...

[23:44] *** dpk joined
[23:50] <arnsholt> There. Now I have arrayiterator.pmc

[23:51] *** _jaldhar left
[23:51] *** census_ joined
[23:52] *** census_ left
[23:53] *** census left
[23:54] *** census joined
[23:54] *** _jaldhar joined
