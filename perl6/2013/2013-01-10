[00:00] <jnthn> Ah, I see

[00:00] <jnthn> Any defaults will be set

[00:00] <jnthn> r: class Foo { has $.a = 'lol'; submethod BUILD() { say 42; } }; Foo.new.a.say;

[00:00] <p6eval> rakudo e26703: OUTPUT¬´42‚ê§lol‚ê§¬ª

[00:01] <jnthn> Unless you explicitly touch them in your BUILD

[00:01] <jnthn> r: class Foo { has $.a = 'lol'; submethod BUILD() { $!a = 'omgz'; } }; Foo.new.a.say;

[00:01] <p6eval> rakudo e26703: OUTPUT¬´omgz‚ê§¬ª

[00:02] <jnthn> r: class Foo { has $.a; submethod BUILD() { } }; Foo.new.a.say;

[00:02] <p6eval> rakudo e26703: OUTPUT¬´Any()‚ê§¬ª

[00:02] <jnthn> You just get that if you never initialize the attribute

[00:03] <bbkr> I find this BUILD more user friendly than P5 Moose BUILDARGS+BUILD approach

[00:03] <perigrin> r: class Foo { has Foo $.a; submethod BUILD () }; Foo.new.a.say;

[00:03] <p6eval> rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/fjdaMotsxl:1‚ê§------> [32ms Foo { has Foo $.a; submethod BUILD () [33m‚èè[31m}; Foo.new.a.say;[0m‚ê§    expecting any of:‚ê§        scoped declarator‚ê§        constraint‚ê§        postfix‚ê§        infix or meta-infix‚ê§  ‚Ä¶

[00:04] <perigrin> bah 

[00:04] <perigrin> r: class Foo { has Foo $.a; submethod BUILD () {} }; Foo.new.a.say;

[00:04] <p6eval> rakudo e26703: OUTPUT¬´Foo()‚ê§¬ª

[00:04] <timotimo> r: class Foo { has $.a; submethod BUILD() { say $.a } }; Foo.new.a.say;

[00:04] <p6eval> rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Virtual call $.a may not be used on partially constructed objects‚ê§at /tmp/FwUvCK26Ov:1‚ê§------> [32mo { has $.a; submethod BUILD() { say $.a[33m‚èè[31m } }; Foo.new.a.say;[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        prefix‚Ä¶

[00:04] <bbkr> timotimo: you have to use $!a

[00:04] <timotimo> oh, that's the trick?

[00:04] <jnthn> Use $!a; $.a is a method call and if you get subclassed then somebody may override it and break your initialization.

[00:05] <perigrin> bbkr: BUILDARGS+BUILD really is a hack because we didn't have the right places to hook into things due to Moose happening at Runtime.

[00:05] <jnthn> If you use $!a that can't happen. Even if their subclass has its own $!a.

[00:05] <timotimo> that's a good hint, thanks!

[00:07] *** skids joined
[00:13] <bbkr> perigrin: I know. And I don't call it a "bad design" - it is as good as it can be. And BUILDAGRS can give huge boost when you know how to use it.

[00:14] * perigrin nods.

[00:18] <bbkr> perigrin: For example I have tons of ORM-like objects which I initialize in "Client->new(id=>3)" way. Then I fetch record from database in BUILDARGS and pass-through it to SUPER::BUILDARGS. This way I can have all attributes in Client class as read-only (faster) and it is 40% faster than initializing attributes in BUILD.

[00:20] <timotimo> r: say "a"; map (-> $x { say $x }), ^4; say "b";

[00:20] <p6eval> rakudo e26703: OUTPUT¬´a‚ê§0‚ê§1‚ê§2‚ê§3‚ê§b‚ê§¬ª

[00:20] <timotimo> locally, i get only a and b.

[00:21] <timotimo> and i don't know why.

[00:21] <timotimo> if i write "sink" before the map, it does work, however

[00:22] <bbkr> timotimo: works for me on HEAD Rakudo built 3 hours ago

[00:27] <jnthn> timotimo: That didn't work in the last Rakudo release, I suspect. This is why we implemented sink context... :)

[00:31] <timotimo> oh, what, this rakudo is old?!

[00:31] <timotimo> well, gotta run anyway

[00:31] <timotimo> and then sleep. good ** perl6 :)

[00:32] <jnthn> o/

[00:32] <bbkr> I would love to see blogpost explaining sink context in nearest future.

[00:34] *** bitonic left
[00:35] <perigrin> bbkr: yeah that would do it.

[00:35] <perigrin> though I do ro not for speed but because mutability is the devil.

[00:39] *** xinming joined
[00:40] <bbkr> This is completely new approach and I assume many users will misunderstand "sink context" because "context" word is strongly associated with "wantarray" behavior in p5.

[00:41] <TimToady> sink context is the same as void context in P5

[00:45] <TimToady> wantarray went away because list vs item is lazily determined; sink, however, is eager by definition, so can flow downhill

[00:51] <TimToady> (as can eager, with its variants hyper and race)

[00:52] <japhb_> BTW, I very much like that Perl 6 allows me to specify different levels of "hurry up".  I wish I could do that in other contexts ... no pun intended, believe it or not.  :-)

[00:54] *** am0c joined
[00:56] <bbkr> TimToady: i think most programmers do not understand void/sink context idea and cannot use it intentionally, so article that will explain it on simple examples would be valuable.

[00:59] <bbkr> for example very common p5 warning 'use warnings; "a" ~~ /(a)/; print $1' is misunderstood. most people who googled for it are like "why void context warning? it was not useless smart match after all"

[01:00] <TimToady> eval: use warnings; "a" ~~ /(a)/; print $1

[01:00] *** am0c_ joined
[01:01] <TimToady> hmm

[01:01] <TimToady> ENOBUUBOT

[01:01] *** am0c_ left
[01:03] <TimToady> anyway, sink/void is used *only* to indicate that some procedural code is to be executed; the "Useless use of" warning is for when you're using immutable value semantics in sink context, which requires mutable semantics in order for whatever it is to have side effects

[01:03] <TimToady> since ~~ has side effects, it should not be emitting such a warning

[01:03] <TimToady> so, a p5 bug

[01:04] <TimToady> well, arguably a bug, but maybe they're indicating you should use =~ in that situation

[01:06] <bbkr> thanks for explanation :)

[01:06] <bbkr> good night perl6

[01:06] <TimToady> arguably in p6 ~~ should defer the warning to the rhs somehow

[01:06] <TimToady> night

[01:11] *** slayer101_ left
[01:12] *** anuby joined
[01:23] *** jeffreykegler joined
[01:25] *** hypolin joined
[01:26] *** jeffreykegler left
[01:30] <timotimo> turns out my rakudo really was from before last star :/

[01:30] <timotimo> but now that i noticed thar, i can do excellent tgings at last!

[01:30] *** raiph joined
[01:31] <raiph> TimToady: ping

[01:38] <raiph> phenny: tell TimToady are you aware there's a summary version of the #perl6 log? Might save you a few days...

[01:38] <phenny> raiph: I'll pass that on when TimToady is around.

[01:44] <japhb_> r: say [\] 1..10

[01:44] <p6eval> rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§You can't backslash that‚ê§at /tmp/slFpVO08KF:1‚ê§------> [32msay [\[33m‚èè[31m] 1..10[0m‚ê§    expecting any of:‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        prefix or term‚ê§        prefix or meta-prefix‚ê§¬ª

[01:44] <japhb_> r: say [\+] 1..10

[01:44] <p6eval> rakudo e26703: OUTPUT¬´1 3 6 10 15 21 28 36 45 55‚ê§¬ª

[01:45] *** whiteknight joined
[01:50] *** dayangkun left
[01:59] *** raiph left
[02:05] <jnthn> http://6guts.wordpress.com/2013/01/10/a-bunch-of-rakudo-news/ # blog post

[02:05] <jnthn> 'night, #perl6

[02:08] *** odoacre joined
[02:21] *** lichtkind left
[02:23] *** werwerwer_ joined
[02:23] *** werwerwer left
[02:27] *** whiteknight left
[02:36] *** japhb_ left
[02:46] *** cognominal left
[02:54] <dalek> specs: e5b8663 | larry++ | S06-routines.pod:

[02:54] <dalek> specs: --> as context for code body

[02:54] <dalek> specs: 

[02:54] <dalek> specs: Allow definite values and containers on the right side of -->, in

[02:54] <dalek> specs: order to make a way to declaratively distinguish procedural code from

[02:54] <dalek> specs: functional without creating more keywords like "proc" or "fun", which

[02:54] <dalek> specs: doesn't help distinguish methods.

[02:54] <dalek> specs: 

[02:54] <dalek> specs: Also allow warning on loops accidentally treated as functional maps

[02:54] <dalek> specs: due to lack of a return spec.

[02:54] <dalek> specs: review: https://github.com/perl6/specs/commit/e5b8663594

[02:56] <TimToady> Note that this is consistent with the change to STD some weeks ago.

[02:56] <phenny> TimToady: 01:37Z <raiph> tell TimToady are you aware there's a summary version of the #perl6 log? Might save you a few days...

[02:57] <TimToady> std: sub foo ( --> Nil ) { "I am a useless use of string in sink context" }

[02:57] <p6eval> std a8bc48f: OUTPUT¬´ok 00:00 44m‚ê§¬ª

[02:58] <TimToady> dinner &

[02:59] *** marloshouse_ left
[03:01] *** marloshouse joined
[03:07] *** dayangkun joined
[03:13] *** aindilis` joined
[03:17] *** cognominal joined
[03:40] *** libertyp1ime joined
[03:40] *** libertyp1ime left
[03:43] *** orafu left
[03:43] *** orafu joined
[04:15] *** anuby left
[04:20] *** woosley joined
[04:21] *** anuby joined
[04:49] *** sisar joined
[04:52] *** cognominal left
[05:11] *** SeaRobber_ joined
[05:16] *** _jaldhar joined
[05:18] *** Chillance joined
[05:19] *** skids left
[05:19] *** rindolf joined
[05:28] *** telex left
[05:30] *** slayer101_ joined
[05:33] *** rindolf left
[05:34] *** rindolf joined
[05:37] *** telex joined
[05:38] *** slayer101_ left
[05:40] *** slayer101_ joined
[05:42] *** tokuhiro_ joined
[05:45] *** LV joined
[05:49] *** slayer101_ left
[05:50] *** slayer101_ joined
[05:52] *** rindolf left
[05:53] *** rindolf joined
[05:55] *** slayer101_ left
[05:56] *** kaleem joined
[05:57] *** LV left
[05:57] *** LordVorp joined
[05:58] *** slayer101_ joined
[06:00] *** Chillance left
[06:06] *** cognominal joined
[06:08] *** sftp left
[06:09] *** sftp joined
[06:11] *** thou joined
[06:12] *** rindolf left
[06:13] *** rindolf joined
[06:19] <moritz> jnthn: I think that .sink works as expected in bbkr's example

[06:19] *** snarkyboojum joined
[06:19] <moritz> once for the nqp::can, once for the actual call

[06:20] *** PacoAir joined
[06:20] <moritz> we could certainly optimize it with a call-method-if-exists op that only does one find_method

[06:24] *** PacoAir left
[06:29] *** rindolf left
[06:29] *** rindolf joined
[06:43] *** FROGGS[mobile] joined
[06:43] <FROGGS[mobile]> morning

[06:45] *** tokuhiro_ left
[06:46] *** tokuhiro_ joined
[06:49] *** rindolf left
[06:49] *** rindolf joined
[06:49] *** SamuraiJack joined
[06:50] *** cognominal left
[06:51] *** tokuhiro_ left
[06:52] *** cognominal joined
[07:00] *** quester joined
[07:02] <tadzik> hello

[07:04] *** cognominal left
[07:06] <sorear> hello tadzik

[07:11] *** vm joined
[07:12] *** cognominal joined
[07:13] *** erkan joined
[07:13] *** erkan left
[07:13] *** erkan joined
[07:13] *** rindolf left
[07:14] *** rindolf joined
[07:33] *** rindolf left
[07:34] *** vm left
[07:34] *** rindolf joined
[07:34] *** aloha joined
[07:34] *** sisar left
[07:36] *** FROGGS joined
[07:39] <FROGGS> morning (again)

[07:40] *** FROGGS[mobile] left
[07:42] *** rindolf left
[07:42] *** aloha left
[07:43] *** aloha joined
[07:43] *** rindolf joined
[07:55] *** rindolf left
[07:55] *** rindolf joined
[07:56] *** PacoAir joined
[07:56] *** cognominal left
[08:00] *** PacoAir left
[08:02] <moritz> jnthn++ # blog post

[08:02] <moritz> TimToady++ # spec commit

[08:07] *** ServerSage joined
[08:12] *** rindolf left
[08:12] *** rindolf joined
[08:21] *** quester left
[08:23] <FROGGS> TimToady: do you think it is possible to change STD.pm6 in a way that I can use it to dump the GLOBAL symbols of a single file?

[08:24] <FROGGS> TimToady: I am trying to do this: https://github.com/FROGGS/p6-File-Inspector-Namespace

[08:24] <bbkr> good morning perl6

[08:25] <FROGGS> TimToady: ... because IMO we need something like this to fulfil the requirements given by S11/versioning, I can describe the problems and the need for it if you want to know

[08:26] *** rindolf left
[08:27] *** rindolf joined
[08:34] <FROGGS> moritz++ # $socket.read commit

[08:35] <moritz> testing of that commit would be very welcome and helpful

[08:35] <FROGGS> hmmm, that shouldnt be too hard

[08:38] <moritz> probably not

[08:38] <moritz> just do a read of 16k, and on the write site, 4 x 4k

[08:38] *** slayer101_ left
[08:38] <moritz> and check if the read actually returned 16k bytes

[08:40] <FROGGS> right

[08:44] *** wk joined
[08:44] *** wk is now known as Guest62890

[08:47] *** rindolf left
[08:47] *** rindolf joined
[08:49] <bbkr> i've already tested socket changes and everything works as expected. but I have no idea how to write spectestst for it without fork

[08:52] *** sqirrel joined
[08:53] <bbkr> also I've tested LWP::Simple affected by this bug on couple of sites and also everything works

[08:54] <FROGGS> cool

[08:55] <bbkr> so now only get() bug remains - https://rt.perl.org/rt3/Ticket/Display.html?id=116302 (affected Star module - HTTP::Easy)

[08:59] *** rindolf left
[08:59] *** grondilu joined
[09:00] *** rindolf joined
[09:01] <grondilu> couldn't I use $^ as a self-declared anonymous variable?   Like:   sub id { $^ };  say id "hello";

[09:02] <moritz> that's what $_ is for

[09:02] <moritz> erm, not in a sub

[09:02] <moritz> no

[09:04] *** erkan left
[09:05] *** bitonic joined
[09:07] <bbkr> I've just also tested few unicode cases - where chunk ends in the middle of multibyte char / read()ing multibyte char partially, etc. and also everything works. moritz++

[09:10] <bbkr> including cases where read param is bigger than available chars. and sleep on server side.

[09:10] <FROGGS> r: say 'abc'.substr( *-1 )

[09:10] <p6eval> rakudo e26703: OUTPUT¬´c‚ê§¬ª

[09:10] <FROGGS> n: say 'abc'.substr( *-1 )

[09:10] <p6eval> niecza v24-16-g89e47b6: OUTPUT¬´c‚ê§¬ª

[09:13] *** dayangkun left
[09:15] *** kaleem_ joined
[09:16] <Woodi> morning #perl6 :)

[09:18] <Woodi> bbkr: I just thinked, what are danger corners for utf8 'parsing' ? eg. http://www.cprogramming.com/tutorial/unicode.html is simple lib for utf8 but described as not quite secure and for 'internals' only...

[09:19] *** kaleem left
[09:19] *** kaleem joined
[09:20] <Woodi> looks utf8 is dangerous as file paths and html...

[09:22] *** kaleem_ left
[09:22] *** rindolf left
[09:22] *** rindolf joined
[09:24] <bbkr> Woodi: I'm not sure that the described dangers are an issue in a language that distinguish Buf and Str types with internal utf8 representation of Str type and strict Buf->Str decode

[09:25] *** cognominal joined
[09:27] *** rindolf left
[09:28] *** rindolf joined
[09:28] <bbkr> Woodi: in C you have just *char for both buffers and strings, charset information is not passed along with it, that's why it may get messy when it is passed from unicode aware method to not-aware one

[09:29] *** erkan joined
[09:29] *** erkan left
[09:29] *** erkan joined
[09:29] <Woodi> I just looked for "internal utf8 repr of Str" but looks bigger libraries just use int32 internally so not realy 'internal utf8'...

[09:31] *** dakkar joined
[09:34] *** SamuraiJack left
[09:42] *** Psyche^ joined
[09:45] <FROGGS> bbkr: my socket.read test is done, just need to recheck

[09:45] *** Patterner left
[09:45] *** Psyche^ is now known as Patterner

[09:46] *** rindolf left
[09:46] *** rindolf joined
[09:48] <jnthn> morning o/

[09:51] <arnsholt> o/

[09:52] <moritz> \o

[09:54] <arnsholt> jnthn: Speaking of the JVM stuff, chromatic said something about an "impedance mismatch due to a foreign memory model" (quoting from memory) in a recent missive. Do you have any idea what he might be referring to?

[10:02] *** cibs left
[10:03] <jnthn> Not exactly, but since the place we worry most about the memory model is REPRs, I guess we could try and weigh up whether the statement is correct by seeing how well things are going on the JVM implementation of 6model from that angle.

[10:04] *** hypolin left
[10:05] <jnthn> Given that my JVM 6model implementation's P6opaque probably already represents objects more efficiently than the 6model on Parrot one, I think we can conclude that whatever impedance mismatch we have on the JVM, it's smaller than the Parrot one we already have.

[10:05] <jnthn> (With regard to memory model, that is.)

[10:05] <arnsholt> That's definitely an interesting data point

[10:06] *** rindolf left
[10:06] *** rindolf joined
[10:06] <nwc10> does the JVM offer a richer primitive type system? In that, as I understand it, Parrot is "INTVAL", "NUMVAL", String and PMC (and the last 2 are effectively just pointers to something)

[10:07] <arnsholt> I think JVM has a bit more

[10:07] <jnthn> nwc10: A bit more.

[10:07] <arnsholt> float and double at least, and int

[10:07] <arnsholt> But not signed/unsigned

[10:07] <moritz> before I read jnthn++'s explanation, I'd thought that parrot gives us the option to use un-GCed memory, and java doesn't

[10:07] <arnsholt> And byte?

[10:07] <nwc10> and you can't be sure whether INTVAL is 32 or 64 bits. And NUMVAL is probably a 64 bit IEEE float

[10:07] <jnthn> Yes, byte

[10:08] <moritz> and that might or might not be relevant

[10:08] <nwc10> you can build small things from bytes. (Not sure how often that ends up being useful)

[10:08] <jnthn> moritz: Even the JVM has an escape hatch there, but so far I've not needed to use it. Unmanaged stuff probably gets in the way of a bunch of analysis.

[10:08] *** SmokeMachine joined
[10:09] <moritz> new java versions offer unsigned arithmetics, iirc

[10:09] <jnthn> It's true that there's no stack allocation exposed BUT any modern JVM will be doing escape analysis and turning some heap allocations into stack ones anyway.

[10:09] <moritz> so I guess that new JVMs have optimizations for it

[10:09] <arnsholt> Oh, neat!

[10:11] <moritz> https://blogs.oracle.com/darcy/entry/unsigned_api

[10:13] *** cibs joined
[10:13] <jnthn> OK, I gotta do some $dayjob bits for a while. :)

[10:23] *** anuby left
[10:25] *** rindolf left
[10:25] *** rindolf joined
[10:44] * arnsholt is becoming increasingly proficient at wrangling Makefiles

[10:44] <arnsholt> This may or may not be a good thing ^_^

[10:44] <moritz> it's certainly helpful

[10:46] <arnsholt> That's certainly true

[10:47] *** rindolf left
[10:47] *** rindolf joined
[11:00] *** rindolf left
[11:01] *** rindolf joined
[11:01] <dalek> roast: bbc7541 | (Tobias Leich)++ | S32-io/IO-Socket-INET. (2 files):

[11:01] <dalek> roast: RT #116288, test that $socket.read will give us the whole cake

[11:01] <dalek> roast: 

[11:01] <dalek> roast: Even if .recv will get several chunks, read will concatenate all these.

[11:01] <dalek> roast: review: https://github.com/perl6/roast/commit/bbc7541d91

[11:03] <jnthn> .oO( the WHOLE cake? accidentally? )

[11:05] <FROGGS> jnthn: whats wrong with it?

[11:05] <FROGGS> ahh

[11:06] <FROGGS> like whole-grain cake

[11:06] <FROGGS> bah

[11:07] *** thou left
[11:09] <dalek> roast: 033cbc9 | (Tobias Leich)++ | S32-io/IO-Socket-INET. (2 files):

[11:09] <dalek> roast: RT #116288, linked ticket to test case

[11:09] <dalek> roast: review: https://github.com/perl6/roast/commit/033cbc9a88

[11:13] *** rindolf left
[11:14] *** rindolf joined
[11:17] *** kresike joined
[11:17] <kresike> hello all you happy perl6 people

[11:17] <tadzik> kresike! \o/

[11:17] <kresike> tadzik, o/

[11:23] *** dayangkun joined
[11:26] *** SamuraiJack joined
[11:32] *** rindolf left
[11:33] *** rindolf joined
[11:35] *** SamuraiJack left
[11:41] *** MayDaniel joined
[11:59] *** dayangkun left
[12:10] *** SamuraiJack joined
[12:12] *** dayangkun joined
[12:13] *** SeaRobber_ left
[12:27] *** _jaldhar left
[12:33] <FROGGS> moritz: do you wanna close it? https://rt.perl.org/rt3/Ticket/Display.html?id=116288

[12:41] <moritz> FROGGS: I want to give .read a default buffer size first

[12:42] <moritz> hanging on .read() isn't good

[12:43] <FROGGS> you mean if I dont supply the desired bytes to read?

[12:43] <moritz> yes

[12:44] <moritz> if you don't know how many bytes to read, you just use .recv

[12:45] <FROGGS> is there a flag from the server that tells one that the received data is just a chunk and that there is more (later) ?

[12:45] <moritz> well, there's .eof

[12:45] <moritz> (if the client closes the connection after sending the last chunk)

[12:46] <FROGGS> s/client/server/ ?

[12:46] *** hash_table joined
[12:46] <moritz> s/client/remote/

[12:46] <FROGGS> k

[12:46] <moritz> depends on whether you're listening on the socket or not

[12:47] <FROGGS> so there will be nothing for persistent connections...

[12:47] <FROGGS> like: see, I have 2MB to send, here is the first chunk...

[12:48] <FROGGS> so the receiving client would know: ahh I got 256kB but there is more

[12:48] <FROGGS> because if the remote will send exactly 256kB you won't know if it is just a chunk or if it is all

[12:51] <moritz> no

[12:51] *** hash_table left
[12:51] <moritz> you need some information on a higher protocol level for that

[12:51] <nwc10> IIRC you (officially) don't even know if there is more on a short read. Only if the read returns 0 octets

[12:52] <nwc10> but IIRC reads from disks are never short.

[12:52] <nwc10> and this is assumed by too much stuff to change

[12:52] <moritz> (we're talking about sockets, not discs)

[12:53] <nwc10> I realise. But on sane operating systems, you can treat all file descriptors the same, if you need to

[12:53] <arnsholt> And by sane OSes, we all agree that the only sane one is Plan 9, right? O;)

[12:54] <nwc10> that wasn't quite what I was thinking, but I'm prepared to accept this argument

[12:54] <arnsholt> Mostly kidding, of course =)

[12:55] <moritz> well, that rules out parrot as a sane OS :-)

[12:56] <nwc10> I'm not sure what the biggest bout of insanity on the JVM is. long isn't atomic, is it?

[12:57] <jnthn> That probably depends if you're on a 32-bit or 64-bit.

[12:57] <jnthn> So no, you shouldn't rely on it. Same story on CLR, fwiw.

[12:57] <jnthn> woo, a pull request

[12:59] *** cognominal left
[12:59] <dalek> nqp-jvm-prep: 93418f5 | (Jonathan Stafford)++ | / (3 files):

[12:59] <dalek> nqp-jvm-prep: implements nqp::sha1

[12:59] <dalek> nqp-jvm-prep: 

[12:59] <dalek> nqp-jvm-prep: Implements nqp::sha1 using the UTF-8 encoding of the input string.

[12:59] <dalek> nqp-jvm-prep: 

[12:59] <dalek> nqp-jvm-prep: Although a test is included (of an ASCII-compatible string), when a non-ASCII

[12:59] <dalek> nqp-jvm-prep: input string is provided the test will fail.  For example, if the input

[12:59] <dalek> nqp-jvm-prep: string is "I√±t√´rn√¢ti√¥n√†liz√¶ti√∏n" the SHA-1 hash of the UTF-8 encoding should

[12:59] <dalek> nqp-jvm-prep: be 4B9C5D2FA4C83F7561787EB4E5F7F06A2CD47425 (according to both the JVM and

[12:59] <dalek> nqp-jvm-prep: nqp::sha1 on Parrot), but the test fails.  I'm not sure if this is an issue

[12:59] <dalek> nqp-jvm-prep: with using non-ASCII characters in the test file or something deeper.

[12:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/93418f5612

[12:59] <dalek> nqp-jvm-prep: baf26c3 | jonathan++ | / (3 files):

[12:59] <dalek> nqp-jvm-prep: Merge pull request #4 from thecabinet/master

[12:59] <dalek> nqp-jvm-prep: 

[12:59] <dalek> nqp-jvm-prep: nqp::sha1

[12:59] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/baf26c3a1b

[13:00] <arnsholt> nwc10: I don't know about long, but double is supposed to be atomic (IIRC there's even a fairly detailed discussion in the JVM spec about ways to avoid word-tear on 32-bit machines)

[13:00] <jnthn> Oh...maybe I'm wrong on long then.

[13:01] <arnsholt> At least I think so. It's been a while since I looked at it

[13:02] <dalek> nqp-jvm-prep: 03bad2f | jnthn++ | docs/LHF.md:

[13:02] <dalek> nqp-jvm-prep: Remove completed task.

[13:02] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/03bad2f7ba

[13:02] <FROGGS> jnthn: there is no LHF.md for nqp/rakudo, right?

[13:03] <jnthn> FROGGS: No, though sometimes we tag RT tickets with [LHF] or so

[13:03] <FROGGS> hmmm, then I should search for it ;o)

[13:03] <FROGGS> thanks

[13:07] *** cognominal joined
[13:07] <dalek> roast: f493956 | jnthn++ | S14-roles/conflicts.t:

[13:07] <dalek> roast: Unfudge some now-passing tests.

[13:07] <dalek> roast: review: https://github.com/perl6/roast/commit/f4939569fe

[13:12] <timotimo> jnthn: how does one find what tests to unfudge? purely by luck? or by saying "i'll work on rakudo so that this test no longer needs to be fudged!"?

[13:12] <tadzik> there's autounfudge somewhere, isn't there?

[13:13] <arnsholt> There's a script that runs the test suite without fudging as well I think, and reports fudged tests that run/pass

[13:13] <timotimo> ah, that's useful

[13:13] <moritz> tools/autounfudge.pl iirc

[13:13] <moritz> or util/ or so

[13:14] <moritz> but in this case, they were passing TODO tests

[13:14] <moritz> which you can see at the end of a spectest summary

[13:14] <timotimo> i must say: it seems to me that perl projects come up with decent tooling all the time

[13:15] <jnthn> timotimo: I fixed something and saw the extra passes last night

[13:15] <jnthn> Just forgot to push the test

[13:16] <timotimo> i'm considering writing (or at least drafting) that article/blogpost about sink/void context today.

[13:16] <moritz> timotimo: I'll be happy to proof-read it for you

[13:17] <timotimo> thanks. for now: errands &

[13:18] *** erkan left
[13:30] *** colomon left
[13:31] <Woodi> about nqp::sha1 above - isn't it a utf8 string engine bug not filtering malformed bytes in the first place ? Str should encapsulate such things IMO

[13:32] <moritz> Str should know nothing about UTF-8

[13:32] <moritz> Buf.decode should

[13:32] <moritz> and whatever other ways there are to create strings from UTF-8 bytes

[13:34] <Woodi> Str user API should not know, but internally it should "explode" on malformed sequence...

[13:35] <moritz> Str is encoding-agnostic. Would could it '"explode" on malformed sequence...'?

[13:36] <moritz> s/Would/How/

[13:36] <Woodi> I think about Str internals vs externals...

[13:36] <moritz> Str internals might know nothing about UTF-8 either

[13:36] <moritz> niecza's Str internals only know about UTF-16, I think

[13:36] <arnsholt> If you have an invalid byte sequence, it should be impossible to get a Str object at all

[13:37] <moritz> right.

[13:37] <moritz> and just to be clear, there are no "invalid byte sequences" in general, only "invalid byte sequences for the encoding we are trying to decode right now"

[13:37] <arnsholt> A Str with invalid internal data regardless of whether the native representation is UTF-8 or -16 or pink unicorns is a compiler bug

[13:38] <arnsholt> moritz: Yeah, that's a necessary qualifier

[13:38] <moritz> what's invalid UTF-8 in one context can be perfectly valid Latin-1

[13:38] <Woodi> things depends on how complicated Str is... is it internally array of bytes without creating logic or kind of str engine with conversions/constructions methods...

[13:39] <Woodi> s/bytes/somebettertermformemorybits/ :)

[13:39] <moritz> Woodi: that's totally not the point. The point is that as soon as you have a Str object (which is immutable), it must have been validated already

[13:39] <Woodi> yes

[13:39] <moritz> it's not at all relevant how complicated Str is

[13:41] <Woodi> do invalid Str's are allowed ?

[13:42] <moritz> No

[13:42] <arnsholt> No.

[13:42] <Woodi> \o/ 

[13:42] <moritz> that's what we've been trying you to tell you for five minutes now :-)

[13:43] <Woodi> but in example above nqp::sha1 was using invalid Str with 8-bit-ascii encoding ?

[13:43] <jnthn> Woodi: It's on nqp-jvm, where I've spent about zero time making sure you can even have a non-ASCII string literal so far. 

[13:44] <jnthn> I'll get something is going wrong in the JAST -> bytecode phase.

[13:44] <jnthn> *bet

[13:44] <Woodi> not blaming anyone :) especially jnthn++ ! just looking what is going on...

[13:45] <Woodi> or maybe assumption was that nqp::str can contain 8-bit str ? or maybe it is allowed on nqp lvl ?

[13:46] <jnthn> Woodi: I didn't think you were, just saying don't rely on nqp-jvm doing sensible things that Perl 6 would yet because it's very early days.

[13:47] <jnthn> It could be as easy as the assembler reading the JAST dump in the wrong encoding...

[13:48] <Woodi> my point is such errors should be catched on Str lvl...

[13:48] <moritz> NO IT SHOULD NOT

[13:48] <moritz> we've been discussing this enough now, haven't we?

[13:48] <Woodi> oki, thinking more

[13:48] *** dayangkun left
[13:49] <jnthn> In a fully implemented Perl 6, Str is NFG, which is more of a data structure than encoding

[13:56] *** cognominal_ joined
[13:57] *** cognominal left
[14:03] *** PacoAir joined
[14:05] <moritz> I hate twitter. An awesome hashtag comes up, and then it's flooded with people tweeting about how awesome that hashtag is, and then you are swamped by meta tweets, and it becomes boring

[14:05] *** dakkar left
[14:06] *** dakkar joined
[14:06] <moritz> happening right now to #overlyhonestmethods

[14:06] <arnsholt> Yeah, that's a bit annoying

[14:08] <timotimo> moritz: make some meta-meta-tweets to remedy the situation, is my advice.

[14:09] *** dayangkun joined
[14:12] <moritz> nah, just complain about it here, and be done with it :-)

[14:21] <arnsholt> Speaking of #overlyhonestmethods, have you seen research in progress?

[14:21] <moritz> I've mostly seen research in stand-still

[14:21] <moritz> in progress too, but that was very rare

[14:21] <arnsholt> http://researchinprogress.tumblr.com/

[14:23] <arnsholt> As a computational linguist, my favourite is http://researchinprogress.tumblr.com/post/33826776468/when-my-algorithm-beats-the-baseline

[14:23] *** atrodo joined
[14:24] *** tokuhiro_ joined
[14:28] <FROGGS> would it makes sense to add a trait like "is_hidden_from_introspection" for things like Buf.Str ?

[14:28] <FROGGS> because:

[14:28] <FROGGS> r: say so Buf.^can('Str')

[14:28] <p6eval> rakudo e26703: OUTPUT¬´True‚ê§¬ª

[14:29] <FROGGS> r: say Buf.Str

[14:29] <p6eval> rakudo e26703: OUTPUT¬´Cannot use a Buf as a string, but you called the Str method on it‚ê§  in method Str at src/gen/CORE.setting:7320‚ê§  in block  at /tmp/mXbE1vhlK4:1‚ê§‚ê§¬ª

[14:29] <moritz> FROGGS: no. Don't have the runtime lying to itself

[14:29] <jnthn> No, it's a bad idea.

[14:29] <moritz> FROGGS: it's simply wrong to assume that you can call every method you find.

[14:29] <jnthn> Remember that .^can is probably used by many internaly bits too

[14:30] <FROGGS> hmmm, so I cant really use .^can('Str') for testing if something can be stringified...

[14:30] *** tokuhiro_ left
[14:30] <FROGGS> sad that is

[14:30] <FROGGS> (not that I need it right now)

[14:31] <jnthn> FROGGS: Given Mu has a Str method, *everything* will claim to be able to be stringified ;)

[14:32] <[Coke]> the only way to know for sure if calling a method will work is to call it.

[14:32] <FROGGS> bah, arguments -.-

[14:32] <FROGGS> :P

[14:32] <FROGGS> brbr

[14:32] <FROGGS> brb

[14:33] <[Coke]> can is necessary but not sufficient?

[14:34] <moritz> correct

[14:42] <[Coke]> (I mean, I know that, I just wanted to restate it)

[14:42] <[Coke]> er, to ask if that was a better way to restate it.

[14:42] <[Coke]> bah. time for coffee #2

[14:50] *** stopbit joined
[14:56] *** am0c left
[15:00] *** am0c joined
[15:06] *** kaare_ joined
[15:08] *** cognominal_ left
[15:08] *** cognominal joined
[15:11] *** am0c left
[15:13] *** SunilJoshi joined
[15:20] *** werwerwer_ left
[15:21] *** inokenty joined
[15:30] *** wtw left
[15:40] *** rindolf left
[15:42] *** rindolf joined
[15:50] *** kaleem left
[15:55] *** Guest62890 left
[15:58] *** cognominal left
[16:00] *** bluescreen10 joined
[16:02] *** kaleem joined
[16:07] *** SunilJoshi left
[16:08] *** SunilJoshi joined
[16:09] <flussence> re: sha1 utf8 - maybe it's using the wrong normalisation form

[16:12] <FROGGS> r: say 0xbeef.chr; say Buf.new(0xbe, 0xef).decode

[16:12] <p6eval> rakudo e26703: OUTPUT¬´ÎªØ‚ê§Malformed UTF-8 string‚ê§‚ê§  in method decode at src/gen/CORE.setting:7344‚ê§  in block  at /tmp/YwdAhLtMSs:1‚ê§‚ê§¬ª

[16:12] <FROGGS> how can it be malformed?

[16:14] <flussence> r: say 0xbe.fmt('%b')

[16:14] <p6eval> rakudo e26703: OUTPUT¬´10111110‚ê§¬ª

[16:14] <flussence> that's a continuation byte

[16:14] <flussence> bit 6 isn't set

[16:15] *** SunilJoshi left
[16:15] <FROGGS> r: say 0xbeef.fmt('%b')

[16:15] <p6eval> rakudo e26703: OUTPUT¬´1011111011101111‚ê§¬ª

[16:15] *** SunilJoshi joined
[16:17] *** skids joined
[16:18] <kresike> bye folks

[16:18] *** kresike left
[16:18] <FROGGS> flussence: I dont get it

[16:19] <FROGGS> ahh

[16:19] <FROGGS> r: say Buf.new(0xbeef).decode

[16:19] <p6eval> rakudo e26703: OUTPUT¬´ÎªØ‚ê§¬ª

[16:20] <FROGGS> I thought Buf.new only takes bytes

[16:21] <flussence> it can take 16 and 32 bit values, and there's supposed to be a "utf8" subset (which nothing supports)

[16:22] <FROGGS> woulde it be sane to handle Buf.new(0xbe, 0xef) like Buf.new(0xbeef) when trying to .decode?

[16:23] <FROGGS> ( .decode('utf-8') that is )

[16:24] <FROGGS> so that .decode.chars will give 1 instead of 2

[16:25] <flussence> that'll make it impossible to determine if you have a valid byte buffer or an invalid stream that happens to decode as some other charset

[16:29] <FROGGS> I mean it should do its best to give you an utf-8 string if you ask it to, internally it can/should stay a bytestream

[16:30] <flussence> But you're no longer asking for utf-8 in that case, you're expecting it to decode as utf-16.

[16:31] *** Chillance joined
[16:31] <FROGGS> how comes that? IMO this is utf-8

[16:31] <FROGGS> one to four bytes per character

[16:32] *** colomon joined
[16:32] <FROGGS> two in this case

[16:32] <flussence> r: say 0xbeef.chr.encode('utf-8')

[16:32] <p6eval> rakudo e26703: OUTPUT¬´Buf:0x<eb bb af>‚ê§¬ª

[16:32] <FROGGS> hmmm

[16:32] <FROGGS> damn

[16:33] <FROGGS> say 0xebbbaf.chr

[16:33] <FROGGS> r: say 0xebbbaf.chr

[16:33] <p6eval> rakudo e26703: OUTPUT¬´Invalid character for UTF-8 encoding‚ê§‚ê§  in method chr at src/gen/CORE.setting:3104‚ê§  in block  at /tmp/kOTnJVXaVr:1‚ê§‚ê§¬ª

[16:33] <flussence> utf-8 is defined only for codepoints up to 1FFFFF

[16:34] <FROGGS> r: say 0xbeef

[16:34] <p6eval> rakudo e26703: OUTPUT¬´48879‚ê§¬ª

[16:35] <FROGGS> 0xbeef.chr.encode('utf-8') <-- this should give me the byte representation of that utf-8 char, no?

[16:36] <flussence> yes.

[16:36] <FROGGS> so why isnt it valid utf-8?

[16:36] <flussence> or more correctly, it will give you the valid utf-8 byte representation of that unicode char

[16:37] <FROGGS> r: say 0xbeef.chr.encode('iso-8859-1')

[16:37] <p6eval> rakudo e26703: OUTPUT¬´Lossy conversion to single byte encoding‚ê§  in method encode at src/gen/CORE.setting:4558‚ê§  in block  at /tmp/xLxLXmO7zq:1‚ê§‚ê§¬ª

[16:37] <FROGGS> k

[16:39] <FROGGS> r: say 0xbeef.chr.encode('utf-8') # I'm not sure but I believe you are encoding an already as utf-8 encoded string as utf-8, so it gets messed up

[16:39] <p6eval> rakudo e26703: OUTPUT¬´Buf:0x<eb bb af>‚ê§¬ª

[16:41] <flussence> You are encoding an *abstract unicode codepoint* into a *binary representation*. Unicode is *not* utf-8 and it is *not* getting messed up.

[16:42] <FROGGS> so 0xbeef is the unicode codepoint that chr can handle

[16:42] <flussence> Yes, exactly.

[16:43] <FROGGS> okay

[16:44] <FROGGS> need to think while walking home

[16:44] <FROGGS> see you later

[16:44] *** FROGGS left
[16:47] *** SunilJoshi left
[16:49] *** sqirrel left
[16:55] *** spider-mario joined
[17:01] <rurban> pmichaud: https://github.com/rakudo/rakudo/pull/93 is now ready

[17:10] *** FROGGS joined
[17:21] <timotimo> hm.  the highlighting program my blog software uses doesn't handle perl6 yet :|

[17:23] *** kaleem left
[17:23] *** thou joined
[17:32] *** wtw joined
[17:36] <dalek> specs: 4909197 | masak++ | S06-routines.pod:

[17:36] <dalek> specs: [S06] typo fixes

[17:36] <dalek> specs: review: https://github.com/perl6/specs/commit/4909197406

[17:36] <masak> (evenin', #perl6)

[17:38] <TimToady> (mornin', masak)

[17:39] <timotimo> trying to come up with sensible and good examples for when lazy-by-default-for can bite you, somewhat unsuccessfully

[17:40] <TimToady> it tends to bite you on the non-lazy end, when you save up something that shouldn't be cached, wasting memory

[17:41] <TimToady> it tends to be less efficient if the lazy algorithm can't deduce when to do batches, and you get too much control flow overhead

[17:42] <TimToady> oh way, you said "-for"

[17:42] *** kaleem joined
[17:42] <TimToady> *wait

[17:43] <timotimo> were you thinking about "lazy-by-default" instead?

[17:43] <TimToady> yes

[17:43] <timotimo> now what you said makes more sense to me :)

[17:44] <TimToady> allowing the --> to provide context for the final statement fixes most of the badness, as far as I can see

[17:44] <TimToady> (plus warning if --> isn't there, and the for wants it)

[17:44] <doy> timotimo: for @items -> $item { check($item) }, at the end of a function, where check is meant to throw exceptions on error and do nothing else

[17:44] <doy> is the context where i ran into it

[17:45] <TimToady> but then this is a function that would be marked with --> Nil since you're obviously not wanting to return anything

[17:45] <doy> (if you proceed to then call that function in void context)

[17:45] <doy> right

[17:45] <TimToady> and --> Nil would put it into sink context

[17:45] <doy> if there was a warning/error for that, it would help a lot

[17:45] <TimToady> just specced last night

[17:47] <TimToady> "if you proceed to call that function in void context": What would you expect it to return if you didn't call it in void context?

[17:48] *** wtw left
[17:48] <doy> well, nothing(:

[17:48] *** kaleem left
[17:48] <TimToady> which kind of nothing? :)

[17:48] * jnthn will try and get the warning/changes in before the Jan release.

[17:48] <doy> as in, i wouldn't have any particular expectation

[17:48] <doy> (:

[17:48] <jnthn> TimToady: I'm a little curious it's parsed as a <parameter>.

[17:49] <jnthn> TimToady: sub foo($x, $y --> $z) { }

[17:49] <jnthn> TimToady: What does this actually mean?

[17:49] <TimToady> the spec says now

[17:49] <jnthn> I read it but didn't get it :)

[17:49] <jnthn> The variable case, that is.

[17:50] <TimToady> S06:687

[17:50] <jnthn> Presumably it's declaring $z

[17:50] <TimToady> yes, and then it implicitly returns $z at the end, since "return $z" is illegal

[17:50] <TimToady> could even do --> $!foo

[17:50] * moritz likes it

[17:51] <TimToady> so you can write an accessor with an empty body

[17:51] <jnthn> OK, but the default for parameters is that $z is a readonly alias...apart from there's nothing for it to be an alias for :)

[17:51] <moritz> well, that would need to have a different default

[17:51] <TimToady> yes, the semantics would have to fudge to rw, since it's an "out" parameter

[17:51] <jnthn> OK, then it makes a bit more sense.

[17:52] * jnthn wonders what <parameter> may be implying now that will make implemetning this a little odd

[17:52] <jnthn> I hope not too much :)

[17:52] <jnthn> Is the detection of "for" as the last statement syntactic?

[17:53] <jnthn> As in, are we looking for an explicit "for" loop there? Not a call to map?

[17:53] <TimToady> yes, same pass as would decide whether to put the sink on it or return it

[17:53] <jnthn> Which was the "yes" to? :)

[17:53] <jnthn> The sink analysis is semantic :)

[17:53] <jnthn> afaik, anyway

[17:53] <TimToady> but you need to know where the statements are

[17:54] <jnthn> sub foo() { for 1..10 { .say } } # warning

[17:54] <jnthn> sub foo() { .say for 1..10 } # warning

[17:54] <TimToady> any loop, in fact

[17:54] <jnthn> sub foo() { 1..10.map: *.say } # warning or not?

[17:55] <TimToady> conservatively, we can warn on that too, and see if any use cases pop up to the contrary

[17:55] <TimToady> the other slightly unresolved thing is what to put after the --> if you *do* want to return a list

[17:55] * [Coke] wonders if there is a writeup as to why it makes sense for those 2 to be warning?

[17:55] <timotimo> doy: i tried to construct a pretty example like that, but now i fail to cause the for at the end of the sub to not be sinked

[17:55] <TimToady> List? Parcel?

[17:55] <timotimo> i seem to be confused as to what void context means, perhaps?

[17:55] <[Coke]> is it the implicit return?

[17:56] <[Coke]> (that's easy. let me say "void sub foo() {... }" ! ;)

[17:56] <jnthn> TimToady: Positional or Iterable is most general I guess, but dpeneds what we want to encourage

[17:56] <jnthn> TimToady: Why do other kinds of loop need the warning? Not because of laziness, but to avoid saving all the values?

[17:57] <TimToady> well, any loop that returns all its values :)

[17:57] <jnthn> (Rakudo doesn't currently implement the "collect the values" thing for loops other than for...)

[17:58] <TimToady> is it better to spec "loop" as primitive, or to look for use cases for loop returning values?

[17:59] <jnthn> I'd be curious to see some good use cases (e.g. where it's better than "for")

[17:59] <jnthn> I guess there's a consistency argument.

[18:00] <TimToady> might be a foolish consistency

[18:00] <jnthn> Aye

[18:00] * jnthn sometimes wonders if for/map are ;)

[18:00] <jnthn> But I guess list comprehensions make it worthwhile...

[18:00] <TimToady> that's partly for pedagogy too

[18:01] <TimToady> and to stomp the meme that differentiates map from for :)

[18:01] <jnthn> I think a lot of people's prior experience of "for" won't be that it's a kind of map (that is, that it produces results)

[18:02] <TimToady> sure, but we're tilting the playing field toward FP here

[18:02] *** jeffreykegler joined
[18:02] <timotimo> do for and map work exactly the same in perl6? or are there subtle differences?

[18:02] *** snarkyboojum left
[18:02] <jnthn> I think "you have to write --> Nil" will actually be harder to teach/justify, for what it's worth.

[18:02] *** moritz joined
[18:02] *** snarkyboojum joined
[18:02] *** gfldex joined
[18:02] *** steven_ joined
[18:02] *** revdiablo joined
[18:02] *** phenny joined
[18:03] *** _ilbot joined
[18:03] *** p6eval joined
[18:03] *** ChanServ sets mode: +v p6eval

[18:03] <jnthn> Also, while so far we've had plenty of people putting type constraints on parameters in Perl 6 code, I've seen much less of that happen with return values.

[18:04] <jnthn> er, return types

[18:05] <jeffreykegler> hi.  Is there a resource where I can check out how the Perl 6 team handles collaboration?

[18:05] <jeffreykegler> I mean things like github, etc.

[18:05] <jeffreykegler> The technical stuff

[18:06] <jeffreykegler> A project of mine is going collaborative, so as usual I am here to steal ^W borrow ideas

[18:06] *** Celelibi joined
[18:06] <timotimo> can i get a small example where a for loop at the end of a sub doesn't get executed because of its lazyness?

[18:07] <jnthn> While I'm all for biasing towards FP, in reality I'm not sure "for" will be naturally seen as an FP construct.

[18:07] <arnsholt> jeffreykegler: One facet of the Perl 6 project which seems pretty special is the liberal attitude to commit bits

[18:07] <timotimo> r: sub test() { for ^2 { print "hip " } }; test(); say "hooray!"

[18:07] <p6eval> rakudo e26703: OUTPUT¬´hip hip hooray!‚ê§¬ª

[18:07] <timotimo> r: sub test() { for ^2 { print "hip " } }; test();

[18:07] <p6eval> rakudo e26703: OUTPUT¬´hip hip ¬ª

[18:07] <jnthn> timotimo: It's not "doesn't get executed"

[18:07] <masak> jeffreykegler: we do most of the collaboration under the perl6/ account of github.

[18:08] <TimToady> well, and here on IRC

[18:08] <jnthn> r: sub test() { my $*x = 2; for ^2 { print "hip " } }; my $*x = 1; test();

[18:08] <p6eval> rakudo e26703: OUTPUT¬´hip hip ¬ª

[18:08] <arnsholt> Getting a commit bit to stuff like the specs or roast is mostly a question of showing some kind of interest

[18:08] <jnthn> r: sub test() { my $*x = 2; for ^2 { print "hip $*x " } }; my $*x = 1; test();

[18:08] <p6eval> rakudo e26703: OUTPUT¬´Dynamic variable $*x not found‚ê§current instr.: 'throw' pc 329834 (src/gen/CORE.setting.pir:147383) (src/gen/CORE.setting:9248)‚ê§called from Sub 'Str' pc 359008 (src/gen/CORE.setting.pir:159143) (src/gen/CORE.setting:10396)‚ê§called from Sub 'Stringy' pc 146729 (src/ge‚Ä¶

[18:08] <TimToady> jeffreykegler: there's also github -> IRC feedback via the dalek bot

[18:08] <jeffreykegler> TimToady: yes your IRC example has already convinced me that we need to converse in public

[18:09] <timotimo> so the main problem is different order of instructions?

[18:09] <jeffreykegler> Something I certainly would not have thought of on my own

[18:09] <TimToady> some info and discussion flows on mailing lists too, but that tends to be secondary

[18:09] <jeffreykegler> masak: whose is the repository?  that is, what github user?

[18:09] <doy> timotimo: seems to only happen with methods, not functions?

[18:10] <timotimo> it belongs to the organisation, i believe, jeffreykegler 

[18:10] *** preflex joined
[18:10] <doy> r: class Foo { has @.items; method check_items { for @.items -> $item { die "bad" if $item == 2 } }; method foo { self.check_items; say for @.items } }; Foo.new(items => (1, 2, 3, 4)).foo

[18:10] <p6eval> rakudo e26703: OUTPUT¬´‚ê§‚ê§‚ê§‚ê§¬ª

[18:10] <doy> r: class Foo { has @.items; method check_items { for @.items -> $item { die "bad" if $item == 2 }; return }; method foo { self.check_items; say for @.items } }; Foo.new(items => (1, 2, 3, 4)).foo

[18:10] <p6eval> rakudo e26703: OUTPUT¬´bad‚ê§  in method check_items at /tmp/uaYwCfXmAp:1‚ê§  in method foo at /tmp/uaYwCfXmAp:1‚ê§  in block  at /tmp/uaYwCfXmAp:1‚ê§‚ê§¬ª

[18:10] <masak> jeffreykegler: it is an organization.

[18:10] <jeffreykegler> https://github.com/perl6 ?

[18:10] <timotimo> doy: that surprises me.

[18:10] <doy> i couldn't reproduce ^^ with subs, for some reason

[18:11] <jeffreykegler> I will probably use a mailing list not an IRC for two reasons

[18:11] <jeffreykegler> One is I don't expect this kind of traffic

[18:11] <jeffreykegler> Second is almost none of my community is in the same time zone

[18:11] <TimToady> jeffreykegler: another important datapath is the irc logs that we can refer back to

[18:12] <TimToady> for instance, did you see what I said at http://irclog.perlgeek.de/perl6/2013-01-09#i_6313797

[18:12] <jeffreykegler> TimToady: about scannerless parsing?  Yes I did

[18:13] <jeffreykegler> By the way, I agree that "scannerless" is not a fortunate choice of terminology

[18:13] <jeffreykegler> But I *do* try to track the literature and it seems to be pretty much embedded

[18:14] <TimToady> I'm glad somebody tracks the literature, and that it's not me :)

[18:15] <TimToady> the fact that S06 mentions PEGs is also a retrofit

[18:15] <jeffreykegler> By the way, the solution I adopted for scannerless parsing is more or less that of Perl 6, with different notation

[18:16] <jeffreykegler> I tried what I call a "Ruby Slippers" approach, but discovered my parser needs a few extra "hooks" for that to work

[18:16] <TimToady> is that Ruby as in the language?

[18:17] <timotimo> doy: i'd be interested to see the comments of some of the experts on that issue

[18:17] <PerlJam> TimToady: no, it's not.

[18:17] <jeffreykegler> No, it's a parsing technique where on failure, you ask the parser, "OK what do you wish for?"

[18:17] <jeffreykegler> Then you give it to it.

[18:17] <arnsholt> "Ruby slippers" as in Wizard of Oz, I think

[18:17] <PerlJam> jeffreykegler: btw, "ruby slippers" makes everyone thing of Ruby the language :)

[18:17] <TimToady> got that part

[18:17] <PerlJam> s/thing/think/

[18:18] <TimToady> just didn't know if there was a rubylang overlay

[18:18] <jeffreykegler> Perljam: so I discover

[18:18] <arnsholt> (Although that particular cultural reference is far enough outside my sphere of reference I'm not really sure what it actually means =)

[18:18] <jeffreykegler> arnsholt: A land without the "Wizard of Oz"?

[18:18] <TimToady> well, it's not transparent in how it would apply to parsing

[18:18] <arnsholt> A land called Europe ;)

[18:19] <jeffreykegler> My parser is Earley based and is 100% accurate (in the technical sense) when it fails ....

[18:19] <arnsholt> A did see it once (an open-air showing on the Mall in Washington DC, actually) but it's been 20 years

[18:19] <jeffreykegler> ... as to why.  It knows what rules it was looking for, what symbols it wants, how far it got in the rules, etc.

[18:19] <arnsholt> Pretty much all I remember is "lions, tigers, bears, oh my" and a yellow brick road

[18:20] <TimToady> arnsholt: the ruby slippers come at the end, where she wishes herself back to Kansas

[18:20] <jeffreykegler> arnsholt: So you don't live near Kansas?

[18:20] <PerlJam> arnsholt: "there's no place like home; there's no place like home; there's no place like home"

[18:20] <arnsholt> Yeah, I've been reading your posts on blogs.perl.org with quite a bit of interest. I always had a soft spot for the Earley algorithm

[18:21] <arnsholt> Right, right. I think that rings a bell

[18:21] <arnsholt> jeffreykegler: Definitely not. I'm in Norway, so it's a bit off the beaten track =)

[18:22] <jnthn> doy: I'm a bit surprised the first of those two didn't die.

[18:22] <jeffreykegler> An example of using the Ruby Slippers: HTML parsing.  Write a "perfect world" grammar, assuming all start and end tags are physically present

[18:22] <jeffreykegler> Then start parsing.  If the parse wants a tag, that you didn't see, just invent it.

[18:23] <jnthn> dinner, bbiab

[18:23] <jeffreykegler> Essentially, the lexer plays Glenda and tells the parser that it has always been in Kansas

[18:23] <doy> jnthn: so was i!

[18:23] <jeffreykegler> I was a little surprised myself when I found this works very smoothly

[18:24] * TimToady has some familiarity with lexers that lie, and tends to avoid them these days :)

[18:24] <TimToady> we would tend to just return a synthetic AST in that case

[18:24] <jeffreykegler> I think reality is overrated as a concept

[18:25] <arnsholt> Well, one of jeffreykegler's use cases for the technique was parsing Perl 5 =)

[18:25] <TimToady> of the four or five ways a compiler can cheat, Perl 5 uses about eight of them

[18:25] <jeffreykegler> Yes, actually a form of the technique shows up, I think in Perl 5's parsing of the "use statement"

[18:25] <jeffreykegler> Also, there's a semi-colon hack, as I recall

[18:26] <jeffreykegler> By the way, the other day you were looking for code that survived from Perl 1 to Perl 5

[18:26] <jeffreykegler> If you look in the yacc grammar, there's a whole lot of it.

[18:26] <huf> what are these ways a compiler can cheat?

[18:26] <TimToady> those techniques that make the parser unsure of which language it's in currently have now been considered harmful for Perl 6

[18:27] <PerlJam> TimToady: jeffreykegler's technique is more like assuming you're in the language you thought you were.

[18:28] <PerlJam> (granted, this assumption can go wrong, just like any other "guessing" technique)

[18:28] <TimToady> huf: well, just on the lexer level, lookbehinds, lookaheads, synthetic token queueing, sublexing for strings, fake lexer states, to name a few

[18:28] <huf> looks like i'll need to grow up a bit to know what those things are :)

[18:29] <TimToady> that's even before you start rewriting ASTs

[18:29] <huf> why are these things cheating?

[18:29] <PerlJam> TimToady: so, Perl 6 is about legitimizing the cheats by making them first class language?  :)

[18:29] <jeffreykegler> A nice feature of Earley/Marpa/Ruby Slippers parsing is no lookahead, and no backtracking.

[18:29] <huf> i mean, isnt this precisely why we have compilers? :)

[18:30] <TimToady> PerlJam: no, it's really throwing out the cheats that cause the parse to be insane

[18:30] *** marloshouse left
[18:31] <TimToady> we do allow backtracking, with the proviso that such code must store all its result data in the AST, so it can be thrown away if we backtrack

[18:31] <jeffreykegler> There's a saying on the NASCAR circuit, I'm told, "You ain't cheatin', You ain't tryin'"

[18:31] *** bluescreen10 left
[18:31] <jeffreykegler> LALR parsing is always in practice a kind of cheat

[18:32] <japhb> obCheating/TechniqueReference

[18:32] <huf> the output of a compiler is magic anyway, magic that, if all went well, does what the code was supposed to do.

[18:32] <jeffreykegler> Because it seems that no practical grammar is ever *quite* LALR

[18:32] *** marloshouse joined
[18:32] <PerlJam> jeffreykegler: In theory, theory and practice are the same; in practice, they're not.  :)

[18:33] <jeffreykegler> In any case, the crucial consideration for me was, "does it work?"

[18:33] <TimToady> an additional constraint on the Perl 6 design is that it *must* allow backtracking to allow Perl 5 regexes as a degenerate case

[18:33] <arnsholt> huf: But there are varying degrees of magic. Parsing Perl 5 for example, is so magical it's all but impossible to replicate outside of the perl codebase

[18:33] <TimToady> well, p5 semantics, not notation

[18:33] <arnsholt> (AFAICT)

[18:34] *** preflex left
[18:34] <japhb> timotimo, The place lazy-default for has really been biting me is when I'm working on glue scripts that do things like chdir around a filesystem as they do different tasks, perhaps executing a loop in a given directory.  When for is lazy, and the contents of the loop don't happen until sometime later, the loop contents end up executing in a different directory than they expected.  Hilarity ensues.

[18:34] <huf> arnsholt: well yes, you need to run it to parse it to run it to ... :)

[18:35] <dalek> nqp: 79adaf3 | rurban++ | .gitignore:

[18:35] <dalek> nqp: Revert "add MANIFEST.generated to .gitignore"

[18:35] <dalek> nqp: 

[18:35] <dalek> nqp: This reverts commit 5f89700d9c98f0f8216f72edadfc6134726c324c.

[18:35] <dalek> nqp: Not generated with parrot 5.0, since https://github.com/parrot/parrot/issues/922

[18:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/79adaf3b3e

[18:35] <dalek> nqp: 5a9b349 | rurban++ | tools/build/Makefile.in:

[18:35] <dalek> nqp: install dynpmc headers, as parrot 5.0 does so

[18:35] <dalek> nqp: 

[18:35] <dalek> nqp: See https://github.com/parrot/parrot/issues/922

[18:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5a9b3492cc

[18:35] *** PacoAir left
[18:36] <jeffreykegler> So back to "how to colloborate", the organization owns the github repository and I see you've got a lot of members

[18:36] <TimToady> it's a pretty flat org chart

[18:36] *** PacoAir joined
[18:37] <TimToady> perhaps the most important organizing principle is "forgiveness > permission"

[18:37] <japhb> Several individuals are higher on the org chart, but not because they are in a supervisory layer.  More like they are taller bumps on a pancake.  :-)

[18:38] <japhb> au++ introduced us to radical trust.  It has served us well since.

[18:38] * PerlJam didn't even realize we /had/ an org chart

[18:38] <TimToady> like I used to tell my kids: "I don't care if you're taller, as long as you're tolerable."

[18:38] <japhb> *chuckle*

[18:39] <TimToady> more of a disorg chart

[18:39] <japhb> I'm going to have to use that.

[18:39] <[Coke]> people work on things that interest them, or maybe on things that will help other people.

[18:39] <japhb> Along with my father's "You grew some?  Yeah, you gruesome all right ...."

[18:39] <jeffreykegler> And the approach to commit bits?

[18:39] <japhb> "here you go"

[18:39] <dalek> perl6-roast-data: bec8594 | coke++ | / (4 files):

[18:39] <dalek> perl6-roast-data: today (automated commit)

[18:39] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/bec8594b09

[18:39] <dalek> perl6-roast-data: 66f4008 | coke++ | / (4 files):

[18:39] <dalek> perl6-roast-data: today (automated commit)

[18:39] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/66f4008e82

[18:39] <dalek> perl6-roast-data: eb3d723 | coke++ | / (4 files):

[18:39] <dalek> perl6-roast-data: today (automated commit)

[18:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/eb3d723298

[18:40] <dalek> perl6-roast-data: de06f3e | coke++ | / (4 files):

[18:40] <dalek> perl6-roast-data: minor fixups

[18:40] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/de06f3e819

[18:40] <jeffreykegler> japhb: au == Audrey Tang?

[18:40] <TimToady> except for historically parrot required CLA signing, so I think rakudo still does too?

[18:40] <japhb> Generally I think the only real limitation is that Rakudo requires a CLA (Contributor License Agreement), presumably to avoid someone's $day_job employer trying to claim ownership.

[18:40] <japhb> jeffreykegler, yes.

[18:40] <[Coke]> rakudo requires perl.org CLA - but it's not because parrot did, I don't think.

[18:41] <[Coke]> (but parrot does also)

[18:41] <TimToady> well, they used to be the same project, more or less

[18:41] <jeffreykegler> Ok.  I always associated the idea with Audrey.  Does her work predate your discussing the project in public on IRC?

[18:42] <TimToady> pretty much started the same time

[18:42] <japhb> Yeah, that's my (fuzzy) memory too.

[18:42] <TimToady> it was au++ that started me on IRC

[18:44] <TimToady> for certain kinds of design discussions, it's just much more efficient than email

[18:44] <TimToady> though email has its place too, as do other scales of communication

[18:44] <jeffreykegler> I have the problem that most of my community is not in the US, and not anywhere near my time zone

[18:44] <PerlJam> TimToady: Does the Cabal Call happen anymore?

[18:44] <TimToady> not for several years

[18:45] <jeffreykegler> So IRC might not work for Marpa::R3 (my project)

[18:45] <japhb> jeffreykegler, Which is why IRC logs (as well as just leaving an IRC window open) work well

[18:45] <japhb> Perl6 development manages pretty well in handling timezones world wide.

[18:45] <jeffreykegler> Of course maybe everybody else will develop it just fine without me

[18:45] <japhb> Because people aren't on here only during "work" hours

[18:46] <PerlJam> jeffreykegler: I bet if you ask moritz, he could log your channel just like #perl6

[18:46] <TimToady> jeffreykegler: you need to have more Hubris :)

[18:46] *** Chillance left
[18:47] <jeffreykegler> TimToady: Actually, I get that criticism a lot

[18:47] <TimToady> "If I take a vacation, they'll screw it up for sure..."  :)

[18:47] <TimToady> "in the nicest of possible ways..."

[18:47] <jeffreykegler> moritz has been very helpful to me in the past

[18:48] <TimToady> of course, when I'm online, it gets screwed up a different way...

[18:48] <PerlJam> jeffreykegler: Is your community 12 hours out of phase with you?  If so, you might need to find a couple of long nights every once in a while, but otherwise IRC handles multi-timezone communication quite well.

[18:48] <jeffreykegler> Perljam: basically, yes

[18:48] <TimToady> with approriate bots, you can leave messages for people

[18:49] <TimToady> or if you know your other person always reads the backlogs, you can just address them vocatively

[18:49] <jeffreykegler> I don't know if it's the education system or what, but Americans do not do parsing theory nearly as much as those outside the US

[18:49] <TimToady> and most IRC clients will highlight that your name has been evoked

[18:49] <japhb> India <-> West Coast US is indeed approximately pessimal.  But I find it less so when it's personal project coordination instead of $day_job coordination.

[18:52] <PerlJam> jeffreykegler: maybe it's population differences.  You're dealing with a self selected group of people from a larger population, so you encounter objectively more parsing-theory-people but probably proportionally the same in a per-capita fashion

[18:54] <PerlJam> (that's my anti-americans-are-stupid optimism anyway :)

[18:54] <jeffreykegler> Btw, I am a US citizen living in California

[18:55] * diakopter too, and is anti-anti-americans-are-stupid

[18:56] <jeffreykegler> What's my next step?  Contact moritz?

[18:56] <japhb> Create your channel first

[18:56] <jeffreykegler> (About IRC, not about the US educational system, that is)

[18:56] <dalek> specs: ffef865 | flussence++ | S (2 files):

[18:56] <dalek> specs: Tidy up overly long lines

[18:56] <dalek> specs: review: https://github.com/perl6/specs/commit/ffef865e3d

[18:58] <PerlJam> jeffreykegler: create a channel; invite people; ask moritz to log it; maybe setup some messaging bots

[18:59] <japhb> Can dalek be told to report commits from a given repo to only one of the channels it is in?

[19:00] <jeffreykegler> I'll get back to my mailing list, and see if the Marpa community likes this idea

[19:00] <arnsholt> japhb: Pretty sure it can

[19:01] <arnsholt> It reports commits to the parrot repo only in #parrot and not here

[19:01] <diakopter> japhb: yes; the listener first writes the messages it receives from github/etc to disk then the dalek process read/spits/deletes them

[19:02] <japhb> Ah, good.

[19:06] <moritz> jeffreykegler: yes

[19:07] <moritz> erm, meant japhb, but it's also a "yes" to jeffreykegler :-)

[19:07] <moritz> japhb: in the mu repo, there are some files im misc/dalek* that contain all the info you need

[19:08] <japhb> I keep forgetting dalek is in mu.

[19:08] <moritz> not dalek itself

[19:08] <moritz> only some documentation and configuration

[19:08] *** inokenty left
[19:08] <japhb> ah, that explains my confusion

[19:10] * jnthn back

[19:16] <FROGGS> you dont even need dalek, the github service hooks can spam every channel

[19:16] <FROGGS> dalek is just a bit better than the github service hook

[19:22] *** MayDaniel_ joined
[19:24] *** MayDaniel left
[19:27] *** Detroit joined
[19:30] <dalek> panda: fcfec51 | tadzik++ | / (2 files):

[19:30] <dalek> panda: In a long dependency chain, ensure that some projects don't get installed twice

[19:30] <dalek> panda: review: https://github.com/tadzik/panda/commit/fcfec5193f

[19:30] *** SamuraiJack left
[19:41] <jeffreykegler> moritz: thanks!

[19:43] <moritz> jeffreykegler: do you have a channel name already?

[19:46] <jeffreykegler> moritz: not yet.  I'm checking with the Marpa mailing list, just in case the community there hates the idea.  I'll let you know.  Is your email address on github good?

[19:50] <dalek> panda: 84e6bd9 | tadzik++ | / (2 files):

[19:50] <dalek> panda: Skip git files during local installation

[19:50] <dalek> panda: review: https://github.com/tadzik/panda/commit/84e6bd972a

[19:55] <moritz> jeffreykegler: yes

[19:55] * skids discovers he will not be debugging C++ for the next two hours.  o/

[19:56] <moritz> on monday I've fixed a bug in some of the worst Perl code I've ever seen

[19:57] <moritz> full of two-letter named variables

[19:57] <moritz> and anonymous subroutines that don't get their data from arguments passed, but from semi-global variables

[19:58] <moritz> (mostly lexicals, but valid in scope of ~2k lines)

[19:58] <masak> o.O

[19:58] <tadzik> duh

[19:58] <masak> nothing you said shocked me, until you said "scope of ~2k lines".

[19:58] <masak> what's wrong with people!?

[19:58] <japhb> Oh, that's nothing in terms of hellish codebases.

[19:59] * japhb mightily resists telling war stories for an hour.

[19:59] * diakopter agrees that's nothing

[19:59] <diakopter> (though I'm sure there's more moritz hasn't mentioned)

[20:00] <skids> The first person to ask "how can I automatically get attributes to be sigilless in an object method" I swear I am going to pelt them with dirty socks.

[20:00] <tadzik> :D

[20:02] <masak> Oh, that's nothing in terms of being pelted with undesirable things.

[20:02] <masak> :P

[20:04] <skids> Yes but dirty socks are always at hand.  Or at least, at foot.

[20:05] <masak> heh.

[20:07] <tadzik> gah, where did github hide the "new repository button" :

[20:07] <tadzik> it's the 3rd time I look for it today

[20:08] <flussence> try looking on the page with "enable middle click paste in gists"... :/

[20:08] <flussence> .oO( why do sites do giant sweeping redesigns without *using* them to see if *they work*? )

[20:08] <diakopter> "people are getting repo happy" "hide the button"

[20:08] <tadzik> bah, I can't even lift-click the "Create public gist"

[20:11] *** jeffreykegler left
[20:11] <dalek> ecosystem: b871794 | tadzik++ | META.list:

[20:11] <dalek> ecosystem: Add Task::Star

[20:11] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/b871794db6

[20:12] <dalek> specs: b35224c | larry++ | S32-setting-library/Containers.pod:

[20:12] <dalek> specs: Clarify uniq semantics; add squish alternative

[20:12] <dalek> specs: 

[20:12] <dalek> specs: The uniq function guarantees uniqueness throughout the list, but is overkill

[20:12] <dalek> specs: if the input is sorted appropriately.  If the user knows the input is sorted,

[20:12] <dalek> specs: or if the user merely desires to reduce runs of adjacent identical instances

[20:12] <dalek> specs: to one instance, the squish function will do that.

[20:12] <dalek> specs: review: https://github.com/perl6/specs/commit/b35224cc47

[20:12] <dalek> specs: 41ec325 | larry++ | S (2 files):

[20:12] <dalek> specs: Merge branch 'master' of github.com:perl6/specs

[20:12] <dalek> specs: review: https://github.com/perl6/specs/commit/41ec3250ff

[20:13] <TimToady> hmm, did I do that right?

[20:15] <diakopter> yay for squishy

[20:16] <TimToady> prior art is the "squish" flag on tr///

[20:17] <diakopter> TimToady: did someone ever codify the syntax for using a function signature as the type of a parameter or return value?

[20:17] *** phenny left
[20:17] <TimToady> nr: $_ = "aabcccddaabbb"; tr:s/a..z/a..z/; .say

[20:17] <diakopter> I remember talking about it

[20:17] <p6eval> niecza v24-16-g89e47b6: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method quote:tr not yet implemented at /tmp/UZia1Zjt3P line 1:‚ê§------> [32m$_ = "aabcccddaabbb"; tr:s/a..z/a..z/[33m‚èè[31m; .say[0m‚ê§‚ê§Unhandled exception: Unable to resolve method statement_level in type Any‚ê§  at /h‚Ä¶

[20:17] <p6eval> ..rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Operators '..' and '..' are non-associtiave and require parenthesis‚ê§at /tmp/WL_CVMs0gg:1‚ê§------> [32m$_ = "aabcccddaabbb"; tr:s/a..z/a.[33m‚èè[31m.z/; .say[0m‚ê§    expecting any of:‚ê§        dotty method or postfix‚ê§¬ª

[20:17] <TimToady> o_O

[20:17] *** phenny joined
[20:18] <TimToady> diakopter: there's something about that somewhere in the specs

[20:19] <flussence> r: $_ = 'associtiave'; s[.*] = 'associative'; .say

[20:19] <p6eval> rakudo e26703: OUTPUT¬´associative‚ê§¬ª

[20:19] <TimToady> S06:1689

[20:19] <masak> TimToady: 'git pull --rebase' avoids pesky merge commits in the specs repo.

[20:20] <TimToady> yes, but I've been burned by that too, meseemeth

[20:20] <diakopter> TimToady: oh yeah. thx

[20:21] <masak> using any kind of rebasing before achieving git nirvana is risky, indeed.

[20:21] <masak> and of course, conflicts are still possible, but rather more pleasant (IMO) than merge conflicts.

[20:21] * TimToady is still in git limbo

[20:21] <masak> :)

[20:23] <TimToady> I'd rather inflict extra dalek messages on people than accidentally delete their patches...

[20:24] <masak> yes, that's pre-nirvana reasoning ;)

[20:24] <diakopter> exterminate...

[20:28] <masak> diakopter: I have never heard a dalek pronounce it quite like that. not even a melancholy one.

[20:28] <masak> it's more like EX-TER-MI-NATE.

[20:34] <FROGGS> is that right? (multi multi note): https://github.com/perl6/specs/blob/master/S32-setting-library/IO.pod#note

[20:35] <[Coke]> r: sub postfix:<!!> ($x) { my $a = $x %% 2 ?? 2 !! 3; [*] $a, $a+2 ... $x } ; say 4!!; say 5!!

[20:35] <p6eval> rakudo e26703: OUTPUT¬´8‚ê§15‚ê§¬ª

[20:37] *** snearch joined
[20:37] <masak> FROGGS: no, that looks like a typo. feel free to fix.

[20:37] <FROGGS> will do, thanks

[20:38] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... 2|3 }; say 4!!; say 5!!

[20:38] <jnthn> woo, finally I have some Perl 6 tuits :)

[20:38] <p6eval> rakudo e26703: OUTPUT¬´(timeout)¬ª

[20:38] <masak> huh!

[20:38] <jnthn> r: say ($x, $x - 2 ... 2|3).perl

[20:38] <p6eval> rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $x is not declared‚ê§at /tmp/k7eWANcb5Q:1‚ê§------> [32msay ($x[33m‚èè[31m, $x - 2 ... 2|3).perl[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[20:39] <jnthn> r: sub foo($x) { say ($x, $x - 2 ... 2|3).perl }; foo(2)

[20:39] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... any(2, 3) }; say 4!!; say 5!!

[20:39] <p6eval> rakudo e26703: OUTPUT¬´(timeout)¬ª

[20:39] <p6eval> rakudo e26703: OUTPUT¬´(timeout)¬ª

[20:39] <masak> something's wrong here.

[20:39] <masak> "I notice that I am confused."

[20:39] <jnthn> Maybe.

[20:40] <jnthn> I think the 2|3 may be auto-threading earlier than any("you expect", "it should be")

[20:40] <jnthn> So it results in two sequences

[20:40] <[Coke]> or, $x is 4, you have 4, 2, ... any (2,3) ... it's too late.

[20:40] <jnthn> One of which never terminates.

[20:40] <[Coke]> you already have your 2.

[20:41] <[Coke]> sub postfix:<!!>($x) { [*] $x, $x - 2 ... any(2, 3) }; say 6!!

[20:41] <masak> oh!

[20:41] <[Coke]> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... any(2, 3) }; say 6!!

[20:41] <masak> jnthn: yes, I think you're right.

[20:41] <[Coke]> yup, I was wrong. :)

[20:41] <p6eval> rakudo e26703: OUTPUT¬´(timeout)¬ª

[20:41] <masak> what I really wanted is not a junction, but an object which .ACCEPTs 2 or 3 ;)

[20:41] <dalek> specs: 0c7f42d | (Tobias Leich)++ | S32-setting-library/IO.pod:

[20:41] <dalek> specs: typo: was "multi multi note (...)"

[20:41] <dalek> specs: review: https://github.com/perl6/specs/commit/0c7f42d08e

[20:42] *** Detroit left
[20:42] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... class { method ACCEPTS($n) { $n == 2 || $n == 3 } } }; say 4!!; say 5!!

[20:42] <p6eval> rakudo e26703: OUTPUT¬´8‚ê§15‚ê§¬ª

[20:42] <masak> \o/

[20:43] <[Coke]> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... {* >=2} }; say 6!!

[20:43] <p6eval> rakudo e26703: OUTPUT¬´6‚ê§¬ª

[20:44] <[Coke]> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... {* >=2} }; say 4!!; say 5!!

[20:44] <p6eval> rakudo e26703: OUTPUT¬´4‚ê§5‚ê§¬ª

[20:44] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... 2<=*<=3 }; say 4!!; say 5!!

[20:44] <p6eval> rakudo e26703: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse quote-words subscript; couldn't find right angle quote‚ê§at /tmp/KcXUvl_XnJ:1‚ê§------> [32m, $x - 2 ... 2<=*<=3 }; say 4!!; say 5!![33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[20:44] <jnthn> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... * == 2|3 }; say 6!!

[20:44] <p6eval> rakudo e26703: OUTPUT¬´48‚ê§¬ª

[20:44] <[Coke]> jnthn++

[20:44] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... 2 <= * <= 3 }; say 4!!; say 5!!

[20:44] <p6eval> rakudo e26703: OUTPUT¬´4‚ê§5‚ê§¬ª

[20:44] <moritz> 2<= # <-- bad

[20:44] <masak> hm.

[20:44] <masak> moritz: yeah. momentary lapse.

[20:45] <masak> but still, the last one should be OK. why isn't it?

[20:45] <moritz> which last one?

[20:45] <masak> r: sub postfix:<!!>($x) { [*] $x, $x - 2 ... 2 <= * <= 3 }; say 4!!; say 5!!

[20:45] <p6eval> rakudo e26703: OUTPUT¬´4‚ê§5‚ê§¬ª

[20:45] <masak> 5!! should be 15.

[20:45] <FROGGS> moritz: would you say that IO::Socket::INET.recv is for strings and .read is for binary data?

[20:45] <TimToady> the RHS of ... should be able to do a smartmatch, so shouldn't autothread, I'd think

[20:45] * masak submits rakudobug

[20:45] <jnthn> TimToady: wfm, it's probably not hard to fix it that way.

[20:46] <moritz> FROGGS: .read is for binary data, .get and .lines are for strings

[20:46] <TimToady> I certainly expected 2|3 to work there

[20:46] <moritz> FROGGS: .recv could be either; happens to be Str right now, but we should really offer both options

[20:47] <[Coke]> so, someone on another chat server said something about a function being undefined for negative even integers. from this I googled to find the double factorial. and now we have a rakudobug. yay.

[20:47] <jnthn> TimToady: Is the "for is just map" thing decidedly staying the same, or is it in the set of things you're currently pondering?

[20:48] <moritz> r: say (2 <= * <= 3).perl

[20:48] <p6eval> rakudo e26703: OUTPUT¬´WhateverCode.new()‚ê§¬ª

[20:49] <TimToady> jnthn: I'm not thinking about changing that part; I'd like to see how the warning approach works out

[20:49] <TimToady> I'd be more likely to introduce some sugar for --> Nil and --> List

[20:49] <jnthn> TimToady: I'm more worried --> Nil feels like a design smell than I am about the warning, fwiw.

[20:49] <TimToady> no idea what that might be though

[20:51] <TimToady> the smelly thing about it, to my mind, is that it is introspecting .DEFINITE

[20:52] <TimToady> thought about syntax for value return like --> (42)

[20:52] <doy> seems like making for be equivalent to 'eager map' or something similiar would make more conceptual sense to me

[20:52] <TimToady> then --> () is "returns nothing"

[20:52] <TimToady> and then you can return a type as a value --> (Any)

[20:53] <jnthn> I think it bothers me because I don't feel having to add type information is a particularly right-feeling fix.

[20:53] <TimToady> but sigs ending with () seems a bit ucky

[20:53] *** xalbo joined
[20:53] <TimToady> well, special-casing 'for' is just as smelly, to me

[20:54] <jnthn> It's not really a special case

[20:54] <jnthn> If anything, it makes it more uniform with the other loops

[20:54] <TimToady> well,the real issue is whether the final statement is to be in sink context

[20:54] <jnthn> Which also always do their work "right away"

[20:55] <jnthn> Hm, true

[20:55] <TimToady> sink context is Perl6-ese for "side effects wanted"

[20:55] <jnthn> Just making it eager fixes the "programs don't behave right" thing, but not the memory leak.

[20:55] <TimToady> it's also what triggers "useless use of" warnings

[20:56] <TimToady> so it's fundamentally the Pascalish proc vs fun thing, but I don't want to use the declarators for that, since methods can also be proc-ish or fun-ish

[20:57] <TimToady> or was it "func"?  don't remember

[20:58] <jnthn> I dunno. I grew up on a basic dialect that did sub vs. function :)

[20:58] <japhb> I would just like to get to a place that I don't have to add boilerplate all over just to make it sane that I ended a subroutine with a for loop.

[20:58] <japhb> 'eager do for' is ... LTA

[20:59] <rurban> ad sockets: .recv is low-level with full options, .read is higher-level with max bytes only

[20:59] <rurban> we just do not support }g,s}etsockopt() options yet :)

[21:00] <masak> japhb: isn't 'eager for' enough?

[21:00] <japhb> And having a signature item at the top change not just the constraint on the return, but the semantics of a not-obviously-related looping construct as well, feels like spooky action at a distance.

[21:00] <TimToady> japhb: also thinking about how to give the optimizer enough info to actually do decent optimization, and return types figure into that heavily

[21:01] <japhb> masak, It may be -- I think I ended up with 'eager do for' working around a bug at some point, and the idiom stuck in my head.

[21:01] *** thou left
[21:01] <TimToady> I think it's mischaractarizing it to call it "boilerplate"

[21:01] <rurban> ad .recv(): here are the proposed options: https://github.com/parrot/parrot/commit/3f17b60f1f79a50898ae47e4bb12d3db57f8d250

[21:01] * jnthn keeps seeing a lot of people getting bitten by this "for loop at end of sub/method may run the code later" thing

[21:02] <japhb> OK, I can see that being a strong word.  But from my perspective, it's code that I have to add that makes the semantics sane *to me*.  It's kindof like //x from Perl 5.

[21:02] <TimToady> at worst, it's mis-huffmanized, I think

[21:02] <TimToady> but people do need to actually think about what a routine returns

[21:02] <flussence> I'd be okay with for loops there emitting a compile-time warning without an "eager" or "return"

[21:02] <moritz> please not

[21:03] <TimToady> and the --> is darn good documentation of that

[21:03] <moritz> warnings are the worst thing to do

[21:03] *** thou joined
[21:03] <moritz> because if you emit a warning, you discourage the lazy usage, because it warns

[21:03] <flussence> oh.

[21:03] <moritz> but then you could make the loop eager in the first place

[21:03] <japhb> I guess a big annoyance with the current state is something that the spec commit addressed, which is that if I forget to say either eager or sink, the semantics of the for have changed -- and I don't know about it until much later (unlike a return constraint failure which would die right out).  So the warning is at least helpful

[21:04] * moritz would be fine with 'for' being eager and 'map' being lazy

[21:04] <[Coke]> building hs-cabal via macports seems brain damaged.

[21:04] <japhb> Yes, mis-huffmanized is fair.  But I maintain that the interaction of things like chdir with laziness means that eager for and plain for are semantically different.

[21:04] <jnthn> moritz: eager or sinky?

[21:04] <japhb> Not just caring about return value.

[21:04] <flussence> whatever happens, please don't copy Rust's end-of-block fubar-ness

[21:04] <TimToady> which is?

[21:05] <flussence> trailing semicolon -> return Nil

[21:05] <jnthn> moritz: I think I just found the lingering method sinking bug.

[21:05] *** hash_table joined
[21:05] <jnthn> moritz: The one doy hit earlier

[21:05] <jnthn> Spectesting the fix

[21:05] <flussence> (no trailing semicolon -> return last statement's value)

[21:05] <xalbo> I'm curious, what is the case for "for" being anything other than eager and sinky, when "map" exists and handles the other case just fine?

[21:05] <[Coke]> I suppose requiring "return" to return a value is right out.

[21:06] <moritz> rurban: a versio of recv that returns a ByteBuffer would be awesome

[21:06] <japhb> Also, if the end of your for loop is a push call, and you forget to sink the for, the requirement to save all loop values means you may OOM because of the quadratic space explosion.  I know because I did it to myself repeatedly.  :-(

[21:06] <TimToady> xalbo: you'd like to be able to write list comprehensions in either order

[21:08] <xalbo> Doesn't map do both orders? That is, map as a method puts the list first, map as a function puts the operation first. Or am I out of date?

[21:09] <flussence> map as a method puts the list first, map as a function puts the map function call first...

[21:09] <japhb> Hmmm, what about calling for "mostly sinky"?  So that it defaults to sink/eager, unless it is part of a larger expression/statement?

[21:09] <japhb> So "return for ..." works as lazy, but "for" by itself is sink?

[21:10] <flussence> can't that be generalised to "implicit returns are eager"?

[21:10] <japhb> flussence, no, I think that's a false generalization.

[21:10] <japhb> You want to be able to say:

[21:10] <japhb> sub add_these ($a, $b) { $a + $b }

[21:10] <flussence> hm

[21:11] *** pmurias joined
[21:11] <pmurias> how can I install ASUSTek Computer, Inc. USB-N10 802.11n Network Adapter [Realtek RTL8188SU]

[21:11] <japhb> Well, you know what I mean.

[21:11] <TimToady> at the moment, I'm inclined to make it a hard error, saying "Use of 'for' as the final statement is disallowed; please put a return after it if it is procedural, or declare signature with --> List if it is functional" or some such

[21:11] <flussence> yeah

[21:11] <pmurias> sorry

[21:11] <pmurias> wrong channel

[21:12] <japhb> I still like 'return for', if that's what you want.

[21:12] <TimToady> except that syntax is currently invalid

[21:12] <TimToady> unless we turn return into a statement_prefix

[21:13] <masak> std: return for 1..3 # Illegal? I think not!

[21:13] <p6eval> std a8bc48f: OUTPUT¬´ok 00:00 42m‚ê§¬ª

[21:13] <masak> :P

[21:13] <japhb> I accept any variant that captures the flavor of what I mean: you have to state that you want a for to return loop values.

[21:13] <rurban> moritz: the default encoding for recv() is binary

[21:13] <rurban> but still, yes

[21:13] <jnthn> TimToady: If we make that an error, we invalidate a load of existing code.

[21:14] <flussence> .oO( maybe we should have --> return types on for loops )

[21:14] <TimToady> jnthn: sure, would require a deprecation cycle, or maybe a Deprecation Cycle

[21:14] <jnthn> TimToady: I think it'll also cause a lot of "wtf"... :(

[21:15] <jnthn> For all its problems, I still find making the imperative-style loop constructs never producing a result list the least bad option so far. :(

[21:16] <jnthn> My main problem with it being breaking list comprehensions...

[21:16] <TimToady> well, that will break a lot of code too

[21:16] <jnthn> Hm, true

[21:16] <TimToady> it's one of those design issues where the language simply doesn't make a needed distinction

[21:17] *** pmurias left
[21:17] <TimToady> we simply don't know whether the final statement is intended as imperative or functional

[21:18] *** kaare_ left
[21:18] <TimToady> and defaulting it either way is gonna screw someone up, and defaulting it neithier way is gonna screw someone up

[21:18] <TimToady> *neither

[21:19] <TimToady> and any solution that involves doctoring the end of the code strikes me as a mere workaround to the fundamental problem of not understanding the intent of the routine

[21:20] <TimToady> maybe we just need a special marker that says "this function is allowed to return a lazy list"

[21:20] <jnthn> To what degree is it fixable by having a forsink and a forresults (but probably one being called for and the other getting another name)?

[21:21] <TimToady> but that still doesn't help know whether you want the eager results of the loop

[21:21] <skids> .oO("use N00b": warn about things you normally wouldn't want warned)

[21:21] *** pmurias joined
[21:21] * FROGGS .oO( use help; )

[21:21] <jnthn> forsink = sink, no results. forresults = exactly what map does.

[21:21] <TimToady> jnthn: doesn't scale to other loops if we want to generalize

[21:22] <TimToady> rather have something composable

[21:22] <TimToady> it's what I'd characterize as a low-wattage solution, and we try to avoid those in P6

[21:22] <jnthn> Yes, I was kinda assuming we leave the other loops not producing a result list, given nobody seems to have missed them much... :)

[21:23] <jnthn> But we could go the composable route on all of 'em too I guess

[21:24] <TimToady> but again, these are kinda bandaids over the real problem of not knowing the intent of the routine

[21:24] <japhb> 'is lazy'?

[21:24] <japhb> Oh NM, you're talking procedural or functional, and that's an oblique angle

[21:25] <dalek> rakudo/nom: 99c4f9c | jnthn++ | src/Perl6/Actions.pm:

[21:25] <dalek> rakudo/nom: Fix a broken case of autosink.

[21:25] <dalek> rakudo/nom: 

[21:25] <dalek> rakudo/nom: $foo.bar() will not be a top-level callmethod, but will actually wrap

[21:25] <dalek> rakudo/nom: it in something to do Perl 6 type coercion if the method returns some

[21:25] <dalek> rakudo/nom: other object. This we need p6type in the autosink list too.

[21:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99c4f9c9b5

[21:26] <moritz> note that traits can only be an answer for routines

[21:26] <FROGGS> but adding a trait to the for loop (and maybe other statements) is most perl-six-y I think

[21:26] <moritz> but the problem with sink also exists with blocks

[21:26] <moritz> consider    try { for @list { die "foo" if $_ ~~ /OHNOEZ } } 

[21:26] <FROGGS> you can apply a trait to an anon block, right?

[21:27] <moritz> not with easy syntax

[21:27] <moritz> and such traits are really just band-aids

[21:27] <moritz> you don't want to litter you code with them

[21:28] <TimToady> if the try is in sink context, then so is the for, and the die, transitively (is where I'd like to get to, so that sink optimizations work well)

[21:29] <TimToady> Perl 5 manages this

[21:29] <dalek> roast: fa9e6b7 | jnthn++ | S04-statements/for.t:

[21:29] <dalek> roast: Test sink/method call/die interaction bug.

[21:29] <dalek> roast: review: https://github.com/perl6/roast/commit/fa9e6b744d

[21:30] <TimToady> as I said yesterday, I think all the eager contexts want to be able to propagate inward for optmization purposes

[21:30] <TimToady> sink/eager/hyper/race

[21:33] <TimToady> if this were the case, a 'for' in final position would always be eager *except* when some outer context actually expects a lazy result

[21:37] <TimToady> well, maybe that's an overstatement

[21:37] <moritz> I don't think we can reliably propagate sink context inwards

[21:38] <TimToady> why not?

[21:38] *** not_gerd joined
[21:38] <not_gerd> hello, #perl6

[21:38] <phenny> not_gerd: 09 Jan 20:19Z <jnthn> tell not_gerd Grammar::Tracer issue fixed, and also added a test. Still gotta look at the Grammar::Debugger issue.

[21:38] <not_gerd> jnthn++

[21:38] *** stevan_ joined
[21:38] <moritz> TimToady: well, maybe with extra run-time meta information we could

[21:39] <TimToady> routines without explicit return specs might have to maintain a dynamic variable, seems to be about the limit of it

[21:39] *** thou left
[21:39] <not_gerd> OO question: if I want to initialize an attribute based on the value of a (public) attribute of the parent class, do I need to write a custom &new?

[21:39] <moritz> r: sub f() { fail "foo" }; f(); say 42 # jnthn, any idea why this doesn't throw the exception?

[21:39] <p6eval> rakudo e26703: OUTPUT¬´42‚ê§¬ª

[21:40] <moritz> not_gerd: no

[21:40] <jnthn> r: sub f() { fail "foo" }; f().sink; say 42

[21:40] <p6eval> rakudo e26703: OUTPUT¬´foo‚ê§  in method sink at src/gen/CORE.setting:10405‚ê§  in block  at /tmp/MeGJ70txCP:1‚ê§‚ê§¬ª

[21:40] <moritz> r: class A { has $.x = 42 }; class B is A { has $.y = self.x / 2 }; say B.new(x => 18).y

[21:40] <p6eval> rakudo e26703: OUTPUT¬´9‚ê§¬ª

[21:41] <moritz> not_gerd: see above

[21:41] <TimToady> or to look at it backwards, every caller can report to the callee its disposition for final statements, and for routines of known return specification, that disposition is a constant

[21:41] *** thou joined
[21:42] <moritz> not_gerd: objects are initialized parent-first, so if you need something more complex than a default value, you can define a submethod BUILD

[21:42] <TimToady> so perhaps then the motivation for --> is more for speed than correctness

[21:42] <jnthn> r: sub f() { fail "foo" }; say f().defined

[21:42] <p6eval> rakudo e26703: OUTPUT¬´False‚ê§¬ª

[21:42] <jnthn> moritz: Because we check for definedness

[21:42] <TimToady> and I suspect people will be quite motivated to add --> if it makes their programs run faster :)

[21:42] <jnthn> moritz: Should we only be checking for "not a type object"?

[21:42] <moritz> jnthn: do we? I thought we checked for p6definite

[21:43] *** hash_table left
[21:43] <jnthn> moritz: We do both

[21:43] <moritz> erm, what?

[21:43] <jnthn> Because .DEFINITE is a *really* cheap test, I assume.

[21:43] <xalbo> Speed, but also documentation. --> Nil seems a handy way to make sure that someone doesn't accidentally try to get a value back from your routine.

[21:43] <moritz> jnthn: ok, we shouldn't :-)

[21:44] <moritz> jnthn: what's the difference between isconcrete and p6definite?

[21:44] <doy> TimToady: that sounds like it would be a reasonable solution to me

[21:44] <jnthn> moritz: uh, good question

[21:44] <skids> What's the rule as to the laziness of the loop control iterator?

[21:44] <moritz> I guess checking only .DEFINITE would be righter

[21:45] <moritz> because we really want Failure in sink context to blow up

[21:45] <jnthn> moritz: oh

[21:45] <jnthn> nqp::isconcrete returns an integer

[21:45] <jnthn> perl6_definite returns a Bool (True or False)

[21:45] <moritz> but they check the same logic?

[21:45] <jnthn> moritz: Yes

[21:45] <jnthn> moritz: Just different result type

[21:46] <jnthn> moritz: Shall I try it?

[21:47] <moritz> jnthn: yes, please

[21:47] * moritz needs to go to bed now, have to get up early tomorrow :/

[21:47] <jnthn> aww

[21:47] <jnthn> OK, trying :)

[21:47] <jnthn> Will commit/push if spectest looks good

[21:48] <xalbo> The new spec for uniq is nice, but it's still a little less explicit than I think it should be for whether the order of the remaining elements is preserved.

[21:49] <not_gerd> r: (class :: is X::AdHoc { has $!first-user-frame = self.backtrace.grep({ !.is-hidden && !.is-setting && .is-routine })[0] }).new

[21:49] <p6eval> rakudo e26703: OUTPUT¬´No such method 'backtrace' for invocant of type 'Any'‚ê§  in method new at src/gen/CORE.setting:9095‚ê§  in method backtrace at src/gen/CORE.setting:9226‚ê§  in method  at /tmp/ZcPXDcuYGT:1‚ê§  in block  at src/gen/CORE.setting:779‚ê§  in method BUILDALL at src/gen/CORE.sett‚Ä¶

[21:50] <moritz> xalbo: then reword :-)

[21:51] <masak> 'night, #perl6

[21:51] <moritz> 'night masak, #perl6

[21:51] <jnthn> moritz: darn, at least one fail

[21:51] <jnthn> no, 2 :(

[21:51] <xalbo> "suppresses all subsequent instances": Turns out, I just suck at reading. Apologies.

[21:52] <jnthn> It does fix the bug though...

[21:56] <jnthn> lives_ok { @arr[*-1] },  "readonly accessing [*-1] of an empty array is ok (1)";

[21:56] <jnthn> That now fails, since @arr[*-1] returns a Failure, which lives_ok then sinks.

[21:57] <diakopter> change the test to look for Failure

[21:57] <diakopter> :)

[21:59] <jnthn> Yeah, all the test regressions seem at first glance to be due to sinking failures

[22:01] <jnthn> ah, there is a genuine bug that at least one test exposes, though

[22:02] <skids> tests++

[22:03] *** thou left
[22:03] *** rindolf left
[22:03] <not_gerd> bye, #perl6

[22:03] *** not_gerd left
[22:04] <skids> .oO(use Test::GlaDOS)

[22:05] *** thou joined
[22:10] *** skids left
[22:15] *** xinming left
[22:17] *** xinming joined
[22:20] *** snearch left
[22:22] *** djanatyn joined
[22:24] <dalek> roast: d0088f5 | jnthn++ | S (2 files):

[22:24] <dalek> roast: Fix tests for Failure/sink interaction.

[22:24] <dalek> roast: 

[22:24] <dalek> roast: A couple of places sunk unhandled Failures, unintentionally. This

[22:24] <dalek> roast: corrects them, now that Rakudo does Failure sinking.

[22:24] <dalek> roast: review: https://github.com/perl6/roast/commit/d0088f5d4c

[22:25] <dalek> rakudo/nom: 45c445a | jnthn++ | src/core/Failure.pm:

[22:25] <dalek> rakudo/nom: Failure.sink should not throw if handled.

[22:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45c445ac7b

[22:25] <dalek> rakudo/nom: 8ca20db | jnthn++ | src/Perl6/Actions.pm:

[22:25] <dalek> rakudo/nom: Remove bogus defined test in sink handling.

[22:25] <dalek> rakudo/nom: 

[22:25] <dalek> rakudo/nom: This means that Failure is now correctly sunk.

[22:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ca20dba80

[22:25] *** preflex joined
[22:26] <FROGGS> how do I compare Bufs? == and eq doesnt work

[22:27] <jnthn> eqv may work

[22:28] <FROGGS> ohh ya, it is listen in Buf.pm

[22:28] <FROGGS> (that I have open...)

[22:31] <dalek> roast: 61f8766 | jnthn++ | S (2 files):

[22:31] <dalek> roast: Unfudge a couple of now-passing tests.

[22:31] <dalek> roast: review: https://github.com/perl6/roast/commit/61f8766f7b

[22:33] *** FROGGS left
[22:37] *** MayDaniel_ left
[22:41] *** spider-mario left
[22:42] *** thou left
[22:42] *** lichtkind joined
[22:43] *** thou joined
[22:53] <lichtkind> call me janitor

[22:54] <jnthn> hi, janitor

[22:55] <lichtkind> unless perl 6 wiki is put off i feel obligated to clean out spam there

[22:58] <dalek> roast: 6b0ddf1 | jnthn++ | S32-array/splice.t:

[22:58] <dalek> roast: Unfudge now-passing splice tests.

[22:58] <dalek> roast: review: https://github.com/perl6/roast/commit/6b0ddf171d

[22:59] <dalek> rakudo/nom: 099d0ec | jnthn++ | src/core/List.pm:

[22:59] <dalek> rakudo/nom: Implement whatever star cases of splice.

[22:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/099d0ecfb4

[22:59] *** whiteknight joined
[23:06] <lichtkind> wiki is clean again

[23:07] <jnthn> lichtkind++

[23:07] *** PacoAir left
[23:07] <japhb> lichtkind++

[23:11] <dalek> nqp: d5c0011 | jnthn++ | src/HLL/Compiler.pm:

[23:11] <dalek> nqp: Fix REPL variable updating bug.

[23:11] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d5c0011763

[23:13] *** slayer101_ joined
[23:14] <dalek> rakudo/nom: 4eca84f | jnthn++ | tools/build/NQP_REVISION:

[23:14] <dalek> rakudo/nom: Bump NQP_REVISION to get REPL fix.

[23:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4eca84f6d5

[23:16] *** sivoais left
[23:16] <jnthn> TimToady: Sorry if you missed it, but if you have chance to comment on what the precedence of setops like (|) would be, it'd help me get https://rt.perl.org/rt3/Ticket/Display.html?id=116100 fixed :)

[23:16] <jnthn> TimToady: er, if *I* missed it!

[23:16] *** sivoais joined
[23:17] *** pmurias left
[23:22] *** lichtkind left
[23:25] *** tokuhiro_ joined
[23:29] *** japhb left
[23:29] *** japhb joined
[23:31] *** stopbit left
[23:35] *** cognominal joined
[23:37] <dalek> rakudo/nom: 3c475e3 | jnthn++ | src/core/operators.pm:

[23:37] <dalek> rakudo/nom: Fix sequences with Junction endpoints.

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3c475e3f40

[23:43] *** skids joined
[23:50] *** aloha left
[23:53] *** hash_table joined
[23:53] *** aloha joined
[23:59] <jnthn> sleep &

[23:59] <diakopter> o/

