[00:01] <sorear> nqp: my int $x; say($x)

[00:01] <camelia> nqp: OUTPUT¬´0‚ê§¬ª

[00:01] <sorear> nqp: my int $x; say($x)

[00:01] <camelia> nqp: OUTPUT¬´0‚ê§¬ª

[00:09] *** raiph left
[00:12] *** raiph joined
[00:17] <sorear> heh.  I'm reading documents on delimited continuations in Haskell... Pugs is listed as a major user :D

[00:20] <ssutch> hmm. now im stumped. i need to add comment support to this grammar, comments can appear any where whitespace can.

[00:21] <ssutch> i guess i have to switch back to token, add back all the <.ws> but make my own .ws that includes '// comments'

[00:22] <ssutch> seems like there should be a better way

[00:22] <sorear> ssutch: just make your own ws

[00:23] *** ecocode left
[00:23] <sorear> if you override ws, rule will call your override instead of the builtin

[00:23] <ssutch> oh, cool

[00:23] <ssutch> can i do something like token ws { <.super> | <comment> }

[00:24] <sorear> I'm not sure if it's actually possible to do that

[00:25] <sorear> but there's not much point since the default is "token ws { <!ww> \s* }

[00:25] <sorear> "

[00:26] <ssutch> ok

[00:27] *** konundra joined
[00:27] <ssutch> what is the difference between <.ws> and <ws>?

[00:30] <colomon> . means it doesn't capture

[00:31] <colomon> o/

[00:31] * colomon hopes he is right.  :)

[00:31] <masak> you are :)

[00:32] *** konundra left
[00:32] <masak> "don't store in a keyed slot in the match object"

[00:33] <ssutch> r: https://gist.github.com/samuraisam/5786535

[00:33] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢‚ê§    // import some shit‚ê§    // more shit // and more shit‚ê§    package fart ;‚ê§ÔΩ£‚ê§ proto => ÔΩ¢ÔΩ£‚ê§‚ê§¬ª

[00:33] <ssutch> my ws just seems to gobble everything up

[00:34] <dalek> nqp: 70b445b | sorear++ | t/jvm/01-continuations.t:

[00:34] <dalek> nqp: Test dynamic binding interaction

[00:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/70b445b6c7

[00:34] <dalek> nqp: 6cfee5a | sorear++ | docs/continuations.pod:

[00:34] <dalek> nqp: Updates for documentation

[00:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6cfee5accc

[00:34] <sorear> dinner&, then implement GatherIter

[00:35] <sorear> (and probably find more bugs)

[00:36] <colomon> sorear++

[00:49] <ssutch> how can i make this rule stop when it reaches a newline: token comment       { '//' [.]*? <.nl> $ }

[00:49] <ssutch> it just keeps ticking right along after hitting a <.nl> (which is defined as { \xA | "\r" \xA | "\r" | "\f" })

[00:50] <colomon> try \v (vertical whitespace) instead?

[00:50] <colomon> though the $ there worries me

[00:50] *** risou_awy is now known as risou

[00:51] <ssutch> how so?

[00:51] <colomon> what are you trying to test there?

[00:51] <colomon> newline followed by end-of-string?

[00:52] <ssutch> no

[00:52] <ssutch> yeah that doesn't make a whole lot of sense, having that ther 

[00:52] <colomon> if you take out the <.nl> and $, you can use $$ (end-of-line) there

[00:53] *** kivutar left
[00:54] <ssutch> hey! :)

[00:54] <ssutch> that works great

[00:54] * colomon probably should have used it a few times in the ABC grammar.  :)

[00:54] <ssutch> so now i have:

[00:54] <ssutch> token comment       { '//' [.]*? $$ }

[00:54] <ssutch>     token ws            { <!ww> [\s | <.comment>]* }

[00:55] <ssutch> which appears to play well with all the rules

[00:55] <ssutch> (c/c++ style // comments)

[00:55] <ssutch> using the $$ seems a lot more efficient to match

[00:55] <ssutch> (watching the Grammar::Tracer)

[00:56] <colomon> cool

[00:57] <colomon> it certainly is a nice concept to have in your toolkit

[01:00] *** FROGGS_ joined
[01:04] *** FROGGS left
[01:12] <timotimo_> ssutch: what is [.]*? supposed to do? shouldn't you be able to do .*? instead?

[01:12] <timotimo_> maybe it was bigger once

[01:12] <ssutch> ill try it out

[01:13] <ssutch> it appears to work the same

[01:17] <timotimo_> i don't think it makes an actual difference

[01:18] <timotimo_> maybe the resulting AST is a bit smaller

[01:18] <timotimo_> hm, the dumping of QAST::Regex nodes seems a bit boring

[01:19] <masak> 'night, #perl6

[01:34] <timotimo_> ssutch: fwiw, if you change '(' ... ')' into '(' ~ ')' [...], you'll get nicer error messages when the closing part is missing

[01:34] <timotimo_> r: say "(foo" ~~ /'(' \w+ ')'/;

[01:34] <camelia> rakudo b2072f: OUTPUT¬´Nil‚ê§¬ª

[01:34] <timotimo_> r: say "(foo" ~~ /'(' ~ ')' [\w+] /;

[01:34] <camelia> rakudo b2072f: OUTPUT¬´Unable to parse expression in ; couldn't find final ')'‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1037‚ê§  in regex  at /tmp/jsCohX6DZ_:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10509‚ê§  in method ACCEPTS at src/gen/CORE.setting:683‚ê§  in block  at /tmp/jsCohX6DZ_‚Ä¶

[01:35] <ssutch> oh cool

[01:35] <timotimo_> r: given "(foo" { when /'(' ~ ')' [\w+] / { say "test" } default { say "yup" } }

[01:35] <camelia> rakudo b2072f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/qaRBXGFeb1:1‚ê§------> [32m when /'(' ~ ')' [\w+] / { say "test" } [33m‚èè[31mdefault { say "yup" } }[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        statement end‚ê§        statement modifier‚ê§        statement modifie‚Ä¶

[01:35] <timotimo_> r: given "(foo" { when /'(' ~ ')' [\w+] / { say "test" }; default { say "yup" } }

[01:35] <camelia> rakudo b2072f: OUTPUT¬´Unable to parse expression in ; couldn't find final ')'‚ê§  in any FAILGOAL at src/stage2/QRegex.nqp:1037‚ê§  in regex  at /tmp/fkjBYDR09G:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:10509‚ê§  in method ACCEPTS at src/gen/CORE.setting:683‚ê§  in block  at /tmp/fkjBYDR09G‚Ä¶

[01:35] <timotimo_> and now you need to wrap it in "try" :|

[01:35] <timotimo_> i'm too tired to decide if this is something bad or good.

[01:40] *** konundra joined
[01:55] <ssutch> is there a way to get the full path of the current file $?FILE is just the base name

[01:55] *** raiph left
[01:57] <timotimo_> do you want to see my very ugly solution to figuring out what file & line my function was called from? :D

[01:58] <ssutch> hah, yes

[01:58] <timotimo_> https://github.com/timo/perl6-vortrag/blob/master/lib/Demonstrate.pm6#L49

[01:58] <timotimo_> but as you can see it's also relative paths

[01:58] <timotimo_> which would give you only the basename + extension for your "main script" anyway

[01:59] <ssutch> looks like i can go say IO::Path.new($?FILE).absolute

[01:59] <timotimo_> r: say $?FILE.path.absolute;

[01:59] <camelia> rakudo b2072f: OUTPUT¬´IO::Path</tmp/wRG91sC32C>‚ê§¬ª

[01:59] <sorear> ssutch: the canonical way to write that is token comment { '//' \V* }

[01:59] <ssutch> r: say $?FILE.path.absolute.directory

[01:59] <sorear> \N* rather

[01:59] <camelia> rakudo b2072f: OUTPUT¬´/tmp‚ê§¬ª

[02:00] *** raiph joined
[02:00] <ssutch> token comment       { '//' .*? $$ } is what i have

[02:01] <ssutch> so it should just be token comment { '//' \N* }

[02:01] <sorear> yeah, that's much slower

[02:01] <ssutch> what is the difference if you don't mind?

[02:02] <sorear> \N* means "match a sequence of non-newline characters"; it's compiled to a single op

[02:02] <sorear> .*? $$ means "match 0 characters.  check for newline.  if you don't find one, repeat with +1 character"

[02:03] <sorear> it requires going through the backtrack engine

[02:03] <sorear> i suppose the long way could be optimized to the short fast way, but that's not done yet

[02:04] * sorear attempts to figure out how to build a rakudo-jvm against HEAD NQP

[02:12] <ssutch> wow, thanks, sorear 

[02:14] <sorear> wow?

[02:14] <raiph> r: sub foo () { \(:bar, :baz) }; say foo<baz>

[02:14] <camelia> rakudo b2072f: OUTPUT¬´True‚ê§¬ª

[02:15] <raiph> r: sub foo () { %(:bar, :baz) }; say foo<baz> # also works

[02:15] <camelia> rakudo b2072f: OUTPUT¬´True‚ê§¬ª

[02:15] <raiph> r: sub foo () { (:bar, :baz) }; say foo<baz> # could this work, and would it compile time check?

[02:15] <camelia> rakudo b2072f: OUTPUT¬´postcircumfix:<{ }> not defined for type Parcel‚ê§  in method gist at src/gen/CORE.setting:10161‚ê§  in method gist at src/gen/CORE.setting:893‚ê§  in sub say at src/gen/CORE.setting:11047‚ê§  in block  at /tmp/JahlZPe2Ha:1‚ê§‚ê§¬ª

[02:15] <timotimo_> r: sub foo () { (:bar, :baz).{} }; # is this in rakudo yet?

[02:15] <camelia> rakudo b2072f:  ( no output )

[02:15] <timotimo_> r: sub foo () { (:bar, :baz).{} }; say foo<baz> # is this in rakudo yet?

[02:15] <camelia> rakudo b2072f: OUTPUT¬´postcircumfix:<{ }> not defined for type Parcel‚ê§  in method gist at src/gen/CORE.setting:10161‚ê§  in method gist at src/gen/CORE.setting:893‚ê§  in sub say at src/gen/CORE.setting:11047‚ê§  in block  at /tmp/a03Z1vxXCj:1‚ê§‚ê§¬ª

[02:16] <ssutch> i dunno, just interesting

[02:16] <raiph> timotimo_: snap ;)

[02:17] <timotimo_> i thought .{} was intended to be a nice contextualizer, like %(...) would be

[02:18] <ssutch> how do i pass a smart matcher to dir, it takes a named parameter called test, so i am trying it like this dir 'dirname', :test</proto$/> to find all things that end with proto

[02:18] <timotimo_> :test</proto$/> will turn that into a string

[02:19] <colomon> to dir method?

[02:19] <timotimo_> r: :test(/proto$/).perl.say;

[02:19] <camelia> rakudo b2072f: OUTPUT¬´"test" => regex(Mu : Mu *%_) { ... }‚ê§¬ª

[02:19] <timotimo_> r: :test</proto$/>.perl.say;

[02:19] <camelia> rakudo b2072f: OUTPUT¬´"test" => "/proto\$/"‚ê§¬ª

[02:19] <ssutch> ahh

[02:19] <ssutch> sweet, thanks

[02:19] <timotimo_> <...> is, in most places, the new quotewords syntax:

[02:20] <timotimo_> r: <foo bar baz>.perl.say

[02:20] <camelia> rakudo b2072f: OUTPUT¬´("foo", "bar", "baz")‚ê§¬ª

[02:20] * sorear has an up-to-date sorear/rakudo fork

[02:21] <ssutch> right

[02:23] *** JimmyZ joined
[02:23] <raiph> "a Parcel ... lets you access the named [elements] by their name" (from S08)

[02:24] <timotimo_> it does? oh!

[02:24] <timotimo_> er, hold on, how does it interact with multiple elements of the same name?

[02:31] <raiph> Reading specs to see what the deal is re parcels; followed link to a 2009 dialog; apparently "spec" isn't abbr for "specification" but rather "speculation"... :)

[02:31] <timotimo_> :3

[02:31] <ssutch> shouldn't slurp take an IO::Path, in addition to a string. seems silly to write (slurp $path.Str)

[02:32] <colomon> maybe?  but there's definitely a slurp method on IO::Path

[02:33] <colomon> r: say dir

[02:33] <camelia> rakudo b2072f: OUTPUT¬´IO::Path<star> IO::Path<src> IO::Path<.subversion> IO::Path<.bashrc> IO::Path<nom-inst1> IO::Path<toqast> IO::Path<test3.pl> IO::Path<.profile> IO::Path<t> IO::Path<nom-inst2> IO::Path<nom-inst> IO::Path<toqast-inst> IO::Path<toqast-inst2> IO::Path<examples> IO::Pa‚Ä¶

[02:33] <colomon> r: say "test3.pl".path.slurp

[02:33] <camelia> rakudo b2072f: OUTPUT¬´No such method 'slurp' for invocant of type 'IO::Path'‚ê§  in block  at /tmp/FgIstDplmx:1‚ê§‚ê§¬ª

[02:33] <colomon> :\

[02:33] <timotimo_> r: say "test3.pl".IO.slurp;

[02:33] <camelia> rakudo b2072f: OUTPUT¬´use Test;‚ê§‚ê§{‚ê§    "fooxbar" ~~ /x/;‚ê§    is $/.prematch, "foo", ".prematch works";‚ê§    is $/.postmatch, "bar", ".postmatch works";‚ê§‚ê§    is ("foo" ~~ /(f)/).kv.join("|"), '0|f', '.kv sees positional';‚ê§    is ("foo" ~~ /$<x>=[f]/).kv.join("|"), 'x|f', '.kv sees names';‚Ä¶

[02:33] <timotimo_> hum.

[02:34] <labster> .IO.open.slurp?

[02:34] <raiph> r: say slurp("test3.pl")

[02:34] <timotimo_> er, wha?

[02:34] <camelia> rakudo b2072f: OUTPUT¬´use Test;‚ê§‚ê§{‚ê§    "fooxbar" ~~ /x/;‚ê§    is $/.prematch, "foo", ".prematch works";‚ê§    is $/.postmatch, "bar", ".postmatch works";‚ê§‚ê§    is ("foo" ~~ /(f)/).kv.join("|"), '0|f', '.kv sees positional';‚ê§    is ("foo" ~~ /$<x>=[f]/).kv.join("|"), 'x|f', '.kv sees names';‚Ä¶

[02:34] <timotimo_> r: "test3.pl".IO.open.read().chars

[02:34] <camelia> rakudo b2072f: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in method read at src/gen/CORE.setting:11184‚ê§  in block  at /tmp/0h98j2DU9H:1‚ê§‚ê§¬ª

[02:35] <labster> yeah, that might need fixed

[02:35] <timotimo_> anyway, i should be heading towards bed.

[02:35] <colomon> labster: IO::Path.slurp should be there, no?  I don't see it in the spec, either, but....

[02:36] <labster> Perhaps, but I just have decide which is appropriate for IO::Handle, and which for IO::Path

[02:37] <labster> I don't think the whole "one giant IO object" thing worked out so well.

[02:38] <colomon> that one seems like it should be on both, IMO

[02:39] <labster> slurp, spurt, and open, should be in both

[02:40] <labster> anything else?

[02:41] <colomon> lines?

[02:42] <labster> lines currently requires an open file handle, but that could be changed too.

[02:43] <labster> oh, never mind, .get opens it for .lines

[02:43] <colomon> the thing about slurp, spurt, and lines is they all make sense on an entire file

[02:43] <labster> I've been thinking about defining .succ and .pred for IO::Path, too.

[02:44] <timotimo_> based on dir()?

[02:44] <labster> Either that, or just inherit from Str.succ.  I haven't decided.

[02:44] <colomon> .... what's the use case?

[02:45] <labster> r: say "file01.txt".succ

[02:45] <camelia> rakudo b2072f: OUTPUT¬´file02.txt‚ê§¬ª

[02:45] <colomon> that does seem pretty handy

[02:46] <labster> Yeah.  based on dir() would be the most magical, but it would also be slow, as it would have to read the directory and sort on each successive call.

[02:48] <colomon> I think the succ thing is better if it *isn't* based on dir.

[02:48] <timotimo_> agreed

[02:48] * timotimo_ disappears

[02:48] <labster> maybe in a module then :)

[02:48] <labster> good night timotimo_ 

[02:49] <colomon> o/

[02:50] <colomon> isn't there a readdir method for iterating through a directory?

[02:50] <labster> contents

[02:51] <labster> the same as dir(), it's a lazy list.

[02:51] <labster> But no, we don't have directory handles like Perl 5.

[02:52] <colomon> contents is the sub/method name?

[02:53] <labster> yes.  Unless you can think of something better.

[02:53] <colomon> how's it different from dir?

[02:53] <labster> dir() === IO::Path.contents

[02:54] <labster> Is there a use case for P5 style readdir?

[02:54] <colomon> labster: not that I can think of, if dir is lazy.

[02:55] <colomon> I just thought it was there.  Might have just done too much p5 programming lately.  :)

[02:55] <labster> opendir ==> readdir ==> closedir is one of my less favorite parts of p5

[02:56] <labster> Well, I have a whole bunch of path methods to add now:  chmod, rename, link, symlink, slurp, spurt, lines, succ, pred

[02:56] <colomon> labster: it's brill compared to the C equivalent, isn't it?

[02:57] <labster> I think I'm glad I'm so ignorant of C.

[02:57] *** RedditAnalytics left
[02:58] <colomon> C is opendir, readdir, closedir too, actually.

[02:58] <colomon> let's celebrate our dir

[02:59] * labster reads rosetta code

[02:59] <labster> by Jove, you're right!

[03:07] *** tgt left
[03:08] <ssutch> how can i tell which line/character grammar.parse fails on

[03:19] <colomon> grammar debugger?

[03:20] <colomon> oooo, rakudo-jvm builds again, and does 2 ** 3 correctly!

[03:22] *** woosley1 joined
[03:23] <JimmyZ> ssutch: https://github.com/jnthn/rakudo-debugger

[03:23] <JimmyZ> sorry, it's https://github.com/jnthn/grammar-debugger

[03:23] <ssutch> JimmyZ: i am using that, it's just a little impractical

[03:24] <JimmyZ> oh

[03:24] <ssutch> my test files are ~500kb so it takes like 5 mins

[03:24] <ssutch> to get to the place where it ies

[03:25] *** SamuraiJack joined
[03:27] *** benabik left
[03:33] *** preflex left
[03:34] <sorear> o/ labster 

[03:34] <colomon> \o sorear

[03:35] *** preflex joined
[03:35] *** ChanServ sets mode: +v preflex

[03:37] <Teratogen> I would think that threads would have been built into the core of Perl 6 from the beginning.

[03:37] <Teratogen> Why try to bolt it on afterwords?

[03:39] <JimmyZ> Teratogen: Patch welcome

[03:39] <Teratogen> it's too late to patch

[03:39] <Teratogen> it should have been in the specification!

[03:40] <lue> http://perlcabal.org/syn/S17.html  # since 13 June 2005, according to the top of the file

[03:40] <lue> Teratogen: ^^^

[03:41] <lue> (yes, it needs plenty of work, but it is there)

[03:44] <labster> \o sorear

[03:45] <sorear> Teratogen: are you here to be productive or just to complain?

[03:45] <labster> hyper ops, async, hyper, and race have been in the specs for a long time.

[03:46] <Teratogen> i am here to be productive!

[03:46] <JimmyZ> Ok, then it's not late

[03:46] <Teratogen> I just want threads in Perl 6 so I can write Android apps in Perl 6!

[03:46] <labster> tl;dr: none of us were smart enough to figure out parrot threads, so we're trying to build a thread implementation on a platform we do understand.  The implementations should inform the specification, but the basic ideas are already included.

[03:47] <sorear> Teratogen: niecza has had threads for years

[03:47] <sorear> real, working threads

[03:47] <Teratogen> cool

[03:47] <sorear> and you just ignore them and pretend they don't exist

[03:47] <sorear> it makes me sad/mad

[03:47] <labster> correction: sorear++ and au++ are smart enough to implement threads.

[03:52] <lue> .oO(It just so happens that Parrot's threads were apparently problematic, thus rakudo hasn't implemented S17 fully)

[03:53] <geekosaur> I thought parrot didn't have weortking threads until recently

[03:53] <geekosaur> *working

[03:53] <geekosaur> and the current state of them is deemed unsatisfactory

[03:53] <geekosaur> (i.e. they may work for some things but are not yet viable for rakudo)

[03:54] <sorear> weird threads

[03:55] <lue> I've never been too involved with rakudo or parrot, so I'm not the most reliable source on the subject :) .

[03:58] <geekosaur> my impression was that parrot had an impossible thread spec that wanted to be all things to all people, and within the past 6 months or so it was thrown out and some kind of actual thread implementation was added. but as sorear said, "weird threads"

[03:59] <geekosaur> ...so, if you want Rakudo to have a working thread implementation, either help Parrot get real threads or help get rakudo-jvm going :)

[04:00] <geekosaur> (or one of the other backends e.g. MoarVM)

[04:01] <geekosaur> ..or use Niecza which has threads now

[04:04] <sorear> I see there's still plenty to do with rakudo-jvm

[04:04] <sorear> (It crashes when trying to print sorry messages)

[04:05] <geekosaur> tbh I didn't think it worked at all yet, they were still working on nqp-jvm?

[04:05] <geekosaur> hackathon may have gotten more done than I realized

[04:06] <sorear> I spent the hackathon working on nqp-jvm

[04:06] <sorear> got it passing all tests by the end

[04:06] <geekosaur> ah

[04:09] <sorear> hmm, we might need to split class files eventually

[04:09] <sorear> the constant table of CORE.setting.class is more than half full! D:

[04:10] <sorear> 36,416 entries

[04:10] <Teratogen> you mean constants like 3.14159?

[04:12] <sorear> Teratogen: http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4

[04:20] <Teratogen> neat

[04:29] *** Patterner left
[04:31] *** Psyche^ joined
[04:31] *** Psyche^ is now known as Patterner

[04:42] <sorear> blegh

[04:48] <sorear> .tell jnthn so uh.. does take have to be a control exception?  because supporting continuation operations within an exception handler = </3.  also I'm not immediately seeing how to catch the take exception

[04:48] <yoleaux> sorear: I'll pass your message to jnthn.

[04:58] <sorear> i guess making the nqp exception engine not a continuation barrier would be horrible, but not *unspeakably* horrible

[05:05] *** JimmyZ left
[05:17] <diakopter> sorear: my intuition tells me that would add a lot of checks.. am I far off?

[05:19] *** Teratogen left
[05:21] <sorear> not so much "add lots of checks" as "rewrite nested loops as goto soup"

[05:22] <sorear> .seen jnthn

[05:22] <yoleaux> I saw jnthn 13 Jun 2013 12:18Z in #perl6: <jnthn> airport, stuff...be back sometime &

[05:22] <diakopter> merge the frames? I thought nqp/rakudo's compilers put all scopes in their own frames

[05:22] <sorear> I'm not sure what frames have to do with this

[05:23] <sorear> what problema re you trying to solve?

[05:23] <diakopter> I didn't see how you could goto across frames

[05:26] <sorear> diakopter: the exception engine is java, not nqp

[05:29] *** Teratogen joined
[05:30] <diakopter> is that different from the "nqp exception engine" you mentioned above?

[05:30] <sorear> the nqp exception engien is written in java

[05:31] <sorear> https://github.com/perl6/nqp/blob/master/src/vm/jvm/runtime/org/perl6/nqp/runtime/ExceptionHandling.java#L50

[05:31] <diakopter> well so far you've answered none of my questions directly, and I can't seem to infer what you want me to infer from your indirect answers; afk&

[05:31] <sorear> this needs to be modified to not be a continuation barrier

[05:32] <sorear> i'm answering to the best of my ability, please ask better questions

[05:33] <ssutch> r: '23.0' ~~ /<[1..9]>\d+!\B/

[05:33] <camelia> rakudo b2072f:  ( no output )

[05:33] <ssutch> r: '23.0' ~~ /<[1..9]>\d+!\B/

[05:33] <camelia> rakudo b2072f:  ( no output )

[05:34] <ssutch> r: '23.0' ~~ /<[1..9]>\d+\B/

[05:34] <camelia> rakudo b2072f:  ( no output )

[05:36] <ssutch> hm, trying to match 1..9 that doesn't have a period at the end

[05:37] <sorear> .ask jnthn Why does dieInternal return a value?

[05:37] <yoleaux> sorear: I'll pass your message to jnthn.

[05:37] <ssutch> to differentiate between ints and floats

[05:42] *** kaare_ joined
[05:43] *** dylanwh left
[05:43] *** dylanwh joined
[05:43] <sorear> ssutch: <!before '.'> *but* you don't have to do this

[05:44] <sorear> ssutch: it's better to use a proto regex and let longest-token semantics do the distinguishing

[05:44] <ssutch> okay

[05:45] <sorear> if you have [[ proto token foo {*}; token foo:A { abc }; token foo:B { def } ]] then it acts a lot like [[ token foo { abc | def } ]]

[05:45] <ssutch> sorear: https://gist.github.com/samuraisam/5790917

[05:47] <sorear> ssutch: as a matter of style, I prefer to use the bare :foo form rather than :sym<foo> *unless* <sym> is used in the body

[05:47] <ssutch> ahh okay, that makes sense

[05:48] <sorear> ssutch: so somewhere higher up you want [[ proto token value {*}; token value:int { <int-lit> }; token value:float { <float-lit> }; token value:bool { <bool-lit> } ]]

[05:49] <ssutch> so what i did before was token constant { [<int-lit> | <float-lit> | <bool-lit> | <str-lit> | <ident>] }

[05:49] <sorear> or you could flatten it out.  [[ proto token value {*}; ...; token value:oct { '-'? 0 <[0..7]>* }; ...; token value:sym<true> { <sym> }; ... ]

[05:51] *** JimmyZ joined
[05:51] *** Chillance left
[05:57] <ssutch> playing with this

[05:58] <ssutch> this is what i have now: https://gist.github.com/samuraisam/5790917

[05:59] *** bluescreen10 joined
[05:59] *** bluescreen10 left
[05:59] *** bluescreen10 joined
[06:00] <sorear> why are nuls special-cased in the grammar?

[06:00] *** bluescreen10 left
[06:01] *** bluescreen10 joined
[06:02] *** bluescreen100 left
[06:02] <ssutch> in the strings?

[06:04] <sorear> yes

[06:04] <ssutch> it was in the ebnf for this language

[06:05] <sorear> I see you've hit on a very important and non-obvious grammar optimization (using a repeated negated character class to quickly slurp up runs of ordinary characters in a string)

[06:07] <ssutch> that's good

[06:08] *** zby_home_ joined
[06:08] <ssutch> ok so this is what i have now: https://gist.github.com/samuraisam/5790917 it didn't fix the issue with matching a part of a float as an int

[06:10] <ssutch> however, if i change token int-lit:sym<dec> to { '-'? <[1..9]>\d* <!before '.'> } it works just fine

[06:10] <sorear> strange.  it most definitely SHOULD work

[06:10] * ssutch shrugs

[06:11] <sorear> r: grammar G { token TOP {^ <num> .* }; proto token num {*}; token num:int { \d+ }; token num:flt { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:11] <camelia> rakudo b2072f: OUTPUT¬´#<failed match>‚ê§¬ª

[06:12] <sorear> wat

[06:12] <sorear> r: grammar G { token TOP {^ {say 1} <num> .* }; proto token num {*}; token num:int { \d+ {say 2} }; token num:flt { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:12] <camelia> rakudo b2072f: OUTPUT¬´1‚ê§#<failed match>‚ê§¬ª

[06:13] <ssutch> le bug?

[06:14] <sorear> r: grammar G { token TOP {^ <num> {say 2} .* {say 3} }; proto token num {*}; token num:int { \d+ }; token num:flt { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:14] <camelia> rakudo b2072f: OUTPUT¬´#<failed match>‚ê§¬ª

[06:15] <sorear> r: grammar G { token TOP {^ <nuxm> .* }; proto token nuxm {*}; token nuxm:sym<int> { \d+ }; token nuxm:sym<flt> { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:15] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢12.34abcÔΩ£‚ê§ nuxm => ÔΩ¢12.34ÔΩ£‚ê§‚ê§¬ª

[06:15] <sorear> r: grammar G { token TOP {^ <nuxm> .* }; proto token nuxm {*}; token nuxm:int { \d+ }; token nuxm:flt { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:15] <camelia> rakudo b2072f: OUTPUT¬´#<failed match>‚ê§¬ª

[06:15] <sorear> n: grammar G { token TOP {^ <nuxm> .* }; proto token nuxm {*}; token nuxm:int { \d+ }; token nuxm:flt { \d+ '.' \d+ } }; say G.parse('12.34abc')

[06:15] <camelia> niecza v24-76-g3e65d84: OUTPUT¬´ÔΩ¢12.34abcÔΩ£‚ê§ nuxm => ÔΩ¢12.34ÔΩ£‚ê§‚ê§¬ª

[06:15] *** xinming left
[06:15] <sorear> apparently rakudo doesn't like the :foo short form very much

[06:16] <sorear> so much for my style advice - sorry

[06:16] <ssutch> yeah, i had to change it back

[06:16] <ssutch> (no problem, i appreciate all the help)

[06:16] <sorear> anyway my example demonstrates rakudo preferring :sym<flt> when appropriate because it's longer

[06:17] <sorear> 23:15 <+camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢12.34abcÔΩ£‚ê§ nuxm => ÔΩ¢12.34ÔΩ£‚ê§‚ê§¬ª

[06:17] <sorear> so.. the FUNCTIONALITY works

[06:18] <sorear> [\d+]? is kind of silly, btw

[06:18] <ssutch> don't need the brackets

[06:18] <sorear> I mean you can just write \d*

[06:19] <sorear> \d+? is something very different, don't write that

[06:19] <sorear> (I beleive it's a non-greedy quantifier)

[06:19] <ssutch> hah, okay, thanks

[06:19] <sorear> + (1 or more) * (0 or more) ? (0 or 1)

[06:19] <sorear> (0 or 1) times (1 or more) = (0 or more) :)

[06:23] *** twigel left
[06:24] *** cognominal joined
[06:27] <eternaleye> ssutch: sorear: The short :foo form interacts poorly with Actions in my testing, and I've also found that declaration order changes the behavior of proto/multi tokens in a grammar (!!!)

[06:28] <eternaleye> In ways that look like they aren't consistently LTM, no less.

[06:28] <cognominal> Backto Paris. Nancy french workshop was nice. lizmat and wendy were great as usual. Too bad jnthn and masak could not make it.    We did the Chartreuse Party place Stanislas after an impressive son et lum√®re.

[06:28] <cognominal> http://www.lorraineaucoeur.com/evt-10359/son-et-lumiere-rendez-vous-place-stanislas/meurthe-et-moselle-nancy/concerts-spectacles-gratuits-ete

[06:28] <ssutch> r: '23.23' ~~ /'-'? <[1..9]>\d* <!before '.'>/

[06:28] <camelia> rakudo b2072f:  ( no output )

[06:28] <sorear> eternaleye: per spec, declaration order is used as a tiebreaker.  I think rakudo is being a bit eager to call ties.

[06:29] <eternaleye> Mm

[06:29] <ssutch> r: say '23.23' ~~ /'-'? <[1..9]>\d* <!before '.'>/

[06:29] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢2ÔΩ£‚ê§‚ê§¬ª

[06:29] <sorear> ssutch: 3 isn't a period, so 2 is not-before-period

[06:29] <eternaleye> ssutch: Because of ^^^, try putting the 'float' rule/token above the 'int' one and see if that lets you leave off the <!before>

[06:29] <sorear> cognominal: have you seen jnthn anywhere recently?

[06:29] <sorear> oh

[06:30] <sorear> I should read more before commenting

[06:30] <cognominal> sorear, I was not in YAPC::NA

[06:31] <sorear> cognominal: jnthn has been irritatingly quiet on #perl6 today, I briefly wondered (because I didn't read your comment well) if that was because he was busy at FPW

[06:32] <ssutch> how can i get that pattern to continue matching

[06:33] <eternaleye> r: say '23.23' ~~ m:ratchet/'-'? <[1..9]>\d* <!before '.'>/

[06:33] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢23ÔΩ£‚ê§‚ê§¬ª

[06:33] <eternaleye> Hmm

[06:33] <ssutch> well, i want it to fail because that's a float

[06:33] <eternaleye> Yeah

[06:33] <sorear> eternaleye: suggest not making the before and after the same

[06:34] <eternaleye> sorear: Ah

[06:34] <sorear> ssutch: you're building increasingly ugly workarounds for LTM problems

[06:34] <eternaleye> r: say '23.25' ~~ m:ratchet/'-'? <[1..9]>\d* <!before '.'>/

[06:34] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢25ÔΩ£‚ê§‚ê§¬ª

[06:34] <ssutch> sorry, LTM?

[06:34] <sorear> ssutch: longest token matching

[06:35] <sorear> ssutch: the rule that says if you can match 2 with one rule or 2.5 with another, take the longer match

[06:36] * sorear needs to do dynamic-wind-y stuff for tc.handlers

[06:36] <ssutch> ah ok, well, i guess i need a workaround for now

[06:36] <eternaleye> r: grammar Foo { proto token num { * }; multi token num:sym<float> { '-'? \d* [ '.' \d+ ]? }; multi token num:sym<int> { '-'? \d+ } }; say Foo.parse( '23.25', :rule<num> )

[06:36] <camelia> rakudo b2072f: OUTPUT¬´ÔΩ¢23.25ÔΩ£‚ê§‚ê§¬ª

[06:38] <sorear> ssutch: try flattening it (instead of having value go to int, and int go to {oct,dec,hex}, do it all at the value level)

[06:38] <sorear> and I second eternaleye's suggestion to play with the order

[06:38] <eternaleye> r: grammar Foo { proto token num { * }; multi token num:sym<float> { '-'? \d* [ '.' \d+ ]? }; multi token num:sym<int> { '-'? \d+ } }; class FooActions { proto method num { * }; multi method num:sym<float> { make 'Float: ' ~ $/.Str }; multi method num:sym<int> { make 'Int: ' ~ $/.Str } }; say Foo.parse( '23.25', :rule<num>, :actions( FooActions.new ) ).ast

[06:38] <camelia> rakudo b2072f: OUTPUT¬´Cannot call 'num:sym<float>'; none of these signatures match:‚ê§:(FooActions : Mu *%_)‚ê§  in method num:sym<float> at src/gen/CORE.setting:440‚ê§  in any !reduce at src/stage2/QRegex.nqp:667‚ê§  in any !cursor_pass at src/stage2/QRegex.nqp:631‚ê§  in regex num:sym<float> at‚Ä¶

[06:39] <eternaleye> r: grammar Foo { proto token num { * }; multi token num:sym<float> { '-'? \d* [ '.' \d+ ]? }; multi token num:sym<int> { '-'? \d+ } }; class FooActions { proto method num { * }; multi method num:sym<float>( $/ ) { make 'Float: ' ~ $/.Str }; multi method num:sym<int>( $/ ) { make 'Int: ' ~ $/.Str } }; say Foo.parse( '23.25', :rule<num>, :actions( FooActions.new ) ).ast

[06:39] <camelia> rakudo b2072f: OUTPUT¬´Float: 23.25‚ê§¬ª

[06:39] <eternaleye> I always forget the signatures on Actions.

[06:40] <ssutch> moving the order around made it work

[06:40] <eternaleye> ssutch: FYI, note the :rule I passed to .parse. This will make testing your grammar VASTLY easier.

[06:40] <ssutch> (with <!before '.'>)

[06:40] <ssutch> eternaleye: thanks for the tip

[06:41] <eternaleye> You can use that to test individual rules, while still doing actions as normal, rather than trying to test everything via either TOP or smartmatching.

[06:42] <sorear> ssutch: does it also make it work without the <!before> ?

[06:42] *** benabik joined
[06:43] <ssutch> sorear: yes, it works fine without the <!before>

[06:45] <ssutch> well, for this section, running a larger test now (it goes really slowly with Grammar::Tracer on)

[06:53] *** nitestryker_ joined
[06:53] <ssutch> well, shoot, now it doesn't work with hex eg 0xFFF

[06:55] <ssutch> an issue with LTM? putting <!before <[xX]>> at the end of the float rule makes it work

[06:56] <eternaleye> ssutch: Well, my float rule also matches int.

[06:56] <eternaleye> Remove the [ ]? from around the second part.

[06:56] <eternaleye> ssutch: The issue is likely that float (which is first) matches the leading 0.

[06:56] <ssutch> yes

[06:56] <eternaleye> ssutch: As a rule of thumb, put the *most restrictive* rule first.

[06:57] <eternaleye> Since 0xFFF won't match things int or float match, but int or float will eat it up, put hex before them.

[06:58] <eternaleye> My mnemonic is 'Picky eaters get first pick'

[06:58] <ssutch> ok, 

[06:59] <eternaleye> Once LTM is fully working, it'll be unneccessary, but for now ordering things like I describe mostly does the job.

[06:59] <ssutch> ok, that can work if i flatten it, is it possible to use proto token implementations as a part of other rules eg proto token x { * }; token x:y { ‚Ä¶ }; token t <x:y>

[07:00] <ssutch> because i need to use int-lit elsewhere besides just in constant

[07:01] *** cognominal left
[07:02] *** cognominal__ joined
[07:03] <eternaleye> r: ( grammar { token x { * }; multi token x:sym<y> { <z> }; proto token z { * }; multi token z:sym<foo> { 'blah' }; } ).parse( 'blah', :rule<x>, :actions( (class { proto method x( $/ ) { * }; multi method x:sym<y>( $/ ) { make $<z>.ast }; proto method z( $/ ) { * }; multi method z:sym<foo>( $/ ) { make "Success, bwahaha!" }; } ).new ) ).ast

[07:03] <camelia> rakudo b2072f: OUTPUT¬´===SORRY!===‚ê§Method 'rxtype' not found for invocant of class 'Integer'‚ê§¬ª

[07:04] *** cognominal__ left
[07:05] *** cognominal joined
[07:06] <dalek> nqp: 8db2525 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/ (2 files):

[07:06] <dalek> nqp: Add a simple way to set exception verbiage at runtime

[07:06] <dalek> nqp: 

[07:06] <dalek> nqp: Set NQP_VERBOSE_EXCEPTIONS in your environment.  This is not the ideal

[07:06] <dalek> nqp: interface, but it will do for now.

[07:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8db25257ce

[07:06] <dalek> nqp: 4deb1c7 | sorear++ | src/vm/jvm/ (2 files):

[07:06] <dalek> nqp: Refactor compilation of continuation-aware ops, allow any op to be easily designated so

[07:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4deb1c730e

[07:06] <eternaleye> r: grammar A { token x { * }; multi token x:sym<y> { <z> }; proto token z { * }; multi token z:sym<foo> { 'blah' }; }; class AActions { proto method x( $/ ) { * }; multi method x:sym<y>( $/ ) { make $<z>.ast }; proto method z( $/ ) { * }; multi method z:sym<foo>( $/ ) { make "Success, bwahaha!" }; }; A.parse( 'blah', :rule<x>, :actions( AActions.new ) ).ast

[07:06] <camelia> rakudo b2072f: OUTPUT¬´===SORRY!===‚ê§Method 'rxtype' not found for invocant of class 'Integer'‚ê§¬ª

[07:08] <eternaleye> r: grammar A { proto token x { * }; multi token x:sym<y> { <z> }; proto token z { * }; multi token z:sym<foo> { 'blah' }; }; class AActions { proto method x( $/ ) { * }; multi method x:sym<y>( $/ ) { make $<z>.ast }; proto method z( $/ ) { * }; multi method z:sym<foo>( $/ ) { make "Success, bwahaha!" }; }; A.parse( 'blah', :rule<x>, :actions( AActions.new ) ).ast

[07:08] <camelia> rakudo b2072f:  ( no output )

[07:08] <eternaleye> r: grammar A { proto token x { * }; multi token x:sym<y> { <z> }; proto token z { * }; multi token z:sym<foo> { 'blah' }; }; class AActions { proto method x( $/ ) { * }; multi method x:sym<y>( $/ ) { make $<z>.ast }; proto method z( $/ ) { * }; multi method z:sym<foo>( $/ ) { make "Success, bwahaha!" }; }; say A.parse( 'blah', :rule<x>, :actions( AActions.new ) ).ast

[07:08] <camelia> rakudo b2072f: OUTPUT¬´Success, bwahaha!‚ê§¬ª

[07:08] <eternaleye> ssutch: ^^^ calling a proto from one branch of a proto

[07:08] <eternaleye> *another

[07:09] <ssutch> cool

[07:10] *** cognominal left
[07:12] *** bbkr_ joined
[07:15] *** ivan``_ joined
[07:16] *** ivan`` left
[07:16] *** bbkr left
[07:16] *** diederich left
[07:16] *** cosimo left
[07:16] *** huf left
[07:16] *** p5eval left
[07:16] *** Hor|zon left
[07:16] *** silug left
[07:16] *** silug_ joined
[07:16] *** huf joined
[07:16] *** Hor|zon joined
[07:16] *** cosimo joined
[07:16] *** p5eval joined
[07:16] *** skids left
[07:17] *** skids joined
[07:17] <ssutch> hot damn, it parses the spec file

[07:19] <labster> \o/

[07:19] <sorear> "the" spec file?

[07:19] <sorear> \o/

[07:20] *** cognominal joined
[07:20] <diakopter> sorear: lololol

[07:22] <labster> We need a grammar to parse the synopses and automatically generate a P6 implementation.

[07:23] <eternaleye> labster: Well, I think that's called 'irc://freenode/net/#perl6'

[07:23] <eternaleye> :P

[07:23] <eternaleye> *freenode.net

[07:23] * FROGGS_ .oO( use English? this could generate grammars for all programmings languages )

[07:23] <sorear> o/ FROGGS_

[07:23] <FROGGS_> hi sorear 

[07:23] <labster> morning FROGGS_ 

[07:23] <FROGGS_> hi labster :o)

[07:23] <FROGGS_> hi all

[07:24] <sorear> FROGGS_: p5 already has an English.pm module! we could import that with v5.pm!

[07:24] <FROGGS_> sorear: but it totally does something else

[07:24] <FROGGS_> I already have a tiny bit of that

[07:25] <sorear> FROGGS_: I found myself wondering earlier today if v5.pm would allow you to use p5 code together with my delimited continuations stuff :)

[07:26] <FROGGS_> well, what exactly is your "delimited continuations stuff" ?

[07:26] <FROGGS_> but basically everything that nqp offers is somehow available in v5

[07:27] <FROGGS_> (in case the Perl 5 syntax isnt to restrictive)

[07:27] <FROGGS_> too*

[07:28] <sorear> nqp-jvm: my $cont := nqp::continuationreset(0, {3 * nqp::continuationcontrol(0, -> $c { $c })});  say(nqp::continuationinvoke($cont, {25}));

[07:28] <camelia> nqp-jvm: OUTPUT¬´No registered operation handler for 'continuationreset'‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in as_jast_clear_bindval‚ê§  in <anon>‚ê§  in <anon>‚ê§  in compile_var‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in <anon>‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§ ‚Ä¶

[07:28] <sorear> pff, does ot seem to have rebuilt

[07:29] <FROGGS_> would it say 75?

[07:29] <FROGGS_> I'm not sure that I understand what it does

[07:29] <sorear>  sorear$ ./nqp -e 'my $cont := nqp::continuationreset(0, {3 * nqp::continuationcontrol(0, nqp::null(), -> $c { $c })}); say(nqp::continuationinvoke($cont, {25}));'

[07:29] <sorear> 75

[07:29] *** cognominal left
[07:30] <sorear> https://github.com/perl6/nqp/blob/master/docs/continuations.pod

[07:30] <JimmyZ> yeah!

[07:30] <sorear> o/ JimmyZ

[07:30] * FROGGS_ reads

[07:31] <JimmyZ> sorear: aloha

[07:31] * sorear wonders if yeah! was meant for sorear

[07:32] <JimmyZ> yes

[07:33] <JimmyZ> congratulations on your continuation work :P

[07:34] <FROGGS_> hmmm, I dont understand it √≥.√≤

[07:34] <FROGGS_> it feels a bit macroish

[07:35] *** woosley1 left
[07:37] *** cognominal joined
[07:39] <dalek> nqp: 986b39d | sorear++ | docs/continuations.pod:

[07:39] <dalek> nqp: Add a conjecture for improving the nqp::continuationclone API

[07:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/986b39d8dc

[07:40] *** snearch joined
[07:48] *** cognominal left
[07:54] <sorear> nqp-jvm: my int $i; try { ""~[]; CATCH { nqp::resume($!) unless $i++ } }

[07:54] <camelia> nqp-jvm: OUTPUT¬´No registered operation handler for 'resume'‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in <anon>‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in compile_all_the_stmts‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in compile_all_the_stmts‚ê§  in as_jast‚ê§ ‚Ä¶

[07:58] <sorear> This is nqp version 2013.02.1-50-g0968572 built on JVM

[07:58] <sorear> that's what I get from the evalbot :/

[07:58] *** aghbas_ left
[07:59] * sorear ponders fixability

[08:01] *** tomyan joined
[08:07] *** ecocode joined
[08:12] *** JimmyZ left
[08:13] *** tomyan left
[08:17] *** JimmyZ joined
[08:25] *** tomyan joined
[08:36] *** FreedomKnight joined
[08:39] *** woolfy joined
[08:42] *** ssutch left
[08:50] <woolfy> At the French Perl Workshop, somebody told me he likes Parrot.  Mostly the champagne-like wine that is made in the Jura.  http://www.jura-vins.com/details-domaine-parrot-et-fils-gaec-VOITEUR,189.htm

[08:51] <woolfy> OK, I am bringing Perl-wine to Perl-meetings.  Now I have to drag around champagne-like bottles with Parrot as well?

[08:51] <woolfy> Liz just tells me no.  The wine-domain is 300km south of here, just a bit too much of a detour on our way home tomorrow.

[08:53] <sorear> just a bit :)

[09:00] <TimToady> at the moment we're a couple hours north of Toulouse, and I finally have ssh access again...

[09:03] <nwc10> on a train?

[09:08] <TimToady> in a timeshare

[09:08] <woolfy> TimToady in Toulouse?  So you could maybe have visited the French Perl Workshop...  boohooo....  (or is it Toulouse, North Carolina or something like that).

[09:08] <TimToady> the schedule wouldn't have worked, since Aron had to be Nice yesterday

[09:08] <TimToady> after coming from Cambridge

[09:09] <woolfy> It was only 936 km, just a 10 hour drive.  :-)

[09:10] <nwc10> that sounds far more relaxing

[09:10] <woolfy> I know, Toulouse is farther from Nancy than from Nancy to Berlin.

[09:10] <TimToady> well, we drove yesterday for about 10 hours already...

[09:10] <woolfy> Ow wow, you must be completely sore...

[09:11] <TimToady> well, my clutch leg ought to be sore from an hour in a traffic jam, but it doesn't seem to be

[09:11] <woolfy> But you know, to know that you are in the same country that I am in and it would just to be too much of a hassle to come over and give you a hug...  Raaahh!

[09:11] <TimToady> c'est la vie

[09:11] <woolfy> Biensur!

[09:12] <nwc10> TimToady: do you dive a manual at home, or is it just a holiday treat?

[09:12] <sorear> .oO( TimToady rites manuals, he doesn't ride them... )

[09:14] <TimToady> I haven't had a manual for several years now, but drove one for most of my life

[09:15] * TimToady learned to drive in a manual, even

[09:15] <nwc10> which, I assume, is as unusual in the US as it is common in Europe

[09:16] <TimToady> I'm sure if I hadn't been walking all over Texas and England the last two weeks, my clutch leg would have been much sorer

[09:17] <woolfy> You did walk quite a bit in Austin.  Just the walks between the two buildings of the YAPC were a nice exercise.

[09:19] *** bbkr joined
[09:19] *** tomyan left
[09:20] *** dmol joined
[09:20] <bbkr> hi. is there a way to access raw bytes in IEEE754 format from Num type? maybe through some NQP tricks?

[09:28] *** JimmyZ left
[09:29] *** lizmat_ joined
[09:29] *** lizmat left
[09:30] *** tomyan joined
[09:31] <lizmat_> good morning #perl6!

[09:31] <lizmat_> https://github.com/perl6/specs/issues/54  Auth/Ver information is UNIT based, but specced as class etc. Propose -unit-

[09:32] * lizmat_ hopes TimToady will have some time to look at issues

[09:32] <sergot> hi ! o/

[09:33] *** atroxaper joined
[09:39] *** tomyan left
[09:39] *** Timbus left
[09:40] *** Timbus joined
[09:41] *** tomyan joined
[09:43] <sorear> hi lizmat_! hi sergot!

[09:45] <FROGGS_> lizmat_: I commented

[09:45] <lizmat_> FROGGS++

[09:45] *** lizmat_ is now known as lizmat

[09:45] <sorear> .tell jnthn observation: Perl6/Grammar.class has nearly 100x as many bytes of serialized objects as Perl6/Actions.class.  Possibly worth looking into?

[09:45] <yoleaux> sorear: I'll pass your message to jnthn.

[09:50] *** spider-mario joined
[09:53] *** JimmyZ joined
[09:59] *** kaare_ left
[09:59] *** dmol left
[10:07] *** raiph left
[10:09] *** tomyan left
[10:10] *** PacoAir joined
[10:20] *** ecocode` joined
[10:22] <masak> lizmat: also worth thinking about in the memespace around https://github.com/perl6/specs/issues/54 is how Perl 6 sees the distinction between "modules" (essentially the 'unit' keyword you're proposing) and "distributions" (a CPAN concept which can contain zero or more modules).

[10:24] *** ecocode left
[10:26] *** sivoais left
[10:27] *** sivoais joined
[10:29] *** SamuraiJack left
[10:34] <sorear> masak! o/

[10:34] * sorear has made changes in the exception system and is getting failures that seem almost unrelated

[10:36] *** JimmyZ left
[10:42] *** tomyan joined
[10:42] *** JimmyZ joined
[10:43] *** pmurias joined
[10:48] *** tomyan left
[10:55] *** imarcusthis- joined
[11:02] * moritz back

[11:05] *** dmol joined
[11:19] <sorear> Oops :D

[11:19] *** rindolf joined
[11:20] <sorear> QAST::VarWithFallback was... not *quite* following the stack rules

[11:20] <sorear> didn't notice until I made die continuation-transparent

[11:24] *** FreedomKnight left
[11:31] <lizmat> masak: a unit may contain multiple modules.  A distribution may contain multiple units.  It's up to the author whether to separate modules over multiple units (allowing them different auth/ver information), or keep them in one unit (forcing the modules to share auth/ver infomation).

[11:31] <JimmyZ> sorear: I had a question ...

[11:32] <JimmyZ> https://github.com/perl6/nqp/blob/9514dbe84f7910cbd2126e5c1351cfe923241341/src/vm/jvm/runtime/org/perl6/nqp/jast2bc/JASTToJVMBytecode.java#L307 Is it still used?

[11:33] <lizmat> the advantage of keeping them in one unit, is that these modules can easily share variables and internal subroutines

[11:33] <sorear> JimmyZ: yes

[11:33] <sorear> JimmyZ: the stage0 compiler generates that

[11:33] <sorear> it won't be used after the next bootstrap update

[11:33] <JimmyZ> sorear: thanks, I'm just curious 

[11:34] <sorear> good :)

[11:34] <JimmyZ> :P

[11:34] <lizmat> sightseeing&

[11:36] *** woolfy left
[11:36] <sorear> ah-double-ha.  there's an overeager optimization here

[11:36] * sorear fixes

[11:38] <timotimo_> optimizers are hard

[11:45] <dalek> nqp: 3b780bd | sorear++ | src/vm/jvm/ (3 files):

[11:45] <dalek> nqp: Change interface of exception system to support eventual continuation transparency

[11:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3b780bdcff

[11:47] <timotimo_> so, nqp-jvm has a MapIter and a GatherIter now, so for loops and gather for loops should work now. what else can i do so far? last time i tried i could say "hello world", but say 1 would cause a huge exception

[11:47] <timotimo_> and instantiating classes with the default constructor wouldn't work either, because of nqp::getoutercapture or something similar

[11:49] <sorear> nqp has neither of those

[11:49] <sorear> those are rakudo things

[11:49] *** kaare_ joined
[11:49] <sorear> and GatherIter is still not quite there

[11:49] <timotimo_> er, right. why do i get those two confused? i should know better

[12:01] *** JimmyZ left
[12:02] *** fgomez left
[12:16] <dalek> nqp: 8975957 | sorear++ | / (2 files):

[12:16] <dalek> nqp: Make exception handlers continuation-transparent

[12:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/89759573a2

[12:35] *** JimmyZ joined
[12:48] *** bruges_ left
[12:48] *** bruges joined
[12:49] *** benabik left
[12:56] *** ecocode` left
[12:59] *** ggoebel_ joined
[13:01] *** ggoebel left
[13:01] *** ggoebel_ is now known as ggoebel

[13:08] <sorear> \o/ just ran a gather block successfully

[13:08] <TimToady> \o/

[13:09] <FROGGS_> sorear++ # \o/

[13:11] *** rindolf left
[13:11] <colomon> \o/

[13:12] *** SamuraiJack joined
[13:13] <timotimo_> oh, look at that, this folder has a file called "gpn13-perl6.mp4" in it. i wonder what it is ... :P    ftp://media.ccc.de/events/gpn/gpn13/

[13:13] <timotimo_> (unfortunately in german and with pretty hard to read text)

[13:14] <timotimo_> bike_tour&

[13:15] <sorear> sorear$ ./perl6 --ll-exception -e 'my @l := gather { take 1; say "hi"; take 2 }; say @l.shift while @l'

[13:15] <sorear> 1

[13:15] <sorear> hi

[13:15] <sorear> 2

[13:15] <JimmyZ> push push :P

[13:18] <sorear> .tell jnthn Mission accomplished! https://github.com/sorear/rakudo/commit/ec48e7  # I'd like to know if I can do without p6handletake

[13:18] <yoleaux> sorear: I'll pass your message to jnthn.

[13:19] <sorear> JimmyZ: there's my commit

[13:20] <JimmyZ> wheee!!

[13:21] <sorear> now um

[13:21] <sorear> there are a few other things wrong with rakudo-jvm

[13:21] * sorear digs in

[13:28] * sorear would like a jnthn or a pmichaud to discuss exception handling factoring with D:

[13:32] *** daniel-s__ is now known as daniel-s

[13:34] <pmurias> sorear: what is continuationclone needed for?

[13:35] <sorear> pmurias: there's a test in t/jvm/01-continuations.t that fails without it

[13:36] <sorear> a callframe is not a completely immutable object, and it needs to be duplicated if you want to invoke the same continuation twice at the same time

[13:37] <sorear> otherwise the callstack gets screwed up because the caller pointers form a loop

[13:37] <pmurias> what I'm asking for is what Perl 6 feature requires invoking the same contiunation twice

[13:39] <pmurias> * continuation

[13:39] <sorear> none

[13:40] <sorear> but NQP is not just for Perl 6

[13:40] <pmurias> it could be usefull for Ruby etc.

[13:40] <sorear> ...I shouldn't be so defensive.

[13:41] * pmurias is thinking how to implement the opcodes on node.js

[13:42] <sorear> don't worry if you can't; I don't expect all VMs to provide precisely the same set of fancy control ops

[13:43] <sorear> everybody that supports p6 needs to provide at least coroutines

[13:43] <sorear> it just happens that the JVM implementation could be extended to unrestricted multiprompt delimited continuations at little marginal cost, so I did so

[13:44] <sorear> we might have nqp::coroutine ops at some point.  for now, the expectation is #?if jvm

[13:47] <sorear> anyone know offhand which CLA I need for Rakudo?

[13:47] <pmurias> one shot contiunations (one without clone) are basically coroutines, I just have to figure out what delimited coroutines amount to ;)

[13:48] <sorear> pmurias: Lexotic gather/take

[13:50] *** birdwindupbird joined
[13:51] *** tgt joined
[13:52] <sorear> labster++ # found the link in your blog

[13:54] <sorear> [ http://www.perlfoundation.org/attachment/legal/cla3.pdf ]

[13:54] *** woosley1 joined
[13:57] *** woosley1 left
[14:13] <pmurias> sorear: re docs/continuations.pod in line 39 "manually add the prompt" it's unclear what prompt refers too

[14:17] *** tomyan joined
[14:20] <sorear> pmurias: s/prompt/reset/

[14:20] <sorear> they're synonyms in the literature.

[14:21] <dalek> nqp: ffee47a | sorear++ | docs/continuations.pod:

[14:21] <dalek> nqp: Fix inconsistent terminology.  pmurias++

[14:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ffee47a8ae

[14:23] *** snearch left
[14:30] <pmurias> sorear: could you supply an example how to simulate shift using control/reset?

[14:34] <sorear> pmurias: when you want to use the continuation, instead of doing continvoke(cont, arg), do reset({ continvoke(cont, arg) }) instead

[14:35] *** cognominal joined
[14:37] *** spider-mario left
[14:38] <sorear> if we were representing continuations as functions, you could do sub shift(&f) { control(sub (&rawc) { f(sub ($a) { reset({ rawc(a) }) }) }) }

[14:43] *** guru joined
[14:44] *** guru is now known as Guest36735

[14:44] *** Guest36735 is now known as ajr_

[14:45] *** amoe_ joined
[14:47] *** amoe left
[14:50] <pmurias> sorear: nqp-on-jvm keeps it's own frames rather than using java ones?

[14:51] <sorear> pmurias: we use both java frames and CallFrame objects

[14:51] <sorear> there's no cps conversion here, calls and returns are native java calls and returns

[14:53] *** ggoebel left
[14:53] <pmurias> jvm allows you to manipulate the stack?

[14:54] <sorear> only by serious abuse of exceptions

[14:54] *** ggoebel joined
[14:55] <pmurias> and how do you recreate the stack, fake things with CallsFrame's?

[14:55] <diakopter> re-entry points to routines, aiui

[14:56] <sorear> control throws a StackSaveException

[14:56] <sorear> all generated routines have StackSaveException handlers that reify the Java frame as an object (which is not the same as the CallFrame)

[14:56] <sorear> reset catches the exception, and bundles the reified frames into a continuation object

[14:56] <diakopter> wait, sorear's not usually up this... early.... I mean late. :)

[14:57] <sorear> invoke calls the first method in the reified chain frame, passing it the reified frame chain

[14:57] <JimmyZ> \o diakopter 

[14:57] <sorear> the generated code then recreates the current frame, and recursively reestablishes the stack

[14:59] <pmurias> what's the overhead of this on normal code?

[15:00] <sorear> one ifnonnull opcode in the function prologue

[15:00] <sorear> (well, and an aload for the argument)

[15:09] *** domidumont joined
[15:10] *** ggoebel left
[15:17] *** pmurias left
[15:17] *** zby_home_ left
[15:18] <[Coke]> Happy father's day to moritz, TimToady, pmichaud, colomon and everyone else.

[15:19] *** zby_home joined
[15:22] *** zby_home left
[15:30] <colomon> [Coke]: thanks!

[15:31] * colomon got a father-and-son set of melodicas for Father's Day.  http://en.wikipedia.org/wiki/Melodica

[15:31] *** rindolf joined
[15:36] * TimToady got to take a long nap, which is about the height of my ambitions today :)

[15:40] *** domidumont left
[15:40] *** rindolf left
[15:40] *** domidumont joined
[15:46] *** risou is now known as risou_awy

[15:48] *** risou_awy is now known as risou

[15:48] *** fhelmberger joined
[15:50] *** risou is now known as risou_awy

[15:51] *** risou_awy is now known as risou

[15:57] *** JimmyZ left
[16:00] *** fhelmberger left
[16:00] *** census joined
[16:00] *** fhelmberger joined
[16:01] *** zby_home_ joined
[16:07] *** fhelmberger left
[16:14] *** raiph joined
[16:23] *** atroxaper left
[16:24] *** Gothmog_ left
[16:24] *** pmurias joined
[16:25] *** risou is now known as risou_awy

[16:41] * [Coke] again bemoans debugging utilities for nqp.

[16:43] *** guru joined
[16:43] *** ajr_ left
[16:43] *** guru is now known as Guest59128

[16:47] *** cognominal left
[16:47] <[Coke]> I have 2 tcl programs that differ only by whitespace, and am trying to figure out why one explodes about "Can only use get_how on a SixModelObject".

[16:47] <[Coke]> (without recompiling nqp to insert debugging output)

[16:52] *** raiph left
[16:52] *** Guest59128 is now known as ajr_

[16:55] *** scottp left
[16:56] *** SamuraiJack left
[16:56] *** scottp joined
[16:59] *** raiph joined
[17:05] <[Coke]> is there a way in NQP to get the name of the sub you're executing?

[17:06] <[Coke]> nqp: say('word:sym<{*}>');

[17:06] <camelia> nqp: OUTPUT¬´word:sym<{*}>‚ê§¬ª

[17:07] <[Coke]> nqp: say('word:sym<" ">:')

[17:07] <camelia> nqp: OUTPUT¬´word:sym<" ">:‚ê§¬ª

[17:11] <sorear> nqp: sub bob() { say(nqp::getcodename(nqp::curcode())) }; bob()

[17:11] <camelia> nqp: OUTPUT¬´bob‚ê§¬ª

[17:15] *** birdwindupbird left
[17:22] <dalek> nqp: 05231f5 | sorear++ | src/vm/ (7 files):

[17:22] <dalek> nqp: Add file names and line numbers to NQP-jvm backtraces when possible

[17:22] <dalek> nqp: review: https://github.com/perl6/nqp/commit/05231f5465

[17:22] <[Coke]> trying to add a debug attribute to my actions class so I can conditionally say "you're in this action method and were passed this value" - just adding the debug attribute is causing a compilation error. wtf.

[17:23] <[Coke]> nqp: class barf {‚ê§  has $.debug := False; ‚ê§ method eek() {say(3)} }

[17:23] <camelia> nqp: OUTPUT¬´Unable to parse expression in blockoid; couldn't find final '}' at line 3, near "has $.debu"‚ê§current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)‚ê§¬ª

[17:25] <[Coke]> r: class barf {‚ê§  has $.debug := False; ‚ê§ method eek() {say(3)} }

[17:25] <camelia> rakudo b2072f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Cannot use := to initialize an attribute‚ê§at /tmp/snuKMfRC6C:2‚ê§------> [32m  has $.debug := False[33m‚èè[31m; [0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[17:25] <[Coke]> r: class barf {‚ê§  has $.debug = False; ‚ê§ method eek() {say(3)} }

[17:25] <camelia> rakudo b2072f:  ( no output )

[17:34] *** ssutch joined
[17:34] <timotimo_> nqp: class barf { has $.debug; method eek() { say(3) } }

[17:34] <camelia> nqp: OUTPUT¬´Unable to parse expression in blockoid; couldn't find final '}' at line 2, near "has $.debu"‚ê§current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)‚ê§¬ª

[17:34] <timotimo_> strange

[17:38] * [Coke] wanders off to do something fun instead of fight with nqp.

[17:42] <sorear> that's because nqp only supports $!.

[17:47] <[Coke]> nqp: class barf {‚ê§  has $!debug := False; ‚ê§ method eek() {say(3)} }

[17:47] <camelia> nqp: OUTPUT¬´Error while compiling block : Error while compiling block  (source text: "{\n  has $!debug := False; \n method eek() {say(3)} }"): Error while compiling op bind (source text: ":="): First child of a 'bind' op must be a QAST::Var‚ê§current instr.: '' pc 48612 (src/stage2/QAST.p‚Ä¶

[17:50] <sorear> and you can't bind in a class body.

[17:50] <sorear> have to do the binding in method new

[17:51] <[Coke]> nqp: class barf {‚ê§  has $!debug;  ‚ê§ method eek() {say(3)} }

[17:51] <camelia> nqp:  ( no output )

[18:06] <[Coke]> nqp: class barf {‚ê§  has $!debug;  ‚ê§ method new() {$!debug := True} method eek() { $!debug && say(3)} }; barf.new().eek()

[18:06] <camelia> nqp: OUTPUT¬´Unable to parse expression in blockoid; couldn't find final '}' at line 4, near "method new"‚ê§current instr.: 'panic' pc 14721 (src/stage2/gen/NQPHLL.pir:5232) (src/stage2/gen/NQPHLL.nqp:279)‚ê§¬ª

[18:09] *** sftp left
[18:09] <sorear> missing newline between new and eek

[18:09] *** sftp joined
[18:10] <sorear> also, nqp news look like this:

[18:12] <sorear> ok, I don't know as well as I thought

[18:12] *** rindolf joined
[18:14] <[Coke]> https://gist.github.com/coke/cdc0d82fd63e0282038c - there's no concat that isn't commented out in that file. weird.

[18:15] <[Coke]> ah. might be an old action. now to figure out how QAST::Op works. :|

[18:16] <[Coke]> sorear++ for help so far.

[18:23] <lee_> i did some comparisons with scala, and summing 1..1000000 takes about 5s vs 10s in rakudo-jvm

[18:23] <lee_> not bad!

[18:24] <lee_> after the first run scala keeps a "CompilerServer" running in the background and it takes about 1s

[18:25] <lee_> er CompileServer

[18:28] <pmurias> http://pastie.org/8049400

[18:29] <pmurias> I get an error when running perl Configure.pl --gen-parrot

[18:29] <pmurias> used to work before

[18:34] <pmurias> which is caused by --prefix="/home/pawel/..." instead of --prefix="/home/pawel/..." being passed to Configure.pl in parrot

[18:37] *** ajr_ left
[18:38] <pmurias> and the whole bug was solved in parrot 8 days ago

[18:40] * moritz doesn't see the difference

[18:49] <FROGGS_> there is no difference

[18:50] *** census left
[18:51] <timotimo_> ~ doesn't matter if you're black or white ~

[19:00] *** tomyan left
[19:02] *** raiph left
[19:05] <ssutch> what are any resources for how grammar/actions and their interaction works?

[19:06] <ssutch> running the debugger, i can step into actions, but kinda lost at what to do once there

[19:06] <ssutch> btw, a grammar that parses all of protocol buffers IDL: https://github.com/samuraisam/p6-pb/blob/master/lib/PB/Grammar.pm (!)

[19:07] <timotimo_> ssutch: when the token/rule/whatever is finished matching, the same-named method in the action class will be called and it will be passed the $/ variable

[19:07] <timotimo_> then, you'd usually use the "make" function to set what the resulting object's .ast value is

[19:07] *** drin_m left
[19:07] <ssutch> when i run 'say $/' in the debugger, it just says (Any)

[19:08] <pmurias> FROGGS_: re there is no difference - you mean to the build process?

[19:08] <timotimo_> did you put the $/ into the method signature?

[19:08] <ssutch> method proto ($/) { make $<proto>.ast; }

[19:09] <timotimo_> okay. in that case, perhaps your version of rakudo is too old; there recently was a fix that made $/ and $! visible to the repl and debugger

[19:09] <ssutch> ah ok, perhaps, i am running the latest star on this machine

[19:10] <FROGGS_> pmurias: the --prefix-es you posted... they are the same

[19:10] <timotimo_> star is too old, yes

[19:10] <ssutch> timotimo_ yes, you're right; i added my $f = $/ and got something from it

[19:10] <timotimo_> the fix went in a few days or maybe a week after star was released

[19:12] *** census joined
[19:12] *** telex left
[19:14] *** telex joined
[19:16] <pmurias> FROGGS_: sorry

[19:16] <pmurias> FROGGS_: a --prefix with quotes is not accepted by the parrot nqp fetches

[19:17] <pmurias> because of a bug

[19:17] *** sunnavy left
[19:18] <FROGGS_> pmurias: ahhh, I see

[19:18] *** bonsaikitten left
[19:19] *** bonsaikitten joined
[19:20] *** Ben_Goldberg joined
[19:20] *** woolfy joined
[19:24] *** domidumont left
[19:28] *** [particle] left
[19:30] *** Gothmog_ joined
[19:34] *** raiph joined
[19:36] *** census left
[19:39] <ssutch> so i think it makes sense to turn the Grammar into a PB::Package class, which in turn has PB::Messages, enums, options, etc

[19:40] <ssutch> how do i carry that $package throughout the actions then? do i just set $package to an instance variable on the actions class?

[19:42] *** SamuraiJack joined
[19:45] *** [particle] joined
[19:46] <timotimo_> you mean use the grammar to generate an instance of the PB::Package class?

[19:46] <ssutch> yeah

[19:46] <timotimo_> ah

[19:46] <timotimo_> that makes sense, yeah

[19:47] <ssutch> and eventually, take PB::Package and turn it into native-feeling perl module

[19:48] *** sunnavy joined
[19:51] *** cognominal joined
[20:02] *** kaare_ left
[20:03] <ssutch> so does this seem right: method package ($/) { make PB::Package.new(name => $<dotted-ident>.Str); }

[20:03] *** raiph left
[20:03] *** spider-mario joined
[20:05] *** abnorman left
[20:06] <ssutch> r: https://gist.github.com/samuraisam/5793230

[20:06] <camelia> rakudo b2072f: OUTPUT¬´(Any)‚ê§¬ª

[20:06] <ssutch> not what i wanted, but on my system gives "use of uninitialized value of type Any in string context  in block  at lib/PB/Actions.pm:23"

[20:07] <timotimo_> i think your $/.ast is faulty, but i'm not sure.

[20:08] <ssutch> yeah, kinda still bumping into things whilst wandering around in the dark

[20:09] <timotimo_> i think you can turn the [...] in your proto token into a $<foo>=(...)

[20:10] <timotimo_> it should be easier still to use an actual proto token for your proto token

[20:10] <FROGGS_> that $/.ast is faulty

[20:11] <FROGGS_> should be like $<proto>=[<message>..., and then in actions: make QAST::Op.new( :op<call>, :name('&infix:<,>'), $<proto>.ast )

[20:11] *** Rix left
[20:11] <timotimo_> wait what? when did we start building qast?

[20:12] <ssutch> 0_0

[20:12] <FROGGS_> ohh, nvm

[20:12] <timotimo_> :D

[20:13] <ssutch> so $<statements>=[<message> | <package> | <import> | <option> | <enum> | <extend> | <service> | ';']*

[20:13] *** pmurias left
[20:13] <ssutch> then i can go $<statements>.ast.flat;

[20:13] <FROGGS_> yeah, and in the method proto: $<statements>.ast.flat

[20:13] <FROGGS_> right

[20:14] <timotimo_> yup. not 100% sure how it'll handle the ";", it would probably give you an (Any) in your list of ast's

[20:14] <FROGGS_> you have to change method TOP afterwards

[20:14] <timotimo_> watch out, though, the .flat could flatten the asts messages, packages etc

[20:16] <ssutch> r: https://gist.github.com/samuraisam/5793230

[20:16] <camelia> rakudo b2072f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Redeclaration of symbol PB::Package‚ê§at /tmp/aktXiRtFoe:110‚ê§------> [32mclass PB::Package [33m‚èè[31m{ [0m‚ê§    expecting any of:‚ê§        scoped declarator‚ê§        constraint‚ê§        postfix‚ê§        statement end‚ê§        statement mod‚Ä¶

[20:16] <[Coke]> ("s not accepted) - are you getting the latest parrot?

[20:16] <ssutch> r: https://gist.github.com/samuraisam/5793230

[20:16] <camelia> rakudo b2072f: OUTPUT¬´(Any)‚ê§¬ª

[20:16] <[Coke]> ISTR I just chased this down so that you could do something like --prefix="/path with a space/" and have it work.

[20:17] <ssutch> ok i made those changes, $statements= and $<statements>.ast.flat

[20:18] <timotimo_> ah, hold on

[20:18] *** cognominal left
[20:18] <timotimo_> i think you need $<statements>>>.ast instead

[20:18] <timotimo_> $<statements> will be a list of match objects, rather than an actual match object, no?

[20:19] <timotimo_> r: <foo bar baz>.>>.uc.perl.say

[20:19] <camelia> rakudo b2072f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused‚ê§at /tmp/Llggt7RJ_X:1‚ê§------> [32m<foo bar baz>.[33m‚èè[31m>>.uc.perl.say[0m‚ê§    expecting any of:‚ê§        dotty method or postfix‚ê§¬ª

[20:19] <timotimo_> r: <foo bar baz>>>.uc.perl.say

[20:19] <camelia> rakudo b2072f: OUTPUT¬´("FOO", "BAR", "BAZ")‚ê§¬ª

[20:20] <timotimo_> std: <foo bar baz>.>>.uc.perl.say

[20:20] <camelia> std d4cc5ab: OUTPUT¬´ok 00:00 41m‚ê§¬ª

[20:20] <timotimo_> that's a rakudobug, then? hm. wonder if i'd be able to figure it out.

[20:20] <ssutch> alright, shoot

[20:21] <ssutch> i have to go do family things, i'll be back

[20:21] *** Rix joined
[20:21] <timotimo_> sure :)

[20:22] <ssutch> "fathers day"

[20:23] <[Coke]> anyone see anything obviously wrong with the action here:

[20:23] <[Coke]> https://github.com/partcl/partcl-nqp/blob/nqp2/src/Partcl/Actions.pm#L281

[20:24] <timotimo_> do you get a specific error from that?

[20:24] <[Coke]> https://gist.github.com/coke/cdc0d82fd63e0282038c - not that I know that's where the error is coming from.

[20:27] *** lizmat left
[20:29] <[Coke]> yes, that's where it's coming from.

[20:29] <FROGGS_> [Coke]: you can try &concat instead

[20:30] <timotimo_> ah, indeed that sounds like a good plan

[20:30] <[Coke]> looks like it might be a confusion of an old PAST style syntax.

[20:31] *** woolfy left
[20:32] <[Coke]> Could not find sub &concat.

[20:32] <[Coke]> trying to ditch the call and just use concat.

[20:32] <FROGGS_> hmmm

[20:33] <[Coke]> docs/qast.markdown - "the ops themselves are documented separtely" - is this referring to docs/nqp-opcode.txt ?

[20:33] <FROGGS_> [Coke]: is this about string concat?

[20:34] <[Coke]> I believe it is trying to QAST-wrap a call to nqp::concat, aye.

[20:34] <FROGGS_> [Coke]: if yes, you could call &infix:<~> on all parts at once

[20:34] <timotimo_> try nqp::say($past.dump); after that action method?

[20:35] <[Coke]> where is, e.g. "nqp::concat" documented?

[20:36] <timotimo_> oh, you want to do nqp::concat

[20:36] <timotimo_>         - QAST::Op(concat) nqp::concat(\"hoo\", \"blop\")

[20:36] <timotimo_> that's how you do a nqp::concat in qast

[20:36] <timotimo_> it's not op<call>, it's op<concat>

[20:37] <[Coke]> there's a concat and a concat_s - do either of those save the value in one of the operands?

[20:37] *** PacoAir left
[20:38] *** pmurias joined
[20:38] <timotimo_> i can't even find the nqp::concat op :|

[20:43] *** dmol left
[20:43] <pmurias> [Coke]: I don't think the ops are documented anywhere, I mostly search the test suit and read the source

[20:45] <[Coke]> pmurias: I was afraid that was the answer.

[20:46] <FROGGS_> please try to call the infix, that is what rakudo and v5 does

[20:47] <[Coke]> pushed a fix to eliminate the call. no clue if it's working, but gets me past the current problem.

[20:48] *** dmol joined
[20:49] <timotimo_> [Coke]: can you give me a brief summary of why i should be interested in tcl?

[20:50] <[Coke]> very unlikely.

[20:50] <ssutch> hah.

[20:51] <[Coke]> its parser is very different from other languages. it was, for a while, *the* embedding language. 

[20:52] * masak waves from back-in-Sweden o/

[20:52] <FROGGS_> hi masak 

[20:53] *** cognominal joined
[20:53] <lue> hello world o/

[20:53] <[Coke]> timotimo_: only reason I'm working on it was that I thought it would be an interesting language for multi-language support on parrot. that never really went anywhere, though I got it to the point where you could run quite a bit of the tcl test suite.

[20:54] <lue> Would it be better to move S03/Adverbs to after terminator precedence, or to make it a =head2 ? (I prefer the first choice because Adverbs are not a precedence level)

[20:54] *** woolfy joined
[20:55] *** lizmat joined
[20:59] <masak> lue: I'm not sure such a change is worth the dust it'd kick up in the blame-log.

[20:59] <masak> that's just my very uninformed initial opinion, though.

[21:00] <lue> Well, considering the Adverbs section describes them as "at a pseudo-precedence level slightly tighter than item assignment", I feel that at least the =head1 was a typo that should be =head2

[21:01] <lue> (I just suggested the move because it's not even in the precedence table at the top of the spec)

[21:05] *** MrMeek-afk joined
[21:07] *** MrMeek left
[21:08] *** woolfy left
[21:09] *** fgomez joined
[21:13] *** zby_home_ left
[21:13] *** twigel joined
[21:15] *** bruges left
[21:17] *** bruges joined
[21:25] *** woolfy joined
[21:32] *** woolfy left
[21:32] *** lizmat left
[21:32] *** lizmat joined
[21:32] <lizmat> r: 42.classify: { $_ }.say  # why shouldn't this work?

[21:32] <camelia> rakudo b2072f: OUTPUT¬´Block.new()‚ê§Nominal type check failed for parameter '&t'; expected Callable but got Bool instead‚ê§  in method classify at src/gen/CORE.setting:1344‚ê§  in block  at /tmp/pDg3yuJ0Ok:1‚ê§‚ê§¬ª

[21:33] <lizmat> r: 42.classify:({ $_ }).say  # I meanyt why shouldn't this work?

[21:33] <camelia> rakudo b2072f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse expression in signature; couldn't find final ')'‚ê§at /tmp/R14I_lSmnN:1‚ê§------> [32m42.classify:([33m‚èè[31m{ $_ }).say  # I meanyt why shouldn't th[0m‚ê§    expecting any of:‚ê§        colon pair‚ê§        signature‚ê§¬ª‚Ä¶

[21:33] <lizmat> r: 42.classify({ $_ }).say  # I meant why shouldn't this work?

[21:33] <camelia> rakudo b2072f: OUTPUT¬´("42" => [42]).hash‚ê§¬ª

[21:34] <lizmat> t/spec/S32-list/classify.t seems to think it shouldn't

[21:34] <pmurias> [Coke]: I'll expand the test suit as part of my gsoc project which hopefully will make it a better reference ;)

[21:35] <[Coke]> pmurias++

[21:36] <lizmat> I'm inclined to fix the test assuming it's ok that it works (albeit a bit nonsensical)

[21:42] <masak> I also think it should work.

[21:42] <masak> Perl generally doesn't have a bias against confusing an item with a collection.

[21:46] *** cognominal left
[21:46] *** cognominal joined
[21:52] <[Coke]> what is the nqp equivalent of pir::find_dynamic_lex ?

[21:53] <timotimo_> git log -u -S to the rescue!

[21:53] <timotimo_> -            my $found := pir::find_lex_relative__PPs(

[21:53] <timotimo_> +            my $found := nqp::getlexrel(

[21:53] <timotimo_> oh, wait, that's not it at all

[21:53] <masak> :)

[21:53] <timotimo_> pir::find_dynamic_lex_relative__PPs -> nqp::getlexreldyn  ;  likely your op is called something similar

[21:54] <timotimo_> pir::find_dynamic_lex__Ps('$?REGEX')(self)  ->  nqp::getlexdyn('$?REGEX')(self)  -  sound good?

[21:57] *** rindolf left
[21:57] <[Coke]> timotimo_: you find that in a git history search? danke.

[21:57] <[Coke]> (someone should add that to docs/nqp-opcode.txt

[22:05] <dalek> roast: a9f8006 | (Elizabeth Mattijsen)++ | S32-list/classify.t:

[22:05] <dalek> roast: Simplification/Addition tests of classify() and .classify()

[22:05] <dalek> roast: review: https://github.com/perl6/roast/commit/a9f8006bf7

[22:08] *** raiph joined
[22:11] <lizmat> too tired to work on categorize.t now, sleep&

[22:11] <[Coke]> No registered operation handler for 'getlexreldyn'

[22:17] <timotimo_> nqp: nqp::say(nqp::getlexdyn('$?ROUTINE'));

[22:17] <camelia> nqp: OUTPUT¬´Null PMC access in get_string()‚ê§current instr.: '' pc 43 ((file unknown):148909852) (/tmp/vtHJHfoR4x:1)‚ê§¬ª

[22:18] <timotimo_> nqp: nqp::getlexdyn('$?ROUTINE');

[22:18] <camelia> nqp:  ( no output )

[22:18] <timotimo_> nqp: nqp::getlexreldyn('$?ROUTINE');

[22:18] <camelia> nqp: OUTPUT¬´Error while compiling block : Error while compiling op getlexreldyn (source text: "nqp::getlexreldyn('$?ROUTINE')"): No registered operation handler for 'getlexreldyn'‚ê§current instr.: '' pc 48612 (src/stage2/QAST.pir:17766) (src/stage2/QAST.nqp:2981)‚ê§¬ª

[22:18] <timotimo_> mhm

[22:19] <[Coke]> no doubt I'm missing a setup somewhere.

[22:20] <masak> yes, hm, there's a file where you register these.

[22:22] *** spider-mario left
[22:22] *** lizmat left
[22:22] *** nitestryker_ left
[22:24] *** lizmat joined
[22:26] *** dmol left
[22:29] *** bbkr left
[22:32] *** Rix left
[22:35] *** pecastro_ joined
[22:37] *** pecastro left
[22:43] <[Coke]> I suspect I need a lesson on how to use the funky lexical stuff in nqp.

[22:50] <Ben_Goldberg> .ping

[22:50] <yoleaux> There is no ping command; nor can this be construed as a response.

[22:50] <timotimo_> :D

[22:50] <diakopter> .yoleaux

[22:50] <diakopter> speechless.

[22:52] *** benabik joined
[22:52] <Ben_Goldberg> I've got a silly question: how hard would it be to implement a 'comefrom' command in perl6?

[22:54] *** frdmn left
[22:55] <dalek> perl6-bench: 7db63d0 | (Geoffrey Broadwell)++ | TODO:

[22:55] *** frdmn joined
[22:55] <dalek> perl6-bench: Add a TODO for IO tests

[22:55] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/7db63d09fe

[22:55] <dalek> perl6-bench: a46b452 | (Geoffrey Broadwell)++ | timeall:

[22:55] <dalek> perl6-bench: Add timeall infrastructure to support tagged tests; add automatically generated tags to tests at startup; add options (with corresponding docs) to list all known tags, list tests matching a tag query, and run tests matching a tag query

[22:55] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/a46b452ce9

[22:55] <dalek> perl6-bench: 2b05b1e | (Geoffrey Broadwell)++ | bench:

[22:55] <dalek> perl6-bench: Enable 'bench time' pass-through to timeall for --tests-tagged option

[22:55] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/2b05b1e6e5

[22:55] <dalek> perl6-bench: 9a6ae7c | (Geoffrey Broadwell)++ | bench:

[22:55] <dalek> perl6-bench: Tiny whitespace fix

[22:55] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/9a6ae7c814

[23:15] <masak> Ben_Goldberg: pretty hard, I imagine. goes pretty deep into the kind of runtime semantics that isn't easily pluggable.

[23:15] <masak> Ben_Goldberg: also, have you considered exactly what semantics you want this 'comefrom' keyword of yours to have?

[23:15] *** Rix joined
[23:16] <masak> Ben_Goldberg: for example, can there be more than one 'comefrom' statement referring to the same label?

[23:16] <masak> ...and what would that mean?

[23:16] <masak> (and before you say "well, obviously...", consider whether it is so obvious) :)

[23:16] <timotimo_> may i suggest a comefrom_and_take($foo, $bar, $baz) syntax, so that you may take local variables over from the previous "position"?

[23:17] <masak> wtf

[23:18] <masak> ...because 'comefrom' wasn't crazy enough already!?

[23:18] <diakopter> haha.

[23:19] <masak> timotimo_: that's not what lexical variables *mean*.

[23:19] <diakopter> eye_gouge($just, $give, $up, $now, $compiler)

[23:19] <timotimo_> i'm glad i was able to improve on the crazy that is comefrom

[23:19] <masak> all you did was smash Don Quixote real hard against another windmill.

[23:20] <timotimo_> use A_WHITEBOARD_FOR_ASSISTANCE_WHEN_READING_THIS_CODE;

[23:20] <timotimo_> good night :)

[23:20] <masak> 'night, timo

[23:21] <sorear> masak: multiple come-froms have a standard meaning.  http://www.cse.unsw.edu.au/~malcolmr/intercal/threaded.html

[23:21] <masak> sorear: I'm aware of multi-threaded INTERCAL ;)

[23:21] <masak> sorear: I would also have accepted "it randomly picks a destination" as a "correct" answer. :)

[23:22] <diakopter> "Each variable has its own set of variables which are private to that thread"

[23:22] <diakopter> surely there's a wrong word in there

[23:22] <masak> even the variables have variables!

[23:23] <masak> diakopter: it's well-founded because some variables can have the empty set :P

[23:24] *** Ben_Goldberg left
[23:25] *** BenGoldberg joined
[23:30] * lue just imagined some sort of C<use ONE_WORLD_GOV;> that makes every single variable global to the entire program, even if they weren't meant to be.

[23:47] <sorear> bah.  autosinking causes a huge explosion of QAST

[23:48] <sorear> (dump output)

[23:48] <diakopter> sorear: your development cycle nowadays is curiously different from when you were doing niecza :)

[23:49] <diakopter> at least, seems that way from a distance

[23:49] <diakopter> back then, your computer was so slow you wrote bug-free code :P

[23:58] <sorear> diakopter: my new computer can compile rakudo about as fast as the old one could compile niecza :P

[23:58] <diakopter> haha.

