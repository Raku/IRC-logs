[00:00] <diakopter> well, my involvement started yesterday when I insulted rurban on twitter, in reply to his grandiose claims about Parrot's GC/threads

[00:01] *** benabik left
[00:03] <swarley> This picture feels relevant. http://media.tumblr.com/tumblr_m81j9veVbr1r856dg.gif

[00:04] <lue> [Coke]: was your "general community note" referring to the discussion here last night (≈20hrs ago, istr), or some discussion on #parrot at another time?

[00:04] <diakopter> my words on #parrot recently

[00:04] <sorear> lue: ongoing discussion in #parrot

[00:05] <[Coke]> swarley: ... 

[00:05] <lue> ah. /me considers joining #parrot

[00:05] <diakopter> [Coke]: but to answer your question, my point in join #parrot today was to rebut rurban's claim that I was without a clue and not knowledgeable

[00:06] <japhb_> lue, probably easier to just irc log it: http://irclog.perlgeek.de/parrot/2013-02-08

[00:06] * flussence just finished reading that and... Wat.

[00:06] <sorear> ok.  everyone, please say "you're wrong" when you want to say "you're clueless"

[00:07] <sorear> the latter is a personal attack and it *always* makes things worse

[00:07] <lue> japhb_: already have it open :)  I liked the discussion between moritz and others at around 21:30

[00:08] <lue> *nod*

[00:08] <japhb_> sorear, Even "you're wrong" is usually too strong.

[00:08] <japhb_> "I disagree" would be about as far as I would go most of the time.

[00:09] <sorear> !seen doy

[00:09] <sorear> seen doy

[00:09] <[Coke]> ENOALOHA.

[00:09] <[Coke]> we need to fire up an aloha instance on feather if we want it back.

[00:10] <[Coke]> I declare a bounty of five USD if it gets done in the next week.

[00:10] <sorear> looks from the logs like doy didn't leave for a specific public reason

[00:11] <lue> fwiw, S17 is still marked as a DRAFT, which likely doesn't help.

[00:15] <diakopter> sorear: you're right; I shouldn't have flamebaited rurban on twitter. I lost my patience with his noise, and I shouldn't have.

[00:16] *** jeffreykegler joined
[00:21] *** swarley-freenode is now known as swarles

[00:22] <swarles> To be fair, and I'm not supporting anyone's actions here but, he was a little annoying with regards to making sure you knew how good the GC and threads were, based on today's IRC log alone

[00:23] <diakopter> pmichaud: I wasn't claiming there was no relationship soured. I merely stated that I didn't see it. Please point it out if it's there

[00:23] *** swarley left
[00:23] *** swarles is now known as swarley

[00:23] <flussence> lue: bleh, I hope that gets changed. I'd rather have s:g/async/bg/ :)

[00:24] <[Coke]> diakopter: conversation grumpiness followed by rurban leaving the channel with no resolution of technical issues. That counts as a negative in my book.

[00:24] <lue> Can anyone quickly tell me|point me to why rurban seems to have been so frustrated with Parrot lately? I'm only curious.

[00:25] <flussence> he found something O(fun) to work on instead (p2)?

[00:26] <lue> Ah. I thought something in|about parrot caused him to leave and start p2.

[00:27] <diakopter> well, he's said several times the invocation system is very inefficient

[00:29] <jnthn> phenny: tell arnsholt So, what I thought were two examples of the same issue were actually not. I fixed one of them. I still need to deal with the other one (which has broken the Rakudo build). I'm too tired now, but anyway, back to square 1 on finding it... :(

[00:29] <phenny> jnthn: I'll pass that on when arnsholt is around.

[00:35] <swarley> Making progress with the organization of nqp-go. I have a basic implementation of *Spec, STable, and SixModelObject, recommendations on where to move from here?

[00:35] <jnthn> swarley: Attack the bootstrap :)

[00:35] <swarley> Oh lord, alright I suppose that had to come eventually

[00:36] <jnthn> Unfortunately that means also taking on calling convetion stuff I guess...

[00:36] <jnthn> uh, convection

[00:36] <jnthn> ...gah! convention!

[00:36] <swarley> With what regard?

[00:36] *** stevan__ joined
[00:36] <swarley> Like, referencing a method added to an object via an STable?

[00:36] <jnthn> The bootstrap involves building KnowHOW, the core meta-object.

[00:37] <jnthn> Yes, but you need to decide how parameters will be handled.

[00:38] *** stevan_ left
[00:39] <swarley> Oh, I suppose I'll need to look up the rules of perl6's method/sub parameter signatures to make that decision

[00:41] <swarley> I'll probably do it with a positive arity means that they are literal arguments, and a negative one means it needs to be further examined

[00:42] <skids> .oO("Calling convection"... is that how parameters rise up through thunky inversion layers?)

[00:43] <swarley> be right back

[00:45] *** xilo_ left
[00:45] <TimToady> nr: my $lines = +qx[tput lines]; my $cols  = +qx[tput cols]; say "$lines $cols";

[00:45] <p6eval> rakudo 4fb07b: OUTPUT«qx, qqx is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:2␤  in sub QX at src/RESTRICTED.setting:9␤  in block  at /tmp/I8VWfgnDpC:1␤␤»

[00:45] <p6eval> ..niecza v24-20-g93138cc: OUTPUT«Unhandled exception: rungather may not be used in safe mode␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (rungather @ 0) ␤  at /tmp/hns2SOI9td line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4227 (ANON @ 3) ␤  at /home/p6eval/niec…

[00:45] <TimToady> how come, when I run that program, it reports 24x80 rather than the actual dimensions of my terminal?

[00:45] <masak> TimToady: no idea. works locally.

[00:46] <masak> no wait.

[00:46] <masak> 24 80

[00:46] <flussence> 35×116 on mine...

[00:46] <masak> here too.

[00:46] <masak> flussence: did you run tput directly?

[00:46] <masak> (like I did first)

[00:46] <flussence> I copy-pasted that line into the repl

[00:46] <skids> LINES and COLUMNS are not exported by shell

[00:47] <masak> on the repl it works.

[00:47] <masak> just not with -e

[00:47] <flussence> oh, yeah. 24 80 here

[00:47] * masak submits rakudobug

[00:47] <flussence> I'm betting it's libreadline doing something on its own to get the numbers

[00:47] <flussence> which then causes them to be defined for tput

[00:48] * TimToady wonders if something's closing STDIN

[00:48] <skids> it works if you export LINES; export COLUMNS even if you resize after doing so.

[00:49] <jnthn> sleep &

[00:49] <TimToady> skids: um, that's not going to help after you've started the program

[00:50] *** benabik joined
[00:50] <TimToady> turns out niecza closes STDIN on qx[] (or attaches to /dev/null), but that doesn't explain rakudo's behavior

[00:51] <TimToady> if I replace tput with cat, rakudo lets me type in a number, and it comes back out

[00:52] <masak> 'night, #perl6

[00:53] <skids> TimToady: just observing that, is all.

[00:53] <japhb_> o/ masak

[00:53] <japhb_> Sleep well.

[00:54] <TimToady> if I do qx[echo $LINES] it comes out 0

[00:54] <TimToady> but most of the rest of the environment seems to be there

[00:55] <TimToady> weird

[00:56] <TimToady> I think I'd better parse stty -a for now instead

[00:58] <TimToady> well, that works with rakudo, if not niecza

[00:59] <TimToady> niecza seems intent upon not making /dev/tty to qx[]

[00:59] <TimToady> *available to

[01:00] <flussence> the bash manpage says it updates $LINES/$COLUMNS on a sigwinch, but even if I try "qx[kill -WINCH $$; ..." it doesn't give a useful answer. very confused.

[01:01] <sorear> probably only happens for interactive shells

[01:01] <ingy> *yawn*

[01:02] <TimToady> from a Unix point of view it's kind of antisocial to lose track of STDIN, just because STDOUT is redirected to a pipe...

[01:12] *** thou left
[01:15] *** jerome left
[01:16] *** pmurias left
[01:21] *** cognominal joined
[01:27] *** jerome joined
[01:34] *** arlinius joined
[01:37] *** PacoAir left
[01:37] *** xilo_ joined
[01:43] *** japhb_ left
[01:44] <swarley> Alright, I have valid STable, BoolificationSpec, StorageSpec, ContainerSpec, InvocationSpec, and SixModelObject declarations :)

[01:45] <diakopter> swarley: are you publishing the code somewhere?

[01:45] <swarley> I will be in just a moment

[01:45] <swarley> I'm just adding a comment to this file first

[01:52] <swarley> diakopter; http://github.com/swarley/nqp-go/

[01:52] <swarley> there is only one subdir with files to it in src/ so I doubt you'll spend more than 5 minutes browsing the code

[01:53] <swarley> Probably only 200 lines of code if that, but i'm still trying to figure out how to engineer this in to be honest

[01:58] *** xilo_ left
[02:11] *** FROGGS_ joined
[02:14] *** FROGGS left
[02:35] *** Chillance left
[02:36] *** erkan left
[02:41] *** arlinius left
[03:08] *** arlinius joined
[03:14] *** Targen joined
[03:24] *** cognominal left
[03:27] *** rking joined
[03:28] *** arlinius left
[03:33] *** cognominal joined
[03:36] <swarley> .u ⮀ 

[03:36] <phenny> U+2B80 (No name found)

[03:36] <phenny> U+0020 SPACE ( )

[03:55] *** arlinius joined
[04:03] *** cognominal left
[04:04] *** aindilis joined
[04:07] *** cognominal joined
[04:08] *** Targen left
[04:09] *** cognominal left
[04:23] *** alec__ left
[04:28] *** kshannon left
[04:29] *** kshannon joined
[04:31] *** happydude joined
[04:32] *** happydude left
[04:36] *** alec__ joined
[04:59] *** preflex_ joined
[05:00] *** preflex left
[05:01] *** preflex_ is now known as preflex

[05:07] *** vaelxon joined
[05:16] *** jeffreykegler left
[05:21] *** xinming left
[05:23] *** xinming joined
[05:44] <swarley> I want the sound from this website to play every time I get a segfault from my program

[05:44] <swarley> I mean, I have yet to get one, but still http://nooooooooooooooo.com/

[05:57] *** thou joined
[07:08] *** dayangkun joined
[07:15] *** domidumont joined
[07:19] *** kaare_ joined
[07:23] *** domidumont left
[09:11] *** am0c joined
[09:17] *** thou left
[09:45] *** Psyche^ joined
[09:49] *** Patterner left
[09:49] *** Psyche^ is now known as Patterner

[09:54] *** stevan__ left
[09:55] *** rindolf joined
[09:57] *** wk joined
[10:03] <moritz> jnthn++ # "calling convection" in the backlog

[10:03] <moritz> :-)

[10:08] *** am0c left
[10:20] <dalek> nqp: afaf87d | jnthn++ | src/ops/nqp.ops:

[10:20] <dalek> nqp: Corret nested SC write barrier enable/disable.

[10:20] <dalek> nqp: 

[10:20] <dalek> nqp: Unbusts the Rakudo build on latest NQP.

[10:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/afaf87d109

[10:58] *** spider-mario joined
[11:04] <masak> afty.

[11:05] * masak hugs everyone, just in case

[11:05] <nwc10> what long arms you have

[11:06] <masak> they're special-made for the purpose.

[11:37] *** SamuraiJack joined
[11:45] *** not_gerd joined
[11:46] <not_gerd> jnthn: see https://github.com/perl6/nqp/issues/74 for some more information on my NQP failures on latest Parrot

[11:46] <not_gerd> the backtrace printer now segfaults, apparently because some constants table is borked

[11:58] <dalek> nqp: 978dc43 | jnthn++ | src/ (3 files):

[11:58] <dalek> nqp: Prepare for eliminating clone callback prop use.

[11:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/978dc43396

[11:58] <dalek> nqp: 1b41b41 | jnthn++ | src/pmc/sixmodelobject.pmc:

[11:58] <dalek> nqp: Add a check to avoid a possible segfault.

[11:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1b41b41bf8

[11:58] <dalek> nqp: f7eb701 | jnthn++ | src/NQP/World.pm:

[11:58] <dalek> nqp: Eliminate use of properties for clone callback.

[11:58] <dalek> nqp: 

[11:58] <dalek> nqp: Still a reference in the setting, but that can go away with a bootstrap

[11:58] <dalek> nqp: update.

[11:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f7eb70170a

[11:59] <jnthn> not_gerd: That sounds...extremely borked indeed...

[12:05] <not_gerd> oO( this is not the constant you're looking for )

[12:08] <not_gerd> do moritz and tadzik build on 32-bit systems as well?

[12:08] <not_gerd> if so, using a 32-bit toolchain might be the way to reproduce the failure....

[12:14] <jnthn> not_gerd: I'm guessing you're on 32-bit lso?

[12:14] <jnthn> *also

[12:14] <not_gerd> jnthn: correct

[12:15] *** PacoAir joined
[12:16] <dalek> nqp-jvm-prep: 1ff0365 | jnthn++ | src/org/perl6/nqp/sixmodel/SerializationReader.java:

[12:16] <dalek> nqp-jvm-prep: Fix position-o in deserialize.

[12:16] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1ff03654e7

[12:16] <dalek> nqp-jvm-prep: e5838cb | jnthn++ | nqp-src/NQPCORE.setting:

[12:16] <dalek> nqp-jvm-prep: Adpot latest clone callback updates.

[12:16] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e5838cb03b

[12:16] <dalek> nqp-jvm-prep: a1696e0 | jnthn++ | t/nqp/55-multi-method.t:

[12:16] <dalek> nqp-jvm-prep: We now pass 55-multi-method.t.

[12:16] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a1696e0b3b

[12:16] <jnthn> not_gerd: Oddness. I find it hard to think what could break 32-bit but not 64-bit in that commit...

[12:17] <not_gerd> perhaps re-shuffling some code exposed some long-standing issue

[12:17] <not_gerd> got https://github.com/perl6/nqp/issues/64 ever resolved?

[12:18] <jnthn> I think that one did, yes.

[12:18] <jnthn> It looks familiar at least.

[12:19] <not_gerd> I might try finding out what't the latest Parrot revision that can host NQP master

[12:19] <not_gerd> perhaps that'smore instructive

[12:19] <jnthn> Maybe or maybe not. It's certainly not clear to me what's going on. :(

[12:20] <jnthn> I will try and get hold of a 32-bit build to try and recreate it.

[12:33] *** wk_ joined
[12:37] *** wk left
[12:43] <tadzik> not_gerd: I build on 64bit

[12:52] <not_gerd> tadzik: so that's not the deciding factor :(

[13:01] *** SamuraiJack_ joined
[13:01] *** SamuraiJack left
[13:02] <nwc10> Are NQP's arrays resizable AND lazy? Or (just) Perl 6's?

[13:05] <colomon> .union

[13:06] <nwc10> All tests successful.

[13:06] <nwc10> Files=23, Tests=274, 35 wallclock secs ( 0.10 usr  0.20 sys + 24.56 cusr  7.44 csys = 32.30 CPU)

[13:06] <nwc10> Result: PASS

[13:06] <jnthn> nwc10: No laziness in nqp

[13:06] <nwc10> that's on x86 Linux, with everything origin/master

[13:07] <nwc10> jnthn: ah OK. In which case, if lazyness can be "faked up" at Perl 6 level, presumably so can sparseness if desired?

[13:07] <jnthn> nwc10: Rakudo's make test, I guess?

[13:07] <nwc10> ie, doesn't make sense to have to do it as NQP ops

[13:07] <nwc10> yes, Rakudo make test

[13:07] <jnthn> Yeah

[13:16] <not_gerd> ls

[13:19] * not_gerd fails to make any headway in tracking down the error

[13:19] <not_gerd> anyway, have a nice weekend

[13:19] *** not_gerd left
[13:21] <nwc10> so what is the problem that crops up on (some) 32 bit platforms?

[13:29] *** jerome left
[13:30] *** aleveres joined
[13:35] <jnthn> nwc10: Not sure so far...

[13:37] *** SamuraiJack_ left
[13:59] *** SamuraiJack_ joined
[14:06] *** erkan joined
[14:06] *** erkan left
[14:06] *** erkan joined
[14:09] *** aleveres_ joined
[14:09] *** aleveres left
[14:09] *** aleveres_ is now known as aleveres

[14:18] *** zby_home_ joined
[14:19] <dalek> nqp: 7133fa1 | jnthn++ | src/ (4 files):

[14:19] <dalek> nqp: Preparations for positional/associative delegate.

[14:19] <dalek> nqp: 

[14:19] <dalek> nqp: This work will eliminate some of the v-table use that is in the way of

[14:19] <dalek> nqp: certain bits of porting work, but should also provide some other wins.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7133fa1bbb

[14:19] <dalek> nqp: 7ec2668 | jnthn++ | src/6model/knowhow_bootstrapper.c:

[14:19] <dalek> nqp: Get KnowHOW bootstrap using REPR compose protocol.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7ec2668a45

[14:19] <dalek> nqp: 9c09d92 | jnthn++ | t/nqp/60-bigint.t:

[14:19] <dalek> nqp: Fix a test that used KnowHOW incorrectly.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9c09d9204a

[14:19] <dalek> nqp: 9ad9e37 | jnthn++ | t/serialization/02-types.t:

[14:19] <dalek> nqp: Fix another bad use of KnowHOW.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ad9e37a2e

[14:19] <dalek> nqp: e93ea46 | jnthn++ | src/ops/nqp.ops:

[14:19] <dalek> nqp: Fix an op that failed to compose a package.

[14:19] <dalek> nqp: 

[14:19] <dalek> nqp: The op overall needs to go away as it's something of a hack, but easier

[14:19] <dalek> nqp: to just fix it up for now.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e93ea465cf

[14:19] <dalek> nqp: e387b52 | jnthn++ | src/6model/reprs/P6opaque.c:

[14:19] <dalek> nqp: Finish removal of pre-REPR-compose code.

[14:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e387b52cef

[14:19] <dalek> rakudo/nom: b39b6f2 | jnthn++ | src/Perl6/Metamodel/ (2 files):

[14:19] <dalek> rakudo/nom: Make sure we call compose_repr early enough.

[14:19] <dalek> rakudo/nom: 

[14:19] <dalek> rakudo/nom: Should always call it before the first intantiation.

[14:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b39b6f2ad2

[14:53] *** mjwhitta joined
[14:56] *** mjwhitta left
[15:01] *** awwaiid left
[15:02] *** pjcj left
[15:06] <colomon> rn: sub a(*@hashes) { say @hashes.perl; }; a(set(<a b c>), set(<d e f>)); 

[15:06] <p6eval> rakudo 4fb07b: OUTPUT«Array.new("a", "b", "c", "d", "e", "f")␤»

[15:06] <p6eval> ..niecza v24-20-g93138cc: OUTPUT«(set("a", "b", "c"), set("d", "e", "f")).list␤»

[15:06] *** pjcj joined
[15:08] *** Chillance joined
[15:08] *** awwaiid joined
[15:09] * jnthn wonders which of those is right

[15:09] * jnthn guesses sets probably shouldn't flatten...

[15:10] <jnthn> rn: my @a = set(<a b c>); say @a.perl

[15:10] <p6eval> niecza v24-20-g93138cc: OUTPUT«[set("a", "b", "c")].list␤»

[15:10] <p6eval> ..rakudo 4fb07b: OUTPUT«Array.new("a", "b", "c")␤»

[15:13] <jnthn> rn: for set(<a b c>) { .say }

[15:13] <p6eval> niecza v24-20-g93138cc: OUTPUT«set(a, b, c)␤»

[15:13] <p6eval> ..rakudo 4fb07b: OUTPUT«a␤b␤c␤»

[15:14] <jnthn> If I give Rakudo the niecza semantics on the assignment/slurpy case, it will also get the "it's an item in a for loop" semantics.

[15:14] <jnthn> Guess that's OK.

[15:19] *** SunilJoshi joined
[15:21] <colomon> what would a hash do?  (instead of a set.)

[15:22] <jnthn> rn: my %h = a => 1, b => 2; my @a = %h; say @a.perl

[15:23] <p6eval> rakudo b39b6f: OUTPUT«Array.new("a" => 1, "b" => 2)␤»

[15:23] <p6eval> ..niecza v24-20-g93138cc: OUTPUT«["a" => 1, "b" => 2].list␤»

[15:23] <jnthn> It flattens.

[15:23] <jnthn> That's why set does also.

[15:23] <jnthn> I guess, anyway.

[15:23] <jnthn> So it would be making it different to hash.

[15:25] <colomon> yeah.

[15:25] <colomon> huh.

[15:26] <dalek> nqp: 723aae4 | jnthn++ | src/6model/ (3 files):

[15:26] <dalek> nqp: P6opaque adding list/hash delegation to P6opaque.

[15:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/723aae488d

[15:26] <dalek> nqp: 030ba9b | jnthn++ | src/ (4 files):

[15:26] <dalek> nqp: s/Indexing/Positional/ in REPR funcs.

[15:26] <dalek> nqp: 

[15:26] <dalek> nqp: Makes it more consistent with Perl 6 terminology and the naming on the

[15:26] <dalek> nqp: JVM.

[15:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/030ba9b090

[15:26] <colomon> jnthn: I guess leave it for now.

[15:26] <jnthn> wow, I fail it at writing commit messages...

[15:26] <jnthn> colomon: Yeah, it's probably one for TimToady++ to weigh in on. Other @other :)

[15:29] <colomon> TimToady++

[15:35] <dalek> nqp: 5795fdf | jnthn++ | src/6model/ (3 files):

[15:35] <dalek> nqp: Toss a bunch of (thankfully unused) mis-design.

[15:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5795fdf1b8

[15:37] <nwc10> jnthn++ # 3 files changed, 43 deletions(-)

[15:37] <nwc10> deleted code is the best code

[15:40] *** SunilJoshi left
[15:45] <tadzik> :)

[15:45] <tadzik> it's certainly bug free

[15:48] <jnthn> ...unles something depended on it :)

[15:48] * jnthn just deleted some more things and is now building stuff to make sure it's as dead code as he thinks it is.

[15:49] <[Coke]> jnthn++

[15:51] <tadzik> what do you think about Rakudo joining http://play-perl.org/?

[15:52] <tadzik> It looks like the new Cool Thing :)

[15:52] <tadzik> tl;dr: you open quests and people complete them for karma

[15:52] <tadzik> like GCI, but no money

[15:53] *** aleveres left
[15:58] <jnthn> tadzik: If it's a way to potentially attract contributors, it seems reasonable.

[15:58] *** uvtc joined
[15:59] * nwc10 is rather confused. I'm trying to work out *where* in NQP the actual code is that implements delete on array.

[15:59] <dalek> nqp: 90e12d2 | jnthn++ | src/ (3 files):

[15:59] <dalek> nqp: Toss some unused v-table handler usages.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/90e12d2c70

[15:59] <dalek> nqp: 7676c23 | jnthn++ | src/6model/ (3 files):

[15:59] <dalek> nqp: Fill out positional REPR funcs more reasonably.

[15:59] <nwc10> to try to delete it. to see what breaks.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7676c2315d

[15:59] <nwc10>  3 files changed, 18 deletions(-)

[16:00] <tadzik> nwc10: what do you mean by "delete on array?" nqp::deletepos?

[16:00] <nwc10> yes. but I cant' work out where that is

[16:00] <tadzik> that's mapped directly to Parrot's delete_keyed_int opcode

[16:00] <jnthn> nwc10: Well, we use the ResizablePMCArray from Parrot, so that's where the actual implementation is. But there's also what tadzik mentioned...that's in QAST::Operations.

[16:00] <jnthn> Right, mapping in src/QAST/Operations.pm or so

[16:00] <tadzik> nwc10: src/stage2/QAST.nqp 1898:QAST::Operations.add_core_pirop_mapping('deletepos', 'delete', '0Qi', :inlinable(1));

[16:01] <nwc10> aha. ack wasn't searchignt hat

[16:01] <tadzik> yeah, it's ack -a for nqp I think

[16:13] *** benabik left
[16:14] *** benabik joined
[16:22] <tadzik> jnthn: should nqp-jvm-prep fail to build now?

[16:24] <jnthn> tadzik: No, though it may require bleeding edge NQP

[16:24] <tadzik> nqp --target=pir --setting=NULL --stable-sc --output=NQPCOREJVM.setting.pir nqp-src/NQPCORE.setting

[16:24] <tadzik> Can not bind attribute '$!clone_callback' declared in class 'NQPRoutine' with this object

[16:24] <tadzik> and nqp is up-to-date

[16:28] *** SunilJoshi joined
[16:29] <swarley> So, what is ack?

[16:31] <swarley> Never mind, I found it

[16:31] <swarley> debian's plain package for ack is a kanji converter. So I was a bit confused

[16:35] * benabik suggests `echo "--type-set=perl6=.pl6,.pm6,.p6n--type-set=nqp=.nqp" > ~/.ackrc

[16:39] *** FROGGS_ is now known as FROGGS

[16:42] <FROGGS> good {{{enter your time of day here}}} folks

[16:42] <jnthn> tadzik: Odd. I can't get it to do that here.

[16:45] <nwc10> is there a way to run individual spectests directly. I tried the obvious and I get:

[16:45] <nwc10> $ ./perl6 t/spec/S16-filehandles/filestat.t

[16:45] <nwc10> ===SORRY!===

[16:45] <nwc10> Could not find Test in any of: /home/nick/Perl/rakudo/install/lib/parrot/4.10.0-devel/languages/perl6/site/lib, /home/nick/Perl/rakudo/install/lib/parrot/4.10.0-devel/languages/perl6/vendor/lib, /home/nick/Perl/rakudo/install/lib/parrot/4.10.0-devel/languages/perl6/lib, /home/nick/.perl6/2013.01-110-gb39b6f2/lib

[16:46] <jnthn> -Ilib

[16:46] <nwc10> ta

[16:47] <FROGGS> nwc10: /usr/bin/perl t/harness --fudge --keep-exit-code --icu=1 t/spec/S05-metasyntax/litvar.t --verbosity=1

[16:47] <FROGGS> in the rakudo dir

[16:47] <FROGGS> thats what I do

[16:47] <jnthn> That's a lot of typing ;)

[16:48] <FROGGS> no, just slash and page up :o)

[16:48] <jnthn> :)

[16:48] <swarley> what shell does everyone use?

[16:49] <tadzik> well, I use zsh

[16:49] <FROGGS> bash

[16:49] <nwc10> bash, but I should investigate zsh

[16:49] <swarley> I use zsh

[16:49] <swarley> I've yet to find a csh'er

[16:50] <tadzik> try #cobol ;)

[16:50] <swarley> oh boy, I'd rather not

[16:50] <jnthn> .oO( I didn't think *that's* what the "c" was for :P )

[16:50] <tadzik> or, I think BSDs still use that as a default shell

[16:50] <swarley> I would look at cobol, if it wasn't for the header of the file

[16:50] <tadzik> or it's named tcsh now

[16:50] <swarley> also c in csh is C shell

[16:51] <swarley> csh

[16:51] <swarley> C Shell, a shell (command interpreter) with C-like syntax 

[16:51] <FROGGS> tadzik: I think my openbsd ( a year^old) has csh, yes

[16:54] <swarley> I giggled when I learned about adventure shell

[16:54] <swarley> http://nadvsh.sourceforge.net/

[16:56] <swarley> alright then. I suppose I should get to work on making the base SMObject struct

[17:04] *** SamuraiJack_ left
[17:04] *** SamuraiJack_ joined
[17:05] *** pmurias joined
[17:05] *** SamuraiJack_ left
[17:05] <pmurias> nwc10: my .ackrc for nqp http://pastie.org/6104432

[17:05] *** SamuraiJack_ joined
[17:07] *** domidumont joined
[17:10] * [Coke] gives a shot at creating a stripped down parrot.

[17:10] *** SamuraiJack__ joined
[17:10] <[Coke]> ... this is going to be slooow. :|

[17:11] *** SamuraiJack_ left
[17:11] <swarley> lol.

[17:12] <timotimo> you're removing the beautiful plumage?

[17:14] <tadzik> [Coke]++

[17:17] *** rindolf left
[17:32] *** pjcj left
[17:37] *** Targen joined
[17:40] * japhb is making good progress on collecting the raw info to start producing the module gap analysis

[17:41] <japhb> I could use some input into the lists "Dog food we already eat" + "Dog food we should be eating"

[17:41] <tadzik> module gap analysis?

[17:42] *** domidumont left
[17:42] *** domidumont joined
[17:43] <japhb> tadzik, I'm going through various different ways to view "Modules we should have in Star-or-the-equivalent to cover most starting needs"

[17:43] <tadzik> japhb: we need proper async IO"

[17:43] <japhb> And then figuring out what we've already got covered, and what is still needed.

[17:43] <tadzik> a libuv binding, or so

[17:44] <tadzik> _sri++ is probably the right person to be consulted about this

[17:44] <japhb> tadzik, async IO is a feature, not a module.  :-)  But I'm actually *also* creating a list of features most wanted by module authors, so that request will go there.  :-)

[17:44] <tadzik> for example, we still write our IRC bots in Perl 5. We shouldn't have to, but the efforts so far fail because of no proper async IO

[17:44] <japhb> Already consulted _sri, he was the first one I asked about features we need before he can do major porting.

[17:44] <tadzik> japhb: I'm sure it can be implemented as a modle

[17:46] <tadzik> in fact, I'll be implementing it now if it wasn't for the upcoming vacation :)

[17:46] <japhb> tadzik, you're implementing async file IO as a module?  Or you're implementing a libuv binding?

[17:48] <japhb> tadzik, Also, I'd already had irc bots on the "Dog food we should be eating" list.  Specifically, I had dalek, phenny, and aloha.  Any others to add?

[17:48] <japhb> moritz, what is ilbot written in?

[17:48] <pmurias> perl6

[17:48] <pmurias> *perl5

[17:48] <japhb> *chuckle*

[17:49] <tadzik> japhb: I'm not yes :P

[17:49] <tadzik> *yet

[17:49] <japhb> heh

[17:49] <tadzik> but it's on the endless "after exams" list

[17:49] <japhb> No one can type today.  :-)

[17:49] <tadzik> and after exams is now

[17:50] <japhb> tadzik, I intend to have a nice big pile of -Ofun available for you or anyone else soon.  You won't be short of fun tasks for a very long time.  ;-)

[17:50] <tadzik> japhb: do you know the Most Wanted Module List?

[17:50] <tadzik> it may need some revising

[17:50] <skids> japhb: put me in for uint* as "features wanted"

[17:51] <tadzik> shopping&

[17:51] <japhb> tadzik, yep, that's one of the sources I'm working from.

[17:51] <japhb> skids, you mean sized natives?

[17:51] <skids> specifically unsigned but yes.

[17:51] <japhb> Or specifically sized *unsigned* natives

[17:51] <japhb> OK

[17:51] <japhb> arnsholt, did you implement unsigned as well, or just signed?

[17:52] <uvtc> [Coke]: re. stripped-down Parrot. I like the fast start-up I get with the current Rakudo⌁Parrot.

[17:53] <dalek> nqp: c4a988a | jnthn++ | src/ (2 files):

[17:53] <dalek> nqp: First pass at getting positional_delegate working.

[17:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4a988a17b

[17:53] <dalek> nqp: 6afcc54 | jnthn++ | src/NQP/Actions.pm:

[17:53] <dalek> nqp: Fix thinkos.

[17:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6afcc54663

[17:53] <dalek> nqp: 6ad0c64 | jnthn++ | src/stage0/ (9 files):

[17:53] <dalek> nqp: Update bootstrap.

[17:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ad0c64978

[17:53] <dalek> nqp: 51c43bf | jnthn++ | src/ (3 files):

[17:53] <dalek> nqp: Switch some things over to positional_delegate.

[17:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/51c43bf667

[17:53] <dalek> nqp: 27c96a9 | jnthn++ | src/QAST/Compiler.nqp:

[17:53] <dalek> nqp: Make VarWithFallback handle type-obj indexing.

[17:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/27c96a9687

[17:53] <japhb> OK, I think I've got all the above comments pulled into my working docs

[17:53] <japhb> More input very much welcomed!

[17:53] *** autark joined
[17:54] <uvtc> japhb: My guess is that R* would be an answer to "What is the batteries-included distribution of Perl 6?"

[17:55] <FROGGS> uvtc: right

[17:55] <japhb> uvtc, exactly

[17:55] <pmurias> japhb: in QAST is to legal to declare the same variable twice?

[17:55] <pmurias> err jnthn 

[17:55] <japhb> Right now it's a few batteries short of a full pack.  :-)

[17:56] <uvtc> "Python has batteries included!!". Ok, so does Perl 6 --- see R*.

[17:56] <jnthn> pmurias: No

[17:56] <uvtc> "

[17:56] <jnthn> pmurias: However, I dunno how hard it looks for it 

[17:56] <skids> japhb: I've had to do horrible things to work around the diamond crony role NYI, but that might be RT'd IIRC.

[17:56] <jnthn> pmurias: (At the QAST::Compiler level.)

[17:57] <jnthn> skids: It's RT'd.

[17:57] *** uvtc left
[17:57] <japhb> skids: Wait, what?  That was a little too compressed for me to read right off.

[17:58] <skids> It's when you inherit A and B which both do C -- the methods and attribs in C conflict.

[17:58] <jnthn> Inherit or compose?

[17:59] <dalek> nqp: d3431b6 | jnthn++ | src/stage0/ (9 files):

[17:59] <dalek> nqp: Update bootstrap.

[17:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d3431b69e5

[17:59] <dalek> nqp: c123e22 | jnthn++ | src/core/NQPMu.pm:

[17:59] <dalek> nqp: Eliminate another Parrot v-table use.

[17:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c123e2229f

[17:59] <japhb> skids, ah "diamond role composition NYI", is that what you meant?

[18:00] <japhb> jnthn++ # Much kicking of NQP butt.

[18:01] <swarley> I can't wait to see a parrot free nqp :)

[18:01] <skids> japhb: yes.

[18:01] <swarley> well, a less parrot plagued nqp

[18:02] <japhb> skids, OK, got it.  :-)

[18:02] <nwc10> OK, Rakudo needs existspos, but not deletepos

[18:02] <japhb> Besides the IRC bots, what other dog food should we be eating?

[18:02] <nwc10> japhb: I'd suggest (at least) make install

[18:03] <japhb> nwc10, ooh, good one

[18:03] <nwc10> and as much of the build system as possible

[18:03] <nwc10> ie, the aim of the build system should be to get a working perl6 up, and then use it to build as much as possible

[18:03] <nwc10> (in my opinion)

[18:04] <jnthn> japhb: tools/contributors.pl and perhaps some other things in this directory could be dogfooeded

[18:05] <japhb> jnthn, OK, good

[18:05] <japhb> nwc10, I agree.

[18:05] <nwc10> this does potentially make cross-compiling a bit more difficult, but worry about that a *lot* later.

[18:06] <arnsholt> Can always keep the Perl 5 versions under a new name as well

[18:06] <phenny> arnsholt: 00:28Z <jnthn> tell arnsholt So, what I thought were two examples of the same issue were actually not. I fixed one of them. I still need to deal with the other one (which has broken the Rakudo build). I'm too tired now, but anyway, back to square 1 on finding it... :(

[18:06] <japhb> nwc10, The funny thing is that we already *have* the cross-compiling problem.

[18:06] <nwc10> python 2.7 has batteries included. Which is great, until you want some fresh ones, but you also want to keep using Django

[18:06] <FROGGS> swarley: I dont really care if the VM is parrot or JVM or something else, rakduo is good enough for my needs

[18:07] <nwc10> I think I messed up the bootstrap. I don't think that Rakudo needs existspos either. Trying to fix things to verify this

[18:07] <swarley> I'm not really concerned with the end product, I'm fine with it using Parrot. I just would like to see the code not relying on parrot

[18:07] *** tokomer joined
[18:09] *** benabik left
[18:10] <jnthn> arnsholt: I fixed the other one this morning :)

[18:10] <nwc10> jnthn: my hunch is that the entire code and tests for exists and delete on arrays can be removed from NQP without affecting Rakudo, its tests, or the spectests

[18:10] * skids envisions a product so complex that it's easier to cross-compile stage1 and then build an emulator of the target system rather than a native stage1. :-)

[18:11] <jnthn> nwc10: nqp::existspos is certainly used in the Rakudo setting

[18:12] <jnthn> nwc10: Seems deletepos ain't

[18:12] <nwc10> ah OK. then I'm wrong on my earlier thought

[18:12] <swarley> Go interfaces are making this sixModel very interesting to code.

[18:12] <nwc10> OK, deletepos can go right away...

[18:12] <nwc10> (will redo that one)

[18:12] <pmurias> and the reason deletepos is not used is that Array.delete is implemented incorrectly

[18:12] *** benabik joined
[18:12] <nwc10> but if deletepos isn't used, then I think that that means that it should be possible to recode existspos in terms of the array size

[18:13] <nwc10> OK. :-(

[18:13] <jnthn> nwc10: Yes, I expect so.

[18:13] <nwc10> me-- # not using git to save the state of my intermediate work

[18:13] <nwc10> hopefully emacs undo can save me

[18:13] <jnthn> pmurias: Even if that's the case, we probably don't need a deletepos

[18:14] <pmurias> do we want to keep the Perl 5 "sparse" semantics?

[18:14] <jnthn> It's a degenerate case of splice.

[18:14] <nwc10> I feel that it belongs in Rakudo, not in NQP

[18:14] * skids back to shoveling knee-high snow.

[18:14] <nwc10> no. We don't want the Perl 5 *broken* sparse semantics

[18:14] <jnthn> Are those teh semantics Perl 5 has deprecated anyway?

[18:14] <pmurias> yes

[18:14] <nwc10> can I mumble on that one please :-)

[18:15] * jnthn wonders if we want an Array.delete method.

[18:15] <nwc10> possibly not.

[18:15] <arnsholt> jnthn: Yeah, I spotted the commit in the scrollback. Good stuff

[18:15] <nwc10> is it fair/easy/legit to offer a SparseArray which is a subclass of Array?

[18:15] <tadzik> jnthn: could you take a look at https://github.com/jnthn/nqp-jvm-prep/pull/15?

[18:16] <tadzik> the existing existspos is rong

[18:17] <jnthn> tadzik: ah, indeed

[18:17] <dalek> nqp-jvm-prep: 1d9f6b4 | tadzik++ | / (2 files):

[18:17] <dalek> nqp-jvm-prep: Make existspos respect the start marker

[18:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1d9f6b4b2a

[18:17] <dalek> nqp-jvm-prep: 602f9dc | jonathan++ | / (2 files):

[18:17] <dalek> nqp-jvm-prep: Merge pull request #15 from tadzik/existspos-bugfix

[18:17] <dalek> nqp-jvm-prep: 

[18:17] <dalek> nqp-jvm-prep: Make existspos respect the start marker

[18:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/602f9dc8c6

[18:17] <jnthn> Hunger strikes! Shop, dinner... &

[18:17] * nwc10 apologises if he's working here to delete code that people lovingly crafted in the past few days.

[18:17] <pmurias> nwc10: shouldn't a SparseArray actually use sparse storage?

[18:18] <nwc10> yes.

[18:18] <nwc10> well, I guess yes.

[18:18] <tadzik> nwc10: I'm glad it'll be gone :)

[18:18] <nwc10> you can fake it on non-sparse storage, I guess.

[18:18] <pmurias> having sparse semantic and a non-sparse storage might be confusing

[18:18] <tadzik> I didn't like it from the start

[18:20] <arnsholt> Well, once you have working sparse semantics you can refactor the guts to use sparse storage as well =)

[18:20] *** SamuraiJack__ left
[18:20] <arnsholt> Make it run, make it right, make it fast =)

[18:21] <nwc10> "fast" might be a lot easier if you can use native arrays and not add a layer on top to fake sparseness

[18:22] <nwc10> but, if there is already a layer on top...

[18:23] <arnsholt> But if you need optimised underlying storage to make it truly blazingly fast, we can always make a custom REPR for it

[18:24] <pmurias> jnthn: the $?PACKAGE only seems to have a default value in the symtable

[18:29] <pmurias> jnthn: ah, it's a compile_time_value

[18:37] *** pjcj joined
[18:38] *** marloshouse left
[18:39] *** SunilJoshi left
[18:41] *** marloshouse joined
[18:47] <pmurias> jnthn: do we want to somehow annotate it on QAST::Var or should I extract it from the symtable?

[19:02] <TimToady> r: sub clear { print state $ = qx[clear] }

[19:02] <p6eval> rakudo b39b6f: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block clear: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while com…

[19:03] <TimToady> rakudobug

[19:05] *** jeffreykegler joined
[19:12] <swarley> Just finished implementing Object (the equivalent of nqp-jvm's SixModelObject), now to figure out what I should do now

[19:13] <pmurias> swarley: think how will you compile method calls, function calls, variables, number addition etc.

[19:15] <swarley> I think that number addition will actually be easy if I can make an interface that would force me to implement a number class that can do all of the things that perl6 numbers/integers are supposed to be able to do

[19:15] *** awwaiid left
[19:15] <swarley> Since in go you can make an interface an argument type, and you can pass anything that implements all of the methods described in the interface

[19:16] *** awwaiid joined
[19:17] *** jerome joined
[19:21] <dalek> rakudo-js: 6a3a4fb | (Paweł Murias)++ | / (2 files):

[19:21] <dalek> rakudo-js: Pass qast_variable.t

[19:21] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/6a3a4fb8dc

[19:26] <japhb> WIP: https://github.com/japhb/perl6-most-wanted

[19:27] <japhb> time to take a keyboard break, I think.  :-)

[19:29] <dalek> rakudo-js: 23ebf1c | (Paweł Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[19:29] <dalek> rakudo-js: Declare javascript variables we store lexicals in.

[19:29] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/23ebf1c863

[19:30] <pmurias> TimToady: can we get rid of Array.delete?

[19:31] *** snearch joined
[19:32] *** snearch left
[19:32] <pmurias> TimToady: and Array.exists? as that seems to be a port of deprecated Perl 5 semantics

[19:33] <swarley> one thing that I'm afraid of is that Go doesn't yet support dynamic loading..

[19:34] <swarley> Actually, it supports dynamic loading of C code

[19:34] <swarley> but not Go code

[19:35] *** GlitchMr left
[19:36] *** japhb left
[19:37] *** japhb joined
[19:38] <jnthn> pmurias: What node were you expecting to have its compile_time_value? Typcially though, they're resolved through the symbol table.

[19:39] *** GlitchMr joined
[19:39] <jnthn> r: sub clear { print state $ = qx[clear] }

[19:39] <p6eval> rakudo b39b6f: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block clear: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while com…

[19:39] <jnthn> r: sub clear { print state $x = qx[clear] }

[19:39] <p6eval> rakudo b39b6f:  ( no output )

[19:42] <pmurias> QAST::Var but I'm taking the value from the symtable now

[19:48] <dalek> rakudo-js: 7d66efa | (Paweł Murias)++ | runtime.js:

[19:48] <dalek> rakudo-js: fake box_n, unbox_n

[19:48] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/7d66efa77e

[19:48] <dalek> rakudo-js: e3c8b1d | (Paweł Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[19:48] <dalek> rakudo-js: remove use of nqp.undef

[19:48] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/e3c8b1d993

[19:49] <nwc10> jnthn: OK, if one wants to punt "exists" on an array up from NQP into Rakudo, one needs to have a way to flag a slot as "non-existent"

[19:49] <nwc10> as best I can tell right now this is done in Parrot with PMC_IS_NULL, and in Java with null

[19:49] *** snearch joined
[19:49] <nwc10> ie, exists_pos tests that.

[19:50] <nwc10> and there's no way to (re)set it from NQP let alone Rakudo

[19:50] <nwc10> rn: my @a; @a[2] = "c"; say @a.exists(1); say @a[1].perl

[19:50] <p6eval> niecza v24-20-g93138cc: OUTPUT«Unhandled exception: Unable to resolve method exists in type Array␤  at /tmp/AVCfak51ry line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4227 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4228 (module-CORE @ 580) ␤  at /ho…

[19:50] <p6eval> ..rakudo b39b6f: OUTPUT«False␤Any␤»

[19:50] <nwc10> r: my @a; @a[2] = "c"; @a[1]=Any; say @a.exists(1); say @a[1].perl

[19:50] <p6eval> rakudo b39b6f: OUTPUT«True␤Any␤»

[19:52] *** snearch left
[19:52] <nwc10> also, is this an off-by-one on delete?

[19:52] <jnthn> nwc10: We can easily nqp::bindpos an nqp::null there I guess

[19:52] *** snearch joined
[19:52] <nwc10> r: my @a; @a[2] = "c"; @a[1]=Any;  say @a.exists(1); say @a[1].perl

[19:52] <p6eval> rakudo b39b6f: OUTPUT«True␤Any␤»

[19:52] <pmurias> can't we just remove Array.delete and Array.exists?

[19:53] <jnthn> pmurias: I am trying to work out what they're actually for :)

[19:53] <jnthn> Like, actual use cases

[19:53] <pmurias> the seem to be copied over from Perl 5

[19:53] <pmurias> * they

[19:54] <nwc10> OK, here goes:

[19:54] <jnthn> My intuitive guess woulda been that .delete is basically splicing out the element in question and exists is about elems.

[19:55] <nwc10> r: my @a; @a[2] = "c"; @a[1]=Any; say @a.exists(1); say @a[1].perl; # no deleting

[19:55] <p6eval> rakudo b39b6f: OUTPUT«True␤Any␤»

[19:55] *** snearch left
[19:55] <nwc10> r: my @a; @a[2] = "c"; @a[1]=Any; @a.delete(1); say @a.exists(1); say @a[1].perl; # deleting at 1

[19:55] <p6eval> rakudo b39b6f: OUTPUT«True␤Any␤»

[19:55] <nwc10> my @a; @a[2] = "c"; @a[1]=Any; @a.delete(2); say @a.exists(1); say @a[1].perl; # deleting at 2

[19:56] <nwc10> r: my @a; @a[2] = "c"; @a[1]=Any; @a.delete(2); say @a.exists(1); say @a[1].perl; # deleting at 2

[19:56] <p6eval> rakudo b39b6f: OUTPUT«False␤Any␤»

[19:56] *** snearch joined
[19:56] <jnthn> r: my @a = 1,2,3; @a.delete(1); say @a

[19:56] <nwc10> so, delete at 2, and element 1 goes away

[19:56] <p6eval> rakudo b39b6f: OUTPUT«use of uninitialized value of type Any in string context  in block  at /tmp/oOxT2iAxYw:1␤␤1  3␤»

[19:56] <pmurias> nwc10: there is already a ticket for that

[19:56] <pmurias> it looks like a bug

[19:56] <jnthn> OK, I honestly thought delete actually shrunk the array up until now. Shows how much I've used it :/

[19:57] *** snearch left
[19:57] <dalek> rakudo/nom: 7ad6e63 | jnthn++ | src/Perl6/Actions.pm:

[19:57] <dalek> rakudo/nom: Fix anonymous state variable regression.

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ad6e63edf

[19:57] <jnthn> TimToady: ^^

[19:58] *** snearch joined
[19:58] <jnthn> r: my $x = 1; sub foo() { state $ = $x++ }; say foo; say foo;

[19:58] <p6eval> rakudo b39b6f: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block foo: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while compi…

[19:58] <jnthn> good, that's a test case...

[19:58] <nwc10> oh, I see the crazy in Array.delete. :-(

[19:59] <nwc10> it's, just, well, wrong.

[20:00] *** snearch left
[20:00] <TimToady> delete is primarily there for sparse arrays, but if normal arrays can support it, why not?  you can save a bit more memory that way

[20:01] *** snearch joined
[20:01] <dalek> roast: e1540b7 | jnthn++ | S04-declarations/state.t:

[20:01] <dalek> roast: Test anonymous state variables.

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/e1540b700f

[20:01] <jnthn> TimToady: But what's it actually meant to do?

[20:01] <TimToady> generally, poke in a null pointer

[20:01] <jnthn> OK, and .exists(...) checks for in range and non-null?

[20:02] <TimToady> yeah

[20:02] <jnthn> OK.

[20:02] <nwc10> pop needs to be consistent with sparseness

[20:02] <jnthn> r: my @a; @a[1] = 1; say @a[0].exists;

[20:02] <p6eval> rakudo b39b6f: OUTPUT«No such method 'exists' for invocant of type 'Any'␤  in block  at /tmp/FLwc_eQDA5:1␤␤»

[20:03] <jnthn> r: my @a; @a[1] = 1; say @a[0]:exists;

[20:03] <p6eval> rakudo b39b6f: OUTPUT«Any()␤»

[20:03] <jnthn> r: my @a; @a[1] = 1; say @a.exists(0);

[20:03] <p6eval> rakudo b39b6f: OUTPUT«False␤»

[20:03] *** snearch left
[20:03] <jnthn> r: my @a; @a[1] = 1; say @a.exists(1);

[20:03] <p6eval> rakudo b39b6f: OUTPUT«True␤»

[20:03] <jnthn> nwc10: Example?

[20:03] <nwc10> I can give you it in perl 5. Let's try perl 6

[20:05] <nwc10> r: my @a; @a[2] = "c"; pop @a; say @a.exists(1); say @a[1].perl; say @a.elems; @a.delete(1); say @a.exists(1); say @a[1].perl; say @a.elems;

[20:05] <p6eval> rakudo b39b6f: OUTPUT«False␤Any␤2␤False␤Any␤0␤»

[20:05] <nwc10> there.

[20:05] <nwc10> deleting an element that *does not exist* changes the size of the array

[20:06] <GlitchMr> masak, when the article about first p6cc task will appear?

[20:06] * nwc10 doesn't exactly find that behaviour sane.

[20:06] <jnthn> Sounds like that's taking "poke a null in there" too literally...

[20:07] <jnthn> Anyway, from this I observe that exists is implementable in terms of elems and nqp::isnull(nqp::atpos(...)) 

[20:07] <TimToady> isn't that the code that is treating delete like splice anyway?

[20:07] <jnthn> And delete in terms of nqp::elems and bindpos'ing a null

[20:08] <nwc10> the Rakudo code for delete is strange and wrong. Doesn't seem to be splicing

[20:08] <jnthn> TimToady: Given until about 10 mintues ago I thought that was the sane thing for it to do, it wouldn't surprise me...

[20:08] <TimToady> :)

[20:08] <GlitchMr> <nwc10> [20:04:13] deleting an element that *does not exist* changes the size of the array

[20:08] <GlitchMr> I've tried doing that in JavaScript.

[20:09] <GlitchMr> Until 'say @a.elems;' part, everything was exactly like Rakudo did.

[20:09] <GlitchMr> Second 'say @a.elems;', that is.

[20:09] <nwc10> not sure if this is the same Rakudo bug as already reported:

[20:09] <nwc10> r: my @a; @a[2] = "c"; @a[1] = Mu; say @a.exists(1); say @a[1].perl; say @a.elems; @a.delete(2); say @a.exists(1); say @a[1].perl; say @a.elems;

[20:09] <p6eval> rakudo b39b6f: OUTPUT«True␤Mu␤3␤False␤Any␤0␤»

[20:09] <nwc10> in that, the trim loop in Array.delete is using a defined test, not an exists test

[20:10] <jnthn> nwc10: Hm, delete looks...odd.

[20:10] <nwc10> it's wrong. It's not doing the Perl 5 behaviour

[20:10] *** not_gerd joined
[20:10] <nwc10> but if it did do the Perl 5 behaviour

[20:10] <nwc10> it would still be inconsistent with pop's current behaviour

[20:10] <not_gerd> Parrot 'post mortem' by chromatic: http://www.modernperlbooks.com/mt/2013/02/goodnight-parrot.html

[20:10] <GlitchMr> Appears to be a bug in delete.

[20:11] <nwc10> (just like Perl 5 is inconsistent between pop, delete and exists)

[20:11] <pmurias> implementing delete for typed arrays (of integers for example) will be tricky

[20:11] <not_gerd> my own vision: http://lists.parrot.org/pipermail/parrot-dev/2013-February/007333.html

[20:11] <nwc10> the implementation sneaks out

[20:11] <GlitchMr> Still, depending on .delete() to work on arrays is just wrong.

[20:11] <jnthn> nwc10: I can see it's wrong from the outside. :) Looking at it makes me wonder why it's the way it is. :)

[20:11] <GlitchMr> I think it was wrong in any programming language.

[20:12] <nwc10> delete *should* work on sparse arrays

[20:12] <GlitchMr> But well, the del behavior in Python is sane.

[20:12] <nwc10> it's meaningful there

[20:12] <GlitchMr> The delete behavior in Perl 6 appears to be JavaScript behavior.

[20:12] <GlitchMr> Which is so wrong.

[20:12] <jnthn> I suspect this isn't one of JavaScripts good parts ;)

[20:12] <GlitchMr> In JavaScript, array is just object with magical .length property.

[20:13] <GlitchMr> Or unset() in PHP.

[20:13] <GlitchMr> The problem is that in JS or PHP, arrays are just objects.

[20:13] <GlitchMr> In Perl 6, arrays are arrays.

[20:14] <GlitchMr> I would rather make .delete() illegal, or implement Python behavior.

[20:14] <colomon> TimToady: would it be okay to add a .set method to p6?  (Or are we already supposed to have one?)  ie instead of set @a you'd be able to say @a.set

[20:15] <GlitchMr> I think the similar argument applies to delete for arrays in Perl 5.

[20:15] <TimToady> colomon: sure

[20:15] <GlitchMr> But delete for arrays is already deprecated in Perl 5.

[20:15] <TimToady> GlitchMr: not by me :)

[20:16] <colomon> TimToady: thanks!

[20:16] <GlitchMr> Personally I find delete on arrays working like that a mistake.

[20:16] *** rindolf joined
[20:17] <GlitchMr> Replacing value with Any is just wrong.

[20:19] <GlitchMr> Personally, I would rather see @a.delete($x) to work like @a.splice($x, 1)

[20:19] <GlitchMr> This is Python behavior.

[20:20] *** snearch joined
[20:22] <dalek> niecza: 4c8f264 | (Solomon Foster)++ | lib/CORE.setting:

[20:22] <dalek> niecza: Add Cool.set and Cool.bag.

[20:22] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4c8f2643b6

[20:23] *** snearch left
[20:23] *** snearch joined
[20:24] <nwc10> Python behaviour precudes sparse arrays, doesn't it?

[20:24] <TimToady> GlitchMr: no, I don't want to huffmanize splicing

[20:25] <GlitchMr> Still, I'm not sure if .delete() working like that makes sense.

[20:25] *** snearch left
[20:25] <GlitchMr> It makes it feel like it's actually a hash, not an array.

[20:26] <TimToady> splicing one element of an array usually mean syou should be using a hash

[20:26] *** snearch joined
[20:27] <TimToady> if an implementation wants to provide sparse arrays by default for Array, then that's okay, and delete should work as in Perl 5

[20:28] <TimToady> need to take progeny to SJC, back later &

[20:28] <GlitchMr> Wasn't delete $a[0] syntax added to Perl 5 when pseudo hashes were added?

[20:28] <GlitchMr> For consistency?

[20:28] <nwc10> no, *after*

[20:28] <dalek> rakudo-js: a4f211a | (Paweł Murias)++ | / (2 files):

[20:28] <dalek> rakudo-js: Pass qast_arguments.t, implement named optional arguments.

[20:28] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/a4f211aa68

[20:28] *** snearch left
[20:29] <nwc10> problem is that pop doesn't properly emulate sparseness

[20:29] <nwc10> which would be fine for Perl 6, if pop from the "start" said "oh, it's sparse" and shrinks the array properly if popping of the last element exposes a gap

[20:30] <nwc10> also, the array ought to be properly sparse at both ends

[20:30] <nwc10> r: my @a; @a[42] = "Perl"; say @a.elems

[20:30] <p6eval> rakudo 7ad6e6: OUTPUT«43␤»

[20:30] <nwc10> which it's not. It's only sparse at the high end

[20:31] <GlitchMr> r: my @a; @a[Inf] = "Perl";

[20:31] <p6eval> rakudo 7ad6e6: OUTPUT«Cannot index Array with Inf␤  in method at_pos at src/gen/CORE.setting:6299␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1402␤  in block  at /tmp/oQrSnTxOCi:1␤␤»

[20:31] <GlitchMr> r: my @a; @a[9e99] = "Perl";

[20:31] <p6eval> rakudo 7ad6e6:  ( no output )

[20:31] <GlitchMr> r: my @a; @a[9e99] = "Perl"; say +@a

[20:31] <p6eval> rakudo 7ad6e6: OUTPUT«1␤»

[20:31] <GlitchMr> Is it array?

[20:31] <nwc10> good point. it's also not sparse in that sense either.

[20:32] <nwc10> it's pretty much exactly like how perl 5 does it. real allocation

[20:32] <GlitchMr> Looks more like hash, except only accepting positive integers.

[20:32] <nwc10> but an out of band way to say "this slot was never allocated to"

[20:32] <GlitchMr> r: my @a; @a[9e99] = "Perl"; say @a.perl;

[20:32] <p6eval> rakudo 7ad6e6: OUTPUT«Array.new("Perl")␤»

[20:33] <GlitchMr> huh?

[20:33] <GlitchMr> r: my @a; @a[9e99] = "Perl"; say @a[0];

[20:33] <p6eval> rakudo 7ad6e6: OUTPUT«Perl␤»

[20:33] <GlitchMr> HUH?

[20:33] <GlitchMr> r: my @a; @a[999999999999999999999999999999999999999999999999999] = "Perl"; say @a[0];

[20:33] <p6eval> rakudo 7ad6e6: OUTPUT«ResizablePMCArray: index out of bounds!␤  in block  at src/gen/CORE.setting:6309␤  in block  at /tmp/bVst6Idbkn:1␤␤»

[20:35] <colomon> n: my @a; @a[999999999999999999999999999999999999999999999999999] = "Perl"; say @a[0];

[20:35] <jnthn> Given arrays in Rakudo aren't spare, that would have been a lot of memory if it had worked ;)

[20:35] <p6eval> niecza v24-20-g93138cc: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/60Jm2iJi6e line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4227 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4228 (module-CORE @ 580) ␤  at /home/p6eval/niecza/li…

[20:35] <jnthn> *aprse

[20:35] <colomon> does seem like they both give a weird error, though.

[20:35] <jnthn> I suspect it overflows somewhere along the line.

[20:35] <GlitchMr> r: my @a = 4; @a[1.0] = 2; @a[2e0] = 3; say @a.perl

[20:35] <p6eval> rakudo 7ad6e6: OUTPUT«Array.new(4, 2, 3)␤»

[20:35] <GlitchMr> r: my @a = 4; @a[1.0] = 2; @a[1e0] = 3; say @a.perl

[20:35] <p6eval> rakudo 7ad6e6: OUTPUT«Array.new(4, 3)␤»

[20:36] <GlitchMr> huh?

[20:36] <GlitchMr> So why 9e99 == 0?

[20:36] *** domidumont left
[20:36] <jnthn> r: say 9e99

[20:36] <p6eval> rakudo 7ad6e6: OUTPUT«9e+99␤»

[20:36] <jnthn> bah

[20:36] <GlitchMr> I'm talking about 'my @a; @a[9e99] = "Perl"; say @a[0];'

[20:36] <nwc10> what integer does 9e99 get coerced to?

[20:36] <GlitchMr> 9e99 is Num

[20:37] <jnthn> Yes, and you have to turn it into an integer at some point.

[20:37] <GlitchMr> > 9e99.Int

[20:37] <GlitchMr> 8999999999999999948859130765266355329578537025198862586562510896759102769772101980841694466750283776

[20:37] <jnthn> r: 9e99.INT.say

[20:37] <p6eval> rakudo 7ad6e6: OUTPUT«No such method 'INT' for invocant of type 'Num'␤  in block  at /tmp/W0V2TW9abC:1␤␤»

[20:37] <jnthn> r: 9e99.Int.say

[20:37] <p6eval> rakudo 7ad6e6: OUTPUT«8999999999999999948859130765266355329578537025198862586562510896759102769772101980841694466750283776␤»

[20:37] <jnthn> I...am pretty sure that isn't going to work out without a very special array implementation. :)

[20:37] <GlitchMr> r: my int $i = 9e99.Int; say $i;

[20:37] <p6eval> rakudo 7ad6e6: OUTPUT«0␤»

[20:38] <GlitchMr> Huh?

[20:38] <geekosaur> too big to fit

[20:38] <GlitchMr> r: my @a; @a[9e99.Int + 1] = "Perl"; say @a.perl;

[20:38] <p6eval> rakudo 7ad6e6: OUTPUT«Array.new(Any, "Perl")␤»

[20:38] <GlitchMr> That would make sense

[20:38] <GlitchMr> So, yeah... 9e99 == 0

[20:39] <arnsholt> r: say max(3,5)

[20:39] <p6eval> rakudo 7ad6e6: OUTPUT«5␤»

[20:39] <geekosaur> 0 is probably better than random-wrapped-value

[20:39] <GlitchMr> If 9e99 is converted to native integer.

[20:39] <GlitchMr> > 8999999999999999948859130765266355329578537025198862586562510896759102769772101980841694466750283776 / 256 ** 32

[20:39] <GlitchMr> 77725516995850001186816

[20:40] <GlitchMr> So it's divisible by 256 ** 32

[20:40] <GlitchMr> To be exact, 256 ** 35

[20:41] <colomon> r: say 9e99.int

[20:41] <p6eval> rakudo 7ad6e6: OUTPUT«No such method 'int' for invocant of type 'Num'␤  in block  at /tmp/vuHTglvj3F:1␤␤»

[20:41] *** tadzik left
[20:44] <swarley> Why not just convert it to a constant like Infinity or something?

[20:45] <swarley> Since it's not an accurate computation anyway.

[20:45] <arnsholt> *sigh* It annoys me that Ubuntu doesn't install perldoc and friends along with Perl

[20:45] <nwc10> they'd probably try not to install perl, but they made the fatal mistake of picking Debian as their upstream :-)

[20:46] *** snearch joined
[20:48] *** snearch left
[20:49] *** snearch joined
[20:49] <swarley> [37] pry(main)> 9e99 - 8e99

[20:49] <swarley> => 1.0000000000000002e+99

[20:50] <swarley> heh, I was pretty sure that ruby handled those numbers as Bignums instead of floats to keep precision... I guess not

[20:51] <colomon> swarley: 8999999999999999948859130765266355329578537025198862586562510896759102769772101980841694466750283776 is a perfectly fine Int in p6.  Problem is it's not a fine int.  But then neither is Inf.

[20:51] *** snearch left
[20:51] <colomon> sanely speaking, I would think it should throw an array bounds error or something.

[20:52] *** snearch joined
[20:52] <swarley> I'm Just saying, if it's not 9 with 99 zeros behind it, it's not correct as far as the math goes so if you're relying on it to do calculations you may find it amiss. So I think that maybe a warning would be warranted

[20:52] <colomon> disagree.

[20:53] <colomon> that's the way floating point numbers always work.

[20:53] <swarley> I'm not saying its a perl6 specific thing

[20:53] <swarley> I know it happens in most languages

[20:53] <swarley> if not all

[20:53] <rindolf> Hi all.

[20:53] <GlitchMr> What do you want?

[20:53] <GlitchMr> > 9 * 10 ** 99

[20:53] <GlitchMr> 9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

[20:54] <colomon> no, I'm saying in p6, 9e99 is a very specific request to make a floating point number approximately equal to 9 * 10**99

[20:54] <colomon> nr: say 9 * 10**99

[20:54] *** snearch left
[20:54] <p6eval> rakudo 7ad6e6, niecza v24-20-g93138cc: OUTPUT«9000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000␤»

[20:54] <swarley> ah.

[20:54] <GlitchMr> nr: say 3.14 * 10**99

[20:54] <swarley> Alright, then disregard my previous thoughts

[20:54] <p6eval> niecza v24-20-g93138cc: OUTPUT«3.14E+99␤»

[20:54] <p6eval> ..rakudo 7ad6e6: OUTPUT«3140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000␤»

[20:54] <GlitchMr> nr: say 3.14 * 10**-99

[20:54] <p6eval> rakudo 7ad6e6: OUTPUT«3.14e-99␤»

[20:54] <p6eval> ..niecza v24-20-g93138cc: OUTPUT«3.1400000000000335E-99␤»

[20:54] *** snearch joined
[20:55] <colomon> rn: say (10**-99).WHAT

[20:55] <p6eval> rakudo 7ad6e6, niecza v24-20-g93138cc: OUTPUT«Num()␤»

[20:56] *** snearch left
[21:00] *** rindolf left
[21:01] *** not_gerd left
[21:03] *** rindolf joined
[21:06] <colomon> rn: (1..100).grep(*.is-prime)

[21:06] <p6eval> rakudo 7ad6e6, niecza v24-21-g4c8f264:  ( no output )

[21:06] <colomon> rn: say (1..100).grep(*.is-prime)

[21:06] <p6eval> rakudo 7ad6e6, niecza v24-21-g4c8f264: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97␤»

[21:07] <colomon> on my computer that doesn't work under Rakudo for some reason.

[21:07] <arnsholt> r: say "empty string is false" if not ""

[21:07] <p6eval> rakudo 7ad6e6: OUTPUT«empty string is false␤»

[21:08] <swarley> Where does nqp-jvm outline it's calling convention? if it does at all. I'm not quite sure as to the anatomy of the project.

[21:09] <swarley> A directory would suffice, but a file name would be splendid

[21:11] <jnthn> swarley: See CallSiteDescriptor.java, and in Ops.java look over arg, result, return and param related ops

[21:11] <dalek> rakudo/nom: d76f9b2 | (Solomon Foster)++ | src/core/Cool.pm:

[21:11] <dalek> rakudo/nom: Add Cool.set and Cool.bag.

[21:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d76f9b2547

[21:11] *** bluescreen10 joined
[21:13] <swarley> Thank you very much, jnthn

[21:13] *** snearch joined
[21:15] *** snearch left
[21:16] *** snearch joined
[21:16] *** stevan_ joined
[21:18] *** snearch left
[21:19] *** jeffreykegler left
[21:26] *** tokomer left
[21:27] *** zby_home_ left
[21:29] *** jeffreykegler joined
[21:37] *** swarley| joined
[21:44] *** rindolf left
[21:47] *** jeffreykegler left
[21:51] <arnsholt> jnthn++ # Grammar::Tracer

[22:02] <colomon> indeed, jnthn++ # Grammar::Tracer helped me out again this week.

[22:02] <timotimo> i wish it could be used to trace rakudos internal parsing process, though :(

[22:03] <arnsholt> Hehe. That'd be super-mega-awesome, yeah

[22:03] <arnsholt> I'm in user-space though, so I can trace my stuff

[22:03] <dalek> nqp: bf54542 | jnthn++ | src/6model/ (2 files):

[22:03] <dalek> nqp: Add associative REPR API.

[22:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bf5454230e

[22:03] <dalek> nqp: 08684cd | jnthn++ | src/ (5 files):

[22:03] <dalek> nqp: Refactor elems.

[22:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/08684cde09

[22:03] <dalek> nqp: 4436142 | jnthn++ | src/ (2 files):

[22:04] <dalek> nqp: Implement associative_delegate.

[22:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/44361425d0

[22:04] <dalek> nqp: 02e8737 | jnthn++ | src/core/NQPCapture.pm:

[22:04] <dalek> nqp: Switch NQPCapture to use associative_delegate.

[22:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/02e8737661

[22:04] <dalek> nqp: 8654841 | jnthn++ | src/QAST/ (2 files):

[22:04] <dalek> nqp: Switch QAST over to associative_delegate.

[22:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/865484191d

[22:10] <dalek> rakudo/nom: a3869a0 | jnthn++ | / (2 files):

[22:10] <dalek> rakudo/nom: Update to build on latest NQP.

[22:10] <dalek> rakudo/nom: 

[22:10] <dalek> rakudo/nom: REPR API additions force a fresh sixmodelobject.h, so also needed to

[22:10] <dalek> rakudo/nom: do an NQP_REVISION bump.

[22:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a3869a037b

[22:13] <dalek> nqp-jvm-prep: bc0b78c | jnthn++ | src/org/perl6/nqp/sixmodel/SerializationReader.java:

[22:13] <dalek> nqp-jvm-prep: Bump serialization version recognized.

[22:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/bc0b78cbae

[22:13] <dalek> nqp-jvm-prep: b410c24 | jnthn++ | nqp-src/nqp-mo.pm:

[22:13] <dalek> nqp-jvm-prep: Get NQPAttribute additions.

[22:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b410c247ce

[22:13] <dalek> nqp-jvm-prep: 4204e07 | jnthn++ | nqp-src/NQPCORE.setting:

[22:13] <dalek> nqp-jvm-prep: Add NQPCapture to the setting.

[22:13] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/4204e07e0d

[22:13] <jnthn> timotimo: There --rxtrace switch to Rakudo, though it maybe ain't the most reliable thing...

[22:14] <timotimo> ooooh

[22:14] <jnthn> Nor is it pretty and colorful

[22:14] <jnthn> oh hmm

[22:15] <jnthn> Seems it gets lost at language switch or so.

[22:17] *** kaare_ left
[22:18] <pmurias> jnthn: ping

[22:19] <pmurias> the while op takes it 1..* params as the body?

[22:19] <jnthn> pmurias: No

[22:19] <jnthn> pmurias: The first param is the body as such

[22:19] <jnthn> Well, given the zeroeth is the condition :)

[22:20] <jnthn> The extra one is the "increment" or whatever

[22:20] <jnthn> Consider

[22:20] <jnthn> r: loop (my $i = 0; $i < 10; $i++) { next if $i % 2; say $i }

[22:20] <p6eval> rakudo d76f9b: OUTPUT«0␤2␤4␤6␤8␤»

[22:20] <jnthn> We need to always do the $i++ even if we next.

[22:20] <jnthn> The extra child would contain the $i++ here

[22:21] <jnthn> So that it ends up outside of the region covered by the next handler.

[22:21] <jnthn> (redo also...)

[22:22] <pmurias> aha

[22:23] *** PacoAir left
[22:23] *** PacoAir joined
[22:25] <pmurias> jnthn: repeat_while also takes that?

[22:25] <pmurias> or only while?

[22:26] <jnthn> pmurias: All of them take it

[22:26] <jnthn> pmurias: On the Parrot and JVM implementations all 4 forms are generated the same way.

[22:26] <jnthn> They have a lot in common.

[22:27] <pmurias> in the js implementation too

[22:27] <jnthn> :)

[22:29] <pmurias> but is it possible to write Perl 6 which compiles to a 3 argument variant of something different from a while?

[22:29] *** erkan left
[22:30] <arnsholt> r: my constant x = 3; say x

[22:30] <p6eval> rakudo d76f9b: OUTPUT«3␤»

[22:32] <jnthn> pmurias: Not that I can think of, off hand.

[22:32] <jnthn> Hmm...the nqp-jvm Makefile got improved and now it's too clever for me to edit.

[22:33] * jnthn tries to figure out how his simple addition creates a circular dependency

[22:33] <pmurias> should perl6 have repeat loop?

[22:35] <pmurias> perl6: repeat {say 1} loop (;0;)

[22:35] <p6eval> niecza v24-21-g4c8f264: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/ZNrjhVGaw8 line 1:␤------> repeat {say 1}⏏ loop (;0;)␤␤Undeclared routine:␤      'repeat' used at line 1␤␤Parse failed␤␤»…

[22:35] <p6eval> ..rakudo d76f9b: OUTPUT«===SORRY!===␤Missing "while" or "until"␤at /tmp/TXtN4nMke2:1␤------> repeat {say 1} ⏏loop (;0;)␤    expecting any of:␤        postfix␤        infix or meta-infix␤        infix stopper␤        statement end␤        statement modi…

[22:36] <masak> evenin', #perl6

[22:39] <swarley> llol what is up with the eject button symbol there?

[22:39] *** not_gerd joined
[22:39] <jnthn> swarley: It tells you where teh parser ejected

[22:39] <swarley> Ah alright

[22:39] <jnthn> o/ masak

[22:39] <not_gerd> <-- the guy who made the Makefile unusable

[22:40] <jnthn> not_gerd: I think I figured out what I misunderstood :)

[22:41] <arnsholt> Is there an accepted idiom/way to create a top-level module that gathers up symbols from subordinate packages and re-exports them to the end user?

[22:41] <jnthn> Mostly, I trust others to know better than me when it comes to makefiles

[22:42] <arnsholt> I've become rather too adept at writing (GNU) Makefiles. I think it scares my colleagues at times =D

[22:42] <swarley> I write weird makefiles

[22:43] <not_gerd> arnsholt: same here

[22:43] <not_gerd> then jnthn had to spoil my fun by using nmake

[22:45] <arnsholt> Hehe

[22:45] <jnthn> I seem to have figured it out

[22:50] *** pupoque joined
[22:51] <arnsholt> Wow, it's almost as if ZMQ has gone out of its way to be unfriendly to interface with from HLLs

[22:54] <timotimo> :(

[22:56] <arnsholt> Just a 'sec

[22:56] <arnsholt> You'll be happy nonetheless =)

[22:58] <arnsholt> timotimo: https://github.com/arnsholt/Net-ZMQ

[22:58] <arnsholt> It's a start =)

[22:58] <timotimo> wait, what, it's already done?

[22:59] <timotimo> how are you so fast?

[22:59] <arnsholt> Well, there's lots more to be done

[22:59] <arnsholt> This was the easy bit

[22:59] <arnsholt> But bedtime now I'm afraid. More hacking tomorrow I hope =)

[23:00] <jnthn> arnsholt++

[23:00] <jnthn> Sleep well :)

[23:01] *** pupoque left
[23:02] <timotimo> good night!

[23:02] <dalek> nqp-jvm-prep: 1c90873 | jnthn++ | / (2 files):

[23:02] <dalek> nqp-jvm-prep: Add a mostly-uncommented QASTNodes.

[23:02] <dalek> nqp-jvm-prep: 

[23:02] <dalek> nqp-jvm-prep: The commented out bits fail to compile, but it seems there are only

[23:02] <dalek> nqp-jvm-prep: really two main reasons for that. This library is used by the QRegex

[23:02] <dalek> nqp-jvm-prep: library, though mostly for its declarations rather than functionality,

[23:02] <dalek> nqp-jvm-prep: so the commented out bits don't block progress to work on regex stuff.

[23:02] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1c90873afc

[23:07] <FROGGS> arnsholt: sleep well you must

[23:08] *** spider-mario left
[23:12] <FROGGS> is "[a|b]" an Regex( :rxtype<altseq> ) ?

[23:13] <pmurias> jnthn: do you think it would be possible to compile the regex NQP codes to non-regex nqp codes?

[23:13] <jnthn> FROGGS: In Perl 6 regex that's a seq

[23:13] <pmurias> so we could have an implementation independent rule engine? and how much speed would that cost?

[23:13] <FROGGS> k, thanks

[23:13] <pmurias> s/nqp codes/QAST nodes

[23:14] <FROGGS> jnthn: in nqp too?

[23:14] <jnthn> It may take a little effort to get the control flow to work.

[23:14] <jnthn> FROGGS: Yes, sorry, I was unclear; I meant the Perl 6 regex syntax.

[23:15] <jnthn> FROGGS: After saying it I also realized that [a|b] would be a weird charclass in P5 regex so it almost certainly wasn't what you meant :)

[23:15] <jnthn> FROGGS: Anyway, | is seq, || is altseq.

[23:15] <FROGGS> ahh cool, understand

[23:16] <jnthn> pmurias: I think control flow aside it's probably possible.

[23:16] <jnthn> pmurias: Especially after a few more bits of cleanup.

[23:16] <jnthn> pmurias: It's hard to guess at the speed impact.

[23:17] <jnthn> You can encode native types nicely enough in QAST so that bit ain't so bad.

[23:18] <jnthn> FROGGS: To clarify if you're wondering, | invokes the LTMer, || just tries things one after the other.

[23:20] <FROGGS> right

[23:21] <jnthn> pmurias: For JVM I think I'll just go straight down to bytecode, but I don't think what you're suggesting is crazy at first blush :)

[23:23] <dalek> perl6-most-wanted: 7e2175c | (Geoffrey Broadwell)++ | README.md:

[23:23] <dalek> perl6-most-wanted: Add link-heavy summary at top of main README, and improve some of the remaining text

[23:23] <dalek> perl6-most-wanted: review: https://github.com/japhb/perl6-most-wanted/commit/7e2175c7ff

[23:23] * pmurias had basic grammars working before the serialization refactor so it's a matter of unbitrotting and expanding ;)

[23:23] <pmurias> (on js)

[23:24] <dalek> rakudo-js: 3e714f7 | (Paweł Murias)++ | runtime.js:

[23:24] <dalek> rakudo-js: Convert arguments to numeric ops.

[23:24] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/3e714f73bf

[23:24] <dalek> rakudo-js: 643f944 | (Paweł Murias)++ | runtime.js:

[23:24] <dalek> rakudo-js: Fix conversion of numers to integers.

[23:24] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/643f944ef6

[23:24] <dalek> rakudo-js: 158e1a6 | (Paweł Murias)++ | / (2 files):

[23:24] <dalek> rakudo-js: Implement parts of qast_core.t

[23:24] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/158e1a621c

[23:24] <dalek> rakudo-js: 298575b | (Paweł Murias)++ | / (3 files):

[23:24] <dalek> rakudo-js: Pass qast_core.t

[23:24] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/298575bdb6

[23:25] <dalek> perl6-most-wanted: 90eb9cd | (Geoffrey Broadwell)++ | README.md:

[23:25] <dalek> perl6-most-wanted: Make it easier to see that first two links are separate in top level README

[23:25] <dalek> perl6-most-wanted: review: https://github.com/japhb/perl6-most-wanted/commit/90eb9cda4c

[23:25] *** PacoAir left
[23:28] *** uvtc joined
[23:33] <uvtc> Just a bit curious about the history here: it seems that, at some point, Parrot was considered to be probably the primary-ish platform for Perl 6 (though, I'm guessing it was assumed there would be others). If that's the case, what were the circumstances around it becoming a general-purpose VM (rather than the Rakudo VM)? Was it something that just gradually happened?

[23:34] <pmurias> is was supposed to be a common VM for dynamic languages

[23:34] <uvtc> If this is all just water under the bridge, I won't push for any sort of answer. But it strikes me as odd that Parrot would become *not* the primary VM for Rakudo, and I was curious about the circumstances surrounding the decision (if there was one).

[23:35] <pmurias> isn't Parrot older than Rakudo?

[23:35] <timotimo> arnsholt: you made the code but no tests? :o

[23:35] <uvtc> I don't know the history here.

[23:36] <colomon> Parrot being a general purpose VM has been a goal for about a decade.

[23:36] <timotimo> i thought that was totally unaccaptable in perl land

[23:36] <jnthn> The idea that Parrot would be a VM for multiple languages pre-dates Rakudo for sure.

[23:36] <jnthn> timotimo: I think arnsholt++ is just getting started so far ;-)

[23:37] <pmurias> the name refers to a joke about merging perl and python

[23:37] <uvtc> Did Parrot pre-date the throwing of the mug and Perl 6?

[23:37] <colomon> timotimo: Perl-land demands tests, but doesn't particularly care whether they are written first, last, or in-between.

[23:37] <colomon> uvtc: no

[23:38] <uvtc> pmurias: Yes, I remember that joke.

[23:38] <jnthn> OK, sleep time here...'night all o/

[23:38] <uvtc> pmurias: the faux book cover too.

[23:38] <colomon> \o

[23:40] <swarley|> I'm more curious as to when parrot-rakudo relations began to become strained 

[23:41] <not_gerd> swarley|: did you read chromatic's latest blog posting?

[23:41] <not_gerd> he details the Perl6-on-Parrot story as he remembers it

[23:41] <uvtc> I'm guessing that there was some balance of priorities (be a general-purpose VM (x%) and be Rakudo's VM (y%). I'm curious if those percentages changed due to some decision, or if it was a gradual thing.

[23:43] <dalek> perl6-most-wanted: c3468c9 | (Geoffrey Broadwell)++ | data-sources/README-sources.md:

[23:43] <dalek> perl6-most-wanted: Linkify data-sources README

[23:43] <dalek> perl6-most-wanted: review: https://github.com/japhb/perl6-most-wanted/commit/c3468c9a51

[23:44] <skids> .oO(Strange the sense of accomplishment one gets from moving lots of stuff that will melt in a few weeks 8 feet sideways)

[23:45] <colomon> swarley: things were definitely somewhat strained at YAPC::NA 2011.

[23:45] <swarley|> Hm

[23:46] <uvtc> skids: because it's fairly light, you get the feeling you're moving huge amounts of *stuff*! Grrr!

[23:49] <uvtc> Ok. Right. Perl 6 was being discussed/planned, and Parrot 0.1.1 was released, it's docs/intro.pod saying:

[23:49] <uvtc> "Perl 6 plans to separate out the design of the compiler and the interpreter. This is why we've come up with a subproject, which we've called Parrot, which has a certain, limited amount of independence from Perl 6. Parrot is destined to be the Perl 6 Virtual Machine, the software CPU on which we will run Perl 6 bytecode. We're working on Parrot before we work on the Perl 6 compiler because it's much easier to write a compiler once you've got a t

[23:49] <uvtc> arget to compile to!"

[23:50] <uvtc> I don't know when 0.1.1 was released...

[23:50] <uvtc> So, at that early point it seemed to be wholly committed to Perl 6.

[23:57] <uvtc> Ok, 0.2.3 seems to be the last version where that text was in the intro doc. The goals seem to have changed as of v0.3.0.

[23:57] <uvtc> I'm curious what happened between Parrot 0.2.3 and 0.3.0.

[23:59] *** lue left
