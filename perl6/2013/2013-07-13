[00:32] *** benabik joined
[00:41] *** jaldhar_ joined
[00:44] *** abnorman left
[00:47] *** fridim_ left
[00:57] *** jaldhar_ left
[01:00] *** jaldhar_ joined
[01:02] *** bruges joined
[01:11] *** ssutch left
[01:33] <raiph> jnthn++ # O(MG)

[01:37] *** abnorman joined
[01:48] *** FROGGS_ joined
[01:51] *** FROGGS left
[02:07] *** crab2313 joined
[02:29] *** abnorman left
[02:36] *** konundra left
[02:56] *** konundra joined
[03:05] *** jaldhar_ left
[03:17] <sorear> good * #perl6

[03:17] <diakopter> sorear: hi

[03:17] <sorear> so which one of you had the bright idea of trying to load the JVM interop engine at SETTING INIT TIME?

[03:18] * diakopter doesn't know enough to cringe or giggle

[03:19] <sorear> diakopter: I haven't completely read the backlog yet, but it looks like someone thought rakudo didn't load slowly enough, so they unconditionally initialized a major subsystem in the setting init

[03:19] *** jaldhar_ joined
[03:19] <sorear> s/major/expensive/

[03:19] <diakopter> oh.

[03:19] <sorear> also it leaks memory when initialized, which is probably breaking the eval server

[03:20] <sorear> and the testsuite

[03:20] * sorear goes into full backlog mode

[03:52] *** preflex_ joined
[03:52] *** ChanServ sets mode: +v preflex_

[03:53] *** preflex left
[03:53] *** preflex_ is now known as preflex

[04:04] *** crab2313 is now known as i_am_old_w_

[04:17] <sorear> done, anyway

[04:18] <sorear> to fix the jvm problems we need to modify Threading.pm so that it doesn't try to instantiate a full scheduler immediately

[04:18] <sorear> in every process

[04:18] <sorear> we could probably add initialized flags and do it that way

[04:19] <sorear> but a large part of me is going "why are you making the setting 200 lines bigger?  use a module!"

[04:35] <cognominal> sorear, what do you think of  https://gist.github.com/cognominal/5989429

[04:36] *** i_am_old_w_ left
[04:37] <sorear> I'm having trouble parsing it

[04:39] <cognominal> sorear: what do you have trouble with?

[04:39] <sorear> that's a really dubious grammar

[04:39] <sorear> here's why it doesn't work:

[04:40] <sorear> C<aa>

[04:40] <sorear> you start to parse in, you now are looking at 'aa>' and try to parse <chunk>+?

[04:40] <sorear> start by calling chunk zero times.  '>' can't match

[04:41] <sorear> now try one time.  it gobbles aa>.  '>' can't match ''

[04:41] <sorear> so try two times.  <chunk> itself fails.

[04:41] <sorear> so the whole <chunk>+? fails.

[04:41] <sorear> +? is almost never what anyone wants

[04:43] <sorear> jnthn wrote a regex single stepper for parrakudo, you don't have to ask me to single-step your regexes :)

[04:43] <cognominal> when you try one time it should gobble 'aa', not 'aa>'

[04:44] <sorear> that requires read-your-mind functionality, which is not enabled in this version of perl 6

[04:45] <cognominal> I will try jnthn's stepper

[04:45] <sorear> [ <!before 'C<' > . ]+ treats '>' as any other character

[04:46] <cognominal> ho, now I see

[04:46] <cognominal> thx

[04:46] <sorear> .oO( RYM not supported in free version of P6 )

[04:47] <cognominal> that's a big problem :(    :)

[04:48] <cognominal> I will learn to use jnthn's stepper 

[04:48] <sorear> that was sort of a joke

[04:49] <sorear> I'm not sure perl6-debug has seen much real use yet

[04:52] <lue> RYM?

[04:52] <cognominal> jokes often offers big wisdom. With the Perl  power come many way to go astray. I suspect that's why many people avoid Perl. I know better because with a simpler language you end up with bigger code. I usually trust more Perl implementers code than mine.

[04:52] <cognominal> RYM is Read Your Mind

[04:52] <lue> figures I'd guess it the instant I ask :)

[04:55] * sorear sadfaces

[04:55] <sorear> someone did something to cause an O(0.5s) regression in jakudo startup time

[04:56] * diakopter wonders what jakudo could mean in Japanese

[04:59] <sorear> nevermind, forgot I had a cpu-hungry background process

[04:59] <sorear> it's back to hugging 6.000s like it should be

[05:07] *** crab2313 joined
[05:08] *** crab2313 left
[05:25] *** benabik left
[05:26] *** benabik joined
[05:27] *** mtk joined
[05:36] *** SamuraiJack joined
[05:38] *** crab2313 joined
[05:46] *** kaare__ joined
[05:58] *** itz joined
[06:00] *** itz_ left
[06:02] *** cooper joined
[06:02] *** cooper left
[06:02] *** cooper joined
[06:08] <PerlJam> anyone awake?

[06:08] <Teratogen> yes

[06:09] <Teratogen> but probably not very useful =)

[06:11] <PerlJam> I want to use classify, but modify the values en passant and I don't quite see how to do it.

[06:13] <PerlJam> i.e., if I have my @values = <+foo +bar -baz>, I'd like to colect those into two lists <foo bar> and <baz>.  

[06:14] <sorear> hmm

[06:15] <sorear> r: my @values = <+foo +bar -baz>; my %h; %h.push(@values.map: { .substr(0,1) => .substr(1) }); say %h.perl

[06:15] <camelia> rakudo 00cd34: OUTPUT¬´No such method 'substr' for invocant of type 'Any'‚ê§  in block  at /tmp/gtYXrEq2Mo:1‚ê§‚ê§¬ª

[06:16] <sorear> r: my @values = <+foo +bar -baz>; my %h; %h.push(@values.map: { $^a.substr(0,1) => $a.substr(1) }); say %h.perl

[06:16] <camelia> rakudo 00cd34: OUTPUT¬´("+" => ["foo", "bar"], "-" => "baz").hash‚ê§¬ª

[06:16] <PerlJam> oh, I can do it "manually".  I was wishing for a way to do it with classify

[06:17] <sorear> yes, it's possible to install a screw with a hammer

[06:17] <TimToady> sounds a bit XY to me too

[06:18] <PerlJam> Maybe so.

[06:19] <TimToady> have you tried modifying $_?

[06:20] <sorear> that probably shouldn't work, even if it does :)

[06:21] <sorear> r: my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { s/.//; $0 }).perl

[06:21] <camelia> rakudo 00cd34: OUTPUT¬´use of uninitialized value of type Any in string context  in block  at /tmp/PSGybg8EKJ:1‚ê§‚ê§use of uninitialized value of type Any in string context  in block  at /tmp/PSGybg8EKJ:1‚ê§‚ê§use of uninitialized value of type Any in string context  in block  at /tmp/PSGybg8EK‚Ä¶

[06:21] <sorear> r: my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { $_ = "foo"; "bar" }).perl

[06:21] <camelia> rakudo 00cd34: OUTPUT¬´("bar" => ["foo", "foo", "foo"]).hash‚ê§¬ª

[06:21] <PerlJam> huh

[06:22] <sorear> r: my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { substr($_,0,1,'') }).perl

[06:22] <camelia> rakudo 00cd34: OUTPUT¬´Too many positional parameters passed; got 4 but expected between 2 and 3‚ê§  in sub substr at src/gen/CORE.setting:2846‚ê§  in block  at /tmp/HW4zwvewGF:1‚ê§‚ê§¬ª

[06:22] <sorear> r: my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { substr-rw($_,0,1,'') }).perl

[06:22] <camelia> rakudo 00cd34: OUTPUT¬´Too many positional parameters passed; got 4 but expected between 1 and 3‚ê§  in sub substr-rw at src/gen/CORE.setting:5452‚ê§  in block  at /tmp/pp3cpGSR2w:1‚ê§‚ê§¬ª

[06:22] <sorear> isn't there supposed to be a 4-arg verison of substr?

[06:22] <sorear> n: my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { substr($_,0,1,'') }).perl

[06:22] <camelia> niecza v24-86-g39ab531: OUTPUT¬´{"b" => ["bar", "baz"], "f" => ["foo"]}‚ê§¬ª

[06:23] <sorear> it works in niecza.  sort of :D

[06:23] <sorear> n: sub what(\l, \r) { my $o = l; l = r; $o };  my @values = <+foo +bar -baz>; say @values.classify(<-> $_ { what(substr-rw($_,0,1),'') }).perl

[06:23] <camelia> niecza v24-86-g39ab531: OUTPUT¬´{"+" => ["foo", "bar"], "-" => ["baz"]}‚ê§¬ª

[06:24] <sorear> what() should probably have a name and become a builtin

[06:24] <sorear> if it's not already

[06:26] <sorear> n: my $str = 'foo'; say substr($foo,0,1,'')

[06:26] <camelia> niecza v24-86-g39ab531: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Variable $foo is not predeclared at /tmp/4Si2k_5hkG line 1:‚ê§------> [32mmy $str = 'foo'; say substr([33m‚èè[31m$foo,0,1,'')[0m‚ê§‚ê§Potential difficulties:‚ê§  $str is declared but not used at /tmp/4Si2k_5hkG line 1:‚ê§------> [3‚Ä¶

[06:26] <sorear> n: my $str = 'foo'; say substr($str,0,1,''); say $str;

[06:26] <camelia> niecza v24-86-g39ab531: OUTPUT¬´o‚ê§oo‚ê§¬ª

[06:26] <sorear> clearly wrong

[06:27] *** daniel-s_ left
[06:27] <TimToady> nr: my @values = <+foo +bar -baz>; say @values.classify({ s/(<[+\-]>)//; ~$0 }).perl

[06:27] <camelia> rakudo 00cd34: OUTPUT¬´use of uninitialized value of type Any in string context  in block  at /tmp/etehveaOuB:1‚ê§‚ê§use of uninitialized value of type Any in string context  in block  at /tmp/etehveaOuB:1‚ê§‚ê§use of uninitialized value of type Any in string context  in block  at /tmp/etehveaOu‚Ä¶

[06:27] <camelia> ..niecza v24-86-g39ab531: OUTPUT¬´{"+" => ["foo", "bar"], "-" => ["baz"]}‚ê§¬ª

[06:28] <sorear> TimToady: I tried that first :[

[06:28] <TimToady> it works in niecza++ :)

[06:28] <PerlJam> yeah, I tried that already too  (rakudo--)

[06:29] <moritz> \o

[06:30] <TimToady> o/

[06:31] <sorear> o/ moritz

[06:32] *** crab2313 left
[06:50] *** raiph left
[07:04] *** daniel-s_ joined
[07:10] *** PacoAir joined
[07:12] *** Rotwang1 joined
[07:18] *** PacoAir left
[07:20] *** PacoAir joined
[07:20] *** FROGGS_ left
[07:22] *** FROGGS joined
[07:30] *** Ayiko joined
[07:31] *** drbean joined
[07:46] <dalek> nqp: c154ef8 | sorear++ | src/vm/jvm/runtime/org/perl6/nqp/ (5 files):

[07:46] <dalek> nqp: Remove a bunch of FOR_STAGE0 stuff.

[07:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c154ef8da2

[07:46] <sorear> I have two failing sprintf tests.  I hope that's expected

[07:47] <FROGGS> sorear: I think so, yes

[07:58] <sorear> .tell jnthn Your problems are because you're initializing the JVM interop module in the setting blocks, which means it initializes on every run.  Because the JVM interop leaks memory (this can be fixed) and is slow to start (this probably can't), I'd really rather we didn't start it every time the setting loads

[07:58] <yoleaux> sorear: I'll pass your message to jnthn.

[07:59] <sorear> .tell jnthn We should either have the threads stuff do initialize-on-first-use, or evict it to a module which is loaded only when needed

[07:59] <yoleaux> sorear: I'll pass your message to jnthn.

[07:59] <sorear> sleep&

[08:00] *** PacoAir left
[08:09] *** mtk left
[08:09] *** SamuraiJack left
[08:12] *** mtk joined
[08:16] *** Rotwang1 left
[08:21] <moritz> I'll migrate the IRC logs to a new DB schema in a few minutes, and do a major software upgrade

[08:21] <moritz> there'll be a short downtime

[08:21] *** daniel-s_ left
[08:21] *** dmol1 left
[08:22] *** spider-mario joined
[08:23] *** domidumont joined
[08:23] *** _ilbot left
[08:26] *** dmol joined
[08:27] *** SamuraiJack joined
[08:29] *** mtk left
[08:33] *** mtk joined
[08:39] *** _ilbot joined
[08:39] *** _ilbot left
[08:42] *** _ilbot joined
[08:43] <moritz> logger is back.

[08:46] *** SamuraiJack left
[08:47] *** dmol left
[08:50] *** domidumont left
[08:50] *** domidumont joined
[08:54] *** estrabd joined
[09:07] *** berekuk joined
[09:09] <moritz> d) and is slow to start (this probably can't),  I'd really rather we didn't start it every time the setting  loads

[09:09] <moritz> 09:58 <+yoleaux> sorear: I'll pass your message to jnthn.

[09:09] <moritz> sorry, Ronja discovered copy&paste :-)

[09:14] <nwc10> Guten tag, Ronja

[09:14] <nwc10> kanst du lesen?

[09:14] <nwc10> :-)

[09:15] <moritz> she can't, being 2.5 years old :-)

[09:16] <nwc10> yes, I kind of guessed that. E is almost 4 and doesn't even reliably know all letters yet

[09:16] <nwc10> one of E's friends *had* cracked reading by about 2.75, but she is a bit special

[09:17] <moritz> wow, that's scary

[09:17] <moritz> when I was young it was an accomplishment to read when you came into school

[09:17] <nwc10> not sure whether it was more than just simple words

[09:17] <moritz> still scary

[09:17] <nwc10> but still, yes, scary

[09:21] <moritz> anyway, the 'today' page from the IRC logs now has a button which loads new lines via ajax

[09:22] <nwc10> nice

[09:22] <moritz> if anybody wants to improve the UI (nicer layout, display a spinning wheel, whatever), that would be great

[09:22] <moritz> I'm not nearly as good with UI as I'd like to be :-/

[09:24] <moritz> (but it has worked in the past a couple of times that I came up with something useful but really ugly, and somebody else contributed a nice design; happend with the IRC logs, perl6.org, the 'features' matrix)

[09:44] *** pmurias joined
[09:55] *** dmol joined
[09:59] *** berekuk left
[10:05] *** berekuk joined
[10:10] *** berekuk left
[10:14] *** PacoAir joined
[10:15] *** mstefanko left
[10:19] <dalek> nqp: f888397 | (Pawel Murias)++ | t/nqp/59-nqpop.t:

[10:19] <dalek> nqp: Test nqp::istrue on lists.

[10:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f888397257

[10:19] <dalek> nqp: d1b71f3 | (Pawel Murias)++ | t/nqp/25-class.t:

[10:19] <dalek> nqp: Expand test 25 to check that methods have access to surrounding nonstatic lexicals.

[10:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d1b71f35db

[10:23] *** mstefanko joined
[10:33] <jnthn> .tell sorear well, how was I to know the interop engine was too inefficient to bind a few types at startup :/

[10:33] <yoleaux> 07:58Z <sorear> jnthn: Your problems are because you're initializing the JVM interop module in the setting blocks, which means it initializes on every run.  Because the JVM interop leaks memory (this can be fixed) and is slow to start (this probably can't), I'd really rather we didn't start it every time the setting loads

[10:33] <yoleaux> jnthn: I'll pass your message to sorear.

[10:33] <yoleaux> 07:59Z <sorear> jnthn: We should either have the threads stuff do initialize-on-first-use, or evict it to a module which is loaded only when needed

[10:37] <dalek> rakudo/nom: 5cab663 | jonathan++ | src/vm/jvm/core/Threading.pm:

[10:37] <dalek> rakudo/nom: Delay initialization of interop until later.

[10:37] <dalek> rakudo/nom: 

[10:37] <dalek> rakudo/nom: It doesn't take well to being initialized once per spectest run in

[10:37] <dalek> rakudo/nom: the eval server due to a memory leak. This may introduce a race

[10:37] <dalek> rakudo/nom: condition, but it's better than hosed spectests.

[10:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5cab6634dd

[10:37] <jnthn> .tell sorear I've done initialize on first use, hopefully it helps.

[10:37] <yoleaux> jnthn: I'll pass your message to sorear.

[10:38] <jnthn> &

[10:51] <dalek> rakudo-js: dd354d7 | (Pawel Murias)++ | / (4 files):

[10:51] <dalek> rakudo-js: Implement setinvocationspec.

[10:51] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/dd354d71ee

[10:51] <dalek> rakudo-js: 2b4ac4d | (Pawel Murias)++ | src/QAST/Compiler/JavaScript.nqp:

[10:51] <dalek> rakudo-js: Fix typo in comment.

[10:51] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/2b4ac4dae2

[10:51] <dalek> rakudo-js: 7c0b2f8 | (Pawel Murias)++ | / (3 files):

[10:51] <dalek> rakudo-js: Update code refs once the outer lexpad for them is ready.

[10:51] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/7c0b2f84d1

[10:51] <dalek> rakudo-js: 33e6d00 | (Pawel Murias)++ | runtime.js:

[10:51] <dalek> rakudo-js: Empty lists boolify to false and others to true.

[10:51] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/33e6d0059f

[10:52] <pmurias> jnthn: should I merge fix-set-invocation-spec?

[10:54] *** berekuk joined
[12:02] *** daniel-s_ joined
[12:03] *** spider-mario left
[12:06] *** spider-mario joined
[12:19] <timotimo> it's pretty good that you're contributing all those tests :)

[12:40] *** Rotwang1 joined
[12:41] *** ztt joined
[12:57] *** ztt left
[12:57] *** berekuk left
[13:04] *** domidumont left
[13:14] *** frdmn left
[13:15] *** frdmn joined
[13:18] *** berekuk joined
[13:32] <timotimo> can i use niecza as a base to figuring out how nodal hyper should work?

[13:35] <sorear> good * #pelr6

[13:35] <yoleaux> 10:33Z <jnthn> sorear: well, how was I to know the interop engine was too inefficient to bind a few types at startup :/

[13:35] <yoleaux> 10:37Z <jnthn> sorear: I've done initialize on first use, hopefully it helps.

[13:41] <timotimo> tadzik: in your comment, do you mean "why .Str.path rather than .path" or "why not IO.path.new(...) instead of ...Str.path"?

[13:42] <tadzik> the latter

[13:42] <tadzik> well, not even .new

[13:42] <tadzik> just adding .path seems to work

[13:43] <timotimo> i think it was because Cool didn't have a .path method that worked i believe

[13:43] <timotimo> i fixed that some time ago in rakudo

[13:44] <timotimo> er, wait, that explains the former, not the latter

[13:44] <timotimo> i think i thought it was prettier to have $thing.path rather than IO.path($thing)

[13:45] <tadzik> I mean, now panda uses IO.copy

[13:45] <tadzik> in your path it's IO.str.copy

[13:45] <tadzik> * patch

[13:45] <tadzik> why not IO.path.copy?

[13:45] <timotimo> oh? hold on

[13:45] <tadzik> I feel a bit confused about Str.copy being file copying, frankly

[13:46] <timotimo> hold on, i don't do that

[13:46] <tadzik> hmm

[13:46] <timotimo> isn't .path a constructor to create paths?

[13:46] <tadzik> I think so

[13:46] <timotimo> r: "foo/bar".path.perl.say

[13:46] <camelia> rakudo 5cab66: OUTPUT¬´IO::Path.new(path => "foo/bar")‚ê§¬ª

[13:46] <tadzik> yep

[13:47] <tadzik> oh, wait

[13:47] <tadzik> I'm confused again :)

[13:47] <tadzik> .Str.path

[13:47] <timotimo> well, i think .Str.path can be replaced with .path in all those places?

[13:47] <timotimo> except, wasn't there some strange Find::Result class?

[13:47] <tadzik> ...I'm confused again

[13:47] <tadzik> Find::Result is obsolete now that we have proper Path objects

[13:47] <tadzik> I'll remove it and get back to you

[13:47] <timotimo> i think the reason behind making the .Str was because Find::Result had a "path" method that returned a string

[13:48] <tadzik> yeah

[13:48] <timotimo> so i had to use the .Str method instead and turn the result fo that into an actual path

[13:48] <tadzik> I see

[13:48] <tadzik> yeah, that'll explain it

[13:48] <timotimo> after removing Find::Result, you can throw away my pull request and just replace .IO.copy with .path.copy globally or something

[13:53] <timotimo> so, if i see that correctly, the only spot where "is nodal" really changes anything is for unary pre- or postfix things, like .[] or .{}

[13:54] *** dmol left
[13:59] *** jlaire joined
[13:59] <timotimo> turns out even the "is nodal" marker trait isn't declared yet

[13:59] *** dmol joined
[14:00] <tadzik> wow, File::Find becomes so much simplier with IO::Path

[14:00] <tadzik> everything Just Works

[14:00] <tadzik> labster++

[14:00] <timotimo> \o/

[14:01] <sorear> o/

[14:02] <tadzik> any idea how do I make submodules point to the latest revision, The Right Way?

[14:02] <timotimo> cd submodule && git fetch && git checkout origin/master && cd .. && git add submodule   -   i *think*

[14:03] <rom1504> no not add submodule, commit

[14:03] <tadzik> something happened :)

[14:03] <timotimo> ah, o

[14:03] <timotimo> thanks rom1504 

[14:04] <rom1504> oh I thought this was #git :D

[14:05] <tadzik> :D

[14:06] *** birdwindupbird joined
[14:06] *** crab2313_ joined
[14:07] * timotimo is going to test his very first, probably wrong, prototype for "is nodal" unary hypers

[14:13] <timotimo> huh.

[14:16] * timotimo typo'd "nodal" to "nodl" and wondered why there were exceptions >_<

[14:18] *** crab2313_ left
[14:23] <timotimo> apparently it's not enough or actually wrong to put "is nodal" on the proto method :|

[14:26] *** Rotwang1 left
[14:28] <timotimo> huh!

[14:29] <timotimo> it's parsing, then World gets called to throw a typed exception and then it bombs

[14:30] *** ecocode joined
[14:45] *** Rotwang1 joined
[14:47] <dalek> panda: aa8e228 | tadzik++ | ext/File__Tools:

[14:47] <dalek> panda: Bump File::Tools version

[14:47] <dalek> panda: review: https://github.com/tadzik/panda/commit/aa8e2283c8

[14:47] <dalek> panda: 7b2d7b2 | tadzik++ | / (5 files):

[14:47] <dalek> panda: Chase File::Find changes and IO::Handle.copy deprecations

[14:47] <dalek> panda: review: https://github.com/tadzik/panda/commit/7b2d7b2afb

[14:47] <tadzik> I suppose I broke All The Things on the way

[14:48] <tadzik> after a release of 2013.07 I'm going to tag panda with 2013.07 as well, and advice people to keep the two in sync

[14:50] <tadzik> <3 'rakudobrew update all'

[14:52] *** raiph joined
[14:55] *** ecocode left
[15:03] *** konundra left
[15:05] <pmurias> tadzik: we have a rakudobrew?

[15:06] <tadzik> pmurias: yeah, sort of :)

[15:06] <tadzik> https://github.com/tadzik/rakudobrew

[15:06] <pmurias> tadzik: what would be super awesome would be a way to build (and test) rakudo on a specified nqp branch 

[15:07] <tadzik> if you could add rakudo-js to it, that'd be great :)

[15:07] <tadzik> pmurias: as noted in the readme, the only requests I accept are pull requests :P

[15:07] <pmurias> there's only nqp-js at this point, rakudo-js is still vapourware

[15:07] <tadzik> I see

[15:07] <tadzik> well, I know, but that'd still be cool :)

[15:08] <tadzik> the moar the merrier

[15:09] *** mst joined
[15:12] *** rindolf joined
[15:22] *** domidumont joined
[15:28] <moritz> .oO( moarvm the merriervm )

[15:28] <timotimo> now i know why my "is modal" stuff doesn't end up in the hyperop

[15:29] <timotimo> because making the hyperop apparently creates a block for that?

[15:29] <huf> that v looks like it feels roman and wants to be a u

[15:29] <timotimo> oh, actually ... it's a sub from further above apparently? METAOP_HYPER_CALL thet is used for >>.[], that would certainly make sense and explain things

[15:30] *** FROGGS left
[15:30] <timotimo> no, that's wrong, hyper_call is >>(...) isn't it?

[15:34] *** FROGGS joined
[15:34] *** xilo joined
[15:36] <timotimo> i ... really don't know how to fix Mu::dispatch:<hyper> to pass on wether or not the op is nodal, because it depends on the object that gets passed in *later* >_<

[15:36] <timotimo> that can't be right

[15:37] <timotimo> yeah, how is that even supposed to work.

[15:37] <timotimo> ah, but of course

[15:38] <timotimo> (<a b>, <c d>>>[0] should look up wether or not [] is nodal in relation to the object that's to the left of the >>, so (...)

[15:38] <timotimo> and *that* can certainly work

[15:41] <timotimo> but if the logic for that is in dispatch:<hyper> only, that can't be enough; otherwise if there's a hypothetical blorp method that is not nodal in List, but it is nodal in Fish, it would have to descend into a List and then not-iterate over Fish (which is, incidentally, Iterable)

[15:48] *** rindolf left
[15:51] <TimToady> I think we can safely assume that the topmost method represents all of them in this regard, and if you're duck-typing harder than that, it's just erroneous

[15:53] <TimToady> otoh, if the algorithm itself is recursively hyper, it can make the decision again, I suppose

[15:53] *** Rotwang1 left
[15:53] * TimToady doesn't really have enough caffeine in him yet to think...

[16:00] *** berekuk left
[16:02] *** rindolf joined
[16:03] *** SamuraiJack joined
[16:08] *** Rotwang1 joined
[16:21] *** Rotwang1 left
[16:22] <timotimo> early prototype ready to get tested

[16:22] <timotimo> only need to come up with a whole bunch of tests

[16:23] <timotimo> what other operations are supposed to be nodal?

[16:23] <timotimo> what about something like .elems?

[16:24] <TimToady> yes, anything that presumes a structure that would otherwise be recursed into

[16:25] <TimToady> .elems on leaves would be rather uninteresting

[16:25] <timotimo> i seem to still be doing "it" wrong

[16:25] <TimToady> just as subscripting on leaves tends to be rather too interesting :)

[16:25] *** lelf joined
[16:26] <timotimo> should the "is nodal" be placed on the proto method or on all candidates or on both?

[16:26] <TimToady> generally the proto would be the &foo that gets passed in to the higher-order function, I'd think

[16:27] <TimToady> arguably any trait on the proto maybe oughta be reflected in the multis though

[16:28] <timotimo> okay; but that's what i have and i'm not getting IS_NODAL here; could it be because i'm checking in the method dispatch:<hyper> of the Mu class? and it says Mu \SELF: ...?

[16:28] <TimToady> dunno, I've never actually looked at how rakudo does HOP

[16:28] <timotimo> OK

[16:29] <TimToady> it's possible it's assuming something for optimization that makes it harder in the general case...

[16:29] <TimToady> you'd need a rakudo expert for that, though

[16:30] * TimToady is just the chief handwaver here...

[16:30] <pmurias> jnthn: ping?

[16:30] <timotimo> :)

[16:30] <timotimo> jnthn: ping from me, too (putting traits on protos vs multi candidates)

[16:33] *** domidumont left
[16:33] *** lelf left
[16:33] <pmurias> jnthn: should the class really be in the list of it's parents? as returned my .HOW.parents?

[16:33] *** lelf joined
[16:34] <moritz> r: say Int.^parents

[16:34] <camelia> rakudo 5cab66: OUTPUT¬´‚ê§¬ª

[16:34] <moritz> r: say Int.^parents.perl

[16:34] <camelia> rakudo 5cab66: OUTPUT¬´()‚ê§¬ª

[16:34] <moritz> huh.

[16:36] <pmurias> moritz: in nqp

[16:36] <dalek> ecosystem: 7e6294d | duff++ | META.list:

[16:36] <dalek> ecosystem: Add Questhub to META.list

[16:36] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/7e6294db86

[16:37] *** benabik left
[16:37] <pmurias> nqp: my $parent := NQPMu.HOW.parents(NQPMu)[0];say($parent.HOW.name($parent))

[16:37] <camelia> nqp: OUTPUT¬´NQPMu‚ê§¬ª

[16:37] <pmurias> moritz: ^^

[16:37] * [Coke] wonders if it is now safe to run the daily spectest run

[16:37] *** benabik joined
[16:39] <timotimo> for a custom-built operator that "is nodal", the hyper operator will not flatten nor descend

[16:39] * [Coke] hurls http://regexcrossword.com/

[16:40] <timotimo> oh that's nicer than the one that went around the net half a year ago

[16:40] *** konundra joined
[16:40] <moritz> pmurias: ok

[16:40] <moritz> maybe it's easier for mro calculation that way?

[16:41] * moritz has no idea

[16:41] <timotimo> In order to save your progress you have to login with Facebook.  <-  ... wat :(

[16:42] <moritz> github login would be the far more natural choice, IMHO

[16:42] <timotimo> javascript localstorage even more so.

[16:44] <timotimo> oh, i know why i'm failing. i'm calling Parcel's postcircumfix:<[ ]> all the time >_>

[16:44] <timotimo> and i neglected to mark that nodal

[16:44] <benabik> Hm.  A* down, .* .* across.  That _should_ match anything I fill out, including nothing, yes?  Or are the patterns all surrounded by ^$ ?

[16:44] <timotimo> but parcel calls self.flat; does that make sense?

[16:44] <timotimo> benabik: apparently they are surrounded by ^$

[16:46] <timotimo> is (<a b>, <c d>)>>[0] supposed to give <a c>? because if that's the case, then the flattening aspect of Parcel's [ ] must be given up; that's gotta explode somewhere else.

[16:47] <timotimo> er, actually ... no

[16:48] <timotimo> does nqp::p6listitems(obj.tree.eager) perhaps not work the way i think it does? does it flatten anyway?

[16:50] *** grondilu joined
[16:51] <moritz> the annoying part of regexcrosswords is that the punctuation is so small that I have trouble reading it when vertical

[16:51] <TimToady> perhaps the underlying problem is that things like .flat are defined operationally when in fact they should be define HOPishly

[16:52] <timotimo> "higher order programmingishly"?

[16:53] <TimToady> yes, so all you have to do is look at the 'is nodal' of the flattening meta-operator

[16:54] <TimToady> seems to me that flattening implies nodal

[16:54] <TimToady> and you don't even have to look at what it is you're flattening

[16:54] <pmurias> moritz: it's calculated from the mro, by the use of the identity function ;)

[16:55] <TimToady> but if the flat is buried operationally in the other thing, rather than being a higher-order function, you can't just look a the flat op, but have to distribute that info elsewhere

[16:55] <benabik> It would be better if the vertical clues were rotated 45¬∞ instead of being fully vertical

[16:56] <timotimo> benabik: my thoughts exactly

[16:58] * timotimo doesn't like running into walls like in the flat case now

[16:58] <timotimo> that doesn't seem quite like something i myself could try fixing just like that

[17:00] *** berekuk joined
[17:03] <TimToady> well, I wouldn't worry too much about Parcels, if you can get the other bits to work

[17:03] <timotimo> right. it seems like when i write [<a b c>, <d e f>]>>[0] it will see that a nodal hyper is needed and knows not to descend

[17:04] <timotimo> and then it calls [0] on a, b, c, d, e and f

[17:04] <TimToady> in the normal case, it probably doesn't matter whether the flat is hidden or not, since the thing that flat is applied to will also be nodal

[17:04] <dalek> perl6-examples: 32f57e6 | (Lucien Grondin)++ | parsers/Newick.pm:

[17:04] <dalek> perl6-examples: style

[17:04] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/32f57e695c

[17:04] <timotimo> i think it has to do with: $items := nqp::p6listitems(obj.flat.eager)  (which was there before), which i changed to depend on $descend and have $items := nqp::p6listitems(obj.eager) instead

[17:05] <timotimo> oh, eager flattens!

[17:06] <timotimo> and .tree.eager and .lol.eager all flatten, too

[17:06] <timotimo> oh

[17:06] <timotimo> [<...>, <...>] is actually syntax for something else isn't it >_<

[17:06] <timotimo> that was pretty darn dumb.

[17:07] <timotimo> r: say [<a b>.item, <c d>.item]

[17:07] <camelia> rakudo 5cab66: OUTPUT¬´a b c d‚ê§¬ª

[17:07] <timotimo> r: say [<a b>.item, <c d>.item].perl

[17:08] <camelia> rakudo 5cab66: OUTPUT¬´[$("a", "b"), $("c", "d")]‚ê§¬ª

[17:08] <timotimo> that's what it should have been

[17:10] <timotimo> yays, it actually works!

[17:12] *** zby_home_ joined
[17:13] *** census_ joined
[17:16] <timotimo> i may end up making a pullrequest this evening, maybe tomorrow.

[17:16] <timotimo> commute&

[17:17] <timotimo> oh, next tram in 30 minutes, guess i'll code some more

[17:19] *** birdwindupbird left
[17:24] <timotimo> TimToady: should the specs include a list of nodal methods and post/prefix operators? i'll probably build a bunch of spectests that ensure each of those that I (we) think should be nodal actually is

[17:25] *** mstefanko left
[17:30] *** ajr joined
[17:30] *** ajr is now known as Guest16306

[17:30] *** Guest16306 is now known as ajr_

[17:31] *** census_ left
[17:36] *** jaldhar_ left
[17:36] *** jaldhar_ joined
[17:49] <benabik> I find the crossword to be slightly easier to read after using the element inspector to set the clues to be non-bold monospace.

[17:52] <lelf> I find it to be a lot easier with pen & paper

[17:54] <lelf> ... maybe cause I dislike to tilt my head

[17:54] * benabik has been tilting his laptop.

[17:56] <lelf> but... but.. then you have to tilt your hands

[18:04] <timotimo> does it seem sensible to have a S03-operator/hyper-nodal.t?

[18:07] <dalek> nqp: 83e79a3 | (Pawel Murias)++ | t/nqp/71-setboolspec.t:

[18:07] <dalek> nqp: Add a test for setboolspec.

[18:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/83e79a3189

[18:07] <dalek> nqp: c39ed26 | (Pawel Murias)++ | t/nqp/ (2 files):

[18:07] <dalek> nqp: Test using the metamodel at runtime more. Expand test 65 and test 72 which tests using the metamodel for inspecting and applying roles at runtime.

[18:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c39ed26073

[18:09] *** lob joined
[18:09] *** lob is now known as dodolob

[18:10] <timotimo> hm. nodal things: elems, uniq... what about pick, roll? reverse? sort? values? keys? kv? pairs?

[18:10] <timotimo> that all seems to be nodal in some way

[18:11] <dalek> rakudo-js: 67218aa | (Pawel Murias)++ | / (7 files):

[18:11] <dalek> rakudo-js: Implement MODE_CALL_METHOD for setbootspec. nqp::rebless, fixed getting the method name, fixed mixing in roles and a couple of other small things.

[18:11] <dalek> rakudo-js: 

[18:11] <dalek> rakudo-js: All that to get QAST::Node.set_compile_time_value to works.

[18:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/67218aaf43

[18:15] <timotimo> .min and .max seem nodal, too

[18:15] <timotimo> and .shift and .pop, too :|

[18:16] <timotimo> i can't just go around and throw an "is nodal" on almost all of the methods of Any and List and Hash now can i?

[18:16] <timotimo> and also: how about derived classes? a user-derived class would then have to plop an is nodal to their reimplementation? maybe that is sensible to ask of them, though.

[18:21] <sorear> o/

[18:21] <timotimo> "as well as various methods that assume they are already working something Positional or Associative", that does sound like i can just go aronud slapping "is nodal" on everything and their dog

[18:22] <tadzik> I keep reading that as "is nadal", which in Polish means "is still"

[18:22] <tadzik> like "it's still not working :("

[18:22] <timotimo> hehe

[18:26] <TimToady> hang in there a sec

[18:28] * timotimo prepares for sage advice and wisdom about the nodality issue to trickle down from TimToady

[18:30] <dalek> specs: 948f48a | larry++ | S32-setting-library/Containers.pod:

[18:30] <dalek> specs: Don't use Nil to mean () anymore

[18:30] <dalek> specs: review: https://github.com/perl6/specs/commit/948f48a8eb

[18:30] <dalek> specs: 674a76b | larry++ | S03-operators.pod:

[18:30] <dalek> specs: clarify what is nodal

[18:30] <dalek> specs: review: https://github.com/perl6/specs/commit/674a76bb2a

[18:31] <timotimo> hum. okay.

[18:31] <timotimo> that clarifies things

[18:31] <TimToady> that's the general principle of the thing, which is more extensible than a list

[18:32] <TimToady> the first conjecture there would save a whole lot of 'is nodal' declarations

[18:32] <TimToady> but we can't just declare Any to be Iterable...

[18:34] <timotimo> that's true. but i'm not sure how to implement the check properly

[18:36] <timotimo> the conjecture about "methods declared in a class that is iterable"

[18:37] <TimToady> probably need jnthn++ to help with that; I see something like 'is Iterable' sets a dynamic variable in the compiler $*NODAL or some such, and maybe there's a 'use nodal' pragma that can also set it for the rest of the statements in a class

[18:37] <TimToady> unless we want .ACCEPTS declared in Any to also be nodal

[18:37] <benabik> `role Iterable is nodal` perhaps?

[18:38] <TimToady> can argue that both ways

[18:38] <TimToady> benabik: maybe, jnthn can probably suggest the best way to go about that

[18:38] <timotimo> and then i'll have to go through the classes and roles that "is nodal" and change all the methods in it?

[18:39] <benabik> (as opposed to just making Iterable magical in some way)

[18:39] <TimToady> maybe we just do the 'is Iterable' thing, and mark every method in Any as nodal

[18:39] <timotimo> "mark every method in any as nodal" by hand? ;)

[18:39] <timotimo> (by hand == with a macro)

[18:40] <TimToady> the point is not to put 'is nodal' all over

[18:40] <timotimo> right.

[18:41] <TimToady> you'd only need it in a class like Any that isn't Iterable

[18:41] <TimToady> and only the proto's location should matter

[18:41] <timotimo> textual location, yes?

[18:41] <timotimo> yeah, of course

[18:42] <TimToady> I'm assuming that protos are not autogenerated in a class higher than they ought to be here

[18:42] <TimToady> but that they're generated in the highest class that actually has a multi

[18:43] <TimToady> if that is a bad assumption, proto location won't work

[18:43] <TimToady> but I think protos should be generated no higher in the hierarchy than they need to be

[18:44] *** dodolob left
[18:45] *** preflex left
[18:46] <dalek> nqp: 48d3bde | (Solomon Foster)++ | src/vm/ (3 files):

[18:46] <dalek> nqp: Add pow_n operation.

[18:46] <dalek> nqp: 

[18:46] <dalek> nqp: This adds a test for raising 1.0 to a power, which allows 1.0 ** Inf to work.

[18:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/48d3bdef27

[18:46] <dalek> nqp: 260c3b5 | (Solomon Foster)++ | src/vm/ (3 files):

[18:46] <dalek> nqp: Add mod_n that fits NQP definition.

[18:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/260c3b5f00

[18:46] <dalek> nqp: b625b30 | (Solomon Foster)++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[18:46] <dalek> nqp: Make div_I conform to p6 spec for infix<div>.

[18:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b625b30fc0

[18:46] *** colomon joined
[18:46] <TimToady> r: class Foo { multi method bar() { say "!!!" } }; Any.bar

[18:46] <camelia> rakudo 5cab66: OUTPUT¬´No such method 'bar' for invocant of type 'Any'‚ê§  in block  at /tmp/RG5jktP1Q1:1‚ê§‚ê§¬ª

[18:46] <sorear> o/ colomon

[18:46] <TimToady> looks like the assumption is good

[18:46] <colomon> \o sorear!

[18:47] *** preflex joined
[18:47] *** ChanServ sets mode: +v preflex

[18:48] *** kaare_ joined
[18:51] *** kaare__ left
[18:52] <dalek> rakudo/nom: aa75b03 | (Solomon Foster)++ | src/core/Num.pm:

[18:52] <dalek> rakudo/nom: Remove JVM-specific hack.

[18:52] <dalek> rakudo/nom: 

[18:52] <dalek> rakudo/nom: Now that JVM's pow_n works correctly, the hack is no longer needed.

[18:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa75b0332e

[18:52] <dalek> rakudo/nom: e62b1a3 | (Solomon Foster)++ | src/core/Num.pm:

[18:52] <dalek> rakudo/nom: Remove JVM-specific hack.

[18:52] <dalek> rakudo/nom: 

[18:52] <dalek> rakudo/nom: Now that JVM's mod_n works correctly, the hack is no longer needed.

[18:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e62b1a3e2e

[18:52] <dalek> rakudo/nom: ee08521 | (Solomon Foster)++ | src/core/Real.pm:

[18:52] <dalek> rakudo/nom: Note spec issue on infix:<mod>.

[18:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ee085211dc

[18:53] <pmurias> sorear: where should the opcode be documented?

[18:54] <dalek> roast: 705a673 | (Solomon Foster)++ | S03-operators/arith.t:

[18:54] <dalek> roast: Unfudge for rakudo.jvm.

[18:54] <dalek> roast: review: https://github.com/perl6/roast/commit/705a673e27

[18:56] <sorear> pmurias: if it needs special documentation, make a pod or markdown file in docs/. otherwise, we don't really have a place for general opcode docs, you should start one.

[18:57] <sorear> pmurias: note: I have no idea what opcode you're talking about.

[18:59] <pmurias> sorry, should have said 'a opcode'

[19:00] *** preflex left
[19:00] <pmurias> I'm thinking of documenting them in docs/qast.markdown

[19:01] <pmurias> what tool should I use for previewing markdown?

[19:01] <tadzik> I use markdown_calibre

[19:01] <tadzik> it comes with calibre, an ebook thingy

[19:02] <tadzik> you can use Text::Markdown from panda ;)

[19:02] <labster> tadzik: why does the new File::Find still use .IO?  *hint hint*

[19:02] *** preflex joined
[19:02] *** ChanServ sets mode: +v preflex

[19:10] <tadzik> labster: *hmm hmm*

[19:11] <tadzik> labster: for, uh, clarity? :)

[19:12] <labster> my pull request from YAPC:NA already removed them

[19:13] *** ecocode joined
[19:15] <dalek> perl6-roast-data: f9842f8 | coke++ | / (5 files):

[19:15] <dalek> perl6-roast-data: today (automated commit)

[19:15] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/f9842f8a19

[19:22] *** rindolf left
[19:26] <[Coke]> slight loss on rakudo.jvm as rakudo.parrot's fudging issue is resolved; sorear++ or jnthn++ got the spec tests running again, yay.

[19:28] *** colomon left
[19:33] <timotimo> r: class Foo { }; say Foo.^find_method('elems') === Any.^find_method('elems')

[19:33] <camelia> rakudo ee0852: OUTPUT¬´True‚ê§¬ª

[19:35] <sorear> yay

[19:35] <sorear> r: role Foo { }; say Foo.^find_method('elems') === Foo.^find_method('elems')

[19:35] <camelia> rakudo ee0852: OUTPUT¬´True‚ê§¬ª

[19:37] <benabik> r: role Foo {}; role Bar { sub elems { 0 } }; say Foo.^find_method('elems') === Bar.^find_method('elems')

[19:37] <camelia> rakudo ee0852: OUTPUT¬´True‚ê§¬ª

[19:37] <benabik> Hmmmmm....

[19:37] <benabik> Oh. sub.

[19:37] <benabik> r: role Foo {}; role Bar { method elems { 0 } }; say Foo.^find_method('elems') === Bar.^find_method('elems')

[19:37] <camelia> rakudo ee0852: OUTPUT¬´False‚ê§¬ª

[19:37] <benabik> \o/

[19:38] <labster> I finally have tuits to look at the io-spec-unix error.  Hm.  It looks like java returns cwd with a slash appended to the end.

[19:40] <GlitchMr> I was reading commits log. I found https://github.com/rakudo/rakudo/commit/a2f9e0bd83aafaeeb7afa58ef126300fca7d6cfd

[19:40] <diakopter> pmurias: google chrome plugin renders .markdown files okay

[19:40] <GlitchMr> But I was confused when (1.0 ** 3) properly returned 1.0 (not 1).

[19:40] <GlitchMr> I assume that it was already fixed.

[19:40] <benabik> GlitchMr: It's been removed again: https://github.com/rakudo/rakudo/commit/aa75b0332e24fe91f49f63a74a495b9cb2c66435

[19:41] <sorear> r: role Foo { method elems { 0 } }; say Foo.^find_method('elems') === Foo.^find_method('elems')

[19:41] <camelia> rakudo ee0852: OUTPUT¬´True‚ê§¬ª

[19:41] <GlitchMr> Makes sense.

[19:41] <GlitchMr> I never understood why it needed such hack anyway. Is ** operator that slow?

[19:41] <GlitchMr> (I don't think 1 ** is common case anyway)

[19:42] <sorear> GlitchMr: pow_n was returning bogus values for that case on jvm, so it had to be worked around

[19:43] <sorear> GlitchMr: see https://github.com/perl6/nqp/commit/48d3bdef27

[19:43] <grondilu> List.combinations is NYI?

[19:43] <sorear> unperl6y values, anyway

[19:43] <grondilu> n: .say for <a b c>.combinations(2)

[19:43] <camelia> niecza v24-86-g39ab531: OUTPUT¬´Unhandled exception: Unable to resolve method combinations in type Parcel‚ê§  at /tmp/PkmLgNW09p line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ‚ê§ ‚Ä¶

[19:43] <grondilu> r: .say for <a b c>.combinations(2)

[19:43] <camelia> rakudo ee0852: OUTPUT¬´No such method 'combinations' for invocant of type 'Parcel'‚ê§  in block  at /tmp/R34S7snKyo:1‚ê§‚ê§¬ª

[19:44] <dalek> rakudo-js: 6ce9794 | (Pawel Murias)++ | / (4 files):

[19:44] <dalek> rakudo-js: Implement nqp::findmethod. Test QAST::Node.{flat,named}.

[19:44] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/6ce9794077

[19:49] <dalek> rakudo-js: 9af914f | (Pawel Murias)++ | t/qast-node.t:

[19:49] <dalek> rakudo-js: Test QAST::Node.unique.

[19:49] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/9af914fb34

[19:56] *** SamuraiJack left
[20:00] *** Khisanth joined
[20:03] <pmurias> diakopter: Markdown Preview?

[20:04] <diakopter> pmurias: maybe

[20:04] <diakopter> I don't remember

[20:08] *** Stygia joined
[20:08] <pmurias> stackedit

[20:09] * jnthn back-ish

[20:09] <diakopter> pmurias: neat

[20:09] <diakopter> not quite github dialect, but close enough I'm sure

[20:11] <tadzik> labster: oh, indeed.

[20:11] *** berekuk left
[20:11] <tadzik> I now see that there were 2 pull requests doing this :)

[20:11] <tadzik> I blame github interface

[20:12] <pmurias> jnthn: have you seen my .parents question?

[20:13] <jnthn> pmurias: Not yet...

[20:14] * jnthn just looks in the ir clog

[20:14] *** berekuk joined
[20:14] <jnthn> r: class A { }; class B is A { }; say B.^parents

[20:14] <camelia> rakudo ee0852: OUTPUT¬´(A)‚ê§¬ª

[20:14] <jnthn> r: class A { }; class B is A { }; say B.^parents(:all)

[20:14] <camelia> rakudo ee0852: OUTPUT¬´(A) (Any) (Mu)‚ê§¬ª

[20:14] <jnthn> pmurias: Those answers are correct

[20:14] <pmurias> jnthn: in nqp

[20:14] <jnthn> oh.

[20:15] <pmurias> nqp: my $parent := NQPMu.HOW.parents(NQPMu)[0];say($parent.HOW.name($parent))

[20:15] <camelia> nqp: OUTPUT¬´NQPMu‚ê§¬ª

[20:15] <jnthn> Well, parents should not include the class itself, no

[20:15] <jnthn> .HOW.mro should.

[20:15] <pmurias> I'll fix that then

[20:16] <pmurias> writing test for nqp-js appears to be succesfull at find nqp bugs ;)

[20:16] <pmurias> * finding

[20:16] <sorear> nqp: say(nqp::elems(NQPMu.HOW.parents(NQPMu)))

[20:16] <camelia> nqp: OUTPUT¬´1‚ê§¬ª

[20:17] <timotimo> jnthn: can you suggest how to efficiently and correctly as well as simply implement "is the method given by $name implemented in a class that is marked 'Iterable'?" and/or "does the proto for this method come from Any?"

[20:18] <jnthn> Is the first one not just "it has a method of that name and it istype Iterable"?

[20:19] <pmurias> jnthn: to avoid rakudo breakage what should I check before merging fix-help and fix-set-invocation-spec?

[20:19] *** konundra left
[20:19] <jnthn> pmurias: Run a Rakudo spectest, making sure (if Rakudo has dependnet changes) to bump NQP_REVISION

[20:20] <timotimo> jnthn: no, if the method comes from a superclass that on't work

[20:20] <jnthn> oh.

[20:21] *** kaare_ left
[20:21] <jnthn> No, there's not a good way to do that. That sounds horribly like the duck typing thing I didn't figure out how to make fast ;)

[20:23] <[Coke]> so, I have a copy of the eval server running, started by hand. if I run replace my perl6 with the eval client, and invoke ./perl6 -e 'say 3', I get a new line but no 3. ??

[20:23] <jnthn> timotimo: How hot path is it?

[20:25] <sorear> [Coke]: any output on the terminal where you started the eval server?  (there shouldn't be, but...)

[20:26] <[Coke]> sorear: ope.

[20:26] <[Coke]> *n

[20:26] <sorear> how did you "replace my perl6 with the eval client"?

[20:28] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/bin/rakudo.jvm.sh#L31

[20:28] <[Coke]> (just did those 3 lines in a fresh checkout)

[20:28] <[Coke]> and started the eval server with: ./perl6-eval-server -bind-stdin -cookie TESTCOOKIE -app perl6.jar

[20:31] <sorear> ah

[20:31] <sorear> @ARGV = ("-e", "say 3")

[20:31] <sorear> "perl eval-client.pl TESTCOOKIE run @ARGV" = "perl eval-client.pl TESTCOOKIE run -e say 3"

[20:31] <arnsholt> Is NQP on JVM failing two sprintf tests expected?

[20:31] <sorear> so it's like you ran ./perl6 -e say 3 normally

[20:32] <sorear> the program is say(), @*ARGS = ("3")

[20:32] <arnsholt> Git checkout from this morning plus some of my changes

[20:32] <sorear> 06:33 < sorear> I have two failing sprintf tests.  I hope that's expected

[20:32] <FROGGS> arnsholt: yes

[20:32] <sorear> 06:33 < FROGGS> sorear: I think so, yes

[20:33] <arnsholt> Right, so my NativeCall hacking didn't magically break sprintf. Good =)

[20:33] <FROGGS> arnsholt: relieved? :o)

[20:33] <arnsholt> Moderately, let's say =D

[20:34] <FROGGS> hehe

[20:36] <[Coke]> sorear: so, ./perl6 -e say 3 actually works. 

[20:37] * [Coke] just reverts ./perl6 to something he can test with.

[20:39] <sorear> [Coke]: your problem is a lack of quoting in the perl file.

[20:40] <sorear> interpolating @ARGV into an exec(STRING) command means you lose the distinction between strings

[20:40] *** konundra joined
[20:41] *** ecocode` joined
[20:42] *** ecocode` left
[20:42] *** ecocode left
[20:42] *** ecocode` joined
[20:47] <[Coke]> Yes. didn't feel like fighting with it.

[20:50] <arnsholt> Heh. I like how the commit dates on my branch aren't monotonically increasing anymore, after a bit of rebasing

[20:52] <[Coke]> sorear: thanks for diagnosing, though. will save me time later when I feel like fixing it.

[20:52] <[Coke]> argh. lost my fix to t/fudgeandrun...

[20:54] <FROGGS> :/ we really need a gitfs

[20:55] *** ajr_ left
[21:03] <dalek> rakudo/nom: bce1048 | coke++ | t/fudgeandrun:

[21:03] <dalek> rakudo/nom: allow script to work on parrot & jvm

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bce10485be

[21:10] <dalek> roast: 15c110c | coke++ | S06-multi/type-based.t:

[21:10] <dalek> roast: fudge for rakudo.jvm

[21:10] <dalek> roast: review: https://github.com/perl6/roast/commit/15c110ccb2

[21:10] <pmurias> jnthn: any ideas/hints what could cause "No code ref at index 2" when compiling http://pastie.org/8138308 with http://pastie.org/8138304

[21:13] <jnthn> we still have spew in nqp? :)

[21:15] <pmurias> https://github.com/perl6/nqp/blob/master/src/core/IO.nqp#L38

[21:15] <jnthn> hah

[21:15] <jnthn> Not much idea aside from something to do with the clone callback stuff perhaps...

[21:16] <jnthn> Givne it's a role

[21:16] <pmurias> I'll saturate nqp with say statements and look some more ;)

[21:18] *** cooper left
[21:20] *** zby_home_ left
[21:21] <jnthn> pmurias: It's almost certainly something to do with closure handling

[21:25] <pmurias> it's some wird interaction between backends, as not emitting javascript got rid of this 

[21:26] <pmurias> what is the compiling SC stack?

[21:27] *** snoopy left
[21:28] <jnthn> When we start compiling someting we push the SC onto the stack

[21:28] <jnthn> it gets popped in QAST::Compiler, or QAST::CompilerJAST, etc.

[21:30] <pmurias> that was the source of the error

[21:30] <pmurias> so if I compile something on two backends when should this get popped?

[21:30] <timotimo> jnthn: it'd be either in hyper(\op, \obj) or in dispatch:<hyper>, probably only in the latter

[21:30] <timotimo> so it's a kind of warm path

[21:31] *** berekuk left
[21:33] <timotimo> the nodal-or-not decision could possibly be compile-time evaluated.

[21:35] <timotimo> huh. no probably not

[21:35] <pmurias> jnthn: the SC stack is used just for determining the current SC, for repossesion purposes?

[21:36] <jnthn> pmurias: yes; it should be popped at the point of SC serialization, I think, but I don't know the exactly timing once you reach the QAST -> backend stage matters terribly

[21:37] <pmurias> jnthn: and it's used for what I think?

[21:38] <jnthn> repo, yes

[21:39] <jnthn> we scwbObject or so in Ops.java on the JVM backend, for example

[21:39] <jnthn> timotimo: OK, will have to ponder it when I'm not drinking a tripel... :)

[21:40] <timotimo> aah, don't worry about it; i'm having some rum right now ;)

[21:41] <timotimo> alternatively, it may make more sense to just make something that'll automatically set "is nodal" on everything that's defined in a class

[21:41] <timotimo> less searching that way; and it'll mostly be at compile-time

[21:41] <timotimo> (and it would require no more changes in the hyper code i have)

[21:42] <timotimo> i should probably push to a branch and put it up for a little bit of review

[21:46] <grondilu> rn: my @a = <foo bar>; say join ":", $@a

[21:46] <camelia> rakudo bce104, niecza v24-86-g39ab531: OUTPUT¬´foo bar‚ê§¬ª

[21:47] <grondilu> maybe the fact that we don't actually need parenthesis should be mentioned in S07:100-111

[21:47] <synopsebot> Link: http://perlcabal.org/syn/S07.html#line_100

[21:48] * grondilu hates parenthesis and he's happy whenever he can not use them

[21:51] <FROGGS> nqp@parrot HEAD is broken?

[21:51] <FROGGS> error:imcc:syntax error, unexpected NREG, expecting '(' ('$N5001')

[21:53] <lelf> r: say 'ababa' ~~ m:ex/aba/

[21:53] <camelia> rakudo bce104: OUTPUT¬´False‚ê§¬ª

[21:55] <timotimo> is there a shorter thing than "git checkout -b things_i_have_done && git push -f . origin/nom:nom" for when i commited my changes on nom but want them on a new branch?

[21:57] <benabik> (on nom) git branch new ; git reset @{u} ; git check new ?

[21:57] <benabik> Maybe not shorter.  :-/

[21:58] <benabik> git config alias.oops '!sh -c "git branch $1 && git reset @{u} && git checkout $1"'  ?

[22:00] <timotimo> what is @{u}?

[22:00] <benabik> Upstream 

[22:01] <timotimo> ah, cool

[22:02] <timotimo> https://github.com/timo/rakudo/compare/nodal - this is what i've done so far and it apparently works

[22:02] <timotimo> i ought to make some more test cases, though.

[22:03] *** berekuk joined
[22:06] * grondilu reads 'Perl 6 changes - 2013W28' and have no clue what 'Promise' is :/

[22:06] * grondilu found nothing relelvant in the spec

[22:11] <jnthn> grondilu: I'll write some stuff about that when I get chance

[22:15] *** spider-mario left
[22:20] <TimToady> "As Nil is (), it shouldn‚Äôt affect code returning Nil."  This is incorrect.  Nil is not supposed to return ().

[22:21] <FROGGS> this is the commit which breaks nqp@parrot: 260c3b5f00c50ca0595ac3a1392b13faf9c386bc

[22:26] <timotimo> so the _n is wrong?

[22:27] <FROGGS> looks like

[22:27] *** berekuk left
[22:27] <benabik> grondilu: http://en.wikipedia.org/wiki/Promise_(programming) ?

[22:30] *** berekuk joined
[22:35] <grondilu> benabik: yep I eventually figured it out.  I didn't know about this.

[22:37] <grondilu> not related at all:  is there any plan to have fmt support large integers?  I mean, for instance to print a big integer in binary:  say (2^80).fmt("%b")

[22:37] <grondilu> r: say .fmt("%040b") given 2**39

[22:37] <camelia> rakudo bce104: OUTPUT¬´0000000000000000000000000000000000000000‚ê§¬ª

[22:38] <grondilu> r: say .fmt("%032b") given 2**31

[22:38] <camelia> rakudo bce104: OUTPUT¬´10000000000000000000000000000000‚ê§¬ª

[22:38] <grondilu> see?

[22:38] <FROGGS> r: say sprintf("%#b", 2**31)

[22:38] <camelia> rakudo bce104: OUTPUT¬´0b10000000000000000000000000000000‚ê§¬ª

[22:38] <FROGGS> nqp-jvm: say(sprintf("%#b", 2**31))

[22:38] <camelia> nqp-jvm: OUTPUT¬´Lexical '&sprintf' not found‚ê§  in <anon>‚ê§  in <anon>‚ê§  in eval‚ê§  in evalfiles‚ê§  in command_eval‚ê§  in command_line‚ê§  in MAIN‚ê§  in <anon>‚ê§  in <anon>¬ª

[22:39] <FROGGS> nqp-jvm: say(nqp::sprintf("%#b", 2**31))

[22:39] <camelia> nqp-jvm: OUTPUT¬´No registered operation handler for 'sprintf'‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in process_args‚ê§  in <anon>‚ê§  in <anon>‚ê§  in compile_op‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in compile_all_the_stmts‚ê§  in as_jast‚ê§  in as_jast‚ê§  in <anon>‚ê§  in compi‚Ä¶

[22:39] <grondilu> r: printf("%#b", 2**32)

[22:39] <camelia> rakudo bce104: OUTPUT¬´0b0¬ª

[22:39] <FROGGS> huh

[22:40] <FROGGS> grondilu: I thought nqp@jvm does already do that, but it seems not

[22:40] <FROGGS> once this new sprintf is capable of all needed features, it will land on nqp@parrot too

[22:41] <grondilu> notice that in order to test it, you should use 2**32, not 2**31 (on a 32-bit machine)

[22:44] *** abnorman joined
[22:44] <FROGGS> the machine doesnt when using bigints

[22:45] *** raiph left
[22:45] <TimToady> r: say (2**39).base(2)

[22:45] <camelia> rakudo bce104: OUTPUT¬´1000000000000000000000000000000000000000‚ê§¬ª

[22:45] <lue> I have a 64-bit machine, and 2**32 wfm (but not, predictably, 2**64)

[22:45] <TimToady> r: say (2**65).base(2)

[22:45] <camelia> rakudo bce104: OUTPUT¬´100000000000000000000000000000000000000000000000000000000000000000‚ê§¬ª

[22:45] <TimToady> how hard can it be?

[22:46] *** abnorman left
[22:47] *** abnorman joined
[22:49] <grondilu> ok

[22:50] <grondilu> r: my $x = 2**100; say $x +& $x

[22:50] <camelia> rakudo bce104: OUTPUT¬´1267650600228229401496703205376‚ê§¬ª

[22:50] <grondilu> r: my $x = 2**100; say ($x +& $x).base(2)

[22:50] <camelia> rakudo bce104: OUTPUT¬´10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000‚ê§¬ª

[22:50] <grondilu> r: my $x = 2**65; say ($x +& ($x + 1)).base(2)

[22:50] <camelia> rakudo bce104: OUTPUT¬´100000000000000000000000000000000000000000000000000000000000000000‚ê§¬ª

[22:50] *** Stygia left
[22:50] <grondilu> r: my $x = 2**65; say ($x +| ($x + 1)).base(2)

[22:50] <camelia> rakudo bce104: OUTPUT¬´100000000000000000000000000000000000000000000000000000000000000001‚ê§¬ª

[22:51] <grondilu> oh, so bitwise logic does work with big integers.  Good.

[22:52] <grondilu> r: say +^ 2**65 # just an other check

[22:52] <camelia> rakudo bce104: OUTPUT¬´-36893488147419103233‚ê§¬ª

[22:52] <grondilu> r: say (+^ 2**65).base(2) # just an other check

[22:52] <camelia> rakudo bce104: OUTPUT¬´-100000000000000000000000000000000000000000000000000000000000000001‚ê§¬ª

[22:52] <grondilu> hum

[22:52] <grondilu> r: say (+^ 2**10).base(2) # just an other check

[22:52] <camelia> rakudo bce104: OUTPUT¬´-10000000001‚ê§¬ª

[22:53] * grondilu is confused by negative integers in bitwise logic

[22:54] <benabik> Bit inverting a signed x is same as -x-1 due to 2s compliment.

[22:55] <TimToady> +^ is 1's complement but the representation always pretends to be 2's complement

[22:55] <TimToady> r: say (+^ 0)

[22:55] <camelia> rakudo bce104: OUTPUT¬´-1‚ê§¬ª

[22:55] <TimToady> there's the degenerate case, flipping all the bits

[22:55] <TimToady> well, it always flips all the bits

[22:56] <TimToady> setting all the bits, in this case

[22:56] <pmurias> jnthn: it wasn't the stack poping

[22:56] <TimToady> the fact that there are in infinite number of them is okay, since we can represent an infinite number of 1 bits with a -

[22:56] <grondilu> ok.  I guess I won't use ^+ as it won't suit my need, then

[22:56] <pmurias> jnthn: serialize_sc seems to have some global state, will try to chase it down tommorow

[22:57] * grondilu meant +^

[22:57] <TimToady> grondilu: it should work exactly the same when stored into a 2's complement native (in the absence of overflow, of course)

[22:59] <TimToady> r: say (2**65).msb

[22:59] <camelia> rakudo bce104: OUTPUT¬´65‚ê§¬ª

[22:59] <TimToady> but if you're just looking for the magnitude of a binary number, .msb is what you want

[23:00] <grondilu> no I want to do bitwise logic on large number (I'm working on http://rosalind.info/problems/cset/)

[23:00] <grondilu> because there are large boolean arrays stored as 000001011100000111...

[23:01] <grondilu> (as strings of 0 and 1, that is)

[23:01] <TimToady> if you want to limit it to a certain number of bits, and not go negative, then you'll want to xor with a large positive 2n-1 number

[23:01] <grondilu> or just do 2**MAX - x

[23:01] <grondilu> I think that's what I'll do

[23:01] <TimToady> but if you don't care about the number of bits actually used, or the sign of the result, unary +^ should work fine

[23:02] <TimToady> it does, in fact do a 1's complement

[23:02] <grondilu> but getting back the boolean array would be tricky, wouldn't it?

[23:03] <grondilu> I mean, +^ would confuse me too much.  But I guess I need to take some time to think clearly about these stuff

[23:03] <TimToady> you might have to & with a sized 2n-1 at that point to make it positive, but all the intermediate stuff doesn't have to

[23:04] <jnthn> pmurias: are you generating code for two backends in one process?

[23:04] * jnthn never did it that way :)

[23:04] <pmurias> jnthn: yes

[23:04] <jnthn> k :)

[23:04] <dalek> rakudo/nom: 6c80bf5 | (Solomon Foster)++ | src/core/Rational.pm:

[23:04] <dalek> rakudo/nom: Fix broken div uses.

[23:04] <dalek> rakudo/nom: 

[23:04] <dalek> rakudo/nom: Rational.pm was written to work with NQP Parrot's broken infix:<div>.  Since NQP JVM now has a properly working infix:<div>, a bunch of these functions started failing.  This corrects floor, ceiling, and Int.

[23:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c80bf57d9

[23:05] <pmurias> jnthn: a prop is being attached to code refs to mark them as cloned

[23:05] <jnthn> pmurias: yes

[23:05] <jnthn> pmurias: oh, hm

[23:06] <jnthn> pmurias: I think that ops abstract that though

[23:06] *** colomon joined
[23:07] <colomon> turns out that getting infix:<div> working properly on jakudo (it never has on parrakudo) broke some of the basic Rat methods.  So now I've fixed those, too.

[23:07] <pmurias> abstract that? the problem is that they get cloned and put into the closure table of one backend, and on the other one are already marked

[23:07] <jnthn> pmurias: ah

[23:07] <pmurias> but it should be fairly easy to workaround that if that is the case

[23:07] <jnthn> pmurias: thats entirely possible. I never really designed it with your use case in mind.

[23:08] <jnthn> BS in general is a kind of marking thing.

[23:09] <pmurias> BS?

[23:09] <FROGGS> colomon: https://github.com/perl6/nqp/commit/260c3b5f00c50ca0595ac3a1392b13faf9c386bc#commitcomment-3628793

[23:09] <FROGGS> jnthn: ------^ any idea about that?

[23:09] <jnthn> pmurias: bound serialization

[23:10] <FROGGS> anybody else has problems building nqp@parrot HEAD?

[23:10] <colomon> I must have modified the wrong file somehow.  :(

[23:10] <jnthn> FROGGS: that looks like sokmebody confusssed a nqp:: and pir::

[23:10] <jnthn> oh wow my typing rocks

[23:11] <FROGGS> I can read it :o)

[23:11] * colomon didn't even notice

[23:12] <jnthn> pmurias: um, bounded, not bound

[23:12] <FROGGS> gnight, see ya in a few hours

[23:12] <jnthn> 'night, FROGGS 

[23:12] *** FROGGS left
[23:12] <colomon> FROGGS++

[23:17] *** dmol left
[23:17] <dalek> specs: 8f30d2d | larry++ | S03-operators.pod:

[23:17] <dalek> specs: nodal ok on normal methods too, not just protos

[23:17] <dalek> specs: review: https://github.com/perl6/specs/commit/8f30d2d1eb

[23:18] <dalek> nqp: a60837b | (Solomon Foster)++ | src/vm/parrot/QAST/Operations.nqp:

[23:18] <dalek> nqp: Undo changes that didn't belong in NQP Parrot.

[23:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a60837b1e2

[23:18] <colomon> With luck that undoes the damage I did to Parrot.

[23:18] <colomon> o/ # back to cabin

[23:18] *** colomon left
[23:20] <pmurias> jnthn: I could either move to the stable sc way of doing things or we could cache the serialization somehow

[23:22] <TimToady> r: say [].can('elems').perl

[23:22] <camelia> rakudo 6c80bf: OUTPUT¬´(method elems(List : Mu *%_) { ... }, method elems(Iterable : Mu *%_) { ... }, method elems(: Mu *%_) { ... })‚ê§¬ª

[23:22] <TimToady> r: say [].can('elems')[*-1].perl

[23:22] <camelia> rakudo 6c80bf: OUTPUT¬´method elems(: Mu *%_) { ... }‚ê§¬ª

[23:22] <TimToady> r: say [].can('elems')[*-1].WHO

[23:22] <camelia> rakudo 6c80bf: OUTPUT¬´().hash‚ê§¬ª

[23:22] <TimToady> r: say [].can('elems')[*-1].WHAT

[23:22] <camelia> rakudo 6c80bf: OUTPUT¬´(Method)‚ê§¬ª

[23:23] <TimToady> r: say [].can('elems')[*-1].WHICH

[23:23] <camelia> rakudo 6c80bf: OUTPUT¬´Method|-172260614‚ê§¬ª

[23:23] <TimToady> any way to tell which class that method is declared in?

[23:23] <jnthn> TimToady: well, can always introspect the signature's first arg's type

[23:24] <TimToady> uh, I though we didn't require the self to do typing

[23:25] <TimToady> in fact, Any doesn't show up above, though List and Iterable do

[23:26] <TimToady> just trying to figure out how to best to look up nodal in those cases we can intuit it

[23:26] <jnthn> The type of the self is what makes multi-dispatch disambiguate in a subclass

[23:26] <jnthn> Yeah...I need to read le spec more carefully and ponder it :)

[23:26] <TimToady> well, except most of the methods in Any aren't multis

[23:27] <jnthn> Sure, but the type is still set on the invocant

[23:27] <jnthn> It's user-selectable though so it can lie

[23:28] <jnthn> Though iirc S12 is like, "don't do that" :)

[23:29] <TimToady> nodnod

[23:30] <jnthn> I mean, any kind of custom dispatch is possible given we keep a hash of methods at each level (walk MRO and se .^method_table) but I guess we want something more efficient.

[23:30] <jnthn> *see

[23:31] <jnthn> If we have a typed array, are we meant to consider nodality of the individual things and respect subtyping, ooc?

[23:31] <jnthn> .oO( is that even a sensible question... :) )

[23:31] <TimToady> well, put 'is nodal' on every &foo that might be used in a hyper is probably best, given it requires no additional run-time lookup in the hyper

[23:31] <jnthn> Oh, of course, it's on hte operator...

[23:31] <TimToady> so probably the compiler needs to just have some way of setting that on all the appropriate &foo's

[23:31] <jnthn> k

[23:33] <TimToady> probably just a $?NODAL (or compile-time $*NODAL) that declarators can examine is an okay hack, and we just force it on when a class has 'is Iterable' in the declaration, or we see a 'use nodal;'

[23:33] <TimToady> or somethin'

[23:33] <TimToady> it doesn't seem like it needs to be an extensible mechanism, so a compiler hack is probably okay in this case

[23:34] *** census_ joined
[23:34] <TimToady> unless we can think of something elegant that doesn't violate S12 :)

[23:35] <TimToady> in any event, there should be no run-time component to determining whether a function is nodal, other than looking up its trait directly

[23:45] <TimToady> "has 'is Iterable' in the declaration" is misstated.  shoulda said "derived from Iterable"

[23:46] <TimToady> maybe a compose-time thing, to handle methods coming from roles correctly

[23:47] <pmurias> jnthn: do you think it would break anything if I made serialization caching on parrot?

[23:47] *** ecocode` left
[23:48] <jnthn> pmurias: What do you mean by serialization caching?

[23:48] <pmurias> if serialize_sc is called a second time on the same sc, it should return the same thing

[23:49] <jnthn> ah

[23:49] <jnthn> probably ok, I mean, the serialization string should come out the same both times

[23:50] <jnthn> Prolly don't want it to be a "default" though

[23:50] <pmurias> the serialization string might change if the object in QAST::WVal change

[23:52] <jnthn> yeah, that doens' tnormally happen though

[23:52] <TimToady> .oO(constant folding, immutability, value identity...)

[23:57] <jnthn> TimToady: I menat once it reaches the backend

