[00:03] <timotimo> hm. so if you have winner $channel { you can just write more * and done *

[00:04] <timotimo> i guess that's okay, too ...

[00:04] <timotimo> i can see where the want for an argument-enabled version of winner comes from in regards to channels

[00:04] <jnthn> I think that only one of the blocks should ever fire.

[00:04] <jnthn> In a single call to winner

[00:04] *** berekuk left
[00:05] <jnthn> s/call to/use of/ given the new syntax I guess :)

[00:05] <jnthn> That's kinda the point.

[00:05] <timotimo> er yes

[00:05] <timotimo> with "can fire as well" i meant "are eligible, as well"

[00:05] <jnthn> Otherwise you don't have a single result to give back...

[00:05] <jnthn> Oh, sorry

[00:05] <jnthn> Then what you said makes sense. :)

[00:05] *** berekuk joined
[00:06] <jnthn> To clarity one thing

[00:06] <jnthn> If you have a more and a done on a single channel

[00:06] <jnthn> Then the mroe always takes precedence

[00:07] <jnthn> It kinda "has to" if you implement it right anyway.

[00:07] <timotimo> i wasn't aware i could be in a situation where the channel is both closed and could supply another value

[00:07] <jnthn> No, you aren't, but it's possible to implement it wrongly and make it look like you are :)

[00:07] <jnthn> *can't

[00:07] <jnthn> *can

[00:07] <jnthn> gah ;)

[00:08] <timotimo> i'm not sure i understand. will i have to sort the given blocks so that "more" always comes before the corresponding "done"?

[00:08] <jnthn> No, you don't

[00:08] <jnthn> The main thing is that you don't see what is possible, then pick at random

[00:08] <jnthn> You pick a random order to consider the things

[00:08] <jnthn> And then take the first one that matches from that randomized ordering.

[00:09] <timotimo> to prevent starvation, or something?

[00:09] <jnthn> Yeah, that kind of thing.

[00:09] <timotimo> that makes it simpler to implement at least

[00:10] <jnthn> The wrong way to do it is to see what's possible then pick from them

[00:10] <jnthn> As that promises races.

[00:10] <timotimo> but just by looking at a channel's has_value and closed or whatever they may be called, i wouldn't do it wrong, right?

[00:10] <timotimo> ah. i randomize, go through the list and the first one that's possible i take

[00:10] <jnthn> No, there's no has_value

[00:10] <jnthn> that would be a race condition if there was

[00:10] <jnthn> YOu cannot assume you are the only one receiving from the channel.

[00:11] <timotimo> ah, because someone else could go in and snatch the value after i figured out it had one

[00:11] <jnthn> So you .poll it, which gives you a value if it can, and then you use it if you get it.

[00:11] <timotimo> what does poll do if there's no value?

[00:11] <jnthn> Nil

[00:11] <timotimo> good

[00:11] <timotimo> i can work with that.

[00:11] *** fridim_ joined
[00:12] <jnthn> Suggestion: work on implementing a WINNER thingy outside of the setting and getting that going, and then put it in the setting and wire it up to the syntax by writing the grammar/actions.

[00:12] *** Psyche^ joined
[00:13] <jnthn> It's probably less frustrating than trying to develop it in the setting :)

[00:13] <timotimo> sure thing. that'll give me a good turnaround time

[00:13] <timotimo> or i could interleave work on the grammar part and the out-of-setting implementation :P

[00:13] <jnthn> y^Haye

[00:13] <jnthn> Well, also that :)

[00:13] <jnthn> Lemme know if you run into any question along the way

[00:13] <timotimo> hm, except i need a running rakudo-jvm to test the stuff

[00:13] <timotimo> surely will

[00:14] * timotimo started a quest on questhub

[00:15] <jnthn> I'll be about on IRC plenty the next 3 days, even if on 2 of them I'll need to mostly focus on $dayjob things (I hope no more than 2). So I'll be happy to answer anything. :)

[00:15] <timotimo> gotcha

[00:15] *** hypolin joined
[00:16] <timotimo> i'm glad i can pick something doable off your plate :P

[00:16] *** colomon left
[00:16] *** Psyche^_ left
[00:16] <jnthn> :)

[00:25] <timotimo> i've got a signature kind of like sub WINNER(@win_args, *@pieces, :$wild_done, :$wild_more, :$later) in mind

[00:26] <timotimo> see anything obviously wrong with that?

[00:26] *** berekuk left
[00:26] <jnthn> How do you know which pieces are done/more?

[00:27] <timotimo> @pieces will be a list of three items each

[00:27] *** berekuk joined
[00:28] <jnthn> ah, k

[00:29] <jnthn> Then yeah, makes sense, I think.

[00:29] <timotimo> say, the arguments that get passed only really matter if there are wildcards, right?

[00:29] <jnthn> ?

[00:29] <jnthn> Arguments passed to the blocks?

[00:29] <timotimo> the arguments between winner and {

[00:29] <timotimo> yes

[00:29] <timotimo> er, to the one block i meant

[00:30] <jnthn> Oh, those only matter for wild card

[00:30] <jnthn> I *think*

[00:30] <timotimo> good :)

[00:30] <jnthn> Worth checking with TimToady what he was thinking, though

[00:30] <TimToady> hmm?

[00:30] *** dwoldrich left
[00:30] <jnthn> uh-oh :D

[00:31] <jnthn> TimToady: winner $p1, $p2 { more $p1 { }; more $p2 { } }

[00:31] <jnthn> TimToady: In this case, is it OK to write:

[00:31] <jnthn> TimToady: winner { more $p1 { }; more $p2 { } }

[00:31] <jnthn> TimToady: That is, the things you put after winner only matter for the more * / done * cases?

[00:32] <TimToady> true, but there could also be mixed cases; I suppose we could intuit it when there is no beginning list

[00:32] <TimToady> but I don't think we should allow a partial list, either all or nothing

[00:33] <jnthn> What's the design motivation for the up-front list, aside from allowing * ?

[00:33] <TimToady> at some point, if we end up naming all our channels, we might allow a tag that merely identifies which one of the list we mean, but for now it's just the $p1

[00:33] <timotimo> if we have a partial list, the extra done's/more's kind of act like the "later" in other cases

[00:33] <TimToady> which is a little weird, since it's kinda container identity

[00:34] <jnthn> Yeah...

[00:34] <jnthn> I'm also wondering what if you

[00:34] <jnthn> winner $p1, $p2 { more $p1 { } } # no mention of $p2

[00:35] <timotimo> if there's no later, what do i do? return Nil?

[00:35] <TimToady> we have to decide if the redundancy is a feature; I think with complicated things it's better to have a list up front

[00:36] *** dayangkun joined
[00:36] <TimToady> I'm still not quite sure a 'later' case is the right approach, rather than just a different keyword 'winnermaybe' or some such

[00:37] <TimToady> pollwinner

[00:37] <TimToady> though a later case allows us to choose what gets returned

[00:37] <dalek> rakudo-star-daily: a969465 | coke++ | log/ (5 files):

[00:37] <dalek> rakudo-star-daily: today (automated commit)

[00:37] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/a96946572a

[00:37] <dalek> rakudo-star-daily: 26d6ece | coke++ | log/ (5 files):

[00:37] <dalek> rakudo-star-daily: today (automated commit)

[00:37] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/26d6ecea6d

[00:37] <dalek> perl6-roast-data: 587cf1c | coke++ | / (5 files):

[00:37] <dalek> perl6-roast-data: today (automated commit)

[00:37] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/587cf1c737

[00:37] <dalek> perl6-roast-data: 1610d45 | coke++ | / (4 files):

[00:37] <dalek> perl6-roast-data: today (automated commit)

[00:37] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/1610d45e04

[00:37] <dalek> perl6-roast-data: 6826ae8 | coke++ | / (4 files):

[00:37] <dalek> perl6-roast-data: today (automated commit)

[00:37] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/6826ae83d7

[00:38] *** berekuk left
[00:39] <jnthn> *nod*

[00:39] <jnthn> OK, heading afk for the evening

[00:39] <jnthn> 'night

[00:39] <TimToady> o/

[00:39] *** berekuk joined
[00:46] <timotimo> i think i'll start implementing tomorrow

[00:46] <timotimo> gnite!

[00:47] <TimToady> o/

[00:49] *** berekuk left
[00:50] *** berekuk joined
[01:01] *** berekuk left
[01:02] *** berekuk joined
[01:03] *** lambdabot joined
[01:12] *** berekuk left
[01:19] *** xinming left
[01:20] *** xinming joined
[01:30] *** colomon joined
[01:33] *** thou left
[01:42] *** tgt left
[01:42] <dalek> nqp: a4637f9 | dwarring++ | examples/rubyish/ (3 files):

[01:42] <dalek> nqp: rubyish quicksort tidy, etc

[01:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a4637f9b8a

[01:43] <dalek> nqp: cf04d56 | dwarring++ | docs/ops.markdown:

[01:43] <dalek> nqp: ops doco typo

[01:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cf04d56dd8

[01:48] *** dayangkun left
[01:57] *** hummeleB1 joined
[02:01] *** woosley joined
[02:14] *** colomon left
[02:15] *** colomon joined
[02:18] <k-ray> BEGIN { @*INC.push("{ $?FILE.match('.*/') }lib") } # What is the recommended way to do this?

[02:18] <preflex>  k-ray: you have 1 new message. '/msg preflex messages' to read it.

[02:22] <colomon> k-ray: what are you trying to do with that?

[02:23] <k-ray> colomon: be able to load modules from the lib directory alongside my script

[02:24] <k-ray> e.g. 'use Bar' from foo/foo.p6 should load foo/lib/Bar.pm6

[02:26] <colomon> r: say "foo/foo.p6".path.directory

[02:26] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«foo␤»

[02:26] <colomon> r: say "foo.p6".path.directory

[02:26] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«.␤»

[02:27] <k-ray> ah, cool...that at least knocks the regex part out

[02:27] <colomon> so… $?FILE.path.directory ~ "/lib"

[02:28] <k-ray> so there's no 'use lib' or equivalent?  just manipulate @*INC directly from within a BEGIN block?

[02:28] <colomon> … maybe a use lib now?  It wasn't there last time I checked, I don't think.

[02:29] <colomon> honestly, usually I just use perl6 -Ilib for working with libraries.  :)

[02:29] <colomon> try use lib, rakudo seems to recognize it.

[02:30] <k-ray> I tried it earlier, was getting something like a "Null PMC" error

[02:31] <geekosaur> mhhh. you should not be seeing those

[02:31] <k-ray> ah...I find it difficult to tell when the problem is me or it :)

[02:32] <geekosaur> that's part of the problem; it's an abstraction leak from the underpinnings of rakudo, which should be catching it and telling you what's actually wrong

[02:33] <k-ray> use lib $?FILE.path.directory ~ '/lib'; # works

[02:33] <colomon> \o/

[02:33] <k-ray> use lib "{ $?FILE.match('.*/') }lib"; # Null PMC

[02:34] <colomon> rakudobug

[02:34] <colomon> dunno if it's already in RT or not

[02:36] <colomon> r: my $a = "foo/foo.pl"; say "{ $a.match('.*/') }lib"; # Null PMC

[02:36] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«lib␤»

[02:36] <colomon> r: my $a = "foo/"; say "{ $a.match('.*/') }lib"; # Null PMC

[02:36] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«lib␤»

[02:36] <colomon> r: my $a = "foo.pl"; say "{ $a.match('.*/') }lib"; # Null PMC

[02:36] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«lib␤»

[02:37] <k-ray> the matching part works fine, it's when I pass it to use lib instead of pushing it onto @*INC that the error occurs

[02:38] <k-ray> iow, my original line, BEGIN { @*INC.push("{ $?FILE.match('.*/') }lib") }, also works

[02:41] <colomon> ah

[02:41] <colomon> weird

[02:43] <diakopter> .

[02:43] <k-ray> I'll just report it and move on...my question is answered, either way. thanks!

[02:45] <colomon> k-ray++

[02:46] *** berekuk joined
[02:50] <k-ray> :) what is all this ++ing anyway?  is there a bot hanging around keeping score for everyone? or just a cultural convention?

[02:52] <geekosaur> there's a couple of karmabots in here, but it is indeed cultural

[02:53] <diakopter> colomon+-

[02:55] <BenGoldberg> preflex: karma k-ray

[02:55] <preflex>  k-ray: 3

[02:56] <japhb_> I wonder if the karma bots are smart enough to combine

[02:56] <BenGoldberg> $bot.comb ?

[02:56] <japhb_> preflex: karma japhb japhb_ japhb__ japhb__ (Geoffrey Broadwell)

[02:56] <preflex>  japhb japhb_ japhb__ japhb__ (Geoffrey Broadwell) has no karma

[02:56] <japhb_> preflex: karma japhb

[02:56] <preflex>  japhb: 444

[02:56] <japhb_> preflex: karma japhb_

[02:56] <preflex>  japhb_: 7

[02:56] <colomon> japhb: I don't think so.

[02:56] <japhb_> preflex: karma japhb__

[02:56] <preflex>  japhb__: 4

[02:56] <japhb_> preflex: karma japhb___

[02:56] <preflex>  japhb___ has no karma

[02:57] <japhb_> preflex: karma Geoffrey Broadwell

[02:57] <preflex>  Geoffrey Broadwell: 64

[02:57] *** berekuk left
[02:57] <japhb_> rp: say 444 + 7 + 4 + 64

[02:57] <camelia> rakudo-parrot 087165: OUTPUT«519␤»

[02:57] <japhb_> Well, hey, halfway to 4 digits.

[02:58] *** berekuk joined
[02:58] <BenGoldberg> I always get a kick out of:

[02:58] <BenGoldberg> preflex: karma C

[02:58] <preflex>  C: 203939

[02:58] <k-ray> lol

[02:58] <japhb_> Though with all the bot churn over the years, who knows what the current value would be by now.

[02:58] <colomon> preflex: karma Solomon Foster

[02:58] <preflex>  Solomon Foster: 411

[02:59] <japhb_> preflex: karma colomon

[02:59] <preflex>  colomon: 276

[02:59] <japhb_> preflex: karma Geoff Broadwell

[02:59] <preflex>  Geoff Broadwell: 1

[02:59] <japhb_> Heh.  Must have it different somewhere

[02:59] *** colomon left
[03:01] <BenGoldberg> preflex: karmabot

[03:01] <preflex>  <: -48438; -: -37205; <-: -7448; <!: -1308; <--: -1073; ~: -1036; --: -762; -rw-r--r: -652; debian: -622; ^: -485

[03:02] * japhb_ wonders who hates debian so much

[03:02] * BenGoldberg was thinking the same thing

[03:02] <BenGoldberg> I mean, the others are obviously from code

[03:02] <BenGoldberg> preflex: karmatop

[03:03] <preflex>  c: 203939; g: 9916; ##c: 7923; c/c: 7221; moritz: 5202; whiteknight: 4931; bacek: 4624; jnthn: 4573; notepad: 4391; #c: 3787

[03:03] <japhb_> Go moritz!

[03:03] <japhb_> Not that whitenight, bacek, and jnthn are slouching, mind you.  :-)

[03:04] <BenGoldberg> I wonder what channels preflex hangs out on?  Is notepad really that awesome, or is there someone out there with that nick on another channel that preflex watches?

[03:05] <k-ray> notepad++ is a popular free windows text editor

[03:05] <BenGoldberg> Not that I've got anything against the notepad program, but it seems silly to ++ it

[03:05] <BenGoldberg> There's a ++ version of it?

[03:05] <geekosaur> yes

[03:06] <k-ray> http://notepad-plus-plus.org/

[03:06] <lambdabot> Title: Notepad++ Home

[03:06] * geekosaur is amused that the first completion google came up with was "notepad++ mac" --- uh, no

[03:06] *** colomon joined
[03:06] <colomon> preflex: karma Solomon Foster

[03:06] <preflex>  Solomon Foster: 411

[03:07] <colomon> eh, not bad

[03:08] *** berekuk left
[03:10] *** lambdabot left
[03:11] *** lambdabot joined
[03:11] *** lambdabot left
[03:12] *** woosley left
[03:12] *** woosley joined
[03:12] *** lambdabot joined
[03:12] *** lambdabot left
[03:13] *** lambdabot joined
[03:13] *** lambdabot left
[03:13] *** colomon left
[03:13] *** colomon joined
[03:16] <grondilu> http://www.amd.com/us/press-releases/Pages/amd-announces-server-graphics-card-2013nov14.aspx?cmpid=social14543734   <-- I'd love to try some parallel programming in Perl 6 with this kind of stuff

[03:17] <grondilu> .oO( though I would probably not write anything interesting nor powerful, but I like to dream I would )

[03:18] *** davecc` joined
[03:18] *** lambdabot joined
[03:18] <lue> .oO(maybe this one'll have a working OpenCL implementation *grumble*...)

[03:22] <grondilu> not sure what you mean.  The article says that the card will be "optimized for use with the OpenCL™ compute programming language"

[03:24] *** ssutch left
[03:24] <geekosaur> that would mean their past attempts at opencl sucked

[03:26] <lue> geekosaur: according to Blender Cycles, their past attempts have indeed been terrible :)

[03:31] *** xenoterracide_ joined
[03:36] <grondilu> an interesting comment about precisely this on reddit:  http://www.reddit.com/r/technology/comments/1qubqr/amd_announces_first_supercomputing_graphics_card/cdgt7u1

[03:36] <lambdabot> Title: iDeNoh comments on AMD announces first "Supercomputing" graphics card with 12..., http://tinyurl.com/njseqxm

[03:37] <grondilu> "Say AMD finally fixes their openCL compiler, then blender finally completes the opencl implementation of cycles, then you have a 12GB buffer to work with, you can perform insane renders at good speeds not having to worry as much about texture usage as the card had a big enough buffer space to handle it. "

[03:37] <grondilu> sounds exciting

[03:41] <lue> grondilu: I was positive I'm not the only one who hears news like that and thinks "does this mean OpenCL works for Cycles now?" :) Only bad part is that it doesn't necessarily help those who can't buy the new card...

[03:50] *** ssutch joined
[03:53] <BenGoldberg> So will the next perl6 be written in OpenCL? :)

[03:54] <BenGoldberg> Err, the next perl6 backend

[04:09] *** colomon left
[04:13] <grondilu> lue: oh yeah these stuff are much more expensive than I thought.  The 6Go version is currently available for $4,200:  http://www.amazon.com/FirePro-S10000-GDDR5-Workstation-Graphics/dp/B00FW6K8GI/ref=sr_1_1/191-4900596-0233618?ie=UTF8&qid=1384747920&sr=8-1&keywords=AMD+FirePro%E2%84%A2+S10000

[04:13] <lambdabot> Title: Amazon.com: AMD FirePro S10000 6GB GDDR5 PCI-E Workstation Graphics Card: Com..., http://tinyurl.com/ln5ucy8

[04:13] *** preflex_ joined
[04:13] *** ChanServ sets mode: +v preflex_

[04:14] *** preflex left
[04:14] <grondilu> BenGoldberg: well, hopefully with the team getting used to implement Perl 6 on moar and moar backends, adding one in OpenCL should be easy.  Though I guess I'm being way too optimistic here.

[04:14] *** preflex_ is now known as preflex

[04:17] *** Tene left
[04:17] *** colomon joined
[04:17] *** djanatyn left
[04:18] *** Tene joined
[04:18] *** Tene left
[04:18] *** Tene joined
[04:19] *** kaleem joined
[04:19] *** ggoebel17 left
[04:20] *** ggoebel17 joined
[04:20] *** djanatyn joined
[04:44] *** kaleem left
[04:45] *** kurahaupo left
[04:47] *** berekuk joined
[04:49] *** cibs left
[04:49] *** wrp6 left
[04:49] *** wrp6 joined
[04:49] *** cibs joined
[04:57] *** berekuk left
[05:00] *** berekuk joined
[05:00] *** wrp6 left
[05:02] *** kurahaupo joined
[05:10] *** berekuk left
[05:21] *** [Sno] left
[05:24] *** berekuk joined
[05:27] *** SamuraiJack__ joined
[05:34] *** berekuk left
[05:42] *** berekuk joined
[05:52] *** berekuk left
[05:53] *** BenGoldberg left
[05:54] <dalek> std: 065efb7 | larry++ | STD.pm6:

[05:54] <dalek> std: define winner, combine, etc. as normal blocks

[05:54] <dalek> std: 

[05:54] <dalek> std: For the moment I'm assuming semantic analysis will rule out malformed blocks.

[05:54] <dalek> std: review: https://github.com/perl6/std/commit/065efb7746

[05:56] <dalek> specs: c3fa8ea | larry++ | S17-concurrency.pod:

[05:56] <dalek> specs: remove sig collision with placeholders

[05:56] <dalek> specs: review: https://github.com/perl6/specs/commit/c3fa8ea69f

[06:18] *** FROGGS left
[06:25] *** kaleem joined
[06:27] *** [Sno] joined
[06:36] *** darutoko joined
[06:38] *** btyler left
[06:45] *** xenoterracide_ left
[06:46] *** maja joined
[06:47] *** maja left
[07:03] *** fridim_ left
[07:06] *** btyler joined
[07:10] *** xenoterracide_ joined
[07:16] *** berekuk joined
[07:20] *** dmol joined
[07:37] *** colomon left
[07:37] *** colomon joined
[07:41] *** rindolf joined
[07:43] *** btyler left
[07:55] *** FROGGS joined
[07:55] *** rindolf left
[07:55] *** rindolf joined
[07:56] <FROGGS> morning

[08:03] *** salv0 joined
[08:03] *** colomon left
[08:04] *** colomon joined
[08:06] *** zakharyas joined
[08:11] *** zakharyas left
[08:14] *** nnunley left
[08:17] *** berekuk left
[08:21] *** xenoterracide_ is now known as xenoterracide

[08:24] *** rindolf left
[08:25] *** mtk left
[08:25] *** rindolf joined
[08:25] *** zakharyas joined
[08:30] *** zakharyas left
[08:30] *** daniel-s joined
[08:34] *** berekuk joined
[08:37] *** mtk joined
[08:40] *** colomon left
[08:41] *** colomon joined
[08:44] *** Khisanth left
[08:53] *** frdmn left
[08:58] *** Khisanth joined
[09:01] *** nnunley joined
[09:06] *** nnunley left
[09:25] *** k-ray left
[09:26] *** k-ray joined
[09:34] *** kurahaupo left
[09:40] *** brrt joined
[09:40] *** darutoko left
[09:41] *** fhelmberger joined
[09:44] *** dmol left
[09:44] *** zakharyas joined
[09:49] *** salv0 left
[09:50] *** salv0 joined
[09:51] *** ssutch left
[09:54] *** Vlavv` left
[09:54] *** ssutch joined
[09:57] *** darutoko joined
[09:59] *** hypolin left
[09:59] *** berekuk left
[10:07] *** Vlavv` joined
[10:15] *** ssutch left
[10:25] *** dakkar joined
[10:26] *** adam7504 joined
[10:28] *** xinming left
[10:28] *** xinming joined
[10:28] <timotimo> mroing

[10:29] *** adam7504 left
[10:29] <moritz> who is that mr. oing?

[10:30] <colomon> "It seems like colomon is—or should be—friends with Moritz Lenz. With this in mind, it's worth noting that Moritz has a more consistent weekly schedule. There is also an obvious connection between colomon and Tobias Leich, dagurval, Will Coleda, and Siddhant Saraf." -- http://osrc.dfm.io/colomon

[10:31] <colomon> moritz++

[10:31] <moritz> colomon++

[10:31] <FROGGS> aww

[10:31] * FROGGS has tears in his eyes

[10:31] <FROGGS> :o)

[10:33] <brrt> that is freaky

[10:33] <moritz> it kinda reminds me of what TimToady++ said about me when we first met in Pisa: "one of the best friends I never met"

[10:33] *** dmol joined
[10:33] *** xinming left
[10:33] *** xinming joined
[10:34] *** lambdabot left
[10:35] <timotimo> timo is an exceptional Perl coder (one of the 24% most active Perl users)  -  wat.

[10:36] <timotimo> it's time github learns to differentiate perl from perl6

[10:37] <hoelzro> timotimo: amen

[10:37] <moritz> timotimo: I wonder if it counts commits twice that were brought into a branch by merging another branch, or something

[10:37] * hoelzro is still waiting on that linguist PR

[10:37] <brrt> i'm a javascript dude apparantly

[10:38] <hoelzro> if anyone wants to +1: https://github.com/github/linguist/pull/750

[10:38] <moritz> 'cause it counts as one of the 7% most active perl users, and frankly that can't be true.

[10:40] <timotimo> https://travis-ci.org/github/linguist/builds/13195445  -  maybe you can figure this out, hoelzro?

[10:40] <timotimo> /home/travis/build/github/linguist/lib/linguist/language.rb:240:in `initialize': Perl6 is missing lexer (ArgumentError)

[10:40] <hoelzro> ugh

[10:40] <hoelzro> that's because they don't have the most recent version of pygments.rb

[10:40] <moritz> also it probably says one is a heck of a PIR coder when one updates the nqp-p bootstrap :-)

[10:40] <timotimo> blergh

[10:40] <jnthn> "Jonathan is a fulltime hacker who works best late at night (around 11 pm)."

[10:40] <timotimo> also interesting: /home/travis/build/github/linguist/lib/linguist/language.rb:240:in `initialize': Inno Setup is missing lexer (ArgumentError)

[10:40] *** denis_boyun joined
[10:41] <moritz> hoelzro: maybe add that as a comment to the pull request

[10:41] <jnthn> haha...that bit's accurate

[10:41] <hoelzro> good idea!

[10:41] <moritz> it's funny when they characterize your hobby as a fulltime pursuit :-)

[10:42] <colomon> indeed

[10:42] <colomon> okay, my first dumb question for the morning is: who is Siddhant Saraf?  name sounds familiar...

[10:43] <moritz> colomon: I remember seeing a related nick in here, but I can't recall who it is

[10:43] <moritz> (and maybe if he changed nick, or something)

[10:44] *** xinming left
[10:45] *** xinming joined
[10:46] <FROGGS> moritz: I was once a 6% most active perl user :o)

[10:46] <moritz> FROGGS: let's start some percentile wars! :-)

[10:47] <FROGGS> moritz: np, I'll hack on S11, you?

[10:49] <moritz> FROGGS: I'll hack on the percentiles :-)

[10:50] *** xinming left
[10:50] * moritz doesn't have the energy to take on a p6 project atm

[10:50] *** xinming joined
[10:52] <jnthn> FROGGS: "I was once a 6% most active perl user" ... but then you took a -> to the knee? :)

[10:54] <Ulti> colomon: I also got 'Siddhant Saraf' in my report... and I don't recognise any of the people in my report card :S

[10:54] <moritz> r: use lib $?FILE.path.directory ~ '/lib';

[10:54] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: ( no output )

[10:54] <moritz> r: use lib "$?FILE.path.directory()/lib";

[10:55] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: ( no output )

[10:55] <moritz> r: use lib "$?FILE.path.directory()/lib"; say @*INC.pelr

[10:55] <camelia> rakudo-parrot 087165: OUTPUT«No such method 'pelr' for invocant of type 'Array'␤  in block  at /tmp/Xwaner7r4Y:1␤  in any  at /tmp/Xwaner7r4Y:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles at gen/parro…»

[10:55] <camelia> ..rakudo-jvm 087165: OUTPUT«No such method 'pelr' for invocant of type 'Array'␤  in block  at /tmp/LE_xYWMkmz:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292␤  in any command_eval at gen/jvm/stage2/NQPHLL.nqp:1196␤  in a…»

[10:55] <moritz> r: use lib "$?FILE.path.directory()/lib"; say @*INC.perl

[10:55] <FROGGS> moritz: siddhant contributed to moritz/json, that is all I can see

[10:55] <camelia> rakudo-parrot 087165: OUTPUT«Array.new("/tmp/lib", "/home/p6eval/rakudo-inst-1/lib/parrot/5.9.0-devel/languages/perl6/site/lib", "/home/p6eval/rakudo-inst-1/lib/parrot/5.9.0-devel/languages/perl6/vendor/lib", "/home/p6eval/rakudo-inst-1/lib/parrot/5.9.0-devel/languages/perl6/lib", "…»

[10:55] <camelia> ..rakudo-jvm 087165: OUTPUT«Array.new("/tmp/lib", "/home/p6eval/rakudo-inst-2/languages/perl6/runtime", "/home/p6eval/rakudo-inst-2/languages/perl6/lib", "/home/p6eval/rakudo-inst-2/languages/nqp/lib", "/home/p6eval/rakudo-inst-2/languages/perl6/site/lib", "/home/p6eval/rakudo-inst-2/…»

[10:55] <timotimo> so, for winner $c1, $c2 { more * { ... } }; do i have access to which channel got me the item inside the more block?

[10:55] <timotimo> spec doesn't seem to discuss this

[10:55] <moritz> r: use lib "{$?FILE.path.directory()}/lib"; say @*INC[0]

[10:55] <camelia> rakudo-parrot 087165: OUTPUT«===SORRY!===␤Null PMC access in get_bool()␤»

[10:55] <camelia> ..rakudo-jvm 087165: OUTPUT«/tmp/lib␤»

[10:56] <FROGGS> jnthn: hmmm no, that was this summer when I was more active hacking on v5

[10:56] <timotimo> it only says if there's winner @foobar, the done * block will get k and v named arguments

[10:58] <timotimo> S17 doesn't actually spec the .closed promise on channels

[10:58] <jnthn> Oh? I thought it did...

[11:01] *** brrt left
[11:02] <timotimo> it says "in order to avoid blocking, you can provide a "later" closure", so i suppose if i've gone through all pieces and none matched, i'll create a Promise.anyof for all the involved parties?

[11:02] <timotimo> so that i can block on it?

[11:06] <timotimo> jnthn: i'm not seeing mention of being able to just put a channel into "anyof" and there's no promise for a value to be available from a channel that i could block on

[11:06] <jnthn> The current impl does a Thread.yield and then tries again...

[11:07] <timotimo> ah. i can try that.

[11:07] <jnthn> Which is not awesome but works

[11:08] <timotimo> if i have only promises, i can do the anyof approach, at least.

[11:10] <jnthn> Yeah

[11:16] *** kurahaupo joined
[11:16] *** darutoko- joined
[11:18] <timotimo> now i have some code that i can try to run ...

[11:18] <timotimo> er. that i can try to call. i still need to write test code.

[11:19] *** darutoko left
[11:22] <hoelzro> timotimo++ # pointing out travis failures I was too stupid to see

[11:25] <timotimo> you're welcome :)

[11:25] <timotimo> interestingly the travis failure wasn't pointed out in the global list of pull requests

[11:25] <timotimo> which is something i'd want to see if i was the project maintainer

[11:26] <timotimo> d'oh. i'll have to inspect the signature of the blocks to see if it takes any nameds before i can just blindly throw :k and :v in there :\

[11:27] <timotimo> oh, wha?

[11:27] <timotimo> r: say ({ say $_, $:k, $:v }).signature

[11:27] <camelia> rakudo-parrot 087165, rakudo-jvm 087165: OUTPUT«:(Mu :k(:$k)!, Mu :v(:$v)!)␤»

[11:27] <timotimo> no $_ argument?

[11:31] <FROGGS>  All is well — The Travis CI build passed (Details) 

[11:31] <FROGGS> nice :o)

[11:32] <timotimo> hoelzro: well done :)

[11:32] <timotimo> always amazing what the power of friendship can achieve! :P

[11:32] <timotimo> it can even move mountains (of code)!

[11:33] <hoelzro> =)

[11:35] *** daniel-s left
[11:42] <timotimo> great, at least a part of my code is working! :)

[11:48] <timotimo> yay, i made four promises, one of them a timeout, and WINNER properly blocked and then selected it :)

[11:48] <jnthn> WIN!

[11:50] <nwc10> jnthn: after a long time valgrind does report errors during that backtrack

[11:50] <nwc10> ==9486==  Address 0x3e1bfb42 is 0 bytes after a block of size 2 alloc'd

[11:50] <nwc10> ==9486==    at 0x4C279EE: malloc (vg_replace_malloc.c:270)

[11:50] <nwc10> ==9486==    by 0x4F78558: MVM_string_utf8_encode_substr (utf8.c:288)

[11:50] <nwc10> [snip]

[11:50] <nwc10> also need lunch

[11:50] <nwc10> oh, wrong window. can I just pretend I told #moarvm?

[11:51] <lizmat> good *, #pler6!

[11:51] <hoelzro> ahoy lizmat!

[11:51] <lizmat> .oO( clearly not awake yet)

[11:51] <FROGGS> nwc10: I'm your witness that you said it in #moarvm

[11:51] <FROGGS> hi lizmat 

[11:52] <timotimo> hey lizmat :)

[11:52] *** tgt joined
[11:53] *** denis_boyun left
[11:54] <jnthn> o/ lmizat

[11:55] <jnthn> nwc10: Ah, that's probably it.

[11:56] *** xinming left
[11:57] <timotimo> hm, so can't combine wildcard with non-wildcard?

[11:58] *** xinming joined
[12:02] <dalek> specs: 64c4899 | (Elizabeth Mattijsen)++ | S19-commandline.pod:

[12:02] <dalek> specs: Some clarification on --include / -I

[12:02] <dalek> specs: review: https://github.com/perl6/specs/commit/64c4899fa0

[12:03] <timotimo> okay, i'm kind of sort of confident that my first implementation isn't completely bogus :)

[12:04] <timotimo> https://gist.github.com/timo/7526734 - comments welcome

[12:04] <timotimo> oops. the comment about the loop slid over the invoke_right sub

[12:11] <lizmat> timotimo: there is no sanity check on @winner_args or @pieces being filled with Promise/Channel 

[12:12] <lizmat> only

[12:12] <timotimo> ah, yes.

[12:14] <lizmat> I would suggest dropping the implementation in src/vm/jvm/core/asyncops.pm

[12:14] * lizmat stashes her work in that area

[12:15] <timotimo> that one is so much shorter and easier to read >_<

[12:15] * colomon is deeply regretting not having his main $work repo moved to git at the moment.

[12:17] <timotimo> i can probably split the WINNER sub into two parts, one for no winner_args and one for some winner_args

[12:18] <lizmat> why?

[12:18] <lizmat> wouldn't it make generation of the ops easier if you keep it this way ?

[12:18] <timotimo> because at the moment i just have an all-encompassing if for that :P

[12:18] <timotimo> it would?

[12:19] <lizmat> hmmm...  perhaps not

[12:19] <lizmat> I gues in the future, you could figure out at compile time whether you would just have promises or channels

[12:19] <timotimo> that's not very easy :)

[12:19] <timotimo> i'm more interested in getting rid of the invoke_right sub for each call

[12:21] *** Rix left
[12:23] *** pernatiy left
[12:31] <tadzik> hello from europe o/

[12:32] <lizmat> tadzik!

[12:32] <tadzik> lizmat!

[12:33] <jnthn> o/ tadzik 

[12:33] <jnthn> Hope your journey back was fine

[12:34] <tadzik> yeah, and it seems like I managed to adjust to time travel quite seemlessly :)

[12:34] <tadzik> timezones, that is

[12:38] * timotimo takes a walk

[12:42] <FROGGS> hi tadzik!

[12:42] <tadzik> hi FROGGS!

[12:47] <rindolf> FROGGS: hi.

[12:47] <FROGGS> hi rindolf 

[12:47] <rindolf> tadzik: hello from Israel.

[12:47] <rindolf> FROGGS: what's up?

[12:47] <FROGGS> $work :o(

[12:49] *** Rix joined
[12:59] <diakopter> whee seemles

[13:00] <diakopter> so seam

[13:03] *** SamuraiJack__ left
[13:12] <lizmat> r: <a b c>.Bag.roll(*).say  # this should hang

[13:12] <camelia> rakudo-parrot 087165: OUTPUT«b b a␤»

[13:12] <camelia> ..rakudo-jvm 087165: OUTPUT«a c c␤»

[13:13] * lizmat just realized that .roll is incorrectly implemented on Bags/Mixes

[13:16] *** dayangkun joined
[13:16] *** dayangkun left
[13:17] *** mtk left
[13:21] *** mtk joined
[13:24] *** berekuk joined
[13:24] *** colomon left
[13:25] *** pernatiy joined
[13:29] *** kaleem left
[13:36] <dalek> rakudo/nom: 2f18b45 | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[13:36] <dalek> rakudo/nom: Fix (Bag|BagHash).roll(*)

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f18b45520

[13:38] *** xinming left
[13:42] *** darutoko- left
[13:42] *** darutoko joined
[13:43] *** xinming joined
[13:44] *** dmol left
[13:51] *** ajr joined
[13:51] *** ajr is now known as Guest40938

[13:52] *** Guest40938 is now known as ajr_

[13:52] *** kaleem joined
[13:53] *** Rix left
[14:00] *** Rix joined
[14:01] *** PacoAir joined
[14:01] *** kaleem left
[14:05] <dalek> roast: d12ea39 | (Elizabeth Mattijsen)++ | S02-types/bag (2 files):

[14:05] <dalek> roast: Add tests for (Bag|BagHash).roll(*)

[14:05] <dalek> roast: review: https://github.com/perl6/roast/commit/d12ea39b21

[14:06] *** jeff_s1 left
[14:10] *** jeff_s1 joined
[14:12] *** itz_ joined
[14:15] *** itz left
[14:16] *** denis_boyun joined
[14:17] *** itz_ left
[14:17] *** nnunley joined
[14:18] *** itz joined
[14:24] <timotimo> can i put the return value of $*W.find_symbol directly into a QAST::Op? i want to :op('callmethod'), :name('new'), $*W.find_symbol(['List'])

[14:25] *** jeff_s1 left
[14:25] <jnthn> No

[14:26] <jnthn> Wrap it in a QAST::WVal

[14:27] <dalek> specs: d0e9368 | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[14:27] <dalek> specs: Elaborate a bit more about (Bag|BagHash).pickpairs

[14:27] <dalek> specs: review: https://github.com/perl6/specs/commit/d0e9368035

[14:27] <timotimo> OK

[14:27] <timotimo> how do i supply things as named arguments?

[14:27] <dalek> rakudo/nom: 5677bfb | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[14:27] <dalek> rakudo/nom: Implement (Bag|BagHash).pickpairs

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5677bfb880

[14:28] <jnthn> :named('the_name')

[14:28] <jnthn> On the node that you're passing as an argumnt

[14:28] <timotimo> ah. i'll have to put those in *Vals anyway

[14:29] <timotimo> er. except ...

[14:30] <timotimo> the .ast values of a pblock or a block can just go into a QAST, right? well, that would only make sense.

[14:31] <timotimo> first version i can attempt to compile ... :)

[14:33] *** denis_boyun left
[14:36] <timotimo> now it complains about wrong winner's in the statement :)

[14:36] <timotimo> not very helpfully, though

[14:37] *** lowpro30 joined
[14:37] <moritz> the last will be winners!

[14:39] *** btyler joined
[14:40] <timotimo> huh. it says "missing block" (well, it tries to, anyway)

[14:41] <timotimo> winner { more $self { $_ }; done $self { last } };  -  this should match the following rules, i think:

[14:42] <timotimo> rule statement_control:sym<winner> { <sym> [<xblock>|<block>] }; rule statement_control:sym<more> { <sym> <xblock> }; rule statement_control:sym<done> { <sym> <xblock> }

[14:42] <timotimo> what am i missing?

[14:43] <moritz> what exactly does xblock match?

[14:43] <moritz> more $self { $_ } looks suspiciously like two terms in a row to me

[14:43] <jnthn> xblock is expression block

[14:43] <jnthn> mathces an EXPR then a pblock iirc

[14:44] <timotimo> yes, that's it

[14:44] <moritz> ah right

[14:44] <jnthn> Do we get sigspace stuff right enough to sue rule there instead of token?

[14:44] <timotimo> oh

[14:45] <timotimo> we recently had some improvements there, but i can turn it into the other thing. do i need to put <.ws> between <sym> and the group then?

[14:45] <jnthn> I think Mouq++ did a load of work on that so it may all be good already; just a thought.

[14:46] <timotimo> the <.missing: 'block'> seems to come from inside <block> if it doesn't match a {

[14:46] <moritz> timotimo: maybe just try smaller snippets first?

[14:46] <moritz> to find out if it's winner, more or done that triggers the problem

[14:46] <timotimo> right. i should stub it out of the setting so that i can quickly experiment with different code snippets

[14:47] <FROGGS> damnit, that was hard to spot:

[14:47] <FROGGS> rp: my %r; %r{~$<a>}.push(~$<b); for %r.kv -> $n, $v { }

[14:47] <camelia> rakudo-parrot 2f18b4: OUTPUT«===SORRY!=== Error while compiling /tmp/X7f6m9Hqze␤Unable to parse expression in argument list; couldn't find final ')' ␤at /tmp/X7f6m9Hqze:1␤------>  %r; %r{~$<a>}.push(~$<b); for %r.kv -> ⏏$n, $v { }␤    e…»

[14:47] <moritz> $<b

[14:47] <timotimo> oh wow :)

[14:47] <timotimo> especially since you had a -> in there

[14:48] <FROGGS> moritz: my variable names are longer... took me five minutes :o)

[14:48] <FROGGS> moritz++ # I'll just ask you next time

[14:48] *** kivutar joined
[14:48] <moritz> a pair of "fresh" eyes often help a lot

[14:48] *** itz_ joined
[14:51] *** itz left
[14:52] *** jeff_s1 joined
[14:56] *** itz joined
[14:56] *** jnap joined
[14:57] *** fridim_ joined
[14:58] <timotimo> say winner $p1, $p2, $p3 ⏏{  -  this TTIAR's :(

[14:58] <timotimo> but i don't think it should, since i offer xblock and block as alternatives

[14:58] *** itz_ left
[14:59] * timotimo tries <block> || <xblock> instead

[14:59] <moritz> isn't there a precedence limit on the expression in pblock?

[14:59] <moritz> try  winner ($p1, $p2, $p3) { }  for the lulz

[14:59] <timotimo> oh, perhaps

[15:00] <timotimo> i'm amidst a recompile, though

[15:00] <timotimo> i guess i can look at the implementation of for for inspiration

[15:01] <timotimo> oh, perhaps i need to replace say winner with say do winner

[15:02] <moritz> erm, yes

[15:02] <moritz> since it's statement_control, it's for *statements*, not expressions

[15:02] <timotimo> whoops, that explodes in a different way :)

[15:02] <moritz> timotimo: and your example code didn't include a say :-)

[15:02] <timotimo> naughty me!

[15:05] <timotimo> my @inner_statements := $<xblock><pblock><blockoid><statementlist><statement>; for @inner_statements -> $/ { ... }; why does this say Can only use iter with representation VMArray and VMHash? shouldn't that <statement> be a list of statements?

[15:05] <timotimo> <statementlist> looks like this:

[15:05] <timotimo> ... ... [ <statement> <.eat_terminator> ]*

[15:06] <moritz> try  say(@inner_statements.HOW.name(@inner_statements))

[15:06] <timotimo> OK

[15:06] <moritz> it might not actually be an array, dunno

[15:06] *** lowpro30_ joined
[15:07] <moritz> also, remember that NQP line numbers are often offby1

[15:07] <timotimo> right.

[15:07] <timotimo> that's the only for anywhere nearby, though :)

[15:08] <moritz> it would be awesome if the error message included type name and REPR name :-)

[15:08] <timotimo> hehe.

[15:09] <timotimo> NQPMu, as i feared :(

[15:09] *** berekuk left
[15:10] <timotimo> found my mistake, too

[15:10] *** lowpro30 left
[15:10] *** lowpro30 joined
[15:12] *** lowpro30_ left
[15:12] * timotimo is not quite there

[15:13] <timotimo> it's tough, because where i'm at in the parse, { could be the beginning of an EXPR that we want to have, or the beginning of the winner block

[15:14] <jnthn> Well, can always cheat and look ahead...

[15:14] <timotimo> that's what i thought, too :)

[15:14] <jnthn> <?before <.lambda> | '{'> # :P

[15:14] <timotimo> i'm not sure accepting lambda would be a good idea

[15:14] <jnthn> uh, I guess it's just '{' in this case

[15:15] <jnthn> yeah, confused it with more/done, which always need the EXPR

[15:15] *** thou joined
[15:15] *** salv0 left
[15:16] *** lowpro30 left
[15:16] <timotimo> xblock and block both explode if there's no {

[15:16] <timotimo> rather than failing to parse and letting me try again further up the stack

[15:17] *** lowpro30 joined
[15:18] <timotimo> Method 'named' not found for invocant of class 'NQPMu'  -  hurm, again something non-matchy in my matches

[15:19] <timotimo> my Whatever recognition is apparently not correct

[15:21] <timotimo> oh, no, there actually is a whatever in my source code, so it's likely working

[15:21] <timotimo> i wonder what goes wrong, though

[15:25] *** lowpro30 left
[15:25] * timotimo finally wises up and uses $/.dump

[15:30] <timotimo> https://gist.github.com/timo/aa7e2bbe7a18de69b1fe  -  this is my $/, i'm getting $<xblock><pblock>.ast and try to set .named on it, but Method 'named' not found for invocant of class 'NQPMu'

[15:30] <timotimo> ?!?

[15:30] *** berekuk joined
[15:31] <timotimo> D'OH

[15:31] *** jeff_s1 left
[15:31] <timotimo> i had $wild_done := ...ast; $wild_more.named('wild_done');

[15:32] <diakopter> lizmat: ok, how did booking.com know to send me a hotel reservation suggestion for a tiny town I was driving through 2 nights ago... when I don't remember doing any google searches and certainly no hotel searches during that time or about that night...?

[15:32] <timotimo> they are watching you.

[15:32] <lizmat> are you on facebook?

[15:32] <diakopter> nope

[15:32] <diakopter> well, yes, but haven't logged in in years

[15:32] *** eternaleye left
[15:32] <lizmat> do you have a facebook app on your phone ?

[15:33] <diakopter> nope

[15:33] <lizmat> then I've run out of ideas

[15:33] <timotimo> it parses \o/

[15:34] <lizmat> doing google searches is the most likely way of getting this

[15:34] <lizmat> the other is searching for a hotel on the booking.com site and not making a reservation

[15:34] <diakopter> 'course, the suggestion was two days late..

[15:34] <lizmat> and yes, we're all being followed

[15:35] <lizmat> then it cost B money, and they will stop doing it  :-)

[15:36] *** davecc` left
[15:37] *** eternaleye joined
[15:38] *** FROGGS left
[15:38] <timotimo> i think the signatures aren't getting set properly :(

[15:40] <timotimo> pblock: { say "wildcard done: $_" }  -  like this? should be right, IMO.

[15:40] *** jeff_s1 joined
[15:41] *** berekuk left
[15:42] <diakopter> tadzik: how many 'thor god of thunder' mutterings did you get to

[15:43] <dalek> specs: 155abd8 | (Elizabeth Mattijsen)++ | S32-setting-library/Containers.pod:

[15:43] <dalek> specs: (Bag|BagHash).pickpairs are more like .grabpairs

[15:43] <dalek> specs: review: https://github.com/perl6/specs/commit/155abd87df

[15:44] *** jeff_s2 joined
[15:44] <timotimo> huh, do i have to -> $_ in order for it to take $_ ?!

[15:44] <timotimo> i thought if i used $_ inside the block somewhere and don't give a different implicit signature, it would Just Work

[15:45] *** jeff_s1 left
[15:45] <moritz> it does, when the compiler handles it correctly :-)

[15:46] <timotimo> huh. i have to do some manual work, then? :(

[15:46] <timotimo> ah, probably just have to call block_closure($<foo><pblock>.ast)

[15:47] <jnthn> timotimo: look up $*IMPLICIT

[15:47] <timotimo> will do

[15:47] <jnthn> timotimo: iirc you may want <xblock(1)>

[15:48] <timotimo> ah, sure :)

[15:48] <timotimo> thanks

[15:48] <timotimo> do i need block_closure, too?

[15:49] <jnthn> probably

[15:50] <timotimo> thank you :)

[15:50] <timotimo> i'm real close now

[15:52] <timotimo> .o( you bring me closure to god )

[15:55] <timotimo> okay, now let's try to put the winners back into the setting

[15:59] <timotimo> https://github.com/rakudo/rakudo/blob/nom/src/vm/jvm/core/Supply.pm#L57 - i don't understand this line

[16:00] *** berekuk joined
[16:04] <tadzik> diakopter: free hundred firty free fousand, froughly

[16:04] <timotimo> tadfik if nomming cookief again?

[16:04] <tadzik> yeah, and writing my bachelor feces :P

[16:05] <timotimo> :D

[16:05] <dalek> rakudo/WINNER: b76c38c | (Timo Paulssen)++ | src/ (3 files):

[16:05] <dalek> rakudo/WINNER: implement winner syntax and WINNER sub.

[16:05] <dalek> rakudo/WINNER: review: https://github.com/rakudo/rakudo/commit/b76c38cd73

[16:05] <dalek> rakudo/WINNER: 3129cb7 | (Timo Paulssen)++ | src/vm/jvm/core/ (2 files):

[16:05] <dalek> rakudo/WINNER: update usages of winner in the setting

[16:05] <dalek> rakudo/WINNER: review: https://github.com/rakudo/rakudo/commit/3129cb7efa

[16:05] <timotimo> something for you to play with

[16:05] <tadzik> WINRAR

[16:06] *** jeff_s1 joined
[16:06] *** jeff_s2 left
[16:07] <lizmat> timotimo: that line in Supply.pm is a Promise

[16:07] <timotimo> yeah, but why call .result on it, then last out of the loop?

[16:07] *** jaffa4 joined
[16:07] <jaffa4> hi all

[16:07] <timotimo> hi jaffa4 :)

[16:07] <jaffa4> have you seen module Perl6::Format?

[16:07] <lizmat> wouldn't that throw the exception if any ?

[16:08] <timotimo> oh, that's a good point actually

[16:08] <timotimo> i'll be AFK for a bit, would you be interested in making my modified versions of these things throw any given exception as well?

[16:08] <timotimo> though perhaps exceptions are already thrown inside WINNER, i'm not sure

[16:08] <timotimo> i have yet to change all winners in the spectests to the new syntax to try out all those cases

[16:09] <TimToady> what a slacker! :)

[16:09] *** itz left
[16:09] <TimToady> timotimo++

[16:11] <lizmat> indeed, timotimo++

[16:11] *** itz joined
[16:13] *** jeff_s1 left
[16:14] <dalek> rakudo/nom: 376b309 | (Elizabeth Mattijsen)++ | src/core/Baggy.pm:

[16:14] <dalek> rakudo/nom: Fix (Bag|BagHash).pickpairs

[16:14] <dalek> rakudo/nom: 

[16:14] <dalek> rakudo/nom: Found thanks to writing tests  :-)

[16:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/376b309f78

[16:16] <dalek> roast: 987bced | (Elizabeth Mattijsen)++ | S02-types/bag (2 files):

[16:16] <dalek> roast: Add tests for (Bag|BagHash).pickpairs

[16:16] <dalek> roast: review: https://github.com/perl6/roast/commit/987bcedb51

[16:17] <lizmat> TimToady: shouldn't Array and Hash not have .grab / .grabpairs / .pickpairs / .rollpairs ?

[16:19] * jnthn wonders if that double negation was intended :)

[16:20] <lizmat> I shouldn't think not

[16:21] * TimToady is starting to think something isn't factored right

[16:21] <TimToady> or 'isn't' if you speak Neglish.

[16:21] *** ajr_ left
[16:22] <lizmat> can't say that ain't true

[16:22] * TimToady is still in early morning free-association mode, but would a :pairs adverb work better rather than doubling all the method named?

[16:23] *** ajr joined
[16:23] <TimToady> "All music is folk music.  Ain't never heard no horse sing no song." --Louis Armstrong

[16:23] *** ajr is now known as Guest65226

[16:24] <diakopter> TimToady: all the built-in methods and typenames and keywords need single-char hangul shorthand. yes.

[16:24] <TimToady> hmm, are they all unique in the first 3 letters?

[16:24] * TimToady doubts it

[16:25] *** SamuraiJack__ joined
[16:26] *** sahadev joined
[16:27] *** [Sno] left
[16:29] *** Guest65226 left
[16:30] *** ajr_ joined
[16:31] *** denis_boyun joined
[16:33] *** groky joined
[16:34] <lizmat> TimToady: so, make a :p named parameter to .pick ?

[16:34] <lizmat> and a :delete one as well, to take care of .grab ?

[16:35] *** WAE3I2E joined
[16:35] *** renormalist joined
[16:36] <TimToady> not sure I want to mess with the pick/grab distinction, since we're dealing with mutability

[16:37] <lizmat> true

[16:37] *** fridim_ left
[16:38] <lizmat> r: (1,2,3).Bag.grab.say

[16:38] *** groky left
[16:38] <TimToady> we've mostly ended up differentiating names when that distinction is in effect

[16:38] <camelia> rakudo-jvm 5677bf: OUTPUT«Cannot call 'grab' on an immutable 'Bag'␤  in block  at /tmp/mQ_ciPr18d:1␤  in any eval at gen/jvm/stage2/NQPHLL.nqp:1086␤  in any evalfiles at gen/jvm/stage2/NQPHLL.nqp:1292␤  in any command_eval at gen/jvm/stage2/NQPHLL.nqp:1196␤  in any command…»

[16:38] <camelia> ..rakudo-parrot 5677bf: OUTPUT«Cannot call 'grab' on an immutable 'Bag'␤  in block  at /tmp/YYleWW6Wkr:1␤  in any  at /tmp/YYleWW6Wkr:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles at gen/parrot/stage2/N…»

[16:39] <TimToady> quietfanatic++ has urged me to unify all those mutable/immutable name distinctions, but he can try that in his own language :)

[16:39] * TimToady suspects it would be a confusing orthogonality

[16:41] * lizmat doesn't want to get into any family quarrel :-)

[16:41] *** denis_boyun left
[16:42] <TimToady> we'd have to adopt you first :)

[16:42] *** denis_boyun_ joined
[16:42] <lizmat> I'll take that a compliment :-)

[16:45] *** kaleem joined
[16:47] <lizmat> anyways, I was just going through the spec and noticed that both colomon++ and me missed "pickpairs", which had been specced in Jan 2012 by a Larry Wall

[16:47] <TimToady> well, he's an idiot :)

[16:48] <lizmat> now now, let's keep this civilized  :-)

[16:48] <TimToady> you shouldn't trust him around Perl 6, since, according to github, "In particular, Larry seems to be a pretty serious Perl expert."

[16:49] <TimToady> doubtless he'll try to bend Perl 6 into resembling Perl

[16:49] *** ajr_ left
[16:49] <lizmat> well, I don't know how serious he is, but he is pretty pretty  :-)

[16:49] *** FOAD left
[16:49] *** FOAD joined
[16:50] *** denis_boyun_ left
[16:50] *** ajr_ joined
[16:50] * TimToady blushes

[16:52] <TimToady> well of course Perl 6 is missing lexer, it writes its own...

[16:52] *** ssutch joined
[16:53] <diakopter> r-j: ENOLEXER

[16:53] <camelia> rakudo-jvm 5677bf: OUTPUT«===SORRY!=== Error while compiling /tmp/9agFu0TYfa␤Undeclared name:␤    ENOLEXER used at line 1␤␤»

[16:53] <diakopter> r-j: >ENOLEXER

[16:53] <camelia> rakudo-jvm 5677bf: OUTPUT«===SORRY!=== Error while compiling /tmp/sQmNPLih4L␤Preceding context expects a term, but found infix > instead␤at /tmp/sQmNPLih4L:1␤------> >⏏ENOLEXER␤»

[16:53] *** zakharyas left
[16:54] <timotimo> jaffa4: sorry, i was AFK (as i mentioned above)

[16:54] <grondilu> r-p: say "parrot"

[16:54] <camelia> rakudo-parrot 5677bf: OUTPUT«parrot␤»

[16:55] <grondilu> r-p: sub f($k) { [*] 1 .. $k }; say f(0)

[16:55] <camelia> rakudo-parrot 5677bf: OUTPUT«1␤»

[16:55] <TimToady> why do people always start that at 1?

[16:55] <TimToady> r-p: sub f($k) { [*] 2 .. $k }; say f(0)

[16:55] <camelia> rakudo-parrot 5677bf: OUTPUT«1␤»

[16:55] <TimToady> works just as well

[16:56] <jaffa4> sorry who wrote a lexer?

[16:56] <grondilu> r-p: sub binomial($n, $k) { ([*] $n, $n-1 ... $n-$k+1) / [*] 1 .. $k }; say binomial(5, 0)

[16:56] <camelia> rakudo-parrot 5677bf: OUTPUT«(timeout)»

[16:56] * TimToady wrote a lexer once...

[16:56] <jaffa4> for perl 5?

[16:56] <grondilu> r-p: sub binomial($n, $k) { ([*] $n-$k+1 .. $n) / [*] 1 .. $k }; say binomial(5, 0)

[16:57] <camelia> rakudo-parrot 5677bf: OUTPUT«1␤»

[16:57] <grondilu> r-p: sub binomial($n, $k) { ([*] $n-$k+1 .. $n) / [*] 1 .. $k }; say binomial(5, 3)

[16:57] <camelia> rakudo-parrot 5677bf: OUTPUT«10␤»

[16:58] <TimToady> since then I've only written metalexers

[16:58] <TimToady> .oO(whatever an exer is...)

[16:58] *** larks joined
[16:59] <lizmat> Ah, I remember the days of the woodexer...   

[16:59] *** FROGGS joined
[16:59] <lizmat> the steamexer was already much better

[17:02] <diakopter> an exer results from a lurgist

[17:03] <timotimo> oh, there aren't even tests for "winner" in roast yet

[17:03] <timotimo> it's only used once for supply tests

[17:03] <lizmat> timotimo: yes

[17:04] <lizmat> I was waiting to write more until the spec had settled a bit more

[17:04] * timotimo knows what he'll spend the rest of the evening doing, after he commutes or and dinners

[17:04] *** itz left
[17:04] <lizmat> fwiw, I would be ok with merging the WINNER branch

[17:04] <jnthn> It's quite funny that it's only tested in supply test, given winner doesn't work on supplies :)

[17:05] <lizmat> well, I guess we can blame the original author of the tests...  :-)

[17:05] <jnthn> The author blames Croatian beer and slivovica :P

[17:05] <lizmat> eh, why wouldn't winner work on supplies ?

[17:05] <jnthn> lizmat: Because you don't ask a supply for a value.

[17:06] <jnthn> lizmat: It supplies the values to you.

[17:06] <timotimo> lizmat: i'll write lots of spectests before i give my blessing, though :P

[17:06] *** itz joined
[17:07] *** eternaleye left
[17:07] * jnthn was a little surprised to see channels referred to as a reactive thingy, which they kinda ain't. You synchronously pull from 'em.

[17:07] <TimToady> rather than going through parsing shenanigans, I'd wondered whether we should just require 'winner * {' when we want the list intuited

[17:07] <lizmat> indeed.. however, the test is for a Channel derived from a supply

[17:07] <jnthn> Promises are a bit of both. You can poll for the result, but .then is reactive.

[17:08] <jnthn> Supplies are completely reactive.

[17:08] <TimToady> $channel.list is kinda reactive the same way

[17:08] <jnthn> TimToady: Yes, that's a curious construct. :)

[17:09] <TimToady> well, we do need to bridge the two worlds from time to time

[17:09] <jnthn> TimToady: I guess .list on a supply is a kind of subscribe in a gather/take...

[17:09] <jnthn> Yes, we do. Bridging all the paradigms we provide matters.

[17:09] <jnthn> otoh, we need to make it explicit enough that it conveys, "this is probably gonna cost you"

[17:09] <TimToady> putting good Spock on the evil bridge, and vice versa

[17:10] <timotimo> i should publish a module ACME::Python that, when used, just dies with "NO LOL"

[17:10] <TimToady> oh wait, it's Kirk that swapped

[17:10] <timotimo> er, Acme::Python

[17:10] <jnthn> timotimo: It should sovle one of the euler problems too, just to be classy.

[17:12] <timotimo> classy indeed

[17:13] <TimToady> we we make the arguments optional to winner, next thing people will want to drop the parens around the arg to loop...

[17:13] <TimToady> s/we/if

[17:13] <timotimo> i'm fine with requiring a * at least.

[17:13] <TimToady> weird typos...

[17:13] <TimToady> or a ()

[17:14] <timotimo> hm

[17:14] <TimToady> but * conveys the spirit better

[17:14] <TimToady> "whatever is used below"

[17:14] <timotimo> i like * better than ().

[17:14] <TimToady> that's why I just used xblock in STD

[17:15] *** eternaleye joined
[17:15] <TimToady> std: winner * { }

[17:15] <camelia> std 065efb7: OUTPUT«ok 00:01 123m␤»

[17:15] <TimToady> std: winner { }

[17:15] <lizmat> winner $p1, @other { done $p1 {...} done @othter { ... } }

[17:15] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Expression needs parens to avoid gobbling block at /tmp/b_UXw55NOF line 1:␤------> winner ⏏{ }␤Missing block (apparently gobbled by expression) at /tmp/b_UXw55NOF line 1:␤------> winner { }⏏…»

[17:15] <timotimo> yes, i was wondering about that.

[17:16] <lizmat> winner $p1, @other { done $p1 {...} done @othter { ... } }   # wouldn't that make more sense ?

[17:16] <lizmat> (apart from the typo)

[17:17] * TimToady also wonders whether people are inadvertently going to try to use 'winner LIST ' to mean '(race LIST)[0]'

[17:17] <TimToady> why not done * instead?

[17:18] <lizmat> shouldn't done not accept a list of promises/channels as well

[17:18] <lizmat> winner $p1, $p1, @other { done $p1,$p2 {...} done @other { ... } }

[17:18] <TimToady> well, syntactically, it could

[17:18] <TimToady> seems supportable

[17:19] <lizmat> then done * would need to be the ones that weren't listed before

[17:19] <TimToady> right

[17:19] <lizmat> and that could be done once

[17:19] <TimToady> and later could become done none() :)

[17:19] <lizmat> unless we're going to allow for slices: done @other[^3]

[17:20] <lizmat> well, I don't like "none" really, as it doesn't convey the timeliness of it

[17:20] <timotimo> as soon as we support lists after done, slice support will happen automatically

[17:20] <lizmat> "idle" conveys that more to me

[17:20] <timotimo> at least i think it would, given my current implementation and how i'd change it to support lists as arguments for done/more blocks

[17:21] <TimToady> well, for a while it was 'notyet'

[17:21] <TimToady> maybe we should call it 'crickets'  :)

[17:22] <timotimo> in that case, i want "tumbleweed" to exist somewhere

[17:22] <TimToady> 'silence'

[17:23] <lizmat> silence I like

[17:23] <TimToady> if this were COBOL it would be something like INDETERMINATE

[17:23] <lizmat> can we also rename "done" to "tinnitus" then ?

[17:23] <timotimo> hoelzro: maybe the linguist maintainer would be more likely to merge your PR if you rebased it on the current master?

[17:24] <TimToady> lizmat: that's more like 'more'

[17:24] <TimToady> 'done' is just the transition from tinnitus to silence

[17:24] <lizmat> ah, I wish it was that easily done

[17:25] *** jeff_s1 joined
[17:25] <TimToady> moi ausi

[17:25] <TimToady> or is that aussi?

[17:26] <hoelzro> timotimo: good idea, I'll try that!

[17:27] <timotimo> that may make your pygments.rb version bump unnecessary

[17:27] <lizmat> aussi, oui

[17:27] * TimToady should probably study French once he finishes Japanese, Mandarin, Spanish, and Basque...

[17:28] <TimToady> Agur!

[17:28] <hoelzro> timotimo: from what I can see, it's already up-to-date

[17:28] *** dmol joined
[17:29] <timotimo> ah, yes

[17:29] <timotimo> i had been looking at a network graph from 10 hours ago

[17:31] <TimToady> and maybe some Russian or Australian...

[17:32] <TimToady> G'die!

[17:32] <TimToady> G'die might!

[17:33] <timotimo> http://questhub.io/realm/perl/quest/52895c109f567afb5300002f - feel free to like my quest :P

[17:33] <lizmat> :-)

[17:33] <TimToady> What is your favorite colour?

[17:34] <timotimo> :D

[17:35] *** kaleem left
[17:35] <lizmat> I'm taking the 5th

[17:35] *** [Sno] joined
[17:35] <lizmat> timotimo: I could write winner tests

[17:36] <timotimo> feel free :)

[17:36] <timotimo> it's always better to hvae someone write the test who didn't write the implementation

[17:36] <lizmat> agree

[17:36] <TimToady> obviously Black is your favorite color

[17:37] <timotimo> Block is my favourite color :D

[17:37] <TimToady> .oO(Black Boxing Day)

[17:39] <kurahaupo> Aussies are asleep, but Kiwis are just waking up: gudday met

[17:40] <dalek> roast: a115250 | (Elizabeth Mattijsen)++ | S17-concurrency/ (2 files):

[17:40] <dalek> roast: Start winner.t by taking winner test from supply.t

[17:40] <dalek> roast: review: https://github.com/perl6/roast/commit/a115250fbf

[17:40] <TimToady> kurahaupo: sure, but it's the wrong day

[17:41] <dalek> roast: d986524 | (Elizabeth Mattijsen)++ | S17-concurrency/supply.t:

[17:41] <dalek> roast: Get the administratrivia right for supply.t

[17:41] <dalek> roast: review: https://github.com/perl6/roast/commit/d986524d21

[17:41] <TimToady> you shoulda wished me a gudday yesterday so it would happen today

[17:42] <dalek> rakudo/nom: 75c45f3 | (Elizabeth Mattijsen)++ | t/spectest.data:

[17:42] <dalek> rakudo/nom: Make sure we roast winner.t

[17:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/75c45f33e8

[17:43] <timotimo> you could have left out winner.t for rakudo/nom and only put it in rakudo/WINNER

[17:43] <TimToady> International Date Line: "Hi, I'm an ASCII--what's your encoding?"

[17:43] <timotimo> it would have been added properly by the merge later

[17:44] *** kivutar left
[17:45] *** rurban1 joined
[17:46] <dalek> roast: 32b8975 | (Elizabeth Mattijsen)++ | S02-types/mix (2 files):

[17:46] <dalek> roast: Add tests for (Mix|MixHash).roll(*)

[17:46] <dalek> roast: review: https://github.com/perl6/roast/commit/32b8975037

[17:46] <kurahaupo> TimToady. mundy, chezdy, waddeva

[17:46] <lizmat> timotimo: I guess you're right

[17:46] <lizmat> on the other hand, all tests will need to be marked skip atm anyway

[17:47] <kurahaupo> TimToady: good morning, anyway.

[17:47] *** kaare_ joined
[17:48] <TimToady> troo

[17:50] * kurahaupo enjoys how #perl6 sometimes transmogrifies into #linguisticsforgeeks

[17:51] *** ajr joined
[17:51] *** ajr_ left
[17:51] *** ajr is now known as Guest61759

[17:51] * TimToady finds it extrememly painful, but then, he's a masochist...

[17:53] *** Guest61759 is now known as ajr_

[17:56] <TimToady> nothing, nada, nobodyhome, nosuchluck, betterlucknexttime, elsewhen

[17:57] <TimToady> actually, 'nobody' is the right length to line up with 'done *'

[17:57] <TimToady> and 'nobody is the winner' makes perfect sense

[17:58] <lizmat> but then "done" doesn't make sense

[17:58] *** fhelmberger_ joined
[17:59] <lizmat> I would suggest "first" if it hadn't another meaning already

[17:59] <dalek> specs: 0eedbb4 | larry++ | S17-concurrency.pod:

[17:59] <dalek> specs: s/later/nobody/

[17:59] <dalek> specs: review: https://github.com/perl6/specs/commit/0eedbb49dd

[18:00] <TimToady> "I have more!" "I am done!" "I am nobody!"

[18:01] <lizmat> s/done/prize/ ?

[18:01] <TimToady> need to rename 'more' to something that works with 'I am ____.' with four letters

[18:01] *** dakkar left
[18:01] *** eternaleye left
[18:01] <TimToady> 'I am here!'

[18:01] *** fhelmberger left
[18:02] <TimToady> $channel.here($x);  # take this

[18:03] *** fhelmberger_ left
[18:03] <TimToady> "Oh wow, here it is!"

[18:04] <TimToady> 'here' also implies more discreteness than 'more'

[18:05] *** eternaleye joined
[18:06] <TimToady> not so good at the 'one item out of many' concept though...

[18:08] *** beastd joined
[18:10] *** rurban1 left
[18:10] *** rurban1 joined
[18:14] <TimToady> well, 'data' is a four-letter word

[18:14] <TimToady> probably a mistake to have two words starting with 'd' though

[18:14] <lizmat> duhh!

[18:15] <TimToady> and failure could be 'doh!'

[18:18] <TimToady> unfortunately, 'item' is also taken, if not on the keyword end, on the method end

[18:19] <TimToady> well, I suppose item could be overloaded on a channel without bothering lists

[18:19] <TimToady> would be slightly less confusing than overloading 'next'

[18:25] *** ajr_ left
[18:25] *** rindolf left
[18:25] *** rindolf joined
[18:30] *** xinming left
[18:30] *** xinming joined
[18:35] *** wtw joined
[18:36] * lizmat is off to see Gravity 3D

[18:40] <timotimo> you promised me tests ;_;

[18:41] <lizmat> the day is not over yet ;-)

[18:41] <timotimo> okay

[18:41] <timotimo> i'll get to implementing the new changes then

[18:43] <lizmat> back in ~ 2.5 hour

[18:44] *** pernatiy left
[18:47] *** Duchess joined
[18:50] *** kurahaupo left
[18:50] *** Eily left
[18:52] *** rindolf left
[18:53] *** xenoterracide left
[18:53] <timotimo> r: my &foo = -> $foo { }; say &foo.signature.params[0].^methods

[18:53] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: OUTPUT«<anon> <anon> <anon> <anon> <anon> <anon> <anon> name constraint_list constraints type named named_names positional slurpy optional parcel capture rw copy readonly invocant default type_captures sub_signature perl␤»

[18:53] <timotimo> r: my &foo = -> $foo { }; say &foo.signature.params[0].positional

[18:53] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: OUTPUT«True␤»

[18:53] *** rindolf joined
[18:53] *** hummeleB1 left
[18:54] *** xenoterracide joined
[18:58] *** xinming left
[18:59] *** xinming joined
[19:00] *** dmol1 joined
[19:00] *** dmol left
[19:02] <jaffa4> How to check a group is matched?

[19:05] *** Rotwang joined
[19:06] <timotimo> jaffa4: the match object will be falsy, for example

[19:07] <timotimo> bleh, it'd be a lot of work to make the random selection of candidates fair when supplying lists of things for more/done blocks

[19:07] *** SamuraiJack__ left
[19:07] <timotimo> i'd have to mess with bags or something

[19:09] *** FROGGS[mobile] joined
[19:09] <jnthn> timotimo: Just get the total number of things, get a random number between that and 0 and that, and then if it's greater than the number of things in the first array go for something in the second.

[19:12] *** xinming left
[19:13] <timotimo> mhm, i feared as much :)

[19:13] *** xinming joined
[19:14] <timotimo> or i could just, you know, use a bag :)

[19:18] <jnthn> Yeah, that'll be fast :P

[19:18] <jaffa4> this always makes $/[0] true while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/)

[19:19] <timotimo> oh damn. now i'm still running into trouble

[19:19] <FROGGS> jaffa4: does the token change?

[19:19] <jaffa4> no

[19:20] <FROGGS> how chould the $/[0] get untrue then?

[19:20] <timotimo> because i still have to know at the end of my loop that i've visited each and every of the promises and channels

[19:20] <timotimo> in a random order

[19:20] <timotimo> i'll have to come up with a cleverer approach than what i just had.

[19:20] <jnthn> timotimo: no, you dont visit each every one

[19:20] <timotimo> i'll magically flatten the list.

[19:20] <jnthn> timotimo: You make a random order to visit them in

[19:20] <jnthn> And then take them in that order

[19:21] <jaffa4> FROGGS: when $token="n\n"

[19:21] <timotimo> i do, if none of them fire, i'll have to fire the "later" block

[19:21] <FROGGS> timotimo: like >> does?

[19:21] <jnthn> Right.

[19:21] <timotimo> FROGGS: the what now?

[19:21] <timotimo> oh, no, not like that

[19:21] <FROGGS> timotimo: this is a sort-of randomy thing :o)

[19:21] <timotimo> much more complicated. it involves splicing.

[19:22] <timotimo> 0, @foo, &block must become 0, @foo[0], &block, 0, @foo[1], &block, ...

[19:22] *** darutoko left
[19:22] <FROGGS> rp: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say 1 }

[19:22] <camelia> rakudo-parrot 75c45f: OUTPUT«1␤»

[19:23] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0] 

[19:23] <timotimo> what? o_ο

[19:23] <camelia> rakudo-parrot 75c45f: OUTPUT«===SORRY!=== Error while compiling /tmp/70XGYgXcqa␤Unable to parse expression in block; couldn't find final '}' ␤at /tmp/70XGYgXcqa:1␤------> (\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0]⏏<EOL>␤    expecting any …»

[19:23] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0] }

[19:23] <camelia> rakudo-parrot 75c45f: OUTPUT«｢n␤｣␤␤»

[19:23] <timotimo> .u ο

[19:23] <FROGGS> ENOYOLEAUX

[19:23] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0].bool }

[19:23] <camelia> rakudo-parrot 75c45f: OUTPUT«No such method 'bool' for invocant of type 'Match'␤  in block  at /tmp/HYf636y9Yp:1␤  in any  at /tmp/HYf636y9Yp:1␤  in any  at gen/parrot/stage2/NQPHLL.nqp:1146␤  in any eval at gen/parrot/stage2/NQPHLL.nqp:1133␤  in any evalfiles at gen/parro…»

[19:23] <FROGGS> .Bool

[19:24] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0].Bool }

[19:24] <camelia> rakudo-parrot 75c45f: OUTPUT«True␤»

[19:24] <jaffa4> now it should not be TRUE

[19:24] <FROGGS> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[0].Bool }; say ?$/[0]

[19:24] <camelia> rakudo-parrot 75c45f: OUTPUT«True␤False␤»

[19:25] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/(.*?\n)\s*(\S\N*)||(.*?\n)\s*$||(.+)/) { say $/[1].Bool }

[19:25] <camelia> rakudo-parrot 75c45f: OUTPUT«False␤»

[19:32] <jaffa4> : my $token="n\n"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<d>.Bool }; 

[19:32] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<d>.Bool }; 

[19:33] <camelia> rakudo-parrot 75c45f: OUTPUT«False␤»

[19:33] <jaffa4> p: my $token="n\n"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<c>.Bool }; 

[19:33] <camelia> rakudo-parrot 75c45f: OUTPUT«True␤»

[19:36] <timotimo> time to remember how to splice.

[19:36] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/p6-Versioning$ perl6-p -Ilib -MCompUnitRepo -e 'use Foo::Bar:ver<1.0.4>'

[19:36] <FROGGS> hello from Foo::Bar:auth<Kevin Flynn [email@hidden.address]
[19:36] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/p6-Versioning$ perl6-p -Ilib -MCompUnitRepo -e 'use Foo::Bar:ver<1.0.1>'

[19:36] <FROGGS> hello from Foo::Bar:auth<Kevin Flynn [email@hidden.address]
[19:37] *** kst left
[19:37] <timotimo> r: my @a = [1, [1, 2, 3].item, "foo"]; @a.splice(1, 1, [1

[19:37] <timotimo> erm

[19:37] <camelia> rakudo-jvm 75c45f: OUTPUT«===SORRY!=== Error while compiling /tmp/CSblgIuQbh␤Unable to parse expression in array composer; couldn't find final ']' ␤at /tmp/CSblgIuQbh:1␤------> , 2, 3].item, "foo"]; @a.splice(1, 1, [1⏏<EOL>␤    expectin…»

[19:37] <camelia> ..rakudo-parrot 75c45f: OUTPUT«===SORRY!=== Error while compiling /tmp/tc3OuRrkpW␤Unable to parse expression in array composer; couldn't find final ']' ␤at /tmp/tc3OuRrkpW:1␤------> , 2, 3].item, "foo"]; @a.splice(1, 1, [1⏏<EOL>␤    expec…»

[19:37] <timotimo> r: my @a = [1, [1, 2, 3].item, "foo"]; @a.splice(1, 1, [1], 1);; say @a

[19:37] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: OUTPUT«1 1 2 3 foo 1 1␤»

[19:37] *** kst joined
[19:37] <timotimo> r: my @a = [1, [1, 2, 3].item, "foo"]; @a.splice(1, 1, 1, [0]);; say @a

[19:37] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: OUTPUT«1 1 2 3 foo 1 0␤»

[19:37] <timotimo> no :\

[19:42] *** Rotwang left
[19:43] *** pernatiy joined
[19:44] *** rindolf left
[19:57] *** Rotwang joined
[20:03] *** bbkr1 joined
[20:03] *** bbkr1 left
[20:05] *** hummeleB1 joined
[20:12] *** berekuk left
[20:13] <tadzik> heh, Good Guy CPH reordered stuff in my backpack for my convenience. "Nice"

[20:16] <jnthn> oh, you're in CPH? :)

[20:17] <tadzik> not anymore

[20:17] <tadzik> but it's so nice of them to move my camera bag to the top of my backpack for me

[20:18] <jnthn> They ain't the most predictable in so far as what they'd like you to remove from hand luggage for them to examine...

[20:18] <jnthn> Sometimes you get away with an iPad left in the bag. Sometimes not. :)

[20:18] <tadzik> :)

[20:18] <tadzik> it's nice of them because my apartment keys were in that bag

[20:19] <tadzik> so they moved from the middle of a huge backpack to the very top :)

[20:20] <jnthn> Aside from running railways, they mostly do stuff right here in Scandinavia. :)

[20:20] <tadzik> :)

[20:21] <moritz> do they managed to screw up railways even worse than in Great Britain?

[20:23] <jnthn> Hm, tough call... :)

[20:24] <jnthn> I think something like, they screw it up here less often, but when they screw it up they really screw it up. :)

[20:24] *** kurahaupo joined
[20:24] <jaffa4> p: my $token="{"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<c>.Bool }; 

[20:24] <camelia> rakudo-parrot 75c45f: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\s'␤at /tmp/zQgMkDtyb6:1␤------> ="{"; while ($token ~~ m:c/$<a>=(.*?\n)\⏏s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(␤Unrecognized backslash sequence: '\S'␤at /t…»

[20:25] <jaffa4> p: my $token="a"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<c>.Bool }; 

[20:25] <camelia> rakudo-parrot 75c45f: OUTPUT«False␤»

[20:26] <jaffa4> p: my $token="\{"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<c>.Bool }; 

[20:26] <FROGGS> jaffa4: you wanna win the next obfuscation contest?

[20:26] <camelia> rakudo-parrot 75c45f: OUTPUT«False␤»

[20:26] <jaffa4> no

[20:26] <jaffa4> p: my $token="\{"; while ($token ~~ m:c/$<a>=(.*?\n)\s*$<b>=(\S\N*)||$<c>=(.*?\n)\s*$||$<d>=(.+)/) { say $/<d>.Bool }; 

[20:26] <camelia> rakudo-parrot 75c45f: OUTPUT«True␤»

[20:27] *** xinming left
[20:28] *** rurban1 left
[20:29] *** rurban1 joined
[20:32] *** xinming joined
[20:42] <Rotwang> why can't I do: has constant Int $.foo = 0x01; ?

[20:43] <jnthn> Rotwang: "has constant" doesn't make much sense. constnat means, well, constant, and has means storage per instance...

[20:43] <jnthn> constant $.foo = 0x01; # seems more reasonable to me

[20:43] <jaffa4> how can I report bug really quickly?

[20:43] <jnthn> If you want a constant with an accessor

[20:44] <jnthn> jaffa4: Write an email to [email@hidden.address] and type VERY FAST!!!

[20:44] <jaffa4> what about subject line

[20:44] <jaffa4> what about subject line?

[20:44] <jnthn> It should describe the bug

[20:44] <FROGGS> well, put something good in it

[20:44] <moritz> well, you should write good one :-)

[20:44] <tadzik> put [BUG] in there for bonus points

[20:45] <FROGGS> tadzik++ *g*

[20:45] <moritz> "this has been [BUG]ging me for months"

[20:45] *** k-ray is now known as raydiak

[20:46] <Rotwang> jnthn: so that will work in the future? (constant $.foo = "bar";)

[20:48] *** cooper joined
[20:48] *** cooper left
[20:48] *** cooper joined
[20:48] <jnthn> r: class Foo { constant $.foo = "bar" }; Foo.foo

[20:48] <camelia> rakudo-jvm 75c45f: OUTPUT«===SORRY!=== Error while compiling /tmp/1DqFfG6YEy␤Variable $.foo used where no 'self' is available␤at /tmp/1DqFfG6YEy:1␤------> class Foo { constant $.foo⏏ = "bar" }; Foo.foo␤    expecting any of:␤        st…»

[20:48] <camelia> ..rakudo-parrot 75c45f: OUTPUT«===SORRY!=== Error while compiling /tmp/NDhJ6o8M9N␤Variable $.foo used where no 'self' is available␤at /tmp/NDhJ6o8M9N:1␤------> class Foo { constant $.foo⏏ = "bar" }; Foo.foo␤    expecting any of:␤       …»

[20:48] <jnthn> std: class Foo { constant $.foo = "bar" }; Foo.foo

[20:49] <camelia> std 065efb7: OUTPUT«ok 00:01 125m␤»

[20:49] <jnthn> Rotwang: Yes, we should make that work, I think.

[20:49] <Rotwang> jnthn: ok, cool

[20:49] <jnthn> my $.foo already works, iirc

[20:50] <jnthn> So anybody wanting to take this on can get inspiration from that :)

[20:52] *** berekuk joined
[20:53] <timotimo> now i has foods

[20:59] <jaffa4> jnthn: is there way of turning off making symbolic operations in the nqp Perl6 parser?

[20:59] <jnthn> jaffa4: "symbolic operations"?

[20:59] <jaffa4> jnthn: making declarations

[21:00] <jaffa4> the parser gives me Redeclaration of symbol Perl6::Format

[21:00] <jaffa4> perl6 does not give the error

[21:01] <jnthn> Ah, then it must be picking up your existing GLOBAL or something...

[21:02] <jnthn> You can't not make declarations, otherwise it won't know how to parse things later on

[21:02] *** kurahaupo left
[21:03] <jaffa4> jnthn: can I empty the global?

[21:04] <jnthn> jaffa4: I'm not entirely sure how it's finding your existing one; it normally creates it afresh...

[21:04] <jnthn> jaffa4: How are you invoking the parser?

[21:05] *** bonsaikitten left
[21:05] *** bonsaikitten joined
[21:05] <jnthn> I guess you can always try whatever module loader does to get a clean slate...

[21:05] <jaffa4> $!parser := Perl6::Grammar.parse( $text, :actions(Perl6::Actions.new())  ); 

[21:06] *** berekuk left
[21:08] <jnthn> Hmmm...

[21:08] *** djanatyn left
[21:08] *** Tene left
[21:09] <jaffa4> I cannot parse the parser

[21:09] <moritz> .oO( one does not simply walk into Perl6::Grammar )

[21:09] *** berekuk joined
[21:10] <jnthn> I mean, the only way it can pick up an existing global or outer, afaik, is around the "if nqp::existskey(%*COMPILING<%?OPTIONS>, 'global') {" line...

[21:11] <jnthn> But I thought only eval ever set that...

[21:14] *** djanatyn joined
[21:15] * lizmat is back, but still a bit dizzy

[21:15] <jaffa4> ok, bye

[21:15] *** jaffa4 left
[21:15] <jnthn> I'm sure something will pull you back down to earth soon...

[21:16] <lizmat> troo

[21:16] *** leont joined
[21:19] *** djanatyn left
[21:26] <FROGGS> jnthn / lizmat: it works like a charm :o)  https://github.com/FROGGS/p6-S11Versioning

[21:26] <lizmat> FROGGS++  way cool!

[21:27] <timotimo> \o/

[21:27] <FROGGS> :o)

[21:28] <FROGGS> the library-installing-part is missing though

[21:28] <lizmat> are you talking about CompUnitRepo::Local::File ?

[21:28] <FROGGS> it expects to have a database of installed libs

[21:29] <FROGGS> lizmat: ::File and ::Installation

[21:29] <lizmat> @*INC is the database

[21:29] <FROGGS> err

[21:29] <jnthn> FROGGS++

[21:29] <lizmat> and it's volatile

[21:29] <FROGGS> ::File works because it doesnt need a database

[21:29] <lizmat> indeed... 

[21:30] <FROGGS> but the ::Installation expects a json blurb, which panda would have to create

[21:30] <lizmat> nooooo

[21:30] <lizmat> panda doesn't create anything

[21:30] <lizmat> it calls the .install method

[21:30] <FROGGS> but panda needs to call into the repo at least

[21:31] <FROGGS> so, panda must know about it :o)

[21:31] <lizmat> must know about the location (top level directory) in which to install

[21:31] <lizmat> nothing more

[21:31] <FROGGS> let'say: an invocation of the panda toolchain results in these databases

[21:32] <lue> FROGGS++

[21:32] <FROGGS> so, if I do: panda install YourSelf, it might query the Repos in order to know which is capable of installing it

[21:32] <FROGGS> then tell it do do the hard work

[21:32] <lue> IIUC, that MANIFEST file would also allow for .pm6 and .p6m module extensions, right?

[21:33] <timotimo> FROGGS: even the panda part works?

[21:33] <FROGGS> because, a repo can be readonly (due to being on a ro filesystem or by being an autoinstaller (aka pan))

[21:33] <FROGGS> timotimo: no, only in my head

[21:33] <timotimo> ah, ok :)

[21:34] <FROGGS> lue: the extension does not matter, because a repo can even store its files in an sql database if it wants to

[21:34] *** colomon joined
[21:34] <lizmat> if you do panda install YourSelf, it should install it in the "user" directory, I would think

[21:35] <lizmat> lue: or on github, cloudpan, whatever

[21:35] <FROGGS> I think so too

[21:35] <lue> FROGGS: ok. The implication made by the top of the README made me think otherwise :) . "(split by '::', plus '.pm' extension)" specifically.

[21:35] <lizmat> now, what the "user" directory is, I don't know

[21:35] <FROGGS> lizmat: but in the end you could have a gazillion on repositories

[21:35] <FROGGS> lue: yeah, I suck at documentation :o)  need to rewrite it

[21:36] <FROGGS> lizmat: %*CUSTOM_LIB<home> perhaps?

[21:36] *** araujo left
[21:36] <lizmat> I think this is the moment to decide these things

[21:37] <lizmat> if I do "$ perl6 -e '.say for @*INC'", I get a list of dirs

[21:37] <FROGGS> it could even gist the to-be-installed modules, or create new repos

[21:37] <lue> FROGGS: to be fair, your code seems to match that claim :) (CompUnitRepo.pm:39)

[21:37] *** araujo joined
[21:37] <lizmat> is any of thise intended to be used for installed modules ?

[21:37] <leont> So, what is the state of perl 6 QA? Is there anyone working on it currently?

[21:38] <FROGGS> lue: that is for the repository-handler plugins

[21:38] <lizmat> leont: in what context?  do you mean, do we have tests?  about 30K :)

[21:38] <FROGGS> lizmat: yes, I think %*CUSTOM_LIB goes in there too

[21:39] <FROGGS> lizmat: btw, see the libraries.cfg file

[21:39] <leont> I mostly meant QA for modules and stuff. I think it'd be nice to get some perl 6 people to the QA hackathon.

[21:39] <FROGGS> we just need to tweak that, with a sane default

[21:39] <lue> FROGGS: OK. [ did I mention FROGGS++ for getting auth/ver stuff in a better state? :) ]

[21:39] <FROGGS> :o)

[21:39] <FROGGS> thanks lue

[21:40] <lizmat> I would think panda would need to use %*CUSTOM_LIB<home> indeed, unless otherwise indicated

[21:40] <lizmat> I guess "--site" would use %*CUSTOM_LIB<site>

[21:40] *** ajr joined
[21:40] <FROGGS> yes

[21:40] <lizmat> I guess "--vendor" would use %*CUSTOM_LIB<vendor>

[21:40] *** ajr is now known as Guest68732

[21:40] <FROGGS> and I think it falls back from site to home if it fails, and then to cwd

[21:41] <FROGGS> not sure though

[21:41] <lue> leont: there's a Test module that modules can (and frequently do) use for testing themselves.

[21:41] <lizmat> not to cwd, unless -I . I would think

[21:41] <lizmat> leont: fwiw, I intend to be in Lyon next year 

[21:44] *** kaare_ left
[21:46] *** xinming left
[21:46] *** dmol1 left
[21:49] <Guest68732> 4-letter sysnonym for 'done' - 'finis' ?

[21:49] <lizmat> 4?

[21:49] <lizmat> r: say "finis".chars

[21:49] <camelia> rakudo-parrot 75c45f, rakudo-jvm 75c45f: OUTPUT«5␤»

[21:50] <Guest68732> duh!

[21:50] <huf> "kész"

[21:50] *** Guest68732 is now known as ajr_

[21:50] *** berekuk left
[21:50] <ajr_> nothing with accents, please.

[21:51] <huf> "kesz"? :D

[21:51] <huf> translit is <3

[21:53] <lue> french has "fini" iirc

[21:53] <lizmat> fin

[21:53] <huf> .hu has fini too, but it means "tasty" :)

[21:53] <lizmat> something one used to see at the end of a French movie  :-)

[21:54] <huf> very useful right now :)

[21:54] *** xinming joined
[21:55] <lue> "j'ai fini la tâche" for instance

[21:55] <lue> lizmat: well, "fin" is a noun. I was under the impression we were going for verbs :P

[21:56] <huf> it's bound to become deliciously confusing if we start bringin in more languages :)

[21:57] <lue> (there are lots of 4-letter *English* synonyms for "done", if you're OK with irony: "acco", "fini", "comp", "achi", etc.)

[21:57] <FROGGS> lizmat: next thing I'll do is to implement .install... just have to muse about the influence of multiple backends and precompilation...

[21:58] <jnthn> .oO( "I have completed the moustache"? )

[21:58] <lizmat> FROGGS: the musing can be very composable, as each CompUnitRepo is responsible for its own logic only

[21:59] <FROGGS> true

[21:59] <lue> jnthn: tâche ->(tasche)-> task :)

[22:01] <jnthn> oh! :)

[22:08] <lizmat> timotimo: winner is supposed to return whatever block was selected, returned, right?

[22:09] <lizmat> S17:394  " The construct as a whole returns the result of whichever block was selected."

[22:09] <synopsebot> Link: http://perlcabal.org/syn/S17.html#line_394

[22:09] <jnthn> aye

[22:09] <lizmat> in the WINNER branch, I get a syntax error in something like

[22:09] <lizmat> my $a = winner { ... }

[22:10] <jnthn> lizmat: Try my $a = do winner { ... }

[22:10] <jnthn> std: my $a = winner { }

[22:10] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'winner' used at line 1␤Check failed␤FAILED 00:01 124m␤»

[22:10] <jnthn> std: my $a = do winner { }

[22:10] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Expression needs parens to avoid gobbling block at /tmp/SZLTWO4oM3 line 1:␤------> my $a = do winner ⏏{ }␤Missing block (apparently gobbled by expression) at /tmp/SZLTWO4oM3 line 1:␤------> my $a = …»

[22:10] <jnthn> std: my $a = do winner * { }

[22:11] <camelia> std 065efb7: OUTPUT«ok 00:01 126m␤»

[22:11] <jnthn> std: my $a = winner * { }

[22:11] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/w6ovzA4t7Z line 1:␤------> my $a = winner * ⏏{ }␤    expecting infix or meta-infix␤Undeclared rou…»

[22:11] <jnthn> Seems STD agrees. It's parsed as a statement_contorl rather than a term.

[22:12] *** berekuk joined
[22:12] <lizmat> the do fixes it (for now), I guess we should be able to do without do, no?

[22:12] <jnthn> Not sure, syntax ain't my job :D

[22:12] *** Tene joined
[22:12] *** Tene left
[22:12] *** Tene joined
[22:12] <lizmat> .oO( do be do be do }

[22:18] *** djanatyn joined
[22:21] *** colomon left
[22:23] *** beastd left
[22:26] *** Rotwang left
[22:28] <lizmat> TimToady: given "winner $p1, $p2 { done $p1 { ... } done $p2 { ... }"

[22:28] <lizmat> would we really need the $p1, $p2 with winner?

[22:29] <lizmat> winner { done $p1 { ... } done $p2 { ... } }

[22:29] <lizmat> seems more sensical to me

[22:29] <lizmat> because what are you going to do it you specify:

[22:29] <lizmat> winner $p3 { done $p1 {...} } ??

[22:34] <lizmat> the parser should create the list of promises / channels to check

[22:35] <lizmat> and also should check for doubles, aka:

[22:35] <lizmat> winner { done $p2 { say "a" } done $p2 { say "b" } }

[22:35] <lizmat> should fail at compile time

[22:48] <dalek> specs: e29f3ad | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[22:48] <dalek> specs: Remove direct params from winner ... {}

[22:48] <dalek> specs: 

[22:48] <dalek> specs: That list should be automagically created from whatever was specified with

[22:48] <dalek> specs: the done $foo { } statements

[22:48] <dalek> specs: review: https://github.com/perl6/specs/commit/e29f3adba9

[22:49] *** sahadev left
[22:49] *** sahadev joined
[22:49] <jnthn> lizmat: I...think that breaks the done * { } case, no?

[22:50] <jnthn> lizmat: There was some discussion of this in the backlog...

[22:50] <jnthn> Last night, iirc...

[22:50] <timotimo> yeah, if we have winner *, we need done $foo, but if we have winner $foo, $bar, we can have done *

[22:50] <lizmat> I would think we don't need done *

[22:51] <jnthn> more * is quite useful.

[22:51] <jnthn> I can kinda see done * going well with it

[22:51] <jnthn> Like if you want to write something to multiplex many channels into one.

[22:51] <jnthn> You don't care which channel you got the think from

[22:52] <lizmat> more $c, $d, $e { ... }

[22:52] <jnthn> winner @channels { more * { $res_chan.send($_) }; done * { $res_chan.close() if ++state $ == @channels } } # or so

[22:52] <lizmat> more @channels { ... }

[22:53] <lizmat> fwiw, it feels too magic to me...

[22:53] *** PacoAir left
[22:55] *** BenGoldberg joined
[22:55] <lizmat> by specifying *which* channels you want to check, you make it clearer

[22:55] <lizmat>         winner $c {

[22:55] <lizmat>             more $c { take $_ }

[22:55] <lizmat>             done $c { last }

[22:55] <lizmat>         }

[22:55] <lizmat> that's $c 3 times

[22:56] *** FROGGS left
[22:57] <timotimo> jnthn: your state needs a few more parens, though :)

[22:57] <lue> I'm partially with lizmat, if only because a requirement to specify what you want at least twice feels like a very terrible thing.

[22:57] <timotimo> at least i think so

[22:57] <timotimo> but you don't

[22:58] <timotimo> winner * { more $c { take $_ }; done $c { last } }

[22:58] <jnthn> std: ++state $ == 42

[22:58] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at /tmp/ZkREL3VIw9 line 1:␤------> ++state $ =⏏= 42␤Parse failed␤FAILED 00:01 124m␤»

[22:58] <jnthn> aww!

[22:58] <lizmat> timotimo: except I would drop the '*' in that example

[23:00] <lue> std: ++(state $ == 42)

[23:00] <camelia> std 065efb7: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at /tmp/uQcsiGJwrG line 1:␤------> ++(state $ =⏏= 42)␤Parse failed␤FAILED 00:01 126m␤»

[23:00] <lue> std: ++(state $ = 42)

[23:00] <camelia> std 065efb7: OUTPUT«ok 00:01 125m␤»

[23:00] <lue> std: ++state $ = 42

[23:00] <camelia> std 065efb7: OUTPUT«ok 00:01 123m␤»

[23:00] <lue> (a rare inversion of the =/== mixup :P)

[23:00] <TimToady> std: 42 == ++state $

[23:00] <camelia> std 065efb7: OUTPUT«ok 00:01 124m␤»

[23:01] <timotimo> lizmat: dropping the * makes parsing harder, but we already have code to do exactly that

[23:01] <jnthn> TimToady: I'm not sure if that's cheating or technique :P

[23:02] <lizmat> timotimo: actually, it already parses

[23:02] <lizmat> I have some tests that work already  :-)

[23:02] <timotimo> yes, as i said, we have code to do exactly that

[23:03] * TimToady prefers to see 'winner *' if it's going to intuit from the list

[23:03] <timotimo> yes

[23:03] <lizmat> ok, misunderstood you

[23:03] <timotimo> i'm with TTD

[23:03] <lue> .oO(I prefer OpenTTD myself...)

[23:03] <timotimo> i just like playing the theme

[23:04] <lizmat> winner $a, $b { done $c {} }  # should this produce an error?

[23:04] <timotimo> the website has not only a JS version of the game, but also an ogg jukebox =)

[23:04] <timotimo> lizmat: given the new semantics, yeah, it should

[23:04] <timotimo> i think i'll drive home and get sleep early today. my head is kinda achy :(

[23:04] <lizmat> but with the old ?

[23:04] <TimToady> but for a single entry I'd rather see 'winner $c { more * {} done * {} } because it doesn't repeat the $c

[23:04] <timotimo> don't forget your ; if you have a single line :)

[23:05] * TimToady left it out on purpose to see if you were awake :)

[23:05] * timotimo is passing all the tests today

[23:06] <lizmat> TimToady: feels like repeating '*' to me

[23:06] <TimToady> better than repeating a variable

[23:06] <lue> I'm fine with repeating * though; generic enough to not matter.

[23:07] <lue> (now if * were spelled PLACEHOLDER_ASTERISK ...)

[23:10] <dalek> rakudo-star-daily: 8d9601f | coke++ | log/ (5 files):

[23:10] <dalek> rakudo-star-daily: today (automated commit)

[23:10] <dalek> rakudo-star-daily: review: https://github.com/coke/rakudo-star-daily/commit/8d9601fd56

[23:13] <[Coke]> getting some not-quite-green test results in the modules ^^

[23:14] <dalek> specs: f8d3714 | (Elizabeth Mattijsen)++ | S17-concurrency.pod:

[23:14] <dalek> specs: Some more simplification: re-introduce winner *

[23:14] <dalek> specs: review: https://github.com/perl6/specs/commit/f8d3714ccf

[23:17] <dalek> roast: 5e7b85b | (Elizabeth Mattijsen)++ | S17-concurrency/winner.t:

[23:17] <dalek> roast: Some winner tests

[23:17] <dalek> roast: review: https://github.com/perl6/roast/commit/5e7b85b48a

[23:18] <lizmat> sleep&

[23:19] <[Coke]> someone wants to help getting the star release going, Passing an object candidate to Mu.bless is deprecated  in method new at /home/coke/sandbox/rakudo-star-daily/star/rakudo-star-daily/install/lib/parrot/5.9.0/languages/perl6/lib/Template/Mojo.pm:80

[23:19] <[Coke]> would clean things up a  bit.

[23:29] *** rurban1 left
[23:31] *** btyler left
[23:32] *** rurban1 joined
[23:36] *** rurban1 left
[23:37] <lue> [Coke]: you could file an issue here about it: https://github.com/tadzik/Template-Mojo/

[23:59] *** telex left
