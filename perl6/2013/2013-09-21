[00:03] <tadzik> wtf, why did synopsebot react to help

[00:10] *** cjwelborn left
[00:13] *** Psyche^_ left
[00:14] <corecatcher> yay, working BarTab order thingy \o/

[00:15] * corecatcher pets jnthn 

[00:17] *** Psyche^ joined
[00:18] *** Guest12202 left
[00:19] *** benabik joined
[00:28] *** EvanTeitelman left
[00:28] <timotimo> crocket, TimToady, may i step in to explain pypy?

[00:28] <crocket> timotimo, Feel free to do so

[00:29] <timotimo> pypy usually refers to two parts: the rpython compilation toolchain and the python interpreter based on the rpython toolchain

[00:29] <timotimo> rpython is basically a "subset" of python, in that there is one point where your program stops running as python and starts being severely restricted in what it can do

[00:29] <timotimo> mostly things like "this function must always return the same type" or something

[00:30] <crocket> ok

[00:30] <timotimo> then the rpython toolchain goes ahead and, starting from a single entry point, adds types to every little nook and cranny of the code at that point

[00:30] <timotimo> (so you can metaprogram in python before the translation starts)

[00:30] <crocket> What is rpython written in?

[00:30] <timotimo> at the end, a pluggable GC, the stackless transformation and a complete meta-tracing JIT are added, the whole thing is spat out as C code and compiled by gcc

[00:30] <timotimo> the rpython translation toolchain is entirely python code

[00:31] <crocket> weird

[00:31] <timotimo> i don't think so.

[00:31] <crocket> timotimo, Is rpython written in Cython?

[00:31] <timotimo> no

[00:31] <timotimo> rpython is a restriction on behavior, not syntax

[00:32] <timotimo> at the point where the rpython translation starts, only code objects and python bytecode remain

[00:32] <timotimo> (and annotations like "this bytecode comes from this line of code")

[00:32] *** EvanTeitelman joined
[00:32] <timotimo> cython doesn't enter the picture at all until you have a fully translated and installed pypy-c program

[00:33] <timotimo> after that you need to do magic to make cython work because cython relies on the CPython extension API, which isn't fully supported by pypy

[00:33] <timotimo> (by pypy-c, i should say)

[00:33] <crocket> timotimo, PyPy doesn't seem to support pytho n3.

[00:34] <timotimo> python 3 support is on the way for pypy-c

[00:34] <timotimo> there will not be python 3 support for the rpython translation toolchain any time soon

[00:34] *** benabik left
[00:35] <crocket> What is pypy-c?

[00:35] <timotimo> i call that the binary that you get when you translate the pypy-python-interpreter source code using the rpython translation toolchain

[00:36] <crocket> timotimo, You make it more complex.

[00:36] <timotimo> it is a bit complex

[00:37] <timotimo> but the big picture is: you use a python interpreter (cpython or pypy, your choice) to run the rpython translation toolchain and you feed that the source code of the pypy-python-interpreter, out comes a pypy-python-interpreter binary

[00:38] <crocket> It seems PyPy is running out of funding.

[00:40] <timotimo> they only require funds to full-time-employ developers

[00:40] <crocket> timotimo, It's already expensive enough.

[00:40] <timotimo> and it would seem like they are getting funded pretty well

[00:40] <crocket> timotimo, How are people paid?

[00:40] <crocket> sponsorship or full-time employment?

[00:41] <timotimo> i'm not sure i understand the difference

[00:41] <timotimo> but i think it's the former

[00:41] *** EvanTeitelman left
[00:41] <timotimo> if you'll excuse me, i have an appointment with my pillow and blanket :)

[00:41] <timotimo> but i really don't understand what you mean by "it's already expensive enough"

[00:42] <crocket> timotimo, devs are actually worth a lot.

[00:42] <crocket> commodity devs aren't paid well enough.

[00:43] <crocket> timotimo, With sponsorship, you don't require full-time engagement.

[00:44] <crocket> A sponsored dev is basically asked to work on a project.

[00:44] <crocket> An employed dev has less autonomy.

[00:44] <timotimo> ok. you'd have to ask the pypy people about this.

[00:44] <timotimo> i still don't understand what you mean by "already expensive enough" and "running out of funds"

[00:45] <timotimo> i think they haven't yet used any of the money you can see on the website for their fundraisers

[00:45] <timotimo> anyway, i'm going to bed now

[00:46] <timotimo> oh, look, they've actually released a beta version of pypy3

[00:47] <crocket> ok

[00:47] <crocket> timotimo, I'll probably want to get funded by internet projects like PyPy instead of having to endure humiliation of corporate programmer jobs.

[01:00] *** benabik joined
[01:05] *** risou_awy is now known as risou

[01:11] *** EvanTeitelman joined
[01:12] *** PacoAir left
[02:01] *** FROGGS joined
[02:06] *** FROGGS left
[02:10] *** risou is now known as risou_awy

[02:14] *** risou_awy is now known as risou

[02:26] <crocket> How is perl6 winning over other languages?

[02:26] <crocket> perl5 wasn't particularly better than python as a language.

[02:27] <crocket> Let's not consider execution environment.

[02:30] <crocket> 90% of everything is either shitty or mediocre.

[02:34] *** Araq joined
[02:57] *** crocket left
[03:02] *** risou is now known as risou_awy

[03:08] *** cjwelborn joined
[03:31] *** thou left
[03:42] *** Mouq joined
[03:44] *** EvanTeitelman left
[03:44] *** ksh left
[03:47] *** ksh joined
[03:58] *** REPLeffect left
[03:59] *** preflex left
[04:02] *** REPLeffect joined
[04:02] *** preflex joined
[04:02] *** ChanServ sets mode: +v preflex

[04:08] *** eternaleye left
[04:09] *** eternaleye joined
[04:10] *** raiph joined
[04:11] *** colomon left
[04:20] *** aindilis left
[04:31] *** Pzter joined
[04:31] *** PZt left
[04:37] <TimToady> crocket seems to have some trollish tendencies, but is not very good at it yet :)

[04:43] <lue> In retrospect, I would agree (including the reason that he didn't seem like a troll at the time)

[04:43] <cognominal> crocket: This kind of comparaisons miss the large picture. Without Perl, there would  probably no Python to begin with. 

[04:44] *** fridim__ left
[04:45] *** BenGoldberg left
[04:49] *** eternaleye left
[04:50] *** eternaleye joined
[04:52] *** cognominal left
[04:52] *** cognominal joined
[05:12] *** rindolf joined
[05:36] *** rindolf left
[05:39] *** cjwelborn left
[05:44] *** FROGGS joined
[05:55] *** pernatiy joined
[05:58] *** ksh left
[05:59] *** ksh joined
[06:05] *** risou_awy is now known as risou

[06:20] *** salv0 left
[06:21] *** salv0 joined
[06:37] *** Pzter is now known as PZt

[06:48] <Woodi> hallo :) I must say I am a bit out of sync with Perl6 development news... so: is it possible to generate binary (in .exe/+x sense) from v6 script at the moment ?

[06:49] *** risou is now known as risou_awy

[06:49] <FROGGS> Woodi: not at the moment

[06:49] <Woodi> and: do some security infrastructure like in Java VM is planned for Perl6 (spec) or MoarVM ?

[06:50] <FROGGS> Woodi: but something like staticperl might be possible without too much fuzz

[06:50] <Woodi> java have applets legacy probably...

[06:50] <FROGGS> Woodi: what do you mean?

[06:50] <Woodi> eg. sandboxing

[06:50] <Woodi> but maybe Perl6 is just language ?

[06:51] <FROGGS> Perl 6 is a language yes

[06:51] <FROGGS> what you want might be maybe that rakudo has a safe setting? like the eval bot offers here?

[06:52] <FROGGS> r: open()

[06:52] <camelia> rakudo c5ba78: OUTPUT«open is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:2␤  in sub open at src/RESTRICTED.setting:5␤  in block  at /tmp/V3hlV_BLEr:1␤␤»

[06:55] *** darutoko joined
[06:56] <Woodi> realy, I do not know what I want :) someting superextra and beatifull :) maybe kind of chroot, maybe sandbox like in applets, maybe SELinux integration or dtrace ? :)

[06:57] * Woodi afk but will be back :)

[07:01] <FROGGS> o/ :o)

[07:06] *** xenoterracide left
[07:07] *** cognominal left
[07:08] *** cognominal joined
[07:13] *** xenoterracide joined
[07:17] *** SamuraiJack_ joined
[07:25] *** raiph left
[07:33] *** raiph joined
[07:34] <Woodi> b :) but realy I asking: is something like that planned and is it needed ? in the future ? becouse integrating security layer later will be +Ofun -Whard...

[07:36] <Woodi> but maybe Perl6 is just yet another low level language and such things are not needed inside :)

[07:47] *** SamuraiJack_ left
[07:48] *** nyuszika7h left
[07:49] *** nyuszika7h joined
[07:59] <timotimo> use NativeCall; sub seccomp() is native("something_something.so"); seccomp();

[08:00] <timotimo> on the java level, you can grab a Perl6::Compiler object as a java instance thingie and put that into a security context with a classloader or something

[08:02] *** raiph left
[08:09] <hoelzro> why is it that when I run a perl6 script, I see two processes in top?

[08:11] <hoelzro> does Parrot spawn some sort of helper thread?

[08:15] <hoelzro> hmm

[08:15] <hoelzro> seems so

[08:20] *** logie left
[08:21] *** denisboyun joined
[08:22] *** logie joined
[08:29] <timotimo> maybe somebody sneaked in a concurrent GC while we weren't looking

[08:35] *** risou_awy is now known as risou

[08:43] <hoelzro> what is it? while(1) { sleep(1) }?

[08:43] <timotimo> yeah, must be something efficient like that

[08:48] *** dmol joined
[08:52] <Woodi> timotimo++: nice and look secure for system/account

[08:53] *** Rotwang1 joined
[08:58] *** iSlug joined
[09:01] *** spider-mario joined
[09:09] *** PacoAir joined
[09:10] <hoelzro> sweet

[09:10] <hoelzro> the JVM profiler + Perl 6 totally works!

[09:10] <hoelzro> http://hoelz.ro/files/perl6-objects.png

[09:10] <hoelzro> wow, SixModelObject. *That's* a shock.

[09:11] <hoelzro> hmm

[09:11] <hoelzro> what's a _P6Opaque? 

[09:12] <hoelzro> er, nvm

[09:19] <arnsholt> hoelzro: Every class backed by the P6opaque gets an autogenerated class, which is the _P6Opaque_\d+ classes

[09:19] <hoelzro> makes sense

[09:20] <arnsholt> Since different classes have different members and such

[09:20] <hoelzro> of course

[09:21] <arnsholt> On Parrot it's handled differently, since we can just malloc() differently sized slabs of memory and index into that

[09:23] <hoelzro> arnsholt: do you happen to know where that P6opaque generating code lives?

[09:23] <hoelzro> if not, I'll probably be able to find it

[09:24] *** iSlug left
[09:24] <masak> antenoon, #perl6

[09:24] <arnsholt> 'sec

[09:25] <dalek> rakudo/method2sub: 20d5a68 | (Elizabeth Mattijsen)++ | src/Perl6/World.nqp:

[09:25] <dalek> rakudo/method2sub: Panic if we cannot make the exception object

[09:25] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/20d5a68a06

[09:26] <arnsholt> hoelzro: src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/P6Opaque.java:253 (generateJVMClass)

[09:26] <hoelzro> ahoy masak

[09:26] <hoelzro> cool, thanks!

[09:26] <masak> this cracked me up: http://irclog.perlgeek.de/perl6/2013-09-20#i_7613368 :)

[09:26] <hoelzro> I'm going to try to hack this profiler to get more details

[09:26] <arnsholt> hoelzro: It's ~350 lines of stuff, mind =)

[09:27] <masak> "it's... a contradiction? well gosh, we gotta do something about that immediately, I guess!"

[09:28] <woolfy> ll

[09:28] *** iSlug joined
[09:28] <lizmat> good *, #perl6!

[09:29] <dalek> rakudo/method2sub: 2f2196f | (Elizabeth Mattijsen)++ | src/core/Any.pm:

[09:29] <dalek> rakudo/method2sub: Fix More/Some confusion

[09:29] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/2f2196f78e

[09:29] <lizmat> I've gotten a bit further with the method 2 sub migration of [] and {}

[09:30] <lizmat> only running perl6 now is a problem, because apparently now %ENV is readonlu

[09:31] <masak> I wonder if people coming in from the outside really have such a one-dimensional view of the world as they seem... or if they just give that impression due to lack of a common language.

[09:31] *** risou is now known as risou_awy

[09:32] <masak> open source communities are like isolated islands in the ocean. people visiting from another island have a hard time blending in, partly because the things they say sound like noises to us.

[09:32] <arnsholt> Heh, TimToady is a very good antidote to that kind of overly serious thing. "it's fast enough already, except when it isn't" =D

[09:32] *** rindolf joined
[09:32] <masak> apparently I got out of my bed on the cultural-relativist side today.

[09:33] <arnsholt> Or maybe you put on your PoMo hat =)

[09:34] <timotimo> pomo?

[09:34] <masak> moritz made my PoMo hat look all ridiculous and stuff :)

[09:35] * masak .oO( I maded you a hat but moritz deconstructed it! ) :P

[09:35] <arnsholt> timotimo: post modern(ism)

[09:35] <masak> timotimo: https://en.wikipedia.org/wiki/Postmodernism

[09:36] <timotimo> of course

[09:36] <masak> unless it happens to be Esperanto for "apple" :)

[09:38] <timotimo> mehsperanto

[09:39] *** SamuraiJack_ joined
[09:40] <masak> I think disparaging Esperanto in here would qualify as throwing stones in a glass house ;)

[09:43] <masak> cognominal: alternative history is hard, but I think Python would have come about with or without Perl.

[09:43] <masak> cognominal: Guido was certainly aware of Perl when he started on Python. he just didn't like semicolons and braces.

[09:52] *** pmurias joined
[09:55] <pmurias> Woodi: re security infrastructure, I don't think anything like that is planned for the spec itself

[09:55] <masak> I've been thinking about CCCs lately. (Cartesian Closed Categories)

[09:56] <masak> and I have this question: how far apart are the OO world and the ADT world really.

[09:57] <masak> at one end, we have objects (data + behavior). at the other end, Algebraic Data Types (defined using unions, tuples, and records).

[09:58] <masak> there are some obvious differences, such as objects being opaque and ADTs being all too willing to be deconstructed. but as Perl 5 and JavaScript and Python show, opaqueness isn't required in an object system.

[09:59] <masak> then there is the fact that behavior is defined "in" the class itself, whereas ADTs only talk about data, and you define behavior from the outside.

[09:59] <masak> ...but as golang shows, you can build a perfectly cromulent OO system by defining methods on the outside of classes.

[10:00] <masak> (and it seems to work quite well. I still haven't figured out if there's any drawback to golang's approach.)

[10:00] <Woodi> pmurias: any idea about S23 ? (status: TBD)

[10:00] <masak> so. is there any strong reason something couldn't be *both* an OO system and fully based on ADTs?

[10:02] <pmurias> Woodi: maybe once it is succesfully implemented it will be specced

[10:02] <masak> I started thinking about all of this when I saw TimToady's red-black tree implementation on RosettaCode. I thought "well, it's a shame we cannot make objects and pattern matching closer to each other than that..."

[10:04] <pmurias> masak: dosn't ADTs stop you from adding new subtypes of some thing?

[10:04] <pmurias> data Foo = Foo | Bar, and we can't add a FooBar constructor

[10:05] <masak> ah, so you mean there's no correspondence to subclassing in the ADT world?

[10:05] <masak> that's true -- but on the other hand JavaScript eschews subclassing for prototype linking, and golang ditches subclassing for wrapping.

[10:05] <masak> so that's also not a showstopper, it seems.

[10:06] <masak> also, if an enum is seen as a tagged union, it's *also* not extensible. which makes a whole lot of sense, if code expects there to be a closed set of cases to handle.

[10:06] <pmurias> you can have a semi decent object system with struct and function pointers for polymorphism if you try hard enough ;)

[10:07] <masak> yeah.

[10:07] <masak> my question, I guess, is whether someone has deliberately tried to make an object system out of sums, products, and exponentials. (like in a CCC)

[10:08] <masak> Haskell doesn't count.

[10:08] <Woodi> hmm, what is object system and pattern matching (in few words) ?

[10:09] *** denisboyun left
[10:09] <masak> Woodi: "object system" = something that allows you to define types (classes?) out of which objects can be instantiated. the objects have state and behavior.

[10:09] *** denis_boyun joined
[10:11] <masak> Woodi: "pattern matching" = the same function can have different function bodies, and the correct one is chosen at invocation time by matching the parameter signature against the arguments.

[10:11] <masak> when you have multis in Perl 6, you generally also have pattern matching.

[10:11] <masak> 'given/when' also does pattern matching.

[10:13] <Woodi> I have burned in brain that objects are just records. + functions. what is responsible for behaviour in ADT ?

[10:14] *** xinming joined
[10:14] <masak> well, "objects = records + functions" is fully compatible with an ADT world view, IIUC.

[10:15] <masak> but records are products, and you haven't fit sums (unions) into that model.

[10:15] <masak> and hence there isn't a great need for pattern matching, either.

[10:17] *** krokite left
[10:18] <masak> in terms of introspecting your ADTs, records/tuples are conjugate with field/element lookup. unions/enums are conjucate with pattern matching, multis, and given/when.

[10:18] <masak> conjugate*

[10:19] <Woodi> isn't a pattern matching a scheduling on some condition ? :)

[10:19] <masak> "scheduling"? please define.

[10:20] <Woodi> running "case" with data type as varible

[10:21] *** Mouq left
[10:21] <masak> in my understanding, that's exactly what pattern matching is. it's "unwinding" the structure that the union has "wound".

[10:22] <masak> the simplest possible product is cons (car/cdr). the simplest possible sum is Either (Left/Right).

[10:22] <masak> I wonder why Lisp gave us the former but we had to wait for Haskell for the latter ;)

[10:24] <masak> the semantics of a product can be summarized as "two go in, one comes out". that is, you have to provide both the car and the cdr to build a cons, but the result is one single unit.

[10:24] <masak> the semantics of a sum can be summarized as "one goes in, two come out". that is, you only have to provide a Left or a Right, and the Either in some sense pretends to be both of these to the rest of the world.

[10:24] <masak> needless to say, these two notions are dual. :)

[10:26] <Woodi> do ADT have loops ? I thing loops are needed for turing completness ?

[10:26] <dalek> rakudo-js: 4342f20 | (Pawel Murias)++ | run (2 files):

[10:26] <dalek> rakudo-js: Pass test 78.

[10:26] <dalek> rakudo-js: 

[10:26] <dalek> rakudo-js: Implement nqp::cwd, nqp::getenvhash, nqp::shell (with 3 arguments).

[10:26] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/4342f20ae7

[10:26] <masak> Woodi: yes, because you can define them recursively.

[10:27] <masak> Woodi: so a (binary) Tree[a] can be defined as (Empty + Leaf[a] + Node[Tree[a] * Tree[a]])

[10:28] *** Rotwang1 left
[10:28] <masak> Woodi: FP folks have a trick for handling recursive types, involving (not surprisingly) the Y combinator.

[10:33] <Woodi> but for object system behaviour definition is needed too, not just data definition

[10:34] <masak> yes, but look at golang.

[10:34] <masak> either you have to claim it has no object system.

[10:34] <masak> or agree that it doesn't keep the behavior definition "inside" the type definition.

[10:37] *** iSlug left
[10:39] <Woodi> looks funcions are defined outside { }, like in object system written in asm :)

[10:41] <Woodi> for me objects/inheritance/stuff is just syntax sugar for not writting same code twice. it makes some order on "code" level, humans prefer that :)

[10:44] <masak> yes.

[10:45] <masak> on some level, putting methods inside of the class definition is a lie.

[10:45] <masak> that can be seen more clearly by considering that there are N copies of the data part, one for each instance -- but there is just 1 copy of the behavior part, one for the whole class.

[10:46] <masak> inheritance is there as a mechanism for not writing the same code twice. as such mechanisms go, it's not a particularly successful one.

[10:46] <masak> there's half a dozen others.

[10:53] *** iSlug joined
[10:55] <Woodi> and what new on the Actor model/STM field in Perl6 ? actually vm is sheduling async tasks on hardware threads ?

[10:56] <masak> I have a whole lot more faith in the Actor model these days, than STM.

[10:56] *** colomon joined
[10:56] <masak> as jnthn has taken to saying, STM is great if you actually have immutable types all through your language. it's less great if you don't.

[10:58] <Woodi> hmm, for me immutable types are compiler feature... users probably want do a=a+1, not b=a+1...

[11:01] <Woodi> but actor model is kind of ideal, concurrent object system...

[11:03] <jercos> well, if you consider a=a+1 in the most literal imperative sense, you could use := instead, you are evaluating a, adding one to that result, and binding a to the immutable result of that addition operation, no? the difference between := and = being that you are changing the contents of a mutable container, rather than rebinding a name.

[11:03] <jercos> but in either sense, it's still "a" resolving to two different immutable values, one before, and one after, right?

[11:05] <masak> well, yes and no.

[11:05] <masak> the 'a' on the right side is an rvalue -- you're accessing it for its value.

[11:05] <dalek> rakudo/method2sub: 149b15d | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[11:05] <dalek> rakudo/method2sub: Change order of candidates to be the same as the original version

[11:05] <dalek> rakudo/method2sub: 

[11:05] <dalek> rakudo/method2sub: Alas, still not being able to assign to hashes

[11:05] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/149b15d2d3

[11:05] <masak> the 'a' on the left side is an lvalue -- you're accessing it for the container that value is in, to replace that value.

[11:06] <jercos> right

[11:08] <jercos> but the result of a as an rvalue is immutable by nature, that being why it's an rvalue... and that whole statement creates a new rvalue which is being placed in the contain that a as an lvalue references, and in the future "a" will resolve to that new rvalue.

[11:09] *** iSlug left
[11:09] <jercos> neither the contents of "a" before, or after the statement need be mutable, it's only the container they're held in, which I'm say is effectively equivalent to a rebind, and for most purposes wouldn't need to be a Scalar.

[11:10] <masak> aye.

[11:10] <masak> much of the confusion in these discussion seems to stem from the difference between immutability of a container and immutability of its contents.

[11:10] <masak> Perl 6 suffers a bit from that too.

[11:11] <masak> and as soon as you start thinking in terms of "deep immutability", all the way down so to speak, you get into philisophical difficulties about which objects "own" each other.

[11:16] <masak> &

[11:17] <masak> oh, and actors/aggregates help with that, because by definition each actor or aggregate is its own "world".

[11:17] <jercos> almost like... multiprocessing and IPC? :p

[11:18] <lizmat> r: multi sub a ($a) { say "without named" }; multi sub a ($a, :$foo) { say "with named" }; a("bar")   # bug or feature ??

[11:18] <camelia> rakudo c5ba78: OUTPUT«with named␤»

[11:18] <lizmat> given 2 candidates, one without named, and one with an optional named

[11:18] <masak> jercos: not "almost like" -- one subsumes the other :)

[11:18] <colomon> lizmat: how could that not be a bug?

[11:18] <lizmat> is it right that the candidate with the optional named parameter is selected even if there is no named parameter given ?

[11:19] <masak> lizmat: I think in this case, it comes down to ordering.

[11:19] <masak> lizmat: I'd need to re-read S06 to be sure.

[11:19] <masak> lizmat: but if it comes down to ordering, I still think the first one should win.

[11:19] <masak> really &

[11:20] <lizmat> r: multi sub a ($a, :$foo) { say "with named" }; multi sub a ($a) { say "without named" }; a("bar")   # which one wins ?

[11:20] <camelia> rakudo c5ba78: OUTPUT«with named␤»

[11:20] <lizmat> seems to not be an order thing here

[11:21] <lizmat> seems the candidate without named params is always ignored (to me, at least)

[11:21] <jercos> I suppose what really cooks my noodle is that if structures are completely immutable, to change one value somewhere in a structure, you have to work that change up all the way to the top, or design something completely backwards like Git, or a transaction log, and have every read progress backwards up a versioning tree until the value sought is found... and neither are particularly appealing from the standpoint of single-threaded performance.

[11:22] <jercos> and there still always has to be something at the top, though the latter structures lend themselves to multiple "top" objects, with some mechanism of resolving to a preferred top...

[11:23] <lizmat> colomon: how could that not not be a bug ?

[11:23] <FROGGS> n: multi sub a ($a, :$foo) { say "with named" }; multi sub a ($a) { say "without named" }; a("bar")   # checking niecza

[11:23] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/iJZSUOXhE1 line 1:␤------> [32mmulti sub a ([33m⏏[31m$a, :$foo) { say "with named" }; multi s[0m␤  $foo is declared but not used at /tmp/iJZSUOXhE1 line 1:␤------> [32mmulti sub a ($a, …»

[11:24] <lizmat> n: multi sub a ($a, :$foo) { $foo; say "with named" }; multi sub a ($a) { say "without named" }; a("bar")   # checking niecza

[11:24] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/wQbNc1555w line 1:␤------> [32mmulti sub a ([33m⏏[31m$a, :$foo) { $foo; say "with named" }; m[0m␤␤without named␤»

[11:24] <FROGGS> n: multi sub a ($a, :$foo) { say "with named $a $foo" }; multi sub a ($a) { say "without named $a" }; a("bar")   # checking niecza

[11:24] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«without named bar␤»

[11:24] <Woodi> jercos: indirection eg. pointers allows to make changes in the middle

[11:24] <lizmat> rn: multi sub a ($a, :$foo) { say "with named $a $foo" }; multi sub a ($a) { say "without named $a" }; a("bar")

[11:24] <jercos> Woodi: yes, but only if the pointers can point to a mutable object :|

[11:24] <camelia> rakudo c5ba78: OUTPUT«use of uninitialized value of type Any in string context  in sub a at /tmp/8jPolJRUuH:1␤␤with named bar ␤»

[11:24] <camelia> ..niecza v24-95-ga6d4c5f: OUTPUT«without named bar␤»

[11:25] <lizmat> I think this calls for either a rakudo or niecza bug

[11:25] <colomon> lizmat: I would (possibly naively) expect the most specific multi to win.  but the least specific multi is winning.  my default assumption is bug.

[11:25] <FROGGS> lizmat: I think it should complain about an ambigious all

[11:25] <FROGGS> call*

[11:25] <lizmat> that at least

[11:25] <lizmat> but how can "no named parameters" not be narrower than "any named parameters" ?

[11:25] <colomon> seems like we've thought up three possible behaviors, and rakudo is doing *none* of them.

[11:26] * lizmat submist rakudobug

[11:26] <jercos> Woodi: if you're assuming pure immutability, there's no "changable container", and allowing such a thing breaks the very point of keeping everything immutable, namely allowing threads to work on the same data without checking locks or keeping logs

[11:27] * colomon goes looking in roast

[11:27] <Woodi> jercos: things that work usually are little gray, not white or black :) eg. OSI vs IP :)

[11:28] <jercos> well yes, in a *practical* sense you're always going to have mutability, you're working on machines with registers that can be changed, with a bank of memory that can be addressed and the data stored at a given address changes arbitrarily, but that doesn't solve the *problem* :p

[11:29] <colomon> positional-vs-named.t only tests named parameters declared with exclamation points.

[11:29] <Woodi> what was the problem, I forget now :)

[11:29] <colomon> rn: multi sub a ($a, :$foo!) { say "with named $a $foo" }; multi sub a ($a) { say "without named $a" }; a("bar")

[11:29] <camelia> rakudo c5ba78, niecza v24-95-ga6d4c5f: OUTPUT«without named bar␤»

[11:29] <jercos> Woodi: the problem is, if you give two threads a cookie, they're probably going to want a glass of milk to go with it ;)

[11:30] <lizmat> colomon: unfortunately, I need *all* named params to be optional  :-(

[11:30] <Woodi> ah, threads :) you must deal with shared memory or copy messages :)

[11:30] <colomon> rn: multi sub a ($a, :$foo?) { say "with named $a $foo" }; multi sub a ($a) { say "without named $a" }; a("bar")

[11:30] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«without named bar␤»

[11:30] <camelia> ..rakudo c5ba78: OUTPUT«use of uninitialized value of type Any in string context  in sub a at /tmp/B1iLu772zp:1␤␤with named bar ␤»

[11:31] <jercos> Woodi: when working at the low level, yes, but higher level programming allows for the same sort of abstraction you can have when dealing with a database, the idea of a transaction, or of concurrent reads and locking writes...

[11:33] <colomon> lizmat: while I agree there's something wonky going on here, do you really require two different subs?  should a("bar") and a("bar", foo=>False) do different things?

[11:33] <lizmat> well, this is about {} and [] accesses

[11:33] <lizmat> if there are no named params specified, I would like it to select the quickest sub

[11:34] <lizmat> *now* I have to check all of the passed named parameters for *each* bare [] and {} access

[11:34] <lizmat> aka:     $delete & $exists & $kv & $p & $k & $v === $default

[11:34] <lizmat>       ?? SELF.at_key($key)

[11:34] <lizmat> rather than just SELF.at_key($key)

[11:35] *** denis_boyun left
[11:35] <colomon> I'm not sure forcing rakudo to figure it out with a multi will be a performance win there.

[11:35] <Woodi> jercos: lastly I think implementation should fit clousely to required result... then you can design what work best... and levels of abstraction allows to do everything (inside)

[11:36] <lizmat> it's about being able to do this at compile time

[11:36] <colomon> I suppose if you have to have a multi anyway, it's not a bit deal...

[11:36] <lizmat> so each {} and [] access doesn't have to go through a multi

[11:36] <lizmat> but can be optimized to take the right one right away

[11:37] <jercos> Woodi: well yes, ideally at the highest level one should simply be able to write code that does things, and not have to worry about concurrency, because the language itself should be designed such that any way to express a problem can be paralellized if the problem is parallelizable.

[11:37] <jercos> but that's sort of a perfect-world thing.

[11:40] <Woodi> I lastly dreaming about cutting layers :) eg. putting html text in data section of asm code :) pages/templates do not change so often :)

[11:40] <Woodi> and servers work more then year... :)

[11:43] <Woodi> all that scripting languages, cpus hate them, I tell ya ;)

[11:50] <dalek> rakudo/method2sub: 25eddf5 | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[11:50] <dalek> rakudo/method2sub: Make all optional named param version handle no named param version

[11:50] <dalek> rakudo/method2sub: 

[11:50] <dalek> rakudo/method2sub: Because of a bug (#119929) the no-named parameter is never selected, unlike

[11:50] <dalek> rakudo/method2sub: Niecza.  Feels to me that a candidate with *no* named parameters is narrower

[11:50] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119929

[11:50] <dalek> rakudo/method2sub: than a candidate with *only* optional named parameters.

[11:50] <dalek> rakudo/method2sub: 

[11:50] <dalek> rakudo/method2sub: Fixing this bug should allow better optimization of all {} and [] accesses

[11:50] <dalek> rakudo/method2sub: without adverbs.

[11:50] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/25eddf504d

[11:51] <lizmat> spectest still not clean  :-(

[11:56] <timotimo> isn't the simples possible sum Maybe?

[11:56] <Araq> I think it's "None" ;-)

[11:58] *** EvanTeitelman joined
[12:01] <timotimo> that doesn't feel like a sum to me any more :)

[12:02] <timotimo> i think foo($a, :$foo) is narrower than foo($a), because foo($a) is really foo($a, *%)

[12:04] <lizmat> timotimo: then there should be an attribute "is nonamed" or something like that

[12:04] <dalek> rakudo-js: d8255c9 | (Pawel Murias)++ | runtime/reprs.js:

[12:04] <dalek> rakudo-js: Add a noop compose to the NFA repr.

[12:04] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/d8255c9c84

[12:04] <lizmat> because we will need the selection of the simplest candidate for speed

[12:04] <timotimo> hmm

[12:04] <timotimo> yes.

[12:07] *** cognominal left
[12:08] *** cognominal joined
[12:12] <masak> timotimo, Araq: ok, "simplest" was a slight exaggeration. :)

[12:12] <masak> but I consider Either to be simpler than Maybe.

[12:13] <masak> Maybe is the simplest monad, though.

[12:13] <masak> during my walk, I thought about the exponentials.

[12:13] <masak> it's kind of cool that CCCs are built up using sums, products, and exponentials.

[12:14] <masak> all of these are used for data abstraction. sums give us choice, products give us structure, and exponentials give us code-as-data.

[12:16] *** lizmat_ joined
[12:16] *** lizmat left
[12:16] <pmurias> CCCs?

[12:16] <diakopter> TimToady: I think crocket was just in a bad mood.

[12:16] <lizmat_> hmmm… the spectest just ate all of my RAM and virtual disk

[12:16] <diakopter> hoelzro: that's way more vmarray/sixmodelobject[] than I expected

[12:17] *** Araq left
[12:17] <masak> pmurias: https://en.wikipedia.org/wiki/Cartesian_closed_category

[12:17] <masak> pmurias: it seems to be Category Theory's answer to lambda calculus.

[12:17] <diakopter> hoelzro: it'd be nice to know where those were allocated

[12:17] <diakopter> (in the source)

[12:17] <cognominal> masak, have you checked elm? It does RFP and generates websites without messing with html, dom and canvas elements  http://elm-lang.org/  :)

[12:17] <Woodi> masak: Either is impler then Maybe and Maybe is simplest ? I assume Either is monad too...

[12:18] <diakopter> (whether directly from bytecode or indirectly from other bytecode in the runtime)

[12:20] <masak> Woodi: no, Either is not a monad.

[12:20] <masak> ...I don't think so anyway.

[12:20] <dalek> rakudo-js: d2391c0 | (Pawel Murias)++ | runtime/ (2 files):

[12:20] <dalek> rakudo-js: Mark delegation at compose time.

[12:20] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/d2391c0edb

[12:23] <Woodi> btw. on the Earth, how many we have ppls knowing Perl6 ? :)

[12:23] <diakopter> 1

[12:23] <masak> 0

[12:23] <diakopter> -1

[12:23] <Woodi> that's not good...

[12:24] <masak> -Inf

[12:24] <Woodi> I was estimating less then +10...

[12:24] <diakopter> yeah, in unary

[12:25] <Woodi> (mainly compilers writers)

[12:27] <diakopter> oh cool http://beta.hackage.haskell.org/

[12:27] <lizmat_> r: say {\01;42}

[12:27] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/RomqDcchmp:1␤    ------> [32msay {\01[33m⏏[31m;42}[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    a…»

[12:27] <lizmat_> this currently eats all RAM / vdisk  in method2sub

[12:28] <dalek> rakudo/method2sub: cfd148a | (Elizabeth Mattijsen)++ | src/Perl6/World.nqp:

[12:28] <dalek> rakudo/method2sub: Handle proper exceptions like they should

[12:28] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/cfd148acf2

[12:28] *** denisboyun joined
[12:30] <lizmat_> r: say "{\01;42}"

[12:30] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/N0UDcSfhpn:1␤    ------> [32msay "{\01[33m⏏[31m;42}"[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤   …»

[12:31] *** cono left
[12:36] <lizmat_> hmmm… oddly enough it happens in the parse stage:

[12:36] <lizmat_> $ perl6 --stagestats -e 'say {\01;42}'

[12:36] <lizmat_> Stage start      :   0.000

[12:36] <lizmat_> ^C

[12:37] *** fridim__ joined
[12:37] *** xenoterracide left
[12:38] *** ksh left
[12:39] <masak> Woodi: surely you're insider enough to see that "knowing Perl6" is slightly ill-defined without a context.

[12:39] <masak> Woodi: you could probably easily get TimToady to say he doesn't "know" Perl 6, and he's the prime candidate for knowing it.

[12:40] <lizmat_> further golf:

[12:40] <lizmat_> $ perl6 --stagestats -e '\00'

[12:40] <lizmat_> Stage start      :   0.000

[12:40] *** ksh joined
[12:41] <hoelzro> diakopter: that's from htmlify.pl in the doc repo

[12:42] <hoelzro> I'm working on tweaking the profiler to properly label P6Opaques

[12:45] <Woodi> masak: yes, quite stupid, reckless question. popularity is variable. but on the other hand Perl6 seems to be hard what is problematic and discouraging...

[12:46] <FROGGS> lizmat_: it happens in the parsing stage because it is thrown by the grammar

[12:46] *** lizmat_ is now known as lizmat

[12:46] <lizmat> yes, but where ???

[12:47] *** xenoterracide joined
[12:47] <lizmat> seems like \0 (only 0 ) folllowed by something else, with or without whitespace after the \0, eats all

[12:48] <diakopter> maybe a bug in quant (nfa or otherwise) :)

[12:48] <diakopter> well, probably not nfa.

[12:50] <FROGGS> lizmat: have you checked HLL::Grammar in nqp?

[12:50] <lizmat> no, not yet

[12:50] <FROGGS> nqp: '\012'

[12:50] <camelia> nqp: ( no output )

[12:50] <FROGGS> r: '\012'

[12:50] <camelia> rakudo c5ba78: ( no output )

[12:50] <FROGGS> r: "\012"

[12:50] <camelia> rakudo c5ba78: ( no output )

[12:51] <FROGGS> r: say "\012"

[12:51] <camelia> rakudo c5ba78: OUTPUT«␀12␤»

[12:51] <FROGGS> r: say "\01"

[12:51] <camelia> rakudo c5ba78: OUTPUT«␀1␤»

[12:51] <FROGGS> r: say 01

[12:51] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/V8QXyzzh1S:1␤    ------> [32msay 01[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at…»

[12:51] <FROGGS> nqp: 01

[12:51] <camelia> nqp: ( no output )

[12:51] <FROGGS> r: 01

[12:51] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/tU567Liomy:1␤    ------> [32m01[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tm…»

[12:52] <FROGGS> lizmat: rakudo/src/Perl6/Grammar.nqp:2747:                <!!{ $/.CURSOR.worry("Leading 0 does not indicate octal in Perl 6; pl...

[12:53] <lizmat> reverting changes I did World.nqp, just to be sure

[12:54] *** xenoterracide left
[12:58] <lizmat> changes I did to World are not the reason

[12:59] <diakopter> bisect?

[13:00] <diakopter> nqp: \\0

[13:00] <camelia> nqp: OUTPUT«Confused at line 2, near "\\\\0"␤current instr.: 'panic' pc 14693 (src/stage2/gen/NQPHLL.pir:5223) (src/stage2/gen/NQPHLL.nqp:279)␤»

[13:00] <diakopter> r: \\0

[13:00] <camelia> rakudo c5ba78: ( no output )

[13:00] <diakopter> r: \\00

[13:00] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tmp/q_A4w0UuRA:1␤    ------> [32m\\00[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /…»

[13:00] <diakopter> r: \\0o0

[13:00] <camelia> rakudo c5ba78: ( no output )

[13:00] <diakopter> r: \00

[13:00] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /tmp/AEjUGGMIYI:1␤    ------> [32m\00[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at /t…»

[13:00] <diakopter> r: eval('\00')

[13:00] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at eval_0:1␤    ------> [32m\00[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at eval_0:1␤  …»

[13:01] <diakopter> r: eval('\\00')

[13:01] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at eval_0:1␤    ------> [32m\00[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o0 if you mean that␤    at eval_0:1␤  …»

[13:03] *** xenoterracide joined
[13:03] <lizmat> ran it under gdb: https://gist.github.com/lizmat/6650426

[13:05] <GlitchMr> I don't see a problem.

[13:06] <lizmat> the only problem it has, is that it eats all of my 16G RAM in about 1 minute running

[13:06] <GlitchMr> \ is capture operator.

[13:07] <lizmat> could someone run the method2sub branch on a jakudo ?

[13:07] <diakopter> lizmat: what about \(0)0 and \(00)

[13:07] <lizmat> they also both hang

[13:08] <FROGGS> lemme build that branch...

[13:08] <lizmat> and eat all RAM

[13:08] <diakopter> what about \(0)

[13:08] * lizmat now understands why the method to sub migration for {} and [] has been laying on the shelf for 1+ year

[13:09] <GlitchMr> I personally would like a grammar without warning for 0 octal, but instead syntax error.

[13:09] <lizmat> diakopter: doesn't hang

[13:09] <diakopter> \(0)1 ?

[13:09] <lizmat> hangs

[13:09] <diakopter> \(0)a

[13:10] <lizmat> hangs

[13:10] <masak> GlitchMr: I like Perl 6. it fits the way I think when I program, even moreso than Perl 5.

[13:10] <diakopter> hm, well, seems like backtracking that doesn't reach the base case

[13:11] <GlitchMr> Well, warning is better than odd behavior in JS where 09 > 010.

[13:11] <GlitchMr> And even odder behavior in PHP where 09 == 0.

[13:11] <diakopter> what about \($_)a

[13:11] <lizmat> sanity check: while parsing the grammar in nqp, it shouldn't access any of Perl6's multi subs for {} or [], or should they?

[13:11] <timotimo> lizmat: have you considered *% where <= 0?

[13:11] <timotimo> er, i mean

[13:11] <timotimo> *% where * <= 0

[13:11] *** SamuraiJack_ left
[13:12] <timotimo> r: multi sub argh($foo, :$name) { say "with named" }; multi sub argh($foo, *% where * <= 0) { say "without named" }; argh("hi"); argh("hi", name => "me");

[13:12] <camelia> rakudo c5ba78: OUTPUT«with named␤with named␤»

[13:12] <lizmat> timotimo: will try in a bit

[13:12] <timotimo> >_<

[13:12] <diakopter> lizmat: hrm, not sure

[13:12] <timotimo> r: multi sub argh($foo, :$name, *% where * <= 0) { say "with named" }; multi sub argh($foo, *% where * <= 0) { say "without named" }; argh("hi"); argh("hi", name => "me");

[13:12] <camelia> rakudo c5ba78: OUTPUT«with named␤with named␤»

[13:12] <GlitchMr> r: subset Unsigned of Int where * > 0; sub something(Unsigned $value) { say $value }; something 1; something 2; something -3;

[13:12] <camelia> rakudo c5ba78: OUTPUT«1␤2␤Constraint type check failed for parameter '$value'␤  in sub something at /tmp/YwOp6RMNbP:1␤  in block  at /tmp/YwOp6RMNbP:1␤␤»

[13:12] <timotimo> don't bother, it doesn't seem to work

[13:12] <lizmat> ah, not working I see  ?

[13:13] <timotimo> :(

[13:13] <timotimo> apologies for getting your hopes up

[13:13] <lizmat> no pb

[13:13] <GlitchMr> r: subset Unsigned of Int where {say "Condition!"; $_ > 0}; sub something(Unsigned $value) { say $value }; something 1; something 2; something -3;

[13:13] <camelia> rakudo c5ba78: OUTPUT«Condition!␤1␤Condition!␤2␤Condition!␤Constraint type check failed for parameter '$value'␤  in sub something at /tmp/R7AOIY1mzi:1␤  in block  at /tmp/R7AOIY1mzi:1␤␤»

[13:13] <timotimo> i know how bad that feels, i do it to me all the time

[13:14] <lizmat> timotimo: know the feeling

[13:14] <GlitchMr> r: multi sub argh($foo, :$name!, *% where * <= 0) { say "with named" }; multi sub argh($foo, *% where * <= 0) { say "without named" }; argh("hi");

[13:14] <camelia> rakudo c5ba78: OUTPUT«without named␤»

[13:14] <GlitchMr> r: multi sub argh($foo, :$name!, *% where * <= 0) { say "with named" }; multi sub argh($foo, *% where * <= 0) { say "without named" }; argh("hi"); argh("hi", name => "me");

[13:14] <camelia> rakudo c5ba78: OUTPUT«without named␤with named␤»

[13:15] <lizmat> diakopter: rebuilding, one moment

[13:15] <lizmat> GlitchMr: all named params *must* be optional

[13:15] <diakopter> why

[13:16] <lizmat> diakopter: \($_)a hangs

[13:16] <lizmat> because the multi sub for simple {} and [] access, should be as simple as possible

[13:16] <diakopter> what about ($_)a

[13:16] <lizmat> also hangs

[13:16] <lizmat> hmmm...

[13:16] <diakopter> hunh.

[13:17] <lizmat> #multi sub postcircumfix:<{ }>( \SELF, $key ) is rw {   # NOT SELECTED

[13:17] <lizmat> #    SELF.at_key($key);

[13:17] <lizmat> #}

[13:17] <lizmat> now has become:

[13:17] <lizmat>     $delete & $exists & $kv & $p & $k & $v === $default

[13:17] <lizmat>       ?? SELF.at_key($key)

[13:17] *** xinming left
[13:18] <diakopter> where's the !!

[13:18] <lizmat> so for each "bare" {} access, we need to set up optional named parameters, and check them

[13:18] <lizmat>       !! SLICE_ONE( SELF, $key,

[13:18] <lizmat>            False, $delete, $exists, $kv, $p, $k, $v );

[13:19] <lizmat> having to set these up, and then check them, is not good for performance  :-)

[13:19] <diakopter> a slurpy hash might be faster

[13:19] <lizmat> diakopter: good point

[13:20] <diakopter> (maybe)

[13:21] <lizmat> hmmmm it seems to hang on a lot more

[13:22] <diakopter> yeah it sounds like backtracking is generally busted

[13:22] <diakopter> can you nopaste the branch diff?

[13:23] <diakopter> or is on github I can see it?

[13:23] <diakopter> *where

[13:23] <lizmat> it's on github, in the method2sub branch

[13:23] * diakopter fancies I can code-read it

[13:23] <lizmat> it's generally stupid and verbose code

[13:24] <timotimo> that's the worst kind :(

[13:24] <lizmat> trying to handle all the permutations of 6 named parameters, is kinda crazy

[13:24] <lizmat> bit still very useful, I thnk

[13:24] <lizmat> *but

[13:24] <lizmat> *think

[13:24] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/rakudo-jvm$ ./perl6 -e '\(0)'

[13:24] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/rakudo-jvm$ ./perl6 -e '\(0)0'

[13:24] <FROGGS> ===SORRY!=== Error while compiling -e

[13:24] <FROGGS> lizmat: how do you get the hang?

[13:25] <lizmat> perl6 -e '\01'   # simplest case

[13:25] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/rakudo-jvm$ ./perl6 -e '\01'

[13:25] <FROGGS> Potential difficulties:

[13:25] <FROGGS>     Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that

[13:26] <timotimo> lizmat: have you considered generating that code? >_<

[13:26] <lizmat> timotimo: yes, but at a later point, when I really know what to generate

[13:26] <timotimo> good point

[13:27] <diakopter> timotimo: yes, at runtime with each invocation :)

[13:27] <lizmat> the big problem with migrating this stuff from methods to subs

[13:27] <diakopter> GIMME THE SPEEDZ

[13:27] <lizmat> is that named parameters cannot be silently ignored

[13:27] <lizmat> if necessary

[13:28] <lizmat> and the method implementation depended on being able to do so

[13:28] <diakopter> yeah, need to check each one and count the valid ones, and see if the total number of keys is greater

[13:28] *** denisboyun left
[13:29] <timotimo> diakopter: sounds great!

[13:29] <timotimo> diakopter: that's just like jit, so it should be really fast!

[13:29] <timotimo> perhaps have to write your own proto to do the heavy work with the nameds?

[13:30] <lizmat> that also has come to mind

[13:30] <timotimo> spectesting: "t/spec/S02-magicals/file_line.t"  i read as "fine line"

[13:30] <timotimo> %)

[13:31] <lizmat> but I wanted to get something working the stupid way before getting smarter

[13:31] <diakopter> don't cross it

[13:31] <lizmat> r: sub a ($a) { say %_ }; a(:foo)

[13:31] <camelia> rakudo c5ba78: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/4fIFVMgB1r␤Placeholder variable '%_' cannot override existing signature␤at /tmp/4fIFVMgB1r:1␤------> [32msub a ($a) { say %_ }[33m⏏[31m; a(:foo)[0m␤    expecting any of:␤        postfix␤        state…»

[13:31] <lizmat> r: sub a { say %_ }; a(:foo)

[13:31] <camelia> rakudo c5ba78: OUTPUT«("foo" => Bool::True).hash␤»

[13:31] <timotimo> .u thin line

[13:32] <yoleaux> No characters found

[13:32] <timotimo> .u thin

[13:32] <yoleaux> U+2009 THIN SPACE [Zs] ( )

[13:32] <yoleaux> U+1F7A1 THIN GREEK CROSS [So] (🞡)

[13:32] <yoleaux> U+1F7A8 THIN SALTIRE [So] (🞨)

[13:32] <lizmat> hmmm… what was the argument about %_ again?  apparently, there is no %_ when there is a signature ?

[13:32] <diakopter> r: sub a (*%_) { say %_ }; a(:foo)

[13:32] <camelia> rakudo c5ba78: OUTPUT«("foo" => Bool::True).hash␤»

[13:32] <timotimo> you can still get at it through a |c and some method on that i guess

[13:32] *** xinming joined
[13:32] <timotimo> r: sub a (|c) { say c.^methods }; c(foo => 1);

[13:32] <camelia> rakudo c5ba78: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/mT2ucGMoWP␤Undeclared routine:␤    c used at line 1␤␤»

[13:32] <timotimo> r: sub a (|$c) { say $c.^methods }; c(foo => 1);

[13:32] <camelia> rakudo c5ba78: OUTPUT«Obsolete use of | or \ with sigil on param $c␤[31m===[0mSORRY![31m===[0m Error while compiling /tmp/sYAaJx8XyA␤Undeclared routine:␤    c used at line 1␤␤»

[13:32] <timotimo> r: sub a (|$c) { say $c.^methods }; a(foo => 1);

[13:33] <timotimo> %)

[13:33] <camelia> rakudo c5ba78: OUTPUT«Obsolete use of | or \ with sigil on param $c␤BUILD at_key at_pos hash exists list elems Capture FLATTENABLE_LIST FLATTENABLE_HASH pairs values keys kv gist Str Bool Numeric perl␤»

[13:33] <timotimo> r: sub a (|c) { say c.^methods }; a(foo => 1);

[13:33] <camelia> rakudo c5ba78: OUTPUT«BUILD at_key at_pos hash exists list elems Capture FLATTENABLE_LIST FLATTENABLE_HASH pairs values keys kv gist Str Bool Numeric perl␤»

[13:33] <timotimo> r: sub a (|c) { say c.hash.perl }; a(1, 2, 3, foo => 1, bar => 2);

[13:33] <camelia> rakudo c5ba78: OUTPUT«EnumMap.new("foo", 1, "bar", 2, )␤»

[13:33] <timotimo> perfect

[13:33] <diakopter> hehhe

[13:33] <timotimo> EnumMap, it's even a super low-level efficient superhash

[13:34] <lizmat> r: sub a (|c) { say c.hash.perl }; a(1, 2, 3, {} => 1, bar => 2);

[13:34] <camelia> rakudo c5ba78: OUTPUT«EnumMap.new("bar", 2, )␤»

[13:34] <lizmat> r: sub a (|c) { say c.hash.perl }; a(1, 2, 3, Exception.new => 1, bar => 2);

[13:34] <camelia> rakudo c5ba78: OUTPUT«EnumMap.new("bar", 2, )␤»

[13:35] <timotimo> haha, nice

[13:35] <lizmat> only if the keys are strings :-(

[13:36] <timotimo> .o( what, like in a piano? )

[13:36] <diakopter> forte.

[13:43] *** EvanTeitelman left
[13:43] <timotimo> QAST::SpecialArg  -  what is this thing o_O

[13:43] <timotimo> ah, it would appear that this is where you put a :named?

[13:44] <FROGGS> yes

[13:44] <FROGGS> it gets mixed in, to provide the .named AFAIR

[13:44] <FROGGS> get*

[13:47] <timotimo> good to know

[13:47] <timotimo> i'm revisiting my lexical-to-local branch for nqp

[13:48] <timotimo> it breaks stuff still

[13:49] <timotimo> annoyingly, it breaks stuff in the rakudo spectest suite, not during compilation of nqp or rakudo

[13:50] <lizmat> diakopter: on second thought, I probably don't want to use a slurpy hash

[13:50] <lizmat> using hashes inside has accesses has something creepy and fragile about it

[13:50] <lizmat> *hash accesses

[13:51] <diakopter> .oO( what if you could force p5 behavior of args )

[13:52] <timotimo> oh, i may not be looking for lexpad operations

[13:52] <timotimo> that must be it

[13:55] <timotimo> hm, wait

[13:55] <timotimo> there was something about Stmts and making temporaries not last after they get executed

[13:55] <timotimo> does that refer to Vars with :decl<local>?

[13:56] <timotimo> no, that wouldn't make sense ... but it may be true stil ...?

[13:56] <lizmat> timotimo: no idea

[14:02] <timotimo> is there an nqp op to clear out a hash?

[14:04] <diakopter> no, but you could probably make set_elems a special case for 0.. and throw on all other inputs

[14:04] <timotimo> class Optimizer { has $!stared_into_the_abyss; ... }

[14:05] <timotimo> has $!abandoned_all_hope;? has $!lost_all_will_to_live;?

[14:06] <timotimo> has $!flipped_the_table;

[14:06] <timotimo> has $no_chance_to_survive := "make your time" # hahahaha

[14:08] *** rindolf left
[14:13] *** SamuraiJack_ joined
[14:18] <timotimo> oh, i think i remember now that it was problematic to not have "is dynamic" because of the usages of [get/set]lex[dyn/caller/outer][_[i/n/s]]?

[14:21] *** benabik left
[14:31] <lizmat> ok, small summary:

[14:31] <lizmat> 1. method2sub branch hangs on the simplest code in the parsing stage, at least on parakudo

[14:32] <lizmat> such as '\01', or 'sub a ()'

[14:32] <lizmat> diakopter suggest backtracking is borked

[14:33] <timotimo> but backtracking surely doesn't depend on the core setting?

[14:33] <lizmat> that would be my thought also

[14:33] <timotimo> well, i've currently commented out most of my optimizer code and get a build failure due to "missing dependency" in nqp

[14:33] <masak> oh btw -- I was wrong earlier: Either is a monad.

[14:34] <masak> knowing that, I think it ties with Maybe in simplicity.

[14:34] <timotimo> okay, i found the culprit, but it doesn't make sense to me.

[14:34] <lizmat> fact is that before I refactored the sub calls to the one candidate with all possible named params

[14:34] <lizmat> I could run the spectest without it blowing up

[14:35] <timotimo> but that doesn't make sense! :o

[14:35] <lizmat> indeed… that's why I'm wrecking my braine

[14:36] <timotimo> if $op.op ~~ /[get|set]lex[dyn|caller|rel]*['_'[i|n|s]]?/ { $!no_grasp_on_lexicals := 1; say("mumble mumble"); } <- how can this cause my whole program to blow up in a weird way?

[14:36] <lizmat> verifying that the last sane commit was 23e9d5187082dbf425f70633fe7cf37600df8c88

[14:38] <timotimo> what's the obvious thing i'm not seeing?

[14:38] *** risou_awy is now known as risou

[14:40] <timotimo> apparently it's enough to have the if9~.

[14:40] <timotimo> does the ~~ operator do crazy things except set $/?

[14:41] <timotimo> hm, does nqp::ctx give me access to lexicals, too?

[14:42] *** REPLeffect left
[14:43] <dalek> rakudo-js: b31c2f9 | (Pawel Murias)++ | / (2 files):

[14:43] <dalek> rakudo-js: Some support for eval etc.

[14:43] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/b31c2f9913

[14:43] <dalek> rakudo-js: dab0fa0 | (Pawel Murias)++ | runtime.js:

[14:43] <dalek> rakudo-js: Convert arguments to split to strings.

[14:43] <dalek> rakudo-js: 

[14:43] <dalek> rakudo-js: This fixes test 80 on standalone nqp.

[14:43] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/dab0fa0ea2

[14:44] <pmurias> timotimo: and how do you detect contextuals?

[14:44] *** thou joined
[14:44] *** benabik joined
[14:45] <lizmat> 23e9d5187082dbf425f70633fe7cf37600df8c88 was the last sane commit

[14:45] <timotimo> pmurias: i hope they have the * in their name

[14:46] <pmurias> there is also $/

[14:46] <timotimo> also, :scope('contextual')

[14:46] <timotimo> $/ is specialcased, as is $_

[14:46] <timotimo> and everything with a * or ? sigil for good measure

[14:46] <pmurias> isn't :scope('contextual') currently only on access?

[14:47] <timotimo> i'm looking at all accesses, so that's fine. i just have to detect it and abort the transform in that case

[14:47] <timotimo> oorrrrrr

[14:47] <timotimo> a five-screen-lines || causes the compilation to not break

[14:47] <timotimo> what am i doing wrong >:(

[14:47] *** denis_boyun joined
[14:49] <timotimo> oh, also these contextuals seem to always be VarWithFallback and i ignore these (oh could that be what i'm doing wrong?)

[14:49] <timotimo> they are not always.

[14:50] <pmurias> hoopl uses something called optimalisation fuel to debug incorrect transforms

[14:50] <pmurias> if you have the abilty to limit the number of transform to $n, you can binary search the incorrect one

[14:51] <timotimo> interesting

[14:51] <pmurias> http://blog.ezyang.com/2011/06/debugging-compilers-with-optimization-fuel/

[14:52] <benabik> Hoopl is pretty awesome.

[14:52] <benabik> (Or at least seems that way conceptually, I've never used it.)

[14:53] *** thou left
[14:53] <lizmat> 2: tried changing the order of the candidates, no change

[14:53] <lizmat> 3. tried having the original methods around as well (in case we missed a code generation part), no change

[14:54] <lizmat> 4. tried having the useless sub candidates around, no change

[14:55] <timotimo> the point is: this is not an optimizer thing

[14:55] <timotimo> i turned off the optimization i added

[14:55] <timotimo> this is purely breaking the code by putting a regex match in

[14:57] <timotimo> is there another way to word a regex match in nqp?

[15:02] *** raiph joined
[15:02] *** rindolf joined
[15:03] <lizmat> 5: tried making at least 1 candidate with an obligatory named parameter, no change

[15:03] * lizmat is done with it for now

[15:04] <timotimo> :(

[15:04] <timotimo> i'm about to give up for now as well

[15:04] <lizmat> .tell jnthn please have a look at the method2sub branch and tell me why this makes perl6 -e '\01' hang on parakudo and eat all memory

[15:04] <yoleaux> lizmat: I'll pass your message to jnthn.

[15:05] <timotimo> you're not infinitely recursing, are you?

[15:05] <timotimo> i should probably just look at the code instead of guessing blindly

[15:05] <lizmat> timotimo: that could well be

[15:05] <lizmat> but I have no idea where that would be and how changing multi subs for {} and [] would make that happen

[15:05] <lizmat> please note, this is happening in the *parse* stage

[15:05] <timotimo> oh

[15:05] <timotimo> you changed the exception stuff

[15:06] <timotimo> have you considered reverting that commit temporarily?

[15:06] <timotimo> it could be it's trying to throw an exception and infinicursing that way

[15:06] *** ksh left
[15:06] <lizmat> I'm pretty sure I did that, but I will do that again

[15:06] <lizmat> just to make sure

[15:07] <timotimo> where do i find the definition of $default?

[15:07] <lizmat> in Any.pm, it's just a secret to determine whether a named parameter was passed or not

[15:07] <timotimo> OK

[15:08] <lizmat> $default = [];

[15:08] <timotimo> found it

[15:08] *** ksh joined
[15:09] * lizmat wishes there was a better way to determine whether a named parameter was passed

[15:11] <timotimo> yeah, |c

[15:11] <timotimo> is the only acceptable way i can think of

[15:13] <masak> anyone remember where the spec talks about the rules of multi dispatch?

[15:14] <masak> lizmat: what would be your suggested way to determine it?

[15:14] <masak> lizmat: and (more importantly), would it carry its own weight compared to $optional = DEFAULT ?

[15:14] <TimToady> S12:1161

[15:14] <synopsebot> Link: http://perlcabal.org/syn/S12.html#line_1161

[15:14] <masak> TimToady: thank you.

[15:15] <lizmat> 6: reverted the exception handler changes, no change

[15:15] <timotimo> i seem to be breaking tests in 01-qast.t

[15:16] <masak> I find nothing there that makes lizmat's finding not a bug.

[15:16] *** SamuraiJack__ joined
[15:16] <lizmat> well, then niecza has a bug  :-)

[15:17] <timotimo> ... huh?

[15:17] <timotimo> did you miss one of the two negations?

[15:17] <masak> rn: multi x($a) { say "right" }; multi x($a, :$x) { say "wrong" }; x(5)

[15:17] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/394ENwm7ty line 1:␤------> [32mmulti x([33m⏏[31m$a) { say "right" }; multi x($a, :$x) { [0m␤  $x is declared but not used at /tmp/394ENwm7ty line 1:␤------> [32mlti x($a) { say "right" …»

[15:17] <camelia> ..rakudo c5ba78: OUTPUT«wrong␤»

[15:17] <masak> n: multi x($) { say "right" }; multi x($, :$x) { say "wrong" }; x(5)

[15:17] <dalek> rakudo/method2sub: a819151 | (Elizabeth Mattijsen)++ | src/Perl6/World.nqp:

[15:17] <dalek> rakudo/method2sub: Return exception handler to original state to reduce noise

[15:17] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/a819151d80

[15:17] <camelia> niecza v24-95-ga6d4c5f: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/U8Lc7dxy_X line 1:␤------> [32mmulti x($) { say "right" }; multi x($, :[33m⏏[31m$x) { say "wrong" }; x(5)[0m␤␤right␤»

[15:18] <masak> lizmat, timotimo: both of you read me wrong :)

[15:18] <masak> I think it *is* a bug (in Rakudo(.

[15:18] <lizmat> not not!

[15:18] <timotimo> that's what i thought

[15:18] <masak> s:2nd/'('/)/

[15:18] <timotimo> and there's no bug in niecza, right?

[15:18] <masak> right.

[15:18] * masak submits rakudobug

[15:18] <timotimo> i think i read you right in that case

[15:18] <lizmat> is alreafy one

[15:18] *** SamuraiJack_ left
[15:18] <masak> oh, good.

[15:18] <lizmat> #119929

[15:18] <synopsebot> Link: https://rt.perl.org/rt3//Public/Bug/Display.html?id=119929

[15:19] <masak> synopsebot: you're a synopsebot, not an RTbot!

[15:19] <timotimo> welp, i can already tell that the "optimization" didn't change parse time in rakudo.

[15:20] <lizmat> tadzik++ hacked that into synopsebot :-)

[15:22] <lizmat> does anybody see how my changes to {} and [] handling can have such a profound influence on *parsing* ??

[15:22] *** EvanTeitelman joined
[15:22] <lizmat> 7. it *does* seem to occur whenever we have any type of warning or error during parsing

[15:23] <lizmat> r: sub a ()   # hangs

[15:23] <camelia> rakudo c5ba78: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/xevCOMJisx␤Missing block␤at /tmp/xevCOMJisx:1␤------> [32msub a ()   # hangs[33m⏏[31m<EOL>[0m␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤       …»

[15:23] <lizmat> r: sub a () {}  # does not hang

[15:23] <camelia> rakudo c5ba78: ( no output )

[15:23] <lizmat> r: \01

[15:23] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/HJ2OgWWcmy:1␤    ------> [32m\01[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /t…»

[15:27] <TimToady> r: \xCAFE

[15:27] <camelia> rakudo c5ba78: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/w56Ip_ryMp␤Undeclared routine:␤    xCAFE used at line 1␤␤»

[15:27] <TimToady> lizmat: note that your \ has nothing whatsoever to do with the 01

[15:28] <TimToady> \0 is meaningful only inside quotes and such

[15:28] <lizmat> TimToady: it's the shortest way to create an error, yes, 

[15:28] <TimToady> r: 01

[15:28] <camelia> rakudo c5ba78: OUTPUT«Potential difficulties:␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tmp/8iAKicTwMU:1␤    ------> [32m01[33m⏏[31m<EOL>[0m␤    Leading 0 does not indicate octal in Perl 6; please use 0o1 if you mean that␤    at /tm…»

[15:28] <TimToady> that's shorter

[15:28] <lizmat> it's how I found the problem originally

[15:28] <lizmat> indeed, '01' is shorter  :-)

[15:28] *** denis_boyun left
[15:29] <timotimo> why can't i have a variable named by the nullbyte? :(

[15:29] <lizmat> r: a

[15:29] <timotimo> perl6 limits me in my creative expression

[15:29] <camelia> rakudo c5ba78: OUTPUT«[31m===[0mSORRY![31m===[0m Error while compiling /tmp/MY6kkTp_rK␤Undeclared routine:␤    a used at line 1␤␤»

[15:29] <lizmat> oddly enough, this does *not* hang

[15:29] <lizmat> but that's *after* parsing

[15:30] <timotimo> right because subs are late-found

[15:31] <timotimo> ah, at least some of the fails i'm getting is due to extra output during compilation

[15:31] <timotimo> not ok 10 - multiple anonymous variables do not warn or err out

[15:31] <timotimo> #      got out: "# trial bind worked!\n# trial bind worked!\nalive\n"

[15:33] * TimToady reverts from random sniping mode to backlog mode...

[15:38] <timotimo> huh, a column chock full of "ok"

[15:38] <timotimo> i was expecting at least one "you are a failure and you should be ashamed of yourself"

[15:38] <TimToady> (via Need Moar Caffeine mode)

[15:39] *** btyler joined
[15:40] * FROGGS activates his MoarCM too

[15:41] * colomon has that blue Mountain Dew in the kitchen, but soooo shouldn't drink it.

[15:46] <timotimo> All tests successful. - i must have accidentally turned my optimization off somehow %)

[15:46] *** denis_boyun joined
[15:47] <timotimo> (maybe because i instantly bail out if i see anything with lex/dyn/whatevs in its name)

[15:51] <lizmat> method2sub theory: during parsing, whenever an exception is built, we go to Perl6 space with an exception object: somehow during the creation of that, something goes wrong. causing a new exception, etc. etc. ad infinitum

[15:52] <pmurias> timotimo: re avoiding ~~ you could use NQPCursor.parse($target, :rule($rule), :c(0))

[15:52] <lizmat> this probably bypasses the stack logic, otherwise we would have a recursion too deep error

[15:52] <timotimo> what does :c(0) do?

[15:52] <lizmat> or maybe we have

[15:52] <lizmat> but we never see that either

[15:52] <lizmat> timotimo: c => 0 ?

[15:53] <lizmat> same as :!c

[15:53] <timotimo> lizmat: very helpful thanks ... not ;)

[15:53] <lizmat> logically speaking

[15:53] <timotimo> i wondered what the c parameter to NQPCursor.parse means

[15:53] <lizmat> ah, ok

[15:53] <lizmat> sorry, missed context

[15:53] <timotimo> :)

[15:54] * lizmat steps away from the keyboard before inventing perl like TimToady did

[15:55] <timotimo> that is by letting your head fall onto the keyboard, right?

[15:56] <masak> "what is that, swearing?" :P

[15:56] <timotimo> "i need a way to swear at my computer and be understood"

[15:56] * geekosaur fully expects there is an esolang composed entirely of swear words

[15:56] <timotimo> cf negative numbers in shakespeare

[15:58] *** ajr joined
[15:58] *** ajr is now known as Guest38353

[15:59] <timotimo> d'oh

[15:59] <timotimo> i think i know what i'm doing wrong

[15:59] <timotimo> i think i'm trying to use regex before my nqp has any idea what those are

[15:59] <timotimo> wow, that sucks

[15:59] *** Guest38353 is now known as ajr_

[16:01] *** Guest60186 joined
[16:01] <timotimo> nqp: say(nqp::index("lex", "getlexdyn"))

[16:01] <camelia> nqp: OUTPUT«-1␤»

[16:01] <timotimo> nqp: say(nqp::index("l", "getlexdyn"))

[16:01] <camelia> nqp: OUTPUT«-1␤»

[16:01] <timotimo> huh.

[16:02] <timotimo> that's probably for lists?

[16:02] <timotimo> oh, no, it's just the other way around

[16:02] <timotimo> nqp: say(nqp::index("getlexdyn", "lex"))

[16:02] <camelia> nqp: OUTPUT«3␤»

[16:03] <timotimo> it's a start.

[16:06] <arnsholt> timotimo: That sounds weird. What kind of stuff are you working on?

[16:07] <timotimo> optimizer

[16:07] <timotimo> whenever i put any kind of regex into the code i get "oh no you don't has nqp-mo :( :( :("

[16:08] <pmurias> it seems wierd

[16:08] <btyler> did some log perusing: RE setting up VMs to try p6 with: it'd be pretty easy to set up vagrant boxes with everything pre-installed, just need to keep them up to date. native install packages are better for most cases though, I imagine

[16:08] <arnsholt> Yeah, that sounds really weird. What kind of error do you get?

[16:10] <arnsholt> (Oh, and is it NQP optimiser or Rakudo optimiser?)

[16:10] <timotimo> nqp optimiser

[16:12] <pmurias> timotimo: could you paste the error?

[16:12] <arnsholt> Yeah, that'd be great

[16:13] <timotimo> Missing or wrong version of dependency 'src/stage1/gen/nqp-mo.nqp'

[16:13] <timotimo> current instr.: '' pc 17537 (src/stage2/gen/nqp-mo.pir:7937) (src/stage2/gen/nqp-mo.nqp:1625)

[16:13] <timotimo> when building src/stage2/gen/NQPP5QRegex.nqp

[16:13] <arnsholt> Weird. I wouldn't really expect circularity issues while you're in the optimiser

[16:14] *** logie left
[16:14] <arnsholt> Maybe it's getting confused about where to get the regex things from

[16:14] <pmurias> isn't it a build issue?

[16:15] <arnsholt> What do you mean?

[16:17] <pmurias> that somehow modules that depend on different versions of the same file have been used together

[16:18] <pmurias> if B and C depend on A and you build them in the order B,A,C you get that error

[16:18] <timotimo> okay, time to try to do some benchmarks i guess

[16:18] <arnsholt> pmurias: Oh, in that sense

[16:19] <arnsholt> Maybe the optimiser is getting built before the regex things are done?

[16:20] *** denis_boyun left
[16:21] <arnsholt> timotimo: That might be worth trying. Try putting Optimizer.nqp last in the list of NQP_SOURCES

[16:21] <timotimo> later.

[16:22] <arnsholt> If that fails, I think the only advice I have left is to pester jnthn once he's back =)

[16:34] <timotimo> .o( if you have a crucial m4 ssd in any of your devices, get the latest smartmontools and see if smartctl -a will output a big fat warning)

[16:39] <dalek> nqp/r-lex-to-local: ecb8e5e | (Timo Paulssen)++ | src/NQP/Optimizer.nqp:

[16:39] <dalek> nqp/r-lex-to-local: try to turn lexicals into locals.

[16:39] <dalek> nqp/r-lex-to-local: review: https://github.com/perl6/nqp/commit/ecb8e5eed8

[16:39] <dalek> nqp/r-lex-to-local: d2a8131 | (Timo Paulssen)++ | src/NQP/Optimizer.nqp:

[16:39] <dalek> nqp/r-lex-to-local: first version to pass rakudo spectests

[16:39] <dalek> nqp/r-lex-to-local: review: https://github.com/perl6/nqp/commit/d2a8131fce

[16:43] <timotimo> mhh. perl6-bench still fails due to shell thingie

[16:45] <dylanwh> a

[16:46] <dylanwh> silly phone keyboards.

[16:48] <timotimo> perl6bench is somehow severely damaged

[16:51] *** Rotwang1 joined
[16:52] <timotimo> r: say cwd;

[16:52] <camelia> rakudo c5ba78: OUTPUT«IO::Path</home/p6eval>␤»

[17:10] *** lizmat left
[17:11] *** lizmat joined
[17:13] *** zakharyas joined
[17:14] *** mtk joined
[17:14] <dalek> nqp: 6bf0985 | (Pawel Murias)++ | t/nqp/55-multi-method.t:

[17:14] <dalek> nqp: Use ok(...) in test.

[17:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6bf0985372

[17:15] *** spider-mario left
[17:16] *** spider-mario joined
[17:20] *** logie joined
[17:20] *** spider-mario_ joined
[17:22] *** spider-mario left
[17:25] *** logie left
[17:26] *** krokite joined
[17:28] <masak> re the previous discussion today: Perl 6 is generally very good at refactoring stuff from one "shape" to another. it seems to me that from this viewpoint, the jump from an array/hash/lambdas shape of some data to an object shape of same data is unnecessarily long.

[17:28] <masak> and I'm currently mulling over how to shorten it.

[17:29] *** spider-mario_ is now known as spider-mario

[17:41] <dalek> rakudo/method2sub: f51a00b | (Elizabeth Mattijsen)++ | src/core/ (2 files):

[17:41] <dalek> rakudo/method2sub: Copy/paste candidates with one different required named param for selection

[17:41] <dalek> rakudo/method2sub: review: https://github.com/rakudo/rakudo/commit/f51a00baed

[17:42] <lizmat> this should at least make the simple {} and [] access select the simple, positional only candidate

[17:44] <masak> at its very smallest, a class/type simply puts a name to a recurring data structure.

[17:44] <masak> allowing you to more easily attach behavior to that class/type, etc.

[17:47] <benabik> If you have a hash with the same attributes as a class C, you can do C.new(|%hash).  Going the other way is less convenient, I think

[17:47] *** [Sno]_ joined
[17:47] <masak> going the other way is less important.

[17:47] <masak> it's more common to impose structure than to de-impose it.

[17:48] *** [Sno] left
[17:48] *** [Sno]_ is now known as [Sno]

[17:49] <benabik> .WHAT reflection should make it easy enough to create a general public attributes to hash function if needed.

[17:50] <benabik> lambda to method conversion is more difficult because the code would be different in each case.

[17:51] *** Rotwang1 left
[17:51] *** spider-mario left
[17:51] *** spider-mario joined
[17:53] *** zakharyas left
[17:55] <masak> yeah; I'm still not sure how lambdas fit into the bigger picture.

[17:55] <masak> not so sure they should be converted to methods.

[17:56] *** spider-mario left
[17:56] <masak> an object attribute could contain a lambda, too.

[17:56] *** xenoterracide left
[17:59] *** spider-mario joined
[18:02] *** wk joined
[18:04] *** wk left
[18:07] *** denysonique left
[18:07] *** Rotwang1 joined
[18:07] *** Rotwang1 left
[18:13] <Ulti> whiccd ..

[18:13] <pmurias> ?

[18:20] <geekosaur> miswindow, I think

[18:23] <pmurias> seems so

[18:23] *** rindolf left
[18:25] <timotimo> run seems to be b0rked WRT cwd

[18:26] <timotimo> we are in: /home/timo/build/perl6-bench/components/niecza

[18:26] <timotimo> Cloning into bare repository 'niecza.git'...

[18:26] <timotimo> but the niecza.git folder appears in /home/timo/build/perl6-bench/, which is the CWD of the perl6 interpreter

[18:26] * timotimo trolls the program by running it from components/

[18:27] <timotimo> sadly i'm not able to just replace the folders in the command with a full name, because there's also a git fetch in there that (except for changing the GIT_DIR env var or something) requires the pwd to be correct

[18:28] <timotimo> is the "emulate a CWD" code part of only non-parrot?

[18:28] <timotimo> because the parrot version of run doesn't have the $*CWD i nit

[18:31] <gtodd> pmurias: ++ blogging about the GSoC stuff you;re doing

[18:31] <pmurias> gtodd: you mean I should blog more?

[18:32] <timotimo> aparently that is so.

[18:35] <gtodd> hehe

[18:35] <gtodd> well do the GSoC stuff and blog about it when you can :)

[18:36] *** darutoko left
[18:37] <timotimo> can this get into the rakudo star release? a hotfix for rakudo?

[18:38] *** denysonique joined
[18:38] * timotimo shall build a test

[18:43] <timotimo> FROGGS: are you awake & available?

[18:43] <FROGGS> yes yes, whats up?

[18:44] <timotimo> i need a short test for roast that will run a subprocess on windows that checks if the last piece of the path is "t"

[18:44] <timotimo> on linux it'd look somewhat like run "pwd"

[18:45] <timotimo> can you tell me what return value { run "pwd" } on windows will give me, so that i can try linux first and then windows?

[18:45] <timotimo> hm, it's probably better to check for $*OS instead

[18:46] <timotimo> oh, hold on, run won't give me the output

[18:46] <timotimo> i need QX instead i think, but how do i test if run runs in the right CWD as well?

[18:47] <FROGGS> timotimo: cd does that for windows

[18:47] <timotimo> how about i try to run cd ../t/ to verify i'm in t (and hope that ../t/ doesn't exist for the rakudo directory ...)

[18:48] <timotimo> you know what. i'm not going to write a test, this is crazy.

[18:48] <timotimo> i'm not a sufficient rocketbrain

[18:49] <timotimo> at least i fixed it.

[18:50] <timotimo> how bad would it be to only return the return code from run instead of having the "return code but boolean" thing?

[18:50] <timotimo> because that still blows up horribly

[18:50] <FROGGS> I think you an be sure to be in the right 't' if you are in 't' and there is a 'spec'

[18:51] <FROGGS> it only returns the exit code, no?

[18:51] <timotimo> currently it returns the exit code, mixes in a bool and crashes parrot if you do it more than a couple of times

[18:51] <FROGGS> it should return a ProcessState objet though

[18:51] <FROGGS> wait

[18:51] <timotimo> we don't have that yet

[18:51] <timotimo> https://gist.github.com/timo/65fed23aaf44b9ebd4e1 - please merge this into nom and release a hotfix release?

[18:52] <FROGGS> ahh

[18:52] <timotimo> masak: ^

[18:52] <FROGGS> I was thinking about shell()

[18:52] <timotimo> shell may need that fix as well

[18:52] <timotimo> nope, that doesn't need a fix

[18:57] <masak> timotimo: waitwaitwait. I'm not backlogged. what caused this and why should we release a hotfix release?

[18:57] <masak> and when did I volunteer for that? :)

[18:57] <timotimo> hehe.

[18:57] <timotimo> this is a regression from when we changed over to $*CWD instead of nqp::chdir

[18:57] <timotimo> the parrot version of run and qx didn't know anything about $*CWD

[18:57] <masak> why does it merit a hotfix release?

[18:58] <timotimo> so everything you execute with run and qx on parrot will run in the cwd you started it in

[18:58] <masak> why didn't the spectests catch this?

[18:58] <timotimo> there are no tests for this, and it turns out that writing one is hairy

[18:58] <masak> seems retroactively we needed one, though. :)

[18:58] <timotimo> yes indeed

[18:58] <timotimo> you have to write a bit of stuff to run that gives you "i changed my directory" via the *return code*

[18:59] <timotimo> i know nowhere near enough shell and even less windows batch file stuff to make that happen

[18:59] <timotimo> it's much easier to do for qx, though, and i'll do that real soon™

[18:59] <timotimo> hotfix release is a good idea because R* isn't released yet

[18:59] <masak> just shell into perl6 and check the current directory?

[18:59] <masak> sounds easy to me :)

[18:59] <timotimo> oh, that's an interesting way to do it

[19:00] <masak> first one that occurred to me :)

[19:00] <timotimo> can we be guaranteed that "perl6" or "perl6.exe" will give us a correct perl6?

[19:00] <timotimo> also, i wasn't able to run perl6-bench

[19:00] <masak> I think there are already tests that do this.

[19:01] <timotimo> Test::Util probably has something?

[19:04] <timotimo> huh, why doesn't that work?

[19:05] <timotimo> is_run('say cwd', { out=>"/home/timo/build/rakudo/t/spec/" }) - that should work?

[19:06] <timotimo> no use, that uses shell.

[19:06] <masak> and why doesn't using shell work?

[19:07] <FROGGS> this gets $*CWD.Str as an arg

[19:07] <timotimo> because shell already works

[19:07] <timotimo> the trouble is in qx and run.

[19:07] <masak> I say if there's to be a hotfix release, there should also be a new passing test that fails on the previous release.

[19:08] <timotimo> testing run by using shell instead don't get you nowhere :)

[19:09] <GlitchMr> https://github.com/perl6/specs/commit/710337efafa2487b58e7b41859ad0232853b4af2

[19:09] <GlitchMr> Different? Does that mean "eqv", "~~", "===", or perhaps something else?

[19:10] <timotimo> FROGGS: i think i need your help :|

[19:11] <timotimo> i need to hotfix my SSD

[19:12] <GlitchMr> rn: my @array is default(42) = 42, 42, 42; say @array[1]:exists ?? "Yes" !! "No";

[19:12] <camelia> rakudo c5ba78: OUTPUT«Yes␤»

[19:12] <camelia> ..niecza v24-95-ga6d4c5f: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Trait default not available on variables at /tmp/HuAvzEuqkx line 1:␤------> [32mmy @array is default(42) [33m⏏[31m= 42, 42, 42; say @array[1]:exists ?? "Y[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niec…»

[19:13] <GlitchMr> rn: my @array is default(42) = 42, 42, 42; say @array[3]; say @array[1]:exists ?? "Yes" !! "No";

[19:13] <camelia> rakudo c5ba78: OUTPUT«42␤Yes␤»

[19:13] <camelia> ..niecza v24-95-ga6d4c5f: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Trait default not available on variables at /tmp/Xos4yQL2BS line 1:␤------> [32mmy @array is default(42) [33m⏏[31m= 42, 42, 42; say @array[3]; say @array[[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niec…»

[19:14] <timotimo> "i need to hotfix my SSD, while you please come up with tests" ;)

[19:16] <GlitchMr> Also, interesting, a day when I simply cannot put huge changelog.

[19:18] <timotimo> saved myself from death and destruction

[19:23] *** xenoterracide joined
[19:44] <timotimo> put a hug changelog instead?

[19:44] <FROGGS> timotimo: sorry, was away... what needs testing now?

[19:44] <timotimo> run and qx need to get a test that shows that they are affected by chdir

[19:45] *** xenoterracide left
[19:45] <FROGGS> k

[19:47] <FROGGS> $ perl6 -e 'use Test; chdir ".."; ok(qx{pwd} ne BEGIN qx{pwd})'

[19:47] <FROGGS> not ok 1 - 

[19:47] <FROGGS> timotimo: what about that?

[19:47] <timotimo> cool

[19:47] <timotimo> that works on windows? o_O

[19:48] <FROGGS> no, we'd use qx{cd} there

[19:48] <timotimo> ah, great

[19:48] <timotimo> now do it with run, too? :)

[19:49] <FROGGS> hmmm

[20:02] <timotimo> GlitchMr: the < > from <( )> got mangled in your blog or at least in my feed reader

[20:04] <GlitchMr> Huh? I just checked. < is properly encoded as &amp;lt; in RSS.

[20:04] <timotimo> it's definitely broken on your site.

[20:05] <GlitchMr> Where?

[20:05] <timotimo> <span class="str">/ [ ( something ) ]* /</span>

[20:05] <GlitchMr> <span class="str"> should be added client-side.

[20:05] <timotimo> yes, but this is about [ <( something )> ]*

[20:06] *** logie joined
[20:06] <GlitchMr> Everything looks fine.

[20:06] <GlitchMr> Oh.

[20:06] <timotimo> now you see it! :)

[20:07] <GlitchMr> Should be fixed after GitHub updates static HTML

[20:09] <timotimo> yes, there it is

[20:09] <FROGGS> damnit, why does run("cd t") doesnt work?

[20:09] <timotimo> because run spawns a subprocess

[20:09] <timotimo> oh, no

[20:10] <timotimo> because run expects you to split the arguments

[20:10] <FROGGS> ohh

[20:11] <FROGGS> $ perl6 -e 'say run("cd", "t")'

[20:11] <FROGGS> 255

[20:11] <FROGGS> :/

[20:11] <FROGGS> why?

[20:11] <timotimo> i think you want run(["cd", "t"]) instead?

[20:12] <FROGGS> no

[20:12] <timotimo> huh.

[20:12] <FROGGS> the problem is it doesnt know about cd there O.o

[20:12] <timotimo> on windows, 255 is success?

[20:12] <FROGGS> I'm on linux atm

[20:12] <timotimo> you need to call cmd.exe and pass cd t as its command?

[20:12] <timotimo> oh, right

[20:12] <FROGGS> I guess it is a shell built-in, and this shell doesnt know about it

[20:13] <timotimo> oh crap

[20:13] <timotimo> i need to compile my rakudo locally before i can help you

[20:13] <FROGGS> froggs@TL02L-R8RXTCW-linux:~/dev/rakudo$ perl6 -e 'say run("which", "dir")'

[20:13] <FROGGS> /bin/dir

[20:13] <FROGGS> 0

[20:14] <FROGGS> for "cd" there is no output but error code 1

[20:14] <timotimo> huh. i get no output and return code 0 for a bare cd

[20:15] <FROGGS> ahh, now I know

[20:15] <FROGGS> weird

[20:16] <FROGGS> $ perl6 -e 'use Test; chdir "t"; ok(run("dir", "t") != BEGIN run("dir", "t"))'

[20:16] <FROGGS> 00-parrot  01-sanity  02-rakudo  fudgeandrun  harness  spec  spectest.data

[20:16] <FROGGS> not ok 1 - 

[20:16] <FROGGS> this should be windows-safe too

[20:16] <timotimo> is != really right?

[20:16] <FROGGS> run returns the exit code

[20:17] <timotimo> oh, of course

[20:18] *** SamuraiJack__ left
[20:18] <FROGGS> is there a test file where we should add this to?

[20:18] <timotimo> probably somewhere in S32-io/

[20:19] <timotimo> either chdir.t or somewhere else

[20:19] <FROGGS> k

[20:19] <FROGGS> I'll add it and test it on my boxes

[20:21] *** SamuraiJack__ joined
[20:27] *** benabik left
[20:35] <dalek> roast: 84d6493 | (Tobias Leich)++ | S29-os/system.t:

[20:35] <dalek> roast: added tests that qqx/qx/run are affected by chdir()

[20:35] <dalek> roast: review: https://github.com/perl6/roast/commit/84d6493077

[20:36] <FROGGS> testing on windows in a sec

[20:40] <timotimo> thank you so much :)

[20:42] <FROGGS> :o)

[20:42] <FROGGS> pleasure

[20:45] <timotimo> the benchmarks show 0 change with my lexical to local transformation

[20:46] <timotimo> maybe it aborts too often, or maybe it just doesn't make a darn difference whatsoever

[20:46] *** spider-mario left
[20:46] <FROGGS> :(

[20:48] *** ssutch joined
[20:50] *** SmokeMac_ joined
[20:51] *** SmokeMachine left
[20:51] <FROGGS> timotimo: qqx/qx seems to behave on windows like on linux, but run() seems to be borken...

[20:52] <FROGGS> hmmm

[20:52] <FROGGS> gah, I an run perl6 itself, but no built-ins -.-

[20:53] <timotimo> :o

[20:55] <timotimo> hm, but how can qx work if it doesn't chdir?

[20:55] *** SamuraiJack__ left
[20:55] <FROGGS> C:\rakudo>perl6 -e "say run('cmd', '/c', 'dir')"

[20:55] <FROGGS> Der Befehl ""dir " ist entweder falsch geschrieben oder

[20:55] <FROGGS> konnte nicht gefunden werden.

[20:55] *** ajr_ left
[20:56] <FROGGS> timotimo: qqx it fails correctly

[20:56] <timotimo> oh you mean the test successfully shows that it's broken

[20:56] <FROGGS> but run() passes, because both fail

[20:56] <FROGGS> yes

[20:56] <timotimo> right. we need an extra piece of predicate in that

[20:58] <FROGGS> and run() itself need to be fixed in parrot or nqp I guess

[20:59] <timotimo> see my patch above

[21:00] <FROGGS> you mean the gist?

[21:00] <timotimo> yes

[21:00] <timotimo> that fixes run and qx

[21:00] <FROGGS> I meant this:

[21:00] <FROGGS> <FROGGS> C:\rakudo>perl6 -e "say run('cmd', '/c', 'dir')"

[21:00] <FROGGS> <FROGGS> Der Befehl ""dir " ist entweder falsch geschrieben oder

[21:00] <timotimo> oh

[21:00] <timotimo> well .... i have no clue what that is all about :(

[21:00] <timotimo> maybe you can use something different from dir?

[21:00] <FROGGS> hmm?

[21:00] <timotimo> something that's not a cmd builtin

[21:01] <FROGGS> that is why I invoke cmd /c

[21:01] <FROGGS> this can execute its built-in

[21:01] <FROGGS> (if it gets the args correctly)

[21:01] <timotimo> but apparently that doesn't work

[21:01] <timotimo> also what's with q{""dir "}

[21:04] <FROGGS> I guess this is how nqp/parrot assembles the passed argument

[21:04] <timotimo> wtf :\

[21:05] <FROGGS> k, patching now on linux and windows...

[21:05] <timotimo> the list is passed directly to pir::spawnw__IP

[21:05] <FROGGS> right

[21:05] <FROGGS> maybe we can emulate it, like it is done for shell

[21:07] <timotimo> where does nqp_shell lead? (that's what's registered for nqp::shell in Operations on parrot)

[21:07] <timotimo> ah, there it is

[21:07] <timotimo> it just does Run_OS_Command

[21:07] <timotimo> i think that's what spawnw also does

[21:07] <FROGGS> yeah, I thought so too

[21:10] <FROGGS> passes on linux now

[21:11] <FROGGS> my windows box still thinks about how all that bytecode should go into its files...

[21:11] <timotimo> %)

[21:15] *** PacoAir left
[21:16] <FROGGS> okay, looks good

[21:16] <FROGGS> timotimo: are you going to pull-request that or should I commit it?

[21:17] <timotimo> it would be lovely if you could commit it for me

[21:17] <FROGGS> k

[21:18] *** bruges left
[21:18] <dalek> rakudo/nom: 776f189 | (Tobias Leich)++ | src/core/control.pm:

[21:18] <dalek> rakudo/nom: hotfix by timotimo++ for qx/run when chdir-ing

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/776f18983c

[21:19] <pmurias> timotimo: nqp::shell is different from pir::spawnw__IP

[21:20] <timotimo> yes, but it uses it internally

[21:20] <timotimo> iirc

[21:20] <pmurias> no

[21:20] <pmurias> it does not

[21:20] <timotimo> oh

[21:20] <timotimo> whoops

[21:21] <pmurias> we have our own version of Run_OS_Command that passes env variables

[21:23] *** Mouq joined
[21:23] <FROGGS> pmurias: an we use that for run() ?

[21:25] *** benabik joined
[21:29] <pmurias> FROGGS: didn't you do the change rakudo do use nqp::shell on parrot part?

[21:29] <FROGGS> pmurias: not that I remember

[21:30] <FROGGS> maybe donaldh?

[21:30] <pmurias> FROGGS: I think we use our custom Run_OS_Command only for running shell commands

[21:31] <FROGGS> yeah, I think so too, but the question is: could we use it for run() too?

[21:31] <FROGGS> because this needs fixing

[21:31] <pmurias> with slight modification yes

[21:31] <FROGGS> that is what I wanted to hear *g*

[21:32] <pmurias> we would need to stop hardcoding /bin/sh

[21:35] <FROGGS> the only difference is that run() takes a list while shell() does not?

[21:36] <masak> FROGGS: the underlying reason had something to do with safe shell quoting, IIRC.

[21:36] <masak> maybe go back in the spec logs and check?

[21:36] <FROGGS> O.o

[21:41] <pmurias> FROGGS: hmm, execlvpe which takes both an env paramater and a array of arguments seems to be a GNU extension :/

[21:41] <FROGGS> damn, and it is not that easy on windows too

[21:41] <FROGGS> http://msdn.microsoft.com/en-us/library/windows/desktop/ms682425%28v=vs.85%29.aspx

[21:42] <benabik> You can use execve and do the path lookup manually.  :-/

[21:43] *** zakharyas joined
[21:45] <timotimo> not quite so hot, the fix :(

[21:45] <FROGGS> well, this is another unrelated issue

[21:46] <benabik> But "slightly chilled fix" doesn't have the same ring.

[21:46] <timotimo> FROGGS: if you had used git am with the file i gave you, you would have gotten the original commit i made ;)

[21:46] <benabik> pmurias: Doesn't execlvpe take variable number of parameters as the arguments?  execvpe would take an array.

[21:51] <FROGGS> timotimo: well, your patch  was somehow invalid :o) (the second chunk)

[21:52] <timotimo> how? :(

[21:52] <timotimo> i made it with git format-patch

[21:53] <timotimo> oh well, thanks for making it work then :)

[21:54] <pmurias> benabik: meant execvpe

[21:55] *** benabik left
[21:57] <pmurias> FROGGS: we could do it the brute way, and set the env variables to the one for the call, and then restore the old ones

[21:57] <pmurias> (I do it that way on nqp-js)

[21:59] <FROGGS> pmurias: it is not about the env, it is about how parrot is passing the args itself

[22:00] <FROGGS> perl6 -e "say run('cmd', '/c', 'dir')" # 'dir' ends up as '"dir ' on windows

[22:08] <pmurias> :/

[22:13] *** zakharyas left
[22:14] *** raiph left
[22:37] *** pmurias left
[22:45] *** amkrankruleuen left
[22:46] *** haagenti joined
[22:46] *** haagenti left
[22:46] *** amkrankruleuen joined
[22:47] *** amkrankruleuen left
[22:47] *** amkrankruleuen joined
[22:48] *** FROGGS left
[22:51] *** amkrankruleuen left
[22:57] *** dmol left
[23:01] *** amkrankruleuen joined
[23:05] <jercos> r: sub dieroll(Str $dice where /^ \d+ 'd' \d+ $/) {(1..+$1).roll(+$0)};dieroll("2d6").perl.say

[23:05] <camelia> rakudo 776f18: OUTPUT«use of uninitialized value of type Any in numeric context  in sub dieroll at /tmp/BGBp2S2wDz:1␤␤use of uninitialized value of type Any in numeric context  in sub dieroll at /tmp/BGBp2S2wDz:1␤␤().list␤»

[23:05] <jercos> erm.

[23:05] <jercos> r: sub dieroll(Str $dice where /^ (\d+) 'd' (\d+) $/) {(1..+$1).roll(+$0)};dieroll("2d6").perl.say

[23:05] <camelia> rakudo 776f18: OUTPUT«(1, 5).list␤»

[23:06] <jercos> That's what I thought, but...

[23:06] <jercos> oh, derp, made the same mistake on my end

[23:06] * jercos shows himself out

[23:07] <timotimo> :)

[23:07] <timotimo> next step: give the nqp optimizer a off flag

[23:08] <timotimo> an*

[23:10] *** btyler left
[23:16] *** rhr left
[23:38] *** BenGoldberg joined
[23:48] <masak> 'night, #perl6

[23:50] <colomon> \o

[23:54] <dalek> perl6-roast-data: 2cf4570 | coke++ | / (3 files):

[23:54] <dalek> perl6-roast-data: today (automated commit)

[23:54] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/2cf45702da

