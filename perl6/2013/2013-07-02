[00:01] *** pmichaud left
[00:03] *** pmichaud joined
[00:17] <timotimo> i'm slightly surprised the mu repo refers to the article http://swtch.com/~rsc/regexp/regexp1.html "Regular Expression Matching Can Be Simple And Fast", yet in rakudo the pathological regex is still pathological

[00:18] * timotimo disappears

[00:19] <[Coke]> ... gist finally updated after a family tech support incident.

[00:26] *** btyler joined
[01:10] *** FROGGS_ joined
[01:13] *** FROGGS left
[01:18] *** Patterner left
[01:42] *** btyler left
[01:50] *** btyler joined
[02:14] *** SamuraiJack_ joined
[02:43] *** BenGoldberg left
[02:49] * colomon is wondering how long he should give his latest awesome line of p6 code before he gives up on it...

[02:52] <colomon> oh, that wasn't so bad...

[02:56] <diakopter> .

[03:01] <colomon> my %by-name = lines.map(*.path).categorize(*.basename).grep(*.value > 1);

[03:03] <colomon> pass it a list of filenames, and it will find all the base names that are duplicates and build a hash from the base name to an array of duplicate paths.  :)

[03:04] *** kingbeast left
[03:08] <colomon> takes 3.5 minutes to process 15,000 filenames under parrakudo

[03:11] *** atroxaper joined
[03:16] *** benabik joined
[03:36] *** fgomez left
[03:38] <lee_> doe this look like a bug? https://gist.github.com/leedo/5906625

[03:39] <lee_> er, nevermind

[03:42] <benabik> r: &infix:<+> !=== &infix:<+>

[03:42] <camelia> rakudo d67185:  ( no output )

[03:42] <benabik> r: say &infix:<+> !=== &infix:<+>

[03:42] <camelia> rakudo d67185: OUTPUT«False␤»

[03:44] <lee_> is === the proper way to compare operators? or should I be using =:=?

[03:50] <TimToady> === should work

[03:50] *** preflex_ joined
[03:50] *** ChanServ sets mode: +v preflex_

[03:50] *** preflex left
[03:50] *** preflex_ is now known as preflex

[03:58] *** FROGGS_ left
[04:00] *** FROGGS_ joined
[04:00] *** chayin_ joined
[04:01] *** chayin left
[04:02] *** Chillance left
[04:03] *** btyler left
[04:22] *** FROGGS_ left
[04:33] <sorear> good * #perl6

[04:34] <lee_> r: all(1,2) ~~ Int

[04:34] <camelia> rakudo d67185:  ( no output )

[04:34] <lee_> r: say all(1,2) ~~ Int

[04:34] <camelia> rakudo d67185: OUTPUT«False␤»

[04:35] <sorear> whee, more backlog than fits in my buffer

[04:35] <sorear> how's the jvm port?

[04:49] *** xinming left
[04:49] <JimmyZ> sorear: 90% passed

[04:51] *** xinming joined
[04:55] *** toddr joined
[04:56] <sorear> JimmyZ: sweeeet

[05:01] *** birdwindupbird joined
[05:03] <JimmyZ> sorear: 90% passed

[05:03] *** xilo left
[05:03] <JimmyZ> irssi--

[05:07] <lee_> does this look curious to anyone else? https://gist.github.com/leedo/5906863

[05:08] <JimmyZ> lee_: nope

[05:09] <JimmyZ> lee_: why need two (( ?

[05:09] <lee_> why does the *@flat signature work on n and not m?

[05:10] <sorear> because (Any) is more specific than a slurpy

[05:10] <JimmyZ> lee_: try m(1,2,3);

[05:10] <sorear> subsignatures are a kind of postconstraint; they apply after the multidispatcher is done

[05:10] <lee_> JimmyZ: the section of code i am working on gets passed a parcel

[05:11] <lee_> sorear: ok thanks, i think that makes sense

[05:13] <sorear> although..

[05:13] <sorear> r: https://gist.github.com/leedo/5906863

[05:13] <camelia> rakudo d67185: OUTPUT«flattened 3␤got Range␤flattened 3␤»

[05:13] <sorear> n: https://gist.github.com/leedo/5906863

[05:13] <camelia> niecza v24-86-g39ab531: OUTPUT«Potential difficulties:␤  $range is declared but not used at /tmp/ik76Y12fzw line 9:␤------> multi sub m ((Range ⏏$range)) {␤␤flattened 3␤got Range␤flattened 3␤»

[05:13] <lee_> hmm, i am running on jvm-rakudo

[05:14] <sorear> D:

[05:14] <sorear> regresssssion

[05:14] <sorear> do we have a test for that?

[05:14] <lee_> i can poke around for one tomorrow

[05:14] <sorear> so jvm-rakudo is now being used in the wild? :)

[05:14] <lee_> sorear: if me being bored is in the wild, yes :P

[05:19] *** toddr left
[05:19] *** konundra left
[05:28] *** ecocode joined
[05:28] <lee_> sorear: it looks like some related tests are failing in S06-multi/unpackability.t

[05:29] <lee_> (on jvm)

[05:39] *** Psyche^ joined
[05:39] *** Psyche^ is now known as Patterner

[05:43] *** Patterner left
[05:47] *** Psyche^ joined
[05:47] *** Psyche^ is now known as Patterner

[05:48] *** zby_home joined
[05:51] *** raiph left
[05:52] *** Patterner left
[05:54] *** Psyche^ joined
[05:54] *** Psyche^ is now known as Patterner

[06:01] *** Patterner left
[06:09] *** Psyche^ joined
[06:09] *** Psyche^ is now known as Patterner

[06:12] *** Patterner left
[06:18] *** dmol joined
[06:24] *** FROGGS[mobile] joined
[06:24] <FROGGS[mobile]> o/

[06:25] <sorear> o/

[06:25] *** berekuk left
[06:26] <JimmyZ> lee_: try m(1,2,3);

[06:26] <JimmyZ> irssi-- again

[06:26] <JimmyZ> :(

[06:27] <sorear> why is your irssi randomly repeating lines

[06:28] *** berekuk joined
[06:35] *** FROGGS[mobile] left
[06:37] *** FROGGS joined
[06:40] <sorear> hmm, if I go ahead with this 9-to-5 thing it'll really hurt my overlap with jnthn :|

[06:40] *** raiph joined
[06:41] <JimmyZ> because I press up arrow to look for '/window next', when I see it, I press enter, but It suddenly switch to another msg 

[06:41] * JimmyZ cant't find another way, i.e: ctrl+r or ctrl+1

[06:43] <sorear> alt-right arrow

[06:43] <JimmyZ> It doesn't work in Xshell4

[06:44] <sorear> alt-1..alt-o

[06:44] <sorear> try esc, meta

[06:44] <JimmyZ> I can only use ctrl+x to switch irc server

[06:46] <JimmyZ> sorear++, esc + 1/2/3 works

[06:50] *** kaleem joined
[06:50] *** pmurias joined
[06:51] <pmurias> when pushing multiple commits to nqp are some of them allowed to break tests if the last one passes?

[06:53] <FROGGS> if you push all at once, I'd say yes

[06:53] <FROGGS> because sometimes it is nicer to split things to have smaller commits

[06:54] <sorear> I think not, because I think the point is bisectability

[06:54] <FROGGS> hmmm, good point

[06:57] <pmurias> sorear: so I should squash them into a single commit?

[06:57] <moritz> either that, or make it a branch and merge

[06:58] <moritz> otoh we aren't very strict about such rules in nqp land

[06:58] <FROGGS> bisecting is hard these days anyway, at least for rakudo when you have to rebuild nqp

[06:59] *** domidumont joined
[07:12] <dalek> roast: 9c64dd0 | (Tobias Leich)++ | S32-num/rshift_pos_amount.t:

[07:12] <dalek> roast: added test for right shifting by a positive amount

[07:12] <dalek> roast: review: https://github.com/perl6/roast/commit/9c64dd0282

[07:15] *** domidumont left
[07:16] *** domidumont joined
[07:20] *** bbkr joined
[07:36] *** daxim joined
[07:43] <lizmat> good *, #perl6!

[07:43] <labster> good * lizmat!

[07:44] <woosley> hello world 

[07:44] <lizmat> woosley! labster!

[07:45] <nwc10> FROGGS: script it!

[07:46] <nwc10> given that in 5 years time, Rakudo will still need NQP (re)building to bisect problems, the sooner that someone automates the bisection dance, the sooner it stops being hard

[07:46] <nwc10> this isn't work that is going to be thrown away

[07:46] <nwc10> (yes, it *is* work)

[07:46] <woosley> hello #perl6, how can I do "get start with nqp and rakudo and Perl6 and even MoraVM" ? 

[07:46] <FROGGS> nwc10: nice idea

[07:47] *** ztt joined
[07:47] <lizmat> .oO{ A virtual machine for snacks }

[07:47] <sorear> o/ labster, lizmat, woosley (ETOOCLOSE2WOOLFY), nwc10

[07:47] <FROGGS> virtual snacks?

[07:48] <lizmat> Mora is a world renowned brand of snacks in the Netherlands

[07:48] <sorear> world renowned, but only in the Netherlands?

[07:49] <labster> most world-renowned things are only renowned by a subset of the world.

[07:50] <lizmat> :-)

[07:50] <DrEeevil> lizmat: ... and belgium!

[07:50] <DrEeevil> "if we sell it you can fry it", right?

[07:50] <lizmat> yup

[07:53] *** labster left
[07:54] *** labster joined
[07:54] <lizmat> .tell jnthn I think the problem is that the default default is not set in the ContainerDescription

[07:54] <yoleaux> lizmat: I'll pass your message to jnthn.

[07:54] <labster> woosley: is that a "how do I learn Perl 6" or "how to I help out" question?

[07:55] <lizmat> .tell jnthn in Actions.nqp, between lines 1943 and 1951 we need to add a default_value key to %cont_info, but I have no idea where to get that from :-(

[07:55] <yoleaux> lizmat: I'll pass your message to jnthn.

[07:55] <woosley> labster: Maybe how do I help out?   

[07:56] <FROGGS> tools/build/bisect.pl --good-is-when="ok 12 - Some crazy test"  - or - tools/build/bisect.pl --bad-is-when="nok 12 - Some crazy test"

[07:57] <FROGGS> nwc10: would that be what you think?

[07:58] <labster> woosley: well, that's easy:  You should just try to have fun with P6.  There are simple things, like writing tests, or just making a module and adding it to the ecosystem.  There are more difficult things like diving into the guts of the compilers, and writing C/Java/NQP.

[07:58] <FROGGS> I guess it should ingore (?) checkouts somehow that cant be build

[07:58] <sorear> ignore

[07:59] <lizmat> .tell jnthn scratch that last one: container_type_info is doing that already

[07:59] <yoleaux> lizmat: I'll pass your message to jnthn.

[07:59] *** bbkr left
[07:59] <labster> woosley: Do whatever you're comfortable with for now -- even using the language helps us out.  And ask here if you have any specific questions/problems.

[08:03] <woosley> labster: Aha, all right, I suppose I can start write some little programs  using  Perl6 

[08:03] *** xinming left
[08:05] <sorear> I guess I just need to get up realllly early and schedule overlap time before $dayjob time

[08:05] *** xinming joined
[08:06] <sorear> on that thought, sleep&

[08:06] *** zby_home left
[08:06] <labster> I get the sense that sorear's sense of "really early" is "about the time normal people wake up"

[08:07] <sorear> labster: thinking more like 5

[08:07] <labster> oh well, that is really early :)

[08:11] <pmurias> a parrot code ref is a PMC*?

[08:13] <lizmat> Parrot Magic Cookie, could be anything, afaik

[08:15] <tadzik> good morrning

[08:19] <pmurias> morning

[08:19] *** Stygia joined
[08:22] <lizmat> tadzik! pmurias!

[08:22] <lizmat> .g thinko

[08:23] <yoleaux> http://www.urbandictionary.com/define.php?term=thinko

[08:29] <lizmat> .g PMC

[08:29] <yoleaux> http://www.ncbi.nlm.nih.gov/pmc/

[08:30] <lizmat> that's completely out of context for #perl6

[08:30] <lizmat> .j

[08:30] <lizmat> .j thinko

[08:30] <lizmat> maybe .j should take the lemma's of S99 ?

[08:41] *** dakkar joined
[08:43] <lizmat> fitness&

[08:48] <raiph> .tell jnthn fperrad has confirmed that "My future goal is to add a TvmJIT backend to https://github.com/perl6/nqp/"

[08:48] <yoleaux> raiph: I'll pass your message to jnthn.

[08:51] *** SamuraiJack_ left
[08:52] *** SamuraiJack_ joined
[08:54] <raiph> .tell jnthn TvmJIT being more or less LuaJIT (but with s-expression syntax)

[08:54] <yoleaux> raiph: I'll pass your message to jnthn.

[08:56] *** fhelmberger joined
[09:01] <JimmyZ> \o/ another backend

[09:03] <dalek> nqp: afa84b8 | (Pawel Murias)++ | / (9 files):

[09:03] <dalek> nqp: Wrap subs in a NQPRoutine code object when NQPRoutine is in scope.

[09:03] <dalek> nqp: 

[09:03] <dalek> nqp: We need capturelex to get that to work properly.

[09:03] <dalek> nqp: I's a port of p6capturelex that takes the code objects type as an argument rather than assuming it's a Rakudo Code.

[09:03] <dalek> nqp: We also add a test that ensures subs are wrapped in codeobjects.

[09:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/afa84b8365

[09:03] <nwc10> And Unladen Swallow will make Python 5 times faster and remove the GIL

[09:04] <nwc10> ie, it's only "another backend" when it's done

[09:04] <nwc10> but it *is* good news that people are working on things like this

[09:05] <masak> good antenoon, #perl6

[09:06] <masak> man, it's hard to focus on anything with new HPMoR episodes out...

[09:07] <pmurias> hi

[09:08] * pmurias goes off to read the newest HPMoR chapter while his latest nqp commit is tested on both backends ;)

[09:08] <FROGGS> $another_backend means too that NQP has a great acceptance... and I like that :o)

[09:08] <moritz> masak: not so hard to focus on reading HPMoR :-)

[09:08] *** Stygia left
[09:11] *** xinming left
[09:12] *** xinming joined
[09:12] <nwc10> masak: how long will it take you to read them all?

[09:12] * jnthn yawns

[09:12] <yoleaux> 07:54Z <lizmat> jnthn: I think the problem is that the default default is not set in the ContainerDescription

[09:12] <yoleaux> 07:55Z <lizmat> jnthn: in Actions.nqp, between lines 1943 and 1951 we need to add a default_value key to %cont_info, but I have no idea where to get that from :-(

[09:12] <yoleaux> 07:58Z <lizmat> jnthn: scratch that last one: container_type_info is doing that already

[09:12] <yoleaux> 08:48Z <raiph> jnthn: fperrad has confirmed that "My future goal is to add a TvmJIT backend to https://github.com/perl6/nqp/"

[09:12] <yoleaux> 08:54Z <raiph> jnthn: TvmJIT being more or less LuaJIT (but with s-expression syntax)

[09:21] * FROGGS .oO( rm -rf INBOX )

[09:22] *** xinming left
[09:23] *** xinming joined
[09:23] <dalek> nqp: 5942262 | (Pawel Murias)++ | / (2 files):

[09:23] <dalek> nqp: Fix BEGIN blocks, they get outer lexicals and can return a value. Add a test.

[09:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5942262224

[09:25] <pmurias> jnthn: BEGIN blocks are fixed and subs wrapped in code objects on both backends

[09:25] <FROGGS> dont we have four backends atm?

[09:26] <FROGGS> (and a fifth in the queue?)

[09:26] <pmurias> FROGGS: jvm,parrot,moarvm,js

[09:26] <nwc10> no, we have one working backend

[09:27] <FROGGS> true

[09:27] <nwc10> one more nearly working

[09:27] <FROGGS> nwc10: I said nothing about their state :o)

[09:27] <nwc10> and I don't think that any of the others can even self-host NQP yet

[09:27] *** raiph left
[09:28] <nwc10> if you *don't* qualify it, people will assume that it's useful and working

[09:28] <FROGGS> I think pmurias knows what is going on

[09:29] <FROGGS> and others can ask, it is a chat

[09:29] *** xinming left
[09:29] <nwc10> it's also logged for posterity, and can be taken out of context

[09:29] *** Stygia joined
[09:29] <nwc10> I wasn't aware of it in context

[09:29] <FROGGS> so, I am thinking it would be nice to smoke *all* in-dev-and-future-backends, if possible

[09:29] <nwc10> but I likely will still be upset by inexact use of terms

[09:30] <nwc10> a reputation for "vapourware" is a big problem

[09:30] <FROGGS> then I will try to be more exact in future

[09:30] <nwc10> thanks

[09:30] *** xinming joined
[09:30] <nwc10> and I'll try not to be so jumpy

[09:30] <FROGGS> *g*

[09:33] *** pecastro left
[09:39] <jnthn> On backends, I think it's worth remembering that JVM has taken ~8 months to get to 90% spectest coverage.

[09:39] *** pecastro joined
[09:39] <jnthn> Now yes, a lot of that was designing portability abstractions, etc.

[09:39] <jnthn> But still, it's a non-small piece of work.

[09:42] <FROGGS> well, I had expected a few months more to get to this point fwiw

[09:42] <jnthn> :)

[09:43] <FROGGS> jnthn: so I can read a nice blog post on my couch tonight? :P

[09:48] <jnthn> FROGGS: Once the numbers in roast-data look good :)

[09:48] *** bbkr joined
[09:49] <FROGGS> I'll buy beer to be on the safe side...

[09:50] *** bbkr left
[09:50] * FROGGS .oO( because we all now, "blog" means "beer + lying on gouch" )

[09:51] *** rindolf joined
[09:51] <nwc10> mmm, roast. To eat with the beer

[09:54] <jnthn> Hmm...$dayjob of Perl 6... :)

[09:54] <jnthn> *or

[09:55] <jnthn> Guess I can try and knock out a few more passes :)

[10:01] *** rindolf left
[10:09] *** dmol1 joined
[10:09] *** dmol left
[10:13] *** dmol1 left
[10:14] *** dmol joined
[10:27] <FROGGS> jnthn++

[10:27] <FROGGS> :o)

[10:31] <dalek> rakudo/nom: 54b7dd5 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/ (2 files):

[10:31] <dalek> rakudo/nom: Enforce scalar container type constraints.

[10:31] <dalek> rakudo/nom: 

[10:31] <dalek> rakudo/nom: Fixes various tests that relied on them being enforced.

[10:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/54b7dd5427

[10:35] <jnthn> Down to 166 test files with failures by now.

[10:37] <FROGGS> jnthn: if you have time, can you run t/spec/S32-num/rshift_pos_amount.t and see if it passes/fails on jakudo?

[10:38] <FROGGS> I added it but it is not in spectest.data yet

[10:39] <jnthn> pmurias: Your changes broke the Rakudo JVM build :(

[10:39] <lizmat> r: my $a; say $a; $a=Nil; say $a  # incorrect, untested bahviour

[10:39] <camelia> rakudo d67185: OUTPUT«(Any)␤Nil␤»

[10:40] <jnthn> Hm, probably Rakudo Parrot on latest NQP too.

[10:40] <FROGGS> will test

[10:40] <lizmat> fwiw, I broke the Nil behaviour!

[10:40] <jnthn> FROGGS: Can't try that until I unbust the build... :(

[10:41] <FROGGS> jnthn: of course

[10:46] <lizmat> .tell TimToady if we're going to put Nil outside of Any, things like this will break, as they now break with Mu: my $a; say $a === Mu

[10:46] <yoleaux> lizmat: I'll pass your message to TimToady.

[10:46] <lizmat> r: my $a; say $a === Mu

[10:47] <camelia> rakudo d67185: OUTPUT«Nominal type check failed for parameter ''; expected Any but got Mu instead␤  in sub infix:<===> at src/gen/CORE.setting:2041␤  in block  at /tmp/viS4a7jFuG:1␤␤»

[10:47] <lizmat> r: say Mu === Mu

[10:47] <camelia> rakudo d67185: OUTPUT«Nominal type check failed for parameter ''; expected Any but got Mu instead␤  in sub infix:<===> at src/gen/CORE.setting:2041␤  in block  at /tmp/qywc7ybuFt:1␤␤»

[10:48] <lizmat> r: say Mu =:= Mu   # works!  :-)

[10:48] <camelia> rakudo d67185: OUTPUT«True␤»

[10:48] <jnthn> Bother. The thing I thought would fix it didn't. :(

[10:48] <FROGGS> jnthn: yes, pakudo doent like it: Method 'get_lexinfo' not found for invocant of class 'NQPRoutine'

[10:49] <jnthn> :(

[10:49] <jnthn> Yes, making substantial NQP changes and not testing them against Rakudo is a very good way to get me to revert stuff....

[10:51] <jnthn> Especially when you change the semantics of BEGIN, which was only put in NQP for the sake of Rakduo's BOOTSTRAP.

[10:51] *** cognominal left
[10:52] <tadzik> hmm. Why do Perl 6 modules like Actions.nqp, Pod.nqp etc end up being jars, and not just classes?

[10:52] <jnthn> tadzik: Because we can more easily package the serialization stuff into the JAR

[10:53] <jnthn> tadzik: Rather than having to shove it in the class file constant pool, which has quite strict limits and required encoding.

[10:53] <tadzik> I see

[10:54] <tadzik> also, shouldn't make clean remove blib? :)

[10:55] <tadzik> but then I have to manually create blib/Perl6

[10:56] <jnthn> yes, we have a .gitignore in there to make sure it exists. :)

[10:56] <nwc10> I'd never thought of the idea of using .gitignore as a hack to avoid needing an '.exists' file or other directory-dropping

[10:59] <dalek> nqp: 8ca10b2 | jnthn++ | / (2 files):

[10:59] <dalek> nqp: Revert BEGIN work, as it breaks Rakudo.

[10:59] <dalek> nqp: 

[10:59] <dalek> nqp: It now lives in a branch begin-lexicals.

[10:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8ca10b2f32

[10:59] <dalek> nqp: f40a989 | jnthn++ | / (9 files):

[10:59] <dalek> nqp: Revert routine wrapping; breaks Rakudo build.

[10:59] <dalek> nqp: 

[10:59] <dalek> nqp: This commit can also be found in begin-lexicals branch now.

[10:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f40a989602

[11:00] *** atroxaper left
[11:01] <jnthn> pmurias: The patches caused serious breakage to Rakudo's BOOTSTRAP. It may even *rely* on BEGIN not being fully implemented in NQP. The only reason NQP got BEGIN was for the bootstrap in Rakudo... The work is now in a branch that I've pushed.

[11:02] <jnthn> pmurias: I don't actually much care that BEGIN is only half-implemented in NQP; NQP is, after all, just a subset. I guess you want it for something, though?

[11:02] <pmurias> yes

[11:04] <pmurias> I wanted that to test deserializing closures

[11:04] <pmurias> I planned to create them a compile time with BEGIN

[11:05] <pmurias> jnthn: routine wrapping breaks Rakudo or just BEGIN?

[11:05] <FROGGS> pmurias: I'll be around if you want me to test commits of a given branch (other than master/nom) of parrot/nqp/rakudo

[11:11] <jnthn> pmurias: Wrapping. I did this, https://gist.github.com/jnthn/5908412 , but it was then broken with another error.

[11:12] <jnthn> So maybe the BEGIN stuff is to blame for the secondary breakage.

[11:15] <jnthn> pmurias: Aren't there already some closure serialization tests?

[11:16] *** mstefanko left
[11:16] <jnthn> t/serialization/03-closures.t

[11:16] <jnthn> ?

[11:16] * jnthn uses those when porting the JVM stuff...

[11:17] <jnthn> *to

[11:19] <pmurias> jnthn: I don't have serialization yet, only deserialization so I wanted the compiler to serialize stuff for me

[11:20] <pmurias> jnthn: if I want to create a pull request to rakudo, how should I check that it still passes all the tests?

[11:22] <jnthn> pmurias: On Parrot, make spectest should come out pretty clean. On JVM, make sure it at least passes sanity tests and runs spectest...

[11:25] *** mstefanko joined
[11:26] <tadzik> duh. http://act.yapc.eu/ye2013/talk/4943

[11:26] <tadzik> "Perl6 is dead, long live Perl5"

[11:28] <FROGGS> hehe

[11:28] <FROGGS> tadzik: I gues he isnt that serious when looking at the tags

[11:28] <FROGGS> +s

[11:29] <tadzik> heh

[11:29] <tadzik> I'd have trouble treating that serious anyway :P

[11:30] <jnthn> It's funny, I'm fairly sure Perl 5 actually is much better resourced than Perl 6 :P

[11:30] <nwc10> I believe that it is

[11:30] <nwc10> and many people doing the ranting aren't contributing resources

[11:30] <tadzik> there are plenty of "let's jump on the perl 7 bandwagon" talks submitted

[11:31] <tadzik> I wonder how many will get through

[11:33] *** Timbus left
[11:35] *** grondilu joined
[11:35] *** Timbus joined
[11:35] <grondilu> Hello.  Not really perl6 related, but here's an article about a new language for general purpose GPU programming:  http://www.wired.com/wiredenterprise/2013/07/gpu-programming-language/

[11:36] <tadzik> TIL: I've been always using "duh" wrong.

[11:36] <nwc10> does anyone who wants to *talk* about Perl "7" have any ability to code?

[11:37] <nwc10> er, to *deliver* code

[11:37] <lizmat> actually, I don't think so

[11:39] <jnthn> Or, difficulter, to deliver language design?

[11:39] <nwc10> or difficultest, to deliver language redesign

[11:39] <nwc10> everyone forgets that there is already a design.

[11:39] <jnthn> *nod*

[11:40] <lizmat> language design?  What?  you need to design? a language?  that just develops itself, no?  like php, right?

[11:40] <nwc10> and the more of that design you think you can throw away, the more you throw away of the ecosystem you were actually relying on

[11:41] <lizmat> thought of the day: is there a difference between Mu and Nil ?

[11:41] <nwc10> I will be surprised if there is anyone *talking* who has actually run `git clone git://perl5.git.perl.org/perl.git`

[11:41] <nwc10> let alone tweaked anything

[11:41] <lizmat> nwc10: you're going to be at YAPC::EU ?

[11:42] <jnthn> FROGGS: Um, well rshift_pos_amount.t seems to give a stack overflow error

[11:42] <nwc10> ACT thinks that I am

[11:42] <jnthn> (on JVM)

[11:42] <lizmat> cool!

[11:42] <lizmat> do you?

[11:42] <FROGGS> jnthn: uhh

[11:43] <FROGGS> I'll build jakudo later and do some testing

[11:46] <masak> lizmat: there's definitely a difference between Mu and Nil. even considering that Nil has meant a number of things lately.

[11:47] <dalek> specs: a120d5a | (Elizabeth Mattijsen)++ | S99-glossary.pod:

[11:47] <dalek> specs: Add parakudo|jakudo

[11:47] <dalek> specs: review: https://github.com/perl6/specs/commit/a120d5a7af

[11:47] <hoelzro> hehe

[11:47] <lizmat> masak: I came to the thought of asking it, as TimToady seemed to play with the idea to place Nil outside of Any

[11:47] <hoelzro> can Rakudo on MoarVM be called Mokudo?

[11:47] <hoelzro> mo' kudo, mo' problems.

[11:47] <tadzik> Marudo

[11:48] <tadzik> .tr pl en marudo

[11:48] <yoleaux> pl in marudo (eo → en)

[11:48] <tadzik> que?

[11:48] <lizmat> hoelzro/tadzik: we'll see which vernacular will stick

[11:48] <nwc10> lizmat: I've paid for it and bought a plane ticket. I think it's likely

[11:48] <hoelzro> Mokudo!

[11:48] <lizmat> and if Nil is outside of any, what makes it different from Mu then?

[11:49] <lizmat> if we understand the difference, we know that we need two terms

[11:49] <lizmat> if we don't, why don't we stick with Mu then?

[11:49] <lizmat> playing advocate of the devil here, yes

[11:49] <masak> "Mu" is just a really wonky name for "Object". it's a blank slate, representing something entirely without features.

[11:50] <masak> "Nil" has more information than that.

[11:50] <masak> it means "you looked for something, but it is not here".

[11:50] *** ecocode` joined
[11:50] <masak> it's a built-in sentinel.

[11:50] *** ecocode left
[11:51] <lizmat> not seeing much of a difference yet, I mean Nil is also a blank slate, something without features

[11:51] <lizmat> even so, that if you assign it to something, it reverts back to its original state

[11:51] <JimmyZ> what? not pakudo?

[11:52] <JimmyZ> so rakudo is akudo on Ruby?

[11:52] <lizmat> lakudo, rakudo on Lua

[11:52] <lizmat> back in 15min&

[11:53] <FROGGS> damnit! I wanna use Perl6 now for $work, I dont wanna do if( anymore, and I dont wanna pass args like date => $date anymore  >:o[

[11:53] <JimmyZ> parakudo is not like jakudo?

[11:56] <masak> FROGGS: that's the spirit!

[11:57] <masak> FROGGS: use that frustration to further Perl 6 in various ways :)

[11:57] <FROGGS> masak: I do

[11:57] <FROGGS> like 6 hours a day

[11:58] <masak> lizmat: 'Mu' is the primordial stateless goo out of which the universe is built, the seed of being and nothingness, but not yet either of them. 'Nil' is that goo specialized into nothingness.

[11:58] <masak> 'Any' is that goo specialized into being.

[11:58] <masak> 'Junction' is that goo specialized into parallel being.

[11:59] <masak> or superposed being.

[12:13] *** grondilu left
[12:15] *** konundra joined
[12:23] <lizmat> masak++

[12:25] <masak> well, 老子++, really. :)

[12:26] <JimmyZ> :D

[12:28] <ztt> 哈哈哈哈

[12:29] <JimmyZ> Claiming 老子 means I'm arrogant

[12:30] <timotimo> "Development of Perl6 is sucking in huge amounts of community creativity, attention and effort." wait what.

[12:30] <hoelzro> timotimo: source?

[12:31] *** konundra left
[12:31] <timotimo> http://act.yapc.eu/ye2013/talk/4943

[12:32] <masak> JimmyZ: in what way? he said lots of good things.

[12:33] <masak> timotimo: I'm just so tired of that zero-sum bullshit.

[12:33] *** atroxaper joined
[12:33] *** atroxaper left
[12:33] <timotimo> yeah, i can understand it

[12:33] <timotimo> but that's even *worse*

[12:33] <JimmyZ> masak: I can't follow you ...

[12:33] <timotimo> that's blowing the work that's going into perl6 so ridiculously out of perspective

[12:34] <JimmyZ> masak: oh I know

[12:34] <timotimo> "damnit, if those two hundred perl6 hackers would just come back to perl5!", wat?

[12:34] <JimmyZ> I know what you mean

[12:35] <lizmat> otoh, I do think the Perl community as a whole, has lost a lot of good people in the past 10 years

[12:35] <JimmyZ> masak: we say the different things

[12:35] <lizmat> getting *them* back is one of *my* long term goals  :-)

[12:36] <BinGOs> "We know where you live"

[12:37] <lizmat> actually, I wish we did, only the NSA knows :-(

[12:38] <ztt> that act smells like a joke

[12:39] <lizmat> on the way to the NLPM meeting&

[12:40] <lizmat> aka Amsterdam.PM meeting

[12:40] <jnthn> Grr. I fixed two things, won a bunch of tests...but lost another load

[12:40] <jnthn> o/ lizmat 

[12:40] *** lizmat left
[12:41] *** ajr joined
[12:41] *** ajr is now known as Guest93975

[12:42] *** Guest93975 is now known as ajr_

[12:43] <timotimo> jnthn: hopefully these other tests have been injustly passing before you fixed a bug that would bring the injustice to light .... or something

[12:43] *** konundra joined
[12:44] <jnthn> timotimo: Yeah, am hunting down what's going on now :)

[12:44] <jnthn> I did manage to win us the transliteration tests. :)

[12:49] <[Coke]> I can sympathize with the p5 people that think p6 is pulling cycles away from p5. (see moarvm vs. parrot, as a smaller example of a very similar thing)

[12:49] <[Coke]> s/p5:first/perl/, maybe.

[12:51] <masak> I can sympathize, too.

[12:52] <masak> I just don't think it's true in, you know, a factual sense.

[12:52] <colomon> [Coke]: I've never understood that logic.  I mean, it's not like the p6 developers (TimToady excepted) are established p5 hackers who were lured away by something shiny.  

[12:52] <moritz> colomon: I think that was different in the beginning

[12:53] <colomon> moritz: sure, a decade ago

[12:58] *** rindolf joined
[12:58] *** jaldhar joined
[12:59] <[Coke]> colomon: I'm not saying they are right, of course.

[12:59] *** mtk left
[12:59] <[Coke]> jnthn++ # more jvm tests

[13:00] <[Coke]> jnthn, sorear: soon we'll have to fix actual failing tests instead of exploding ones.

[13:00] *** mtk joined
[13:00] <jnthn> [Coke]: Well, doing a bit of that now too

[13:01] <nwc10> [Coke]: "p5 people" - I'm not aware of much overlap between the people blowing off about Perl 6 and the people contributing code to Perl 5 (either the core, or (show me to be wrong) important things on CPAN)

[13:03] <[Coke]> not porters.

[13:04] *** woosley1 joined
[13:04] <nwc10> so people who think it's more useful to contribute by talking. But don't actually contribute in any way to the thing that they say matters to them.

[13:09] *** daniel-s_ joined
[13:10] *** PacoAir joined
[13:10] <Ulti> I think there is a mismatch in perl-land between people who are employed to program in perl, and those that just like it as a go to language for fun things as well as bits of work

[13:10] <Ulti> the people who only program in perl5 every day at work and not in the evening are the ones most bitter as far as I can see... its where all the production ready cries come from

[13:11] <Ulti> because until its the mythical production ready release they aren't even going to start learning the language or writing a single line

[13:11] <nwc10> not thought of it that way (work vs play). Interesting

[13:11] <Ulti> so basically for them its been a decade of nothing

[13:11] <nwc10> but those people *also* don't contribute to Perl 5

[13:12] <Ulti> rather than a decade of play and hopeful steady improvements

[13:12] <Ulti> nwc10: well probably not core, but they likely have that once CPAN module only they use :)

[13:12] <Ulti> *one

[13:13] <nwc10> use? or wrote?

[13:13] <Ulti> both 

[13:14] <jnthn> ah, think I found why I busted stuff :)

[13:14] <Ulti> I groan when I read the standard perlmonks perl6 troll about production readyness and waiting a decade *blah* *blah*... I'm in academia you just use whatever is a good tool for the job, I've used perl6 in "production" just to parse an especially nasty custom text format into something usable by my perl5 scripts

[13:14] <jnthn> *and* another bug :)

[13:15] *** jaldhar left
[13:17] <[Coke]> jnthn: as long as the net # of passing tests increases!

[13:17] *** jaldhar joined
[13:18] <jnthn> [Coke]: yeah, I managed to lose some, but think I've saved them again :)

[13:19] *** mtk left
[13:19] <masak> Ulti: the "work vs play" notion is brilliant. thank you. Ulti++

[13:19] <nwc10> I also see a bunch of other, um, factual inaccuracies such as grumbling that for PHP there's now Hip-Hop, which is a drop-in faster replacement. Which, well, means that the author hasn't read https://github.com/facebook/hiphop-php/blob/HEAD/hphp/doc/inconsistencies

[13:22] <jnthn> Indeed

[13:22] <jnthn> "HipHop VM currently does not support PHP namespaces."

[13:23] <jnthn> That feels like a fairly sizable missing thing...though maybe namespaces ain't used much in PHP. :)

[13:23] *** mtk joined
[13:23] <nwc10> well, they are new, and they use the most awesome character ever as the namespace separator

[13:23] <jnthn> Yeah!

[13:24] <jnthn> Nice for Windows users. ;)

[13:24] <jnthn> "oh, so it's like a directory" :)

[13:24] <tadzik> :D

[13:25] <nwc10> oh, so it's part of a meta-character in double-quoted strings

[13:28] <dalek> nqp: fa3d25f | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[13:28] <dalek> nqp: Invoke accepts_type on correct meta-object.

[13:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fa3d25fdfa

[13:30] <dalek> rakudo/nom: dceb13c | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[13:30] <dalek> rakudo/nom: Implement checking post constraints.

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dceb13cfb8

[13:30] <dalek> rakudo/nom: faa0f9e | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Ops.java:

[13:30] <dalek> rakudo/nom: Implement nqp::p6isbindable.

[13:30] <dalek> rakudo/nom: 

[13:30] <dalek> rakudo/nom: Fixes various of the remaining multi-dispatch issues, and other things

[13:30] <dalek> rakudo/nom: that relied on multi-dispatch, such as transliteration.

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/faa0f9eea0

[13:30] <dalek> rakudo/nom: 7dfcd66 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/RakudoContainerSpec.java:

[13:30] <dalek> rakudo/nom: Fix error reporting.

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7dfcd66840

[13:30] <colomon> what's the file op for creation date?

[13:32] <moritz> nqp::stat maybe?

[13:32] <colomon> in p6, I mean

[13:33] <moritz> r: say 'README'.path.created

[13:33] <camelia> rakudo 54b7dd: OUTPUT«No such method 'created' for invocant of type 'IO::Path'␤  in block  at /tmp/LLLUUTZdkF:1␤␤»

[13:33] <colomon> hmm.... changed or modified? (probably either is close enough, but what's the difference?)

[13:33] <timotimo> i think one is for data and the other is for metadata

[13:33] <moritz> one is about content, one is for meta data

[13:34] <moritz> oh, and POSIX doesn't track the 'created' date of a file

[13:34] * colomon is pretty certain these files have never been changed...

[13:34] <colomon> moritz++ timotimo++

[13:37] * colomon needs to blog on this project.  :)

[13:38] <timotimo> now i'm interested to know what it is

[13:38] <colomon> ;)

[13:39] <colomon> I'm coding up a p6 script to figure out which photo files on my hard drives are duplicates that can be safely deleted

[13:39] <timotimo> ah

[13:39] <timotimo> while that's not useful to me in particular, that does sound nice :)

[13:39] <colomon> it's got lots of fun bits, like sort(*.changed)

[13:40] <colomon> to get the oldest file first

[13:40] <tadzik> colomon: install fdupes :)

[13:40] <tadzik> or fdups

[13:40] <tadzik> I did the same thing a while ao

[13:42] <colomon> and categorize(*.basename) to find which files have the same filename but different paths

[13:43] <masak> why 'categorize' and not (the simpler) 'classify'?

[13:43] <masak> I'm asking because I don't think I see the point of 'categorize' yet. I've never used it, only 'classify'.

[13:43] <colomon> .... good point, I think

[13:44] <colomon> think-o

[13:44] <masak> yes. S32/Containers seems to suggest 'classify' is what to use here.

[13:44] <colomon> funny, in that I did use classify a couple of lines later...

[13:44] <colomon> classify({ MD5($_) }

[13:44] <masak> :)

[13:45] <colomon> I had a great use for categorize a few days ago, let me see if I can dig it up

[13:47] <timotimo> colomon: wouldn't classify: *.&MD5 also work?

[13:47] <colomon> timotimo: calling a sub as a method?

[13:47] <masak> classify: &MD5

[13:47] <timotimo> oh, even better still

[13:48] <masak> yes, it's the only one that removes a level of invocation.

[13:48] <colomon> masak++

[13:48] <timotimo> r: sub do-something($a) { say "someone think of the $a!" }; "children".&do-something

[13:48] <camelia> rakudo 54b7dd: OUTPUT«someone think of the children!␤»

[13:48] <colomon> I used categorize to invert a hash

[13:49] <colomon> I'm now trying to figure out if invert would have worked as well.  It seems like it's not quite the same thing?

[13:49] <timotimo> well, invert gives you a list of pairs, if you push that into an empty hash, you'll get a hash with once-values-now-keys and list of once-keys-now-values

[13:53] <colomon> actually, it was a bit more than inverting the hash.  but it's an interesting fine line.  

[13:53] <colomon> most ponder

[13:56] <colomon> *must

[13:57] *** daniel-s_ left
[13:58] <masak> sounds interesting. please share if the pondering yields something. :)

[13:59] *** daniel-s- joined
[14:05] *** FROGGS left
[14:06] *** lizmat joined
[14:06] *** kaleem left
[14:09] *** daniel-s- left
[14:10] *** notjack joined
[14:12] * lizmat is in the car, on the way to Amsterdam

[14:12] <lizmat> and not driving

[14:12] <masak> :)

[14:20] *** ztt left
[14:21] *** xilo joined
[14:24] <jnthn> grr...working out this given.t fail is a bit tricky

[14:26] *** FROGGS[mobile] joined
[14:33] *** skids left
[14:41] *** ecocode` left
[14:42] <dalek> specs: c4f1fe8 | (Elizabeth Mattijsen)++ | S11-modules.pod:

[14:42] <dalek> specs: Some preliminary work on CompUnitRepo's interface

[14:42] <dalek> specs: review: https://github.com/perl6/specs/commit/c4f1fe8493

[14:43] *** lizmat left
[14:44] <jnthn> aha....

[14:46] <jnthn> yay. given.t passes in full now.

[14:46] <masak> yay

[14:46] <timotimo> hooray!

[14:47] <jnthn> Gets us another 45.

[14:48] <notjack> perl6: my $t = 'pass'; given $t {when 'pass' {say 'yay'} when 'fail' {say 'boo'}}

[14:48] <camelia> rakudo 7dfcd6: OUTPUT«===SORRY!===␤Confused␤at /tmp/s2B0BGUsuv:1␤------> ass'; given $t {when 'pass' {say 'yay'} ⏏when 'fail' {say 'boo'}}␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modifi…

[14:48] <camelia> ..niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/Sb0zHQGy15 line 1:␤------> pass'; given $t {when 'pass' {say 'yay'}⏏ when 'fail' {say 'boo'}}␤␤Parse failed␤␤»

[14:48] <timotimo> semicolon

[14:48] <timotimo> .o(rakudo could totally steal that error message, no?

[14:48] <timotimo> )

[14:48] <timotimo> maybe i'll look into that later today

[14:49] <jnthn> I thought I tried that once and ran into something, but I totally forget what. Maybe it was nothing big.

[14:50] <notjack> confused at 'ass'

[14:50] <notjack> I've been there, camelia.

[14:50] <jnthn> ;)

[14:52] *** raiph joined
[14:52] * timotimo runs away scared instead

[14:53] <jnthn> timotimo: nah, give it a try!

[14:55] <dalek> nqp: 800df5e | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[14:55] <dalek> nqp: Be sure to keep tc.curFrame in sync.

[14:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/800df5e0ee

[14:55] * TimToady always wonders whether LuaJIT can possibly have the type finesse to handle Perl 6 when the type system of Lua is so impoverished^Wsimple

[14:55] <yoleaux> 10:46Z <lizmat> TimToady: if we're going to put Nil outside of Any, things like this will break, as they now break with Mu: my $a; say $a === Mu

[14:55] <hoelzro> hmm

[14:56] <hoelzro> I've thought about a Lua backend for NQP; I wonder how much work that would take?

[14:56] <hoelzro> bonus: really easy-to-write C extensions =)

[14:56] <jnthn> hoelzro: The answer, whether or not you s/Lua//, is "lots" :)

[14:56] <TimToady> tell lizmat If we put Nil outside of Any, we probably need a .is-nill primitive, or some way of training people to use =:= when they try to use ===

[14:56] <TimToady> .tell lizmat If we put Nil outside of Any, we probably need a .is-nill primitive, or some way of training people to use =:= when they try to use ===

[14:56] <yoleaux> TimToady: I'll pass your message to lizmat.

[14:57] *** Chillance joined
[14:57] <hoelzro> heh

[14:57] <TimToady> much like we currently do with smartmatching

[14:57] <TimToady> std: 42 when Nil

[14:57] <camelia> std d4cc5ab: OUTPUT«Potential difficulties:␤  Smartmatch against Nil always fails; perhaps you should use * === Nil or :!defined instead at /tmp/ZaNr1otX5x line 1:␤------> 42 when ⏏Nil␤ok 00:00 42m␤»

[14:57] <jnthn> oh...the loop code-gen doesn't know how to handle arity 1 loop blocks...

[14:58] <TimToady> of course, now that message is wrong, unless we fix === Nil  :)

[14:59] <TimToady> as I mentioned yesterday, we can do something similar to junctions to force === to work on Nil, though perhaps aliasing to none() is overkill

[15:00] * TimToady is actually a bit surprised that =:= Nil works, which probably means he is thinking of =:= wrongishly...

[15:00] *** snoopy left
[15:00] <jnthn> Or implementations are thinking of =:= wrongishly... ;)

[15:01] <jnthn> I think it means at the momnet something like "are the things on each side at the same memory address" 

[15:01] * TimToady doesn't think of those things as containers, but it's really just a more primitive container notion

[15:01] <TimToady> and thus perhaps the right thing here

[15:03] <TimToady> nr: constant Mu2 = Mu; say Mu2 =:= Mu

[15:03] <camelia> rakudo 7dfcd6, niecza v24-86-g39ab531: OUTPUT«True␤»

[15:03] <TimToady> \o/

[15:07] * TimToady notest that the only instance of '=== Nil' in either niecza or rakudo are actually down in roast

[15:07] <TimToady> *instances

[15:07] <TimToady> all in the pick and roll tests

[15:12] <raiph> does anyone know if any gather/take implementation does batching yet?

[15:13] <raiph> is sorear's work on continuations relevant to laziness being useful/performant?

[15:13] <dalek> nqp: 98a7d2e | jnthn++ | src/vm/jvm/QAST/Compiler.nqp:

[15:13] <dalek> nqp: Handle arity-1 loop constructs.

[15:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/98a7d2eebc

[15:13] <raiph> (for gather/take)

[15:14] <jnthn> The continuation work on JVM was done for gather/take.

[15:14] <jnthn> (Without that, we wouldn't have been able to support it at all on JVM.)

[15:16] <raiph> jnthn: thanks

[15:16] <raiph> jnthn: does the rakudo gather/take do batching?

[15:17] *** rindolf left
[15:17] *** woosley1 left
[15:18] <raiph> jnthn: is/was batching a tricky thing to implement?

[15:18] <TimToady> raiph: it's unlikely to do that before we figure out how to optimize some gather/takes to use interthread queues

[15:18] <TimToady> but once there's a queue, there's a natural buffer for batching

[15:19] <TimToady> it might be worth batching some in the continuation model as well, if there's a place to put the results, and if taking a continuation is expensive

[15:19] <jnthn> raiph: I believe it doesn't do batching.

[15:19] <jnthn> I think it'll be a worthwhile optimization.

[15:19] <TimToady> and if we can detect where strict laziness isn't required

[15:20] <jnthn> Yeah.

[15:20] <jnthn> I think pmichaud++, when he gets tuits for it, is planning on some work on letting us know such things.

[15:20] <jnthn> Or at least, know more... :)

[15:20] <TimToady> recursive constant definitions will tend to want strict laziness, for instance, but maybe this falls out of recognizing we're asking for something that hasn't been computed yet

[15:21] *** domidumont left
[15:21] <dalek> nqp: 65a2aef | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/runtime/Ops.java:

[15:21] <dalek> nqp: nqp::decont shouldn't explode on nulls.

[15:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/65a2aefd4e

[15:23] * TimToady would still like to be able to define Hamming numbers recursively:

[15:23] <TimToady> constant @hamming = 1, dedup (@hamming X* 2) M (@hamming X* 3) M (@hamming X* 5);

[15:24] <TimToady> I guess that'd be s/dedup/squish/ these days, now that it's a builtin

[15:24] *** raiph left
[15:24] <TimToady> (and assuming M is defined somehow to be a lazy n-way merge)

[15:31] <TimToady> nr: say squish 1,2,2,3

[15:31] *** raiph joined
[15:31] <camelia> niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'squish' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1502 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 36) ␤  at /h…

[15:31] <camelia> ..rakudo 7dfcd6: OUTPUT«===SORRY!===␤Undeclared routine:␤    squish used at line 1␤␤»

[15:31] <TimToady> NYI I guess

[15:32] <TimToady> is LHF though

[15:33] <timotimo> the sun is so lovely out, but even with a light terminal and full backlight i can hardly use my editor or irc client :|

[15:33] <timotimo> also the keyboard gets pretty darn hot

[15:34] <TimToady> you need to find a cave

[15:34] <timotimo> just 5 meters to my right is a hackspace ;)

[15:34] <timotimo> but it's warm in there. it's direltcy under a roof and the roof isn't insulated properly

[15:35] <TimToady> that's what IR clogs are for

[15:36] <TimToady> maybe it would help to turn the hackspace over so that the floor is radiating instead of the ceiling...

[15:37] <timotimo> hehe

[15:37] <lee_> does this look like a useful optimization for [+] 1..10000? https://gist.github.com/leedo/735a5f09350bd2d50d33

[15:38] <lee_> it seems to cut the time down quite a bit

[15:38] <timotimo> screed heating? :)

[15:40] <timotimo> http://imgur.com/a/BLsoE <- my spot right now

[15:40] <timotimo> lee_: watch out, that may blow up if someone defines their own infix:<+>

[15:41] <timotimo> at least i always had to make sure that didn't happen when i worked with the optimizer

[15:41] <timotimo> oh, i'm talking crap, since it's lexical, you'll always compare with the "correct" infix:<+>

[15:42] *** crab2313 joined
[15:43] <lee_> i wasn't sure what the best way to test that min and max are both Ints

[15:44] <colomon> I'd say $values.min ~~ Int && $values.max ~~ Int

[15:50] *** crab2313 left
[15:57] *** FROGGS joined
[15:59] * colomon just erased 24 gigs worth of duplicated photos

[15:59] *** domidumont joined
[16:00] <FROGGS> ohh, I read "duplicated p*rnos" for a moment

[16:00] *** PacoAir left
[16:00] <TimToady> lee_: there's something a little wrong with it in regards to flattening, since a range in list context flattens, but you're kinda bypassing the flattening, such that [+] $range would "flatten" $range when it shouldn't, seems to me

[16:01] <jnthn> Pro tip: an epoch in milliseconds is quite different from an epoc in seconds.

[16:01] <TimToady> epochs shouldn't be integers at all, in P6-think...

[16:02] * TimToady realizes that this is a minority view in the world today :)

[16:02] <jnthn> Well, we gotta get what we want in terms of what platforms think ;)

[16:02] <TimToady> that's part of the world I was referrin' to

[16:02] <pmurias> jnthn: the way I'm solving the lack of BEGIN to generate a convenient example of a serialized closure is it insert vim folds into generated code so that I can view more complex stuff

[16:04] <jnthn> bah, all that and the test that wants $*TZ explodes 'cus we don't have sprintf that works yet...

[16:04] <dalek> rakudo/nom: 284a76f | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Ops.java:

[16:04] <dalek> rakudo/nom: Implement nqp::p6decodelocaltime.

[16:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/284a76f0a8

[16:04] <dalek> rakudo/nom: 5b1775f | jnthn++ | src/core/Temporal.pm:

[16:04] <dalek> rakudo/nom: Enable $*TZ on JVM.

[16:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b1775fa05

[16:05] <TimToady> lee_: also, I'm not sure the form you have it would be amenable to constant folding--you'd like [+] 1..10000 to fold at compile time

[16:05] *** konundra left
[16:06] <TimToady> nr: my $range = 1..10000; say [+] $range

[16:06] <camelia> niecza v24-86-g39ab531: OUTPUT«1..10000␤»

[16:06] <camelia> ..rakudo 7dfcd6: OUTPUT«10000␤»

[16:06] <TimToady> rakudo++

[16:06] <TimToady> nr: my $range = 1..10000; say [+] @$range

[16:06] <camelia> rakudo 7dfcd6, niecza v24-86-g39ab531: OUTPUT«50005000␤»

[16:07] <TimToady> lee_: I don't think your optimization distinguishes those as it ought

[16:07] <lee_> hmm yeah, i see your point

[16:08] <TimToady> probably need something slightly more ASTy

[16:10] *** kaleem joined
[16:10] <TimToady> nr: sub foo (*@args) { say +@args }; sub bar (**@args) { say +@args }; foo 1..100, 1..100; bar 1..100, 1..100

[16:10] <camelia> niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Slice parameters NYI at /tmp/5rPlwdIOLf line 1:␤------> *@args) { say +@args }; sub bar (**@args⏏) { say +@args }; foo 1..100, 1..100; ba␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/l…

[16:10] <camelia> ..rakudo 7dfcd6: OUTPUT«200␤2␤»

[16:12] <TimToady> r: sub bar (**@args) { say @args[0].WHAT }; bar 1..100

[16:12] <camelia> rakudo 7dfcd6: OUTPUT«(Range)␤»

[16:12] <TimToady> r: sub bar (**@args) { say @args[0].WHAT }; my $range = 1..100; bar $range

[16:12] <camelia> rakudo 7dfcd6: OUTPUT«(Range)␤»

[16:12] <TimToady> rakudobug

[16:13] <TimToady> (I suspect)

[16:13] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my $range = 1..100; bar $range

[16:13] <camelia> rakudo 7dfcd6: OUTPUT«(Range)␤»

[16:13] * lee_ looks up *@args vs **args, i'm new!

[16:13] *** kaleem_ joined
[16:13] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my $range = 1..100; bar |$range

[16:14] <camelia> rakudo 5b1775: OUTPUT«(Int)␤»

[16:14] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my $range = 1..100; bar @$range

[16:14] <camelia> rakudo 5b1775: OUTPUT«(List)␤»

[16:14] <jnthn> timotimo: Just did the Makefile re-ordering we discussed last night. :)

[16:14] <jnthn> timotimo: Gets rid of some errors :)

[16:15] <[Coke]> jnthn: almost time for the daily run. should I wait 10m?

[16:15] <jnthn> [Coke]: Yes ;)

[16:15] <jnthn> Will push in a moment

[16:15] <jnthn> (within 10)

[16:15] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my @range := 1..100; bar @range

[16:15] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:15] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my $range := 1..100; bar $range

[16:15] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:15] *** Stygia left
[16:16] <TimToady> so where's the $ vs @ difference?

[16:16] *** kaleem left
[16:17] <TimToady> such that one could emulate normal slurpy by examining |args?

[16:17] <jnthn> .oO( in the mind of whoever wants binding not to be a low level operation... :S )

[16:17] *** jlaire left
[16:17] <TimToady> n: sub bar (|args) { say args[0].WHAT }; my @range := 1..100; bar @range

[16:17] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Builtins.InvokeSub (Niecza.P6any obj, Niecza.Variable[] pos) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.ToComposable (Niecza.STable arg…

[16:18] <jnthn> r: say Range ~~ Positional

[16:18] <camelia> rakudo 5b1775: OUTPUT«True␤»

[16:18] <TimToady> |args should be very raw

[16:18] <jnthn> That's why it's allowed to be bound directly to :=

[16:18] <jnthn> It is. And @a and $a are just names of storage locations.

[16:19] *** SamuraiJack_ left
[16:19] <TimToady> and how does normal binding distinguish $ from @ then?

[16:19] <jnthn> As in, why is it an error to do:

[16:19] <jnthn> r: my @a := 'foo'

[16:19] <camelia> rakudo 5b1775: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Str'␤  in block  at /tmp/O4nHjGxa_F:1␤␤»

[16:19] <jnthn> ?

[16:20] <TimToady> as in, how does *@args know to flatten @ but not $

[16:20] * jnthn *thought* it was a combination of type and "not in a scalar container"

[16:21] * jnthn has no idea how much Pm expects the current details to change in this regard...

[16:22] <TimToady> n: sub bar (|args) { say args[0].WHAT }; my $range = 1..100; bar $range

[16:22] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Builtins.InvokeSub (Niecza.P6any obj, Niecza.Variable[] pos) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.ToComposable (Niecza.STable arg…

[16:22] <TimToady> r: sub bar (|args) { say args[0].WHAT }; my $range = 1..100; bar $range

[16:22] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:22] <TimToady> no scalar container there...

[16:22] <jnthn> Um, they're invisible, though, no?

[16:22] <jnthn> r: my $x = 1..100; say $x.WHAT

[16:22] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:22] *** jlaire joined
[16:22] <jnthn> r: my $x := 1..100; say $x.WHAT

[16:22] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:22] <FROGGS> ohh, Stage parse      :  59,851 for jakudo... I should have tried it earlier :o)

[16:23] <dalek> rakudo/nom: f2b0f89 | jnthn++ | tools/build/Makefile-JVM.in:

[16:23] <dalek> rakudo/nom: Sync CORE.setting ordering with Parrot Makefile.

[16:23] <dalek> rakudo/nom: 

[16:23] <dalek> rakudo/nom: No reason for them to be different. timotimo++ for noticing.

[16:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2b0f89803

[16:23] <jnthn> FROGGS: How much is it for you on Parrot? :)

[16:23] <jnthn> [Coke]: Fire!

[16:23] <TimToady> r: my $x = 1..100; my @a = $x; say +@a

[16:23] <camelia> rakudo 5b1775: OUTPUT«1␤»

[16:23] <TimToady> r: my $x = 1..100; my $a = $x; say +$a

[16:23] <camelia> rakudo 5b1775: OUTPUT«100␤»

[16:24] <FROGGS> jnthn: 130s

[16:24] <jnthn> FROGGS: Hm, difference is a bit more pronounced than that for me.

[16:24] <FROGGS> damn it, I forgot to buy beer :/

[16:25] <jnthn> :(

[16:25] <TimToady> r: sub bar (|args) { say VAR(args[0]).WHAT }; my $range = 1..100; bar $range

[16:25] <camelia> rakudo 5b1775: OUTPUT«===SORRY!===␤Undeclared name:␤    VAR used at line 1␤␤»

[16:25] <jnthn> .VAR works

[16:25] <TimToady> r: sub bar (|args) { say args[0].VAR.WHAT }; my $range = 1..100; bar $range

[16:25] <camelia> rakudo 5b1775: OUTPUT«(Scalar)␤»

[16:25] <TimToady> there we go

[16:25] <TimToady> r: sub bar (|args) { say args[0].VAR.WHAT }; my @range := 1..100; bar @range

[16:25] <jnthn> ah, that's what you were after...

[16:26] <camelia> rakudo 5b1775: OUTPUT«(Range)␤»

[16:26] *** arnsholt joined
[16:26] <TimToady> what lee_++ would need to emulate flattening to do the optimization correctly by that method

[16:26] <arnsholt> o/

[16:27] <jnthn> o/ arnsholt 

[16:27] <TimToady> r: sub bar (|args) { say args[0].VAR }; my @range := 1..100; bar @range

[16:27] <camelia> rakudo 5b1775: OUTPUT«1..100␤»

[16:28] <arnsholt> jnthn: From a cursory look at JNA, it looks like it passes pointers around in Java longs, so I think I'll try to mirror the Parrot approach to NativeCall on JVM as a first whack

[16:28] <TimToady> r: sub bar (|args) { say args[0].VAR }; my $range = 1..100; bar $range

[16:28] <camelia> rakudo 5b1775: OUTPUT«1..100␤»

[16:28] <TimToady> I guess .gist loses the distinction

[16:28] *** fgomez joined
[16:28] *** pmurias left
[16:29] <TimToady> r: sub bar (|args) { say args[0].VAR.Str }; my $range = 1..100; bar $range

[16:29] <camelia> rakudo 5b1775: OUTPUT«Range<-109147205>␤»

[16:29] <TimToady> heh

[16:29] <jnthn> arnsholt: ok

[16:30] <jnthn> arnsholt: Good luck! :)

[16:30] <arnsholt> Thanks =)

[16:31] <TimToady> r: sub bar (|args) { my $which = say args[0].VAR; say $which.WHAT }; my $range = 1..100; bar $range

[16:31] <arnsholt> Passing pointers around in integers is kind of horrible, but I think it'll work

[16:31] <camelia> rakudo 5b1775: OUTPUT«1..100␤(Bool)␤»

[16:31] <FROGGS> I think I'm trying j5 today...

[16:31] <jnthn> arnsholt: It's only cheating if you get caught ;)

[16:31] <TimToady> r: sub bar (|args) { my \which = say args[0].VAR; say which.WHAT }; my $range = 1..100; bar $range

[16:31] <camelia> rakudo 5b1775: OUTPUT«1..100␤(Bool)␤»

[16:31] <TimToady> jnthn: why Bool?

[16:32] <TimToady> duh

[16:32] <moritz> say

[16:32] <TimToady> r: sub bar (|args) { my \which = args[0].VAR; say which.WHAT }; my $range = 1..100; bar $range

[16:32] <camelia> rakudo 5b1775: OUTPUT«(Scalar)␤»

[16:32] <arnsholt> jnthn: I'll hide it as well as I can, in that case =D

[16:32] <djanatyn> is there something equivalent to template::toolkit or jinja2 or mustache for perl6

[16:32] <moritz> maybe we should spec say() return "you are looking at the return value from &say"

[16:33] <[Coke]> jnthn: fired.

[16:33] <TimToady> well, that would work as a True value, but not as a False value :)

[16:33] *** kaleem joined
[16:34] *** kaleem_ left
[16:34] <TimToady> "you are looking at the return value from &say" but False, obviously...  :)

[16:34] <jnthn> [Coke]: yay. Hopefully we make the 90% :)

[16:34] <jnthn> Especially since I seem to have spent the day patching Rakudo rather than doing $dayjob :)

[16:35] <[Coke]> jnthn: oh, that's a given. unless you screwed something up!

[16:35] <jnthn> Yes, there is that potential ;)

[16:39] <TimToady> .tell lizmat A STD.pm6 commit message of "Same change as in rakudo" is not very informative when I do 'git log' :P

[16:39] <yoleaux> TimToady: I'll pass your message to lizmat.

[16:40] <dalek> std: 102c740 | larry++ | STD.pm6:

[16:40] <dalek> std: Recommend =:= Nil rather than ===

[16:40] <dalek> std: review: https://github.com/perl6/std/commit/102c7406f4

[16:42] <sorear> good * #perl6

[16:42] <jnthn> o/ sorear 

[16:44] <pmichaud> yes, when I get tuits I want to review the whole list model, especially in light of what I learned from preparing the parallelism talk

[16:44] <pmichaud> so can clean up Nil and stuff then as needed.

[16:44] <sorear> o/ pmichaud 

[16:45] <pmichaud> sorear: btw, your CLA arrived.

[16:45] <colomon> \o

[16:45] <colomon> \o/

[16:45] <sorear> pmichaud: \o/ \o/

[16:45] <colomon> he's official!

[16:45] <TimToady> now he just needs to learn to be officious like me :)

[16:46] <sorear> .oO( any idea how many cities it went through 'cus USPS can't read my atrocious handwriting? )

[16:46] <sorear> TimToady: :p

[16:48] *** PacoAir joined
[16:49] <pmichaud> sorear: no, don't know that, sorry.  :)

[16:50] <sorear> did it at least get recorded under the correct name?

[16:50] <pmichaud> looking

[16:51] *** mstefanko left
[16:51] <TimToady> and that would be Murgatroyd McGillacudy?

[16:53] *** kaleem left
[16:53] <pmichaud> sorear: I think it's recorded under the correct name, since I just now recorded it :)

[16:54] *** Lorn_ is now known as Lorn

[16:54] *** Lorn left
[16:54] *** Lorn joined
[16:55] <TimToady> been thinking about the list context thing, and if we're not to pass context down to listops saying how eager we are, then the listop has to return an uncommitted list back up, and have lazy/eager/hyper/race select the algorithm lazily after the return somehow

[16:55] *** dakkar left
[16:55] <TimToady> lazy and eager can just be signaled by how you pull args off the list, but hyper and race have to have some other means of telling the algorithm to behave differently

[16:56] *** mstefanko joined
[16:56] <TimToady> and it would be nice if sink could do that too, rather than just being eager and throwing stuff away

[16:58] <TimToady> it would also be nice if the mechanism we choose is sufficiently amenable to static analysis that we can pass context down the calls at compile time where the decision doesn't have to be deferred to run time

[16:58] <pmichaud> I think the iterators can signal hyperness downward, though.

[16:58] <pmichaud> at least, that's the model I've been playing with a bit

[16:58] <pmichaud> (mentally)

[16:59] <TimToady> what I'm saying is that the compile-time aspects of context could be considered an optimization, and the general solution does not have to involve having passing the context to each thing that might return a list, but merely to the interator object that is returned, as you say

[17:00] <pmichaud> right

[17:00] <moritz> so that means we're getting rid of inward-propagated sink context?

[17:00] <TimToady> by that view, thinking of special calls that pass context downward can  be viewed as a premature optimization

[17:01] <pmichaud> I'm thinking inward-propagated sink is just a form of hyper/race

[17:01] <TimToady> moritz: it means we could

[17:01] <TimToady> I'm saying it only has to propagate into the iterator, not into the map/grep/whatever

[17:01] <pmichaud> well, map/grep/whatever *is* an iterator at the underlying level.

[17:01] <pmichaud> it's just an iterator wrapped inside of a List

[17:02] <pmichaud> anyway, I've been thinking that I have the List/ListIter boundary slightly off in Rakudo

[17:02] <TimToady> otoh, it might mean that map/grep/whatever have to provide different algorithms that this "inversion of control" could select

[17:02] <pmichaud> and that fixing that will clean up a lot of the hyper/sink/eager/other stuff.

[17:04] <pmichaud> anyway, I don't know when tuits will arrive again.  

[17:04] <pmichaud> all of our predictions about my tuit availability have been way off thus far.

[17:05] <TimToady> or we need to find the primitives that we can implement map in a context-ignorant way and have it Just Work as a hyper map or race map

[17:05] <pmichaud> TimToady: that's what I've been thinking will work.

[17:05] <pmichaud> well, not exactly.

[17:05] <pmichaud> MapIter becomes hyper and race aware, at any rate.

[17:05] <pmichaud> indeed, all of the *Iters do

[17:05] <TimToady> and where the language accidentally enforces ordering, we need to address that

[17:05] <pmichaud> (there aren't that many... ListIter, MapIter, GatherIter, Range)

[17:06] <timotimo> jnthn: i tried to do the reordering of the makefile myself and couldn't get it to compile properly :(

[17:06] <jnthn> timotimo: oh...weird.

[17:06] <jnthn> timotimo: Well, it's done now

[17:07] <timotimo> but if you were successful, i'm glad :)

[17:07] <jnthn> And helped :)

[17:07] <jnthn> yeah, IO spec tests are in better shape now

[17:07] <TimToady> (which, btw, probably means I'm gonna stick to my guns on the non-eagerness of for loops)

[17:07] <TimToady> but we'll see

[17:07] *** ajr_ left
[17:07] <jnthn> uh, IO::Spec spectests, that is :)

[17:08] <TimToady> does anyone foresee a difficulty with changing all the === Nil spectests to =:= Nil?

[17:08] * moritz 

[17:09] <moritz> =:= is meant to test containers, not identity

[17:09] <moritz> r: my $x = Nil; say $x =:= Nil;

[17:09] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:09] <TimToady> that's supposed to put Any into $x

[17:10] <TimToady> r: my $x := Nil; say $x =:= Nil

[17:10] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:11] <TimToady> so it turns out that =:= is using a more primitive notion of "container" than somoe of us have been thinking, but that seems fine

[17:12] *** konundra joined
[17:12] <TimToady> r: my $x := Mu; say $x =:= Mu

[17:12] <pmichaud> I'm afk again

[17:12] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:12] <TimToady> r: my $x = Mu; say $x =:= Mu

[17:12] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:12] <TimToady> hmm

[17:13] <TimToady> r: my $x = Mu; say |$x =:= Mu

[17:13] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (lines 1, 1)␤»

[17:13] *** birdwindupbird left
[17:13] <TimToady> how to deref a $x containing Mu (or Nil)...

[17:13] <masak> r: my $x = Mu; say $x.WHICH; say Mu.WHICH

[17:13] <camelia> rakudo f2b0f8: OUTPUT«Mu␤Mu␤»

[17:13] <masak> hm.

[17:13] <TimToady> r: my \x = Mu; say x =:= Mu

[17:13] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:14] <TimToady> I guess don't put it into $x in the first place

[17:14] <TimToady> r: my $x = Mu; my \x = $x; say x =:= Mu

[17:14] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:15] <TimToady> hard to strip off that (Scalar) object...

[17:15] <TimToady> r: my $x = Mu; my \x = |$x; say x =:= Mu

[17:15] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (line 1)␤»

[17:15] <TimToady> we seem to be missing a primitive

[17:16] <moritz> r: my $x = Mu; say nqp::decont($x) =:= Mu

[17:16] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:16] <moritz> r: say Mu =:= Any

[17:16] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:17] <TimToady> maybe we should expose decont?

[17:17] *** raiph left
[17:17] <moritz> what's the use case?

[17:18] <moritz> (besides using =:= for stuf it wasn't intended to do)

[17:18] *** fhelmberger left
[17:18] <TimToady> looking at a user-supplied value in $foo to see if it's Nil?

[17:18] <TimToady> well, =:= was intended to compare two pointers, really, and that's still what it's doing

[17:19] <TimToady> we just don't have a language-level way to name the pointer in $x yet

[17:19] *** raiph joined
[17:22] *** xilo left
[17:23] <TimToady> otoh, there might be a way of getting === to work even if Nil is outside of Any, if Nil is just a pseudo-junction of some sort

[17:23] *** spider-mario joined
[17:24] <TimToady> or more generally, if the failover to Junction can be generalized to other conceptual types outside of Any

[17:25] <diakopter> "Ranges from S02 and S03 which are nearly frozen"

[17:25] <diakopter> labster: ...

[17:25] <TimToady> diakopter!!  \o/

[17:26] <colomon> \o/

[17:27] <diakopter> .seen diakopter

[17:27] <yoleaux> You're right there.

[17:29] *** xilo_ left
[17:30] <masak> .seen yoleaux

[17:30] <yoleaux> I'm right here.

[17:30] <masak> wherever you go, there you are.

[17:30] <masak> [Coke]: by the way, thank you for the tip about Buckaroo Banzai ;)

[17:32] *** rindolf joined
[17:35] *** ajr joined
[17:35] *** ajr is now known as Guest50674

[17:36] *** Guest50674 is now known as ajr_

[17:37] *** daxim left
[17:41] *** xilo joined
[17:43] <notjack> perl6: sub f(*%args) { say %args;} f(1,2,'three', four=>'five');

[17:43] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/PuSqco7PSV:1␤------> sub f(*%args) { say %args;} ⏏f(1,2,'three', four=>'five');␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement mod…

[17:43] <camelia> ..niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/fzhjxMEy4R line 1:␤------> sub f(*%args) { say %args;}⏏ f(1,2,'three', four=>'five');␤␤Parse failed␤␤»

[17:43] <TimToady> masak: we used to live a couple miles away from that dam they use in the end credits :)

[17:44] <masak> ooh

[17:44] * masak .oO( we used to live dam close )

[17:44] <TimToady> one of those dams that gets water behind it every twenty years or so, but in so doing prevents downtown LA from washing away, which could be construed as either good or bad

[17:45] <masak> :)

[17:48] <TimToady> r: sub decont($var) { $var }; my $x = Mu; say decont($x) =:= Mu

[17:48] <camelia> rakudo f2b0f8: OUTPUT«Nominal type check failed for parameter '$var'; expected Any but got Mu instead␤  in sub decont at /tmp/kHY49emIC3:1␤  in block  at /tmp/kHY49emIC3:1␤␤»

[17:48] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say decont($x) =:= Mu

[17:48] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:49] <TimToady> r: sub decont(\var) { var }; my $x = Mu; say decont($x) =:= Mu

[17:49] <camelia> rakudo f2b0f8: OUTPUT«Nominal type check failed for parameter 'var'; expected Any but got Mu instead␤  in sub decont at /tmp/FCAYkOSda8:1␤  in block  at /tmp/FCAYkOSda8:1␤␤»

[17:49] <TimToady> r: sub decont(Mu \var) { var }; my $x = Mu; say decont($x) =:= Mu

[17:49] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:49] <TimToady> rats

[17:50] <TimToady> r: sub decont(Mu \var) { var }; my $x = Mu; say decont($x).WHAT

[17:50] <camelia> rakudo f2b0f8: OUTPUT«(Mu)␤»

[17:51] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say decont($x).WHAT

[17:51] <camelia> rakudo f2b0f8: OUTPUT«(Mu)␤»

[17:55] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say $x.WHICH; say decont($x).WHICH; say Mu.WHICH

[17:55] <camelia> rakudo f2b0f8: OUTPUT«Mu␤Mu␤Mu␤»

[17:55] *** xilo left
[17:55] * TimToady chews his cud

[17:55] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say $x.WHERE; say decont($x).WHERE; say Mu.WHERE

[17:55] <camelia> rakudo f2b0f8: OUTPUT«459420040␤459420040␤459420040␤»

[17:56] <jnthn> Um.

[17:56] <jnthn> .WHERE decontainerizes?

[17:56] <TimToady> r: sub decont(Mu \var) { var }; my $x = Mu; say decont($x) =:= Mu;  # why doesn't work?

[17:56] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:57] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say decont($x) =:= Mu;  # why doesn't work?

[17:57] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:57] <TimToady> r: sub decont(Mu $var) { $var }; my $x = Mu; say nqp::decont($x) =:= Mu;  # why doesn't work?

[17:57] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:57] <jnthn> r: sub decont(Mu $var) { $var }; say decont(Mu).VAR

[17:57] <camelia> rakudo f2b0f8: OUTPUT«(Mu)␤»

[17:58] <jnthn> r: sub decont(Mu $var) { $var }; say decont(Mu) =:= Mu

[17:58] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:58] <jnthn> r: sub decont(Mu $var) { $var }; my $x := Mu; say decont($x) =:= Mu

[17:58] <camelia> rakudo f2b0f8: OUTPUT«True␤»

[17:58] <jnthn> r: sub decont(Mu $var) { $var }; my $x = Mu; say decont($x) =:= Mu

[17:58] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[17:58] *** domidumont left
[17:58] <jnthn> Um. That's surprising...

[17:58] <TimToady> me2

[17:58] <jnthn> r: sub decont(Mu $var) { $var }; my $x = Mu; say decont($x).VAR

[17:59] <camelia> rakudo f2b0f8: OUTPUT«Mu␤»

[17:59] <jnthn> r: sub decont(Mu $var) { $var }; my $x = Mu; say nqp::iscont(decont($x))

[17:59] <camelia> rakudo f2b0f8: OUTPUT«1␤»

[17:59] <jnthn> I wonder if this is something to do with the "don't flatten" thing...

[17:59] *** skids joined
[17:59] <TimToady> then why doesn't \var work?

[18:00] <TimToady> r: sub decont(Mu \var) { var }; my $x = Mu; say nqp::iscont(decont($x))

[18:00] <camelia> rakudo f2b0f8: OUTPUT«1␤»

[18:00] <jnthn> r: sub decont(Mu \var) { say nqp::iscont($var); $var }; my $x = Mu; say nqp::iscont(decont($x))

[18:00] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Variable '$var' is not declared␤at /tmp/9X3e9QuPxR:1␤------> b decont(Mu \var) { say nqp::iscont($var⏏); $var }; my $x = Mu; say nqp::iscont(d␤    expecting any of:␤        postfix␤»

[18:00] <jnthn> r: sub decont(Mu \var) { say nqp::iscont(var); var }; my $x = Mu; say nqp::iscont(decont($x))

[18:00] <camelia> rakudo f2b0f8: OUTPUT«1␤1␤»

[18:01] <jnthn> \var doesn't mean decontainerize, it means "take whatever was passed"

[18:01] <TimToady> but returning var should decont?

[18:01] <TimToady> r: sub decont(Mu \var) { return var }; my $x = Mu; say nqp::iscont(decont($x))

[18:01] <camelia> rakudo f2b0f8: OUTPUT«1␤»

[18:02] <TimToady> r: sub decont(Mu \var) { |var }; my $x = Mu; say nqp::iscont(decont($x))

[18:02] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (lines 1, 1)␤»

[18:02] <jnthn> TimToady: I think it reconts.

[18:03] <jnthn> TimToady: To not lose the scalar nature of it, but to make sure it's ro, it re-wraps it in a read-only container.

[18:04] <TimToady> r: my &decont := &nqp::decont; my $x = Mu; say nqp::iscont(decont($x))

[18:04] <camelia> rakudo f2b0f8: OUTPUT«Type check failed in binding; expected 'Callable' but got 'Any'␤  in block  at /tmp/In723T7kNf:1␤␤»

[18:04] <TimToady> r: my &decont = &nqp::decont; my $x = Mu; say nqp::iscont(decont($x))

[18:04] <camelia> rakudo f2b0f8: OUTPUT«Type check failed in assignment to '&decont'; expected 'Callable' but got 'Any'␤  in block  at /tmp/NLN214_Q6X:1␤␤»

[18:05] <TimToady> r: my \decont = &nqp::decont; my $x = Mu; say nqp::iscont(decont($x))

[18:05] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&decont' called (lines 1, 1)␤»

[18:05] <FROGGS> timotimo: an if is allowed

[18:05] <TimToady> r: my \decont = &nqp::decont; my $x = Mu; say nqp::iscont(decont.($x))

[18:05] <camelia> rakudo f2b0f8: OUTPUT«No such method 'Any' for invocant of type 'Mu'␤  in block  at /tmp/RXIMdwFzt_:1␤␤»

[18:05] <TimToady> r: my $decont = &nqp::decont; my $x = Mu; say nqp::iscont($decont.($x))

[18:05] <camelia> rakudo f2b0f8: OUTPUT«No such method 'Any' for invocant of type 'Mu'␤  in block  at /tmp/TGWKSyNgqq:1␤␤»

[18:06] <TimToady> .oO(...)

[18:07] <TimToady> r: say &nqp::decont ~~ Callable

[18:07] <camelia> rakudo f2b0f8: OUTPUT«False␤»

[18:07] <timotimo> oh, of course it is. good catch.

[18:07] <timotimo> but is the basic approach sensible?

[18:07] <FROGGS> timotimo: same for when

[18:07] <jnthn> TimToady: nqp:: things a macro-ish, not sub-ish

[18:07] <timotimo> hmm

[18:07] <FROGGS> timotimo: but yes, I think it is useful, for say, routine_decl after block

[18:08] <timotimo> so you think i should parse a full thingie after a block and if it succeeds i should explode?

[18:09] <TimToady> jnthn: but then there's the paragraph at S06:3149

[18:09] <dalek> perl6-roast-data: b3c45da | coke++ | / (5 files):

[18:09] <dalek> perl6-roast-data: today (automated commit)

[18:09] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b3c45da117

[18:10] <[Coke]> # 07/02/2013 9c64dd0 rakudo++ (26088); niecza (81.73%); pugs (36.42%); rakudo.jvm (92.34%)

[18:10] <FROGGS> timotimo: yes because I would think that these are the usual mistakes

[18:10] <FROGGS> yay

[18:10] <FROGGS> \o/

[18:11] <colomon> \o/

[18:11] <[Coke]> masak: (BB) glad you liked it!

[18:12] <[Coke]> r: say 26088*.95-24092

[18:12] <camelia> rakudo f2b0f8: OUTPUT«691.6␤»

[18:13] <masak> labster: re https://github.com/perl6/specs/commit/71e9f8551c297d7840c3dca9e3bbf4382a2bd92d -- the descriptions of floor and ceiling don't make sense. the description of round partially doesn't make sense.

[18:13] <masak> labster: if you just say "the highest integer", it sounds like you mean "real integer".

[18:13] <masak> labster: and complex numbers aren't ordered.

[18:14] <timotimo> big ups, everyone \o/

[18:19] <jnthn> Wow, that's some way past 90%!

[18:21] * colomon is thinking he is going to install OS X 10.8.X as soon as his current Time Machine backup is finished.... JVM 1.7 here we come!

[18:21] <jnthn> TimToady: The -ish was quite a big -ish ;)

[18:21] <FROGGS> jnthn: about that stack overflow from rshift.t, on my machine 0xx3700 blows up while 0xx3500 does not

[18:21] <FROGGS> jnthn: is that a limitation of my machine?

[18:22] <jnthn> FROGGS: Wait, is there actually some recursion expected to be going on here?

[18:22] * jnthn thought it was a test for bit-shifting...

[18:23] <FROGGS> jnthn: dunno, does the X+> a recursion?

[18:23] <FROGGS> yes, but it is just the size of the list

[18:23] <FROGGS> even the hardcoded list blows up

[18:23] <FROGGS> (6010 elements)

[18:23] <jnthn> X is implemented iteratively, iirc

[18:23] <FROGGS> that is why I tested 0 xx 3700

[18:24] <FROGGS> to find out what the max list size is

[18:24] <FROGGS> and it is somewhere arround 3500 .. 3700 here

[18:24] <FROGGS> wonder if that is about memory limits or something VM-ish

[18:25] <jnthn> yeah, $i looks iterative to me

[18:25] <jnthn> oops

[18:25] <jnthn> X looks iterative tome

[18:26] <jnthn> the meta-op form

[18:26] * jnthn wonders if there's something weird going on with the gather/take

[18:27] <notjack> is it possible to implement a function composition operator such that it takes two functions as input (foo, bar) and returns a function which, when called, applies foo to the result of bar, then the inverse-of-bar (if it exists) to the result of foo?

[18:27] <FROGGS> if RANGE X+> RANGE and 0 xx NUMBER show the same limit, does this still point to gather/take?

[18:27] <moritz> notjack: yes, if you can find a way to find the inverse of bar

[18:28] <jnthn> Well, I'm only wondering about gather/take 'cus X meta-op is implemented in terms of it

[18:28] <notjack> I was under the impression that functions can define their own inverses

[18:28] *** lizmat joined
[18:28] <notjack> like they can declare that they're associative, etc, I thought they could also declare themselves invertible

[18:28] <moritz> not out of the box

[18:28] <notjack> (and provide the inverse definition)

[18:29] <moritz> Perl 6 is not a computer algebra system

[18:29] <notjack> hmm, ok, my misapprehension

[18:29] <moritz> (though you could certainly build on top of it, and I've been tempted before :-)

[18:29] <moritz> *build one

[18:29] <notjack> I didn' tmean P6 should "figure out" the inverse, only allow subs to declare themselves invertible, and provide and inverse

[18:29] <moritz> you can certainy do that with traits

[18:29] <notjack> like sub exp is invertible {...} inverse is log {...}

[18:29] <[Coke]> https://gist.github.com/coke/5879701 updated.

[18:30] <timotimo> std: given "1" { when Str { say "yup" } when Int { say "oh what?" } }

[18:30] <camelia> std 102c740: OUTPUT«===SORRY!===␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/okQWqFuRj0 line 1:␤------> given "1" { when Str { say "yup" }⏏ when Int { say "oh what?" } }␤    expecting horizontal whitespace␤Parse faile…

[18:30] <TimToady> we never did invertable, but we did at one point consider 'is commutative'

[18:31] <timotimo> yeah, i can port that possibly

[18:31] <timotimo> but not right now

[18:31] <notjack> yeah, commutitivity would be helpful for optimizing reductions

[18:32] <notjack> if you knew + was commutitive then you could optimize the operation [+]

[18:32] <moritz> r: multi sub trait_mod:<is>(&r, :$inverse!) { &r does role { method inverse() { $inverse } } }; sub f($x) is inverse({$_ - 2}) { $x + 2 }

[18:32] <camelia> rakudo f2b0f8:  ( no output )

[18:32] <moritz> r: multi sub trait_mod:<is>(&r, :$inverse!) { &r does role { method inverse() { $inverse } } }; sub f($x) is inverse({$_ - 2}) { $x + 2 }; say &f.inverse.(f(42))

[18:32] <camelia> rakudo f2b0f8: OUTPUT«42␤»

[18:32] <moritz> there you go

[18:33] <notjack> here's a test case: define an invertible function log, whose inverse is exp, then an composition operator "under" and say  mult = sum under log such that mult (3,4) is the same as 3*4

[18:34] <notjack> oh, that's cool

[18:34] <TimToady> precision suffers...

[18:34] <notjack> traits are neat

[18:34] <TimToady> unless you get to real symbolic algebra

[18:34] <[Coke]> ah. someone added a reference to nqp::chdir() in the jvm, but never actually implemented it.

[18:34] <notjack> TimToady: the goal is more code clarity in certain contexts

[18:35] <TimToady> but this is partly why we are trying to keep the typespace outside of Any so that we can do conceptual types

[18:35] <notjack> where it's easier to think of transforming the problem to a new domain, expressing a calculation that's simple (in the new domain), and projecting back to the original domain

[18:35] <moritz> like schwartz' transform

[18:35] <TimToady> sure, I think of that as a kind of strength reduction optimization

[18:35] <notjack> think of FFT, e.g.

[18:35] <notjack> right

[18:37] <notjack> then of course you have to start thinking of identity functions, left- vs right-inverses, etc

[18:37] <notjack> but even a coarse implementation is a boon for the user

[18:37] <raiph> .ask sorear is niecza's gather/take lazy?

[18:37] <yoleaux> raiph: I'll pass your message to sorear.

[18:37] <TimToady> raiph: yes, it is

[18:37] <raiph> TimToady: thx

[18:38] <moritz> n: my @a := gather { for ^5 { take $_; .say } }; my $ = @a[2]

[18:38] <camelia> niecza v24-86-g39ab531: OUTPUT«0␤1␤»

[18:38] <TimToady> ooh, In-n-Out magically happened, yum &

[18:38] <[Coke]> ugh. chdir on the jvm is not straightforward.

[18:39] <FROGGS> jnthn: if the things I posted are connected, it is more about memory limits or so rather that a fixed maximum list size... 0..54 X+ 0..54 works while 0..55 X+ 0..55 blows up

[18:39] <FROGGS> (according to my 6guts :P)

[18:40] * FROGGS .oO( a straightbackward chbackdir )

[18:41] *** ilbot_nextgen joined
[18:41] <notjack> another sugar-y question

[18:41] <moritz> or maybe a curly chdir?

[18:42] <notjack> is it possible to define a function that, given a seq of function names, produces a function which is a chain of those subs?

[18:42] <moritz> yes.

[18:42] <notjack> like chain(qw<sqroot sum square>) ?

[18:43] <notjack> (sorry, I'm still speaking pidgin perl5)

[18:43] <FROGGS> sub chainy( *@subs ) {  ::($_) for @subs }

[18:43] <FROGGS> sub chainy( *@subs ) {  ::($_)() for @subs } # invoke them

[18:43] <moritz> not quite

[18:44] <arnsholt> jnthn: On JVM, should a non-serializable type throw an exception in deserialize_stub, or is something else preferred?

[18:44] <moritz> well, if you do it that way, you have to pass the names with &

[18:44] *** Rotwang joined
[18:44] <moritz> so chainy <&sqrt &sin>   or so

[18:44] <jnthn> arnsholt: There is fine

[18:44] <FROGGS> r: sub test { say 42 }; ::('test')()

[18:44] <camelia> rakudo f2b0f8: OUTPUT«No such symbol 'test'␤  in method <anon> at src/gen/CORE.setting:10482␤  in any  at src/gen/Metamodel.nqp:2580␤  in any find_method_fallback at src/gen/Metamodel.nqp:2568␤  in any find_method at src/gen/Metamodel.nqp:939␤  in block  at /tmp/awrTvwhJoM:1␤␤»…

[18:44] <FROGGS> r: sub test { say 42 }; ::('&test')()

[18:44] <camelia> rakudo f2b0f8: OUTPUT«42␤»

[18:44] <FROGGS> moritz++

[18:45] <arnsholt> jnthn: Throw, you mean?

[18:45] <jnthn> arnsholt: It's fine to do it there; maybe it's better to use ExceptionHandling.dieInternal(...) than a plain throw

[18:45] <timotimo> bleeeeh, contentEditable="true" is dumb :(

[18:46] <FROGGS> r: sub chainy( :$args, *@subs ) { ::("&$_")($args) for @subs }; chainy( qw<say print>, args => 42 )

[18:46] <camelia> rakudo f2b0f8: OUTPUT«42␤42»

[18:46] <notjack> r: sqrt(15);

[18:46] <camelia> rakudo f2b0f8:  ( no output )

[18:46] <notjack> r: say sqrt(15);

[18:46] <camelia> rakudo f2b0f8: OUTPUT«3.87298334620742␤»

[18:46] <arnsholt> Right. dieInternal sounds promising

[18:47] <notjack> r: sub sum {[+] @_;} say sum(1,2,3);

[18:47] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/iDF1MkkiMC:1␤------> sub sum {[+] @_;} ⏏say sum(1,2,3);␤    expecting any of:␤        postfix␤        statement end␤        statement modifier␤        statement modifier loop␤        horiz…

[18:47] <moritz> notjack: the ; should go after the }

[18:48] <notjack> r: sub sum {[+] @_}; say sum(1,2,3);

[18:48] <camelia> rakudo f2b0f8: OUTPUT«6␤»

[18:49] <notjack> r: sub sum {[+] @_}; sub prod {[*] @_};  sub chainy( *@subs ) {  ::($_)() for @subs }; say chainy(&sqrt &sum &prod)(3,4);

[18:49] <camelia> rakudo f2b0f8: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Numeric at src/gen/CORE.setting:885␤  in sub infix:<+> at src/gen/CORE.setting:3263␤  in sub infix:<+> at src/gen/CORE.setting:3262␤  in sub  at src/gen/CORE.setting:14408␤  in su…

[18:50] <notjack> r: sub sum {[+] @_}; sub prod {[*] @_};  sub chainy( *@subs ) {  ::($_)() for @subs }; say (chainy(&sqrt &sum &prod))(3,4);

[18:50] <camelia> rakudo f2b0f8: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤  in method Numeric at src/gen/CORE.setting:885␤  in sub infix:<+> at src/gen/CORE.setting:3263␤  in sub infix:<+> at src/gen/CORE.setting:3262␤  in sub  at src/gen/CORE.setting:14408␤  in su…

[18:51] <notjack> oh, it's backwards!

[18:51] <notjack> I defined prod wrong

[18:52] *** arnsholt_ joined
[18:53] *** xilo joined
[18:55] *** arnsholt left
[18:59] *** dmol left
[19:00] *** cc joined
[19:02] *** cc left
[19:04] <dalek> roast: 1bafd26 | (Elizabeth Mattijsen)++ | S02-types/nil.t:

[19:04] <dalek> roast: Fix nil regression

[19:04] <dalek> roast: review: https://github.com/perl6/roast/commit/1bafd2697b

[19:07] *** ggoebel2 left
[19:16] <FROGGS> wow, fetching $beer is equal to ten lines of irc

[19:17] * moritz wants 10 commits

[19:20] <FROGGS> I could push something, but that lowers jakudo's percentage...

[19:21] <FROGGS> btw moritz, can you confirm that a rshift operation by a negative amount is correct when you see one?

[19:21] <FROGGS> I really dont know what to expect...

[19:21] <FROGGS> n: say -10 +> -1

[19:21] <camelia> niecza v24-86-g39ab531: OUTPUT«-1␤»

[19:21] <FROGGS> n: say -10 +> -9999999

[19:22] <camelia> niecza v24-86-g39ab531: OUTPUT«-5␤»

[19:22] <moritz> isn't that just a left-shift with the neg?

[19:22] <FROGGS> ?

[19:22] <moritz> p: say -16 +> -1

[19:22] <camelia> pugs: OUTPUT«-32␤»

[19:22] <moritz> p: say -16 +> 1

[19:22] <camelia> pugs: OUTPUT«-8␤»

[19:22] <moritz> that's kinda what I'd expect, intuitively

[19:22] <moritz> r: say 16 +> 1

[19:22] <camelia> rakudo f2b0f8: OUTPUT«8␤»

[19:22] <FROGGS> yeah, that was my first guess

[19:22] <FROGGS> pnr: say -10 +> -1

[19:23] <camelia> pugs: OUTPUT«-20␤»

[19:23] <camelia> ..rakudo f2b0f8: OUTPUT«-10␤»

[19:23] <camelia> ..niecza v24-86-g39ab531: OUTPUT«-1␤»

[19:23] <FROGGS> pnr: say -10 +< 1

[19:23] <camelia> rakudo f2b0f8, niecza v24-86-g39ab531, pugs: OUTPUT«-20␤»

[19:23] <notjack> what's the general pattern for applying a unary function foo to each value of an @array?

[19:23] <FROGGS> I can implement it that way...

[19:23] * colomon has the 4 GB OS X 10.8 installer downloaded...

[19:23] <FROGGS> any objections? anybody?

[19:23] <notjack> I tried gather take foo($_) for @array but p6 yelled at me

[19:23] <FROGGS> good.

[19:23] <FROGGS> :P

[19:24] <notjack> and >>foo<< @array gave me a weird error

[19:24] <moritz> notjack: @array.map: &foo;

[19:24] <FROGGS> >>foo<< needs a LHS too, no?

[19:24] <notjack> foo is unary

[19:24] <FROGGS> brb

[19:24] <moritz> notjack: or gather { take foo($_) for @array }

[19:24] <notjack> moritz: ah, thanks

[19:25] <notjack> I was missing the { } around gather

[19:25] <moritz> >>foo<< would only work with an infix foo

[19:25] *** xilo left
[19:26] <skids> FROGGS: beware rshift and a few bitops broken at the BigInt/native int border currently.

[19:26] <moritz> that's what FROGGS is trying to fix, no?

[19:26] <notjack> oh, I know why I skipped the {} after gather: if I put them in, then the block can't see @_ inside a sub

[19:26] <dalek> specs: adbf8b0 | (Brent Laabs)++ | S32-setting-library/Numeric.pod:

[19:26] <dalek> specs: clarify Complex rounders

[19:26] <dalek> specs: review: https://github.com/perl6/specs/commit/adbf8b0522

[19:26] <moritz> just give your sub a proper signature :-)

[19:27] <notjack> sub baz { gather { take sqrt $_ for @_ } } # :( doesn't work

[19:27] <masak> useless use of gather.

[19:27] <skids> Fix is already in rt.

[19:27] <moritz> sub baz(*@v) { @v>>.sqrt }

[19:27] <masak> r: sub baz { sqrt $_ for @_ }; say baz 1 4 9

[19:27] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/18eL0jX7rc:1␤------> sub baz { sqrt $_ for @_ }; say baz 1 ⏏4 9␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        statem…

[19:27] <masak> hrm :)

[19:28] <masak> r: sub baz { sqrt $_ for @_ }; say baz <1 4 9>

[19:28] <camelia> rakudo f2b0f8: OUTPUT«1 2 3␤»

[19:28] <huf> wait wait wait, for really *is* map?

[19:28] *** colomon left
[19:28] <notjack> hmm, I imagined that would only return the last value

[19:28] <moritz> huf: yes :(

[19:28] <moritz> anyway, map or >> is fine

[19:28] <notjack> hence gather

[19:28] <huf> i should read some docs eventually, instead of asking basic questions one by one... :(

[19:28] <moritz> if you want to do it with gather, you can day

[19:28] <masak> huf: I don't mind it so much for statement_mod 'for'.

[19:29] <masak> huf: because that's how Perl 6 does list comprehensions.

[19:29] <moritz> r: sub baz(*@v) { gather { take sqrt($_) for @v } }; say baz 1, 4, 9, 25

[19:29] <camelia> rakudo f2b0f8: OUTPUT«1 2 3 5␤»

[19:29] <moritz> but yes, gather is overkill

[19:29] <skids> RT #115958 and...

[19:29] <huf> masak: i dont think i mind, since in p5 map made "sense" in void context (and yet, no sensible person ever used it like that)

[19:29] <segomos> moritz: is it a bug that DBIish fails to release a prepared SELECT in a way that i can insert afterwards (Commands out of sync error)?  If it is then i'll debug a little more and send a pull request with a fix

[19:29] <huf> the way a thing works is no license to use it like that :D

[19:30] <segomos> i can't insert^ (if i don't request rows from the SELECT)

[19:30] <skids> ... #115966

[19:30] <moritz> segomos: yes, it's a bug

[19:31] <labster> masak: hopefully my clarifications on the rounders spec is better.  I suspect that was the result of me trying to spec something too late at night.

[19:43] <notjack> I'm still having trouble with the "chained functions" thing

[19:43] <notjack> r: sub sqar {@_ »*« @_}; sub sum { [+] @_}; sub sqrtt {@_>>.sqrt}; sub chainy( :$args, *@subs ) { ::("&$_")($args) for reverse @subs }; say chainy(qw<sqrtt sum sqar>, args => (3,4) )

[19:43] <camelia> rakudo f2b0f8: OUTPUT«4 2 1.4142135623731␤»

[19:44] <notjack> what I want is "5"

[19:44] <notjack> (sqrt of sum of squares) (3,4) #pythogorean triple is 3 4 5

[19:45] <dalek> nqp: 88892f7 | jnthn++ | src/vm/jvm/runtime/org/perl6/nqp/sixmodel/reprs/CallCaptureInstance.java:

[19:45] <dalek> nqp: Make CallCapture REPR clonable.

[19:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/88892f7672

[19:45] <notjack> whereas this works: 

[19:45] <moritz> notjack: $args is a scalar, yet you try to treat it as a list

[19:46] <notjack> I stole "chainy" from FROGGS 

[19:46] <notjack> it should be passed as an opaque argument list to the first funcion in the chain

[19:46] <moritz> ... indendently of who wrote the function :-)

[19:46] <notjack> maybe that's |*args?

[19:47] <moritz> I don't think you can have an argument that is both named and without context

[19:47] <jnthn> std: sub foo(:\bar) { }

[19:47] <camelia> std 102c740: OUTPUT«ok 00:00 43m␤»

[19:47] <jnthn> r: sub foo(:\bar) { }

[19:47] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Malformed parameter␤at /tmp/IYwqZYTlhh:1␤------> sub foo(⏏:\bar) { }␤    expecting any of:␤        statement list␤        prefix or term␤        prefix or meta-prefix␤        new name to be defined␤»…

[19:47] <jnthn> Hm. :)

[19:47] <moritz> not in rakudo, at least :-)

[19:47] <notjack> this works: 

[19:47] <notjack>  r: sub sqar {@_ »*« @_}; sub sum { [+] @_}; sub sqrtt {@_>>.sqrt}; say sqrtt(sum(sqar(3,4)));

[19:47] <camelia> rakudo f2b0f8: OUTPUT«5␤»

[19:47] *** rindolf left
[19:48] <notjack> what I want is a chainy such that chainy(qw<sqrtt sum sqar), ...whatever...) is sqrtt(sum(squar(...whatever...)));

[19:49] <notjack> or, ideally,chainy simply constructs and returns the function (sqrtt of sum of sqar) such that I can assign it to a name and use it later

[19:49] <moritz> then do that :-)

[19:49] <notjack> ok, how? :)

[19:50] <moritz> do you know how currying works?

[19:50] <notjack> not in p6

[19:50] <jnthn> walk, bbiab

[19:50] <moritz> you can do it just like in perl 5

[19:50] <moritz> return an anonymous function

[19:51] <notjack> but how do I get chainy to compose the function?

[19:51] <notjack> given that it returns a (novel, anonymous) function derived from the functions named in its arguments?

[19:52] <notjack> and the argument list can name any number of functions, from 1 to N

[19:52] <moritz> do you know how to do it with just one function?

[19:52] <notjack> In p5 I'd evoke it with &

[19:53] <moritz> or let me rephrase

[19:53] <moritz> do you know how to compose/chain two functions?

[19:53] <notjack> only by stringing them out

[19:54] <moritz> r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }

[19:54] <camelia> rakudo f2b0f8:  ( no output )

[19:54] <moritz> r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }; my &f = compose(&sqrt, &cos); f(0)

[19:54] <camelia> rakudo f2b0f8:  ( no output )

[19:54] <moritz> r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }; my &f = compose(&sqrt, &cos); say f(0)

[19:54] <camelia> rakudo f2b0f8: OUTPUT«1␤»

[19:54] <moritz> now you just have to do it in a loop, and with the lookup by name

[19:55] <notjack> given that b(a(...)) is syntax, it's not clear to me hwo to make that a loop

[19:55] *** btyler joined
[19:55] <notjack> I can see that's amenable to recursion

[19:56] <moritz> recursion and loops are just the same, really

[19:57] <notjack> I mean, an easy way is to literally compose a string and execute it

[19:59] <notjack> > r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }; my &f = [compose] (&sqrt, &cos, &cos); say f(0);

[19:59] <FROGGS> skids: yes, I'm working on that... your patch btw breaks compiling. but I think #i can supply a fix till tomorrow for rshift

[19:59] <notjack> r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }; my &f = [compose] (&sqrt, &cos, &cos); say f(0);

[19:59] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/vMHWDpmbBk:1␤------> gs) { b(a(args)) } }; my &f = [compose] ⏏(&sqrt, &cos, &cos); say f(0);␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤       …

[19:59] <dalek> DBIish: 1d48c17 | segomos++ | lib (2 files):

[19:59] <dalek> DBIish: Bug work-around where a prepared SELECT w/o .fetch causes the result set to not be released and subsequent prepared statements fail

[19:59] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/1d48c176a2

[20:00] <notjack> to me, that indicates there's a difference between loops and recursion in this context

[20:01] <notjack> because functions aren't quite values in the same way that (for example) numbers are, in p6

[20:01] <moritz> well, syntactic differences, yes

[20:01] <moritz> but what you can do with recursion, you can also do with loops

[20:01] <moritz> or vice versa

[20:01] <notjack> yes, in general, recursion can be implemented with a loop and a stack 

[20:02] <moritz> r: sub compose(&a, &b) { return sub (\args) { b(a(args)) } }; my &composed = reduce &compose, &sqrt, &cos, &cos; say composed(0)

[20:02] <camelia> rakudo f2b0f8: OUTPUT«0.54030230586814␤»

[20:02] <notjack> but I thought the topic of discussion was exactly those syntactic differences

[20:02] <segomos> moritz: thanks dude

[20:02] <TimToady> .tell lizmat The biggest practical difference between Mu and Nil is that Mu.ACCEPTS($x) is always true, and Nil.ACCEPTS($x) is always false

[20:02] <yoleaux> TimToady: I'll pass your message to lizmat.

[20:02] <moritz> segomos: thank you for your fix

[20:03] <notjack> ok, i'm going to have to study reduce

[20:03] <notjack> I thought [] should suffice for reduction

[20:03] <notjack> s/should/would/

[20:03] <moritz> [] is for infixes

[20:03] <notjack> ah...

[20:03] <notjack> thank you.

[20:04] <moritz> nr: sub a($a, $b) { $a + $b }; say [&a] 1, 2, 3

[20:04] <camelia> niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/N0OLrjfRwq line 1:␤------> sub a($a, $b) { $a + $b }; say [&a] ⏏1, 2, 3␤␤Parse failed␤␤»

[20:04] <camelia> ..rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/5G6u4mz3yM:1␤------> sub a($a, $b) { $a + $b }; say [&a] ⏏1, 2, 3␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤        statement end␤        stat…

[20:04] <TimToady> try [[&a]]

[20:04] <moritz> nr: sub a($a, $b) { $a + $b }; say [[&a]] 1, 2, 3

[20:04] <camelia> niecza v24-86-g39ab531: OUTPUT«6␤»

[20:04] <camelia> ..rakudo f2b0f8: OUTPUT«===SORRY!===␤Unable to parse expression in bracketed infix; couldn't find final ']'␤at /tmp/MXHCOrJWEd:1␤------> sub a($a, $b) { $a + $b }; say [[&⏏a]] 1, 2, 3␤»

[20:04] <moritz> NYI in rakudo

[20:04] * [Coke] wonders why the spec list was backed up

[20:04] <moritz> notjack: [] is basically syntactic sugar for &reduce, plus it pays attention to associativity

[20:06] <Ayiko> r: sub infix:<compose>(&a, &b) { return sub (\args) { b(a(args)) } }; my &f = [compose] (&sqrt, &cos, &cos); say f(0);

[20:06] <camelia> rakudo f2b0f8: OUTPUT«0.54030230586814␤»

[20:07] <TimToady> none of those parens are necessary :)

[20:07] <TimToady> except around the signature

[20:07] <TimToady> r: sub infix:<compose>(&a, &b) { return sub (\args) { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:07] <camelia> rakudo f2b0f8: OUTPUT«0.54030230586814␤»

[20:08] <moritz> Ayiko++

[20:08] <TimToady> lessee, we can do better

[20:09] <TimToady> r: sub infix:<compose>(&a, &b) { return -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:09] <camelia> rakudo f2b0f8: OUTPUT«0.54030230586814␤»

[20:09] <TimToady> r: my &infix:<compose> = -> &a, &b { return -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:09] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Undeclared routine:␤    compose used at line 1␤␤»

[20:09] *** ilbot_nextgen left
[20:10] <TimToady> n: my &infix:<compose> = -> &a, &b { return -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:10] <camelia> niecza v24-86-g39ab531: OUTPUT«1␤»

[20:10] <TimToady> hmm

[20:10] <TimToady> oh, return...

[20:10] <TimToady> r: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:10] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Undeclared routine:␤    compose used at line 1␤␤»

[20:10] <TimToady> still seems like a bug

[20:11] <TimToady> r: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = &sqrt compose &cos compose &cos; say f 0

[20:11] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Two terms in a row␤at /tmp/EuhikrJ5oB:1␤------>  -> \args { b a args } }; my &f = &sqrt ⏏compose &cos compose &cos; say f 0␤    expecting any of:␤        postfix␤        infix stopper␤        infix or meta-infix␤   …

[20:11] <TimToady> my &infix<> isn't working right

[20:12] <TimToady> r: constant infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = &sqrt compose &cos compose &cos; say f 0

[20:12] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤invoke() not implemented in class 'QAST::Want'␤at /tmp/hwpxxON05L:1␤------> ␤»

[20:12] <TimToady> n: constant infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = &sqrt compose &cos compose &cos; say f 0

[20:12] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <file…

[20:12] <TimToady> cool!

[20:13] <TimToady> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = &sqrt compose &cos compose &cos; say f 0

[20:13] <camelia> niecza v24-86-g39ab531: OUTPUT«0.54030230586813977␤»

[20:14] <TimToady> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:14] <camelia> niecza v24-86-g39ab531: OUTPUT«0.54030230586813977␤»

[20:14] <notjack> cool!

[20:14] <TimToady> no parens at all :)

[20:14] <notjack> can you skip the assignment to &f and call the output of [compose] anonymously, withoug using parens?

[20:15] <TimToady> um, not that I know of

[20:15] <TimToady> wait, maybe

[20:15] <moritz> with reducde

[20:16] <moritz> *reduce

[20:16] <moritz> erm, never mind

[20:16] <notjack> this is cool

[20:16] <notjack> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f =

[20:16] <notjack>                   [compose] &sqrt, &cos, &cos; say f 0

[20:16] <camelia> niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Malformed initializer at /tmp/I4FW_obhiC line 1:␤------> &a, &b { -> \args { b a args } }; my &f ⏏=␤␤Parse failed␤␤»

[20:17] *** colomon_chrome joined
[20:17] <notjack> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:17] <camelia> niecza v24-86-g39ab531: OUTPUT«0.54030230586813977␤»

[20:17] <notjack> r: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] &sqrt, &cos, &cos; say f 0

[20:17] <camelia> rakudo f2b0f8: OUTPUT«===SORRY!===␤Undeclared routine:␤    compose used at line 1␤␤»

[20:17] <colomon_chrome> o/

[20:18] <colomon_chrome> went looking for LHF on JVM.  Discovered indent.t's fatal error 80% through was this line: -        warn sprintf('Asked to remove %d spaces, ' ~ -                     'but the shortest indent is %d spaces', -                     $outdent, $common-prefix) if $outdent > $common-prefix;

[20:18] <notjack> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; sub chain { [compose] @_; } my &f = chain &cos, &sqrt, &cos; say f(0);

[20:18] <camelia> niecza v24-86-g39ab531: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/I6XwEu5p6j line 1:␤------>  a args } }; sub chain { [compose] @_; }⏏ my &f = chain &cos, &sqrt, &cos; say f(␤␤Parse failed␤␤»…

[20:18] <colomon_chrome> is there any real reason to use sprintf instead of normal p6 variable interpolation there?

[20:19] <TimToady> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; 0.$&({ [compose] &sqrt, &cos, &cos })  # almost

[20:19] <camelia> niecza v24-86-g39ab531:  ( no output )

[20:19] <[Coke]> colomon_chrome: not based on that example, no.

[20:19] <TimToady> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; say 0.$&({ [compose] &sqrt, &cos, &cos })  # almost

[20:19] <camelia> niecza v24-86-g39ab531: OUTPUT«{ ... }␤»

[20:20] <[Coke]> seems reasonable to not drag in stuff not directly related to the test.

[20:20] <TimToady> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; say 0.&({ [compose] &sqrt, &cos, &cos })  # almost

[20:20] <camelia> niecza v24-86-g39ab531: OUTPUT«{ ... }␤»

[20:20] <colomon_chrome> [Coke]: that code is in the indent method 

[20:20] <TimToady> hmm, oughta work

[20:20] <notjack> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] qw<&sqrt &cos &cos>; say f 0

[20:20] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: Nominal type check failed in binding '&a' in 'ANON'; got Str, needed Callable␤  at /tmp/xjDVXvkq6W line 0 (ANON @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2773 (reduceop @ 59) ␤  at /tmp/xjDVXvkq6W line 1 (mainline @ 4) ␤  at…

[20:21] *** lizmat left
[20:21] <notjack> n: my &infix:<compose> = -> &a, &b { -> \args { b a args } }; my &f = [compose] qw<sqrt cos cos>; say f 0

[20:21] <[Coke]> colomon_chrome: oh. yah, if there's no formatter with the %d, I'd say just use interpolation.

[20:21] <camelia> niecza v24-86-g39ab531: OUTPUT«Unhandled exception: Nominal type check failed in binding '&a' in 'ANON'; got Str, needed Callable␤  at /tmp/Ri_hXArZM1 line 0 (ANON @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2773 (reduceop @ 59) ␤  at /tmp/Ri_hXArZM1 line 1 (mainline @ 4) ␤  at…

[20:23] <colomon_chrome> [Coke]: so the next thing is, of course I tried it myself before coming here.  And here's the crazy thing: it actually breaks the build

[20:23] <TimToady> n: say <sqrt cos cos>».map: { &::($_) }

[20:23] <camelia> niecza v24-86-g39ab531: OUTPUT«sub sqrt(Any $x) { ... } sub cos(Any $x) { ... } sub cos(Any $x) { ... }␤»

[20:23] <TimToady> notjack: ^^

[20:23] <TimToady> ::() is symbolic lookup syntax

[20:23] <colomon_chrome> ooooo, my normal computer is booting up in 10.8.4!

[20:24] * colomon_chrome crosses his fingers....

[20:24] <dalek> DBIish: 0429089 | segomos++ | lib34 (2 files):

[20:24] <dalek> DBIish: Correcting a typo I made in the last bug workaround

[20:24] <dalek> DBIish: review: https://github.com/perl6/DBIish/commit/042908993b

[20:27] *** snoopy joined
[20:30] *** colomon joined
[20:31] *** colomon left
[20:31] *** colomon joined
[20:32] <colomon> o/

[20:32] <colomon> javap -version

[20:32] <colomon> 1.7.0_04

[20:32] *** vk joined
[20:33] <jnthn> uh-oh :)

[20:33] <jnthn> I hope that isn't too early to have the indy fixes...

[20:33] <FROGGS> jnthn: do you have any objections that -8 +> -1 acts like -8 +< 1 ?

[20:34] *** colomon_chrome left
[20:35] <colomon> jnthn: I'm pretty sure the latest JVM I was able to find online would have been very happy to install on OS X 10.8.4

[20:36] <jnthn> FROGGS: On JVM they come out the same...I dunno if that identity holds up generally?

[20:38] <skids> In C negative rshift is lshift.  However newer C compilers will warn if they see this done with literals.

[20:38] *** konundra left
[20:39] <jnthn> k

[20:39] * colomon fixes the scrolling on his machine

[20:39] <FROGGS> k, that is all I wanted to know :o)

[20:39] <FROGGS> thank you all

[20:40] *** fgomez left
[20:40] <colomon> BTW, should have mentioned this earlier: JSON::RPC, LWP::Simple, and Sitemap::XML::Parser started failing their tests overnight

[20:41] <FROGGS> colomon: this might be fixed already

[20:41] <FROGGS> ohh, hmm, nvm

[20:41] <masak> labster++ # Complex rounding spec fixes

[20:41] <colomon> FROGGS: what were you thinking?  I can always trying running the smoke test again...

[20:42] <FROGGS> colomon: I was thinking about a bad commit from yesterday, which got fixed by jnthn++ this morning (eu timezone)

[20:42] <FROGGS> but this bad commit broke building of rakudo

[20:42] *** pmurias joined
[20:42] <FROGGS> so, it cant affect just a few modules :o)

[20:43] <skids> Correcting myself, actually it looks like that behavior is compiler-specific. gcc lshifts, but ISO 9899:1999 6.5.7 Bit-wise shift operators §3 says the behavior is undefined.

[20:43] <FROGGS> well, undef is okay too

[20:43] <FROGGS> so we can do something, and spec it

[20:44] <skids> I think it could come in handy.

[20:44] <FROGGS> the best thing to do is what the user expects

[20:44] <[Coke]> https://github.com/blog/1547-release-your-software

[20:45] <FROGGS> github++

[20:51] <dalek> rakudo/nom: 86975e1 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[20:51] <dalek> rakudo/nom: Finish post-constraints trnaslation.

[20:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/86975e1fa6

[20:51] <dalek> rakudo/nom: 0ab12f3 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.nqp:

[20:51] <dalek> rakudo/nom: Fix over-sharing bug in bind-check multi dispatch

[20:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ab12f3486

[20:51] <dalek> rakudo/nom: a026db1 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Ops.java:

[20:51] <dalek> rakudo/nom: Remove debugging code.

[20:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a026db14b5

[20:51] <dalek> rakudo/nom: c96b216 | jnthn++ | src/vm/jvm/runtime/org/perl6/rakudo/Binder.java:

[20:51] <dalek> rakudo/nom: Generic instantiation in signature binding.

[20:51] <dalek> rakudo/nom: 

[20:51] <dalek> rakudo/nom: Handles constructs like (::T, T).

[20:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c96b216f39

[20:52] *** lue left
[20:52] <nwc10> jnthn: if there's a prize for figuring out what that bundle of awesome actually enables, I'm not going to win it :-(

[20:53] <[Coke]> jnthn: let me know if I should rerun the aborted files gist tonight.

[20:53] <timotimo> thank you for finishing the trnaslation. that really messed me up!

[20:53] <timotimo> :þ

[20:53] <[Coke]> ah. Generic type parameter binding NYI! that will fix something, I'm sure of it. :)

[20:53] <jnthn> nwc10: Most notably, unbusts some parametric roles stuff.

[20:54] <jnthn> [Coke]: Yes, there was a test failing wiht that error that now passes fully also.

[20:54] <FROGGS> (fully also)++

[20:55] *** vk left
[20:58] <dalek> nqp: ec5448d | (Tobias Leich)++ | src/vm/parrot/ops/nqp_bigint.ops:

[20:58] <dalek> nqp: special-case negative values in rshift

[20:58] <dalek> nqp: 

[20:58] <dalek> nqp: ... and treat rshifting by an negative amount like an lshift by

[20:58] <dalek> nqp: positive amount.

[20:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ec5448d713

[20:58] <colomon> I read c96b216 as "Genetic instantiation in signature binding." -- exciting yet worrying

[20:59] <jnthn> :P

[20:59] *** vk joined
[21:00] <FROGGS> nr: say -10 +> 1

[21:00] <camelia> rakudo f2b0f8, niecza v24-86-g39ab531: OUTPUT«-5␤»

[21:00] <colomon> jnthn: any clue why using string interpolation instead of sprintf in Str.indent would break the Rakudo (jam) build?

[21:00] <FROGGS> nr: say -11 +> 1 # this should be equal in a mo'

[21:00] <camelia> niecza v24-86-g39ab531: OUTPUT«-6␤»

[21:00] <camelia> ..rakudo f2b0f8: OUTPUT«-5␤»

[21:01] <jnthn> colomon: no

[21:01] <FROGGS> ohh no, I didnt update nqp_head yet...

[21:01] <colomon> jnthn: I've temporarily gotten sidetracked by the issue of getting my MBP back to doing what I need now that I've got OS X 10.8.4 on it.  

[21:02] <jnthn> :)

[21:05] <FROGGS> is there an nqp of for list repetition like there is nqp::x for strings?

[21:05] *** lue joined
[21:06] *** skids left
[21:06] *** arnsholt_ left
[21:07] *** BenGoldberg joined
[21:07] <jnthn> No

[21:07] <FROGGS> k

[21:07] <FROGGS> thx

[21:08] * jnthn will have 3 talks at YAPC::EU o.O

[21:08] <tadzik> woosh

[21:08] <masak> nice!

[21:09] <FROGGS> and I won't be there ó.ò

[21:09] <jnthn> Aww

[21:09] <jnthn> And...it's in Kiev \o/

[21:09] <FROGGS> yeah, it is a bit like family +^ yapc for me

[21:10] <jnthn> *nod*

[21:10] <nwc10> the hackathon is not yet very popular: http://act.yapc.eu/ye2013/talk/4904

[21:10] * jnthn marks himself as going

[21:10] *** Rotwang left
[21:10] <jnthn> I'm guessing that moritz++ and masak++ might attend it too ;)

[21:10] <nwc10> they haven't starred it yet

[21:11] <jnthn> Well, maybe people haven't really got starrted with doing that yet... :)

[21:11] <FROGGS> hehe, then I never met moritz when we are living in the same country >.<

[21:12] <masak> starring it now.

[21:12] *** spider-mario left
[21:14] <jnthn> You're a star!

[21:15] * masak ★

[21:15] * nwc10 is starrtled by how many puns can be made with just one word

[21:16] <masak> ★.★

[21:16] <nwc10> what's the point of trying with anything else? :-)

[21:16] <masak> just doing one word might lead to pun starrvation...

[21:16] <TimToady> we're only just starring

[21:16] *** lue left
[21:17] * perigrin is a Perl hipster, already registered to attend YAPC::NA 2014.

[21:18] <nwc10> masak: neighbody is going to starrve on this channel. Plenty of meat :-)

[21:18] * TimToady is a Perl hipstar

[21:19] <masak> nwc10: are you really going to keep beating that d... oh dang.

[21:22] <jnthn> That joke isn't "stable" yet? :P

[21:23] *** frdmn left
[21:23] <timotimo> starbl?

[21:23] <masak> oh here we go again, another lap around the old familiar course.

[21:23] <TimToady> That beat has the Ringo truth.

[21:23] <masak> just jockeying around.

[21:23] *** frdmn joined
[21:24] <masak> frdmn: your quit message makes it look like you're a Python programmer.

[21:24] <masak> or a parselmouth.

[21:24] <TimToady> maybe just a leaky tire

[21:25] <perigrin> or a star hooked up to a geiger counter.

[21:26] <masak> or maybe he's just a little horse right now.

[21:26] * TimToady thinks we should welcome someone from Mongolia...

[21:26] *** raiph left
[21:26] *** vk left
[21:27] *** PacoAir left
[21:28] * masak .oO( I don't think we khan do that... )

[21:28] *** lue joined
[21:28] <TimToady> you are an incorrigible punstar

[21:29] <masak> no, Gengh is.

[21:30] <TimToady> 'cuz Kub is too laconic

[21:31] <diakopter> *groan*

[21:32] <masak> I think we just ran out of famous Khans.

[21:32] <masak> no-one knows about Ögedei.

[21:32] <huf> batu much punning can be bad for you

[21:32] <frdmn> masek: whats my quit message again? :P

[21:32] <masak> 23:23 -!- frdmn [~frdmn@irc.frd.mn] has quit [Quit: ssssSSSSssss]

[21:33] <frdmn> ah.

[21:33] <frdmn> i just like minecraft

[21:33] <TimToady> are you really in Mongolia?  I hear they like horses there...

[21:33] <labster> Ulan is betaar

[21:33] <masak> haha

[21:33] <huf> mondavi and mongolia?

[21:33] <frdmn> i aint. i still like horses

[21:33] <masak> Huhot is too hot.

[21:34] <diakopter> TimToady: yes, especially starlings

[21:34] * lue wants to get in on the pun action, but doesn't know where to start. Whatever.

[21:34] <perigrin> our huhot closed :/

[21:35] *** raiph joined
[21:35] *** raiph left
[21:39] *** vk joined
[21:39] <masak> perigrin: oh, I was thinking of the capital of Inner Mongolia -- but it seems it's translitted "Hohhot".

[21:41] <dalek> roast: fa26638 | (Brent Laabs)++ | S32-num/rounders.t:

[21:41] <dalek> roast: testing fix for RT #118545, round with scale argument

[21:41] <dalek> roast: review: https://github.com/perl6/roast/commit/fa2663852b

[21:41] <dalek> roast: eb460a3 | (Brent Laabs)++ | S (4 files):

[21:41] <dalek> roast: Merge branch 'master' of github.com:perl6/roast

[21:41] <dalek> roast: review: https://github.com/perl6/roast/commit/eb460a31c4

[21:41] <huf> jesus christ that city is huge.

[21:42] <TimToady> it's a space startion

[21:42] *** raiph joined
[21:43] <masak> it's a trap!

[21:45] <diakopter> it was a dark and starmy night, the starving dog typed starkly

[21:45] <labster> can someone give me access to close tickets on RT?

[21:45] *** iSlug joined
[21:46] <labster> .oO (it was a dark and swarthy night)

[21:48] <diakopter> TimToady: I thought .mn was Minnesota

[21:48] *** pmurias left
[21:50] * diakopter stares at Van Gogh's Night

[21:50] *** ajr_ left
[21:51] * jnthn blug: http://6guts.wordpress.com/2013/07/02/rakudo-on-jvm-progress-update/

[21:51] <masak> jnthn++

[21:51] <timotimo> yay

[21:51] <masak> who has access to give labster more RT privs?

[21:51] <diakopter> afaik, [Coke]

[21:51] <masak> pmichaud?

[21:51] <masak> oh, ok.

[21:54] <masak> ooh, two blog posts for the price of one! :D

[21:58] <jnthn> ;)

[21:58] <labster> jnthn++ for both

[22:02] <TimToady> nr: class NewNil is Mu { }; multi infix:<===>(Mu \a, NewNil \b) { a.WHAT =:= NewNil }; say 42 === NewNil; say NewNil === NewNil; my $x = NewNil; say $x === NewNil;

[22:02] <camelia> niecza v24-86-g39ab531: OUTPUT«False␤True␤True␤»

[22:02] <camelia> ..rakudo c96b21: OUTPUT«Nominal type check failed for parameter ''; expected Any but got NewNil instead␤  in sub infix:<===> at src/gen/CORE.setting:2041␤  in block  at /tmp/PnvhBvO7YI:1␤␤»

[22:03] <TimToady> seems like we might be able to define === for some things outside of Any

[22:03] <TimToady> not sure what is bothering rakudo there though...

[22:04] <jnthn> Maybe the proto is restrictiver than you want for that.

[22:04] <TimToady> hmm

[22:04] <jnthn> proto sub infix:<eqv>(Any $?, Any $?) { * }

[22:04] *** vk left
[22:04] <jnthn> So, not a bug in the dispatcher. Phew. :)

[22:06] <TimToady> huh, I don't even see a proto in niecza for ===, so maybe that's how it's getting Mu,Mu

[22:07] <jnthn> I guess the default proto is (|) :)

[22:07] <jnthn> oh, but that doesn't work for arity things...

[22:07] <jnthn> So, no idea... :)

[22:07] <jnthn> n: say &infix:<===>.arity

[22:07] <camelia> niecza v24-86-g39ab531: OUTPUT«2␤»

[22:07] <jnthn> n: say &infix:<===>.count

[22:07] <camelia> niecza v24-86-g39ab531: OUTPUT«2␤»

[22:07] <jnthn> Hm. :)

[22:07] <jnthn> Must have one somewhere...

[22:09] <TimToady> anyway, as long as Mu doesn't have a multi candidate, it should behave the same, triggering junctional logic

[22:09] * colomon has working gcc again!  o/

[22:09] <jnthn> Yes, true.

[22:09] <TimToady> so Any,Any is probably overspecified

[22:09] <jnthn> We can relax it.

[22:09] <TimToady> and preventing us from writing === Nil with Nil outside Any

[22:10] <jnthn> It just means it'll auto-thread over a failed multi-dispatch rather than a failed proto-dispatch.

[22:10] *** iSlug left
[22:10] <jnthn> (where a proto-dispatch is really just a single dispatch, nothing special)

[22:10] *** lue left
[22:11] <TimToady> well, you have to handle that anyway if you're gonna inline the proto, seems

[22:12] <jnthn> The optimizer considers the proto before considering the candidates, iirc

[22:12] <jnthn> r: proto foo($) { * }; multi foo($a) { }; multi foo($a, $b) { }; foo(1, 2)

[22:12] <camelia> rakudo c96b21: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling proto of 'foo' will never work with argument types (Int, Int) (lines 1, 1)␤    Expected: :()␤»

[22:12] <jnthn> um, that expected is a bit off :S

[22:13] <jnthn> But it does say the proto is the problem. :)

[22:13] <jnthn> Todo: whine at compile time about multi candidates that could never be reached thanks to the proto. :)

[22:15] <TimToady> nr: class NewNil is Mu { }; multi infix:<===>(Mu \a, NewNil \b) { a.WHAT =:= NewNil }; say so 42 === 41 | NewNil | 42; say so NewNil = 41 | NewNil | 42;

[22:15] <camelia> rakudo c96b21: OUTPUT«Nominal type check failed for parameter ''; expected Any but got NewNil instead␤  in sub infix:<===> at src/gen/CORE.setting:2041␤  in block  at /tmp/LSxR2m10yb:1␤␤»

[22:15] <camelia> ..niecza v24-86-g39ab531: OUTPUT«True␤Unhandled exception: Writing to readonly scalar␤  at /tmp/DDyAHFdRax line 1 (mainline @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4579 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4580 (module-CORE @ 576) ␤  at /home/p6eval/nie…

[22:15] <TimToady> hmm

[22:16] <TimToady> n: class NewNil is Mu { }; multi infix:<===>(Mu \a, NewNil \b) { a.WHAT =:= NewNil }; say so NewNil == 41 | NewNil | 42;

[22:16] <camelia> niecza v24-86-g39ab531: OUTPUT«Potential difficulties:␤  &infix:<===> is declared but not used at /tmp/nGqhQB0JyI line 1:␤------> lass NewNil is Mu { }; multi infix:<===>⏏(Mu \a, NewNil \b) { a.WHAT =:= NewNil }␤␤Unhandled exception: Nominal type check failed for #0 n…

[22:16] <TimToady> n: class NewNil is Mu { }; multi infix:<===>(Mu \a, NewNil \b) { a.WHAT =:= NewNil }; say so NewNil === 41 | NewNil | 42;

[22:16] <camelia> niecza v24-86-g39ab531: OUTPUT«True␤»

[22:16] <TimToady> there we go

[22:17] *** notjack left
[22:17] <TimToady> I think we can make === Nil work

[22:18] <jnthn> Same

[22:20] <TimToady> === Mu is still a bit problematic, unless the junction failover can be triggered by Mu,Mu calling nextsame

[22:21] <TimToady> well, I suppose the Mu,Mu case could call directly into the autothreader if it wanted to

[22:23] <raiph> .ask sorear is niecza's gather/take batched, or 100% lazy?

[22:23] <yoleaux> raiph: I'll pass your message to sorear.

[22:24] *** lue joined
[22:24] *** Timbus left
[22:24] <raiph> hi TimToady. Do you know the answer to what I just asked sorear?

[22:26] *** Timbus joined
[22:27] <TimToady> I suspect it's all lazy, but have no proof

[22:29] <TimToady> otoh, if it were completely lazy, I'd expect recursive constant definitions to work, and they don't, at least not good enough for hamming numbers

[22:30] * masak .oO( hamming with faint praise )

[22:31] <raiph> I see batching as a pragmatic enhancement of P6's laziness capabilities, not a compromise or reflection of some problem in P6's laziness design. Any comments?

[22:31] <TimToady> n: constant @a = 1,2,3, @a.map(*+4); say @a[10]

[22:31] <camelia> niecza v24-86-g39ab531: OUTPUT«(Any)␤»

[22:31] <TimToady> should be 11, not Any

[22:31] <masak> raiph: I sometimes perceive it as a problem.

[22:31] <masak> raiph: mostly when I want the guarantee of laziness.

[22:31] <masak> that is, a batching number of 0.

[22:32] <TimToady> well, 1, depending on how you count

[22:32] <masak> yeah.

[22:33] <TimToady> n: constant @a = 1,2,3, @a.map(*+4); say @a[^10]

[22:33] <camelia> niecza v24-86-g39ab531: OUTPUT«1 2 3  (Any) (Any) (Any) (Any) (Any) (Any)␤»

[22:34] <TimToady> somehow it loses track of @a as a concept, and gets stuck on @a the concrete array we have so far

[22:34] <masak> maybe too little binding, too much assignment?

[22:34] <TimToady> the = on constant is binding

[22:34] <TimToady> or defining, anyway

[22:35] <TimToady> r: my @a; @a.plan: 1,2,3, @a.map(*+4); say @a[^10]

[22:35] <camelia> rakudo c96b21: OUTPUT«No such method 'plan' for invocant of type 'Array'␤  in block  at /tmp/Vt5VeuZknb:1␤␤»

[22:35] <TimToady> hmm, I though rakudo had .plan already

[22:36] <masak> I thought so too.

[22:37] <masak> yes, I know the '=' on constant is binding. just thinking maybe Niecza gets it wrong there.

[22:38] <TimToady> anyhoo, not sure that's evidence against strict laziness

[22:38] *** lizmat joined
[22:39] <TimToady> The hard part of knowing when you know comes down to knowing when you don't know.

[22:40] <lizmat> back from Amsterdam.pm meeting

[22:40] <yoleaux> 14:56Z <TimToady> lizmat: If we put Nil outside of Any, we probably need a .is-nill primitive, or some way of training people to use =:= when they try to use ===

[22:40] <yoleaux> 16:39Z <TimToady> lizmat: A STD.pm6 commit message of "Same change as in rakudo" is not very informative when I do 'git log' :P

[22:40] <yoleaux> 20:02Z <TimToady> lizmat: The biggest practical difference between Mu and Nil is that Mu.ACCEPTS($x) is always true, and Nil.ACCEPTS($x) is always false

[22:41] <lizmat> TimToady: good point, seemed like something sensible at the time, clearly lacking in content looking at it now

[22:42] <TimToady> turns out === Nil can probably be made to work anyway

[22:44] <masak> 'night, #perl6

[22:44] <TimToady> I made a prototype NewNil work in niecza, and we probably just need to generalize the proto infix:<===> in rakudo from Any,Any to Mu,Mu to allow definitions of === from outside of Any

[22:44] <lizmat> so, Nil in combination with "is default", should this work" sub n { Nil }; my $a is default(fail "No go"); $a=n

[22:45] <lizmat> I guess === falling out of Junction, would not be a problem ?

[22:45] <TimToady> doesn't need to be in Junction either

[22:46] <TimToady> we have not defined the ability to pass a thunk or closure as default, so that would fail at compile time currently

[22:46] <TimToady> since a trait's arg is evaluated at BEGIN time, basically

[22:47] <TimToady> not sure what it would mean to supply a closure as a default; when would we call it?

[22:48] <lizmat> but the idea, of putting a Failure object as a default for a scalar, would that make sense?

[22:48] <TimToady> but anyway, yes, a returned Nil is still a Nil, and would still set the default when assigned

[22:48] <lizmat> Specifically when receiving a value from a sub, or from a regex

[22:49] <TimToady> note though that --> Any would preclude returning Nil if we put it outside of Any

[22:49] <lizmat> true

[22:49] <lizmat> well

[22:49] <lizmat> hmmm...

[22:50] <TimToady> so --> Int:D becomes a strong guarantee of a real value being returned

[22:50] <TimToady> is the latest thinking

[22:50] <lizmat> and so BOOM if Nil is returned

[22:50] *** konundra joined
[22:50] <TimToady> which means the only way such a routine can signal error is by throwing an exception

[22:50] *** dmol joined
[22:50] <TimToady> and fail would through an exception, presuming Failure is outside of Int

[22:50] <TimToady> *throw

[22:51] <lizmat> so either it throws an exception itself, or it gets thrown an exception upon return

[22:51] <TimToady> we might end up putting Failure outside of Any, alongside Nil

[22:51] <TimToady> (this was in the original OKness proposal, btw)

[22:51] <lizmat> this is lacking from my memory, can I look that up somewhere?

[22:52] <TimToady> as soon as it typechecks against Int, it'd throw

[22:52] <lizmat> indeed

[22:52] <lizmat> my Int $a is default(42)=Nil

[22:53] <lizmat> would still set $a to 42 or not?

[22:53] <raiph> masak, TimToady: do you think it likely that rakudo will one day support both strictly lazy (batch=1) and mostly lazy?

[22:53] <TimToady> well, it would already be set to 42 by the 'is default', so the = Nil is kinda redundant

[22:54] <lizmat> true, I guess the example is contrived

[22:54] <TimToady> my Int $a is default(42); already implies setting to Nil, in a sense

[22:54] <lizmat> my Int $a is default(42); $a=23; $a=Nil

[22:54] <TimToady> yes, that'd set it to 42

[22:55] <TimToady> it actually helps to have Nil outside of most types, so you can just check on the type failure of ordinary assignment

[22:55] <TimToady> but you and jnthn were discussing that earlier already

[22:55] *** dmol left
[22:55] <lizmat> indeed, because currently

[22:55] <lizmat> my $a is default(42); $a=23; $a=Nil 

[22:56] <lizmat> would *not* fire up the typecheck

[22:56] <TimToady> because the default constraint is Mu currently

[22:56] <TimToady> the .of type, I mean

[22:56] <lizmat> yup

[22:57] <TimToady> there was always some feeling that we should make that Any as well, so that you couldn't accidentally store junctions

[22:57] <TimToady> maybe this is an additional argument for that

[22:58] <lizmat> r: my Any $a=Nil; say $a # no typecheck, so Nil just gets stored

[22:58] <camelia> rakudo c96b21: OUTPUT«Nil␤»

[22:58] <lizmat> r: my Cool $a=Nil; say $a # typecheck, so Nil just gets (wrongly) replaced by default

[22:58] <camelia> rakudo c96b21: OUTPUT«Nil␤»

[22:58] <TimToady> beause Nil is currently in Any

[22:58] <lizmat> r: my Int $a=Nil; say $a # typecheck, so Nil just gets (wrongly) replaced by default

[22:58] <camelia> rakudo c96b21: OUTPUT«No such method 'gist' for invocant of type 'NQPMu'␤  in sub say at src/gen/CORE.setting:11365␤  in block  at /tmp/QwnYfjAwbt:1␤␤»

[22:59] <TimToady> r: class NewNil is Mu {}; my Any $x = NewNil;

[22:59] <camelia> rakudo c96b21: OUTPUT«Nominal type check failed for parameter '$got'; expected Any but got NewNil instead␤  in block  at /tmp/WLku4zjaqe:1␤␤»

[22:59] <TimToady> it would work more like that

[22:59] <lizmat> yup

[23:00] <lizmat> when I'm awake tomorrow, I'll just do that with Nil and see what happens

[23:00] <TimToady> well, the default default of my Int $a would be Int as well, I presume

[23:00] <lizmat> yes, the type Int

[23:00] <TimToady> see earlier discussion about how to add an === operator outside of Any

[23:01] <TimToady> proto infix:<===>(Any,Any) also needs to change to (Mu,Mu)

[23:01] <lizmat> will look at backlog later… pretty tired now… 2 hour drive, not a lot, but enough to stop the brane functions

[23:01] * TimToady understands perfectly :)

[23:02] <lizmat> any thoughts on S11 ?   

[23:02] <TimToady> not yet

[23:02] * lizmat runs away :-)

[23:02] *** Radvendii joined
[23:02] <lizmat> let me know if I should clarify things more

[23:03] <lizmat> I guess the basic questions are:

[23:03] <lizmat> 1. is the compunit the base of use, or is a package?

[23:03] <lizmat> 2. if 1 is compunit, is it a good idea to get meat-info from pos

[23:03] <lizmat> pod

[23:04] <lizmat> meta

[23:04] <lizmat> I'm tried, I should stop

[23:04] <lizmat> tired

[23:04] <lizmat> :-)    sleep&

[23:05] <jnthn> meat-info! :D

[23:05] <jnthn> 'night lizmat 

[23:05] <labster> good work, good night lizmat

[23:08] <flussence> github's added binary downloads back, if anyone cares. The only catch is they now have to be associated with a tag

[23:08] *** skids joined
[23:11] <raiph> jnthn: thx for previous answers. my last two: is rakudo's gather/take lazy? and do you think it likely batching will be implemented this year on at least one backend?

[23:13] <timotimo> rakudo's gather/take is totally lazy

[23:14] <jnthn> raiph: It's lazy, don't know about batching. I'm not personally likely to work on it, since gather/take isn't an area I've been much involved with so far, and others know/understand it better. :)

[23:15] <jnthn> And I don't like making time estimates on behalf of others :P

[23:16] <btyler> jnthn: I really enjoyed reading the first part of the interview, looking forward to the rest!

[23:17] <timotimo> did y'all see "github releases"? that seems neat

[23:18] <jnthn> btyler: Happy it was interesting :)

[23:18] <timotimo> i agree about the interestingity

[23:20] <raiph> jnthn++ # answeringity

[23:23] <jnthn> unconciousity &

[23:31] *** Radvendii left
[23:43] *** Radvendii joined
