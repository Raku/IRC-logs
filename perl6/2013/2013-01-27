[00:08] *** For-Odin joined
[00:14] *** For-Odin left
[00:15] *** balders_dod joined
[00:17] <swarley> So

[00:17] <swarley> 􏿽xBB

[00:17] <swarley> Is that supposed to be a guillete?

[00:17] <swarley> Or >>?

[00:17] <TimToady> » is the real one, and >> is the "Texas" version

[00:17] <swarley> So, you can use >>?

[00:18] <colomon> yes

[00:18] <swarley> Because 􏿽xBB is rendered oddly in gVim for me

[00:18] <TimToady> maybe your vim isn't understanding UTF-8 properly

[00:18] <swarley> Well, the character appears correctly

[00:18] <swarley> But it's position is very low

[00:19] <TimToady> maybe you need a better font then...

[00:19] <TimToady> or just move to Texas

[00:20] <swarley> Ah there, i switched fonts and it's fine

[00:20] <TimToady> \o/

[00:20] <swarley> I just need to figure out how to map a key to that character now though

[00:21] <TimToady> in vim, ^K>> works

[00:21] <swarley> Oh, cool.

[00:21] * lue recommends Compose key in linux

[00:21] <TimToady> yes, that also works more widely

[00:21] * colomon set up his TextMate to do it for >>[tab]

[00:22] <TimToady> .oO(That's the wonderful thing about standards, there's so many of them to choose from...)

[00:24] <timotimo> i'm wondering what to do before i can allow myself to pullrequest

[00:24] <timotimo> i guess i'll just use a pull request to ask for comments?

[00:25] <TimToady> or under Gnome you can say CTRL+SHIFT+u BB

[00:40] <jnthn> evening o/

[00:50] <timotimo> https://github.com/rakudo/rakudo/pull/101 - i made a pull request with some thoughts as a request for comments

[00:54] <jnthn> timotimo: Thanks, I'll review it once I've had to rest :)

[00:54] <jnthn> s/to/some

[00:55] <jnthn> timotimo: 1s in the spectest is noise

[00:55] <timotimo> oh, wait

[00:55] <timotimo> i'm not sure if the spectests are run with optimize=3, i think not!

[00:55] <jnthn> The improvement seems good :)

[00:55] <timotimo> i should re-run, definitely.

[00:55] <jnthn> No, they are 2 by default

[00:55] <masak> good evening, #perl6 ;)

[00:56] <colomon> \o

[00:56] <jnthn> timotimo: Does it regress any spectests, ooc?

[00:56] *** japhb_ joined
[00:56] <timotimo> if disabled, no

[00:56] <timotimo> don't know for sure how to turn the optimization up to 3 for the spectests :|

[00:57] <timotimo> is there an easy way?

[00:57] <timotimo> would like to not have to re-compile rakudo for it

[00:57] <timotimo> but i can totally do it. it's fast on that box

[00:57] <timotimo> yeah, i'll just do it

[00:59] <jnthn> Well, make it a #2 :)

[01:00] <timotimo> done just that

[01:00] <jnthn> Or diddle the harness, I guess

[01:00] <timotimo> and now i'll wait about 1100 seconds (and not in binary)

[01:03] * colomon has written many bits of code which work perfectly when not used.

[01:05] <timotimo> :)

[01:08] <timotimo> S05...

[01:10] <masak> 'night, #perl6

[01:10] <colomon> o/

[01:11] <timotimo> night masak!

[01:12] <timotimo> S16...

[01:14] <timotimo> the dreaded socket io net spectest

[01:16] <swarley> Just making sure before I venture further with a messed up based, there is nothing outstandingly incorrect here is there? http://pastebin.com/njuiSUqU

[01:19] *** xinming_ joined
[01:19] *** raiph left
[01:19] <timotimo> Files=722, Tests=26726, 1109 wallclock secs ( 4.41 usr  1.05 sys + 877.37 cusr 76.03 csys = 958.86 CPU  -  if that's not just due to some weird coincidence, that's really quite an improvement!

[01:19] <timotimo> where did it come from?!

[01:20] <timotimo> oh, hold on, the wallclock seconds are actually 10 seconds more :(

[01:20] <timotimo> so, 1% longer

[01:21] <jnthn> timotimo: The optimizer is most likely to have very little effect on spectest, fwiw.

[01:21] <jnthn> timotimo: The spectests are generally long lists of things to try with no looping.

[01:21] <jnthn> timotimo: Whereas the place the optimizations can help most is by making repeated actions faster.

[01:22] *** xinming left
[01:22] <timotimo> yeah

[01:23] * timotimo runs four spectests, two on his branch, two on nom, and looks at how good it works

[01:23] <timotimo> bbl

[01:36] <jnthn> sleep, 'night &

[01:38] *** hash_table joined
[01:39] <timotimo> the tension is almost unbearable

[01:39] <timotimo> but it is barely humanable

[01:39] <timotimo> so i will be all right

[01:51] *** lue left
[02:02] *** aindilis joined
[02:03] <timotimo> assuming i didn't do a silly mistake again, the optimizer enhancement seems to have had 0 effect on the spectest suite.

[02:08] *** inverse left
[02:10] <timotimo> jnthn: fwiw, i have a test suite to check that my junction unfolding doesn't break things, and it gets a reduction in run time by 40%, too, even if i remove all the loopy code from it

[02:10] <timotimo> but it's (of course) very junction heavy

[02:12] *** raiph joined
[02:13] *** [particle]1 left
[02:14] *** [particle] joined
[02:18] *** xinming_ left
[02:20] *** raiph left
[02:24] *** xinming joined
[02:29] <swarley> r: say "hello" ~~ /<+. - < h e l l o >>/

[02:29] <p6eval> rakudo c356d8: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unrecognized regex metacharacter < (must be quoted to match literally)␤at /tmp/EdrVfFYZbW:1␤------> [32msay "hello" ~~ /<+[33m⏏[31m. - < h e l l o >>/[0m␤Unrecognized regex metacharacter + (must be quoted to match literally)␤at /t…

[02:29] <swarley> oh

[02:29] <swarley> duh

[02:30] <timotimo> i know some of these characters!

[02:30] <swarley> Should I define keywords as terms?

[02:30] <swarley> token term:<while> { <sym> ... }

[02:31] <swarley> hm, it appears not

[02:31] <timotimo> i only know than in python a term is a bigger expression than just a keyword (and while does not constitute part of a term)

[02:38] *** benabik joined
[02:41] <timotimo> r: sub infix:<,>($a, $b) { say "whoa"; ($a, $b) }; any(1, 2);

[02:41] <p6eval> rakudo c356d8:  ( no output )

[02:41] <timotimo> r: sub infix:<,>($a, $b) { say "whoa"; ($a, $b) }; say(1, 2);

[02:41] <p6eval> rakudo c356d8: OUTPUT«12␤»

[02:41] <timotimo> r: sub infix:<,>($a, $b) { say "whoa"; ($a, $b) }; say (1, 2);

[02:42] <timotimo> oh, dur, recursion warning

[02:42] <p6eval> rakudo c356d8: OUTPUT«(timeout)whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤whoa␤w…

[02:45] *** FROGGS_ joined
[02:45] <swarley> Now, before I go and do something crazy. You guys said I should use NQP instead of the PCT right?

[02:46] <timotimo> yeah, nqp is nice to have. haven't looked at PCT at all, though

[02:47] <colomon> if you asked the parrot guys, they might well say PCT.

[02:47] * colomon doesn't know, and hasn't talked much to parrot guys in the last 18 months.

[02:47] <swarley> But, I heard something earlier about parrot being deprecated, what's the replacement?

[02:48] <swarley> [17:09:15] <timotimo> swarley: yeah, parrot is being deprecated

[02:48] <swarley> Good old /grep

[02:48] *** FROGGS left
[02:53] <timotimo> oh, no, that was not completely serious

[02:53] <timotimo> currently, there's work going on to make nqp cross-compile to JVM and java script. after that, nqp can self-host on jvm and java script.

[02:53] <timotimo> (and rakudo can be run as a jar file or as a java script thingie)

[02:54] <swarley> oh nifty.

[02:55] <swarley> Does NQP currently compile down to pbc?

[02:55] <timotimo> er, it does compile down to pir, i know that much

[02:55] *** colomon left
[02:55] <timotimo> │/home/timo/build/rakudo/install/bin/parrot  -o CORE.setting.pbc src/gen/CORE.setting.pir  -  so yes

[02:55] *** colomon joined
[02:57] <timotimo> i think my pull request #101 is pretty nice. this is a workflow i should try more often.

[02:57] <timotimo> okay, 4am is definitely "should be restin'" territory

[02:57] <timotimo> swarley: i wish you the best of luck! :)

[02:58] <swarley> Thank you, sleep well

[03:01] *** raiph joined
[03:12] *** hash_table left
[03:15] *** arlinius left
[03:22] *** rummik joined
[03:27] *** rummik left
[03:27] *** rummik joined
[03:27] *** rummik left
[03:27] *** rummik joined
[03:27] *** rummik left
[03:29] *** rummik- joined
[03:33] *** rummik- left
[03:38] *** balders_1od joined
[03:41] *** balders_dod left
[03:41] *** s1n left
[04:15] *** Targen joined
[04:16] *** preflex_ joined
[04:17] *** preflex left
[04:17] *** preflex_ is now known as preflex

[04:19] *** b1rkh0ff left
[04:19] *** b1rkh0ff joined
[04:42] *** arlinius joined
[04:56] *** daniel-s_ joined
[05:00] *** daniel-s left
[05:07] *** FROGGS_ left
[05:08] *** FROGGS_ joined
[05:16] *** kaare_ joined
[05:42] *** MikeFair left
[06:10] *** kaare_ left
[06:15] *** SunilJoshi joined
[06:31] *** SunilJoshi left
[06:31] *** MikeFair joined
[06:36] *** quester joined
[06:39] *** Chillance left
[06:39] *** Targen left
[06:40] *** xinming left
[06:41] *** xinming joined
[06:55] *** Targen joined
[07:39] *** [particle]1 joined
[07:42] *** [particle] left
[07:43] *** vividsnow joined
[07:48] *** balders_1od left
[07:54] *** vividsnow left
[07:58] *** araujo left
[07:58] *** araujo joined
[08:17] *** vividsnow joined
[08:39] *** SunilJoshi joined
[08:43] *** kaare_ joined
[08:45] *** FROGGS_ is now known as FROGGS

[08:51] <FROGGS> moritz: morning, how do I invoke the QAST dumper again? can I do this from within perl? like on a given regex

[09:02] <moritz> FROGGS: ./perl6 --target=past

[09:04] *** quester left
[09:06] <FROGGS> ohh, cool!

[09:08] <FROGGS> moritz: thanks

[09:44] *** Psyche^ joined
[09:47] *** Patterner left
[09:47] *** Psyche^ is now known as Patterner

[10:04] <masak> good forenoon, #perl6

[10:07] *** PacoAir joined
[10:12] <FROGGS> hi masak 

[10:12] <sorear> o/ FROGGS, masak 

[10:25] *** grondilu joined
[10:26] * grondilu had a segmentation fault during last compilation attempt.

[10:26] <grondilu> ^ compilation of rakudo, that is.

[10:29] * grondilu is currently trying again

[10:33] <grondilu> it worked this time, I guess it's because I had too many other processes running.

[10:47] <jnthn> o/ all

[10:51] *** spider-mario joined
[10:56] <FROGGS> sorear o/, grondilu o/, jnthn o/

[11:03] <grondilu> \o

[11:06] *** Su-Shee_ joined
[11:07] *** SamuraiJack joined
[11:10] *** Su-Shee left
[11:10] *** Su-Shee_ is now known as Su-Shee

[11:18] <nwc10> jnthn: good curry?

[11:18] <jnthn> nwc10: Yes, good and spicy :)

[11:21] <jnthn> Then good beer afterwards

[11:21] <jnthn> Including a stout called "else if" :P

[11:21] <nwc10> good job you're in Sweden, not Denmark :-)

[11:22] * jnthn ponders getting module loading working

[11:33] *** MayDaniel joined
[11:33] <arnsholt> o/

[11:34] <jnthn> hi arnsholt 

[11:35] <timotimo> mornin'

[11:42] *** SunilJoshi left
[11:46] <arnsholt> Wat?

[11:47] <arnsholt> Apparently weird things happen if I try to set the storage_spec properly in P6int.c

[11:47] <jnthn> "properly"?

[11:47] <arnsholt> Well, fetching the info from the REPR data I've attached, rather than the hardcoded sizeof(INTVAL)*8

[11:48] <jnthn> Mebbe that P6opaque doesn't cope with alignment issues yet.

[11:48] <arnsholt> Could be

[11:48] <timotimo> looking for suggestions what to do with my junction-opt branch next :)

[11:58] <arnsholt> This is weird. If I have one bit of code that sets spec.bits to 64, it segfaults, if I have another one, it seems to work

[11:59] *** Targen left
[11:59] <timotimo> maybe the one bit is executed too late and there's a discrepancy between the bits value at different points in the program?

[12:00] <arnsholt> Don't think so. I printf the value in the function =)

[12:01] * timotimo could only really guess wildly

[12:01] <arnsholt> But for some reason the REPR data is zeroed out, even though it shouldn't be

[12:01] <arnsholt> I think that's related to it

[12:02] <jnthn> arnsholt: You're not ending up on the other side of a pre-comp boundary, are you?

[12:02] <timotimo> jnthn: i was trying to find the gist where you created the optimisation transformation testbed, but it seems it got deleted? i wanted to star or fork it so that you were credited properly

[12:02] <jnthn> arnsholt: repr data must be explicitly serialized

[12:03] <arnsholt> Oh, of course!

[12:03] <jnthn> timotimo: hm, not even sure which gist you mean ;)

[12:03] <arnsholt> I've just added the stuff to the REPR data, so the P6int in the bootstrappy parts doesn't have it

[12:03] <jnthn> argh argh argh HLL::Compiler specializes on --target=nqp all over...

[12:03] <jnthn> *--target=pir even

[12:04] <timotimo> jnthn: i would give you the link, but ... ;)

[12:04] <timotimo> oh, wait, irclog!

[12:05] <timotimo> https://gist.github.com/4348324 - anonymous gist, i see!

[12:08] <jnthn> oh, that :)

[12:10] <timotimo> phenny: tell hoelzro: do you feel like you can open a pull request for your pygments work soon? or do you want more testing to be done first?

[12:10] <phenny> timotimo: I'll pass that on when hoelzro is around.

[12:13] <timotimo> is there a way to step into the perl6 grammar with the rakudo debugger or the grammar tracer to see what's going on in special cases?

[12:13] <timotimo> i might tackle the missing "null regex" error messages if i could see wth is going on :D

[12:14] <jnthn> No, it doesn't do that...problem being that the debugger works partly by subclassing Perl6::Grammar

[12:14] <timotimo> oh, haha :)

[12:14] <timotimo> and copypasting the prel6 grammar into a .p6 file won't work either, because the actions are nqp?

[12:15] <jnthn> Right

[12:16] <jnthn> And also it depends on Perl6::World

[12:16] <arnsholt> jnthn: Is there something special I have to do to add REPR data to a REPR that didn't previously have that?

[12:16] <arnsholt> (I imagine using new deserialize logic for old data in the bootstrap stuff is going to explode in fun and interesting ways)

[12:16] <jnthn> arnsholt: Aside from just hanging your REPR data off the approriate STable hook?

[12:17] <jnthn> Oh

[12:17] <jnthn> Yeah, you need to implement serialize/deserialize REPR data functions

[12:17] <jnthn> Also since it's a back-incompat change you'll need to look at bumping the serialization format version and then only reading it if the current version is high enough.

[12:18] <arnsholt> Hmm.

[12:19] <jnthn> I won't pretend it's much fun, but it shouldn't be too hard.

[12:19] <jnthn> Reason you need to support both ways for a bit is due to the bootstrapping nature of things.

[12:19] <arnsholt> Yeah, that makes sense

[12:20] <arnsholt> Where does the serialization format numbering stuff live?

[12:20] <jnthn> src/6model/serialization.c, but I've not had to do a back-incompat change before :)

[12:20] <jnthn> But it keeps the current version number in the reader/writer objects.

[12:20] <jnthn> Most of the infrastructure you need should be there.

[12:21] <jnthn> Just need to have a MIN_READABLE and MAX_READABLE or so and on deserialization do a check for being in range rather than exact version number.

[12:21] <arnsholt> Excellent. I've got to do some laundry now, but I'm gonna give it a whack once that's done

[12:22] <timotimo> phenny: tell hoelzro: the only issues i can see with it are: @!foo has a red, fat ! and +@($block) has a red, fat ($ in it, so everything that looks remotely like a twigil (thrigil?) seems to get that treatment

[12:22] <phenny> timotimo: I'll pass that on when hoelzro is around.

[12:26] <dalek> nqp: 8658578 | jnthn++ | src/HLL/Compiler.pm:

[12:26] <dalek> nqp: Make --target=pir a little less special.

[12:26] <dalek> nqp: 

[12:26] <dalek> nqp: Whole thing needs a good bit of reviewing, though.

[12:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8658578e46

[12:27] *** SunilJoshi joined
[12:27] <dalek> nqp-jvm-prep: 6860de4 | jnthn++ | / (4 files):

[12:27] <dalek> nqp-jvm-prep: Start to prepare cross-compiler for libraries.

[12:27] <dalek> nqp-jvm-prep: 

[12:27] <dalek> nqp-jvm-prep: Previously, we always created a Java class file with the same name.

[12:27] <dalek> nqp-jvm-prep: This generates unique names, but provides a way to get control over it

[12:27] <dalek> nqp-jvm-prep: when compiling so you can get something that can be started directly

[12:27] <dalek> nqp-jvm-prep: by invoking the JVM with that class name also.

[12:27] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/6860de438d

[12:27] <jnthn> Whee... https://gist.github.com/4648146

[12:28] <timotimo> ooooh

[12:34] *** mr- joined
[12:50] <nwc10> oooh.

[12:50] <nwc10> how verbose is the Java equivalent? :-)

[12:51] <nwc10> jnthn++ # reducing the risk of RSI when programming for the JVM

[12:52] *** sftp left
[12:56] *** sftp joined
[12:59] *** vividsnow left
[13:08] <dalek> nqp-jvm-prep: 59cbf82 | jnthn++ | / (4 files):

[13:08] <dalek> nqp-jvm-prep: Implement nqp::loadbytecode.

[13:08] <dalek> nqp-jvm-prep: 

[13:08] <dalek> nqp-jvm-prep: Loads the class file for compilation unit, triggers deserialization

[13:08] <dalek> nqp-jvm-prep: and runs any load-time code.

[13:08] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/59cbf82e17

[13:08] <dalek> nqp-jvm-prep: a7b6661 | jnthn++ | .gitignore:

[13:08] <dalek> nqp-jvm-prep: Update .gitignore.

[13:08] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a7b6661336

[13:34] <dalek> nqp: ce4d991 | jnthn++ | src/QAST/Operations.nqp:

[13:34] <dalek> nqp: An nqp::loadbytecode.

[13:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ce4d991ed4

[13:34] <dalek> nqp: 8e78004 | jnthn++ | src/stage0/ (9 files):

[13:34] <dalek> nqp: Update bootstrap.

[13:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8e78004ba7

[13:34] <dalek> nqp: bde6231 | jnthn++ | src/ModuleLoader.pm:

[13:34] <dalek> nqp: Use some nqp:: ops in ModuleLoader.

[13:34] <dalek> nqp: 

[13:34] <dalek> nqp: Some bits of it will want to be backend-specific, but may as well make

[13:34] <dalek> nqp: the rest easier to share.

[13:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bde6231e0d

[13:34] <dalek> nqp: 35db357 | jnthn++ | src/NQP/World.pm:

[13:34] <dalek> nqp: Update NQP::World to use more nqp:: ops.

[13:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/35db357a9f

[13:49] *** SunilJoshi left
[13:54] *** clkao joined
[14:07] *** MikeFair___ joined
[14:07] *** MikeFair left
[14:13] <arnsholt> jnthn: src/6model/serialization.c dies if the serialization version is != to the one in the code. Should that be > perhaps?

[14:15] <jnthn> arnsholt: No, as I said, we should introduce #defines for a min and max and check if it lies between the two.

[14:15] <arnsholt> Oh, right, right!

[14:15] <jnthn> arnsholt: We don't need to support every way we ever serialized, I think :)

[14:16] <arnsholt> I misparsed it as version checks in the {,de}serialize_repr_data functions affected (which we need as well)

[14:16] <jnthn> ah, ok :)

[14:16] <arnsholt> Yeah, I guess we can ditch some of them eventually

[14:16] *** pmurias joined
[14:20] <pmurias> jnthn: wouldn't an exact version check be better? Unless you want to have a complex scheme to check all the valid combinations?

[14:21] <arnsholt> Right now I've made it die if version is smaller than MIN_VERSION or larger than CURRENT_VERSION

[14:21] <jnthn> pmurias: We have to support a couple of versions at a given time thanks to bootstrap.

[14:21] <jnthn> arnsholt: wfm

[14:21] <arnsholt> Might as well die if we get version numbers from the future =)

[14:22] <jnthn> pmurias: To write we always write current verion, it's just as reading issue.

[14:22] <jnthn> arnsholt: yes, good point.

[14:22] <jnthn> *a

[14:23] <arnsholt> Hmm. For some reason my repr_data objects are full of zeroes

[14:23] <arnsholt> Even though they shouldn't

[14:25] <arnsholt> It's compiling src/stage1/gen/nqp-mo.pm, so that's the very first round of compilation, right?

[14:25] <jnthn> yeah

[14:28] * arnsholt adds some more printf()s

[14:29] <timotimo> jnthn: can you review and/or provide guidance for https://github.com/rakudo/rakudo/pull/101 today?

[14:31] <arnsholt> Hmm. deserialize_repr_data is hit once, and creates a repr_data that isn't seen in get_storage_spec

[14:32] <arnsholt> compose and type_object_for aren't hit AFAICT

[14:33] <pmurias> timotimo: maybe put your test into roast?

[14:34] <timotimo> pmurias: can you suggest a category? should they be considered "tests for the optimisation rakudo has" or "tests that junctions work as intended"?

[14:34] <timotimo> depending on that, i may put them into integration/ instead of the S** category where junctions belong

[14:35] <arnsholt> jnthn: So what's actually segfaulting is that decontainerize is passed the pointer 0xfffffffffffffffd from type_check in nqp.ops

[14:35] <arnsholt> But my changes are all to the repr_data stuff in P6int

[14:35] <timotimo> wow, who even has that much RAM? :P

[14:36] <arnsholt> Yeah, I suspect this is NULL minus a couple of bytes =)

[14:36] <pmurias> timotimo: the test mostly tests junctions so I suppose it's a junction test

[14:38] <jnthn> arnsholt: Can I see a diff of your changes? I may be able to spot something

[14:38] <jnthn> timotimo: Yes, will look over it some more. It seemed like a sane direction as much as I looked at it so far.

[14:38] <pmurias> timotimo: it's not really rakudo specific

[14:38] <jnthn> timotimo: doing the any/all case is probably also not so bad

[14:39] <timotimo> jnthn: yeah, but seemed much harder from my point of view

[14:39] <jnthn> timotimo: For the tests - we should have enough junction tests to make sure the optimization doesn't break stuff.

[14:39] <jnthn> timotimo: any(1,2) generates something more complex than 1|2 ?

[14:40] <timotimo> at least a bit more complex

[14:41] <timotimo> it generates a call to infix:<,> at least.

[14:41] <jnthn> Oh?

[14:41] <jnthn> That's...odd. I'd expect it to be a QAST::Op.new( :op('call'), :name('&any'), ... )

[14:41] <timotimo> also, all the junction tests i've seen so far would prevent the optimisation from happening, because it seems to require an if, whereas these tests all have just a boolean context marker before them, i think the optimizer code i have bails out in that case

[14:41] <jnthn> With the args in there.

[14:41] <pmurias> jnthn: after skimming through roast, the one timotimo added also seems a worthy addition

[14:41] <arnsholt> jnthn: https://gist.github.com/4648660 on dyncall-sized-num

[14:42] <timotimo> jnthn: let me quickly check the generated asts.

[14:42] <jnthn> timotimo: OK, then add tests to cover the cases you have.

[14:42] <arnsholt> I've merged in master locally, but don't think any of those changes touch these bits of code

[14:42] <timotimo> oh, huh. i must have missed something.

[14:46] <jnthn> arnsholt: fwiw, writing the align is probably a bad idea as if you write the file on a machine with one alignment and read it on another...

[14:46] <jnthn> I dobut that's the bug though.

[14:46] <arnsholt> Oh, good point

[14:47] <arnsholt> Yeah, that shouldn't be it

[14:47] <jnthn> I'm not immediately seeing what is going wrong.

[14:48] <timotimo> i ought to do more systematic and rigorous tests.

[14:48] <jnthn> The code looks pretty much as I'd have done it...

[14:50] <arnsholt> Dang

[14:53] <timotimo> jnthn: strange, i was certain i had gotten a big explosive error when i activated any/all support in my code due to some strange parcel related something-or-other.

[14:55] *** gaussblurinc joined
[14:57] *** s1n joined
[15:00] <timotimo> what other calls should activate the junction unfolder except prefix:<?>, <!> and <so>?

[15:02] <jnthn> Can't immediately thing of any others

[15:02] <jnthn> oh

[15:02] <jnthn> not

[15:02] <timotimo> excellent

[15:02] <timotimo> had you not put the "oh" in between, it would have been a nice combination of autopun and "not" humor

[15:03] <jnthn> :P

[15:03] <dalek> nqp-jvm-prep: 7fdaa9e | jnthn++ | lib/QAST/JASTCompiler.nqp:

[15:03] <dalek> nqp-jvm-prep: Fix temp allocation thinko.

[15:03] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/7fdaa9e90c

[15:03] <dalek> nqp-jvm-prep: 0965731 | jnthn++ | / (2 files):

[15:03] <dalek> nqp-jvm-prep: Add nqp::ctxlexpad.

[15:03] <dalek> nqp-jvm-prep: 

[15:03] <dalek> nqp-jvm-prep: General lexpad introspection still needs more work though.

[15:03] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/096573145c

[15:03] <dalek> nqp-jvm-prep: 7fbb725 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[15:03] <dalek> nqp-jvm-prep: Don't lose caller in library loading.

[15:03] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/7fbb725d7f

[15:03] <dalek> nqp-jvm-prep: d312240 | jnthn++ | src/org/perl6/nqp/sixmodel/reprs/ContextRefInstance.java:

[15:03] <dalek> nqp-jvm-prep: Implement object lexical lookup through context.

[15:03] <dalek> nqp-jvm-prep: 

[15:03] <dalek> nqp-jvm-prep: Need to do a bunch of other cases, but this is what ModuleLoader needs.

[15:03] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/d3122400ee

[15:03] *** Chillance joined
[15:04] <timotimo> okay, with more junction optimisations, maybe the spectest time will decrease (it's at 6:23 right now)

[15:06] <arnsholt> jnthn: Making the conditional in get_storage_spec if(repr_data && repr_data->bits) seems to fix it

[15:07] <arnsholt> I've no idea how I end up with nulled out repr_data, but at least this seems to do the trick

[15:08] <timotimo> well, the junction tests pass at least. don't know if the optimisation got them, though. gotta check more closely

[15:09] *** awwaiid left
[15:09] <arnsholt> Even passes the NQP tests =D

[15:10] <timotimo> hey, that's excellent! :)

[15:10] <jnthn> Nice :)

[15:13] <timotimo> 6:19 instead of 6:23. is that significant or noise?

[15:13] <timotimo> i don't feel like running the suite four times in a row tbh :)

[15:13] <timotimo> i could just run the junction tests, though

[15:13] <jnthn> Probably noise. But as I said, the spectests are really the worst case for the optimizer.

[15:14] <timotimo> yes, but i *still* got a damned good improvement from no-loop-code

[15:14] <timotimo> and that surprised me bigtime in a positive way

[15:14] <jnthn> :)

[15:16] *** xinming left
[15:16] *** xinming joined
[15:25] <dalek> nqp: 4bfcd13 | jnthn++ | src/NQP/World.pm:

[15:25] <dalek> nqp: Sketch in JVM support for module/setting code-gen.

[15:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4bfcd13737

[15:25] <dalek> nqp: 9ed3bc1 | jnthn++ | src/NQP/ (2 files):

[15:25] <dalek> nqp: Add an option for stable SC handles.

[15:25] <dalek> nqp: 

[15:25] <dalek> nqp: We can't do these in general thanks to the bootstrap, but we need it in

[15:25] <dalek> nqp: order to handle cross-compiling.

[15:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ed3bc1fdd

[15:26] <timotimo> jnthn: my intuition says that if there's junctions on both sides, i should unfold the smaller one, so that there are less junctions in there overall, does that make sense?

[15:27] <jnthn> timotimo: think so, yes

[15:28] <timotimo> since junctions are somewhat slow, they should be used as little as possible, and turning $x & $y == -1|0|1 into $x == -1|0|1 && $y == -1|0|1 "sounds" faster than $x | $y == -1 && $x | $y == 0 && $x | $y == 1 (also this unfolding seems totally wrong)

[15:29] <timotimo> is it just me or is unfolding only the right side not even doable in a sensible way?

[15:31] <dalek> nqp-jvm-prep: 7c09119 | jnthn++ | nqp-jvm-cc.nqp:

[15:31] <dalek> nqp-jvm-prep: Use stable-sc option always.

[15:31] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/7c09119dc8

[15:31] <dalek> nqp-jvm-prep: db4bab9 | jnthn++ | / (3 files):

[15:31] <dalek> nqp-jvm-prep: Start cross-compiling an nqp-mo and ModuleLoader.

[15:31] <dalek> nqp-jvm-prep: 

[15:31] <dalek> nqp-jvm-prep: The nqp-mo is very close to the real NQP one, just with some Parrot

[15:31] <dalek> nqp-jvm-prep: specific bits and mixins (NYI) commented out. ModuleLoader has a few

[15:31] <dalek> nqp-jvm-prep: more bits commented out, but is very close.

[15:31] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/db4bab9be8

[15:31] <jnthn> timotimo: oh, I guess it dpends on the | vs &

[15:32] <jnthn> timotimo: tbh, I'd leave the "junctions on both sides" case for now

[15:32] <jnthn> I think there could be some tricky things there depending on who has the | and who has the &

[15:32] <timotimo> i'll unfold only the left side if it has both and unfold the right side only if the left side has none. sounds good to me at least

[15:32] <jnthn> We're meant to thread one then the other, it's not about the side.

[15:33] <jnthn> So yeah, I'd just go for the "junction on one side" for now. It will cover most of the interesting cases to optimize anyway :)

[15:40] *** cibs left
[15:40] * nwc10 finds junctions crazy and counter-intuitive

[15:41] *** gaussblurinc left
[15:41] *** cibs joined
[15:42] *** LlamaRider joined
[15:43] <LlamaRider> Hi #perl6. Need a panda tip - when I try "panda install Web", it complains HTTP::Daemon is not in the ecosystem. 

[15:43] <LlamaRider> tips to circumvent?

[15:44] <timotimo> LlamaRider: you can git clone the repo for http::daemon and install it with panda locally by giving its path, that ought to help

[15:44] <timotimo> other than that, i think panda knows --no-dependencies or something like that

[15:45] *** spider-mario left
[15:48] <LlamaRider> any clue where that module is? A github search gets a bunch of other http guys, but not http::daemon

[15:50] <timotimo> sorry, no clue :(

[15:51] <timotimo> jnthn: how early should the optimisation code bail out if the level isn't high enough for this particular optimisation?

[15:51] <LlamaRider> I think I will just end up trying HTTP::Easy instead. Thanks for the help anyway!

[15:52] <timotimo> have fun! :)

[15:52] <jnthn> timotimo: The main reason the various other things don't bail out is because the analysis they do can produce "this code will never work" errors.

[15:52] <jnthn> So the analysis without the transformation still does something worthwhile.

[15:53] <jnthn> For yours, I don't think that's the case, so you could just guard the whole thing.

[15:54] *** mr- left
[15:55] <timotimo> ah, ok. i will then

[16:00] *** LlamaRider left
[16:06] *** cog joined
[16:18] *** jtpalmer_ is now known as jtpalmer

[16:19] *** b1rkh0ff left
[16:19] *** b1rkh0ff joined
[16:22] <dalek> nqp-jvm-prep: f391295 | jnthn++ | src/org/perl6/nqp/runtime/LibraryLoader.java:

[16:22] <dalek> nqp-jvm-prep: Don't duplicately load modules.

[16:22] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/f3912956f7

[16:22] <dalek> nqp-jvm-prep: 710ca4d | jnthn++ | / (2 files):

[16:22] <dalek> nqp-jvm-prep: Implement nqp::forceouterctx.

[16:22] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/710ca4d71f

[16:22] <dalek> nqp-jvm-prep: e409dbb | jnthn++ | / (2 files):

[16:22] <dalek> nqp-jvm-prep: Add an almost-empty setting.

[16:22] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/e409dbbd1a

[16:22] <dalek> nqp-jvm-prep: dbf1735 | jnthn++ | src/org/perl6/nqp/runtime/LibraryLoader.java:

[16:22] <dalek> nqp-jvm-prep: Remove leftover debugging code.

[16:22] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/dbf1735c20

[16:22] <dalek> nqp-jvm-prep: cbdf515 | jnthn++ | nqp-jvm-cc.nqp:

[16:22] <dalek> nqp-jvm-prep: Set default setting and --no-regex-lib.

[16:22] <dalek> nqp-jvm-prep: 

[16:22] <dalek> nqp-jvm-prep: Means that it's now possible to just do:

[16:22] <dalek> nqp-jvm-prep: 

[16:22] <dalek> nqp-jvm-prep:     nqp nqp-jvm-cc.nqp -e "say('ok')"

[16:22] <dalek> nqp-jvm-prep: 

[16:22] <dalek> nqp-jvm-prep: And it will load the (currently almost empty) setting (which does also

[16:22] <dalek> nqp-jvm-prep: bring in the MOP).

[16:22] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/cbdf515f2e

[16:22] <timotimo> aaaaw yiss :))

[16:24] <tadzik> ooh

[16:26] *** cog left
[16:29] <arnsholt> jnthn: Changing the nqp::composetype stuff to the new compose protocol. Should I do that in a branch, or is it ok to do straight on master^Wnom?

[16:31] <jnthn> arnsholt: Will need updates in both Rakudo and NQP I guess. Anyway, so long as you land both fairly close in time, straight in nom/master should be fine.

[16:32] * nwc10 is wondering how easy/hard it would be to run a smoker that smokes the NQP bootstrap

[16:32] <nwc10> ie

[16:32] <nwc10> for each checkin on NQP

[16:32] <nwc10> 1) does it pass its own tests as-is

[16:32] <nwc10> 2) if so, can it redo the bootstrap?

[16:32] <nwc10> 3) if so, does it still pass the tests?

[16:32] <nwc10> 4) if so, profit!

[16:33] <nwc10> can travis do that?

[16:33] <arnsholt> jnthn: I'll make a partner branch for Rakudo as well, in that case

[16:33] <jnthn> nwc10: Actually it's probably a bit simpler than that... (more)

[16:33] <arnsholt> In case of unexpected strangeness down the line

[16:34] <jnthn> The NQP build does 3 steps. First, building whatever bootstrap files were checked in from PIR to PBC. Second, building current NQP source with those. Third, using the thing it just build from latest source to build the latest source again.

[16:34] <jnthn> And then make test runs on that final output.

[16:35] <jnthn> So you're always testing the latest NQP compiled by the latest NQP.

[16:35] <nwc10> ah OK? so each build is actually a re-bootstrap?

[16:35] <jnthn> Yeah, all make bootstrap-files does is say "make the current state be the set of pre-compiled output that we ship"

[16:35] <nwc10> aha. that makes a lot of sense

[16:36] <nwc10> it's a manually initiated step saying "this lot are good. I'm not about to paint myself into a corner by using the new ones"

[16:36] *** cog joined
[17:01] *** vividsnow joined
[17:02] <dalek> roast: ef58502 | (Timo Paulssen)++ | S03-junctions/boolean-context.t:

[17:02] <dalek> roast: add a few junction tests relevant to the optimizer

[17:02] <dalek> roast: review: https://github.com/perl6/roast/commit/ef58502713

[17:07] <timotimo> jnthn: if there are no more worries, i'd consider this code ready to be merged. i'll run a spectest again, just to make sure.

[17:11] *** vividsnow left
[17:12] <TimToady> nwc10: if you find junctions crazy and counterintuitive, you must find English crazy and counterintuitive as well, since they're stolen straight out of English :)

[17:14] <nwc10> well, English is already ambiguous in its use of "or", and a double (or triple) negative in colloquial English doesn't mean the same thing as one in more formal English, so, um

[17:14] <nwc10> that might actually be a "Yes, I do find it counterintuitive" :-)

[17:16] <nwc10> oh, and the answer to confirm the hypothesis implied by a question such as "you don't have any cheese?"

[17:16] <TimToady> "Yes, I don't" -- how you'd say it in Japanese

[17:16] <nwc10> not related, but amuses me - "no, not *that* left. The other left!"

[17:17] <nwc10> Japanese++ # logical date orders, logical answers

[17:18] <nwc10> actually, to be clear, it's not *junctions* in isolation. It's how they *combine* that doesn't pan out how I expect

[17:18] <TimToady> well, the regular verb system is the best part; only two irregular verbs (plus compounds of those)

[17:19] <TimToady> well, the left one governs in both English and in Perl

[17:19] <TimToady> if any of these equals all of those  # one of the left has to equal every value on the right

[17:20] <TimToady> if all of these equals any of those  # all the values on the left must equal at least one on the right

[17:20] <jnthn> timotimo: OK, gonna sort out some food now, will have a look after that :)

[17:20] <jnthn> timotimo: Just pull request the latest :)

[17:20] <timotimo> the latest stuff is already in the pullrequest

[17:21] <timotimo> oh, what did i do wrong? forgot to update the plan. as i always do.

[17:22] <dalek> roast: 8b2fc6f | (Timo Paulssen)++ | S03-junctions/boolean-context.t:

[17:22] <dalek> roast: bump up the plan, too.

[17:22] <dalek> roast: review: https://github.com/perl6/roast/commit/8b2fc6f39c

[17:23] <jnthn> timotimo: OK. Shop, then food, then will look :)

[17:23] * jnthn bbl

[17:24] <TimToady> otoh, among those Japanese verb forms, you have to track several levels of politeness, and whether you're being polite to the person you're speaking to, or polite to the person you're speaking about, and the fact that the causative forms tend to have negative connotations, whether active or passive  :)

[17:24] <TimToady> so every natural language has ways to drive you nuts

[17:27] <TimToady> and if you put the wrong honorific on, either too low, or too high, it's an insult (because if you put one too high you're obviously being sarcastic)

[17:28] <timotimo> NQP is supposed to be Not Quite Perl6, no? The Rosettacode page on Parrot omits the 6, which could lead to some confusion, i think.

[17:29] <nwc10> TimToady: it almost sounds like someone designed it to be a torture test

[17:29] <TimToady> well, it's Not Quiter Perl 5 :)

[17:29] <timotimo> (especially since it "excludes many features of perl", since with nqp you get OOP and signatures and such)

[17:29] <TimToady> timotimo: feel free to fix--it's a wiki, after all

[17:30] <timotimo> don't relly feel like registering :|

[17:37] *** mr- joined
[17:47] *** Exodist joined
[17:51] *** marloshouse_ joined
[17:51] <masak> o/, #perl6

[17:51] *** marloshouse left
[17:51] *** marloshouse_ is now known as marloshouse

[17:53] <moritz> \o masak, #perl6

[17:55] <timotimo> evening :)

[17:56] <masak> nwc10: I tend not to trust my own intuition about how negated operators and junctions combine.

[17:57] <masak> nwc10: which isn't a big practice, because there's some demoivrian duality there which always allows me to go 'if none(@things) eq $target' instead of 'if all(@things) ne $target'.

[17:57] <masak> s/a big practice/a big hurdle in practice/

[18:06] <TimToady> and in the places where people are likely to get tripped up, p6 does not-raising just like English, so it tends to do what they want

[18:06] <TimToady> or to put it the other way, English treats not like a metaoperator, just like Perl 6

[18:06] <timotimo> i wonder in what places creating parcels at optimize time and adding them as word values is helpful

[18:09] <TimToady> one could imagine an optimization where common capture types can map to common multi sig types via an integer table

[18:09] <masak> yes, I'm pondering whether the not-raising is what currently confuses nwc10.

[18:09] <masak> it certainly confused me before I learned about it ;)

[18:10] <TimToady> if you think of it all in terms of HOP, it helps, I think

[18:10] <timotimo> is there a win to finding call &infix:<,> where all its Want child nodes have a ctv and creating a parcel from that, for instance?

[18:10] <TimToady> ne is just a ! that applies an eq

[18:10] <masak> *nod*

[18:10] <masak> yes, that's the model I ended up with.

[18:10] <masak> and the ! is raised to the whole expression.

[18:11] <TimToady> well, but that falls out of the fact that the eq already 'ate' its arguments

[18:11] <timotimo> (shouldn't the optimizer already inline that call anyway?)

[18:12] <TimToady> timotimo: I'd think of it more as going all the way to a preformed capture, when you know it's going to be fed to a signature binding

[18:12] <timotimo> in what kind of example code would that happen?

[18:13] * TimToady is just talking in a hand-wavey fashion; pay him no mind

[18:13] <timotimo> hehe.

[18:13] * TimToady is probably suggesting something that already happens

[18:14] * TimToady would be (marginally) more productive by getting dressed for church...

[18:14] <nwc10> now he tells us...

[18:15] <TimToady> .oO(what to wear to one's daughter's hipster church...)

[18:16] <masak> hips.

[18:16] * masak .oO( we wore bones before it was hip )

[18:18] *** benabik left
[18:19] <TimToady> .oO(the hipster bone's connected to the...thighster bone...)

[18:20] *** cog left
[18:20] <TimToady> the fuzzy red and black plaid, I think--they'll think I'm a recovering goth

[18:21] <TimToady> goths always recover by adding red into their wardrobe

[18:23] *** am0c left
[18:27] *** benabik joined
[18:33] *** MikeFair___ left
[18:34] *** MikeFair joined
[18:40] *** spider-mario joined
[18:41] <FROGGS> good evening

[18:42] <FROGGS> std: / $( $x ) /

[18:42] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $x is not predeclared at /tmp/aLP8vr9fow line 1:␤------> [32m/ $( [33m⏏[31m$x ) /[0m␤Check failed␤FAILED 00:00 43m␤»

[18:44] <timotimo> hello froggs

[18:44] <FROGGS> hi timotimo 

[19:02] *** mtk left
[19:11] <dalek> rakudo-js: f742245 | (Paweł Murias)++ | runtime.js:

[19:11] <dalek> rakudo-js: Do not use the Boolean type as nqp is supposed to just use 1 and 0.

[19:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/f74224550d

[19:11] <dalek> rakudo-js: ab0ee8e | (Paweł Murias)++ | run_tests:

[19:11] <dalek> rakudo-js: Run faster tests first.

[19:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/ab0ee8e99f

[19:11] <dalek> rakudo-js: 822ed2a | (Paweł Murias)++ | / (2 files):

[19:11] <dalek> rakudo-js: Pass a ctx arguments to ops.

[19:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/822ed2ae2b

[19:11] <dalek> rakudo-js: 4a75697 | (Paweł Murias)++ | / (2 files):

[19:11] <dalek> rakudo-js: Move runtime for grammars (which we haven't regained yet since the refactor) to a leftovers file.

[19:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/4a75697901

[19:13] *** xy joined
[19:14] *** benabik left
[19:16] *** benabik joined
[19:19] *** vividsnow joined
[19:26] <jnthn> timotimo: I've realized there's a problem with optimizing "any"

[19:26] <jnthn> r: my @a = 1,2,3; say 2 == any(@a)

[19:26] <p6eval> rakudo c356d8: OUTPUT«any(False, True, False)␤»

[19:26] <jnthn> It can flatten.

[19:26] <jnthn> r: my @a = 1,2,3; if 2 == any(@a) { say 'ok' }

[19:26] <p6eval> rakudo c356d8: OUTPUT«ok␤»

[19:27] <timotimo> good point.

[19:27] <timotimo> strangely, that passes in my changed perl

[19:28] <timotimo> i'll check to figure out why the optimizer bails out for that optimization

[19:29] <timotimo> ah, in that specific case, it fails because of the +$node.list == 1 { return 0 }, but if i flatten two lists in there, it will most probably fail again

[19:30] <jnthn> I think we'd be best avoiding any/all for now

[19:30] <timotimo> ah, look

[19:30] <timotimo> if only one argument is passed, like @a, it will bail out due to tha tcheck

[19:31] <jnthn> yeah, any(1, @a, 2) is still gonna be a problem though

[19:31] <jnthn> The only way we can do better is to check that all the values are known at compile time and that they won't flatten, which is a bit of work...

[19:32] <timotimo> indeed.

[19:32] * jnthn shoulda spotted that one earlier

[19:32] <timotimo> yes, i will just skip any/all handling.

[19:32] <timotimo> (and add tests for that behaviour, for future reference)

[19:34] <dalek> roast: 865c95f | (Timo Paulssen)++ | S03-junctions/boolean-context.t:

[19:34] <dalek> roast: optimizers got to take special care of any/all/none due to flattening

[19:34] <dalek> roast: review: https://github.com/perl6/roast/commit/865c95f97e

[19:35] <jnthn> timotimo: OK. Other than that it looked good

[19:36] <timotimo> pushed the remove-any-and-all commit to the PR

[19:37] <timotimo> jnthn: so the decision to make this a level 2 optimization comes some time in the future?

[19:37] <nwc10> sorry if this is a naive question - assuming that the plan survives contact with the enemy, and the JVM port pans out to functionality, does it mean that one can

[19:37] <timotimo> it does mean that one can

[19:37] <nwc10> a) distribute the JVM version of Rakudo Star as a single JAR?

[19:37] <nwc10> b) also run it in webbrowsers (if anyone is crazy enough to still enable Java as a plugin)?

[19:37] <jnthn> timotimo: Hm, we could do that now.

[19:38] <timotimo> can the jar contain the dependencies, like the byte code utility library nqp-jvm uses?

[19:38] <jnthn> timotimo: Otherwise nobody benefits by default

[19:38] <timotimo> right. i'll cook up and push a commit

[19:38] <nwc10> good third question :-)

[19:38] <jnthn> Maybe worth spectesting with it that way too

[19:39] <jnthn> 3 is mostly for things that I know have caused problems and need moer careful consideration.

[19:39] <timotimo> i've already started the rakudo build, spectests are on the way in a minute

[19:40] <jnthn> nwc10: I'm not sure we get those capabilities "for free".

[19:40] <jnthn> nwc10: But they sound feasible with a bit of work.

[19:40] <nwc10> ah OK. Cool.

[19:40] <jnthn> nwc10: On the web part of it, depends how class loaders and stuff play out there I suspect.

[19:41] <timotimo> there's one more confusion i have: is invokedynamic something that'll be important to the whole effort? it would seem that nqp itself may not need it, but perhaps rakudo will?

[19:41] <nwc10> probably not worth trying too hard, as I don't think that anyone sane still invites malware to their machine via Oracle's most wonderful software

[19:41] <jnthn> nwc10: I've avoided using any of the "unsafe" things would would surely be forbidden in a web context, so hopefully it's fine...

[19:42] <jnthn> I'm happy to delegate it to somebody who thinks running a Perl 6 applet in their browser is a cool thing ;)

[19:42] <nwc10> OK, next naive question - are the unsafe things needed for such useful stuff as accessing the file system?

[19:42] <jnthn> No, that can happen through the normal class libs.

[19:42] <jnthn> NativeCall is one thing that'd use the unsafe stuff, for example.

[19:42] <nwc10> jnthn: yes, seems a good plan. Delegate to a minion. MOAR BRAAAAANES

[19:43] *** SamuraiJack left
[19:44] <diakopter> indeed

[19:44] <dalek> nqp/dyncall-sized-num: d841e27 | jnthn++ | src/HLL/ (2 files):

[19:44] <dalek> nqp/dyncall-sized-num: Abstract notion of "pre-compiled".

[19:44] <dalek> nqp/dyncall-sized-num: 

[19:44] <dalek> nqp/dyncall-sized-num: Previously, this has been tied to --target=pir.

[19:44] <dalek> nqp/dyncall-sized-num: review: https://github.com/perl6/nqp/commit/d841e27bcd

[19:44] *** dalek left
[19:45] <arnsholt> Ooops. That was my fault

[19:45] *** dalek joined
[19:45] *** ChanServ sets mode: +v dalek

[19:46] <timotimo> jnthn: the spectests succeeded :)

[19:46] <dalek> rakudo/dyncall-sized-num: f7a5a2f | (Arne Skjærholt)++ | src/ (4 files):

[19:46] <dalek> rakudo/dyncall-sized-num: Start integrating with native size support in NQP.

[19:46] <dalek> rakudo/dyncall-sized-num: review: https://github.com/rakudo/rakudo/commit/f7a5a2f3b7

[19:47] <arnsholt> jnthn: I've gotten the moving parts to move together, more or less, but doesn't look like the bits information gets to the P6int REPR ATM

[19:47] <arnsholt> I'll look more into it tomorrow

[19:49] <timotimo> heh, i parsed "look more into it" as "appear to be enjoying it more"

[19:52] <jnthn> timotimo: I want to look at exploiting invokedynamic; at the moment, I'm not.

[19:52] <arnsholt> I'm certainly confused ATM =)

[19:52] <jnthn> timotimo: It's in the category of "optimization" more than "make something work" :)

[19:52] <jnthn> arnsholt: Maybe NativeHOW lacks a repr_compose function that does composetype? Or did you take care of that?

[19:53] <arnsholt> Oh. In that case, I think I may just have put it in the wrong place

[19:54] <arnsholt> There's a method compose, where I put the composetype call

[19:55] <jnthn> arnsholt: Oh, you can do it in there too

[19:55] <jnthn> arnsholt: I just ended up with a repr_compose method that compose calls 

[19:55] <arnsholt> In that case, I dunno

[19:56] <arnsholt> My initial exploration (with printf in P6int's compose function) seemed to indicate no joy. But I could just have missed it in the compiler output

[19:56] <arnsholt> Maybe I'll try a die or something tomorrow =)

[19:59] <jnthn> timotimo: OK, you're happy it's ready to merge?

[20:04] <timotimo> i think so, yes

[20:06] <dalek> rakudo/nom: 433dca6 | (Timo Paulssen)++ | src/Perl6/Optimizer.pm:

[20:06] <dalek> rakudo/nom: unfold junctions at compile time sometimes.

[20:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/433dca6ff7

[20:06] <dalek> rakudo/nom: 8f80e88 | (Timo Paulssen)++ | src/Perl6/Optimizer.pm:

[20:06] <dalek> rakudo/nom: build a new "is_from_core".

[20:06] *** dalek left
[20:06] * jnthn closed the pull request in a few seconds

[20:06] *** dalek joined
[20:06] *** ChanServ sets mode: +v dalek

[20:06] <arnsholt> Hmm. Looks like the flood limit on irc.perl.org is different from freenode

[20:16] <tadzik> it is

[20:18] *** mr- left
[20:27] *** kaare_ left
[20:27] <timotimo> jnthn: do you think there's a way to get rakudo to spit out pre- and post-optimisation pasts easily?

[20:29] <jnthn> timotimo: --target=past should give you pre-opt, and I guess --target=optimize may already give you the post-optimized.

[20:32] <timotimo> oh, it does!

[20:32] <timotimo> that's neat

[20:37] * masak .oO( --target=beer doesn't give me beer :/ )

[20:37] <pmurias> jnthn: how good will the interop with things like jruby and closure be?

[20:38] <nwc10> can jruby interact with native Java functions?

[20:38] <nwc10> (similar question for closure)

[20:38] <jnthn> pmurias: no idea

[20:39] <jnthn> pmurias: As good as somebody spends time making it I guess :)

[20:39] <nwc10> OK, answer seems to be "yes" (both ways) for JRuby

[20:39] <jnthn> I'd certainly like us to be able to call out to Java code, and the other direction would seem rather useful too

[20:40] <pmurias> if we interop with JRuby we could have Perl6 on Rails ;)

[20:42] <nwc10> pmurias: surely you're actually doing the more useful port here - getting Perl6 closer to the metal, by interacting with Node.js

[20:42] <timotimo> :D

[20:42] <tadzik> pmurias: and we'll be better than Parrot :)

[20:43] *** vividsnow left
[20:43] <tadzik> I watched a Node.js talk today. It was all about "look, we have an event loop. And we don't have threads, you can start 8 applications if you care" and said nothing about being useful as a web client

[20:44] *** adu joined
[20:44] <timotimo> er, node.js as a web *client*?

[20:45] <timotimo> well, i suppose you could do that. but why?

[20:45] <masak> tadzik: someone on Twitter once said "Node.js looks like a partial implementation of POE"

[20:46] <jnthn> masak: Yes, but is POE webscale?

[20:46] <moritz> for some reason I always had the impression that POE required you to know far too much about it's itnernals or data model or whatever

[20:46] <moritz> ie no fun to use as a newcomer

[20:47] <timotimo> Perl Over Ethernet?

[20:47] <timotimo> oh, it's the event framework

[20:47] <moritz> Perl Object Enfironment

[20:47] <tadzik> timotimo: because Javascript

[20:48] <tadzik> node is really just v8, so you _could_ not care about what the website does with JS

[20:48] <tadzik> like WWW::Mechanize being not enough, but WWW::Mechanize::Firefox being too much

[20:48] <moritz> I consider myself pretty well-versed when it comes to Perl 5, but when I try to do some POE stuff, I find myself cargo-culting stuff from the docs all the time

[20:49] * geekosaur has not done POE in a while, nut a lot of stuff claimed by the docs never actually worked as the docs claimed in his experience

[20:49] <geekosaur> *but a lot...

[20:49] <tadzik> moritz: did you try AnyEvent?

[20:49] <moritz> tadzik: not really

[20:50] <timotimo> so, MuEvent for perl6 will be super rad, right?

[20:50] <timotimo> also, since parrot now has threads, and the JVM has threads, too, how long until nqp gets threads? how far down most people's priority lists is that?

[20:52] <pmurias> nwc10: right now I have stoped doing the port till my exams are over ;)

[20:52] <moritz> jnthn: I thought I might try to experiment a bit with constant folding

[20:53] <moritz> jnthn: and somehow I need to mark those operators that are constant-foldable

[20:53] <moritz> should I mix in a role into the proto? or add an attribute to Routine?

[20:54] <tadzik> timotimo: I wrote Threads.pm a while ago, but as nqp only works with green threads for now, so does rakudo

[20:54] <tadzik> bringing native threads to nqp is probably pretty doable

[20:55] <timotimo> yes, i've read about the green threads and i liked that quite a bit (although i have not played around with it yet)

[20:56] *** sftp left
[20:57] * grondilu is surprised we need threads in nqp

[20:57] *** snearch joined
[20:57] <nwc10> I think that you might find it quite hard to abstract the threads models of Parrot and JVM in such a way that it's easy to write one system to target both

[20:57] *** sftp joined
[20:58] <jnthn> moritz: Perhaps the mixin

[20:58] <jnthn> moritz: You could do it as part of the precedence mixin stuff perhaps...

[21:03] <moritz> I'll try it as a normal trait in core for now

[21:04] <pmurias> timotimo: there is node-webkit which allows writing desktop apps in node which use HTML do display the GUI

[21:04] <timotimo> oh. well, that's halfway sensible. that kind of approach exists for like 20 different platforms already anyway

[21:05] <pmurias> tadzik: speed is the main advantage of node.js, and using javascript both on the client and sever side

[21:06] <pmurias> timotimo: is there something like that in perl?

[21:07] *** bruges_ left
[21:08] <dalek> rakudo/constant-folding: a1bcaa6 | moritz++ | src/core/ (2 files):

[21:08] <dalek> rakudo/constant-folding: mark some numeric operators as pure

[21:08] <dalek> rakudo/constant-folding: review: https://github.com/rakudo/rakudo/commit/a1bcaa63c3

[21:08] <nwc10> moritz: not sure if this is somethign that matters, but

[21:09] <nwc10> in perl 5

[21:09] <timotimo> pmurias: i really don't know anything about perl5

[21:09] <nwc10> a) beware that anything that does warn shouldn't be constant folded

[21:09] <nwc10> (warnings might be fatal)

[21:09] *** bruges joined
[21:09] <nwc10> b) This code is valid and should not bail out at compile time

[21:09] <nwc10> if (0) {

[21:09] <nwc10>     $a = 0/0;

[21:09] <nwc10> }

[21:10] <pmurias> timotimo: what's your language of choice (besides Perl6 ;)

[21:10] <timotimo> it was python for a very long time

[21:11] *** erkan left
[21:11] <timotimo> i have a work-project, which turned into a somewhat big framework type deal and my lack of discipline when working with unrestricted types is making it hard for me to work efficiently

[21:11] <timotimo> a friend of mine had been showing me areas where perl5 is extremely good and when i saw that perl6 is gradually typed, has compile-time checks, proper signatures and such a nice object system, i was kind of hooked

[21:12] <timotimo> also, djanatyn had been showing me a few cool things

[21:12] <moritz> nwc10: I kinda hope that when stuff returns a Failure instead of throwing an exception, I can just serialize the Faillure and return it

[21:13] <nwc10> I don't understand that Perl 6 toolchain/architecture enough to know whether that works

[21:14] <nwc10> but I hope that the suggested corner test cases are useful

[21:15] <moritz> nwc10: certainly worth considering

[21:15] <masak> g'night, #perl6

[21:16] <timotimo> good night masak!

[21:16] <nwc10> I can't offhand remember any other corner cases of constant folding

[21:16] <moritz> nwc10: I also thought about emitting compile time warnings or errors like "$construct will always warn/error at run time"

[21:16] <moritz> well, I wonder if 'string' x $very_big_number is a good idea

[21:16] *** bluescreen10 joined
[21:17] <pmurias> isn't moving errors to compile time allowed in Perl6?

[21:17] <nwc10> moritz: depends how those interact with dead code.

[21:18] <moritz> pmurias: I'm not sure. If not, maybe we can establish that :-)

[21:18] <moritz> anyway, bed time for me.

[21:18] * moritz waves

[21:18] <pmurias> moritz: g'night

[21:18] * nwc10 should go to bed too

[21:18] <jnthn> 'night, moritz 

[21:22] <timotimo> well, good night bedgoers!

[21:30] <japhb> Wow, it's like someone yelled 'Lights out!' over there.  :-)

[21:32] <timotimo> i'm staying up at least a bit longer

[21:35] <FROGGS> jnthn: do you agree that this is a typo? https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.pm#L1623 cmp to https://github.com/perl6/std/blob/master/STD.pm6#L2474-L2475

[21:35] <FROGGS> there is nothing like, $[abc], is there?

[21:35] <FROGGS> std: $[abc]

[21:35] <p6eval> std 7deb9d7: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $[ variable; in Perl 6 please use user-defined array indices at /tmp/zWTiPQ6JDd line 1:␤------> [32m$[[33m⏏[31mabc][0m␤Parse failed␤FAILED 00:00 41m␤»

[21:36] <FROGGS> but there is $<abc> for a match var, and $(...) for contextualizer

[21:37] <jnthn> FROGGS: Yeah, looks typo-ish.

[21:37] <jnthn> STD seems righter

[21:37] <FROGGS> k

[21:38] <FROGGS> I still have problems, so there are other things wrong

[21:38] <FROGGS> it's hard to compare std and nqp/rakudo

[21:43] <dalek> nqp-jvm-prep: ca07f22 | jnthn++ | docs/ROADMAP:

[21:43] <dalek> nqp-jvm-prep: ROADMAP update.

[21:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/ca07f2263b

[21:43] <dalek> nqp-jvm-prep: d1a8010 | jnthn++ | / (2 files):

[21:43] <dalek> nqp-jvm-prep: Simplify nqp::say, provide nqp::print.

[21:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/d1a801054c

[21:43] <dalek> nqp-jvm-prep: 0ff27ea | jnthn++ | src/org/perl6/nqp/jast2bc/JASTToJVMBytecode.java:

[21:43] <dalek> nqp-jvm-prep: Get more string decode handling in place.

[21:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/0ff27ea5db

[21:43] <dalek> nqp-jvm-prep: 448080d | jnthn++ | nqp-src/NQPCORE.setting:

[21:43] <dalek> nqp-jvm-prep: Fix say and add print to the NQP setting.

[21:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/448080d4c6

[21:43] <dalek> nqp-jvm-prep: 1aee9de | jnthn++ | nqp-jvm-cc.nqp:

[21:43] <dalek> nqp-jvm-prep: Try to leave less files around.

[21:43] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/1aee9de977

[21:43] <jnthn> FROGGS: Yeah, though they're closer than they once were. The exception stuff often differs 'cus Rakudo knows about typed exceptions.

[21:43] *** matija joined
[21:43] <FROGGS> and the grammar and actions are split up

[21:43] <FROGGS> (and we are building an ast)

[21:44] * colomon is very happy to see what appears to be steady progress on nqp-jvm-prep

[21:50] * timotimo is amazed, frankly, at the amount of progress that jnthn is cranking out

[22:00] <FROGGS> TimToady: in STD regexes, what token will parse the contextualizer? / $( 1 ) /

[22:01] <FROGGS> TimToady: is it token metachar:var line 5060?

[22:02] <jnthn> FROGGS: yes

[22:02] <djanatyn> timotimo: :O

[22:02] <jnthn> FROGGS: and variable in the main language parses contextualizers.

[22:02] <djanatyn> timotimo: what have I been showing you?

[22:02] <FROGGS> jnthn: k, so than I'm on the right track since friday ;o)

[22:03] <FROGGS> dunno if the smiley is right though

[22:03] <timotimo> djanatyn: you've been showing me bits of perl6 here and there

[22:03] <jnthn> FROGGS: I suspect you may want to override that rule in Rakudo's regex grammar, if we don't already.

[22:04] <FROGGS> well, I adjusted it so it will match $(..., and not just $<alpha>... and $\W<alpha>...

[22:04] <djanatyn> timotimo: do you mean perl5?

[22:05] <timotimo> i'm pretty sure not

[22:05] <jnthn> FROGGS: I wonder if we can't just do what STD does...

[22:06] <jnthn> FROGGS: You may be seeing a fossil from an older, now-fixed parsing bug...

[22:06] <FROGGS> jnthn: k, thanks

[22:14] *** snearch left
[22:17] <dalek> nqp-jvm-prep: a4567c9 | jnthn++ | / (2 files):

[22:17] <dalek> nqp-jvm-prep: Stopgap solution for coercion stuff.

[22:17] <dalek> nqp-jvm-prep: 

[22:17] <dalek> nqp-jvm-prep: Needs to pay attention to the methods that will usually do the work

[22:17] <dalek> nqp-jvm-prep: also, but that can come later.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a4567c9171

[22:17] <dalek> nqp-jvm-prep: c778c18 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[22:17] <dalek> nqp-jvm-prep: Better boolification default.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/c778c183b5

[22:17] <dalek> nqp-jvm-prep: a2c3290 | jnthn++ | src/org/perl6/nqp/runtime/Ops.java:

[22:17] <dalek> nqp-jvm-prep: Stringify to 1, not 1.0.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/a2c3290f9e

[22:17] <dalek> nqp-jvm-prep: 865ecf2 | jnthn++ | nqp-src/NQPCORE.setting:

[22:17] <dalek> nqp-jvm-prep: Add testing functions to setting.

[22:17] <dalek> nqp-jvm-prep: 

[22:17] <dalek> nqp-jvm-prep: Directly copied from main NQP setting; seem to work.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/865ecf273a

[22:17] <dalek> nqp-jvm-prep: 35a1e9b | jnthn++ | / (35 files):

[22:17] <dalek> nqp-jvm-prep: Rearrange test suite a little.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/35a1e9b074

[22:17] <dalek> nqp-jvm-prep: b9a8931 | jnthn++ | t/qast/qast_ (2 files):

[22:17] <dalek> nqp-jvm-prep: Update tests for .0 changes.

[22:17] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/b9a893101c

[22:21] *** balders_dod joined
[22:23] *** MayDaniel left
[22:27] <dalek> nqp-jvm-prep: 8b22061 | jnthn++ | / (16 files):

[22:27] <dalek> nqp-jvm-prep: Start running a subset of the NQP test suite.

[22:27] <dalek> nqp-jvm-prep: 

[22:27] <dalek> nqp-jvm-prep: This adds a "make nqptest" target and adds the tests that we already

[22:27] <dalek> nqp-jvm-prep: are able to cross-compile and pass from t/nqp. They are copied right

[22:27] <dalek> nqp-jvm-prep: from the NQP repo, unmodified.

[22:27] <dalek> nqp-jvm-prep: 

[22:27] <dalek> nqp-jvm-prep: So far we pass 15 test files and 95 tests (out of 65 files and 584

[22:27] <dalek> nqp-jvm-prep: tests).

[22:27] <dalek> nqp-jvm-prep: review: https://github.com/jnthn/nqp-jvm-prep/commit/8b22061511

[22:28] *** cog joined
[22:30] <tadzik> awesome awesome

[22:30] <tadzik> jnthn++

[22:31] <stevan_> jnthn: around?

[22:31] <jnthn> stevan_: yeah, though only for a little longer...gotta get up to teach tomorrow :)

[22:31] <stevan_> may I ask a few questions, i don't require deep answers :)

[22:32] <stevan_> I promise I won't keep you too long 

[22:32] <jnthn> sure

[22:32] <stevan_> cool

[22:32] <stevan_> so first question is, how complete is QAST? is that all the nodes NQP uses? 

[22:33] <jnthn> Rakudo and NQP both produce QAST

[22:33] <stevan_> specifcally these nodes -> https://github.com/perl6/nqp/tree/master/src/QAST

[22:33] <jnthn> It's serving us pretty well.

[22:33] <stevan_> ok, cool

[22:33] <jnthn> QAST evolved from PAST, which was, API wise, very stable.

[22:33] <stevan_> k

[22:34] <jnthn> QAST was partly "lessons learned", partly integrating 6model, and partly preparing for backend independence.

[22:34] <stevan_> so, second question, how much thinking have you guys done about how Perl 5 and Perl 6 would interoperate?

[22:35] <jnthn> I don't see major QAST changes down the line. masak++ has added some bits related to macros...

[22:35] <jnthn> On interop, we've talked about various options.

[22:35] <stevan_> yeah it seemed pretty complete to me, just wasnt sure if there was something I hadn't seen 

[22:36] <stevan_> is there a prevailing wind in any specific direction?

[22:36] <spider-mario> I’m seeing some strange behavior with !op and junctions

[22:36] <spider-mario> it seems that (junction) !op value is `not ((junction) op value)`

[22:37] <spider-mario> at least with op = %%

[22:37] <stevan_> jnthn: I guess the specifics are; are you planning on just linking to libperl.so? or do you think p5 on Rakudo is more of a possibility?

[22:37] <spider-mario> r: all(3, 4) !%% 2

[22:37] <p6eval> rakudo 9c9d79:  ( no output )

[22:37] *** adu left
[22:37] <spider-mario> r: say(all(3, 4) !%% 2)

[22:37] <p6eval> rakudo 9c9d79: OUTPUT«True␤»

[22:38] <jnthn> The two interop things that are worth doing, in my view, are (a) embed Perl 5 and hang its SVs off 6model objects and try and make things somehow sorta work, and (b) build a Perl 5 implementation that targets QAST.

[22:38] <spider-mario> I thought it would mean “all not divisible by 2”

[22:38] <spider-mario> when it seems to actually mean “not(all divisible by 2)”

[22:39] <spider-mario> n: say(all(3, 4) !%% 2)

[22:39] <p6eval> niecza v24-18-gaf64300: OUTPUT«True␤»

[22:39] <spider-mario> why is that?

[22:39] <spider-mario> r: say(all(2, 3) != 2)

[22:39] <p6eval> rakudo 9c9d79: OUTPUT«True␤»

[22:39] <jnthn> Where a is useful in so far as "we get run the XS modules" and b is useful in so far as "it just integrates nicely"

[22:39] <stevan_> right

[22:39] <jnthn> On b, we actually do have a very tiny bit of it ;)

[22:39] <jnthn> r: say 'a b' ~~ m:P5/a b/

[22:39] <p6eval> rakudo 9c9d79: OUTPUT«｢a b｣␤␤»

[22:40] <stevan_> larry's work on the STD_p5?

[22:40] <stevan_> oh, the regex

[22:40] <stevan_> hehe :)

[22:40] <jnthn> well, but I took "how is Perl 5 regex parsed" from STD_P5 with few changes.

[22:42] <jnthn> What's cute is that you can actually use the Rakudo debugger to single step through P5 regexes too

[22:42] <grondilu> rn: say all(3, 4) !%% 2

[22:42] <jnthn> I basically got it for "free" 'cus the debugger works at AST level.

[22:42] <p6eval> rakudo 9c9d79, niecza v24-18-gaf64300: OUTPUT«True␤»

[22:42] <grondilu> rn: say not all(3, 4) %% 2

[22:42] <p6eval> rakudo 9c9d79, niecza v24-18-gaf64300: OUTPUT«True␤»

[22:42] <jnthn> spider-mario: I think that was discussed here earlier; the not is lifted outside of the expression, iirc

[22:43] <spider-mario> it certainly looks so

[22:43] <spider-mario> thanks

[22:43] <flussence> think of the all() as a mini-fork()

[22:43] <timotimo> jnthn: tbh, i didn't do much to make sure this negation stuff works with my optimisation. didn't even look at !op much

[22:43] <spider-mario> I was more puzzled by !op than by all

[22:43] <timotimo> do you think something may go wrong?

[22:44] <stevan_> jnthn: ok, perfect, you've answered my questions :)

[22:44] <spider-mario> maybe we should make it a test?

[22:44] <stevan_> thanks much

[22:44] <stevan_> have a good night sleep

[22:44] <spider-mario> and run that test with optimizations enabled

[22:44] <jnthn> stevan_: welcome

[22:45] <spider-mario> hm, do you usually speak american or british english here?

[22:45] <geekosaur> "yes"? :)

[22:45] <spider-mario> I see that timotimo has just said “optimisation”

[22:45] <spider-mario> I replied “optimization” without putting too much thought

[22:45] <spider-mario> (+with)

[22:46] <jnthn> spider-mario: I'm British and end up typing American spellings a bunch of the time

[22:46] <spider-mario> neither are my native language, I’m french

[22:46] <geekosaur> language here is somewhat flexible, in my experience.  mostly some form of English but you'll spates of other languages as well

[22:46] <jnthn> I've even had people edit my commits to Rakudo to change things from British to American spelling o.O

[22:47] <spider-mario> :D

[22:47] <spider-mario> so, I shouldn’t worry about it?

[22:47] <timotimo> i haven't fixed what spelling of optimization i should be using in my head

[22:47] <spider-mario> neither have I

[22:47] <timotimo> i don't do optimization often, at all. at least not this kind

[22:48] <spider-mario> the spelling in french is the same as in british english

[22:48] <diakopter> jnthn: probably that's when an American doesn't know there is a British spelling

[22:48] <spider-mario> with an `s`

[22:49] <timotimo> the german one is "optimierung"

[22:50] <jnthn> OK, time for some rest

[22:50] <jnthn> 'night o/

[22:50] <spider-mario> there are things where french is closer to american english than british english, though

[22:50] <spider-mario> good night, jnthn

[22:50] <spider-mario> for example, (US) to have a cramp vs. (UK) to have cramp

[22:51] <timotimo> good night jnthn! and good teaching :)

[22:51] <spider-mario> in french, it’s « avoir une crampe », so there’s an article before the noun

[22:52] <spider-mario> I meant closer than *to* british english

[22:52] *** awwaiid joined
[22:52] <timotimo> ah, the optimization i wrote doesn't recognize operators if they have METAOP_NEGATE applied to them

[22:52] <spider-mario> of course british english is still closer to american english than french is. :D

[22:54] <timotimo> the optimization bails out pretty pessimistically

[22:57] *** cog left
[22:57] <japhb> timotimo: That's exactly what you want.

[22:58] <japhb> Nothing more annoying than discovering your optimization was over-general and is acting as an automated bug insertion mechanism

[22:58] <timotimo> indeed!

[23:06] *** cog joined
[23:10] *** PacoAir left
[23:31] *** sftp left
[23:41] *** pmurias left
[23:41] *** userman joined
[23:43] *** cog left
[23:48] *** cog joined
[23:55] *** userman left
