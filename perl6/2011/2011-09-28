[00:01] *** benabik joined
[00:02] *** gern left
[00:05] *** tyatpi left
[00:05] *** replore joined
[00:11] *** risou_awy is now known as risou

[00:16] *** abercrombie joined
[00:29] *** risou is now known as risou_awy

[00:42] *** ashleydev joined
[00:45] *** whiteknight left
[00:54] *** bacek_at_work joined
[00:54] *** aloha joined
[00:55] *** alvis left
[00:58] *** Sarten-X left
[00:58] *** vlixes`` joined
[01:00] *** vlixes` left
[01:02] *** araujo joined
[01:06] *** Sarten-X joined
[01:10] *** alvis joined
[01:28] *** ponpon joined
[01:28] *** p0nb1k1 joined
[01:28] *** ponbiki left
[01:28] *** ponpon left
[01:31] *** Sarten-X left
[01:39] *** Sarten-X joined
[01:48] *** cognominal_ joined
[01:51] *** cognominal left
[01:59] *** ZapZ_ joined
[02:00] *** wolfman2000 joined
[02:08] <colomon> rakudo: my $a; say $a.defined

[02:08] <p6eval> rakudo 317f89: OUTPUT«Bool::False␤»

[02:08] *** masonkramer left
[02:12] *** envi_ joined
[02:20] <soh_cah_toa> what is the Cool type for? is that mentioned anywhere in the spec?

[02:22] <[Coke]> soh_cah_toa: http://perlcabal.org/syn/S02.html#The_Cool_class_(and_package) ?

[02:23] <soh_cah_toa> [Coke]: great, thanks

[02:23] <[Coke]> de nada.

[02:25] <soh_cah_toa> hm, this doesn't really make sense to me :\

[02:27] <[Coke]> best I could find. ;)

[02:28] *** packetknife joined
[02:28] <jlaire> soh_cah_toa: it's a common super class for all scalar types

[02:29] <jlaire> or something like that

[02:30] <soh_cah_toa> ok

[02:31] <colomon> it's sort of the magic perl class... things which are Cool try hard to Do What You Mean

[02:32] <colomon> when I started with Perl 6, all user classes worked that way too, but then people noticed that meant the simplest class you could create had dozens (hundreds?) of methods on it.

[02:32] <soh_cah_toa> yeah, spec says user-defined classes are not Cool

[02:32] <colomon> so that functionality was filtered out into Cool, and if you want your classes to do all that stuff, you just add "is Cool" to them.  :)

[02:33] <soh_cah_toa> yeah

[02:35] <colomon> But yeah, it lets you do stuff like...

[02:35] <benabik> This class is Cool.

[02:35] <soh_cah_toa> looks like it's most of the p5 builtin functions

[02:36] <benabik> class This is Cool, sorry.

[02:36] <colomon> rakudo: say (3524324 + 32222).split(/5/).perl

[02:36] <p6eval> rakudo 317f89: OUTPUT«("3", "", "6", "46").list␤»

[02:36] <jlaire> std: class This is Cool {}

[02:36] <p6eval> std 8b331d2: OUTPUT«ok 00:01 118m␤»

[02:37] <colomon> Many (most?) of what you'd think of as string or numeric methods are defined on Cool, so that you can call string methods on numbers, and vice versa.

[02:38] <soh_cah_toa> ok

[02:39] <soh_cah_toa> and does anyone know of a good blog/article that explains proto subs/regexes? they're not sitting well w/ me just yet

[02:40] <moritz> soh_cah_toa: http://perlgeek.de/en/article/mutable-grammar-for-perl-6 tries

[02:41] <colomon> that's proto regexes, not proto subs, right?

[02:41] <colomon> moritz++

[02:41] <colomon> moritz: up with the wee one?

[02:41] <moritz> aye, proto regexes

[02:41] <moritz> colomon: no, up by myself

[02:42] <soh_cah_toa> moritz: in your example, what does the <sym> refer to in the rule definition?

[02:43] <moritz> soh_cah_toa: in token sigil:sym<$>  { <sym> }

[02:43] <soh_cah_toa> yes

[02:43] <moritz> soh_cah_toa: the <sym> is '$'

[02:44] <soh_cah_toa> is 'sym' just a name your chose or can it be anything?

[02:44] <soh_cah_toa> like token sigil:foo<%> { <foo> }

[02:45] <moritz> soh_cah_toa: in rakudo, it must be 'sym'

[02:45] <soh_cah_toa> ok

[02:45] <moritz> soh_cah_toa: not sure if general Perl 6 permits any identifier

[02:46] <soh_cah_toa> alright, but what about proto subs/methods? they seem to be very different

[02:46] * soh_cah_toa is looking at src/core/Cool.pm, btw

[02:46] <colomon> yes, very different

[02:47] <moritz> lemme try

[02:47] <colomon> moritz: go for it, I need to get to bed.  ;)

[02:47] <colomon> o/

[02:47] <moritz> to the outside, a bunch of multis looks just like single sub or method

[02:47] <moritz> colomon: sleep well

[02:47] <moritz> and this single sub or method is a 'proto'

[02:48] <moritz> so if you take a reference like &foo, that's a reference to the &foo proto

[02:48] <moritz> the proto is then responsible for re-dispatching to its multi candidates

[02:49] <moritz> and there's a special syntax for redispatch, it's just   proto sub foo(signature) {*}

[02:49] <soh_cah_toa> but doesn't every multi sub/method do that even w/o a proto?

[02:49] <moritz> but the proto could do something else, like first modifying its arguments before re-dispatch or so

[02:49] <moritz> soh_cah_toa: there are no multis without a proto in perl 6

[02:50] <moritz> soh_cah_toa: for subs the proto is just autogenerated

[02:50] <soh_cah_toa> ah, ok

[02:50] <dalek> roast: 6a6cd4f | Coke++ | S02- (5 files):

[02:50] <dalek> roast: niecza fudging

[02:50] <dalek> roast: review: https://github.com/perl6/roast/commit/6a6cd4f3ba

[02:50] <soh_cah_toa> alright, consider this:

[02:51] <soh_cah_toa> proto method subst(|$) {*}

[02:51] <soh_cah_toa> multi method subst($matcher, $replacement, *%adverbs) {

[02:51] <soh_cah_toa>     self.Stringy.subst($matcher, $replacement, |%adverbs);

[02:51] <soh_cah_toa> }

[02:51] <soh_cah_toa> when, subst() is called, the proto first flattens the args then re-dispatches?

[02:51] <moritz> soh_cah_toa: no, it doesn't flatten the args

[02:51] <moritz> soh_cah_toa: in a signature, |$foo  means "capture the rest of the argument list in $foo"

[02:52] <soh_cah_toa> isn't that slurpy * though?

[02:52] <moritz> and |$ just means "capture the rest of the argument list in an anonymous variable", or phrased differently, "do nothing"

[02:52] <moritz> soh_cah_toa: no, the {*} means "redispatch to all the candidates in here"

[02:52] <soh_cah_toa> i meant in a sub signature

[02:52] <moritz> that's not part of the signature, but part of the routine body

[02:53] <soh_cah_toa> sub foo(*@foo)

[02:53] <soh_cah_toa> vs

[02:53] <soh_cah_toa> sub foo(|@foo)

[02:53] <soh_cah_toa> i thought | flattens and * slurps

[02:53] *** packetknife left
[02:53] <moritz> soh_cah_toa: I think you're confusing a few things here

[02:54] <moritz> on the call side, foo(|@args) flattens

[02:54] <moritz> but in a signature, (|$foo) means "capture the rest"

[02:54] <soh_cah_toa> ah

[02:55] <soh_cah_toa> then what about * in a sub signature?

[02:55] *** tyatpi joined
[02:56] <moritz> * slurps

[02:56] <moritz> but *@foo only slurps positionals

[02:57] <moritz> and *%foo only slurps named

[02:57] <moritz> |$foo takes 'em all

[02:57] <soh_cah_toa> and *$foo is positionals too?

[02:58] <jlaire> std: sub f(*$) { }

[02:58] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[03:00] *** xinming_ left
[03:01] <soh_cah_toa> so like in the example above, is proto sub foo($|) {*} the default autogenerated proto?

[03:01] <soh_cah_toa> s/$|/|$/

[03:01] <moritz> soh_cah_toa: yes

[03:01] * moritz doesn't know what *$foo does

[03:02] <soh_cah_toa> then isn't explicitly specifying a proto method (in Cool.pm, that is) a bit redundant as they don't actually do anything before re-dispatching? on that note, why is subst() even declared a multi in the first place? it only has one definition

[03:02] <sorear> good * #perl6

[03:02] <phenny> sorear: 27 Sep 15:28Z <[Coke]> ask sorear if https://gist.github.com/1245372 - can I apply that?

[03:02] <phenny> sorear: 27 Sep 21:47Z <diakopter> tell sorear I submitted two niecza issues

[03:03] <sorear> diakopter: grammar A is STD { } # fails, because you didn't "use STD", and STD.pm6 isn't in the default PERL6LIB anyway.  The latter might be a bug, but the STD API isn't settled

[03:04] <sorear> diakopter: github sends me email every time someone opens an issue against something that I can commit to.  It's kind of annoying.

[03:06] <dalek> roast: 278afd4 | Coke++ | S06- (2 files):

[03:06] <dalek> roast: niecza fudging

[03:06] <dalek> roast: review: https://github.com/perl6/roast/commit/278afd49fd

[03:06] <sorear> [Coke]: *372 looks fine.

[03:07] <[Coke]> sorear: excellent. am running one last spec test, will get us to over 4400tests.

[03:07] *** xinming joined
[03:08] <sorear> \o/

[03:13] <[Coke]> All tests successful.

[03:13] <[Coke]> Files=175, Tests=4458, 448 wallclock secs ( 1.66 usr  1.07 sys + 771.65 cusr 36.38 csys = 810.76 CPU)

[03:13] <[Coke]> (niecza)

[03:14] <dalek> niecza: 724429c | Coke++ | t/run_spectests:

[03:14] <dalek> niecza: "make spectest" now respects TEST_JOBS

[03:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/724429cc49

[03:14] <dalek> niecza: a49e2ba | Coke++ | t/spectest.data:

[03:14] <dalek> niecza: run fudged tests.

[03:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a49e2ba533

[03:15] <[Coke]> I'm still in the LHF zone, even.

[03:18] <sorear> \o/ \o/

[03:23] <TimToady> here's a shell function for niecza: https://gist.github.com/1246913  :)

[03:23] <TimToady> it's pretty stupid about quotes

[03:24] <TimToady> but it's good enough for running stty...

[03:29] * sorear ponders

[03:29] *** vlixes`` left
[03:34] *** soh_cah_toa left
[03:41] *** tokuhiro_ left
[03:42] *** molaf joined
[03:51] *** satyavvd joined
[04:02] *** envi_ left
[04:06] *** abercrombie left
[04:09] *** thou joined
[04:16] *** shinobicl_ joined
[04:25] *** daniel-s joined
[04:31] *** woosley joined
[04:31] *** woosley left
[04:36] *** uasi left
[04:36] *** Trashlord left
[04:37] *** Trashlord joined
[04:55] *** uasi joined
[05:01] <dalek> roast: f3f35ac | Coke++ | S0 (36 files):

[05:01] <dalek> roast: niecza fudging

[05:01] <dalek> roast: review: https://github.com/perl6/roast/commit/f3f35acafe

[05:04] <[Coke]> I think I'm running out of LHF. ;)

[05:04] <[Coke]> running another niecza spectest now.

[05:09] <[Coke]> it was curious to me that a lot of the niecza skips were right next to rakudo "nom regression"s.

[05:09] <[Coke]> wonder if those denote spec changes, perhaps, or if just a coincidence.

[05:12] *** koban` joined
[05:14] <sorear> [Coke]: no doubt a combination of tat, and tests that never should have worked in the first place.

[05:14] <sorear> [Coke]: you may have noticed that post-nom I've had a lot less bad things to say about Rakudo :)

[05:15] <[Coke]> heh.

[05:15] <sorear> TimToady: do you think something like that should go into niecza's CORE?

[05:15] <sorear> TimToady: the main blocker for a &shell in niecza is me having no idea how to deal with quotes

[05:15] <[Coke]> ARGH, typo, have to rerun the spectest. (SOON)

[05:18] *** shinobicl_ left
[05:19] *** woosley joined
[05:22] *** alim joined
[05:24] <[Coke]> All tests successful.

[05:24] <[Coke]> Files=219, Tests=5462, 598 wallclock secs ( 2.04 usr  1.37 sys + 969.46 cusr 47.50 csys = 1020.37 CPU)

[05:24] <[Coke]> (niecza)

[05:25] <dalek> niecza: 6689415 | Coke++ | t/spectest.data:

[05:25] <dalek> niecza: run fudged tests

[05:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/66894154e9

[05:25] <sorear> wow! Coke++

[05:26] <[Coke]> and now zzz.

[05:30] *** mberends left
[05:36] *** tokuhiro_ joined
[05:36] *** alim left
[05:39] <dalek> roast: c336a95 | moritz++ | S (5 files):

[05:39] <dalek> roast: rakudo unfudges

[05:39] <dalek> roast: review: https://github.com/perl6/roast/commit/c336a95a7e

[05:50] *** wtw joined
[05:50] *** wtw left
[05:50] *** wtw joined
[05:54] *** kaleem joined
[06:01] *** qweqwe joined
[06:02] *** qweqwe_ joined
[06:02] *** qweqwe_ left
[06:06] *** qweqwe left
[06:09] *** orafu left
[06:10] *** thou left
[06:11] *** orafu joined
[06:17] <jnthn> o/

[06:18] <moritz> \o

[06:19] <moritz> nom: my $x = '1}; say "pwnd"; #'; 'a' ~~ /<$x>/

[06:19] <p6eval> nom 317f89: OUTPUT«pwnd␤pwnd␤»

[06:19] <moritz> ouch

[06:20] <jnthn> ...ouch.

[06:23] * moritz submits rakudobug

[06:23] <moritz> so, how is the release going?

[06:24] <sorear> erm

[06:24] <sorear> what is the bug there?

[06:25] <sorear> other than the eskimo

[06:25] <moritz> sorear: the eskimo

[06:25] <sorear> ah

[06:25] <jnthn> Also curious why we see it twice.

[06:25] <moritz> it's supposed to be a runtime error

[06:27] *** lichtkind left
[06:27] <sorear> jnthn: the twiceness is correct.  You're matching the regex against a string with two indexes

[06:27] <sorear> The cursor can either be at 0/1 or 1/1, and <$x> has to be tried at both places

[06:28] <sorear> and $x could in principle have been modified, so reusing the eval is a matter of optimization

[06:28] <jnthn> ah, makes sense

[06:28] <jnthn> (no coffee yet today :))

[06:29] <sorear> I'm about to sleep; I fixated on the correct twiceness and failed to notice the eskimo :D

[06:29] * sorear tries to remember what ey was waiting to ask jnthn

[06:29] <jnthn> I'm about to have to commute anyways...

[06:30] * sorear sleep

[06:30] <dalek> niecza/serialize: bdf76de | sorear++ | / (2 files):

[06:30] <dalek> niecza/serialize: Type creation proper

[06:30] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/bdf76dedcd

[06:30] *** masak` joined
[06:30] <masak`> a *regex* injection?

[06:31] <masak`> whoa.

[06:31] <masak`> moritz++

[06:31] <masak`> is that even possible in Perl 5?

[06:33] <jnthn> Achievement!

[06:34] <masak`> I think I found the offending line: https://github.com/rakudo/rakudo/commit/154292e02414d476ffe0b3b64b7073c08029523f#L2R37

[06:34] <masak`> ;)

[06:34] <jnthn> I look at fixing that this evening, if pmichaud++ doesn't beat me to it.

[06:34] <jnthn> Commute time.

[06:34] <jnthn> &

[06:35] <masak`> the ingredients of an injection are there: user input, unchecked, going straight into an &eval.

[06:36] <masak`> by the way, someone seems to have hijacked my nickname on freenode.

[06:36] <masak`> is there a procedure for when that happens?

[06:41] <sorear> /msg nickserv ghost masak PASSWORD

[06:43] *** masak` is now known as masak

[06:43] <masak> sorear: thank you.

[06:44] <moritz>  masak fwiw I discovered this injection by reading the diffs

[06:45] * sorear wonders how the other Masak will take this

[06:45] * sorear sleep for real

[06:46] <dalek> rakudo/nom: 038d9ea | moritz++ | src/core/Attribute.pm:

[06:46] <dalek> rakudo/nom: nicer Attribute.Str

[06:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/038d9ea1e6

[06:46] <masak> the other masak had already logged out, it seems.

[06:47] <masak> from what I can tell from a simple duckduckgo search, it's someone from Indonesia.

[06:47] <masak> could be a simple misunderstanding.

[07:03] *** ZapZ_ left
[07:15] <jnthn> masak: (injection) note though that you're interpolating it as regex syntax

[07:16] <jnthn> masak: So you coulda done '. { say "pwnd" }' as the string

[07:16] <jnthn> It should be fixed but it's not giving people capabilities they'd not otherwise have.

[07:24] *** alim joined
[07:27] <moritz> I'd like to have two regex interpolation syntaxes

[07:27] <moritz> one for safe interpolation, one for permissive

[07:30] <jnthn> "safe"?

[07:33] <moritz> interpolation that doesn't allow code blocks, code assertions, variable definitions etc.

[07:46] <moritz> nom: say Capture.^attributes

[07:46] <p6eval> nom 038d9e: OUTPUT«$!list $!hash␤»

[07:46] <moritz> nom: say Match.^attributes

[07:46] <p6eval> nom 038d9e: OUTPUT«$!orig $!from $!to $!CURSOR $!list $!hash␤»

[07:46] <moritz> is it intentional that .^attributes returns the parent's attributes as well?

[07:46] <moritz> nom: class A is Rat { }; say A.^attributes

[07:47] <p6eval> nom 038d9e: OUTPUT«$!numerator $!denominator␤»

[07:47] <moritz> nom: class A is Rat { }; say A.^attributes(:local)

[07:47] <p6eval> nom 038d9e: OUTPUT«␤»

[07:47] <moritz> nom: say Match.^attributes(:local)

[07:47] <p6eval> nom 038d9e: OUTPUT«$!orig $!from $!to $!CURSOR␤»

[07:47] <moritz> I guess that answers my question :-)

[07:50] <jnthn> yes, intentional :)

[07:50] *** wallberg joined
[07:54] <masak> moritz: this safe/powerful dichotomy (or wishes to have same) seems to pop up in ever more places in Perl 6. Pod and command-line handling is another example.

[07:54] <masak> except that command-line handling should probably always be safe...

[08:07] *** daxim joined
[08:07] *** xinming_ joined
[08:09] *** wamba joined
[08:10] *** xinming left
[08:24] *** m6locks joined
[08:25] *** dakkar joined
[08:26] *** Bzek joined
[08:43] *** ab5tract joined
[08:47] *** p0nb1k1 left
[08:49] <dalek> rakudo/nom: 2b6272f | moritz++ | docs/announce/2011.09:

[08:49] <dalek> rakudo/nom: [docs] update regression list

[08:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b6272f803

[08:51] <masak> leave one out, put another one in ;)

[08:52] *** ab5tract left
[09:02] *** mj41 joined
[09:08] * jnthn just did code review session :)

[09:08] <jnthn> oops, ww

[09:22] *** Vlavv` joined
[09:22] *** mishin joined
[09:22] *** Vlavv_ left
[09:29] *** envi_ joined
[09:31] *** wallberg left
[09:34] *** tyatpi left
[09:34] *** tyatpi joined
[09:36] *** replore left
[09:58] *** uasi left
[10:06] *** odoacre left
[10:10] *** mj41 left
[10:16] <dalek> rakudo/nom: b007943 | moritz++ | docs/announce/2011.09:

[10:16] <dalek> rakudo/nom: [announce] wording improvements by snarkyboojum++

[10:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b0079434cc

[10:17] <moritz> nom: class action { method TOP($/) { say $/.WHICH } }; grammar g { token TOP { a } }; say g.parse('a', :actions(action)).WHICH

[10:17] <p6eval> nom 2b6272: OUTPUT«75843840␤75101672␤»

[10:17] *** woosley left
[10:18] <moritz> ah, that's why my attempts to implement to implement $/.ast and make() have been futile

[10:18] *** huf left
[10:19] *** huf joined
[10:24] *** tokuhir__ joined
[10:26] *** tokuhiro_ left
[10:31] <flussence> I've now got a semi-working Str.indent, but nom seems to have a regex bug that I just can't figure out (https://github.com/flussence/p6-misc/blob/master/lib/Indent.pm#L25 - $0 is always blank even though the match succeeds)

[10:32] <moritz> nom: given 'a' { when /./ { say $/ } }

[10:32] <p6eval> nom 2b6272: OUTPUT«Any()␤»

[10:32] <flussence> that looks like it...

[10:32] <moritz> flussence: scoping problem, it seems

[10:33] <moritz> nom: given 'a' { when /./ { say $/ } 

[10:33] <p6eval> nom 2b6272: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[10:33] <flussence> nom: given 'a' { if /./ { say $/ } }

[10:33] <p6eval> nom 2b6272: OUTPUT«a␤»

[10:33] <moritz> so work-aroundable

[10:37] <flussence> down to 10/60 failures from 27/60 :D

[10:41] <masak> moritz: so they *were* different Match classes?

[10:41] <masak> one is nqp, the other one Rakudo?

[10:42] *** frettled joined
[10:42] *** uasi joined
[10:43] <moritz> masak: no

[10:44] <moritz> masak: but the object that the object method sees is a different one than the thing returned to the caller

[10:46] *** mj41 joined
[10:47] <masak> ah.

[10:48] <tadzik> good mornings

[10:48] <masak> that doesn't explain why it didn't find the .ast method.

[10:48] <masak> tadzik: \o

[10:55] *** tyatpi left
[10:57] <tadzik> does JSON::Tiny work now?

[10:57] *** mj41 left
[10:57] <snarkyboojum> tadzik: doesn't seem to

[10:57] <jnthn> No protoregexes yet

[10:58] <tadzik> oh, ok

[10:58] <flussence> Result: PASS \o/

[10:59] <flussence> (is this code too late to get into 2011.09 somehow?)

[11:00] <jnthn> flussence: which code, ooc?

[11:00] <flussence> Str.indent

[11:01] <flussence> link to current is in the backlog 30 mins ago

[11:02] <jnthn> Should be harmless to put it in.

[11:02] <flussence> yay!

[11:04] <moritz> masak: it didn't find the $!ast attribute; but when I declared it as 'has $.ast is rw' and called the rw method, it set the value

[11:05] <moritz> masak: but on the wrong object, so it was worthless

[11:09] <jnthn> moritz: Were you doing bindattr?

[11:09] <jnthn> moritz: If so, remember to decontainerize first.

[11:11] <masak> moritz: yes... but why didn't it find the $!ast attribute, if it was the same class?

[11:11] *** sftp left
[11:11] *** tokuhir__ left
[11:11] *** sftp joined
[11:11] *** cognominal joined
[11:14] <jnthn> masak: That's what I said about decont :)

[11:14] *** cognominal_ left
[11:14] <jnthn> nqp::bindattr($thing-in-a-container, Class, '$!name') # problem

[11:14] <jnthn> er, scalar container that is.

[11:16] *** pmurias joined
[11:16] <masak> nqp::bindattr is nice. just don't tell TheDamian :P

[11:16] *** pmurias left
[11:16] <jnthn> masak: It'll end up needing a pragma to use at some point, I suspect.

[11:17] <masak> nod.

[11:27] *** mishin left
[11:29] <flussence> std: /\N ** 0..*/

[11:29] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[11:32] <masak> \N is interesting.

[11:34] *** mtk joined
[11:34] *** mtk left
[11:35] *** mtk joined
[11:37] <masak> whereas \n in regexes mean '\n or \r or \r\n', \N just means 'neither \n nor \r'

[11:37] <masak> note the assymmetry there.

[11:38] <flussence> I see \r\n as the strange case :)

[11:38] *** tzhs joined
[11:39] <tadzik> t/spec/S19-command-line/dash-e.rakudo - TODO passed:   2-3

[11:39] <tadzik> Files=495, Tests=16062, 1416 wallclock secs; Result: PASS

[11:39] <flussence> dash-e seems to suffer from a heisenbug

[11:40] *** Patterner left
[11:41] <moritz> ah, I see the problem

[11:41] <moritz> in nqp/src/QRegex/Cursor.nqp, method !reduce

[11:41] <moritz>         pir::find_method__PPs($actions, $name)($actions, self.MATCH)

[11:41] <moritz>             if pir::can__IPS($actions, $name);

[11:41] <moritz> it calls self.MATCH

[11:42] *** Psyche^ joined
[11:42] *** Psyche^ is now known as Patterner

[11:42] <moritz> and self.MATCH seems to check if if the cached $!match is an NQPMatch

[11:42] <moritz> not if it's defined

[11:43] <moritz> wait, that's the NQPCurosr.MATCH

[11:43] <jnthn> dash-e consistently fails here

[11:43] <moritz> oh, the Perl 6 Cursor.MATCH never caches match

[11:44] <moritz> jnthn: do I need to decontainerize self in ordinary (non-rw) methods?

[11:46] <jnthn> No

[11:46] <jnthn> Pretty sure we bind the decontainerized thing

[11:57] <mls_> afternoon perl6!

[11:59] <mls_> jnthn: is the purpose of sink_past to reduce unnecessary cloning?

[11:59] <tadzik> afternoon mls_ 

[11:59] <tadzik> ...afternoon already? Man, I got up late

[12:00] <mls_> It's two oclock here

[12:02] <tadzik> yeah, same here

[12:02] *** bluescreen10 joined
[12:02] *** frettled_ joined
[12:02] <mls_> so you're really up late ;)

[12:02] <jnthn> mls_: Well, it's got more than one use. But in the routine declaration case, yes, it does that.

[12:02] <jnthn> mls_: Avoids generating unrequired code.

[12:03] *** frettled left
[12:03] <jnthn> mls_: In other cases (like /foo/) we'll need it to get things right functionally though. BUT I may just eliminate it in favor of PAST::Want.

[12:03] <mls_> Ah, that was exactly what I was about to ask ;)

[12:04] <jnthn> I was tempted last night but...was too tired.

[12:07] *** tokuhiro_ joined
[12:12] <zenog> masak: I asked Magnus (the original MediaWiki author) why he wrote it in PHP, and the answer was that he did not know PHP back then, and used the project as an opportunity to learn PHP.

[12:15] <masak> zenog: hah! :)

[12:20] *** bluescreen10 left
[12:23] <ingy> hi moritz 

[12:24] *** tokuhiro_ left
[12:27] <ingy> moritz, TimToady, masak: I settled on <a>* % <b>, <a>+ % <b>, <a>2+ % <b>, <a>42 % <b>, <a>2-4 % <b>, with %% forms of all of those. So very close to p6 % variations, but just a little nicer. :)

[12:28] * [Coke] wonders if we should make Larry update the spec tests whenever he changes the spec as a throttle. ;)

[12:28] <ingy> [Coke]: how do we *make* him do it?

[12:29] * ingy volunteers to help muscle TimToady 

[12:32] <moritz> nom: role a { has $!a }; class b does a { has $!a }

[12:32] <p6eval> nom b00794: OUTPUT«===SORRY!===␤Attribute '$!a' already exists in the class 'b', but a role also wishes to compose it␤»

[12:32] <moritz> nom: role a { has $!a }; class b does a { method foo { $!a } }

[12:32] <p6eval> nom b00794: OUTPUT«===SORRY!===␤Attribute $!a not declared in class b at line 1, near " } }"␤»

[12:33] <moritz> so if a role has an attribute, I can neither use it in a class that I compose the role into, nor can I declare one on my own

[12:33] <moritz> that seems LTA to me

[12:34] <masak> agreed.

[12:34] <jnthn> Agree but not sure what to do about it.

[12:34] <jnthn> It's a language design call really.

[12:35] <jnthn> If we decide what's wanted I can probably work out how to do it.

[12:35] *** bluescreen10 joined
[12:35] <moritz> well, either we make attributes private to roles, or we compose them into the class

[12:35] <jnthn> In master we didn't try to check attributes at compile time so never ran into this. It just magically worked.

[12:36] <jnthn> moritz: "private to roles" still involves them being copied into the class.

[12:36] <tadzik> b: role a { has $!a }; class b does a { method foo { $!a }}

[12:36] <p6eval> b 1b7dd1:  ( no output )

[12:36] <tadzik> that's what I'd expect

[12:36] <jnthn> We can do that, it just means that we have to keep track of every attribute used in the class body, and then check them after composition has taken place.

[12:37] <jnthn> (at the point we parse the usage of $!a, we don't yet know about the one in the role)

[12:37] <colomon> phenny: tell mberends You can get an extra 1000+ tests by turning on the trig tests (except atan2, which isn't fudged for niecza yet).  With TEST_JOBS=8, they make "make spectest" take about an additional minute to run on quad-core MBP. 

[12:37] <phenny> colomon: I'll pass that on when mberends is around.

[12:37] <jnthn> (since role composition happens at the closing } of the class)

[12:39] <jnthn> Changing it to do what b does is the easier of the two options.

[12:39] <moritz> I'd be fine with either way

[12:42] *** im2ee joined
[12:42] *** cognominal_ joined
[12:45] *** cognominal left
[12:46] <jnthn> Let's see if TimToady++ has any opinions. :)

[12:46] *** benabik left
[12:48] *** envi_ left
[12:50] <masak> "Perl[ 5]'s compiler is essentially a 3-pass compiler with interleaved phases: A bottom-up pass; A top-down pass; An execution-order pass"

[12:50] * masak shudders

[12:53] <jnthn> heh...we do top-down and bottom up in Perl 6, and walking the AST is kinda an execution order pass ;)

[12:53] <masak> and they're interleaved o.O

[12:53] <jnthn> ;)

[12:53] <masak> I can't believe I haven't seen it before! Perl 6 is Perl 5! :O

[12:58] <daxim> =:-o

[13:02] <masak> next you'll be telling me they were originated by the same person!

[13:04] * tadzik puts hand on masak's shoulder

[13:09] <masak> eek!

[13:10] *** woosley joined
[13:11] *** Holy_Cow joined
[13:12] *** Holy_Cow left
[13:16] *** tokuhiro_ joined
[13:24] *** alim left
[13:26] *** satyavvd left
[13:33] *** benabik joined
[13:40] *** pmurias joined
[13:55] *** envi_ joined
[13:58] *** sivoais left
[13:58] *** jimmy1980 joined
[13:59] *** jaldhar left
[13:59] *** kaleem left
[14:01] *** sivoais joined
[14:01] *** koban` left
[14:04] *** pmurias left
[14:16] *** wolfman2000 left
[14:18] *** replore_ joined
[14:19] *** replore_ left
[14:20] <flussence> aha, I think I've figured out Text-Tabs-Wrap on nom

[14:20] <flussence> match objects don't implicitly stringify when I call string stuff on them

[14:21] <jnthn> nom: say Match.^methods(:local)

[14:21] <p6eval> nom b00794: OUTPUT«prematch postmatch caps chunks gist Str Numeric Bool ACCEPTS orig from to CURSOR␤»

[14:21] <jnthn> Hm. Str but no Stringy.

[14:21] <flussence> nom: Match ~~ Cool

[14:22] <p6eval> nom b00794:  ( no output )

[14:22] *** mishin_ joined
[14:22] <flussence> b: Match ~~ Cool

[14:22] <p6eval> b 1b7dd1:  ( no output )

[14:22] <flussence> b: say Match ~~ Cool

[14:22] <p6eval> b 1b7dd1: OUTPUT«Bool::True␤»

[14:22] <flussence> nom: say Match ~~ Cool

[14:22] <p6eval> nom b00794: OUTPUT«Bool::False␤»

[14:22] <flussence> there it is

[14:22] <jnthn> ah, that's more likely it

[14:23] <felher> I just saw jnthn++'s grammar debugger and the exporthow-thing seems to be rakudo specific, isn't it? Do the specs specify a method to do something like that (yet)? I.e.: would a fully working P6 implementation of todays specs be able to do something like that without requiring hacking on internals?

[14:24] <jnthn> felher: There's no spec'd way to do it just yet. The Rakudo way isn't hacking on internals really though, it's just sticking some stuff in a package.

[14:24] <jnthn> felher: I'd like to see something standardized there

[14:24] <jnthn> But I'm not totally happy with EXPORTHOW as the mechanism just yet.

[14:24] <jnthn> It's incomplete anyway

[14:25] *** kaleem joined
[14:25] <felher> jnthn: k, thanks a lot. Because it took me quite a while to search for a way to do that with pure specified Perl6. :D

[14:25] <jnthn> felher: Yeah, I didn't find one, so I had to invent something. :)

[14:26] <jnthn> felher: Actually it's the same mechanism CORE.setting uses too.

[14:26] <jnthn> And BOOTSTRAP

[14:26] <im2ee> Hello1 :)

[14:27] <tadzik> hey hey

[14:29] <masak> hey hey hey

[14:29] <felher> jnthn: nice :). I think i first read about it in your 'a hint of meta programming' post.

[14:30] <felher> 'hey' xx 4

[14:31] <im2ee> :)

[14:35] <jnthn> #phasers is in...how long? 

[14:36] * jnthn makes it just under 3 hours

[14:36] *** sivoais left
[14:36] *** wtw left
[14:37] *** sivoais joined
[14:39] *** jimmy1980 left
[14:44] <felher> Speaking of such things as meta-programming and langauge extensions: masak, hows your macro-branch doing? And your HGA? I don't mean to stalk... just too excited about macros... I hope i don't annoy you already?

[14:45] <masak> :)

[14:46] <masak> you're not annoying me. I'm excited too :)

[14:46] <masak> it's going well. nothing new on the HGA. but I'm well on my way with D1.

[14:47] <masak> meant to push the branch yesterday, but didn't get as far as I wanted before becoming too tired to work.

[14:48] *** thou joined
[14:51] <felher> masak++: good to hear that D1 on it's way. I'm eagerly waiting for that branch as i'd really like to play with macros. Especially because macros in P6 are quite a vague term to me. Even after reading the part of the specs about them. :)

[14:52] <jnthn> An implementation will probably help devagueify the spec :)

[14:52] <felher> yeah, hope so :)

[14:53] <[Coke]> was the grant approved?

[14:53] <[Coke]> Or is this pre-emptive?

[14:53] <masak> <masak> nothing new on the HGA.

[14:53] <[Coke]> \o/ (either way)

[14:54] <masak> felher: I'm playing with macros locally, and it's great!

[14:56] <felher> masak: i'm sure it is :D

[14:56] <moritz> nom: sub f(|$arg) { $arg.elems == 1 ?? $arg[0] !! $arg }; say f(1).WHAT; say f(1, 2).WHAT

[14:56] <p6eval> nom b00794: OUTPUT«Int()␤Capture()␤»

[15:03] <jnthn> decommute

[15:14] *** wallberg joined
[15:18] *** icwiener joined
[15:19] <TimToady> sorear: see for https://gist.github.com/1246913 now for shell() that uses a bash-c helper to process args shellishly

[15:21] <sorear> good * #perl6

[15:23] *** tzhs left
[15:23] *** donri left
[15:24] <flussence> today's "wtf am I doing wrong" puzzle: «Not enough positional parameters passed; got 0 but expected between 1 and 5 in sub run-tests at t/sep.t:11», https://github.com/flussence/Text-Tabs-Wrap/blob/master/t/sep.t

[15:26] <masak> well, first off, don't trust that line number.

[15:26] <flussence> I've learned not to trust the filename so far :)

[15:27] <masak> secondly, the siggie in https://github.com/flussence/Text-Tabs-Wrap/blob/master/TestFiles.pm indeed doesn't match.

[15:27] *** bluescreen10 left
[15:27] <sorear> well, your call to sub-tests has 0 paramers.

[15:28] <sorear> you need to make the parameters in TestFiles named.

[15:28] <flussence> oh, whoops

[15:29] <flussence> that named param thing's got me before. It worked fine in ng/niecza...

[15:30] <felher> nom: [lcm] (1,2,3)

[15:30] <p6eval> nom b00794:  ( no output )

[15:30] <felher> nom: [lcm] (1..3) # know issue?

[15:30] <p6eval> nom b00794: OUTPUT«(timeout)maximum recursion depth exceeded␤»

[15:31] <felher> s/know/known

[15:32] * masak submits rakudobug

[15:33] *** mj41 joined
[15:33] <masak> nom: [lcm] 1..3

[15:33] <p6eval> nom b00794: OUTPUT«(timeout)maximum recursion depth exceeded␤»

[15:34] <felher> same problem for [gcd]

[15:34] <felher> nom: [gcd] 1..3

[15:34] <p6eval> nom b00794: OUTPUT«(timeout)maximum recursion depth exceeded␤»

[15:39] *** bluescreen10 joined
[15:40] <flussence> .oO( I'd prefer a line number, even a wrong one, over just seeing «Use of uninitialized value in string context» over and over... )

[15:40] *** mberends joined
[15:41] <mberends> colomon: pre-thanks

[15:41] <phenny> mberends: 12:37Z <colomon> tell mberends You can get an extra 1000+ tests by turning on the trig tests (except atan2, which isn't fudged for niecza yet).  With TEST_JOBS=8, they make "make spectest" take about an additional minute to run on quad-core MBP. 

[15:41] * mberends tries the tests

[15:43] * jnthn home

[15:46] *** cognominal joined
[15:48] *** cognominal_ left
[15:51] *** mberends left
[15:51] *** kfo_ joined
[15:52] * masak decommutes

[15:52] *** masak left
[15:52] *** kfo left
[15:53] <colomon> #phasers in approx 100 minutes?

[15:53] <sorear> #phasers in 96.

[15:54] <sorear> flussence: known nieczabug.  It's only supposed to work for subs declared 'proto' or explicitly 'only'

[15:55] <sorear> niecza: ~Any # flussence 

[15:55] <p6eval> niecza v10-8-g6689415: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 613 (CORE warn @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /tmp/PW8at5SO7L line 0 (MAIN mainline…

[15:56] <flussence> sorear: it's in nom actually :)

[15:56] <sorear> flussence: what do you mean?

[15:56] <sorear> nom: ~Any

[15:56] <p6eval> nom b00794: OUTPUT«Use of uninitialized value in string context␤»

[15:58] <jnthn> that's correct

[15:58] <jnthn> Granted a line number would be nice.

[15:59] *** woosley left
[16:00] *** alester joined
[16:01] <moritz> niecza: make 1

[16:01] <p6eval> niecza v10-8-g6689415: OUTPUT«Unhandled exception: System.InvalidCastException: Cannot cast from source type to destination type.␤  at Builtins.Make (Niecza.Frame fr, Niecza.Variable v) [0x00000] in <filename unknown>:0 ␤  at MAIN.C0_mainline (Niecza.Frame ) [0x00000] in <filename unkno…

[16:02] <moritz> that error should *really* give a better message

[16:02] <moritz> niecza: class A {  has $.x }; A.x

[16:02] <p6eval> niecza v10-8-g6689415: OUTPUT«Unhandled exception: Attempted to access slot x of type object for A␤  at /tmp/H214Q7ytu4 line 0 (MAIN x @ 0) ␤  at /tmp/H214Q7ytu4 line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niec…

[16:03] <moritz> niecza: 'a' ~~ /a/; make 3; say $/.ast

[16:03] <p6eval> niecza v10-8-g6689415: OUTPUT«3␤»

[16:03] <moritz> niecza: 'a' ~~ /a/; make 3, 4; say $/.ast

[16:03] <p6eval> niecza v10-8-g6689415: OUTPUT«Unhandled exception: Excess arguments to CORE make, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE make @ 0) ␤  at /tmp/5azAjadfMS line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_AN…

[16:03] * moritz agrees with niecza, and disagrees with the spectests

[16:04] *** mberends joined
[16:09] <dalek> roast: cd15146 | moritz++ | S05-grammar/action-stubs.t:

[16:09] <dalek> roast: remove non-spec tests for &make with multiple arguments

[16:09] <dalek> roast: review: https://github.com/perl6/roast/commit/cd15146fcd

[16:14] <dalek> rakudo/nom: 7411261 | moritz++ | / (4 files):

[16:14] <dalek> rakudo/nom: implement Match.ast and &make

[16:14] <dalek> rakudo/nom: 

[16:14] <dalek> rakudo/nom: This involves caching Match objects in Cursor.MATCH, because otherwise

[16:14] <dalek> rakudo/nom: the $/ that is passed to an action method is not the same as the one

[16:14] <dalek> rakudo/nom: returned from a match, thus $.ast is lost

[16:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7411261e90

[16:14] *** cognominal_ joined
[16:17] *** cognominal left
[16:18] <moritz> nom: my $x = rx/a/; say 'a' ~~ /<{$x}>/

[16:18] <p6eval> nom b00794: OUTPUT«Null PMC access in find_method('MATCH')␤  in regex <anon> at /tmp/l10YMcmt4C:1␤  in method ACCEPTS at src/gen/CORE.setting:6178␤  in <anon> at /tmp/l10YMcmt4C:1␤  in <anon> at /tmp/l10YMcmt4C:1␤␤»

[16:18] <moritz> nom: my $x = rx/a/; say 'a' ~~ /<$x>/

[16:18] <p6eval> nom b00794: OUTPUT«a␤»

[16:19] *** risou_awy is now known as risou

[16:19] <dalek> rakudo/nom: fc90822 | moritz++ | t/spectest.data:

[16:19] <dalek> rakudo/nom: run two more regex test files

[16:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc90822eba

[16:22] <sorear> nom: 1

[16:22] <p6eval> nom b00794:  ( no output )

[16:24] *** MayDaniel joined
[16:27] <moritz> [Coke], sorear: t/spec/S05-grammar/action-stubs.t fails just one test on niecza, should be trivial to fudge

[16:28] <moritz> ... and it's interesting to see that the one failing test was added as a regression test for rakudo :-)

[16:28] <moritz> (test sharing)++

[16:34] *** kaleem left
[16:35] <sorear> evalbot rebuild rakudo

[16:35] <p6eval> OK (started asynchronously)

[16:37] *** cognominal_ left
[16:38] *** cognominal_ joined
[16:39] *** dual left
[16:41] <moritz> note that this rebuilds b, not nom

[16:42] <moritz> evalbot rebuild noexistent

[16:42] <p6eval> OK (started asynchronously)

[16:43] *** kaare_ joined
[16:46] <sorear> moritz: I started a nom rebuild and it had no effect,  unless it's horribly slow

[16:46] <sorear> nom: 1

[16:46] <p6eval> nom b00794:  ( no output )

[16:46] *** dual joined
[16:46] <sorear> still on b00

[16:48] <moritz> it *is* slow

[16:48] <moritz> Failed allocation of 4096 bytes

[16:48] <moritz> Parrot VM: PANIC: Out of mem!

[16:48] <sorear> wa?

[16:49] <moritz> what is perl ./poll ?

[16:50] <moritz> it uses up 619M of virtual memory

[16:50] <sorear> context?

[16:50] *** molaf left
[16:50] <moritz> on the evalbot box

[16:50] <moritz> host04

[16:50] *** kaleem joined
[16:50] <sorear> uhm, wtf.

[16:50] <sorear> that would be the dalek backend.

[16:51] <sorear> it shouldn't be leaking memory *that* fast

[16:51] <moritz> if I kill it, will it respawn?

[16:51] <sorear> no

[16:51] <moritz> so what's a controlled way of restarting it?

[16:52] <sorear> su to sorear, connect to screen, ^a 1, ^C, up, enter

[16:52] <sorear> which I've just done

[16:53] <moritz> sorear++

[16:53] <moritz> nom rebuild runs again, fwiw

[16:53] <sorear> actually I just ran it in a loop to make restarting it easier

[16:54] * sorear wants some kind of heap-profiler for Perl 5

[16:55] <sorear> dalek-poller is supposed to retain the shas of every commit it reports, so that it only reports a commit once, instead of once per minute

[16:55] <sorear> apparently it's retaining more than that.

[16:56] *** kaleem left
[16:56] *** DAADXRY joined
[16:56] *** NAAAPL8 joined
[16:59] *** cognominal_ left
[16:59] *** cognominal_ joined
[17:02] *** dakkar left
[17:04] *** Chillance joined
[17:08] *** nightlord joined
[17:08] *** localhost left
[17:09] *** localhost joined
[17:11] *** mberends left
[17:17] *** sivoais left
[17:17] *** sivoais joined
[17:17] <moritz> nom: class SVG::Box { }; enum SVG::Plot::AxisPosition <Zero SmallestValue LargestValue>;

[17:17] <p6eval> nom fc9082:  ( no output )

[17:17] <moritz> hm

[17:17] <moritz> not so easy to reproduce

[17:20] <moritz> I get PAST::Compiler can't compile node of type SVG::Plot::AxisPosition

[17:25] <sorear> perl6: "xy" ~~ /<k=.alpha> {make 42} <l=.alpha>/; say $<k>; say $/.ast; say $<l>

[17:25] <p6eval> rakudo fc9082: OUTPUT«Cannot access attributes in a type object␤  in sub make at src/gen/CORE.setting:6130␤  in block <anon> at /tmp/rJOIX0Bkmc:1␤  in regex <anon> at /tmp/rJOIX0Bkmc:1␤  in method ACCEPTS at src/gen/CORE.setting:6192␤  in <anon> at /tmp/rJOIX0Bkmc:1␤  in <anon> at /tmp/…

[17:25] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped b…

[17:25] <p6eval> ..niecza v10-8-g6689415: OUTPUT«#<match from(0) to(1) text(x) pos([].list) named({}.hash)>␤42␤#<match from(1) to(2) text(y) pos([].list) named({}.hash)>␤»

[17:25] <sorear> moritz: still seems to be a bit of an issue with &make in nom

[17:26] *** masak joined
[17:26] <masak> \o/

[17:26] <sorear> o/ MASAK

[17:26] <moritz> sorear: I don't know if you can call make like that

[17:26] <moritz> sorear: or more to the point, I just copied the old implementation, which suffered from the same problem

[17:26] <sorear> S05:896

[17:27] <sorear> also S05:2771

[17:27] <masak> moritz: I didn't think of it before, but the regex injection is still qualitatively different from code-in-regexes, even if they are similarly powerful. the former is in the hands (potentially) of the user, the latter in the hands of the developer.

[17:28] <dalek> roast: 9e7eee0 | Coke++ | S05-grammar/action-stubs.t:

[17:28] <dalek> roast: niecza fudging.

[17:28] <dalek> roast: 

[17:28] <dalek> roast: moritz++ for the hint.

[17:28] <dalek> roast: review: https://github.com/perl6/roast/commit/9e7eee07d9

[17:28] <sorear> when Perl 6.0 is released, it has to have something like "no re 'eval'"

[17:29] <dalek> niecza: 39d9e6e | Coke++ | t/spectest.data:

[17:29] <dalek> niecza: run fudged test.

[17:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/39d9e6ef76

[17:29] <[Coke]> moritz, sorear: Thanks, fudged.

[17:29] <moritz> niecza: say &make.signature.perl

[17:29] <p6eval> niecza v10-8-g6689415: OUTPUT«Unhandled exception: Unable to resolve method signature in class Sub␤  at /tmp/OEyoT7hTy1 line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2116 (CORE module…

[17:29] <moritz> sorear: where is &make defined in niecza?

[17:29] <sorear> I kind of like being able to write IRC bots that accept regexes in untrusted user input

[17:29] <sorear> CORE.setting

[17:29] <sorear> sub make($x) ...

[17:30] <moritz> and where is Niecza::builtin('make') defined?

[17:30] <TimToady> sorear: speaking of injections, did you seem my bash-c helper?

[17:31] <moritz> #phasers time

[17:32] <masak> ooh!

[17:33] *** mishin_ left
[17:33] <sorear> TimToady: Yes I did.  I'm afraid I don't understand the two-string / string-array mapping terribly well

[17:34] <TimToady> all of the dequoting is done by the helper now, which gets the entire command as a single argument

[17:35] <TimToady> all the magic happens in the eval "$@"

[17:35] <sorear> it's a single argument?

[17:35] <TimToady> windows relies on the app to decode args, alas

[17:36] *** uasi left
[17:36] <colomon> moritz: for the record, with the new nom, every time I try ABC I get Null PMC access in find_method('new')

[17:36] <TimToady> fortunately, the shell() command relies on the shell to do that, unlike run()

[17:37] <sorear> TimToady: there's some complicated ugly code in the Mono WinAPI emulator which splits Arguments into something suitable for execve

[17:37] <jnthn> colomon: Running it with --ll-exception and gisting the backtrace could give me a clue

[17:38] <TimToady> run needs execve, but shell doesn't

[17:38] <colomon> jnthn: https://gist.github.com/1248611

[17:39] <jnthn> colomon: Oh...are you running it with -n?

[17:39] <colomon> jnthn: if I specify the proper include directory, it gets a bit further before dying

[17:39] <jnthn> ok, thanks.

[17:40] *** ab5tract joined
[17:40] <sorear> TimToady: wait, are you on windows or *nix?

[17:40] <colomon> which makes it sound like that's some sort of "module not found" issue, or perhaps it's reading old versions of the module compiled under a previous rakudo?  

[17:42] <TimToady> *nix

[17:42] <TimToady> I am assuming if you say shell, you have a bash available somewhere

[17:43] <sorear> does djgpp/cygwin bash.exe count?

[17:43] <TimToady> after all, I'm running stty, which isn't exactly portable either... :)

[17:44] <[Coke]> git llog

[17:45] <jnthn> fatal: Not a git repository :)

[17:45] <moritz> git: 'llog' is not a git command. See 'git --help'.

[17:45] <moritz> :-)

[17:46] <TimToady> and bash.exe is probably fine, if you can get a helper to run it without re-introducing an unwanted level of quoting

[17:47] <dalek> rakudo/nom: 01d3a6b | duff++ | docs/release_guide.pod:

[17:47] <dalek> rakudo/nom: Update release info

[17:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01d3a6b78b

[17:47] <TimToady> the *nix solution is relying on #!/bin/bash to fire up the bash

[17:47] *** sayu joined
[17:47] <TimToady> pity you can't just run 'bash -c' and pass the rest as the other string

[17:48] <sorear> looks like older (1998) Perl5 just used libc spawnw()

[17:48] *** nightlord left
[17:49] <sorear> I like how I have a detached head 13 years in the past and most of the code hasn't moved

[17:49] <TimToady> well, 1998 Perl5 wasn't trying to run on the CLI :)

[17:51] <sorear> what?  SvPV used to be able to return NULL?

[17:51] *** supernovus joined
[17:52] *** daniel-s left
[17:52] <dalek> rakudo/nom: 2eb6118 | duff++ | docs/release_guide.pod:

[17:52] <dalek> rakudo/nom: oops, forgot to remove Riga from the future

[17:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2eb61188d0

[17:52] <supernovus> In the newest nom, is there a way to get a dump of a Match object? There used to be $match.perl  but now that seems to do the same thing as $match.Str.

[17:52] <moritz> supernovus: nope, it's NYI; but it would be fun to write one (hint, hiint :-)

[17:54] <supernovus> moritz: Ah ha. I need to learn more about Match objects first. I'm trying to find a list of submatches (this is from a grammar parse) in a parent match. I'll dig into the code, maybe I'll come up with a .perl method while I'm at it :-)

[17:55] <moritz> supernovus: .caps gives you a list of submatches, ordered by starting position

[17:55] <moritz> (list of pairs of key => submatch, to be exact)

[17:56] <supernovus> moritz: fantastic, I'll start there :-)

[17:57] <moritz> nom: say Match.^attributes

[17:57] <p6eval> nom fc9082: OUTPUT«$!orig $!from $!to $!CURSOR $!ast $!list $!hash␤»

[17:57] <TimToady> moritz: note that, according to S12:2414, .^attributes is supposed to default to :excl, just like .^methods and .^parents are supposed to (and don't yet)

[17:59] <moritz> why .^parents?

[17:59] <TimToady> so the user can think of their outermost class as the root

[18:00] <TimToady> and for consistency, but I see the argument for inconsistency

[18:00] <TimToady> and it doesn't make much difference for attributes, since Any and Cool don't have any

[18:01] <TimToady> but I really miss :excl every time someone says .^methods

[18:03] <TimToady> so I guess one could argue that only .^methods needs the intermediate default

[18:04] <moritz> nom: 'aa' ~~ /<alpha>+/; say $<alpha>.WHAT

[18:04] <p6eval> nom 01d3a6: OUTPUT«Parcel()␤»

[18:04] <moritz> nom: say (1, 2).list.Parcel

[18:04] <p6eval> nom 01d3a6: OUTPUT«1 2␤»

[18:04] <moritz> nom: say (1, 2).Parcel

[18:04] <p6eval> nom 01d3a6: OUTPUT«Method 'Parcel' not found for invocant of class 'Parcel'␤  in <anon> at /tmp/5dei4bBxt3:1␤  in <anon> at /tmp/5dei4bBxt3:1␤␤»

[18:05] <moritz> nom: say (1, 2).join(', ')

[18:05] <p6eval> nom 01d3a6: OUTPUT«1, 2␤»

[18:05] <moritz> nom: say ("a", "b").perl

[18:05] <p6eval> nom 01d3a6: OUTPUT«("a", "b")␤»

[18:06] <moritz> nom: say (a => 'b').perl

[18:06] <p6eval> nom 01d3a6: OUTPUT«"a" => "b"␤»

[18:07] <moritz> nom: 'aa' ~~ /<alpha>+/; say $/.hash.WHAT

[18:07] <p6eval> nom 01d3a6: OUTPUT«EnumMap()␤»

[18:07] <moritz> nom: 'aa' ~~ /<alpha>+/; say $/.hash.perl

[18:07] <p6eval> nom 01d3a6: OUTPUT«alpha        a a␤»

[18:08] <moritz> nom: my %h = a => 1; say %h.EnumMap;

[18:08] <p6eval> nom 01d3a6: OUTPUT«Method 'EnumMap' not found for invocant of class 'Hash'␤  in <anon> at /tmp/6nHdYQjXh6:1␤  in <anon> at /tmp/6nHdYQjXh6:1␤␤»

[18:11] *** mberends joined
[18:12] <supernovus> that's interesting, its parsing a grammar, and the stringified match shows the full match, but any optional captures such as <attributes>* while being parsed, are not included in the caps (and thus $node<attributes> returns nothing...) Am I sensing a spec change or is this just a bug?

[18:13] <sorear> ok, it looks like 0aaad0ff was the important commit, and it looks like it may have been related to ithreads?

[18:13] <sorear> network being spotty now

[18:13] <sorear> o/ mberends

[18:13] <moritz> supernovus: what does $<attributes>.elems contain?

[18:13] <moritz> supernovus: likely a bug, either in you or in rakudo

[18:14] <mberends> \o sorear, Niecza spectest count is over 7000 with the trig tests added. Shall I commit the extended spectest.data?

[18:14] <sorear> TimToady: suppose I'm a Win32 programmer, and I have $filename and $command_tail.  What function should I call to do CreateProcess with no reparsing?  run($filename, $command_tail)

[18:14] <sorear> mberends: why not?

[18:15] <mberends> indeed why not :-)

[18:16] <sorear> then go ahead

[18:17] <dalek> niecza: 0e35fd0 | mberends++ | t/spectest.data:

[18:17] <dalek> niecza: [t/spectest.data] add trig tests made possible by colomon++

[18:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0e35fd0447

[18:17] <dalek> niecza: 85199bf | mberends++ | t/spectest.data:

[18:17] <dalek> niecza: Merge branch 'master' of https://github.com/sorear/niecza

[18:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/85199bf172

[18:19] *** sayu left
[18:21] <supernovus> $node<attribute>.elems returns 0

[18:22] <moritz> so it matched zero times

[18:22] <supernovus> Yeah, the strange part is, it parses the document... you would think if it didn't match, it would reject the whole thing.

[18:23] <moritz> it's ok for * to match zero repetitions

[18:23] <sorear> whee, I think I understand it.

[18:23] * sorear out.

[18:24] <moritz> that doesn't make the match fail

[18:25] <supernovus> moritz: but if I try something illegal like <test blah/> it fails, whereas if I put a valid <test name="blah"/> it parses, shows the full string if I stringify $node, but doesn't have the <attribute> sub-match available, even though it must have parsed it...

[18:25] <TimToady> sorear, mberends: the why-not would be that $command_tail would not be portable to *nix, if we restrict run to execve semantics

[18:26] <TimToady> and the point of splitting out shell() was to do that, I thought

[18:27] <TimToady> so shell("$file $command_tail") is closure to the win semantics

[18:29] <TimToady> or run needs to accept multiple args, and glue them back together for win

[18:30] <TimToady> or we define some other function between shell() and run() that does the win file/arg thing

[18:30] <mberends> TimToady: true, I have some C code somewhere to iron out the Win32/*nix wrinkles, not sure how well that would port to C#. I hope I can find it, only half a chance because I'm in away from home for two days.

[18:30] <supernovus> Yeah, if I remove the * from the <attributes> rule, it returns the found attribute (but also makes it so that elements MUST have an attribute.) So for some reason, if you use * on a subrule, it will match the rule, but won't include it in the captures.

[18:35] <masak> wow, 7000 passing Niecza spectests!

[18:36] <mberends> masak: like you said, Niecza doesn't feel like it does very much less than Rakudo

[18:36] <colomon> mberends: do you know anything about making pixmap graphics work in GTK?

[18:38] <mberends> colomon: yes, a little. I've been reading lots of http://docs.go-mono.com. I guess Mandelbrot needs to draw individual pixels. I'll take a look for that.

[18:39] <colomon> mberends++ # I got far enough to figure out I needed some sort of Pixmap or "cairo surface", but I've got no idea how to hook those up to do anything useful yet.

[18:40] <mberends> colomon: niecza/examples/gtk-clock.pl uses a Cairo context

[18:41] *** bluescreen10 left
[18:41] <moritz> nom: 'aa' ~~ /<alpha>*/; say $/.caps>>.key

[18:42] <p6eval> nom 01d3a6: OUTPUT«alpha alpha␤»

[18:42] <supernovus> nom: grammar T { rule TOP { ^ <element> $ }; rule element { '<' <name> <attribute>* '/>' }; rule attribute { <name> '=' '"' <value>? '"' }; token name { <.ident>+ [ ':' <.ident>+ ]? }; token value { <-[\"]>+ }; }; my $m = T.parse('<test this="that"/>'); say $m<element><name>.perl; say $m<element><attribute>.perl;

[18:42] <p6eval> nom 01d3a6: OUTPUT«test␤()␤»

[18:42] <supernovus> nom: grammar T { rule TOP { ^ <element> $ }; rule element { '<' <name> <attribute> '/>' }; rule attribute { <name> '=' '"' <value>? '"' }; token name { <.ident>+ [ ':' <.ident>+ ]? }; token value { <-[\"]>+ }; }; my $m = T.parse('<test this="that"/>'); say $m<element><name>.perl; say $m<element><attribute>.perl;

[18:42] <p6eval> nom 01d3a6: OUTPUT«test␤this="that"␤»

[18:43] <supernovus> Bug? Or intentional behaviour?

[18:45] <moritz> supernovus: I'll look into it

[18:45] <dalek> rakudo/nom: 08e1061 | moritz++ | src/core/ (3 files):

[18:45] <dalek> rakudo/nom: .perl methods for Match and EnumMap

[18:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08e10613dd

[18:47] <supernovus> moritz: Thanks, I'm still playing with it over here, to see what I can find. It's been a while since I played with grammars (the last time was porting Exemel::Grammar from alpha to ng) so I'm a bit rusty now :-P

[18:48] *** wallberg left
[18:51] *** sivoais left
[18:51] *** sivoais joined
[18:51] <supernovus> Interesting, if you change the * to a + it does the same thing (matches, but doesn't include it in the caps).

[18:52] *** risou is now known as risou_awy

[18:53] *** risou_awy is now known as risou

[18:55] <masak> sounds buggy.

[18:56] *** daxim left
[18:56] <masak> nom: grammar G { rule TOP { <foo>* }; rule foo { \w } }; say G.parse("aaaaaa")

[18:56] <p6eval> nom 01d3a6: OUTPUT«␤»

[18:57] * masak submits rakudobug

[18:57] <masak> nom: grammar G { rule TOP { <foo>+ }; rule foo { \w } }; say G.parse("aaaaaa")

[18:57] <p6eval> nom 08e106: OUTPUT«␤»

[18:57] <masak> nom: grammar G { rule TOP { <foo> }; rule foo { \w } }; say G.parse("aaaaaa")

[18:57] <p6eval> nom 08e106: OUTPUT«␤»

[18:57] <masak> nom: grammar G { rule TOP { <foo> }; rule foo { \w } }; say ?G.parse("aaaaaa")

[18:57] <p6eval> nom 08e106: OUTPUT«Bool::False␤»

[18:57] <masak> hm. maybe I'm doin' something rong.

[18:58] <mberends> colomon: I get as far as http://docs.go-mono.com, then Mono Libraries, Cairo, Context Class, Members, then Public Members. There is no method to draw only one pixel. The nearest approximation might be a line from a point to itself, if that is not truncated.

[19:00] <masak> what's the best way do do something like <EXPR> (and infixes and prefixes etc) in a user-defined grammar?

[19:00] <supernovus> nom: grammar G { rule TOP {  <foo> }; rule foo { \w+ } }; say G.parse("aaa");

[19:00] <p6eval> nom 08e106: OUTPUT«aaa␤»

[19:01] <masak> huh.

[19:01] <supernovus> nom: grammar G { rule TOP {  <foo>+ }; rule foo { \w } }; say G.parse("aaa"); # move the + on the other hand...

[19:01] <p6eval> nom 08e106: OUTPUT«␤»

[19:01] <masak> supernovus: I don't like this.

[19:01] <masak> feels incorrect.

[19:02] <moritz> yep, something with quantified named rules is very off

[19:02] <supernovus> masak: that's what I think too... the above should work, and create a submatch called $<foo> which should contain ('a','a','a')

[19:02] <masak> aye.

[19:03] *** birdwindupbird joined
[19:03] *** birdwindupbird left
[19:04] *** Alias_ joined
[19:07] *** MayDaniel left
[19:08] *** Alias left
[19:09] *** mtk left
[19:10] *** mtk joined
[19:10] *** risou is now known as risou_awy

[19:11] <colomon> b: grammar G { rule TOP {  <foo>+ }; rule foo { \w } }; say G.parse("aaa");

[19:11] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Confused at line 22, near "\x{2}grammar G"␤»

[19:11] <colomon> b: grammar G { rule TOP {  <foo>+ }; rule foo { \w } }; say G.parse("aaa");

[19:11] <p6eval> b 1b7dd1: OUTPUT«␤»

[19:11] <colomon> niecza: grammar G { rule TOP {  <foo>+ }; rule foo { \w } }; say G.parse("aaa");

[19:11] <p6eval> niecza v10-11-g85199bf: OUTPUT«G()␤»

[19:12] <jnthn> sigspace?

[19:12] <jnthn> perl6: grammar G { rule TOP {  <foo>+ }; rule foo { \w } }; say

[19:12] <jnthn> gah

[19:12] <p6eval> niecza v10-11-g85199bf: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/2kyy8e6KdF line 1 (EOF):␤------> [32m TOP {  <foo>+ }; rule foo { \w } }; say[33m⏏[31m<EOL>[0m␤␤Un…

[19:12] <p6eval> ..pugs, rakudo 08e106: OUTPUT«␤»

[19:12] <jnthn> perl6: grammar G { rule TOP {  <foo>+ }; token foo { \w } }; say G.parse("aaa")

[19:13] <p6eval> pugs: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/j4vhQgZCeN line 1, column 59 - line 2, column 1␤»

[19:13] <p6eval> ..niecza v10-11-g85199bf: OUTPUT«#<match from(0) to(3) text(aaa) pos([].list) named({"foo" => (#<match from(0) to(1) text(a) pos([].list) named({}.hash)>, #<match from(1) to(2) text(a) pos([].list) named({}.hash)>, #<match from(2) to(3) text(a) pos([].list) named({}.hash)>).list.item}.has…

[19:13] <p6eval> ..rakudo 08e106: OUTPUT«aaa␤»

[19:13] <jnthn> If you do rule, it wants <.ws>

[19:13] <jnthn> That won't match aa

[19:13] <jnthn> (e.g. won't match two alphanumerics next to each other)

[19:14] <supernovus> b: grammar T { rule TOP { ^ <element> $ }; rule element { '<' <name> <attribute>* '/>' }; rule attribute { <name> '=' '"' <value>? '"' }; token name { <.ident>+ [ ':' <.ident>+ ]? }; token value { <-[\"]>+ }; }; my $m = T.parse('<test this="that"/>'); say $m<element><name>.perl; say $m<element><attribute>.perl;

[19:14] <p6eval> b 1b7dd1: OUTPUT«Match.new(␤ from => 1,␤ orig => "<test this=\"that\"/>",␤ to   => 5,␤)␤[Match.new(␤ from => 6,␤ orig => "<test this=\"that\"/>",␤ to   => 17,␤ named => {␤  value => [␤    Match.new(␤     from => 12,␤     orig => "<test this=\"that\"/>",␤     to   => 16,␤    ),␤  ],␤  na…

[19:16] <supernovus> b: grammar T { rule TOP { ^ <element> $ }; rule element { '<' <name> <attribute>* '/>' }; rule attribute { <name> '=' '"' <value>? '"' }; token name { <.ident>+ [ ':' <.ident>+ ]? }; token value { <-[\"]>+ }; }; my $m = T.parse('<test this="that"/>'); say $m<element><name>.Str; say @($m<element><attribute>).perl;

[19:16] <p6eval> b 1b7dd1: OUTPUT«test␤[Match.new(␤ from => 6,␤ orig => "<test this=\"that\"/>",␤ to   => 17,␤ named => {␤  value => [␤    Match.new(␤     from => 12,␤     orig => "<test this=\"that\"/>",␤     to   => 16,␤    ),␤  ],␤  name =>    Match.new(␤    from => 6,␤    orig => "<test this=\"that\…

[19:17] *** tokuhir__ joined
[19:17] <supernovus> uhg, still, but yeah, in ng it returns the matches, unlike in the current nom. 

[19:18] <supernovus> err, still ugly that was meant to say...

[19:18] <moritz> supernovus: in b, use $/.pretty if you want something pretty

[19:19] <moritz> supernovus: in nom, upgrade to the commit I'm about to push, and simply   say $/

[19:19] <supernovus> moritz++

[19:19] <dalek> rakudo/nom: 21b04a8 | moritz++ | src/core/Match.pm:

[19:19] <dalek> rakudo/nom: more informative Match.gist

[19:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/21b04a8633

[19:19] <moritz> supernovus: it doesn't fix the problem with the captures, it just produces something more pretty

[19:20] <supernovus> awesome

[19:20] *** tokuhiro_ left
[19:20] <supernovus> debugging stuff is always good :-)

[19:20] <jnthn> supernovus: Have you tried Grammar::Tracer or Grammar::Debugger?

[19:22] <supernovus> jnthn: not yet, those sound like bloody useful tools, I will add them to my toolkit! :-)

[19:26] <supernovus> gah, I can't wait until panda works again, manually tracking down dependencies makes me feel like I'm back in 1996, running Slackware...

[19:27] <tadzik> :)

[19:28] <dalek> rakudo/nom: 8d71c8c | moritz++ | src/core/Match.pm:

[19:28] <dalek> rakudo/nom: Match.perl needs to be a multi

[19:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d71c8c002

[19:30] *** envi_ left
[19:36] <moritz> fwiw, mandelbrot 501x501 takes about 5m12s on current nom, and 37s on niecza

[19:36] <moritz> (usually I generate 201x201 as a benchmark)

[19:37] <PerlJam> niecza++

[19:37] <moritz> nom: say 312/37

[19:37] <p6eval> nom 08e106: OUTPUT«8.43243243243243␤»

[19:37] <PerlJam> (that also gives rakudo a target to shoot for as far as improved performanc.

[19:39] *** thou left
[19:40] <jnthn> moritz: Was that on master or optimizer?

[19:40] <moritz> jnthn: nom

[19:41] <tadzik> it's funny, because in Polish you sometimes say "nom" if you mean "yep"

[19:41] <jnthn> moritz: yeah, by master I menat nom ;)

[19:41] <jnthn> gah :)

[19:41] <jnthn> moritz: oh...did you break S02-types/declare.t temporarily?

[19:42] <jnthn> Looks like that's what the Match.perl should be multi patch woulda fixed

[19:44] <jnthn> moritz: Also, test 17 consistently fails in S05-grammar/inheritance.t.

[19:45] <[Coke]> (wow, ww ages ago:) git llog does a log for me in local time with nice formatting.

[19:46] <im2ee> have to go... Good night! :)

[19:46] <tadzik> o/

[19:46] <jnthn> o/

[19:46] <im2ee> o/

[19:47] *** im2ee left
[19:47] <dalek> rakudo/nom: 47d772a | jnthn++ | src/Perl6/Grammar.pm:

[19:47] <dalek> rakudo/nom: Fix segfault when using state variables in mainline.

[19:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/47d772af5c

[19:49] <ingy> o/

[19:50] * ingy just implemented % %% and <x>22-33 in Pegex

[19:50] <ingy> moritz: you around?

[19:50] <ingy> wanna see something cool?

[19:52] <PerlJam> I'd like to see something cool  :)

[19:52] <tadzik> Int is Cool!

[19:53] * jnthn tags 92192 as testneeded

[19:53] <tadzik> link? I have a tuit in handy

[19:54] <tadzik> ok, got it

[19:54] <ingy> rule_part: <rule_item>1-2 % /~<WS>(<PERCENT><PERCENT>?)<WS>~/

[19:54] <ingy> is cool

[19:55] <ingy> it's the rule from pegex.pgx that parses % and %% and it uses %

[19:56] <ingy> it matches <x> or <x> % <y>

[19:56] <ingy> 1 or two rule items separated by % or %%

[19:56] <ingy> cool! :D

[19:57] <ingy> <x>0-1  ==  <x>?

[19:57] <jnthn> tadzik: 99734 too if you like

[19:58] <jnthn> tadzik: https://rt.perl.org/rt3/Ticket/Display.html?id=99734

[19:58] <tadzik> I never know where to put a test :0

[19:58] <ingy> <x>0+  ==  <x>*

[19:58] <tadzik> :)

[19:58] <ingy> etc

[19:58] <PerlJam> that is pretty cool.

[19:59] <PerlJam> It's also the first implementation of %/%% I think.  (Did TimToady put it in STD yet?)

[19:59] <ingy> well pegex != p6regex... but yeah!

[20:00] <masak> PerlJam: Niecza has %.

[20:00] <PerlJam> sorear++

[20:00] <ingy> sorear++

[20:00] <PerlJam> (I'm assuming he implmemented it :)

[20:00] <masak> aye :)

[20:00] <ingy> heh

[20:01] <jnthn> tadzik: And if you're really having fun, 99938 also :)

[20:01] <ingy> 10e0 Niecza developers...

[20:04] <jnthn> tadzik: And finally, 99942. OK, that's my ticket wrangling for today :)

[20:04] <PerlJam> 10e0 Niecza developers sitting on the channel, 10e0 developers sitting on the channel, take one down, pass him around  ....  then put him back!

[20:09] <dalek> Heuristic branch merge: pushed 35 commits to rakudo/optimizer by jnthn

[20:12] <dalek> roast: 7425d60 | tadzik++ | S12-methods/method-vs-sub.t:

[20:12] <dalek> roast: Tests for RT #92192

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/7425d606a0

[20:12] <dalek> roast: a16ea83 | tadzik++ | S06-signature/positional-placeholders.t:

[20:12] <dalek> roast: Test for RT #99734

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/a16ea836cb

[20:12] <dalek> roast: 99872de | tadzik++ | S04-declarations/state.t:

[20:12] <dalek> roast: Unskip test for RT #99938

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/99872dece7

[20:12] <dalek> roast: 763ffeb | tadzik++ | S03-metaops/reduce.t:

[20:12] <dalek> roast: Test for RT #99942

[20:12] <dalek> roast: review: https://github.com/perl6/roast/commit/763ffeb37a

[20:12] *** mj41 left
[20:12] <tadzik> jnthn: ok, now you close those :)

[20:15] <jnthn> tadzik: All closed \o/

[20:15] <jnthn> tadzik++

[20:16] <tadzik> jnthn++ for the actual closing :)

[20:22] *** vlixes joined
[20:25] <masak> 'night, #perl6

[20:26] <tadzik> 'night

[20:27] <masak> ɔouɐɹqop

[20:27] *** masak left
[20:28] <jnthn> wait, what?!

[20:28] <jnthn> oh...

[20:28] <jnthn> Very clever :P

[20:29] <tadzik> ;)

[20:32] <diakopter> .

[20:35] *** ab5tract left
[20:40] *** djanatyn is now known as sad-djan

[20:49] *** kaare_ left
[20:50] <dalek> rakudo/optimizer: 9d797f6 | jnthn++ | src/Perl6/Optimizer.pm:

[20:50] <dalek> rakudo/optimizer: Include line numbers to CHECK failure output.

[20:50] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/9d797f6454

[20:51] *** thou joined
[20:54] *** thou left
[20:57] *** leprevost joined
[21:08] *** sad-djan is now known as djanatyn

[21:10] *** ab5tract joined
[21:13] *** LoRe_ is now known as LoRe

[21:16] *** benabik left
[21:20] *** c1sung left
[21:20] *** c1sung joined
[21:25] *** packetknife joined
[21:30] *** ab5tract left
[21:31] *** wamba left
[21:32] <[Coke]> mberends: are you fudging atan2, or would you like me to?

[21:34] <mberends> [Coke]: please do  it, I'm working on more Niecza Gtk stuff

[21:34] <[Coke]> 'sfine. I'm on a roll there.

[21:35] <[Coke]> Will work on it after $DAYJOB.

[21:35] <mberends> \o/

[21:36] <[Coke]> gah. red bull does not give me wings, it gives me HIIIIIICUPS.

[21:37] <diakopter> s/wings/runs/

[21:37] <[Coke]> O_o

[21:38] *** cotto left
[21:38] *** p0nb1k1 joined
[21:39] <dalek> rakudo/optimizer: b2ceda1 | jnthn++ | src/binder/multidispatch.c:

[21:39] <dalek> rakudo/optimizer: Don't need to worry about definedness constraint on candidates that would never match anyway.

[21:39] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b2ceda1442

[21:39] <dalek> rakudo/optimizer: f80dca3 | jnthn++ | src/Perl6/Actions.pm:

[21:39] <dalek> rakudo/optimizer: Set type on self (just the type of the package we're currently in).

[21:39] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/f80dca3023

[21:39] <dalek> rakudo/optimizer: b7316c1 | jnthn++ | src/Perl6/Optimizer.pm:

[21:39] <dalek> rakudo/optimizer: Don't try to compile-time analyze dispatches involving generic types.

[21:39] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b7316c1851

[21:39] <dalek> niecza: ecd62ba | mberends++ | examples/gtk-clock.pl:

[21:39] <dalek> niecza: [examples/gtk-clock.pl] window is resizeable after sorear++ fixed issue #57

[21:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ecd62ba1ad

[21:42] *** p0nb1k1 is now known as ponbiki

[21:47] *** soh_cah_toa joined
[21:50] *** soh_cah_toa_ joined
[21:52] *** soh_cah_toa left
[21:53] *** soh_cah_toa_ is now known as soh_cah_toa

[21:58] *** leprevost left
[22:01] *** cotto joined
[22:03] *** thelazydeveloper joined
[22:03] *** thelazydeveloper left
[22:07] *** mberends left
[22:11] <sorear> good * #perl6

[22:11] <diakopter> *

[22:11] <[Coke]> ho, sorear.

[22:17] *** jeffreykegler joined
[22:20] *** jeffreykegler left
[22:25] *** alester left
[22:31] <[Coke]> mberends - ah, that's not a normal test file.

[22:32] <[Coke]> so, I take it back. too much of a PITA to do at the moment.

[22:45] *** cognominal joined
[22:48] *** cognominal_ left
[22:52] *** whiteknight joined
[22:54] <[Coke]> S02-lexical-conventions/begin_end_pod.t - that second test should never be run, yes?

[22:55] <tadzik>   yes

[22:55] <tadzik> that's the point of the test :)

[22:56] <[Coke]> then I'm changing it to a nok to make it more obvious.

[22:56] <sorear> how about changing it to a flunk?

[22:57] <[Coke]> I am not familiar with that test function, but sure. (I assume: fails all the time.)

[23:10] *** Chillance left
[23:14] <[Coke]> done.

[23:15] <dalek> roast: 72da761 | Coke++ | S02-lexical-conventions/ (2 files):

[23:15] <dalek> roast: make the "don't run this test" tests more obvious

[23:15] <dalek> roast: review: https://github.com/perl6/roast/commit/72da76196e

[23:23] *** icwiener left
[23:29] <dalek> rakudo/optimizer: 3d89708 | jnthn++ | src/ (4 files):

[23:29] <dalek> rakudo/optimizer: Very preliminary implementation of inlining chosen multi-dispatch candidates. So far, a routine is an inlining candidate iff it consists of a single statement, made entirely of pirops and its arguments, with strictly one use of each argument. Regresses two test files, which ain't bad given this is the very first shot.

[23:29] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/3d89708a95

[23:30] <tadzik> that looks promising

[23:30] <tadzik> does that inline $a + $b for example?

[23:30] <jnthn> tadzik: If it knows enough about their types, yes.

[23:31] <jnthn> tadzik: And if that type information lets us resolve the dispatch candidate at compile time.

[23:31] <tadzik> so Int $a = 5; Int $b = 7; $a + $b can possibly inline, or that'd have to be native ints?

[23:32] <jnthn> Here it reports it inlined the + call there.

[23:32] <jnthn> We do have a bit of a problem though :(

[23:32] <jnthn> A load of multi candidates are marked with :D and :U

[23:33] <jnthn> This totally hoses inlining.

[23:34] <jnthn> Anyway, this is a reasonable start.

[23:36] <jnthn> Hmm...the optimizer seems to be missing analysing some things... :S

[23:41] <jnthn> oh, curious...something to do with pasttype chain.

[23:44] <jnthn> oh my, that's cary.

[23:44] <jnthn> *scary

[23:47] <diakopter> found a bug?

[23:49] <jnthn> diakopter: no :)

[23:49] <jnthn> Figured it out, i think.

[23:53] *** ponbiki left
[23:55] *** jaldhar joined
