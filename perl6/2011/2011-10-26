[00:12] *** whiteknight joined
[00:17] *** thou left
[00:22] *** aloha left
[00:24] *** replore joined
[00:25] *** hugme left
[00:26] *** Juerd left
[00:27] *** [Coke] left
[00:27] *** masak left
[00:27] *** Util left
[00:27] *** tadzik left
[00:27] *** PerlJam left
[00:27] *** thou joined
[00:29] *** aloha joined
[00:31] *** jaldhar left
[00:32] *** Sarten-X left
[00:39] *** abercrombie joined
[00:39] *** Sarten-X joined
[01:07] *** envi_ joined
[01:09] *** jaldhar joined
[01:16] *** Util joined
[01:16] *** masak joined
[01:16] *** [Coke] joined
[01:17] *** PerlJam joined
[01:20] *** Entonian left
[01:29] *** Juerd joined
[01:43] *** tadzik joined
[02:03] <japhb> phenny ask moritz now that [Coke] has confirmed I have a CLA filed with TPF, what do I need to do next to apply for a Rakudo commitbit?

[02:06] *** whiteknight left
[02:40] *** packetknife joined
[02:41] *** envi_ left
[02:42] *** wolfman2000 joined
[02:44] *** tokuhiro_ joined
[03:25] *** cooper left
[03:31] *** cooper joined
[03:36] <sorear> good * #perl6

[03:36] <moritz> good morning

[03:36] <sorear> I need to find a way to /ignore comments directed to or from p6eval

[03:36] *** japhb_ joined
[03:36] <sorear> I'm doing the ?sorear|iecza search and it's mostly GlitchMr

[03:38] <japhb_> sorear, I'm at my Perl Mongers meeting, and someone just asked about bindings to native libraries from Perl 6, and I remembered someone had connected to GTK using niecza.  Do you remember who it was, and (pushing my luck here) where that project is?

[03:39] <moritz> japhb_: niecza repo, examples/gtk-*

[03:39] *** Yappoko___ left
[03:39] *** PZt left
[03:39] *** apejens left
[03:39] *** apejens joined
[03:39] <moritz> japhb_: mostly mberends++

[03:39] <japhb_> moritz++ # Thank you!

[03:40] *** Yappoko___ joined
[03:40] *** Trashlord left
[03:40] *** domidumont left
[03:40] *** lue left
[03:40] *** domidumont1 joined
[03:40] * sorear needs to make time to drop by sandiego.pm some time

[03:41] *** lue joined
[03:41] *** Trashlord joined
[03:42] *** thou left
[03:44] <abercrombie> Does lines() read from $*ARGFILES or @*ARGS?

[03:45] <moritz> $*ARGFILES

[03:46] *** cooper left
[03:46] <moritz> japhb_: as for the commit bit, you don't need to do anything. If pmichaud agrees, you'll get one. I've contacted him by email

[03:46] <abercrombie> Thanks. But I found if I modify @*ARGS, then the subsequent lines() will read from what I set

[03:46] *** cooper joined
[03:47] *** packetknife left
[03:47] <moritz> well, $*ARGFILES does take it list of filenames from @*ARGS (and if empty defaults to $*IN)

[03:47] <moritz> so the two are connected, and it's this connection you are seeing

[03:48] <japhb_> moritz, thank you again (re: commitbint)

[03:48] <japhb_> *commit bit

[03:48] <abercrombie> Gotcha. Thank you.

[03:48] *** molaf joined
[03:59] *** PZt joined
[04:05] *** molaf left
[04:05] *** alc joined
[04:07] *** cooper left
[04:09] <PerlJam> re commit bit for japhb_ --  +1

[04:10] <japhb_> PerlJam, thank you.  :-)

[04:11] *** soh_cah_toa_ left
[04:27] *** abercrombie left
[04:31] *** lue left
[04:31] *** Yappoko___ left
[04:31] *** apejens left
[04:31] *** overrosy left
[04:31] *** pochi left
[04:31] *** japhb left
[04:34] *** overrosy joined
[04:37] *** lue joined
[04:37] *** Yappoko___ joined
[04:37] *** apejens joined
[04:37] *** pochi joined
[04:37] *** japhb joined
[04:46] *** colomon left
[04:49] *** colomon joined
[05:06] *** wolfman2_ joined
[05:08] *** wolfman2000 left
[05:12] *** orafu left
[05:12] *** orafu joined
[05:13] *** uniejo joined
[05:15] *** uniejo left
[05:17] *** SHODAN joined
[05:19] *** japhb_ left
[05:38] *** daniel-s left
[05:53] *** daniel-s joined
[06:05] *** wtw joined
[06:12] <moritz> japhb: welcome as a rakudo committer!

[06:13] <moritz> oops, accidentally sent the mail to rakudobug, not to pmichaud

[06:13] * sorear was wondering about that :D

[06:14] <sorear> How confused would perl6-ers be if niecza started producing files with names like Run.Test.dll instead of Test.dll?

[06:14] <moritz> moritzfail

[06:14] <moritz> not more than that it generates .dll files at all :-)

[06:17] <moritz> .exe and .dll on linux take some time to get used to

[06:18] <japhb> moritz, excellent, thanks!

[06:20] *** koban joined
[06:25] <masak> moritz: I forwarded Robert's reply about RT not finding anything on "given".

[06:25] <masak> apparently, since "given" is a registered user, RT assumes that was what we were searching for and produces nothing.

[06:25] <moritz> masak: thanks, seen it

[06:26] <masak> also apparently, this is a "feature", but at least Robert puts it in quotes and says that it might change in later versions.

[06:27] *** finanalyst joined
[06:27] <moritz> I hope it does, it makes the search DOSable

[06:28] <masak> how do you mean, "DOSable"?

[06:28] <finanalyst> rakudo: class D {has $.a = 9; has $.b = $.a eq 0 or $.a gt 20 ?? $.a !! 20 }

[06:28] <p6eval> rakudo 97aa73: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:syntax error, unexpected COMMA (',')␤   in file '(file unknown)' line 240␤␤»

[06:28] <masak> finanalyst: 'eq' is for strings.

[06:28] <finanalyst> rakudo: class E {has $.a = 9; has $.b = ($.a eq 0 or $.a gt 20) ?? $.a !! 20 }

[06:28] <p6eval> rakudo 97aa73:  ( no output )

[06:29] <masak> finanalyst: 'or' has loose precedence, as opposed to '||'

[06:29] <moritz> simply by registering the $n most common search terms as user names

[06:29] <finanalyst> masak: i thought it was general and for numbers too

[06:29] <masak> moritz: oh, I wasn't even thinking of it in terms of that; I just figgered it's in no way a feature and just Wrong.

[06:29] <masak> finanalyst: what made you think that?

[06:29] <finanalyst> any way, it works with brakets and when not in a class, but not in a class definition

[06:30] <finanalyst> masak: now you ask, I can't remember

[06:30] <masak> rakudo: class E { has $.a = 9; has $.b = $.a }; say E.new.b

[06:30] <p6eval> rakudo 97aa73: OUTPUT«9␤»

[06:30] <masak> rakudo: class E { has $.a = 9; has $.b = $.a ?? $.a !! 20 }; say E.new.b

[06:30] <p6eval> rakudo 97aa73: OUTPUT«9␤»

[06:30] <finanalyst> masak: trying to keep up with changes is difficult

[06:30] <masak> finanalyst: worksforme

[06:31] <masak> finanalyst: yeah but in this case nothing changed :)

[06:31] <finanalyst> masak: class E works, class D creates an error

[06:31] <masak> finanalyst: 'eq' is for strings in perl 5 too.

[06:31] <masak> finanalyst: that's because you used 'or'.

[06:31] <masak> finanalyst: which has loose precedence.

[06:31] <masak> that is, looser than '='

[06:32] <finanalyst> masak: when the expression is used in a normal expression, I got what i expected

[06:32] <masak> so it parses as '(has $.b = $.a eq 0) or $.a gt 20 ?? $.a !! 20'

[06:32] <finanalyst> when in a class definition, i got a funny IMCC error

[06:32] <finanalyst> ah, now I see

[06:33] <masak> finanalyst: if you get what you wanted with '=' and 'or', it's by luck and you're not testing all cases.

[06:33] <sorear> o/ masak!

[06:33] <finanalyst> masak: i'm not trying to test all cases. I got an error that was strange, so I tried to reproduce it

[06:33] <masak> sorear: \o

[06:34] <masak> finanalyst: as far as that goes, it's great. keep it up :)

[06:34] <masak> finanalyst: I should be explicit about separating my thanks for your bug reporting from my critique of your choice of operators. :)

[06:35] <finanalyst> masak: although my syntax was wrong, it seems to me that somehow the error should be trapped better

[06:35] <masak> definitely.

[06:35] <sorear> masak: how foolish would I be to merge /serialize in the weekend before the release?

[06:35] <sorear> masak: do you think I have enough users to care about waiting for it to stablize? :)

[06:35] <finanalyst> masak: is == still the test operator for numbers, as in perl5?

[06:36] <masak> sorear: not sure, but I'm willing to test it against my mid-sized application before you merge. I'm sure mberends et all will do the same.

[06:36] <masak> finanalyst: yes.

[06:36] <finanalyst> masak: thanx. for some reason I thought that == had been eliminated in favour of a more general operator

[06:37] <sorear> masak: maybe we need something like plumage-smoke for Perl6land

[06:37] <masak> finanalyst: '== < > <= >=' is for numbers, 'eq lt gt le gt' is for strings.

[06:37] <masak> sorear: yes.

[06:37] <masak> finanalyst: there are these interesting "phantom improvements" that people think have happened to Perl 6 but that haven't. yours is a bit unusual.

[06:38] <sorear> finanalyst: it's sort of the other way around.  Str/Num allomorphism means you have to be clear what comparison type you're using

[06:38] <masak> the most common phantom improvement is where people believe that bareword keys in hashes are outlawed. we tell them "no, that's still fine" and they go "O RLY?"

[06:38] <sorear> finanalyst: Perl 6's version of the allomorphism is a bit weaker and we have an === operator that can compare anything

[06:39] <masak> Perl 6's allomorphism is cool. :)

[06:39] <finanalyst> i'm at a stage where i understand perhaps over 50% of perl6, but nowhere near everything. I'm also anxious to use perl6 for all the cool things. But I keep getting tripped up by changes

[06:40] <sorear> TimToady++ # introducing me to the concept of allomorphism.  Took longer to "get" than, say, monads

[06:40] <sorear> I'm an old Perl5 hand, and I like to think of 42 and "42" as fundamentally the same, so I don't use === much

[06:40] <finanalyst> so when i've misunderstood something, i'm not sure whether its because i never did understand it, or i understood it once, and the language changed 

[06:40] <sorear> I know my code isn't careful to keep them straight

[06:41] <sorear> It's possible Perl 6 is ultimately a simpler language than Perl 5.  It's certainly much easier to parse.

[06:41] <finanalyst> allomorphism????? wooo what?? where can i read up on it

[06:42] <sorear> I've long since forgotten, if I got you a link it would be from Google

[06:42] <finanalyst> ok

[06:46] <masak> finanalyst: you'll find that it's a fancy term for something that you already know. :) "scalar" is the allomorphic thing in Perl 5 for strings, ints, floats.

[06:48] <sorear> well yeah

[06:49] <sorear> all good ideas are the same as things I already know ;)  but knowing the terms helps a lot just the same.

[06:49] <masak> "allomorphic, n, Linguistics. one of the alternate contextually determined phonological shapes of a morpheme, as I<en> in I<oxen>, which is an allomorph of the English plural morpheme."

[06:49] <masak> sorear: agreed.

[06:50] <sorear> oh hey

[06:50] <masak> oh, sorry. that was the entry for "allomorph".

[06:50] * sorear plunks on'yomi/kun'yomi into a more general mental bucket.

[06:57] <masak> I wonder what the exact relation between allomorphy and type punning is.

[07:26] *** xinming joined
[07:36] * masak uses @AoA»[0] in real code and feels pretty great about it

[07:37] *** wk left
[08:00] <moritz> http://www.perlmonks.org/?node_id=933807 that rakudo dog would be called "Null PMC Access", no? :-)

[08:03] *** agentzh joined
[08:06] <sorear> InvalidCastException here I'm sure :-)

[08:06] <moritz> aye :-)

[08:06] <moritz> niecza: +'a'

[08:06] <p6eval> niecza v10-61-gbacff10: OUTPUT«␤Unhandled Exception: System.FormatException: Unknown char: a␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) […

[08:06] <moritz> or this one as second candidate :-)

[08:08] *** mj41_nb joined
[08:08] *** mj41 joined
[08:16] *** koban left
[08:22] <dalek> roast: be0ff5f | moritz++ | S12-construction/new.t:

[08:22] <dalek> roast: test nextwith() in .new method

[08:22] <dalek> roast: review: https://github.com/perl6/roast/commit/be0ff5f467

[08:23] <moritz> rakudo: try { die 1; CATCH { die 2 } }

[08:23] <p6eval> rakudo 97aa73: OUTPUT«2␤  in block <anon> at /tmp/ke9dCRSykE:1␤  in block <anon> at /tmp/ke9dCRSykE:1␤  in block <anon> at /tmp/ke9dCRSykE:1␤  in <anon> at /tmp/ke9dCRSykE:1␤»

[08:26] *** dakkar joined
[08:27] <dalek> roast: c3c9fb7 | moritz++ | S04-exception-handlers/catch.t:

[08:27] <dalek> roast: test throwing exceptions in CATCH blocks

[08:27] <dalek> roast: review: https://github.com/perl6/roast/commit/c3c9fb772d

[08:27] * moritz closes another 2-year old bug

[08:28] <moritz> nom: ...('foo')

[08:28] <p6eval> nom 97aa73:  ( no output )

[08:28] <moritz> nom: !!!('foo')

[08:28] <p6eval> nom 97aa73: OUTPUT«Stub code executed␤  in block <anon> at /tmp/kKGKvghO_P:1␤  in <anon> at /tmp/kKGKvghO_P:1␤»

[08:38] <moritz> rakudo: try { die 'omg!'; CATCH { say '$!'; } }

[08:38] <p6eval> rakudo 97aa73: OUTPUT«$!␤omg!␤  in block <anon> at /tmp/oCb_62sHiz:1␤  in block <anon> at /tmp/oCb_62sHiz:1␤  in <anon> at /tmp/oCb_62sHiz:1␤»

[08:45] <dalek> niecza/serialize: 9083142 | sorear++ | / (7 files):

[08:45] <dalek> niecza/serialize: Switch to single-AppDomain execution

[08:45] <dalek> niecza/serialize: 

[08:45] <dalek> niecza/serialize: As I thought, remote method invocation seems to have been the major

[08:45] <dalek> niecza/serialize: bottleneck in /serialize.  Using a lighter-weight isolation protocol

[08:45] <dalek> niecza/serialize: has improved performance:

[08:45] <dalek> niecza/serialize: 

[08:45] <dalek> niecza/serialize: (time mono-sgen run/Niecza.exe -C CORE)

[08:45] <dalek> niecza/serialize: master:  user    0m30.898s

[08:45] <dalek> niecza/serialize: before:  user    1m26.453s

[08:45] <dalek> niecza/serialize: now:     user    0m29.246s

[08:45] <dalek> niecza/serialize: 

[08:45] <dalek> niecza/serialize: The new procedure uses only Assembly-level isolation: runtime

[08:45] <dalek> niecza/serialize: assemblies are renamed to have names starting with Run.; so CORE.dll

[08:45] <dalek> niecza/serialize: is the compiler's CORE and Run.CORE.dll is the user's.  This seemed

[08:45] <dalek> niecza/serialize: preferable over the reverse to avoid name clashes with perversely

[08:45] <dalek> niecza/serialize: named user modules.

[08:45] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/9083142af6

[08:45] <sorear> this is the "one big optimization" I was talking about yesterday.  glad to see numbers confirming my hunches

[08:46] <moritz> \o/

[08:46] <moritz> rakudo: my %a; %a{ CATCH{} }

[08:46] <p6eval> rakudo 97aa73:  ( no output )

[08:47] <sorear> interestingly, the time required for 'mono-sgen run/Niecza.exe -e "say 2 + 2"'  is statistically significant faster (3.8s vs 6.0s)

[08:47] <sorear> diakopter: ^^^

[08:47] <moritz> what about niecza startup time?

[08:48] <dalek> roast: af82544 | moritz++ | S04-exception-handlers/catch.t:

[08:48] <dalek> roast: RT #80864

[08:48] <dalek> roast: review: https://github.com/perl6/roast/commit/af825448c1

[08:48] <sorear> moritz: won't be affected until I redo the bootstrap at the end of the month

[08:48] <moritz> sorear: ok

[08:48] <moritz> perl6: do { CATCH { }; CATCH { } }

[08:48] <p6eval> niecza v10-61-gbacff10: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Limit one CATCH phaser per block, please. at /tmp/udH7y94R5a line 1:␤------> [32mdo { CATCH { }; CATCH { } [33m⏏[31m}[0m␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE …

[08:48] <p6eval> ..rakudo 97aa73: OUTPUT«===SORRY!===␤only one CATCH block allowed at line 1, near "}"␤»

[08:48] <p6eval> ..pugs b927740:  ( no output )

[08:48] <sorear> I now have the challenge of getting "make reboot" working again before Oct31

[08:49] <moritz> sorear: that error message doesn't match my understanding of English

[08:50] <sorear> moritz: it's a pun off a phrase commonly seen on advertisements in the USA - Great deal!!! Limit one $ITEM per customer.

[08:50] <moritz> ie I'm missing either a verb (if Limit is a noun), or a subject (if 'Limit' is a verb)

[08:50] <sorear> the implied verb is "is"

[08:50] <moritz> sorear: ah

[08:50] <sorear> aka "sorear being too cute"

[08:52] <dalek> roast: 7bf7582 | moritz++ | S04-exception-handlers/catch.t:

[08:52] <dalek> roast: only one CATCH per block, please

[08:52] <dalek> roast: review: https://github.com/perl6/roast/commit/7bf75824b5

[08:54] * moritz is pleased to announce that all but one rakudobugs related to 'try' or 'CATCH' have been closed. mls_++

[08:55] * sorear -> sleeeep

[08:56] <jnthn> moritz: \o/

[08:56] <jnthn> mls_++ indeed!

[08:57] <jnthn> moritz: Which one remains?

[08:58] <moritz> jnthn: one related to warn

[08:58] <moritz> jnthn: which currently just cheats, and writes to $*ERR

[08:58] <jnthn> ah, that may be resolved by an mls patch I didn't get to yet.

[09:00] <moritz> nom: -> { return 1 }

[09:00] <p6eval> nom 97aa73:  ( no output )

[09:01] <moritz> shouldn't we be able to catch that at compile time, since return is supposed to be lexotic?

[09:01] <moritz> nom: -> { return 1 }.()

[09:01] <p6eval> nom 97aa73: OUTPUT«Attempt to return outside of any Routine␤  in block <anon> at /tmp/buE64W0CCC:1␤  in block <anon> at /tmp/buE64W0CCC:1␤  in <anon> at /tmp/buE64W0CCC:1␤»

[09:04] <jnthn> moritz: We could

[09:05] <moritz> otoh ... return isn't special syntax, so it's just a call

[09:05] * moritz did want to override return occasionally

[09:05] <moritz> erm, on exactly one occasion so far

[09:06] <moritz> nom: sub f { my sub return($x) { nextwith(2*x) }; return 5 }; say f

[09:06] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&x' called (line 1)␤»

[09:06] <moritz> nom: sub f { my sub return($x) { nextwith(2*$x) }; return 5 }; say f

[09:06] <p6eval> nom 97aa73: OUTPUT«No dispatcher in scope␤  in sub return at /tmp/r_CL9MbfVW:1␤  in sub f at /tmp/r_CL9MbfVW:1␤  in block <anon> at /tmp/r_CL9MbfVW:1␤  in <anon> at /tmp/r_CL9MbfVW:1␤»

[09:07] <moritz> ah, because &return isn't a proper sub, but rather defined as  my &return := BLOCK

[09:07] <jnthn> Well, also because...where are you going to nextwith to in a sub? :)

[09:07] <jnthn> (an only sub, that is)

[09:07] <moritz> right :-)

[09:08] <moritz> should be more like &OUTER::return()

[09:10] <jnthn> oh, I see what you were trying to do

[09:10] <jnthn> CORE::return perhaps :)

[09:10] <moritz> is that implemented?

[09:11] <moritz> nom: say CORE

[09:11] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&CORE' called (line 1)␤»

[09:11] <moritz> nom: say CORE::return

[09:11] <p6eval> nom 97aa73: OUTPUT«Could not find symbol 'CORE::&return'␤  in block <anon> at /tmp/wVyNz17DDv:1␤  in <anon> at /tmp/wVyNz17DDv:1␤»

[09:11] <moritz> seems not :-)

[09:11] <jnthn> ah, no, didn't do that yet

[09:12] <moritz> nom: sub f { my sub return($x) { pir::find_outer_lex__PS('&return').(2*$x) }; return 5 }; say f

[09:12] <p6eval> nom 97aa73: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:syntax error, unexpected PREG, expecting '(' ('$P100')␤    in file '(file unknown)' line 77177405␤␤»

[09:12] <jnthn> That won't work because return in outer is...the return you're currently defining :)

[09:12] <jnthn> You'd have to look 2 frames out. :)

[09:12] <moritz> nom: sub f { my sub return($x) { pir::find_caller_lex__PS('&return').(2*$x) }; return 5 }; say f

[09:13] <p6eval> nom 97aa73: OUTPUT«maximum recursion depth exceeded␤  in sub infix:<*> at src/gen/CORE.setting:2306␤  in sub return at /tmp/b7ZCXDD4yx:1␤  in sub return at /tmp/b7ZCXDD4yx:1␤  in sub return at /tmp/b7ZCXDD4yx:1␤  in sub return at /tmp/b7ZCXDD4yx:1␤  in sub return at /tmp/b7ZCXDD4yx:1␤  …

[09:13] <moritz> nom: sub f { my sub return($x) { pir::find_caller_lex__PS('&return').(10) }; return 5 }; say f

[09:13] <p6eval> nom 97aa73: OUTPUT«(signal SEGV)maximum recursion depth exceeded␤»

[09:13] <moritz> nom: sub f { my sub return($x) { callframe(1).my<&return>.(10) }; return 5 }; say f

[09:13] <p6eval> nom 97aa73: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Any'␤  in <anon> at src/gen/Metamodel.pm:3177␤  in sub return at /tmp/NJ0ewLo9ph:1␤  in sub return at /tmp/NJ0ewLo9ph:1␤  in sub f at /tmp/NJ0ewLo9ph:1␤  in block <anon> at /tmp/NJ0ewLo9ph:1␤  in <anon> at …

[09:14] <moritz> nom: sub f { my sub return($x) { callframe(2).my<&return>.(10) }; return 5 }; say f

[09:14] <p6eval> nom 97aa73: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Any'␤  in <anon> at src/gen/Metamodel.pm:3177␤  in sub return at /tmp/WCTRCwHqoW:1␤  in sub f at /tmp/WCTRCwHqoW:1␤  in block <anon> at /tmp/WCTRCwHqoW:1␤  in <anon> at /tmp/WCTRCwHqoW:1␤»

[09:14] <moritz> meh

[09:14] <jnthn> one more :)

[09:14] <moritz> nom: sub f { my sub return($x) { callframe(3).my<&return>.(10) }; return 5 }; say f

[09:14] <p6eval> nom 97aa73: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Any'␤  in <anon> at src/gen/Metamodel.pm:3177␤  in sub return at /tmp/RxihKxF1K9:1␤  in sub f at /tmp/RxihKxF1K9:1␤  in block <anon> at /tmp/RxihKxF1K9:1␤  in <anon> at /tmp/RxihKxF1K9:1␤»

[09:14] <jnthn> hmm.

[09:14] <jnthn> oh, wait...

[09:14] <jnthn> is callframe lexical or caller chain?

[09:14] <moritz> caller chain

[09:15] <jnthn> Well, the setting isn't in the caller chain :)

[09:15] <jnthn> It's in the lexical one.

[09:15] <moritz> right

[09:15] * jnthn should implement CORE, OUTER etc.

[09:22] <mls_> nom: sub f { my sub return($x) { pir::find_lex_skip_current__PS('&return').(10) }; return 5 };

[09:22] <p6eval> nom 97aa73:  ( no output )

[09:22] <mls_> (morning!)

[09:23] *** envi_ joined
[09:23] *** Vlavv_ joined
[09:23] <moritz> nom: sub f { my sub return($x) { pir::find_lex_skip_current__PS('&return').(10) }; return 5 }; say f

[09:23] <p6eval> nom 97aa73: OUTPUT«(signal SEGV)maximum recursion depth exceeded␤»

[09:23] <moritz> still finds my return, not the outer

[09:24] <moritz> nom: sub f { my $r := pir::find_lex_skip_current__PS('&return'); my sub return($x) {$r(2 * $x) }; return 5 }; say f

[09:24] <p6eval> nom 97aa73: OUTPUT«10␤»

[09:24] <moritz> \o/

[09:25] *** Vlavv` left
[09:28] <moritz> nom: class A is int { has $.x }

[09:28] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤Method 'parrot_vtable_mappings' not found for invocant of class 'Perl6::Metamodel::NativeHOW'␤»

[09:29] <jnthn> Well, that's LTA...

[09:29] * jnthn wonders if you should be allowed to do that.

[09:30] <moritz> no

[09:30] <jnthn> nom: native A is int { }

[09:30] <p6eval> nom 97aa73:  ( no output )

[09:30] <jnthn> nom: native A is int { has $.x }

[09:30] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤A native cannot have attributes at line 1, near " }"␤»

[09:30] <moritz> I remember that deriving from native types may not change storage

[09:30] <jnthn> right.

[09:30] <jnthn> It should fail but currently it fails for the wrong reasons.

[09:31] *** alc left
[09:32] *** kfo_ joined
[09:33] <moritz> akshually I found a small fail in the error message that is supposed to show up, and wanted to demonstrate that :-)

[09:34] <moritz> I guess I'll just commit it (after testing)

[09:34] <moritz> nqp::bindattr(1, '$!foo', int, 3)

[09:35] <moritz> nom: nqp::bindattr(1, '$!foo', int, 3)

[09:35] <p6eval> nom 97aa73: OUTPUT«get_string() not implemented in class 'int'␤  in block <anon> at /tmp/4cCrXBqNSA:1␤  in <anon> at /tmp/4cCrXBqNSA:1␤»

[09:35] *** kfo left
[09:35] <moritz> nom: nqp::bindattr(1, int, '$!foo', 3)

[09:35] <p6eval> nom 97aa73: OUTPUT«Can not bind non-existant attribute '$!foo' on class 'int'␤  in block <anon> at /tmp/lPj9ip4WsN:1␤  in <anon> at /tmp/lPj9ip4WsN:1␤»

[09:36] <dalek> nqp: fd63797 | moritz++ | src/6model/reprs/P6 (2 files):

[09:36] <dalek> nqp: fix copy&pastos

[09:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fd637972d3

[09:37] <moritz> nom: int.^add_attribute(int, 1)

[09:37] <p6eval> nom 97aa73: OUTPUT«Method 'dispatch:<.^>' not found for invocant of class 'int'␤  in block <anon> at /tmp/bx5Gs5aHcn:1␤  in <anon> at /tmp/bx5Gs5aHcn:1␤»

[09:37] * moritz fails to show the failing fail :-)

[09:39] <masak> I had a "caught exceptions too happily" situation today. one day it will sink in that I can't just check for failure, period.

[09:39] <masak> moritz: the sooner your exception work lands, the better :)

[09:40] <moritz> masak: agreed

[09:40] <moritz> but it must be done before it can land :/

[09:40] <moritz> nom: say X::Base.new

[09:40] <p6eval> nom 97aa73: OUTPUT«Base.new(message => Mu)␤»

[09:46] * moritz has been plowing his way through nqp/src/6model/reprs/

[09:46] <moritz> and all the .h files and most .c files look pretty understandable

[09:46] <moritz> but P6opaque.c... wow.

[09:48] <jnthn> :)

[09:48] <jnthn> moritz: Well, it is basically computing C structure layouts along its way :)

[09:48] <jnthn> Then making sure we can efficiently GC-mark the appropriate parts of them. :)

[09:48] <mls_> it creates a entry->offset table

[09:49] <jnthn> It's more fiddly than hard, really.

[09:49] <moritz> jnthn: I noticed the struct building. Which is why it does the crazy casting to char and then back to a void pointer and then back to a PMC pointer

[09:50] <jnthn> crazy code is crazy

[09:50] <mls_> (btw, why is the "hint" not simply called "slot"?)

[09:51] <jnthn> mls_: We may not always be able to use it.

[09:51] <moritz> hysterical raisins, it seems

[09:51] <jnthn> No, I still find hint fairly sane

[09:52] <mls_> yes, but in that case UNKNOWN_SLOT (aka -1)

[09:52] <jnthn> It conveys "here's a clue that you may be able to use to lookup faster"

[09:52] <jnthn> mls_: No, it's more than that.

[09:52] <jnthn> mls_: We can only rely on those to work out in SI situations.

[09:52] <moritz> jnthn: so far it complains that the attribute doesn't exist if hint == 0

[09:52] <moritz> does that mean that some MI situations are still NYI?

[09:53] <jnthn> No

[09:53] <jnthn> MI works

[09:53] <jnthn> It just means we can't do that particular optimization in the case of MI.

[09:53] <mls_> see: slot = hint >= 0 && !(repr_data->mi) ? hint : ...

[09:54] <jnthn> MI is still way better now than in the original way I was going to do P6opaque though :)

[09:55] <moritz> ah, I see(-ish)

[09:55] <moritz> in MI we have the additional try_get_slot call

[09:55] <jnthn> nod

[09:55] <tadzik> jnthn: btw, did you notice the time jump in settings compilation/spectests after the optimizer merge?

[09:56] <jnthn> tadzik: Yeah

[09:57] <jnthn> tadzik: The spectests are about the worst case for the optimizer.

[09:57] <jnthn> tadzik: No real loops or anything.

[09:57] <jnthn> tadzik: Setting compilation - it's worth the time spent there.

[09:57] <tadzik> oh, so that's the reason for what I noticed recently

[09:57] <tadzik> sure

[09:57] <jnthn> yeah but...for me it's not actually a huge jump.

[09:57] <tadzik> :)

[09:57] <tadzik> I can imagine

[09:58] <jnthn> Well but I mean as a percentage.

[09:58] <tadzik> hmm

[09:58] <jnthn> It wasn't like "add optimizer, now it's twice as slow"

[09:58] <tadzik> for me, it was

[09:58] * moritz eagerly awaits his 12-core $work machine

[09:59] <jnthn> OK, that's...odd.

[09:59] * jnthn wonders why there are such different relative differences.

[09:59] *** que joined
[09:59] <tadzik> http://irclog.perlgeek.de/perl6/2011-10-19#i_4590435

[10:00] <que> hi perl6

[10:00] *** replore left
[10:00] *** envi_ left
[10:00] <tadzik> there is a possibility that there were many, many more tests though :)

[10:00] <tadzik> hello que 

[10:00] *** envi_ joined
[10:00] <tadzik> I should check out flussence++'s graphs from those dates

[10:00] <que> I have a small question about mutable immutable 

[10:00] <tadzik> that's like a month

[10:01] <que> my Int $i =5;$i =6; $i.say ; #6

[10:01] * moritz hopes that immutables are not mutable :-)

[10:01] <tadzik> well, it's not that dramatic it seems (number of tests)

[10:01] <jnthn> tadzik: S05-rx/mass.t can be time consuming

[10:01] <jnthn> lunch - bbs

[10:02] <tadzik> . o O ( launch )

[10:02] <que> Int is a immutables type ,but it mutable

[10:02] <moritz> que: the variable $i is mutable

[10:02] <moritz> nom: 5 = 6

[10:02] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤Method 'lvalue' not found for invocant of class 'Float'␤»

[10:02] <moritz> wow, didn't we have better error messages for that?

[10:02] <que> $i is Int object?

[10:03] <tadzik> yes

[10:03] <moritz> que: $i is a variable which holds an Int object

[10:03] <moritz> nom: my $i := 5; $i = 6

[10:03] <que> Int is immutables?

[10:03] <tadzik> hmm

[10:03] <p6eval> nom 97aa73: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/G3JOnQW7KY:1␤  in <anon> at /tmp/G3JOnQW7KY:1␤»

[10:03] <tadzik> true. Int is immutable, $i can hold one immutable object, and then another

[10:03] <tadzik> the object doesn't get changed, the value of $i does

[10:04] <tadzik> it's not like it's a constant

[10:04] <que> can you show me a example ? immutable's example

[10:05] <moritz> num: my $i := 3; $i = 6

[10:05] <moritz> nom: my $i := 3; $i = 6

[10:05] <tadzik> num num num :)

[10:05] <p6eval> nom 97aa73: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/QPGSxc4U7M:1␤  in <anon> at /tmp/QPGSxc4U7M:1␤»

[10:05] <moritz> que: there you go

[10:05] <moritz> que: $i is bound to an Int, so you can't assign a new value to it

[10:05] <que> thanks moritz

[10:05] <moritz> que: does that make sense to you?

[10:05] <moritz> nom: 5++

[10:05] <p6eval> nom 97aa73: OUTPUT«Cannot assign to a non-container␤  in sub postfix:<++> at src/gen/CORE.setting:2270␤  in block <anon> at /tmp/mWTnM2GQzP:1␤  in <anon> at /tmp/mWTnM2GQzP:1␤»

[10:05] <moritz> another example

[10:05] <que> not ?

[10:06] * moritz can't parse that line

[10:06] <moritz> que: the other important thing is that there are no methods in class Int which modify an Int instance

[10:06] <tadzik> Date is immutable, you can't change the month. But keeping a Date in $a, you can assign a different Date to $a, and Date does not get changed, $a does. It's the same with Int, iiuc

[10:07] <moritz> compare

[10:07] <moritz> nom: my @a = 3, 4; @a.push(5); say @a # the push mutates @a

[10:07] <p6eval> nom 97aa73: OUTPUT«3 4 5␤»

[10:07] <moritz> there aren't any comparable methods in Int

[10:08] *** lue left
[10:09] *** saaki left
[10:10] *** MayDaniel joined
[10:13] <que> moritz:my $i := 5 ,$i must be 5 can't assign it 6,but can the example show Int is immutable?

[10:14] <moritz> que: no. The absense of a feature (mutability) can never be proven by examples

[10:14] <moritz> que: I can just show you examples how other objects mutate, and show that they don't work for Int. Maybe that convinces you, maybe not

[10:15] <que> show me

[10:16] <moritz> I did

[10:16] *** envi_ left
[10:16] <que> Oh?? thanks

[10:17] *** [Sec] joined
[10:17] <moritz> masak: re https://gist.github.com/1293853, in role R[ {{{$foo}}}] { },  what does $foo contain? the AST of a parameter list?

[10:18] *** saaki joined
[10:19] *** envi_ joined
[10:21] *** lue joined
[10:24] *** grondilu joined
[10:24] <grondilu> rakudo: my int $n; say $n = 42;

[10:24] <p6eval> rakudo 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in sub say at src/gen/CORE.setting:5281␤  in block <anon> at /tmp/0oeqA8MH_x:1␤  in <anon> at /tmp/0oeqA8MH_x:1␤»

[10:25] <moritz> and if yes, does that mean that arbitrary parts of syntax can be replaced with a {{{ }}} block?

[10:25] <moritz> std: my $name; quasi { class {{{$name}}} { } }

[10:25] <grondilu> I thought native integer were implemented?

[10:25] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/kVz_Nl_DW5 line 1:␤------> [32mmy $name; quasi { class {{{$name}}} [33m⏏[31m{ } }[0m␤    expecting infix or meta-infix␤Parse f…

[10:25] <moritz> grondilu: yes, just  probably not every case

[10:25] <moritz> nom: my int $x = 3; say $x

[10:25] <p6eval> nom 97aa73: OUTPUT«3␤»

[10:25] <moritz> nom: my int $x = 3; say $x = 4

[10:25] <p6eval> nom 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in sub say at src/gen/CORE.setting:5281␤  in block <anon> at /tmp/kjpskFwLvE:1␤  in <anon> at /tmp/kjpskFwLvE:1␤»

[10:26] <grondilu> oh, ok

[10:26] <moritz> that's a parrot Integer leaking through

[10:26] <moritz> jnthn: ^^

[10:27] <moritz> nom: sub f($x) { $x * 2 }; say f(my int $a = 3)

[10:27] <p6eval> nom 97aa73: OUTPUT«6␤»

[10:27] <moritz> nom: sub f($x) { $x * 2 }; my int $a; say f($a = 3)

[10:27] <p6eval> nom 97aa73: OUTPUT«6␤»

[10:27] <moritz> nom: sub f($x) { $x * 2 }; my int $a; say f(($a = 3).gist)

[10:27] <p6eval> nom 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/S3WY55l0dR:1␤  in <anon> at /tmp/S3WY55l0dR:1␤»

[10:27] <moritz> nom: my int $x = 2; $x.gist

[10:27] <p6eval> nom 97aa73:  ( no output )

[10:27] <moritz> nom: my int $x = 2; say $x.gist

[10:27] <p6eval> nom 97aa73: OUTPUT«2␤»

[10:30] * moritz sighs. We had such a nice insulation between parrot and rakudo types, and now they leak through when using native types :/

[10:35] *** alc joined
[10:35] <dalek> roast: 4cafc7d | moritz++ | S02-types/native.t:

[10:35] <dalek> roast: RT #102244, native ints leaking through in assginment

[10:35] <dalek> roast: review: https://github.com/perl6/roast/commit/4cafc7d551

[10:39] *** Trashlord left
[10:48] <jnthn> moritz: It's just PAST::Compiler trying to be helpful and failing.

[10:49] <jnthn> moritz: File ticket (if you didn't already); it's probably something in assign_op

[10:49] <jnthn> (Like it doesn't call box_native_if_needed on the PAST tree it produces)

[10:51] <jnthn> Another thing to deal with in QAST - let the language configure its box/unbox regime.

[10:56] *** grondilu left
[10:57] * masak would like a guide for pronouncing "QAST"

[11:01] <jnthn> .oO( d e qast )

[11:01] <masak> :)

[11:02] *** que left
[11:09] *** ab5tract joined
[11:09] <masak> moritz: I think a lot of people who have the wrong expectations on junctions really want the amb special form from Lisp: http://community.schemewiki.org/?amb -- and IIRC a year or so back nothingmuch stopped by, had those expectations, and then implemented amb as a CPAN module.

[11:09] <masak> maybe that should go in the FAQ :)

[11:14] <masak> ah, here's his blog post about it: http://blog.woobling.org/2009/08/abstracting-ambiguity.html

[11:14] <masak> but I seem to misremember about the CPAN module.

[11:17] <masak> perl6: sub foo { our $a = 5 }; sub bar { say our $a }; bar; foo; bar

[11:17] <p6eval> rakudo 97aa73, niecza v10-61-gbacff10: OUTPUT«Any()␤5␤»

[11:17] <p6eval> ..pugs b927740: OUTPUT«␤␤»

[11:17] <masak> \o/

[11:17] <masak> ...wonder what model Pugs has for 'our' variables...

[11:34] *** finanalyst left
[11:36] *** DataLinkDKT joined
[11:41] *** Patterner left
[11:42] <moritz> jnthn: ticket filed

[11:43] *** Psyche^ joined
[11:43] *** Psyche^ is now known as Patterner

[11:56] *** JimmyZ joined
[11:58] <moritz> masak: fix it :-)

[11:59] <masak> Pugs? yeah, in time... :)

[11:59] <masak> I still haven't dived into setting up a Pugs development environment, but thanks to ingys explorations and yours, it feels quite approachable now.

[12:03] *** que joined
[12:03] *** replore_ joined
[12:04] <que> moritz: can you give me an example about mutable

[12:04] <moritz> que: did you like my example with .push on the Array?

[12:05] <que> I need to read it again

[12:05] * moritz wonders why he does all the typing when his examples are ignored anyway

[12:05] * masak hugs moritz 

[12:06] <moritz> thanks

[12:07] <masak> moritz: just saw your question at http://irclog.perlgeek.de/perl6/2011-10-26#i_4616492

[12:07] <masak> moritz: when I wrote it I pictured it as one single parameter, not a parameter list. but yes, AST.

[12:07] <masak> moritz: I think it makes more sense to pass in lists of ASTs, not ASTs of lists, into macros.

[12:07] <moritz> masak: now I'm mightily confused

[12:08] <masak> let's hear it.

[12:08] <moritz> masak: because I thought that you can only substitute terms with {{{ $var }}} holes

[12:08] *** colomon left
[12:08] <masak> aye. (btw, I prefer "placeholder" to "hole" nowadays)

[12:08] <moritz> std: my $op; quasi { 1 {{{ $op }}} 2 }

[12:08] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/g5MaPfOhaW line 1:␤------> [32mmy $op; quasi { 1 [33m⏏[31m{{{ $op }}} 2 }[0m␤    expecting infix or meta-infix␤Parse failed␤FA…

[12:08] <masak> right.

[12:08] <masak> that will never work.

[12:09] <moritz> masak: but the inside of role R[...] is parsed as a signature, not as a list of terms

[12:09] <masak> almost right.

[12:09] *** Trashlord joined
[12:09] <masak> it *is* parsed as a signature.

[12:09] <masak> but terms are part of a signature, in the form of type names.

[12:09] <masak> so it's OK there.

[12:10] <moritz> std: my $thing; quasi { role R[{{{$thing}}}] { } }

[12:10] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse generic role at /tmp/FDHAuBs39A line 1:␤------> [32mmy $thing; quasi { role R[33m⏏[31m[{{{$thing}}}] { } }[0m␤Couldn't find final ']'; gave up at /tmp/FDHAuBs39A line 1:␤------> [32mmy $thing; quasi { role R[[33m⏏…

[12:10] <moritz> seems not very OK there

[12:10] <que> moritz:another small question

[12:10] <que> > my int $x =5 Use of uninitialized value in string context Use of uninitialized value in string context Use of uninitialized value in string context Use of uninitialized value in string context ===SORRY!=== Lexical '$x' is of wrong register type in lexical lookup

[12:10] <masak> moritz: I don't think STD's quasi parsing handles that.

[12:11] <moritz> masak: even if you could, that would only allow injection of constraints, not of parameters, right?

[12:11] <masak> moritz: also, I might simply be wrong about terms being OK there.

[12:11] * moritz waits for the question

[12:11] <masak> moritz: right, but the rest of the signature could be put outside of the placeholder as usual.

[12:12] <moritz> oh, it seems that the REPL doesn't like native lexicals yet

[12:12] <moritz> masak: well, if terms are allowed, than only in the form of   multi fib(0) { 1 }

[12:13] <moritz> masak: so as a constraint, not as a declaration

[12:13] *** pernatiy joined
[12:13] <moritz> so I don't see a big problem here

[12:14] <moritz> (hey, that's new, isn't it? *I* don't see a problem with something macro-related where masak sees a problem :-)

[12:15] <masak> :-P

[12:16] <masak> I'm not sure what arbitrary distinction you draw between constraints-as-types and constraints-as-values here...

[12:16] <masak> both are terms.

[12:16] *** molaf joined
[12:16] <que> thanks

[12:16] *** que left
[12:16] <moritz> que: I've sent a bug report

[12:17] <masak> and in both cases, we're prevented from actually creating the role until macro-call o'clock.

[12:17] *** alc left
[12:17] <moritz> masak: constraints-as-types are optionally followed by *another* term-like thing (the parameter), so they need special parsing

[12:18] <moritz> hm, are we? do we need the constraints on an anonymous formal parameter to build the role?

[12:18] <moritz> in analogy:  sub f(0) { the body here doesn't need to know about the 0 }

[12:19] *** alc joined
[12:20] <masak> true, but there are conceptual problems with building the signature (and therefore the sub) before we've filled in the placeholders.

[12:20] <masak> these are immutable things, so it's hard to fake it and go back and fill in afterwards.

[12:20] <moritz> right

[12:21] <jnthn> But we don't parse term in the sub f(0) { case

[12:21] <jnthn> We parse value.

[12:21] <masak> clearly more research is needed in this area.

[12:21] <masak> right, it can't be term because that would get '$x' wrong.

[12:22] <moritz> so by current understanding that means that no quasi placeholder can appear in the signature, except in where BLOCK clauses maybe

[12:23] <jnthn> Not quite true

[12:23] <jnthn> Defaults are parsed as term.

[12:24] <moritz> std: my $h; quasi { sub f($x = {{{$h}}}) { say $x } }

[12:24] <p6eval> std 580b69a: OUTPUT«ok 00:01 133m␤»

[12:25] <JimmyZ> nom: my num $num; say $num++;

[12:25] <p6eval> nom 97aa73: OUTPUT«Cannot assign to a non-container␤  in sub postfix:<++> at src/gen/CORE.setting:2697␤  in block <anon> at /tmp/snsnzj7U8Z:1␤  in <anon> at /tmp/snsnzj7U8Z:1␤»

[12:25] <jnthn> std: my $h; quasi { sub f({{{$h}}}) { say $x } }

[12:25] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/n3DtpymxwY line 1:␤------> [32mmy $h; quasi { sub f[33m⏏[31m({{{$h}}}) { say $x } }[0m␤Couldn't find final ')'; gave up at /tmp/n3DtpymxwY line 1:␤------> [32mmy $h; quasi { sub f([33m⏏[31m{{{$h}…

[12:25] <jnthn> Right, that's what I was expecting.

[12:25] <jnthn> (sorry if you already did it - I kinda skim-backlogged after a long meeting :))

[12:26] <jnthn> JimmyZ: rw native parameters nyi

[12:26] <jnthn> (so we can't have native ++ yet)

[12:26] <moritz> jnthn: are they even specced?

[12:26] <jnthn> moritz: Well, they aren't outlawed by the spec... :)

[12:27] * moritz isn't sure how much sense they make

[12:27] <jnthn> Well, I'm not sure saying "you can't $i++ if $i is a native int" is going to fly

[12:28] * moritz neither, but OTOH "we want that feature, so make it happen" makes sense and is possible in all cases

[12:29] <moritz> the very point of int (vs. Int) is that it does *not* pass a reference, but the value

[12:29] <jnthn> yeah

[12:29] <jnthn> Maybe it only works in the static case.

[12:29] <moritz> static case?

[12:29] <jnthn> e.g. we have to statically know it's going to bind to an rw parameter

[12:29] <jnthn> As in

[12:29] <moritz> ah

[12:30] <jnthn> If you don't statically know what you're calling, it won't work out.

[12:30] <JimmyZ> $num is not NaN, so what will $num++ be？ 

[12:30] <JimmyZ> 1？

[12:30] <jnthn> heh

[12:30] <moritz> JimmyZ: the same as NaN + 1

[12:30] <jnthn> NaN ;)

[12:30] <moritz> perl6: say NaN + 1

[12:30] <p6eval> pugs b927740, rakudo 97aa73, niecza v10-61-gbacff10: OUTPUT«NaN␤»

[12:32] <JimmyZ> I'm curious, why my int $int default is 0, and my num $n default is NaN

[12:32] <moritz> JimmyZ: the idea is to mimic "undefined" as good as possibles

[12:33] <moritz> JimmyZ: but 'int' doesn't have anything close to "undefined", so something else must be used. 0 is an obvious choice

[12:33] <JimmyZ> maybe NaI

[12:33] <moritz> JimmyZ: but floating point numbers support NaN, so it makes sense to use them

[12:33] <moritz> JimmyZ: how would you store that in an integer register of your CPU?

[12:38] <JimmyZ> perl6: say NaN ~ 1 + 1;

[12:38] <p6eval> pugs b927740, rakudo 97aa73, niecza v10-61-gbacff10: OUTPUT«NaN2␤»

[12:38] *** benabik left
[12:38] <dalek> rakudo/nom: cbc652c | moritz++ | docs/ChangeLog:

[12:38] <dalek> rakudo/nom: add some ChangeLog entries

[12:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cbc652c834

[12:38] <flussence> moritz: ever seen how javascript does it? it's scary :)

[12:39] <moritz> flussence: javascript, or v8?

[12:39] <flussence> the one I read was about mozilla's implementation - they put the type data and the value in a single register...

[12:39] <moritz> iirc using the highest bit to indicate "not a real int, interpret as a reference" or something

[12:40] <masak> yuck.

[12:41] <JimmyZ> nom: my Num $num; say $num++

[12:41] <p6eval> nom 97aa73: OUTPUT«0␤»

[12:41] <mux> GHC (haskell) does something similar for optimisation purposes, albeint in a totally different context obviously

[12:42] <mux> (taking one or two bits our of an int)

[12:42] <JimmyZ> my Num $num default is 0?

[12:42] <moritz> JimmyZ: no

[12:42] <jnthn> Default is the type object there.

[12:42] <moritz> nom: my Num $num; say $num.perl

[12:42] <p6eval> nom 97aa73: OUTPUT«Num␤»

[12:42] <jnthn> If you succ on a Num, it becomes a 1

[12:43] <jnthn> .oO( that sounded weird out loud )

[12:43] <JimmyZ>  num $num ++ is different from Num $num ++

[12:43] <moritz> if you left out that 'on', it would've been much less weird :-)

[12:43] <moritz> JimmyZ: num is different from Num in that num-typed variables can't hold a type object

[12:43] <moritz> not sure if NaN is the best default though

[12:44] <JimmyZ> nom: my Num $num = NaN; say $num++

[12:44] <p6eval> nom 97aa73: OUTPUT«NaN␤»

[12:44] <moritz> nom: say num ~~ num

[12:44] <p6eval> nom 97aa73: OUTPUT«Method 'ACCEPTS' not found for invocant of class 'num'␤  in block <anon> at /tmp/X4fqoPFeNW:1␤  in <anon> at /tmp/X4fqoPFeNW:1␤»

[12:44] <moritz> nom: say num ~~ Num

[12:44] <p6eval> nom 97aa73: OUTPUT«Bool::False␤»

[12:44] <moritz> nom: say num ~~ Mu

[12:44] <p6eval> nom 97aa73: OUTPUT«Bool::False␤»

[12:44] <moritz> woah.

[12:44] <JimmyZ> nom: my Num $num = NaN; say $num++; say $num++; say $num++

[12:44] <p6eval> nom 97aa73: OUTPUT«NaN␤NaN␤NaN␤»

[12:45] <JimmyZ> nom: my Num $num; say $num++; say $num++; say $num++

[12:45] <p6eval> nom 97aa73: OUTPUT«0␤1␤2␤»

[12:46] <JimmyZ> nom: my num $num; say $num + 1； say $num + 2;

[12:46] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤Confused at line 1, near "say $num +"␤»

[12:46] <jnthn> nom: say int ~~ Mu

[12:46] <p6eval> nom 97aa73: OUTPUT«Bool::False␤»

[12:46] <jnthn> hm :)

[12:46] <JimmyZ> nom: my num $num; say $num+1； say $num+2;

[12:46] <p6eval> nom 97aa73: OUTPUT«===SORRY!===␤Confused at line 1, near "say $num+1"␤»

[12:46] <jnthn> Well, it's a native, not an object but... :)

[12:46] <moritz> nom: say num.defined

[12:46] <p6eval> nom 97aa73: OUTPUT«Method 'defined' not found for invocant of class 'num'␤  in block <anon> at /tmp/IlMbHkpIGO:1␤  in <anon> at /tmp/IlMbHkpIGO:1␤»

[12:46] <jnthn> Yeah, that's wrong

[12:46] <jnthn> nom: say num

[12:46] <p6eval> nom 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'num'␤  in sub say at src/gen/CORE.setting:5281␤  in block <anon> at /tmp/VOY_dFDZTm:1␤  in <anon> at /tmp/VOY_dFDZTm:1␤»

[12:47] <jnthn> huh

[12:47] <jnthn> I'm sure that used to work.

[12:47] <jnthn> nom: say int

[12:47] <p6eval> nom 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'int'␤  in sub say at src/gen/CORE.setting:5281␤  in block <anon> at /tmp/Q89tPGJ8Lj:1␤  in <anon> at /tmp/Q89tPGJ8Lj:1␤»

[12:47] <moritz> jnthn: it even says 'class' in the error message, so if it's a class, it must be ~~ Mu :-)

[12:47] <jnthn> I'm really sure that one did.

[12:47] <jnthn> nom: say int.^methods

[12:47] <p6eval> nom 97aa73: OUTPUT«Method 'dispatch:<.^>' not found for invocant of class 'int'␤  in block <anon> at /tmp/9kTKsV5nJE:1␤  in <anon> at /tmp/9kTKsV5nJE:1␤»

[12:47] * moritz writes more tests

[12:47] <JimmyZ> nom: my Num $num = NaN; say $num.WHAT

[12:47] <jnthn> nom: say int.HOW.mro(int)

[12:47] <p6eval> nom 97aa73: OUTPUT«Num()␤»

[12:47] <p6eval> nom 97aa73: OUTPUT«Method 'gist' not found for invocant of class 'int'␤  in method gist at src/gen/CORE.setting:3680␤  in sub say at src/gen/CORE.setting:5281␤  in block <anon> at /tmp/Bi4RGUq83a:1␤  in <anon> at /tmp/Bi4RGUq83a:1␤»

[12:47] <jnthn> oh

[12:48] <jnthn> that'll do it.

[12:48] <masak> bug?

[12:48] <jnthn> yeah, looks like

[12:48] * masak submits

[12:48] <jnthn> somehow it's not building the MRO properly.

[12:48] <jnthn> And since method dispatch and type checking are all done by MRO...yeah, not surprising.

[12:48] <jnthn> ENEEDMOARTESTS ;)

[12:48] <moritz> really? I thought the problem is that .mro returns a Parcel, and Parcel.gist recurses into the elements

[12:49] <moritz> and hits int.gist, and dies

[12:49] <moritz> at least that's what the p6eval output tells me

[12:50] <JimmyZ> anyway, (my Num $num)++ is deferent from (my num $num)++ is a little strange to me

[12:50] <moritz> nom: my int $x = 3; say $x.gist

[12:50] <p6eval> nom 97aa73: OUTPUT«3␤»

[12:51] <JimmyZ> s/deferent/different/

[12:54] *** im2ee joined
[12:54] <moritz> masak: got a ticket number for the bug you just submitted?

[12:55] <im2ee> Hi. :)

[12:55] <moritz> hi im2ee 

[12:55] <masak> hi im2ee 

[12:56] <masak> moritz: not yet; still looking for the start of the bug in the logs :)

[12:56] <masak> ...and I got derailed into finding out whether irssi has search functionality... :/

[12:56] <dalek> roast: 29a84dc | moritz++ | S02-types/native.t:

[12:56] <dalek> roast: basic tests for native type objects

[12:56] <dalek> roast: review: https://github.com/perl6/roast/commit/29a84dc677

[12:56] <moritz> masak: there's /lastlog, but it might not be flexible/nice enough for your needs

[12:58] <masak> thanks.

[12:58] <masak> the relevant log is longish, so this will take a few minutes.

[12:58] <masak> I'll post the URL when I've sent the email.

[13:01] *** alc left
[13:04] *** bluescreen10 joined
[13:04] <masak> moritz: https://rt.perl.org/rt3/Ticket/Display.html?id=102256

[13:04] <jnthn> moritz: oh...

[13:05] <jnthn> moritz: I read the wrong live of p6eval output

[13:05] <jnthn> nom: say int.HOW.mro(int).elems

[13:05] <p6eval> nom cbc652: OUTPUT«1␤»

[13:05] <jnthn> ok, *that* is a problem :)

[13:05] <moritz> aye :-)

[13:05] <masak> ok, that goes into the ticket.

[13:07] <moritz> masak: tested in S02-types/native.t

[13:07] <dalek> roast: 45800f1 | moritz++ | S02-types/native.t:

[13:07] <dalek> roast: label and extend tests for RT #102256

[13:07] <dalek> roast: review: https://github.com/perl6/roast/commit/45800f1a4f

[13:07] <masak> moritz++

[13:07] <moritz> ah, I can add that note myself :-)

[13:08] * moritz adds the 'testcommitted' tag

[13:11] *** tokuhiro_ left
[13:11] *** tokuhiro_ joined
[13:11] <PerlJam> Have you guys seen http://www.infoq.com/presentations/Simple-Made-Easy ?

[13:12] <masak> yep :)

[13:12] <masak> I mentioned it here the other day.

[13:12] <PerlJam> yeah, I'm looking at it again and picking out things I missed the first time :)

[13:12] <masak> http://irclog.perlgeek.de/perl6/2011-10-22#i_4601445

[13:13] *** molaf left
[13:14] <PerlJam> Perl 6 fares well as a language that allows for Simplicity as Hickey defines it.

[13:14] <masak> I should hope so! :P

[13:15] <masak> PerlJam: you probably saw this when I wrote it, but I like this example of Perl 6 simplifying my life: https://gist.github.com/1149245

[13:15] <PerlJam> yes, that is awesome.  :)

[13:16] <masak> it's like the Perl 6 code only focuses on delivering content, with all the fat trimmed.

[13:16] <masak> that bit will definitely go in my Dancing Links reprise in London next month. :)

[13:17] <moritz> :-)

[13:17] * moritz likes it

[13:18] <masak> now, in terms of complecting things... you might argue that the Perl 5 version is long because it complects the circular list traversal and finding the smallest item.

[13:19] * moritz reads that blog post as "TLAs are LTA" :-)

[13:19] <masak> because if you took those apart, you could at least use List::Util's &min

[13:20] <moritz> does &min from List::Util support the equivalent of &by?

[13:20] *** sayu joined
[13:21] <masak> no :(

[13:21] <PerlJam> no, but there's List::UtilsBy

[13:21] <masak> :P

[13:21] <masak> this will make a great set of slides... :)

[13:21] <masak> "...and here's the Perl 6 version..."

[13:22] <PerlJam> it literally adds the "by" for all of min, max, uniq, zip, sort, etc.

[13:22] <moritz> zip_by ?

[13:23] <moritz> hm, nope :-)

[13:23] <masak> PerlJam++

[13:24] <PerlJam> LeoNerd++  (for writing the module so that Perl 5 can sort of compete with Perl 6 ;)

[13:25] <masak> note that Perl 6 de-complects out of the box.

[13:25] <masak> I remember looking at the loop I had written, getting the realization that it could be made into a sequence operator.

[13:27] *** MayDaniel left
[13:27] <masak> lazy lists rock. they allow you to decouple things and make them co-routine-like almost without thinking about it.

[13:27] *** benabik joined
[13:29] <PerlJam> Like past perls, once people get used to using these "higher level" constructs, they'll wonder how they ever got along without them :)

[13:30] <PerlJam> I just wonder how much of the Awesome Perl 6 will export outside of Perl

[13:31] <masak> well, I think Perl 5 has shown so far that it adapts pretty nicely to the new tricks that Perl 6 provides. sometimes 'smartmatch' turns into 'psychoticmatch' along the way, but by and large, Perl 5 adapts.

[13:31] <masak> what Perl 6 provides is something of a "full immersive experience".

[13:33] * flussence ... installs ghc

[13:34] <arnsholt> PerlJam: I think grammars as the natural next step to regexes will catch on (eventually)

[13:34] *** abercrombie joined
[13:34] <arnsholt> The full range of awesome in P6 grammars might be hard to put into some languages, but grammars are a more natural way to express these things, on the whole

[13:36] <PerlJam> arnsholt: I tend to agree, but only time will tell.

[13:36] *** im2ee left
[13:36] <arnsholt> Oh yes, definitely

[13:36] *** im2ee joined
[13:37] <arnsholt> Lazy lists are likely as well. The growing interest in Haskell and friends points in that direction as well

[13:37] <PerlJam> I wonder if Perl 6 feature adoption in Perl 5 could be used as an indicator about Perl 6 feature adoption in the wild

[13:37] <masak> probably not. Perl 5 people are usually a bit ahead of any such curve.

[13:38] <masak> so maybe it's a good predictor ;)

[13:38] <PerlJam> maybe

[13:38] <arnsholt> Yeah, it's not a perfect model, but as a proxy it's probably not entirely useless

[13:38] <arnsholt> (To first order, and all that =)

[13:39] <PerlJam> lazy lists will be hard for most other languages to adopt because to be useful, they need to be pervasive.

[13:40] <masak> aye.

[13:40] <jnthn> The hard thing was getting them to be eager enough in the right places so as to avoid surprises.

[13:41] <jnthn> Which got a bunch easier to do when pmichaud++ came up with the immutable iterator model.

[13:42] * moritz wonders if it's possible to make a for 1..100 { } in sink context about as fast as iterating with native ints

[13:44] <masak> if you can compile it into a while loop, why not?

[13:45] <moritz> I was more thinking along the lines of haviing hash.map produce some "intelligent" iterator that, when in sink contest, does it at run time

[13:45] <jnthn> The thing is that you have a block at runtime.

[13:46] <jnthn> The cost is muchly in that invocation too

[13:46] <jnthn> Whereas the while loop tends to flatten out.

[13:46] <jnthn> Well, with --optimize=3 at the moment

[13:46] <moritz> well, that's still much better than the call chain we have now

[13:46] <jnthn> But maybe we should try brining that one into level 2 for the November release 

[13:46] <moritz> with eager, eager, gimme, reify, reify, reify   or so

[13:46] *** SHODAN left
[13:46] <masak> jnthn: no rush :)

[13:46] <jnthn> Yeah, I mentioned to Pm that I suspect we have one too many layers.

[13:47] <jnthn> masak: well, it's only changing a number to do it ;)

[13:47] <jnthn> The next thing the optimizer needs to do is learn that variables exist.

[13:47] <jnthn> Today it lives in mostly blissful ignorance of them :)

[13:47] <moritz> :-)

[13:48] * moritz thinks an NQP optimizer would be more important for now

[13:48] <masak> quite possibly.

[13:48] <jnthn> Well, it needs that variable analysis.

[13:49] <jnthn> In many senses, I need to solve the same kind of analysis problem for both.

[13:49] <masak> similar-ish languages, are they? :P

[13:49] <jnthn> Apparently :P

[13:52] *** darkop joined
[13:55] *** mikemol left
[13:56] <arnsholt> I'm getting an urge to make something better than make. Someone whack me =)

[13:56] *** mikemol joined
[13:56] * moritz hugs arnsholt 

[13:56] <arnsholt> Or that =D

[13:56] * masak tickles arnsholt with a goose feather

[13:56] <flussence> have a look at redo before you go doing that

[13:56] <masak> or rake.

[13:57] <benabik> cmake?

[13:57] <flussence> https://github.com/apenwarr/redo - I haven't used it, but it looks nicest of the alternatives I've seen

[13:57] <moritz> cmake just creates Makefiles, no?

[13:58] <moritz> .oO( Module::Build )

[13:58] <benabik> moritz: No idea.

[13:58] <arnsholt> flussence: Oooh, never heard of redo before

[13:58] <moritz> benabik: at least that's a project I used handled it

[13:58] <arnsholt> Sounds shiny from the opening paragraph

[13:58] <masak> I was just thinking the same :)

[13:59] *** thou joined
[14:00] * moritz remembers reading the original notes, being excited for a minute, and then discarding it

[14:01] <arnsholt> I've had this idea of a better make several times, but each time I'm reminded of a quote from someone I had a chat with at Opera: "make sucks. It's just too bad all the alternatives suck even more."

[14:01] <PerlJam> People have been trying to create a better make for *decades*

[14:02] <mux> did you mean, people have been creating better makes for decades, /6􏿽xB0

[14:02] <mux> make that ? :-) at the end

[14:03] <PerlJam> heck ... one of the first disucsisons I had on IRC about programming stuff was how much make sucked and that it needed to be replaced with something better.

[14:03] <moritz> ah well, no Windows support

[14:03] <PerlJam> That was in 1992 or so.

[14:04] <benabik> moritz: The problem with Windows support is that you either reinvent shell syntax or miss some power of Make because you don't support shell syntax.  :-/

[14:04] <mux> scons is not bad at all

[14:04] <masak> ah! 'scons' was the name I was looking for.

[14:04] <masak> mux++

[14:04] <moritz> benabik: I'm well aware of the problems. It's solutions I'm looking for :-)

[14:05] <mux> I wish it didn't allow full python syntax however, that's quite dumb since people are now able to create SConstruct files that won't work with some python versions

[14:05] * PerlJam has heard of "cons", but not "scocs"

[14:05] <PerlJam> er, scons

[14:05] <mux> they definitely didn't need the full power of the language

[14:05] <mux> PerlJam: well, it's supposed to be cons successor

[14:05] <moritz> mux: but I'm sure it made the implementation much easier :-)

[14:05] <[Coke]> why are we talking about improving make? don't we have better things to do?

[14:05] <mux> moritz: yeah :-)

[14:06] <benabik> [Coke]: #perl6 distracted?  That never happens.

[14:06] <[Coke]> I have to use ANT regularly, don't get me started. :P

[14:06] <mux> oh man, ant

[14:06] <mux> stupid XML configuration files for builds

[14:06] <benabik> moritz: I've found Rake to be reasonable since I get the power of Ruby instead of sh.  But like everything else, it has its problems.

[14:06] <mux> ant is such a nightmare

[14:06] <moritz> ah right, I wanted to fix feather for [Coke]++

[14:06] <masak> Ant definitely uses XML in a way no-one ever should.

[14:07] <benabik> Hm.  Redo really is fascinating.

[14:07] <mux> I wish people understood how XML /may/ be approrpiate for exchanging data between possibly very different systems, but that there's no way in hell it's appropriate to present a XML configuration file to a human

[14:07] <moritz> [Coke]: trouble is, feather has only about 1G of RAM, and rakudo build on amd64 needs about 1.5G :(

[14:08] <moritz> mux: and it was never meant to be a data exchange format, just a markup language

[14:08] * jnthn wishes he knew where it all went

[14:08] <moritz> it's a nice markup language for sure

[14:08] <benabik> Although I think a .do file only fails if the last command failed.  :-/

[14:08] <moritz> can't you do a  set -x  or so?

[14:09] <[Coke]> moritz: to increase the limit? not past the system default.

[14:09] <moritz> [Coke]: sorry, that was to benabik 

[14:09] <mux> moritz: it's not so bad as an interchange format, because thanks to the huge number of XML related standards and nearly ubiquitiuous language support, you get something that you can use to store data/parse data/validate data for nearly free

[14:09] <[Coke]> moritz: ah, yes.

[14:10] <benabik> moritz: Yes, although I dislike systems that have "all your files should include ___ at the beginning".  Make the default safe.

[14:10] * benabik will stop pretending this is #redo instead of #perl6 now.

[14:10] <mux> oh, and it gives you structure and deals with character encodings itself.

[14:11] <moritz> ... which partially relies on autodetection

[14:11] <mux> yeah but that's because OSes didn't catch up and fail to give applications proper MIME types for files :-)

[14:12] * moritz stops pretending this is #xml-rant instead of #perl6 :-)

[14:12] * mux stops pretending

[14:13] <masak> ooh, #xml-rant!

[14:13] *** cognomore left
[14:13] *** cognomore joined
[14:14] <dalek> roast: c3a585e | (Solomon Foster)++ | S16-filehandles/filetest.t:

[14:14] <dalek> roast: Fudged for niecza.

[14:14] <dalek> roast: review: https://github.com/perl6/roast/commit/c3a585e610

[14:14] <dalek> roast: 6a5a339 | (Solomon Foster)++ | S32-num/complex.t:

[14:14] <dalek> roast: Fudge for Niecza.

[14:14] <dalek> roast: review: https://github.com/perl6/roast/commit/6a5a3396dc

[14:14] <dalek> roast: 016a50f | (Solomon Foster)++ | S32-num/exp.t:

[14:14] <dalek> roast: Fudge for Niecza.

[14:14] <dalek> roast: review: https://github.com/perl6/roast/commit/016a50fe62

[14:14] <dalek> roast: 7560a7a | (Solomon Foster)++ | S32-num/int.t:

[14:14] <dalek> roast: Make Niecza-friendly: don't assume Rats stringify the same as Nums, and fudging.

[14:14] <dalek> roast: review: https://github.com/perl6/roast/commit/7560a7a7e9

[14:15] *** tokuhiro_ left
[14:16] <masak> perl6: say 5/4

[14:16] <p6eval> niecza v10-61-gbacff10: OUTPUT«5/4␤»

[14:16] <p6eval> ..pugs b927740, rakudo cbc652: OUTPUT«1.25␤»

[14:16] <masak> isn't that a Nieczabug?

[14:17] <moritz> it is

[14:17] * masak submits it

[14:18] <masak> any relevant synopsis I can quote?

[14:18] <PerlJam> masak: hey ... supposedly the TPF voted (or whatever) on your grant proposal ... have you heard anything?

[14:18] <moritz> masak: you can cite roast :-)

[14:19] <masak> PerlJam: haven't heard anything yet, no.

[14:19] <moritz> masak: S02: say 1/5;    # 0.2 exactly (not via Num)

[14:20] <masak> moritz++

[14:21] <PerlJam> masak: bummer.  Maybe it's time to ping Karen again :)

[14:21] <masak> perl6: say 1/3

[14:21] <moritz> ... though by latest spec that's .gist, and not .Str

[14:21] <p6eval> rakudo cbc652: OUTPUT«0.333333333333333␤»

[14:21] <p6eval> ..pugs b927740: OUTPUT«0.3333333333333333333333333333333333333333␤»

[14:21] <p6eval> ..niecza v10-61-gbacff10: OUTPUT«1/3␤»

[14:21] <moritz> perl6: say (1/2).Str

[14:21] <p6eval> niecza v10-61-gbacff10: OUTPUT«1/2␤»

[14:21] <p6eval> ..rakudo cbc652: OUTPUT«0.5␤»

[14:21] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Rat: "&Str"␤    at /tmp/JaZi9iv517 line 1, column 5 - line 2, column 1␤»

[14:21] <moritz> ok, that is wrong at least

[14:22] <masak> PerlJam: feel free. in the meantime, I'm finding a few macro tuits here and turning them into commits or design gists.

[14:23] <masak> moritz: you mean Rat.gist isn't defined in the spec? sounds like something that should be spec'd if you ask me.

[14:24] <dalek> roast: 47573c5 | (Solomon Foster)++ | S32-num/exp.t:

[14:24] <dalek> roast: Fix niecza fudging.

[14:24] <dalek> roast: review: https://github.com/perl6/roast/commit/47573c5434

[14:24] <moritz> masak: no. I mean that the 'say 1/2' line invokes .gist on the Rat

[14:24] <dalek> niecza: e4121a3 | (Solomon Foster)++ | lib/CORE.setting:

[14:24] <dalek> niecza: Add log subs and log10 sub and method.

[14:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e4121a3d79

[14:24] <dalek> niecza: 9b24a83 | (Solomon Foster)++ | lib/CORE.setting:

[14:24] <dalek> niecza: Add unpolar and cis.

[14:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9b24a83252

[14:24] <dalek> niecza: 9b9d1c0 | (Solomon Foster)++ | lib/CORE.setting:

[14:24] <dalek> niecza: Add exp($x, $base).

[14:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9b9d1c0c82

[14:24] <dalek> niecza: 519e0b6 | (Solomon Foster)++ | lib/CORE.setting:

[14:24] <dalek> niecza: Add Complex.polar.

[14:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/519e0b665d

[14:24] <dalek> niecza: 71325b0 | (Solomon Foster)++ | t/spectest.data:

[14:24] <dalek> niecza: Turn on S32-num files that now work.

[14:24] <moritz> masak: and not .Str. So the spec doesn't talk about .Str stringification there

[14:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/71325b058d

[14:25] <masak> moritz: yes, I understand.

[14:25] <masak> maybe that bit of spec just needs clarifying.

[14:26] <moritz> well, it is very silent on most .gist'ifications, and on many .Str'ifications

[14:26] *** JodaZ left
[14:26] <moritz> S02 is a weird mixture of "bits and pieces" and incomplete API documentation

[14:35] <masak> perfect for someone to just guerrilla-spec at some point.

[14:36] <moritz> quick straw poll: should Rat.new(2, 1) stringify to 2.0 or to 2?

[14:36] <moritz> and should 2e0 stringify to 2 or 2e0?

[14:36] <PerlJam> 2.0

[14:36] <masak> 2.0

[14:36] <masak> moritz: what does 2e1 stringify to?

[14:36] <moritz> masak: 20 or 20e0

[14:36] <[Coke]> coming from tcl, I'd prefer the .0 on the end.

[14:37] <flussence> perl6: say (eval '2.0').perl

[14:37] <masak> moritz: scientific notation feels like Num to me, but if they're Int then maybe they can stringify like Int.

[14:37] <p6eval> pugs b927740, rakudo cbc652, niecza v10-66-g71325b0: OUTPUT«2/1␤»

[14:37] * flussence likes round-tripping

[14:37] <flussence> rakudo: say (eval '2.0').Str.eval.perl

[14:37] <p6eval> rakudo cbc652: OUTPUT«2␤»

[14:37] <flussence> hm

[14:37] <flussence> perl6: say (eval '2.0').Str.eval.perl

[14:37] <p6eval> rakudo cbc652: OUTPUT«2␤»

[14:37] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Rat: "&Str"␤    at /tmp/mivPVyzw7Y line 1, column 5 - line 2, column 1␤»

[14:37] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«␤Unhandled Exception: Unable to resolve method eval in class Str␤  at /tmp/6bZqfMADY_ line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2193 (CORE C1051_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2194 (CORE module-CO…

[14:38] *** cognomore left
[14:38] *** cognominal_ joined
[14:38] *** cognomore joined
[14:38] <flussence> perl6: say eval((eval '2.0').Str).perl

[14:38] <p6eval> niecza v10-66-g71325b0: OUTPUT«2/1␤»

[14:38] <p6eval> ..rakudo cbc652: OUTPUT«2␤»

[14:38] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Rat: "&Str"␤    at /tmp/0q2Ojup5PN line 1, column 10-26␤»

[14:38] <PerlJam> moritz: I'm with masak on scientific notation

[14:39] <PerlJam> though I never think of a number in scientific notation as "integer"; they're always some floating point thing in my head.

[14:39] <PerlJam> (at least historically)

[14:40] * moritz will regret this one

[14:41] *** cognominal left
[14:42] <masak> 'what will 2e0 stringify to?' might be the wrong question. 'what type does it parse to?' sounds like a more immediate question.

[14:43] <moritz> Num

[14:43] <moritz> the spec is pretty clear

[14:43] *** im2ee left
[14:43] <flussence> (do we even have any types that stringify to scientific notation?)

[14:43] <moritz> on this account

[14:44] <PerlJam> flussence: I hope not

[14:44] *** im2ee joined
[14:44] <moritz> flussence: strings which contain numbers in scientific notation :-)

[14:46] *** skangas joined
[14:49] <[Coke]> hurm. so, I change my mind: Floats should stringify with .0 even if they're intable. Rats should stringify to ints if they can.

[14:50] <masak> agreed.

[14:50] <dalek> specs: 660b108 | moritz++ | S02-bits.pod:

[14:50] <dalek> specs: [S02] define .Stringy and .gist for Num and Rat

[14:50] <dalek> specs: 

[14:50] <dalek> specs: leave a bit of wiggle room in the Num stringification fow now.

[14:50] <dalek> specs: review: https://github.com/perl6/specs/commit/660b10810a

[14:51] <moritz> then please change the spec too, not just your mind :-)

[14:51] <masak> actually, I don't mind if 4/1 stringifies to 4/1 either.

[14:51] <moritz> pugs: say 1/7

[14:51] <p6eval> pugs b927740: OUTPUT«0.1428571428571428571428571428571428571429␤»

[14:51] <moritz> it used to answer with 1/7 at one point

[14:51] <moritz> I hated it

[14:51] <masak> yeah.

[14:51] <moritz> I *knew* that I asked it for the value of 1/7.

[14:51] <masak> Rats should stringify to their decimal expansion.

[14:52] <masak> we're just talking about the Int case here.

[14:52] <moritz> you mean where .denominator == 1?

[14:52] <masak> or rather, the "denominator in the reduced fraction is 1" case.

[14:52] <masak> right.

[14:53] <[Coke]> should 4/2 stringify the same as 2/1 ?

[14:53] <moritz> masak: so what changed your mind?

[14:53] <moritz> [Coke]: yes

[14:53] <[Coke]> ah, catching up, reduced, aye.

[14:53] *** nornagest joined
[14:53] <[Coke]> rat's aren't floats.

[14:54] <masak> moritz: correctly understanding the domain we were moving in.

[14:54] <masak> moritz: I don't like for pi to stringify to something with 'e0' at the end, for example.

[14:55] <moritz> masak: and it won't

[14:55] <moritz> S02:3543 constant pi is export = 3.14159_26535_89793_23846_26433_83279_50288;

[14:55] <moritz> that's a Rat, not a Num

[14:55] <masak> fair enough.

[14:55] <masak> it makes things a bit better...

[14:56] <masak> ...but I think I still prefer Rats and Nums to stringify the same, rather than to have Nums append 'eN' to stuff.

[14:56] <masak> Num is a sort of inaccuracy fallback for Rat, after all.

[14:56] * moritz doesn't care too strongly either way, as long as it's specced and consistent

[14:57] <moritz> perl6: say 2e0 ** 35

[14:57] <p6eval> pugs b927740, rakudo cbc652, niecza v10-66-g71325b0: OUTPUT«34359738368␤»

[14:57] <moritz> perl6: say 2e0 ** 65

[14:57] <p6eval> pugs b927740: OUTPUT«36893488147419103232␤»

[14:57] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«3.68934881474191E+19␤»

[14:57] <p6eval> ..rakudo cbc652: OUTPUT«3.68934881474191e+19␤»

[14:57] <masak> I'll have a look at the spec tonight after $dayjob, unless someone beats me to it.

[14:57] *** sivoais left
[14:59] *** slavik1 left
[14:59] *** slavik2 joined
[15:01] <masak> std: if 42 { say "A" } else if 5 { say "B" }

[15:01] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Please use 'elsif' at /tmp/kf213KjczR line 1:␤------> [32mif 42 { say "A" } else if [33m⏏[31m5 { say "B" }[0m␤Confused at /tmp/kf213KjczR line 1:␤------> [32mif 42 { say "A" } else if [33m⏏[31m5 { say "B" }[0m␤    expecting stat…

[15:02] <masak> perl6: if 42 { say "A" } else if 5 { say "B" }

[15:02] <p6eval> rakudo cbc652: OUTPUT«===SORRY!===␤Missing block at line 1, near "if 5 { say"␤»

[15:02] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Please use 'elsif' at /tmp/fgP25RSzdE line 1:␤------> [32mif 42 { say "A" } else if [33m⏏[31m5 { say "B" }[0m␤␤Two terms in a row at /tmp/fgP25RSzdE line 1:␤------> [32mif 42 { say "A" } else if [33m⏏[31m5 { say "B" }…

[15:02] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "if"␤    expecting "=" or bare or pointy block construct␤    at /tmp/TEvJkbeeLF line 1, column 24␤»

[15:02] <masak> rakudo-- pugs-- niecza++

[15:04] * [Coke] occasionally wonders: if we have to recognize "else if" to complain about it, why not just support it instead.

[15:04] <[Coke]> (instead of complaining, not instead of elsif)

[15:04] <moritz> [Coke]: it introduces the dangling-else ambiguty again

[15:04] *** sayu left
[15:05] <moritz> if 1 { } else if 2 { } else { }  # does the 'else' belong to 1 or to 2?

[15:05] <moritz> that's a pitfall that Perl generally avoids by requiring blocks after if/elsif/else, and by having 'elsif' separate from 'else if'

[15:06] <JimmyZ> how does C do it?

[15:06] <[Coke]> I would expect it to work the same as if you had used elsif.

[15:06] <moritz> iirc it just disambiguates one way or another

[15:06] * JimmyZ would like to else if = elsif

[15:07] <mux> yeah, that's why you often have to wrap macros inside do { ... } while (0); blocks

[15:07] <mux> to avoid unexpected problems when your macro is used as: if (foo) MACRO;

[15:07] <mux> in moritz's example, I believe C intreprets it as if 1 { } else { if 2 { } else { } }

[15:08] <mux> not sure though

[15:08] * moritz wonders if the two cases are actually semantically distinct

[15:09] <flussence> I don't see any way for that to be ambiguous, unless the language allows one `if` to have multiple `else` blocks attached, which doesn't make sense to me

[15:09] * JimmyZ hates elsif :)

[15:09] <masak> JimmyZ: tell me why.

[15:10] <mux> moritz: mmm, I think you're right, it doesn't matter one way or the other :-)

[15:10] <JimmyZ> because I use PHP too. when I use else if in perl, I always got a unexpected wrong

[15:11] <JimmyZ> or switch from other languages 

[15:11] <jnthn> decommute &

[15:11] <flussence> if/else if/else is just a longer way of writing `$if-clause ?? ... !! $else-if-clause ?? ... !! ... # else`, and that's well-defined (well, in most languages...)

[15:11] <masak> JimmyZ: if you have that as a reason, you must also respond to moritz's reason for having 'elsif'.

[15:12] <JimmyZ> elseif is ok to me too.

[15:14] <flussence> (of course, in PHP, nested ternaries behave as uselessly as possible...)

[15:16] <flussence> (wow, ghc takes a *long* time to compile...)

[15:18] *** fsergot left
[15:20] *** sivoais joined
[15:20] *** sivoais left
[15:21] <sorear> good * #perl6

[15:21] *** sivoais joined
[15:21] *** wtw left
[15:23] <masak> hi sorear 

[15:23] * masak decommutes

[15:23] <JimmyZ> what's different between 'if 1 { } else  { if 2 { } else { }  } ' and  'if 1 { } elsif 2 { } else { }  ' 

[15:25] <JimmyZ> the first is C and the second is Perl6

[15:27] <abercrombie> no difference

[15:28] <JimmyZ> 'if 1 { } else if 2 { } else { } ' in C and 'if 1 { } else { if 2 { } else { } } ' ?

[15:29] <JimmyZ> 'if 1 { } else if 2 { } else { } ' in C and 'if 1 { } elsif 2 { } else { } ' in Perl 6?

[15:30] <abercrombie> still no difference since those 2 forms in C are the same.

[15:30] <moritz> I was wrong earlier

[15:30] <moritz> the difference really comes from forcing blocks

[15:30] <sorear> JimmyZ: the elsif version has fewer braces

[15:31] <moritz> not from the 'elsif' vs. 'else if' distinction

[15:31] <geekosaur> blah.  mono-sgen cores on my Air w/latest Mono... (mono works but seems like it's slower?)

[15:32] * geekosaur shouldn't be doing this, probably, but wished he'd had a p6 over the weekend

[15:33] <JimmyZ> sorear: but why disallowed 'else if'

[15:33] <abercrombie> In C, if {} else if {} else {} is the same as if {} else { if {} else {} }

[15:34] <moritz> because we consistently force blocks after 'if' and 'else'

[15:35] <JimmyZ> why not 'else if' = 'elsif' ?

[15:35] <moritz> because we consistently force blocks after 'if' and 'else'

[15:35] <moritz> and we want to avoid exceptions

[15:36] *** am0c joined
[15:36] <JimmyZ> does C have this issues?

[15:37] <JimmyZ> these

[15:37] *** darkop left
[15:37] <abercrombie> JimmyZ: you know, in C actually there isn't a seperate "else if" but really just a simple style for else { if }

[15:37] <moritz> C doesn't force blocks after 'if' and 'else', hence it has the dangling else problem.

[15:37] <JimmyZ> i know it

[15:38] <moritz> which has a rather arbitrary disambiguation rule, which bites you if happen to have formatted your code the other way round

[15:41] *** wamba joined
[15:50] *** agentzh left
[15:50] * JimmyZ would like to suggest that 'else if' is a exception, hehe

[15:51] <moritz> it is. It throws one :-)

[15:51] <moritz> SCNR

[15:51] <JimmyZ> is a exception that not consistently force blocks after else :)

[15:54] * jnthn hope

[15:54] <jnthn> er

[15:54] * jnthn home

[15:55] <geekosaur> perl 6 is trying not to be the crazed bundle of exceptions that perl 5 is

[15:55] <geekosaur> it's perceived as a slippery slope; allow one, then others start to creep in...

[15:56] *** bluescreen10 left
[16:03] *** bluescreen10 joined
[16:04] *** worr joined
[16:04] <geekosaur> also, perl 6 is hardly unique here; sh has elif, and IIRC Algol68 also used elif in preference to else if (for a slightly different reason:  the syntax unambiguously ends ifs, so you can't have dangling else-s, but you would then have a bunch of fi-s which can be avoided by using elif

[16:06] * JimmyZ sleeps

[16:10] *** molaf joined
[16:15] <sorear> goodie, the single-domain change didn't increase #failing-spectest-files

[16:17] <sorear> niecza: say <a b c d>[2,3]

[16:18] <p6eval> niecza v10-66-g71325b0: OUTPUT«c d␤»

[16:18] <sorear> apparently I broke this...?

[16:19] *** wolfman2_ left
[16:20] *** im2ee left
[16:21] *** im2ee joined
[16:24] *** JimmyZ left
[16:40] <TimToady> how is it broke?

[16:41] <sorear> TimToady: confusingly

[16:41] <sorear> it says "c" locally

[16:41] <TimToady> ah

[16:41] <TimToady> arity of array maybe?

[16:41] <sorear> if I copy the definition of Parcel.postcircumfix:<[ ]> into an augment, it works fine

[16:41] <sorear> it's being miscompiled but only if it's in CORE.setting

[16:42] <TimToady> it's acting like [+(2,3)] maybe?

[16:43] <sorear> maybe

[16:43] <sorear> but I'm hunting the difference in the compilation now

[16:46] *** im2ee left
[16:47] *** im2ee joined
[16:53] *** donri joined
[16:59] *** dakkar left
[16:59] *** mberends joined
[17:03] <dalek> rakudo/nom: 6b78ad0 | jnthn++ | src/Perl6/Actions.pm:

[17:03] <dalek> rakudo/nom: Fix code-gen for assignment to native types.

[17:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b78ad0e37

[17:05] *** im2ee left
[17:06] *** im2ee joined
[17:09] *** REPLeffect left
[17:10] <tadzik> #phasers in 20?

[17:10] <jnthn> yes

[17:11] <mberends> hi tadzik, jnthn, *

[17:11] <jnthn> o/ mberends 

[17:11] <tadzik> hello mberends 

[17:11] <tadzik> btw, now #phasers happens to be during my classes

[17:12] *** slavik2 left
[17:14] *** Kivutarrr joined
[17:15] *** pernatiy left
[17:15] *** daniel-s left
[17:17] *** GlitchMr joined
[17:18] *** mj41_nb left
[17:18] *** mj41 left
[17:19] <dalek> roast: 11b1be0 | jnthn++ | S02-types/native.t:

[17:19] <dalek> roast: Unfudge a couple of tests for natives.

[17:19] <dalek> roast: review: https://github.com/perl6/roast/commit/11b1be0e20

[17:19] <dalek> rakudo/nom: a4602de | jnthn++ | src/Perl6/Metamodel/NativeHOW.pm:

[17:19] <dalek> rakudo/nom: Helps to actually compute the MRO before using it. :-) This fixes various issues with native types.

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4602ded5f

[17:20] <jnthn> That's who of today's tickets dealt with. :)

[17:21] <jnthn> *two

[17:21] *** Kivutarrr left
[17:23] *** jdv79 joined
[17:23] <jdv79> jnthn: thx for the blog post!

[17:23] *** packetknife joined
[17:23] <jnthn> jdv79: Blog...oh, it was a little while back though. :)

[17:23] *** aber joined
[17:23] * jnthn should create something else exciting so he can write another one :)

[17:24] *** abercrombie left
[17:24] <dalek> niecza/serialize: 87fff3b | sorear++ | lib/CORE.setting:

[17:24] <dalek> niecza/serialize: Rearrange setting to make inlining work better

[17:24] <dalek> niecza/serialize: 

[17:24] <dalek> niecza/serialize: Also adds missing \s to non-inlined versions of &postcircumfix ops.

[17:24] <dalek> niecza/serialize: Fixes <a b c d>[2,3].

[17:24] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/87fff3b069

[17:26] *** slavik1 joined
[17:27] *** abercrombie joined
[17:27] <jnthn> tadzik: I just ran setting compilation through the sub profiler and got a curious result. The optimizer seems to account for only 4% of time spent in compiling CORE.setting here.

[17:27] <tadzik> jnthn: right, I measured it today and it's still about 3 minutes

[17:28] <tadzik> wonder what caused that back then, weird

[17:28] <tadzik> I must keep better track of those results

[17:28] <tadzik> compiling of the Optimizer.pm itself can't be that long, it's just nqp

[17:30] *** packetknife left
[17:30] *** aber left
[17:34] <dalek> niecza/serialize: 0271633 | sorear++ | lib/CodeGen.cs:

[17:34] <dalek> niecza/serialize: Implement SubInfo.transparent required for &?BLOCK

[17:34] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/0271633471

[17:34] *** buubot_backup left
[17:36] <diakopter> .

[17:37] <sjohnson> ,

[17:39] <sorear> !

[17:41] <geekosaur> ∭

[17:41] <sjohnson> heh

[17:44] <dukeleto> [~~]

[17:48] <mberends> ⌨

[17:49] <sjohnson> (='.'=)

[17:53] <dalek> niecza/serialize: 9ee80cd | sorear++ | lib/Kernel.cs:

[17:53] <dalek> niecza/serialize: Fix GLOBAL/PROCESS in indirect name usage (how did this ever work?)

[17:53] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/9ee80cdb00

[17:54] *** buubot_backup joined
[18:00] <dalek> niecza/serialize: 09b8ac7 | sorear++ | lib/CodeGen.cs:

[18:00] <dalek> niecza/serialize: Actually report errors from C3 inconsistency...

[18:00] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/09b8ac7737

[18:01] <diakopter> std: 4 +| 5

[18:01] <p6eval> std 580b69a: OUTPUT«ok 00:01 120m␤»

[18:01] <diakopter> rakudo: say 4 +| 5

[18:01] <p6eval> rakudo a4602d: OUTPUT«5␤»

[18:09] *** Reaganomicon joined
[18:13] <[Coke]> rakudo: my $¢=32;

[18:13] <p6eval> rakudo a4602d: OUTPUT«===SORRY!===␤Confused at line 1, near "my $\x{a2}=32;"␤»

[18:14] <dalek> niecza/serialize: 4c49318 | sorear++ | lib/ObjModel.cs:

[18:14] <dalek> niecza/serialize: Fix stubbing of modules

[18:14] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/4c49318784

[18:17] <TimToady> perl6: [[1,2,3],[4,5,6],[7,8,9]]»[0].say

[18:17] <p6eval> rakudo a4602d, niecza v10-66-g71325b0: OUTPUT«1 2 3 4 5 6 7 8 9␤»

[18:17] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\187'␤*** ␤    Unexpected "\187["␤    expecting term postfix or operator␤    at /tmp/F3bf2NksVb line 1, column 26␤»

[18:17] <TimToady> pugs: [[1,2,3],[4,5,6],[7,8,9]]>>[0].say

[18:17] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected ">>["␤    expecting term postfix or operator␤    at /tmp/6rI8WNnHT_ line 1, column 26␤»

[18:18] <TimToady> pugs: [[1,2,3],[4,5,6],[7,8,9]]>>.[0].say

[18:18] <p6eval> pugs b927740: OUTPUT«␤»

[18:18] <TimToady> b: [[1,2,3],[4,5,6],[7,8,9]]»[0].say

[18:18] <p6eval> b 1b7dd1: OUTPUT«147␤»

[18:18] <TimToady> masak: I'm trying to figure out what you mean by "real code" in http://irclog.perlgeek.de/perl6/2011-10-26#i_4616132

[18:19] <TimToady> only b is close to currently specced semantics for ».[0]

[18:21] <diakopter> TimToady: is "It is not necessary to type any of the unicode symbols. They all have an equivalent that is plain ASCII" still valid?  (sorear pointed out $¢)

[18:23] <moritz> masak: does markdown support something like meta data/annotations?

[18:23] <masak> not explicitly.

[18:24] <masak> but it supports arbitrary XML...

[18:24] *** bluescreen10 left
[18:25] <masak> TimToady: code that I wrote for a purpose other than just fun. in Niecza.

[18:26] * moritz wonders what format to write the FAQs in

[18:26] <PerlJam> pod6

[18:26] <sorear> moritz: iambic pentameter

[18:26] <masak> Klingon.

[18:26] <PerlJam> all of the above?

[18:26] <sorear> masak: does that count as a format?

[18:28] * moritz doesn't know any Klingon, and doesn't see much advantage in using it

[18:28] <PerlJam> masak: that code you wrote for purposes other than fun ... you also wrote it for fun too, right?

[18:29] <masak> Pod6 could use the exercise, I guess.

[18:29] <masak> Markdown is less hassle for you.

[18:30] <jdv79> jnthn: yeah, i only remember to check once in a while.

[18:31] <TimToady> masak: my point is that it doesn't work in niecza, unless maybe in /serialize

[18:31] <TimToady> it still has the old semantics

[18:31] <TimToady> which preclude using » and .[0] together, other than as a nop on the leaves

[18:32] <sorear> Is there a connection here between ».[0] and masak's real code?

[18:32] <TimToady> http://irclog.perlgeek.de/perl6/2011-10-26#i_4616132

[18:33] <TimToady> perl6: [[1,2,3],[4,5,6],[7,8,9]]»[1].say

[18:33] <p6eval> niecza v10-66-g71325b0: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 641 (CORE warn @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[18:33] <p6eval> ..rakudo a4602d: OUTPUT«.[1] out of range for type 1␤  in method at_pos at src/gen/CORE.setting:1013␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:991␤  in method reify at src/gen/CORE.setting:4052␤  in method reify at src/gen/CORE.setting:3959␤  in method reify at src/gen/CORE.…

[18:33] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\187'␤*** ␤    Unexpected "\187["␤    expecting term postfix or operator␤    at /tmp/b9Rijo08qs line 1, column 26␤»

[18:33] <TimToady> b: [[1,2,3],[4,5,6],[7,8,9]]»[1].say

[18:33] <p6eval> b 1b7dd1: OUTPUT«258␤»

[18:33] <[Coke]> b,nom: say "be nice if this worked."

[18:34] *** mberends_ joined
[18:35] <TimToady> diakopter: $¢ is just experimental error  :P

[18:35] *** mberends left
[18:35] <moritz> [Coke]: not too hard to do, I guess

[18:35] *** mberends_ left
[18:36] <[Coke]> then we can remove "pugs" from perl6 and easily add it back in if we want it.

[18:36] *** slavik1 left
[18:36] <moritz> well, that's just a one-line patch anyway :-)

[18:37] *** slavik1 joined
[18:37] <TimToady> well, obviously someone just needs fix pugs

[18:37] <TimToady> *to fix

[18:37] <masak> :)

[18:38] *** molaf left
[18:39] <TimToady> it's easy, just add 6model, and STD parser, and fix all the hacky parts to work around the absence of regexes, and maybe another minor thing or two...

[18:39] *** fsergot joined
[18:39] <moritz> and the compiler middleware, I guess

[18:40] <masak> sounds like fun!

[18:40] <TimToady> or just backend one of the other implementations to emit .hs, and call it pugs

[18:40] <PerlJam> TimToady: would it be $ɛ or something if it were experimental error?  :)

[18:41] *** bluescreen10 joined
[18:42] <TimToady> no, it would be $ε instead :P

[18:42] <moritz> .u ε

[18:42] <phenny> U+03B5 GREEK SMALL LETTER EPSILON (ε)

[18:43] <sorear> hrrm.  seems I've broken return-pass

[18:43] <TimToady> .u ɛ

[18:43] <phenny> U+025B LATIN SMALL LETTER OPEN E (ɛ)

[18:43] <PerlJam> I did say "or something"

[18:45] *** Chillance joined
[18:48] *** mberends joined
[18:49] * sorear needs to write some kind of debug dumper for .ser files

[18:49] *** ksi joined
[18:51] <cognominal_> This may interest jnthn. A mere use of https://github.com/ihrd/uri/blob/master/lib/IETF/RFC_Grammar.pm  triggers Malformed $*PKGDECL at line 46, near "=> $init_g"

[18:52] <cognominal_> this package contains a require, but that should be runtime...

[18:53] <cognominal_> I would not be surprised if that was related to the serialization stuff

[18:55] <PerlJam> it looks to me like it's treating "grammar => $init_grammar" as a grammar declaration.

[18:55] <PerlJam> (or trying to anyway)

[18:55] <moritz> :grammar($init_grammar) would be a workaround

[18:56] <masak> we have an RT ticket about such behavior.

[18:56] <masak> I don't remember if we closed it. I think we did.

[18:56] <dalek> faq: 6a76d0b | moritz++ | answers.md:

[18:56] <dalek> faq: link to source

[18:56] <dalek> faq: review: https://github.com/perl6/faq/commit/6a76d0bf95

[18:58] <[Coke]> now if I could just get moritz to work on this java for me.

[18:59] <moritz> masak: that ticket is still open in nom

[18:59] <cognominal_> Perljam, moritz. indeed this keyword is not  protected by an <end_keyword>

[19:00] <PerlJam> Is that a LHF?  Sounds like it.

[19:00] <masak> moritz: ah. thank you.

[19:00] <masak> PerlJam: wouldn't surprise me if t'were tied to LTM somehow.

[19:00] <moritz> nom: say (trusts => 1)

[19:00] <p6eval> nom a4602d: OUTPUT«"trusts" => 1␤»

[19:01] <PerlJam> masak: ah, could be.

[19:01] <moritz> I'll try it with end_keyword

[19:01] <moritz> nom: say (grammar => 1)

[19:01] <p6eval> nom a4602d: OUTPUT«===SORRY!===␤Malformed $*PKGDECL at line 1, near "=> 1)"␤»

[19:02] <moritz> cognominal_: the <.end_keyword> is at the start of package_def

[19:02] <cognominal_> I dream of a        proto token package_declarator is keyword{ <...> }

[19:03] *** slavik1 left
[19:03] <cognominal_> that would append a <end_keyword> after the <sym>

[19:04] <moritz> how does STD do it?

[19:04] <GlitchMr> print STDERR "lol"

[19:04] <GlitchMr> How can I do it in Perl 6?

[19:04] <PerlJam> GlitchMr: just like that?

[19:05] <PerlJam> well, not quite like that I guess

[19:05] <GlitchMr> Could not find sub &STDERR

[19:05] <GlitchMr> ...

[19:05] <PerlJam> use $*ERR

[19:05] <cognominal_> moritz, meaning it appears to late because the 'grammar' token is already reduced at that stage?

[19:05] <sorear> print $*ERR: "lol"

[19:05] *** slavik1 joined
[19:05] <GlitchMr> perl6: print $*ERR: "There is something wrong on line .\n";

[19:05] <p6eval> niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Invocant handling is NYI at /tmp/xXoPnwelMx line 1:␤------> [32m: "There is something wrong on line .\n"[33m⏏[31m;[0m␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die…

[19:05] <p6eval> ..rakudo a4602d: OUTPUT«===SORRY!===␤Confused at line 1, near "print $*ER"␤»

[19:05] <p6eval> ..pugs b927740: OUTPUT«There is something wrong on line .␤»

[19:06] <GlitchMr> ...

[19:06] <sorear> why do you ... so much

[19:06] <sorear> use words, they're clearer

[19:06] <moritz> sorear++

[19:06] <GlitchMr> :)

[19:06] <GlitchMr> Yeah. Right.

[19:06] <sorear> also pugs++

[19:06] <GlitchMr> I don't know English.

[19:06] <[Coke]> also, please don't use "perl6:" unless you mean it. it's quite verbose.

[19:06] <moritz> GlitchMr: then don't use ... either. It doesn't tell us anything

[19:07] <PerlJam> GlitchMr: $*ERR.print: "foo"

[19:07] <cognominal_> anyway you gave me the workaround

[19:07] <GlitchMr> rakudo: $*ERR.print "There is something wrong on line .\n";

[19:07] <p6eval> rakudo a4602d: OUTPUT«===SORRY!===␤Confused at line 1, near "$*ERR.prin"␤»

[19:07] <jnthn> Need the colon

[19:07] <GlitchMr> rakudo: $*ERR.print: "There is something wrong on line .\n";

[19:07] <p6eval> rakudo a4602d: OUTPUT«There is something wrong on line .␤»

[19:07] <GlitchMr> Thanks :)

[19:08] <PerlJam> I wonder why the dative form didn't work.

[19:08] <PerlJam> maybe my brain is just comingling perl 5 and perl 6 too much

[19:09] <TimToady> perl6: note "lol"

[19:09] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&note"␤    at /tmp/o3IAVDLOm5 line 1, column 1 - line 2, column 1␤»

[19:09] <p6eval> ..rakudo a4602d, niecza v10-66-g71325b0: OUTPUT«lol␤»

[19:10] <sorear> PerlJam: print $*ERR: "foo" is *supposed* to work but only implmeneted by pugs atm.

[19:10] <TimToady> perl6: note lol "lol"

[19:10] <p6eval> niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'lol' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤ …

[19:10] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&note"␤    at /tmp/MYhSSs7gma line 1, column 1 - line 2, column 1␤»

[19:10] <p6eval> ..rakudo a4602d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&lol' called (line 1)␤»

[19:10] <sorear> TimToady++ # I didn't think of that at all

[19:11] <sorear> TimToady: say eval '&?BLOCK.WHAT' # this has just come up

[19:12] <GlitchMr> (\N*) ::: { fail "Invalid diff hunk: $1" }

[19:12] <GlitchMr> What is \N?

[19:12] <sorear> not a newline

[19:12] <TimToady> not \n

[19:12] <GlitchMr> OK :)

[19:12] <TimToady> and \R is not \r, unlike in p5

[19:13] <TimToady> p5's \R is just \n in p6

[19:13] <moritz> GlitchMr: read S05 for more info on regexes

[19:14] <jnthn> sorear: Guess it's Block since eval implies a lexical scope

[19:14] <moritz> cognominal_: I have a patch for the <.end_keyword> things, spectest now...

[19:14] <TimToady> is there any reason it needs to be differentiated from Block?

[19:15] <TimToady> GlitchMr: perhaps if you translated the synopses into Polish you wouldn't have to read them in English :)

[19:15] <sorear> well, it's got to provide $! $/ lexicals

[19:15] <GlitchMr> :P

[19:16] <dalek> faq: 2695668 | moritz++ | / (2 files):

[19:16] <dalek> faq: answer another question

[19:16] <dalek> faq: review: https://github.com/perl6/faq/commit/26956682e5

[19:16] <TimToady> seriously, you keep asking questions that could be answered with a grep of the synopses

[19:17] * [Coke] ponders a nicely formatted hardcopy of the SYN.

[19:18] <cognominal_> TimToady, maybe there should be a keyword "keyword" used in place of "token" that would imply an implit <.end_keyword>.

[19:18] <cognominal_> *implicit

[19:18] <TimToady> and where would .end_keyword go?

[19:18] <moritz> [Coke]: it would be out of date before the printing press spit out the last page :-)

[19:19] <[Coke]> moritz: sometimes it's nice to read things on paper.

[19:19] * jnthn actually met somebody with a printed copy of the Perl 6 synopses once :)

[19:19] * jnthn tries to recall who/where 

[19:19] <GlitchMr> m:P5/(?mi)^(?:[a-z]|\d){1,2}(?=\s)/

[19:19] <GlitchMr> ... ok...

[19:20] <masak> GlitchMr: if you don't say more, we don't know what you mean.

[19:20] <GlitchMr> :)

[19:20] <cognominal_> jnthn, you need to buy a RV or a truck to carry the synopses?

[19:20] <cognominal_> or an iPad? :)

[19:22] <cognominal_> TimToady, the <.end_keyword> would be implied after the declared token within the rule that define it.

[19:22] <GlitchMr>         | (.**1..10)

[19:22] <GlitchMr>           {

[19:22] <GlitchMr>                 $*ERR.print: "There is something wrong near " ~ (~$0).perl ~ ".\n";

[19:22] <GlitchMr>                 return 0.42 # just to end parsing of grammar

[19:22] <GlitchMr>           }

[19:22] <GlitchMr> (I wanted to type ...)

[19:23] <moritz> GlitchMr: please don't paste more than one line of code here. Use a pastebin

[19:23] <GlitchMr> That's probably bad coding... yeah... I guess I cannot make good code...

[19:23] <masak> GlitchMr: http://gist.github.com is one.

[19:23] <cognominal_> token terminator:sym<when>   { 'when'   <.end_keyword> }    would  be    keyword terminator:sym<when>;  

[19:23] <cognominal_> because the block that defines it would be redundant.

[19:24] * moritz is not sure that use case is general enough, but it reads nicely

[19:24] <sorear> moritz: macro! :D

[19:25] <TimToady> that is currently written: token terminator:sym<when> { <sym> } with an implied .endsym

[19:25] <cognominal_> going that way on want to be wild and do  write    keyword terminator:sym<if when unless while…>

[19:25] <cognominal_> when a factorization lead to another, that a good sign.

[19:26] <cognominal_> TimToady: in nom, the .endsym is currently explicit

[19:26] <TimToady> in which case you'd *have* to use use <sym> since it's generic, not 'when'

[19:26] <TimToady> so the current way is more powerful, if we allow slices

[19:27] *** chromis joined
[19:27] <TimToady> .oO(sliced declarations, sheesh...)

[19:27] <dalek> niecza/serialize: 3c4b14d | sorear++ | src/NieczaGrammar.pm6:

[19:27] <dalek> niecza/serialize: Prevent mainline Routines from eating return exceptions

[19:27] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/3c4b14d5e6

[19:27] <TimToady> well, more like hyper declarations

[19:27] <dalek> roast: 7f92c99 | moritz++ | S02-literals/pairs.t:

[19:27] <dalek> roast: unfudge passing tests

[19:27] <dalek> roast: review: https://github.com/perl6/roast/commit/7f92c991d1

[19:27] <dalek> rakudo/nom: 158bd07 | moritz++ | src/Perl6/Grammar.pm:

[19:27] <dalek> rakudo/nom: protect "grammar" etc with <.end_keyword>

[19:27] <dalek> rakudo/nom: 

[19:27] <dalek> rakudo/nom: cognominal++ noted that it is applied too late (after the package_declarator:sym<...>

[19:27] <dalek> rakudo/nom: action method has fired)

[19:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/158bd07eef

[19:28] <TimToady> but a slice is a sort of hyper-y thing, I guess

[19:28] <sorear> niecza should be down to 10 failing files

[19:30] <TimToady> don't want to distract you, but it'd be nice if duck mapping S03:4276 could get in before your relase

[19:31] <TimToady> *lease

[19:31] <TimToady> nom too, for that matter

[19:31] <jnthn> Do we have an RT for it? If not, plesae somebody make one...RT is my extra memory at the moment :)

[19:31] <TimToady> then masak++'s Real Code™ would work

[19:32] <masak> it *did* work...

[19:32] <TimToady> on nom?

[19:32] <TimToady> I don't see how

[19:32] <TimToady> I showed ^^ that it doesn't work

[19:32] <masak> on Niecza.

[19:32] *** bluescreen10 left
[19:33] <TimToady> doesn't work there either

[19:33] <masak> with Match objects.

[19:33] * moritz submits rakudotodo

[19:33] <TimToady> niecza: [[1,2,3],[4,5,6],[7,8,9]]»[1].say

[19:33] <p6eval> niecza v10-66-g71325b0: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 641 (CORE warn @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[19:34] <TimToady> I'd say Match objects are only working accidentally

[19:34] <masak> niecza: "oh %foo% and %bar% but %baz% too".comb(/ '%' (\w+) '%' /)>>[0].perl

[19:34] <p6eval> niecza v10-66-g71325b0:  ( no output )

[19:34] <masak> niecza: say "oh %foo% and %bar% but %baz% too".comb(/ '%' (\w+) '%' /)>>[0].perl

[19:34] <p6eval> niecza v10-66-g71325b0: OUTPUT«["%foo%", "%bar%", "%baz%"].list␤»

[19:34] <masak> \o/

[19:34] <masak> nothing accidental about it ;)

[19:34] <sorear> looks like niecza is checking ~~ List | Parcel | Range

[19:35] <TimToady> niecza: say "oh %foo% and %bar% but %baz% too".comb(/ '%' (\w+) '%' /).list»[0].perl

[19:35] <p6eval> niecza v10-66-g71325b0: OUTPUT«["%foo%", "%bar%", "%baz%"].list␤»

[19:36] <TimToady> niecza: say "oh %foo% and %bar% but %baz% too".comb(/ '%' (\w+) '%' /).list».perl

[19:36] <p6eval> niecza v10-66-g71325b0: OUTPUT«"%foo%" "%bar%" "%baz%"␤»

[19:38] <TimToady> anyway, it's supposed to try the [0] before checking for recursion (and ignore the [0] from Any somehow)

[19:39] <masak> I can't decide if I like or dislike the discontinuity of recursing for some things and not for others... :)

[19:40] *** zamolxes left
[19:40] *** zamolxes joined
[19:41] *** manildomin joined
[19:41] <manildomin> hi

[19:42] <moritz> hello manildomin 

[19:42] <dalek> roast: 918275a | moritz++ | S02-types/hash.t:

[19:42] <dalek> roast: unfudge another test for rakudo

[19:42] <dalek> roast: review: https://github.com/perl6/roast/commit/918275a5b1

[19:42] <masak> manildomin! \o/

[19:42] <manildomin> hi

[19:43] <masak> manildomin: how's it going with Perl 6?

[19:44] * moritz -> sleep

[19:44] <manildomin> it's giving me some difficulties but I think Perl6 is interesting so I keep learning it

[19:45] <masak> 'night, moritz 

[19:45] <masak> manildomin: if you have any favourite difficulties, we're here to help.

[19:45] <manildomin> thanks

[19:45] <manildomin> I assume that Rakudo compiles perl6 code to bytecode for parrot, am I right?

[19:46] <cognominal_> TimToady: the problem with the hyperop-y syntax to fold a proto regex is that is conflict with the multitokenish convention used for circumfix.

[19:47] <masak> manildomin: right.

[19:47] <masak> well, at least to PIR.

[19:47] <cognominal_> I seee this hyperop-y syntax would apply in many places in the grmmar.

[19:48] <manildomin> ok, then is it possible asking rakudo not to run the program but to give a pir output file instead?

[19:48] *** chromis left
[19:48] <masak> manildomin: been a while since I tried it -- but yes.

[19:48] <masak> manildomin: why -- are you experiencing long compile times?

[19:50] <manildomin> I was just wondering if it was possible

[19:50] <cognominal_>     token circumfix:sym<[ ]> { '[' <semilist> ']' }  # on the other hand, there would be no hyperoperated sym here 

[19:50] *** bluescreen10 joined
[19:50] <masak> wah, ok.

[19:50] <PerlJam> manildomin: perl6 --target=pir -e 'say "hi"'

[19:50] <manildomin> ok, thanks

[19:58] <manildomin> I have an issue with a code found in the book "Using Perl6" (again :))

[19:58] <masak> which one?

[19:58] <masak> nom: given sqrt -1 -> $_ is copy { .=subst(/N$/, "m!"); say .subst("N", "Wh"); say .subst("N", "B"); say .subst("N", "Thank you M") }

[19:58] <p6eval> nom a4602d: OUTPUT«Wham!␤Bam!␤Thank you Mam!␤»

[19:59] <masak> :)

[19:59] <masak> nom: given sqrt -1 -> $_ is copy { .=subst(/N$/, "m!"); say .subst("N", "Wh"); say .subst("N", "B"); say .subst("N", "Thank you M").subst("am", "a'm" }

[19:59] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[19:59] <masak> nom: given sqrt -1 -> $_ is copy { .=subst(/N$/, "m!"); say .subst("N", "Wh"); say .subst("N", "B"); say .subst("N", "Thank you M").subst("am", "a'm") }

[19:59] <p6eval> nom 158bd0: OUTPUT«Wham!␤Bam!␤Thank you Ma'm!␤»

[20:00] <manildomin> this one : http://pastebin.com/nbnhhrrZ

[20:00] * masak looks

[20:01] <PerlJam> nom doesn't grok that syntax yet, does it?

[20:01] <masak> nom: my @a; my :($first, *@rest) := \(|@a);

[20:01] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤Malformed my at line 1, near ":($first, "␤»

[20:01] <masak> seems not.

[20:01] <masak> b: my @a; my :($first, *@rest) := \(|@a); say "alive"

[20:01] <PerlJam> (I'm not even sure b did :)

[20:01] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Malformed my at line 22, near ":($first, "␤»

[20:01] <masak> seems not :)

[20:02] <jnthn> std: my @a; my :($first, *@rest) := \(|@a); say "alive"

[20:02] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/FTwI75S8RI line 1:␤------> [32mmy @a; my [33m⏏[31m:($first, *@rest) := \(|@a); say "alive"[0m␤    expecting scoped declarator␤Parse failed␤FAILED 00:01 120m␤»

[20:02] <manildomin> my version of Rakudo is Rakudo Perl 6, version 2011.04 built on parrot 3.8.0 0

[20:02] <manildomin> maybe it's too old?

[20:02] <jnthn> not even STD :P

[20:02] <masak> uhm.

[20:02] <masak> maybe the colon simply shouldn't be there?

[20:03] <PerlJam> then why do I remember that syntax?

[20:03] <masak> yeah, good question.

[20:04] * jnthn doesn't think it should be there

[20:04] * masak checks S06

[20:04] <masak> S06:1480: my (@a,@b,@c) := |$foo;

[20:05] <masak> S06:1732: my Dog ($fido, $spot)   := twodogs();

[20:05] <PerlJam> S03:280L   Signature literal   :(Dog $self:)

[20:05] <masak> S06:3220: :(:who($name), :why($reason)) := (why => $because, who => "me");

[20:05] <PerlJam> s/L/:/

[20:06] <masak> PerlJam: I don't think :() works with, my, is all.

[20:06] <masak> s/,//

[20:06] *** cooper joined
[20:06] <masak> 'night, #perl6

[20:06] <PerlJam> masak: S03:4882:  my :(Dog $foo is woof = 123); # same thing (full Signature form)

[20:06] <manildomin> 'night

[20:07] *** jlaire left
[20:07] <PerlJam> The text starting from S03:4952 too

[20:08] <PerlJam> especially where it says "Signatures are expected after declarators such as C<my>, C<sub>, C<method>, C<rule>, etc.  In such declarators the colon may be omitted.  But it's also legal to use it"   :-)

[20:09] <manildomin> if I remove it the code works flawlessly

[20:15] *** GlitchMr left
[20:16] <im2ee> Good night! :)

[20:17] *** im2ee left
[20:20] *** jlaire joined
[20:25] *** MayDaniel joined
[20:32] *** Je joined
[20:35] *** Je left
[20:38] *** dorlamm joined
[20:39] *** MayDaniel left
[20:39] *** envi_ left
[20:44] *** jlaire left
[20:44] *** jlaire joined
[20:52] *** pat____ joined
[20:52] <pat____> hi

[20:52] <pat____> have been playing around with "but" and some questions arose.

[20:52] *** manildomin left
[20:54] *** y3llow_ joined
[20:54] *** pothos_ joined
[20:56] *** pothos left
[20:56] *** pothos_ is now known as pothos

[20:56] *** y3llow left
[20:56] *** y3llow_ is now known as y3llow

[20:57] <pat____> if I do “my $foo = *+* but role {method Str {"+"}}” 

[20:57] *** kaare_ joined
[20:58] <pat____> it seems to me that it get Stringified to early when I try it on interactive perl

[20:59] <benabik> pat____: It may be that the REPL is using either .gist or .perl to perform the output instead of .Str

[20:59] <pat____> yeah let me specify

[21:00] <pat____> I want a variable ($foo) that returns e.g.  7 if called with $foo(3,4) and "+" if called ~$foo

[21:01] <benabik> Oh that's interesting...

[21:01] <pat____> yeah

[21:01] <benabik> nom: my $foo = *+* but role {method Str {"+"}}; say $foo(3,4); say $foo

[21:01] <p6eval> nom 158bd0: OUTPUT«+␤WhateverCode.new()␤»

[21:01] *** DataLinkDKT left
[21:02] <pat____> interesting, my nom here at home says "+"

[21:02] <benabik> b: my $foo = *+* but role {method Str {"+"}}; say $foo(3,4); say $foo

[21:02] <p6eval> b 1b7dd1: OUTPUT«7␤_block1093␤»

[21:03] <benabik> I would say that both b and nom are wrong here...

[21:03] *** DataLinkDKT joined
[21:04] *** DataLinkDKT left
[21:04] *** wamba left
[21:04] <pat____> nom: my $foo = *+* but role {method Str {"+"}}; say "{~$foo} || {$foo(4,3)}"

[21:04] <p6eval> nom 158bd0: OUTPUT«_block1411 || +␤»

[21:05] <jnthn> You need a method gist in the role, not a method Str

[21:05] <pat____> what's gist, don't know that

[21:05] <jnthn> nom: my $foo = *+* but role { method gist {"+"}}; say $foo(3,4); say $foo

[21:05] <p6eval> nom 158bd0: OUTPUT«+␤WhateverCode.new()␤»

[21:05] <pat____> it's the same

[21:06] <jnthn> hmm

[21:06] <jnthn> oh

[21:06] <jnthn> nom: my $foo = (*+*) but role { method gist {"+"}}; say $foo(3,4); say $foo

[21:06] <p6eval> nom 158bd0: OUTPUT«+␤WhateverCode.new()␤»

[21:06] <jnthn> no, not that.

[21:07] <pat____> yeah though about that, but if the brackets were wrong they would be *+(* but role{…})

[21:07] <jnthn> Yes, that's what I was wondering about.

[21:09] <pat____> so, can we say that wasn't considered yet in the implementation, but my intetion was right

[21:09] <pat____> ?

[21:09] <pat____> or am I missing something with that "but"

[21:09] <jnthn> pat____: Looks like it should work. Not quite sure what the underlying bug is - I can't think of any reason off hand why it would fail to work.

[21:10] <benabik> I'm also curious about the fact that $foo(3+4) actually returns "+"

[21:10] <jnthn> Right. :)

[21:10] <pat____> me too

[21:10] <jnthn> I really want to know what on earth is going on there.

[21:10] <pat____> that's why I came here

[21:10] <jnthn> Given I did the mixins implementation, guess that's one for me to fathom... :)

[21:10] <benabik> pat____: If jnthn doesn't know what's happening, then us mere mortals are doomed.  ;-)

[21:11] <jnthn> OH!

[21:11] <jlaire> nom: my $foo = { ($^a + $^b) but role { method gist {"+"} }; say $foo(3,4); say $foo

[21:11] <jnthn> bwaha

[21:11] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[21:11] <jlaire> nom: my $foo = { ($^a + $^b) but role { method gist {"+"} } }; say $foo(3,4); say $foo

[21:11] <p6eval> nom 158bd0: OUTPUT«+␤Block.new()␤»

[21:12] <jnthn> nom: my $foo = *+*; $foo = $foo but role { method gist {"+"}}; say $foo(3,4); say $foo

[21:12] <p6eval> nom 158bd0: OUTPUT«7␤+␤»

[21:12] <jnthn> Yeah, currying gone wild

[21:12] <jlaire> .oo( $foo but= ... )

[21:12] <jnthn> The whatever currying is transitive.

[21:12] <jnthn> Thus

[21:12] <jnthn> * + * but blah

[21:12] <jnthn> becomes

[21:13] <jnthn> -> $x, $y { $x + $y but blah }

[21:13] <benabik> !!

[21:13] <PerlJam> rakudo needs a --deparse option  :)

[21:13] <jnthn> e.g. it actually sucks the but into the closure too :)

[21:13] <jlaire> yay, I guessed right

[21:13] <jnthn> Well, when you do * + * / 2 or something it's what you want :)

[21:13] <benabik> There's no way to limit the extent of *, is there?

[21:13] <jnthn> But given it just took me 5 minutes to realize what on earth was going on, maybe we should shove does and but on the exclude list for * currying...

[21:13] <jnthn> Opinions welcome. 

[21:14] <jnthn> TimToady: ^^

[21:14] <jnthn> benabik: Don't think so

[21:14] <jnthn> OK, so at least it's not actually a bug in mixins. *phew* :)

[21:14] <jlaire> maybe we'll be able to define a special type of parens that does that as a macro some day

[21:15] <pat____> sorry for even considering that

[21:16] <benabik> I wonder if * should stop at {}s.

[21:16] <jnthn> pat____: Don't worry, it surprised me too.

[21:16] <benabik> my $foo = {*+*} but "+"

[21:16] <jnthn> benabik: Well, but now you have a closure that returns a closure...

[21:16] <jlaire> you need to call it twice

[21:17] <tadzik> 'evening

[21:17] <PerlJam> jlaire: nah, just call the result of calling it 

[21:17] <benabik> jnthn: That's what it does _now_ sure.

[21:17] <jnthn> o/ tadzik 

[21:17] <jnthn> benabik: I don't think I want to break that, or so goes my initial reaction.

[21:17] *** cooper left
[21:17] <jnthn> benabik: I agree some mechanism for saying "that's quite enough curry for today, thanks" could be handy.

[21:17] <jnthn> But then you could always just write it another way.

[21:18] <PerlJam> jnthn: I like your idea about does/but

[21:18] <PerlJam> jnthn: and will would have to be on that list too

[21:18] <jnthn> nom: my $foo = {$^a + $^b} but role { method gist {"+"}}; say $foo(3,4); say $foo

[21:18] <benabik> jnthn: My thought was that {} already generated a closure, so why do a closure inside a closure?  If you still needed it you could do {{*+*}}

[21:18] <p6eval> nom 158bd0: OUTPUT«7␤+␤»

[21:18] <jnthn> PerlJam: will?

[21:19] <jnthn> PerlJam: There's a will infix?

[21:19] <benabik> nom: my $foo = {$^a + $^b} but "+"; say ~$foo; say $foo(3,4)

[21:19] <p6eval> nom 158bd0: OUTPUT«+␤7␤»

[21:19] <jnthn> I thought that was just a trait...

[21:19] <PerlJam> oh, maybe.

[21:19] <jnthn> PerlJam: I can happily add does/but to the list. Want to give @other time to ponder the issue first though.

[21:20] <benabik> pat____: {$^a + $^b} but "+" seems to DTRT, although you'll still need the role { method gist {}} if you want to change how it responds to say instead of just ~.

[21:21] <pat____> okay, thanks a lot, so there's no way to do that with the whatever “*”?

[21:21] * benabik wonders if $foo but "foo" should override .gist in addition to .Str

[21:22] <benabik> pat____: Apparently only the two statement way (although that may change): my $foo = *+*; $foo = $foo but "+"

[21:22] <jnthn> $foo but= role { ... } should work too

[21:23] <benabik> nom: my $foo = *+*; $foo but= '+'; say ~$foo

[21:23] <p6eval> nom 158bd0: OUTPUT«+␤»

[21:24] <benabik> golfing is fun

[21:24] <pat____> nom: my $foo; ($foo = *+*) but= "+"

[21:24] <p6eval> nom 158bd0:  ( no output )

[21:25] <pat____> nom: my $foo; ($foo = *+*) but= "+"; say ~$foo, $foo(2,3)

[21:25] <p6eval> nom 158bd0: OUTPUT«+5␤»

[21:25] <pat____> got it

[21:25] <benabik> nom: (my $foo = *+*) but= '+'; say ~$foo, $foo(2,3)

[21:25] <p6eval> nom 158bd0: OUTPUT«+5␤»

[21:25] <jnthn> oh, cute. :)

[21:25] <jnthn> yeah, = is on the no-curry list.

[21:26] <benabik> Cute is one word for it.  :-D

[21:26] *** bluescreen10 left
[21:27] <jnthn> Cute is good :)

[21:28] <benabik> I can't think of a situation where $foo = {*+*} needing $foo()(1,1) is useful.

[21:28] <benabik> I can see why it's the case, but I don't see why that would be intended.

[21:29] *** soh_cah_toa joined
[21:29] <pat____> maybe some "stop currying brackets=

[21:30] <pat____> like 《》

[21:31] <pat____> I can't think of a way macros could do that in an easy way

[21:31] <pat____> oh

[21:31] *** pat____ left
[21:32] <benabik> Rewrite 《foo》to {my $temp = foo; $temp}() ?

[21:35] *** cooper joined
[21:36] <benabik> nom: $_ = {*+*}; .()(1,1).say; $_ = {{*+*}}; .()(1,1).say; $_ = { {*+*} }; .()(1,1).say

[21:36] <p6eval> nom 158bd0: OUTPUT«2␤2␤2␤»

[21:37] <benabik> Strange to me that any number of {}s only produce one additional closure.

[21:37] <jnthn> Well, it's an inline block inside the next one.

[21:37] <jnthn> Same reason that

[21:37] <jnthn> nom: { say 1 }; { say 2 }

[21:37] <p6eval> nom 158bd0: OUTPUT«1␤2␤»

[21:37] <jnthn> does that.

[21:38] <benabik> But the first ones in an assignment create a closure.  Okay.  :-/

[21:39] <benabik> $_ = {my $a={*+*}}; .()()(1,1).say

[21:39] <benabik> nom: $_ = {my $a={*+*}}; .()()(1,1).say

[21:39] <p6eval> nom 158bd0: OUTPUT«2␤»

[21:39] <benabik> Okay, enough (ab)using that.

[21:47] *** pernatiy joined
[21:53] *** benabik left
[21:57] *** ab5tract left
[22:01] *** kaare_ left
[22:17] *** MayDaniel joined
[22:20] *** dorlamm left
[22:21] *** whiteknight joined
[22:22] *** cooper left
[22:23] *** ksi left
[22:23] <cognominal_> in nqp/src/NQPQ/Grammar.pm, I can't parse    the <?[<[]> in         | <sigil> <?[<[]> <postcircumfix>

[22:24] <cognominal_> from the context, I understand it is a zero width assertion that is true is the current char is either '<' or '['  but nevertheless I can't visually parse it

[22:25] <cognominal_> ho, noe I can!

[22:26] <cognominal_> *now

[22:26] <cognominal_> with the '?', I was unable to recognize the character class

[22:27] <jnthn> heh, it looks...weird :) But yes :)

[22:27] <jnthn> std: / <?[<[]> <postcircumfix> /

[22:28] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Couldn't find terminator ] at /tmp/zUvDuqCkCw line 1 (EOF):␤------> [32m/ <?[<[]> <postcircumfix> /[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 121m␤»

[22:28] <jnthn> hm

[22:28] <jnthn> too weird for STD...

[22:28] <jnthn> Which probably means nqp's parser is being a bit too liberal.

[22:36] <jnthn> Time for some rest &

[22:39] *** replore_ left
[22:41] *** envi_ joined
[22:43] *** wolfman2000 joined
[22:51] <TimToady> perl6: ({ say "hi"})

[22:51] <p6eval> rakudo 158bd0, niecza v10-66-g71325b0:  ( no output )

[22:51] <p6eval> ..pugs b927740: OUTPUT«hi␤»

[22:51] <TimToady> ({ * + * }) ought to work, since {} should be bare brackets

[22:53] *** jlaire left
[23:09] <sjohnson> TimToady:  that sorta looks like a emoticon of someone with starry eyes kissing

[23:13] <donri> or an owl

[23:14] *** jlaire joined
[23:15] *** jlaire left
[23:16] *** jlaire joined
[23:20] <sorear> good * #perl6

[23:25] <nornagest> Good night.

[23:25] *** nornagest left
[23:27] *** aindilis left
[23:28] *** MayDaniel left
[23:29] *** aindilis joined
[23:30] <dalek> niecza/serialize: 05b5bb6 | sorear++ | / (2 files):

[23:30] <dalek> niecza/serialize: Fix crashes when trying to compile CORE:: name references

[23:30] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/05b5bb64c7

[23:31] *** Chillance left
[23:35] *** thou left
[23:37] *** envi_ left
[23:38] <dalek> niecza/serialize: 878afab | sorear++ | src/niecza:

[23:38] <dalek> niecza/serialize: Fix compile-time references to OUTER etc

[23:38] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/878afabdbb

[23:48] *** aindilis left
[23:48] *** aindilis joined
[23:52] *** thou joined
[23:59] *** japhb_ joined
