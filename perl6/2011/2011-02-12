[00:00] <pmurias> you need installed clisp with configure quicklisp

[00:00] <sorear> with -Bclisp?

[00:00] <pmurias> yes

[00:00] <sorear> what's quicklisp?

[00:04] <dalek> niecza: cf9e0a4 | sorear++ | src/ (2 files):

[00:04] <dalek> niecza: Remove some gimme5 cruft from this STD too

[00:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/cf9e0a4af0

[00:04] <sorear> rakudo: say ( 1 ).WHAT

[00:04] *** shi joined
[00:04] <pmurias> sorear: cpanm for lisp

[00:04] <p6eval> rakudo : OUTPUT«Int()␤»

[00:04] <sorear> rakudo: say ( 1, ).WHAT

[00:04] <p6eval> rakudo : OUTPUT«Parcel()␤»

[00:04] <pmurias> http://www.quicklisp.org/beta/

[00:05] <pmurias> quicklisp allows loading lisp modules with (ql:load "module") which automatically fetches from the internet/and installs that module

[00:11] <pmurias> sorear: quicklisp is required for installing the json library

[00:14] <sorear> pmurias: how helpful was the use of json?

[00:16] <sorear> pmurias: you've talked in the past about moving to a binary format

[00:16] *** awwaiid joined
[00:16] <sorear> I am considering this

[00:19] *** bluescreen left
[00:21] <pmurias> the use of json was a major annoyance

[00:21] <pmurias> i had to unpack the arrays buy hand

[00:21] <pmurias> * by

[00:24] <pmurias> hmm, sbcl seems to be faster the the mono backend on "while $a < 1000000 {$a = $a + 1}

[00:24] <pmurias> i'll investigate it tommorow

[00:24] <pmurias> s/the/then

[00:25] <pmurias> sorear: what do you want to move to?

[00:30] <pmurias> sleep&

[00:30] *** pmurias left
[00:32] *** Sarten-X left
[00:34] <TimToady> sorear: 'is unary is defequiv' is sort of the opposite of a fossil; it's more like info hung out there for the use of macros someday

[00:34] <TimToady> but it might be the wrong place to hang the info anyway

[00:34] <TimToady> they are fossils in the sense that they were put there a long time ago

[00:35] <TimToady> back before STD could even be executed

[00:35] *** bluescreen joined
[00:48] *** felliott left
[00:54] *** felliott joined
[00:55] *** lakshman joined
[00:56] <lakshman> Is there an expert in perl 6 datastructures?

[00:58] <TimToady> depends on whether you're mad about them  :)

[00:59] <lakshman> mad about them?

[00:59] <TimToady> a number of people understand S09 pretty well, but nobody's implemented it all yet

[00:59] <TimToady> I guess I don't know what you're actually asking

[01:00] <TimToady> they could use a champion, if that's what you're asking

[01:01] <TimToady> but there are a number of people who can answer questions about the design

[01:01] *** qiyong joined
[01:03] <TimToady> lakshman: do you have a more specific question?

[01:03] <lakshman> no I need to come up with specific questions i'll get back to you

[01:03] <lakshman> Thanks

[01:03] <TimToady> no problem

[01:04] *** coldhead joined
[01:14] *** Sarten-X joined
[01:21] *** lakshman left
[01:24] *** felliott_ joined
[01:24] *** felliott left
[01:25] *** felliott_ is now known as felliott

[01:27] *** shi left
[01:32] *** jaldhar_ joined
[01:34] *** icwiener left
[01:38] *** gdey left
[01:44] *** gdey joined
[01:50] <sjohnson> hmm, new vim with blowfish encryption for text files is kind of handy

[01:55] *** gdey left
[02:01] *** noganex_ joined
[02:03] *** Chillance left
[02:04] *** noganex left
[02:08] *** jaldhar_ left
[02:12] *** Sarten-X left
[02:17] *** risou joined
[02:17] *** kanishka joined
[02:18] *** Sarten-X joined
[02:19] *** risou left
[02:42] *** stkowski left
[02:45] *** bluescreen left
[02:50] *** whiteknight left
[02:52] *** justatheory left
[02:54] *** minimalist joined
[02:57] *** nadim left
[03:16] *** cdarroch left
[03:21] *** lue joined
[03:23] <sorear> phenny: tell pmurias Half the reason I picked JSON was to make life easier for people like you.  Let's discuss what you could have used later.

[03:23] <phenny> sorear: I'll pass that on when pmurias is around.

[03:24] <sorear> TimToady: ok.

[03:24] *** lakshman joined
[03:24] <sorear> wb lakshman

[03:24] *** agentzh joined
[03:24] <sorear> TimToady: I'll make niecza ignore those traits, then.

[03:25] <sorear> or maybe they could be transformed into something readable at runtime

[03:26] <lue> I'm not dead yet, zebras!

[03:29] *** jferrero left
[03:36] *** ryan__ joined
[03:46] *** dukeleto left
[03:47] *** dukeleto joined
[03:59] *** Trashlord left
[04:03] *** Trashlord joined
[04:04] *** HarryS left
[04:23] *** Su-Shee_ joined
[04:26] *** Su-Shee left
[04:27] *** BaggioKwok joined
[04:29] *** BaggioKwok left
[04:33] *** stifynsemons joined
[04:36] *** Sarten-X left
[04:37] <stifynsemons> how does one invoke a subroutine indirectly, as in &{"test"} from perl5?

[04:37] *** kanishka left
[04:38] <sorear> I guess it would be something like callframe.my.{'&test'}.()

[04:38] <sorear> sub test has to be declared 'is dynamic' for this to work

[04:38] <TimToady> well, ::("test")() ought to work

[04:38] <sorear> generally speaking Perl 6 doesn't swing that way

[04:38] <TimToady> but I doubt rakudo does that yet

[04:39] <sorear> subs are pretty hidden

[04:39] <sorear> TimToady: why not ::('&test')() ?

[04:39] <TimToady> all symbolic refs are syntactically distinguished from hard refs

[04:39] <sorear> wouldn't ::("test") be referencing a typename?

[04:39] <TimToady> yeah, probably wants the &

[04:39] <stifynsemons> Indirect name lookups not implemented yet :-(

[04:39] *** jaldhar_ joined
[04:40] <stifynsemons> thanks though

[04:40] <sorear> the Perl 6 Way doesn't use indirect name lookups very often

[04:41] <sorear> it's one of those things we support more for supporting 5->6 than actually being important

[04:41] <stifynsemons> so if I want to map a user supplied string into a function name, how would I do that the Perl 6 way?

[04:41] <sorear> is it important that the user be able to run any Perl 6 function?

[04:42] <sorear> including stuff like CORE::tan and CORE::exit?

[04:42] <stifynsemons> not any perl6 function in general; normally I add a prefix which restricts this.

[04:42] <sorear> it's better form to use an explicit hash for that sort of thing

[04:42] <stifynsemons> I could implement it I suppose as a set of anonymous subroutines stored in a hash table, I think.

[04:43] <stifynsemons> I can appreciate that.

[04:43] <sorear> they don't have to be anonymous

[04:43] <sorear> sub foo { ... }; sub bar { ... }; my %hash = :&bar, :&foo;

[04:44] <stifynsemons> oh, that's not much different that what I intended that way ... since I don't have to assign the sub definitions directly to the hash table.

[04:44] <stifynsemons> thanks

[04:44] *** Sarten-X joined
[04:45] <stifynsemons> that seems to work well

[04:46] <TimToady> pugs: sub foo { say "yup" }; ::("foo")()

[04:46] <p6eval> pugs:  ( no output )

[04:48] <TimToady> pugs: sub foo { say "yup" }; MY::{'foo'}()

[04:48] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "MY"␤    expecting ";", Doc block, block declaration, declaration, construct or expression␤    at /tmp/rFEs7rPRrg line 1, column 24␤»

[05:00] <dalek> niecza: bec0cd5 | sorear++ | lib/Builtins.cs:

[05:00] <dalek> niecza: Abstract map logic away from simple batching

[05:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bec0cd5dab

[05:12] *** minimalist left
[05:14] <sorear> rakudo: say ~(1,2 Z+ 10,20,30,40)

[05:14] <p6eval> rakudo : OUTPUT«11 22␤»

[05:14] <sorear> rakudo: say ~(1,2 Z 10,20,30,40)

[05:14] <p6eval> rakudo : OUTPUT«1 10 2 20␤»

[05:14] <sorear> TimToady: correct?

[05:18] <TimToady> yes

[05:21] *** kanishka joined
[05:47] *** ryan__ left
[05:55] *** takadonet joined
[05:55] <takadonet> yo

[05:56] *** takadonet left
[05:56] *** takadonet joined
[05:57] <takadonet> try this again...

[05:57] <sorear> hi takadonet 

[05:57] <takadonet> sorear: how are u sir?

[05:57] <sorear> I hear you do BioPerl6

[05:57] <sorear> ryan__ was looking for gsoc stuff earlier

[05:58] <takadonet> for doing work on bioperl6?

[05:59] <sorear> possibly

[05:59] <takadonet> Pyrimidine would be the man to discuss that

[06:00] <takadonet> aka https://github.com/cjfields

[06:00] <takadonet> he also the pumpkin of perl 5 version of bioperl

[06:02] <takadonet> what library (on linux) do you need so you can view previous commands enter when in the interactive mode?

[06:02] <takadonet> i always forgot

[06:03] <takadonet> forget*

[06:04] <arnsholt> readline

[06:05] *** stifynsemons left
[06:05] <takadonet> arnsholt: thx

[06:07] *** felliott left
[06:19] *** takadonet left
[06:22] *** fhelmberger joined
[06:29] *** satyavvd joined
[06:46] <sorear> TimToady: What should 1,2 Z> 1,2 Z> 1,2 do?

[06:46] *** Trashlord left
[06:47] *** woosley joined
[06:48] *** cxreg2 is now known as cxreg

[06:49] *** kanishka left
[06:52] *** Trashlord joined
[06:53] *** kanishka joined
[06:53] <TimToady> I'd think it should return (1>1>1), (2>2>2)

[06:54] <TimToady> False,False, in other words

[06:54] <sorear> I wonder if Z needs to be sensitive to precedence for that to work

[06:55] <dalek> niecza: b86e304 | sorear++ | lib/Builtins.cs:

[06:55] <dalek> niecza: Streamline flattening process for map

[06:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b86e304c0b

[06:55] <dalek> niecza: f3b81bb | sorear++ | / (5 files):

[06:55] <dalek> niecza: Implement Z, Zop, X, Xop

[06:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f3b81bb5e0

[06:56] <TimToady> Z is always a list infix in precedence, but it does need to be sensitive to chaining semantics, I expect

[06:59] * sorear -> sleep

[07:13] *** nadim joined
[07:15] *** envi joined
[07:43] <coldhead> congratulations on the looming nuptials, TimToady

[07:45] *** Mowah joined
[07:58] *** hudnix left
[07:58] *** hudnix joined
[08:07] <dalek> roast: 051af06 | moritz++ | S0 (3 files):

[08:07] <dalek> roast: some rakudo unfudges, mostly related to infix orelse

[08:07] <dalek> roast: review: https://github.com/perl6/roast/commit/051af06bdb

[08:07] <moritz_> good morning

[08:19] <tadzik> o/

[08:23] *** jaldhar_ left
[08:23] *** _jaldhar_ joined
[08:34] *** agentzh left
[08:42] *** agentzh joined
[09:00] *** kst left
[09:03] *** protorom joined
[09:04] *** wiseguyxp_ left
[09:13] *** Sarten-X left
[09:13] *** kanishka left
[09:13] *** satyavvd_ joined
[09:15] *** satyavvd left
[09:21] *** Sarten-X joined
[09:28] *** Su-Shee_ is now known as Su-Shee

[09:35] *** REPLeffect left
[09:37] *** REPLeffect joined
[09:44] *** lue left
[09:44] *** lue joined
[09:46] *** woosley1 joined
[09:47] *** woosley left
[09:47] *** cjk101011 joined
[09:52] *** Chillance joined
[10:01] *** satyavvd_ left
[10:02] *** woosley1 left
[10:22] *** _jaldhar_ left
[10:22] *** _jaldhar_ joined
[10:23] *** peters_mops left
[10:29] *** _jaldhar_ left
[10:29] *** _jaldhar_ joined
[10:35] <moritz_> rakudo: say 1 !+ 3

[10:35] <p6eval> rakudo : OUTPUT«===SORRY!===␤Can't negate + because it is not iffy enough at line 22, near " 3"␤»

[10:44] *** coldhead left
[10:49] <dalek> rakudo: f4ec358 | moritz++ | docs/ChangeLog:

[10:49] <dalek> rakudo: [docs] update ChangeLog

[10:49] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/f4ec358412

[10:59] *** Sarten-X left
[11:01] *** pmurias joined
[11:07] *** Sarten-X joined
[11:15] *** whiteknight joined
[11:35] *** colbseton joined
[11:39] *** colbseton left
[11:42] *** Trashlord left
[11:52] *** masak joined
[11:52] <masak> привет, zebras.

[11:54] *** agentzh left
[12:01] *** MayDaniel joined
[12:03] * masak has been wrapping his head around the SOLID principles lately

[12:04] <masak> they're mostly what I expected them to be, except the Open/closed principle, which didn't make any sense whatsoever until it suddenly did.

[12:08] <masak> it's also interesting/valuable to discover places in well-designed libraries where these principles are broken, sometimes deliberately as a tradeoff.

[12:09] *** shi joined
[12:27] *** MayDaniel left
[12:33] *** colbseton joined
[12:51] *** BinGOs left
[12:53] *** pmurias left
[12:53] *** edenc left
[12:53] *** perigrin left
[12:53] *** perigrin joined
[12:54] *** edenc joined
[12:55] *** BinGOs joined
[12:57] <masak> if C is a class fairly far down in an inheritance hierarchy, and it has an (overridden) method .foo, will the PRE blocks in the .foo methods of C's base class(es) also trigger when C.foo is called?

[12:57] <masak> is the answer different if .foo is a multi method?

[12:57] <masak> &

[13:02] <jnthn> Sleep. I got it. \o/

[13:02] *** Trashlord joined
[13:12] *** felliott joined
[13:17] *** orafu left
[13:19] *** _jaldhar_ left
[13:19] *** _jaldhar_ joined
[13:21] *** protorom left
[13:25] *** drbean left
[13:35] <moritz_> congratulations jnthn. I'm jealous :-)

[13:35] <jnthn> moritz_: Aww. Sorry.

[13:35] <jnthn> hugme: hug moritz_ 

[13:35] * hugme hugs moritz_

[13:49] *** MayDaniel joined
[14:05] * colomon remembers rocking a very small baby at 2am, reading a Gene Wolfe paperback in a strange sleepless haze.

[14:06] <colomon> Now-a-days, however... well, last night I was rocking a much larger toddler, and reading Lois McMaster Bujold on my Droid.

[14:08] *** kanishka joined
[14:16] *** hudnix left
[14:20] <jnthn> ooh, bacek++ has added the write barriers to nqp \o/

[14:22] <moritz_> and the parrot folks have temporarily unmerged the gen_gc branch

[14:22] <jnthn> oh.

[14:22] <moritz_> because it had troubles to build on some platforms

[14:22] <jnthn> Aww.

[14:22] <jnthn> OK.

[14:23] <colomon> write barriers?

[14:25] <moritz_> and performance regressions in register access

[14:28] *** vmspb joined
[14:30] *** satyavvd joined
[14:31] <jnthn> colomon: Triggers some GC action when an object is written to and before some allocation happens.

[14:31] <jnthn> s/allocatin/something that may trigger a GC run/

[14:36] *** satyavvd left
[14:37] <masak> a write barrier is a GC trigger?

[14:37] <masak> gee, sounded more like it would be some sort of barrier against writing... :)

[14:38] <jnthn> masak: It's not a trigger as such

[14:38] <jnthn> masak: It's more to do with generation management, so the next run doesn't eat stuff it shouldn't.

[14:38] <masak> ah, ok.

[14:38] <jnthn> masak: If an object in one generation comes to point to things in other generations, that needs some special handling on the next GC run.

[14:38] <jnthn> iiuc, anyway ;)

[14:39] <masak> it has a ring of truthiness to it...

[14:39] <masak> now, what about my PRE/POST question above?

[14:40] <masak> what's the relation between a method in a derived class, its (top-level) PRE/POST blocks, and methods in more base classes and their (top-level) PRE/POST blocks.

[14:40] <masak> s/\./?/

[14:40] <jnthn> masak: AFAIK none at the moment. (more)

[14:41] *** xinming_ left
[14:42] <jnthn> masak: I'm not sure we should go in the direction of enforcing that they're always run up/down the hierarchy. It may be very Liskov-ish, but we aren't so Liskov-ish to always give the methods in a parent class a chance to run either.

[14:42] *** xinming joined
[14:42] <jnthn> Further, if the invariants relate to arguments passed to the method, how does a PRE/POST block in a method in a parent class make sense if it's never invoked?

[14:42] <masak> yes, that's what I'm fishing for.

[14:43] <masak> but S04:1459 says "call all the appropriate per-method C<PRE> phasers", which makes it sound like there's a chain of PRE phasers.

[14:43] <jnthn> Oh. :/

[14:43] <jnthn> I'm not sure that makes sense - or is practical.

[14:43] <masak> there might be, even for one method, of course, but there's no real need to divide things into several PRE phasers.

[14:43] <masak> no, I don't think it ultimately does make sense.

[14:43] <jnthn> Right.

[14:44] <jnthn> My feeling is that we'll have the meta-programming capabilities to let people who want Beta-style OO where you always call the least derived method and it chooses how to delegate to more derived ones.

[14:44] <masak> just consider .foo($a) in Parent and .foo($b, $c) in Child -- how would PRE be able to run in Parent if Child.foo was called?

[14:44] <jnthn> s/who want/implement/

[14:44] <masak> jnthn: that sounds a little like proto methods.

[14:45] <jnthn> Well, not quite. A bit broader: it sounds like dispatchers.

[14:45] <moritz_> I think only PRE phasers from the candidate list should be considered

[14:45] <moritz_> ie those that could be reached with nextsame()

[14:45] <masak> that makes a bit more sense.

[14:46] <jnthn> Apart from instead of the list you're iterating over being most to least derived, it's the other way.

[14:46] <masak> *nod*

[14:46] <jnthn> moritz_: Doing nextsame() into a method (note, *not* multi - that's different) can fail.

[14:47] <jnthn> e.g. if I have a method m($a) { } in a parent class and a method m($a, $b) { nextsame() } in its child, that *will* fail.

[14:47] <jnthn> For multis though, you'd not get that situation.

[14:47] <jnthn> Of course, hopefully people will pay attention to Liskov and never put themselves into such a situation. :)

[14:48] * masak feels he has not completely encompassed the problem space yet

[14:48] <jnthn> I don't particularly want to make method single-dispatch more complex for the sake of encouraging people to do bad OO.

[14:48] <masak> it makes a lot of sense that people who dabble with PRE/POST would be Liskov-aware.

[14:48] <moritz_> what about class A { method x($y) { my $k = $y ** 2; PRE { $k <= 10 } }} ; class B is A { method x($y) { ... } }

[14:49] <moritz_> does it have to run the parent method up to the point where PRE can be evaluated?

[14:49] <masak> moritz_: uhm.

[14:49] <masak> moritz_: PRE blocks are run before the method body.

[14:49] <masak> says so in S04.

[14:49] <jnthn> masak: That's only half the truth.

[14:49] <masak> that's why they're called PRE :)

[14:49] <jnthn> masak: The method callframe surely needs to exist.

[14:49] <jnthn> But before the "main" body, yes.

[14:49] <masak> that's what i meant :)

[14:49] <jnthn> OK :)

[14:50] <jnthn> That PRE would work albeit with a warning, I guess. :)

[14:50] <jnthn> rakudo: say Any <= 10

[14:50] <p6eval> rakudo : OUTPUT«Use of uninitialized value in numeric context  in <anon> at line 22:/tmp/vQPJ_UVjZ_␤Bool::True␤»

[14:50] <jnthn> :)

[14:50] *** risou joined
[14:51] <jnthn> I guess the rule is "PRE should only care about attributes and arguments"

[14:53] <masak> PRE runs after INIT, but before ENTER. so there's no really good way to assign to $k each time.

[14:54] <masak> but the assignment might as well be done inside the PRE block (the declaration still being before/outside it). problem solved.

[14:54] <moritz_> INIT my $x = $y * $y;

[14:55] <jnthn> Don't that run, like, one, ever? :)

[14:55] <masak> yes.

[14:55] <jnthn> *Won't

[14:55] <jnthn> *once

[14:55] <jnthn> ...can't type. :)

[14:55] <masak> so it doesn't quite cut it.

[14:57] *** risou left
[14:58] *** kanishka1 joined
[14:58] *** kanishka1 left
[14:59] *** kanishka1 joined
[15:00] *** kanishka left
[15:12] <masak> hm, if I implement ENTER blocks in Yapsi, it'll be easier to do named subs...

[15:13] <moritz_> why is that?

[15:16] <masak> because I plan (at least initially) to let 'sub foo { ... }' be sugar for 'my &foo;', 'ENTER { &foo := { ... } }'

[15:17] *** icwiener joined
[15:17] <masak> yapsi: say 42

[15:17] <p6eval> yapsi: OUTPUT«===SORRY!===␤Unable to find module 'Yapsi' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval/p1/lib/parrot/3.0.0-devel/languages/perl6/lib␤  .)␤»

[15:25] <moritz_> so... a sub doesn't have a body until it's called?

[15:25] * moritz_ confused

[15:25] <moritz_> oh wait, ENTER from the outer scope

[15:25] <masak> aye.

[15:26] <masak> maybe there's a "Liskov dialect" or Perl 6, accessible through a pragma, wherein DBC is possible, and methods are required to override with the same signature. that would make PRE/POST blocks along the inheritance chain much more feasible.

[15:27] <jnthn> masak: lisklass Foo { ... } # :-)

[15:27] <masak> but they're slightly odd creatures. if there's a parameter $x, and the PRE block of Parent.foo mentions $x, we expect it to bind to the $x of Child.foo when it is called.

[15:27] <jnthn> Eww. :)

[15:27] <masak> very anti-lexical of them.

[15:28] <moritz_> I think we need to signature-bind to all the parent methods where PRE blocks are run

[15:29] <masak> yes, probably. that would solve that.

[15:29] <jnthn> phenny: tell pmichaud when you get chance, please take a look over https://github.com/rakudo/rakudo/blob/nom/NOMMAP.markdown - it's my work plan for the nom branch. kplzthx

[15:29] <phenny> jnthn: I'll pass that on when pmichaud is around.

[15:30] <masak> markdown \o/

[15:30] <jnthn> ETOOLAZYTOPOD :)

[15:31] <masak> well, Github highlights both, IIRC.

[15:31] <jnthn> Right. :)

[15:31] *** hudnix joined
[15:31] <jnthn> But the difference between what I have to type to hae a text file and a markdown file is...tiny. :)

[15:31] <jnthn> So there's kinda no reason not to do it. 

[15:32] *** stifynsemons joined
[15:34] *** stifynsemons left
[15:36] *** Sarten-X left
[15:44] *** Sarten-X joined
[15:46] <masak> right. it's Structure for Free.

[15:49] <dalek> nqp: c8ce669 | jnthn++ | src/pmc/nqpmultisig.pmc:

[15:49] <dalek> nqp: Fix a mark bug that saw some people get segfaults in multi-method dispatch situations.

[15:49] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c8ce669583

[15:52] <masak> I have a heisentest here: a Perl 6 program that Yapsi should run but happily runs on the command line. when I copy+paste it as a test, Yapsi refuses to compile it (as it should).

[15:52] *** dukeleto left
[15:53] <masak> I find myself wanting a test to fail. :)

[15:53] *** dukeleto joined
[15:53] <moritz_> is there a "not" missing in your previous statement?

[15:53] <moritz_> "should run but happily runs"

[15:53] <masak> right. "that Yapsi shoudn't compile"

[15:54] <masak> fwiw, the program is 'my $a = 1; { say $a; my $a = 2; say $a }'

[15:54] <masak> std: my $a = 1; { say $a; my $a = 2; say $a }

[15:54] <p6eval> std 625303c: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol '$a' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::<$a>␤  before you can unambiguously declare a new '$a' in this scope at /tmp/7qHlmTzxbR line 1:␤------> [32mmy

[15:54] <p6eval> ..$a…

[15:55] *** Sarten-X left
[15:56] <jnthn> I can't remember who reported the nqp multi dispatch test segfault, but the patch I just commited above should fix it.

[15:58] <jnthn> walk &

[16:00] <dalek> nqp: 5ed3fad | jnthn++ | src/metamodel/reprs/P6str.c:

[16:00] <dalek> nqp: Fix an issue in the P6str repr spotted by sorear++.

[16:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5ed3fad3b7

[16:03] *** Sarten-X joined
[16:04] *** Sarten-X left
[16:05] *** vmspb left
[16:11] <masak> ah. the heisentest turned out to be due to state bleedover between runs.

[16:11] <masak> testers take note: a test showing that something fails isn't much worth on its own, since there are so many orthogonal ways something can fail. :)

[16:12] <arnsholt> Indeed. State behaving in funny ways makes for interesting debugging of tests

[16:13] <masak> I have a few globals in Yapsi. one of them is the culprit here.

[16:13] <arnsholt> I've had some fun (fsv. of fun) debugging backtracking shenanigans in Parrotlog =)

[16:13] *** wooden left
[16:15] *** qiyong left
[16:15] *** Patterner left
[16:16] *** cognominal left
[16:17] *** Psyche^ joined
[16:17] *** Psyche^ is now known as Patterner

[16:17] *** ryan_ joined
[16:18] <masak> yay! changed the global into a private attribute on the ::Actions class, and that brought out the failing test! \o/

[16:19] <masak> if that isn't a victory for narrow scopes, I don't know what is.

[16:19] *** HarryS joined
[16:21] <arnsholt> Absolutely

[16:23] *** Sarten-X joined
[16:34] <jnthn> back :)

[16:35] *** stifynsemons joined
[16:36] *** whiteknight left
[16:37] *** cognominal joined
[16:39] *** stifynsemons left
[16:52] *** plobsing left
[16:52] *** stifynsemons joined
[16:56] *** stifynsemons left
[17:14] *** plobsing joined
[17:15] <dalek> yapsi: 639e391 | masak++ | lib/Yapsi.pm:

[17:15] <dalek> yapsi: [Yapsi] narrowed the scope of %vars

[17:15] <dalek> yapsi: 

[17:15] <dalek> yapsi: Instead of a lexical inside ::Actions, it is now a private attribute.

[17:15] <dalek> yapsi: This makes a lot more sense, because the variable should be reset with

[17:15] <dalek> yapsi: each new parse anyway.

[17:15] <dalek> yapsi: review: https://github.com/masak/yapsi/commit/639e391f7e

[17:17] <masak> std: unless a {}

[17:17] <p6eval> std 625303c: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'a' needs parens to avoid gobbling block at /tmp/XQXOz5gt1Q line 1:␤------> [32munless a[33m⏏[31m {}[0m␤Missing block (apparently gobbled by 'a') at /tmp/XQXOz5gt1Q line 1:␤------> [32munless a {}[33m⏏[31m<EOL>[0m␤    expecting any

[17:17] <p6eval> ..of…

[17:30] <sorear> good * #perl6

[17:32] <masak> sorear! \o/

[17:32] <diakopter> * * *

[17:32] <jnthn> It's not * here

[17:32] <jnthn> oh, wait..

[17:32] <masak> { $_ * $_ }

[17:32] <jnthn> :)

[17:32] <diakopter> std: * * *

[17:32] <masak> oh wait, { $^a * $^b }

[17:32] <p6eval> std 625303c: OUTPUT«ok 00:01 119m␤»

[17:32] <masak> { $_ * $_ } was the old sugaring...

[17:33] <masak> *desugaring

[17:38] *** dual left
[17:38] <masak> std: my @a = 1, => 2

[17:38] <p6eval> std 625303c: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix => instead at /tmp/atbVfl3TGD line 1:␤------> [32mmy @a = 1, [33m⏏[31m=> 2[0m␤Parse failed␤FAILED 00:01 122m␤»

[17:38] <masak> rakudo: my @a = 1, => 2

[17:38] <p6eval> rakudo : OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Undef'␤»

[17:38] * masak submits LTA rakudobug

[17:42] <dalek> yapsi: b62dada | masak++ | t/compiler.t:

[17:42] <dalek> yapsi: [t] two new tests

[17:42] <dalek> yapsi: 

[17:42] <dalek> yapsi: One fails.

[17:42] <dalek> yapsi: review: https://github.com/masak/yapsi/commit/b62dada857

[17:42] <dalek> yapsi: 97dea43 | masak++ | t/compiler.t:

[17:42] <dalek> yapsi: [t/compiler.t] checked error message on failure

[17:42] <dalek> yapsi: 

[17:42] <dalek> yapsi: Just knowing that something fails isn't very informative. It turns out

[17:42] <dalek> yapsi: we were sometimes failing for the wrong reasons. This commit is more

[17:42] <dalek> yapsi: discerning about the actual failure.

[17:42] <dalek> yapsi: review: https://github.com/masak/yapsi/commit/97dea43f1e

[17:44] *** dual joined
[17:45] *** MayDaniel left
[17:51] *** justatheory joined
[17:54] *** MayDaniel joined
[17:56] *** kanishka1 left
[17:56] *** kanishka joined
[17:59] <TimToady> is anyone here currently using rakudo on Mac?  What's the best way to install?

[17:59] *** MayDaniel left
[18:00] <jnthn> TimToady: I think layla++ asked that recently...I *think* the answer was that there wasn't any packages around, so best was just to build it from source.

[18:02] * jnthn is failing ot use the ir clog search...

[18:04] <TimToady> thanks, we'll do that

[18:04] <jnthn> TimToady: http://irclog.perlgeek.de/perl6/2011-02-01#i_3242639

[18:13] <masak> yes, build from source.

[18:14] *** kaare_ joined
[18:14] <masak> Mac OS X is basically BSD with pretty graphics. ;)

[18:20] <tadzik> isn't that Darwin?

[18:24] <arnsholt> Darwin and BSD userspace, IIRC

[18:25] <arnsholt> And I use Rakudo on OS X. I build from source

[18:25] *** kanishka left
[18:28] <colomon> I use Rakudo on OS X, built from source.

[18:29] <colomon> Someone was working on building package distribution recently, though.

[18:29] *** pmurias joined
[18:30] <pmurias> sorear: hi

[18:30] <phenny> pmurias: 03:23Z <sorear> tell pmurias Half the reason I picked JSON was to make life easier for people like you.  Let's discuss what you could have used later.

[18:44] *** kaini joined
[18:45] *** kaini left
[18:50] *** kaini joined
[18:56] *** jvv joined
[19:00] <sorear> pmurias: hi

[19:11] <lue> good morning zebras! o/

[19:13] <tadzik> hey lue!

[19:13] <masak> lue \o

[19:14] <sorear> hi lue

[19:23] * lue is so close to beating TeX and friends with several forms of aquatic life.

[19:24] <tadzik> ...why can we have 61 seconds?

[19:25] <lue> I think I asked before, and I believe it has to do with leap seconds.

[19:25] <tadzik> http://perlcabal.org/syn/S32/Temporal.html#line_72

[19:25] *** wiseguyxp_ joined
[19:26] <sorear> tadzik: leap seconds are added to the end of existing minutes

[19:26] <sorear> tadzik: the Earth rotates on its axis once every 86400.xxxxx seconds

[19:26] <tadzik> I see

[19:26] <sorear> we divide the sidereal day into 24 hours with 60 minutes each

[19:27] <TimToady> they should just put some big weights in some towers so they can adjust the rotation rate to match the atomic clock

[19:27] <sorear> most minutes have 60 seconds, but to keep UT1 synchronized with the Sun we add 1 second to a minute occasionally

[19:28] <sorear> erm, the solar day

[19:28] <sorear> the sidereal day only has 1436 minutes...

[19:28] <lue> TimToady: or giant rockets.

[19:28] <TimToady> or more likely (meaning not likely at all) pump a great amount of water to/from reservoirs on the equator

[19:29] <sorear> because the Earth rotates on its axis every 1436 minutes, but the Earth is also revolving around the Sun

[19:29] <TimToady> we should do something about the year length too

[19:29] <sorear> every 366 rotations of the Earth, we see the Sun rise 365 times because 1 of them was cancelled out by yearly motion

[19:30] <TimToady> you can get it back by traveling around the world in the right direction

[19:30] <sorear> I wonder if we could cancel out global warming by cleverly manipulating the Milankovitch cycles

[19:33] <lue> .oO(Or perhaps open a hole in the atmosphere that's always on the Dark Side™ of the Earth, to let all the heat out)

[19:33] <pmurias> re what to replace json with something with a structure and existing implementations would be preferable

[19:34] <pmurias> sorear: why do you want to replace json? (in what ways does the replacement have to be better)

[19:34] <sorear> pmurias: you said json made your work harder

[19:34] <sorear> the main reason I picked json was to make implementing backends (readers in genral) *easier*

[19:34] <sorear> so obviously something is very wrong

[19:35] <pmurias> common lisp doesn't have pattern matching

[19:35] *** shi left
[19:35] <pmurias> so unpacking arrays had to be worked around

[19:36] <sorear> what could you have dealt with easier?

[19:38] *** envi left
[19:40] <pmurias> i'm not sure i don't have much experience with different serialisation formats

[19:41] <pmurias> in the end i just converted json into sexpressions and copied out parts of docs/nam.pod

[19:48] *** molaf joined
[19:50] <masak> I should probably attack serialization soon in Yapsi. I'm getting to the point where I need static lexpads and BEGIN to work.

[19:51] *** cjk101011 left
[20:04] <dalek> niecza: 311ba52 | sorear++ | / (2 files):

[20:04] <dalek> niecza: Reorganize and combine TODO lists

[20:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/311ba524a7

[20:04] *** rgrau joined
[20:08] *** felliott left
[20:10] *** Tedd1 left
[20:10] *** wiseguyxp_ left
[20:19] *** stifynsemons joined
[20:24] *** felliott joined
[20:28] *** felliott left
[20:29] *** stifynsemons left
[20:36] <masak> that's a nice read. EASY, MEDIUM, HARD, NASTY.

[20:37] <masak> I'm surprised to see &eval and BEGIN both fall under NASTY.

[20:37] <tadzik> I like how this looks like „that's easy. Do it”

[20:37] *** zby_home_ joined
[20:38] <sorear> masak: NASTY means basically "I don't understand this well enough to even start"

[20:39] <sorear> the other three are mostly broken down by time required

[20:39] <sorear> EASYs will take me less than an hour if I'm in a proper flow state

[20:39] <moritz_> masak: I guess both BEGIN and eval carry context between run- and compile time

[20:39] <moritz_> which makes it hard

[20:39] <sorear> exactly

[20:40] * jnthn considers BEGIN decidedly hard and scary

[20:40] <sorear> eval is probably the easier of the two, since it doesn't depend on the immediate metamodel and doesn't require general serialization

[20:41] *** stifynsemons joined
[20:41] *** colbseton left
[20:42] <jnthn> sorear: I don't consider eval at all easy, but I think it's a lot less hassle to do right than BEGIN is.

[20:44] <moritz_> an approximation of eval is much better than nothing.

[20:44] <jnthn> True. Rakudo had an eval that couldn't see outer lexicals for many months.

[20:44] <moritz_> and it was enough to pass quite some spectests

[20:45] <jnthn> Right.

[20:46] <sorear> I could do *that* right now

[20:47] * sorear adds to agenda

[20:47] <moritz_> sorear: that would be enough for eval_{lives,dies}_ok

[20:48] <moritz_> which evalutes in context of Test.pm anyway, not in the context of the test file

[20:53] <moritz_> sorear: another TODO: MAIN subs

[20:54] <moritz_> niecza: say %*ENV<PATH>

[20:54] <masak> moritz_, sorear: thanks for explanations about why BEGIN and &eval are nasty. what you say matches what I've been thinking about them so far for Yapsi.

[20:54] <p6eval> niecza v2-42-g311ba52: OUTPUT«␤»

[20:55] <moritz_> perl6: print %*ENV<PATH>

[20:55] <p6eval> niecza v2-42-g311ba52:  ( no output )

[20:55] <p6eval> ..rakudo : OUTPUT«/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games»

[20:55] <p6eval> ..pugs: OUTPUT«*** Can't modify constant item: VUndef␤    at /tmp/q2nhWB6tGn line 1, column 7 - line 2, column 1␤       /tmp/q2nhWB6tGn line 1, column 7 - line 2, column 1␤»

[20:55] <moritz_> another TODO

[20:56] <masak> ...already in there.

[20:56] <moritz_> in the issue tracker?

[21:00] <moritz_> sorear: I want run() ... and preferably not in SAFE.setting, but in a FULL.setting or so :-)

[21:04] <sorear> right.  FULL is spelled CORE for now

[21:04] <sorear> I'm not 100% happy with this factoring

[21:05] <sorear> niecza: say ?(slurp "/etc/passwd")

[21:06] <p6eval> niecza v2-42-g311ba52: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'slurp' used at line Any()1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/SAFE.setting line 377 (SAFE die @ 2)␤  at /home/p6eval/niecza/src/STD.pm6 line 1148 (STD P6.comp_unit @ 73)␤  at

[21:06] <p6eval> ../home/p6eval/niecz…

[21:06] <sorear> goodie, p6eval is using it

[21:06] <stifynsemons> Another newbie question: my %g; %g<gamma>.[].push(5) doesn't auto-vivify hash element gamma. So I have to use my %g; %g<gamma>=[]; %g<gamma>.[].push(5). Is there a simpler syntax?

[21:07] <moritz_> sorear: so how do I run neicza with CORE instead SAFE

[21:07] <sorear> moritz_: don't pass --safe to the executable

[21:07] <sorear> stifynsemons: I suspect push %g<gamma>, 5 should work

[21:08] <sorear> stifynsemons: generally you shouldn't use .[].; that overload exists for the sake of string interpolation

[21:08] <moritz_> what's wrong with .[] ?

[21:09] <stifynsemons> push %g<gamma>, 5 doesn't work in 201101 rakudo star

[21:09] <sorear> moritz_: it's a no-op, except when it's not

[21:10] <sorear> (%g<gamma> //= []).push(5) will definitely work

[21:10] <masak> rakudo: my %g; push $g<gamme>, 5; say %g.perl

[21:10] <sorear> but is rather on the ugly side

[21:10] <p6eval> rakudo : OUTPUT«===SORRY!===␤Symbol '$g' not predeclared in <anonymous> (/tmp/yn4U_mE8fT:22)␤»

[21:10] <masak> rakudo: my %g; push %g<gamme>, 5; say %g.perl

[21:10] <p6eval> rakudo : OUTPUT«Method '!fill' not found for invocant of class ''␤  in 'List::push' at line 2881:CORE.setting␤  in main program body at line 22:/tmp/l0BsSJw77w␤»

[21:10] <moritz_> I'm pretty sure both the sub and method form should work

[21:10] * masak is surprised the spectests wouldn't pick something like that up.

[21:11] * masak submits rakudobug

[21:11] <masak> stifynsemons++

[21:11] <moritz_> masak: there are tests for that. They are just fudged :-)

[21:11] <stifynsemons> thanks

[21:11] <stifynsemons> ok, for now, I'll just %<gamma>.[].push(5) for now :-)

[21:11] <masak> moritz_: right, but ISTR this *used* to work. have they been fudged recently?

[21:12] <masak> stifynsemons: leave comments with the RT ticket number in; that way, you'll remember to improve the code when the bug is fixed.

[21:12] <sorear> in my family, "fudge" is considered a low-tier swear word.  Makes reading about spectests a little amusing. :)

[21:12] <moritz_> rakudo: my %h; %h<a>[0] = 3; say %h.perl

[21:12] <p6eval> rakudo : OUTPUT«{"a" => [3]}␤»

[21:12] <moritz_> masak: I remember *that* working

[21:13] <moritz_> I didn't fudge any autoviv tests lately

[21:14] <moritz_> alpha: my %a; push %a<b>, 3; say %a.perl

[21:14] <p6eval> alpha : OUTPUT«No applicable candidates found to dispatch to for 'push'␤in Main (file <unknown>, line <unknown>)␤»

[21:15] * moritz_ -> sleep

[21:15] <masak> 'night, moritz_. dream of excellent autovivification.

[21:19] <lue> I am beginning the beating process on XeLaTeX, albeit only in my head :) . afk.

[21:21] <sorear> TimToady: ping.

[21:22] <sorear> TimToady: suppose I have a given statement with 256 whens, each labelled when 0, when 1, ... when 255; obviously this should be a jump table

[21:22] <sorear> TimToady: suppose further that the 63 case ends with $_ = 195; proceed;

[21:22] <sorear> TimToady: what should happen?  does it make sense to use the jump table here?  how?

[21:22] <sorear> TimToady: what if it were $_ = 16; proceed; ?

[21:23] <masak> interested question: is there a nice Perl or Unix tool that would allow me to start two processes and have the output of one fed as input to the other? I'm asking for p4.

[21:23] <sorear> masak: man 1 sh

[21:23] <sorear> sh -c 'program1 | program2'

[21:24] <masak> ok, I was unclear.

[21:24] <masak> they reciprocally feed input to each other.

[21:24] <masak> they are "talking" to each other.

[21:24] <masak> I might need to do some minimal processing in the middle, too. at least to get things started.

[21:24] <sorear> you're asking for deadlocks if you do that because of buffering semantics

[21:25] <masak> yes, I gathered as much from reading 'perldoc -f pipe'.

[21:25] <sorear> there is an easyish way though

[21:25] <masak> I don't need it to be fast, just reliable.

[21:26] <masak> best idea I have so far is to re-run things lots of time, each time a little further.

[21:26] <masak> that's risky if there's randomness involved, which there might be.

[21:26] <sorear> mkfifo $TMP; <$TMP a | b >$TMP

[21:28] *** dukeleto left
[21:28] *** dukeleto joined
[21:28] <masak> hm...

[21:30] <masak> with additional piping, that might fly.

[21:30] <masak> sorear++

[21:42] *** y3llow_ joined
[21:42] *** pothos_ joined
[21:42] *** plobsing left
[21:43] *** y3llow left
[21:44] *** y3llow_ is now known as y3llow

[21:44] *** pothos left
[21:44] *** pothos_ is now known as pothos

[21:59] <stifynsemons> I noticed that there is implicit whitespace in a grammar like: grammar E { rule TOP { ^[ <a> <b> ]$}    token a { a } token b { b}  }

[21:59] <stifynsemons> so that E.parse("a b") matches but E.parse("ab") doesn't.

[22:00] <sorear> that's because you used "rule"

[22:00] <stifynsemons> is this the way it is supposed to be? I couldn't tell from the synopsis.

[22:00] <sorear> if you had used token TOP, there'd be no issue

[22:00] <stifynsemons> so if a rule includes a token, it puts space between them?

[22:01] <sorear> it's even simpler than that

[22:01] <sorear> every " " in a rule becomes <.ws>

[22:01] <stifynsemons> oh, that is simple

[22:01] <masak> and <.ws> *requires* whitespace between \w things.

[22:01] <stifynsemons> that's even what I want :-)

[22:02] <masak> ...due to the way we most often want identifiers to work in languages.

[22:02] <stifynsemons> I assume that multiple spaces maps to a single <.ws> as well

[22:03] <masak> yes.

[22:10] *** coldhead joined
[22:10] *** plobsing joined
[22:11] *** HaraldJoerg joined
[22:12] <sorear> well, it does, but that's just an optimization

[22:12] <sorear> <.ws> is defined such that <.ws><.ws> === <.ws>

[22:12] <sorear> don't try <.ws>+ though; that will hang

[22:20] *** aindilis left
[22:25] <masak> trying to pipe two p4 algorithms together is the most confusing thing I've attempted in a long, long time.

[22:28] <diakopter> <.ws>+ should probably be fixed not to hang..

[22:28] <masak> +1

[22:28] <sorear> -1

[22:29] *** plobsing left
[22:29] <masak> *all* quantified empty things should be fixed not to hang.

[22:29] <masak> that's what Perl 5 does.

[22:29] <diakopter> how about a warning then

[22:29] <sorear> deliberately introducing inconsistencies into a programming language to make one edge case nicer is never a good idea

[22:30] <sorear> masak: ?

[22:30] <masak> <.ws>+ is a special case of [<something-that-matches-empty-string>]+

[22:30] <sorear> if you can make this sound consistant, I'll support t

[22:30] <sorear> mm

[22:30] <masak> it's just good customer service not to hang in that case.

[22:30] <masak> it can be easily detected, and it's never what the user wants.

[22:32] <sorear> given "" ~~ /<ws>+/; what is +$<ws> ?

[22:32] <sorear> given "" ~~ /<ws>?/; what is +$<ws> ?

[22:32] <masak> in fact, a Thompson engine will *have* to address this case, since it's founded on having to progress one character with each iteration.

[22:33] <masak> and LTM, while not exactly a Thompson engine, expresses the same kinds of sentiment.

[22:35] <sorear> niecza's LTM Thompson engine does handle this case

[22:35] *** kfo joined
[22:35] <sorear> I still like the idea of doing logic programming using regexes that never match anything

[22:38] <masak> it's working! \o/ \o/ \o/

[22:38] <masak> sorear++

[22:38] <sorear> what did I do?

[22:38] <masak> I had a bit of a problem with flushing, but ++$| solved that.

[22:38] <masak> sorear: you gave the clue about a named FIFO.

[22:38] <masak> sorear: man, you should see this. the algorithms are actually playing each other.

[22:39] *** kfo_ left
[22:39] <jnthn> Wow!

[22:40] <masak> now I just need to do a harness script that does all-against-all over a range of "board" sizes. and collects statistics.

[22:41] <jnthn> That'll heat the CPU some. Good job it's winter. :-)

[22:41] <masak> :)

[22:44] <sorear> clearly, the next step is genetic algorithms.

[22:44] <sorear> with a simulated tournament for fitness ranking

[22:45] <masak> look! https://gist.github.com/824207

[22:45] <masak> sorear: it would be, if p4 wasn't a solved problem. :)

[22:47] <Tene> masak: depends on what metric you're measuring fitness by ;)

[22:48] <Tene> least cpu time used to win, perhaps?

[22:48] <masak> ooh

[22:48] <masak> still, not even that's too hard when one knows the answer.

[22:49] <masak> would be more interesting, I think, with an intractable problem.

[22:49] <Tene> Yes, rather.

[22:53] *** Trashlord left
[22:54] *** Trashlord joined
[22:56] <pmurias> masak: we can't reliably determin if a regex matches an empty string

[22:57] <masak> at runtime, we can.

[22:57] <masak> and that's what matters.

[22:57] <pmurias> in some cases we can in others not

[22:57] <masak> "am I in a quantifier? will the next iteration take me exactly nowhere? exit loop."

[22:58] <pmurias> and what do we do succed/fail?

[22:58] *** bacek left
[22:58] <masak> I don't understand the question. the quantifier succeeds.

[22:58] <pmurias> no it doesn't

[22:58] <masak> I see.

[22:59] <Tene> it... doesn't?

[22:59] *** JodaZ left
[22:59] <Tene> Why not?

[22:59] <pmurias> because it doesn't terminate

[22:59] <Tene> a* should match the empty string successfully.

[22:59] *** bacek joined
[22:59] <pmurias> (a*)* would hang

[23:00] * pmurias thinks

[23:01] <masak> exactly the (a*)* case is used as an example with the Thompson engine.

[23:01] <pmurias> (a*)* works in Perl 5

[23:01] <masak> the general situation is 'a quantifier with something that (as a default) matches the empty string).

[23:01] <masak> s/\)./'./

[23:03] *** autark joined
[23:03] *** kjeldahl left
[23:03] <pmurias> we could define the quantifers that way that they stop when the thing doesn't match anything

[23:03] <masak> I now have the harness playing every algorithm against every algorithm, for game sizes between 6 and 20. :)

[23:04] <masak> pmurias: yes, that's what I'm saying.

[23:06] <masak> 'night, #perl6.

[23:06] *** masak left
[23:08] <colomon> masak++

[23:08] <colomon> though 20 is nothing....

[23:11] *** HaraldJoerg left
[23:14] * colomon thinks his algorithm should do pretty well until about 60 or so (barring bugs that slipped through testing, of course).

[23:16] *** autark left
[23:19] *** HaraldJoerg joined
[23:24] *** plobsing joined
[23:25] *** HaraldJoerg left
[23:29] <dalek> nqp: d6338b2 | jnthn++ | src/NQP/Actions.pm:

[23:29] <dalek> nqp: Toss 'is pirflags' and add 'is vtable'. Calls method on the meta-object, though none implement it yet. Eventually this allows overriding of some Parrot v-table methods again when using 6model, which we'll need for other Parrot bits to interop with languages using 6model.

[23:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d6338b268b

[23:29] <dalek> nqp: a022547 | jnthn++ | t/nqp/52-vtable.t:

[23:29] <dalek> nqp: Update test file to use is parrot_vtable rather than is pirflags. Still doesn't pass again yet, though.

[23:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a022547b1e

[23:30] *** drbean joined
[23:31] <sorear> jnthn: how long until it will be possible to have other parrot languages using 6model objects?

[23:32] <jnthn> sorear: Well, in a sense, they already could, if they're prepared to use the new nqp already.

[23:32] *** MayDaniel joined
[23:32] <jnthn> sorear: I think the main blocker is probably documentation and examples of doing stuff other than what NQP does with it.

[23:33] <sorear> will it eventually be possible to use new objects without nqp code?

[23:33] <jnthn> Yeah.

[23:34] <jnthn> The weaving at the moment is one of developer (e.g. my ;)) convenience than need.

[23:34] <sorear> Dedenting heredocs turns out to be less trivial than I thought.

[23:35] <jnthn> You can already do everything in PIR with 6model that you can do from NQP, so any other languaes that can generate such PIR should do just fine. And since doing most things with 6model is method calls anyway...it shouldn't be so bad.

[23:35] <sorear> perl6: my $x = 1; say "$x".WHAT

[23:35] <p6eval> pugs: OUTPUT«Str␤»

[23:35] <p6eval> ..rakudo : OUTPUT«Str()␤»

[23:35] <p6eval> ..niecza v2-42-g311ba52: OUTPUT«␤»

[23:35] <sorear> niecza: my $x = 1; say "$x".typename

[23:35] <p6eval> niecza v2-42-g311ba52: OUTPUT«Num␤»

[23:36] <jnthn> o.O

[23:36] *** shi joined
[23:36] <sorear> jnthn: niecza treats "$x" as just $x

[23:36] <jnthn> Ah :)

[23:37] <sorear> wondering if maybe it... shouldn't

[23:37] <sorear> otoh, "foo" really shouldn't call &infix:<~>

[23:40] <stifynsemons> how does one delete hash keys?

[23:43] <TimToady> by spec, %hash<key>:delete, but that's not in rakudo yet

[23:43] <sorear> %hash{"key"}:delete

[23:43] <TimToady> %hash.delete('key') in rakudo

[23:43] <sorear> TimToady: is the latter spec?  does niecza need to support it?

[23:43] * jnthn knows why we have the %hash<key>:delete, but his brane still refuses to find it attractive...

[23:44] <stifynsemons> thanks

[23:47] <TimToady> sorear: no, not spec

[23:48] <jnthn> The adverb way will be the only one? :(

[23:51] <TimToady> please tell me how .delete(Str) can possibly be a degenerate case of a multidimensional list of slices

[23:51] <jnthn> Hmm. I guess I'm not arguing for keeping .delete(Str) really...I've just never really managed to like the :delete approach.

[23:52] <jnthn> Maybe it feels too end-weighty.

[23:52] <jnthn> Maybe I'll get used to it with time.

[23:52] <TimToady> delete is supposed to return the deleted elements exactly as if it were subscripted anyway

[23:52] <sorear> FWIW, niecza has a .delete-key which is used by postcircumfix:<{ }>

[23:52] <jnthn> Just one of those rare-ish cases where something in Perl 6 grates a bit. It may just be me.

[23:52] <TimToady> I don't mind internal methods

[23:53] <sorear> although it's slightly misnamed now that it accepts slices (or at least its sister at-key does)

[23:59] <sorear> TimToady: did you see my question about jumptables in the backlog?

