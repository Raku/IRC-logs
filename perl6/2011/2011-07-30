[00:01] <shinobicl> rakudo: my $D = DateTime.new(year=>2011,month=>12,day=>12);  $D.day-of-year++; say $D.perl;

[00:01] <p6eval> rakudo 922500: OUTPUT¬´DateTime.new(year => 2011, month => 12, day => 12, hour => 0, minute => 0, second => 0/1)‚ê§¬ª

[00:02] *** impious joined
[00:03] <shinobicl> rakudo: say $_ for DateTime.^methods>>.name;

[00:03] <p6eval> rakudo 922500: OUTPUT¬´new‚ê§check-time‚ê§now‚ê§clone‚ê§clone-without-validating‚ê§Instant‚ê§posix‚ê§offset‚ê§truncated-to‚ê§whole-second‚ê§in-timezone‚ê§utc‚ê§local‚ê§Date‚ê§Str‚ê§perl‚ê§is-leap-year‚ê§days-in-month‚ê§daycount-from-ymd‚ê§ymd-from-daycount‚ê§get-daycount‚ê§day-of-month‚ê§day-of-week‚ê§week‚ê§week-year‚ê§week-number‚ê§week‚Ä¶

[00:04] <shinobicl> how can i "move" a DateTime to the next (or previous) day? 

[00:06] <shinobicl> rakudo: my $D = DateTime.new(year=>2011,month=>12,day=>32); say $D.perl;

[00:06] <p6eval> rakudo 922500: OUTPUT¬´day of 2011/12 must be in 1..31‚ê§‚ê§  in 'check-value' at line 6915:src/gen/core.pm‚ê§  in 'check-date' at line 6923:src/gen/core.pm‚ê§  in 'DateTime::new' at line 7050:src/gen/core.pm‚ê§  in main program body at line 22:/tmp/BJDZcc_Eun‚ê§¬ª

[00:06] <gfldex> DateTime.Instant + 24 * 60 * 60

[00:06] <gfldex> Instant gives you seconds since unix epoc

[00:07] <gfldex> that may not work if you have leap seconds and cross the last day of the year

[00:07] <gfldex> calendars are tricky

[00:07] <shinobicl> rakudo: my $D = DateTime.new(year=>2011,month=>12,day=>12);  my DateTime $D2 = $D.Instant + (24*60*60); say $D2;

[00:07] <p6eval> rakudo 922500: OUTPUT¬´Type check failed for assignment‚ê§    Container type: DateTime‚ê§               Got: Instant‚ê§  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp‚ê§  in main program body at line 22:/tmp/9eEKX0pAHN‚ê§¬ª

[00:07] <gfldex> rakudo: my $D = DateTime.new(year=>2011,month=>12,day=>12); my DateTime $D2 = DateTime.new($D.Instant + (24*60*60)); say $D2;

[00:07] <p6eval> rakudo 922500: OUTPUT¬´2011-12-13T00:00:00Z‚ê§¬ª

[00:08] <shinobicl> so, to "move" a datetime i have to create a new one.... that's what i was trying to avoid.

[00:09] <gfldex> perl6 tries to avoid mutator methods

[00:09] <shinobicl> oh well.... is just a detail, i guess :) Thanks gfldex!

[00:09] *** risou is now known as risou_awy

[00:09] *** risou_awy is now known as risou

[00:09] <gfldex> because we have $obj.=meth

[00:10] <gfldex> sadly DateTime does not play well with .=

[00:11] <shinobicl> i'm trying to make a "Workday" class... You just have to specify a calendar file with holidays

[00:12] <shinobicl> so i want a function to move to the next workday (or any amount of workdays)

[00:13] <shinobicl> well... go back to work then :) thanks again gfldex

[00:13] <shinobicl> s/go/going/

[00:17] *** shinobicl left
[00:17] <gfldex> rakudo: my $d = now; say $d; $d.=succ; say $d;

[00:17] <p6eval> rakudo 922500: OUTPUT¬´Instant:2011-07-30T00:17:53.202019Z‚ê§Instant:2011-07-30T00:17:54.202019Z‚ê§¬ª

[00:19] <gfldex> rakudo: my $d = DateTime.new('2011-7-30'); say $d.succ;

[00:19] <p6eval> rakudo 922500: OUTPUT¬´Invalid DateTime string; please an ISO 8601 timestamp‚ê§  in 'DateTime::new' at line 7110:src/gen/core.pm‚ê§  in main program body at line 22:/tmp/FAp3XXsa5z‚ê§¬ª

[00:19] <gfldex> rakudo: my $d = DateTime.new('2011-07-30'); say $d.succ;

[00:19] <p6eval> rakudo 922500: OUTPUT¬´Invalid DateTime string; please an ISO 8601 timestamp‚ê§  in 'DateTime::new' at line 7110:src/gen/core.pm‚ê§  in main program body at line 22:/tmp/PRjwIUo1Dp‚ê§¬ª

[00:20] <gfldex> rakudo: my $d = Date.new('2011-07-30'); say $d.succ;

[00:20] <p6eval> rakudo 922500: OUTPUT¬´2011-07-31‚ê§¬ª

[00:20] <gfldex> rakudo: my $d = Date.new('2011-07-30'); $d.=succ; say $d

[00:20] <p6eval> rakudo 922500: OUTPUT¬´2011-07-31‚ê§¬ª

[00:24] <dalek> rakudo/nom: 965540e | jonathan++ | t/spectest.data:

[00:24] <dalek> rakudo/nom: Run recurse.t after fixes by pmichaud++.

[00:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/965540e451

[00:25] <dalek> roast: 3a7b996 | jonathan++ | S06-advanced_subroutine_features/recurse.t:

[00:25] <dalek> roast: Unfudge a test now Rakudo implements &?ROUTINE.

[00:25] <dalek> roast: review: https://github.com/perl6/roast/commit/3a7b99632f

[00:25] <tadzik> jnthn: yep

[00:25] <tadzik> I probably shouldn't :)

[00:30] <jnthn> tadzik: me either :)

[00:31] <jnthn> tadzik: Was pondering a bit. Thing is, not every routine will have docs...

[00:32] <jnthn> tadzik: Maybe best thing is we create an is doc('...') trait handler, which mixes in an (anonymous if you like) role with a has $.docs

[00:32] <jnthn> tadzik: Then we only make doc storage for documented things.

[00:33] <jnthn> tadzik: Then you can also use $*ST.apply_trait ... which will handle serialization stuff properly too.

[00:38] *** RandalSchwartz joined
[00:38] * RandalSchwartz waves at the channel

[00:38] <RandalSchwartz> are rakudo star questions welcome here, or is there a better channel?

[00:38] <tadzik> sounds not bad

[00:38] <tadzik> RandalSchwartz: it's a perfect place

[00:39] <RandalSchwartz> does the current or immediate future star support exceptions, and in particular, have the introspection available to support continuations?

[00:40] <sorear> I can't speak for continuations, but general exceptions absolutely

[00:40] <RandalSchwartz> separate question, but equally important - how about green threads?

[00:40] <tadzik> not at all

[00:40] <RandalSchwartz> so that's still a ways out?

[00:40] <tadzik> aye

[00:40] <sorear> it would be helpful to know your use case

[00:41] <jnthn> Current Rakudo master supports exceptions. We've some breakage in nom development branch, but will fix that for sure before it becomes master and goes into the next release.

[00:41] <RandalSchwartz> I want to know if the trickiest parts of call-cc are in there, so I can implement a seaside in Perl.

[00:41] <RandalSchwartz> Seaside from Smalltalk

[00:41] <sorear> Perl 6 has (and implemented in Star) all the primitves you need to implement green threads, except nonblocking IO

[00:41] <sorear> RandalSchwartz: lisp people tend not to distinguish between call-cc and coroutines.  Which do you need?

[00:42] <sorear> do you need to be able to "rewind" execution by invocing the same continuation more than once?

[00:42] <RandalSchwartz> i need to be able to throw an exception deep in a call stack, catch it at the top, serialize all the local stack frames, then reanimate that later

[00:42] <RandalSchwartz> yes, it needs to be repeatable

[00:43] <sorear> there is no way to make a sub return more than once in general Perl 6

[00:43] <RandalSchwartz> right - I don't need that

[00:43] <RandalSchwartz> the sub hasn't "returned" yet

[00:43] <RandalSchwartz> we're just in the exception handler

[00:43] <sorear> but you said it needs to be repeatable

[00:43] <RandalSchwartz> yes - from serializations

[00:43] <sorear> we are having a communication gap here

[00:43] <RandalSchwartz> clone the serialization, activate it into real stack frames, restart it

[00:44] <RandalSchwartz> at least, that's how Seaside does it in smalltalk

[00:44] <tadzik> jnthn: that way the subs get actually documented at runtime, when the traits are applied, right?

[00:44] <sorear> Perl 6 (in general) is probably never going to support such a messy thing

[00:44] *** drbean joined
[00:44] <RandalSchwartz> so no call-cc either?

[00:44] <RandalSchwartz> since call-cc is essentially that

[00:44] <sorear> no

[00:45] <sorear> call-cc is not the same as serializing stack frames

[00:45] <RandalSchwartz> yea - that's an implementation deal

[00:45] <RandalSchwartz> detail

[00:45] <sorear> call-cc in Perl 6 is implemented by the &take primitive, and it has nothing to do with the exception mechanism

[00:45] <sorear> (what became of 'merlyn'?)

[00:46] <RandalSchwartz> on Freenode, I've always been RandalSchwartz

[00:46] <sorear> oh.

[00:46] <RandalSchwartz> I need to research "take" I guess

[00:46] <RandalSchwartz> to figure out if it'll do what I need

[00:46] <jnthn> tadzik: trait application is BEGIN time.

[00:46] <RandalSchwartz> maybe I don't need repeatability either

[00:47] <tadzik> mebbe

[00:47] <sorear> If you need to be serializing stack frames, then you probably need to write C code.

[00:47] <RandalSchwartz> too bad Smalltalk has that beat then

[00:47] <RandalSchwartz> I was hoping Perl would be as flexible as smalltalk

[00:47] <RandalSchwartz> I guess you can't write a nice debugger in Perl either then.  not like smalltalks

[00:47] <jnthn> tadzik: Certainly. I implemented it. :P

[00:48] <jnthn> tadzik: There are other ways we could do it, but this is by far the easiest.

[00:48] <sorear> ... RandalSchwartz trolling?  */me's brain breaks*

[00:48] <RandalSchwartz> not at all

[00:48] <RandalSchwartz> I have a need

[00:49] <RandalSchwartz> Smalltalk fills it perfectly, but I was hoping to use Perl6 instead

[00:49] <sorear> smalltalk fills it perfectly *today*

[00:49] <sorear> smalltalk is also older

[00:49] <RandalSchwartz> Smalltalk could fulfill it shortly after it was developed

[00:50] <RandalSchwartz> Smalltalk started with "thisContext" in the 1980 release

[00:50] <RandalSchwartz> via "thisContext", everything I said above is possible

[00:50] <sorear> RandalSchwartz: did Smalltalk start with the ability to serialize thisContext to a string of bytes and restore it later?

[00:50] <RandalSchwartz> Yup

[00:50] <RandalSchwartz> there's nothing new in the VM to support that

[00:50] <sorear> I still think you're trolling us.  But OK.

[00:50] <RandalSchwartz> the VM could always do that, because the debugger needed to be able to get at all the stack frames

[00:50] <RandalSchwartz> have you seen the 1980 Smalltalk debugger?

[00:51] <sorear> No

[00:51] <sorear> I was born in 1990

[00:51] <RandalSchwartz> I wrote the Camel book in 1990. :)

[00:52] <sorear> Perl 6 has &callframe, which does most of what you want, except the object graph serialization stuff

[00:52] <jnthn> sorear: So far as I'm aware, everything RandalSchwartz has said about Smalltalk is true.

[00:52] <RandalSchwartz> if every object can be serialized, that's enough

[00:53] <RandalSchwartz> we can build it from theat

[00:53] <RandalSchwartz> as long as we can also restore it, including a call stack frame

[00:53] <sorear> RandalSchwartz: Rakudo Star doesn't have anything like Storable

[00:53] <RandalSchwartz> in smalltalk, those are all objects which can be reified.

[00:53] <RandalSchwartz> there's .perl and .eval, right?

[00:53] <RandalSchwartz> close enough for now

[00:53] <sorear> Perl 6 has reified stack frames too

[00:53] <sorear> rakudo: say callframe.perl

[00:53] <p6eval> rakudo 922500: OUTPUT¬´Method 'perl' not found for invocant of class 'ParrotInterpreter'‚ê§  in <anon> at line 1317:src/gen/core.pm‚ê§  in 'Any::join' at line 1:src/metamodel/RoleToInstanceApplier.nqp‚ê§  in 'Mu::attribs' at line 1318:src/gen/core.pm‚ê§  in 'Mu::perl' at line 1322:src/gen/core.p‚Ä¶

[00:54] <RandalSchwartz> ahh - that's not good :)

[00:54] <ash__> doesn't tardis do a lot of this stuff your talking about already? 

[00:54] <RandalSchwartz> is that for me?

[00:54] <jnthn> RandalSchwartz: We probably have the meta-programming capabilities to write a serializer for objects already. The callframe stuff is rather trickier.

[00:54] <RandalSchwartz> I don't know tardis.

[00:54] <sorear> jnthn: trolling, imo, is making deliberately inflammatory remarks because you like seeing people angry or defensive.  it doesn't require lying.

[00:54] <ash__> its a perl6 debugger masak++ wrote

[00:55] <RandalSchwartz> ok - looking

[00:55] <ash__> with a nice feature of being able to step forward and backwards through a program 

[00:55] <ash__> https://github.com/masak/tardis 

[00:55] <jnthn> ash__: Yes, but he also wrote his own runtime for a small subset of Perl 6, which could handle such things.

[00:55] <RandalSchwartz> ahh - time travelling.  yeah, if you can capture execution state, then rewind, that's enough

[00:55] <ash__> ah, I wasn't sure how he implemented it, i just know its a perl6 debugger :P

[00:56] <RandalSchwartz> I just want to know how to be inside 17 levels of method call, on item 7 of a 1..10 loop, and save that associated with a UUID, then restore it later so I'm still on item 7.

[00:56] <sorear> I imagine RandalSchwartz needs something a bit more featureful than masak's runtime, which is only barely powerful enough to emulate a Minsky machine.

[00:56] <jnthn> Aye.

[00:56] <RandalSchwartz> which is what Seaside essentially does

[00:57] <RandalSchwartz> I'd also accept a full-on greenthread for each invocation, and temporarily park the thread.

[00:57] <RandalSchwartz> as long as I could restart it later from a master thread

[00:57] <sorear> RandalSchwartz: more interesting question is how to save all the values of each lexical variable

[00:57] <RandalSchwartz> that's how the Perl5 "continuation" framework works, with full forks

[00:57] <sorear> RandalSchwartz: and all the classes and code fragments work.

[00:57] <RandalSchwartz> sorear - that's handled in Smalltalk. :)

[00:58] *** cschimm1 left
[00:58] <RandalSchwartz> each stack frame is an object with accessors for all lexicals and referenced objects

[00:58] <RandalSchwartz> from there, you can build a serialization of the frame

[00:58] <RandalSchwartz> and you can then store that, and fetch it later.

[00:58] <RandalSchwartz> and rebuild it from before.

[00:58] <sorear> I still feel like your goal is to demoralize us by making unflattering comparisons to 30 year old languages

[00:59] <sorear> anyway, gather/take can emulate green threads

[00:59] <RandalSchwartz> sorear - you don't know me very well then.

[00:59] <RandalSchwartz> I'm just a practical guy

[00:59] <RandalSchwartz> trying to make perl6 popular by building cool things with it

[00:59] <RandalSchwartz> and then telling the world about that

[00:59] <RandalSchwartz> and in the process, perhaps making some money for me and a bunch of other people

[00:59] <RandalSchwartz> if that's trolling, you have an odd definition. :)

[01:00] <ash__> http://perlcabal.org/syn/S04.html#The_gather_statement_prefix is gather/take 

[01:00] <RandalSchwartz> but yes, it's sad that not enough was taken from Smalltalk over the years.

[01:00] <sorear> dinner&

[01:00] *** noganex_ joined
[01:01] <tadzik> Routine:D

[01:01] <dalek> rakudo/nom: 0657b85 | jonathan++ | src/Perl6/Actions.pm:

[01:01] <dalek> rakudo/nom: Fix bug in PAST::Block arity calculation; fix bug in hash vs block detection.

[01:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0657b853a9

[01:01] <dalek> rakudo/nom: 09d8b34 | jonathan++ | t/spectest.data:

[01:01] <dalek> rakudo/nom: Run S06-other/anon-hashes-vs-blocks.t.

[01:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/09d8b34106

[01:01] <tadzik> A defined routine is a happy routine

[01:02] <jnthn> RandalSchwartz: It's nice you want to do that. If you can get gather/take to do what you want it may be viable. If not, I don't think Rakudo (and maybe Perl 6) can easily provide what you're after *yet*. I suspect part of the issue is that you either need VM co-operation, or at least to have things like stack frames be first class. That's not the situation we have today, unfortunately.

[01:03] <jnthn> At lesat, not without more work than it should be.

[01:04] *** noganex left
[01:04] <RandalSchwartz> it *is* one of the remarkable things that they said turned smalltalk 72 in 76... realizing that stack frames should be first-class.

[01:04] <RandalSchwartz> from there, the debugger could be easily written in smalltalk, and that led to "compile this code and restart in the middle" as a trivial event.

[01:05] <jnthn> Yes, it's attractive in many ways.

[01:05] <tadzik> hmm

[01:05] <tadzik> jnthn: could you peek at this? http://wklej.org/id/569556/

[01:06] <tadzik> that feels right, but how do I get around this to get what I want?

[01:06] <jnthn> tadzik: You're overcomplicating things :)

[01:06] <tadzik> am I? :)

[01:06] <jnthn> $docee does role { method WHY() { $docs } }

[01:06] <jnthn> No need to play with the MOP

[01:06] <jnthn> :)

[01:06] <tadzik> just. Ok :)

[01:07] <tadzik> trait_mod:<does> plays with the MOP, it looked so alone

[01:07] <ash__> doesn't parrot support coroutines? I know there is the CoroutinePMC 

[01:07] <ash__> I guess there is no bridge to rakudo though?

[01:07] <jnthn> ash__: gather/take are coroutine-powerful

[01:07] <ash__> oh

[01:07] <ash__> got ya

[01:07] <tadzik> jnthn: but that doesn't fix the issue :(

[01:07] <jnthn> ash__: May even be implemented using Parrot's Coroutine PMC under the hood

[01:07] <tadzik> '$docs' is still not predeclared in WHY

[01:08] <jnthn> tadzik: oh, I ran into that bug the other day

[01:08] <tadzik> gah

[01:08] <jnthn> my $d = $docs; # then use $d in the role

[01:08] <tadzik> uff

[01:08] <jnthn> tadzik: Yeah, my fault...it's on my todo list.

[01:08] <jnthn> Hopefully trivialish to fix.

[01:09] <tadzik> no problem, thanks for the workaround :)

[01:09] <jnthn> nom: sub foo($a) { my $a; }

[01:09] <p6eval> nom: OUTPUT¬´Redeclaration of symbol $a at line 1, near "; }"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[01:09] <jnthn> hm

[01:09] <jnthn> nom: sub foo($a) { my $a; BEGIN say "got here?!" }

[01:09] <p6eval> nom: OUTPUT¬´Redeclaration of symbol $a at line 1, near "; BEGIN sa"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[01:10] <jnthn> oh, hm

[01:10] <RandalSchwartz> well - I need to go do some more looking to see if there's another angle to do what I want, so thanks for the pointers.

[01:10] <RandalSchwartz> consider this also a strong request to make stack frames a first class object, at least when request.

[01:10] <RandalSchwartz> requested.

[01:11] *** soh_cah_toa joined
[01:11] <RandalSchwartz> many things become possible at that point, including very fancy edit-n-go debuggers.

[01:16] <jnthn> tadzik: ah, I found what's going on with the bug you just hit on. Wasn't what I expected it to be...

[01:16] <tadzik> jnthn: when do you need :build($true) to apply_trait?

[01:16] <jnthn> tadzik: Bit tired to fix it now, but at least I understand what's going on.

[01:17] <jnthn> tadzik: When you want to pass that to the trait mod

[01:17] <jnthn> tadzik: you want :docs($true) I guess

[01:17] <jnthn> hang on wait what

[01:17] <jnthn> :)

[01:17] <tadzik> trait_mod<will> uses build(true)

[01:17] <jnthn> multi trait_mod:<doc>(Routine:D $docee, Mu:D $docs_text, :$docs!) {

[01:18] <jnthn> You need a required named arg to indicate the trait mod do hit

[01:18] * tadzik scratches head

[01:18] <jnthn> So you'd need to call apply trait with the declarand, the doc object and :docs($true)

[01:18] <tadzik> s/do/to?

[01:18] <jnthn> yes :)

[01:18] <jnthn> That's how they're disambiguated.

[01:19] <jnthn>  multi trait_mod:<doc>

[01:19] <jnthn> shoulda been

[01:19] <tadzik> okay

[01:19] <jnthn>  multi trait_mod:<is>

[01:19] <jnthn> :)

[01:19] <tadzik> ee

[01:19] <tadzik> oh, is doc()\

[01:19] <jnthn> right :)

[01:19] <tadzik> brr

[01:19] <tadzik> okay :)

[01:20] <jnthn> .oO( is 3:20am() )

[01:20] <jnthn> Think I'll sleep a bit :)

[01:21] <tadzik> sleep? Gentleman, there's Perl 6 going on! :)

[01:21] <jnthn> That happens 24/7! :P

[01:21] <tadzik> oh shush :)

[01:22] <tadzik> oh

[01:22] *** impious left
[01:22] <tadzik> if there's .WHY maybe the trait_mod should be 'because'

[01:22] <tadzik> sub foo because('foo') {}

[01:22] <tadzik> &foo.WHY :P

[01:22] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, $doc_obj, :$docs!) { my $do = $doc_obj; $r does role { method docs() { $do } } }

[01:22] <p6eval> nom:  ( no output )

[01:23] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, $doc_obj, :$docs!) { my $do = $doc_obj; $r does role { method docs() { $do } } }; sub foo is doc('oh lol vodka') { }; say &foo.docs

[01:23] <tadzik> jnthn: how about 'because' instead of 'is doc'?:)

[01:23] <p6eval> nom: OUTPUT¬´No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:‚ê§:(Attribute $attr, Any $rw)‚ê§:(Attribute $attr, Any $readonly)‚ê§:(Routine $r, Any $rw)‚ê§:(Parameter $param, Any $readonly)‚ê§:(Parameter $param, Any $rw)‚ê§:(Parameter $param, Any $copy)‚ê§:‚Ä¶

[01:23] *** RandalSchwartz left
[01:23] <jnthn> hmm

[01:24] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, $doc_obj = 'default', :$doc!) { my $do = $doc_obj; $r does role { method docs() { $do } } }; sub foo is doc { }; say &foo.docs

[01:24] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:24] <jnthn> eek!

[01:24] <tadzik> e ke ke ke :)

[01:24] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, $doc_obj = 'default', :$doc!) { my $do = $doc_obj; $r does role { method docs() { $do } } }; sub foo is doc('lol wut') { }; say &foo.docs

[01:24] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:24] <ash__> o.0

[01:25] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, :$doc!) { my $do = 'foo'; $r does role { method docs() { $do } } }; sub foo is doc { }; say &foo.docs

[01:25] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:25] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, :$doc!) { my $do = 'foo'; $r does role { method docs() { $do } } }; sub foo is doc { };

[01:25] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:25] <tadzik> nom: multi trait_mod:<because>(Routine:D $r, $doc_obj = 'default') { my $do = $doc_obj; $r does role { method docs() { $do } } }; sub more because('moar!'); say &more.docs

[01:25] <p6eval> nom: OUTPUT¬´Malformed block at line 1, near "because('m"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[01:25] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, :$doc!) { my $do = 'foo'; say "here" }; sub foo is doc { };

[01:25] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:26] <jnthn> ok, wtf.

[01:26] *** Chillance left
[01:26] <tadzik> nom: multi trait_mod:<is>(Routine:Dr, :$doc!) { my $do = 'foo'; say "here" }; sub foo is doc { };

[01:26] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:26] <tadzik> ee

[01:27] <jnthn> nom: multi trait_mod:<is>(Routine:D $r, :$doc!) { say "here" }; sub foo is doc { };

[01:27] <p6eval> nom: OUTPUT¬´here‚ê§¬ª

[01:27] <tadzik> nom: multi trait_mod:<because>(Routine:D $r, $d) { say "bigos" }; sub just because("I wanted") {};

[01:27] <p6eval> nom: OUTPUT¬´Malformed block at line 1, near "because(\"I"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[01:27] <tadzik> oh, 'because' does not even parse

[01:28] <jnthn> no :)

[01:28] * tadzik shows parser a tounge

[01:28] <jnthn> I got the segv in the debugger.

[01:28] <jnthn> Sadly...that doesn't help a lot.

[01:28] <jnthn> oh, wait a second...

[01:29] <jnthn> nom: BEGIN { my $a = 'hi'; say $a }

[01:29] <p6eval> nom: OUTPUT¬´Segmentation fault‚ê§¬ª

[01:29] <jnthn> Got it.

[01:29] <colomon> \oi/

[01:30] <colomon> wait, did I just grow a third arm?!

[01:30] <tadzik> okay, my code segfaults too, so there's a chance it's correct :P

[01:30] <jnthn> But I'm *really* too sleepy to fix that one.

[01:30] <tadzik> that means I'll get some sleep too :)

[01:31] <jnthn> *sigh*

[01:31] <jnthn> Guess the lexpad refactor I thought I'd get away with for a while, I actually won't.

[01:32] * jnthn gets some rest so he has hackenergy for tomorrow :)

[01:32] <tadzik> I'm resting too then :)

[01:32] <jnthn> night o/

[01:32] <tadzik> jnthn++

[01:32] *** ab5tract left
[01:32] <tadzik> 'night!

[01:35] <colomon> \o

[01:40] *** molaf_ left
[01:54] *** kboga left
[02:01] *** bluescreen10 joined
[02:05] *** bluescreen10 left
[02:13] *** Trashlord left
[02:13] *** cosimo left
[02:13] *** TiMBuS left
[02:15] *** skangas left
[02:15] *** pernatiy_ joined
[02:15] *** pernatiy left
[02:15] *** literal left
[02:15] *** literal joined
[02:15] *** pnu joined
[02:15] *** skangas_ joined
[02:15] *** skangas_ is now known as skangas

[02:15] *** [particle] left
[02:16] *** [particle] joined
[02:17] *** Trashlord joined
[02:17] *** cosimo joined
[02:17] *** TiMBuS joined
[02:17] <sorear> What happened to communication?

[02:17] <sorear> Stack frames ARE first class objects!!

[02:18] <sorear> it's like merlyn or me has lost the ability to speak/understand English

[02:18] <sorear> or both

[02:20] <ash__> is english your first language?

[02:27] <sorear> yes

[02:27] <sorear> merlyn's too

[02:28] <sorear> I'm bemoaning a breakdown of communication here

[02:41] *** jimmy1980 left
[02:48] *** jimmy1980 joined
[02:54] *** tokuhirom joined
[03:01] *** whiteknight left
[03:14] *** soh_cah_toa left
[03:24] *** kaare_ joined
[03:25] *** tokuhirom left
[03:26] *** tokuhirom joined
[03:26] *** Su-Shee left
[03:27] *** soh_cah_toa joined
[03:28] *** Su-Shee joined
[03:30] *** tokuhirom left
[03:35] *** robinsmidsrod joined
[03:51] *** soh_cah_toa left
[03:53] <sorear> I feel bad about earlier.  Like somehow all those problems were my fault.

[04:06] *** shinobicl joined
[04:11] <TimToady> don't sweat it

[04:12] <TimToady> Randal isn't the sort of person who keeps score

[04:14] <sorear> TimToady: would it be horrible if $x."A::b"() were interpreted the same as $x.A::b ?

[04:14] <sorear> ie, interpreting the part before :: as a symbolic reference to a class name

[04:15] <TimToady> maybe, especially if $x is a foreign object that assigns a different meaning to ::

[04:16] <TimToady> part of the reason for putting the quote form there is to allow communication with foreign dispatchers

[04:17] <TimToady> however, it would be okay if Perl's dispatcher treated it like a type prefix

[04:17] <TimToady> the parser can't assume that, though

[04:17] <TimToady> (sans type inference)

[04:18] <sorear> My least favorite thing about J is the shared commuity opinion, "There are two kinds of programmers: those that use J, and those that would if they were smart enough to"

[04:19] <TimToady> yes, Haskell has tendencies to that as well, though they're not expressed so succinctly :)

[04:19] <sorear> is it worse now than three years ago when I left in disgust?

[04:20] <TimToady> dunno

[04:21] <TimToady> but it's a tendency I'm always bearing in mind when designing the fancier bits of p6, so as to keep it accessible to mere mortals

[04:21] <[Coke]> J == ASCIIAPL, neh?

[04:21] <TimToady> basically

[04:21] * [Coke] wonders if apl on parrot even compiles anymore.

[04:22] * [Coke] will find out lazzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz.

[04:22] <TimToady> not much to an APL compiler...well, parser, anyway...

[04:22] <sorear> it's not the mere mortals stuff that bothers me, but the arrogance of it all...

[04:22] <[Coke]> t/spec/S05-substitution/subst.rakudo sure does like the taste of CPU.

[04:22] <TimToady> my brother-in-law wrote an APl interpreter for his undergrad honors project

[04:23] <sorear> J is one of those fun languages that don't have a compiler in any sense of the word

[04:23] <TimToady> in PDP-11 assembler

[04:23] <sorear> I don't know about APL though

[04:23] <TimToady> it's pretty much the same language with different symbols

[04:23] <sorear> but the J interpeter executes while parsing, and the language is set up such that it would be hard for it not to

[04:24] <TimToady> .u ‚åΩ

[04:24] <phenny> U+233D APL FUNCTIONAL SYMBOL CIRCLE STILE (‚åΩ)

[04:24] <TimToady> is J precedence-less like APL?

[04:25] <TimToady> I think J's syntax rules are a bit fancier than APL's in some ways though

[04:25] <sorear> J gives binary metaops higher precedence over normal ops

[04:25] <sorear> 1 * 2 + 3 means 1 * (2 + 3) as in APL though

[04:26] *** cryptographrix joined
[04:27] <TimToady> Oh, I didn't realize J was also by Iverson

[04:29] <sorear> I don't think it has anything to do with "genius" versus "mortal"

[04:29] <sorear> as I see it, the community selection is "can you tolerate arrogant jerks?"

[04:30] *** cryptographrix left
[04:30] <TimToady> we can tolerate them as long as they don't behave that way :)

[04:34] <TimToady> some arrogant jerks are trainable, some are not :)

[04:36] <TimToady> our official minimum bar on perl6.org is "know how to be nice to people", not a requirement that you manage it 100% of the time :)

[04:37] <TimToady> but people who know how to be nice are usually willing to listen when someone points out that they've been less nice than strictly necessary

[04:37] <sorear> yeah.  what I'm saying is it feels like the J community is exactly the opposite

[04:39] <TimToady> well, yeah...it can be a self-reinforcing cult/cultural dynamic when you get a barricade mentality

[04:40] <TimToady> it's not just the intelligencia that fall into that trap

[04:40] <TimToady> the higher the barricade, the more shibboleths develop

[04:41] <TimToady> it's one thing when a shibboleth is used to tell when someone is an outsider, so you know to be gentle; it's quite another when it's used (as in the original sense) to decide whether to kill someone

[04:42] <TimToady> if someone comes in here and says PERL, we know they're not really in the know

[04:42] <TimToady> but we can have compassion for them :)

[04:43] <TimToady> 'course, if they come in here and tell us it *has* to be PERL because it's an acronym, then maybe they're just an arrogant jerk :)

[04:43] <TimToady> so it kinda works as a filter, similar to Camelia, for telling the jerks from the jerkoids

[04:46] <TimToady> maybe we're just arrogant about *not* being jerks :)

[04:46] *** kaare_ left
[04:49] <[Coke]> dalek?

[04:50] <[Coke]> ugh, zz

[04:51] *** Mowah joined
[04:52] <dalek> rakudo/nom: 39931fd | Coke++ | t/spectest.data:

[04:52] <dalek> rakudo/nom: track spectest failure modes.

[04:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39931fdfe6

[05:03] *** lefthandman joined
[05:06] <TimToady> sorear: what is your definition of "first class"?  Do you mean "on the heap", or something else?

[05:06] *** benabik left
[05:12] *** tokuhirom joined
[05:18] <sorear> TimToady: on the heap as a Perl 6 object, ~~Mu, with .HOW .WHAT .WHO

[05:18] <sorear> returned by &callframe

[05:20] <TimToady> but when the stack unwinds, and you keep a ref to it, does it stay valid, such that you could continue it, is the other part, or is the heap object just epiphenomenal?

[05:20] <TimToady> that might currently be implementation dependent

[05:20] *** meteorjay joined
[05:20] *** meteorjay left
[05:21] <TimToady> sorry, now my English is coming sideways out...

[05:22] <sorear> Hehe

[05:23] <sorear> I don't think it's currently possible to 'go to' a allFrame object

[05:23] <TimToady> must be those continuations in my brane

[05:23] <TimToady> that might be part of Randal's question

[05:23] <TimToady> and part of his def of 1st class

[05:23] <sorear> I think Randal's real question is "Can I implement Continuity in Perl 6?"

[05:24] *** meteorjay joined
[05:24] <TimToady> Randal has liked Smalltalk even longer than he's liked Perl

[05:25] <TimToady> but it's one of those things that I just try to design close to, not necessarily to mandate it, but to perhaps make it possible in the future

[05:25] <TimToady> but I suspect it might impede portability to mandate it

[05:25] <TimToady> or optimizability

[05:26] <TimToady> otoh there are some pretty snappy Smalltalk implementations

[05:27] <TimToady> Ruby is basically Smalltalk underneath

[05:28] <TimToady> but also I don't think Smalltalk scales very well into the real world

[05:31] <sorear> What do you mean by that?

[05:34] <TimToady> it's just a general feeling that I get for "workspace" languages; I always feel a bit claustrophobic, like I'll be in trouble if I do anything outside of the little toy world

[05:34] <sorear> I like to think of Unix as a workspace language

[05:35] <TimToady> I dunno, Unix is a bit more outward looking, i think

[05:35] <TimToady> and it's a very big toybox, if toybox it is

[05:36] <TimToady> but toybox has always been an anti-pattern to Perl; we want Perl to talk to everything else

[05:37] <TimToady> so it's sort of ironic that Perl culture has become a bit of an echo chamber

[05:38] <sorear> echo chamber?

[05:38] <TimToady> we talk to each other more than we talk to outsiders

[05:39] <mberends> if Unix is a toybox, at least the toys are made of the metal of your CPU, and you can drill, saw and weld them

[05:39] <TimToady> Unix is more like a rather cluttered garage

[05:40] <sorear> every toybox language I've played with has had a built-in assembler

[05:40] <sorear> * this means ['Forth']

[05:43] * TimToady wonders if we should reserve {'foo','bar','baz'} for set notation, as a hash without values

[05:44] <TimToady> probably would be too much ambiguity

[05:44] <sorear> I wonder if it makes sense to allow $::("!foo")

[05:45] <TimToady> how come Unicode has bag delimiters but not set delimiters?

[05:45] <TimToady> .u ‚üÖ

[05:45] <phenny> U+27C5 LEFT S-SHAPED BAG DELIMITER (‚üÖ)

[05:45] <TimToady> .u ‚üÜ

[05:45] <phenny> U+27C6 RIGHT S-SHAPED BAG DELIMITER (‚üÜ)

[05:45] <sorear> I've always seen sets typeset with { }

[05:45] <TimToady> it's bad enough to overload { } with => inside...

[05:47] *** nymacro joined
[05:47] <TimToady> 'foo' ‚à™ 'bar' ‚à™ 'baz' works, I suppose

[05:47] <TimToady> assuming we have (Any,Any) as a variant

[05:48] <TimToady> probably a level violation though

[05:48] <TimToady> 'foo' ‚à™ 'bar' ‚à™ (1 ‚à™ 2 ‚à™ 3) would not do the right thing

[05:49] <TimToady> set theory wants sets that contain sets

[05:50] <TimToady> perl6: say set 1,2,3

[05:50] <p6eval> rakudo 922500: OUTPUT¬´123‚ê§¬ª

[05:50] <p6eval> ..pugs: OUTPUT¬´*** No such subroutine: "&set"‚ê§    at /tmp/O8N8XGq87X line 1, column 5 - line 2, column 1‚ê§¬ª

[05:50] <p6eval> ..niecza v8-4-g2c56dcb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§       'set' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ‚ê§  at‚Ä¶

[05:50] <TimToady> rakudo: say set(1,2,3).kv

[05:50] <p6eval> rakudo 922500: OUTPUT¬´011223‚ê§¬ª

[05:51] <TimToady> what I thought

[05:52] <TimToady> that should make 11 21 31 in some order

[05:52] <TimToady> or 1True2True3True

[05:52] *** djanatyn joined
[05:52] <djanatyn> Hey guys.

[05:52] <TimToady> that's why I added Object hash to the features lists to be with Sets

[05:53] <TimToady> howdy

[05:53] <djanatyn> I've been messing with Perl 5 for quite a while now.

[05:53] <TimToady> is that why it's a mess?

[05:53] <djanatyn> I've been checking out both Perl 6 and Python.

[05:53] <TiMBuS> lol

[05:53] <djanatyn> Nah, looks like some other guys got there first.

[05:53] * TimToady snorts

[05:53] <djanatyn> Can you guys tell me why I should join the Perl 6 revolution instead of becoming a Pythonista?

[05:54] <djanatyn> I really liked hacking in Perl 5. It's the first language that I actually started making Cool Stuff with.

[05:54] <djanatyn> But, Python seems pretty awesome too. I haven't used Moose very much, but I'

[05:54] <djanatyn> *I've been getting used to the standard OOP in Perl 5.

[05:54] <TimToady> Python is in the business of making features look like hammers so that problems look like nails, which is fine when your problems look like nails

[05:54] <djanatyn> Perl 6 seems a *lot* more object oriented

[05:54] <TimToady> it is

[05:54] <TimToady> it's more OO than Python

[05:55] <TimToady> more on a par with Ruby

[05:55] <djanatyn> Heh

[05:55] <djanatyn> I checked out Ruby, too.

[05:55] *** sshc joined
[05:55] <TimToady> Ruby has different problems, though there's some overlap with Python

[05:55] <djanatyn> Is everything an object in Perl 6 as well?

[05:55] <TimToady> perl6: say 1.WHAT

[05:55] <p6eval> pugs: OUTPUT¬´Int‚ê§¬ª

[05:55] <p6eval> ..rakudo 922500, niecza v8-4-g2c56dcb: OUTPUT¬´Int()‚ê§¬ª

[05:56] <TimToady> does that answer your question? :)

[05:56] <djanatyn> yep ;)

[05:56] <Tene> djanatyn: Yeah, pretty much, depending on what angle you look at native attributes and packed arrays from.

[05:56] <djanatyn> I was looking at ruby's main website

[05:56] <djanatyn> I got really confused at first, when I saw some simple code:

[05:56] <TimToady> now, we do have native types specced, which force the type info onto the container instead

[05:56] <djanatyn> 1.times { print "hello world" }

[05:57] <TimToady> we don't think .times belongs in the Int class

[05:57] <Tene> Yeah, I still think that that's pretty horrible.

[05:57] <djanatyn> I thought there was a function, "times", that took it's argument as a prefix followed by a period

[05:57] <djanatyn> which shows how much I know about object oriented programming.

[05:57] <djanatyn> so, Perl 6 will fix me up?

[05:57] <mberends> djanatyn: a nice you'll notice here is the community, over here language implementers and users mix freely, there is no elite.

[05:58] <djanatyn> I have to admit, the whole culture of perl 6 is pretty enticing.

[05:58] <TimToady> at least, the elite pretend not to be :)

[05:58] <djanatyn> you guys seem really friendly and helpful, and dedicated to the language in general.

[05:58] <TimToady> well, you have to be a little bit bonkers to keep working at the same goal for 11 years

[05:58] <djanatyn> I like writing stuff :)

[05:58] <djanatyn> I'm not exactly the best at it, though

[05:58] <TimToady> we all have our strengths and weaknesses

[05:59] <djanatyn> (people like me are the reason perl has a reputation for looking like line noise)

[05:59] <TimToady> it will be a little harder to do that in p6, but only a little :)

[05:59] <Tene> djanatyn: Haha, no, not so much.

[05:59] <TimToady> there's lots of wiggle room

[05:59] <TimToady> the obfuscation tends to come out a little differently

[05:59] <djanatyn> Tene here knows me pretty well

[06:00] <djanatyn> He always fixes up my perl code for me ;)

[06:00] <Tene> Yeah, and you still don't listen to me about using bareword filehandles. :P

[06:00] <djanatyn> gotta work on that ^_^

[06:00] <djanatyn> let's write something in perl 6 :D

[06:01] <djanatyn> with no bareword filehandles.

[06:01] * djanatyn installs parrot and rakudo

[06:01] <Tene> sweet; let's do it

[06:01] <TimToady> for example, you can compare the two solutions in http://rosettacode.org/wiki/Constrained_random_points_on_a_circle#Perl_6

[06:02] <TimToady> the second one is "functional", but arguably less readable

[06:02] <sorear> djanatyn: Python's competition is the Perl 5 revival led by Moose and company.  Perl 6 wants to obsolete both of them someday :D

[06:02] <TimToady> Python's main problem right now is that they defined a small incompatibility with 3.0, and can't get anyone to adopt it

[06:03] <TimToady> I think we made the right choice to go for a large incompatibility, since the pain of crossing will be about the same

[06:04] <djanatyn> I'm on debian - should I actually go through building the compiler from source, or is there a convenient package out there?

[06:04] <TimToady> best to build from source for now, probably

[06:04] <moritz> you need to build from source

[06:04] <Tene> djanatyn: rakudo was recently added to debian unstable, I hear

[06:04] <sorear> I think a lot of newbies overstate the importance of choosing a language to learn

[06:04] <moritz> debian packages are being worked on

[06:05] <sorear> I've been programming for about 13 years.  Last weekend I learned J in 4 days.  It's not hard at all to pick up more, once you have one

[06:05] <TimToady> yes, but you are one of those elite that are pretending not to be :P

[06:05] <djanatyn> I've been programming...well. That's hard to say.

[06:05] <djanatyn> I've been messing around with computers and languages as long as I can remember.

[06:05] <djanatyn> I've actually started sitting down, reading books and documentation, and writing stuff for about...6 months, I'd say?

[06:06] <djanatyn> But before that, I did a lot of experimentation with programming languages, and a lot of learning my way around unix.

[06:06] <djanatyn> And for some weird reason, I've always known a bunch of C. not sure exactly where I picked that up.

[06:06] <TimToady> if you want to see how Perl 6 stacks up (no pun intended) against other languages, rosettacode.org is a nice site

[06:07] <sorear> (incidentally, everyone needs to check out J.  At the very least, it will make whatever language you're using now seem much more readable. :)

[06:07] <Tene> aw, c'mon, you can say "stacks up" and not mention factor. :P

[06:07] <TimToady> well, all the APLish languages hold brevity to be one of the highest goals

[06:08] <sorear> also the J implemententation makes Perl 5 look pretty

[06:08] <TimToady> we're trying to get most of the power, without sacrificing readability

[06:08] <TimToady> so our metaops look very different from normal ops

[06:08] <TimToady> we also believe in precedence :)

[06:09] <djanatyn> :D

[06:09] <djanatyn> so, rakudo-star has lots of documentation and stuff, but rakudo is just the compiler?

[06:09] <TimToady> certainly, the docs are still shakier for P6

[06:10] <moritz> djanatyn: right, docs and modules

[06:13] * djanatyn runs Configure.pl

[06:14] <TimToady> you probably want --gen-parrot

[06:14] <djanatyn> Umm, do I need to install parrot first?

[06:14] <TimToady> not if you ^^

[06:14] <djanatyn> Yep, added that to the end

[06:14] <djanatyn> cool :D

[06:14] <djanatyn> and should that be run as root?

[06:14] <TimToady> nah

[06:14] <TimToady> it does a local install in your directory

[06:14] <TimToady> you can make a symlink to that if you like

[06:15] *** araujo left
[06:19] <sorear> TimToady: do you think $::("!attr") makes sense?

[06:19] *** molaf joined
[06:19] <TimToady> not particularly

[06:19] <sorear> hmm

[06:19] <TimToady> unless it's a pure textual macro that slurps the surrounding token

[06:20] <TimToady> but that's not how it is in my head

[06:20] <sorear> How is it in your head?

[06:21] <TimToady> my head wants ::() to only occur on normal :: boundaries

[06:21] <TimToady> not between sigil and twigil

[06:21] *** mattp_ left
[06:21] <TimToady> if you want to do any token gluing, it should be inside the ()

[06:22] <TimToady> ::() is specced to reparse for :: though, unlike .""

[06:22] <TimToady> FOO::{} doesn't reparse, since it's direct stash lookup

[06:23] <sorear> What do you think of my $var; $::("var") ?

[06:23] <TimToady> that's okay-ish to me, but a bit of a no-op

[06:24] <TimToady> perl6: my $foo = 42; say $::foo

[06:24] <sorear> of course I would never write it with a string literal

[06:24] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Cannot make a compile time reference to the semantic root package at /tmp/eiik5xxEZs line 1 (EOF):‚ê§------> [32mmy $foo = 42; say $::foo[33m‚èè[31m<EOL>[0m‚ê§‚ê§Potential difficulties:‚ê§  $foo is declared but not used at /tmp/eiik‚Ä¶

[06:24] <p6eval> ..pugs, rakudo 922500: OUTPUT¬´42‚ê§¬ª

[06:24] <TimToady> ^^

[06:24] <TimToady> same thing, really

[06:24] <djanatyn> Configure.pl takes a long time :)

[06:24] <sorear> (as you can see the niecza name handling needs this rewrite badly)

[06:25] <TimToady> any initial :: is really a no-op

[06:25] <TimToady> except in a type capture

[06:25] <sorear> djanatyn: it's downloading, compiling, and installing Parrot

[06:25] <djanatyn> tell me more about why perl 6 is better than perl 5, please? ;)

[06:25] <djanatyn> sorear: yeah, I suspected it might take a while

[06:25] <sorear> djanatyn: surely that depends on how you define "better"

[06:26] <djanatyn> Well, it's apparently more object oriented

[06:26] <sorear> betterness space is many-dimensional, the answer depends on exactly which covector you mean..

[06:26] <djanatyn> that sounds pretty awesome to me

[06:26] *** uvtc joined
[06:26] <TimToady> it retains all of the essence of Perl while cleaning up a lot of the cruft, and becomeing much more powerful too

[06:26] <djanatyn> And I've heard it's a lot more "functional".

[06:26] <sorear> the best thing about Perl 6 is that it has muliple implementations

[06:26] <djanatyn> what exactly does that mean (if it's true?)

[06:26] <moritz> we really need a "what does Perl 6 provide over $language" page

[06:26] <TimToady> it's more FP if you want it to be

[06:27] <uvtc> TimToady: earlier you were talking about potential unicode delimiters for sets.

[06:27] <djanatyn> I spent a while with haskell

[06:27] <uvtc> TimToady: Since sets usually use curlies, maybe the next best thing is wavies?

[06:27] <uvtc> $s = ‚åá a b c ‚åá

[06:27] <uvtc> U+2307

[06:27] <TimToady> FP is about programming more with definitions than with side effects, basically

[06:27] <sorear> perl 6 has more potential for higher-order programming in the basic language

[06:27] <sorear> anonymous subs are more concise (this helps a LOT)

[06:28] <TimToady> all operators are really just normal functions

[06:28] <Tene> uvtc: when I wrote a set module a long time ago, I used circumfix:<‚¶É ‚¶Ñ>

[06:28] <moritz> multi dispatch!

[06:29] <uvtc> Tene: oooh, pretty. :)

[06:29] <Tene> and for bags, I used circumfix:<‚üÖ ‚üÜ>

[06:29] <TimToady> perl 6 allows the user to be confused about the difference between numbers and strings, but unlike Perl 5, is not confused itself

[06:29] <Tene> .u ‚¶É ‚üÖ

[06:29] <phenny> U+2983 LEFT WHITE CURLY BRACKET (‚¶É)

[06:29] <phenny> U+0020 SPACE ( )

[06:29] <phenny> U+27C5 LEFT S-SHAPED BAG DELIMITER (‚üÖ)

[06:29] <TimToady> SPACE, the final frontier...

[06:30] <djanatyn> hey, phenny? isn't that python? :D

[06:30] <Tene> yep

[06:30] <TimToady> you wanna rewrite in p6, go ahead :)

[06:30] <djanatyn> that actually sounds like it might be fun!

[06:30] <djanatyn> but phenny has tons of stuff, would be pretty difficult.

[06:30] <djanatyn> Writing an IRC bot in p6 sounds like a fun task.

[06:31] <djanatyn> One of my goals is to write an IRC client and an IRC server in p5.

[06:31] <djanatyn> Well, technically, I wasn't sure exactly what language I wanted to do it in ;)

[06:31] <Tene> yeah, unfortunately Perl 6 is missing a lot of support that would make that reasonable. :(

[06:31] <djanatyn> aww. :\

[06:31] <TimToady> soon now

[06:31] <djanatyn> Well, how unreasonable would it be?

[06:31] <Tene> network IO is awkward, rakudo doesn't have threading or async IO, etc.

[06:32] <djanatyn> Oh, I see.

[06:32] <TimToady> niecza has async

[06:32] <djanatyn> That would make it a bit unreasonable.

[06:32] <Tene> and niecza has threading

[06:32] <TimToady> but not async IO, I expect

[06:32] <djanatyn> Cool, parrot is installed and my Makefile is configured

[06:32] * djanatyn makes

[06:32] <Tene> Haha, yeah, I misread. :(

[06:34] <sorear> niecza is on the CLR, a fairly mature (but not Perl-focused) runtime system which has threading and async I/O

[06:34] <djanatyn> the most compelling and the least attractive reason for me to learn perl 6 seems to be the same.

[06:34] <djanatyn> It's at an early stage, so a lot of the stuff in otherl languages doesn't seem to be there yet

[06:34] <djanatyn> (if I understand correctly)

[06:34] <sorear> if you want to write an app using async I/O for niecza, you can probably do it, with hacks

[06:34] <TimToady> yes, but we have 350 examples of running code on rosettacode.org

[06:34] <sorear> with Rakudo it will be a lot harder

[06:35] <sorear> there was a GSoC last year (failed) to add threads to Parrot

[06:35] <sorear> the main thing stopping niecza from having async I/O is a user

[06:36] <sorear> you can't just design something like this without use cases, you'll make something unintentionally useless

[06:36] <TimToady> Uri was just asking me about async IO at dinner

[06:36] <sorear> I would be eager to work closely with someone wanting to use async I/O, to make it happen in a useful way

[06:36] <TimToady> since he was one of the people who originally wrote an RFC for it in 2000 :)

[06:37] <sorear> then we can write a spec for it

[06:37] <TimToady> http://dev.perl.org/perl6/rfc/47.pod

[06:39] <djanatyn> Is there an emacs mode for perl6?

[06:39] <TimToady> I think so, but many of us are vimpy

[06:39] <TimToady> vimpacious?

[06:40] <TimToady> viminators?

[06:40] *** JimmyZ joined
[06:40] <sorear> I usually use vim with :syntax off

[06:40] <sorear> perl6.vim is unusably slow and doesn't work anyway

[06:40] <djanatyn> Whenever I turn the syntax off, I usually spend more time debugging.

[06:40] <TimToady> I usually have it on?

[06:40] <TimToady> *.

[06:41] <TimToady> but my machine is pretty speedy, and I mostly look at short examples

[06:41] <djanatyn> I'm really talented at creating stupid syntax errors.

[06:41] <djanatyn> I'm on a netbook! :D

[06:41] <djanatyn> If all goes well, I should be getting a ThinkPad next week.

[06:41] <djanatyn> I'm a poor high school student, so I've been saving up.

[06:41] <djanatyn> Is there Curses support in Perl 6?

[06:42] <djanatyn> Or a Curses library or something?

[06:42] <TimToady> I thought parrot had something once

[06:42] <TimToady> I usually just use ANSI codes :)

[06:43] <sorear> yeah the cutoff for perl6.vim being unusably slow is around 500 lines for me

[06:43] <uvtc> djanatyn: http://modules.perl6.org/ lists a number of modules currently available

[06:44] <uvtc> But curses seems to be on the most-wanted list (linked to from that page)

[06:44] <djanatyn> I haven't been using perl for very long, but it's pretty obvious that CPAN is *huge*.

[06:44] <sorear> djanatyn: most of us are pretty young here.

[06:44] <djanatyn> was there a CPAN before perl 5?

[06:44] <TimToady> some of us just act young

[06:45] <TimToady> djanatyn: not really

[06:45] <TimToady> perl 4 didn't have an extension mechanism

[06:45] <djanatyn> nice try, mr. wall :D

[06:45] <sorear> me, I've been using the same computer since I was in middle school

[06:45] <TimToady> instead we got variant versions like oraperl and sybperl

[06:45] <TimToady> I could see that wouldn't scale, so P5 had an extension mechanism

[06:45] <sorear> TimToady: why?  lack of DynaLoader?

[06:46] <TimToady> that was part of the P5 design

[06:46] <djanatyn> Interesting.

[06:46] <djanatyn> sorear: I anticipate using this new ThinkPad for quite a long time.

[06:47] <TimToady> ThinkPads are generally pretty solid workhorses

[06:47] <djanatyn> would it be possible to use the Template::Toolkit in Perl 6?

[06:47] <djanatyn> I've been working on a little project in perl 5 to create a personal website.

[06:47] <Tene> uvtc: Several years back, I started a roguelike in Perl 6, using Curses from parrot, until i gave up on being the only one fixing HLL interop in rakudo.  I've mentioned several times in here, though, that a Curses module that just wrapped the Parrot Curses module would be pretty trivial, with a small bit of embedded PIR.

[06:47] <sorear> you'd need to port it.

[06:47] <djanatyn> it uses the template toolkit to generate a bunch of html pages.

[06:48] <sorear> no Perl 6 implementation has a Perl 5 compatibility layer yet

[06:48] <djanatyn> it takes a bunch of input files, processes them, and spits out a static website.

[06:48] <sorear> and (by design) no Perl 5 module can accidentally parse as Perl 6

[06:48] <Tene> djanatyn: There's a small workalike to Template::Toolkit in the web.pm repo

[06:48] <djanatyn> I was having a lot of fun with it, and learned a lot of perl 5 quirks writing it.

[06:48] <Tene> called... uh... Ratel, I think.

[06:48] <sorear> wait what am I talking about I wrote just such a compatibility layer last year

[06:48] <djanatyn> I also saw HTML::Template, which might be just what I need.

[06:49] <sorear> I'm young but sometimes I act old :D

[06:49] <djanatyn> Heh.

[06:51] <uvtc> Tene: would make an interesting tutorial if you could explain how you created your Curses module. (BTW, where does one even find a list of available "Parrot modules"?)

[06:51] <TimToady> you have to be initiated into the inner mysteries :)

[06:51] <sorear> try looking in parrot/runtime/library

[06:52] <Tene> uvtc: in the 'library' dir of... yeah, that

[06:52] <sorear> hmmm, Uri's RFC advocates ithreads

[06:53] * sorear wonders if ithreads will be part of Perl 6

[06:53] *** sshc left
[06:53] *** sshc joined
[06:53] <sorear> it seems to make a big difference whether the system can assume single-threaded access to all objects

[06:53] <djanatyn> I feel like I'm compiling the language of the future :D

[06:54] <Tene> uvtc: All i did back then was: use Curses:from<parrot>;

[06:54] <TimToady> djanatyn: we'd like to think so

[06:54] <sorear> use Curses:from<parrot> doesn't work anymore

[06:54] <sorear> this might be my fault

[06:55] <Tene> uvtc: an equivalent Curses.pm for Rakudo would just load the Curses.pbc file and then copy the relevant namespace.

[06:55] <Tene> sorear: No, it isn't.

[06:55] <sorear> Tene: so it started before I disabled the PDD21 implementation while making Blizkost work?

[06:55] <TimToady> sorear: the PROCESS vs GLOBAL split is there in case we decide we want ithreads

[06:56] <sorear> TimToady: I don't understand how that would work

[06:56] <uvtc> sorear: Ah, `/runtime/parrot/library`. Thanks.

[06:56] <sorear> TimToady: surely any object can be bound to a PROCESS::<$x> variable

[06:56] <TimToady> each interpreter would have its own GLOBAL but share PROCESS

[06:56] *** daxim joined
[06:56] <sorear> which means any object can potentially be accessible from multiple interpreters

[06:56] <Tene> sorear: It was working and broken several times long before blizkost was around.

[06:56] <TimToady> the PROCESS space would likely be readonly to interpreters by default

[06:57] <sorear> what if I do $PROCESS::IN does role { has $.x }; $PROCESS::IN.x = $unshared?

[06:58] <uvtc> Tene: Still might make a great blog post. Walk a user through how to use libs in runtime/parrot/library from your Perl 6 source code file.

[06:59] <TimToady> sorear: what if it doesn't let you?

[06:59] <Tene> sorear: see http://blogs.gurulabs.com/stephen/2009/05/cross-language-library-loading.html

[06:59] <djanatyn> It looks like if I stick with learning Perl 6, I might actually get the chance to write some modules.

[06:59] <Tene> So, 2009/05

[06:59] <djanatyn> How difficult is that?

[06:59] <djanatyn> And does learning Perl 6 currently include learning how Parrot works?

[06:59] <djanatyn> Oh, awesome!

[06:59] <djanatyn> perl6 is compiled :D

[07:00] <TimToady> whatever that means

[07:00] <daxim> ‚Üë what he said

[07:01] <sorear> Except for Tcl and J, every language I've played with has had a compiler, and I've played with quite a few.

[07:01] <djanatyn> I mean to say, the "make" command has finished for rakudo-star.

[07:01] <sorear> ah.

[07:02] <TimToady> ah, we misunderstood completely :)

[07:02] <TimToady> sorry, it's a hot button question in Perl culture :)

[07:02] <TimToady> djanatyn: I hope it doesn't, because I don't currently know how Parrot works

[07:03] <djanatyn> ...that's a good sign, I think.

[07:03] <djanatyn> For me. Maybe.

[07:03] * djanatyn jumps right into perl6!

[07:03] <TimToady> well, someone has to know how it works...

[07:03] <djanatyn> let's get a hello world or something.

[07:03] <TimToady> perl6: say "hello, world"

[07:03] <p6eval> pugs, rakudo 922500, niecza v8-4-g2c56dcb: OUTPUT¬´hello, world‚ê§¬ª

[07:04] <sorear> not knowing how Parrot works is probably a good sign

[07:05] <djanatyn> ...huh.

[07:05] <djanatyn> Well, running a one-line "hello world" program took several seconds.

[07:05] <djanatyn> Is that just because it takes a while for parrot to start up, or is perl6 really really slow? :)

[07:05] <sorear> djanatyn: I also encourage you to apt-get install mono-complete and take a look at https://github.com/downloads/sorear/niecza/niecza-8.zip

[07:06] <sorear> djanatyn: what you're seeing is constant factors

[07:06] <moritz> djanatyn: rakudo is slow, but usually not that slow

[07:06] <sorear> djanatyn: Rakudo Perl 6 *is* very slow, it takes 0.05 seconds per line or so

[07:06] <TimToady> rakudo/parrot has historically been slow, but the new rakudo "nom" is about five times faster

[07:06] <djanatyn> moritz: I'm on a really slow EeePC.

[07:07] <TimToady> niecza is pretty zippy, except when it isn't

[07:07] <moritz> a "hello, world" takes < 1s here, nearly all of it startup

[07:07] <TimToady> anyway, that will improve greatly over time

[07:08] <TimToady> parrot has forced rakudo to do some silly things in the past

[07:08] <TimToady> and rakudo has done a few silly things all on its own

[07:08] <TimToady> but it's getting better fast

[07:08] <sorear> djanatyn: ls -lh perl6.pbc

[07:09] <sorear> djanatyn: think about "several seconds to start up" in the context of the size of that file

[07:09] <sorear> that file contains the parser and code generator

[07:09] <djanatyn> Oh, snap.

[07:10] <sorear> djanatyn: I'm curious how long niecza takes to start for you

[07:10] <djanatyn> well, I suppose I could install it.

[07:10] <uvtc> Once Rakudo has done its job of compiling a Perl 6 source file, is the execution speed thereafter entirely dependent upon Parrot?

[07:11] <moritz> uvtc: no

[07:11] <moritz> uvtc: eval() needs to call back into the compiler

[07:11] <sorear> uvtc: no, because Rakudo controls what instructions are generated

[07:11] <TimToady> nom would not be five times faster if it was dependent entirely on parrot speed

[07:12] <TimToady> nom generates many fewer temp objects

[07:12] <uvtc> sorear: So, of course, the better Rakudo can optimize its output, the faster execution will be.

[07:12] <sorear> uvtc: for instance, rakudo compiles $lexical to find_lex $P0, '$lexical'; runtime would be faster if it were a direct reference, rather than a  string-indirect reference

[07:13] *** Jackneill joined
[07:13] <moritz> the nice thing is that with nom we have enough information at compile time to make such optimizations

[07:14] *** wamba joined
[07:14] <uvtc> Has compilation speed also increased approx 5x in nom? (Aside from execution speed.)

[07:14] <TimToady> it might once pmichaud++ finishes his qregex integration

[07:15] <sorear> if you manage to speed up compilation more than 2x I'll have major catching up to do :(

[07:15] <sorear> or is that :)?

[07:16] <TimToady> well, the choice is yours...

[07:16] <djanatyn> *yawn*

[07:16] <djanatyn> I'll be back tommorow.

[07:16] <TimToady> what TZ are you in?

[07:17] <djanatyn> See you guys, and thanks for the information :D

[07:17] <djanatyn> EST. It's 3:17am over here right now.

[07:17] <TimToady> yow

[07:17] <TimToady> good night

[07:17] <djanatyn> Also, my battery on the netbook is down to 10%.

[07:17] <Tene> Sleep well.

[07:17] <djanatyn> So, see you tommorow.

[07:17] <djanatyn> Thanks.

[07:17] <uvtc> Sounds promising. Gah, what am I doing up so late? Thanks for the info, all. (Can't find a "going to sleep unicode symbol ... improvising) ‚õ∫

[07:17] <Tene> Yeah, that netbook has a pretty small battery, iirc.

[07:17] <Tene> .u ‚õ∫

[07:17] <phenny> U+26FA (No name found)

[07:17] * TimToady won't be on tomorrow much; 12 hours of driving to get back home...

[07:18] <uvtc> U+26FA (TENT)

[07:18] <djanatyn> Tene: around 3 hours with the brightness down to the minimum value, it seems.

[07:18] *** uvtc left
[07:18] <Tene> ahh, I never tried turning down the brightness, I don't think.

[07:19] * TimToady should turn in soon too, being an old geezer

[07:20] <sorear> djanatyn: what, no AC adapter?

[07:21] <djanatyn> sorear: too lazy to get up

[07:21] * sorear dares not think how much energy his PC is using... "P4 Northwood, plugged in most of the time"

[07:21] * djanatyn usually uses his netbook in his bed

[07:21] <djanatyn> that way I can just tuck it away and fall asleep at 3am.

[07:22] <djanatyn> Or, I can chug nasty energy drinks that ruin my body and just continue to use it until I pass out :D

[07:22] <djanatyn> I'm all natural tonight.

[07:22] <sorear> my bed is 2 ft behind me.

[07:23] <sorear> good night, djanatyn

[07:44] *** timbunce joined
[07:46] <sorear> o/ timbunce

[08:06] *** JimmyZ left
[08:17] *** mattp_ joined
[08:23] *** Kivutarrr joined
[08:26] *** JimmyZ joined
[08:29] *** araujo joined
[08:29] *** araujo left
[08:29] *** araujo joined
[08:33] *** masak joined
[08:33] <masak> morning, #perl6.

[08:33] <sorear> o/ masak

[08:33] <mberends> greetings

[08:36] *** birdwindupbird joined
[08:39] <masak> shinobicl: hm, I'd suggest adding Duration to your DateTime, but... sometimes adding a fixed number of seconds is not what one wants. oftentimes it's more like "one month after this", or "three years prior to this", and the conversion isn't obvious.

[08:39] <masak> shinobicl: S32/Temporal is silent when it comes to such a class, mostly because we tried to be conservative at the time. I think there's room for one, though.

[08:39] <masak> biggest problem is that Duration is taken. :)

[08:42] <sorear> clearly, it should be DateTime::Duration *ducks*

[08:42] <masak> that's not half-bad, actually.

[08:43] <masak> because it is a duration of datetimes.

[08:47] *** masak left
[08:50] *** masak joined
[08:51] <masak> by the way, the assessment "only barely powerful enough to emulate a Minsky machine" will probably feature in the next Yapsi release announcement somehow. :)

[08:52] <moritz> what does "one year before 2012-02-29" mean?

[08:52] <moritz> or s/before/prior to/

[08:55] <masak> moritz: I would make it "2011-02-28", but YMMV. it doesn't follow algebraical laws, of course.

[08:55] <dalek> rakudo/nom: 8f3f2cb | moritz++ | src/core/terms.pm:

[08:55] <dalek> rakudo/nom: Merge pull request #31 from kboga/special-vars

[08:55] <dalek> rakudo/nom: 

[08:55] <dalek> rakudo/nom: $*PROGRAM_NAME

[08:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8f3f2cb921

[08:55] <masak> in particular, transitivity gets broken here.

[08:55] <moritz> nom: my @a = a => 1, b => 2; say @a.perl; say a.hash.perl; say @a.perl;

[08:55] <p6eval> nom: OUTPUT¬´Array.new("a" => 1, "b" => 2)‚ê§Could not find sub &a‚ê§current instr.: '_block1002' pc 161 ((file unknown):156) (/tmp/uREO7JGT99:1)‚ê§¬ª

[08:55] <JimmyZ> rakudo: multi sub infix:<april>(Int $day where { 0 < * < 31 }, Int $year){  return DateTime.new(:year($year), :month(4), :day($day));};  my $data = 2 april 2011

[08:55] <p6eval> rakudo 922500:  ( no output )

[08:56] <moritz> nom: my @a = a => 1, b => 2; say @a.perl; say @a.hash.perl; say @a.perl;

[08:56] <p6eval> nom: OUTPUT¬´Array.new("a" => 1, "b" => 2)‚ê§("a" => 1, "b" => 2).hash‚ê§Array.new("a" => 1, "b" => 2)‚ê§¬ª

[08:56] <masak> JimmyZ: that's a wicked infix :P

[08:56] <JimmyZ> rakudo: multi sub infix:<april>(Int $day where { 0 < * < 31 }, Int $year){  return DateTime.new(:year($year), :month(4), :day($day));};  my $data = 2 april 2011; say $data;

[08:56] <p6eval> rakudo 922500: OUTPUT¬´2011-04-02T00:00:00Z‚ê§¬ª

[08:56] <masak> JimmyZ++

[08:56] *** timbunce left
[08:56] <JimmyZ> masak:  I saw it  from http://gfldex.wordpress.com/2011/07/29/toying-with-time-in-perl6/

[08:57] <JimmyZ> gfldex++; actually

[08:57] <masak> ah. gfldex++

[09:00] <JimmyZ> make infix:<april> into S32 seems wicked 

[09:00] <JimmyZ> But I like the usecase

[09:03] *** timbunce joined
[09:07] *** mj41 joined
[09:10] * JimmyZ thinks the really reason that Perl6 use butterfly as mascot is Perl6 wants butterfly effect in the further ;)

[09:11] <masak> hah :)

[09:11] <masak> well, if a butterfly wing flap exhibits the butterfly effect, surely Perl 6 has done so now, many times over.

[09:12] <JimmyZ> but not big enough?

[09:12] <masak> well, the thing about big enough butterfly effects is that they still start small, because of their origin.

[09:13] * JimmyZ nods

[09:13] <masak> also, the thing about exponential growth is that most of it looks like relative standstill at a low level.

[09:16] <masak> bacteria grow in a vat, doubling every minute. it's full at 60 minutes. at 50 minutes, not even a thousandth is fill. at 59, already half.

[09:25] <jnthn> morning, #eprl6

[09:25] <jnthn> ...pre-coffee typing skills: not good

[09:26] <masak> jnthn! \o/

[09:26] <jnthn> masak! \o/

[09:27] <masak> weekend, bad enough weather, all-day hacking Perl 6. what more could you ask for? :)

[09:27] *** Mowah left
[09:27] * sorear can only hack in good weather

[09:29] <masak> do you go for design-mulling walks in bad weather?

[09:29] <sorear> in bad weather, I sleep, because I'll overheat if I do anything else

[09:30] <sorear> I need a better heatsink for my brain

[09:30] * jnthn cools his with cold beer from the fridge :)

[09:30] <jnthn> ...though not at this time of day :)

[09:31] <jnthn> oh heh, what a thing to wake up to...

[09:31] <jnthn> last night I left my debugger open, broken at a nom segfault.

[09:31] <masak> "good morning! regards, me from last night." :P

[09:32] <jnthn> yeah...last night me musta thunk I'd appreciate this somehow :P

[09:36] * sorear sleep

[09:37] *** Vlavv left
[09:38] *** im2ee joined
[09:39] *** im2ee left
[09:39] *** Vlavv_ joined
[09:39] *** im2ee joined
[09:41] *** im2ee left
[09:48] <masak> I want to talk more about $x."A::b"()

[09:48] *** Jackneill left
[09:49] <masak> specifically, what's A? I think that matters for the answer.

[09:50] <jnthn> To me that doesn't interpolate anything

[09:50] <masak> I've only ever used $x.A::b when A is a role whose .b method has been overridden by the class I'm just declaring.

[09:50] <jnthn> You can use it to get to parent classes too.

[09:50] <masak> I wouldn't mind if $x."A::b"() meant that.

[09:50] <jnthn> But iirc you can't use it for unrelated classes

[09:50] <masak> jnthn: ok, then I wouldn't mind if $x."A::b"() meant parent classes too.

[09:50] <masak> jnthn: right.

[09:50] <masak> and that's my point, I guess.

[09:51] <jnthn> masak: Well, I only don't find if it's the MOP that does it

[09:51] <masak> I'd like for it to mean the same. :)

[09:51] <jnthn> But the MOP just gets a string method name

[09:51] <jnthn> And I'd rather it didn't have to go parsing it every time.

[09:51] <JimmyZ> morning, jnthn

[09:51] <jnthn> hi, JimmyZ 

[09:51] <JimmyZ> hello

[09:52] <masak> jnthn: surely performance can't be the issue here -- the used has explicitly chosen to make an interpolated method call.

[09:52] <masak> user*

[09:52] <tadzik> good morning

[09:52] <masak> tadzik! \o/

[09:54] <jnthn> < jnthn> But the MOP just gets a string method name

[09:54] <tadzik> masak! \o/

[09:54] <jnthn> As in, it doesn't know it's interpolated 

[09:54] <jnthn> That currently all happens outside of the MOP

[09:54] <moritz> I think there are two questions we need to ask

[09:54] <jnthn> It just gets asked "here's a string method name, look it up"

[09:54] <jnthn> (Yes, we can do something different if need be.)

[09:54] <moritz> if :: is interpolated, how would I call a method with :: in its name?

[09:55] <moritz> (might be important for language interop)

[09:55] <moritz> and if it's not interpolated, how do I call $obj.Class::$computed_name()

[09:55] <moritz> ?

[09:55] <jnthn> moritz: I think that's why we looked at putting the handling in the meta-object

[09:56] <masak> actually, the syntax $x.A::$method() should probably work too, yes.

[09:56] <jnthn> moritz: $obj.$(Class.^find_method($computed_name))

[09:56] <masak> std: my $obj; my $computed_name; class Class {}; $obj.$(Class.^find_method($computed_name))

[09:57] <p6eval> std 516268a: OUTPUT¬´ok 00:01 121m‚ê§¬ª

[09:57] <moritz> masak: if so, either $x.A::"$method"() or $x.A::($methodname)()

[09:57] <masak> moritz: oh! right. meant the former.

[09:58] <masak> I found an interesting (ex-)exploit in SOAP::Lite yesterday based exactly on the Perl 5 handling of interpolated method calls.

[09:58] <jnthn> nom: class A { method m() { 1 } }; class B is A { method m() { 2 } }; my $obj = B.new; say $obj.$(A.^find_method('m'))()

[09:58] <p6eval> nom: OUTPUT¬´Non-declarative sigil is missing its name at line 1, near "$(A.^find_"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[09:58] <jnthn> aww

[09:58] <masak> so it was amusing to me to see them brought up in the backlog, too.

[09:58] <masak> thinking of blogging about that exploit; it was so exquisite :)

[09:59] <masak> also, at some point I'll be making a talk called "Exploit-driven development" :)

[09:59] <jnthn> Anyway, in general I'd give -1 to re-parsing interpolated strings.

[09:59] <jnthn> (as method names)

[10:00] <jnthn> And we find a proper interpolation syntax - or tell people to go play with the MOP - if they want to other thing.

[10:01] <masak> jnthn: what was it about the parsing of the "A::b" that you didn't like? I'm not sure I grok'd.

[10:03] <jnthn> masak: We probably agree the parser can't handle it (or we break interop), so then the MOP has to, which means that for efficiency it in turn needs to know when it has a call it has to parse, so that's another extension there. And quotes don't normally make :: mean anything, so we'd be giving them extra semantics just in one context.

[10:04] <jnthn> Getting the MOP to do string parsing inside of it also feels icky. It's not really its job.

[10:04] * moritz agrees with jnthn++ after reading these points

[10:04] <jnthn> We've gone to lengths in Perl 6 to stop making everything type-y be about strings. Parrot still suffers from a legacy of doing so.

[10:05] <masak> ah, that last point I can appreciate.

[10:05] <masak> "don't put magic behaviour into mere strings".

[10:05] <jnthn> I'd rather we find a way to make something like $obj.A::($m_name)() work if we want short syntax for this.

[10:06] <masak> essentially, mere strings being too magical form both of the steps in the SOAP injection attack we talked about yesterday.

[10:06] <masak> jnthn: agreed.

[10:06] <jnthn> Indeed.

[10:06] <jnthn> I'd rather people only have to worry about mere strings going boom on them in a small number of places. e.g. eval.

[10:07] <moritz> speaking of injection attacks

[10:07] <masak> that said, having pipes in &open is a wicked cool thing. I'd like to have something similar in Perl 6 :)

[10:07] <moritz> I love it that nom makes built-in types inheritable

[10:07] <moritz> so I can do thing like

[10:07] <jnthn> inheritable?

[10:07] <moritz> class HTMLStr is Str { }

[10:07] <masak> o.O

[10:07] <jnthn> We couldn't do that in master?

[10:07] <masak> decidedly not.

[10:07] <jnthn> oh.

[10:08] <moritz> and then I can write a template system that automatically escapes Str, but not HTMLStr

[10:08] <moritz> jnthn: how would you instantiate that in master?

[10:08] <masak> :P

[10:08] <jnthn> moritz: How do you do it in nom? :)

[10:08] <moritz> jnthn: pir::repr_box_str($source, HTMLStr)

[10:08] <jnthn> oh, using the op

[10:08] <jnthn> OK :)

[10:08] <masak> eeew.

[10:09] <jnthn> Was gonna say... :)

[10:09] <moritz> it might need a better API someday :-)

[10:09] <jnthn> s/might/will/ :)

[10:09] <moritz> but if it allows me to get rid of XSS in my templates I'm willing to go with the ugly API for now :-)

[10:09] <masak> my mini-challenge still stands: http://irclog.perlgeek.de/perl6/2011-07-29#i_4187188

[10:09] <masak> no-one has stepped up to the challenge yet. :)

[10:09] * jnthn cooks bacon and ponders how to refactor static lexpads

[10:10] * moritz creates a mini-challenge to masak: motiviate people to participate in your mini-challenge!

[10:10] *** birdwindupbird left
[10:10] * masak read that as "jnthn ponders how to bacon static lexpads" and rubs eyes

[10:10] <moritz> jnthn: isn't bacon better fried?

[10:10] <jnthn> fry ~~ cook, no? :P

[10:10] <moritz> I mean, cooked bacon... come on

[10:11] * jnthn is going to fry it :)

[10:11] <moritz> jnthn: might be a language barrier thing

[10:11] <jnthn> moritz: I suspect so :)

[10:11] <masak> moritz: I would've thought the price of one beer would be enough motivation. of course, there's also plenty of prestige involved. :P

[10:11] <jnthn> I consider "cook" as generic. "fry" is just an implementation of that :)

[10:11] <moritz> to me there's a difference between "prepare a meal" and "cook a meal"

[10:11] *** amkrankruleuen joined
[10:12] <moritz> and fry ~~ prepare, but fry !~~ cook

[10:12] <masak> I think moritz thinks cook === boil.

[10:12] <moritz> ah yes

[10:12] <masak> not so.

[10:12] <masak> boil ~~ cook, but cook !~~ boil.

[10:13] <jnthn> then I see the confusion

[10:13] <jnthn> wtf, you can boil bacon?!

[10:14] * jnthn never tried that but doesn't really want to either

[10:14] <masak> *lol*

[10:14] <moritz> you can boil anything that fits into a pot and doesn't evaporate too soon

[10:17] <masak> TimToady: [‚à™] <foo bar baz>

[10:17] <masak> TimToady: it's perfect :)

[10:17] <masak> (also, I guess, it's synonymous to 'set <foo bar baz>') :)

[10:20] <tadzik> why is token comment:sym<#=(...)> "(...)" (whatever that means), and accepts a <quote_EXPR>?

[10:20] <masak> djanatyn: hi! welcome!

[10:21] <moritz> tadzik: the sym:<...> can contain any thing

[10:21] <moritz> tadzik: and only if you use <sym> in the regex, it gains some meaning

[10:22] <moritz> tadzik++ # https://gist.github.com/1114044

[10:23] <tadzik> moritz: there are tests for that now :)

[10:23] <tadzik> very basic yet, https://github.com/rakudo/rakudo/blob/podparser/t/pod/why.t

[10:23] <moritz> \o/

[10:24] <tadzik> documenting routines gives a segfault so far, but jnthn++ is onto that. I'm now investigating the variables case

[10:25] <masak> oh, TimToady agrees in the backlog with what moritz, jnthn and I just painstakingly reasoned ourselves towards with the MOP not interpolating method names with "::" in them :)

[10:25] <masak> TimToady++

[10:26] *** nymacro left
[10:31] <jnthn> tadzik: I didn't do variable traits just yet, I'm afraid.

[10:31] <tadzik> jnthn: attributes documenting will be trate-ish too, si?

[10:31] <tadzik> okay, still on the roadmap?

[10:31] <jnthn> tadzik: Probably can be

[10:31] <jnthn> Attribute traits already work.

[10:31] <tadzik> okay

[10:31] <jnthn> It's only variable ones that are missing.

[10:32] <jnthn> Yes, you should be able to mix into Attribute.

[10:32] <tadzik> I can probably wait for them, no problem with that

[10:38] <moritz> I suspect in the long run .WHY wants to return something Pod::-ish

[10:38] <moritz> so that you can say

[10:38] <moritz> #= B<fast> implementation of the fourier transform

[10:40] <masak> agreed. as long as there is also a reasonable way to get a text-only form.

[10:41] <tadzik> moritz: once pod_string is there (so: formatting codes are done), .WHY will probably use those and return arrays, yes

[10:42] *** JimmyZ_ joined
[10:44] <moritz> masak: there's always .Str and .gist

[10:45] *** JimmyZ left
[10:45] <tadzik> it still bothers me that every string that we have in $=POD now will end up being an array of some sort

[10:45] *** JimmyZ_ is now known as JimmyZ

[10:46] <moritz> does it have to be?

[10:47] <tadzik> I worry that bringing something like "it's an array, unless when it isn't" will bring more harm than good to parsing and to processing later

[10:47] <tadzik> maybe not

[10:47] <moritz> in Haskell terms, we could write  PodStr = Str | List[chunks]

[10:48] <moritz> dunno if something can be accomplished sanely in p6

[10:48] <masak> tadzik: ah -- the name of that "data structure", apparently, is "twine".

[10:48] <tadzik> oh?

[10:48] <masak> tadzik: not "rope" as I claimed.

[10:48] <masak> tadzik: see XML::Easy and subclasses for the use of it.

[10:48] <masak> it occurs often enough in these kinds of hierarchical-text use cases.

[10:49] *** MayDaniel joined
[10:49] * masak goes hunting for bacon &

[10:49] * tadzik reads https://metacpan.org/module/XML::Easy::NodeBasics#Twine

[10:52] <moritz> wow, planet.haskell.org has sent more vistors to perl6.org than planetsix.perl.org

[10:53] *** molaf left
[10:53] <TiMBuS> * sorear wonders if ithreads will be part of Perl 6

[10:54] <TiMBuS> :/

[10:54] <TiMBuS> id prefer not...

[10:54] <moritz> and the features page has had > 4k visitors

[10:58] *** Instil left
[11:01] *** Instil joined
[11:22] *** Jackneill joined
[11:31] *** DarthGandalf left
[11:37] <masak> moritz: was it au++'s translation of TimToady's Dec 24 post to ‰∏≠ÂúãÂÇ≥Áµ±? that's the only reference to perl6.org on planet.haskell.org that I find.

[11:43] <dalek> features: 5ca311b | masak++ | features.json:

[11:43] <dalek> features: [features.json] reordering

[11:43] <dalek> features: 

[11:43] <dalek> features: sin, .pick, and .fmt aren't really operators, they're built-ins.

[11:43] <dalek> features: review: https://github.com/perl6/features/commit/5ca311b2b1

[11:57] *** timbunce left
[11:57] *** timbunce_ joined
[11:58] <TiMBuS> is there a reason hashes in perl6 arent just bags containing pairs? too much breakage?

[12:00] *** timbunce_ left
[12:00] *** timbunce joined
[12:09] <masak> TiMBuS: I don't think Bags do what you think they do.

[12:10] <masak> TiMBuS: a hash cannot contain the same key twice. a Bag is like a Set, except that it can contain multiple copies of the same element.

[12:14] <TiMBuS> whu

[12:14] <TiMBuS> oh

[12:14] <TiMBuS> well then, a set

[12:30] <masak> a Set could still contain two distinct Pairs with the same key; a Hash can't.

[12:30] *** MayDaniel left
[12:34] <masak> niecza: class C { has $.x }; (my %h){C.new(:x(42))} = "OH HAI"; say %h.perl

[12:34] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´{"C()<instance>" => "OH HAI"}.hash‚ê§¬ª

[12:35] <dalek> features: 56279ad | masak++ | features.json:

[12:35] <dalek> features: [features.json] added hashes with non-str keys

[12:35] <dalek> features: review: https://github.com/perl6/features/commit/56279ad672

[12:35] <masak> hm, but that test for Niecza was unfair, I realize.

[12:35] <masak> (becuase Str is the default)

[12:36] *** Chillance joined
[12:36] <masak> niecza: class C { has $.x }; (my C %h){C.new(:x(42))} = "OH HAI"; say %h.perl

[12:36] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´{"C()<instance>" => "OH HAI"}.hash‚ê§¬ª

[12:36] <masak> niecza: class C { has $.x }; (my C %h){C.new(:x(42))} = "OH HAI"; %h{C.new(:x(5))} = "OH NOES"; say %h.perl

[12:36] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´{"C()<instance>" => "OH NOES"}.hash‚ê§¬ª

[12:36] <masak> right.

[12:37] *** wamba left
[12:49] <flussence> did that qregex stuff happen yet?

[12:50] <jnthn> flussence: The "get nqp and Rakudo parsed using it" stuff? No, sadly not yet.

[12:50] <flussence> aww

[12:51] <jnthn> On features, nom now has currying

[12:51] <jnthn> (We runn the same .assuming tests as master)

[12:52] <flussence> Files=313, Tests=8899!

[12:52] <jnthn> \o/

[12:52] <jnthn> We can break 9000 today I expect.

[12:52] <jnthn> Anyone who wants to help with that, there's some LHF in the LHF.markdown ;)

[12:53] <masak> rakudo: say trim "   foo  "

[12:53] <p6eval> rakudo 922500: OUTPUT¬´foo‚ê§¬ª

[12:53] <flussence> perl6: 'a,b' ~~ /<?after ','>/; # this work yet?

[12:53] <p6eval> niecza v8-4-g2c56dcb:  ( no output )

[12:53] <p6eval> ..rakudo 922500: OUTPUT¬´Method 'after' not found for invocant of class 'Cursor'‚ê§  in <anon> at line 22:/tmp/OPeNdw7K2c‚ê§  in 'Cool::match' at line 2684:src/gen/core.pm‚ê§  in 'Regex::ACCEPTS' at line 6418:src/gen/core.pm‚ê§  in main program body at line 1:/tmp/OPeNdw7K2c‚ê§¬ª

[12:53] <p6eval> ..pugs: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HANDLE>' trapped b‚Ä¶

[12:54] <flussence> nom: 'a,b' ~~ /<?after ','>/;

[12:54] <p6eval> nom: OUTPUT¬´Method 'after' not found for invocant of class 'Cursor'‚ê§current instr.: '_block1010' pc 445 ((file unknown):25669379) (/tmp/dzEYHHDxws:1)‚ê§¬ª

[12:55] <tadzik> wow, so podparser is on 8900! :)

[12:55] <jnthn> tadzik: You've been working ALL SUMMER and you only pass one extra test?!?! :P

[12:56] <jnthn> (teasing, of course :))

[12:56] <jnthn> tadzik: I'm guessing a bunch of the other tests you have a spectest material eventually, though?

[12:56] <jnthn> tadzik: I mean, we'd need tests for $=POD and .WHY and so on.

[12:57] <tadzik> probably, the t/pod stuff

[12:58] <tadzik> more tests are working, podparser on master did pass some todos rakudo didn't

[12:58] <jnthn> ah, ok

[12:59] <tadzik> I guess they're yet commented out in nom

[13:00] <flussence> er... in src/core/Any.pm:166, are infix:<min> and infix:<max> really supposed to be identical?

[13:00] *** Reaganomicon left
[13:00] <jnthn> nom: say 1 min 2; say 1 max 2;

[13:00] <p6eval> nom: OUTPUT¬´1‚ê§1‚ê§¬ª

[13:00] <jnthn> bwaha

[13:00] <jnthn> flussence: no :)

[13:01] <jnthn> Fixing :)

[13:01] <masak> let's see... 'given' is a topicalizer but not a loop, right?

[13:01] <masak> so, specifically, I can't 'redo' one, right? :)

[13:01] <jnthn> masak: afaik, no

[13:02] <jnthn> masak: Use for item ... :)

[13:02] <masak> perl6: given "OH HAI" { .say; redo }

[13:02] <p6eval> rakudo 922500: OUTPUT¬´OH HAI‚ê§  in <anon> at line 22:/tmp/Zb1m4DeNh1‚ê§¬ª

[13:02] <p6eval> ..pugs: OUTPUT¬´OH HAI‚ê§*** Cannot use this control structure outside a 'loop' structure‚ê§    at /tmp/uJZZXqeEXR line 1, column 24-29‚ê§¬ª

[13:02] <p6eval> ..niecza v8-4-g2c56dcb: OUTPUT¬´OH HAI‚ê§Unhandled exception: Illegal control operator: redo‚ê§  at /tmp/rB9D6ktKro line 1 (MAIN mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1933 (CORE C906_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1934 (CORE module-CORE @ 56) ‚Ä¶

[13:02] *** thundergnat left
[13:02] <masak> implementations agree. also, Rakudo master LTAs.

[13:02] <masak> nom: given "OH HAI" { .say; redo }

[13:02] <p6eval> nom: OUTPUT¬´OH HAI‚ê§Warning‚ê§¬ª

[13:03] * masak shys back

[13:03] <masak> won't do it again, I promise!

[13:03] <jnthn> :P

[13:03] <jnthn> Should be improved really.

[13:04] * masak suddenly imagines the nom branch as a stern robot nanny

[13:04] *** soh_cah_toa joined
[13:04] <masak> soh_cah_toa: every time you join the channel, I get a little bit of repetition in trigonometry. :)

[13:04] <masak> soh_cah_toa++

[13:04] <soh_cah_toa> ha!

[13:05] <jnthn> OK, time to redesign static lexpads...

[13:08] <tadzik> I don't get the trigonometry joke

[13:09] <soh_cah_toa> tadzik: soh cah toa is a mnemonic for remebering trig functions

[13:09] <TiMBuS> he probably knows that, i think hes just being obtuse..

[13:11] <soh_cah_toa> ah ;)

[13:12] <masak> TiMBuS: no, it might simply be that it's not widespread in Poland.

[13:12] <tadzik> no, I don't know that mnemonic! :)

[13:12] <masak> it's not widespread in Sweden.

[13:12] <soh_cah_toa> tadzik: soh = sin is opposite of hypotenuse, cah = cosine is adjacent of hypotenuse, toa = tangent is adjacent over hypotenuse

[13:12] <soh_cah_toa> s/of/over/

[13:12] <tadzik> hmm, interesting ;)

[13:12] * flussence just discovered tools/progress-graph.pl

[13:13] <masak> I had an easier time in school with trig than most people seem to have had. much thanks to BASIC, where I had already explored and understood the behaviour of sin/cos/tan et al.

[13:14] <soh_cah_toa> trig itself is easy. trig + calculus is not

[13:14] <soh_cah_toa> for me anyways...

[13:15] <TiMBuS> i was just being punny. sorry, didnt mean to send the chat off into a different tangent

[13:15] <masak> enough "fooling around" with what I later learned was called "differential equations" in BASIC taught me how these trig functions essentially fall out of equations involving derivatives.

[13:15] <masak> TiMBuS: ah! both puns belatedly appreciated :P

[13:16] * soh_cah_toa shudders when he hears the word "differentials"

[13:16] <masak> maybe I should make a few blog posts sometime about how fooling around with things like $Œîx = $y; $Œîy = -$x; can give a greater understanding of math.

[13:16] <masak> soh_cah_toa: they weren't real differentials, just discrete approximations, as above.

[13:17] <soh_cah_toa> yeah

[13:17] <masak> but such blog posts would really need to be tied to some maths package or other.

[13:17] <masak> hmmm, Perl 6 + Paper.js... :)

[13:18] <jnthn> Paper.js?

[13:19] <jnthn> oh, neat

[13:19] <jnthn> :)

[13:20] <masak> yes!

[13:20] *** MayDaniel joined
[13:21] <jnthn> That Keyboard Interaction example looks, er.. :)

[13:21] * jnthn goes back to his lexical refactors :)

[13:22] <masak> jnthn: a lot of little animals look like sperm. :)

[13:22] <masak> sorear: I want to use Niecza v8. was there ever a point release or something to the reported build problems of niecza-v8? I see nothing on the github repo page.

[13:23] <jnthn> masak: Heh, at least it wasn't just me who thought it looked like that :P

[13:26] *** mj41 left
[13:27] <masak> sorear: nvm, Niecza 8 works fine here. sorear++

[13:27] *** JimmyZ left
[13:27] <masak> jnthn: I did think that, yes. but even if I hadn't, I'd probably'd been able to guess what you thought it looked like. :P

[13:29] <dalek> roast: f555c5c | moritz++ | / (7 files):

[13:29] <dalek> roast: rakudo unfudges

[13:29] <dalek> roast: review: https://github.com/perl6/roast/commit/f555c5cd1f

[13:29] <tadzik> I feel a sudden need for a huge, magnetic whiteboard for my room

[13:29] <masak> tadzik: whiteboards suck. get yourself a blackboard.

[13:29] <masak> niecza: sub foo { -> { foo } }; say foo()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

[13:30] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´Block()<instance>‚ê§¬ª

[13:30] <masak> niecza++

[13:30] <tadzik> masak: you think so?

[13:30] <tadzik> but where do I buy white markers then? :)

[13:31] <jnthn> Chalk!

[13:31] <masak> tadzik: in my last $owrkplace, our office was the only one with a blackboard -- because we specifically asked for one when we moved.

[13:31] <tadzik> why do you prefer blackboards?

[13:31] *** JimmyZ joined
[13:32] <masak> because the relative net "convenience" gotten from whiteboards is negative.

[13:32] <jnthn> masak: Less chalk dust everywhere is negative? :)

[13:32] <tadzik> I don't get it

[13:32] <masak> jnthn: if you get chalk dust everywhere, your doin it rong.

[13:32] <masak> also, chalk dust is nothing compared to the failure modes of whiteboard markers.

[13:33] <masak> you can always trust a piece of chalk.

[13:33] <masak> the same cannot be remotely said of a whiteboard marker.

[13:33] <soh_cah_toa> what does that -> syntax do when it's the first argument of a subroutine? like `grep(-> $_ {self.HOW.can(self, $_)}`

[13:33] <masak> then there's the failure modes of the whiteboard itself.

[13:33] <masak> soh_cah_toa: the -> makes the {} not execute there and then.

[13:34] <masak> soh_cah_toa: rather it's used as a value.

[13:34] * tadzik -> STORE

[13:34] <jnthn> masak: Whatever happened between you and a whiteboard to make you so bothered about them? :)

[13:34] <masak> soh_cah_toa: the variable(s) after the -> but before the {} are parameters, like to a sub.

[13:34] <masak> jnthn: nothing in particular. just thousands of small incidents.

[13:35] <soh_cah_toa> parameters to the { } block?

[13:35] <masak> jnthn: are you seriously telling me you've never put a marker to a whiteboard, only to discover they're "incompatible" and the pen was really meant for paper, and the whiteboard will now have to be cleaned with alcohol because the markings just won't come off? :(

[13:35] <jnthn> nom: my $a = -> $b, $c { say "$b and $c" }; $a(1,2)

[13:35] <p6eval> nom: OUTPUT¬´1 and 2‚ê§¬ª

[13:35] <masak> soh_cah_toa: exactly.

[13:36] * soh_cah_toa ponders this

[13:36] <jnthn> masak: No, but I agree it's a waste of alcohol.

[13:36] <masak> jnthn: it's a waste of everything.

[13:36] <masak> jnthn: there are no "incompatible" pieces of chalk.

[13:36] <masak> there are no blackboards that can't be cleaned.

[13:37] <masak> the proverbial tabula rasa must've been a blackboard :P

[13:39] <soh_cah_toa> masak: are there any docs or maybe a blog that describe the -> ? i sorta understand your example but not the grep() one

[13:41] <masak> soh_cah_toa: well, S06 probably mentions it.

[13:41] * soh_cah_toa looks

[13:41] <masak> soh_cah_toa: the grep() example looks odd to me too :)

[13:42] <moritz> soh_cah_toa: -> $x { ... }  is nearly the same as  sub ($x) { ... }

[13:42] <masak> soh_cah_toa: it seems to grep out the method names that self can do from some list or other.

[13:42] <moritz> ie the -> introduces a signature, and the whole thing is a "block", which is something like a small subroutine

[13:43] <jnthn> If it helps, read -> as "lambda"

[13:43] <soh_cah_toa> what's the advantage over just doing sub ($x) { }?

[13:44] <jnthn> soh_cah_toa: It's transparent to return, plus a bit shorter.

[13:44] <jnthn> It can also go anywhere a block can

[13:44] <moritz> there are other differences

[13:44] <jnthn> Which isn't true of a sub.

[13:44] <moritz> for example only subs have separate $/ and $! variables

[13:44] <jnthn> That also.

[13:44] <moritz> so those in blocks are shared with the outer sub

[13:45] <soh_cah_toa> what do you mean "transparent to return"?

[13:45] <masak> soh_cah_toa: if you do 'return' in a -> {}, that block doesn't see the return.

[13:45] <masak> soh_cah_toa: instead, the surrounding sub does.

[13:46] <moritz> consider

[13:46] <moritz> sub f() { for @a -> $x { return if $x eq 3 } } 

[13:47] <masak> that's another point to consider, that the {} in a for loop are just "ordinary blocks", that can also accept a -> and parameters.

[13:47] <masak> that's one of my absolute favorite unifications of Perl 6.

[13:48] <masak> also, if statements. <3

[13:48] <moritz> if computation() -> $x { say "computation succeeded, $x was the return value" }

[13:49] <moritz> nom: say (:5<x>).key

[13:49] <p6eval> nom: OUTPUT¬´Invalid character 'x' in number literal‚ê§current instr.: 'nqp;Perl6;Actions;_block1835' pc 31584 (src/gen/perl6-actions.pir:10597) (src/Perl6/Actions.pm:3669)‚ê§¬ª

[13:49] *** drbean left
[13:49] <moritz> nom: say (:a<x>).key

[13:49] <p6eval> nom: OUTPUT¬´a‚ê§¬ª

[13:49] <moritz> nom: say (:a<x>).value

[13:49] <p6eval> nom: OUTPUT¬´x‚ê§¬ª

[13:51] <soh_cah_toa> hmm...

[13:51] <soh_cah_toa> i don't see what's so special about the sub f() example

[13:52] <moritz> it just demonstrates that it makes sense for return() to be tied to subs intead of blocks

[13:53] <soh_cah_toa> ok

[13:53] <soh_cah_toa> and how does `if computation() -> $x` differ from `if $s = computation()` though?

[13:54] <masak> scoping.

[13:54] <masak> $x is bound to the insides of the if block. $s is visible outside it.

[13:54] <soh_cah_toa> ah, yes. right

[13:54] <masak> in a very real sense, $x doesn't "exist" unless the condition is true.

[13:55] <soh_cah_toa> oh interesting

[13:55] * moritz thinks he could use that in Str.match

[13:55] <masak> Ruby's syntax { |vars_here| ... } is more "honest" in the sense that it's clearer how the parameters are scoped.

[13:56] <soh_cah_toa> right

[13:56] <soh_cah_toa> alright, i think i understand a little

[13:56] <masak> soh_cah_toa++ # level up :)

[13:58] <soh_cah_toa> ah yes. the "pointy blocks" section in s06 does explain it. i always thought it was just a new syntax for the `for` loop

[13:59] <masak> right. the nice thing is how general it is.

[13:59] <masak> it's almost like you could take the -> {} part of a for loop and walk away with it :D

[14:00] <jnthn> Well, we kinda do at compile time :)

[14:00] <jnthn> It just becomes an argument to map.

[14:00] <masak> yeah :)

[14:00] <masak> "This Just In: Perl 6 Eliminates The For Loop"

[14:00] <soh_cah_toa> yeah, ok

[14:01] <soh_cah_toa> i kinda like that idea. cool

[14:02] <masak> perl6: say [+]($_ when $_ %% 3|5 for ^1000)

[14:02] <p6eval> rakudo 922500: OUTPUT¬´166838‚ê§¬ª

[14:02] <p6eval> ..niecza v8-4-g2c56dcb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse argument list at /tmp/7lym7ryYCc line 1:‚ê§------> [32msay [+]([33m‚èè[31m$_ when $_ %% 3|5 for ^1000)[0m‚ê§Couldn't find final ')'; gave up at /tmp/7lym7ryYCc line 1:‚ê§------> [32msay [+]($_ [33m‚èè[31mwhen $_ %‚Ä¶

[14:02] <p6eval> ..pugs: OUTPUT¬´*** ‚ê§    Unexpected "when"‚ê§    expecting operator, ":" or ")"‚ê§    at /tmp/6X5Se45YF9 line 1, column 12‚ê§¬ª

[14:03] <masak> niecza: say [+] ($_ if $_ %% 3|5 for ^1000)

[14:03] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´0‚ê§¬ª

[14:03] <masak> sorear: ^^

[14:03] <moritz> rakudo: ^1000 ==> grep 3|6 ==> [+] ==> say

[14:03] <p6eval> rakudo 922500: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "^1000 ==> "‚ê§¬ª

[14:07] <masak> that's seriously pretty.

[14:07] * masak thinks [==>] and his head asplodes

[14:08] <jnthn> rakudo: ^1000 ==> grep 3|6 ==> reduce &infix:<+> ==> say

[14:08] <p6eval> rakudo 922500: OUTPUT¬´any(3, 6)‚ê§¬ª

[14:08] <jnthn> er :)

[14:08] <masak> rakudo: ^1000 ==> grep * %% 3|5 ==> reduce &infix:<+> ==> say

[14:08] <p6eval> rakudo 922500: OUTPUT¬´(timeout)¬ª

[14:08] <masak> aww

[14:08] *** wamba joined
[14:09] <jnthn> nom:  ^1000 ==> grep * %% 3|5 ==> reduce &infix:<+> ==> say

[14:09] <p6eval> nom: OUTPUT¬´166838‚ê§¬ª

[14:10] <masak> '^1000 ==> grep { so $_ %% 3|5 } ==> reduce &infix:<+> ==> say' works locally.

[14:10] <masak> nom: ^1000 ==> grep { so $_ %% 3|5 } ==> reduce &infix:<+> ==> say

[14:10] <p6eval> nom: OUTPUT¬´499500‚ê§¬ª

[14:10] <masak> hm, but that's the wrong answer :)

[14:11] *** Jackneill left
[14:12] <masak> ah. there is some precedence problem in master.

[14:13] <masak> rakudo: ^1000 ==> grep * %% (3|5) ==> reduce &infix:<+> ==> say

[14:13] <p6eval> rakudo 922500: OUTPUT¬´(timeout)¬ª

[14:13] <masak> locally, 233168

[14:13] <masak> (!)

[14:13] * jnthn hands masak some parens :)

[14:15] <masak> rakudo: ^1000 ==> grep(* %% (3|5)) ==> reduce &infix:<+> ==> say

[14:15] <p6eval> rakudo 922500: OUTPUT¬´(timeout)¬ª

[14:16] <masak> still 233168.

[14:17] <jnthn> masak: Does nom get it right?

[14:20] <masak> nom: ^1000 ==> grep(* %% (3|5)) ==> reduce &infix:<+> ==> say

[14:20] <p6eval> nom: OUTPUT¬´(timeout)¬ª

[14:22] <masak> gives the same: 233168

[14:23] <masak> hey, maybe that *is* the right answer... :)

[14:23] <masak> rakudo: my $s; for ^1000 { if $_ %% 3 || $_ %% 5 { $s += $_ } }; say $s

[14:23] <p6eval> rakudo 922500: OUTPUT¬´233168‚ê§¬ª

[14:23] <masak> oh what do you know. :)

[14:24] <flussence> anyone know what commit the nom branch started at?

[14:24] * flussence wants to make a new docs/spectest-progress.csv

[14:25] <masak> flussence: bab8369282c1f58302e76d2101c20b9a449e64f9

[14:25] <masak> that's the first commit in the nom branch, from Feb 8 2011.

[14:27] <dalek> rakudo/nom: efb679b | jonathan++ | src/core/Any.pm:

[14:27] <dalek> rakudo/nom: Fix infix:<max> (flussence++).

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/efb679bd4f

[14:27] <dalek> rakudo/nom: 6846753 | jonathan++ | / (3 files):

[14:27] <dalek> rakudo/nom: Sketch out a StaticLexPad class.

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68467530c5

[14:27] <dalek> rakudo/nom: 5acf3d6 | jonathan++ | src/pmc/perl6lexinfo.pmc:

[14:27] <dalek> rakudo/nom: Add a way to associate a Perl 6 StaticLexPad object with the Perl6LexInfo (eventually, a chunk of Perl6LexInfo will go away, as we move the data it holds into StaticLexPad).

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5acf3d6e44

[14:27] <dalek> rakudo/nom: 33755a6 | jonathan++ | src/Perl6/SymbolTable.pm:

[14:27] <dalek> rakudo/nom: Sketch out static lexpad creation and block association; untested as of yet.

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33755a6256

[14:27] <dalek> rakudo/nom: cf45eac | jonathan++ | src/core/Any.pm:

[14:27] <dalek> rakudo/nom: Turns out Any.max was missing; add it.

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cf45eac603

[14:27] <jnthn> masak: heh, the document added int hat commit has muchly come true :)

[14:27] <masak> \o/

[14:28] * masak loves it when a plan comes together

[14:33] * jnthn hits an amusing circularity

[14:34] <jnthn> The setting imports a bunch of stuff from Perl6::Metamodel::BOOTSTRAP. One of them is now StaticLexPad. Apart from we need that to create a static lex pad in order to install the stuff we're importing. :)

[14:35] *** birdwindupbird joined
[14:36] <tadzik> well, that's like writing a Perl 6 compiler in Perl 6 :)

[14:36] <masak> well, duh :)

[14:36] <masak> oh come on, no-one would ever attempt THAT.

[14:36] <masak> :P

[14:37] * masak loves how bootstrapping never ceases to make his brain revolt a little

[14:39] *** Mowah joined
[14:43] * jnthn hopes a two-pass approach is enough to saw this one.

[14:46] <moritz> Ronja now tries to reach for the keyboard... don't be surprised if you read garbage from me occasionally

[14:46] <moritz> I mean, more often than usual :-)

[14:48] <masak> Ronja++

[14:48] <moritz> she level-ups quiet often these days :-)

[14:49] <tadzik> :)

[14:49] <tadzik> Ronja needs karma :)

[14:49] <tadzik> phenny: pl en "karma"?

[14:49] <phenny> tadzik: "karma" (pl to en, translate.google.com)

[14:50] <tadzik> it means "food" in Polish :)

[14:50] <moritz> she sure needs both :-)

[14:50] <tadzik> Ronja++

[14:51] <masak> phenny: en pl "food"?

[14:51] <phenny> masak: The en to pl translation failed, sorry!

[14:51] <masak> phenny: is it just me, or are you getting worse at translating?

[14:52] <tadzik> "food" was a second guess of google translate

[14:52] <tadzik> Dog Food was the next one :)

[14:53] <tadzik> it is more widely used as an animal kind of food, yes

[14:53] * masak .oO( you put your karma in your dogma? )

[14:55] * tadzik giggles

[14:56] <colomon> How's the module hacking coming?

[14:58] *** Tedd1 joined
[14:58] <tadzik> is it this weekend?

[14:59] <masak> supposed to be.

[14:59] <tadzik> /o\

[15:00] <tadzik> I thought this was going to be something just before the YAPC

[15:01] <masak> we could always do it twice. :)

[15:01] <masak> or simply save it till next weekend.

[15:01] <masak> something tells me that there's enough to do for two weekends...

[15:02] <jnthn> At the very least, it would be worth taking some of the key modules this weekend and seeing why they don't compile and/or work.

[15:02] <jnthn> And putting those things into nommap.

[15:02] <moritz> it's really, really hard to do that with a compiler tha can't be installed

[15:03] <tadzik> I suppose I can write a Pies implementation that would use the not-installed perl6

[15:03] <tadzik> then possibly we could automate the process, as emmentaller did

[15:04] <moritz> nonono

[15:04] <colomon> moritz: can't be installed in the sense that it cannot be run from any other directory?

[15:04] <moritz> making nom installable is the real fix

[15:05] <masak> +1

[15:05] <tadzik> I should still have the patch that made nom run when instlaled somewhere

[15:05] <tadzik> it broke running from within the build dir though

[15:05] <colomon> +1

[15:06] <colomon> actually, +100

[15:07] *** Mowah left
[15:09] *** birdwindupbird left
[15:10] <moritz> just tried it - nom's perl6 binary can't be run outside the build dir

[15:11] <moritz> I've tried to fix that in nom-install, but got stuck

[15:11] <colomon> anyone know how to set @path in niecza?

[15:14] <jnthn> moritz: Is there a branch with the latest effort on that?

[15:15] <moritz> jnthn: yes. nom-install.

[15:15] <jnthn> moritz: OK. I'm a bit consumed with the static lexpad stuff at the moment, but can try and look at that later.

[15:18] *** xinming_ joined
[15:19] *** Kivutarrr left
[15:21] *** xinming left
[15:28] <colomon> Hmmm: my @bin := $x, @xs Z?^ @bin;

[15:29] <colomon> doesn't seem to actually work in master

[15:30] <moritz> colomon: regarding your recent changes in roast: it would be more readable if you commit the generated files in a separate commit

[15:30] <colomon> moritz: good point

[15:32] *** MayDaniel left
[15:32] <flussence> argh, why doesn't `git rev-list bab836928..HEAD` DWIM?

[15:33] *** ash__ left
[15:33] <moritz> which part of it dosn't DWYW?

[15:34] <soh_cah_toa> <moritz> Eclesia: are these contracts more declarative (like types), or can they be arbitrary runnable code?

[15:34] <soh_cah_toa> <E

[15:34] <flussence> it doesn't start at commit bab836928 or anything even close

[15:34] <soh_cah_toa> what the heck? copy/paste error i guess

[15:34] <flussence> oh, maybe it does

[15:35] <flussence> I want a $start..$end, but it's giving me $start ^.. $end :(

[15:36] <moritz> so you must write it as bab836928^..HEAD :-)

[15:37] <flussence> doesn't seem to work :(

[15:38] <pmichaud> good morning, #perl6

[15:38] <flussence> maybe I'm just blind...

[15:38] <jnthn> morning, pmichaud  :)

[15:38] <dalek> rakudo/nom: 36d0329 | jonathan++ | src/Perl6/SymbolTable.pm:

[15:38] <dalek> rakudo/nom: Break import into a two-pass process to hopefully pre-empt a circularity problem.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36d0329b8a

[15:38] <dalek> rakudo/nom: 1e69c1e | jonathan++ | src/Perl6/Grammar.pm:

[15:38] <dalek> rakudo/nom: A little more circularity sawing in prep for the static lexpads refactor.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e69c1e14b

[15:40] <moritz> flussence: works here

[15:40] <moritz> flussence: note that the commit mentioned first is at the bottom

[15:40] *** tokuhirom left
[15:40] <flussence> yeah, but it's not.

[15:40] <flussence> I found a workaround anyway: bab836928~1..HEAD seems to show it

[15:40] *** tokuhirom joined
[15:40] <moritz> $ git rev-list bab836928^..HEAD|tail -n 1

[15:40] <moritz> bab8369282c1f58302e76d2101c20b9a449e64f9

[15:41] <pmichaud> commit 8f3f2cb looks wrongish

[15:41] <flussence> oh, it probably didn't work before because I was on the wrong branch

[15:42] <pmichaud> I don't think we can reliably grab $PROGRAM_NAME from the IGLOBALS ARGV LIST

[15:45] <pmichaud> http://gist.github.com/1115659

[15:45] *** tokuhirom left
[15:46] *** jimmy1980 left
[15:47] <masak> niecza: my ($a, $b) = 42, "OH HAI"; .say for ¬´foo $a $b¬ª

[15:47] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´foo‚ê§42‚ê§OH‚ê§HAI‚ê§¬ª

[15:47] *** jimmy1980 joined
[15:47] <masak> niecza++

[15:48] <masak> niecza: my ($a, $b) = 42, "OH HAI"; .say for ¬´foo$a bar$b¬ª

[15:48] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´foo42‚ê§barOH‚ê§HAI‚ê§¬ª

[15:48] *** molaf joined
[15:51] <dalek> features: 0fc8137 | masak++ | features.json:

[15:51] <dalek> features: [features.json] another one: interpolating word list

[15:51] <dalek> features: review: https://github.com/perl6/features/commit/0fc81372be

[15:52] *** Jackneill joined
[15:52] *** Jackneill left
[15:52] *** Jackneill joined
[15:52] <flussence> well, here's attempt 1: https://gist.github.com/1115667

[15:52] <flussence> (it doesn't seem to work yet)

[15:53] * mberends has just used Debian Testing to install Rakudo 2011.04 and Parrot 3.3.0 in less than a minute o/

[15:57] <moritz> pmichaud: agreed, it needs to work differently

[15:59] <moritz> presumably src/main.nqp or Perl6::Compiler must capture the program name somehow

[16:01] <shinobicl> hi

[16:01] <sjn> hi, shinobicl 

[16:01] <shinobicl> i'm still making my workdaycalendar class, but i would like some "ideas" about the implementation...

[16:02] <shinobicl> http://pastebin.com/m0pNn8qL

[16:03] <moritz> shinobicl: from the description it seems you're only dealing with days, so Date might be a simpler base than DateTime

[16:04] <shinobicl> ok, noted :) 

[16:04] <sjn> well, try implementing it. spec'ing the API is nice, but you should really try to _use_ it to figure out if it's any good. :)

[16:05] * sjn assumes that there's no code :-P

[16:05] <shinobicl> i wonder if a current_day attribute would be nice.. sou you could do $calendar++ and get the next workday from the current_day

[16:05] <shinobicl> yes, i have some code

[16:05] <shinobicl> but i'm a litle shy :D

[16:05] <moritz> shinobicl: well, you could have a Calendar and a Day object

[16:05] <shinobicl> thse functions are implemented and tested

[16:05] <moritz> so you can do $day++, not $calendar++

[16:06] <sjn> shinobicl: ah :)

[16:06] * sjn prefers reading code before any documentation, especially when it comes to Perl 6 

[16:07] <shinobicl> ok

[16:07] <shinobicl> give me a sec

[16:07] <shinobicl> https://github.com/shinobi/TaskScheduler

[16:07] <sjn> Perl 6 is so crazy easy to read, I'm beginning to doubt the usefulness of API documentation o_O

[16:09] <shinobicl> workday class.. mmm, But the calendar is the central part of all this. Maybe the calendar can generate Workday objects :). Those Workdays would still be bound to their parent Calendar

[16:11] <sjn> shinobicl: are you open for crazy suggestions, or does this code have to "stay nice" (no experimenting)? :)

[16:12] *** Mowah joined
[16:12] <shinobicl> i mostly want new questions to ask to the calendar :) (lines 63 - 65 in the README)

[16:13] <shinobicl> and crazy suggestions too :)

[16:13] <sjn> well, my first thought was that move_by could a multi method

[16:14] <shinobicl> but you can only move by an integer ammount

[16:15] <sjn> hm

[16:15] <shinobicl> that amount could be days or weeks or months but always integers

[16:15] <sjn> multi move_by (Second $seconds) {}

[16:15] <sjn> multi move_by (Minute $minutes) { ... }

[16:16] *** jaldhar left
[16:16] <sjn> multi move_by (Hour $hours) { ...¬†}

[16:16] *** jaldhar joined
[16:16] * sjn us just throwing out some ideas here

[16:16] <shinobicl> well... moving by anything less than a day of out of scope, i think.

[16:17] <shinobicl> one thing that worries me is, for example

[16:17] *** elledge joined
[16:17] <sjn> I see that you accept seconds as input

[16:18] <sjn> but you don't claim in the code that you can only move_by a minimum of 3600 seconds

[16:18] <sjn> 3600*24

[16:19] <shinobicl> oh, is the only way i know y can calculate the nexy day. COnverting date time to Instant and adding (or substracting) 3600*24 to that instant

[16:19] <sjn> shinobicl: are you trying to recreate another existing API, or are you free to change the API as you want?

[16:20] *** elledge left
[16:21] <shinobicl> i want to create a TaskScheduler than can be told "Run this task the 1st monday of the month ar certain time". This "Weekday calendar" is one part of that. So, as long as this Weekday calendar can support this, i have no problem changing anything

[16:21] <shinobicl> so, is free-to-change

[16:23] <shinobicl> right now, i want to do a function that can answer "How many workdays are until 2011-12-12"

[16:23] <shinobicl> and another that can answer "how many workdays until 3 months from $date"

[16:24] <shinobicl> in the latter, i have a problem, on how much days are 3 months. the workday closer to 90 natural days from now? or (as for today) should i try to reach October 28?

[16:25] <shinobicl> the question is a valid one... but i don't know which path to take to reach the "3 months from now"

[16:26] * sjn thinks shinobicl should try to model the basics first (Second, Minute, Hour, Day, Week, Weekday, Weekend, Month, Year)

[16:27] <sjn> when you have described the basics, you can add the custom stuff (e.g. LeapYear)

[16:27] <sjn> and when you have that ready, figuring out how many days a given month has, should be trivial (well, you should make that trivial, at least ;)

[16:27] <shinobicl> rakudo: say DateTime.^methods>>.name.perl

[16:27] <p6eval> rakudo 922500: OUTPUT¬´("new", "check-time", "now", "clone", "clone-without-validating", "Instant", "posix", "offset", "truncated-to", "whole-second", "in-timezone", "utc", "local", "Date", "Str", "perl", "is-leap-year", "days-in-month", "daycount-from-ymd", "ymd-from-daycount", "get-day‚Ä¶

[16:28] <shinobicl> DateTime has lots of that stuff done

[16:28] <sjn> great

[16:28] <shinobicl> rakudo: say Date.^methods>>.name.perl

[16:28] <p6eval> rakudo 922500: OUTPUT¬´("get-daycount", "new", "new-from-daycount", "today", "truncated-to", "clone", "succ", "pred", "Str", "perl", "is-leap-year", "days-in-month", "daycount-from-ymd", "ymd-from-daycount", "day-of-month", "day-of-week", "week", "week-year", "week-number", "weekday-of-m‚Ä¶

[16:29] <sjn> you're not using those, are you?

[16:29] <shinobicl> More than implementing all that stuff, is a matter on how to use it. Seconds, Minuts, Hours, Weeks... all that is done already by perl6 :)

[16:29] <shinobicl> haven't needed to use them, yet

[16:29] <shinobicl> except for day-of-week

[16:30] <sjn> well, that's because you're counting Integers, and calling them "seconds"

[16:30] <sjn> seems like you're not very keen on using other peoples code, perhaps? </wild-guess> :)

[16:31] <sjn> (sorry, I'm assuming a lot today :-P)

[16:32] <shinobicl> haha ok, no problem.... but why seconds... adding seconds is just a workaround. I just want to move by days. And skipping the non-working days when doing so

[16:32] <gfldex> DateTime does not provice much to work with dates, it's a (fairly wide) bridge between ISO time stamps and seconds since the unix epoch

[16:33] <shinobicl> brb soon!

[16:33] <sjn> shinobicl: I'm talking about seconds because you're already using them in your methods :-P

[16:33] <sjn> well, claiming to use them :)

[16:34] <gfldex> if you want to express 'DateTime(now) + 3 days' you have to build a new DateTime object

[16:35] <sjn> make a WorkDay class :)

[16:35] <sjn> and when you add any day to that, the result should be another WorkDay? :)

[16:36] <shinobicl> that's another thing. A workday can not exist without a calendar. So, maybe i should use the workdaycalendar as a workday generator. But, would be that useful? I already have a funtion that returns a datetime after adding or substracting a certaing ammount of workdays

[16:36] * sjn isn't entirely sure how to do that though. can operator overloading check the Types of it's operands?

[16:36] <dalek> rakudo/nom: 7e9102f | jonathan++ | src/Perl6/SymbolTable.pm:

[16:36] <dalek> rakudo/nom: Add new static lexpad handling in SymbolTable alongside the old, to start migrating from one to the other.

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7e9102f77b

[16:36] <dalek> rakudo/nom: 8489bbb | jonathan++ | src/pmc/perl6lexpad.pmc:

[16:36] <dalek> rakudo/nom: Start to prepare Perl6LexPad for using the new StaticLexPad for static lexical values and configuration, not Perl6LexInfo.

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8489bbb5fc

[16:36] <dalek> rakudo/nom: 4189ea6 | jonathan++ | src/pmc/perl6lex (2 files):

[16:36] <shinobicl> sjn: i think yes... 

[16:36] <dalek> rakudo/nom: Switch Perl6LexPad over to new static lexicals model. Seems to work.

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4189ea66e9

[16:36] <dalek> rakudo/nom: df5a10b | jonathan++ | src/pmc/perl6lexinfo.pmc:

[16:36] <dalek> rakudo/nom: Remove some now-unused properties in Perl6LexInfo.

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df5a10b20c

[16:37] <gfldex> DateTime got a .succ method

[16:37] <gfldex> you could subclass from DateTime and skip in the .succ method if you would return a day that's not a workday

[16:38] <sjn> shinobicl: If I were you, I'd start at the bottom, with the basics (WorkDay is a special kind Role for a Day, perhaps?) and then make a Calendar of that.

[16:38] <shinobicl> rakudo: my $D = DateTime.new(year=>2012,month=>12,day=>12); my $D2 = $D.succ; say $D.perl;

[16:38] <sjn> forget the Calendar for a while, until the basics are clear

[16:38] <p6eval> rakudo 922500: OUTPUT¬´Method 'succ' not found for invocant of class 'DateTime'‚ê§  in main program body at line 22:/tmp/18KZwLvSxr‚ê§¬ª

[16:38] <gfldex> then you can feed any function with workdays that would like to have DateTime

[16:39] <shinobicl> but without the calendar, there are not workdays. 

[16:39] <sjn> no, a without a _Day_ there's no _WorkDay_

[16:39] <gfldex> ohh, the .succ method is in Date, not DateTime

[16:40] <shinobicl> rakudo: my $D = Date.new(year=>2012,month=>12,day=>12); my $D2 = $D.succ; say $D.perl;

[16:40] <p6eval> rakudo 922500: OUTPUT¬´Date.new(2012, 12, 12)‚ê§¬ª

[16:40] <shinobicl> rakudo: my $D = Date.new(year=>2012,month=>12,day=>12); my $D2 = $D.succ; say $D2.perl;

[16:40] <p6eval> rakudo 922500: OUTPUT¬´Date.new(2012, 12, 13)‚ê§¬ª

[16:40] <shinobicl> :D

[16:40] <sjn> you absolutely must have a concept "Day" to be able to claim that there's something called "WorkDay"

[16:40] <shinobicl> sjn: is called "Date" :)

[16:40] <sjn> the Calendar is just a nice system on top of the days :)

[16:41] <sjn> to keep track of them

[16:41] <shinobicl> mmm

[16:41] <gfldex> sjn: i do not agree on that

[16:41] <gfldex> a calendar is a system that sits ontop of _irregular_ planet movement

[16:41] <sjn> remember, those cavemen 30000 years ago thought about "Days" waaay before they thought about "Caledars" :)

[16:41] <gfldex> it's more definition that anything else

[16:42] <sjn> Calendars*

[16:42] <gfldex> most Calendars invanted over the last 30000 are not used anymore

[16:42] <sjn> gfldex: sure, the Calendar concept has changed a lot through history

[16:43] <sjn> gfldex: you're missing my point :-P

[16:43] <sjn> gfldex: my point is that a Calendar is one (of many, asy you imply) way of keeping track of days and months and years and such

[16:44] <sjn> but whatever the Calendar is today, there's one thing that won't change: It consists out of Days

[16:45] <sjn> anyhoo, maybe this is a bit besides shinobicl's needs :-P

[16:46] <shinobicl> yes, i need to keep track of workdays. My TaskScheduler is intended to be for the "enterprise" :)

[16:46] <shinobicl> but i like the concept of WorkDay (or WorkDate?)

[16:46] <shinobicl> i'll see how it fits in my idea of the calendar

[16:50] <gfldex> it might very well be that a calendar that is consisting of days is over engeneering for a taskscheduler

[16:50] <gfldex> for the taskscheduler The Nextish Thing should be enough

[16:50] <shinobicl> all depend on what is needed to ask certain questions. 

[16:51] <shinobicl> im my taskscheduler, i shluld be able to say "run this task on the 1st monday of Jan, Feb and March" and have another secondary date to run. That might be "3 days from the previous try"

[16:52] <shinobicl> all this expresses in a xml

[16:52] <shinobicl> expressed*

[16:53] *** aindilis joined
[16:53] <shinobicl> well... going back to work, thanks for the feedback moritz, sjn and gfldex! :)

[17:00] <sjn> shinobicl: np :)

[17:02] *** soh_cah_toa left
[17:04] <dalek> rakudo/nom: d2676e8 | jonathan++ | src/ (2 files):

[17:04] <dalek> rakudo/nom: Stop generating a bunch of code that we no longer need after the static lexpad refactor.

[17:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2676e8704

[17:04] <dalek> rakudo/nom: 4655200 | jonathan++ | src/Perl6/SymbolTable.pm:

[17:04] <dalek> rakudo/nom: Now that we build the static lexpad up as we compile, we don't need to do re-install stuff in it at fixup time. This should be a modest win for run-immediately mode (not least because it results in a smaller PAST tree and less to do).

[17:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4655200e4d

[17:07] <djanatyn> *yawn*

[17:07] <djanatyn> good morning!

[17:08] <jnthn> morning djanatyn 

[17:09] <masak> djanatyn! \o/

[17:09] <djanatyn> masak: Hey!

[17:09] <djanatyn> I was reading about you last night!

[17:09] <djanatyn> I saw lots of perl 6 modules that I was checking out, and you were the face on the github page

[17:10] <masak> djanatyn: I was reading things you said in the backlog this morning! :)

[17:10] <masak> djanatyn: I like you already :)

[17:10] <djanatyn> oh, cool :D

[17:10] <djanatyn> well, I like myself too

[17:10] <djanatyn> but you seem pretty cool as well.

[17:10] <masak> steepest descent into the Perl 6 community in quite some time, I might say.

[17:10] <masak> congrats.

[17:10] <djanatyn> Really?

[17:10] <masak> yup.

[17:10] <djanatyn> I would thihk that people would be diving into the perl 6 community all the time.

[17:11] <masak> they do, but they usually nose around the edges of it for a while.

[17:11] <masak> sometimes for years.

[17:11] <djanatyn> the people at the IRC channel I hang out like to say that Perl 6 will be the best language ever...in ten years.

[17:11] <masak> depends on what you mean by "be".

[17:12] <masak> to me, it already is ;)

[17:12] <djanatyn> I dunno. 

[17:12] <djanatyn> I was kinda shocked at how slow hello world ran ;)

[17:12] <masak> that's not the language's fault, though.

[17:12] <masak> (and yes, that kind of reasoning sounds really phony until you've been around a while.) :P

[17:13] <masak> djanatyn: if you want a faster Perl 6 implementation, I suggest looking at Niecza.

[17:13] <djanatyn> Yeah, a lot of people suggested that.

[17:14] <djanatyn> Are perl 6 modules currently only usable on a specific implementation?

[17:14] <djanatyn> like, the HTML::Template module that I saw on github.

[17:14] *** birdwindupbird joined
[17:14] <masak> to a first approximation, yes.

[17:14] <djanatyn> Will that only work on parrot, or niecza too?

[17:14] <masak> but we're sort of building ourselves towards implementation independence.

[17:15] <masak> for smaller scripts, it's trivially true.

[17:15] <masak> for modules, it's harder.

[17:16] <dalek> rakudo/nom: 28424c4 | jonathan++ | src/Perl6/SymbolTable.pm:

[17:16] <dalek> rakudo/nom: Fix up usage of variables in BEGIN; should deal with the issue tadzik++ ran into recently.

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/28424c4891

[17:16] <masak> partly due to features being differently distributed between the impls; partly because of lowlevel "cheats" available on one VM and not another.

[17:16] <jnthn> tadzik: ^^ Nech sa p√°ƒçi. :-)

[17:17] * masak guesses "p√°ƒçi" is a sound loan

[17:17] <JimmyZ> ah... ./perl6 --setting=NULL --target=pir --output=src/gen/CORE.setting.pir src/gen/CORE.setting

[17:17] <tadzik> oh, cool!

[17:17] <JimmyZ> Segmentation fault

[17:17] <tadzik> Just when I finished winow√≥dka :)

[17:17] <jnthn> masak: literally, "let it please"

[17:17] <masak> oh!

[17:17] *** jack-ji joined
[17:17] <tadzik> not as in "patrzy?

[17:18] <masak> phenny: sk en "Nech sa p√°ƒçi."?

[17:18] <tadzik> "

[17:18] <phenny> masak: "Here you are." (sk to en, translate.google.com)

[17:18] <tadzik> o

[17:18] <tadzik> I mean, oh

[17:18] <JimmyZ> Segmenation fault on nom

[17:18] <jnthn> masak: Yeah, that's the main usage of it.

[17:18] <masak> jnthn: I thought it had to do with "patch". /me blushes

[17:18] <jnthn> masak: Often said by nice waitress who gives you your noms.

[17:18] <jnthn> masak: Hey! I don't pun *all* the time! :D

[17:19] <jnthn> masak: Though it...woulda been a good one. :P

[17:19] <masak> now I am disappoint. :P

[17:19] <masak> phenny: pl en "patrzy"?

[17:19] <phenny> masak: "looks" (pl to en, translate.google.com)

[17:20] <tadzik> that looked like "ah, see for yourself"

[17:20] <masak> phenny: sk en "Nech"?

[17:20] <phenny> masak: "May" (sk to en, translate.google.com)

[17:20] <masak> ah, as in "let".

[17:20] <jnthn> Right.

[17:22] <jnthn> OK, there's another slightly delicate last step in the static lexpad refactor, but I need a break first. :)

[17:23] <masak> djanatyn: so, what are your plans now? are you going to write something, or are you still in study-phase?

[17:23] <djanatyn> Well, probably the biggest thing that I've written in perl 5 was a kind of blog engine.

[17:23] *** alfplayer joined
[17:23] <pmichaud> blog engine!

[17:23] <masak> :)

[17:24] <masak> djanatyn: my blog engine is in Perl 6 :)

[17:24] <djanatyn> It took text files following a really simple syntax (title in the first line, tags in the second, etc.) and turned those into a fully working static website.

[17:24] <tadzik> I wrote mine in Dancer once, it had like 30 lines or so :)

[17:24] <djanatyn> I want to write it again, but this time in Perl 6 :D

[17:24] <tadzik> mine used mysql

[17:24] <djanatyn> tadzik: The only thing is, I want mine to be completely static.

[17:24] <djanatyn> Like the one I implemented in Perl 5.

[17:25] <tadzik> I see

[17:25] <djanatyn> I used the Template::Toolkit library for the perl 5 version.

[17:25] <djanatyn> I'll use HTML::Template for the perl 6 version :D

[17:26] <masak> mine is completely static.

[17:26] <masak> also, it's only 250 lines long.

[17:26] <djanatyn> Nice :D

[17:26] <djanatyn> mine is...well, let me check.

[17:26] <masak> https://github.com/masak/psyde/blob/master/psyde

[17:26] <djanatyn> I named it blackbox, but then remembered that was the name of a window manager >_>

[17:27] <tadzik> yes :)

[17:27] <djanatyn> https://github.com/djanatyn/blackbox

[17:27] <masak> name it blogbox :P

[17:27] <djanatyn> the actual perl script is 90 lines, 74 sloc

[17:27] <flussence> "soapbox"

[17:27] <djanatyn> and...the template is 22 sloc

[17:27] <masak> nice.

[17:28] <djanatyn> and the css file is 20 sloc :)

[17:28] <masak> mine's probably bigger :)

[17:28] <djanatyn> It's reaaaaaaaally kinda lame, though.

[17:28] <djanatyn> It only has support for one tag for each entry :D

[17:28] <masak> djanatyn: I think you're doing the right thing writing something in Perl 6, be it a blog engine or something else. that's the way to learn a language.

[17:29] <djanatyn> That's the main way I learned perl 6.

[17:29] <masak> oh, mine doesn't do tags at all.

[17:29] <djanatyn> I was...well, in a weird state of affairs last month. I spent a lot of the time just reading "Programming Perl" and not really writing anything.

[17:29] <flussence> (ok, I got this script working. 57 revisions done, about 1000 to go...)

[17:29] <djanatyn> So, then I just sat down and wrote a bunch of stuff later.

[17:30] <masak> :)

[17:30] <masak> djanatyn: it took me a long time to get to really start writing Perl 6. something like 4 or 5 years.

[17:31] <djanatyn> 4 or 5 years?

[17:31] <pmichaud> it's taken me 4 or 5 years to write perl 6 as well.  :-)

[17:31] <tadzik> years since?

[17:31] <djanatyn> Well, I'm guessing it wasn't as easy to write perl 6 back then compared to how it is now.

[17:32] <tadzik> writing was always easy. Now, executing...

[17:32] <djanatyn> And I wasn't really writing anything useful when I was 11 or 12 anyway :P

[17:32] <pmichaud> Me either.  I didn't start writing useful stuff until I was 15.  :P

[17:32] <djanatyn> Yeah, that's about the time that I started writing stuff.

[17:32] <tadzik> hmm

[17:32] <masak> tadzik: I consider my actual entry into the community to be ~2008. but I was lurking and sniffing around already in 2005.

[17:32] <tadzik> now, the definition of 'useful stuff' :)

[17:33] <djanatyn> https://github.com/djanatyn/roguelike/blob/master/main.c <-- this is the first cool thing I did :SD

[17:33] <pmichaud> tadzik: Yes, there are some people who might claim I've yet to write anything useful :)

[17:33] <djanatyn> I started writing a roguelike.

[17:33] <masak> ooh

[17:33] <tadzik> pmichaud: I'm just wondering what was the first useful thing I did write :)

[17:33] <djanatyn> You could walk around, bump into stuff, go to different levels, and collect gold that appeared randomly around the map

[17:33] *** alfplayer left
[17:33] <tadzik> I remember a paintbrush-like program written in middle school, but I didn'd allow you to save images

[17:33] <djanatyn> except sometimes the gold would cause segfaults, and once you went to a different level, you couldn't go back ;)

[17:34] *** Trashlord left
[17:34] <pmichaud> Other than the occasional game, the first useful set of things I wrote were accounting packages for my dad's business.  :)

[17:34] <pmichaud> converted a 4-day process into a 4-hour one :)

[17:34] *** JimmyZ left
[17:34] <colomon> :)

[17:34] <masak> nice.

[17:34] <masak> pmichaud: which language?

[17:35] <pmichaud> BASIC

[17:35] *** Trashlord joined
[17:35] <colomon> I wrote an amortization program for my dad's office.  BASIC, running on a CP/M system with 8 inch floppies.  :)

[17:37] <tadzik> hmm

[17:37] <pmichaud> My dad didn't want me to have a computer... he thought it would end up in the closet and never amount to anything useful. :-P

[17:38] <colomon> ah, my parents were very supportive.

[17:38] <djanatyn> My parents make it difficult for me to program :P

[17:38] <colomon> even got a Commodore 64 for us at the original price.  

[17:39] <pmichaud> well, he completely changed his tune once we had the accounting systems in place

[17:39] <djanatyn> I bet the only reason they let me write perl is because they saw me blessing some object :D

[17:39] <tadzik> mine set a rule for "no computer in the work week" The effect was that I rushed like crazy to do computer on the weekends, and I still feel the subconcious need to sit in front of the computer anytime possible :/

[17:39] <djanatyn> tadzik: my parents had the same rule

[17:39] <djanatyn> until I got a laptop and had to do homework with it :D

[17:40] <tadzik> :)

[17:40] <pmichaud> yeah, Perl is one of the few languages where blessings outnumber the curses.   Unless you consider the heavily punctuated syntax as a form of swearing.  :)

[17:40] <masak> I don't even notice the sigils anymore. nowadays I just see blonde, brunette, redhead...

[17:41] * pmichaud wonders about that mapping.

[17:41] *** jack-ji left
[17:41] <flussence> I didn't even have a PC until about 10 years ago... good thing I'm a quick learner I suppose.

[17:41] <masak> flussence: oh, you finished learning already? :P

[17:42] <flussence> nope, still catching up :)

[17:42] <tadzik> oh, the computer came early in here :) I remember drawing in paintbrush when being <=6 or so

[17:43] <tadzik> my sister's one. My sister's 18 years older than me :)

[17:44] *** clintongormley joined
[17:45] <tadzik> jnthn: still segfaults for me :/

[17:46] *** clintongormley left
[17:46] <tadzik> I'll paste a patch

[17:48] <tadzik> jnthn: https://gist.github.com/1115781

[17:48] <tadzik> the segfaulting code in a comment

[17:49] <tadzik> patch is against the current podparser branch

[17:50] <dalek> Heuristic branch merge: pushed 23 commits to rakudo/podparser by tadzik

[17:51] <jnthn> nom: sub foo { }; &foo does role { method WHY() { 'abc' } }; say &foo.WHY

[17:51] <p6eval> nom: OUTPUT¬´Rebuild in progress‚ê§¬ª

[17:53] <jnthn> That bit works here

[17:53] <jnthn> hm

[17:54] <tadzik> 0x00007ffff3e31000 in Rakudo_cont_decontainerize () from dynext/perl6_ops.so

[17:55] <sorear> good * #perl6

[17:56] <tadzik> hello sorear 

[17:56] *** kaare_ joined
[17:57] <masak> sorear! \o/

[17:59] <sorear> masak: my C %h declares a hash with Str keys and C values

[17:59] <sorear> masak: niecza's behavior on those tests was correct

[18:00] <masak> oh!

[18:00] <masak> my %h{C} declares a hash with C keys?

[18:01] <masak> hm, seems so.

[18:01] <masak> niecza: class C { has $.x }; my %h{C}; %h{ C.new(:x(42)) } = "OH HAI"; say %h.perl

[18:01] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Postconstraints, and shapes on variable declarators NYI at /tmp/9eqfZWwSKB line 1:‚ê§------> [32mclass C { has $.x }; my %h{C}[33m‚èè[31m; %h{ C.new(:x(42)) } = "OH HAI"; say %h[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /hom‚Ä¶

[18:02] <sorear> masak: what are you pointing me to 5h-ago?

[18:02] <masak> the fact that it gave 0 when Rakudo didn't?

[18:02] * masak checks

[18:03] <masak> yes, I think that should give a non-zero sum.

[18:03] <sorear> colomon: what do you mean by '@path'?

[18:04] <colomon>  sorear: Unhandled exception: Unable to locate module ABC::Header in @path

[18:04] <sorear> o/ djanatyn

[18:04] <colomon> I was just mucking about and trying to run the ABC module on niecza.

[18:05] *** Mowah left
[18:05] <colomon> should be working on $work instead, and then working on trig, but I got curious.  ;)

[18:07] <sorear> ah.  -Idir

[18:07] <colomon> Is that an upper case i there?

[18:07] <sorear> yes

[18:07] <colomon> groovy

[18:07] <colomon> sorear++

[18:07] <sorear> like the cc -I option

[18:07] * colomon nods

[18:10] *** envi left
[18:11] <djanatyn> hey sorear 

[18:13] <sorear> hi djanatyn

[18:14] <djanatyn> I'll be right back, gotta do some things first.

[18:14] <djanatyn> Then I want to get started on that Perl 6 static website generator.

[18:14] <tadzik> you may want to look at supernovus' whitenoise repo, maybe

[18:14] <tadzik> https://github.com/supernovus/whitenoise/

[18:16] <masak> huh. whitenoise and blackbox.

[18:16] <masak> obviously I should've named my blog software "greygoblin" :)

[18:22] <flussence> (on closer inspection, all this script's done is miscompile rakudo 100 times in a row...)

[18:22] *** pernatiy_ is now known as pernatiy

[18:27] <colomon> sorear: any quick guess why the line if %key_signature.exists($pitch<basenote>.uc) would fail?

[18:27] <colomon> Missing block at /Users/colomon/tools/ABC/lib/ABC/Grammar.pm line 144:

[18:27] <colomon> ------> ey_signature.exists($pitch<basenote>.uc)‚èè;

[18:28] <moritz> colomon: niezca uses %h{$key}:exists

[18:28] <masak> sorear: I want to use Niecza to parse Perl 6 code and operate its AST. would you recommend (1) writing an ordinary Perl 6 script that somehow reaches into Niecza and calls it, or (2) starting from Niecza itself and picking away compilation steps until I have what I need?

[18:28] <colomon> moritz: !!!!

[18:30] <masak> easier to see why when you realize that it's STD-based.

[18:30] <masak> whereas Rakudo is more "heavily STD-inspired".

[18:37] <sorear> niecza: my %key_signature; my $pitch; %key_signature.exists($pitch<basenote>.uc)

[18:37] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´Unhandled exception: Unable to resolve method uc in class Any‚ê§  at /tmp/vdiMeJOyuA line 1 (MAIN mainline @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1933 (CORE C906_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1934 (CORE module-CORE @ 5‚Ä¶

[18:37] <moritz> runtime error

[18:37] <moritz> whereas your error was a compile-time error

[18:37] <sorear> masak: hmm.  what kind of AST do you need?

[18:38] <sorear> colomon: the problem is the end-of-line }

[18:39] <sorear> colomon: lines 143-144 are parsed as $a ~= %b{$c}; if (%b.exists($c));

[18:39] <colomon> sorear: oh!

[18:39] <sorear> maybe an unspace would help

[18:42] <colomon> rewriting to if cond { block } looks like it works 

[18:44] <colomon> Hmmm, next issue is 

[18:44] <colomon> Two definitions found for symbol ::GLOBAL::ABC::Duration::&duration-from-parse

[18:44] <colomon>   first at ??? line ???

[18:44] <colomon>   second at ??? line ??? at /Users/colomon/tools/ABC/lib/ABC/Duration.pm line 10:

[18:44] <masak> I think any kind would be a really good start.

[18:44] <masak> sorear: for a couple years I've been looking for a realiable way to transform Perl 6 source to AST.

[18:47] *** molaf left
[18:48] *** wamba left
[18:49] <moritz> masak: what about viv?

[18:49] <moritz> masak: it seems to be as reliable as STD itself

[18:54] <masak> yes, mebbe.

[18:55] <masak> trick is to get the text output into Perl 6 somehow.

[18:55] <masak> is it still YAML 1.1?

[18:55] <moritz> it's called parsing

[18:55] <masak> moritz: yes, I've heard of it...

[18:56] <moritz> masak: it might be easier to patch viv to produce something that's easier to parse

[18:56] <moritz> masak: something like JSYNC

[18:56] <masak> mmm.

[19:02] <sorear> masak: to get a useful ASTification of files, you'll need a large chunk of niecza

[19:02] <sorear> mainly because of 'use'

[19:02] <masak> ah.

[19:02] <sorear> niecza's grammar alone can parse CORE.setting, but to parse *other* files, you need to reload the symbols

[19:03] <sorear> and there's messy integration between the grammar, the actions, and the metamodel in order to make stuff like pi + 2 work

[19:03] <sorear> the grammar has to call back into the compiler to find out that "pi" is a constant and doesn't take arguments

[19:04] <masak> *nod*

[19:04] <dalek> niecza: 0cd0f42 | sorear++ | / (3 files):

[19:04] <dalek> niecza: Name unification part 1, suboids use process_name

[19:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0cd0f42e3f

[19:07] <sorear> to answer your question, I'd start by copying src/niecza and src/NieczaCompiler.pm6, and try to hack NieczaCompiler.compile to add a "just return the parsed unit

[19:07] <sorear> " option

[19:09] <masak> thanks. I'll try that.

[19:13] <moritz> niecza: constant $x = 3 + 4; say $x

[19:13] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´7‚ê§¬ª

[19:13] <moritz> niecza: constant $x = 3 + 4; say $x; $x = 9

[19:13] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´7‚ê§Unhandled exception: assigning to readonly value‚ê§  at /tmp/t23WRGUb8e line 1 (MAIN mainline @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1933 (CORE C906_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1934 (CORE module-CORE @ 56) ‚ê§  at /h‚Ä¶

[19:14] <moritz> niecza: constant $x = 3 + 4; say $x; $x := 9

[19:14] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´7‚ê§¬ª

[19:14] <moritz> niecza: constant $x = 3 + 4; say $x; $x := 9; say $x

[19:14] <p6eval> niecza v8-4-g2c56dcb: OUTPUT¬´7‚ê§9‚ê§¬ª

[19:14] <moritz> that should be forbidden, no?

[19:15] <sorear> probably

[19:16] * moritz submits nieczabug

[19:16] <masak> moritz++

[19:17] *** Chillance left
[19:17] <moritz> RFC: I'd like to reduce the size of README, and move most of the installation instructions to a separate INSTALL file

[19:17] <moritz> (in rakudo, that is)

[19:18] <moritz> background is that in binary distributions that part is pretty much useless

[19:18] <masak> +1

[19:19] <moritz> I'll go ahead if I get another +1 from jnthn|pmichaud

[19:20] <sorear> Illegal redeclaration of symbol 'self' (see line 93) # aiiiiieeee

[19:22] <dalek> roast: 993a659 | moritz++ | S03-operators/assign.t:

[19:22] <dalek> roast: unfudge max= tests for rakudo, now that infix:<max> propelry works again

[19:22] <dalek> roast: review: https://github.com/perl6/roast/commit/993a65997c

[19:28] *** birdwindupbird left
[19:28] <jnthn> Now it shoots out the answer!

[19:29] <masak> with a twisting motion.

[19:33] *** nbrown joined
[19:34] <flussence> (I think I've got this thing to compile rakudo properly now, but at this rate it's probably going to be running for at least a week...)

[19:35] <moritz> flussence: what are you doing?

[19:36] <flussence> trying to get data from the nom branch to use tools/progress-graph.pl on

[19:36] <flussence> using this: https://gist.github.com/1115667

[19:36] <masak> rakudo: my $s = "zebras."; for ^5 { $s = [~] (my $p = <he she I you we they>.roll), " ", ($s eq "zebras." ?? "like" !! <think assume believe hope>.roll), ($p eq "he"|"she" ?? "s" !! ""), " ", $s }; $s.=ucfirst; say $s

[19:36] <p6eval> rakudo 922500: OUTPUT¬´He hopes you hope I believe they believe we like zebras.‚ê§¬ª

[19:36] <masak> :)

[19:37] *** soh_cah_toa joined
[19:37] <jnthn> mind = blown

[19:37] <masak> the plot got too thick, I guess.

[19:37] <jnthn> flussence: You could always just sample every n commits. :)

[19:38] <dalek> rakudo/nom: 7a3a394 | moritz++ | t/spectest.data:

[19:38] <dalek> rakudo/nom: more passing test files, jnthn++

[19:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7a3a394d4c

[19:38] <flussence> that'd probably be not quite as stupid as what I'm doing, yes :)

[19:38] <moritz> flussence: or let others do parts of the work for you

[19:40] <flussence> I suppose I don't *need* to do all these in sequence on one machine, the output file has commit IDs and their timestamps anyway

[19:41] *** Chillance joined
[19:42] <flussence> ooh, it actually produced one data point!

[19:43] <flussence> "2011-02-08 15:48:05",bab8369,17559,3106,583,20,21249,22014,544

[19:44] <jnthn> flussence: I guess that's before things were taken apart :)

[19:45] <moritz> looks like it :-)

[19:45] <flussence> hm, if I skip 40 commits or so, that should put me right into can't-run-any-spectests territory, that should be a lot faster...

[19:46] <moritz> it would indeed

[19:47] <dalek> niecza: 9a4bec8 | sorear++ | src/Niecza (2 files):

[19:47] <dalek> niecza: Use lower-level MOP routines for categoricals, not ::($name)

[19:47] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9a4bec87a9

[19:52] *** nbrown left
[19:52] *** jrockway joined
[19:54] <dalek> roast: baa7d6f | moritz++ | S12-introspection/meta-class.t:

[19:54] <dalek> roast: another rakudo unfudge

[19:54] <dalek> roast: review: https://github.com/perl6/roast/commit/baa7d6f429

[19:57] *** nbrown joined
[20:02] *** sivoais left
[20:05] *** pernatiy left
[20:05] *** sivoais joined
[20:05] *** pernatiy joined
[20:12] <dalek> 6model: 74a549e | (Martin Berends)++ | c/ (9 files):

[20:12] <dalek> 6model: [6model/c] add hashtable and a few tests (works only on Linux)

[20:12] <dalek> 6model: review: https://github.com/jnthn/6model/commit/74a549e76d

[20:14] *** Jackneill left
[20:15] *** kaare_ left
[20:20] *** xinming_ left
[20:20] *** xinming joined
[20:37] *** wamiks joined
[20:39] <pmichaud> moritz: +1 to splitting stuff out of README if you want

[20:50] *** soh_cah_toa left
[20:53] *** mikehh joined
[20:59] * moritz does it.

[21:00] *** benabik joined
[21:00] *** molaf joined
[21:01] *** noganex_ left
[21:02] <masak> is there a method for invoking a Routine? besides postcircumfix:<( )>, I mean?

[21:02] <jnthn> rakudo: sub foo($a) { say $a }; &foo.callwith(42)

[21:02] <p6eval> rakudo 922500: OUTPUT¬´42‚ê§¬ª

[21:03] <moritz> why do you need anything besides .() ?

[21:03] <jnthn> That's what I thought when I saw .callwith :)

[21:03] <masak> oh, interesting, .callwith without being in a call already :)

[21:03] *** noganex joined
[21:03] <dalek> rakudo/nom: 90f996e | moritz++ | / (2 files):

[21:03] <dalek> rakudo/nom: move most of the build instructions into a separate INSTALL file

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90f996e230

[21:04] <masak> moritz: I don't, I'm just thinking ahead :)

[21:04] <jnthn> masak: It's no relation to callwith fwiw

[21:04] <jnthn> (in a deep way)

[21:05] <masak> what has no relation to callwith? .() ?

[21:05] <jnthn> Code.callwith(...) has no relation to callwith(...)

[21:06] <masak> oh!

[21:06] <jnthn> I dunno if the first is even tested, fwiw.

[21:06] <masak> that's... unfortunate...

[21:06] <jnthn> I guess if we have it it's spec

[21:06] <masak> huh? :)

[21:06] <jnthn> But it seems kinda...well...pointless.

[21:07] <jnthn> ooh, we get quite a way through autothreading.t now :)

[21:07] <masak> hm, yes. S06:1146 mentions something of the sort.

[21:08] <masak> "Use of C<callwith> allows the routine to be called without introducing an official C<CALLER> frame."

[21:08] <masak> that seems to be why.

[21:08] <masak> should've been named .gotowith :P

[21:08] <jnthn> oh

[21:08] <jnthn> well, we don't do that. :)

[21:08] * masak submits rakudobug

[21:09] * jnthn doesn't bother re-adding it to nom :)

[21:09] <jnthn> oh, but we don't do CALLER yet

[21:09] <jnthn> hey, prove that Rakudo bug :)

[21:09] <mikehh> the parrot PDS is on in #parrotsketck on irc.parrot.org if anyone is interested

[21:10] <mikehh> #parrotsketch sorry

[21:10] <moritz> masak: use callframe() to prove it :-)

[21:12] <masak> rakudo: sub foo { &bar.callwith() }; sub bar { say callframe.perl }; foo

[21:12] <p6eval> rakudo 922500: OUTPUT¬´Method 'perl' not found for invocant of class 'ParrotInterpreter'‚ê§  in <anon> at line 1317:src/gen/core.pm‚ê§  in 'Any::join' at line 1:src/metamodel/RoleToInstanceApplier.nqp‚ê§  in 'Mu::attribs' at line 1318:src/gen/core.pm‚ê§  in 'Mu::perl' at line 1322:src/gen/core.p‚Ä¶

[21:12] <masak> hrm.

[21:12] <masak> how do I use callframe?

[21:12] <masak> rakudo: sub foo { &bar.callwith() }; sub bar { say callframe }; foo

[21:12] <p6eval> rakudo 922500: OUTPUT¬´CallFrame()<0x5044b20>‚ê§¬ª

[21:13] *** benabik left
[21:13] <jnthn> It says CALLER frame, not anything about CallFrame ;)

[21:13] <masak> d√•light.

[21:13] <jnthn> CallFrame includes all the intermediate blocks too, iirc.

[21:13] *** benabik joined
[21:13] <masak> s/h//

[21:13] <jnthn> d√•lightful!

[21:14] <masak> mikehh: irc.perl.org, surely?

[21:14] <mikehh> masak: either or

[21:14] <masak> aha.

[21:16] <masak> moritz: how can I show it with callframe? I'm looking at the class, but it seems all I can do with it is .my

[21:18] <masak> rakudo: sub foo { my $foo; &bar.callwith() }; sub bar { my $bar; say callframe.my }; foo

[21:18] <p6eval> rakudo 922500: OUTPUT¬´$bar      3__CANDIDATE_LIST__     35$_    43call_sig      59$/    63$!    71‚ê§¬ª

[21:18] <masak> that's good enough.

[21:18] * masak adds that to the ticket

[21:19] <cognominal_> rakudo: grammar A { token a { a } };  "a" ~~ /<A::a>/

[21:19] <p6eval> rakudo 922500: OUTPUT¬´===SORRY!===‚ê§regex assertion not terminated by angle bracket at line 22, near "::a>/"‚ê§¬ª

[21:20] <masak> fwiw, I can see how a Block can have a .my, but not really how a Routine can have a .my

[21:22] *** soh_cah_toa joined
[21:26] <moritz> why not?

[21:26] <moritz> it also has curlies that introduce a lexical scope

[21:27] *** wamiks left
[21:27] <jnthn> Also, Routine ~~ Block

[21:27] * moritz -> sleep

[21:28] <masak> night, moritz.

[21:28] <masak> moritz, jnthn: you make valid points. :)

[21:32] *** wamba joined
[21:38] *** hanekomu joined
[21:39] *** MayDaniel_ joined
[21:45] <jnthn> oh noes

[21:46] <jnthn> INSTALL conflicts with the directory install on case-insensitive OS.

[21:46] <jnthn> so...

[21:46] <jnthn> error: Updating 'INSTALL' would lose untracked files in it

[21:46] <jnthn> could not detach HEAD

[21:46] <jnthn> :(

[21:46] <jnthn> Anyone with a Rakudo commit bit able to renmae that? :)

[21:47] <jnthn> tadzik: Good news: I found the segfault, I think. And shoulda fixed it. Bad news: there's another thing not quite right yet.

[21:48] *** Patterner left
[21:48] *** soh_cah_toa left
[21:48] <Tene> jnthn: something wrong with rakudo repo?

[21:48] <jnthn> Tene: yeah...don't worry, can fix.

[21:48] <Tene> Oh, okay.

[21:49] <jnthn> Tene: Case-sensitive filesystem assumption causes problem on case-sensitive one :)

[21:49] <Tene> oops

[21:49] *** Psyche^ joined
[21:49] *** Psyche^ is now known as Patterner

[21:51] <dalek> rakudo/nom: 0aacf70 | jonathan++ | src/Perl6/SymbolTable.pm:

[21:51] <dalek> rakudo/nom: Refactor BEGIN handling now that we have improved static lexpads. Note, this lets you write stuff that won't yet work out well with pre-compilation - beware. :-)

[21:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0aacf70dd5

[21:51] <dalek> rakudo/nom: fd68c86 | jonathan++ | INSTALL (2 files):

[21:51] <dalek> rakudo/nom: Rename INSTALL to INSTALLME (better names welcome) since on case-insensitive OS it conflicts with install directory made by --gen-parrot.

[21:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd68c86b4f

[21:54] *** hanekomu left
[21:55] *** soh_cah_toa joined
[21:57] <jnthn> tadzik: ah, actually I think it will work out :)

[21:57] <masak> std: class A { method foo { $.bar: "OH HAI" } }

[21:57] <p6eval> std 516268a: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Illegal use of colon as invocant marker at /tmp/x7FNvtQEPg line 1:‚ê§------> [32mclass A { method foo { $.bar:[33m‚èè[31m "OH HAI" } }[0m‚ê§Check failed‚ê§FAILED 00:01 121m‚ê§¬ª

[21:58] <masak> I see.

[21:58] <jnthn> tadzik: Aww, no, not quite...too much scope sharing.

[21:58] <masak> $cake.have ^ $cake.eat :)

[22:06] *** MayDaniel_ left
[22:07] <shinobicl> hi

[22:07] <jnthn> tadzik: When you're about, feel free to try your patch again, and let me know if the segfault is gone. Also feel free to push it somewhere either way, so I can play with it.

[22:08] <shinobicl> i don't quite the "roles" feature yet... I have a role that i want to apply to Dates, and replace succ and pred

[22:09] <shinobicl> is parametric, and requires an existing "calendar" object to work

[22:09] <shinobicl> https://github.com/shinobi/TaskScheduler/blob/master/WorkdayCalendar.pm

[22:09] <shinobicl> the role is at line 107

[22:10] <shinobicl> when i use a .succ method, it goes in a loop with this error: in 'succ' at line 108:WorkdayCalendar.pm

[22:10] <shinobicl>   in <anon> at line 81:WorkdayCalendar.pm

[22:10] <shinobicl>   in 'WorkdayCalendar::move-by-workdays' at line 1:src/metamodel/RoleToInstanceApplier.nqp and is goes and goes that way

[22:11] <masak> shinobicl: that error message says only where things went wrong, not what went wrong.

[22:12] <masak> shinobicl: how are you applying the role?

[22:12] <shinobicl> it goes in an infinite recursiom when using .succ

[22:12] <shinobicl> give a sec..

[22:12] <shinobicl> diag "Testing Workday role, using $FILE_CAL_CORRECT";

[22:12] <shinobicl> my $w_date = Date.new(year=>2011, month=>07, day=>01) does Workday[$calendar];

[22:12] <shinobicl> is( #--- Friday to Monday

[22:12] <shinobicl>     $w_date.succ,

[22:12] <shinobicl>     Date.new(year=>2011, month=>07, day=>04),

[22:12] <shinobicl>     "Workday role: Skipping weekends (Friday + 1 = Monday)"

[22:12] <shinobicl> );

[22:14] <masak> looks like it could work.

[22:14] <sorear> masak: as I understand it, the method is literally named 'postcircumfix:<( )>'

[22:15] <sorear> niecza: class Foo { method postcircumfix:<( )> ($x) { say $x } }; Foo.new.(24)

[22:15] <p6eval> niecza v8-6-g9a4bec8: OUTPUT¬´24‚ê§¬ª

[22:15] <masak> sorear: yes. I was just curious; the .[] and .{} methods seem to have evolved helper methods, maybe .() had too without my noticing it...

[22:15] <sorear> ah.

[22:21] <masak> tadzik: ping

[22:21] *** drbean joined
[22:22] <sorear>  how evil is the 'factory object' pattern?

[22:22] <shinobicl> i know.: i'm redefining 'succ' in my role. My new 'succ' uses a function that is intended to use the original 'succ'. 

[22:22] <shinobicl> somehow, i should be able to call the "base class" succ function

[22:22] <masak> sorear: I've always had a hard time putting my finger on that one. I know what it's for and why it's needed, but I can't determine whether the need is genuine or stems from restrictions in the language.

[22:23] <jnthn> shinobicl: nextsame

[22:23] <shinobicl> nextsame.succ ?

[22:23] <jnthn> or nextwith(args)

[22:23] <Tene> masak: Here's an interesting presentation of that question: what's the difference between a factory object and class objects?

[22:23] <jnthn> no, just nextsame to defer with the same arguments, nextwith to specify

[22:23] <Tene> What more than the name in .new() vs .give-me-an-instance() ?

[22:24] <jnthn> There's callwith and callsame which are similar but let you get and play with the return value

[22:24] <sorear> masak: I'm thinking of changing Op::CallMethod.new(|node($/), receiver => ..., name => ..., args => [...]) to $*op-factory.call-method($/, ..., ...., ...)

[22:24] <sorear> masak: in the name of dependency injection and a bit of terseness

[22:26] <masak> sorear: sounds good to me, from my pattern-n00b perspective.

[22:26] <masak> Tene: I *think* that factory methods are usually a bit more involved than .new methods.

[22:26] <masak> Tene: though I'm not really sure.

[22:27] <Tene> masak: You can add additional "constructor methods" to a class.  I certainly often do.

[22:27] *** cottoo left
[22:28] <masak> Tene: oh, sure.

[22:28] *** cotto joined
[22:28] <sorear> Tene: I am speaking of one object which has constructors for *many* classes

[22:28] <masak> Tene: the Factory pattern sometimes involves a whole different object, though... right.

[22:28] <masak> Tene: we might be talking about different patterns.

[22:31] <Tene> masak: I thought that we were talking about a large range of patterns and their relative tradeoffs.

[22:31] <masak> Tene: what made you think that? :)

[22:32] <masak> Tene: sorear opened up with mentioning 'factory object'.

[22:32] <shinobicl> jnhtn: The problem is that i am not calling the old 'succ' directly from the new 'succ'. The new succ calls another method that uses the 'old' succ instead.

[22:33] *** am0c joined
[22:33] <Tene> masak: sorear is trying to decide how to implementsomething, and considering the factory pattern as one option.  You expressed that you don't feel you fully understand the nature of the need for that pattern.

[22:34] <shinobicl> i think i can avoid to use the old 'succ' at all... but it just seem right the way how is implemented now. (except for this 'infinite recursion' error)

[22:35] <Tene> So the entire point of my question was for you to compare the fatory pattern against other things to see what the factory pattern actually offers, or whether language features could fill the same role.

[22:35] <jnthn> shinobicl: Oh, that's awkwarder.

[22:36] <jnthn> shinobicl: Maybe quality if explicitly if you know the class that has the old one.

[22:36] <jnthn> $obj.ClassName::succ

[22:36] <masak> Tene: in pattern lingo, a "factory" is a reified constructor, i.e. an object which handles the construction for some other class.

[22:36] <shinobicl> oh... i'll try that

[22:36] <Tene> masak: Right.

[22:36] <masak> Tene: one factory can sometimes create several different types of objects.

[22:37] <Tene> Presumably using some internal state to govern their creation.

[22:37] <masak> Tene: from Wikipedia: "Factory objects are used in situations where getting hold of an object of a particular kind is a more complex process than simply creating a new object."

[22:37] <masak> Tene: I'm unsure about the use of this pattern, because I don't often find myself in that situation.

[22:37] <masak> probably because I don't use Dependency Injection that heavily yet.

[22:38] <masak> I am under the impression that as DI increases in one's system, the need/want for factories will, too.

[22:38] * jnthn hasn't found that in practice.

[22:38] <Tene> Right.  For many uses of that, I've just added additional constructors to the class itself, and passed around classes.

[22:38] <masak> jnthn: interesting.

[22:38] <jnthn> masak: Unless you consider a DI container to be a factory :)

[22:38] <masak> Tene: I tend to do something like that as well.

[22:39] <masak> jnthn: maybe it is; I don't know.

[22:39] *** wamiks joined
[22:39] <Tene> masak: especially if your factory class doesn't use any attributes.

[22:39] <masak> jnthn: I don't tend to use DI containers either :P

[22:40] <sorear> I don't think I've ever used a formal DI container

[22:40] <sorear> but DI is one of my favorite pattterns, go figure

[22:42] <shinobicl> IT WORKS! Thanks, jnhtn!!

[22:42] <masak> sorear: it's getting to be one of mine, too. or IoC in it's various forms, really.

[22:43] <masak> eugh, s/it's/its/

[22:43] <masak> I spell like an American!

[22:43] *** wamba left
[22:43] *** wamiks left
[22:43] <masak> (no offense)

[22:43] <Tene> ;_;

[22:44] * sorear doesn't

[22:44] <jnthn> fwiw, when I teach DI then DI containers are something I introduce as a convenience and later on, not as a starting point.

[22:45] <Tene> $*offense-factory-factory.create-offense-factory.create-offense.offended();

[22:45] <masak> Tene: I see you code according to all the latest fashions.

[22:45] <sorear> for me DI is something that emerges naturally from the framework of a larger app; I haven't yet understood how to wedge my ideas into premade DI containers

[22:46] <masak> it's important to keep one's factory factories well factored.

[22:46] <sorear> (yes, I count niecza as a larger app.  kinda sad.)

[22:46] <Tene> masak: You've read "Why I Hate Frameworks" of course, yes?

[22:47] <masak> Tene: is it the one with the hammers?

[22:47] <felher> Can one have a sub that pattern-matches on a list with head $x and a tail $xs? Just like in haskell? Would one use [A

[22:47] <Tene> masak: yeah

[22:47] <masak> sorear: I was so happy when I managed to explain DI to myself. I made a diagram :)

[22:47] <masak> sorear: it was one of my first blog posts on use.perl

[22:47] <felher> *Would one use ($head, *@tail)?

[22:47] <Tene> felher: yes

[22:47] <Tene> felher: you'd use []

[22:47] <Tene> felher: http://en.wikipedia.org/wiki/Perl_6#Quicksort

[22:47] <masak> sorear: this is the one: http://strangelyconsistent.org/blog/ill-call-you-back

[22:48] <felher> Tene: k, thnx.

[22:48] <felher> Is there a way to get $start and $last? (*@start, $last) is not possible i think.

[22:49] <jnthn> nom: "abc".split('b').say

[22:49] <p6eval> nom: OUTPUT¬´a c‚ê§¬ª

[22:49] <jnthn> nom: split('a', 'abc').say

[22:49] <p6eval> nom: OUTPUT¬´Nominal type check failed for parameter '$pat'; expected Regex but got Str instead‚ê§current instr.: 'split' pc 539704 (src/gen/CORE.setting.pir:128315) (src/gen/CORE.setting:1140)‚ê§¬ª

[22:49] <masak> wow, that *is* a long time ago. in the blog post, I'm actually *grateful* that Rakudo didn't *crash* when I used a callback :P

[22:53] <jnthn> git diff

[22:53] <jnthn> oops

[22:54] <Tene> jnthn: there are questions about 6model plans in #parrotsketch right now, btw.

[22:54] <jnthn> ah

[22:54] <jnthn> Tene: joined in case I can help with any of them

[23:01] <dalek> rakudo/nom: 5c6ac4f | jonathan++ | src/ (3 files):

[23:01] <dalek> rakudo/nom: Implement auto-threading in the $junc.meth case.

[23:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5c6ac4fef1

[23:01] <dalek> rakudo/nom: 7c8ab31 | jonathan++ | src/core/Cool.pm:

[23:01] <dalek> rakudo/nom: Liberalize sub form of split, leave type handling to methods.

[23:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7c8ab31eb5

[23:02] <jnthn> OK, pass all but 3 tests of S03-junction/autothreading.t now :)

[23:02] <flussence> waitwaitwait - is that *real* threading?

[23:03] <jnthn> No :)

[23:03] <jnthn> w/in 16

[23:06] <Tene> flussence: Rakudo doesn't run on any other VMs yet, and Parrot's threading has been broken for years.

[23:06] <jnthn> rakudo: say (1 < all(2,3,4)).WHAT

[23:06] <p6eval> rakudo 922500: OUTPUT¬´Junction()‚ê§¬ª

[23:06] <jnthn> rakudo: say (1 ne all(2,3,4)).WHAT

[23:06] <p6eval> rakudo 922500: OUTPUT¬´Bool()‚ê§¬ª

[23:17] *** timbunce left
[23:18] *** PacoLinux joined
[23:20] *** control-alt-coke left
[23:24] <sorear> flussence: "autothreading" is a technical term and doesn't have anything to do with OS threads

[23:25] <sorear> (there are some people who think junctions can use OS threads.  IMHO, they are just deluding themselves.)

[23:25] <sorear> s/can/could eventually/

[23:25] *** sftp left
[23:26] <masak> it's unusual for humble opinions to express that people are just deluding themselves :P

[23:27] *** timbunce joined
[23:28] <flussence> well yeah, I get that using threads all over the place isn't a magical speed up thing...

[23:28] <masak> but yes, I agree with the sentiment. even if junctions ever got to use threads, I don't see a very big gain from that.

[23:28] <masak> mostly, I use junctions for very small scopes, like comparisons, or in the middle of a chain of method calls.

[23:28] *** sftp joined
[23:33] <flussence> (and I just had to deal with a bunch of thread-induced headache at $dayjob last week!)

[23:33] <masak> ok, my https://github.com/masak/farm is "finished" now. it ended up quite a bit bigger than sorear++'s.

[23:33] <dalek> rakudo/nom: 886f677 | jonathan++ | src/core/Str (2 files):

[23:33] <dalek> rakudo/nom: ne should behave just like !eq

[23:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/886f677430

[23:33] <dalek> rakudo/nom: 87ab44f | jonathan++ | t/spectest.data:

[23:33] <dalek> rakudo/nom: We now pass all of S03-junctions/autothreading.t.

[23:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/87ab44f4ac

[23:34] <masak> but I like this factoring, and I think it'll be a beeeze to plug it into a harness for automated players.

[23:34] <masak> I've been playing at it, and there's some bug in there wherein the stock gives me all of its rabit instead of the 6 I asked for. can't seem to find why that is.

[23:35] <masak> will probably blog about this way of using OO and testing tomorrow.

[23:35] <masak> 'night, #perl6.

[23:35] *** masak left
[23:35] *** timbunce left
[23:42] *** stepnem left
[23:47] *** molaf_ joined
[23:48] *** stepnem joined
[23:50] *** molaf left
[23:50] <dalek> roast: bcd4217 | jonathan++ | S02-builtin_data_types/undefined-types.t:

[23:50] <dalek> roast: Update test to latest spec; remove a Rakudo fudging.

[23:50] <dalek> roast: review: https://github.com/perl6/roast/commit/bcd42172e4

[23:52] <dalek> rakudo/nom: 018c561 | jonathan++ | src/Perl6/Actions.pm:

[23:52] <dalek> rakudo/nom: Fix sink prefix.

[23:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/018c561086

[23:52] <dalek> rakudo/nom: 6f9747c | jonathan++ | t/spectest.data:

[23:52] <dalek> rakudo/nom: Another passing test file.

[23:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6f9747c465

[23:53] <flussence> hm, well this graph script's going nowhere - none of these old revisions can --gen-nqp because they're using a configure switch that got renamed later and the git revision wasn't pinned down like it is for --gen-parrot :/

[23:58] *** Trashlord left
