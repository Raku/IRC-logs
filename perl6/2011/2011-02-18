[00:02] *** pjcj joined
[00:02] *** jasonmay joined
[00:03] *** envi left
[00:05] *** kaydsoft left
[00:08] *** gdey left
[00:08] *** gdey joined
[00:10] *** MayDaniel left
[00:12] *** icwiener left
[00:13] *** gdey left
[00:20] *** masonkramer joined
[00:29] <AzaToth> rakudo: my $‚ì® = "alloha"; say $‚ì®

[00:29] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "my $\u24e8 = \"a"‚ê§¬ª

[00:30] <donri> rakudo: my $b√∂rk-b√∂rk = "Swedish chef!"; say $b√∂rk-b√∂rk

[00:30] <p6eval> rakudo 6f9116: OUTPUT¬´Swedish chef!‚ê§¬ª

[00:30] <AzaToth> donri: so, why aint $‚ì® ok?

[00:31] *** moosenewbie joined
[00:31] <AzaToth> imo, it's unicode

[00:31] <jnthn> rakudo: say '‚ì®' ~~ /<ident>/

[00:31] <AzaToth> or did I miss something?

[00:31] <p6eval> rakudo 6f9116: OUTPUT¬´‚ê§¬ª

[00:31] <jnthn> rakudo: say ?('‚ì®' ~~ /<ident>/)

[00:32] <p6eval> rakudo 6f9116: OUTPUT¬´Bool::False‚ê§¬ª

[00:32] <donri> maybe it makes distinction between punctuation etc

[00:32] <jnthn> It's not an identifier character, it seems.

[00:32] <jnthn> donri: Yes.

[00:32] <donri> maybe it can be used infix?

[00:32] <jnthn> Yes, it's probably fine for an infix.

[00:32] <AzaToth> rakudo: say ?('‚ìî' ~~ /<ident>/)

[00:32] <p6eval> rakudo 6f9116: OUTPUT¬´Bool::False‚ê§¬ª

[00:33] <jnthn> .u ‚ìî

[00:33] <phenny> U+24D4 CIRCLED LATIN SMALL LETTER E (‚ìî)

[00:33] <jnthn> Hmm

[00:34] <jnthn> rakudo: say ?('‚ìî' ~~ /\w/)

[00:34] <p6eval> rakudo 6f9116: OUTPUT¬´Bool::False‚ê§¬ª

[00:34] <AzaToth> using compose it's Compose + ( + e + )

[00:34] <AzaToth> da Super key

[00:34] <AzaToth> it _looks_ like a letter at least „ÉÑ

[00:35] <plobsing> rakudo: my $GoodThing‚Ñ¢ = "shiny"; say $GoodThing‚Ñ¢;

[00:35] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "my $GoodTh"‚ê§¬ª

[00:35] <AzaToth> hehe

[00:35] <plobsing> but I want to trademark my variable names!

[00:35] <jnthn> AzaToth: Looking at http://www.fileformat.info/info/unicode/char/24d4/index.htm suggests it doesn't have a bunch of properties.

[00:36] <AzaToth> rakudo: my $‚Ñ† = "alloha"; say $‚Ñ†

[00:36] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "my $\u2120 = \"a"‚ê§¬ª

[00:36] <AzaToth> .u ‚Ñ†

[00:36] <phenny> U+2120 SERVICE MARK (‚Ñ†)

[00:37] <AzaToth> jnthn: so symbols are not good for identifiers then I assume

[00:39] <AzaToth> jnthn: does the specification spe cify anywhere what is valid for identifier?

[00:40] <jnthn> AzaToth: I'd suspect in S02

[00:40] <AzaToth> I so suspected too

[00:40] *** stifynsemons left
[00:40] <arnsholt> Anything that Unicode says is alpha-numeric is a good first-approximation, IIRC

[00:40] <AzaToth> but http://perlcabal.org/syn/S02.html#Lexical_Conventions doesn't really specify that deeply

[00:41] <AzaToth> "In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations. By default Perl presents Unicode in "NFG" formation, where each grapheme counts as one character. A grapheme is what the novice user would think of as a character in their normal everyday life, including any diacritics. "

[00:41] *** mfollett left
[00:41] *** moosenewbie left
[00:41] <jnthn> AzaToth: It says:

[00:41] <jnthn> An I<identifier> is composed of an alphabetic character followed by

[00:41] <jnthn> any sequence of alphanumeric characters.  The definitions of alphabetic

[00:41] <jnthn> and numeric include appropriate Unicode characters.

[00:42] <AzaToth> ah, down there

[00:45] <plobsing> rakudo: my @‚Ñï := 1, 2, 3, ... *; say @‚Ñï[100];

[00:45] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Comma found before apparent series operator; please remove comma (or put parens‚ê§    around the ... listop, or use 'fail' instead of ...) at line 22, near " ... *; sa"‚ê§¬ª

[00:45] <plobsing> rakudo: my @‚Ñï := 1, 2, 3 ... *; say @‚Ñï[100];

[00:45] <p6eval> rakudo 6f9116: OUTPUT¬´101‚ê§¬ª

[00:47] <dalek> nqp/ctmo: 8b83fce | jonathan++ | / (4 files):

[00:47] <dalek> nqp/ctmo: First cut of storing/looking things up in the SC. Will need something for putting one assembled at compile time in place too.

[00:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/8b83fcef18

[00:47] <dalek> nqp/ctmo: 8b1576b | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[00:47] <dalek> nqp/ctmo: Fill out get_slot_past method in SC builder.

[00:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/8b1576b797

[00:47] <dalek> nqp/ctmo: 9d84745 | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[00:47] <dalek> nqp/ctmo: Start to fill out some of the SC builder bits.

[00:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/9d84745004

[00:54] *** envi joined
[01:01] <jnthn> sleep &

[01:05] *** kanishka joined
[01:08] <AzaToth> rakudo: class aq { method a { return class { method b { return 3; } } }; }; say(aq.a.b);

[01:08] <p6eval> rakudo 6f9116: OUTPUT¬´3‚ê§¬ª

[01:08] <AzaToth> rakudo: class q { method a { return class { method b { return 3; } } }; }; say(q.a.b);

[01:08] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22‚ê§¬ª

[01:08] <AzaToth> feature or bug?

[01:12] <donri> I wish take would use $_

[01:12] <flussence> std: class q { method a { return class { method b { return 3; } } }; }; say(q.a.b);

[01:12] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse argument list at /tmp/BzWtgg41gn line 1:‚ê§------> [32mass { method b { return 3; } } }; }; say[33m‚èè[31m(q.a.b);[0m‚ê§Couldn't find final ')'; gave up at /tmp/BzWtgg41gn line 1:‚ê§------> [32m method b { return 3; } } }; };

[01:12] <p6eval> ..say(q.a.[33‚Ä¶

[01:16] <AzaToth> rakudo: class c { method a { return class { method b { return 3; } } }; }; say(c.a.b);

[01:16] <p6eval> rakudo 6f9116: OUTPUT¬´3‚ê§¬ª

[01:16] <AzaToth> I assume q.XXX. overrules here

[01:22] <donri> Duno if anyone here uses Convore but https://convore.com/perl-6/

[01:22] <jdhore> ew, convore :(

[01:23] <plobsing> donri: never seen it before. is there much if any of an advantage over gchat or irc?

[01:24] <donri> plobsing: threaded live-chats

[01:24] <plobsing> I don't know what that means, but it sounds a lot like IRC

[01:25] <jdhore> It's basically like really crappy IRC

[01:25] <donri> IRC isn't threaded, logged and searchable etc

[01:26] <donri> The only good thing about IRC is that everyone uses it

[01:26] <plobsing> http://irclog.perlgeek.de/perl6/2011-02-18#i_3308184

[01:26] <jdhore> It's logged and searchable

[01:26] <jdhore> Yep, what he just linked

[01:27] <donri> Yea that just works and requires no setup

[01:27] <plobsing> all hail the perl geek

[01:28] <donri> Anyway, ignore Convore if you like, just thought there should be a Perl 6 group.

[01:28] <donri> There is a Perl one but I dislike when they're grouped together

[01:28] <donri> Like on Reddit.

[01:28] <sorear> good * #perl6

[01:29] <plobsing> Perl? on Reddit? isn't that the very definition of "glutton for punishment"?

[01:30] <jdhore> surprisingly, no

[01:36] <sorear> When people here say "„ÉÑ", I hear "tsu".  It's not a smilie at *all*.

[01:37] <donri> Is it a smiley though?

[01:37] <sorear> hello AzaToth

[01:41] *** mfollett joined
[01:45] *** stkowski left
[01:53] *** ab5tract left
[01:56] *** DarkWolf84 joined
[01:56] <DarkWolf84> hello #perl6

[01:57] *** mfollett left
[01:58] <DarkWolf84> rakudo: "alive".say

[01:58] <p6eval> rakudo 6f9116: OUTPUT¬´alive‚ê§¬ª

[02:01] *** noganex joined
[02:01] <DarkWolf84> too bad ;(

[02:02] <DarkWolf84> I think I've done something nasty (stupid) to try.rakudo.org bot

[02:05] *** noganex_ left
[02:05] <donri> that thing never works when I try it

[02:06] <coldhead> try.rakudo.org is throwing a "serious" error

[02:06] <coldhead> :\

[02:12] <DarkWolf84> yeah

[02:12] *** shi left
[02:13] <DarkWolf84> I tried to get some lines from $*IN

[02:13] <DarkWolf84> I just forgot that it's just cgi

[02:14] <sorear> hi DarkWolf84

[02:14] <DarkWolf84> hi sorear 

[02:16] <DarkWolf84> sorear, do you know someone who has access to try.rakudo.org

[02:17] <sorear> ask moritz_

[02:17] <sorear> maybe alester

[02:17] <DarkWolf84> ok

[02:18] <DarkWolf84> I hate when do something like that

[02:18] <plobsing> hmmm... isn't try.rakudo.org partially sandboxed?

[02:18] <DarkWolf84> maybe

[02:18] <plobsing> should $*IN really mess it up?

[02:19] <DarkWolf84> yeah

[02:20] <DarkWolf84> maybe it's waiting for input

[02:20] <sorear> try.rakudo.org uses $*IN and $*OUT internally

[02:21] <sorear> there are 3 programs running - Rakudo, a CGI script, and a server thingy which accepts commands from the CGI script and runs instances of Rakudo

[02:21] <sorear> $*IN is used to communicate between the first and the third

[02:22] <DarkWolf84> I'm sure it broke during my tests

[02:22] <DarkWolf84> and the last line was $*IN.get

[02:23] <plobsing> the visibility is the problem. it should stash away a private reference to STDIN and then set the globally visible handle to /dev/null or somesuch.

[02:24] *** stifynsemons joined
[02:25] <AzaToth> raduko: $„ÉÑ=":)" 

[02:25] <AzaToth> rakudo: $„ÉÑ=":)" 

[02:25] <DarkWolf84> nice :)

[02:25] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Symbol '$„ÉÑ' not predeclared in <anonymous> (/tmp/t5U3lYR3Ia:22)‚ê§¬ª

[02:26] <AzaToth> lol?

[02:26] <DarkWolf84> bug

[02:27] *** mfollett joined
[02:27] <plobsing> rakudo: my $„ÉÑ =":)"; say $„ÉÑ;

[02:27] <p6eval> rakudo 6f9116: OUTPUT¬´:)‚ê§¬ª

[02:29] <DarkWolf84> rakudo: $a = "epic fail"

[02:29] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Symbol '$a' not predeclared in <anonymous> (/tmp/LPeU6hJ1K5:22)‚ê§¬ª

[02:29] <DarkWolf84> I got it

[02:29] <DarkWolf84> it's the strict pragma :)

[02:31] <AzaToth> haha

[02:31] <AzaToth> rakudo: no strict; $„ÉÑ=":)" 

[02:31] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Symbol '$„ÉÑ' not predeclared in <anonymous> (/tmp/9rIJnUEP1H:22)‚ê§¬ª

[02:31] <DarkWolf84> lol

[02:32] <AzaToth> rakudo: say .perl

[02:32] <p6eval> rakudo 6f9116: OUTPUT¬´Any‚ê§¬ª

[02:35] *** cdarroch left
[02:38] <DarkWolf84> bye, I have to go to bed or soon will become insomniac

[02:39] *** DarkWolf84 left
[02:43] <donri> rakudo: sub postfix:<‚ò∫>($s) { say "$s! :)" }; "Hello"‚ò∫

[02:43] <p6eval> rakudo 6f9116: OUTPUT¬´Hello! :)‚ê§¬ª

[02:44] *** stifynsemons left
[02:52] <Tene> AzaToth: Rakudo doesn't yet implement 'no strict'

[02:53] *** mfollett left
[02:53] *** mfollett joined
[02:55] *** mfollett_ joined
[02:55] *** donri left
[02:57] *** whiteknight left
[02:57] *** stifynsemons joined
[02:58] *** mfollett left
[02:58] *** mfollett_ is now known as mfollett

[03:05] *** pjcj left
[03:06] <sorear> perl6: class A { }; class B { method succ() { A } }; my $x = B; $x++; say $x.WHAT

[03:06] <p6eval> niecza v2-68-ga938d4c: OUTPUT¬´(timeout)¬ª

[03:06] <p6eval> ..pugs: OUTPUT¬´Int‚ê§¬ª

[03:06] <p6eval> ..rakudo 6f9116: OUTPUT¬´Int()‚ê§¬ª

[03:06] <sorear> perl6: class A { }; class B { method succ() { A } }; my $x = B; $x++; say $x.WHAT

[03:06] <p6eval> pugs: OUTPUT¬´Int‚ê§¬ª

[03:06] <p6eval> ..rakudo 6f9116: OUTPUT¬´Int()‚ê§¬ª

[03:06] <p6eval> ..niecza v2-68-ga938d4c: OUTPUT¬´‚ê§¬ª

[03:07] <sorear> perl6: class A { }; class B { method succ() { A.new } }; my $x = B.new; $x++; say $x.WHAT

[03:07] <p6eval> pugs: OUTPUT¬´*** Cannot cast from VObject (MkObject {objType = (mkType "B"), objAttrs = <Hash:0x7ff40a63b169>, objOpaque = Nothing, objId = MkObjectId {unObjectId = 5}}) to Double (VNum)‚ê§    at /tmp/CVi7s2qu7b line 1, column 66-70‚ê§¬ª

[03:07] <p6eval> ..rakudo 6f9116: OUTPUT¬´A()‚ê§¬ª

[03:07] <p6eval> ..niecza v2-68-ga938d4c: OUTPUT¬´‚ê§¬ª

[03:08] *** Rotwang left
[03:08] <sorear> niecza: class A { }; class B { method succ() { A.new } }; my $x = B.new; $x++; say $x.typename

[03:08] <p6eval> niecza v2-68-ga938d4c: OUTPUT¬´A‚ê§¬ª

[03:08] <sorear> I guess WHAT.Str is broken

[03:09] *** woosley joined
[03:10] *** cognominal left
[03:11] *** cognominal joined
[03:12] <dalek> niecza: 1b13b31 | sorear++ | Makefile:

[03:12] <dalek> niecza: Auto-compile setting on make to end p6eval timeouts

[03:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1b13b31840

[03:13] *** stifynsemons left
[03:14] *** felipe left
[03:21] *** pjcj joined
[03:22] *** AzaToth left
[03:22] *** rbuels left
[03:23] *** rbuels joined
[03:27] *** mfollett left
[03:34] <diakopter> seen TimToady

[03:34] <aloha> TimToady was last seen in #perl6 17 hours 27 mins ago saying "okay, say goodbye now".

[03:34] <diakopter> orly

[03:37] *** dolmen left
[03:37] <colomon> He was also on as TimToady_it or something like that today.

[03:49] *** ponbiki left
[03:49] *** ponbiki joined
[04:03] *** envi left
[04:17] *** hudnix left
[04:20] *** stifynsemons joined
[04:20] *** jaldhar joined
[04:21] *** hudnix joined
[04:23] *** Su-Shee_ joined
[04:27] *** Su-Shee left
[04:35] *** sftp left
[04:42] *** fith joined
[04:49] <dalek> niecza: b4c48f4 | sorear++ | lib/SAFE.setting:

[04:49] <dalek> niecza: Fix .join for lists starting with an undefined value

[04:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b4c48f4da1

[05:00] *** cognominal left
[05:04] *** mtk left
[05:10] <dalek> niecza: dfdfc66 | sorear++ | / (6 files):

[05:10] <dalek> niecza: Implement the % operator

[05:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/dfdfc66b6a

[05:12] *** mtk joined
[05:21] <dalek> nqp: 549d447 | bacek++ | / (3 files):

[05:21] <dalek> nqp: Create attribute accessors. Mostly stolen from nqpclr

[05:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/549d447ffe

[05:39] *** agentzh joined
[05:40] *** wooden joined
[05:40] *** wooden left
[05:40] *** wooden joined
[05:44] *** ponbiki left
[05:44] *** ponbiki joined
[06:06] *** stifynsemons left
[06:27] *** y3llow_ joined
[06:28] *** kcwu left
[06:29] *** pothos left
[06:30] *** y3llow left
[06:30] *** y3llow_ is now known as y3llow

[06:33] *** kanishka left
[06:34] *** coldhead left
[06:34] *** coldhead joined
[06:36] *** cjk101010 joined
[06:37] *** kcwu joined
[06:41] *** pothos joined
[06:42] <dalek> niecza: 7f006be | sorear++ | lib/ (2 files):

[06:42] <dalek> niecza: Add a general upcall/downcall mechanism

[06:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7f006bef89

[06:47] <sorear> next month I'll be using that to implement eval

[06:50] <sorear> rakudo: say \1

[06:50] <p6eval> rakudo 6f9116: OUTPUT¬´Capture()<0x3d070d0>‚ê§¬ª

[06:50] <sorear> rakudo: say (\1).perl

[06:50] <p6eval> rakudo 6f9116: OUTPUT¬´\(1)‚ê§¬ª

[06:50] <sorear> rakudo: say (\:foo).perl

[06:50] <p6eval> rakudo 6f9116: OUTPUT¬´\("foo" => Bool::True)‚ê§¬ª

[06:50] <sorear> rakudo: say (\(:foo)).perl

[06:50] <p6eval> rakudo 6f9116: OUTPUT¬´\("foo" => Bool::True)‚ê§¬ª

[06:51] <sorear> rakudo: say (\(:foo, 5)).perl

[06:51] <p6eval> rakudo 6f9116: OUTPUT¬´\(5, "foo" => Bool::True)‚ê§¬ª

[06:58] *** pothos left
[06:58] *** pothos joined
[06:59] *** kaare_ joined
[07:03] * sorear out

[07:08] <moritz_> phenny: tell AzaToth see http://www.perlmonks.org/?node_id=846772

[07:08] <phenny> moritz_: I'll pass that on when AzaToth is around.

[07:11] *** Mowah joined
[07:20] *** nadim__ left
[07:28] *** pothos left
[07:29] *** pothos joined
[07:32] *** wtw joined
[07:32] *** cotto left
[07:55] *** cotto joined
[08:00] *** felipe joined
[08:02] *** Su-Shee_ is now known as Su-Shee

[08:23] *** kanishka joined
[08:24] *** byzas joined
[08:30] *** envi joined
[08:34] *** ruoso left
[08:34] *** shortcircuit left
[08:41] *** justatheory left
[08:42] *** avuserow left
[08:43] *** avuserow joined
[08:53] *** daxim joined
[08:55] *** ruoso joined
[09:11] *** TiMBuS left
[09:11] *** TiMBuS joined
[09:14] <moritz_> good morning zebras

[09:14] <moritz_> any volunteers for rakudo releases?

[09:23] *** cognominal joined
[09:24] <coldhead> what would that involve?

[09:25] <moritz_> coldhead: following a release guide; notably writing a release announcement (70% copy&paste), running automated test, running  make release VERSION=...   and finally writing an email with the announcement

[09:26] <moritz_> typically about 1 to 2 hours of work, plus some time waiting for the spectest runs to finish

[09:26] <moritz_> see https://github.com/rakudo/rakudo/blob/master/docs/release_guide.pod for the full instructions

[09:32] *** kanishka left
[09:41] <jdhore> moritz_, I'm not really involved with Rakudo (i suppose), but i'd be up for doing one.

[09:46] <moritz_> jdhore: great! Which month do you want to take?

[09:47] <jdhore> I'm generally free enough to handle it, but just for ease of things, mark me down for March, if that works.

[09:48] <moritz_> sure, thanks a lot

[09:48] *** orafu left
[09:48] <tadzik> rakudo: my $a = 1, 2, 3; my $b = 1, 2, 3; my $c = [ $a, $b ]; $c.perl.say # why?

[09:48] <p6eval> rakudo 6f9116: OUTPUT¬´[1, 1]‚ê§¬ª

[09:49] <moritz_> tadzik: because $a =  is item assignment precedence

[09:49] <moritz_> rakudo: my $a = 1, 2, 3; say $a.perl

[09:49] <benabik> rakudo: my @a = 1,2,3; my @b = 1,2,3; my @c = [ @a, @b ]; @c.perl.say

[09:49] <p6eval> rakudo 6f9116: OUTPUT¬´1‚ê§¬ª

[09:49] <p6eval> rakudo 6f9116: OUTPUT¬´[[1, 2, 3, 1, 2, 3]]‚ê§¬ª

[09:49] <jdhore> no worries :)

[09:49] <moritz_> std: my $a = 1, 2, 3;

[09:49] <p6eval> std 625303c: OUTPUT¬´ok 00:01 122m‚ê§¬ª

[09:50] <dalek> rakudo: 498950f | moritz++ | docs/release_guide.pod:

[09:50] <dalek> rakudo: jdhore++ makes the March release

[09:50] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/498950fd38

[09:50] <jdhore> :D

[09:50] <tadzik> moritz_: I'm thinking about http://stackoverflow.com/questions/5038918/perl6-do-i-need-the-sigil-for-userdefined-variables

[09:51] <jdhore> Mind if i ask, what's with the whole ++ thing?

[09:51] <TiMBuS> karma jdhore 

[09:51] <aloha> jdhore has karma of 1.

[09:51] <moritz_> jdhore: karma

[09:51] <TiMBuS> karma TiMBuS

[09:51] <aloha> TiMBuS has karma of 0.

[09:51] <TiMBuS> :<

[09:52] <flussence> that's a pretty low bus factor

[09:52] <jdhore> ah, i didn't know there was a karma bot in here

[09:52] <flussence> karma flussence

[09:52] <aloha> flussence has karma of 35.

[09:52] <flussence> whoa

[09:53] <jdhore> for a bit of fun:

[09:53] <jdhore> karma C

[09:53] <aloha> C has karma of 286.

[09:53] <Tene> karma tene

[09:53] <aloha> tene has karma of 34.

[09:53] <Tene> karma C++

[09:53] <aloha> C++ has karma of 0.

[09:53] <Tene> (C++)--

[09:53] <Tene> karma C++

[09:53] <aloha> C++ has karma of 0.

[09:53] * Tene goes to bed.

[09:54] *** am0c left
[09:54] <jdhore> C++++

[09:54] <jdhore> karma C++

[09:54] <aloha> C++ has karma of 0.

[09:54] <jdhore> damn :(

[09:55] <moritz_> tadzik: I wrote a reply now

[09:55] <tadzik> good

[09:56] <jdhore> moritz_, There's a small typo in release_guide.pod...For the upcoming 2011 releases, it still says: "Planned 2010 Releases"

[09:57] <moritz_> jdhore: thanks, will fix

[09:57] <jdhore> no worries :)

[10:02] *** donri joined
[10:05] *** woosley left
[10:06] *** cotto left
[10:06] <dalek> rakudo: fe2b4e1 | moritz++ | docs/release_guide.pod:

[10:06] <dalek> rakudo: [docs] update years in release_guide.pod, jdhore++. Also add the rest of the planned release dates for 2011

[10:06] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/fe2b4e119f

[10:09] *** am0c joined
[10:11] *** Chillance joined
[10:22] <dalek> tpfwiki: (Andrew Tvardzik)++ | http://www.perlfoundation.org/perl6/index.cgi?socia

[10:28] *** volpe joined
[10:29] *** zenog joined
[10:33] <zenog> Hi, I read somewhere that shuffling an array should be done like @array.pick(*). What is the asymptotic runtime of this command? Sorry, I have no ideas about the inner workings of that idiom ...

[10:33] <phenny> zenog: 16 Feb 23:52Z <colomon> tell zenog I certainly wasn't annoyed with his program.  I just ran out of tuits to look at the longer version....

[10:34] <zenog> phenny: thx

[10:34] <zenog> colomon: no problem ;-)

[10:35] <zenog> Also, does @array = @array.pick(*) happen in situ? Quite important for big data.

[10:37] <moritz_> zenog: iirc .pick(*) uses Fisher-Yates shuffle. If not, it should be changed to do that

[10:37] <moritz_> zenog: and .= isn't really in-place yet :/

[10:37] <zenog> moritz_: OK, thanks. Fisher-Yates is good.

[10:38] <zenog> moritz_: Does that mean one would have to use .=, or would @a = @a. do exactly the same?

[10:39] <moritz_> zenog: I think that depends on the cleverness of the compiler

[10:40] *** awoodland joined
[10:40] <zenog> moritz_: OK, thanks for the info ;-) ... maybe it should become part of the language definition that such things are guaranteed ... would help people to write readable code without fearing performance penalties ;-)

[10:41] <moritz_> zenog: maybe. But I guess that's to be a goal for a later Perl 6 revision, not 6.0.0

[10:42] <zenog> moritz_: OK.

[10:56] <donri> @array .=  pick(*, :replace)  #?

[10:57] <moritz_> pick(, :replace) has been renamed to .roll

[10:57] <donri> well, @array.pick(*, :replace)

[10:57] <donri> ok

[10:57] <donri> isn't that then what zenog wants

[10:57] <moritz_> rakudo: .print for <do re mi fa so lo>.roll.[^5]

[10:57] <p6eval> rakudo 6f9116: OUTPUT¬´lo¬ª

[10:57] <moritz_> rakudo: .print for <do re mi fa so lo>.roll(*).[^5]

[10:57] <p6eval> rakudo 6f9116: OUTPUT¬´dolorefaso¬ª

[10:57] <moritz_> donri: not at all

[10:58] <moritz_> :replace is not in-place

[10:58] <donri> ok

[10:58] <moritz_> (but it was replaced because it was confusing)

[11:01] *** awoodland left
[11:01] <donri> so what it do?

[11:02] <moritz_> what the name says :-)

[11:02] <moritz_> think of rolling dice

[11:02] <moritz_> rakudo: .print for <a b c>.roll(10)

[11:02] <p6eval> rakudo 6f9116: OUTPUT¬´baaabcaabc¬ª

[11:03] <donri> > dir test => /^D/

[11:03] <donri> Desktop Downloads Documents

[11:03] <donri> > dir.grep: /^D/

[11:03] <donri> Desktop Downloads Documents

[11:03] <donri> what's the point of dir test?

[11:04] <moritz_> donri: the default value

[11:04] <moritz_> of none <. ..>

[11:04] <donri> aha

[11:06] <huf> neat!

[11:07] <moritz_> I noticed that much of my directory processing code immediately excluded those two anyway

[11:08] <huf> yeah

[11:19] <flussence> the difference between dir(:test) and .grep is the former's allowed to optimise using low-level filesystem tricks, while the latter doesn't have full knowledge of the data so can't do much with it. Also the <. ..> thing.

[11:26] <flussence> ( i.e. it can use scandir() )

[11:41] *** coldhead left
[11:41] *** tomaw left
[11:42] <donri> isn't dir.grep lazy?

[11:42] *** MayDaniel joined
[11:43] <flussence> yes but it still has to read the entire directory into perl6 to figure out which ones to throw away

[11:44] <donri> but if test allows perl stuff like regex?

[11:45] <flussence> depends on the implementation

[11:46] <flussence> it can create a regex callback to pass to scandir or do it at whatever level is appropriate

[11:47] <donri> hokay

[11:47] <flussence> the point is that a specialised interface can be optimised easier than a general one

[11:47] <donri> sure

[11:48] <donri> I mostly agree with the Zen of Python: Consistency is good, but practicality beats purity.

[11:49] *** tzhs joined
[11:49] <flussence> that sounds like a specialised case of TMTOWTDI :)

[11:49] <donri> Yea I'm agreeing less lately with the "one way to do it"

[11:50] <donri> Well, it only says one *obvious* way, which is still a good thing

[11:50] <flussence> (there's more than one way to do it wrong...)

[11:51] <donri> :D

[11:51] *** masonkramer left
[11:51] *** masonkramer joined
[11:51] <donri> http://docs.pylonsproject.org/projects/pyramid/1.0/designdefense.html#pyramid-provides-more-than-one-way-to-do-it

[11:52] *** masak joined
[11:52] <masak> guten apr√®s-midi, zebras.

[11:52] <flussence> o/

[11:52] <arnsholt> Hey masak 

[11:52] <bacek> o/

[11:54] <donri> Perl 6 seems to usually provide an obvious way to do it, from what I've seen so far.

[11:54] <donri> While still verily TIMTOWTDI

[11:55] <arnsholt> masak: Read your latest blog post with interest last night

[11:55] <donri> Though I think the point of "one obvious way to do it" is more for reading code than writing it

[11:56] <arnsholt> It was especially fitting considering I was discovering quite a few of the ways Prolog exception handling can be done wrong =)

[11:56] <donri> Easier to follow others' code if they use obvious solutions

[11:57] <donri> But Perl 6's expressiveness is usually intentional, not hacked on top of the language as Ruby people like to do (&:foo for example)

[11:58] <donri> So I think WhateverCode for example is still an "obvious solution" even though there are many other ways to do the same

[11:58] <donri> (Am I rambling?)

[11:58] <masak> arnsholt: nice to hear ;)

[11:58] *** volpe left
[11:59] <masak> arnsholt: come to think of it, PGE/GGE also checks what went wrong when things went wrong in their test suites.

[12:00] <arnsholt> Probably a good idea. I try to make my tests robust

[12:00] <arnsholt> But since it's Prolog, a failing test often means that the test program starts backtracking all over the place =)

[12:01] <arnsholt> Which results in weirdness. But then the TAP harness will throw a fit, at least

[12:01] <donri> TAP: I'm the author of a Python testing framework, would it benefit from a TAP outputter?

[12:02] <donri> Sorry for the channel hijack ;)

[12:03] <flussence> well, I've been running my perl6 tests with a test harness that was never designed for perl6, so I'd say it's a good idea :)

[12:03] <arnsholt> That's a good question. But primarily one for the Python community I think

[12:04] <donri> Then I can codename the release "Tap dancer"

[12:06] *** tomaw joined
[12:07] *** Hackbinary left
[12:15] *** Mowah left
[12:21] *** agentzh left
[12:26] <masak> donri: sometimes I'm surprised that TAP isn't more widely adopted in other language communities. it's such a simple, straightforward protocol.

[12:28] <arnsholt> Yeah, I really like it as well. The most important part is that it has an extremely low startup cost

[12:28] <arnsholt> All you need is to be able to run a program and write to a terminal

[12:29] <moritz_> and you don't need an XML writer :-)

[12:30] <arnsholt> TAP really was an asset for my Prolog project, especially in the fledgling state it's in

[12:30] <arnsholt> s/was/is

[12:30] <masak> in the past few years, I've picked up some Java testing framework or other, looked at its API, and then gone "screw it" and re-implemented a subset of TAP.

[12:30] <arnsholt> I don't have all the needed control structures well-implemented enough to be able to reliably test all in Prolog

[12:30] <masak> it's happened three or four times.

[12:31] <moritz_> masak: one would think that the second time, you have made the reimplementation reusable :-)

[12:31] <masak> hm, maybe I did. don't remember :P

[12:32] <masak> "copying over to the new project and modifying the copy" counts as re-use, right? :P

[12:32] <moritz_> to the first order, yes :-)

[12:32] <arnsholt> testanything.org lists two TAP libs for Java, but only one looks really useful

[12:32] <arnsholt> tap4j

[12:33] <masak> ooh

[12:38] *** simon___ joined
[12:39] *** gfldex left
[12:43] *** cjk101010 left
[12:43] <masak> one of the search hits that led people to my blog: "find out if a point is in a polygon with perl" 

[12:43] <masak> \o/

[12:43] <masak> another: "the looting of manila" :P

[12:44] <moritz_> masak is having fun with log file analysis :-)

[12:44] *** xinming left
[12:45] <masak> yeah, sometimes when I remember that I have them. :)

[12:45] *** xinming joined
[12:51] *** mtk left
[12:57] <masak> "can it be seen different ways by different people? frankenstein" -- someone must've been either disappointed, or shocked, or both. http://strangelyconsistent.org/blog/perl-6-the-frankensteins-monster-of-operators

[12:59] <mux> I have to say it seems Perl 6 went a bit operator-crazy; and coming from someone deep in haskell-land, I think that tells a lot

[12:59] <mux> while I don't know them very well, it seems to me that the so-called hyper-operator would have been advantageously replaced by the usual functional combinators

[13:00] *** mtk joined
[13:00] <moritz_> but then you'd have to write &infix:<+> or &[+] to refer to a simple addition

[13:01] <masak> mux: the hyper operators *are* functional combinators.

[13:01] <masak> it's just a matter of representing them as meta-operators.

[13:01] <masak> by the way, is there any reasonable use for [[+]] ?

[13:02] <mux> masak: yes, they are combinators; my point is that I would have just had functions for those

[13:02] <masak> (since [+] already recurses, I mean)

[13:02] <moritz_> std: 1 [+] 2

[13:02] <mux> moritz_: I don't know about that

[13:02] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[13:02] <masak> mux: they are sugar for functions.

[13:02] <huf> does the actual name matter that much? it's a rose by any other name

[13:02] *** gfldex joined
[13:02] <mux> masak: yes, they are infix functions. still, you get my point, I hope.

[13:03] <masak> huf: I'd rather write 'a + b' than 'add-numbers(a, b)'

[13:03] <mux> infix functions of arity 2 if we want to be extra pedantic

[13:03] <huf> masak: yeah, i didnt mean that well-chosen names dont matter, 

[13:03] <masak> mux: I think I get your point.

[13:03] <huf> rather, why do people expect the name of everything to match \w+?

[13:03] <mux> masak: but would you rather write zipWith (+) xs ys or xs <<+>> ys or whatever the hyper-operator for this is?

[13:03] <masak> my point is that the hyperops are well-chosen names.

[13:03] *** Vlavv left
[13:03] <moritz_> it' nicer to write  @a Z+ @b  than  zipwith(&[+], @a; @b)

[13:03] <mux> ah, Z+

[13:04] <masak> mux: I think I prefer the latter.

[13:04] <mux> moritz_: well, it's true that Perl's syntax for function application makes this a bit messy

[13:04] <moritz_> mux: that's why we have meta operators :-)

[13:04] <masak> right. they're "just" sugar.

[13:04] <mux> anyways, it's not like I think this is a major problem or anything

[13:04] <masak> but they're sugar in the right place.

[13:05] <mux> so, for instance, Z+ makes sense mostly because it is so ugly to write &[+] :-)

[13:05] <mux> now, if I could write &[+] in a less noisy way...

[13:07] <moritz_> then you'd be programming haskell :-)

[13:07] *** pmurias joined
[13:08] <moritz_> don't they use `+` for that?

[13:08] <pmurias> no

[13:08] <pmurias> they use `foo` to make an op out of a function

[13:08] <mux> yeah, it's (+)

[13:09] <moritz_> ah, right

[13:09] <mux> you enclose operators in brackets to use them prefix

[13:09] <mux> and inversely, you enclose functions in backticks to make them infix

[13:09] <pmurias> what i dislike about hyperops is that we have both a bunch of hyperops and a bunch of higher order functions

[13:09] <mux> ie 3 `elem` [1..10] == True

[13:10] * mux starts a rakudo build for great justice

[13:12] <mux> what, finished already?!

[13:16] <donri> Does Perl 6 have something like Haskell `foo`?

[13:17] *** Vlavv joined
[13:17] *** stifynsemons joined
[13:18] <donri> Surprised me that e.g. [say] 1,2,3 doesn't work

[13:19] <donri> or for 1,2,3 &say

[13:19] <huf> wouldnt [say] .... expand to 1 say 2 say 3 ?

[13:20] <huf> which is nonsense

[13:20] <donri> true, bad example

[13:22] *** orafu joined
[13:25] <jnthn> Operators have a bunch of associated meta-data that lets us know what makes sense to use in a meta-operator.

[13:26] <masak> what's nice about the meta-data is that it's the *same* data that the parser uses.

[13:26] *** nymacro left
[13:26] <masak> thus, to learn Perl 6 is in a sense to learn how to make a programming language.

[13:26] <masak> it's very meta.

[13:31] *** jaldhar left
[13:36] <mathw> Well, kind of

[13:36] <mathw> I do like the way Perl 6 doesn't shovel the details of things like how operators work under the carpet

[13:36] <mathw> you can pick them up and play with them right there in Perl 6

[13:37] <mathw> quite haskellish :)

[13:38] *** skangas left
[13:38] *** skangas joined
[13:38] *** pmurias left
[13:41] *** uvtc joined
[13:43] *** plainhao joined
[13:49] <masak> I see it play out in a couple of places in the language.

[13:49] <donri> rakudo: say ([,] [1,2,3]).WHAT

[13:49] <donri> say WHAT!

[13:49] <p6eval> rakudo 6f9116: OUTPUT¬´Parcel()‚ê§¬ª

[13:49] <donri> I love it when stuff is not just syntax

[13:49] <masak> someone wants to muck with the OO system. Perl 6 says "here's how I do things through MOPs. feel free to tinker around".

[13:50] <masak> someone wants to muck with sublanguages. Perl 6 goes "here are the primitives I use, things like grammars and operators and ASTs. feel free to extend and subclass as much as you want."

[13:51] <masak> same thing with metaops. all the components for making a new one are already expressen through the language.

[13:51] <masak> in fact, the language has evolved around those concepts.

[13:51] <daxim> I want "dynamic views" on the source.  one view is source code, another one class diagrams, another one flow control boxes.

[13:51] <daxim> or whatever people can come up with how to media-lise the underlying abstract source

[13:52] <daxim> programming is still so primitive :(

[13:53] <masak> daxim: have you come across Boomerang and lenses yet?

[13:53] <daxim> nope

[13:53] <masak> that sounds like it could be the missing piece of that puzzle.

[13:53] *** awoodland joined
[13:53] <masak> I would like such views much better if they were intelligent enough to feed changes back to the model.

[13:53] <masak> lenses give you that.

[13:58] <pyrimidine> rakudo: (1,2,3)>>.say

[13:58] <p6eval> rakudo 6f9116: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[14:00] <masak> pyrimidine: yes, that works. but don't do that unless you really don't care about the order of the output.

[14:00] <masak> rakudo: .say for 1,2,3 # guarantees the order

[14:00] <p6eval> rakudo 6f9116: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[14:01] <pyrimidine> yeah, that's what I was thinking as well, possibly running in parallel

[14:01] <masak> indeed.

[14:01] * pyrimidine now just needs a keyboard shortcut for french quotes :)

[14:01] <masak> it doesn't in Rakudo (yet), but it could, and then you'd have introduced undefined behaviour.

[14:02] <pyrimidine> yep

[14:02] <masak> ^K > > in vim.

[14:02] <masak> C-u \ latin-1-postfix > > in Emacs.

[14:02] <masak> er, C-u \ latin-1-postfix RET > > in Emacs.

[14:03] * pyrimidine likes the vim form better

[14:03] <mathw> compose > > if you're running X and have a compose key in your keyboard layout

[14:03] * mathw likes compose keys

[14:04] <donri> I predict `say .WHAT` will be a common debugging idiom

[14:04] <masak> it already is :)

[14:05] <moritz_> or .perl

[14:05] <masak> say .perl is useful, too.

[14:05] <moritz_> eveny  say :$x.perl

[14:05] <moritz_> s/y//

[14:05] <masak> I tend to do say ($value1, $value2, $value3).perl a bit, too.

[14:05] <donri> But those are not funny

[14:06] <masak> oh, you wanted punniness? :P

[14:06] <uvtc> With Emacs, "M-x ucs-insert bb <Ret>" seems to provide a ª

[14:07] <moritz_> all these emacs users must love typing...

[14:07] <masak> warning! non-utf8 character detected! :)

[14:07] <masak> uvtc: your client seems to be on latin-1.

[14:07] <masak> moritz_: actually, much of it gets folded in by tabbing.

[14:08] <masak> the tabbing in M-x is really good, and customizable.

[14:08] <uvtc> The minibuffer pointed out to me that "C-x 8 RET bb RET" also works.

[14:08] <daxim> compose, >, >

[14:09] <masak> uvtc: cool!

[14:09] <daxim> running emacs without taking advantage of X is‚Ä¶ counter-productive

[14:09] <uvtc> masak: I'm using xchat. (...looking for pref to tell it to use utf-8 encoded unicode...)

[14:10] <daxim> http://xchat.org/encoding/

[14:10] <uvtc> ´hm...ª

[14:11] <uvtc> daxim: thanks for the link!

[14:12] <masak> can anything be done about the intermittent failure in t/spec/S02-builtin_data_types/instants-and-durations.t ?

[14:13] <moritz_> yes.

[14:14] <donri> Wouldn't it be better if .perl was implied in the interactive rakudo

[14:14] <moritz_> nope

[14:14] <donri> why?

[14:14] <moritz_> some .perl output is pretty huge

[14:14] <moritz_> for example from nested match objects

[14:14] *** fhelmberger joined
[14:15] <donri> so then you add a say

[14:15] <moritz_> then you first get 20 pages full of output

[14:15] <moritz_> because you didn't remember to add a say()

[14:16] *** uvtc left
[14:16] *** plobsing left
[14:16] <donri> I guess .perl isn't exactly like Ruby's .inspect or Python's repr()

[14:16] *** gimix left
[14:17] *** uvtc joined
[14:17] <uvtc> ¬´test¬ª

[14:17] <uvtc> ¬´test2¬ª

[14:18] *** masonkramer left
[14:19] <masak> uvtc++

[14:19] <donri> Is there something more like repr() then?

[14:20] <moritz_> what does repr() do?

[14:20] <masak> moritz_: in all fairness, the "lots of output" scenario could (and maybe should) be caught before outputting screenfuls of stuff.

[14:21] <donri> Represent what an object is as a string, but not string adaption

[14:21] <moritz_> donri: what does that mean?

[14:23] <donri> moritz_: Usually either like .perl, or for complex/large objects something less ambiguous than string adaption but not valid code, usually some variant of <TypeName extra info>

[14:23] *** Vlavv left
[14:24] <moritz_> hm, we have a .dump method on Match objects which do roughly that

[14:24] <donri> This works on anything though

[14:24] *** rhr left
[14:24] <donri> By calling __repr__ on the object, either overridden or inherited from "object"

[14:25] <moritz_> that's how .perl works too

[14:25] <donri> <__main__.Foo object at 0x7ff3fa5c2bd0>  # instance of custom noop class

[14:26] <donri> Method 'perl' not found for invocant of class 'FileHandle'

[14:26] <moritz_> rakudo: class A { }; say A.new

[14:26] <p6eval> rakudo 6f9116: OUTPUT¬´A()<0x3cf22f0>‚ê§¬ª

[14:26] <moritz_> donri: well, you can't serialize file handles. Still it should give something better

[14:26] <donri> That's .Str though right?

[14:27] <donri> moritz_: Yea, that's the point.

[14:27] <moritz_> that's .Str, yes

[14:27] *** Axius joined
[14:27] <moritz_> so... .Str does the same as python's repr by default?

[14:27] <donri> Python: <open file 'Perl 6/002.pl', mode 'r' at 0x7fe5ebb83c90>

[14:28] <donri> moritz_: .Str seems more like str() in Python

[14:29] <donri> repr() is more for debugging and str() for adaption/coercion

[14:30] <donri> So, more like .perl but sensible for non-constant objects like file handles and complex objects like custom classes

[14:30] *** tzhs left
[14:31] <donri> .inspect in Ruby is the same as repr()

[14:31] *** shortcircuit joined
[14:31] <uvtc> moritz_: what are you using to syntax highlight Perl 6 snippets on your blog?

[14:32] <moritz_> uvtc: Text::VimColor

[14:32] <moritz_> + perl6.vim

[14:33] <uvtc> moritz_: Ah. Thanks.

[14:33] <uvtc> Incidentally, I notice that the Perl 6 Rosetta Code samples are syntax highlighted.

[14:33] <uvtc> The site says they use GeSHi.

[14:33] <donri> So do you agree that something more similar to repr and inspect might be useful, and if so what might should it be called?

[14:33] <uvtc> Though I don't see Perl 6 listed in their Supported Languages list.

[14:33] <moritz_> I think shortcircuit adapted the p5 hilighter a bit

[14:34] *** wtw left
[14:34] <moritz_> donri: I don't see why .perl shouldn't be up to the task, when modified to give sensible output on non-serializable data

[14:35] <donri> moritz_: <moritz_> some .perl output is pretty huge

[14:35] <uvtc> moritz_: I see. Thanks.

[14:36] <donri> The point is that defaulting to .Str for the interactive shell is bad, but you say defaulting to .perl isn't good either

[14:36] <moritz_> I don't see why defaulting .Str is bad per se

[14:36] <donri> 1, "1" and [1] all output the same

[14:36] <donri> It's confusing.

[14:37] <donri> And then sometimes you have to add parenthesis for .perl

[14:37] <moritz_> well, 1, "1" and [1] also behave similarly

[14:37] *** Vlavv joined
[14:38] <donri> Still, rather confusing for exploration as a beginner

[14:38] <donri> At least some way to make it default to .perl would be useful

[14:38] <moritz_> but maybe a case could be made for a .pretty method that re-dispatches to .perl by default

[14:38] <shortcircuit> moritz_: I didn't personally do anything with the p6 highlighter implementation. I started writing a langfile for it, but got pulled aside into other things and forgot.

[14:39] <donri> .pretty sounds like it implies formatted .perl

[14:39] *** mtk left
[14:39] <donri> e.g. indentation and line wrapping

[14:39] <moritz_> shortcircuit: so are you using the p5 one right now?

[14:39] <donri> which might be a good thing to have too

[14:39] <TimToady> maybe we should have .python and .ruby methods too, which is why we have a .perl method, after all... :)

[14:40] <donri> :D

[14:40] <shortcircuit> moritz_: I don't think so; each language tag name goes to a separate rules file. I'll look to see what the story is, though. Sec.

[14:40] <donri> A Perl 6 lexer for Pygments would be useful

[14:40] <donri> Used on GitHub and many others

[14:41] <moritz_> agreed

[14:41] <moritz_> donri: want to write one?

[14:41] <donri> Not really, but I want one written, which may or may not lead to something

[14:42] <shortcircuit> FWIW, the highlighter on RC doesn't do [much] actual syntactic analysis. I think its awareness is limited to whitespace and some custom per-language regex rules.

[14:42] <TimToady> could add a switch to viv to emit various highlighter languages

[14:42] <arnsholt> donri: A lexer for Perl 6 isn't an impossible task

[14:42] <shortcircuit> Ah, yeah. Looks like the perl6 language file was adapted 2009/12/25 from the existing Perl5 language file.

[14:42] <arnsholt> I think, at least

[14:43] <masak> :)

[14:43] <donri> resources for me or whoever: http://pygments.org/docs/lexerdevelopment/  and  https://bitbucket.org/birkenfeld/pygments-main/src/2f2a9d7bea1c/pygments/lexers/agile.py#cl-811

[14:43] <shortcircuit> moritz_: ^^

[14:43] *** mtk joined
[14:43] <arnsholt> And you can probably get a fair amount of inspiration from Rakudo and STD's grammars

[14:43] <moritz_> shortcircuit: thanks

[14:43] <masak> lexing double-quoted strings is about as hard as parsing double-quoted strings.

[14:44] <moritz_> and a proper lexer must keep track of terms vs. operators

[14:44] <moritz_> so it needs a symbol table too

[14:44] <masak> and LTM.

[14:44] <donri> Is that important for simple syntax highlighting?

[14:45] <moritz_> I guess it can cheat wrt LTM

[14:45] <TimToady> if a highlight language is turing complete you could write a Perl 6 VM in it...  :)

[14:45] <shortcircuit> moritz_: If you're interested in the specifics: http://geshi.svn.sourceforge.net/viewvc/geshi/trunk/geshi-1.0.X/src/geshi/perl6.php?revision=2430&view=markup

[14:45] <masak> donri: depends how much you care about it making mistakes.

[14:45] <zenog> One question about Rakudo Star: Is there a reason why there is no readline support?

[14:45] *** stifynsemons left
[14:45] <masak> zenog: there is readline support.

[14:45] <moritz_> donri: well, if it doesn't keep track of term vs. operators, it doesn't get regex boundaries right

[14:46] <zenog> masak: Hm.

[14:46] <donri> zenog: install libreadline-dev

[14:46] <uvtc> shortcircuit++

[14:46] <uvtc> shortcircuit: thanks

[14:46] <moritz_> and then configure rakudo again

[14:46] <moritz_> and parrot

[14:46] <moritz_> well, the other way round :-)

[14:46] <donri> moritz_: is that true for perl5 too?

[14:46] <moritz_> donri: yes

[14:47] <zenog> donri: Thanks, did not have that ...

[14:47] <donri> i mean if https://bitbucket.org/birkenfeld/pygments-main/src/2f2a9d7bea1c/pygments/lexers/agile.py#cl-811  is enough, maybe it's enough to adapt that

[14:47] <donri> that's for perl5

[14:47] <shortcircuit> uvtc: rosettacode.org is used as a guinnea pig/testing environment for BenBE (the guy behind GeSHi) to get real testing and coverage, so it tends to get patches and updates before official releases.

[14:47] <zenog> moritz_: Devel::REPL works for me.

[14:47] <shortcircuit> Also saves me from having to maintain that particular nightmare. :)

[14:48] <uvtc> shortcircuit: ha. :)

[14:48] <masak> donri: by experience, I'd say a syntax highlighter that can't correctly find the ends of strings is almost completely worthless.

[14:48] *** MayDaniel left
[14:48] <donri> masak: so is the highlighting of perl5 on github etc useless?

[14:48] <masak> donri: I don't know. I haven't paid much attention to it.

[14:49] <donri> I even find it helpful for perl *6* :P

[14:49] <masak> I generally pay attention when I have to edit code in it :)

[14:50] <donri> yea but pygments isn't really for editors

[14:50] <donri> more for pastebins, blogs, source previews, documentation

[14:51] <masak> it would seem to me that the basic problem is the same.

[14:51] <masak> but I might be mistaken.

[14:51] <donri> point is that it's not end of the world if it gets something complicated and rare wrong

[14:52] <uvtc> I use Pandoc mostly for writing documentation. It provides source code highlighting for a number of languages.

[14:52] *** ymasory joined
[14:53] <masak> donri: for some reason, cperl-mode does a really decent job syntax-highlighting Perl 6, even though it wasn't designed for it.

[14:53] <masak> donri: my guess is that they spent a good deal of effort thinking about failure modes, and it paid off.

[14:53] <donri> Likely pandoc uses Kate's parser

[14:53] <uvtc> I think it uses "highlighting-kate" to do syntax highlighting.

[14:54] <uvtc> donri: yes

[14:55] *** mkramer joined
[14:55] <donri> I wonder if a generic Kate lexer could be written for Pygments

[14:55] <donri> uvtc: does it do perl6?

[14:56] <uvtc> donri: no

[15:01] <uvtc> Oh, highlighting-kate is a Haskell lib written by the author of Pandoc. http://johnmacfarlane.net/highlighting-kate/

[15:01] <zenog> Another question: Is there something equivalent to my "@sorted = @unsorted.sort: { .lc };", but for hash keys instead of methods?

[15:01] *** Chillance left
[15:02] <moritz_> .sort: { %lookup{$_} }

[15:04] <donri> uvtc: yea but it's merely a binding to the parser used by the kate editor

[15:04] <uvtc> So, it would seem that what's required for highlighting-kate to support Perl 6 is a Kate description file for it.

[15:04] <zenog> moritz_: Thanks!

[15:07] *** kaare_ left
[15:09] <zenog> moritz_: Oops I guess I meant something different: I have hashes in the array, and I always want to get the value denoted by a certain key.

[15:10] <zenog> e.g. this does not work:  ( { key => 1 }, { key => 2 }).max: { $_{key} 

[15:10] <zenog> neither this:  ( { key => 1 }, { key => 2 }).max: { $_->{key} 

[15:10] <zenog>  (forgot the closing })

[15:11] <masak> rakudo: my @a = { foo => 2 }, { foo => 1 }; say (@a.max: { .<foo> }).perl

[15:11] <p6eval> rakudo 6f9116: OUTPUT¬´{"foo" => 2}‚ê§¬ª

[15:11] <moritz_> rakudo: say ( { key => 1 }, { key => 2 } ).max: { .<key> }.perl

[15:11] <p6eval> rakudo 6f9116: OUTPUT¬´Unable to handle non-closure Ordering yet‚ê§  in 'Any::max' at line 1567:CORE.setting‚ê§  in main program body at line 22:/tmp/sQWHSo_c_3‚ê§¬ª

[15:11] <moritz_> rakudo: say ( { key => 1 }, { key => 2 } ).max( { .<key> }).perl

[15:11] <p6eval> rakudo 6f9116: OUTPUT¬´{"key" => 2}‚ê§¬ª

[15:11] <moritz_> ah, masak++ was faster

[15:11] <moritz_> aka "seems to work here"

[15:12] <moritz_> zenog: the problem is that you didn't read the error message, I guess :-)

[15:12] <zenog> yeah!

[15:12] <moritz_> rakudo: key

[15:12] <p6eval> rakudo 6f9116: OUTPUT¬´Could not find sub &key‚ê§  in main program body at line 22:/tmp/xIIsY4Qpml‚ê§¬ª

[15:12] <moritz_> my %h = key => 2; %h{key}

[15:12] <moritz_> rakudo: my %h = key => 2; %h{key}

[15:12] <p6eval> rakudo 6f9116: OUTPUT¬´Could not find sub &key‚ê§  in main program body at line 22:/tmp/L8ZpxUilBu‚ê§¬ª

[15:12] <mathw> nooooo

[15:12] <mathw> take away the barewords

[15:12] <moritz_> rakudo: my %h = key => 2; %h{'key'}

[15:12] <mathw> I'll talk!

[15:12] <p6eval> rakudo 6f9116:  ( no output )

[15:13] <zenog> moritz_: Well. The problems was more that I could not make anything out of it.

[15:13] <moritz_> rakudo: my %h = key => 2; %h<key>

[15:13] <p6eval> rakudo 6f9116:  ( no output )

[15:13] <moritz_> std: my %h; %h{key}

[15:13] <p6eval> std 625303c: OUTPUT¬´ok 00:01 120m‚ê§¬ª

[15:13] <zenog> rakudo:  ( { key => 1 }, { key => 2 }).max: { .<key> }

[15:13] <p6eval> rakudo 6f9116:  ( no output )

[15:13] <moritz_> std: key

[15:13] <p6eval> std 625303c: OUTPUT¬´ok 00:01 117m‚ê§¬ª

[15:13] <moritz_> std: fooobar

[15:13] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§ 'fooobar' used at line 1‚ê§Check failed‚ê§FAILED 00:01 117m‚ê§¬ª

[15:14] *** risou joined
[15:14] <moritz_> why is key() a known routine to std?

[15:14] <moritz_> what does it do?

[15:14] <zenog> rakudo:  say ( { key => 1 }, { key => 2 }).max: { .<key> }.perl

[15:14] <p6eval> rakudo 6f9116: OUTPUT¬´Unable to handle non-closure Ordering yet‚ê§  in 'Any::max' at line 1567:CORE.setting‚ê§  in main program body at line 22:/tmp/PJ0wdKrBJA‚ê§¬ª

[15:14] <moritz_> precedence.

[15:14] <mathw> zenog: I think it's parsing it differently to how you want it to, and that's why it works oddly.

[15:15] <moritz_> rakudo: say { .key }.perl

[15:15] <zenog> Hm. It works on the Rakudo Star I have installed, but not here on the channel.

[15:15] <p6eval> rakudo 6f9116: OUTPUT¬´{ ... }‚ê§¬ª

[15:15] <masak> std: value

[15:15] <p6eval> std 625303c: OUTPUT¬´ok 00:01 117m‚ê§¬ª

[15:16] <mathw> this string doth not a good sorting routine make

[15:16] <zenog> this here works with Rakudo Star 2011.01: (( { key => 1 }, { key => 2 }).max: { .<key> })<key>

[15:17] <moritz_> rakudo: (( { key => 1 }, { key => 2 }).max: { .<key> })<key>

[15:17] <masak> IIRC, the syntax max: { ... }.perl *should* work by spec, but doesn't in Rakudo yet.

[15:17] <p6eval> rakudo 6f9116:  ( no output )

[15:17] <moritz_> rakudo: say (( { key => 1 }, { key => 2 }).max: { .<key> })<key>

[15:17] <p6eval> rakudo 6f9116: OUTPUT¬´2‚ê§¬ª

[15:17] <moritz_> zenog: and it works here too.

[15:17] <moritz_> star: say (( { key => 1 }, { key => 2 }).max: { .<key> })<key>

[15:17] <p6eval> star 2010.09:  ( no output )

[15:17] <moritz_> hm

[15:17] <moritz_> it's a bit old-ish :-)

[15:18] <zenog> moritz_: The one that returned the hash instead of the value did not ...

[15:18] <zenog> moritz_: But that could be the version then ;-)

[15:19] *** cotto joined
[15:21] *** mfollett joined
[15:27] *** stifynsemons joined
[15:31] *** sftp joined
[15:31] <sorear> good * #perl6

[15:31] <sorear> zenog: hi!

[15:32] <sorear> zenog: are you still going to do 1.5?

[15:34] *** perlpilot joined
[15:34] <zenog> sorear: Same answer as last time :-(

[15:42] <sorear> masak: perl6.vim is fine for static higlighting, but is unusably slow if I want to type code in the middle of STD.pm6.  400+ ms lag per character.  Usually I use :set ft=perl while editing...

[15:43] <sorear> zenog: I'm planning to do it myself today, sorry.

[15:43] *** V15170R joined
[15:44] *** mfollett left
[15:47] <zenog> sorear: No problem, I'd be actually happy about it.

[15:48] <sorear> TimToady: have you read http://use.perl.org/~Alias/journal/35508 yet?

[15:48] *** Axius left
[15:51] *** mfollett joined
[15:51] *** flw_ joined
[15:52] *** mfollett left
[15:53] *** mfollett joined
[15:54] *** flw_ is now known as flw

[15:54] *** flw left
[15:55] *** kaare_ joined
[15:55] <TimToady> sorear: um, yeah, I read it something like 3 years ago...

[15:57] <moritz_> .oO( Alias scares the hell out of me ) :-)

[15:57] *** risou_ joined
[15:58] <perlpilot> moritz_: Must be an Australian thing  ;)

[15:59] <perlpilot> (unless you are one of the few people who isn't scared by Damian)

[15:59] *** bemjb joined
[15:59] <uvtc> I've seen a lot of "Perl 6 scares me" comments online, but most seem to be centered around syntax (ex. sequence ops, meta ops, hyper ops).

[15:59] <masak> Perl 6 has a Smalltalk-esque streak of not being handleable by anything other than Perl 6. I guess that's what Alias is talking about, wrt parsing.

[15:59] <masak> (and it's true)

[15:59] <flussence> aaaahhhh! new things! panic!

[16:00] <moritz_> perlpilot: I never met Damian

[16:00] <perlpilot> I'm giving a lightning talk later today to some college students on a few of the things I think are cool in Perl 6.  I'll see how scared they are vs. excited.

[16:00] <V15170R> i kinda like the idea behind grammars but i don't quite get it... 

[16:00] *** risou left
[16:00] <V15170R> if i want to parse an XML, grammars should be the way to do it?

[16:00] <moritz_> yes

[16:00] <perlpilot> V15170R: A way.  yes

[16:01] <uvtc> I think people will be a lot less frightened of Perl 6 if they first see the "baby Perl 6" way of doing things, before being shown the fancier acrobatics that are possible.

[16:02] <uvtc> That is, the "Perl 6 as a better Perl 5" way of doing things.

[16:02] <perlpilot> uvtc: people are strange.

[16:03] <colomon> V15170R: are you familiar with things like lex, yacc, bison, antlr?

[16:03] <perlpilot> half of them will be scared and the other half will be excited.  When you show them baby perl 6, half of them will be happy and half of them will ask "that's it?"

[16:03] <donri> V15170R: if you're parsing with "pure perl 6", grammars is the best way to handle complexity.

[16:03] <masak> V15170R: people tend to want to use gramamrs for parsing XML. and while grammar are very-well suited for parsing XML (much better than regexes alone), it's probably not the best way to parse XML. :)

[16:04] <masak> depending on your requirements, of course.

[16:05] <donri> Binding libxml2 is perhaps the "best" way

[16:05] <uvtc> perlpilot: The impression I get online is that a non-trivial number of people see some Perl 6 syntax and think/write "Yikes! Those Perl 6 people have gone off the deep end".

[16:06] <[Coke]> lots of people think that about much of perl6.

[16:06] <TimToady> someone has to go off the deep end occasionally

[16:06] <donri> When I see Perl 6 code, even before, my reaction was usually "that looks much more sane than Perl 5" (speaking as someone who don't really use Perl 5)

[16:07] <TimToady> yes, the deep end we go off of is (we hope) deeply sane

[16:07] <V15170R> no, colomon, i've never worked with those tools...

[16:07] *** plobsing joined
[16:08] <donri> TimToady: :D

[16:09] <colomon> V15170R: ah.  Well, grammars amount to making that sort of tool an integral part of the language, instead of an ugly, hard-to-use add-on.

[16:09] <perlpilot> uvtc: greatness is rarely apprehended universally or even by a majority at first.  People need time to understand it.

[16:10] <[Coke]> perlpilot: haugtiness, however, is caught right out.

[16:10] <sorear> uvtc: the difference is that Alias has been vindicated by history

[16:10] * [Coke] thinks that might be missing an aitch.

[16:10] <uvtc> Quick example: the 99 bottles of beer RC sample. http://rosettacode.org/wiki/99_Bottles_of_Beer#Perl_6

[16:10] <sorear> "You end up with a language which is expressive as hell, but where the most sophisticated editor you can create is vi (with no syntax highlighting allowed)." # THIS IS MY LIFE TODAY

[16:10] <donri> I said the other day, it's probably easy to abuse Perl 6 ("Why Perl 6 scares the hell out of me") but probably also easier to write quality code with it vs others like perl5

[16:11] <donri> It's about culture and best practices

[16:11] <donri> An expressive language allows exploring and discovering good practices

[16:11] <uvtc> I think that scares people. It could use a simple "normal code" example shown first.

[16:11] <perlpilot> sorear: that's funny given Alias helped make Padre.

[16:11] <masak> sorear: mine too.

[16:12] <masak> but I do believe that Perl 6 allows for Eclipse-style refactoring. and I intend to explore that avenue at some point.

[16:12] <sorear> perlpilot: Alias' relationship to Padre is a good a-priori reason to trust him on toolchain issues

[16:12] <donri> I mainly use Python, which supposedly tries to keep you from abusing the language. But the reality is, you can abuse the shits out of Python; it's mainly culture that prevents people from doing so.

[16:12] * [Coke] doesn't know anyone who actually uses refactoring tools.

[16:12] <perlpilot> [Coke]: I use some of the simple ones available in Padre.

[16:12] * [Coke] tends to hand roll that. but then, I often use vi with no syntax highlighting.

[16:12] * colomon neither (what [Coke] said)

[16:13] <donri> The result instead is that when there's a proper use case for "abusing" Python, it might require what is arguably a hack

[16:13] <zenog> [Coke]: I use them for Perl, Java, and C#. It is way more productive than doing that by hand or search and replace. You never want to go back.

[16:13] <zenog> [Coke]: It is the same thing as with version control.

[16:13] <perlpilot> sorear: except that you're looking at a snapshot in time from before Padre existed.  :)

[16:13] *** byzas left
[16:13] <masak> uvtc: that is not at all how I'd implement "99 bottles" in Perl 6, fwiw.

[16:14] <colomon> I thought I established yesterday that using Z like that didn't work in Rakudo atm?

[16:14] <masak> uvtc: it's a very extravagant solution, in that it reaches for sequence operators and parallel looping.

[16:14] <masak> but it used to.

[16:14] <masak> as evidenced by the comment above that code.

[16:14] <zenog> Question: Is there a thing that I can call after BUILD, without having to rewrite BUILD?

[16:15] <sorear> Question not understood.

[16:15] <masak> ditto.

[16:15] <perlpilot> zenog: sounds like you want to .wrap BUILD ?

[16:15] <colomon> masak: when was Thousand Oaks?

[16:15] <masak> why wrap a submethod?

[16:15] <masak> colomon: dunno. a year or so ago?

[16:15] *** pigdude joined
[16:15] <TimToady> is this an XY problem?

[16:16] <masak> colomon: October 2009.

[16:16] <perlpilot> colomon: Oct  2009

[16:16] *** Patterner left
[16:16] <colomon> masak: ah, so alpha, then.

[16:16] <perlpilot> (I released it :)

[16:16] <colomon> perlpilot++

[16:16] <masak> perlpilot++

[16:16] <masak> colomon: yes. it worked on alpha.

[16:17] <zenog> perlpilot: Not sure.

[16:17] <perlpilot> zenog: Why do you want to call something after BUILD?

[16:18] *** Psyche^ joined
[16:18] *** Psyche^ is now known as Patterner

[16:18] <zenog> perlpilot: I just want to set some attributes depending on the value of some others.

[16:18] <uvtc> I think the Rosetta Code Perl 6 samples need to have both easily-digestible Perl-5-ish examples as well as more modern Perl-6-ish ones. Yes, I know, "well-volunteered".

[16:18] <zenog> perlpilot: Say the object gets passed some data, and some attributes are the statistics of that data.

[16:19] <zenog> perlpilot: Is there lazy building of objects in Perl 6, like in Moose?

[16:19] <flussence> .oO( vague project suggestion for 2011: make a faster vim )

[16:20] <dalek> niecza: dc52195 | sorear++ | lib/SAFE.setting:

[16:20] <dalek> niecza: Implement Capture.perl

[16:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/dc5219563d

[16:20] <dalek> niecza: c2ca536 | sorear++ | lib/CLRBackend.cs:

[16:20] <dalek> niecza: [clr] Generate verifiable code by default (these segfaults are getting irritating)

[16:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c2ca536fb7

[16:21] <perlpilot> zenog:  "lazy object building" is in my mental model of Perl 6, but I don't think anyone has implemented it

[16:22] *** V15170R left
[16:23] <zenog> perlpilot: Anyway, I coded around it ... just reimplemented BUILD from scratch.

[16:24] *** simon___ left
[16:24] <masak> rakudo: my $b = 2; sub b($b) { "$b bottle{$b == 1 ?? "" !! "s"} of beer" }; repeat while --$b { .say for "&b($b) on the wall", b($b), "Take one down, pass it around", "&b($b-1) on the wall", "" }

[16:24] <perlpilot> zenog: that sounds wrong.

[16:24] <p6eval> rakudo 6f9116: OUTPUT¬´2 bottles of beer on the wall‚ê§2 bottles of beer‚ê§Take one down, pass it around‚ê§1 bottle of beer on the wall‚ê§‚ê§1 bottle of beer on the wall‚ê§1 bottle of beer‚ê§Take one down, pass it around‚ê§0 bottles of beer on the wall‚ê§‚ê§¬ª

[16:24] <masak> there, that's my submission.

[16:25] *** domidumont1 left
[16:26] <masak> rakudo: my $b = 2; sub b($b) { "$b bottle{"s".substr($b == 1)} of beer" }; repeat while --$b { .say for "&b($b) on the wall", b($b), "Take one down, pass it around", "&b($b-1) on the wall", "" }

[16:26] <p6eval> rakudo 6f9116: OUTPUT¬´2 bottles of beer on the wall‚ê§2 bottles of beer‚ê§Take one down, pass it around‚ê§1 bottle of beer on the wall‚ê§‚ê§1 bottle of beer on the wall‚ê§1 bottle of beer‚ê§Take one down, pass it around‚ê§0 bottles of beer on the wall‚ê§‚ê§¬ª

[16:26] <flussence> {'s' if $b != 1}

[16:26] <masak> I could do it that way, but Randal Schwartz might shoot me :P

[16:26] <colomon> masak++

[16:26] <masak> flussence: that would give a Nil, I think.

[16:26] <donri> "In the case of variables, this means that in scripts and modules, lexical variables (√† la strict) are the default, but in those -e one-liners the default is package variables."  -- is there a "use nonstrict;"? :P

[16:27] <masak> donri: 'no strict'

[16:27] <flussence> hm

[16:27] <masak> donri: NYI in Rakudo.

[16:27] <donri> aha, what specifically is 'no'?

[16:27] <zenog> perlpilot: Well ... the code needs to run somehow ...

[16:27] <masak> donri: 'no' cancels out a 'use'.

[16:27] <donri> masak: does that work for anything?

[16:27] *** sftp left
[16:28] <masak> donri: to a first approximation, yes.

[16:28] <flussence> {"s"[$b==1]}

[16:29] <perlpilot> zenog: Are you talking about inheriting from another class except that the derived class wants to set some attributes based on the value of others?

[16:29] *** nymacro joined
[16:30] <masak> flussence: no .[] on Str.

[16:30] <zenog> perlpilot: No inheritance, I just want to have method to set up my data, i.e., implement the constructor myself.

[16:30] <flussence> rakudo: say ("s"[$_==1]).perl for 0..4

[16:30] <p6eval> rakudo 6f9116: OUTPUT¬´"s"‚ê§undef‚ê§"s"‚ê§"s"‚ê§"s"‚ê§¬ª

[16:31] <flussence> rakudo: say ("s"[$_==1]) for 0..4

[16:31] <p6eval> rakudo 6f9116: OUTPUT¬´s‚ê§s‚ê§s‚ê§s‚ê§¬ª

[16:31] * [Coke] gets his first perl6 bug sent to perl5-porters.

[16:31] <zenog> perlpilot: Ah, there is also new that I can define ... so forget what I said ...

[16:31] <flussence> rakudo: say "bottle{"s"[$_==1]}" for 0..4

[16:31] <p6eval> rakudo 6f9116: OUTPUT¬´bottles‚ê§.[Bool::True] out of range for type Str()‚ê§  in <anon> at line 1‚ê§  in <anon> at line 22:/tmp/6v3XUEO89o‚ê§  in main program body at line 1‚ê§¬ª

[16:31] <perlpilot> zenog: so, I don't understand in what context you're rewriting BUILD then.  IF it's your class, you already wrote BUILD and would just add a bit of extra code at the end.

[16:31] <flussence> oh, thought so

[16:31] <flussence> (and it looked so promising with perl6 -e ...)

[16:32] <flussence> rakudo: say "bottle{"s "[$_==1].trim}" for 0..4

[16:32] <p6eval> rakudo 6f9116: OUTPUT¬´bottles‚ê§Method 'trim' not found for invocant of class 'Failure'‚ê§  in <anon> at line 22:/tmp/1mapvnWJf2‚ê§  in main program body at line 1‚ê§¬ª

[16:32] <perlpilot> zenog: Also ... it's a good thing you said "no inheritance" because I had my "YOU'RE DOING IT WRONG" all ready to go if you hadn't  :)

[16:33] <masak> notice, people, how easily we get "bottle{"s"[$_==1]}". now write a lexer that finds the right ending " :)

[16:34] <TimToady> One-Pass Parsers "–Ø" Us!

[16:34] <masak> ;)

[16:34] *** neroxx joined
[16:34] <masak> Ya.

[16:35] <TimToady> Right you ·¥ö.

[16:37] <[Coke]> you square box, you. :P

[16:37] <perlpilot> zenog: you still may be doing it wrong if you're going to write your own .new()  BUILD is for "setting up your data"

[16:38] <zenog> perlpilot: Yeah but BUILD complains that the data does not exist.

[16:39] <zenog> Perl 6 may still not be the perfect thing for impatient people like me ;-)

[16:39] <masak> zenog: time for a nopaste!

[16:39] <masak> I tend to write my own .new when I want to override the way arguments are passed.

[16:41] <zenog> http://nopaste.info/5210b5d0b0.html

[16:41] *** estrabd_afk is now known as estrabd

[16:41] <zenog> You have all seen that beast already ;-)

[16:41] <zenog> sorry, it is not a minimal example

[16:42] <perlpilot> zenog: so, the stuff from lines 62-73 is what you want to happen at .new-time?

[16:42] <perlpilot> i.e. it would be in a BUILD?

[16:43] <masak> line 60 looks suspicious.

[16:43] *** s1n left
[16:43] <masak> first argument to .bless should be self.CREATE

[16:43] <masak> and then you need to | the %args

[16:43] <[Coke]> zeong;is it really teh IO that take 60s, or is it that plus the data manipulation?

[16:43] <zenog> masak: I "copied" it from the Perl 6 book.

[16:43] <perlpilot> [Coke]: I'd wager it's really the IO 

[16:44] <zenog> [Coke]: IO. Data manipulation is also _dead_ slow.

[16:44] <masak> zenog: huh.

[16:44] <[Coke]> even raw parrot IO ain't that slow, is it?

[16:46] <zenog> [Coke]: I am not sure whether it is actually the IO, or some slow-down due to problem with memory management etc.

[16:46] <zenog> [Coke]: to be honest, I have no idea ;-)

[16:47] <perlpilot> [Coke]: the slowness could come from the Perl 6 wrapper around the Parrot IO, but I've noticed that IO in Rakudo seems alt slower than it should as well.

[16:47] <perlpilot> s/alt/alot/

[16:47] <masak> s/alot/a lot/ :)

[16:48] <plobsing> there's stuff other than reading going on in those loops. instance creation and/or array.push could be the choke point.

[16:48] <zenog> plobsing: indeed

[16:48] <masak> http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html

[16:48] * [Coke] builds a copy of rakudo to play with this.

[16:49] <plobsing> zenog: You should try to isolate which of these is the problem. Try just reading, or reading + pushing, or reading + instantiating. Figure out where the cost is. I highly doubt IO accounts for all of it.

[16:50] <[Coke]> zenog: can you give me a URL to the dataset so I don't have to guess?

[16:50] <zenog> [Coke]: http://www.grouplens.org/system/files/ml-data.tar__0.gz

[16:51] <perlpilot> masak: We are the music makers and we are the dreamer of dreams.  :)

[16:52] <zenog> I now side-stepped the problem and do the computation of num_users/num_items it externally (out of the class code): http://nopaste.info/cd9e033893.html

[16:52] *** neroxx left
[16:53] <zenog> It is also more correct, because there may be new users/items in the test data, so I am basically not able to set it correctly just using the data that is passed to the object. So forget about that constructor issue ...

[16:56] <[Coke]> just saw 'perl6.1' go by in the install logs and was freaked out for a sec.

[16:57] <[Coke]> zenog: ... what's the command line invocation needed? takes 2 args, but help only mentions 1 file.

[16:58] *** risou joined
[16:58] <zenog> [Coke]: use the same file twice

[16:58] <zenog> [Coke]: don't use the complete file, but only say 1K or 10K lines ;-)

[16:58] <[Coke]> k.

[17:00] <[Coke]> No such attribute '@!rating_data' in class 'MatrixFactorization'

[17:00] <dalek> niecza: ca96dd2 | sorear++ | / (2 files):

[17:00] <dalek> niecza: Implement \(1) capture syntax

[17:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ca96dd2af3

[17:00] *** risou_ left
[17:01] <sorear> now I just need it to stop segfaulting

[17:02] <zenog> [Coke]: Try this one: http://nopaste.info/cd9e033893.html

[17:02] *** perlpilot left
[17:05] *** fhelmberger left
[17:09] <[Coke]> zenog: ok. that one's getting further...

[17:10] *** skangas_ joined
[17:10] <sbp> rakudo: my token abc { example };  say 'example' ~~ /<&abc>/

[17:10] <p6eval> rakudo 6f9116: OUTPUT¬´example‚ê§¬ª

[17:10] <sbp> why <&abc> there? why not <abc>?

[17:11] <sbp> http://rakudo.org/status doesn't mention this, it seems

[17:11] *** MayDaniel joined
[17:11] <[Coke]> so you can refer to it as abc when interrogating the match, I think.

[17:12] *** skangas left
[17:12] *** lopaway left
[17:12] *** robinsmidsrod left
[17:12] *** lopaway joined
[17:12] *** skangas_ is now known as skangas

[17:12] <[Coke]> whoops. misread S05.

[17:13] <[Coke]> S05 //"a leading & unambiguously calls a routine instead." 

[17:13] <sbp> rakudo: my token abc { example };  say 'example' ~~ /<abc>/

[17:13] <p6eval> rakudo 6f9116: OUTPUT¬´Method 'abc' not found for invocant of class 'Cursor'‚ê§  in <anon> at line 22:/tmp/isUu8Y2Afl‚ê§  in 'Cool::match' at line 2637:CORE.setting‚ê§  in 'Regex::ACCEPTS' at line 6202:CORE.setting‚ê§  in main program body at line 22:/tmp/isUu8Y2Afl‚ê§¬ª

[17:13] <sbp> a token is not a routine, no?

[17:13] *** robinsmidsrod joined
[17:14] *** s1n joined
[17:14] <jnthn> rakudo: my token abc { example };  say 'example' ~~ /<&abc>/

[17:15] <p6eval> rakudo 6f9116: OUTPUT¬´example‚ê§¬ª

[17:15] <jnthn> If you're finding it in the lexical scope rather than as a method, need to say so.

[17:15] <sorear> rakudo: say [\>] 1, 2;

[17:15] <p6eval> rakudo 6f9116: OUTPUT¬´Bool::TrueBool::False‚ê§¬ª

[17:15] <sorear> hi jnthn

[17:15] <jnthn> o/ sorear 

[17:15] <sbp> jnthn: than as a method of a grammar?

[17:16] <jnthn> sbp: Yeah. Though grammars are just classes really :)

[17:16] <sbp> gotcha, makes sense. thanks!

[17:16] <jnthn> And regex/token/rule are just methods with a different syntax on the inside. 

[17:17] *** awoodland left
[17:20] <TimToady> well, we're about to wander off from COSBI toward Africa, so it's likely a couple days till we have internet again

[17:20] <Tene> rakudo: grammar Foo { token fu { ^ f+ u+ $ } }; say 'fffffffuuuuuuuuuuu' ~~ /<&Foo::fu>/;

[17:20] <p6eval> rakudo 6f9116: OUTPUT¬´Null PMC access in invoke()‚ê§  in <anon> at line 1‚ê§  in 'Cool::match' at line 2637:CORE.setting‚ê§  in 'Regex::ACCEPTS' at line 6202:CORE.setting‚ê§  in main program body at line 22:/tmp/zQG25C_RKG‚ê§¬ª

[17:20] <jnthn> Crappy error, but it shouldn't work.

[17:20] <jnthn> TimToady: Have a safe journey

[17:21] <[Coke]> TimToady: have fun!

[17:21] <jnthn> Yes, that too :)

[17:21] <[Coke]> ... assuming it's that kind of trip.

[17:21] <TimToady> from time to time

[17:21] <[Coke]> .g COSBI

[17:21] <phenny> [Coke]: http://www.cosbi.eu/

[17:21] <Tene> jnthn: what's the right way to do that, then?

[17:22] <TimToady> y'all be good

[17:22] <Tene> jnthn: I mean, there's Foo.parse(,:rule<fu>), but then I can't do anything else inside my match.  Does that mean that I have to write a grammar that inherits from Foo?

[17:22] <TimToady> ciao &

[17:23] <jnthn> Tene: <Foo::fu> in theory should work, but I think pmichaud had some implementation questions/concerns about it.

[17:23] * sbp takes a peek at https://github.com/masak/perl6-literate

[17:23] *** pigdude left
[17:23] *** pigdude joined
[17:24] <Tene> Yeah, I remember that too.  I didn't know if that had been discussed further or not.

[17:24] *** rhr joined
[17:24] <sorear> I don't like <Foo::fu>; it falls apart if <fu> wants to use subrules expecting grammar Foo

[17:25] <sorear> [ :lang(Foo) <fu> ] makes more sense, and has the advantage of working in at least two implementations of p6regex

[17:25] <Tene> sorear: I think that was included in pm's concerns.

[17:25] <sbp> rakudo: grammar Foo { token fu { ^ f+ u+ $ } }; say 'fffffffuuuuuuuuuuu' ~~ /[ :lang(Foo) <fu> ]/;

[17:25] <Tene> rakudo: grammar Foo { token fu { ^ f+ u+ $ } }; say 'fffffffuuuuuuuuuuu' ~~ /[ :lang(Foo) <fu> ]/;

[17:25] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say 'fffff"‚ê§¬ª

[17:25] <p6eval> rakudo 6f9116: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say 'fffff"‚ê§¬ª

[17:25] <Tene> ^5 sbp

[17:26] <Tene> ‚Åµ might be better

[17:26] <sbp> heheh

[17:26] <sorear> niecza: grammar Foo { token fu { ^ f+ u+ $ } }; say 'fffffffuuuuuuuuuuu' ~~ /[ :lang(Foo) <fu> ]/;

[17:26] <p6eval> niecza v2-74-gc2ca536: OUTPUT¬´fffffffuuuuuuuuuuu‚ê§¬ª

[17:26] <Tene> :D

[17:27] *** justatheory joined
[17:28] *** kjeldahl left
[17:31] <colomon> sorear++

[17:33] *** qwkl joined
[17:33] <qwkl> hello

[17:33] <colomon> \o

[17:33] *** Bzek left
[17:34] *** V15170R joined
[17:34] <sorear> hello

[17:34] <qwkl> is this the correct syntax to pass-through an indeterminate number of arguments:

[17:34] <qwkl> -> *@args { g(|@args) }

[17:34] *** sftp joined
[17:35] <masak> qwkl: looks right.

[17:35] *** MayDaniel left
[17:35] *** stifynsemons left
[17:35] <sorear> qwkl: better to use -> |$args { g(|$args) }

[17:35] *** cdarroch joined
[17:35] *** cdarroch left
[17:35] *** cdarroch joined
[17:35] <sorear> a slurpy array will 1. not pass-through named arguments 2. lose parcel structure

[17:36] <sorear> suppose you have a call func(@a, @b) and a definition sub func(@x, @y) { ... }

[17:36] <sorear> using a slurpy in the middle breaks that

[17:36] <sorear> a capture won't

[17:36] <qwkl> thanks, I got it..

[17:36] <qwkl> rakudo: sub Y(&f) { my &g = do { f(-> |$args { g(|$args) }) } }; say Y(-> &fac { -> $n { $n > 1 ?? $n * fac($n - 1) !! 1 } })(6);

[17:36] <p6eval> rakudo 6f9116: OUTPUT¬´720‚ê§¬ª

[17:37] <qwkl> ^^ a Y combinator in Perl 6

[17:38] <sorear> You could probably make that more elegant with .assuming

[17:38] <colomon> woah, -> |$args already works in rakudo?  jnthn++

[17:39] <sorear> colomon: it hasn't worked basically forever?

[17:39] <sorear> rakudo: say ~[\>] 3,2,1,1,2,3

[17:39] <colomon> sorear: it's news to me.  I assumed you were doing something that only worked in niecza.

[17:39] <p6eval> rakudo 6f9116: OUTPUT¬´Bool::True Bool::True Bool::True Bool::False Bool::False Bool::False‚ê§¬ª

[17:39] <sorear> hah

[17:39] <sorear> sigs and stuff are a LOT further along in Rakudo atm

[17:40] <jnthn> |$args has worked since quite a while. :)

[17:41] <[Coke]> jnthn++

[17:41] *** takadonet joined
[17:41] <takadonet> hey all

[17:41] *** takadonet left
[17:42] * [Coke] is interested to look more at zenog's speed issues but $dayjob calls.

[17:42] <jnthn> ...short visit!

[17:42] <PerlJam> drive by greeting

[17:42] <masak> his client got overloaded by the greeting...

[17:42] *** takadonet joined
[17:42] <takadonet> lets try this again...

[17:42] <masak> takadonet: \o

[17:42] *** stifynsemons joined
[17:43] <PerlJam> takadonet: we didn't even get a chance to hug you the first time!

[17:43] <takadonet> PerlJam: I know. I just saw the irc log 

[17:43] <takadonet> I been reading it all morning

[17:43] <zenog> [Coke]: I tried different variants of IO/data structure creation, here are some results: http://nopaste.info/90763f2c7b.html

[17:44] <takadonet> should just join the channel instead of refreshing the page

[17:47] *** Guest57743 left
[17:48] *** daxim left
[17:48] *** ymasory left
[17:51] *** nadim joined
[17:51] <zenog> Is it a feature that arrays are not interpolated any more?

[17:51] <moritz_> zenog: see S02 on string literals

[17:52] <masak> rakudo: my @a = 1,2,3; say "OH @a[] HAI"

[17:52] <p6eval> rakudo 6f9116: OUTPUT¬´OH 1 2 3 HAI‚ê§¬ª

[17:52] <jnthn> rakudo: my @a = 1,2,3; say "OH @a HAI"

[17:52] <p6eval> rakudo 6f9116: OUTPUT¬´OH @a HAI‚ê§¬ª

[17:52] <jnthn> :)

[17:52] <zenog> ah

[17:53] <jnthn> No email addresses in double quoted strings won't get screwed up :)

[17:53] <jnthn> *Now

[17:53] <dukeleto> rakudo: my @a = 1,2,3; say "OH @a() HAI"

[17:53] <p6eval> rakudo 6f9116: OUTPUT¬´invoke() not implemented in class 'Array'‚ê§  in main program body at line 22:/tmp/3k3bg2bEQf‚ê§¬ª

[17:53] <dukeleto> hmm, that used to work, methinks

[17:53] <sorear> you can also use {@a}

[17:53] <jnthn> dukeleto: It's correct.

[17:53] <jnthn> dukeleto: You tried to invoke it.

[17:54] <jnthn> rakudo: my @a = 1,2,3; @a() # just like this

[17:54] <p6eval> rakudo 6f9116: OUTPUT¬´invoke() not implemented in class 'Array'‚ê§  in main program body at line 22:/tmp/0ibgbyfkbN‚ê§¬ª

[17:54] <sorear> niecza: my @a = 1,2,3; say "OH @a() HAI"

[17:54] <p6eval> niecza v2-75-gca96dd2: OUTPUT¬´Unhandled exception: Unable to resolve method INVOKE in class Array‚ê§  at /tmp/KbPGUNxUix line 1 (MAIN mainline @ 4)‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 1106 (SAFE C467_ANON @ 2)‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 1107 (SAFE module-SAFE @ 32)‚ê§  at

[17:54] <p6eval> ../home/p6eval‚Ä¶

[17:59] <sorear> huh.  niecza seems to be parsing [!=] as [![=]]

[17:59] *** kjeldahl joined
[17:59] <moritz_> niecza: say 1 != 3

[18:00] <p6eval> niecza v2-75-gca96dd2: OUTPUT¬´Bool::True‚ê§¬ª

[18:00] <moritz_> niecza: 1 = 2

[18:00] <p6eval> niecza v2-75-gca96dd2: OUTPUT¬´Unhandled exception: assigning to readonly value‚ê§  at /tmp/QeFFg8oufT line 1 (MAIN mainline @ 1)‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 1106 (SAFE C467_ANON @ 2)‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 1107 (SAFE module-SAFE @ 32)‚ê§  at

[18:00] <p6eval> ../home/p6eval/niecza/lib/SAFE.se‚Ä¶

[18:00] <sorear> moritz_: it's only happening inside reduce metaops

[18:00] <moritz_> ah

[18:01] *** envi left
[18:01] <moritz_> niecza: say [!=] 1, 1

[18:01] <p6eval> niecza v2-75-gca96dd2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§This macro cannot be used as a function at /tmp/cwE4ah2GQE line 1:‚ê§------> [32msay [!=][33m‚èè[31m 1, 1[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/SAFE.setting line 377 (SAFE die @ 2)‚ê§  at

[18:01] <p6eval> ../home/p6eval/niecza/src/STD.p‚Ä¶

[18:01] <sorear> if you insist

[18:01] <dalek> niecza: ef92f25 | sorear++ | / (3 files):

[18:01] <dalek> niecza: Test mergeback

[18:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ef92f25d96

[18:01] <dalek> niecza: 81aba73 | sorear++ | lib/SAFE.setting:

[18:01] <dalek> niecza: Add the reduce metaoperator

[18:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/81aba73315

[18:01] <dalek> niecza: f79241a | sorear++ | src/Operator.pm6:

[18:01] <dalek> niecza: Fix [!%%] et al

[18:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f79241a8cf

[18:07] <qwkl> actually, my Y had an unnecessary closure; afaict, sub Y(&f) { my &g = f({ g(|$^args) }) } is a valid fixed-point combinator, fully equivalent to the default implementation of Y...

[18:09] *** gdey joined
[18:11] <moritz_> nothing a &?BLOCK or &?ROUTINE wouldn't solve, once that's implemented :-)

[18:12] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[18:15] *** V15170R left
[18:20] <dalek> niecza: ace95a1 | sorear++ | lib/SAFE.setting:

[18:20] <dalek> niecza: Fix right-associative triangle reduce, decontainerization

[18:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ace95a1f81

[18:20] <dalek> niecza: 8bd6b3b | sorear++ | / (2 files):

[18:20] <dalek> niecza: Add reduce.t to run_spectests

[18:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8bd6b3b8f0

[18:20] <dalek> roast: c8e9e01 | sorear++ | S03-metaops/reduce.t:

[18:20] <dalek> roast: Fudge reduce.t for niecza

[18:20] <dalek> roast: review: https://github.com/perl6/roast/commit/c8e9e0160e

[18:21] <zenog> &

[18:21] *** zenog left
[18:34] <dalek> roast: ae2a2d8 | sorear++ | S02-builtin_data_types/autovivification.t:

[18:34] <dalek> roast: Unfudge autovivification.t for niecza a bit more

[18:34] <dalek> roast: review: https://github.com/perl6/roast/commit/ae2a2d8627

[18:34] <dalek> niecza: 0668028 | sorear++ | src/niecza:

[18:34] <dalek> niecza: Implement is readonly parameter trait

[18:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0668028fc4

[18:38] <moritz_> sorear: are you aware of autounfudge and update_passing_test_data in the rakudo repo?

[18:39] <moritz_> sorear: should be quite easy to adapt for niecza

[18:39] <sorear> vaguely

[18:39] <sorear> I'll check them out

[18:39] <moritz_> in fact I once ran update_passing_test_data against niecza, which provided the first batch of passing spectests

[18:40] <sorear> oh, niece!

[18:40] <moritz_> both expect a t/spectest.data

[18:40] <sorear> er. nice.  can't spell :)

[18:40] <moritz_> and I wanted to write the corresponding harness in perl6

[18:40] <moritz_> which is why I want run() in niecza :-)

[18:40] *** tty234_ is now known as tty234

[18:41] <sorear> How is the top level $UNIT::_ initialized?  Does it bind to $SETTING::_ ?

[18:41] * sorear would vaguely prefer separate units to not share globals like that

[18:42] <moritz_> I think $UINT::* can be copied from $SETTING::*

[18:43] <moritz_> and since all the routines are immutable, you can cheat there

[18:43] <moritz_> hm, but classes are mutable...

[18:43] <sorear> Copied, or bound?

[18:43] <moritz_> i thought of assignment actually

[18:43] <moritz_> not sure if that works out

[18:43] <sorear> I think $_ is supposed to alias $OUTER::_; it's is rw etc

[18:44] <sorear> I think the sensible thing for &run to do is a runtime probe for Mono.Posix, and use execve if available, otherwise we must be on Windows with .NET, so emulate perlwin32's system emulation :)

[18:47] <moritz_> niecza: use fatal;

[18:47] <p6eval> niecza v2-80-g8bd6b3b:  ( no output )

[18:47] *** gdey left
[18:48] *** risou left
[18:52] *** qwkl left
[19:00] *** ymasory joined
[19:01] *** REPLeffect joined
[19:24] *** gbacon_ left
[19:26] *** uvtc left
[19:27] <moritz_> niecza: $_ = 'a'; .say if /b/

[19:27] <p6eval> niecza v2-80-g8bd6b3b: OUTPUT¬´a‚ê§¬ª

[19:27] <moritz_> niecza: $_ = 'a'; .say if m/b/

[19:27] <p6eval> niecza v2-80-g8bd6b3b: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method quote:m not yet implemented at /tmp/Ldt_yRfSNN line 1 (EOF):‚ê§------> [32m$_ = 'a'; .say if m/b/[33m‚èè[31m<EOL>[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/SAFE.setting line 377 (SAFE die @

[19:27] <p6eval> ..2)‚ê§  at /home/p‚Ä¶

[19:27] * moritz_ opens a bug report

[19:31] *** nymacro left
[19:31] *** pigdude left
[19:40] <moritz_> niecza: say 'ab cd foo'.words.perl

[19:40] <p6eval> niecza v2-81-g0668028: OUTPUT¬´["ab", "cd", "foo"]‚ê§¬ª

[19:47] <dalek> tpfwiki: (Herbert Breunung)++ | http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

[20:05] *** Mowah joined
[20:07] *** ymasory left
[20:10] <sorear> moritz_: unlikely to be fixed soon

[20:11] <sorear> until I come up with some nice bit of cleverness, allowing $CALLER::_ to work will completely break loop inlining

[20:11] <sorear> since every block *needs* a distinct $_

[20:12] <sorear> niecza doesn't guarantee distinct $/ or $! per block and can mostly get away with it, but nested $_ aliasing idioms show up a lot more

[20:19] *** cotto_work left
[20:25] *** cotto_work joined
[20:28] *** jevin joined
[20:30] <masak> Perl 6 hacking time! \o/

[20:30] <benabik> \o/

[20:30] *** plainhao left
[20:31] *** MayDaniel joined
[20:32] *** dorlamm joined
[20:32] * masak puts on some Jonathan Coulton and digs in

[20:33] <colomon> \o/  (that's for p6 hacking, not Coulton. :)

[20:34] *** y3llow_ joined
[20:34] *** pothos_ joined
[20:35] <sorear> hello masak !!!

[20:35] *** y3llow left
[20:35] *** y3llow_ is now known as y3llow

[20:35] * sorear is working out plans for OUTER

[20:35] <masak> hello, sorear of Three Exclamation Marks. :)

[20:35] *** pothos left
[20:36] *** pothos_ is now known as pothos

[20:38] *** mtk left
[20:43] <Tene> masak: I have a vague memory of wanting to talk with you about something, but I have no idea what it was.  Are you aware of anything pending from me?

[20:45] <masak> Tene: we have a couple of recurring topics: macros, operator overloading, HLL interop...

[20:46] <masak> but no, I don't have any continuations lying around.

[20:46] <Tene> 'k, thanks.

[20:46] *** mtk joined
[20:48] <masak> it's not always easy to write Just One More Test... :)

[20:53] *** kst left
[20:55] <masak> I've been assuming all day that perl6 -e implies 'no strict'... for some reason.

[20:56] <masak> too much Perl 5 exposure, I guess. :)

[20:56] *** dorlamm left
[21:00] <sorear> I don't really see the use of 'no strict'

[21:00] <masak> there's not much logic behind it, I guess.

[21:00] <masak> just convenient for one-liners.

[21:00] <masak> in this case, it was just in my fingers. nothing really conscious.

[21:01] <sorear> use strict smells like, to use one of TimToady++'s analogies, an EXTEND

[21:01] <sorear> it was put in to maintain backward compatibility

[21:01] <masak> which is why Perl 6 assumes 'use strict', I guess.

[21:01] <masak> since it's really the right default.

[21:03] *** mkramer left
[21:04] <colomon> amen.

[21:05] *** MayDaniel left
[21:12] *** Tedd1^ joined
[21:13] <masak> ok, I now officially Don't Like that &dir returns strings whose paths are relative to the directory sent in, not to the current directory.

[21:15] <flussence> './' X~ dir; # would be nicer if I knew how to get the current dir in p6...

[21:16] <colomon> it seems like the thing is it is easier to add the path to the directory sent in than it is to remove it.

[21:16] *** Tedd1 left
[21:16] <flussence> Text-Tabs-Wrap has a bunch of files containing test input/output, I do something horrible with $*PROGRAM_NAME to get at them

[21:16] *** molaf joined
[21:17] <jnthn> rakudo: say cwd

[21:17] <p6eval> rakudo 6f9116: OUTPUT¬´/home/p6eval/rakudo‚ê§¬ª

[21:18] <flussence> I tried pwd and gave up looking when it didn't work :(

[21:23] <masak> cwd does make a bit more sense here...

[21:25] * flussence stuck in bash-mode

[21:27] <masak> rakudo: for dir() { .say }

[21:27] <p6eval> rakudo 6f9116: OUTPUT¬´Operation not permitted in safe mode‚ê§  in 'Safe::forbidden' at line 2:/tmp/lnat35BzSe‚ê§  in main program body at line 22:/tmp/lnat35BzSe‚ê§¬ª

[21:27] <masak> aww :)

[21:28] <masak> could someone please try and reproduce this? https://gist.github.com/834440

[21:28] <Tene> masak: Yes, I've been complaining about problems with rakudo's IO class and associated functions for a while now.

[21:29] <flussence> no output here too

[21:29] <jnthn> masak: take doesn't default to $_, does it?

[21:29] <masak> oh!

[21:29] <Tene> we don't have "default to $_" in Perl 6

[21:29] <Tene> jnthn: no, it definitely doesn't

[21:29] <masak> jnthn: d'oh! :)

[21:29] <masak> now it works...

[21:30] <jnthn> :)

[21:30] <masak> jnthn++ masak--

[21:30] <Tene> well, not for function calls, at least.  There are a few constructs that work with $_.

[21:30] <masak> sometimes I want .take

[21:30] <Tene> masak: that sounds reasonable

[21:31] <flussence> rakudo: my $basepath = do given $*PROGRAM_NAME.split('/') { .pop; .join('/') || '.' }; say $basepath;

[21:31] <p6eval> rakudo 6f9116: OUTPUT¬´/tmp‚ê§¬ª

[21:31] <Tene> masak: That's a lot more reasonable than .say is

[21:31] <flussence> I wonder if that could be shorter...

[21:31] <masak> Tene: what do you say we change &dir to return cwd-relative paths in the spec, and see what falls out of it?

[21:31] *** shortcircuit left
[21:31] <Tene> masak: or dir could return IO objects.

[21:31] *** shortcircuit joined
[21:32] <masak> or that.

[21:32] <Tene> and IO objects could have a useful .Str method

[21:32] <masak> they have .path

[21:32] *** kst joined
[21:32] <flussence> that's a string, make it .Str!

[21:32] <masak> sure, why not?

[21:32] <flussence> (what would an INET stringify to?)

[21:32] <jnthn> if all(dir('foo/bar')>>.modtime) > $five_mins_ago { ... } \ could be useful...

[21:33] <jnthn> Or such things. :)

[21:33] <masak> jnthn: nod.

[21:33] <masak> (it's called .changed) :)

[21:33] <jnthn> worreva :P

[21:33] <Tene> masak: *also*, IO objects are currently broken, as they store the path when first instantiated, but don't open the file until they're accessed, so if you make a bunch of IOs, then chdir, then access your IOs, they don't work

[21:33] <masak> jnthn: we had a productive bikeshed session over .changed et al. I'm proud of it :)

[21:33] <jnthn> IOHNOES!

[21:33] *** pyrimidine left
[21:34] <masak> Tene: yes, that's decidedly RONG.

[21:34] <jnthn> Agree

[21:34] <jnthn> Doesn't dwim.

[21:35] <masak> ok, how about this one? my @l = gather for dir>>.IO { take $_ }; .say for @l

[21:36] <masak> could anyone confirm that it doesn't give any output, even in a directory with files?

[21:36] <masak> it's the >>.IO that does it, it seems.

[21:36] <Tene> masak: IMO, .say is very broken

[21:36] <flussence> they should store the absolute path instead, right? (also .relative(cwd) would be a nice addition)

[21:36] <masak> Tene: I've been convinced it isn't. but I used to be suspicious as well.

[21:36] <jnthn> masak: How do IO objects stringify?

[21:36] <Tene> masak: compare the .say on most objects to the .say on IO objects

[21:37] <masak> jnthn: ah. you solved that one too :)

[21:37] <masak> jnthn: say .path for @l works :)

[21:37] <jnthn> :)

[21:37] <colomon> jnthn++

[21:37] <masak> Tene: I know. it breaks Liskov.

[21:37] <jnthn> masak: Can you solve some of my problems for me in return? ;)

[21:37] <masak> jnthn: you'd like that, wouldn't you :P

[21:37] <Tene> masak: for example, your example up there calling .say on each IO object would write newlines to the files, and nothing to stdout

[21:38] <masak> Tene: oh!

[21:38] <masak> Tene: yes, I fell into that one :(

[21:38] <masak> that explains it all.

[21:39] <Tene> masak: I've seen that more than once; I'm rather unhappy with say as both a method and a standard function.

[21:39] <Tene> masak: I'm similarly-but-less-so uncomfortable with the two variants of map, grep, etc. that take different arguments.

[21:39] <masak> Tene: I don't think it's likely to change. it'll just remain an FAQ until Perl 7, which will have user-friendly monads :P

[21:40] <Tene> any-list.map accepts a Code, but Code.map accepts a list.

[21:40] <Tene> So your "generic function" that will work on whatever you pass to it can mysteriously break when you pass it a Code object.

[21:40] <masak> :(

[21:41] * jnthn didn't realize Code.map was different...

[21:41] * masak hadn't really realized that

[21:41] <jnthn> I'm trying to remember if I've ever seen that used.

[21:41] <sorear> niecza has a completely different handling of filenames

[21:41] <sorear> you can for instance say ".".IO.realpath;

[21:41] <jnthn> rakudo: my @a = 1,2,3; say ({ 2 * $_ }).map(@a).perl

[21:42] <p6eval> rakudo 6f9116: OUTPUT¬´No candidates found to invoke for method 'map' on object of type 'Block'; available candidates have signatures:‚ê§:(Mu : &block;; *%_)‚ê§:(Mu : %block;; *%_)‚ê§‚ê§  in main program body at line 22:/tmp/JpXv2AOsGi‚ê§¬ª

[21:42] <Tene> jnthn: what about grep?  I thought there was a Code.grep, at least

[21:42] <sorear> Tene: there is an Any.grep

[21:42] <jnthn> rakudo: my @a = 1,2,3; say ({ 2 == $_ }).grep(@a).perl

[21:42] <p6eval> rakudo 6f9116: OUTPUT¬´()‚ê§¬ª

[21:43] <Tene> Hmm.  Looks like I'm misinformed here.

[21:43] <Tene> sorear: I've never actually understood why there was Any.grep, Any.map, etc.  I don't understand the utility of single items acting like lists in some cases.  I expect that's my ignorance, though.

[21:45] <colomon> Tene: Any.grep is the array grep.

[21:45] <colomon> I mean, Any.grep takes .list on the object, and then greps on the list.

[21:46] <Tene> Hmm.

[21:46] <colomon> It works on single objects because there is an Any.list which turns a single object into a list.

[21:47] <colomon> but it works on anything array-like as well.

[21:47] <colomon> it also means that if you define a new type with a meaningful .list method on it, all the built-in list methods will work on your type.

[21:48] <Tene> Ahh, okay.

[21:48] <masak> I'd also like not only .path on IO, but also .filename or some such.

[21:49] <Tene> masak: not all IOs have filenames

[21:49] <Tene> or paths

[21:49] <masak> that's not my fault.

[21:49] <colomon> +1 to Tene

[21:49] <masak> that just means we have the wrong abstraction somewhere :)

[21:49] <Tene> ... or do they?  I can't remember what things TimToady agreed with me on, and which he disagreed on.

[21:49] <masak> I'd like .path and .filename on File objects, OK? :)

[21:49] <Tene> I had a notable conversation about it a while back, where I rather disagreed with him about the abstractions involved.

[21:50] <sorear> Rakudo makes the mistake of treating paths and filehandles as the same thing

[21:51] <flussence> I've done some pretty horrible (and useful) things in perl5 by passing filehandles where paths are expected

[21:53] <masak> Tene: the IO spec is still up for grabs.

[21:53] <masak> all it's looking for is some caring soul to nurture it back into sanity.

[21:54] <Tene> Hmm.

[21:54] <Tene> Tempting.

[21:55] *** mfollett_ joined
[21:56] *** frodwith left
[21:57] *** frodwith joined
[21:59] *** mfollett left
[21:59] *** mfollett_ is now known as mfollett

[21:59] *** MayDaniel joined
[22:02] <masak> hey, I just created this little tool: https://gist.github.com/834500

[22:02] <masak> it's a mini-tote.

[22:03] <masak> I'd very much like for someone to try it for one of his projects and be as hooked by the technology as I am :)

[22:04] <masak> what it does is keep track of .pm and .t files, noting when they change. then it re-runs all the tests.

[22:04] <Tene> masak: you could use $dir as IO, and then $dir.dir

[22:04] <Tene> ;)

[22:04] *** donaldh joined
[22:04] <masak> Tene: it felt more sensible to send in string paths for some reason.

[22:05] <sorear> inotify.

[22:05] <Tene> masak: Ahh, I see you're a fan of tools breaking when you have fiels with spaces in the name. ;)

[22:05] <colomon> So that's a p6 script that just sits there, monitoring the files and launching tests?

[22:05] *** molaf left
[22:06] <Tene> I'd very much prefer that 'run' didn't do any shell processing, and you had to ask for that specifically, with a different function

[22:06] * colomon is imagining 90% of his computer's resources going to that script after a few hours of running it...

[22:06] <masak> colomon: exactly.

[22:06] <jnthn> colomon: It's cold in Sweden. This helps keep houses warm. :P

[22:06] <Tene> masak: I personally use 'keep', from here: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Higher-order_shell/

[22:06] <masak> Tene: yes, I know about it :)

[22:07] <Tene> masak: it uses strace to find all the fiels used by a command, and installs inotify hooks on them, etc the other stuff you know.

[22:07] <masak> Tene: preferably, I'd like to wire tote up the same way.

[22:07] <Tene> :P

[22:07] <masak> using strace, yes.

[22:07] <masak> and inotify.

[22:07] <colomon> jnthn: seriously, I can imagine that thing adding several degrees to the temperature in my office...

[22:07] <masak> when available.

[22:07] <masak> colomon: having the tests trigger-on-save doesn't sound like much, but it's wonderful.

[22:08] <masak> for lack of a better word.

[22:08] <colomon> It does sound pretty nice, I admit.

[22:08] <masak> something to do with not having to context-switch as much.

[22:08] <masak> plus, it makes it harder to quit :P

[22:08] <masak> "just one more test run..."

[22:10] <masak> I prefer not to put types on my attributes, for fear that all my code will break once they're enforced... :/

[22:10] <colomon> one glitch... I know I usually find myself running a single test file over and over, so I don't spend the time it takes running my entire test suite.

[22:10] <colomon> "glitch", I should say.

[22:11] <colomon> also, running them all this way will potentially generate a lot of output to sort through, no?

[22:12] <masak> colomon: yes, you're right. this isn't an ultimate solution.

[22:12] <masak> I'd like three modes: all test files; one test file; one test.

[22:12] <colomon> masak: darn you, why didn't you implement the ultimate solution first!  ;)

[22:13] <masak> because of the definition of 'ultimate'... :P

[22:14] <colomon> nonsense.  if you wrote the ultimate one first, then you'd be done.  

[22:15] <colomon> think of how much work you'd save!  :p

[22:17] <masak> it's comforting to know you're saying that with an ironic tone of voice :)

[22:17] *** Mowah left
[22:17] *** Trashlord left
[22:18] <moritz_> phenny: tell sorear please see branch p6_spectests on moritz/niecza -- t/run-spectests.pl should work as soon as you implement run() (tested with s/run/say/)

[22:18] <phenny> moritz_: I'll pass that on when sorear is around.

[22:19] <dalek> nqp/ctmo: f115e3e | jonathan++ | src/ (4 files):

[22:19] <dalek> nqp/ctmo: Various fixes and tweaks. This gets us actually doing an initial call to the SC builder during the compile, though of course it's a drop in the ocean. Turns out that there's going to be quite some yaks to shave before this can really come into use.

[22:19] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/f115e3ecd3

[22:20] <masak> welcome to Yak Shaving Night with the #perl6 crew...

[22:21] <tadzik> ...zebras?

[22:21] <tadzik> o/

[22:22] *** donaldh left
[22:22] *** thepler left
[22:23] *** Trashlord joined
[22:23] *** MayDaniel left
[22:25] *** jimbob joined
[22:32] <masak> tadzik: good evening, zebra.

[22:33] <masak> Tene: I think if there was something better than &run that did not break in the presence of spaces, I'd use that. as there isn't, I just reach for &run. :/

[22:36] <Tene> masak: If you can't pass a list to run instead, then run is broken.

[22:36] <flussence> NativeCall + execve() !

[22:36] <masak> Tene: for someone with so many excellent opinions, you're making surprisingly few changes to the spec... :>

[22:36] <flussence> (oh wait, getting a return value might be hard.)

[22:36] <Tene> ... eww, run only accepts a single strin argument.  It's *worse* than system().

[22:37] * masak urges Tene to make it better

[22:37] <Tene> masak: My opinions don't have a strong history of agreeing with TimToady, so I have no confidence about what spec contributions I could make that are likely to be agreeable.

[22:38] *** Tedd1 joined
[22:38] <masak> Tene: I reject your excuse. lots of us don't have a strong history of agreeing with TimToady, yet we commit to the spec occasionally anyway :)

[22:39] <masak> rakudo: my @a = 3, 1, 2; say "OH {@a.sort} HAI"

[22:39] <p6eval> rakudo 6f9116: OUTPUT¬´OH 1 2 3 HAI‚ê§¬ª

[22:39] <sbp> you're not disagreeing with his disagreement, just disagreeing that it matters? :-)

[22:39] <masak> rakudo: my @a = 3, 1, 2; say "OH @a.sort() HAI"

[22:40] <p6eval> rakudo 6f9116: OUTPUT¬´OH 1 2 3 HAI‚ê§¬ª

[22:40] <sbp> rakudo: my @a = 3, 1, 2; say "OH {{@a.sort}} HAI"

[22:40] *** am0c left
[22:40] <p6eval> rakudo 6f9116: OUTPUT¬´OH 1 2 3 HAI‚ê§¬ª

[22:41] <masak> sbp: well, I don't disagree that Tene disagrees, if that's what you mean. :)

[22:41] *** Tedd1^ left
[22:41] <colomon> masak: are you *sure* I'm being ironic?  I might be thinking that Extreme Programming is getting kind of stale, and it's now time for Ultimate Programming!!!!!!

[22:42] <masak> colomon: that's a possibility, albeit a remote one. ;)

[22:46] <Tene> masak: I'm reluctant about investing the time to do it right if it's questionable that it'll stay around.

[22:48] *** mfollett left
[22:50] *** mfollett joined
[22:50] <masak> Tene: I understand. though I do think that you have many suggestions that would improve the current state of things.

[22:50] <masak> I could try adding them myself, in my copious free time...

[22:51] <Tene> masak: could be.  There's the secondary problem that I'm not actually doing anything at all these days.

[22:51] <masak> I've updated mini-tote at https://gist.github.com/834500 -- it now uses prove.

[22:51] <colomon> masak++

[22:51] * masak hugs Tene

[22:51] <Tene> I haven't done any notable work on personal projects in over a year now; I guess I'm pretty burned out or something.

[22:53] <masak> sounds like it.

[22:57] <tadzik> what's mini-tote?

[22:59] <masak> tadzik: tote is a testing framework that I sometimes almost write or think about writing. mini-tote is (perhaps) the beginnings of the real tote.

[22:59] <masak> tadzik: http://strangelyconsistent.org/blog/helpfully-addictive-tdd-on-crack

[23:00] <masak> also, http://strangelyconsistent.org/blog/some-thoughts-on-tote

[23:04] *** whiteknight joined
[23:06] <tadzik> masak: looks funny

[23:11] <tadzik> sleeping, o/

[23:12] <masak> 'night, tadzik.

[23:18] *** jimbob left
[23:31] *** s1n left
[23:31] *** donri left
[23:31] *** TiMBuS left
[23:31] *** ponbiki left
[23:31] *** perigrin left
[23:31] *** benabik left
[23:31] *** bacek left
[23:31] *** stepnem left
[23:31] *** donri_ joined
[23:32] *** ponbiki joined
[23:32] *** perigrin joined
[23:32] *** benabik joined
[23:32] *** barika left
[23:32] *** bacek joined
[23:32] *** s1n joined
[23:34] *** stepnem joined
[23:34] *** TiMBuS joined
[23:42] *** barika joined
[23:46] *** mfollett left
[23:55] *** vmspb joined
[23:56] *** jerbraun joined
[23:59] *** kaare_ left
