[00:00] <daniel-s> you know what, it is my experience that IRC is generally quite a violent place

[00:01] <daniel-s> what with all the trout slapping and needing to duck after a comment

[00:01] *** Trashlord left
[00:05] <sorear> I'm thinking I should stop putting off unification

[00:06] <sorear> it's pretty clearly needed and my workaround is getting more and more unpleasant

[00:09] *** daniel-s left
[00:13] *** whiteknight joined
[00:27] *** daniel-s joined
[00:29] *** daniel-s left
[00:41] *** whiteknight left
[00:45] *** whiteknight joined
[00:50] <colomon> flussence: I have a big block of C++ code that does basically exactly that to hash geometry objects -- serialize them to a string and then hash that string.

[00:57] *** Dzzy left
[01:01] *** noganex_ joined
[01:02] *** noganex left
[01:04] *** whiteknight left
[01:06] *** whiteknight joined
[01:08] *** ggoebel left
[01:10] *** nymacro joined
[01:11] <TiMBuS> wouldnt it be easier just to use their memory address or something

[01:12] <TiMBuS> bad idea probably, if the GC moves

[01:13] *** ggoebel joined
[01:13] *** ajoe47 left
[01:16] <colomon> TiMBuS: the whole point (at least for my code) was that two identical objects with different addresses had to hash to the same thing.

[01:16] <TiMBuS> ah. well then yes. it all depends on the use

[01:21] *** ggoebel left
[01:22] *** mberends left
[01:28] *** starboarder2001 joined
[01:37] <TimToady> that's why we differentiate value semantics from object semantics, it all comes down to eqv vs ===

[01:37] <TimToady> and object semantics must not be GC sensitive

[01:38] <TimToady> it shouldn't matter if a GC happens in the middle of ===

[01:38] <TimToady> and it shouldn't change the hash of the .WHICH either

[01:39] <lichtkind> good night

[01:39] <lichtkind> o/

[01:39] <TimToady> \o

[01:39] <colomon> o/

[01:39] <lichtkind> :)

[01:39] *** lichtkind left
[01:39] <TimToady> biab &

[01:55] *** starboarder2001 left
[02:04] *** cooper joined
[02:12] *** mberends joined
[02:13] <pmichaud> nom:  say Mu, Nil, [3,4,5], (3,4,5);   # checking

[02:13] <p6eval> nom: OUTPUT«Can only use get_who on a SixModelObject␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[02:13] <pmichaud> oops

[02:13] <pmichaud> nom:  say Mu, [3,4,5], (3,4,5);   # checking

[02:13] <p6eval> nom: OUTPUT«Mu()3 4 5345␤»

[02:13] <pmichaud> \o/  # maybe

[02:14] <pmichaud> TimToady: tests and reactions welcomed.  :-)

[02:14] <pmichaud> afk for a bit -- dinner

[02:18] <TimToady> looks pretty good, but also looking for dinner...

[02:19] *** daniel-s joined
[02:54] *** whiteknight left
[03:05] *** Chillance left
[03:07] *** envi_laptop joined
[03:18] *** bkolera left
[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:35] *** zostay joined
[03:35] *** zostay left
[03:37] *** ggoebel joined
[03:56] *** dukeleto left
[03:57] *** dukeleto joined
[04:01] *** daniel-s left
[04:12] *** mish joined
[04:13] *** mish left
[04:25] *** kaare_ joined
[04:44] *** zostay joined
[04:45] *** bkolera joined
[05:18] *** Pain joined
[05:19] *** Pain left
[05:40] <dalek> rakudo/nom: cd87a74 | pmichaud++ | / (4 files):

[05:40] <dalek> rakudo/nom: Add preliminary Range and RangeIter type.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cd87a746cb

[05:40] <dalek> rakudo/nom: f1e984a | pmichaud++ | src/Perl6/Actions.pm:

[05:40] <dalek> rakudo/nom: Bit of a cheat to get Inf/+Inf/-Inf/NaN working again.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f1e984ab4a

[05:40] <dalek> rakudo/nom: 33c6b6c | pmichaud++ | src/core/ (2 files):

[05:40] <dalek> rakudo/nom: Initial version of 1..* ranges.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33c6b6c818

[05:40] <dalek> rakudo/nom: a56af91 | pmichaud++ | / (4 files):

[05:40] <dalek> rakudo/nom: Add Nil handling.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a56af91824

[05:40] <dalek> rakudo/nom: dac61a3 | pmichaud++ | src/core/ (8 files):

[05:40] <dalek> rakudo/nom: First pass at handling infinities in lists and ranges.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dac61a39fa

[05:40] <dalek> rakudo/nom: 729c703 | pmichaud++ | src/core/List (2 files):

[05:40] <dalek> rakudo/nom: More infinity updates to List.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/729c703bf0

[05:40] <dalek> rakudo/nom: b723c37 | pmichaud++ | src/core/ (3 files):

[05:40] <dalek> rakudo/nom: Handle infinite lists in join (experimental).  Important for when the repl

[05:40] <dalek> rakudo/nom: or say are given an infinite list to display.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b723c3768e

[05:40] <dalek> rakudo/nom: 03dfac0 | pmichaud++ | src/core/GatherIter.pm:

[05:40] <dalek> rakudo/nom: Add a temporary :infinite flag to GATHER, for experimentation

[05:40] <dalek> rakudo/nom: with infinite sequences and repetition operators.  Eventually

[05:40] <dalek> rakudo/nom: :infinite will likely be replaced by some other marker -- this

[05:40] <dalek> rakudo/nom: is just for evaluation.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/03dfac0ed6

[05:40] <dalek> rakudo/nom: 9866597 | pmichaud++ | src/core/List.pm:

[05:40] <dalek> rakudo/nom: Implement infix:<xx>.

[05:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9866597cea

[05:59] *** mberends left
[05:59] *** nymacro left
[06:06] *** am0c joined
[06:17] *** cyk left
[06:22] *** am0c left
[06:23] *** wamba joined
[06:40] *** am0c joined
[06:41] *** wamba left
[06:42] *** cooper left
[06:43] *** kaare__ joined
[06:44] *** kaare_ left
[06:45] *** mberends joined
[06:57] *** daniel-s joined
[07:03] *** wamba joined
[07:08] *** _twitch joined
[07:14] *** daniel-s left
[07:14] *** c9s_ joined
[07:16] *** xinming left
[07:18] *** xinming joined
[07:22] *** Su-Shee_ is now known as Su-Shee

[07:29] *** muixirt joined
[07:32] <muixirt> good morning, is there any docs/spec for nqp other than its source code?

[07:35] <mberends> hi muixirt, there are no nqp docs afaik. Depending on what you need, the test suite might be useful.

[07:40] <muixirt> mberends: ok

[07:43] *** dukeleto left
[07:43] *** dukeleto joined
[07:43] *** dukeleto left
[07:44] *** dukeleto joined
[07:44] *** dukeleto left
[07:45] *** dukeleto joined
[07:45] *** dukeleto left
[07:45] *** dukeleto joined
[07:45] *** dukeleto left
[07:46] *** dukeleto joined
[07:46] *** dukeleto left
[07:47] *** dukeleto joined
[07:47] *** dukeleto left
[07:47] *** dukeleto joined
[07:47] *** dukeleto left
[07:48] *** dukeleto joined
[07:53] <TBA2> morning #perl6

[07:59] * sorear out

[08:03] *** cosimo joined
[08:04] <TBA2> if i do $x.split(/ $y /), does that treat $y as a regex or a string?

[08:05] <TBA2> perl6: my $a = "test"; my $b = "es"; print $a.split(/ $b /);

[08:05] <p6eval> rakudo 248244, niecza v6-177-g365e216: OUTPUT«tt»

[08:05] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped by operat…

[08:05] <TBA2> rakudo: my $a = "test"; my $b = "es"; print $a.split(/ $b /);

[08:05] <p6eval> rakudo 248244: OUTPUT«tt»

[08:11] <TBA2> rakudo: my $a = "this is a test"; my $b = " "; print $a.split(/ $b /);

[08:11] <p6eval> rakudo 248244: OUTPUT«thisisatest»

[08:19] *** cosimo left
[08:19] *** am0c left
[08:34] *** tokuhirom left
[08:34] *** tokuhirom joined
[08:36] <moritz> good morning

[08:36] <moritz> rakudo: my $a = "this is a test"; my $b = " "; print $a.split($b).perl

[08:36] <p6eval> rakudo 248244: OUTPUT«("this", "is", "a", "test")»

[08:36] <moritz> rakudo: my $a = "this is a test"; my $b = " "; print $a.split(/ $b /).perl

[08:37] <p6eval> rakudo 248244: OUTPUT«("this", "is", "a", "test")»

[08:40] <TBA2> morning moritz

[08:40] <moritz> good morning

[08:40] <TBA2> seems rakudo treats it as a string, im sure expected behaviour is regex? one of the synopses seems to imply i need to use $::b to treat it as a plain string?

[08:42] <TBA2> just rereading S05, looks like its doing the right thing for a string scalar

[08:42] <moritz> well, / $b / should be the same as / ' ' /, and it is

[08:43] <TBA2> when i was playing around with some earlier i was starting to think the opposite was true, turned out to be one of those red herring things again :p

[08:43] <moritz> and .split() has two forms, one taking a regex, one taking a string as delimiter

[09:02] *** donri left
[09:05] *** rjerrin1 joined
[09:05] *** VXZ joined
[09:11] *** scottp left
[09:12] *** spetrea joined
[09:13] <spetrea> I'm writing an ecmascript parser in Perl5

[09:13] <spetrea> using Parse::Yapp

[09:14] *** scottp joined
[09:16] <spetrea> I saw an article about writing parsers using Parse::Eyapp, it was explaining how to write a parser for an inifile grammar using Parse::Eyapp and producing PIR code to use it inside Parrot

[09:17] <spetrea> "Parsing Strings and Trees with Parse::Eyapp" it was called

[09:17] <spetrea> I'd like it if there were more articles like that around

[09:17] <spetrea> I can learn a lot from those

[09:17] <spetrea> does Perl6 offer some kind of Parse::Yapp equivalent ?

[09:21] <TiMBuS> ermm

[09:21] <TiMBuS> you mean like, grammars

[09:22] <TiMBuS> or do you mean ast building stuff

[09:22] <moritz> well, grammars are built-in

[09:22] <TiMBuS> yeah which is why im not sure what he means exactly

[09:22] *** _twitch left
[09:22] <TiMBuS> unless he didnt know perl6 had awesome grammars builtin

[09:24] <moritz> of course there's still the opportunity to write other parsing modules for Perl 6

[09:28] <spetrea> ok grammars are builtin

[09:28] <spetrea> what kind of parsers can I write

[09:29] <spetrea> LL(1), LL(*), LALR ... etc etc ?

[09:29] <spetrea> what algo does Rakudo's implementation of grammars use

[09:31] <spetrea> I'd gladly switch my implementation of the ECMAScript parser to Perl6

[09:34] <muixirt> spetrea: what's the purpose of that parser?

[09:35] <spetrea> muixirt: parse javascript, generate call graphs and event graphs(like having event E , making a graph of all places that event can be fired from and drawing that graph)

[09:36] <spetrea> that's the purpose :)

[09:36] <TiMBuS> im pretty retarded so, im gunna say its a recdescent parser, and I can't tell you which 'type' of parser it is =/

[09:36] <spetrea> anyway here's the current grammar I wrote https://github.com/wsdookadr/qx-parser/blob/master/js_yapp/js_grammar.yp

[09:37] *** jaldhar left
[09:37] *** broquaint left
[09:38] <spetrea> moritz: ?

[09:38] <spetrea> moritz: any benchmarks of Rakudo's grammars against yacc,bison,lemon parser, Parse::Yapp from Perl6, Parse::Eyapp from Perl5, ANTLR ?

[09:40] <TiMBuS> benchmarks in speed? because i can tell you which is faster without doing all that

[09:40] <TiMBuS> (hint: not rakudo)

[09:44] *** xinming left
[09:45] <TiMBuS> http://www.perlmonks.org/?node_id=530779 thats what i was looking for

[09:45] <spetrea> TiMBuS: looking

[09:49] <moritz> spetrea: currently everything you do in rakudo is two or three orders of magnitudes slower than what you do in perl 5

[09:50] <moritz> (we're working on speeding it up)

[09:52] <spetrea> moritz: so, is it hard to optimize stuff ?

[09:52] <moritz> spetrea: what stuff?

[09:52] <spetrea> moritz: I dunno, I don't know something in particular that's slow in Rakudo

[09:52] <TiMBuS> all of it

[09:52] *** lewanmi1 joined
[09:52] <TiMBuS> bahaha. but seriously

[09:53] *** lewanmi1 left
[09:53] <moritz> spetrea: well, the current optimization work involves a totally new object system under the hood

[09:53] <moritz> which is why it takes some considerable effort

[09:55] <TiMBuS> not to mention parrot is working on replacing its entire internals, and still needs a working jit backend

[09:55] <spetrea> moritz: but are you 100% sure that current rakudo implementation is the bottleneck and not Parrot ?

[09:57] <spetrea> is there a mature, industrial-level language implementation in Parrot ? like java is for the jvm(sorry for the example, I don't know a  better one, I hate java too)

[09:57] <TiMBuS> bottleneck is a misleading term, but id probably say yes, rakudo is the slower part

[09:58] <spetrea> TiMBuS: well , what I mean is.. is rakudo's implementation generating not-so-fast parrot code, or is parrot not that fast at executing whatever rakudo is generating ?

[09:59] <TiMBuS> its completely unoptimized across the entire field :D

[10:01] *** tokuhirom left
[10:02] <TiMBuS> but rakudos current object model wastes a lot of time. that, i am sure of

[10:06] *** tokuhirom joined
[10:07] <muixirt> would it be unfair to say that parrot provides high level but slow building bricks for dynamic languages but often they are a mismatch for any concrete language and therefor language devs have to work around the problems with the result that compilers are awful slow?

[10:09] *** tokuhirom left
[10:10] <TiMBuS> muixirt, it does seem that way

[10:10] <TiMBuS> but i think parrot devs knew that some time ago, and expected most languages to make most (all?) of their own PMC's etc

[10:11] <muixirt> it's not only a problem of rakudo but of other parrot based languages like lua too (at least is was some months ago)

[10:11] *** tokuhirom joined
[10:11] <TiMBuS> and when M0 comes around that should all be a bit better. hopefully. maybe? idk. ill just trust whiteknight

[10:11] *** xinming joined
[10:13] <TiMBuS> http://www.jnthn.net/papers/2011-yapc-russia-rakudo.pdf spetrea, this should be pretty a good read for you

[10:14] <TiMBuS> a very convincing argument for what i was saying about the current model being.. not so optimal

[10:15] <TBA2> a question for #perl6 - how do you remove solid cement/plaster/paint/glue from a blocked drain? answers in p6 plz :)

[10:17] <muixirt> top

[10:18] <VXZ> a really nasty regular expression?

[10:20] <TBA2> s/drain-crap/clean-air/?

[10:20] * TBA2 wishes it were that simple

[10:22] <VXZ> idk about anyone else, but I became a programmer so I wouldn't have to be bothered by mundane things like laws of the physical universe...

[10:22] <TiMBuS> NaCl ==> sink()

[10:22] <TiMBuS> uh

[10:22] <TiMBuS> NaOH

[10:26] <TBA2> hm, will it dissolve cement? seems it can dissolve aluminium though lol

[10:26] <TBA2> HCI maybe?

[10:28] <TBA2> VXZ: wish i could ignore the laws of physics, sadly, when i switch on my washing machine i get to go swimming :/

[10:29] <TiMBuS> sounds like a perk

[10:31] <TBA2> lol, $dodgy_wiring + $flooding != life()

[10:32] *** muixirt left
[10:35] <spetrea> so Lua also has an implementation in Parrot

[10:35] <spetrea> I wonder how those guys feel about parrot

[10:35] <moritz> spetrea: the problem with rakudo's speed is three-fold: 1) there's an impedance mismatch between perl6 and parrot 2) parrot itself isn't too fast and 3) rakudo doesn't do any optimizations yet

[10:36] *** whiteknight joined
[10:36] <spetrea> what's rakudo's parser written in ?

[10:36] <moritz> Perl 6

[10:36] <TBA2> 4) rakudo bugs sometimes require writing "slower" code

[10:37] <spetrea> there must be some minimal part of Perl6 that is first implemented, so that you can bootstrap I guess

[10:37] <moritz> yes

[10:37] <moritz> that part is called "nqp" (Not Quite Perl 6)

[10:38] <moritz> which was bootstrapped with the previous grammar engine and compiler toolkit

[10:39] <moritz> that's the part that implements the grammar engine

[10:52] <VXZ> TBA2: maybe you shouldn't switch on your washing machine?

[10:54] <TiMBuS> the richard stallman approach

[10:54] <TiMBuS> hmm. kinda distasteful..

[10:55] <VXZ> what? you have someting against washboards?

[10:56] *** daniel-s joined
[11:06] *** rjerrin1 left
[11:10] <TBA2> VXZ: could always go naked, no washing to do (except perhaps towels, and i can wash those in the shower with me!)

[11:27] <daniel-s> how long does rakudo take to build

[11:28] <moritz> daniel-s: that depends very much on how much RAM you have available, and how fast your machine is

[11:29] <moritz> daniel-s: if you less than 1G of ram available, compiling the setting is kinda slow

[11:29] <daniel-s> I'm building it on my netbook

[11:30] *** lichtkind joined
[11:32] *** icwiener joined
[11:32] *** HarryS left
[11:32] *** mj41 joined
[11:36] <daniel-s> I thought it was done...

[11:37] <daniel-s> it was just the configure script :(

[11:42] *** mj41 left
[11:42] *** Holy_Cow joined
[11:42] <TBA2> if your short on ram it might not compile at all, was using a VM a few months back that only had 256mb assigned and make kept failing (out of memory), was forced to increase to 512mb minimum

[11:43] *** Holy_Cow left
[11:49] <daniel-s> this thing has 1GB

[11:49] <daniel-s> I think it's done

[11:50] <daniel-s> make test seems ok after ~5 or 6

[11:50] <daniel-s> :)

[11:52] *** cognominal_ left
[11:54] *** cognominal joined
[11:56] *** jedai left
[12:04] *** dorlamm joined
[12:07] *** orafu left
[12:07] *** orafu joined
[12:10] *** Chillance joined
[12:14] *** jedai joined
[12:29] *** jedai left
[12:49] *** icwiener_ joined
[12:50] *** icwiener left
[13:01] <pmichaud> good morning, #perl6

[13:01] *** woosley joined
[13:02] <daniel-s> pmichaud: o/

[13:02] *** dorlamm left
[13:03] <pmichaud> rakudo:   say ((1,2) xx 4).perl

[13:03] <p6eval> rakudo 248244: OUTPUT«((1, 2), (1, 2), (1, 2), (1, 2))␤»

[13:07] <pmichaud> rakudo:  my @a = (1,2,3) xx *;  say @a[15];

[13:08] <p6eval> rakudo 248244: OUTPUT«(timeout)»

[13:08] <pmichaud> nom:  my @a = (1,2,3) xx *;  say @a[15];

[13:08] <p6eval> nom: OUTPUT«1␤»

[13:08] <pmichaud> \o/

[13:09] *** Moukeddar joined
[13:10] *** bkolera left
[13:11] *** Moukeddar left
[13:12] *** icwiener_ left
[13:13] <moritz> nom:  my @a = (1,2,3) xx *;  say @a[14];

[13:13] <p6eval> nom: OUTPUT«3␤»

[13:13] <moritz> \o/ indeed

[13:13] <pmichaud> nom:  my @a = (1,2,3) xx *;  say @a[1500];

[13:13] <p6eval> nom: OUTPUT«1␤»

[13:14] *** icwiener joined
[13:14] <jlaire> nom: my @a = (((0,1) xx *) xx *) xx *; say @a[1000 .. 1007]

[13:14] <p6eval> nom: OUTPUT«Method 'Numeric' not found for invocant of class 'Range'␤current instr.: 'infix:<+>' pc 165728 (src/gen/CORE.setting.pir:41941) (:1478)␤»

[13:15] <pmichaud> don't have slices yet

[13:15] <pmichaud> maybe I'll add that now.

[13:15] <jlaire> oh, ok

[13:15] <jlaire> nom: my @a = (0,1) xx *; say @a[1000], @a[1001], @a[1002], @a[1003]

[13:15] <p6eval> nom: OUTPUT«0101␤»

[13:15] *** JimmyZ joined
[13:15] <jlaire> nom: my @a = (((0,1) xx *) xx *) xx *; say @a[1000], @a[1001], @a[1002], @a[1003]

[13:15] <p6eval> nom: OUTPUT«0101␤»

[13:31] *** kanishka joined
[13:33] *** satyavvd joined
[13:33] *** woosley left
[13:34] *** mj41 joined
[13:36] *** wamba left
[13:43] *** satyavvd_ joined
[13:45] *** satyavvd left
[13:51] *** kanishka left
[13:51] *** cognominal_ joined
[13:52] <JimmyZ> good evening, #perl6

[13:53] *** wamba joined
[13:54] *** cognominal left
[14:04] *** wamba left
[14:09] *** satyavvd_ left
[14:09] <dalek> rakudo/nom: af53013 | pmichaud++ | src/core/Any.pm:

[14:09] <dalek> rakudo/nom: Interim implementation of list slicing syntax (full implementation

[14:09] <dalek> rakudo/nom: requires several core types to be "does Positional").

[14:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af53013891

[14:32] *** MayDaniel joined
[14:32] *** jedai joined
[14:45] *** mj41 left
[14:46] <lichtkind> is in rakudo still done this way: "$filename.IO ~~ :X?

[14:47] *** ajoe47 joined
[14:57] *** kst left
[14:57] *** kst joined
[15:01] *** tokuhirom left
[15:12] *** MayDaniel left
[15:12] *** Crytel joined
[15:13] *** jaldhar joined
[15:14] *** Crytel left
[15:24] *** daniel-s left
[15:32] <dalek> rakudo/nom: f131ee4 | pmichaud++ | NOMMAP.markdown:

[15:32] <dalek> rakudo/nom: Update NOMMAP.markdown.

[15:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f131ee4158

[15:38] *** muixirt joined
[15:41] <muixirt> every time one runs a script the Perl 6 setting has to go through the parser (in rakudo)?

[15:42] <pmichaud> muixirt: no.

[15:42] <pmichaud> the setting is compiled into the rakudo .pbc

[15:43] <muixirt> probably misunderstood docs/architecture.svg

[15:44] *** ggoebel left
[15:44] <moritz> well, it only shows which stages it goes through, not when

[15:47] <muixirt> moritz: is it me or is it a teeny bit misleading?

[15:48] *** thou joined
[15:49] *** ggoebel joined
[15:49] <pmichaud> I can see that it's somewhat misleading, yes.

[15:51] *** cooper joined
[15:56] *** whiteknight left
[15:57] *** ggoebel left
[15:58] *** whiteknight joined
[15:58] <dalek> rakudo/nom: 5b34d7c | pmichaud++ | src/core/ (4 files):

[15:58] <dalek> rakudo/nom: Operator reorganization part 1:  Start moving the boolean/numeric/any operators into appropriate locations.  (Stringy will come next.)

[15:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b34d7c7b4

[16:00] *** Trashlord joined
[16:09] <thou> hello, #perl6!

[16:16] <thou> so, i have a question about the pseudo-example in S06:2739:  my &old_thermo := &thermo; &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }   # Shouldn't that be normal assignment to &old_thermo, otherwise the assignment to &thermo would affect &old_thermo as well?

[16:22] *** JimmyZ left
[16:24] *** JimmyZ joined
[16:27] <pmichaud> thou: I think that := binds to the value, not to the container.

[16:28] <pmichaud> ...although that's not what S03 currently says.  Let me check further.

[16:28] <thou> okay.

[16:32] <pmichaud> correct, &old_thermo would be bound to the container.

[16:32] <pmichaud> (based on latest discussions I have at present.)

[16:33] <pmichaud> more likely is that &thermo = sub   should be a binding instead of an assignment

[16:33] <pmichaud> i.e.,  &thermo := sub ...

[16:34] <thou> there's a mention just after that example: Note that &thermo.WHICH stays the same after the .wrap, as it does with the equivalent assignment shown since assignment to a Routine works like a container, changing the contained do property but not the container itself.

[16:34] <pmichaud> yeah, looking at that now

[16:34] <JimmyZ> nom: my $a = 3; my $b := $a; say $b; $a = 4; say $b; # just looks like this one

[16:34] <p6eval> nom: OUTPUT«3␤4␤»

[16:35] <pmichaud> well, not exactly like that one.  Assignment to routines is 'special'

[16:35] <pmichaud> (according to the spec)

[16:36] <thou> i am, personally, feeling quite certain that i don't understand this bit of the language :-)

[16:36] <pmichaud> what's given in S06 at that point is probably pseudocode anyway, since the previous sentence says "more or less the same effect as..."

[16:36] <pmichaud> i.e., it doesn't happen *exactly* that way

[16:36] <thou> yeah

[16:37] <pmichaud> it's probably more like

[16:37] <pmichaud>    my $old_do := &thermo.do;   &thermo.do := sub ($t) { old_thermo.invoke( ... ) }

[16:37] *** JimmyZ left
[16:38] <pmichaud> er

[16:38] <thou> since this is a somewhat tricky bit to understand, though, it'd be good if it *is* possible to write something that would work in the same way

[16:38] <pmichaud>    my $old_do := &thermo.do;   &thermo.do := sub ($t) { $old_do.invoke( ... ) }

[16:39] *** JimmyZ joined
[16:39] <thou> that at least gives me the impression that i understand it. maybe that's good, maybe not :-)

[16:40] *** wamba joined
[16:40] <JimmyZ> nom: my &a = { 1 + 1; } ; my &b := &a;  &a = { &b() +2 }; say &b(); # looks like this one? 

[16:40] <p6eval> nom: OUTPUT«maximum recursion depth exceeded␤current instr.: '_block1015' pc 439 ((file unknown):8834567) (:1)␤»

[16:41] <pmichaud> the main point is that   $handle = &sub.wrap(   )  enables you to in-place change what a sub does, and $handle.unwrap restores the original behavior.

[16:41] <pmichaud> how it works internally is (intentionally?) underspecified, I think.

[16:41] <JimmyZ> nom: my &a = { 1 + 1; } ; my &b := &a;  &a = { &b() +2 }; say &a(); # or this

[16:41] <p6eval> nom: OUTPUT«maximum recursion depth exceeded␤current instr.: '_block1015' pc 439 ((file unknown):20561415) (:1)␤»

[16:43] <pmichaud> for example, if you to have <sin> default to degrees instead of radians, you can do:   $handle = &sin.wrap( { callwith( $^t * 180 / pi ) });   say sin(90);   $handle.unwrap;  

[16:43] <pmichaud> *if you want

[16:43] <thou> pmichaud: OK. I will treat that example as suitably pseudo-ish that I don't need to pay attention to its details, and I'm not missing anything if I gloss over it.

[16:44] <pmichaud> (this is a contrived example... there's a way to get the built-in sin function to default to degrees without using .wrap :-)

[16:44] *** birdwindupbird joined
[16:46] *** JimmyZ left
[16:47] *** JimmyZ joined
[16:50] <JimmyZ> nom: sub thermo ($t) {...}; my &old_thermo := &thermo; &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }; say &thermo(20);

[16:50] <p6eval> nom: OUTPUT«Cannot assign to a non-container␤current instr.: 'infix:<=>' pc 166282 (src/gen/CORE.setting.pir:41944) (:1456)␤»

[16:50] <JimmyZ> std: sub thermo ($t) {...}; my &old_thermo := &thermo; &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }; say &thermo(20);

[16:50] <p6eval> std 37a0cdd: OUTPUT«Potential difficulties:␤  $t is declared but not used at /tmp/V6mSV2ssdM line 1:␤------> [32msub thermo ([33m⏏[31m$t) {...}; my &old_thermo := &thermo; &t[0m␤ok 00:01 129m␤»

[16:51] <thou> :-)

[16:51] <JimmyZ> I don't know why std complains $t

[16:52] <thou> td: sub thermo ($t) { say "Temp is now $t" }; my &old_thermo := &thermo; &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }; say &thermo(20);

[16:52] <thou> std: sub thermo ($t) { say "Temp is now $t" }; my &old_thermo := &thermo; &thermo = sub ($t) { old_thermo( ($t-32)/1.8 ) }; say &thermo(20);

[16:53] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 129m␤»

[16:55] <JimmyZ> nom: sub thermo ($t) {...}; my &old_thermo := &thermo; &thermo := sub ($t) { old_thermo( ($t-32)/1.8 ) }; say &thermo(20); #doesn't work too.

[16:55] <p6eval> nom: OUTPUT«Cannot use bind operator with this LHS at line 1, near " sub ($t) "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[16:56] *** birdwindupbird left
[17:01] <literal> 7w 29

[17:23] *** dorlamm joined
[17:24] *** dorlamm left
[17:27] *** birdwindupbird joined
[17:32] <dalek> rakudo/nom: 2561084 | pmichaud++ | / (2 files):

[17:32] <dalek> rakudo/nom: Operator reorganization part 2:  Move string-generic operators into Stringy.pm .

[17:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/256108460d

[17:35] <JimmyZ> pmichaud: Stringy.pm is lost ;)

[17:36] <JimmyZ> 'night 

[17:36] *** JimmyZ left
[17:37] *** whiteknight left
[17:38] <thou> i wonder if it's too late to --amend :-)

[17:40] <moritz> well, having Stringy.pm added in another commit won't kill us

[17:40] <sorear> good * #perl6

[17:40] <sorear> spetrea: ping

[17:44] <thou> hej, moritz

[17:44] <thou> o/

[17:45] <moritz> \o

[17:47] *** jaldhar left
[17:47] *** jaldhar joined
[17:52] *** zby_home_ joined
[18:02] *** kaare__ left
[18:02] <TBA2> should i expect the following to do a global substitution?

[18:02] <TBA2> rakudo: my $a = "a::b::c"; $a ~~= s/\:\:/\//, :g; print $a;

[18:02] <p6eval> rakudo 248244: OUTPUT«a/b::c»

[18:03] <TBA2> perl6: my $a = "a::b::c"; $a ~~= s/\:\:/\//, :g; print $a;

[18:03] <moritz> s:g/.../.../

[18:03] <p6eval> rakudo 248244: OUTPUT«a/b::c»

[18:03] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "~~="␤    expecting operator␤    at /tmp/xyXXqZMjiE line 1, column 23␤»

[18:03] <p6eval> ..niecza v6-177-g365e216: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot make assignment out of ~~ because chaining operators are diffy at /tmp/D42UV8CJwj line 1:␤------> [32mmy $a = "a::b::c"; $a ~~=[33m⏏[31m s/\:\:/\//, :g; print $a;[0m␤␤Unhandled exception: Check failed␤␤  at

[18:03] <p6eval> ../home/p6eval/niecza/boot/lib/COR…

[18:03] <TBA2> thx moritz :)

[18:05] <moritz> TBA2: and you shoulld use ~~, not ~~=

[18:05] <moritz> with s///, :g you construct a list of one substitution and one pair

[18:05] <sorear> niecza: say "a::b::c".subst("::","/")

[18:05] <p6eval> niecza v6-177-g365e216: OUTPUT«a/b::c␤»

[18:05] <sorear> niecza: say "a::b::c".subst("::","/",:g)

[18:05] <p6eval> niecza v6-177-g365e216: OUTPUT«a/b/c␤»

[18:06] <TBA2> moritz: am ok with that first bit, could you run that last one by me again :)

[18:06] <sorear> niecza: my $a  = "a::b::c"; $a ~~ (s/'::'/\// :g); say $a # just curious

[18:06] <p6eval> niecza v6-177-g365e216: OUTPUT«a/b/c␤»

[18:08] <moritz> TBA2: the comma constructs a list

[18:08] <moritz> TBA2: the first part is a sustition (s///), the second part is a pair (:g)

[18:09] <moritz> perl6: say (:g).perl

[18:09] <p6eval> pugs: OUTPUT«("g" => Bool::True)␤»

[18:09] <p6eval> ..rakudo 248244, niecza v6-177-g365e216: OUTPUT«"g" => Bool::True␤»

[18:09] <TBA2> ahh i see, makes sense now :) (and modifiers are starting to make more sense lol)

[18:10] *** wamba left
[18:11] *** kst left
[18:11] *** kst joined
[18:11] *** wamba joined
[18:14] <sorear> phenny: tell spetrea to check out niecza if performance is a major concern

[18:14] <phenny> sorear: I'll pass that on when spetrea is around.

[18:18] *** cbk left
[18:21] <sjn> jnthn: 

[18:21] <sjn> oops :)

[18:23] <moritz> how is/was NPW?

[18:24] <moritz> are masak-san and jnthn-san still alive?

[18:27] <TBA2> should this work (and does it/can it in rakudo): my $class = "Test"; my $method = "Something"; require $class; my $classObj = $class.new(); $class."$method"();

[18:27] <moritz> no

[18:28] <moritz> $class is always a Str

[18:28] <TBA2> is there any way atm?

[18:28] <moritz> there's always eval()

[18:29] <TBA2> was hoping for a more p6'ish way :)

[18:29] <moritz> probably my $type_obj = ::($class) or so

[18:29] <moritz> (but NYI)

[18:29] <TBA2> kk thanks (again!)

[18:34] <TBA2> just to clarify, only the $class.new bit doens't work? it appears $obj."$method"() does, once you've got the object to call it on

[18:35] <moritz> right

[18:36] <TBA2> cool, sry if im being dumb though, but how (in p6 world) does eval help me here? confuzzled :)

[18:36] <moritz> rakudo: my $name = 'Int'; say $name.WHAT; say eval($name).WHAT

[18:36] <p6eval> rakudo 248244: OUTPUT«Str()␤Int()␤»

[18:36] * jnthn is tired but alive :)

[18:37] <thou> moritz++

[18:37] <TBA2> thanks, yet again lol :) you're becoming my personal tutor hehe ;)

[18:37] <TBA2> really though, much appreciated :D

[18:38] *** birdwindupbird left
[18:38] <moritz> .oO( please /msg me your billing address :-) )

[18:39] *** masak joined
[18:39] <masak> evening, #perl6.

[18:39] <moritz> \o/ masak 

[18:39] <TBA2> evenin masak

[18:40] <moritz> how was NPW?

[18:40] <masak> we survived arranging a Perl event \o/

[18:40] <jnthn> pmichaud: Seems Stringy.pm is missing in 2561084

[18:40] <TBA2> moritz: Dan Wright, Yet Another Society, ... *vbg*

[18:40] <masak> moritz: I'm very please with the way it all turned out.

[18:40] <jnthn> masak: So did our attendees ;)

[18:40] <masak> pleased*

[18:41] <jnthn> (as in, survived us arranging a Perl event :))

[18:41] <masak> :)

[18:42] * jnthn had a nap after getting home :)

[18:42] <TBA2> should rakudo complain if a method with the same parameter list is declared twice in a class?

[18:42] <TBA2> rakudo: class A { method A() { say "A1"; }; method A() { say "A2"; }; }; my $a = A.new(); $a.A();

[18:42] <TBA2> perl6:  class A { method A() { say "A1"; }; method A() { say "A2"; }; }; my $a = A.new(); $a.A();

[18:42] <p6eval> rakudo 248244: OUTPUT«A2␤»

[18:42] <p6eval> pugs, rakudo 248244: OUTPUT«A2␤»

[18:42] <p6eval> ..niecza v6-177-g365e216: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two definitions of method A (see line 1) at /tmp/Djx1erXBbs line 1:␤------> [32ms A { method A() { say "A1"; }; method A[33m⏏[31m() { say "A2"; }; }; my $a = A.new(); $a[0m␤␤Unhandled exception: Check failed␤␤  at

[18:42] <p6eval> ../home/p6eval/niecza/boot/lib/COR…

[18:42] *** envi_laptop left
[18:42] <jnthn> nom: class A { method A() { say "A1"; }; method A() { say  "A2"; }; }; my $a = A.new(); $a.A();

[18:42] <p6eval> nom: OUTPUT«sh: ./perl6: not found␤»

[18:42] <jnthn> tssk

[18:42] *** thou left
[18:43] <moritz> TBA2: yes, unless they are declared as 'multi'

[18:43] <jnthn> TBA2: Should and it's fixed in nom, I'm sure.

[18:43] *** donri joined
[18:43] <moritz> TBA2: known bug

[18:43] <jnthn> nom: class A { method A() { say "A1"; }; method A() { say  "A2"; }; }; my $a = A.new(); $a.A();

[18:43] <p6eval> nom: OUTPUT«sh: ./perl6: not found␤»

[18:43] <TBA2> jnthn: think i'm on nom branch

[18:43] <TBA2> yeah i am

[18:44] <moritz> jnthn: nom rebuild will fail until Stringy.pm is supplied

[18:44] *** aindilis` left
[18:44] <jnthn> moritz: aww

[18:44] <jnthn> TBA2: OK, then I'd expect it's complaining. :)

[18:44] <TBA2> lol :)

[18:44] <jnthn> TBA2: At least, https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/MethodContainer.pm#L12 looks like it should.

[18:45] *** aindilis joined
[19:01] <pmichaud> oops

[19:02] <pmichaud> Stringy.pm coming up

[19:02] <pmichaud> pushed.

[19:03] <masak> I also pushed something. :)

[19:04] <flussence> rakudo: class A { method A() { say "A1"; }; method A() { say "A2"; }; }; my $a = A.new(); $a.*A();

[19:04] <p6eval> rakudo 248244: OUTPUT«A2␤»

[19:04] <pmichaud> workshop is done?

[19:05] <pmichaud> nom:  say 'alive yet?'

[19:05] <p6eval> nom: OUTPUT«sh: ./perl6: not found␤»

[19:05] <pmichaud> :-(

[19:05] <pmichaud> sorry about that, folks

[19:06] <pmichaud> is there a way to bump p6eval?  or can I be endowed with sufficient magic to make it happen?

[19:06] <dalek> rakudo/nom: 36b32d2 | pmichaud++ | src/core/Stringy.pm:

[19:06] <dalek> rakudo/nom: Forgot to add Stringy.pm.  pmichaud--

[19:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36b32d2db0

[19:06] <dalek> rakudo/nom: 2238d52 | masak++ | src/Perl6/Metamodel/AttributeContainer.pm:

[19:06] <dalek> rakudo/nom: use hash lookup instead of array search

[19:06] <dalek> rakudo/nom: 

[19:06] <dalek> rakudo/nom: jnthn++ found this opportunity for improvement during a live

[19:06] <dalek> rakudo/nom: exploration of the metamodel system in his talk NPW 2011. He

[19:06] <dalek> rakudo/nom: said "patches welcome"; here's the patch.

[19:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2238d5209b

[19:06] <moritz> masak++ jnthn++

[19:06] <pmichaud> jnthn: do we really accept patches from masak++?  How do we know he's not just trying to increase the number of bugs to report?  ;-) ;-)

[19:08] * pmichaud is exploring some ideas on improving the numeric bridge system

[19:10] <masak> exploration. we're doing it.

[19:10] <moritz> nom: say 1

[19:10] <p6eval> nom: OUTPUT«1␤»

[19:10] <pmichaud> \o/

[19:10] <pmichaud> nom:  my @a = 100..*;   say @a[5..10]

[19:10] <p6eval> nom: OUTPUT«105106107108109110␤»

[19:10] <pmichaud> rakudo: my @a = 100..*;  say @a[5..10]

[19:10] <p6eval> rakudo 248244: OUTPUT«105106107108109110␤»

[19:11] <masak> jnthn: how can I give my attribute a different AttributeHOW? I want to make sure the infinite regress I hinted at really is impossible. ;)

[19:11] <pmichaud> nom:  my @a = (100..*).map({$_ * 2});   say @a[5..10]

[19:11] <p6eval> nom: OUTPUT«210212214216218220␤»

[19:11] <pmichaud> rakudo:  my @a = (100..*).map({$_ * 2});   say @a[5..10]

[19:12] <p6eval> rakudo 248244: OUTPUT«(timeout)»

[19:12] <pmichaud> nom +1

[19:12] <masak> jnthn: (something like: AttributeHOW is just a class A, which can have attributes, and one of the attributes has a custome AttributeHOW, namely A)

[19:12] <pmichaud> rakudo:   say 100..*

[19:13] <p6eval> rakudo 248244:

[19:13] <p6eval> ..OUTPUT«(timeout)103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193…

[19:13] <pmichaud> nom:  say 100..*

[19:13] <p6eval> nom: OUTPUT«100..Inf␤»

[19:13] <pmichaud> nom:  say   @(100..*)

[19:13] <p6eval> nom: OUTPUT«...␤»

[19:13] <pmichaud> nom:  say (100..*).join(' ')

[19:13] <p6eval> nom: OUTPUT«...␤»

[19:14] <pmichaud> nom:   say (3,4,5,100..*).join(' ')

[19:14] <p6eval> nom: OUTPUT«3 4 5 ...␤»

[19:14] <moritz> is that .gist'ed?

[19:14] <pmichaud> in that case it's .join putting on the '...' for the infinite element

[19:15] <pmichaud> I'm not sure what join should do when it encounters an infinite list, so I did that :)

[19:15] <jnthn> masak: See EXPORTHOW

[19:15] <jnthn> pmichaud: Yeah, we should code review it very carefully ;-)

[19:16] <jnthn> pmichaud: I see you've been hacking. \o/

[19:16] <pmichaud> jnthn: a bit.

[19:16] <pmichaud> the new lists system is much more robust than previously

[19:17] <pmichaud> say ('hello','world') xx *

[19:17] <pmichaud> nom: say ('hello','world') xx *

[19:17] <p6eval> nom: OUTPUT«...␤»

[19:17] <jnthn> pmichaud: Excellent.

[19:17] <jnthn> pmichaud: Is gather/take in place?

[19:18] <pmichaud> jnthn: yes, it is!

[19:18] <pmichaud> well, sorta

[19:18] <jnthn> \o/

[19:18] <pmichaud> Actions.pm doesn't know how to create <blorsts>

[19:18] <jnthn> ah

[19:18] <jnthn> That doesn't surprise me.

[19:18] <masak> jnthn: oh! so I can only have one AttributeHOW in play at a time? I guess that makes sesnse.

[19:18] <Su-Shee> someone more knowledgeable than me could/should pugs point out here: http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from

[19:18] <Su-Shee> good evening.

[19:18] <masak> Su-Shee! \o/

[19:19] <jnthn> masak: The design does try to lead you down the path of doing sane things :)

[19:19] <pmichaud> nom:  my $a = 0;  say gather { take $a while $a++ < 10 }

[19:19] <p6eval> nom: OUTPUT«Method 'clone' not found for invocant of class 'Sub'␤current instr.: '_block1002' pc 102 ((file unknown):75172107) (:1)␤»

[19:19] <pmichaud> that's the bug I get when using gather

[19:19] <pmichaud> however

[19:19] <pmichaud> nom:  my $a = 0;  say GATHER { take $a while $a++ < 10 }

[19:19] <p6eval> nom: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[19:19] <masak> jnthn: I mean, it just means that the parser holds one AttributeHOW at a time. there can still be several different in your program when you're done compiling.

[19:19] <pmichaud> I cheated for now and created &GATHER :-)

[19:19] <jnthn> pmichaud: ah, OK

[19:20] <jnthn> pmichaud: I can fix the actions

[19:20] <pmichaud> I added some blockers to NOMMAP

[19:20] <pmichaud> well, not "blockers" so much as "things that people will encounter during testing"

[19:20] <jnthn> pmichaud: ah, basically roles

[19:20] <pmichaud> constants, too.   and hash constructors

[19:20] <jnthn> Plus the core...er..."constants"

[19:21] <jnthn> Guess they're enums.

[19:21] <pmichaud> if we can just make the constants into lexical entries for now that'd probably be sufficient

[19:21] <jnthn> Well, not all of them.

[19:21] <pmichaud> we can enumify them later

[19:21] <jnthn> pmichaud: Does circumfix:<{ }> exist yet?

[19:21] <pmichaud> jnthn: it does, but it doesn't work because of the hash constructor bug in Actions.pm

[19:21] <jnthn> pmichaud: Or, do we have Pair type again yet?

[19:21] <pmichaud> we do have Pair, yes.

[19:21] <jnthn> nom: say (a => 42).WHAT

[19:21] <p6eval> nom: OUTPUT«Null PMC access in find_method('new')␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[19:21] <jnthn> ah

[19:22] <pmichaud> nom:  say ('a'=>42).WHAT

[19:22] <p6eval> nom: OUTPUT«Pair()␤»

[19:22] <jnthn> hm :)

[19:22] <pmichaud> a => 2  doesn't use &infix:<=>> directly

[19:22] <pmichaud> 'a' => 2 does

[19:22] <jnthn> Well, I suspect mostly just a case of "not yet re-worked for nom"

[19:22] <pmichaud> (a => 2 gets special parsing treatment... <fatarrow> I think)

[19:22] <pmichaud> similarly

[19:23] <jnthn> yeah

[19:23] <pmichaud> nom:   say (:a<42>).WHAT

[19:23] <p6eval> nom: OUTPUT«Null PMC access in find_method('new')␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[19:23] <pmichaud> same thing.

[19:23] <jnthn> *nod*

[19:23] <pmichaud> it might be as simple as it's looking for 'Pair' in package instead of lexical namespace

[19:23] * pmichaud checks

[19:23] <jnthn> I suspect so.

[19:23] <jnthn> I'll have a look soon.

[19:24] *** thou joined
[19:24] <pmichaud> looks like that might've been it

[19:25] <pmichaud> compiling now to see

[19:25] <jnthn> Just about anything that uses :scope('package') is wrong.

[19:25] <pmichaud> agreed.

[19:25] <pmichaud> I think we can even s/Just about a/A/

[19:26] <pmichaud> > say (a=>42).WHAT

[19:26] <pmichaud> Segmentation fault

[19:26] <pmichaud> :-(

[19:26] <pmichaud> guess that's not (all of) it

[19:27] <jnthn> wow :)

[19:30] <lichtkind> there was no spam in last 2 month and ingy++ also updated the wiki

[19:30] <lichtkind> i think we could allow the chatbot again monitor the wiki

[19:32] <dalek> rakudo/nom: 8a35e99 | pmichaud++ | NOMMAP.markdown:

[19:32] <dalek> rakudo/nom: More NOMMAP stuff.

[19:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a35e99cf4

[19:32] <masak> lichtkind: a problem with the chatbot was that it wasn't very informative. it didn't give a summary, just said what page changed.

[19:33] <lichtkind> yes

[19:33] <lichtkind> but we could change that too :)

[19:33] <slavik1> I had an idea for a git based wiki

[19:33] <slavik1> no db for content, just static pages/code

[19:34] <slavik1> and tracked in git

[19:34] <slavik1> on server

[19:36] <lichtkind> slavik1 a dream for ages of an wiki written in perl 6

[19:36] *** ymasory joined
[19:36] <lichtkind> we could name it dezember :)

[19:37] <slavik1> lol

[19:37] <dalek> rakudo/nom: e7a2851 | pmichaud++ | NOMMAP.markdown:

[19:37] <dalek> rakudo/nom: More NOMMAP updates.

[19:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e7a28517a0

[19:38] <slavik1> lichtkind: only when mod_perl6 is semi stable :P

[19:38] <slavik1> I blame jnthn :P

[19:47] <TBA2> lichtkind: funnily enough am writing a p6 MVC platform as we speak :) uses CGI, can't even get mod_perl6 to compile, and obviously horrendously slow :) but writing a wiki with it is doable!!

[19:48] <TBA2> (temporarily with no file uploads, havent got around $*IN lacking binmode yet!)

[19:48] <moritz> TBA2: you might be interested in HTTP::Server::Simple

[19:49] <moritz> rakudo: say $*IN.read(20).perl

[19:49] <p6eval> rakudo 248244: OUTPUT«Buf.new(76, 97, 110, 100, 32, 100, 101, 114, 32, 66, 101, 114, 103, 101, 44, 32, 76, 97, 110, 100)␤»

[19:49] <moritz> there, binary reading from $*IN

[19:49] <TBA2> moritz: am using apache2, whats the benefit?

[19:49] <TBA2> and yeah i can get it to read a Buf from $*IN, but not when its a multipart file upload via POST

[19:50] <TBA2> when it gets to the file content it thinks its reached end of input, doesnt even die

[19:50] <moritz> TBA2: you save the startup time of rakudo for each request

[19:51] <moritz> https://github.com/mberends/http-server-simple/ # this one

[19:51] <TBA2> good point, but i'm hoping mod_perl6/mod_parrot will solve that one

[19:51] <TBA2> hmm

[19:51] <lichtkind> TBA2: whats your project caleld?

[19:51] <lichtkind> called

[19:51] <TBA2> good idea though :) think i might write a http-server-simple wrapper for it

[19:51] <TBA2> no name yet, its living under the namespace CGI:: on my dev box :)

[19:52] <lichtkind> TBA2: its you firc p6 program?

[19:52] <TBA2> so far it supports GET, POST (incl. multipart but not file uploads), HTTP responses, configuration and basic routing

[19:52] <lichtkind> masak: i would have soon something to factcheck

[19:53] <TBA2> sortaish, first attempt at writing something worthwhile, until now its just been bits of playing around to get the hang of p5/p6 differences (which im still struggling with!!)

[19:54] <lichtkind> TBA2: just complain where tablets can be written better

[19:55] <TBA2> been waiting on p6 for years :P thought i'd jump in now its starting to mature a bit!

[19:55] <TBA2> lichtkind: not sure i understand sorry

[19:56] <lichtkind> TBA2: i misunderstood, first i thought you had hard time to understand but i think you struggle because the difference

[19:58] <jnthn> pmichaud: Thanks for nommap updates. I see my work's cut out for me. :)

[19:58] *** kboga joined
[19:58] <sorear> good * #perl6

[19:59] <lichtkind> moin sorear 

[19:59] <masak> o/ sorear 

[20:00] <lue> hello world! o/

[20:01] <masak> hellue! \o/

[20:01] <sorear> slavik1: are't github wikis git-backed?

[20:01] <slavik1> sorear: no clue

[20:02] <slavik1> sorear: if they are, they copied me!

[20:02] <slavik1> :P

[20:02] <sorear> o/ masak

[20:06] <lue> today I feel like trying to get blocks in blocks working...

[20:06] <sorear> lue: you mean in yapsi?

[20:07] <TBA2> lichtkind: can't vouch for my coding (particularly my p6 code lol), but here's what i got so far: https://github.com/tba2/CGI

[20:08] <lichtkind> thanks

[20:08] <lue> no, in my Pod parser.

[20:08] * lichtkind wanders to implement the spirograph and harmonograph in p6

[20:09] <lichtkind> since we have exzelent SVG oh NOES but no GUI

[20:09] <sorear> clearly, niecza needs a FastCGI module

[20:09] <moritz> or something better, which isn't as hard to debug as FastCGI

[20:10] <sorear> what's better than FastCGI?

[20:10] <moritz> dunno

[20:10] <TBA2> !FastCGI?

[20:10] <moritz> for a web project I currently use a pure-perl preforking server behind an Apache mod_proxy

[20:11] <sorear> moritz: do you use anything like PSGI?

[20:11] <moritz> sorear: no, but the webframework I use (Mojolicious) supports it

[20:11] <moritz> sorear: and if I were to use some "cloud" hosting, I'd surely use it

[20:12] <Eevee> reverse proxy to lang-specific microserver seems to be gaining steal

[20:12] <Eevee> er, steam

[20:13] <sorear> psgi is cool

[20:13] <moritz> aye

[20:13] *** wamba left
[20:13] <__sri> <3 perl server behind reverse proxy

[20:14] <__sri> for me as a perl web developer it is perfect, since it is built exclusively out of the technologies i know and love

[20:14] *** y3llow left
[20:14] <__sri> unlike fastcgi... which is horrible to debug

[20:15] *** pothos left
[20:15] <Eevee> similarly #python tends to suggest nginx reverse-proxying to a wsgi server

[20:15] *** pothos joined
[20:15] *** y3llow joined
[20:15] <flussence> there's scgi as well, but I've never used it so can't say whether it's better than fcgi or not...

[20:15] <Su-Shee> I'd guess that every one of the fashionable interpreted languages suggests something like this...

[20:16] * __sri would take http over scgi/wsgi, but it's better than fastcgi

[20:16] <sorear> I think it has more to do with load speed

[20:16] <Eevee> ruby has, uh, thin

[20:16] <__sri> irrelevant

[20:16] <masak> inconceivable!

[20:16] <__sri> you're generating synamic content

[20:16] <flussence> I like fcgi, but that's mostly because I know how to get it working most of the time

[20:16] <sorear> back in the heyday of CGI, most people used C or Pre-Modern Perl, both of which load in <10ms

[20:16] <Eevee> not really sure how it works though

[20:16] <__sri> *dynamic

[20:17] <masak> "synamic" sounds like it should mean something, though.

[20:17] <masak> quick, patch it into the spec! :)

[20:17] <__sri> the bottle neck is pretty much always the database

[20:18] * __sri quickly registers a trademark on "synamic"

[20:18] <masak> __:)

[20:18] <Eevee> fcgi is a strange beast

[20:18] <Eevee> you have to wrangle the server to speak it, wrangle the app to listen to it, and wrangle the sysadmin to understand wtf is going on

[20:18] <masak> __sri: is the database the bottleneck regardless of the database layout?

[20:18] <Eevee> three englishmen trying to use sanskrit as their common language

[20:19] <thou> TBA2: fyi, lichtkind++ was referring to the Perl6 Tablets, a set of docs he has written. if you're not understanding some perl6 thing, check there, and if it's insufficient, he's asking you let him know so he can expand on the topic. Tablets are at:  http://www.perlfoundation.org/perl6/index.cgi?perl_6_tablets

[20:19] <Su-Shee> Masak: I suggest for the spec: "Synamic dispatching is a new method of semantically meaningful dynamic between abstract interfaces at runtime" 

[20:19] <masak> Su-Shee: oh no, not this game again :P

[20:19] * sorear needs to learn German at some point

[20:20] <Su-Shee> masak: you said "spec" first ;)

[20:20] <flussence> Eevee: it's ugly, but it's the best I can convince my $dayjob to use, which is a hell of a lot better than they were on before :)

[20:20] <__sri> masak: yea

[20:20] <Eevee> flussence: much like svn, "better than the previous thing" seems to be fastcgi's main bullet point  :)

[20:20] <__sri> scaling web app servers is also a lot easier than scaling a database

[20:21] <Su-Shee> we skipped everything in between and went straight from cvs to git in the office. 

[20:21] <masak> Su-Shee: "These junctions will never reach parallel saturation, because their synamic core is isometric to the intrinsic protomodule."

[20:21] <flussence> thankfully I never had to use you-know-what there, even if I am stuck on svn. :)

[20:21] <Su-Shee> masak: very nice!

[20:21] <masak> :)

[20:21] <Eevee> current $work went from cvs-with-branching-bolted-on to svk-with-branching-bolted-on to git-with-branching-bolted-on

[20:21] <Su-Shee> *hihi* :)

[20:22] <flussence> that sounds... horrible

[20:22] <Eevee> I've quietly suggested that perhaps git doesn't really need branching bolted on, but the workflow has too much inertia

[20:22] <flussence> hey, at least you have a workflow!

[20:22] <Su-Shee> actually, we shoved 12 years of cvs straight into git and it just worked besides some scripts who now have to support git calls instead of cvs. 

[20:22] <Eevee> so when we have problems like "our main git repo has 60,000 tags", we solve it with "let's move the tags into a mysql database and delete them from git"

[20:23] <masak> some people here might appreciate http://www.johndcook.com/blog/2011/03/08/limerick-primes/#comment-88473

[20:23] <Su-Shee> Eevee: oh boy that totally sounds like us in principle...

[20:24] <TBA2> thou: thanks, didn't know about them!!

[20:24] <Su-Shee> dammit one of my devices makes a nasty high pitched sound...

[20:24] <lue> rakudo: say ":a<b>" ~~ /<?{Perl6::Grammar.parse($0, :rule<colonpair>)}>/;

[20:24] <p6eval> rakudo 248244: OUTPUT«␤»

[20:26] <flussence> Su-Shee: cheap timer ICs probably, I'm sitting near one that has an audible charging LED...

[20:26] <lue> Please tell me I did something wrong and it's not the fact that it's still a bug :)

[20:27] <TBA2> sleepy time, night #perl6

[20:27] <lue> goodnight TBA2 o/

[20:28] <masak> lue: you refer to $0, but there's no prior capture...

[20:30] <pmichaud> just pushed more operator reorgs and have to depart for ~1h... feel free to fix if I broke anything :)

[20:30] <pmichaud> bbl

[20:31] <lue> admittedly I just copy-n-pasted that bit from an old comment in Grammar.pm6, to see if it works now.

[20:32] <masak> lue: suggest knowing what it means first, and pointing out that it's a bug second :P

[20:32] <masak> (not that I always do it in that order...)

[20:32] <flussence> bug early, bug often

[20:32] <masak> +1

[20:33] <masak> there must be a dozen or more bugs in RT of the type "masak learns something new about the Perl 6 language"

[20:33] <masak> ("...by claiming it's wrong when it isn't")

[20:34] <moritz> and several hundred legitimate bug reports by masak++

[20:34] <masak> oh yeah, those...

[20:34] <masak> someone should fix those :P

[20:34] <dalek> rakudo/nom: 0b1f748 | pmichaud++ | src/core/ (4 files):

[20:34] <dalek> rakudo/nom: Operator reorganization part 3:  Move Int/Num/Real into {Int|Num|Real}.pm.

[20:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0b1f748b55

[20:34] <lue> Well, I was hoping I screwed something up :) . Now to add some tests for config stuff so I can see if that line works.

[20:40] *** ajoe47 left
[20:41] *** HarryS joined
[20:42] <moritz> we talk about that, and I see http://news.slashdot.org/story/11/06/19/183231/Life-As-a-Bug-Hunter?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+Slashdot%2Fslashdot+%28Slashdot%29 popping up in my feed reader. Coincidence?

[20:42] <lichtkind> thanks thou :)

[20:45] <thou> lichtkind: was machst du mit dem Tableten jetzt? hast uebersetzung neutig? ich kann ein bisschen deutsch, genug zu hilfen mit uebersetzung nach englisch.

[20:45] <lichtkind> thou: die denglishen sind wesentlich aktueller

[20:45] <lichtkind> in denen entwickle ich auch

[20:47] <lichtkind> sorear said he want to lean german :)

[20:50] <tadzik> hello zebras

[20:51] <masak> tadzikbot! \o/

[20:51] <tadzik> oh, then you know

[20:52] <tadzik> how are things?

[20:52] * masak <-- a bit tired

[20:52] <masak> tadzik: you?

[20:52] <lue> hello tadzik! o/

[20:53] <tadzik> masak: oh, semi-tired too

[20:54] <tadzik> also, lots of exam-learning

[20:54] <tadzik> with a true feeling that I know these things, but I still need to practice it like a madman

[20:54] <tadzik> lue: hellou!

[20:55] <masak> tadzik: jnthn and I did a little Perl Workshop this weekend. that was right after a full-day event at $owrk on the Friday. *that* was after a lot of slides-writing and another evening event on the Tuesday. I'm now having some free time, first time in a week. :)

[20:56] *** muixirt left
[20:57] <tadzik> how was the workshop?

[20:57] <tadzik> oh, stop pulling my leg, I know you were finishing the slides in the car riding to the workshop :P

[20:57] <masak> very good for a pair of n00bs, I think :)

[20:57] <jnthn> People seemed happy. No major incidents :)

[20:58] <masak> tadzik: I was editing the slides up until the last moments, yes... :)

[20:58] <lue> Just commited some changes to SUPERNOVA. (It's amazing how good it feels to commit something!)

[20:58] <tadzik> do you have some spare t-shirts with the bear-viking? :)

[20:59] <masak> tadzik: maybe... :)

[20:59] <tadzik> If there's an option, I'd like to be the first in the queue. This picture is lovely

[20:59] * masak feels happy

[20:59] <jnthn> .oO( I'm glad we chose that over the bare-viking... )

[21:00] <masak> jnthn: Conan the Bearbarian...

[21:00] <jnthn> masak++ # awesome drawing :)

[21:00] <tadzik> Conannson rather

[21:00] <masak> hey, I just sketched some posing bear off flickr and put a viking helmet on it :P

[21:01] <jnthn> masak: How much did you drink to think of doing that? :P

[21:01] <masak> jnthn: it's funny you bring that up... :P

[21:01] <tadzik> just a bit of bear :)

[21:01] * lue is curious about this bear now

[21:02] <masak> jnthn: I was 100% sober. I was sitting opposite some beer drinker who suggested it, though. :)

[21:02] <masak> lue: http://conferences.yapceurope.org/npw2011/

[21:02] <tadzik> oh, NPW'ers, you so crazy ;)

[21:02] <jnthn> masak: What a crazy guy :)

[21:03] <masak> you'd have to be crazy to be seen in that kind of helmet... :P

[21:03] <lue> :)

[21:04] * lue is resisting the strong urge to make it so that all the .pod files in the specs/ repo is considered the same file type by the file command

[21:05] *** kboga left
[21:10] <masak> right now in Rakudo, you have to use slurp("filename") but lines("filename".IO). that feels odd.

[21:11] <colomon> lines("filename".IO) doesn't actually work, does it?

[21:12] * colomon admits he has only tried "filename".IO.lines ...

[21:12] <masak> maybe it doesn't.

[21:12] <masak> rakudo: say lines("foo")

[21:12] <p6eval> rakudo 248244: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/FT9UetEfQh␤  in 'lines' at line 5929:CORE.setting␤  in main program body at line 22:/tmp/FT9UetEfQh␤»

[21:12] <masak> that indicates that Rakudo is still running under old assumptions.

[21:12] *** wamba joined
[21:13] <colomon> lines("foo") does work locally.

[21:13] <masak> sure.

[21:13] <masak> but it shouldn't, as per spec.

[21:13] <colomon> lines("foo".IO) does not

[21:13] <masak> well, lines("foo") should act on the string, not a file.

[21:13] <colomon> on the other hand, "foo".lines just returns the string "foo"

[21:13] <masak> right.

[21:14] <masak> that's what I'm talking about.

[21:14] *** jaldhar left
[21:14] <colomon> masak: yes, I know what the spec says here

[21:14] *** jaldhar joined
[21:14] <colomon> it's just weird that the method form follows the spec and the sub form does not

[21:15] <masak> agreed.

[21:15] <colomon> and it's a nuisance that .IO doesn't work.

[21:15] <masak> especially for us beginners' tutorial authors.

[21:16] * masak grumbles and hopes someone hears

[21:16] <colomon> I'm tempted to make a dummy class IO that just holds a single string and has .lines and .slurp.  :)

[21:17] <colomon> (and fix the sub forms in the process)

[21:17] <masak> :)

[21:18] *** Woodi left
[21:18] * lue &

[21:19] <colomon> seems like a terrible hack, but likely to be really handy.

[21:19] <pmichaud> back again

[21:20] * lichtkind is so happy :)

[21:20] <jnthn> o/ pmichaud 

[21:20] *** tokuhirom joined
[21:21] <jnthn> pmichaud: Prob won't get too much of your nommap tasks done tonight. May have better luck tomorrow evening though.

[21:21] <pmichaud> jnthn: no problem, I wasn't really expecting you to do much until you can decompress from this weekend :)

[21:21] <pmichaud> 20:34 <moritz> and several hundred legitimate bug reports by masak++

[21:21] <pmichaud> 20:34 <masak> oh yeah, those...

[21:21] <pmichaud> 20:34 <masak> someone should fix those :P

[21:22] <pmichaud> I'm working on that now.  It's called 'nom'  :P

[21:24] <jnthn> std: gather { take $^n }

[21:24] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Placeholder variable $^n may not be used here because the surrounding block takes no signature at /tmp/oWYbbVZvk_ line 1:␤------> [32mgather { take $^n[33m⏏[31m }[0m␤Check failed␤FAILED 00:01 121m␤»

[21:24] <lichtkind> jnthn, pmichaud o/

[21:24] <sorear> Rakudo thinks paths and open files are the same type of object

[21:24] <sorear> which may be wrong

[21:24] <pmichaud> lichtkind: o/

[21:24] <sorear> niecza: gather { take $^n } # did I break this?

[21:24] <p6eval> niecza v6-177-g365e216: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Placeholder variable $^n may not be used here because the surrounding block takes no signature at /tmp/xsKNQEqaCA line 1:␤------> [32mgather { take [33m⏏[31m$^n } # did I break this?[0m␤␤Unhandled exception: Check failed␤␤  at

[21:24] <p6eval> ../home/p6eval/niecza…

[21:24] <jnthn> hi lichtkind 

[21:24] <thou> lichtkind: :-)

[21:25] *** ymasory left
[21:26] <colomon> sorear: is that the right way to say it?  I would have thought Rakudo thinks paths are strings and open files are ... umm ... file objects? ... but sometimes takes a path string when it should have required an IO.

[21:27] *** thou left
[21:30] <lichtkind> thou: i thought you are away ?

[21:32] *** PacoLinux left
[21:37] *** wamba left
[21:40] * masak .oO( wherefore art thou away? )

[21:41] *** Psyche^ joined
[21:45] *** Patterner left
[21:45] *** Psyche^ is now known as Patterner

[21:45] *** takadonet left
[21:46] *** mberends left
[21:53] *** Woodi joined
[21:58] <masak> blog post! http://strangelyconsistent.org/blog/june-19-2011-reading-files

[22:05] <sorear> colomon: I/O objects in Rakudo sometimes represent unopened files, such as "foo".IO ~~ :e

[22:07] <masak> I wonder if it would be less confusing to have IO be called File.

[22:07] <masak> "foo".File ~~ :e

[22:08] <pmichaud> not all IO is files.

[22:08] <masak> right.

[22:08] <pmichaud> however, if it's coming from a pathspec, it might be.

[22:08] <masak> yes.

[22:08] <masak> maybe File ~~ IO or something.

[22:08] <colomon> sorear: that's spec, not Rakudo

[22:09] <lichtkind> sorear: thanks ofr bringing that up, that was my question 2 hours ago

[22:09] <masak> good night, #perl6.

[22:09] <pmichaud> masak: or maybe it should just be "file".xxx   that produces a IO object

[22:09] <lichtkind> good night masak

[22:09] <colomon> sorear: or at least....   hmmm

[22:09] <pmichaud> i.e.,  "foo".file

[22:09] <pmichaud> without having to be a type

[22:09] <lichtkind> have to drop you past tomorrow

[22:09] <masak> hm, yes, maybe

[22:09] <pmichaud> or even  "foo".path

[22:09] *** masak left
[22:09] <colomon> .path

[22:09] <colomon> +1

[22:09] <lichtkind> +1

[22:09] <pmichaud> or "foo".Path, if Path ever becomes a type

[22:10] <lichtkind> or take the path quotes

[22:10] <colomon> ah, I was kind of assuming it would be a type

[22:10] <lichtkind> qp//

[22:10] <colomon> rakudo: "file".IO; say "alive"

[22:10] <p6eval> rakudo 248244: OUTPUT«alive␤»

[22:10] <lichtkind> i like that idea very much it makes File::Spec obsolet

[22:11] <colomon> sorear: I take it back, I guess we do have .IO like that.  Interesting.

[22:12] <colomon> ugh, that's nasty

[22:13] <dalek> rakudo/nom: a8a615f | pmichaud++ | src/core/ (4 files):

[22:13] <dalek> rakudo/nom: More operator cleanups, a few bug fixes.

[22:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8a615f3e4

[22:13] <dalek> rakudo/nom: d16961b | pmichaud++ | src/core/Str.pm:

[22:13] <dalek> rakudo/nom: Fix some string operator bugs introduced by the operator refactor.

[22:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d16961b615

[22:14] * colomon is suddenly worried he is at least partially responsible for this mess.  Sigh.

[22:14] *** tokuhirom left
[22:15] <colomon> totally looks to me like half the methods in IO belong in a separate class, with Path seeming a reasonably likely name for it.

[22:15] <pmichaud> colomon: you'd be welcome to experiment with such ideas in nom, I think.

[22:16] *** s1n left
[22:16] <colomon> pmichaud: oooooooo....

[22:16] <pmichaud> don't have to worry about breaking spectests (yet :-)

[22:16] <colomon> :)

[22:16] <pmichaud> on the other hand, nom is still a raging frontier full of bugs.  masak will love it :)

[22:20] <colomon> biggest obstacle is that I probably should be spending any available perl time I have working on my presentation for YAPC::NA

[22:20] <jnthn> pmichaud: Did that operator bug fix you just did include one for an infinite recursion?

[22:20] <pmichaud> jnthn: yes

[22:21] <jnthn> phew :)

[22:21] <jnthn> nom: my @a = gather { for 1..10 -> $n { take $n } }

[22:21] <p6eval> nom: OUTPUT«Method 'clone' not found for invocant of class 'Sub'␤current instr.: '_block1002' pc 84 ((file unknown):55222760) (:1)␤»

[22:22] <jnthn> gah

[22:22] <pmichaud> that's the blorst bug

[22:22] <jnthn> nom: my @a = GATHER({ for 1..10 -> $n { take $n } })

[22:22] <p6eval> nom:  ( no output )

[22:22] <jnthn> Yeah, I know

[22:22] <pmichaud> (which I'm pretty sure is now called <blast> in STD.pm)

[22:22] <jnthn> ah :)

[22:22] <jnthn> nom: my @a = GATHER({ for 1..10 -> $n { take $n } }); say @a

[22:22] <p6eval> nom: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[22:26] <jnthn> nom: say { 'a' => 'b' }.WHAT

[22:26] <p6eval> nom: OUTPUT«Method 'list' not found for invocant of class 'Integer'␤current instr.: 'nqp;Perl6;Actions;_block3183' pc 61952 (src/gen/perl6-actions.pir:21977)␤»

[22:27] <jnthn> ah.

[22:28] *** tokuhirom joined
[22:29] *** tokuhirom left
[22:30] *** s1n joined
[22:33] <sorear> colomon: niecza goes the other way.  IO is the type of paths, open(:r) returns a TextReader

[22:34] <sorear> colomon: I do NOT like the idea of a single class with both reading and writing methods.  That's Java-think.  We have MI and roles, we doubly don't need it

[22:35] <colomon> sorear: are you saying with should have a path-class, a read-class and a write-class?

[22:35] * colomon doesn't know why he used dashes there.  it's been a long... errr... long period of time.

[22:37] <sorear> colomon: s:g/class/class or role/, but yes

[22:37] <pmichaud> .oO(...single class with both reading and writing methods has been around for far longer than Java  :)

[22:38] <sorear> probably the latter two ought to be roles, since @Larry doesn't like MI much

[22:38] <colomon> yeah, but the idea of reading and writing ... right, what sorear said.

[22:38] <sorear> pmichaud: C89's OO support is even worse than Java's. :)

[22:38] <colomon> :)

[22:38] <pmichaud> sorear: not to mention C++, or even the original C  FILE structure :-)

[22:38] * jnthn isn't that fond of inheritance generally, let alone multiple inheritance... :)

[22:39] <jnthn> It's telling that as early as the GoF book, they advocated composition over inheritance.

[22:39] <sorear> C++ has istream and ostream as separate classes.  one of the things it got right, I say ;)

[22:39] <colomon> jnthn: early?  You youngsters.. . ;)

[22:39] <dalek> rakudo/nom: 1c11415 | jnthn++ | src/Perl6/Actions.pm:

[22:39] <dalek> rakudo/nom: Toss existing phasers code; will need re-doing anyway.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c11415772

[22:39] <dalek> rakudo/nom: ba41493 | jnthn++ | src/Perl6/Actions.pm:

[22:39] <dalek> rakudo/nom: Fix pair handling.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba414932db

[22:39] <dalek> rakudo/nom: 15a3a15 | jnthn++ | src/Perl6/Actions.pm:

[22:39] <dalek> rakudo/nom: Fix gather; also fix loop along the way.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15a3a1501a

[22:39] <dalek> rakudo/nom: 605480d | jnthn++ | NOMMAP.markdown:

[22:39] <dalek> rakudo/nom: Remove a couple of done things from nommap.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/605480dd0d

[22:39] <dalek> rakudo/nom: 12d25b6 | jnthn++ | src/Perl6/Actions.pm:

[22:39] <dalek> rakudo/nom: Fix hash composer ({ a => 1, b => 2 }).

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/12d25b618d

[22:40] <jnthn> pmichaud: Some fixes :)

[22:40] <pmichaud> jnthn: niiiice

[22:40] <jnthn> pmichaud: It's not a new issue in nom, but something's up with quote parsing.

[22:40] <jnthn> pmichaud: say "abc { 2 + 2 }"

[22:41] <jnthn> pmichaud: Somehow we end up parsing/doing actions for that block twice.

[22:41] <jnthn> I'm at a loss as to why.

[22:41] <pmichaud> I'll look at it.  does it happen in nqp as well, or just rakudo/nom ?

[22:41] <jnthn> pmichaud: My suspicion is NQP also. Lemme try and check.

[22:43] <jnthn> Hmm, maybe not in NQP

[22:43] <pmichaud> yes, I'd be a little surprised if it happens in nqp

[22:43] <pmichaud> anyway, I'll check into it if you don't beat me to it :)

[22:44] <jnthn> OK

[22:44] <jnthn> It feels somehow familiar

[22:44] <jnthn> I think I ran into it when I was putting in interpolated stuff

[22:44] <jnthn> Where stuff = postcircumfixes.

[22:44] <pmichaud> postcircumfixes can cause double parses, yes.

[22:45] <pmichaud> it's one of the things I really dislike about them.

[22:45] <jnthn> Yeah, but I'd maybe not expect blocks to.

[22:45] <pmichaud> I agree, blocks shouldn't 

[22:45] <jnthn> It's just a tad wasteful.

[22:45] <sorear> string interpolation, in general

[22:45] <pmichaud> it's not only wasteful, if there are side effects it can be dangerous :-)

[22:45] <pmichaud> you have to be prepared to undo anything that got done in the middle

[22:46] <sorear> actually it seems it's set up to make it impossible to double parse anything containing a <term>

[22:46] <sorear> if you have the rest of the rules correctly...

[22:54] <pmichaud> I haven't looked at STD.pm6 closely in a while... but I wondered how it would handle

[22:54] <jnthn> pmichaud: "* undeclared type names produce Null PMC errors" => example?

[22:54] <jnthn> nom: say loldoesnotexist # ?

[22:54] <p6eval> nom: OUTPUT«Can only use get_who on a SixModelObject␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[22:55] <pmichaud> my $str = "With $scalar.methods.missing.term.paren( { BEGIN { oops() } } ..... no closing paren "

[22:55] <pmichaud> I'll go look again sometime.

[22:55] <jnthn> nom: my wtf $x;

[22:55] <p6eval> nom: OUTPUT«Malformed my at line 1, near "wtf $x;"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[22:55] <jnthn> nom: my WTF $x;

[22:55] <p6eval> nom: OUTPUT«In "my" declaration, typename WTF must be predeclared (or marked as declarative with :: prefix) at line 1, near " $x;"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[22:55] <pmichaud> nom:  say noexist.foo()

[22:55] <p6eval> nom: OUTPUT«Can only use get_who on a SixModelObject␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[22:55] <pmichaud> nmmm

[22:55] <pmichaud> hmmmm

[22:56] <jnthn> pmichaud: I know that error reporting is busted

[22:56] <sorear> pmichaud: There's no .suppose, so I think it ultimately becomes a FAILGOAL error

[22:56] <sorear> std: say "foo bar $_.pie(  "

[22:56] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse double quotes at /tmp/S84_byi2EO line 1:␤------> [32msay "foo bar $_.pie(  [33m⏏[31m"[0m␤Couldn't find final '"'; gave up at /tmp/S84_byi2EO line 1 (EOF):␤------> [32msay "foo bar $_.pie(  "[33m⏏[31m<EOL>[0m␤Parse

[22:56] <p6eval> ..failed␤FAILED…

[22:56] <sorear> std: say "foo bar $_.pie()  "

[22:56] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[22:56] <jnthn> pmichaud: I was wondering if you meant typename as in "something parsed by the typename rule"

[22:56] <pmichaud> jnthn: no, I mean unrecognized barewords

[22:56] <sorear> yeah.  once it starts parsing the postcirc, it's committed

[22:56] <jnthn> pmichaud: OK, then I follow :)

[22:57] <pmichaud> sorear: okay, I'm quite less concerned then.

[22:58] <pmichaud> so, once we start a postcirc, we're committed to completing it or abandoning the parse entirely

[22:58] <felher> good night, #perl6 :)

[22:58] <pmichaud> and postcircs are the only place where we'd get nasty side effects.

[22:59] <pmichaud> jnthn: I put that in NOMMAP because I kept running into null pmc errors when I'd use a bareword somewhere unexpected

[22:59] <pmichaud> maybe something like:

[23:00] <pmichaud> nom:  my $a = NoSuchType;

[23:00] <p6eval> nom: OUTPUT«Can only use get_who on a SixModelObject␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[23:00] <pmichaud> you can take that one out until I reproduce the error, if you like :)

[23:00] <pmichaud> when I come up with another example I'll put it back in (with the example)

[23:01] <jnthn> pmichaud: Well, it's a good reminder that I need to fix the above error anyway.

[23:01] <pmichaud> that too

[23:01] <pmichaud> but if I get the null pmc one again, I'll post the example.  I've had it bite me at least 3-4 times in the past 36 hours

[23:02] <pmichaud> (and then took me a little time to find it in each case)

[23:06] <jnthn> OK, thanks

[23:08] <jnthn> nom: fail('x')

[23:08] <p6eval> nom: OUTPUT«x␤current instr.: 'fail' pc 168906 (src/gen/CORE.setting.pir:42229) (:115)␤»

[23:08] <pmichaud> it's a dummy fail for now

[23:08] <pmichaud> it just dies

[23:08] <pmichaud> I'll actually mark it as such

[23:08] <jnthn> ah, ok

[23:09] <pmichaud> I figured it was easier to fix a dummy fail than to go into the code and s/die/fail/  everywhere that would need it

[23:12] <pmichaud> I'm still getting a fair number of Null PMC access in invoke() messages... might have an example shortly

[23:12] <sorear> actually I think there is one place where it can be a problem

[23:12] <sorear> std: "$foo.bar(): @baz"

[23:12] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable @baz is not predeclared at /tmp/1bV4BnpCuF line 1:␤------> [32m"$foo.bar(): @baz[33m⏏[31m"[0m␤Variable $foo is not predeclared at /tmp/1bV4BnpCuF line 1:␤------> [32m"$foo[33m⏏[31m.bar(): @baz"[0m␤Check failed␤FAILED 00:01 121m␤»

[23:13] <sorear> rakudo: $*OUT.say(): "Hi"

[23:13] <p6eval> rakudo 248244: OUTPUT«===SORRY!===␤Confused at line 22, near "$*OUT.say("␤»

[23:13] <sorear> I think <args> should probably check $*QSIGIL and refuse to allow :=-syntax if so

[23:13] <sorear> er, :-syntax

[23:14] *** whiteknight joined
[23:16] <jnthn> nom: foo::bar

[23:16] <p6eval> nom: OUTPUT«Null PMC access in invoke()␤current instr.: '_block1002' pc 83 ((file unknown):53310070) (:1)␤»

[23:16] <jnthn> pmichaud: Like that? :)

[23:16] <pmichaud> Like that.

[23:16] <pmichaud> but I don't think I've had many :: bareword names

[23:16] <pmichaud> and I'm sure it's occurred in some cases where there wasn't a ::

[23:17] <pmichaud> oh, come to think of it, maybe not

[23:17] <pmichaud> ummmm.... not sure

[23:18] <pmichaud> I may work on numerics later tonight

[23:18] <pmichaud> (e.g., 3.5  and the like)

[23:19] <jnthn> pmichaud: Well, I fix the cases I can see, and just note any others when you see them.

[23:19] <pmichaud> I will definitely do that.

[23:19] * jnthn wishes he was tired :/

[23:19] <jnthn> I should be.

[23:19] <jnthn> Maybe the nap earlier this evening was a bad idea. :)

[23:19] <pmichaud> I didn't start marking things in NOMMAP until earlier today (didn't figure out how I wanted to mark them until earlier today)

[23:26] *** thou joined
[23:27] <jnthn> nom: sub foo($x where -> $n { $n < 42 }) { }

[23:27] <p6eval> nom:  ( no output )

[23:27] <jnthn> nom: sub foo($x where -> $n { $n < 42 }) { say 'ok' }; foo(40)

[23:27] <p6eval> nom: OUTPUT«ok␤»

[23:27] <jnthn> nom: sub foo($x where -> $n { $n < 42 }) { say 'ok' }; foo(42)

[23:27] <p6eval> nom: OUTPUT«Constraint type check failed for parameter '$x'␤current instr.: 'foo' pc 274 ((file unknown):39409697) (:1)␤»

[23:28] <jnthn> ah, I did it and forgot to remove it from nommap :)

[23:32] <jnthn> pmichaud: I removed the lookup errors issue form nommap.

[23:32] <jnthn> (After fixing the ones I could find)

[23:32] <pmichaud> jnthn: wfm

[23:32] <jnthn> Please add it back if you find more, with example. :)

[23:32] <pmichaud> will do :)

[23:33] *** daniel-s joined
[23:35] <jnthn> pmichaud: Meh. We've got down to one loadinit. It's still one too many...

[23:35] <pmichaud> :-P

[23:36] <jnthn> pmichaud: Remember that horrible roles and lexicals issue we had in master?

[23:36] <pmichaud> I try not to remember that.

[23:36] <pmichaud> (but fail.)

[23:36] <jnthn> Yeah, well...

[23:36] <jnthn> It's back. :/

[23:36] <jnthn> Same reason. The loadinit.

[23:37] <dalek> rakudo/nom: d254daf | jnthn++ | src/Perl6/Grammar.pm:

[23:37] <dalek> rakudo/nom: Fix missing $?PACKAGE set for UNIT.

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d254daf361

[23:37] <dalek> rakudo/nom: 5dda806 | jnthn++ | src/Perl6/SymbolTable.pm:

[23:37] <dalek> rakudo/nom: Give a more helpful message than null PMC access for some busted lookups.

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5dda806004

[23:37] <dalek> rakudo/nom: e61533a | jnthn++ | src/Perl6/SymbolTable.pm:

[23:37] <dalek> rakudo/nom: Fix other known case of symbol non-existance giving a crappy error.

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e61533a8c0

[23:37] <dalek> rakudo/nom: f4ef8df | jnthn++ | NOMMAP.markdown:

[23:37] <dalek> rakudo/nom: Update nommap.

[23:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4ef8dfed0

[23:37] <jnthn> pmichaud: I'm wondering what happens if the very, very first thing we do in UNIT is call the thing that's currently the loadinit...

[23:37] <jnthn> pmichaud: Though I fear it's not quite that simple.

[23:39] <pmichaud> I don't have a problem with that approach.  Since BEGIN is being handled quite differently now, it might work.

[23:39] * sorear is struggling still with packages

[23:39] <jnthn> pmichaud: I'm pondering having the INITs all fired at the end of the deserialization/fixup.

[23:39] <pmichaud> INIT?  or CHECK?

[23:39] <jnthn> pmichaud: BEGIN and CHECK are parse-time.

[23:39] <sorear> How are BEGINs handled now?

[23:39] <jnthn> sorear: They're not yet :)

[23:40] <jnthn> pmichaud: CHECK comes after we're done with the grammar and actions, and before we go PAST => PIR

[23:40] <pmichaud> jnthn: right, BEGIN and CHECK are parse time, but we used to have some code to duplicate their effects in master upon load.  That's now being handled by the SC, iiuc.

[23:40] <jnthn> Right

[23:40] <pmichaud> which means the reasons for using :loadinit are much less

[23:40] <jnthn> That was my feeling too.

[23:41] <pmichaud> the biggest challenge I'd see is with use

[23:41] <pmichaud> i.e., when we use a module, we need to get its "loadinit" to fire right away before we continue parsing

[23:41] <jnthn> pmichaud: We already run its mainline.

[23:41] <jnthn> pmichaud: If that is what fires the "loadinit" too, we're fine.

[23:41] <pmichaud> jnthn: ...via :load, or some other mechanism?

[23:42] <jnthn> oh sh...

[23:42] <jnthn> Oh, I think we get away with it.

[23:42] <pmichaud> currently it happens via :load, iiuc

[23:42] *** takadonet joined
[23:42] <jnthn> Yeah

[23:42] <pmichaud> HOWEVER

[23:42] <pmichaud> !!

[23:42] <jnthn> But if we go load => mainline => "loadinit"

[23:42] <jnthn> The outers are all fine.

[23:43] <pmichaud> NotFound++ just added some feature in Parrot to be able to locate the :main sub in an Eval PMC or Packfile or whatever

[23:43] <pmichaud> so maybe we could turn off the :load and instead search for :main out of the loaded module and invoke it from there

[23:43] *** y3llow left
[23:44] *** pothos left
[23:44] <pmichaud> the problem with :load => mainline => "loadinit"  is that :load isn't in our lexical scope

[23:44] <pmichaud> perhaps it could search up the caller chain to find the lexical scope, however.

[23:44] <pmichaud> and then attach mainline to that before invoking it

[23:44] <jnthn> Maybe

[23:44] <pmichaud> or!!!!!

[23:45] <pmichaud> :load could simply stick the desired mainline in some fixed location

[23:45] <jnthn> The issue we really get into is that the role body gets invoked before the mainline callframe exists

[23:45] <jnthn> It's that mis-ordering that gets us into bother.

[23:45] <pmichaud> we then get back from :load (having not executed the module's mainline or loadinit yet), look in that fixed location for the mainline and invoke it from the correct context

[23:45] <thou> i think pmichaud is excited by this problem

[23:46] <thou> !!!!! :-)

[23:46] <jnthn> That's another option but I'm not sure it handles the outer pointers going to the rong place.

[23:46] <pmichaud> it might not

[23:46] <pmichaud> but it will hugely help

[23:46] <pmichaud> thinking

[23:48] <pmichaud> if the role body is invoked first, does that auto-close the mainline callframe?

[23:48] <jnthn> Something like that

[23:48] <jnthn> At the moment it's failing to find the setting

[23:48] <jnthn> Which I think is a result of it auto-closing the mainline callframe

[23:48] <pmichaud> so, we can either try to find the mainline callframe that the role body (bodies) used and steal it for our mainline

[23:49] <jnthn> hm

[23:49] <pmichaud> or we can re-point the role bodies to the correct outers when our mainline is invoked

[23:49] <jnthn> that's...tricky.

[23:49] <jnthn> Yes, that's what we do in master.

[23:49] <jnthn> I can factor it less evily in nom though.

[23:49] <jnthn> I was hoping there may be a nicer way

[23:49] *** info joined
[23:49] <jnthn> But maybe there ain't.

[23:49] <pmichaud> I think we can get the mainline callframe before invoking it

[23:49] <pmichaud> thinking...

[23:49] <jnthn> Hmm

[23:50] <pmichaud> (restoring it and/or resuing it might be tricky.  but we really just want its lexpad, yes?

[23:50] <pmichaud> *reusing

[23:51] <jnthn> kinda

[23:51] <jnthn> hm

[23:51] <jnthn> I need to sleep

[23:51] <jnthn> $dayjob tomorrow

[23:51] <pmichaud> np

[23:51] <jnthn> And I'm meant to be exhausted :)

[23:51] <pmichaud> I'll brainstorm in bg a bit more on this

[23:52] <jnthn> OK, thanks ;)

[23:52] <pmichaud> oh, I have a really nasty idea

[23:52] <jnthn> Anyway, need to fix roles up so we can have Positional

[23:52] <pmichaud> you won't like it :)

[23:52] <jnthn> And Numeric and all that lot

[23:52] <jnthn> heh :)

[23:52] <pmichaud> we could do the same thing I do for gather/take

[23:53] <pmichaud> invoke the mainline.  the mainline instantly does capture_lex on its (role bodies), and then .yields() back to the caller.  Do whatever else we need to do.  Then resume the mainline after the .yield()

[23:53] <lichtkind> sorear: did you start niecza ?

[23:53] <jnthn> eek!

[23:54] <jnthn> pmichaud: That's evil and would probably work... :)

[23:54] <pmichaud> but overall I think the idea is correct that we want to invoke our "loadinit" stuff outside of :load/:init

[23:54] <pmichaud> i.e., as the first step in the mainline

[23:55] <pmichaud> anyway, more to play with tomorrow :)

[23:55] <jnthn> aye

[23:56] <pmichaud> being able to put Positional on classes would help with a lot of stuff

[23:56] <jnthn> Sure

[23:56] <jnthn> Will try and churn that out soon

[23:56] <pmichaud> without it I can't multi-dispatch on @foo versus $foo

[23:56] <jnthn> Things are busy-ish, but should get some hacking time.

[23:56] <jnthn> Friday and weekend will be free for Perl 6 stuff too :)

[23:56] <pmichaud> excellent

[23:57] <pmichaud> my schedule is fairly open as long as things remain stable health-wise here at the house :)

[23:57] <jnthn> ok :)

[23:57] <pmichaud> so I'm just going to keep hacking away at nom

[23:57] <jnthn> Wow. We have over 2000 lines of setting...

[23:57] <pmichaud> I'm about to remove some

[23:57] <jnthn> :)

[23:57] <pmichaud> I figured out a much cleaner Range implementation

[23:57] <jnthn> oh, nice

[23:57] <pmichaud> about to commit + push now

[23:58] <jnthn> nom: my @a = gather { take 1; take 2; take 3; }; say @a

[23:58] <p6eval> nom: OUTPUT«1 2 3␤»

[23:58] <jnthn> \o/

[23:58] <jnthn> nom: foo::bar

[23:58] <p6eval> nom: OUTPUT«Could not find symbol 'foo::&bar'␤current instr.: 'fail' pc 168948 (src/gen/CORE.setting.pir:42238) (:115)␤»

[23:58] <jnthn> nom: foo

[23:58] <p6eval> nom: OUTPUT«Could not find symbol '&foo'␤current instr.: 'fail' pc 168948 (src/gen/CORE.setting.pir:42238) (:115)␤»

[23:58] <jnthn> Improvements. :)

[23:58] <jnthn> nom: our sub foo() { say 1 }; GLOBAL::foo()

[23:58] <p6eval> nom: OUTPUT«1␤»

[23:58] <jnthn> Good.

[23:59] <pmichaud> nice nice nice

[23:59] <pmichaud> I can clean up a couple of workarounds now

