[00:00] <diakopter> it's the only subrule call I can find, and subrule is in the backtrace

[00:00] <diakopter> and the error is Don't know how to save info from node of type String

[00:01] <diakopter> at least, I think it falls under subrule

[00:04] <cognominal> rakudo: grammar G is HLL::Grammar { }

[00:04] <p6eval> rakudo 8839b1: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Routine $r, Any $info, Any $inlinable)␤:(Pa…

[00:07] *** cooper left
[00:08] <diakopter> hunh. nqp (not nqpq) fails a lot of the 01-regex.t tests

[00:10] <diakopter> I'm not much help today

[00:12] <jnthn> diakopter: Is that maybe a side-effect of having build nqpq? (just a wild guess...)

[00:12] <diakopter> no idea

[00:12] * diakopter continues commenting parts of 01-regex.t out until it compiles

[00:15] <diakopter> hm, maybe it's in NQPHLL

[00:15] * diakopter looks for that

[00:16] <diakopter> no, that's already compiled to pbc

[00:17] <jnthn> diakopter: oh!!

[00:17] <jnthn> my $result := $string ~~ /<$regex>/;

[00:17] <jnthn> diakopter: OK, that looks like it's because interpolation is not yet implemented in nqpq.

[00:18] <jnthn> diakopter: So it's same reason 49-regex-interpolation.t rails

[00:18] <jnthn> er, fails

[00:19] *** _dolmen_ joined
[00:19] <diakopter> well, even commenting those two out doesn't seem to fix

[00:20] <jnthn> diakopter: the .t file in p6regex.t is a test runner

[00:21] <diakopter> I know

[00:21] <jnthn> diakopter: It won't work until 49-regex-interpolation.t does.

[00:21] <diakopter> actually, commenting both of those out makes it give a different error

[00:21] *** _dolmen_ left
[00:21] <diakopter> Method 'CURSOR' not found for invocant of class 'NQPMatch'

[00:21] <jnthn> oh, that one is probably easy to fix :)

[00:22] * diakopter looks for NQPMatch

[00:23] <jnthn> It's somewhere in src/QRegex/Cursor.nqp iirc

[00:23] * diakopter adds it

[00:24] *** icwiener left
[00:24] * diakopter wonders how to impl interpolation

[00:24] *** cooper joined
[00:29] *** localhost left
[00:29] <dalek> nqp: e1a19de | diakopter++ | src/QRegex/Cursor.nqp:

[00:29] <dalek> nqp: add missing CURSOR method to NQPMatch

[00:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e1a19def20

[00:30] *** localhost joined
[00:36] *** PacoLinux_ joined
[00:52] <jnthn> 'night, #perl6

[00:52] <diakopter> jnthn: o/

[00:52] *** PacoLinux_ left
[00:56] *** molaf_ joined
[00:58] *** autin joined
[01:00] *** molaf left
[01:01] *** pmurias_ left
[01:01] <dalek> roast: 41f3591 | coke++ | S05-interpolation/regex-in-variable.t:

[01:01] <dalek> roast: rakudo fudge

[01:01] <dalek> roast: review: https://github.com/perl6/roast/commit/41f359146b

[01:03] <dalek> rakudo/nom: 8c69edb | coke++ | t/spectest.data:

[01:03] <dalek> rakudo/nom: track failure modes/run fudged tests

[01:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c69edbe29

[01:04] <diakopter> [Coke]: I think the two Multiple array tests there above your last commit are succeeding misleadingly

[01:05] <diakopter> none of those interpolation ones will succeed

[01:07] *** Mowah_ left
[01:13] *** cooper left
[01:14] *** tokuhirom joined
[01:27] *** plutoid joined
[01:41] *** [Sec] joined
[01:54] *** wolfman2000 joined
[02:02] * colomon is too lazy to backlog -- anything exciting happen today?  (Was at Christmas parade and then football game.)

[02:12] *** pat_js left
[02:18] *** tokuhirom left
[02:19] *** IngisKahn left
[02:21] *** buubot_backup left
[02:21] *** tokuhirom joined
[02:28] *** tokuhirom left
[02:32] <diakopter> whee

[02:32] <diakopter> found and fixed a bug

[02:32] <dalek> nqp: fd2fd16 | diakopter++ | src/QAST/Compiler.nqp:

[02:32] <dalek> nqp: make conjseq handle zerowidth subtype

[02:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fd2fd16c7d

[02:32] <colomon> diakopter++

[02:36] *** aindilis left
[02:36] *** aindilis joined
[02:37] *** cooper joined
[02:41] *** buubot_backup joined
[02:42] *** risou_awy is now known as risou

[02:48] *** am0c joined
[03:00] *** Guest51139 left
[03:05] *** lichtkind left
[03:06] <diakopter> phenny: tell jnthn I fixed/finished and applied your negate/backslash patch

[03:06] <phenny> diakopter: I'll pass that on when jnthn is around.

[03:09] <dalek> nqp: 856a79c | diakopter++ | src/QRegex/P6Regex/ (2 files):

[03:09] <dalek> nqp: enable backslash sequences in character classes, enable negated character classes. patch mostly from jnthn++

[03:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/856a79c18f

[03:09] *** Logicus joined
[03:10] <Logicus> Anyone out there?

[03:10] <diakopter> hi

[03:10] <Logicus> ah evening :)

[03:14] *** Logicus_ joined
[03:15] *** Logicus left
[03:15] <Logicus_> perl6: say 3;

[03:15] <p6eval> pugs b927740, rakudo 8c69ed, niecza v11-24-gcdd4e66: OUTPUT«3␤»

[03:15] <Logicus_> hrm

[03:15] *** tokuhirom joined
[03:16] <diakopter> rakudo and niecza are the two actively developed implementations

[03:16] <Logicus_> ok

[03:16] <Logicus_> im completely new to perl 6

[03:17] <diakopter> welcome :)

[03:17] <Logicus_> I've been learning Perl5 for a few years, but in a very heretical way

[03:17] <sjn> That's better than most other people :)

[03:17] <Logicus_> had very big arguments with various PerlMonks who didn't like my ideas

[03:17] * sjn notes most other people don't know any Perl6 at all

[03:18] <Logicus_> it seems very mysterious somehow

[03:18] <sjn> Logicus_: do your ideas make it easier for people to understand what's going on in your code? :)

[03:18] <Logicus_> yes.

[03:18] <sjn> are you sure? :)

[03:19] <diakopter> Logicus_: if your P5 ideas work for you, that's great. Maybe the monks disagreed with you if you said your ideas were the "right" way to do things.

[03:19] <Logicus_> to put it in a nutshell, i wrote a sort of Lispish language in Perl without even really knowing what I was doing

[03:19] *** tokuhirom left
[03:19] <Logicus_> I want to start looking at Perl 6 with a view to getting my system recoded in it by the time it's ready 

[03:20] <diakopter> Logicus_: you have a choice of using rakudo, which currently runs only on the Parrot VM, and niecza, which currently runs on the CLR (both Microsoft .Net and mono)

[03:20] <Logicus_> well it's a long story, about 4 years ago I came to perlmonks all humble like and tried to share what I had and get feedback on how to make it faster

[03:21] <Logicus_> I'm using Ubuntu Maverick if that's any help...

[03:21] <sjn> what kind of language constructs did you make that you thought Perl5 was missing?

[03:21] <Logicus_> they looked at my baby perl of the time and dismissed it

[03:21] <diakopter> people can be dismissive :)

[03:21] <Logicus_> well I didn't know what was missing or what was in place or anything at the time

[03:21] <sjn> critique can be a harsh mistress

[03:22] <Logicus_> I just solved the problem infront of me in what turned out to be a completely different way to how the mainstream solved it

[03:22] <Logicus_> your not wrong they made me want to completely give up on perl 

[03:22] <diakopter> everybody has a different learning path

[03:22] <sorear> hello Logicus_

[03:22] <Logicus_> but I didn't, and just recently I've combined my system with PSGI/Plack

[03:22] <Logicus_> hi

[03:23] <sorear> Logicus_: perl 6 has a lot of lisp influences

[03:23] <Logicus_> my learning path was through "tizag.com"

[03:24] <Logicus_> I'm good at solving problems by myself so that was all the reference I needed for a long time

[03:24] <sorear> Logicus_: have you seen _Higher Order Perl_?

[03:24] <sjn> half of all programming in communicating the intent of your program to the next guy (which might even be yourself in three months). Which is mainly a communication job; meaning you have to think about how you form your message so the recipient/reader has the best chance of understanding your message/code

[03:24] <Logicus_> yup, MJD

[03:24] <Logicus_> my system has some H.O.Pish properties that are very nice

[03:24] <sorear> sjn: communication and memory are the same problem through special relativity-colored glasses

[03:25] <Logicus_> that was a big part of my problem... communicating what I had 

[03:25] <sjn> sorear: I have no idea what you just tried to say there :)

[03:25] <sorear> heh.. communication is a large part of what we deal with every day

[03:25] <Logicus_> you see I came at it from a totally bizarre angle and I didn't know any of the mainstream stuff to relate it to at first

[03:26] <sorear> we encourage many of our members to keep their heads in the clouds

[03:26] <sjn> "mainstream

[03:26] <sjn> oops

[03:26] <Logicus_> that's cool :)

[03:26] <sorear> and then every few days TimToady comes up with a brilliant but WTF idea and we have to figure out what he means

[03:26] <Logicus_> im really not a mainstream sort of person lol... the idea of getting a job doing mainstream perl and writing unit tests and things gives me day-mares

[03:27] <diakopter> Logicus_: don't feel alone; I'm sure there are tens of thousands of Perl users like that

[03:27] <sorear> Logicus_: I'm curious if you're out of school now.  There seems to be a strong youth bias in P6 versus the broader Perl community

[03:27] <Logicus_> I'm 31

[03:27] * diakopter too

[03:28] <Logicus_> but I must admit, part of my brain is still about 15

[03:28] <Logicus_> :P

[03:28] <diakopter> part of my brain is about 105  (for the worse, not for the better) :/

[03:28] <sjn> "mainstream" means "something do people do". when it comes to languages, mainstream is really a positive thing. if many people use the same language for expressing things, more people have access to that expression. it's like choosing to write a book in a mainsteam language like "English" instead of a smaller (but perhaps more expressive) language like Northern Saami

[03:28] <Logicus_> well there is the whole spectrum eh, when 900 years old you reach... etc

[03:29] <sjn> more accessibility (mainstreamy-ness) means more people can understand what you're trying to do, meaning more people can help you improve your work

[03:29] * diakopter has no clue how to solve https://rt.perl.org/rt3//Public/Bug/Display.html?id=100650

[03:30] <Logicus_> I've always wanted to get people on board with what I'm doing but so far I've failed to sell it very well

[03:30] <Logicus_> I'm just not a salesman at all

[03:30] <sjn> critique = good

[03:30] <diakopter> phenny: tell jnthn conj didn't handle zerowidth; I fixed that first

[03:30] <phenny> diakopter: I'll pass that on when jnthn is around.

[03:30] <Logicus_> oh im all for critique, but just not dismissive critique coming from someone who hasn't really looked at the problem properly

[03:30] <sorear> nom: say so 'aaabaaa' ~~ /^ (.*) b/

[03:30] <p6eval> nom 8c69ed: OUTPUT«Bool::False␤»

[03:31] <sorear> nom: say so 'aaabaaa' ~~ /^ .* b/

[03:31] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[03:31] <Logicus_> I just setup a new site http://www.perlnights.com

[03:31] <sorear> nom: say so 'aab' ~~ /^ (a*) b/

[03:31] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[03:31] <sorear> nom: say so 'aab' ~~ /^ (aa || a) b/

[03:31] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[03:31] <Logicus_> I've put loads of stuff up there

[03:31] <sorear> nom: say so 'aab' ~~ /^ (a || aa) b/

[03:31] <p6eval> nom 8c69ed: OUTPUT«Bool::False␤»

[03:31] <diakopter> sorear: oooo

[03:31] <sorear> diakopter: quantifiers have nada to do with this

[03:31] <Logicus_> How close are we to getting Perl 6 to perform like 5 does?

[03:32] <sorear> backtracking into parens is broken

[03:32] <diakopter> Logicus_: kindof a long way, unfortunately

[03:32] <sorear> diakopter: do grammars and // use the same regex engine yet?

[03:32] <sorear> I remember nom diverged them for a while

[03:32] <diakopter> in nom, yes I'm pretty sure. it's reproducible in nqpq too

[03:32] <sorear> Logicus_: depends on the aspect by which you mean

[03:33] <sorear> nom: my $foo = / aa /; say so 'aab' ~~ /^ <$foo> b/

[03:33] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[03:33] <sorear> nom: my $foo = / aa || a /; say so 'aab' ~~ /^ <$foo> b/

[03:33] <Logicus_> well I'd really like my aXML system to be the first web-dev framework out on Perl 6

[03:33] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[03:33] <sorear> nom: my $foo = / a || aa /; say so 'aab' ~~ /^ <$foo> b/

[03:33] <p6eval> nom 8c69ed: OUTPUT«Bool::False␤»

[03:34] <sorear> diakopter: it's not just inline () subrules, all subrules are backtrack-broken

[03:34] <diakopter> sorear: yup

[03:34] <diakopter> good find

[03:34] <sorear> nom: my $foo = /:!r a || aa /; say so 'aab' ~~ /:!r ^ <$foo> b/ # I wonder if :r is being forced on by accident

[03:34] <p6eval> nom 8c69ed: OUTPUT«Bool::False␤»

[03:34] <sorear> nope, not that

[03:34] <sorear> Logicus_: too late for that

[03:34] <Logicus_> ok, one of the first

[03:35] *** cooper left
[03:35] *** natureboy joined
[03:35] <Logicus_> I'm too late with Perl5 I think, everyone already has strongly held beliefs about how things should be done with it

[03:36] <Logicus_> they don't like this sort of thing at all : <count str="<sqd>str</sqd>">(db_get)blog.chapter="(sqd)chapter(/sqd)".content(/db_get)</count> 

[03:36] <sorear> :P

[03:36] <sorear> ...what?

[03:36] <Logicus_> exactly!

[03:36] <sorear> I don't understand that at all

[03:37] <Logicus_> that's how far outside the mainstream I am lol

[03:37] <sorear> you need to write a freaking manual

[03:37] <Logicus_> working on it

[03:37] <sorear> good

[03:37] <Logicus_> http://www.perlnights.com/action.pl?action=library/aXML

[03:38] <sorear> if you're going to speak using special jargon, you need to define your terms

[03:38] <Logicus_> understood :)

[03:40] <Logicus_> brb - ciggy break

[03:41] <sorear> you might not want to name anything in a Perl community after Merlyn

[03:41] <sorear> that's the screen name of Randal L. Schwartz

[03:45] <Logicus_> yeh I didn't know there was a merlyn when I chose that

[03:45] <Logicus_> why not btw?

[03:46] <Logicus_> I picked that name to fit in with the castle theme (as the opposite to a monastery)

[03:47] <Logicus_> Kn1ghts and M0nks... 1/0 you see

[03:48] <Logicus_> I was shocked when one of the first posts in that section was by a user called merlyn!

[03:49] <Logicus_> then I looked up the name and found out about the schwartzian transform

[03:49] <Logicus_> I thought it was impressive?

[03:59] <Logicus_> hrm.. ping?

[04:03] <Logicus_> .... tumbleweed rolls by ....

[04:04] *** kaleem joined
[04:04] <Logicus_> hi

[04:12] <sorear> Logicus_: you're going to need to learn patience if you want to fit in here.

[04:12] <Logicus_> I was just wondering if I had lost connection again

[04:13] <Logicus_> im reading exegesis 2 by damian conway right now

[04:14] *** kaleem left
[04:14] <diakopter> Logicus_: that's quite outdated

[04:15] <diakopter> just read http://www.perlcabal.org/syn/S02.html instead

[04:15] <Logicus_> do  you... ah lol 

[04:15] <Logicus_> read my mind :)

[04:15] <diakopter> notice the pretty table of contents :)

[04:15] <Logicus_> now I know this page will make a beep when there is activity I can be looking elsewhere between saying stuff

[04:16] <Logicus_> that's quite a large table!

[04:17] <diakopter> it's a very long Synopsis

[04:19] <sorear> Logicus_: be warned that a common side-effect of hanging out here is ego deflation

[04:19] <Logicus_> what is it with programmers and ego eh?

[04:19] *** natureboy left
[04:20] <sorear> #perl6 is a pretty exceptional place

[04:20] <sorear> the "mainstream" encourages people to be loud and egotistical

[04:20] * diakopter stares at src/QAST/Compiler.nqp

[04:20] <sorear> we're not that way

[04:23] <Logicus_> I've never been either unless pushed into it

[04:23] <Logicus_> (like on perlmonks)

[04:25] * diakopter wonders how backtracking into subrules could ever work in this engine

[04:27] <diakopter> hrm

[04:28] <diakopter> oh.

[04:28] <diakopter> cursor_next

[04:35] <Logicus_> sorear, you didn't answer my Q about randal... is there something I should know about him? 

[04:38] *** molaf_ left
[04:42] <Logicus_> well I'm going to bed, thanks for that link diakopter, I will read the rest of that with interest tomorrow!

[04:42] <Logicus_> night!

[04:43] <diakopter> o/

[04:43] *** Logicus_ left
[04:57] *** benabik left
[04:57] *** benabik joined
[05:04] *** PacoLinux_ joined
[05:08] *** PacoLinux_ left
[05:11] *** IngisKahn joined
[05:27] *** jdhore1 left
[05:27] <diakopter> sorear: I added backtracking to subrule :) I feel proud

[05:30] <dalek> nqp: 035ecba | diakopter++ | src/QAST/Compiler.nqp:

[05:30] <dalek> nqp: add backtracking support to subrule (captures included). Tested, barely. :)

[05:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/035ecba059

[05:31] <diakopter> phenny: tell jnthn I added backtracking to subrule to fix the bug you pointed out. Seems to work for the test cases I tried. No idea whether it regresses anything else. :/

[05:31] <phenny> diakopter: I'll pass that on when jnthn is around.

[05:33] <diakopter> I wish there were a p6eval target for nqpq

[05:33] <diakopter> *was

[05:36] <diakopter> well, there's a bug

[05:37] <diakopter> it doesn't like nested captures

[05:37] <diakopter> Null PMC Access

[05:39] <diakopter> phenny: tell jnthn hrm; it doesn't like backtracking into nested captures.

[05:39] <phenny> diakopter: I'll pass that on when jnthn is around.

[05:40] <diakopter> maybe I used $P11 instead of %*REG<cur> somewhere

[05:42] <diakopter> b: 23:30 <+dalek> nqp: 035ecba | diakopter++ | src/QAST/Compiler.nqp:

[05:43] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Confused at line 22, near "23:30 <+da"␤»

[05:43] <diakopter> er

[05:43] <diakopter> 23:30 <+dalek> nqp: 035ecba | diakopter++ | src/QAST/Compiler.nqp:

[05:43] <diakopter> ugh

[05:44] <diakopter> this is troubling. from Regex to QRegex, Pm removed the capability to store a cursor on the backtracking stack

[05:46] <diakopter> ergh

[05:47] <TimToady> with lazy lists of cursors you don't need a backtracking stack

[05:53] <diakopter> QRegex doesn't have that I'm preetty sure

[06:00] *** localhost left
[06:01] *** localhost joined
[06:33] *** am0c left
[06:35] *** am0c joined
[06:36] *** colorspace joined
[06:36] *** colorspace left
[06:36] *** am0c left
[06:59] *** Chillance left
[07:03] *** sayu joined
[07:29] *** sayu left
[07:47] *** tokuhirom joined
[07:58] *** daniel-s joined
[08:22] *** birdwindupbird joined
[08:23] *** birdwindupbird left
[08:23] *** birdwindupbird joined
[08:24] <diakopter> hm

[08:24] <diakopter> maybe I need to use the cstack

[08:34] <tadzik> good morning

[08:34] <diakopter> o/

[08:34] <diakopter> hey, weren't you just here

[08:34] <tadzik> hm?

[08:35] <diakopter> oh, I guess 8.5 hours ago

[08:35] <diakopter> time flies

[08:35] <tadzik> oh, could've had a longer sleep ;)

[08:43] <tadzik> hmm, to silence all prints/says in a lexical scope I could change $*OUT to... what?

[08:45] <tadzik> I can $*OUT = $some-opened-file, but what if I want to silence it completely?

[08:45] <tadzik> besides opening /dev/null

[08:50] *** am0c joined
[08:50] * diakopter wonders whether I should stay awake until jnthn returns

[08:55] <sorear> tadzik: I guess something like temp $*OUT but= role { method print(*@_) { } };

[08:56] <tadzik> aye, I was thinking about that too

[08:56] <sorear> but that won't work on niecza because &CORE::say and &CORE::print bypass $*OUT entirely

[08:56] <sorear> the spec is silent on exactly which $*OUT methods call which other

[09:04] *** birdwindupbird left
[09:04] *** birdwindupbird joined
[09:04] <sorear> actually it won't work on niecza because but still hasn't been completely implemented :/

[09:05] * diakopter still doesn't know what but means

[09:06] <tadzik> it's like does, but doesn't modify the object, but creates a new one? I think, unsure

[09:06] <tadzik> 0 does True would modify 0, 0 but True will create a funny object

[09:07] <tadzik> nom: 0 does True; say ?0

[09:07] <p6eval> nom 8c69ed: OUTPUT«No applicable candidates found to dispatch to for 'infix:<does>'. Available candidates are:␤:(Mu $obj, Positional @roles)␤:(Mu $obj, Mu $role)␤␤  in block <anon> at /tmp/e3Iivej8qn:1␤  in <anon> at /tmp/e3Iivej8qn:1␤»

[09:07] <tadzik> okay

[09:08] <tadzik> nom: class A { }; A does role { method a { say 'b' } }; A.new.?a; my $a = A.new but role { method b { say 'c' } }; $a.?b; $a.?a; A.new.?b

[09:08] <p6eval> nom 8c69ed: OUTPUT«Cannot change the type of a type object␤  in mixin at src/gen/Metamodel.pm:925␤  in sub infix:<does> at src/gen/CORE.setting:7748␤  in block <anon> at /tmp/i4McikgHWe:1␤  in <anon> at /tmp/i4McikgHWe:1␤»

[09:08] <tadzik> pff

[09:08] <tadzik> nevermind me then

[09:15] <sorear> nom: 0 does role { method Bool { True } }; say ?0

[09:15] <p6eval> nom 8c69ed: OUTPUT«Bool::True␤»

[09:16] <sorear> diakopter: in Perl 5 you can use bless to change the type of an existing object.  Perl 6 has a much more restricted form of the same in that you can only change to sub-types created by adding one or more roles

[09:17] <sorear> $foo but Bar is exactly (except possibly in cases involving overriding of clone) equivalent to given $foo.clone { $_ does Bar; $_ }

[09:17] <sorear> tadzik: yes, you CAN change 0.

[09:17] <tadzik> ah, I was just syntactically wrong

[09:17] <sorear> there's been some discussion in the past about forbidding does on objects that override WHICH

[09:18] <sorear> no, you tried to change the type of a type object.

[09:18] <sorear> which I guess 6model forbids

[09:18] <sorear> with good reason, perhaps.

[09:19] <tadzik> hmm

[09:38] <tadzik> std: Ph'nglui mglw'nafh Cobol R'lyeh wgah'nagl fhtagn.

[09:39] <p6eval> std be1f10e: OUTPUT«===SORRY!===␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/CkyOC_BE3_ line 1 (EOF):␤------> mglw'nafh Cobol R'lyeh wgah'nagl fhtagn.⏏<EOL>␤Undeclared routine:␤  'fhtagn' used at line 1␤Parse failed␤FAI…

[09:39] <tadzik> std: Ph'nglui mglw'nafh Cobol R'lyeh wgah'nagl fhtagn

[09:39] <p6eval> std be1f10e: OUTPUT«===SORRY!===␤Undeclared names:␤   'Cobol' used at line 1␤ 'Ph'nglui' used at line 1␤      'R'lyeh' used at line 1␤Undeclared routines:␤   'fhtagn' used at line 1␤        'mglw'nafh' used at line 1␤     'wgah'nagl' used at line 1␤Check failed␤FAILED 00:01

[09:39] <p6eval> ..119m␤»…

[09:43] *** autin left
[09:43] *** plutoid left
[09:46] *** risou is now known as risou_awy

[09:55] * sorear sleep

[10:02] *** sftp left
[10:03] *** sftp joined
[10:06] *** tokuhirom left
[10:13] <moritz> nom: role A[::T1, ::T2] { }; class B does A[Int, Int] { }

[10:13] <p6eval> nom 8c69ed:  ( no output )

[10:14] <moritz> nom: subset UInt of Int where * >= 0; role A[::T1, ::T2] { }; class B does A[Int, UInt] { }

[10:14] <p6eval> nom 8c69ed:  ( no output )

[10:15] <moritz> nom: subset UInt of Int where { 0 < $_ < 100 };  role A[::T1, ::T2] { }; class B does A[Int, UInt] { }

[10:15] <p6eval> nom 8c69ed:  ( no output )

[10:15] <moritz> hm

[10:15] <moritz> in the setting I get

[10:16] <moritz> Cannot use 'Int, UInt6' as an argument to a parametric role as its value is not known at compile time at

[10:16] <moritz> ah, because I misspelled UInt64

[10:32] <dalek> rakudo/Rational: 6853995 | moritz++ | src/core/Rat (2 files):

[10:32] <dalek> rakudo/Rational: make Rational a parametric role

[10:32] <dalek> rakudo/Rational: 

[10:32] <dalek> rakudo/Rational: hangs during setting compilation :(

[10:32] <dalek> rakudo/Rational: review: https://github.com/rakudo/rakudo/commit/6853995e40

[10:33] * diakopter stays awake waiting for jnthn

[10:47] <moritz> has anybody updated the regex tests from ** to %?

[10:47] * diakopter hasn't seen it

[10:52] *** tokuhirom joined
[10:52] <diakopter> I can't imagine there were very many using it for separator?

[10:54] <moritz> t/spec/S05-metasyntax/repeat.t does, at least

[10:57] * moritz tries to update

[11:01] *** spine joined
[11:02] <jnthn> o/

[11:02] <phenny> jnthn: 03:06Z <diakopter> tell jnthn I fixed/finished and applied your negate/backslash patch

[11:02] <phenny> jnthn: 03:30Z <diakopter> tell jnthn conj didn't handle zerowidth; I fixed that first

[11:03] <phenny> jnthn: 05:31Z <diakopter> tell jnthn I added backtracking to subrule to fix the bug you pointed out. Seems to work for the test cases I tried. No idea whether it regresses anything else. :/

[11:03] <phenny> jnthn: 05:39Z <diakopter> tell jnthn hrm; it doesn't like backtracking into nested captures.

[11:03] <diakopter> :)

[11:03] <jnthn> Wow, somebody has been busy ;)

[11:06] <jnthn> oh, curious...so I got the patch right and the compiler got it wrong... ;)

[11:06] <diakopter> yeah

[11:07] <jnthn> diakopter++

[11:08] <jnthn> and you improved my cclass patch some too :)

[11:08] <diakopter> my solution for \\ was kinda hacky; probably you have a better one

[11:13] <jnthn> Well, the backslash escape thingy makes JSON::Tiny able to use that approach rather than all the <before ...> stuff

[11:13] <jnthn> nom: say 3.008 / 4.073

[11:13] <p6eval> nom 8c69ed: OUTPUT«0.738521973974957␤»

[11:14] <jnthn> diakopter: I fear that your backtrack patch has hosed the spectest though :(

[11:15] <diakopter> eek

[11:15] <jnthn> S05-mass\recursive # fails a bunch

[11:15] <jnthn> S05-mass\rx # fails to compile

[11:15] <jnthn> eek, and then one hangs

[11:15] <diakopter> odd.

[11:15] <jnthn> S05-match\capturing-contexts hangs

[11:16] <diakopter> any of them that use nested rule calls and backtrack will fail, I think

[11:16] <dalek> roast: e2b7423 | moritz++ | S05-metasyntax/repeat.t:

[11:16] <dalek> roast: start to switch regex tests from ** to %

[11:16] <dalek> roast: review: https://github.com/perl6/roast/commit/e2b7423a5e

[11:16] <jnthn> Not had enough coffee to look into that yet really

[11:16] <jnthn> diakopter: Mind if I move that patch to a branch for now?

[11:16] <diakopter> nope

[11:17] <moritz> diakopter: fwiw the roast patch added a skip for a now-hanging regex test in repeat.t

[11:17] <jnthn> sigspace test hung too

[11:18] <dalek> roast: 1ec9f11 | moritz++ | / (6 files):

[11:18] <dalek> roast: rakudo unfudges

[11:18] <dalek> roast: review: https://github.com/perl6/roast/commit/1ec9f110ab

[11:18] <moritz> that one involved sigspace too, iirc

[11:19] <dalek> nqp: 93744c1 | jnthn++ | src/QAST/Compiler.nqp:

[11:19] <dalek> nqp: Revert "add backtracking support to subrule (captures included). Tested, barely. :)"

[11:19] <dalek> nqp: 

[11:19] <dalek> nqp: This reverts commit 035ecba0590b0dbd0a66836d5ff06db568436714.

[11:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/93744c1c29

[11:19] <jnthn> diakopter: It's in the branch "backtrack"

[11:20] <diakopter> not being able to backtrack into subrule & captures is kindof a huge deal :/ I'm very surprised Pm didn't do it yet

[11:21] <jnthn> I thought that's what he'd put the $!restart stuff in for.

[11:21] <jnthn> I wonder if he got half way and didn't get chance to finish it.

[11:22] <diakopter> I think $!restart is only used from cursor_next, and cursor_next wasn't called from anywhere 'til my patch

[11:22] <jnthn> Then, sounds like "yes"

[11:27] <jnthn> diakopter: Undoing the backtracking patch fixes all the regressions apart from S05-mass/rx.t...

[11:27] <jnthn> So guess something in the cclass patches has done that 

[11:28] * jnthn investigates

[11:28] <jnthn> oh wow, it dies with the least useful error ever.

[11:28] <moritz> try --ll-exception

[11:28] <moritz> well, only the BT will be better...

[11:29] <jnthn> moritz: yeah, doing so :)

[11:29] <jnthn> hmm...blows up in conjseq

[11:29] <diakopter> ack

[11:30] * diakopter wonders how that could be

[11:30] <jnthn> diakopter: It's not your change, by the looks of it.

[11:30] <jnthn> diakopter: My best guess is that the cclass code sometimes makes an empty conjseq

[11:30] *** MayDaniel joined
[11:31] <diakopter> ah

[11:31] <diakopter> I'll buy that for a euro

[11:32] <diakopter> or a gyro

[11:33] <diakopter> mmm gyros. dieting by portion control is painful.

[11:33] <diakopter> hm 3:33 a.m.

[11:36] <diakopter> nom: say 'foo' ~~ /f & \w & \D/

[11:36] <p6eval> nom 8c69ed: OUTPUT«=> <f>␤␤»

[11:37] <diakopter> nom: say 'foo' ~~ /(?:f & \w & \D)/

[11:37] <p6eval> nom 8c69ed: OUTPUT«===SORRY!===␤Quantifier quantifies nothing at line 1, near "f & \\w & \\"␤»

[11:37] <diakopter> std: say 'foo' ~~ /(?:f & \w & \D)/

[11:37] <p6eval> std be1f10e: OUTPUT«===SORRY!===␤Quantifier quantifies nothing at /tmp/vNaO1tx0KX line 1:␤------> say 'foo' ~~ /(?:⏏f & \w & \D)/␤Check failed␤FAILED 00:01 123m␤»

[11:37] <jnthn> diakopter: oh

[11:38] <jnthn> 'bbccdd' ~~ /<-[d..b]>/

[11:38] <diakopter> (?: needs a better error

[11:38] <jnthn> It's that one

[11:38] <jnthn> One that should die anyway.

[11:38] <jnthn> iirc

[11:38] <jnthn> std: 'bbccdd' ~~ /<-[d..b]>/

[11:38] <p6eval> std be1f10e: OUTPUT«ok 00:01 123m␤»

[11:38] <jnthn> hm

[11:38] <jnthn> Is that death or just "never match"?

[11:39] <jnthn> nom: say 'bbccdd' ~~ /<-[d..b]>/

[11:39] <p6eval> nom 8c69ed: OUTPUT«=> <b>␤␤»

[11:39] <diakopter> nom: say 'bbccdd' ~~ /<-[d..b]>+/

[11:39] <p6eval> nom 8c69ed: OUTPUT«=> <bbccdd>␤␤»

[11:39] <diakopter> niecza: say 'bbccdd' ~~ /<-[d..b]>+/

[11:39] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«#<match from(0) to(6) text(bbccdd) pos([].list) named({}.hash)>␤»

[11:40] <jnthn> hm :)

[11:40] <jnthn> here's what std says

[11:40] <jnthn> A reversed range is illegal.  In directly compiled code it's a compile-time

[11:40] <jnthn> error to say

[11:40] <jnthn> <[ z .. a ]> /  # Reversed range is not allowed

[11:41] <diakopter> heh

[11:41] <masak> aye.

[11:41] <jnthn> So we should die just...not so badly :)

[11:41] <jnthn> lolitsmasak!

[11:41] <jnthn> And the test should be dies_ok

[11:41] <diakopter> why do I always read lolitamasak

[11:42] <jnthn> ouch!

[11:42] <jnthn> "keys right next to each other" is usually an input problem :P

[11:45] *** danishman joined
[11:45] <diakopter> jnthn: how long does your nqpq take to rebuild after changing .nqp

[11:45] *** whiteknight joined
[11:45] <dalek> roast: 1d2cac2 | jnthn++ | S05-mass/rx.t:

[11:45] <dalek> roast: Fix test for reversed character ranges.

[11:45] <dalek> roast: review: https://github.com/perl6/roast/commit/1d2cac2fbb

[11:46] *** whiteknight is now known as Guest43790

[11:47] *** danishman left
[11:47] <jnthn> diakopter: Well, here it goes and builds the entire nqp bootstrap again...so at least 30s...

[11:48] <diakopter> hm, mine takes a full minute just to compile QRegex.nqp

[11:48] <jnthn> diakopter: Seems that the negated escaped hyphen tests somehow got broken too

[11:48] <diakopter> ah, that probably needs a special case too

[11:48] <jnthn> nom: say '---x--' ~~ /<-[\-]>/

[11:48] <p6eval> nom 8c69ed: OUTPUT«=> <x>␤␤»

[11:48] <jnthn> > '---x--' ~~ /<-[\-]>/

[11:48] <jnthn> => <->

[11:48] <jnthn> d'oh :)

[11:49] <diakopter> I bet I can fix that

[11:50] <jnthn> ok

[11:50] * jnthn is just adding in a decent error for the reversed char ranges

[11:53] <dalek> nqp: 1b061e8 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[11:53] <dalek> nqp: Catch illegally reversed character ranges and die with a good error.

[11:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1b061e8a7a

[11:55] <dalek> nqp: af28c73 | diakopter++ | src/QRegex/P6Regex/ (2 files):

[11:55] <dalek> nqp: allow escaped hyphens too

[11:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/af28c73584

[11:55] <dalek> nqp: 6ad13cc | diakopter++ | src/QRegex/P6Regex/Actions.nqp:

[11:55] <dalek> nqp: Merge branch 'master' of github.com:perl6/nqp

[11:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ad13cc0a2

[11:55] <diakopter> hm how do I do the rebase thing

[11:55] <jnthn> git pull --rebase

[11:56] <diakopter> that'll avoid the merge branch commit?

[11:56] <jnthn> yes

[11:56] <jnthn> diakopter: testing that patch :)

[11:57] <diakopter> thanks

[12:00] <diakopter> jnthn: I think \- accidentally worked previously

[12:00] <jnthn> oh :)

[12:00] <jnthn> I can believe that :)

[12:00] <diakopter> that is, the \ was interpreted as one of the possible (or not possible) chars

[12:00] <diakopter> as well as the \ or -

[12:00] <diakopter> er

[12:00] <jnthn> yes, seems that your patch helped \o/

[12:00] <diakopter> you know what I mean

[12:01] <jnthn> doing full spectest run then will bump NQP_REVISION.

[12:03] <jnthn> moritz: With the bump I'm about to do, the JSON::Tiny::Grammar's str rule can start using the commented out "<-["\\\t\n]>+" case

[12:03] <jnthn> (rather than all the <before ...>

[12:03] *** Logicus joined
[12:04] <jnthn> moritz: It's...rather faster ;)

[12:08] <diakopter> jnthn: in your sleep did you think about regex interpolation?

[12:09] <jnthn> diakopter: I realized that we already have it working in Rakudo and that it actually doesn't need any methods in the common role or engine changes. It just needs a couple of methods writing in NQPCursor. 

[12:09] <jnthn> diakopter: I can take a crack at that today.

[12:09] <diakopter> oh..

[12:09] <Logicus> I woke up to a dream about Perl 6 this morning lol

[12:09] <Logicus> that's what happens when you read about something last thing at night

[12:10] <diakopter> bed&

[12:10] <masak> diakopter: 'night. dream of interpolation in regexes :)

[12:11] <jnthn> diakopter: sleep well o/

[12:11] <dalek> rakudo/nom: b312db8 | jnthn++ | tools/build/NQP_REVISION:

[12:11] <dalek> rakudo/nom: Bump to an NQP with support for escape sequences in character classes, plus other fixes and improvements. diakopter++.

[12:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b312db8c04

[12:12] <masak> Logicus: two questions: was it a happy dream, and will it eventually lead to a spec change? :P

[12:12] *** Psyche^ joined
[12:13] <Logicus> two answers: yes it was very pleasant, and I don't know enough about Perl6 yet to say anything meaningful about specs

[12:14] <masak> :)

[12:14] <fsergot> nom: say "a::b::::d".split("::").perl

[12:14] <p6eval> nom 8c69ed: OUTPUT«("a", "b", "", "d").list␤»

[12:14] <Logicus> in the dream I was learning how to put some sort of Perl6 statement together, and I was using this interactive graphical learning console which told me I had the "moon" character in the wrong place

[12:14] <Logicus> whatever that means.

[12:14] <masak> sometimes the effect newcomers have is to set off a chain reaction that leads to a spec change.

[12:14] <masak> Logicus: oh no, the "moon" character in the wrong place! o.O

[12:14] <Logicus> as long as it's not a chain reaction which destroys the station that's all good

[12:15] <masak> "that's not a moon character!"

[12:15] <Logicus> It's too big to be a moon charachter

[12:15] <masak> .u ⺝

[12:15] <phenny> U+2E9D CJK RADICAL MOON (⺝)

[12:16] *** Patterner left
[12:16] *** Psyche^ is now known as Patterner

[12:17] <masak> .u 月

[12:17] <phenny> U+6708 CJK UNIFIED IDEOGRAPH-6708 (月)

[12:17] <masak> phenny: "月"?

[12:17] <phenny> masak: "Month" (zh-CN to en, translate.google.com)

[12:17] <masak> close enough :)

[12:17] <masak> phenny: "月亮"?

[12:17] <phenny> masak: "Moon" (zh-CN to en, translate.google.com)

[12:17] <masak> ah, of course.

[12:17] <jnthn> moritz: Please can I have a commit bit for JSON::Tiny?

[12:18] <moritz> jnthn: sure

[12:18] <moritz> hugme: add jnthn to json

[12:18] * hugme hugs jnthn. Welcome to json!

[12:18] <masak> rule in Mandarin: the word is usually two characters, even if the first character would've been enough in Classical Chinese.

[12:18] <Logicus> and the argonauts!

[12:18] <moritz> jnthn: feel free to commit the simplification to the regex rule

[12:19] <moritz> and I guess .trans can be replaced by .subst or so

[12:19] <moritz> or even s///

[12:19] <masak> Logicus: best way to learn how to avoid putting the "moon" character in the wrong place is to learn about the most basic rule of Perl 6 parsing: that of two-terms-in-a-row being disallowed.

[12:19] <moritz> now that that works

[12:20] <masak> Logicus: in some languages you can write 'obj.method 1, 2, 3' and it means 'obj.method(1, 2, 3)'. not so in Perl 6.

[12:20] <jnthn> moritz: Also the .item workaround in the actions is no longer needed :)

[12:20] <moritz> jnthn: \o/

[12:20] <masak> Logicus: because both '$obj.method' and '1' are terms, and they can't follow one another without an intervening operator.

[12:21] <moritz> jnthn: anything that simplifies JSON::Tiny is appreciated, because it also simplifies the book :-)

[12:21] <masak> Logicus: it's like the Perl 6 parser is always in a mode where it expects a term or expects an operator, and it flips back and forth between these two.

[12:24] <jnthn> moritz: It's not so much a simplification, but it turns out special-casing the string action method for the "single string with no escapes" case is a > 10% win.

[12:25] <Logicus> ok

[12:26] <jnthn> Even without that, from-json on projects.json now runs in half the time that it did yesterday

[12:27] <felher> When you define a function in common lisp and some default value for an argument X , you can specify another variable (x-supplied-p mostly) that is set to NIL if the argument X was user-supplied, T if X was set to its default value. Is something like that possible in Perl6?

[12:27] <jnthn> moritz: method value:sym<number>($/) { make eval $/.Str }

[12:27] <jnthn> moritz: Is +$/.Str not good enough these days?

[12:28] <arnsholt> felher: I'd probably just do that with two different multis, one with and one without the argument

[12:29] <masak> Logicus: so something like 'say $*OUT "OH HAI"' is also disallowed in Perl 6. both '$*OUT' and '"OH HAI"' are terms.

[12:29] *** rindolf joined
[12:29] <rindolf> Hi all

[12:29] <masak> hi rindolf 

[12:30] * rindolf was finally able to checkout Rakudo nom from github. There were networking problems.

[12:30] <rindolf> masak: hi, what's up?

[12:31] <masak> rindolf: a bit too many things at the moment :) it will get better soonish, though.

[12:31] <masak> rindolf: how're you?

[12:31] <felher> arnsholt: good point, but that may lead to quite a duplication of code sometimes :)

[12:32] <rindolf> masak: I'm fine. Yesterday I went over my RSS feeds.

[12:33] <rindolf> masak: and I worked on some CPAN modules.

[12:33] <Logicus> so everything is expressed as either a term or an operator?

[12:33] <rindolf> masak: I blogged about the upcoming Tel Aviv Perl Mongers meeting, and have some blog posts in the pipe.

[12:33] <Logicus> I'm guessing we select $*OUT first, then say to it ?

[12:34] <masak> literal: you could do it as $*OUT.say("OH HAI") or $*OUT.say: "OH HAI" or say $*OUT: "OH HAI"

[12:34] <rindolf> masak: one of them is about the rt.cpan.org anti-pattern of someone filing a bug on one of my modules, I'm asking for some input, I wait many weeks, they don't reply, and I close the bug due to inactivity.

[12:34] <rindolf> It happened to me many times.

[12:34] <felher> Hm, maybe somthing like: 'role IsDefault {}; ... ... ... sub foo($a = 3 but isDefault) { ... $a ~~ isDefault ...}'. Is that a legitimate way for using roles?

[12:35] <masak> Logicus: depending on what you mean by "everything", then yes, everything is either a term or an operator :)

[12:35] <masak> Logicus: of course, the picture gets more detailed the closer you look. for example, prefix operators are OK in term position. things like -42 or ?$value

[12:36] <Logicus> ok, everythings a fractal really...

[12:36] <masak> yes :)

[12:37] <masak> Logicus: also, things that look like terms (such as "say") are really subroutine listops (list operators), and they throw the parser back into expect-term mode. that's why "say 42" isn't a parse error.

[12:37] <masak> s/things/some things/

[12:38] <Logicus> so because it's expecting a term, 42 by itself without quotes is taken to be a term

[12:39] <Logicus> implicitly

[12:39] <masak> 42 is a term, period.

[12:39] <masak> but "say" isn't, and that's the point.

[12:39] <masak> so it's not two terms in a row.

[12:39] <Logicus> but it must be preceded by a listop

[12:40] <Logicus> ?

[12:40] <masak> right. the listop "resets" the parser mode.

[12:40] <masak> Logicus: also, sometimes the parser "cheats" and accepts TTIAR because it's part of a special form in the language. for example C< if 42 { say "OH HAI" } > would've been TTIAR (the 42 and the block are both terms), if it weren't for "if" which is a special form.

[12:41] <Logicus> TTIAR?

[12:41] <masak> two terms in a row :)

[12:41] <Logicus> Term Term...

[12:41] <masak> right.

[12:41] <Logicus> Two Terms In A... ok

[12:41] <masak> this concludes my light introduction to parsing in Perl 6.

[12:42] <masak> I like this stuff. I once wrote a Perl 6 parser in Perl 6.

[12:42] <Logicus> good stuff thanks :)

[12:42] <Logicus> I love parsers :)

[12:43] <Logicus> I've even been known to be sat playing around with parsing on xmas morning :P

[12:43] *** MayDaniel left
[12:47] *** tokuhirom left
[12:48] <masak> xmas morning is a surprisingly good time for hacking.

[12:53] <Logicus> perhaps today is a good day to hack!

[12:53] <jnthn> nom: my $x = 42; my $y = "$x"; say $y.WHAT

[12:53] <p6eval> nom b312db: OUTPUT«Int()␤»

[12:53] <jnthn> b: my $x = 42; my $y = "$x"; say $y.WHAT

[12:53] <p6eval> b 1b7dd1: OUTPUT«Str()␤»

[12:54] <Logicus> nom: my $x = 42; my $y = $x; say $y.WHAT

[12:54] <p6eval> nom b312db: OUTPUT«Int()␤»

[12:55] <Logicus> so the quotes didn't make any difference

[12:56] <jnthn> Logicus: Yeah, it's a bug...

[12:56] <Logicus> so in the correct final version the quotes are required?

[12:56] <jnthn> well, an ex-bug given I've patched it locally

[12:56] <masak> Logicus: no, both $x and "$x" are fine.

[12:57] <masak> Logicus: but "$x" is a Str, not an Int.

[12:57] <moritz>  ... at least it should be

[12:57] <Logicus> ah right of course, so putting the quotes should coerce it

[12:57] <masak> in Pure, Ideal Perl 6 :)

[12:57] <moritz> let's call that PIP6 :-)

[12:57] <masak> Logicus: yes, it's a circumfix coercion :)

[12:57] <jnthn> Oddly, found it when I was optimizing match object construction :)

[12:57] *** Trashlord left
[12:57] <masak> moritz: deal :)

[12:58] <Logicus> circumfix... hrm sounds dodgy... like circumfixtion or something

[12:58] <masak> jnthn: because no sane person would use that way to coerce Int->Str? :P

[12:58] <masak> Log

[12:58] <Logicus> im a long way from sane :)

[12:58] <masak> Logicus: well, that would be being nailed to a pair of matching parentheses or something :)

[12:58] <jnthn> masak: Nah, 'tis just a bug :)

[12:59] <Logicus> no I was thinking more along the lines of a certain popular jewish operation 

[12:59] *** Trashlord joined
[12:59] <masak> jnthn: right, just trying to motivate why it's been long unfound.

[12:59] <masak> Logicus: ah, that would be stripping of the outermost pair of matching parentheses, then :P

[12:59] <Logicus> ouch!

[13:01] <masak> could be wrose. the outermost parens don't actually do much.

[13:01] <masak> worse*

[13:01] <rindolf> Can anyone put a tarball of git://github.com/perl6/roast.git on a fast HTTP server, so I can download it quickly? github is SLOW.

[13:01] <Logicus> true, but I think they would be best left exactly where they are.

[13:01] <jnthn> nom: say 2.205 / 6.117

[13:01] <p6eval> nom b312db: OUTPUT«0.360470819028936␤»

[13:01] <masak> they're just for grouping :P

[13:03] <jnthn> tadzik: projects.json should now get parsed in about a third of the time :)

[13:04] *** Trashlord left
[13:04] *** Trashlord joined
[13:06] <moritz> rindolf: once? or regularly?

[13:06] <rindolf> moritz: once.

[13:08] *** Trashlord left
[13:09] *** Trashlord joined
[13:10] <rindolf> Though regularly would also be a good idea.

[13:10] <moritz> rindolf: moritz.faui2k3.org/tmp/roast.git.tar

[13:11] <dalek> rakudo/nom: 0786d96 | jnthn++ | src/Perl6/Actions.pm:

[13:11] <dalek> rakudo/nom: Fix an interpolation bug.

[13:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0786d963d3

[13:11] <dalek> rakudo/nom: 0ad267e | jnthn++ | src/core/Cursor.pm:

[13:11] <dalek> rakudo/nom: Optimize match object construction somewhat.

[13:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ad267eee5

[13:13] <jnthn> moritz: Interesting. from-json spends less than 20% of its time actually parsing. The other 80% is constructing the match objects and running the actions.

[13:13] <rindolf> moritz: thanks, but git checkout there didn't work.

[13:15] *** Trashlord left
[13:18] <arnsholt> rindolf: It looks like a tar archive of the repo

[13:19] <rindolf> arnsholt: no, it's a tar archive of the dot-git (".git") directory.

[13:19] *** Trashlord joined
[13:19] <rindolf> arnsholt: I don't know how to get the working copy.

[13:19] *** Trashlord is now known as Guest56160

[13:20] <arnsholt> Put it in an empty directory, rename to .git and then git checkout master should do the trick I think

[13:25] <rindolf> Got it working now.

[13:29] *** dpress joined
[13:29] *** Guest56160 left
[13:32] *** Guest56160 joined
[13:36] *** Lothar left
[13:36] *** yath left
[13:36] *** fhelmberger left
[13:36] *** Woodi left
[13:36] *** japhb left
[13:36] *** mls left
[13:36] *** zamolxes left
[13:36] *** risou_awy left
[13:36] *** jevin left
[13:36] *** revdiablo left
[13:37] *** ilogger2 joined
[13:37] *** ChanServ sets mode: +v ilogger2

[13:37] *** snarkyboojum_ joined
[13:38] *** stepnem joined
[13:41] *** jevin joined
[13:41] *** Guest56160 joined
[13:42] <rindolf> Hi all. I'm getting these make spectest failures - http://paste.debian.net/146373/

[13:50] *** Guest56160 left
[13:50] *** Guest56160 joined
[13:51] *** Mowah_ joined
[13:52] <jnthn> rindolf: The regex stuff is having a load of work done at the moment. Maybe you've just got a slightly inconsistent Rakudo and spectest version.

[13:54] <rindolf> jnthn: OK.

[13:56] *** Guest56160 left
[13:56] <dalek> features: be7c71f | jnthn++ | features.json:

[13:56] <dalek> features: Rakudo handles backslash escapes in char classes now.

[13:56] <dalek> features: review: https://github.com/perl6/features/commit/be7c71fe5e

[13:58] <dalek> features: f387311 | jnthn++ | features.json:

[13:58] <dalek> features: Rakudo nom also has some Buf support.

[13:58] <dalek> features: review: https://github.com/perl6/features/commit/f387311674

[13:58] *** dorlamm joined
[14:01] *** nightlord joined
[14:02] *** Guest56160 joined
[14:07] *** fsergot joined
[14:11] <spine> hi there. Is there anything simple in perl6 to Serialize my data structures to disk, like the Storable module from perl5?

[14:11] <spine> Or do I have to write my own serialization code with something like Simple::Redis?

[14:13] *** mj41 joined
[14:17] *** Guest56160 left
[14:17] *** kaare_ joined
[14:18] <masak> spine: there's .perl, which may or may not be enough for your needs.

[14:18] *** vivek joined
[14:18] *** vivek left
[14:19] <masak> rakudo: say [1, 2, { a => [5, 42] }].perl

[14:20] <p6eval> rakudo 0ad267: OUTPUT«[1, 2, {"a" => [5, 42]}]␤»

[14:20] *** Guest56160 joined
[14:21] <dalek> roast: 3f97578 | jnthn++ | S05-mass/rx.t:

[14:21] <dalek> roast: Unfudge more lookahead/lookbehind tests.

[14:21] <dalek> roast: review: https://github.com/perl6/roast/commit/3f97578a02

[14:22] <spine> masak: wow that looks great thanks a lot. So I can just store that to disk and later read it in with eval :)

[14:24] <arnsholt> nom: q{"}.perl.say

[14:24] <p6eval> nom 0ad267: OUTPUT«"\""␤»

[14:25] <dalek> roast: 7dbc061 | jnthn++ | S05-mass/rx.t:

[14:25] <dalek> roast: Another bunch of unfudges.

[14:25] <dalek> roast: review: https://github.com/perl6/roast/commit/7dbc061d29

[14:25] *** Guest56160 left
[14:33] <rindolf> jnthn: now I'm getting this after an update - http://paste.debian.net/146381/

[14:43] *** kfo joined
[14:46] *** Guest56160 joined
[14:46] <Logicus> is eval going to be as slow in p6 as in p5?

[14:47] <Woodi> Logicus: probably eval will be fast becouse it's noop :)

[14:48] <masak> eh?

[14:48] <Woodi> non-existen i mean :)

[14:48] <masak> nom: eval "say 'OH HAI'"

[14:48] <p6eval> nom 0ad267: OUTPUT«OH HAI␤»

[14:48] <jnthn> rindolf: hM, INTERESTING.

[14:48] <jnthn> oops :)

[14:48] <Woodi> ok, maybe i am wrong

[14:48] <masak> maybe... :)

[14:48] <Woodi> i thinked grammars replace it

[14:50] <jnthn> rindolf: Please could you run t/spec/S03-operators/range.rakudo and give me the output?

[14:50] *** Moukeddar joined
[14:50] *** benabik joined
[14:53] <rindolf> jnthn: yes.

[14:54] <rindolf> jnthn: http://paste.debian.net/146383/

[14:55] <dalek> roast: d957740 | jnthn++ | S02-literals/ (2 files):

[14:55] <dalek> roast: Untodo some tests we now pass; spotted by rindolf++.

[14:55] <dalek> roast: review: https://github.com/perl6/roast/commit/d957740d43

[14:56] <rindolf> Heh, thanks for the ++

[14:56] <rindolf> :-)

[14:56] <rindolf> jnthn: :-)

[14:56] <jnthn> rindolf: I can reproduce that range fail here too

[14:56] <rindolf> jnthn: OK. Good.

[14:58] <dalek> nqp: a6a4c80 | jnthn++ | src/QRegex/P6Regex/Grammar.nqp:

[14:58] <dalek> nqp: Tweak an error message to have a missing space.

[14:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a6a4c80b6d

[15:02] *** Guest56160 left
[15:04] *** Guest56160 joined
[15:07] <dalek> rakudo/nom: ac24a6d | jnthn++ | src/core/Cursor.pm:

[15:07] <dalek> rakudo/nom: Eliminate a pir:: and a method call.

[15:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac24a6d3d5

[15:07] <dalek> rakudo/nom: f3467e0 | jnthn++ | tools/build/NQP_REVISION:

[15:07] <dalek> rakudo/nom: Get corrected error.

[15:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f3467e0b86

[15:07] <dalek> roast: 6242705 | jnthn++ | S05-metasyntax/charset.t:

[15:07] <dalek> roast: Correct and unfudge a test for old char range syntax.

[15:07] <dalek> roast: review: https://github.com/perl6/roast/commit/6242705500

[15:08] *** kaare_ left
[15:10] *** kaare joined
[15:11] *** kaare is now known as Guest40733

[15:13] *** Guest40733 left
[15:14] *** nightlord left
[15:15] *** Guest56160 left
[15:18] <tadzik> 'afternoon

[15:27] *** dorlamm left
[15:29] *** Moukeddar left
[15:34] *** Guest56160 joined
[15:38] *** Guest56160 left
[15:46] *** MayDaniel joined
[15:48] *** lloh joined
[15:48] *** lloh left
[15:48] *** jdhore joined
[15:52] <jnthn> o/ tadzik 

[15:55] *** kaare joined
[15:56] *** kaare is now known as Guest2721

[16:01] <tadzik> t/spec/S06-other/main-usage.rakudo ........................ Failed 6/17 subtests

[16:04] <jnthn> tadzik: That test file has failed for me for a while; I figured it was win32-specific stuff

[16:06] <tadzik> well, I don't think it is, since it fails for me :)

[16:07] <jnthn> Does

[16:07] <jnthn> perl6 -e "sub MAIN($bar) { }" --help

[16:07] <jnthn> give any output for you?

[16:08] <tadzik> Usage:

[16:08] <tadzik>   -e '...'

[16:08] <jnthn> oddness

[16:08] <jnthn> here it gives nothing at all

[16:08] <jnthn> oh, wait, what...

[16:09] <jnthn> What about just perl6 -e "sub MAIN($bar) { }"

[16:09] <tadzik> nothing

[16:09] <jnthn> Great, we're getting opposite results...

[16:09] <tadzik> :>

[16:10] <tadzik> how about perl6 -e "sub MAIN($bar) { say $bar }"?

[16:10] <tadzik> it prints a blank line here

[16:10] <jnthn> prints

[16:10] <jnthn> Usage: -e '...' <bar>

[16:10] <jnthn> er, line break after Usage:

[16:10] <tadzik> yeah

[16:11] <jnthn> so, not a blank line

[16:11] <jnthn> hmm, wtf...

[16:11] <wolverian> I hope you're not running that on a shell that interpolates $ variables inside double quotes

[16:11] * wolverian captain obvious

[16:11] <jnthn> er

[16:12] <jnthn> well, mine doesn't

[16:12] <jnthn> tadzik? :)

[16:12] <tadzik> haha

[16:12] <tadzik> should've used ''

[16:12] <tadzik> now perl6 -e 'sub MAIN($bar) { }' --help doesn't print anything

[16:12] <jnthn> ok

[16:13] <jnthn> that's at least one of the fails then

[16:15] <jnthn> nom: say "--help" ~~ /^ ( '--' | '-' | ':' ) ('/'?) (<-[0..9\.]> .*) $/

[16:15] <p6eval> nom f3467e: OUTPUT«#<failed match>␤»

[16:15] <jnthn> nom: say "help" ~~ /^ (<-[0..9\.]> .*) $/

[16:15] <p6eval> nom f3467e: OUTPUT«#<failed match>␤»

[16:15] <jnthn> nom: say "help" ~~ /^ (<-[0..9]> .*) $/

[16:15] <p6eval> nom f3467e: OUTPUT«=> <help>␤ 0 => <help>␤␤»

[16:21] *** MayDaniel left
[16:34] <cognominal> jnthn, how to inherit form HLL::Grammar in Perl6?

[16:35] <cognominal> nom: class A is HLL::Grammar {    };    

[16:35] <p6eval> nom f3467e: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Routine $r, Any $info, Any $inlinable)␤:(Param…

[16:35] <cognominal> nom: grammar A is HLL::Grammar {    };    

[16:35] <p6eval> nom f3467e: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Routine $r, Any $info, Any $inlinable)␤:(Param…

[16:36] <cognominal> I meant the second

[16:37] <jnthn> cognominal: Not sure...you'd have to have some kind of "use" statement, but we don't have a :from<nqp> thingy in place yet.

[16:37] <cognominal> ok

[16:39] <jnthn> tadzik: Think I've got a fix for the main-usage.t issue

[16:39] <cognominal> this means EXPR and the like are unvailable from perl6

[16:42] <cognominal> jnthn, meaning somehow encasulating a nqp object to use it from Perl 6?

[16:45] <jnthn> cognominal: I think it's - at least primarily - a module loading issue.

[16:45] <masak> nom: class A is B {}

[16:45] <p6eval> nom f3467e: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Routine $r, Any $info, Any $inlinable)␤:(Param…

[16:45] <masak> hm, that error message could probably be more awesome...

[16:46] <jnthn> masak: Not sure about the best way to do it without making other things worse...

[16:47] <jnthn> masak: I guess some kinda catch-all-ish multi candidate may help

[16:51] <cognominal> the error displays neither the place of the error nor the signature of the sub. That makes difficult to find the problem

[16:52] <cognominal> by place, I mean file and line number.

[16:52] <jnthn> signature of...what sub?

[16:53] <dalek> nqp: 98ef1a1 | jnthn++ | src/QAST/Compiler.nqp:

[16:53] <dalek> nqp: Compilation of literal nodes ignored negate flag; fix this.

[16:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/98ef1a1525

[16:53] <dalek> nqp: cc3918c | jnthn++ | src/QRegex/P6Regex/ (2 files):

[16:53] <dalek> nqp: Turns out that fixing the negation of literals renders the backlit stuff unrequired; remove it.

[16:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cc3918cb46

[16:53] <jnthn> tadzik: That should fix your main-usage issue.

[16:53] <cognominal> jnthn, here,  the  trait_mod:<is> signature should involves grammar types here?

[16:53] <jnthn> No

[16:54] <tadzik> nice

[16:54] <jnthn> It's the (Mu:U, Mu:U) case that would catch it were the type defined

[16:54] <jnthn> tadzik: And I think I figured out some aspect on the windows problem too

[16:54] <jnthn> tadzik: It's the :args thing in tests

[16:56] <cognominal> sorry, I should have said capture.   I mix signature and capture, just the way I do for arguments and parameters :(

[16:56] <jnthn> cognominal: ah, I see what you mean...

[16:57] <jnthn> cognominal: I'll try adding a candidate to catch this case

[16:57] <jnthn> tadzik: heh. The reason it doesn't work is, of all things, missing :i support 

[17:00] <dalek> rakudo/nom: ca161f7 | jnthn++ | tools/build/NQP_REVISION:

[17:00] <dalek> rakudo/nom: Bump to NQP version with fix for \. in the char class.

[17:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca161f7fb5

[17:10] *** sayu joined
[17:19] *** sayu left
[17:19] *** sayu_ joined
[17:24] *** Guest2721 left
[17:27] *** Moukeddar joined
[17:32] *** orafu joined
[17:32] *** pat_js joined
[17:33] <pat_js> hi

[17:33] <pat_js> What is the recursion max in Rakudo?

[17:38] <jnthn> pat_js: Think it's set to around a thousand frames or so

[17:39] <pat_js> jnthn: hmmm, then i might need another algorithm, thanks

[17:39] <felher> nom: sub correct($x) { return True; }; sub func($x where correct) { say $x; }

[17:39] <p6eval> nom f3467e: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'correct' will never work with no arguments (line 1)␤    Expected: :(Any $x)␤»

[17:40] <felher> Shouldn't that be possible in theory?

[17:40] <felher> (btw: jnthn++ for merging the protoregex branch :) )

[17:40] <rindolf> pat_js: you can use a dedicated stack for recursion.

[17:40] <jnthn> felher: I think Rakudo is right here

[17:40] <wolverian> 'where &correct'?

[17:41] <jnthn> You need...what wolverian said :D

[17:41] <felher> wolverian: jnthn: ah, i see, thnx :)

[17:41] <jnthn> wolverian: The RHS of the where acts kinda like a smartmatch.

[17:41] <jnthn> gah

[17:41] <jnthn> that was aimed at felher :)

[17:43] <felher> jnthn: ah, and you can't match against functions because the function would be evaluated first? So you need the '&'?

[17:43] <jnthn> felher: correct

[17:43] <jnthn> You'd be evaluating against the return value of the function there.

[17:43] <wolverian> felher: otherwise you couldn't match against the return value of a function...

[17:43] <jnthn> felher: BTW, Rakudo caught that one at compile time for you ;-)

[17:44] *** skangas joined
[17:44] <felher> jnthn: yeah, i know. I watched the optimizer quite a bit, lately. Great work, btw :)

[17:44] <felher> wolverian: jnthn: thnx for explaining :)

[17:44] <wolverian> you're welcome

[17:45] <moritz> jnthn++ # JSON::Tiny fixes

[17:46] <jnthn> moritz: If you can find a way to improve string handling there's at least another 25% to be shaved off 

[17:47] <jnthn> moritz: For example, it's a bit ugly, but checking for the "exactly one match and it was <str>" case and just grabbing and using its ast rather than doing the join stuff gets you about that.

[17:48] <jnthn> moritz: But I didn't want to ugly up your nice code ;)

[17:50] <moritz> you mean for strings which don't contain any backslash escapes?

[17:51] <jnthn> moritz: correct

[17:51] <jnthn> moritz: It's the join and map that noms up time

[17:51] <moritz> jnthn: feel free to commit it anyway

[17:51] <moritz> for the book I'll nicify the code in a branch

[17:52] <jnthn> moritz: ah, that works too

[17:52] <jnthn> :)

[17:52] *** icwiener joined
[17:52] <moritz> but for real world usage, 25% speed win is enough to warrant a single 'if' :-)

[17:58] <jnthn> nom: say 1.574 / 2.205

[17:58] <p6eval> nom ca161f: OUTPUT«0.713832199546485␤»

[17:58] <jnthn> More like 30%

[17:58] <jnthn> :)

[17:58] <jnthn> nom: say 1.574 / 6.117

[17:58] <p6eval> nom ca161f: OUTPUT«0.257315677619748␤»

[17:58] <jnthn> Runs in a quarter of the time it did when I first got it to work at all :)

[17:59] <masak> \o/

[18:00] *** sayu joined
[18:01] <jnthn> moritz: pushed :)

[18:01] *** sftp_ joined
[18:02] <moritz> \o/ indeed

[18:02] * jnthn wonders how "fast" b ran it :)

[18:03] *** sayu_ left
[18:05] <[Coke]> would be nice to know for something like a blog post when starnom comes out

[18:06] *** Guest2721 joined
[18:06] <jnthn> [Coke]: I'm planning to make some comparrisons for that :)

[18:07] <moritz> jnthn: for the JSON emitter, I was thinking of something like

[18:07] <[Coke]> jnthn: ah, right, not like we can't just rebuild b then. ;)

[18:08] <moritz> proto sub to-json(..) is export {*}

[18:08] <jnthn> moritz: Yes, that will work

[18:08] <moritz> good

[18:08] <jnthn> moritz: I did that locally once

[18:08] <jnthn> moritz: Then it blocked on trans

[18:08] <moritz> great

[18:08] <jnthn> hmm...seems I tossed the patch. d'oph.

[18:08] <moritz> ah well, probably not hard to redo

[18:09] <jnthn> no, it took me about a minute... :)

[18:12] <moritz> jnthn: feel free to add yourself to the CREDITS in json/README

[18:13] <moritz> tadzik++ should do that too

[18:13] <dalek> rakudo/nom: 4cff8e5 | jnthn++ | NOMMAP.markdown:

[18:13] <dalek> rakudo/nom: Remove done stuff, de-dupe etc. nommap.

[18:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4cff8e5b97

[18:13] <tadzik> I don't think I did commit to json

[18:14] <moritz> tadzik: you had the "speed up string parsing by a factor of 100" commit (or similar)

[18:15] <moritz> https://github.com/moritz/json/commit/bca5efa76e300bb9c2d07ab287ee1224a5e9e4a2

[18:18] <tadzik> oh, that was jnthn's idea :)

[18:18] <tadzik> at mberends++' place

[18:18] <moritz> ... and implemented by tadzik++

[18:24] *** molaf joined
[18:25] <colomon> tadzik: how's panda coming?  ;)

[18:30] <tadzik> colomon: it works :)

[18:30] <colomon> \o/

[18:30] <tadzik> moritz: no, I just retyped jnthn++'s code :)

[18:30] <colomon> tadzik: have you pushed your fixes?

[18:30] <tadzik> colomon: si

[18:30] <colomon> \o/

[18:30] <tadzik> colomon: look at https://gist.github.com/1379175

[18:31] <tadzik> it already gave results :)

[18:31] <tadzik> but now, I need to hack on minix abit

[18:32] <colomon> tadzik: okay, I'll take a look at getting it working with niecza.  OH!  you've got useful results for nom already!  Callooh! Callay!

[18:32] <benabik> Minix?

[18:33] <tadzik> aye

[18:33] <tadzik> colomon: I updated the wiki too

[18:33] <colomon> Woah, we hacked on minix in class in 1991...

[18:34] <tadzik> I hack on it on my classes now :)

[18:37] *** benabik left
[18:39] <colomon> tadzik: wiki?

[18:40] <colomon> wait, we've got a Rational branch now?

[18:41] <colomon> apparently everything has happened while I've been busy this weekend, and I'm going to keep on being too busy to track it in all likelihood.  :(

[18:42] <tadzik> colomon: perl6/ecosystem wiki

[18:43] *** edkolev joined
[18:43] <colomon> tadzik++ 

[18:44] <tadzik> that's not new :)

[18:45] *** vmspb joined
[18:45] <colomon> I didn't know about it, that's good enough for me.

[18:46] <tadzik> Like

[18:46] *** Chillance joined
[18:48] *** molaf left
[19:10] <jnthn> I blogged: http://6guts.wordpress.com/2011/11/20/rakudo-this-weeks-release-and-the-next-rakudo-star/

[19:12] *** snarkyboojum_ is now known as snarkyboojum

[19:15] <masak> jnth++

[19:15] <masak> gah, jnth-- jnthn++

[19:19] <jnthn> ;)

[19:19] *** MayDaniel joined
[19:26] *** icwiener left
[19:28] *** MayDaniel left
[19:30] <felher> jnthn++ for blogpost. Great to see so many things improving :)

[19:36] *** icwiener joined
[19:46] <colomon> tadzik: install of panda fails on my 64-bit Linux machine.

[19:48] <colomon> t/04-roundtrip.t .. No applicable candidates found to dispatch to for ''. Available candidates are:

[19:48] <colomon>   in block <anon> at t/04-roundtrip.t:37

[19:49] <colomon> That's in JSON::Tiny

[19:51] <djanatyn> hmm, I'm getting a weird error which I think might be because something isn't implemented yet, or because of a bug

[19:51] <djanatyn> or, because my code sucks :)

[19:52] <colomon> Those three cases do cover a lot of the possibilities.  :)

[19:53] <djanatyn> https://gist.github.com/1380783

[19:54] <djanatyn> I'm not sure how self-explanatory my code is, but I can explain what I'm doing if you like

[19:54] <djanatyn> ...hmm, wait a sec'

[19:55] <djanatyn> oh, I didn

[19:55] <djanatyn> *I didn't initialize anonymous arrays to push to -_-

[19:55] <djanatyn> never mind, fixing

[19:56] <djanatyn> thanks for your help ;)

[19:58] <tadzik> colomon: I know that :/

[19:58] <tadzik> bootstrap won't work

[19:58] <tadzik> due to JSON and Test::Mock tests failing

[19:58] <tadzik> you can either install it via ufo, or... tactically remove JSON and Test::Mock tests before they get run

[20:02] *** MayDaniel joined
[20:02] *** MayDaniel left
[20:04] <snarkyboojum> with ./bootsrap.sh --no-tests or --force? :D

[20:06] <tadzik> (:

[20:16] <colomon> djanatyn: sorry to disappear there, surprise bout of 3-year-old watching on my part.

[20:17] *** imarcusthis joined
[20:19] <sorear> good * #perl6

[20:19] <colomon> o/

[20:20] *** edkolev left
[20:30] *** benabik joined
[20:33] *** ksi joined
[20:34] *** sayu left
[20:35] *** MayDaniel joined
[20:36] <djanatyn> does perl5 have auto-vivification?

[20:38] <tadzik> yes, I think

[20:38] <moritz> yes

[20:38] *** MayDaniel left
[20:38] <moritz> though with slightly different semantics than in p6

[20:39] <moritz> in particular, read accessess never autoviv in p6

[20:39] <moritz> but in p5, they do (except in the very last level)

[20:40] <moritz> jnthn++ # blog

[20:40] <sorear> in p6, autoviv is done at the point of assignment, and it chases backward to autoviv all the necessary containers

[20:40] <benabik> last level?

[20:40] <sorear> in p5, autoviv is done at the point of the indexing operation

[20:41] <sorear> $foo->{'bar'}; # this will do the equivalent of $foo //= {} first in p5

[20:42] <sorear> (it is my opinion that the p5 method works better in practice)

[20:45] *** PacoLinux_ joined
[20:47] <djanatyn> is there a way I can look up all the methods for hashes?

[20:47] <djanatyn> actually, I'll just ask:

[20:48] <sorear> rakudo: say Hash.^methods(:all)».name

[20:48] <djanatyn> I want to figure out how many keys exist for a hash. I know that I can do %foo.keys.elems - is there a cleaner or more readable way?

[20:48] <p6eval> rakudo 4cff8e: OUTPUT«too many named arguments: 1 passed, 0 used␤  in methods at src/gen/Metamodel.pm:370␤  in method dispatch:<.^> at src/gen/CORE.setting:726␤  in block <anon> at /tmp/AVKyseFeOg:1␤  in <anon> at /tmp/AVKyseFeOg:1␤»

[20:48] <sorear> rakudo: say Hash.^methods».name

[20:48] <p6eval> rakudo 4cff8e: OUTPUT«new at_key STORE_AT_KEY STORE delete push _push_construct perl elems exists iterator list keys kv values pairs invert at_key STORE_AT_KEY Capture FLATTENABLE_LIST FLATTENABLE_HASH fmt Bool ACCEPTS perl elems infinite item fmt Int Num chrs Numeric Str abs conjugate …

[20:49] <djanatyn> ooh, %foo.elems, thanks

[20:49] <flussence> rakudo: my %a = (a=>1, b=>2, c=>3); say +%a

[20:49] <p6eval> rakudo 4cff8e: OUTPUT«3␤»

[20:49] * djanatyn is refactoring and using some cool perl6 tricks

[20:51] *** tokuhirom joined
[20:52] <djanatyn> what order does %hash.keys put the keys in the list? order added?

[20:54] <sorear> random order

[20:54] <benabik> hash order, I think.

[20:54] <djanatyn> :D

[20:55] <sorear> in niecza %hash.keys returns in order-added for all hashes up to 7 elements

[20:55] <djanatyn> anyway, I have a surprise for you guys that's almost finished

[20:55] <benabik> sorear: 7?

[20:55] <djanatyn> which isn't really that interesting, but kind of cool, I suppose

[20:55] <sorear> above 7 elements it switches to hash order

[20:57] <sorear> benabik: actually 11 looking at the code again

[20:57] <benabik> sorear: Faster to iterate over a small loop than to bother allocating a hash?

[20:57] *** cooper joined
[20:57] <sorear> benabik: exactly

[20:59] <sorear> niecza: say 'a' .. 'z'

[20:59] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«"a".."z"␤»

[21:00] <sorear> niecza: say ('a' .. 'z').pick

[21:00] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«c␤»

[21:00] <sorear> niecza: say ('a' .. 'z').pick(5)

[21:00] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«s f g k p␤»

[21:01] <sorear> niecza: my %hash; for ('a' .. 'z').pick(11) { %hash{$_}++; say $_; }; say %hash.keys

[21:01] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«t␤k␤j␤p␤l␤e␤r␤u␤v␤h␤i␤t k j p l e r u v h i␤»

[21:01] <sorear> niecza: my %hash; for ('a' .. 'z').pick(12) { %hash{$_}++; say $_; }; say %hash.keys

[21:01] <p6eval> niecza v11-24-gcdd4e66: OUTPUT«b␤o␤w␤e␤z␤q␤m␤s␤a␤h␤y␤i␤i y h a s m q z e w o b␤»

[21:01] <sorear> \o/

[21:02] <benabik> sorear: Is that something you did, or the way the CLR HashMap works?

[21:02] * benabik is just curious.

[21:02] <sorear> benabik: something I did

[21:02] *** HarryS joined
[21:02] <sorear> it's kind of sad that someone with my qualifications can write a significantly faster HashMap than the builtin one

[21:04] <Moukeddar> it's funny

[21:04] *** pat_js left
[21:07] <benabik> You have excellent qualifications.  You're the author of one of the leading implementations of Perl 6.  :-)

[21:09] <Moukeddar> guys, how do you benchmark you collections?

[21:12] <sorear> I have a script in tools/ that runs a sub a million times, averages the time, and makes a crude attempt to compensate for systematic error

[21:13] <diakopter> benabik: is there a VTABLE_push_PMC or how is it spelled

[21:13] <jnthn> diakopter: VTABLE_push_pmc

[21:13] <diakopter> jnthn: or you

[21:13] <diakopter> oh

[21:13] <sorear> I was using a benchmark like sub () { my %hash; %hash<a> = 1; %hash<b> = 2; %hash<c> = 3 }

[21:14] <sorear> then I confirmed that it did, in fact, make a measurable speedup on niecza's self-compilatin time

[21:15] <sorear> this was a few versions ago when niecza's STD was still using @*MEMOS[$/.pos]<L> to implement 'lineof', which requires 200,000 one-element hashes when compiling a big file like CORE.setting or STD.pm6

[21:16] <jnthn> sorear: Do you still have @*MEMOS at all?

[21:16] <sorear> I've since changed it to something more like @*LINEMEMOS[$/.pos], reducing the need for performant one-element hashes

[21:16] <sorear> jnthn: yes

[21:16] <moritz> nom: say so '"' ~~ /<[\c32 .. \c126]>/

[21:16] <p6eval> nom 4cff8e: OUTPUT«Bool::False␤»

[21:16] <moritz> nom: say so '"' ~~ /<-[\c32 .. \c126]>/

[21:16] <p6eval> nom 4cff8e: OUTPUT«Bool::True␤»

[21:16] <moritz> nom: say ord '"'

[21:16] <p6eval> nom 4cff8e: OUTPUT«34␤»

[21:16] <moritz> nom: say ord '\'

[21:17] <p6eval> nom 4cff8e: OUTPUT«===SORRY!===␤Confused at line 1, near "say ord '\\"␤»

[21:17] <moritz> nom: say ord '\\'

[21:17] <p6eval> nom 4cff8e: OUTPUT«92␤»

[21:17] <jnthn> moritz: Ah...the case of backslash sequences and range may not be implemented yet...

[21:18] <jnthn> diakopter: ^^ if you're bored ;-)

[21:19] <moritz> nom: say so '"' ~~ /\ ..~/

[21:19] <p6eval> nom 4cff8e: OUTPUT«===SORRY!===␤Confused at line 1, near "say so '\"'"␤»

[21:19] <Moukeddar> interesting

[21:19] <moritz> nom: say so '"' ~~ /<-[\ ..~]>/

[21:19] <p6eval> nom 4cff8e: OUTPUT«Bool::True␤»

[21:19] <Moukeddar> thanks for the tips ;)

[21:20] <moritz> erm

[21:20] <moritz> that's not correct either, is it?

[21:20] <jnthn> er, how does that one parse... P)

[21:20] <jnthn> :)

[21:21] <jnthn> moritz: Looking at it - the .. handling certainly only supports having an actual character each side.

[21:21] <moritz> char class from space (codepoint 32) to ~ (codepoint 126)

[21:21] <moritz> nom: say chr 35

[21:21] <p6eval> nom 4cff8e: OUTPUT«#␤»

[21:21] <jnthn> moritz: yes, that's how it should be parsed :)

[21:21] <jnthn> moritz: I'm saying I don't think it's happening that way.

[21:22] <sorear> jnthn: @*MEMOS is useful!  but having a memo on _every_ character position is just wrong.

[21:22] <djanatyn> okay, let's see if this works

[21:24] * moritz commits a patch that makes JSON::Tiny not use .trans... but it comes out wrong anyway :(

[21:24] <jnthn> sorear: Yeah, Pm didn't do an @*MEMOS, so was curious if Niecza kept it :)

[21:27] <djanatyn> here we go! :D

[21:27] <djanatyn> http://djanatyn.github.com/2011/11/19/parsing-birthdays.html

[21:28] <djanatyn> a blog post about how I used perl6

[21:28] *** fsergot left
[21:30] <djanatyn> grr, gotta fix a few things

[21:32] <djanatyn> there, now the example of the ICS file has it's own seperate lines

[21:32] <jnthn> djanatyn++

[21:32] <djanatyn> jnthn: ?

[21:32] <djanatyn> why are you incrementing me? o_o

[21:33] <diakopter> karma djanatyn 

[21:33] <aloha> djanatyn has karma of 4.

[21:33] <djanatyn> :D

[21:33] <djanatyn> hooray

[21:33] * djanatyn takes a shower, brb

[21:33] <jnthn> djanatyn: It's a #perl6 way of people showing they like something somebody else did :)

[21:34] <djanatyn> well, thank you :)

[21:34] <djanatyn> #perl6++

[21:35] <diakopter> karma perl6

[21:35] <aloha> perl6 has karma of 9.

[21:35] <jnthn> karma diakopter 

[21:35] <aloha> diakopter has karma of 486.

[21:35] <jnthn> :)

[21:35] <diakopter> karma jnthn

[21:35] <aloha> jnthn has karma of 2187.

[21:36] <diakopter> karma moritz 

[21:36] <aloha> moritz has karma of 2732.

[21:36] <diakopter> karma TimToady

[21:36] <aloha> TimToady has karma of 250.

[21:36] <diakopter> karma lwall

[21:36] <aloha> lwall has karma of 0.

[21:36] <diakopter> oh

[21:37] *** Guest2721 left
[21:42] <tadzik> karma tadzik

[21:42] <aloha> tadzik has karma of 832.

[21:42] <tadzik> wow, it was 666 not that long ago :)

[21:43] <jnthn> Clearly you've been hacking like a beast since then :)

[21:43] * masak .oO( hacking like baest... )

[21:44] <vmspb> Hi

[21:44] <vmspb> This is correct for Ideal Perl 6?

[21:44] <vmspb> rakudo: say "\x4_0", "\c6_4", "\o1_0_0"

[21:44] <p6eval> rakudo 4cff8e: OUTPUT«@@@␤»

[21:45] <vmspb> I think the current STD grammar finds "\c6_4" as "\c6" ~ "_4", in contrast to "\x4_0" and "\o1_0_0"

[21:45] <vmspb> May need to be replaced s/\d+/<decint>/ in STD.pm6#L415 

[21:45] *** mj41 left
[21:51] <djanatyn> is there anything new on perl6 + google code in yet?

[21:52] <djanatyn> ah, it opens tommorow :D

[22:07] *** fsergot joined
[22:14] *** icwiener left
[22:16] *** MayDaniel joined
[22:17] *** mj41 joined
[22:18] *** amkrankruleuen joined
[22:19] *** PacoLinux_ is now known as PacoLinux

[22:19] *** Moukeddar left
[22:23] *** Trashlord joined
[22:27] <sorear> o/ MASAK

[22:27] *** PacoLinux left
[22:28] *** cooper left
[22:31] <sorear> or masak, if your highligher is case sensistive.

[22:35] <colomon> :)

[22:41] *** MayDaniel left
[22:46] *** icwiener joined
[22:46] <masak> 'night, #Perl6

[22:46] *** daniel-s joined
[22:52] <sorear> :/

[22:52] <sorear> I wanted to finish the discussion on promoting niecza we started the other day

[22:54] *** mj41 left
[22:54] *** icwiener_ joined
[22:54] *** icwiener left
[22:54] *** PacoLinux joined
[23:01] * diakopter ditches gedit for scite

[23:02] *** icwiener_ left
[23:08] *** Moukeddar joined
[23:12] *** cooper joined
[23:12] *** vmspb left
[23:17] *** PacoLinux left
[23:18] <jnthn> 'night, #perl6

[23:29] *** Moukeddar left
[23:53] *** woosley joined
[23:53] *** woosley left
