[00:03] <[Coke]> how does one install SVG::Plot for rakudo?

[00:05] * [Coke] finds panda.

[00:06] <[Coke]> panda borked on current nom?

[00:15] *** ch3ck3r left
[00:17] <flussence> missing some regex stuff, iirc. Lots of stuff seems to currently...

[00:23] <[Coke]> rakudo: class A { multi method a() { }}; use MONKEY_TYPING; augment class A { multi method a() { } }

[00:24] <p6eval> rakudo 545638:  ( no output )

[00:25] *** colomon joined
[00:25] <[Coke]> rakudo: for 1,2 X <a b> { say "$^x $^y" }

[00:25] <p6eval> rakudo 545638: OUTPUT«1 a␤1 b␤2 a␤2 b␤»

[00:25] <[Coke]> for 1,2 X (<a b> X 'x') { say "$^x $^y" }

[00:26] <[Coke]> rakudo: for 1,2 X (<a b> X 'x') { say "$^x $^y" }

[00:26] <p6eval> rakudo 545638: OUTPUT«1 a␤1 x␤1 b␤1 x␤2 a␤2 x␤2 b␤2 x␤»

[00:28] *** colomon_ joined
[00:29] <[Coke]> rakudo: 555 ~~!~~ 666

[00:29] <p6eval> rakudo 545638:  ( no output )

[00:30] <[Coke]> rakudo: my $a=305+437+6; say ($a-44), " tickets that aren't just blocking on tests."

[00:30] <p6eval> rakudo 545638: OUTPUT«704 tickets that aren't just blocking on tests.␤»

[00:31] <[Coke]> rant: "LTA error message" is not, by itself, an actionable ticket.

[00:31] *** colomon left
[00:31] *** colomon_ is now known as colomon

[00:33] *** Chillance left
[00:34] <colomon> [Coke]: I know the thought on the LTA error message tickets is to remind us to be better.  But obviously it's a pretty low priority thing!

[00:38] <[Coke]> rakudo: @_.=[3]

[00:38] <p6eval> rakudo 545638: OUTPUT«===SORRY!===␤Cannot declare placeholder parameter @^_ in the mainline at line 1, near ".=[3]"␤»

[00:39] *** colomon left
[00:41] <[Coke]> rakudo: say 1 % 0

[00:41] <p6eval> rakudo 545638: OUTPUT«1␤»

[00:41] *** replore joined
[00:41] <[Coke]> std: class A {}; sub A {}

[00:41] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Illegal redeclaration of routine 'A' (see line 1) at /tmp/1e7_lwVnRT line 1:␤------> class A {}; sub A⏏ {}␤Check failed␤FAILED 00:01 119m␤»

[00:41] <[Coke]> rakudo: class A {}; sub A {}

[00:41] <p6eval> rakudo 545638:  ( no output )

[00:42] <[Coke]> rakudo: say 16 < 5 < 66

[00:42] <p6eval> rakudo 545638: OUTPUT«Bool::False␤»

[00:42] <[Coke]> rakudo: say (16 < * < 66)(5)

[00:42] <p6eval> rakudo 545638: OUTPUT«Bool::True␤»

[00:45] *** whiteknight left
[00:46] *** whiteknight joined
[00:47] <[Coke]> rakudo: my $a = class { has $a; }; say $a.perl;

[00:47] <p6eval> rakudo 545638: OUTPUT«<anon>␤»

[00:47] <[Coke]> rakudo: my $a = class { has $a; }; say $a.new(a => 1).perl;

[00:47] <p6eval> rakudo 545638: OUTPUT«<anon><-856690017062603138>␤»

[00:48] *** whiteknight left
[00:49] <[Coke]> rakudo: sub if() { '2' }; say if;

[00:49] <p6eval> rakudo 545638: OUTPUT«␤»

[00:49] <benabik> nom: say if;

[00:49] <p6eval> nom 545638: OUTPUT«␤Could not find sub &if␤  in block <anon> at /tmp/eVdvJS7KRE:1␤  in <anon> at /tmp/eVdvJS7KRE:1␤␤»

[00:49] <[Coke]> boy, some of these masak bugs are sticky.

[00:50] <[Coke]> rakudo: my %h = {"a" => "b"}; %h{"a"} = %h.delete("a"); say %h.perl;

[00:50] <p6eval> rakudo 545638: OUTPUT«().hash␤»

[00:50] <diakopter> std: while (4) ; # hopefully this is legal

[00:50] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Missing block at /tmp/0gQBL4sLsC line 1:␤------> while (4) ⏏; # hopefully this is legal␤Parse failed␤FAILED 00:01 120m␤»

[00:51] <[Coke]> rakudo: multi foo() { say "OH HAI" }; multi foo(Int $a?) {};multi foo(Str $a?) {}; foo

[00:51] <p6eval> rakudo 545638: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:()␤:(Int $a)␤:(Str $a)␤␤  in sub foo at /tmp/exSGgscNNw:1␤  in block <anon> at /tmp/exSGgscNNw:1␤  in <anon> at /tmp/exSGgscNNw:1␤␤»

[00:52] <[Coke]> rakudo: die "A"; CATCH { say "OH HAI" }; CATCH { say "OH NOES" }

[00:52] <p6eval> rakudo 545638: OUTPUT«===SORRY!===␤only one CATCH block allowed at line 1, near ""␤»

[00:52] <[Coke]> rakudo: die "A"; CONTROL { say "OH HAI" }; CONTROL { say "OH NOES" }

[00:52] <p6eval> rakudo 545638: OUTPUT«===SORRY!===␤only one CONTROL block allowed at line 1, near ""␤»

[00:56] *** S11001001 left
[00:56] <[Coke]> rakudo: 1 .. 2 .. 3

[00:56] <p6eval> rakudo 545638:  ( no output )

[01:00] <[Coke]> rakudo: my @a = <one two>; @a[-1] = 'zero'; @a.perl

[01:00] <p6eval> rakudo 545638: OUTPUT«Cannot use negative index -1 on Array␤  in method throw at src/gen/CORE.setting:5980␤  in method <anon> at src/gen/CORE.setting:6074␤  in <anon> at src/gen/Metamodel.pm:2085␤  in find_method_fallback at src/gen/Metamodel.pm:2083␤  in find_method at src/gen/Metamode…

[01:01] <[Coke]> std: my @a = <one two>; @a[-1] = 'zero'; @a.perl

[01:01] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unsupported use of [-1] subscript to access from end of array; in Perl 6 please use [*-1] at /tmp/HGjlVLl5ks line 1:␤------> my @a = <one two>; @a[-1]⏏ = 'zero'; @a.perl␤Parse failed␤FAILED 00:01 123m␤»

[01:01] <[Coke]> is ::T valid anymore?

[01:05] *** Tene left
[01:05] *** djanatyn left
[01:09] <TimToady> why not?

[01:10] <[Coke]> Just wondering if I could close some tickets, is all.

[01:10] <[Coke]> TimToady: there are several [spec] tickets that probably need you to poke at them.

[01:11] <[Coke]> rakudo: multi foo() { nextsame }; foo()

[01:11] <p6eval> rakudo 545638:  ( no output )

[01:11] <TimToady> don't doubt it

[01:12] <[Coke]> rakudo: ::()

[01:12] <p6eval> rakudo 545638: OUTPUT«===SORRY!===␤Cannot look up empty name␤»

[01:13] <[Coke]> std: ::()

[01:13] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 119m␤»

[01:13] <[Coke]> is rakudo ok there?

[01:13] <TimToady> sure

[01:15] <TimToady> rakudo: ::(())

[01:15] <p6eval> rakudo 545638:  ( no output )

[01:15] *** ggoebel left
[01:16] <benabik> A variable named '()'?

[01:17] <TimToady> should warn about undefined

[01:17] <[Coke]> woot. there are now 747 tickets in the queue.

[01:17] <benabik> nom: say ().WHAT

[01:17] <[Coke]> there are 47 tickets that needtests.

[01:17] <p6eval> nom 545638: OUTPUT«Parcel()␤»

[01:18] *** alester_ joined
[01:19] <TimToady> rakudo: ::(Nil)

[01:19] <p6eval> rakudo 545638:  ( no output )

[01:19] <TimToady> rakudo: ::(Any)

[01:19] <p6eval> rakudo 545638: OUTPUT«Use of uninitialized value in string context␤»

[01:20] <TimToady> rakudo: ().Str

[01:20] <p6eval> rakudo 545638:  ( no output )

[01:20] <TimToady> rakudo: say ().Str

[01:20] <p6eval> rakudo 545638: OUTPUT«␤»

[01:21] <TimToady> rakudo: say Nil.Str

[01:21] <p6eval> rakudo 545638: OUTPUT«␤»

[01:24] <TimToady> std: sub if() { '2' }; say if;

[01:24] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/L2jtRs4j7l line 1:␤------> sub if() { '2' }; say⏏ if;␤Confused at /tmp/L2jtRs4j7l line 1:␤-----…

[01:24] <TimToady> std: sub if() { '2' }; say if();

[01:24] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 122m␤»

[01:47] *** wolfman2000 joined
[02:44] *** donri left
[02:51] *** ponbiki joined
[02:56] *** colomon joined
[03:10] *** mishin joined
[03:12] *** kaleem joined
[03:15] *** colomon left
[03:22] *** envi_ joined
[03:25] <sorear> good * #perl6

[03:29] *** colomon joined
[03:35] *** scorpil left
[03:35] *** frew joined
[03:35] *** frew left
[03:39] *** colomon left
[03:42] <mishin> Hi perl6

[03:46] <mishin> i try to  perl Configure.pl --gen-parrot under cygwin and get error https://gist.github.com/1263566

[03:50] <mishin> but i think i need http://site.icu-project.org/

[03:52] <sorear> Configure picked a compiler that doesn't exist.  Wierd.

[04:04] *** tokuhir__ joined
[04:07] *** tokuhiro_ left
[04:07] *** envi_ left
[04:36] *** lestrrat left
[04:41] *** satyavvd joined
[04:48] *** [Coke] left
[04:54] <moritz> good morning

[05:00] *** alester_ left
[05:03] <sorear> hi moritz

[05:03] *** mishin left
[05:12] *** molaf joined
[05:15] *** lestrrat joined
[05:22] *** SHODAN joined
[05:29] *** dual joined
[05:54] <moritz> nom: sub foo() { die "OH NOEZ" }␤ foo

[05:54] <p6eval> nom 545638: OUTPUT«OH NOEZ␤  in sub foo at /tmp/2I7guEZtFD:1␤  in block <anon> at /tmp/2I7guEZtFD:2␤  in <anon> at /tmp/2I7guEZtFD:1␤␤»

[05:55] <moritz> nom: sub foo() { die "OH NOEZ" }; foo

[05:55] <p6eval> nom 545638: OUTPUT«OH NOEZ␤  in sub foo at /tmp/BnNlgTp7PK:1␤  in block <anon> at /tmp/BnNlgTp7PK:1␤  in <anon> at /tmp/BnNlgTp7PK:1␤␤»

[06:01] *** wolfman2000 left
[06:10] <japhb> perl6: (0 but True).say

[06:10] <p6eval> rakudo 545638: OUTPUT«No applicable candidates found to dispatch to for 'infix:<but>'. Available candidates are:␤:(Mu $obj, Positional @roles)␤:(Mu $obj, Mu $role)␤␤  in sub infix:<but> at src/gen/CORE.setting:7364␤  in block <anon> at /tmp/PtemMnfgKk:1␤  in <anon> at /tmp/PtemMnfgKk:1␤…

[06:10] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VBool True to Pugs.AST.Types.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[06:10] <p6eval> ..niecza v10-36-g241a2d8: OUTPUT«␤Unhandled Exception: RoleApply with superclasses NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE infix:<but> @ 0) ␤  at /tmp/pKkgy0gIkN line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at …

[06:10] *** tokuhir__ left
[06:11] <japhb> OK, are those just three different ways to say 'NYI', or am I missing something obvious?

[06:13] <japhb> perl6: (0 but Bool::True).say

[06:13] <p6eval> rakudo 545638: OUTPUT«No applicable candidates found to dispatch to for 'infix:<but>'. Available candidates are:␤:(Mu $obj, Positional @roles)␤:(Mu $obj, Mu $role)␤␤  in sub infix:<but> at src/gen/CORE.setting:7364␤  in block <anon> at /tmp/T_XPTD3evU:1␤  in <anon> at /tmp/T_XPTD3evU:1␤…

[06:13] <p6eval> ..niecza v10-36-g241a2d8: OUTPUT«␤Unhandled Exception: RoleApply with superclasses NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE infix:<but> @ 0) ␤  at /tmp/OgHvadB67x line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at …

[06:13] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VBool True to Pugs.AST.Types.VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[06:13] <sorear> japhb: 2 NYI, 1 oldspec

[06:13] <sorear> also:

[06:13] <japhb> sorear, OK, thanks

[06:14] <sorear> b: (0 but True).say

[06:14] <p6eval> b 1b7dd1: OUTPUT«0␤»

[06:14] <japhb> OOC, why is b: not included in perl6: ?  Seems at least as useful a comparison point as pugs: ...

[06:15] <sorear> ask moritz

[06:15] <japhb> moritz, ^^  :-)

[06:17] <japhb> phenny, ask jnthn Can you make '$value but True' and '$value but False' work without too much trouble?  This is coming up when trying to implement MAIN as per spec.

[06:17] <phenny> japhb: I'll pass that on when jnthn is around.

[06:17] <sorear> japhb: try writing it longform

[06:17] <sorear> rakudo: say (0 but role { method Bool { True } })

[06:17] <p6eval> rakudo 545638: OUTPUT«0␤»

[06:17] <sorear> rakudo: say ?(0 but role { method Bool { True } })

[06:17] <p6eval> rakudo 545638: OUTPUT«Bool::True␤»

[06:18] <japhb> sorear, ah ... OK, that will work for now.

[06:18] <sorear> per spec, this is exactly the same as 0 but True

[06:18] <japhb> phenny, tell jnthn sorear++ has found a workaround.  A bit uglier, but the long form seems to work.

[06:18] <phenny> japhb: I'll pass that on when jnthn is around.

[06:19] *** mtk left
[06:21] *** gnude joined
[06:27] *** donri joined
[06:32] *** tokuhiro_ joined
[06:33] *** mtk joined
[06:41] *** gnude left
[06:44] *** mberends joined
[06:46] <dalek> niecza: fce895a | mberends++ | examples/gtk-sierpinski.pl:

[06:46] <dalek> niecza: [examples/gtk-sierpinski.pl] enable window resizing

[06:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fce895a2f5

[06:47] *** GlitchMr joined
[06:48] <sorear> hello GlitchMr

[06:48] <GlitchMr> Hi, sorear

[06:51] <mberends> hi sorear: Niecza had a very good at amsterdam.pm.org last night imo. The only disappointment mentioned was startup speed, and I promised the members that the serialize branch would fix that :)

[06:51] <mberends> *very good showing # I should read before pressing Enter

[06:52] <mberends> we looked at Gtk stuff and also the p5 integration examples.

[06:58] * sorear should try to find a pm someday to understand what mberends is talking about better

[06:59] *** mj41 joined
[06:59] <sorear> but not this week, too few tuits

[06:59] <sorear> and on that note, sleep

[06:59] <mberends> good night

[07:04] <GlitchMr> std: aaa{}

[07:04] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'aaa' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[07:04] <GlitchMr> std: sub aaa{Because $aaa}

[07:04] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Variable $aaa is not predeclared at /tmp/K5uHUxQbLn line 1:␤------> sub aaa{Because ⏏$aaa}␤Undeclared name:␤      'Because' used at line 1␤Check failed␤FAILED 00:01 120m␤»

[07:09] *** colomon joined
[07:31] *** mishin joined
[07:43] *** mj41 left
[07:47] *** colomon left
[07:48] *** baest joined
[07:55] *** mj41 joined
[07:55] <dalek> roast: ef8462e | moritz++ | S10-packages/basic.t:

[07:55] <dalek> roast: test class redeclaration of a package

[07:55] <dalek> roast: review: https://github.com/perl6/roast/commit/ef8462e88c

[07:58] <moritz> nom: sub f($x:) { say $x }; f(3)

[07:58] <p6eval> nom 545638: OUTPUT«Lexical 'self' not found␤  in sub f at /tmp/VVBtLcDj2G:1␤  in block <anon> at /tmp/VVBtLcDj2G:1␤  in <anon> at /tmp/VVBtLcDj2G:1␤␤»

[07:58] <moritz> nom: sub f($x:) { say $x }; 3.&f

[07:58] <p6eval> nom 545638: OUTPUT«Lexical 'self' not found␤  in sub f at /tmp/ShMWDE7gCI:1␤  in method dispatch:<var> at src/gen/CORE.setting:689␤  in block <anon> at /tmp/ShMWDE7gCI:1␤  in <anon> at /tmp/ShMWDE7gCI:1␤␤»

[07:58] <moritz> nom: sub f($x:) { say $x }; 

[07:58] <p6eval> nom 545638:  ( no output )

[07:58] *** amkrankruleuen joined
[07:58] <moritz> nom: my method f($x:) { say $x }; 1.&f

[07:58] <p6eval> nom 545638: OUTPUT«1␤»

[08:05] <dalek> roast: 044a4a6 | moritz++ | S12-subset/subtypes.t:

[08:05] <dalek> roast: test for RT #71820, failed subset type check error includes name of subset

[08:05] <dalek> roast: review: https://github.com/perl6/roast/commit/044a4a61eb

[08:06] <moritz> nom: say (1 Z 2).perl

[08:06] <p6eval> nom 545638: OUTPUT«((1, 2),).list␤»

[08:06] <moritz> nom: say (1 Z 2).[0].WHAT

[08:06] <p6eval> nom 545638: OUTPUT«Parcel()␤»

[08:06] <moritz> nom: say (1 Z 2).elems

[08:06] <p6eval> nom 545638: OUTPUT«1␤»

[08:09] <dalek> roast: 64bc53d | moritz++ | S03-metaops/zip.t:

[08:09] <dalek> roast: test that infix Z returns a list of parcels (RT #75818

[08:09] <dalek> roast: review: https://github.com/perl6/roast/commit/64bc53d164

[08:11] *** amkrankruleuen left
[08:11] *** amkrankruleuen joined
[08:12] *** tokuhiro_ left
[08:14] <dalek> roast: bb44b6c | moritz++ | S10-packages/joined-namespaces.t:

[08:14] <dalek> roast: new test file for joined namespaces

[08:14] <dalek> roast: review: https://github.com/perl6/roast/commit/bb44b6c056

[08:16] <dalek> rakudo/nom: 3d67ff2 | moritz++ | lib/Test.pm:

[08:16] <dalek> rakudo/nom: [Test] do not count dying will Null PMC access as a success

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3d67ff22d0

[08:16] <dalek> rakudo/nom: 840ad74 | moritz++ | t/spectest.data:

[08:16] <dalek> rakudo/nom: run another test file

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/840ad74415

[08:27] *** masak joined
[08:27] <masak> *yawn* good morning, #p6ople

[08:27] <phenny> masak: 04 Oct 23:09Z <diakopter> ask masak how many primes in the first 10^9 primes are primes when represented in a number system other than decimal, but interpreted as decimal, or vice versa?

[08:27] <phenny> masak: 04 Oct 23:11Z <diakopter> ask masak ... or in any number system represented as another number system but interpreted as the original number system?

[08:27] <phenny> masak: 04 Oct 23:15Z <diakopter> ask masak ... e.g. the prime X represented in base-X is 1, etc. that'll get you started.

[08:27] <phenny> masak: 04 Oct 23:16Z <diakopter> ask masak er, scratch that last line ;)

[08:28] <masak> :P

[08:29] <masak> a kind of "number system mojibake" problem...

[08:30] <moritz> I don't quite understand the problem or question

[08:30] <masak> in the case of interpreting in a fewer-digit number system, there will also be lots of "illegal" numbers. just stating the obvious here, really.

[08:30] <moritz> there's a known number of primes below 1e9

[08:30] <moritz> and then you can think about number of ways to represent them

[08:30] <masak> hm, indeed.

[08:31] <moritz> or is it about strings that are primes when interpreted in two different ways?

[08:31] <masak> oh, it appears so.

[08:31] <moritz> like '13'.base(10) and '13'.base(8) both being prime, even if it not the same?

[08:32] <moritz> nom: say '13'.base(8)

[08:32] <p6eval> nom 545638: OUTPUT«Method 'base' not found for invocant of class 'Str'␤  in block <anon> at /tmp/UAf5bHITZN:1␤  in <anon> at /tmp/UAf5bHITZN:1␤␤»

[08:32] <moritz> erm, wrong way around

[08:32] <moritz> nom: say :8('13')

[08:32] <p6eval> nom 545638: OUTPUT«11␤»

[08:32] *** dakkar joined
[08:32] <masak> :)

[08:32] <masak> I'm on irssi on screen on feather today, by the way.

[08:35] <masak> <jlaire> sounds very ad-hoc

[08:35] <masak> this is the feeling I get whenever "interpreted in base X" shows up.

[08:39] <moritz> funny thing is, you can even use changing bases

[08:39] *** mj41 left
[08:39] <moritz> ie a different base for each digit

[08:40] <moritz> and in some of those bases, you can represent pi and e and so on as very regular numbers

[08:42] <moritz> pi/2 is 1.111111... in the base (1, 1/3, 2/5, 3/7, 4/9 ...)

[08:44] <moritz> nom: my @base := 1..* Z 1, 3, 5 ... *; say @base[^6].perl

[08:44] <p6eval> nom 545638: OUTPUT«((1, 1), (2, 3), (3, 5), (4, 7), (5, 9), (6, 11))␤»

[08:44] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say @base[^6].perl

[08:44] <p6eval> nom 545638: OUTPUT«(1/1, 2/3, 3/5, 4/7, 5/9, 6/11)␤»

[08:45] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] 2 X* @base[^20]

[08:45] <p6eval> nom 545638: OUTPUT«22.4796732103645␤»

[08:45] <moritz> erm, right, I need to build the running product of these bases

[08:45] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] 2 X* [ @base[^20]

[08:45] <p6eval> nom 545638: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 1␤»

[08:45] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] 2 X* [\*] @base[^20]

[08:45] <p6eval> nom 545638: OUTPUT«5.14157671400225␤»

[08:46] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] -2,  2 X* [\*] @base[^30]

[08:46] <p6eval> nom 545638: OUTPUT«0␤»

[08:46] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] 2 X* [\*] @base[^30]

[08:46] <p6eval> nom 545638: OUTPUT«0.115608257536946␤»

[08:47] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say [+] 2 X* [\*] @base[^25]

[08:47] <p6eval> nom 545638: OUTPUT«1.14158113096343␤»

[08:47] <moritz> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say pi - [+] 2 X* [\*] @base[^25]

[08:47] <p6eval> nom 545638: OUTPUT«2.00001151903657␤»

[08:47] <moritz> ... modulo the first digit, it appears :-)

[08:48] *** packetknife left
[08:49] <masak> nom: my @base := 1..* Z/ 1, 3, 5 ... *; say (pi - [+] 2 X* [\*] @base[^25]) % 1

[08:49] <p6eval> nom 545638: OUTPUT«1.151903657437e-05␤»

[08:49] <masak> close enough :)

[08:50] <moritz> a better way to use this identity are so-called "spigot algorithms"

[08:51] <dalek> rakudo/nom: fc304e3 | moritz++ | src/core/Exception.pm:

[08:51] <dalek> rakudo/nom: report errors to $*ERR

[08:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc304e3d7a

[08:52] <dalek> roast: 18c3485 | moritz++ | S0 (3 files):

[08:52] <dalek> roast: tests for RT #77056 and #76280

[08:52] <dalek> roast: review: https://github.com/perl6/roast/commit/18c3485fd6

[08:52] *** woosley joined
[09:01] *** daxim joined
[09:06] <masak> re https://rt.perl.org/rt3//Public/Bug/Display.html?id=73502

[09:06] <masak> the current rakudo error message is plain wrong.

[09:06] <masak> and AFAIAC, there's nothing wrong with the code as such.

[09:07] <moritz> nom: @_.= 3

[09:07] <p6eval> nom 840ad7: OUTPUT«===SORRY!===␤Cannot declare placeholder parameter @^_ in the mainline at line 1, near ".= 3"␤»

[09:07] <moritz> well, it's @_ that's being declared, not @^_

[09:07] <masak> right.

[09:07] <moritz> but apart from that... I agree

[09:07] <masak> in fact, nothing's being declared as such.

[09:07] <moritz> @_ *is* a placeholder var in Perl 6

[09:08] <masak> nom: my @_

[09:08] <p6eval> nom 840ad7: OUTPUT«===SORRY!===␤Cannot declare placeholder parameter @^_ in the mainline at line 1, near ""␤»

[09:08] *** [Coke] joined
[09:09] <moritz> masak: would you prefer 'Cannot *use* placeholder parameter"?

[09:11] *** fngraph joined
[09:11] *** fngraph left
[09:14] <masak> yes, I think that would help a lot.

[09:14] <masak> because placeholder parameters aren't declared, really. that's why we have them.

[09:16] <dalek> rakudo/nom: b7af9ff | moritz++ | src/Perl6/Actions.pm:

[09:16] <dalek> rakudo/nom: improve error message, masak++

[09:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7af9ff283

[09:17] <moritz> masak: it's nearly as easy to change such things as to whine about them :-)

[09:17] <moritz> s/whine/complain/

[09:17] <masak> good to know.

[09:18] <moritz> the misreporting of @_ as @^_ might be less trivial to fix, but shouldn't be too hard either

[09:19] <masak> although (1) at this point, I have complaining down to a fine art, and (2) there's still a bit of a threshold to start making commits while doing $dayjob.

[09:22] *** Vlavv_ joined
[09:25] *** Vlavv` left
[09:30] *** orafu left
[09:30] *** replore left
[09:32] *** orafu joined
[09:35] *** GlitchMr left
[09:42] *** wamba joined
[09:43] *** woosley left
[09:43] <moritz> nom: say -Inf cmp -Inf

[09:43] <p6eval> nom 840ad7: OUTPUT«0␤»

[09:44] <moritz> nom: say -Inf cmp '-Inf'

[09:44] <p6eval> nom 840ad7: OUTPUT«-1␤»

[09:44] <moritz> nom: say '-Inf'.Numeric

[09:44] <p6eval> nom 840ad7: OUTPUT«-Inf␤»

[09:44] <moritz> teh fun

[09:44] <moritz> don't worry, I'm about to fix it

[09:53] <moritz> t/spec/S32-io/IO-Socket-INET.t is sooo slow

[10:01] *** pothos left
[10:02] *** pothos_ joined
[10:02] *** pothos_ is now known as pothos

[10:06] *** envi_ joined
[10:15] *** ggoebel joined
[10:16] *** mishin left
[10:17] <dalek> rakudo/nom: bbe823d | moritz++ | src/Perl6/Actions.pm:

[10:17] <dalek> rakudo/nom: avoid @_ being reported as @^_

[10:17] <dalek> rakudo/nom: 

[10:17] <dalek> rakudo/nom: It seems easier to pass the full variable name to add_placeholder_parameter

[10:17] <dalek> rakudo/nom: than to reconstruct it from sigil, identifier and the twigil

[10:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bbe823d64d

[10:17] *** sirmacik left
[10:17] *** sirmacik joined
[10:39] *** f00li5h left
[10:45] *** colomon joined
[11:07] *** tokuhiro_ joined
[11:12] <dalek> rakudo/nom: 4f19b79 | Coke++ | t/spectest.data:

[11:12] <dalek> rakudo/nom: run unfudged test

[11:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f19b79107

[11:14] <masak> [Coke]: LTA-class or not, if a ticket is too vague to have an observable, please flag it as problematic.

[11:14] <masak> [Coke]: I know I sometimes make assumptions when posting tickets. I try not to.

[11:14] <tadzik> good morning, herd

[11:17] <tadzik> in what time is #phasers today?

[11:17] *** colomon left
[11:20] <masak> tadzik: it was 17:30 UTC last week.

[11:23] <tadzik> hmm

[11:23] <tadzik> so it's in the middle of my lectures /

[11:24] <tadzik> :/

[11:24] <tadzik> if I count correctly

[11:24] <tadzik> bbl

[11:25] <masak> those are late classes.

[11:26] <tadzik> aye

[11:26] <tadzik> whole day free, and one lecture 18-20

[11:26] <tadzik> it'd better be an interesting one

[11:31] <moritz> nom: say <foo bar baz>.min

[11:31] <p6eval> nom bbe823: OUTPUT«bar␤»

[11:32] <moritz> the current implementation in nom does that by setting a tracker to +Inf

[11:32] <moritz> then using $tracker cmp $elem on each, and relies on that facth that +Inf cmp's higher than any other element

[11:33] <moritz> nom: say 'f' cmp 'I'

[11:33] <p6eval> nom bbe823: OUTPUT«1␤»

[11:33] <moritz> nom: say 'foo' cmp 'Inf'

[11:33] <p6eval> nom bbe823: OUTPUT«1␤»

[11:33] <moritz> nom: say 'foo' cmp '-Inf'

[11:33] <p6eval> nom bbe823: OUTPUT«1␤»

[11:34] <moritz> ... and it coerces both arguments to .Numeric first, to see if one of them is Inf or -Inf

[11:34] <moritz> which goes horribly wrong in some cases

[11:35] <moritz> nom: class A { has $.s handles <Str> }; say (A.new(:s<a>), A.new<:s<b>).min

[11:35] <p6eval> nom bbe823: OUTPUT«Method 'at_key' not found for invocant of class 'A'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1018␤  in block <anon> at /tmp/Dps1k06ACJ:1␤  in <anon> at /tmp/Dps1k06ACJ:1␤»

[11:35] *** satyavvd left
[11:35] <moritz> nom: class A { has $.s handles <Str> }; say (A.new(:s<a>), A.new(:s<b>).min

[11:35] <p6eval> nom bbe823: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[11:35] <moritz> nom: class A { has $.s handles <Str> }; say (A.new(:s<a>), A.new(:s<b>)).min

[11:35] <p6eval> nom bbe823: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:608␤  in sub infix:<==> at src/gen/CORE.setting:1993␤  in sub infix:<cmp> at src/gen/CORE.setting:1036␤  in method reify at…

[11:36] <moritz> so that happens because cmp looks if $a == Inf etc.

[11:36] <masak> moritz: maybe Inf should really be a Num, but in all other cases (Int, Str, etc) it stands in for something meaning "always wins in a comparison".

[11:36] <masak> well, not always. not against Inf, I guess.

[11:37] *** Psyche^ joined
[11:37] <moritz> masak: but then we need a better to check if something is an Inf

[11:38] <moritz> nom: class A { has $.s handles <Str> }; say A.new(:s<a>) == Inf

[11:38] <p6eval> nom bbe823: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:608␤  in sub infix:<==> at src/gen/CORE.setting:1993␤  in block <anon> at /tmp/PkejLY3KPA:1␤  in <anon> at /tmp/PkejLY3KPA:…

[11:38] <moritz> nom: class A { has $.s handles <Str> }; say A.new(:s<a>).?Numeric == Inf

[11:38] <p6eval> nom bbe823: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:608␤  in method dispatch:<.?> at src/gen/CORE.setting:719␤  in block <anon> at /tmp/5htm48hpin:1␤  in <anon> at /tmp/5htm48…

[11:38] *** kaleem left
[11:38] <moritz> somehow I liked the old .? semantics better

[11:39] <masak> huh? .?Numeric fails with an error? and that's the "new semantics"?

[11:40] <moritz> masak: yes, because there a Mu.Numeric, which it finds

[11:41] *** Patterner left
[11:41] *** Psyche^ is now known as Patterner

[11:41] *** GlitchMr joined
[11:42] <moritz> tl;dr I have no idea how to fix infix cmp

[11:46] *** replore joined
[11:47] <masak> it's the same fundamental issue as with sorting: we basically have no idea how to factor types into it all.

[11:48] <masak> nom: say Mu.Numeric

[11:48] <p6eval> nom bbe823: OUTPUT«Use of uninitialized value in numeric context␤0␤»

[11:48] <masak> nom: say Mu.new.Numeric

[11:48] <p6eval> nom bbe823: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:608␤  in block <anon> at /tmp/jRZGlh0zm5:1␤  in <anon> at /tmp/jRZGlh0zm5:1␤»

[11:48] <masak> huh.

[11:48] <moritz> that's intentional

[11:49] <masak> it's a Liskov smell, at least.

[11:49] <moritz> you basically never want to numify a type object to anything else than 0

[11:49] <flussence> wow, I left tryrakudo on its own for a few weeks... and it's still running

[11:50] <moritz> flussence: does it run on nom already?

[11:50] <flussence> er, lemme check (I think so)

[11:50] <flussence> oh, nope

[11:50] <flussence> 2011.02-4-g14319fc

[11:50] <flussence> shouldn't be too hard to fix...

[11:51] <moritz> probably just involves uploading a src/gen/CORE.setting.pir to feather3

[11:51] <flussence> oh wait, it's slightly more involved since the safe mode stuff changed

[11:51] <moritz> it got easier :-)

[11:52] <moritz> but yes, it still needs adaption

[11:54] *** bluescreen10 joined
[11:55] *** baest left
[11:56] *** baest joined
[11:58] <dalek> rakudo/nom: ff78b5b | moritz++ | tools/build/Makefile.in:

[11:58] <dalek> rakudo/nom: clean up CORE.setting

[11:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ff78b5ba7b

[11:58] <masak> moritz++ # tireless improvements

[12:06] *** preflex left
[12:07] <masak> biggest beef I have with irssi so far, after using it for half a day, is that the input buffer is separate from the channel discussion.

[12:07] *** preflex joined
[12:08] <masak> which is totally irrational, since it has no bearing at all on what can and can't be done. it's just a presentational thing.

[12:17] *** bluescreen10 left
[12:18] <masak> today's mini-challenge: write a "template system" in as little code as possible.

[12:19] <masak> it should take as input a template and a bunch of key-value mappings to be replaced.

[12:19] *** bluescreen10 joined
[12:19] <masak> the exact format of the template and the way the key-value mappings are replaced are left open for easier golfability.

[12:20] <moritz> so just interpolate variables, no ifs/loops/whatever?

[12:26] <masak> right.

[12:34] <moritz> masak: https://gist.github.com/1264326

[12:35] <moritz> note that with a bit fewer bells and whistles, that would be just %args{$0}

[12:36] <masak> will look, will just post my variant first :)

[12:36] <masak> nom: my $t = q[%foo% %bar% %foo% %baz%]; my %b = foo => 1, bar => 2, baz => 3; $t.=subst("%{.key}%", .value, :g) for %b.pairs; say $t

[12:36] <p6eval> nom 4f19b7: OUTPUT«Method 'key' not found for invocant of class 'Any'␤  in block <anon> at /tmp/_FcaSjNVCT:1␤  in block <anon> at /tmp/_FcaSjNVCT:1␤  in method reify at src/gen/CORE.setting:3749␤  in method reify at src/gen/CORE.setting:3654␤  in method reify at src/gen/CORE.setting:365…

[12:36] <moritz> the &filter is for injecting HTML escaping etc.

[12:37] <masak> moritz: nice!

[12:37] <masak> b: my $t = q[%foo% %bar% %foo% %baz%]; my %b = foo => 1, bar => 2, baz => 3; $t.=subst("%{.key}%", .value, :g) for %b.pairs; say $t

[12:37] <p6eval> b 1b7dd1: OUTPUT«1 2 1 3␤»

[12:38] <masak> what's wrong with nom here?

[12:38] <[Coke]> moritz++ 738 tickets; 40 blocking on tests.

[12:38] <moritz> I'm not sure it's actually wrong

[12:38] <moritz> maybe it is

[12:38] <moritz> masak: it doesn't give the block inside the string a $_

[12:39] * [Coke] calls that "under 700 ``real'' tickets, but needs a better word.

[12:39] <moritz> nom: { .say }.()

[12:39] <p6eval> nom 4f19b7: OUTPUT«Any()␤»

[12:39] * [Coke] feels dirty using fake ascii double quotes. ;)

[12:39] <moritz> nom: $_ = 'foo'; { .say }.()

[12:39] <p6eval> nom 4f19b7: OUTPUT«foo␤»

[12:39] <moritz> nom: $_ = 'foo'; "{ .say }"

[12:39] <p6eval> nom 4f19b7: OUTPUT«foo␤»

[12:39] <moritz> huh

[12:39] <moritz> nom: $_ = 'foo'; "{ .say }" for $_

[12:39] <p6eval> nom 4f19b7: OUTPUT«foo␤»

[12:40] <moritz> b: my $t = q[%foo% %bar% %foo% %baz%]; my %b = foo => '%bar%', bar => '%foo%', baz => 2; $t.=subst("%{.key}%", .value, :g) for %b.pairs; say $t

[12:40] <p6eval> b 1b7dd1: OUTPUT«%foo% %foo% %foo% 2␤»

[12:40] <moritz> masak: are you sure you want that semantics for your template system?

[12:41] <moritz> :-)

[12:41] <moritz> the first rule of parsing is that you avoid multi-pass parsing.

[12:42] <moritz> ... with exceptions :-)

[12:42] <[Coke]> ... parse club. you should say "parse club."

[12:42] <moritz> [Coke]: you're right :-)

[12:43] <[Coke]> rakudo: class A { has $.a, $.b; }; A.new(a => 1, b => 10);

[12:43] <p6eval> rakudo 4f19b7: OUTPUT«Null PMC access in find_method('b')␤  in <anon> at /tmp/1VU50j3jQh:1␤  in block <anon> at /tmp/1VU50j3jQh:1␤  in <anon> at /tmp/1VU50j3jQh:1␤»

[12:44] <dalek> niecza: 23f1b2e | (Paweł Murias)++ | lib/ (2 files):

[12:44] <dalek> niecza: remove debugging statements

[12:44] <dalek> niecza: review: https://github.com/sorear/niecza/commit/23f1b2ecec

[12:44] *** pmurias joined
[12:45] *** GlitchMr left
[12:45] * [Coke] does a niecza spectest and sees that things did not stay where he put them.

[12:45] * [Coke] suspects people are, like, adding new tests and stuff.

[12:46] <masak> moritz: for sure, it's a tradeoff between minimalism and that weird multi-pass behavior. I should probably use .trans instead.

[12:47] <moritz> [Coke]: I'm usually not very good at testing my spectest changes with niecza first

[12:48] <moritz> [Coke]: otoh I'm fine with cleaning up tests or rakudo when somebody adds tests for niecza

[12:48] *** benabik left
[12:48] <masak> b: my %b = foo => 1, bar => 2, baz => 3; say .key for %b.pairs

[12:49] <p6eval> b 1b7dd1: OUTPUT«foo␤bar␤baz␤»

[12:49] <masak> nom: my %b = foo => 1, bar => 2, baz => 3; say .key for %b.pairs

[12:49] <p6eval> nom 4f19b7: OUTPUT«foo␤bar␤baz␤»

[12:49] <masak> moritz: I still don't get why my mini-templating system works on b but not on nom.

[12:49] <moritz> nom: my %b = foo => 1, bar => 2, baz => 3; say "{.key}" for %b.pairs

[12:49] <p6eval> nom 4f19b7: OUTPUT«Method 'key' not found for invocant of class 'Any'␤  in block <anon> at /tmp/Jsj9_WhUJ_:1␤  in block <anon> at /tmp/Jsj9_WhUJ_:1␤  in method reify at src/gen/CORE.setting:3749␤  in method reify at src/gen/CORE.setting:3654␤  in method reify at src/gen/CORE.setting:365…

[12:49] <moritz> b: my %b = foo => 1, bar => 2, baz => 3; say "{.key}" for %b.pairs

[12:49] <p6eval> b 1b7dd1: OUTPUT«foo␤bar␤baz␤»

[12:49] <moritz> nom: say "{.key}" given a => b

[12:49] <p6eval> nom 4f19b7: OUTPUT«Could not find sub &b␤  in block <anon> at /tmp/c5YU2FpqXA:1␤  in <anon> at /tmp/c5YU2FpqXA:1␤»

[12:49] <moritz> nom: say "{.key}" given a => 1

[12:49] <p6eval> nom 4f19b7: OUTPUT«Method 'key' not found for invocant of class 'Any'␤  in block <anon> at /tmp/2uyJfcJMNu:1␤  in block <anon> at /tmp/2uyJfcJMNu:1␤  in block <anon> at /tmp/2uyJfcJMNu:1␤  in <anon> at /tmp/2uyJfcJMNu:1␤»

[12:50] <moritz> b: say "{.key}" given a => 1

[12:50] <p6eval> b 1b7dd1: OUTPUT«a␤»

[12:50] <moritz> nom: $_ = a => 1; say "{.key}"

[12:50] <p6eval> nom 4f19b7: OUTPUT«a␤»

[12:50] <masak> odd, no?

[12:50] <moritz> yes, seems like topicalization by 'given' and 'for' does something differently

[12:51] *** pmurias left
[12:51] <moritz> ... different than $_ assignment, that is

[12:51] * masak submits rakudobug

[12:52] *** tokuhiro_ left
[12:53] *** Sarten-X left
[12:57] <[Coke]> there are many new failures in the spec test on niecza which make me think the new tests are wrong.

[12:57] <[Coke]> for example: S06-traits/is-rw.t

[12:58] <[Coke]> nok eval('foo(28)'), 'is rw requires a variable';

[12:58] <[Coke]> this causes niecza to die with:

[12:58] <[Coke]> Unhandled Exception: Binding $a is rw in MAIN foo, cannot bind read-only value to is rw parameter

[12:59] <[Coke]> is the test wrong there, or niecza?

[13:00] *** im2ee joined
[13:01] *** Sarten-X joined
[13:02] *** cosimo left
[13:09] <im2ee> Hello! :)

[13:10] <Woodi> hi im2ee 

[13:11] <Woodi> [Coke]: from what are listen std can answer such questions

[13:11] <Woodi> std: eval('foo(28)')

[13:11] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 120m␤»

[13:12] <[Coke]> Woodi: no, std is just a parser.

[13:12] <Woodi> then no idea what you ask about :)

[13:12] <[Coke]> doesn't help when you're trying to decide how an eval should fail.

[13:13] <[Coke]> phenny: tell sorear that when I fudge roast for niecza, he should definitely check to make sure he's happy with the new tests.

[13:13] <phenny> [Coke]: I'll pass that on when sorear is around.

[13:13] <[Coke]> there. buck passed.

[13:13] <Woodi> [Coke]: then it looks like something like anti-wiki :)

[13:14] *** cosimo joined
[13:15] *** benabik joined
[13:16] *** Tene joined
[13:16] <masak> [Coke]: &eval doesn't catch excceptions any more, so to me it looks like the test is wrong, yes.

[13:18] *** cosimo_ joined
[13:19] *** tzhs joined
[13:24] <Woodi> b: my $a = 1; say $a.undef.defined

[13:24] <p6eval> b 1b7dd1: OUTPUT«Method 'undef' not found for invocant of class 'Int'␤  in main program body at line 22:/tmp/FTec92shi6␤»

[13:24] <Woodi> nom: my $a = 1; say $a.undef.defined

[13:24] <p6eval> nom ff78b5: OUTPUT«Method 'undef' not found for invocant of class 'Int'␤  in block <anon> at /tmp/WNUtMR_pYC:1␤  in <anon> at /tmp/WNUtMR_pYC:1␤»

[13:25] <Woodi> std: my $a = 1; say $a.undef.defined

[13:25] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 122m␤»

[13:25] <Woodi> std: my $a = 'a'; say $a.undef.defined

[13:25] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 122m␤»

[13:25] <Woodi> b: my $a = 'a'; say $a.undef.defined

[13:25] <p6eval> b 1b7dd1: OUTPUT«Method 'undef' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/lU3Rjb0ZET␤»

[13:26] <masak> Woodi: STD won't tell you when a method doesn't exist.

[13:26] <masak> it's just a parser.

[13:26] <Woodi> b: my $a = 'a'; $a = Any; say $a.defined

[13:26] <p6eval> b 1b7dd1: OUTPUT«Bool::False␤»

[13:26] <masak> std: my $a = 1; $a.completely-made-up-method-name

[13:26] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 122m␤»

[13:27] <Woodi> k

[13:28] <Woodi> b: my $a = 'a'; undef $a; say $a.defined

[13:28] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Unsupported use of undef as a verb; in Perl 6 please use undefine function or assignment of Nil at line 22, near " $a; say $"␤»

[13:28] <Woodi> b: my $a = 'a'; undefine $a; say $a.defined

[13:28] <p6eval> b 1b7dd1: OUTPUT«Bool::False␤»

[13:28] <Woodi> tada

[13:29] <masak> nom: my $a = 'a'; undefine $a; say $a.defined

[13:29] <p6eval> nom ff78b5: OUTPUT«Bool::False␤»

[13:30] <Woodi> b: my $a = 'a'; undefine $a; say $a.perl

[13:30] <p6eval> b 1b7dd1: OUTPUT«Any␤»

[13:31] <Woodi> sub a{ return undefine }; say a.perl

[13:31] <Woodi> b: sub a{ return undefine }; say a.perl

[13:31] <p6eval> b 1b7dd1: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in 'undefine' at line 606:src/gen/core.pm␤  in 'a' at line 22:/tmp/Vg60EQJ50P␤  in main program body at line 22:/tmp/Vg60EQJ50P␤»

[13:32] <Woodi> nom: sub a{ return undefine }; say a.perl

[13:32] <p6eval> nom ff78b5: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in sub undefine at src/gen/CORE.setting:7467␤  in sub a at /tmp/jIK5ew30wq:1␤  in block <anon> at /tmp/jIK5ew30wq:1␤  in <anon> at /tmp/jIK5ew30wq:1␤»

[13:32] <masak> 'undefine' is a function, expecting 1 argument.

[13:32] <masak> Woodi: you seem to assume it's a term.

[13:32] <Woodi> it's not right for me

[13:32] <dalek> roast: 2f1dec0 | Coke++ | S0 (10 files):

[13:32] <dalek> roast: niecza fudging

[13:32] <dalek> roast: review: https://github.com/perl6/roast/commit/2f1dec0540

[13:33] <Woodi> perl5: sub a{ return undef }; print a()

[13:33] <[Coke]> ok. if anyone updates those tests, I'd appreciate a retry in niecza. I guess I just need to auto-smoke after roast updates.

[13:33] <Woodi> is any v5 daemon here ? :)

[13:34] <masak> Woodi: 'undef' is both a term and a function in Perl 5. in Perl 6, the term is now Any (and other type objects), and 'undefine', respectively.

[13:34] * Woodi do not like this

[13:34] <masak> s/, and/, and the function is/

[13:34] <Woodi> 'return Any' looks strange...

[13:34] <masak> Woodi: feel free to explain why you do not like it. I like it.

[13:35] <masak> or 'return Str' if your function is supposed to return a Str.

[13:35] <masak> or 'fail'.

[13:35] <masak> or 'die "something went wrong"'

[13:35] <Woodi> becouse i learned from Perl5 and 'return undef' was perfect, clear, etc

[13:36] <[Coke]> Some things are going to change. Sorry.

[13:36] <Woodi> but why change good things ??

[13:36] <Woodi> to many mantras IMO

[13:38] <masak> Woodi: you can't just come into #perl6 and ask "but why change good things ??" :P

[13:38] <masak> it's our job to take an essentially good thing -- Perl 5 -- and change it for the better.

[13:39] <huf> Woodi: also, in perl5 return undef was most probably a bug :)

[13:39] <masak> these changes are often done with good reason. if the reason turned out to be less than good, we usually make a better change later.

[13:39] <masak> huf: there's that, too.

[13:40] <masak> Woodi: when would you do 'return undef' rather than 'return' in Perl 5?

[13:40] <Woodi> return returns truth i think...

[13:41] <huf> you think wrong

[13:41] <huf> but i think in this case the best you can do is figure out how undefs work and why it was split into many things in p6 before pronouncing judgement

[13:42] <masak> perl6: say defined foo; sub foo { return } # Woodi: observe

[13:42] <p6eval> rakudo ff78b5, niecza v10-38-g23f1b2e: OUTPUT«Bool::False␤»

[13:42] <p6eval> ..pugs: OUTPUT«␤»

[13:43] <huf> masak: a bare return is short form for what in p6?

[13:43] <huf> in p5 it was return () iirc

[13:43] <masak> Woodi: I'd be happy to explain why Perl 6 has two things where Perl 5 has only one. but as huf says, it's more urgent that you know about how undefs work in Perl 5. :)

[13:43] <masak> huf: 'return Nil'

[13:43] <masak> IIUC.

[13:44] <masak> and Nil is short for a kind of undef ()

[13:44] <Woodi> huf: "RFC 28: Perl should stay Perl" and: "The essence of Perl is really context sensitivity, not just to syntactic context, but also to semantic, pragmatic, and cultural context."

[13:44] <huf> masak: Nil is what? empty list in list ctx and some form of undef in item

[13:44] <huf> ?

[13:45] <huf> Woodi: yes?

[13:45] <Woodi> after all Perl6 is descendant of Perl5 and good things should stay

[13:45] <masak> huf: yes, something very much like that.

[13:45] <huf> you've just demonstrated that you dont understand how the supposed good think in p5 works

[13:45] <huf> Woodi: how *exactly* do you want it to stay the same in p6 if you dont know what it is?

[13:45] <masak> huf: it's an object representing "could've got a list of things here, but got nothing, not even an empty list"

[13:46] <huf> masak: ah, Nil is emptylister than ()? heheh :D

[13:46] <snarkyboojum> thank goodness for good error messages

[13:46] <snarkyboojum> std: undef

[13:46] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤  Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  :!defined as a matcher,␤        Any:U as a type constrain…

[13:46] <masak> snarkyboojum++

[13:46] <Woodi> huf: how you think, why Perl is/was so popular ? :) becouse some clear things like "return undef" JUST WORKS

[13:47] <huf> Woodi: but i'm telling you it's most likely a big in p5.

[13:47] <masak> Woodi: as huf points out, you're making a bit of a fool of yourself by claiming that Perl 6 should be like Perl 5, and then demonstrating your lack of insight into how Perl 5 actually works.

[13:47] <[Coke]> Woodi: there is always perl5, and you are, of course, welcome to keep using it if you don't want to learn more about six.

[13:47] *** localhost left
[13:48] <Woodi> allPpls: i think perl5 wasn't perfect and this is my reason to involwing in v6. but "what was worked will stay" - cannot find exact citation...

[13:48] <mux> reminds me of yesterday, when someone who had broken his FreeBSD system for not properly following 3rd party apps update instructions, claimed that FreeBSD is broken, that versioned shared libs are too, and that I was an idiot for not believing him

[13:49] *** localhost joined
[13:49] <masak> Woodi: you keep assuming that 'undef' was working as it was.

[13:49] <PerlJam> Woodi: "return undef" is often a code smell anyway

[13:50] <Woodi> yes, masak, it was working perfect.

[13:50] <huf> so i suppose there's no possibility that other people have more insight than you

[13:50] <Woodi> why it is smell ?

[13:50] <huf> Woodi: because list context. it's almost surely not what you want.

[13:50] <Woodi> huf: pls enlight me :)

[13:51] <masak> Woodi: what type would 'undef' have in Perl 6?

[13:51] <Woodi> example:

[13:51] <masak> Woodi: remember that it can be returned from any function, even those that return Str or Int or DateTime.

[13:51] <Woodi> sub a{ return undef }

[13:52] <masak> auugh

[13:52] <PerlJam> masak: careful ... he'll just invoke "magic" with a handwave.

[13:52] <masak> Woodi: you're not listening.

[13:52] <huf> Woodi: sub x { return undef } if (x()) { works as expected } my @x = x(); if (@x) { surprise }

[13:52] <masak> Woodi: why are you using 'return undef' there, and not just 'return'?

[13:52] <huf> Woodi: but that's just explicit return undef, not really the core issue here

[13:52] <Woodi> then it works for: scalars, hashes, lists, bools - it Perl philosophy

[13:52] <mux> lol

[13:53] <mux> people have just shown you how it doesn't really work for lists

[13:53] <huf> Woodi: p6 has more types than that...

[13:53] <masak> Woodi: are you not reading what people are telling you?

[13:53] <mux> I love people who have the nerve to dispute what perl's philosophy is, with people who are the main contributors to the language

[13:53] <masak> Woodi: a conversation has to be a bit of give-and-take. you have to react to what we tell you, too.

[13:53] <Woodi> mux: then it should be better in v6 :)

[13:54] * masak hugs Woodi 

[13:54] <Woodi> thanx :)

[13:54] <masak> I think I needed that more than you did.

[13:54] <PerlJam> #perl6 ... where you get a hug even if we suspect you're a troll  :)

[13:54] <mux> group hug?

[13:54] <moritz> [Coke]: oh, my fault. eval() in rakudo catches exceptions, in niecza it doesn't

[13:55] <Woodi> mux: contribution does not matter, using Perl matters

[13:55] <masak> Woodi: you're using it wrong :)

[13:55] <mux> whatever

[13:56] <moritz> [Coke]: and I suppose niecza is correcter here

[13:56] <Woodi> PerlJam: you think i am trolling here ?

[13:57] <masak> Woodi: *I* think you're trolling here.

[13:57] <masak> Woodi: but I also think you are not aware you are.

[13:57] <PerlJam> Woodi: in any case,  if your subroutine is likely to be used in both scalar and list contexts, you should use just "return;" to mean "give nothing back", otherwise if you use "return undef;" in list context, you end up with a one element list containing a single undef value.

[13:57] <mux> it's very hard to differentiate an ignorant person and a successful troll

[13:57] <Woodi> i think i just have other thinking

[13:57] <mux> I for one just think you have no clue what you're talking about

[13:57] <snarkyboojum> I've learned something from this convo anyway, undef isn't typed enough for Perl 6, that seems to be a big part of it, so you return Mu or Nil or an undefined type object

[13:57] <masak> what mux said.

[13:58] <masak> I'm glad I reached snarkyboojum++ :)

[13:58] <snarkyboojum> maybe not 100% right, but seems to be part of it :D

[13:58] <masak> then this conversation wasn't a total waste.

[13:58] <snarkyboojum> masak++ for general learnedness ;)

[13:58] <moritz> niecza: try eval('1 1')

[13:58] <p6eval> niecza v10-38-g23f1b2e:  ( no output )

[13:58] <moritz> niecza: eval('1 1')

[13:58] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«␤Unhandled Exception: Two terms in a row at (eval) line 1:␤------> 1 ⏏1␤␤  at /home/p6eval/niecza/lib/CORE.setting line 1938 (CORE eval @ 4) ␤  at /tmp/WlCFX9p4gO line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line…

[13:58] <Woodi> no. return Any, or return Mu is just to many headache for language like Perl

[13:59] <moritz> so, return; then

[13:59] <Woodi> but i will leave this subject now

[13:59] <snarkyboojum> Woodi: well just a return from a sub will return Nil anyway, so you're all good :)

[13:59] <masak> Woodi: JUST USE 'return;' IN EITHER PERL 5 OR 6, YOU F-ING MORON

[13:59] * flussence blinks

[13:59] <PerlJam> masak: Hmm.  Do you need another hug?

[13:59] <masak> Woodi: WE'VE BEEN TELLING YOU THIS FOR HALF AN HOUR, DAMMIT

[13:59] <huf> ... how is returning anything a headache?!

[13:59] <huf> wat.

[14:00] <masak> PerlJam: hug didn't help. letting of steam might've.

[14:00] * PerlJam hugs masak anyway

[14:00] <masak> thanks. :/

[14:01] <flussence> well someone was going to do it eventually.

[14:01] <snarkyboojum> I think Woodi is just grappling with the idea - no hard feelings eh :D

[14:01] <huf> wish we had mst here ;)

[14:01] <masak> I agree that might not have been very #perl6-y. not sure it helped either me or Woodi, either.

[14:02] <huf> masak: it makes this channel more believable

[14:02] <masak> Woodi: for what it's worth, I don't think you're a moron. I think in this particular discussion, you have comprehension problems.

[14:02] <huf> you're all too friendly and patient

[14:02] <masak> Woodi: as in, it's not us (or Perl 6), it's you.

[14:02] <moritz> huf: it works on the vast majority of subjects in our secrect psychology study :-)

[14:03] <moritz> [Coke]: I'll try to fix some of that fallout tonight

[14:03] <masak> I confess that shouting was my second recourse, after realizing that I don't have op powers.

[14:03] <moritz> you... don't?

[14:04] *** ChanServ sets mode: +o moritz

[14:04] *** moritz sets mode: +o masak

[14:04] *** moritz sets mode: -o moritz

[14:04] <masak> thanks.

[14:04] <flussence> kicking people is never the correct answer, unless you're making a ruby joke.

[14:04] <PerlJam> I think Woodi is just victim of the same disease of those people who say "Perl 6 isn't Perl because it uses a . instead of a ->"   (i.e., not a deep enough understanding of the essence of the language)

[14:04] <masak> PerlJam: aye, probably.

[14:05] <moritz> PerlJam: one problem is that Woodi is voicing strong opinions, but doesn't know much about perl 6, and has even admitted that here

[14:05] <masak> PerlJam: it's very naive to come in, pick a feature, and start yelling "you promised you wouldn't change the good parts", though.

[14:05] <moritz> PerlJam: it's a form of agression

[14:05] <snarkyboojum> except in this case the issues of definedness and types is a little deeper than syntactic changes from -> to .

[14:05] <masak> they are.

[14:06] <mux> I think what's really naive (and actually moronic) is not being able to realize you don't have the necessary knowledge of something to actually argue with people who obviously know what they're talking about

[14:06] <snarkyboojum> maybe I'm too charitable, but I reckon he was genuinely trying to grok it :D

[14:06] <masak> fwiw, I still feel a little strange when I do 'return Str' or similar.

[14:06] <masak> my bet is that not many people have run into this situation yet.

[14:06] <Woodi> masak: this wasn't only about 'return'. i was about to eagerly dropping things that works ok in v5. perl5 ppls want perl6 too. and new ppls in Perl community, like you, do not understand that

[14:06] <moritz> masak: yep, but it doesn't happen often

[14:06] <PerlJam> Hmm.

[14:07] <moritz> Woodi: fwiw undef wasn't eagerly dropped. It was dropped after years of trying to figure out what 'undef' actually means, and realizing it doesn't have a meaning

[14:07] <moritz> in Perl 6, that is

[14:07] <snarkyboojum> Woodi: I guess the message was that there are good reasons for why the change has happened, and they're probably a little subtle

[14:07] <masak> Woodi: I agree there's a general risk of changing "too much". but "undef" isn't such a case.

[14:07] <moritz> masak: in the end you usually want to fail() instead of return Str;

[14:07] <masak> aye.

[14:07] <masak> I think so too.

[14:07] <PerlJam> Woodi: everything that has changed in Perl 6 from Perl 5, has done so after quite a fair bit of thought.  Sometimes they've changed several times before we've gotten where we are today.

[14:08] <masak> Woodi: you've undermined yourself somewhat in this discussion by defending 'return undef' when people have been telling you (repeatedly) that it's probably an error to use it.

[14:09] <flussence> two errors, actually: perl -wle 'sub x { return undef }; my %x = x()'

[14:09] <flussence> :)

[14:09] <masak> Woodi: but even aside from that, 'undef' was changed for really good reasons, IMO.

[14:09] <Woodi> moritz: first notice i was asking about how to do 'return undef'. before i tested 'return' probably someone advised to use 'return Any'  and that is not what i expect form Perl. and then discussion started.

[14:09] * [Coke] wonders if we can get a perl5 mode for evalbot.

[14:09] <moritz> [Coke]: buubot_backup has a perl 5 mode

[14:09] <moritz> buubot_backup: eval: undef + 2

[14:09] <buubot_backup> moritz: ERROR: Can't modify constant item in undef operator at (eval 20) line 2, at EOF 

[14:09] <PerlJam> Woodi: in any case ... we're not the ones you need to convince if you want to make a change in Perl 6.  We're not the language designer.  

[14:10] <moritz> PerlJam: we are :-)

[14:10] <moritz> at least a subset of them

[14:10] <PerlJam> moritz: shh :)

[14:10] <masak> PerlJam: didn't you get the memo? :P

[14:10] <moritz> to /return/ to a more technical issue, I'm now trying to make rakudo not catch exceptions in eval()

[14:10] <moritz> it's been spec not to catch for some time

[14:10] <moritz> and niecza doesn't catch

[14:10] <masak> ++morotz

[14:10] <masak> augh

[14:11] <masak> ++moritz

[14:11] <moritz> and the mismatch between the two causes maintenance nightmares in roast

[14:11] <snarkyboojum> Niecza does perl5 bits and bobs now eh.. not sure if that's p6eval'able

[14:12] <moritz> snarkyboojum: I'd rather not, it probably doesn't have a safe mode :-)

[14:12] <masak> Woodi: we have types in Perl 6. that's the main reason 'undef' had to change.

[14:12] <snarkyboojum> Woodi: lots of juicy reading in the perl6-language archives fwiw e.g. http://osdir.com/ml/perl6-language/2009-11/msg00075.html

[14:12] <dalek> rakudo/eval-throws: 741a933 | moritz++ | src/core/control.pm:

[14:12] <dalek> rakudo/eval-throws: Do not catch exceptions from eval()

[14:12] <dalek> rakudo/eval-throws: review: https://github.com/rakudo/rakudo/commit/741a93358f

[14:12] <masak> Woodi: that's also the main reason 'wantarray' had to go.

[14:12] <snarkyboojum> moritz: good point :)

[14:13] <flussence> while we're on an error-handling topic, I want to whine about rakudo's Test.pm: https://gist.github.com/1179681

[14:13] <PerlJam> masak: They were warts on the flesh of context-sensitivity?

[14:14] <masak> PerlJam: :)

[14:14] <moritz> flussence++

[14:14] <snarkyboojum> Woodi: or rather the real spec on definedness http://perlcabal.org/syn/S02.html#Undefined_types # I will stop now :D

[14:15] <masak> PerlJam: there wasn't any way to combine MMD and wantarray. and we liked MMD more :)

[14:23] <dalek> rakudo/eval-throws: fa2d5c5 | moritz++ | lib/Test.pm:

[14:23] <dalek> rakudo/eval-throws: Test.pm needs to deal with eval() not catching exceptions

[14:23] <dalek> rakudo/eval-throws: review: https://github.com/rakudo/rakudo/commit/fa2d5c525a

[14:24] <Woodi> masak: types are additional feature to 'automagic typing' - where it is possible

[14:24] <moritz> Woodi: that's bullshit

[14:24] <moritz> Woodi: types are very deeply rooted in the language

[14:25] <moritz> even if it doesn't always appear to be the case

[14:25] <Woodi> moritz: i am just user

[14:25] <mberends> Woodi: you might be interested in the history of the demise of undef. Here is the moment it became doomed: http://irclog.perlgeek.de/perl6/2009-11-24#i_1762914. Prior to that, it caused problems, for example http://irclog.perlgeek.de/perl6/2009-11-23#i_1760736. Mu and Nil were still to me named, as you will see if you read further.

[14:25] <Woodi> and it works that way

[14:25] <moritz> Woodi: if your argument is "i am just a user", don't participate in language design discussion

[14:25] <mux> spot on.

[14:25] <flussence> it helps if you've actually *used* the language too.

[14:26] <moritz> Woodi: if you want to participate in those discussions, you can't be "just a user", but you need to actually understand the implications of stuff

[14:26] <masak> that's what makes language design both thrilling and frustrating :)

[14:26] <masak> usually the implications aren't understood until there's an implementation on which to try a feature out.

[14:27] <mux> designing a language is science; not packing N 'cool' features together...

[14:27] <moritz> feedback is ok, but then please formulate it constructively

[14:27] <PerlJam> mux: I disagree.  Designing a languae is art  :-)

[14:27] <mux> PerlJam: heh. and quite a bit of that too yeah ;-)

[14:28] <Woodi> moritz: 1. i do not say anything autoritary. OK ?

[14:28] <mux> that sentence alone just made my irony-meter explode

[14:28] <moritz> Woodi: you basically say "$thing sucks". That's not constructive.

[14:28] <Woodi> 2. real programmer feedback on Perl: types are additional feature to 'automagic typing' - where it is possible

[14:29] <snarkyboojum> Woodi: as a user of a language type info can be very helpful.. perl 6 uses the idea of gradual typing - see http://6guts.wordpress.com/2010/09/20/gradual-typing-merged-mops-and-bounded-serialization/

[14:29] <Woodi> moritz: i was wrong. just 'return' is better :)

[14:30] <moritz> Woodi: ok, great

[14:30] <Woodi> snarkyboojum: it is what i say in details

[14:30] <snarkyboojum> Woodi: there's lots of info out there for the inquisitive mind :)

[14:30] <moritz> [Coke]: if you ack 'nok\s+eval'  in roast, you get a list of moritzFAIL :-)

[14:31] * Woodi was doing tee when you still yelling on me :)

[14:32] * Woodi thinks forcing 'return Anything' is bad. but seems no one force this :)

[14:34] <PerlJam> Woodi: Perl doesn't *force* anything.  IT strongly encourages things, however.

[14:34] <PerlJam> Woodi: this is part of the essence of Perl.  TMTOWTDI after all

[14:36] * benabik is in the middle of backlogging, but...

[14:36] <benabik> Does fail() return, or do you need to return fail?

[14:36] <moritz> benabik: fail() returns

[14:37] * benabik wonders why he asks when he has perl6 installed.

[14:37] <masak> benabik: that habit is hard to break. :)

[14:38] <masak> at least you notice it, unlike most of p6l. :P

[14:39] <benabik> Hm.  The REPL isn't as robust as it could be.  `sub foo { fail('bar') }; my $x = foo` just exited the REPL.  It printed bar, but nothing else.

[14:39] <masak> actually, p6l has been mostly silent recently. not really living up to its reputation as a think tank.

[14:39] * masak needs to re-ignite the 'rw attr' thread

[14:39] <moritz> masak: it usually is quite the think tank if you inject a quesiton or idea

[14:39] <felher> masak++ for macro-branch :D

[14:40] <masak> benabik: we've had a bunch of those things. this particular one might be new.

[14:40] <masak> benabik: want to report it to RT?

[14:40] <benabik> masak: where's RT?

[14:40] <masak> benabik: just email [email@hidden.address] about it.

[14:41] <benabik> masak++

[14:41] <masak> like magic, it'll turn into a bug report in the system :)

[14:43] *** DarkWolf84 joined
[14:43] <DarkWolf84> hello #perl6

[14:43] <masak> DarkWolf84! \o/

[14:44] <DarkWolf84> hi, masak

[14:44] <masak> felher: ooh, you've tried it out? any nice use-case yet? :)

[14:44] * benabik golfs a bit.

[14:45] <DarkWolf84> nom: my $a = sub { return }; say $a;

[14:45] <p6eval> nom ff78b5: OUTPUT«_block1011␤»

[14:45] <DarkWolf84> is that corect?

[14:45] <DarkWolf84> I think it shoud be Any

[14:46] <benabik> nom: my $a = sub { return }; say $a()

[14:46] <p6eval> nom ff78b5: OUTPUT«Nil␤»

[14:46] <benabik> DarkWolf84: The _block1011 is the (somewhat LTA) string for the sub.

[14:46] <PerlJam> DarkWolf84: It should not be Any, but it certainly should not be "_block1011"

[14:47] *** daxim left
[14:48] <benabik> I think it's probably supposed to be Code.

[14:48] <snarkyboojum> niecza is arguably more meaningful

[14:48] <snarkyboojum> niecza: my $a = sub { return }; say $a;

[14:48] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«{ ... }␤»

[14:48] <benabik> Er, Sub.

[14:48] <snarkyboojum> or not :)

[14:49] <benabik> The parrot object is leaking through.

[14:49] <snarkyboojum> I like it tho ;)

[14:50] <benabik> nom: fail; say 'foo'

[14:50] <p6eval> nom ff78b5: OUTPUT«foo␤»

[14:50] <benabik> nom: sub foo { fail; say 'foo' }; foo

[14:50] <p6eval> nom ff78b5:  ( no output )

[14:50] <felher> masak: Nope, sorry, had to learn for an exam. But i sure will. :) Will/did you blogpost about your branch?

[14:50] <benabik> That seems odd.

[14:51] <masak> felher: yes, as soon as I manage to get back on the horse again with blogging.

[14:51] *** jaldhar left
[14:51] <masak> somehow there's not as much time in a day as there used to be.

[14:52] <DarkWolf84> masak: ok, it was the braces

[14:53] <masak> DarkWolf84: right, I should've told you. sorry :)

[14:53] <DarkWolf84> so perl6 is context language like ever :)

[14:53] <benabik> More concise...

[14:53] <masak> I looked at that and thought "he probably meant to call it". forgot to mention it, though.

[14:53] <DarkWolf84> s/like ever/like perl 5/

[14:53] <benabik> nom: sub foo { fail; say 'foo' }; foo; fail; say 'bar' # I expect either "foo\nbar" or nothing, but get...

[14:53] <p6eval> nom ff78b5: OUTPUT«bar␤»

[14:54] <masak> DarkWolf84: it's not so much context here, as explicitly calling a variable.

[14:54] <masak> DarkWolf84: to call &foo, you either have to do '&foo()' or 'foo'.

[14:54] <masak> DarkWolf84: with '$a', there's only the '$a()' option.

[14:54] <DarkWolf84> masak: but foo is just a sub not a closure

[14:55] *** kmwallio joined
[14:55] <masak> DarkWolf84: the difference between sub and closure doesn't matter from the perspective of calling it.

[14:56] <benabik> nom: my &foo = sub { return }; my $bar; say &foo; say $bar; say &foo(); say $bar(); say foo

[14:56] <p6eval> nom ff78b5: OUTPUT«_block1011␤Any()␤Nil␤Method 'postcircumfix:<( )>' not found for invocant of class 'Any'␤  in <anon> at src/gen/Metamodel.pm:3164␤  in block <anon> at /tmp/JpNnxJP95D:1␤  in <anon> at /tmp/JpNnxJP95D:1␤»

[14:56] <benabik> Oh, forgot a step...

[14:56] <benabik> nom: my &foo = sub { return }; my $bar = &foo; say &foo; say $bar; say &foo(); say $bar(); say foo

[14:56] <p6eval> nom ff78b5: OUTPUT«_block1011␤_block1011␤Nil␤Nil␤Nil␤»

[14:57] <felher> masak: Sounds good to me. :) 

[14:57] <masak> benabik++

[14:58] <masak> felher: general plan: an introductory post about macros and what they are; then a post about the work with D1.

[14:58] <benabik> _block1011 is still somewhat LTA.  Code should probably .gist to '{ … }' or something

[14:58] *** GlitchMr joined
[14:58] <benabik> Not sure how it's falling back to the parrot sub.

[14:58] <PerlJam> benabik: or ... the actual code :)

[14:59] <jnthn> Because we want named subs to stringify to the name of the sub.

[14:59] <phenny> jnthn: 06:17Z <japhb> ask jnthn Can you make '$value but True' and '$value but False' work without too much trouble?  This is coming up when trying to implement MAIN as per spec.

[14:59] <phenny> jnthn: 06:18Z <japhb> tell jnthn sorear++ has found a workaround.  A bit uglier, but the long form seems to work.

[14:59] <jnthn> And it doesn't make sense to have our own slot for name when a Parrot sub has such a slot

[14:59] <DarkWolf84> nom: my $array_reff = <a b c>;  $a.say; a.perl.say

[14:59] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Symbol '$a' not predeclared in <anonymous> (/tmp/EOPfxRFz_7:1)␤»

[15:00] <DarkWolf84> oops

[15:00] <jnthn> Probably should be more like <anon> or so though, rather than _block1234

[15:00] <PerlJam> jnthn: indeed.

[15:00] <DarkWolf84> nom: my $array_reff = <a b c>;  $array_reff.say; array_reff.perl.say

[15:00] <p6eval> nom ff78b5: OUTPUT«a b c␤Could not find sub &array_reff␤  in block <anon> at /tmp/tx20zgbwCP:1␤  in <anon> at /tmp/tx20zgbwCP:1␤»

[15:00] <jnthn> I can probably do something about it; file a ticket.

[15:00] <PerlJam> DarkWolf84: missing a sigil

[15:00] <jnthn> decommute &

[15:01] <DarkWolf84> again

[15:01] <DarkWolf84> nom: my $array_reff = <a b c>;  $array_reff.say; $array_reff.perl.say

[15:01] <p6eval> nom ff78b5: OUTPUT«a b c␤("a", "b", "c")␤»

[15:01] <DarkWolf84> ok

[15:01] <felher> masak: Nice. *waitingForIt* :)

[15:01] *** SHODAN left
[15:02] <DarkWolf84> I really must try nom :)

[15:02] <TimToady> why do we want to stringify to just the name, when .name is available for that?

[15:03] *** baest left
[15:04] <DarkWolf84> PerlJam, I'm verry absend theese days

[15:06] *** risou_awy is now known as risou

[15:06] <DarkWolf84> absent*

[15:06] <TimToady> in fact, I would argue that sub foo might stringify to &foo, and an anonymous function to just &

[15:06] <masak> cute.

[15:07] <masak> perl6: sub foo {}; say &foo ~~ &foo

[15:07] <p6eval> rakudo ff78b5, niecza v10-38-g23f1b2e: OUTPUT«Nil␤»

[15:07] <p6eval> ..pugs: OUTPUT«␤»

[15:07] <masak> hm.

[15:07] <benabik> Nil?

[15:07] <DarkWolf84> O_O

[15:07] <masak> perl6: sub foo { say "because it was run" }; say &foo ~~ &foo

[15:07] <p6eval> rakudo ff78b5, niecza v10-38-g23f1b2e: OUTPUT«because it was run␤Bool::True␤»

[15:07] <p6eval> ..pugs: OUTPUT«because it was run␤1␤»

[15:09] <DarkWolf84> yeah i got it

[15:10] <DarkWolf84> nom: say Any ~~ Any

[15:10] <p6eval> nom ff78b5: OUTPUT«Bool::True␤»

[15:10] <DarkWolf84> nope

[15:11] <DarkWolf84> nom: say 0 ~~ 0

[15:11] <p6eval> nom ff78b5: OUTPUT«Bool::True␤»

[15:11] <DarkWolf84> ...

[15:12] <DarkWolf84> oh, the refs are different

[15:12] <TimToady> smartmatching is not symmetrical

[15:13] <moritz> and nearly everything is Any

[15:13] <DarkWolf84> i forgot ~~ is not ==

[15:13] <masak> nom: say Junction ~~ Any

[15:13] <p6eval> nom ff78b5: OUTPUT«Bool::False␤»

[15:14] * masak .oO( "I said *nearly* everything!" )

[15:14] <TimToady> nom: say Any ~~ :!defined

[15:14] <p6eval> nom ff78b5: OUTPUT«Bool::True␤»

[15:14] <DarkWolf84> why Any is defined

[15:14] <moritz> it is not

[15:14] <TimToady> it's not

[15:14] <moritz> that's the !

[15:14] <TimToady> or rather, it's !

[15:15] <benabik> nom: sub foo { 2 }; say 2 ~~ &foo

[15:15] <p6eval> nom ff78b5: OUTPUT«2␤»

[15:15] <benabik> nom: sub foo { 2 }; say 1 ~~ &foo

[15:15] <p6eval> nom ff78b5: OUTPUT«2␤»

[15:15] <DarkWolf84> my dad

[15:15] <masak> are you talking about !?

[15:15] <DarkWolf84> my bad*

[15:15] <moritz> nom: say so try { eval 'die "foo"' }

[15:15] <p6eval> nom ff78b5: OUTPUT«Bool::False␤»

[15:16] <moritz> I get a segfault with my local patch :(

[15:16] <moritz> nom: try { die "foo" }; say so $!

[15:16] <p6eval> nom ff78b5: OUTPUT«Bool::True␤»

[15:17] <moritz> am I right in assuming that exceptions should be False rather than True?

[15:17] <TimToady> benabik: you're exercising S03:3611

[15:19] <benabik> TimToady: I would almost expect a 0 arg sub to be called and then the result smart matched against...

[15:19] <benabik> Ignoring the LHS of ~~ is odd.  (to me)

[15:21] <TimToady> the left arg was already bound to $_, and the right arg was *already* called for the smartmatch, and the smartmatch found a Callable on the right, so it's entirely up to the Callable whether it pays attention to $_ or not

[15:21] <masak> moritz: I can't think of a reason they should. but maybe there is one?

[15:22] <benabik> TimToady: Fair enough.

[15:22] <masak> moritz: also -- False and :!defined, or False but :defined?

[15:25] <moritz> masak: not sure about defined

[15:26] <DarkWolf84> will qregex implement LTM

[15:26] <DarkWolf84> ?

[15:26] <moritz> masak: my use case is that I want to write   nok try { eval $string }

[15:26] <moritz> masak: and try { } should return the exception on failure, afaict

[15:26] <moritz> or should it return a Failure that wraps the exception?

[15:26] <moritz> and then the Failure is neither .defined nor True?

[15:26] <tadzik> wow, there have been shouts

[15:27] <moritz> tadzik: not only shouts, but shouts by masak :-)

[15:27] <tadzik> I can barely imagine masak shoulting

[15:27] <tadzik> or even shouting

[15:27] <DarkWolf84> me too

[15:27] <masak> me neither.

[15:28] * tadzik hugs masak

[15:28] <DarkWolf84> the trols make mirakles sometimes

[15:28] <masak> ...but if it gets me this many hugs, maybe I should start shouting more often... :)

[15:28] <tadzik> I found it more like misunderstanding than trolling

[15:28] <masak> oh, it was.

[15:28] <tadzik> SOMEBODY HUG ME DAMNIT

[15:28] <tadzik> :)

[15:29] <masak> a misunderstanding, I mean.

[15:29] <masak> suddenly I found myself thinking of mst's post about "sometimes the only way to reach through to a person that wastes everybody's time is to shout at them".

[15:29] <masak> and then I tried it.

[15:30] <benabik> masak: I'm not sure WWmstD is a good way to live your life.  ;-)

[15:30] <masak> here's the post, by the way: http://www.shadowcat.co.uk/blog/matt-s-trout/on-being-a-bastard/

[15:30] <masak> benabik: heh :)

[15:30] <tadzik> lecturestime, will be a bit early and a bit late for #phasers today

[15:32] <benabik> obey, I don't have a lecture today.  I can be in #phasers!

[15:33] *** tzhs left
[15:40] <DarkWolf84> ok, bb then

[15:41] *** DarkWolf84 left
[15:42] *** mkramer left
[15:43] *** mkramer joined
[15:43] *** molaf left
[15:47] <im2ee> Catalyst, Dancer or Mojolicious? :)

[15:47] <im2ee> Which is the best one?

[15:48] <flussence> I'd go with mojolicious, but I haven't used the middle one

[15:48] <masak> if I were to start a project today, I'd probably reach for Dancer.

[15:49] <masak> but I have nothing against the other two.

[15:49] <im2ee> masak, so why Dancer? :)

[15:49] <flussence> catalyst is like using a mountain to swat a fly

[15:49] <im2ee> I'm looking for the easiest one.. I won't spend a lot of time for web development. :)

[15:50] <masak> im2ee: Dancer seems very easy to get started with.

[15:50] <flussence> try.rakudo.org's frontend uses mojolicious, but it doesn't really do much with it besides render one page.

[15:51] <masak> Catalyst seems to be very capable and have a dedicated community. the Catalyst community is likely the biggest of the three.

[15:52] <im2ee> So, i probably will use Dancer. :)

[15:52] <flussence> use all of them at the same time!

[15:53] <im2ee> flussence, maybe i will. I must think it over. :)

[15:54] <flussence> .oO( hm, nobody's written an Acme::Cancerlicious yet )

[15:59] *** packetknife joined
[16:00] *** colomon joined
[16:01] * masak decommutes

[16:03] <felher> If i have a array of hashes like { value => X, name => Y }, is there a common idom to get the maximum hash compared by hash<value>?

[16:04] <moritz> felher: max :by({ $^a<value> <=> $^b<value> }), @hashes

[16:05] <[Coke]> oooh. my coworker bought me some spicy padam. mmmm.

[16:13] *** MayDaniel joined
[16:13] <PerlJam> Would a Perl 6 version of Dancer be called Prancer?  (and would that give the wrong impression? ;)

[16:14] <im2ee> PerlJam, why Prancer? :)

[16:15] <PerlJam> why not?

[16:15] <im2ee> ;)

[16:15] <PerlJam> im2ee: btw, since you were polling, Dancer++  :)

[16:16] <im2ee> So i will test it. :)

[16:16] <im2ee> karma Dancer

[16:16] <aloha> Dancer has karma of 1.

[16:16] <moritz> im2ee: Mojolicious++

[16:16] <im2ee> moritz, why? :)

[16:16] <im2ee> karma Mojolicious

[16:16] <aloha> Mojolicious has karma of 1.

[16:16] <im2ee> :)

[16:16] <im2ee> The same karma. :)

[16:17] <moritz> im2ee: because it works, and is fun

[16:17] <moritz> im2ee: and much easier to get started with than Catalyst

[16:17] <moritz> (ok, that's not too hard :-)

[16:17] <PerlJam> I've never used Mojolicious but from what I've read, it seems kind of like Catalyst re-imagined to be more like Dancer.

[16:17] <im2ee> moritz, have You ever been using Dancer? :)

[16:18] <_sri> mojolicious is more for people that love web development, not so much for those that just want to get away from it again as quick as possible (imo)

[16:18] <_sri> a key feature is real-time web apps

[16:18] <PerlJam> _sri: yeah, it seems to have that "fun" thing going for it :)

[16:18] <moritz> im2ee: no

[16:19] <moritz> im2ee: which is why I don't comment on it

[16:19] * PerlJam is hacking a Dancer app right now.

[16:20] <_sri> i personally consider mojolicious my catalyst2

[16:20] <im2ee> moritz, so.. i'll try both. :)

[16:20] <felher> moritz: Thnx, but thats what i tried first (well, i actually tried @hashes.max: { $^a<value> cmp $^b<value } ), but it seems that one of the first two values that getting compared is -Inf, and Num<value> doesn't work :)

[16:21] <moritz> felher: then try .sort({block}).[*-1]

[16:22] <_sri> but yea, you should love web development, or you won't appreciate either

[16:23] <felher> moritz: k, thnx :) My array is small enough so sort doesn't cost much, i guess :)

[16:23] *** wolfman2000 joined
[16:24] <colomon> #Phasers in 67?

[16:24] <PerlJam> _sri: what's a "real time web app" ?

[16:25] *** daniel-s left
[16:25] <_sri> PerlJam: http://en.wikipedia.org/wiki/Real-time_web

[16:26] <_sri> Comet/WebSockets

[16:27] <PerlJam> _sri: so, how does mojo support "real-time web" exactly?  Just that it's fast and unobtrusive?

[16:27] <slavik1> real time web = turning web browsers into thick clients ...

[16:27] <moritz> PerlJam: websocket support

[16:28] <[Coke]> (dancer,mojo,catalyst) I picked up mojo because of the screencasts, and it has been very very nice to me so far.

[16:28] <mberends> 2

[16:28] <PerlJam> [Coke]: I started watching them too, but I haven't done anything with Mojo yet.

[16:28] *** mkramer left
[16:29] <[Coke]> PerlJam: if you wish to play, see: https://github.com/coke/muddle and maybe commit some stuff. ;)

[16:29] <[Coke]> ugh, haven't touched it since 9/21.

[16:31] *** envi_ left
[16:32] <_sri> PerlJam: supporting Comet and WebSockets properly is really hard, our whole stack is non-blocking/evented

[16:32] <PerlJam> _sri: gotcha.  (now that I've read a little more :)

[16:33] *** envi_laptop joined
[16:38] <felher> nom: my @array = 1,2,3; @array = @array 

[16:38] <felher> problem known?

[16:38] <p6eval> nom ff78b5: OUTPUT«maximum recursion depth exceeded␤  in method infinite at src/gen/CORE.setting:4012␤  in method infinite at src/gen/CORE.setting:3710␤  in method infinite at src/gen/CORE.setting:4022␤  in method infinite at src/gen/CORE.setting:3710␤  in method infinite at src/gen/COR…

[16:40] *** alester left
[16:41] <[Coke]> felher: "doctor, it hurts when I do this!"

[16:41] <[Coke]> but yah, that's a bug.

[16:44] <felher> [Coke]: Sorry, i'm not sure i understand what you wanted to say with "doc..." :)

[16:46] *** daniel-s joined
[16:49] * moritz submits rakudobug

[16:51] <[Coke]> felher: man goes to the doctor, having hurt his arm in an accident. He shows the doctor, moving his arm, saying "doctor, it hurts when I do this!" the doctor says, "well, don't do that! next!"

[16:52] <felher> [Coke]: Ah, i see. Thnx for explaining :)

[16:53] * [Coke] overtells it. I think the original is just:

[16:53] <[Coke]> The patient says, "Doctor, it hurts when I do this." "Then don't do that!" 

[16:53] <[Coke]> (henny youngman)

[16:54] <huf> it's explained/documented in the jargon file :D

[16:55] * [Coke] finds a list of henny youngman jokes on the internet and is distracted.

[16:55] *** dakkar left
[16:56] <[Coke]> A man goes to a psychiatrist. "Nobody listens to me!" The doctor says, "Next!"

[16:57] <huf> "doctor, it hurts when i pee" "sir, there's a knot on your wiener" "oh damn, i forgot the bread!"

[16:57] <benabik> Bread?

[16:57] <huf> tying knots on your hankie is a way to remember to do things

[16:57] <huf> according to anecdotes

[16:58] <huf> i'll keep telling this joke until the world learns about this custom

[16:58] <huf> :D

[16:58] <benabik> ah

[16:59] <moritz> problem is, it doesn't tell you *what+ you have forgotten :-)

[16:59] <huf> moritz: well, the guy in the joke figured it out eventually :D

[17:00] <huf> jokes translate rather badly between even slightly different cultures :(

[17:01] <sjohnson> does Perl6 do a lot of the fancy IPC stuff?

[17:02] <flussence> I think the fanciest stuff we have is qx()...

[17:03] *** donri left
[17:03] *** nebuchadnezzar left
[17:10] <moritz> jnthn: regarding the optimizer, a shorthand for nqp::want(nqp::p6box_i(some_expression_returning_int), 'Ii', same_expression_returning_int) would really be nice

[17:10] <moritz> same for the Num/num case

[17:10] <masak> huf: similarly, it's more effective to remember how many pieces of luggage you're carrying on your travels, rather than which ones.

[17:11] <TimToady> With respect to genericity/specificity, most programmers have been taught either to be noun-dominant (OO) or verb-dominant (FP), but Perl 6 tries to keep both of those in different parts of its brain, just like you do.

[17:12] <huf> masak: i was told that's how to remember your shopping list

[17:12] <jnthn> moritz: Yeah, I did what I could with the things I had to hand. I don't find it ideal, I just don't know exactly what better looks like yet. :)

[17:12] <masak> huf: yeah. I do that too. sometimes I make mnemonics out of the shopping items, though.

[17:12] <TimToady> Much of the pushback on the design of Perl 6 has come from people who don't want to rethink their verbs vs nouns.

[17:12] <TimToady> see undef vs undef, for instance

[17:12] <huf> masak: i tend to list in a sea of fog, as far as memory is concerned

[17:12] <TimToady> of wantarray (verb) vs Parcel (noun)

[17:13] <TimToady> *or

[17:13] <moritz> jnthn: nqp::p6autobox_i(expression_returning_int) maybe?

[17:13] *** MayDaniel left
[17:13] <TimToady> or == as defined by nouns rather than by the language :)

[17:13] <masak> im2ee: thanks for starting the nice discussion on web frameworks. :)

[17:13] <jnthn> moritz: Yeah, I was trying to find a way that fits in with what map_node already does

[17:13] <jnthn> moritz: But maybe that's a less important goal.

[17:14] <masak> huf: huh! my mental space isn't foggy, it's a whiteboard. which is funny, since I prefer blackboards in meatspace. :)

[17:14] <moritz> jnthn: it could compilre rather directly to what we have now

[17:14] <jnthn> moritz: Yes, I could make it do so :)

[17:14] <masak> huf: but I usually make lists on my fingers, right hand first.

[17:15] <huf> masak: in kindergarten, i was convinced (for years) that each day was two because we had an afternoon nap in the middle

[17:15] <huf> not much has changed as far as my brain is concerned

[17:15] <moritz> jnthn: on a related matter, how much sense does it make to add native ops that return Bool?

[17:15] <moritz> jnthn: ie infix:<==> and the like

[17:15] <huf> masak: if it's not in my irclogs, it's mythical :D

[17:15] * diakopter backlogs to see why masak is @

[17:15] <pmichaud> good afternoon, #perl6

[17:15] <flussence> it's a halo

[17:15] <PerlJam> diakopter: he was feeling very #perl-like earlier

[17:15] <jnthn> pmichaud! \o/

[17:16] *** am0c joined
[17:16] <moritz> good pm, pm

[17:17] *** Chillance joined
[17:17] <masak> pmichaud! \o/

[17:18] <masak> diakopter: I lost my temper, so they gave me op.

[17:18] *** bluescreen10 left
[17:18] *** bluescreen10 joined
[17:19] <[Coke]> ho, pmichaud++

[17:19] <pmichaud> nom:  my &foo = /bcd/;   say 'abcdefg' ~~ /<&foo>/;

[17:19] <p6eval> nom ff78b5: OUTPUT«=> <bcd>␤␤»

[17:20] <moritz> nom: say so 'ab' ~~ /^.*b/

[17:20] <p6eval> nom ff78b5: OUTPUT«Bool::True␤»

[17:20] <moritz> nom: say so 'ab' ~~ /^(.*)b/

[17:20] <p6eval> nom ff78b5: OUTPUT«Bool::False␤»

[17:20] <moritz> that one

[17:22] *** rml left
[17:24] *** rml joined
[17:25] <diakopter> wow, several people got very huffy/defensive

[17:25] *** dark_x joined
[17:27] <masak> diakopter: "defensive" is the word you generally use when these discussions happen. it's not a word I would use. what do you mean by it?

[17:29] <im2ee> masak, all my pleasure. :)

[17:29] <im2ee> afk

[17:30] <moritz> #phasers time

[17:30] <TimToady> diakopter: I saw little huffy/defensive, but a great deal of frustration with the inability to communicate effectively

[17:31] <PerlJam> Yeah, more "annoyed" and "exasperated" and "irked"

[17:31] <GlitchMr> nom: print 

[17:31] <GlitchMr> 0􏿽xB2

[17:31] <p6eval> nom ff78b5:  ( no output )

[17:31] <GlitchMr> nom: print 0􏿽xB2

[17:31] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Confused at line 1, near "print 0\ufffd"␤»

[17:31] <GlitchMr> Accidental line break character

[17:32] <GlitchMr> \uf

[17:32] <GlitchMr> \uffd

[17:32] <GlitchMr> Yeah, it makes sense

[17:32] <GlitchMr> I have wrongly configured IRC client

[17:32] <GlitchMr> nom: print 0􏿽xB2

[17:32] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Confused at line 1, near "print 0\ufffd"␤»

[17:33] *** GlitchMr left
[17:33] <diakopter> TimToady: ok

[17:35] <TimToady> myself, the discussion both here and and on #parrot led me to muse about nouns and verbs, and how hardwired they get in our brains.  :)

[17:35] <masak> ooh, there was a discussion on #parrot?

[17:36] <pmichaud> ...I missed a discussion?  There was one that I didn't instigate/throw gasoline upon?  ;-)

[17:36] <TimToady> about the meaning of ==

[17:36] <TimToady> it was just a small conflagration :)

[17:36] <masak> :P

[17:36] <diakopter> masak: I guess I meant that I saw people taking [their understandings of] Woodi's questions/statements personally, as if they thought Woodi was trying to make assertions/claims that he doesn't deserve to make.. so I interpreted folks' responses as trying to defend their views that Woodi has no right to make such assertions/claims

[17:36] *** bluescreen10 left
[17:37] <masak> diakopter: ooh, that *is* a good use of the word.

[17:37] <masak> diakopter: as for me, you're right in the sense that I let it get to me.

[17:38] <TimToady> otoh, observing that the path to understanding proceed through the step of understanding that you don't understand is not entirely a defensive notion :)

[17:38] <TimToady> *ceeds

[17:38] <masak> diakopter: but it wasn't so much "doesn't deserve to make" as "ok, how do I get this guy's attention?"

[17:39] <PerlJam> masak: and  then you turned into mst for a brief moment  :)

[17:39] <masak> next time, if there's a next time, I won't call the person a moron, but the act.

[17:39] <masak> having read mst's post more closely, that seems to be what he does.

[17:39] <masak> which makes a lot of sense.

[17:39] *** ashleydev joined
[17:40] *** nebuchadnezzar joined
[17:40] <masak> PerlJam: well it was half experiment and half venting of frustration.

[17:40] <PerlJam> yes, and ad hominem statements tend to escalate any ... misunderstandings  rather than quell the situation.

[17:40] <masak> nod.

[17:40] *** bluescreen10 joined
[17:40] <masak> to Woodi++'s credit, he took it well (partly because he was away making tea).

[17:41] <TimToady> it did appear that the person in question does (did?) not yet understand the extent to which he does not understand...

[17:42] <TimToady> but we all have areas where we're like that...

[17:43] <masak> TimToady: not sure I understand... :)

[17:43] <diakopter> masak: did you say something?

[17:43] * masak .oO( Meta-Dunning-Kruger )

[17:49] *** MayDaniel joined
[17:49] <masak> though Dunning-Kruger is pretty meta already.

[17:49] <dalek> rakudo/optimizer: ad8f64a | moritz++ | src/core/Int.pm:

[17:49] <dalek> rakudo/optimizer: more native int ops

[17:49] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/ad8f64a571

[17:49] <masak> at least as far as I understand it :)

[17:56] *** bluescreen10 left
[17:59] *** daniel-s left
[18:05] *** MayDaniel left
[18:06] <Woodi> i think i was scared about USABILITY eg. forcing ppls to choose what undefined type they should return; but probably others answered to perl5-undef-implementation versus perl6-undefs-idea-refactoring... i must agree i should not be allowed to talk about second...

[18:07] <Woodi> but about versus vs nount - perl5 undef is (probably) both...

[18:10] <TimToady> we might not have chosen to detangle the verb from the noun, except that Perl 6 has to be much pickier about whether the next thing is a term or not, and we aren't allowed to guess about that, as Perl 5 does

[18:11] *** bluescreen10 joined
[18:12] <TimToady> in order to be extensible, Perl 6 relies much more heavily on catching two-terms-in-a-row errors

[18:12] <TimToady> and ambiguous verbs/nouns tend to defeat that

[18:14] <TimToady> taking that together with the fact that there are many different ways of being undefined, there really wasn't much point in keeping undef

[18:15] <TimToady> as for the panic, we've had a saying from the start of Perl 6, which is that "Everyone is allowed to panic, once."

[18:15] <TimToady> :)

[18:16] <TimToady> interestingly, masak++ is one of the chief violators of that rule, but we keep him around anyway for the entertainment value.  :)

[18:17] <masak> I was wondering about my panic count at this point.

[18:17] <tadzik> he still has something twisted before on his head

[18:18] <Woodi> TimToady: but i still have problem with 'return;' returning something undefined. what if before that $_ have some defined value ?

[18:18] <TimToady> return as nothing to do with $_ in either Perl 5 or Perl 6, so I don't understand your question.

[18:19] <TimToady> s/as/has/

[18:19] <Woodi> 'return undef' was 'scripting language trick'

[18:19] <Woodi> i assume: if no walue then $_ is used. maybe i am wrong

[18:20] <PerlJam> Woodi: you are (wrong).

[18:20] <TimToady> you've made a false generalization about Perl 5

[18:20] <TimToady> only certain functions default to $_

[18:20] <TimToady> return is not one of them

[18:20] <Woodi> ok

[18:20] <TimToady> we decided that having to memorize a list was bad

[18:20] <TimToady> so in Perl 6, *no* functions default to $_

[18:21] <TimToady> you can use an invocant-less method if you like, though

[18:21] <Woodi> then how [$@%]_ work ? 

[18:21] <masak> nom: sub defsay(*@a) { if @a { say @a } else { say $_ } }; $_ = 42; defsay

[18:21] <p6eval> nom ff78b5: OUTPUT«Any()␤»

[18:21] <tadzik> zing!

[18:21] <masak> hm... $_ not dynamic...

[18:22] <PerlJam> Woodi: what do you mean?

[18:23] *** replore left
[18:23] <TimToady> there are still some special syntactic constructs that default to $_

[18:23] <TimToady> such as, .foo means $_.foo

[18:23] <TimToady> and 'when' implicitly smartmatches against $_

[18:23] <TimToady> and s/// still works on $_ by default

[18:24] <TimToady> but mostly, those variables are considered special self-declaring parameters now

[18:24] <masak> rakudo: $_ = 42; .++; .say

[18:24] <p6eval> rakudo ff78b5: OUTPUT«===SORRY!===␤Method 'unshift' not found for invocant of class 'Undef'␤»

[18:24] <masak> hah!

[18:24] * masak submits rakudobug

[18:24] <masak> b: $_ = 42; .++; .say

[18:24] <Woodi> ok

[18:24] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Method 'unshift' not found for invocant of class 'Undef'␤»

[18:24] <jnthn> masak: already ticketed, I think :)

[18:25] <masak> curses! I probably beat myself to it!

[18:25] <TimToady> I think I asked about .++ last week, in fact

[18:25] <masak> oh yeah

[18:25] *** kaare_ joined
[18:26] <TimToady> Woodi: so constructs that hardwire $_ in Perl 5 don't necessarily have to do that in Perl 6; for instance, when you say grep { $_ eq 'foo' }

[18:26] <TimToady> in Perl 5, it's a special syntax that finds a block and forces $_ to be a kind of loop parameter

[18:27] <TimToady> in Perl 6, it's just an anonymous function that is the first argument to grep

[18:27] <TimToady> and when you write { $_ eq 'foo' } it's as if you'd said sub ($_) { $_ eq 'foo' }

[18:28] <Woodi> so $_ is now near plain variable...

[18:28] <PerlJam> Woodi: same with @_ and %_

[18:29] <Woodi> ok, memoized i think

[18:30] <PerlJam> Woodi: Perl 6 is simultaneously less magical and more magical than Perl 5.  :)

[18:30] *** envi_laptop left
[18:31] <Woodi> PerlJam: oh yes, sometimes i think Perl6 is to compressed by Huffman method :)

[18:32] <TimToady> that is one design principle out of many, but we do use it from time to time

[18:32] <masak> any program or language can be ruined by taking a good thing to extremes.

[18:32] <PerlJam> masak: look at lisp!  :)

[18:32] <dalek> rakudo/optimizer: b6c5071 | moritz++ | src/core/Num.pm:

[18:32] <dalek> rakudo/optimizer: native num trig ops

[18:32] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b6c5071970

[18:32] <dalek> rakudo/optimizer: e19f726 | moritz++ | src/core/Num.pm:

[18:32] <dalek> rakudo/optimizer: more num builtins, including log() and the rest of the trig functions

[18:32] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/e19f7262a2

[18:33] <masak> PerlJam: hey, careful. do not upset the big-bearded ancestors!

[18:34] <Woodi> TimToady: i worry that so many new features can scary a lot of users... but if someone dig that he/she drown :)

[18:36] <PerlJam> Woodi: Similar to how you can program in Perl using metaphorical baby-talk, you can pick up the "new features" piece-meal so that they aren't so onerus.

[18:36] <TimToady> keeping new users from drowning in too much detail is also one of our design principles

[18:37] <TimToady> but it's all tradeoffs

[18:37] <TimToady> there's no such thing as a perfect language

[18:37] <masak> awww

[18:37] <TimToady> and that's the fault of the waterbed theory, which is another design principle

[18:37] <PerlJam> TimToady: context is king!  Perfect for what purpose?  :)

[18:38] <TimToady> the waterbed theory is actually implicit in huffman coding, since you can only make some things easier by making other things harder

[18:39] <Woodi> PerlJam: in Perl context the usual context is UNIX admins scripting (<6)...

[18:39] <tadzik> I won't be so sure

[18:39] <TimToady> another design principle in Perl 6 is that there are always *many* contexts, often with conflicting goals

[18:40] <PerlJam> Woodi: maybe.  There are lots of perl-based web apps out there.

[18:40] <PerlJam> Woodi: And I primarily use perl at work for data processing and number crunching stuff (with PDL)

[18:41] <masak> Woodi: at $dayjob, it's web apps all the way. not so much UNIX admins as everything admins. :)

[18:41] <TimToady> even for a single piece of software, the users, designers, programmers, marketers, and administrators can have profoundly conflicting goals.

[18:42] <Woodi> TimToady: i have one dream... High Performance Perl...

[18:43] <TimToady> Perl 6 is much likelier to get there than Perl 5 ever could be

[18:43] <flussence> .oO( never had speed issues running frozen-bubble on my pentium 2... )

[18:44] <TimToady> but high performance depends on good optimizers, and good optimizers depend on knowing a lot about your program

[18:44] <masak> you make it sound so easy ;)

[18:44] <flussence> but if someone implements perl6 on top of LLVM or the like, then it becomes Someone Else's Problem :)

[18:45] <TimToady> so an optimizable language makes many distinctions, which worries Certain People

[18:47] <TimToady> flussence: as we have seen already, if the VM in question doesn't know what to do with the distinctions provided by the language, not much optimization can happen ;)

[18:47] *** bluescreen10 left
[18:48] <masak> that's the challenge of optimization: it cuts through all layers of the stack.

[18:48] <masak> a few other things do that too. DESTROY submethods among them. we don't have those either.

[18:48] <PerlJam> It would be interesting if Perl could do some type-inference and tell you when you've used an object in a slot with an incompatible type

[18:48] <jnthn> Well, I see it more as being able to pass sufficient information down the stack.

[18:48] <TimToady> and why the impedance mismatch with the parrot model was such a killer

[18:48] <jnthn> PerlJam: It's on my todo list for optimizer.

[18:50] <TimToady> anyway, all that <waves hands upward> is another design principle

[18:50] <TimToady> we've got 'em coming and going

[18:50] *** birdwindupbird joined
[18:50] <Woodi> i would like that one day marketing ppls will go down to admins and say: we want you use Perl in next app becouse we do not want spend money on new servers but we want new projects perform better on old servers :)

[18:50] *** birdwindupbird left
[18:52] <PerlJam> Woodi: I don't think that marketing people care about new servers or not :)

[18:53] <Woodi> PerlJam: they do... it is pain for them - how to buy as small amount as possible :)

[18:55] *** skangas left
[18:58] *** GlitchMr joined
[18:58] <Woodi> ah, right, management ppls

[19:00] *** bluescreen10 joined
[19:00] <im2ee> re

[19:00] <moritz> jnthn: fwiw, nom merged into optimizer runs mandelbrot-color in 37.8s

[19:00] <jnthn> ooh, we broke 40s \o/

[19:01] <jnthn> moritz: Is that unmodified mandelbrot-color?

[19:01] <moritz> jnthn: yes

[19:01] <jnthn> moritz: e.g. no extra type info added?

[19:01] <jnthn> moritz: OK :)

[19:01] <jnthn> nom: say (16 * 60 + 14) / 37.8

[19:01] <p6eval> nom ff78b5: OUTPUT«25.7671957671958␤»

[19:02] <jnthn> Something of a speedup. Still plenty of work to go :)

[19:02] <moritz> 27.6s with additional type info

[19:02] <jnthn> Wow. :)

[19:03] <jnthn> Living the gradual typing dream :)

[19:03] <jnthn> ...well, not quite yet. :)

[19:03] <Woodi> so if i talk so much today then two more sentence do not change to much i think :) so: Simple::Redis can store now keys, hashes and list; to be found in: https://github.com/slunski/perl6-simple-redis

[19:03] <moritz> nom: sub f(int $x) { $x = $x + 1}; my int $x = 10; f($x); say $x

[19:03] <p6eval> nom ff78b5: OUTPUT«10␤»

[19:04] <Woodi> gratulation Perl6 magicans :)

[19:04] <moritz> jnthn: there's probably no good way to make ++ work on native ints, is there?

[19:04] <Woodi> and gn and gl #perl6

[19:04] <jnthn> moritz: I suspect we have to make native int rw params work somehow.

[19:05] <jnthn> moritz: It's non-trivial and I need to fathom how to do it in a way that optimizes down nicely.

[19:05] <jnthn> moritz: So, ENOTYET.

[19:05] <jnthn> But I really don't think telling people they can't ++ an int is going to fly.

[19:05] <moritz> jnthn: any objections to me pushing the merging of nom into optimizer?

[19:06] <jnthn> moritz: Go ahead.

[19:06] <TimToady> C can ++ an int, so can we...someday...

[19:07] <moritz> well, it could be macro-ish

[19:07] <dalek> rakudo/optimizer: 2146e92 | moritz++ | / (14 files):

[19:07] <dalek> rakudo/optimizer: Merge branch 'nom' into optimizer

[19:07] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/2146e92546

[19:09] <jnthn> Well, inlining practically is about turning a sub into a macro :)

[19:09] <TimToady> it does imply understanding the nativeness of references though

[19:09] <jnthn> TimToady: yes, that's what makes it a bit tricky :)

[19:10] <TimToady> and how type information on a native variable is carried by its context

[19:10] <TimToady> not by the variable itself

[19:10] <moritz> jnthn: fwiw https://gist.github.com/1265348 doesn't seem to inline the call to &fancy, even though there's log(num) multi now

[19:10] <jnthn> Well, that's what makes me not so scared of native references. 

[19:10] <moritz> jnthn: not sure if that's expected or not

[19:11] <jnthn> moritz: It won't inline things with sub calls in just yet.

[19:11] <jnthn> moritz: That needs some special care.

[19:11] <jnthn> The optimizer todo list is....long :)

[19:12] <moritz> and even weireder, the call is

[19:12] <moritz> $N100 = "&fancy"($P103)

[19:12] <moritz> I would have expected it pass a num register to &fancy

[19:12] <jnthn> Should be possible too.

[19:12] <diakopter> TimToady: since I've moved to California, I've notied people have stopped using linking verbs, definite article, and sentence subjects, and not just in IRC/IM/emails, speech also.  Is this a California/SiValley thing or global or what?

[19:12] * moritz expects full awesomeness :-)

[19:13] <jnthn> moritz: That's where I'm aiming :)

[19:13] <jnthn> Rome wasn't built in a day :)

[19:14] <diakopter> or 11 years

[19:14] <jnthn> :P

[19:14] <jnthn> ooh, it's stopped raining...I should visit the store and get something to eat for supper

[19:14] <moritz> rome wasn't built in software either :-)

[19:14] <jnthn> bbs

[19:16] <diakopter> TimToady: is it just that any word that could possibly be left out unambiguously is left out, regardless of convention?

[19:18] <TimToady> I would have to see some examples in situ, but I would hazard a guess that in such cases redundancy is provided out-of-band, or by protocol

[19:19] <TimToady> you can't have effective human communication without some redundancy or error correction mechanism

[19:19] <TimToady> so arguably, what we could be seeing is people not caring whether they communicate effectively :)

[19:20] <TimToady> you could also be seeing spillover from people's native tongues

[19:20] <TimToady> not many languages have definite articles, for instance

[19:20] <diakopter> from $work irc:   bruce: non symlink versioning live in production!  # implied "is now"

[19:21] <benabik> …  symlink based versioning?

[19:21] <TimToady> many languages omit "is" where it's obvious, such as classical greek

[19:22] <TimToady> but I'd also argue that the ! has some aspectual, er, aspect to it

[19:22] <TimToady> something like "anything surprising is by definition new information"

[19:22] <TimToady> so that takes care of the "now"

[19:23] <diakopter> PersonA: Existing project works for me.  # implied "An"

[19:23] <TimToady> indefinite articles are even rarer in human languages

[19:24] <diakopter> PersonB: ok works on whatever server i'm on  # implied "it"

[19:24] <diakopter> it might be my company culture (to which I'm just not as accustomed as I might be) :/

[19:25] <TimToady> there's a long tradition, largely unrecognized by grammar nazis, of leaving the subject out in English when it's obvious

[19:25] <TimToady> "gotta run"

[19:25] <TimToady> "sure is dark in here!"

[19:26] <TimToady> "don't get no satisfaction"

[19:26] <colomon> TimToady: Don't know what you are talking about

[19:26] <masak> diakopter: I find those utterances terse but not surprisingly so.

[19:26] <colomon> ;)

[19:27] <TimToady> "works for me"

[19:27] <diakopter> have to lunch & ;)

[19:28] *** mberends left
[19:28] <masak> articles are nice to have in a language but are by no means necessary.

[19:28] <masak> their use is much more complicated than first meets the eye.

[19:29] <TimToady> s/ a /

[19:29] <TimToady> not to mention /

[19:31] <masak> :)

[19:31] *** MayDaniel joined
[19:36] <TimToady> diakopter: note also the 1st/2nd person vs 3rd person distinction is partially carried by whether the verb has an 's' on it

[19:37] <TimToady> "works for me" vs "work for me"

[19:37] *** bluescreen100 joined
[19:37] <TimToady> the latter can be either 1st or 2nd person depending on the question it's answering

[19:38] <TimToady> "What do you do for a living?" "Work for me."

[19:38] <TimToady> "What do you want me to do?"  "Work for me."

[19:38] *** MayDaniel left
[19:39] <TimToady> when you say "work for me" to mean "work for myself" is also a fascinating linguistic topic.

[19:40] <TimToady> why is it "I've gotta be me!" and not "I've gotta be myself!" ?

[19:40] <diakopter> or "I've gotta be I"

[19:41] <TimToady> fake latin doesn't impress me :)

[19:41] <diakopter> I thought I was going to lunch

[19:41] <jnthn> Curious. "Work for me" sounds really odd to my ears; I'd expect it to be "Work for myself"

[19:41] <TimToady> didn't say you had to go

[19:42] <TimToady> it's a mechanism for treating yourself as some other person, pragmatically speaking

[19:43] <TimToady> linguistic multiple personalities

[19:44] <TimToady> not just "me"

[19:44] <TimToady> "Just look at you!"

[19:44] <TimToady> why isn't it "youreself"?

[19:44] <TimToady> s/e//

[19:44] <moritz> in German we're much more picky about such reflexive forms

[19:44] <TimToady> s/ about.*//  :)

[19:44] <moritz> :-)

[19:45] <moritz> though some of us are abolishing the Genetive, which is a realy pity

[19:46] <TimToady> well, English is slowly losing the subjunctive, and "whom"

[19:47] <masak> genitive*

[19:47] <TimToady> the past is unevenly distributed too

[19:47] <masak> from 'gignere', 'to beget'.

[19:48] <masak> heh, sometimes Latin looks like ancient Italian :P

[19:52] * [Coke] wishes his phone would stop reminding him about the sixperl call.

[19:53] <masak> those still happen?

[19:54] *** MayDaniel joined
[19:56] <TimToady> I would not infer that, were I you.

[19:57] <masak> I see.

[19:58] <masak> I now feel fairly confident in inferring that TimToady no longer participates in sixperl calls :P

[19:59] <PerlJam> They could spontaneously start again ...  :)

[19:59] * moritz calls "sixperl"

[19:59] <diakopter> #phasers is more fun

[19:59] <moritz> there you go, spontanesous sixperl call

[19:59] * masak groans

[20:00] <masak> nom: say "spontaneous ", <one two three four five six>.roll, "perl call"

[20:00] <p6eval> nom ff78b5: OUTPUT«spontaneous fourperl call␤»

[20:00] <TimToady> Refrigerator!

[20:01] <[Coke]> eek.

[20:01] <m6locks> nice

[20:01] <[Coke]> bananaphone call.

[20:01] <masak> maybe I should've {}'d inward, rather than "-ing outward.

[20:02] <masak> nom: say "ba", "na" x 2, "phone call"

[20:02] <p6eval> nom ff78b5: OUTPUT«bananaphone call␤»

[20:03] <masak> nom: say "ba{"na" x 2}phone call"

[20:03] <p6eval> nom ff78b5: OUTPUT«bananaphone call␤»

[20:03] * masak finally embraces {} in qq strings as something he likes :)

[20:03] <masak> TimToady++

[20:04] <sjohnson> nom: say ("ring" X 7).join("-"), "... banana phone!"

[20:04] <p6eval> nom ff78b5: OUTPUT«ring-7... banana phone!␤»

[20:04] <sjohnson> nom: say ("ring" x 7).join("-"), "... banana phone!"

[20:04] <p6eval> nom ff78b5: OUTPUT«ringringringringringringring... banana phone!␤»

[20:04] <masak> sjohnson: 'x' is string rep, 'xx' is list rep.

[20:04] <sjohnson> nom: say ("ring" xx 7).join("-"), "... banana phone!"

[20:04] <p6eval> nom ff78b5: OUTPUT«ring-ring-ring-ring-ring-ring-ring... banana phone!␤»

[20:04] <sjohnson> masak++

[20:05] <benabik> nom: say "{join ('ring' xx 7): '-'}… ba{'na' x2}phone!"

[20:05] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[20:06] <benabik> nom: say "{('ring' xx 7).join('-')}… ba{'na' x2}phone!"

[20:06] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[20:06] <benabik> Ah well.

[20:06] <masak> benabik: 'x 2', not 'x2'

[20:06] <masak> STD has a better error message.

[20:06] <benabik> nom: say "{join ('ring' xx 7): '-'}… ba{'na' x 2}phone!"

[20:06] <p6eval> nom ff78b5: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[20:06] <masak> aww :/

[20:07] <benabik> std: say "{join ('ring' xx 7): '-'}… ba{'na' x 2}phone!"

[20:07] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 123m␤»

[20:07] <tadzik> hehe

[20:07] <masak> I'm not sure Rakudo supports indirect methods.

[20:07] <tadzik> way better

[20:07] <sjohnson> （　｀ー´）

[20:07] <benabik> nom: say "{('ring' xx 7).join('-')}… ba{'na' x 2}phone!"

[20:07] <p6eval> nom ff78b5: OUTPUT«ring-ring-ring-ring-ring-ring-ring… bananaphone!␤»

[20:07] <masak> \o/

[20:07] <benabik> masak++

[20:07] <masak> b: say "{join ('ring' xx 7): '-'}… ba{'na' x 2}phone!"

[20:07] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[20:07] *** kmwallio left
[20:07] <masak> b didn't either.

[20:08] <moritz> nom and b mostly parse the same

[20:08] <masak> niecza: say join ('ring' xx 7): '-'

[20:08] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«===SORRY!===␤␤Invocant handling is NYI at /tmp/PTv0Ncv1UF line 1 (EOF):␤------> say join ('ring' xx 7): '-'⏏<EOL>␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ …

[20:08] <masak> awww.

[20:08] <moritz> niecza++

[20:08] <masak> but... who will implement it FIRST? :D

[20:08] <tadzik> YAPSI!

[20:08] *** y3llow left
[20:08] <masak> well, Yapsi doesn't to methods yet...

[20:09] *** pothos left
[20:09] <tadzik> nom: my @a = "hip" xx 2; say ~(@a, @a.WHAT.perl), "!"

[20:09] <masak> nor classes and objects in general...

[20:09] <p6eval> nom ff78b5: OUTPUT«hip hip Array!␤»

[20:09] <masak> lol

[20:09] <masak> I had forgotten about that one ;)

[20:10] <tadzik> you forget about it the second time, and for the second time I'm here to remind you that it's your invention :P

[20:10] <diakopter> niecza: say: say 4; goto say; # TimToady why isn't say allowed as a label

[20:10] *** y3llow joined
[20:10] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«===SORRY!===␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/G9CQevIUQU line 1:␤------> say: say⏏ 4; goto say; # TimToady why isn't say a␤␤Two t…

[20:10] <masak> tadzik: well, this time I (vaguely) remembered that I had originated it :)

[20:10] *** pothos_ joined
[20:10] <tadzik> ;)

[20:11] *** pothos_ is now known as pothos

[20:11] *** mj41 joined
[20:12] *** y3llow left
[20:12] *** packetknife left
[20:13] <dalek> rakudo/optimizer: 5b40d01 | moritz++ | src/core/ (4 files):

[20:13] <dalek> rakudo/optimizer: use native types in the setting a bit more

[20:13] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/5b40d01462

[20:13] *** y3llow joined
[20:13] *** GlitchMr left
[20:13] *** pothos left
[20:13] *** pothos_ joined
[20:14] *** pothos_ is now known as pothos

[20:14] <flussence> nom: say ('ring' X '-' xx 6, '… bananaphone!').join

[20:14] <p6eval> nom ff78b5: OUTPUT«ring-ring-ring-ring-ring-ring-ring… bananaphone!␤»

[20:14] *** wamba left
[20:15] *** y3llow left
[20:15] *** y3llow joined
[20:16] <masak> nom: given {}.^name -> $_ is copy { .=uc; .=subst('H', 'M'); $_ = .comb.join(' * '); .say }

[20:16] <p6eval> nom ff78b5: OUTPUT«M * A * S * H␤»

[20:17] <flussence> nom: print 'ring' X '-' xx 6, '… bananaphone!' # shorter

[20:17] <masak> tadzik: new one ;)

[20:17] <p6eval> nom ff78b5: OUTPUT«ring-ring-ring-ring-ring-ring-ring… bananaphone!»

[20:17] <tadzik> masak: haha, nice :)

[20:17] <masak> TimToady: sometimes I'm wondering if .=rhs shouldn't be a macro instead, expanding to $_.=rhs, with rhs possibly being several chained method calls; see above.

[20:18] *** mattp_ left
[20:18] <flussence> I want a call-a-bunch-of-methods shorthand like ». is for variables...

[20:19] <tadzik> given?

[20:19] <tadzik> I don't think I understand

[20:19] <tadzik> oh, i think I understand

[20:20] <flussence> you can write ($a, $b, $c)».foo, but not $a.«(<foo bar etc>)

[20:20] *** mattp_ joined
[20:20] <masak> flussence: a bit worrying that in your proposed syntax, the method names are strings...

[20:20] <flussence> yeah, not sure about the details.

[20:21] <masak> std: my $a; $a.«(<foo bar etc>)

[20:21] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unable to parse quote-words subscript; couldn't find right double-angle quote at /tmp/v4Lx0OvsVs line 1 (EOF):␤------> my $a; $a.«(<foo bar etc>)⏏<EOL>␤Parse failed␤FAILED 00:01 120m␤»

[20:21] <masak> std: my $a; $a«.(<foo bar etc>)

[20:21] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unable to parse quote-words subscript; couldn't find right double-angle quote at /tmp/3WegW9TvCg line 1 (EOF):␤------> my $a; $a«.(<foo bar etc>)⏏<EOL>␤Parse failed␤FAILED 00:01 120m␤»

[20:21] <sorear> good * #perl6

[20:21] <phenny> sorear: 13:13Z <[Coke]> tell sorear that when I fudge roast for niecza, he should definitely check to make sure he's happy with the new tests.

[20:22] <flussence> and both of them look like the start of a hash subscript...

[20:22] <masak> hola, sorear 

[20:25] <sjohnson> nom: "efbc88e38080efbd80e383bcc2b4efbc890a".pack("H*").print

[20:25] <p6eval> nom ff78b5: OUTPUT«Method 'pack' not found for invocant of class 'Str'␤  in block <anon> at /tmp/cL0ao0RmEu:1␤  in <anon> at /tmp/cL0ao0RmEu:1␤»

[20:26] <masak> I'll get to it, I promise :)

[20:26] <masak> but even then, you'd have problems with the Str/Buf distinction above.

[20:27] <masak> I can never quite remember which way without looking...

[20:27] <flussence> nom: my $a = 1; {.sin, .cos, .tan}».map({$a.$_})

[20:27] <p6eval> nom ff78b5:  ( no output )

[20:27] <flussence> oh wait

[20:27] <flussence> nom: my $a = 1; say {.sin, .cos, .tan}».map({$a.$_})

[20:27] <p6eval> nom ff78b5: OUTPUT«0.841470984807897 0.54030230586814 1.5574077246549␤»

[20:27] <sorear> backlog complete

[20:27] <sorear> masak: you can take your hat off now.

[20:27] <flussence> it's close, but backwards and messy

[20:28] <sjohnson> what's the pack equivalent in perl 6?

[20:28] <sorear> diakopter: in 'say: say 5', say IS allowed as a label, but it effectively shadows CORE::say

[20:29] <sorear> niecza: say: &say(4); goto say; # using &say explicitly disambiguates

[20:29] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«===SORRY!===␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/wFcMxL_aNS line 1:␤------> say: &say(4); goto say⏏; # using &say explicitly disambiguat…

[20:29] <flussence> std: goto 'say'

[20:29] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 120m␤»

[20:29] <sorear> niecza: say: &say(4); goto 'say'; # using &say explicitly disambiguates

[20:29] <tadzik> sjohnson: it's "pack", but NYI in nom

[20:29] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«(timeout)4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4􏿽xE2􏿽x90

[20:29] <sjohnson> o

[20:29] <tadzik> b: "efbc88e38080efbd80e383bcc2b4efbc890a".pack("H*").print

[20:29] <p6eval> b 1b7dd1: OUTPUT«Method 'pack' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/bIFCI1d64Y␤»

[20:29] <masak> sorear: seems I'm not authorized to take my hat off. moritz op'd me.

[20:30] <tadzik> eek

[20:30] <sorear> niecza: say: CORE::say 4; goto 'say'; # this works too diakopter 

[20:30] <flussence> std: 10: print "HELLO WORLD\n"; 20: goto 10

[20:30] <sorear> masak: /mode #perl6 -o masak ?

[20:30] <p6eval> niecza v10-38-g23f1b2e: OUTPUT«(timeout)4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4␤4􏿽xE2􏿽x90

[20:30] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Illegal use of colon as invocant marker at /tmp/ZVkIMA2_Lw line 1:␤------> 10:⏏ print "HELLO WORLD\n"; 20: goto 10␤Check failed␤FAILED 00:01 122m␤»

[20:30] *** MayDaniel left
[20:30] *** masak sets mode: -o masak

[20:30] <tadzik> :)

[20:30] <masak> ooh :)

[20:30] <PerlJam> flussence: remember, all's fair if you predeclare.  you didn't first load  BASIC::Grammar  :)

[20:31] <masak> sorear++

[20:31] *** phenny left
[20:31] *** mj41 left
[20:31] <sorear> masak: what were you trying?

[20:32] <sorear> masak: btw, I just gave you a chanserv can-use-the-op-command bit

[20:32] <masak> thanks.

[20:32] <masak> I was trying /msg Chanserv deop #perl6 masak

[20:32] <moritz> /msg chanserv op #perl6

[20:32] <moritz> is the magical incantation then

[20:32] <moritz> and you can deop yourself

[20:32] <masak> not with ChanServ I couldn't...

[20:33] <moritz> well, with 'yourself' I meant /deop masak :-)

[20:33] <masak> ok :)

[20:34] <sorear> pm, moritz, and I are the metaops here.

[20:34] <sjohnson> rakudo: "efbc88e38080efbd80e383bcc2b4efbc89".pack("H*").print

[20:34] <p6eval> rakudo ff78b5: OUTPUT«Method 'pack' not found for invocant of class 'Str'␤  in block <anon> at /tmp/nPy85Y4V11:1␤  in <anon> at /tmp/nPy85Y4V11:1␤»

[20:35] <sjohnson> i guess since nom won't do it, i shouldn't have bothered with that.  oops!

[20:35] <masak> sjohnson: .pack would be a method on List/Parcel, but I guess there could be a delegator on Cool as well.

[20:35] <tadzik> time for fat-face-with-open-eyes! :)

[20:35] *** wolfman2000 left
[20:35] <sjohnson> （　° ー°）

[20:35] <tadzik> :D

[20:36] <tadzik> I have to copypaste those somewhere

[20:36] <sjohnson> The fatface monologues

[20:36] <masak> lol

[20:38] <flussence> this talk of .pack reminded me of a thing I wanted to do but never got around to... https://gist.github.com/1186468

[20:38] <sorear> 11:23 < masak> sorear: how far along are you with the /serialization branch?

[20:39] <sorear> I'd say I'm around half done; probably a bit more than half when it comes to hard stuff, a bit less for yakshavy bits

[20:39] <sorear> ETA 1-2 weeks, depending on tuit availability

[20:39] <sorear> 11:23 < masak> sorear: and what will it mean, exactly, when it lands?

[20:40] <moritz> instant world domination

[20:40] <moritz> proper role composition

[20:40] <masak> as if Niecza needed more of that... :P

[20:40] <masak> world domination, I mean.

[20:40] <moritz> it does

[20:40] <im2ee> Good night! :)

[20:41] <masak> 'branoc!

[20:41] <sorear> the immediate effects will be slower compilation, slightly faster startup, and more availability of metastuff at runtime

[20:41] <sorear> post-merge, I'll tackle roles and BEGIN, both of which are clearly blocking on this

[20:41] <masak> *nod*

[20:41] <masak> why are roles blocking on it?

[20:42] <sorear> because I don't want to implement role composition twice

[20:42] <sorear> we need the ability to compose roles at compile time and at runtime

[20:42] <sorear> in niecza/master, those are two completely different metamodels

[20:45] <moritz> I've just did an experiment; I tried to think of all the corner cases of the &min function, and implement it

[20:45] <moritz> https://gist.github.com/1265646

[20:45] <moritz> looks surprisingly lengthy/complex -- is there anything I can significantly simplify?

[20:45] *** hamza joined
[20:46] <masak> # FIRST next;

[20:46] <masak> nice!

[20:47] <masak> moritz++ # idiom discovery

[20:47] <tadzik> what does it do?

[20:47] <tadzik> besides "nothing, it's commented out"?

[20:48] <tadzik> like "start from the second iteration"?

[20:48] <moritz> tadzik: skip the first iteration, if not commented out

[20:48] <moritz> right

[20:48] <sorear> moritz: don't you also need special cases for handling Ranges?

[20:48] <moritz> sorear: care to elaborate?

[20:49] <sorear> I vaguely thought min was overloaded to do interval operations

[20:49] *** phenny joined
[20:49] <masak> moritz: you don't need the trinary at L15 if you just assign -Int at L5.

[20:49] <masak> er, -Inf.

[20:49] <masak> perl6: say -Int

[20:49] <p6eval> rakudo ff78b5: OUTPUT«Cannot unbox type object to a native integer␤  in sub prefix:<-> at src/gen/CORE.setting:2259␤  in block <anon> at /tmp/trrLYZoBzd:1␤  in <anon> at /tmp/trrLYZoBzd:1␤»

[20:49] <p6eval> ..pugs, niecza v10-38-g23f1b2e: OUTPUT«0␤»

[20:49] <moritz> sorear: minmax does some weird Range stuff, but I'm not aware of any in min

[20:49] * masak submits rakudobug

[20:49] <sorear> moritz: you can combine the two clauses if you allow both a $comparer and a $transformer

[20:51] <masak> it would be good to have it be one code path, not two similar-ish ones.

[20:51] *** im2ee left
[20:51] <moritz> sorear: you're right; separating the loops is probably premature optimization

[20:51] *** hamza left
[20:52] <sorear> moritz: if you really want to deoptimize, &cmp = { &by($^a) cmp &by($^b) }

[20:53] <sorear> and what's the &by.arity == 0 case good for?

[20:53] <moritz> sorear: :by(&rand)

[20:53] <sorear> there is no &rand

[20:53] <PerlJam> moritz++

[20:53] <moritz> sorear: :by(-> { rand })  then

[20:53] <sorear> ...why would you do that?

[20:54] <moritz> sorear: people write code like that. If you don't guard against the zero-arity case, masak will write a bug report

[20:54] <PerlJam> heh

[20:54] <PerlJam> :by( -> { -1 }) is more likely I think

[20:55] *** mj41 joined
[20:57] <moritz> .[0] would be cheaper

[20:57] <masak> sorear: that's true, I will.

[20:58] <sjohnson> any one here an "flock master" ?

[20:59] <benabik> sjohnson: I just had do deal with some problems with it, but I'm not a master exactly.

[21:00] <sjohnson> benabik: cool.  it's about time i finally got proficient with the basics of it

[21:00] <PerlJam> Is a flock master the lead duck?

[21:00] <sjohnson> heh

[21:00] <masak> does it count if one has player some "Angry Birds"?

[21:00] <masak> played*

[21:00] <sjohnson> less that, more a guy who understands flock() like the back of his hand

[21:00] <sjohnson> masak: i suppose it could :)

[21:01] <benabik> sjohnson: Ah.  I now know enough to do some simple debugging involving NFS.

[21:01] * moritz wonders what kind of understanding the back of a hand needs

[21:01] <PerlJam> sjohnson: I've pondered flock more than I've pondered the back of my hand I think.

[21:01] <benabik> ( flock -s 200 || exit 1; echo locked! ) 200>mylock

[21:01] <sjohnson> if a script locks a text file... and some other script that doesn't use any flock statements tries to modify it... will the changes be allowed?

[21:02] <benabik> sjohnson: That's the kind of thing I don't know.  :-D

[21:02] <sjohnson> in other words, does flock() go by the honesty policy?

[21:02] <moritz> yes

[21:02] <moritz> ie, yes, changes allowed

[21:02] <PerlJam> sjohnson: yes

[21:02] <PerlJam> sjohnson: unless it's on a system that requires mandatory locking

[21:03] <PerlJam> er .. you know what I mean

[21:03] <sjohnson> interesting.  so, if say that 2nd script wanted to do the right thing, would you need some sort of explicit flock() statement that requests to use it, and thus would be rejected since the 1st script used it

[21:03] <sjohnson> ?

[21:03] <PerlJam> s/requires/only supports/  # now you really know what I meant :)

[21:03] <moritz> sjohnson: yes

[21:04] <flussence> if you're trying to write a file safely, the safe way is to write to a temp copy, fsync then rename over the old version. Modifying in-place is bad.

[21:04] <masak> even utilities that modify in-place do what flussence suggested :)

[21:04] *** kaare_ left
[21:05] <flussence> (a lot of people found this out the hard way when ext4 became widespread)

[21:05] <PerlJam> flussence: er ... why?  What did ext4 have to do with it?

[21:05] <moritz> sjohnson: fwiw you can find out about the locking stuff quite nicely by doing experiments

[21:05] <moritz> sjohnson: in one console, write

[21:05] <moritz> perl -Mautodie -wE 'open my $h, "README"; flock $h, 2; sleep(5000)'

[21:05] <sjohnson> yeah, i was about to bust open my classic "farm".

[21:06] <sjohnson> sjohnson% touch pig cow chicken

[21:06] <flussence> PerlJam: they changed the default journal mode, so rename-then-fsync went horribly wrong or something like that

[21:06] <moritz> and in another one, try   echo 'foo' > README

[21:06] <sjohnson> moritz: i like your idea better than mine!

[21:06] <PerlJam> sjohnson: Is this on linux btw?

[21:06] <sjohnson> yeah

[21:06] <sjohnson> just some ubuntu shell i have

[21:07] <flussence> (I think a workaround's been added to ext4 since then)

[21:07] <PerlJam> sjohnson: if you have root, you can remount a partition for mandatory locking and see what the difference is 

[21:08] * sjohnson learns much today

[21:09] <PerlJam> sjohnson: some systems, (like Windows I believe) only have mandatory locking, so if you're writing for portability you should understand what happens :)

[21:09] <moritz> masak: why do you think that -Int should not warn?

[21:09] <sjohnson> i suppose i might understand more with this too:  http://en.wikipedia.org/wiki/File_locking

[21:09] *** ggoebel left
[21:09] <sjohnson> PerlJam: good to know.  thankfully, no portability with this particular script.. but good to keep in mind

[21:10] <sjohnson> thanks for the help

[21:10] <sjohnson> *p6 group hug*

[21:11] <masak> moritz: because I can see it being part of a legitimate mathematical computation, where it would make more sense for it to pun to 0 than to warn.

[21:11] <masak> moritz: I think we have several of these cases.

[21:11] <PerlJam> sjohnson: so ... when will you have flock implemented for Perl 6?  :-)

[21:12] <sjohnson> if i tried, i'm sure it would be the collapse of the internet

[21:12] <sjohnson> i have 0 faith in my low-level programming skills at this present time

[21:12] <moritz> masak: note that ++ and -- and *= etc. don't warn

[21:12] <sjohnson> especially if some bank used rakudo

[21:12] <moritz> nom: +Int

[21:12] <p6eval> nom ff78b5: OUTPUT«Use of uninitialized value in numeric context␤»

[21:12] <sjohnson> might get sued millions of dollars

[21:13] <sorear> moritz: I think it would more more correct to die(..) unless &by.arity == 1|2

[21:14] <masak> moritz: oh, so maybe it's just the "mutating" math operators that don't warn?

[21:14] <moritz> masak: yes

[21:14] <masak> I'll add that to the ticket (and change the subject)

[21:14] <dalek> rakudo/nom: d3e6519 | moritz++ | src/core/Int.pm:

[21:14] <dalek> rakudo/nom: add some missing :D markers on Int ops, masak++

[21:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d3e651975a

[21:15] *** bluescreen100 left
[21:15] *** bluescreen10 left
[21:15] <jnthn> moritz: That...probably just hosed inlining :(

[21:15] <sjohnson> how hard is it to understand parrot programming language?

[21:15] <sorear> masak: per spec, $x op= $y means something like $x = ($x // [op]) op $y

[21:15] <moritz> sjohnson: there is no "parrot programming language"

[21:16] <moritz> jnthn: then inlining needs to improve wrt D

[21:16] <masak> sjohnson: did you mean PIR? nqp?

[21:16] <moritz> erm, :D

[21:16] <masak> sjohnson: C? :)

[21:16] <sjohnson> PIR

[21:16] <sjohnson> i would imagine that rakudo is written in some sort of parrot-script, if you will

[21:16] <moritz> jnthn: those :D's aren't in there for fun, but because we need them

[21:17] <masak> sjohnson: no, not anymore.

[21:17] * sjohnson wonders where he's been all this time

[21:17] <masak> sjohnson: Rakudo is written in Perl 6, nqp, and some C.

[21:17] <jnthn> moritz: It's kinda trickyish.

[21:17] <sjohnson> what's NQP?

[21:17] <sjohnson> not quite perl.. hmm

[21:17] *** dual left
[21:17] <moritz> a subset of Perl 6

[21:17] <jnthn> moritz: We have to know try and track declaredness as well as type.

[21:17] * sjohnson tries to understand

[21:17] <tadzik> hehe

[21:17] <tadzik> "add some missing :D" -- moritz

[21:18] <sjohnson> so, if you want to compile rakudo, what gets compiled first?  C?

[21:18] <PerlJam> sjohnson: NQP is just enough Perl 6 to implement Perl 6 :)

[21:18] <tadzik> sjohnson: yes

[21:18] <sjohnson> trying to figure what the first stage is of perl6 being interpretted to build rakudo

[21:18] <tadzik> then the compiler, which is nqp

[21:18] <tadzik> then the setting, which is Perl 6

[21:18] <sjohnson> perl6 dev team has been busy bees!

[21:19] <moritz> jnthn: maybe we need to declare variables as Int:D more often

[21:19] <moritz> ... or maybe that should become the default, just like in params

[21:19] <jnthn> moritz: Yeah, we don't implement that defaulting yet.

[21:19] <jnthn> moritz: Though it shouldn't be hard to.

[21:19] <tadzik> :D is default in params?

[21:20] <jnthn> moritz: There's only one problem with it for variables

[21:20] <jnthn> my Str $s;

[21:20] <moritz> right

[21:20] <PerlJam> tadzik: :D == defined

[21:20] <tadzik> yes, I know

[21:20] <sorear> :D is default in params?

[21:20] <moritz> jnthn: that might need to assign a default

[21:20] <PerlJam> oh.

[21:20] <jnthn> sorear: Apparently. ;)

[21:20] <tadzik> huh

[21:20] <sorear> when was this decided?

[21:20] * PerlJam is only paying about 0.25 attention to the N channels he's looking at on IRC

[21:20] <moritz> or maybe it's only on the invocant?

[21:20] * moritz checks the spec

[21:21] <jnthn> oh, maybe...I thought it was done for params generally

[21:21] <flussence> rakudo: sub x(Str $x) { say $x.WHAT }; x(Str)

[21:21] <p6eval> rakudo ff78b5: OUTPUT«Str()␤»

[21:21] <moritz> the commit log of a4e255cdec866af833f91d1e3c0d9ce6ddbdf74f says "Invocants now default to :D"

[21:21] <jnthn> oh

[21:21] <jnthn> Hm, ok

[21:22] <jnthn> That's less happy for the inliner :)

[21:22] <moritz> huh, I thought the :D caused problem for the inliner?

[21:22] <PerlJam> jnthn: is there some preference between :D and :U in MMD?

[21:22] * moritz totally confused

[21:22] <masak> sorear: I remember this being talked about during pre-YAPC::EU.

[21:23] <jnthn> moritz: Yes and no (more)

[21:23] <jnthn> moritz: Needing to know whether something is defined or not to inline is only a problem if the common case is that we don't easily know.

[21:23] <jnthn> moritz: If stuff defaults to :D and you have to declare otherwise, the optimizer knows plenty.

[21:26] <jnthn> If the situation is "we need to know it's :D to inline the candidate, and we have to infer that", then it's a little tricky.

[21:26] <moritz> right

[21:26] <gfldex> nom: my Str $foo = '12.345'; say $foo.Rat;

[21:26] <p6eval> nom ff78b5: OUTPUT«Method 'Rat' not found for invocant of class 'Str'␤  in block <anon> at /tmp/ERpEWJVnpT:1␤  in <anon> at /tmp/ERpEWJVnpT:1␤»

[21:27] <moritz> nom: say '12.234'.Numeric.WHAT

[21:27] <p6eval> nom ff78b5: OUTPUT«Rat()␤»

[21:28] *** dual joined
[21:29] * moritz conducts an experiment

[21:31] <masak> moritz: hey, what's this about giving me tickets for testing? :P

[21:31] <sorear> masak: eh, so I just need to get to YAPC::EU someday.  ok.

[21:32] <moritz> masak: the experiment :-)

[21:32] <masak> my interests lie more in the area of increasing the RT queue size...

[21:32] <masak> sorear: yes, but not for that reason. that one discussion already happened.

[21:32] <moritz> an attempt to suck you into the test suite :-)

[21:33] <moritz> a mini challenge. Don't you love mini challenges? :-)

[21:33] <masak> :P

[21:34] <masak> moritz: I admire your tenacity wrt the test suite. I occasionally make dips into it, but I find I cannot sustain maintaining it for some reason.

[21:34] <masak> I can sustain submitting rakudobugs.

[21:35] <dalek> rakudo/nom: fb53581 | moritz++ | src/core/Cool.pm:

[21:35] <dalek> rakudo/nom: missing coercers, gfldex++

[21:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb5358187d

[21:35] * moritz cannot sustain to stay awake, and thus fades to sleep

[21:35] *** cognominal left
[21:35] *** cognominal joined
[21:36] <gfldex> what could "Can only use get_what on a SixModelObject" mean?

[21:36] <masak> moritz: dream of dozens of autonomous moritz agents, living on the 'Net and tending the test suite.

[21:36] <masak> gfldex: that you've somehow dropped out of the normal type system.

[21:36] <masak> gfldex: my guess is metamodel, or different HLL.

[21:37] <benabik> Likely a raw parrot object leaked out somewhere.

[21:37] <sorear> or doing unspeakable things with pir::

[21:37] <gfldex> i would never even try to do unspeakable things with pir::

[21:37] <jnthn> metamodel is all .WHATable

[21:38] <gfldex> say %.components.WHAT;

[21:38] <gfldex> that's the line causing it

[21:38] <gfldex> aint have no pir:: in it

[21:38] <jnthn> Where is that line?

[21:38] <jnthn> In a method?

[21:38] <gfldex> yes

[21:39] <benabik> %.components?  Shouldn't there be something between % and . ?

[21:39] <jnthn> gfldex: OK, I'll need a bit more context. If you can golf it down to something small, I can investigate...

[21:39] <benabik> (Although I don't think it should leak parrot into the system either.

[21:40] * gfldex looks for his golf clubs

[21:41] <masak> benabik: '%.components' looks fine to me.

[21:41] <benabik> masak: What does it mean?

[21:41] <masak> benabik: it means 'public hash attribute'

[21:41] <sorear> benabik: %.components is shorthand for self.components.hash

[21:41] <masak> benabik: the '.' is a twigil.

[21:42] <benabik> Oh.  *facepalm*

[21:42] <gfldex> i'm trying to nomify a script that used to work with master

[21:42] <benabik> I forgot . could be a twigil too.  *sigh*

[21:49] <dalek> roast: fc78e0f | masak++ | S03-operators/arith.t:

[21:49] <dalek> roast: added test for #100768

[21:49] <dalek> roast: 

[21:49] <dalek> roast: Because moritz++ told me to.

[21:49] <dalek> roast: review: https://github.com/perl6/roast/commit/fc78e0fcab

[21:55] *** benabik left
[21:58] *** mj41 left
[22:02] *** f00li5h joined
[22:04] *** S11001001 joined
[22:09] <masak> 'night, #perl6. dream of implementations with all green in http://perl6.org/compilers/features

[22:22] <sorear> o/ S11001001

[22:22] <S11001001> hi sorear

[22:27] *** [Coke] left
[22:29] <sjohnson> heh

[22:29] *** [Coke] joined
[22:29] <sjohnson> is that binary for 0xC9 ?

[22:29] <S11001001> sjohnson: indeed

[22:30] <sjohnson> oh, i didn't even see you there

[22:30] <sjohnson> i thought it was his way of saying:  o/ 0b101010

[22:30] <sjohnson> iow, *

[22:35] <sorear> what's the significance of 0xC9

[22:36] *** am0c left
[22:37] <S11001001> just a star trek thing

[22:37] *** kfo left
[22:38] *** kfo joined
[22:40] <sjohnson> sorear: do you use / like C at all?

[22:40] <sorear> sjohnson: yes

[22:41] <sjohnson> yes to both? :)

[22:41] <sorear> yes

[22:42] *** alvis left
[22:43] <sjohnson> cool

[22:43] <sjohnson> another question

[22:43] <sjohnson> do you know much about Programming Pearls?

[22:44] <sjohnson> i wanted to beef up on some computer science knowledge, and there's that book.. and the TAOCP.. which might be too expensive, too difficult, and to large of a read

[22:44] <sjohnson> having a hard time deciding which avenue to go down.

[22:47] <dalek> niecza/serialize: 11c6923 | sorear++ | / (6 files):

[22:47] <dalek> niecza/serialize: Reimplement sub "extend" functionality

[22:47] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/11c69230ab

[22:47] <dalek> niecza/serialize: 63597b7 | sorear++ | / (4 files):

[22:47] <dalek> niecza/serialize: Reimplement return-pass, Whatever currying

[22:47] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/63597b7145

[22:48] <sorear> sjohnson: ALL OF THEM. :D

[22:48] <sjohnson> not a bad idea

[22:48] <sorear> sjohnson: I found TAOCP in a library.  It still contained a few things I didn't already know

[22:50] <sjohnson> that book's so big, probably would warrant me buying it

[22:50] <sorear> other things you ought to read: *SICP  *Draft Report on the EDVAC  (to be continued)

[22:54] <sjohnson> thanks

[22:54] <sjohnson> no idea what it means from the title

[22:54] <sjohnson> but sounds interesting nonetheless

[22:55] *** alvis joined
[22:55] <TimToady> google is your friend, at least this time

[22:55] *** S11001001 left
[22:55] <sorear> the latter was a document written around '45 that outlined the design of the modern computer

[22:56] <sorear> it's still useful because it was written for an audience without much computer experience :D

[22:56] <cognominal> nom: 'aaaa' ~~ m/ $<a>=.*/; $/<a>.perl

[22:56] <phenny> cognominal: 30 Sep 23:48Z <[Coke]> ask cognominal to update RT#75850 with the expected output.

[22:56] <p6eval> nom fb5358:  ( no output )

[22:56] <sjohnson> i'd like to learn practical stuff like which data structures are good for what scenarios

[22:57] <sjohnson> instead of marvel over cool abrasct computer concepts

[22:57] <sjohnson> mostly casue i want to write an encryption app for free

[22:57] <cognominal> nom: 'aaaa' ~~ m/ $<a>=.*/; say $/<a>.perl

[22:57] <p6eval> nom fb5358: OUTPUT«Match.perl(orig => "aaaa", from => 0, to => 4, ast => Mu, list => ().list, hash => EnumMap.new())␤»

[22:57] * sjohnson already owns applied cryptography

[22:57] <sorear> I wouldn't trust a cryptography app unless it was written by someone famous

[22:58] <sorear> there is a LONG history of independant cryptography apps that are actually completely useless because of a misunderstanding or something

[22:58] <sjohnson> i am well aware of that, to be honest.

[22:58] <sjohnson> i was hoping to pay a professianal to have a conversation with me

[22:58] <sjohnson> so i could describe exactly what the protocl is

[22:59] <sjohnson> protocol is

[22:59] <sjohnson> and let me know if i'm a fool or not.

[22:59] <sjohnson> obviously i'd be for free, so no one would kill me for selling a faulty product at least.

[23:00] <sorear> what do you want to do that gpg doesn't already do?

[23:07] <sjohnson> gpg doesn't have perfect forward secrecy

[23:07] <sjohnson> also, i want to make a clone of Secway Simp, which encrypts IM traffic

[23:07] <sjohnson> like MSN, Jabber, ICQ, etc.

[23:09] <sorear> erm, what do you mean perfect forward secrecy

[23:11] *** hacktor joined
[23:11] <sjohnson> private key compromised

[23:11] <sjohnson> means all previous messages that you can assume were sniffed and stored somewhere are readable

[23:12] <sjohnson> use a private key only for authentication, and use a diffie hellman to agree on a shared sym. key, will mean you need to solve the DH problem first, even if the private key is compromised

[23:12] <sjohnson> only thing an attacker could do with a private key once its compromised, is pretend to be you in future conversations, and not read past ones.

[23:13] <dalek> rakudo/optimizer: a47b0cd | jnthn++ | src/Perl6/Actions.pm:

[23:13] <dalek> rakudo/optimizer: Tighten up what we admit for inlining; require that the arguments are *all* mentioned.

[23:13] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/a47b0cd4bd

[23:13] <dalek> rakudo/optimizer: fb111db | jnthn++ | / (3 files):

[23:13] <dalek> rakudo/optimizer: Add support for --optimize=[off|1|2|3]. The default is level 2. 'off' will not even enter the optimizer, so it skips CHECK time could-never-work analysis. Classify inlining and compile-time multi selection as level 2 for now; block inlining gets level 3 initially but should drop to two in the not too distant future; it needs some more aggressive testing. We build the setting with --optimize=3.

[23:13] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/fb111db88f

[23:14] *** hacktor is now known as gttg

[23:14] <sjohnson> sorear: see http://en.wikipedia.org/wiki/Perfect_forward_secrecy .  also, Secway Simp deosn't even have PFS with their authenticated mode, they admitted in an email to me.

[23:15] <sjohnson> so my free product would probably the first one to do it.  problem is, i need some better understanding of how things are done in the C programming world as well as algorithms as far as data storage go, so I don't look like the village idiot in the crypto community

[23:15] <jlaire> < sjohnson> i'd like to learn practical stuff like which data structures are good for what scenarios

[23:15] <jlaire> I recommend reading "Introduction to Algorithm" and solving lots of algorithm problems

[23:15] <sorear> sjohnson: if you want to learn about the science of algorithms and data structures, READ TAOCP.

[23:16] <sorear> that's the main focus of the book series

[23:16] * jlaire is currently reading TAOCP and likin' it

[23:17] <sorear> sjohnson: also read anything else you can find.  Ask questions here, I collect obscure algorithms and data structures.

[23:17] <sjohnson> thanks for the advice

[23:18] <sjohnson> sorear: so TAOCP isn't 100% esoteric?

[23:18] <sjohnson> i can apply that understanding to real world stuff?

[23:18] <jlaire> yes

[23:18] <sjohnson> sweet

[23:18] <sjohnson> will do!

[23:18] <sorear> sjohnson: *everything* in TAOCP is usable in the real world.

[23:19] <sjohnson> i'll just go ahead and get the goods then

[23:19] <sorear> sjohnson: there are some books that are designed to be usable by people too busy to really learn how to program.  TAOCP is not one of them

[23:20] <sjohnson> uh oh.

[23:20] <sjohnson> i mean, i'm willing to put in time

[23:20] <sjohnson> but i don't know if i can devote all my free time for the next 15 years to trying to make sense of TAOCP

[23:20] <jlaire> familiarity with assembly programming for machines from the '60s is especially useful ;)

[23:22] <sorear> sjohnson: I'd say I've devoted 10% of my free time for the last 10 years to becoming a better programmer, and I had no troble reading TAOCP.

[23:22] <sjohnson> oh okay

[23:23] <sjohnson> i should just read it, and not assume it's going to be the most impossible thing in the world.

[23:23] <sjohnson> there was once a time i thought it would be impossible for me to learn Perl

[23:23] <sjohnson> and i stuck with that distorted view for 4 years, and avoided it whenever a perl task came up at work.  then i had to learn it, bought the camel book, and was doing some impressive stuff only a few days later

[23:23] <sjohnson> it was a great feeling, btw.

[23:24] <sjohnson> good life lesson

[23:24] <jlaire> sorear: "It still contained a few things I didn't already know" <-- was "a few things" a slight exaggeration?

[23:24] <sorear> jlaire: do you mean understatement?

[23:24] <jlaire> urd

[23:25] <jlaire> yes*

[23:25] <sorear> jlaire: I'd say I already knew most of the really important things there, because of how long I've spent as a practicing programmer and especially how much reading I've done on algorithms

[23:26] <jlaire> sorear: ok, I see. how much time did you spend on the exerices v. reading the book?

[23:27] <sorear> 2:3 or so.  I didn't systematically do all the exercises

[23:27] <jlaire> tyvm

[23:28] <jlaire> I don't thnk anyone could do them all ;)

[23:28] <sjohnson> sorear: does it deal with big O notation, for someone like me who is unable to prove notations in a CS class?

[23:28] <sjohnson> or does it just assume you already know that, and skip it entirely

[23:28] <sjohnson> (taocp that is)

[23:28] <sjohnson> i'm not very familiar with some of the basic things, and i kind of need to start small.

[23:28] <sorear> sjohnson: it talks about what O(n) is, yes

[23:29] <jlaire> in that case, I'd recommend Concrete Mathematics, too

[23:29] <sjohnson> cool

[23:30] <sjohnson> i've logged both your recommednations, by the way

[23:30] <sjohnson> so, it's not falling on deaf ears :)

[23:30] <sorear> sjohnson: I'm a crypto geek too, I'd be interested in seeing your designs

[23:30] <jlaire> TAOCP has a fairly lengthy section on mathematics, but I found it a bit terse

[23:30] <jlaire> :)

[23:30] <TimToady> O() is mostly just a funny way to talk about dimensionality

[23:30] <jlaire> o_O

[23:31] <jlaire> TimToady: sounds interesting, can you elaborate

[23:31] <sjohnson> sorear: i had one change made in GnuPG 1.4.x branch, so at least i finally contributed to something

[23:31] <sjohnson> took a lot of arguing on the mailing list

[23:31] <TimToady> it's about the size of search spaces

[23:31] <sorear> the important thing with O() is that you understand compositionality

[23:32] <sorear> few mortals can prove that a lookup in a distinct-set forest takes O(A^-1(N)) time

[23:32] <TimToady> O(1) basically means you have to move in 0 dimensions to achieve a solution

[23:32] <sjohnson> but the security of DH with using a private key to authenticate only gives me hope for a better future of safety :)  but GnuPG is pretty cool, i do like it a lot.

[23:32] <TimToady> O(n) means you have to move in 1 dimension

[23:32] <TimToady> O(n^2) means 2 dimensions, etc

[23:32] <sorear> but, given that, every programmer needs to be able to intuit the time complexity of doing N lookups

[23:32] <jlaire> .oO( moving in fractal dimensions )

[23:32] <TimToady> relationships between dimensions produce fractal dimensionality

[23:33] * sorear wonders how many dimensions there are in O(A^-1(N))

[23:33] <sjohnson> .oO( ... ) is Big Think notation

[23:33] <jlaire> sorear: what's a "distinct-set forest"? google gives no hits

[23:33] <sjohnson> i also need to remember what log cruves sort of look like too.

[23:34] <sjohnson> curves*

[23:34] <TimToady> they keep getting flatter, but never go flat

[23:34] <TimToady> just like exponentials never quite go straight up

[23:35] *** gttg left
[23:36] <sorear> http://en.wikipedia.org/wiki/Disjoint-set_data_structure#Disjoint-set_forests

[23:36] <jlaire> oh, disjoint makes more sense

[23:37] <sorear> sjohnson: a log curve is one where going from 1 to 10 is 1 unit, and so is going from 1000 to 10000

[23:37] <TimToady> fractal branches are generally disjoint

[23:38] <sjohnson> i wonder how much of this stuff that facebook guy knew, before he made billions

[23:38] <sjohnson> i wonder if there's a point where one knows too much math

[23:39] * jlaire was told that the lookup is "practically amortized constant" when learning about this data structure

[23:39] * jnthn wonders if there's a point where on feels they know too many anything :)

[23:39] <jnthn> *one

[23:39] <jnthn> Well, there's probably some things I'd rather not know about but...there's always something interesting more to learn. :)

[23:39] <jlaire> technical skills probably weren't the reason he made billions

[23:40] * TimToady wonders whether knowing both too little and too much about something are really mutually exclusive...

[23:41] <jnthn> :)

[23:41] <sorear> I think making billions is mostly a function of being evil

[23:42] <TimToady> neither the converse nor the inverse follow, of course :)

[23:42] <dalek> rakudo/optimizer: c191cfe | jnthn++ | src/Perl6/Optimizer.pm:

[23:42] <dalek> rakudo/optimizer: Improve error reporting. When we determine a call could never work, shows the desired signature(s) in the error.

[23:42] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/c191cfe663

[23:45] <dalek> rakudo/optimizer: b5d2c9b | jnthn++ | src/Perl6/Actions.pm:

[23:45] <dalek> rakudo/optimizer: Try to get better line reporting for calls.

[23:45] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b5d2c9bb54

[23:46] *** jaldhar joined
[23:50] *** itz left
[23:53] *** cggoebel joined
[23:57] *** itz joined
[23:59] *** wolfman2000 joined
