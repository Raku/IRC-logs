[00:04] <ranott> glad to see so many developers putting their time into Rakudo.  Sorry about the away.

[00:05] *** benabik left
[00:06] *** Moukeddar joined
[00:23] *** impious left
[00:38] *** whiteknight joined
[00:42] <TimToady> sorear: I found a strange niecza bug, gist coming

[00:43] <TimToady> https://gist.github.com/1121634

[00:44] <TimToady> it's a random number generator, which produces the correct sequence, except that the 3rd number is supposed to be 539453717, not -460546283

[00:44] <TimToady> (works in nom)

[00:44] <TimToady> hmm

[00:45] <TimToady> nom: https://gist.github.com/1121634

[00:45] <p6eval> nom: OUTPUT«467478574␤512932792␤539453717␤20349702␤615542081␤378707948␤933204586␤824858649␤506003769␤380969305␤»

[00:45] <TimToady> niecza: https://gist.github.com/1121634

[00:45] <p6eval> niecza v8-21-g9c1607b: OUTPUT«467478574␤512932792␤-460546283␤20349702␤615542081␤378707948␤933204586␤824858649␤506003769␤380969305␤»

[00:45] <sorear> nom: say -1 % 100

[00:45] <p6eval> nom: OUTPUT«99␤»

[00:45] <sorear> niecza: say -1 % 100

[00:45] <p6eval> niecza v8-21-g9c1607b: OUTPUT«-1␤»

[00:46] <sorear> perl6: say -1 % 100

[00:46] <p6eval> niecza v8-21-g9c1607b: OUTPUT«-1␤»

[00:46] <p6eval> ..pugs, rakudo 922500: OUTPUT«99␤»

[00:46] <TimToady> there it is

[00:48] *** tokuhirom joined
[00:48] <TimToady> there's a nom bug too; it segfaults if I move the inner sub till after the inner call to subrand()

[00:48] <TimToady> so probably a post-declaration messup

[00:49] <TimToady> masak: ^^   :)

[00:49] *** wolfman2000 joined
[00:51] <dalek> nqp: 4e5bf5f | pmichaud++ | src/PAST/NQP.pir:

[00:51] <dalek> nqp: Add :pasttype<xor_nqp>, which allows the return value for two true

[00:51] <dalek> nqp: values in an xor expression to be specified as one of the children.

[00:51] <dalek> nqp: This can likely be immediately added to Parrot's PCT as a replacement

[00:51] <dalek> nqp: for :pasttype<xor>, but since nom/nqp will need this long before the

[00:51] <dalek> nqp: next Parrot supported release we'll keep a copy here too.

[00:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4e5bf5f690

[00:58] <dalek> roast: 9aed4c2 | sorear++ | S02-names/pseudo.t:

[00:58] <dalek> roast: [S02-names/pseudo.t] add CALLER, OUTER

[00:58] <dalek> roast: review: https://github.com/perl6/roast/commit/9aed4c2913

[01:04] *** noganex_ joined
[01:05] <pmichaud> locally:

[01:05] <pmichaud> > say 42 ^^ 15

[01:05] <pmichaud> Nil

[01:05] <pmichaud> > my $x;  $x ^^= 42;  $x ^^= 15;  say $x

[01:05] <pmichaud> Nil

[01:05] <pmichaud> (this last one is wrong, should probably result in Any)

[01:06] <sorear> why should it result in Any?

[01:06] <pmichaud> assigning Nil to a scalar

[01:06] <sorear> oh

[01:07] <sorear> you really beleive that? :(

[01:07] *** noganex left
[01:07] <pmichaud> I believe that's what the spec says, yes.

[01:07] <sorear> yeah but it's so horrible

[01:08] <TimToady> perhaps you should return False if it's false...

[01:08] <pmichaud> the spec currently says it wants an empty list in list context, though.  Since we don't have a list context, Nil seeems the next-best-thing.

[01:08] <TimToady> sorear: Nil is defined as the absence of a value, so you can't usefully store it

[01:08] <TimToady> well, how about () then?

[01:08] <pmichaud> I can have it return () always, yes.

[01:09] <TimToady> perl6: say 1 ^^ 0

[01:09] <p6eval> niecza v8-21-g9c1607b: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical &infix:<^^> in mainline␤␤Server stack trace: ␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>…

[01:09] <p6eval> ..pugs, rakudo 922500: OUTPUT«1␤»

[01:09] *** woosley joined
[01:10] <sorear> I have a negative reflex reaction to anything that involves adding tests to the hot path of assignments

[01:10] *** donri left
[01:10] <sorear> do we still beleive Nil ~~ Parcel ~~ Any?

[01:10] <pmichaud> nom doesn't have Nil ~~ Parcel

[01:11] <pmichaud> nom:  say Nil ~~ Parcel;

[01:11] <p6eval> nom: OUTPUT«Bool::False␤»

[01:11] <pmichaud> although it is still Cool and Any

[01:11] <sorear> nom: say Nil.WHAT

[01:11] <p6eval> nom: OUTPUT«Nil␤»

[01:11] <TimToady> Nil is about the closest thing we have to a bottom value

[01:11] <sorear> nom: say Nil.^parents

[01:11] <p6eval> nom: OUTPUT«Iterator() Iterable() Cool() Any() Mu()␤»

[01:12] <TimToady> my $x := Nil; say $x

[01:12] <TimToady> perl6: my $x := Nil; say $x

[01:12] <p6eval> rakudo 922500: OUTPUT«Nil()␤»

[01:12] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/3bLKcQdeAv line 1, column 1-13␤»

[01:12] <p6eval> ..niecza v8-21-g9c1607b: OUTPUT«␤»

[01:12] <TimToady> nom: my $x := Nil; say $x

[01:13] <p6eval> nom: OUTPUT«Nil␤»

[01:13] <TimToady> that works

[01:13] <TimToady> nom: say Nil ~~ List

[01:13] <p6eval> nom: OUTPUT«Bool::False␤»

[01:13] <TimToady> why is Iterable there twice?

[01:14] <pmichaud> It's not.

[01:14] <pmichaud> Iterator and Iterable

[01:14] * TimToady is blind

[01:14] <pmichaud> Nil is self-iteratating.

[01:14] <pmichaud> *iterating.

[01:14] <TimToady> self-irritating :)

[01:14] <pmichaud> *irritating.  Whatever.

[01:15] *** jevin left
[01:15] <TimToady> sorear: is the -1 % 100 bug a niecza bug or a mono/clr bug?

[01:16] <TimToady> http://rosettacode.org/wiki/Subtractive_generator  <-- 3 uses of sequence operator!

[01:17] <dalek> rakudo/nom: cefbda4 | pmichaud++ | / (3 files):

[01:17] <dalek> rakudo/nom: Some infix:<xor> improvements -- two true values passed to xor or ^^

[01:17] <dalek> rakudo/nom: now result in Nil instead of a segfault-inducing Parrot Undef.

[01:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cefbda4b12

[01:17] <TimToady> also shows how very different p6 code can look from p5 code because of that

[01:18] <sorear> TimToady: it's a niecza bug

[01:18] <pmichaud> afk, walk

[01:18] <sorear> pmichaud: 'Nil is self-iterating' ?

[01:18] *** jevin joined
[01:19] <pmichaud> some things such as Parcels and Nil can act as their own iterator.

[01:19] <pmichaud> i.e., they reify to themselves when iterated.

[01:19] <sorear> ah

[01:19] <dalek> rakudo/nom: 6834ff0 | pmichaud++ | NOMMAP.markdown:

[01:19] <dalek> rakudo/nom: Update NOMMAP.

[01:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6834ff033c

[01:20] <pmichaud> afk, walk.

[01:20] <sorear> nom: for Nil { say 1 }

[01:20] <p6eval> nom:  ( no output )

[01:20] <sorear> that's what I thought

[01:20] *** Moukeddar left
[01:20] <TimToady> it's basically an undefined ()

[01:20] <sorear> TimToady: (my $x := Nil leaving $x =:= Nil) is this a bug?

[01:21] <pmichaud> these days I tend to lean towards the idea that := should do the binding, whatever it may be.

[01:21] <TimToady> possibly, according to current spec, but the spec might be wrong there

[01:21] <TimToady> what pmichaud++ said

[01:21] <sorear> pmichaud: does that translate to "yes" or "no"?

[01:21] <pmichaud> sorear: "not a bug"

[01:21] <sorear> niecza: say -1.0 % 100.0

[01:21] <p6eval> niecza v8-21-g9c1607b: OUTPUT«-1/1␤»

[01:21] <sorear> niecza: say -1e0 % 100e0

[01:21] <p6eval> niecza v8-21-g9c1607b: OUTPUT«99␤»

[01:22] <pmichaud> similarly I tend to think that binding to a Parcel should leave things as a Parcel and not convert it to a Seq or anything else

[01:22] <sorear> niecza: say -1 % (2**64)

[01:22] <p6eval> niecza v8-21-g9c1607b: OUTPUT«-1␤»

[01:22] <TimToady> I'm find with binding being very primitive compared to assignment

[01:22] <TimToady> *fine

[01:22] <sorear> looks like Num case is correct and all the others are backward

[01:22] <pmichaud> right... keeping binding very primitive seems to be desirable in nom

[01:23] <pmichaud> afk, walk for real this time.

[01:27] *** whiteknight left
[01:27] <dalek> specs: 81bd38c | larry++ | S02-bits.pod:

[01:27] <dalek> specs: Bind of Nil with := is primitive

[01:27] <dalek> specs: 

[01:27] <dalek> specs: (But parameter binding is ::= semantics, which treats Nil as if no arg had been passed.)

[01:27] <dalek> specs: review: https://github.com/perl6/specs/commit/81bd38ce3e

[01:32] *** ranott left
[01:34] *** daniel-s joined
[01:39] *** daniel-s_ joined
[01:39] *** daniel-s left
[01:43] *** daniel-s__ joined
[01:43] *** daniel-s_ left
[01:49] <sorear> niecza: (-1) % 100

[01:49] <p6eval> niecza v8-21-g9c1607b:  ( no output )

[01:49] <sorear> niecza: say (-1) % 100

[01:49] <p6eval> niecza v8-21-g9c1607b: OUTPUT«-1␤»

[01:50] <sorear> niecza: say (-101) % 100

[01:50] <p6eval> niecza v8-21-g9c1607b: OUTPUT«99␤»

[01:51] *** molaf joined
[01:55] <dalek> niecza: 0053246 | sorear++ | lib/Builtins.cs:

[01:55] <dalek> niecza: Fix sign behavior of % (TimToady)

[01:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0053246b75

[01:59] *** woosley left
[02:00] <daniel-s__> nom: 4**3.say

[02:00] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[02:01] <daniel-s__> rakudo: 4**3.say

[02:01] <p6eval> rakudo 922500: OUTPUT«3␤»

[02:01] <daniel-s__> rakudo: say 4**3

[02:01] <p6eval> rakudo 922500: OUTPUT«64␤»

[02:04] <sorear> method call binds tighter than anything else

[02:07] <dalek> niecza: 826f49f | sorear++ | t/spectest.data:

[02:07] <dalek> niecza: Add S02-names/pseudo.t

[02:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/826f49f206

[02:07] <dalek> roast: fdbe891 | sorear++ | S02-names/pseudo.t:

[02:07] <dalek> roast: Finish S02-names/pseudo.t

[02:07] <dalek> roast: review: https://github.com/perl6/roast/commit/fdbe891a03

[02:07] <sorear> wound up with 140 pseudo package tests

[02:29] *** daniel-s__ is now known as daniel-s

[02:32] *** molaf left
[02:38] *** rdesfo left
[02:39] *** breinbaas left
[02:40] *** breinbaas joined
[02:46] *** lichtkind left
[03:10] *** jaldhar left
[03:11] *** jaldhar joined
[03:21] *** envi joined
[03:28] *** Su-Shee joined
[04:05] *** jimmy1980 left
[04:06] <dalek> niecza: 17807f3 | sorear++ | / (2 files):

[04:06] <dalek> niecza: Implement .gist

[04:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/17807f3107

[04:10] *** wolfman2000 left
[04:10] <sorear> 1 failing test (was 5)

[04:11] *** mattp_ left
[04:14] *** SHODAN joined
[04:14] *** jimmy1980 joined
[04:14] <sorear> *file

[04:17] *** birdwindupbird joined
[04:17] *** satyavvd joined
[04:26] <dalek> niecza: 7888fe2 | sorear++ | src/NieczaFrontendSTD.pm6:

[04:26] <dalek> niecza: Fix LTM automaton generation for user-defined operators

[04:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7888fe27d5

[04:26] <sorear> all spectests should now be an unregressed state

[04:34] *** araujo left
[04:35] *** araujo joined
[04:35] *** sivoais left
[04:43] *** am0c left
[04:44] *** Moukeddar joined
[04:46] *** am0c joined
[04:50] *** SHODAN left
[05:11] *** woosley joined
[05:12] *** SHODAN joined
[05:16] *** Moukeddar left
[06:01] *** daniel-s left
[06:01] *** mberends left
[06:01] *** clkao left
[06:02] *** clkao joined
[06:07] *** wtw joined
[06:08] *** mattp_ joined
[06:15] <moritz> good morning

[06:15] <dalek> roast: 37d802d | moritz++ | S0 (6 files):

[06:15] <dalek> roast: rakudo unfudges

[06:15] <dalek> roast: review: https://github.com/perl6/roast/commit/37d802de9d

[06:15] <dalek> roast: add4718 | moritz++ | S32-list/reduce.t:

[06:15] <dalek> roast: fix a test I broke earlier, moritz--

[06:15] <dalek> roast: review: https://github.com/perl6/roast/commit/add4718a26

[06:16] <sorear> hello moritz

[06:17] <sorear> moritz: niecza should be passing 'make spectest' again.  also, 140 new pseudopackage tests.

[06:17] <moritz> \o/

[06:17] *** aloha left
[06:19] *** koban joined
[06:19] <sorear> niecza: CORE::say 1..5

[06:19] <p6eval> niecza v8-25-g7888fe2: OUTPUT«1..5␤»

[06:19] <TimToady> niecza: UNIT::say 1..5

[06:20] <p6eval> niecza v8-25-g7888fe2: OUTPUT«1..5␤»

[06:20] <TimToady> \o/

[06:20] <TimToady> niecza: MY::say 1..5

[06:20] <p6eval> niecza v8-25-g7888fe2: OUTPUT«1..5␤»

[06:20] <TimToady> ooh

[06:20] <TimToady> niecza: SETTING::say 1..5

[06:20] <p6eval> niecza v8-25-g7888fe2: OUTPUT«1..5␤»

[06:20] <TimToady> wowee

[06:21] <TimToady> niecza: FOO::say 1..5;  # just checking :)

[06:21] <p6eval> niecza v8-25-g7888fe2: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/NM97DlEJJP line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1957 (CORE C915_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1958 (CO…

[06:21] <TimToady> sorear++

[06:37] *** aloha joined
[06:59] *** masak joined
[06:59] <masak> good morning, #perl6.

[07:00] <masak> I have a question: why doesn't Perl 5 core have a 'comb' builtin by now?

[07:00] <masak> how do people cope? do they write their own? is there a CPAN module?

[07:02] <sorear> well, there's m//g

[07:02] *** mj41 joined
[07:02] <sorear> buubot_backup: eval: join " ", "12+34*56" =~ m/\d+/g

[07:03] <buubot_backup> sorear: 12 34 56

[07:03] <sorear> also o/ masak

[07:04] * sorear points out shiny niecza feature to masak

[07:08] *** aindilis left
[07:11] *** aindilis joined
[07:12] <sorear> rakudo: say Str === Str

[07:12] <p6eval> rakudo 922500: OUTPUT«Bool::True␤»

[07:12] <sorear> rakudo: say Str eq Str

[07:12] <p6eval> rakudo 922500: OUTPUT«Bool::True␤»

[07:12] <sorear> nom: say Str === Str

[07:12] <p6eval> nom: OUTPUT«Bool::True␤»

[07:12] <sorear> nom: say Str eq Str

[07:12] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤Bool::True␤»

[07:14] <masak> sorear: cool!

[07:14] <masak> and yes, there's m//g, that's not too bad. will use that :)

[07:29] *** odoacre left
[07:35] *** odoacre joined
[07:39] *** Mowah joined
[07:45] <dalek> niecza: 6b9d707 | sorear++ | / (6 files):

[07:45] <dalek> niecza: Implement new Nil model

[07:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6b9d70738d

[07:46] <dalek> roast: 5451960 | sorear++ | S02-builtin_data_types/nil.t:

[07:46] <dalek> roast: [S02-builtin_data_types/nil.t] Expand tests to cover all functionality in contemporaneous Niecza commit.

[07:46] <dalek> roast: review: https://github.com/perl6/roast/commit/5451960f00

[07:46] <sorear> moritz: I pre-skipped all the new tests for Rakudo because I don't know if it will pass them

[07:48] <sorear> nom: sub foo($x = 123, $y = 456) { say ($x, $y) }; foo(Nil, 42)

[07:48] <p6eval> nom: OUTPUT«Nil 42␤»

[07:48] <sorear> evalbot rebuild niecza

[07:48] <p6eval> OK (started asynchronously)

[07:49] <sorear> niecza: sub foo($x = 123, $y = 456) { say ($x, $y) }; foo(Nil, 42)

[07:49] <p6eval> niecza v8-26-g6b9d707: OUTPUT«123 42␤»

[07:50] <sorear> I decided it made more sense just to check for Nil in the signature binder

[07:51] <sorear> if we find Nil while doing type checking and it came from a parameter, we throw out the argument and try again using the fallbacks

[07:51] *** meteorjay joined
[07:52] <sorear> hmm, I'm at a good stopping point

[07:52] * sorear sleep

[07:56] *** wamba joined
[08:05] <masak> 'night, sorear 

[08:05] <masak> dream of more wonderful features in Niecza.

[08:42] *** daxim joined
[08:45] *** woosley left
[08:47] *** woosley joined
[08:51] *** Kivutarrr joined
[08:51] *** zamolxes left
[08:52] *** zamolxes joined
[08:58] *** woosley1 joined
[08:58] *** woosley1 left
[09:00] *** woosley left
[09:04] *** jjore_ left
[09:06] <jnthn> o/ #perl6

[09:25] *** Mowah left
[09:29] *** satyavvd left
[09:31] *** ranott joined
[09:34] *** beekor left
[09:35] <masak> \o jnthn 

[09:36] <moritz> o/

[09:37] *** ab5tract joined
[10:09] *** espadrine joined
[10:14] <dalek> roast: 5eced30 | moritz++ | integration/lazy-bentley-generator.t:

[10:14] <dalek> roast: turn an RC entry by TimToady++ into an integration tests

[10:14] <dalek> roast: 

[10:14] <dalek> roast: Very interesting for us, because it makes nom segfault

[10:14] <dalek> roast: review: https://github.com/perl6/roast/commit/5eced30e2b

[10:16] *** im2ee joined
[10:17] *** im2ee left
[10:23] *** Kivutarrr left
[10:47] *** cosimo joined
[10:49] *** jjore joined
[11:05] *** ab5tract left
[11:06] <jnthn> masak: o/

[11:06] * jnthn teaching :)

[11:07] <jnthn> ooh, a segfault

[11:07] *** tokuhirom left
[11:07] *** tokuhirom joined
[11:11] <jnthn> somehow we're getting a Parrot string leaking in.

[11:11] * moritz imagines jnthn diagnosing a segfault while teaching

[11:12] *** tokuhirom left
[11:13] <tadzik> „yeah, ok kids, just a second, I got this..”

[11:13] <tadzik> oh, good afternoon #perl6

[11:14] <moritz> \o tadzik 

[11:14] <dalek> roast: 1640c4b | moritz++ | S02-builtin_data_types/nil.t:

[11:14] <dalek> roast: refudge nil.t for rakudo

[11:14] <dalek> roast: review: https://github.com/perl6/roast/commit/1640c4b5f5

[11:15] <jnthn> :)

[11:16] <jnthn> Nah, they're doing exercies :)

[11:16] <moritz> kids, please design a complete storage and meta-object system for Perl 6 that supports gradual typing; don't bother me with questions until you're finished.

[11:18] *** ab5tract joined
[11:19] <tadzik> jnthn: whatcha teaching?

[11:19] <jnthn> SVN this morning, JavaScript this afternoon :)

[11:20] <jnthn> Segfaults on the &subrand ... *;

[11:20] *** azawawi joined
[11:20] <azawawi> hi

[11:20] *** satyavvd joined
[11:20] <azawawi> moritz: ping

[11:20] * jnthn could make it go away by making assignment coerce or die for non-Perl 6 types

[11:21] <jnthn> But I'd rather work out where the Parrot string is coming from.

[11:23] <azawawi> Just wanted to say that the latest development release of Wx::Scintilla now wraps the latest Scintilla 2.x. This means that we now have control over Perl and Perl 6 lexer in scintilla in Padre and other editors using Wx

[11:24] <azawawi> i started working on LexPerl6.cxx, should i use the spec as the source code for highlighting stuff

[11:24] <azawawi> or perl6-examples?

[11:24] <moritz> azawawi: pong

[11:25] <moritz> STD.pm6 is a pretty good, big chunk of Perl 6 code to test on

[11:26] <azawawi> so STD.pm6 and NieczaActions.pm6

[11:26] *** MayDaniel joined
[11:26] * moritz nods

[11:26] <azawawi> cool

[11:28] <moritz> http://wingolog.org/archives/2011/08/02/a-closer-look-at-crankshaft-v8s-optimizing-compiler might interest the compiler junkies

[11:29] *** odoacre left
[11:35] *** cosimo left
[11:40] *** azawawi left
[11:44] <tadzik> mmm, bacon for breakfast

[11:45] <tadzik> life doesn't get much better than that :)

[11:46] <moritz> $ ./perl6 -e 'class MyEx is Exception { }; try { MyEx.new().throw }; say $!.WHAT'

[11:46] <moritz> MyEx()

[11:46] <moritz> \o/

[11:47] <tadzik> yay!

[11:47] <moritz> yesterday I experimented with it, and only got segfaults and infinite loops as response

[11:48] <moritz> now I've decided to approach it differently, more bottom-up

[11:48] <dalek> rakudo/nom-exceptions: 8ea619d | moritz++ | NOMMAP.markdown:

[11:48] <dalek> rakudo/nom-exceptions: note a segfault in NOMMAP

[11:48] <dalek> rakudo/nom-exceptions: review: https://github.com/rakudo/rakudo/commit/8ea619d7c3

[11:48] <dalek> rakudo/nom-exceptions: 69e9988 | moritz++ | src/core/Exception.pm:

[11:48] <dalek> rakudo/nom-exceptions: extract payload from parrot excetions, if available

[11:48] <dalek> rakudo/nom-exceptions: review: https://github.com/rakudo/rakudo/commit/69e9988adb

[11:48] <dalek> rakudo/nom-exceptions: 0c51f85 | moritz++ | src/core/Exception.pm:

[11:48] <dalek> rakudo/nom-exceptions: in Exception, make sure we have a parrot exception before throwing

[11:48] <dalek> rakudo/nom-exceptions: review: https://github.com/rakudo/rakudo/commit/0c51f85bbd

[11:48] <moritz> and I've only modified src/core/*.pm files for it so far

[11:49] *** timbunce joined
[11:54] <takadonet> morning all

[11:59] *** pernatiy joined
[12:01] *** satyavvd left
[12:07] *** donri joined
[12:11] *** im2ee joined
[12:16] <tadzik> morning takadonet 

[12:22] <moritz> nom: multi d(*@a) { 1 }; multi d(Exception $x) { 2 }; say d Exception.new

[12:22] <p6eval> nom: OUTPUT«Ambiguous dispatch to multi 'd'. Ambiguous candidates had signatures:␤:(Positional @a)␤:(Exception $x)␤␤current instr.: 'd' pc 478 ((file unknown):485) (/tmp/PYK54132Gp:1)␤»

[12:22] <jnthn> that looks dubious 

[12:22] <jnthn> The non-slurpy should win, I think.

[12:22] <jnthn> can't investigate now

[12:22] <moritz> my attempts in the setting (with die()) have the slurpy one always win

[12:23] <moritz> yes, I agree

[12:23] <jnthn> Not so surprising there's an issue there - I've yet to get through triaging the multi tests.

[12:24] *** awoodland joined
[12:26] <moritz> .u ä

[12:26] <phenny> U+00E4 LATIN SMALL LETTER A WITH DIAERESIS (ä)

[12:27] *** im2ee left
[12:29] <tadzik> oh, da964eb128332cca8126543a413e905e24a9a75e is a fail

[12:29] *** BooK left
[12:30] <tadzik> in t/pod/07-tables.t last two tables have an identical ast tree

[12:30] * moritz again comments on checking $/.from and $/.to

[12:30] <tadzik> yes, that's what I'm up to no

[12:31] <tadzik> so the hash index would be from-to, rather than the id

[12:31] <tadzik> does infix:<~> stringify both sides, in nqp?

[12:33] <tadzik> seems so

[12:35] <dalek> rakudo/nom: 967ab7a | tadzik++ | src/Perl6/Actions.pm:

[12:35] <dalek> rakudo/nom: Use $/.from ~ ",' ~ $/.to as a POD block id when adding them to $=POD

[12:35] <dalek> rakudo/nom: 

[12:35] <dalek> rakudo/nom: The previous approach didn't work for two identical POD blocks existing

[12:35] <dalek> rakudo/nom: in the document, and caused a failure in t/pod/07-tables.t

[12:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/967ab7a168

[12:35] <dalek> rakudo/podparser: e028411 | jonathan++ | src/ (4 files):

[12:35] <dalek> rakudo/podparser: Register Capture type so we can use it in the binder.

[12:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/e0284114e1

[12:35] <dalek> rakudo/podparser: 3588736 | jonathan++ | src/core/Capture.pm:

[12:35] <dalek> rakudo/podparser: Fix a thinko.

[12:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/358873603f

[12:35] <dalek> rakudo/podparser: 0bc9883 | jonathan++ | src/ (2 files):

[12:35] <dalek> rakudo/podparser: Make |$c work again in signatures; $c becomes a Capture with the current unbound stuff in it.

[12:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/0bc9883a45

[12:35] <dalek> rakudo/podparser: d74aaa8 | tadzik++ | / (19 files):

[12:35] <dalek> rakudo/podparser: Merge branch 'nom' into podparser

[12:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/d74aaa8c6a

[12:36] <tadzik> hrm

[12:36] <tadzik> what is podparser doing here

[12:37] <moritz> you merged into podparser

[12:37] <tadzik> I just did 'git push', this must've pushed some old podparser commits already merged into nom and pushed, but not pushed to github/podparser

[12:38] <tadzik> ok if I remove that branch now?

[12:39] <moritz> what does 'git branch' says?

[12:39] <moritz> first,    git checkout nom

[12:39] <tadzik> nom

[12:39] <moritz> then git branch -D podparser

[12:39] <moritz> then

[12:39] <moritz> git push origin :podparser # note the colon

[12:39] <tadzik> yeah, I know how to do it :)

[12:40] <tadzik> just asking if to do it :)

[12:40] <moritz> if you don't need it anymore, delete it

[12:40] <moritz> note that in the end, you'll have to get a list of your commits to submit them to gsoc

[12:40] <donri> https://bitbucket.org/gward/vcprompt/ ;)

[12:41] <tadzik> huh

[12:41] <moritz> dunno if you need the branch for that... you can just go through the nom commit list

[12:41] <tadzik> I probably will. All commits done in the summer, not only those gsoc-related?

[12:44] <tadzik> donri: yeah, I have (nom) in my prompt :)

[12:46] <moritz> tadzik: all gsoc related commits

[12:46] <tadzik> oh, that'll require some work :)

[12:46] <tadzik> luckily, majority of my commits all gsoc related

[12:49] <donri> om nom nom

[12:57] *** Holy_Cow joined
[12:59] *** Holy_Cow left
[13:00] <masak> how old is 'our'? since v5.0.0?

[13:08] <[Coke]> nom: http://www.cnn.com/

[13:08] <p6eval> nom: OUTPUT«Confused at line 1, near "http://www"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[13:09] <[Coke]> does it only work on gist? ;)

[13:09] <moritz> yes

[13:10] <moritz> p6eval special-cases the URLs and follow the link to the raw text

[13:10] <[Coke]> *snap*

[13:23] *** stephanmg joined
[13:23] *** stephanmg left
[13:24] *** daniel-s joined
[13:24] *** shinobicl joined
[13:28] *** daniel-s left
[13:29] *** daniel-s joined
[13:31] *** jaldhar left
[13:33] *** daniel-s left
[13:33] *** daniel-s joined
[13:37] *** daniel-s left
[13:37] *** Chillance joined
[13:37] *** daniel-s joined
[13:38] *** mls_ joined
[13:38] <mls_> Hi perl6!

[13:38] <moritz> hello mls_ 

[13:38] <mls_> $dayjob is interfering with perl6 hacking quite a bit today ;(

[13:39] <PerlJam> good morning #perl6

[13:39] <tadzik> hello mls_, PerlJam 

[13:39] <moritz> good morning PerlJam 

[13:39] <moritz> mls_: as long as it pays the bills... 

[13:39] <mls_> right... ;)

[13:41] <jnthn> mls_: know the feeling :)

[13:42] *** daniel-s left
[13:42] *** daniel-s joined
[13:46] *** daniel-s_ joined
[13:46] *** daniel-s left
[13:47] <jnthn> nom: my %h = a => ['a','a'], b => ['b']; %h.pairs.max({ $^x.value.elems })

[13:47] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 620679 (src/gen/CORE.setting.pir:157473) (src/gen/CORE.setting:434)␤»

[13:47] <jnthn> Bug :(

[13:51] *** daniel-s__ joined
[13:51] *** daniel-s_ left
[13:51] *** smash joined
[13:52] <mls_> jnthn: did you already fix the lex problem in the CATCH handler (i.e. $_ and $! not being accessible)?

[13:53] <moritz> nom: try { die 'foo'; CATCH { say $! } }

[13:53] <p6eval> nom: OUTPUT«Any()␤»

[13:53] <moritz> looks like "no"

[13:53] <jnthn> mls_: no

[13:54] *** leprevost joined
[13:55] *** daniel-s__ left
[13:55] *** daniel-s__ joined
[13:57] *** mkramer joined
[13:58] <mls_> a simple workaround would be to make the code generate a capture_lex, but I'd prefer a real fix

[13:59] *** mkramer left
[14:00] <smash> hello everyone

[14:02] <moritz> \o smash 

[14:04] *** drbean left
[14:06] *** awoodland left
[14:09] *** uvtc joined
[14:10] <uvtc> azawawi: Great news about LexPerl6.cxx. azawawi++ . Besides Scite, I think Geany also uses Scintilla.

[14:11] <uvtc> azawawi: Thanks for doing it. :)

[14:14] <uvtc> phenny, tell azawawi http://irclog.perlgeek.de/perl6/2011-08-03#i_4215724

[14:14] <phenny> uvtc: I'll pass that on when azawawi is around.

[14:16] *** uvtc left
[14:20] *** Holy_Cow joined
[14:31] <[Coke]> lexperl6.cxx?

[14:32] <jnthn> mls_: The real fix is to finish the $! and $/ refactor so we really only give them to routines and then lookup them us as dynamics.

[14:32] <jnthn> That fixes $!

[14:33] <jnthn> $_ - the block should take a $_ as an implicit parameter, I suspect. so that's how $_ is set.

[14:33] <[Coke]> will fix, or has fixed?

[14:33] *** wamba left
[14:33] <jnthn> will fix

[14:33] <jnthn> Thing is that we still need the capture_lex though.

[14:33] <jnthn> I'm not sure why that is missing.

[14:34] <jnthn> oh, I bet it's not missing

[14:34] <jnthn> Just pointing to the real outer rather than the fake frame we insert for the handler.

[14:36] *** molaf joined
[14:38] *** birdwindupbird left
[14:40] *** wtw left
[14:51] <PerlJam> why can't people be more like #perl6 people?

[14:52] <[Coke]> PerlJam: oh, yah, like THAT would help.

[14:53] <[Coke]> ... you didn't mean sarcastic, did you.

[14:53] <moritz> PerlJam: then people wouldn't see a reason to come here anymore (except the awesome language, of course)

[14:54] <PerlJam> [Coke]: you remind me so much of this guy I work with  ;)

[14:54] <[Coke]> uhoh.

[14:54] *** Holy_Cow left
[14:55] <PerlJam> last night I had some family drama that could have been avoided if people were just a little more logical and forthright.

[14:55] <PerlJam> today I have work drama because people are having "communication" issues.

[14:56] <PerlJam> At least on #perl6 there's some humor to offset any drama  :)

[14:57] <PerlJam> (I mean, even just writing those sentences I had to wonder about the existence of a "forth wright" which has a bit of a humor component)

[15:00] <shinobicl> hi....      is Mu == undefined value?

[15:00] <PerlJam> shinobicl: most undefined :)

[15:00] <moritz> Mu is an undefined value, yes

[15:00] <shinobicl> is ok if a function of mine returns Mu when the arguments are not valid?

[15:01] <PerlJam> shinobicl: does it return some other typed info normally?

[15:01] <shinobicl> an Int

[15:01] <moritz> shinobicl: it's much saner to fail()

[15:01] <moritz> or to put the appropriate constraints into the signature

[15:02] <moritz> thing is, if a function returns Mu that would normally return an Int, the calling code either has to handle that case directly, or it will fail with a weird error

[15:02] <shinobicl> mmm... fail... that will throw an exception... well, is saner that way i guess

[15:02] <moritz> so rather throw an informative error in the first place

[15:03] *** koban left
[15:03] *** molaf left
[15:07] *** SHODAN left
[15:11] *** slavik left
[15:11] *** slavik joined
[15:12] *** colourspace joined
[15:12] *** wamba joined
[15:13] *** slavik left
[15:13] *** slavik joined
[15:18] *** xinming_ joined
[15:21] *** xinming left
[15:25] <masak> PerlJam: sometimes we're just as trigger-happily defensive, illogical, and trollable as on any other IRC channel. at least I am :)

[15:25] <masak> PerlJam: but yes, it is indeed offset by something which makes the overall atmosphere here feel very nice.

[15:25] * masak hugs everyone :)

[15:26] <masak> decommute &

[15:26] <PerlJam> no masak, you're WRONG  .... sorry, I can't channel tchrist long enough to build up a good novelesque rant :)

[15:26] <masak> :P

[15:27] <masak> you have until I get home to disprove me. then you goin' down :P

[15:27] *** masak left
[15:28] <PerlJam> But that's almost #perl6's motto (mission?) or something.    #perl6:  the friendly place.

[15:35] *** Doctor_Pi joined
[15:37] <Doctor_Pi> I'm having some problems building rakudo-star 2011-07. Should I report them here or the mailing lists?

[15:37] <PerlJam> Doctor_Pi: here is a good start.   

[15:37] <PerlJam> Doctor_Pi: what OS?  What problems?

[15:38] <Doctor_Pi> Mac OS X 10.5.8 on a PowerBook G4

[15:40] *** daniel-s__ left
[15:40] * jnthn home :)

[15:40] <PerlJam> Doctor_Pi: what are the problems exactly?

[15:42] <Doctor_Pi> My command "perl Configure.pl --gen-parrot --gen-parrot-option='--icu-config=/usr/local/bin/icu-config' does a whole bunch of stuff and then terminates with a "Unable to locate parrot-config" error.

[15:42] <flussence> s/gen-parrot-option/parrot-option/

[15:44] *** daxim left
[15:45] <Doctor_Pi> flussence: no, part is correct. I can see it finds icu-config with that part. The command was still terminating with just the --gen-parrot part.

[15:45] <Doctor_Pi> PerlJam: there is an earlier error message which I think is relevant. Let me find it and post it.

[15:49] *** JimmyZ joined
[15:56] * [Coke] returns from a meeting, and wonders if a forth wright is a like a mill wright.

[15:59] <Doctor_Pi> PerlJam: Argument "RELEASE_3_6_0" isn't numeric in addition (+) at Configure.pl line 25, <$REQ> line 1. Appears right after I run the command.

[15:59] <PerlJam> Hmm

[16:01] <[Coke]> I'm assuming that's rakudo's configure, not parrots.

[16:04] *** JimmyZ left
[16:05] <Doctor_Pi> PerlJam: wait a sec. There's more sorry and it was staring at in the face. I think I should use pastbin for the next part.

[16:09] <Doctor_Pi> PerlJam: http://pastebin.com/9WkYLULk

[16:10] <PerlJam> ah, evil pcre

[16:11] <PerlJam> you'll have to pass --without-pcre to parrot

[16:11] <PerlJam> (to parrot's config that is)

[16:11] <PerlJam> or install libpcre

[16:12] <[Coke]> probably have an older version in path somewhere that got picked up, and parrot's too stupid to deal with it.

[16:12] <[Coke]> PerlJam++

[16:12] <Doctor_Pi> I can have as many --gen-parrot-option as I want in the master Configure.pl?

[16:13] <PerlJam> Doctor_Pi: I think so, but I don't know for sure.

[16:13] <Doctor_Pi> or I can just add it in mty existing one

[16:14] <PerlJam> Doctor_Pi: alternatively, I think you can say --gen-parrot-option='--icu-config=... --without-pcre'

[16:15] *** broquaint joined
[16:16] <moritz> that won't work

[16:16] <moritz> I think you have to repeat --gen-parrot-option= for each option you want to pass on

[16:17] *** nine left
[16:17] *** nine joined
[16:17] *** [particle] left
[16:18] *** spetrea left
[16:18] *** sftp left
[16:19] *** spetrea joined
[16:19] *** sftp joined
[16:20] *** felher left
[16:21] <pmichaud> good morning, #perl6

[16:21] <Doctor_Pi> Let my try.

[16:24] <takadonet> pmichaud: morning

[16:24] *** yath left
[16:25] <Doctor_Pi> ok adding "--without-pcre" in the --gen-parrot-option to a preexisting option didn't work. Will repeat --gen-parrot-option.

[16:26] <[Coke]> karma pmichaud

[16:26] <aloha> pmichaud has karma of 1167.

[16:26] <[Coke]> pmichaud++o/

[16:26] <[Coke]> karma pmichaud

[16:26] <aloha> pmichaud has karma of 1168.

[16:28] <Doctor_Pi> moritz: you're right. One has repeat --gen-parrot-option= for each option you want to pass on.

[16:29] <pmichaud> nom:  my $x;  $x ^^= 42;  $x ^^ = 15;  say $x;

[16:29] <p6eval> nom: OUTPUT«Confused at line 1, near "$x ^^ = 15"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[16:29] <pmichaud> nom:  my $x;  $x ^^= 42;  $x ^^= 15;  say $x;

[16:29] <p6eval> nom: OUTPUT«Nil␤»

[16:29] <pmichaud> \o/

[16:30] *** yath joined
[16:32] *** noganex_ left
[16:33] <[Coke]> yay

[16:34] <shinobicl> continuing with throwing an exception for invalid data instead of just returning Mu... in a test, how should i test it? What is the variable for capturing the error after the "try" ?

[16:34] <PerlJam> shinobicl: $!

[16:35] <moritz> shinobicl: dies_ok { your_func("invalid arguments") }, 'description';

[16:36] <PerlJam> shouldn't that be fails_ok  :)

[16:37] <moritz> nom: use Test; sub f() { fail('a') }; dies_ok { f() }

[16:37] <p6eval> nom: OUTPUT«not ok 1 - ␤»

[16:37] <moritz> hm

[16:37] <pmichaud> fail doesn't throw an exception, it returns a value.

[16:37] <moritz> I guess it should just call the closure in sink context

[16:38] <moritz> which would then rethrow

[16:38] <shinobicl> cool.. thanks moritz

[16:38] <moritz> nom: use Test; sub f() { fail('a') }; isa_ok f, Failure

[16:38] <p6eval> nom: OUTPUT«ok 1 - The object is-a 'Failure'␤»

[16:39] <PerlJam> moritz++ you can never have too much karma

[16:39] <moritz> pmichaud: any comments on the nom-exceptions branch?

[16:39] <pmichaud> moritz: didn't know there was one... looking.

[16:40] <pmichaud> (or maybe I knew but forgot)

[16:40] <moritz> pmichaud: it doesn't regress anything, but doesn't add too much either... my attempt to add a die() multi that throws an existing exception failed due to a dispatchy detail

[16:40] <moritz> oh, it's new

[16:42] *** noganex joined
[16:43] <pmichaud> +    my Mu $payload   := nqp::atkey($parrot_ex, 'payload');

[16:43] <pmichaud> +    my $ex := pir::defined($payload) ?? $payload !! nqp::create(Exception);

[16:43] <pmichaud> that looks... wrong.

[16:43] <pmichaud> I don't think that $!ex should be anything other than a Parrot Exception.

[16:43] <[Coke]> pmichaud: if I go to 123people.com and search for my name, I see your picture under "related pictures". (but not mine). The internets are creepy.

[16:43] *** mj41 left
[16:44] <pmichaud> [Coke]: it's just the electronic version of tabloids, I suspect.  :-/

[16:46] *** Moukeddar joined
[16:47] <PerlJam> [Coke]: does you picture show up when you search for pmichaud's name?  :)

[16:47] <PerlJam> s/you/your/

[16:47] <pmichaud> PerlJam: doesn't look like it.

[16:48] <moritz> pmichaud: that's not the parrot exception, but the one we pass to the user

[16:49] <moritz> pmichaud: and the idea is to attach a Perl 6 exception as a payload of the parrot exception, and unwrap before we turn it to p6 land

[16:49] <PerlJam> [Coke]: Apparently you're 39.  All of the Premium Public Records show age: 39

[16:49] *** wolfman2000 joined
[16:50] <moritz> pmichaud: and only in the cases were the parrot exception doesn't have a payload do we create a new Perl 6 exception object

[16:50] <[Coke]> PerlJam: maaaaaaaaayb

[16:54] *** [particle] joined
[16:55] <pmichaud> moritz: but what about Parrot exceptions that already have a payload?

[16:55] <pmichaud> (that aren't Perl 6 exceptions?)

[16:56] *** avar left
[16:56] <moritz> pmichaud: those never occur in the whole spectest suite

[16:56] <moritz> pmichaud: but I agree that we should guard against those

[16:56] *** athomason joined
[16:56] <pmichaud> I'm certain that our testing of Exceptions is underdone

[16:57] <pmichaud> this repeated argument of "it doesn't occur in the spectest suite" is getting a little stale, given that we know the spectest suite is really not very complete on edge cases.

[16:57] <pmichaud> or in new features.

[16:58] <moritz> but the test coverage won't increase unless somebody implements these features

[16:58] <PerlJam> pmichaud: I thought it was an invitation to add more tests

[16:58] <[Coke]> pmichaud: no, but it's a reasonable starting point, esp. for people like me who don't necessarily know any big picture items.

[16:59] <moritz> so, coming back to the original discussion, would you be fine with the branch if I additionally check if the payload is a 6model object?

[16:59] <moritz> or ~~ Any or so?

[16:59] *** Moukeddar left
[16:59] <pmichaud> I want to know more about what problem is trying ot be solved here, first.

[16:59] <moritz> throwing and returning more than type of exceptions

[16:59] *** literal left
[17:00] *** literal joined
[17:00] <pmichaud> example?

[17:00] <moritz> in nom and master, if you subclass Exception, throw it and catch it, you an Exception, not an object of your subclass

[17:00] *** Gothmog_ left
[17:00] *** Gothmog_ joined
[17:00] <moritz> nom: class A is Exception { }; try { die A.new }; say $!.WHAT

[17:00] <p6eval> nom: OUTPUT«Exception()␤»

[17:01] <pmichaud> nom:  class A is Exception { };  try { A.new.throw };  say $!.WHAT

[17:01] <p6eval> nom: OUTPUT«Exception()␤»

[17:02] <moritz> in the long run I want to throw lots of different exception classes/objects

[17:02] <pmichaud> okay, I understand that part.

[17:02] <moritz> like X::Comp, X::IO etc.

[17:03] <[Coke]> +1 there.

[17:03] *** tokuhirom joined
[17:03] <pmichaud> I think it's a mistake in .throw()  to rebind $!ex without possibly saving the old value somewhere.

[17:04] <pmichaud> I'm wondering if a new Parrot Exception should be created when the Perl 6 Exception object is created, instead of when it's thrown.

[17:04] *** avar joined
[17:04] *** avar left
[17:04] *** avar joined
[17:04] <pmichaud> (i.e., in .BUILD or .new instead of .throw)

[17:05] *** noganex left
[17:07] <pmichaud> also, I should note that we do have Parrot Exceptions that carry payloads -- all of the control exceptions do so.

[17:07] <moritz> pmichaud: I think the correct solution is to call a method on the Perl 6 exception object, so that it can decide what do with it (replace, stack or ignore)

[17:08] <pmichaud> I'm having trouble parsing "it" there

[17:09] <pmichaud> s/parsing/binding/

[17:09] <moritz> it == the parrot exception

[17:09] <pmichaud> for both "it"s?

[17:09] *** pernatiy left
[17:09] <moritz> no, the second

[17:11] <flussence> .oO( English needs more pronouns... or named variables )

[17:11] <pmichaud> I think named variables are called "nouns".  ;-)

[17:11] *** noganex joined
[17:12] <moritz> I think we should have some contranouns that go with the pronouns

[17:13] <PerlJam> .oO(anti-nouns?)

[17:13] <pmichaud> anyway, checking that the payload is a 6model object doesn't seem that useful to me.  All of the payloads that I think we encounter are likely to be Perl 6 objects.  They just aren't necessarily Perl 6 Exceptions.

[17:13] <pmichaud> i.e., I'm against the assumption that the payload is a Perl 6 Exception.

[17:13] <pmichaud> (because it's false)

[17:14] <moritz> does &EXCEPTION ever see control exceptions?

[17:14] <pmichaud> I suspect it would, for CONTROL blocks.

[17:15] <moritz> ok

[17:15] *** Holy_Cow joined
[17:15] *** Holy_Cow left
[17:15] <moritz> so, checking ~~ Exception?

[17:15] <moritz> (or X::Base, once we get to it)

[17:15] <pmichaud> somehow I wish we were checking the type of the Parrot Exception instead of the payload.

[17:15] <pmichaud> I can conceive of having an exception that carries another exception as its payload.

[17:16] <moritz> so, introspect the 'type' attribute of the parrot exception? or subclass it, check its type?

[17:17] <pmichaud> one of those two, maybe.  I'm not really sure.

[17:17] <pmichaud> It would really help to have a lot more use cases.

[17:17] <moritz> what kind of use cases?

[17:17] <pmichaud> that's what I'm missing at the moment -- a set of use cases that help to illuminate the problem space.

[17:17] <moritz> my current one is basically

[17:17] <pmichaud> what will be creating the exceptions?

[17:18] <moritz> die(), or X::Something.new()

[17:18] <pmichaud> yeah, but that doesn't seem to really illuminate the problem space for me.

[17:18] *** kaare_ joined
[17:18] <moritz> try { eval $somestring; CATCH { given X::Comp { say 'Could not compile your input, sorry' } } } 

[17:19] <moritz> pmichaud: that's why I'm asking what kind of use cases you want

[17:19] <pmichaud> s/given/when/  ?

[17:19] <moritz> erm, yes

[17:19] <moritz> sorry

[17:19] <pmichaud> okay, that's a lot more helpful.

[17:19] <pmichaud> so, in that case, eval() has to be able to generate a X::Comp exception

[17:20] <moritz> yes

[17:20] <moritz> or more accurately, the compiler

[17:20] <moritz> into which eval() calls

[17:20] <pmichaud> well, I suspect eval() has to catch the exception from the compiler.  The compiler might not know about Perl 6 Exceptions -- might not be Perl at all.

[17:21] *** kjeldahl_ joined
[17:21] <pmichaud> i.e., eval() has to catch the exception from the compiler, and convert it to an appropriate X::Comp exception.

[17:21] *** impious joined
[17:21] *** kjeldahl_ left
[17:23] *** noganex left
[17:24] <pmichaud> although since it's in a try block already, I guess any exception coming back from a (foreign?) compiler will have already gone through &EXCEPTION, at least as things currently stand.

[17:24] <moritz> sorry, have to run, bbi3h

[17:24] <pmichaud> okay, I'll keep thinking on the issue.

[17:27] *** benabik joined
[17:31] <pmichaud> Today's forecast high temperature:   109degF  (42.8degC)    :-(

[17:32] <PerlJam> pmichaud: according to my iphone, it's only 102 degF though  ;)

[17:32] * PerlJam suddenly feels slightly happier about 95 degF

[17:32] *** tcunha left
[17:33] <flussence> jeez, I get worried when my CPU gets that hot...

[17:33] <pmichaud> my outdoor thermometer currently reads 105.8

[17:34] <pmichaud> overnight low temperature was 87.5  :-(

[17:36] <sjohnson> yikes.com

[17:36] <sjohnson> that's hot!

[17:36] *** masak joined
[17:36] <masak> evening, #perl6.

[17:36] <jnthn> pmichaud: Ouch! :O

[17:36] <pmichaud> masak!  o/

[17:36] <jnthn> yay tis masak!

[17:36] <colomon> \o

[17:36] * jnthn has a $dayjob free evening. Dinner first, then hopefully some decent nom hacking :)

[17:36] <masak> PerlJam: I'm not saying #perl6 isn't a very friendly place. it is.

[17:37] <PerlJam> masak: I know ... I was just messing with you.

[17:37] <masak> PerlJam: I'm saying that it's a friendly place not because the people here are exceptionally friendly, although they probably are...

[17:37] <masak> PerlJam: ...but because we work on it, consciously and as a group.

[17:37] <PerlJam> yeah, it's our hug-culture

[17:38] <masak> for each year that passes, I'm happy to realize that it seems to work even as we scale up.

[17:38] <masak> hopefully the early seeding of friendliness will overpower the inevitable dilution of growing.

[17:39] <pmichaud> that's been my experience in another forum as well.  As long as the seeding takes hold, momentum goes a long way.

[17:43] <takadonet> masak: My sudoku solver did not finish even over night :(

[17:44] *** M_o_C joined
[17:44] *** M_o_C left
[17:44] *** M_o_C joined
[17:46] *** molaf joined
[17:46] <mls_> finished $dayjob (this day: openssl hacking). back to nom...

[17:50] *** nsh left
[17:50] *** sbp left
[17:55] <masak> takadonet: that just means you need to find another approach. could be worse. :)

[17:55] <takadonet> ya well going to test it now to ensure that it works using a VERY simple sudoku puzzle

[17:56] <takadonet> i was getting some weird uninitizal error but they got fix  with updates to nom branch

[17:58] *** nsh joined
[17:59] *** sbp joined
[17:59] <takadonet> well it works but getting some warnings message...

[18:00] <takadonet> bbl

[18:03] *** mkramer joined
[18:04] *** mkramer left
[18:16] *** felher joined
[18:22] <Doctor_Pi> make spectest in the rakudo subdirectory is giving me "fatal: not a git repository" right after "cd t/spec && git fetch &&  git checkout rakudo-master && git merge origin/rakudo-master" . The tests are running anyways.

[18:31] *** Mowah joined
[18:40] *** am0c left
[18:44] <dalek> niecza: 8e562ff | sorear++ | lib/CORE.setting:

[18:44] <dalek> niecza: Fix crash on Range iteration

[18:44] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8e562ff810

[18:46] <sorear> good * #perl6

[18:47] *** espadrine left
[18:49] <[Coke]> sorear: hio.

[18:50] <masak> o/ sorear 

[18:52] *** Trashlord left
[18:54] *** Trashlord joined
[18:57] *** survery joined
[18:57] *** survery left
[18:58] *** aindilis left
[18:58] *** aindilis joined
[19:00] *** pernatiy joined
[19:01] *** M_o_C left
[19:06] *** jjore left
[19:06] *** jjore joined
[19:07] *** [Coke] left
[19:09] *** [Coke] joined
[19:13] <sorear> ok, that last commit took 50 failed test files down to 4

[19:13] <masak> \o/

[19:14] <sorear> nom: enum Foo < A B C >; say Foo::A.Str

[19:14] <p6eval> nom: OUTPUT«A␤»

[19:15] <sorear> nom: say True.gist

[19:15] <p6eval> nom: OUTPUT«Bool::True␤»

[19:15] <sorear> nom: say ~True

[19:15] <p6eval> nom: OUTPUT«Bool::True␤»

[19:16] <masak> nom: say True ~~ *

[19:16] <p6eval> nom: OUTPUT«Bool::True␤»

[19:19] <dalek> roast: fc26150 | sorear++ | S02-builtin_data_types/bool.t:

[19:19] <dalek> roast: [S02-builtin_data_types/bool.t] Update for new Enum .gist/.Str rules

[19:19] <dalek> roast: review: https://github.com/perl6/roast/commit/fc26150604

[19:21] *** localhost joined
[19:22] <sorear> nom: say item Nil

[19:22] <p6eval> nom: OUTPUT«Could not find sub &item␤current instr.: '_block1002' pc 79 ((file unknown):12758678) (/tmp/7T4gPHTNrr:1)␤»

[19:23] <pmichaud> ooc, does the spec list the stringification of Bool anywhere?

[19:23] * masak .oO( if it's an enum, yes... )

[19:23] <pmichaud> wfm

[19:23] <sorear> the spec defines Bool as an enum

[19:24] <masak> rakudo: say item Nil

[19:24] <p6eval> rakudo 922500: OUTPUT«␤»

[19:24] <pmichaud> rakudo:  say (item Nil).WHAT

[19:24] <masak> rakudo: say (item Nil).WHAT

[19:24] <sorear> I think there should probably be a (Note: Implementations are not required to actually use the 'enum' keyword, due to circularity issues.  However Bool should *act* as if it were an enum.)

[19:24] <p6eval> rakudo 922500: OUTPUT«Seq()␤»

[19:24] <sorear> I'm wondering what the signature of item should be

[19:25] <sorear> currently in niecza it's sub item(Mu $x) { $x }

[19:25] <sorear> niecza: say item Nil

[19:25] <p6eval> niecza v8-26-g6b9d707: OUTPUT«Unhandled exception: No value for parameter Mu $x in CORE item␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE item @ 0) ␤  at /tmp/NQHWqVlYjT line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1964 (CORE C920_ANON @ 2) ␤  at …

[19:25] <jnthn> eww

[19:25] <sorear> I'm considering a change to 'Mu $x?'

[19:25] <sorear> jnthn: what at?

[19:26] <jnthn> Nil doing that.

[19:26] <pmichaud> item parses as a list operator.

[19:27] <sorear> jnthn: turning to Seq, or being ignored by the binder?

[19:27] <jnthn> sorear: Requring a special case in the binder.

[19:27] <sorear> S02:2244

[19:28] <jnthn> Yes, I know what the spec says. It doesn't mean I have to agree it's a good idea. :)

[19:28] *** noganex joined
[19:34] *** [particle] left
[19:35] <flussence> ohai, I let that script run for a week: https://github.com/flussence/specgraphs/raw/master/output/rakudo-tests.png

[19:35] <flussence> (the output's still a bit messy but the data's there)

[19:37] <jdhore> flussence, I'm guessing the green line is nom?

[19:37] <flussence> it's all nom, the lines are pass/fail/something

[19:37] <flussence> I don't think they're stacked quite right...

[19:38] <jdhore> ah

[19:40] <flussence> there's a script and csv file to do this in rakudo/docs & rakudo/tools already, but the data for it hasn't been updated in ages

[19:40] *** [particle] joined
[19:42] <flussence> and GD::Graph isn't all that pretty to look at IMO, so I wrote another one more or less from scratch using Chart::Gnuplot. still getting the hang of it though...

[19:43] * moritz back

[19:44] <jnthn> o/ Mowah 

[19:44] <jnthn> er

[19:44] <jnthn> o/ moritz 

[19:45] <jnthn> darn tab key not being smart enough

[19:45] <dalek> rakudo/nom: 21977e8 | jonathan++ | src/binder/types. (2 files):

[19:45] <dalek> rakudo/nom: Add a way to store Nil in preperation for handling it in more cases.

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/21977e881e

[19:45] <dalek> rakudo/nom: 07c976f | jonathan++ | src/binder/ (3 files):

[19:45] <dalek> rakudo/nom: Transform a segfault into an exception (moritz++ for reporting).

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07c976f46d

[19:45] <dalek> rakudo/nom: 1519560 | jonathan++ | NOMMAP.markdown:

[19:45] <dalek> rakudo/nom: Remove one completed goal from NOMMAP, as well as one that's kinda too vague to be useful.

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15195609ed

[19:47] <jdhore> "Probably many our things become my things."   <--- If you had no context, this sentence would be hilariously nonsensical.

[19:48] <jnthn> :)

[19:49] <jnthn> S02-builtin_data_types/pair.t seems to think you should be able to do $pair.key := "KEY"

[19:49] <jnthn> imo, binding doesn't work in this case

[19:50] <jnthn> (e.g. that's not one of the LHS forms we should be able to bind to)

[19:50] <sorear> +1

[19:50] <sorear> absolutely no binding to method returns.  ever.

[19:51] <moritz> feel free to kick out that test

[19:51] <jnthn> \o/

[19:51] <pmichaud> ...then how does   @a[$x] := ...   work?

[19:52] <dalek> features: 3f6c104 | larry++ | features.json:

[19:52] <dalek> features: add pseudo packages

[19:52] <dalek> features: review: https://github.com/perl6/features/commit/3f6c104268

[19:52] <pmichaud> I'm fine with saying that Pair.key cannot be rebound -- S02:1505 seems to say as much.

[19:53] <jnthn> pmichaud: Syntactic form.

[19:54] <TimToady> Lisp programmers might want to change a cdr though...

[19:54] <jnthn> pmichaud: It becomes something like @a.postcircumfix:<[ ]>($x, :BIND(...)) or some such.

[19:55] * TimToady is back from a morning-long power feyl

[19:55] <PerlJam> "power feyl"?

[19:55] * moritz thought that wouldn't happen in civilized lands

[19:55] <PerlJam> is that phonetic or should I be googling?

[19:56] <TimToady> we're out in the Wild West

[19:56] <pmichaud> they're threatening rolling blackouts here

[19:56] <moritz> PerlJam: fonetic :-)

[19:57] <sorear> fēl or fīl?

[19:57] <dalek> roast: cc48639 | jonathan++ | S02-builtin_data_types/pair.t:

[19:57] <dalek> roast: Toss tests that rely on being able to bind to a method return value.

[19:57] <dalek> roast: review: https://github.com/perl6/roast/commit/cc486395ae

[19:58] <pmichaud> S02 explicitly says that a Pair's value may be rebound.

[19:58] <PerlJam> TimToady, jnthn: do you guys ever talk with Stevan about the P5 mop stuff?  

[19:58] <pmichaud> Perhaps that's syntactic also via .{ }

[19:58] <TimToady> occasionally

[19:58] <moritz> PerlJam: I did, just the other day

[19:59] *** ab5tract left
[19:59] <jnthn> PerlJam: Haven't really done that...though I read pretty much all of Moose core while doing research for 6model. :)

[19:59] <jnthn> Would be interesting to meet/chat with him more at some point :)

[20:00] <moritz> nickname stevan on irc.perl.org

[20:00] <sorear> question: my $x = 2; my $y = foo => $x; $y.value = 5; say $x

[20:00] <PerlJam> moritz: does he have any art we can steal for p6?  :-)

[20:01] <sorear> nothingmuch can be blamed for niecza's existance.  I came to p6 via #moose

[20:01] <jnthn> sorear: At a guess, no

[20:01] <jnthn> sorear: Too much spooky action at a distance.

[20:01] <masak> nothingmuch++

[20:01] <jnthn> nom: my $foo = 42; say (:$foo).perl

[20:01] <p6eval> nom: OUTPUT«"foo" => 42␤»

[20:02] <moritz> PerlJam: he takes a quite different approach (classes are like lexpads, and objects are like closure clones of such lexpads)

[20:02] <jnthn> oh, that works, the test requires on eqv on pairs which I guess doesn't work

[20:02] <masak> jnthn: parens not necessary.

[20:02] <masak> nom: my $foo = 42; say :$foo.perl

[20:02] <p6eval> nom: OUTPUT«"foo" => 42␤»

[20:02] <jnthn> masak: I know, but my brain groups it wrong otherwise. :/

[20:03] <moritz> PerlJam: it's interesting, and it fits well into p5 think in some way, but so far I don't see that we can or should steel from that

[20:03] <masak> jnthn: mine too :)

[20:03] <jnthn> I always do a double take when I see in C#:

[20:03] <jnthn> new Foo().some_method();

[20:03] <masak> jnthn: prefix ops are usually tighter than that.

[20:03] <masak> jnthn: oh yes, me too, in Java.

[20:03] <jnthn> I always paren it.

[20:04] <masak> jnthn: not to mention A.new B()

[20:04] <jnthn> ...lolwut? :)

[20:04] <masak> I think that was how it was done.

[20:04] <masak> dreadful.

[20:04] <jnthn> Maybe in Java :P

[20:04] <masak> in Java, yes.

[20:04] <jnthn> I don't think C# has an atrocity like that. :P

[20:04] <masak> :P

[20:06] *** localhost left
[20:07] *** lichtkind joined
[20:09] <jnthn> Woo, with some patches I'm trying now we should have most of pair.t back :)

[20:09] <pmichaud> I'm working on bool.t

[20:09] <jnthn> All but one test, that master passed, hopefully.

[20:09] <jnthn> pmichaud: ok :)

[20:10] <moritz> jnthn: do you have eqv for Pair/Enum, or should I push it?

[20:10] <moritz> (need a few more minutes for compilation :/)

[20:10] <jnthn> moritz: I have one compiling now, fairly confidnet it'll work.

[20:11] <moritz> +multi sub infix:<eqv>(Enum:D $a, Enum:D $b) {

[20:11] <moritz> +    $a.key eqv $b.key && $a.value eqv $b.value;

[20:11] <moritz> +

[20:11] <moritz> +}

[20:11] <jnthn> mine also does $a.WHAT === $b.WHAT

[20:11] <moritz> jnthn++

[20:11] <moritz> our eqv overlord

[20:12] <jnthn> :P

[20:12] * jnthn starts going through spectest.data and making a shortlist of test files to focus on 

[20:12] <pmichaud> What should True.value return, ooc?

[20:13] <jnthn> S03-operators/minmax.t # LHF I suspect, if anyone wants to take it :)

[20:13] <moritz> pmichaud: 1?

[20:13] <pmichaud> should it be 1 or True?

[20:14] <sorear> perl6: say True.value

[20:14] <moritz> enum A <b c d>; say b.key

[20:14] <p6eval> rakudo 922500: OUTPUT«Method 'value' not found for invocant of class 'Bool'␤  in main program body at line 22:/tmp/AfURRSQE8X␤»

[20:14] <p6eval> ..pugs: OUTPUT«*** No such method in class Bool: "&value"␤    at /tmp/cdHr2RRN5t line 1, column 5 - line 2, column 1␤»

[20:14] <p6eval> ..niecza v8-27-g8e562ff: OUTPUT«1␤»

[20:14] <moritz> perl6: enum A <b c d>; say b.key

[20:15] <sorear> perl6: enum B < F T >; say T.value

[20:15] <p6eval> pugs: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/49xtY90TNi line 1, column 1-15␤»

[20:15] <p6eval> ..rakudo 922500, niecza v8-27-g8e562ff: OUTPUT«b␤»

[20:15] <p6eval> rakudo 922500, niecza v8-27-g8e562ff: OUTPUT«1␤»

[20:15] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/JTEuvalht3 line 1, column 1-15␤»

[20:15] <pmichaud> so have we accepted that Bool ~~ Int, then?

[20:15] <moritz> nom: enum B < F T >; say T.value

[20:15] <p6eval> nom: OUTPUT«1␤»

[20:15] <masak> pmichaud: that seems to be the consequence of the current spec.

[20:15] <moritz> pmichaud: it might ~~ uint1 or so

[20:15] <masak> moritz: but uint1 ~~ Int

[20:16] <moritz> masak: does it? I'm uncertain about the native types

[20:16] <masak> moritz: IIUC all native types ~~ their corresponding capital-letter type.

[20:17] *** localhost joined
[20:17] <pmichaud> are .pick and .roll for enums defined only on the enum itself, or for the enumerated values also?

[20:17] <pmichaud> i.e.,    True.pick   versus Bool.pick

[20:17] <sorear> doesn't True.^methods eqv Bool.^methods?

[20:18] <pmichaud> sure, but one can distinguish on :D versus :U

[20:18] <masak> feels to me True.pick should always return True.

[20:18] <pmichaud> more tellingly

[20:18] <masak> 'night, #perl6

[20:18] *** masak left
[20:18] <pmichaud> enum Coin <Heads Tails>;   say Coin.pick;   say Heads.pick

[20:18] <jnthn> masak is right about the native/capital letter type thing.

[20:18] <pmichaud> nom: enum Coin <Heads Tails>;  say Coin.defined;

[20:19] <p6eval> nom: OUTPUT«Bool::False␤»

[20:19] <pmichaud> nom: enum Coin <Heads Tails>;  say Coin.WHAT;

[20:19] <p6eval> nom: OUTPUT«Coin()␤»

[20:19] <jnthn> Coin is a type object.

[20:19] <pmichaud> nom: enum Coin <Heads Tails>;  say Coin.^parents;

[20:19] <p6eval> nom: OUTPUT«Int() Real() Numeric() Cool() Any() Mu()␤»

[20:19] <jnthn> Though note it's HOW is not ClassHOW, but rather EnumHOW.

[20:19] <jnthn> *its#

[20:19] <[Coke]>  /* I do */ new Foo().stuff() /* all the time in ColdFusion */

[20:19] *** mattp_ left
[20:20] <[Coke]> (me was further in backscroll than me thought)

[20:20] <pmichaud> nom:  enum Coin <Heads Tails>; say Coin.pick;

[20:20] <p6eval> nom: OUTPUT«Coin::Heads␤»

[20:20] <pmichaud> nom:  enum Coin <Heads Tails>; say Coin.pick(2);

[20:20] <p6eval> nom: OUTPUT«Heads Tails␤»

[20:20] <pmichaud> nom:  enum Coin <Heads Tails>; say Coin.roll(3);

[20:20] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤Use of uninitialized value in string context␤  ␤»

[20:20] <jnthn> o.O

[20:20] <pmichaud> nom:  enum Coin <Heads Tails>; say Coin.list;

[20:20] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤␤»

[20:21] <pmichaud> where is Coin.pick coming from?

[20:21] <jnthn> pmichaud: my role Enumeration 

[20:21] <jnthn> pmichaud: src/core/Enumeration.pm

[20:21] <pmichaud> okay.

[20:22] <pmichaud> nom:  enum Coin <Heads Tails>; say Heads.pick(2);

[20:22] <p6eval> nom: OUTPUT«Heads Tails␤»

[20:22] <pmichaud> that feels wrong to me.

[20:22] <jnthn> pmichaud: How so?

[20:22] <jnthn> oh, I guess I can kinda see why.

[20:22] <jnthn> Hm

[20:22] <pmichaud> it's like saying that   2.pick(2)  should be able to return two Ints

[20:22] <pmichaud> (neither of which are 2)

[20:22] *** wallberg joined
[20:22] <jnthn> yeah

[20:22] <pmichaud> nom:  enum RGB <Red Green Blue>;  say Red.pick

[20:22] <p6eval> nom: OUTPUT«RGB::Blue␤»

[20:22] <jnthn> :)

[20:23] <pmichaud> I vote to put a :U on that

[20:23] <jnthn> *nod*

[20:23] <jnthn> We can.

[20:23] <pmichaud> I'll do that...

[20:23] <TimToady> or :A, by new spec

[20:23] <jnthn> Feel free to try it.

[20:23] <TimToady> :U includes failures

[20:23] <jnthn> TimToady: That new spec...needs some thought.

[20:23] *** localhost left
[20:23] <jnthn> TimToady: It's not in the slightest bit the kind of change I wanted there.

[20:24] <TimToady> but you always carp :)

[20:24] <TimToady> and sometimes you're right :)

[20:24] <pmichaud> I learned long ago to be wary of asking for changes (in S05).  :-)

[20:24] <moritz> new spec? from when?

[20:25] <PerlJam> moritz: just the :A :U :D trichotomy

[20:25] *** localhost joined
[20:25] <jnthn> TimToady: I wanted :U and :D (or whatever we call them) to be low-level, very cheap REPR-level operations.

[20:25] <moritz> is :D the default now?

[20:25] <jnthn> Not sugar for (expensive) *.defined

[20:26] <jnthn> It's a circularity issue as well as a cost one.

[20:30] *** localhost left
[20:31] *** timbunce left
[20:31] *** slavik left
[20:35] <TimToady> it's intended to be low-level, the *.defined is just a high-level view of whatever the bit is

[20:35] <moritz> .defined is overridable

[20:35] <sorear> *.Mu::defined? :)

[20:37] <dalek> roast: faf8b59 | jonathan++ | S02-builtin_data_types/pair.t:

[20:37] <dalek> roast: Fudge 1 test for Rakudo (review/fix welcome).

[20:37] <dalek> roast: review: https://github.com/perl6/roast/commit/faf8b59725

[20:37] <pmichaud> jnthn: before I do any Enumeration thingies I probably need to wait for your pair changes.

[20:38] *** timbunce joined
[20:38] <jnthn> pmichaud: Just pushed.

[20:38] <pmichaud> In S12, why is

[20:38] <pmichaud>     Day.enums   # map of key/value pairs

[20:38] <pmichaud> not called Day.pairs ?

[20:38] *** bbkr1 joined
[20:39] *** bbkr1 left
[20:39] <moritz> because it returns enums, not pairs?

[20:39] <jnthn> pmichaud: iiuc, .paris would return a list of pairs; .enums returns an EnumMap.

[20:39] <dalek> rakudo/nom: 8443d11 | jonathan++ | src/core/ (2 files):

[20:39] <dalek> rakudo/nom: Implement eqv for Enum (and thus Pair).

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8443d11710

[20:39] <dalek> rakudo/nom: 40f4264 | jonathan++ | src/core/Pair.pm:

[20:39] <dalek> rakudo/nom: Assignable .key and .value for Pair.

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40f4264cec

[20:39] <dalek> rakudo/nom: e9ee086 | jonathan++ | src/core/Enum.pm:

[20:39] <dalek> rakudo/nom: Enum.invert (inherited by Pair).

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e9ee086e48

[20:39] <dalek> rakudo/nom: c048df8 | jonathan++ | t/spectest.data:

[20:39] <dalek> rakudo/nom: Add a passing test file.

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c048df8f8b

[20:39] <jnthn> That's +90 or so tests. :)

[20:40] <pmichaud> (returns EnumMap) makes sense then.

[20:40] <pmichaud> Should we define .pairs then to be .enums.pairs, ooc?

[20:40] <jnthn> It'd be an easy way to implement it, if nothing else. :)

[20:40] <pmichaud> same for .keys and .values ?

[20:40] <jnthn> wfm

[20:40] <jnthn> .oO( didn't I already do it that way? :) )

[20:41] <pmichaud> .enums appears to be NYI

[20:41] <pmichaud> oh, wait, it's there.

[20:41] <jnthn> pmichaud: it's there

[20:41] <pmichaud> .keys and .values and .pairs are NYI

[20:41] <jnthn> but .keys and...right :)

[20:42] <pmichaud> seems like ^enum_values is misnamed.  Ought to be ^enum_map

[20:42] <pmichaud> since one gets back more than just the values.

[20:42] <jnthn> *nod*

[20:43] <jnthn> Probably a leftover from when I was exploring how to do EnumHOW. :)

[20:43] <dalek> roast: 3915649 | pmichaud++ | S02-builtin_data_types/bool.t:

[20:43] <dalek> roast: Unfudge some passing bool.t tests.

[20:43] <dalek> roast: review: https://github.com/perl6/roast/commit/3915649758

[20:44] <dalek> rakudo/nom: 0cd9e76 | pmichaud++ | src/core/Bool.pm:

[20:44] <dalek> rakudo/nom: Add some enum-like methods to Bool.

[20:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cd9e76cb2

[20:45] <pmichaud> it feels like .enums, .hash, and .pairs have some ambiguous overlap here.

[20:46] <pmichaud> I had the impression that Pair.key is supposed to be immutable.

[20:47] <pmichaud> S02:1504

[20:47] <pmichaud> "As with C<Hash> types, C<Pair> and C<PairSeq> are mutable in their

[20:47] <pmichaud> values but not in their keys."

[20:48] <jnthn> Oh.

[20:48] <jnthn> Then I was misled by both the tests and master :)

[20:48] <TimToady> it's not clear whether that's just a foolish consistency

[20:48] <pmichaud> I think the tests predate that spec change.

[20:48] <pmichaud> (by a lot.)

[20:49] <pmichaud> should Enum.invert return a Pair, or an Enum ?

[20:49] *** slavik joined
[20:51] <TimToady> I would guess Enum

[20:51] <pmichaud> Pair.invert also returns an Enum, or a Pair?

[20:51] <TimToady> I would guess Pair for that

[20:51] <TimToady> but I guess we really need to see use cases

[20:52] <jnthn> nom: say Enum.new(:key<a>, :value(1)); say Pair.new(:key<a>, :value(1));

[20:52] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[20:52] <TimToady> I'm just a bit slow to automatically convert between mutables and immutables

[20:52] <pmichaud> I agree, thus my questions.  :)

[20:52] <jnthn> pmichaud: If the above .new calls both work we can self.new ... :)

[20:52] <pmichaud> it looks like pairs/enums/hashes have some really fuzzy lines about that at the moment.

[20:53] <pmichaud> jnthn: self.new is what I was going to switch to, yes.  :)

[20:53] <TimToady> well, hashes are funny because we treat the keys as immutable but the values as mutable

[20:53] *** Mowah left
[20:53] <pmichaud> yes, but that can be true with Pair also.

[20:53] <pmichaud> (is true currently)

[20:54] <TimToady> but it's strange to a Lisp mind that car and cdr differ

[20:54] *** localhost joined
[20:54] *** localhost left
[20:54] <TimToady> so I'm thinking currently that Pair.key is mutable, while a Hash key isn't

[20:54] <TimToady> though some would argue that a mutable Hash key just automatically deletes and readds

[20:55] <pmichaud> well, we don't normally see Hash keys alone

[20:55] <TimToady> not sure I wanna go that far, at least not yet

[20:56] <PerlJam> What are the differences between a Hash and a list of Pairs?

[20:56] <pmichaud> I think I'm fine with saying that Pair keys are mutable; just need to fix the spec (and tests) then.

[20:56] <jnthn> pmichaud: The tests already check the key is mutable.

[20:56] <jnthn> Unless I mis-read...

[20:57] <pmichaud> jnthn: for Pair itself, yes -- I'm thinking of return values from .pairs, .keys, etc.

[20:57] <TimToady> it seems to me that generally you want either a mutable data structure or an immutable enum value

[20:57] <jnthn> pmichaud: ah, ok :)

[20:57] <TimToady> and the immutables are likely to be faster, at least on decontainerization

[20:57] <pmichaud> jnthn: I'm trying to make sure we're not dis-unified on .enums, .pairs, .keys, .values, .kv, .key, .value, .list, .hash, .elems, etc.

[20:58] <TimToady> the optimizer might be able to see .pairs.enums and usefully change it to .enums

[20:59] <pmichaud> the name "enums" feels wrong to me that it results in an EnumMap.  Feels like it ought to be a List.

[20:59] <TimToady> or .pairs.decontainerize -> .enums

[20:59] <TimToady> or something

[20:59] <pmichaud> Since EnumMap flattens to a list in list context I'm less worried about it... but it still feels like the wrong term.

[21:00] <jnthn> pmichaud: Plurals often feel listy, yes.

[21:00] <jnthn> Maybe .hash

[21:00] <pmichaud> .hash implies mutability, though.

[21:00] <jnthn> (Since that doesn't really mean "a hash", just "something hashy")

[21:00] <TimToady> well, but .enums can have dup keys

[21:01] <pmichaud> ah, I missed the dup keys aspect.

[21:01] <TimToady> while an EnumMap is basically an immutable Hash

[21:01] <jnthn> pmichaud: I'd seen .hash as more of a contextualizer than something that promises mutability, but that's just me. :)

[21:02] <pmichaud> jnthn: you're correct, it's a contextualizer.  My bad.

[21:02] <TimToady> otoh spec currently says .enums returns an EnumMap, which may be wrong

[21:02] <pmichaud> I'm fine with .enums returning an EnumMap for an enum.  That kind of makes sense.

[21:02] <jnthn> TimToady: Having *something* on an enumeration that returns an EnumMap is very useful.

[21:03] <TimToady> but it means if you invert an enums you can't push it to keep dups

[21:03] <jnthn> ...dups?

[21:03] <pmichaud> well, .invert should probably return a Hash or something like that

[21:03] <TimToady> no

[21:03] <TimToady> we used to spec it like that, iirc

[21:04] <TimToady> there's no point in manufacturing a Hash when we're just going to use its (inverted) pairs

[21:05] <pmichaud> let me look at .invert again -- I was absent when a lot of that work was taking places.

[21:05] <pmichaud> *place.

[21:05] *** jjore left
[21:05] <TimToady> it's currently specced to return a List, so you can say %foo.push: %bar.invert

[21:05] <pmichaud> .invert currently produces a list of (inverted) pairs

[21:05] *** jjore joined
[21:05] <pmichaud> I agree with that.

[21:06] *** Sarten-X left
[21:06] *** takadonet joined
[21:06] <TimToady> but I suspect it's really a list of enums

[21:06] <pmichaud> that works for me

[21:07] *** Kivutarrr joined
[21:07] *** slavik left
[21:08] <pmichaud> so I don't understand the "you can't push it to keep dups" part

[21:11] <TimToady> rakudo: my %foo; %foo.push: 'a' => 1, 'a' => 2, 'a' => 3;  say %foo.perl

[21:11] <p6eval> rakudo 922500: OUTPUT«{"a" => [1, 2, 3]}␤»

[21:12] <TimToady> rakudo: my %foo; %foo.push: {'a' => 1, 'a' => 2, 'a' => 3};  say %foo.perl

[21:12] <p6eval> rakudo 922500: OUTPUT«Trailing item in Hash.push  in <anon> at line 5481:src/gen/core.pm␤{}␤»

[21:12] <pmichaud> ah

[21:12] <TimToady> rakudo: my %foo; %foo.push: {'a' => 1, 'a' => 2, 'a' => 3}.pairs;  say %foo.perl

[21:12] <p6eval> rakudo 922500: OUTPUT«{"a" => 3}␤»

[21:12] <TimToady> that

[21:13] *** Sarten-X joined
[21:14] <pmichaud> so what would be a case with .enums?

[21:14] <pmichaud> I mean, I see the problem with {'a' => ... }

[21:14] <pmichaud> but in that case, it's a Hash, which can't have duplicate keys.

[21:15] <TimToady> I dunno, Bag.enums maybe

[21:15] <TimToady> maybe not

[21:15] <pmichaud> in that case, I'd say that .enums returns something that isn't an EnumMap

[21:15] <pmichaud> but still acts like a list of enums/pairs in list context

[21:15] <TimToady> seems okayish

[21:16] <pmichaud> which I guess recalls my earlier question of "what's the (semantic) difference between .enums and .pairs?"   Is it simply that .pairs is guaranteed to return a Positional, while .enums returns something Associative?

[21:16] *** thundergnat joined
[21:17] *** lichtkind left
[21:19] <pmichaud> ...that doesn't feel right, now that I look at it.

[21:19] <TimToady> I think they're both Positional

[21:19] *** slavik joined
[21:19] <pmichaud> I hope an EnumMap isn't Positional.

[21:19] <pmichaud> We discussed that once before (with Hash ~~ Positional) and decided against it.

[21:19] <TimToady> no, it just knows what to do in list context, like a Hash

[21:20] *** timbunce left
[21:20] <pmichaud> okay, I can live with that.

[21:21] <thundergnat> rakudo: my ($x,$y); say $x = $x +& 1; say $y +&= 1; # bug?

[21:21] <p6eval> rakudo 922500: OUTPUT«0␤1␤»

[21:22] <thundergnat> nom: my ($x,$y); say $x = $x +& 1; say $y +&= 1;

[21:22] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<+&>'. Available candidates are:␤:()␤:(Any $x)␤:(Int $a, Int $b)␤␤current instr.: 'infix:<+&>' pc 599325 (src/gen/CORE.setting.pir:144929) (src/gen/CORE.setting:1468)␤»

[21:22] <thundergnat> rakudo: my ($x,$y); say $x = $x ?& 1; say $y ?&= 1; #same problem

[21:22] <p6eval> rakudo 922500: OUTPUT«Bool::False␤Bool::True␤»

[21:23] <pmichaud> nom:  my $x;  say $x +& 1;

[21:23] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<+&>'. Available candidates are:␤:()␤:(Any $x)␤:(Int $a, Int $b)␤␤current instr.: 'infix:<+&>' pc 599325 (src/gen/CORE.setting.pir:144929) (src/gen/CORE.setting:1468)␤»

[21:23] <pmichaud> that's the "bug"

[21:24] <jnthn> Looks like a missing multi candidate or so.

[21:24] <pmichaud> nom only has +& defined for Int

[21:25] <pmichaud> not for Any.

[21:26] <thundergnat> Is that worth file a rakudobug for?

[21:26] <thundergnat> *ing

[21:26] *** impious left
[21:27] <dalek> features: d8e968e | larry++ | features.json:

[21:27] <dalek> features: more specs

[21:27] <dalek> features: review: https://github.com/perl6/features/commit/d8e968ee65

[21:28] *** envi left
[21:30] <pmichaud> thundergnat: yes, file a rakudobug please.

[21:30] <thundergnat> pmichaud: Ok

[21:30] <TimToady> the rakudo behavior is correct

[21:31] <TimToady> it's the nom behavior that's wrong

[21:31] <pmichaud> surely   $y +&= 1;  is zero though, yes?

[21:31] <pmichaud> or am I mentally misparsing?

[21:31] <TimToady> S03:4021

[21:31] <pmichaud> oh!

[21:31] <TimToady> no, the identity for anding is all true

[21:31] <pmichaud> right, $y defaults to all-ones.

[21:32] <thundergnat> So not a bug then

[21:32] <pmichaud> then nom is simply suffering from not having  &infix:<+&>(Any, Any)

[21:32] * pmichaud fixes.

[21:34] *** donri left
[21:35] <jnthn> pmichaud: Fixing that and related is probably going to get us back S03-operators/bit.t

[21:35] <huf> _whoa_ 

[21:36] <huf> this feature is awesome

[21:36] <jnthn> huf: Which one? :)

[21:36] <huf> S03:4021

[21:36] <pmichaud> :)

[21:36] <TimToady> well, yes :)

[21:36] <pmichaud> Yes, it's awesome.

[21:36] <jnthn> aha :)

[21:36] <pmichaud> Perl 6 strives for awesomeness.  The Perl 6 implementations strive to catch up with that.  :)

[21:37] <pmichaud> nom:  my %h;   %h<xyz> *= 4;  say %h.perl;

[21:37] <p6eval> nom: OUTPUT«("xyz" => 4).hash␤»

[21:37] <thundergnat> Awesome, though a little unintuitive in some of the weird corner cases. 

[21:37] <benabik> Does that actually call infix:<*>(), or does it call infix:<*>(4)?

[21:38] <pmichaud> it calls infix:<*>()

[21:38] <pmichaud> basically

[21:38] <TimToady> perl6: say [*]

[21:38] <pmichaud>      infix:<*>( infix:<*>(), 4)

[21:38] <p6eval> pugs: OUTPUT«1␤»

[21:38] <p6eval> ..niecza v8-27-g8e562ff: OUTPUT«0␤»

[21:38] <p6eval> ..rakudo 922500: OUTPUT«␤»

[21:38] <TimToady> nom: say [*]

[21:38] <p6eval> nom: OUTPUT«␤»

[21:38] <TimToady> hmm

[21:38] <pmichaud> nom:  say [*] ()

[21:38] <p6eval> nom: OUTPUT«1␤»

[21:39] <TimToady> nom: say [*];

[21:39] <p6eval> nom: OUTPUT«␤»

[21:39] <TimToady> buglet, I think

[21:39] *** donri joined
[21:39] <pmichaud> I believe so.  Common one, too.  :)

[21:39] <pmichaud> at least pugs gets it right :)

[21:39] <TimToady> niecza: say [*] 4

[21:39] <p6eval> niecza v8-27-g8e562ff: OUTPUT«4␤»

[21:40] <TimToady> well, at least niecza gets that one right

[21:40] <pmichaud> nom: say [*] 4;  # checking, although I'm sure it's correct

[21:40] <p6eval> nom: OUTPUT«4␤»

[21:40] <TimToady> niecza: say [*] ()

[21:40] <p6eval> niecza v8-27-g8e562ff: OUTPUT«0␤»

[21:41] <sorear> nom: say +Nil

[21:41] <p6eval> nom: OUTPUT«0␤»

[21:43] <sorear> nom: say ~Nil

[21:43] <p6eval> nom: OUTPUT«␤»

[21:43] <sorear> Is the lack of warnings on these correct/

[21:43] <TimToady> I suspect not

[21:43] <TimToady> well, + may be okay

[21:43] <pmichaud> I think there should probably be warnings, since Nil is undefined.

[21:43] <TimToady> hard to say

[21:44] <TimToady> warnings are probably saner

[21:44] <TimToady> one should really use () to mean an empty list, not Nil

[21:44] *** im2ee joined
[21:44] <pmichaud> looks like Iterable needs a :D on method Numeric

[21:45] <TimToady> we should try defaulting invocants to :D and see what hell breaks loose

[21:45] * PerlJam bets very little hell breaks loose

[21:46] <TimToady> except for all the new methods that break

[21:46] <pmichaud> well, hell breaks loose for "static method"

[21:46] <pmichaud> *methods

[21:46] <pmichaud> i.e., those that expect to be on the type object

[21:46] <pmichaud> (such as "new" :)

[21:46] <TimToady> I suppose we could issue an exception for new, or just say that static methods must be marked with :A (or whatever it ends up)

[21:46] *** donri left
[21:46] <jnthn> rakudo: Mu.all

[21:46] <pmichaud> I'm fine with marking static methods

[21:47] <p6eval> rakudo 922500: OUTPUT«Method 'all' not found for invocant of class ''␤  in main program body at line 22:/tmp/rICn1DcArW␤»

[21:47] <jnthn> rakudo: Any.all

[21:47] <p6eval> rakudo 922500:  ( no output )

[21:47] <pmichaud> grrrr, tadzik's Pod stuff caused me to delete a directory that caused me to clobber my +& fixes when I tried to fix it.  

[21:47] *** Patterner left
[21:47] <jnthn> :(

[21:47] <pmichaud> tadzik-- (Pod source is in Pod/ and not src/Pod)

[21:48] <pmichaud> or, even more likely, src/core/Pod/

[21:49] <PerlJam> pmichaud: sounds like you just aren't make enough use of git's features :)

[21:49] <PerlJam> (or perhaps not commtting often enough)

[21:49] *** Psyche^ joined
[21:49] *** Psyche^ is now known as Patterner

[21:49] <pmichaud> PerlJam: no, I just mistyped a command.

[21:50] <pmichaud> And I didn't realize that the Pod/ subdir had source files in it

[21:50] <pmichaud> I thought they were just generated.

[21:50] <jnthn> pmichaud: It's a module, so src/Pod is probably righter. Fully agree it shoudln't be in root of the repo though.

[21:50] <pmichaud> tadzik++  # still deserves karma for Pod implementation, though.

[21:51] <pmichaud> pmichaud-- # mistyping a command

[21:52] <jnthn> pmichaud++ # fixing stuff

[21:52] <jnthn> .oO( Conservation of Karma Principle )

[21:52] <sorear> negative karma never sticks, especially if applied to a popular person.

[21:54] <TimToady> perl6: say [\*] ();

[21:54] <dalek> niecza: f727731 | sorear++ | lib/ (2 files):

[21:54] <dalek> niecza: Mark more setting functions as Nil-transparent, and implement Parcel/List.ACCEPTS

[21:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f72773185f

[21:54] <p6eval> pugs: OUTPUT«1␤»

[21:54] <p6eval> ..rakudo 922500:  ( no output )

[21:54] <p6eval> ..niecza v8-27-g8e562ff: OUTPUT«␤»

[21:54] <sorear> it should pass all spectest again

[21:55] <pmichaud> nom: say [\*] ();

[21:55] <p6eval> nom: OUTPUT«Attempt to return from exhausted Routine␤current instr.: 'die' pc 586638 (src/gen/CORE.setting.pir:137574) (src/gen/CORE.setting:291)␤»

[21:55] <pmichaud> *huh*

[21:55] *** REPLeffect left
[21:55] <TimToady> should probably return ()

[21:55] <pmichaud> probably a bug in the triangle metaop code.

[21:55] * pmichaud will fix.

[21:56] <pmichaud> > my $x;  say $x +& 1;

[21:56] <pmichaud> Use of uninitialized value in numeric context

[21:56] <pmichaud> 0

[21:56] <pmichaud> \o/

[21:56] *** im2ee left
[21:57] <jnthn> :)

[22:01] *** donri joined
[22:01] * sorear wonders what the 'n+-' on PROCESS, GLOBAL, CALLER, DYNAMIC refers to.

[22:02] *** ixxvil joined
[22:02] <ixxvil> did you guys finalise  on the logo for roku?>

[22:02] <ixxvil> sorry

[22:02] <ixxvil> rakudo

[22:02] <pmichaud> very few things are final in Perl 6.  :-)

[22:02] <dalek> features: f9b23b7 | larry++ | features.json:

[22:02] <dalek> features: ding niecza for missing degenerate cases

[22:02] <dalek> features: 

[22:02] <dalek> features: [op] and op= don't do the right thing with nothing

[22:02] <dalek> features: review: https://github.com/perl6/features/commit/f9b23b7dd9

[22:02] <pmichaud> (short answer: "no")

[22:03] <pmichaud> > say +Nil

[22:03] <pmichaud> Use of uninitialized value in numeric context

[22:03] <pmichaud> 0

[22:03] <pmichaud> \o/

[22:04] <jnthn> \o/

[22:04] *** colourspace left
[22:05] *** colourspace joined
[22:10] <pmichaud> Latest push leaves a couple of failing spectests... but I have to leave for an hour so will fix them when I get back (if nobody beats me to them).

[22:10] <pmichaud> Fixed +Nil, triangle op on empty lists, and +&.

[22:10] <pmichaud> bbiah

[22:10] *** Kivutarrr left
[22:11] <dalek> rakudo/nom: 9a99a12 | pmichaud++ | src/core/Numeric.pm:

[22:11] <dalek> rakudo/nom: Add infix:<+&>(Any, Any) (and related bitwise ops).

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a99a124db

[22:11] <dalek> rakudo/nom: 120d3be | pmichaud++ | src/core/ (6 files):

[22:11] <dalek> rakudo/nom: Make sure .Numeric is properly multied.

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/120d3be93c

[22:11] <dalek> rakudo/nom: f72544a | pmichaud++ | src/core/metaops.pm:

[22:11] <dalek> rakudo/nom: Fix triangle metaops on empty lists (TimToady++).

[22:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f72544ab58

[22:14] <ixxvil> pmichaud: yeah but did you guys finalize on the logo?

[22:14] <ixxvil> i remember a few designing it for you guys but became of that

[22:14] <ixxvil> what

[22:14] <ixxvil> what became*

[22:14] *** saaki left
[22:15] <dalek> rakudo/nom: f5ab8d0 | jonathan++ | src/Perl6/Metamodel/ (2 files):

[22:15] <dalek> rakudo/nom: Allow overriding of postcircumfix:<( )>.

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5ab8d0c55

[22:15] <dalek> rakudo/nom: bc30e74 | jonathan++ | src/core/Capture.pm:

[22:15] <dalek> rakudo/nom: Cheating |$c in argument lists (only puts in positional bit...will fix that up shortly).

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bc30e745fb

[22:15] <dalek> rakudo/nom: d9a6cfa | jonathan++ | t/spectest.data:

[22:15] <dalek> rakudo/nom: We now pass S13-overloading/typecasting-long.t.

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9a6cfa697

[22:15] <dalek> rakudo/nom: 275e3db | jonathan++ | src/core/Junction.pm:

[22:15] <dalek> rakudo/nom: Implement junction invocation.

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/275e3dbe89

[22:15] <dalek> rakudo/nom: d097bdc | jonathan++ | src/core/Any.pm:

[22:15] <dalek> rakudo/nom: Any.[all|any|n?one]

[22:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d097bdc8aa

[22:16] *** leprevost left
[22:31] *** drbean joined
[22:32] *** ixxvil left
[22:33] *** MayDaniel left
[22:37] <dalek> features: 0f4caee | larry++ | features.json:

[22:37] <dalek> features: spec refinements

[22:37] <dalek> features: review: https://github.com/perl6/features/commit/0f4caee822

[22:38] *** Moukeddar joined
[22:42] *** kaare_ left
[22:45] <pmichaud> jnthn: how does the 'invoke' vtable mapping work, exactly?

[22:46] *** supernovus joined
[22:47] <pmichaud> I mean, what happens for types that don't define a postcircumfix:<( )> ?

[22:47] <jnthn> nom: class A { }; A.new.()

[22:47] <p6eval> nom: OUTPUT«invoke() not implemented in class 'A'␤current instr.: '_block1002' pc 109 ((file unknown):30838431) (/tmp/qBw7q6zeTK:1)␤»

[22:47] <jnthn> er, too soon

[22:47] <jnthn> Anyway, it just says postcircumfix:<( )> is not implemented.

[22:48] <pmichaud> is postcircumfix:<( )> implemented in Code, though?

[22:48] <jnthn> No (more)

[22:48] <jnthn> There's a fast path for Code and its subclasses

[22:48] <pmichaud> ohhhhhh

[22:48] <pmichaud> +Code.HOW.add_parrot_vtable_mapping(Code, 'invoke', nqp::null());

[22:48] <jnthn> Yes :)

[22:48] <pmichaud> the null removes the mapping?

[22:48] <jnthn> That's a bit...cheaty. ;)

[22:49] <jnthn> Suppresses emission of it at least, yes.

[22:49] <supernovus> So, I was just taking a quick peek at "nom" and am wondering how different it is to actually write core libs for it (or at least port ones from the "old" directory) as the Temporal.pm would be a nice thing to bring back, but I'm not sure where to start (I helped work on the version in the current "master" branch.)

[22:49] <jnthn> I'm not 100% happy with that factoring, but I didn't think of a nicer one yet.

[22:49] <pmichaud> so, Code and subclasses default back to the fast path, and everything else under Mu gets the slow postcircumfix:<( )>.  Cheaty, yes, but fastpaths often are.

[22:49] <jnthn> Right. :)

[22:49] <pmichaud> supernovus: it depends on the lib.

[22:50] <jnthn> And it's actually not so cheaty - it's a general feature now. We use it in Capture in NQP for example.

[22:50] <pmichaud> supernovus: mainly, class declarations need to become "my class"

[22:50] <jnthn> But not for invoke.

[22:50] <pmichaud> jnthn++  # wfm, thanks

[22:51] <jnthn> Another 25 passing tests coming up :)

[22:53] <supernovus> pmichaud: okay, I'll see about setting up a parallel path for "nom" and see if I can port Temporal. Hopefully someone else takes on IO::Socket::INET, those are the two "core" libs that I use quite often that are still missing from nom. Scratching an itch :-)

[22:53] <pmichaud> supernovus++   # let us know where we can help :)

[22:54] <dalek> roast: c0a9803 | jonathan++ | S12-introspection/attributes.t:

[22:54] <dalek> roast: Update attributes introspection test to latest spec; fudge :tree tests for Rakudo.

[22:54] <dalek> roast: review: https://github.com/perl6/roast/commit/c0a98035f8

[22:55] *** [particle] left
[22:55] *** whiteknight joined
[22:56] *** [particle] joined
[22:56] <dalek> rakudo/nom: 057f236 | jonathan++ | src/Perl6/Metamodel/AttributeContainer.pm:

[22:56] <dalek> rakudo/nom: Fix bug where .^attributes could make multiple entries for an attribute in the result list.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/057f236405

[22:56] <dalek> rakudo/nom: 402f330 | jonathan++ | src/core/Attribute.pm:

[22:56] <dalek> rakudo/nom: Some missing methods on Attribute.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/402f33061e

[22:56] <dalek> rakudo/nom: 80467f3 | jonathan++ | src/ (3 files):

[22:56] <dalek> rakudo/nom: Some missing decontainerizations in Attribute methods and a naming fix to bring us in line with spec and tests.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/80467f33d8

[22:56] <dalek> rakudo/nom: 538d581 | jonathan++ | t/spectest.data:

[22:56] <dalek> rakudo/nom: Run S12-introspection/attributes.t.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/538d581e7b

[22:56] <Moukeddar> guys, can someone explain to me the difference between the different types of licenses ?

[22:56] <sorear> ok

[22:56] <Moukeddar> GPL,GPLv2,NewBSD, etc...

[22:57] <sorear> GPL family licenses require derived works to use the same license

[22:58] <sorear> if you create a modified version of Linux and distribute it, you have to provide the source, and anyone who gets your modified version is allowed to make derivatives themselves

[22:59] <sorear> BSD family licenses have no such restriction

[22:59] <sorear> you can make a modified version of BSD Unix and destribute it commercially with no restrictions

[23:00] <sorear> if you want to know what a specific license says, there is no substitute for reading it (or paying someone to read it for you)

[23:01] <sorear> also, I know absolutely nothing about the specifics of how copyright law is implemented and enforced in Morocco

[23:02] <sorear> was that useful?

[23:02] <sorear> Moukeddar

[23:02] <Moukeddar> i'm reading :)

[23:03] <gfldex> please note that licenses are not written in plain english

[23:03] <Moukeddar> gfldex, good point Sir :)

[23:04] <Moukeddar> copyright law isn't really enforced here

[23:04] <Moukeddar> but it's good to know

[23:04] <sorear> your deferential style of address amuses me.

[23:04] <Moukeddar> what style?

[23:05] *** wallberg left
[23:07] <sorear> you use 'Sir' much more than is typical

[23:11] *** smash left
[23:13] <dalek> rakudo/nom: 9fdde9e | pmichaud++ | src/core/Enumeration.pm:

[23:13] <dalek> rakudo/nom: Roles apparently can't quite handle 'multi method' yet, so set

[23:13] <dalek> rakudo/nom: Enumeration.Numeric back to an ordinary method for now.

[23:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9fdde9e46a

[23:14] <Moukeddar> i just like it :)

[23:17] <jnthn> pmichaud: They can't?

[23:18] <jnthn> pmichaud: Details?

[23:18] *** whiteknight left
[23:18] *** whiteknight joined
[23:18] <pmichaud> jnthn: undo the patch I just made, then run t/spec/S12-class/anonymous.t :)

[23:18] <dalek> niecza: 695339a | sorear++ | / (5 files):

[23:18] <dalek> niecza: Add a place in the return sequence to hook in LEAVE.

[23:18] <dalek> niecza: review: https://github.com/sorear/niecza/commit/695339aa74

[23:19] <dalek> rakudo/nom: 3b56d34 | jonathan++ | src/core/IO.pm:

[23:19] <dalek> rakudo/nom: Implement get and close subs.

[23:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3b56d34f58

[23:19] <dalek> rakudo/nom: 0db8c6f | jonathan++ | t/spectest.data:

[23:19] <dalek> rakudo/nom: 3 more passing IO test files giving about 50 more passing tests.

[23:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0db8c6f9c2

[23:20] <jnthn> pmichaud: thanks, I look tomorrow at that one

[23:27] *** shinobicl left
[23:28] *** supernovus left
[23:28] *** wamba left
[23:29] <pmichaud> afk, dinner.

[23:30] <dalek> rakudo/nom: a207490 | pmichaud++ | / (2 files):

[23:30] <dalek> rakudo/nom: Add prefix:<+^>(Any), winning us the S03-operators/bit.t tests.

[23:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a207490190

[23:42] *** molaf_ joined
[23:43] <dalek> roast: 2603206 | jonathan++ | S12-attributes/undeclared.t:

[23:43] <dalek> roast: Update S12-attributes/undeclared.t to handle compilers that can detect undeclared attributes at compile time; remove two tests that are invalid.

[23:43] <dalek> roast: review: https://github.com/perl6/roast/commit/260320674f

[23:45] *** molaf left
[23:45] <colourspace> what is hlagh

[23:47] <dalek> rakudo/nom: de65682 | jonathan++ | src/core/IO.pm:

[23:47] <dalek> rakudo/nom: Implement slurp.

[23:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de65682c7b

[23:47] <dalek> rakudo/nom: 6d942a8 | jonathan++ | t/spectest.data:

[23:47] <dalek> rakudo/nom: Two more passing test files.

[23:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6d942a8370

[23:49] <sorear> colourspace: context?

[23:50] *** kcwu left
[23:50] *** kcwu joined
[23:51] <sorear> What happens if a LEAVE block throws an exception during exceptional unwinding?

[23:51] <sorear> Are LEAVE blocks queued on entry or at inline time?  (return; LEAVE {... })

[23:52] <jnthn> sleeep &

[23:56] <sorear> likewise in a DBC context, are POST blocks run during exceptional unwinding, and what happens if they fail?

