[00:04] *** Quadrescence joined
[00:06] <Quadrescence> what is the meaning of x$ = any(1,2,3)

[00:06] <jnthn> x$, or $x ?

[00:07] <jnthn> $x = any(1,2,3) assigns a junction to the variable $x

[00:07] <jnthn> nom: my $x = any(1,2,3); if 1 == $x { say "beer" }; if 4 == $x { say "cheese" }

[00:07] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'. Available candidates are:␤:(Any $x)␤:(Int $a, Int $b)␤:(Num $a, Num $b)␤:(Complex $a, Complex $b)␤:(Real $a, Real $b)␤:(Complex $a, Real $b)␤:(Real $a, Complex $b)␤:(Any $a, Any $b)␤␤current instr.: 'infix:<==>'…

[00:07] <jnthn> er, hm

[00:07] <sjn> heh

[00:08] * jnthn wonders if that bot is up to date...

[00:08] <jnthn> oh

[00:08] <jnthn> rakudo: my $x = any(1,2,3); if 1 == $x { say "beer" }; if 4 == $x { say "cheese" }

[00:08] <p6eval> rakudo 72d158: OUTPUT«beer␤»

[00:08] <jnthn> OK, there you go :)

[00:08] <jnthn> nom: nom: my $x = any(1,2,3); if 1 == $x { say "beer" }

[00:08] <p6eval> nom: OUTPUT«Confused at line 1, near "nom: my $x"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23533 (src/stage2/gen/NQPHLL.pir:6314) (src/stage2/gen/NQPHLL.pm:328)␤»

[00:08] <jnthn> nom: my $x = any(1,2,3); if 1 == $x { say "beer" }

[00:08] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<==>'. Available candidates are:␤:(Any $x)␤:(Int $a, Int $b)␤:(Num $a, Num $b)␤:(Complex $a, Complex $b)␤:(Real $a, Real $b)␤:(Complex $a, Real $b)␤:(Real $a, Complex $b)␤:(Any $a, Any $b)␤␤current instr.: 'infix:<==>'…

[00:08] * sjn likes junctions just as much as he likes quantum superpositions :)

[00:08] <jnthn> nom: if 1 == any(1,2,3) { say "beer" }

[00:08] <p6eval> nom: OUTPUT«beer␤»

[00:08] <jnthn> ah, *that* bug.

[00:09] <jnthn> (nom branch only got junction auto-threading last night...)

[00:10] <sjn> Quadrescence: http://en.wikipedia.org/wiki/Perl_6#Junctions

[00:10] <soh_cah_toa> Quadrescence: it's an alternate notation for my $x = 1 | 2 | 3;

[00:10] <soh_cah_toa> yes, see above link

[00:12] <sjn> Quadrescence: one of many utterly fascinating features in Perl6 :)

[00:12] <soh_cah_toa> indeed

[00:12] <Quadrescence> sjn, Isn't that feature very old though, dating back before the prolog days

[00:13] <Quadrescence> jnthn, I typo'd, $x of course

[00:14] <sjn> Quadrescence: well, it's "new" in the Perl world

[00:14] <sjn> I'm pretty sure you'll find most "new" features in Perl6 in other languages

[00:15] <soh_cah_toa> except better :)

[00:15] <sjn> you might have some difficulties finding all of them in one language though :)

[00:15] <soh_cah_toa> plus, prolog is a logic programming language. i could be wrong but this is the first i've seen junctions in a dynamic language at least

[00:16] <Quadrescence> (prolog is dynamic)

[00:17] <jlaire> raudo: say not so Cool

[00:17] <dalek> roast: 85b83d5 | jonathan++ | S12-construction/BUILD.t:

[00:17] <dalek> roast: Turn some todos to skips.

[00:17] <dalek> roast: review: https://github.com/perl6/roast/commit/85b83d55a7

[00:17] <dalek> roast: 14975bd | jonathan++ | S12-construction/construction.t:

[00:17] <dalek> roast: Correct a test and re-fudge construction.t (only one we lost is related to Seq).

[00:17] <dalek> roast: review: https://github.com/perl6/roast/commit/14975bd405

[00:17] <jlaire> rakudo: say not so Cool

[00:17] <soh_cah_toa> really? i don't know about that

[00:17] <dalek> roast: 891dafc | jonathan++ | S02-builtin_data_types/ (4 files):

[00:17] <dalek> roast: Merge branch 'master' of github.com:/perl6/roast

[00:17] <dalek> roast: review: https://github.com/perl6/roast/commit/891dafccea

[00:17] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[00:18] *** j`ey joined
[00:18] <sjn> rakudo: say so

[00:18] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Confused at line 22, near "say so"␤»

[00:18] <sjn> rakudo: say so Cool

[00:18] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:18] * sjn wonders what the "so" operator is

[00:18] <sorear> good * #perl6

[00:19] <sjn> is "so" eqivalent to "~~" ?

[00:19] <sjn> sorear: wb :)

[00:19] <dalek> rakudo/nom: e467eaf | jonathan++ | src/ (7 files):

[00:19] <dalek> rakudo/nom: Add default %_ for methods. It's rather smarter than master, and doesn't allocate if it's never used.

[00:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e467eaf189

[00:19] <dalek> rakudo/nom: d9b6344 | jonathan++ | t/spectest.data:

[00:19] <dalek> rakudo/nom: We now pass two more test files.

[00:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9b6344ea9

[00:20] <soh_cah_toa> rakudo: say not ~~ Cool

[00:20] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:20] <soh_cah_toa> i guess not

[00:21] <soh_cah_toa> i've never seen it either. now i'm curious

[00:21] <huf> isnt so the wordy ?

[00:22] <huf> ?

[00:23] *** whiteknight joined
[00:23] *** j`ey left
[00:25] <sorear> sjn: so is a lower-priority ?

[00:25] <sorear> not ~~ Cool is a bug

[00:25] <sorear> perl6: say not ~~ Cool

[00:25] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/EIw6Z9ZVo1 line 1:␤------> [32msay not ~~[33m⏏[31m Cool[0m␤␤Parse failed␤␤»…

[00:25] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "~~"␤    at /tmp/zcpNZg1Y_b line 1, column 9␤»

[00:25] <p6eval> ..rakudo 72d158: OUTPUT«Bool::False␤»

[00:26] <soh_cah_toa> rakudo: my Int $foo = 0; say ?$foo;

[00:26] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:26] <dalek> niecza: d3c5fc0 | sorear++ | src/NieczaActions.pm6:

[00:26] <dalek> niecza: Fixes to compiler to work with correct $/ semantic

[00:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d3c5fc0126

[00:26] <soh_cah_toa> rakudo: my Int $foo = 0; say so $foo;

[00:26] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:26] <soh_cah_toa> oh yeah. look at that

[00:27] * sjn fails to understand whats going on

[00:28] <soh_cah_toa> sjn: from what i understand "so" is a lower-precedence "?" operater for forcing boolean context

[00:28] <sorear> sjn: so $x means $x ?? True !! False

[00:28] <soh_cah_toa> oh, the double question marks

[00:29] <sjn> hokay... what's the use case?

[00:29] <huf> where you'd use !! in other languages?

[00:30] <sjn> if so $variable_that_can_be_undef { ... }

[00:31] <sjn> ...or is there some other use?

[00:31] <sjn> (as in "use, where the word «so» make the code read easier"

[00:31] <sjn> )

[00:33] <sorear> sjn: my $variable = so function_returns_giant_array();

[00:35] <dalek> roast: ed8e11e | jonathan++ | S12-class/attributes.t:

[00:35] <dalek> roast: Update test; can't use default constructor to set non-public attrs.

[00:35] <dalek> roast: review: https://github.com/perl6/roast/commit/ed8e11e266

[00:35] * sjn is still confused

[00:36] <huf> dunno, it happens to me fairly often that i just want the truthiness of a value and dont care about the value

[00:37] <dalek> november: 4d3f6b5 | softmoth++ | / (4 files):

[00:37] <huf> "back in my day we made do with negation and used it twice!"

[00:37] <dalek> november: Fix tags update when server_root is set

[00:37] <dalek> november: 

[00:37] <dalek> november: November::Tags.new() now takes a config param, instead of always

[00:37] <dalek> november: creating its own new Config object.

[00:37] <dalek> november: review: https://github.com/viklund/november/commit/4d3f6b50cb

[00:37] <dalek> november: b79c3ea | softmoth++ | data/ (18 files):

[00:37] <dalek> november: Clean up data/*; add FAQ and About pages, etc.

[00:37] <dalek> november: review: https://github.com/viklund/november/commit/b79c3ea7f6

[00:38] <dalek> rakudo/nom: 1762378 | jonathan++ | NOMMAP.markdown:

[00:38] <dalek> rakudo/nom: Remove done nommap item.

[00:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17623784c1

[00:38] <dalek> rakudo/nom: aeb6b08 | jonathan++ | src/Perl6/Actions.pm:

[00:38] <dalek> rakudo/nom: Fix bug with has ($!a, $!b) style decls.

[00:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aeb6b08607

[00:38] <dalek> rakudo/nom: e66e95f | jonathan++ | t/spectest.data:

[00:38] <dalek> rakudo/nom: We pass S12-class/attributes.t.

[00:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e66e95f8ac

[00:39] *** JimmyZ joined
[00:40] <JimmyZ> good morning, #perl6

[00:42] <jnthn> o/ JimmyZ 

[00:42] <jnthn> And, goodnight #perl6

[00:42] <JimmyZ> good night, jnthn :)

[00:42] <sjn> rakudo: sub is_done { 0 }; say "not done" if not so is_done

[00:42] <p6eval> rakudo 72d158: OUTPUT«not done␤»

[00:42] <sjn> jnthn: nn! :)

[00:43] <sjn> rakudo: sub is_done { Bool::False }; say "not done" if not so is_done

[00:43] <p6eval> rakudo 72d158: OUTPUT«not done␤»

[00:43] <sjn> rakudo: sub is_done { <> }; say "not done" if not so is_done

[00:43] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Unsupported use of <>; in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list at line 22, near "<> }; say "␤»

[00:43] <sjn> rakudo: sub is_done { () }; say "not done" if not so is_done

[00:43] <p6eval> rakudo 72d158: OUTPUT«not done␤»

[00:43] <sjn> rakudo: sub is_done { (0) }; say "not done" if not so is_done

[00:43] <p6eval> rakudo 72d158: OUTPUT«not done␤»

[00:43] <sjn> rakudo: sub is_done { (0,0) }; say "not done" if not so is_done

[00:44] <p6eval> rakudo 72d158:  ( no output )

[00:45] <sjn> uhm

[00:45] <sjn> rakudo: say < >.WHAT

[00:45] <p6eval> rakudo 72d158: OUTPUT«Parcel()␤»

[00:45] <sjn> rakudo: say < 0 >.WHAT

[00:45] <p6eval> rakudo 72d158: OUTPUT«Str()␤»

[00:45] <sjn> rakudo: say < 0, 0 >.WHAT

[00:45] <p6eval> rakudo 72d158: OUTPUT«Parcel()␤»

[00:45] <sjn> rakudo: say so < 0, 0 >

[00:46] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[00:46] <sjn> rakudo: say so < 0 >

[00:46] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:46] <sjn> rakudo: say so < >

[00:46] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[00:46] <sjn> rakudo: say so < 1 >

[00:46] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[00:46] <sjn> why is < foo > a Str?

[00:48] <sjn> meh, never mind, my n00b questions can wait :)

[00:48] <huf> rakudo: < 'foo' >.WHAT

[00:48] <p6eval> rakudo 72d158:  ( no output )

[00:48] <huf> rakudo: say < 'foo' >.WHAT

[00:48] <p6eval> rakudo 72d158: OUTPUT«Str()␤»

[00:48] <huf> i think < foo > is something like $hash{foo} was in perl5

[00:49] <huf> where simple strings dont have to be quoted

[00:49] <sjn> right

[00:49] <huf> rakudo: say < 1 + 1 >.WHAT

[00:49] <p6eval> rakudo 72d158: OUTPUT«Parcel()␤»

[00:49] <huf> hmm :D

[00:50] <huf> honestly, i have no idea :)

[00:52] *** dolmen left
[00:55] *** lichtkind left
[01:00] *** noganex_ joined
[01:02] *** tokuhir__ left
[01:03] *** noganex left
[01:13] <flussence> < 1 + 1 > is qw(1 + 1)

[01:15] *** ab5tract left
[01:16] <huf> ah

[01:19] *** JimmyZ_ joined
[01:20] *** daniel-s joined
[01:23] *** JimmyZ left
[01:23] *** JimmyZ_ is now known as JimmyZ

[01:26] *** wolfman2000 joined
[01:36] *** JimmyZ_ joined
[01:39] *** JimmyZ left
[01:39] *** JimmyZ_ is now known as JimmyZ

[01:52] *** whiteknight left
[02:06] *** daemon left
[02:10] *** daniel-s left
[02:39] *** daemon joined
[02:44] *** JimmyZ left
[02:59] *** ZaphrodZenovka left
[02:59] *** ZaphrodZenovka joined
[03:09] *** kaare_ joined
[03:12] *** TBA2 left
[03:15] *** mdxi left
[03:23] *** Su-Shee_ joined
[03:26] *** Su-Shee left
[03:44] *** envi joined
[03:51] *** leprevost joined
[03:55] *** _jaldhar joined
[03:59] *** jdhore1 left
[04:01] *** jdhore1 joined
[04:01] *** jdhore1 left
[04:01] *** jdhore1 joined
[04:06] *** kaare_ left
[04:07] *** bkolera joined
[04:11] *** Quadrescence left
[04:22] *** mdxi joined
[04:29] *** cognominal_ joined
[04:32] *** cognominal left
[04:47] *** _jaldhar left
[04:49] *** _jaldhar joined
[04:49] *** donri left
[04:54] *** am0c left
[04:56] *** cognominal joined
[04:59] *** cognominal_ left
[05:07] *** am0c joined
[05:11] <Tene> rakudo: say < 1 + 1 >.perl

[05:11] <p6eval> rakudo 72d158: OUTPUT«("1", "+", "1")␤»

[05:17] *** araujo left
[05:22] *** Bzek joined
[05:24] *** soh_cah_toa left
[06:00] *** cognominal_ joined
[06:02] *** daniel-s joined
[06:03] *** cognominal left
[06:04] <daniel-s> in the perl6 book, it describes the normal way of creating variables in a class

[06:04] <phenny> daniel-s: 08 Jul 19:35Z <sorear> tell daniel-s We already have a translator bot, phenny: en de "hello moritz, how are you today?"?

[06:04] *** zby_home joined
[06:05] <daniel-s> using has $!variable

[06:05] <daniel-s> if you create it using "my $variable", but within a class, it still seems to work fine

[06:06] *** JimmyZ joined
[06:06] <moritz> daniel-s: 'has $!variable' is per instance

[06:06] <daniel-s> is my $variable static?

[06:06] <moritz> daniel-s: which means that if you create 5 objects of your class, you have 5 different $!variable's

[06:07] <moritz> rakudo: class A { has $.a; }; say A.new(a => 5).a; say A.new(a => 6).a

[06:07] <p6eval> rakudo 72d158: OUTPUT«5␤6␤»

[06:07] <JimmyZ> moritz: Does $a and $.a also declare $!a ?

[06:08] <moritz> rakudo: class A { my $a; method set($x) { $a = $x }; method get($x) { $a } }; my @objs = A.new, A.new; @objs[0].set(5); say @objs[0].get

[06:08] <p6eval> rakudo 72d158: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'A::get' at line 22:/tmp/ECRNq8zqk2␤  in main program body at line 22:/tmp/ECRNq8zqk2␤»

[06:08] <moritz> rakudo: class A { my $a; method set($x) { $a = $x }; method get() { $a } }; my @objs = A.new, A.new; @objs[0].set(5); say @objs[0].get

[06:09] <p6eval> rakudo 72d158: OUTPUT«5␤»

[06:09] <moritz> see? different object, same variable

[06:09] <moritz> JimmyZ: in a 'has' yes

[06:13] *** JimmyZ left
[06:19] *** Mowah joined
[06:21] * moritz sees lots of segfaulting tets in nom

[06:21] <daniel-s> rakudo: class A { my $a; method set($x) { $a = $x }; method get() { $a } }; my @objs = A.new, A.new; @objs[0].set(5); say @objs[1].get

[06:21] <p6eval> rakudo 72d158: OUTPUT«5␤»

[06:22] <daniel-s> is that the way I should declare variables if I want them to be static

[06:22] <daniel-s> using the my keyword, or is there something more appropriate

[06:23] <moritz> use my

[06:28] *** JimmyZ joined
[06:28] <JimmyZ> moritz: I'm confused by S12

[06:28] <JimmyZ> moritz:   S12 said, " has $brain; # also declares $!brain; As with the ! declaration, no accessor is generated. "

[06:29] <JimmyZ> moritz: and it said, "Public attributes have a secondary sigil of "dot", indicating the automatic generation of an accessor method of the same name"

[06:29] <JimmyZ> moritz: since $.a also declare $!a, as it said, with the ! declaration, no accessor is generated

[06:29] <JimmyZ> moritz: so, "Public attributes have a secondary sigil of "dot", indicating the automatic generation of an accessor method of the same name" looks wrong

[06:29] <JimmyZ> well, I'm not sure whether I understand wrong, or it's not explicit

[06:35] <sorear> JimmyZ: the stuff in S12 about has $x and my $!x makes very little sense to me or jnthn

[06:35] <sorear> JimmyZ: don't expect it to stay.

[06:36] <JimmyZ> sorear: Ok, that' explains  a lot

[06:36] <JimmyZ> sorear: thanks

[06:36] <moritz> 'has $x' is just the same as 'has $!x', but it also creates an alias $x to $!x

[06:38] * JimmyZ thinks it  breaks consistency or something

[06:40] *** Aridai joined
[06:40] <daniel-s> is it possible to my $!x

[06:40] <daniel-s> what does that do

[06:40] <daniel-s> is it different to my $x

[06:42] <moritz> phenny: tell jnthn that I get lots of (new) segfaults in current nom spectest, https://gist.github.com/1073396 has the stack trace of a randomly chosen test

[06:42] <phenny> moritz: I'll pass that on when jnthn is around.

[06:58] *** molaf__ left
[07:01] *** masak joined
[07:01] <masak> phenny: tell sjn the function &so is simply the opposite of the function &not. it's the low-precedence form of prefix:<?>. it's not used often, but we like to toy with it. :)

[07:01] <phenny> masak: I'll pass that on when sjn is around.

[07:01] <phenny> masak: 08 Jul 19:36Z <sorear> tell masak ("0") - #p5p is seriously talking about making "" the only false string.  "0" falseness is a pretty disgusting Perlism imo

[07:02] <phenny> masak: 08 Jul 19:36Z <sorear> tell masak oh, and it's really annoying to work around.  I can't use if $name in niecza because "0" is often a valid name, but "" never is

[07:03] <masak> sorear: the situation is slightly diff'rent in Perl 5, which consciously blurs the distinction between Int/Num and Str. which makes the case for making "0" true weaker in Perl 5 but stronger in Perl 6, I guess.

[07:03] <masak> oh, and OH HAI #perl6! :)

[07:04] * masak resumes hacking on the Perl 6 text adventure game... "crypt"

[07:06] *** molaf joined
[07:14] <masak> rakudo: (my %things)<door> = (class { method open { say "You open the door" } }).new; "open the door" ~~ /$<verb>=[\w+] \h+ [the]? \h+ $<noun>=[\w+]/; my $noun = $<noun>; my $thing = %things{$noun}; $thing."$<verb>"()

[07:14] <p6eval> rakudo 72d158: OUTPUT«You open the door␤»

[07:14] <masak> \o/

[07:15] <masak> pardon me, but that is freaking AWESOME

[07:23] <masak> rakudo: (my %things)<door> = (class { method open { say "You open the door" } }).new; "open the door" ~~ /$<verb>=[\w+] <.ws> [the]? <.ws> $<noun>=[\w+]/; %things{$<noun>}."$<verb>"()

[07:23] <p6eval> rakudo 72d158: OUTPUT«You open the door␤»

[07:28] <sjn> o/

[07:28] <phenny> sjn: 07:01Z <masak> tell sjn the function &so is simply the opposite of the function &not. it's the low-precedence form of prefix:<?>. it's not used often, but we like to toy with it. :)

[07:29] <cotto> Is anyone going from Helsinki to Riga for YAPC::EU?

[07:30] <masak> sjn: in the 'if so $some-value' case, the 'so' is unnecessary, because boolification is implicit in the if statement.

[07:31] <sjn> masak: what's the canonical use case then?

[07:31] <masak> sjn: any time you want do to the equivalent of prefix:<?> but don't care for parentheses.

[07:31] *** Chillance joined
[07:31] <masak> sjn: think of when you'd use 'and' instead of '&&' to get rid of parentheses.

[07:32] <masak> or 'or' 'stead of '||'.

[07:32] <sjn> $has_elements = so [ 0 ];

[07:32] <masak> yeah.

[07:32] <masak> though in that case '?' works just as well.

[07:32] * sorear out

[07:32] <masak> std: not ~~ Cool

[07:32] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/reztdjBWdt line 1:␤------> [32mnot ~~[33m⏏[31m Cool[0m␤Parse failed␤FAILED 00:01 119m␤»…

[07:33] * sjn is still not used to having a "?" operator

[07:33] <masak> it's strangely consistent with prefix:<+> and prefix:<~>

[07:33] <sjn> hm

[07:34] <masak> it's like three "views" on a value: string, number, bool.

[07:34] <sjn> rakudo: my @elems = 1,2,3; say "we have elements: " ~ ? @elems;

[07:34] <p6eval> rakudo 72d158: OUTPUT«we have elements: Bool::True␤»

[07:35] <masak> I have to log off; I'm switching means of transportation.

[07:35] <cotto> where does jnthn live?

[07:35] <moritz> sweden

[07:35] <masak> cotto: southern Sweden.

[07:35] <sjn> Lund :)

[07:35] <masak> Central Lund :P

[07:35] *** dogfish joined
[07:35] <cotto> masak, moritz, thanks

[07:36] *** masak left
[07:36] *** araujo joined
[07:38] *** im2ee joined
[07:40] *** dogfish left
[07:40] *** cooper left
[07:46] *** Su-Shee_ is now known as Su-Shee

[07:49] *** Aridai left
[07:49] *** danoran joined
[07:50] <danoran> howdy.  Is there a todo list anywhere?

[07:53] <danoran> never mind.  I found it on http://rakudo.org/how-to-help/

[07:53] <moritz> danoran: there's a ROADMAP file in the rakudo repository

[07:53] <moritz> danoran: but currently most development happens in the 'nom' branch

[07:54] <moritz> danoran: and in the nom branch there's a file called LHF.markdown with easy tasks to get started

[07:56] <moritz> afk &

[07:59] *** isBEKaml joined
[08:00] <danoran> thanks.  I'm just kindof looking around.  I've been considering trying to develop a simple website in perl6

[08:07] *** molaf left
[08:07] *** isBEKaml left
[08:11] <JimmyZ> danoran:  http://ttjjss.wordpress.com/2011/01/10/bailamos/ FYI

[08:13] *** molaf joined
[08:18] *** molaf left
[08:27] <danoran> JimmyZ:  Thanks, I thought you were commenting on my language settings, which are in spanish(btw).  I'm still relatively new to Perl (5 or 6), so I think I'll have to just get some basic perl going before anything shnazzy...

[08:31] *** dual joined
[08:33] *** zby_home left
[08:34] *** danoran left
[08:39] <daniel-s> rakudo: class A {my $!x; method get() {$!x}; method set($a) {$!x = $a}}; my $b = A.new(); $b.set(5); $b.get();

[08:39] <p6eval> rakudo 72d158: OUTPUT«Null PMC access in get_attr_str()␤  in main program body at line 2:/tmp/kbmEUJi7Dp␤»

[08:39] <daniel-s> rakudo: class A {my $!x; method get() {$!x}; method set($a) {$x = $a}}; my $b = A.new(); $b.set(5); $b.get();

[08:39] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Symbol '$x' not predeclared in set (/tmp/GFw0fmmT81:22)␤»

[08:39] *** jedai left
[08:40] <daniel-s> rakudo: class A {my $!x; method get() {$!x}; method set($a) {$!x = $a}}; my $b = A.new(); $b.set(5); #$b.get();

[08:40] <p6eval> rakudo 72d158: OUTPUT«Null PMC access in get_attr_str()␤  in main program body at line 2:/tmp/SUJIONoFWX␤»

[08:40] <daniel-s> rakudo: class A {my $!x; method get() {$!x}; method set($a) {$!x = $a}}; my $b = A.new(); #$b.set(5); $b.get();

[08:40] <p6eval> rakudo 72d158: OUTPUT«Null PMC access in get_attr_str()␤  in main program body at line 2:/tmp/avwu5T5His␤»

[08:41] <daniel-s> rakudo: #class A {my $!x; method get() {$!x}; method set($a) {$!x = $a}}; my $b = A.new(); $b.set(5); $b.get();

[08:41] <p6eval> rakudo 72d158:  ( no output )

[08:41] <daniel-s> rakudo: class A {my $x; method get() {$!x}; method set($a) {$!x = $a}}; my $b = A.new(); $b.set(5); $b.get();

[08:41] <p6eval> rakudo 72d158: OUTPUT«No such attribute '$!x'␤  in 'A::set' at line 22:/tmp/7rkYUlbyR0␤  in main program body at line 22:/tmp/7rkYUlbyR0␤»

[08:43] *** bkolera left
[08:50] *** dolmen joined
[08:53] *** kaare_ joined
[08:54] *** dolmen left
[08:55] *** jedai joined
[09:04] *** twinshadow left
[09:09] <felher> JimmyZ++: First thnx for uploading jnthn++ talks. But i fear they might be broken (were broken). I was not able to play them with either of mplayer, mplayer2, vlc. Both videos started but seem to be broken few moments after starting them. Is this just a mplayer{2,}, vlc issue or are they indeed broken?

[09:13] *** twinshadow joined
[09:31] <daniel-s> whose site is http://szabgab.com

[09:33] <tadzik> szabgab's

[09:33] <daniel-s> lol, makes sense

[09:35] <szabgab> :)

[09:37] *** xinming left
[09:38] *** jack-ji joined
[09:44] <daniel-s> hey

[09:44] <daniel-s> I was just reading stuff on your site

[09:44] <daniel-s> I have read alot of the tutorials on your site as well

[09:46] <jnthn> morning, #perl6

[09:46] <phenny> jnthn: 06:42Z <moritz> tell jnthn that I get lots of (new) segfaults in current nom spectest, https://gist.github.com/1073396 has the stack trace of a randomly chosen test

[09:46] <szabgab> daniel-s: I hope you liked them

[09:46] <szabgab> some are a bit outdated

[09:46] <jnthn> moritz: ugh. :/

[09:51] *** daniel-s left
[09:51] *** masak joined
[09:51] * masak is on a train

[09:52] <jnthn> Is it running late?

[09:53] <jnthn> </troll> :)

[09:57] *** masak` joined
[09:58] *** wamba joined
[09:58] *** daniel-s joined
[09:59] *** masak left
[10:00] *** buubot_backup left
[10:00] <masak`> jnthn: no, so far everything's dandy.

[10:00] <masak`> jnthn: but it seems the connections won't take me all the way :(

[10:01] <masak`> that's not the fault of SJ, though. it's just that the local communications suck.

[10:02] <masak`> apparently, no-one ever had the idea that someone would want to travel between those two particular hamlets on a Saturday afternoon...

[10:03] *** daniel-s left
[10:03] <masak`> oh, and btw: I get the feeling that whereas bringing a laptop on the train is nowadays accepted behaviour, bringing a laptom and an external keyboard is still considered slightly weird :P

[10:04] <jnthn> :P

[10:04] <jnthn> At least you took a *small* external keyboard. :)

[10:05] <masak`> with it and two chargers (computer+phone), I'm sitting in a small bird's nest of wires here. :)

[10:05] <masak`> (at least I put the headphones away)

[10:06] *** masak` is now known as masak

[10:12] *** daniel-s joined
[10:15] <dalek> rakudo/nom: f583316 | jonathan++ | src/binder/container.c:

[10:15] <dalek> rakudo/nom: Decontainerize a little earlier in scalar assignment, so that the value type check will actually work from the correct type check cache, rather than creating an inferior runloop to do the type check. Should very significantly speed up every $a = $b.

[10:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f58331690e

[10:15] *** masak` joined
[10:16] *** masak left
[10:17] *** masak` is now known as masak

[10:17] <masak> the "backtick dance", commonly practiced by people on Swedish public transport.

[10:18] <jnthn> .oO( ECONNECTIONNOTLAGOM )

[10:19] *** buubot_backup joined
[10:21] *** daniel-s left
[10:21] <tadzik> masak: why the external keyboard?

[10:21] <masak> tadzik: computer broke down during NPW. (probably due to stress.)

[10:22] <tadzik> oh

[10:22] <masak> tadzik: the keyboard was rendered 2/3 unusable.

[10:22] <tadzik> at least you can put the external keyboard on the normal keyboard and it won't press the keys below :)

[10:22] <tadzik> I always have this problem when putting notebook on a keyboard

[10:22] <masak> it will press 1/3 of the keys below :)

[10:22] <tadzik> ;)

[10:24] *** twinshadow left
[10:26] <jnthn> Ouch. The segfault happens in the fixed size pool allocator, deep in Parrot guts, of all places.

[10:27] <masak> oh noes not in the pool

[10:27] <jnthn> Got it reproduced in the debugger here. Sadly, it doesn't make it any more obvious what's going on than the bt moritz++ gisted.

[10:27] <jnthn> masak: Yeah, it's a very odd place to hit this.

[10:27] *** twinshadow joined
[10:31] <jnthn> The only patch that looks liable to have introduced this is the %_ handling one

[10:31] <masak> git bisect?

[10:32] <jnthn> Well, trouble is that the segfault doesn't even happen every run

[10:32] <jnthn> On the file I have it's liek 1 in 3 times :/

[10:33] <jnthn> Which almost certainly means it's memory corruption.

[10:35] <jnthn> aha

[10:35] <jnthn> found a couple of lines to comment out that reliably make the segfault go away

[10:35] *** whiteknight joined
[10:36] * jnthn can guess what's going on, and it would cause memory corruption...

[10:37] <colomon> woah -- I just tried pull and rebuild (nom) and got a segfault in the build.  I'm assuming this is probably what you guys are already looking at...

[10:40] <masak> std: 42.?"foo"()

[10:40] <p6eval> std 37a0cdd: OUTPUT«Potential difficulties:␤  Useless use of quotes at /tmp/vPgos3mZPe line 1:␤------> [32m42.?"foo"[33m⏏[31m()[0m␤ok 00:01 118m␤»

[10:40] *** xinming joined
[10:40] <jnthn> colomon: Others have seen it in the spectests

[10:40] <colomon> right

[10:40] *** [Sec] joined
[10:40] <jnthn> colomon: But now I know what's going on it's totally feazible it's show up while compiling the setting.

[10:41] <colomon> Looking more closely, it looks like it happened when compiling Test.pm to Test.pir.

[10:41] <jnthn> Also completely feasible

[10:41] <jnthn> Every time run Perl 6 code at BEGIN time we risk memory corruption.

[10:42] <jnthn> Testing a patch at the moment

[10:43] <jnthn> The %_ patch made an assumption that really it shoulda been able to. Turns out the fact it couldn't meant something else was busted.

[10:46] <jnthn> nom: BEGIN { $_ = 42; .say }

[10:46] <p6eval> nom: OUTPUT«Segmentation fault␤»

[10:46] <masak> o.O

[10:46] <jnthn> That's another manifestation of the same issue.

[10:47] <jnthn> (Glad it didn't work, or my theory on what's wrong woulda been wrong...)

[10:47] <masak> I just passed 300 lines with the text adventure.

[10:48] <colomon> masak++

[10:48] <masak> there's not a lot there yet, but anyone willing to play and give early feedback is most welcome to do so.

[10:49] <masak> https://github.com/masak/crypt

[10:49] <masak> oh, I have to get off this train :)

[10:49] <masak> o/

[10:49] *** masak left
[10:49] *** kcwu left
[11:00] *** drbean left
[11:00] *** Kivutarrr joined
[11:05] *** odrm joined
[11:05] *** kaare_ left
[11:08] *** daniel-s joined
[11:11] <JimmyZ> felher:  try KMPlayer or flash player ?

[11:11] *** REPLeffect left
[11:11] <JimmyZ> felher:  any player that can open *.flv

[11:12] <tadzik> where do I download those?

[11:13] *** daniel-s left
[11:15] *** daniel-s joined
[11:18] *** REPLeffect joined
[11:19] <JimmyZ> tadzik: http://irclog.perlgeek.de/perl6/2011-07-06#i_4070012

[11:22] <tadzik> lowndoading

[11:23] *** Kivutarrr left
[11:23] *** Kivutarrr joined
[11:23] <jlaire> vlc can play .flv no problem

[11:24] <JimmyZ> felher:  it would be appreciated to upload jnthn' talk to youtube

[11:25] <tadzik> I cannot download them now, HTTP request sent, awaiting response...

[11:27] <JimmyZ> it may be outdated :(

[11:28] <tadzik> is there a mirror?

[11:29] *** am0c left
[11:30] <dalek> rakudo/nom: 48e6bf7 | jonathan++ | src/binder/bind.c:

[11:30] <dalek> rakudo/nom: Extra check to make sure we don't corrupt memory when handling *%_ in optimized code path.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48e6bf724c

[11:30] <JimmyZ> tadzik: http://v.ku6.com/playlist/index_4350502.html

[11:34] <tadzik> thanks JimmyZ 

[11:34] <JimmyZ> tadzik: again, it would be appreciated to upload jnthn' talk to youtube :)

[11:35] <felher> JimmyZ: I guess KMplayer uses Mplayer. And each of Mplayer, Mplayer2, vlc are able to play flv. I see the first seconds of the video, but not more. But i'll just use your new link and watch them in my browser. Thnx :)

[11:35] <tadzik> I'll have to download it first, but I guess that's doable

[11:36] <JimmyZ> felher:  you're welcome

[11:36] <felher> akf &

[11:36] <felher> *afk & :)

[11:43] *** Kivutarrr left
[11:45] *** whiteknight left
[12:00] *** tokuhir__ joined
[12:02] *** ciphertext joined
[12:25] *** wamba left
[12:33] *** f00li5h left
[12:36] *** wamba joined
[12:46] <pmichaud> good morning, #perl6

[12:48] <jnthn> morning, pmichaud 

[12:48] <Trashlord> good afternoon, #perl6

[12:49] *** wamba left
[12:52] *** wamba joined
[12:52] <tadzik> good afternoon #perl6

[12:58] *** drbean joined
[12:59] *** Mowah left
[13:09] *** [Coke] left
[13:11] *** [Coke] joined
[13:12] *** wamba1 joined
[13:12] *** wamba left
[13:16] *** Mowah joined
[13:17] *** mberends joined
[13:18] <mberends> o/ #perl6 (from London)

[13:19] <pmichaud> mberends: o/

[13:19] <mberends> .oO( backlogging the past week is going to be quite a challenge )

[13:19] <pmichaud> yes, it will be.

[13:19] <pmichaud> We hope to keep it challenging.  :)

[13:19] <jnthn> hi mberends 

[13:20] <dalek> rakudo/nom: c23e04f | jonathan++ | src/ (2 files):

[13:20] <dalek> rakudo/nom: Add is rw trait for routines.

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c23e04f605

[13:20] <dalek> rakudo/nom: 6b6bc4e | jonathan++ | src/ (2 files):

[13:20] <dalek> rakudo/nom: Get of and returns trait to set return type for routines (not checked yet).

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b6bc4eea2

[13:20] <dalek> rakudo/nom: 1fa3334 | jonathan++ | src/core/ (2 files):

[13:20] <dalek> rakudo/nom: Introspection of .returns/.of on Routine.

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1fa3334270

[13:20] <dalek> rakudo/nom: 2f5b530 | jonathan++ | src/ (3 files):

[13:20] <dalek> rakudo/nom: Ops for decontainerizing if non-rw sub and for type checking return values.

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f5b530d09

[13:20] <dalek> rakudo/nom: 63e2719 | jonathan++ | src/core/ (4 files):

[13:20] <dalek> rakudo/nom: We run into code-gen issues for routines that evaluate to something void; avoid (heh, get it) that.

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63e2719f34

[13:20] <dalek> rakudo/nom: 9298db6 | jonathan++ | src/binder/multidispatch.h:

[13:20] <dalek> rakudo/nom: Copy-pasto.

[13:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9298db61f4

[13:20] <moritz> \o

[13:21] <mberends>  \o

[13:22] <pmichaud> in 63e2719, I think STORE_AT_KEY needs an is_rw

[13:23] <pmichaud> and it should probably be pir::set__1QsP  to avoid the extra $value statement.

[13:23] <jnthn> pmichaud: That wasn't the patch where I sprinkled those, but thanks, will add

[13:23] <jnthn> pmichaud: I think I tried that and PAST::Compiler did the Wrong Thing...

[13:23] <jnthn> Didn't I leave a comment...

[13:24] <pmichaud> the comment says you tried 2QsP, which will be a null.

[13:24] <jnthn> oh, that's what's already there

[13:24] <jnthn> I could try it as 1

[13:26] <dalek> 6model: dcfb55a | (Martin Berends)++ | c/ (3 files):

[13:26] <dalek> 6model: [6model/c] initial Configure and Makefile machinery

[13:26] <dalek> 6model: review: https://github.com/jnthn/6model/commit/dcfb55a2e9

[13:28] <jnthn> ooh, I'm going to have to watch this carefully

[13:28] <jnthn> Doubt I can build it though... .sh!

[13:28] <dalek> 6model: 665397f | (Martin Berends)++ | c/t/Test.h:

[13:28] <dalek> 6model: [6model/c/t/Test.h] initial TAP emitter for C based tests

[13:28] <dalek> 6model: review: https://github.com/jnthn/6model/commit/665397f27a

[13:28] <jnthn> oh, it promises a .bat :)

[13:28] <mberends> jnthn: I was not able to test a Configure.bat, but is will come :)

[13:28] <jnthn> mberends++

[13:28] <mberends> *it will

[13:30] <mberends> it has been very pleasing how well the dlopen() et al behaved.  This paves the way for a C based eval().

[13:31] <mberends> just worried about whether Win32 and its POSIX subsystem will also support it.

[13:31] <moritz> and the end of the output from ./perl6 t/spec/S02-builtin_data_types/assigning-refs.rakudo

[13:31] <moritz> I get:

[13:31] <moritz> # FUDGED!

[13:31] <moritz> too few arguments: 0 passed, 23198880 expected

[13:32] <jnthn> moritz: Is that new?

[13:32] <dalek> rakudo/nom: 6a28829 | jonathan++ | src/core/ (7 files):

[13:32] <dalek> rakudo/nom: First round of getting us more honest with routine rw-ness.

[13:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a28829df2

[13:32] *** lichtkind joined
[13:32] <jnthn> pmichaud: pir::set__1QsP worked

[13:33] <moritz> jnthn: not sure.. but the segfaults seem to have gone away

[13:34] <jnthn> moritz: Yeah, I fixed those.

[13:34] <moritz> jnthn++

[13:34] <jnthn> moritz: Was something in the *%_ patch

[13:35] <moritz> jnthn: just saw it in the log

[13:35] <dalek> 6model: 9e81523 | (Martin Berends)++ | c/t/01-toolchain/01a-cc.c:

[13:35] <dalek> 6model: [c/t/01-toolchain/01a-cc.c] test C compiler and dynamic library loader

[13:35] <dalek> 6model: review: https://github.com/jnthn/6model/commit/9e81523b5d

[13:36] <jnthn> mberends: There's a win32 equivalent for dlopen if it doesn't work right off

[13:36] *** im2ee left
[13:37] <mberends> jnthn: yeah, there's gotta be for .DLL files, just never needed to use it before

[13:38] <dalek> roast: 82ca32c | moritz++ | S12-c (2 files):

[13:38] <dalek> roast: unfudges and refudges for rakudo

[13:38] <dalek> roast: review: https://github.com/perl6/roast/commit/82ca32c02f

[13:39] <mberends> which Win32 C compiler requires the least amount of disk space?

[13:39] <mberends> eek, laptop battery has only 5 minutes remaining

[13:40] <mberends> o/

[13:40] *** mberends left
[13:40] *** im2ee joined
[13:47] *** mberends joined
[13:48] *** Moukeddar joined
[13:48] <Moukeddar> \o Perl6'ers

[13:49] <dalek> rakudo/nom: 5c4d4d9 | jonathan++ | src/core/List.pm:

[13:49] <dalek> rakudo/nom: A couple more places where we missed 'is rw'.

[13:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5c4d4d9fe2

[13:49] <dalek> rakudo/nom: fd88893 | jonathan++ | src/core/EnumMap.pm:

[13:49] <dalek> rakudo/nom: And one more 'is rw'.

[13:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd88893e90

[13:56] *** mberends left
[13:56] *** mberends joined
[14:00] *** drbean left
[14:01] *** [Coke] left
[14:02] *** mberends left
[14:03] *** MayDaniel joined
[14:03] *** [Coke] joined
[14:04] <tadzik> moritz: got a while?

[14:04] *** Moukeddar left
[14:09] <dalek> rakudo/nom: f2e0b4a | jonathan++ | src/ (3 files):

[14:09] <dalek> rakudo/nom: Make sure we don't lose scalarness of [...] and so forth that are returned, just rw-ness should be stripped.

[14:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2e0b4a604

[14:09] <dalek> rakudo/nom: dba1c2f | jonathan++ | src/Perl6/Actions.pm:

[14:09] <dalek> rakudo/nom: Turn on scalar decontainerization of return values, and return value type checking. Note we need to be careful to add 'is rw' now to routines that fall off the bottom with a value we expect to return in containerized form. Think I've caught all of these; testing welcome.

[14:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dba1c2f2aa

[14:13] <jnthn> break, bbs

[14:15] *** wamba1 left
[14:37] *** Zapelius left
[14:38] * TimToady is home again

[14:38] <phenny> TimToady: 08 Jul 21:14Z <sorear> tell TimToady  / <fun($/)> / doesn't use <.newlex> or <.finishlex> at all, does it create a new $/ or does it use the surrounding $*CURLEX's $/ ?

[14:39] <jnthn> wb, TimToady :)

[14:44] <jnthn> std: sub foo { }; sub foo { }

[14:44] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of routine 'foo' (see line 1) at /tmp/VEHAcmljus line 1:␤------> [32msub foo { }; sub foo[33m⏏[31m { }[0m␤Check failed␤FAILED 00:01 118m␤»

[14:44] <TimToady> the trip home yesterday was not supposed to be a redeye, but left 3 hours late, after several lightning delays and a medical emergency on board...fortunately while we were still parked...

[14:44] <pmichaud> TimToady: o/

[14:45] <TimToady> so if I'm grumpy today, it's not you :)

[14:45] <pmichaud> ...unless it is.  :)

[14:45] <TimToady> well, not only you :)

[14:47] <pmichaud> afk for a while -- bbl

[14:50] <dalek> rakudo/nom: a78aaa0 | jonathan++ | / (2 files):

[14:50] <dalek> rakudo/nom: Catch routine redeclaration in actions, rather than leaving it to IMCC to whine about.

[14:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a78aaa0de7

[15:12] *** [perlhack] joined
[15:12] *** MayDaniel left
[15:13] *** [perlhack] left
[15:15] <dalek> roast: 3dee80a | Coke++ | S02-magicals/dollar-underscore.t:

[15:15] <dalek> roast: track a nom regression.

[15:15] <dalek> roast: review: https://github.com/perl6/roast/commit/3dee80abf2

[15:15] <TimToady> sorear: re why 0 is false, mostly hysterical raisins: P<6 can't really tell the difference between a string being used as a number and a number being used as a string

[15:16] <TimToady> so the P6 answer up till now on that has been "like P5"

[15:17] <TimToady> but since P6 *can* tell the difference between those, we could think about revising it

[15:18] <TimToady> if we implement val() according to spec, and change the string truth rule, then '0' would be true, but <0> would be false, since it thinks of itself as a string only secondarily

[15:19] * [Coke] pokes dalek.

[15:19] <TimToady> I suspect the main point at which it would fool people is my $num = prompt("Pick a number: ")

[15:19] <TimToady> unless we default prompt to val semantics or teach people to write val prompt, or given them a different prompt function that assumes val

[15:20] <dalek> rakudo/nom: 734ed25 | Coke++ | t/spectest.data:

[15:20] <dalek> rakudo/nom: This test runs with a fudge.

[15:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/734ed25ad1

[15:20] <jnthn> TimToady: What decides whether you are allowed to mix in to something using does? e.g. what makes Foo.new does Bar OK, but 3 does Bar not OK? It feels like some kind of immutability thing.

[15:20] <TimToady> going the other way, it could fool people who aren't expecting my @strs = <I have 0 zebras> to use val on the 0

[15:21] <TimToady> but both of these seem relatively minor issues

[15:21] * jnthn didn't find anything on the spec

[15:21] <jnthn> (no hurry, I see you're pondering $other-issue at the moment too :))

[15:21] <TimToady> can anyone think of a more egregious counter-use-case?

[15:21] <TimToady> I think I'm done with "0".Bool for the moment...

[15:21] <jnthn> I can only expect people be surprised about the '0' case because tradition has made them expect it to be false :)

[15:21] <TimToady> but leaning towards making it True

[15:22] <TimToady> I'm trying to put my thumb on the scales of the future over the past here :)

[15:23] <TimToady> yes, you have to use 'but' instead to change the type of an immutable value, I think

[15:24] <TimToady> so it's very much an immutability thing

[15:25] <jnthn> Yeah, I would expect "but" to work

[15:25] <jnthn> Just wasn't sure how we decide immutability

[15:26] <jnthn> And it really matters now since if you mix into 0 then you've mixed into the 0 constant shared by your whole program in nom. :)

[15:27] <TimToady> sorear: re scoping of $/ in //, I'm inclined to keep the rule simple the way it is, and just use the outer $/, since we've already pretty much guaranteed to clobber it by the time the // finishes, and I find named decls to be a convenient ledge on the slippery slope

[15:27] <TimToady> the main problem here is the potential conflict with the laziness of regexen

[15:29] <TimToady> and, in fact, laziness is probably the main reason we shouldn't have just made the change we just made :)

[15:30] *** kaare_ joined
[15:30] <TimToady> I may have to retract it...

[15:30] <TimToady> or we put in some kind of laziness barrier to out-of-band dynvars

[15:30] <TimToady> not sure what that'd look like though

[15:32] <TimToady> we already had the problem writ small, when we could say things like my @x := gather $_ if /foo/ for @stuff

[15:33] <TimToady> since there's no real block there to contain a new $/

[15:33] <dalek> roast: bcdd95c | Coke++ | S02-names_and_variables/variables-and-packages.t:

[15:33] <dalek> roast: fudge for rakudo nom.

[15:33] <dalek> roast: review: https://github.com/perl6/roast/commit/bcdd95c94e

[15:33] <TimToady> perhaps we should suppress non-thread-local-ish updates to $/ or $! somehow

[15:34] <TimToady> so that gather would naturally not clobber your $/ or $!

[15:35] <TimToady> maybe we can force a separate co-routine/thread to get its own $/ or $!

[15:35] <TimToady> somehow...

[15:36] <TimToady> which is kind of an argument for declaring coroutines with named decls like other languages do, ah well... :)

[15:36] <TimToady> not gonna go there...

[15:37] <TimToady> main problem is knowing at compile time which thunks are going to end up parallelized, when the language itself is mutable

[15:38] *** kcwu joined
[15:38] <dalek> rakudo/nom: 63f8bd7 | jonathan++ | src/ (3 files):

[15:38] <dalek> rakudo/nom: proto auto-generation for methods, so it's now possible to write multi methods again without having to write an explicit proto. Re-uses generic instantiation get get the invocant type on the auto-gen'd proto right...a cunning use I'd not thought of for it. :-)

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63f8bd72a0

[15:38] <dalek> rakudo/nom: 1e5e666 | jonathan++ | t/spectest.data:

[15:38] <dalek> rakudo/nom: Now pass S12-methods/syntax.t again.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e5e666b48

[15:38] <dalek> rakudo/nom: ce6e224 | jonathan++ | src/Perl6/Actions.pm:

[15:38] <dalek> rakudo/nom: Start to differentiate between where we need to derive a dispatcher and when we need to auto-gen a proto for lexical multis.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce6e2248bb

[15:39] <TimToady> maybe the dynvar nature of $/ and $! saves us here, since the control routines for gatherish things can just declare new ones

[15:39] *** daniel-s_ joined
[15:39] <TimToady> in which case the compiler doesn't need to worry about it at all

[15:39] *** leprevost left
[15:40] <TimToady> we'd just have to be careful to make builtins like gather also intercept them

[15:40] *** huf left
[15:40] *** daniel-s_ left
[15:41] <TimToady> sorear: so I guess the short answer is that /stuff/ won't use the users $/ as long as some control structure inside defines its own $/

[15:41] <TimToady> which might actually depend on how lazy the particular RE is

[15:43] <TimToady> or not, if we just assume any RE is lazy

[15:43] *** im2ee left
[15:43] * TimToady flutters back onto the backlog log...

[15:44] *** im2ee joined
[15:47] *** thou left
[15:48] * TimToady wonders whether we should steal a meme from python and have a Batteries distribution that defines what any red-blooded or green-ichored programmer should expect in the standard module system...

[15:49] <TimToady> thinking specifically of things already in the spec, like DateTime

[15:50] <TimToady> but more editorially controlled than CPAN

[15:51] <TimToady> so that OS vendors would be expected to build up from Batteries, not just from baremetal P6

[15:52] <TimToady> unless they were specifically in the business of subsetting Batteries, which should be an explicit declaration

[15:52] <TimToady> (of the OS vendor, not in P6)

[15:52] <TimToady> better memes than Batteries also entertained...

[15:53] <TimToady> Normal, etc.

[15:53] <TimToady> "Norm" is nice and short :)

[15:53] <TimToady> and sounds like a nickname

[15:54] <jnthn> Clothed (as opposed to *bare*metal :))

[15:56] <TimToady> or "Norma"

[15:57] *** huf joined
[15:58] <dalek> rakudo/nom: 86fd89b | jonathan++ | src/Perl6/ (2 files):

[15:58] <dalek> rakudo/nom: First cut of nested lexical multis, which derive a dispatcher based on the one in the outer lexical scope.

[15:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/86fd89bd0b

[15:58] <dalek> rakudo/nom: 5448b49 | jonathan++ | NOMMAP.markdown:

[15:58] <dalek> rakudo/nom: Remove completed nommap item.

[15:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5448b49fd3

[16:02] <lichtkind> TimToady: nah, norma is a supermarket chain in germany

[16:04] *** tokuhir__ left
[16:05] *** [Coke] left
[16:07] <sorear> good * #perl6

[16:09] <lichtkind> sorear: o/

[16:11] <jnthn> hi sorear 

[16:12] <dalek> specs: 08b8886 | larry++ | S06-routines.pod:

[16:12] <dalek> specs: require parallelizers to declare $/ and $! dynvars

[16:12] <dalek> specs: 

[16:12] <dalek> specs: Spurred by a question from sorear++.  We need to be careful about async

[16:12] <dalek> specs: update of dynvars.  Probably need a more general policy here eventually.

[16:12] <dalek> specs: review: https://github.com/perl6/specs/commit/08b8886b8f

[16:13] <sorear> WHAT?  $/ and $! are dynvars now?

[16:13] <TimToady> always have been

[16:14] <sorear> jnthn: explain?

[16:14] <TimToady> S02:2812

[16:15] <jnthn> sorear: explain...what?

[16:15] <jnthn> sorear: dynvar bit?

[16:15] <sorear> yes

[16:15] <jnthn> Ah

[16:15] <jnthn> Sounds familiar but...

[16:15] <jnthn> my $/ is context; # means that it can be seen dynamically too

[16:15] <sorear> S02:2812 just talks about the validity of CALLER::<$/>

[16:16] <jnthn> Right

[16:16] <sorear> I thought TimToady was saying $/ == DYNAMIC::<$/>

[16:16] <sorear> er,  CONTEXT

[16:16] <jnthn> But if something is not marked "is context" (and all $*foo are by default) then they don't appear in CALLER

[16:16] <jnthn> Otherwise we can't optimize most lexicals down to locals/registers/whatever.

[16:17] <jnthn> my $a; foo() # foo can't use $CALLER::a

[16:17] <jnthn> my $a is context; foo() # foo can use $CALLER::a

[16:17] <sorear> anyways, this "thunks declare their own $/" business is troubling to me.

[16:17] <TimToady> eh, who said that?

[16:18] <TimToady> thunks can't declare their own $/

[16:18] <sorear> TimToady: you did.  S06:38

[16:18] *** donri joined
[16:18] <TimToady> if they do, it's a decl in the outer lexical scope

[16:19] <TimToady> "lazy constructs" is not referring to the thunk, but to the control code that potentially calls it

[16:19] <TimToady> dyamically

[16:19] <TimToady> *n

[16:20] <sorear> I always thought '$/' was a lexically scoped reference.

[16:20] <TimToady> sure, it's a lexical, just like all dynvars are

[16:20] <TimToady> but we really need to be able to intercept async updates to those vars

[16:20] <sorear> why?

[16:21] <sorear> and how?

[16:21] <TimToady> sanity

[16:21] <TimToady> that's what the new paragraph explains, is how

[16:22] <TimToady> things like .subst need to locate the $/ to update dynamically

[16:23] <TimToady> .match rather, to avoid confusing the issue

[16:23] <TimToady> .subst has extra $/ issues

[16:25] <TimToady> see the discussion in the backlog also

[16:26] <TimToady> specifically http://irclog.perlgeek.de/perl6/2011-07-09#i_4086805 and surroundings

[16:27] <TimToady> in that example reading @x could clobber $/

[16:27] <TimToady> that would violate Least Surprise

[16:28] <TimToady> we can't have $! or $/ behaving that volatilely or they will be essentially useless

[16:30] <sorear> TimToady: but then '$/' has to somehow find the $/ to read dynamically

[16:31] <sorear> TimToady: which conflicts with the notion that $/ reads the $/ in the nearest outer Routine

[16:31] <TimToady> yes, and it will be properly dynamically scoped when they do

[16:31] <sorear> or rather the nearest outer scope with a $/

[16:32] <sorear> sorry, I just got up and I don't understand how it's possible for $/ to be lexically and dynamically scoped at the same time.

[16:32] *** mberends joined
[16:34] <TimToady> I don't think it's lexically scoped in any sense that is extra over other dynamic variables

[16:34] <TimToady> some control code may have to be declared in a way that *doesn't* define a new dynamic $/ is all

[16:35] *** jack-ji left
[16:36] <sorear> TimToady: so basically you're saying say $/ should be compiled like say $*foo ?

[16:36] <TimToady> or maybe we could have a different default for routines that look like control code, such as those that declare formal & params

[16:36] <sorear> TimToady: what about $_ ?

[16:36] <TimToady> that's what the spec has said for a long time

[16:37] <TimToady> $_ is handled just as it was

[16:37] <sorear> where?

[16:37] <TimToady> where does it say that?

[16:38] <TimToady> S02:2812

[16:38] <sorear> that doesn't say anything about bare $/

[16:38] <sorear> it only talks about CALLER::<$/>

[16:39] <TimToady> "C<$_>, C<$!> and C<$/> are always dynamic, as are any variables whose declared names contain a C<*> twigil."

[16:39] <sorear> "dynamic" in that context just means "can be accessed through CALLER"

[16:39] <TimToady> it's just that blocks use a $_ param that defaults to the outer $_

[16:40] <TimToady> $/ and $! don't do that

[16:41] <TimToady> so if we, er, "simply" define the match routine not to declare $/, it will automatically find the caller's $/

[16:44] <TimToady> this is essentially the same problem as returning an exit code from a forked process immediately, which requires time travel.

[16:44] <TimToady> async code has to return data in-band, not out-of-band

[16:45] <TimToady> there can only be one event stream between two threads, or things go non-deterministic

[16:45] <TimToady> and since laziness is fundamentally async, we have to force anything async into a single event stream

[16:46] <dalek> rakudo/nom: e66182f | jonathan++ | src/Perl6/Actions.pm:

[16:46] <dalek> rakudo/nom: Toss dead code.

[16:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e66182f21e

[16:46] <dalek> rakudo/nom: 1c4235b | jonathan++ | src/Perl6/Actions.pm:

[16:46] <dalek> rakudo/nom: proto routine auto-generation for lexical multis.

[16:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c4235b923

[16:46] <dalek> rakudo/nom: fbe8267 | jonathan++ | t/spectest.data:

[16:46] <dalek> rakudo/nom: Three more passing test files.

[16:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fbe8267e4c

[16:46] <TimToady> er, that didn't come out right...

[16:46] <TimToady> and $! and $/ are fundamentally out-of-band

[16:48] *** [Coke] joined
[16:54] <dalek> roast: b075ede | jonathan++ | S12-introspection/parents.t:

[16:54] <dalek> roast: Make S12-introspection/parents.t not depend on how type objects stringify.

[16:54] <dalek> roast: review: https://github.com/perl6/roast/commit/b075ede780

[16:59] *** wamba joined
[16:59] <TimToady> jnthn++ for purging the p5-think

[17:00] <jnthn> TimToady: Well, also ~Any doesn't do the same thing in nom as master

[17:00] <jnthn> nom: say Any; say ~Any

[17:00] <p6eval> nom: OUTPUT«Any()␤Use of uninitialized value in string context␤␤»

[17:00] <jnthn> Due to .gist/.Str split, I guess

[17:02] <TimToady> there is a long history of confusing strings with types in Perl...

[17:02] <TimToady> I know who to blame it on, at least up until several years ago :)

[17:03] <TimToady> but the mistake was propagated in parrot culture too

[17:03] <jnthn> Yeah

[17:03] <jnthn> And it took a new objects implementation to really break free of it.

[17:04] * jnthn grudgingly implement .isa('Foo')

[17:04] <jnthn> *implemented

[17:05] <jnthn> Though the MOP doesn't even provide it.

[17:05] <TimToady> glad to see the memerot in this case :)

[17:05] * TimToady wonders if anyone has ever used the term "memerot" before...

[17:06] <TimToady> though in this case it's been taken out and shot repeatedly, and stayed undead

[17:07] <TimToady> "undead memes" is probably redundant

[17:10] *** JimmyZ left
[17:11] *** grey21 joined
[17:16] *** anonymous joined
[17:16] <jnthn> nom: say [Cool, [Any, [Mu]]] eqv [Cool, [Any, [Mu]]]

[17:16] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤Use of uninitialized value in string context␤Use of uninitialized value in string context␤Use of uninitialized value in string context␤Use of uninitialized value in string context␤Bool:…

[17:16] <jnthn> hm

[17:16] *** _jaldhar left
[17:16] *** anonymous is now known as Guest77419

[17:16] <TimToady> alternatively, we make $! and $/ more in-band, and they just record the last return value on the user end, and the called routine doesn't have to worry about them at all, but then s/// must be a macro that desugars to a call that sets $/ on return

[17:16] <jnthn> rakudo: say [Cool, [Any, [Mu]]] eqv [Cool, [Any, [Mu]]]

[17:16] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[17:17] * jnthn likes master's answer better...

[17:17] *** _jaldhar joined
[17:17] *** Guest77419 left
[17:18] <TimToady> nom: say [Cool, [Any, [Mu]]] ~~ [Cool, [Any, [Mu]]]

[17:18] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Mu, Mu $topic, Mu %_)␤␤current instr.: 'ACCEPTS' pc 398913 (src/gen/CORE.setting.pir:106021) (src/gen/CORE.setting:238)␤»

[17:18] <jnthn> Array.ACCEPTS sure ain't implemented

[17:18] <jnthn> eqv looks like a bunch of cheat

[17:18] <TimToady> cirsaw related maybe?

[17:19] <sorear> jnthn: what do you think of making $_ compile to find_dynamic_lex?

[17:20] <TimToady> we can probably stick with treating $_ as pure lexical, and leave it dynamic only in the sense that CALLER can see it

[17:21] <TimToady> since everybody has a lexical $_ one way or another

[17:21] <jnthn> TimToady: No, just NYI

[17:22] <TimToady> that's not cheating, that's just laziness :)

[17:23] <jnthn> sorear: Feels odd...given we always have one immediately in the block

[17:23] <jnthn> (unless I missed a proposal to change that...)

[17:24] <TimToady> no, it's just that S02:2812 lumps $_ in as always dynamic, but it's relatively meaningless from the standpoint of code gen

[17:24] <TimToady> we could make that clearer I suppose

[17:29] <sorear> jnthn: blocks yes but not Codes

[17:30] <jnthn> sorear: ah, true

[17:30] <sorear> TimToady: my @x := gather take $_ if .pie for @baz

[17:30] <TimToady> but they still have a $_

[17:30] <TimToady> from OUTER

[17:30] <sorear> TimToady: needs to use _gather's $_, not the Block's $_

[17:30] <jnthn> sorear: Thunks aren't really first class though...

[17:31] <TimToady> doesn't for already imply that

[17:31] <jnthn> sorear: There's not a situation where you can have one that wouldn't see its outer's $_

[17:31] <jnthn> afaik

[17:31] <TimToady> does for just temporize right now?

[17:31] <sorear> TimToady: yes

[17:32] <TimToady> is prolly enuf

[17:32] <TimToady> or rewrites front to ->$_{}

[17:33] <TimToady> could be ast-macro-y

[17:33] <jnthn> iirc Rakudo does that rewrite.

[17:33] <sorear> if $_ is being treated as a contextual, that makes some things nicer

[17:33] <TimToady> esp if we ever want -> behavior on those for loops

[17:33] <sorear> but not others

[17:34] *** ciphertext left
[17:34] *** grey21 left
[17:36] <TimToady> シャワーにdenkenします。＆

[17:45] *** Mowah left
[17:47] *** icwiener joined
[17:47] *** cooper joined
[17:59] *** pyrexkidd left
[17:59] <[Coke]> is there an implementation of enums in nom?

[18:00] <jnthn> no

[18:01] <[Coke]> thanks.

[18:02] <[Coke]> what about S12-introspection?

[18:03] *** [awall] joined
[18:03] *** [awall] left
[18:04] <[Coke]> nevermind, those are failing interestingly.

[18:07] <jnthn> [Coke]: Working on parents.t at the moment.

[18:14] <cognominal_> hi, what is the Perl 6 equivalent of Javascript Harmony proxies?  http://wiki.ecmascript.org/doku.php?id=harmony:proxies

[18:14] <cognominal_> …if any

[18:19] <[Coke]> argh. massive git rebase -i failure. :P

[18:21] <[Coke]> should have just done 31 commits. Is there a way to completely throw out a rebase?

[18:21] <[Coke]> ah, whew.

[18:29] <dalek> roast: db85667 | Coke++ | S (15 files):

[18:29] <dalek> roast: reflect current rakudo/nom state

[18:29] <dalek> roast: review: https://github.com/perl6/roast/commit/db85667ac1

[18:34] <dalek> Heuristic branch merge: pushed 21 commits to rakudo/nom by coke

[18:34] <[Coke]> I tried to collapse the commits on nom branch and was only able to combine them down to 21 commits instead of the 3 I was hoping for. Apologies.

[18:35] * sorear wonders what exactly TimToady is doing to his shower with the elctron microscope

[18:36] <sorear> cognominal_: implementation dependant

[18:37] <sorear> cognominal_: for 6model, you want to implement a new REPR and a new HOW

[18:37] <sorear> cognominal_: details TBD

[18:38] <[Coke]> jnthn++ # more passing tests.

[18:38] <[Coke]> almost worth having to merge that. :)

[18:38] *** kaare_ left
[18:38] <TimToady> Jetzt habe ich ein 電顕 nicht gekauft...  # corrections welcome

[18:39] *** Bzek left
[18:47] <dalek> roast: 6f1bf0c | jonathan++ | S12-introspection/parents.t:

[18:47] <dalek> roast: More de-stringification of parents.t.

[18:47] <dalek> roast: review: https://github.com/perl6/roast/commit/6f1bf0c8a5

[18:47] <dalek> roast: 41fda76 | jonathan++ | S (15 files):

[18:47] <dalek> roast: Merge branch 'master' of github.com:/perl6/roast

[18:47] <dalek> roast: review: https://github.com/perl6/roast/commit/41fda76314

[18:51] <sorear> phenny: de en " Jetzt habe ich ein 電顕 nicht gekauft"?

[18:51] <phenny> sorear: The de to en translation failed, sorry!

[18:51] <sorear> phenny: de en " Jetzt habe ich ein Substantiv nicht gekauft"?

[18:51] <phenny> sorear: "Now I have not bought a noun" (de to en, translate.google.com)

[18:51] *** masak joined
[18:51] <masak> oh hai!

[18:51] <sorear> o/ MASAK

[18:52] <masak> greetings from Nowhere In Particular! :)

[18:52] <masak> (it's slightly left of the middle of Sweden)

[18:53] <sorear> *envy*

[18:53] * sorear is in the subtropical USA coping with a heat wave

[18:54] <jnthn> dinner &

[18:54] <masak> the weather here is sunny but not intolerable.

[18:54] <masak> I should put in a few hours and finish crypt tonight.

[18:54] <dalek> rakudo/nom: 20abe0d | jonathan++ | src/Perl6/Metamodel/C3MRO.pm:

[18:54] <dalek> rakudo/nom: Fix up MRO computation when there's containered stuff around.

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/20abe0db74

[18:54] <dalek> rakudo/nom: bab5ed2 | jonathan++ | src/core/ (2 files):

[18:54] <dalek> rakudo/nom: Flesh out eqv a bit more.

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bab5ed2615

[18:54] <dalek> rakudo/nom: 98baf0f | jonathan++ | src/Perl6/Metamodel/MultipleInheritance.pm:

[18:54] <dalek> rakudo/nom: Implement :tree in .^parents.

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/98baf0f9dd

[18:54] <dalek> rakudo/nom: d31e835 | jonathan++ | t/spectest.data:

[18:54] <dalek> rakudo/nom: Run S12-introspection/parents.t,

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d31e835475

[18:54] <dalek> rakudo/nom: 322fcc0 | jonathan++ | src/ (3 files):

[18:54] <dalek> rakudo/nom: Implement Attribute.get_value.

[18:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/322fcc053d

[18:55] <masak> C3MRO sounds like a Star Wars droid. :P

[18:56] <masak> also, the :tree output from .^parents looks impressive, but I can't think of a single actual use for it.

[18:56] <masak> specifically, it doesn't say to which class the methods belong, IIRC.

[18:57] <jnthn> masak: er, .^parents returns...the parents.

[18:57] <jnthn> Not methods

[18:57] <jnthn> :)

[18:58] <masak> er.

[18:58] <masak> good point.

[18:58] <tadzik> Attribute.get_value, is that what we need for a nice Mu.perl? :)

[18:58] <masak> jnthn: I was thinking of .^methods(:tree), if there is such a thing.

[18:58] <tadzik> oh, masak-san. You want do discuss Formatting Codes a bit?

[18:58] <masak> tadzik: sure.

[18:58] <masak> tadzik: wasn't .perl supposed to be the one that doesn't break encapsulation?

[18:59] <tadzik> was it?

[18:59] <[Coke]> Tests: 6161

[18:59] <tadzik> yay!

[18:59] <masak> yay tests!

[19:00] <masak> tadzik: I want to discuss formatting codes! bring it on!

[19:00] <tadzik> masak: to cut the long story short: is there a more efficient way of handling formatting codes than figuring out a pod_string token, which checks every character for being a formatting code?

[19:00] <jnthn> tadzik: (Mu.perl) yes and it handles natives automagically for you

[19:00] <tadzik> jnthn: cute :)

[19:00] <masak> tadzik: does every formatting code contain a '<'?

[19:01] <tadzik> masak: yes. It's a capital letter, followed by a bunch of <'s

[19:01] <tadzik> no, post-processing is not an option really

[19:01] <masak> I see.

[19:01] <tadzik> because of B<=begin block ... =end block> Pod6 allows

[19:01] <masak> since you want a tree structure as your "result" (I presume), if I were you I'd definitely do it with a grammar.

[19:01] <masak> but maybe a dedicated one.

[19:02] <masak> i.e. one that only does the formatting codes.

[19:02] <tadzik> just for formatting codes, I thought about it. But again, due to magic like I presented, they have to be handled in the grammar anyway

[19:02] <masak> not sure I understand your example.

[19:02] <masak> what's it do?

[19:03] <tadzik> oh, wait

[19:03] <tadzik> I may have misread S26

[19:03] <masak> that happens to all of us, I think :P

[19:03] <tadzik> I frequently have trouble figuring out what in S26 is an example and what is just S26 itself

[19:04] <masak> yeah :)

[19:04] <tadzik> I think it may use the code I presented to bold a fragment of an example

[19:04] <masak> you'd really want to read the HTML output...

[19:04] <tadzik> yes, it seems so

[19:04] <tadzik> I wonder how much work I would have to do after GSoC to fully parse S26

[19:04] <masak> I know S26 talks about which formatting codes are to be interpreted literally and which ones are to be interpreted magically in verbatim blocks, or sump'n.

[19:06] <tadzik> yeah, allowing only some of them suggests post-processing

[19:07] <masak> not necessarily.

[19:07] <masak> it could also suggest having some checks in the rules in the grammar.

[19:07] <tadzik> In particular,

[19:07] <tadzik> you can nest comment blocks in the middle of a formatting code

[19:07] <tadzik> if you look this up in S26 you would be worried too :)

[19:07] <masak> heh :)

[19:07] * masak looks it up

[19:08] * tadzik tries to parse this example by hand

[19:09] <tadzik> I have no idea what this is supposed to represent, to be honest

[19:09] <masak> are you talking about S26:1540?

[19:10] * tadzik checks line numbers

[19:10] <tadzik> nope

[19:10] <tadzik> 1703

[19:10] * masak looks

[19:11] <tadzik> oh, I think I see what this means

[19:11] <tadzik> B<I shall bla bla =begin comment bla bla =end comment and bla bla>

[19:11] <tadzik> insane, imho

[19:12] <masak> I think your analysis is correct.

[19:12] <masak> but it also says there that formatting codes are just a type of block.

[19:12] <masak> so it's all nodes in a tree, basically.

[19:12] <tadzik> yeah, so no post-processing

[19:12] <masak> not if you can avoid it :)

[19:13] <masak> I agree that the whole concept of =comment feels very meta :)

[19:13] <tadzik> now =code :allow<B> bothers me

[19:13] <masak> that's the thing you'd have to use dynvars for.

[19:13] <tadzik> so the grammar rule itself has to figure out what kind of tokens it allows inside

[19:13] <masak> yep.

[19:13] <masak> might be specific to =code, I dunno

[19:14] <tadzik> it's for everything

[19:14] <masak> brb, keep talking :)

[19:14] <TimToady> mutable derivative languages, who'da thunk?

[19:14] <tadzik> those block options are not in my schedule, but I feel like implementing them anyway in some spare moment

[19:15] <TimToady> well, mutated by derivation, more precisely...

[19:15] <TimToady> just like the quote nibbler does

[19:15] <TimToady> (in STD, anyway)

[19:16] <masak> yes.

[19:16] <masak> I think this amounts to the same thing.

[19:18] <TimToady> the big point of p6 parsing is that you can mixin new escapes and still have all the old ones

[19:18] *** wamba left
[19:18] <TimToady> and the JIT lexer is supposed to Just Work

[19:19] <TimToady> STD actually does mix in bits of grammar roles to do things like Q:qq:w

[19:19] <masak> TimToady: when you mix in new grammar into something, where do the new actions go?

[19:19] <TimToady> yes, well, that's a sore point :)

[19:20] <masak> yeah :/

[19:20] <TimToady> "a subject of ongoing research" :)

[19:20] <TimToady> suggestions welcome...

[19:20] *** colomon left
[19:20] <tadzik> okay. So if FormattingCodes are just another blocks, are they allowed, top-level in Perl 6 code?

[19:21] <TimToady> not all blocks are created equal

[19:21] <tadzik> no, for <[A..Z]>'<' is not a directive

[19:21] <tadzik> ok, I get it, kinda

[19:22] <TimToady> niecza: { $^a }

[19:22] <p6eval> niecza v7-20-gd3c5fc0: OUTPUT«Unhandled exception: No value in mainline available for parameter $a␤  at /tmp/DqRXTRiYwT line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-…

[19:22] <TimToady> innersting

[19:22] <masak> tadzik: I guess that's not the only restriction on how blocks can be nested.

[19:23] <TimToady> niecza: if 42 { $^a }

[19:23] <tadzik> masak: what do you mean?

[19:23] <p6eval> niecza v7-20-gd3c5fc0: OUTPUT«Unhandled exception: No value in mainline available for parameter $a␤  at /tmp/UqmiJ5g38p line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-…

[19:23] <TimToady> is that a compile-time or run-time error?

[19:23] <jnthn> nom: if 42 { say $^a } # curious...

[19:23] <p6eval> nom: OUTPUT«42␤»

[19:23] <TimToady> ooh, yea

[19:23] <TimToady> hmm

[19:23] <TimToady> bad example, maybe

[19:23] <jnthn> TimToady: Looks like runtime from the backtrace.

[19:24] <TimToady> niecza: BEGIN { $^a }

[19:24] <p6eval> niecza v7-20-gd3c5fc0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Placeholder variable $^a may not be used here because the surrounding block takes no signature at /tmp/jTDSdW1Hzf line 1:␤------> [32mBEGIN { [33m⏏[31m$^a }[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/…

[19:24] <TimToady> that's what I was looking for...

[19:24] <jnthn> nom: BEGIN { $^a } # again, curious...

[19:24] <p6eval> nom: OUTPUT«Cannot use placeholder parameters in this kind of block at line 1, near " # again, "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23533 (src/stage2/gen/NQPHLL.pir:6314) (src/stage2/gen/NQPHLL.pm:328)␤»

[19:25] <tadzik> Segmentation fun! https://gist.github.com/1073860

[19:25] <TimToady> that block is definitely not created equal, unless it's the other ones that aren't...

[19:25] <jnthn> Not as good an error, but compile time.

[19:25] <tadzik> jnthn: could you take a peek?

[19:25] *** peczenyj joined
[19:25] <TimToady> the niecza one is also compile time

[19:25] <TimToady> that last one

[19:25] <jnthn> tadzik: Two things

[19:25] <jnthn> tadzik: substr($_.name, 2, nqp::chars($_.name))

[19:25] <TimToady> "Check failed"

[19:25] <jnthn> tadzik: We talked about that one the other day

[19:26] <jnthn> just use 2 arg form of substr, or you'll have to box the return value from nqp::chars

[19:26] <jnthn> You're feeding a Parrot object into a Perl 6 sub. The binder hates that.

[19:26] <tadzik> oh, ok

[19:26] *** peczenyj left
[19:26] <jnthn> I guess I should figure out how to make it hate it in a less segfaulty way though

[19:26] <TimToady> All that being said, misplaced placeholders are not checked by grammar mixin

[19:27] <jnthn> tadzik: The other thing is that get_value needs an argument! :)

[19:27] <jnthn> tadzik: Or it doesn't know what object to grab the attribute value for.

[19:27] <tadzik> oh! :)

[19:27] <TimToady> semantics tend to be the domain of dynvars instead of syntax

[19:27] <TimToady> (compiler dynvars)

[19:27] <tadzik> is 'self' sufficient?

[19:27] <jnthn> tadzik: yes, that's what you want in this case.

[19:28] <jnthn> tadzik: as masak said, I'm not sure if .perl is the one that should break the encapsulation though

[19:28] <jnthn> tadzik: Or whether only DUMP should do that

[19:28] <tadzik> I think rakudo does that

[19:28] <tadzik> master, I mean

[19:28] * jnthn looks around for a language designer :)

[19:29] <masak> tadzik: it does.

[19:29] <masak> (and that's wrong)

[19:29] <jnthn> (iyo)

[19:29] <masak> right.

[19:29] <jnthn> (or I want a spec ref)

[19:29] <tadzik> it should return the code that creates the same structure. How do you do that w/o breaking encapsulation?

[19:29] <masak> to be honest, I don't remember which one of .perl and .pretty was supposed not to break encapsulation.

[19:29] <jnthn> tadzik: Well, you can't actually return code that creates the same structure in that sense

[19:30] <jnthn> tadzik: Because .new doesn't by default accept values for privates

[19:30] <jnthn> (in nom)

[19:30] <tadzik> hmm, true

[19:30] <masak> tadzik: if constructors aren't supposed to accept values for accessor-less attrs, the point is kinda moot anywa... what jnthn said.

[19:30] <jnthn> masak: Yeah. Depends if the point is for debugging or not

[19:30] <tadzik> multi method DUMP(Mu:D:) { self.perl }

[19:30] <jnthn> I suspect that DUMP - since it's uppercase - is fine to break encapsulation.

[19:31] <tadzik> ok

[19:31] <jnthn> Uppercase means OMGWTF :)

[19:31] <jnthn> And .perl maybe should not

[19:31] <jnthn> And then add a DUMP(Any:D:)

[19:31] <jnthn> In Any

[19:31] <jnthn> Which otherwise delegates to .perl

[19:31] <jnthn> oh, wait

[19:31] <jnthn> no, that's silly

[19:31] <jnthn> :)

[19:31] <jnthn> hm

[19:31] <tadzik> anyway, I get Method 'get_value' not found for invocant of class 'BOOTSTRAPATTR'

[19:32] <jnthn> grr...does this mean we need a whole hierarchy of DUMP as well as one of perl...

[19:32] <tadzik> sniff sniff, is that circularity? :)

[19:32] <jnthn> tadzik: oh heh

[19:32] <masak> I don't *want* a standard dumping function that breaks encapsulation. am I the only one?

[19:32] <jnthn> tadzik: Yup

[19:32] <tadzik> well, it's good that the method I wrote is useless anyway then ;)

[19:32] *** offby1 is now known as snord

[19:32] <jnthn> masak: I guess you write code that doesn't ever need to be debugged.

[19:32] *** snord is now known as offby1

[19:32] <masak> jnthn: it's not that.

[19:32] <masak> jnthn: it's about making stupid things slightly inaccessible.

[19:33] <jnthn> masak: Are you really saying "let's make anybody who wants to be able to dump the innards of an object install a CPAN module"?

[19:33] <tadzik> you can still break it with MOP, can't you?

[19:33] <sorear> TimToady: BEGIN calls blast which calls block which calls newlex(0)

[19:33] <jnthn> tadzik: Sure

[19:33] <sorear> TimToady: { } uses pblock which uses newlex(1)

[19:33] <tadzik> I guess that's the beginning of Data::Dumper :)

[19:33] <masak> jnthn: no, I'm saying "to break encapsulation, do .HOW and then .get_attribute($name, $obj)"

[19:33] <masak> jnthn: make it a little hard :)

[19:33] <sorear> TimToady: this sets $*CURLEX<!NEEDSIG>, which is checked by add_placeholder

[19:34] <jnthn> masak: I think .DUMP (in uppercase) is quite clear that you're doing something "interesting"

[19:34] <masak> bleh

[19:34] <tadzik> or .HOW :)

[19:34] <sorear> TimToady: the error message in { $^a } is LTA because it's generated after inlining...

[19:34] <jnthn> Right

[19:34] <masak> jnthn: what good is real encapsulation if we provide all those primitives to break it?

[19:34] <masak> jnthn: before you know it you have lots of code parsing the .DUMP output :(

[19:34] <tadzik> phenny "gościnność"?

[19:35] <tadzik> phenny: "gościnność"?

[19:35] <phenny> tadzik: "hospitality" (pl to en, translate.google.com)

[19:35] <masak> tadzik: the word looks like "guestishness", which kinda makes sense :)

[19:35] <tadzik> maybe we need a role Hospitality, which just breaks encapsulation without worrying, and you can apply it to your classes if you want to :)

[19:35] <masak> tadzik: or maybe "hostishness".

[19:35] <tadzik> masak: it's something like that, yes :)

[19:36] <jnthn> masak: I...find the fact that somebody would think of doing that kinda depressing. :/

[19:37] <masak> if I were BDFL, I'd charge anyone wanting to add a .DUMP method with first studying encapsulation in OO for a week, and then writing a one-page essay on why it's a good thing.

[19:37] <jnthn> masak: If they're stupid enough to do that, they're stupid enough to install a CPAN module that lets them do the same thing and parse its output too, I suspect.

[19:37] <masak> (it would appear I need to work on the "B" part of "BDFL") :P

[19:37] <masak> jnthn: yes. I'm just saying let's not encourage it in core.

[19:38] <masak> jnthn: the .HOW.get_attr is *needed* as a last-resort safety valve.

[19:38] <masak> jnthn: for things like serialization and object construction.

[19:38] <masak> jnthn: but besides that... it should be *tough* to break that encapsulation layer.

[19:39] <masak> "private" should mean something.

[19:39] *** Patterner left
[19:39] <jnthn> Well, I've said what I think. I can't be bothered to waste any more time on this.

[19:40] <jnthn> I've done the MOP bit, I'll leave @other to work out what .perl and .DUMP will and won't do.

[19:40] <masak> "Perl 6 objects: more like coconuts than like grapes"

[19:44] <TimToady> .oO(I've...got...a loverly bunch of coconuts...)

[19:44] <cognominal_> sorear, thx

[19:44] <masak> TimToady: don't know the reference, but it sounds catchy :)

[19:46] * TimToady is wondering about syntax that supports SSA better, and incidentally makes it easy to declare SSA-style "constants" that don't take sigils

[19:46] <sorear> I started with Perl because I'm allergic to languages that try to enforce good practice

[19:47] <masak> sorear: point taken.

[19:47] <TimToady> suggest strongly is pretty okay though :)

[19:48] <masak> bbl

[19:52] <TimToady> such as reserving my x = stuff() if x is lowercase and/or unrecognized

[19:52] *** jevin_ left
[19:52] <TimToady> or maybe tie it to ::= instead

[19:52] <TimToady> that is, allow current constant syntax for 'my' as well, restricted to SSA semantics

[19:53] <TimToady> might be a net win, and the absense of a sigil will remind people to treat them as readonly

[19:53] <TimToady> just like constants, except they can be rebound next time through

[19:53] *** jevin joined
[19:54] <TimToady> might be a net win (almost typed newt win...)

[19:56] *** cognominal_ left
[19:58] *** cognominal joined
[19:59] *** jevin left
[20:08] <sorear> TimToady: sub foo($f) { $/ := 2; $f(&say) }; $/ := 1; foo(*.($/)); # what does this print?

[20:12] <TimToady> I would think it prints 1

[20:12] <TimToady> *.($/) does not make the identity of $/ lazy

[20:12] <TimToady> or thunky

[20:13] <TimToady> and we already use * to escape the placeholder rules that disallow two levels of formals

[20:14] *** cognominal left
[20:14] <sorear> TimToady: why does it not make the identity lazy?

[20:15] <TimToady> why should it?

[20:15] *** cognominal joined
[20:15] <sorear> TimToady: because you could be passing the code object to &GATHER or something

[20:15] <TimToady> hmm

[20:17] <TimToady> well, maybe it is lazy then--I guess that's how we expect dynvars to behave anyway

[20:17] * TimToady is just shooting from a jet-lagged hip here...

[20:17] *** molaf joined
[20:18] * TimToady feels a fork coming, in the chess sense...

[20:19] * TimToady wonders if it's worth distinguishing $/ from $*/, and decides probably not, since most uses of $/ are implicit anyway

[20:21] <TimToady> one can do my $dl := $/; if one really needs to access the lexical $/, I suppose

[20:22] <TimToady> perhaps that implies that $/ should just be set with assignment semantics, so we avoid rebinding it too often

[20:22] <tadzik> how would iterate over the characters in a string in nqp?

[20:23] <TimToady> maybe you have to not-quite iterate... :P

[20:24] *** wamba joined
[20:26] <tadzik> :)

[20:26] <tadzik> all that comes to my mind is substr() magic :/

[20:27] <jnthn> nqp: my @chars := pir::split('', 'abcde'); say +@chars

[20:27] <p6eval> nqp: OUTPUT«Null PMC access in add()␤current instr.: '_block1000' pc 0 ((file unknown):1)␤»

[20:27] <jnthn> nqp: my @chars := pir::split('', 'abcde'); say(+@chars)

[20:27] <p6eval> nqp: OUTPUT«5␤»

[20:27] <jnthn> tadzik: That then iterate over the array works

[20:27] <tadzik> oh, that works too, nice

[20:27] <jnthn> tadzik: substr is probably nasty

[20:27] <tadzik> yeah

[20:28] <jnthn> tadzik: Because if it's a UTF-8 string (which it probably is) it'll scan from the start every time :/

[20:28] <tadzik> yeah

[20:29] <sorear> TimToady: why avoid binding?  binding is cheaper than assingment in nom, IIUC

[20:30] <jnthn> sorear: True, but the gap is *much* smaller than in master.

[20:30] <jnthn> oh, though binding was awful in master too...

[20:30] <jnthn> :/

[20:31] * jnthn has busted generic instantiation, which is a pain to debug :(

[20:36] * masak is spent

[20:37] <TimToady> better than being bought...

[20:38] <masak> I think so, yes. I also haven't sold out.

[20:38] <masak> and I'm going to cash in on some well-earned sleep :)

[20:38] <masak> 'night, Perl 6 knights.

[20:39] <jnthn> night, masak

[20:39] *** masak left
[20:39] <tadzik> gah, I'm typing too slow

[20:45] *** im2ee left
[20:46] *** im2ee joined
[20:51] <awwaiid> I just (re-)learned that niecza compiler is written in perl6 with C# only for runtime support? neat

[20:54] *** Psyche^ joined
[20:54] *** Psyche^ is now known as Patterner

[21:00] *** kst left
[21:01] <TimToady> pmichaud, moritz: re http://irclog.perlgeek.de/perl6/2011-07-08#i_4082133 <?before \s*> is not a no-op to the lexer, since LTM follows a before in preference to what comes after it

[21:06] *** im2ee left
[21:20] <moritz> ah.

[21:24] *** NecroWater joined
[21:24] <dalek> rakudo/nom: 8ff1db3 | moritz++ | t/spectest.data:

[21:24] <dalek> rakudo/nom: 5 more passing test files

[21:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ff1db3c5d

[21:26] *** NecroWater left
[21:27] *** odrm left
[21:28] *** GodFather joined
[21:30] <dalek> roast: 675dd78 | moritz++ | S03- (2 files):

[21:30] <dalek> roast: two wee rakudo unfudges

[21:30] <dalek> roast: review: https://github.com/perl6/roast/commit/675dd781fa

[21:31] <jnthn> ooh, yay, more tests.

[21:31] <jnthn> :)

[21:32] <moritz> Files=225, Tests=6417

[21:32] <jnthn> Wow. And that's before we have regexes. :)

[21:33] <tadzik> so it's 6418 on podparser :P

[21:33] <tadzik> if there are no regressions

[21:35] <dalek> roast: 6b6ba2a | moritz++ | S03-operators/eqv.t:

[21:35] <dalek> roast: some rakudo unfudges in eqv.t

[21:35] <dalek> roast: review: https://github.com/perl6/roast/commit/6b6ba2af8c

[21:36] * jnthn is tinkering with generics some more

[21:38] <pmichaud> TimToady: (before \s*)   Makes perfect sense, thanks.

[21:38] <pmichaud> "in preference of" means "instead of"?

[21:42] *** Psyche^ joined
[21:44] <moritz> nom: my ::T $foo = 3; say T

[21:44] <p6eval> nom: OUTPUT«Type check failed in assignment to '$foo'; expected 'T' but got 'Int'␤current instr.: '_block1002' pc 28 ((file unknown):0) (/tmp/Z6MiUHTh7T:1)␤»

[21:46] *** Patterner left
[21:46] *** Psyche^ is now known as Patterner

[21:46] * jnthn wonders what that even means...

[21:46] <jnthn> nom: my ::T $foo; say T

[21:46] <p6eval> nom: OUTPUT«Could not find sub &T␤current instr.: '_block1002' pc 73 ((file unknown):64254729) (/tmp/bZqSRNwwZp:1)␤»

[21:46] <moritz> jnthn: ask masak. https://rt.perl.org/rt3//Ticket/Display.html?id=72814

[21:47] <jnthn> I guess he just saw NPMCA and ticketed it :)

[21:47] <jnthn> it is, after all, always wrong

[21:48] <moritz> jnthn: right, but I can still point a finger at him and should "he should know!!!"

[21:49] <jnthn> :D

[21:49] <tadzik> std: my ::T $foo; say T

[21:49] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[21:50] <Util> Is there a problem with adding .classify to nom, or is it just NYI ?

[21:50] <moritz> seems like a type capture

[21:50] <moritz> tadzik++

[21:50] <moritz> Util: should work

[21:50] <tadzik> moritz: I didn't do anything :)

[21:50] <moritz> tadzik: you asked std

[21:50] <tadzik> oh, moritz, I'll ask you something

[21:50] <jnthn> wait, what's it capturing? :)

[21:51] <jnthn> nom: my ::T $foo; say $foo.WHAT

[21:51] <p6eval> nom: OUTPUT«Cannot call a method on type variable T␤current instr.: 'nqp;Perl6;Metamodel;GenericHOW;find_method' pc 20734 (src/gen/perl6-metamodel.pir:4429) (src/gen/Metamodel.pm:123)␤»

[21:51] <moritz> jnthn: the type of the value first assigned to the variable?

[21:51] <jnthn> no wai

[21:51] <tadzik> about parsing FormattingCodes, do you see any better option than making something like pod_string { [ <formattingcode> || . ]+ }?

[21:51] *** Kivutarrr joined
[21:52] <GodFather> Newbie: What's wrong with this code?  rule ph { abc }  my $s = "abc";  print ("OK\n") if $s ~~ / <ph>/;  I get error Useless declaration of has-scoped .....

[21:52] <tadzik> you probably want this to be "my rule"

[21:52] <jnthn> *my* rule ph { abc }

[21:52] <Util> rakudo: my @a = 1..5; my %h = @a.classify({$_ %% 2}); %h.perl.say;

[21:52] <p6eval> rakudo 72d158: OUTPUT«{"Bool::False" => [1, 3, 5], "Bool::True" => [2, 4]}␤»

[21:53] <Util> nom:    my @a = 1..5; my %h = @a.classify({$_ %% 2}); %h.perl.say;

[21:53] <p6eval> nom: OUTPUT«Method 'classify' not found for invocant of class 'Array'␤current instr.: '_block1002' pc 122 ((file unknown):150) (/tmp/FFFKSTPc6m:1)␤»

[21:53] <tadzik> has-scoped is like a class attribute, I guess rules default to that

[21:53] <Util> Looks NYI to me, moritz 

[21:54] <GodFather> Ok, tried that get Error Method  'ph' not found for invocant of class 'Cursor' etc

[21:54] <tadzik> that's a rakudobug, you probably need <ph=&ph> or something like this

[21:55] <tadzik> rakudo: my rule ph { abc }; my $s = "abc";  print ("OK\n") if $s ~~ / <ph=&ph>/

[21:55] <p6eval> rakudo 72d158: OUTPUT«OK␤»

[21:55] <jnthn> or just <&ph> if you just want a match

[21:55] <jnthn> (but not to capture)

[21:56] <GodFather> jnthn, thanks that worked

[21:58] *** jevin joined
[21:59] *** jevin left
[22:00] *** drbean joined
[22:01] *** soh_cah_toa joined
[22:03] *** icwiener left
[22:10] <moritz> [Coke]: I think it was you who asked that a few days ago... if you want accurate count of skipped spectests, run tools/test_sumamry.pl

[22:13] *** jferrero left
[22:15] *** jevin joined
[22:16] *** jferrero joined
[22:28] * [Coke] supposes he should get back to tests...

[22:29] <[Coke]> moritz: oh, I was just curious. that "test=" number isn't a true count, esp. as we re-fudge things to get more files running again. That's all.

[22:30] <[Coke]> oh - as you look at test files, try to un-skip tests - I've found a few that are todo'able or even pass.

[22:41] *** jevin left
[22:41] *** wamba left
[22:49] *** Kivutarrr left
[23:05] *** Kivutarrr joined
[23:09] <dalek> rakudo/nom: c30f5f3 | jonathan++ | src/ops/perl6.ops:

[23:09] <dalek> rakudo/nom: Fix .VAR, which in turn was causing problems deep in generic instantiation of attributes.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c30f5f35f3

[23:09] <dalek> rakudo/nom: 12e692c | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[23:09] <dalek> rakudo/nom: Correct earlier patch to attribute generic instantiation.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/12e692c33d

[23:09] <dalek> rakudo/nom: 8e8d803 | jonathan++ | src/Perl6/ (2 files):

[23:09] <dalek> rakudo/nom: Fixes to make sure type variables can be seen inside the role body.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8e8d8032bc

[23:09] <dalek> rakudo/nom: 5aba02f | jonathan++ | src/Perl6/Actions.pm:

[23:09] <dalek> rakudo/nom: Type variables need to defer to runtime lookup rather than being compile-time resolved in attribute lookup.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5aba02fd6b

[23:09] <dalek> rakudo/nom: 0280c83 | jonathan++ | t/spectest.data:

[23:09] <dalek> rakudo/nom: We now pass S14-roles/submethods.t.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0280c83a01

[23:09] <dalek> rakudo/nom: 1f04cbc | jonathan++ | src/Perl6/Actions.pm:

[23:09] <dalek> rakudo/nom: Also make sure mentions of generic types as terms are not resolved too early, so T.new works.

[23:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f04cbc3bf

[23:10] *** ciphertext joined
[23:14] <dalek> rakudo/nom: fb396ad | jonathan++ | NOMMAP.markdown:

[23:14] <dalek> rakudo/nom: Update nommap.

[23:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb396ad295

[23:17] *** dorlamm joined
[23:17] <[Coke]> hurm. I'm getting conflicts trying to do this interactive rebase. I have 4 commits to the same file. Each one changes different lines in the file. If I re-order the commits in the interactive editor, it always generates a conflict.

[23:18] <[Coke]> any suggestins?

[23:29] *** orafu left
[23:29] *** orafu joined
[23:32] *** jevin joined
[23:38] *** lichtkind left
[23:38] *** molaf left
[23:41] *** bluescreen10 left
[23:41] <dalek> roast: 46ff167 | Coke++ | S1 (2 files):

[23:41] <dalek> roast: track rakudo/nom

[23:41] <dalek> roast: review: https://github.com/perl6/roast/commit/46ff167e45

[23:41] *** bluescreen10 joined
[23:43] <dalek> rakudo/nom: 6d729b9 | Coke++ | t/spectest.data:

[23:43] <dalek> rakudo/nom: list errors

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6d729b9406

[23:43] <dalek> rakudo/nom: ec9adf4 | Coke++ | t/spectest.data:

[23:43] <dalek> rakudo/nom: run fudged test

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ec9adf4894

[23:43] <dalek> rakudo/nom: d4a91f4 | Coke++ | t/spectest.data:

[23:43] <dalek> rakudo/nom: errors

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4a91f4514

[23:43] <dalek> rakudo/nom: 417acfb | Coke++ | t/spectest.data:

[23:43] <dalek> rakudo/nom: run fudged test

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/417acfb4f5

[23:46] *** f00li5h joined
[23:48] * [Coke] just pushes. ;)

[23:52] <jlaire> rakudo: say (1,2,3).map: *.Str()

[23:52] <p6eval> rakudo 72d158: OUTPUT«123␤»

[23:52] *** molaf joined
[23:52] <jlaire> rakudo: say (1,2,3).map: *.Str().WHAT

[23:52] <p6eval> rakudo 72d158:  ( no output )

[23:53] <jlaire> nom: say (1,2,3).map: *.Str().WHAT

[23:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[23:53] <TimToady> rakudo: say (1,2,3).map: *.Str().PARROT

[23:53] <p6eval> rakudo 72d158: OUTPUT«StringStringString␤»

[23:53] <TimToady> vm leakage

[23:54] <jlaire> ok, that's what the local error smells like

[23:54] <jlaire> ===SORRY!=== Type objects are abstract and have no attributes, but you tried to access $!do

[23:55] <jlaire> nom: say (1,2,3).map: *.Str().WHAT

[23:55] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[23:56] <TimToady> rakudo: say (1,2,3).map: *.Str.WHAT

[23:56] <p6eval> rakudo 72d158:  ( no output )

[23:56] <TimToady> rakudo: say (1,2,3).map: *.Str.PARROT

[23:56] <p6eval> rakudo 72d158: OUTPUT«StringStringString␤»

[23:56] *** Kivutarrr left
[23:56] <TimToady> sounds like you tried to .() a WHAT

[23:57] <jlaire> Str without parens give the same error

[23:57] <TimToady> which should make a coercer, but maybe it doesn't

[23:57] <TimToady> ah, so it's internal

[23:57] <TimToady> yes, Str should invoke as coercion, so there's some disconnect somewhere

[23:57] <jlaire> nom: say (1,2,3).map: *.Str.WHAT

[23:58] <p6eval> nom: OUTPUT«Method 'count' not found for invocant of class 'Str'␤current instr.: '_block8724' pc 428189 (src/gen/CORE.setting.pir:119060) (src/gen/CORE.setting:2151)␤»

[23:58] <jlaire> nom: say (1,2,3).map: *.Str().WHAT

[23:58] <p6eval> nom: OUTPUT«Method 'count' not found for invocant of class 'Str'␤current instr.: '_block8724' pc 428189 (src/gen/CORE.setting.pir:119060) (src/gen/CORE.setting:2151)␤»

[23:58] <jlaire> nom: say (1,2,3).map: *.Str

[23:58] <p6eval> nom: OUTPUT«Method 'count' not found for invocant of class 'Str'␤current instr.: '_block8724' pc 428189 (src/gen/CORE.setting.pir:119060) (src/gen/CORE.setting:2151)␤»

[23:58] <TimToady> oh, yes, that's the parrot leakage

[23:59] *** envi left
[23:59] <jlaire> nom: say (1,2,3).map: *

[23:59] <TimToady> not sure what count does there though

[23:59] <p6eval> nom: OUTPUT«Method 'count' not found for invocant of class 'Whatever'␤current instr.: '_block8724' pc 428189 (src/gen/CORE.setting.pir:119060) (src/gen/CORE.setting:2151)␤»

[23:59] <jlaire> oh well

[23:59] <TimToady> oh, finding the max arity

[23:59] <TimToady> *.Str ought to return a WhateverCode

