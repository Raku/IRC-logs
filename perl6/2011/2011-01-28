[00:01] *** kst left
[00:01] *** kst joined
[00:06] <masak> moritz_: maybe your experience with .?including shows that it shouldn't be run on type objects? after all, they are our undefined values nowadays, not just Any.

[00:16] *** MayDaniel left
[00:18] *** pmurias left
[00:21] *** flatwhatson left
[00:22] *** Trashlord joined
[00:24] *** [particle] left
[00:25] *** [particle] joined
[00:28] *** stkowski left
[00:28] *** vmspb left
[00:29] *** ponbiki left
[00:31] <masak> I blogged, lol: http://strangelyconsistent.org/blog/a-quick-p6cc-status-update

[00:32] <masak> 'night, #perl6.

[00:32] <diakopter> n

[00:32] *** masak left
[00:34] *** ponbiki joined
[00:41] <dalek> nqp-rx/nom: 94b693e | jonathan++ | src/ (4 files):

[00:41] <dalek> nqp-rx/nom: Give native attrs a firey baptism by switching $!pos and $!from attributes in Cursor to be native int attributes. This saves a bunch of boxing/unboxing and as a result should reduce GC churn and also be a memory improvement for big parses (since Match objects reference Cursor objects). Note that Match objects still need to store these boxed for now, but that'll be fixed in the future and be a further memory usage and GC churn reduction.

[00:41] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/94b693e319

[00:41] <colomon> \o/

[00:41] <colomon> (I'm assuming the tests actually pass.... ;)

[00:41] <jnthn> No regressions shown up in make test.

[00:41] <colomon> jnthn++

[00:42] *** Vlavv_ left
[00:42] <colomon> I can't tell you how excited I am to see all these commits from you.  :)

[00:42] *** Vlavv joined
[00:43] <jnthn> colomon: Here's what to look forward to: class Complex { has num $!re; has num $!im; ... } # :-)

[00:43] <colomon> hmmm... except it's kind of nice to have any real type allowed internally for Complex.  but the speed.... the speed....

[00:43] <jnthn> Today a Num is 3 PMCs big, and a Complex totals 8.

[00:44] <jnthn> With native attrs it can be 1.

[00:44] <colomon> woof.

[00:44] <TimToady> well, that would be type complex, not Complex :)

[00:44] <jnthn> Meaning they'll use a bunch less memory.

[00:44] <jnthn> TimToady: ?

[00:44] <jnthn> TimToady: That'd still be a reference type.

[00:44] <TimToady> native complex consisting of 2 nums

[00:45] <jnthn> TimToady: I don't know that Complex - just becuase it has reference semantics - needs to store non-native Nums?

[00:45] <jnthn> TimToady: Anyway, we can do complex with num and num too. :)

[00:46] <jnthn> I thought the difference was that complex is more native-structish and Complex is not.

[00:46] <TimToady> certainly if Complex is a role it could use num or Num or Rat

[00:46] <TimToady> or maybe the role name is sompthing else

[00:46] <flussence> that reminds me... I might be able to make my DWIM .Buf thing once this stuff's in place.

[00:46] <jnthn> Hm

[00:46] <TimToady> we'd certainly like compact arrays of native complexes without refs

[00:47] <TimToady> heavy-duty PDLish stuff

[00:47] <jnthn> TimToady: Yes, I figured that's what complex will do, and Complex would not.

[00:47] <colomon> I personally like the idea that Complex is two Reals, and complex is two nums.  That seems like a nice choose between expressiveness and raw firepower.

[00:47] <TimToady> which Complex? :)

[00:47] <jnthn> TimToady: Anyway, I don't really mind exactly how we factor it, tbh. :)

[00:48] <colomon> TimToady: I was implying that Complex is a class, not a role.  :)

[00:48] <jnthn> TimToady: I'm just happy that I've got pretty close to supporting those. :)

[00:48] <TimToady> indeed

[00:48] <TimToady> I'm very excited me own self

[00:48] <TimToady> I very much like the direction all this is going, aka "faster"

[00:49] <jnthn> TimToady: In STD do Match objects maintain a reference back to the cursor?

[00:49] <colomon> faster!

[00:50] <jnthn> TimToady: They do in nqp-rx, Rakudo, etc. It's fine if it's needed, but we seem to use it in relatively few places and it means that we end up keeping a bunch more objects around.

[00:51] <TimToady> STD doesn't really distinguish Match from Cursor currently; it just pretends they're the same type, and cheats on the mutable/immutable bits

[00:51] <jnthn> Ah, OK.

[00:51] <jnthn> I'll see what pmichaud++ thinks. :)

[00:53] <jnthn> TimToady: BTW, one thing to ponder.

[00:53] * TimToady ponders zero things

[00:53] <jnthn> TimToady: If I write class Foo { has int $!a; has int $!b; }

[00:53] <jnthn> And I then have a my Foo @x;

[00:54] <jnthn> Is that "magically" a compact array of compact structs?

[00:54] <jnthn> That is, does "oh, all the types in there are themselves native or compact" the condition for the whole class being considered a compact struct?

[00:54] <jnthn> I worry a little that this could be too magical.

[00:54] <TimToady> that's kinda how the spec reads currently, but I hear your concern

[00:55] <jnthn> Maybe I'm C# brain-damaged, but it has a struct keyword for the one meaning and a class keyword for the other.

[00:55] <jnthn> Not especially suggesting that "struct" is the keyword we want

[00:55] <jnthn> But being clear which semantics you're looking for feels kinda useful

[00:55] <jnthn> I can also see the case where you have

[00:56] <jnthn> class Foo { has $!bar; has $!baz } and you want Foo to act like a compact struct with two pointers to other objects.

[00:56] <jnthn> Which is an option we preclude at present.

[00:57] *** whiteknight joined
[01:02] <TimToady> so maybe that's a distinction on the array rather than the class

[01:03] <TimToady> and maybe it defaults to the same nativeness as the inner type, but can be forced opposite

[01:05] <jnthn> Maybe it's a difference of representation.

[01:06] <jnthn> Though one representation could easily know to act in either way too.

[01:06] <jnthn> Anyway, I'm not going to block on an answer any time soon.

[01:06] <TimToady> and might have to for MI

[01:07] <jnthn> Well, not *too* soon. :)

[01:07] <jnthn> But I hope not too far into the future either. :)

[01:07] <jnthn> Yes, MI limits object layout possibilities.

[01:07] *** kst left
[01:08] *** kst joined
[01:10] <jnthn> Time to rest. I need to do something workish tomorrow. :) o/

[01:11] *** drbean joined
[01:11] *** cafesofie left
[01:28] *** felliott left
[01:34] *** cafesofie joined
[01:36] *** felliott joined
[01:36] *** felliott left
[01:40] *** jevin joined
[01:43] *** cafesofie left
[01:45] <sorear> good * #perl6

[01:45] <phenny> sorear: 27 Jan 16:49Z <diakopter> tell sorear  pmurias didn't quite use the right syntax for phenny: :)  05:05 < pmurias> tell sorear re -Bnam you mean -Bclisp?

[01:45] <sorear> phenny: tell pmurias yes.

[01:45] <phenny> sorear: I'll pass that on when pmurias is around.

[01:49] * colomon is suddenly in love with zavolaj

[01:54] <sorear> moritz_: (Perl 6 is MAD) TimToady decided that long ago ;)

[01:59] <sorear> bah I missed jnthn

[01:59] <sorear> I need his help understanding native types

[02:06] *** kst left
[02:06] *** kst joined
[02:07] <colomon> can you monkey patch a role?  somehow that doesn't seem to make sense to me....

[02:18] <TimToady> roles are immutable

[02:18] <sjohnson> camel patch

[02:19] <colomon> shucks.

[02:19] <colomon> I just implemented the math functions in http://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/ using zavolaj.

[02:20] <colomon> trivially easy to do.  zavolaj++

[02:20] <colomon> now I'm trying to figure out how to make it a useful module.

[02:22] <colomon> I think they should probably be in core in the long run, but  I thought implementing it as a module using zavolaj would be a useful exercise.

[02:25] *** JimmyZ joined
[02:25] <colomon> Math::Unusual  ?

[02:26] <colomon> Math::ExtendedLibrary  ?

[02:31] *** TiMBuS left
[02:34] *** TiMBuS joined
[02:37] *** felliott joined
[02:38] *** TiMBuS left
[02:39] *** aindilis joined
[02:40] *** woosley joined
[02:40] *** TiMBuS joined
[02:59] *** noganex joined
[03:02] *** TiMBuS left
[03:03] *** noganex_ left
[03:03] *** agentzh joined
[03:06] *** whiteknight left
[03:09] *** justatheory left
[03:12] *** TiMBuS joined
[03:14] *** cafesofie joined
[03:17] *** TiMBuS left
[03:20] *** JimmyZ left
[03:22] *** TiMBuS joined
[03:23] *** cdarroch left
[03:33] *** TiMBuS left
[03:36] *** TiMBuS joined
[03:38] *** cafesofie left
[03:40] *** am0c joined
[03:46] *** justatheory joined
[03:49] *** envi joined
[04:01] <diakopter> sorear: 

[04:01] <diakopter> .g CompilerGlobalScopeAttribute

[04:01] <phenny> diakopter: http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.compilerglobalscopeattribute.aspx

[04:04] <sorear> good * #perl6

[04:04] <diakopter> * * *

[04:05] <sorear> diakopter: what about it?

[04:06] <diakopter> thought maybe it could cross appdomain or assembly boundaries (or just namespace)

[04:06] <sorear> colomon: having lots of methods in a role is a (mild) smell

[04:06] <sorear> colomon: since the method table has to be duplicated a lot

[04:06] <sorear> diakopter: "This class is used only for communication with debugger tools."

[04:07] <diakopter> hm, I didn't see that

[04:27] *** Su-Shee left
[04:28] *** Su-Shee joined
[04:30] <lue> hello zebras! o/

[04:42] <colomon> \o

[04:48] *** kst left
[04:48] *** kst joined
[04:49] <dalek> niecza: 5c57dd5 | moritz++ | t/fudgeandrun:

[04:49] <dalek> niecza: use mono to run spectests until we have a better solution

[04:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5c57dd586e

[04:49] <dalek> niecza: 9a4634a | moritz++ | t/run_spectests:

[04:49] <dalek> niecza: run more tests

[04:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9a4634a69a

[05:00] *** felliott left
[05:09] *** satyavvd joined
[05:28] *** flatwhatson joined
[05:35] *** JimmyZ joined
[05:36] *** JimmyZ left
[05:50] * sorear out

[05:52] *** kaare_ joined
[05:53] *** envi left
[05:57] *** envi joined
[06:36] *** xinming_ joined
[06:40] *** xinming left
[06:40] *** orafu left
[06:40] *** orafu joined
[06:40] <woosley> rakudo:  my @a=(24,4);sub fo(@a){say |@a.perl};fo(@a);

[06:40] <p6eval> rakudo 549d2a: OUTPUT«[24, 4]␤»

[06:46] <woosley> rakudo:  my @a=(24,4);sub fo(@a){ my $b = |@a; say $b.perl};fo(@a);

[06:46] <p6eval> rakudo 549d2a: OUTPUT«\(24, 4)␤»

[06:50] *** justatheory left
[06:50] <woosley> rakudo:  my @a=(24,4);sub fo(@a){ my $b = |(|@a); say $b.perl};fo(@a);

[06:50] <p6eval> rakudo 549d2a: OUTPUT«\(24, 4)␤»

[06:53] *** agentzh left
[07:10] *** agentzh joined
[07:21] *** drbean left
[07:22] *** justatheory joined
[07:30] *** cjk101010 joined
[07:31] *** amkrankruleuen left
[07:32] *** amkrankruleuen joined
[07:32] *** fhelmberger joined
[07:41] *** dju left
[07:44] *** fhelmberger left
[07:50] *** justatheory left
[07:59] *** kfo_ joined
[08:02] *** kfo left
[08:04] *** pnu left
[08:09] *** kst left
[08:09] *** kst joined
[08:14] *** pnu joined
[08:14] *** jimmy1980 left
[08:15] *** jimmy1980 joined
[08:21] *** masak joined
[08:22] <masak> morning, #perl6.

[08:23] *** amkrankruleuen left
[08:23] *** amkrankruleuen joined
[08:33] *** wtw joined
[08:42] *** JimmyZ joined
[08:45] *** timbunce joined
[08:50] *** jimmy1980 left
[08:50] *** tzhs joined
[08:51] <woosley> rakudo: my $a = ([x => 1, x=>2]); my $b = |$a; say $b.perl; 

[08:51] <p6eval> rakudo 549d2a: OUTPUT«\("x" => 1, "x" => 2)␤»

[08:51] <woosley> rakudo: my @a = ([x => 1, x=>2]); my $b = |@a; say $b.perl; 

[08:51] <p6eval> rakudo 549d2a: OUTPUT«\(["x" => 1, "x" => 2])␤»

[08:52] <masak> rakudo: my @a = x => 1, x=>2; my $b = |@a; say $b.perl

[08:52] <p6eval> rakudo 549d2a: OUTPUT«\("x" => 1, "x" => 2)␤»

[08:52] <woosley> my $a = ([x =>1, x=>2], [x =>3]); say |$a.perl

[08:53] <woosley> rakudo: my $a = ([x =>1, x=>2], [x =>3]); say |$a.perl

[08:53] <p6eval> rakudo 549d2a: OUTPUT«(["x" => 1, "x" => 2], ["x" => 3])␤»

[08:53] <woosley> akudo: my @a = ([x =>1, x=>2], [x =>3]); say |@a.perl

[08:54] <woosley> rakudo: my @a = ([x =>1, x=>2], [x =>3]); say |@a.perl

[08:54] <p6eval> rakudo 549d2a: OUTPUT«[["x" => 1, "x" => 2], ["x" => 3]]␤»

[08:55] <masak> woosley: |$a.perl and |@a.perl might not do what you think.

[08:56] *** jimmy1980 joined
[08:56] <masak> woosley: method postfix is tighter than almost anything, including symbolic unary.

[08:56] <woosley> Those things are so confusing...

[08:56] <masak> well, they have to be one way or the other. :)

[08:56] <masak> they're less confusing once you look them up.

[08:57] <masak> may I recommend S03, especially the table in the beginning?

[08:57] <masak> http://perlcabal.org/syn/S03.html#Operator_precedence

[08:57] <woosley> rakudo:  say |([x => 1, x=>2]).perl

[08:57] <p6eval> rakudo 549d2a: OUTPUT«["x" => 1, "x" => 2]␤»

[08:58] <masak> same thing there.

[08:58] <masak> your essentially flattening the Str from .perl

[08:58] <woosley> S06 says:  |([x=>1, x=>2]);  # List (from an Array), becomes \((x=>1), (x=>2))

[08:59] *** puge left
[08:59] <moritz_> note that the | is not included in the .perl

[08:59] <moritz_> because method calls have tighter precedence

[08:59] <woosley> Oh, right

[08:59] <masak> woosley: this is moritz_. he likes to repeat what I say.

[08:59] <JimmyZ> rakudo: say (|([x => 1, x=>2])).perl

[08:59] <p6eval> rakudo 549d2a: OUTPUT«\("x" => 1, "x" => 2)␤»

[09:00] <masak> and for some reason people understand him better. :P

[09:00] <moritz_> masak: sometimes it works :-)

[09:00] <masak> I'm not complaining; just amused. :)

[09:00] <woosley> rakudo: say (|([x => 1, x=>2], [x => 3])).perl

[09:00] <p6eval> rakudo 549d2a: OUTPUT«\(["x" => 1, "x" => 2], ["x" => 3])␤»

[09:01] <woosley> Interesting

[09:01] <woosley> Why say (|([x => 1, x=>2])).perl is not returning \(["x" => 1, "x" => 2])

[09:02] <moritz_> because f(a, b) is not the same as f((a, b))

[09:02] <moritz_> the former has two positional arguments, the latter one

[09:03] <moritz_> so maybe you want |(|[...])

[09:03] <moritz_> or not

[09:03] <moritz_> depending on what you want to achieve

[09:03] <woosley> but f((a)), f((a, b)) is something similar

[09:03] *** drbean joined
[09:03] <moritz_> similar, but not the same

[09:04] <moritz_> rakudo: say (1) ~~ Positional

[09:04] <p6eval> rakudo 549d2a: OUTPUT«Bool::False␤»

[09:04] <moritz_> rakudo: say (1, 2) ~~ Positional

[09:05] <p6eval> rakudo 549d2a: OUTPUT«Bool::True␤»

[09:05] <moritz_> hm

[09:06] <woosley> rakudo: @a = 2, 3, 4; my :($f, $o) := \(|@a); say $f.perl

[09:06] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Malformed my at line 22, near ":($f, $o) "␤»

[09:07] <moritz_> std: my  @a = 2, 3, 4; my :($f, $o) := \(|@a); say $f.perl

[09:07] <p6eval> std 625303c: OUTPUT«===SORRY!===␤Malformed my at /tmp/CMJ6as_O3c line 1:␤------> my  @a = 2, 3, 4; my ⏏:($f, $o) := \(|@a); say $f.perl␤    expecting scoped declarator␤Parse failed␤FAILED 00:01 122m␤»

[09:07] <woosley> rakudo: @a = 2, 3, 4; my :($f, *$o) := \(|@a); say $f.perl

[09:07] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Malformed my at line 22, near ":($f, *$o)"␤»

[09:07] <moritz_> rakudo: my ($f, $o, @a); @a = 2, 3, 4; :($f, $o) = \(|@a); say $f.perl

[09:07] <p6eval> rakudo 549d2a: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/et1Qk2fhnM␤»

[09:08] <moritz_> rakudo: my ($f, $o, @a); @a = 2, 3, 4; :($f, $o) := \(|@a); say $f.perl

[09:08] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/39pL0QTcgl␤»

[09:08] <moritz_> rakudo: my ($f, $o, @a); @a = 2, 3, 4; :($f, $o, $) := \(|@a); say $f.perl

[09:08] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 3␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/eeH_GtWW59␤»

[09:08] <moritz_> that's... curious

[09:08] <woosley> moritz_:  This code is taken from book using perl6/chap 4/4.6 unpacking

[09:08] <woosley> and it is not working

[09:09] <moritz_> woosley: that's bad... care to open a ticket on github for it?

[09:09] <moritz_> for the book, that is

[09:09] <moritz_> or maybe rakudobug? /me not sure

[09:09] <woosley> rakudo: my @a=4,5,6; my ($f, *$o) = @a; say $f.perl 

[09:09] <p6eval> rakudo 549d2a: OUTPUT«4␤»

[09:10] <woosley> I don't know how to submit rakudo bug, but sure I can open a ticket on github for the book

[09:11] <moritz_> I'll do the rakudobug

[09:11] <moritz_> mailto:rakudobug@perl.org

[09:12] <moritz_> rakudo: my ($f, $o, @a); @a = 2, 3; :($f, $o, $) := \(|@a); say $f.perl

[09:12] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 3␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/x7pZHTnCH2␤»

[09:13] <moritz_> rakudo: my ($f, $o, @a); @a = 2, 3; :($f, $o) := |@a; say $f.perl

[09:13] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/tad0HKVRnS␤»

[09:13] <woosley> Capture is alway consider to be a scalar? 

[09:15] <masak> woosley: things stored in $ variables are treated as scalars unles explicitly transformed somehow.

[09:15] <masak> inclusing lists, arrays, and hashes.

[09:16] *** Mowah joined
[09:16] <moritz_> ... unless the $ var is bound contextless

[09:16] <moritz_> rakudo: sub f(\$x) { for $x { .say } }; f(1, 2, 3)

[09:16] <p6eval> rakudo 549d2a: OUTPUT«Too many positional parameters passed; got 3 but expected 1␤  in 'f' at line 1:/tmp/DaTJ5CjVXh␤  in main program body at line 22:/tmp/DaTJ5CjVXh␤»

[09:17] <moritz_> rakudo: sub f(\$x) { for $x { .say } }; f((1, 2, 3))

[09:17] <p6eval> rakudo 549d2a: OUTPUT«1␤2␤3␤»

[09:17] *** kst left
[09:17] <woosley> rakudo: my ($a, $b) := 5;

[09:17] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/SmnvZnU1ir␤»

[09:17] <moritz_> here $x contains a flattening list. Very confusing

[09:17] *** kst joined
[09:18] <woosley> that't what S06 says, |@a returns \(blalala)

[09:18] <moritz_> colomon: re http://justrakudoit.wordpress.com/2011/01/28/zavolaj/ what LibM or Math::LibM or Math::Extended or so?

[09:22] <masak> Math::Like::The::Natives

[09:31] *** woosley left
[09:32] *** tzhs left
[09:32] *** dakkar joined
[09:32] *** daxim joined
[09:35] *** skangas left
[09:35] *** skangas joined
[09:38] <tadzik> ~~

[09:40] <masak> hi, koala.

[09:46] <moritz_> masak: regarding p6cc, will you let the different solutions play against each other?

[09:48] <masak> moritz_: so far, I've been running solutions to find out specific things. don't know if I will bother letting solutions play against each other... it's a cool idea, for sure.

[09:49] <masak> things I've needed to find out so far have been limited to "is this indeed the wrong algorithm?" and "is this as slow as it looks?"

[09:51] *** wallberg joined
[09:55] *** JimmyZ left
[09:56] *** mberends joined
[09:59] <mberends> masak++ # all the Perl 6 Coding Contest activity :-)

[09:59] <masak> \o/

[09:59] <masak> mberends: nice to see all the progress on nqp-jvm, too!

[10:01] *** agentzh left
[10:01] <mberends> it surprises me that with all the work that has gone one, the passing test count sits stubbornly at 45. there should have been some removal of blockers by now, methought.

[10:01] <mberends> *gone in, meh

[10:02] <frettled> gone in 60 seconds? :)

[10:02] <masak> jnthn seems to think some LHF is imminent.

[10:02] <frettled> masak: There are some nifty tricks played by the contestants, pretty cool.

[10:03] <masak> frettled: yes. I don't think I had realized that code exhibition/review would be this big a part of the contest. I'm glad it is.

[10:04] <frettled> Yep, that's the best part of it, I think.

[10:05] <masak> of the tasks, p4 is the Kobayashi Maru. :)

[10:09] *** drbean left
[10:10] <frettled> Oh, really?

[10:10] <frettled> Do you think that Captain Moritz will come up with a novel solution?

[10:11] <tadzik> how do I make the class Callable, so it reacts to $obj()?

[10:11] *** wallberg left
[10:11] <tadzik> rakudo: class Foo { method invoke() { 1 } }; my $a = Foo.new; say $a()

[10:11] <p6eval> rakudo 549d2a: OUTPUT«invoke() not implemented in class 'Foo'␤  in main program body at line 22:/tmp/owhF4WKzVM␤»

[10:11] <masak> frettled: everyone blew p4, exept arnsholt (who blew the deadline instead).

[10:11] <tadzik> rakudo: No, it _is_ implemented!

[10:11] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Confused at line 22, near "No, it _is"␤»

[10:11] <frettled> masak: aha :D

[10:12] <masak> tadzik: postcircumfix:<( )>

[10:12] <tadzik> so what's with this invoke() thingy?

[10:12] <masak> tadzik: a Parrot internalism.

[10:12] <frettled> Slightly LTA error message, then.

[10:12] <masak> aye.

[10:13] *** wallberg joined
[10:15] *** ab5tract joined
[10:17] *** wallberg left
[10:27] *** kst left
[10:27] *** kst joined
[10:43] <mberends> github.com currently seems to be heavy overloaded. A clone of mono/mono.git is barely proceeding, and one of perl6/nqp-rx aborted three time with various server error symptoms. Github seems to be a victim of its own success :/

[10:44] *** snearch joined
[10:45] <arnsholt> Yeah, it was never very snappy, but now it's just ridiculous

[10:46] <Tene> mberends: That's not quite what they're a victim of. >.>

[10:50] *** tzhs joined
[10:53] *** coldhead left
[10:53] <jnthn> morning, #perl6

[10:54] <mberends> ahoy jnthn :)

[10:54] <tadzik> ohay

[10:55] *** coldhead joined
[10:57] <jnthn> mberends: Aww...no more test passes yet? 

[10:57] <jnthn> mberends: Are you still using the hacked down setting?

[10:57] <jnthn> mberends: Or the Real Thing?

[10:57] *** tzhs left
[11:00] <masak> mornin', jnthn

[11:00] <jnthn> mberends: Looks like the one we hacked down for debugging.

[11:00] <jnthn> masak: ohhai

[11:00] * jnthn slept in quite a bit :)

[11:00] <jnthn> Stayed up last night hacking on...stuff. :)

[11:00] <masak> :)

[11:00] * masak woke up surprisingly early today

[11:01] * jnthn tries pointing nqpjvm at the real setting, out of curiosity.

[11:02] <jnthn> Aww. Doesn't quite manage it.

[11:02] *** satyavvd left
[11:02] <mberends> jnthn: nope. I think there is a $*BIND_VALUE missing from some part of PAST2JSTCompiler.pm

[11:03] <jnthn> mberends: The setting provides many of the ops and built-in types, so you can probably pass more tests already by starting to bring bits over from the setting.

[11:03] <jnthn> mberends: Yes, I can an error about that too.

[11:03] <jnthn> mberends: I guess if you bring pieces of the setting over a bit at a time, you'll at the same time golf down an example of what's wrong.

[11:03] <mberends> that global is conditionally created, except when it is isn't :/

[11:04] <jnthn> Contextual. Not global. :)

[11:04] <jnthn> It should hang out in a pair with a true value of $*BIND_CONTEXT though. :)

[11:04] * mberends sits corrected

[11:05] <mberends> *should* !!! that's the bug! thanks jnthn ;)

[11:06] <masak> jnthn++

[11:07] *** IllvilJa left
[11:07] <jnthn> mberends: Just adding a single multi to the NQPSetting.pm in the java dir trigges a related mis-compile too.

[11:08] <mberends> ok, so compiling any multi might be the problem. no time now, but a useful clue for later :)

[11:09] <jnthn> mberends: Your emit_lexical_lookup is RONG.

[11:10] <jnthn> Hmm, seems the correct version is there but marked TODO :)

[11:10] *** JimmyZ joined
[11:11] <mberends> that means when it's uncommented, it crashes even worse

[11:14] <jnthn> ah, yes...

[11:14] <jnthn> OK.

[11:21] <jnthn> mberends: Let me know if you want me to debug further. But it looks to me like getting the binding sorting out would get multis there - or way closer - and then it's copy-paste of setting code to get you a bunch more passes. :)

[11:22] *** kst left
[11:23] *** kst joined
[11:23] *** IllvilJa joined
[11:24] <mberends> thanks jnthn, I don't want to consume your tuits, and there is enough for me to proceed with :)

[11:24] <jnthn> OK :)

[11:24] <jnthn> mberends++ # nqpjvm :)

[11:25] <masak> jnthn++ diakopter++ mberends++

[11:28] *** redicaps joined
[11:28] <tadzik> what to hack on, hmm

[11:31] <mberends> neutro for Windows?

[11:31] <tadzik> I made it ready for Windows, there was just no one to test it

[11:34] <flussence> ooh, I know!

[11:34] <flussence> add url-installing to it!

[11:36] <tadzik> hah, like in the old times!

[11:36] <tadzik> do you remember the first version? You'll be giving it the git url, and it'll clone, ufo and make install it :)

[11:36] <tadzik> not a bad idea

[11:37] <tadzik> so, anywants want to pick an LHF?

[11:38] * moritz_ considers learning C#, so that he can help with nqp-on-CLR

[11:39] <moritz_> can anybody recommend a good, free ebook?

[11:39] *** gimix left
[11:43] *** drbean joined
[11:46] <masak> moritz_: hm, there's gotta be a C# channel on freenode where they'd know...

[11:47] <jnthn> moritz_: There's one at http://www.programmersheaven.com/2/CSharpBook but most of it was written by a non-native English speaker. I reviewed/corrected a ton of stuff in it when I worked at PH.

[11:47] <jnthn> And isn't up to date with the latest stuff.

[11:48] <jnthn> But it is free and is an e-book. :)

[11:48] <jnthn> moritz_: The WinForms/Data Access chapters can be skipped I expect.

[11:49] <moritz_> jnthn: thanks, I'll take a look

[11:49] <jnthn> Gee, they've really gotten into their ads on that site since I left... 

[11:49] * moritz_ didn't see any ads :-)

[11:50] <jnthn> :)

[11:53] *** felliott joined
[12:00] *** pmurias joined
[12:02] *** coldhead left
[12:12] *** ab5tract left
[12:14] <bbkr> hi. what is P6 syntax for "try ... finally " exception handling?

[12:15] <masak> try { something-dangerous(); CATCH { fix() } }

[12:15] <masak> but they try {} is optional.

[12:15] <masak> s/they/the/

[12:15] *** flussence left
[12:15] *** ab5tract joined
[12:16] <bbkr> CATCH is not the same as finally. i'm trying to write in P6 following short riddle: https://gist.github.com/800061

[12:16] <bbkr> finally in almost all languages is executed always after try block, not when catchable exception occured

[12:18] <tadzik> erm, so why not to put it after the try block?

[12:18] <tadzik> so try { foo(); CATCH { bar(); }; finally();

[12:19] <jnthn> That's not always what's wanted. 

[12:19] <jnthn> There is meant to be a block that's always invoked when a block is left

[12:19] <jnthn> s/a block/a phaser/

[12:19] <bbkr> jnthn: is right

[12:19] <jnthn> POST { } or so

[12:19] <jnthn> Rakudo doesn't implement it yet though :(

[12:20] *** karupanerura joined
[12:20] <masak> LEAVE {} ?

[12:21] <jnthn> Yes, if it's in the spec. :)

[12:21] *** mtk joined
[12:21] <masak> it is.

[12:21] <jnthn> :)

[12:21] <masak> and (as opposed to POST), it doesn't fail if the return value of the block is false.

[12:21] <jnthn> masak++ # reads the spec :)

[12:21] <colomon> \o

[12:22] <masak> o/

[12:22] <jnthn> co/omon!

[12:24] <colomon> hello!

[12:24] <masak> he\\o!

[12:24] <colomon> hel\o

[12:25] <colomon> I started to try to figure out how to implement BigInts using a module and zavolaj last night.

[12:25] <colomon> (and a big int library)

[12:25] <masak> cool

[12:25] <bbkr> ok, so now when we know that finally is the same as LEAVE{} in P6, how should the following code behave when implemented: sub foo { try { return True;  LEAVE { return False } } }; foo()

[12:26] *** llabthgie joined
[12:26] <colomon> seem stuck on a procedural detail with library files at the moment, but hopefully it is sortable.

[12:28] <jnthn> bbkr: I don't know that returning from a LEAVE block is going to end too well...

[12:29] <jnthn> bbkr: The return will have triggered the invocation of .leave which will in turn have triggered the LEAVE block.

[12:29] <jnthn> Wouldn't surprise me if that's a good way to get yourself a nice infinite loop of exception throwing.

[12:33] *** ab5tract left
[12:33] <tadzik> moritz_: http://stackoverflow.com/questions/194812/list-of-freely-available-programming-books you may want to look hear

[12:33] <tadzik> * here

[12:34] <jnthn> Pardon?

[12:34] <jnthn> :)

[12:35] <masak> jnthn: yes.

[12:35] <masak> :)

[12:35] * masak wonders if jnthn remembers the English/Dutch cross-language pun from Liz&Wendy

[12:35] *** snearch left
[12:36] <jnthn> masak: If it's the one that involves horses... :)

[12:37] <masak> that's the one.

[12:38] <masak> one can almost get it to work in German too, but one would have to say "Pfardon?" :P

[12:40] *** V15170R joined
[12:44] <moritz_> almost.

[12:45] *** kensanata joined
[12:48] <colomon> oooo, do libraries have to be dynamic to work with zavolaj?  that seems like it would make sense...

[12:49] *** bluescreen joined
[12:50] <jnthn> colomon: They need to work with dlopen/dlsym

[12:50] *** flussence joined
[12:51] <flussence> well that's annoying, my home box can't reach the outside world for some reason (even though ssh still works?)

[12:53] <colomon> \o/ 

[12:54] <colomon> (making a dylib did it!)

[12:57] <tadzik> pfardon is what a horse says instead of "I'm sorry"?

[13:03] <jnthn> :D

[13:04] <colomon> Any idea how to return a string from a function using zavolaj?

[13:04] <flussence> "sub Str foo()" should work

[13:04] *** JimmyZ left
[13:04] *** JimmyZ joined
[13:04] <flussence> as long as it returns a char* in C, anyway

[13:05] <colomon> but what happens to the memory pointed to by the char *?

[13:05] <masak> tadzik: the Dutch word for 'horses' is 'pardon'. the rest of the joke is privmsg material, as this is a family channel. :)

[13:05] * JimmyZ tries to use zavolaj link to libevent and get segfault :(

[13:06] <flussence> hmm, I'd imagine the common-sense thing would be that Parrot takes a copy of the string before the user code gets to see it...

[13:06] <flussence> (I don't really know what happens)

[13:08] <JimmyZ> jimmy@ubuntu:~/rakudo$ ./perl6 event-lib.p6 #some function works, some segfault

[13:09] <JimmyZ> 1.4.13-stable

[13:10] <colomon> flussence: I guess I can make it work if I treat the string as an opaque pointer.

[13:10] <takadonet> morning all

[13:11] <jnthn> JimmyZ: If they segfault then maybe the signature is wrong.

[13:11] <colomon> is there a way to pass null as an opaque pointer?

[13:11] <jnthn> colomon: Hmm...it may be that a type object maps to null...or should do.

[13:12] <flussence> There used to be: pir::null__P(). Stopped working recently :(

[13:12] *** felliott left
[13:12] <JimmyZ> jnthn: there are two function returns 'const char *', so I use 'ruturns Str', one works, another segfault

[13:12] *** redicaps left
[13:12] <JimmyZ> *returns*

[13:13] *** flussence_ joined
[13:16] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *$o) := \(|@a); say $f.perl

[13:16] <p6eval> rakudo 549d2a: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'infix:<:=>' at line 1␤  in main program body at line 22:/tmp/acjNyrQf2G␤»

[13:16] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *@o) := \(|@a); say $f.perl

[13:16] <p6eval> rakudo 549d2a: OUTPUT«\(\(2, 3, 4))␤»

[13:16] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *@o) := @a; say $f.perl

[13:16] <p6eval> rakudo 549d2a: OUTPUT«[2, 3, 4]␤»

[13:17] *** MayDaniel joined
[13:17] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *@o) := \@a; say $f.perl

[13:17] <p6eval> rakudo 549d2a: OUTPUT«\(2, 3, 4)␤»

[13:17] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *@o) := |@a; say $f.perl

[13:17] <p6eval> rakudo 549d2a: OUTPUT«\(2, 3, 4)␤»

[13:17] <jnthn> Hm

[13:17] <jnthn> At least one of those should work.

[13:18] <masak> aye.

[13:18] <jnthn> rakudo: my @a = 2, 3, 4; my ($f, *@o) := @a.Capture; say $f.perl

[13:18] <p6eval> rakudo 549d2a: OUTPUT«\(2, 3, 4)␤»

[13:19] <flussence_> oh, there I am

[13:19] *** flussence left
[13:19] *** flussence_ is now known as flussence

[13:19] <jnthn> OK, that last one is surprisng.

[13:19] <colomon> errr, is there a C function which can be cleverly used to convert an opaque char * to a Str?

[13:19] <colomon> strdup would do it, but non-standard and leaks memory.

[13:19] <jnthn> Doesn't just Str work with that?

[13:20] <colomon> jnthn: it's the memory management that has me worried

[13:21] *** fhelmberger joined
[13:22] <colomon> strcat will do

[13:26] * colomon just did his first successful BigInt math (and printed the result, which was the trickiest bit)

[13:26] *** mtk left
[13:28] *** learningg joined
[13:28] <learningg> Hi!

[13:28] <learningg> Q: how to write this  "  /usr/bin/time -f %E /usr/bin/wget -p -q -O /dev/null  "  in perl?

[13:29] <masak> learningg: you're probably looking for the channel #perl-help on irc.perl.org, where they will help you with Perl 5 questions such as that one.

[13:29] <learningg> masak Thank You

[13:29] <colomon> I reckon I can have a working BigInt library by sometime tomorrow, but it will be a pain in the arse to install.

[13:29] <masak> learningg: you're welcome. good luck.

[13:33] <learningg> masak, Thank You

[13:34] <JimmyZ> jnthn: does zavolaj support callback fuction args??

[13:35] * moritz_ is pretty sure it doesn't

[13:36] *** JimmyZ_ joined
[13:36] *** kaare_ left
[13:37] <jnthn> JimmyZ: No

[13:38] <jnthn> JimmyZ: They're on the todo list, but not done yet.

[13:38] *** mtk joined
[13:39] *** JimmyZ left
[13:39] *** JimmyZ_ is now known as JimmyZ

[13:41] <JimmyZ> great, that would be -O fun

[13:42] * jnthn suspects implementing them might be -Otricky :P

[13:44] <moritz_> ETOOMANYBIGOS

[13:44] * JimmyZ is curious how callback will pass into C lib.

[13:44] *** MayDaniel left
[13:47] <masak> moritz_: so you felt you had to add three more? :P

[13:49] * jnthn afk a little

[13:49] <tadzik> reminds me of plobsing's mail to parrot-dev a while ago

[13:49] <tadzik> "the cost of building these new annotations is probably between O(God No) and O(F@%#)"

[13:50] *** karupanerura left
[13:50] <moritz_> masak: of course

[13:51] <masak> ;)

[13:51] <masak> tadzik: I liked that one :P

[13:51] <colomon> >     say Math::BigInt.new("131414212321313141") + Math::BigInt.new("1000000000000000000000000000000");

[13:52] <tadzik> me too :)

[13:52] <colomon> 1000000000000131414212321313141

[13:52] <tadzik> hiya!

[13:52] <tadzik> does it use the Parrot Bigint PMC?

[13:52] <colomon> nope

[13:53] <colomon> it uses http://www.di-mgt.com.au/bigdigits.html

[13:53] <masak> colomon++

[13:53] <colomon> also, so far it only does .new, .Str, and infix:<+>  :)

[13:54] <flussence> rakudo: say '0x' X~ ([\~] '0' xx 4)

[13:54] <p6eval> rakudo 549d2a: OUTPUT«0x00x000x0000x0000␤»

[13:54] <flussence> rakudo: say '0x' X~ ([\~] '0' xx 4 Z~ '1')

[13:54] <p6eval> rakudo 549d2a: OUTPUT«0x01␤»

[13:54] <flussence> rakudo: say '0x' X~ (([\~] '0' xx 4) Z~ '1')

[13:54] <p6eval> rakudo 549d2a: OUTPUT«0x01␤»

[13:55] <flussence> er.g

[13:55] <flussence> rakudo: say '0x' X~ ([\~] '0' xx 4) Z~ '1' xx *

[13:55] <p6eval> rakudo 549d2a: OUTPUT«0x010x0010x00010x00001␤»

[13:56] <flussence> rakudo: say ('0x' X~ ([\~] '0' xx *) Z~ '1' xx *)[60..64]».Int.join(' ')

[13:56] <p6eval> rakudo 549d2a: OUTPUT«1 1 1 1 1␤»

[13:56] *** learningg left
[13:56] <flussence> rakudo: say ('0x' X~ ([\~] '0' xx *) Z~ '1' xx *)[60..64].join(' ')

[13:56] <p6eval> rakudo 549d2a: OUTPUT«0x00000000000000000000000000000000000000000000000000000000000001 0x000000000000000000000000000000000000000000000000000000000000001 0x0000000000000000000000000000000000000000000000000000000000000001 0x00000000000000000000000000000000000000000000000000000000000000001

[13:56] <p6eval> ..0x00000000000000…

[13:56] <flussence> trying too hard as usual... :)

[13:56] <flussence> rakudo: say ('0x1' X~ ([\~] '0' xx *))[60..64]».Int.join(' ')

[13:56] <p6eval> rakudo 549d2a: OUTPUT«-9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808␤»

[13:57] <flussence> rakudo: say ('0x1' X~ ([\~] '0' xx *))[55..60]».Int.join(' ')

[13:57] <p6eval> rakudo 549d2a: OUTPUT«-9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808 -9223372036854775808␤»

[13:57] * flussence facepalm

[13:57] <flussence> rakudo: say ('0b1' X~ ([\~] '0' xx *))[55..64]».Int.join(' ')

[13:57] <p6eval> rakudo 549d2a: OUTPUT«72057594037927936 144115188075855872 288230376151711744 576460752303423488 1152921504606846976 2305843009213693952 4611686018427387904 -9223372036854775808 -9223372036854775808 -9223372036854775808␤»

[13:58] <flussence> ISTR this broke horribly near the overflow value, but it seems to work now.

[13:59] <flussence> rakudo: say ('0b1' X~ ([\~] '0' xx *) Z~ '1')[59..62]».Int.join(' ')

[13:59] <p6eval> rakudo 549d2a: OUTPUT«Method 'Int' not found for invocant of class ''␤  in main program body at line 22:/tmp/fvwmhZNomh␤»

[13:59] <colomon> > my @crazy := Math::BigInt.new("1"), -> $x { $x * Math::BigInt.new("2") } ... *; say @crazy[100]

[13:59] <colomon> 1267650600228229401496703205376

[13:59] <flussence> huh

[13:59] <flussence> rakudo: say ('0b1' X~ ([\~] '0' xx *) Z~ '1' xx *)[59..62]».Int.join(' ')

[13:59] <p6eval> rakudo 549d2a: OUTPUT«2305843009213693952 4611686018427387904 -9223372036854775808 -9223372036854775808␤»

[14:00] <flussence> colomon: can it do factorial 700 yet? :)

[14:01] <tadzik> you don't want Rakudo to do that :)

[14:02] *** drbean left
[14:02] <moritz_> rakudo: say [*] 1..700

[14:02] <p6eval> rakudo 549d2a: OUTPUT«Inf␤»

[14:02] <moritz_> that's a very good approximation :-)

[14:03] <colomon> flussence: baby steps here.

[14:03] <mberends> colomon++

[14:04] <colomon> I don't think [*] works with it.  hmmm.

[14:04] *** timbunce left
[14:05] <moritz_> did you declare them as   our multi infix:<*> etc?

[14:06] <colomon> moritz_++ # forgot the our, now it works.

[14:07] <colomon> it says 50! is 30414093201713378043612608166064768844377641568960512000000000000, is that big enough for now

[14:07] <colomon> ?

[14:07] <colomon> (might be an obiwan error in there.)

[14:07] <tadzik> rakudo: say 50!

[14:07] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Confused at line 22, near "say 50!"␤»

[14:07] <tadzik> blah

[14:08] *** Axius joined
[14:08] <tadzik> rakudo: sub postfix:<!> { [*] 1..$^n }; say 50!

[14:08] <p6eval> rakudo 549d2a: OUTPUT«3.04140932017134e+64␤»

[14:08] <colomon> oh, hey, that's right, at least to the first approximation

[14:08] <dalek> niecza: 619094e | pmurias++ | cl-backend/backend.lisp:

[14:08] <dalek> niecza: [cl-backend] methods with 0 arguments

[14:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/619094e9fe

[14:08] <dalek> niecza: 07888da | pmurias++ | cl-backend/backend.lisp:

[14:08] <dalek> niecza: [cl-backend] remove bar method only used for testing

[14:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/07888da0e0

[14:08] <dalek> niecza: 79f1b8c | pmurias++ | cl-backend/backend.lisp:

[14:08] <dalek> niecza: [cl-backend] started loggin the stuff all the opcodes get compiled to

[14:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/79f1b8c620

[14:08] <flussence> colomon++ 

[14:08] *** Axius left
[14:08] *** Axius joined
[14:09] <flussence> python2.6 agrees with the long answer

[14:09] <flussence> (it's nice that python has bigints built in, but I find it a horribly verbose language)

[14:09] *** timbunce joined
[14:09] <mberends> colomon: no, 50! is not big enough, it's still less than a googol. try 70! ;) ;)

[14:10] <colomon> anyway, that's probably all the hacking time I've got this morning, I've got to get dressed and go with my wife to the surgeon's for a consult.

[14:10] <colomon> 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000 # just for mberends 

[14:11] <flussence> nice\!

[14:11] <mberends> :-) good to know you won't be hacking with the surgeon ;)

[14:18] * JimmyZ is failed in using libevent with zavolaj. he wants callback.

[14:22] * tadzik pokes masak

[14:23] <tadzik> masak: how are your modules and their META.infos?

[14:24] <masak> oh :)

[14:24] <tadzik> colomon: poke, poke

[14:24] <masak> I will have a slot for them tonight, promise :)

[14:24] <tadzik> bah, sorry

[14:24] <tadzik> cosimo: poke poke

[14:24] <masak> tadzik: thanks for the reminder. :)

[14:24] <tadzik> I could merge all this stuff in the new ecosystem

[14:25] *** Axius left
[14:27] *** V15170R left
[14:29] * jnthn back

[14:32] <jnthn> colomon++ # Math::BigInt with Zavolaj!

[14:36] <dalek> niecza: 0877070 | pmurias++ | cl-backend/backend.lisp:

[14:36] <dalek> niecza: [cl-backend] strip nam-ann when printing out the op tree

[14:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/087707078b

[14:53] <pmurias> phenny: tell sorear the way classes and lexical classes are represented in nam seems very strange, could you look into it and change it and/or document why it makes sense

[14:53] <phenny> pmurias: I'll pass that on when sorear is around.

[14:53] <phenny> pmurias: 01:45Z <sorear> tell pmurias yes.

[14:54] <dalek> star: 10444fb | pmichaud++ | skel/docs/announce/2011.01:

[14:54] <dalek> star: Add draft 2011.01 announcement.

[14:54] <dalek> star: review: https://github.com/rakudo/star/commit/10444fb51a

[15:00] <dalek> star: 76b5a91 | pmichaud++ | skel/docs/UsingPerl6-draft.pdf:

[15:00] <dalek> star: Update Using Perl 6 draft.

[15:00] <dalek> star: review: https://github.com/rakudo/star/commit/76b5a911d3

[15:00] <dalek> star: 42b8770 | pmichaud++ | / (2 files):

[15:00] <dalek> star: Update Makefiles, Parrot config.

[15:00] <dalek> star: review: https://github.com/rakudo/star/commit/42b877048d

[15:03] <pmurias> phenny: tell sorear what does the null nam opcode do?

[15:03] <phenny> pmurias: I'll pass that on when sorear is around.

[15:05] *** felliott joined
[15:05] <dalek> star: 85bd8b2 | pmichaud++ | skel/docs/announce/2011.01:

[15:05] <dalek> star: Update dates in 2011.01 release announcement.

[15:05] <dalek> star: review: https://github.com/rakudo/star/commit/85bd8b22d8

[15:05] <dalek> star: 465838a | pmichaud++ | skel/docs/announce/2011.01:

[15:05] <dalek> star: Add a note that compiler releases will continue monthly.

[15:05] <dalek> star: review: https://github.com/rakudo/star/commit/465838a80a

[15:06] *** mberends left
[15:08] <jnthn> pmichaud is has a commit!

[15:18] <masak> \o/

[15:18] *** cafesofie joined
[15:19] <jnthn> .oO( He's a star! :P )

[15:19] *** MayDaniel joined
[15:19] *** kaare_ joined
[15:20] <pmichaud> running spectests now

[15:21] <moritz_> would it be useful to write a command line parser in nqp-rx?

[15:21] <moritz_> iirc the current one is written in PIR, and doesn't quite fit rakudo's needs

[15:21] *** wtw left
[15:21] <moritz_> $ ./perl6 -f

[15:21] <moritz_> ===SORRY!===

[15:21] <moritz_> Unable to open filehandle from path '-f'

[15:21] *** Trashlord left
[15:21] <moritz_> I'd expect that to die from the unrecognized option

[15:22] <pmichaud> I've always thought that HLL::Compiler's command line parser should work similar to Perl 6's command line parsing

[15:22] <pmichaud> particle++ even has a grant to work on that

[15:23] <moritz_> not sure I want to implement the full S19 madness :-)

[15:23] <pmichaud> thus "similar to" and not "exactly like"  :-)

[15:24] * moritz_ nods :-)

[15:24] <pmichaud> and I still maintain there are parts of S19 that aren't realistic

[15:24] *** Patterner left
[15:27] <moritz_> actually my approach was a bit different

[15:27] <moritz_> I wanted to something with the cool new nqp-rx/nom

[15:27] <moritz_> and stumbled over this big block of PIR for command line parsing

[15:28] <moritz_> and thought that this might be a good and fun thing to attack

[15:28] <pmichaud> it would be a very good thing to attack

[15:28] <moritz_> good

[15:28] <pmichaud> +2 from me

[15:28] <moritz_> should I start in a different repo?

[15:28] <pmichaud> I plan to move nqp-nom to be its own perl6/nqp repo

[15:28] <pmichaud> (after this weekend)

[15:29] <jnthn> moritz_: No objections to nqp-rx/nom commits on my part

[15:29] <pmichaud> you can manage it however you like.... and what jnthn++ said is what I was going to recommend :)

[15:29] <jnthn> Though what pmichaud++ said - that branch is going to shuffle off to a repo of its own.

[15:29] <pmichaud> easiest might be to implement it with a different method name for development and testing

[15:29] <jnthn> And nqpclr and nqpjvm will move in to join it, I expect.

[15:29] <jnthn> +1

[15:30] <pmichaud> i.e., keep the existing one in parallel during development

[15:30] <moritz_> sure thing

[15:30] <jnthn> That's what I've done for a lot of things. :)

[15:30] <jnthn> Thus why we had a Cursor2 for a while. :)

[15:30] <pmichaud> then there's no real problem with keeping it in master

[15:30] *** Psyche^ joined
[15:30] *** Psyche^ is now known as Patterner

[15:30] <pmichaud> well, in the -nom branch until it becomes master :)

[15:31] *** felliott left
[15:31] * jnthn would miss having a branch called nom...

[15:31] <jnthn> ...but the Rakudo branch to integrate 6model will probably be called that too. ;)

[15:33] <pmichaud> \o/  I finally have my email inbox under 25 messages!

[15:33] <dalek> star: ee87d3c | coke++ | README:

[15:33] <dalek> star: Fix grammar-o

[15:33] <dalek> star: review: https://github.com/rakudo/star/commit/ee87d3c86b

[15:34] <pmichaud> coke++

[15:34] <[Coke]> my inbox is > 10K.

[15:35] <moritz_> jnthn: in nom, when I run 'make test' (and the built is out of date), I get some error during t/p6regex/01-regex.t

[15:35] <pmichaud> mine usually hovers in the 100s, and after a period of absence from handling email it'll easily break 1K

[15:35] <moritz_> Null PMC access in find_method('new_type')

[15:35] <moritz_> current instr.: 'parrot;Regex;Cursor;' pc 32 (src/Regex/Cursor.pir:38)

[15:35] <moritz_> called from Sub '' pc 0 (src/HLL.pir:17)

[15:35] <moritz_> ... call repeated 1 times

[15:35] *** wamba joined
[15:35] <moritz_> jnthn: any idea what's wrong?

[15:35] <pmichaud> now I'm under 20 messages :-)

[15:36] <jnthn> moritz_: Odd...make test doesn't run those for me...

[15:36] <moritz_> jnthn: neither does it for me... but it does in master

[15:36] <jnthn> moritz_: Oh.

[15:36] *** kst left
[15:36] <jnthn> moritz_: Ah...maybe something is not loading the meta-objects.

[15:36] <jnthn> moritz_: Or the 6model library

[15:36] <jnthn> moritz_: Or the setup dynop is not being called

[15:37] *** kst joined
[15:37] <jnthn> moritz_: What does the p6regex tests run the test files with?

[15:37] <pmichaud> now under 10 messages :)

[15:37] <pmichaud> (I'll stop here.)

[15:37] <moritz_> jnthn: I have no idea... I'll try to thoroughly clean everything, maybe it's a glob gone mad or so

[15:38] <moritz_> 01-regex.t doesn't appear in Makefile

[15:38] <moritz_> "huh"

[15:38] <jnthn> moritz_: It's probably be a prove call or something

[15:39] <moritz_> test: all core-test setting-test p6regex-test

[15:39] <moritz_> p6regex-test: $(P6REGEX_PBC) prove -r --exec $(PARROT) t/p6regex

[15:39] <pmichaud> if we're getting ready to embark on a new rakudo branch, should we see about cleaning up the existing branches in the rakudo repo?  Obviously the 'alpha' branch should remain, and I can get rid of a lot of mine

[15:39] <moritz_> +1

[15:39] <jnthn> I'll bet $(P6REGEX_PBC) doesn't actually work.

[15:40] <moritz_> P6REGEX_PBC     = P6Regex.pbc

[15:40] <moritz_> and that one exists

[15:40] <pmichaud> I think he means that the .pbc itself fails

[15:40] <jnthn> Right but it'll be busted.

[15:40] <moritz_> ok

[15:40] <jnthn> I didn't do anything to make it init 6model.

[15:40] <pmichaud> i.e., it hasn't been updated to .... right

[15:41] <jnthn> If you can track down the .pir file it's made from, try adding the dynop setup call that's in src/NQP/Compiler.pir

[15:41] *** felliott joined
[15:41] <jnthn> (It's already smart enough to not double-init itself.)

[15:41] <pmichaud> src/Regex/P6Regex.pir, likely

[15:41] <moritz_> yep

[15:41] <jnthn> pmichaud: Did you see my Cursor patch last night?

[15:42] <pmichaud> better is to put the dynop setup call into HLL/Compiler, I would think.

[15:42] <pmichaud> although perhaps it has to be in all .pbc's that use it

[15:42] <pmichaud> jnthn: no, my schedule topsy-turveyed again yesterday

[15:42] <jnthn> pmichaud: OK, no hurry. It's just a nice one. :)

[15:43] <jnthn> pmichaud: $!from and $!pos are stored as native ints now, which saves a load of boxing/unboxing. :)

[15:43] <pmichaud> oooooh

[15:43] <pmichaud> I really need to get some good benchmarks together

[15:43] <jnthn> pmichaud: Sadly Match isn't shuffled over to being a 6model object yet.

[15:43] *** cjk101010 left
[15:43] <jnthn> pmichaud: So we still have to box them to stick 'em in the Match object

[15:43] <jnthn> But that's fixable.

[15:43] <moritz_> jnthn: copying the init stuff makes the build fail

[15:44] <jnthn> moritz_: Joy...

[15:44] <jnthn> moritz_: What with?

[15:44] <moritz_> /home/moritz/p6/nqp-rx/parrot_install/bin/parrot --library=src/stage1 src/stage1/nqp.pbc \ --target=pir --output=src/stage2/gen/hllgrammar-grammar.pir \ src/HLL/Grammar.pm

[15:44] <moritz_> Null PMC access in isa()

[15:44] <moritz_> current instr.: '_block11' pc 8 (gen/nqp-how.pir:10)

[15:44] <moritz_> called from Sub '_block1124' pc 7166 (gen/nqp-how.pir:2802)

[15:44] <moritz_> called from Sub '' pc 7173 (gen/nqp-how.pir:2805)

[15:44] <moritz_> jnthn: maybe the dependencies on the ops are missing

[15:44] <pmichaud> seems likely

[15:45] <pmichaud> here's a semi-big question about our build environment

[15:45] <jnthn> moritz_: Hmm, maybe but that's not the error I'd expect for that.

[15:45] <jnthn> moritz_: Maybe the dynpmcs are but...hm

[15:45] <pmichaud> in the past, we always tied rakudo to specific parrot releases, because improvements to rakudo often required corresponding changes in parrot

[15:46] <pmichaud> s/releases/revisions/

[15:46] <pmichaud> are we at a point now where Parrot is "stable" enough that it makes sense for us to tie to specific nqp revisions?

[15:46] *** wallberg joined
[15:46] <pmichaud> or will the reworking of nqp and rakudo imply more changes to parrot guts as it has in the past?

[15:47] <moritz_> pmichaud: I've been very glad in the past few months that it's relatively easy to build rakudo on a specific parrot revision (for bisecting etc.)

[15:47] <moritz_> pmichaud: so I'd be unhappy to sacrifice that simplicity

[15:48] <pmichaud> well, it might be much the same as now, only we tell nqp to build against a specific revision of parrot rather than tell rakudo to do it (more)

[15:49] <pmichaud> and the rakudo Configure script could simply pass the --parrot-config option along to the nqp it's building

[15:51] <pmichaud> the alternative would seem to be that Rakudo has to manage separate parrot and nqp installations

[15:51] <pmichaud> and I'd rather it be just one

[15:51] <pmichaud> (more)

[15:51] * [Coke] suggests that pmichaud end his sends with » when there's more. 

[15:51] <[Coke]> (less typing. ;)

[15:51] <jnthn> pmichaud: It's hard to guess how much changes to Parrot will happen, tbh.

[15:52] <jnthn> er, will need to happen

[15:52] <[Coke]> rakudo: [+] 1..∞

[15:52] <jnthn> In order to unblock things.

[15:52] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Confused at line 22, near "[+] 1..\u221e"␤»

[15:52] <pmichaud> jnthn: have you needed to do much changing to parrot guts for nqp-nom thus far?

[15:52] <[Coke]> rakudo: [+] 1..Inf

[15:52] <jnthn> pmichaud: I've not changed anything that I can recall.

[15:52] <p6eval> rakudo 549d2a: OUTPUT«(timeout)»

[15:53] <pmichaud> jnthn: right, so I'm guessing you've either saved up a lot of stuff to fix, or there's not a lot to change :)

[15:53] <jnthn> pmichaud: Feels more like the latter at the moment.

[15:53] <pmichaud> but I *know* that nqp-nom will have some significant changes as we do the new rakudo branch

[15:53] <jnthn> pmichaud: Where is PAST etc going to live?

[15:53] <pmichaud> so it seems easier to have rakudo depend directly on nqp, rather than have it depend on a version of parrot into which we've imported nqp

[15:54] *** felliott left
[15:54] <[Coke]> +1

[15:54] <pmichaud> ultimately I expect nqp-nom will have its own PAST::Compiler

[15:54] <jnthn> How soon do you expect that? (more)

[15:54] <jnthn> I expect to need some additions there at some point soon.

[15:54] <pmichaud> I'd expect sooner rather than later, then.

[15:55] <pmichaud> but still, that seems like it can be hidden behind nqp-nom changes (which have to be concurrent) 

[15:55] *** am0c left
[15:55] <jnthn> Right.

[15:55] <pmichaud> okay, just checking.  

[15:56] <pmichaud> noted that we want an easy way to test parrot changes against nqp and rakudo... I'll preserve that somehow

[15:56] <pmichaud> I suspect it will be even quicker to locate problems because building nqp will be a prereq to building rakudo in this system

[15:56] <pmichaud> (and nqp often finds problems in parrot as quickly as rakudo does)

[15:56] <pmichaud> s/as quickly/more quickly/

[15:57] *** felliott joined
[15:57] <pmichaud> when we did the original ng branch of rakudo, one of the reasons I went ahead and put nqp-rx into parrot and used that was that our configuration system was still relying on subversion sequential revision numbers, and I didn't want to spend a lot of time trying to fix that for git

[15:58] <pmichaud> that issue no longer exists, of course :)

[15:59] <jnthn> :)

[15:59] <jnthn> pmichaud++ # shaving these yaks :)

[16:00] *** Trashlord joined
[16:03] *** JimmyZ left
[16:09] *** kst left
[16:09] *** kst joined
[16:11] <pmichaud> okay, I've uploaded the 2011.01 star tarball to github... will publish the release note after lunch

[16:11] *** cafesofie left
[16:12] <pmichaud> if anyone encounters any issues with the tarball, let me know :)

[16:12] <pmichaud> (I just downloaded a copy from github and I'm building/retesting now)

[16:12] <pmichaud> (last month there were some issues with the download file, iirc)

[16:13] <pmichaud> afk, lunch

[16:17] <sorear> good * #perl6

[16:17] <phenny> sorear: 14:53Z <pmurias> tell sorear the way classes and lexical classes are represented in nam seems very strange, could you look into it and change it and/or document why it makes sense

[16:17] <phenny> sorear: 15:03Z <pmurias> tell sorear what does the null nam opcode do?

[16:17] *** kensanata left
[16:29] *** vmspb joined
[16:30] <sorear> pmurias: the null opcode produces a typed null pointer; most of the nam types support nulls

[16:32] <pmurias> sorear: hi

[16:32] *** kst left
[16:32] <sorear> hi.

[16:32] <pmurias> sorear: what does the argument mean?

[16:32] <sorear> It's the type.

[16:34] <pmurias> and so what is null('var')?

[16:35] <pmurias> a null reference?

[16:35] *** justatheory joined
[16:36] <moritz_> nqp: [1, 2]

[16:36] <p6eval> nqp:  ( no output )

[16:36] *** kst joined
[16:36] <moritz_> nqp: say([1, 2])

[16:36] <p6eval> nqp: OUTPUT«2␤»

[16:37] *** cafesofie joined
[16:40] <moritz_> is any nqp::foo stuff implementedß

[16:41] <moritz_> s/ß/?/

[16:42] *** MayDaniel left
[16:42] <jnthn> moritz_: Not yet.

[16:42] <jnthn> moritz_: Well

[16:42] <jnthn> moritz_: Not yet in Parrot's NQP

[16:43] <jnthn> We need a place to document the available NQP ops and then to get mappings of them overall all VMs, I suspect.

[16:47] *** envi left
[16:47] <sorear> pmurias: yes

[16:47] <sorear> pmurias: don't let null('var') escape into Perl6-space

[16:48] <dalek> niecza: b708fda | pmurias++ | docs/nam.pod:

[16:48] <dalek> niecza: partly document nam op methodcall

[16:48] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b708fdaa30

[16:48] <dalek> niecza: b1d83be | pmurias++ | docs/nam.pod:

[16:48] <dalek> niecza: Document nam op null.

[16:48] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b1d83be469

[16:48] *** Guest54166 left
[16:48] <dalek> niecza: 8875eb5 | pmurias++ | docs/nam.pod:

[16:48] <dalek> niecza: Document nam op const.

[16:48] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8875eb5be1

[16:48] <pmurias> sorear: what do we need null('var') for?

[16:49] <sorear> initializing local variables

[16:50] <sorear> especially, locals in CgOp blocks

[16:51] <sorear> see for instance SAFE.setting line 474

[16:51] <dalek> nqp-rx/nom: 94c8f60 | moritz++ | build/Makefile.in:

[16:51] <dalek> nqp-rx/nom: install dynops and dynpmcs

[16:51] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/94c8f60232

[16:51] <jnthn> moritz__++

[16:51] <pmurias> sorear: what does rnull do?

[16:52] <sorear> there used to be a lot more lines like that, but improvements in the optimizer and expansions of the C# core have squeezed Q:CgOp's role :)

[16:52] <moritz_> jnthn: you can tell I used nqp from a non-build directory :-)

[16:52] <sorear> (rnull A B C) = (prog A B C {Nil})

[16:53] <sorear> Q:CgOp has to return a value; use rnull if you don't have a value to return

[16:53] <sorear> rnull should probably be called rnil now; it predates Nil and had to use null('var') once

[16:53] <jnthn> moritz_: I hadn't done that yet. :)

[16:53] <moritz_> jnthn: is there an example of how to write a constructor somewhere in nom?

[16:54] <pmurias> couldn't we just replace (rnull ...) with (prog A B C {Nil})?

[16:54] <moritz_> jnthn: nm, found it

[16:55] <sorear> pmurias: I was tired of typing the long form

[16:56] *** MayDaniel joined
[16:58] *** wallberg left
[17:00] <pmurias> sorear: is the {} using Nil from the CORE rather then the one from the lexicall scoped specced somewhere?

[17:01] <jnthn> moritz_: BTW classes inherit from NQPMu by default

[17:01] <jnthn> moritz_: And get new from it

[17:01] <jnthn> iirc

[17:01] *** MayDaniel left
[17:01] <moritz_> jnthn: yep, but it's a .new() without arguments

[17:02] <moritz_> that's why I want to write my own

[17:03] <jnthn> ah, gotcha. :)

[17:03] <moritz_> hm, but BUILD doesn't exist in NQPMu

[17:03] <moritz_> ah, I have to write my own

[17:04] <jnthn> moritz_: Yeah, I've still got a few bits to get through there.

[17:04] <dalek> niecza: 6442d8f | pmurias++ | docs/nam.pod:

[17:04] <dalek> niecza: document nam op rnull

[17:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6442d8f4af

[17:04] *** snearch joined
[17:05] <pmurias> sorear: you should check that i don't put incorrect stuff in doc/nam.pod

[17:07] *** wamba left
[17:14] *** V15170R joined
[17:16] <vmspb> perl6: say (1,2 X 3,4).perl

[17:16] <p6eval> pugs, rakudo 549d2a: OUTPUT«((1, 3), (1, 4), (2, 3), (2, 4))␤»

[17:16] <p6eval> ..niecza v1-196-g0877070: OUTPUT«Unhandled exception: Cross products NYI␤  at /home/p6eval/niecza/lib/SAFE.setting line 377 (SAFE die @ 2)␤  at /home/p6eval/niecza/lib/SAFE.setting line 1020 (SAFE infix:<X> @ 2)␤  at /tmp/rQsOXcSoGo line 1 (MAIN mainline @ 3)␤  at

[17:16] <p6eval> ../home/p6eval/niecza/lib/SAFE.setting line 1037 (SA…

[17:16] <vmspb> perl6: say (1,2 X 3,4 X 5,6).perl

[17:16] *** zby_home joined
[17:16] <p6eval> rakudo 549d2a: OUTPUT«No applicable candidates found to dispatch to for 'infix:<X>'. Available candidates are:␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/Ee00B27rmj␤»

[17:16] <p6eval> ..niecza v1-196-g0877070: OUTPUT«Unhandled exception: Cross products NYI␤  at /home/p6eval/niecza/lib/SAFE.setting line 377 (SAFE die @ 2)␤  at /home/p6eval/niecza/lib/SAFE.setting line 1020 (SAFE infix:<X> @ 2)␤  at /tmp/hr1YYo_2ye line 1 (MAIN mainline @ 4)␤  at

[17:16] <p6eval> ../home/p6eval/niecza/lib/SAFE.setting line 1037 (SA…

[17:16] <p6eval> ..pugs: OUTPUT«((1, 3, 5), (1, 3, 6), (1, 4, 5), (1, 4, 6), (2, 3, 5), (2, 3, 6), (2, 4, 5), (2, 4, 6))␤»

[17:16] <masak> pugs++

[17:17] <masak> vmspb: it's a bit output-intensive to use 'perl6: ', so unless you're explicitly interested in *all* implementations, please use 'rakudo: ' or similar.

[17:17] <masak> output-intensive as in, it consumes backlog :P

[17:22] *** daxim left
[17:22] *** Zapelius joined
[17:23] <[Coke]> rakudo: say π

[17:23] <p6eval> rakudo 549d2a: OUTPUT«Could not find sub &π␤  in main program body at line 22:/tmp/Jnrky0hRPs␤»

[17:23] * [Coke] is sad.

[17:25] <sorear> pmurias: as a general rule, I like to only allow shadowing for symbols explicitly mentioned in the source, although there are still a lot of bugs, and I don't think it's specced

[17:26] *** bluescreen left
[17:26] *** kthakore left
[17:27] *** nothingmuch left
[17:28] *** kthakore joined
[17:28] <masak> [Coke]: last I looked, π wasn't in latin-1.

[17:29] *** mberends joined
[17:30] <flussence> (it's in greek-1)

[17:30] <sorear> pmurias: most of this started when I was trying to port STD over - it was failing very horribly and opaquely

[17:31] <sorear> I eventually figured out that STD::Regex was shadowing CORE::Regex and using the wrong type was breaking things

[17:32] <V15170R> rakudo: multi sub postfix:<π> (Real $n) { 355/113 * $n }; say 2π;

[17:32] <p6eval> rakudo 549d2a: OUTPUT«6.28318584070797␤»

[17:33] <TimToady> rakudo: constant π = pi;

[17:33] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Constant type declarator not yet implemented at line 22, near "= pi;"␤»

[17:34] <V15170R> can i define a multi that accepts both real and Int or do I have to declare two subs?

[17:34] *** nothingmuch joined
[17:34] *** GinoMan joined
[17:34] <moritz_> V15170R: role Real accepts Num, Rat and Int

[17:34] *** cdarroch joined
[17:34] *** cdarroch left
[17:34] *** cdarroch joined
[17:34] <moritz_> and Numeric the same, plus Complex

[17:34] <V15170R> nice :)

[17:35] <V15170R> rakudo: multi sub postfix:<π> (Real $n = 1) { 355/113 * $n }; say 2π; say π;

[17:35] <TimToady> perl6: constant π = pi;

[17:35] <p6eval> rakudo 549d2a: OUTPUT«6.28318584070797␤Could not find sub &π␤  in main program body at line 22:/tmp/sxEKBwbteg␤»

[17:35] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤Constant type declarator not yet implemented at line 22, near "= pi;"␤»

[17:35] <p6eval> ..pugs: OUTPUT«decodeUTF8': bad data: '\960'␤*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/nI2CiiFRBo line 1, column 12␤»

[17:35] <p6eval> ..niecza v1-200-g6442d8f: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'pi' used at line Any()1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/SAFE.setting line 377 (SAFE die @ 2)␤  at /home/p6eval/niecza/src/STD.pm6 line 1174 (STD P6.comp_unit @ 71)␤  at

[17:35] <p6eval> ../home/p6eval/niecza/s…

[17:36] *** rgrau joined
[17:39] <pmurias> TimToady: if somebody lexically redefines Nil should empty blocks return the value from CORE or the one defined by the user?

[17:40] *** bluescreen joined
[17:43] <masak> redefining Nil! soon you'll be wanting to redefine builtins or augment core classes! :P

[17:52] <V15170R> rakudo: multi sub postfix:<;> (Real $n) { $n + 1 }; say 3;

[17:52] <p6eval> rakudo 549d2a: OUTPUT«4␤»

[17:54] <pmurias> masak: augment core classes?! do i look like a rubyist? ;)

[17:55] <masak> pmurias: but think of the possibilties! we can mix database access into... everything! o.O

[17:55] *** pmurias left
[17:55] <masak> oh noes, I scared away pmurias... :/

[17:56] <PerlJam> masak: It's all funny until someone takes you seriously. ;-)

[17:56] <PerlJam> How do you think ActiveRecord and such happened in Ruby?

[17:56] *** mtk left
[17:56] <moritz_> in p6 we have different reprs for that

[17:56] <PerlJam> someone was joking around and someone else thought "hey, that's a good idea" and did it

[17:56] <masak> :P

[17:56] <V15170R> rakudo: multi sub postfix:<;> (Real $n) { $n + 1 }; say 3; ; sub thisDoesSomething { return 100; }; say thisDoesSomething;

[17:56] <p6eval> rakudo 549d2a: OUTPUT«4␤102␤»

[17:57] *** mtk joined
[17:57] <V15170R> redefining ; seems like a good way to troll co-workers :)

[17:57] <masak> V15170R: :)

[17:57] <masak> why 102?

[17:57] <moritz_> V15170R: now add a state variable to psotfix:<;>

[17:57] * masak doesn't get it

[17:58] <V15170R> the ; after 100 and the ; after thisDoesSomething i guess

[17:58] <moritz_> aye

[17:59] *** jarfhy joined
[17:59] <pmichaud> back from lunch (for a bit)

[17:59] *** dakkar left
[17:59] <jnthn> pmichaud: Got a moment for a question?

[18:00] <jnthn> Relates to PAST nodes and natively typed things.

[18:01] <pmichaud> go ahead

[18:01] *** timbunce left
[18:02] <jnthn> It's all about PAST::Var, really.

[18:02] <jnthn> PAST::Var with :scope('attribute') at the moment always presumres that we'll be getting an object (in Parrot, a PMC).

[18:02] <jnthn> What is the correct way to extend PAST to indicate otherwise?

[18:03] *** ggoebel left
[18:03] <jnthn> In the future, the same question will apply for PAST::Var with type lexical, and I guess register too.

[18:03] <pmichaud> the primary reason that PAST::Var exists is because of the need to handle vivification and lvalue-ness

[18:04] <pmichaud> otherwise it could all be done with PAST::Op

[18:04] <jnthn> Well, I still want the l-valueness.

[18:04] <V15170R> moritz_: a "static" variable?

[18:04] <pmichaud> in the sense of a 'bind', yes?

[18:04] <moritz_> V15170R: yep

[18:04] <jnthn> pmichaud: Yes, exactly that.

[18:04] <pmichaud> okay

[18:04] <moritz_> alpha: sub f { state $x++ }; say f, f, f, f, f

[18:04] <p6eval> alpha : OUTPUT«Use of uninitialized value␤1234␤»

[18:04] <pmichaud> looking

[18:05] <jnthn> pmichaud: On a related matter, at the moment PAST::Var with :scope('parameter') always puts the parameter into a lexical. Unconditionally.

[18:05] <jnthn> I ponder that a parameter_register or some such could be good.

[18:05] <jnthn> Well, something that allows that capability would be good

[18:06] <jnthn> I'm not in the slightest attached to that naming or way of enabling it.

[18:07] <V15170R> rakudo: multi sub postfix:<;> { state $^a + 1 }; say 3; ; sub thisDoesSomething { return 100; }; thisDoesSomething;

[18:07] <p6eval> rakudo 549d2a: OUTPUT«===SORRY!===␤"state" not yet implemented at line 22, near "+ 1 }; say"␤»

[18:07] <pmichaud> what would be generated for fetching a non-PMC, attribute, ooc?

[18:07] <pmichaud> s/,//

[18:07] <jnthn> At the moment it's $I0 = repr_get_attr_int obj, type_obj, name

[18:08] <jnthn> (Note that getting an attribute just by name without saying what class it's associated with is not supported - at least, not by P6opaque...since attributes are always scoped to exactly one class.)

[18:08] <pmichaud> is there something in the PAST representation that associates the attribute name with its type?

[18:08] <pmichaud> or does the compiler have to know and keep track of that?

[18:09] <pmichaud> by 'type' I mean I/S/N/P

[18:09] <jnthn> Not at the moment. (more)

[18:09] <jnthn> The other part of the story is that I think we need a general :type(...) thing available on all PAST nodes.

[18:09] <jnthn> :returns just holds a name.

[18:10] <pmichaud> what would the :type hold?

[18:10] <jnthn> But we need something that holds a meta-object.

[18:10] <jnthn> er

[18:10] <jnthn> type object sorry

[18:10] <pmichaud> :returns could hold a type object

[18:10] <jnthn> Yeah but...too much history of not doing. :/

[18:10] <pmichaud> strings are just shortcut conveniences

[18:10] <jnthn> I don't want to have to go and add "is it a string" checks.

[18:10] <pmichaud> in general any attribute ought to be able to hold any past

[18:10] *** ggoebel joined
[18:10] <jnthn> I'd rather be able to be promised "what is in :type is a type object"

[18:11] <pmichaud> is it a type object, or code to access a type object?

[18:11] <jnthn> Anyway, if you know the type object you can find out from that if it's int/num/str

[18:11] <jnthn> It's a type object.

[18:11] <pmichaud> and I guess we're guaranteed that the type object exists at the time the PAST is being generated?

[18:12] <jnthn> The bigger picture here is that when we hit class Foo { we do ClassHOW.^new_type(name => 'Foo')

[18:12] <jnthn> Yes, that's where I'm heading with this.

[18:12] <pmichaud> what about   use Foo;

[18:12] <jnthn> That happens at BEGIN time already.

[18:12] <pmichaud> what about a precompiled module containing   use Foo;

[18:13] <jnthn> So after we've parsed it, we then have a way to go and find the type objects we want.

[18:13] <jnthn> Well, that's where the whole bounded serialization stuff comes in.

[18:13] <jnthn> I don't want to try and do that right away.

[18:13] <pmichaud> my point being that the precompiled module doesn't contain Foo

[18:13] <jnthn> ?

[18:13] <jnthn> Oh

[18:14] <jnthn> Yes, for now we'll have to both create it at compile time *and* emit code for the pre-compiled case that can construct it.

[18:14] <pmichaud> locate it

[18:14] <pmichaud> not construct it

[18:14] <jnthn> Ideally, yes.

[18:14] <jnthn> But we need all the serialization stuff in place for that to really work.

[18:15] <pmichaud> I don't see what that quite has to do with serialization, but okay.

[18:15] <jnthn> I didn't want to do that in the same refactor.

[18:15] <jnthn> Imagine we have

[18:15] <jnthn> class Foo { }

[18:15] <jnthn> And we pre-compile that code

[18:16] <jnthn> Because the type object is needed at compile time, we'd have created it as we compiled.

[18:16] <jnthn> However, when we load that pre-compiled module Foo needs to exist.

[18:16] <jnthn> Ideally we'd have serialized the one we make at compile time.

[18:16] <jnthn> And stashed it away in the bytecode.

[18:17] <jnthn> Well, we will have to do that somehow

[18:17] <pmichaud> right

[18:17] <jnthn> The line between serialization and construction is blurry. :)

[18:17] <pmichaud> but the loading module doesn't construct Foo, it simply finds Foo

[18:17] <pmichaud> after it loads it from the serialized bytecode

[18:17] <jnthn> Oh, yes, sorry. I mis-read.

[18:17] <jnthn> Yeah, you're right. I mis-parsed.

[18:18] <pmichaud> okay, back to attribute

[18:18] <pmichaud> so,   :type would be on the PAST getting the 'self' object?

[18:18] <jnthn> Yes.

[18:18] <jnthn> Which itself would be a PAST::Var node, I guess.

[18:19] <pmichaud> I guess we'd never do attribute fetches on objects returned from other methods or subs?

[18:19] <jnthn> You *can*

[18:19] <jnthn> You just have to be sure of their type.

[18:19] <jnthn> Also note that this is for the P6opaque REPR. (more)

[18:19] <jnthn> It's completely possible to write a REPR that doesn't care for the class handle.

[18:20] <jnthn> We'll probably have some extra ones that suit other language's views of OO.

[18:21] <jnthn> Parrot has always had a PPPs form of get_attribute, and PAST has always had a 2-child form that supports this, fwiw.

[18:21] <pmichaud> okay

[18:21] <jnthn> It's just that...we never used it. :)

[18:21] <pmichaud> right, I don't have a problem with needing the class information to fetch the attribute

[18:22] <pmichaud> I'm just trying to make sure that requiring the class information doesn't preclude us from operations we need

[18:22] <jnthn> OK. I just wanted to convey that it's needed for Perl 6, but we're not boxing ourselves out of supporting other languages with no such needs.

[18:22] <jnthn> We actually get attribute inheritance wrong in Rakudo today. :/

[18:22] <pmichaud> I know we need it for Perl 6, but there's a difference between saying "we need it to support this part of Perl 6" and "all operations in Perl 6 have to use this interface"

[18:23] <pmichaud> anyway, I think I'm okay with :type except for the name

[18:23] <jnthn> :)

[18:24] <pmichaud> not sure what to use instead

[18:24] *** ggoebel left
[18:24] <jnthn> :type_obj

[18:24] <jnthn> hmm...not sure I like that

[18:24] <pmichaud> I'd prefer :type over :type_obj

[18:24] <jnthn> :typeobject is a bit long

[18:24] <pmichaud> anyway, let's go with :type for now then -- we can change it later if I think it's important.  it may grow on me.

[18:24] <jnthn> OK :)

[18:25] <pmichaud> so, updating PAST::Var becomes fairly simple then

[18:25] <jnthn> Yeah, that deals with various aspects of it.

[18:25] <jnthn> Only leaves the "parameter that goes in a register" case.

[18:25] <pmichaud> in the 'attribute' method, you just check the :type of the PAST representing 'self' and query that object for the attribute to find out what kind of thing you'll be getting back so you know what instruction to emit

[18:25] <jnthn> Which is a separate issue.

[18:25] <jnthn> Yes, that's a good summary.

[18:26] <pmichaud> oh, ooc, would it be a good idea (or too difficulty) to prefix our custom ops with nqp_  or something like that?

[18:26] *** plobsing left
[18:26] <pmichaud> *difficult

[18:27] <pmichaud> that way parrot could adopt some of them by dropping the nqp_ prefix without any concern for conflict

[18:27] *** cafesofie left
[18:27] <jnthn> Hmm

[18:27] <pmichaud> most of the opcode names ought to be in generated code anyway

[18:27] <jnthn> We could do. (more)

[18:27] <jnthn> I actually want to try and get nqp::foo in place with some mapping functionality

[18:27] <jnthn> That way the transition is even easier. :)

[18:27] <pmichaud> that shouldn't be too hard at all

[18:28] <jnthn> Anyway, no objection at all to changing the op names to have a prefix.

[18:28] <pmichaud> just follow the same mechanism that PAST::Compiler does for piroptable

[18:28] <pmichaud> but make it nqpoptable

[18:28] <pmichaud> or nqppirtable

[18:28] <pmichaud> or something like that

[18:28] *** ggoebel joined
[18:29] <jnthn> OK :)

[18:29] <pmichaud> and feel free to add a :nqpop to PAST::Op, I think.  (not sure if that belongs in PAST or in NQP)

[18:29] <jnthn> I'm only so attached to the name :nqpop. (more)

[18:29] <pmichaud> there's a bit of a question as to whether PAST or NQP should be doing the translation to the backend

[18:29] <jnthn> I'd prefer something that conveys that it's an abstraction over backend/vm operations.

[18:29] <jnthn> It feels kinda external to NQP.

[18:29] <pmichaud> well, "nqp" is abstraction

[18:29] <jnthn> True :)

[18:30] <pmichaud> if we think of nqp as being our tool for abstracting over vm backends

[18:30] <jnthn> True, I can see it that way too :)

[18:30] <pmichaud> (nqp being the entire system, not just the compiler portion)

[18:30] <jnthn> *nod*

[18:31] <jnthn> Focusing on the name NQP is probably good. The name PCT is slightly awkward when we have extra backends. :)

[18:31] <jnthn> Or we could just say "oh, the P means Portable" ;)

[18:31] *** _jaldhar left
[18:32] * jnthn is quite excited about the potential to write a compiler once and have it both run on and generate code for multiple backends :)

[18:34] <jnthn> pmichaud: Anyway, adding :nqpop will let me eliminate a bunch of differences between nqpclr+nqpjvm vs nqparrot

[18:34] <pmichaud> right

[18:34] <pmichaud> that might need to be something that happens as/when we move our new version of PAST out of the Parrot repo

[18:34] <jnthn> OK

[18:34] <jnthn> What is your expected timeline for us to do that? (more)

[18:35] <jnthn> On the one hand, I could do with :type to add the natively typed attributes support to NQP. On the other hand, I've tested the functionality from PIR and don't have an immediate use case for accessing it from NQP.

[18:36] <jnthn> As in, I can cope a couple of weeks probably without having to do that switch.

[18:36] <pmichaud> I'm not sure of the timeline.  a couple of weeks doesn't sound too farfetched, depending on other things in my world

[18:36] <jnthn> s/switch/feature/ :)

[18:36] <jnthn> OK

[18:37] <pmichaud> it wouldn't bother me for :nqpop to appear in Parrot's PAST, though, either.

[18:37] <pmichaud> or perhaps the translation temporarily exists in NQP's actions

[18:37] <pmichaud> with the expectation that it'll ultimately appear in a new PAST

[18:37] <jnthn> OK, then we've got a bunch of options.

[18:37] <pmichaud> anyway, I'd say don't let it become a blocker for you

[18:37] <jnthn> *nod*

[18:37] *** bluescreen left
[18:38] <jnthn> The natively typed parameters issue only needs resolving when we go to move Cursor to NQP.

[18:39] <pmichaud> because of speed, or what?

[18:39] <jnthn> Right

[18:39] <jnthn> GC churn too

[18:39] <jnthn> It'd be silly to box just for the sake of crossing the call boundary

[18:39] <pmichaud> okay

[18:39] <jnthn> Especially when we are goign to stick the thing into a natively typed attribute slot :)

[18:39] <jnthn> *going

[18:40] <jnthn> Well, it's not "going to" any more either. :)

[18:40] <jnthn> We do. :)

[18:40] <jnthn> Anyway, I think that's all of the things I wanted to ask.

[18:40] <jnthn> Thanks!

[18:48] <pmichaud> Release announcements posted

[18:48] <jnthn> pmichaud++

[18:50] *** bluescreen joined
[18:51] <jnthn> pmichaud: Looks good.

[18:53] <jnthn> OK, time for me to find some dinner. :)

[18:54] *** mberends left
[18:57] <sorear> jnthn: Doesn't the P stand for Patrick?

[19:00] <frettled> pmichaud: hmm, the subject of the e-mail announcement says Rakudo Star 2010.12 :)

[19:00] <masak> pmichaud++

[19:00] <frettled> But it's correct on rakudo.org.

[19:00] <masak> if only it were the other way! ;)

[19:00] <frettled> That would be easier to fix, yes :D

[19:01] <frettled> That reminds of people sending "recalls" of emails.

[19:01] *** MayDaniel joined
[19:03] *** plobsing joined
[19:04] <pmichaud> oops

[19:04] *** ggoebel left
[19:04] <pmichaud> forgot to change the subject line, yes.

[19:05] <pmichaud> oh well.

[19:05] <pmichaud> 2010.12 was released also

[19:05] <pmichaud> I'll send a followup.

[19:05] <pmichaud> I'll just re-send.

[19:05] *** ggoebel joined
[19:06] <pmichaud> re-sent.

[19:12] <jnthn> oh, I didn't even notice that... :)

[19:15] *** dukeleto left
[19:15] *** dukeleto joined
[19:18] *** MayDaniel left
[19:24] *** ggoebel left
[19:27] *** V15170R left
[19:31] *** ggoebel joined
[19:40] <sorear> jnthn: I need help figuring out how native types are supposed to work.

[19:46] *** dukeleto left
[19:46] *** dukeleto joined
[19:47] *** MayDaniel joined
[19:50] *** xinming_ left
[19:50] *** xinming joined
[19:55] *** cafesofie joined
[19:56] *** cafesofie left
[20:00] *** kst left
[20:00] <moritz_> rakudo: pir::die("OH NOEZ")

[20:00] <p6eval> rakudo 549d2a: OUTPUT«OH NOEZ␤  in main program body at line 22:/tmp/KjUHIdzci3␤»

[20:00] *** kst joined
[20:02] <moritz_> rakudo: say pir::isa(pir::new('Undef'), 'Undef')

[20:02] <p6eval> rakudo 549d2a: OUTPUT«1␤»

[20:03] *** saaki left
[20:03] <jnthn> sorear: What aspect of them?

[20:03] <jnthn> sorear: Also, note that I'm still working a bunch of stuff out as well :)

[20:03] <sorear> jnthn: Aspects of them that require hard thinking. :)

[20:04] <jnthn> :P

[20:04] <sorear> You seem to have a rather involved idea set up with inlining and repr fanciness

[20:04] <jnthn> sorear: At the moment, I consider the notion of whether something can be stored as a native type as a question that its REPR can answer.

[20:05] * sorear thinks "steal stealable stuff from 6model" would make a good Feb minigoal

[20:05] <jnthn> So P6opaque - which knows how to store native or value-y things - asks the REPR of the type its attributes declare what they want.

[20:07] <jnthn> The way I have it, stuff where you have a role Foo[::T] { has T $!x } should "just work" and allocate compact storage when a value for T is passed in like, say, int.

[20:07] <jnthn> The other piece of the puzzle is 

[20:07] <jnthn> my int $x = ...

[20:07] <jnthn> What is assignable?

[20:07] <jnthn> The answer as I have it so far is "things that know how to unbox as an int"

[20:07] <jnthn> So Int does

[20:08] <jnthn> But it doesn't preclude people from creating their own types that would do the same thing.

[20:09] <jnthn> Things may change as I dig into the Rakudo-on-6model work.

[20:09] <jnthn> But what's there now is my best attempt to get it rightish so far. :)

[20:09] *** saaki joined
[20:10] <moritz_> jnthn: I sometimes get "get_attr_str() not implemented in class 'RakudoObject'" on parse or other compile time errors... do you know what that usually means?

[20:10] <sorear> jnthn: I don't *really* understand the role of the REPR in all of this

[20:11] <sorear> jnthn: roles parametrized by types don't particularly make sense either

[20:11] <moritz_> why not?

[20:11] <moritz_> don't you have that all the time in various languages?

[20:12] <moritz_> hash<int> etc.

[20:12] <sorear> If I knew why I didn't understand something, I'd understand it

[20:12] <jnthn> moritz_: Yes - it's almost always the same thing.

[20:12] <sorear> it's not generics in general that baffle me, it's their interaction with other Perl 6 notions

[20:13] <jnthn> moritz_: When accessing attributes stored in a P6opaque, one now has to always specify the class where the attr was declared. Not just a name.

[20:13] <jnthn> moritz_: I changed most instances where that wasn't already fixed up, but I probably missed some. Either feel free to hunt it down or pass me backtace or info on how to reproduce.

[20:13] <jnthn> er, how to reproduce the bug

[20:13] <jnthn> :P

[20:14] <jnthn> sorear: A role declaration is really declaring a role "factory".

[20:14] <masak> I've always seen REPR as the stuff that objects are made of.

[20:14] <moritz_> jnthn: will golf down

[20:15] <sorear> masak: in the presence of native types, the question must be asked, "What do you mean by object?"

[20:15] <jnthn> sorear: As for representations - they're just things with an API of some kind responsible for the storage of an object.

[20:15] <sorear> I'm spoiled by Haskell, I'd like to see denotational semantics for all your words :)

[20:15] <jnthn> Oh my, it's been a few years since I did those. :P

[20:16] <jnthn> moritz_: Thanks.

[20:16] <moritz_> jnthn: nqp -e 'while 1 { '

[20:16] <jnthn> sorear: I'll try and blog a bit more on the native type stuff, once it settles down some more in my brane. :)

[20:17] <moritz_> produces that error message

[20:17] *** coldhead joined
[20:19] <moritz_> jnthn: seems that FAILGOAL in Cursor.pm has     $P0 = getattribute self, '$!target'

[20:20] <colomon> http://john.freml.in/lisp-features -- are these all available in p6 as well?  ;)

[20:21] <dalek> nqp-rx/nom: 4ba2dc2 | jonathan++ | src/Regex/Cursor-builtins.pir:

[20:21] <dalek> nqp-rx/nom: Fix incorrect attr access spotted by moritz++.

[20:21] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/4ba2dc26e1

[20:21] <jnthn> moritz_: Yes, that was it. :)

[20:22] *** ggoebel left
[20:22] *** ggoebel joined
[20:23] <PerlJam> colomon: heck, Perl *5* has 2 of those

[20:23] <moritz_> \o/ if that means I get better error messages :-)

[20:24] <PerlJam> colomon: well, it sorta has #1, so maybe Perl 5 has 1.5 of those :)

[20:25] <sorear> Perl and Lisp have a long history of comparison

[20:26] <jnthn> moritz_: Yes, the error looked a bunch saner.

[20:26] <sorear> don't ask TimToady about "oatmeal with fingernail clippings mixed in"

[20:26] *** y3llow_ joined
[20:26] <PerlJam> sorear: that's one of my favorite quotes. It makes me a little giddy to this day  :)

[20:26] *** pothos_ joined
[20:27] <PerlJam> as does mjd's RETARDO quote.

[20:27] *** ChanServ sets mode: +v _ilbot

[20:27] *** ChanServ sets mode: +v aloha

[20:27] <colomon> RETARDO?

[20:27] *** ChanServ sets mode: +v phenny

[20:28] *** ChanServ sets mode: +v IRSeekBot

[20:28] *** y3llow left
[20:28] *** y3llow_ is now known as y3llow

[20:28] *** pothos left
[20:29] *** pothos_ is now known as pothos

[20:29] <PerlJam> colomon: See http://en.wikiquote.org/wiki/Mark_Jason_Dominus

[20:29] *** bluescreen left
[20:30] <colomon> nice

[20:31] <PerlJam> I should edit that article.  The original uttering was in all caps on IRC.  

[20:31] <masak> PerlJam: please do.

[20:33] <PerlJam> Well, I ALLCAPPED it, but I can't find my IRC logs where he first said it, so they may have been purged by now.

[20:33] <coldhead> new rakudo, woot

[20:34] <coldhead> i feel so alive

[20:34] <PerlJam> but you're head is so cold

[20:34] <PerlJam> s/you're/your/

[20:34] <masak> PerlJam: he's just not getting hot-headed, that's all.

[20:41] *** ggoebel left
[20:41] *** TomH_ joined
[20:45] *** bluescreen joined
[20:45] *** TomH_ left
[20:46] *** wooden left
[20:46] *** cafesofie joined
[20:47] *** mkramer1 left
[20:47] *** ggoebel joined
[20:51] <masak> PerlJam: since you like the RETARDO quote, have you heard the quote by Babbage? that one makes me a little giddy each time I think of it.

[20:52] <masak> it's actually a longer, more eloquent version of the MJD quote.

[20:52] <masak> 'On two occasions I have been asked,—"Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?" In one case a member of the Upper, and in the other a member of the Lower, House put this question. I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.'

[20:53] <masak> I'm sure if Babbage had grokked the term RETARDO, he'd have approved. :)

[20:55] *** Chillance joined
[20:58] *** cafesofie left
[21:00] <colomon> rakudo: say 1234567890098765432100123456789

[21:00] <p6eval> rakudo 549d2a: OUTPUT«5466656383893124373␤»

[21:00] <colomon> bother

[21:02] <masak> that's not right... :)

[21:05] <diakopter> rakudo: say 123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847

[21:05] <p6eval> rakudo 549d2a: OUTPUT«7759554590699921335␤»

[21:05] <diakopter> pugs: say 123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847

[21:05] <p6eval> pugs: OUTPUT«123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847␤»

[21:05] <diakopter> perlesque: say 123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847

[21:05] <p6eval> perlesque: OUTPUT«␤Unhandled Exception: System.OverflowException: Value is too large␤  at System.Int64.Parse (System.String s) [0x00000] in <filename unknown>:0 ␤  at sprixel.perlesqueParser.emitCode (sprixel.Env e, Antlr.Runtime.Tree.CommonTree node, Antlr.Runtime.Tree.CommonTree nextNode,

[21:05] <p6eval> ..sprixel.…

[21:08] <diakopter> perlesque: say(BigInteger.Parse('123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847'))

[21:08] <p6eval> perlesque: OUTPUT«123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847␤»

[21:08] <diakopter> perlesque: say(BigInteger.Parse('123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847')/BigInteger.Parse('123456789009876543210012345678997575'))

[21:08] <p6eval> perlesque: OUTPUT«1000000000000000000000000000000000006798159737749648517056334668␤»

[21:08] <sorear> niecza: say 123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847

[21:08] <p6eval> niecza v1-200-g6442d8f: OUTPUT«1.23456789009877E+98␤»

[21:09] <sorear> I'm suprised that worked

[21:09] <diakopter> :)

[21:09] <masak> by my calculations, I have 13 projects up on http://modules.perl6.org -- I'm now going to traverse them and apply http://ttjjss.wordpress.com/2011/01/08/perl-6-module-ecosystem-%E2%80%93-news-and-ideas/ to them.

[21:09] <sorear> fsvo "worked"

[21:10] <diakopter> perlesque:

[21:10] <p6eval> perlesque:  ( no output )

[21:10] <diakopter> perlesque: say(BigInteger.Parse('123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847')/BigInteger.Parse('12345678900987654321001234567899757512345678900987654321001234567899757583927897239879601019283740987130987

[21:10] <p6eval> perlesque: OUTPUT«unhandled node type: <invalid>␤Statement_list 1␤ Statement_list 2␤  Sub_declaration 3␤   METHODNAME say(␤   Statement_list 1␤    Statement_list 1␤     Infix_expr 1␤      Infix_expr 1␤       Infix_expr 1␤        Infix_expr 1␤         Infix_expr 1␤          Infix_expr 1␤          

[21:10] <p6eval> ..Ta…

[21:10] <diakopter> hm

[21:10] <sjohnson> yikes.com

[21:10] *** Mowah left
[21:11] <diakopter> perlesque: say(BigInteger.Parse('123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847123456789009876543210012345678997575839278972398796010192837409871309871039846784749863018970193847')/BigInteger.Parse('123456789009876543210012345678997575'))

[21:11] <p6eval> perlesque: OUTPUT«1000000000000000000000000000000000006798159737749648517056334668095037397097658022482563187835010252658843907006108399984473589776279160572358762168414952625921106␤»

[21:11] <diakopter> even

[21:12] <diakopter> <sigh> oh, I got the logic backwards. try Int32.Parse first, then try Int64.Parse only if that fails, then try BigInteger.Parse if that fails..

[21:12] * diakopter goes to fix

[21:13] *** bluescreen left
[21:15] *** plobsing left
[21:17] *** pmurias joined
[21:19] *** pjcj left
[21:21] *** MayDaniel left
[21:23] <dalek> sprixel: 14c24b9 | diakopter++ | sprixel/ (3 files):

[21:23] <dalek> sprixel: enable BigInteger parsing from raw integer literal inputs

[21:23] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/14c24b99d8

[21:23] <masak> tadzik: ping

[21:29] *** snearch left
[21:30] <masak> rakudo: say "Holy $_(), Batman! This fake Japanese is really $_()!" given sub fake-japanese { [~] map { <h k r t>.roll, <a i o u>.roll }, ^5 }

[21:30] <p6eval> rakudo 549d2a: OUTPUT«Holy kikorohuro, Batman! This fake Japanese is really korikikora!␤»

[21:31] <colomon> somehow defining multi sub infix:<+> in my Math::BigInt class is stopping class methods from being able to see the normal infix:<+> operators.... :\

[21:31] * sorear points masak the way of Lingua::JA::Romaji::Valid

[21:31] <masak> sorear: thanks ;)

[21:36] *** alester joined
[21:36] *** cafesofie joined
[21:37] *** zby_home left
[21:38] <jnthn> colomon: Declare it "our multi sub ..." for now.

[21:38] <jnthn> colomon: Will be fixed with the other multi changes.

[21:42] *** kst left
[21:43] *** kst joined
[21:45] <colomon> jnthn: it is declared "our multi sub" already, alas.

[21:47] *** pjcj joined
[21:49] *** felliott left
[21:52] <jnthn> colomon: Oh. :(

[21:53] <colomon> rakudo: class A { has $.a; method blue($n) { say $.a + $n; }; our multi sub infix:<+>(A $a, A $b) { A.new(:a($a.a + $b.a)); }; }; say A.new(:a(10)).blue(42)

[21:53] <p6eval> rakudo 549d2a: OUTPUT«No applicable candidates found to dispatch to for 'infix:<+>'. Available candidates are:␤:(A $a, A $b)␤␤  in 'A::blue' at line 22:/tmp/OvBw3dlA0t␤  in main program body at line 22:/tmp/OvBw3dlA0t␤»

[21:53] <colomon> golfed in one!

[21:53] <dalek> november: 302e4f8 | masak++ | META.info:

[21:53] <dalek> november: [META.info] added

[21:53] <dalek> november: review: https://github.com/viklund/november/commit/302e4f8e03

[21:54] <colomon> rakudo: class A { has $.a; method blue($n) { say $.a + $n; }; multi sub infix:<+>(A $a, A $b) { A.new(:a($a.a + $b.a)); }; }; say A.new(:a(10)).blue(42)

[21:54] <p6eval> rakudo 549d2a: OUTPUT«52␤Bool::True␤»

[21:54] <jnthn> Oh, curious.

[21:55] <jnthn> But in the second case you've hidden all of the other definitions of +

[21:55] <jnthn> OTOH, if you write it like that now and it works, then it'll keep on working when the multis get fixed. :)

[21:55] <colomon> taking a slew of "our"s out of my code seems to have made the situation much better.

[21:56] *** felliott joined
[21:56] <jnthn> :)

[21:56] <colomon> wonder if that one's been reported before?

[21:56] <jnthn> That area is known to be quirky.

[21:56] <jnthn> If it's not been reported, another ticket = another test case. :)

[21:57] <colomon> now the problem is that without the "our"s, it looks like meta-ops don't work with the new infix:<+>s.  :\

[21:58] <colomon> at least, += doesn't appear to be working.

[21:58] *** cafesofie left
[22:01] *** felliott left
[22:02] <colomon> jnthn: would it be fair to say you think both versions should work?

[22:02] <colomon> (writing bug report)

[22:02] * colomon is listening to a lovely, lovely fiddle accordion duet on LiveTrad.com.

[22:03] <tadzik> masak: pong

[22:06] <tadzik> masak: oh modules!

[22:09] <masak> tadzik: added META.info to csv, druid, gge, html-template, perl6-literate, november, proto, pun, svg, ufo, web, xml-writer, yapsi, and yarn.

[22:09] <masak> I forgot tardis, but I'm adding that one now.

[22:10] <tadzik> masak: whoa whoa

[22:10] <masak> tadzik: I'm curious why your blog post takes your neutro's META.info as an example, yet neturo has no META.info.

[22:10] <tadzik> masak: care to add them to the new ecosystem?

[22:10] <tadzik> masak: it has, in metainfo branch

[22:10] <tadzik> masak: the "stable" neutro uses the "stable" ecosystem

[22:10] <masak> ok.

[22:10] <dalek> yapsi: d524312 | masak++ | META.info:

[22:10] <dalek> yapsi: [META.info] added

[22:10] <dalek> yapsi: review: https://github.com/masak/yapsi/commit/d524312b93

[22:10] <masak> that explains it.

[22:11] <tadzik> masak: I remember mentioning that on the blag (that it's a branch)

[22:11] <masak> ok.

[22:11] <masak> maybe I didn't read it carefully enough, then.

[22:11] <masak> tadzik: "add them to the new ecosystem" -- again, how?

[22:13] <masak> tadzik: also, I understand the purpose of all fields, except one -- version. ooc, what are you planning to use that field for?

[22:14] <masak> tadzik: nope, http://ttjjss.wordpress.com/2011/01/08/perl-6-module-ecosystem-–-news-and-ideas/ does not mention any neutro branch.

[22:17] <tadzik> masak: version is to be used once module authors start to version their modules. At this stage it's useless, yes

[22:18] <masak> it seems to me that is the use of the word 'module' that I once tried to call 'project', since a repository can contain many (versioned) modules.

[22:19] <masak> so the project version of META.info doesn't have to have any connection to the module versions, a la S11?

[22:19] *** dukeleto left
[22:20] *** dukeleto joined
[22:20] <tadzik> *shrug*

[22:21] <masak>  I see.

[22:24] <tadzik> ENOTYETPLANNED

[22:26] <masak> I'm not condemning it in any way. I just don't see at present why I should mark up META.info in addition to my modules, should I feel the urge to version them.

[22:28] <jnthn> Having the same thing in two places is just asking for it to get out of sync.

[22:28] *** kst left
[22:28] *** kst joined
[22:31] *** plobsing joined
[22:38] <masak> jnthn: if it is the same thing.

[22:41] <masak> it's also slightly odd to see 'version' without 'authority'.

[22:42] <masak> in some sense, module versions are meaningless without module authorities.

[22:43] <masak> S11:506: "Once the authority is selected, then and only then is any version selection done; the version specification is ignored until the authority is selected."

[22:45] <jnthn> src/Perl6/Module/Locator.pm cares about authority first, though I'm not sure it could be said to "select" one if you don't specify which you want.

[22:46] <masak> std: class Dog:<cpan:JRANDOM 1.2.1> emulates :<1.2.0>;

[22:46] <p6eval> std 625303c: OUTPUT«===SORRY!===␤Unable to parse class definition at /tmp/9tc2GftRb_ line 1:␤------> class Dog:<cpan:JRANDOM 1.2.1> ⏏emulates :<1.2.0>;␤    expecting trait␤Parse failed␤FAILED 00:01 118m␤»

[22:46] * masak thought so

[22:46] <jnthn> masak: What would the semantics be if I just use Foo; and have one with :auth<jnthn>:ver<42> and a :auth<masak>:ver<5>? :)

[22:48] <masak> TimToady: S01:151 and S11:620 contradict each other.

[22:48] <sorear> it should be out of band.

[22:49] <flussence> pretending to be an average disinterested user for a moment, I'd assume it'd pick the highest version when I'm not picky about who wrote it

[22:50] <masak> jnthn: 'use Foo;' means 'use Foo:auth(Any):ver(Any);'

[22:50] <flussence> (that's how perl5 works when someone takes over maintenance of someone else's module on cpan, anyway.)

[22:50] <masak> jnthn: what happens when both those auth-version pairs are present in the module database, I don't know.

[22:50] <masak> jnthn: something sane. ;)

[22:51] <masak> possibly what flussence said.

[22:51] <masak> though I can easily imagine that backfiring in some cases.

[22:51] <jnthn> Aye

[22:51] <jnthn> I mean, you may be considered more authoritative. :)

[22:53] <masak> heaven forbid.

[22:53] <jnthn> :P

[22:54] *** cafesofie joined
[22:58] *** MayDaniel joined
[22:58] *** MayDaniel left
[22:58] *** MayDaniel joined
[23:00] *** dorlamm joined
[23:04] *** kaare_ left
[23:07] *** vmspb left
[23:09] <colomon> rakudo: class A { has $.a; method blue($n) { say $.a + $n; }; multi sub infix:<+>(A $a, A $b) { A.new(:a($a.a + $b.a)); }; }; say A.new(:a(10)).blue(42); my $a = A.new(:a(10)); $a += A.new(:a(42)); say $a.a;

[23:09] <p6eval> rakudo 549d2a: OUTPUT«52␤Bool::True␤Can't take numeric value for object of type A␤  in 'Any::Numeric' at line 1456:CORE.setting␤  in 'infix:<+>' at line 7454:CORE.setting␤  in main program body at line 1␤»

[23:09] <colomon> rakudo: class A { has $.a; method blue($n) { say $.a + $n; }; our multi sub infix:<+>(A $a, A $b) { A.new(:a($a.a + $b.a)); }; };  my $a = A.new(:a(10)); $a += A.new(:a(42)); say $a.a;

[23:09] <p6eval> rakudo 549d2a: OUTPUT«Can't take numeric value for object of type A␤  in 'Any::Numeric' at line 1456:CORE.setting␤  in 'infix:<+>' at line 7454:CORE.setting␤  in main program body at line 1␤»

[23:09] <colomon> hmm.

[23:15] *** shi joined
[23:17] *** cafesofie left
[23:25] *** pmurias left
[23:31] <masak> night, #perl6

[23:31] *** masak left
[23:39] <colomon> my big int library seems to thing 1 - 100000000000000000 == 18346744073709551617  :\

[23:43] <dalek> niecza: a87fbf8 | sorear++ | docs/announce.v2:

[23:43] <dalek> niecza: Add a draft for the v2 announce

[23:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a87fbf8035

[23:43] *** plobsing left
[23:44] <colomon> Bother: "Added the new functions mpIsNegative, mpChs and mpAbs in anticipation of adding full signed integer functionality in the next version."

[23:47] <dalek> nqp-rx/nom: 0de3800 | jonathan++ | src/stage0/ (4 files):

[23:47] <dalek> nqp-rx/nom: Update bootstrap with cursor using natively typed attributes.

[23:47] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/0de38004ba

[23:53] <sorear> colomon: Why aren't you using GMP?

[23:54] <colomon> GMP won't build on my machine.

[23:56] <colomon> their "solution" to the problem is essentially "get a new compiler toolchain".

