[00:00] <slavik1> perl6: say 2 ** 64

[00:00] <p6eval> pugs, niecza v6-150-g612a7b7: OUTPUT«18446744073709551616␤»

[00:00] <p6eval> ..rakudo 4a6d21: OUTPUT«1.84467440737096e+19␤»

[00:00] <slavik1> still no auto-bignum for rakudo?

[00:01] <sorear> still!

[00:01] <sorear> more like, colomon++ is on it!

[00:02] <sorear> pmichaud: ping

[00:04] <jnthn> grrr...the time it takes to compile the setting PIR => PBC is getting annoying.

[00:06] <sorear> pmichaud: my Base $x = Derived.new; sub foo(Derived $y is rw) { $x = Base.new; my Derived $z = $y; }; foo($x)

[00:06] <sorear> pmichaud: where does that fail?

[00:07] <sorear> pmichaud: can the type check be removed in the assignment to $z?

[00:10] *** whiteknight joined
[00:20] <jnthn> sorear: I think I pondered a while ago that "is rw" probably constrains various optimizations.

[00:20] <jnthn> I suspect that's one of them.

[00:24] *** lumi_ left
[00:25] <dalek> rakudo/nom: 2888998 | jnthn++ | src/Perl6/Metamodel/ (5 files):

[00:25] <dalek> rakudo/nom: Basic case of type checking against a role. Doesn't support parameter subtyping just yet.

[00:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2888998b6e

[00:25] <dalek> rakudo/nom: 68216e5 | jnthn++ | src/core/operators.pm:

[00:25] <dalek> rakudo/nom: Add prefix:<!>.

[00:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/68216e5219

[00:25] <dalek> rakudo/nom: f14f7dc | jnthn++ | src/core/ (3 files):

[00:25] <dalek> rakudo/nom: Add .count and .arity to Signature; Code has these methods and delegates to the Signature.

[00:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f14f7dc6f9

[00:25] <dalek> rakudo/nom: c10daf7 | jnthn++ | src/binder/bind.c:

[00:25] <dalek> rakudo/nom: Gut existing slurpy hash/array handling, in preparation for re-implementing it with new Array and Hash types.

[00:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c10daf7877

[00:25] *** cotto left
[00:25] <colomon> jnthn: what's with the strange syntax in Rat.new?  No bless?  And why is it only for Rat:U?  Shouldn't calling new on a defined Rat work as well?

[00:25] *** lumi_ joined
[00:28] * sorear ponders splitting at_key into get_key, set_key, and create_key

[00:28] <sorear> ditto _pos

[00:31] <jnthn> colomon: let me look...

[00:31] *** estrabd joined
[00:31] <jnthn> colomon: Well, no point going through the whole bless thing - it's slower.

[00:32] <jnthn> But the :U is dubious.

[00:32] <colomon> So the BUILD thing represents a faster way to create an object?

[00:32] <jnthn> colomon: If you call BUILD directly, yes

[00:32] <jnthn> Though subclassing probably bets...interesting. :)

[00:33] <colomon> oh

[00:33] *** thou joined
[00:33] <jnthn> *gets

[00:33] <jnthn> Wonder if new wants to become a multi though

[00:33] <jnthn> So we can have new overrides that are more efficient and still reach the normal interfce.

[00:37] <pmichaud> colomon: much of the code in nom is workaround as opposed to "it's supposed to be this way"

[00:37] <pmichaud> because we don't have all of the object bless/create stuff in place yet.

[00:38] <colomon> pmichaud: gotcah

[00:38] <colomon> *gotcha

[00:38] <colomon> I'm just trying to glance at it every now and then as so not to fall too far behind.  Stupid busy $work.

[00:38] <pmichaud> ultimately we'll just be able to use .new as we do in master... but at present there's no working bless that introspects the object attributes and does the initializations automatically

[00:39] <pmichaud> so moritz just created a BUILD to do it manually for now

[00:39] <sorear> pmichaud: any thoughts on my type checking question?

[00:41] <pmichaud> sorear: I don't think it's valid to remove the typecheck there, no.

[00:42] <jnthn> pmichaud: ping

[00:42] <jnthn> oh, you're right there :)

[00:42] <pmichaud> jnthn: pong

[00:42] <jnthn> pmichaud: May have a circularity sawing issue.

[00:42] <jnthn> pmichaud: With Array and Hash.

[00:43] <jnthn> my @a; # really needs Array to at least have its attributes known here

[00:43] <jnthn> I suspect we're going to probably want to use @a in Mu, Any, etc.

[00:43] <sorear> jnthn: Are you telling me that it's possible to have $x with a static type of Derived containing a value of type Base?

[00:44] <jnthn> sorear: huh? I said we couldn't do the optimization.

[00:44] <sorear> if the static type information can be *wrong*, and you're OK with that, then I have some head-wrapping to do

[00:44] <jnthn> sorear: I'm confused. I said you couldn't remove the type check.

[00:45] <jnthn> You seem to think I said it'd be OK to.

[00:45] <sorear> jnthn: no, I do not think that

[00:46] <pmichaud> sorear: if you're asking if it's possible for type constraints to be violated because of actions at a distance -- there's precedent for it, yes.

[00:46] <jnthn> I suspect not in *that* case though. 

[00:46] <pmichaud> I'm not sure which case sorear is specifically referring to here.

[00:46] <jnthn> An is rw param should aggregate the constraints, I thought?

[00:46] <sorear> pmichaud: I come from a Haskell background

[00:46] <jnthn> There *is* a possibility of screwing it up with :=

[00:46] *** daniel-s joined
[00:47] <jnthn> Or at least, that's been discussed.

[00:47] <sorear> pmichaud: where I come from, type constraints are never violated.  EVER.

[00:47] <pmichaud> I think sorear++ is referring to the fact that $y's constraints are violated.

[00:47] <sorear> *major culture shock confusion*

[00:48] <pmichaud> sorear: this is a case where I don't advocate a particular interpretation; I simply have asked "how is this supposed to work" and this is the answer I got back.

[00:48] <pmichaud> i.e., other people have decided that the type violation is "normal" for Perl 6 here.

[00:48] <jnthn> pmichaud: Yes, in that example though, I'm pretty sure that assignment would fail.

[00:48] <sorear> where I come from, if a variable's type constraints can be violated, no matter how contrived the situation - that's a release-blocking compiler bug

[00:48] <pmichaud> the assignment to $z, yes, but not the assignment to $x

[00:49] <jnthn> pmichaud: oh, I see what you mean.

[00:49] <jnthn> Yeah. Hm.

[00:49] <jnthn> I'm not sure what to say besides "maybe constraints on rw parameters are pointless".

[00:49] <pmichaud> the assignment to $x inside of foo means that $y is no longer of type Derived

[00:49] <jnthn> Yeah, I missed that on the first read.

[00:50] <jnthn> pmichaud: Back to what I was asking about Array/Hash - I suspect the declaration of their attributes may need to move in to BOOTSTRAP

[00:51] <pmichaud> jnthn: I have no problem with that.

[00:51] <jnthn> pmichaud: So we don't run into annoying "can't declare @foo/%bar variables before this point in the setting"

[00:51] <jnthn> pmichaud: OK.

[00:51] <pmichaud> there aren't that many attributes, anyway :)

[00:51] <jnthn> pmichaud: I probably also have roles to the point where Real and Numeric can become roles.

[00:51] <jnthn> At least, all known blockers to that are gone.

[00:52] <pmichaud> jnthn: oh, wait, does this mean that Iterator and Iterable have to move into BOOTSTRAP also?

[00:52] <pmichaud> if so, that's kind of icky

[00:52] <jnthn> pmichaud: Not automatically.

[00:52] <pmichaud> well, Iterable, at any rate.

[00:52] <jnthn> pmichaud: I'm not sure Iterable meets the criteria of "stuff that needs to be in BOOTSTRAP".

[00:52] <pmichaud> it's a base class for List

[00:53] <jnthn> pmichaud: Ah...class not role?

[00:53] <pmichaud> well, we don't have roles yet :)

[00:53] <pmichaud> but yes, it tends to want to act like a class at the moment

[00:53] <jnthn> OK

[00:53] <jnthn> Does it declare any storage?

[00:53] <pmichaud> not yet, but it might

[00:53] *** lumi_ left
[00:53] <jnthn> Ah

[00:53] <pmichaud> another question ...

[00:53] <jnthn> Then the storage aspect of it (only) would want to be in BOOTSTRAP.

[00:53] <pmichaud> do you have to put all of the attributes into BOOTSTRAP?

[00:54] <jnthn> It's all about storage.

[00:54] <pmichaud> or is it possible to have some in bootstrap and some in setting?

[00:54] <jnthn> pmichaud: Do you mean, per type?

[00:54] <jnthn> pmichaud: Or overall?

[00:54] *** lumi_ joined
[00:54] <pmichaud> for Array and Hash

[00:54] <jnthn> Then all

[00:55] *** Mowah left
[00:55] <jnthn> The criteria for "goes in bootstrap" is essentially "used in a declarative situation".

[00:55] <pmichaud> anyway, I don't have any heartache over moving those into bootstrap

[00:55] <jnthn> That is, the compiler wants to make instances of them as it builds up the environment.

[00:55] <pmichaud> it does become kind of painful to have to put List and EnumMap in there as well, but I can deal with it.

[00:56] <jnthn> Well, only the attributes

[00:56] <jnthn> Not the rest.

[00:56] <pmichaud> right

[00:56] <jnthn> Essentially, P6opaque needs to know all the attributes before the first time it makes an instance.

[00:56] <pmichaud> got it

[00:56] <pmichaud> and that would include the attributes of its base classes, too :-)

[00:56] <jnthn> Otherwise it can't compute the SI optimized memory layout that'll let us do indexed access.

[00:56] <jnthn> Exactly.

[00:57] <pmichaud> feel free to move them around

[00:57] <jnthn> Thanks, will do. Though probably tomorrow.

[00:57] <pmichaud> (conceptually it's not much different from when we were defining these classes in PIR :-)

[00:59] <jnthn> Yeah, though I expect we'll end up with the minimalish "has to be in BOOTSTRAP" set.

[00:59] <jnthn> I only put stuff in there when it needs to, or when not doing so is going to be just far too painful otherwise.

[00:59] <pmichaud> we should leave comments in the setting classes that indicate what's been defined in BOOTSTRAP

[00:59] <pmichaud> e.g.

[00:59] <pmichaud>    class List {

[00:59] <pmichaud>         # has $!items

[00:59] <pmichaud>         # has $!rest

[01:00] <pmichaud> or

[01:00] <pmichaud>         # From BOOTSTRAP:

[01:00] <pmichaud>         #     has $!items

[01:00] <pmichaud> etc.

[01:00] <jnthn> ah, good idea

[01:00] <jnthn> Will do that and add missing ones.

[01:00] *** noganex joined
[01:01] <pmichaud> my overall idea is that someone can look at the definition in core/ and from there figure out where everything is

[01:01] <pmichaud> it's okay to shorten it to just say    # predefined in BOOTSTRAP

[01:01] <pmichaud> so that they know they also need to check BOOTSTRAP (without being specifically told what is there)

[01:01] <jnthn> Ah, even better.

[01:02] <jnthn> Then it's not maintaining the same thing in two places

[01:04] *** noganex_ left
[01:04] *** mtk left
[01:05] <jnthn> pmichaud: Sleeping soon. Things for tomorrow: move array/hash to bootstrap, slurpy array/hash parameters, our-scoped variables and subs.

[01:06] <jnthn> pmichaud: Anything else you'd like me to look at especially?

[01:06] <pmichaud> those sound great

[01:06] <pmichaud> of those, slurpies would be the biggest help at the moment

[01:07] <jnthn> OK. And .arity and .count are done.

[01:07] <pmichaud> \o/

[01:07] <pmichaud> any feeling for the timing of bless/build/create ?

[01:07] <jnthn> Plus put back basic (not finished yet) .perl in signature

[01:07] <jnthn> So we get better multi-dispatch errors

[01:08] <jnthn> (bless/build/create) once we have slurpies they're more approachable.

[01:08] <pmichaud> wfm

[01:08] <pmichaud> I agree that's a blocker

[01:08] <jnthn> Oh

[01:08] <jnthn> We may need |@foo too

[01:08] <jnthn> (to pass args on to bless from new...)

[01:08] <jnthn> well, |%foo really

[01:09] <jnthn> The other thing on taht is that I found this note in the spec:

[01:09] <jnthn> "Note that the default BUILD will only initialize public attributes; you must write your own BUILD (as above) in order to present private attributes as part of your initialization API."

[01:09] <jnthn> That's different from what we've been doing so far.

[01:09] <pmichaud> oh, very much so.

[01:09] <pmichaud> I hadn't caught that one before.

[01:10] <jnthn> Should we go with what the spec says?

[01:10] *** lumi_ left
[01:10] <sorear> it's new, I think

[01:10] <pmichaud> I think yes.

[01:10] <sorear> a reaction to rakudo's behavior

[01:10] <jnthn> Oh, that's why :)

[01:10] <jnthn> OK, if it's reactionary then I follow it :)

[01:10] <pmichaud> That part of the spec makes initialization possible to be much faster

[01:10] <sorear> prototyped successfully in niecza

[01:10] <jnthn> Yeah

[01:10] <sorear> pmichaud: how?

[01:11] <jnthn> pmichaud: I plan to pre-computed a list of BUILDs that we actually ahve to call, in the meta-object.

[01:11] <jnthn> pmichaud: Then just walk that list.

[01:11] <jnthn> Rather than the craziness we do now

[01:11] *** lumi_ joined
[01:11] <jnthn> So if a class has now BUILD submethod of its own and no public attributes, we know we've nothing to call

[01:11] <pmichaud> exactly

[01:11] <jnthn> Now we always pointlessly call BUILD on Mu/Any

[01:11] <pmichaud> it's a lot cheaper to only have to call BUILD for the public attributes.

[01:12] <jnthn> Yeah

[01:12] <jnthn> Quite happy about that change overall.

[01:12] <jnthn> We'll break some folk's code.

[01:12] <sorear> I don't follow.  Why does it make a difference?

[01:12] <jnthn> Maybe worth a warning in the June release.

[01:12] <pmichaud> looks like it was changed 2010-11-05

[01:12] <pmichaud> https://github.com/perl6/specs/commit/5f6096f431d57e66b3857702327cdfa649c7aacb

[01:12] <jnthn> Oh, I was burried in $dayjob back then.

[01:12] <jnthn> And probably paying little attention.

[01:12] <sorear> Why is only initializing public attributes so much faster than initializing all of them?

[01:13] <jnthn> sorear: If you have a class with just private attributes, no need to call BUILD

[01:13] <jnthn> sorear: Maybe calls aren't so expensive for you. They are on Parrot.

[01:13] <pmichaud> what about something like    has $!private = ....  ?

[01:14] <jnthn> hmm

[01:14] <jnthn> I'm not sure quite where that is handled.

[01:14] <jnthn> In BUILD feels wrong though

[01:14] <jnthn> I mean, if the user writes their own BUILD we shouldn't ignore things like that.

[01:14] <sorear> for me, Mu.bless calls BUILD submethods only for classes that define them

[01:14] <pmichaud> well, it should be post-build, definitely.

[01:14] <jnthn> Maybe taht lives in BUILDALL

[01:14] <sorear> does Rakudo automatically generate BUILD methods?

[01:14] <pmichaud> the defaults are supposed to happen after other building takes place

[01:15] <jnthn> sorear: No, there's a default one in Mu

[01:15] <pmichaud> sorear: in rakudo there's a default BUILD method that occur.... what jnthn said

[01:16] <jnthn> That's what S12 is talking about by "the default BUILD", presumably.

[01:16] <pmichaud> some fun:

[01:16] <pmichaud> in nqp,  say(pir::const::CCLASS_WORD)

[01:16] <pmichaud> now results in

[01:17] <pmichaud> "say"(.CCLASS_WORD)

[01:17] <jnthn> Whee.

[01:17] <pmichaud> (in the PIR output)

[01:17] <jnthn> .oO( don't try that in Rakudo... :) )

[01:17] <pmichaud> which means we don't have to deal with the silly Q:PIR .includes, and we also future-proof our bootstrap .pir

[01:17] <jnthn> \o/

[01:18] <pmichaud> (currently the bootstrap pir holds the constant values, not the symbolic constants, which means things break if/when parrot changes the values)

[01:18] <pmichaud> why not in Rakudo?

[01:18] <jnthn> oh, ouch

[01:18] <jnthn> pmichaud: Because at present it'll get boxed to a Parrot Integer

[01:18] <pmichaud> it's a PAST::Val node

[01:19] <pmichaud> it's pretty smart about boxing

[01:19] <jnthn> pmichaud: Yeah, but there's no way to say at present what to do if we have some I register and need a P register

[01:19] <jnthn> afaik

[01:19] <jnthn> I mean, on a per-HLL basis

[01:19] <jnthn> It'd be nice if we had something like that in PAST::Compiler

[01:20] <pmichaud> we can add that at some point.  but yes,  say(pir::const::CCLASS_WORD)  would fail

[01:20] <pmichaud> but that's not the intended use case

[01:20] <jnthn> Yes, that's what I meant

[01:20] <jnthn> OK :)

[01:20] <pmichaud> oh, wait

[01:20] <pmichaud> I don't think it'd be boxed at all

[01:20] <pmichaud> the pir that would be generated would be

[01:20] <pmichaud> oh, yeah, it'd get boxed

[01:21] <pmichaud> anyway

[01:21] *** awwaiid left
[01:21] <pmichaud> the use case in rakudo is    pir::die("message", pir::const::CONTROL_RETURN)   

[01:21] <pmichaud> i.e., as an argument to pir:: opcodes

[01:21] <jnthn> ah, then that's just fine :)

[01:22] <pmichaud> yes, the plan has been for PAST to support HLL-level boxing at some point

[01:22] <pmichaud> I'll add that to the new version of PAST

[01:23] <jnthn> OK, great :)

[01:23] *** fish|ipad left
[01:23] <pmichaud> I'm being called away for a while -- bbl/tomorrow

[01:23] *** fish|ipad joined
[01:23] *** fish|ipad left
[01:23] *** fish|ipad joined
[01:24] <jnthn> Sleep time here also

[01:24] <jnthn> night o/

[01:26] *** whiteknight left
[01:34] *** huycwork joined
[01:36] *** fish|ipad left
[01:38] *** lumi_ left
[01:40] *** lumi_ joined
[01:45] *** fish|ipad joined
[01:45] *** fish|ipad left
[01:45] *** fish|ipad joined
[01:53] *** kid51 joined
[01:58] *** fish|ipad left
[02:04] *** araujo joined
[02:04] *** araujo left
[02:04] *** araujo joined
[02:23] *** kid51 left
[02:25] *** Chillance left
[02:29] *** kid51 joined
[02:38] <TiMBuS> http://quercus.caucho.com/

[02:38] <TiMBuS> i um

[02:38] <TiMBuS> i lack words

[02:43] *** lumi_ left
[02:44] *** lumi_ joined
[02:52] <sorear> so I implemented a new autoviv implementation that makes @a[0][0][0] = @a[0][0][5] = 10 work

[02:52] <sorear> but it's half as fast as the current one :/  *shelve*

[02:53] <colomon> Is it only slowing down autoviv?

[02:54] <sorear> no, all aggregate access

[02:54] <colomon> oh, that's ugly

[02:55] <TimToady> I assume you're still trying to do it all at run time, rather than isolating the knowable lvalues at parse time

[02:56] * colomon has up-to-date niecza and nom built for the first time all week...

[02:56] <colomon> afk # bed

[02:58] <pmichaud> xyz( @a[0][0][0] )    # don't really know if it's lvalue or not at parse time

[02:58] <TimToady> yes you do

[02:58] <TimToady> now if it were a method, you'd have a point

[02:58] <pmichaud> xyz could be multi

[02:58] <pmichaud> xyz( @a[$x] )   then

[02:58] <TimToady> chances are they're all or none rw

[02:59] <TimToady> but all knowable at compile time

[02:59] <pmichaud> method call, then :-)

[02:59] <TimToady> maybe we outlaw that :)

[03:00] <pmichaud> afk for a bit  # walk

[03:00] <TimToady> but you can still know that no method declared in this program named "foo" was rw

[03:00] <sorear> maybe outlaw what?

[03:00] <TimToady> rw params on methods :)

[03:01] <TimToady> in any case, I still think autoviv that can be known to be required at compile time is likelier to be faster than any lazy implementation of autoviv

[03:02] <TimToady> and I think it's knowable much of the time

[03:03] <sorear> compile time analysis is definitely going to be a huge win...

[03:04] <sorear> (I agree)

[03:04] <sorear> the main thing that still looms in my mind about whole-program analysis is the setting

[03:05] <sorear> if we have to analyze the user's program before we can optimize CORE, that'll really hurt my chances of getting 50ms -e 'say 2 + 2' :)

[03:06] <sorear> (on my system that seems to take about 8ms with perl5.  also, it seems I have HZ=250)

[03:07] <Eevee> or outlaw rw params entirely  8)  this ain't C, you can return a list

[03:08] <sorear> outlawing rw parameters would require us to special case = much more than we already do

[03:09] <sorear> and other operators, like ++

[03:09] <Eevee> ah, boo.

[03:09] *** lumi_ left
[03:09] <TimToady> well, that's why operators are functions in P6, not methods :)

[03:10] *** lumi_ joined
[03:11] *** am0c left
[03:13] *** envi_laptop joined
[03:15] <TimToady> it's also not entirely certainly that we can't outlaw rw params on a proto by proto basis

[03:21] *** furryfishy joined
[03:21] *** furryfishy left
[03:21] *** furryfishy joined
[03:23] *** Su-Shee_ joined
[03:25] *** Su-Shee left
[03:25] <pmichaud> what about   lift xyz( @a[$x][$y][$z] )

[03:25] *** kid51 left
[03:27] <Util> I love being able to call a sub as a method with the .&foo syntax.

[03:27] <Util> I can even change foo($_,42) into .&foo(42) .

[03:28] <Util> Where is this syntax mentioned in the Specs?

[03:30] <sorear> S12:339

[03:31] <TimToady> I think it's a bit ugly, actually :)

[03:31] <sorear> It just occurred to me that there's nothing in the specs requiring CORE:: to be implemented as a loadable Perl 6 module

[03:32] <TimToady> nope, can be purely lexical OUTER

[03:32] <TimToady> in fact, I once had it set up such that you *can't* load CORE

[03:33] <sorear> if it is just a bunch of stubbed routines from the runtime code, then I don't have any "perl6 -e '2 + 2' takes 500ms to run CORE's CHECK-time optimization" problems

[03:35] *** hudnix left
[03:37] *** lumi_ left
[03:38] *** lumi_ joined
[03:42] *** jaldhar left
[03:42] *** jaldhar joined
[03:49] *** ymasory joined
[03:51] <Util> TimToady: Thanks! I must say that, if I did not already know about .&foo, I would not infer it from S12:339.

[03:51] <Util> An explicit example would be a helpful addition (as well as being `ack`-able)

[03:52] <Util> I can see how .&foo is implied, but it is a bit of a reach.

[04:13] *** perlEnthusiatic joined
[04:14] <perlEnthusiatic> hello

[04:14] <perlEnthusiatic> How can I get started to contribute to Perl6?

[04:16] <perlEnthusiatic> any1 here?

[04:16] *** ymasory left
[04:17] <TimToady> howdy

[04:17] <TimToady> what are you interested in?

[04:18] <sorear> welcome

[04:19] <TimToady> perlEnthusiatic: mostly, just start playing with it, to begin with

[04:19] <TimToady> find something fun to try to write

[04:20] <perlEnthusiatic> I am interested in anything that is Perl 

[04:20] <TimToady> that's kind of a broad category these days :)

[04:21] <TiMBuS> start simple. write some perl6 bindings for gtk :D

[04:21] *** lumi_ left
[04:21] <TimToady> if you're familiar with Perl 5, then probably you want to look at moritz's p5-to-p6 pages first

[04:22] <sorear> perlEnthusiatic: perhaps I should ask why you are interested in Perl?

[04:22] *** lumi_ joined
[04:22] <TimToady> http://perlgeek.de/en/article/5-to-6

[04:22] <sorear> If we know what brought you here, perhaps it would help.

[04:22] <TimToady> what do you currently do with Perl?

[04:23] <perlEnthusiatic> I am interested in Perl because I learnt it in 7 days after i passed out from college and made 3 figures salary at a corporate company... I never looked back eversince!

[04:24] <perlEnthusiatic> Watch Larry Wall's and Damian's interviews all the time and finally thought of contributing what I can

[04:24] <TimToady> have you played with, say, C or mono?

[04:25] <sorear> what natural language(s) are you familiar with?

[04:25] <perlEnthusiatic> C, C#, C++ - C# is kind of better these days considering that I am working on it

[04:26] <TimToady> one thing you can do is find something that hasn't been written in Perl 6 yet and write it; there's a list of tasks at http://rosettacode.org/wiki/Reports:Tasks_not_implemented_in_Perl_6

[04:26] <TimToady> if you know C# you can probably help sorear out with niecza, since that runs on mono/.net

[04:28] <TimToady> niecza: say "howdy perlEnthusiatic!"  # greetings from mono

[04:28] <p6eval> niecza v6-150-g612a7b7: OUTPUT«howdy perlEnthusiatic!␤»

[04:28] <perlEnthusiatic> good, and you?

[04:28] <sorear> for Perl6 to be a well-used language, it needs...

[04:28] <sorear> ... faster compilers

[04:29] <TiMBuS> niecza is not yet sentient

[04:29] <sorear> ... faster, leaner runtimes

[04:29] <sorear> ... more libraries in the box

[04:29] <sorear> ... better infrastructure / CPAN integration stuff

[04:29] <TimToady> me?  I just hang out here and kibbitz...

[04:29] <TiMBuS> the ability to determine lvalues

[04:29] <perlEnthusiatic> I understand.

[04:29] <sorear> ... more widely-disseminated documentation

[04:30] <sorear> ... more public awareness

[04:30] <sorear> ... probably other things

[04:30] <sorear> all of these are interrelated

[04:31] <perlEnthusiatic> ok...

[04:31] <yath> speaking of niecza, will it be able to call other CLI classes?

[04:31] <perlEnthusiatic> I am taking a look at the things that are not implemented. 

[04:31] <yath> i.e. is this a design goal?

[04:31] <sorear> yath: it can call other CLI classes; making it more transparent is a design goal

[04:31] <yath> sorear: \o/

[04:32] <perlEnthusiatic> guys, I am out. Be back later on. Excited to be part of the team. 

[04:32] <TimToady> welcome!

[04:32] <perlEnthusiatic> Thanks Yim

[04:32] <perlEnthusiatic> Tim*

[04:32] <sorear> niecza> Q:CgOp { (box Int (rawscall System.Console.get_WindowWidth)) }

[04:32] <sorear> 80

[04:32] *** perlEnthusiatic left
[04:32] <sorear> something like that

[04:32] <yath> cool! sorear++

[04:37] <sorear> known gaping holes: * no support for overloading * no support for calling constructors * limited support for CLR primitive operations * no ability to add assembly references

[04:40] *** kaare_ joined
[04:56] *** JimmyZ joined
[05:01] *** lumi_ left
[05:02] *** lumi_ joined
[05:03] *** nymacro joined
[05:09] <sorear> std: my push $x;

[05:09] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/fIqFDaVyZG line 1:␤------> [32mmy [33m⏏[31mpush $x;[0m␤    expecting any of:␤       scoped declarator␤      typename␤Parse failed␤FAILED 00:01 118m␤»

[05:09] <sorear> std: my ::push $x;

[05:09] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[05:18] <sorear> std: my sub Int foo($x) { }

[05:18] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Return type Int is not allowed between 'sub' and 'foo'; please put it:␤  after the 'my' but before the 'sub',␤  within the signature following the '-->' marker, or␤  as the argument of a 'returns' trait after the signature. at /tmp/19JUuvJQKF line

[05:18] <p6eval> ..1:␤…

[05:33] *** XoDys joined
[05:33] *** XoDys left
[05:35] <sorear> *mumbles at is_name having to reparse the name*

[05:45] *** XoDys joined
[05:46] <sorear> it would be a bit nicer if it could access the longname or identifier Match directly.  I wonder why all the callers stringify it.

[05:46] * sorear feels like ey's on a reverse engineering project

[05:47] <sorear> niecza: #DEBUG -1␤say 2 + 2

[05:47] <p6eval> niecza v6-150-g612a7b7: OUTPUT«DEBUG␤In EXPR, at 10␤In loop, at 10␤is_name say␤Looking for say␤Looking in MY:file</tmp/6wWodVbveI>␤Looking in MY:unit<CORE>:xid<837>␤Looking in MY:unit<CORE>:xid<1>␤Looking in MY:unit<CORE>:xid<0>␤say not found␤In EXPR, at 14␤In loop, at 14␤after push: 1␤In loop, at

[05:47] <p6eval> ..18␤after push:…

[05:52] *** lumi_ left
[05:53] *** lumi_ joined
[05:55] <sorear> TimToady: Is the stuff in STD that tries to let lexical lookups fall-back to OUR:: and GLOBAL:: fossils?

[06:01] *** kaare_ left
[06:07] * sorear afk walk

[06:14] <TimToady> sorear: not sure--if there's a Foo package in GLOBAL, you should be able to find Foo::<$bar> without putting GLOBAL on the front of it

[06:16] <TimToady> OUR is for looking up something in our package that hasn't been declared with 'our', so probably is meaningful if others can add vars to our current package, which they can

[06:17] <TimToady> but maybe it's illegal anyway to use that as a bare variable without explicit OUR:: qualification

[06:17] <TimToady> so maybe that one doesn't make much sense

[06:19] *** thou left
[06:21] *** envi_laptop left
[06:26] *** f00li5h left
[06:31] *** lumi_ left
[06:31] *** envi_laptop joined
[06:32] *** lumi_ joined
[06:36] *** f00li5h joined
[06:36] *** envi_laptop left
[06:37] *** XoDys left
[06:41] * sorear returns

[06:41] <sorear> (with much more understanding of names, too)

[06:45] *** kaare_ joined
[06:46] <moritz> sorear: did you study with master Elodin? :-)

[06:47] <sorear> no

[06:47] <moritz> (sorry, obscure reference to fantasy, see "The Name of the Wind" by. P. Rothfuss)

[06:47] <sorear> I studied, but noone else showed up :/

[06:54] <JimmyZ> Does Perl 6 support static attrs?

[06:55] <sorear> yes

[06:55] <sorear> Rakudo? no

[06:55] <sorear> syntax is 'my $.foo'

[06:57] <JimmyZ> thanks

[06:59] *** lumi_ left
[06:59] <sorear> JimmyZ: are you writing some kind of documentation?

[07:00] *** lumi_ joined
[07:02] <JimmyZ> sorear: Nope, I thought about it yesterday night before sleeping

[07:05] <sorear> speaking of which, *poof*

[07:18] *** jfried joined
[07:20] *** wamba joined
[07:23] *** lumi_ left
[07:23] *** lumi_ joined
[07:38] *** jrockway left
[07:38] *** ilogger2_ joined
[07:45] *** hillu joined
[07:45] *** clkao joined
[07:45] *** Bucciarati joined
[07:45] *** acrussell joined
[07:45] *** cognominal joined
[07:45] *** mj41 joined
[07:45] *** cotto_work joined
[07:45] *** barika joined
[07:45] *** starcoder2 joined
[07:45] *** c9s joined
[07:45] *** Util joined
[07:45] *** BinGOs joined
[07:45] *** Tedd1 joined
[07:45] *** Patterner joined
[07:45] *** sorear joined
[07:45] *** nymacro joined
[07:45] *** sftp_ joined
[07:45] *** meraxes joined
[07:45] *** felher joined
[07:45] *** prammer joined
[07:45] *** mdxi joined
[07:45] *** wolverian joined
[07:45] *** krakan joined
[07:45] *** _ilbot joined
[07:45] *** charsbar__ joined
[07:45] *** gabiruh joined
[07:45] *** aloha joined
[07:45] *** llabthgie joined
[07:45] *** athomason joined
[07:45] *** JodaZ joined
[07:45] *** mux joined
[07:45] *** nsh| joined
[07:45] *** Raynes joined
[07:45] *** mikemol joined
[07:45] *** jdhore1 joined
[07:45] *** snarkyboojum joined
[07:45] *** eternaleye joined
[07:45] *** ashleydev joined
[07:45] *** LoRe joined
[07:45] *** beppu joined
[07:45] *** ascent_ joined
[07:45] *** jesk joined
[07:45] *** cschimm1_ joined
[07:45] *** robinsmidsrod joined
[07:45] *** Yappoko__ joined
[07:45] *** c1sung joined
[07:45] *** foomator joined
[07:45] *** Grrrr joined
[07:45] *** nrr joined
[07:45] *** Helios joined
[07:45] *** ribasushi joined
[07:45] *** jql joined
[07:45] *** bbkr_ joined
[07:45] *** chitragupt joined
[07:45] *** jasonmay joined
[07:45] *** starcoder joined
[07:45] *** uniejo joined
[07:45] *** geekosaur joined
[07:45] *** jdv79 joined
[07:45] *** pochi joined
[07:45] *** kfo_ joined
[07:45] *** yves joined
[07:45] *** silug joined
[07:45] *** tomize joined
[07:45] *** jnthn joined
[07:45] *** betterworld joined
[07:45] *** pjcj joined
[07:45] *** simcop2387 joined
[07:45] *** jtpalmer joined
[07:45] *** domidumont joined
[07:45] *** sivoais joined
[07:45] *** stepnem joined
[07:45] *** PacoLinux joined
[07:45] *** xinming joined
[07:45] *** kst joined
[07:45] *** REPLeffect joined
[07:45] *** george_z0rwell joined
[07:45] *** frettled joined
[07:45] *** lue joined
[07:45] *** ChrisDennis joined
[07:45] *** masak joined
[07:45] *** Guest96628 joined
[07:45] *** _patch joined
[07:45] *** y3llow joined
[07:45] *** Vlavv joined
[07:45] *** TimToady joined
[07:45] *** Su-Shee_ joined
[07:45] *** wamba joined
[07:45] *** Maddingu1 joined
[07:45] *** lestrrat joined
[07:45] *** tylercur1is joined
[07:45] *** larks_ joined
[07:45] *** szbalint_ joined
[07:45] *** breinbaa1 joined
[07:45] *** sunnavy joined
[07:45] *** pnu joined
[07:45] *** tadzik joined
[07:45] *** takesako joined
[07:45] *** cosimo joined
[07:45] *** mathw joined
[07:45] *** jjore joined
[07:45] *** pmichaud joined
[07:45] *** ingy joined
[07:45] *** Juerd joined
[07:45] *** flussence joined
[07:45] *** Lorn joined
[07:45] *** dukeleto joined
[07:45] *** amkrankruleuen joined
[07:45] *** colomon joined
[07:45] *** [particle] joined
[07:45] *** wooden joined
[07:45] *** lumi_ joined
[07:45] *** tty234 joined
[07:45] *** tewk joined
[07:45] *** pyrimidine joined
[07:45] *** miso2217 joined
[07:45] *** cxreg joined
[07:45] *** hatseflats joined
[07:45] *** perigrin joined
[07:45] *** Eevee joined
[07:45] *** jfried joined
[07:45] *** takadonet joined
[07:45] *** arnsholt joined
[07:45] *** sbp joined
[07:45] *** fhelmberger joined
[07:45] *** huf joined
[07:45] *** slavik1 joined
[07:45] *** yahooooo joined
[07:45] *** Gothmog_ joined
[07:45] *** moritz joined
[07:45] *** yath joined
[07:45] *** Katibe joined
[07:45] *** ruoso joined
[07:45] *** drbean joined
[07:45] *** apejens joined
[07:45] *** PerlJam joined
[07:45] *** szabgab joined
[07:45] *** mberends joined
[07:45] *** zamolxes joined
[07:45] *** pothos joined
[07:45] *** JimmyZ joined
[07:45] *** _sri joined
[07:45] *** envi_laptop joined
[07:45] *** literal joined
[07:45] *** HarryS joined
[07:45] *** perplexa joined
[07:45] *** furryfishy joined
[07:45] *** buubot_backup joined
[07:45] *** Trashlord joined
[07:45] *** Bzek joined
[07:45] *** tomaw joined
[07:45] *** sftp_ left
[07:45] *** nymacro left
[07:45] *** sorear left
[07:45] *** Patterner left
[07:45] *** Tedd1 left
[07:45] *** BinGOs left
[07:45] *** Util left
[07:45] *** c9s left
[07:45] *** starcoder2 left
[07:45] *** barika left
[07:45] *** cotto_work left
[07:45] *** Pathin joined
[07:45] *** araujo joined
[07:45] *** noganex joined
[07:45] *** estrabd joined
[07:45] *** Krunch joined
[07:45] *** benabik joined
[07:45] *** slavik joined
[07:45] *** shachaf joined
[07:45] *** cookys joined
[07:45] *** Woody2143 joined
[07:45] *** nebuchadnezzar joined
[07:45] *** PZt joined
[07:45] *** kcwu joined
[07:45] *** baest joined
[07:45] *** estrai_ joined
[07:45] *** sjn joined
[07:45] *** renormalist joined
[07:45] *** broquaint joined
[07:45] *** frodwith joined
[07:45] *** zb joined
[07:45] *** perplexa is now known as Guest4182

[07:45] *** jfried left
[07:45] *** Eevee left
[07:45] *** perigrin left
[07:45] *** cxreg left
[07:45] *** hatseflats left
[07:45] *** miso2217 left
[07:45] *** pyrimidine left
[07:45] *** tewk left
[07:45] *** tty234 left
[07:45] *** HarryS left
[07:45] *** envi_laptop left
[07:45] *** _sri left
[07:45] *** JimmyZ left
[07:45] *** pothos left
[07:45] *** zamolxes left
[07:45] *** mberends left
[07:45] *** szabgab left
[07:45] *** PerlJam left
[07:45] *** apejens left
[07:45] *** drbean left
[07:45] *** ruoso left
[07:45] *** Katibe left
[07:45] *** yath left
[07:45] *** moritz left
[07:45] *** shachaf left
[07:45] *** tty234 joined
[07:45] *** risou joined
[07:45] *** shachaf joined
[07:49] *** jfried joined
[07:49] *** kolibrie_ joined
[07:49] *** kaare_ joined
[07:49] *** f00li5h joined
[07:49] *** diakopter joined
[07:49] *** ggoebel joined
[07:49] *** gfldex joined
[07:49] *** mattp_ joined
[07:49] *** skangas joined
[07:49] *** rhr joined
[07:49] *** jrockway joined
[07:49] *** revdiablo joined
[07:49] *** bs338 joined
[07:49] *** spinclad joined
[07:49] *** krunen joined
[07:49] *** Eevee joined
[07:49] *** perigrin joined
[07:49] *** hatseflats joined
[07:49] *** cxreg joined
[07:49] *** miso2217 joined
[07:49] *** pyrimidine joined
[07:49] *** tewk joined
[07:49] *** sftp_ joined
[07:49] *** nymacro joined
[07:49] *** sorear joined
[07:49] *** Patterner joined
[07:49] *** Tedd1 joined
[07:49] *** BinGOs joined
[07:49] *** Util joined
[07:49] *** c9s joined
[07:49] *** starcoder2 joined
[07:49] *** barika joined
[07:49] *** cotto_work joined
[07:50] *** envi_laptop joined
[07:50] *** _sri joined
[07:50] *** JimmyZ joined
[07:50] *** pothos joined
[07:50] *** zamolxes joined
[07:50] *** mberends joined
[07:50] *** szabgab joined
[07:50] *** PerlJam joined
[07:50] *** apejens joined
[07:50] *** drbean joined
[07:50] *** ruoso joined
[07:50] *** Katibe joined
[07:50] *** yath joined
[07:50] *** moritz joined
[07:53] *** Su-Shee_ is now known as Su-She

[07:53] *** Su-She is now known as Su-Shee

[07:58] *** mj41 left
[08:02] *** mj41 joined
[08:06] <TiMBuS> :I

[08:16] <dalek> rakudo/nom: af773fb | moritz++ | src/core/Num.pm:

[08:16] <dalek> rakudo/nom: add Num.isNaN

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af773fb56a

[08:16] <dalek> rakudo/nom: 8393f6b | moritz++ | / (2 files):

[08:16] <dalek> rakudo/nom: Add Complex (mostly copied from master)

[08:16] <dalek> rakudo/nom: 

[08:16] <dalek> rakudo/nom: Sadly I couldn't test it, because "Complex.new(2, 3).Str"

[08:16] <dalek> rakudo/nom: segfaults in Rakudo_cont_decontainerize - but maybe it gives

[08:16] <dalek> rakudo/nom: jnthn++ et. al. a useful start point for debugging

[08:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8393f6bfcf

[08:18] <moritz> nom: my $x = 3; say "foo $x"

[08:18] <p6eval> nom:  ( no output )

[08:18] *** beekar joined
[08:18] <moritz> ah, string interpolation in general segfaults.

[08:22] <pmichaud> pmichaud@kiwi:~/rakudo$ ./perl6

[08:22] <pmichaud> > my @t; @t[0][2] = @t[0][0] = 9;  say @t[0].perl;

[08:22] <pmichaud> [9, Any, 9]

[08:22] <pmichaud> \o/

[08:23] <moritz> \o/ indeed

[08:24] <moritz> Method 'methodname' not found for invocatn of class 'SixModelObject' ... is really frustrating

[08:24] <pmichaud> > my @a;  @a[0][0][0] = @a[0][0][5] = 10;  say @a.perl;

[08:24] <pmichaud> [[[10, Any, Any, Any, Any, 10]]]

[08:24] <pmichaud> \o/

[08:25] <mberends> \o/ :-)

[08:29] * moritz wonders if pmichaud suffers from insNOMnia

[08:29] <mberends> heh

[08:29] <pmichaud> lately, yes.

[08:30] <pmichaud> I'm having so much -Ofun hacking that I've been foregoing sleep to do it

[08:31] <mberends> istr that pmichaud generally gets by on a much-below-average amount of sleep

[08:31] *** araujo left
[08:31] <pmichaud> that was once very true, yes.  but a few months ago I was needing above-average amounts of sleep.  for me it seems to come and go in cycles 

[08:32] <pmichaud> I'm heading back into a below-average period again, it appears :)

[08:32] <dalek> rakudo/nom: 3f8e441 | moritz++ | src/core/ (3 files):

[08:32] <dalek> rakudo/nom: add a few missing .abs methods, and avoid segfault in Complex stringification

[08:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3f8e441b7c

[08:32] <moritz> $ ./perl6 -e '1i'

[08:32] <moritz> Method 'new' not found for invocant of class 'Sub'

[08:32] <moritz> I have no clue where that Sub is coming from

[08:33] <pmichaud> me either... but program initialization in general needs a fair bit of rework in nom

[08:36] <moritz> the generated pir looks funny-ish

[08:37] *** lumi_ left
[08:37] *** lumi_ joined
[08:37] <pmichaud> moritz: in the case of  "$.re $op ($.im.abs)i"   (which I know you've changed already)   wouldn't there need to be parens after the method calls?

[08:37] <pmichaud> (that may or may not be why it failed)

[08:38] *** jaldhar left
[08:38] <moritz> pmichaud: simple interpolation of any variable segfaults in nom

[08:38] *** jaldhar joined
[08:38] <pmichaud> ah, that's an issue.

[08:38] <moritz> pmichaud: and I think $.re is considered sufficently variable-ish that it doesn't need parens

[08:39] *** HarryS joined
[08:39] <moritz> perl6: class A { has $.foo = 3; method Str() { "Foo: $.foo" } }; say A.new.Str

[08:39] <p6eval> pugs, rakudo 4a6d21, niecza v6-150-g612a7b7: OUTPUT«Foo: 3␤»

[08:39] <pmichaud> well, the .abs would want one.

[08:39] <moritz> aye

[08:39] *** kaare_ left
[08:40] <pmichaud> I guess since they parse as variables it fits.

[08:40] <moritz> https://gist.github.com/1021349 lines 4 to 16... maybe pir -> pbc was faster if we didn't emit such constants 3 times :-)

[08:42] <tadzik> :D

[08:42] <masak> morning, #perl6.

[08:42] <tadzik> I wonder how faster would it get if we passed it to |uniq

[08:42] <dalek> rakudo: ae5bead | pmichaud++ | / (3 files):

[08:42] <dalek> rakudo: Update &infix:<=> to evaluate its arguments in a r-to-l sequence.

[08:42] <dalek> rakudo: This appears to fix the @t[0][2] = @t[0][0] = 9 bug.

[08:42] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/ae5beadb92

[08:43] <mberends> good morning masak

[08:43] <pmichaud> which constants?

[08:43] <moritz> good morning tadzik and masak 

[08:44] <tadzik> .const 'Sub' $P14 = "11_1307867594.6099" 

[08:45] <pmichaud> I only see it twice there.  :)

[08:46] <moritz> the third time it's stored in a different (unused) PMC

[08:46] <moritz>     .return ($P44)

[08:46] <moritz>     .const 'Sub' $P46 = "12_1307867594.6099"

[08:46] <moritz>     .return ($P46)

[08:47] <pmichaud> that's actually a different constant.

[08:47] <pmichaud> note the "12_" instead of the "11_"

[08:47] <moritz> it's the same sub

[08:47] <moritz> oh

[08:47] <moritz> ok

[08:47] <pmichaud> I agree it ends up being unused (more)

[08:47] <moritz> still dead code

[08:47] <TiMBuS> hey pmichaud, w/r/t autovivifying and lvalues: have you figured out a solution to the "@a[1..*] = @b[1..*]" problem?

[08:47] <pmichaud> TiMBuS: Yes, I have.

[08:48] <TiMBuS> i ask because i spent a solid few hours trying to fix it myself and failing pretty miserably and id love to hear how

[08:48] <TiMBuS> you did it

[08:48] <pmichaud> there are still some design issues, but figuring out the assignment part itself is no big deal

[08:49] <pmichaud> the major question at this point is how we signal that something is "infinitish"

[08:49] <TiMBuS> i thought the current list implementation had to track if something was potentially infinite

[08:49] <pmichaud> we've speculatively used   ,*   to mean "this parcel acts like it's infinite", and then any such parcel used in an array causes autotrimming to take place

[08:50] <pmichaud> sure, the list implementation tracks if something is potentially infinite -- what we've been missing is how to signal that a sequence is infinite

[08:50] <pmichaud> e.g., if I have a gather/take statement, how can I signal "the results of this gather are potentially infinite"?

[08:51] <pmichaud> so, the answer is that we do something like   (gather {...} ,*)

[08:51] <pmichaud> which creates a Parcel with the contents of the gather, and the Parcel "knows" that it's infinite because of the final ,*

[08:51] <TiMBuS> i see

[08:52] <pmichaud> so, when that gets used as a subscript, the postcircumfix<[ ]>  knows to check subscripts as it goes and stop when it finds one that is beyond the end of the current array  (i.e., don't extend the array)

[08:52] <pmichaud> what we call "autotrim"

[08:54] <pmichaud> (dead code)  the reason for the dead .return there is that we have to do some fakery in the first sub in order to get "main" to work properly and still have :load :init subs take place in the proper sequence.   the end result of that fakery is that the PAST compiler gets a little confused and we get two returns

[08:55] <pmichaud> ...which has mainly to do with the fact that parrot doesn't give us good control over :load versus :init versus :main (further complicated by the fact that subs with :outer have to physically occur after their outer context, which means that :main cannot be both the last sub in a file and an :outer target).

[08:57] *** daniel-s_ is now known as daniel-s

[08:57] <TiMBuS> so TimToadys solution was to check for lvalue-ness at ast building time. I'm guessing this is impossible?

[08:57] <masak> yes, the initialization of private attributes was spec'd to go away after the Big Discussion about introspection of attributes. the one that TheDamian started on p6l.

[08:58] <masak> TiMBuS: it does sound at least difficult.

[08:58] <ingy> o/

[08:58] <pmichaud> masak: ah, yes, I forgot about that discussion

[08:59] <masak> pmichaud: the other part that needed to go away was .perl printing private attrs.

[08:59] <ingy> masak: going to yapc:eu?

[08:59] <masak> ingy: yes \o/

[08:59] <TiMBuS> also, is there a reason to not just assume any gather/take is potentially infinite instead? saving the need for the hacker to make a special parcel setup (unless that is what you're already 'magically' doing)

[08:59] <pmichaud> TiMBuS: I'm not willing to say impossible, but we've come up with a few (possibly obscure) instances where it doesn't seem possible

[08:59] <masak> ingy: though being three events away, it does feel a bit distant :)

[08:59] <pmichaud> TiMBuS: the sequence    1...10   is implemented using gather/take, but is obviously not infinite.

[08:59] <ingy> masak: \o/\o/

[09:00] <pmichaud> in general, we implement sequences and other very-lazy operations using gather/take, but we don't want all (or even most) of those to be treated as infinite

[09:00] <ingy> masak: 3rd for me too, what others?

[09:00] <pmichaud> same thing goes for things like I/O and the like

[09:01] * ingy has 9 confs planned from now to eo11

[09:01] <TiMBuS> ...assume infinite unless provably not? no, no that requires language analysis.

[09:01] <ingy> masak: actually y:eu is my 4th

[09:01] <pmichaud> the person implementing &infix:<...>  has enough context to be able to say "this should act infinite" -- we just need some way to signal that in the returned value.

[09:01] * moritz should consider getting a "real" job to be able to afford more conferences :-)

[09:02] <ingy> moritz: just stop living a "real" life

[09:02] <masak> ingy: NPW next weekend, then FPW the next.

[09:02] <moritz> ingy: no way, family still takes precedence

[09:02] <moritz> .oO( or "binds tighter", in p6 speak :-)

[09:03] <TiMBuS> being lazy is hard :s

[09:04] <ingy> masak: YAPC:NA, DebConf, CCC, YAPC:EU, IPW, OSDC.fr, PPW, YAPC:Tokyo, OSDC.au

[09:05] *** icwiener joined
[09:05] * ingy lives the Python dream...

[09:06] <ingy> s/Python/$perl6_dialect/

[09:07] <tadzik> damn those junctions, where do they come from

[09:07] *** lumi_ left
[09:07] <ingy> masak: anyway, let's plan on some hacking

[09:08] *** lumi_ joined
[09:10] <tadzik> if a junction is created, the phrase /:i junction/ should appear somewhere in the generated pir

[09:10] <tadzik> ?

[09:10] <pmichaud> not necessarily

[09:10] <pmichaud> any() would create a Junction, for example

[09:10] <pmichaud> as would  infix:<|>

[09:10] <tadzik> ok, I'll look for that

[09:10] <pmichaud> lots of things can create junctions

[09:11] <masak> ingy: yes, let's!

[09:11] <masak> tadzik: have you tried minimizing the code?

[09:13] <tadzik> masak: seems that I should

[09:14] <tadzik> but the simplest case fails :/

[09:14] *** Mowah joined
[09:14] <tadzik> it's this silly thing, the function returns a pod node, the returned thing is a junction

[09:15] <tadzik> let's see what happens when I inline a function

[09:16] *** nymacro left
[09:16] <masak> tadzik: if the simplest case fails, that's significant. :)

[09:20] <tadzik> whenever it's returned, it magically becomes a Junction

[09:20] <masak> what's the smallest piece of code that you can demonstrate this with?

[09:21] <tadzik> oh wait, I think I'm close

[09:21] <tadzik> yes, got it

[09:21] <masak> \o/

[09:21] <tadzik> passing $<identifier>.substr(4) to a .new makes the object become a Junction as soon as it's returnet

[09:21] <tadzik> or even returned

[09:22] <masak> is it possible to demonstrate with p6eval?

[09:22] <moritz> try $<identifier>.Str.substr(4)

[09:22] <tadzik> there we go

[09:22] <tadzik> Null PMC access in find_method('perl')...

[09:22] <moritz> or (~$<identifier>).substr(4)

[09:22] <tadzik> in 'Junction::Str' at line 1

[09:23] <tadzik> so $<identifier> is a Junction!

[09:23] <moritz> what does $<identifier>.PARROT report?

[09:23] <tadzik> or is it? :)

[09:23] <tadzik> Junction

[09:23] <masak> wtf

[09:23] <moritz> wtf

[09:23] <pmichaud> I bet somewhere in your grammar you have  $<identifier> = { foo | bar }

[09:23] <tadzik> yeah, I wanted to say it gently, but seriously, wtf

[09:24] <tadzik> $<identifier>=[ 'code' | 'comment' ]

[09:24] <pmichaud> or something like that.

[09:24] * tadzik weeps

[09:24] <pmichaud> is that inside of curlies?

[09:24] <tadzik> that's inside a token, yes

[09:24] <pmichaud> can I see the whole token ?

[09:24] <tadzik> but || doesn't change much. Sure

[09:25] <masak> tadzik: why d'you keep using | for alternations? it's a ticking bomb... :/

[09:25] <tadzik> https://github.com/tadzik/gsocmess/blob/master/lib/Pod6/Grammar.pm#L78

[09:25] <tadzik> masak: yeah, you warned me, I remember :)

[09:25] <masak> warning still applies. :)

[09:25] <tadzik> but still, that part was supposed to be fired on sym<abbreviated>, not <abbreviated_raw>

[09:25] <moritz> I guess it just feels more future-proof

[09:25] <tadzik> so that one should not apply

[09:26] <tadzik> yeah, must've forgot about that

[09:26] <tadzik> but it's not the case it seems

[09:27] <tadzik> Every | has now a pair in the grammar, the Junction still is

[09:27] <pmichaud> I bet there's an unpaired brace somewhere.

[09:27] <masak> tadzik: I still think you'd do well to minimize the failing code.

[09:27] *** sjohnson joined
[09:28] *** fish|ipad joined
[09:28] *** fish|ipad left
[09:28] *** fish|ipad joined
[09:28] <tadzik> masak: the failing code is lists, which basically depends on the entire grammar with action methods

[09:28] <masak> tadzik: well, you don't need to preserve the intended semantics, just the bug...

[09:28] <tadzik> yeah, I know

[09:29] <tadzik> oh, wait

[09:29] <tadzik> if $<identifier> ~~ /^item [\d+]?/ { # <= turns Match into a Junction

[09:30] <tadzik> yeah, ~~ modifies $/ :/

[09:31] <pmichaud> smartmatching match objects with regexes does weird stuff, yes.

[09:31] <pmichaud> try ~$<identifier>  if you really mean to do a string match.

[09:32] <tadzik> it then turns Match into a Proxy, but everything seems to work

[09:32] <pmichaud> why are your action methods doing "return", ooc?

[09:32] <pmichaud> oh, those aren't actions methods I guess

[09:32] <tadzik> yep

[09:33] *** mj41 left
[09:33] <tadzik> yay, fixed

[09:34] <tadzik> pmichaud++ masak++ moritz++, Thank you

[09:34] <pmichaud> isn't   /^item [\d+]?/   the same as  /^item \d*/   ?

[09:34] <pmichaud> that looks funny to me :-)

[09:34] <tadzik> it probably is, yes

[09:35] <tadzik> indeed, now that I think of it :0

[09:35] <tadzik> :)

[09:36] <masak> tadzik: if you give me a minimal test case, I'll submit the rakudobug for you.

[09:37] <daniel-s> are modules and packages different things in perl 6?

[09:38] <masak> daniel-s: yes.

[09:38] <tadzik> masak: cando in a sec

[09:38] <daniel-s> according to the documentation, the module keyword is what used to be the package keyword in perl 5

[09:38] <masak> aye.

[09:38] <daniel-s> is there something that explains it I can read?

[09:38] <masak> well, S10 and S11...

[09:39] <tadzik> lessons learned. When in doubt, stringify

[09:39] <tadzik> another two tests fixed :)

[09:40] <masak> daniel-s: but the executive summary is "no-one really knows what `package` is for in Perl 6".

[09:40] <masak> tadzik: that honestly sounds like a lesson one shouldn't have to learn, ideally.

[09:40] <daniel-s> masak: is that cos it's not finished yet?

[09:40] <pmichaud> the fact that $<identifier> isn't a string seems like a good lesson to remember, though.

[09:40] <masak> sure.

[09:40] <pmichaud> p5 folks are used to thinking that matches return strings... but they don't.

[09:41] <masak> but I don't see why .substr shouldn't treat it like a string.

[09:41] <pmichaud> it's not .substr that was the issue

[09:41] <pmichaud> it was the smartmatch

[09:41] <masak> I still haven't seen the code! :)

[09:41] <pmichaud> and Regex.ACCEPTS(Match)   doesn't necessarily imply "string match"

[09:41] <masak> why would a smartmatch produce a junction?

[09:41] <pmichaud> I don't know about that part yet.

[09:42] <pmichaud>     multi method ACCEPTS(@topic) {

[09:42] <pmichaud>         my Mu $match = any(@topic).match(self);

[09:42] <pmichaud>         pir::store_dynamic_lex__vSP('$/', $match);

[09:42] <pmichaud>         $match

[09:42] <pmichaud>     }

[09:42] <pmichaud> because it thinks it's smartmatching an array

[09:42] <masak> o.O

[09:42] <pmichaud> (because Match does Positional)

[09:42] <masak> oy vey.

[09:42] <pmichaud> so the any() creates the Junction

[09:43] <pmichaud> which then autothreads over .substr

[09:43] <masak> that has to be wrong.

[09:43] <masak> that junction shouldn't leave the method.

[09:44] <pmichaud>   Array     Regex     array "boolean grep"    .any.match(X)

[09:44] <pmichaud> straight out of S03

[09:44] <pmichaud> it returns a junction of match objects.

[09:44] <masak> :'(

[09:44] <JimmyZ> \o Programming Perl, Fourth Edition

[09:44] <pmichaud> I agree it might want some improvement.

[09:44] <pmichaud> we can add an entry for  Regex.ACCEPTS(Match)

[09:45] <pmichaud> which would be tighter than Positional

[09:45] <pmichaud> we can change Regex.ACCEPTS(@topic)  so that it returns a boolean instead of a junction of matches

[09:46] <masak> yes.

[09:46] <pmichaud> none of the other smart match entries return a boolean, though, so I'm not sure that's right.

[09:47] <pmichaud> I also suspect the smartmatch operator got confused by the existence of the regex on the right-hand-side, causing it to treat the lhs operand (the match object) as a lvalue to be manipulated

[09:47] <masak> hm.

[09:47] <pmichaud> e.g., as in a substitution.  so there might be a syntactic issue there as well

[09:47] <masak> huh.

[09:48] *** fish|ipad left
[09:49] <pmichaud> ...because ~~   temporarily binds its lhs to  $_,  I'm wondering if the regex match operation is also manipulating $_ somehow.

[09:50] <tadzik> rakudo: "" ?? say 1 !! say 2

[09:50] <p6eval> rakudo 4a6d21: OUTPUT«2␤»

[09:51] <masak> rakudo: say "".so

[09:51] <p6eval> rakudo 4a6d21: OUTPUT«Bool::False␤»

[09:53] <masak> JimmyZ: that's quite witty. took me a while to get, though :)

[09:53] <JimmyZ> masak: Hehe

[09:54] <pmichaud> omg it's 5am

[09:56] <pmichaud> http://gist.github.com/1021390   # \o/

[09:56] <masak> \o/

[09:56] <masak> reimplementing Rakudo means feeling joy about the simple things again ;)

[09:57] <pmichaud> yeah, I can use some of that these days :)

[09:57] <pmichaud> but even master can be fun:

[09:57] <pmichaud> rakudo:  my @t;  @t[0][2] = @t[0][0] = 5;  say @t[0].perl;

[09:57] <p6eval> rakudo 4a6d21: OUTPUT«[Any, Any, 5]␤»

[09:57] <pmichaud> hmm, not updated yet.  works in current master.

[09:57] <masak> ooh

[09:57] <pmichaud> oh, maybe I forgot to push.

[09:57] <masak> that could explain it.

[09:58] <pmichaud> no, I pushed

[09:58] <pmichaud> pmichaud@kiwi:~/master$ ./perl6

[09:58] <pmichaud> > my @t; @t[0][2] = @t[0][0] = 5;  @t[0].perl.say

[09:58] <pmichaud> [5, Any, 5]

[09:58] <pmichaud> > 

[09:58] <masak> \o/

[09:59] *** whiteknight joined
[10:04] *** lumi_ left
[10:04] *** lumi_ joined
[10:05] <dalek> rakudo/nom: a7476b2 | pmichaud++ | src/Perl6/Actions.pm:

[10:05] <dalek> rakudo/nom: Update variable interpolation in string literals for 6model version of strings.

[10:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a7476b2183

[10:05] <dalek> rakudo/nom: 08ac96b | pmichaud++ | src/ops/perl6.ops:

[10:05] <dalek> rakudo/nom: Allow Routine objects to associate with Parrot Coroutines as well as Subs.

[10:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08ac96b356

[10:17] <moritz> pmichaud++

[10:18] <dalek> nqp: 6a0f778 | pmichaud++ | / (3 files):

[10:18] <dalek> nqp: Make a common set of pir constants available.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6a0f7782c8

[10:18] <dalek> nqp: ce077cd | pmichaud++ | src/stage0/ (6 files):

[10:18] <dalek> nqp: Update bootstrap to get built-in includes.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ce077cdf91

[10:18] <dalek> nqp: 9d5b199 | pmichaud++ | src/PAST/Compiler-Regex.pir:

[10:18] <dalek> nqp: Convert first set of .CCLASS_* constants to remain symbolic in generated PIR.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9d5b199d38

[10:18] <dalek> nqp: c1aa27f | pmichaud++ | src/PAST/Compiler-Regex.pir:

[10:18] <dalek> nqp: Eliminate final .CCLASS_* non-symbol constants in regex code gen.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c1aa27f664

[10:18] <dalek> nqp: 67d1c79 | pmichaud++ | src/NQP/ (2 files):

[10:18] <dalek> nqp: Add pir::const::CONSTANT to NQP.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/67d1c79d02

[10:18] <dalek> nqp: 285bf9f | pmichaud++ | src/stage0/ (6 files):

[10:18] <dalek> nqp: Update bootstrap to enable pir::const:: constants in NQP sources.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/285bf9fdbb

[10:18] <dalek> nqp: 8adbe89 | pmichaud++ | src/HLL/Compiler.pm:

[10:18] <dalek> nqp: Update some pir constants to use pir::const:: instead of Q:PIR.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8adbe89c5b

[10:18] <dalek> nqp: c4d0afb | pmichaud++ | src/HLL/Grammar.pm:

[10:18] <dalek> nqp: Remove more extraneous .include's.

[10:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4d0afb38e

[10:19] <masak> \o/

[10:19] <pmichaud> afk, sleep -- bbiaw

[10:31] <masak> <TimToady> me?  I just hang out here and kibbitz...

[10:32] <masak> cracks me up every time that happens :P

[10:33] <masak> I guess TimToady gets some satisfaction from doing that kind of Henry V move, too...

[10:33] <sbp> heh

[10:40] *** awoodland joined
[10:43] *** dju joined
[10:46] *** dju left
[10:47] *** sftp_ left
[10:47] *** dju joined
[10:48] *** lumi_ left
[10:48] *** lumi_ joined
[10:55] <jnthn> afternoon, #perl6

[10:55] <masak> o/

[10:56] <JimmyZ> afternoon, jnthn

[11:11] *** awoodland left
[11:12] <masak> 下午好, JimmyZ 

[11:12] *** Guest4182 is now known as perplexa

[11:12] *** perplexa left
[11:12] *** perplexa joined
[11:24] <JimmyZ> 下午好，masak

[11:41] <daniel-s> hugme: hug someone

[11:41] * hugme hugs someone

[11:41] *** dju left
[11:41] *** dju joined
[11:41] *** dju left
[11:41] *** dju joined
[11:42] <masak> mystery hug!

[11:43] <daniel-s> hugme: hug masak

[11:43] * hugme hugs masak

[11:45] * masak beams

[11:47] * moritz beams masak into hacking mode

[11:48] <masak> moritz: I"m sorry, today is more or less full of $dayjob... :/

[11:52] <moritz> masak: no worries, happens to all of use

[11:52] *** lumi_ left
[11:52] <masak> I'd love to hack, but I need to get this out of the way first.

[11:53] *** lumi_ joined
[11:53] <masak> can't even complain about $work intruding on the weekend... I've have weeks to prepare this, but I saved it for the last minute. :)

[11:58] *** jaldhar left
[11:58] *** jaldhar joined
[12:14] <daniel-s> phenny, tell daniel-s hi

[12:14] <phenny> You can tell yourself that.

[12:14] *** Mowah left
[12:16] *** huycwork_ joined
[12:17] *** daniel-s is now known as daniel-s_1

[12:17] *** huycwork left
[12:17] *** daniel-s_1 is now known as daniel-s

[12:19] *** daniel-s is now known as daniel-s_

[12:19] *** daniel-s_ is now known as daniel-s

[12:23] *** daniel-s left
[12:25] *** mj41 joined
[12:26] *** kaare_ joined
[12:32] *** mj41 left
[12:35] *** daniel-s joined
[12:36] <daniel-s> what does the >>. do?

[12:36] *** Moukeddar joined
[12:36] <daniel-s> @modules>>.*noticed($event)

[12:36] <masak> daniel-s: it distributes the method calls over all of the elements.

[12:36] <flussence> like map { $_.noticed($event) } @modules

[12:36] <flussence> but different

[12:37] <masak> rakudo: my @a = 1, 2, 3; my @b = @a>>.exp(); say @b.perl

[12:37] <p6eval> rakudo ae5bea: OUTPUT«[2.71828182845905, 7.38905609893065, 20.0855369231877]␤»

[12:37] <daniel-s> so in this case, @modules is a while bunch of classes, some of which may have the noticed() method

[12:38] <daniel-s> it's calling every method of every class (if there is one) that's called noticed()?

[12:38] <masak> or have several, through inheritance.

[12:38] <daniel-s> ok, thanks

[12:38] <masak> the * makes it look up the MRO chain.

[12:39] <daniel-s> MRO?

[12:39] <masak> method resolution order

[12:40] <masak> rakudo: class A { method x { "A" } }; class B is A { method x { "B" } }; class C {}; my @a = A.new, B.new, C.new; my @b = @a>>.*x; say @b.perl

[12:40] <p6eval> rakudo ae5bea: OUTPUT«["A", "B", "A"]␤»

[12:40] <masak> \o/

[12:40] <masak> the first "A" comes from the A.new instance. the "B" and the "A" come from B.new. C.new leaves no trace.

[12:41] <masak> jnthn++!

[12:41] *** lumi_ left
[12:42] *** hudnix joined
[12:42] *** lumi_ joined
[12:42] <flussence> (I totally didn't notice the .* part there... still not fully awake :)

[12:44] <masak> the .? .+ .* are a stroke of genius, IMO. they are strangely consistent with regex quantifiers. and they put the focus on inheritance hierarchies in a good way.

[12:45] *** Chillance joined
[12:46] <TiMBuS> masak, probably one of the best features in perl6 imo

[12:47] <daniel-s> oh, forgot: masak++

[12:48] <daniel-s> http://pastebin.com/3dmaZXCp much easier to read than masak's example just now

[12:49] <masak> TiMBuS: yes, I agree.

[12:49] <masak> TiMBuS: imagine how ugly it'd look if method invocation were still ->

[12:49] <masak> :)

[12:49] <TiMBuS> ack

[12:49] <flussence> rakudo: class A {}; A.?b(); A.c();

[12:49] <p6eval> rakudo ae5bea: OUTPUT«Method 'c' not found for invocant of class ''␤  in main program body at line 22:/tmp/n8_ySNGQBc␤»

[12:49] <flussence> ooh

[12:49] <masak> yeah.

[12:49] <daniel-s> @a>>->*x;

[12:49] <TiMBuS> when i saw .? i was amazed. imagine if javascript had it for walking around DOM nodes

[12:50] <TiMBuS> instead of checking for null over and over

[12:50] <flussence> imagine if javascript had it for *anything*...

[12:50] <masak> TiMBuS: coffeescript has it, I bet.

[12:50] <Moukeddar> Hello Perlers

[12:50] <masak> Moukeddar! \o/

[12:50] <Moukeddar> my hero :)

[12:51] <Moukeddar> what's up?

[12:52] <masak> we were just praising the extreme suitability of .? and .+ and .* in Perl 6.

[12:53] <masak> rakudo: class A {}; class B { method hi { say "OH HAI" } }; A.new.?hi; B.new.?hi;

[12:53] <p6eval> rakudo ae5bea: OUTPUT«OH HAI␤»

[12:56] <Moukeddar> perl always freaks me with it's statements :)

[12:56] <masak> how so?

[12:56] <JimmyZ> I guess you are saying perl 5?

[12:56] <masak> I mean, we're all freaked, but in different ways... :)

[12:57] <Moukeddar> like that one you mentioned before

[12:57] <masak> it's really pretty straightforward.

[12:57] <masak> it's like A.new.hi, but with an extra ? thrown in.

[12:57] <Moukeddar> A doesn't inherit B , still it can access its methods

[12:57] <masak> oh no no

[12:57] <masak> that's not what's happening.

[12:58] <JimmyZ> rakudo: class A {}; class B { method hi { say "OH HAI" } }; A.new.?hi;

[12:58] <p6eval> rakudo ae5bea:  ( no output )

[12:58] <masak> A.new.?hi doesn't find any method, but instead of dying, the program just carries on.

[12:58] <masak> thanks to the .?

[12:58] <JimmyZ> rakudo: class A {}; class B { method hi { say "OH HAI" } }; A.new.?hi;

[12:58] <p6eval> rakudo ae5bea:  ( no output )

[12:58] <masak> it's B.new.?hi that finds a method.

[12:58] <daniel-s> TiMBuS: in the Net::IRC::Bot module, when a callback sends something to the channel, I'm using $e.conn.sendln() and sending raw IRC

[12:58] <JimmyZ> no output

[12:59] <daniel-s> is there an easier way of doing simpler things like sending messages to a channel or user?

[12:59] <TiMBuS> woah. woah. someone uses my module??

[12:59] <masak> :D

[12:59] <TiMBuS> use $event.say()

[12:59] <TiMBuS> the event has the context of the event so, it can just reply

[12:59] <masak> TiMBuS: oh, the '@modules>>.*noticed($event)' line was from your module? :)

[12:59] <masak> that explains it :)

[13:00] <TiMBuS> so it was!

[13:00] <masak> then it's no coincidence that you also like .* et al. :P

[13:00] <TiMBuS> i used perls native dispatch to avoid hobbling together yet another event based system

[13:00] <masak> \o/

[13:00] <masak> TiMBuS: I've used it for the exact same thing. in Yapsi.

[13:01] <Moukeddar> so , ? prevents exceptions?

[13:01] <masak> Moukeddar: yes, it makes it OK not to find the method.

[13:02] <TiMBuS> daniel-s, oh my bad its $event.msg("Reply text") my bad

[13:02] <masak> Moukeddar: .* and .+ are more about inheritance, like you assumed.

[13:02] <Moukeddar> uhm , like nullable types ? , like saying it's ok if it isn't found ?

[13:02] <TiMBuS> not .say

[13:02] <masak> Moukeddar: yes, there's a parallel.

[13:02] <TiMBuS> it would have been .say but perl has that as a keyword so

[13:02] <daniel-s> oh yea, thanks, I was about to say, because my bot just pooped itself

[13:02] <Moukeddar> interesting thing that you implemented that :)

[13:03] <TiMBuS> also daniel-s if you have any suggestions for features, please ask

[13:03] <daniel-s> no problem

[13:03] <TiMBuS> or if you have any design ideas

[13:04] <daniel-s> also, I'm not really the only person who uses it

[13:04] <daniel-s> ?

[13:04] <TiMBuS> not sure

[13:04] <TiMBuS> but i can say its probably not more than a handful of people

[13:04] *** wamba left
[13:04] <masak> rakudo: class A { method x { "life is like a dream" } }; class B is A { method x { "merrily " x 4 } }; class C is B { method x { "row " x 3 ~ " your boat" } }; say C.new.+x.join("\n")

[13:04] <p6eval> rakudo ae5bea: OUTPUT«row row row  your boat␤merrily merrily merrily merrily ␤life is like a dream␤»

[13:05] <masak> oh! "gently down the stream"!

[13:05] <TiMBuS> that ok. just insert it as a role with the decorator pattern

[13:05] <masak> rakudo: class A { method x { "life is like a dream" } }; class B is A { method x { "merrily " x 4 } }; class C is B { method x { "gently down the stream" } }; class D is C { method x { "row " x 3 ~ "your boat" } }; say C.new.+x.join("\n")

[13:05] <p6eval> rakudo ae5bea: OUTPUT«gently down the stream␤merrily merrily merrily merrily ␤life is like a dream␤»

[13:05] *** Bzek_ joined
[13:05] <masak> g'ah! :)

[13:05] <masak> rakudo: class A { method x { "life is like a dream" } }; class B is A { method x { "merrily " x 4 } }; class C is B { method x { "gently down the stream" } }; class D is C { method x { "row " x 3 ~ "your boat" } }; say D.new.+x.join("\n")

[13:05] <p6eval> rakudo ae5bea: OUTPUT«row row row your boat␤gently down the stream␤merrily merrily merrily merrily ␤life is like a dream␤»

[13:06] <Moukeddar> lol

[13:07] <masak> TiMBuS: I did it with 'nextsame' last advent calendar: http://perl6advent.wordpress.com/2010/12/14/day-14-nextsame-and-its-cousins/

[13:07] <Moukeddar> loved the x for repitition

[13:07] <masak> Moukeddar: there's also xx for repeating things in lists

[13:07] <TiMBuS> yeah i read that and linked it on a few forums. quite nice

[13:07] <masak> rakudo: say ("Moukeddar" xx 5).perl

[13:07] <p6eval> rakudo ae5bea: OUTPUT«("Moukeddar", "Moukeddar", "Moukeddar", "Moukeddar", "Moukeddar")␤»

[13:07] <Moukeddar> i'm being cloned

[13:08] *** lumi_ left
[13:08] <masak> Moukeddar: in Perl 5, both x and xx are called x, and it all depends on context.

[13:08] <Moukeddar> like?

[13:08] <masak> Moukeddar: "Moukeddar" x 5 would be string cloning, but ("Moukeddar") x 5 is list cloning in Perl 5.

[13:08] <daniel-s> TiMBuS: on here: https://github.com/TiMBuS/Net--IRC/ where you give a little example

[13:08] <daniel-s> there's this line: modules = (AnnoyUsers.new(), Autoident.new(password => 'nspassw0rd')),

[13:08] <Moukeddar> i understand

[13:08] <TiMBuS> yep

[13:09] <masak> Moukeddar: there's a lot of that kind of context in Perl 5.

[13:09] <daniel-s> is it supposed to be module =>

[13:09] *** lumi_ joined
[13:09] <Moukeddar> YAY Perl :)

[13:09] <TiMBuS> it is!

[13:09] <daniel-s> ie. "=>" instead of "="

[13:09] <TiMBuS> good catch

[13:10] *** furryfishy left
[13:10] *** buubot_backup left
[13:10] *** Trashlord left
[13:10] *** Bzek left
[13:10] *** tomaw left
[13:10] <masak> Moukeddar: I wrote a blog post of how I learned about that kind of context, if you're interested: http://strangelyconsistent.org/blog/the-taming-of-the-newbie-a-comedy-on-irc

[13:11] <TiMBuS> oh man i just saw my code again for the bots default nicknames. still proud of it

[13:11] <Moukeddar> lol , the title is hilarious

[13:11] <TiMBuS> has $nick     = "Rakudobot";

[13:11] <TiMBuS> has @altnicks = $nick X~ ("_","__",^10);

[13:11] <masak> Moukeddar: yeah. I was the newbie :)

[13:11] *** PhatEddy joined
[13:12] <Moukeddar> you?

[13:12] <masak> just read it, and you'll see :)

[13:12] <masak> TiMBuS: nice!

[13:13] <masak> TiMBuS: don't forget the backticks, too!

[13:13] <PhatEddy> perl6: class A {has $.a}; class B is A {}; my A $a .= new; my A $b = $a.clone

[13:13] <p6eval> niecza v6-150-g612a7b7: OUTPUT«Unhandled exception: Unable to resolve method clone in class A␤  at /tmp/o_bXafFnFM line 1 (MAIN mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1769 (CORE C837_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1770 (CORE module-CORE @ 57) ␤  at

[13:13] <p6eval> ../home/p6eval/n…

[13:13] <p6eval> ..pugs, rakudo ae5bea:  ( no output )

[13:13] <daniel-s> <PerlJam> masak: clearly you are insane.

[13:13] <daniel-s> haha

[13:13] <masak> ;)

[13:13] <PhatEddy> perl6: class A {has $.a}; class B is A {}; my A $a .= new; my B $b = $a.clone

[13:14] <p6eval> niecza v6-150-g612a7b7: OUTPUT«Unhandled exception: Unable to resolve method clone in class A␤  at /tmp/RAfNrn9P4e line 1 (MAIN mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1769 (CORE C837_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1770 (CORE module-CORE @ 57) ␤  at

[13:14] <p6eval> ../home/p6eval/n…

[13:14] <p6eval> ..pugs:  ( no output )

[13:14] <p6eval> ..rakudo ae5bea: OUTPUT«Type check failed for assignment␤    Container type: B␤               Got: A␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/NzzSrQsztG␤»

[13:14] <masak> the adjoining Hacker News discussion was quite enlightening, too: http://news.ycombinator.com/item?id=1064622

[13:15] <PhatEddy> Anyone about can suggest a way for me to do that second example w. rakudo?

[13:15] <masak> lots of FP people thinking Perl is insane for not seeing that strings are really lists :P

[13:15] <masak> PhatEddy: provide a 'method B' in the A class, and then fo 'my B $b = $a.B'.

[13:16] <masak> PhatEddy: an A is not a B, so you can't explain to store it in a variable typed as B.

[13:16] <Moukeddar> i think context behavior makes things more complex

[13:17] *** Mowah joined
[13:20] <masak> Moukeddar: I think I know what you mean.

[13:20] <masak> Moukeddar: some Perl 5 programmers might disagree, though. saying "it's easy once you've learned it".

[13:20] *** tomaw joined
[13:20] <masak> but that's true of surgery and windsurfing too.

[13:21] *** Trashlord joined
[13:21] <masak> Trashlord! \o/

[13:21] <Moukeddar> lol,

[13:21] <PhatEddy> masak: hmmm ... thanks but that is just an example  and your solution doesn't quite cover what I actually want done - will explain in moment.

[13:22] <Moukeddar> well , i find it just like context in an English conversation

[13:22] <masak> PhatEddy: ok.

[13:22] <masak> Moukeddar: right.

[13:22] <Su-Shee> as someone from the humanities department I've always found "context" totally intuitive. in fact, how could something NOT be dependent on that? :)

[13:22] <PhatEddy> rakudo: grammar g {token TOP {:i a}}; class lc_Match is Match { method Str { self.Match::Str.lc }; method orig { self.Match::Str } };  if g.parse('A') {say 'OK'; my lc_Match $lc = $/.clone; say 'something'} else {say 'no match'}

[13:22] <p6eval> rakudo ae5bea: OUTPUT«OK␤»

[13:22] *** buubot_backup joined
[13:22] <PhatEddy> notice (think its a bug) that something never show up

[13:22] <masak> Moukeddar: Perl 5 is very influenced by things from natural languages. some things worked out fine, others less so.

[13:23] <Moukeddar> indeed

[13:23] <masak> PhatEddy: ah, you don't own the A class in this case. I see.

[13:23] <PhatEddy> right

[13:23] <Moukeddar> i mean , the whole context idea , i find it pretty innovative

[13:24] <masak> PhatEddy: well, the restriction still holds. Match is not an lc_Match, so you can't store it in an lc_Match container.

[13:24] <masak> Moukeddar: in the case of 'reverse', you only have to learn one new builtin, and it does two things for you.

[13:24] <masak> Moukeddar: so in a sense, it "saves space" in the brain.

[13:24] <masak> maybe. :)

[13:25] <Moukeddar> if there's a space already :p

[13:25] <masak> yes, it's dangerous to talk about the brain as a hard drive, I know.

[13:25] <masak> it's much more holographic than that :)

[13:26] <masak> Moukeddar: one place where Perl 5 really messed up is in the conversion from lists to scalars. there are like three different ways that Perl 5 does that, and one has to learn when each one applies.

[13:26] <Moukeddar> oh dear,

[13:26] <masak> sometimes the list becomes the length of the list. sometimes it becomes the last element of the list. sometimes it becomes the stringification of all the elements.

[13:27] <Moukeddar> isn't there some helper classes or methods to help deal with this mess , and specify exactly when to use each case?

[13:28] <Moukeddar> and btw , you're pretty good at writing :)

[13:30] <Moukeddar> the other day i started with design patterns , and i've found that i've been using many of them without knowing it , feels foolish

[13:31] <masak> most of use recognize the patterns as something we've had contact with even before we knew their names.

[13:31] <masak> it's like monads. you could have invented them. :)

[13:32] <masak> (and probably have)

[13:35] <PhatEddy> masak: don't you think that restriction make it difficult to extend internal classes and libraries?  I will continue to poke around looking for some kind of solution.

[13:35] <Moukeddar> monads?

[13:35] <Trashlord> masak: hey :)

[13:36] <Moukeddar> all praise the Trashlord

[13:36] <masak> PhatEddy: it's not an restriction particular to Perl 6. that's how strict typing works.

[13:36] <PhatEddy> thx

[13:37] <masak> PhatEddy: the only way your example could work would be if there were some implicit narrowing casting being done in the background. there isn't.

[13:37] <gfldex> PhatEddy: change "my lc_Match $lc

[13:37] <gfldex> " to my $lc"

[13:37] <Moukeddar> masak, i have one more request , is there some kind of dictionary for the main keywords in this field (programming and designing)

[13:37] <Moukeddar> ex : Model , entity , behavior , etc

[13:37] <masak> Moukeddar: monads exist in Haskell to preserve a central feature called "referential transparency", which means that functions never have visible side effects.

[13:37] <gfldex> PhatEddy: if you dont want strict types, dont use them

[13:38] <masak> Moukeddar: no, you just have to read a lot of stuff until it starts making sense. Wikipedia and c2.com help a lot, though.

[13:38] <Moukeddar> so , there isn't a specific definition for those words or concepts?

[13:39] <Moukeddar> just reading and watching?

[13:39] <PhatEddy> gfldex: OK, I don't need strict types but I do want a modified Match object that stringifies in lower case and has method to return original match.  BTW - don't know much about strict typing ... :(

[13:39] <masak> Moukeddar: each of those three words you mentioned fire off a certain set of neurons in my brain. but they do that because I've read those words a thousand times by now; it's like a very composite taste experience :)

[13:40] <masak> Moukeddar: so even if you found an excellent dictionary and read through it once, it's not of much use. you need to read it from a lot of angles.

[13:40] <Moukeddar> so , you build your own definition for those words , right?

[13:40] <masak> I guess. one that's fairly close to other people's.

[13:40] <Moukeddar> ok n makes sense :)

[13:41] <gfldex> PhatEddy: that makes sense but .clone is most likely the wrong way to do it.

[13:43] <tadzik> ~~

[13:43] <PhatEddy> gfldex: thx - can you at least point me in the direction of a better/right way

[13:44] <gfldex> PhatEddy: you want a copy constructor or you may want to try a wrapper around the stringify|say method

[13:46] <gfldex> PhatEddy: if I get you right you want to modify the behaviour of an object at runtime. That's what nom is for. :) So for now you will most likely have to cheat.

[13:48] *** hudnix left
[13:51] *** lumi_ left
[13:52] *** lumi_ joined
[13:57] <tadzik> All tests successful.

[13:57] <tadzik> I thought I'll never see this, and will have to leave to my home in the remote village covered in shame

[13:58] <TiMBuS> rakudo: my $match = ("TiMBuS" ~~ /T(...)uS/); $match does role { method Str {return callsame.lc} }; say ~$match

[13:58] <p6eval> rakudo ae5bea: OUTPUT«Null PMC access in clone()␤  in 'Str' at line 1␤  in main program body at line 7674:CORE.setting␤»

[13:59] <TiMBuS> .. uh

[13:59] <TiMBuS> didnt expect that

[13:59] <TiMBuS> rakudo: my $match = ("TiMBuS" ~~ /T(...)uS/); $match does role { method Str {callsame} }

[13:59] <p6eval> rakudo ae5bea:  ( no output )

[14:00] <TiMBuS> .. right

[14:00] <TiMBuS> rakudo: my $match = ("TiMBuS" ~~ /T(...)uS/); $match does role { method Str {callsame} }; say ~$match

[14:00] <p6eval> rakudo ae5bea: OUTPUT«Null PMC access in clone()␤  in 'Str' at line 1␤  in main program body at line 7674:CORE.setting␤»

[14:00] * TiMBuS just walks away

[14:01] <gfldex> rakudo needs more nom:)

[14:01] <PhatEddy> rakudo: grammar g {token TOP {:i a}}; if g.parse('A') {say $/; my $lc = $/.clone; say $/; say 'something'}

[14:01] <p6eval> rakudo ae5bea: OUTPUT«A␤»

[14:04] <gfldex> rakudo: grammar g {token TOP {:i a}}; if g.parse('A') {say $/.^WHAT; say $/.clone.^WHAT; }

[14:04] <p6eval> rakudo ae5bea: OUTPUT«too many positional arguments: 2 passed, 1 expected␤  in main program body at line 22:/tmp/I1_mKd8uAW␤»

[14:05] *** araujo joined
[14:06] <gfldex> rakudo: grammar g {token TOP {:i a}}; if g.parse('A') {say $/.WHAT; say $/.clone.WHAT; }

[14:06] <p6eval> rakudo ae5bea: OUTPUT«Match()␤»

[14:07] *** JokeBot joined
[14:07] <daniel-s> Jokebot: joke please

[14:09] <daniel-s> JokeBot is what I've been working on for the last hour or so

[14:09] <daniel-s> yep, that's right, it's completely useless

[14:09] <TiMBuS> wheee

[14:09] <daniel-s> ..mostly cos all the jokes suck

[14:10] <daniel-s> I wanted to find 1 line ones, so that it could put it in the chat

[14:10] <daniel-s> but they're too long, so it PMs them instead

[14:10] <TiMBuS> daniel-s, check out my acme module

[14:10] <TiMBuS> if you didnt see it

[14:10] <jnthn> JokeBot: joke please

[14:10] <TiMBuS> insert bitcoin for joke

[14:11] <jnthn> that was awful

[14:11] <jnthn> JokeBot: joke please

[14:11] <tadzik> JokeBot: joke please

[14:11] <tadzik> why privmsg?

[14:11] <TiMBuS> JokeBot: joke me

[14:11] <TiMBuS> aw

[14:11] <TiMBuS> JokeBot: joke please

[14:11] <tadzik> JokeBot: joke please

[14:11] <jnthn> tadzik: because they're so bad we don't want to all see them :P

[14:11] <daniel-s> tadzik: because alot of them are too long and I didn't want to flood the chat

[14:12] <jnthn> JokeBot: joke please

[14:12] *** XoDys joined
[14:12] <TimToady> JokeBot: joke hugme

[14:12] <daniel-s> I'll find 1 line ones that it can say in the main chat

[14:12] *** XoDys left
[14:12] <colomon> JokeBot: joke please

[14:12] *** JokeBot left
[14:12] <TimToady> hugme: hug jokebot

[14:12] * hugme hugs jokebot

[14:12] <daniel-s> yea, they're too long

[14:12] <TiMBuS> but it works!!

[14:12] <daniel-s> you killed my bot

[14:12] <TiMBuS> lmao

[14:12] <tadzik> phenny: tell JokeBot joke please

[14:12] <phenny> tadzik: I'll pass that on when JokeBot is around.

[14:13] <jnthn> lol

[14:14] <daniel-s> I'll find out what the flood limits for freenode are and slow it down

[14:14] <TiMBuS> oooh thats what i need to do with my module. throttling.

[14:15] <TiMBuS> and unrelated: the state hash sucks. ill make it an object

[14:16] <daniel-s> I needed to use: "use Net::IRC::Modules::Autoident;"

[14:16] <daniel-s> instead of "use Modules::Autoident;"

[14:16] <daniel-s> because of where it is in the heirarchy

[14:16] <daniel-s> is that correct?

[14:16] <daniel-s> it worked anyway

[14:16] <TiMBuS> thats likely

[14:17] <TiMBuS> ive had to move things around a bit

[14:18] <TiMBuS> Net::IRC::Modules::Autoident argh that is so long to type D:

[14:19] <TiMBuS> stupid me for picking a perl5 name

[14:22] <TiMBuS> daniel-s, if you think of any cool modules, write them and ill put them into the modules folder :D

[14:23] <TiMBuS> reminder: perl6 has no threads or async IO so watch out if you make a bot do anything that pauses for too long (like the twitter module i gave up on)

[14:23] <daniel-s> because it won't respond with pongs?

[14:23] <TiMBuS> even if it did have async IO id need to make a callback handler and oh man.. thats like 10 lines more code ._.

[14:24] <TiMBuS> yeah itll time out

[14:24] <tadzik> I don't understand. I added more tests, and this still works

[14:24] <TiMBuS> lol

[14:27] *** envi_laptop left
[14:31] <masak> dang, I missed the JokeBot. :)

[14:31] <tadzik> ;)

[14:35] *** awwaiid joined
[14:36] <pmichaud> good morning, #perl6

[14:38] <tadzik> good morning pmichaud

[14:38] *** MayDaniel joined
[14:39] <jnthn> hi, pmichaud 

[14:41] *** lumi_ left
[14:42] *** lumi_ joined
[14:45] <masak> good morning, pmichaud.

[14:45] <tadzik> I think S26 is at least partly wrong. S26:821 says "This is yet another ordinary paragraph", but S26:51 says "An indented Pod block is considered to have a I<virtual left margin>, determined by the indentation of its opening delimiter". So the "ordinary paragraph" has a virtual left margin, so it's a code block, am I right?

[14:47] *** donri joined
[14:47] * masak goes and reads those two bits

[14:47] <tadzik> thank you, my mentor

[14:48] <masak> tadzik: let's see that we agree on this: the paragraph at S26:821 is an "ordinary paragraph" because it has the same indentation as the heading at S26:819. yes?

[14:49] *** JokeBot joined
[14:49] <tadzik> I think that's what it tries to say, yes

[14:50] <daniel-s> JokeBot: joke

[14:50] <masak> tadzik: good.

[14:50] <JokeBot> Worrying works! 90% of the things I worry about never happen.

[14:50] <phenny> JokeBot: 14:12Z <tadzik> tell JokeBot joke please

[14:50] <tadzik> but the code block description states:

[14:50] <masak> tadzik: so even "ordinary paragraph" blocks have a virtual margin. but it must be 1.

[14:50] <tadzik> A code block may be implicitly specified as one or more lines of text, each of which starts with a whitespace character at the block's virtual left margin.

[14:51] <masak> nod.

[14:51] <tadzik> masak: I think the previous ones have a margin of zero, or ""

[14:51] <masak> I don't see a conflict.

[14:51] <tadzik> while the last one has a margin of 4, or "    "

[14:51] <masak> directives (things that start with '=') set the "current margin baseline".

[14:52] <tadzik> so that's where we disagree

[14:52] <masak> when TheDamian says "virtual margin of 1", he seems to mean "on the current margin baseline".

[14:52] <masak> so he's 1-based.

[14:52] <masak> (as column numbers tend to be, I guess)

[14:52] <tadzik> again: An indented Pod block is considered to have a I<virtual left margin>, determined by the indentation of its opening delimiter

[14:52] <tadzik> and the opening delimiter is =begin pod, 4 spaces to the left

[14:52] <tadzik> not the =head1

[14:53] <tadzik> oh, I think I see your point

[14:53] <masak> I don't get it. show with a nopaste?

[14:53] <tadzik> but again, if it has the virtual margin, it's a code block, not an ordinary paragraph

[14:53] <masak> your use of "virtual margin" confuses me.

[14:53] <tadzik> masak: I'll gimp it for you for the visual experience

[14:53] <masak> everything "has a virtual margin", and it's a number.

[14:55] <masak> the virtual margin is just the regular margin minus the current margin baseline ( plus an off-by-one because we're one-based).

[14:58] <tadzik> masak: see http://i.imgur.com/dhljt.png

[14:58] * masak looks

[14:59] <masak> tadzik: you just made a picture where you pretended that the =head2 isn't there. what's up with that? :)

[15:00] <masak> I explicitly pointed it out to you first thing I did in this discussion...

[15:00] <tadzik> masak: because it isn't. It doesn't open a block

[15:00] <masak> "This is another heading block"

[15:00] <tadzik> "=head2 This is another heading block". Yep, and it ends

[15:00] <tadzik> with a blank line below it

[15:00] <tadzik> that's how abbreviated blocks work

[15:00] <masak> and in the process, it set a new baseline margin, no?

[15:01] <tadzik> nope. The opening delimiter sets the margin. The =head2 doesn't open anything, or if it does, it ends immediately

[15:01] <tadzik> the last paragraph belongs to the toplevel =begin pod (imaginary), not to =head2 nor =head1

[15:01] <masak> fine, I hear you.

[15:01] <masak> what's the basis for this in S26?

[15:01] <tadzik> S26:51

[15:02] <masak> ok, right.

[15:02] <masak> yes, I see now what you mean.

[15:02] <masak> S26:819 does set a new baseline, but it's immediately re-set to the old one because it was an abbreviated block.

[15:02] <tadzik> yes

[15:03] <masak> I now agree with your interpretation.

[15:03] <masak> did you email TheDamian already with some other question?

[15:03] <masak> because this feels like one he could resolve if you emailed him about it.

[15:03] <tadzik> nope, I took your point yesterday

[15:03] <masak> (with the picture and the explanation)

[15:04] <tadzik> I will, thanks

[15:04] <masak> I'm very happy that you're running into these things.

[15:04] <tadzik> I'll commit my code and tests now so you can look into it

[15:04] <masak> it's model crunching. :)

[15:04] <masak> no wait, "model churn" is the term.

[15:05] <pmichaud> what about S26:135 -- does that apply?

[15:05] <tadzik> I'm unfamiliar with it either way :)

[15:05] * tadzik looks

[15:06] <tadzik> pmichaud: the only content of the =head2 block is the "This is another heading block". It's then ended by a blank line

[15:06] <masak> pmichaud: the "Unlike Perl 5..." part?

[15:06] <pmichaud> masak: yes

[15:06] <tadzik> oh, this thingy

[15:07] <tadzik> well, I assume that if the pod examples in S26 are not delimited with anything, they're delimited with =begin pod and =end pod

[15:07] <pmichaud> in tadzik's png example, the indented text isn't within =pod, =nested, or =item, so it's not a code block

[15:07] <masak> pmichaud: I think it's assumed that S26:821 is within a... what tadzik said. :)

[15:08] <masak> it has to be within something for it to be Pod.

[15:08] <tadzik> masak: commits pushed

[15:08] <masak> and then =pod is sort of the natural assumption.

[15:08] <masak> er, =begin pod

[15:08] *** JokeBot left
[15:09] *** dju_ joined
[15:09] <tadzik> whoops, debugging code left

[15:10] <masak> how embarassing. :)

[15:10] <tadzik> luckily it's not swearing

[15:11] <masak> s/r/rr/

[15:11] <tadzik> swearring?

[15:12] *** dju left
[15:12] <masak> yarr

[15:13] <masak> no, I had to look up the spelling of "embarrassing", because it looked rong. :)

[15:13] <jnthn> masak: swearring? wtfffffff?

[15:13] <jnthn> :)

[15:17] <daniel-s> I've noticed I've been doing this alot when I'm opening a file

[15:17] <daniel-s> http://pastebin.com/GCgXzUgL

[15:17] <daniel-s> is there a shorter way of doing the same thing?

[15:17] <jnthn> my @jokes = lines("jokes.txt")

[15:18] <daniel-s> awesome, thanks jnthn++

[15:22] *** MayDaniel left
[15:22] *** lumi_ left
[15:22] <masak> shouldn't that be lines("jokes.txt".IO) ?

[15:23] *** lumi_ joined
[15:24] <masak> S32/Str:395 seems to indicate lines(Str) works on the string, not on the contents of a file with that name.

[15:25] *** daniel-s left
[15:25] <masak> rakudo: say lines("Joke 1: not very funny\nJoke 2: a little funny\nJoke 3: extremely funny").perl

[15:25] <p6eval> rakudo ae5bea: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/lX9HijKmp9␤  in 'lines' at line 5929:CORE.setting␤  in main program body at line 22:/tmp/lX9HijKmp9␤»

[15:25] <masak> ...but Rakudo seems to be lagging.

[15:25] * masak submits rakudobug :)

[15:27] <dalek> rakudo/nom: ab08e61 | jnthn++ | src/ (6 files):

[15:27] <dalek> rakudo/nom: Move array and hash and dependencies partially into the BOOTSTRAP, so we can use them in declarative situations in the setting.

[15:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ab08e61b33

[15:27] <dalek> rakudo/nom: d615b4f | jnthn++ | src/ (7 files):

[15:27] <dalek> rakudo/nom: Slurpy array and hash arguments. Also should mean optional array and hash parameters work again.

[15:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d615b4ff92

[15:33] *** huycwork_ left
[15:35] <tadzik> masak: http://wklej.org/id/545230/ wouldn't that fix your fresh ticket?

[15:39] <masak> tadzik: well, there also needs to be a lines(Str) that DTRT in its place.

[15:39] <masak> but it's a good start. :) the first half.

[15:40] <masak> actually, you're probably right in that it satisfies the letter of the ticket.

[15:50] <tadzik> there is one

[15:50] <tadzik> masak: https://github.com/rakudo/rakudo/blob/master/src/core/Cool-str.pm#L488

[15:52] <masak> might need to 'is export' that one to get the sub.

[15:53] <tadzik> oic

[15:53] <dalek> rakudo/nom: 9b7d574 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[15:53] <dalek> rakudo/nom: Accidentally busted my '@a; @a[0] = ...' a couple of commits ago; this fixes it.

[15:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9b7d5746ac

[15:54] <tadzik> maybe we need some nomtests for regressions like this one?

[15:54] <jnthn> tadzik: We may even have some, if only I ran them... :)

[15:54] <tadzik> ;)

[15:55] * jnthn should make an effort to get at least t/00-parrot running consistently

[15:56] <masak> jnthn: if that wasn't a branch, not running the tests would be an offense meriting karma withdrawal.

[15:56] <masak> (but keep up the good work!) :P

[15:56] <jnthn> masak: :P

[15:57] <jnthn> It looks like we're dangerously close to passing all of 08-var-array.t

[15:57] <tadzik> horray!

[15:58] <jnthn> ooh

[15:58] <jnthn> I guess say can use slurpies now

[15:58] <jnthn> That probably gets us more tests.

[15:59] <tadzik> what does it use now, arrays?

[15:59] <jnthn> tadzik: a hack :)

[15:59] <tadzik> :P

[16:01] * jnthn tries it

[16:04] *** molaf joined
[16:05] *** hudnix joined
[16:09] <jnthn> Setting things that'd get us more of 00-parrot and 01-sanity: ++ (prefix and postfix), .Str on Array

[16:09] <dalek> rakudo/nom: c0312cd | jnthn++ | src/core/IO.pm:

[16:09] <dalek> rakudo/nom: Use slurpies for print and say now we have them.

[16:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c0312cdc96

[16:10] <tadzik> I may get on it in a sec

[16:11] *** lumi_ left
[16:11] <sorear> good * #perl6

[16:11] *** lumi_ joined
[16:11] <tadzik> good * sorear

[16:17] *** fish|ipad joined
[16:17] *** felipe joined
[16:19] *** fish|ipad left
[16:20] *** fish|ipad joined
[16:20] *** fish|ipad left
[16:20] *** fish|ipad joined
[16:20] *** wamba joined
[16:25] *** thou joined
[16:27] <JimmyZ> rakudo: class what is Cool { ... }; say so what;

[16:27] *** ymasory joined
[16:27] <p6eval> rakudo ae5bea: OUTPUT«Bool::False␤»

[16:30] <dalek> rakudo/nom: 8f7a0ac | jnthn++ | src/Perl6/ (2 files):

[16:30] <dalek> rakudo/nom: Get our-scoped subs working again.

[16:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8f7a0acc44

[16:30] * moritz has seen zebras today

[16:30] <JimmyZ> rakudo: class what is Cool { ... }; say so what.WHAT; #bug?

[16:30] <p6eval> rakudo ae5bea: OUTPUT«Null PMC access in find_method('handled')␤  in 'prefix:<?>' at line 1␤  in 'prefix:<so>' at line 599:CORE.setting␤  in main program body at line 22:/tmp/5rLOHZ546o␤»

[16:30] <JimmyZ> rakudo: class what is Cool { ... }; say so Cool.WHAT;

[16:30] <p6eval> rakudo ae5bea: OUTPUT«Bool::False␤»

[16:31] <jnthn> rakudo: class what is Cool { ... }; say what.WHAT

[16:31] <p6eval> rakudo ae5bea: OUTPUT«Failure()␤»

[16:31] <jnthn> nom: class what is Cool { ... }; say what.WHAT

[16:31] <p6eval> nom: OUTPUT«The following packages were stubbed but not defined:␤    what␤␤current instr.: 'nqp;Perl6;SymbolTable;assert_stubs_defined' pc 2767 (src/gen/perl6-symboltable.pir:778)␤»

[16:31] <jnthn> nom++ :)

[16:31] <moritz> that is a Failure indeed :-)

[16:32] <JimmyZ> nom: class what is Cool { ... }; say Cool.WHAT

[16:32] <p6eval> nom: OUTPUT«The following packages were stubbed but not defined:␤    what␤␤current instr.: 'nqp;Perl6;SymbolTable;assert_stubs_defined' pc 2767 (src/gen/perl6-symboltable.pir:778)␤»

[16:32] <jnthn> JimmyZ: Stubbing a package and not defining it is a compile time error.

[16:32] <jnthn> std:  class what is Cool { ... }; say Cool.WHAT

[16:32] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'Cool' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[16:33] <jnthn> er...that wasn't the error I was expecting. :)

[16:33] <jnthn> std:  class what is Cool { ... };

[16:33] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[16:33] <JimmyZ> std: class what is Cool { ... }; say Int.WHAT

[16:33] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[16:33] <jnthn> I'm sure STD used to complain about stubs.

[16:34] <JimmyZ> I'm not sure why std accepts Int.WHAT

[16:34] <sorear> niecza: class what is Cool { ... }; say Cool.WHAT

[16:34] <p6eval> niecza v6-150-g612a7b7: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Package was stubbed but not defined at /tmp/EoZq7dz64x line 1:␤------> [32mclass what is Cool { ... }[33m⏏[31m; say Cool.WHAT[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @

[16:34] <p6eval> ..2) ␤  at /hom…

[16:34] <sorear> cribbed from nom

[16:35] <JimmyZ> niecza: class what is Cool { ... }; say Int.WHAT

[16:35] <p6eval> niecza v6-150-g612a7b7: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Package was stubbed but not defined at /tmp/HUki7Kt6KQ line 1:␤------> [32mclass what is Cool { ... }[33m⏏[31m; say Int.WHAT[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @

[16:35] <p6eval> ..2) ␤  at /home…

[16:35] <tadzik> moritz: visited a zoo with Ronja? :)

[16:35] <jnthn> sorear: oh, you implemented it in niecza rather than std having it?

[16:35] <jnthn> OK, I must be mis-remembering.

[16:35] <moritz> jnthn: in nom, how do I get an RPA from an Array?

[16:35] <moritz> tadzik: yes

[16:35] <JimmyZ> std: class what is Cool { ... }; say Int.WHAT # I gueess this also be SORRY ... ?

[16:35] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[16:36] <moritz> tadzik: though she wasn't very interested in the animals... too early for her

[16:36] <moritz> JimmyZ: no, it should rather never complain about Cool

[16:36] <sorear> jnthn: 'role Foo[$x] { my method ::($x) { } }'  After the method, what names are in lexical scope?

[16:36] <tadzik> heh, I was showing a book full of animals to Mathilda today. She's able to point out the eyes, nose and ears of pretty much every animar, including a Crocodile, Coliber or a Cameleon

[16:36] <tadzik> s/every/any/ I suppose

[16:37] <moritz> tadzik: how old is she?

[16:37] <tadzik> moritz: I think about year and a half

[16:38] <moritz> sounds reasonable

[16:39] <tadzik> oh, you may want to review the newest gsoc changes in some spare time

[16:40] *** dju__ joined
[16:40] <moritz> I'll put it on my schedule

[16:40] <tadzik> thank you

[16:41] <jnthn> sorear: Compile time error, I suspect.

[16:41] <jnthn> moritz: Not sure off hand - ask pmichaud 

[16:42] <jnthn> sorear: Along the lines of "value not known at compile time"

[16:42] <sorear> jnthn: how about role Foo[$x] { my method ::("k" x 10) { } }?

[16:42] <sorear> jnthn: how about role Foo { my method ::("k" x 10) { } }?

[16:42] <sorear> jnthn: how about class Foo { my method ::("k" x 10) { } }?

[16:43] *** fish|ipad left
[16:43] <jnthn> sorear: If we can statically work that out at parse time, it's probably kosher.

[16:43] <jnthn> I'm not in a hurry to implement that though. :)

[16:44] <sorear> as I'm currently redesigning the system, "my method" with a variable name is legal everywhere except in roles

[16:44] *** dju_ left
[16:44] <sorear> because all roles are parametric and roles defer evaluation of ... stuff to instantiation time

[16:45] <jnthn> I suspect "variable is generic but we need its value in a non-generic context" issues will show up for various things.

[16:45] <yath> hm. dumb question. how does @foo[*-1] work?

[16:45] <jnthn> role Foo[$x] { constant $y = $x; } # probably also bad

[16:45] <yath> *-1 is a block, as it seems

[16:46] *** MayDaniel joined
[16:46] <jnthn> yath: Yes. There's a multi candidate for postcircumfix:<[ ]> that takes a block and passes in the @foo.elems

[16:46] <yath> jnthn: and that evaluates them how?

[16:46] <yath> s/them/it/

[16:46] <jnthn> yath: Subtracts 1 from it, meaning you have the index of the last element

[16:47] <pmichaud> draft of my yapc::eu talk proposal, comments welcomed:  http://pmichaud.com/sandbox/yapc-talk-1.txt

[16:47] <yath> jnthn: no, i mean, if i have a block *-1, how would i call it, if i was an array?

[16:47] <jnthn> my @foo = 1,2,3; say @foo[*-1] # *-1 is invoked with 3, so we look up @foo[2]

[16:47] <yath> oh

[16:47] <jnthn> yath: Sorry, I don't follow what you're asking...

[16:47] <yath> rakudo: my $block = *-1; $block(23)

[16:48] <p6eval> rakudo ae5bea:  ( no output )

[16:48] <yath> err

[16:48] <yath> rakudo: my $block = *-1; say $block(23)

[16:48] <p6eval> rakudo ae5bea: OUTPUT«22␤»

[16:48] <jnthn> oh, I see what your question meant now :)

[16:48] <yath> jnthn: that was my actual question - thanks :)

[16:48] * yath is quite drunk, sorry ;->

[16:49] <sorear> niecza supports running any code at BEGIN time, as long as it consists of string and number literals, infix:<,>, and infix:«=>»

[16:49] <jnthn> yath: That's one way to use a Sunday :)

[16:50] <yath> jnthn: it's holiday in germany tomorrow ;)

[16:50] <yath> and i've got wine :)

[16:50] <yath> nevertheless, i still spend my time trying to understand perl6 - even while drinking %-)

[16:51] <pmichaud> yath: sometimes that's the best (and perhaps only) way to understand perl6

[16:51] <mberends> pmichaud: perhaps mention series in the proposal?

[16:51] <yath> pmichaud: heh

[16:51] <pmichaud> mberends: +1

[16:52] *** fish|ipad joined
[16:52] *** fish|ipad left
[16:52] *** fish|ipad joined
[16:54] <_patch> rakudo: say 'food' ~~ /<?after f>o+/

[16:54] <p6eval> rakudo ae5bea: OUTPUT«Method 'after' not found for invocant of class 'Cursor'␤  in <anon> at line 22:/tmp/kn3SpGi9JX␤  in 'Cool::match' at line 2684:CORE.setting␤  in 'Regex::ACCEPTS' at line 6415:CORE.setting␤  in main program body at line 22:/tmp/kn3SpGi9JX␤»

[16:54] <sorear> I find that depriving yourself of sleep until the threshold of delirium and then trying to understand stuff works, too

[16:54] <tadzik> oh, I want to see that talk

[16:54] <_patch> rakudo: say 'food' ~~ /o+<?before d>/

[16:54] <p6eval> rakudo ae5bea: OUTPUT«oo␤»

[16:54] <tadzik> I'd like to see "common caveats when handling lists in grammars" :)

[16:55] <jnthn> tadzik: :P

[16:55] <sorear> no "after" in Rakudo?

[16:55] <pmichaud> http://pmichaud.com/sandbox/yapc-talk-1.txt  # updated, mentioning sequences, examples, and reworking the content a bit

[16:56] <tadzik> sorear: I don't think so

[16:56] <tadzik> yay, gsoc-podparser still passes more spectests than master :)

[16:57] <pmichaud> updated again

[16:58] <tadzik> dogwalk &

[16:58] <jnthn> pmichaud: Looks good :)

[16:58] <pmichaud> any other talks people would like to see given?

[16:59] <mberends> pmichaud: can the "better programs" at the end mean "prettier", "faster" or something else?

[16:59] <pmichaud> mberends:  ummm, "yes".  :)

[16:59] <mberends> "more readable" sounds a bit weak

[17:00] <pmichaud> "more elegant code", perhaps?

[17:00] <_patch> is there any way to currently do regex lookbehinds in rakudo?

[17:00] <mberends> pmichaud: yes, and a performance benefit, if there is one

[17:00] <yath> hm. is that a feature?:

[17:01] <yath> rakudo: my @foo = <a b c d>; my $foo = sub { say @_.perl; return 1; }; say @foo[$foo]

[17:01] <jnthn> yath: I don't think there is at the moment.

[17:01] <p6eval> rakudo ae5bea: OUTPUT«(timeout)»

[17:01] <pmichaud> I also wanted to somehow get in there that I think the talk would help Perl 5 programmers as well

[17:01] <yath> jnthn: what am i exactly doing wrong? seems like the say @_.perl fails

[17:01] <pmichaud> after using Perl 6 lists, you kind of think about Perl 5 lists in a new light too :)

[17:02] <jnthn> yath: I'm not sure exactly.

[17:02] <pmichaud> _patch: I'm not sure if lookbehinds are implemented yet.  If so, it'd be <?after ...>

[17:03] *** fish|ipad left
[17:03] <pmichaud> yath:  you're passing a block as an index to the array?

[17:03] <yath> pmichaud: isn't that what *-1 also does?

[17:03] <pmichaud> well, it actually passes a WhateverCode

[17:03] <yath> pmichaud: $foo = sub { return 1; } works, fwiw

[17:03] <yath> rakudo: my @foo = <a b c d>; my $foo = sub { return 1; }; say @foo[$foo]

[17:04] <p6eval> rakudo ae5bea: OUTPUT«b␤»

[17:05] <pmichaud> mberends: "Come to this talk and learn how Perl 6's list features can result 

[17:05] <pmichaud> in more elegant and faster code.

[17:05] <pmichaud> "

[17:05] <pmichaud> how's that?

[17:05] *** JimmyZ left
[17:05] <mberends> better, but still won't attract p5 users

[17:06] <mberends> but it's a good snappy ending

[17:06] <dalek> rakudo/nom: a71c872 | jnthn++ | NOMMAP.markdown:

[17:06] <dalek> rakudo/nom: Update nommap.

[17:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a71c872411

[17:06] <yath> i think "list features" is a very bad idea to attract p5 users, given that lists and arrays in perl5 are totally fucked :-)

[17:06] *** lumi__ joined
[17:07] <yath> or maybe.. historically grown...

[17:07] <pmichaud> I'd like to propose one more talk but can't come up with a topic

[17:07] <pmichaud> otoh, jnthn++ already has two perl6 talks.  not sure how many p6 talks yapc::eu will be able to handle :)

[17:08] <pmichaud> http://yapceurope.lv/ye2011/talk/3515

[17:08] <pmichaud> http://yapceurope.lv/ye2011/talk/3516

[17:08] <pmichaud> and there's also "State of the Parrot":  http://yapceurope.lv/ye2011/talk/3407

[17:08] <jnthn> ;)

[17:08] <jnthn> Yes, I didn't realize that cotto was coming until I saw that talk

[17:08] <jnthn> There's also a Perl 6 Hackathon

[17:09] <pmichaud> well, I'll submit this one; if anyone else has talk ideas please let me know :)

[17:09] <mberends> :)

[17:10] <yath> hm

[17:10] * yath thinks he should think about the question before asking it, it may be too dumb.

[17:10] <yath> smoking &

[17:10] *** skyheights joined
[17:11] <jnthn> pmichaud: I think you did an NQP one last year, iirc?

[17:11] <jnthn> Guess there's not so much new this year beyond "you can write all your stuff in NQP now" and "now uses 6model" though...and my talk will look a lot at 6model.

[17:12] *** lumi_ left
[17:12] *** kolibrie_ left
[17:12] *** f00li5h left
[17:12] *** diakopter left
[17:12] *** ggoebel left
[17:12] *** gfldex left
[17:12] *** mattp_ left
[17:12] *** skangas left
[17:12] *** rhr left
[17:12] *** jrockway left
[17:12] *** revdiablo left
[17:12] *** bs338 left
[17:12] *** spinclad left
[17:12] *** krunen left
[17:12] <yath> hm, something is weird.

[17:13] <yath> rakudo: my $foo = sub { return @_[0] - 1 }; my @bar = 1..23; say @bar[$foo]

[17:13] <p6eval> rakudo ae5bea: OUTPUT«(timeout)»

[17:14] <yath> is this supposed to happen..?

[17:14] <Trashlord> hm

[17:15] <Trashlord> I've never seen it time out before

[17:15] <colomon> rakudo: my $foo = *-1; my @bar = 1..23; say @bar[$foo]

[17:15] <pmichaud> jnthn: I thought about doing an NQP talk, yes.

[17:15] <p6eval> rakudo ae5bea: OUTPUT«23␤»

[17:15] <pmichaud> jnthn: but I think it might overlap with yours a fair bit

[17:15] <sorear> rakudo: my $foo = sub { return @_[0] - 1 }; say $foo(23)

[17:15] <pmichaud> rakudo:  my $foo = { $^n - 1 };  my @bar = 1..23;  say @bar[$foo];

[17:16] <p6eval> rakudo ae5bea: OUTPUT«22␤»

[17:16] <p6eval> rakudo ae5bea: OUTPUT«23␤»

[17:16] <yath> what is $^n?!

[17:16] <pmichaud> it might be the @_ that is the issue there.

[17:16] <sorear> yath: placeholder variable

[17:16] <yath> sorear: for?

[17:16] <sorear> an argument

[17:16] <yath> hm

[17:16] <pmichaud> rakudo:  my $foo = sub ($n) { $n - 1 };  my @bar = 1..23;  say @bar[$foo];

[17:16] <p6eval> rakudo ae5bea: OUTPUT«23␤»

[17:17] <sorear> in Perl 6, every sub has a signature

[17:17] <sorear> if you don't explicitly write one, one is generated by assembling used placeholders

[17:17] <pmichaud> rakudo:  my $foo = sub { @_[0] - 1 };  my @bar = 1..23;  say @bar[$foo];

[17:17] <colomon> oh, is the signature of sub { @_[0] - 1 }    () ?

[17:17] <sorear> colomon: no, (*@_)

[17:17] <p6eval> rakudo ae5bea: OUTPUT«(timeout)»

[17:17] <pmichaud> colomon: the signature of that one is  (*@_ is rw) or something like that

[17:18] <pmichaud> rakudo: my $foo = sub { @_[0] - 1 };  say $foo.signature

[17:18] <p6eval> rakudo ae5bea: OUTPUT«Signature()<0x52df990>␤»

[17:18] <pmichaud> rakudo: my $foo = sub { @_[0] - 1 };  say $foo.signature.perl

[17:18] <p6eval> rakudo ae5bea: OUTPUT«:(;; *@_)␤»

[17:18] <yath> anyway, i just came across that and thought it might be helpful if someone knows that :) i was wondering how Whatever gets the parameter passed to the block i pass to []

[17:18] <yath> like in @foo[*-1]

[17:18] *** MayDaniel left
[17:18] <colomon> pmichaud: is that because @_ is used, or is that always the signature where there isn't any other obvious signature?

[17:19] <pmichaud> colomon: it's because @_ is used, iirc.

[17:19] <sorear> if there is no other obvious signature, (\$_ = $OUTER::_) is used

[17:20] <sorear> yath: that's called a "Whatever closure"

[17:20] <sorear> rakudo: say (* + 5)(7)

[17:20] <p6eval> rakudo ae5bea: OUTPUT«12␤»

[17:20] <pmichaud> sorear: that's for bare blocks... I don't think it's that way for subs, though?

[17:20] <sorear> rakudo: say (* + *)(7, 5)

[17:20] <p6eval> rakudo ae5bea: OUTPUT«12␤»

[17:20] <yath> sorear: wheeee

[17:20] <yath> thanks sorear++

[17:20] <sorear> pmichaud: AFAIK it applies to all code objects, even methods and regexes

[17:20] <yath> needing more wine, i think :)

[17:21] <yath> sorear: does that "if there is no other obvious signature .." only apply to *?

[17:21] * jnthn had pmichaud's understanding

[17:21] <jnthn> Subs get an emty $_

[17:21] <yath> ah

[17:22] <yath> didn't read, sorry :)

[17:22] <pmichaud> having:    sub foo() { say $_; };       foo()     print the contents of foo's OUTER::$_ would be... strange

[17:22] <pmichaud> most people expect $_ to be Any in that case.

[17:23] <pmichaud> (sorry, eliminate the first parens)

[17:23] <yath> hm, $_?

[17:23] <pmichaud> $_ = 5;   sub foo { say $_; };    foo();   # I'd expect Any, not 5

[17:24] <pmichaud> $_ = 5;   sub foo { $_ = 6 };  foo();  say $_;    # I'd expect 5, not 6.

[17:24] <yath> $_ doesn't have anything to do with the arguments passed, does it?

[17:24] <pmichaud> yath: it can in bare blocks

[17:25] <yath> pmichaud: oh. how that?

[17:25] <yath> pmichaud: besides it'd expect it from perl5

[17:25] <pmichaud> rakudo:  my $foo = { say $_ + 1 };    foo(5);

[17:25] <p6eval> rakudo ae5bea: OUTPUT«Could not find sub &foo␤  in main program body at line 22:/tmp/Pxm3YUh0wx␤»

[17:25] <pmichaud> rakudo:  my $foo = { say $_ + 1 };    $foo(5);

[17:25] <p6eval> rakudo ae5bea: OUTPUT«6␤»

[17:25] <yath> hmm

[17:26] <sorear> STD thinks that subs get $OUTER::_...I'll change it and see what breaks

[17:26] <yath> hm.

[17:26] <yath> and why?

[17:26] *** benabik left
[17:26] <pmichaud> a block that has no other signature assumes that it has an optional parameter that goes into $_

[17:27] <yath> pmichaud: but why does

[17:27] <yath> rakudo: my $foo = sub { [+] @_[0,1] }; $foo(23,42)

[17:27] <p6eval> rakudo ae5bea:  ( no output )

[17:27] <yath> rakudo: my $foo = sub { [+] @_[0,1] }; say $foo(23,42)

[17:27] <p6eval> rakudo ae5bea: OUTPUT«65␤»

[17:27] <yath> pmichaud: work then?

[17:28] <pmichaud> sorear: S06:306

[17:28] <yath> pmichaud: or is $_ aliased to @_[0] there?

[17:28] <pmichaud> yath: since you used @_, that defines the signature of the block

[17:28] <sorear> yath: if you use @_ in a block, $_ is not created

[17:28] <yath> ahh

[17:28] <yath> funny

[17:28] <sorear> Perl 6 programmers hardly ever use @_

[17:29] <pmichaud> @_ exists mostly for p5 backcompat

[17:29] *** wamba left
[17:29] <yath> so rule of thumb is: w/o signature only one arg in $_, if you need more than one, pass a signature?

[17:30] <pmichaud> yath: for blocks, yes.

[17:30] <sorear> or use placeholders, yes

[17:30] <pmichaud> for subs, it's best to just always put a signature :)

[17:30] <yath> sorear: placeholders? *sigh*

[17:30] <yath> sorear: what's that now? :-)

[17:30] <pmichaud> yath: my $foo = { $^a + $^b };  say $foo(5,7);

[17:31] <pmichaud> rakudo: my $foo = { $^a + $^b };  say $foo(5,7);

[17:31] <p6eval> rakudo ae5bea: OUTPUT«12␤»

[17:31] <pmichaud> rakudo: my $foo = { $^a + $^b + $^a };  say $foo(5,7);

[17:31] <p6eval> rakudo ae5bea: OUTPUT«17␤»

[17:31] *** benabik joined
[17:31] <yath> pmichaud: hm.

[17:31] <yath> pmichaud: but why?

[17:31] <pmichaud> it's like writing:   my $foo = sub ($a, $b) { $a + $b }    but shorter

[17:32] <pmichaud> the classic p5 example would be:

[17:32] <yath> yes, but why $^a and $^b?

[17:32] <pmichaud> it can be whatever names you want

[17:32] <yath> and not $^foo and $^bar?

[17:32] <pmichaud> rakudo: my $foo = { $^bar + $^foo };  say $foo(5,7);

[17:32] <p6eval> rakudo ae5bea: OUTPUT«12␤»

[17:32] <yath> O_O

[17:32] <yath> so that's in order of occurance, or what?

[17:32] <pmichaud> collation by identifier

[17:32] <masak> in Unicode order.

[17:33] <yath> ah

[17:33] <yath> crazy.

[17:33] <yath> seriously. :)

[17:33] *** skyheights left
[17:33] <pmichaud> my $foo = { $^foo + $^bar }   is like     sub ($bar, $foo) { $foo + $bar }

[17:33] <moritz> yath: it's only meant for very short subs

[17:33] <pmichaud> the classic use example is with sort:     sort { $^a <=> $^b }, @list

[17:33] <masak> rakudo: say { $^second ~ " " ~ $^first }(" HAI", "OH")

[17:33] <p6eval> rakudo ae5bea: OUTPUT«OH  HAI␤»

[17:34] <yath> heh. really. that's why i love perl.

[17:34] <yath> thanks moritz++ pmichaud++ masak++ sorear++

[17:34] * yath is off for smoking

[17:34] *** beekar left
[17:35] <huf> isnt there another twigil for placeholders that orders by something else?

[17:35] *** Moukeddar_ joined
[17:35] <pmichaud> the ':' twigil gives named parameters instead of positional

[17:36] <pmichaud> I'm not aware of a twigil to change the ordering

[17:36] <jnthn> nom: my $x = { say "$:a, $:b" }; $x(b => 42, a => 100)

[17:36] <p6eval> nom: OUTPUT«get_pmc_keyed() not implemented in class 'Integer'␤current instr.: 'nqp;Perl6;Actions;_block7380' pc 62312 (src/gen/perl6-actions.pir:0)␤»

[17:36] *** Moukeddar left
[17:36] <jnthn> hm

[17:37] *** whiteknight left
[17:38] <jnthn> huh, where'd that prefix:<+> come from...

[17:40] <sorear> hey masak

[17:41] *** jrockway joined
[17:41] <sorear> pmichaud: What is S06:369 talking about?

[17:42] <pmichaud> typo

[17:42] <pmichaud> oh, wait, looking

[17:43] *** lumi__ left
[17:43] <yath> sooo.. just to make sure i did understand that correctly: a block has signature () if it doesn't use @_ or any of the funny $^ variables?

[17:43] <thou> yath: no, it has implicit $_

[17:43] <moritz> correct

[17:43] <pmichaud> yath: a *sub* has signature () if it doesn't use those

[17:43] *** kolibrie_ joined
[17:43] *** f00li5h joined
[17:43] *** diakopter joined
[17:43] *** ggoebel joined
[17:43] *** gfldex joined
[17:43] *** mattp_ joined
[17:43] *** skangas joined
[17:43] *** rhr joined
[17:43] *** revdiablo joined
[17:43] *** bs338 joined
[17:43] *** spinclad joined
[17:43] *** krunen joined
[17:43] <yath> thou: tried that.

[17:43] *** donri left
[17:44] *** donri joined
[17:44] <yath> rakudo: my $foo = sub { return $_+1 }; $foo(12)

[17:44] <p6eval> rakudo ae5bea: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in <anon> at line 2:/tmp/ABcV_d5d5d␤  in main program body at line 22:/tmp/ABcV_d5d5d␤»

[17:44] <yath> pmichaud: isn't a sub a block?

[17:44] <pmichaud> a block has signature   ($_ is rw = $OUTER::_)   if it doesn't have the variables

[17:44] <moritz> pmichaud: is there a convenient way to get an RPA from a List (in nom)?

[17:44] <pmichaud> yath: a sub is a special form of a block, called a Routine

[17:44] <pmichaud> moritz: not at present... but why do you need one?

[17:44] <yath> pmichaud: ah..

[17:44] *** lumi_ joined
[17:44] <pmichaud> we're trying to move way away from RPAs

[17:44] <moritz> pmichaud: for implementing .join

[17:45] *** jaldhar left
[17:45] *** jaldhar joined
[17:45] <moritz> pmichaud: it needs to reify the whole thing anyway, and when it's reified, I can use pir::join

[17:45] <pmichaud> moritz: looking/thinking

[17:46] <yath> one last silly question: is sub foo { ... } the same as { ... }?

[17:46] <moritz> .gimme(*), and then access $items

[17:46] <yath> s/foo //

[17:46] <sorear> yath: no

[17:46] <moritz> yath: no. For example return() works on subs, not on blocks

[17:46] <pmichaud> .gimme(*) isn't guaranteed to reify the whole thing, though.

[17:47] <pmichaud> might want .gimme(Inf)

[17:47] <thou> yath: definitely *not* silly questions

[17:47] <yath> moritz: but "my $x = { return 23 }" works

[17:47] <sorear> yath: also, blocks get an implicit $_, subs don't

[17:47] <sorear> rakudo: my $x = { return 23 }; sub foo () { $x(); say "Got here"; }; say foo()

[17:47] <yath> sorear: then i don't understand:

[17:47] <p6eval> rakudo ae5bea: OUTPUT«23␤»

[17:47] <yath> rakudo: $_ = "foobar"; my $x = { say $_ }; $x()

[17:47] <p6eval> rakudo ae5bea: OUTPUT«foobar␤»

[17:48] <moritz> .gimme(*) runs the code  while $!rest && $eager  where $eager is True

[17:48] <sorear> the return in $x makes foo() return

[17:48] <yath> ahh

[17:48] <pmichaud> moritz: but it will stop upon reaching an infinite generator

[17:48] <pmichaud> (I don't have that code in there yet... the List code is still incomplete.)

[17:48] <moritz> ah, ok

[17:49] <yath> sorear: ah.. thanks!

[17:49] * yath is beginning to understand :)

[17:49] <sorear> 10:47 < yath> rakudo: $_ = "foobar"; my $x = { say $_ }; $x()

[17:49] <sorear> this works because, in a block, $_ is an *optional* parameter

[17:50] <moritz> rakudo: say Inf

[17:50] <sorear> if you don't supply it, it defaults to the value of $_ from the outer scope

[17:50] <p6eval> rakudo ae5bea: OUTPUT«Inf␤»

[17:50] <moritz> nom: say Inf

[17:50] <p6eval> nom: OUTPUT«sh: ./perl6: not found␤»

[17:50] <thou> yath: there's  .leave() method that works on all kinds of BLOCKs that's kind of like return

[17:50] <yath> thou: and where would i invoke that method on?

[17:51] <moritz> for example on &?BLOCK

[17:51] <thou> good question, i'm still reading the synopses :-) i'm not sure it's implemented

[17:51] <moritz> which is the current block

[17:51] <yath> hm

[17:51] <yath> ah

[17:51] <moritz> or an item of @?BLOCKS (which is the array of the current and all outer blocks)

[17:51] <yath> rakudo: say (sub { say "foo" }).signature.perl; say { say "foo" }.signature.perl

[17:51] <p6eval> rakudo ae5bea: OUTPUT«:()␤:(;; Mu \|$_?)␤»

[17:51] <moritz> (both NYI in rakudo)

[17:52] <thou> but it's kind of a nice way, in my mind, to think about it; return is like a leave() that goes up the dynamic call stack looking for a sub or method

[17:52] <yath> hm, hm, tricky!

[17:52] <sorear> moritz: where is @?BLOCKS spec'd?

[17:52] <pmichaud> sorear: I think S06:369 is dealing with blocks being passed to listops or the  $foo.method: syntax

[17:52] <yath> but well thought :)

[17:53] *** lichtkind joined
[17:53] <pmichaud> @?BLOCK is no longer in the spec

[17:53] <moritz> sorear: dunno, I remebered @?ROUTINES or something, and thought it also exists for blocks

[17:53] <pmichaud> it's been removed, I think.

[17:53] <moritz> ack will tell

[17:53] <pmichaud> it did exist at one time, yes.

[17:53] <lichtkind> pmichaud: ohai, your boardmember of the parrot.org, you know if the logo is under a free license?

[17:54] <sorear> BLOCKS was never in the specs as long as git history goes back

[17:54] <pmichaud> *BLOCK*

[17:54] <pmichaud> not BLOCK*S*

[17:55] <yath> so sub { ... } creates a Sub, { ... } just a Block

[17:55] <pmichaud> lichtkind: I'm no longer a board member of parrot.org

[17:55] <yath> funny.

[17:55] <sorear> 4681baa37

[17:55] <moritz> lichtkind: try #parrot

[17:57] <pmichaud> (I don't know the logo's licensing terms, either.)

[17:57] <lichtkind> pmichaud: allright the web site told so

[17:57] <pmichaud> lichtkind: where are you looking on the web site?

[17:58] <pmichaud> I need to get it fixed then :)

[17:59] <lichtkind> pmichaud: my fault as always (it was stated as previous :) )

[17:59] <pmichaud> no problem, just wanted to make sure it wasn't listed somewhere else :)

[17:59] <lichtkind> your too kind :)

[18:00] <lichtkind> pmichaud: maybe i have some further quastions too if you dont mind about developement of parrot and such

[18:01] <pmichaud> I don't mind, but #parrot might be a better place to ask

[18:01] <pmichaud> I've really moved away from much of the core decision making about parrot

[18:02] <sorear> funny... my general opinion on Parrot and Rakudo has been that they would be much better off if they shared an architect

[18:03] <lichtkind> sorear: why do you think so?

[18:03] *** wamba joined
[18:03] <pmichaud> sorear: that's probably true.... but politically Parrot seemed to be moving itself *away* from Perl development, not closer

[18:04] <moritz> under allison's steering, parrot moved a bit away from primarily focusing on Perl 6

[18:04] <pmichaud> not just Perl 6, but Perl in general.

[18:04] <pmichaud> in many respects it was actively trying to remove as much perl stuff as it could

[18:04] *** lumi_ left
[18:05] *** Moukeddar joined
[18:05] <pmichaud> even to the point of saying at times "if perl solves the problem by doing XYZ, we have to do something else"

[18:05] *** lumi_ joined
[18:06] <moritz> seems that List.join is not a LHF :(

[18:07] <pmichaud> moritz: I'm trying to decide how to do the RPA part

[18:07] <pmichaud> are there other places where we'll want an RPA?

[18:07] <moritz> pmichaud: it seems that an RPA allone doesn't solve the problem

[18:08] <moritz> pmichaud: because we need to convert to parrot strings first before we can join()

[18:08] <pmichaud> trying to use the join opcode is going to be a bit nasty also because it'll go through the str_vtable

[18:08] *** Moukeddar_ left
[18:08] <pmichaud> er, VTABLE_get_string

[18:08] <pmichaud> which will be slow.

[18:08] *** Moukeddar left
[18:08] <moritz> so we should really create a parrot string array

[18:08] <pmichaud> called a Cat

[18:08] *** beekar joined
[18:08] <pmichaud> to go along with our LoL's

[18:09] <moritz> by pir::repr_unbox_str($item.Str) or so

[18:09] <pmichaud> why not just implement join in pure perl 6?

[18:09] <pmichaud> I also wonder if .join is Stringy, not Str

[18:09] <yath> hm, what's wrong with this? shouldn't it flatten to a list?

[18:09] <yath> rakudo: { say "foo" ~ $^foo ~ $^bar }(<baz bar>)

[18:09] <p6eval> rakudo ae5bea: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in <anon> at line 2:/tmp/h19n3RaI7k␤  in main program body at line 22:/tmp/h19n3RaI7k␤»

[18:10] <pmichaud> yath: list arguments don't automatically flatten, no.

[18:10] <yath> pmichaud: hm, can i force that somehow?

[18:11] <pmichaud> rakudo:   { say "foo" ~ $^foo ~ $^bar }(<baz bar>, <abc def>);

[18:11] <p6eval> rakudo ae5bea: OUTPUT«fooabc defbaz bar␤»

[18:12] <yath> hm, not with .list

[18:12] <pmichaud> flattening is usually done with prefix:<|>

[18:12] <pmichaud> I don't know if it'll work on the literal list

[18:13] <pmichaud> rakudo:   { say "foo" ~ $^foo ~ $^bar }(|<baz bar>);

[18:13] <p6eval> rakudo ae5bea: OUTPUT«foobarbaz␤»

[18:13] <pmichaud> ...it does.

[18:13] <yath> pmichaud: ah, cool, that's what i were looking for! thanks!

[18:13] * pmichaud adds that as something to cover in his talk

[18:13] <yath> :-)

[18:14] <yath> argh

[18:14] <yath> i read "rick roll" instead of "pick roll" in <foo bar>.^methods

[18:16] <tadzik> never gonna pick you up...

[18:16] <pmichaud> moritz: anyway, to get an RPA would be something like:    @list.gimme(Inf) and then use the $!items RPA

[18:17] <jnthn> pmichaud: join in pure Perl 6 has the issue that we'd do loads of concats

[18:17] <jnthn> pmichaud: And with immutable strings tht's probably slow. I guess join does something saner.

[18:17] <moritz> pmichaud: tried that... it segfaults

[18:18] <pmichaud> moritz: I'm guessing it's segfaulting on the fact that they aren't parrot strings, yes.

[18:19] <jnthn> That really shouldn't make it segfault...

[18:19] <pmichaud> moritz: try   pir::join__sP   if you haven't already

[18:19] <pmichaud> er,

[18:19] <pmichaud> join__vsP

[18:19] <jnthn> Note that the resulting string needs to be perl6_box_str'd

[18:19] <jnthn> v?

[18:19] <pmichaud> grrr

[18:19] <pmichaud> join__SsP

[18:20] <jnthn> phew ;)

[18:20] <pmichaud> nm, pir::join already has it that way.

[18:21] <moritz> yes, I'm boxing after the join

[18:21] <pmichaud> http://gist.github.com/1021842

[18:22] <pmichaud> and

[18:22] <pmichaud> http://gist.github.com/1021843

[18:24] <pmichaud> jnthn: I'm wondering which will be slower, the repeated concats or the multiple VTABLE_get_string invocations

[18:24] <pmichaud> does VTABLE_get_string end up going through any PIR with 6model/nom ?

[18:25] <jnthn> pmichaud: vtable overrides are rather faster in 6model

[18:25] <moritz> repeated concat is O(n^2)

[18:25] <jnthn> pmichaud: Parrot's implementation of them is...how can I say this nicely...

[18:25] <jnthn> ...yeah, I can't, but anyway. :)

[18:25] <pmichaud> moritz: vtable overrides in parrot are 3000x

[18:25] <pmichaud> (per whiteknight's benchmarks)

[18:25] <jnthn> In 6model it's a few pointer follows to find the thing to call.

[18:26] <pmichaud> jnthn: the question is whether it results in new interpreters, at least according to the way Parrot natively does it

[18:26] <sorear> it's still gonna be slow

[18:26] <sorear> because of Parrot_pcc_...

[18:26] <jnthn> sorear: true

[18:26] <sorear> and inferior runops

[18:26] <pmichaud> exactly

[18:26] <jnthn> Yeah, we hit the inferior runloop issue

[18:27] <pmichaud> even at O(n^2), I'm wondering if we'll still do better than O(n)

[18:27] <pmichaud> sorry, O(n) where "n" is really 300x

[18:27] <pmichaud> 3000x

[18:27] <pmichaud> grrrr

[18:27] <pmichaud> (need food I think)

[18:27] <sorear> the sane thing to do is to expose StringBuilder to Perl 6 code

[18:27] <sorear> does pir::new work in 6model?

[18:27] <sorear> probably not I guess

[18:27] <pmichaud> we're trying to avoid the Parrot PMCs/objects

[18:27] <sorear> since it's not a SixModelObject

[18:27] <jnthn> Yes, but you'd best be darn careful with the thing you get back.

[18:28] <pmichaud> pir::new works -- that's one way we get hashes and rpas

[18:28] <pmichaud> (Parrot native Hash, that is)

[18:28] <jnthn> So long as you don't let it leak out of code that doesn't know how to hadnle it, it's fine.

[18:28] <jnthn> *handle

[18:28] <jnthn> So yes, we could use StringBuilder.

[18:29] <jnthn> It's O(n) and better than the inferior runloops :)

[18:29] <sorear> jnthn: what nom operations are legal to perform with a non-SixModelObject?

[18:30] <jnthn> sorear: Probably, binding it to an attribute/scalar that is of type Mu, calling methods on it, using it in a pir::op

[18:31] <pmichaud> currently one can also use it in boolean contexts, but that might go away

[18:31] <jnthn> Yes, true

[18:31] <moritz> we can also construct a FSA from $!items and call parrot's join() on it

[18:31] <jnthn> moritz: That'd also work.

[18:32] <pmichaud> that's basically the same as unboxing all of the elements, isn't it?

[18:32] <moritz> it just involves an iteration over $!items, which I wanted to avoid, since I still have the "iterating is slow" thing in the back of my mind (from rakudo/master)

[18:32] <moritz> pmichaud: yes

[18:32] <moritz> they need to be unboxed at some point, the question is just if we do it ourselves, or if we let parrot do it

[18:32] <jnthn> Doing it ourselves is better

[18:32] <pmichaud> let parrot do it == inferior runloops

[18:33] <pmichaud> == WAY SLOW

[18:33] <jnthn> Right

[18:33] <jnthn> The way moritz++ suggested will be pretty fast.

[18:33] <moritz> ok, it's the self.gimme(Inf) that causes the segfault

[18:33] <pmichaud> does the FSA avoid PMC creations?

[18:33] <pmichaud> moritz: okay to use .gimme(*) for now if that works

[18:33] <pmichaud> we'll just have to remember to change it later

[18:34] <pmichaud> you can also do     my $list = (self,).list;  and then repeatedly shift $list until it's empty

[18:34] <pmichaud> (that's iteration)

[18:35] <sorear> why do you say "iterating is slow"?

[18:35] <pmichaud> because it's historically been slow in master, I suspect.  I hope we don't bring too many master assumptions into nom.

[18:36] <pmichaud> the underlying fundamentals of nom are way different

[18:36] <jnthn> Or too many master realities :)

[18:37] <pmichaud> in general I think nom should avoid premature optimization as much as possible at this point.  write the natural answer, and then let's figure out what's slow.

[18:37] <pmichaud> that's one reason I went ahead and wrote List.gimme in p6 instead of trying to optimize it for PIR

[18:37] <colomon> pmichaud: speaking of which, are those profiling tools you cobbled together in nom yet?  :)

[18:37] <sorear> nom's going to be pretty hard to stay ahead of ;)

[18:37] <pmichaud> colomon: not yet.  I'm going to put them into nqp.

[18:38] <pmichaud> I can likely do that today.

[18:38] <colomon> pmichaud++

[18:39] <jnthn> I think getting Test.pm to run again should become a goal soon.

[18:39] <pmichaud> that's normally an early goal of a new implementation, yes :)

[18:39] <pmichaud> that's what 00-parrot is supposed to lead to :)

[18:39] * colomon didn't realize Test.pm wasn't working yet

[18:39] <tadzik> I prepared a version of Test.pm with no our and proto multis, and I try to compile it frequently :)

[18:40] <pmichaud> I have no problem with updating Test.pm to be more nom-friendly at this point

[18:40] <jnthn> tadzik: What's the current blocker in that one?

[18:40] <tadzik> let me see

[18:40] <sorear> problem: Test.pm doesn't have a spec

[18:40] <tadzik> there is no 

[18:40] <tadzik> "Testing" spec?

[18:40] <pmichaud> anything that is a blocker probably deserves tests in t/00-parrot/ fwiw

[18:40] <sorear> tadzik: correct

[18:40] <tadzik> oh

[18:40] <jnthn> Or t/01-sanity/

[18:40] <pmichaud> we've talked about creating one, yes

[18:41] <jnthn> pmichaud: What's the difference between the two, ooc? :)

[18:41] <pmichaud> sorry, t/01-sanity is right

[18:41] <moritz> I wanted to write one, got carried away, and never really came back to it :/

[18:41] <pmichaud> t/01-sanity  : things needed to do Test.pm

[18:41] <pmichaud> t/00-parrot  : just some basic stuff

[18:41] <pmichaud> so, replace my mentions of 00-parrot above with 01-sanity

[18:41] <pmichaud> 01-sanity is what we want to target (and what should be the Test.pm suite)

[18:42] <pmichaud> lunchtime here.

[18:43] *** jaldhar left
[18:43] *** jaldhar joined
[18:43] <tadzik> jnthn: ResizablePMCArray: Can't shift from an empty array!

[18:43] <tadzik> current instr.: 'nqp;Perl6;Actions;cleanup_modifiers' pc 72327 (src/gen/perl6-actions.pir:25628)

[18:43] <tadzik> will paste

[18:43] <jnthn> tadzik: Is that something to do with regex?

[18:43] <tadzik> http://wklej.org/id/545402/

[18:43] <tadzik> no eye deer

[18:45] <jnthn> yes, it is

[18:45] <jnthn> I didn't do anything with regexes yet :)

[18:46] <tadzik> :)

[18:46] <tadzik> I wonder if I can rip them off

[18:46] <thou> sorear: is this behavior of niecza something you'd like a bug report for? and you like those on github?  http://friendpaste.com/sBNlMhQ4dwYgWbEeONc81

[18:51] *** lumi_ left
[18:52] *** lumi_ joined
[18:53] <yath> hm, why is .WHAT of a Block still a Block?

[18:53] <yath> er, ignore that :)

[18:53] * yath ist just trying to understand how foo.^bar works

[18:54] <sorear> foo.^bar means foo.HOW.bar(foo)

[18:54] <yath> ah, HOW..

[18:55] *** sylwek joined
[18:55] <sorear> thou: yeah bug reports for those would be good

[18:55] <sorear> the second problem is new to me, the first is a new manifestation of an old problem

[18:58] <sorear> thou++ # rlwrap

[18:58] <thou> yes, it's very nice! :-)

[19:05] <thou> sorear: for the 2nd issue, i'm really not sure that it's correct syntax. but i guess you can sort that out :-) thanks, sorear++

[19:09] *** kst left
[19:09] *** kst joined
[19:14] <thou> sorear: OK, bugs at https://github.com/sorear/niecza/issues/created_by/softmoth?sort=created&direction=desc&state=open&page=1

[19:16] <sorear> thou: the syntax should be \|(%h<a>:p)

[19:16] *** MayDaniel joined
[19:16] *** sftp joined
[19:17] <sorear> adverbs attach to the lowest-priority thing they can find, which in this case is the call to prefix:<!>

[19:17] <sorear> prefix:sym<|> rather

[19:17] <sorear> the error should *probably* be "You can't adverb that"

[19:18] <sorear> niecza: 2.WHAT :foo

[19:18] <p6eval> niecza v6-150-g612a7b7: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤You can't adverb that at /tmp/eGTV4z3bLI line 1 (EOF):␤------> [32m2.WHAT :foo[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at

[19:18] <p6eval> ../home/p6eval/niecza/src/STD.pm6 line …

[19:18] <thou> ah, right. should probably fix the examples at http://perlcabal.org/syn/S06.html#line_765

[19:18] <thou> ?

[19:18] <masak> std: my $foo; |$foo :adverb

[19:18] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[19:18] <thou> doit |%hash<a>:p,1,2,3;

[19:18] <sorear> yes

[19:19] <yath> hm, can i find out from where a method comes from? i don't see what a{sin,cos,tan} should do on a Parcel

[19:21] <moritz> you can loop through $class.^parents

[19:21] <moritz> and in each, look at .methods(:local)

[19:21] <thou> niecza: \(|(%h<a>:p))

[19:21] <p6eval> niecza v6-150-g612a7b7: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable %h is not predeclared at /tmp/Fa8H_8P7g6 line 1:␤------> [32m\(|([33m⏏[31m%h<a>:p))[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at

[19:21] <dalek> rakudo/nom: 6023be1 | pmichaud++ | src/core/ (3 files):

[19:21] <p6eval> ../home/p6eval/niecza/src/STD.pm6 line …

[19:21] <dalek> rakudo/nom: Add Hash.STORE.

[19:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6023be1de0

[19:22] <sorear> thou: 'softmoth' can now push to perl6/specs

[19:22] <thou> niecza: my %h = :a<1>; \(|(%h<a>:p))

[19:22] <p6eval> niecza v6-150-g612a7b7:  ( no output )

[19:23] <sorear> thou: the html file on perlcabal.org is automatically generated from S06-routines.pod

[19:23] <thou> niecza: my %h = :a<1>; say (\(|(%h<a>:p))).perl

[19:23] <p6eval> niecza v6-150-g612a7b7: OUTPUT«\(|{"a" => "1"})␤»

[19:24] *** sylwek left
[19:25] *** larks_ is now known as larks

[19:25] *** larks left
[19:25] *** larks joined
[19:34] <moritz> nom: pir::new__Ps('FixedStringArray'); say 'alive';

[19:34] <p6eval> nom: OUTPUT«alive␤»

[19:34] <moritz> nom: my $a = pir::new__Ps('FixedStringArray'); say 'alive';

[19:34] <p6eval> nom:  ( no output )

[19:34] <moritz> that makes it kinda hard for me to work with FSAs :/

[19:36] <masak> it just... silently fails?

[19:36] <moritz> it segfaults locally

[19:36] <colomon> nom: my $a := pir::new__Ps('FixedStringArray'); say 'alive';

[19:36] <p6eval> nom: OUTPUT«Can only use perl6_assert_bind_ok on a SixModelObject␤current instr.: '_block13' pc 28 ((file unknown):0) (:1)␤»

[19:36] <sorear> it's only silent because p6eval isn't smart enough to report the exit code of programs it runs

[19:37] <sorear> and I don't feel comfortable enough with the p6eval setup to hack it

[19:40] *** lumi_ left
[19:41] *** lumi_ joined
[19:43] * moritz gives up on List.join

[19:44] *** ymasory left
[19:45] <pmichaud> you have to bind

[19:45] <pmichaud> assignment won't work with non-6model objects

[19:45] <pmichaud> and I think it only works for binding to attributes, atm (perhaps ever)

[19:45] <moritz> well, at least I can't bind to lexicals

[19:47] <dalek> specs: c4304e7 | (Tim Smith)++ | S06-routines.pod:

[19:47] <dalek> specs: [S06] Fix an example in the Named arguments section

[19:47] <dalek> specs: review: https://github.com/perl6/specs/commit/c4304e7eed

[19:47] *** MayDaniel left
[19:53] <pmichaud> wow, parrot has gotten really slow at compiling src/gen/CORE.settings.pir

[19:53] <pmichaud> http://gist.github.com/1021929

[19:53] <pmichaud> that's.... a bit surprising.

[19:54] <moritz> rakudo: class A { say $?CLASS }

[19:55] <p6eval> rakudo ae5bea: OUTPUT«===SORRY!===␤Symbol '$?CLASS' not predeclared in <anonymous> (/tmp/j_UahhdFY1:22)␤»

[19:55] <pmichaud> I guess we're going to have to figure out register allocation in PAST / POST instead of letting IMCC handle it  :-(

[19:56] <pmichaud> or figure out how to manage the registers better in the prologue

[19:56] *** kaare_ left
[20:00] <sorear> managing temporary registers isn't very hard

[20:00] <sorear> just set aside a set of register numbers for temporaries, then allocate them as a stack

[20:02] <benabik> PAST just keeps a counter and increments it each time a register is asked for.  Less than ideal.

[20:02] <pmichaud> PAST expected imcc to be able to handle that.

[20:02] <tadzik> seen mberends

[20:02] <aloha> mberends was last seen in #perl6 2 hours 53 mins ago saying ":)".

[20:02] <pmichaud> (because imcc advertised itself as being able to do so)

[20:03] <tadzik> mberends: is the perlduino code living somewhere?

[20:05] <mberends> tadzik: it's still not in a publishable state. I am currently working on the biggishint library part, and that is being published in Zavolaj as an example

[20:06] <tadzik> mberends: there is an interested redditor: http://www.reddit.com/r/perl/comments/hxs82/perl_on_2mb_embedded_system/c1z9ga4?context=3

[20:07] *** molaf left
[20:12] <jnthn> pmichaud: I analysed the registre allocation.

[20:12] <jnthn> pmichaud: Unforturenly, the problem isn't going to get linearly worse.

[20:13] <jnthn> pmichaud: It's going quadratic, which is why it's got suddenly painful.

[20:14] <jnthn> pmichaud: Should we be able to bind Parrot things to lexicals?

[20:14] <jnthn> pmichaud: I can make bidning to a Mu-typed one OK.

[20:15] <sorear> I think it would be good to make use Curses:from<parrot> as minimally painful as possible

[20:15] <sorear> allowing binding Parrot stuff to lexicals sounds like a zero-cost way to make wrapping Parrot stuff less painful

[20:16] <jnthn> :/

[20:16] <sorear> is it painful to implement?

[20:16] <jnthn> No

[20:16] <sorear> or slow?

[20:16] <jnthn> It's more that every time something non-6model-y can get into the system, we have to stop and handle it.

[20:16] *** dju_ joined
[20:16] <jnthn> I'd rather wrap/munge it at boundaries.

[20:17] <jnthn> Import boundaries are a great time to do that.

[20:17] <jnthn> Largely, Parrot objects and PMCs should be treated in Rakudo the same way a Rakudo on CLR would treat CLR objects.

[20:17] <sorear> most handling can be done using pir::

[20:17] *** dju_ is now known as dju

[20:18] <sorear> but it's impossible to create lexicals using pir::, so another way has to exist

[20:18] *** wallberg joined
[20:18] <sorear> How would Rakudo on CLR treat CLR objects?

[20:18] *** lumi_ left
[20:19] <pmichaud> jnthn: I think I know how to manage the temporaries

[20:19] <jnthn> I suspect the thing to do it belongs at the NQP level rather than Rakudo level. But most likely an interop meta-object.

[20:19] <jnthn> pmichaud: We can do that.

[20:19] <jnthn> pmichaud: One alternative is that I just break the SC stuff over multiple Parrot subs.

[20:19] <pmichaud> bad alternative :)

[20:19] *** lumi_ joined
[20:19] <jnthn> pmichaud: 1000 things in one, next 1000 in another, etc.

[20:19] <jnthn> OK

[20:19] <pmichaud> since subs are slow and increase our startup time

[20:20] <pmichaud> let's go ahead and solve the register allocation problem

[20:20] <jnthn> OK

[20:20] <pmichaud> can you embed the SC stuff into PAST::Stmt, though?

[20:20] <jnthn> Oh, sure

[20:20] <pmichaud> go ahead and do that, please

[20:20] <jnthn> It's just a sequence of PAST nodes

[20:20] *** dju__ left
[20:20] <jnthn> Wait

[20:20] <sorear> another alternative would be to make a great big string with binary description of the SC, then use a new nqp_build_sc op

[20:20] <jnthn> Explain a little more about you want :)

[20:20] <aloha> positive: nothing; negative: nothing; overall: 0.

[20:21] <pmichaud> I presumbe the SC is at some level a sequence of unrelated PAST nodes

[20:21] <jnthn> sorear: Well, but by then I may as well have done the full-blown serialization.

[20:21] <dalek> niecza: e51f7a9 | sorear++ | / (3 files):

[20:21] <dalek> niecza: [remove-CURLEX] Reimplementation of STD is_name

[20:21] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e51f7a953a

[20:21] <pmichaud> basically, I'm thinking that PAST::Stmt will be our "temporary register" boundary

[20:21] <jnthn> pmichaud: Ah, OK

[20:21] <jnthn> pmichaud: There's an Obvious Way to do that.

[20:21] <jnthn> (for me to put in the PAST::Stmts nodes)

[20:21] <masak> explain why aloha butts into grownup conversation.

[20:21] <aloha> positive: nothing; negative: nothing; overall: 0.

[20:21] <masak> explain why this is a good idea.

[20:21] <aloha> positive: nothing; negative: nothing; overall: 0.

[20:22] <sorear> explain sorear

[20:22] <aloha> positive: | perf/ (4 files): (dalek), | / (3 files): (dalek), | / (2 files): (dalek); negative: nothing; overall: 1382.

[20:22] <jnthn> explain jnthn

[20:22] <aloha> positive: | src/Perl6/Grammar.pm: (dalek), | dotnet/compiler/PAST2DNSTCompiler.pm: (dalek), is writing a really nice MOP and then parrot will steal it and then rakudo should scream since parrot understands the MOP under the hood (dukeleto); negative: nothing; overall: 805.

[20:22] <pmichaud> I figure that when you create an SC item, simply wrap it in a PAST::Stmts node

[20:22] <masak> 'explain' is not a good bot prefix, since it's a perfectly good human conversation prefix.

[20:23] <jnthn> pmichaud: looking now

[20:25] <pmichaud> jnthn: what's a "good size" for a temporary register bank?  100?  1000?

[20:25] <tadzik> explain tadzik

[20:25] <aloha> positive: did, recently (moritz), . (dalek), : ooh! excitement! (mberends); negative: nothing; overall: 311.

[20:25] <tadzik> what is that? :)

[20:25] <pmichaud> bots should not speak unless addressed. Period.

[20:26] <masak> explain masak

[20:26] <aloha> positive: moritz_++ (colomon), | doc/ChangeLog: (dalek), said (jnthn); negative: C3 Multiple inheritance has been very good to me, it doesn't need senseless hating (sorear); overall: 364.

[20:26] <pmichaud> jnthn: i.e., what number of temporaries would be able to handle a large percentage of our cases?

[20:27] <colomon> explain colomon

[20:27] <aloha> positive: :) (TimToady), | t/spectest.data: (dalek), reminder (masak); negative: nothing; overall: 120.

[20:27] *** wamba left
[20:27] <jnthn> pmichaud: 1000 sounds excessive

[20:27] <jnthn> pmichaud: The most complex objects we build are probably parameters.

[20:27] <jnthn> pmichaud: Which should be sub-100

[20:28] <pmichaud> well, it's also complexity of expressions

[20:28] *** bitpart joined
[20:28] <pmichaud> and if we do inlining, we end up with even more nesting

[20:28] <jnthn> pmichaud: Oh, you meant generally rather than just for this use case

[20:29] <pmichaud> yes, I"m planning to solve it generally.  :)

[20:29] <pmichaud> (since I think I know how to do that relatively easily)

[20:29] <jnthn> OK, then I can see it being more in some cases

[20:29] <pmichaud> besides, register identifiers are cheap

[20:29] <jnthn> True.

[20:29] <pmichaud> it's not like we're going to allocate 1000 actual registers unless we truly need them

[20:29] <jnthn> *nod*

[20:29] <jnthn> I guess it's an easy enough number to change if we need to later?

[20:30] <pmichaud> (I'm assuming, of course, that $P2000  doesn't automatically put 2000+ P-registers in the call frame.)

[20:30] <jnthn> I, er, hope not :)

[20:30] <pmichaud> yes, it'd be trivial to change

[20:30] <pmichaud> I'll go with 1000 for now

[20:30] <jnthn> OK, then maybe 1000 is a good starting guess.

[20:30] <mberends> pmichaud: this sort of problem really needs a high water mark diagnostic. There is little sense in guessing.

[20:31] <pmichaud> mberends: it'll be easy to see if we guess too low.  and too high isn't an issue.

[20:31] <pmichaud> (other than all non-temporary register allocations will start at the value I pick for the temp max)

[20:32] <pmichaud> 1000 seems simple enough, at any rate.

[20:33] <pmichaud> note when I say "1000" it doesn't mean that things go bad if we run out of temporaries

[20:33] <jnthn> pmichaud: I think we've also traditionally left $P0..$P9 unused.

[20:33] <pmichaud> it just means that further allocations aren't temporary (but that would be limited to the sub that needed 1000 of them)

[20:34] <pmichaud> jnthn: yes, I'm planning to start the temporaries at $P50 or $P100 or something like that

[20:34] <pmichaud> the non-temporaries start at $P1000

[20:34] <jnthn> pmichaud: OK :)

[20:34] <pmichaud> $P0...$P9 remain reserved for the user

[20:34] <pmichaud> $P10..$P19 get used by nqp's libraries

[20:35] <jnthn> 10 regisers should be enough for anyone!

[20:35] <jnthn> :-)

[20:35] <pmichaud> you can always get more by introducing your own register namespace :)

[20:35] <pmichaud> these are just the ones you get using the $P... syntax.

[20:35] <tadzik> karma tadzik

[20:35] <aloha> tadzik has karma of 311.

[20:35] <pmichaud> afk for a bit

[20:35] <tadzik> so explain has something to do with karma

[20:35] <tadzik> int eresting;

[20:36] *** dorlamm joined
[20:38] <colomon> jnthn: back in my 6502 programming days, we only had three registers... limited to 8-bits, too!  ;)

[20:39] <sorear> argh!

[20:39] <moritz> you wouldn't run Perl 6 on that :-)

[20:40] <sorear> I just noticed longnames are allowed to end in ::

[20:40] * sorear tries to work this into eir mental model

[20:40] *** masak left
[20:41] *** pjcj left
[20:42] *** kcwu left
[20:43] <sorear> STD.pm6 line 4058 is... being a problem for me now

[20:48] <jnthn> Isn't trailing :: is a synonym for .WHO

[20:48] <jnthn> ?

[20:48] <jnthn> s/is//

[20:49] *** masak joined
[20:49] <sorear> jnthn: I'm thinking that too, now.

[20:50] <jnthn> Holy s**t

[20:50] <sorear> ststststs

[20:50] <jnthn> I just turend off the "always dump deserialization and fixup PIR" thing I did for debugging SC issues.

[20:50] <tadzik> oh wow

[20:51] <jnthn> And it took running NQP tests from 27 seconds down to 19.

[20:51] <sorear> What did that thing do?

[20:51] <jnthn> sorear: Basically, emitted a LOAD of pointless code :)

[20:51] <pmichaud> jnthn: can you leave it enabled until I get the temporary register code in place?

[20:51] <jnthn> sorear: There's two cases. One where we have built up an environment mostly during the parse, will run immediately and just need to fiddle with it a little.

[20:51] <pmichaud> it serves as a good baseline for me to check

[20:52] <jnthn> sorear: And another one where we have to build the world.

[20:52] <jnthn> pmichaud: I can; I'd like to check how this works out with Rakudo too, but I needn't push it.

[20:52] <jnthn> pmichaud: Or you could use it as your baseline.

[20:52] <sorear> jnthn: and if target => 'eval' we don't need to build the world because the compiler built it?

[20:52] <pmichaud> I'd still like the PAST::Stmts patch, though.

[20:52] <jnthn> sorear: Correct.

[20:53] <jnthn> sorear: I didn't have any clue that leaving both in was so...costly.

[20:53] <dalek> nqp: c0d2879 | jonathan++ | src/NQP/SymbolTable.pm:

[20:53] <dalek> nqp: Add extra PAST::Stmts nodes to better delimit steps, to allow better code generation.

[20:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c0d2879bcb

[20:53] <pmichaud> jnthn++

[20:54] <pmichaud> btw, the other reason for fixing this in the general case is that rakudo master will benefit also :)

[20:54] <jnthn> Troo :)

[20:55] <jnthn> pmichaud: Perl6::SymbolTable patch pushed too

[20:55] <jnthn> Bit bugged I had to patch both...tells me I've got some refactors to do later on.

[20:55] <pmichaud> excellent, thanks.

[20:56] <jnthn> oh, it wasn't pushed...push failed

[20:56] <jnthn> now.

[20:57] *** lumi_ left
[20:57] *** lumi_ joined
[20:57] *** pjcj joined
[20:58] <tadzik> jnthn: was that last nqp commit supposed to give a speedup?

[21:00] <dalek> rakudo/nom: b534a1f | jnthn++ | src/ (3 files):

[21:00] <dalek> rakudo/nom: Implement default values on parameters.

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b534a1fbb3

[21:00] <dalek> rakudo/nom: 0b64b37 | jnthn++ | src/Perl6/SymbolTable.pm:

[21:00] <dalek> rakudo/nom: Extra PAST::Stmts nodes to delimit sections of the deserialization/fixup code.

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0b64b37ca9

[21:06] <jnthn> tadzik: no

[21:06] <jnthn> tadzik: The one pmichaud wants me to hold off with to nqp would give a speedup for NQP and Rakudo in run-immediately mode, and a smaller win for pre-compilation (just the compile stage, not runtime).

[21:07] <pmichaud> I'm only asking for a hold for an hour or two, I think.

[21:07] <pmichaud> actually

[21:07] <pmichaud> you can go ahead and push when you're ready, jnthn.  I just won't pull until after I'm done.

[21:07] <jnthn> pmichaud: If that's not going to cause problems for you, sure

[21:07] <pmichaud> it shouldn't.

[21:08] <pmichaud> as long as I got the PAST::Stmts commit separate from the others, it's fine.

[21:08] <pmichaud> (and I have that now.)

[21:08] *** Moukeddar joined
[21:09] <dalek> nqp: c7bf530 | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[21:09] <dalek> nqp: Detect whether we're in pre-compilation or run-right-away mode and only code-gen the things we need. Quite a notable speedup for NQP tests; can always put it back if we need to debug it, but problems with this have been pretty rare.

[21:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c7bf5307ba

[21:09] <Moukeddar> Hello Perlers

[21:09] <sorear> hello Moukeddar

[21:09] <tadzik> hello Moukeddar 

[21:09] <Moukeddar> how are you doing guys?

[21:10] <jnthn> Weekend is ending :(

[21:10] <jnthn> But otherwise fine :)

[21:10] <Moukeddar> yes , indeed, good to hear

[21:10] <Moukeddar> who's here using static blog ?

[21:11] <Moukeddar> when you store the posts in files instead of database

[21:11] <jnthn> I think masak is

[21:11] <masak> aye.

[21:11] <masak> moritz uses something like that, too.

[21:11] <Moukeddar> masak, and pmichaud i guess too

[21:12] <masak> at least a file-backed blogging system. maybe not static.

[21:12] <pmichaud> my blog is wordpress, mainly

[21:12] <masak> wordpress is dynamic.

[21:12] <Moukeddar> i was thinking about it , and found it pretty secure, no room for SQL injection or whatsoever

[21:13] <masak> as a rule, one should use the least powerful technology where it's still comfortable to implement the solution.

[21:14] <masak> i.e. use a small hammer when you can, and a sledge when you must.

[21:14] <Moukeddar> are those from merphy's rules?

[21:14] <masak> no, they're from a book about programming languages whose name I'm forgetting right now.

[21:15] <Moukeddar> when you remember it , note it :)

[21:15] <Moukeddar> 97 things programmer should know?

[21:16] <masak> Moukeddar: this one: http://www.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695

[21:16] <tadzik> no speedup for me

[21:17] <jnthn> tadzik: What are you looking for a speedup on? :)

[21:17] <Moukeddar> looks somewhat interesting , 20 years of experience in a single book :)

[21:17] <jnthn> tadzik: NQP test suite run time is a good one.

[21:19] <masak> Moukeddar: so, you're thinking of writing a blogging system?

[21:19] <Moukeddar> yes, as a show off :)

[21:20] <tadzik> jnthn: it's exactly the same

[21:20] *** wamba joined
[21:20] <masak> Moukeddar: are you planning to use it after you've written it? :)

[21:20] <tadzik> about 67 seconds

[21:20] <Moukeddar> yes

[21:20] *** MayDaniel joined
[21:20] <Moukeddar> if it impresses me :)

[21:20] <masak> Moukeddar: release early, release often. :)

[21:20] <masak> Moukeddar: what language?

[21:20] <jnthn> tadzik: Oddness.

[21:20] <jnthn> tadzik: Was notable gain here.

[21:21] <Moukeddar> the language is still a big issue

[21:21] <Moukeddar> release early, release often , what rule is this?

[21:21] <Moukeddar> my country is being torn apart by 3 major languages : Arabic , French , English

[21:21] <masak> Moukeddar: an agile one. it's about getting something out there, rather than getting something perfect out there.

[21:22] <masak> Moukeddar: interesting that you use the term "torn apart". why is that?

[21:23] <Moukeddar> well , the business domain is schizofrenic , some use English , some still use French , And Arabic is the official language :p

[21:24] <masak> you could say the same about Sweden. some use Swedish, some Finnish, some English. but I wouldn't say Sweden is torn apart by that fact. :)

[21:25] <pmichaud> okay, my first test case will be t/nqp/13-op.t .  Currently its mainline uses approx 173 unique registers

[21:26] <Moukeddar> well , believe me , it is being torn 

[21:26] <pmichaud> let's see if we can reduce that number :-)

[21:26] <Moukeddar> they just can't decide

[21:26] <tadzik> jnthn: no change at all :(

[21:26] <jnthn> ++pmichaud ;)

[21:26] <jnthn> tadzik: You certainly have latest NQP master checked out?

[21:26] <masak> Moukeddar: I would say it's only a problem if people are excluded or can't understand because of the choice of language.

[21:26] <tadzik> jnthn: yep, and I realclean'd and rebuilt

[21:26] <jnthn> Not latest NQP_REVISION?

[21:26] <jnthn> OK.

[21:26] <jnthn> Then I'm confused. :)

[21:27] *** tandy80 joined
[21:27] <tadzik> also, t/p6regex/01-regex.t .. 332/? Null PMC access in can()

[21:27] <thou> Moukeddar: is it causing political tension? or people are using language as a way to prevent certain groups from getting some jobs, for example?

[21:28] <masak> are the languages dividing people into separate groups with separate identities?

[21:29] *** dorlamm left
[21:29] <tandy80> hi guys, what's the best to learn coming from php? perl or python?

[21:29] <tandy80> no trolls plz

[21:29] <Moukeddar> thou, there's no political tension , but some companies require you to have previous project in french , or you pass the interview in French

[21:30] <Moukeddar> which is a big issue

[21:30] <thou> Moukeddar: by the way, other ways to interpret the original question ("which language?") might be regarding which programming language you intend to use to write your blogging system; or possibly which templating language you might use

[21:30] <Moukeddar> it's just crazy

[21:30] <masak> tandy80: I'd say Perl is closer to PHP. but it's not necessarily that simple.

[21:30] <Moukeddar> thou, MVC architecture is my first choice

[21:30] <tandy80> and to get a job in finance what would you reckon? perl or php?

[21:30] <Moukeddar> so it can be any language , i guess

[21:30] <tandy80> sorry perl or python

[21:31] <masak> tandy80: I reckon either would do fine :)

[21:31] <tandy80> ok thank you very much :)

[21:31] *** lumi_ left
[21:31] <masak> tandy80: there's a bit of a jump from programming language to a job in finance. I'd say don't worry about the connection -- there probably is none. :)

[21:31] <Moukeddar> tandy80, finance requires functional languages in most i guess

[21:31] <masak> Moukeddar: yes, more than other branches.

[21:31] <dalek> rakudo/nom: a46c5d2 | jnthn++ | src/ops/perl6.ops:

[21:31] <dalek> rakudo/nom: Allow binding Parrot things to Mu-typed scalars.

[21:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a46c5d2dbf

[21:31] <dalek> rakudo/nom: 4df8fab | jnthn++ | src/Perl6/Actions.pm:

[21:31] <dalek> rakudo/nom: Unbreak hash vs block detection a bit.

[21:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4df8fabefb

[21:31] <masak> some even use APL.

[21:32] <tandy80> masak: I am more on the finance side now ;)

[21:32] <masak> and here on this channel, we're more on the programming language side ;)

[21:32] <Moukeddar> functional languages are your friends

[21:32] *** lumi_ joined
[21:33] <masak> with dysfunctional languages like these, who needs enemies?

[21:33] <thou> tandy80: also, you really can't go wrong learning either one. most of the concepts map between the two pretty easily

[21:33] <Moukeddar> masak, unleashed the inner-troll

[21:33] <tandy80> ok thank you very mucj for this advise

[21:33] <masak> tandy80: good luck in finance!

[21:39] <Moukeddar> it's a dog world 

[21:40] <masak> "it's a doggy-dog world" :)

[21:40] <Moukeddar> dog but softer and much cuter

[21:41] *** Psyche^ joined
[21:44] *** Patterner left
[21:44] *** Psyche^ is now known as Patterner

[21:44] <masak> tandy80: Python has a larger built-in library of things. Perl has a larger module repository. Python has block indentation. Perl has block curly braces. Python has fewer "ways to do it". Perl has a slightly more liberal view on restricting the programmer. Python has slightly antiquated OO facilities. Perl has Moose. :)

[21:45] <masak> uh, for the first and the last of those, s/Perl/Perl 5/.

[21:45] <benabik> Perl has s///

[21:45] <masak> :)

[21:46] <masak> tandy80: when you come to a Perl channel, expect at least a little Perl bias :P

[21:47] <tandy80> masak: haha yes I know about the bias but at least I get a good knowledge here ;)

[21:47] <masak> we're known for that :)

[21:52] *** tandy80 left
[21:53] <pmichaud> first pass at temporary register allocation reduced from 173-ish to 128-ish registers

[21:54] <jnthn> pmichaud: Nice

[21:54] <jnthn> pmichaud: I suspect that the thing we're mosly aiming this at might have a much larger win.

[21:54] <pmichaud> ...and only used two temporaries to do it

[21:54] <jnthn> wow!

[21:57] *** PacoLinux left
[21:57] <pmichaud> second pass reduces it to 89-ish registers

[21:58] <pmichaud> still only required at most two temporaries (per register bank) to do it.

[21:58] <jnthn> whoa

[21:59] <masak> blog post! http://strangelyconsistent.org/blog/june-12-for-loops

[21:59] *** lumi_ left
[21:59] *** MayDaniel left
[22:00] *** lumi_ joined
[22:00] <masak> rakudo: my $foo = 42; say "The number is '$foo'"

[22:00] <p6eval> rakudo ae5bea: OUTPUT«The number is '42'␤»

[22:02] <masak> rakudo: my $sentence = "Look, a fish!"; for $sentence.words -> $word { say "'$word' has $word.chars() characters" }

[22:02] <p6eval> rakudo ae5bea: OUTPUT«'Look,' has 5 characters␤'a' has 1 characters␤'fish!' has 5 characters␤»

[22:02] <Moukeddar> the answer to the ultimate question?

[22:03] <pmichaud> third pass reduced it to 19 registers, using a max of 4 temporaries in a bank

[22:03] <jnthn> O.O

[22:03] <masak> I must have an outdated Rakudo. The above fails locally.

[22:03] * masak updates

[22:03] <pmichaud> let's make sure nqp still passes its tests :)

[22:04] <pmichaud> it does.  now let's see how rakudo master does.

[22:04] <masak> oh! bash quoting fail. never mind :)

[22:05] <jnthn> pmichaud: That was...fast :)

[22:05] <jnthn> pmichaud++

[22:08] <pmichaud> ah, but it breaks master

[22:08] <pmichaud> now to figure out why.

[22:08] <sorear> good * #perl6

[22:09] <masak> good *, sorear

[22:09] <colomon> \o

[22:11] <pmichaud> for the SC stuff, we go from 1100 registers used down to 500  (so far)

[22:11] <pmichaud> still some possible further optimizations

[22:11] <pmichaud> (SC stuff being the SC generated for NQP.pir)

[22:11] *** Guest96628 is now known as alys

[22:11] *** alys is now known as alyx

[22:11] <sorear> I'm not suprised _at all_ that you reduced 170 registers to 19

[22:11] <jnthn> pmichaud: I'm guessing many are the .const 'Sub' $Px ones

[22:12] *** alyx left
[22:12] *** alyx joined
[22:12] <pmichaud> jnthn: correct.  and I'm thinking those aren't reusable.

[22:12] <pmichaud> sorear: I'm not that surprised either.

[22:12] <jnthn> pmichaud: I don't think so.

[22:13] <sorear> Why does .const need registers?

[22:13] <pmichaud> ...because those are what get passed to the opcodes

[22:14] <Moukeddar> milestones are like goals , right?

[22:14] <sorear> how does .const work?

[22:14] <sorear> Moukeddar: sort of

[22:14] <Moukeddar> ok

[22:14] <sorear> Moukeddar: milestones implies that you have furhter to go.  Intermediate steps.

[22:14] <Moukeddar> phase?

[22:14] <pmichaud> IMCC might be smart enough to treat the .const's  as _pc arguments instead of _p ones

[22:15] <thou> masak: probably you have rejected this idea, but just in case: have you considered using something like disqus for comments in your blog?

[22:15] <pmichaud> so that it doesn't allocate a register or use it in the allocation analysis

[22:15] <sorear> Moukeddar: the legend goes that Roman roads had stones placed 1 mile apart to count distance.  So we get phrases like "keep going until the next mile-stone"

[22:15] <pmichaud> and "mile" was the distance of 1000 steps

[22:16] <pmichaud> thus originally "mille"

[22:16] <Moukeddar> 5 4nderstand

[22:18] <thou> masak: btw, i usually put baking powder in my pancakes

[22:18] <Moukeddar> num luck misses with my key mapping

[22:18] * sorear is wondering how much of STD's check_variable and whatnot to leave in the grammar, or if it should be moved to actions

[22:20] <sorear> niecza: say "foo @!pie bar"

[22:20] <p6eval> niecza v6-151-ge51f7a9: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot resolve class for private method at /tmp/WffMHQqA49 line 1:␤------> [32msay "foo @!pie[33m⏏[31m bar"[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at

[22:20] <p6eval> ../home/p6eval/niecza/sr…

[22:22] *** whiteknight joined
[22:26] *** Moukeddar left
[22:28] *** araujo left
[22:29] *** Eevee left
[22:32] *** araujo joined
[22:33] *** jaldhar left
[22:34] *** lumi_ left
[22:34] *** jfried left
[22:35] *** lumi_ joined
[22:37] <sorear> pmichaud: Parsing Perl6 is more your domain, right?  Do you know what all the cases in STD's <variable> are for?

[22:37] <sorear> or TimToady: if he's around

[22:43] *** dju_ joined
[22:44] *** araujo left
[22:44] *** dju left
[22:45] *** wallberg left
[22:45] <masak> thou: you're the second person to mention disqus (after sorear). I haven't looked closely enough at it to be able to accept or reject it yet.

[22:46] <masak> thou: next time I'll make pancakes, I'll be making them out of sourdough. TIMTOWTDI. :)

[22:46] <masak> 'night, #perl6.

[22:46] <thou> ok. for a 10-year+ blog, i could understand very well avoiding an external service like disqus

[22:46] <jnthn> night o/

[22:46] *** mishnik joined
[22:46] *** mishnik|2 joined
[22:46] <masak> thou: plus, it's fun to invent one's own wheel ;)

[22:47] <thou> but it could also just work, and you could have comments on your blog tomorrow. :-)

[22:47] <thou> ok, good night masak

[22:48] <thou> :-) when i was a kid Mom had sourdough starter in the fridge, named Herman. she'd feed Herman every few days, and on the weekends we'd have pancakes or waffles. good stuff. :-)

[22:49] *** bitpart left
[23:08] *** dju_ is now known as dju

[23:10] <sorear> whiteknight: maybe you should be the third person to mention disqus to masak? :D

[23:21] <dalek> rakudo/nom: b64412d | jnthn++ | src/Perl6/Metamodel/MultiMethodContainer.pm:

[23:21] <dalek> rakudo/nom: Clean up multi method implementation a little so it exposes a cleaner API.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b64412d327

[23:21] <dalek> rakudo/nom: 563344f | jnthn++ | src/Perl6/Metamodel/ (3 files):

[23:21] <dalek> rakudo/nom: Multi-method specialization and composition.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/563344fe5d

[23:21] <dalek> rakudo/nom: 1206d0c | jnthn++ | src/Perl6/SymbolTable.pm:

[23:21] <dalek> rakudo/nom: If we have to dynamically compile code, be sure to fix up all the nested Parrot subs with their Perl 6 Code objects, not just the outermost one.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1206d0c2a4

[23:21] <dalek> rakudo/nom: dbb28dc | jnthn++ | src/ (2 files):

[23:21] <dalek> rakudo/nom: Ensure that we locate signatures from the code object, not just the static signature, otherwise instantiated generic signatures will never be located, just the generic original.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbb28dcf22

[23:26] <sorear> o/ jnthn

[23:26] <sorear> jnthn: I want to at least understand how to make roles work before the month is over...

[23:27] * sorear is planning to scrap check_variable as it currently exists and replace it with some different sort of checker

[23:28] <jnthn> sorear: Same ;)

[23:29] <jnthn> sorear: My current attempt at doing that seems to be wroking out fairly well.

[23:30] <jnthn> Key previous mistake: not reifying all the different things that can show up, or forms roley things can show up as, into separate meta-objects.

[23:31] <dalek> rakudo/nom: e5e56ae | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[23:31] <dalek> rakudo/nom: Need to fix up cloned code objects in all cases, not just dispatcher derivation.

[23:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5e56ae836

[23:31] <dalek> rakudo/nom: 8bcdd16 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[23:31] <dalek> rakudo/nom: Fix a couple of really silly bugs in code object generic and signature generic instantiation that were hiding various others (which have been resolved over the last few commits).

[23:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8bcdd16c07

[23:31] <sorear> jnthn: what do you mean by that?

[23:32] <sorear> jnthn: like not distinguishing the role from the punned class?

[23:32] <sorear> is the g in twigil soft or hard?

[23:32] <jnthn> I say it soft.

[23:32] <jnthn> No, the punning bit wasn't to bad in the master implementation.

[23:32] <jnthn> *too

[23:33] <jnthn> I guess the biggest missing thing was no meta-object that represented a generic type variable.

[23:33] <jnthn> The pile of cheats that resulted caused...issues.

[23:34] <jnthn> Of course, in master there wasn't a really good way to do meta-objects.

[23:34] <sorear> How can you have a metaobject for a generic type variable?

[23:34] *** daniel-s joined
[23:34] <sorear> Do you also have a metaobject for ::($foo) ?

[23:34] <sorear> ...I suppose you would/should.

[23:35] <sorear> after all the methods have to exist while they are being compiled, so they need return types

[23:35] <jnthn> I didn't get to interpolated names yet, but it sounds like something that'd need to be handled in a similar way.

[23:35] <sorear> I think I get that much

[23:36] <sorear> niecza currently has cheaty support for interpolated names, but only in method definitions

[23:36] <sorear> regex ::($name) { ... } # no other form is valid

[23:36] <jnthn> I didn't even realize that was allowed until relatively recently.

[23:36] <jnthn> And was slightly horrified when I saw it.

[23:37] <sorear> I'm not entirely sure it *was* allowed before I complained to TimToady that it was impossible to write add_categorical in Perl 6

[23:37] <sorear> then he used his super retcon powers to add it to Perl 6 without changing STD

[23:38] <jnthn> oh, so it's your fault :P

[23:38] <jnthn> I can see it being useful though :)

[23:38] *** lumi_ left
[23:38] <jnthn> It's just a little way down my list of things to worry about. Of course, if you have a cuse case in Niecza for it I can see why you're worrying about it now.

[23:38] <jnthn> I do worry a bit about how to factor those things in the general case.

[23:39] <lichtkind> good night

[23:39] <sorear> well, that and I'm currently trying to modify Niecza's grammar to not maintain two copies of the symbol table

[23:39] <sorear> Which is forcing me to confront a lot of questions about the meaning of names

[23:39] *** lumi_ joined
[23:40] *** wamba left
[23:40] <jnthn> Yeah...I've been fighting the same battle in nqp and nom.

[23:40] <lichtkind> sounds like its really advantage to have 2 implementations :)

[23:40] <jnthn> At least, with the packages.

[23:40] <jnthn> Not got lexpads as unified as I want just yet.

[23:42] <lichtkind> jnthn: how you mena that?

[23:43] <jnthn> lichtkind: In general, I'm unifying the object the compiler works with and the ones that exist at runtime

[23:43] <jnthn> lichtkind: But I'm not as far along with that as I'd like to be with lexpads.

[23:49] <sorear> niecza has an interesting problem with that sort of unification

[23:49] *** araujo joined
[23:49] <sorear> I'm trying to keep the compiler pure Perl 6

[23:49] *** jaldhar joined
[23:49] *** araujo left
[23:49] *** araujo joined
[23:49] <sorear> so the compile time objects are just classes; they aren't manifestations of deeper runtime objects

[23:51] <sorear> it seems like unification would create major problems for cross-compilation

[23:53] *** nymacro joined
[23:54] <jnthn> Must sleep...actually have to act like I have a $dayjob tomorrow

[23:55] <jnthn> night o/

[23:55] *** Chillance left
[23:57] <dalek> rakudo/nom: b977e96 | jnthn++ | src/Perl6/SymbolTable.pm:

[23:57] <dalek> rakudo/nom: Add some missing cloning at fixup time, which led to things being shared in ways they should not be.

[23:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b977e96d8b

[23:59] <lichtkind> jnthn: what is a lexpad?

