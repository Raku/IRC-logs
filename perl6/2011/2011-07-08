[00:02] *** araujo left
[00:03] *** araujo joined
[00:04] <masak> 'night, #perl6

[00:04] *** masak left
[00:09] *** lichtkind left
[00:27] *** dorlamm left
[00:30] *** bluescreen10 left
[00:31] <dalek> rakudo/nom: 31fa9ff | jonathan++ | src/ (2 files):

[00:31] <dalek> rakudo/nom: Only auto-generate an accessor method if the user didn't already provide one.

[00:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/31fa9ffc75

[00:31] <dalek> rakudo/nom: bf8a6af | jonathan++ | src/core/Parcel.pm:

[00:31] <dalek> rakudo/nom: Allow | to work on a Parcel.

[00:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf8a6af50a

[00:31] <dalek> rakudo/nom: 61aa803 | jonathan++ | src/core/Junction.pm:

[00:31] <dalek> rakudo/nom: First cut implementationg of an auto-threader. Not wired up yet, and plenty of room to optimize this.

[00:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/61aa8037b0

[00:31] <dalek> rakudo/nom: fe39b76 | jonathan++ | src/ (5 files):

[00:31] <dalek> rakudo/nom: Wire up the auto-threader for single and multi-dispatch. Not heavily tested, but seems to work out with various tests (multi, single, multiple junctions, correct return value, pos and named args, etc).

[00:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fe39b76976

[00:40] <dalek> rakudo/nom: 265331a | jonathan++ | t/spectest.data:

[00:40] <dalek> rakudo/nom: Two more passing test files.

[00:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/265331a987

[00:40] <dalek> rakudo/nom: 5f2a810 | jonathan++ | NOMMAP.markdown:

[00:40] <dalek> rakudo/nom: Update nommap.

[00:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5f2a810dfd

[00:40] <jnthn> grr...I think my body clock thinks that a 30 hour day is normal now...

[00:41] <jnthn> sleep &

[00:44] *** colomon joined
[00:51] <[Coke]> jnthn: no, stay up and let it roll over.

[00:53] *** tokuhirom left
[01:02] *** daemon left
[01:04] *** noganex left
[01:06] *** noganex joined
[01:06] <lue> $ ./perl6 -e 'say "hai".comb; say "hai".comb.perl'

[01:06] <lue> h a i

[01:06] <lue> ("h", "a", "i").list

[01:06] <lue> afk for nom time &

[01:18] *** [Coke] left
[01:20] *** [Coke] joined
[01:20] *** envi left
[01:22] *** daniel-s joined
[01:32] <[Coke]> nom: [\+] 1..1000;

[01:32] <p6eval> nom: OUTPUT«Nominal type check failed for parameter '$infinite'; expected Any but got Mu instead␤current instr.: 'GATHER' pc 354855 (src/gen/CORE.setting.pir:91676) (src/gen/CORE.setting:1942)␤»

[01:52] *** beekor left
[02:01] *** whiteknight left
[02:01] *** whiteknight joined
[02:07] *** f00li5h left
[02:09] *** thou left
[02:43] *** thou joined
[02:48] <dalek> specs: 0a5a59c | larry++ | S06-routines.pod:

[02:48] <dalek> specs: $! and $/ are created only by routines/compunits

[02:48] <dalek> specs: 

[02:48] <dalek> specs: Blocks don't have their own $! or $/ unless you explicitly declare one.

[02:48] <dalek> specs: review: https://github.com/perl6/specs/commit/0a5a59c66b

[02:52] *** f00li5h joined
[02:53] *** whiteknight left
[03:02] *** flatwhatson joined
[03:02] *** flatwhatson left
[03:03] *** aindilis left
[03:15] *** pjcj left
[03:18] *** perlhack joined
[03:18] <sorear> perl6: say Regex ~~ Routine

[03:18] <perlhack> :-)4000 words and will be what you fluent dialogue

[03:18] <p6eval> rakudo 72d158, niecza v7-18-g240a9af: OUTPUT«Bool::True␤»

[03:18] <p6eval> ..pugs: OUTPUT«␤»

[03:18] <sorear> o/ perlhack

[03:19] <perlhack> hi sorear

[03:19] <perlhack> i am try my best learnning english.

[03:20] <soh_cah_toa> perlhack: what's your native language?

[03:20] <sorear> almost

[03:20] <sorear> mandarin

[03:20] <perlhack> soh_cah_toa:Chinese

[03:20] <sorear> ey was here before I left

[03:20] <soh_cah_toa> ouch, mandarin -> english will be hard

[03:21] <sorear> perlhack: did you get a chance to meet jnthn at BJPW?

[03:21] <perlhack> No .At that time no money car

[03:22] <perlhack> sorear, 

[03:22] <sorear> soh_cah_toa: it's been interesting to study

[03:23] <soh_cah_toa> i've always wondered what it must be like for non-english speaking programmers to write code that uses the english language since they all do

[03:24] <perlhack> i think we will be in english and communication technology.

[03:24] <perlhack> :-)

[03:25] <sorear> soh_cah_toa: you should ask around, quite a lot of #perl6 is *not* native English speakers

[03:25] <soh_cah_toa> really? that's very interesting

[03:26] <perlhack> around  usa  round uk

[03:27] *** Su-Shee left
[03:29] *** Su-Shee joined
[03:38] *** envi joined
[04:05] *** pjcj joined
[04:07] *** perlhack left
[04:22] *** Bzek joined
[04:22] *** satyavvd joined
[04:27] *** _jaldhar left
[04:27] *** soh_cah_toa left
[04:35] <dalek> specs: aca4e5d | larry++ | S04-control.pod:

[04:35] <dalek> specs: detangling $! from inflight semantics of @!

[04:35] <dalek> specs: review: https://github.com/perl6/specs/commit/aca4e5d20a

[04:37] <TimToady> it's still a mess, but must zzz &

[04:49] *** ZaphrodZenovka left
[04:50] *** ZaphrodZenovka joined
[04:51] <sorear> TimToady++ # agreed

[04:51] <sorear> though sink context still makes me uneasy

[04:55] *** kaare_ joined
[05:05] *** koban joined
[05:05] *** koban left
[05:12] *** _jaldhar joined
[05:17] *** agentzh joined
[05:19] *** silug_ left
[05:19] *** silug_ joined
[05:22] *** cognominal_ joined
[05:24] <sorear> Why is "0" false?

[05:26] *** _jaldhar left
[05:27] *** cognominal left
[05:27] *** araujo left
[05:30] *** _jaldhar joined
[05:30] *** _jaldhar left
[05:31] *** _jaldhar joined
[05:31] *** _jaldhar left
[05:32] *** _jaldhar joined
[05:32] *** molaf_ left
[05:33] *** birdwindupbird joined
[05:39] <daniel-s> is there another company that offers a translation API

[05:39] <daniel-s> similar to google translate

[05:41] <sorear> "is company", I don't know

[05:42] <sorear> there are a *ton* of academic translator projects

[05:42] <sorear> and there used to be many commercially-backed ones

[05:42] <sorear> there might still be

[05:46] <daniel-s> well, I don't care who runs it

[05:47] *** Tedd1^ left
[05:47] *** molaf_ joined
[05:47] <daniel-s> I want to be able to add translation to something I'm writing

[05:47] <daniel-s> I just want to be able to give it some text and say, please translate this from x to y

[05:47] *** wtw joined
[05:53] *** stephanepayrard_ joined
[05:56] *** alim joined
[05:56] *** cognominal_ left
[06:22] *** Tedd1 joined
[06:31] <thou> \o/ november "running" on rakudo-master: http://postimage.org/image/1si2l8tlw/5ad5ec6f/

[06:51] *** thou left
[06:57] *** Mowah joined
[07:02] *** alim left
[07:06] *** drbean left
[07:17] <dalek> niecza: 8dc8c8f | sorear++ | / (14 files):

[07:17] <dalek> niecza: Reimplement $_ $! $/ according to more-current spec

[07:17] <dalek> niecza: 

[07:17] <dalek> niecza: Every Routine now contains all three of these, every non-Routine

[07:17] <dalek> niecza: only has $_.

[07:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8dc8c8fae8

[07:20] *** am0c left
[07:23] *** pjcj left
[07:33] <sorear> tomorrow I'll look into making $_ etc generation lazier

[07:33] <sorear> *out*

[07:37] *** cognominal joined
[07:40] *** stephanepayrard_ left
[07:44] *** wamba joined
[07:45] *** pjcj joined
[07:48] <dalek> nqp: 442e0b3 | pmichaud++ | / (5 files):

[07:48] <dalek> nqp: Update nqp:: event and debug logging support.

[07:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/442e0b3db6

[07:48] <dalek> nqp: 59bc2bb | pmichaud++ | src/stage0/ (6 files):

[07:48] <dalek> nqp: Update bootstrap.

[07:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/59bc2bbcd0

[07:49] <jnthn> Morning, #perl6

[07:59] <pmichaud> jnthn: o/

[08:02] <jnthn> ooh, more event logging stuff :)

[08:02] <tadzik> good morning #perl6

[08:03] <pmichaud> Yes.  I got tired of hacking together debug code so decided to formalize it a bit better.

[08:03] <jnthn> pmichaud: What does it write to the log? Timestap, flags and message?

[08:03] <pmichaud> message

[08:03] <pmichaud> but you can parameterize the message somewhat.

[08:03] <pmichaud> don't have timestamp in there yet... will likely add that.

[08:04] <pmichaud> nqp::deb(flags, 'message %sub% %caller%')   # sends 'message' to the log along with the current sub and its caller

[08:04] <jnthn> pmichaud: OK, because with timestamp and sub entry/exit we have a basic profiler :)

[08:05] <pmichaud> can't easily do a reliable sub exit.

[08:05] <pmichaud> we can do a sub entry, no problem.

[08:05] <jnthn> ah, true

[08:05] <pmichaud> that's why I didn't really worry about timestamp just yet

[08:05] <pmichaud> because sub exit is a real challenge

[08:05] <jnthn> ok

[08:05] <jnthn> same challenge as temp/LEAVE etc

[08:05] <pmichaud> we can still get a basic profiler to tell us how many times a sub is invoked, and who is doing the invoking

[08:06] <pmichaud> and with lexical return, we can capture sub exits except when skipped due to an exception.

[08:07] <pmichaud> and I might put in a field that lets us identify contexts (to match up entry/exit)... if I can figure out a way to do that.

[08:07] <pmichaud> anyway, nqp::deb() is fairly efficient, if the flags indicate nothing is to be logged, it skips over the evaluation of the second argument entirely.

[08:08] <jnthn> *nod*

[08:08] <pmichaud> so, it's only the cost of a jump if nothing is to be logged.

[08:08] <jnthn> oh, you added a pasttype for it too!

[08:09] <pmichaud> it had to be a pasttype to get the macro-ish capabilities

[08:09] *** im2ee joined
[08:09] <pmichaud> if I have   nqp::deb(flags,  $xyz.fmt('some format %s thingy'))

[08:09] <pmichaud> I don't want to pay the cost of the .fmt if we're not going to log it anyway :)

[08:11] <pmichaud> and yes, it's a pasttype, which means it can go into PAST trees to automatically insert stuff.  like subroutine entry/exit.  :)

[08:11] <jnthn> nice

[08:11] <pmichaud> PAST::Op.new(:pasttype<nqpdebug>, 0x10, 'entry %sub% %caller%')

[08:13] <pmichaud> so, in tracking down the outer bug, I have a couple of observations.

[08:13] <pmichaud> first, I wonder if it's related to the bug that causes nqp's repl to also fail on the second and subsequent commands

[08:14] <jnthn> No, that's related to an issue I already fixed in nom

[08:14] <pmichaud> and second, it looks like the line

[08:14] <pmichaud>                 $output[0].set_outer_ctx($outer_ctx);

[08:14] <pmichaud> in HLL::Compiler.eval is never called.

[08:15] <pmichaud> oh, wait, yes it is.

[08:15] <pmichaud> but whatever is setting the outer is doing so *before* that line is called.

[08:15] <jnthn> (Issue is unpopulated %*HOW on the second line.)

[08:16] <pmichaud> I'm going to add in some more debugging and track it down just a bit more.

[08:16] <jnthn> oh..

[08:17] *** im2ee_ joined
[08:17] <jnthn> hm

[08:17] <jnthn> There is one place SymbolTable.pm emits a set_outer_ctx call

[08:18] <jnthn> *but* it should only do that when we call load_setting

[08:18] <jnthn> Which we don't for second line of eval

[08:19] <pmichaud> we look it up in Perl6/Grammar.pm, too.

[08:20] *** alim joined
[08:20] *** im2ee left
[08:21] <jnthn> afk for 10

[08:25] *** mj41 joined
[08:41] <jnthn> back

[08:41] *** mj41 left
[08:45] <pmichaud> oh oh oh oh

[08:45] <pmichaud> duh

[08:45] <pmichaud> I think I know where the problem is.

[08:45] * jnthn figured it'd be a "duh" problem once found...

[08:45] <pmichaud>                     $save_ctx := $interactive_ctx;

[08:46] <pmichaud> $interactive_ctx is created based on HLL::Compiler in INIT.

[08:46] <pmichaud> so it has the nqp setting as its outer

[08:46] <jnthn> oh!

[08:46] <jnthn> This...explains a lot.

[08:46] <jnthn> pmichaud++

[08:47] * jnthn now feels silly for not seeing this

[08:47] <daniel-s> if I have a named rule, and it has matched several times into $<name>

[08:48] <daniel-s> I can access each match with $<name>[0]

[08:48] <tadzik> jnthn: is there something like ^get_attribute in 6model? I mean the attribute value

[08:48] <daniel-s> but for $<name> -> $name {say $name;}

[08:48] *** araujo joined
[08:48] *** araujo left
[08:48] *** araujo joined
[08:48] <daniel-s> doesn't print the $name on each line

[08:48] <daniel-s> it prints them all together

[08:48] <pmichaud> daniel-s: for $<name>.list -> $name { ... }

[08:48] <jnthn> tadzik: no

[08:49] <pmichaud> otherwise $<name> is treated as a scalar.

[08:49] <pmichaud> (and only iterates once)

[08:49] <daniel-s> ok, thank pmichaud++

[08:49] <daniel-s> *thanks

[08:49] <pmichaud> I think  for @($<name>) also works.

[08:49] <jnthn> tadzik: What're you trying to do?

[08:50] <pmichaud> jnthn: so I think the answer is that instead of setting up an outer_ctx, we really want to be setting up an outer_lex

[08:50] <tadzik> jnthn: .perl, and I wonder if pir::getattribute is still desirable in nom

[08:50] <jnthn> tadzik: .perl for...what?

[08:50] <jnthn> tadzik: Mu.perl?

[08:50] <tadzik> yes

[08:50] <jnthn> tadzik: There's an nqp::getattr

[08:51] <tadzik> ok, thansk

[08:51] <jnthn> But beware of the natives

[08:51] <daniel-s> [16:49:39] <pmichaud> I think  for @($<name>) also works.   <--- yes, it does

[08:51] <jnthn> They get nqp::getattr_i and so forth

[08:52] * jnthn suspects we'll end up putting back Attribute.get_value/Attribute.bind_value eventually

[08:52] <tadzik> Method 'substr' not found for invocant of class 'String' -- that's the circularity issue, yep?

[08:52] <jnthn> yup

[08:53] <jnthn> I guess obtaining Attribute objects is kinda annoying - you already have to go through the intropsection interface to do it. So guess it's not so bad to have those...

[08:59] <pmichaud> jnthn: okay, so now that we know what's happening... I know of a (perhaps not too clean) way to fix it 

[09:00] *** dual left
[09:02] <pmichaud> although it's a lot cleaner than what we have now.

[09:03] <jnthn> Look for a frame named interactive_ctx in lexpad_full and don't walk any further out? ;)

[09:03] <pmichaud> instead of creating a fake context and lexpad at the beginning of HLL::Compiler, we could just use the first context that gets returned from the interactive repl

[09:04] <pmichaud> (and munge its lexpad on each repl iteration)

[09:04] <jnthn> ah, maybe that'd work

[09:04] <pmichaud> it's a little messy -- e.g., if there are any active closures

[09:05] <pmichaud> we probably don't want to mess with the context's lexpad if it has any closures outstanding -- especially if we start doing slot lookups

[09:05] <pmichaud> oh, even simpler.  destroy the outer_ctx pointer on the fake context we create

[09:05] *** morphi joined
[09:05] <pmichaud> that way it won't have an outer for us to chase.

[09:06] <pmichaud> I wonder if Parrot lets me do that.

[09:07] <morphi> perl6: say 3;

[09:07] <pmichaud> looks like "no".

[09:07] <p6eval> pugs, rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«3␤»

[09:08] <jnthn> You can't set_outer_ctx to null?

[09:08] <jnthn> oh

[09:08] <pmichaud> what happens if I just do   $context := pir::new__Ps('CallContext'), I wonder?

[09:08] <jnthn> it'd be set_outer

[09:09] <pmichaud> and set_outer/set_outer_ctx are defined on Sub, not on CallContext

[09:09] <jnthn> nqp: my $a = 42; sub foo() { say $a }; &foo.set_outer(pir::null__P()); foo()

[09:09] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " 42; sub f"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[09:09] <jnthn> nqp: my $a := 42; sub foo() { say $a }; &foo.set_outer(pir::null__P()); foo()

[09:09] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3851 (src/Regex/Cursor.pir:239)␤»

[09:10] <jnthn> nqp: my $a := 42; sub foo() { say($a) }; &foo.set_outer(pir::null__P()); foo()

[09:10] <p6eval> nqp: OUTPUT«Symbol '&foo' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[09:10] <pmichaud> I don't think it's &foo in nqp.

[09:10] <jnthn> nqp: my $a := 42; sub foo() { say($a) }; foo.set_outer(pir::null__P()); foo()

[09:10] <p6eval> nqp: OUTPUT«␤»

[09:10] <pmichaud> I kind of like the new CallContext idea, fwiw.

[09:10] <pmichaud> the only thing the fake context gets used for is its lexpad.

[09:10] <pmichaud> (I think. :)

[09:11] <pmichaud> Let me try that real quick and see what happens.

[09:11] <jnthn> pmichaud: If we set_outer the thingy we use as the cumulative lexpad before it ever gets invoked, then none of the resulting contexts will have an outer.

[09:11] <jnthn> Hmm...maybe what you're thinking of works too BUT where will it get its lexpad from?

[09:11] <pmichaud> right now the thingy is an INIT block :)

[09:11] *** Tedd1 left
[09:11] <pmichaud> we give a fake lexpad same way we do now

[09:11] <pmichaud> (although that might be a PMC null error.)

[09:12] <pmichaud> I think I like your idea better.

[09:12] <pmichaud> I'll try it first.

[09:14] *** Chillance joined
[09:14] <daniel-s> how do you append to a list

[09:14] <daniel-s> ie. turn <a b> into <a b c>

[09:15] <tadzik> .push

[09:16] <daniel-s> nom: <a b>.push(<c>).say

[09:17] <p6eval> nom: OUTPUT«Method 'push' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 96 ((file unknown):10472868) (/tmp/1kJW3Xu2NV:1)␤»

[09:17] <TiMBuS> lolnom

[09:17] <daniel-s> nom: <a b>.push("c").say

[09:17] <p6eval> nom: OUTPUT«Method 'push' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 96 ((file unknown):11066788) (/tmp/8Ei4VJIGEd:1)␤»

[09:17] <daniel-s> perl6: <a b>.push("c").say

[09:17] <jnthn> A Parcel is immutable

[09:17] <p6eval> rakudo 72d158: OUTPUT«abc␤»

[09:17] <p6eval> ..pugs: OUTPUT«*** Can't modify constant item: VUndef␤    at /tmp/HETyJ_hTAB line 1, column 1 - line 2, column 1␤»

[09:17] <p6eval> ..niecza v7-19-g8dc8c8f: OUTPUT«Unhandled exception: Unable to resolve method push in class Parcel␤  at /tmp/lxxHjyNOed line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-CO…

[09:17] <daniel-s> perl6: say <a b>.push("c")

[09:17] <p6eval> pugs: OUTPUT«*** Can't modify constant item: VUndef␤    at /tmp/5CLwwpAFoA line 1, column 5 - line 2, column 1␤»

[09:17] <p6eval> ..rakudo 72d158: OUTPUT«abc␤»

[09:17] <p6eval> ..niecza v7-19-g8dc8c8f: OUTPUT«Unhandled exception: Unable to resolve method push in class Parcel␤  at /tmp/QLs79ktZQ_ line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-CO…

[09:17] <jnthn> perl6: say (<a b>, 'c').perl # create a new Parcel

[09:17] <daniel-s> works in rakudo

[09:18] <p6eval> pugs: OUTPUT«("a", "b", "c")␤»

[09:18] <p6eval> ..rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«(("a", "b"), "c")␤»

[09:18] <jnthn> nom: say (<a b>, 'c').perl # create a new Parcel

[09:18] <p6eval> nom: OUTPUT«(("a", "b"), "c")␤»

[09:18] <jnthn> Or use an array

[09:18] <TiMBuS> nom: <a b>.list.push('c').cay

[09:18] <p6eval> nom: OUTPUT«Method 'cay' not found for invocant of class 'Array'␤current instr.: '_block1002' pc 120 ((file unknown):144) (/tmp/Amz780A4ou:1)␤»

[09:18] <TiMBuS> .. say

[09:18] <jnthn> daniel-s: I wonder if it coerces it to something else first then pushes.

[09:19] <jnthn> $parcel.push feels odd to me though

[09:19] <pmichaud> $parcel.push should fail.

[09:19] <daniel-s> is the <a b>.push("c") way of doing it wrong? or just not implemented in all the implementations

[09:19] *** morphi left
[09:19] <pmichaud> nom:  <a b>.push('c').say

[09:19] <p6eval> nom: OUTPUT«Method 'push' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 96 ((file unknown):38628772) (/tmp/XhqrpJmTyD:1)␤»

[09:19] <pmichaud> nom:  <a b>.list.push('c').say

[09:19] <p6eval> nom: OUTPUT«␤»

[09:20] <TiMBuS> well thats not right is it

[09:20] <pmichaud> List.push isn't returning self.

[09:20] <pmichaud> (which is a bug, deserving a spectest.)

[09:21] <tadzik> nom: class A { has $.a }; my $a = A.new(a => 7); nqp::getattr($a, A, '$!a')

[09:21] <p6eval> nom: OUTPUT«Can not get non-existant attribute '$!a' on class 'A'␤current instr.: '_block1002' pc 104 ((file unknown):46109011) (/tmp/y5Gje_Jxlf:1)␤»

[09:21] <tadzik> hrm

[09:21] <jnthn> tadzik: Correct

[09:21] <tadzik> why so?

[09:21] <jnthn> tadzik: You need to explicitly decontainerize if you're going to use getattr

[09:21] <tadzik> oh

[09:21] <jnthn> (the $a, that is)

[09:22] <pmichaud> nom: class A { has $.a }; my $a := A.new(a => 7); nqp::getattr($a, A, '$!a')

[09:22] <tadzik> nom: class A { has $.a }; my $a = A.new(a => 7); nqp::getattr(pir::perl6_decontainerize__PP($a), A, '$!a')

[09:22] <p6eval> nom:  ( no output )

[09:22] <pmichaud> nom: class A { has $.a }; my $a := A.new(a => 7); nqp::getattr($a, A, '$!a').say

[09:22] <p6eval> nom: OUTPUT«7␤»

[09:22] <tadzik> nom: class A { has $.a }; my $a = A.new(a => 7); nqp::getattr(pir::perl6_decontainerize__PP($a), A, '$!a').say

[09:22] <p6eval> nom: OUTPUT«7␤»

[09:22] <tadzik> :)

[09:22] <jnthn> or bind like pmichaud++ showed

[09:22] <jnthn> If you have the opportunity

[09:22] <jnthn> But I guess you often don't

[09:23] <pmichaud> it's the assignment that tends to containerize.  if you avoid the assignment it's often not an issue :)

[09:23] <tadzik> I need to do it with 'self' :)

[09:23] <pmichaud> nom: class A { has $.a };  nqp::getattr(A.new(a => 7), A, '$!a').say

[09:23] <p6eval> nom: OUTPUT«7␤»

[09:24] <jnthn> tadzik: self may be containerized

[09:24] <tadzik> and may not?

[09:24] <pmichaud> I think self tends to be decontainerized -- at least it has been in all of my uses.

[09:24] <jnthn> ah

[09:25] <pmichaud> if you want the container I think you have to do    method foo(\$self:)

[09:25] <jnthn> tadzik: yeah but it's never a problem to call perl6_decontainerize on a container

[09:25] <jnthn> er, on a non-container

[09:25] <jnthn> it's just a noop then

[09:27] <tadzik> https://gist.github.com/1071441 -- Segmentation fun

[09:27] <tadzik> same effect without the decont. Any obvious mistakes I'm missing?

[09:28] <jnthn> tadzik: Not taking care of native types

[09:29] <jnthn> tadzik: I suspect we should implement Attribute.get_value though and handle that in there

[09:29] <tadzik> oh, that one is native

[09:29] <jnthn> oh

[09:30] <jnthn> you have no natively typed attrs there though

[09:30] <pmichaud> nqp::chars is a native int

[09:30] <pmichaud> can't pass that to substr

[09:31] <jnthn> oh

[09:31] <pmichaud> either use nqp::substr (and box the result), or box the result of nqp::chars, or use $_.name.chars

[09:31] <jnthn> or just use 2 arg substr? :)

[09:31] <pmichaud> or omit the parameter entirely, since   substr($_.name, 2) will g..... right

[09:32] <jnthn> tadzik: This won't work on inherited attributes though.

[09:32] <jnthn> $type

[09:32] <jnthn> oh wait

[09:32] <jnthn> $type is the name?!

[09:32] <jnthn> You need a type object there

[09:32] <jnthn> The type object of the class the attribute belongs to

[09:32] <pmichaud> self.WHAT

[09:32] <pmichaud> but yes, only works for first-level class.

[09:32] <jnthn> Right, but that's still going to be wrong for inherited.

[09:32] <pmichaud> correct.

[09:33] <daniel-s> nom: my %a; %a<a>.push("b").say

[09:33] <p6eval> nom: OUTPUT«Method 'push' not found for invocant of class 'Any'␤current instr.: '_block1002' pc 99 ((file unknown):48479263) (/tmp/xVqNMmDbph:1)␤»

[09:33] <pmichaud> we don't have autoviv arrays yet.

[09:33] <pmichaud> (in nom)

[09:33] <jnthn> tadzik: Safest way is to loop over .^mro and call .^attributes(:local) on each of them

[09:33] <tadzik> mhm

[09:33] <daniel-s> nom: my %a; say %a<a>

[09:33] <p6eval> nom: OUTPUT«Any()␤»

[09:33] <daniel-s> nom: my %a; say %a<a>, "b"

[09:33] <p6eval> nom: OUTPUT«Any()b␤»

[09:34] <daniel-s> :(

[09:34] <daniel-s> nom: my %a; [say %a<a>], "b"

[09:34] <tadzik> btw: https://gist.github.com/1071450 cheaty .WHY, but I couldn't resist :)

[09:34] <p6eval> nom: OUTPUT«Any()␤»

[09:34] *** ab5tract joined
[09:34] <daniel-s> nom: my %a; [say %a<a>].push("b")

[09:34] <p6eval> nom: OUTPUT«Any()␤»

[09:34] <daniel-s> nom: my %a; [%a<a>].push("b")

[09:34] <p6eval> nom:  ( no output )

[09:34] <jnthn> tadzik: big cheat :P

[09:34] <tadzik> still smaller than before ;)

[09:34] <daniel-s> rakudo: my %a; [%a<a>].push("b")

[09:34] <p6eval> rakudo 72d158:  ( no output )

[09:35] <jnthn> tadzik: I suspect .WHY may be macro-y

[09:35] <tadzik> no no no no

[09:35] <jnthn> Like .WHAT and so forth

[09:35] <tadzik> oh, this way

[09:36] <tadzik> I thought I'll have to wait for macros ;)

[09:36] <jnthn> tadzik: Well, question is where the doc lives

[09:36] <jnthn> No no :)

[09:36] <tadzik> jnthn: I guess the Pod will be an attibute of the Method object

[09:36] <jnthn> tadzik: Well, but you can document a bunch of things?

[09:36] <jnthn> Subs...methods...classes...attributes?

[09:36] <tadzik> yes

[09:37] <tadzik> signatures too, I think

[09:37] <jnthn> Parameters at lesat.

[09:37] <tadzik> yep

[09:38] <jnthn> We'll have a little fun here I suspect

[09:38] <jnthn> Parameter.WHY # probably the doc for the Parameter class

[09:38] <jnthn> $param.WHY # probably the doc for a parameter itself

[09:39] <tadzik> so just method WHY(:U:) and :D:, or however you write that :)

[09:39] <jnthn> Yeah

[09:39] <jnthn> I guess the :U wants to go and delegate to the meta-object

[09:39] <jnthn> .^POD or some such

[09:40] <pmichaud> lololol

[09:40] <pmichaud> jnthn: this blank context stuff is really.... funny

[09:40] <jnthn> lol? :)

[09:40] <pmichaud> if I set_outer to null, I can no longer see or set any outer lexicals.

[09:41] *** jedai left
[09:41] <jnthn> What are you setting it on?

[09:41] <pmichaud> so, I can put the context into a lexical within the sub itself... and that lexical gets clobbered as soon as I overwrite the hash :-)

[09:41] <pmichaud> (I've got it worked out... it's just funny how the values slip away)

[09:41] <jnthn> lol

[09:41] <jnthn> :)

[09:43] *** jedai joined
[09:46] <pmichaud> http://gist.github.com/1071472  # first attempt, failed  (guess why!)

[09:46] <pmichaud> http://gist.github.com/1071474 # second attempt, failed (guess why!)

[09:47] *** JodaZ left
[09:48] *** JodaZ joined
[09:48] <jnthn> first one because you killed the outer before calling it :P

[09:48] <pmichaud> ding!

[09:49] <jnthn> ok, the second one is less obvious :)

[09:49] <pmichaud> hint:  blank_context() returns PMCNULL in the second one.

[09:50] <jnthn> oh! you threw away its own lexicals!

[09:50] <pmichaud> ding!

[09:51] <jnthn> lol :)

[09:51] <jnthn> The sub! It eats itself!

[09:54] <moritz> it accidentally itself.

[09:55] <dalek> roast: ac4734b | moritz++ | S03-smartmatch/any-type.t:

[09:55] <dalek> roast: fudge any-type.t for rakudo

[09:55] <dalek> roast: review: https://github.com/perl6/roast/commit/ac4734ba38

[09:55] <jnthn> It's whole self.

[09:56] * jnthn wonders if we'll win any tests back that just incidentally used junctions 

[09:56] <jnthn> *its

[09:56] <moritz> we do

[09:56] <jnthn> \o/

[09:56] <moritz> roll.t says my current run of update_passin_test_thingy.pl

[09:57] *** wamba left
[09:57] <jnthn> moritz: There's on todo'd test in I think S03-junctions/boolean-context.t that was todo'd for Rakudo master. The clean implementation of auto-threading failed it too. I'm wondering if the test is dubious.

[09:57] *** dayangkun joined
[09:57] <dalek> rakudo/nom: aaffbef | moritz++ | t/spectest.data:

[09:57] <dalek> rakudo/nom: two more passing test files

[09:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aaffbef820

[09:58] <moritz> nom: say so(3)

[09:58] <p6eval> nom: OUTPUT«Bool::True␤»

[09:58] <moritz> nom: say so(True & False)

[09:58] <p6eval> nom: OUTPUT«Bool::False␤»

[09:58] <moritz> nom: say so(True & False) == False

[09:58] <p6eval> nom: OUTPUT«Bool::False␤»

[09:59] <pmichaud> nom: say (so True & False) == False

[09:59] <p6eval> nom: OUTPUT«Bool::True␤»

[09:59] <moritz> nom: say False == False

[09:59] <p6eval> nom: OUTPUT«Bool::True␤»

[09:59] <pmichaud> so(True & False) should be a parse error.

[09:59] <pmichaud> std:  say so(True & False);

[09:59] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[09:59] <pmichaud> or, maybe not.

[09:59] <pmichaud> I would think so would be &so

[09:59] <pmichaud> sorry

[09:59] <pmichaud> I would think  so(...) would be &so

[10:00] <jnthn> me too

[10:00] <pmichaud> pmichaud@kiwi:~/nom$ ./perl6

[10:00] <pmichaud> > say 1

[10:00] <pmichaud> 1

[10:00] <pmichaud> > say 1

[10:00] <pmichaud> 1

[10:00] <pmichaud> \o/

[10:00] <pmichaud> now to clean up the debugging and other junk I threw in :)

[10:00] <moritz> std seems to imply that 'so' should be available both as prefix and listop

[10:03] <moritz> anyway, the test failure seems to be related to so vs so(), not autothreading

[10:04] <pmichaud> double-check the definition of so in the setting.

[10:04] <pmichaud> I might've defined it as Mu

[10:04] *** wamba joined
[10:05] <moritz> and that's correct

[10:05] <pmichaud> okay :)

[10:05] <jnthn> pmichaud: yay!

[10:05] <jnthn> pmichaud++ # working out the repl issue

[10:05] <pmichaud> I can only find the one instance of <so> in std.pm6

[10:06] <moritz> it's just not available as a sub

[10:06] <moritz> std: not()

[10:06] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[10:06] <moritz> std: rand()

[10:06] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of rand(); in Perl 6 please use rand at /tmp/EMLTRMYuUq line 1:␤------> [32mrand[33m⏏[31m()[0m␤Parse failed␤FAILED 00:01 117m␤»

[10:06] <jnthn> moritz: # S32-list/pick.t                           # needs junctions

[10:06] <moritz> std: time()

[10:06] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'time' used at line 1␤Check failed␤FAILED 00:01 118m␤»

[10:06] <moritz> std: time

[10:06] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[10:06] <jnthn> moritz: Wonder if that one nearly passes now :)

[10:07] <pmichaud> jnthn: it might.  I was within a few tests when I blocked on autothreading, I think.

[10:08] <pmichaud>    token prefix:abs

[10:08] <pmichaud>         { <sym> » <?before \s*> <O(|%named_unary)> }

[10:08] <moritz> $ ./perl6 t/spec/S32-list/pick.t

[10:08] <moritz> Could not find sub !YOU_ARE_HERE

[10:08] <pmichaud> moritz: comment out the enum at the bottom

[10:08] <pmichaud> (or skip it or whatever)

[10:08] <pmichaud> ...what does the <?before \s*> do, I wonder?

[10:09] <moritz> optimize to <?> I hope

[10:09] <pmichaud> lol

[10:09] <jnthn> moritz: what?!

[10:09] <dalek> roast: 4573a92 | moritz++ | S32-list/pick.t:

[10:09] <dalek> roast: fudge pick.t for rakudo

[10:09] <dalek> roast: review: https://github.com/perl6/roast/commit/4573a92cd0

[10:09] <moritz> jnthn: \s* always matches

[10:09] <pmichaud> that's from std.pm6, btw.

[10:09] <jnthn> moritz: No, I meant !YOU_ARE_HERE error

[10:09] <moritz> there are always at least zero whitespaces

[10:10] <moritz> jnthn: related to the old enum action methods, I think

[10:10] <pmichaud> !YOU_ARE_HERE error == enum declaration

[10:10] <jnthn> moritz: oh!

[10:10] <jnthn> OK

[10:10] <pmichaud> .oO( make test.... git commit.... git push... bump NQP_REVISION .... make spectest... git commit.... git push)

[10:11] <dalek> rakudo/nom: c514e45 | moritz++ | t/spectest.data:

[10:11] <dalek> rakudo/nom: we pass a fudge pick.t

[10:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c514e45fcf

[10:11] <daniel-s> rakudo: my %a; say "there is no %a<b>" if %a<b> ~~ "Any()";

[10:11] <p6eval> rakudo 72d158: OUTPUT«there is no Any()␤»

[10:11] <daniel-s> rakudo: my %a; say 'there is no %a<b>' if %a<b> ~~ "Any()";

[10:11] <p6eval> rakudo 72d158: OUTPUT«there is no %a<b>␤»

[10:12] <pmichaud> moritz: don't forgit to commit/push the modified tests :)

[10:12] <daniel-s> is if %a<b> ~~ "Any()"; the best way to check if an element in a hash exists?

[10:12] <moritz> 12:09 <+dalek> roast: fudge pick.t for rakudo

[10:12] <dalek> nqp: 1f28be4 | pmichaud++ | src/HLL/Compiler.pm:

[10:12] <dalek> nqp: Fix handling of interactive_ctx so that it doesn't mistakenly grab

[10:12] <dalek> nqp: NQP's setting as its outer (and bring it into the HLL's contexts).

[10:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1f28be4c87

[10:12] <pmichaud> daniel-s: if %a.exists('b')

[10:12] <jnthn> dalek: no :)

[10:12] <jnthn> er, daniel-s :)

[10:12] <jnthn> what pmichaud said

[10:13] <moritz> daniel-s: you never want to ~~ 'Any()' really

[10:13] <moritz> daniel-s: rather ~~ Any

[10:13] <moritz> rakudo: say Any

[10:13] <p6eval> rakudo 72d158: OUTPUT«Any()␤»

[10:13] <huf> that test wouldnt fail much in ordinary code, no?

[10:13] <moritz> when you see Any() somewhere in the output, it just means that you see a type object

[10:14] <moritz> huf: note that by current spec, type objects stringify to '' by default

[10:14] <pmichaud> testing for "Any()"  would also find hash entries that consist of the string "Any()"  :-)

[10:14] <huf> moritz: i mean checking if something is Any

[10:14] <moritz> so that test only "works" sometimes with an outdate spec

[10:14] <huf> moritz: not the "Any()" thing

[10:14] <moritz> huf: depends on what you store in your hash

[10:14] <huf> is undef Any?

[10:15] <pmichaud> there is no more "undef"  :-)

[10:15] <huf> ah, of course

[10:15] <pmichaud> there are a number of undefined type objects

[10:15] <moritz> there are many undefs, and Any is one of them :-)

[10:16] <moritz> nom: class A { has $.bt = BackTrace.new }; say A.bt.concise;

[10:16] <p6eval> nom: OUTPUT«Cannot access attributes in a type object␤current instr.: '_block6785' pc 375738 (src/gen/CORE.setting.pir:101584) (src/gen/CORE.setting:642)␤»

[10:16] <moritz> nom: class A { has $.bt = BackTrace.new }; say A.net.bt.concise;

[10:16] <p6eval> nom: OUTPUT«Method 'net' not found for invocant of class 'A'␤current instr.: '_block1002' pc 95 ((file unknown):144) (/tmp/9fJGJ0pVXi:1)␤»

[10:16] <moritz> nom: class A { has $.bt = BackTrace.new }; say A.new.bt.concise;

[10:16] <p6eval> nom: OUTPUT«  in method <anon> at /tmp/jz8HW3nEiu:1␤  in method BUILDALL at src/gen/CORE.setting:276␤  in method bless at src/gen/CORE.setting:266␤  in method new at src/gen/CORE.setting:251␤␤»

[10:17] <jnthn> :)

[10:17] <moritz> I guess it's more robust if new() sets the backtrace

[10:17] <moritz> then we are not dependent on the number of internal method calls

[10:20] <dalek> rakudo/nom: 3803bd5 | pmichaud++ | tools/build/NQP_REVISION:

[10:20] <dalek> rakudo/nom: Bump NQP_REVISION so we get the interactive context fix and our

[10:20] <dalek> rakudo/nom: REPL starts working again.  jnthn++

[10:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3803bd599d

[10:20] <pmichaud> \o/

[10:20] <pmichaud> finding that bug was more fun than it should've been.

[10:21] *** drbean joined
[10:21] <pmichaud> well, I'll get some sleep now, at least a short bit before I have to get the kids up

[10:21] <pmichaud> bbl

[10:21] <jnthn> pmichaud++ 

[10:22] <moritz> sleep well pmichaud++

[10:22] <jnthn> sleep well, even if breifly

[10:22] *** drbean left
[10:29] *** daniel-s is now known as daniel-ss

[10:29] *** Jackneill joined
[10:29] *** Jackneill left
[10:29] *** Jackneill joined
[10:29] *** daniel-ss is now known as daniel-s

[10:30] *** mj41 joined
[10:32] *** daniel-s is now known as daniel-ss

[10:33] *** daniel-ss is now known as daniel-s

[10:36] *** dayangkun left
[10:46] *** daxim joined
[10:48] *** im2ee_ is now known as im2ee

[10:52] *** mj41 left
[11:00] *** awoodland joined
[11:04] *** Transbot joined
[11:04] <daniel-s> moritz: you're German, correct?

[11:05] *** whiteknight joined
[11:07] *** Transbot left
[11:13] <moritz> daniel-s: correct

[11:13] *** mj41 joined
[11:14] *** Transbot joined
[11:14] <daniel-s> !transde hello moritz, how are you today?

[11:14] <Transbot> hallo moritz, wie geht es Ihnen heute?

[11:15] <daniel-s> !transen bist du gut?

[11:15] <Transbot> are you well?

[11:15] <moritz> !transen danke, ich kann mich nicht beklagen

[11:15] <Transbot> thank you, I can not complain

[11:16] <jnthn> !transen Ich will ein Bier mit Currywurst!

[11:16] <Transbot> I want a beer with sausage!

[11:16] <jnthn> The curry! It lost the curry!

[11:16] <moritz> it doesn't do the curyying very well, it seems :-)

[11:16] <moritz> !transen Weißwurst

[11:16] <Transbot> White sausage

[11:16] <jnthn> I assume not.

[11:16] <moritz> !transen Bratwurst

[11:16] <Transbot> Bratwurst

[11:16] <daniel-s> lol

[11:17] <moritz> daniel-s: does it use the Google Translate API?

[11:17] <daniel-s> yea

[11:17] <daniel-s> which apparently they're going to get rid of in a few months

[11:17] <jnthn> !transen blutwurst

[11:17] <Transbot> pudding

[11:17] <daniel-s> it does subscriptions too

[11:17] <jnthn> hm :)

[11:17] <daniel-s> so if you use !pmde username

[11:18] <daniel-s> it will PM you everything username says in german

[11:18] <daniel-s> and !pmen for german to english

[11:18] <moritz> cool

[11:18] <moritz> daniel-s++

[11:18] <jnthn> Neat bot :)

[11:18] <jnthn> daniel-s++

[11:18] <daniel-s> that's mostly what I did it for, because I was on a channel with alot of german people

[11:19] <jnthn> .oO( seems all the German words I know relate to food :) )

[11:23] *** Transbot left
[11:24] *** mj41 left
[11:38] *** mj41 joined
[11:40] <tadzik> std: my $=HRR

[11:40] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[11:40] <tadzik> hmm

[11:42] *** satyavvd left
[11:43] *** mj41 left
[11:43] <tadzik> what is the role of <?before> in token twigil:sym<:> { <sym> <?before \w> } ?

[11:44] <jnthn> Avoiding some parse issue

[11:44] <jnthn> Maybe with the : param sep

[11:44] <tadzik> std doesn't have that

[11:44] *** MayDaniel joined
[11:45] <tadzik> ok, I'll check '=' both with and without :)

[11:45] <jnthn> STD does have proto token twigil is endsym<begid> {*}

[11:45] <jnthn> I dunno exactly what that does but suspect it may be related.

[11:46] <tadzik> but I still feel dizzy about having a twigil '=' for documentation variables, where $=POD is the only one in the whole spec

[11:46] <jnthn> ah, yes token begid { <?before \w> }

[11:46] <jnthn> tadzik: Yeah, that does feel odd

[11:46] <jnthn> tadzik: I still wonder if $?POD wouldn't make sense.

[11:47] <tadzik> well, maybe we could stick the whole .WHY tree for classes in $=WHY or something, it'd make it easier to search for them

[11:48] <jnthn> Search for them?

[11:48] <tadzik> or would it? $=FooBar::WHY looks like a typo :)

[11:48] <flussence> .oO( being able to walk that tree would be nice... )

[11:48] * jnthn had figured we'd attach the POD to the correct declarand at parse time or so

[11:48] <tadzik> jnthn: say you want to get a documentation for Benchmark.pm6, it's a module, and exports 4 subs

[11:48] <tadzik> jnthn: yes, but you don't neceserilly know the names

[11:49] <tadzik> it's just a wild guess, or I'm just desperately trying to figure out a use of $=

[11:55] <TimToady> thing is, $? is lexically scoped, and $= is only file scoped

[11:56] <TimToady> and the = is to remind you of the pod =

[11:56] <jnthn> TimToady: If it's installed in UNIT, is there much of a difference?

[11:56] <TimToady> it's more of a brane issue than a computer issue

[11:56] <jnthn> *nod*

[11:57] <jnthn> I've nothing against the twigil for POD, I just agree with tadzik a bit that it feels odd we only have one variable

[11:57] <jnthn> Also, if it's the array of all POD blocks I don't know why it's $=POD and not @=POD

[11:57] <jnthn> Then for @=POD -> $block { } would dtrt

[11:57] <TimToady> think of $=POD as a placeholder

[11:58] <TimToady> but S26 kinda ran with it, I guess

[11:59] <TimToady> shower

[12:02] <TimToady> or look at it this way, lots of things that are documented to have $=POD on the front could have that factored away if they're named lookups

[12:02] <TimToady> really &

[12:02] <tadzik> jnthn: S26 says nothing about whether $=POD should be an array or something else

[12:03] <tadzik> that's merely my interpretation

[12:04] *** JimmyZ joined
[12:06] <[Coke]> daniel-s: what are you using for the backend translations? google?

[12:06] *** drbean joined
[12:06] <jnthn> tadzik: ah, k

[12:07] *** MayDaniel left
[12:07] <[Coke]> (I wired up a bot on an ascii-only chat server, and was sad to find out that google translat API is getting turned off this year.)

[12:07] *** Jackneill left
[12:15] <JimmyZ> good evening, #perl6

[12:16] *** alim left
[12:17] *** Instil left
[12:17] *** alim joined
[12:18] *** wamba left
[12:24] *** [Coke] left
[12:26] *** [Coke] joined
[12:26] <daniel-s> [Coke]: yea, google translate

[12:27] <daniel-s> I don't know of anything else

[12:27] <daniel-s> If you find out though, let me know

[12:27] *** agentzh left
[12:30] <[Coke]> eh. I'd been using babelfish before that, but google is much better.

[12:34] *** smash joined
[12:35] <smash> hello everyone

[12:35] <tadzik> hello smash 

[12:35] <jnthn> hi smash 

[12:41] <moritz> niecza: say [*] 1..6

[12:41] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«720␤»

[12:41] <moritz> niecza: say [*] 1.."6"

[12:41] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«0␤»

[12:42] <moritz> perl6: say [*] 1.."6"

[12:42] <p6eval> pugs, rakudo 72d158: OUTPUT«720␤»

[12:42] <p6eval> ..niecza v7-19-g8dc8c8f: OUTPUT«0␤»

[12:45] <[Coke]> nom: "smash".comb.say

[12:45] <p6eval> nom: OUTPUT«Method 'comb' not found for invocant of class 'Str'␤current instr.: '_block1002' pc 75 ((file unknown):36162976) (/tmp/0rK26HkWS2:1)␤»

[12:46] <[Coke]> nom: <s m a s h>.comb.say

[12:46] <p6eval> nom: OUTPUT«Method 'comb' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 106 ((file unknown):79) (/tmp/l9Y5zOSAah:1)␤»

[12:46] <[Coke]> ah well.

[12:46] <moritz> comb (with arguments) needs regexes

[12:46] <moritz> that's why we don't have it yet

[12:47] <[Coke]> sadface!

[12:52] *** [Coke] left
[12:54] *** [Coke] joined
[12:56] *** bluescreen10 joined
[12:57] *** perlhack joined
[12:58] <perlhack> :-)

[12:58] *** xhacktly joined
[13:03] *** daemon joined
[13:05] <daniel-s> [Coke]: so I can just fall back to babelfish when the google API goes away?

[13:05] <daniel-s> is it just like the google one

[13:05] <daniel-s> or similar anyway?

[13:08] <[Coke]> ISTR I had to screen scrape it. :(

[13:08] * moritz -> afk

[13:08] <dalek> rakudo/nom: 203aea2 | moritz++ | src/core/Str.pm:

[13:08] <dalek> rakudo/nom: add argumentless Str.comb to make [Coke]++ happy

[13:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/203aea21a5

[13:09] <[Coke]> happyface!

[13:09] *** perlhack left
[13:14] *** im2ee left
[13:14] *** im2ee joined
[13:22] *** xhacktly left
[13:28] *** drbean left
[13:31] *** im2ee left
[13:32] *** im2ee joined
[13:37] *** whiteknight left
[13:43] *** masak joined
[13:43] <masak> <sorear> Why is "0" false?

[13:44] <colomon> tradition!

[13:44] <masak> because it makes a lot of sense to write 'if not $beers_left' or 'if not @buildings'.

[13:53] <masak> the lack of punning of 0 to false is the only direct drawback I've found so far with Lua.

[13:53] <masak> sorear: oh! or did you mean "0" the string?

[13:53] <masak> you probably did.

[13:53] * jnthn read it as "0" the string

[13:54] <jnthn> But the arguments kinda still hold. 

[13:54] <jnthn> It's useful.

[13:54] <masak> I'm less eager to defent that punning now that we have types.

[13:54] <masak> I can't think of a use case right now.

[13:54] <masak> perhaps reading from STDIN or something.

[13:54] <jnthn> Having types doesn't change the fact that data you read in from the outside world comes in as strings.

[13:54] <jnthn> Well, or just anywhere :)

[13:56] <masak> sure, but having ?"0" be False feels like a fairly feeble way to compensate for that, to be honest.

[13:56] <masak> I dunno, it feels like a tiny solution to a much bigger general issue.

[13:56] <masak> why isn't ?"0.0" false, for example?

[13:56] *** MayDaniel joined
[13:56] <masak> what about ?"0e1" ?

[13:57] <masak> what makes "0" so special?

[14:01] *** REPLeffect left
[14:03] <masak> perl6: say ?"0.0"; say ?"0e1"

[14:03] <p6eval> pugs: OUTPUT«1␤1␤»

[14:03] <p6eval> ..rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«Bool::True␤Bool::True␤»

[14:04] <masak> so yes, why *is* "0" false?

[14:05] <flussence> so "while($int--)" works, presumably - that wouldn't work for floats in any language.

[14:07] <flussence> (also people might be using the magic string++/-- things...)

[14:10] <masak> flussence: note that we're not talking about Int and 0, but about Str and "0".

[14:10] <flussence> rakudo: my $i = '00g'; say $i while ($i--);

[14:10] <p6eval> rakudo 72d158: OUTPUT«00f␤00e␤00d␤00c␤00b␤00a␤»

[14:10] <flussence> hm.

[14:11] <JimmyZ> ?"0".Int

[14:12] <JimmyZ> perl6: say ?"0.0".Int

[14:12] <p6eval> pugs: OUTPUT«*** No such method in class Str: "&Int"␤    at /tmp/qXls9lLbJf line 1, column 5 - line 2, column 1␤»

[14:12] <p6eval> ..rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«Bool::False␤»

[14:12] <JimmyZ> well, it's false

[14:12] <flussence> rakudo: say (?"0.0").Int

[14:12] <p6eval> rakudo 72d158: OUTPUT«1␤»

[14:13] <JimmyZ> perl6: say ?"0e1".Int

[14:13] <p6eval> pugs: OUTPUT«*** No such method in class Str: "&Int"␤    at /tmp/YwqQE_dBP_ line 1, column 5 - line 2, column 1␤»

[14:13] <p6eval> ..rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«Bool::False␤»

[14:13] <JimmyZ> false again :)

[14:13] <JimmyZ> it's a mess?

[14:14] <masak> at least it's not terribly consistent.

[14:15] <flussence> well it's useful to have a string representation of 0 mean false, but it's not worth typecasting every non-empty string to a Num just to see whether to return false...

[14:16] <flussence> and besides, I question the sanity of anyone using scientific notation for bools :)

[14:16] <JimmyZ> perl6: say ?"1e1".Int

[14:16] <p6eval> rakudo 72d158, niecza v7-19-g8dc8c8f: OUTPUT«Bool::True␤»

[14:16] <p6eval> ..pugs: OUTPUT«*** No such method in class Str: "&Int"␤    at /tmp/Z7sBCr8cfk line 1, column 5 - line 2, column 1␤»

[14:16] <JimmyZ> perl6: say ?"0sfsdfsdf23".Int

[14:17] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«Unhandled exception: System.FormatException: Unknown char: s␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) [0x…

[14:17] <p6eval> ..rakudo 72d158: OUTPUT«Bool::False␤»

[14:17] <p6eval> ..pugs: OUTPUT«*** No such method in class Str: "&Int"␤    at /tmp/Bw30yfc6i0 line 1, column 5 - line 2, column 1␤»

[14:17] <masak> flussence: there are several string representations for the magnitude zero. why does one of them get special treatment when boolified?

[14:17] *** leprevost joined
[14:22] *** explorer__ joined
[14:24] *** jferrero left
[14:26] <flussence> I don't have a better answer than "everyone else does it" :)

[14:28] <[Coke]> for the devil's advocate: what string values do you propose evaluate to true/false?

[14:28] <[Coke]> I would say "" is false. Anything that doesn't numify to a false value is true. Everything else is probably up for debate.

[14:29] *** ab5tract left
[14:29] <[Coke]> if this were ColdFusion or tcl, we could have "false" and "no" be False. ;)

[14:29] *** tokuhir__ joined
[14:29] <flussence> basically it's consistent with what other languages do when boolifying strings, and we've already got .chars/.Int if you prefer a different definition of true/false

[14:30] <flussence> (mind you, I've only checked in perl5/php...)

[14:30] <flussence> oh, python just *has* to be different...

[14:31] <[Coke]> bah. I want a "make spectest" target that actual records everything.

[14:31] <[Coke]> *actually

[14:33] <flussence> `make rakudo_test_run.tar.gz`?

[14:33] <flussence> (that should get a TAP::Archive file, is that good enough?)

[14:34] <daniel-s> [Coke]: I might try tomorrow at creating a library to scrape from the google translate website

[14:34] <daniel-s> if it's straightforward html that comes back from a http post or get, it might be doable

[14:35] <daniel-s> but that would especially suck because no doubt, google would keep changing it

[14:35] <[Coke]> flussence: going with shell wonkery for now.

[14:37] *** daniel-s left
[14:42] *** wtw left
[14:42] <[Coke]> I wish to learn Chinese.

[14:42] <[Coke]> Any pointers? 

[14:42] <[Coke]> aside from trading with perlhack? ;)

[14:42] *** jack-ji joined
[14:46] <masak> [Coke]: congratulations! a good investment, and much fun ahead.

[14:47] <masak> [Coke]: what can I say? get a good textbook. preferably with audio material. I have suggestions if you want them.

[14:47] <masak> [Coke]: make sure you practice at least an hour or two a day.

[14:47] <masak> :)

[14:48] * [Coke] knows that mandarin is sort-of-kind-of on the curriculum in his kid's district, I wonder if there are any local resources.

[14:49] * [Coke] suspects it's not worth running spectest_full at the moment.

[14:49] <[Coke]> ;(on nom)

[14:49] <flussence> it's already up to a quarter of what master passes!

[14:50] *** fhelmberger left
[14:56] *** im2ee left
[14:57] *** im2ee joined
[14:58] *** Tedd1 joined
[15:03] <pmichaud> good morning, #perl6

[15:05] *** _jaldhar left
[15:06] <jnthn> o/, pmichaud 

[15:06] <masak> good morning, pmichaud

[15:12] *** alim left
[15:13] <JimmyZ> good morning, pmichaud 

[15:14] *** daniel-s joined
[15:17] *** daniel-s left
[15:19] *** spq1 joined
[15:21] *** colomon left
[15:24] *** thou joined
[15:26] *** alester left
[15:26] *** donri joined
[15:27] *** colomon joined
[15:27] *** leprevost left
[15:37] *** alester joined
[15:40] *** alester left
[15:42] *** daxim left
[15:42] *** im2ee left
[15:50] *** masak left
[15:52] *** Jackneill joined
[16:14] <JimmyZ> nom run ./perl6 -e "" is into interactive mode, is it a bug?

[16:15] *** awoodland left
[16:18] <jnthn> JimmyZ: Sounds like.

[16:19] <JimmyZ> jnthn: I think so, master isn't interactive mode

[16:23] <jnthn> It's feasibly a regression when translating various bits of HLL::Compiler from PIR to NQP.

[16:24] *** dakkar joined
[16:25] *** [Coke] left
[16:26] *** [Coke] joined
[16:33] <dalek> roast: 1df028a | jonathan++ | S12-class/basic.t:

[16:33] <dalek> roast: Re-fudge S12-class/basic.t for nom (we win 2, lose one, but it's due to an eval bug rather than a bug in what it's testing, it seems).

[16:33] <dalek> roast: review: https://github.com/perl6/roast/commit/1df028a289

[16:37] <dalek> roast: 5031753 | jonathan++ | S12-class/instantiate.t:

[16:37] <dalek> roast: Update a test to match latest spec (though we can't actually run it in Rakudo yet - no regexes.)

[16:37] <dalek> roast: review: https://github.com/perl6/roast/commit/5031753250

[16:43] <JimmyZ> jnthn: does $.a also declares $!a ?

[16:43] *** dakkar left
[16:43] <jnthn> JimmyZ: yes

[16:44] <dalek> rakudo/nom: 25767e9 | jonathan++ | src/Perl6/ (2 files):

[16:44] <dalek> rakudo/nom: Factor out package redeclaration logic so we'll be able to re-use it for all the various type-y declarators, and make it a bit smarter, e.g. so tadzik++ can declare a Block in Pod.

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25767e9395

[16:44] <dalek> rakudo/nom: f5c0a44 | jonathan++ | src/core/Mu.pm:

[16:44] <dalek> rakudo/nom: First cut of clone, though probably not quite deep enough yet for many objects.

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5c0a44ff5

[16:44] <dalek> rakudo/nom: bb5852a | jonathan++ | src/Perl6/SymbolTable.pm:

[16:44] <dalek> rakudo/nom: Fix redeclaration detection for nested classes.

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bb5852ad2d

[16:44] <dalek> rakudo/nom: 73518c8 | jonathan++ | t/spectest.data:

[16:44] <dalek> rakudo/nom: Run S12-class/basic.t.

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/73518c8dc5

[16:44] <dalek> rakudo/nom: 9420d14 | jonathan++ | NOMMAP.markdown:

[16:44] <dalek> rakudo/nom: Update nommap.

[16:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9420d1406e

[16:44] <JimmyZ> jnthn:  I didn't find where spec said, I just find spec says $brain also declares $!brain

[16:45] *** aindilis joined
[16:46] <jnthn> JimmyZ: I think it says it declares an attribute and an accessor method.

[16:47] <dalek> rakudo/nom: bf66171 | jonathan++ | src/core/Mu.pm:

[16:47] <dalek> rakudo/nom: Make sure $obj.Mu::new() style delegation works.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf66171d7b

[16:47] <dalek> rakudo/nom: ca81dd4 | jonathan++ | t/spectest.data:

[16:47] <dalek> rakudo/nom: We now pass S12-construction/new.t - or as much as master does, anyway.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca81dd4ec6

[16:49] *** MayDaniel left
[16:50] *** jack-ji left
[16:50] <JimmyZ> jnthn: I din't find where spec says $.a also declares $!a :( .   I just find this one  S12:649

[16:52] *** nothingmuch joined
[16:53] <jnthn> JimmyZ: Hmm, it could be clearer on that, I agree.

[16:53] *** MayDaniel joined
[16:55] *** JimmyZ left
[16:55] *** Holy_Cow joined
[16:55] *** Holy_Cow left
[16:56] <[Coke]> jnthn: how many test now? huh? Huh? HUH?

[16:56] <[Coke]> *tests

[16:58] <tadzik> jnthn++ # thanks! :)

[16:59] <tadzik> will try that in a sec

[17:01] <jnthn> [Coke]: I think we're well over 5K, but some way to go to 6K :)

[17:01] <jnthn> Though at current rate "some way" may easily mean a day or two :)

[17:03] <[Coke]> once regexes land, how long do you think until nom->master ?

[17:03] *** birdwindupbird left
[17:04] *** cdarroch joined
[17:04] *** cdarroch left
[17:04] *** cdarroch joined
[17:04] <[Coke]> that's a bad question. let me check the NOMMAP.

[17:04] <jnthn> :)

[17:05] <jnthn> [Coke]: Yeah, it's hard to say. Don't know how much other stuff stuff will be done between now and regexes landing.

[17:05] <jnthn> [Coke]: Once they do I think it'll be time to focus on the module ecosystem though.

[17:05] <jnthn> [Coke]: And get a feel for what needs taking care of to have a bunch of modules run again.

[17:06] *** am0c joined
[17:06] <jnthn> afk for a while, going to visit masak++ :)

[17:06] <thou> perl6: sub doit(Str $text is rw) { $text ~= '!'; say $text; }; my $foo = 'foo'; doit(~$foo); say $foo;

[17:06] <p6eval> pugs: OUTPUT«*** Can't modify constant item: VStr "foo"␤    at /tmp/MZkoWiyLSx line 1, column 29-41␤»

[17:06] <p6eval> ..niecza v7-19-g8dc8c8f: OUTPUT«Unhandled exception: Binding Str $text is rw in MAIN doit, cannot bind read-only value to is rw parameter␤  at /tmp/1NV0wKPb_o line 0 (MAIN doit @ 0) ␤  at /tmp/1NV0wKPb_o line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE…

[17:06] <p6eval> ..rakudo 72d158: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in 'doit' at line 22:/tmp/z70jeXq8f9␤  in main program body at line 22:/tmp/z70jeXq8f9␤»

[17:07] <[Coke]> jnthn: ~~!

[17:14] *** MayDaniel left
[17:16] *** metaperl_ joined
[17:16] *** metaperl_ left
[17:19] *** wamba joined
[17:24] *** stepnem left
[17:25] *** wamba left
[17:26] <tadzik> jnthn: now how do I handle cases like Pod::Block::Named? Block package inside the Pod package?

[17:26] *** stepnem joined
[17:27] <tadzik> oh wait, it just works. Nvm, forgot a .new :)

[17:29] *** REPLeffect joined
[17:34] *** tokuhir__ left
[17:35] *** birdwindupbird joined
[17:38] *** [particle] left
[17:43] <tadzik> jnthn: I get a Could not locate compile-time value for symbol Pod::Block::Named when adding a Pod::Block::Named to the SymbolTable, want to take a look?

[17:50] *** [particle] joined
[17:51] *** [particle] left
[17:53] *** [particle] joined
[18:01] *** cognominal left
[18:03] *** cognominal joined
[18:07] *** mkramer1 joined
[18:18] *** wamba joined
[18:28] *** lue left
[18:30] *** lue joined
[18:32] *** birdwindupbird left
[18:32] *** wamba left
[18:33] *** mkramer1 left
[18:36] *** Bzek left
[18:38] <lue> Here's my comb patch (which I worked on last night):  https://gist.github.com/1072463 [feel free to ignore and do a much better job if I messed something up :)]

[18:42] <lue> Oh! I just noticed moritz added an argumentless variant of comb.

[18:43] <thou> \o/ november made a new page on my web site: http://postimage.org/image/1vx5gn8as/8d301d9a/

[18:46] *** Jackneill left
[18:48] <lue> ping $nom_people (question about comb)

[18:49] <moritz> lue: pong

[18:50] <lue> I just noticed you wrote a comb method a couple hours ago. My patch of comb [which I worked on last night], tries to implement the $limit as well.

[18:51] <lue> [Which, being an idiot, I _just now_ decided to test the $limit part, and discover it doesn't work]

[18:51] <moritz> lue: and since named arguments are passed by *name*, it's essential that you get the name right

[18:51] <moritz> lue: lim vs. limit

[18:53] <lue> Yeah. I forgot that :$ meant named argument, and when I remembered that, I didn't think of that.

[18:55] <lue> ...sigh. Now I know I why the limiting part "failed" for me just now; I tried using the number as a positional argument /me slaps self in head

[18:56] *** dolmen joined
[18:59] <lue> According to the spec [S32/Str], $limit isn't even a named argument.

[19:04] *** quiccker left
[19:04] *** REPLeffect left
[19:04] *** REPLeffect joined
[19:08] *** mkramer joined
[19:09] *** kytibe joined
[19:14] *** Moukeddar joined
[19:15] <Moukeddar> Hello ;)

[19:15] <lue> hello o/

[19:15] <tadzik> hello Moukeddar

[19:15] <Moukeddar> how are you all doing ?

[19:16] <Moukeddar> missed you all :)

[19:16] <tadzik> oh cool. Then new Rakudo branch is evolving rapidly

[19:17] *** [Coke] left
[19:19] <Moukeddar> today i saw a car named Parrot

[19:19] <Moukeddar> #perl6 came immediately to my mind

[19:19] *** [Coke] joined
[19:21] *** wamba joined
[19:21] <thou> \o/ got my apache config tweaked so november looks pretty  http://postimage.org/image/2m6teqqg4/99e42fc7/

[19:22] <Moukeddar> the simplicity is awesome :)

[19:23] <Moukeddar> good work :)

[19:23] <thou> Moukeddar: well, didn't design the pages. just getting masak++ 's software running again after some time of bitrot

[19:23] <Moukeddar> you know what they say

[19:23] <tadzik> cute :)

[19:23] <tadzik> thou: what is the webserver running it?

[19:23] <Moukeddar> Great people steal ot copy ?

[19:24] <Moukeddar> Apache he said

[19:24] <tadzik> oh, so it's running perl6 as a cgi?

[19:24] <Moukeddar> look at the search bar :)

[19:24] <Moukeddar> it says it all 

[19:24] <thou> tadzik: apache2, just hacking things together because november borks unless it's at the root of the web url space

[19:25] <tadzik> I see

[19:25] <thou> that is host:port/view/Page works, but host:port/wiki/view/page fails

[19:25] <tadzik> thou: have you thought of using Perl6's HTTP::Server::Simple?

[19:25] <Moukeddar> i must try running it on IIS7.5

[19:25] <thou> tadzik: yes, but i have to convert november to use psgi

[19:25] <tadzik> sounds like fun :)

[19:25] <thou> and i wanted to get it running as is first

[19:25] <tadzik> sure thing

[19:25] <thou> yeah

[19:25] *** smash left
[19:25] <thou> i want to convert to web.pm, and then it'll have psgi for free i believe

[19:26] <thou> but to do that i have to get Web.pm out of bitrot, as i understand it

[19:26] <thou> so ... one thing at a time :-)

[19:26] <tadzik> I don't think Web.pm uses PSGI

[19:26] *** Moukeddar left
[19:26] <tadzik> Web.pm is passing its tests on master for some time now, methinks

[19:26] <thou> ah, ok. i hadn't tried it yet

[19:27] <thou> mebby someone was talking about getting it to run on nom ;-)

[19:27] <colomon> on niecza, as I remember the conversation

[19:27] <thou> if web.pm doesn't use psgi, i'm not sure what it's good for

[19:27] <sorear> good * #perl6

[19:28] <sorear> o/ colomon

[19:28] <colomon> speak of the devil....

[19:28] <thou> bye, sorear

[19:28] <colomon> o\

[19:28] <thou> or hello

[19:28] * thou is never sure if "good *" is a greeting or farewell

[19:28] <colomon> depends on whether you're arriving or leaving!

[19:29] <tadzik> it's like "good" ~ any("morning", "afternoon", "evening"), as I understand it

[19:29] <thou> yeah

[19:29] <thou> ok, i guess it's more like a greeting than a farewell

[19:31] <thou> rakudo: say 'goodmorning' ~~ "good" ~ any(<morning afternoon evening>)

[19:31] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[19:31] <thou> rakudo: say 'goodmorning' ~~ "good" ~ [|] <morning afternoon evening>

[19:31] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[19:32] <thou> i guess my problem was i always add <night bye> into that list....

[19:32] <moritz> well, you can use it tha way too :-)

[19:32] <jlaire> rakudo: class C { has Int $.x; method Str() { $.x } }; say C.new(:a(42)).Str.WHAT

[19:32] <p6eval> rakudo 72d158: OUTPUT«Any()␤»

[19:33] <jlaire> rakudo: class C { has Int $.x; method Str() { $.x } }; say C.new(:a(42)).Str().WHAT

[19:33] <p6eval> rakudo 72d158: OUTPUT«Any()␤»

[19:33] <thou> nom: say 'goodmorning' ~~ "good" ~ [|] <morning afternoon evening>

[19:33] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Any $x)␤:(Str $a, Str $b)␤:(Any $a, Any $b)␤␤current instr.: 'infix:<~>' pc 353352 (src/gen/CORE.setting.pir:90433) (src/gen/CORE.setting:1590)␤»

[19:33] <thou> std: say 'goodmorning' ~~ "good" ~ [|] <morning afternoon evening>

[19:33] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 121m␤»

[19:33] <jlaire> rakudo: class C { has Int $.x; method Str() { $.x } }; say C.new(:x(42)).Str().WHAT

[19:33] <p6eval> rakudo 72d158: OUTPUT«Int()␤»

[19:33] <thou> niecza: say 'goodmorning' ~~ "good" ~ [|] <morning afternoon evening>

[19:33] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«Bool::False␤»

[19:33] <jlaire> rakudo: class C { has Int $.x; method Str() { $.x } }; say (~C.new(:x(42))).WHAT

[19:33] <p6eval> rakudo 72d158: OUTPUT«Str()␤»

[19:34] <thou> niecza: say 'goodmorning' ~~ "good" ~ any(<morning afternoon evening>)

[19:34] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«Bool::False␤»

[19:34] <sorear> ~ doesn't autothread

[19:34] <sorear> phenny: de en "hello moritz, how are you today?"

[19:35] <sorear> phenny: de en "hello moritz, how are you today?"?

[19:35] <phenny> sorear: "moritz hello, how are you today?" (de to en, translate.google.com)

[19:35] <sorear> phenny: en de "hello moritz, how are you today?"?

[19:35] <phenny> sorear: "hallo moritz, wie geht es Ihnen heute?" (en to de, translate.google.com)

[19:35] <sorear> phenny: tell daniel-s We already have a translator bot, phenny: en de "hello moritz, how are you today?"?

[19:35] <phenny> sorear: I'll pass that on when daniel-s is around.

[19:35] *** benabik left
[19:35] <pmichaud> nom:  say 'goodmorning' ~~ 'good'~any(<morning afternoon evening>);  

[19:35] <p6eval> nom: OUTPUT«Bool::True␤»

[19:35] <pmichaud> \o/

[19:36] <sorear> phenny: tell masak ("0") - #p5p is seriously talking about making "" the only false string.  "0" falseness is a pretty disgusting Perlism imo

[19:36] <phenny> sorear: I'll pass that on when masak is around.

[19:36] <sorear> phenny: tell masak oh, and it's really annoying to work around.  I can't use if $name in niecza because "0" is often a valid name, but "" never is

[19:36] <phenny> sorear: I'll pass that on when masak is around.

[19:37] * [Coke] wonders if our plethora of bots is /documented/ anywhere.

[19:37] <sorear> nom: say chars [~] 1..10000

[19:37] <p6eval> nom: OUTPUT«(timeout)»

[19:37] <sorear> niecza: say chars [~] 1..10000

[19:37] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«38894␤»

[19:38] <sorear> pmichaud: the fundamental difference here is that niecza has ~ as list-associative

[19:39] <thou> does anyone know if it's correct that a ~ (string contextualizer) turns a var into read-only?

[19:39] <thou> perl6: sub doit(Str $text is rw) { $text ~= '!'; say $text; }; my $foo = 'foo'; doit(~$foo); say $foo;

[19:39] <p6eval> niecza v7-19-g8dc8c8f: OUTPUT«Unhandled exception: Binding Str $text is rw in MAIN doit, cannot bind read-only value to is rw parameter␤  at /tmp/mlIUcIOUGm line 0 (MAIN doit @ 0) ␤  at /tmp/mlIUcIOUGm line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE…

[19:39] <p6eval> ..rakudo 72d158: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in 'doit' at line 22:/tmp/np8HqCSBQk␤  in main program body at line 22:/tmp/np8HqCSBQk␤»

[19:39] <p6eval> ..pugs: OUTPUT«*** Can't modify constant item: VStr "foo"␤    at /tmp/DgIG_3hFnN line 1, column 29-41␤»

[19:39] <sorear> thou: imo, yes

[19:40] <thou> this is something that changed in rakudo since the last time november was working; i've changed several "is rw" to "is copy" (since the modification wasn't really needed in upper scope anyways, fortunately)

[19:41] <thou> i guess there is probably spec tests for this

[19:42] <pmichaud> thou: think of it this way:

[19:42] <pmichaud> my Int $foo = 3;  doit(~$foo)

[19:42] <pmichaud> the contextualizer *cannot* change $foo to a string.

[19:42] <pmichaud> it has to produce a read-only value that is the string representation of $foo

[19:43] <thou> ok.

[19:43] <thou> i knew that.

[19:43] <thou> i was thinking "but it's just a contextualizer; if it's already a Str, it should be a no-op"

[19:44] *** [Coke] left
[19:44] <thou> but really if you're gonna depend on it already being a string in the code, then you shouldn't write the contextualizer in the first place

[19:44] <thou> any meaningful use of the ~ requires it to be ro

[19:44] <thou> thanks

[19:46] *** [Coke] joined
[19:47] <thou> \o/ got /history/Page working

[19:51] *** lichtkind joined
[19:52] <lichtkind> thou: are you softmoth?

[19:52] <thou> yep

[19:52] <thou> i'm polyidentical

[19:52] <thou> unfortunately

[19:54] <lichtkind> thou: thats fine just for my orientation

[19:56] *** [Coke] left
[19:58] *** [Coke] joined
[19:58] *** mkramer left
[20:03] *** nnunley joined
[20:05] <thou> seems all the links that are exposed to the user are now working in november

[20:06] <thou> (missing is the /register link, which apparently was not quite completed)

[20:06] <thou> i'll try to clean up my work and commit

[20:06] <tadzik> great! :)

[20:06] <tadzik> thou++

[20:09] *** soh_cah_toa joined
[20:09] *** [Coke] left
[20:11] *** [Coke] joined
[20:11] *** Zapelius joined
[20:15] *** [Coke] left
[20:16] *** kaare_ left
[20:17] *** [Coke] joined
[20:19] *** cdarroch left
[20:24] <dalek> rakudo/nom: 5ea35d9 | Coke++ | t/spectest.data:

[20:24] <dalek> rakudo/nom: This (commented out) test file doesn't exist.

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ea35d9e94

[20:25] *** [Coke] left
[20:27] *** [Coke] joined
[20:31] *** envi left
[20:32] *** [Coke] left
[20:34] *** [Coke] joined
[20:35] <[Coke]> can t/spec/S07-iterators/range-iterator.t be deleted?

[20:35] <[Coke]> std: our Int $foo = 0;

[20:35] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 121m␤»

[20:38] <sorear> generally test files don't get deleted

[20:39] <dalek> rakudo/nom: bafbc15 | Coke++ | t/spectest.data:

[20:39] <dalek> rakudo/nom: Alphabetize & note failure cause.

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bafbc155ee

[20:40] *** [Coke] left
[20:42] *** [Coke] joined
[20:45] <dalek> roast: 008d2e5 | Coke++ | S02-builtin_data_types/assigning-refs.t:

[20:45] <dalek> roast: untodo passing test

[20:45] <dalek> roast: review: https://github.com/perl6/roast/commit/008d2e55aa

[20:45] <dalek> rakudo/nom: 372e76c | Coke++ | t/spectest.data:

[20:45] <dalek> rakudo/nom: Unskip passing testfile

[20:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/372e76c8a8

[20:47] *** dalek left
[20:48] <[Coke]> pmichaud: ping.

[20:49] *** dalek joined
[20:49] *** ChanServ sets mode: +v dalek

[20:49] <tadzik> seen jnthn 

[20:49] <aloha> jnthn was last seen in #perl6 3 hours 43 mins ago saying "afk for a while, going to visit masak++ :)".

[20:51] <[Coke]> would it be helpful in nom's t/spectest.data to, for those tests that are currently listed but commented out, to show the exception (without, say, going through and diagnosing the root cause of the exception?)

[20:51] <[Coke]> e.g.:

[20:51] <[Coke]> +# S02-builtin_data_types/autovivification.t # err: No applicable candidates fou S02-builtin_data_types/bool.t

[20:51] <[Coke]> er:

[20:51] <[Coke]> # S02-builtin_data_types/autovivification.t # err: No applicable candidates found to dispatch to for 'trait_mod:<is>'.

[20:53] <dalek> november: 96e6433 | softmoth++ | Makefile:

[20:53] <dalek> november: Tidy: clean up whitespace, sort SOURCES

[20:53] <dalek> november: review: https://github.com/viklund/november/commit/96e64334b3

[20:53] <dalek> november: ac9d4b5 | softmoth++ | Makefile:

[20:53] <dalek> november: Add Digest::SHA to Makefile

[20:53] <dalek> november: review: https://github.com/viklund/november/commit/ac9d4b574e

[21:03] *** cooper left
[21:03] <dalek> november: a241244 | softmoth++ | lib/November.pm:

[21:03] <dalek> november: Fix one "string".IO ~~ :e test

[21:03] <dalek> november: review: https://github.com/viklund/november/commit/a241244ea1

[21:03] *** cooper joined
[21:10] *** bluescreen10 left
[21:12] <sorear> TimToady: ping

[21:13] *** Mowah left
[21:13] <pmichaud> [Coke]: pong

[21:14] <dalek> november: e68e5b0 | softmoth++ | data/users:

[21:14] <dalek> november: Update data/users with a valid SHA256 user/pass

[21:14] <dalek> november: review: https://github.com/viklund/november/commit/e68e5b014c

[21:14] <pmichaud> (add errors to spectest.data)  yes, that's helpful.  I've been doing that as I try various tests

[21:14] <pmichaud> i.e., I try the test to see if it works, if it doesn't, I record why in spectest.data

[21:14] <sorear> phenny: tell TimToady  / <fun($/)> / doesn't use <.newlex> or <.finishlex> at all, does it create a new $/ or does it use the surrounding $*CURLEX's $/ ?

[21:14] <phenny> sorear: I'll pass that on when TimToady is around.

[21:15] <pmichaud> since / is like a sub or method, I suspect it gets its own $/

[21:15] <pmichaud> er, since /rx/

[21:15] <pmichaud> I think it's more sub-like than block-like.

[21:25] <sorear> std: / :my $x; /; say $x

[21:25] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 122m␤»

[21:25] *** bluescreen10 joined
[21:28] *** explorer__ left
[21:34] *** ccc joined
[21:36] *** jferrero joined
[21:39] *** Chillance left
[21:46] *** Patterner left
[21:48] *** Psyche^ joined
[21:48] *** Psyche^ is now known as Patterner

[21:49] *** bluescreen100 joined
[21:52] *** bluescreen100 left
[21:52] *** y3llow left
[21:52] *** y3llow_ joined
[21:52] *** pothos left
[21:52] *** pothos_ joined
[21:53] *** y3llow_ is now known as y3llow

[21:53] *** pothos_ is now known as pothos

[21:54] *** bluescreen10 left
[21:57] *** ccc left
[21:59] *** benabik joined
[22:03] *** buubot_backup left
[22:11] *** yahooooo joined
[22:11] <dalek> roast: eec7077 | Coke++ | S02-builtin_data_types/declare.t:

[22:11] <dalek> roast: Skip more tests for rakudo(nom)

[22:11] <dalek> roast: review: https://github.com/perl6/roast/commit/eec70777d5

[22:13] <dalek> rakudo/nom: 458245f | Coke++ | t/spectest.data:

[22:13] <dalek> rakudo/nom: Add some failure comments, running one more test.

[22:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/458245f6ed

[22:13] <[Coke]> is there any automated process at this point that can try to run SKIPped tests?

[22:14] *** drbean joined
[22:14] <[Coke]> (specifically fudge/skips in t/spec)

[22:17] *** cbk left
[22:17] * jnthn back

[22:18] <[Coke]> jnthn: front

[22:18] <jnthn> [Coke]: 中 :P

[22:19] *** cdarroch joined
[22:19] *** cdarroch left
[22:19] *** cdarroch joined
[22:21] <[Coke]> bacardi? ;)

[22:22] <jnthn> :P

[22:24] <jnthn> tadzik: ping

[22:27] *** buubot_backup joined
[22:32] *** aindilis left
[22:32] *** aindilis joined
[22:35] *** Krunch left
[22:38] <dalek> roast: 9bdef44 | Coke++ | S02-builtin_data_types/mixed_multi_dimensional.t:

[22:38] <dalek> roast: match up with rakudo-current(nom)

[22:38] <dalek> roast: review: https://github.com/perl6/roast/commit/9bdef440e2

[22:39] <dalek> rakudo/nom: e5ed290 | Coke++ | t/spectest.data:

[22:39] <dalek> rakudo/nom: add a reason, pass a test.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5ed29015e

[22:43] <dalek> roast: 4fff7b4 | Coke++ | S02-builtin_data_types/multi_dimensional_array.t:

[22:43] <dalek> roast: match up with rakudo-current(nom)

[22:43] <dalek> roast: review: https://github.com/perl6/roast/commit/4fff7b484a

[22:44] <dalek> rakudo/nom: 1483a05 | Coke++ | t/spectest.data:

[22:44] <dalek> rakudo/nom: add a passing test.

[22:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1483a05560

[22:50] <dalek> rakudo/nom: 2d10e5c | Coke++ | t/spectest.data:

[22:50] <dalek> rakudo/nom: add more failure reasons.

[22:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2d10e5c568

[22:51] * [Coke] should probably not do that in quite so many small commits.

[22:51] <jnthn> It's like Coke++ wants the karma! ;)

[22:52] <[Coke]> given I don't commit any actual functionality, it's the best I can do. :)

[22:52] <jnthn> I'm glad you're doing it. :)

[22:56] <[Coke]> 5585 tests.

[22:57] <jnthn> \o/

[22:59] <[Coke]> Though it occurs to me that the the test harness doesn't give you an easy way to say "This may tests are TODO/SKIP/FAIL" :P

[22:59] <tadzik> jnthn: pong

[23:00] <tadzik> thanks to insomnia I'm here again :)

[23:01] <jnthn> tadzik: Did you solve your issues?

[23:01] <tadzik> jnthn: nope

[23:01] <jnthn> (The looking up POD::Block ones...)

[23:01] <cooper> what is the easiest equivalent to perl 5's each method for hashes?

[23:01] <jnthn> tadzik: What did you try to do

[23:01] <jnthn> ?

[23:01] <tadzik> cooper: .kv probably

[23:01] <tadzik> jnthn: I'll push the current podparser and paste you a patch, ok?

[23:01] <cooper> so like

[23:01] <cooper> for %hash.kv -> $a, $b {... } 

[23:01] <jnthn> tadzik: $*ST.find_symbol(['POD::Block']) by any chance?

[23:01] <cooper> ?

[23:02] <jnthn> cooper: yes

[23:02] <cooper> thank you

[23:02] <tadzik> jnthn: nah, .add_constant as usual, only now I'm trying 'Pod::Block::Named' rather than 'Pod__Block__Named'

[23:02] <jnthn> nom: my %h = a => 1, b => 2; for %hash.kv -> $k, $v { say "$k = $v" }

[23:02] <p6eval> nom: OUTPUT«Symbol '%hash' not predeclared in <anonymous> (/tmp/F4JaLy7NbR:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[23:02] <jnthn> nom: my %h = a => 1, b => 2; for %h.kv -> $k, $v { say "$k = $v" }

[23:02] <p6eval> nom: OUTPUT«a = 1␤b = 2␤»

[23:02] <jnthn> tadzik: ah

[23:02] <jnthn> tadzik: yeah, I can see what's up

[23:03] <tadzik> cool

[23:03] <jnthn> my $type_obj := self.find_symbol([$type]);

[23:03] <jnthn> find_symbol expects the name to be pre-split

[23:03] <dalek> Heuristic branch merge: pushed 30 commits to rakudo/podparser by tadzik

[23:03] <jnthn> try

[23:03] <jnthn> my $type_obj := self.find_symbol(pir::split('::', $type));

[23:03] <jnthn> or some such

[23:04] <tadzik> hmm, will try

[23:04] <jnthn> (that line appears in add_constant)

[23:04] <jnthn> 718 in the checkout I have here

[23:04] <tadzik> so I should poke add_constant itself?

[23:06] <tadzik> yay, win!

[23:08] <tadzik> jnthn: should classes in my package Pod {} be our'd?

[23:12] *** wolfman2000 left
[23:14] <tadzik> they work when they are, let's see if they work when they aren't :)

[23:21] <dalek> rakudo/podparser: 82b7267 | tadzik++ | src/Perl6/SymbolTable.pm:

[23:21] <dalek> rakudo/podparser: [SymbolTable] Fix lookup of type object with "::" in their names, jnthn++

[23:21] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/82b7267d78

[23:21] <dalek> rakudo/podparser: 93c4425 | tadzik++ | / (8 files):

[23:21] <dalek> rakudo/podparser: Give Pod classes proper names, jnthn++ for making that possible

[23:21] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/93c44255d8

[23:22] <tadzik> jnthn++ once again, thanks for help :)

[23:25] <jnthn> tadzik: our is default for classes

[23:25] <jnthn> and yes, they need to be, or you can't look them up through :: style lookup

[23:27] *** cdarroch left
[23:28] <tadzik> that's what I thought, both things :)

[23:29] <jnthn> :)

[23:31] *** tokuhir__ joined
[23:32] *** orafu left
[23:33] *** wamba left
[23:33] *** orafu joined
[23:37] *** molaf__ joined
[23:40] *** molaf_ left
[23:41] *** bluescreen10 joined
[23:47] *** ab5tract joined
[23:51] *** wamba joined
[23:52] <tadzik> ok, I'll maybe try to sleep now &

[23:53] <jnthn> :)

[23:53] <jnthn> o/ tadzik 

[23:56] *** wamba left
