[00:22] *** drbean left
[00:54] *** Chillance left
[01:02] *** carlin left
[01:18] *** thou left
[01:39] *** japhb_ left
[01:45] *** bluescreen10 left
[01:45] *** bluescreen100 left
[01:48] *** wolfman2000 joined
[01:49] *** thou joined
[01:57] *** bluescreen100 joined
[02:02] *** diegoviola left
[02:04] *** bluescreen10 joined
[02:07] *** whiteknight left
[02:21] *** djanatyn is now known as djan|sipna

[02:29] *** jaldhar left
[02:32] *** jaldhar joined
[03:16] *** sivoais left
[03:17] *** sivoais joined
[03:17] *** sivoais left
[03:17] *** sivoais joined
[03:30] *** soh_cah_toa left
[03:49] <[Coke]> 

[04:04] *** tokuhiro_ left
[04:14] *** tokuhiro_ joined
[04:25] <moritz> good morning

[04:26] <sorear> good morning moritz

[05:15] *** orafu left
[05:18] *** orafu joined
[05:23] * Woodi wonders do quasi need unquote varibles... in 'macro abc { some_stuff }' is Perl code so will be ASTed anyway in macro time...

[05:28] *** daniel-s joined
[05:52] *** [Sec] left
[06:00] *** [Sec] joined
[06:03] *** kaare_ joined
[06:07] *** risou_awy is now known as risou

[06:11] *** am0c joined
[06:24] *** risou is now known as risou_awy

[06:47] *** zby_home joined
[06:55] *** awara joined
[06:56] *** awara left
[07:21] *** drbean joined
[07:35] *** dual joined
[08:12] <dalek> niecza: 9740424 | sorear++ | lib/ (2 files):

[08:12] <dalek> niecza: Major refactoring of PrepareEval, INIT time, and subordinate unit freeze/thaw

[08:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/97404246e7

[08:13] <dalek> niecza: 4001766 | sorear++ | lib/Serialize.cs:

[08:13] <dalek> niecza: Bump serialize version

[08:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4001766cdd

[08:26] *** thou left
[08:31] *** am0c left
[08:47] *** simcop2387 left
[08:48] *** simcop2387 joined
[08:54] <masak> morning, #perl6

[08:55] <sorear> hello masak

[08:56] <masak> Woodi: no, not really. the 'some_stuff' is just regular code. a macro that doesn't *explicitly* return an AST is considered erroneous. maybe we'll consider returning Nil or failing to be equivalent to returning an empty AST, though, I dunno.

[08:57] <sorear> masak: erroneous, really?

[08:57] <sorear> seems easy enough to me to make that an error.

[08:58] <masak> I'm speaking now as if text macros don't exist. but yeah, in my branch the compiler dies if it doesn't get an AST as a return value.

[09:10] <dalek> niecza: 7451754 | sorear++ | / (4 files):

[09:10] <dalek> niecza: Finish implementation of -gen-app function

[09:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7451754a41

[09:14] <sorear> niecza: say acos i

[09:14] <p6eval> niecza v10-220-g4001766: OUTPUT«1.5707963267949-0.881373587019543i␤»

[09:18] <masak> hm, why isn't that a real value?

[09:20] <sorear> because the cosine of any real value is real

[09:20] <sorear> so the arc-cosine of any unreal value must be unreal

[09:21] *** risou_awy is now known as risou

[09:21] <masak> oh, sorry; thought it said 'acos 1' :)

[09:28] *** GlitchMr joined
[09:30] <Woodi> masak: i try to understand: macro abc( $a ) { somestuff + {{{ $a }}} } # somestuff is parsed to AST and $a is AST passed - they on 'same lvl' then some composition on AST lvl shoud work...

[09:31] <masak> sorear: but your answer tells me you grok holomorphic functions ;)

[09:31] <sorear> masak: s/holomorphic functions/modus tollens/

[09:32] <masak> Woodi: no, a macro is supposed to return an AST (usually via a quasi), and {{{ $a }}} only works inside quasis.

[09:32] <masak> sorear: oh, indeed.

[09:32] <TiMBuS> why um. why a triple curly?

[09:33] <masak> TiMBuS: know about Lisp and `(a ,b c) ?

[09:33] <TiMBuS> why not some kind of normal qq construct

[09:33] <Woodi> TiMBuS: S06 proposition but probably (hope) outdated now...

[09:34] <TiMBuS> masak, yeah i know about passing around lisp in lisp. the one thing i made in parrot was a homoiconic language

[09:34] <masak> TiMBuS: there's this idea that you triple the circumfix characters delimiting the quasi block.

[09:34] <masak> TiMBuS: it's right there in S06.

[09:35] <Woodi> masak: ok, i realy mean:  macro abc( $a ) { quasi {  somestuff + {{{ $a }}} } }

[09:35] <TiMBuS> yeah but im just wondering on a more simple level here. why make a whole boatload of curlies when you can be less noisy

[09:36] <TiMBuS> like, was it a decision done on purpose? similar to ?? !!

[09:36] <Woodi> anyway, now i think about macros as some cut-modify on AST lvl

[09:37] <Woodi> TiMBuS: yesterday TimToady proposed use some 'one char' signature for that

[09:37] <TiMBuS> oh

[09:38] * TiMBuS looks at keyboard

[09:38] <masak> TiMBuS: I've flip-flopped a bit on liking {{{$a}}}

[09:38] <masak> TiMBuS: I think it's fine that it stands out a bit and doesn't look like "regular" syntax.

[09:39] <masak> Woodi: then the answer to your question posed as a statement is "yes", there's composition of ASTs going on.

[09:40] <masak> the {{{ }}} syntax is a way to say, "hold on, that was the literal code I wanted to make into an AST, but here I have an AST already-prepared that I want to insert".

[09:41] <TiMBuS> well i agree its good it stands out, it also blends in

[09:41] <masak> aye.

[09:41] <TiMBuS> which i dont.. yeah idunno

[09:41] <TiMBuS> we are meant to copy the good parts of lisp, not the bad

[09:41] <masak> TiMBuS: TimToady felt the need to change it because it doesn't carry enough information about the grammatical category.

[09:41] <TiMBuS> $a }}} } }

[09:42] <masak> TiMBuS: or, put differently, it only works for terms.

[09:42] <masak> TiMBuS: I wouldn't generally write all those braces on the same line; I'd use line breaks and indentation. then it looks quite palatable.

[09:42] *** tokuhiro_ left
[09:43] <masak> TiMBuS: in some sense, you could make the same argument about five loops nested inside each other.

[09:44] *** mj41 joined
[09:46] <sorear> apparently, we have no spectests (that niecza passes?) for class A { class B is A { } }

[09:46] *** zby_home__ joined
[09:47] <sorear> whereas niecza itself uses that style heavily

[09:47] *** zby_home left
[09:47] <sorear> and it's broken now

[09:47] *** drbean left
[09:48] <masak> nom: class A { class B is A {}; say B ~~ A }; say A::B ~~ A

[09:48] <p6eval> nom 9c6aed: OUTPUT«Bool::True␤Bool::True␤»

[09:48] <masak> niecza: class A { class B is A {}; say B ~~ A }; say A::B ~~ A

[09:48] <p6eval> niecza v10-221-g7451754: OUTPUT«===SORRY!===␤␤System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.P6how.CollectMMDs () [0x00000] in <filename unknown>:0 ␤  at Niecza.P6how.Revalidate () [0x00000] in <filename unknown>:0 ␤  at…

[09:49] <sorear> worked fine pre-serialize.

[09:49] *** daniel-s left
[09:49] *** drbean joined
[09:51] *** mj41 left
[09:53] <dalek> niecza: 000cc77 | sorear++ | / (2 files):

[09:53] <dalek> niecza: Checkpoint new bootstrap attempt

[09:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/000cc772dd

[09:53] <dalek> niecza: 616e8ac | sorear++ | lib/ (2 files):

[09:53] <dalek> niecza: Fix inheritance of an outer class by an inner class

[09:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/616e8ac5ec

[09:56] <Woodi> masak: ok, understud case. now: do macros-returning-strings allow quasi ? do m-r-s allow quasi/ast marked eg. :ast(Ruby) ?

[09:58] <masak> Woodi: as far as I and my grant are concerned, macros aren't allowed to return strings. please ask someone else. :)

[09:58] <Woodi> ok, didn't know.

[09:59] <Woodi> what about 'submacros' ?

[10:01] * Woodi have lost idea what is macro scope now...

[10:03] <masak> do you mean macros inside macros, or macros inside quasis?

[10:04] <masak> they're both just scoped differently.

[10:04] <Woodi> 1. just wonder what 'submacro' in S06 means; 2. wonder how to have AST to have it alredy prepared...

[10:04] * masak checks S06

[10:06] <masak> Woodi: I have no idea what "submacro" means in that context.

[10:06] <masak> it either means "a macro that is a sub" (but all of them are, in a sense) or "a macro that is somehow below or inside something else" (but what and why would that help?)

[10:07] <sorear> niecza: $A::b; $A::b

[10:07] <p6eval> niecza v10-221-g7451754:  ( no output )

[10:07] <sorear> niecza: $A::b; package A { our $b }

[10:07] <p6eval> niecza v10-221-g7451754:  ( no output )

[10:07] <masak> as to how is AST formed: the parser reads the source code, and generates ASTs. so at the time of a macro invocation, the parser has just parsed the argument list into little snippets of AST, and it's very easy to pass those into the macro itself.

[10:08] <sorear> niecza: $A::b; package A { our constant $b = 5}

[10:08] <p6eval> niecza v10-221-g7451754: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/SMMJwi1HMi line 1:␤------> $A::b; package A { our ⏏constant $b = 5}␤␤»

[10:08] <Woodi> aha

[10:09] <sorear> niecza: %A::b; %A::b

[10:09] <p6eval> niecza v10-221-g7451754: OUTPUT«===SORRY!===␤␤Two definitions found for symbol ::GLOBAL::A::%b␤␤  first at /tmp/MoaEmOBhix line 1␤  second at /tmp/MoaEmOBhix line 1 at /tmp/MoaEmOBhix line 1 (EOF):␤------> %A::b; %A::b⏏<EOL>␤␤␤Unhandled Exception: Ch…

[10:14] <masak> Woodi: somewhat simplified: runtime thinks and deals in values, like 42 and "OH HAI". compiler thinks and deals in code represented as ASTs, like int:42 and infix:<+>:(int:2, int:2) and subcall:<say>:(string:"OH HAI")

[10:15] <masak> (AST syntax is for educational purposes only and entirely made up)

[10:16] <dalek> niecza: 4865e86 | sorear++ | lib/Kernel.cs:

[10:16] <dalek> niecza: Hack - allow merging empty containers

[10:16] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4865e86871

[10:28] <Woodi> masak: macros run both in compile time and run-time ?

[10:30] <masak> yes, though I've only focused on compile-time so far.

[10:31] <masak> at runtime, the macro is called as a regular sub, and since it then gets values and not ASTs, the values will have to be converted to ASTs. it's as yet unclear which entity does the conversion.

[10:36] <sorear> Why are you calling macros at run-time at all?

[10:41] <masak> this is Perl. we don't disallow things just because we don't see their use. :)

[10:42] <masak> more to the point though, a macro still has that magical code generation ability at runtime.

[10:42] <masak> so it's a bit like a more civilized &eval call.

[10:44] *** Shozan joined
[10:46] <sorear> masak: macros take AST arguments though.

[10:46] <sorear> niecza: /x/; say 'L'

[10:46] <p6eval> niecza v10-224-g4865e86: OUTPUT«␤Unhandled Exception: System.Exception: Niecza.Variable not subtype of System.String[]:Void PushCapture(System.String[], Niecza.Variable)␤  at Niecza.CLRBackend.ClrOp.TypeCheck (System.Type sub, System.Type super, System.Object c) [0x00000] in <filename u…

[10:49] <masak> sorear: yes, that's the problem.

[10:49] <masak> sorear: there are a couple of solutions/workarounds to make it all work, neither of which I particularly like.

[10:49] <dalek> niecza: bd53b44 | sorear++ | lib/ (2 files):

[10:49] <dalek> niecza: Fix miscompilation of string literal "L" after regex compiled in same file

[10:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bd53b441f3

[10:50] * sorear doubts it makes any sense to have a regression test for that

[10:50] <masak> :)

[10:51] <masak> how...? what...? :)

[10:52] <moritz> why not? :-)

[10:52] <masak> why did TimToady settle on the use of the term 'zyg' for 'child' again?

[10:52] <moritz> becaues it's short

[10:52] <masak> hmmm.

[10:52] <masak> at the cost of making everybody ask.

[10:54] <tadzik> hehe

[10:56] *** ggoebel left
[10:58] * sorear -> sleep

[11:01] *** ggoebel joined
[11:03] *** MayDaniel joined
[11:05] <masak> 'night, sorear. dream of literals "L" being compiled correctly after regexes.

[11:08] *** whiteknight joined
[11:10] *** SHODAN left
[11:21] *** carlin joined
[11:24] <masak> this one is close-ish to both station and Bokus: http://www.hitta.se/ViewDetailsPink.aspx?Vkiid=OY7P9URx1OEmPIrA0KqYdA%253d%253d&vad=fotograf&var=Malm%f6

[11:26] *** ggoebel left
[11:26] <jnthn> masak: wrong window? :)

[11:28] <masak> oh, yeah. :/

[11:29] <masak> (jnthn and I are privmsg'ing about a photographer)

[11:31] *** worr joined
[11:34] *** drbean left
[11:37] *** GlitchMr left
[11:38] *** Psyche^ joined
[11:41] *** Patterner left
[11:41] *** Psyche^ is now known as Patterner

[11:41] *** drbean joined
[12:03] *** shinobicl_ joined
[12:06] *** Chillance joined
[12:08] *** whiteknight left
[12:11] <cognominal_> In french slang, zig zig is the action that can eventually end up in a zyg. That's also the title of a song full of puns and aliterations :  http://www.youtube.com/watch?v=CVJIKwSjcUs

[12:16] <masak> according to the YouTube comments, it's WWII slang introduced by German soldiers.

[12:20] <cognominal_> That may be right because the song is part a very provocative album about nazi decadence by Gainsbourg. 

[12:22] <cognominal_> Anyway if there no provocation anywhere, that could not be Gainsbourg

[12:26] <cognominal_> Funny enough, in some songs, when the text is too explicit, he switch to English but somehow in American stores, he got away with the explicit lyrics label. Too bad because I suspect that was a badge of quality for kids.

[12:29] *** shinobicl_ left
[12:31] *** Trashlord left
[12:32] <masak> :)

[12:34] *** preflex_ joined
[12:35] *** preflex left
[12:35] *** preflex_ is now known as preflex

[12:36] *** Shozan left
[12:47] *** GlitchMr joined
[12:48] <flussence> niecza now passes >10k tests, fsvo "pass": https://github.com/flussence/specgraphs/raw/master/niecza/output.png

[12:48] <flussence> (and this graph's a huge mess with the serialize branch mixed in)

[12:50] <colomon> yes, breaking 10k corresponds to my wife driving us to Ann Arbor Wednesday and me hacking on VLHF in the car.  ;)

[12:51] <masak> colomon++

[12:53] <colomon> masak++ for #phasering for me.

[12:53] <colomon> I'm pretty sure there's still a lot of LHF in there.

[12:54] <colomon> but it's a bit tricky to find them, because some tests don't work for incidental reasons

[12:55] <masak> wow, imagine getting Pugs back in the race too...

[12:59] *** mj41 joined
[13:00] <masak> perl6: say "I like ", <Niecza Rakudo Pugs>.pick, " the best!"

[13:00] <p6eval> niecza v10-225-gbd53b44: OUTPUT«I like Rakudo the best!␤»

[13:00] <p6eval> ..pugs b927740, rakudo 9c6aed: OUTPUT«I like Niecza the best!␤»

[13:00] <masak> aww :)

[13:00] <masak> mutual admiration. :)

[13:03] *** diegoviola joined
[13:06] *** Trashlord joined
[13:06] *** SHODAN joined
[13:08] *** MayDaniel left
[13:11] *** pmurias joined
[13:15] *** tokuhiro_ joined
[13:26] <felher> :D

[13:39] *** mj41 left
[13:55] *** GlitchMr left
[13:58] *** MayDaniel joined
[14:13] *** ggoebel joined
[14:14] *** ggoebel left
[14:22] *** fridim_ joined
[14:23] <colomon> rakudo: say (1..100).grep(10 < * < 20).gist

[14:23] <p6eval> rakudo 9c6aed: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 9…

[14:23] <colomon> b: say (1..100).grep(10 < * < 20).gist

[14:23] <p6eval> b 1b7dd1: OUTPUT«Method 'gist' not found for invocant of class 'List'␤  in main program body at line 22:/tmp/tNAzcGmS9y␤»

[14:23] <colomon> b: say (1..100).grep(10 < * < 20).perl

[14:23] <p6eval> b 1b7dd1: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70…

[14:23] <colomon> b: say (1..100).grep(* < 20).perl

[14:23] <p6eval> b 1b7dd1: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)␤»

[14:24] <colomon> niecza: say (1..100).grep(10 < * < 20).perl

[14:24] <p6eval> niecza v10-225-gbd53b44: OUTPUT«(11, 12, 13, 14, 15, 16, 17, 18, 19).list␤»

[14:24] <colomon> niecza++

[14:24] <colomon> masak: ^^ known bug?

[14:28] *** tarekul joined
[14:28] *** tarekul left
[14:31] *** JimmyZ joined
[14:42] *** simcop2387 left
[14:43] *** fridim_ left
[14:44] *** simcop2387 joined
[14:49] *** mj41 joined
[14:50] <masak> colomon: no, looks new to me.

[14:50] * masak submits rakudobug

[14:50] <masak> colomon++

[14:53] <masak> colomon: by the way, why do you use .gist with &say?

[14:53] *** fsergot joined
[14:53] <fsergot> Hi! :-)

[14:53] <masak> nom: say (1..100).grep(* < 20).perl

[14:53] <p6eval> nom 9c6aed: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19).list␤»

[14:53] <masak> fsergot: hi!

[14:54] <fsergot> masak, how are you? :-)

[14:54] <masak> fsergot: I'm fine. who are you? :P

[14:54] <masak> nom: say (1..100).grep({ 10 < $_ < 20 }).perl

[14:55] <p6eval> nom 9c6aed: OUTPUT«(11, 12, 13, 14, 15, 16, 17, 18, 19).list␤»

[14:55] <masak> innerestin'

[14:56] <jnthn> masak: Probably something to do with auto-currying

[14:57] <masak> you mean "auto-priming"? :)

[14:57] * masak doesn't know which one is correct, actually

[14:58] <jnthn> no, then

[14:58] <jnthn> grr

[14:58] <jnthn> No, the * thing

[14:59] <masak> yes, the * thing

[14:59] <masak> but is it currying or priming?

[15:00] <jnthn> clos-o-matic

[15:00] <jnthn> Or closurematic :)

[15:01] <jnthn> It may be priming in some cases, but not in ones like * * *

[15:01] * masak <== vertigo

[15:01] *** bluescreen10 left
[15:01] *** bluescreen100 left
[15:02] *** bluescreen10 joined
[15:02] <jnthn> masak: Happens to some people, to the altitude one is at when doing higher order programming...

[15:03] *** grondilu joined
[15:03] <jnthn> *due to

[15:03] <masak> :P

[15:03] *** grondilu left
[15:04] * masak looks forward to MJD's upcoming fictional "Acrophobiac Programming"

[15:04] *** grondilu joined
[15:05] <Woodi> my $c1 = "*2\r\n\$3\r\nGET\r\n"; my Str $c2 = "*2\r\n\$3\r\nGET\r\n";  # which one for performance ?

[15:05] <grondilu> where is the log for this chan?

[15:06] <grondilu> (if there is any)

[15:07] <jnthn> Woodi: When you add type information, the compiler can make use of it.

[15:07] <jnthn> Woodi: To generate better code.

[15:08] <jnthn> Whether compilers actually will do that at the moment is another matter

[15:08] <jnthn> Rakudo does to some degree. In some cases, it can do WAY better. In others, just a bit or not much at all.

[15:09] <Woodi> asking becouse it's definition with initialization to Str. ok, adding type is good for me

[15:09] *** cognominal joined
[15:09] *** GlitchMr joined
[15:10] <masak> grondilu: http://irclog.perlgeek.de/perl6/today

[15:10] <grondilu> masak: ok, thks

[15:11] *** grondilu left
[15:11] <gfldex> nom: my Str $s1 = "arther"; $s1 = 42; say $s1.WHAT; my $s2 = "dent"; $s2 = 42; say $s2.WHAT;

[15:11] <p6eval> nom 9c6aed: OUTPUT«Type check failed in assignment to '$s1'; expected 'Str' but got 'Int'␤  in block <anon> at /tmp/2RPjbDzR_G:1␤  in <anon> at /tmp/2RPjbDzR_G:1␤»

[15:11] <gfldex> Woodi: ^^

[15:11] *** cognominal_ left
[15:12] <gfldex> Woodi: you can let the compiler remove some of the rope to hang yourself

[15:12] <masak> I will not reassign. reassignment is the mind killer.

[15:13] <TimToady> it'x zyg so it sorts last in a YAML file

[15:16] <masak> ah.

[15:16] <masak> so you needed a term for 'child' that sorted after all the other attributes? :)

[15:18] <Woodi> gfldex: i was realy asking: do 'my $a = "string";' is good for compiler to guess correct type for optimization. But that question is extremally stupid in context of scripting language :) To first approximation... Compilator can parse full script and then see that it is always a string. But defining type probably better...

[15:19] <jnthn> Woodi: I expect the optimizer may be able to catch some things like that but it's decidedly non-trivial. Essentially, you have to keep track of the assumptions you made and be ready to undo them if you "disprove" that the initially assigned type could hold.

[15:20] <jnthn> http://sixgill.org/ti-draft.pdf is in the same problem space

[15:21] <TimToady> late-bound rw parameters are a killer

[15:21] <jnthn> TimToady: Right

[15:21] <jnthn> TimToady: Well, method calls are.

[15:21] * TimToady wonders if there's ever any programming style that needs rw parameters to methods

[15:22] <jnthn> TimToady: Method calls in general are an assumption blocker

[15:22] <TimToady> that can't be done some other way in p6

[15:22] <jnthn> TimToady: You don't know if the invocant will be modified even

[15:22] <TimToady> well, we expect that

[15:23] <jnthn> TimToady: no, I meant rw style

[15:23] <jnthn> $a.foo # $a may not even contain the same object afterwards

[15:23] <TimToady> that seems somewhat pernicious

[15:23] <jnthn> (since method foo($x is rw:) { $x = 42 }

[15:23] <jnthn> )

[15:24] <jnthn> TimToady: The more immediate pain point is this

[15:24] <TimToady> maybe we can track the names of all pernicious methods defined

[15:24] <jnthn> We have to define infix:<+> as, say, Int:D, Int:D

[15:24] <jnthn> TimToady: So knowing "$x is an Int, $y is na Int" isn't enough to inline $x + $y

[15:25] <jnthn> TimToady: Well, but it's not as simple - the method may be introduced in an eval or something.

[15:26] *** bluescreen10 left
[15:26] <jnthn> Or the module is compiled, then some other class in a later module come along with one.

[15:27] <jnthn> I suspect the best we can do in various cases we think will be expensive is emit a set of contitions, and if they hold up, enter a well optimized code path. Otherwise, fall back.

[15:27] <jnthn> Though that's what the paper I linked a moment ago is really doing...though it does it dynamically at JIT level.

[15:31] <TimToady> it's probably a bigger win when you can move the conditions outside a hot loop

[15:31] <jnthn> yes, that's what I was thinking

[15:32] <jnthn> Of course, there's a limit to what you can statically decide is hot also.

[15:32] <jnthn> You end up guessing.

[15:32] <TimToady> well, to the first approximation, smaller tends to be hotter, and that works in our favor

[15:33] <TimToady> so the hot loops are likelier to be doable, if you just guess based on doability

[15:34] <jnthn> Yes, it's probably just spotting clues.

[15:34] <jnthn> "I'm a while loop with a small body. You may want to do me."

[15:34] <jnthn> "I'm a loop nested inside another loop with a single statement body. You should really do me!"

[15:35] <jnthn> etc

[15:35] <jnthn> All fun stuff to work on :)

[15:35] <TimToady> if there's a way to falsify asap, then you just do all loops, and give up on the longer ones as soon as they falsify

[15:36] <jnthn> Well, it's not always just "falsify"; "can't be sure" can happen also.

[15:37] <jnthn> I guess it all depends on how cheap it can be to give up.

[15:37] <jnthn> Feels almost like some kinda of constraint-y thing.

[15:38] <TimToady> sure, it's always the #1 constraint of optimization: Don't get caught!

[15:38] <jnthn> ;)

[15:38] *** bluescreen10 joined
[15:39] <TimToady> there's also pragmas and -O levels to decides some of these things

[15:39] <TimToady> *de

[15:39] <Woodi> 'do less' is nice too

[15:39] <jnthn> Hmm. Seems I have a talk to do on optimizing Rakudo / Perl 6 next weekend :)

[15:40] <TimToady> it helps to have a language that helps the user distinguish eager from lazy, so we don't have to guess much on that one

[15:40] <cognominal> Rare

[15:40] <cognominal> Acrophobiac

[15:40] <cognominal> Programming,

[15:40] <cognominal> Enhanced

[15:40] <cognominal> :)

[15:40] <TimToady> we call that canola these days

[15:42] <cognominal> I wonder if anyone indulged in acrostic programming.

[15:44] <arnsholt> Sounds like something for Perl poetry =)

[15:44] <TimToady> $a = ...; $b = ...; $c = ...; ...  # makes it easy to do x, even in English

[15:45] <masak> for me having a "grey area" between distinctions like "clearly optimizable" and "clearly not optimizable" is what saves us from Death by Halting Problem.

[15:46] <TimToady> I'm not so worried about Death by Halting; I'm much more concerned about Death by Not Halting.

[15:47] *** drbean left
[15:47] <TimToady> it's hard to figure out when to throw the Inadvertent Infinite Loop exception

[15:48] <TimToady> "Admiral, our cruise missiles are all blowing up before reaching their destinations, and we don't know why!"

[15:48] <masak> that's essentially what I mean.

[15:49] <masak> it's only a problem as long as you don't allow "I don't know" as an answer.

[15:49] <TimToady> yes, but it's so much fun to enforce more precision on you

[15:49] <masak> :P

[15:49] <masak> just be careful not to put me in an infinite loop... :P

[15:49] <TimToady> "I don't know" can also be a problem.  :)

[15:49] <masak> of course it can.

[15:50] <TimToady> Teens are great at "I don't know."

[15:50] <masak> but it's sometimes a nice alternative to not coming back with an answer.

[15:50] <TimToady> sure

[15:54] <TimToady> but sometimes knowing whether you know is also hard

[15:54] *** bluescreen10 left
[15:54] *** drbean joined
[15:56] *** bluescreen10 joined
[15:57] <TimToady> on some level, merely having multiple threads, and the possibility to violate encapsulation of the run-time system, means you can't really know much of anything ever, so you kinda have to assume that won't happen

[15:58] <TimToady> and, of course, a cosmic ray can do that to you even with the best written program

[15:59] <TimToady> the universe is not always our friend :)

[15:59] <masak> s/always // # ;)

[16:00] <TimToady> it's friendly enough to allow us to exist

[16:00] <masak> yeah. thanks.

[16:01] <TimToady> about the best we can do is multi-level control feedback, aka defense in depth

[16:03] *** buubot_backup left
[16:03] <TimToady> funny how different kinds of efficiency have differing increases in risk; there's probably something deep there that it's too early in the morning to think about

[16:03] <TimToady> backlogging &

[16:09] *** JimmyZ left
[16:14] <masak> perl6: say <back forward side>.pick ~ <logging porting chatting>.pick

[16:14] <p6eval> rakudo 9c6aed: OUTPUT«sideporting␤»

[16:14] <p6eval> ..pugs b927740: OUTPUT«backlogging␤»

[16:14] <p6eval> ..niecza v10-225-gbd53b44: OUTPUT«forwardlogging␤»

[16:14] <masak> somehow fitting.

[16:15] *** daniel-s joined
[16:15] <TimToady> indeed

[16:15] <TimToady> I'd've use , instead of ~, meself

[16:16] <TimToady> *used

[16:16] <masak> oh dang.

[16:16] <masak> I usually tell people that myself... :)

[16:17] <jnthn> grrr...this compact struct stuff gets hard

[16:18] * jnthn grabs notepad, pen, cup of tea and heads to the sofa for a while

[16:19] <masak> ooh, tea!

[16:19] <TimToady> ooh, of!

[16:19] * TimToady likes ofness

[16:20] *** am0c joined
[16:20] <masak> well, 的 :P

[16:21] <masak> (Mandarin pronunciation DE)

[16:21] <masak> though actually, 的 means the opposite of "of", namely "'s"

[16:21] <TimToady> of is pronounced de in French too :)

[16:22] <masak> aye :)

[16:22] <TimToady> "'s" in Japanese is pronounced 'no'

[16:23] <masak> though those two words in French and Mandarin are probably no more related than ありがとう and "obrigado"

[16:31] <pmurias> jnthn: do 'is rw' invocants even make much sense?

[16:31] <phenny> pmurias: 21 Oct 03:19Z <sorear> tell pmurias Now that "embedding a P5 interpreter" has become a common way, I think embedding tests belong in roast, in S01

[16:33] <pmurias> jnthn: it seems very hackish to be you first extract the object out of the container and then call a method on it and pass it the container as the invocant

[16:33] *** Khisanth left
[16:37] *** whiteknight joined
[16:39] <cognominal> masak: will it be possible to create a lexical variable within a macro visible outside it?

[16:41] <masak> cognominal: assuming AST macros, no, not that I can see. that's part of the hygiene.

[16:43] <arnsholt> So to get a macro to pass values to its arguments code you'd have do something with pointy blocks, right?

[16:44] *** _jaldhar joined
[16:44] <masak> I don't understand the question. could you exemplify?

[16:44] *** jaldhar left
[16:45] <jnthn> pmurias: That view may be conflating method lookup and invocation a bit too much.

[16:46] <arnsholt> masak: Well, the canonical example of an intended namespace pollution in a CL macro is anaphoric if

[16:46] <arnsholt> Which puts the value tested into a variable named it ($_, essentially)

[16:47] <arnsholt> To make a similar macro you'd do essentially what if does, no?

[16:47] <arnsholt> (Of course Perl 6 if already does the anaphora thing)

[16:48] *** MayDaniel left
[16:49] *** buubot_backup joined
[16:49] <masak> arnsholt: if some-function() -> $it { ... }

[16:50] <arnsholt> Yeah, essentially

[16:51] <arnsholt> No other way than "polluting-macro($foo,$bar) -> $it { ... }" (FSVO of "polluting" macro)

[16:52] <arnsholt> I have a macrophile friend, and the ability to do namespace pollution when you want to is something of a hobby horse for him is why I'm asking

[16:52] <cognominal> masak, so I am out of luck, if, using macros, I want to write code equivalent to :          my $startlabel   := self.post_new('Label', :result($prefix ~ 'start'));

[16:53] <cognominal> … pulling code from QAST/Compiler.NQP for example.

[16:54] <cognominal> *sake of example

[16:55] *** daniel-s left
[16:56] <TimToady> maybe a macro should be allowed to return a text followed by an AST, and the text can do any needed declarations; or maybe we strengthen the COMPILING interface to allow declarational hoisting somehow

[16:57] *** thou joined
[16:58] <TimToady> or maybe we allow quasi-unquotes in textual macros :)

[16:59] <masak> :)

[16:59] <TimToady> i.e. give the textual macro's reparse some recourse to the macro's lexical scope

[17:00] <TimToady> well, maybe declarations in the quasi should simply have a way to leak out

[17:01] <TimToady> someway of saying "this quasi is/isn't a separate lexical scope

[17:02] <TimToady> that seems simplest

[17:02] <TimToady> well, from the user's point of view :)

[17:02] <TimToady> you'd have to treasure up declarations and install them

[17:02] *** preflex left
[17:02] *** preflex_ joined
[17:03] <TimToady> back to that unification thang...

[17:03] *** preflex_ is now known as preflex

[17:03] *** poincare101 joined
[17:04] *** fridim_ joined
[17:05] <poincare101> perl6: say 3

[17:05] <p6eval> pugs b927740, rakudo 9c6aed, niecza v10-225-gbd53b44: OUTPUT«3␤»

[17:05] <poincare101> perl6: say 3;

[17:05] <p6eval> pugs b927740, rakudo 9c6aed, niecza v10-225-gbd53b44: OUTPUT«3␤»

[17:05] <TimToady> you can say that again

[17:06] <poincare101> perl6: $i = 0; $i++; say $i;

[17:06] <p6eval> niecza v10-225-gbd53b44: OUTPUT«===SORRY!===␤␤Variable $i is not predeclared at /tmp/GNff9TDaAx line 1:␤------> <BOL>⏏$i = 0; $i++; say $i;␤␤Variable $i is not predeclared at /tmp/GNff9TDaAx line 1:␤------> $i = 0; ⏏$i++; say $i;␤␤…

[17:06] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "$i" requires predeclaration or explicit package name␤    at /tmp/gnZ88QgHd5 line 1, column 3␤»

[17:06] <p6eval> ..rakudo 9c6aed: OUTPUT«===SORRY!===␤Symbol '$i' not predeclared in <anonymous> (/tmp/rpheSQ_Vgk:1)␤»

[17:06] <poincare101> what in the world just happened?

[17:07] <jnthn> As all three implementations told you, you need to declare $i :)

[17:07] <jnthn> perl6: my $i = 0; $i++; say $i;

[17:07] <p6eval> pugs b927740, rakudo 9c6aed, niecza v10-225-gbd53b44: OUTPUT«1␤»

[17:13] <TimToady> poincare101: unlike Perl 5, Perl 6 has 'use strict' on by default, so you have to declare your vars

[17:13] <TimToady> but since 'my' lets you do that inline with first use, it's not a huge bother

[17:13] <TimToady> 'my' is short for a reason :)

[17:14] <TimToady> requiring declarations also makes the semantics much more deterministic than any of p5, python, or ruby

[17:14] *** soh_cah_toa joined
[17:16] *** Khisanth joined
[17:18] <masak> I get so surprised every time I hear people say that languages that require 'my' or equivalent makes the language unusable for them. (and people seem to say that far more often than I'd expect, too)

[17:19] <masak> yes, it's a bit of extra work, but it also saves loads of debugging time.

[17:20] <masak> in a way, it's similar to the type information that you sometimes have to put into Haskell. yes, it's slightly more work, but it pays off almost immediately because it helps you write better code.

[17:23] *** skangas left
[17:27] <masak> poincare101: if you want less error output next time, a tip is to target only one implementation, such as 'nom:'. that's less to write, too ;)

[17:29] <dalek> nqp: d116187 | jnthn++ | src/HLL/SerializationContextBuilder.pm:

[17:29] <dalek> nqp: Give SymbolTable::Event a more optimal constructor.

[17:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d116187a24

[17:33] *** drbean left
[17:37] <masak> TimToady: why are the outer parens needed in the divisor-less example at http://rosettacode.org/wiki/FizzBuzz#Perl_6 ?

[17:38] <masak> nom: .say for (('' xx 2, 'Fizz') xx * Z~ ('' xx 4, 'Buzz') xx *) Z|| 1 .. 100

[17:38] <p6eval> nom 9c6aed: OUTPUT«1␤2␤Fizz␤4␤Buzz␤Fizz␤7␤8␤Fizz␤Buzz␤11␤Fizz␤13␤14␤FizzBuzz␤16␤17␤Fizz␤19␤Buzz␤Fizz␤22␤23␤Fizz␤Buzz␤26␤Fizz␤28␤29␤FizzBuzz␤31␤32␤Fizz␤34␤Buzz␤Fizz␤37␤38␤Fizz␤Buzz␤41␤Fizz␤43␤44␤FizzBuzz␤46␤47␤Fizz␤49␤Buzz␤Fizz␤52␤53␤Fizz␤Buzz␤56␤Fizz␤58␤59␤FizzBuzz␤61␤62␤Fizz␤64␤Buzz␤Fi…

[17:38] <masak> nom: .say for ('' xx 2, 'Fizz') xx * Z~ ('' xx 4, 'Buzz') xx * Z|| 1 .. 100

[17:38] <p6eval> nom 9c6aed: OUTPUT«1␤2␤Fizz␤4␤Buzz␤Fizz␤7␤8␤Fizz␤Buzz␤11␤Fizz␤13␤14␤Fizz␤16␤17␤Fizz␤19␤Buzz␤Fizz␤22␤23␤Fizz␤Buzz␤26␤Fizz␤28␤29␤Fizz␤31␤32␤Fizz␤34␤Buzz␤Fizz␤37␤38␤Fizz␤Buzz␤41␤Fizz␤43␤44␤Fizz␤46␤47␤Fizz␤49␤Buzz␤Fizz␤52␤53␤Fizz␤Buzz␤56␤Fizz␤58␤59␤Fizz␤61␤62␤Fizz␤64␤Buzz␤Fizz␤67␤68␤Fizz␤Bu􏿽xE2􏿽x80

[17:39] <masak> it can't be a matter of infix:<xx> versus infix:<Z||>, because the former is definitely tighter.

[17:40] *** drbean joined
[17:41] <masak> infix:<~> and infix:<||> are on the same level of precedence, so even if the rule about a "sub-level" of Z precedences (currently conjectural in the spec), they would tie, precedence-wise.

[17:42] *** risou is now known as risou_awy

[17:42] <masak> and their associativity is L, which means (as far as I can see) that those outer parns should be implied...

[17:42] <masak> what am I missing?

[17:42] *** djan|sipna is now known as djanatyn

[17:48] <arnsholt> Isn't $a Z $b Z $c different from ($a Z $b) Z $c?

[17:49] <masak> yes, good point.

[17:49] <masak> I wonder how that affects $a Z~ $b Z|| $c, though.

[17:50] <masak> nom: .say for (1, 4, 7) Z~ (2, 5, 8) Z|| (3, 6, 9)

[17:50] <p6eval> nom 9c6aed: OUTPUT«1␤4␤7␤»

[17:50] <masak> nom: .say for ((1, 4, 7) Z~ (2, 5, 8) Z|| (3, 6, 9))

[17:50] <p6eval> nom 9c6aed: OUTPUT«1␤4␤7␤»

[17:51] <masak> nom: .say for ((1, 4, 7) Z~ (2, 5, 8)) Z|| (3, 6, 9)

[17:51] <p6eval> nom 9c6aed: OUTPUT«12␤45␤78␤»

[17:51] <masak> nom: .say for (1, 4, 7) Z~ ((2, 5, 8) Z|| (3, 6, 9))

[17:51] <p6eval> nom 9c6aed: OUTPUT«12␤45␤78␤»

[17:52] <masak> so $a Z~ $b Z|| $c parses *neither* like ($a Z~ $b) Z|| $b *nor* like $a Z~ ($b Z|| $c)

[17:52] * Woodi like what 'my' do, just would like more 'my' as optional :)

[17:52] *** Trashlord left
[17:52] <masak> niecza: .say for (1, 4, 7) Z~ (2, 5, 8) Z|| (3, 6, 9)

[17:52] <p6eval> niecza v10-225-gbd53b44: OUTPUT«===SORRY!===␤␤This macro cannot be used as a function at /tmp/KWQKretyop line 1:␤------> .say for (1, 4, 7) Z~ (2, 5, 8) Z||⏏ (3, 6, 9)␤␤"Z~" and "Z||" are non-associative and require parens at /tmp/KWQKretyop line 1:␤…

[17:53] <masak> ah, there you go. Niecza likely has it right.

[17:53] <masak> Woodi: 'my' is opt-out, but the 'no strict' hasn't been implemented by any of the Big Three yet.

[17:54] <Woodi> masak: why you mention 'strict' ?

[17:56] <masak> Woodi: because you mentioned you would like 'my' to be optional.

[17:56] <TimToady> S03:1699 says non-identical list infixes are considered non-associative rather than list associative

[17:57] <masak> yes, I finally figured it out thanks to Niecza.

[17:58] <Woodi> masak: yea, string 'my' to be optional but 'my' behaviour to be default, with and without 'my'...

[17:59] <masak> TimToady: but the conjecture at S03:4746 could change that.

[17:59] <masak> (and I'm for implementing that conjecture.)

[18:00] <masak> Woodi: I don't think you actually mean that. it would mean that { $a = 42; { $a = 5 } } would refer to two different containers.

[18:00] <masak> so the inner assignment would declare a new variable rather than overwrite the outer one.

[18:01] *** Khisanth left
[18:01] <Woodi> masak: i like like C do this - { $a = 42; { $a = 5 } is same container

[18:03] <arnsholt> Woodi: But without explicit declarations it's impossible to tell when you want them to be the same and when you want them to be different

[18:03] <Woodi> arnsholt: then in inner {} my can be used :)

[18:04] * Woodi SHOOT to  enything global (just in case)

[18:05] <masak> Woodi: but C requires you to explicitly declare variables.

[18:06] <masak> Woodi: it still sounds to me that it's 'no strict' you want.

[18:06] <Woodi> masak: becouse of type

[18:06] <Woodi> masak: no way, 'strict' behaviour by default + more sugar :)

[18:06] <masak> Woodi: that's a strange arguemnt, because there are no variables in C without a type.

[18:07] <moritz> there's no reason C couldn't infer types from initializations, for example

[18:07] *** thou left
[18:07] <masak> Woodi: how can you have both 'strict' behaviour and be able to skip saying 'my'? it doesn't make sense.

[18:07] <moritz> i = 3; # guess what type i could have

[18:08] <arnsholt> moritz: void* obviously ;p

[18:08] <masak> Go does something like that with its := initialization, doesn't it?

[18:08] <Woodi> masak: by default.

[18:08] <masak> Woodi: you're not making enough sense for me to understand your point.

[18:09] *** GlitchMr left
[18:09] *** zby_home joined
[18:09] *** zby_home__ left
[18:09] <Woodi> masak: i will find some Perl 6 code and erase my and post gist :)

[18:10] <TimToady> we are not going to turn Perl 6 into Ruby

[18:10] <masak> Woodi: well, I got the "erase 'my'" part. what I didn't get is how you think that that is somehow still strict.

[18:11] <masak> Woodi: "strict" here *means* "the 'my' declataions aren't optional"

[18:11] <Woodi> 'strict' mean "varibles are local" ?

[18:11] <masak> no.

[18:11] <TimToady> strict means not *guessing* where the variables are

[18:11] <moritz> "strict" means "variables need to be declared"

[18:11] <moritz> and in p5, strict also means 'no barewords as string literals' and 'no soft references'

[18:12] <TimToady> this is one of the bits of Ruby we decided most definitely *not* to borrow

[18:12] <masak> Woodi: from perldoc strict: This generates a compile-time error if you access a variable that wasn't declared via "our" or "use vars", localized via "my()", or wasn't fully qualified.

[18:12] <TimToady> I consider it a misfeature of Ruby

[18:12] <masak> me too.

[18:12] <moritz> "localized via "my()"" sounds... misleading

[18:13] <TimToady> it's one of those little things that is cute when it's small, but bites you when it gets bigger

[18:13] <moritz> after all my() doesn't act on an existing variable, but creates a new one

[18:13] <TimToady> well, "local" is misnamed in Perl 5 :)

[18:14] <Woodi> masak: in Perl 5 'my' was workaround for Perl 4. just wanted to drop and have localized vars by default. but iffinding vars is needed for something more then i will stop

[18:15] <Woodi> and TimToady++ all the time :)

[18:15] <masak> Woodi: interesting historical viewpoint. also, according to me, vastly underestimating lexicals. Ö=

[18:15] <masak> :)

[18:15] <masak> they are not just a "workaround" for Perl 4.

[18:15] <masak> they are "doing it right this time".

[18:16] <Woodi> masak: pls be specific, i know Perl 5 mantras :)

[18:16] <Woodi> Perl 6 :) Perl 5 Maybe too...

[18:17] <masak> basically, dynamicals were the predominant model in Perls 1..4. they're great, but lexicals scale better and are better buddies with compilers.

[18:17] <masak> when I say "dynamical", I mean the behaviour of a variable to follow the runtime flow rather than the static code structure.

[18:17] <masak> and when I say "lexical", I mean "my" variables.

[18:18] <masak> Perl 5 adopted lexical variables with the "my" keyword, but couldn't drop dynamic variables because of backwards compatibility.

[18:18] *** am0c left
[18:19] <Woodi> know that so far

[18:19] <sorear> good * #perl6

[18:19] <masak> eval sub foo { $x = 42 }; sub bar { $x = 5; foo; print $x }; bar

[18:19] <buubot_backup> masak: 421

[18:19] <masak> eval sub foo { $x = 42 }; sub bar { $x = 5; foo; print $x; return }; bar

[18:19] <buubot_backup> masak: 42

[18:20] <masak> Woodi: that's typical dynamicals behaviour.

[18:20] <masak> eval sub foo { my $x = 42 }; sub bar { my $x = 5; foo; print $x; return }; bar

[18:20] <buubot_backup> masak: 5

[18:20] <masak> that's typical lexicals behaviour.

[18:20] <masak> lexicals are *not* a "workaround". :)

[18:21] <masak> though I have the feeling that dynamicals are a bit less-is-more easier to implement...

[18:21] <Woodi> introduce 'm' was workaround for globals by default

[18:21] <masak> Woodi: I feel we're not quite getting through to each other.

[18:22] <Woodi> maybe, maybe not

[18:22] <huf> Woodi: 'my' doesnt just mean it's a lexical variable

[18:22] <huf> it also declares the variable

[18:23] <huf> otherwise how could you tell what $x = 1; means?

[18:23] <huf> is it a new $x? is it the old one?

[18:24] <Woodi> huf: i mean: definition on first occurence (like in all good scripting langauges)

[18:24] <masak> Woodi: yes, the dynamical variables were (package-)global. and they are still the default in Perl 5.

[18:24] <Woodi> but if have downsides then they not often commented

[18:24] <Woodi> masak: forget global, pls !

[18:25] <masak> Woodi: the big downside is that you can't tell a declaration of a new variable from a typo.

[18:25] <masak> the compiler doesn't help you at all there.

[18:25] <masak> if you don't think that's a problem, try writing a large program with a typo in it.

[18:26] <huf> i also find the code easier to read if there is a clear marker for declarations

[18:26] <sorear> masak: "Niecza has it right"... weren't you arguing just yesterday that all macros should be callable as functions? :)

[18:26] <Woodi> agree that 'my' introduce some ordung...

[18:26] <TimToady> calling macros as function is specced somewhere

[18:26] <sorear> phenny: "ordung"?

[18:26] <phenny> sorear: "ordung" (de to en, translate.google.com)

[18:27] <Woodi> but that 'my' features isn't commented a lot - do not saw before.

[18:27] <moritz> phenny: "ordnung"?

[18:27] <phenny> moritz: The de to en translation failed, sorry!

[18:28] <moritz> heh, it identified it as German, but couldn't translate? :-)

[18:28] <Woodi> moritz: yes, this is De word, no idea how to spell/write :)

[18:29] <Woodi> i mean 'order' :)

[18:29] <moritz> that's what 'Ordnung' means, yes :-)

[18:30] <sorear> phenny: "Ordnung"?

[18:30] <phenny> sorear: "Order" (de to en, translate.google.com)

[18:30] <sorear> heh.

[18:30] <TimToady> Woodi: it's commented on all the time, you just don't recognize it.  But you continually here "use strict", and that's what it means, mainly, is "use my"

[18:30] <Woodi> so compilers without 'my' are possible to exist. but if 'my' helps more it's ok for me

[18:30] <TimToady> *hear

[18:30] <sorear> I guess phenny thinks Germans will never be so lazy as to not uppercase a noun?

[18:31] <moritz> well, "google translate really"

[18:31] <Woodi> TimToady: i assumed ('strict5' === 'strict6') == True

[18:32] <moritz> TimToady: how should 'no strict' scope undeclared variables?

[18:32] <TimToady> Woodi: it is not at all clear what you mean by that

[18:32] <moritz> TimToady: to the outermost mutable scope? or package scope?

[18:33] <Woodi> i assumed 'strict in p5' == 'strict in p6'

[18:33] <TimToady> I don't see much reason not to do it the way Perl 5 does it, offhand

[18:34] *** alvis left
[18:34] <TimToady> Woodi: that's the part that was clear, not the part that was unclear

[18:34] <TimToady> in which sense did you mean it?

[18:35] *** am0c joined
[18:36] <masak> Woodi wants 'my' declarations to be optional by default.

[18:36] <Woodi> TimToady: not see any meta-sense here. just thinked 'my' is for locality

[18:36] *** alvis joined
[18:36] <masak> Woodi: 'my' *is* for "locality" (but it's called "lexicality")

[18:36] *** sunnavy left
[18:37] *** sunnavy joined
[18:37] <Woodi> masak: that i know. new part for me is it is for other things too

[18:37] <TimToady> there are three different sub-meanings of strict in P5, plus whether to apply it by default

[18:38] <TimToady> plus the semantics of 'no strict vars', which is what I was answering moritz++ about

[18:38] <TimToady> anyway, P5 differs from P6 in all four of those ways

[18:39] <moritz> though of course 5.14 (or was it 5.12?) enables 'strict' if you request that version

[18:39] <TimToady> so I have no idea which one you thought was ==

[18:39] <Woodi> TimToady: ony 'my' part

[18:39] <Woodi> only*

[18:40] <TimToady> that's still two different ways, 'use strict vars' or 'on by default'

[18:42] <Woodi> which part is about locality/lexicals ?

[18:42] <TimToady> the 'vars' part

[18:42] <dalek> niecza: b117e92 | sorear++ | / (2 files):

[18:42] <dalek> niecza: Horrible little hack to redirect CompilerBlob so serialize can build NieczaBackendDotnet

[18:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b117e92930

[18:43] <Woodi> so even in Perl5 it means that declaration need to be in place ? thinked it only to differentiate from global vars...

[18:44] <sorear> wooh, niecza just built itself again

[18:44] <Woodi> it have double meaning...

[18:44] <Woodi> and if this discussion have no sense can we finish now ?

[18:44] <sorear> (that said, the newly built one isn't quite working)

[18:44] <TimToady> sure :)

[18:44] * moritz submits p5 doc patch to unconfuse strict.pm

[18:46] <moritz> lots of people in perl community (in particular on perlmonks) complain that interaction with p5p is hard. I just have the feeling that *discussing* things with p5p is hard, because they don't offer a coherent opinion

[18:46] <moritz> getting simple patches accepted is a lot easier, IME

[18:48] <sorear> #p5p is pretty friendly

[18:49] <Woodi> TimToady: can you tell what you mean about problems in Ruby lastly ?

[18:51] <masak> <TimToady> it's one of those little things that is cute when it's small, but bites you when it gets bigger

[18:51] <masak> Woodi: that

[18:51] <masak> Woodi: it's what I said about typos.

[18:54] * Woodi still do not understand. but ok. tell him go coffe (ASAP or SAP) :)

[18:55] <arnsholt> Woodi: With implicit declarations you won't catch the typo of writing $vairable when you actually meant $variable

[18:55] <masak> Woodi: you'll understand after you've written that 1000-line program with a typo in it and 'strict vars' turned off :)

[18:56] <colomon> masak: why do I use .gist with say?  because I have no idea what does what now....

[18:57] <moritz> say uses .gist, print uses .Stringy (which re-dispatches to .Str)

[18:58] *** ponbiki left
[18:58] <Woodi> understud case. but it is not so big feature

[19:02] *** GlitchMr joined
[19:05] <masak> Woodi: the fact that you say that tells me that you haven't felt the pain of the abscence of the "not so big feature".

[19:05] <masak> yet.

[19:06] <dalek> niecza: 5792d5b | sorear++ | lib/ (2 files):

[19:06] <dalek> niecza: Avoid O(n) GetField and GetMethod in thaw procedure

[19:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5792d5b0bd

[19:06] *** molaf__ left
[19:07] <Woodi> masak: so far I used Perl 5 to detect this error :)

[19:07] <sorear> cuts "mono-sgen run/Niecza.exe --help" from 13.5s to 2s...

[19:07] *** soh_cah_toa left
[19:07] <Woodi> 'used only once, can be....'

[19:10] <moritz> that doesn't catch accidental variable reuse in an inner scope

[19:16] <cognominal> coffeescript felt in that ruby trap and I got burned quite a few times.

[19:17] <Woodi> cognominal: 'trap' means no vars predeclaration ?

[19:18] <cognominal> yup

[19:21] <cognominal> at least,  they are not global by accident

[19:21] <Woodi> k. but so far 'declaration-on-sight was standard for scriptic languages :)

[19:21] <pmurias> jnthn: "that view" - you mean mine or the one which allows 'is rw' invocants

[19:22] <pmurias> jnthn: "is rw" invocants imply that the method is looked up on the object and invoked on the container 

[19:22] <jnthn> pmurias: yours

[19:22] <cognominal> Woodi, that does not make this behavior right.

[19:23] <pmurias> jnthn: how so?

[19:23] <jnthn> I don't get "invoked on" - the on-ness is all in the lookup really.

[19:23] <jnthn> Beyond that point, it's just the same as a sub call.

[19:24] <pmurias> in the implementation yes

[19:24] <Woodi> cognominal: agree, now :)

[19:25] <pmurias> the method just takes the capture, i can imagine the user putting some unrelated object in the invocant

[19:26] <jnthn> They may, sure

[19:26] <jnthn> The binder will catch them though since the invocant has a type constraint on it.

[19:26] <jnthn> (that is, will catch them passing anything they're not allowed to)

[19:26] <cognominal> Woodi, that did not matter much in old scripting languages. But in coffeescript, this is particularly bad because it is a functional language so scoping is a crucial concept.

[19:27] <sorear> pmurias: I want you to think about @foo[0][0] = 12; and @foo[0]."postcircumfix:<[ ]>"(0) = 12

[19:27] <masak> cognominal: that's a very good point. 'my' makes scoping more *exact*, which is important in languages which care about lexical scopes.

[19:28] <masak> Woodi: think about 'my $var; { $var = 42 }; say $var' and what would happen if the declaration was taken away but "declare-on-sight" was in effect.

[19:28] <arnsholt> masak: That's one of my main philosophical complaints with Python and Ruby. Since you don't declare variables, all your functions have only a single, top-level scope

[19:29] <arnsholt> Probably makes implementations a bit simpler though =)

[19:29] <masak> arnsholt: JavaScript is a "fun" case of that. they have you declare variables, but all your functions *still* have only a signle, top-level scope :(

[19:29] <sorear> Javascript is the same way really even though it does have declarations

[19:29] * Woodi realy lost now... do C is some niche language ?

[19:29] <masak> sorear is stealing my thoughts but he expresses them shorter.

[19:29] <masak> :)

[19:30] <sorear> it's useful sometimes but I spent about two days figuring it out

[19:30] <arnsholt> Ah yes, JavaScript. Always a good example, both for cool features and horrible misfeatures

[19:30] <masak> Woodi: C has declarations. we told you this an hour ago.

[19:30] <masak> Woodi: C not only has declarations, it allows variables to be declared in nested scopes, not just in the top-level function scope.

[19:30] <cognominal> speaking about javascript/coffeescript, I have not thought yet if executing a function in a particular context is meaningful in Perl6

[19:31] <masak> at least, um, ANSI C or something. not K&R C.

[19:31] <masak> cognominal: are you referring to nested subs? they're wonderful.

[19:31] <Woodi> masak: I point C as nice guesing what { var_here } mean

[19:31] <masak> Woodi: but it doesn't guess. you have to declare variables in C.

[19:32] <sorear> as opposed to FORTRAN, which *does* tuess

[19:32] <masak> oh man, FORTRAN is declare-on-sight? :/

[19:32] <sorear> FORTRAN even has this lovely feature, almost feels like a precursor of sigils, where variables starting with <[ I .. N ]> are integers and the rest are reals

[19:33] <Woodi> declaration-on-sight is declaration place and inside {} use C guesing rule..

[19:33] <masak> maŭbe I shouldn't be surprised; BASIC is, too.

[19:33] <cognominal> masak:  I am talking about the apply function, http://justin.harmonize.fm/index.php/2009/09/an-introduction-to-javascripts-this/

[19:33] <moritz> sorear: ... unless declared otherwise

[19:33] <sorear> masak: I think they removed that feature in one of the more recent revisions

[19:33] <masak> Woodi: but there *is* no "C guessing rule"...

[19:33] <pmurias> niecza: my @a;my $a = @foo[0];$a[0] = 12;say @a.perl;

[19:33] <masak> Woodi: you're misinformed on that one.

[19:33] <p6eval> niecza v10-225-gbd53b44: OUTPUT«===SORRY!===␤␤Variable @foo is not predeclared at /tmp/sx0owaMyWw line 1:␤------> my @a;my $a = ⏏@foo[0];$a[0] = 12;say @a.perl;␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line …

[19:33] <Woodi> no

[19:33] <pmurias> niecza: my @foo;my $a = @foo[0];$a[0] = 12;say @foo.perl;

[19:33] <p6eval> niecza v10-225-gbd53b44: OUTPUT«␤Unhandled Exception: System.InvalidOperationException: out of sync␤  at System.Collections.Generic.Dictionary`2+Enumerator[System.Object,System.Reflection.FieldInfo].VerifyState () [0x00000] in <filename unknown>:0 ␤  at System.Collections.Generic.Dictio…

[19:34] * Woodi tee

[19:34] <cognominal> masak: there are many blog entry about the meaning and use of this in javascript, this one is not the best but I can't find the one I search for.

[19:34] <pmurias> sorear: that exception seems to be strange

[19:34] <masak> Woodi: you're misinformed on that one, and you're stubborn enough to protest when told the truth.

[19:34] <cognominal> masak: http://howtonode.org/what-is-this

[19:35] *** donri joined
[19:35] <masak> cognominal: I have a vague knowledge about 'this' in JavaScript. I expect to learn it for real soonish, as I delve deeper into JS.

[19:35] *** fridim_ left
[19:35] <pmurias> sorear: my understanding of @foo[0][0] = 13 is that the container returned by @foo[0] handles the [0] method call

[19:37] <masak> Woodi: https://gist.github.com/1324972

[19:37] <cognominal> masak: coffeekup use very much  apply and call. I have yet to reading it carefully. But it is coffeescript at its best.

[19:37] <masak> cognominal: ok :)

[19:39] <sorear> pmurias: yes, but the container returned by @foo[0] is _empty_

[19:39] <Woodi> masak: you intentionaly misunderstand me ?

[19:40] <Woodi> i say: C-like guesing not C like declarations

[19:40] <masak> Woodi: no, I'm sincerely trying to communicate with you.

[19:40] <sorear> pmurias: this only works (try a working compiler, not niecza) because of rw invocants

[19:40] <masak> Woodi: what do you mean by "C-like guessing"? there is none that I know of.

[19:40] <Woodi> and discusion is of-Perl6-topic now

[19:41] <masak> Woodi: we are having communication problems. please bear with me.

[19:41] <masak> and I'll do my best to understand your points.

[19:41] <Woodi> buubot_backup: my $a="rule"; { print $a };

[19:41] <buubot_backup> Woodi: Couldn't match input.

[19:41] <moritz> saying "what I said was bullshit" clears up much more than saying "the discussion is now off-topic, stop it"

[19:41] <Woodi> something like this

[19:41] <pmurias> rakudo: my @foo;my $a = @foo[0];$a[0] = 12;say @foo.perl;

[19:41] <p6eval> rakudo 9c6aed: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/wVHVFEveaE:1␤  in <anon> at /tmp/wVHVFEveaE:1␤»

[19:42] <masak> Woodi: that's not "C-like guessing", that's the rules for lexical lookup!

[19:42] <Woodi> you should guess it dear Masak

[19:42] <pmurias> rakudo: my @foo;@foo[0][0] = 12;say @foo.perl;

[19:42] <p6eval> rakudo 9c6aed: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/SxnU2ubpyd:1␤  in <anon> at /tmp/SxnU2ubpyd:1␤»

[19:42] <masak> Woodi: I'm trying my best to guess what you mean. it's hard.

[19:42] <sorear> b: my @foo;@foo[0][0] = 12;say @foo.perl;

[19:42] <jnthn> That's Rakudo not doing auto-viv...

[19:42] <p6eval> b 1b7dd1: OUTPUT«[[12]]␤»

[19:43] * jnthn should probably task steal that one from pmichaud++

[19:43] <masak> Woodi: nevertheless, thanks for your patience in explaining what you mean.

[19:44] <pmurias> sorear: but it's the empty container doing the magic not the value inside it otherwise my $foo = @foo[0];$foo[0] = 12; would also autovivify

[19:44] <masak> Woodi: part of the problem in understanding what you mean is that your terminology is "non-standard" (by which I mean "arbitrary and illogical")

[19:45] <Woodi> i do my best :) 

[19:45] <masak> Woodi: "you should guess, dear masak" after I finally understand you might be meant as a joke, but it comes off as being slightly obnoxious.

[19:46] <masak> Woodi: nevertheless, I now understand that by "C-like guessing" you meant "lexical lookup". please use that term from now on. :)

[19:47] <Woodi> masak: i adopting to Perl6 and not so far ago I was close to formulate YX problem :)

[19:47] <masak> of course. we're all on a learning curve here. that's fine.

[19:47] <sorear> pmurias: my $foo; $foo[0] = 12 does autovivify

[19:49] *** sunnavy left
[19:49] *** sunnavy joined
[19:51] * Woodi now knows: a) Haskell; b) lexical lookup; :)

[19:51] <dalek> niecza: b12f0e7 | sorear++ | lib/Kernel.cs:

[19:51] <dalek> niecza: Fix iterator usage in previous commit

[19:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b12f0e728e

[19:52] *** GlitchMr42 joined
[19:52] <masak> Woodi: interesting tidbit: Perl 6 is *full* of lexical scoping. the concept is used to its limit.

[19:53] <dalek> niecza: ea5d9a0 | sorear++ | src/STD.pm6:

[19:53] <dalek> niecza: Track s/Cursor.new/Cursor.cursor_start/

[19:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ea5d9a0e3e

[19:53] <masak> Woodi: I periodically have an insight along the lines of "oh wow, this uses lexical scoping too? cool!"

[19:53] <masak> it's just such a winning concept.

[19:53] <masak> that's why I protested earlier when you characterized it as a "workaround" :)

[19:54] <moritz> nom: class A { eval 'has $.x' }; say A.new(x => 3).x

[19:54] <p6eval> nom 9c6aed: OUTPUT«===SORRY!===␤A  cannot have attributes at line 1, near ""␤»

[19:54] <moritz> nom: class A { BEGIN eval 'has $.x' }; say A.new(x => 3).x

[19:54] <p6eval> nom 9c6aed: OUTPUT«===SORRY!===␤A  cannot have attributes at line 1, near ""␤»

[19:54] *** GlitchMr left
[19:54] <moritz> why not?

[19:55] <moritz> class A { do { has $.x } }; say A.new(x => 3).x

[19:55] <moritz> nom: class A { do { has $.x } }; say A.new(x => 3).x

[19:55] <p6eval> nom 9c6aed: OUTPUT«3␤»

[19:55] <jnthn> moritz: Probably that eval doesn't know it's in a class definition or some such

[19:55] <moritz> so, inner scopes do not prevent attributes from working, but eval do?

[19:56] <jnthn> moritz: e.g. it's treated like a little bit of mainline

[19:56] <jnthn> moritz: I guess you can argue that the BEGIN case there should work

[19:56] <moritz> jnthn: but the error message knows that it's in A

[19:56] * masak submits rakudobug

[19:56] <jnthn> moritz: no, the error message is busted

[19:56] <jnthn> masak: no, wait

[19:56] * masak waits :)

[19:56] <jnthn> What are you actually going to submit?

[19:56] <jnthn> The first case should certainly not work

[19:56] <masak> agreed.

[19:56] <moritz> aye

[19:56] <jnthn> The second one...maybe.

[19:56] <masak> agreed.

[19:57] <jnthn> So the question is...

[19:57] <masak> it certainly shouldn't give that error message if it doesn't work.

[19:57] <jnthn> In eval, what do we treat as the current package?

[19:57] <jnthn> masak: The "A" in the error messsage is not referring to the clas A

[19:57] <masak> the current package of the caller?

[19:57] <jnthn> Call it B in the code to see :)

[19:57] <Woodi> masak: ppls have two half-spheres in head. and probably connections betwin dhat halves are responsible for talking. so: few ppls are much worse with putting concepts into spoken words what do not say how good they grok concepts...

[19:57] <masak> jnthn: aha, it's an article ;)

[19:58] <jnthn> nom: class B { BEGIN eval 'has $.x' }

[19:58] <moritz> nom: class B { BEGIN eval 'has $.x' }; say B.new(x => 3).x

[19:58] <p6eval> nom 9c6aed: OUTPUT«===SORRY!===␤A  cannot have attributes at line 1, near ""␤»

[19:58] <jnthn> Right

[19:58] <jnthn> See the double space? :)

[19:58] <jnthn> It doesn't know what sort of thing it is in :)

[19:58] <Woodi> so, do not wory, i know what that lookup is :)

[19:58] <jnthn> nom: has $.x

[19:58] <p6eval> nom 9c6aed: OUTPUT«===SORRY!===␤A  cannot have attributes at line 1, near ""␤»

[19:58] <jnthn> Right. :)

[19:58] <jnthn> So there's two things here

[19:58] * sorear wonders hypothetically if conducting the conversation in some other language would help.

[19:59] <jnthn> First, reporting of declaring attributes in the mainline is giving a crappy error

[19:59] <masak> Woodi: absolutely -- verbalizing != conceptualizing.

[19:59] <jnthn> Second, eval is doing the wrong kind of thing about current package.

[19:59] <masak> jnthn: so... TWO rakudobugs? :D

[19:59] <moritz> masak: I'm fixing the error message right now

[19:59] <jnthn> masak: Right. They're separate issues :)

[20:00] <jnthn> Well, apart from.. )

[20:00] * masak submits rakudobug

[20:00] <jnthn> What moritz said :)

[20:00] <jnthn> But tickets are easy to close too :)

[20:00] <masak> yeah :)

[20:00] <masak> and good bookkeeping

[20:00] <jnthn> Gotta get you to your 2000 :P

[20:01] *** soh_cah_toa joined
[20:01] <moritz> masak: if you open a ticket for the error message, that's just maintenance overhead

[20:01] <masak> moritz: ah, you don't think we need a spectest for it?

[20:02] <moritz> masak: nope, because the error message isn't specced (yet)

[20:02] <masak> then I'll just submit the eval-current-package one.

[20:02] <masak> good point.

[20:02] <moritz> no objections to the BEGIN eval ticket

[20:02] <jnthn> Yeah, we should probably make that one work.

[20:03] <jnthn> I'm in the middle of re-doing the repr API at the moment though, so won't get to that for a day or two.

[20:04] <moritz> what should the error message read? "The mainline cannot have attributes"?

[20:04] <masak> Woodi: I'm not underestimating your intelligence, or your familiarity with concepts. but if you say "lexical lookup" rather than "C-like guessing", it's easier for *me* talking with you.

[20:05] <masak> a common terminology helps.

[20:06] <jnthn> moritz: Something like that would work

[20:06] * moritz tests

[20:07] <cognominal> I have done a lot of rakudo code reading this last few days. I am impressed by the progress made.    jnthn++ pmichaud++ among others.

[20:07] <masak> moritz: "Can't declare an attribute outside of class or role definiton"

[20:07] <dalek> niecza: 3909462 | sorear++ | lib/CodeGen.cs:

[20:07] <dalek> niecza: Reimplement generation of goto target handlers

[20:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3909462f10

[20:07] <moritz> masak: what about grammars?

[20:07] <masak> moritz: I wouldn't mind if they're not mentioned in the error message.

[20:07] <cognominal> it is nice to see that much more implementation code is written in Perl 6

[20:07] <masak> feels more like a kind of "foolish completeness"

[20:07] <moritz> I thought "outside of a package", but not all packages support attributes either

[20:08] <masak> it's more like a kind of "OO package".

[20:08] <jnthn> "You can't declare an attribute here" :)

[20:08] <jnthn> "You can't declare an attribute here; maybe you'd like a class or a role?" :)

[20:08] <sorear> Whitespace is required betwee alphanumeric tokens: sub none (*@p) { no⏏ne @p }  <--- my least favorite kind of nieczabug to debug.

[20:09] <masak> jnthn: +1

[20:09] * moritz likes jnthn++'s last proposal

[20:09] <masak> it's very friendly.

[20:09] * jnthn occasionally is :)

[20:11] <cognominal> not everyone can be a git, or design it.

[20:11] <moritz> cognominal++

[20:12] <dalek> rakudo/nom: 40f181b | moritz++ | src/Perl6/Actions.pm:

[20:12] <dalek> rakudo/nom: fix "cannot have attributes" error message for the mainline. jnthn++

[20:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/40f181b8f7

[20:17] <dalek> nqp: b498832 | moritz++ | tools/build/PARROT_REVISION:

[20:17] <dalek> nqp: bump PARROT_REVISION to after the green_threads merge to get some more testing

[20:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b498832b5d

[20:18] *** GlitchMr42 left
[20:19] *** fsergot left
[20:28] *** whiteknight left
[20:28] *** whiteknight joined
[20:28] *** whiteknight left
[20:29] *** whiteknight joined
[20:29] *** cognominal left
[20:31] *** cognominal joined
[20:32] *** SHODAN left
[20:34] *** saaki left
[20:35] <dalek> niecza: 14a888b | sorear++ | src/niecza:

[20:35] <dalek> niecza: Fix compilation of endsym annotations

[20:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/14a888b519

[20:35] <sorear> \o/ niecza/serialize-compiled-niecza/serialize can run say "Hello, world"

[20:37] <masak> \o/

[20:37] <sorear> now spectesting

[20:41] *** wooden joined
[20:49] *** pothos left
[20:50] <sorear> hrm, new-niecza can't seem to handle #`<< > >>

[20:51] *** y3llow_ joined
[20:51] *** pothos_ joined
[20:51] *** pothos_ is now known as pothos

[20:52] <dalek> roast: e8eb581 | Coke++ | / (9 files):

[20:52] <dalek> roast: niecza fudging

[20:52] <dalek> roast: review: https://github.com/perl6/roast/commit/e8eb58149a

[20:53] *** y3llow left
[20:53] *** y3llow_ is now known as y3llow

[20:54] <sorear> [Coke]: are you fudging previously working tests?  I'm starting to fear I'm missing regressions because of this project

[20:56] *** kfo_ joined
[20:59] *** kfo left
[21:00] *** jdv79 left
[21:06] <sorear> niecza: say "<" x 2e0

[21:06] <p6eval> niecza v10-230-g3909462: OUTPUT«<␤»

[21:06] <masak> nom: say "<" x 2e0

[21:06] <p6eval> nom 40f181: OUTPUT«<<␤»

[21:06] <sorear> pretty obviously broken

[21:07] <sorear> niecza: say 1e0 >= 1

[21:07] <p6eval> niecza v10-230-g3909462: OUTPUT«Bool::True␤»

[21:07] <sorear> niecza: my $x = 2e0; $x--; say $x; say $x.WHAT; say $x >= 1

[21:07] <p6eval> niecza v10-230-g3909462: OUTPUT«NaN␤Num()␤Bool::False␤»

[21:07] <sorear> WHAT.

[21:09] <sorear> niecza: say 0e0.succ

[21:09] <p6eval> niecza v10-230-g3909462: OUTPUT«1␤»

[21:09] <sorear> niecza: say 0e0.pred

[21:09] <p6eval> niecza v10-230-g3909462: OUTPUT«NaN␤»

[21:10] <masak> negative numbers: they are a sham.

[21:12] *** Khisanth joined
[21:14] *** breinbaas left
[21:18] *** breinbaas joined
[21:18] *** poincare101 left
[21:18] *** poincare101 joined
[21:22] *** wolfman2000 left
[21:27] *** _jaldhar left
[21:33] *** zby_home left
[21:33] <dalek> niecza: 3a82e24 | sorear++ | lib/Serialize.cs:

[21:33] <dalek> niecza: Fix deserialization of 64-bit values between -2**62-1 and -2**63

[21:33] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3a82e24f3d

[21:37] *** explorer__ left
[21:37] *** packetknife joined
[21:39] *** donri left
[21:43] <masak> 'night, #perl6

[21:44] <lue> hello world! o/

[21:44] *** xinming left
[21:44] <jnthn> hellue

[21:44] <lue> goodnight, masak

[21:46] *** xinming joined
[21:55] *** kaare_ left
[22:04] *** mj41 left
[22:12] *** drbean left
[22:13] *** dual left
[22:18] <sorear> what?

[22:18] <sorear> "Result: PASS"

[22:18] <sorear> \o/ \o/ \o/ \o/

[22:18] *** packetknife left
[22:18] *** drbean joined
[22:19] <sorear> TODO: automate

[22:20] <diakopter> sorear: impressive!

[22:22] *** soh_cah_toa left
[22:24] <TimToady> it's not "Cannot declare an attribute here"; it's "Cannot declare an attribute now"  :)

[22:29] <jnthn> I could declare it now if I were somewhere else now :P

[22:31] <TimToady> well, "Too late to declare attribute" would be much more communicative

[22:31] <TimToady> "Too late to declare attribute without augment" anyway

[22:32] <jnthn> TimToady: ah, you mean the eval case?

[22:32] <TimToady> yes

[22:32] <jnthn> Yeah, we can do better there

[22:32] <jnthn> TimToady: I thought you meant the mainline case.

[22:32] <TimToady> sorry

[22:32] <jnthn> np

[22:33] <TimToady> brane not fiering on all cilyndrs toady

[22:34] <TimToady> interestingly, \$x is a decl isn't even specced anywhere

[22:34] *** pmurias left
[22:34] <TimToady> I'm also thinkin' that |$x wants to lose its sigil

[22:34] <jnthn> Hm

[22:34] * jnthn ponders that |@x is actually meaningful-ish...

[22:35] <jnthn> But it may well not do the right thing.

[22:35] <jnthn> And could be hard to make it do so.

[22:35] <TimToady> @(|x) is probably what you really want there anyway

[22:35] <jnthn> Yes.

[22:35] <jnthn> wfm if we do that.

[22:36] <sorear> jnthn: how are we feeling today about adding attributes to P6opaque post-compose?

[22:36] <TimToady> your current |$x works snapshotty?  spec currently says the rest of the sig can only be parsed by a subsig, and I'm of the impression that's not how it is currently

[22:36] <sorear> jnthn: do you mean |@x in a signature?

[22:36] <jnthn> sorear: yes

[22:36] *** whiteknight left
[22:36] <jnthn> sorear: (adding attributes post-compose) -1 for P6opaque. Use a different repr.

[22:37] <sorear> jnthn: is this still the my \x = term; discussion?

[22:37] <TimToady> yes

[22:37] <sorear> diakopter: I was worrying if I'd be this far by Monday

[22:37] * TimToady is considering that | params want the same treatment

[22:37] <TimToady> since they're nearly as raw as parcels

[22:37] <sorear> diakopter: it's always kind of shocking when you plan for a third 80% and it doesn't materialize

[22:37] <TimToady> and should not commit to itemization

[22:38] <jnthn> sorear: Sometimes things work out well :)

[22:38] <TimToady> it means you did one or two things right for a change :)

[22:38] <jnthn> TimToady: Current |$x works snapshotty, yes

[22:39] <diakopter> or more tests are needed ;)

[22:39] <TimToady> but then how do you continue

[22:39] <jnthn> TimToady: The binder would be totally happy about it showing up at any point.

[22:39] <jnthn> TimToady: The limitation in nom is actually because I copied STD's notion that | is a variadic.

[22:39] <jnthn> TimToady: That is, it's purely a compiler restriction. The binder will happily see capture params at any point and cope.

[22:39] <TimToady> (|$x $y, $z) or (|$x, $y, $z) or (|$x ($y, $z)) <- current spec

[22:40] <jnthn> OK, the first is...weird to me :)

[22:40] <TimToady> well, it's just another constraint in that case

[22:40] <jnthn> wait, does that even parse?

[22:40] <TimToady> probably not

[22:40] <jnthn> std: sub foo(|$x $y, $z) { }

[22:40] <p6eval> std be1f10e: OUTPUT«===SORRY!===␤Unable to parse signature at /tmp/u0OpPETMkz line 1:␤------> sub foo⏏(|$x $y, $z) { }␤Couldn't find final ')'; gave up at /tmp/u0OpPETMkz line 1:␤------> sub foo(|$x ⏏$y, $z) { }␤    expecting any o…

[22:40] <jnthn> Was gonna say

[22:40] <jnthn> I followed STD pretty closely in terms of what we parse in the signatures.

[22:40] <TimToady> but in the middle one, is $y still the first ar in $x?

[22:41] <TimToady> *arg

[22:41] <jnthn> TimToady: Yes

[22:41] <jnthn> (more)

[22:41] <jnthn> TimToady: The Rakudo binder interpretation of |$c is that it's transparent to the current binder state

[22:41] <TimToady> it's probably saner that way, I guess, given that rvalue | returns to the same level too

[22:41] <jnthn> TimToady: Apart from that if allows you not to capture anything after it if you meant it to swallow everything.

[22:42] <jnthn> But you could write

[22:42] <jnthn> sub ($a, $b) { }

[22:42] <jnthn> And

[22:42] *** soh_cah_toa joined
[22:42] <diakopter> is there a way to git add * recursively into dirs

[22:42] <jnthn> sub (|$c1, $a, |$c2, $b, |$c3) { }

[22:42] <jnthn> And $a and $b would get exactly the same things in them 

[22:42] <TimToady> nodnod

[22:42] <jnthn> I actually thought that worked in Rakudo up until a few days ago, when I found it didn't get past the parse. :)

[22:43] <TimToady> note also that I've been thinking of the snapshot-ness as a way of maybe doing partial binding

[22:43] <jnthn> Yes, that's how we ended up with snapshot semantics :)

[22:43] <sorear> jnthn: why, does |$c2 reset to the beginning?

[22:43] <jnthn> sorear: No

[22:43] <jnthn> sorear: In the above case, $c1 will have two positionals, $c2 will have one, $c3 will have nothing.

[22:44] <jnthn> sorear: It's really "snapshot what we didn't yet bind"

[22:44] <TimToady> so something like map could just tack a |$restart on the end and then pass that back as the new place to start next time

[22:44] <jnthn> TimToady: Yeah, we never quite figured out what passing it back meant

[22:44] <sorear> jnthn: ah, misunderstood what you meant by "$a and $b would get the same"

[22:44] <sorear> diakopter: I thought git add did that by default

[22:44] <jnthn> sorear: ah, sorry. That wasn't so clear.

[22:44] <jnthn> sorear: I meant same values in both cases, not some values :)

[22:45] <jnthn> TimToady: The other problem I struggled on a bit is how to do it efficiently.

[22:45] <TimToady> snapshotting the bind state being conceptually cleaner than introspecing sigs for arity

[22:45] <sorear> diakopter: the manpage says it does do that by default

[22:45] <jnthn> TimToady: Well, true, but from a cost perspective, it's cheap to ask the block its arity once then zip through the list

[22:45] <TimToady> you almost want to have captures stored in Lispy cons lists

[22:46] <TimToady> so your snapshot is just a pointer into the leaves

[22:46] <TimToady> s/leaves/branches

[22:46] <jnthn> That probably means making capture a load smarter than it curerntly is

[22:46] <jnthn> (Which may not be a problem, of course.)

[22:46] <TimToady> well, you asked about efficiency, and we do try to do all the Capture(Parcel) we can at compile time

[22:47] <TimToady> anyway, cons lists beat copying all the rest of the params every time through the map

[22:47] <TimToady> s/params/args/

[22:47] <jnthn> Well, I was thinking about the map case in particular here

[22:47] <TimToady> cain't think today

[22:48] <jnthn> Part of the problem here is that I've hooked all of Parrot's arg handling that I can and I fear implementing this efficiently depends on a part I can't hook.

[22:48] <sorear> treating captures as an alist will make named arguments very awkwrd since they can be removed in any order

[22:48] <TimToady> just the ordered part, not the named part

[22:49] <jnthn> sorear: I assumed we were just talking about...that.

[22:49] <jnthn> :)

[22:49] <sorear> TimToady: so the named part should be snapshot by copying?

[22:49] <jnthn> sorear: That's what Rakudo does.

[22:49] <jnthn> Nameds tend to be kinda incidental anyway.

[22:49] <TimToady> or just deleting them when they're used

[22:50] <TimToady> wait, that won't work, nevermind

[22:50] <jnthn> phew, I spent a while wondering what I'd missed :P

[22:50] *** itz left
[22:51] * TimToady 's brane tends to revert to mutable semantics when it is not working well

[22:52] <TimToady> another way, keep the actual named params in the list, but have a record of which names we've seen, so we don't scan the list for names we know aren't there

[22:52] <jnthn> TimToady: To push another issue that I'm going to run up against onto your stack: I'd like to try and figure out the "when do we have value semantics" thing at some point. (more)

[22:52] *** itz joined
[22:52] <jnthn> I'm currently working on the compact struct stuff.

[22:52] <jnthn> But that raises the "what is a compact struct" question

[22:53] <jnthn> And I'm suspecting it's better to let the programmer decide they want those semantics rather than just force them on them because their class happens to just contain native types, etc.

[22:53] <TimToady> could well be; I kinda see the issue there

[22:54] <sorear> jnthn: you mean pass-by-value a la CLR ValueType?

[22:54] <jnthn> C# does it by having a class vs struct keyword

[22:54] <jnthn> sorear: Yes, that

[22:54] <TimToady> issue is, do you let them change an element of the struct

[22:54] <TimToady> do you reserve the right to keep it immutable, and just poke a new struct in the same place?

[22:54] <sorear> TimToady: sure if you declare the parameter rw :D

[22:55] * sorear hasn't actually thought deeply on this

[22:55] <TimToady> at what point are refs just native immutables point to mutables?

[22:55] <TimToady> and when do you need a natvie immutable ref pointing to a mutable ref for rw semantics

[22:55] <dalek> niecza: 98f83a8 | Coke++ | t/spectest.data:

[22:55] <dalek> niecza: run fudged tests

[22:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/98f83a89b4

[22:55] <TimToady> and how do you type all those?

[22:55] <jnthn> TimToady: Yeah, it gets...fun.

[22:56] <TimToady> how much of C do you reproduce, in short

[22:56] <sorear> with your keyboard or with your type system?

[22:56] <TimToady> the latter

[22:56] <TimToady> I don't care how it's spelled :)

[22:57] <jnthn> TimToady: I haven't got all the way with thinking through the details yet.

[22:57] <TimToady> and how do you reproduce C semantics on VMs that are inimical to it, such as JVM

[22:57] <jnthn> TimToady: Getting bigint stuff right is kidna my first use case.

[22:57] <jnthn> (Since it's the first time I have something besides int/num/str that I need to flatten in to another type)

[22:58] <sorear> also, what of? sub foo(uint16 $x) {...}; my uint8 $y; ...; foo($y)

[22:58] <TimToady> well, the abstraction layer is supposed to help you there, whether or not the bigint implementation scales down well enough

[22:58] <jnthn> TimToady: That wasn't quite what I meant

[22:58] <sorear> jnthn: why do you need to flatten Int into other types?

[22:59] <jnthn> TimToady: Just more that at an implementation level, flattening the bigint repr's storage into Int is what we want, otherwise things get expensive.

[22:59] <jnthn> TimToady: And doing that without cheating means I should go and work on the compact struct stuff.

[22:59] <jnthn> Plus I don't really thinking something like P6opaque is the place to start putting in hacks :)

[23:00] <jnthn> sorear: I don't; I need P6bigint to flatten into Int.

[23:00] <TimToady> which is why I lean towards including a good bigint directly as Int, rather than wrapping a failover from Int64 to bigint

[23:00] <jnthn> TimToady: Well, that's what I'm aiming at.

[23:00] <TimToady> a good bigint package should do the little integers efficiently

[23:00] <TimToady> as well as the big ones

[23:01] <TimToady> if you really need the speed, you'll use natives anyway

[23:01] <jnthn> Well, yes. 

[23:02] <sorear> I think where jnthn is going is that he wants to implement Int via NQP for consistancy with the other user-visible types

[23:02] <sorear> P6bigint can be a funky primitive because it's hidden

[23:02] <jnthn> sorear: Well, it's not really an NQP level issue

[23:03] <jnthn> sorear: It's simply that I don't want P6opaque to special-case big integer handling

[23:03] <jnthn> Especially when it's just a degenerate case of the compact struct issue.

[23:03] <sorear> jnthn: you could, in principle, have a custom repr for Int that handles big integers without touching P6opaque at all

[23:03] <jnthn> Apart from the struct in question is from a bigint library

[23:04] <jnthn> sorear: Yes, but it's be a royal pain.

[23:04] <jnthn> sorear: I'd have to re-implement most of P6opaque inside of it.

[23:04] <jnthn> sorear: Remember you can mix whatever you want into Int.

[23:04] <jnthn> 42 but role { has num $!alomorph } ...

[23:05] <jnthn> sorear: It'd just make for an awkward factoring and probably cause bugs.

[23:05] <jnthn> I'd rather Int is just a P6opaque with the bigint library's structure flattened directly into the body of it.

[23:07] <jnthn> And if the factoring is right, from P6opaque's point of view, any flattened in stuff is just "a bunch of bytes that some repr other than me knows what to do with"

[23:08] <TimToady> that way feels righter to me too, fwiw, wim

[23:10] <jnthn> Anyway, that's why I'm currently twiddling a bunch of 6model guts. :)

[23:12] <TimToady> bbl &

[23:13] <jnthn> hmm...getting a bit tired here...

[23:13] * jnthn decides to continue with the refactor tomorrow

[23:17] *** jferrero joined
[23:18] *** shinobicl_ joined
[23:19] <jnthn> sleep &

[23:26] <[Coke]> sorear: I'm pretty sure all the things I've fudged today were for tests that were not already being run.

[23:26] <sorear> ok, good

[23:27] <[Coke]> Going forward, I'll try to make sure I open tickets if I have to fudge something in "make spectest"

[23:27] <[Coke]> that work?

[23:27] *** whiteknight joined
[23:28] <sorear> [Coke]: yes

[23:28] <sorear> o/ whiteknight

[23:28] <sorear> sorry if I'm being unreasonably paranoid.

[23:28] <whiteknight> hello sorear

[23:29] *** fridim_ joined
[23:33] <[Coke]> sorear: no worries.

[23:41] <[Coke]> sorear: if I wanted to implement "List.munch", where would I look?

[23:41] *** ponbiki joined
[23:42] *** soh_cah_toa left
[23:42] *** drbean left
[23:43] <sorear> [Coke]: first you'd have to figure out what List.munch is supposed to do.  It is not specced.

[23:44] <[Coke]> sorear: excellent point.

[23:45] <[Coke]> it's used in several spec tests, unfortunately. I'd say that's a bug in either the tests or the spec.

[23:49] *** drbean joined
[23:49] * [Coke] opens a specbug.

[23:49] *** bluescreen10 left
[23:49] <TimToady> well, it's part of a bigger bug called pm hasn't rewritten the iterators chapter yet

[23:54] <[Coke]> opened specs issue #7 so we don't lose it.

