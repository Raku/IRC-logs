[00:18] *** Woodi left
[00:18] *** Woodi joined
[00:44] <sorear> lichtkind: that last comment wasn't directed at you, sorry.

[00:44] <sorear> lichtkind: conclusions from rakudo sources - I don't remember

[00:46] *** _jaldhar left
[00:46] *** _jaldhar joined
[01:01] *** noganex joined
[01:03] *** Trashlord left
[01:04] *** noganex_ left
[01:21] *** buubot_backup left
[01:30] *** _jaldhar left
[01:30] *** _jaldhar joined
[01:43] *** cdarroch left
[01:47] *** am0c left
[01:48] *** envi_laptop joined
[02:00] *** am0c joined
[02:03] *** _jaldhar left
[02:03] *** Trashlord joined
[02:03] *** _jaldhar joined
[02:25] *** whiteknight left
[02:47] *** xinming left
[03:00] *** xinming joined
[03:13] *** agentzh joined
[03:13] *** envi_laptop left
[03:21] *** Trashlord left
[03:21] *** REPLeffect left
[03:24] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:28] *** thowe joined
[03:28] <thowe> I need to thank TimToady.

[03:29] <thowe> He inadvertently set me on what feels like the path of enlightenment.

[03:29] <sorear> he does that to people a lot

[03:30] <thowe> this is probably more inadvertent than usual

[03:30] <sorear> are you someone I should know/know of/remember?

[03:31] <thowe> no, I'm very much nobody

[03:32] <thowe> A few months ago I stumbled in here and ended up talking about past experiences with perl and sort of moving to Ruby...

[03:33] <thowe> He asked me some questions about what bugged me in perl and later I decided to go back and take a better look at perl and I realized a lot of it was just me being ignorant.  Now I have been doing perl again for months instead of Ruby and it's been fun.

[03:34] * sorear never figured out ruby

[03:34] *** Tanktalus left
[03:35] <sorear> well, it's pretty awesome that we have TimToady here at all :)

[03:35] <thowe> I'm not positive I did either since I had to take a second look at perl years later to get it.  Maybe I will do the same with Ruby (but I suspect it will be Perl6 instead).

[03:35] *** Tanktalus joined
[03:37] <thowe> But anyway, that conversation led me down a very different path than if I had never had it.  I guess if one is paying attention they could say that about a lot of things, but that conversation sticks out in my mind.

[03:37] *** lue left
[03:37] <thowe> but he's not here.  Maybe he'll scroll up.  Thanks TimToady.

[03:42] <TimToady> yer welcome!

[03:43] <TimToady> and thanks for the encouragement

[03:47] <thowe> =)

[03:52] <lichtkind> good night

[03:52] *** lichtkind left
[03:52] *** am0c left
[03:58] <Tene> sorear: I figured out ruby.  Trust me, it's not really worth it.

[04:10] <sorear> TimToady: I wonder to what extent, say, ::DYNAMIC makes sense as a name reference

[04:10] *** y3llow left
[04:11] *** y3llow joined
[04:15] *** bkolera joined
[04:16] *** _jaldhar is now known as jaldhar

[04:31] <sorear> pugs: my $x = 4; { my $x = 2; say $OUTER::x }

[04:31] <p6eval> pugs: OUTPUT«4␤»

[04:31] <sorear> pugs: my $x = 4; { my $x = 2; say $::x }

[04:31] <p6eval> pugs: OUTPUT«2␤»

[04:32] <sorear> pugs: package Foo { { our $x = 2 }; say $::x }

[04:32] <p6eval> pugs: OUTPUT«2␤»

[04:32] <sorear> pugs: { our $x = 2; }; package Foo { say $::x }

[04:32] <p6eval> pugs: OUTPUT«*** Undeclared variable: ("$x",MkPad (padToList [("$_",PELexical {pe_type = (mkType "Scalar"), pe_proto = <Scalar:0x7f0040e59f31>, pe_flags = MkEntryFlags {ef_isContext = True}, pe_store = <ref:0x7f0040e588d1>}),("@_",PELexical {pe_type = (mkType "Array"), pe_proto = <Array:0x7f004…

[04:33] <sorear> pugs: { package Bar { our $x = 2 } }; package Foo { say $Bar::x }

[04:33] <p6eval> pugs: OUTPUT«␤»

[04:33] <sorear> pugs: { package Bar { our $x = 2 } }; package Foo { say $GLOBAL::Bar::x }

[04:33] <p6eval> pugs: OUTPUT«␤»

[04:33] <sorear> pugs: { our package Bar { our $x = 2 } }; package Foo { say $GLOBAL::Bar::x }

[04:33] <p6eval> pugs: OUTPUT«␤»

[04:33] <sorear> ?

[04:34] <sorear> TimToady: in the absense of a lexically visible declaration of Foo, does ::Foo::Bar mean OUR::Foo::Bar or GLOBAL::Foo::Bar?

[04:40] *** xinming left
[04:47] <TimToady> good question

[04:47] <TimToady> meaning I'm not sure

[04:47] <TimToady> it seems, pragmatically, that you wouldn't use ::Foo unless you expected the name to be defined later

[04:47] <TimToady> it which case we might be able to defer its meaning till then

[04:48] <TimToady> if not, OUR is shorter than GLOBAL, so I'd be inclined to make GLOBAL the default

[04:50] <TimToady> or it could be argued that a postdeclaration will be OUR in any case, so might as well assume it

[04:50] <TimToady> as is too often the case, I can argue it both ways

[04:51] <TimToady> or we can say, it must be supplied eventually as some alias in the current lexical scope

[04:51] <TimToady> but that doesn't make a lot of sense, because if you know it later in the scope, why can't you know it now?

[04:53] <TimToady> similar considerations apply for OUR, so I guess GLOBAL is still the best default

[04:53] <TimToady> on the assumpt that ::Foo will eventually be supplied at link time

[04:54] <TimToady> (since our or my would imply we already know at compile time)

[04:54] <TimToady> does that make sense to you?

[04:54] <slavik1> gobal aka extern?

[04:54] <slavik1> global*

[04:55] <TimToady> yeah, something like that

[04:55] *** molaf joined
[04:55] <TimToady> "I dunno what it means in the comp unit, but I will by link time"

[04:56] *** kaare_ joined
[04:57] <TimToady> I suppose one could also make a case for ::*Foo

[04:58] <TimToady> but there's little a package can do that can't also be done with an ordinary var

[05:14] *** thou joined
[05:17] *** xinming joined
[05:30] *** kaare_ left
[05:31] *** muixirt joined
[05:31] <muixirt> good morning

[05:32] *** envi_laptop joined
[05:34] <sorear> TimToady: GLOBAL:: is good, that's the behavior I have a use case for

[05:34] <sorear> TimToady: but it's a little inconsistant with the parts of S02 that say $::x ~~ $OUR::x (if no lexical $x and no strict)

[05:53] *** mdrc joined
[05:54] <sorear> TimToady?

[05:54] <mdrc> hello, in something like http://pastebin.com/rgZbke43 , how's anonymous array notation in perl6?

[05:56] <sorear> anononymous array syntax hasn't been changed at all

[05:56] <sorear> but almost everything else in that snippet has

[05:56] <mdrc> fine. thanks

[05:56] *** fhelmberger_ joined
[05:57] <mdrc> like the hash brackets?

[05:57] <sorear> yes

[05:57] <mdrc> ok

[05:58] <sorear> and the array brackets, and method calls, and iterating over array elements, and sub parameters, and here documents

[05:58] <sorear> and named parameters

[05:58] <mdrc> just scanned the doc quickly, rather nice

[05:59] <sorear> :)

[05:59] <mdrc> seems you qualify for a new type of console

[06:00] <mdrc> with special perl keys

[06:00] <sorear> "special

[06:00] <sorear> "special" perl keys?

[06:00] <mdrc> like an ascii replacement

[06:00] <sorear> but I need ASCII

[06:00] <mdrc> the iterator char etc

[06:01] <sorear> all the characters I use in my Perl are ASCII

[06:01] <sorear> Iterator char?

[06:01] <mdrc> i can't type it here

[06:01] <mdrc> something like >>

[06:02] <sorear> ...are you a troll

[06:02] <mdrc> im anti

[06:02] <sorear> perl6: say [1,4,9]>>.sqrt

[06:02] <p6eval> pugs, rakudo 248244, niecza v6-177-g365e216: OUTPUT«123␤»

[06:03] <sorear> non-ASCII?  what?

[06:03] <mdrc> so the ascii equivalent works too, that's just fine

[06:04] <sorear> trolls seem to think you need special Perl 6 keyboards

[06:04] *** wamba joined
[06:04] <mdrc> trolls think everyone else is a troll

[06:06] <sorear> so why did you bring up keyboards?

[06:06] <mdrc> because the type-system is alpha and omega

[06:07] <mdrc> and perl6 use a new set of glyphs

[06:07] <sorear> what are you even talking about?

[06:07] <mdrc> about perl6 representation

[06:07] *** molaf left
[06:07] <sorear> you must be confusing this with some other Perl 6

[06:08] <sorear> the Perl 6 I know has no special glyphs, or alphas or omegas, or Tk module, or anything like that

[06:08] <mdrc> good luck for you it's ascii compatible

[06:08] * sorear hugs mdrc

[06:08] <mdrc> :)

[06:08] <mdrc> thanks

[06:17] <mdrc> then we get to talk a bit, might sort it out

[06:17] <mdrc> what i got already

[06:18] <mberends> mdrc: were you referring to non-ascii characters in the syntax of p6 such as « »?  Each one has an ascii equivalent for unicode-challenged systems.

[06:18] <mdrc> only here to show my respect, actually. . . else i'd left

[06:19] <mdrc> just woke up and about to leave

[06:19] <sorear> o/ mberends

[06:19] <mberends> oahy, sorear

[06:19] <mberends> ahoy

[06:19] <mberends> finger sort error

[06:19] <sorear> mdrc: Are you trying to answer my PMs?

[06:20] <mdrc> oh, didn't see you were private, sry

[06:21] <mdrc> fault of the whisper

[06:21] <sorear> mberends: user defined precedence finally works :>  trying now to get an inconsistency in the spec explained by TimToady

[06:26] <TiMBuS> https://github.com/MrMEEE/bumblebee/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac

[06:26] <TiMBuS> uh

[06:27] <sorear> it's great publicity.  I'd never heard of bumblebee before today,

[06:27] <slavik1> does rakudo* releases include parrot?

[06:27] <sorear> Still can't figure out what it's supposed to do, though.

[06:27] <sorear> slavik1: yes

[06:28] <slavik1> sorear: does install in a self contained dir or does it have an install make target?

[06:35] <sorear> no clue

[06:36] <slavik1> kk

[06:37] <slavik1> another stupid question, will perl5 code work in rakudo* with use v5? or is that still on the "to be implemented" list?

[06:37] <TiMBuS> now how you want it to

[06:38] <TiMBuS> not* how

[06:38] <slavik1> I see, ok

[06:38] <slavik1> and I presume there is a way to compile perl to pbc?

[06:38] <TiMBuS> you can import modules and eval perl5 code

[06:39] <slavik1> k

[06:39] <TiMBuS> perl5 to pbc? no. that idea was abandoned

[06:39] <slavik1> perl6 to pbc :)

[06:39] <TiMBuS> ah. yeah

[06:39] <slavik1> kk

[06:39] <TiMBuS> https://github.com/jnthn/blizkost here might be what you want

[06:40] <slavik1> I remember that one ^^

[06:40] <mberends> sorear: I saw the precedence discussion, and thought any kind of numerical precedence ordering is limited. I thought if you define precedence levels only relative to other entries, you can extend a single/double linked list of precedence levels without limits.

[06:44] <TiMBuS> the zavolaj readme says that it only works with known nci_thunk s but is that still the case? parrot uses libffi now

[06:45] *** sivoais joined
[06:46] <pmichaud> earlier versions of rakudo (and PGE) handled precedence levels by successive string extentions

[06:46] <pmichaud> *extensions

[06:46] *** daniel-s joined
[06:47] <pmichaud> that's why the :prec<...>  items are all 'x=' and the like

[06:47] <mdrc> like a regular LR1 parser, i suppose

[06:48] <mberends> TiMBuS: yes, because zavolaj has not (yet) been reworked to make use of parrot#s new libffi. I have not yet looked into how much work is involved, and it seems wrong to prioritize that currently, whilst such a lot is happening in rakudo/nom.

[06:49] <TiMBuS> mberends, no need to rush or anything, im just not sure how the new libffi worked. assumed it was mostly transparent like the old nci was

[06:51] <mberends> TiMBuS: aye, libffi may be something similar to nci, only smarter :)

[06:54] <TiMBuS> well, yeah, but what i mean is i thought it might have just been switched out and replaced, and unchanged pir code would now work with the new ffi

[06:54] <sorear> pmichaud: what was changed?

[06:55] <pmichaud> sorear: nothing changed... just haven't (re-)implemented that capability since then

[06:55] <sorear> ooh?

[06:55] <pmichaud> anyway, tighter precedence would be indicated by adding '>' before the '=', looser precedence by adding '<' before the '='

[06:55] <sorear> alpha: sub infix:<@>($x,$y) is equiv<*> { $x * $y }; say 1 + 2 @ 3

[06:55] <p6eval> alpha : OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:is'␤in Main (file <unknown>, line <unknown>)␤»

[06:55] <pmichaud> then it's a straight string comparison to compare the precedence of two operators

[06:56] <sorear> yes, that's exactly what niecza does

[06:56] <sorear> $sub.prec_info.<prec> ~~ s/\=/<=/ if $trait eq 'looser'

[06:58] <sorear> pmichaud: if I read the spec correctly, ::Foo::Bar defaults to GLOBAL, but $::x defaults to OUR.  What do you think?

[06:58] <pmichaud> seems like it might be inconsistent, but I'd have to study it closer to form a good opinion on it.

[06:59] <sorear> (I need to learn to not be paralyzed when I notice a little hole in my understanding of the spec...)

[06:59] <pmichaud> since we've never really worked on getting packages exactly right until 'nom', I haven't looked at all of the intricacies of the spec in that respect

[06:59] <slavik1> http://pastebin.com/EAgDWxbt

[06:59] <slavik1> what am I doing wrong?

[07:00] <pmichaud> I don't think Rakudo knows how to use Parrot-native .pbc libraries

[07:01] <slavik1> they are all .pir though

[07:01] <slavik1> and came with rakudo*

[07:01] <slavik1> via make install

[07:01] <pmichaud> well, Parrot installs a lot of things that Rakudo might not be able to use.

[07:01] <pmichaud> Rakudo * gives a full Parrot install, not just Rakudo-only stuff.

[07:01] <slavik1> I see

[07:01] <slavik1> but it should be able to use .pir libs, no? it worked before ... at some point

[07:02] <mdrc> perl6 continues with the fork emulation, right?

[07:02] <pmichaud> I know it can use .pir libs that it compiles, yes.

[07:02] * sorear -> sleep

[07:03] <TiMBuS> mdrc, no perl6 is trying to build in Coro instead

[07:03] <mdrc> in Coro?

[07:03] <pmichaud> slavik1: that said, Data::Dumper is usually already loaded by default when rakudo loads, so you may just be able to call the 'dumper' function directly.

[07:03] <pmichaud> rakudo:  dumper([1, 2, 3]);

[07:03] <TiMBuS> Coro is a perl 5 module that allows async {} blocks

[07:03] <p6eval> rakudo 248244: OUTPUT«Could not find sub &dumper␤  in main program body at line 22:/tmp/QWFjhRRBvf␤»

[07:03] <slavik1> :P

[07:03] <slavik1> Dumper?

[07:03] <pmichaud> oh, I guess not.  :-(

[07:04] <mdrc> hmm

[07:04] <slavik1> rakudo: say Dumper "hello";

[07:04] <p6eval> rakudo 248244: OUTPUT«Could not find sub &Dumper␤  in main program body at line 22:/tmp/d_JpaF3vyh␤»

[07:04] <pmichaud> rakudo:  Data::Dumper::dumper([1, 2, 3]);

[07:04] <p6eval> rakudo 248244: OUTPUT«Cannot find sub Data::Dumper::dumper␤  in main program body at line 1␤»

[07:04] <pmichaud> rakudo: _dumper([1,2,3]);

[07:04] <p6eval> rakudo 248244: OUTPUT«Could not find sub &_dumper␤  in main program body at line 22:/tmp/xQr6J1JfQQ␤»

[07:04] <slavik1> rakudo: say new Data::Dumper("hello");

[07:04] <p6eval> rakudo 248244: OUTPUT«===SORRY!===␤Unsupported use of C++ constructor syntax; in Perl 6 please use method call syntax at line 22, near "(\"hello\");"␤»

[07:04] <slavik1> lol

[07:05] <pmichaud> looks like there's not a way to quite do it.  (more)

[07:05] <slavik1> rakudo: say Data::Dumper::new("hello");

[07:05] <p6eval> rakudo 248244: OUTPUT«Cannot find sub Data::Dumper::new␤  in main program body at line 1␤»

[07:05] <slavik1> D:

[07:05] <pmichaud> even if there was, it's doubtful that Parrot's Data::Dumper participates properly in the symbol table importation.  It was written before Parrot's standards for export/import were in place.

[07:05] <slavik1> pmichaud: idea was to load a module :)

[07:05] <TiMBuS> mdrc, the current threading synopsis sucks, but from what I gather it looks very similar to Coro. No idea if it will be scrapped or used or whatever. I know that I don't like perl 5 threads though.

[07:06] <mdrc> TiMBuS: just apropos libray export and shared code bases

[07:07] <mdrc> (i din't use threads in the microsoft sense)

[07:13] <dalek> rakudo/nom: a92bda7 | pmichaud++ | src/core/Mu.pm:

[07:13] <dalek> rakudo/nom: Refactor PMCNULL handling in &DUMP.

[07:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a92bda75cf

[07:13] <dalek> rakudo/nom: 5ef97ff | pmichaud++ | src/core/ (2 files):

[07:13] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[07:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ef97ffd03

[07:13] <dalek> rakudo/nom: 65bec51 | pmichaud++ | / (5 files):

[07:13] <dalek> rakudo/nom: Add the first bit of gather/take functionality.

[07:13] <dalek> rakudo/nom: 

[07:13] <dalek> rakudo/nom: It doesn't quite work yet, because Actions.pm doesn't yet know how

[07:13] <dalek> rakudo/nom: to properly compile <blorst> blocks -- it gives a "no clone method

[07:13] <dalek> rakudo/nom: found for 'Sub'" error.  As soon as that's fixed, gather/take should

[07:13] <dalek> rakudo/nom: work fine.  In the meantime, one can do  GATHER({...}) to get

[07:13] <dalek> rakudo/nom: roughly equivalent functionality.

[07:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/65bec51494

[07:28] *** thou left
[07:34] *** fhelmberger_ left
[07:39] *** mdrc left
[07:43] *** Su-Shee_ is now known as Su-Shee

[07:44] <dalek> rakudo/nom: 74ecbe0 | pmichaud++ | src/core/ (2 files):

[07:44] <dalek> rakudo/nom: s/BIND_KEY/STORE_AT_KEY/ for consistency with List/Array.

[07:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74ecbe02e3

[07:44] <dalek> rakudo/nom: 434bab6 | pmichaud++ | / (4 files):

[07:44] <dalek> rakudo/nom: Add Enum, Pair, .pairs method, and enum/hash flattening.

[07:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/434bab6045

[07:52] *** Trashlord joined
[07:55] *** mj41 joined
[08:23] *** wamba left
[08:42] *** amkrankruleuen left
[08:42] *** amkrankruleuen joined
[08:58] *** nymacro joined
[09:18] *** spq left
[09:19] *** spq1 joined
[09:21] *** pochi left
[09:29] <mberends> fresh rakudo/nom loops forever in t/01-sanity/12-try.t, the virtual memory size seen by top oscillating between 159m and 175m

[09:36] <TBA2> perl6: class A { method X { return B.new(); } } class B is A {}; my $a = A.new(); my $b = $a.B(); print $b;

[09:36] <p6eval> pugs: OUTPUT«*** No such method in class A: "&B"␤    at /tmp/7HSQNuudES line 1, column 79-90␤»

[09:36] <p6eval> ..niecza v6-177-g365e216: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Strange text after block (missing comma, semicolon, comment marker?) at /tmp/INTils3O_6 line 1:␤------> [32mclass A { method X { return B.new(); } }[33m⏏[31m class B is A {}; my $a = A.new(); my $b[0m␤␤Undeclared name:␤    

[09:36] <p6eval> ..'B' used at line 1␤␤P…

[09:36] <p6eval> ..rakudo 248244: OUTPUT«===SORRY!===␤Confused at line 22, near "class A { "␤»

[09:36] <TBA2> should that work?

[09:36] <TBA2> i.e. creating an instance of a parent class from a subclass?

[09:37] <TBA2> rakudo: class A { method X { return B.new(); } } class B is A {}; my $a = A.new(); my $b = $a.B(); print $b;

[09:37] <p6eval> rakudo 248244: OUTPUT«===SORRY!===␤Confused at line 22, near "class A { "␤»

[09:37] <moritz> TBA2: you need a semicolon or newline after the closing } of the class

[09:38] <TBA2> rakudo: class A { method X { return B.new(); } }; class B is A {}; my $a = A.new(); my $b = $a.X(); print $b;

[09:38] <p6eval> rakudo 248244: OUTPUT«Could not find sub &B␤  in 'A::X' at line 22:/tmp/or3Vo8OipM␤  in main program body at line 22:/tmp/or3Vo8OipM␤»

[09:38] <TBA2> moritz: ty, you helped me spot another typo, but still errors?

[09:39] <TBA2> perl6: class A { method X { return B.new(); } }; class B is A {}; my $a = A.new(); my $b = $a.X(); print $b;

[09:39] <p6eval> rakudo 248244: OUTPUT«Could not find sub &B␤  in 'A::X' at line 22:/tmp/w_TJ322F4N␤  in main program body at line 22:/tmp/w_TJ322F4N␤»

[09:39] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&B"␤    at /tmp/jCAJkOHnSy line 1, column 29-36␤»

[09:39] <p6eval> ..niecza v6-177-g365e216: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Illegally post-declared type:␤   'B' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1133 (STD P6.comp_unit @ 30) ␤ 

[09:39] <moritz> rakudo: class A { method X { return ::B.new(); } }; class B is A {}; my $a = A.new(); my $b = $a.X(); print $b;

[09:39] <p6eval> ..at /home/p6eval/ni…

[09:39] <p6eval> rakudo 248244: OUTPUT«B()<0x3e89780>»

[09:39] <moritz> there you go

[09:39] <TBA2> my local rakudo gives: Illegal redeclaration of symbol 'A'

[09:39] <TBA2> ah!!! i see, ty!

[09:39] <moritz> you can't use a type name before you declare it

[09:39] <TBA2> so how does using :: change that? presumably thats global namespace?

[09:39] <moritz> so either you must stub it with  'class B { ... };'

[09:40] <moritz> or you need to use ::B, which says "B is a type name which I'll declare later"

[09:40] <TBA2> ahh thats it, thank you!!

[09:40] <TBA2> however, I still get 'Illegal redeclaration of symbol 'A'' in rakudo, that a bug?

[09:40] <moritz> TBA2: how old is your rakudo?

[09:41] <TBA2> was just thinking that when i seen you used rakudo just then lol :)

[09:41] * TBA2 updates his rakudo

[09:41] <moritz> rakudo: class B { ... }; class A { method x { B.new } }; class B is A { }; say A.x

[09:41] <p6eval> rakudo 248244: OUTPUT«B()<0x45ab100>␤»

[09:41] <moritz> nom: class B { ... }; class A { method x { B.new } }; class B is A { }; say A.x

[09:41] <p6eval> nom: OUTPUT«B<69377880>␤»

[09:42] <TBA2> j/w, which branch is the rakudo compiler in here on?

[09:43] <tadzik> 'rakudo' is on master

[09:43] <tadzik> 'nom' is nom

[09:43] <moritz> right

[09:43] <tadzik> nom: say "nom!"

[09:43] <p6eval> nom: OUTPUT«nom!␤»

[09:43] <TBA2> cool thx

[09:44] <moritz> nom: say "nom!" x 5

[09:44] <p6eval> nom: OUTPUT«Could not find sub &infix:<x>␤current instr.: '_block1002' pc 83 ((file unknown):61956725) (:1)␤»

[09:44] <moritz> ooh, LHF

[09:47] <flussence> nom: sub infix:<x>($thing, Int $count) { $thing for ^$count }; say "nom!" x 5

[09:47] <p6eval> nom: OUTPUT«Null PMC access in find_method('new')␤current instr.: 'nqp;Perl6;Actions;_block1794' pc 29113 (src/gen/perl6-actions.pir:9731)␤»

[09:48] <flussence> worked for me in master :(

[09:48] <TBA2> how weird lol

[09:48] <moritz> flussence: x is string repetition

[09:48] <TBA2> just tried to build master and get this:

[09:48] <TBA2> Null PMC access in find_method('new')

[09:48] <moritz> flussence: xx is list repetition

[09:48] <moritz> TBA2: did you re-run Configure.pl?

[09:48] <moritz> (you should)

[09:49] * TBA2 pours water over head to wake up properly

[09:49] <flussence> sub infix:<x>($thing, Int $count) { (callsame).join } # ;)

[09:49] <TBA2> moritz: thx again, perhaps i should leave programming to a more conscious state :D

[09:49] <moritz> TBA2: btw did you try the class B is A  thing in the REPL?

[09:49] <moritz> ie in the interactive mode?

[09:49] <TBA2> yeah thats where i was trying

[09:50] <moritz> if yes, previous declarations of A could lead to the redeclaration error

[09:50] <TBA2> well, after failing miserably to get actual code to work

[09:50] <TBA2> was a new instance, keep accidentally ctrl+c'ing it lol

[09:51] *** araujo left
[09:51] <flussence> rakudo: class A::B::C {}; class A::B {}; # is this meant to happen?

[09:51] <p6eval> rakudo 248244:  ( no output )

[09:51] <flussence> hm, that's different

[09:51] <tadzik> rakudo: class A::B::C {}; class A::B {}; say 'alive'

[09:51] <p6eval> rakudo 248244: OUTPUT«alive␤»

[09:52] <tadzik> but you get illegal redeclaration, don't you?

[09:52] <flussence> on the repl if I do them on separate lines, they don't work...

[09:58] *** donri left
[10:05] *** agentzh left
[10:06] *** Woodi left
[10:06] <TBA2> ok two questions from my sleepy morning brain:

[10:07] <TBA2> how do i declare an attribute static (i.e. p6 equivalent of c#s "static int x;")

[10:07] <TBA2> and which constructor should(can?) i use to fill that static attribute as soon as the class is imported with a use statement?

[10:07] <moritz> my $.x (but doesn't work yet in rakudo; as a workaround you can just use 'my $x' in the class body)

[10:08] *** Woodi joined
[10:08] <moritz> rakudo: class A { my $x = 5; method xx { say $x } }; A.xx

[10:08] <p6eval> rakudo 248244: OUTPUT«5␤»

[10:08] <moritz> rakudo: class A { my $x = 5; method xx { say $x } }; A.xx; A.new.xx

[10:08] <p6eval> rakudo 248244: OUTPUT«5␤5␤»

[10:08] <TBA2> moritz: thanks, exactly what i needed :)

[10:10] *** mj41 left
[10:13] <moritz> nqp: say(pir::repeat__SSI("foo", 0))

[10:13] <p6eval> nqp: OUTPUT«␤»

[10:13] *** wamba joined
[10:13] <moritz> nqp: say(pir::repeat__SSI("foo", -1))

[10:13] <p6eval> nqp: OUTPUT«Cannot repeat with negative arg␤current instr.: '_block1000' pc 0 ((file unknown):1)␤»

[10:15] <dalek> rakudo/nom: e123266 | moritz++ | src/core/Str.pm:

[10:15] <dalek> rakudo/nom: implement infix:<x>

[10:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e123266b96

[10:18] *** Chillance joined
[10:30] *** Chillance left
[10:31] <TBA2> in this example: class A { method X { return ::B.new(); } }; class B is A {}; my $a = A.new(); my $b = $a.X(); print $b;

[10:32] <TBA2> say class A and B were in separate .pm files, do I need to 'use' the parent/subclassses?

[10:32] <TBA2> it works fine if i stick it all in REPL but once i split it into separate files I get various errors depending on what I actually do

[10:35] <TBA2> example: http://pastebin.com/1UymDH95

[10:38] *** eternaleye left
[10:39] *** eternaleye joined
[10:44] *** Chillance joined
[10:45] *** am0c joined
[10:57] *** JimmyZ joined
[11:00] <JimmyZ> good evening, #perl6

[11:08] *** woosley joined
[11:10] *** dalek left
[11:11] *** dalek joined
[11:11] *** ChanServ sets mode: +v dalek

[11:11] *** p6eval left
[11:15] *** dalek left
[11:16] *** dalek joined
[11:16] *** ChanServ sets mode: +v dalek

[11:20] *** p6eval joined
[11:20] *** ChanServ sets mode: +v p6eval

[11:25] *** Woodi left
[11:25] *** mberends left
[11:25] *** Woodi joined
[11:27] *** nymacro left
[11:28] <muixirt> nqp: $a := 0; $a++; 

[11:28] <p6eval> nqp: OUTPUT«Symbol '$a' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[11:28] <muixirt> nqp: my $a := 0; $a++; 

[11:28] <p6eval> nqp:  ( no output )

[11:28] <muixirt> rakudo: my $a := 0; $a++;

[11:28] <p6eval> rakudo 248244: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1␤  in main program body at line 1:CORE.setting␤»

[11:29] *** am0c left
[11:29] <JimmyZ> nom: my $a := 0; $a++;

[11:29] <p6eval> nom: OUTPUT«Cannot assign to a non-container␤current instr.: 'infix:<=>' pc 145745 (src/gen/CORE.setting.pir:36711) (:1210)␤»

[11:30] <muixirt> are there more cases where rakudo can't run nqp programs?

[11:31] <JimmyZ> well, nqp is Not Quite Perl 6

[11:32] <JimmyZ> that is, it's a subset of Perl 6

[11:32] <muixirt> JimmyZ: and it isn't really a subset of Perl 6 either ... semantically

[11:33] <JimmyZ> yes, that's why it is called Not Quite Perl 6

[11:49] *** Eevee left
[11:50] *** Eevee joined
[11:59] *** Shozan joined
[12:02] *** woosley left
[12:02] <muixirt> moritz: wrt your last commit, nom will still heavily depend on pir?

[12:03] *** Woodi left
[12:05] *** Woodi joined
[12:05] *** mberends joined
[12:08] *** orafu left
[12:12] <mberends> muixirt: nom will use pir:: but not Q:PIR any more, and the long term plan is to rewrite the pir:: as nqp:: or vm:: to be more portable

[12:13] *** orafu joined
[12:18] <muixirt> mberends: thanks for answering, will wait for pmichaud's next blog post

[12:18] <mberends> :)

[12:21] *** ggoebel left
[12:25] *** ggoebel joined
[12:29] <moritz> muixirt: well, we have to implement stuff by using the operations that our VM provides. Currently that still means PIR

[12:30] <muixirt> moritz: ok (sorry for dumb questions :-)

[12:38] <muixirt> moritz: is there a list of primitives that nqp/nom rely on?

[12:39] <tadzik> `ack pir::` :)

[12:39] <muixirt> tadzik: well ... :-)

[12:40] <tadzik> what's on your mind?

[12:43] <muixirt> these primitives would be the real bytecode, an api that VM devs could provide to run Rakudo on different platforms

[12:44] <muixirt> of course i don't know how src/pmc and src/6model would fit into that :-(

[12:44] *** lateau joined
[12:46] <tadzik> I think it will all eventually go down to porting nqp somehow

[12:52] *** buubot_backup joined
[12:53] <moritz> muixirt: these primitives are compiled down to "real bytecode", but currently there's a step inbetween (PIR)

[12:53] *** nsh left
[12:55] *** Guest18398 joined
[12:55] *** kcwu left
[12:56] *** MayDaniel joined
[12:57] *** kcwu joined
[12:59] *** icwiener joined
[13:11] *** lichtkind joined
[13:21] <pmichaud> good morning

[13:23] <colomon> o/

[13:24] <tadzik> good am, pm

[13:24] <tadzik> haha, I stole moritz' greeting :P

[13:27] *** mj41 joined
[13:28] <moritz> PLAGIARISM!

[13:29] <colomon> heh.  I've been reading a swashbuckling classic for the first time, only to discover a really crappy book I read last year stole every single plot development of the first seven chapters of the classic.

[13:30] <pmichaud> "The parts of this book that are original are not good, and the parts that are good are not original."   :-)

[13:30] <colomon> Apparently the author decided to "update" the classic by adding magic, doubling the length of the prose, and removing every shred of likability from the characters.

[13:31] <tadzik> it's like with translations

[13:31] * moritz has read some very good translations

[13:32] * colomon too... including a lot of great swashbucklers.

[13:33] *** Mowah joined
[13:34] <tadzik> swashbucklers as in pirates?

[13:37] <colomon> errr... of course, I assume the translation was good because I liked the final result.  I have neither enough French or Spanish to handle Dumas or Perez-Reverte.

[13:38] <colomon> tadzik: mostly musketeers and the like, but pirates are good too.

[13:38] <colomon> I can't always be reading Winnie-the-Pooh and Thomas the Tank Engine.  ;)

[13:38] * moritz read some of the Harry Potter novels in English, and some in the German translation. The translations were good enough that I don't remember which I read in which language :-)

[13:41] <tadzik> when they were translating Harry Potters to Polish, there were contests on the intertnet for the best translation of a particular name or word

[13:42] <moritz> heh :-)

[13:42] * pmichaud hopes NPW is proceeding well.

[13:43] <tadzik> oh, right, the guys are absent

[13:54] *** lateau left
[14:00] <TBA2> can anyone point me to where in rakudo master i can find where it deals with 'use' statements

[14:00] <moritz> TBA2: src/Perl6/Actions.pm, search for sym<use>

[14:01] <TBA2> moritz: thx :)

[14:01] <moritz> I've occasionally tried to fiddle with it :-)

[14:02] *** mj41 left
[14:03] * TBA2 is gonna regret this

[14:03] <TBA2> it seems use statements are carried out even if the package has been previously imported, soo, trying to find out why :/

[14:03] <TBA2> this can be my intro to the rakudo source haha :s

[14:04] <moritz> TBA2: because 'use' imports symbols into the current scope

[14:04] <TBA2> what about when all use imports are in the global namespace?

[14:04] <moritz> Perl 6 doesn't do imports into a global namespace (except type names maybe)

[14:04] <moritz> but into lexical scopes

[14:05] *** MayDaniel left
[14:05] <TBA2> i.e. if A.pm imports B.pm and B.pm imports A.pm, when both are loaded I get some kind of maximum recursion depth

[14:05] <moritz> it's a situation you should avoid for now

[14:06] <moritz> consider putting both into the same file

[14:06] <TBA2> will do, but is that a fault of rakudo or perl 6 specs?

[14:06] <moritz> probably rakudo, not sure though

[14:07] <TBA2> will attempt to investigate lol, never had a problem with p5 and i assume its something people would need to do

[14:07] <moritz> aye

[14:12] *** Moukeddar joined
[14:12] <Moukeddar> Hello :)

[14:13] *** kaare_ joined
[14:16] *** betterworld left
[14:21] <pmichaud> > my %h = <a b c d e f g h>;  say %h.kv.perl;

[14:21] <pmichaud> (('a', 'b'), ('c', 'd'), ('e', 'f'), ('g', 'h'))

[14:21] <pmichaud> \o/

[14:21] *** betterworld joined
[14:22] <moritz> \o/

[14:23] <TimToady> that seems problematic to bind to -> $k, $v

[14:23] <pmichaud> it flattens in flat context

[14:23] <TimToady> I guess for is flat, yeah

[14:23] <TimToady> still waiting for the coffee to finish...

[14:23] <pmichaud> np :-)

[14:24] <pmichaud> I think nom finally gets Parcel handling pretty close to right.

[14:24] <Moukeddar> moritz, o/

[14:24] <TimToady> \o/ too

[14:25] <Moukeddar> that google presentation on Good API design was very helpful and inspiring :)

[14:25] <Moukeddar> can someone please explain to me what's exactly Scalability ?

[14:28] <dalek> rakudo/nom: 741ed7b | pmichaud++ | / (6 files):

[14:28] <dalek> rakudo/nom: Switch ListIter to be an Iterator, ListIter :flat affects only Parcel flattening.  Add a preliminary List.perl.

[14:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/741ed7beda

[14:28] <dalek> rakudo/nom: 4d4bfa6 | pmichaud++ | src/core/EnumMap.pm:

[14:28] <dalek> rakudo/nom: Add EnumMap .keys, .kv, .values.

[14:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4d4bfa6789

[14:28] <pmichaud> niecza:  my %h = <a b c d e f>;  say %h.perl

[14:28] <p6eval> niecza v6-177-g365e216: OUTPUT«{"a" => "b", "c" => "d", "e" => "f"}.hash␤»

[14:28] <moritz> Moukeddar: able to handle large sets of data, or be able to run distributed over many machines

[14:29] *** mcallan joined
[14:29] <Moukeddar> so that's the core principe of Cloud infrastructure

[14:29] <Moukeddar> thank you

[14:30] <sorear> I'll have to see how pm implemented List.perl

[14:30] <sorear> good * #perl6

[14:30] <pmichaud> sorear: it's the naive one for now

[14:31] <pmichaud> more as a diagnostic tool than "this is the way output should look" 

[14:31] <sorear> pmichaud: I'm just wondering how you got the subparcels to show up

[14:31] <sorear> pmichaud: at List.pm line 100, what's the difference between pir::XXX and pir__XXX?

[14:32] <pmichaud> Didn't do anything special for that -- the resulting list is a list of parcels

[14:32] <pmichaud> pir::XXX is an opcode.   pir__XXX is a function that maybe someday will be an opcode :-)

[14:32] *** betterworld left
[14:32] <pmichaud> (at which point we change the first __ to ::

[14:33] <sorear> in nieczaland, .map flattens its invocant

[14:33] <pmichaud> you're probably looking for Parcel.pm:41

[14:33] <sorear> because %hash.kv.map({$^b => $^a})

[14:34] <pmichaud> I'm pretty sure .map shouldn't flatten by default.

[14:34] <TimToady> yes it should

[14:34] <TimToady> it should be identical to for

[14:34] <pmichaud> I had already treated for as being

[14:34] <TimToady> and you can say %hash.kv.lol.map

[14:34] <pmichaud>     for @list { ... }     <-->     flat(@list).map({ ... })

[14:35] *** daniel-s left
[14:36] <pmichaud> and I would expect   %hash.kv.map( { $_.value => $_.key } )   for what sorear++ wrote

[14:36] <pmichaud> oh, that's not right

[14:36] <pmichaud> hmmm

[14:37] <pmichaud> anyway, I can switch map to flattening behavior.  I'd expect some roast tests to fail, though.

[14:38] <TimToady> I think there is a set of ops that the (p5) user will always expect to flatten, and that's why we have lol to do the other thing

[14:38] <sorear> why do nom lists have only a single $!nextiter?

[14:38] <dalek> book: f1f9cbe | (Frederik Schwarzer)++ | src/operators.pod:

[14:38] <dalek> book: Remove execution bit from file.

[14:38] <dalek> book: review: https://github.com/perl6/book/commit/f1f9cbefa3

[14:38] <dalek> book: 1eb0908 | (Przemysław Wesołek)++ | src/operators.pod:

[14:38] <dalek> book: Merge pull request #56 from icwiener/master

[14:38] <dalek> book: 

[14:38] <dalek> book: Remove execution bit from file.

[14:38] <dalek> book: review: https://github.com/perl6/book/commit/1eb09083c1

[14:38] <pmichaud> they only need one?  ;-)

[14:38] <pmichaud> TimToady: yes, my version of .map comes from before the spec of .lol

[14:39] <TimToady> well, we need some lolcode then :P

[14:39] <sorear> Is there a difference between ((1,2), (3,4).list.lol and ($(1,2), $(3,4).list.lol?

[14:40] <TimToady> Syntax error near line 1

[14:40] <pmichaud> yes, http://irclog.perlgeek.de/perl6/2010-09-17#i_2837842   is the part I missed.  :-)

[14:40] <sorear> s:g/'.list'/)$/ /

[14:40] *** mcallan left
[14:41] <pmichaud> good, this will make things a bit more efficient, too.

[14:42] <TimToady> usually when I redecide things like that I decide wrong, until someone points out when I said the other thing :)

[14:42] <TimToady> esp this time of the AM

[14:42] <TimToady> sorear: as far as I can tell, those come out the same

[14:43] <TimToady> a Parcel of 2 Seqs sez Sleepybrane

[14:44] <pmichaud> something tells me they're not quite exactly the same, but I'm not sure about that yet.  I'll know more when I implement LoL soon :)

[14:44] <TimToady> .list is close to a no-op on a parcel

[14:44] <pmichaud> yes, that's what it looks like in nom.

[14:45] <pmichaud> Basically   .list on a Parcel just constructs an already-reified list of the Parcel's elements

[14:45] <TimToady> do you mean it's not lazy?

[14:45] <pmichaud> it doesn't flatten

[14:45] <pmichaud> it just changes type

[14:45] <pmichaud> i.e.,   (1, 2).WHAT   will be Parcel, while  (1, 2).list.WHAT will be List

[14:45] <sorear> unless one or more of the parcel's elements is an Iterator, no?

[14:46] <pmichaud> sorear: yeah, that could be

[14:46] <pmichaud> or an Iterable

[14:46] <TimToady> why I asked about lazy

[14:47] <pmichaud> nom gets it right, even if nom's implementor doesn't :)

[14:49] <TimToady> I'm starting to wonder if ::Foo::bar should really mean ::("Foo::bar") and then just search both lex and global at run time

[14:50] <TimToady> in which case, maybe we should just outlaw it and force people to write the latter

[14:51] <TimToady> or maybe it means START { ::("Foo::BAR") }

[14:51] <TimToady> *bar

[14:51] *** mcallan joined
[14:51] <TimToady> or INIT, or something not compile-timey

[14:51] <TimToady> maybe it's polymorphic somehow

[14:52] *** mcallan left
[14:53] <TimToady> but S12:95 already talks about virtual class names without a leading ::

[14:56] <sorear> I think what I'll do for now is make ::($x) pick GLOBAL or OUR depending on the presense of a sigil in $x

[14:57] <TimToady> non-sigil should probably scan lex and failover to GLOBAL

[14:57] <sorear> yes

[14:58] *** betterworld joined
[14:58] <sorear> ideally at compile time

[14:58] <TimToady> of $x is a constant, sure :)

[14:59] * TimToady now thinks of strings that are constant in the first N chars only...

[14:59] <TimToady> perhaps one could get such from a Cat

[15:01] <TimToady> constant $prefix = "Foo::Bar::"; my $x = cat($prefix, '$that');  # Optimize me!

[15:01] <TimToady> er

[15:01] <TimToady> '<$that>' I guess

[15:01] *** Moukeddar left
[15:02] <TimToady> I suppose memoizing each step of the name lookups would have a similar effect

[15:02] <TimToady> albeit with a small run-time overhead each time to figure out we've already seen Foo::Bar

[15:03] *** betterworld left
[15:06] *** mj41 joined
[15:07] <sorear> if you're just doing leading prefixes, it's easy to tell the compiler that

[15:07] <sorear> Foo::Bar::('$that')

[15:07] <TimToady> as opposed to trailing prefixes? :P

[15:08] <sorear> when they trail they're not namespaces, but rather a MTA

[15:08] <TimToady> if I got paralyzed by holes in the spec, why, I'd just be paralyzed all the time...wait, how is that different from reality?

[15:09] <TimToady> so maybe there's really little use case for leading ::

[15:11] <TimToady> and perhaps trying to force it in there is a form of confusing hard ref with symbolic ref, so we shouldn't

[15:12] <moritz> I must have missed part of the dicussion... how would you reference types that haven't been declared yet?

[15:12] <TimToady> if you're going to declare them yourself, you should probably have a stub instead

[15:12] *** mj41 left
[15:13] <TimToady> the part you missed is that it's not clear where to look for Foo if you see ::Foo::bar

[15:14] * JimmyZ wonders how is A B C  and  U D disscusion

[15:14] *** betterworld joined
[15:14] * TimToady is still thinking about that

[15:15] * JimmyZ thinks B is default

[15:16] <JimmyZ> actually I like U D just because my english is poor, undefined && define is easy to me 

[15:16] <moritz> what would A B C mean?

[15:16] <sorear> TimToady: niecza uses stuff like ::Op::CallMethod all over the place, to delay references to link time and reduce the amount of recompiling I have to do

[15:17] * TimToady thinks A is okay, but maybe D for Data and F for Failure

[15:17] <TimToady> Failure is concrete but you still want to filter them out of sigs

[15:17] <JimmyZ> B means Both, which I guess is default

[15:17] <moritz> Abstract, Both, Concrete?

[15:17] <TimToady> I'm saying Both is *wrong*, because it's not either-or

[15:18] <TimToady> we've got Maybes and Errors and Just

[15:18] <TimToady> in H-Think

[15:18] <moritz> I'm just asking what people where thinging when proposing A B C

[15:18] <TimToady> yes

[15:18] <sorear> moritz: Abstract, Concrete

[15:18] <pmichaud> moritz: :U and :D   mnemonically mean   "undefined" and "defined"

[15:18] <pmichaud> which isn't exactly what nom is doing at the moment

[15:19] <moritz> right, they don't map to .defined

[15:19] <sorear> and we're proposing to change the name instead of the semantics

[15:19] <moritz> but rather to $thing === $thing.WHAT

[15:19] <pmichaud> so, it was felt that :A and :C might be more mnemonically accurate

[15:19] <pmichaud> I don't mind if we keep :U and :D  with the undefined/defined meanings as well, though.

[15:19] <TimToady> and what do you do with a Failure?

[15:20] <pmichaud> then :A could be "abstract, fast"

[15:20] <TimToady> I don't see a use case for :C really

[15:20] <pmichaud> and :U could be "undefined, might be slow because it has to check .defined"

[15:20] <pmichaud> and I don't mind if there is no :C  :-)

[15:20] <TimToady> not a type object doesn't say much

[15:20] <pmichaud> basically we just want something that means "everything but :A"

[15:21] <TimToady> one could argue that you don't want Failure binding to either :A or :D by default

[15:21] <TimToady> (if :D meatns Data)

[15:21] <pmichaud> right, so :U could perhaps pick up the Failure case

[15:22] <TimToady> and I still really like that :D is a happy face

[15:22] <TimToady> "happy data"

[15:22] <pmichaud> I'm happy enough if we keep :D

[15:23] <pmichaud> mainly :U is the one that bugs me

[15:23] <JimmyZ> D F ?

[15:23] <pmichaud> (as it currently maps in nom)

[15:23] <TimToady> F seems redundant with Failure $f

[15:23] <moritz> maybe we could have :D (both defined and concrete), :A (abstract), and :F (not defined but concrete)

[15:23] <TimToady> don't need to add :X for types that exist

[15:23] <moritz> though... exactly

[15:24] <pmichaud> :A  - abstract

[15:24] * moritz wonders if Failure ~~ Any

[15:24] <pmichaud> :U - undefined

[15:24] <TimToady> considered :T for type objects, but there's destructive interference with ::T

[15:24] *** ymasory joined
[15:24] <pmichaud> and something that means !undefined

[15:25] <pmichaud> rakudo:   say Failure ~~ Any   # first guess

[15:25] <p6eval> rakudo 248244: OUTPUT«Bool::True␤»

[15:25] <pmichaud> of course, if Failure !~ Any, then for most default arguments it wouldn't bind anyway

[15:26] <moritz> that's exactly what I'm thinking right now

[15:27] * TimToady now wonders whether our low-level last-ditch human-readable stringifyer is also outside of Any and is called Success

[15:28] <TimToady> that's probably a sixth of six impossible things

[15:29] <pmichaud> > my %h = <a b c d e f g h>;  say %h.kv.perl

[15:29] <pmichaud> (('a', 'b'), ('c', 'd'), ('e', 'f'), ('g', 'h'))

[15:29] <pmichaud> > say %h.kv.map({; $^b => $^a }).perl

[15:29] <pmichaud> ('b' => 'a', 'd' => 'c', 'f' => 'e', 'h' => 'g')

[15:29] <pmichaud> \o/

[15:30] <TimToady> why do you need the ;?

[15:30] <pmichaud> maybe don't need it

[15:30] <TimToady> the parameters should make it a closure

[15:30] <TimToady> I think...

[15:30] <dalek> rakudo/nom: a02622b | pmichaud++ | src/core/ (2 files):

[15:30] <dalek> rakudo/nom: Add &infix:«=>» and Enum.perl.

[15:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a02622bbda

[15:30] <dalek> rakudo/nom: fac5bdf | pmichaud++ | src/core/ (2 files):

[15:30] <dalek> rakudo/nom: .map now automatically flattens its invocant.

[15:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fac5bdf54d

[15:30] <TimToady> or was that just $_?

[15:31] <pmichaud> I put the ';' in out of habit for pair constructor closures :)

[15:32] <pmichaud> anyway, nom seems to have trouble with a bare Pair constructor in the closure at the moment (but it doesn't think it's a hash constructor)

[15:32] <pmichaud> we still have some things to fix up in block handling in nom

[15:35] <TimToady> yes, S04:1564 sez placeholders also force closure

[15:36] <pmichaud> okay

[15:36] <pmichaud> jnthn: ^^^^^^

[15:36] *** Mowah_ left
[15:36] <TimToady> basically, you can only parameterize a hash composer with closed-over lexical vars

[15:36] <sorear> I thought Failure was ~~ $everything

[15:37] <sorear> subset Zot of Int where False; my Zot $x = function_that_fails;

[15:38] <TimToady> yes, we've also be considering it a form of 'bottom'

[15:38] <TimToady> *been

[15:39] <TimToady> so maybe Mu is "top" and "success" and our final string forcer is Mu($x)  :)

[15:41] <dalek> rakudo/nom: 03b9dd9 | pmichaud++ | src/Perl6/Actions.pm:

[15:41] <dalek> rakudo/nom: <for> no longer needs explicit &flat, .map handles it automatically for us.

[15:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/03b9dd90e7

[15:46] *** Eevee left
[15:46] *** thowe left
[15:47] *** Eevee joined
[15:52] *** Mowah_ joined
[16:03] <TimToady> I do think we need to take the human-format string forcing away from Str so that Str can be Stringy's bridge type

[16:03] <pmichaud> wfm

[16:04] <moritz> +1

[16:05] <TimToady> and probably apply it to each of say's args without flattening

[16:05] <sorear> +2

[16:05] <TimToady> further differentiating say from print

[16:06] <TimToady> note should probably do the same

[16:06] <pmichaud> say's  signature would no longer be  sub say(*@args) { ... }   then?

[16:06] <TimToady> correct

[16:06] <pmichaud> okay.

[16:07] <pmichaud> I wonder if we should keep say as being print + "\n"   and introduce another huffmanized human-oriented output.

[16:07] <TimToady> probably needs to process the parcel directly, and force each arg with whatever we end up calling the stringer

[16:08] <pmichaud> maybe "speak"  :-P

[16:09] <pmichaud> "show"

[16:10] *** ajoe47 joined
[16:10] <pmichaud> (might look a little too much like "s"+"how" there)

[16:11] <TimToady> I don't think we need any hybrid between print and say

[16:11] <TimToady> it would just confuse people more

[16:11] <pmichaud> no, I'm saying that 'say' is the hybrid between print and something else

[16:12] <TimToady> no, I want say for the dwimmy one

[16:12] <pmichaud> okay

[16:12] <TimToady> it's the proper huffman coding

[16:12] <pmichaud> well, that's why I was saying a short thingy

[16:12] *** Eevee left
[16:12] <TimToady> I would probably never use a print + "\n"

[16:13] <pmichaud> I worry that having say be more dwimmy than + "\n"  will mess up p5 programmers that are getting used to 'say' with that meaning

[16:13] <TimToady> well, it wouldn't be the first thing :)

[16:13] *** Eevee joined
[16:14] <TimToady> ref/deref is just not going to be consisten from p5 to p6

[16:14] <TimToady> *tent

[16:14] <pmichaud> not to mention ~~  :-P

[16:15] <TimToady> I just notice that we're have a lot of extra ~ in rosettacode because say defaults the other way

[16:15] <TimToady> *having

[16:15] <pmichaud> that's a good argument in favor of what you're  (ahem)  saying  then :)

[16:16] <TimToady> also some credit to sorear++ for pushing the notion from time to time

[16:17] <TimToady> still don't know what to call the dwimstringer though...

[16:17] <TimToady> don't completely like any of the suggestions so far

[16:18] * JimmyZ would like to see say  defaults say ~

[16:18] <TimToady> well, it just does it to each arg, not to the args as a whole, I think

[16:19] <pmichaud> does print do the same thing?  or is print suddenly the dwim stringer?

[16:19] <TimToady> so we can still glue things together with , instead forcing everyone to concat

[16:19] <TimToady> huh?  print just does what it already does

[16:21] <pmichaud> right now,  say is just  print @*args, "\n"

[16:21] <pmichaud> sorr

[16:21] <pmichaud> sorry

[16:21] <pmichaud>     say is just    print @args, "\n"

[16:21] <pmichaud> and each of @args ends up being stringified (via low-level .Str)

[16:23] <pmichaud> iiuc, you're wanting    say  to use .Stringy instead of .Str

[16:23] <pmichaud> (and we move .Str to be a bridge type for Stringy)

[16:23] *** Eevee left
[16:23] <TimToady> print can keep doing that, I suppose, or we could think about whether high-level stringy makes more sense for print

[16:23] <TimToady> but that's kinda independent of what say does now

[16:24] <pmichaud> for example, a question is whether

[16:24] <TimToady> no, say doesn't use Stringy

[16:24] *** Eevee joined
[16:24] <TimToady> there are two competing meanings of "high" and "low" here

[16:25] <pmichaud> best explanation for me would be some examples, then

[16:25] <pmichaud> especially examples from the rosetta code

[16:26] <pmichaud> I tend to see the Str vs Stringy distinction as being the difference between    say Mu   and   say ~Mu     or     say 1..5   and say ~(1..5)

[16:26] <pmichaud> (which might be an incorrect viewpoint, but it comes from past discussions.)

[16:27] <TimToady> we're talking about taking two different behaviors away from Str and putting them somewhere else

[16:27] <TimToady> and Stringy might just call Str by default

[16:27] <pmichaud> yes, I get that part (more)

[16:28] <pmichaud> I'm not sure what behaviors are being taken away

[16:28] <TimToady> the two behaviors in question, one is "high", and the other is "low"

[16:28] <TimToady> the "high" behavior is to take some arbitrary type and produce the metastring that a human would want to see while, e.g., debugging

[16:29] <TimToady> the "low" behavior is to force stringification of things that don't normally want to stringify because we're just about to output them

[16:29] <pmichaud> so, we want "high" behavior, but not so high that we just end up duplicating .perl

[16:30] <TimToady> yes, because the whole point of the human output is that the human can tolerate frame violations

[16:30] <TimToady> whereas .perl must keep all frames explicit

[16:30] <pmichaud> I don't suppose "perl" as a listop makes sense :-)

[16:31] *** natureboy joined
[16:31] <TimToady> well, I keep wanting some prefix form or other

[16:31] <TimToady> but whatever

[16:31] <pmichaud> and you want say to have which behavior, "high" or "low" ?

[16:31] <TimToady> the question is whether we need different functions for the high and low, or whether they can be thought of as the same thing

[16:31] <TimToady> both behaviors

[16:31] *** cooper left
[16:32] <TimToady> and print is either low or nothing (coercion to "" with warning as default)

[16:32] <pmichaud> concatenation is low behavior?

[16:32] <TimToady> with , you mean?

[16:32] <pmichaud> in general

[16:32] <pmichaud> i.e.,    $a ~ "string"

[16:33] <pmichaud> or  "string $a"

[16:33] <TimToady> in general, concatentation is .Stringy which will complain and use ""

[16:33] <TimToady> that seems the best default for strings that are going off to other compute processes

[16:33] <TimToady> rather than to humans

[16:33] <pmichaud> agreed thus far

[16:34] <TimToady> print is arguably more compute than human now that we have say

[16:34] <TimToady> say for the human output

[16:34] <TimToady> and "print" means send it to a printer, originally...

[16:35] <TimToady> print is likelier to be used for things like sending data down a socket to another program

[16:35] <pmichaud> yes; part of what has been confusing me is that the word "high" used to describe .Stringy  (the coercion with warning)

[16:36] <pmichaud> that's switched now.

[16:36] <TimToady> well, Metaphors We Live By is sometimes more like Metaphors We Die By...

[16:36] <TimToady> and in this case probably means we should avoid the high/low metaphor entirely

[16:36] <pmichaud> right

[16:37] <pmichaud> so, we want some method that means approximately   .perl in some cases and .Str in others

[16:37] <pmichaud> i.e., that isn't quite so strict as .perl about frames

[16:38] <TimToady> .loose :)

[16:38] <pmichaud> that method could be just  .say, fwiw

[16:38] <pmichaud> and then say as a prefix/listop simply invokes .say on its arguments

[16:38] <TimToady> not listop

[16:39] <TimToady> say @foo;   # <- puts spaces

[16:39] <pmichaud> low-prec prefix, then 

[16:40] <pmichaud> .say then defaults to .Str or .perl, but can be overridden in cases where the context prefers that

[16:40] <TimToady> you can always say @foo.join and such

[16:41] <pmichaud> well, in the case of  @foo.say, it should use .Str 

[16:41] *** jaldhar left
[16:41] *** nebuchadnezzar left
[16:41] <TimToady> .smart  :)

[16:41] *** jaldhar joined
[16:41] <pmichaud> .human

[16:41] <TimToady> yes, arrays default to .Str

[16:42] <TimToady> print smart @foo;

[16:42] <TimToady> print smart @foo, "\n";   # say

[16:43] <pmichaud> okay, I see what you're getting too now and I'm much less confused by the high/low distinction

[16:43] <TimToady> trouble with human is it's also a noun

[16:43] <pmichaud> *getting to

[16:43] <TimToady> what high/low distinction?  :P

[16:43] <TimToady> trouble is IO is both very high and very low

[16:43] <TimToady> depending on your viewpoint

[16:43] <TimToady> so let's take the viewpoint out of it

[16:44] <TimToady> .terse if we think of it as a chopped down .perl

[16:45] <pmichaud> .lrep  (logical representation, or .perl backwards  :-)  :-)

[16:45] <pmichaud> (sorry, couldn't help myself there :)

[16:45] <TimToady> .meta if we think of it as adding meta-info where that would be thrown away by .Str

[16:46] <lichtkind> sorear: i just added Niecza to http://www.perlfoundation.org/perl6/index.cgi?implementations

[16:46] <lichtkind> hope more will follow :)

[16:49] * TimToady is tempted to call the coercion .Say

[16:50] *** nebuchadnezzar joined
[16:55] <TimToady> .vet has possibilities

[16:56] <pmichaud> .meta seems a little too meta to me -- it doesn't get the "this is for I/O" concept in there.   I don't follow ".vet".

[16:56] <lichtkind> oh my ego is hurt wiki changes are no more visible :)

[16:57] <TimToady> as in "vet this for appropriateness for children"

[16:57] * lichtkind added sin cos tan gcd and lcm

[16:57] <TimToady> yes, meta is overgeneral

[16:58] <TimToady> to vet something is to run it through a human filter for someone else

[16:58] <pmichaud> of course, .vet can also be a noun :-)

[16:58] <pmichaud> .vetted, maybe

[16:58] <TimToady> don't know that there's much chance of confusion on that one though

[16:58] <TimToady> I'm looking for something shorter than 5 chars

[16:59] *** jaldhar left
[16:59] <TimToady> that is unlikely to be confused with anything else

[16:59] *** jaldhar joined
[17:00] <JimmyZ> lichtkind: Niecza doesn't have a link 

[17:02] <pmichaud> .name, .label, .text, .gist   (just brainstorming)

[17:02] <lichtkind> JimmyZ: because it has not yet a page

[17:02] <lichtkind> JimmyZ: you can change that :)

[17:03] <lichtkind> i thought i begin my mentioning it

[17:03] <JimmyZ> oh, I think it link to github

[17:03] <pmichaud> .form

[17:03] <lichtkind> JimmyZ: do it :)

[17:03] <pmichaud> .repr

[17:04] <pmichaud> .desc

[17:04] *** Eevee left
[17:04] <pmichaud> .pers   (for "person", as well as the "s"hort form of .per"l")

[17:05] <pmichaud> or maybe the "s"imple form of per"l"  :-)

[17:05] <pmichaud> there's even   .perls     :-)

[17:05] <colomon> .pearl

[17:06] <pmichaud> (not less than 5 chars, though)

[17:06] *** Eevee joined
[17:06] <pmichaud> .view   (probably too much conflict with other concepts)

[17:06] <moritz> .ruby (just kidding)

[17:07] <pmichaud> there's always   .dump  :-)

[17:08] *** JimmyZ left
[17:08] <colomon> errr... .dump is kind of what the rough approximation of the concept is named in p5, right?

[17:09] <pmichaud> right.  .dump comes from the notion that this is used in debugging

[17:10] <TimToady> most of these things are way to overloaded in the culture

[17:10] <pmichaud> instead of .pretty, could use  .beau  (or .belle :-)

[17:10] <TimToady> *too

[17:10] <pmichaud> .cute

[17:10] <TimToady> yttcn

[17:10] <pmichaud> yes, I do!  :)

[17:10] <pmichaud> .nice

[17:10] <TimToady> .cat and .kitten

[17:10] <colomon> btw, debugging in C++ the last few days has left me wishing I could use p6 for work.  "say @basis" takes a remarkably large amount of code in C++....

[17:11] <moritz> .nice-ish

[17:11] *** jaldhar left
[17:11] *** frelopes joined
[17:11] <pmichaud> I kind of like .nice

[17:11] <TimToady> .ish

[17:11] <pmichaud> it's.... nice

[17:11] *** jaldhar joined
[17:11] <colomon> can we have .nasty too?

[17:11] <TimToady> ish = "I See Humans!"

[17:11] <pmichaud> .perlish    or .pish  :-)

[17:11] <pmichaud> .pfh   (".perl for humans")

[17:12] <TimToady> ish has the advantage of implying approximatoin

[17:12] *** frelopes left
[17:12] <pmichaud> .neat

[17:13] <moritz> .tidy

[17:13] <TimToady> tidy is nice, but the actual method is kind untidy

[17:13] <moritz> .hacky

[17:14] <pmichaud> .pith

[17:14] <pmichaud> (too noun-y)

[17:14] <jlaire> .show is intuitive to a haskellist

[17:15] <pmichaud> I think we're after something that gets the representation but doesn't display it

[17:15] <pmichaud> .show implies "display it"

[17:15] <jlaire> hmm, that's what it does in haskell, but I realize it sounds misleading

[17:15] <TimToady> it leaves out the metastuff where the user is likely to not want it

[17:15] <TimToady> but really, it's mostly the other way around

[17:16] <TimToady> just output some stuff, but if I get something unexpected, do something safeish instead

[17:16] <TimToady> safeish and informative

[17:16] <TimToady> so "vet this for the children"  :)

[17:17] <TimToady> it's the censor's *bleep*  :)

[17:17] <pmichaud> .info  :-)

[17:17] <jlaire> .what (.wat .wut :]) .dwim .tos (to string)

[17:18] <moritz> .huh

[17:18] <TimToady> so maybe the .perl'd bits should be in reverse video or something

[17:18] *** Eevee left
[17:18] <moritz> .wtf

[17:18] <TimToady> that's not so child safe :)

[17:18] *** Eevee joined
[17:18] <jlaire> .nsfc

[17:19] <TimToady> this would be a .sfh call

[17:19] <TimToady> .safe

[17:19] <pmichaud> I worry that .safe goes along with 'taint' somehow someday.

[17:19] <TimToady> .defang .declaw

[17:19] <TimToady> .coddle :)

[17:20] <moritz> .hug

[17:20] <jlaire> is this method going to be used often, other than implicitly by say?

[17:20] <pmichaud> .said  :-)

[17:21] <pmichaud> .phrased  :-)

[17:21] <TimToady> I can see it used where Str() and .Str look too ugly, or are not dwimmy enough

[17:22] <TimToady> pity ok is used already

[17:23] <TimToady> if we never have native strings, could steal .str

[17:23] <pmichaud> too much confusion with .str, I think.

[17:24] <TimToady> .norm

[17:24] <TimToady> confusing with normalize though

[17:24] <moritz> sounds like a mathematical thing

[17:24] *** Eevee left
[17:24] <TimToady> still like vet the best so far

[17:25] * moritz doesn't

[17:25] *** Eevee joined
[17:25] <TimToady> I agree it's not perfect

[17:25] <TimToady> .me

[17:25] <TimToady> print me @foo;  :)

[17:26] <moritz> maybe a bit too .cute :-)

[17:26] <jlaire> .meh

[17:26] <colomon> Is there a compelling reason to huffmanize it to fewer than 5 characters?  it seems like something you might well never call directly...

[17:27] <pmichaud> .sane ?

[17:27] <TimToady> I think it will be called often as long as we don't dehuffmanize it

[17:27] <TimToady> except it's arguably insane :)

[17:27] <jlaire> .huff

[17:27] <pmichaud> only for the implementors

[17:27] <pmichaud> the point is that it's been made sane by someone else :)

[17:28] <pmichaud> I was also thinking in the sense of "sanitized"

[17:28] <TimToady> no, it really is insane in the sense that it's not a coherent set of frames

[17:28] <TimToady> go insane in the way that humans do all the time

[17:28] <pmichaud> that feels like .gist, then :-)

[17:29] <TimToady> gist is pretty good, but has git overlodings

[17:29] <TimToady> *oa

[17:29] <pmichaud> because of the nopaste feature?  that might actually reinforce as much as disassociate

[17:29] <TimToady> gist isn't bad

[17:31] <TimToady> print gist "Foo = ", @foo, "\n";   # what say "Foo = ", @foo; turns into

[17:31] *** Eevee left
[17:31] <TimToady> so gist is also a parcel processor as a (syntactic) listop

[17:32] <TimToady> as a listop, applies .gist to each arg and then joins(')

[17:32] <TimToady> or just returns the list

[17:32] <pmichaud> afk for a bit -- lunchtime

[17:32] <TimToady> let's go with gist, I guess

[17:33] <_patch> rakudo: say '"abc"' ~~ /<+print-["]>*/

[17:33] <p6eval> rakudo 248244: OUTPUT«␤»

[17:33] <_patch> rakudo: say 'abc"' ~~ /<+print-["]>*/

[17:33] <p6eval> rakudo 248244: OUTPUT«abc␤»

[17:33] *** donri joined
[17:34] <moritz> _patch: it matches zero-width string before the "

[17:34] <moritz> _patch: if you don't want zero-width matches, use +

[17:34] <_patch> moritz: thanks!

[17:34] *** Eevee joined
[17:35] *** ajoe47 left
[17:41] *** PacoLinux left
[17:43] *** PacoLinux joined
[17:45] *** Eevee left
[17:45] *** Eevee joined
[17:50] *** ajoe47 joined
[17:51] <dalek> rakudo/nom: e3fb8b7 | pmichaud++ | src/core/ (3 files):

[17:51] <dalek> rakudo/nom: Clean up .perl a bit for List/Array/Parcel.

[17:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e3fb8b7ca0

[17:51] *** Eevee left
[17:52] *** Eevee joined
[17:53] <_patch> rakudo: grammar X { token TOP { <print> } }; say X.parse('a')

[17:53] <p6eval> rakudo 248244: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in 'Mu::print' at line 1321:CORE.setting␤  in 'X::TOP' at line 22:/tmp/HzxMvP9wH9␤  in 'Grammar::parse' at line 6463:CORE.setting␤  in main program body at line 22:/tmp/HzxMvP9wH9␤»

[17:53] <_patch> rakudo: grammar X { token TOP { <alpha> } }; say X.parse('a')

[17:53] <p6eval> rakudo 248244: OUTPUT«a␤»

[17:56] <_patch> anyone know why i can't use <print> in my grammar?

[17:58] <moritz> because it's a method in class Mu, of which grammars implicitly derive from

[17:58] <moritz> and rules are just methods

[18:02] <_patch> moritz: how would one use the functionality normally provided by <print> in a regex, when using a grammar?

[18:10] <moritz> _patch: <+print> or maybe <:print> (but not yet implemented)

[18:12] <_patch> rakudo: grammar X { token TOP { <+print> } }; say X.parse('a')

[18:12] <p6eval> rakudo 248244: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in 'Mu::print' at line 1321:CORE.setting␤  in 'X::TOP' at line 22:/tmp/8Npu1DxIwD␤  in 'Grammar::parse' at line 6463:CORE.setting␤  in main program body at line 22:/tmp/8Npu1DxIwD␤»

[18:12] <moritz> I guess it's a bug that you can't use it that way

[18:12] *** Eevee left
[18:13] *** Eevee joined
[18:16] * TimToady wonders if there's any way to reliably detect the accidental match of a leading null string by a *

[18:16] <TimToady> that is at least good enough to issue a warning, along with "To suppress this warning, do ..."

[18:27] * ashleydev thinks that there's lots of marketing that will happen implicitly if it's .wtf (think of how much people will talk about it and enjoy using it)

[18:28] * ashleydev also thinks that people will feel that perl6 will sympathize with them when they are debugging if it's .wtf

[18:29] <ashleydev> more human connection...

[18:29] <TimToady> too emotionally overloaded for what it actually does

[18:32] *** envi_laptop left
[18:32] <TimToady> and it's not my place to force people to say crudities that might singe their consciences

[18:33] <jlaire> how about .look

[18:33] <TimToady> too general

[18:33] <TimToady> and no shorter than .gist

[18:44] *** cyk joined
[18:49] <cxreg> this is interesting stuff

[18:49] <cxreg> http://people.mozilla.com/~dmandelin/KnowYourEngines_Velocity2011.pdf

[18:49] <cxreg> i assume it's old news to you guys though

[18:55] <dalek> rakudo/nom: e7026ba | pmichaud++ | src/core/ (3 files):

[18:55] <dalek> rakudo/nom: More .perl updates for Hash and List.  Added circumfix:<{ }>, which

[18:55] <dalek> rakudo/nom: doesn't work yet due to a bug in the actions.

[18:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e7026ba74b

[18:59] * TimToady wonders if while we are detanglish .Str from .gist, we should also detangle .Bool from .truth

[18:59] <pmichaud> I wouldn't be opposed to that.

[18:59] <TimToady> so .Bool returns True/False, but .truth can just return 0 or 1

[19:00] *** tokuhirom left
[19:00] <TimToady> not sure how it should play with autothreading though

[19:00] <TimToady> well, .truth would certainly force collapse

[19:01] <TimToady> the question is whether .Bool then autothreds like ? and so are specced to

[19:01] <TimToady> I think probably yes

[19:01] <TimToady> Bool is just the "bridge" type of booleans :)

[19:05] <dalek> rakudo/nom: ba008de | pmichaud++ | src/core/Hash.pm:

[19:05] <dalek> rakudo/nom: Fix Hash.STORE to accept Enums and EnumMaps.

[19:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba008de41f

[19:06] *** kst left
[19:07] *** kst joined
[19:09] *** muixirt left
[19:12] * moritz doesn't see the point of separate .truth and .Bool methods

[19:12] <moritz> we've had that before (.true and .Bool), and abolished it because it was confusing/inconsistent, and nobody could name a real benefit of the distinction

[19:18] <dalek> specs: 669e0dd | larry++ | S (5 files):

[19:18] <dalek> specs: .Str -> .gist and .Bool -> .truth as appropriate

[19:18] <dalek> specs: 

[19:18] <dalek> specs: .Str and .Bool are now just the normal types.  The primitives used by

[19:18] <dalek> specs: 'say' and conditionals are now separate methods.  So .gist (and gist())

[19:18] <dalek> specs: now do the forced-dwimmy human-readable stringification used by 'say',

[19:18] <dalek> specs: and .truth is the primitive that returns a 0 or 1 to be used internally

[19:18] <dalek> specs: by conditionals like 'if' and 'while'.

[19:18] <dalek> specs: review: https://github.com/perl6/specs/commit/669e0ddc86

[19:19] <TimToady> we have to keep our types distinct from our predicates

[19:19] *** Eevee left
[19:20] *** Eevee joined
[19:21] <cxreg> the GC tricks in that slide deck are pretty compelling

[19:21] <TimToady> especially those predicates that are required for circularity saws

[19:22] *** thou joined
[19:23] <TimToady> and it's just wrong for .Bool to return an integer instead of a Bool

[19:28] <TimToady> part of the reason we got rid of .true is because people were confusing it with True.  .truth doesn't have that problem so much.

[19:29] <TimToady> and I submit that .Bool/.Boolean was every bit as confusing if not more so

[19:29] <TimToady> we are now *much* more consistent

[19:29] <TimToady> Boolean is a role.  Bool is a type.  .truth is a primitive predicate.

[19:29] <moritz> so 'if' and 'unless' would ask for .truth, not .Bool?

[19:29] <TimToady> maybe it should be .TRUTH

[19:30] <TimToady> correct

[19:32] <TimToady> and it's now .truth that is defined in Junction so that they can collapse correctly

[19:33] <pmichaud> prefix:<?>   then uses .Bool or .Boolean   (and autothreads)  ?

[19:33] *** dukeleto left
[19:33] <pmichaud> .Boolean, probably.

[19:33] <TimToady> it always autothreaded

[19:33] *** dukeleto joined
[19:33] <pmichaud> well, at one time we said that boolean context collapsed, and prefix:<?> was a contextualizer that did that

[19:33] <TimToady> but since it autothreads externally, it could use .truth internally if it wanted to

[19:34] <pmichaud> anyway, I'm fine with the new constellation of types, roles, gists, etc.

[19:37] <TimToady> well, we can think about that.  one could argue that Bool still needs to collapse when used as a storage type, or maybe that's just bool

[19:37] <TimToady> as a general rule, native types can't take junctions

[19:38] *** wamba left
[19:38] * TimToady wonders if that's what the universe is doing...

[19:41] <TimToady> it's probably a symptom of our non-QM minds that we think of the collapsed value as the primitive rather than the superposed one

[19:41] <TimToady> another of those high/low metaphors that we have to be careful about

[19:42] <pmichaud> what high/low metaphor?  ;-)

[19:42] <TimToady> the other one that is below the third one that is hiding it on that pile over there

[19:44] <sorear> good * #perl6

[19:44] <TimToady> I am always up to my old tricks, except when I'm down to my old tricks.

[19:44] <sorear> I see y'all have been busy... new spec commit for me to review

[19:45] <TimToady> circularity sawing on Bool as well as Str

[19:45] <TimToady> nap &  # will answer Qs when I wake up

[19:48] <sorear> lichtkind: you want wiki changes to be visible?  complain to TPF and get them to stop the spam

[19:49] *** thou left
[19:52] *** ymasory left
[20:10] <sorear> TimToady: I don't understand why .gist was changed

[20:10] <sorear> er

[20:10] <sorear> TimToady: I don't understand why .Bool was changed

[20:10] <sorear> it converts any type to Bool, it should be called Bool

[20:11] <sorear> also: now that you've renamed it, you need to add a special case somewhere to recover '0 but True'

[20:11] <sorear> also: are you saying I need to define bools in terms of Int now? :(

[20:18] *** cbk joined
[20:19] *** mj41 joined
[20:29] *** natureboy left
[20:32] <lichtkind> sorear: i did so several times to my grant manager

[20:32] <lichtkind> TimToady: is it fair to day that changes like categorize and rol are driven by the programs people write here but most of the other are driven by implementation

[20:37] *** araujo joined
[20:51] *** lue joined
[20:51] <lue> hello zebras! o/

[20:51] <tadzik> hello lue!

[20:59] *** cooper joined
[21:01] *** mj41 left
[21:05] *** kaare_ left
[21:08] <sorear> hi...

[21:09] <dalek> specs: d3f2a14 | pmichaud++ | S03-operators.pod:

[21:09] <dalek> specs: S03 example missing ".perl" on display of flattening Parcel results.

[21:09] <dalek> specs: review: https://github.com/perl6/specs/commit/d3f2a14bba

[21:09] <sorear> pmichaud: hi

[21:11] <pmichaud> sorear: o/

[21:18] <sorear> pmichaud: can you explain to me why .Bool -> .truth?

[21:18] * tadzik does not liek

[21:19] * sorear will at least give it a chance to be explained

[21:20] <pmichaud> I might not be the best explainer.  But iiuc, .truth is like ".Numeric" -- it simply means "return something that I can use in a boolean context".  It doesn't have to be a Bool.

[21:20] <sorear> unrelated: Niecza and Rakudo both have some sort of GLOBAL::PARENT (although the purpose is completely different).  What allowences does the spec make for this?

[21:20] <pmichaud> GLOBAL::PARENT ?

[21:21] <sorear> for you, it's get_root_namespace

[21:21] <pmichaud> you mean something "above the GLOBAL namespace?"

[21:21] <sorear> yes

[21:21] <pmichaud> I don't know if that will exist still in nom.

[21:22] <pmichaud> that's more an artifact of Parrot than Rakudo, I suspect.

[21:31] <ajoe47> has a noob ??? I have perl6 in ~/rakudo and a perl6 in ~/rakudo/parrot_install/bin. Which should I use?

[21:32] <pmichaud> the one in parrot_install/bin

[21:32] <ajoe47> thx

[21:32] <pmichaud> the one in ~/rakudo only works from the ~/rakudo dir

[21:32] <ajoe47> gotcha!

[21:33] *** cooper left
[21:38] <sorear> ajoe47: there are no noobs here.  that's too disrespectful for us.  this place is inclusive of all comers. :)

[21:40] <sorear> pmichaud: AFAIK, "boolean context" is .Bool, so absolutely any object can be used in boolean context (at worst it hits Mu.defined/Bool)

[21:40] * TimToady shouldn't have put the .truth conjecture in with the gist

[21:41] <TimToady> was trying to detangle observation from types, but shouldn't do that on a day like today...

[21:41] <pmichaud> what's today like?  ;-)

[21:41] *** Psyche^ joined
[21:41] <sorear> I'm not real attached to "0 but True" anyway, I wouldn't mind if we changed the spec in such a way as to break it :)

[21:42] * TimToady is trying not to observe that

[21:42] *** icwiener left
[21:43] <sorear> although I'd prefer an observation method that is allowed to return True and False...

[21:43] <sorear> 1 and 0 is kinda blech

[21:43] <TimToady> that's fine, we can break the circularity some other way

[21:43] <TimToady> how are you breaking the circularity, out of curiosity?

[21:44] <TimToady> to avoid .Bool.Bool.Bool.Bool....

[21:45] * TimToady imagines some primitive like decide($x, {this}, {that})

[21:45] *** Patterner left
[21:45] *** Psyche^ is now known as Patterner

[21:46] <TimToady> or is it just coerce to Bool and then introspect based on intimate knowledge of the Bool type?

[21:50] <pmichaud> at some level it should probably be a native 'bool'

[22:01] <pmichaud> > say Mu, 1, 2, <a b c>, [<d e f>]

[22:01] <pmichaud> Mu()12abcd e f

[22:01] <dalek> specs: f1ac9f5 | larry++ | S (5 files):

[22:01] <dalek> specs: revert the .truth conjecture

[22:01] <dalek> specs: 

[22:01] <dalek> specs: Shouldn't have speculated about .truth along with the .gist change,

[22:01] <dalek> specs: so reverting that part.  Also, what conditionals do to break the

[22:01] <dalek> specs: boolean circularity is left up to the implementation.

[22:01] <dalek> specs: review: https://github.com/perl6/specs/commit/f1ac9f58ea

[22:01] <pmichaud> TimToady++

[22:02] <pmichaud> I've forgotten the answer to this -- is there a way to get p6eval to do an unscheduled rebuild of the latest version of an implementation?

[22:03] *** tokuhirom joined
[22:03] *** dukeleto left
[22:03] <pmichaud> e.g., to get it to build the version of nom I just pushed?

[22:03] <dalek> rakudo/nom: d310eb8 | pmichaud++ | src/ (3 files):

[22:03] <dalek> rakudo/nom: Fixing flats part #1:  Change $!flat flag to $!flattens (to avoid punditry with .flat).

[22:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d310eb82d1

[22:03] <dalek> rakudo/nom: de6c43d | pmichaud++ | src/ (7 files):

[22:03] <dalek> rakudo/nom: Fixing flats part #2:  Move $!flattens flag from ListIter into List.

[22:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de6c43d350

[22:03] <dalek> rakudo/nom: ba6af41 | pmichaud++ | src/core/ (5 files):

[22:03] <dalek> rakudo/nom: First cut at an implementation of 'gist' (from specs commit 669e0dd).

[22:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba6af41de5

[22:03] *** dukeleto joined
[22:07] <TimToady> has bool $.Bool;  # how it seems like it might be for a native bool; the api can still be .Bool

[22:09] <pmichaud> yes, that's about what nom does... except it uses 'int' instead of 'bool' because Parrot doesn't have a native 'bool' type

[22:10] <TimToady> it's also possible that any assignment to a boolean storage location collapses so we don't get silly errors

[22:10] <pmichaud> nom: say 'hello'

[22:10] <p6eval> nom: OUTPUT«hello␤»

[22:10] <TimToady> my bool $x = any(@y) == $z;  # should Just Work

[22:10] <pmichaud> oh, no version number?

[22:10] <pmichaud> hmmm

[22:11] *** buubot_backup left
[22:11] *** REPLeffect joined
[22:11] <pmichaud> nom:  Perl6::Compiler.version   # maybe

[22:11] <p6eval> nom: OUTPUT«Null PMC access in invoke()␤current instr.: '_block1002' pc 83 ((file unknown):134) (:1)␤»

[22:11] <pmichaud> maybe not.

[22:12] <pmichaud> nom:  Perl6::Compiler.compiler('perl6').version  # maybe

[22:12] <p6eval> nom: OUTPUT«Null PMC access in invoke()␤current instr.: '_block1002' pc 83 ((file unknown):50160326) (:1)␤»

[22:12] <pmichaud> maybe not.

[22:19] <TimToady> there's something screwy with our notation: my Any $x as bool;

[22:20] <TimToady> should be more like: my bool $x from Any;

[22:20] *** Dzzy joined
[22:21] <TimToady> or like what I was suggesting earlier: my bool(Any) $x;

[22:21] *** masak joined
[22:21] <masak> good midnight, #perl6

[22:21] <TimToady> so I officially Don't Like 'as'

[22:21] <pmichaud> nom:  say Mu   # yet?

[22:21] <p6eval> nom: OUTPUT«Mu()␤»

[22:22] <pmichaud> nom:  say Mu, [3,4,5];  # yet?

[22:22] <p6eval> nom: OUTPUT«Mu()Array<73764008>␤»

[22:22] <pmichaud> not yet.

[22:22] <pmichaud> masak:  o/ !!

[22:22] <pmichaud> how goes the workshop?

[22:22] <masak> pmichaud: it seems to be proceeding flawlessly.

[22:23] <pmichaud> nom:  my %h = <a b c d e f>;  say %h.kv.perl;   # is this working yet on p6eval?

[22:23] <p6eval> nom: OUTPUT«(('a', 'b'), ('c', 'd'), ('e', 'f')).list␤»

[22:23] <pmichaud> \o/

[22:23] <masak> I'm a bit tired, but I thought I might pop in to edublog before going to bed.

[22:24] <masak> TimToady: in Ye Olde Apocalypses, somewhere there's a mention about implicit casting being made if there's an appropriate casting method on the source type. has that feature been scrapped completely since then?

[22:24] <masak> TimToady: it seems that the static assignment checking jnthn++ is building towards could still support something like that.

[22:26] <TimToady> Cool replaced most of that

[22:26] <masak> but Cool is a special case for Perl-native types, no?

[22:27] <TimToady> anything beyond that probably needs the approval of the destination

[22:27] <TimToady> my int(Cool) $x = mumble()

[22:27] <masak> not sure I can parse the 'int(Cool)' bit.

[22:28] <pmichaud> I think it means "cast to int from any Cool value"

[22:28] <pmichaud> if the value isn't Cool, it's a type violation

[22:28] <TimToady> it means bind as if it's Cool, but then int() it

[22:29] <masak> oh. is that spec'd?

[22:29] <TimToady> misleading to use = there

[22:29] <TimToady> no, but neither is 'as' on parameters, afaict

[22:29] <masak> it's not? o.O

[22:29] <masak> I'm pretty sure I've seen it in there somewhere.

[22:29] <masak> probably in S06 or S12.

[22:30] <masak> hm, maybe that was just on return values....

[22:30] <TimToady> yes, but nothing else

[22:30] <masak> huh.

[22:31] <pmichaud> it appears once in S32/Numeric.pod

[22:31] <pmichaud> S32-setting-library/Numeric.pod:244:  multi method base(Cool $base as Int)

[22:31] <TimToady> anyway, generations of programmers will revile us if 'my Cool $x as int;' is how we declare a native

[22:32] <masak> pmichaud: right, but S32 doesn't feel normative with such things. we already take "liberties" with those method declarations in the name of explanatoriness.

[22:32] <pmichaud> masak: I agree, just wanted to point out the (sole) reference in the current spec :)

[22:32] <TimToady> it has to be some variant of 'my int $x;'

[22:32] <pmichaud> my Cool => int $x;    # branestorm

[22:33] <masak> TimToady: I have to ask. what's wrong with 'int $x'?

[22:33] * masak hasn't backlogged properly

[22:34] <pmichaud> my int $x = 3 + 4;   # type violation, 3+4 is Int

[22:34] <masak> I thought those types autoboxed/unboxed.

[22:34] <TimToady> yes, those probably do

[22:34] <masak> i.e. even if we don't have autoconversion anywhere else, we do on those types.

[22:34] <TimToady> I'm more going after parameters

[22:35] <masak> same thing there, no?

[22:35] <masak> or doesn't that work because of binding?

[22:36] <TimToady> sub foo (Cool $x as int) just looks wrong when it's more like (int $x accepts Cool)

[22:36] <TimToady> or (int(Cool) $x) in my head

[22:36] <TimToady> which looks like a coercion

[22:36] <masak> int $x digs Cool

[22:36] <masak> ;)

[22:37] * TimToady shoots masak in a dispassionate sort of way

[22:37] <masak> :P

[22:37] <TimToady> then hugs him

[22:37] <masak> too late, I'm wounded...

[22:37] <TimToady> you're the one playing with time usually

[22:38] <TimToady> debug yourself :)

[22:38] <masak> implementor, debug thyself.

[22:39] <TimToady> and generally we'd probably say: (int() $x) to default to something like Cool or Any

[22:40] <TimToady> and to address the boxing issue, maybe native types default to box, so 'my int $x;' is short for 'my int(Int) $x;'

[22:41] <masak> +1

[22:41] <masak> defaulting to box is something I've just assumed so far.

[22:42] *** thou joined
[22:43] <lichtkind> masak: how long you will be around?

[22:43] <TimToady> my &intboxer := &int.assuming(Int);

[22:43] <pmichaud> in the backlog you once suggested   sub foo(Foo>Bar $x) { ... }   to coerce from Foo to Bar

[22:43] <masak> lichtkind: I'm already asleep, actually. I'm just writing a blog post before my session times out.

[22:44] <masak> pmichaud: I don't like overloading '>' with coercion, just as I don't like Ruby's overloading of the numeric relationals with 'is' semantics.

[22:45] <masak> pmichaud: 'as' is much clearer to me.

[22:45] <TimToady> as is going to die

[22:45] <masak> I gathered as much :)

[22:45] <lichtkind> masak: well than sleep well :)

[22:45] <masak> TimToady: just saying I liked it.

[22:45] <masak> lichtkind: thanks. you too :)

[22:45] <pmichaud> when this was discussed before, I remember some complications with the From(To) syntax... I'm looking those up

[22:46] *** thou left
[22:46] *** buubot_backup joined
[22:46] <TimToady> declarative as, but perhaps not infix:<as>

[22:46] <TimToady> it's To(From)

[22:46] <TimToady> so that To() can default

[22:46] <pmichaud> okay, To(From)

[22:47] <pmichaud> I still remember having an unresolved issue with it.

[22:47] <pmichaud> I'm seeing if I can track it down in the ir clogs

[22:47] <lichtkind> TimToady: if i may reinforce my question, did categorize and roll and mcd are driven by programs or by your ideas

[22:47] <TimToady> I have no idea what you're asking

[22:47] <masak> btw, 'uniq' isn't spec'd. is the Rakudo implementation of it a rogue thing, or should it be spec'd?

[22:47] <TimToady> and if I did, the answer is probably both

[22:48] <TimToady> well, if we spec it, we'll have to decide its semantics

[22:49] <masak> that's what I'm thinking.

[22:49] <masak> I'm kinda curious what semantics it has...

[22:49] <masak> if I knew, I'd have spec'd it already.

[22:49] <pmichaud> I think 'uniq' was at one time one of those operators that TheDamian said should be a builtin because so many people get it wrong :-)

[22:50] <TimToady> well, does it require a sorted list, first off

[22:50] <masak> TimToady: no.

[22:50] <masak> TimToady: that was determined on p6l long ago.

[22:50] <masak> TimToady: and I think it's right to break Unix "tradition" there.

[22:50] <TimToady> then doesn't dup 'sort :uniq'  :)

[22:50] <masak> huh? is *that* spec'd? :P

[22:50] <TimToady> next question is which identity semantics

[22:51] <masak> aye.

[22:51] <masak> Rakudo's uniq hashes strings.

[22:51] <masak> I don't really like that.

[22:51] <TimToady> if it isn't, and uniq doesn't require sorted, then sort should probably take a :uniq option

[22:51] <TimToady> since the algo for sorted is much more memory efficient

[22:51] <lichtkind> TimToady: i just wondered how much influence the actual perl 6 modules/programs have on the spec lately

[22:51] <masak> I don't mind sort taking a :uniq option.

[22:51] <TimToady> so it should probably be === semantics

[22:52] <TimToady> meaning an object hash

[22:52] <masak> I think so, yes.

[22:52] <TimToady> or a Set

[22:52] <masak> Rakudo's Set uses uniq.

[22:52] <TimToady> a Set should probably default to === semantics

[22:52] <masak> aye.

[22:52] <TimToady> but I'll bet rakudo's uniq doesn't

[22:52] <masak> and so should uniq, probably.

[22:52] <masak> no, it doesn't.

[22:53] <masak> it uses Str comparisons, because uniq does.

[22:53] <TimToady> "Well, there you have it."

[22:53] * masak nods

[22:53] <masak> that was easier than I thought. :)

[22:53] <flussence> wouldn't .uniq just be a duplicate of .Set.List then?

[22:53] <masak> whoa, circularity.

[22:54] <TimToady> .uniq is readable

[22:54] <TimToady> but I think it's not the same

[22:54] <masak> no.

[22:54] <TimToady> .uniq can be lazy

[22:54] <masak> .uniq preserves order.

[22:54] <masak> .Set.List doesn't have to.

[22:55] <TimToady> that too

[22:56] <TimToady> my KeySet %seen; take $next unless %seen++;

[22:56] <TimToady> well, with a gather between

[22:56] <TimToady> and a loop...

[22:57] <masak> I don't feel a need to spec the exact implementation... :)

[22:57] <masak> just enough to nail it down.

[22:57] <TimToady> yeah

[22:57] <flussence> I've never seen that %hash++ thing before... does that increment the .each counter?

[22:57] <masak> but yes, I agree about the above semantics.

[22:57] <masak> flussence: I think it was TimToady being sloppy :)

[22:58] <flussence> still seems like a neat idea :)

[22:58] <masak> ...or not... :)

[22:58] * masak isn't a fan of 'each'

[22:58] <TimToady> sub uniq { grep {(state KeySet %)[$_]++ or $_} @_ }

[22:58] <masak> stateful container types. yech.

[22:59] <TimToady> %hash++ is a typo

[22:59] <flussence> aww

[23:00] <masak> \o/

[23:00] <TimToady> so is the missing comma before @_ ^^^

[23:00] <flussence> std: my %hash; %hash++;

[23:00] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[23:00] <TimToady> and it's wrong

[23:00] <flussence> I'll just have to define that ++ myself... :)

[23:00] <TimToady> state % is KeySet

[23:01] <TimToady> otherwise it's a hash of KeySets

[23:02] <TimToady> sub uniq { grep {(START KeySet.new)[$_]++ or $_}, @_ }   # more like this

[23:03] *** daniel-s joined
[23:03] * TimToady wonders if we should really rename START to STATE

[23:05] <masak> TimToady: STATE feels less like a phase than START.

[23:05] <masak> START gives me a sense of when things execute. which is kind of the point of phaser names.

[23:06] <TimToady> maybe it's enough that the begin with the same letters

[23:06] <TimToady> *they

[23:06] <masak> :P

[23:07] <flussence> close enough :)

[23:07] <masak> STAVANGER

[23:07] <TimToady> we could rename 'state' to 'start' and really confuse the P5ers :)

[23:07] *** aindilis` left
[23:07] <masak> I would mind that less :)

[23:07] <masak> but I also think it's fine the way it is now...

[23:08] <TimToady> I think we'll leave it alone

[23:08] *** aindilis` joined
[23:08] <TimToady> it's not like we have an OUR phaser either

[23:08] <masak> that... does not seem to make sense.

[23:09] <masak> now, a HAS phaser I *could* see.

[23:09] <masak> probably composition time or something.

[23:10] <masak> blog post! http://strangelyconsistent.org/blog/june-18-2011-junctions

[23:10] <TimToady> well, see S03:4825

[23:12] <masak> oh, so in a sense we do have one.

[23:12] <masak> fair enough. I agree seeking consistency there would be foolish.

[23:13] <TimToady> or at least hobgobliny

[23:14] <masak> and smallminded.

[23:14] <TimToady> there are hobgobliny things that are neither foolish nor smallminded :)

[23:15] <pmichaud> masak: might mention that the way to find a winner in an array is via .grep

[23:15] <pmichaud> or even .first

[23:15] <TimToady> lichtkind: perhaps more to the point, I don't remember

[23:15] <masak> TimToady: http://www.ratebeer.com/beer/wychwood-hobgoblin-cask/44542/ , for example :)

[23:15] <masak> pmichaud: good idea.

[23:15] <pmichaud>     @contestants.first($winner)    # returns the first $winner

[23:15] * masak adds that

[23:16] <pmichaud> @contestants.grep($winner)   # returns all of the winners

[23:16] <TimToady> @contestants.grep($winner).head

[23:17] <pmichaud> we want to decapitate the winner?   <shudder>

[23:17] <TimToady> isn't that how you create hobgoblins?

[23:17] <pmichaud> consistently, yes.

[23:17] <TimToady> Sleepy Hollow, and all that

[23:17] <masak> no wonder they have small minds.

[23:19] <masak> pmichaud: .grep is a forwards reference, but I like it so much I'm going to put it in there anyway.

[23:19] <TimToady> it's not like most of these folks won't have seen grep

[23:20] <TimToady> though anymore it's misnamed

[23:20] <TimToady> should be .gap, for generalized ACCEPT pattern, or some such

[23:21] <TimToady> ah well, "regular expressions" were never so irregular..

[23:21] <masak> TimToady: my target group is 12..15-year-old beginners interested in programming.

[23:22] <pmichaud> masak: meaning they're likely to have known about grep for 11..14 years :-P

[23:22] <TimToady> what? kid friendly?

[23:22] <masak> :P

[23:22] <daniel-s> rakudo: (1..6).roll;

[23:22] <masak> 'night, #perl6.

[23:22] <p6eval> rakudo 248244:  ( no output )

[23:22] <pmichaud> masak is writing @tutorials>>.vet  :-P

[23:22] <pmichaud> "safe for children"

[23:22] <daniel-s> rakudo: say (1..6).roll;

[23:23] <p6eval> rakudo 248244: OUTPUT«5␤»

[23:23] *** masak left
[23:23] <TimToady> next thing you know you'll be talking about butterflies and candy

[23:23] <daniel-s> rakudo: say (1..6).roll;

[23:23] <p6eval> rakudo 248244: OUTPUT«2␤»

[23:23] <daniel-s> rakudo: say (1..6).pick;

[23:23] <p6eval> rakudo 248244: OUTPUT«3␤»

[23:23] <daniel-s> are .roll and .pick the same thing?

[23:24] <TimToady> at that point yes

[23:24] <TimToady> however

[23:24] <TimToady> try .roll(20)

[23:25] <TimToady> rakudo: say (1..6).roll(20)

[23:25] <p6eval> rakudo 248244: OUTPUT«24246265414665513516␤»

[23:25] <TimToady> rakudo: say (1..6).pick(20)

[23:25] <daniel-s> rakudo: $_ = (1..100); say .roll(20);

[23:25] <p6eval> rakudo 248244: OUTPUT«541263␤»

[23:25] <p6eval> rakudo 248244: OUTPUT«14923260415897101919012146804497876735␤»

[23:25] <daniel-s> rakudo: say (1..6).pick(20)

[23:25] <p6eval> rakudo 248244: OUTPUT«134625␤»

[23:26] <TimToady> roll used to be pick(:replace)

[23:26] <daniel-s> pick selects things one time only?

[23:26] <TimToady> yes

[23:26] <TimToady> "pick rocks out of a bag" metaphor

[23:27] <lichtkind> TimToady: my question is how foreces changed that drive the spec over the year, it seems to me that forst there were the ideas what we need, and its more and more practical things now

[23:27] <lichtkind> i know roll

[23:27] <TimToady> I don't remember that sort of thing

[23:27] <lichtkind> i just spend some time in the spec diffs to update the tablet index

[23:28] <TimToady> in particular because the design process in my head is largely unconscious to begin with

[23:29] <lichtkind> TimToady: so evil forces could whisper into your head and you wouldn't even otice?

[23:29] <TimToady> and I have a hard enough time remembering the future that I tend not to remember the past.

[23:29] <lichtkind> notice

[23:29] <TimToady> evil forces whisper in my head continuously; remember my theology is about Original Sin. :)

[23:30] <TimToady> bbl &

[23:30] <lichtkind> TimToady: in my understanding christian theologeans made their own ideas about jewish concepts on that matter :)

[23:31] <lichtkind> have fun :)

[23:34] <lichtkind> its a real blessing to have those diffs on git hub for my work

[23:41] <sorear> I wander off for <2 hours and *so much*...

[23:42] <sorear> TimToady: Currently, .Bool once, then intimate knowledge.  Changing it to .Bool until fixed point is on my agenda

[23:42] <sorear> TimToady: I don't think using Int instead helps with circularity.  1.Int.Int.Int.Int.Int... doesn't give you a decide-able value

[23:44] <sorear> TimToady: I still don't really follow the logic of stores to native types.  Is it intended to be a completely ad-hoc coercion process?  bool(Any) calls .Bool then stashes the native booleyness

[23:47] <sorear> How do object hashes ...hash?

[23:54] <flussence> well, you could .perl them then md5-hash that string... :) /me ducks

