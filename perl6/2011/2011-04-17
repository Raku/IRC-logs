[00:05] *** Transformer joined
[00:06] *** Transformer left
[00:34] *** woosley joined
[00:47] *** Alias_ joined
[00:49] *** Alias left
[00:50] *** kensanata left
[01:03] *** am0c joined
[01:34] *** [Coke] left
[01:35] *** Bucciarati left
[01:36] *** [Coke] joined
[01:42] *** Chillance left
[01:50] *** [Coke] left
[01:52] *** [Coke] joined
[02:05] *** [Coke] left
[02:06] *** [Coke] joined
[02:07] *** Bucciarati joined
[02:11] *** Bucciarati left
[02:16] *** [Coke] left
[02:18] *** [Coke] joined
[02:19] *** sftp left
[02:19] *** sftp joined
[02:25] *** [Coke] left
[02:26] *** Bucciarati joined
[02:27] *** [Coke] joined
[02:31] *** estrabd left
[02:31] *** [Coke] left
[02:33] *** [Coke] joined
[02:33] *** estrabd joined
[02:34] *** nymacro joined
[02:37] *** Bucciarati left
[02:46] *** Bucciarati joined
[02:47] *** alester joined
[02:56] *** Bucciarati left
[03:00] *** Bucciarati joined
[03:01] *** skyheights joined
[03:02] * skyheights was happy to see all the activity on #perl6 yesterday

[03:02] *** skyheights left
[03:06] * TimToady too

[03:06] *** JimmyZ left
[03:12] *** Juerd left
[03:13] *** PerlJam left
[03:13] *** Util left
[03:13] *** Util joined
[03:13] *** Juerd joined
[03:13] *** hatseflats left
[03:14] *** PerlJam joined
[03:14] *** hatseflats joined
[03:18] *** JimmyZ joined
[03:29] *** am0c left
[03:32] *** hudnix left
[03:32] *** [Coke] left
[03:34] *** [Coke] joined
[03:48] *** [Coke] left
[03:49] *** araujo left
[03:50] *** envi joined
[03:50] *** [Coke] joined
[03:56] *** orafu left
[03:56] *** orafu joined
[04:02] *** [Coke] left
[04:03] *** JimmyZ left
[04:03] *** [Coke] joined
[04:13] *** [Coke] left
[04:15] *** [Coke] joined
[04:22] *** [Coke] left
[04:24] *** [Coke] joined
[04:44] *** alester left
[05:34] <TiMBuS> http://www.winestockwebdesign.com/Essays/Lisp_Curse.html i dont get it

[05:35] <TiMBuS> doing things in lisp is so easy that nothing gets done ?

[05:35] * TiMBuS looks at cpan

[05:35] <TiMBuS> so, perl is.. hard?

[06:04] *** gente joined
[06:04] *** gente left
[06:08] *** woosley left
[06:09] *** woosley joined
[06:15] <s1n> TiMBuS: that guy is a goon, proof:

[06:15] <s1n> "Endgame: A random old-time Lisp hacker's collection of macros will add up to an undocumented, unportable, bug-ridden implementation of 80% of Haskell because Lisp is more powerful than Haskell."

[06:19] *** woosley left
[06:40] *** envi left
[06:44] *** envi joined
[06:56] *** araujo joined
[07:00] <dalek> sprixel: d7e7c61 | diakopter++ | / (11 files):

[07:00] <dalek> sprixel: some cursor work and a bit of non-basic-block-detecting optimization of simple variables that aren't captured, making them CIL locals.  meh.

[07:00] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/d7e7c61fc5

[07:01] *** justatheory left
[07:01] <sorear> diakopter: interesting-sounding

[07:02] <diakopter> ish

[07:03] *** dju__ joined
[07:03] <diakopter> it needs a full basic-block pass or two

[07:05] <diakopter> perlesque: my $x = 2_000_000_000; 1 while --$x; # shouldn't time out (any longer; it used to)

[07:05] <p6eval> perlesque:  ( no output )

[07:06] <diakopter> my desktop pc is a lot faster than p6eval

[07:06] *** dju_ left
[07:09] <diakopter> sorear: i guess it's fully effective if all the computation heavy basic blocks were manually separated out by the programmer

[07:09] <diakopter> well, sorta

[07:10] <diakopter> out&

[07:20] *** Tedd1 left
[07:26] *** Tedd1 joined
[07:30] *** _jaldhar left
[07:31] *** _jaldhar joined
[07:45] *** daxim joined
[07:55] *** molaf joined
[07:56] *** donri joined
[08:36] *** plobsing left
[08:41] *** plobsing joined
[08:42] <ncow> ok, I understand what people have said earlier about the long compile times for rakudo, I really do. The machine in question is a PIII with 256 mb ram, so no exactly top of the line. It can usually build Perl 5 from source, for instance, in around 30 min. So far, building rakudo for the first time, it's been over 30 hours. Honestly, this is getting ridiculous. I really can't remember anything taking so long to compile on this machine. I could have built ha

[08:43] <ncow> I'm not trying to critize rakudo or perl 6, but anything that takes more then a day to compile is difficult, imho, to want to invest a lot of time into, despite the fact that I want to finally check this out (and I still want to, assuming it ever finishes compiling)

[08:44] *** Axius joined
[08:45] <frettled> ncow: you need to load splitlong.pl, your first statement stopped at «I could have built ha»

[08:45] <ncow> I'm trying really hard, and I've built pretty much everything there is from source under Linux, and I really can't recall anything taking more than 30 min to build (other than Linux 2.6 kernel, which usually takes 3-4 hours max to finish building both the kernel and modules)

[08:47] <ncow> frettled: I'm not sure I understand? Are my lines coming as truncated to you? I'm fairly certain my lines are maxing out at a normal length?

[08:47] <frettled> In 1994, building X took more than 24 hours on a SparcStation 2, which was closer to state-of-the-art than your now ancient hardware.  When Mozilla (the web browser-mail client-news client) arrived on the scene, the source was around 1 GB, and also took more than 24 hours to compile.

[08:47] <frettled> ncow: Yes, they do come as truncated, if they're too long.  Use splitlong.pl.

[08:47] <ncow> frettled: are you sure? the hardware I'm building on was new in 2003, nearly 10 years /later/

[08:48] <ncow> so how could my hardware be ancient compared to 1994 hardware

[08:49] <frettled> ncow: it's ancient _today_.

[08:49] <frettled> ncow: building these programs I spoke of took ages on more-current hardware than your hardware is current today

[08:49] <ncow> frettled: I honestly think that it's your irc client that is truncated. I can clearly see my lines coming from the server on my other client and it looks fine

[08:49] <frettled> ncow: while that hardware was merely 1-3 years old at the time, yours is 8 years old.

[08:49] <frettled> ncow: No, it's not my IRC client.  It's how IRC works.  Trust me on this.

[08:50] <frettled> ncow: Load splitlong.pl.  Guess why it's even needed...

[08:50] <ncow> frettled: why do I see the full likes in /another/ client then

[08:50] <frettled> That your client prints what you type is just how it is, and always have been.

[08:50] <frettled> ncow: it was only the ONE statement that was truncated, the others were not.

[08:51] <moritz> ncow: http://irclog.perlgeek.de/perl6/2011-04-17#i_3526308

[08:51] <ncow> I'm not talking about /this/ client's local echoing, I'm talking about another client (on my phone) that I can see all the lines (including the one you meantioned) in full, which is why I believe it's your client doing that, as it's clearly not the server doing it

[08:51] <frettled> ncow: The IRC protocol does not support more than 512 8-bit characters on a single line.

[08:52] <ncow> frettled: not every server strictly adheres to the RFCs

[08:52] <ncow> s/servers/daemon software/

[08:52] <frettled> ncow: /script load splitlong.pl

[08:52] <frettled> just do it

[08:52] <moritz> ncow: back to the original topic... what do you actually want?

[08:52] <frettled> ncow: Yes, and sending lines more than 512 chars is in violation of the protocol, which is why you must split those lines.

[08:53] <huf> so it doesnt even get cut off at the same length for all servers on freenode? _nice_

[08:53] <ncow> and where exactly am I supposed to get this script from? You seem to be assuming you even know what client I'm on right now

[08:53] <frettled> ncow: Yes, I did a /ctcp ncow version, and got the response that you're using irssi.

[08:53] <moritz> ncow: we know that the compilation time is less than awesome, and there's work under way to fix it

[08:53] <ncow> huf: apparently

[08:54] <huf> good work irc, just like when you specified the encoding of the messages properly...

[08:54] <ncow> "/script load splitlong.pl" gives me unknown command

[08:54] <huf> just dont write long lines then

[08:54] <huf> or do, and expect them to be cut off and play this "fun" game every time

[08:54] <ncow> I usually try not to, and to be honest, I didn't think my lines were all that long

[08:54] <huf> this is why we load splitlong ;)

[08:55] <ncow> I get that. I'm still wondering why I can see the full lines on my phone that I sent from my laptop

[08:55] <ncow> oh well

[08:55] <ncow> I'm off to bed, sorry for any trouble

[08:55] <frettled> ncow: okay, you've probably not installed scriptassist, then.  Please follow the instructions here instead: https://bugs.launchpad.net/ubuntu/+source/irssi-text/+bug/60098/comments/3

[08:56] <ncow> ok, noted

[08:56] <frettled> ncow: don't fret about it :)

[09:00] <tadzik> ncow: pardon me, but didn't you complain about exactly the same thing yesterday?

[09:01] <moritz> tadzik: which is why I asked what exactly he wanted. I didn't get any reply

[09:01] <tadzik> I think that question was already answered

[09:02] <moritz> seems that line-length-in-IRC discussions are more interesting

[09:03] <frettled> Anyway, I think it's hard to solve long compile times on eight year old hardware with a low amount of RAM - 256 MB isn't much, it wasn't much eight years ago, either (1024 seemed pretty common then), so it's not unreasonable to expect trashing because of low memory.  However, as moritz++ noted, Rakudo does take a rather long time to compile even on more current hardware with plenty of RAM, even though it's just a matter of tens of minutes rather ...

[09:03] <frettled> ... than tens of hours.

[09:03] <frettled> (w00t, splitlong.pl in action)

[09:04] <sbp> hitting enter more often works too :-)

[09:04] <frettled> Hmm, I haven't tried compiling Rakudo on my new-ish Mac Mini, which has an SSD.

[09:04] <frettled> sbp: that looks too much like work ;)

[09:04] * moritz doesn't think rakudo compilation is CPU bound, except when swapping :-)

[09:04] * frettled spends a lot of time and energy being lazy.  Works well with being a sysadmin - laziness (automation) is _good_.

[09:05] <sbp> could be a good slogan for perl6!

[09:05] <moritz> .u ellipsis

[09:05] <phenny> U+0EAF LAO ELLIPSIS (ຯ)

[09:05] <sbp> "Automated laziness."

[09:05] <moritz> .u horizontal ellipsis

[09:05] <phenny> U+2026 HORIZONTAL ELLIPSIS (…)

[09:05] <moritz> something to teach splitlong.pl to use :-)

[09:05] <frettled> perl Configure.pl --gen-parrot for Rakudo Star 2011.01: Around 2.5 minutes on a shared-time computer with a 2.4 GHz CPU and 8 GiB RAM.

[09:06] * frettled is now running make -j8 :)

[09:07] <frettled> moritz: not compatible with US-ASCII and Latin-1, but perhaps splitlong.pl could check irssi's configuration regarding UTF-8-ness.

[09:07] <huf> ascii and latin1 can go where the sun dont shine

[09:07] <frettled> sbp: nice slogan :)

[09:07] <tadzik> isn't jnthn's work on lexical-settings going to help Rakudo too?

[09:08] *** mj41 joined
[09:08] <frettled> 27416 jani      20   0  321m 261m 8504 R  100  3.3   1:17.38 parrot              

[09:09] <frettled> Hah, I remembered correctly regarding memory usage.  :D

[09:09] <frettled> This is on an x86_64 computer, though, so memory usage is higher than it would be on x86_32.

[09:09] <frettled> It's still climbing, around 400 MiB virtual now.

[09:10] <frettled> I recall that we had some problem reports last year about computers running out of memory while running Parrot to make Rakudo, tee-hee.

[09:11] <frettled> And there it broke the 512 MiB resident barrier.

[09:11] <frettled> Warp 1?

[09:12] *** Axius left
[09:13] <jnthn> morning o/

[09:14] *** masak joined
[09:14] <masak> oh hai, zebras!

[09:16] <jnthn> hah, I beat masak to proving my awakeness by 1 minute :P

[09:16] <frettled> Pandas.  We're pandas.

[09:16] <frettled> jnthn: \o/

[09:16] <masak> frettled++ # preserving our image

[09:16] <jnthn> You make it seem to black and white...

[09:17] <jnthn> *so

[09:17] * frettled munches on some bamboo sprigs.

[09:17] * jnthn considers a bacon sarnie

[09:17] <masak> frettled: you realize that you're not a *real* panda until you have the panda badge on modules.perl6.org? :)

[09:17] <frettled> masak: uhoh

[09:18] <frettled> Perhaps I'll lay off the bamboo sprigs until I know my stomach can handle it, then.  D

[09:19] <masak> waking up, I had this idea about attribute initialization and BUILD and all that stuff.

[09:19] <masak> I haven't thought it through since that half-asleep state, but I'd like to hear what you think about it :)

[09:20] <frettled> Is it coherent?  :D

[09:20] <masak> think so.

[09:20] <masak> basically, we ditch the restriction of "you can't access $!foo because this is a type object, sonny".

[09:21] <frettled> Hmm, building Rakudo Star 2011.01 took less than 15 minutes on less-than-current hardware.  I'll be darned yellow, that's less than I recall it was for the 2010 editions.

[09:21] <masak> when we see an assignment 'has $!foo = "OH HAI";', we do that assignment at class construction time, to the type object.

[09:21] <jnthn> wait, what?

[09:21] <masak> not a good idea? :)

[09:22] <jnthn> Well, type objects are "empty instances".

[09:22] <jnthn> It's the lack of storage that makes them undefined.

[09:22] <arnsholt> frettled: IIRC there have been a number of Parrot performance improvements in the last year or so

[09:22] <masak> no, it's being undefined that makes them undefined.

[09:23] <jnthn> And how do we decide that it's undefined?

[09:23] <frettled> arnsholt: yes, I recall some of the chatting about it.

[09:23] <jnthn> Anyway, doing it at class construction time is hard.

[09:23] <frettled> arnsholt: funnily enough, this hardware is just over four years old :)

[09:24] <jnthn> We don't have all the attributes yet, and maybe not all the parents. We need to know to compute a storage approach for, e.g. P6opaque.

[09:24] <jnthn> And we can't do that until after class composition.

[09:24] <jnthn> So in that case the type object really *doesn't* get allocated with anywhere to store the attributes.

[09:25] <jnthn> I'm guessing where you're going is "and then we just clone the type object to make an instance", though :)

[09:26] <frettled> jnthn: I'm just waiting to hear why that is bad as well :)

[09:26] <jnthn> It'd work in the case masak++ suggested

[09:26] <jnthn> But for has $.c = $.a + $.b;

[09:27] <jnthn> It's rather more problematic, as you want to do some evaluation there each time.

[09:28] <frettled> Hmm, I thought $! and $. were disjunct.

[09:28] <jnthn> Well, I coulda written has $!c = $!a + $!b; as well :)

[09:28] *** hanekomu joined
[09:28] <frettled> (:

[09:29] <jnthn> (Also, has $!a = foo(); has the issue that foo() might to be defined by class construction time...it may be post declared.)

[09:30] <mberends> ncow: US$2.50 should get you 1GB RAM to massively upgrade your computer: http://us.webuy.com/product.php?sku=SMEMM8DHD

[09:32] <masak> as I said, it's just an idea, and I was curious where it would lead us; if it solves any problems, etc.

[09:32] <masak> yesterday I was creating a bunch of small classes just for giving names to things.

[09:33] <masak> they looked like this: 'class OpType::Comma is OpType { method tightness { 2 } };'

[09:33] <masak> my first instinct was to write it as 'class OpType::Comma is OpType { has $.tighness = 2 }'

[09:34] <masak> but I realized I would only be using these classes as type objects, never as instances. so that idea was out. :/

[09:34] <frettled> Isn't declaring tightness as a constant very restricting?

[09:34] <masak> frettled: I was basically after a way to assign a constant to the type.

[09:35] <masak> so that I can later do 'if $op1.tightness < $op2.tightness { ... }'

[09:35] <jnthn> std: class Foo { constant $.bar = 2; }

[09:35] <p6eval> std 4608239: OUTPUT«ok 00:01 121m␤»

[09:35] <masak> ah, that would be it.

[09:35] <jnthn> Doesn't need an attribute, should be able to just have a constant and a method to access it :)

[09:36] <jnthn> Granted Rakudo almost certainly doesn't yet handle that.

[09:36] <masak> jnthn++

[09:36] <jnthn> :(

[09:36] <masak> no, rakudo doesn't handle 'constant'. alpha might've.

[09:36] <jnthn> Well

[09:36] <jnthn> I think it "handled" it. :)

[09:36] <masak> jnthn: but that's not your fault :) it's everybody's "fault" :)

[09:37] <jnthn> Part of what I've been doing in nqp/ctmo is letting us have a much more proper implementation of constant :)

[09:37] <frettled> masak: Ah, I think I see what you're getting at now.

[09:37] <masak> \o/

[09:38] <masak> jnthn: right.

[09:42] *** woosley joined
[09:48] <masak> rakudo: class C {}; use Test; is_deeply C.new, C.new, "the are alike"

[09:48] <p6eval> rakudo 5ac05e: OUTPUT«not ok 1 - the are alike␤#      got: C.new()␤# expected: C.new()␤»

[09:48] <masak> s/the/they/

[09:48] <masak> anything we can do about that? or would that just be overkill?

[09:52] <jnthn> Well, the fallback could be "are they exactly the same type, and if so, do they deeply have the same attributes"

[09:52] <masak> that's what I'm thinking.

[09:52] <masak> oh well, I'll just write an adapter this time.

[09:52] <masak> turning the objects into hashes.

[09:54] <jnthn> .Capture.hash will pretty much do that for you, btw :)

[09:54] <masak> even for private attributes?

[09:55] *** icwiener joined
[09:55] <jnthn> ah, good question

[09:55] <jnthn> forget offhand

[09:56] <masak> rakudo: class C { has $!a }; say C.new(:a(42)).Capture.hash.perl

[09:56] <p6eval> rakudo 5ac05e: OUTPUT«{}␤»

[09:56] *** zby_home_ joined
[09:56] <masak> rakudo: class C { has $.a }; say C.new(:a(42)).Capture.hash.perl

[09:56] <p6eval> rakudo 5ac05e: OUTPUT«{"a" => 42}␤»

[09:56] <masak> jnthn++

[09:56] <masak> and, phew. :)

[09:57] <masak> rakudo: class C { has $!a; method a { $!a } }; say C.new(:a(42)).Capture.hash.perl

[09:57] <p6eval> rakudo 5ac05e: OUTPUT«{}␤»

[09:57] <masak> hm...

[09:58] <jnthn> It'll go by .has_accessor on the meta-attribute.

[09:59] <masak> nod.

[10:04] *** MayDaniel joined
[10:07] <masak> rakudo: given 42 { when SomeUndeclaredTyp { say "OH HAI" }; default { say "OH NOES" } }

[10:07] <p6eval> rakudo 5ac05e: OUTPUT«===SORRY!===␤Missing block at line 22, near "; default "␤»

[10:07] <masak> er, s/Typ/Type/

[10:08] <masak> std: given 42 { when SomeUndeclaredTyp { say "OH HAI" }; default { say "OH NOES" } }

[10:08] <p6eval> std 4608239: OUTPUT«===SORRY!===␤Function 'SomeUndeclaredTyp' needs parens to avoid gobbling block at /tmp/ggW4TXS4y1 line 1:␤------> given 42 { when SomeUndeclaredTyp⏏ { say "OH HAI" }; default { say "OH NOE␤Missing block (apparently gobbled by

[10:08] <p6eval> ..'SomeUndeclaredTyp'…

[10:08] <masak> I like STD's error messages much better here.

[10:08] * masak submits rakudobug

[10:13] *** MayDaniel left
[10:13] <jnthn> Hmm, may not be too hard to add a basic version of that

[10:13] <masak> rakudo: role A { our sub foo { say "OH HAI" } }; A::foo

[10:13] <p6eval> rakudo 5ac05e: OUTPUT«Cannot find sub A::foo␤  in main program body at line 1␤»

[10:13] <masak> jnthn: should that work?

[10:14] <jnthn> mumble

[10:14] * masak submits rakudobug

[10:14] <jnthn> :)

[10:14] <jnthn> I don't know, tbh.

[10:14] <jnthn> I can argue it both ways.

[10:14] <masak> me too.

[10:14] <masak> but I wrote it by accident, and now that I'm thinking about it, it doesn't seem so odd.

[10:14] <jnthn> role A { our sub foo { say $?CLASS } } # ouch :)

[10:15] <masak> well, yeah. but there will always be edge cases.

[10:15] <jnthn> True

[10:15] <frettled> masak: cutting edge cases, even :)

[10:15] <masak> I can distinguish methods using the $obj.A::foo syntax, so why not subs using just A::foo?

[10:16] <masak> frettled: that's why they're double-edged swords? :P

[10:16] <jnthn> rakudo: sub foo($x) { our sub bar() { say $x; } }; bar()

[10:16] <p6eval> rakudo 5ac05e: OUTPUT«Null PMC access in type()␤  in 'bar' at line 22:/tmp/5gk1BaNW3F␤  in main program body at line 22:/tmp/5gk1BaNW3F␤»

[10:16] <jnthn> It's basically this :)

[10:17] <frettled> masak: or used as razors by Mr. Occam?

[10:17] <jnthn> std: sub foo($x) { our sub bar() { say $x; } }; bar()

[10:17] <p6eval> std 4608239: OUTPUT«Potential difficulties:␤  &bar is declared but not used at /tmp/GLTX5X17cG line 1:␤------> sub foo($x) { our sub bar⏏() { say $x; } }; bar()␤ok 00:01 122m␤»

[10:17] <jnthn> Interesting. :)

[10:17] <masak> I know STD is a bit wrong in that area.

[10:18] <masak> so take that with a granum of salus.

[10:18] <jnthn> It complained about &bar not being used, but not about bar() not being defined.

[10:23] <masak> this is untenable. the sun is shining, and I haven't had my run this weekend.

[10:23] <masak> as lue++ would've said: "curse you, nice weather!"

[10:23] <frettled> See masak run.

[10:24] *** satyavvd joined
[10:26] *** satyavvd_ joined
[10:27] *** awoodland joined
[10:28] *** satyavvd left
[10:34] *** sftp_ joined
[10:34] *** sftp left
[10:38] *** awoodland left
[10:50] *** whiteknight joined
[10:52] *** satyavvd_ left
[11:07] *** dayangkun_ joined
[11:12] *** Chillance joined
[11:13] <dalek> errors: 62aa2c5 | moritz++ | notes.pod:

[11:13] <dalek> errors: Exception isa Capture

[11:13] <dalek> errors: review: https://github.com/perl6/errors/commit/62aa2c54ae

[11:30] <masak> Capture: Function call arguments (right-hand side of a binding)

[11:30] <masak> moritz: is this so that you'll be able to match Signatures against Exceptions?

[11:32] <masak> um... we're overloading $0 etc for exceptions?

[11:32] <masak> that feels... odd.

[11:34] <masak> moritz: I'd have expected the uniquely identifying part of an exception to be the type object of the Exception (a subtype of X:: or whatever).

[11:34] <masak> moritz: why use strings or integers when we have a type system?

[11:39] <moritz> masak: because I don't want to force people to create a new type for every possible error

[11:39] <moritz> masak: note that you can still create enums of errors, and stick them in as IDs

[11:40] <moritz> this is not java after all :-)

[11:40] <masak> I'm not saying it's Java.

[11:41] <masak> I am saying, however, that I looked forward to the interaction between smartmatching on X:: types and inheritance.

[11:41] <masak> I think the long-term benefits of that should be at least considered.

[11:42] <moritz> you can create X:: enums, and smartmatch .[0] against them

[11:43] <moritz> you can also subclass yourself, or compose roles into your own exception objects

[11:43] <moritz> they are just objects after all

[11:44] *** icwiener left
[11:49] <masak> I'm thinking of the use case "catch any numeric exception" or "catch any I/O exception".

[11:53] <moritz> masak: would you be happier with coarse grained types and carrying finer grades of information via the capture elements?

[11:54] *** Patterner left
[11:56] *** Psyche^ joined
[11:56] *** Psyche^ is now known as Patterner

[11:59] <masak> moritz: at this point, it's not so much about happiness. I just want to make sure we don't put a poor man's type system in place where we could have had... our type system.

[12:01] <masak> I already know 'when' clauses work very well with types.

[12:01] *** arnsholt left
[12:01] <moritz> 'when' clauses work well with everything that smart-matches

[12:02] <masak> yes, but you know what I mean. when I use a type, I have exactly one word, and I write that. 'when SomeType'.

[12:02] <masak> if you want to talk about happiness, handling exceptions that way would make me happy. :)

[12:03] <moritz> I see what you mean, but I have some reservations

[12:03] <moritz> those include: I don't want to define a huge number of empty classes or roles solely for classification. That just feels wrong.

[12:04] <moritz> if those types are composed at runtime on demand, that itself can lead to further errors

[12:05] <masak> could you give a concrete example?

[12:05] <moritz> methods can clash when composing multiple roles

[12:09] <moritz> or does that only happen at compile time?

[12:09] <jnthn> Depends.

[12:09] <jnthn> If you mix them in one by one, no clash.

[12:09] <jnthn> If you do like $foo does (Bar, Baz, WTF)

[12:10] <jnthn> Then you could get a conflict.

[12:10] <jnthn> Note that if matching against signatures is important, that mostly involves defining .Capture to do whatever sort of mapping from the exception object you wish

[12:10] <jnthn> It doesn't have to be a capture

[12:11] <jnthn> $foo ~~ :(...) will, as a fallback if none of the other smartmatching cases match, do a capture coercion.

[12:14] *** dayangkun_ left
[12:19] <masak> the "conflict" you get with '$foo does (Bar, Baz, WTF)' isn't an error; it's just later methods applied winning.

[12:19] <jnthn> No

[12:20] <jnthn> $foo does (Bar, Baz, WTF) is "derive an anonymous subclass, and .^add_role each of them, then compose it"

[12:21] <jnthn> (See S14)

[12:21] <jnthn> It's different from

[12:21] <jnthn> (($foo does Bar) does Baz) does WTF

[12:24] <masak> ah.

[12:24] <masak> I sit corrected.

[12:29] <jnthn> The semantics you want are available, just not with the syntax you mentioned. :)

[12:33] <masak> right.

[12:34] *** Chillance left
[12:36] <jnthn> stroll &

[12:41] *** arnsholt joined
[12:57] <masak> hunting for food &

[13:05] *** arnsholt left
[13:17] *** MayDaniel joined
[13:27] *** MayDaniel left
[13:32] *** yegor left
[13:35] *** pmurias joined
[13:40] <jnthn> Hunting? Gee, I normally just go to the supermarket these days...

[13:41] *** alester joined
[13:47] *** yarp joined
[14:03] *** yegor joined
[14:08] *** hudnix joined
[14:09] *** arnsholt joined
[14:39] *** uniejo left
[14:41] *** yarp left
[14:46] <TimToady> it seems that std: isn't updating, 'cuz I fixed this several weeks ago

[14:46] <TimToady> std: sub foo($x) { our sub bar() { say $x; } }; bar()

[14:46] <p6eval> std 4608239: OUTPUT«Potential difficulties:␤  &bar is declared but not used at /tmp/c4_DUQ3F35 line 1:␤------> sub foo($x) { our sub bar⏏() { say $x; } }; bar()␤ok 00:01 122m␤»

[14:47] *** Chillance joined
[14:49] *** yegor left
[14:49] <TimToady> and I think roles are the right approach to use on exception classifications

[14:50] <TimToady> if you compose at compile time, you'll get conflicts at compile time

[14:50] *** yegor joined
[14:51] <TimToady> and that's exactly what roles are for, inheritance without hierarchy

[14:52] <TimToady> we can also ensure that if an error occcurs while creating exceptions, we capture all the data raw and don't thrown any info away

[14:53] <TimToady> "Panic: here's everything I know: ..."

[14:53] <TimToady> s/ensure/try to ensure/  :)

[14:54] *** MayDaniel joined
[14:54] <TimToady> bbl &

[14:55] *** yegor left
[14:59] *** colomon left
[15:01] *** MayDaniel left
[15:04] *** colomon joined
[15:07] *** pmurias_ joined
[15:07] *** pmurias_ left
[15:07] *** yegor joined
[15:11] *** kaare_ joined
[15:19] *** sivoais left
[15:24] *** jaffa4 joined
[15:38] *** justatheory joined
[15:44] *** woosley left
[15:50] *** [Coke] left
[15:51] <masak> \o/ # roles/inheritance for exceptions

[15:51] *** [Coke] joined
[15:52] *** daxim left
[15:54] *** hanekomu left
[16:13] *** envi left
[16:15] <masak> is there a list equivalent of .join?

[16:15] <masak> i.e. input a list, output the same list but with one or more items intersprixeled in between each original element.

[16:16] <masak> rakudo: say (1..5 Z "foo", *).perl

[16:16] <jnthn> Zip?

[16:16] <p6eval> rakudo 5ac05e: OUTPUT«(1, "foo", 2, "foo", 3, "foo", 4, "foo", 5, "foo")␤»

[16:16] <masak> not quite.

[16:16] <masak> I don't want the fencepost at the end.

[16:17] <masak> oh well.

[16:17] <masak> I'll just write it out as an explanatory for loop :)

[16:18] <frettled> TimToady++: oooh, nice clarifying explanation

[16:20] *** alester left
[16:21] *** icwiener joined
[16:21] <masak> for @original { push @new, $_, "foo"; LAST { pop @new } }

[16:21] <masak> is quite nice.

[16:26] <sorear> good * #perl6

[16:27] <moritz> hello sorear

[16:27] *** hanekomu joined
[16:27] <dalek> niecza: 11b04b4 | pmurias++ | hoopl/ (2 files):

[16:27] <pmurias> sorear: hi

[16:27] <dalek> niecza: [hoopl] refactoring

[16:27] <dalek> niecza: review: https://github.com/sorear/niecza/commit/11b04b41ea

[16:28] <jnthn> o/ sorear 

[16:28] * jnthn ponders what he's gonna do for dinner :)

[16:28] * moritz just had a lovely, self-made pizza

[16:28] <jnthn> ooh :)

[16:29] * frettled is eating two oven-baked fillets of trout with a lemon-mango marinade, plus a mash of cooked vegetables (carrots, sweet potato, etc.).

[16:30] <jnthn> Eww, fish. :P]

[16:30] <frettled> ghoti!

[16:30] <jnthn> :D

[16:30] *** hanekomu left
[16:33] <sorear> ncow: ping

[16:35] * masak is getting ready to cook a lentil dal with whole cinnamon, cardamom, and cloves

[16:36] <masak> perl6: my @foo; pop @foo; say "alive"

[16:36] <p6eval> niecza v4-66-g11b04b4: OUTPUT«Unhandled exception: System.IndexOutOfRangeException: Array index is out of range.␤  at Niecza.VarDeque.Pop () [0x00000] in <filename unknown>:0 ␤  at CORE.C264_List_2Epop_2Ditem (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.RunCore

[16:36] <p6eval> ..(Niecza.Frame& cur) [0x00…

[16:36] <p6eval> ..pugs, rakudo 5ac05e: OUTPUT«alive␤»

[16:36] <masak> sorear: ^

[16:38] <jaffa4> is there pack

[16:38] <jaffa4> unpack

[16:38] <jaffa4> in Perl 6?

[16:38] <masak> jaffa4: yes.

[16:38] <moritz> jaffa4: you should know by know where the specs are, and how you can search them

[16:38] <moritz> s:2nd/know/now/

[16:38] <jaffa4> In what language it implemented?

[16:38] <masak> jaffa4: and I started implementing them last summer, but they're big, so I only got started.

[16:38] <masak> jaffa4: they're in the setting, so they're in Perl 6.

[16:39] <jaffa4> Is it implemented?

[16:39] <masak> jaffa4: partly.

[16:39] <masak> not too much, actually.

[16:39] <masak> patches are welcome.

[16:39] <jaffa4> have your though about convert perl5 functions into perl6?

[16:40] <masak> see https://github.com/rakudo/rakudo/blob/master/src/core/Buf.pm#L40 for the implementation of Buf.unpack

[16:40] <masak> jaffa4: yes, I have.

[16:40] <jaffa4> that is how you do it

[16:40] <masak> jaffa4: specifically, I'd like to port the 17k Perl 5 tests for pack/unpack.

[16:40] <jaffa4> ,is that not?

[16:40] <masak> jaffa4: the implementation will likely differ a bit, because Perl 5 doesn't have the concept of Buf.

[16:40] <moritz> perl 5 doesn't separate Str and Buf, which makes it non-trivial

[16:41] <masak> and that has more repercussions that one might first think.

[16:41] <moritz> also perl 5 doesn't have user-facing scalar data types

[16:41] <masak> unpack/pack are full of (conscious) intermixings of string and buf.

[16:41] <moritz> so it doesn't matter if unpack returns '123' or 123 in perl 5

[16:41] <moritz> it does in perl 6

[16:41] <masak> hm, that one never posed that much of a problem.

[16:41] <masak> but yes, it's a difference.

[16:42] <jaffa4> String and buffer?

[16:42] <jaffa4> I do not know the difference myself?

[16:42] <masak> hold on, I have a blog post on that :)

[16:42] *** am0c joined
[16:42] <jaffa4> I do not know the difference myself...

[16:42] <masak> http://strangelyconsistent.org/blog/str-and-buf-i-think-i-get-it-now

[16:42] <masak> jaffa4: ^

[16:44] <jaffa4> By the way, D language makes similar distinctions

[16:45] <jaffa4> When does it make a difference?

[16:45] <jaffa4> Are these going to be two different type?

[16:45] <masak> yes, exactly.

[16:46] <masak> strings are made of characters. bufs are made of bytes.

[16:46] <jaffa4> so string is going to have encoding property I guess

[16:46] <masak> bytes are not characters. bytes *code for* characters.

[16:46] <masak> jaffa4: maybe as an implementation detail, they will.

[16:47] <masak> but when something is a string, that's when it doesn't *need* an encoding property.

[16:47] <masak> because it's already characters.

[16:47] <jaffa4> characters but what characters?

[16:47] <moritz> Unicode characters

[16:47] <moritz> codepoints or graphemes

[16:48] <masak> even that is an implementation detail. though a more important one.

[16:48] <moritz> no, it's really part of the API

[16:48] <masak> TimToady seems to not want us to be entirely tied to Unicode, though.

[16:49] <masak> there are some places on the planet where Unicode is a bad idea.

[16:49] <moritz> if I have a base character and a combining character, does . in regex match them both?

[16:49] <masak> sounds like a question for tchrist :P

[16:49] <moritz> ah, your "even that" was about Unicode, not about graphemes/codepoints, it seems

[16:49] <jaffa4> utf8,16?

[16:50] <jaffa4> 32?

[16:50] <masak> moritz: aye.

[16:50] <masak> jaffa4: preferably all of them.

[16:50] <moritz> jaffa4: those can all encode the same characters, which is that question doesn't matter

[16:50] <masak> jaffa4: that's just a question of how you encode/decode.

[16:50] <masak> jaffa4: but we tend to default to utf8.

[16:55] <jaffa4> ok

[16:59] *** masak left
[16:59] *** masak joined
[17:01] *** pmurias left
[17:03] *** pmurias joined
[17:07] *** knewt2 left
[17:08] <dalek> roast: ea701e8 | moritz++ | S02-builtin_data_types/instants-and-durations.t:

[17:08] <dalek> roast: [instants-and-durations.t] test Durations with integers to avoid occasional test failures due to FP errors

[17:08] <dalek> roast: review: https://github.com/perl6/roast/commit/ea701e84be

[17:08] <moritz> I've meant to do this for ages.

[17:09] <masak> moritz++

[17:18] <tadzik> g'afternoon pandas

[17:19] <masak> tadzik! \o/

[17:24] *** am0c left
[17:25] <moritz> tadzik++ # I for one welcome our new module overpanda :-)

[17:27] <tadzik> overpanda? :)

[17:30] <moritz> a panda-shaped overlord :-)

[17:31] * masak .oO( "...things quickly turned panda-shaped" )

[17:33] <tadzik> I could gain some Panda-weight :0

[17:33] <tadzik> :)

[17:34] <tadzik> thundegnat++!

[17:35] <tadzik> A vice-panda appears! Or even the biggest Panda, he has TWO Panda-badged modules :)

[17:35] <tadzik> still I don't know why does he use - rather than ::

[17:40] *** mj41 left
[17:46] *** birdwindupbird joined
[17:53] *** birdwindupbird left
[18:05] *** Mowah joined
[18:09] *** _jaldhar left
[18:09] *** _jaldhar joined
[18:10] *** SHODAN joined
[18:12] *** Mowah left
[18:14] <tadzik> oh, the lovely "Died". What a strange disturbance of the force: tests pass, program dies

[18:15] <masak> time to write more tests!

[18:15] <masak> (and perhapd not to die without a message from within the application) :)

[18:16] <tadzik> "ha ha ha"

[18:17] <tadzik>         try { $panda.resolve($x) };

[18:17] <tadzik>         say $! if $!;

[18:17] <tadzik> seems to be the problem. Is $! reseted after a successful try {}, and should it?

[18:18] <tadzik> masak: yeah, the main thing that disturbs me is not the fact that I shipped a broken Panda, but the fact that my tests are wrong :)

[18:18] <tadzik> tests do not test panda-the-script after all

[18:22] *** Rotwang joined
[18:26] *** Mowah joined
[18:32] *** [Coke] left
[18:34] *** [Coke] joined
[18:41] *** risou left
[18:41] <tadzik> hmm

[18:42] <tadzik> try { foo() }; $fail = $! is clearly not the same as try { foo(); CATCH { $fail = $! } }. Intentional? Why?

[18:43] *** rgrau joined
[18:45] <moritz> a try { } that didn't catch an exception resets $!

[18:45] <moritz> so that after the try you can ask $! if something went wrong

[18:46] <tadzik> yes

[18:46] <tadzik> the first case resulted in a strange "Died" out of nowhere, the second works

[18:48] <tadzik> rakudo: try { die 'a'; CATCH { die "inside" } }

[18:48] <moritz> that's a know bug

[18:48] <p6eval> rakudo 5ac05e: OUTPUT«(timeout)»

[18:48] <tadzik> just checking if it's still here

[18:59] *** ponbiki joined
[19:01] *** birdwindupbird joined
[19:02] *** birdwindupbird left
[19:03] *** birdwindupbird joined
[19:05] *** Mowah left
[19:06] *** Alias joined
[19:06] *** newguy left
[19:08] *** Alias_ left
[19:09] <tadzik> phenny: tell colomon IO::Prompter's META.info has a missing dep (Testing), mind adding it?

[19:09] <phenny> tadzik: I'll pass that on when colomon is around.

[19:09] <tadzik> phenny: thank you dear

[19:14] *** Mowah joined
[19:15] <tadzik> jnthn | Doesn't emacs have everything? ;)

[19:15] <tadzik>   lue | It has an organizer! \o/

[19:15] <tadzik> jnthn | I bet it even has a girlfriend.

[19:15] <tadzik> we surely need "#perl6quotes", like Parrot has ParrotQuotes on their wiki

[19:16] <jnthn> gee, when'd I say that... :P

[19:18] *** noganex joined
[19:19] *** szr joined
[19:19] *** icwiener left
[19:20] <ncow> ok, it's been over 40 hours and it's still compiling.

[19:20] <cognominal> I know that text has a mate :)

[19:21] <ncow> sweet buttery jesus, what is it in there that could be talking so long?

[19:21] <tadzik> ncow: you're below the system requirements, get over it

[19:21] <ncow> actually from what I've read I seem to be right on the line

[19:21] *** noganex_ left
[19:22] <ncow> nevertheless, I've never had something take so long to compile on this system.

[19:22] <arnsholt> ncow: It's well established that swap thrashing will instantly increase your run-time by many orders of magnitude

[19:22] <frettled> ncow: btw, your hardware is not eight years old, the CPU is at leaste nine years old.  :)  And you have too little RAM (as I said), so your OS is probably trashing.

[19:22] <arnsholt> It sucks, but there not really anything that can be done about it

[19:22] <frettled> except upgrading a little bit

[19:23] <frettled> ncow: I tested on _four_ year old hardware, hardly anything like current, and got Parrot + Rakudo (from Rakudo Star 2011.01) compiled in about 12 minutes.

[19:23] <ncow> yes the HD activity LED indicator is constantly lit uo

[19:23] <ncow> up

[19:24] <ncow> may I ask why it needs so much ram just to first-time compile? Again, I feel forced to compare this experience to everything else I've ever compiled from source on this (or other) machines

[19:24] <frettled> ncow: then I'm afraid to say you cannot have compiled much in terms of recent software.  That something requires more than 200 MB of RAM while compiling is, unfortunately, hardly news.

[19:24] <sorear> ncow: HELLO

[19:25] <ncow> why was this process constructed in such a way that calls for so much ram, that is all I want to know.

[19:25] <sorear> ncow: do you have me on ignore or something?

[19:25] <tadzik> sorear: no, he just asks the same question for the third time

[19:25] <ncow> frettled: I've compiled an awful lot, actually, on this machine alone, as well as countless other set ups, believe me kindly, I'm not stranger to this

[19:25] <ncow> sorear: no, sorry

[19:26] <ncow> sorear: I'm looking back but I don't see anything from you other than these two lines that I see here, if there is something I've missed, I am sorry

[19:28] <ncow> tadzik: I'm not meaning to sound repetative, it's just a little frusterating. It seems this build process is grossly biased towards newer hardware, when 98% of thing that I've build from source on this machine take under 15 minutes, depending on the size of the package. Sometimes even just a couple minutes. I can build an entire tool chain (glibc, gcc, bin-utils) in under 3 hours 

[19:28] <frettled> ncow: even the linux kernel, in less than 15 minutes?!

[19:29] <ncow> It can build Perl 5 in under half an hour. Yet it takes almost two days so far to build.

[19:29] <masak> ncow: your computer is swapping a lot.

[19:29] <ncow> frettled: as I mentioned the other day, that one is an exception. the kernel image + modules usually takes around 4 hours

[19:29] <frettled> ncow: and the problem is that Parrot _does_ require a lot of RAM to do it

[19:29] <ncow> 3 hours*

[19:29] <ncow> frettled: which is still a far cry from 48 hours

[19:29] <frettled> ncow: it's not an exception, I'm afraid, it's rather common for complex software to take both lots of memory while compiling and lots of disk access.

[19:29] <masak> ncow: this would all be solved with more RAM.

[19:30] <ncow> masak: I have no doubt about that

[19:30] <ncow> frettled: I perfectly udnerstand that

[19:30] <ncow> but I still find it difficult to accept that the current process is the most optimal and best all around.

[19:31] <pmurias> it's not

[19:31] <jnthn> ncow: Nobody has set out and *planned* for the build process to take a bunch of RAM. It does because the toolchain it's built upon isn't particularly well optimized yet.

[19:31] <frettled> ncow: nobody has claimed it is

[19:31] <jnthn> Or in some places, at all optimized.

[19:31] <pmurias> but your machine is obsolete

[19:31] <ncow> When I fly back home, I'll be building it on a newer quad core machine with 8 gigs of ram (my own at home) which i'm sure will be monumentally faster

[19:31] <frettled> ncow: in fact, you've gotten explicit acknowledgement that it's suboptimal.

[19:31] <ncow> fair enough

[19:32] <frettled> ncow: if it's a four year old 2.4 GHz box like the one I tested on (in a multi-user setting), expect around 12 minutes :)

[19:32] <masak> neither of us should be blaming the other. it's just that ncow's setup and Rakudo don't work together well right now.

[19:32] <jnthn> ncow: Things will improve, but development takes time. :-)

[19:32] <ncow> I'm nto blaming anyone

[19:33] <sorear> ncow: have you considered not using Rakudo?

[19:33] <frettled> sorear: heresy! :D

[19:33] <ncow> do you fellas suppose I could instead fire up linux in a virtual machine (I have one in vmware ws 7) on my dual core laptop that I have with me here and build it there, and then transfer the finished build to the real box?

[19:33] *** donri left
[19:33] <masak> ncow: sure.

[19:33] <sorear> ncow: rakudo builds are non-transportable, that's why there's no binary available for download

[19:33] <ncow> I'm not sure what dependacies it relies on. I usually prefer to build on (or at least for) the target system

[19:34] <SHODAN> or you could just replace the real box with the laptop

[19:34] <SHODAN> ;)

[19:34] <ncow> sorear: I was afraid of that

[19:34] <ncow> sorear: not use rakudo? what other Perl 6 alternative is there?

[19:34] <sorear> ncow: now, on the other hand, https://github.com/downloads/sorear/niecza/niecza-4.01.zip

[19:34] <pmurias> niecza uses a lot less ram

[19:34] <ncow> sorear: I just wanted to test out Perl 6

[19:34] <sorear> I have a 8-9 year old computer with 384 MB ram

[19:35] <tadzik> ncow: I understand your mood, and believe me, when you're developing Rakudo, a 15-minute-lasting compilation is not something I fancy a lot. But that's a fact: you're below the memory limit. It's not the length, not the time, it's the amount of memory it needs. What you are probably stuck on, is the compilation of a file of over 7 thousand lines. Rakudo is currently a memory hog, and because it's basically

[19:35] <tadzik>  compiling itself, it takes a helluva memory. Combined with the fact that you don't really have that much, it may cause funny situations, like a 40-hour-lasting compilation. As I said, this limitation used to give people segfaults (was that you sorear?), so you're partly lucky, and partly not. Now, the process of minimizing Rakudo's memory usage as well as splitting the compilation to a smaller parts is in

[19:35] <tadzik>  progress, ask jnthn for details. We're sorry for the current state of Rakudo's performance, but we really do what we can, given the manpower we have

[19:35] <tadzik> ...whoa, that was a message

[19:35] <tadzik> ncow: does that clear your doubts and answer your questions?

[19:35] <sorear> ncow: Parrot's garbage collector is the butt of many jokes around here

[19:36] <sorear> ncow: even the people with 8 GiB lying around think it's pathetic

[19:36] <ncow> tadzik: yes, thanks. I udnerstand all that.

[19:36] <tadzik> I'm glad

[19:36] <tadzik> sorear: oh, it got a lot better recently

[19:37] <jnthn> sorear: The generational GC is an improvement at least.

[19:37] <jnthn> Not that there isn't room for more improvement but still...it's a move in the right direction.

[19:38] <sorear> it still needs to stop requiring 5 separate allocations per P6object PMC

[19:38] <jnthn> Indeed.

[19:39] <sorear> it still needs to stop retaining every single temporary in each function (some people call this a problem with the register allocator, but I have a very inclusive conception of "garbage collector")

[19:40] <sorear> ncow: I don't recommend trying to build niecza, it seems to need about 300MB while compiling itself, but the binary I linked you should work fine

[19:41] <sorear> ncow: don't use the Debian mono version (2.6); 2.8 uses about half as much memory (2.10 also works :))

[19:42] *** GinoMan joined
[19:49] *** pjcj left
[19:57] *** nymacro left
[19:58] *** alester joined
[19:59] *** justatheory left
[20:00] *** colomon left
[20:05] *** birdwindupbird left
[20:05] *** molaf left
[20:06] *** colomon joined
[20:09] *** ymasory left
[20:12] <ncow> sorear: thanks

[20:14] *** birdwindupbird joined
[20:27] *** _jaldhar left
[20:27] *** _jaldhar joined
[20:27] *** aindilis left
[20:28] *** aindilis joined
[20:32] *** pjcj joined
[20:34] <dalek> nqp/ctmo: 1d1ea2f | jonathan++ | src/metamodel/how/NQP (4 files):

[20:34] <dalek> nqp/ctmo: Get packages meta-objects to set a hash in their .WHO (can promote it to some more full-on Stash type later, probably, but this is fine for now.) (Foo.WHO)<$x> := 42 style stuff now works fine.

[20:34] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/1d1ea2fda4

[20:34] <dalek> nqp/ctmo: 06f82a8 | jonathan++ | src/metamodel/knowhow_bootstrapper.c:

[20:34] <dalek> nqp/ctmo: Should have a stash for KnowHOWs too.

[20:34] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/06f82a86fc

[20:34] <dalek> nqp/ctmo: 9869549 | jonathan++ | src/NQP/ (2 files):

[20:34] <dalek> nqp/ctmo: s/$*PKGMETA/$*PACKAGE/ - it's the compile time $?PACKAGE, after all. Install $?PACKAGE. Set up a GLOBALish, though nothing is done with it just yet.

[20:34] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/9869549033

[20:41] *** tzhs left
[20:41] *** wallberg joined
[20:49] *** birdwindupbird left
[20:59] *** SHODAN left
[21:00] *** ymasory joined
[21:02] *** GinoMan left
[21:08] *** GinoMan joined
[21:11] *** Rotwang left
[21:13] *** everyone_loves_P joined
[21:13] <masak> everyone_loves_P: \o/

[21:13] <masak> everyone_loves_P: I'm more of an M person myself.

[21:14] <moritz> .oO( everbody loves pm? )

[21:14] <everyone_loves_P> no, Perl!!!!

[21:14] <jnthn> oh, truncation :)

[21:14] <everyone_loves_P> yeah (((

[21:15] *** everyone_loves_P left
[21:15] <jnthn> .oO( everyone_loves_pivo )

[21:21] *** peterhil joined
[21:24] <masak> peterhil: hei!

[21:32] <peterhil> Hei

[21:32] *** kaare_ left
[21:34] <masak> peterhil: tervetuloa meidän nöyrä kanava.

[21:41] *** dorlamm joined
[21:42] *** ymasory left
[21:43] *** GinoMan left
[21:44] <peterhil> Kiitos, ajattelin vain vilkaista mitä uutta Perl 6:ssa on...

[21:44] <peterhil> Opettelin joskus vähän Perliä ennen Pythonia ja Rubya.

[21:44] <frettled> Oooh, I understood five words.

[21:45] <jnthn> I understood Perl, Python and Ruby... :)

[21:45] <peterhil> (And now everyone idling will wonder what I'm writing...)

[21:45] * jnthn smiles at the cute case declensions 

[21:46] <sorear> I think I get the "6" too

[21:48] <peterhil> Translation: Thank you, I just thought to take a peek at what is new on Perl 6... I learned some Perl before Python and Ruby.

[21:48] <masak> peterhil: uskon Perl 6 pitää mukavia yllätyksiä sinulle.

[21:48] <masak> did I get that right? I'm leaning heavily on Google Translate here.

[21:49] <jaffa4> miért kell idegen nyelven beszélni?

[21:49] <jnthn> What was that about a goat-pole?

[21:49] <masak> jaffa4: ah, Hungarian. :)

[21:50] *** alester left
[21:50] <jaffa4> sorear: do you have a test suite?

[21:50] <peterhil> masak: Oikeammin: Uskon että, Perl 6 sisältää ...

[21:51] <jaffa4> no comprendo tu palablas

[21:52] <peterhil> So I've been learning Javascript lately and read from Wikipedia that Perl 6 has had influences from it in addition to Haskell (optional strong typing?)

[21:52] <peterhil> Are there some functional programming features from Haskell?

[21:52] <peterhil> Like map, reduce, takeWhile, cycle, foldr etc...?

[21:53] <jaffa4> cycle

[21:53] <jaffa4> I do not know cycle

[21:53] <peterhil> What are the JS influences? The closures and the object system?

[21:53] <jaffa4> typeless?

[21:53] <jnthn> peterhil: Yes, Perl 6 has various functional bits

[21:53] <peterhil> IIRC cycle takes an array and loops it over in Haskell.

[21:54] *** silent_h_ joined
[21:54] <jnthn> rakudo: say [*] 1..10

[21:54] <p6eval> rakudo 5ac05e: OUTPUT«3628800␤»

[21:54] <jnthn> Is reduction meta-operator

[21:55] <jaffa4> rakudo [**] 3;

[21:55] <jaffa4> rakudo: [**] 3;

[21:55] <p6eval> rakudo 5ac05e:  ( no output )

[21:55] <peterhil> jaffa4: Haskell had some special term for the optional typing... I think it was type inference

[21:55] <jaffa4> rakudo: [**] 3,1;

[21:55] <p6eval> rakudo 5ac05e:  ( no output )

[21:55] <masak> rakudo: .say for (1, 2, 3) xx *

[21:55] <jaffa4> rakudo: [**] (3,1);

[21:55] <pmurias> peterhil: i don't think Perl 6 was inspired by Javascript much

[21:55] <p6eval> rakudo 5ac05e:

[21:55] <p6eval> ..OUTPUT«(timeout)␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤2􏿽xE2

[21:55] <p6eval> rakudo 5ac05e:  ( no output )

[21:56] <masak> peterhil: there's your cycle.

[21:56] <masak> and I don't like it that "(timeout)" overwrites the beginning of the output :(

[21:57] <masak> peterhil: and yes, we have map, reduce/fold, and a bunch of other FP concepts.

[21:57] <masak> peterhil: in fact, Perl 5 (and earlier) already had map and grep.

[21:57] <peterhil> masak: OK, cool

[21:58] <pmurias> Perl 5 already has closures so they were not taken from javascript

[21:58] <pmurias> which itself seem to be a bit Perl inspired

[21:58] <masak> Perl 6 has prototypes. sort of.

[21:59] <pmurias> masak: they are real prototypes

[21:59] <masak> oh, good.

[21:59] <pmurias> masak: it's just that a prototype OO system is left for CPAN

[21:59] <diakopter> javascript has $varnames and everything ;)

[21:59] <masak> then maybe that's the inspiration from JavaScript?

[22:00] <peterhil> In Javascript the objects are basically just hashes. But the values can contain functions.

[22:01] <masak> rakudo: my $obj = { foo => { say "OH HAI" } }; $obj<foo>()

[22:01] <peterhil> The description on Wikipedia for Perl6 seems to describe something similar

[22:01] <p6eval> rakudo 5ac05e: OUTPUT«OH HAI␤»

[22:01] <masak> peterhil: that's not usually how we do objects, but it definitely works.

[22:02] <masak> rakudo: class C { method foo { say "OH HAI" } }; C.new.foo

[22:02] <p6eval> rakudo 5ac05e: OUTPUT«OH HAI␤»

[22:03] <jnthn> sleep &

[22:03] <pmurias> what concepts from python and ruby influenced Perl 6?

[22:03] <peterhil> masak: That latter way seems more familiar from some years back, when I started to learn Perl by doing the Useless Python exercises.

[22:04] <peterhil> At some point I gave up, and continued with learning Python. :-)

[22:05] <masak> I am not familiar with those exercises.

[22:05] <masak> pmurias: I know Ruby sigils inspired Perl 6 twigils :)

[22:05] *** dual left
[22:05] <masak> pmurias: (Ruby uses a '@' sigil to show attribute classitude)

[22:06] <masak> Python... Python had the chained comparisons before Perl 6 did, I think.

[22:07] <masak> and though it doesn't have junctions, it has set operations named any() and all() that work a bit similar.

[22:07] * pmurias remove mention of SMOP from the wikipedia Perl 6 article

[22:07] <pmurias> * removed

[22:10] <peterhil> Mixins from Ruby?

[22:11] <masak> no, from Smalltalk.

[22:11] <masak> I don't think Ruby's do method collision detection.

[22:11] <masak> oh noes!

[22:12] <masak> rakudo: say [1..3].perl

[22:12] <p6eval> rakudo 5ac05e: OUTPUT«[1, 2, 3]␤»

[22:12] *** alester joined
[22:12] <masak> ranges get expanded!

[22:12] <pmurias> rakudo: say [1..1000].perl

[22:13] <p6eval> rakudo 5ac05e: OUTPUT«[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,

[22:13] <p6eval> ..72, 73…

[22:13] <masak> rakudo: class C { method postcircumfix:<[ ]>($p) { say $p.WHAT } }; C.new[1..5]

[22:13] <p6eval> rakudo 5ac05e: OUTPUT«Range()␤»

[22:13] <masak> oh phew.

[22:13] <masak> still in business, then.

[22:13] <pmurias> rakudo: say (1..3).perl

[22:13] <p6eval> rakudo 5ac05e: OUTPUT«1..3␤»

[22:13] <masak> they don't expand in postcircumfixes. :)

[22:14] <pmurias> rakudo: say ["a","b",1..3,"d"].perl

[22:14] <p6eval> rakudo 5ac05e: OUTPUT«["a", "b", 1, 2, 3, "d"]␤»

[22:14] <masak> I guess circumfix:<[ ]> has some kind of flattening context going on.

[22:14] <masak> the things you learn by writing tests :P

[22:16] <jaffa4> What is []?

[22:17] <masak> rakudo: class O { method postcircumfix:<[ ]>() { 42 } }; say O[]

[22:17] <p6eval> rakudo 5ac05e: OUTPUT«Method '!select' not found for invocant of class ''␤  in main program body at line 22:/tmp/puyVJCCcYF␤»

[22:18] <jaffa4> rakudo: print [1,2,3]

[22:18] <p6eval> rakudo 5ac05e: OUTPUT«1 2 3»

[22:18] <jaffa4> rakudo: print [1,2,3]*3

[22:18] <p6eval> rakudo 5ac05e: OUTPUT«9»

[22:19] <jaffa4> rakudo: print (1,2,3)*3

[22:19] <p6eval> rakudo 5ac05e: OUTPUT«9»

[22:19] <jaffa4> rakudo: print (1,2,4)*3

[22:19] <p6eval> rakudo 5ac05e: OUTPUT«9»

[22:19] <jaffa4> rakudo: print (1,2,4,5)*3

[22:19] <p6eval> rakudo 5ac05e: OUTPUT«12»

[22:19] <peterhil> masak: There were some challenges on here back on 2003: http://replay.waybackmachine.org/20041019090643/http://uselesspython.com/up2/sourcecode.html

[22:20] <peterhil> But the excercises I was referring were actually here: http://www.pythonchallenge.com/ Fun stuff!

[22:20] *** silent_h_ left
[22:21] *** jaffa4 left
[22:21] <masak> hello? p6eval?

[22:21] <masak> rakudo: say "OH HAI"

[22:21] <masak> it went to bed.

[22:21] <masak> so should I.

[22:21] <masak> 'night, #perl6.

[22:21] *** masak left
[22:21] <p6eval> rakudo 5ac05e: OUTPUT«OH HAI␤»

[22:21] <peterhil> 'I got to level 20 and did the first six + nr 17 with Perl

[22:22] <peterhil> 'Night masak

[22:26] *** wallberg left
[22:29] *** coldhead left
[22:37] *** dorlamm left
[22:46] *** dayangkun_ joined
[22:47] *** dayangkun__ joined
[22:51] *** dayangkun_ left
[22:57] *** colomon left
[23:03] *** colomon joined
[23:06] *** rgrau left
[23:16] *** pmurias left
[23:19] *** silent_h_ joined
[23:19] *** [Coke] left
[23:21] *** [Coke] joined
[23:45] <diakopter> rakudo: say "OH HAI"

[23:45] <p6eval> rakudo 5ac05e: OUTPUT«OH HAI␤»

[23:45] * diakopter notes quickness

