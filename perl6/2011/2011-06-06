[00:00] *** dorlamm left
[00:36] *** icwiener left
[00:37] <dalek> rakudo/nom: 89f13aa | jnthn++ | src/ (2 files):

[00:37] <dalek> rakudo/nom: A little cleanup and a step closer with multi-methods. Some tricky problems to go.

[00:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/89f13aaaff

[00:37] <dalek> rakudo/nom: 0e5faf7 | jnthn++ | src/binder/multidispatch.c:

[00:37] <dalek> rakudo/nom: Fix an inverted set of checks in the narrowness analysis for multi-dispatch. With this, instantiating the proto in subclasses and adding their candidates to it works and dispatches correctly, though only in the pre-compiled case (need to fix the fixup, a la nqp, though not so nasty).

[00:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e5faf7f61

[00:37] <dalek> rakudo/nom: d17aca6 | jnthn++ | / (5 files):

[00:37] <dalek> rakudo/nom: Refactor handling of how we locate the candidate list for a dispatcher to be a bit more dynamic.

[00:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d17aca602e

[00:51] <jnthn> huh, above two are inverted...

[00:51] <jnthn> anyway, sleep &

[00:52] <dalek> rakudo/nom: bbc5b0d | jnthn++ | / (2 files):

[00:52] <dalek> rakudo/nom: Expand on nommap, add another piece of LHF.

[00:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bbc5b0ddad

[00:54] *** mtk left
[00:57] *** spinclad joined
[01:01] *** mtk joined
[01:17] *** Chillance left
[01:21] *** nymacro joined
[01:24] <dalek> niecza: d3f8dc6 | sorear++ | lib/Kernel.cs:

[01:24] <dalek> niecza: Fix NIECZA_TRACE_LOAD for evals

[01:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d3f8dc6601

[01:24] <dalek> niecza: 9cf99ec | sorear++ | src/ (2 files):

[01:24] <dalek> niecza: NAM generation for subset & enum

[01:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9cf99ecfb0

[01:27] *** pernatiy joined
[01:33] *** s1n joined
[01:35] *** whiteknight left
[01:52] *** donri left
[02:02] *** nymacro left
[02:16] *** PhatEddy left
[02:19] *** nymacro joined
[02:39] <sorear> Is "self := self.CREATE;" legal in a new method?

[02:40] <sorear> erm, I think that should be self.CREATE(*)

[02:42] *** envi joined
[02:50] *** noganex joined
[02:51] <dalek> niecza: 2c90936 | sorear++ | lib/CORE.setting:

[02:51] <dalek> niecza: Fix EnumMap construction

[02:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2c909363dd

[02:52] *** noganex_ left
[03:11] <TimToady> I don't see how self := self.CREATE can possibly work on a scalar variable, since $x.new will deref to the type object in $x

[03:11] <TimToady> it might just possibly work on array or hash vars

[03:12] <TimToady> but then why would you do it if there's already an Array or Hash object?

[03:12] *** masonkramer joined
[03:13] <TimToady> or are you just wanting to change what 'self' means in the method?

[03:13] <TimToady> that seems a bit...odd...

[03:15] <TimToady> I'm not sure I'd go as far as to say it's antisocial though...

[03:16] <TimToady> more like a way to do a tail-recursive graft of a real method onto the end of the constructor

[03:18] <TimToady> and it's not like you're changing the type of self, you're just changing its definedness

[03:19] <TimToady> one could make a feature of it and say that self.bless always reifies self in place, I suppose

[03:21] <TimToady> seems a bit restrictive though

[03:21] <TimToady> so we should probably leave the capability optional, if we allow it

[03:22] <TimToady> use/abuse cases are welcome

[03:22] <sorear> yeah, grafting a real method

[03:23] <TimToady> it could be a common idiom

[03:23] *** daniel-s joined
[03:23] <TimToady> I'm trying to think of a downside

[03:23] <sorear> I was doing self := self.CREATE; $!x = 1; $!y = 2; self

[03:23] <sorear> basically

[03:24] <sorear> my Mu.new doesn't allow creation-time assignment to private attributes

[03:24] <sorear> which is increasingly seeming like a mistake

[03:24] *** Su-Shee_ joined
[03:24] <TimToady> well...CREATE is supposed to be separate from bless

[03:25] <TimToady> and in the standard formulation it's bless that initializes in a proper derived order

[03:26] <TimToady> I suppose I can imagine an object that can't be allocated separately to initialization, though I'd tend to incorporate creation into initialization in that case, not the other way around

[03:27] <daniel-s> moritz, why does it matter what order a multi subroutine comes in?

[03:27] *** Su-Shee left
[03:27] <daniel-s> I'm looking at the changes to the perl book from yesterday

[03:27] <daniel-s> https://github.com/perl6/book/commit/8ebeb7e6aed645f6cf68c08118d0dc69893a69b0

[03:28] <TimToady> daniel-s: see S12:1146

[03:28] <sorear> TimToady: niecza's CREATE/bless factoring is known to be bogus... I'm looking at new

[03:29] <sorear> niecza: class A { has $.b; method show() { say $!b } }; A.new(b => 3).show

[03:29] <p6eval> niecza v6-60-g2c90936: OUTPUT«3␤»

[03:29] <sorear> niecza: class A { has $!b; method show() { say $!b } }; A.new(b => 3).show

[03:29] <p6eval> niecza v6-60-g2c90936: OUTPUT«Any()␤»

[03:30] <TimToady> that seems close to what is specced

[03:30] <TimToady> $!b is not part of the public API

[03:31] <TimToady> the main problem is we don't have a mechanism to point out unused parameters

[03:31] <sorear> is there a spec-appproved way to create an A (2nd case) with a specific value of $!b?

[03:31] <mberends> sorear: if your let me know where Mono 2.6.7 went wrong in Niecza, I might look for a workaround (subject to your review)

[03:32] <sorear> mberends: scroll up to moritz.*«auld» and you'll find a one-line test case

[03:32] <mberends> :)

[03:33] <TimToady> sorear: sure, submethod BUILD ($!b) {} is supposed to make b settable

[03:34] <TimToady> it's only the implicit build that doesn't make $!b available

[03:34] <sorear> I thought BUILD could only have named arguments

[03:34] <TimToady> S12:826

[03:34] <sorear> wait, that's completely beside the point

[03:34] <TimToady> it has named arguments

[03:34] <TimToady> the question is whether we retract the named param change

[03:34] <TimToady> named-to-positional change

[03:35] <daniel-s> TimToady, so if two sets of parameters are the same and both are constrained, it's the order in which they appear in the .pl file?

[03:35] <TimToady> or do we force people to write (:$!b)

[03:35] <TimToady> "the order in which they are declared"

[03:35] <TimToady> they may not be in the same file

[03:36] <TimToady> the inter-file ordering is perhaps not right yet though

[03:36] *** hudnix left
[03:36] <daniel-s> ok, so the compiler doesn't look at how narrow the constrain is?

[03:36] <TimToady> there are use cases for either before or after

[03:36] <TimToady> daniel-s: that's more or less a halting problem

[03:37] *** tokuhirom joined
[03:42] <TimToady> I suppose the current formulation of doing used constraints before our own constraints (assume the use happens before our defs) is okay

[03:43] <TimToady> since we can force our constraints into an earlier rank with a judicious use of a slightly tighter nominal check

[03:44] <TimToady> or we can not import the other constraints till further down, I guess

[03:45] <TimToady> otoh, one could argue that if you're adding to the constrained cases of another file, you probably want to override them, which argues to put imported candidates later

[03:46] <TimToady> otgh, one could also be wanting to add a better generic case at the end, so it's kind of a wash

[03:46] <TimToady> the thing to optimize for is probably the thing that's easiest to explain

[03:47] <TimToady> and order of import/declaration is pretty easy to explain

[03:50] * TimToady thinks about a rule that says only twigil'd positional parameters can be set with named args, then allow $:foo to be a positional that can be named; woudl be hard to keep $:foo and :$bar straight though...

[03:53] <TimToady> I dunno, one of the original rationales for proto was to regularize the naming of positionals, so it seems to me if we want to leave the positional names out of the API, there's some way with proto foo ($,$, :$opt), and let the multis pick their own hidden names for positionals

[03:55] <TimToady> but the point of proto foo ($x,$y,:opt) was that foo(:x(1), :y(2)) could turn into foo(1,2) at compile time, at least for functions

[03:55] <TimToady> so I don't buy the performance argument much

[03:56] <TimToady> only the API argument, and maybe ($,$) addresses that

[03:58] <TimToady> I suppose there's something to be said for requiring :$!foo in BUILD to keep people from thinking there's some way to set them positionally

[03:58] <TimToady> but that's a lot of mandatory punctuation

[04:01] *** wamba joined
[04:07] *** tokuhirom left
[04:08] *** tokuhirom joined
[04:13] <yath> hmmmmm.

[04:13] * yath has an understanding problem. i can use [<=] to check the order of values. so 1 <= 2 <= 3 gives True, 1 >= 2 <= 3 gives false

[04:14] <yath> 1 >= 2 otoh is False and False <= 3 is true

[04:15] <yath> (1 >= 2) <= 3 is True also

[04:15] <yath> why does a chained comparison behave different?

[04:17] <mberends> I don't get your False <= 3.  It's 2 <= 3.  Chained comparisons are special.

[04:17] <yath> rakudo: say 1 >= 2 <= 3; say (1 >= 2) <= 3;

[04:17] <p6eval> rakudo 048573: OUTPUT«Bool::False␤Bool::True␤»

[04:18] <yath> the latter evaluates to False <= 3

[04:18] <yath> but what's so special about the former?

[04:18] <mberends> I think 1 >= 2 <= 3 DWIMs as (1>=2) && (2<=3)

[04:19] <yath> seems so. was just wondering why :)

[04:20] <TimToady> it's magic

[04:20] <mberends> to enable a kind of SQL BETWEEN emulation

[04:20] <TimToady> we don't try to fake it the way, say, Icon fakes it

[04:20] <TimToady> we just say "that's what it means"

[04:21] <yath> mberends: i know it's dwimmy and i have no problem at all with it :) i was just wondering how this is implemented

[04:21] <yath> TimToady: Icon?

[04:21] <TimToady> another language

[04:21] <yath> hm.

[04:21] <mberends> yath: liek TimToady++ said, it's implemented by magic ;)

[04:21] <TimToady> it's implemented by recognizing the particular precedence level, and just forcing it to mean that

[04:22] <TimToady> how the implementation does it is not the concern of the user, as long as the semantics are consistent

[04:22] <yath> okay, just found O('%chaining') in Grammar.pm

[04:22] <yath> so nothing i should care about. thanks :)

[04:22] <TimToady> which includes the stipulation that side effects happen only once

[04:22] <TimToady> you can care about it, esp if you're implementing it :)

[04:23] <yath> first i should learn the user-visible parts of perl6 :)

[04:23] <mberends> .oO( hopefully the test suite verifies once-only side effects )

[04:30] <TimToady> mberends: doesn't look like it, offhand

[04:32] <mberends> meh, I can imagine how it should look. There is a round tuit for that not far off.

[04:33] <TimToady> looks like it belongs in S03-operators/relational.t

[04:33] <TimToady> I'll let you do it, if you want to.

[04:33] <mberends> ok, thanks.  will do :)

[04:34] *** satyavvd joined
[04:34] *** satyavvd left
[04:34] *** satyavvd joined
[04:35] <TimToady> ah, looks like it *might* be tested in short-circuit.t

[04:35] <TimToady> but it seems to be testing for something else

[04:35] <mberends> then at a minimum, I'll clarify the matter in some comments

[04:36] <TimToady> it might catch the error for what it thinks is a different reason

[04:36] <TimToady> thanks

[04:42] <sorear> perl6: say(1) == say(2) == say(3)

[04:42] <p6eval> pugs, rakudo 048573, niecza v6-60-g2c90936: OUTPUT«1␤2␤3␤»

[04:42] <sorear> huh.  I thought that was broken in niecza

[04:43] <sorear> yath: learning the user-visible parts of pero 6 first is probably a mistake

[04:43] <sorear> for me, learning a language is like making a building.  you have to start from the bottom and work up, the other way around is impossible

[04:44] <yath> sorear: i'm actually trying to understand basics of the language first before figuring out how they are implemented :)

[04:44] <yath> sorear: i tried understanding how rakudo works a couple of times with no result

[04:46] <yath> in perl5 terms: it makes to sense looking at what an HV* looks like if i don't even know what a hash is

[04:56] <mberends> TimToady: I believe short-circuit.t test 70 (chained comparison short-circuit: not re-evaluating middle) does verify once-only side effects completely.

[04:57] <sorear> yath: I'm not entirely sure what you mean by that last one

[04:58] *** koban` joined
[05:00] *** [particle] left
[05:02] *** wamba left
[05:02] *** [particle] joined
[05:05] <yath> sorear: i mean that i should understand the perl6 language first before looking at how features are implemented. if i don't know how grammars work it doesn't make much sense to look at the perl6 grammar also.

[05:06] *** birdwindupbird joined
[05:06] <sorear> yes and no

[05:07] <sorear> trying to understand the Perl 6 grammar syntax without first understanding recursive parser theory seems a bad idea to me

[05:07] *** tomaw left
[05:10] *** [particle]1 joined
[05:10] *** [particle] left
[05:31] *** _jaldhar_ left
[05:32] *** koban` left
[05:34] <yath> err, sorry. s/how grammars work/how the perl6 rule syntax is/

[05:35] <sorear> yeah, there's a bit of a chicken and egg problem there

[05:35] <yath> see. so i'm trying to write some perl6 code first :)

[05:36] <sorear> TimToady has made the language definition metacircular in such a way that it cannot be effectively parsed except with itself, or a subset of itself that includes the grammars

[05:37] <yath> by the way, why does Array have a .chars method? i couldn't find it either rakudo or parrot, does it get stringified automagically?

[05:37] <sorear> yes

[05:38] <sorear> rakudo: say [1, 2, 3].chars

[05:38] <p6eval> rakudo 048573: OUTPUT«5␤»

[05:38] <yath> does that apply to any object?

[05:38] <sorear> rakudo: say [1, 2, 3].Str

[05:38] <p6eval> rakudo 048573: OUTPUT«1 2 3␤»

[05:38] <sorear> no, only objects that inherit from Cool

[05:38] <sorear> rakudo: say [1, 2, 3].^parents

[05:38] <p6eval> rakudo 048573: OUTPUT«List()Iterable()Cool()Any()Mu()␤»

[05:38] <yath> ah

[05:38] <yath> thanks!

[05:38] <sorear> niecza: say [1, 2, 3] ~~ Cool # can't remember if this is done correctly

[05:38] <p6eval> niecza v6-60-g2c90936: OUTPUT«Bool::True␤»

[05:39] <yath> is Cool just cool or does that stand for something?

[05:42] *** kaare_ joined
[05:44] *** _jaldhar_ joined
[05:45] <TimToady> hmm, I was thinking Array would have its own .chars that avoided stringifying...

[05:45] <dalek> niecza: 11cd2ab | sorear++ | / (3 files):

[05:45] <dalek> niecza: NAMOutput/CLRBackend parsing for enums and subsets.  First draft of full support

[05:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/11cd2abe3a

[05:45] <sorear> yath: it's just cool

[05:45] <yath> ah okay :)

[05:45] <TimToady> er, it has a backronym

[05:46] <TimToady> ./S02-bits.pod:	    Cool        Perl 6 Convenient OO Loopbacks

[05:46] <yath> common object oriented.. lazyness?

[05:46] <yath> ah

[05:46] <yath> :)

[05:47] <TimToady> and you do already know something about parsers because you have one in your head :)

[05:52] *** wtw joined
[05:54] *** jaldhar joined
[05:55] *** _jaldhar_ left
[06:02] <sorear> rakudo: enum Foo (:a("b")); say Foo::a;

[06:02] <p6eval> rakudo 048573: OUTPUT«b␤»

[06:04] *** jaldhar left
[06:04] *** jaldhar joined
[06:04] <sorear> TimToady: how does S12:1743 apply to string valued enums?

[06:09] <TimToady> the table seems a bit off in that regard; I think .Stringy and ~ should probably produce the .value stringified

[06:09] <TimToady> .Str should probably stay abstract like it is

[06:10] * sorear doesn't understand the difference between Str and Stringy

[06:10] <TimToady> but Foo ~ Bar should concat the values of two string-valued enums, I imagine

[06:11] <TimToady> Stringy is for coercion when you want to continue to process as a normal string; Str is last-ditch forced string coercion for human understandability, so even Junctions stringify under Str

[06:11] <TimToady> whereas Junctions autothread under Stringy

[06:12] <TimToady> rakudo: say (1 | 2)

[06:12] <p6eval> rakudo 048573: OUTPUT«any(1, 2)␤»

[06:12] *** wamba joined
[06:12] <TimToady> rakudo: say "a" ~ (1 | 2)

[06:12] <p6eval> rakudo 048573: OUTPUT«any("a1", "a2")␤»

[06:12] <TimToady> you see the difference there

[06:13] <TimToady> rakudo: say True

[06:13] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[06:14] <TimToady> rakudo: say ~True

[06:14] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[06:14] <TimToady> that one should probably be 1, if we want strings to work consistently

[06:14] <TimToady> s/strings/string-valued enums/

[06:15] *** Su-Shee_ is now known as Su-Shee

[06:15] <TimToady> otherwise .value is the only way to get a string out of an enum that supposed represents a string, which is kinda nutty

[06:16] <TimToady> or we make a different table for string-valued enums than for numeric ones

[06:17] <TimToady> could argue that the latter is more what people expect

[06:20] <sorear> &infix:<~> never sees junctions anyway

[06:22] <TimToady> rakudo: (1|2).say

[06:22] <p6eval> rakudo 048573: OUTPUT«any(1, 2)␤»

[06:22] <TimToady> that one doesn't autothread either

[06:23] <TimToady> I think I'll just make an asymmetry for ~ and .Stringy depending on whether it's numeric/stringy

[06:25] <dalek> specs: 21b2cd9 | larry++ | S12-objects.pod:

[06:25] <dalek> specs: .Stringy produces key only on numeric enums

[06:25] <dalek> specs: review: https://github.com/perl6/specs/commit/21b2cd9e0b

[06:27] *** jaldhar left
[06:27] *** jaldhar joined
[06:34] *** ascott_tainer joined
[06:35] <sorear> Is .Str the same as .perl on junctions?

[06:35] *** wamba left
[06:38] <TimToady> seems about right

[06:40] *** fhelmberger joined
[06:40] * sorear wonders if Day.enums should really be Day.^enums

[06:42] <sorear> I guess .Str and .Stringy on Str-type enums should have the effect of stripping enumness and making a vanilla Str

[06:43] * sorear checks out how rakudo-ng does enums

[06:45] <TimToady> as the spec currently stands, .Str produces the full name, but .Stringy produces the .value on stringy enums

[06:46] <TimToady> rakudo likely follows the old spec there

[06:47] <sorear> in an expression our enum Foo < Bar Baz Quux >;  are the unqualified aliasesBar, Bar, Quux installed in OUR:: or just MY::?

[06:47] *** jaldhar left
[06:47] <TimToady> I think they follow along into the OUR::

[06:48] <TimToady> since the main point of an enum is to define the individual bits

[06:48] <moritz> daniel-s: re order of multis in the book: it doesn't actually matter in this case, it was just for the sake of consistency with the earlier example

[06:48] <TimToady> it's a convenient way to define a set of constants

[06:56] <TimToady> rakudo: enum PO2 (<zero one two three four five six seven eight> Z 1,2,4...*); say +PO2::eight

[06:56] <p6eval> rakudo 048573: OUTPUT«16␤»

[06:56] <TimToady> that seems wrongish

[06:56] <TimToady> oh wait

[06:57] <TimToady> rakudo: enum PO2 (<zero one two three four five six seven eight> Z=> 1,2,4...*); say +PO2::eight

[06:57] <p6eval> rakudo 048573: OUTPUT«256␤»

[06:57] <TimToady> that's better

[06:59] <sorear> PO2...?

[06:59] <TimToady> powers of 2

[07:00] <TimToady> just testing the idiom for naming bits in a word

[07:00] <sorear> yeahhh

[07:00] <sorear> that won't work in niecza for a while

[07:00] <sorear> :)

[07:01] <TimToady> you're so lazy :)

[07:01] <sorear> 'tis been almost a year and still no BEGIN

[07:01] <sorear> of course I'm lazy.  I'm an ex-Haskell programmer.

[07:01] * TimToady is eager...

[07:01] <moritz> sorear: just construct a program where everything but the BEGIN blocks run in an eval :-)

[07:02] <sorear> hah. :)

[07:02] <TimToady> there you go

[07:02] <TimToady> .oO(the piece of cake is a lie...)

[07:03] <TimToady> but to the first approximation, moritz++ speaks truth

[07:05] * sorear crumples up the EnumHOW stuff, which is increasingly making no sense, and decides to have enum A < B C > just be syntactic sugar for class A is IntBasedEnum { method enums() { constant = enum < B C > }; constant B = A(0); constant C = A(1) }; constant B = A::B; constant C = A::C

[07:06] <yath> hm

[07:06] <yath> what is the difference between Num and Numeric?

[07:07] <sorear> Numeric is a role

[07:07] <TimToady> Num is a specific type (C's double)

[07:07] <yath> ah

[07:07] <yath> thanks

[07:07] <TimToady> but a boxed double, whereas num is unboxed

[07:08] <TimToady> so Numeric is stuff that applies to both Rat and Num

[07:08] * sorear wonders if there is a direct etymological connection between Num and NV

[07:08] <sorear> and Int and Complex and FatRat

[07:09] *** nsh joined
[07:10] <TimToady> I dunno about etymological connect, but there's definitely a neural connection :)

[07:11] <TimToady> speaking of neural connections, I'd better disconnect some of mine for a few hours, so I don't disconnect any while driving tomorrow.

[07:11] <TimToady> zzz &

[07:13] *** mj41 joined
[07:16] *** _twitch joined
[07:35] *** daniel-s left
[07:39] *** koban` joined
[07:40] *** MayDaniel joined
[07:44] *** MayDaniel left
[07:52] *** daniel-s joined
[07:53] *** tomaw_ joined
[07:58] *** daniel-s left
[08:12] *** tomaw_ is now known as tomaw__

[08:14] *** tomaw__ is now known as tomaw

[08:17] *** amkrankruleuen joined
[08:20] <yath> mhm

[08:20] <yath> rakudo: my %foo = foo => bar, bar => baz; %foo.values»

[08:20] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Confused at line 22, near "%foo.value"␤»

[08:21] <sorear> values must be quoted

[08:21] <yath> err, yes

[08:21] <yath> rakudo: my %foo = foo => "bar", bar => "baz"; %foo.values»

[08:21] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Confused at line 22, near "%foo.value"␤»

[08:21] <yath> why at %foo.value and not at %foo.value_s_?

[08:21] <sorear> because it truncates

[08:22] <sorear> it gives you a fixed context near the syntax error

[08:22] <sorear> you have an extraneous »

[08:22] <yath> yeah, i know. was just wondering why is stops at .value

[08:22] <yath> but truncating explains that, thanks

[08:23] <yath> rakudo: my %foo = foo => "bar", bar => "baz"; %foo.bar» # works like expected :)

[08:23] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Confused at line 22, near "%foo.bar\x{bb} "␤»

[08:31] *** jaldhar joined
[08:34] <cxreg> wow, lots of action in nom the last few days

[08:35] *** dakkar joined
[08:35] <dalek> niecza: 1e5cc31 | sorear++ | / (6 files):

[08:35] <dalek> niecza: Reimplement enums as sugar for a class and constants.  Mostly working but MRO issues.

[08:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1e5cc31394

[08:35] <tadzik> yeah, pretty much

[08:35] <tadzik> we have passing tests ;)

[08:39] *** Reaganomicon left
[08:41] *** mtk left
[08:43] <sorear> my C3 MRO calculator is acting broken

[08:45] *** icwiener joined
[08:49] *** jaldhar left
[08:49] *** mtk joined
[09:02] <dalek> niecza: b9ff148 | sorear++ | src/Metamodel.pm6:

[09:02] <dalek> niecza: Fix C3 MRO handling

[09:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b9ff148f1b

[09:02] <dalek> niecza: 8391b5c | sorear++ | src/niecza:

[09:02] <dalek> niecza: Inadequate attempt to enable string enums

[09:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8391b5cb4b

[09:14] <moritz> http://www.benjamincoe.com/post/6234388028/why-i-hate-ruby-or-at-least-some-common-practices-of yay for monkey-patching

[09:17] *** donri joined
[09:26] *** pernatiy left
[09:27] <dalek> niecza: 9dd105a | sorear++ | lib/ (3 files):

[09:27] <dalek> niecza: Implement subset declarations

[09:27] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9dd105a767

[09:27] *** masak joined
[09:27] <masak> morning, #perl6.

[09:28] <sorear> hi masak.

[09:30] <jnthn> morning, #perl6

[09:31] <jnthn> std: class Foo { }; class Bar trusts Foo { }

[09:31] <p6eval> std c843201: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/2uSXCNjM5G line 1:␤------> [32mclass Foo { }; class Bar [33m⏏[31mtrusts Foo { }[0m␤    expecting trait␤Parse failed␤FAILED 00:01 112m␤»

[09:32] <masak> 'trusts' only occurs inside of a class body, right?

[09:32] <jnthn> TimToady: ^ Please can we just make trusts into a normal trait_mod? Today it seems to be the "odd one out" for no good reason.

[09:32] <tadzik> std: class Foo { }; class Bar trusts  { }

[09:32] <p6eval> std c843201: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse class definition at /tmp/NLGGjvJPca line 1:␤------> [32mclass Foo { }; class Bar [33m⏏[31mtrusts  { }[0m␤    expecting trait␤Parse failed␤FAILED 00:01 112m␤»

[09:32] <tadzik> whoops

[09:32] <tadzik> std: class Foo { }; class Bar { trusts Foo; }

[09:32] <p6eval> std c843201: OUTPUT«ok 00:01 112m␤»

[09:32] <tadzik> weird indeed

[09:32] <jnthn> TimToady: I'll still be possible in the class body with "also trusts". Anyway, this makes it easier to set up mutually trusting classes at stub time.

[09:33] <jnthn> And it's just more consistent :)

[09:33] <sorear> niecza: enum Reg < AX BX CX DX SI DI BP SP >; my $reg = BP; $reg++; $reg++; say $reg.perl

[09:33] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg::SP␤»

[09:33] <jnthn> er :)

[09:34] * sorear shows off the latest feature to jnthn

[09:34] <jnthn> oh, I mis-read it

[09:34] <jnthn> sorear: Nice

[09:34] <jnthn> sorear: How's it factored?

[09:34] <jnthn> sorear: That is, what actually *is* an enum in Niecza?

[09:35] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say BX.WHAT

[09:35] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg()␤»

[09:35] *** daniel-s joined
[09:35] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; Reg BX.WHAT

[09:35] <p6eval> niecza v6-65-g9dd105a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/FZdQW5EuT1 line 1:␤------> [32mum Reg < AX BX CX DX SI DI BP SP >; Reg [33m⏏[31mBX.WHAT[0m␤␤Parse failed␤␤»

[09:35] <jnthn> gah

[09:35] <sorear> that declaration creates class Reg is IntBasedEnum is Int { method enums() { ... } } and a bunch of constants

[09:35] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say Reg.WHAT

[09:35] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg()␤»

[09:36] <sorear> most of the methods are implemented in IntBasedEnum or CommonEnum

[09:36] <jnthn> OK

[09:36] <masak> sorear++ # enums!

[09:36] <sorear> NUM NUM NUM

[09:37] <masak> :)

[09:38] <sorear> unfortunately my latest change to subsets somehow broke stub packages

[09:39] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say BX.Int

[09:39] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg::BX␤»

[09:40] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say BX.Int + 42

[09:40] <p6eval> niecza v6-65-g9dd105a: OUTPUT«43␤»

[09:40] <sorear> method Int() { self } # seemed like a good definition at the time

[09:40] <masak> :)

[09:41] <jnthn> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say Reg(3)

[09:41] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg()␤»

[09:41] *** masak left
[09:41] <sorear> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say Reg.(3) # I wonder

[09:41] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Reg::DX␤»

[09:41] <moritz> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say BX.Int ~~ Int

[09:41] <p6eval> niecza v6-65-g9dd105a: OUTPUT«Bool::True␤»

[09:41] <moritz> so, technically it's correct :-)

[09:41] <sorear> there's some STD brokenness with parsing a simple typename immediately followed by a postcircumfix

[09:42] <moritz> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say BX.Int + 0

[09:42] <p6eval> niecza v6-65-g9dd105a: OUTPUT«1␤»

[09:42] <moritz> niecza: enum Reg < AX BX CX DX SI DI BP SP >; say SP.Int + 0

[09:42] <p6eval> niecza v6-65-g9dd105a: OUTPUT«7␤»

[09:42] <sorear> erm.  those values are in the wrong order, it should be AX CX DX BX

[09:42] <sorear> or maybe it was ADCB

[09:46] <moritz> nqp: say(0_0_1)

[09:47] <p6eval> nqp: OUTPUT«(timeout)»

[09:47] <moritz> nqp: say(0_01)

[09:47] <p6eval> nqp: OUTPUT«(timeout)»

[09:47] <dalek> niecza: 58de2de | sorear++ | lib/C (2 files):

[09:47] <dalek> niecza: Fix package stubs, all tests pass again

[09:47] <dalek> niecza: review: https://github.com/sorear/niecza/commit/58de2de29b

[09:47] <sorear> now I have met my goals for today

[09:47] * sorear sleeps

[09:48] <jnthn> sleep well

[09:48] <jnthn> moritz: oh...

[09:49] <jnthn> moritz: nqp and Rakdo share the same parsing and string -> integer code...

[09:49] <moritz> nqp: say(HLL::Actions::string_to_int('1_2', 10))

[09:49] <p6eval> nqp: OUTPUT«Null PMC access in invoke()␤current instr.: '_block11' pc 48 ((file unknown):29)␤»

[09:49] <moritz> nqp: use HLL; say(HLL::Actions::string_to_int('1_2', 10))

[09:49] <p6eval> nqp: OUTPUT«Incompatible versions of `core_ops' oplib. Found 3.3.0 but loaded 3.4.0␤current instr.: 'nqp;ModuleLoader;_block210' pc 2286 (src/stage2/gen/module_loader.pir:821)␤»

[09:49] <jnthn> wtf.

[09:49] <jnthn> nqp: use NQPHLL; say(HLL::Actions::string_to_int('1_2', 10))

[09:49] <p6eval> nqp: OUTPUT«(timeout)»

[09:49] <jnthn> Yeah, it's that one.

[09:49] <moritz> ah, I see the bug

[09:50] <jnthn> yay :)

[09:50] <moritz> while $i < $len { my $char := ...; next if $char eq '_';

[09:50] <moritz> in that case it never increments $i

[09:50] <jnthn> oops!

[09:54] <dalek> nqp: 2aa210a | moritz++ | / (2 files):

[09:54] <dalek> nqp: fix and test _ in integer literals

[09:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2aa210a467

[09:54] *** kboga joined
[09:55] * moritz loves it that the after changing the setting, the rebuild doesn't need to make a new perl6 binary

[09:55] <jnthn> moritz: :)

[09:55] <jnthn> moritz: Something is busted on Win32 that means it keeps rebuilding everything, every time.

[09:56] <moritz> jnthn: :(

[09:56] <moritz> jnthn: caused by 131a2966330086d992ac0ed2f762a5e4ec4eb216 ?

[09:57] <jnthn> moritz: Don't think it's anything new

[09:58] <jnthn> Seems to be something to do with $(DYNEXT_TARGET): $(DYNPMC) $(DYNOPS)

[10:00] <jnthn> yeah, it re-triggers that rule eveyr time. HMm.

[10:02] <jnthn> If I remove $(DYNPMC) $(DYNOPS) the issue goes away.

[10:03] <moritz> but then you don't have the dependency anymore :/

[10:03] <jnthn> Right, but one of those must be to blame...

[10:03] <jnthn> ah, keeping $(DYNPMC) is fine too. So $(DYNOPS) must trigger too easily.

[10:04] <jnthn> huh, $(DYNOPS) never seems to appear on the left hand side of a :

[10:07] <moritz> jnthn: its expanded version appears

[10:07] <moritz> Makefile.in line 380

[10:07] <jnthn> yeah

[10:07] <moritz> $(OPS_DIR)/$(OPS)$(LOAD_EXT): ...

[10:07] * jnthn tries replacing the expanded version with $(DYNOPS) just to see

[10:09] <jnthn> nope, no difference :(

[10:09] <moritz> you should commit that particular bit anyway

[10:10] <jnthn> yeah, will do

[10:10] <jnthn> but gah, what's causing this

[10:12] * jnthn is veyr confused

[10:12] <jnthn> Remove $(DYNOPS) from $(DYNEXT_TARGET) rule and the problem goes away. Put it back and remove all dependencies from $(DYNOPS) and I have the issue.

[10:13] <moritz> does $(DYNOPS) expand to a single file name?

[10:14] <jnthn> DYNOPS        = \ $(OPS_DIR)\$(OPS)$(LOAD_EXT)

[10:14] <jnthn> oh, why is it over two lines...

[10:16] <jnthn> Nope, changing that doesn't help either

[10:16] <jnthn> The expansion of that looks correct.

[10:16] <dalek> rakudo/nom: 4de98ed | moritz++ | src/CORE.setting/ (3 files):

[10:17] <dalek> rakudo/nom: implement all conversions from/to {Str,Num,Int}

[10:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4de98eda08

[10:17] <dalek> rakudo/nom: 6c2cf70 | moritz++ | LHF.markdown:

[10:17] <dalek> rakudo/nom: remove done items from LHF

[10:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c2cf70b06

[10:18] <jnthn> moritz: pir::repr_box_int__PIP(pir::repr_unbox_num__NP(self), Int);

[10:18] <jnthn> Can now be

[10:19] <jnthn> pir::perl6_box_int__PI(pir::repr_unbox_num__NP(self));

[10:19] <jnthn> Which is faster.

[10:19] <jnthn> (perl6_box_str and perl6_box_num also exist)

[10:19] <jnthn> I updated operators.pm with those but missed the coercy ones.

[10:19] <moritz> jnthn: ah, I was wondering about the difference, but used whatever was present in the file I edited

[10:20] *** Reaganomicon joined
[10:21] <jnthn> moritz: Both will work, it's just a speed difference.

[10:21] <moritz> jnthn: will fix (if I remember after lunch :-)

[10:29] *** mj41 left
[10:32] <dalek> rakudo/nom: a1a96b1 | moritz++ | / (2 files):

[10:32] <dalek> rakudo/nom: implement Num versions of most math ops. Some brave soul needs to write tests...

[10:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a1a96b127b

[10:33] <jnthn> I suspect spectest has some :)

[10:34] <jdhore1> So I just submitted a patch (of sorts) to upstream Git...I expect to be sobbing quietly from all the insults soon :(

[10:34] *** Chillance joined
[10:37] *** ascott_tainer left
[10:38] *** amkrankruleuen left
[10:39] *** amkrankruleuen joined
[10:40] *** PhatEddy joined
[10:42] <PhatEddy> rakudo: class A { method h {say 'hello'} }; my A $x.= new; my $y = $x.can('h'); say $y.perl

[10:42] <p6eval> rakudo 048573: OUTPUT«Method 'perl' not found for invocant of class 'P6Invocation'␤  in main program body at line 22:/tmp/4j9X_k_95E␤»

[10:43] <PhatEddy> should be like this maybe

[10:43] <PhatEddy> rakudo: sub a {say 'hello'}; my $x = &a; say $x.perl;

[10:43] <p6eval> rakudo 048573: OUTPUT«{ ... }␤»

[10:48] <dalek> rakudo/nom: 6c9a4d3 | jnthn++ | build/Makefile.in:

[10:48] <dalek> rakudo/nom: A couple of Makefile tweaks while trying to figure out why $(DYNOPS) triggers every time.

[10:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c9a4d33a8

[10:50] *** masak joined
[10:56] *** mj41 joined
[11:03] <yath> is * _always_ Whatever?

[11:03] *** jaldhar joined
[11:03] <yath> or are there corner cases?

[11:04] <masak> there are corner cases.

[11:04] <masak> sometimes it's multiplication :P

[11:04] <yath> besides that ;)

[11:04] <masak> well, in regexes, it's a quantifier...

[11:04] <masak> it's also a twigil.

[11:05] <yath> specifically, is bless(*, ...) equivalent to bless(Whatever.new, ...)?

[11:05] <jnthn> Yes

[11:05] <yath> s/bless/self.$&/

[11:05] <masak> aye.

[11:05] <jnthn> It's Whatever there

[11:05] <yath> hmm

[11:05] <yath> okay. thanks

[11:05] <jnthn> Well

[11:05] <jnthn> I hope it's an instance of Whatever there

[11:05] <masak> basically, Whatever is understood by a number of builtins in Perl 6.

[11:05] <jnthn> Otherwise we're gonna have a hell of a time trying to instantiate a Whatever... :)

[11:05] <masak> and they do The Appropriate Thing when they see it.

[11:06] <jnthn> oh, no, it may just work anyway :)

[11:06] <yath> jnthn: of course. just thought in that case it might be self or so.

[11:06] <masak> rakudo: my $mult = * * *; say $mult(4, 5)

[11:06] <p6eval> rakudo 048573: OUTPUT«20␤»

[11:06] <yath> masak: wtf? how does that parse?

[11:06] <masak> yath: humans get more confused than parsers, that's all.

[11:07] <masak> yath: it flips back and forth between expecting a term and expecting an op.

[11:07] <masak> nothing magical.

[11:07] <yath> masak: i understand the _intent_, but not how the parser works this way :)

[11:07] <masak> see above :)

[11:07] <yath> yes, but.. what is $foo(bar)?

[11:08] <yath> ah, * * * is implictly a block

[11:08] <yath> confusing

[11:09] <masak> ah, yes.

[11:09] <masak> * * * translates to { $^a * $^b }

[11:09] <masak> which means -> $a, $b { $a * $b }

[11:09] <masak> which could be seen as a (lesser) anonymous sub.

[11:10] <yath> anway, think i'll have to push some karma on masak++, jnthn++, TimToady++, mberends++, moritz++ and sorear++ (in no specific order) for helping me trying to understand perl6

[11:10] <yath> :)

[11:10] *** daniel-s_ joined
[11:10] <masak> we're glad you're here. keep at it :)

[11:10] <jnthn> Dang, the whatever stuff doesn't work in nom yet.

[11:12] <yath> whee. and 'my $x = -> { say $x }' is like 'my $x = sub { say $_[0] }

[11:12] <yath> ' in perl5

[11:12] <yath> that's crazy :-)

[11:12] <yath> err.

[11:12] <yath> forget that.

[11:12] <yath> whee. and 'my $x = -> $y { say $y }' is like 'my $x = sub { say $_[0] }' in perl5 :)

[11:13] *** daniel-s left
[11:14] <yath> still, one dumb question: why do i need the colon at @foo.sort: -> ...?

[11:15] <yath> does .foo: bar translate to .foo(bar)?

[11:15] <jnthn> yath: It's just another way to write the arg list

[11:15] <jnthn> You could use @foo.sort(-> ...) too

[11:15] <yath> yep, that works too.

[11:15] <jnthn> I don't personally find the colon form all that pretty :)

[11:15] <jnthn> Though some like it. :)

[11:19] <yath> hmm

[11:20] <yath> rakudo: class a { method y (@*args) { say @*args } }; my $x = a.new; $x.y: "foo"

[11:20] <p6eval> rakudo 048573: OUTPUT«Nominal type check failed for parameter '@*args'; expected Positional but got Str instead␤  in 'a::y' at line 22:/tmp/QA5HOJz2n6␤  in main program body at line 22:/tmp/QA5HOJz2n6␤»

[11:20] <yath> what is wrong with that?

[11:21] <yath> or does the colon form only work with one parameter?

[11:21] <jnthn> yath: Did you mean *@args (slurpy)?

[11:21] <yath> oh. yes.

[11:21] *** MayDaniel joined
[11:21] <yath> ah

[11:22] <yath> but why does

[11:22] <yath> rakudo: class a { method y (@*args) { say @*args } }; my $x = a.new; $x.y(<foo bar>)

[11:22] <p6eval> rakudo 048573: OUTPUT«foobar␤»

[11:22] <yath> work then?

[11:22] *** Mowah joined
[11:23] <jnthn> rakudo: say <foo bar> ~~ Positional

[11:23] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[11:23] <jnthn> rakudo: say <foo bar>.WHAT

[11:23] <p6eval> rakudo 048573: OUTPUT«Parcel()␤»

[11:23] <jnthn> That's why :)

[11:24] <yath> hmm...

[11:24] <jnthn> <foo bar> isn't a string, it's a parcel of strings

[11:24] <jnthn> And those can bind to @-sigil things

[11:24] <yath> yeah, of course

[11:24] <yath> but what is the * twigil for?

[11:27] *** MayDaniel left
[11:28] <jnthn> Dynamic scoping

[11:28] <jnthn> $foo # look in the lexical scope

[11:28] <jnthn> $*foo # look in the dynamic scope (e.g. walk the call chain)

[11:29] <yath> hm, does that make sense in prototypes?

[11:29] <yath> at least in their declaration?

[11:31] <jnthn> I don't especially see the relation there

[11:31] <jnthn> The default IO handles are examples of dynamically scoped things.

[11:31] <yath> well, i have written - by accident - method foo (@*bar)

[11:31] <jnthn> Oh, I thought you meant prototype objects :)

[11:32] <jnthn> Yes, they make sense

[11:32] <jnthn> It just means that the parameter is dynamically scoped

[11:32] <yath> nah, i'm still coming from perl5 :P

[11:32] <yath> ah

[11:32] <yath> so $foo and $*foo are actually different things?

[11:32] <jnthn> You could write a sub execute_with_different_stdout($*OUT, $code) { $code() }

[11:33] <jnthn> And call it execute_with_different_stdout($my_file_handle, { ... })

[11:33] <yath> and what does $code do? reference to $*OUT or to $OUT?

[11:33] <jnthn> I just passed it a closure

[11:33] <yath> yes, but if it does anyting with "OUT" - would it use $*OUT or $OUT?

[11:33] <jnthn> $foo and $*foo are both variable accesses 

[11:34] <jnthn> But it's how they're looked up that differs

[11:34] <yath> hmm, i can't express myself today %-)

[11:35] <jnthn> rakudo: my $a = 42; my $*b = 100; sub foo() { say $a; say $*b; }; sub bar() { my $*b = 69 }; foo(); bar();

[11:35] <p6eval> rakudo 048573: OUTPUT«42␤100␤»

[11:35] <jnthn> oops

[11:35] <jnthn> rakudo: my $a = 42; my $*b = 100; sub foo() { say $a; say $*b; }; sub bar() { my $*b = 69; foo() }; foo(); bar();

[11:35] <p6eval> rakudo 048573: OUTPUT«42␤100␤42␤69␤»

[11:35] <yath> what i meant is: do $foo and $*foo point to the same object?

[11:35] <jnthn> rakudo: my $a = 42; my $*b = 100; sub foo() { say $a; say $*b; }; sub bar() { my $*b = 69; my $a = "foo never sees this"; foo() }; foo(); bar();

[11:35] <p6eval> rakudo 048573: OUTPUT«42␤100␤42␤69␤»

[11:36] <jnthn> yath: In general, no

[11:36] <jnthn> yath: They may

[11:36] *** stepnem joined
[11:36] <jnthn> But really you're saying what sort of lookup you want

[11:37] <jnthn> See example I worte. In taht one, the $a in foo is always the varaible in its outer scope. For for $*b in bar we declared a new one, then call foo. And it sees the most recently one in the call stack.

[11:37] <yath> jnthn: so $foo and $*foo are actually as differet as $foo and @foo are?

[11:37] <jnthn> rakudo: sub foo($*x) { say $x; say $*x; }; foo(42)

[11:37] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Symbol '$x' not predeclared in foo (/tmp/MRLDS6wkPC:22)␤»

[11:37] <jnthn> Seems so :)

[11:38] <yath> ah okay. could have tried that myself :P

[11:38] <yath> thanks, jnthn++!

[11:38] <moritz> rakudo: our $x = 3; say my $*x

[11:38] <p6eval> rakudo 048573: OUTPUT«Any()␤»

[11:41] *** timbunce joined
[11:44] *** wamba joined
[11:45] *** satyavvd left
[11:46] <daniel-s_> moritz, in the perl6 book, does everything have to be in american spelling

[11:46] <daniel-s_> ie: color, favorite, etc.

[11:47] <moritz> daniel-s_: it should be consistent

[11:51] <masak> US spelling is more or less the default in the programming world.

[11:52] <masak> I live in Europe, where reaching for a Commonwealth spelling might be more... immediate.

[11:52] <TiMBuS> we have a team of translators working tirelessly to convert this to book british english

[11:52] <masak> :D

[11:52] <TiMBuS> some of the meaning might be lost in translation

[11:53] <masak> in fact, I get slightly confused when I see code with british spelling in the variable names. mathw++'s Form is like that.

[11:53] <jnthn> :P

[11:53] <masak> it's a great module with some real promise. but every time I look at it, I go "huh?" :)

[11:53] <jnthn> British English is the correct way, but America is bigger. :P

[11:53] <moritz> it's like Perl and PHP :-)

[11:53] <jnthn> :D

[11:54] <TiMBuS> s/\.\n/, 'innit?/g

[11:55] * masak is reminded of http://meta.wikimedia.org/wiki/Guerilla_spelling_campaigns

[11:55] <dalek> nqp: 3fc9a23 | jonathan++ | src/ops/nqp.ops:

[11:55] <dalek> nqp: Soften type_check a little in the face of non-6model types. Unbreaks colonpair logic in Rakudo's Actions.pm.

[11:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3fc9a236db

[11:56] <jnthn> Darn, taht commit message was misleading

[11:56] <jnthn> non-6model *values* 

[11:56] <jnthn> :)

[11:56] <masak> this channel is too small for people with non-6model values! :P

[11:57] <jnthn> :P

[11:57] <masak> I mean, I'm all for separation of repr and state, but...

[11:58] <jnthn> masak: lolbut repr and state are one and the same

[11:58] <jnthn> :P

[11:58] <masak> oh noes

[11:58] <masak> I knew it!

[11:59] <masak> anyway, I'm against all kind of softening in the face of those non-6model types... ;)

[11:59] <masak> wow, the mileage of this commit comment is impressive :P

[12:00] <jnthn> :P

[12:00] <jnthn> OK, lunch time...then I sort out :U and :D so we can have ACCEPTS back.

[12:00] <jnthn> And other such stuff.

[12:00] <dalek> rakudo/nom: 752cf6c | jnthn++ | src/ (2 files):

[12:00] <dalek> rakudo/nom: Handle fixing up of code objects that get cloned during compile time, e.g. for proto instantiation. Aside from proto generation, that seems to get multi-method dispatch working.

[12:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/752cf6ca99

[12:01] <masak> the more I look at :U pretending that it's a smiley, the more it looks like a duck.

[12:04] <moritz> but :D stands for duck, no?

[12:07] <masak> I thought it stood for 'donut'.

[12:08] <moritz> "dunnot use this"

[12:10] <masak> "dunnot" goes well with the "cannot" spelling we standardized on :P

[12:12] *** wknight8111 joined
[12:16] *** mtk left
[12:16] *** daniel-s_ is now known as daniel-s

[12:17] <daniel-s> why is it that in this example, I still need to fully qualify a method if I import it from a package

[12:17] <daniel-s> http://pastebin.ca/2075520

[12:17] <daniel-s> say md5_hex("hi"); #doesn't work

[12:20] <masak> because the .md5_hex method isn't exported.

[12:21] <masak> in fact -- and I think it's been up for discussion before -- it's unclear why Digest::MD5 is a class and not just a module.

[12:21] *** molaf joined
[12:22] <masak> it doesn't have any state. nothing happens if you instantiate it. there wouldn't be any special benefit of subclassing it.

[12:22] <moritz> it's just overengineering

[12:23] <flussence_> in the original perl5 version, you can instantiate an object and feed it data in chunks. Maybe it was intended to do that at some point

[12:26] <tadzik> hello

[12:27] <moritz> \o/ it's tadzik 

[12:27] <flussence_> oh hai, I was just about to bug you about something :)

[12:27] <moritz> don't implant bug in my gsoc student! :-)

[12:28] <colomon> nom build process seems messed up for me?

[12:28] <flussence_> I just updated panda (mine was wayyy out of date), and it seems it hasn't installed Shell::Command which it needs, probably other stuff too.

[12:28] <tadzik> I knew it's panda :)

[12:28] <colomon> Configuring NQP ...

[12:28] <colomon> perl Configure.pl --parrot-config=../parrot_install/bin/parrot_config

[12:28] <colomon> Option parrot-config does not take an argument

[12:28] <tadzik> flussence_: oh, let me look into that

[12:28] <tadzik> flussence_: yeah, the deps are broken. LHF if you want it :)

[12:29] *** mtk joined
[12:29] <moritz> colomon: did you call nom's configure with --gen-nqp?

[12:29] <colomon> moritz: yes

[12:29] <colomon> but I didn't make realclean first

[12:30] <moritz> it's and odd error

[12:30] <tadzik> were ops implemented for every separate type in master too, or we're doing that in nom for perf reasons?

[12:31] <moritz> rakudo: say (1+1).perl

[12:31] <p6eval> rakudo 048573: OUTPUT«2␤»

[12:31] <moritz> rakudo: say (1+1).WHAT

[12:31] <p6eval> rakudo 048573: OUTPUT«Int()␤»

[12:31] <moritz> I guess it either did smart coercion, or had its own variant

[12:32] *** pernatiy joined
[12:32] <colomon> tadzik: math ops?

[12:33] <flussence_> huh, it looks like the deps were all there, it just broke because File::Tools was outdated on my end.

[12:33] <colomon> tadzik: they should be implemented for every separate type.

[12:34] <colomon> moritz: I'm kind of worried that if I blow everything away, the pcre bug will be harder to work around with the new --gen-nqp option.

[12:37] <tadzik> colomon: I see

[12:37] <dalek> book: 4ed4419 | moritz++ | src/ (11 files):

[12:37] <dalek> book: [src] start to properly cross-link sections

[12:37] <dalek> book: review: https://github.com/perl6/book/commit/4ed4419538

[12:37] <tadzik> flussence_: no, no

[12:37] <tadzik> File::Tools is now deprecated in favor of Shell::Command

[12:38] <tadzik> ...I think :

[12:38] <tadzik> :)

[12:38] <flussence_> but Shell::Command is *in* File::Tools.

[12:38] <tadzik> oh, ok :)

[12:38] <tadzik> crap, I don't remember my own modules

[12:38] <moritz> rakudo: say 2 % 1.1

[12:39] <p6eval> rakudo 048573: OUTPUT«0.9␤»

[12:39] <tadzik> flussence_: yeah, updating modules is tricky since we're not versioning them

[12:39] <tadzik> maybe panda needs a 'bigupdate' target which blindly updates all the installed modules

[12:39] <tadzik> or just those with no git repo updates

[12:40] *** wamba left
[12:41] *** PhatEddy left
[12:42] <flussence_> (I was going to suggest "use gentoo's dependency syntax", but that's insane :)

[12:48] <tadzik> :)

[12:48] <tadzik> ## More basic math ops

[12:48] <tadzik> See t/00-parrot/02-op-math.t and operators.pm. Add enough to make that

[12:50] <jnthn> ...? :)

[12:50] <moritz> c&p gone RONG?

[12:50] *** Moukeddar joined
[12:50] <tadzik> ...what was that

[12:50] <Moukeddar> Hello :)

[12:51] <tadzik> bad middle mouse key, bad

[12:51] <tadzik> hi Moukeddar 

[12:51] * tadzik gets on gsoctrack

[12:51] <Moukeddar> how are you doing?

[12:51] <moritz> hacking!

[12:52] <tadzik> hack hack

[12:52] <masak> hey Moukeddar 

[12:52] <Moukeddar> hey , my hero

[12:52] <Moukeddar> how is it today?

[12:52] <dalek> rakudo/nom: 85cebb8 | moritz++ | src/CORE.setting/ (2 files):

[12:52] <dalek> rakudo/nom: replace repr_box with perl6_box ops

[12:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85cebb83da

[12:52] <dalek> rakudo/nom: a6180c8 | moritz++ | src/CORE.setting/operators.pm:

[12:52] <dalek> rakudo/nom: implement Num % Num

[12:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a6180c89a0

[12:53] <masak> Moukeddar: it's too warm. I can't think. :)

[12:53] * masak brings out the rain dance equipment

[12:53] * jnthn wants an appartment with air con.

[12:53] <Moukeddar> lol , you should try 45􏿽xB0C

[12:53] <moritz> jnthn: btw the rest of t/00-parrot/01-literals.t depends on say() with more than one argument

[12:54] <jnthn> moritz: Yeah

[12:54] <moritz> SLURP!

[12:54] <jnthn> moritz: Can't ahve that until we have slurpies, which mean arrays

[12:54] <Moukeddar> your brain will shutdown

[12:54] <jnthn> masak: I'm going to get rich and then buy a summer house in Kiruna :P

[12:54] <tadzik> a car termometer said it's 30 C today, I thought it was joking. It was not

[12:54] <flussence_> .oO( my office picked a good time to close for a week )

[12:55] <Moukeddar> well, you gotta test the heat

[12:55] <masak> Moukeddar: yes, I guess I should be happy, relatively speaking. :)

[12:55] <jnthn> masak: oh, wtf...still too far south. It's 23°C there!

[12:55] <Moukeddar> brb , lunch

[12:55] <masak> jnthn: arrrgh! even Kiruna can't be trusted?

[12:55] <jnthn> masak: No! O.O

[12:56] <tadzik> my mentors?

[12:56] <jnthn> Rrejkjavik looks rather more comfortable at present. :)

[12:56] <tadzik> S26 doesn't say anything about Comment blocks being anything special, so I assume their insides must be a valid Pod insides, no?

[12:56] <tadzik> I thought inside the comment block whatever works, but seems that what code blocks are

[12:57] <tadzik> my point: there can't be no invalid pod in comment blocks

[12:57] <moritz> tadzik: I'd agree: comment blocks are ignored except for finding their end

[12:57] <moritz> ie they don't produce any Pod AST

[12:59] <masak> hm. is there anything supporting that view in S26?

[12:59] <tadzik> so they're parsed exactly like code blocks, whatever works until =end?

[13:00] <tadzik> All Pod blocks are intrinsically Perl 6 comments, but

[13:00] <tadzik> D<Pod comments|Pod comment> are comments that Pod renderers ignore too.

[13:00] <tadzik> renderers. But parsers?

[13:00] <moritz> masak: just common sense :-)

[13:00] <tadzik> The spec doesn't say

[13:00] <tadzik> I suppose yes

[13:01] <tadzik> but that said, there has to be a special kind of delimited comment, paragraph comment and abbreviated comment

[13:02] <masak> tadzik: the part you quoted is goodenuf for me.

[13:02] <masak> not sure S26 makes a real distinction between Pod parsers and Pod renderers.

[13:03] <arnsholt> Doesn't S26 say that comments should be available through the POD API?

[13:03] <tadzik> yes

[13:03] <moritz> ah, so there might be a need for a Pod::Comment block or so

[13:04] <tadzik> yeah, that's fine. The thing that bothers me is that it needs special grammar rules

[13:04] <arnsholt> So they pretty much have to be just like other blocks, modulo the special magic that their rendering method has to be a noop

[13:04] <moritz> comments do, in generaly

[13:04] <tadzik> three of them. raw-delimited, raw-paragraph, raw-abbreviated

[13:05] <tadzik> that's the repr, yes

[13:05] <tadzik> ...no :)

[13:05] <tadzik> or, whatever

[13:06] <tadzik> they're quite similar to =END block

[13:09] *** stepnem left
[13:10] <arnsholt> Also, I'm rather looking forward to working with Pod6

[13:11] *** stepnem joined
[13:13] <tadzik> you can do that now :)

[13:13] <tadzik> well, it parses

[13:14] <arnsholt> =D

[13:15] <tadzik> passes more spectests than master :)

[13:15] *** gbacon joined
[13:16] *** [particle] joined
[13:16] <tadzik> I wonder if parsing comments can be done w/o backtracking

[13:16] <moritz> why not?

[13:16] <tadzik> I suppose much <!before> magic will do

[13:16] <moritz> <start> .*? <stopper>

[13:16] <moritz> ok, strictly speaking .*? is backtracking

[13:16] <tadzik> yeah

[13:17] *** [particle]1 left
[13:22] <tadzik> survey: inspecting a Pod6::Comment object, would you expect the content to be line-splitted?

[13:22] <moritz> no

[13:22] <arnsholt> I'll answer with another question: Can I expect the contents of a normal block to be so?

[13:23] * tadzik checks the tests

[13:23] <tadzik> nope, it's paragraph-splitted then

[13:24] *** Moukeddar left
[13:26] *** koban` left
[13:26] <tadzik> the thing is Pod6::Block.content is an array of elems, so in case of Code/Comment only the 1st element will be set

[13:28] *** wamba joined
[13:31] <masak> maybe it shouldn't always be an array?

[13:32] <tadzik> the content of a block is usually a bunch of other pod nodes

[13:32] <slavik> TimToady: I know this channel is not for it, but is there like a quick guide on optimizing perl5 code for faster execution? I finally wrapped my head around the lexicographic permutation generation, and was wondering if there are any perl5 tricks I can use to make code run faster.

[13:34] <masak> slavik: perldoc perlperf?

[13:35] *** JimmyZ joined
[13:35] <slavik> masak: will take a look

[13:36] <masak> these days I just assume that there's a perldoc section for my problem at hand. there usually is :P

[13:36] <moritz> Algorithm::Permute, Algorithm::Loops

[13:36] <slavik> GAH!!!!!!!!!

[13:37] <masak> hah, opening quote of perldoc perlperf: "Do Not Engage in Useless Activity" :P

[13:40] *** Moukeddar joined
[13:40] *** envi left
[13:41] <masak> Moukeddar: have you seen my recent blog posts, about learning Perl 6 from the start?

[13:45] *** envi joined
[13:45] <tadzik> the girl who has to write an irc bot in Perl 6 coud make use of that

[13:46] <Moukeddar> no masak 

[13:46] <Moukeddar> give me the link please

[13:46] <masak> http://strangelyconsistent.org/blog/list-of-posts

[13:46] <masak> 31 May and on.

[13:47] *** wamba left
[13:47] <colomon> just tried a nom build from scratch, still seems borked for me

[13:47] * masak tries, too

[13:48] <jnthn> colomon: How's it broke?

[13:48] <Moukeddar> btw , activestate is the one building binaries for windows?

[13:48] <Moukeddar> it doesn't have perl6

[13:49] <masak> Moukeddar: that's right. but there are Windows binaries for Rakudo.

[13:49] <colomon> jnthn: https://gist.github.com/1010296

[13:49] <Moukeddar> what's rakudo star?

[13:51] <PerlJam> Moukeddar: a large, bright burst of light followed by butterflies

[13:51] <masak> Moukeddar: it's a distribution of Rakudo with a couple of modules included.

[13:52] <Moukeddar> the nicest desciption evar:p

[13:52] <jnthn> colomon: Ah...I think pmichaud diddled with NQP's Configure and I didn't try re-configuring since then... :)

[13:52] <masak> yeah, it'll be hard to top "Star" as a name :)

[13:52] <jnthn> colomon: It may be fallout from those changes.

[13:52] <masak> "Rakudo Octothorpe"...

[13:53] <PerlJam> The commercial version will be called "Rakudo $" of course  :)

[13:54] <masak> :D

[13:54] *** PacoLinux joined
[13:54] <Moukeddar> lol

[13:55] <jnthn> .oO( And the smoker's version will be called "Rakudo |"... )

[13:55] <PerlJam> jnthn: or perhaps  "Rakudo #|"

[13:55] <PerlJam> (but it all depends on what you're smoking)

[13:56] <Su-Shee> and _I_ can wear a "Rakudo Starlet" shirt ;) 

[13:56] <Moukeddar> starlet?

[13:57] <PerlJam> Moukeddar: Su-Shee just likes to think we're in Hollywood

[13:57] <Su-Shee> PerlJam: now don't shatter my dreams and hopes.. ;)

[13:57] <Moukeddar> oh yeah , selling with the body

[13:57] <Su-Shee> also, all americans are in hollywood, I've seen it on tv.

[13:58] <Moukeddar> hehehe

[13:58] <PerlJam> Su-Shee: That's why the San Andreas fault is so unstable; too many people standing on it.

[13:58] <Su-Shee> PerlJam: ah. of course. that explains it. 

[13:59] <Moukeddar> masak, i changed your blog sample from "'sauna" to "sauce" , better that way

[13:59] <colomon> jnthn: ah, third times the charm

[13:59] <Moukeddar> L.A was invaded by aliens

[14:00] <Moukeddar> "if $had-enough eq "yes""

[14:01] <Moukeddar> it is expressive

[14:02] <Moukeddar> so ,my in perl is like dim in vb and let in F# right?

[14:02] <PerlJam> Moukeddar: sort of.

[14:03] <masak> Moukeddar: both declare things, yes.

[14:03] <masak> Moukeddar: but in VB, you can use variables without 'dim', IIRC.

[14:03] <Moukeddar> shiny stuff attract me :p

[14:03] <Moukeddar> yes you can declare without dim

[14:04] <masak> well, you can use without declaring.

[14:04] <masak> you can't in Perl 6.

[14:04] <jnthn> colomon: What did it need to make it work?

[14:04] <Moukeddar> and i guess it's a good thing

[14:04] <colomon> jnthn: a really fresh start

[14:04] <jnthn> colomon: ah, ok :)

[14:04] <masak> Moukeddar: for the reason I explained in the post, yes. :)

[14:05] <Moukeddar> and also (1 .. 100).roll

[14:05] <colomon> jnthn: what happened before is, I made a .... oh, crap, hold on.  I think the time it worked I built master instead of nom.

[14:05] <Moukeddar> it picks a random digit , right ?

[14:05] <colomon> jnthn: well, I'm trying again, we'll see what happens this time.

[14:05] <masak> Moukeddar: a random number between 1 and 100, yes :)

[14:05] <colomon> ERRTOOMANYSTEPS

[14:05] <Moukeddar> shiny , it's kinda like LINQ , just more compact

[14:06] <jnthn> colomon: I think the idea is that you'll just do --gen-nqp in Rakudo and it'll sort out Parrot for you.

[14:06] <colomon> jnthn: that definitely didn't work for me

[14:06] <masak> rakudo: say (1 .. 100).roll(10).perl

[14:06] <p6eval> rakudo 048573: OUTPUT«(49, 59, 64, 48, 73, 66, 99, 95, 64, 8)␤»

[14:07] <Moukeddar> nice

[14:07] <masak> Moukeddar: there's also .pick(10) that takes 10 but never takes the same more than once.

[14:07] <Moukeddar> rakudo: say "Hello World".roll(5).perl

[14:07] <p6eval> rakudo 048573: OUTPUT«("Hello World", "Hello World", "Hello World", "Hello World", "Hello World")␤»

[14:08] <masak> Moukeddar: strings aren't lists :)

[14:08] <masak> rakudo: say "Hello World".comb.roll(5).perl

[14:08] <p6eval> rakudo 048573: OUTPUT«("W", "d", "l", "o", "d")␤»

[14:08] <Moukeddar> aren't they more line an array of chars?

[14:08] <masak> nope.

[14:08] <colomon> jnthn: arrrrrrrrrrrrrrrgh!

[14:08] <jnthn> colomon: :(

[14:08] <Moukeddar> but in other languages they are

[14:08] <PerlJam> Moukeddar: strings are too complicated to be just an array of chars

[14:08] <colomon> jnthn: okay, once more with feeling

[14:09] <Moukeddar> right , right

[14:09] <jnthn> colomon: Here's what I suspect you'll have to do at the moment. Build an NQP with --gen-parrot. make install it. Then point Rakudo's --parrot-config=... at the Parrot NQP build.

[14:09] <masak> jnthn: oh! I'm also getting an error building nom!

[14:09] <jnthn> colomon: Ore maybe build them all separately.

[14:09] *** PacoLinux left
[14:09] <jnthn> masak: oh noes!

[14:09] <jnthn> masak: Co je to?

[14:10] <Moukeddar> there's no way to get intellisense for perl ,right ?

[14:10] <masak> jnthn: from what you just wrote, it's the same problem.

[14:10] *** PacoLinux joined
[14:10] <masak> Moukeddar: not that I know of. but Padre (the editor) has surprised me before.

[14:10] *** hudnix joined
[14:11] <Su-Shee> I often sense intelli in perl... ;) (what's intellisense?!)

[14:11] <Moukeddar> heheh,

[14:12] *** masonkramer left
[14:12] <Moukeddar> it's the dark magic

[14:12] <Moukeddar> the voodoo of coders

[14:13] <Su-Shee> "aha". 

[14:13] <PerlJam> Moukeddar: I guess that explains why I don't know what it is either ...  I'm a programmer, not a coder.

[14:13] <masak> Su-Shee: it's tab completion for type names, attribute names, and method names.

[14:14] <Moukeddar> another symantic pittfall

[14:14] <masak> usually not with the Tab key, though :)

[14:14] <PerlJam> vim has something like that.

[14:14] <Moukeddar> what's a coder ?

[14:14] <Su-Shee> ah. a feature I utterly hate.

[14:14] <Moukeddar> and what's a programmer?

[14:14] <Su-Shee> PerlJam: yes, with ctrl-p

[14:15] <masak> Intellisense is one of those features you get hooked on, and then you can't program with editors that don't have it :P

[14:15] <PerlJam> Moukeddar: Any definition I give you would just be made up by me right now.  :)

[14:15] <Moukeddar> make sense then :p

[14:15] <JimmyZ> Good evening

[14:15] <Moukeddar> masak, it's like crack

[14:15] <masak> Moukeddar: a coder is someone who writes things that a decoder will read. duh :P

[14:15] <Su-Shee> masak: unless you type pretty well and pretty fast then it plainly gets in the way. 

[14:15] <Moukeddar> there's no going back

[14:15] *** xinming joined
[14:15] <PerlJam> Su-Shee: ding!

[14:15] <Su-Shee> PerlJam: I won something? :)

[14:16] <masak> Su-Shee: I've seen good implementations and bad implementations of it. just like with most other things.

[14:16] <Moukeddar> with big fat visual studio 10 , it'll definitely get in your way

[14:16] <masak> JimmyZ: 你好!

[14:16] <jnthn> masak: Hey, I can program with and without intellisense. :)

[14:17] <Su-Shee> muhaha. ok, yes. ;) me too :)

[14:17] <Moukeddar> Super Coders

[14:17] <colomon> jnthn: confirmed that it breaks with a clean checkout

[14:17] <Su-Shee> Moukeddar: you realize that plenty of people don't even know windows and their programming stuff? ;)

[14:17] <jnthn> It's kinda nice to have because I don't have to bother learning the .Net class libraries. :)

[14:18] <Moukeddar> Su-Shee, i do realize that ,

[14:18] <Moukeddar> well the BCL is kinda like the perl modules and ruby packages 

[14:18] <Moukeddar> you'll have to

[14:19] <benabik> Is `sub func(\$a)` normal Perl 6 or something special in Rakudo/NQP?  Closest thing I see in the spec is `\|$a` to grab the raw arguments Parcel.

[14:21] <jnthn> benabik: It's spec

[14:22] <jnthn> benabik: NQP doesn't have it. nom has it in Rakudo, and master has it also.

[14:22] <dalek> rakudo/nom: 351dd72 | jnthn++ | src/Perl6/ (2 files):

[14:22] <dalek> rakudo/nom: Pass along :U and :D constraints so they're represented in the parameter object.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/351dd72d63

[14:22] <dalek> rakudo/nom: 00677d3 | jnthn++ | src/ (2 files):

[14:22] <dalek> rakudo/nom: Add flags to represent definedness/undefinedness constraints.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/00677d3b25

[14:22] <dalek> rakudo/nom: dc11240 | jnthn++ | src/binder/bind. (2 files):

[14:22] <dalek> rakudo/nom: Teach binder about :U and :D.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc11240f80

[14:22] <dalek> rakudo/nom: b747c6a | jnthn++ | src/binder/multidispatch. (2 files):

[14:22] <dalek> rakudo/nom: Teach multi-dispatcher about :U and :D, so we can now do multi-dispatch based on them.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b747c6abb4

[14:22] <benabik> jnthn: It is a large spec, so I'll buy that I missed it.  From context (recent nom commit), I'm guessing it grabs a non-containered value?

[14:22] <jnthn> benabik: No. It says "bind whatever you get passed directly"

[14:23] <jnthn> benabik: If it's a container you'll be able to assign to it. If it's not a container, you won't.

[14:23] <jnthn> benabik: It turns out that in Rakudo it's the fastest way to accept parameters.

[14:24] <jnthn> So we use it for various built-ins.

[14:24] <jnthn> Generally, CORE.setting will do anything that's reasonable to perform decently, even if we'd not encourage people to do it in their everyday code.

[14:24] <benabik> jnthn: Skips creating new variables and such, so is faster?  Interesting.

[14:24] <jnthn> benabik: Yes.

[14:25] <benabik> jnthn++ # Taking time to answer random questions

[14:25] *** wtw left
[14:31] <JimmyZ> masak:  您好

[14:33] * masak now feels he shoulda 您'd JimmyZ too :)

[14:34] <mathw> masak: I am not changing my spelling for you :P

[14:34] <mathw> what I should do is actually do some work on Form at some point

[14:34] <mathw> I keep saying that

[14:34] <masak> mathw: I'm not asking you to change the spelling. :)

[14:34] <masak> mathw: in fact, if more people used UK spellings, the surprise factor would be smaller.

[14:35] <mathw> :)

[14:35] <mathw> Well the simple thing is that there are too many Americans

[14:35] <mathw> and too many non-Americans who've learned English from American teachers

[14:35] <mathw> and they're ALL WRONG :P

[14:35] <masak> I dunno about that, there seem to be lots of Commonwealth peeps out there too.

[14:35] <mathw> I know English spelling is crazy, but why have two forms of crazy?

[14:36] <mathw> hah well there are a load of variants for the Commonwealth countries too

[14:36] <masak> I think it's far too late for the "why two forms of crazy" question.

[14:36] <mathw> yes

[14:36] <mathw> but it's not too late for me to masak++ you for your awesome tutorial blog posts

[14:37] <mathw> it's a fantastically no-nonsense approach to programming tutorial

[14:37] <mathw> I love it

[14:37] <masak> thanks! :)

[14:37] <mathw> I love how Perl 6-y it is too

[14:37] <mathw> 6-y is the new sexy :)

[14:37] * masak happy

[14:37] *** kboga left
[14:38] <masak> it's actually less work than the November blog posts, because I don't have to code before I blog.

[14:39] <mathw> vi skribis bone (I think?)

[14:39] <masak> dankon :)

[14:39] <mathw> and you're doing it in a second language too

[14:39] <masak> oh right. I am :P

[14:39] <mathw> damned people with their fluency in multiple languages mumble mumble :)

[14:40] <masak> jnthn did correct a typo I had made, though: s/swoop up/scoop up/ the results

[14:40] <masak> jnthn++

[14:40] <mathw> heh that's actually a nice image

[14:40] <mathw> swoop up the results :)

[14:40] <masak> like an eagle, swooping up a mouse :P

[14:41] <mathw> yes

[14:42] <masak> anyway, I'm glad I'm back to blogging. I'm also glad I refrained from doing a clichéd "it's been a long time since I last blug" blog post.

[14:42] <mathw> :)

[14:42] <mathw> good for you

[14:43] *** mkramer joined
[14:44] <tadzik> most of the 2/3 of Week #3 done :)

[14:44] * moritz wonders if we had a too liberal schedule for tadzik++ :-)

[14:45] <tadzik> I was peeking at masak's :)

[14:45] *** daniel-s left
[14:45] <tadzik> now indentation-based code blocks are quite tricky

[14:46] *** PhatEddy joined
[14:46] *** Moukeddar left
[14:47] <tadzik> also, tables

[14:47] *** Moukeddar joined
[14:47] <tadzik> but the psychological bareer is broken, if I count right :)

[14:48] <masak> tadzik++ # keep up the good work, don't mind the schedule so much :)

[14:48] <mathw> tadzik: what are you doing?

[14:49] <PhatEddy> rakudo: my $a; eval $a.WHO

[14:49] <p6eval> rakudo 048573: OUTPUT«Null PMC access in invoke()␤  in 'eval' at line 1213:CORE.setting␤  in 'eval' at line 1213:CORE.setting␤  in main program body at line 22:/tmp/dPvhCT3k6G␤»

[14:50] <PhatEddy> rakudo: my $a; say $a.WHO ~ 'after'

[14:50] <p6eval> rakudo 048573: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Any $x = { ... })␤:(Any $a, Any $b)␤␤  in main program body at line 22:/tmp/f0nlWgcfJL␤»

[14:52] <PhatEddy> Hopefully I check RT better/harder this time ...

[14:54] <masak> rakudo: my $a; say $a.WHO.PARROT

[14:54] <p6eval> rakudo 048573: OUTPUT«Method 'PARROT' not found for invocant of class 'Any'␤  in main program body at line 22:/tmp/mjFBTn_NC5␤»

[14:54] <masak> rakudo: say Any.PARROT

[14:54] <p6eval> rakudo 048573: OUTPUT«␤»

[14:54] *** Moukeddar left
[14:54] <masak> PhatEddy: you're onto something here.

[14:54] <masak> PhatEddy: this one I haven't seen before...

[14:54] <masak> rakudo: say (my $a).WHO

[14:54] <p6eval> rakudo 048573: OUTPUT«Any␤»

[14:54] <moritz> don't submit any bugs related to .PARROT

[14:54] <moritz> it's not spec

[14:55] <masak> nodnod

[14:55] <masak> but see above -- something's going on here.

[14:55] <masak> rakudo: say Any.chars

[14:55] <p6eval> rakudo 048573: OUTPUT«Method 'chars' not found for invocant of class ''␤  in main program body at line 22:/tmp/RGV_hDNNHR␤»

[14:55] <masak> rakudo: say Any ~ ""

[14:55] <p6eval> rakudo 048573: OUTPUT«Any()␤»

[14:55] <masak> rakudo: say (my $a).WHO ~ ""

[14:55] <p6eval> rakudo 048573: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Any $x = { ... })␤:(Any $a, Any $b)␤␤  in main program body at line 22:/tmp/ntNtFyrsov␤»

[14:56] <masak> moritz: how would you explain that?

[14:56] <moritz> masak: with Mu

[14:56] <tadzik> mathw: just pushed code blocks and comment blocks

[14:56] <moritz> masak: or non-p6 types

[14:56] <moritz> rakudo: say (my $a).WHO ~~ Mu

[14:56] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[14:56] <moritz> rakudo: say pir::typeof (my $a).WHO

[14:56] <jnthn> masak: .WHO doesn't behave very in current Rakudo

[14:56] <p6eval> rakudo 048573: OUTPUT«NameSpace␤»

[14:56] <tadzik> masak: I wouldn't mind having twice or thrice active schedule I have if I didn't have all the university crap on my head

[14:57] <moritz> right, it's a parrot-level type

[14:57] <tadzik> 4 exams on friday, 2 of them deadly

[14:57] <jnthn> rakudo: say (my $a).WHO.WHAT

[14:57] <p6eval> rakudo 048573: OUTPUT«Method 'WHAT' not found for invocant of class 'Any'␤  in main program body at line 22:/tmp/lS9vi8OFvo␤»

[14:58] <PhatEddy> rakudo: class A{}; my A $a .= new; eval $a.WHO

[14:58] <p6eval> rakudo 048573: OUTPUT«Null PMC access in invoke()␤  in 'eval' at line 1213:CORE.setting␤  in 'eval' at line 1213:CORE.setting␤  in main program body at line 22:/tmp/BfB1bYJ9_N␤»

[14:58] <JimmyZ> nopaste?

[14:59] *** acrussell joined
[14:59] <PhatEddy> rakudo: class A{}; my A $a .= new; say $a.WHO

[14:59] <p6eval> rakudo 048573: OUTPUT«A␤»

[14:59] <PhatEddy> rakudo: class A{}; my A $a .= new; say $a.WHO ~ ''

[14:59] <p6eval> rakudo 048573: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Any $x = { ... })␤:(Any $a, Any $b)␤␤  in main program body at line 22:/tmp/6WQHZMJuVx␤»

[15:00] <JimmyZ> masak: which one is a bug ? https://gist.github.com/1010409

[15:01] * masak looks

[15:01] <masak> JimmyZ: my guess is that Rakudo simply doesn't recognize the last form yet.

[15:02] *** wknight8111 left
[15:02] <PhatEddy> Unless I hear back differently will file who problems with RT ...

[15:02] <masak> PhatEddy: sure, go ahead.

[15:04] * JimmyZ wonders what's the difference between : $a and  :$a

[15:05] <moritz> the \ and a space

[15:05] <JimmyZ> std: sub foo ( \:$a ) { ... }

[15:05] <p6eval> std c843201: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed parameter at /tmp/xxG0Z27Wqo line 1:␤------> [32msub foo ( [33m⏏[31m\:$a ) { ... }[0m␤    expecting any of:␤   name␤   parameter␤      routine_def␤    signature␤Parse failed␤FAILED 00:01 113m␤»

[15:06] <JimmyZ> std: sub foo ( \ :$a ) { ... }

[15:06] <p6eval> std c843201: OUTPUT«ok 00:01 114m␤»

[15:06] <JimmyZ> masak: I am not sure is that rakudo simply doesn't recognize the last form

[15:09] <JimmyZ> masak:  i updated https://gist.github.com/1010409

[15:12] <jnthn> By the way, in nom:

[15:12] <jnthn> > say (my $a).WHO.WHAT

[15:12] <jnthn> Stash()

[15:14] <dalek> rakudo/nom: 3561701 | jnthn++ | src/ (2 files):

[15:14] <dalek> rakudo/nom: Turns out we need to derive_dispatcher a bit earlier in the bootstrap, at least for now.

[15:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/35617016e8

[15:14] <dalek> rakudo/nom: 39768a2 | jnthn++ | build/Makefile.in:

[15:14] <dalek> rakudo/nom: Some notes on ordering of setting files.

[15:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39768a2520

[15:14] <dalek> rakudo/nom: 75bf1b6 | jnthn++ | src/CORE.setting/ (4 files):

[15:14] <dalek> rakudo/nom: Mu.ACCEPTS, Mu.Str, update various other Str methods. 'say $foo.WHAT' now works.

[15:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/75bf1b66f4

[15:15] *** awwaiid joined
[15:16] <masak> JimmyZ: those signatures might mean something, but I'm having difficulty understanding what.

[15:16] <JimmyZ> masak: me too.

[15:17] <masak> JimmyZ: that makes it hard for me to pick out any bug or mismatch among all of those signatures :)

[15:17] <JimmyZ> masak:  hehe

[15:17] * moritz wonders if that backslash+space thing is actually and unspace

[15:18] <moritz> or accidentally parsed as one

[15:18] <jnthn> std: sub foo(:) { }

[15:18] <p6eval> std c843201: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed parameter at /tmp/9t_a1SC6vD line 1:␤------> [32msub foo(:[33m⏏[31m) { }[0m␤    expecting any of:␤     formal parameter␤       named_param␤Parse failed␤FAILED 00:01 113m␤»

[15:18] <jnthn> std: sub foo( : ) { }

[15:18] <p6eval> std c843201: OUTPUT«ok 00:01 113m␤»

[15:18] <JimmyZ> me is not sure whether is an unspace or not.

[15:19] <jnthn> (difference between : \$a and \ :$a) my guess is that the first is the invocant colon and a positional is-parcel param, the second is an is-parcel named parameter.

[15:20] <JimmyZ> rakudo: my $a = 1; say $a = $a\ ++; say $a;

[15:20] <p6eval> rakudo 048573: OUTPUT«1␤1␤»

[15:21] *** MayDaniel joined
[15:21] <TimToady> you can't rely on order of side effects, so either 1 1 or 1 2 are "correct"

[15:21] <TimToady> maybe even 2 2

[15:22] <TimToady> maybe not

[15:22] <moritz> "here be dragons"

[15:22] * moritz links that sentence in perlsyn

[15:23] <JimmyZ> rakudo: my $a = 1; say $a = ++$a; say $a;

[15:23] <p6eval> rakudo 048573: OUTPUT«2␤2␤»

[15:23] <JimmyZ> that 2 2

[15:24] <sorear> good * #perl6

[15:24] <TimToady> I think that one has to be 2 2

[15:24] <masak> sorear! \o/

[15:24] * PerlJam would expect something with a 2 in the second position either way

[15:24] <PerlJam>  1 1 would be too weird

[15:25] <JimmyZ> rakudo: sub foo ( : \$a ) { say $a }; foo(3);

[15:25] <p6eval> rakudo 048573: OUTPUT«Lexical 'self' not found␤  in 'foo' at line 1:/tmp/Fit8qLeo4K␤  in main program body at line 22:/tmp/Fit8qLeo4K␤»

[15:25] <sorear> o/ masak

[15:25] <moritz> niecza: my $a = 1; say $a = ++$a; say $a;

[15:25] <p6eval> niecza v6-66-g58de2de: OUTPUT«2␤2␤»

[15:25] <jnthn> JimmyZ: Ah, that confirms it.

[15:25] <jnthn> JimmyZ: It's parsed as the invocant colon.

[15:26] <TimToady> that's what I'd expect

[15:27] <jnthn> TimToady: Yeah, works for me too :)

[15:27] <jnthn> Though error is a bit LTA.

[15:27] <TimToady> not as LTA as STD's  :)

[15:28] * JimmyZ doesn't know what vocant means :(

[15:28] <JimmyZ> s/vocant/invocant/

[15:28] <TimToady> related to "vocal"

[15:28] <TimToady> "something you call"

[15:28] <moritz> JimmyZ: an invocant is the object that you call a method on

[15:28] <PerlJam> JimmyZ: invocant -> invoke

[15:29] <TimToady> we made up the word for one of the Camel books

[15:29] <moritz> JimmyZ: so in $a.b the inocant is $a

[15:29] <TimToady> so you won't find it in a dictionary

[15:29] <sorear> rakudo: my %h; say %h.^parents

[15:29] <p6eval> rakudo 048573: OUTPUT«EnumMap()Iterable()Cool()Any()Mu()␤»

[15:29] <mathw> TimToady: did you? Wow. I use it all the time.

[15:30] <sorear> rakudo: my $e = enum < ook! ook. ook? >; say $e.WHAT

[15:30] <p6eval> rakudo 048573: OUTPUT«EnumMap()␤»

[15:30] <PerlJam> TimToady: it's in the wiktionary!  http://en.wiktionary.org/wiki/invocant   :)

[15:30] <masak> JimmyZ: 'invocant' = 呼叫的事

[15:30] <TimToady> niecza: sub foo ( : \$a ) { say $a }; foo(3);

[15:30] <p6eval> niecza v6-66-g58de2de: OUTPUT«3␤»

[15:30] <masak> JimmyZ: or something like that :)

[15:30] <TimToady> that's...wrongish

[15:31] <tadzik> jnthn: shouldn't make realclean remove CORE.Setting.pbc?

[15:31] <TimToady> niecza: sub foo ( $: \$a ) { say $a }; foo(3);

[15:31] <p6eval> niecza v6-66-g58de2de: OUTPUT«Unhandled exception: No value for parameter \$a in MAIN foo␤  at /tmp/cXVDsP1JAC line 0 (MAIN foo @ 0) ␤  at /tmp/cXVDsP1JAC line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1664 (CORE C758_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting

[15:31] <p6eval> ..line 1665 (CO…

[15:31] <TimToady> sorear: invocant : should probably imply $ to the left

[15:32] <jnthn> tadzik: yes

[15:32] <sorear> TimToady: does STD parse the former case as having an invocant colon?

[15:32] <TimToady> sorear: I believe so

[15:32] <tadzik> jnthn: fixing

[15:32] <sorear> niecza doesn't currently process arg separators at all except in method_def

[15:33] <jnthn> Rakudo has them handled in signature

[15:33] <TimToady> possibly STD can detect a bogus : now

[15:33] <dalek> roast: c4cf773 | sorear++ | S12-enums/anonymous.t:

[15:33] <dalek> roast: Make the fifth test in S12-enums/anonymous.t test what it looks like it was supposed to test

[15:33] <dalek> roast: review: https://github.com/perl6/roast/commit/c4cf773801

[15:34] <TimToady> since we added the self-awareness

[15:34] <JimmyZ> thanks for explaination

[15:34] <TimToady> some of our explanations might even be correct :)

[15:35] *** jaldhar left
[15:35] <sorear> rakudo: enum Day <Sun>; say ~Sun

[15:35] <p6eval> rakudo 048573: OUTPUT«0␤»

[15:37] * JimmyZ thought rakudo master doesn't support enum since ng refactor

[15:37] *** nymacro left
[15:37] <tadzik> rakudo: my $a = 5; $a.WHAT.say

[15:37] <p6eval> rakudo 048573: OUTPUT«Int()␤»

[15:37] <tadzik> rakudo: my $a = 5; $a.WHAT.WHAT.say

[15:38] <p6eval> rakudo 048573: OUTPUT«Int()␤»

[15:38] <jnthn> awww, master had some cute theories :)

[15:38] <tadzik> nom has them too :)

[15:38] <jnthn> I suspect it has a different answer to that.

[15:38] <tadzik> > my $a = 5; $a.WHAT.WHAT.say

[15:38] <tadzik> Int()

[15:38] <sorear> niecza: enum roman (i => 1);

[15:38] <p6eval> niecza v6-66-g58de2de: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Compile time expression is insufficiently trivial at /tmp/kE4036I5au line 1:␤------> [32menum roman (i => 1)[33m⏏[31m;[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤ 

[15:38] <p6eval> ..at /home/p6eva…

[15:38] <jnthn> tadzik: oh!

[15:39] <jnthn> tadzik: Yeah, that one is right

[15:39] <jnthn> tadzik: I was thinking .HOW.WHAT.

[15:39] <jnthn> Though I may have fixed that in master anyway

[15:39] <tadzik> dunno

[15:39] <tadzik> wasn't there some case in which .WHAT.say wasn't working?

[15:39] <tadzik> I think there's a bug about this

[15:39] <sorear> I'm having to fix/remove a few/ spectests with dated assumptions

[15:41] <jnthn> sorear: The enum spec has been through several itreations

[15:41] <jnthn> sorear: Rakudo has gone through various attempts at supporting it

[15:41] <dalek> rakudo/nom: a9e3910 | tadzik++ | build/Makefile.in:

[15:41] <dalek> rakudo/nom: [Makefile] clean CORE.setting.pbc

[15:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a9e3910b2a

[15:41] <jnthn> sorear: Until I got fed up and decided it was somebody else's problem to figure out. :)

[15:41] <jnthn> Then masak++ had a go :)

[15:42] <masak> I didn't get terribly far, tbh.

[15:42] <moritz> and then I tried to make enums work in the setting

[15:43] <masak> quickly ran into problems that jnthn is fixing now in nom.

[15:43] <moritz> and that was... horrible

[15:43] <masak> it's good to know we're pushing our limits, at least :P

[15:46] <TimToady> it's not entirely clear that the enum spec is sane yet

[15:46] <TimToady> .oO(as if the rest of the spec is sane...)

[15:47] *** Patterner left
[15:49] <sorear> TimToady: What is the default scope of an enum declaration?

[15:49] <TimToady> should be the same as constant

[15:50] <TimToady> which we've gone back and forth on...  :/

[15:50] * jnthn thought "our" was the latest

[15:50] <TimToady> probably

[15:50] <TimToady> it's not like you care if someone else tries and fails to change your constants :)

[15:51] <TimToady> it's also not clear the Foo::Bar is visible if Bar is lexical inside Foo

[15:51] <TimToady> *that

[15:51] <dalek> rakudo/nom: 5c4a5f6 | jnthn++ | src/Perl6/Metamodel/ (2 files):

[15:51] <dalek> rakudo/nom: Default parent type is Any if none is specified.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5c4a5f63c4

[15:51] <dalek> rakudo/nom: d311e5a | jnthn++ | .gitignore:

[15:51] <dalek> rakudo/nom: Update .gitignore so status is clean.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d311e5a347

[15:51] <dalek> rakudo/nom: 842ee25 | jnthn++ | NOMMAP.markdown:

[15:51] <dalek> rakudo/nom: Update nommap.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/842ee251d7

[15:52] <jnthn> TimToady: I decided "no" on that one. :)

[15:52] <sorear> niecza sorries if you try to define my any-declator Foo::Bar

[15:52] <jnthn> TimToady: Oh, wait,

[15:52] <jnthn> TimToady: Actually multi-part mys...what sorear said

[15:52] <jnthn> multi-part ours are OK

[15:52] <jnthn> nqp: class Foo::Bar { }

[15:52] <p6eval> nqp:  ( no output )

[15:52] <jnthn> nqp: my class Foo::Bar { }

[15:52] <p6eval> nqp: OUTPUT«A my scoped package cannot have a multi-part name yet at line 1, near " { }"␤current instr.: 'nqp;HLL;Grammar;panic' pc 26397 (src/stage2/gen/NQPHLL.pir:7039)␤»

[15:52] <jnthn> heh, yet :)

[15:53] <jnthn> "Maybe we'll find a way to make it work"

[15:53] <TimToady> no, I mean package Foo { my constant Bar = 42; }; say Foo::Bar

[15:53] <jnthn> Oh, in that case, no.

[15:53] <TimToady> no colon in the declaration

[15:53] <jnthn> Right

[15:53] *** jevin joined
[15:53] <jnthn> In that case I'm certain Foo::Bar is not visible.

[15:53] <TimToady> but we might allow Foo::Bar access to lexicals that are exported but not imported

[15:54] <jnthn> I don't follow...example?

[15:55] <moritz> module Foo { sub bar is export { } }; Foo::bar

[15:55] <jnthn> Ah

[15:55] <TimToady> yeah, that

[15:55] <jnthn> Presumably you'd get the "is export" trait to deal with that installation?

[15:55] <TimToady> std: package Foo { my constant foo is export = 42 }; Foo::foo

[15:55] <p6eval> std c843201: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'Foo::foo' used at line 1␤Check failed␤FAILED 00:01 115m␤»

[15:56] <jnthn> TimToady: tbh, I'd really rather we don't make export magically our-scope things.

[15:56] <TimToady> which STD apparently doesn't like (yet-ish)

[15:56] <masak> I think having enums be our-scoped by default makes sense. classes and roles and grammars and subtypes are our-scoped.

[15:56] *** Psyche^ joined
[15:56] *** Psyche^ is now known as Patterner

[15:56] <jnthn> TimToady: Provided we our-scope constants and enums by default, there's really no need, imo.

[15:57] <dalek> rakudo/nom: 8b86542 | moritz++ | build/Makefile.in:

[15:57] <dalek> rakudo/nom: [build] declare missing dep on metamodel sources

[15:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b86542663

[15:57] <TimToady> so my...is export is requiring all access to be via import, I guess...

[15:57] <jnthn> TimToady: Yes, that's what I'd figured.

[15:57] <TimToady> is probably okay, given our current set of 'our' defaulters

[15:58] <TimToady> would be problematic if Bool::True was bogus :)

[15:58] <sorear> TimToady: is STD right to parse Day(2) and Day.(2) completely differently?

[15:58] <jnthn> Well, it's in the setting, so export doesn't really come into it :)

[15:59] <TimToady> we have inline imports

[15:59] <jnthn> ah, did you mean the general case rather than Bool specifically?

[15:59] <TimToady> sorear: it's probably a design smell

[15:59] <TimToady> jnthn: yes

[15:59] <jnthn> TimToady: ah, ok

[16:00] <jnthn> Then I understand. :)

[16:00] <dalek> roast: 758acfb | sorear++ | S12-enums/basic.t:

[16:00] <dalek> roast: Twiddle basic enum tests to numify where needed, fudge for niecza

[16:00] <dalek> roast: review: https://github.com/perl6/roast/commit/758acfb9f4

[16:00] <TimToady> sorear: but I suppose it depends on *how* it parses them differently

[16:01] <dalek> niecza: ea84744 | sorear++ | / (3 files):

[16:01] <dalek> niecza: Minor enum fixes, two new passing test files

[16:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ea8474432b

[16:03] <sorear> niecza: enum Day <Sun Mon Tue Wed Thu Fri Sat>; say Day(3); say Day.(3); # I blame STD for this, but haven't investigated too deeply yet

[16:03] <p6eval> niecza v6-66-g58de2de: OUTPUT«Day()␤Day::Wed␤»

[16:03] <TimToady> the first is forcing a function call syntax, the second is a postcircumfix

[16:04] <TimToady> so the second requires Day to be Callable, while the first has to recognize that Day is a type, and not treat it like an ordinary function, in some sense or other

[16:04] <TimToady> but I think it comes out to the same .() call either way

[16:06] <jnthn> me afk for a bit

[16:07] <jnthn> heh

[16:07] * jnthn afk for a bit

[16:07] * JimmyZ tries to sleep

[16:08] <TimToady> STD does attach an argument list in the case of Day(3), so it ought to be recognizable as a form of coercion

[16:09] <TimToady> we do have to recognize a null coercion .() as a no-op somewhere though

[16:09] <TimToady> niecza: enum Day <Sun Mon Tue Wed Thu Fri Sat>; say Day(3); say Day.()

[16:09] <p6eval> niecza v6-66-g58de2de: OUTPUT«Day()␤Unhandled exception: No value for parameter $key in CORE CommonEnum.postcircumfix:<( )>␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE CommonEnum.postcircumfix:<( )> @ 0) ␤  at /tmp/nfiILG9Dug line 1 (MAIN mainline @ 3) ␤  at

[16:09] <p6eval> ../home/p6eval/niecza/lib/CORE.setting line …

[16:09] <TimToady> there probably

[16:09] <sorear> hmm... it looks like STD produces  exactly the same parse tree for Foo::[2] and Foo::{2}

[16:10] <sorear> wait, no

[16:18] <TimToady> rakudo: say (1000000000 .. 2000000000).roll

[16:18] <p6eval> rakudo 048573: OUTPUT«1088995434␤»

[16:18] <TimToady> \o/

[16:23] <TimToady> perl6: say (1000000000 .. 2000000000).pick

[16:23] <p6eval> niecza v6-66-g58de2de: OUTPUT«Unhandled exception: Unable to resolve method pick in class Range␤  at /tmp/9oEsHEjdiJ line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1664 (CORE C758_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1665 (CORE module-CORE @ 56) ␤ 

[16:23] <p6eval> ..at /home/p6eva…

[16:23] <p6eval> ..pugs: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[16:23] <p6eval> ..rakudo 048573: OUTPUT«1434985450␤»

[16:23] <TimToady> pugs--

[16:23] <TimToady> rakudo++

[16:25] <TimToady> でも。。。

[16:26] <TimToady> rakudo: say (1000000000 .. 2000000000).pick(2)

[16:26] <p6eval> rakudo 048573: OUTPUT«(timeout)»

[16:26] * TimToady wonders if we could recognize that situation and just do an anti-cache

[16:27] <TimToady> seems like it would be fairly trivial to recognize that the arg to pick is much smaller than the range in question

[16:28] <TimToady> and then it comes down to the relative overhead of doing it either way

[16:28] <sorear> I wonder why pugs requested exactly 1 MiB

[16:28] <TimToady> rakudo: say (1..2000).pick(2)

[16:28] <p6eval> rakudo 048573: OUTPUT«1745625␤»

[16:29] <TimToady> even that might be faster with an anti-cache

[16:29] *** mtk left
[16:29] <TimToady> I think ghc and/or pugs caps requests somewhere

[16:29] <TimToady> I've seen that number many times

[16:30] <TimToady> "One meg should be enough for anyone..."

[16:30] <sorear> I think an anti-cache is always better, it's O(n log n)

[16:30] <sorear> erm

[16:30] <sorear> no, it's O(n) filtering behavior, which requires rerolls sometimes

[16:31] <sorear> unless it were done ISAM-style

[16:31] <sorear> muahahaha!

[16:31] <sorear> now that you meantion ghc, I remember that ghc uses 1MiB superblocks

[16:32] <sorear> all memory for small GCable objects is allocated in 1MiB increments

[16:32] <benabik> sorear: With a sorted tree anti-cache, couldn't it filter in O(log n)?  So @a.pick($n) would be O(m log n) (m = +@a)

[16:32] <sorear> pugs is probably using some variation on a 2-3-4 tree to store the cache

[16:33] *** wamba joined
[16:33] <benabik> sorear: No, re-rolls.  You're right.  May still be efficient for n << m as TimToady said.  (Probably n < sqrt(m) due to birthday paradox)

[16:34] * PerlJam wonders what a "sorted tree anti-cache" is exactly.

[16:34] <TimToady> an anti-memoizer: "If we saw this already, *don't* return it"

[16:35] <TimToady> not exactly an anti-memoizer though, since that's based on argument matching

[16:35] <TimToady> I think the birthday paradox doesn't hurt you much even > sqrt(m)

[16:36] <TimToady> not till you fill up enough to reroll the majority of the time

[16:36] <benabik> After sqrt(m), you'd be re-rolling about half the time.  Less than optimal.

[16:37] <TimToady> 'course, memory requirments for a billion table entries is not cheap either...

[16:37] <benabik> True, balance of cost of re-roll vs cost of creating intermediate lists.

[16:37] <TimToady> even my bit @seen[1000000000] is pretty big

[16:37] *** pjcj_ joined
[16:37] *** mtk joined
[16:39] <TimToady> but for numbers approaching large you probably could use a bitmap, or just do a Knuth shuffle

[16:39] <TimToady> actually, a truncated Knuth shuffle can get you pretty good results for any intermediate m

[16:40] <TimToady> assuming you can make the mutable structure to hold it

[16:40] <TimToady> doesn't help much with picking 3 out of a billion though

[16:41] *** pjcj left
[16:42] *** pjcj_ is now known as pjcj

[16:45] *** mj41 left
[16:48] *** _twitch left
[16:48] <sorear> benabik: no, you reroll half the time at m/2

[16:49] <sorear> benabik: what the birthday paradox says is that the *first* reroll is expected around sqrt(m)

[16:49] <benabik> sorear: ...  Guh, you're right.  Trying to pay attention to too many things at once.

[16:49] <sorear> TimToady: I beleive a truncated Knuth shuffle is what Rakudo uses now

[16:50] <sorear> for Niecza's pick I think I'm going to use an anticache up to m/2 then switch over to Knuth

[16:50] *** ymasory joined
[16:54] * TimToady has to hit the road now, probably offline till evening

[16:55] *** birdwindupbird left
[16:56] *** JimmyZ left
[16:56] <sorear> phenny: tell TimToady S12-enum/basic.t:89 is dubious.  Shouldn't that be a call to the enum (as a coercer?)

[16:56] <phenny> sorear: I'll pass that on when TimToady is around.

[16:58] *** wknight8111 joined
[16:58] <dalek> niecza: 4cbecb9 | sorear++ | src/niecza:

[16:58] <dalek> niecza: Improve handling of term:name and term:ident, supporting Day(2), Foo::bar

[16:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4cbecb9163

[16:59] <sorear> o/ wknight8111

[16:59] <wknight8111> hello sorear

[17:02] *** pernatiy left
[17:02] *** frettled_ joined
[17:03] *** frettled_ left
[17:03] *** frettled joined
[17:12] *** kaare_ left
[17:14] *** molaf left
[17:19] <sorear> huh.

[17:19] <sorear> there seem to be *no* tests in roast dedicated to "our sub"

[17:24] <masak> spectests: expect to find missing tests :)

[17:25] *** dakkar left
[17:26] <moritz> sorear: probably because 'our' used to be the default

[17:28] *** dukeleto joined
[17:32] *** MayDaniel left
[17:32] <dalek> niecza: b3631e9 | sorear++ | / (3 files):

[17:32] <dalek> niecza: Implement "our sub"

[17:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b3631e9eca

[17:34] <dalek> niecza: 9bedd6b | sorear++ | test (2 files):

[17:34] <dalek> niecza: Merge tests

[17:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9bedd6bede

[17:41] <sorear> btw, niecza just passed 1000 non-roast tests

[17:43] <masak> nice!

[17:43] <masak> how many roast tests?

[17:43] <sorear> not so easy to count.

[17:43] <sorear> 2000ish

[17:44] <sorear> moritz probably has the most recent number

[17:44] *** pyrimidine joined
[17:44] <moritz> only if I rerun :-)

[17:46] *** orafu joined
[17:48] <masak> 2000's about what I expected at this point. sorear++

[17:49] <frettled> From what I read, niecza is a really, really nice part of the Perl 6 ecosystem, so I'll join in on sorear++

[17:50] <frettled> I think it's moritz's blog that I'm reading the most about that in.

[17:50] *** pernatiy joined
[17:52] <colomon> I suspect a week's intense effort could push that north of 10,000 passing spec tests.  (Not counting trig...)

[17:59] <sorear> frettled: I think only colomon++ has been blogging about it

[18:07] <sorear> bleh... almost all of roast's subset tests are MMD-related

[18:12] *** kcwu joined
[18:22] <moritz> sorear: meh, spectest on niecza broken

[18:23] <moritz> Undeclared routines: 'lives_ok' used at line 37,40 'plan' used at line 5

[18:23] <moritz> so, 0 passing spectests :-)

[18:26] <sorear> \o/

[18:27] <pmichaud> good afternoon, #perl6

[18:27] <sorear> good afternoon, pmichaud.

[18:28] <masak> good afternoon, pm/

[18:31] <dalek> niecza: 9671a2d | sorear++ | src/niecza:

[18:31] <dalek> niecza: Fix sub exporting (moritz)

[18:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9671a2d4c0

[18:34] <sorear> ow.

[18:34] <sorear> any(1..5) # 671 µs

[18:34] *** mj41 joined
[18:36] *** icwiener left
[18:39] <jnthn> o/ pmichaud 

[18:40] <sorear> by comparison

[18:40] <sorear> 1|2|3|4|5 # 7.98µs

[18:41] <sorear> any(1,2,3,4,5) # 16.4µs

[18:41] <jnthn> pmichaud: Some reported build issues, though I suspect mostly out of things being in a state of flux (e.g. Rakudo not using the new stuff in nqp yet)

[18:47] *** envi left
[18:47] *** Phreak joined
[18:48] *** fhelmberger left
[18:49] *** Chillance left
[18:50] *** Chillance joined
[19:05] <masak> sorear: so... iterators are slow, is that it?

[19:06] <sorear> masak: RangeIterator is a lot slower than it could be, yeah

[19:06] <sorear> but it's written in a high-level style and relies on infix:<cmp>, which is not fast itself at the moment

[19:09] <frettled> sorear: brilliant, I don't even know who I'm paying attention to.  Hah. :D

[19:10] <moritz> sorear: importing still borked

[19:14] <sorear> moritz: importing was never borked, it was actually exporting I borked, which means that your obj/Test.nam is miscompiled

[19:18] *** birdwindupbird joined
[19:19] <moritz> sorear: deleting that fixes it

[19:22] <moritz> nqp: say(pir::ord("ab"))

[19:22] <p6eval> nqp: OUTPUT«97␤»

[19:23] <moritz> sorear: t/spec/S32-num/pi.t aborts prematurely

[19:25] <colomon> frettled: good thing I only blog for the fame.  ;)

[19:31] <frettled> colomon: hee-hee :D  Well done, anyway :D

[19:32] <dalek> rakudo/nom: d2a8a97 | moritz++ | / (2 files):

[19:32] <dalek> rakudo/nom: implement Cool.bytes and .ord

[19:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2a8a9700f

[19:35] <jnthn> omgz, all nom eaten!

[19:36] <jnthn> er, all *LHF* nom :)

[19:42] <dalek> niecza: 945867e | sorear++ | / (7 files):

[19:42] <dalek> niecza: mergeback augments

[19:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/945867ed86

[19:43] *** Phreak left
[19:43] <sorear> rakudo: say pi()

[19:43] <p6eval> rakudo 048573: OUTPUT«Could not find sub &pi␤  in main program body at line 22:/tmp/HBYWO6fMrH␤»

[19:43] <sorear> pugs: say pi()

[19:43] <p6eval> pugs: OUTPUT«3.141592653589793␤»

[19:44] <sorear> is pi() correct Perl6 anymore?

[19:44] <PerlJam> What's a slicel?

[19:44] <moritz> iirc only term:pi is correct

[19:44] <sorear> moritz: mind if I kill the tests for pi()?

[19:44] <sorear> well, invert :)

[19:45] <moritz> sorear: do whatever you deem correct

[19:46] <dalek> roast: 3c40f3a | sorear++ | S32-num/pi.t:

[19:46] <dalek> roast: [S32-num/pi.t] pi() is no longer valid

[19:46] <dalek> roast: review: https://github.com/perl6/roast/commit/3c40f3ac69

[19:46] <sorear> was that the only failing file?

[19:46] <moritz> yes

[19:46] <moritz> around 2.3k passes

[19:47] <moritz> (including skips)

[19:47] <sorear> :/

[19:47] <sorear> why does it count skips?

[19:47] <moritz> dunno

[19:47] <sorear> is my Test using the wrong syntax, I wonde

[19:47] <dalek> rakudo/nom: 80a9810 | moritz++ | src/CORE.setting/Int.pm:

[19:47] <dalek> rakudo/nom: Int.chr

[19:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/80a9810c0b

[19:47] <dalek> rakudo/nom: 52a6917 | moritz++ | src/CORE.setting/Cool.pm:

[19:47] <dalek> rakudo/nom: Cool.flip

[19:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/52a6917a86

[19:47] <moritz> nope, general TAP::Harness "feature"

[19:48] <moritz> perl6: say 42.1.log

[19:48] <p6eval> niecza v6-71-g9671a2d: OUTPUT«Unhandled exception: Unable to resolve method log in class Rat␤  at /tmp/cAf14UFD_Z line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1664 (CORE C758_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1665 (CORE module-CORE @ 56) ␤  at

[19:48] <p6eval> ../home/p6eval/n…

[19:48] <p6eval> ..pugs: OUTPUT«3.7400477406883357␤»

[19:48] <p6eval> ..rakudo 048573: OUTPUT«3.74004774068834␤»

[19:48] <moritz> perl6: say 42.1.ln

[19:48] <p6eval> niecza v6-71-g9671a2d: OUTPUT«Unhandled exception: Unable to resolve method ln in class Rat␤  at /tmp/TwT1lJVPqr line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1664 (CORE C758_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1665 (CORE module-CORE @ 56) ␤  at

[19:48] <p6eval> ../home/p6eval/ni…

[19:48] <p6eval> ..pugs: OUTPUT«*** No such method in class Rat: "&ln"␤    at /tmp/5dtN7LDp1H line 1, column 5 - line 2, column 1␤»

[19:48] <p6eval> ..rakudo 048573: OUTPUT«3.74004774068834␤»

[19:53] <moritz> perl6: say 42.1.log(10)

[19:53] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&log"␤    at /tmp/NCUcQ2gnWv line 1, column 5 - line 2, column 1␤»

[19:53] <p6eval> ..niecza v6-71-g9671a2d: OUTPUT«Unhandled exception: Unable to resolve method log in class Rat␤  at /tmp/PamdjqgRqI line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1664 (CORE C758_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1665 (CORE module-CORE @ 56) ␤  at

[19:53] <p6eval> ../home/p6eval/n…

[19:53] <p6eval> ..rakudo 048573: OUTPUT«1.62428209583567␤»

[19:57] *** icwiener joined
[19:58] <dalek> niecza: 24b29e4 | sorear++ | / (3 files):

[19:58] <dalek> niecza: Remove EACH junction type, which only existed on a misunderstanding

[19:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/24b29e46a6

[19:58] <dalek> rakudo/nom: a240642 | moritz++ | src/CORE.setting/Num.pm:

[19:58] <dalek> rakudo/nom: Num.sqrt and .log

[19:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a240642647

[20:01] *** bharat1 joined
[20:02] <jnthn> pmichaud: ping

[20:04] <jnthn> NQP configure is totally busted on Win32. :/

[20:05] <jnthn> ah

[20:05] <jnthn> --with-parrot at least works

[20:07] *** bharat1 left
[20:09] *** cognominal left
[20:10] *** cognominal joined
[20:14] *** xinming left
[20:14] *** xinming joined
[20:15] *** Mowah left
[20:16] <jnthn> pmichaud: Turns out it's not so busted, once I figured out how to work it. It's just --gen-parrot that doesn't work on Win32.

[20:17] *** wamba left
[20:21] <sorear> I'm suprised

[20:21] <sorear> even without fancy optimizations, junctions are pretty competitive with other looping constructs

[20:22] <sorear> ?( 3 == any(1,2,3,4,5) ) is twice as fast as ?( grep 3, 1,2,3,4,5 ) in niecza currently

[20:22] <masak> \o/

[20:24] <dalek> rakudo/nom: 4ab94e9 | jnthn++ | build/gen_nqp.pl:

[20:24] <dalek> rakudo/nom: Quick hack that should fix --gen-nqp, so --gen-parrot --gen-nqp should work again (maybe... :-))

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4ab94e96ba

[20:24] <dalek> nqp: c9a6dba | jonathan++ | / (4 files):

[20:24] <dalek> nqp: Add an Uninstantiable representation, whihc is useful for types that you can't instantiate.

[20:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c9a6dbaa14

[20:24] <jnthn> Spelling is useful too...

[20:25] <colomon> jnthn++

[20:25] <jnthn> karma for spelling wrong? :)

[20:25] <aloha> for spelling wrong? :) has karma of 0.

[20:25] <jnthn> ...

[20:26] <sorear> pre-populating a hash with keys for 1,2,3,4,5 and then doing %hash{3}, is, however, 4x faster than the junction

[20:26] <sorear> if the values are <a b c d e>, then the hash is 40x faster than the junction

[20:27] <sorear> not that the junction is slower; it just seems that 90% of the cost of %hash{3} is incurred in System.Int32.ToString()

[20:27] <dalek> niecza: 31e91e9 | sorear++ | / (6 files):

[20:27] <dalek> niecza: Add a makejunction primitive

[20:27] <dalek> niecza: review: https://github.com/sorear/niecza/commit/31e91e9e58

[20:30] *** wknight8111 left
[20:33] *** parcs left
[20:39] *** birdwindupbird left
[20:44] *** thou left
[20:44] *** thou joined
[20:46] <dalek> niecza: 1019d95 | sorear++ | / (3 files):

[20:46] <dalek> niecza: Minor junction optimizations (use indexed slot access, short-circuity collapse)

[20:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1019d95513

[21:09] *** timbunce left
[21:10] *** masak left
[21:14] *** masak joined
[21:16] *** timbunce joined
[21:28] *** dorlamm joined
[21:32] *** icwiener left
[21:33] *** Eevee left
[21:35] <dalek> niecza: bec71af | sorear++ | / (2 files):

[21:35] <dalek> niecza: Avoid inferior runloops for autothreading only subs

[21:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bec71af69a

[21:35] <dalek> niecza: 47239f7 | sorear++ | lib/Kernel.cs:

[21:35] <dalek> niecza: Avoid inferior runloops on unknown-method autothreading

[21:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/47239f72e1

[21:36] *** Eevee joined
[21:42] <masak> blog post!

[21:42] <masak> http://strangelyconsistent.org/blog/june-6-2011-building-strings

[21:42] *** Trashlord left
[21:43] <tadzik> my assembly project is slower when using registers than when using memory

[21:43] <benabik> masak: There's a &mash; in there.  I assume you wanted &mdash;

[21:43] <tadzik> things are getting irrational

[21:43] <masak> benabik: thanks, fixing.

[21:44] *** Trashlord joined
[21:44] <sorear> tadzik: what kind of assembly?

[21:44] <masak> tadzik: why waste your time optimizing by hand? computers are better at it than we are by now... :)

[21:45] <tadzik> sorear: x86

[21:45] <tadzik> masak: that's what THEY expect me to do :)

[21:45] <mberends> tadzik: might a debugger be interfering with the timing?

[21:45] <tadzik> I have 5 variables on stack in my code. I noticed ebx is unused, so I moved one of the most used vars to ebx. Things slowed down by 25% on 200 runs

[21:45] <tadzik> mberends: I'm not running under a debugger

[21:46] <tadzik> unless -g is the issue, but I doubt it

[21:46] *** Psyche^ joined
[21:47] *** Patterner left
[21:47] *** Psyche^ is now known as Patterner

[21:47] <masak> I think I'll skip this month's Yapsi release :/

[21:47] <masak> focus on the next one instead.

[21:47] <masak> 'night, #perl6.

[21:47] <tadzik> masak: night

[21:47] *** masak left
[21:50] <sorear> tadzik: x86 is very sensitive to assembly layout issues, loop alignment and whatnot

[21:51] <tadzik> sorear: I didn't reorganize the stack after this, I just not use my [ebp-20] anymore, may that impact this?

[21:51] <tadzik> I guess not, but everything here has dozens of side-effects. After I finish this, I'm writing haskell only

[21:51] <sorear> tadzik: you changed the low-order bits of every subsequent instruction in your program, right?

[21:52] <tadzik> oh, so the instructions have a different size and everything is moved?

[21:52] <sorear> yes

[21:52] * sorear is done messing with junctions for now

[21:53] <sorear> next I think I'll mess with new/CREATE/bless/BUILDALL/BUILD

[21:55] *** TiMBuS joined
[21:56] *** sivoais joined
[21:56] *** ymasory left
[22:05] *** timbunce left
[22:06] <jnthn> I blug: http://6guts.wordpress.com/2011/06/06/the-rakudo-nom-hacking-marathon/

[22:08] <pyrimidine> jnthn++

[22:08] <pyrimidine> nice post!

[22:08] <tadzik> The :U and :D type-modifiers

[22:08] <tadzik> smiley-syntax

[22:09] <pyrimidine> just need :P now

[22:11] <tadzik> Probably-defined

[22:11] <jnthn> :)

[22:11] <tadzik> :O – obviously defined

[22:12] <tadzik> :F – F*** knows :)

[22:12] <tadzik> it even looks similar

[22:13] <tadzik> oh, I'm pushing it

[22:13] <mberends> :Q - Schrödinger's cat defined

[22:13] <tadzik> quantum variables

[22:14] <tadzik> rakudo: my $a = any(Mu, Any); say $a.defined

[22:14] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[22:14] <tadzik> ...how can you tell, rakudo?

[22:14] <mberends> tadzik: try again, the answer might change ;)

[22:14] <jnthn> I suspect you're asking the junction if *it's* defined there :)

[22:14] <tadzik> shh!

[22:15] <sorear> phenny: tell masak Your blog is spamming planet perl6 with duplicated posts

[22:15] <phenny> sorear: I'll pass that on when masak is around.

[22:16] <tadzik> rakudo: class Cat { has $.alive }; my $a = any(Cat.new(alive => 1), Cat.new(alive => 0)); say $a.alive

[22:16] <p6eval> rakudo 048573: OUTPUT«any(1, 0)␤»

[22:16] <tadzik> clever

[22:17] <mberends> jnthn: in yr blog post, s/could/called/

[22:17] <sorear> niecza: class Cat { has $.alive }; my $a = any(Cat.new(alive => 1), Cat.new(alive => 0)); say $a.alive

[22:17] <p6eval> niecza v6-75-g1019d95: OUTPUT«Unhandled exception: Nominal type check failed for scalar store; got Junction, needed Any or subtype␤  at /tmp/mTbkaGYqd9 line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1658 (CORE C754_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting

[22:17] <p6eval> ..line 1659 (CORE …

[22:17] <sorear> oh

[22:17] <sorear> niecza: class Cat { has $.alive }; my Mu $a = any(Cat.new(alive => 1), Cat.new(alive => 0)); say $a.alive

[22:17] *** mj41 left
[22:17] <p6eval> niecza v6-75-g1019d95: OUTPUT«Junction()<instance>␤»

[22:19] <jnthn> mberends: thanks

[22:24] *** dorlamm left
[22:37] <jnthn> sleep &

[22:43] <felher> masak++, jnthn++, for blogging. :)

[22:46] *** cognominal_ joined
[22:49] *** cognominal left
[22:55] *** spq1 joined
[23:00] <tadzik> I keep reading "hacking marathon" as "morning hackathon"

[23:00] <tadzik> sleep as well &

[23:07] *** Ali_h_ joined
[23:10] *** Ali_h left
[23:41] *** jaldhar joined
[23:43] *** Ali_h_ is now known as Ali_h

[23:58] *** ymasory joined
