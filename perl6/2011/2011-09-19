[00:11] *** donri left
[00:31] <colomon> sorear: is there any easy / good way to define constants in C#?  My code would be a lot cleaner if I had constants for pi and i

[00:35] <sorear> colomon: public static readonly Complex i = ...;

[00:35] <sorear> and Math.PI

[00:35] <colomon> .PI, not .Pi?

[00:35] <sorear> correct, PI

[00:36] * colomon gives C# designers a dirty look

[00:36] <colomon> sorear++

[00:36] <jnthn> Well, it's not mandated by the language. But the C# cultural convention is that CONSTANTS SHOULD BE SHOUTED OUT LOUD.

[00:36] <jnthn> :)

[00:37] <sorear> yeah.  I find int.MaxValue to be much wronger than Math.PI

[00:37] <jnthn> heh, what, you want consistency too? :)

[00:38] <jnthn> oh what, how's it this late...and I should actually get up to work in the morning...

[00:41] <jnthn> sleep &

[00:41] <colomon> jnthn: o/

[00:45] <colomon> oooo, autopromotes Int to Double.  handy

[00:45] <sorear> yeah C-family languages do that as a rule

[00:47] <colomon> I still don't quite have a feel for when C# is slick like that and when it is clunky.  and I tend to expect clunky.

[00:51] *** gbacon joined
[00:51] *** Chillance left
[00:54] *** am0c joined
[00:54] *** whiteknight left
[01:11] <colomon> btw, the other thing that keeps killing me is I don't want to use () after method calls with no arguments.  :)

[01:11] <sorear> Heh

[01:23] *** am0c left
[01:24] *** am0c joined
[01:31] *** am0c left
[01:31] *** am0c joined
[01:34] <[Coke]>  tchrist-- # general (#&$ery on p5p.

[01:36] <dalek> roast: ca8ada6 | Coke++ | S (4 files):

[01:36] <dalek> roast: rakudo nom fudging.

[01:36] <dalek> roast: review: https://github.com/perl6/roast/commit/ca8ada6b18

[01:37] <dalek> rakudo/nom: 35ec9c7 | Coke++ | t/spectest.data:

[01:37] <dalek> rakudo/nom: track failures, run fudged tests.

[01:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/35ec9c7286

[01:41] <sorear> [Coke]: wah?

[01:49] *** wamba left
[01:49] <colomon> oh, shoot.  C#'s Math doesn't have all the trig functions.

[01:50] <colomon> that makes the super-simple version I had in mind not work.  

[01:58] *** orafu left
[01:58] *** orafu joined
[02:00] *** abercrombie joined
[02:03] * colomon does not enjoy hand correcting his autogenerated code.

[02:06] <dalek> niecza/serialize: b62a6bb | sorear++ | / (5 files):

[02:06] <dalek> niecza/serialize: checkpoint 1 of executable code in new model

[02:06] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/b62a6bba24

[02:10] *** bluescreen10 joined
[02:12] *** miguet left
[02:17] *** s_mosher joined
[02:17] <colomon> sorear: got all the non-hyperbolic trig functions (except atan2) passing all spectests.    but I need to reformulate the code generation a bit, and I want to check with the suggested implementation of the complex functions anyway.  still, nice progress tonight.

[02:19] <s_mosher> hey sorear, I want to express appreciation for the CLR integration work you've been doing lately with Niecza

[02:24] <sorear> colomon++ # excellent

[02:24] <sorear> s_mosher: Thank you!  I need to know that I'm doing useful things sometimes :)

[02:40] *** gbacon left
[02:41] *** daniel-s joined
[02:55] <s_mosher> sorear, for sure. I think it's a great strength for Niecza to have.

[02:57] <s_mosher> I tend to work with Rakudo mostly, but I'm planning something that will be better suited to Niecza. (It wouldn't be remotely practical with Rakudo today.)

[03:05] <s_mosher> out for now

[03:05] *** s_mosher left
[03:06] <colomon> afk # bed

[03:06] *** wolfman2000 joined
[03:24] *** Reaganomicon left
[03:49] *** envi_laptop joined
[03:59] *** masonkramer left
[04:01] *** packetknife joined
[04:03] *** packetknife left
[04:03] *** abercrombie left
[04:10] *** [particle]1 left
[04:14] *** birdwindupbird joined
[04:14] *** satyavvd joined
[04:18] *** REPLeffect joined
[04:21] *** tokuhiro_ left
[04:24] *** jamtech left
[04:29] *** tokuhiro_ joined
[04:29] *** woosley joined
[04:31] *** araujo left
[04:32] <moritz> good morning

[04:49] <woosley> good *, #perl6

[04:51] *** uasi joined
[05:03] *** soh_cah_toa left
[05:04] *** mberends left
[05:05] *** kaleem joined
[05:10] *** JimmyZ joined
[05:20] <sorear> hello moritz

[05:27] *** koban` joined
[05:27] *** koban` left
[05:30] *** mberends joined
[05:31] *** uasi left
[05:33] <dalek> roast: e2676ba | jamesrom++ | README:

[05:33] <dalek> roast: Typo.

[05:33] <dalek> roast: review: https://github.com/perl6/roast/commit/e2676bac1e

[05:33] <dalek> roast: f3dfe0e | moritz++ | README:

[05:33] <dalek> roast: Merge pull request #6 from jamesrom/patch-1

[05:33] <dalek> roast: 

[05:33] <dalek> roast: Typo.

[05:33] <dalek> roast: review: https://github.com/perl6/roast/commit/f3dfe0e2e1

[05:45] *** am0c left
[05:45] *** _jaldhar left
[05:52] *** JimmyZ left
[05:53] *** wtw joined
[05:55] *** mberends left
[06:00] *** packetknife joined
[06:08] *** orafu left
[06:10] *** orafu joined
[06:11] *** REPLeffect left
[06:12] *** wamba joined
[06:13] *** mberends joined
[06:25] *** REPLeffect joined
[06:27] *** SHODAN joined
[06:27] *** mberends left
[06:45] *** static_perl left
[06:47] *** agentzh joined
[06:49] *** fridim_ left
[06:50] <agentzh> hi, can nqp compile source files to pbc/pir files that can be run by parrot later directly?

[06:52] <sorear> yes

[06:52] <sorear> this is in fact how nqp works

[06:52] <moritz> agentzh: yes, that's how the bootstrap works

[06:52] <agentzh> moritz: any doc on the command line syntax?

[06:53] *** dayangkun joined
[06:53] *** mishin joined
[06:53] <moritz> agentzh: dunno about docs, but --target=pir -o out.pir is what you need

[06:53] <agentzh> moritz: cool, thanks! i'll try it out :)

[06:53] <moritz> and then   parrot -o out.pbc out.pir

[06:54] <moritz> there are plenty of examples in the Makefile

[06:55] <agentzh> moritz: cool, it works, though not making things faster ;)

[06:56] *** uasi joined
[06:57] <agentzh> moritz: i'll read Makefile in detail, thanks :)

[06:57] <Woodi> do copy of rakudo/src/core/* to dir in PERL6LIB just work ?

[06:58] *** mj41 joined
[06:58] <Woodi> hmm, or it is consider builtin ?

[06:59] <Woodi> *considered

[06:59] *** drbean left
[07:00] <sorear> bad idea

[07:00] <sorear> the stuff in src/core/* isn't Perl modules

[07:00] <sorear> they're setting fragments

[07:00] <sorear> subtly differen

[07:01] <Woodi> problem is IO::Select::INET do not work for me and it is in core...

[07:02] <Woodi> so how to use i-s-i ?

[07:02] <Woodi> debian-rakudo here

[07:04] <sorear> don't use it

[07:04] <sorear> just access it

[07:05] <sorear> b: say IO::Socket::INET.^methods

[07:05] <p6eval> b 1b7dd1: OUTPUT«newexceptionperlmaybefailBooldefinedStrNumIntcanisadoeslistACCEPTSStrNumericSeqallanyonenonejoinelemsflatmapsortrotatefirstgrepreverseendminmaxminmaxpickrollclassifyreduceuniqkvkeysvaluespairspostcircumfix:<[ ]>at_pospostcircumfix:<{ }>at_keyclonedefineditemblessBUILDBU…

[07:05] <sorear> and it's spelled Socket, not Select

[07:05] <Woodi> ah :)

[07:05] <Woodi> right

[07:05] <Woodi> thanks sorear 

[07:07] * sorear sleep

[07:14] *** dayangkun_ joined
[07:17] *** dayangkun left
[07:19] *** lumi_ left
[07:22] *** araujo joined
[07:22] *** araujo left
[07:22] *** araujo joined
[07:32] *** woosley left
[07:32] *** woosley joined
[07:32] *** woosley left
[07:42] <ingy> plobsing: a pegex parser applies a compiled pegex grammar to an input stream, and then calls a method in a "receiver" class for every matched subrule. the default receiver returns a hash that looks like {subrule_name => [terminals]}

[07:42] <ingy> plobsing: so... both :)

[07:44] <ingy> plobsing: by having your action methods in a receiver class (instead of inside the grammar rules themselves) you can use the same grammar against many differnt receivers

[07:45] <moritz> it's the same concept as the 'actions' in Perl 6 grammars

[07:46] <moritz> and so far I haven't seen a single grammar with more than one actions class/receiver

[07:46] <ingy> moritz: well I can easily imagine it :)

[07:46] <ingy> say you have a yaml grammar for instance

[07:47] <moritz> ingy: it's not a problem of imagination :-)

[07:47] <moritz> ingy: I can think of many cases too, I just said that I've never encountered such a case in the wild

[07:47] <ingy> then everyone who wants to work with yaml in any special way will simply define a receiving class

[07:48] <moritz> since the structure of captures is a result of the implementation, it basically becomes part of the grammar's API

[07:48] <moritz> so it becomes hard to change a grammar later on, while retaining the structure of the captures

[07:48] *** wamba left
[07:49] <ingy> noted

[07:51] <moritz> that's kinda obvious, but it's less obvious if there's a good solution to that

[07:51] <moritz> p6's capture aliasing makes it possible (but still hard) to maintain the structure

[07:54] <ingy> i'm spending a lot of time trying to make my default structures as clean as possible, and adding a few simple syntax hints to pegex

[07:55] <ingy> i'm spending a lot of time trying to make my default structures as clean as possible, and adding a few simple syntax hints to pegex to make the structures cleaner

[07:55] <ingy> so that the receiving classes can be minimal

[07:55] <tadzik> good morning

[07:55] <ingy> o/

[07:56] *** daxim joined
[07:56] <ingy> moritz: https://gist.github.com/1226129

[07:57] <ingy> pester pester... :)

[07:59] <moritz> ingy: I too find that I don't often use <a> ** <b>

[08:01] <moritz> ingy: it's occasionally useful though

[08:01] *** packetknife left
[08:03] <ingy> moritz: I'll write up a list of variations of that that I would like to handle nicely and maybe you can help me find a reasonable syntax 

[08:03] <moritz> ingy: ok

[08:05] <ingy> moritz: I need a**b because that can return a list of [a+] whereas a [b a]* has to return a form of [a,[a*]] and that just cascades into complexity

[08:06] <moritz> ingy: why can't multiple captures of the same name simply return a list?

[08:06] <mishin> what is latest release racudo ro windows?

[08:06] *** uasi left
[08:07] <ingy> a: b? c b+

[08:07] <moritz> mishin: rakudo has source releases which you can compile on windows too

[08:07] <ingy> I think combining the b's in that case is not what you want

[08:08] <moritz> mishin: I think the last winidows binary was 2011.04 or so

[08:08] <moritz> ingy: hm, right. Perl 6 solves that by allowing you to write  (b?) c b+  or  (b)? c b+

[08:08] <ingy> I want pegex rules to follow very obvious, er, rules 

[08:08] <mishin> thanks is it planned to compile new release?

[08:09] <moritz> somebody does that occasinally.

[08:09] <moritz> mishin: you could do it too

[08:09] <moritz> and share the result with the community

[08:09] <ingy> moritz: bbl

[08:14] *** dayangkun__ joined
[08:14] <mishin> @motitz: Good idea, it is necessary to understand only how it to make and that to me it is necessary for this purpose

[08:18] *** dayangkun_ left
[08:21] *** lumi_ joined
[08:25] <jnthn> monring o/

[08:26] <moritz> \o jnthn 

[08:26] <jnthn> +# S32-temporal/DateTime-Instant-Duration.t # err: Method 'eval' not found for invocant of class 'Str'

[08:27] <jnthn> Well, that looks like lhf. ;)

[08:27] <jnthn> [Coke]++ # tracking failure modes

[08:28] *** agentzh left
[08:29] *** daniel-s left
[08:29] *** daniel-s joined
[08:34] <ingy> moritz: one thing to mention is that pegex grammars always assume '^ ...grammar... $', (since Pegex is intended to be a parser, not a regex replacement)

[08:36] <ingy> I only thought of that because I was just considering adding a parser option to not enforce the $ to do a partial parse :)

[08:38] *** Trashlord joined
[08:40] <moritz> ingy: makes sense

[08:40] <dalek> Heuristic branch merge: pushed 484 commits to rakudo/nom-exceptions by moritz

[08:40] <moritz> oops, accidnetally pushed to the wrong branch :-)

[08:41] <dalek> rakudo: d7f45ff | moritz++ | src/core/Cool.pm:

[08:41] <dalek> rakudo: Cool.eval

[08:41] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/d7f45ff8cf

[08:46] *** odoacre_ joined
[08:55] *** dayangkun__ left
[08:56] *** dayangkun__ joined
[08:56] *** dayangkun__ left
[08:58] *** replore left
[08:58] *** REPLeffect left
[08:58] *** REPLeffect joined
[08:59] *** PZt left
[09:04] *** woosley1 joined
[09:06] *** am0c joined
[09:07] *** kaleem left
[09:07] *** kaleem joined
[09:08] *** replore joined
[09:13] *** drbean joined
[09:17] *** am0c left
[09:18] *** am0c joined
[09:18] *** PZt joined
[09:20] *** uasi joined
[09:32] <moritz> nom: say now.perl.eval

[09:32] <p6eval> nom 35ec9c: OUTPUT«Method 'eval' not found for invocant of class 'Str'␤  in <anon> at /tmp/seKsoO4hPv:1␤  in <anon> at /tmp/seKsoO4hPv:1␤␤»

[09:32] <moritz> evalbot rebuild nom

[09:32] <p6eval> OK (started asynchronously)

[09:32] *** tokuhiro_ left
[09:39] *** wamba joined
[09:46] *** am0c left
[09:46] <Woodi> perl6: class A { has $.b = 10; }; sub foo() { say self.b };  my $b = A.new; $b.foo()

[09:46] <p6eval> niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤'self' used where no object is available at /tmp/FpMaFHP0Pk line 1:␤------>  { has $.b = 10; }; sub foo() { say self⏏.b };  my $b = A.new; $b.foo()␤␤Potential difficulties:␤  &foo is declared but not used a…

[09:46] <p6eval> ..rakudo 35ec9c: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in foo (/tmp/F3btE1vtBR:1)␤»

[09:46] <p6eval> ..pugs: OUTPUT«*** No compatible multi variant found: "&foo"␤    at /tmp/cS5G0ZtE0I line 1, column 70 - line 2, column 1␤»

[09:47] <Woodi> pls someone tell me how to call method in perl6

[09:47] <Woodi> imho DWIM is heavy broken in perl6

[09:48] <moritz> Woodi: well, it works just fine if you actually write a method, not a sub

[09:48] <arnsholt> nom: class A { hsa $.b = 10; method foo() { say self.b; }; }; my $a = A.new; $a.foo

[09:48] <Woodi> perl6: class A { has $.b = 10; }; method foo() { say self.b };  my $b = A.new; $b.foo()

[09:48] <p6eval> nom 35ec9c: OUTPUT«Null PMC access in find_method('b')␤  in <anon> at /tmp/sCgQyi8yuW:1␤  in <anon> at /tmp/sCgQyi8yuW:1␤  in <anon> at /tmp/sCgQyi8yuW:1␤␤»

[09:48] <p6eval> rakudo 35ec9c: OUTPUT«Useless declaration of a has-scoped method in mainline␤Method 'foo' not found for invocant of class 'A'␤  in <anon> at /tmp/FW3IOJlmdA:1␤  in <anon> at /tmp/FW3IOJlmdA:1␤␤»

[09:48] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Methods must be used in some kind of package at /tmp/hyx7Uu5g5b line 1:␤------> class A { has $.b = 10; }; method foo⏏() { say self.b };  my $b = A.new; $b.fo␤␤Potential difficulties:␤  'method' declaration…

[09:48] <p6eval> ..pugs: OUTPUT«10␤»

[09:48] <moritz> Woodi: you can't expect a programming language to do what you mean if it contradicts with what you tell it.

[09:49] <arnsholt> Or something. My Perl 6 is a bit rusty

[09:49] *** am0c joined
[09:49] <arnsholt> At any rate, as moritz says, you need to place the method declaration inside the class

[09:49] <moritz> arnsholt: probably works if you spell 'has' correctly :-)

[09:49] <arnsholt> Ooooooh, right. That might help =D

[09:49] <Woodi> moritz: DWIM usually allow to say what i mean and language gueses right :)

[09:49] <arnsholt> nom: class A { has $.b = 10; method foo() { say self.b; }; }; my $a = A.new; $a.foo # Once more, with feeling

[09:50] <p6eval> nom 35ec9c: OUTPUT«10␤»

[09:50] <arnsholt> There we go.

[09:50] <moritz> arnsholt++ # with feeling

[09:50] *** envi_|2 joined
[09:50] <Woodi> ah

[09:50] <arnsholt> Woodi: But that'll explode messily when you have class A {}; class B {}

[09:51] *** envi_laptop left
[09:51] <arnsholt> It's the kind of dwimmery that'll only come back and bite you because figuring it out properly is an AI-complete problem (or close enough)

[09:51] <moritz> DWIM must be applied con spirito, ma non troppo :-)

[09:51] <Woodi> i just know how to write 'espresso' and 'cappucino' :)

[09:53] <Woodi> perl6: class A { has $.b = 10; }; method foo() { say self.b; };  my $b = A.new; $b.foo()

[09:53] <p6eval> rakudo 35ec9c: OUTPUT«Useless declaration of a has-scoped method in mainline␤Method 'foo' not found for invocant of class 'A'␤  in <anon> at /tmp/ar6dwzEOi9:1␤  in <anon> at /tmp/ar6dwzEOi9:1␤␤»

[09:53] <p6eval> ..pugs: OUTPUT«10␤»

[09:53] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Methods must be used in some kind of package at /tmp/rVGT1p0wCF line 1:␤------> class A { has $.b = 10; }; method foo⏏() { say self.b; };  my $b = A.new; $b.f␤␤Potential difficulties:␤  'method' declaration…

[09:53] *** JimmyZ joined
[09:54] <Woodi> perl6: class A { has $.b = 10;  }; sub foo($self) { say $self.b };  my $b = A.new; $b.&foo

[09:54] <p6eval> pugs, rakudo 35ec9c, niecza v9-32-g380d891: OUTPUT«10␤»

[09:54] <moritz> Woodi: if the method is meant to go into the clas, write it inside the class

[09:54] <Woodi> but why it working

[09:55] <Woodi> *is is *?

[09:55] <Woodi> goot that works but strange

[09:56] <Woodi> perl6: class A { has $.b = 10;  }; method foo($self) { say $self.b }; };  my $b = A.new; $b.foo

[09:56] <moritz> because methods and subs are really just the same thing, they are just being searched for in different ways

[09:56] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "};"␤    expecting ";", identifier, Doc block, block declaration, declaration, construct or expression␤    at /tmp/GjmwrntSVA line 1, column 64␤»

[09:56] <p6eval> ..rakudo 35ec9c: OUTPUT«Useless declaration of a has-scoped method in mainline␤===SORRY!===␤Confused at line 1, near "};  my $b "␤»

[09:56] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Methods must be used in some kind of package at /tmp/KpfJuDuNfV line 1:␤------> class A { has $.b = 10;  }; method foo⏏($self) { say $self.b }; };  my $b = A.n␤␤Unexpected closing bracket at /tmp/KpfJuDuNfV…

[09:56] <arnsholt> That's the monkey patching approach, essentially. Put the method declaration -inside- the braces of the class, and you can drop the .& syntax

[09:56] <Woodi> perl6: class A { has $!b = 10;  }; method foo() { say self.b }; };  my $b = A.new; $b.foo

[09:56] <jnthn> The syntax you're looking for is "my method foo ..." then "$b.&foo"

[09:56] <p6eval> rakudo 35ec9c: OUTPUT«Useless declaration of a has-scoped method in mainline␤===SORRY!===␤Confused at line 1, near "};  my $b "␤»

[09:56] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Methods must be used in some kind of package at /tmp/9eKhcynh6Z line 1:␤------> class A { has $!b = 10;  }; method foo⏏() { say self.b }; };  my $b = A.new; $b␤␤Unexpected closing bracket at /tmp/9eKhcynh6Z…

[09:56] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "};"␤    expecting ";", identifier, Doc block, block declaration, declaration, construct or expression␤    at /tmp/p8QqoC2JdS line 1, column 58␤»

[09:57] <moritz> perl6: class A { has $.b = 10 }; my method foo() { self.b }; say A.new.&foo

[09:57] <p6eval> niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Methods must be used in some kind of package at /tmp/2pLDg_kLPp line 1:␤------> class A { has $.b = 10 }; my method foo⏏() { self.b }; say A.new.&foo␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/ni…

[09:57] <p6eval> ..pugs, rakudo 35ec9c: OUTPUT«10␤»

[09:57] <JimmyZ> moritz: there are not same if /$.b/$!b/

[09:57] <Woodi> perl6: class A { has $!b = 10;  method foo() { say self.b }; };  my $b = A.new; $b.foo

[09:57] <p6eval> pugs: OUTPUT«*** No such method in class A: "&b"␤    at /tmp/WtRi0z4m_h line 1, column 45-52␤»

[09:57] <p6eval> ..niecza v9-32-g380d891: OUTPUT«Unhandled exception: Unable to resolve method b in class A␤  at /tmp/Nf0AdwQpJj line 1 (MAIN A.foo @ 2) ␤  at /tmp/Nf0AdwQpJj line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968_ANON @ 2) ␤  at /home/p6eval/niecza/lib/…

[09:57] <p6eval> ..rakudo 35ec9c: OUTPUT«Method 'b' not found for invocant of class 'A'␤  in method foo at /tmp/XDwEmaEC3W:1␤  in <anon> at /tmp/XDwEmaEC3W:1␤  in <anon> at /tmp/XDwEmaEC3W:1␤␤»

[09:57] <moritz> JimmyZ: right, but that's more of a difference in the compilation context than in the generated code object

[09:58] *** am0c left
[09:58] <Woodi> perl6: class A { has $!b = 10;  method foo() { say self!b }; }  my $b = A.new; $b.foo

[09:58] <p6eval> niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/7D5IP8Gk3q line 1:␤------> !b = 10;  method foo() { say self!b }; }⏏  my $b = A.new; $b.foo␤␤Parse failed␤␤»

[09:58] <p6eval> ..rakudo 35ec9c: OUTPUT«===SORRY!===␤Confused at line 1, near "class A { "␤»

[09:58] <p6eval> ..pugs: OUTPUT«10␤»

[09:58] <moritz> need a ; after the } that closes the class

[09:58] <moritz> or a newline

[09:59] <Woodi> perl6: class A { has $!b = 10;  method foo() { say self!b }; };  my $b = A.new; $b.foo

[09:59] <p6eval> rakudo 35ec9c: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Mu'␤  in <anon> at src/gen/Metamodel.pm:3029␤  in method dispatch:<!> at src/gen/CORE.setting:644␤  in method dispatch:<!> at src/gen/CORE.setting:656␤  in method foo at /tmp/ak6_fPNeDy:1␤  in <anon> at …

[09:59] <p6eval> ..pugs, niecza v9-32-g380d891: OUTPUT«10␤»

[09:59] <Woodi> perl6: class A { has $!b = 10;  method foo() { say self.b }; };  my $b = A.new; $b.foo;

[09:59] <p6eval> rakudo 35ec9c: OUTPUT«Method 'b' not found for invocant of class 'A'␤  in method foo at /tmp/Q7JQMfJEvA:1␤  in <anon> at /tmp/Q7JQMfJEvA:1␤  in <anon> at /tmp/Q7JQMfJEvA:1␤␤»

[09:59] <p6eval> ..pugs: OUTPUT«*** No such method in class A: "&b"␤    at /tmp/E2Bt12eIfM line 1, column 45-52␤»

[09:59] <p6eval> ..niecza v9-32-g380d891: OUTPUT«Unhandled exception: Unable to resolve method b in class A␤  at /tmp/UmTG8luWKq line 1 (MAIN A.foo @ 2) ␤  at /tmp/UmTG8luWKq line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968_ANON @ 2) ␤  at /home/p6eval/niecza/lib/…

[09:59] <Woodi> perl6: class A { has $!b = 10;  method foo() { say $b }; };  my $b = A.new; $b.foo;

[10:00] <p6eval> pugs: OUTPUT«*** ␤    Unexpected " };"␤    expecting "::"␤    Variable "$b" requires predeclaration or explicit package name␤    at /tmp/YEGH9P9njR line 1, column 47␤»

[10:00] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Variable $b is not predeclared at /tmp/TcEO80zcIS line 1:␤------> s A { has $!b = 10;  method foo() { say ⏏$b }; };  my $b = A.new; $b.foo;␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/…

[10:00] <p6eval> ..rakudo 35ec9c: OUTPUT«A<70099768>␤»

[10:00] <Woodi> i give up :)

[10:00] <JimmyZ> rakudo: class A { has $!b = 10; method foo() { say self!b }; }; my $b = A.new; $b.foo  # I think it's a bug

[10:00] <p6eval> rakudo 35ec9c: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Mu'␤  in <anon> at src/gen/Metamodel.pm:3029␤  in method dispatch:<!> at src/gen/CORE.setting:644␤  in method dispatch:<!> at src/gen/CORE.setting:656␤  in method foo at /tmp/FherJzZ4W9:1␤  in <anon> at …

[10:00] <moritz> Woodi: I recommend reading the chapter on objects and classes in https://github.com/downloads/perl6/book/2011.07.a4.pdf

[10:00] <moritz> Woodi: and http://perlcabal.org/syn/S12.html if you want the gory details :-)

[10:00] <JimmyZ> LTA bug?

[10:01] *** wamba left
[10:01] <Woodi> must be book, S12 not contain any use of class...

[10:01] <moritz> huh?

[10:01] <Woodi> any small-complete-example

[10:01] *** woosley1 left
[10:01] <moritz> JimmyZ: should probably read 'Cannot find private method b in class A' or so

[10:02] <JimmyZ> b: class A { has $.b = 10; method foo() { say self.b }; }; my $b = A.new; $b.foo  

[10:02] <p6eval> b 1b7dd1: OUTPUT«10␤»

[10:02] <JimmyZ> b: class A { has $!b = 10; method foo() { say self!b }; }; my $b = A.new; $b.foo  

[10:02] <p6eval> b 1b7dd1: OUTPUT«Method '!b' not found for invocant of class 'A'␤  in 'A::foo' at line 22:/tmp/kH2gKWVHoK␤  in main program body at line 22:/tmp/kH2gKWVHoK␤»

[10:02] <JimmyZ> b++ ;)

[10:02] <moritz> beijing++ indeed :-)

[10:03] * JimmyZ submits LTA bug

[10:03] <moritz> JimmyZ++

[10:06] <JimmyZ> speak of bug, rt didn't proctect email address

[10:06] *** JimmyZ left
[10:06] <moritz> JimmyZ: are you logged in?

[10:06] *** JimmyZ joined
[10:07] <JimmyZ> moritz: no

[10:07] <moritz> hm

[10:07] <moritz> well, in the end a copy goes to [email@hidden.address] and that doesn't protect the email either

[10:07] <moritz> or maybe not well

[10:07] <moritz> but that's how mailing lists work

[10:08] * JimmyZ would like to protect emails

[10:09] <szabgab> hi, can anyone help me with the rakudo compilation on windows?

[10:09] *** arthur-_ left
[10:09] <szabgab> I sent the failure to perl6-users yesterday but no reaction so far

[10:10] <szabgab> it starts by complaining that nqp.exe cannot be found and ends by a windows pop-up

[10:11] <moritz> what does the windows popup say?

[10:11] <moritz> .\nqp.exe --target=pir --output=src\stage2\QRegex.pir src\stage2\QRegex.nqp

[10:11] <moritz> gmake: *** [QRegex.pbc] Error -1073741515

[10:11] <moritz> that doesn't look good :(

[10:12] <moritz> ah right, I see it in your email

[10:12] <moritz> szabgab: is there a libparrot.dll somehwere in the install/ dir?

[10:13] <szabgab> nope

[10:13] <arnsholt> szabgab: Win64 or win32?

[10:13] <szabgab> 64

[10:13] <szabgab> but I think strawberry is 32 bit

[10:13] <arnsholt> Right. I think jnthn was wrangling some parrot-related problems on win64 the other day

[10:13] <arnsholt> Might be something similar you're running into

[10:14] <moritz> szabgab: or in the parrot/ folder maybe?

[10:14] <szabgab> yes I have parrot\libparrot.dll

[10:14] *** arthur-_ joined
[10:15] <moritz> szabgab: maybe try copying that to install\bin\

[10:15] <szabgab> http://www.nntp.perl.org/group/perl.perl6.users/2011/09/msg1540.html

[10:16] <moritz> it seems that -shared

[10:16] <moritz> "C:\work\rakudo\install\bin\libparrot.dll"

[10:16] <moritz> appears in the makefile

[10:16] <moritz> so the build system expects it to be there

[10:16] <JimmyZ> rm it 

[10:17] <szabgab> moritz: after copying libparrot.dll and running again perl Configure.pl --gen-parrot I get the same crash

[10:17] *** wamba joined
[10:17] <szabgab> oh in bin

[10:18] <jnthn> Note that for some reason we don't always end up with libparrot.dll getting copied into the right place...

[10:18] <szabgab> there is install\bin\libparrot.dll

[10:18] <jnthn> I dunno why...

[10:18] <szabgab> and still crashes

[10:18] <JimmyZ> rm all libparrot.dll s

[10:18] <jnthn> Yeah. If you run Rakudo from build directory it wants libparrot.dll in that directory too

[10:19] <jnthn> Not a problem after make install, afaik.

[10:19] <jnthn> I thougth the makefile had a line to copy it into the right place...will have to take a look and see what came of it.

[10:21] <szabgab> I removed the whole install directory and started again

[10:21] <szabgab> running perl Configure.pl --gen-parrot

[10:27] <szabgab> adn I get the crash, should I run some make install now?

[10:28] <moritz> won't do any good until nqp is properly build and installed

[10:28] <moritz> szabgab: what you could try: copy libparrot.dll into the nqp/ folder

[10:28] <jnthn> When is it failing

[10:28] <jnthn> ?

[10:28] <szabgab> http://www.nntp.perl.org/group/perl.perl6.users/2011/09/msg1540.html  <- jnthn 

[10:29] <moritz> szabgab: and then in that folder, run 'gmake install'

[10:29] <jnthn> OK, try what moritz++ suggested

[10:29] <jnthn> ah, I think we never needed to do that in NQP before QRegex came along; it invokes nqp.exe. We didn't tend to invoke it during nqp build before.

[10:29] <szabgab> so copy from install\bin\libparrot.dll to nqp\ ?

[10:30] <jnthn> szabgab: yes

[10:30] <szabgab> cd nqp; gmake install

[10:30] <moritz> right

[10:30] <szabgab> done

[10:31] <szabgab> and now?

[10:31] <moritz> did it work?

[10:31] <szabgab> it seems so

[10:31] <moritz> cd .. # back to rakudo

[10:31] <moritz> perl Configure.pl # without options

[10:31] <moritz> gmake

[10:31] <moritz> # and wait....

[10:31] <szabgab> waiting :)

[10:33] <szabgab> same popup crash

[10:33] <szabgab> different output on console

[10:33] <szabgab> gmake: *** [CORE.setting.pbc] Error -1073741515

[10:33] <moritz> then also copy libparrot.dll into the rakudo dir

[10:34] <szabgab> copy install\bin\libparrot.dll .

[10:34] <szabgab> gmake

[10:34] * jnthn suspects we should just get Configure.pl to do this copying.

[10:35] <szabgab> let's see if the copying helps at all :)

[10:36] <jnthn> *nod*

[10:37] <jnthn> I see you're building against Strawberry too, which I haven't tried. If it's got this far it's likely to work out though.

[10:37] <szabgab> ok, gmake worked

[10:37] <szabgab> what now?

[10:38] <szabgab> gmake test

[10:38] <szabgab> t\02-embed\01-load.t  failed

[10:40] <szabgab> ok, I have perl6.exe and it works when I am in the rakudo dir

[10:40] <szabgab> after running gmake install it also works outside

[10:40] <szabgab> thanks for your help

[10:41] <szabgab> now trying   gmake spectest

[10:41] <jnthn> Great. I'll try and patch the Configure.pls this evening.

[10:43] <szabgab> I see some of the tests in the spec are failing

[10:43] <szabgab> is there a way I can easily report them?

[10:44] *** odoacre_ left
[10:44] *** odoacre left
[10:44] <szabgab> or should I wait with that till thing get stable

[10:44] <szabgab> ?

[10:45] *** odoacre joined
[10:45] <jnthn> szabgab: I'd be interesting to know what fails.

[10:46] <jnthn> I've been getting clean test runs here of late.

[10:46] <jnthn> (Win64/MSVC)

[10:46] <szabgab> t\spec\S02-literals\radix.rakudo .......................... Failed 3/131 subtests

[10:46] <szabgab> t\spec\S02-magicals\args.t ................................ Failed 1/4 subtests

[10:46] <szabgab> so far

[10:47] <jnthn> Are you on 32 bit or 64?

[10:47] <szabgab> 64 bit machine

[10:47] <szabgab> Win7

[10:48] <szabgab> but strawberry is 32 I think

[10:50] *** wamba left
[10:50] <jnthn> ah, then you've probably got a 32-bit build

[10:50] <jnthn> We have some issues on 32 bit at the moment.

[10:54] <szabgab> ok, I won't have much time to play with rakudo anyway, just wanted to make sure I can at least compile it :)

[11:02] <szabgab> jnthn: it seems to be stuck on t\spec\S02-types\instants-and-durations.t .................

[11:02] *** breinbaa1 left
[11:03] <jnthn> szabgab: Yeah, that's one of the 32-bit issues ;(

[11:03] <jnthn> :(

[11:03] <szabgab> ok

[11:03] *** breinbaas joined
[11:11] *** wamba joined
[11:12] *** mishin left
[11:13] <snarkyboojum> "stuck on an instant" - that's kinda deep

[11:15] <jnthn> It gets stuck in an instant, for a long duration :P

[11:27] *** donri joined
[11:37] *** Patterner left
[11:39] *** wamba left
[11:40] *** JimmyZ left
[11:41] *** Psyche^ joined
[11:41] *** Psyche^ is now known as Patterner

[11:44] *** geekosaur joined
[11:47] *** jql joined
[11:48] <Woodi> perl6: class A { has $!b = 10;  method foo() { say $!b }; };  my $b = A.new; $b.foo;

[11:48] <p6eval> pugs, rakudo 35ec9c, niecza v9-32-g380d891: OUTPUT«10␤»

[11:48] <Woodi> tada :)

[11:51] <Woodi> do IO::Socket::INET defaults to TCP ?

[11:53] <moritz> I don't think anything else is implemented

[11:55] <Woodi> looks like it depends on parrot implementation

[11:56] <ingy> moritz: can action method return values change whether the match that invoked them is then considered a match?

[11:57] <moritz> ingy: no

[11:57] <moritz> that's what assertions are for.

[11:58] <ingy> moritz: good :)

[11:59] <ingy> I don't want to do it, but I thought maybe I was missing something important

[11:59] <ingy> and I already have assertions

[11:59] <ingy> =<foo> !<bar> <foo>

[12:01] *** _jaldhar joined
[12:02] <ingy> if an action return() the that branch is pruned, if return(undef) then the branch becomes the scalar (undef)

[12:02] <moritz> letting actions influence the parse goes against the whole concept of separating actions and parsing

[12:03] <ingy> moritz: right 

[12:03] <ingy> very good point

[12:03] <jnthn> Plus the action methods never return anything of interest.

[12:03] <jnthn> They always "make".

[12:03] <moritz> right, in p6 they make() stuff

[12:03] <moritz> not sure I like that part

[12:03] <ingy> jnthn: that's not the case in pegex

[12:04] <tadzik> yeah, I got stuck on that a few times

[12:04] <tadzik> it feels weird, it's a normal method, but it doesn't return

[12:04] <ingy> they are allowed to make stuff, but actually returning stuff looks like the better way out

[12:05] <moritz> hey, I just got a nice idea

[12:05] *** satyavvd left
[12:05] <moritz> one can use signature unpacking on $/ in action methods

[12:05] <jnthn> ooh!

[12:05] <tadzik> woo

[12:06] <ingy> each rule makes something by default, but an action method can change that

[12:06] <moritz> method foo( $/ (:$bar, :$baz) ) { no need for $<bar> or $<baz> here ... }

[12:06] <tadzik> looks magic

[12:07] <moritz> does signature unpacking work in nom already?

[12:07] <ingy> bbl :P

[12:10] <Woodi> perl6: class A { has $!b = 10;  method foo() { say $!b.perl }; };  my $b = A.new; $b.foo;

[12:10] <p6eval> pugs: OUTPUT«\10␤»

[12:10] <p6eval> ..rakudo 35ec9c, niecza v9-32-g380d891: OUTPUT«10␤»

[12:10] *** mtk joined
[12:14] <jnthn> moritz: yes

[12:16] <moritz> oh, but it doesn't do action methods yet :(

[12:20] *** colomon left
[12:31] *** packetknife joined
[12:32] *** benabik left
[12:32] *** JimmyZ joined
[12:34] <JimmyZ> nom: sub foo($/) { say "$<hi>, $<world>"; }; foo({ 'hi'=>'hello', 'world'=>'#perl6'});  #like this?

[12:34] <p6eval> nom 35ec9c: OUTPUT«hello, #perl6␤»

[12:35] <moritz> no

[12:35] *** bluescreen10 left
[12:36] <moritz> nom: sub foo($/ (:$hi, :$world)) { say "$hi, $world" }; foo { hi => 'hello', world => '#perl6' }

[12:36] <p6eval> nom 35ec9c: OUTPUT«hello, #perl6␤»

[12:36] <moritz> excpt that I'd pass in a Match object, not a hash

[12:40] <JimmyZ> b: ( -> { say $^hi, $^world; } )('hello', '#perl6'); 

[12:40] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Placeholder variable cannot override existing signature at line 22, near " )('hello'"␤»

[12:42] * JimmyZ couldn''t understand

[12:43] *** woosley joined
[12:43] <moritz> -> {  is an empty signature

[12:45] <JimmyZ> thanks

[12:48] *** bluescreen10 joined
[12:52] *** pernatiy joined
[12:54] *** packetknife left
[12:56] *** [particle] joined
[12:58] <felher> rakudo: enum Thing ( large => 'l', small => 's')

[12:58] <p6eval> rakudo 35ec9c: OUTPUT«===SORRY!===␤This type cannot unbox to a native integer␤»

[12:58] <felher> Is that regression known?

[12:58] * moritz didn't know about it

[12:58] <moritz> felher++

[12:59] * jnthn did.

[12:59] <jnthn> Just not doing non-numeric enums yet.

[13:00] <felher> jnthn: k :)

[13:02] <felher> Another thing: 

[13:03] <felher> rakudo: say (1 != 1 & 2); say ('a' !eq 'b' & 'c'); # where is the difference?

[13:03] <p6eval> rakudo 35ec9c: OUTPUT«all(False, True)␤Bool::True␤»

[13:05] <moritz> b: say (1 != 1 & 2);

[13:05] <p6eval> b 1b7dd1: OUTPUT«Bool::True␤»

[13:05] <moritz> I think that's a nom bug

[13:05] <moritz> rakudo: say (1 !== 1 & 2)

[13:05] <p6eval> rakudo 35ec9c: OUTPUT«Bool::True␤»

[13:07] <felher> moritz: They all should return junctions, shouldn't they? 

[13:08] <moritz> felher: no, since they are negated operators

[13:08] <moritz> (which are special-cased)

[13:08] <moritz> $a !op $b  should be the same as   not $a op $b

[13:09] *** kaleem left
[13:09] <felher> moritz: oh, okay, i see. So all(1,2) !== 3 is the same as '!all(1,2) == 3'?

[13:10] <moritz> minus precedence issues, yes

[13:10] <moritz> !(all(1,2) == 3)

[13:10] <felher> moritz: yeah, shold be 'not' instead of '!' :)

[13:10] <felher> moritz: thnx :)

[13:16] *** Holy_Cow joined
[13:16] *** packetknife joined
[13:16] *** Holy_Cow left
[13:17] <cognominal> nom: eval qq"sub $_ (*\%_ ) \{ elt('$_', |\%_) \}"  for < div >;

[13:17] <p6eval> nom 35ec9c: OUTPUT«Lexical '$!' not found␤  in sub eval at src/gen/CORE.setting:421␤  in block <anon> at /tmp/K7bUV8kDof:1␤  in method reify at src/gen/CORE.setting:3660␤  in method reify at src/gen/CORE.setting:3565␤  in method reify at src/gen/CORE.setting:3565␤  in method gimme at sr…

[13:18] <moritz> nom: say qq"sub $_ (*\%_ ) \{ elt('$_', |\%_) \}"  for < div >

[13:18] <p6eval> nom 35ec9c: OUTPUT«sub div (*%_ ) { elt('div', |%_) }␤»

[13:18] *** lumi_ left
[13:18] <moritz> nom: eval '1 2'; say $!

[13:18] <p6eval> nom 35ec9c: OUTPUT«Confused at line 1, near "1 2"␤»

[13:20] *** packetknife left
[13:21] *** lumi_ joined
[13:33] *** kaleem joined
[13:37] *** jimmy1980 joined
[13:48] *** jamtech joined
[13:53] *** PacoLinux joined
[13:53] *** uasi left
[13:53] *** wamba joined
[13:53] *** SHODAN left
[14:00] <[Coke]> phenny, tell jnthn I have a 32-bit windows 7 box that I've built nom on before using strawberry & visual studio. ping me if you need testing.

[14:00] <phenny> [Coke]: I'll pass that on when jnthn is around.

[14:02] *** SHODAN joined
[14:06] *** SHODAN left
[14:11] *** thou joined
[14:16] *** wolfman2000 left
[14:17] *** jimmy1980 left
[14:20] * [Coke] yawns.

[14:26] *** skangas__ joined
[14:26] *** skangas left
[14:27] *** wtw left
[14:31] *** kaare_ joined
[14:36] *** uasi joined
[14:40] *** [particle] left
[14:42] *** woosley left
[14:45] *** [particle] joined
[14:53] *** am0c joined
[14:55] *** [particle]1 joined
[14:55] *** [particle] left
[14:55] *** sayu joined
[14:56] * moritz hates error messages from pdflatex

[14:56] <moritz> they are sometimes quite obscure, and point into completely wrong directions

[14:57] <TimToady> phenny: tell ingy that if your grammar assumes ^ $ you can never use a grammar to parse a portion of a string, such as an embedded block in a different language

[14:57] <phenny> TimToady: I'll pass that on when ingy is around.

[14:58] <felher> Whats the easiest way to check if $value is in @array? $value == @array.any?

[14:58] *** sivoais joined
[14:59] <moritz> yes

[14:59] <felher> moritz: thnx :)

[14:59] *** Holy_Cow joined
[14:59] <moritz> if $value is a number, and you want to compare numerically, that is :-)

[14:59] *** Holy_Cow left
[14:59] <felher> moritz: yes, i do :)

[14:59] <TimToady> and if you don't want it fast :)

[14:59] <mux> no more grep($value, @array) ? :)

[15:00] <TimToady> you can do that too

[15:00] <moritz> well, if you want it fast, and @array is big, you're doing something wrong :-)

[15:01] * TimToady thinks about content addressabe memories...

[15:01] <TimToady> *able

[15:03] * moritz 's memory is also content addressable

[15:06] *** thou left
[15:08] <cognominal> as you get older, you don't loose much content but addressability becomes erratic.

[15:08] <sorear> good * #perl6

[15:09] <sorear> cognominal: my addressability has always been erratic...

[15:10] *** pjcj left
[15:10] *** pjcj joined
[15:11] * sorear needs a way to have irssi ignore p6eval's niecza-mentions

[15:11] *** daniel-s left
[15:11] <moritz> sorear: should p6eval misspell niecza? :-)

[15:11] <moritz> (I'm not quite serious)

[15:12] <sorear> moritz: hah.  No, because then people I care about will start spelling it the same way. :)

[15:14] <moritz> perl6: sub digitize($x) { $x.substr(0, 1) ~ ($x.chars - 2) ~ $x.substr(*-1) }; say digitize('niecza')

[15:14] <p6eval> rakudo 35ec9c: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:560␤  in sub infix:<<> at src/gen/CORE.setting:1929␤  in method substr at src/gen/CORE.setting:2636␤  in sub digitize at…

[15:14] <p6eval> ..pugs: OUTPUT«n4niecza␤»

[15:14] <p6eval> ..niecza v9-32-g380d891: OUTPUT«n4a␤»

[15:15] <TimToady> /niecza.[^v]/ or so

[15:16] <TimToady> highlighting goes wonky though

[15:16] <TimToady> someone needs to rewrite irssi into P6 :)

[15:17] <TimToady> doubtless there's some way to manage highlighting with a plugin, if you're devious enough

[15:18] <TimToady> and have nothing better to do...

[15:23] <sorear> anyone here played with smuxi?

[15:27] *** y3llow left
[15:27] *** y3llow_ joined
[15:27] *** y3llow_ is now known as y3llow

[15:29] *** am0c left
[15:31] *** am0c joined
[15:34] *** static_perl joined
[15:36] *** mtk left
[15:37] *** am0c left
[15:40] *** am0c joined
[15:42] <TimToady> jnthn: the fix for .Bool on // seems to need more help; I get "Cannot assign to non-container" in method Bool, which I presume is trying to set $/

[15:43] <TimToady> perhaps the // is closing over the wrong $/ somehow

[15:44] <TimToady> also, some kind of similar fix is needed for //.ACCEPTS

[15:44] <TimToady> maybe this is pmichaud++ territory

[15:44] *** supernovus joined
[15:45] <TimToady> more specifically, "when /(\d+)/ { $0 }" fails to set $0

[15:45] *** mkramer joined
[15:48] <jnthn> TimToady: Yeah, I realized that somehow I'd never quite followed through with implementing current spec on $/ and $! :S

[15:48] <phenny> jnthn: 14:00Z <[Coke]> tell jnthn I have a 32-bit windows 7 box that I've built nom on before using strawberry & visual studio. ping me if you need testing.

[15:48] *** mykhal joined
[15:48] <jnthn> TimToady: I need to re-read it and then twiddle. I somehow thought I'd done that already...

[15:52] <jnthn> TimToady: And yes, having a pmichaud++ around to look at it would be nice, but when that does happen then getting protoregexes back in place and NFA stuff integrated into nom is kinda higher priority. That's something I'd struggle with knowing how to do, whereas the $/ handling I can most likely figger out.

[15:52] <jnthn> :)

[15:52] <TimToady> just being a squeaky wheel...

[15:52] *** mtk joined
[15:52] *** uasi left
[15:54] <supernovus> It seems the features chart is slightly out of date (last updated Aug 20th). I'm not sure how many of the items have been updated since, but I know Date/DateTime are supported in nom now. I can update that, but I'm sure there's other features that should be updated. I'm just not sure which ones.

[15:54] *** Reaganomicon joined
[15:55] <TimToady> feel free to fix the parts you know about, and ignore the rest, or bug other people to fix

[15:55] <supernovus> TimToady: okay, works for me :-)

[15:59] <supernovus> And since DateTime is working again, I'll get DateTime::Utils fixed up to work with nom.

[15:59] <jnthn> I think we deserve a + on introspection in nom now. ng has one, and I consider nom at least as capable there, if not more so.

[15:59] <jnthn> Anyone want to explain to me what "Inheritance manipulation" means in the MOP section, so I can know if we do it? :)

[16:00] <jnthn> I mean, if you're constructing a class using the MOP, you can certainly .^add_parent

[16:00] <jnthn> That's how the compiler implements it.

[16:00] <TimToady> maybe they mean at run time

[16:00] <tadzik> supernovus: having DateTime fixed would be nice too :)

[16:01] <TimToady> or maybe they mean picking MRO

[16:01] <TimToady> or something WALKish

[16:02] <jnthn> class MyMROClassHOW is Metamodel::ClassHOW { method mro($obj) { ... } } # :-)

[16:02] <TimToady> we could probably figger out who to blame for adding it

[16:02] <jnthn> I'm quite sure you can implement your own MRO today, it's just diddling with the meta-object :)

[16:02] <jnthn> Yeah. I don't mind it being there, I'd just like to know whether I can give us a + or only a +/- :)

[16:03] <supernovus> tadzik: is it still broken? I haven't done much testing over here yet. I noticed I can at least create DateTime and Date objects again, and was going to throw DateTime up against strftime() and see what sticks ;-)

[16:03] <tadzik> supernovus: there are like 2 failing tests in DateTime.t

[16:03] <TimToady> looks like pmichaud++ added it

[16:04] <TimToady> or last edited the line :)

[16:05] <TimToady> probably just translated to json

[16:06] <supernovus> tadzik: I'll look into it, I haven't run the spec tests in far too long.

[16:06] <supernovus> tadzik: And since the spec tests aren't fully functional, I'll give nom the +- rating for DateTime for now.

[16:06] *** colomon joined
[16:07] <TimToady> yeah, would need to trace back through features.txt

[16:07] <tadzik> sounds good

[16:07] *** janosik joined
[16:08] <dalek> features: f38194f | (Timothy Totten)++ | features.json:

[16:08] <dalek> features: Changed DateTime/Date for nom to +-, changed Introspection for nom to +.

[16:08] <dalek> features: review: https://github.com/perl6/features/commit/f38194f748

[16:12] *** mberends joined
[16:13] *** mj41 left
[16:17] <sorear> o/ colomon, mberends

[16:17] <colomon> \o

[16:17] <sorear> (janosik too if you want it)

[16:18] *** replore left
[16:18] *** pjcj left
[16:18] *** pjcj joined
[16:19] *** im2ee joined
[16:19] <im2ee> Hi! :)

[16:19] <sorear> Hello and welcome, im2ee.

[16:20] <mberends> o/ sorear

[16:23] *** replore_ joined
[16:23] <moritz> nom: say (1 + *).WHAT

[16:23] <p6eval> nom 35ec9c: OUTPUT«WhateverCode()␤»

[16:24] *** am0c left
[16:25] <dalek> features: 1bc3ef4 | moritz++ | features.json:

[16:25] <dalek> features: nom does Whatever currying

[16:25] <dalek> features: 

[16:25] <dalek> features: also remove an entry where nobody else seems to know what it means

[16:25] <dalek> features: review: https://github.com/perl6/features/commit/1bc3ef4611

[16:27] <supernovus> well, there definitely is something weird with the current DateTime... DateTime.new(time) returns the proper UTC time. DateTime.now.utc is returning, err, okay, that's the problem, my current timezone is -0700 and DateTime.now is returning +0700... 

[16:29] <pmichaud> good morning, #perl6

[16:29] <mls_> hi pmichaud!

[16:29] <mberends> o/ pmichaud

[16:29] <sorear> hi pmichaud

[16:31] *** kaleem left
[16:32] <[Coke]> supernovus: checkout the recent todo'd spectests marked 'nom regression', that sounds familiar.

[16:33] <pmichaud> mainly stopping in to say "I'm still around" -- things have been a little hectic around here the past few days

[16:33] <pmichaud> (all is relatively well, though)

[16:33] <sorear> how are we for #phasers in 3040?

[16:34] <moritz> nom: say 3040 div 24, ' ', 3040 % 24

[16:34] <p6eval> nom 35ec9c: OUTPUT«126 16␤»

[16:35] <supernovus> it seems the internal local-timezone class is doing something wrong... it's returning 25200 as my timezone offset instead of -25200 ...

[16:35] <moritz> so, sign error?

[16:35] <flussence> .oO( didn't we have a divmod function? )

[16:35] <phenny> flussence: 18 Sep 08:30Z <tadzik> tell flussence since nom is now default, please feel free to file every Pod-related issue you have to RT; external memory is better for me to remember about stuff

[16:35] <flussence> tadzik: will do

[16:36] <tadzik> flussence: thanks

[16:36] *** static_perl left
[16:37] <jnthn> pmichaud: o/

[16:38] <[Coke]> pmichaud: o/

[16:38] <mls_> jnthn: here's an ugly patch for you to look at: https://gist.github.com/9be7df6c549eb2385b7e

[16:38] *** kaleem joined
[16:38] *** pjcj left
[16:39] <jnthn> mls_: but...but...I like pretty things! :P

[16:39] * jnthn looks

[16:39] <jnthn> mls_: My word, it's ugly :P

[16:39] <mls_> I don't see any better way to fix the :outer problem for CATCH blocks

[16:39] <jnthn> mls_: What's the problem it's solving?

[16:39] <jnthn> mls_: Well, I think (need to check the spec) we should be looking $/ up dynamically anyway

[16:39] <jnthn> er, $!

[16:40] *** pjcj joined
[16:40] <mls_> problem is, the CATCH block is already on the serialization queue

[16:40] <mls_> what about $_?

[16:40] <mls_> same thing?

[16:40] <jnthn> Why doesn't CATCH have its outer being the block it's in?

[16:40] <jnthn> That's what should happen really.

[16:41] <jnthn> If we're fudging in some other frame at the moment, that really wants to go away, I suspect.

[16:41] <mls_> Ok, we can also do that.

[16:41] <mls_> (Currently there's a an extra block that creates the exception)

[16:41] <mls_> (maybe for historic reasons)

[16:42] <pmichaud> ...there is?  that seems odd.

[16:42] * jnthn is looking at the code and can't quite tell

[16:42] <jnthn> But my brane is kind of a mess today, so :/

[16:42] <sorear> nom is doing serialization now?  I am so behind the times

[16:42] <jnthn> sorear: Not in that sense...though hopefully, soon.

[16:42] <mls_> the first $handler := line creates it

[16:43] <pmichaud> ah yes, I see the extra block.

[16:43] <jnthn> *nod*

[16:44] <jnthn> I'd rather see if we can not have that. Or at most, it only contributes to the dynamic scope, not the lexical one.

[16:44] <pmichaud> perhaps the handler should add code to the catch block instead of wrapping it in a new one

[16:44] <jnthn> That sounds preferable.

[16:44] <mls_> maybe it was added so that the handler doesn't change $_/$/...

[16:45] <pmichaud> I suspect it was simply "get something working"

[16:45] <pmichaud> since many aspects of exceptions were still fuzzy at the time

[16:47] <mls_> (Btw, jnthn, if you want a 10% speedup for mandelbrot, just change "$z.abs > 2" to "$z.abs > 2e0")

[16:47] <mberends> sorear: the Gtk text editor is beginning to work with plain text. Do you think we could get some syntax highlighting to work, and would you have time to help me when I get tuit (after next week's release)?  Btw, I'll probably make that #phasers time on Wednesday via mobile connection during decommute.

[16:47] <PerlJam> mls: that seems so backwards

[16:48] <mls_> yeah, that's something the optimizer should do ;)

[16:48] *** birdwindupbird left
[16:49] *** replore_ left
[16:49] <jnthn> Hm...not sure if the optimizer can do that too easily.

[16:49] <jnthn> It may be able to know that it's impossible for any of the same type candidates to match, mind.

[16:51] <mls_> Hmm, true, it can't assume that it's ok to promote a Int to Num in all cases

[16:51] <tadzik> mls_: why does it give such a speedup?

[16:51] <jnthn> It avoids a re-dispatch.

[16:51] <mls_> No more calls to .Bridge

[16:52] <tadzik> ah

[16:52] <jnthn> Num + Num ==> dispatch straight to the right candidate

[16:52] <jnthn> Num + Int ==> coercion, then re-dispatch.

[16:52] <jnthn> I suspect that kinda thing will only be made to look ever more ugly once we have an optimizer.

[16:52] <sorear> mberends: ...why are you writing a text editor?

[16:52] <sorear> my C text editor is slow enough already.

[16:53] <pmichaud> My gut still tells me that .Bridge is the wrong answer to this problem.

[16:53] * sorear is not thrilled with Bridge either

[16:54] <jnthn> pmichaud: That may be so. But even if it isn't, there's still probably going to be a double-dispatch (the multi candidate that coerces, then the one that does the work).

[16:54] <pmichaud> jnthn: I don't see a problem with special dispatch candidates for Int/Num variants.

[16:54] <jnthn> pmichaud: Well, there's that option too :)

[16:54] <jnthn> pmichaud: They do blow up exponentially 

[16:55] <pmichaud> I did a little playing around with some of these cases and managed to reduce things by one or two dispatches

[16:55] <jnthn> But I guess a given program will probably only use to many variants.

[16:55] <jnthn> s/to/so/

[16:55] <pmichaud> part of the problem is that .Bridge only fixes one candidate at a time, when it should probably be done in pairs

[16:55] <sorear> the blowup is only quadratic

[16:55] <jnthn> sorear: ah, true.

[16:55] <jnthn> sorear: That's bad enough.

[16:56] *** supernovus left
[16:56] *** thou joined
[16:56] <jnthn> Int, Num, Rat, Complex... :)

[16:56] <jnthn> Guess it ain't so bad.

[16:56] <pmichaud> Str

[16:56] <pmichaud> unless we're willing to live with the redispatches there :)

[16:57] <jnthn> pmichaud: I may be willing to live with those. :)

[16:57] <sorear> pmichaud: I think that "multiple dispatch" is only a sensible approach to the numeric ladder if the dispatcher itself knows about the Int->Rat->Num->Complex subtyping relationship

[16:57] <jnthn> I guess Rat + Int is going to be commonish.

[16:57] <jnthn> sorear: Well, the problem is that it's not a subtyping relationship.

[16:57] *** mberends left
[16:57] *** pjcj left
[16:57] <jnthn> nom: say Int ~~ Complex

[16:57] <p6eval> nom 35ec9c: OUTPUT«Bool::False␤»

[16:58] <jnthn> niecza: say Int ~~ Complex

[16:58] <p6eval> niecza v9-32-g380d891: OUTPUT«Bool::False␤»

[16:58] <pmichaud> I'm not certain about that relationship, fwiw.

[16:58] <sorear> jnthn: exactly

[16:58] <sorear> jnthn: as the types are currently defined, multiple dispatch on + doesn't make sense

[16:59] <jnthn> Well, in a sense, if people are trying to write fast code, they'll write in types. And probably use native ones anyway.

[17:00] <pmichaud> well, we'd like it to be "fast" even if they don't.  :-)

[17:01] <jnthn> Well, multi-dispatch in terms of the decision making process is pretty fast in nom now. :-) It's just that our only current backend is kinda slow on the invoke part, so re-dispatch is a pretty painful cost.

[17:02] <mls_> hmm, let me run the profiler...

[17:02] <jnthn> mls_: ooc, what does one feed the output of your profiler too? Or is it meant for direct human consumption?

[17:02] <mls_> no, it's meant for kcachegrind

[17:02] <jnthn> oh!

[17:03] <jnthn> OK :)

[17:03] <mls_> dunno if it exists for windows

[17:03] <jnthn> I did manage to coerce it into running on Windows once before.

[17:06] *** pjcj joined
[17:06] <mls_> invoke() cost seems to be 1%

[17:07] *** JimmyZ left
[17:07] <moritz> that's... surprisingly little bad

[17:07] <jnthn> uh.

[17:07] <pmichaud> ops or ticks?

[17:07] <moritz> wait, is that PIR level invoke?

[17:08] <jnthn> That's WAY off what you'll see if you look with a C profiler.

[17:08] <mls_> I mean the invoke for the Bridge calls ;)

[17:08] <jnthn> oh.

[17:08] <mls_> ticks

[17:08] <jnthn> Where is mandelbrot spending a lot of time, ooc?

[17:09] <mls_> on a hll or opcode level?

[17:09] <jnthn> hll

[17:10] *** plobsing left
[17:11] <mls_> well, the most time is spent in that inner block comparing z against 2

[17:11] *** plobsing joined
[17:13] <mls_> but only 6.5% is spent with opcodes from that block, about 30% is infix<+>, infix<>>, infix<*>, abs

[17:13] <jnthn> *nod*

[17:14] <PerlJam> so ... all we need is a single op to do all that and it'll be *much faster  ;)

[17:14] <mls_> ah, yes, a mandlebrot op!

[17:14] <mls_> mandel

[17:15] <jnthn> PerlJam: Well, or to implementing inlining ;)

[17:17] *** mberends joined
[17:17] <mls_> mandelbrot also spends 10% in @color_map[$_]. I wonder why that's so expensive.

[17:18] <pmichaud> subscripting is generally expensive

[17:18] <pmichaud> it can likely be optimized, but there's a fair bit that happens there

[17:18] <pmichaud> afk, lunch

[17:19] <moritz> mls_: too many redispatches, probably

[17:19] *** MayDaniel joined
[17:19] *** SHODAN joined
[17:19] <mls_> yes, many different functions involved

[17:20] *** packetknife joined
[17:20] <jnthn> food shop, bbiab

[17:21] <moritz> postcircumfix, at_pos, exists, gimme, 

[17:22] *** sayu left
[17:23] <TimToady> well, the thing Bridge should probably be doing is allomorphic caching

[17:23] <TimToady> not to the extend P5 mushes its scalars, but enough to not do the same work over and over

[17:23] <TimToady> *extent

[17:24] <TimToady> and constants like 2 should certainly be as allomorphic as possible

[17:24] <TimToady> well, within the bounds of Coolness

[17:25] *** packetknife left
[17:26] <TimToady> in the absense of type inference, the fastest run-time strategy will probably be do assume memoizing is useful on conversions, and disable it on values that are written as often as they are converted

[17:26] <TimToady> (once that trend is noted)

[17:26] <TimToady> P5 does some tricks like that

[17:27] <TimToady> though mostly on regex optimizations

[17:28] <TimToady> but since a constant can't be rewritten, memoization is a no-brainer

[17:29] <TimToady> esp if it can be done at compile-time, but then it starts looking like type inference :)

[17:29] <sorear> the complicating factors here are 1. multithreading 2. memory usage

[17:29] <TimToady> both good reasons to figure it out at compile time :)

[17:29] <PerlJam> no threaded compiles?

[17:30] <moritz> if I change the $z.abs > 2  to $z.abs > 2e0, mandelbrot goes down from 48.6s to 42.1s

[17:30] <TimToady> that's what I'm talking about

[17:30] <moritz> nom: say (48.6-42.1) / 48.6

[17:30] <p6eval> nom 35ec9c: OUTPUT«0.133744855967078␤»

[17:30] <im2ee> What is exactly a "nom"?

[17:30] <PerlJam> im2ee: it's the sound one makes while eating :)

[17:30] *** mj41 joined
[17:30] <TimToady> coincidentally, it stands for New Object Model

[17:30] <PerlJam> im2ee: or it's just the New Object Model branch of Rakudo

[17:31] <im2ee> TimToady, PerlJam , thanks. :)

[17:32] <TimToady> sorear: the single-ownership model of mutables probably helps with memoization under threading

[17:32] <mls_> afk -> home...

[17:33] <TimToady> if you're not the owner, you don't do it

[17:33] <TimToady> with immutables, it doesn't much matter who does it, as long as it's idempotent

[17:33] <sorear> who understands the single-ownership-model?

[17:34] <TimToady> beats me, but that never stopped me before

[17:34] <TimToady> I'm that fool that rushes in, y'know...

[17:35] <TimToady> but I suppose you might think of it as a funny kind of monad

[17:37] <colomon> as opposed to ingy, who is a funny kind of nomad?

[17:41] <TimToady> .oO(a 'mandelbrot op' is sorta what hotpath analyzers *do*, y'know...)

[17:41] * jnthn knows :)

[17:42] <jnthn> Just non-trivial (and fun ;-)) to build one :)

[17:42] <PerlJam> As soon as M0 hits the streets, builing a mandelbrot op on-the-fly should be easier.

[17:42] <PerlJam> s/builing/building/

[17:42] <TimToady> re subscript overhead, that's one of the reasons for the sigil policy, so that we can know that @a[$x] is a single subscript by definition, since $x can't flatten

[17:46] <TimToady> so it can hotpath around the whole slice processor

[17:46] <TimToady> P5 also had an optimization for literal subscripts, btw

[17:50] * ingy is nowmad

[17:50] <phenny> ingy: 14:57Z <TimToady> tell ingy that if your grammar assumes ^ $ you can never use a grammar to parse a portion of a string, such as an embedded block in a different language

[17:51] <ingy> TimToady: I'm not certain of that

[17:52] <ingy> I can invoke a parse with any start rule

[17:53] <ingy> which means that I can have actions that do launch entire new parses

[17:53] *** mj41 left
[17:53] <ingy> and then put the result of the sub parse into the ast that triggered them

[17:53] <ingy> .

[17:56] *** mj41 joined
[18:01] *** slavik1 left
[18:04] *** slavik1 joined
[18:07] *** molaf left
[18:09] *** benabik joined
[18:12] *** jamtech left
[18:13] *** jamtech joined
[18:14] *** packetknife joined
[18:18] *** pernatiy left
[18:22] *** PacoLinux left
[18:24] * sorear out

[18:24] *** molaf joined
[18:26] *** reokie joined
[18:29] *** reokie left
[18:30] *** envi_|2 left
[18:38] *** packetknife left
[18:40] *** PacoLinux joined
[18:46] *** shinobicl_ joined
[18:50] *** kaleem left
[18:58] *** Caldrin joined
[18:59] *** im2ee left
[18:59] *** im2ee joined
[18:59] <moritz> pmichaud: ping

[19:14] *** masak joined
[19:14] <masak> OH HAI #perl6

[19:15] <moritz> lol it's masak!

[19:16] <jnthn> o/ masak

[19:18] <mberends> oh hai masak

[19:19] <TimToady> o̐\

[19:19] <TimToady> (doffs hat)

[19:19] <jnthn> :)

[19:20] <jnthn> TimToady: So, there should be a $/ and $! per sub, and the mainline is a "sub" for this too. Is the lookup of them still lexical?

[19:21] <jnthn> Something about the "gather and async must also define them" made me think there was a switch to a dynamic lookup, but I just realized that didn't really follow :)

[19:21] <TimToady> last I heard :)

[19:21] <jnthn> OK.

[19:23] <TimToady> but it bears more thought...

[19:23] <jnthn> If you say that I'm gonna put off doing anything until you've thunk more :P

[19:26] *** daxim left
[19:28] <TimToady> that's probably...wise...

[19:28] <ingy> hi TimToady 

[19:28] <PerlJam> But then if you don't do something, you can't twiddle his thinking (which is probably why he needs to think more)

[19:29] <jnthn> TimToady: Is it safe to assume the "one $! and $/ per sub" thing is here to stay?

[19:30] <jnthn> Or, more likely than not?

[19:30] <jnthn> Well, if I do it I guess I make some bugs go away...so provided it doesn't make more new ones on the way it's a win ;)

[19:31] <TimToady> likely to stay, I think, but we do need to figure out how not to set $/ from things like grep: /pattern/

[19:31] <jnthn> Hm

[19:31] <jnthn> yeah

[19:31] <jnthn> That's why I was wondering about dynamic.

[19:31] <TimToady> and grep: sub { /pattern/ } is not the answer

[19:31] <jnthn> ew, no :)

[19:32] <jnthn> It also fixes the subst case :)

[19:32] <TimToady> well, even if we call it dynamically set, dynvars are still defined lexically

[19:32] <moritz> grep could localize $CALLER::</>

[19:32] <jnthn> ...wait, what? :)

[19:32] <jnthn> TimToady: I menat dynamically looked up.

[19:32] *** MayDaniel left
[19:32] <ingy> TimToady: can you reexplain why I would not want to anchor grammars

[19:32] *** REPLeffect left
[19:33] <TimToady> jnthn: yes, but the setting of $/ from within a matcher doesn't have to use that mechanism

[19:33] *** shinobicl_ left
[19:33] <jnthn> $foo.subst(/blah/, { #`the $/ in here is the one set in subst` }); #`out here, $/ not touched`

[19:34] <TimToady> what if you have a string that contains leading and trailing garbage you want to ignore; how do you parse that without substr()?

[19:36] <TimToady> jnthn: yes, that argues for dynamic reads too

[19:37] *** birdwindupbird joined
[19:37] *** birdwindupbird left
[19:37] <jnthn> TimToady: Yeah. I'm curious what the counter-examples for dynamic reads look like :)

[19:37] <TimToady> I suppose something that wants to be transparent can do $/ := CALLER::<$/> or some such

[19:38] <ingy> TimToady: well I feel like I'm creating an acmeist parsing language. it doesn't seem the job of a parsing language to write a json grammar that can pull json out of a garbage can.

[19:39] <ingy> but it I needed to do that I certainly could add garbage rules to the json-in-garbage grammar

[19:39] <TimToady> the question is who's to be master, that's all...

[19:40] <TimToady> that seems inside out to me

[19:41] <TimToady> the P6 view is that there is no priviledged level of grammar, and every lexical scope can have its own language, as it were

[19:41] <ingy> well I can certainly add a add-garbage-rules-to-my-grammar option in the parser

[19:41] <ingy> but I can't imagine ever needing it

[19:42] <ingy> unless I was wanted my grammars to also be general purpose regexen :D

[19:42] <cognominal> nom:  my ($a, $b) = "ab" ~~ /(a)(b)/; say "'$a' '$b'"

[19:42] <p6eval> nom 35ec9c: OUTPUT«'ab' ''␤»

[19:42] <TimToady> a parser at any level just starts at a point in the string, and ends at some other point; it's the outside of that that sets it going in the right starting spot, and verifies that the end spot is adequate

[19:42] <cognominal> what am I doing wrong here?

[19:43] <jnthn> nom:  my ($a, $b) = ("ab" ~~ /(a)(b)/).list; say "'$a' '$b'"

[19:43] <p6eval> nom 35ec9c: OUTPUT«'a' 'b'␤»

[19:43] <PerlJam> cognominal: you're not flattening or it's a bug

[19:44] <jnthn> I think you gotta .list it yourself.

[19:44] <ingy> TimToady: sure but for json or any other dsl you always start at the start and end at the end, so if I publish 1000 grammars and they all have ^ ... $ obviously I mad a mistake

[19:44] <TimToady> I suspect list assignment should do that for you

[19:45] <TimToady> ingy: it's the thing that applies the grammar that checks that, not the grammar itself

[19:46] <TimToady> or you just have alternate top rules, like the P6 grammar does

[19:46] <TimToady> TOP checks, and comp_unit doesn't

[19:47] <TimToady> TOP also also allows an alternate end to be specified from outside

[19:47] <ingy> so if I define a rul called TOP I don't need ^ or $ in my grammar?

[19:47] <ingy> pegex has a TOP special rule too...

[19:48] <TimToady> well, just don't make it impossible to work as an embedded parser, I don't much care how you don't do it :)

[19:48] *** MayDaniel joined
[19:49] <cognominal> thx jnthn++, TimToady++

[19:49] <TimToady> use inline python; python { ... }

[19:50] <ingy> TimToady: did you see earlier: https://gist.github.com/1227402

[19:50] *** im2ee left
[19:51] <ingy> TimToady: and you didn't answer: 15:47 < ingy> so if I define a rul called TOP I don't need ^ or $ in my grammar?

[19:52] <ingy> does TOP imply ^ $?

[19:54] <ingy> the Pegex TOP is special in that if you start a parse with rule aaa the default ast is {aaa: ...} whereas if you start with TOP it is just ...

[19:55] <jnthn> Well, switching to just one $! and $/ per routine, not per block, didn't break the build...let's see how spectest fares...

[19:56] <jnthn> ...oh dear.

[19:56] <TimToady> ingy: no, TOP does not imply ^ $

[19:57] <ingy> anyway I think that when you use a grammar/parser the normal case is that you want to parse an entire text. but parsing a substr should be a (non-default) option

[19:57] <ashleydev> Couldn't you add something equivalent to Lisp macros to languages like Perl or Python?: http://www.paulgraham.com/raq.html

[19:57] <phenny> ashleydev: 31 Aug 07:14Z <masak> tell ashleydev that yes, macros can be both AST-based and unhygienic. just defer all variable checks until macro-apply-time, and then have $x in the macro be the same as $x outside the macro. it's probably easier to implement than hygiene.

[19:58] <ingy> but I'm not entirely sure of myself, so I show up on #perl6 to eat brains

[19:58] <ashleydev> "Not without turning them into dialects of Lisp."

[19:58] <TimToady> parsers should not assume how they will be used

[19:59] <arnsholt> ashleydev: I read that too yesterday. I was amused ^_^

[19:59] <ingy> parser should assume how they will be used

[19:59] <arnsholt> masak: Apparently you're going to turn Perl 6 into a dialect of Lisp =D

[19:59] <ashleydev> haha

[19:59] <TimToady> too late

[19:59] <ingy> and provide alternatives when are needed :)

[19:59] <donri> you can simulate macros with python's standard libs

[20:00] <arnsholt> Simulate macros?

[20:00] <donri> well, in that they're not a language feature, but it does provide stuff like ast parser/compiler and import hooks

[20:00] <ingy> TimToady: anyway, thanks for your input. I don't think I'm missing anything at this point.

[20:03] *** bluescreen10 left
[20:04] *** packetknife joined
[20:04] *** localhost left
[20:05] <cognominal> nom: my ($a, $b) = ( "a \n<-> b" ~~ / ^ (.*?) ^^ '<->' (.*) / ).list ; say "'$a' '$b'"

[20:05] <p6eval> nom 35ec9c: OUTPUT«'' ''␤»

[20:05] <cognominal> it seems that there is no backtrack over ^^

[20:06] *** localhost joined
[20:07] *** mkramer left
[20:07] <jnthn> OK, I fixed eval up and now the switch to $! and $/ being per sub doesn't look quite so disasterous for spectest.

[20:08] <cognominal> cool, jnthn++, it seems I run into it today.

[20:09] <masak> arnsholt: what TimToady said. you seem to be under the impression that Perl 6 isn't a Lisp.

[20:10] *** Chillance joined
[20:10] *** BooK joined
[20:11] <jnthn> https://gist.github.com/1227465 # fallout from $! and $/ per sub

[20:11] <arnsholt> masak: Well, I do agree that Perl is definitely very Lispy

[20:11] <TimToady> 'course, it's also a Smalltalk, Java, Erlang, awk, sed, shell, C, C++, C#...

[20:12] <arnsholt> But phrasing it as only languages that are "dialects of Lisp" can have macros sort of implies the whole parentheticalness to me

[20:12] <cognominal> nice potpourri

[20:13] <TimToady> arnsholt: it's assuming that homiconicity can only be done with parens

[20:13] <masak> well, only *real* homoiconicity :P

[20:13] <TimToady> or however you spell that

[20:14] <TimToady> well, the Perl philosophy is to fake everything so well you can't normally tell the difference

[20:14] <masak> :)

[20:14] <arnsholt> Quite, quite

[20:15] <TimToady> we don't, however, define our lists using cons cells by default, though you can do cons using =>

[20:15] <cognominal> that's a lapsus, when TimToady thinks Lisp, he thinks homicide :)

[20:15] <jnthn> TimToady: Should eval bind its result to $!, or assign?

[20:16] <TimToady> part of the reason for simplifying the scoping of $/ and $! is to make it not matter, as long as we're consistent

[20:17] <jnthn> TimToady: ah, well, it's consistency we lack it turns out, now I see what's happening

[20:17] <jnthn> TimToady: try was binging, eval assigning. 

[20:17] <jnthn> er, binding :)

[20:17] <jnthn> so try { ... }; eval '...' # epic fail :)

[20:17] * jnthn switches eval to bind to see what happens

[20:18] <TimToady> it might be better to switch everything to assignment, so we can do $/ := CALLER::<$/> tricks

[20:18] <jnthn> heh

[20:18] <jnthn> turns out Parrot defines a find_caller_lex but not store_caller_lex

[20:18] *** _jaldhar is now known as jaldhar

[20:18] <jnthn> So if I switch to assignment I don't have to go and hack C to add an op

[20:18] <jnthn> So, assign wins ;)

[20:18] <TimToady> \o/

[20:20] *** bluescreen10 joined
[20:20] *** janosik left
[20:21] <BooK> TimToady: did you get my email? about a T-shirt

[20:22] *** kshannon joined
[20:23] <TimToady> ah, yes, I had overlooked it

[20:25] <jnthn> TimToady: Looks dramatically better after switching both to assign.

[20:25] <jnthn> Well, making try assign too.

[20:27] <jnthn> Yay. Down to just two test files with regressions now, both in S05.

[20:32] *** kaare_ left
[20:33] <TimToady> if $! and $/ become dynamic, we'd need some way of declaring control subs that don't declare $! and $/

[20:34] <TimToady> or force them to do $/ := CALLER::<$/> by convention

[20:34] <jnthn> fwiw, Rakudo's setting doesn't declare control-y things as subs.

[20:34] <TimToady> innersting

[20:34] <TimToady> that's anudda way

[20:35] <jnthn> Well, depends what you mean by "controlly things"

[20:35] <jnthn> my &redo := -> |$ { ... # for example

[20:35] <jnthn> Not quite sure what the rationale was for it; you'd hafta ask pmichaud++

[20:35] <TimToady> I'm thinking of things that take closures that used to close over OUTER::<$!> and such

[20:35] <TimToady> your ifs and whiles and such

[20:36] <TimToady> if we're going to look up CALLER::<$!> via their stack frames, they need to be transparent

[20:36] <jnthn> ah, I see

[20:37] <jnthn> Yeah, that's the big downside of them becoming dynamic.

[20:37] <jnthn> How waterbedesque.

[20:37] <TimToady> but control routines seem relatively rare, so can be de-huffmanized

[20:37] <jnthn> True. Whereas .subst is quite common :)

[20:38] <jnthn> OK, I have only 1 test file with regressions left. 

[20:38] <TimToady> or such routines can copy out their final $! or $/ if they want

[20:38] <TimToady> .match would, .subst wouldn't, to the first approximation

[20:39] <TimToady> or it's in the // s/// macro logic

[20:39] <jnthn> .subst not doing so would make masak happy :)

[20:40] <jnthn> ah, I think the failing test file is a victim of the changed semantics.

[20:40] <TimToady> but then how does s/// set $/, if it's hidden down in .subst?

[20:40] *** packetknife left
[20:41] <jnthn> Maybe either s/// doesn't desugar to .subst (though it probably should) or it passes along an adverb.

[20:41] <jnthn> {

[20:41] <jnthn>     my $str = "abcabcabc";

[20:41] <jnthn>     ok($str ~~ m:p/abc/, 'Continued match');

[20:41] <TimToady> an optional rw param to .match and .subst seems messy

[20:41] <masak> well, I hope you solve this ;) I'm going to bed.

[20:41] <jnthn> Here, it expected a fresh $/.

[20:41] <masak> g'nite, #perl6.

[20:41] <jnthn> night, masak

[20:41] *** masak left
[20:41] <tadzik> night

[20:41] <tadzik> dang!

[20:42] <jnthn> :)

[20:42] <tadzik> and he's talking about leaving too early!

[20:43] <TimToady> tadzik: you need an autoresponder :)

[20:43] <TimToady> jnthn: fix with a 'my $/' maybe

[20:44] <tadzik> well, it's Sweden, the road to bed is probably snowy, freezing and full of Polarizzly bears. Better leave to soon than too early

[20:45] <dalek> roast: b68a710 | jnthn++ | S05-modifier/pos.t:

[20:45] <dalek> roast: Update a test for current $/-per-routine spec.

[20:45] <dalek> roast: review: https://github.com/perl6/roast/commit/b68a71047b

[20:45] <jnthn> TimToady: coulda done that too..

[20:46] <jnthn> OK, final run through the spectests justin case, then I push.

[20:46] *** pmurias joined
[20:46] *** wallberg joined
[20:47] <pmurias> ingy: if TOP implies ^ and $ how am i supposed to turn that off?

[20:48] <PerlJam> pmurias: matach a subrule?

[20:49] <dalek> rakudo/nom: 7563146 | jnthn++ | src/ (3 files):

[20:49] <dalek> rakudo/nom: Switch to having a $! and $/ per routine, not per block. Also consistently use assignment, not binding, for $! and $/.

[20:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7563146c33

[20:50] <BooK> TimToady: thanks

[20:50] <pmurias> PerlJam: and if TOP contains a lot of stuff? copy and paste it?

[20:50] <jnthn> There we go...that wasn't so bad as I feared. Time for a beer.

[20:51] <tadzik> what does it fix?

[20:51] <tadzik> oh, I think I know

[20:53] <jnthn> tadzik: The patch I just did?

[20:53] <jnthn> tadzik: Our non-compliance with the spec ;)

[20:53] <jnthn> Though maybe some other bits too :)

[20:53] <jnthn> pmurias: No, TOP would just ^ <that_rule> $ I guess.

[20:55] *** SHODAN left
[20:56] <TimToady> cognominal: yes, niecza and ng seem to agree it's a bug in nom

[20:56] <TimToady> perl6: my ($a, $b) = ( "a \n<-> b" ~~ / ^ (.*?) ^^ '<->' (.*) / ).list ; say "'$a' '$b'"

[20:56] <p6eval> niecza v9-32-g380d891: OUTPUT«'a ␤' ' b'␤»

[20:56] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped b…

[20:56] <p6eval> ..rakudo 35ec9c: OUTPUT«'' ''␤»

[20:57] <jnthn> TimToady: I think nom still has general issues backtracking, fwiw.

[20:57] <TimToady> well, a pm thing, likely

[20:57] <jnthn> very much so 

[20:59] <TimToady> whoa, Method 'postcircumfix:<[ ]>' not found for invocant of class 'CallContext'

[20:59] <jnthn> o.O

[20:59] <jnthn> That should really not happen.

[21:00] <TimToady> the line in question:             $s ~= @row[^20]».fmt("%3s ").join.subst(/^' '/,'');

[21:00] <TimToady> which doesn't tell you much :)

[21:01] <tadzik> hehe

[21:01] <tadzik> that reminds me of something :>

[21:02] <jnthn> tadzik: yes. :(

[21:02] <jnthn> tadzik: Wasn't it something like that we were seeing in wherefore-gc?

[21:02] <tadzik> jnthn: certainly

[21:02] <jnthn> :'(

[21:02] <TimToady> and if I take out the » it segfaults

[21:02] <jnthn> That's bad news.

[21:02] <tadzik> also when I tried to fix multi-line docs

[21:03] <jnthn> TimToady: bt may help.

[21:03] <jnthn> TimToady: But I doubt it. It's almost certainly very action-at-a-distance.

[21:03] <jnthn> (GC issue)

[21:03] <tadzik> TimToady: try with parrot -G perl6.pbc 'file' maybe?

[21:04] <TimToady> hope I have enough memory :)

[21:04] <tadzik> if you can build nom you surely have lots of it :P

[21:05] *** benabik left
[21:11] <TimToady> well, it got a different error, after a great deal of thrashing on a 3gig system :)

[21:11] <tadzik> :P

[21:11] <TimToady> so yeah, probably GC corruption

[21:11] *** MayDaniel left
[21:16] *** wallberg left
[21:27] *** sbp left
[21:27] *** nsh left
[21:54] <sorear> good * #perl6

[21:54] <sorear> jnthn: what's the last word on $/ and $!?

[21:56] <diakopter> sorear: his last commit made them per-routine, afaik

[21:56] <jnthn> sorear: Latest is that they're per-routine (and mainline gets them)

[21:56] <jnthn> sorear: And whether lookup of them is dynamic or lexical is still up in the air

[21:56] <jnthn> sorear: nom has it as lexical 

[21:56] <jnthn> (mostly because that was the current state)

[21:56] <jnthn> I think niecza has them per-routine anyway? If so, in that regard I think we just converged a bit :)

[21:57] <jnthn> Also, $/ and $! are now consistently assigned to, not bound.

[21:58] <jnthn> (We did a bit of each before...)

[21:58] <jnthn> (As in, nom did a bit of each)

[22:00] <sorear> jnthn: I am tentatively -1 to assigning to $/ and $!.  I have an optimization which saves two allocations per routine entry that requires $/ and $! to be bound, not assigned

[22:01] <jnthn> sorear: Well, it should be all assignment or all binding, not the accidental mixture we had. TimToady++ preferred assignment as it makes $/ := CALLER::<$/> style things possible.

[22:01] <sorear> jnthn: requiring allocating two containers in the prologue makes me :(

[22:02] <jnthn> sorear: It'd in theory make me :( too but (1) it's per routine and (2) I allocate them lazily in nom.

[22:02] <sorear> jnthn: I wasn't aware that there was a mixture - I thought it was all binding

[22:02] <sorear> jnthn: please elaborate on (2)

[22:02] <jnthn> sorear: The mixture in nom was accidental, not intentional.

[22:03] <jnthn> sorear: I have a "trap" for if the lexpad lookup comes back as null (which should never happen). If it hits that trap, it checks if it's one of the magicals being looked up and creates the container then.

[22:03] <jnthn> So things that never need a $!, $_ and $/ never end up allocating a container.

[22:04] <jnthn> I figure a smart inliner would be able to further cheapen that by tossing the check in a lot of cases. But for now a null check per lexical access is vastly cheaper than all the allocations.

[22:05] *** bluescreen10 left
[22:05] <dalek> rakudo/nom: e062a4c | jnthn++ | src/Perl6/Metamodel/ (2 files):

[22:05] <dalek> rakudo/nom: Make role Foo[::T] does Bar[T] { ... } work.

[22:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e062a4cf2b

[22:05] <dalek> rakudo/nom: 178ddf6 | jnthn++ | src/ (2 files):

[22:05] <dalek> rakudo/nom: Refactor so that we create a BUILDPLAN at a per-class level as well as for the whole hierarchy.

[22:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/178ddf600c

[22:15] *** mj41 left
[22:20] *** bluescreen10 joined
[22:26] <tadzik> gah, I don't get it

[22:27] <tadzik> token comment:sym<#=> { [ '#=' {say('almost there')} \h+ $<attachment>=[\N*] ] } prints 'almost there' 6 times

[22:27] <tadzik> when I change that to [ ... ]+, it doesn't print it at all

[22:30] *** jamtech left
[22:34] <jnthn> tadzik: Confuses me too, fwiw.

[22:34] <jnthn> Not sure why it'd be doing that.

[22:34] <tadzik> maybe it causes the regex to be pre-compiled in a wrong way, for some reason

[22:38] *** jamtech joined
[22:38] <jnthn> mebb

[22:38] <jnthn> *mebbe

[22:39] <dalek> rakudo/nom: d9b19d6 | jnthn++ | src/Perl6/Metamodel/MROBasedTypeChecking.pm:

[22:39] <dalek> rakudo/nom: Add missing .^does.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9b19d682e

[22:39] <dalek> rakudo/nom: e97afdb | jnthn++ | src/core/ (2 files):

[22:39] <dalek> rakudo/nom: Ensure that when we mix in a role, its attributes are initialized appropriately (for example, any defaults are applied).

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e97afdb4b6

[22:39] <dalek> rakudo/nom: 9256ee2 | jnthn++ | t/spectest.data:

[22:39] <dalek> rakudo/nom: We now pass S14-roles/parameterized-mixin.t.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9256ee2bb6

[22:39] <dalek> rakudo/nom: b10ef51 | jnthn++ | NOMMAP.markdown:

[22:39] <dalek> rakudo/nom: Remove completed tasks from nommap.

[22:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b10ef51901

[22:41] <jnthn> We can probably have a + on the parametric roles entry on features now too. :)

[22:41] *** domm left
[22:43] *** arnsholt left
[22:45] <diakopter> jnthn: I'll update it

[22:45] *** packetknife joined
[22:46] <jnthn> diakopter: thanks!

[22:46] <jnthn> Didn't get a clone of that on my new machine yet...

[22:47] <dalek> features: 8fae163 | diakopter++ | features.json:

[22:47] <dalek> features: 17:41 < jnthn> We can probably have a + on the parametric roles entry on features now too. :)

[22:47] <dalek> features: review: https://github.com/perl6/features/commit/8fae1633a4

[22:47] *** packetknife left
[22:53] <tadzik> jnthn: why does BUILD_LEAST_DERIVED take arguments, some future plans?

[22:53] <jnthn> yeah

[22:53] <jnthn> $foo does Answer(42)

[22:54] *** wamba left
[22:55] *** pmurias left
[22:56] <tadzik> mhm

[22:56] <tadzik> sleepytime, g'night!

[22:58] <jnthn> night, tadzik 

[23:01] *** jamtech left
[23:02] *** jamtech joined
[23:06] *** envi_|2 joined
[23:08] *** buubot_backup left
[23:11] *** molaf_ joined
[23:16] *** molaf left
[23:17] *** packetknife joined
[23:18] *** bluescreen10 left
[23:28] *** buubot_backup joined
[23:30] *** bluescreen10 joined
[23:32] <jnthn> sleep for me &

[23:33] *** packetknife left
[23:34] *** envi_|2 left
[23:59] *** uasi joined
