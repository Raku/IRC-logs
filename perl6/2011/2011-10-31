[00:02] <[Coke]> sorear: 5 test files failed in niecza spectest

[00:03] <[Coke]> djanatyn: the SYNopses have an IO chapter. Not sure if the book does.

[00:03] <japhb> The good news is that the performance of @A X~ @A is only slightly worse than linear in (@A X~ @A).elems, and that could just be a matter of the size of the strings.  The problem seems to be that the coefficient sucks -- only ~600 elements/second on my box.

[00:04] *** alester left
[00:15] *** donri left
[00:16] <djanatyn> okay, got it :D

[00:17] <djanatyn> perl6 is fun!

[00:20] *** replore_ joined
[00:20] <djanatyn> I'm a little confused on how regex works, though.

[00:21] <[Coke]> they're... a little different than from p5.

[00:22] <djanatyn> in the original perl5 code I was writing, I had the code: for (<FILE>) { if (/^DTSTART:(.+)/) { print "date: $1\n"; } }

[00:26] *** Grrrr left
[00:26] *** DarthGandalf left
[00:27] *** MayDaniel left
[00:28] *** DarthGandalf joined
[00:31] *** Grrrr joined
[00:40] <djanatyn> are $1, $2, and $3 just like in perl5?

[00:40] *** wolfman2_ left
[00:41] *** daniel-s joined
[00:41] <[Coke]> I believe they start at 0 now.

[00:41] <djanatyn> aaaaaaaaah

[00:41] <djanatyn> okay, that makes more sense

[00:41] <djanatyn> I always wondered why they didn't start at zero

[00:42] <djanatyn> that also explains why my code was acting weird

[00:43] <[Coke]> nom: "DTSTART: foobar" ~~ /^^ DTSTART: (.*)/ && say $0

[00:43] <p6eval> nom 36d829: OUTPUT¬´=> <: foobar>‚ê§‚ê§¬ª

[00:44] <djanatyn> do I have to escape \: now?

[00:45] *** japhb left
[00:45] <[Coke]> nom: "DTSTART: foobar" ~~ /^^ 'DTSTART:' (.*)/ && say $0

[00:45] <p6eval> nom 36d829: OUTPUT¬´=> < foobar>‚ê§‚ê§¬ª

[00:45] <[Coke]> sorry, yes, colon is, as in many places in p6, special.

[00:46] <djanatyn> ah, that's okay

[00:49] <djanatyn> yay, I've got it doing the same thing as the perl5 code in less lines

[00:50] <djanatyn> https://gist.github.com/1326659

[00:53] <djanatyn> perl6 has macros? ...like, lisp macros? O_o

[00:57] <[Coke]> the spec does. ;)

[00:58] <djanatyn> hmm, I 

[00:58] <djanatyn> heh :)

[00:58] <[Coke]> masak++ is working on them for rakudo.

[00:58] <djanatyn> so, how do they work, exactly?

[00:58] <djanatyn> and does any implementation have them yet?

[01:00] <[Coke]> There's a been a lot of chat on the channel in the past week or so yet. No, I think masak's work is the first.

[01:03] <djanatyn> is the syntax for anonymous arrays the same as in perl5?

[01:05] <[Coke]> nom: sort(1,2,3,5,6).say

[01:05] <p6eval> nom 36d829: OUTPUT¬´1 2 3 5 6‚ê§¬ª

[01:06] <djanatyn> push @array, ($foo, $bar); # would this push a two element array containing $foo and $bar onto @array?

[01:10] <djanatyn> nope, looks like I need to change those parentheses to square brackets

[01:12] *** japhb joined
[01:14] *** frzntoz joined
[01:15] <colomon> [Coke]: is it normal to get a number of hangs in the test running?

[01:18] *** envi_ joined
[01:20] *** DarthGandalf left
[01:30] *** cooper joined
[01:31] <djanatyn> yay, I finished it :D

[01:31] <djanatyn> and made a sandwich and coffee too

[01:31] <TimToady> \o/

[01:32] <djanatyn> now to split things into classes

[01:32] <TimToady> ooh, class warfare!

[01:32] <djanatyn> and I can start processing the data and figuring out neat things about the birthdays of all my friends

[01:33] <djanatyn> I can actually do a few things now. let's see which day of the year has the most birthdays:

[01:37] <djanatyn> hmm

[01:38] <djanatyn> how do I go through each key in a hash?

[01:38] *** whiteknight left
[01:38] <djanatyn> like, in a for loop. can I just use a for loop?

[01:38] * djanatyn hasn't used perl in a long time >_>

[01:38] *** ponbiki left
[01:38] <TimToady> %hash.keys in p6

[01:39] <TimToady> or often, for %hash.kv -> $key, $value { ... }

[01:39] *** ponpon joined
[01:39] *** ponbiki joined
[01:40] <djanatyn> for %hash.keys -> $key { say "%hash{$key}"; } # like this?

[01:41] <djanatyn> okay, gerat

[01:41] <djanatyn> *great

[01:41] <TimToady> well, in that case you could just use .values

[01:41] <djanatyn> that's awesome :D

[01:41] <TimToady> but if you want to sort them, we usually use sort %hash.pairs -> $p { $p.key, $p.value)

[01:46] <colomon> std: sort %hash.pairs -> $p { $p.key, $p.value)

[01:46] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable %hash is not predeclared at /tmp/skirxUJx7R line 1:‚ê§------> [32msort [33m‚èè[31m%hash.pairs -> $p { $p.key, $p.value)[0m‚ê§Unexpected block in infix position (method call needs colon or parens to take arguments) at /tmp/skirxUJ‚Ä¶

[01:46] <colomon> std: my %h; sort %hash.pairs -> $p { $p.key, $p.value)

[01:46] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable %hash is not predeclared at /tmp/YrnSo8fiyL line 1:‚ê§------> [32mmy %h; sort [33m‚èè[31m%hash.pairs -> $p { $p.key, $p.value)[0m‚ê§Unexpected block in infix position (method call needs colon or parens to take arguments) at /tmp/‚Ä¶

[01:46] <TimToady> works better with a 'for'

[01:46] <colomon> oh

[01:47] <colomon> I thought you were doing some weird form of sort, with -> $p { $.pay, $p.value } as the schwartzian transform

[01:48] <colomon> (which is why I was trying to check to see if it was actually legal.  :)

[01:48] <sorear> [Coke]: about a year ago, I implemented the simplest case of string macros for Rakudo, but the code was very horrible and I didn't want it merged

[01:48] <[Coke]> colomon: when running the non-running tests? yes. You could try sorear's ulmit -t trick.

[01:49] <colomon> [Coke]: so far I'm just watching and killing by hand

[01:49] <[Coke]> colomon: yah, that's what I did. ;)

[01:51] <djanatyn> i'm just trying to figure out if multiple occurences of an item in an array occur

[01:51] <dalek> 6model: 3d901f4 | diakopter++ | lua/ (18 files):

[01:51] <dalek> 6model: tons of bugfixes

[01:51] <dalek> 6model: review: https://github.com/diakopter/6model/commit/3d901f47fb

[01:52] <djanatyn> I have an array of 2 element arrays, containing a date, and a name

[01:53] <djanatyn> I want to figure out how many occurences of each date there are

[01:53] <djanatyn> so I made a hash, and each time a date occurs, it uses that date as the key and increments the value by one

[01:53] <djanatyn> so I can track each occurence

[01:54] <djanatyn> and, it turns out, when you try to increment a value for a key that doesn't exist, it intializes that key with a value of zero and sets it to one!

[01:54] <djanatyn> so, hooray!

[01:54] <[Coke]> autovivification.

[01:54] <djanatyn> is that what it's actually called?

[01:54] <TimToady> part of it

[01:54] <TimToady> the part that creates it

[01:55] <djanatyn> that's awesome

[01:55] <TimToady> the other part is that operators know their bootstrap identity values

[01:55] <djanatyn> perl 6 is the most polite language

[01:55] <TimToady> nom: say [+]

[01:55] <p6eval> nom 36d829: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 1‚ê§¬ª

[01:55] <TimToady> nom: say [+]()

[01:55] <djanatyn> it's like, "oh, it looks like it would be a pain in the neck to do this the hard way, let me just help you out"

[01:55] <p6eval> nom 36d829: OUTPUT¬´0‚ê§¬ª

[01:55] <TimToady> nom: say [*]()

[01:55] <p6eval> nom 36d829: OUTPUT¬´1‚ê§¬ª

[01:56] <TimToady> so if you do *= to an autovivified value, it assumes there's already a 1 there

[01:56] <djanatyn> good guy perl6

[01:58] *** DarthGandalf joined
[01:58] <dalek> 6model: 16a57be | diakopter++ | lua/Runtime/MultiDispatch/MultiDispatcher.lua:

[01:58] <dalek> 6model: missing file

[01:58] <dalek> 6model: review: https://github.com/diakopter/6model/commit/16a57be400

[02:02] <djanatyn> :D

[02:02] <djanatyn> wow, that's amazgin

[02:02] <djanatyn> *amazing

[02:06] <djanatyn> https://gist.github.com/1326748 -- it totally works!

[02:15] <djanatyn> interesting!

[02:15] <djanatyn> the most common day for birthdays on my facebook is 10/30, with 7 birthdays

[02:16] *** snarkywork joined
[02:18] <djanatyn> ...hey, that's today!

[02:18] <snarkywork> djanatyn: looks like ics is the iCal file format - http://en.wikipedia.org/wiki/ICalendar ?

[02:18] <snarkywork> djanatyn: would be a great module for modules.perl6.org :D

[02:19] <djanatyn> snarkywork: ...sure?

[02:19] <djanatyn> I'd like to do that

[02:19] <djanatyn> but this code is really specialized and specific

[02:19] <djanatyn> it doesn't actually parse iCal, it just uses regex to find specific information

[02:19] <djanatyn> but yeah, that seems like a fun thing to do! I'll have to find out more about the iCal format.

[02:19] <snarkywork> could always be generalised later - write a little Perl6 grammar for it, if you wished

[02:20] <snarkywork> djanatyn++ # great idea :)

[02:22] <snarkywork> supporting the whole iCal file format might be a lot of work, but you could start by just parsing a subset, and slowly build it up

[02:23] <djanatyn> yeah

[02:25] <djanatyn> are there any good graphing modules for perl6, or should I just transfer this information into a flat text file and graph it with Chart::Clicker in perl5?

[02:29] <snarkywork> djanatyn: not too sure (doesn't appear to be any on modules.perl6.org really)

[02:37] *** envi_ left
[02:47] <dalek> 6model: 02121da | diakopter++ | lua/Runtime/MultiDispatch/MultiDispatcher.lua:

[02:47] <dalek> 6model: most of MultiDispatcher porting

[02:47] <dalek> 6model: review: https://github.com/diakopter/6model/commit/02121daaa9

[02:48] <japhb> It seems that in rakudo, creating '@A X~ @B' using a sub based on gather/take is a LOT faster than a sub based on push'ing the results on a big array.  Looking at the low-level code, it looks like part of what makes this fast is direct Parrot support for gather/take.  In niecza, should I also expect gather/take to be much faster than @result.push?

[02:54] <TimToady> push typically has to keep reallocating the array as it grows, unless it cheats and peeks how much is incoming

[02:54] <TimToady> (which p5 can do because it's eager)

[02:55] *** frzntoz left
[02:56] <TimToady> using .plan might be faster than .push

[02:56] *** wolfman2000 joined
[02:56] <TimToady> but maybe not

[02:57] <dalek> 6model: 718d631 | diakopter++ | lua/Runtime/MultiDispatch/MultiDispatcher.lua:

[02:57] <dalek> 6model: rest of MultiDispatcher porting

[02:57] <dalek> 6model: review: https://github.com/diakopter/6model/commit/718d631312

[02:59] <diakopter> forgot about Signatures.  4 more files.

[03:04] <djanatyn> is there an article I could read about writing modules for perl6?

[03:25] *** Chillance left
[03:31] *** snarkywork left
[03:40] <djanatyn> ...what exactly is := ?

[03:40] <djanatyn> is it defining an array as a function?

[03:42] <djanatyn> my @fib := 1, 1, *+* ... *; # found this in a blog post

[03:42] <benabik> djanatyn: := is binding.  It makes a variable mean something else instead of store something else.

[03:42] <benabik> nom: my $x = 1; my $y := $x; $y = 2; say $x

[03:42] <p6eval> nom 36d829: OUTPUT¬´2‚ê§¬ª

[03:42] <benabik> nom: my $x = 1; my $y = $x; $y = 2; say $x

[03:42] <p6eval> nom 36d829: OUTPUT¬´1‚ê§¬ª

[03:42] <djanatyn> oh, cool!

[03:42] <djanatyn> so it's binding an expression to that array?

[03:43] <benabik> It's binding the list to the variable.

[03:44] <djanatyn> oh, okay

[03:44] <djanatyn> is there an easy way to describe what * means when declaring a list?

[03:46] <benabik> The * at the end of the list means there is no end.

[03:46] <benabik> *+* is roughly the same as sub($x, $y) { $x + $y }

[03:48] <djanatyn> okay, I see

[03:51] <benabik> *, aka Whatever, is very useful.

[03:51] <benabik> nom: say (-pi, 0, pi).map: *.cos

[03:51] <p6eval> nom 36d829: OUTPUT¬´-1 1 -1‚ê§¬ª

[03:56] *** mkramer joined
[03:59] <dalek> 6model: 65fea87 | diakopter++ | lua/Runtime/Signatures/SignatureBinder.lua:

[03:59] <dalek> 6model: most of SignatureBinder.lua

[03:59] <dalek> 6model: review: https://github.com/diakopter/6model/commit/65fea87bbf

[04:17] *** daniel-s left
[04:18] *** mkramer left
[04:29] *** mkramer joined
[04:29] *** mkramer left
[04:31] <djanatyn> man, now that I wrote some perl6 code, I'm so excited that I don't want to go back to reading my common lisp book ;)

[04:31] <djanatyn> common lisp is exciting, but kinda ugly sometimes

[04:31] <djanatyn> and haskell is too hard for me right now

[04:31] <djanatyn> perl6 is fun! I dunno what to do with it, though

[04:36] <dalek> 6model: 83f8cb9 | diakopter++ | lua/Runtime/Signatures/SignatureBinder.lua:

[04:36] <dalek> 6model: rest of SignatureBinder.lua

[04:36] <dalek> 6model: review: https://github.com/diakopter/6model/commit/83f8cb9b7a

[04:41] *** bluescreen10 left
[04:44] *** gorbad joined
[04:49] *** kaleem joined
[04:53] <dalek> 6model: 377bf88 | diakopter++ | lua/Runtime/Signatures/Signature.lua:

[04:53] <dalek> 6model: Signature.lua

[04:53] <dalek> 6model: review: https://github.com/diakopter/6model/commit/377bf88a31

[05:04] <moritz> o/

[05:05] <dalek> 6model: 48d5e3b | diakopter++ | lua/Runtime/Signatures/ (2 files):

[05:05] <dalek> 6model: Parameter.lua

[05:05] <dalek> 6model: review: https://github.com/diakopter/6model/commit/48d5e3b14c

[05:09] <dalek> 6model: 2b82bd4 | diakopter++ | lua/Runtime/Signatures/DefinednessConstraint.lua:

[05:09] <dalek> 6model: DefinednessConstraint

[05:09] <dalek> 6model: review: https://github.com/diakopter/6model/commit/2b82bd4437

[05:10] <diakopter> yay; that completes the port of 6model/dotnet to Lua

[05:10] <moritz> why lua? because you can?

[05:11] <diakopter> heh

[05:11] <diakopter> an experiment I guess

[05:15] *** orafu left
[05:17] *** orafu joined
[05:21] <diakopter> now to start on porting jnthn's nqp->C# compiler to nqp->lua

[05:21] <diakopter> theoretically it's just a matter of syntax, and adjusting for the one-indexed tables

[05:22] <diakopter> well, and converting the whole compile-to-assembly to compile-to-requirable-lua-module.

[05:22] <diakopter> that should be pretty straightforward.

[05:23] <diakopter> phenny: tell jnthn initial port complete; ready for emitter translation

[05:23] <phenny> diakopter: I'll pass that on when jnthn is around.

[05:23] *** preflex_ joined
[05:24] *** preflex left
[05:24] *** preflex_ is now known as preflex

[05:34] *** kaleem left
[05:35] *** drbean left
[05:36] *** kaleem joined
[05:38] *** daniel-s joined
[05:41] *** drbean joined
[05:45] <dalek> 6model: dc565a3 | diakopter++ | lua/ (101 files):

[05:45] <dalek> 6model: move into foo dir

[05:45] <dalek> 6model: review: https://github.com/diakopter/6model/commit/dc565a31c5

[05:46] <dalek> 6model: 662ac2e | diakopter++ | lua/ (90 files):

[05:46] <dalek> 6model: rename foo to runtime

[05:46] <dalek> 6model: review: https://github.com/diakopter/6model/commit/662ac2e5bf

[05:58] *** molaf joined
[06:01] *** drbean left
[06:07] *** kaare_ joined
[06:08] *** drbean joined
[06:09] *** sftp left
[06:13] *** molaf left
[06:14] * sorear ponders priorities for the next 25 hours

[06:20] <dalek> niecza: 1b30eff | sorear++ | lib/Cursor.cs:

[06:20] <dalek> niecza: Better error message for /<perl>/ et al (fixes #69)

[06:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1b30eff2a7

[06:22] <sorear> bugs?  rewriting outdated documentation?  BEGIN?

[06:22] <diakopter> BEGIN :)

[06:22] <diakopter> mberends would say docs

[06:31] <japhb> Performance and correctness test of existing nom Str.Numeric(): https://gist.github.com/1327012

[06:31] * japhb pops another yak off the stack

[06:32] <sorear> niecza #73 is more complicated than it looks

[06:35] * diakopter looks

[06:35] <dalek> niecza: dab6499 | sorear++ | lib/CORE.setting:

[06:35] <dalek> niecza: List.pick shouldn't overwrite the variables it returns (fixes #73)

[06:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/dab649965d

[06:38] * japhb looks at the size of the current yak, looks at the clock, decides to sleep instead

[06:38] <japhb> g'night all

[06:38] *** Trashlord left
[06:39] <sorear> niecza: my $str = "a\"b\\c"; $str ~~ s:g { <["\\]> } = '\\' ~ $/; say $str

[06:39] <p6eval> niecza v10-245-g1b30eff: OUTPUT¬´a\"b\\c‚ê§¬ª

[06:41] *** cooper left
[06:42] *** koban joined
[06:43] <sorear> nom: say <a b c>.pick xx 3

[06:43] <p6eval> nom 36d829: OUTPUT¬´c c c‚ê§¬ª

[06:43] <dalek> niecza: ab36838 | sorear++ | lib/CORE.setting:

[06:43] <dalek> niecza: Escape backslashes and quotes in Str.perl (fixes #72)

[06:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ab36838232

[07:06] <sorear> What exactly does BEGIN { @*INC.push: ... } mean?

[07:07] <moritz> what do you think it means? :-)

[07:07] <moritz> it means, at BEGIN time, push something to @*INC

[07:08] <sorear> my first idea is that it modifies @PROCESS::INC, which is verboten since anything that cannot be saved is read-only at BEGIN time

[07:09] <moritz> "cannot be saved"?

[07:10] <sorear> when the compilation unit is serialized

[07:10] <moritz> why can't it be saved?

[07:10] <sorear> not so much "read-only" as "inaccessible" I suppose

[07:10] <sorear> because it's not per-module

[07:11] * moritz surpresss his desire to yell "just make it work"

[07:12] <sorear> heh, current niecza has a *horrible* hack dedicated to exactly that

[07:12] <moritz> :-)

[07:12] <sorear> it recognizes BEGIN { @*INC.push("string-literal") } by AST walking and then modifies the search path correctly-ish

[07:13] <moritz> I'm fine with changing it all to 'usb lib ...;', but rakudo doesn't implement that yet :(

[07:13] <moritz> and since neither approach is specced, the one used in roast is what worked in the earlier compiler(s)

[07:13] <sorear> the other side of this question is, what should be the scope of BEGIN { @*INC }?

[07:14] <sorear> I guess it can't reasonably be inherited by importing modules

[07:15] <moritz> sorear: on second thought it could be a feature that all modules share @*INC

[07:15] <moritz> you set it up once in your mainline, and then the modules can just 'use' their dependencies

[07:15] <masak> g'mornings, #perl6

[07:15] <sorear> allowing modules to share variables directly opens up a can of worms.

[07:15] <moritz> \o masak 

[07:16] <sorear> o/ masak

[07:16] <masak> I need to understand this "cannot be saved when the compilation unit is serialized" business.

[07:16] <moritz> how do other languages do it?

[07:17] <masak> it seems to make BEGIN mostly useless.

[07:17] <sorear> moritz: most other languages do it by not having BEGIN at all, or not having precompilation

[07:17] <sorear> Perl 6 is pretty unique for wanting both

[07:18] <masak> what's precompilation?

[07:18] <sorear> masak: the basic rule in Niecza is, read-write access to local state, read-only access to data from imported modules

[07:18] <masak> oh, saving compiled things. I see.

[07:18] <masak> sorear: makes sense.

[07:18] <sorear> masak: A.pm6: 'use B; constant foo = B::bar' # this is ok

[07:18] <masak> right.

[07:19] <sorear> masak: A.pm6: 'use B; BEGIN { push @B::bar, 5 }' # this is not ok

[07:19] <masak> *nod*

[07:20] <sorear> what I've decided to do is add a synthetic dynamic scope as the CALLER of all BEGINs, and add @*INC to that as local state

[07:21] <sorear> otoh, this won't allow modules to find their transitive dependencies, hmm.

[07:22] <sorear> because of the caching of compiled modules thing I'm skeptical of anything that allows A to influence B's parsing

[07:22] <sorear> masak: I'd like you to test your apps with new-niecza, ideally before the release tomorrow evening :)

[07:23] <masak> will do.

[07:23] <masak> oh, it's still Sunday where you're at? :)

[07:23] <masak> yes, of course it is.

[07:24] <sorear> well, 0024

[07:24] <masak> ah.

[07:24] <masak> I just arrived to $work.

[07:24] <sorear> When I say "tomorrow" I often mean "after I've slept", even if it's already past midnight :)

[07:25] <sorear> or as my mom puts it: "It ain't tomorrow 'till I've slept."

[07:25] <masak> that's a fine rule-of-thumb ;)

[07:25] <masak> quietfanatic was saying something similar on Twitter the other day.

[07:28] <masak> http://twitter.com/quietfanatic/status/130331607524573184

[07:28] <sorear> Maybe the cache should be keyed on (unitname, @*INC) instead of just unitname...?

[07:28] <sorear> .o( If I'm going to call it a cache I should probably give it a size limit and LRU eviction code )

[07:29] <sorear> OTOH, I've been thinking a bit about a whole-system redesign, elaborating on S11 and handling :auth, etc etc

[07:31] <masak> ooh

[07:32] <masak> I think those parts suffer slightly from overdesignitis, at least where things like module databases enter the picture.

[07:32] <sorear> the place S11 really goes wrong imo is that it assumes the unit of software packaging is the single class

[07:32] <masak> on the other hand, it's difficult to try to deliver on all of the promises without a module database... :/

[07:32] *** dual left
[07:32] <masak> sorear: what, according to you, is the unit of software packaging?

[07:32] <sorear> nobody is going to write POE6 as a single file

[07:32] <masak> right.

[07:33] <sorear> masak: a group of one or more files that have tight interconnections

[07:33] <sorear> CLR assemblies, Java jars, CPAN distributions - these are all instantiations of the same Platonic ideal and I think we would do well to move Perl6 closer to it

[07:34] <masak> aye.

[07:35] <sorear> importantly, all of these systems have metadata common to and external to the various classes

[07:35] <masak> nice HN comment comparing teaching Scheme to teaching Python: http://news.ycombinator.com/item?id=3176295

[07:35] <masak> (via @chromatic_x)

[07:35] <masak> sorear: prototype it in Niecza, without much regard for the spec. then we'll spec it.

[07:36] *** mkramer1 joined
[07:37] <sorear> I agree with that comment

[07:38] <sorear> I'm really bad with these primitive concept things.  I didn't _really_ get programming until I understood how to build a computer out of transistors

[07:39] *** Trashlord joined
[07:42] <masak> ;)

[07:43] <masak> I find it refreshing sometimes to remember that there are people who find assignment bewildering. I can't even recall a time when I did.

[07:44] <sorear> for bureaucratic reasons I'm currently taking an intro to programming class.  Most of my classmates don't grok assignment.

[07:45] *** mkramer joined
[07:45] *** mkramer1 left
[07:48] <moritz> sorear: what language are they teaching?

[07:48] <snarkyboojum> I still remember learning to pronounce ":=" in Pascal as "set equal to" heh #probably had to be there

[07:48] <sorear> moritz: Java

[07:50] <snarkyboojum> yay bureacracy

[07:50] <snarkyboojum> bureaucracy*

[07:54] <dalek> niecza: a1c7d29 | sorear++ | / (3 files):

[07:54] <dalek> niecza: Change BEGIN to be run immediately instead of an alias for INIT

[07:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a1c7d299c9

[07:55] *** baest left
[07:55] *** baest joined
[07:58] <sorear> TimToady: is the assignment in my \x = foo; syntacticallyspecial?

[07:59] <sorear> TimToady: (I am thinking it has to be; if my \x were a normal declarator it would have to decide whether to make a scalar or list constainer)

[07:59] *** mishin_ joined
[08:01] *** finanalyst joined
[08:06] <masak> sorear: for many years I've found it almost immorally wrong to be teaching OO to intro-to-programming students. hearing that many of them don't grok assignment makes me more set in that opinion.

[08:07] <masak> I wonder if we in the programmers' guild are exceptionally bad at the didactic bits.

[08:07] * sorear thinks it's almost immorally wrong to teach OO *period*, but I digress

[08:07] <masak> ;)

[08:10] *** GlitchMr joined
[08:11] * masak was weaned on BASIC, so by EWD he's forever corrupted and probably shouldn't have opinions about didactics

[08:11] *** gorbad left
[08:11] <masak> though I doubt that EWD would've appreciated OO in its different forms.

[08:12] <sorear> well by that logic we shouldn't let TimToady teach a language, nevermind design one

[08:13] <szabgab> tadzik: if I am not mistaken your blog post http://ttjjss.wordpress.com/2011/10/24/muevent-anyevent-lookalike-for-perl-6/ got into ironman but not into PlanetSix, any idea why?

[08:14] <szabgab> and apparently that's the only Perl 6 related post in the last week

[08:14] <masak> :/

[08:14] <sorear> o/ szabgab 

[08:14] <szabgab> ./

[08:14] <masak> argh, gotta blog more...

[08:14] <masak> I have things to write about, just few tuits.

[08:15] <szabgab> I have 3 wooden tuits in my hand

[08:15] <szabgab> but they are heavily used

[08:15] * masak learns about http://en.wikipedia.org/wiki/Dijkstra_Prize and wonders how many people have won a prize *and have the whole prize renamed in their honour*

[08:16] <sorear> ow! my hand is bit by the circularity saw

[08:17] <sorear> apparently making enum Bool < False True > call EnumMap.new at BEGIN time adds a bunch of new ordering dependencies to the setting

[08:17] <masak> pmichaud has been complaining about the circularity aspects of Bool.

[08:17] <masak> to the point where he doubts it's even possible.

[08:21] *** daxim joined
[08:28] <sorear> *shrug* it's not really any more circular than the idea that ClassHOW is a class

[08:28] <sorear> at worst it will require knot-tying and fakery

[08:29] <moritz> nom: say ClassHOW.HOW

[08:29] <p6eval> nom 36d829: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&ClassHOW' called (line 1)‚ê§¬ª

[08:29] <moritz> nom: say Int.HOW.HOW

[08:29] <p6eval> nom 36d829: OUTPUT¬´Method 'gist' not found for invocant of class 'NQPClassHOW'‚ê§  in sub say at src/gen/CORE.setting:5274‚ê§  in block <anon> at /tmp/nC7CfX3KF8:1‚ê§  in <anon> at /tmp/nC7CfX3KF8:1‚ê§¬ª

[08:29] <sorear> niecza: say Int.HOW.HOW

[08:29] <p6eval> niecza v10-248-ga1c7d29: OUTPUT¬´ClassHOW.new(...)‚ê§¬ª

[08:32] * masak .oO( Alexandrian knot-tying as a way to solve problems )

[08:38] <Woodi> found something like 'CICS' http://en.wikipedia.org/wiki/CICS but wander what it realy is - something like Unix daemon or OS subsystem ? 

[08:40] <snarkyboojum> briefly, for a newbie, what does YOU_WERE_HERE mean? :D

[08:40] <Woodi> and just wondering maybe such thing can be used to do STM work in Perl. or just maybe implement kernel module (accesible via syscal) to do Multi-Compare-And-Swap for transactions opearting on few structures at once...

[08:41] <Woodi> just something lov-lvl...

[08:41] <Woodi> low :)

[08:42] <masak> snarkyboojum: it's YOU_ARE_HERE, and that's where your program is inserted into a setting.

[08:42] *** GlitchMr42 joined
[08:42] <snarkyboojum> Woodi: CICS is a mainframe system to run customer centric backend processing and stuff :)

[08:43] <snarkyboojum> masak: ah! that's sheds some light - the "where your program is inserted into a setting" - thank you

[08:43] <masak> snarkyboojum: so the -n flag corrsponds to something like the program 'for lines() { {YOU_ARE_HERE} }'

[08:44] *** odoacre joined
[08:44] <snarkyboojum> Woodi: I have used CICS is a past life #not that it's perl6 related :)

[08:44] *** GlitchMr left
[08:46] <sorear> Woodi: multi-CAS as a kernel module?  do you have a clue what you're talking about?  if not, can I help>?

[08:50] <snarkyboojum> anyone read the OMeta paper by Alessandro Worth, "Experimenting with Programming Languages"? Some cool ideas in there, Worlds being one of them.

[08:51] <Woodi> sorear: a little, just if such functionality as syscall would be fast enough comparing to implementations using few CASes

[08:51] *** mj41 joined
[08:51] <snarkyboojum> was also struck by the use of 'World' in masak++s macro gists

[08:51] <Woodi> snarkyboojum: so what is CICS ? what kind of software, daemon, library ?

[08:52] <sorear> Woodi: lol

[08:52] <snarkyboojum> Woodi: a mainframe software system - unless we're talking about different things

[08:53] <Woodi> sorear: if 90% of Fortune 500 use CICS for transaction then fast kernel module for transaction do not looks bad idea

[08:53] <sorear> Woodi: you're lucky if a syscall is 100 times slower than CAS

[08:53] <sorear> Woodi: transaction, as in, you buy stuff from a company

[08:53] <Woodi> snarkyboojum: but compared to Unix ?

[08:53] <sorear> Woodi: not the same as STM at all

[08:54] <sorear> Woodi: CICS handles business transactions

[08:54] <sorear> Woodi: prints invoices, etc

[08:54] <snarkyboojum> Woodi: it's software - it's runs on an OS, a Unix probably - nothing to do with STM or programming languages :)

[08:54] <Woodi> sorear: but what it is... :) deamon, app ?

[08:54] <sorear> Woodi: it does not matter

[08:54] <sorear> Woodi: it is completely irrelevant

[08:55] <Woodi> i know :) just looking for 'transaction mechanism'

[08:56] <sorear> You are frustrating me.

[08:56] <masak> snarkyboojum: 'World' is just a more fitting term for 'SymbolTable'.

[08:57] <Woodi> sorear: it is not my intention! just creativity of someone who do not know something cannot be done :)

[08:57] <Woodi> it somethimes work i hear

[08:57] <snarkyboojum> masak: cool - World means something bigger in OMeta, but was just struck by the similarity in terminology

[08:57] <masak> snarkyboojum: oh, I didn't know OMeta used the term.

[08:59] <Woodi> snarkyboojum: how apps use CICS ? by sending request via network or via API from libraries ?

[08:59] <snarkyboojum> masak: check out http://bit.ly/urzzW3 - struck by quite a few design similarities between OMeta and Perl6 - though perhaps that's stretching

[08:59] <snarkyboojum> really fun read too imo

[09:00] <sorear> snarkyboojum: how do I convince Woodi that "implement STM using CICS" is not a brilliant maverick idea but rather patent nonsense?

[09:00] <snarkyboojum> sorear: I'm not really sure :)

[09:00] <Woodi> sorear: i want functionality of transaction, pls do be so straight on names...

[09:01] <snarkyboojum> Woodi: I'd rather not try and remember if that's ok with you :) It's pretty much off-topic here.

[09:01] <sorear> Woodi: in English, some words have more than one meaning

[09:01] <masak> snarkyboojum: ah, I think I've seen this one before and at least skimmed it. looks interesting indeed.

[09:01] <Woodi> not off topic at all

[09:02] <masak> Woodi: when regulars tell you that you have misunderstood a word and you're off topic -- pro tip -- listen to them.

[09:02] <masak> do not argue. that makes you look like a bit of a fool. and you're not one, I know that.

[09:03] <masak> in general, when people tell you "you are wrong about this", at least review your points before charging ahead and protesting.

[09:03] <tadzik> hello #perl6

[09:03] <masak> good morning, tadzik 

[09:03] <Woodi> masak: problem is that i know that i not mess things, just compressed many things in 2 sentences

[09:04] <sorear> masak: my thoughts here are "if only I could express myself eloquently in, say, Polish!"

[09:04] <tadzik> szabgab: seems that I forgot to set a category. Interesting that it got to ironman then, they probably show everything, including pictures of birds and squirrels

[09:04] <masak> Woodi: I'm with sorear on this one. you're speaking nonsense. business transactions != database/software transactions

[09:05] <masak> Woodi: it's like someone were to say "I've heard trampolines are very powerful in software. I have a plank and some springs -- what do I do?"

[09:05] <tadzik> szabgab: should be fixed now

[09:05] <Woodi> masak: pls go to source - read what i say, ok ? 

[09:05] <masak> Woodi: I did.

[09:06] * masak decides not to waste more time on this discussion

[09:06] <sorear> stupid NullReferenceException acting all impossible to debug

[09:08] *** Chillance joined
[09:34] <tadzik> szabgab: it got there just now, thanks for noticing

[09:45] * Woodi thinks mutexes can do semaphore work and something else can "do STM work", what I say. so assuming someone say something not always is that 

[09:46] <sorear> ahahaha - found the issue - BEGINs weren't getting lexical storage correctly allocated

[09:46] <sorear> need to get better at not taking the lowest level code for granted

[09:46] * sorear sleep

[09:48] <szabgab> I hate the trailing 's in English - or rather I don't understand it

[09:50] <dalek> nqp/bigint: f8beb9d | moritz++ | src/6model/reprs/P6bigint.c:

[09:50] <dalek> nqp/bigint: avoid allocations and deallocations in bigints {s,g}eg_int

[09:50] <dalek> nqp/bigint: 

[09:50] <dalek> nqp/bigint: jaeckel++ in #libtom told me that this works reliably, and a look into the

[09:50] <dalek> nqp/bigint: source confirms it

[09:50] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/f8beb9d627

[09:51] <geekosaur> Woodi thinks mutexes can do semaphore wor

[09:51] <masak> szabgab: do you mean just the Saxon genitive, or contractions like "it is"/"it has" -> "it's"

[09:51] <masak> ?

[09:52] <szabgab> "this years YAPC" 

[09:52] <szabgab> or "this year's YAPC"?

[09:52] <moritz> the latter

[09:52] <szabgab> isn't that the same as "this year is YAPC" ?

[09:52] <moritz> no

[09:53] <moritz> the 's indicates possesion

[09:53] <szabgab> "Gabor's headache"

[09:53] <moritz> "the YAPC belongs to this year"

[09:53] <moritz> "years" would be plural

[09:53] <geekosaur> sort of, you can implement semaphores using mutexes.  you are also reinventing the wheel, possibly with more coners than is considered acceptable.  likewise STM can be built from ore primitive components

[09:53] <szabgab> so I think I have been doing this in the wrong way for 20 years now :)

[09:54] <moritz> szabgab: I'm glab your mind is still flexible enough to admit that (not easy after 20 years) :-)

[09:54] <geekosaur> the "is" version only applies to "it's" vs "its" which is inconsistent with the more common possessive form, which is why many native English speakers get it wrong :)

[09:55] <szabgab> emptyness is very flexible

[09:55] <szabgab> geekosaur: that explains it

[09:57] <masak> geekosaur: right -- if you learn only the rule "X's means possession", you'll get "its"/"it's" wrong.

[09:57] <jnthn> moritz: yay, nice :)

[09:57] <phenny> jnthn: 05:23Z <diakopter> tell jnthn initial port complete; ready for emitter translation

[09:58] <masak> it explains many of the grammatical errors related to "its"/"it's" because most of these people are actually *following the rule*, they just don't know about the exception.

[09:58] <moritz> good morning jnthn :-)

[09:58] <jnthn> diakopter: Great! \o/

[10:00] <jnthn> Grr, I want to do Perl 6 stuff all day, but probably should worry a bit about $dayjob things first :)

[10:05] *** GlitchMr_42 joined
[10:05] *** envi_ joined
[10:06] *** envi_ left
[10:06] *** envi_ joined
[10:09] *** GlitchMr42 left
[10:12] <moritz> it's funny how I wrote those bigint tests, and started with a negative number and thought "there's no reason why negative numbers shouldn't work, but no harm done by being extra careful"

[10:13] <moritz> and of course they broke :-)

[10:13] <jnthn> moritz++ # takes a negative view of my code

[10:13] <jnthn> ;-)

[10:14] <moritz> jnthn: I didn't think whose code it was, just general testing paranoia :-)

[10:14] <jnthn> moritz: I'm getting close with the repr refactors. Once they're done, I'll need to update Rakudo to cope with them. After that, I'll update bigint branch to work with it. Then we can make a Rakudo branch to start trying to integrate this there. :)

[10:15] <masak> moritz++ # testing paranoiac

[10:17] * moritz wonders about implementing exponentation for bigints

[10:17] <jnthn> moritz: Isn't there a function for that?

[10:17] <moritz> libtommath offers mp_pow(mp_int base, unsigned long exp)

[10:18] <moritz> which kinda makes sense, because when the exponent is larger than 'unsgined long', you're having a problem anyway :-)

[10:18] <jnthn> :D

[10:19] <masak> unless your base is 1.

[10:19] <jnthn> Then we'll still get the right answer even if we truncate :P

[10:19] <moritz> or 0

[10:19] <masak> or -1.

[10:19] <masak> i and -i are fine too, I guess.

[10:20] <moritz> but they are not Int

[10:20] <moritz> so not my problem right now

[10:20] <masak> they are GaussInt :P

[10:20] <jnthn> masak worries about imaginary problems :P

[10:20] * masak has complex issues

[10:20] <masak> colomon++ # pun

[10:22] <masak> it's so typical of our "realist" culture, that we're allowed to have irrational problems and negative issues, but as soon as someone starts talking about something imaginary...

[10:23] <masak> ...we get told to multiply by the complement and move on with our lives.

[10:25] <geekosaur> "please rotate your phone 90 degrees and try your call again"

[10:28] *** replore_ left
[10:41] *** kfo joined
[10:42] *** jesk left
[10:44] *** jesk joined
[10:45] *** kfo_ left
[10:46] *** koban left
[10:53] *** mishin_ left
[11:01] *** pmurias joined
[11:01] *** preflex left
[11:01] *** preflex_ joined
[11:02] *** preflex_ is now known as preflex

[11:05] *** sftp joined
[11:13] <bbkr> tadzik++ # MuEvent

[11:17] <jnthn> bbkr: Any chance you can check https://rt.perl.org/rt3/Ticket/Display.html?id=101912 is now fixed for you?

[11:22] <bbkr> jnthn: sure, i'll take a look at it after $dayjob, thanks for taking care of this bug!

[11:22] *** SHODAN joined
[11:27] * djanatyn attempts to install rakudo on windows

[11:27] <djanatyn> Are there any perl 6 developers on windows?

[11:28] * jnthn does Rakudo dev on windows

[11:28] <jnthn> Use ActivePerl + MSVC compiler tool chain.

[11:28] <jnthn> For a smooth experience

[11:28] <jnthn> :)

[11:28] * djanatyn should really install cygwin

[11:28] <jnthn> oh noes

[11:28] * jnthn hates cygwin.

[11:29] <jnthn> I've no clue if Rakudo works under that or not.

[11:29] <jnthn> Just do a "real" Windows build :)

[11:30] <djanatyn> I've been putting it off, since I don't have to use Windows very much

[11:30] <djanatyn> why do you hate cygwin?

[11:30] <djanatyn> I like cygwin because I'm much more comfortable doing development in a *nix environment

[11:31] <jnthn> It's sorta like *nix but sorta like Windows so you end up having to cope with the quirks of both.

[11:31] <djanatyn> Oh, not nice.

[11:32] <djanatyn> I've used rakudo on fedora and on debian

[11:32] <jnthn> It's probably fine if there already are cygwin packages for what you want.

[11:32] <djanatyn> sure.

[11:32] <djanatyn> Do you ever have any difficulties with writing portable perl6 code?

[11:32] <djanatyn> or, is the current state of the implementations mature enough so that the code is portable no matter what?

[11:33] <geekosaur> .oO { all together now:  "Eunice!" }

[11:33] <jnthn> Given I do most of my Rakudo dev on Windows, it tends to get looked after quite well

[11:33] *** GlitchMr_42 left
[11:33] <jnthn> There's a couple of test fails here and there that I didn't track down yet, but by and large Rakudo works nicely on Windows.

[11:33] <jnthn> I suspect that Niecza also works nicely there too.

[11:34] <jnthn> Given it targets the CLR :)

[11:35] <moritz> once you get parrot to build on windows, the hard part is probably over

[11:36] <jnthn> yes

[11:38] *** Psyche^ joined
[11:41] <djanatyn> wow, that was surprisingly painless

[11:41] <djanatyn> rakudo is working fine on my computer :)

[11:41] <djanatyn> ...thanks, jnthn ;)

[11:42] *** Patterner left
[11:42] *** Psyche^ is now known as Patterner

[11:42] <jnthn> \o/

[11:42] <djanatyn> maybe I could start using perl6 more often, now that I've got it on all my computers

[11:42] <djanatyn> still having trouble thinking of good use cases, though

[11:42] <djanatyn> all I do with my life is play games and do schoolwork ^_^;

[11:45] <moritz> well, you can use it for math at the very least

[11:45] <djanatyn> :D

[11:45] <djanatyn> for anything I've needed to do on windows, I've used python

[11:46] <djanatyn> i'll think of more things to do with perl6 while at school

[11:46] <djanatyn> see ya

[11:46] <moritz> have fun

[11:49] <masak> I bet there's a wide intersection between things that can be coded in Perl 6, and schoolwork.

[11:58] *** coto joined
[11:58] <coto> hi perl6

[11:58] <coto> i found in rakudo / src / core / Hash.pm line 77

[11:58] <coto> self.{$key} = [ self.{$key}, $value];

[11:58] <coto> if i change it to 

[11:59] <coto> my $tmp = self.{$key} ; self.{$key} = [ $tmp, $value];

[11:59] <coto> it works . but dont't konw why.

[11:59] <coto> maybe you want to give it a try?

[12:02] <dalek> nqp: 91838e0 | mls++ | src/how/NQPClassHOW.pm:

[12:02] <dalek> nqp: use reverse() method instead of manually reversing the mro array

[12:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/91838e07cd

[12:02] *** finanalyst left
[12:03] <coto> it is  about hash stacking push

[12:06] *** mkramer left
[12:07] *** Vlavv_ left
[12:10] *** aloha left
[12:11] *** aloha joined
[12:12] *** coto left
[12:14] *** pothos_ joined
[12:15] *** ab5tract joined
[12:16] * moritz tries

[12:17] *** pmurias_ joined
[12:17] *** Juerd_ joined
[12:17] *** Tene_ joined
[12:17] *** Tene_ left
[12:17] *** Tene_ joined
[12:17] *** Vlavv_ joined
[12:21] <tadzik> why shouldn't that work?

[12:22] *** pmurias left
[12:22] *** baest left
[12:22] *** Trashlord left
[12:22] *** pothos left
[12:22] *** sivoais left
[12:22] *** sirmacik left
[12:22] *** smash left
[12:22] *** fhelmberger_ left
[12:22] *** Juerd left
[12:22] *** imarcusthis left
[12:22] *** Tene left
[12:22] *** yath left
[12:22] *** _ilbot left
[12:22] *** Juerd_ is now known as Juerd

[12:22] *** pothos_ is now known as pothos

[12:23] <masak> rakudo: my %h; %h<foo> = [ %h<foo>, 42 ]; say %h.perl

[12:23] <p6eval> rakudo 36d829: OUTPUT¬´("foo" => [Any, 42]).hash‚ê§¬ª

[12:23] <masak> rakudo: my %h = foo => [<value>]; %h<foo> = [ %h<foo>, 42 ]; say %h.perl

[12:23] *** Trashlord joined
[12:23] <p6eval> rakudo 36d829: OUTPUT¬´maximum recursion depth exceeded‚ê§  in method defined at src/gen/CORE.setting:507‚ê§  in method Parcel at src/gen/CORE.setting:4278‚ê§  in method iterator at src/gen/CORE.setting:4337‚ê§  in method reify at src/gen/CORE.setting:3953‚ê§  in method gimme at src/gen/CORE.setti‚Ä¶

[12:24] <masak> yeah, that's gotta be a bug.

[12:24] <masak> but I think it's been reported.

[12:24] <masak> coto: if I were you I'd write something like (%h //= []).push($value)

[12:26] *** baest joined
[12:26] *** sivoais joined
[12:26] *** sirmacik joined
[12:26] *** smash joined
[12:26] *** fhelmberger_ joined
[12:26] *** imarcusthis joined
[12:26] *** yath joined
[12:26] *** _ilbot joined
[12:29] <Woodi> [D

[12:36] *** envi_ left
[12:39] *** bluescreen10 joined
[12:40] <moritz> masak: Hash.push isn't supposed to create an array around single items

[12:46] *** bluescreen10 left
[12:48] <dalek> rakudo/nom: 53dd308 | moritz++ | src/core/Hash.pm:

[12:48] <dalek> rakudo/nom: fix Hash.push; fix proposed by coto++

[12:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53dd308687

[12:49] *** am0c left
[12:50] *** tokuhiro_ joined
[12:55] <dalek> roast: 684d27a | moritz++ | S32-hash/push.t:

[12:55] <dalek> roast: unfudge S32-hash/push.t for rakudo

[12:55] <dalek> roast: review: https://github.com/perl6/roast/commit/684d27a60b

[12:55] <tadzik> oh, it was broken before? I see the point now

[12:59] *** bluescreen10 joined
[13:02] *** simcop2387 left
[13:02] *** simcop2387 joined
[13:07] *** benabik left
[13:13] *** simcop2387 left
[13:17] <masak> moritz: um, I meant (%h<foo> //= []).push($value)

[13:18] *** simcop2387 joined
[13:19] <moritz> masak: yes, but same objection

[13:20] <masak> that is a .push to an Array

[13:20] <masak> not a Hash

[13:21] <moritz> masak: coto++ explained how to rewrite parts of Hash.push not to trigger a bug. I don't see how your line would have helped with that, since it doesn't match Hash.push()'s desired semantics

[13:22] *** envi_ joined
[13:24] <masak> oh, now I see what you mean.

[13:24] <masak> yeah, it's two different use cases.

[13:24] *** kaleem left
[13:32] *** GlitchMr joined
[13:33] <dalek> nqp: ae3236c | mls++ | / (4 files):

[13:33] <dalek> nqp: bump parrot revision to get directaccess support, use directaccess for most var lookups

[13:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ae3236c822

[13:35] *** cognominal___ joined
[13:39] *** cognominal_ left
[13:40] <djanatyn> I wonder, are there any perl-like languages on the JVM?

[13:40] <djanatyn> kinda off-topic, I guess

[13:47] <colomon> There's JRuby, if you consider that sufficiently perl-like.

[13:49] *** GlitchMr42 joined
[13:51] *** JimmyZ joined
[13:52] *** donri joined
[13:53] *** thou joined
[13:53] *** GlitchMr left
[13:54] *** pmurias_ is now known as pmurias

[13:55] <geekosaur> in a skeevy-uncle^Wcousin sense?

[13:56] <jnthn> mls: In what cases don't we label it :directaccess?

[13:57] <jnthn> mls: It feels like we should have been able to make that the default, and PAST::Compiler is smart enough to know when it's an issue.

[13:58] *** pernatiy joined
[14:01] <mls> two reasons: 1) I didn't want to break existing code that uses its own lexpad/info implementation

[14:02] <mls> 2) rakudo's lexinfo implementation does that vivify magic on $_, $/, $!

[14:02] <mls> %_

[14:02] <mls> ( 1) means other languages )

[14:02] <jnthn> mls: aha

[14:03] <jnthn> yeah, those ones are special...

[14:03] <jnthn> and yeah, PAST::Compiler can't know.

[14:04] <dalek> nqp: ca12593 | mls++ | src/PAST/SixModelPASTExtensions.pir:

[14:04] <dalek> nqp: fix label name so that rakudo builds again

[14:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca12593779

[14:04] <jnthn> mls: Does it have any measurable performance impact?

[14:04] * moritz tries

[14:04] <jnthn> er, where by impact I mean, positive impact ;)

[14:05] <mls> It should speed things up a bit. Problem is, I don't have good benchmarks for nqp

[14:05] <moritz> building rakudo's setting?

[14:05] <tadzik> yeah

[14:06] <mls> could be that most of the time is spent in regex execution

[14:07] *** benabik joined
[14:09] *** ab5tract left
[14:14] <jnthn> Last time I profiled at least 20% was spent in actions, and about 5% in the optimizer. So both of those should benefit.

[14:15] <moritz> should rakudo profit from it too?

[14:15] <tadzik> well, the compiler is faster, so I suppose yes

[14:18] <moritz> the mandelbrot benchmark doesn't show much of a difference

[14:18] <jnthn> moritz: I suspect only when we patch Rakudo itself to use :directaccess

[14:18] <jnthn> Well, other than compile time

[14:18] <jnthn> But mandelbrot is dominated by its runtime.

[14:21] <mls> the nqp compiler is not much faster, just about 1.5%

[14:23] <mls> (I timed the compilations of Action.pm)

[14:23] <[Coke]> 1.5% is nothing to sneeze at.

[14:24] <[Coke]> ... I wonder if that is a US only idiom.

[14:24] <mls> dunno, am german ;)

[14:24] <mls> Anyway, I committed it so that I compare apples with apples when testing my stacked lexpad patch

[14:25] <mls> (and I also thought that it's a nice thing to have ;) )

[14:26] <moritz> mls++

[14:27] <mls> I wish there was an easy way to get rid of those lexpad allocations

[14:27] <mls> they don't do anything useful for nqp/rakudo, they just store the pointer to the context

[14:28] <mls> the lexical lookup could also take a context as extra parameter, but then it's no longer a vtable op and thus it gets much slower

[14:28] <mls> and I don't want to add extra vtable entries for lexical lookup

[14:29] <jnthn> Such is the problem with making the protocol to everything in the VM be through a often ill-fitting set of v-tables.

[14:30] <jnthn> The Rakudo lexpad does hold onto the odd other thing

[14:30] <jnthn> But really it'd just as easily be associated with the context instead.

[14:31] <mls> yes, I looked at it. It also holds that default_named_slurpy thing set in the binder

[14:31] <jnthn> Right.

[14:31] <jnthn> But another GCable just to point to a couple of things is kinda costly.

[14:32] <mls> Yes. For rakudo, the context *is* the pad. ctx + lexinfo is enough to get/set vars

[14:32] <mls> that may be different for other languages, where the lexpad is more dynamic

[14:35] <djanatyn> :\ ah, I just realized I was trying to write java code in perl6

[14:36] <jnthn> mls: yes

[14:36] <djanatyn> I was about to write an accessor method for my perl6 class -_-

[14:36] <jnthn> mls: But the current design penalizes languages that aren't so dynamic.

[14:38] *** lrnperl joined
[14:46] *** simcop2387 left
[14:46] <moritz> does t/spec/S14-roles/composition.t have passing TODOs for anybody else on rakudo?

[14:46] *** simcop2387 joined
[14:47] *** GlitchMr42 left
[14:51] *** kranius left
[14:51] <jnthn> moritz: I saw them, yes

[14:51] <moritz> great

[14:52] <dalek> roast: 54eccb9 | moritz++ | S14-roles/composition.t:

[14:52] <dalek> roast: untodo passing tests in composition.t

[14:52] <dalek> roast: review: https://github.com/perl6/roast/commit/54eccb92d7

[14:52] *** Alejandro23 joined
[14:53] *** Alejandro23 left
[14:57] *** ab5tract joined
[15:03] <moritz> nom: say (1 < * < 3).(2)

[15:03] <p6eval> nom 53dd30: OUTPUT¬´Bool::True‚ê§¬ª

[15:03] <moritz> nom: say (1 < * < 3).(1)

[15:03] <p6eval> nom 53dd30: OUTPUT¬´Bool::True‚ê§¬ª

[15:03] <moritz> I guess it tries to evaluate  (1 < 1) < 3

[15:03] <moritz> nom: say (1 < * < 1).(1)

[15:03] <p6eval> nom 53dd30: OUTPUT¬´Bool::True‚ê§¬ª

[15:04] <moritz> nom: say (1 < * < 1).(2)

[15:04] <p6eval> nom 53dd30: OUTPUT¬´Bool::False‚ê§¬ª

[15:04] <sjohnson> happy halloween !

[15:04] <benabik> nom: say Bool::False < 2

[15:04] <p6eval> nom 53dd30: OUTPUT¬´Bool::True‚ê§¬ª

[15:04] *** PacoLinux joined
[15:05] *** [particle]1 joined
[15:06] *** [particle] left
[15:06] *** [particle]1 is now known as [particle]

[15:06] *** _jaldhar left
[15:06] *** kranius joined
[15:10] *** sirmacik left
[15:12] <jnthn> moritz: I guess it's something like that, yes

[15:12] <jnthn> moritz: Not sure how best to fix it.

[15:14] <moritz> jnthn: probably needs to be special-cased in the currier

[15:17] <jnthn> moritz: Well, I'm not sure if the currier knows enough at the point it's invoked

[15:17] <benabik> nom: say 1 < 1 < 1

[15:17] <p6eval> nom 53dd30: OUTPUT¬´Bool::False‚ê§¬ª

[15:19] <jnthn> I mean, if we have 1 < * < 10, then maybe it sees and transforms the 1 < *, and only after that sees the (already transformed thing) < 10

[15:21] <benabik> nom: say (1 < $^a < 1).(1)

[15:21] <p6eval> nom 53dd30: OUTPUT¬´===SORRY!===‚ê§Cannot use placeholder parameter $^a in the mainline at line 1, near " < 1).(1)"‚ê§¬ª

[15:21] <benabik> nom: say {1 < $^a < 1}.(1)

[15:21] <p6eval> nom 53dd30: OUTPUT¬´Bool::False‚ê§¬ª

[15:34] <moritz> niecza: say (1 < * < 3).(2)

[15:34] <p6eval> niecza v10-248-ga1c7d29: OUTPUT¬´Bool::True‚ê§¬ª

[15:34] <moritz> niecza: say (1 < * < 3).(1)

[15:34] <p6eval> niecza v10-248-ga1c7d29: OUTPUT¬´Bool::False‚ê§¬ª

[15:34] <moritz> niecza: say (1 < * < 3).(3)

[15:34] <p6eval> niecza v10-248-ga1c7d29: OUTPUT¬´Bool::False‚ê§¬ª

[15:34] <moritz> just do it like niecza does it :-)

[15:34] *** risou_awy is now known as risou

[15:37] <dalek> roast: f8ffa96 | moritz++ | S02-types/whatever.t:

[15:37] <dalek> roast: tests for RT #102466, Whatever-currying of chained ops

[15:37] <dalek> roast: review: https://github.com/perl6/roast/commit/f8ffa96e43

[15:40] <dalek> rakudo/nom: ee1a1c5 | moritz++ | tools/build/NQP_REVISION:

[15:40] <dalek> rakudo/nom: bump NQP revision, just because we can

[15:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ee1a1c5d2e

[15:42] *** benabik left
[15:44] *** donri left
[15:47] *** wolfman2000 left
[15:47] *** lrnperl left
[15:56] *** ggoebel left
[16:00] *** JimmyZ left
[16:01] *** ggoebel joined
[16:09] *** REPLeffect joined
[16:10] *** REPLeffect left
[16:11] *** REPLeffect joined
[16:11] *** REPLeffect left
[16:13] *** dual joined
[16:13] *** ggoebel left
[16:17] *** simcop2387 left
[16:18] *** ggoebel joined
[16:19] *** simcop2387 joined
[16:22] *** donri joined
[16:24] *** araujo left
[16:25] *** araujo joined
[16:32] *** GlitchMr joined
[16:37] *** IngisKahn joined
[16:42] *** ab5tract left
[16:52] *** icwiener joined
[16:55] <masak> jnthn: that sounds wrong (the 1 < * < 10 reasoning). even in the normal case of 1 < $a < 10, it can't build the thunk until it's seen all the comparisons.

[16:57] * masak installs the new Niecza

[16:57] <jnthn> masak: I never said it was specific to this case.

[16:58] *** kaleem joined
[17:01] <masak> oh.

[17:01] <masak> nom: sub foo { say "OH HAI"; 4 }; say 1 < foo() < 10

[17:01] <p6eval> nom ee1a1c: OUTPUT¬´OH HAI‚ê§Bool::True‚ê§¬ª

[17:01] <masak> jnthn: but it handles this case right...

[17:02] <dalek> nqp/reprapi2: a743c97 | jnthn++ | src/ (9 files):

[17:02] <dalek> nqp/reprapi2: Toss clone from the REPR API; it's just implementable in terms of the more primitive allocate and copy_to.

[17:02] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/a743c97fab

[17:02] <jnthn> masak: Yes

[17:02] <jnthn> masak: We already know it's about currying, no?

[17:04] <masak> it's about priming, yes.

[17:05] <masak> my point was that in the above case it seems to already be handling the $a correctly. on the face of it, there's no reason it couldn't handle the * the same way.

[17:06] <masak> I haven't looked at the code for chained comparisons, so I don't know how realistic it is that the same codepath handle the $a case and the * case, but they feel kinda similar.

[17:07] <masak> in both cases there's something that should be evaluated only once but compared twice.

[17:07] *** daniel-s left
[17:08] <jnthn> Well, chained ones are handled by a pasttype chain

[17:08] <masak> according to Wikipedia, "Sch√∂nfinkelisation" has been proposed as an alternative name for currying.

[17:08] <jnthn> ...

[17:08] <masak> ok...

[17:08] <TimToady> riigghhhhttttt.......

[17:09] <masak> :D

[17:09] * TimToady is sad because curry is tasty

[17:09] *** daniel-s joined
[17:09] * masak hugs TimToady 

[17:10] *** MayDaniel joined
[17:10] *** MayDaniel left
[17:10] *** MayDaniel joined
[17:10] <TimToady> may we should call it ph·ªüing, if we can figure out how it's like noodles

[17:11] <ingy> sorear: if there was a CLR yaml implementation, would it be easy to expose to niecza?

[17:11] * masak thinks of the awesome hanzi for a kind of noodles

[17:11] <dalek> nqp/reprapi2: e4e4bb4 | jnthn++ | src/6model/ (8 files):

[17:11] <dalek> nqp/reprapi2: Add gc_cleanup to REPR API; none of the current reprs need it, but bigint will. Not yet called.

[17:11] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/e4e4bb465f

[17:12] <masak> http://en.wikipedia.org/wiki/Biang_Biang#The_Chinese_character_for_bi.C3.A1ng

[17:12] <ingy> hi TimToady, made it safely to TimToady.next

[17:12] * masak .oO( dynastic programming )

[17:15] <masak> ingy: was there a workshop or conference of some sort recently? how was it?

[17:15] <masak> or is it about to happen?

[17:15] <jnthn> Next 2 weekends are workshop filled \o/

[17:15] <jnthn> Well

[17:15] <jnthn> partially

[17:15] <jnthn> :)

[17:16] <masak> \o/

[17:16] <TimToady> wow, I know all the subparts of it, but that's one impressive collection of radicals

[17:17] <masak> sorear: my app works fine on niecza. bothersome error on compilation still remains, though. I'll try to track it down and golf it now.

[17:17] <masak> sorear: but overall, things work just as fine as they did pre-merge.

[17:17] <masak> TimToady: I thought you might like it :D

[17:18] <ingy> masak: I was hanging out in SF last week with rafl for GSoC Mentors thinger

[17:20] <TimToady> it's got ‚ªå Á©¥ ÂøÉ Âàñ Èæª ‚æ∫ and two Èï∑'s

[17:20] *** am0c joined
[17:21] <sorear> good * #perl6

[17:21] <masak> sorear! \o/

[17:22] <TimToady> offhand I don't see any larger units, though the outside of the inside may be a ÊÑà variant

[17:23] <masak> I doubt that.

[17:23] <TimToady> and I haven't labelled all the hole characters in Ext B yet, so there could be something better there

[17:24] <masak> the ÂàÇ on the right doesn't look like the right part of your variant. and the roof is too different.

[17:24] *** mj41 left
[17:24] <TimToady> ÊÑà is used in variants that has sword on the right

[17:24] <TimToady> the top is not hole though

[17:25] <sorear> ingy: probably not too hard.

[17:25] <masak> knife == sword ?

[17:27] <TimToady> yes, alternate gloss is all

[17:27] <masak> ok.

[17:28] <TimToady> I tend to use 'knife' for the †ö§ variant

[17:29] <masak> my computer can't display that one.

[17:30] <TimToady> but I've been known to rename radicals before, so I might change it

[17:30] <TimToady> it shows in my firefox

[17:32] *** aloha left
[17:32] <TimToady> some of my original radical names were more Japanese-oriented, and sometimes I undo that

[17:35] <dalek> nqp/reprapi2: 6dc6dc9 | jnthn++ | src/6model/reprs/P6opaque. (2 files):

[17:35] <dalek> nqp/reprapi2: Teach P6opaque to delegate to other reprs where it should. We now longer special case handling of various things in P6opaque that we probably never should have, have the hooks for getting P6bigint correctly flattenable into P6opaque, etc.

[17:35] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/6dc6dc92b1

[17:35] <jnthn> If anybody on non-Win32 wants to check reprapi2 builds for them, that'd be helpful.

[17:35] <jnthn> Next up: get Rakudo to build on it.

[17:36] <IngisKahn> curious, what are you working on, TimToady?

[17:42] <TimToady> being able to describe any CJK character by describing its subparts and their locations

[17:42] *** aloha joined
[17:43] <TimToady> so the character in question comes out something like walk.o hole.it Heart.ib moon.iml sword.imr tiedthreads.imct 2.Long.imcbC horse.imcbc

[17:44] <TimToady> but that could change is any of the subparts turn out to be other characters

[17:44] <sorear> is it public?

[17:45] <sorear> I suppose you've seen the ideographic description whatchamahicky in Unicode?

[17:45] <TimToady> not yet, or I couldn't change my radical names :)

[17:45] <IngisKahn> That sounds pretty cool

[17:45] <[Coke]> jnthn: testing on OS X.

[17:46] *** kboga joined
[17:47] *** risou is now known as risou_awy

[17:49] *** sjohnson left
[17:53] <jnthn> [Coke]: Danke.

[17:53] <dalek> rakudo/reprapi2: 5711fcf | jnthn++ | src/binder/sixmodelobject.h:

[17:53] <dalek> rakudo/reprapi2: Update sixmodelobject.h. Unsurprisingly, build epicly busted.

[17:53] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/5711fcf213

[17:53] <dalek> rakudo/reprapi2: 63a6131 | jnthn++ | src/pmc/perl6lexpad.pmc:

[17:53] <dalek> rakudo/reprapi2: Update Perl6Lexpad for new REPR API.

[17:53] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/63a613104a

[17:54] *** MayDaniel left
[17:55] <kboga> jnthn: fwiw, the reprapi2 branch builds on Ubuntu 11.10 (x64)

[17:56] <jnthn> kboga: Thanks!

[18:00] *** poincare101 left
[18:01] <[Coke]> jnthn: passes on OSX 10.6.8 intel

[18:03] <moritz> the rakudo branch doesn't build yet

[18:03] <moritz> perl6_ops.c:4277: error: ‚ÄòREPROps‚Äô has no member named ‚Äòinstance_of‚Äô

[18:03] <jnthn> moritz: right

[18:07] <dalek> rakudo/reprapi2: 71cf8b8 | jnthn++ | src/ops/perl6.ops:

[18:07] <dalek> rakudo/reprapi2: Update ops for REPR API changes.

[18:07] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/71cf8b8ecb

[18:07] <dalek> rakudo/reprapi2: 69b450a | jnthn++ | src/binder/bind.c:

[18:07] <dalek> rakudo/reprapi2: Update the binder for the new REPR API.

[18:07] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/69b450a6a0

[18:08] *** mj41 joined
[18:09] *** daxim left
[18:12] *** Holy_Cow joined
[18:13] *** SHODAN left
[18:16] *** Holy_Cow left
[18:19] <dalek> rakudo/reprapi2: cf864ab | jnthn++ | src/binder/multidispatch.c:

[18:19] <dalek> rakudo/reprapi2: Update multi-dispatcher for new REPR API.

[18:19] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/cf864abc2a

[18:19] <dalek> rakudo/reprapi2: 55293a2 | jnthn++ | src/binder/ (2 files):

[18:19] <dalek> rakudo/reprapi2: Get remaining C parts updated, or at least to a first approximation. We now get to trying to build the setting...BOOM SEGFAULT!

[18:19] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/55293a2a75

[18:21] *** MayDaniel joined
[18:25] <sorear> dalek?

[18:25] * sorear out

[18:32] *** benabik joined
[18:33] *** mj41 left
[18:42] <kboga> no segfault here when building the setting on the rakudo/reprapi2 branch

[18:42] <kboga> spectests pass too

[18:44] <jnthn> kboga: Oh?

[18:44] <jnthn> kboga: reprapi2 branch in Rakudo and reprapi2 nqp branch?

[18:44] <jnthn> kboga: What platform?

[18:44] <jnthn> And 32-bit or 64-bit?

[18:44] <kboga> oh my bad... forgot to pull in the reprapi2 changes =(

[18:44] <kboga> rebuilding

[18:44] <jnthn> oh

[18:47] <kboga> ok, segfault confirmed.

[18:49] <jnthn> thanks

[18:49] <jnthn> ok, dinner time

[18:49] *** poincare101 joined
[18:53] *** _jaldhar joined
[18:54] *** poincare101 left
[18:55] *** drbean left
[18:56] *** poincare101 joined
[18:58] * moritz got a backtrace

[18:59] <moritz> https://gist.github.com/1328486

[18:59] *** ggoebel left
[18:59] <moritz> and valgrind aborts with an internal error when I run the setting compilation step on it :/

[18:59] * cognominal___ pulls rakudo/reprapi2 to build on Lion

[18:59] *** cognominal___ is now known as cognominal

[18:59] <moritz> cognominal___: probably not very interesting there either

[19:00] *** drbean joined
[19:02] * moritz notices the suspicious lack of write barriers in bind_attribute_boxed

[19:03] <cognominal> https://gist.github.com/1328504

[19:03] <cognominal> some warnings when building bind.c

[19:04] *** ggoebel joined
[19:05] <moritz> well, probably set_pmc_at_offset would need a write barrier

[19:06] <moritz> maybe also copy_to

[19:06] * moritz doesn't really understand stuff, just guesses around wildly

[19:08] <cognominal> do I need to pull the special nqp/reprapi2 branch? or  perl Configure.pl does it for me

[19:09] *** kaleem left
[19:10] <mls> aargh! the build() method in BOOTSTRAPATTR returns nothing back to the caller

[19:10] *** molaf joined
[19:11] <mls> parrot's default is *not* to check the return argument count, so the behaviour is undefined

[19:12] <mls> this results in spurious buildplan entries (cause create_BUILDPLAN checks if the return value of build() is defined) 

[19:16] <moritz> hm, I thought that empty Perl 6 subs return Nil

[19:16] <mls> nqp

[19:16] <moritz> or is that compiled with NQP?

[19:16] <moritz> ok

[19:20] *** pernatiy left
[19:21] *** mj41 joined
[19:27] <mls> for now I'm using the following patch: https://gist.github.com/1328585

[19:28] <mls> jnthn: please check if the patch is good (is the build method needed at all?)

[19:28] <moritz> is there any general rule what empty NQP blocks should return?

[19:30] *** IngisKahn left
[19:30] <mls> currently nqp uses parrot semantics, i.e. when the last statement's value is an native int, an int will be returned and so on

[19:30] <mls> if it is void (because the last statement was a pirop or there were no statements), nothing is returned

[19:31] <mls> Actually I like that nqp is so close to parrot

[19:33] <mls> (looking at the code the above is actually not true: void is only returned for empty blocks)

[19:34] <mls> so maybe it's an PCT bug

[19:36] *** shinobicl_ joined
[19:37] <mls> anyway, afk -> home

[19:37] *** skangas joined
[19:38] <TimToady> masak: yes, the default is that a quasi is its own block, and we probably need something like "my COMPILING::<$x> = 42;" to poke things outward

[19:40] <cognominal> with Jonathan metamodel, serizalization and masak macro support, I feel that Christmas will be in November this year

[19:45] <moritz> perl6: say X::NYI

[19:45] <p6eval> niecza v10-251-g806e0fb: OUTPUT¬´‚ê§Unhandled Exception: Unable to resolve method postcircumfix:<( )> in class Any‚ê§  at /tmp/cNtqqNjTRU line 1 (mainline @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2223 (ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2224 (module-CORE @ ‚Ä¶

[19:45] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&X::NYI"‚ê§    at /tmp/Hhuwm6yORT line 1, column 5 - line 2, column 1‚ê§¬ª

[19:45] <p6eval> ..rakudo ee1a1c: OUTPUT¬´NYI()‚ê§¬ª

[19:49] *** molaf left
[19:52] *** envi_ left
[19:54] <moritz> nom: role A { }; say A.new

[19:54] <p6eval> nom ee1a1c: OUTPUT¬´A.new()‚ê§¬ª

[20:18] *** bluescreen10 left
[20:19] *** drbean left
[20:23] *** _jaldhar left
[20:23] * TimToady is not against scrapping @*INC entirely; there's a reason S11 doesn't mention it

[20:24] <TimToady> sorear: ^^

[20:26] *** drbean joined
[20:28] <TimToady> sorear: all assignment to declarators is syntactically special; we just fudge my's pseudo-assignment a bit more in the direction of real assignment than, say, has

[20:29] <TimToady> this is why jnthn++ and I have been discussing moving the parsing of assignment back to being part of the declarator parse

[20:29] <TimToady> it's kinda too bad that everyone is used to using = for that, but I don't see a good alternative

[20:31] *** poincare101 left
[20:34] *** mkramer joined
[20:35] <cognominal> jnthn: segfaulting in Lion too, but with a different stack trace

[20:36] * jnthn is back

[20:39] *** diegoviola joined
[20:40] * masak is back

[20:40] <jnthn> copycat

[20:40] <jnthn> moritz: Write barriers are the responsibility of the stuff calling down to the REPR

[20:48] *** plobsing left
[20:50] <jnthn> mls: Patch is probably fine

[20:51] *** plobsing joined
[20:53] *** saaki joined
[20:53] <jnthn> moritz: Yeah, your segfault report matches mine, so probably not GC related. That's good.

[20:59] *** ksi joined
[21:11] *** IngisKahn joined
[21:16] *** GlitchMr left
[21:19] <jnthn> moritz: oh, I think I see the place you meant

[21:30] *** benabik left
[21:33] <jnthn> nqp: say(int.HOW.name(int));

[21:33] <p6eval> nqp: OUTPUT¬´Can only use get_how on a SixModelObject‚ê§current instr.: '_block1000' pc 27 ((file unknown):35) (/tmp/TUO0NNacpC:1)‚ê§¬ª

[21:35] <jnthn> nqp: class A { }; say(A)

[21:35] <p6eval> nqp: OUTPUT¬´A()‚ê§¬ª

[21:50] *** jferrero left
[21:55] *** drbean left
[22:01] *** whiteknight joined
[22:02] *** drbean joined
[22:03] *** mj41 left
[22:14] *** shinobicl_ left
[22:15] *** xinming left
[22:22] *** REPLeffect joined
[22:28] *** daniel-s left
[22:31] *** REPLeffect left
[22:31] *** REPLeffect joined
[22:34] <masak> sorear: I isolated it! \o/

[22:34] <masak> sorear: https://gist.github.com/1329249

[22:34] * masak submits nieczabug

[22:35] *** daniel-s joined
[22:39] <colomon> masak: heisenbug?

[22:39] <dalek> 6model: 8a1fc64 | diakopter++ | lua/ (6 files):

[22:39] <dalek> 6model: lots of Makefile changes; get rid of most 'dofile' calls

[22:39] <dalek> 6model: review: https://github.com/diakopter/6model/commit/8a1fc64d63

[22:43] <masak> colomon: no, it disappears after A.pm has been compiled once.

[22:43] <colomon> masak: ah. 

[22:43] <masak> (Niecza has a cache where it stores compiled modules)

[22:44] <masak> changing the real A.pm expired the cache, causing the bug to reappear. the bug is thus a bit annoying during development.

[22:44] <masak> sorear: pls fix ;)

[22:45] <masak> (but it's not a problem with the serialization branch. it was there long before)

[22:45] <dalek> nqp/reprapi2: a375e18 | jnthn++ | src/ops/nqp.ops:

[22:45] <dalek> nqp/reprapi2: Don't look up something we already have.

[22:45] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/a375e18532

[22:45] <dalek> nqp/reprapi2: c0c5bb0 | jnthn++ | src/NQP/SymbolTable.pm:

[22:45] <dalek> nqp/reprapi2: Fix a nasty NQP bug where the REPL and code run immediately rather than pre-compiled didn't properly see the setting.

[22:45] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/c0c5bb0703

[22:45] <dalek> nqp/reprapi2: 516c219 | jnthn++ | src/6model/reprs/P6opaque.c:

[22:45] <dalek> nqp/reprapi2: Add a missing sanity check to P6opaque that catches some nasty bugs.

[22:45] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/516c219f3a

[22:45] <masak> 'night, #perl6

[22:47] <colomon> \o

[22:48] *** kaare_ left
[22:50] <sorear> TimToady: how is assignment to "my $x" in any way different from real assignment?

[22:59] <dalek> rakudo/reprapi2: caf5040 | jnthn++ | src/Perl6/Metamodel/ContainerDescriptor.pm:

[22:59] <dalek> rakudo/reprapi2: Avoid the NQP default constructor for now, which doesn't handle native types properly. This gets us a bit further into the build.

[22:59] <dalek> rakudo/reprapi2: review: https://github.com/rakudo/rakudo/commit/caf50408f8

[23:02] *** MayDaniel left
[23:04] <jnthn> bah, I get a segfault at the command prompt and an infinite loop in realloc under the debugger...

[23:04] *** ab5tract joined
[23:07] <dalek> 6model: 36af411 | diakopter++ | .gitignore:

[23:07] <dalek> 6model: update .gitignore

[23:07] <dalek> 6model: review: https://github.com/diakopter/6model/commit/36af41142d

[23:07] *** dual left
[23:08] <dalek> 6model: 69b75fd | diakopter++ | lua/compiler/compile.pir:

[23:08] <dalek> 6model: add compile.pir

[23:08] <dalek> 6model: review: https://github.com/diakopter/6model/commit/69b75fdaca

[23:13] *** icwiener left
[23:14] *** pmurias left
[23:17] <dalek> nqp/reprapi2: fd65ca0 | jnthn++ | src/ops/nqp.ops:

[23:17] <dalek> nqp/reprapi2: Fix thinko in repr_clone op.

[23:17] <dalek> nqp/reprapi2: review: https://github.com/perl6/nqp/commit/fd65ca0b4f

[23:23] *** benabik joined
[23:23] *** ksi left
[23:36] *** cooper joined
[23:43] *** snearch joined
[23:55] <jnthn> OK, reprapi2 is close. It builds and mostly spectests - if I turn off the optimizer, which is tickling some remaining bug somewhere.

[23:55] *** daniel-s left
[23:55] <jnthn> ah, and the spectests that fail largely seem to do so because I'm dumping debug output into them...

[23:57] *** Tene_ is now known as Tene

[23:58] *** daniel-s joined
[23:59] * jnthn will hunt that tomorrow, then get it all merged.

[23:59] <jnthn> Then the bigint work can continue \o/

[23:59] <dalek> 6model: a435091 | diakopter++ | lua/compiler/ (7 files):

[23:59] <dalek> 6model: first part of DNST->LST CSharp->Lua rename

[23:59] <dalek> 6model: review: https://github.com/diakopter/6model/commit/a4350912c8

