[00:07] <dalek> niecza: 84360d1 | sorear++ | lib/ (3 files):

[00:07] <dalek> niecza: No more "ModuleWithTypeObject", everything gets a type now

[00:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/84360d1c96

[00:07] <dalek> rakudo/nom: 7c0bd49 | jnthn++ | src/ (2 files):

[00:07] <dalek> rakudo/nom: Some infrastructure for booleanization, and a very very cheating Bool, pending figuring out how to write EnumHOW.

[00:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7c0bd494b3

[00:07] <dalek> rakudo/nom: 4d39aa6 | jnthn++ | src/CORE.setting/operators.pm:

[00:07] <dalek> rakudo/nom: First few relational ops.

[00:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4d39aa61ab

[00:07] <dalek> rakudo/nom: 4ac71a8 | jnthn++ | src/Perl6/Actions.pm:

[00:07] <dalek> rakudo/nom: Get if/unless/while and maybe some others working again.

[00:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4ac71a8873

[00:07] *** noganex_ joined
[00:09] <sorear> jnthn: Is knowhow a mandatory part of Perl 6, or just reserved syntactic space for implementations that need it?

[00:10] <jnthn> sorear: I've been pondering that. It made it into std as a result of smop, I think.

[00:10] <jnthn> sorear: I'm not sure that it's a great name.

[00:11] *** noganex left
[00:11] <jnthn> And it's not really defined anywhere in the spec.

[00:17] <dalek> rakudo/nom: 63185a7 | jnthn++ | src/CORE.setting/operators.pm:

[00:17] <dalek> rakudo/nom: Few more relational ops.

[00:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63185a7300

[00:26] *** jfried left
[00:40] *** cooper|ipad left
[00:44] *** lumi left
[00:45] *** lumi joined
[00:51] <sorear> TimToady: What does enum <variable> <a b c> mean?  Why does STD accept a variable instead of a longname here?

[00:55] <TimToady> an enum is just a constant mapping, and we allow other constants to go into names with or without a sigil

[00:56] *** lue joined
[00:56] <sorear> ah

[00:56] <sorear> makes sense

[00:56] <sorear> after 'enum $foo < a b c >', can $foo('a') be accessed directly?

[00:57] <sorear> I presume not

[00:57] <TimToady> $foo<a> maybe

[00:59] <sorear> S12:1983 talks about how, after enum A < b c >, A responds to postcircumfix:<( )> while b and c don't

[00:59] <sorear> Is this a fossil from back when type objects had their own types? (Enum vs. A)

[01:02] <sorear> TimToady:

[01:04] <dalek> rakudo/nom: aa75145 | jnthn++ | src/binder/multidispatch.c:

[01:04] <dalek> rakudo/nom: Fix a multi-dispatch bug.

[01:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa75145027

[01:04] <dalek> rakudo/nom: dbbe49f | jnthn++ | src/Perl6/Metamodel/ClassHOW.pm:

[01:04] <dalek> rakudo/nom: Publish type check cache.

[01:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbbe49f248

[01:04] *** icwiener_ joined
[01:06] <TimToady> could be; enums have historically been overengineered in several directions, so we should aim for the simplest thing that gets people from point A to point B

[01:07] *** icwiener left
[01:08] <TimToady> main thing is that they still have to introduce the individual symbols when that's desired

[01:17] *** cdarroch left
[01:22] *** lumi left
[01:23] *** lumi joined
[01:26] *** jferrero left
[01:52] *** donri left
[01:53] *** whiteknight left
[02:11] <dalek> rakudo/nom: 63ff94c | jnthn++ | src/binder/container.c:

[02:11] <dalek> rakudo/nom: Couple of write barriers.

[02:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63ff94c0cb

[02:11] <dalek> rakudo/nom: 539761b | jnthn++ | src/binder/bind.c:

[02:11] <dalek> rakudo/nom: A little binder cleanup and optimization.

[02:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/539761b74e

[02:11] <dalek> rakudo/nom: 02d3637 | jnthn++ | src/Perl6/Actions.pm:

[02:11] <dalek> rakudo/nom: Little optimization for compiling primitive multis.

[02:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02d3637de9

[02:11] <dalek> rakudo/nom: aaf51d0 | jnthn++ | NOMMAP.markdown:

[02:11] <dalek> rakudo/nom: Update nommap.

[02:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aaf51d0326

[02:12] *** woosley joined
[02:13] <jnthn> Let's try sleep again... &

[02:15] *** Chillance left
[02:21] *** lumi left
[02:21] *** lumi joined
[02:26] *** mtk left
[02:37] *** mtk joined
[02:48] *** nymacro joined
[03:05] *** hudnix left
[03:10] *** lumi left
[03:11] *** lumi joined
[03:23] *** Su-Shee_ joined
[03:26] *** Su-Shee left
[03:29] *** envi joined
[03:48] *** thou joined
[03:52] *** lumi left
[03:54] *** lumi joined
[03:55] *** lue left
[04:38] *** wamba joined
[04:44] * sorear wonders how much sense taint mode makes in Perl6

[05:02] *** lumi left
[05:25] *** mberends joined
[05:28] *** molaf joined
[06:00] *** am0c joined
[06:12] *** daniel-s joined
[06:18] *** daniel-s left
[06:24] *** [Sec] left
[06:25] *** daniel-s joined
[06:29] *** kaare__ joined
[06:35] <sorear> bah.  horrible unproductive day.  ->sleep

[06:38] <daniel-s> good night

[06:39] *** mberends left
[06:42] *** mberends joined
[06:58] *** kaare__ left
[07:00] *** wamba left
[07:12] *** tadam joined
[07:17] *** benabik left
[07:19] *** awoodland joined
[07:40] *** hanekomu joined
[07:42] *** Tedd1 joined
[07:43] *** envi left
[07:48] *** jjore left
[07:49] *** mj41 joined
[07:51] *** jjore joined
[07:53] *** tadam left
[07:56] *** cooper|ipad joined
[07:57] *** thou left
[08:06] *** envi joined
[08:08] *** Su-Shee_ is now known as Su-Shee

[08:09] *** mj41 left
[08:10] *** cooper|ipad left
[08:24] *** pernatiy_ joined
[08:25] *** pernatiy left
[08:27] *** masak joined
[08:28] <masak> morning, #perl6.

[08:28] <tadzik> morning masak

[08:28] <masak> g'ah! I forgot to edublog yesterday! :/

[08:28] <mberends> morning, masak

[08:28] * masak makes up for it now

[08:28] *** araujo left
[08:30] *** lateau joined
[08:34] *** lateau left
[08:34] <mberends> masak: I'm looking forward to your edublog teaching Perl 6 to my wife and son :)

[08:35] <masak> mberends: cool.

[08:35] <masak> mberends: I really wish the "environment" for toying around with BASIC code and the like that existed when I was a kid hadn't gone away.

[08:36] <mberends> aye

[08:37] <mberends> I'm also try to re-kindle that with Arduino. Also, this morning Click on BBC World featured http://www.raspberrypi.org/

[08:38] *** tadam joined
[08:43] * moritz would love a p6 repl with easy graphic output

[08:43] *** tadam left
[08:45] <tadzik> did I hear kindle? :)

[08:45] <mberends> hi tadzik, no you didn't :)

[08:45] <tadzik> :>

[08:46] <tadzik> I find the device quite tempting

[08:46] *** zby_home_ left
[08:46] *** envi_|2 joined
[08:46] <mberends> people do hack 'em, but only in minor ways apparently

[08:46] *** Mowah joined
[08:50] *** envi left
[08:55] <masak> I recently showed my twin cousins how to write simple stuff in QBasic. even getting QBasic to run is *far* too tricky nowadays.

[08:55] <tadzik> I think amazon is close to releasing an SDK for it

[08:56] <masak> (I have a 64-bit Windows installation, so I needed DOSBox to get it to run. DOSBox uses the concept of "mounting directories onto disk drive letters" to get going.)

[08:57] <masak> blog post! http://strangelyconsistent.org/blog/june-3-if-statements

[08:57] <mberends> yay!

[08:59] <moritz> *else say that it's just right.

[09:00] <moritz> looks like a markup glitch

[09:00] <masak> aye; saw that after publishing. it's already in the pipeline. :)

[09:00] <masak> thanks.

[09:00] <masak> oh! I forgot to mention the braces. I should do that briefly, too.

[09:01] <Su-Shee> .oO(smalltalk... :)

[09:02] <masak> what about smalltalk?

[09:02] <Su-Shee> repl with gui and easy to learn/teach and so on.

[09:03] <masak> ah, yes.

[09:03] <masak> Squeak seems nice in many ways.

[09:03] <masak> as does the Lively kernel.

[09:03] <Su-Shee> masak: grown-ups use "Pharo" mostly. (and I don't mean it in a sarcastic way)

[09:04] <masak> oh, ok. haven't heard about Pharo.

[09:04] <masak> I do have a CD here with software from Cincom that I got at a set of Smalltalk lectures once.

[09:05] <Su-Shee> I have to say I'm absolutely amazed by Smalltalks.. the smoothsness, the level of integration, image-based, the very well written docs, the educational aspect.. 

[09:07] <Su-Shee> it really merges OO, gui, programming into one smooth flow of use. amazing stuff.

[09:09] <masak> I've always been impressed by that class navigator thing.

[09:10] <Su-Shee> masak: imagine writing code, the gui and the documentation being on the same level of usability.

[09:10] <Su-Shee> it's really basically "hack as you go, oh wait, I want a button here just now..."

[09:10] <masak> :)

[09:11] <Su-Shee> no, I really mean it. This is a whole new level of hacking away and being productive..

[09:11] <masak> shame there's that monad-like echo chamber effect going on where a lot of nice things go into Smalltalk, but they never come out again. :/

[09:12] <Su-Shee> the community interested in smalltalk is too small, usally it's only people who went for the OO aspect of Ruby or come from the GUI world (like me) - and that's only a few people...

[09:12] <Su-Shee> most developers go for functional languages...

[09:13] <Su-Shee> a friend of mine really did take smalltalk and tought 8-10 year old girls with it.. it's amazing what children can hack if you give them the right environment...

[09:15] <masak> aye.

[09:16] <masak> and it must be great to *be* a kid with the right environmant, too.

[09:17] <Su-Shee> well set aside that my personal future doesn't lie in moving a green turtle on the screen (the hello world of smalltalk) it's amazing to have an environment which is optimized for all technical consequences moving a green turtle implies.. 

[09:18] <Su-Shee> like "move this object, change its attributes on the fly, connect events to it" and so on...

[09:20] <moritz> speaking of such environments, http://polycode.org/ is just high on reddit

[09:20] <Su-Shee> ah. *click* :)

[09:26] <masak> looks like a very nice project.

[09:29] <masak> shopping &

[09:35] *** nymacro left
[09:36] *** daniel-s left
[09:36] *** cglr joined
[09:38] *** MayDaniel joined
[09:40] *** awoodland left
[09:52] *** jfried joined
[09:56] *** cglr left
[10:05] *** MayDaniel left
[10:15] *** mtk left
[10:20] *** daniel-s joined
[10:20] *** woosley left
[10:20] *** daniel-s left
[10:20] *** daniel-s joined
[10:23] *** buubot_backup left
[10:23] *** hanekomu_ joined
[10:23] *** whiteknight joined
[10:25] *** mtk joined
[10:27] *** hanekomu left
[10:34] *** hanekomu_ left
[10:34] *** hanekomu joined
[10:43] <jnthn> o/, #perl6

[10:49] <tadzik> hello jnthn 

[10:50] <jnthn> hi tadzik :)

[10:50] * jnthn got decent sleep, when he finally managed to lose conciousness. :)

[10:50] <jnthn> Plan: coffee. bacon. hack.

[10:51] *** noam joined
[10:51] <tadzik> nice

[10:52] <tadzik> nom needs like 4 seconds to calculate the sum from 1 to 100000. I think it was like 40 for Rakudo, but I may be wrong

[10:54] <jnthn> tadzik: What code are you using for that, ooc?

[10:55] <tadzik> jnthn: some stupid "speedtest.nqp" thing from my ~/src/perl/perl6, will paste somewhere

[10:56] <tadzik> http://wklej.org/id/540720/

[10:56] <mberends> o/ jnthn.  Almost on topic, I am trying to get my biggishint lib in shape to be a zavolaj example

[10:57] <jnthn> tadzik: ah, using binding. OK :)

[10:57] <tadzik> binding is supposed to be slow?

[10:57] <jnthn> No, binding is quite fast now.

[10:58] <jnthn> However, LOADS of other stuff is still far from optimized.

[10:58] <jnthn> As in, I've got a long list of reasons why that code takes as long as it does to run.

[10:58] <tadzik> 8 seconds with assignment

[10:59] <tadzik> I've examined the pir, and it's full of nqp_something_something_serialization_something 

[11:00] <jnthn> Yes :)

[11:01] *** zermatts joined
[11:01] <jnthn> Well, generally you'll find one huge-ish deserialization sub

[11:01] <jnthn> But then the body will also do a load of that

[11:01] <tadzik> yeah

[11:01] <jnthn> It's the 10000

[11:01] <jnthn> We don't create it every time now

[11:01] <jnthn> We make it once then look it up

[11:01] *** JimmyZ joined
[11:02] <tadzik> 10000 times? :)

[11:02] <tadzik> I see the point. Also, the 1, no?

[11:02] <jnthn> tadzik: Yes, which isn't really ideal in a sense, but is still WAY faster than what master does (which is make 10000 instances of Int).

[11:02] <jnthn> Right, same for the 1.

[11:03] <tadzik> also, isn't ++ an LHF?

[11:03] <jnthn> Probably.

[11:03] <tadzik> s/an/a/ I think

[11:03] <jnthn> oh

[11:03] <jnthn> Not sure that "is rw" works properly yet but maybe enough

[11:06] <tadzik> after modifying operators.pm make says Nothing to be done for `all'.

[11:06] *** araujo joined
[11:06] <jnthn> huh.

[11:06] <jnthn> :/

[11:07] <jnthn> tadzik: Can you check the makefile?

[11:07] <tadzik> I can, but my Makefile-fu is weak

[11:09] *** cognominal joined
[11:20] <tadzik> I do like commits like this one

[11:20] <dalek> rakudo/nom: 79f3713 | jnthn++ | src/ (2 files):

[11:20] <dalek> rakudo/nom: Realized in the shower that for an onlystar block entering a multi-dispatcher, we don't need a new callframe, we can just use the perfectly good one that we already have. Did it. 30% speed win on operator calling heavy benchmark.

[11:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/79f3713002

[11:21] <moritz> \o/

[11:21] * tadzik imagines jnthn having a commit-terminal inside the shower cabin

[11:22] <tadzik> a perfect hack, you never know when it will come to your mind

[11:22] <moritz> that's what memory is for :-)

[11:27] <moritz> http://www.reddit.com/r/programming/comments/hrceu/what_httpperl6org_gets_right/

[11:27] *** hanekomu left
[11:37] *** buubot_backup joined
[11:41] * jnthn checks the nommap and gets hacking

[11:42] *** donri joined
[11:44] *** pmurias joined
[11:55] *** noam left
[11:56] *** kaare__ joined
[11:59] *** pmurias left
[12:02] *** Reaganomicon joined
[12:18] <dalek> rakudo/nom: 22b5c71 | jnthn++ | src/Perl6/Actions.pm:

[12:18] <dalek> rakudo/nom: Defer building of signature objects a little longer, so we get more time to twiddle the parameter descriptors. Will allow us to keep the actions a bit neater.

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/22b5c71c6f

[12:18] <dalek> rakudo/nom: d38d813 | jnthn++ | src/Perl6/ (2 files):

[12:18] <dalek> rakudo/nom: Clean up implicit invocant handling; gets us more STDish again.

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d38d81374b

[12:18] <dalek> rakudo/nom: 1f9cb7c | jnthn++ | src/Perl6/Actions.pm:

[12:18] <dalek> rakudo/nom: Set default parameter type (Mu or Any, depending on context).

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f9cb7c85f

[12:18] <dalek> rakudo/nom: e01c3de | jnthn++ | src/CORE.setting/operators.pm:

[12:18] <dalek> rakudo/nom: Remove now-unrequired type annotations.

[12:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e01c3de4cb

[12:25] *** tadam joined
[12:41] *** kaare__ left
[12:55] <moritz> fwiw rakudo/nom loops on t/00-parrot/01-literals.t

[12:57] <jnthn> moritz: Oddness.

[12:57] <jnthn> moritz: Though, I didn't even look at the tests yet.

[13:01] <moritz> t/00-parrot/04-op-cmp.t  passes

[13:02] *** am0c left
[13:03] <jnthn> oh, nice :)

[13:06] <jnthn> moritz: Any chance you can golf down what it is in literals.t that makes it loop?

[13:06] <jnthn> moritz: It's a weird failure mode.

[13:10] <dalek> rakudo/nom: f0f9487 | jnthn++ | src/Perl6/SymbolTable.pm:

[13:10] <dalek> rakudo/nom: Restore named parameters.

[13:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f0f9487cef

[13:10] <dalek> rakudo/nom: 6beb173 | jnthn++ | src/Perl6/Actions.pm:

[13:10] <dalek> rakudo/nom: Get positional and named (though not slurpy) placeholder parameters working again.

[13:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6beb173f61

[13:13] <tadzik> so Test.pm compiles?

[13:14] *** yinyin joined
[13:14] <jnthn> tadzik: doubt it

[13:14] <tadzik> I must start keeping 2 copies of Rakudo, so I can gsochack and have fun with nom at the same time

[13:15] <jnthn> tadzik: And if it does I doubt that it works...

[13:15] <tadzik> it doesn't parse, that's funny

[13:16] <tadzik> Semicolon form of module definition not allowed in subscope;

[13:16] <tadzik> please use block form at line 8,

[13:16] <jnthn> oh.

[13:16] *** tadam left
[13:16] <jnthn> tadzik: You may be able to hunt that down.

[13:16] <jnthn> tadzik: I copied the hanlding of that stuff from STD, I think. But maybe I screwed up...or didn't test it enough. :)

[13:16] <tadzik> hmm

[13:17] <tadzik> std; module Test; our $a = 'b';

[13:17] <tadzik> std: module Test; our $a = 'b';

[13:17] <p6eval> std 4b1b100: OUTPUT«ok 00:01 115m␤»

[13:17] <jnthn> nom: module Test; our $a = 'b';

[13:17] <jnthn> oh wait :)

[13:18] <jnthn> tadzik: Don't think I put "our" back yet, fwiw.

[13:18] <tadzik> hmm

[13:19] <tadzik> no, "my" doesn't help there

[13:20] <jnthn> tadzik: I suspect it's something in package_def

[13:20] <jnthn> $*begin_compunit handling or some such.

[13:22] <tadzik> our scoped variables not yet implemented at line 8, near "    = 0;\no"

[13:22] <tadzik> better :)

[13:23] <tadzik> and proto and dispatch auto-generation for multis not yet implemented at line 55

[13:23] <tadzik> so I guess the module issue is fixed

[13:23] <tadzik> or it's broken in a different way

[13:23] *** MayDaniel_ joined
[13:23] <tadzik> looks like it was an STD copy-pasto or copy-thinko

[13:25] <tadzik> and the warning still works when it should, commiting

[13:25] <tadzik> std: { module asd; }

[13:25] <p6eval> std 4b1b100: OUTPUT«===SORRY!===␤Semicolon form of module definition not allowed in subscope;␤  please use block form at /tmp/hwt_zMISGB line 1:␤------> { module asd⏏; }␤    expecting any of:␤   name␤   trait␤Parse failed␤FAILED 00:01 112m␤»

[13:25] <tadzik> that's it

[13:27] <jnthn> tadzik++

[13:27] <tadzik> jnthn++ for proper motivation :)

[13:28] <tadzik> also, running nom from outside the build directory is broken

[13:28] <jnthn> tadzik: master requires make install for that, no?

[13:28] <tadzik> jnthn: yes, but that doesn't help nom

[13:28] <jnthn> tadzik: Sure, the make install target hasn't been updated at all :)

[13:29] <tadzik> :P

[13:29] <tadzik> I'll try to peek on that

[13:29] <jnthn> tadzik: Feel free to work on it. perl6.exe, CORE.setting.pbc and everything in blib/Perl6/ needs installing.

[13:29] <tadzik> where should the pbcs land?

[13:29] <jnthn> Oh, and the dynops/dynpmcs, but that shoudln't change

[13:29] <jnthn> Hmm, good quesiton

[13:29] <jnthn> Where Parrot will find them ;-)

[13:30] <jnthn> I guess in its library directory

[13:30] <tadzik> as where perl6.pbc does?

[13:30] <jnthn> yeah, CORE.setting.pbc would go where perl6.pbc does, then make a Perl6 subdirectory within that location for the stuff inside blib/Perl6/

[13:30] <dalek> rakudo/nom: 5af4643 | tadzik++ | src/Perl6/Grammar.pm:

[13:30] <dalek> rakudo/nom: Fix semicolon form of module definition conforming to STD

[13:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5af4643bf0

[13:32] <tadzik> bleh, make rebuild everything on every Makefile update

[13:35] * jnthn trying to track down why switching trait_mod:<is> to multi-dispatch causes issues

[13:39] *** whiteknight left
[13:41] *** tadam joined
[13:41] <jnthn> oh duh, I think I did something silly

[13:41] <colomon> oh noez!

[13:42] <colomon> jnthn silly?

[13:42] <sorear> good * #perl6

[13:42] <colomon> \o

[13:42] <sorear> maybe I'll get something useful done today

[13:43] *** woosley joined
[13:44] *** tadam left
[13:47] <JimmyZ> \o

[13:47] <tadzik> o/

[13:47] <tadzik> I feel wrong about having PERL6_PBC and PERL6_PBCS in one Makefile

[13:48] *** jfried left
[13:49] *** colomon left
[13:52] <jnthn> tadzik: maybe the second one wants to be PERL6_BLIBS

[13:52] <tadzik> "load_bytecode" couldn't find file 'blib/Perl6/ModuleLoader.pbc' -- looking for pbcs in blib/ seems wrongish

[13:52] <tadzik> mebbe

[13:53] *** _twitch joined
[13:53] <sorear> tadzik: why?

[13:54] <tadzik> sorear: everything wants Perl6/Foo.pbc, only ModuleLoader wants to be in blib

[13:54] <tadzik> when we install it, it doesn't really want to be in /parrot/blabla/library/blib/Perl6/ contrary to everything else I suppose

[13:55] <sorear> jnthn: I'm having trouble figuring out how nom's SubsetHOW works.

[13:56] <jnthn> sorear: ?

[13:56] <jnthn> sorear: It's just an empty class ATM

[13:57] <sorear> Oh, it *doesn't* work?

[13:57] <jnthn> sorear: Right :)

[13:57] <jnthn> sorear: Just a "fill this in" stub :)

[13:57] <sorear> ha...okay

[13:57] <sorear> can you answer a few questions on what will go in there?

[13:58] <sorear> obviously the most important part of subset is type_check

[13:58] *** colomon joined
[13:58] <jnthn> sorear: IIRC I need to twiddle with the type check stuff a bit more generally.

[13:58] <sorear> er, other way around

[13:58] <sorear> yeah

[13:59] <tadzik> jnthn: any opinion on the hardcoded blib issue?

[13:59] <sorear> I'm left wondering about stuff like 'my SubsetType $s; $s.perl.say'

[13:59] <sorear> and 'SubsetType.^isa(BaseType)'

[13:59] <jnthn> sorear: I'll probably look at it within the next week.

[14:00] <sorear> ok.  I'll do enums instead today

[14:00] <sorear> o/ colomon

[14:01] <jnthn> tssk, my traits bug gets weirder and weirder...

[14:01] <jnthn> oh wait...duh.

[14:03] <tadzik> heh, now it works after make install and doesn't without installing :>

[14:05] <sorear> colomon: do you have the source for the mandelbrot code you tested on niecza?  I wanna check it for more LHF :)

[14:05] *** yinyin left
[14:09] <daniel-s> hi

[14:09] <daniel-s> is there a cleaner way of doing this?:

[14:09] <daniel-s> $file_out.say("{@company[$i]},{@link[$i]}");

[14:10] <daniel-s> it's in a for loop that goes from 0 to the lenth of the arrays (both same)

[14:11] <jnthn> Don't need the {...}

[14:11] <jnthn> @company[$i] will interpolate by itself

[14:12] <dalek> nqp: 5baa62c | jonathan++ | src/6model/sixmodelobject.c:

[14:12] <dalek> nqp: Fail in a more helpful way when important stuff is missing in meta-objects.

[14:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5baa62c226

[14:13] <daniel-s> yep, worked, thanks

[14:14] <daniel-s> so an array that is indexed will interpolate, but not one without an index

[14:14] <moritz> correct

[14:17] <sorear> daniel-s: are @company and @link always the same length?

[14:18] <daniel-s> yes

[14:18] <daniel-s> if they weren't I would have checked first, or checked as they were being filled, but it worked fine for what I needed

[14:19] <sorear> consider for @company Z @link -> $company, $link { $file_out.say("$company,$link") }

[14:19] <moritz> for @company Z @link -> $c, $l { say "$c, $l" }

[14:19] *** hudnix joined
[14:19] <daniel-s> what does the Z do?

[14:19] <moritz> rakudo: say <a b c> Z 1, 2, 3;

[14:19] <p6eval> rakudo 048573: OUTPUT«a1b2c3␤»

[14:20] <daniel-s> i see

[14:20] *** ymasory left
[14:24] <JimmyZ> rakudo: say <a b c> Z, 1, 2, 3;

[14:24] <p6eval> rakudo 048573: OUTPUT«a1b2c3␤»

[14:25] <sorear> I still think $ORS = '' is the wrong default.

[14:25] <sorear> er

[14:26] <sorear> $OFS

[14:27] <moritz> jnthn: it's the 0_0_1_4 in 01-literals.t that makes nom loop

[14:30] <moritz> http://news.perlfoundation.org/2011/06/2011q2-grant-proposal-port-pmt.html

[14:30] <moritz> is Marc Fisher here?

[14:32] <tadzik> I want to see the "Documentation for a module" part :>

[14:33] <tadzik> unless that'd be just extracting the pod, though that's non-trivial too

[14:34] * moritz thinks the proposal is rather half-baked

[14:34] <jnthn> std: 0_0_1_4

[14:34] <p6eval> std 4b1b100: OUTPUT«ok 00:01 111m␤»

[14:34] <jnthn> rakudo: say 0_0_1_4

[14:34] <p6eval> rakudo 048573: OUTPUT«14␤»

[14:35] <jnthn> moritz: Thanks, will investigate in a bit.

[14:38] <sorear> Fisher mentions perlesque in a blog post from 2010

[14:38] <sorear> maybe diakopter knows em

[14:39] *** Ali_h joined
[14:41] *** isBEKaml joined
[14:42] *** JimmyZ_ joined
[14:43] <dalek> rakudo/nom: 999dba4 | jnthn++ | src/binder/ (3 files):

[14:43] <dalek> rakudo/nom: Few small multi-dispatch fixes/tweaks.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/999dba4c9b

[14:43] <dalek> rakudo/nom: c14145b | jnthn++ | src/Perl6/Metamodel/NativeHOW.pm:

[14:43] <dalek> rakudo/nom: NativeHOW.type_check.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c14145b693

[14:43] <dalek> rakudo/nom: a49224b | jnthn++ | src/CORE.setting/traits.pm:

[14:43] <dalek> rakudo/nom: Oops, left in debugging code.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a49224b24c

[14:43] <dalek> rakudo/nom: 6942b63 | jnthn++ | src/CORE.setting/traits.pm:

[14:43] <dalek> rakudo/nom: Switch trait_mod:<is> to use multi-dispatch, so we'll be able to add more traits.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6942b63a40

[14:43] <dalek> rakudo/nom: dfeb5b9 | jnthn++ | NOMMAP.markdown:

[14:43] <dalek> rakudo/nom: Remove done items from nommap.

[14:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dfeb5b97c8

[14:45] *** JimmyZ left
[14:45] *** JimmyZ_ is now known as JimmyZ

[14:46] * moritz left a comment on the tpf blog, but it's held for moderator approval

[14:46] *** bluescreen10 joined
[14:47] <tadzik> jnthn: I added the install targets, but the remote executing still fails on blib/Perl6/ModuleLoader.pbc. If I remove blib/ from SymbolTable.pm (the only place where it exists), then the local executing gets broken

[14:47] <tadzik> http://wklej.org/id/540866/ -- the patch

[14:48] <sorear> I wonder if [email@hidden.address] redirects anywhere useful

[14:48] <tadzik> perl6: [email@hidden.address]
[14:48] <p6eval> pugs, rakudo 048573: OUTPUT«zysvfure@pcnn.bet␤»

[14:48] <p6eval> ..niecza v6-56-g84360d1: OUTPUT«Unhandled exception: Unable to resolve method trans in class Str␤  at /tmp/0mMxYHqSQH line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1565 (CORE C715_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1566 (CORE module-CORE @ 53) ␤ 

[14:48] <p6eval> ..at /home/p6eval…

[14:48] <sorear> why do I even bother

[14:49] <sorear> tadzik--

[14:50] <moritz> the IRC logs do their best to obsucre the email address

[14:51] <moritz> tadzik: you might need the blib/ in the install location too - at least for ModuleLoader.pbc

[14:51] <jnthn> I don't mind putting blib in the install location for now, fwiw.

[14:59] <tadzik> moritz: then it breaks in that other way I described

[15:01] <moritz> tadzik: I didn't see a description of that other way, sorry

[15:01] <tadzik> oh, right

[15:01] <tadzik> that crashes in a different way then

[15:02] <tadzik> or maybe I mixed it up

[15:02] <moritz> did you try to put everything under blib/, or just the module loader?

[15:02] <tadzik> just the module loader

[15:06] <tadzik> Null PMC access in find_method('load_setting') when I cp it there

[15:08] *** isBEKaml left
[15:11] *** benabik joined
[15:16] *** pjcj left
[15:17] <jnthn> std: sub foo(\$foo) { }

[15:17] <p6eval> std 4b1b100: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/rOAp5VQd1v line 1:␤------> sub foo(\⏏$foo) { }␤ok 00:01 114m␤»

[15:17] <jnthn> std: sub foo(\$foo) { $foo }

[15:17] <p6eval> std 4b1b100: OUTPUT«ok 00:01 115m␤»

[15:17] <jnthn> std: sub foo(\:$foo) { $foo }

[15:17] <p6eval> std 4b1b100: OUTPUT«===SORRY!===␤Malformed parameter at /tmp/g2hRzGj0le line 1:␤------> sub foo(⏏\:$foo) { $foo }␤    expecting any of:␤   name␤   new name to be defined␤ parameter␤      routine_def␤    signature␤Parse failed␤FAILED 00:01 113m␤»

[15:17] <jnthn> std: sub foo(:\$foo) { $foo }

[15:17] *** JimmyZ_ joined
[15:17] <p6eval> std 4b1b100: OUTPUT«===SORRY!===␤Malformed parameter at /tmp/IjDmC5DLDR line 1:␤------> sub foo(:⏏\$foo) { $foo }␤    expecting any of:␤   formal parameter␤       named_param␤Parse failed␤FAILED 00:01 113m␤»

[15:17] <jnthn> hmm...how to parcel a named :)

[15:20] *** JimmyZ left
[15:21] *** JimmyZ_ is now known as JimmyZ

[15:33] <JimmyZ> std: sub foo( \ :$foo) { $foo }

[15:33] <p6eval> std 4b1b100: OUTPUT«ok 00:01 115m␤»

[15:33] <JimmyZ> std: sub foo( : \$foo) { $foo }

[15:33] <p6eval> std 4b1b100: OUTPUT«ok 00:01 115m␤»

[15:44] *** daniel-s left
[15:46] *** ymasory joined
[15:46] *** birdwindupbird joined
[15:46] * JimmyZ sleeps

[15:46] *** JimmyZ left
[15:50] *** woosley left
[15:51] *** lue joined
[15:52] <lue> hello o/ Just came to give you a blag post: https://rdstar.wordpress.com/2011/06/04/lue-will-be-online-soon/

[15:55] <dalek> rakudo/nom: 9120d6c | jnthn++ | src/CORE.setting/Mu.pm:

[15:55] <dalek> rakudo/nom: Stub new/CREATE/bless.

[15:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9120d6c597

[15:55] <dalek> rakudo/nom: a790134 | jnthn++ | src/CORE.setting/Mu.pm:

[15:55] <dalek> rakudo/nom: Mu.Bool, Mu.defined.

[15:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a790134164

[15:55] <dalek> rakudo/nom: 8c632b6 | jnthn++ | src/Perl6/Metamodel/AttributeContainer.pm:

[15:55] <dalek> rakudo/nom: Interface for the actions to get at attributes that are allowed to be accessed in the current class body.

[15:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c632b69b1

[16:00] *** thou joined
[16:06] *** wamba joined
[16:07] *** ilogger2 joined
[16:07] *** ChanServ sets mode: +v ilogger2

[16:23] *** kaare__ joined
[16:30] <moritz> https://github.com/zhuomingliang/rakudo/commit/6c117301a9a9530503220588151dd1543743e08f

[16:31] *** cooper|ipad joined
[16:31] <moritz> I don't understand that - why is the ? necessary? I mean there aren't multiple occurrences of parrot_config in the path, and if yes, we'd want to substitute the last, right?

[16:32] <dalek> rakudo/nom: f9e5f02 | jnthn++ | / (3 files):

[16:32] <dalek> rakudo/nom: Start fleshing out Attribute a bit more.

[16:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9e5f027de

[16:32] <dalek> rakudo/nom: b748b55 | jnthn++ | src/Perl6/Actions.pm:

[16:32] <dalek> rakudo/nom: Fix up attribute access, including compile-time detection of missing/tyop'd attributes.

[16:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b748b55ed1

[16:32] <dalek> rakudo/nom: 6a20ac9 | jnthn++ | src/Perl6/Actions.pm:

[16:32] <dalek> rakudo/nom: Attribute binding.

[16:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a20ac9723

[16:42] <dalek> nqp: 401cd85 | jonathan++ | src/ops/nqp.ops:

[16:42] <dalek> nqp: Missing decontainerize. Unbreaks some type checks in rakudo/nom.

[16:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/401cd85bba

[16:43] <jnthn> moritz: Doens't immediately make much sense to me either.

[16:46] <jnthn> D'oh, that attribute binding patch didn't really work at all...

[17:02] *** thou joined
[17:04] *** thou left
[17:05] *** hanekomu joined
[17:06] <sorear> Does binding attributes make sense?

[17:07] <jnthn> sure

[17:07] <jnthn> Actually I got the binding bit right and screwed up the type check in the first attempt.

[17:07] <sorear> $!foo only, right?

[17:07] <jnthn> Yes

[17:07] <jnthn> $.foo := ... won't work.

[17:08] <jnthn> nom is *very* strict about what can appear on the LHS of a bind.

[17:08] <sorear> Does $.foo := ... make any sense whatsoever?

[17:08] <jnthn> Compile time error in nom.

[17:08] <dalek> rakudo/nom: 5634c40 | jnthn++ | src/Perl6/ (2 files):

[17:08] <dalek> rakudo/nom: Attribute binding that actually seems to work.

[17:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5634c405ee

[17:08] <sorear> I feel... vindicated.

[17:09] <sorear> some months ago I was trying to argue that the LHS of binds should be restricted to a small number of semantic forms

[17:09] <jnthn> If you're going to make binding cheap and have a chance at an efficeint container model, I think it has to be that way.

[17:10] * TimToady has always thought that binding should be very primitive

[17:11] *** tadam joined
[17:11] <TimToady> (which doesn't stop TimToady from wanting contradictory things, of course...)

[17:11] <jnthn> sorear: Note that $!foo works because (unlike is sometimes speculated) $!foo is *always* a directl reference to an attribute storage slot. Not a magically inlined private accessor method for that storage slot.

[17:12] <jnthn> (And yes, I know I S12 may be wrong there.)

[17:12] <sorear> no, S12 agrees with you

[17:12] <jnthn> ah, good :)

[17:12] <TimToady> the existence of a private accessor does not contradict

[17:13] <sorear> the magically inlined private accessor thing is something I made up

[17:13] <jnthn> TimToady: The existence of one doesn't; $!foo within the class body meaning "that accessor" does, though.

[17:13] <sorear> it simplified some things

[17:13] <TimToady> I think it's generated on demand, is more like what it should be

[17:14] <jnthn> I figure the use case is for trusted classes that want to get at the attributes?

[17:14] <TimToady> yes, and we trust ourselves too :)

[17:14] <jnthn> OK

[17:14] <jnthn> I'll have a shot at trusts at some point.

[17:14] <TimToady> but really, the syntax is just a funny way of calling a function

[17:14] <sorear> jnthn: that, and to get rid of the distinction between $!foo and $!foo()

[17:15] <sorear> in the niecza model they are exactly the same

[17:15] <jnthn> sorear: I don't think that's correct, fwiw.

[17:15] <TimToady> it's a false(ish) analogy to $.foo and $.foo()

[17:16] <TimToady> a consistency we don't really need

[17:16] <sorear> what, TimToady arguing against strange consistency? *faints*

[17:17] <jnthn> > class Foo is Mu { has $!x; method m { $!x := -> { say 42 }; $!x() } }; Foo.new.m

[17:17] <TimToady> it would be less compelling if we didn't have twigils

[17:17] <jnthn> 42

[17:17] <TimToady> or if we hadn't chosen closely related twigils

[17:18] <sorear> what happens on has $!foo; say @!foo ?

[17:19] <TimToady> it's more like the consistency of people who line up constructs vertically that aren't really related

[17:19] <jnthn> > class Foo { has $!x; method m { @!x } }

[17:19] <jnthn> Attribute @!x not declared in class Foo at line

[17:20] <TimToady> that looks like the right answer to me

[17:20] <jnthn> (that's nom...)

[17:20] <sorear> ooh, comple time error, nifty

[17:20] <jnthn> ooh, it did say line 1 too

[17:20] <jnthn> I pasto'd :)

[17:20] <jnthn> Yes, master doesn't complain until runtime.

[17:22] *** thou joined
[17:22] *** thou left
[17:23] <jnthn> Time for a break and some dinner.

[17:23] *** thou_ joined
[17:27] <colomon> sorear: https://github.com/colomon/mandelbrot/blob/master/bin/mandelbrot-color.pl

[17:36] *** pschon joined
[17:37] <sorear> thanks

[17:38] <sorear> 259 lines and it ran without modification? nice

[17:41] *** Moukeddar joined
[17:42] <TimToady> according to http://justrakudoit.wordpress.com/2011/05/31/just-dont-rakudo-it/ he made a couple of trivial mods

[17:42] *** pschon left
[17:45] <colomon> first made trivial mods to the script, then made trivial mods to Niecza so the script would run without them.  :)

[17:46] *** Trashlord joined
[17:46] <colomon> In particular, adding .re and .im and fixing Complex.abs.

[17:47] <colomon> to be fair, most of the lines are color data.  :)

[17:58] *** PhatEddy joined
[17:59] <PhatEddy> rakudo: class ting{has $.tang; submethod BUILD($wallah){ $.tang = $wallah +2 } }; my $x = ting.new(5); say $x.tang

[17:59] <p6eval> rakudo 048573: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'ting::BUILD' at line 22:/tmp/U004LXPrz4␤  in main program body at line 22:/tmp/U004LXPrz4␤»

[18:00] <PhatEddy> There is an rt that looks a bit similar here: http://rt.perl.org/rt3/Public/Bug/Display.html?id=73688

[18:00] <PhatEddy> Bug? new or attach to similar rt?

[18:02] <TimToady> the default new does not take positional parameters

[18:03] <pmichaud> good afternoon, #perl6

[18:03] <colomon> PhatEddy: what TimToady is trying to say, the code is wrong.  :)

[18:03] <TimToady> suppose you have a complicated object with various parents

[18:03] <TimToady> each BUILD has to know whether the parameter is for it or not

[18:03] <TimToady> they can't all claim the first parameter

[18:03] <TimToady> so you have to use named arguments

[18:04] <TimToady> s:g/parameter/argument/

[18:04] <PhatEddy> I understand the point about the code being wrong and am reading through the explanation ... Thx

[18:04] <mberends> hi pmichaud

[18:04] <TimToady> the error message is definitely LTA

[18:04] <dalek> nqp: 13eb661 | pmichaud++ | / (3 files):

[18:04] <dalek> nqp: Refactor --gen-parrot and Configure.pl a bit more, move git repo

[18:04] <dalek> nqp: management into NQP::Configure module.

[18:04] <dalek> nqp: 

[18:04] <dalek> nqp: The --gen-parrot argument to Configure.pl now accepts an optional

[18:04] <dalek> nqp: value to be used for 'git checkout'; thus "--gen-parrot=master"

[18:04] <dalek> nqp: will build Parrot from its 'master' branch instead of the one

[18:04] <dalek> nqp: given by tools/build/PARROT_REVISION.  Any valid argument to

[18:04] <dalek> nqp: "git checkout" can be given to "--gen-parrot".  Minimum revision

[18:04] <dalek> nqp: checks (according to --min-parrot-revision or tools/build/PARROT_REVISION)

[18:04] <dalek> nqp: are still performed.

[18:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/13eb661cc8

[18:04] <dalek> nqp: df3bf99 | pmichaud++ | src/ops/nqp.ops:

[18:04] <dalek> nqp: Merge branch 'master' of github.com:perl6/nqp

[18:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/df3bf9916e

[18:05] * TimToady wonders if we could install a default multi method new ($bogus, *@bogus) { die "This error message is not LTA." }

[18:06] *** george_z0rwell joined
[18:06] <pmichaud> since nom's new won't be written in PIR and will use Rakudo's normal binder, I'd expect the error message to improve

[18:07] <pmichaud> instead of Parrot's LTA "got 1 but expected 2"

[18:07] <jnthn> s/will/is/ :P

[18:07] <jnthn> (OK, it's only a stub...I don't have hash yet. :P)

[18:07] <pmichaud> nom:  say 1   # do we have 'nom' yet?

[18:07] <pmichaud> nom: say 1   # do we have 'nom' yet?

[18:07] <jnthn> pmichaud: Not yet.

[18:07] <pmichaud> ENONOM

[18:08] <pmichaud> I think that means it's time for me to get lunch.  :)

[18:08] <TimToady> rakudo: use MONKEY_TYPING; class Mu { multi method new ($bogus, *@bogus) { die "Your code is RWONG!" } }; say Cool.new(1,2,3)

[18:08] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Illegal redeclaration of symbol 'Mu'␤»

[18:08] <jnthn> TimToady: augment :)

[18:08] <TimToady> rakudo: use MONKEY_TYPING; augment class Mu { multi method new ($bogus, *@bogus) { die "Your code is RWONG!" } }; say Cool.new(1,2,3)

[18:08] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤A method named 'new' already exists in class 'Mu'. It may have been supplied by a role.␤»

[18:08] <jnthn> TimToady: And existing one isn't multi.

[18:08] <TimToady> who designed this stupid language?!?

[18:09] <pmichaud> ...it's been designed?

[18:09] <jnthn> I'm not sure the spec says that the default one should be multi or not. :)

[18:09] <jnthn> I suspect it may be worthwhile making it so.

[18:09] <pmichaud> multi new +1

[18:09] <TimToady> rakudo: use MONKEY_TYPING; augment class Any { multi method new ($bogus, *@bogus) { die "Your code is RWONG!" } }; say Cool.new(1,2,3)

[18:09] <p6eval> rakudo 048573: OUTPUT«Cool()<0x436d160>␤»

[18:10] <TimToady> heh

[18:10] <TimToady> someone's cheating somewhere...

[18:10] *** Moukeddar left
[18:10] <jnthn> heh, wtf.

[18:12] <TimToady> niecza: use MONKEY_TYPING; augment class Mu { multi method new ($bogus, *@bogus) { die "Your code is RWONG!" } }; say Cool.new(1,2,3)

[18:12] <p6eval> niecza v6-56-g84360d1: OUTPUT«Potential difficulties:␤  @bogus is declared but not used at /tmp/14YggAAKaR line 1:␤------> t class Mu { multi method new ($bogus, *⏏@bogus) { die "Your code is RWONG!" } };␤  $bogus is declared but not used at /tmp/14YggAAKaR line 1:␤------>

[18:12] <p6eval> ..G; augment cla…

[18:13] <TimToady> niecza: use MONKEY_TYPING; augment class Mu { multi method new ($bogus, *@bogus) { die "Your code is RWONG!"; $bogus; @bogus } }; say Cool.new(1,2,3)

[18:13] <p6eval> niecza v6-56-g84360d1: OUTPUT«Unhandled exception: No matching candidates to dispatch for new␤  at  line 0 (new @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1556 (CORE module-CORE @ 50) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1566 (CORE mainline @ 1) ␤  at  line 0 (boot-MAIN @ 1) ␤ 

[18:13] <p6eval> ..at  line 0 (…

[18:13] <pmichaud> TimToady: just to verify -- does   List.new(...)  in a Parcel flatten or not-flatten?  e.g.,   (1, 2, List.new(...), 3)

[18:13] <pmichaud> i.e., does .new always return a (non-flattening) item?

[18:13] *** cognominal_ joined
[18:13] <TimToady> funny, on my local niecza it tell me my code is RWONG

[18:14] <TimToady> is this niecza out of date?

[18:15] <pmichaud> (rakudo master treats .new as flattening, I think)

[18:15] <TimToady> pmichaud: I'd think it'd return a sub-Parcel that defers the flattening decision

[18:15] <TimToady> such that a lol would Seq-ize it

[18:16] <pmichaud> I meant if the parcel is subsequently flattened

[18:16] <pmichaud> my @a = (1, 2, List.new(...), 3)

[18:16] <TimToady> sure, if it's a subparcel, it flattens

[18:16] <pmichaud> okay

[18:16] <pmichaud> same with

[18:16] <TimToady> same as my @a = (1, 2, ('a', 'b', 'c'), 4, 5)

[18:16] <pmichaud> my @a = (1, 2, Range.new(:min(3), :max(5)), 6)

[18:16] <pmichaud> ?

[18:16] <pmichaud> that ends up with six elements, not four?

[18:17] <TimToady> yes, ranges are supposed to flatten in list context, but not in lol context

[18:17] <TimToady> s/list/flat/

[18:18] <pmichaud> okay

[18:18] <pmichaud> good to know -- will keep it that way then.

[18:18] <pmichaud> thanks

[18:20] <PhatEddy> I vaguely understand from the discussion that my code is wrong because of issues related to multiple inheritance but a better error message is desirable and expected soon from nom.

[18:20] <TimToady> yes, except it's also a problem with single inheritance

[18:21] <TimToady> you still have multiple BUILDs in that case

[18:21] <TimToady> and it does look practical to give a better message someday

[18:21] <pmichaud> (someday soon, even)

[18:22] <pmichaud> afk, fetching lunch

[18:23] <TimToady> rakudo: say grep 1..3, 0..5;

[18:23] <p6eval> rakudo 048573: OUTPUT«123␤»

[18:23] <TimToady> that's correct

[18:23] *** tadam left
[18:23] <TimToady> pmichaud: ^^

[18:24] <pmichaud> that doesn't seem related to my question, but okay :-)

[18:25] <TimToady> 1..3 and 0..5 both behave like parcels

[18:25] <TimToady> the 0..5 flattens, but the 1..3 doesn't

[18:25] <pmichaud> right, but that's an argument list

[18:25] <TimToady> because of the context binding to grep

[18:25] <TimToady> 0..5 is in list context

[18:26] <pmichaud> and infix:<..>  could have different flattening semantics than Range.new

[18:26] <pmichaud> (from what you just said it doesn't... but it could've gone the other way :)

[18:26] <TimToady> I don't see much reason to make them different

[18:26] <sorear> sub () is rw { 5 } # is this an error?

[18:26] <jnthn> imo yes

[18:26] <pmichaud> 'is rw' usually checks for rw-ness

[18:27] <sorear> does sub () is parcel make sense? :_

[18:27] <sorear> :)

[18:27] <TimToady> the normal result of any function/method is a Parcel-ish thing, so I tend to go with Parcel semantics when possible

[18:27] <pmichaud> wfm

[18:28] <TimToady> sorear: I dunno, but it makes my head hurt more...

[18:28] <pmichaud> on a similar note, then

[18:28] <pmichaud> if someone defines their own .new method:

[18:29] <pmichaud> class XYZ { method new($x) { my $obj = self.bless(...);   $obj } }

[18:29] <pmichaud> then XYZ.new would end up being non-flattening in a Parcel (because it was returned as a scalar)

[18:29] <pmichaud> what will be the best way to avoid that?

[18:29] <sorear> well sometimes there are code objects that want to only sometimes return a rw value

[18:30] *** Chillance joined
[18:30] <sorear> pmichaud: niecza has an unitem() primitive for cases like that

[18:30] <pmichaud> sorear: this looks like it might end up being a FAQ

[18:30] <TimToady> new($x --> Parcel) maybe

[18:30] <sorear> Range.new($x,$y) is defined approximately like unitem(self.bless(*, :$min, :$max))

[18:30] <TimToady> maybe not

[18:31] <jnthn> pmichaud: Explicitly return it in a Parcel

[18:31] <pmichaud> jnthn: that doesn't eliminate flattening

[18:31] <jnthn> TimToady: That's more a check than a coercion

[18:31] <pmichaud> the flattening is due to the '$'

[18:31] *** tomaw joined
[18:31] <TimToady> huh?

[18:31] <pmichaud> er, non-flattening is due to the '$'

[18:31] <jnthn> TimToady: --> is sugar for "returns" or "of"?

[18:31] <TimToady> return |$obj;   #  :P

[18:31] <pmichaud> sorry, I mis-phrased all of that

[18:32] <sorear> whether the value is returned in a Parcel or not has no effect on any of this

[18:32] <TimToady> right

[18:32] <pmichaud> it's the $ that causes the return value to be non-flattening

[18:32] <sorear> my $a1 = [1,2,3]; my @x = $a1,; # $a1 is wrapped in a Parcel, nothing happens

[18:32] <pmichaud> putting it in a parcel just means it's a parcel with a non-flattening item

[18:33] <jnthn> ah, yes

[18:33] <sorear> niecza: my $a1 = [1,2,3]; say $a1.perl; say (@$a1).perl; say unitem($a1).perl

[18:33] <p6eval> niecza v6-56-g84360d1: OUTPUT«[1, 2, 3]␤[1, 2, 3].list␤[1, 2, 3].list␤»

[18:33] <TimToady> nothing sets the "flatten me" flag, on some level or other

[18:33] <TimToady> the @ flag, as it were

[18:33] <pmichaud> I don't mind saying that method new()  should return   $obj.list   or @($obj) or somesuch

[18:34] <sorear> pmichaud: the trouble is that .list causes Range to become List

[18:34] <TimToady> @$obj

[18:34] <TimToady> why?

[18:34] <TimToady> shouldn't .flat do that?

[18:34] <sorear> which is why I have unitem

[18:34] <TimToady> .list is not .flat

[18:34] <pmichaud> Range is not a List

[18:35] <pmichaud> so .list is the normally way to make it into one

[18:35] <pmichaud> *normal

[18:35] <pmichaud> regardless of flattening/non-flattening

[18:36] * TimToady wonders whether he should wonder whether the Tylenol is poisoned... :)

[18:37] <pmichaud> sorear: I tend to think of the default new as doing  "return self".... which could already be a non-item.

[18:37] <pmichaud> so doing   .list wouldn't be necessary on Range

[18:39] * TimToady wonders whether Range does Parcel makes any sense...

[18:39] <sorear> pmichaud: that's because in your world, all objects default to non-item, but the flag is only respected for subclasses of Iterable

[18:39] *** Khisanth joined
[18:40] <sorear> in my world, the flag is respected for everything, so objects are items by default

[18:40] <TimToady> can you give some examples of where it makes a difference?

[18:40] <sorear> my @x = Range.bless(*, :min(1), :max(10))

[18:41] <sorear> in niecza, @x.perl = [1..10]

[18:41] <pmichaud> btw, in nom we're eliminating the flags altogether.

[18:41] <sorear> in rakudo, @x.perl = [1,2,3,4,5,6,7,8,9,10]

[18:41] <pmichaud> it's generally a compile-time thingy

[18:41] <sorear> pmichaud: that doesn't even make sense

[18:42] <pmichaud> istr that TimToady++ has said in the past that he felt that flattening ought to be compile-time based on the sigil

[18:42] <sorear> how will you tell the difference between sub foo() { [1,2,3] } ans sub foo() { my @ = 1, 2, 3 } ?

[18:42] <sorear> then [0,foo,4]

[18:43] <pmichaud> because [1,2,3] returns an Array that is wrapped in a Scalar

[18:43] <pmichaud> and Scalar's don't flatten.

[18:43] <pmichaud> the second just returns an Array

[18:43] <jnthn> I guess it's not so much "no flag" as "the flag is just a type"

[18:43] <pmichaud> "the flag is a Scalar container"

[18:43] <jnthn> Right.

[18:45] <pmichaud> so TimToady's earlier suggestion of   return |$obj   (or something like it) might be sufficient.

[18:45] <jnthn> (Actually, Scalar is a type that something knows is a scalar container, and the mechanism is there for other types to be too...so the whole container stuff will be useful to other HLLs)

[18:45] *** tomaw left
[18:46] <pmichaud> btw,   my @x = Range.bless(*, :min(1), :max(10))    should end up with @x being eagerly evaluated, iirc

[18:47] <pmichaud> because array assignment is "mostly eager"

[18:47] <sorear> do you draw a cutoff anywhere?

[18:48] <pmichaud> not as long as the list is known finite

[18:48] <TimToady> niecza: say grep 1..3, 0..5;

[18:48] <p6eval> niecza v6-56-g84360d1: OUTPUT«123␤»

[18:48] <sorear> what do you think of for 1e0..1e10 { .say } ?

[18:49] <TimToady> niecza: say grep 1..3, Range.bless(*, :min(1), :max(10));

[18:49] <p6eval> niecza v6-56-g84360d1: OUTPUT«Unhandled exception: Unable to resolve method bless in class Range␤  at /tmp/rYVdmW4Xoo line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1565 (CORE C715_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1566 (CORE module-CORE @ 53) ␤ 

[18:49] <p6eval> ..at /home/p6ev…

[18:49] *** cooper|ipad left
[18:49] <pmichaud> sorear: I'm pretty sure that's lazy.

[18:49] <sorear> bless(*, ...) is currently spelled CREATE(...)

[18:50] <pmichaud> (because 'for' is lazy)

[18:50] <TimToady> niecza: say grep 1..3, Range.CREATE(:min(1), :max(10));

[18:50] <p6eval> niecza v6-56-g84360d1: OUTPUT«␤»

[18:51] <TimToady> rakudo: for 1e0..1e10 { .say }

[18:51] <p6eval> rakudo 048573:

[18:51] <p6eval> ..OUTPUT«(timeout)␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤52␤53␤54␤55␤56␤57␤58␤59␤60␤61␤62␤63␤64␤65␤66␤67␤68␤69␤70␤71␤72␤73␤74␤75␤76␤77␤78␤79␤80␤81␤82␤83␤84␤85␤86␤87␤

[18:51] <TimToady> looks lazy to me

[18:51] <TimToady> rakudo: for eager 1e0..1e10 { .say }

[18:52] <p6eval> rakudo 048573: OUTPUT«(timeout)»

[18:52] <TimToady> looks eager to me :)

[18:53] <TimToady> rakudo: for "aaaaaa" .. "zzzzzz" { .say }

[18:53] <p6eval> rakudo 048573:

[18:53] <p6eval> ..OUTPUT«(timeout)aaab␤aaaaac␤aaaaad␤aaaaae␤aaaaaf␤aaaaag␤aaaaah␤aaaaai␤aaaaaj␤aaaaak␤aaaaal␤aaaaam␤aaaaan␤aaaaao␤aaaaap␤aaaaaq␤aaaaar␤aaaaas␤aaaaat␤aaaaau␤aaaaav␤aaaaaw␤aaaaax␤aaaaay␤aaaaaz␤aaaaba␤aaaabb␤aaaabc␤aaaabd␤aaaabe␤aaaabf␤aaaabg␤aaaabh␤aaaabi␤aaaabj␤aaaabk␤aaaabl␤aaaabm␤aaaabn␤aa…

[18:54] <TimToady> sure would be nice if that (timeout) didn't overwrite the beginning...

[18:54] <pmichaud> yeah, that seems kinda weird.  :-)

[18:54] <sorear> niecza's general policy is to process lists eagerly until it hits an iterator, then go lazy

[18:54] <sorear> I think this is what you call "mostly eager"

[18:54] <pmichaud> no

[18:54] <pmichaud> a simple iterator isn't sufficient.

[18:55] *** thou_ left
[18:55] <TimToady> we mark our iterators as finite/infinite

[18:55] <TimToady> s/we/rakudofolk/ :)

[18:55] <pmichaud> well, even in Perl 6.

[18:55] <pmichaud> the problem the infinite/finite is intended to avoid is action-at-a-distance due to laziness

[18:56] *** cooper|ipad joined
[18:56] <pmichaud> with   my @a = (1, 2, 3, @b, 4)

[18:56] <pmichaud> we can't stop evaluating as soon as we hit b's iterator, because the next line might be

[18:56] <pmichaud> @b[100] = 'oops'

[18:56] <TimToady> it forces eager to behave a bit more like what a P5 person would expect

[18:56] <pmichaud> and we want @a to have the value of @b *before* that assignment was made

[18:57] <pmichaud> s/@b/@b[100]/

[18:57] <sorear> rakudofolk have a lot of influence on perl 6

[18:57] <TimToady> fershure

[18:57] <pmichaud> only because we've asked a lot of hard questions already

[18:57] <pmichaud> it's not that we said "this is how the language should be" -- it's that we said "how is this supposed to work?" and these are the answers we got back.

[18:58] <sorear> so once I have not-completely-eager list assignment, it'll need to keep going until it sees a cursor marked as "infinite"

[18:59] <sorear> does "stop at any iterator" work for "mostly lazy" level?

[18:59] <sorear> s/iterator/cursor/

[18:59] <pmichaud> I think that mostly lazy is allowed to work ahead or not as it desires

[19:01] <TimToady> even if the rest of S07 is bogus, the definitions at the front are pretty accurate

[19:01] <sorear> Have you figured out ,* yet?

[19:01] <pmichaud> ,* is a compile-time marker that marks a parcel as being "infinite" or "whateverish"  

[19:01] <TimToady> the latest is that it's just a marker, and no Whatever appears on the end

[19:01] <pmichaud> (I haven't quite decided what the better term for it is)

[19:01] <TimToady> and maybe ,() is the opposite marker

[19:02] <TimToady> and we decided it was easy enough to do the 'repeat last element' some other way

[19:02] <pmichaud> .repfinal works for me, btw.

[19:02] <TimToady> @stuff.repfinal(3) for insta... yeah

[19:02] <sorear> what does marking a parcel infinite do?

[19:03] <pmichaud> causes its iterator to report "infinite"

[19:03] <masak> rehi, #perl6!

[19:03] <pmichaud> which means that eager evaluation of that parcel becomes lazy

[19:03] <TimToady> hire, #masak

[19:03] <pmichaud> (mostly eager evaluation, that is)

[19:03] <jnthn> hire masak!

[19:03] <jnthn> no, wait, don't... :)

[19:04] <masak> :)

[19:04] <pmichaud> this enables things like  &infix:<...>  to be able to signal "I'm returning an infinite sequence because my RHS is *"

[19:04] <pmichaud> internally, when &infix:<...> knows that its RHS is *, it can return a parcel of   (gather { ... } ,*)

[19:05] <pmichaud> which means that the result is conceptually infinite

[19:05] <TimToady> or however we mark it internally

[19:05] *** tomaw joined
[19:06] <pmichaud> ("however we mark it internally" ==   the ,* after the gather is resolved at &infix:<...>'s compile time :-)

[19:06] <TimToady> I'm pretty comfortable with the boundary between mostly lazy and mostly eager; the boundary with strictly eager is probably sink context; I'm less sure how the boundary with strictly lazy works

[19:06] <TimToady> since some recursive definitions need something approaching strict laziness

[19:07] <TimToady> there's handwaving verbiage in "Mostly Lazy" about that, but I'm not sure how we detect circular definition without deadlock...

[19:09] <TimToady> but several rosettacode examples could use better recursive definitions of lazy constant arrays

[19:09] <pmichaud> TimToady: would ,* resolve some of those, ooc?

[19:09] <TimToady> I don't want to go as far as Haskell in requiring strict laziness

[19:10] <TimToady> I don't think ,* does anything to help the strict lazy end

[19:10] <pmichaud> for example:    my @a = (1, 2, @b, 3, *)

[19:10] <pmichaud> would tend to make evaluation lazy

[19:10] <TimToady> it does let us issue an immediate "out of memory" error on ;1..*;

[19:10] <pmichaud> because the parcel is signalling "infinite"

[19:11] <TimToady> yes, that would lazify it, and then we could blow up the rocket if they run off the end :)

[19:12] <TimToady> except, of course, that it's allowed to work ahead, so you can't guarantee that @b isn't immediately evaluated

[19:13] <pmichaud> troo

[19:13] <TimToady> my @a = (1, 2, lazy @b, 3) has the same issue

[19:14] <TimToady> my @a = (1, 2, very-lazy @b, 3)

[19:14] <TimToady> and very-eager :)

[19:15] *** cooper|ipad left
[19:15] <TimToady> or make very a meta-op on the next thing :)

[19:15] <masak> uber-lazy

[19:15] <pmichaud> LAZY

[19:15] <pmichaud> EAGER

[19:15] <TimToady> my @a = (1, 2, (very lazy @b), 3)

[19:15] <sorear> I thought it was supposed to be a pragmatic module

[19:16] <TimToady> well, it's our spec, we can rewrite it :)

[19:16] <sorear> I suppose infinitized iterators have to distribute their infiniteness to any iterators they generate on reify?

[19:16] <TimToady> well, maybe the last one

[19:17] <pmichaud> yeah, I'm not sure that follows.

[19:17] <TimToady> I suppose it depends on what kind of sub-iterator you're generating...

[19:17] <pmichaud> ,*  simply means "act like an infinite list", it doesn't actually make the list infinite.  :-)

[19:17] <sorear> my @x = (gather { ... }, *); @x.shift; my @y = @x;

[19:18] <sorear> after the shift, the original ParcelIterator is gone

[19:18] <sorear> @x contains only a GatherIterator

[19:18] <pmichaud> @x isn't infinite.

[19:18] <pmichaud> nor does it need to be marked at asuch.

[19:18] <pmichaud> *as such

[19:19] * TimToady doesn't follow

[19:19] <pmichaud> I don't quite follow the example either

[19:19] <sorear> my @x = (gather { take 1 while 1 }, *); @x.shift; my @y = @x;

[19:19] <sorear> better?

[19:19] <pmichaud> likely run out of resources on  the my @y = @x;

[19:20] <pmichaud> as it tries to mostly eager evaluate @x

[19:20] <TimToady> unless it's marked infinite

[19:20] <TimToady> which is what sorear++ is asking

[19:20] <pmichaud> right

[19:20] <pmichaud> I'm not sure we should have that level of transitivity

[19:20] * TimToady wonders whether ,* should be a real sentinal

[19:21] <TimToady> *nel

[19:21] <pmichaud> somewhat like Nil?

[19:21] <pmichaud> maybe an infinite Nil?

[19:21] *** pjcj joined
[19:22] <sorear> INFINITE NOTHING

[19:22] <pmichaud> (i.e.,   () but with an infinite flag set)

[19:22] <TimToady> which is why I was proposing () for the Other

[19:23] <sorear> what would that do?

[19:23] <TimToady> mark it as finite, but it wouldn't work if ,* is also Really 

[19:23] <pmichaud> I think "force a Parcel to act finite, regardless of its contents"

[19:23] <TimToady> There

[19:24] <TimToady> @foo, *, ()  is a problem

[19:24] <TimToady> or however one writes it

[19:24] <pmichaud> oh, that looks like something else entirely to me

[19:24] <pmichaud> I was thinking that ,* was "infinite" only at the end

[19:24] <pmichaud> in the middle, it's just a Whatever.

[19:24] <TimToady> which smells

[19:24] <pmichaud> agreed

[19:25] <pmichaud> which is the smell I've detected with ,* somewhat from the beginning :-)

[19:25] <TimToady> was thinking if it's a real sentinel, then (1,@foo,3) could have @foo return ,* and it would still work

[19:26] <TimToady> for most purposes, we could replace ,* with ...*

[19:26] <pmichaud> oooh

[19:27] <pmichaud> well, not exactly

[19:27] <sorear> I don't get it.  What's the practical difference between @foo and @foo,() ?

[19:27] <pmichaud> (1,3,5,*)  is definitely different from  (1,3,5 ... *)

[19:27] <TimToady> troo

[19:28] <pmichaud> heh

[19:28] <TimToady> sorear: it'd only be different if @foo looked infinite

[19:28] <pmichaud> which leaves

[19:28] <pmichaud>    1,3,5, () ... *

[19:28] <pmichaud> or

[19:28] *** pjcj left
[19:28] <pmichaud>     1,3,5, () xx *

[19:29] <sorear> TimToady: I want to know _how_ it would be different ...

[19:29] *** wamba joined
[19:29] <TimToady> (un)fortunately, my lunch has just arrived...*

[19:29] <pmichaud> () xx *  might be very workable

[19:30] <TimToady> ** almost means that

[19:30] <TimToady> nom &

[19:30] <pmichaud> sorear: a lot of this comes down to "how do we signal infinite lists in subscripts"  (which is what started this)

[19:31] <pmichaud> so,   @a[1,2,3,foo()]   might autotrim if foo() was detectably infinite

[19:31] <pmichaud> a final ,() could mean "ignore the infiniteness of earlier items in the parcel"

[19:31] <pmichaud> thus   @a[1,2,3,foo(),()]   prevents autotrimming, even if foo() signals infiniteness

[19:32] <pmichaud> or something like that.

[19:32] <sorear> What if earlier items in the parcel aren't infinite, but will produce infinite items when reified?

[19:32] <pmichaud> I agree, I don't quite see the full use case for ,() yet.

[19:32] <sorear> e.g. (1, infinitelist, 2)

[19:32] <pmichaud> it's "detectably infinite" that we're looking for, generally

[19:32] <pmichaud> not "ends up being infinite"

[19:33] <pmichaud> we really have three states -- "known finite", "known infinite", and "not known to be either"

[19:34] <pmichaud> various operations may choose different cutoffs based on whether something is known to be finite or known to be infinite

[19:35] <pmichaud> if we "discover" infiniteness in the process of reifying, that's yet another case (that the operation can decide how it wants to handle)

[19:35] *** MayDaniel_ joined
[19:36] <PhatEddy> perl6: class A {has $.a is rw}; class B is A {has $.a is rw}; my $x = B.new; $x.a = 12

[19:36] <p6eval> pugs, rakudo 048573, niecza v6-56-g84360d1:  ( no output )

[19:36] <PhatEddy> rakudo: class A {has $.a is rw}; class B is A {has $.a is rw}; my $x = B.new; $x.a = 12

[19:36] <p6eval> rakudo 048573:  ( no output )

[19:36] <masak> ...and that's correct!

[19:36] *** MayDaniel_ left
[19:37] <PhatEddy> Which class a attribute did I update?

[19:37] *** pjcj joined
[19:37] <tadzik> PhatEddy: none. You updated an attribute of an object, not a class

[19:37] <tadzik> and the object was of class B

[19:37] <tadzik> (I suppose)

[19:38] <jnthn> It was a method dispatch, so yes, B.

[19:38] <pmichaud> you updated the one in class B

[19:38] <pmichaud> afk, walk

[19:43] *** pjcj left
[19:47] *** Moukeddar_ joined
[19:50] <sorear> PhatEddy: in rakudo master and niecza, dunno about pugs, you updated both simultaneously

[19:50] <sorear> AFAIK only nom implements the "attributes are identified by class x name" thing yet

[19:51] <PhatEddy> still playing with it ... thx

[19:51] <TimToady> eh? no, those should be two separate $!a locations

[19:51] <TimToady> and $.a is always virtual

[19:51] <jnthn> TimToady: It's certainly that way in nom.

[19:51] <TimToady> so only looks at the outer

[19:52] <TimToady> you'd have to get fancy to set them all

[19:52] <sorear> TimToady: bug in rakudo master and niecza

[19:53] <TimToady> rakudo: class A {has $.a is rw; method report { say $!a.perl }}; class B is A {has $.a is rw; }; my $x = B.new; $x.a = 12; $x.report

[19:53] <p6eval> rakudo 048573: OUTPUT«12␤»

[19:53] <TimToady> yes, that's rwrong

[19:54] <TimToady> pugs: class A {has $.a is rw; method report { say $!a.perl }}; class B is A {has $.a is rw; }; my $x = B.new; $x.a = 12; $x.report

[19:54] <p6eval> pugs: OUTPUT«\12␤»

[19:54] <TimToady> that's also bogus

[19:55] * moritz thinks that's good material for a test case

[19:55] <TimToady> it's like, the whole *point* of $!a to be a separate location in each class that uses it

[19:56] <TimToady> when we say "private" we mean "private"

[19:56] <sorear> TimToady: it will work after the nom merge!

[19:56] <jnthn> It works in nom already :P

[19:56] <jnthn> Well, apart from lack of accessor generation... :)

[19:56] *** Vlavv_ joined
[19:56] * TimToady speculatively wipes the sweatdrop from his brow

[19:56] <jnthn> nqp gets it right also now ;)

[19:57] <TimToady> nqp: class A {has $.a is rw; method report { say $!a.perl }}; class B is A {has $.a is rw; }; my $x = B.new; $x.a = 12; $x.report

[19:57] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:239)␤»

[19:57] <sorear> despite my prior claims to the contrary

[19:57] <moritz> TimToady: I don't think nqp has automatic accessors

[19:58] <sorear> nqp: class A { has $!a; method report() { say($!a) } }; class B is A { has $!a; method set() { $!a := 12 } }; my $x := B.new; $x.set; $x.report;

[19:58] <p6eval> nqp: OUTPUT«␤»

[19:58] <sorear> nqp also does not have list ops or assignment

[19:58] *** tadam joined
[20:00] <TimToady> bbl # Aron's potential in-laws just showed up to meet the clan...

[20:00] *** tadam left
[20:01] <PhatEddy> Hmmm ... just a thought as to how I got the wrong idea about using build in the first place.  The explanation in S12 under Construction and Initialization is very helpful but the example here http://perlcabal.org/syn/S12.html#Submethods seems confusing.  No?

[20:02] *** kjeldahl joined
[20:05] <tadzik> what do you want to do?

[20:05] *** ggoebel joined
[20:05] <tadzik> I find myself using BUILD as Moose BUILD method, so giving it callsame; at the very beginning

[20:06] *** jfried joined
[20:07] <PhatEddy> I was trying to just get the URI module to have a constructor that takes a simple uri string parameter which I now understand I can do by overriding new - fine.

[20:08] <PhatEddy> tadzik: did you look at the link - is it possible that it gives confusing implications about what build does?

[20:08] <tadzik> PhatEddy: I think I read it, and I'm quite confused how BUILD works and why it works that way. I think it's meant to control the attribute initialization

[20:09] <PhatEddy> thx

[20:09] <tadzik> personally, I use it as "I want to do something as soon as the object is created and everything is initialized"

[20:10] <tadzik> rakudo: class A { submethod BUILD { say "whoosh!" } }; A.new

[20:10] <p6eval> rakudo 048573: OUTPUT«whoosh!␤»

[20:10] *** Moukeddar_ left
[20:11] <pmichaud> I think "BUILD" (in Perl 6) is more along the lines of "this is how I want this class' attributes to be initialized."

[20:11] *** wsppan joined
[20:12] <sorear> What does an anonymous subset do?

[20:12] *** wsppan left
[20:14] *** whiteknight joined
[20:14] <TimToady> the object is specifically *not* completely initialized when BUILD is called

[20:15] <TimToady> and maybe not initialized after either

[20:15] <TimToady> since there could be subclasses that haven't run their BUILD yet

[20:15] <TimToady> sorear: returns an anonymous type object

[20:17] <TimToady> which you could presumably use on the right of a smartmatch

[20:18] <TimToady> tadzik: the object is only guaranteed initialized at the end of BUILDALL

[20:19] <TimToady> I think I mentioned this before...

[20:19] <tadzik> yeah, I think so

[20:19] *** MayDaniel_ joined
[20:19] <tadzik> which may prove the thing is quite confusing

[20:20] <sorear> Anonymous enums are specced to return an EnumMap rather than a type object.  Does this extend to named enums?

[20:20] <sorear> What about the 'enum $foo <a b c>' syntax, is $foo bound to the EnumMap or the type object?

[20:20] <PhatEddy> perl6: class A {has $!a is rw; submethod BUILD ($!a) {}}; my $x = A.new(12);

[20:20] <p6eval> niecza v6-56-g84360d1: OUTPUT«===SORRY!===␤␤Unhandled parameter twigil ! at /tmp/Nk1fctALne line 1:␤------> s A {has $!a is rw; submethod BUILD ($!a⏏) {}}; my $x = A.new(12);␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line

[20:20] <p6eval> ..469 (CORE di…

[20:20] <p6eval> ..rakudo 048573: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in 'A::BUILD' at line 22:/tmp/haXGyGRcNl␤  in main program body at line 22:/tmp/haXGyGRcNl␤»

[20:20] <p6eval> ..pugs: OUTPUT«*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/u1qKqiIkd6 line 1, column 55-69␤»

[20:21] <PhatEddy> that's from another example in S12

[20:21] <PhatEddy> I think ...

[20:23] <PhatEddy> Did I misunderstand the example just above here: http://perlcabal.org/syn/S12.html#Mutating_methods

[20:24] <masak> PhatEddy: I think BUILD parameters are supposed to be named.

[20:24] <TimToady> it will always be called with named args, not positional

[20:24] <PhatEddy> I start to understand that but am wondering whether I understood the examples in the Synopsis

[20:25] <TimToady> if anything translates positional to named, it'll be the new

[20:25] <PhatEddy> Are the synopsis examples off or do I not understand them, if I may so ask?

[20:26] <TimToady> otoh it's relying on binding named args to positional params, which jnthn and masak indicated they'd like to get rid of

[20:26] <TimToady> those examples are fine, but they're expecting to be called with named arguments

[20:26] *** MayDaniel_ left
[20:26] *** dorlamm joined
[20:27] <TimToady> the positions of parameters in BUILD and the positions of args in (a position) new have nothing to do with each other

[20:27] <TimToady> since .bless always takes named args, not positional

[20:27] <TimToady> and has to distribute them to multiple BUILDs

[20:27] <dalek> nqp: 16638bd | pmichaud++ | Configure.pl:

[20:27] <dalek> nqp: Fix typo in min-parrot-revision handling.

[20:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/16638bd90c

[20:27] <TimToady> (via BUILDALL, which is also named-only)

[20:28] <TimToady> sorear: I don't have a strong opinion; we need to look at use cases for full type objects vs EnumMap objects

[20:28] *** Eevee joined
[20:28] <dalek> book: 76b1e78 | duff++ | src/regexes.pod:

[20:28] <dalek> book: minor wording fix (daniel stojanov)++

[20:28] <dalek> book: review: https://github.com/perl6/book/commit/76b1e782c9

[20:29] <TimToady> I'm inclined to lean toward EnumMap, since it's defined

[20:29] <TimToady> esp if a smartmatch will dwim

[20:29] <sorear> would an anonymous enum still produce a new type?

[20:29] <dalek> book: c284546 | duff++ | src/regexes.pod:

[20:29] <dalek> book: Merge pull request #55 from daniel-s/master

[20:29] <dalek> book: 

[20:29] <dalek> book: typo in regexes.pod

[20:29] <dalek> book: review: https://github.com/perl6/book/commit/c284546f60

[20:29] * masak tries to find the blog post that chronicles the switch to the current style of enum declaration

[20:30] <sorear> my $em = enum < a b c >; $em<a>.WHAT.say

[20:30] <sorear> o/ masak

[20:30] <masak> \o

[20:30] <masak> http://strangelyconsistent.org/blog/i-can-haz-constant

[20:30] <sorear> oh, you didn't just join

[20:30] <masak> the use case then was 'has enum $.meth <foo bar>'

[20:31] <TimToady> along with 'has constant $.pi = 3;'

[20:31] <masak> aye.

[20:31] <masak> the important thing with it being that the public accessor shares the enum between the class and its decendents.

[20:32] <masak> descendants*

[20:33] <masak> and I guess sharing the EnumMap would be enough for that.

[20:33] <masak> if we wanted to share the type, we'd have made a type declaration instead.

[20:34] *** kaare__ left
[20:34] <TimToady> sorear:  if you deref $em<a> you're typically just going to get an integer, I'd think

[20:34] <TimToady> $em<a>:pair might return the Enum

[20:34] <dalek> nqp: e8a1c1f | jonathan++ | src/6model/reprs/P6opaque. (2 files):

[20:34] <dalek> nqp: Extend P6opaque so it knows how to vivify containers. Should perform rather better doing things this way than Rakudo does with master; no extra lookup cost to objects that don't need the feature (like in NQP).

[20:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e8a1c1f0f3

[20:35] <TimToady> and both of these are independent of the decision to install a as a subtype of the whole EnumMap

[20:35] <sorear> TimToady: well, with enum Foo <a b c>; Foo.enums<a>.WHAT eq 'Foo()'

[20:35] <TimToady> as a separate symbol

[20:36] <dalek> rakudo/nom: bda8f95 | jnthn++ | src/Perl6/ (2 files):

[20:36] <dalek> rakudo/nom: Get attributes working more. Assignment now works as well as binding. Does type checks.

[20:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bda8f95656

[20:37] <TimToady> .<a> might return something different than bare a does

[20:37] <TimToady> a means 'subset a of Foo where 0' or some such when used as a type

[20:38] <TimToady> but just 0 when used as a number

[20:38] <sorear> I thought a was just a constant

[20:38] <sorear> 0 can be used as a type

[20:38] <TimToady> as a subset type

[20:38] <sorear> multi foo(0) { ... }

[20:38] <sorear> so why couldn't a non-literal constant?

[20:38] <TimToady> turns into foo(Int where 0) or some such

[20:39] <sorear> not Any where 0?

[20:39] <TimToady> enums usually decide to be Int or Str

[20:39] <jnthn> sorear: Certainly Int where 0

[20:39] <jnthn> sorear: Otherwise multi sorting gets hosed.

[20:40] <TimToady> someone probably needs to put together a matrix of ways to refer to an enum against what it means in various contexts...

[20:40] <pmichaud> someone++

[20:41] <pmichaud> seen someone

[20:41] <aloha> Sorry, I haven't seen someone.

[20:41] <pmichaud> alas.

[20:41] <TimToady> I have copious free negative time...

[20:44] <masak> sounds like something Merlin would have...

[20:45] *** george_z0rwell left
[20:45] *** wamba left
[20:47] *** wamba joined
[20:48] <sorear> rakudo: subset Foo;

[20:48] <p6eval> rakudo 048573:  ( no output )

[20:48] <sorear> rakudo: subset Foo; my Foo $x; say $x.perl; $x = $x

[20:48] <p6eval> rakudo 048573: OUTPUT«Any␤»

[20:48] <sorear> is it being interpreted as subset Foo of Any where True #OK ?

[20:49] <sorear> is this correct?

[20:49] *** wamba left
[20:50] <TimToady> probably

[20:50] * TimToady thinks about monkey patching subset types...

[20:52] *** Vlavv_ left
[20:53] *** pjcj joined
[21:00] *** kjeldahl left
[21:01] *** dorlamm left
[21:02] *** tomaw_ joined
[21:04] <dalek> roast: 00f8c3c | moritz++ | S12-attributes/inheritance.t:

[21:04] <dalek> roast: attribute tests for virtual accessors vs. private storage

[21:04] <dalek> roast: review: https://github.com/perl6/roast/commit/00f8c3cbeb

[21:04] <masak> \o/ moritz++

[21:05] *** tomaw left
[21:05] <masak> I imagine there's a corresponding RT ticket for that test.

[21:06] <jnthn> Yes. It's one of the oldest ones.

[21:06] *** tomaw_ is now known as tomaw

[21:08] <masak> I think this one is related: http://rt.perl.org/rt3/Ticket/Display.html?id=61500

[21:09] *** Vlavv joined
[21:27] *** Psyche^ joined
[21:27] *** Psyche^ is now known as Patterner

[21:29] *** Vlavv left
[21:31] <masak> blog post! http://strangelyconsistent.org/blog/june-4-loops

[21:42] *** Vlavv joined
[21:43] <masak> tomorrow we'll write our first game. :)

[21:43] <masak> (I practiced writing it out today just to check that all the prerequisites are in place.) :)

[21:46] *** Psyche^ joined
[21:49] *** Patterner left
[21:49] *** Psyche^ is now known as Patterner

[21:58] <dalek> rakudo/nom: f0144c1 | jnthn++ | src/CORE.setting/operators.pm:

[21:58] <dalek> rakudo/nom: Avoid a bunch of container creation for the primitive ops.

[21:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f0144c11cd

[22:09] *** MayDaniel joined
[22:11] *** pochi joined
[22:29] <masak> 'night, #perl6.

[22:30] *** jfried left
[22:35] *** jfried joined
[22:37] *** noganex joined
[22:40] *** hanekomu left
[22:59] *** jfried left
[23:16] *** MayDaniel left
[23:22] <sorear> \o/ I just figured out what anon constant means

[23:28] <TimToady> it means almost the exact same thing as BEGIN  :)

[23:32] *** rhr joined
[23:37] <sorear> Where might I see an object of type 'Code'?

[23:38] <sorear> niecza: say constant $x = 2 + 2

[23:38] <p6eval> niecza v6-56-g84360d1: OUTPUT«4␤»

[23:39] <sorear> std: constant Foo::Bar = 3

[23:39] <p6eval> std 4b1b100: OUTPUT«===SORRY!===␤Malformed constant at /tmp/NxsEuspAa2 line 1:␤------> constant Foo:⏏:Bar = 3␤    expecting any of:␤       coloncircumfix␤ signature␤Parse failed␤FAILED 00:01 111m␤»

[23:39] <sorear> std: constant $Foo::Bar = 3

[23:39] <p6eval> std 4b1b100: OUTPUT«ok 00:01 114m␤»

[23:41] * sorear is annoyed by the proliferation of slightly different code fragments in niecza for converting $*SCOPE + longname/variable/identifier/etc into a resolved name

[23:53] *** daniel-s joined
[23:56] *** Trashlord left
