[00:01] *** donri joined
[00:02] <soh_cah_toa> i forget, how do i perform a negative lookahead assertion? i know for a "character class" it would be <!alpha> but i'm trying to perform a negative lookahead for a newline

[00:03] <tadzik> <!before \n> should be ok

[00:03] <soh_cah_toa> oh, right 'before'

[00:03] <soh_cah_toa> thanks

[00:06] *** replore joined
[00:07] <sorear> <![\n]> will be much faster in ≈ã, possibly in nom too

[00:07] *** colomon left
[00:07] <sorear> <!before \n> will be slightly faster in niecza

[00:07] <soh_cah_toa> ≈ã? what's that? :\

[00:08] <sorear> .u ≈ã

[00:08] <phenny> U+014B LATIN SMALL LETTER ENG (≈ã)

[00:08] <sorear> I'm trying to start a meme here

[00:08] <soh_cah_toa> :)

[00:08] <tadzik> I like that

[00:08] <jnthn> Like I can be bothered to learn to type that :P

[00:08] <jnthn> Byut, cute :)

[00:08] <tadzik> oh, you can just copypaste that every time you need it

[00:08] <tadzik> I do it with sjohnson's fatface

[00:08] * sorear just compose n g

[00:09] <diakopter> what does the meme mean

[00:09] <flussence> altgr+g=≈ã for me

[00:09] <flussence> also, whoosh! https://github.com/flussence/specgraphs/raw/master/impls.png

[00:10] <tadzik> wzooom

[00:10] <sorear> beta, ng, and beijing are all quite problematic

[00:10] <sorear> I guess b would also work for me

[00:10] <soh_cah_toa> what's ng?

[00:10] <tadzik> the old master

[00:10] <soh_cah_toa> ah

[00:11] <soh_cah_toa> why ng? is it an acronym?

[00:12] <tadzik> wasn't that nextgen?

[00:12] <tadzik> I dunno

[00:12] <sorear> I think it was nextgen originally

[00:12] <soh_cah_toa> ok

[00:13] *** risou_awy is now known as risou

[00:13] <jnthn> It was a pun on "nextgen" and "new grammar"

[00:14] <tadzik> new grammar, new object model, what'd be next?

[00:14] <sorear> flussence++ # cool.  would be even cooler if it could go back to the creation of niecza in Jun10 or thereabouts

[00:15] <sorear> tadzik: the next part of rakudo that seriously needs an overhaul is PCT, so I guess ncg (new code generator)

[00:15] <sorear> tadzik: although that might be more of a nqp thing not touching Rakudo proper

[00:16] <tadzik> indeed

[00:16] <supernovus> ≈ã: say "hello from ng ;-)";

[00:16] <supernovus> darn ;-)

[00:16] <jnthn> sorear: Yeah, that's the plan.

[00:17] *** supernovus left
[00:17] <sorear> jnthn: wow, I didn't think I'd be right :-)

[00:18] * sorear notes that ncg puns as Native Code Generator (used by the GHC people to refer to their new non-C-based backend)

[00:18] *** donri left
[00:18] *** donri joined
[00:19] <sorear> well, it was "new" when I was active in '07, they might not consider it new anymore :)

[00:20] *** tokuhir__ left
[00:23] <soh_cah_toa> rakudo: my $foo = "foobar"; $foo ~~ s:g|o|e|; say $foo

[00:23] <p6eval> rakudo 47d772: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "$foo ~~ s:"‚ê§¬ª

[00:24] <soh_cah_toa> does 2011.07 not support alternate delimiters in regexes? i keep getting "Unable to parse blockoid, couldn't find final '}'"

[00:24] <soh_cah_toa> and when i use / instead, it compiles fine

[00:24] <tadzik> it may be

[00:24] <soh_cah_toa> :(

[00:25] <tadzik> rakudo: my $foo = "foobar"; $foo ~~ s:g{o}{e}; say $foo

[00:25] <p6eval> rakudo 47d772: OUTPUT¬´Could not find sub &s:g{o}‚ê§  in block <anon> at /tmp/HeWgmLqI9k:1‚ê§  in <anon> at /tmp/HeWgmLqI9k:1‚ê§‚ê§¬ª

[00:25] <soh_cah_toa> aw man...that means i gotta backslash escape every / in the regex

[00:25] <tadzik> just '' them

[00:26] <jnthn> b: rx{ / }

[00:26] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<{ }>, couldn't find final '}' at line 22‚ê§¬ª

[00:29] *** risou is now known as risou_awy

[00:32] <tadzik> g'night #perl6

[00:32] <jnthn> 'night

[00:32] <soh_cah_toa> \o

[00:36] <sorear> rakudo: s :g{o}{e}

[00:36] <p6eval> rakudo 47d772: OUTPUT¬´Method 'at_key' not found for invocant of class 'Pair'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1016‚ê§  in block <anon> at /tmp/yXNrOCi9et:1‚ê§  in <anon> at /tmp/yXNrOCi9et:1‚ê§‚ê§¬ª

[00:36] <sorear> er

[00:36] <sorear> rakudo: s|o|e|

[00:37] <p6eval> rakudo 47d772: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "s|o|e|"‚ê§¬ª

[00:37] <sorear> tadzik: s:g{o}{e} is not valid syntax

[00:37] <sorear> std: s:g{o}{e}

[00:37] <p6eval> std 8b331d2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of brackets around replacement; in Perl 6 please use assignment syntax at /tmp/mny7SuVZ6D line 1:‚ê§------> [32ms:g{o}[33m‚èè[31m{e}[0m‚ê§Parse failed‚ê§FAILED 00:01 120m‚ê§¬ª

[00:45] *** cooper joined
[00:45] <soh_cah_toa> how do i dynamically call subroutines? if that's what you'd called it, i guess. for instance, if i have a package named Foo::Bar with a subroutine called foo(), calling `my $pkg = 'Foo::Bar'; &"$pkg"::foo()` from another package doesn't seem to work

[00:45] <soh_cah_toa> i haven't had to do that in p6 yet :\

[00:48] <[Coke]> sorear: there are huge number of tests that depend on Range stringifying as a list of numbers, it would seem.

[00:48] *** [particle] left
[00:48] <sorear> perl6: say ~(1..6)

[00:48] <p6eval> pugs, rakudo 47d772: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[00:48] <p6eval> ..niecza v10-12-gecd62ba: OUTPUT¬´1..6‚ê§¬ª

[00:49] <diakopter> hm

[00:49] <diakopter> makes me think

[00:49] <sorear> [Coke]: that may be part of the gist transition that I didn't quite track.  I'd like to see what jnthn or TimToady has to say about it

[00:49] <diakopter> perl6: say (1..6).perl

[00:49] <p6eval> rakudo 47d772, niecza v10-12-gecd62ba: OUTPUT¬´1..6‚ê§¬ª

[00:49] <p6eval> ..pugs: OUTPUT¬´(1, 2, 3, 4, 5, 6)‚ê§¬ª

[00:50] <diakopter> perl6: print (1..6)

[00:50] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´1..6¬ª

[00:50] <p6eval> ..pugs, rakudo 47d772: OUTPUT¬´123456¬ª

[00:50] <[Coke]> aye. (i'd rather see todo fudges working first, will make it easier to go back and fix those either way.

[00:50] *** [particle] joined
[00:50] <sorear> niecza: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = Foo::Bar:: ; say $pkg<&foo>()

[00:50] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´hello‚ê§Bool::True‚ê§¬ª

[00:51] <sorear> for soh_cah_toa

[00:51] <soh_cah_toa> rakudo: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = Foo::Bar:: ; say $pkg<&foo>()

[00:51] <p6eval> rakudo 47d772: OUTPUT¬´Method 'at_key' not found for invocant of class 'Any'‚ê§  in find_method at src/gen/Metamodel.pm:143‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1016‚ê§  in block <anon> at /tmp/iWnWAchJkO:1‚ê§  in <anon> at /tmp/iWnWAchJkO:1‚ê§‚ê§¬ª

[00:51] <sorear> niecza: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = "Foo::Bar" ; say GLOBAL::($pkg)::foo() # alternatively, if you have a string

[00:52] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any‚ê§  at /tmp/Mfyor77x8J line 1 (MAIN mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2116 (‚Ä¶

[00:52] <sorear> niecza: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = "Foo::Bar" ; say &GLOBAL::($pkg)::foo () # alternatively, if you have a string

[00:52] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row at /tmp/A9WdeXais5 line 1:‚ê§------> [32m= "Foo::Bar" ; say &GLOBAL::($pkg)::foo [33m‚èè[31m() # alternatively, if you have a string[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[00:52] <sorear> niecza: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = "Foo::Bar" ; say &GLOBAL::($pkg)::foo() # alternatively, if you have a string

[00:52] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´hello‚ê§Bool::True‚ê§¬ª

[00:52] <soh_cah_toa> i'm using 2011.07 though

[00:53] <sorear> Why don't you use a class?

[00:53] <sorear> class Foo::Bar { method foo() { ... } }; my $class = Foo::Bar;  $class.foo;

[00:53] <soh_cah_toa> i'm building a functional interface

[00:53] <soh_cah_toa> it has to determine what package to use based on the os

[00:56] <soh_cah_toa> "Indirect name lookups not yet implemented"

[00:56] <soh_cah_toa> wonderful :(

[00:57] <dalek> rakudo/optimizer: 74e8d35 | jnthn++ | src/Perl6/Actions.pm:

[00:57] <dalek> rakudo/optimizer: Handle natively typed variables in inlinability analysis.

[00:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/74e8d35f35

[00:57] <dalek> rakudo/optimizer: b4ecf53 | jnthn++ | src/binder/multidispatch.c:

[00:57] <dalek> rakudo/optimizer: Couple of fixes to native types in multi-dispatch; one in narrowness compuation, another in compile time analysis.

[00:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b4ecf537fa

[00:57] <dalek> rakudo/optimizer: 7d26339 | jnthn++ | src/core/Int.pm:

[00:57] <dalek> rakudo/optimizer: Stub in first couple of native operators.

[00:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/7d26339432

[00:57] <dalek> rakudo/optimizer: 074021d | jnthn++ | src/Perl6/Optimizer.pm:

[00:57] <dalek> rakudo/optimizer: A crack at enabling inlining in the simple case of chaining operators, though something seems slightly adrift here. At this point, we can now inline the couple of native operators that have been added to the setting. There's various issues, various test regressions, but not crazily many.

[00:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/074021dfcb

[00:58] <diakopter> adrift :)

[00:58] <jnthn> what? :)

[00:58] <diakopter> amiss?

[00:58] <sorear> soh_cah_toa: I've recently become quite fond of the "class as a container for functions" pattern.

[00:58] <jnthn> I didn't stay up late enough that I've started imagining words, have I? :)

[00:59] <sorear> adrift is a real word.

[00:59] <jnthn> "lacking aim, direction, or stability. "

[00:59] <sorear> jnthn: ~(1..6)

[00:59] <jnthn> Well, this is most certainly lacking stability :)

[00:59] *** [particle] left
[00:59] <soh_cah_toa> well still, i'm building a File::Spec module it it needs to know what package to use depending on $*OS

[00:59] <diakopter> I was merely musing that the usual word to follow "slightly" in such a context is "amiss"

[01:00] <jnthn> diakopter: Hmm...doesn't feel as natural. I blame dialect. :)

[01:00] <jnthn> nom: ~(1..6)

[01:00] <p6eval> nom 47d772:  ( no output )

[01:00] <jnthn> nom: say ~(1..6)

[01:00] <p6eval> nom 47d772: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[01:00] <jnthn> sorear: That's what I expect, fwiw.

[01:00] <sorear> jnthn: niecza says 1..6

[01:01] <jnthn> niecza: say 1..6; say 1...6;

[01:01] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´1..6‚ê§1 2 3 4 5 6‚ê§¬ª

[01:01] <sorear> which feels more correct to me.  I'd like to be persuaded by arguments instead of tests :)

[01:01] <jnthn> sorear: I think those two are meant to be consistent.

[01:01] <sorear> 1..6 returns a Range object. 1...6 returns a List.

[01:01] *** [particle] joined
[01:01] <jnthn> sorear: Suggest arguing with TimToady might be more useful ;)

[01:02] <sorear> jnthn: has TimToady spec'd the correct stringification?

[01:02] <soh_cah_toa> nom: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = "Foo::Bar" ; say &GLOBAL::($pkg)::foo()

[01:02] <p6eval> nom 47d772: OUTPUT¬´Method 'postcircumfix:<( )>' not found for invocant of class 'Failure'‚ê§  in <anon> at src/gen/Metamodel.pm:3134‚ê§  in block <anon> at /tmp/h0ql3y4ze4:1‚ê§  in <anon> at /tmp/h0ql3y4ze4:1‚ê§‚ê§¬ª

[01:02] <jnthn> sorear: Can't recall a spec ref off hand. OTOH, I've never really been the person working on lists/ranges etc in Rakudo.

[01:02] <soh_cah_toa> nom: package Foo::Bar { our sub foo() { say "hello" } }; my $pkg = "Foo::Bar" ; say &::($pkg)::foo()

[01:02] <p6eval> nom 47d772: OUTPUT¬´Method 'postcircumfix:<( )>' not found for invocant of class 'Failure'‚ê§  in <anon> at src/gen/Metamodel.pm:3134‚ê§  in block <anon> at /tmp/P_Xpzd037M:1‚ê§  in <anon> at /tmp/P_Xpzd037M:1‚ê§‚ê§¬ª

[01:02] <sorear> jnthn: is that a pm thing?

[01:02] <jnthn> sorear: Yes.

[01:03] * sorear pngs pmichaud

[01:03] *** packetknife left
[01:06] <diakopter> niecza: say list 1..6

[01:06] <p6eval> niecza v10-12-gecd62ba: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'list' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ‚ê§ ‚Ä¶

[01:07] <diakopter> There is a "list" operator which imposes a list context on its arguments even if list itself occurs in a item context.  <-- S02... is this right?

[01:07] <jnthn> 3am...guess that means sleep

[01:08] <jnthn> Plan for tomorrow: clean up the mess I've made while implementing inlining, and hack on other nom stuff :)

[01:08] <jnthn> 'ngiht

[01:08] <jnthn> *night

[01:08] <diakopter> o

[01:18] *** benabik joined
[01:20] <soh_cah_toa> does anyone know of a good blog/article explaing submethods? i usually see BUILD or DESTROY submethods

[01:21] <benabik> AFAIK, submethods are methods that aren't inheritied.

[01:21] *** packetknife joined
[01:23] <soh_cah_toa> what about BUILD methods, though? when are those invoked? what's special about them?

[01:26] <benabik> BUILD is called as part of new?

[01:26] <arnsholt> BUILD is called by the default .new method

[01:26] <arnsholt> moritz has a blog post about it somewhere I think

[01:26] <benabik> I think new defaults to self.bless(*); self.BUILD;

[01:26] <soh_cah_toa> before or after new()?

[01:26] <benabik> Although I don't know what bless is these days.

[01:27] <benabik> soh_cah_toa: inside

[01:27] <arnsholt> http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html for example

[01:27] *** [particle] left
[01:28] <soh_cah_toa> great, thanks

[01:30] *** [particle] joined
[01:30] *** alester joined
[01:31] *** toebu left
[01:31] <benabik> Does :$!var, in general, alter attributes?  Or is that special to BUILD?

[01:32] <benabik> (in a sig, referencing the blog post)

[01:32] *** toebu joined
[01:37] *** whiteknight left
[01:42] *** soh_cah_toa left
[01:45] *** wolfman2000 joined
[01:51] *** [particle] left
[01:54] *** [particle] joined
[01:56] *** molaf joined
[01:56] *** packetknife left
[02:12] <sorear> benabik: in general.  However it is never used except with BUILD.

[02:17] <sorear> who will take Martin Kealey on p6l?

[02:21] *** woosley joined
[02:29] <dalek> niecza/serialize: 1e4b501 | sorear++ | / (3 files):

[02:29] <dalek> niecza/serialize: Simplify marshalling for metaobject references

[02:29] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/1e4b50112a

[02:39] *** colomon joined
[02:39] *** uasi joined
[02:41] *** uasi left
[02:44] <[Coke]> need to see if the rakudo tool for reporting on # of skipped/todo'd tests works on niecza.

[02:55] <[Coke]> how many tests did trig get us up to?

[03:13] <dalek> niecza: 031dc9f | sorear++ | lib/Test.pm6:

[03:13] <dalek> niecza: Implement todo()

[03:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/031dc9f703

[03:13] <dalek> niecza: 12c9283 | sorear++ | FETCH_URL:

[03:13] <dalek> niecza: Update bootstrap version

[03:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/12c92833ba

[03:15] *** ponbiki joined
[03:16] <[Coke]> All tests successful.

[03:16] <[Coke]> Files=275, Tests=7907, 743 wallclock secs ( 2.67 usr  1.66 sys + 1220.96 cusr 59.34 csys = 1284.63 CPU)

[03:16] <[Coke]> Result: PASS

[03:16] <[Coke]> (niecza)

[03:17] <[Coke]> sorear: (todo) ah, nifty. I can start converting the tests now.

[03:17] <dalek> roast: d0e149b | Coke++ | S0 (29 files):

[03:17] <dalek> roast: niecza fudging

[03:17] <dalek> roast: review: https://github.com/perl6/roast/commit/d0e149b4bd

[03:17] <dalek> roast: 5d6e74b | Coke++ | S05-metasyntax/litvar.t:

[03:17] <dalek> roast: Fix test plan.

[03:17] <dalek> roast: review: https://github.com/perl6/roast/commit/5d6e74bc02

[03:18] <dalek> niecza: 406bfa2 | Coke++ | t/spectest.data:

[03:18] <dalek> niecza: run fudged tests.

[03:18] <dalek> niecza: review: https://github.com/sorear/niecza/commit/406bfa2193

[03:23] <sorear> yay

[03:23] <sorear> Coke++

[03:23] *** [particle] left
[03:33] *** vlixes` joined
[03:34] *** cognominal left
[03:34] *** cognominal joined
[03:34] *** vlixes left
[03:34] <[Coke]> sorear: do you mind if I allow todos with no reason?

[03:35] <[Coke]> (then I can allow "?#niecza todo" which is really all the information I have at this point.)

[03:39] *** odoacre joined
[03:42] *** molaf left
[03:43] <[Coke]> (done)

[03:43] *** kaleem joined
[03:44] <[Coke]> (rerunning spec test with todos...)

[03:51] <sorear> [Coke]: go ahead

[03:57] *** packetknife joined
[03:58] *** WhyteGurl23 joined
[03:58] <sorear> WhyteGurl23: are you interested in Perl 6?

[03:58] *** satyavvd joined
[04:01] *** WhyteGurl23 left
[04:07] *** mberends joined
[04:10] <dalek> niecza: ac814f7 | Coke++ | lib/Test.pm6:

[04:10] <dalek> niecza: escape "#" in TAP test descriptions

[04:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ac814f71e4

[04:10] <dalek> niecza: 8fdba33 | Coke++ | lib/Test.pm6:

[04:10] <dalek> niecza: Allow bare todos.

[04:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8fdba33e9a

[04:11] <dalek> roast: 4bdf17e | Coke++ | S0 (59 files):

[04:11] <dalek> roast: Convert niecza faux-todo to real todo.

[04:11] <dalek> roast: review: https://github.com/perl6/roast/commit/4bdf17ed08

[04:11] *** envi_ joined
[04:16] *** flussence left
[04:18] *** [particle] joined
[04:27] <sorear> wow you're on a roll.  Coke++

[04:28] <sorear> o/ mberends

[04:29] <mberends> o/ sorear, [Coke]-on-a-roll!

[04:30] <sorear> mberends: I was wondering today what the most useful behavior of serialization+CLR-interop would be

[04:30] <sorear> wait, I think I just gave myself an idea

[04:32] <mberends> sorear: I'd not noticed your fix for issue 57 until a few hours ago, now any Gtk window can be resized. I know it works for diakopter++ on Windows as well.

[04:32] <sorear> nice

[04:33] * sorear is now reading the .net serialization docs

[04:34] *** flussence joined
[04:35] *** colomon left
[04:35] *** alester left
[04:35] *** saaki left
[04:35] *** jfried left
[04:35] *** robinsmidsrod left
[04:35] *** ruz left
[04:35] *** TimToady left
[04:35] *** szabgab left
[04:35] *** JodaZ_ left
[04:35] *** sbp left
[04:35] *** nsh left
[04:35] *** _sri left
[04:35] *** sjn left
[04:35] *** ranguard left
[04:35] *** betterworld left
[04:35] *** jdhore left
[04:35] *** alester_ joined
[04:37] *** WhyteGurl23 joined
[04:37] <WhyteGurl23> males hmu

[04:38] *** jdhore joined
[04:38] *** ranguard joined
[04:38] *** szabgab joined
[04:38] *** sjn joined
[04:38] <sorear> WhyteGurl23: hi.  you seem to be a chatmosphere user.

[04:38] <sorear> WhyteGurl23: this channel is used to coordinate the development of the next version of the "Perl" programming language.

[04:38] *** uasi joined
[04:39] <sorear> WhyteGurl23: please tell chatmosphere to remove #perl6 from its list of dating channels.

[04:39] *** robinsmidsrod joined
[04:40] <WhyteGurl23> male 23-32 hmu

[04:43] <sorear> WhyteGurl23: what language(s) do you speak?  ¬øhabla espa√±ol? Êó•Êú¨Ë™û„Å´Ë©±„Åõ„Åæ„Åô„ÅãÔºü

[04:43] <sorear> stupid IRC proxies blocking my geo-IP

[04:44] *** saaki joined
[04:44] *** jfried joined
[04:44] *** ruz joined
[04:44] *** TimToady joined
[04:44] *** JodaZ_ joined
[04:44] *** sbp joined
[04:44] *** nsh joined
[04:44] *** _sri joined
[04:44] *** betterworld joined
[04:44] *** donri left
[04:44] *** donri joined
[04:45] *** WhyteGurl23 left
[04:49] *** [particle] left
[05:05] *** mberends left
[05:09] *** mberends joined
[05:15] *** koban` joined
[05:20] *** odoacre left
[05:22] *** packetknife left
[05:22] *** sftp left
[05:25] *** athomason left
[05:25] *** athomason_ joined
[05:26] *** packetknife joined
[05:28] <mberends> sorear: I've met two use cases for serialization in CLR: 1. passing objects from one process to another for Remote Method Invocation, and 2. persistent storage of objects for resumable workflow engines.

[05:30] *** packetknife left
[05:31] *** packetknife joined
[05:32] *** daniel-s joined
[05:33] <sorear> mberends: I am speaking of Perl 6 serialization.

[05:33] *** slavik1 left
[05:33] * sorear just figured out most of the details for the namesake feature of niecza/serialize; optimism +5

[05:37] <mberends> sorear: I was wondering where the CLR Interop would come in. All I could imagine was Perl 6 managing the networking or the storage of the CLR objects. I'm afraid I cannot yet imagine the reverse case, of CLR doing anything with serialized Perl 6 objects. They would be opaque to CLR.

[05:46] <sorear> mberends: constant Foo = CLR::...  # requires a CLR Type to be saved in the compiled module

[05:46] <sorear> mberends: it seems .net already has this pretty well handled, though.  BinaryFormatter saves the assembly's FullName and uses that to reload it on deserialization; I'll copy that logic

[05:47] <sorear> I'd love to reuse the .net serializer but there doesn't seem to be a place to plug in bounding

[05:48] <sorear> oh, I found a place to plug in bounding

[05:48] <sorear> but there's still a disturbing amount of indirection here

[05:51] *** slavik1 joined
[05:52] <mberends> sorear: that's still good news, the indirection is most likely necessary, and the overheads less than the I/O that usually follows.

[05:58] *** zostay left
[06:01] <sorear> mberends: how has gtk been treating you?  any new problems come up?

[06:01] *** wtw joined
[06:02] *** slavik1 left
[06:05] <mberends> sorear: The Niecza side of Gtk has behaved extremely well. Most of the work is in finding which CLR classes and objects to use, sometimes they are in other namespaces. The Mono library documentation turns out to be patchy, even sparse in places.

[06:05] *** zostay joined
[06:06] <sorear> mberends: I suppose you're also using the language-neutral (ok, C) GTK docs?

[06:06] *** orafu left
[06:07] *** orafu joined
[06:07] <mberends> sorear: correct

[06:10] <mberends> sorear: the matchboxes puzzle solution exits with a strange error message because of the custom event loop used in the place of Application.Run: https://gist.github.com/1240895

[06:11] <mberends> commute &

[06:11] *** mberends left
[06:11] *** gern joined
[06:14] <gern> I've been trying to figure out if you can overload >=. It seems like multi infix:<>=>(...) is problematic.

[06:15] <sorear> that doesn't work because quoting

[06:15] <sorear> there are several ways to make this work

[06:15] <sorear> multi infix:¬´>=¬ª() # alternate quote character

[06:15] <gern> Will do thanks

[06:15] <sorear> multi infix:<< >= >>() # double the quote (<<<, <<<< works too)

[06:16] <sorear> multi infix:<\>=>() # escape the close-quote

[06:16] <sorear> multi infix:['>=']() # alternate syntax uses general Perl 6 quoting

[06:16] <sorear> multi infix:[">="]() # naturally this works too, as does qq () and friends

[06:17] <gern> Yikes. More ways than I thought. Also I assume GLOBAL::infix<> will work

[06:17] <sorear> GLOBAL:: won't work and wouldn't solve your problem anyway

[06:17] <sorear> you could define GLOBAL::infix:¬´>=¬ª

[06:18] <sorear> GLOBAL::infix:<>=> is the same syntax error for the same reason

[06:18] <gern> Perhaps I just need to read a little more :)

[06:18] <sorear> but GLOBAL probably doesn't do what you think

[06:18] *** packetknife left
[06:18] <gern> I was overloading the operator within a class so I assumed it wouldn't be globaly visible withou that

[06:19] <sorear> definitions using GLOBAL need to be accessed using GLOBAL

[06:19] <sorear> "4 >= 3" looks for infix:<< >= >> in lexical scopes *only*

[06:20] <gern> OK. Thanks I tried a couple of your suggestions and they work great.

[06:20] <sorear> you can either define >= outside the class, or define it "is export" and then import the class

[06:20] <gern> I'll play with both.

[06:20] <gern> Thanks again.

[06:20] <sorear> note, Beijing-class Rakudos handle >= completely wrong

[06:21] <sorear> they *do* keep it in GLOBAL

[06:21] <sorear> this is probably fixed in nom

[06:21] <gern> I'm using nom

[06:21] *** alim joined
[06:21] <sorear> excellent

[06:21] *** alim left
[06:22] *** alim joined
[06:39] *** gern left
[06:46] *** lestrrat left
[06:52] *** lestrrat joined
[06:53] <dalek> niecza/serialize: 8a35c4f | sorear++ | / (7 files):

[06:53] <dalek> niecza/serialize: Finish basic type creation

[06:53] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/8a35c4fa6e

[06:53] * sorear out

[07:43] *** mj41 joined
[07:46] *** envi_ left
[08:06] *** Trashlord left
[08:11] *** mj41 left
[08:11] *** mj41 joined
[08:25] *** dakkar joined
[09:03] *** mj41 left
[09:05] *** Bzek left
[09:12] *** PZt left
[09:13] <jnthn> o/ #perl6

[09:14] <eiro> jnthn, masak: can you give me an average price of the fly when you come to france ? 

[09:17] *** masak joined
[09:17] <masak> eiro: I don't understand the question :/

[09:17] <masak> could you maybe restate it?

[09:19] *** mj41 joined
[09:20] <eiro> masak, sorry. i wonder how does it cost to take carre of your charges if we invite you to the next fpw

[09:20] <eiro> (jp12) 

[09:21] <eiro> so if you remember the average cost of your fly sweden/paris, it would help

[09:22] <eiro> the IATA of your airport too

[09:22] <mux> there's a perl6 event in paris?

[09:22] <eiro> masak, oh, by the way: i'm wearing my t-shirt "i'm NOT normalized" 

[09:22] <eiro> mux, no: perl event 

[09:23] <masak> eiro: :D

[09:23] * mux is wearing his t-shirt "Sex with your girlfriend, 74 people like it" with facebook-like icons.

[09:23] <mux> http://www.tshirthell.com/funny-shirts/sex-with-your-girlfriend-74-people-like-this/

[09:23] <eiro> but masak and jnthn came and gave valuable talks last events so i would like to sponsor them the next year

[09:25] <jnthn> eiro: masak and I would tend to fly from CPH

[09:25] *** vlixes` left
[09:26] *** vlixes` joined
[09:26] <jnthn> (Which is actually in Denmark, but still only 30 minutes from here :))

[09:27] <eiro> jnthn, thx

[09:27] <masak> eiro: it cost 300 EUR last time.

[09:27] *** orafu left
[09:28] <masak> that's 300 EUR both ways.

[09:28] <masak> grr, disambiguation is hard :)

[09:28] <masak> the total cost was 300 EUR.

[09:28] <eiro> 300 is for paris and back

[09:28] <eiro> ok

[09:29] *** orafu joined
[09:33] *** mj41 left
[09:38] *** mj41 joined
[09:41] *** woosley left
[09:43] *** replore left
[09:48] *** tty234_ is now known as tty234

[09:52] *** _twitch joined
[09:54] *** newsbad_com left
[10:01] <tadzik> 'morning

[10:01] <jnthn> o/ tadzik 

[10:01] <jnthn> Wondered which of us would be about first today ;)

[10:01] <tadzik> jnthn goes to sleep later, and wakes up earlier. Madness

[10:04] *** mj41 left
[10:05] *** woosley joined
[10:06] <jnthn> :)

[10:06] * jnthn is hacking a little more on inlining

[10:07] *** lambdabot2 joined
[10:09] *** lambdabot2 left
[10:18] *** daxim joined
[10:18] *** mj41 joined
[10:20] *** kst` joined
[10:25] <flussence> I don't think this is implemented in nom, but would /\N ** $chars-per-line/ be correct?

[10:25] <flussence> (ATM I'm using an ugly assertion that counts $0.Str.chars...)

[10:31] <flussence> niecza: my $str = ('a'..'z').join; my $tw = 8; say $str.comb(/\N ** $tw/).perl;

[10:31] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´Potential difficulties:‚ê§  Unsupported use of atom ** $tw as separator;nowadays please use atom+ % $tw at /tmp/I6Gpvh_uxt line 1:‚ê§------> [32min; my $tw = 8; say $str.comb(/\N ** $tw[33m‚èè[31m/).perl;[0m‚ê§‚ê§["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"‚Ä¶

[10:31] <flussence> oh.

[10:32] <flussence> niecza: my $str = ('a'..'z').join; my $tw = 8; say $str.comb(/\N ** 0..$tw/).perl;

[10:32] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Malformed range at /tmp/IuUN68TH0Y line 1:‚ê§------> [32min; my $tw = 8; say $str.comb(/\N ** 0..[33m‚èè[31m$tw/).perl;[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[10:34] <donri> why does infix:<,> have lower precedence than ternary?

[10:35] <jnthn> Place where I like that is so you can use it when passing an argument without having to add parens.

[10:36] *** mauke joined
[10:37] <mauke> hello is this where the ?:, action is 

[10:37] <donri> yep :)

[10:37] <donri> except ternary in perl6 is ?? !!

[10:37] <mauke> donri: oh, you asked the wrong question

[10:38] <mauke> don't confuse me, man

[10:38] <donri> i did?

[10:38] <mauke> yes

[10:38] <mauke> of course , should have lower precedence than ?? !!

[10:38] <donri> i'm sensing a but

[10:39] <mauke> that doesn't apply in the middle part

[10:39] <mauke> I don't know how perl6 syntax works but ?? !! is a incircumfix operator

[10:40] <mauke> i.e. it works like parens around the middle part

[10:40] <mauke> there is no syntactic ambiguity that would need to be resolved by precedence

[10:40] <jnthn> std: 1 ?? 2, 3 !! 4

[10:40] <p6eval> std 8b331d2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Precedence of , is too loose to use between ?? and !!; please use parens around inner expression at /tmp/EqH77wOeIb line 1:‚ê§------> [32m1 ?? 2,[33m‚èè[31m 3 !! 4[0m‚ê§Parse failed‚ê§FAILED 00:01 120m‚ê§¬ª

[10:40] <mauke> yeah, I don't know where perl got that

[10:40] <mauke> it works in C

[10:43] <mauke> to use a perl5 example, this is like throwing a parse error for @foo[1, 2] and requiring @foo[(1, 2)] because [] binds tighter than ,

[10:46] <flussence> "1 ? 2, 3 : 4" is a syntax error in perl 5 :)

[10:46] <mauke> yes, that's how this started

[10:47] <mauke> and I was surprised to learn that it's still broken in perl6

[10:48] <flussence> what would that construct be used for in C?

[10:48] <mauke> return cond ? printf("zomg\n"), foo() : bar();

[10:50] *** mberends joined
[10:52] *** vlixes`` joined
[10:55] *** im2ee joined
[10:56] <im2ee> Hello! :)

[10:56] *** vlixes` left
[10:56] <tadzik> hi im2ee 

[10:58] <flussence> mauke: that line could be written more clearly using &&, or as a function. Perl 6's behaviour isn't broken; we're not trying to be a better C. That's a job for D :)

[10:58] <tadzik> a block could work too

[10:58] <mauke> that line can't be written using &&

[10:58] <mauke> it is in a function

[10:58] <tadzik> I guess Perl people are not really used to ',', and don't really miss this

[10:58] <mauke> perl6's behavior is broken, regardless of whether it's trying to be a better C or not

[10:59] <tadzik> rakudo: 1 ?? { say 'foo'; say 'bar' } !! say "NOPE"

[10:59] <p6eval> rakudo 47d772:  ( no output )

[10:59] <mauke> perl5 provides do {...}, which is a decent workaround

[10:59] <jnthn> The parens will do it too

[10:59] <mauke> ah, bare block

[10:59] <mauke> nice

[10:59] <tadzik> wait, why doesn't it work

[10:59] <jnthn> oh, maybe not there

[10:59] <tadzik> rakudo: 1 ?? { say 'foo'; say 'bar' }.() !! say "NOPE"

[10:59] <p6eval> rakudo 47d772: OUTPUT¬´foo‚ê§bar‚ê§¬ª

[10:59] <tadzik> I'd expect it to be executed right away

[10:59] <jnthn> tadzik: I woudln't.

[11:00] <jnthn> tadzik: It's a closure there.

[11:00] <tadzik> not like it's a sub or something

[11:00] <tadzik> mhm

[11:00] <tadzik> I'd expect it to be immediate block in this case

[11:00] <mauke> flussence: I'm not talking about any particular piece of code. I simply don't understand why perl thinks this is a syntax error when 1) it's completely unambiguous and 2) the language it was stolen from (C, otherwise much more primitive) doesn't have this restriction

[11:01] <tadzik> I can agree with that

[11:04] *** uasi left
[11:04] *** SHODAN joined
[11:08] *** mberends left
[11:09] <dalek> nqp: 422048a | jnthn++ | src/PAST/NQP.pir:

[11:09] <dalek> nqp: Fix handling of WHAT in nqp::op mapping.

[11:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/422048a4ff

[11:11] *** lambdabot2 joined
[11:13] *** lambdabot2 left
[11:21] *** benabik left
[11:22] *** envi joined
[11:23] *** colomon joined
[11:23] <colomon> [Coke]++!

[11:24] *** lambdabot2 joined
[11:26] <masak> mauke: I don't want to sound negative, but your presence here makes the ma<Tab> problem even worse :P

[11:26] *** lambdabot2 left
[11:27] <masak> mauke: also, ?? !! is an infix in STD.pm6. there's no concept of incircumfix. it's just an infix with strange parsing rules.

[11:28] *** PZt joined
[11:29] *** lambdabot2 joined
[11:32] <mux> lambdabot is in #perl6?

[11:32] <mux> > fix (1:)

[11:32] <lambdabot2>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...

[11:32] *** _twitch left
[11:33] <tadzik> is that haskell?

[11:33] <masak> aye.

[11:34] *** leprevost joined
[11:34] <masak> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Function.html#v:fix

[11:35] <tadzik> > tail [1, 2, 3]

[11:35] <lambdabot2>   [2,3]

[11:35] <tadzik> hah, I can haskell

[11:35] <dalek> rakudo/optimizer: 1a2a145 | jnthn++ | tools/build/NQP_REVISION:

[11:35] <dalek> rakudo/optimizer: Bump NQP_REVISION to get map_node fixes.

[11:35] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/1a2a145cfd

[11:35] <dalek> rakudo/optimizer: 7b09735 | jnthn++ | src/Perl6/ (2 files):

[11:35] <dalek> rakudo/optimizer: Add supprot for nqp::want, and make various bits of analysis smarter about PAST::Want.

[11:35] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/7b09735e76

[11:35] <dalek> rakudo/optimizer: f70067c | jnthn++ | src/core/Int.pm:

[11:35] <dalek> rakudo/optimizer: Native operators should use nqp::want; get infix:<+>(int, int) to do so.

[11:35] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/f70067c8b3

[11:35] <dalek> rakudo/optimizer: e14527f | jnthn++ | src/Perl6/Optimizer.pm:

[11:35] <dalek> rakudo/optimizer: Correct the chain analysis so it only handles the very constrained (but very common) case I'd intended it to. Fixes various of the spectest regressions.

[11:36] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/e14527fce1

[11:36] *** Psyche^ joined
[11:37] *** Patterner left
[11:37] *** Psyche^ is now known as Patterner

[11:37] *** _twitch joined
[11:42] *** _twitch left
[11:42] <masak> I was unable to implement &fix in Perl 6, nor was I able to find a use for it afterwards ;)

[11:43] <tadzik> :)

[11:43] <mux> heh

[11:43] <tadzik> I assume the use could be something of this sort

[11:43] <tadzik> > take 5 fix (1:)

[11:43] <lambdabot2>   Couldn't match expected type `[a]'

[11:43] <lambdabot2>         against inferred type `(a1 -> a1...

[11:43] <tadzik> okay, I don't know haskell :P

[11:43] <mux> fix is not that easy to grok

[11:43] <tadzik> but that's like repeat, or is it?

[11:43] <mux> fix is a fixed-point combinator

[11:44] <mux> it allows you to write anonymous recursive functions

[11:44] <masak> sounds like Y

[11:44] <tadzik> mhm

[11:44] <mux> exactly like Y, yes

[11:44] <masak> the secret ingredient for recursion ;)

[11:44] <mux> > fix ((1:) . scanl (+) 1)

[11:44] <lambdabot2>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...

[11:44] * tadzik puts Learn Yourself Haskell for a Greater Good just after SICP on his list

[11:45] <mux> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 4

[11:45] <lambdabot2>   24

[11:45] <mux> (factorial using fix)

[11:46] <tadzik> I just found a nice article which uses Haskell for examples, and I really wish I could read that

[11:46] <tadzik> (http://twanvl.nl/blog/haskell/finding-rectangles)

[11:46] <donri> > take 5 $ fix (1:)

[11:46] <lambdabot2>   [1,1,1,1,1]

[11:53] *** benabik joined
[11:55] <masak> tadzik: reading that, I immediately think "dynamic programming".

[11:55] <masak> er, I mean, subproblem caching.

[11:55] *** _twitch joined
[11:56] <mux> yes please :-) I dearly hate the term "dynamic programming"

[11:56] <mux> one of the worse names I know of

[11:57] <tadzik> programming while running

[11:57] <jnthn> urgh

[11:57] *** SHODAN left
[11:57] <jnthn> https://gist.github.com/1250599

[11:58] * mux gets a mental picture of tadzik writing Haskell code while jumping

[11:58] <jnthn> tadzik, or anyone else with a Parrot to hand: can you try the above gist and let me know if it fails for you too?

[11:59] <tadzik> jnthn: sure

[11:59] <tadzik> jnthn: it says 8589934590

[12:00] <masak> 8589934590 here too.

[12:01] <jnthn> huh, here it says something odd about add_i_n_n :S

[12:01] <jnthn> OK, platform bug then.

[12:01] <mux> error:imcc:eval_ins: op 'add_i_n_n' not found

[12:02] <jnthn> mux: Aha!

[12:02] <mux> that's what I get here (I suddenly realized I have parrot installed too)

[12:02] <jnthn> mux: Platform?

[12:02] <mux> FreeBSD

[12:02] <mux> let me dig the parrot version

[12:02] <jnthn> mux: 32 or 64 bit?

[12:02] <mux> 32bits

[12:02] <jnthn> tadzik, masak: bleeding Parrot, or the NQP one?

[12:02] <tadzik> x64. He has bigger numbers

[12:02] <tadzik> jnthn: PARROT_REVISION

[12:02] <mux> rakudo-2011.07

[12:02] <jnthn> Yeah but I'm on 64-bit too.

[12:02] <mux> (tht may be a bit old)

[12:02] <tadzik> s/He/We/, I meandt

[12:02] <masak> oh, here it's parrot-3.3.0

[12:02] <cognominal> jnthn, how optimization mesh with evals or require?

[12:03] <masak> this is an x86_64

[12:03] <mux> does that help at all?

[12:03] <mux> This is Parrot version 3.6.0 built for i386-freebsd.

[12:03] <jnthn> mux: Well, it tells me it's not just a Windows issue :)

[12:04] <mux> alright :)

[12:04] <jnthn> cognominal: I probably need a bit more detail onw aht you want to know.

[12:04] <jnthn> *on what

[12:04] <jnthn> cognominal: require - well, it's runtime so anything you pull in then is going to be too late to, for example, inline.

[12:06] *** packetknife joined
[12:06] *** Trashlord joined
[12:06] <cognominal> my concern was one can dynamically create subs in eval. Maybe that can mess with the hypotheses used on optimization. Not sure though.

[12:07] * [Coke] yawns

[12:09] <masak> cognominal: nope.

[12:10] <masak> cognominal: evals are in a lexical scope below the compiled code.

[12:10] <masak> so it all works out fine.

[12:10] *** vlixes``` joined
[12:10] *** SHODAN joined
[12:11] <cognominal> nice

[12:11] <masak> in cases where it doesn't work out fine, there's wording in the spec to the effect of "if you're doing funky stuff with evals, and the optimizer wants to make assumptions about normality, the optimizer wins and you lose".

[12:11] <mux> lol

[12:13] <cognominal> if the user is warned everything is fair.

[12:14] *** slavik1 joined
[12:14] *** vlixes`` left
[12:15] <mux> I wish specs were written that way rather than the usual, terse style

[12:15] <mux> "You lose" is so much better than "undefined behaviour"

[12:17] <masak> of course, it's only true if your goal was defined behaviour :P

[12:17] <cognominal> undefined behavior has some bad C-ish after taste. One may get the false impression it is platform specific.

[12:17] <flussence> Two subs enter! One sub leaves!

[12:17] <jnthn> nom: sub foo(:$a) { }; foo(a => 3)

[12:17] <p6eval> nom 47d772:  ( no output )

[12:20] <benabik> I like the way my programming language theory professor described undefined behavior.  H;s -> H';s' (H = heap, s = statement) where s' is an unknown statement and H' is the state of "the computer is on fire"

[12:21] <mux> hahaha, nice :)

[12:22] <masak> reminds me of http://marc.info/?l=linux-kernel&m=102893054014512&w=2

[12:22] <im2ee> Where rakudo gets libs from?

[12:23] <im2ee> env PERL6LIB? :)

[12:24] *** mj41 left
[12:24] <mux> masak: awesome. makes me wish I was born at that time :-)

[12:25] <masak> me too.

[12:25] <masak> but the present isn't too bad either.

[12:26] * cognominal wishes somone will blog someday about settings and serialization

[12:26] <masak> there are certainly interesting things going on in CS and software engineering if you look.

[12:26] <tadzik> im2ee: yes

[12:26] <masak> cognominal: I blogged about settings a few weeks back.

[12:26] <jnthn> cognominal: I'll blog more about serialization once I really dig in to it.

[12:27] <jnthn> cognominal: All that exists right now is various bits of local sketching on it.

[12:27] <jnthn> cognominal: I've been looking more at the optimizer recently.

[12:27] <jnthn> Next post is probably about that. :)

[12:27] *** wamba joined
[12:27] <cognominal> jnthn++ masak++

[12:28] <[Coke]> hey, autounfudge works on niecza with limited prodding.

[12:28] <[Coke]> nifty.

[12:29] <cognominal> masak, your stuff about -n and -p was nice indeed.

[12:30] * [Coke] wonders why tools/test_summary.pl is hand-parsing TAP and not using the lovely module fo rit.

[12:31] <dalek> rakudo/optimizer: a3f69b6 | jnthn++ | src/ (2 files):

[12:31] <dalek> rakudo/optimizer: Don't lie about what types we can provide.

[12:31] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/a3f69b6800

[12:31] <dalek> rakudo/optimizer: 1f0a570 | jnthn++ | src/Perl6/Optimizer.pm:

[12:31] <dalek> rakudo/optimizer: Don't lose :named during inlining a call. Fixes majority of inliner-induced failures.

[12:31] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/1f0a570338

[12:31] *** replore joined
[12:32] *** replore left
[12:32] <masak> cognominal: thank you. I'm sure there's more to write about settings, and definitely more to write about serialization.

[12:32] <masak> I'm only starting to learn about serialization now that I'm working on macros in nom.

[12:33] <im2ee> "Default constructor only takes named arguments".

[12:33] <im2ee> What may be wrong? :)

[12:33] <jnthn> masak: Plus the world is going to change there in a little bit.

[12:33] <jnthn> im2ee: Are you on optimizer branch?

[12:33] <im2ee> jnthn, hmm, on nom.

[12:33] <tadzik> im2ee: what did you write?

[12:34] <jnthn> im2ee: Heh, curious conincidence. I just fixed a bug in the optimizer that caused a spectest to fail with that error. :)

[12:34] <tadzik> im2ee: autogenerated .new never take positional parameters, double check that

[12:36] *** mj41 joined
[12:36] <im2ee> jnthn:

[12:36] <im2ee> Default constructor only takes named arguments

[12:36] <im2ee>   in method new at src/gen/CORE.setting:514

[12:36] <im2ee>   in method <anon> at main.p6:10

[12:36] <im2ee>   in method BUILDALL at src/gen/CORE.setting:536

[12:36] <im2ee>   in method bless at src/gen/CORE.setting:526

[12:36] <im2ee>   in method new at src/gen/CORE.setting:511

[12:36] <im2ee>   in <anon> at main.p6:47

[12:36] <im2ee>   in <anon> at main.p6:1

[12:36] <jnthn> im2ee: How are you calling .new?

[12:37] <im2ee> it's main.p6:10, 47 and the next one is :1 :

[12:37] *** dakkar left
[12:37] <masak> im2ee: could you perhaps gist the code?

[12:37] <im2ee> ok :)

[12:37] <jnthn> For anybody who wants to check out how inlining helps so far, grab latest optimizer branch, then time each of these three:

[12:37] <jnthn> my $i = 0; while $i < 1000000 { $i = $i + 1 }; say $i

[12:38] <jnthn> my Int $i = 0; while $i < 1000000 { $i = $i + 1 }; say $i

[12:38] <jnthn> my int $i = 0; while $i < 1000000 { $i = $i + 1 }; say $i

[12:38] <tadzik> ooo

[12:38] <tadzik> 10.37s user 0.17s system 99% cpu 10.549 total

[12:38] *** bluescreen10 joined
[12:38] <tadzik> 6.51s user 0.17s system 99% cpu 6.704 total

[12:38] <im2ee> It's the code:

[12:38] <im2ee> http://pastebin.com/2tDvuVqe

[12:38] <tadzik> 1.81s user 0.19s system 99% cpu 1.997 total

[12:38] <tadzik> luvly

[12:39] <masak> :)

[12:39] <masak> im2ee: IO::Select.new( $!listener )

[12:39] <masak> won't work.

[12:39] <tadzik> im2ee: IO::Select.new( $!listener );

[12:39] <im2ee> Hmm, right...

[12:39] <masak> something like :$!listener might.

[12:39] <tadzik> oh, fastmasak

[12:39] <masak> tadzik: well, I knew the line number already :P

[12:39] <tadzik> ;)

[12:39] <im2ee> masak++ tadzik++ , thanks. :)

[12:40] <im2ee> Sorry for the problem. :)

[12:40] <tadzik> im2ee: plus, IO::Select has no listener attribute :)

[12:40] <masak> im2ee: don't apologise, just write wonderful code ;)

[12:40] <tadzik> just .new() it, and add filehandles using .add() then

[12:41] <tadzik> patches welcome

[12:41] <im2ee> masak, ok, thanks. :)

[12:41] <im2ee> thanks tadzik :)

[12:42] <jnthn> tadzik: There's an annoying code-gen issue at the moment, though

[12:42] <jnthn> my int $i = 0; while $i < 1000000 { $i = $i + 1; 1 }; say $i

[12:42] <jnthn> tadzik: Try ^; it should be even faster.

[12:43] <tadzik> 1.48s

[12:43] <tadzik> it's blocking on the startup time I suppose :)

[12:43] <im2ee> I work on the something like TCP simple server. I don't exactly know if it'll be useful, but .. who knows. :)

[12:44] <tadzik> im2ee: one could probably subclass it to write a specific tcp server

[12:44] <flussence> OTOH, perl -MMoose -wle with the same code took >1s on a cold start here :)

[12:44] <jnthn> tadzik: Right.

[12:44] <tadzik> :)

[12:44] <jnthn> tadzik: Well, you could always repeat them with 10 million. 

[12:44] <flussence> (and >0.2s on the second run, so it's not that far off...)

[12:45] <jnthn> ugh, want a sarnie but have no bread

[12:45] <tadzik> jnthn: it's then 11.13s vs 7.30s

[12:45] <jnthn> shop &

[12:45] <tadzik> bus &

[12:45] <jnthn> tadzik: ok, good to know.

[12:45] <masak> jnthn: feels silly that that should be even faster :/

[12:45] <jnthn> masak: What feels silly exactly?

[12:46] <masak> that a '1;' at the end makes it faster.

[12:46] <jnthn> masak: Yes, as I said, it's avoiding a code-gen bug.

[12:46] <masak> also, why do you keep writing 1e6 with so many zeroes?

[12:46] <masak> :P

[12:46] <jnthn> nom: say 1e6.WHAT

[12:46] <p6eval> nom 47d772: OUTPUT¬´Num()‚ê§¬ª

[12:46] <jnthn> That's why.

[12:46] <benabik> nom: 1e6.Int.say

[12:46] <p6eval> nom 47d772: OUTPUT¬´1000000‚ê§¬ª

[12:47] <jnthn> masak: Anyway, the code-gen bug will get fixed at some point, maybe even soonish.

[12:48] <im2ee> nom: sub m ( Regex $s ) { say $s }; m(/lol/);

[12:48] <p6eval> nom 47d772: OUTPUT¬´_block1019‚ê§¬ª

[12:48] <im2ee> how to print this regex? :)

[12:48] <jnthn> masak: PCT wasn't really built with native types in mind. Various bits of pmichaud++'s additions of late have helped that, but there's still the odd issue here and there.

[12:48] <masak> oki

[12:48] <jnthn> afk, shop

[12:50] <[Coke]> nom: /lol/.gist.gist

[12:50] <p6eval> nom 47d772:  ( no output )

[12:50] <[Coke]> nom: /lol/.gist.say

[12:50] <p6eval> nom 47d772: OUTPUT¬´_block1010‚ê§¬ª

[12:50] <[Coke]> nom: /lol/.perl.say

[12:50] <p6eval> nom 47d772: OUTPUT¬´_block1010‚ê§¬ª

[12:51] <[Coke]> knowing that a regex is a sub under the covers, I'm not sure how you'd get the original regexp back out.

[12:52] <flussence> doesn't the string of input code get saved somewhere?

[12:52] *** satyavvd left
[12:53] *** daniel-s left
[12:54] <masak> [Coke]: the regex engine simply needs to do '&regex-sub but role { method perl { $original-string } }'

[12:55] <[Coke]> masak - assuming it was constructed with a literal, sure. ;)

[12:56] <masak> hm :)

[12:56] *** [particle] joined
[12:56] <[Coke]> which I grant would cover this case.

[12:58] *** dakkar joined
[12:58] <masak> interesting -- regex objects share that property with quasis, that interpolated variables are stored as variables, not as values.

[12:59] <masak> with qq strings for example, it's the values.

[12:59] <[Coke]> "Synopsis", "pass","fail","todo","skip","plan","spec"

[12:59] <[Coke]> "total",      6270,   157,     3,  1477,  7907, 21768

[12:59] <[Coke]> Not sure why there are fails in the Niecza spec run since I just did a clean run last night.

[13:00] <[Coke]> (results of a slightly modified test-summary.pl run cribbed from rakudo's tools dir)

[13:00] <im2ee> " expected IO but got IO::Socket::INET instead"

[13:00] <im2ee> IO::S::INET isn't IO type? :)

[13:03] *** vlixes``` left
[13:04] *** daniel-s joined
[13:07] *** woosley left
[13:08] *** mj41 left
[13:08] *** kst` left
[13:08] *** daxim left
[13:08] *** orafu left
[13:08] *** mauke left
[13:08] *** szabgab left
[13:08] *** DarthGandalf left
[13:08] *** skangas left
[13:08] *** jlaire left
[13:08] *** mikemol left
[13:08] *** m6locks left
[13:08] *** Grimnir_ left
[13:09] *** mberends joined
[13:10] *** mj41 joined
[13:10] *** mauke joined
[13:10] *** kst` joined
[13:10] *** daxim joined
[13:10] *** orafu joined
[13:10] *** szabgab joined
[13:10] *** m6locks joined
[13:10] *** DarthGandalf joined
[13:10] *** skangas joined
[13:10] *** jlaire joined
[13:10] *** mikemol joined
[13:10] *** Grimnir_ joined
[13:11] *** sjn left
[13:11] *** sjn joined
[13:11] *** mauke left
[13:11] *** mauke joined
[13:20] *** alester_ left
[13:20] <mberends> [Coke]: great to see test_summary also working on Niecza! It does show one of the shortcomings of prove, that it counts 1477 skips as passes.

[13:24] *** pmurias joined
[13:26] *** GlitchMr joined
[13:26] <GlitchMr> "load_bytecode" couldn't find file 'CORE.setting.pbc'

[13:26] <GlitchMr> ...?

[13:27] *** dark_x joined
[13:29] <mberends> GlitchMr: that may be the result of a failed build. Try 'make realclean', then 'perl Configure.pl --gen-parrot', and then 'make' again.

[13:29] <GlitchMr> I used Windows build

[13:30] <GlitchMr> I installed Parrot-win32 and after that Rakudo on it...

[13:30] <GlitchMr> I haven't compiled it...

[13:30] <GlitchMr> Weird...

[13:31] <m6locks> something with them directory settings

[13:31] <mberends> yes. I don't have a Windows system to compare with you :(

[13:32] <GlitchMr> Maybe I did something wrong

[13:32] <GlitchMr> Maybe I've downloaded wrong file

[13:33] <GlitchMr> C:\rakudo\bin>perl6.exe

[13:33] <GlitchMr> > say "Hello, world :)."

[13:33] <GlitchMr> Hello, world :).

[13:33] <lambdabot2>   Not in scope: `say'

[13:33] <GlitchMr> OK, it seems to work...

[13:34] <GlitchMr> I accidentally activated bot lol

[13:35] <mberends> :) at least your home system is saying Hello

[13:35] <GlitchMr> > my $a

[13:35] <GlitchMr> Any()

[13:35] <lambdabot2>   Not in scope: `my'

[13:35] <GlitchMr> ...?

[13:36] <GlitchMr> Any()...?

[13:36] <GlitchMr> I know it doesn't have yet value, but Any() is pretty weird...

[13:36] <GlitchMr> > 2+2

[13:36] <lambdabot2>   4

[13:36] <GlitchMr> At least that...

[13:37] *** jimmy1980 joined
[13:37] <mberends> GlitchMr: instead of > try rakudo: to talk to out Perl 6 bot

[13:37] <GlitchMr> OK :).

[13:37] *** blue_ joined
[13:37] <mberends> rakudo: say "Hello GlitchMr"

[13:37] <p6eval> rakudo 47d772: OUTPUT¬´Hello GlitchMr‚ê§¬ª

[13:38] <GlitchMr> I see null byte...

[13:38] <mberends> it's the newline that comes from say

[13:38] <GlitchMr> Oh, I see.

[13:38] <m6locks> so, perl6 package for ubuntu? anyone using ubuntu here?

[13:38] <GlitchMr> Makes sense.

[13:39] <mberends> m6locks: Ubuntu yes, but perl6 compiled from source

[13:39] <GlitchMr> rakudo: 1 => 2 => 3 => 4 => 5

[13:39] <p6eval> rakudo 47d772:  ( no output )

[13:39] <m6locks> mberends: aye

[13:39] <GlitchMr> rakudo: use Data::Dumper; print Dump 1 => 2 => 3 => 4 => 5

[13:39] <p6eval> rakudo 47d772: OUTPUT¬´===SORRY!===‚ê§Could not find Data::Dumper in any of: lib, /home/p6eval/.perl6/lib, /home/p6eval/nom-inst2/lib/parrot/3.8.0-devel/languages/perl6/lib, .‚ê§¬ª

[13:39] <flussence> Debian has rakudo packages, you can use those

[13:40] <mberends> no Data::Dumper in Perl 6, there is a .perl method to print

[13:40] <m6locks> flussence: got url?

[13:40] <GlitchMr> mberends, more details?

[13:40] <GlitchMr> How can I use it?

[13:40] <mberends> rakudo: say ( 1 => 2 => 3 => 4 => 5).perl

[13:40] <p6eval> rakudo 47d772: OUTPUT¬´1 => 2 => 3 => 4 => 5‚ê§¬ª

[13:40] <GlitchMr> Makes sense

[13:41] <GlitchMr> rakudo: print { 1 => 2, 3 => 4, 5 => 6) . perl

[13:41] <p6eval> rakudo 47d772: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 1‚ê§¬ª

[13:41] <GlitchMr> rakudo: print { 1 => 2, 3 => 4, 5 => 6}.perl

[13:41] <p6eval> rakudo 47d772: OUTPUT¬´{"1" => 2, "3" => 4, "5" => 6}¬ª

[13:41] <GlitchMr> rakudo: print { 1 => 2, 3 => 4, 5 => 6 => 7}.perl

[13:41] <p6eval> rakudo 47d772: OUTPUT¬´{"1" => 2, "3" => 4, "5" => 6 => 7}¬ª

[13:42] <flussence> m6locks: http://packages.debian.org/sid/rakudo

[13:42] <m6locks> thx

[13:44] <m6locks> oh btw, adding that link to the rakudo.org page would be nice

[13:44] <GlitchMr> rakudo: $_ = 'hEllo'; s/E/e/; print

[13:44] <p6eval> rakudo 47d772:  ( no output )

[13:44] <m6locks> it's not there, can only fedora, suse, freebsd and what have you, people are asking about it in the comments section

[13:45] <m6locks> +find

[13:45] <flussence> sounds like the majority are fine, maybe you should tell ubuntu to fix it :)

[13:46] <m6locks> fix what?

[13:46] <GlitchMr> rakudo: my $hash = 'flexibility'=>'of', 'arrays', 'like PHP', 3, 'does it exist?' => '?'; print {$hash}.perl

[13:46] <p6eval> rakudo 47d772: OUTPUT¬´_block1011¬ª

[13:47] <flussence> lack of perl 6 packages :)

[13:47] <m6locks> well then again, I can post the link to the comments, hope webmaster sees it and adds it to the list

[13:47] <GlitchMr> Probably not.

[13:47] <m6locks> but I can try!

[13:47] <GlitchMr> Whatever, mixing arrays and hashes would be strange anyway...

[13:48] <flussence> rakudo: say (a=>1, 2, 'b').perl

[13:48] <GlitchMr> It never helped me, it's actually annoying in PHP...

[13:48] <p6eval> rakudo 47d772: OUTPUT¬´("a" => 1, 2, "b")‚ê§¬ª

[13:48] <flussence> rakudo: say (a=>1, 2, 'b')<a>.perl

[13:48] <p6eval> rakudo 47d772: OUTPUT¬´Method 'at_key' not found for invocant of class 'Parcel'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1016‚ê§  in block <anon> at /tmp/zdNogHz3pi:1‚ê§  in <anon> at /tmp/zdNogHz3pi:1‚ê§‚ê§¬ª

[13:48] *** alvis left
[13:51] <GlitchMr> I guess I cannot use modules from Perl 5 in Perl 6...

[13:52] <blue_> looking 4 nitro???

[13:55] <dalek> rakudo/optimizer: 1cb3f8d | jnthn++ | src/core/Int.pm:

[13:55] <dalek> rakudo/optimizer: A few more native int operators. If anybody fancies doing the num ones, dive in!

[13:55] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/1cb3f8dc7e

[13:58] <jnthn> GlitchMr: Not really at the moment, though there is work going on to make that possible.

[13:59] <mberends> jnthn: I may dive in after $work :)

[14:01] <jnthn> mberends: yay :)

[14:13] *** wolfman2000 left
[14:15] *** leprevost left
[14:16] *** donri left
[14:17] *** jimmy1980 left
[14:18] *** kaleem left
[14:18] *** shinobicl joined
[14:18] *** _twitch left
[14:19] *** cognominal_ joined
[14:20] *** blue_ left
[14:21] *** cognominal left
[14:23] *** wtw left
[14:24] *** koban` left
[14:36] *** sftp joined
[14:40] *** SHODAN left
[14:49] *** kmwallio joined
[14:52] * masak decommutes

[14:52] *** masak left
[14:54] <sorear> good * #perl6

[14:55] <sorear> mauke: Hi!

[14:55] <sorear> @part #perl6

[14:55] <lambdabot2> Not enough privileges

[14:55] *** ChanServ sets mode: +o sorear

[14:56] *** sorear sets mode: +q lambdabot2!*@*

[14:56] *** sorear sets mode: -o sorear

[14:57] <daxim> what was that good for now?

[14:57] <dalek> roast: a242d03 | jnthn++ | S06-signature/slurpy-params.t:

[14:57] <dalek> roast: Remove tests that relied on old named to positional behavior; re-fudge for Rakudo.

[14:57] <dalek> roast: review: https://github.com/perl6/roast/commit/a242d03c0c

[14:57] *** alim left
[14:57] <mberends> good * sorear

[14:57] *** [particle]1 joined
[14:58] <sorear> daxim: lambdabots are not welcome here.  That decision was made long before my tenure and will only be reversed by consensus

[14:58] *** [particle] left
[15:02] <dalek> rakudo/nom: 38f1a2c | jnthn++ | src/ (2 files):

[15:02] <dalek> rakudo/nom: Implement 'is required' on parameters.

[15:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38f1a2c6c3

[15:02] <dalek> rakudo/nom: 9da03d2 | jnthn++ | t/spectest.data:

[15:02] <dalek> rakudo/nom: Run S06-signature/slurpy-params.t.

[15:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9da03d2616

[15:02] <dalek> rakudo/nom: 8ba6979 | jnthn++ | src/core/Range.pm:

[15:02] <dalek> rakudo/nom: Tiny optimization to range iteration.

[15:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ba6979c1d

[15:07] *** mberends left
[15:08] *** molaf joined
[15:12] <benabik> What is lambdabot?

[15:13] <benabik> aloha: lambdabot?

[15:14] *** pmurias left
[15:21] <sorear> benabik: #haskell bot.  Was kickbanned from here years ago, some clueless person brought it back under a different name.

[15:22] <dalek> roast: 67a09e1 | jnthn++ | S12-methods/parallel-dispatch.t:

[15:22] <dalek> roast: Correct private method call usage in parallel dispatch tests.

[15:22] <dalek> roast: review: https://github.com/perl6/roast/commit/67a09e1804

[15:22] <sorear> very spammy, responds to every line starting @ or >

[15:22] <sorear> and with that I leave

[15:22] <benabik> sorear: thanks

[15:22] <benabik> and buy

[15:22] <benabik> *bye

[15:23] *** thou joined
[15:23] <dalek> rakudo/nom: 1eeac15 | jnthn++ | src/core/Mu.pm:

[15:23] <dalek> rakudo/nom: Fix error reporting for non-existent private methods.

[15:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1eeac15d52

[15:23] <dalek> rakudo/nom: 1e95c0a | jnthn++ | src/Perl6/Actions.pm:

[15:23] <dalek> rakudo/nom: Catch illegally unqualified private method calls at compile time.

[15:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e95c0ad5b

[15:26] <jnthn> That's 2 more RTs down. :)

[15:26] *** kaleem joined
[15:29] *** kaare_ joined
[15:33] *** thou left
[15:37] *** alpha-- joined
[15:37] *** alpha-- left
[15:37] *** alpha-- joined
[15:38] *** packetknife left
[15:40] <jnthn> nom: 1.5 lcm 1.5

[15:40] <p6eval> nom 47d772: OUTPUT¬´(timeout)maximum recursion depth exceeded‚ê§¬ª

[15:41] <flussence> interesting that it gets both a timeout and an error message...

[15:41] <jnthn> I guess lcm and gcd make no sense on non-integral values?

[15:42] <kmwallio> is there a way to capture the output of a command ran using run() ?

[15:44] <jnthn> kmwallio: Don't think run does that; maybe use qx{the command} instead.

[15:45] <kmwallio> cool thanks

[15:45] <kmwallio> is there any place to easily look things like that up?

[15:46] *** preflex joined
[15:50] <jnthn> kmwallio: Not sure where to point you at in this case...I don't think the book covers these.

[15:50] <im2ee> IO::S::INET isn't IO type? :)

[15:51] <im2ee> IO::Socket::INET isn't IO type?*

[15:51] <dalek> rakudo/nom: d104b94 | jnthn++ | src/core/Numeric.pm:

[15:51] <dalek> rakudo/nom: Fix infinite recursion with lcm/gcd. Resolves the [lcm] 1..3 issue.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d104b94fd5

[15:51] <jnthn> Don't think it inherits from IO, if that's what you mean.

[15:52] <im2ee> I got error:

[15:52] <im2ee> " expected IO but got IO::Socket::INET instead"

[15:52] *** alpha-- left
[15:53] <im2ee> In IO::Select.add()

[15:53] <jnthn> Ah, hm

[15:53] <jnthn> Maybe ask the author of IO::Select :)

[15:55] <im2ee> tadzik is afk :)

[15:55] <im2ee> So, i'm waiting. :)

[15:57] *** lambdabot2 left
[15:59] *** espadrine left
[16:00] <jnthn> nom: package Foo { }; class Foo { }

[16:00] <p6eval> nom 1e95c0:  ( no output )

[16:01] <bbkr_> nom: package Foo { }; class Foo::Bar { }; say "alive";

[16:01] <p6eval> nom 1e95c0: OUTPUT¬´alive‚ê§¬ª

[16:01] <jnthn> nom: module Foo { }; class Foo { }

[16:01] <p6eval> nom 1e95c0: OUTPUT¬´===SORRY!===‚ê§Illegal redeclaration of class 'Foo' at line 1, near "{ }"‚ê§¬ª

[16:02] <jnthn> Good

[16:02] <jnthn> We're one ticket being closed away from being back down to 850.

[16:05] <moritz> \o

[16:06] <jnthn> moritz! \o/

[16:06] *** Holy_Cow joined
[16:07] *** Holy_Cow left
[16:08] *** risou_awy is now known as risou

[16:11] *** MayDaniel joined
[16:14] <jnthn> moritz: Does your bitwise buf/str work let us close this one: https://rt.perl.org/rt3/Ticket/Display.html?id=67852

[16:15] <moritz> jnthn: it has always been closable in nom since the creation of the bitwise string ops...

[16:16] <moritz> jnthn: it's just that the typical parrot-string-vs-perl6-Str test is .trans, which is NYI in nom

[16:16] <dalek> rakudo/nom: def94fa | jnthn++ | src/Perl6/Grammar.pm:

[16:16] <dalek> rakudo/nom: Add error from STD for using $0 in a prameter list.

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/def94fa7f5

[16:17] *** mberends joined
[16:17] <GlitchMr> rakudo; multi sub postfix:<!> is equiv:<++> ( Int $x ) { return [*] 1 .. $x } say 3!

[16:17] <GlitchMr> rakudo: multi sub postfix:<!> is equiv:<++> ( Int $x ) { return [*] 1 .. $x } say 3!

[16:17] <p6eval> rakudo 1e95c0: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "( Int $x )"‚ê§¬ª

[16:17] <moritz> jnthn: about the int ops, why does it need a box?

[16:18] <moritz> GlitchMr: custom ops are not yet done in rakudo/nom

[16:18] <GlitchMr> Oh, I see...

[16:18] <moritz> GlitchMr: and we never did 'is equiv', though niecza does that

[16:18] <GlitchMr> niecza: multi sub postfix:<!> is equiv:<++> ( Int $x ) { return [*] 1 .. $x } say 3!

[16:18] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unhandled trait equiv:<++> for this context at /tmp/zxVJ7P6sal line 1:‚ê§------> [32mmulti sub postfix:<!> is equiv:<++> [33m‚èè[31m( Int $x ) { return [*] 1 .. $x } say 3![0m‚ê§‚ê§Strange text after block (missing comma, semico‚Ä¶

[16:19] <moritz> jnthn: ah, never mind, finally I understood

[16:19] <GlitchMr> Makes sense...

[16:19] <moritz> GlitchMr: is equiv(&postfix:<++>)  iirc

[16:20] <GlitchMr> niecza: multi sub postfix:<!> is equiv(&postfix:<++>) ( Int $x ) { return [*] 1 .. $x } say 3!

[16:20] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Strange text after block (missing comma, semicolon, comment marker?) at /tmp/kyL3Dvbt02 line 1:‚ê§------> [32m:<++>) ( Int $x ) { return [*] 1 .. $x }[33m‚èè[31m say 3![0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[16:20] <moritz> niecza: multi sub postfix:<!> is equiv(&postfix:<++>) { [*] 1.. $^X }; say 5!

[16:20] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unsupported use of $^X variable; in Perl 6 please use $*EXECUTABLE_NAME at /tmp/apX29CxZ6e line 1:‚ê§------> [32m> is equiv(&postfix:<++>) { [*] 1.. $^X [33m‚èè[31m}; say 5![0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[16:20] <moritz> niecza: multi sub postfix:<!> is equiv(&postfix:<++>) { [*] 1.. $^a }; say 5!

[16:20] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´120‚ê§¬ª

[16:20] <GlitchMr> Yay

[16:20] <moritz> niecza: multi sub postfix:<!>(Int $a) is equiv(&postfix:<++>) { [*] 1.. $a }; say 5!

[16:20] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´120‚ê§¬ª

[16:21] <moritz> GlitchMr: seems like the signature needs to come before the trait

[16:21] <GlitchMr> niecza: multi sub postfix:<!>(Int $a) is equiv(&postfix:<++>) { [*] 1.. $a }; say 1337!

[16:21] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´8874663836657679616624106464181330095477201209934728179488259618265583472082422451756532829820227220586694812398717056396577963484185843624972811566695752967507809547583275355249722514792503207256105871660473160528528660309295831784330274184810480309094806‚Ä¶

[16:21] <GlitchMr> ... nice 4 seconds pause

[16:21] <GlitchMr> niecza: multi sub postfix:<!>(Int $a) is equiv(&postfix:<++>) { [*] 1.. $a }; say 133713371337133713371337!

[16:21] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´(timeout)¬ª

[16:21] <GlitchMr> (timeout)... I see...

[16:21] <moritz> GlitchMr: 2.5 of which are niecza startup time

[16:22] <GlitchMr> Makes sense...

[16:26] *** thou joined
[16:31] *** kaleem left
[16:35] *** mj41 left
[16:36] *** kaleem joined
[16:36] <dalek> roast: 41c9d28 | jnthn++ | S06-advanced/callsame.t:

[16:36] <dalek> roast: Fix test file that assumed Int ~~ Num, and unfudge the test Rakudo rightly didn't pass before it was fixed.

[16:36] <dalek> roast: review: https://github.com/perl6/roast/commit/41c9d28aeb

[16:38] *** MayDaniel left
[16:43] *** Holy_Cow joined
[16:43] <jnthn> OK, another bunch of tickets marked testneeded :)

[16:45] *** Holy_Cow left
[16:48] <moritz> jnthn: it seems that adding num operator multis break tests with Inf, -Inf and NaN

[16:48] <moritz> jnthn: (optimizer branch)

[16:48] <moritz> multi prefix:<->(num $a) {

[16:48] <moritz>     nqp::want(

[16:48] <moritz>         nqp::p6box_n(nqp::neg_n($a)),

[16:48] <moritz>         'Nn', nqp::neg_n($a),

[16:48] <moritz>     );

[16:48] <moritz> }

[16:49] <moritz> $ ./perl6 -e 'say -Inf'

[16:49] <moritz> ===SORRY!===

[16:49] <moritz> error:imcc:undefined identifier 'Inf'

[16:49] <moritz> it generates

[16:49] <moritz>     set $N100, Inf

[16:49] <moritz>     neg $N101, $N100

[16:51] <jnthn> moritz: Interesting.

[16:51] <jnthn> moritz: Maybe Inf and NaN need to return PAST::Wants.

[16:52] <moritz> jnthn: or maybe the num serialization of Inf needs to be fixed

[16:52] <jnthn> moritz: Yes, that's where you'd add it.

[16:53] <felher> I'd like to get a key-grep method for Hash and Array. So one can write [email@hidden.address] { $_ % 2 }' instead of [email@hidden.address] { @array[$_] % 2 }' or [email@hidden.address] { $^k if $^v % 2 }'. I know thats doesn't help much, it's easy to implement though. I have no idea if it should get specced or not, but as im just hear to learn, i would really like to hear your objections about it. :)

[16:54] *** GlitchMr left
[16:55] <moritz> felher: so test the value, but return the key?

[16:55] <felher> moritz: yes

[16:55] <jnthn> moritz: Do you think the tests under "# test postcircumfix parallel dispatch" in parallel-dispatch.t are invalid now?

[16:56] <jnthn> moritz: They seem to assume that hyper dispatch doesn't descend into data structures - apart from it now does.

[16:57] <moritz> jnthn: yes, bogus

[16:57] <jnthn> moritz: Feel free to push the num native ops to optimizer even if it breaks tests, btw. It's OK to have a little mess in there for now.

[16:57] <jnthn> moritz: Thanks, just wanted a second opinion. :)

[16:57] <moritz> jnthn: I wonder if they can be fixed

[16:57] <jnthn> I'm just spectesting a fix for the other reason we fail that file

[16:57] <moritz> jnthn: do hypers descend into pairs?

[16:57] <jnthn> moritz: I'm not entirely sure how.

[16:57] <jnthn> moritz: Not sure they do.

[16:58] <moritz> nom: (a => 1)>>.say

[16:58] <p6eval> nom 1e95c0: OUTPUT¬´Method 'at_key' not found for invocant of class 'Pair'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1020‚ê§  in method reify at src/gen/CORE.setting:3744‚ê§  in method reify at src/gen/CORE.setting:3649‚ê§  in method gimme at src/gen/CORE.setting:3986‚ê§  in method‚Ä¶

[16:58] <moritz> nom: (a => 1, b => 2)>>.say

[16:58] <p6eval> nom def94f: OUTPUT¬´"a" => 1‚ê§"b" => 2‚ê§¬ª

[16:58] <moritz> looks like not

[16:58] <moritz> so (a => 1, a => 2)>>.<a> would be a valid test

[17:01] <jnthn> nom: say (a => 1, a => 2)>>.<a>

[17:01] <p6eval> nom def94f: OUTPUT¬´Method 'at_key' not found for invocant of class 'Pair'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1020‚ê§  in method reify at src/gen/CORE.setting:3744‚ê§  in method reify at src/gen/CORE.setting:3649‚ê§  in method reify at src/gen/CORE.setting:3649‚ê§  in method‚Ä¶

[17:01] <moritz> hm

[17:01] <jnthn> nom: say (a => 1).<a>

[17:01] <p6eval> nom def94f: OUTPUT¬´Method 'at_key' not found for invocant of class 'Pair'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:1020‚ê§  in block <anon> at /tmp/BsLMGC1u03:1‚ê§  in <anon> at /tmp/BsLMGC1u03:1‚ê§‚ê§¬ª

[17:01] <moritz> well, that needs to be fixed :-)

[17:02] <moritz> felher: I like the suggestion, and i had similar ideas myself; what I lack so far is an idea how to generalize it well

[17:02] <moritz> felher: it would make sense for .grep, .map and .first at least

[17:02] <dalek> rakudo/nom: 71d1557 | jnthn++ | src/Perl6/Actions.pm:

[17:02] <dalek> rakudo/nom: Fix .+$foo() style dispatches (many candidates plus indirect name in combination).

[17:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71d15575c3

[17:04] <moritz> hm, not sure about map

[17:04] *** Chillance joined
[17:04] <moritz> map would just always return .keys

[17:04] <felher> moritz: Yeah, i used it for grep and first so far.

[17:05] *** dakkar left
[17:06] <dalek> roast: 185b9a1 | jnthn++ | S12-methods/parallel-dispatch.t:

[17:06] <dalek> roast: Remove some bogus tests and add a replacement one suggested by moritz++.

[17:06] <dalek> roast: review: https://github.com/perl6/roast/commit/185b9a1f05

[17:06] <moritz> felher: https://gist.github.com/1251289

[17:08] *** localhost left
[17:09] *** localhost joined
[17:10] <dalek> rakudo/nom: 9e7a62e | jnthn++ | src/core/Enum.pm:

[17:10] <dalek> rakudo/nom: Add Enum.at_key.

[17:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9e7a62ef57

[17:10] <dalek> rakudo/nom: db05a44 | jnthn++ | t/spectest.data:

[17:10] <dalek> rakudo/nom: Run S12-methods/parallel-dispatch.t.

[17:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/db05a44a31

[17:11] <felher> moritz: nice. :)

[17:11] <dalek> roast: 448e286 | jnthn++ | S12-methods/calling_sets.t:

[17:11] <dalek> roast: Unfudge a few tests for Rakudo.

[17:11] <dalek> roast: review: https://github.com/perl6/roast/commit/448e2861e6

[17:11] <benabik> Why is it at_key and at_pos instead of AT_KEY/AT_POS or even postfix:[]/{} ?

[17:13] *** masak joined
[17:13] <masak> bom tarde, #p6

[17:13] <jnthn> .oO( set up us the bom )

[17:15] <masak> jnthn: yes -- lcd and gcm only make sense for integral types, since it hinges on the concept of divisibility.

[17:17] * cognominal_ heads up to nqp and is flabbergasted by the number of folders:  NQPQ, QAST, QRegex. What is all this new (or not so new?) Q stuff.

[17:17] <masak> jnthn: should work fine on Gaussian integers, though I haven't tried :)

[17:17] <jnthn> masak: :P

[17:17] <jnthn> nom: say [lcm] 1..3

[17:17] <p6eval> nom def94f: OUTPUT¬´6‚ê§¬ª

[17:17] <jnthn> masak: Fixed that at least :)

[17:17] <masak> cognominal_: Perl 6 has been bought wholesale by the Chinese social network, QQ.

[17:18] <PerlJam> cognominal_: Q .... you know .... like from the Continuum  

[17:18] <masak> cognominal_: by popular demand, we're changing name from "Perl 6" to "Qerl".

[17:18] <PerlJam> heh

[17:18] <jnthn> cognominal_: People keep complaining about the name "Perl 6", and it's part of a highly secretive campaign to...dammit, masak beat me!

[17:18] <masak> \o/

[17:19] <TimToady> you sure we're not in the James Bond universe instead?

[17:19] <masak> dang, missed that one!

[17:19] <masak> "and who are you, R?" :)

[17:19] <cognominal_> let me tell you that Q is pronouced like cul, that is "ass" in French. :)

[17:19] <PerlJam> TimToady: that's probably a better conceptual fit.

[17:20] <jnthn> cognominal_: I look forward to talking about this exciting new technology at FPW next year :P

[17:20] <PerlJam> TimToady: except I want to know who's M ?

[17:20] <masak> cognominal_: that's between you and the French! :P

[17:20] *** daniel-s left
[17:20] <masak> PerlJam: Gloria.

[17:20] *** mj41 joined
[17:20] <TimToady> SWMBO indeed

[17:21] <cognominal_> this year was the year of acmeism in the french OSDC.

[17:21] <masak> TimToady: :)

[17:21] <PerlJam> cognominal_: that makes me think ingy might change his name again  :)

[17:21] <cognominal_> anyway, that was at the first french OSDC that acmeism was unleashed on a unsusspecting world in the fiest place.

[17:22] <cognominal_> *first

[17:24] <felher> moritz: i would like to have such a method builtin nevertheless. I needed it quite a few times now. I like to discuss it more but my connection is just dying each and every 10 seconds or so. So i'm off 'till i'm at home. Thnx for your opionion :)

[17:25] *** dark_x left
[17:26] <cognominal_> more seriously, why almost every name has Q counterpart and what is the difference between stuff with a Q and without it?

[17:27] *** sayu joined
[17:28] <jnthn> cognominal_: It's the beginnings of a set of refactors to code-gen and similar, plus a new regex engine.

[17:28] <cognominal_> ok

[17:32] *** thou left
[17:33] *** risou left
[17:33] *** risou_awy joined
[17:33] *** risou_awy is now known as risou

[17:34] * tadzik is back

[17:34] *** risou is now known as risou_awy

[17:34] *** risou_awy is now known as risou

[17:36] *** risou left
[17:36] *** risou_awy joined
[17:36] *** risou_awy left
[17:36] *** risou joined
[17:38] <ingy> o/

[17:39] <sjohnson> hi

[17:39] <dalek> rakudo/optimizer: ebf115c | moritz++ | src/core/Num.pm:

[17:39] <dalek> rakudo/optimizer: prefix:<->(num). Wracks havoc of tests becase -Inf now generates invalid PIR (set $N100, Inf)

[17:39] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/ebf115ced9

[17:40] * ingy buggers off to write yaml.pgx

[17:40] <ingy> I'll need a <INDENT> <DEDENT> magics

[17:41] <ingy> seems like a parser subclass to me

[17:42] <jnthn> moritz: Will look a bit after dinner.

[17:42] <jnthn> moritz: Unless you beat me.

[17:42] <jnthn> er, beat me to looking at it, I mean :)

[17:45] <moritz> ingy: try <ARTHURDENT> :-)

[17:46] <benabik> moritz: I've been calling that rule <DENTARTHURDENT>.  Is that first DENT unneeded?  ;-)

[17:48] <moritz> benabik: if oyu call them <ARTHURDENT> and <ARTHURUNDENT>, the first DENT is indeed superfluous :-)

[17:48] <moritz> *you

[17:50] <tadzik> huh

[17:50] <tadzik> "Uninstantiable representation does not support attribute storage"

[17:50] *** kaleem left
[17:50] <tadzik> I suppose nqp::getattr fails for IO::Socket because it's a role, not a class

[17:50] <moritz> correct

[17:50] <moritz> you need to supply the class into which the role was composed

[17:51] <tadzik> but wait, I don't even pass IO::Socket in there

[17:51] <moritz> what do you pass in there?

[17:51] <tadzik> my subset Handle of Any where any(IO, IO::Socket);

[17:51] <tadzik> still, I pass an ordinary IO

[17:51] <moritz> what does your call look like?

[17:52] <moritz> to nqp::getattr, that is

[17:52] <ingy> moritz: what about <CDENT> ?

[17:52] <tadzik> my $fh := nqp::getattr(pir::perl6_decontainerize__PP($handle), IO, '$!PIO');

[17:52] <moritz> and what does $handle.WHAT say?

[17:52] <tadzik> oh, IO

[17:53] <tadzik> I have IO in there, that should probably be what the $handle is

[17:53] <tadzik> I bet it'll say Handle...

[17:53] <tadzik> it doesn't say anything, as if it was a compile-time error or so

[17:54] <jnthn> nom: subset Money of Int; class C { has Money $.x }; C.new

[17:54] <p6eval> nom def94f:  ( no output )

[17:54] <tadzik> I'm on optimizer btw

[17:54] <jnthn> hm, not that.

[17:54] <moritz> hmmm

[17:54] <moritz> nom: say (1e0 cmp 1e0).WHAT

[17:54] <p6eval> nom def94f: OUTPUT¬´Num()‚ê§¬ª

[17:54] <moritz> shouldn't that be an Int?

[17:55] <tadzik> but I get 1..4 printed before

[17:55] <jnthn> Yes.

[17:56] <colomon> moritz: it should be an enum, really

[17:56] <tadzik> nom: say Int.WHAT.WHAT

[17:56] <p6eval> nom def94f: OUTPUT¬´Int()‚ê§¬ª

[17:57] <tadzik> is it safe to pass $foo.WHAT as a second arg of nqp::getattr?

[17:57] <moritz> tadzik: in first approximation, yes

[17:57] <tadzik> well, it still fails before that somehow

[17:57] <moritz> tadzik: it fails horribly if somebody subclasses the handle

[17:57] <tadzik> right

[17:58] <tadzik> I'd be glad if classes having $!PIO shared some common interface

[18:00] <masak> make one :)

[18:02] <tadzik> I'm not even asking about the spec stuff anymore, or Larry will shout at me again. Btw, I invented a new BUILDALL abuse to get the "do stuff after the object is done" :P

[18:04] *** sayu left
[18:11] <diakopter> Qerl makes me think of squirrel

[18:16] <TimToady> .oO( http://irclog.perlgeek.de/perl6/2011-02-28#i_3341430 )

[18:17] *** bluescreen10 left
[18:18] *** donri joined
[18:18] <tadzik> oh, maybe I did it subconsciously, I don't remember that sentence of yours

[18:18] <tadzik> maybe because that was half a year ago

[18:19] <dalek> book: be3bf3b | Ivan64++ | src/basics.pod:

[18:19] <dalek> book: Clarify that the input data is stored in a file called "scores"

[18:19] <dalek> book: review: https://github.com/perl6/book/commit/be3bf3bfe4

[18:19] <dalek> book: ef3e150 | Ivan64++ | src/operators.pod:

[18:19] <dalek> book: I think %matches was meant as opposed to %games.

[18:19] <dalek> book: review: https://github.com/perl6/book/commit/ef3e1506b4

[18:19] <dalek> book: 61bc204 | moritz++ | src/ (2 files):

[18:19] <dalek> book: Merge pull request #59 from Ivan64/master

[18:19] <dalek> book: 

[18:19] <dalek> book: Two minor corrections

[18:19] <dalek> book: review: https://github.com/perl6/book/commit/61bc204b28

[18:22] *** daxim left
[18:27] *** espadrine joined
[18:30] * [Coke] retro-convos, "Moose and qerl".

[18:30] <[Coke]> you have to say it with a bad russian accent.

[18:30] * [Coke] reserves that for a talk title!

[18:31] *** MayDaniel joined
[18:31] <PerlJam> But how do you pronounce "qerl"?

[18:33] <tadzik> k≈Çerl

[18:33] <moritz> PerlJam: as you write it :-)

[18:34] <[Coke]> kwerl.

[18:38] *** c1sung left
[18:39] *** risou is now known as risou_awy

[18:42] *** c1sung joined
[18:44] *** mj41 left
[18:49] <TimToady> mauke: if you're going to hang out here comfortably, you ought to at least struggle feebly to figure out why C's approach to precedence might be considered suboptimal...  :)

[18:49] *** mj41 joined
[18:51] <mauke> TimToady: in general or just the ,/?: bit?

[18:51] *** wamba left
[18:52] <TimToady> both :)

[18:52] <mauke> then I don't see the problem

[18:52] <TimToady> but certainly ?: is the proximate cause

[18:52] <TimToady> C is different from Perl two ways at least

[18:52] *** flussence_ joined
[18:53] <TimToady> first, it doesn't allow assignment to ?:

[18:53] <mauke> (C++ does; not a fundamental difference)

[18:53] <TimToady> what should a ? b = c : b = d do?

[18:53] <PerlJam> not something stupid :)

[18:53] <mauke> oh, I think that's where C and C++ differ

[18:54] <mauke> if you follow strict precedence, you get (a ? b = c : b) = d

[18:54] <mauke> and IIRC that's exactly what perl5 does

[18:54] <TimToady> which, you'll note, is an inconsistency

[18:54] <mauke> NAK

[18:54] <TimToady> between the "then" part and the "else" part

[18:55] *** flussence left
[18:55] <TimToady> people try to use it as a small if/then/else and get confused

[18:55] <mauke> they do?

[18:55] <TimToady> what should a ? b, c : d, e do?

[18:55] <mauke> (a ? b, c : d), e

[18:56] <TimToady> that's not what the typical user thinks

[18:56] <mauke> [citation needed]

[18:56] *** envi left
[18:56] <TimToady> and we're trying to keep Perl from silently making mysterious mistakes that confuse users

[18:56] *** flussence_ is now known as flussence

[18:56] <mauke> this feels like the wrong way to do it, though

[18:56] <TimToady> the use cases for allowing low-precedence ops inside ?: are all very fiddly

[18:57] <mauke> what's missing is that the "else" part has no explicit end marker, unlike the "then" part

[18:57] <TimToady> almost obfuscational

[18:57] <dalek> rakudo/optimizer: b95d441 | moritz++ | src/core/Num.pm:

[18:57] <dalek> rakudo/optimizer: more num ops; correct return value of cmp

[18:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/b95d441c0b

[18:57] <dalek> rakudo/optimizer: 0b30152 | moritz++ | src/core/Num.pm:

[18:57] <dalek> rakudo/optimizer: more num ops

[18:57] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/0b30152702

[18:57] <mauke> alternatively you could make ?: have different left-precedence and right-precedence

[18:57] <TimToady> sure, but most people don't actually think of it that way

[18:58] <TimToady> the expense of enforcing a couple of parens is well worth all the newbie errors it catches

[18:58] <TimToady> and the expense of making a few people upset who think they're implied :)

[18:59] <mauke> ok, that's at least a reason I can understand

[18:59] <TimToady> so that is one place where Perl 6 forces people to say what they mean, just to be clear, just as you'd have to put parens after the !! if you want lower precedence there

[19:00] <TimToady> as for citations, language design is still more of an art than a science :)

[19:01] <mauke> it still feels wrong to me, like warning for "print (" instead of catching the general problem

[19:01] <TimToady> which we also fixed in Perl 6

[19:01] <TimToady> or at least made a different mistake

[19:02] <TimToady> but the foundation of Perl 6 is to question everything that went before

[19:02] <PerlJam> mauke: now you sound like me.  I'm always "feeling wrong" about Perl 6 features :)

[19:03] <PerlJam> (though the recent addition of %/%% felt right out of the box)

[19:03] <mauke> what does that do?

[19:03] <TimToady> but there's a great deal of "invisible" design that goes into making errors detectable

[19:04] *** perl_noob joined
[19:04] <TimToady> we used to overload regex patterns

[19:04] <TimToady> so x ** 1..5 was numeric quantification

[19:04] <TimToady> but x ** ',' was by separator

[19:04] <perl_noob> hy, would anyone tell me what happens when shift is used for assigning? like my $i = shift ??

[19:04] <TimToady> "as long as there are commas, parse x"

[19:04] <TimToady> we separated those into two notations

[19:05] <flussence> rakudo: sub a { my $i = shift; say $i }; a(1, 2, 3)

[19:05] <p6eval> rakudo db05a4: OUTPUT¬´Too many positional parameters passed; got 3 but expected 0‚ê§  in sub a at /tmp/FHgIdpWgVC:1‚ê§  in block <anon> at /tmp/FHgIdpWgVC:1‚ê§  in <anon> at /tmp/FHgIdpWgVC:1‚ê§‚ê§¬ª

[19:05] <TimToady> which allows us to have both numeric and separators

[19:05] <PerlJam> perl_noob: in perl 5, it shifts either @_ or @ARGV depending on where it's used

[19:05] <flussence> rakudo: sub a(*@_) { my $i = shift; say $i }; a(1, 2, 3)

[19:05] <p6eval> rakudo db05a4: OUTPUT¬´No applicable candidates found to dispatch to for 'shift'. Available candidates are:‚ê§:(Positional @a)‚ê§‚ê§  in sub shift at src/gen/CORE.setting:4242‚ê§  in sub a at /tmp/3LkA56OmGO:1‚ê§  in block <anon> at /tmp/3LkA56OmGO:1‚ê§  in <anon> at /tmp/3LkA56OmGO:1‚ê§‚ê§¬ª‚Ä¶

[19:05] <flussence> that's what happens, an error

[19:05] <TimToady> and the %/%% will certainly feel somewhat wrongish since we picked something that was unlikely to resemble anything else you'd see in P6 regexes

[19:05] <mauke> I'm actually a bit disappointed that perl6 still clings to regexes

[19:06] <perl_noob> PealJam: it 's in the first line of a sub of a code i got here... it's just "my $j = shift;" and i cant figure it ouy

[19:06] <TimToady> um, as opposed to clinking to what?

[19:06] <perl_noob> out*

[19:06] <PerlJam> clings?

[19:06] <flussence> rakudo: sub a(Int $i, Str $j = '#', Bool $k = false) { say $i }; a(1, 2, 3) # better way of writing subs

[19:06] <p6eval> rakudo db05a4: OUTPUT¬´Nominal type check failed for parameter '$j'; expected Str but got Int instead‚ê§  in sub a at /tmp/WoXi0J6NsV:1‚ê§  in block <anon> at /tmp/WoXi0J6NsV:1‚ê§  in <anon> at /tmp/WoXi0J6NsV:1‚ê§‚ê§¬ª

[19:06] <flussence> rakudo: sub a(Int $i, Str $j = '#', Bool $k = false) { say $i }; a(1)

[19:06] <p6eval> rakudo db05a4: OUTPUT¬´Could not find sub &false‚ê§  in code <anon> at /tmp/P0jLtAOPxI:1‚ê§  in sub a at /tmp/P0jLtAOPxI:1‚ê§  in block <anon> at /tmp/P0jLtAOPxI:1‚ê§  in <anon> at /tmp/P0jLtAOPxI:1‚ê§‚ê§¬ª

[19:06] <TimToady> the P6 regexs are far and away the most radical redesign feature of P6

[19:06] <flussence> rakudo: sub a(Int $i, Str $j = '#', Bool $k = False) { say $i }; a(1)

[19:06] <p6eval> rakudo db05a4: OUTPUT¬´1‚ê§¬ª

[19:06] <PerlJam> mauke: regex are still a useful tool either way

[19:07] <TimToady> we did keep *, +, and ? though

[19:07] <moritz> mauke: in perl 6, regexes are much less essential for non-string code than in perl 5

[19:07] <TimToady> just about everything else changed

[19:07] <mauke> PerlJam: but they shouldn't be a core language thing

[19:07] <PerlJam> mauke: why not?

[19:07] <TimToady> sez who?

[19:07] <mauke> this is my ass speaking

[19:08] <mauke> armchair language designer and all that

[19:08] <moritz> jnthn: fwiw the optimizer branch makes the mandelbrot thing run in 43s; I've created a copy that uses a few more type annotations, and native int for the iterator variable... 32s

[19:08] <flussence> oh, I meant to ask about the other *+?s...

[19:08] *** thou joined
[19:08] <mauke> I only have vague notions of what feels right and what doesn't, so don't take me too serious

[19:08] <TimToady> we went the other way, P5 didn't actually make them a core language well enough

[19:08] <jnthn> moritz: Not bad, not bad... :)

[19:08] <flussence> should $obj.?multi die if none of the existing multis apply?

[19:08] <TimToady> treating regexes as strings was Bad Design in p5

[19:08] <jnthn> .? has nothing to do with multis

[19:08] <tadzik> moritz: niecza is like 5 seconds, or is it?

[19:09] <jnthn> It's about the method dispatcher.

[19:09] <flussence> well that answers my question :)

[19:09] <mauke> PerlJam: the language should be flexible enough to let you write regexes as a library

[19:09] <jnthn> flussence: Well, back in b we flattened all the dispatchers out.

[19:09] <jnthn> Then things changed.

[19:10] <TimToady> and P6 is flexible enough to let you import any first-class language from the library, including regexes

[19:10] <tadzik> I've never seen a language like that, so I'd think twice about the "should"

[19:10] <TimToady> that doesn't force us to treat regexes as a second-class language as P5 does, or as a third-class language as Python does

[19:10] <mauke> tadzik: depending on your definitions Haskell is that language

[19:11] <tadzik> does it have first-class regexes, with stuff like $foo ~~ /bla bla/ or s/foo/bar/?

[19:11] <flussence> TimToady: ooc, how does Python do them? strings?

[19:11] <PerlJam> flussence: everyone (almost) does regex-as-strings

[19:12] <mauke> tadzik: no, but I wouldn't call that first class

[19:12] *** alvis joined
[19:12] <tadzik> maybe I'm using the wrong words here, but I hope you see what I meant

[19:12] <moritz> mauke: what does a feature need to be "first class", besides literals and the ability to pass them around as objects?

[19:12] *** perl_noob left
[19:12] <tadzik> basically, I meant "stuff like Regex.match() doesn't count"

[19:13] <mauke> I'm thinking of parser combinator libraries like parsec

[19:13] <mauke> moritz: the ability to construct them at runtime, at least

[19:13] <mauke> to abstract over them

[19:14] <moritz> [x] possible

[19:14] <moritz> [x] possible

[19:14] <tadzik> C can do that

[19:14] <tadzik> construct them at runtime, I mean

[19:14] <mauke> C can't dance

[19:14] <mauke> it has no legs

[19:14] <TimToady> the problem with most languages is that they force you to do it at runtime

[19:15] <tadzik> yeah, but the standard dance.h can

[19:15] <TimToady> and you end up with inferior runloop problems too

[19:16] <TimToady> P6's approach is much more like Haskell combinators that can be compiled efficiently.

[19:16] <mauke> what do you mean? less efficient execution because they're no special language support?

[19:16] <TimToady> you can do things at run-time, but you're not forced to

[19:16] <mauke> er, not "they're"

[19:17] *** alester joined
[19:18] <mauke> gut feeling again: if something isn't efficient enough, it's preferable to improve the compiler until it is, instead of pulling the feature into the core language

[19:19] <PerlJam> your gut is weird.

[19:19] <mauke> (I realize that this is vague and not always possible)

[19:19] <PerlJam> "pulling a feature into the core language" is all about expressivity and making things easier for the programmer to get work done.

[19:19] <moritz> mauke: lisp exists :-)

[19:20] <mauke> PerlJam: I'd say it's the opposite

[19:20] <mauke> depends on how exactly it's done, though

[19:20] <TimToady> so you'll maintain an artificial distinction between languages you use as a native speaker, and languages you can't actually use direclty, but just think about using at one remove?

[19:20] <TimToady> that's how most languages treat regex language

[19:20] <TimToady> you have to handle regexes with tongs all the time

[19:21] <moritz> despite all wishes otherwise, perl 6 is not a minimalist language, and won't be one

[19:21] *** thou left
[19:21] <im2ee> How goes Your day? :)

[19:21] <TimToady> Perl 6 is about saying what you mean, not about talking about saying what you mean

[19:21] <TimToady> that's why it's given/when, not switch/case

[19:21] <mauke> heh

[19:21] <mauke> I hope perl6's version is better than perl5's

[19:22] <PerlJam> TimToady:  I think you've hit the anil on the head.  mauke is probably one of the people who *wants* to handle regex with tongs all the time.

[19:22] <TimToady> p5 tried to cargo cult the syntax without the type system to carry it off correctly

[19:23] *** Vlavv` left
[19:24] *** Vlavv` joined
[19:24] <PerlJam> mauke: do you find regex an icky intrusion in your otherwise nice perl code?

[19:24] <mauke> hah, no

[19:25] <mauke> everyone knows there is no such thing as "nice perl code"!!!1

[19:25] <PerlJam> heh

[19:25] <PerlJam> I think I've generally assumed that most other perl-people have a similar relationship with Perl as I do.  Clearly this is not the case.

[19:25] <mauke> but given that I'm the author of http://mauke.dyndns.org/stuff/perl/ccomm.pl and use regexes all the time ... no, not really

[19:26] <TimToady> P5 only pretends to make regex into a real language, but underneath it's all still strings, and that's where nearly all the problems arise, from double-parsing and inferior run-looping

[19:27] <mauke> I think I agree

[19:27] <TimToady> turning it into real language allows us to pick the correct defaults on how variables are treated, rather than forcing string interpolation semantics

[19:28] <PerlJam> double parsing rears its ugly head everytime someone uses a $variable in a regex.  How many of those questions does #perl field in a given week?

[19:28] <TimToady> so vars always match literally in P6

[19:28] <TimToady> no more need for \Q...\E

[19:28] <tadzik> so eskimo shouldn't work? :)

[19:28] <TimToady> eskimo won't work; you'll have to cheat some other way :)

[19:28] <mauke> just the other day I was thinking about what an "ultimate regex library" would look like

[19:29] <PerlJam> mauke: perl 6?  :)

[19:29] <mauke> does perl6 let me match other things than strings?

[19:29] <TimToady> you realize the Perl 6 parser is written in Perl 6 regexes?

[19:29] <tadzik> :)

[19:29] <PerlJam> mauke: yes

[19:29] <tadzik> that's the *WHAM* moment

[19:30] <mauke> TimToady: I've heard about it but I don't really know what perl6 actually looks like

[19:30] <m6locks> ;)

[19:31] <mauke> PerlJam: can it give me more information about a match than just "matched" / "didn't match"? particularly "matched but could potentially match more if the string was longer" and "didn't match but could potentially match from offset X if the string was longer"

[19:32] <tadzik> ew

[19:32] *** kshannon left
[19:32] <moritz> mauke: there's a .moreinput mechanism in STD which lets you provide a longer string whenever the regex engine examines the end of the string

[19:32] <TimToady> in what units are you defining offset X?

[19:32] <PerlJam> mauke: that part is a bit underspecced, but I believe the answer is yes to those as well.  

[19:33] <mauke> TimToady: bytes, because I was thinking in C

[19:33] *** sivoais left
[19:33] <TimToady> yes, well, we've got a slightly more nuanced view of the various possible definitions of "character" here

[19:33] *** ruoso left
[19:34] *** kshannon joined
[19:34] <TimToady> but for various definitions, there will likely be a way to do it

[19:34] <mauke> I have a very specific use case for this feature and it involves a pty, so it really is bytes

[19:34] <TimToady> do you expect to match any non-ASCII characters?

[19:35] *** ruoso joined
[19:35] <mauke> good question

[19:35] <mauke> maybe

[19:36] <TimToady> then you may need to know a bit more than just where the bytes are

[19:36] <mauke> what do you mean?

[19:36] <moritz> if it's "ultimate", I'd rather hope it could match > 127 :-)

[19:36] <PerlJam> mauke: See, that's what Perl 6 needs; people who have specific use-cases that someone can write an implementation for features against.  that way we vet the spec and get an implementation out of the deal  :)

[19:37] <mauke> moritz: of course it could, but most urls are ascii

[19:37] <mauke> does perl6 do continuations?

[19:38] <TimToady> but what encoding is your pty returning characters in?  and do you know for sure, or are you just guessing from an env var?

[19:38] <mauke> TimToady: neither, I'm guessing from the bytes

[19:38] <mauke> and the guess will probably be "try utf-8; if that fails, give up"

[19:39] <TimToady> Perl 6 the language does not mandate continuations, though it can be implemented in terms of them

[19:39] <TimToady> in fact, that's the case on parrot

[19:40] <benabik> No call/cc in p6?

[19:40] <PerlJam> mauke: were you asking if continuations were exposed to the Perl 6 programmer?

[19:40] <TimToady> not all platforms can supply continuations easily, so it would be implementation dependent on whether they are available on a language level

[19:40] *** sivoais joined
[19:40] <mauke> I mean as a userspace feature. "hey, let's suspend this execution and get back to it later"

[19:41] <TimToady> we expose such behavior more by use of lazy lists

[19:41] <mauke> I'm asking because moritz mentioned the ability to extend the target string on the fly while matching

[19:41] <mauke> that's only half of the functionality

[19:41] <[Coke]> TimToady: ah, sorear had a question for you about the stringification of ranges.

[19:42] <mauke> I also want to suspend the regex matcher and get back to it later

[19:42] <[Coke]> perl6: say ~(1..6)

[19:42] <p6eval> pugs, rakudo db05a4: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[19:42] <p6eval> ..niecza v10-17-g8fdba33: OUTPUT¬´1..6‚ê§¬ª

[19:43] <moritz> given the existance of (1...6), I'm much less oppose to niecza's stringification as I would have been some time ago

[19:43] <[Coke]> perl6: say ~(1...6)

[19:43] <p6eval> rakudo db05a4, niecza v10-17-g8fdba33: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[19:43] <p6eval> ..pugs: OUTPUT¬´*** ‚ê§    Unexpected "6"‚ê§    expecting operator or ")"‚ê§    at /tmp/E0KHWH7uIJ line 1, column 11‚ê§¬ª

[19:44] <TimToady> and .. is supposed to primarily represent an interval, not a list

[19:44] <flussence> pugs: say ~(1...)

[19:44] <p6eval> pugs: OUTPUT¬´Stack space overflow: current size 8388608 bytes.‚ê§Use `+RTS -Ksize -RTS' to increase it.‚ê§¬ª

[19:44] <flussence> :(

[19:44] <[Coke]> hee!

[19:44] <mauke> ah, good old ghc

[19:44] * [Coke] gives flussence a cookie!

[19:45] <[Coke]> TimToady: so you're cool with it stringifying to the range itself?

[19:45] <[Coke]> If you change the spec, I will update the spec tests. (and then fudge niecza & rakudo to deal with it.)

[19:46] <[Coke]> (... or fix rakudo, i suppose.)

[19:46] <TimToady> niecza: print 1..6

[19:46] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´1..6¬ª

[19:46] <TimToady> that, however, is wrong, since a range should iterate in list context

[19:47] <tadzik> masak: what was the presentation software we were using for LAF?

[19:47] * [Coke] hates the new print/say dichotomy. :P

[19:47] * jnthn hates the new print/say dichotomy. :P

[19:48] <[Coke]> is pretty sure it doesn't impact the stringification used in the tests, though.

[19:48] <jnthn> ...does anybody like it? :)

[19:48] <masak> tadzik: Failure.

[19:48] * masak hates the new print/say dichotomy. :/

[19:48] <arnsholt> There's a dichotomy between print and say?

[19:48] <tadzik> I hate it too!

[19:48] <tadzik> masak: in which repo does it live?

[19:48] <masak> tadzik: https://github.com/masak/failure

[19:48] <PerlJam> arnsholt: say isn't  print + "\n" 

[19:48] <tadzik> kthx

[19:49] <tadzik> . o O ( failure lives in all my repos )

[19:49] <arnsholt> Aha. What's the difference between the two?

[19:49] <masak> tadzik: I have found a correlation between derogatory project names and longevity of projects. so "failure" was the name I chose.

[19:50] <diakopter> heh

[19:50] <flussence> .oO( "PHP" )

[19:50] * moritz kinda likes that there are different stringifications, but isn't sure that the print/say distinction is the right trigger

[19:50] <tadzik> arnsholt: they stringify stuff differently

[19:50] <masak> moritz: I'm pretty sure the print/say distinction isn't the right trigger.

[19:51] <flussence> I tried to $io.write($str) the other day...

[19:51] <tadzik> :P

[19:51] <arnsholt> Oh. I think I can get behind not liking that

[19:51] <moritz> nom: $*OUT.write('foo')

[19:51] <p6eval> nom db05a4: OUTPUT¬´Nominal type check failed for parameter '$buf'; expected Buf but got Str instead‚ê§  in method write at src/gen/CORE.setting:5008‚ê§  in block <anon> at /tmp/LoKfzWwLbV:1‚ê§  in <anon> at /tmp/LoKfzWwLbV:1‚ê§‚ê§¬ª

[19:52] <diakopter> hm

[19:52] <PerlJam> masak: would a different verb help?

[19:53] <TimToady> it's pretty easy to define a println if you want it

[19:53] <[Coke]> hey, for rakudo, do we want to add ALL the spectests to t/spectest.data in commented out form?

[19:53] <moritz> [Coke]: nope

[19:53] <PerlJam> TimToady: yeah, but I think one of the reasons say was so well liked was because so many people wanted exactly that.  :)

[19:53] *** ingy left
[19:54] <moritz> [Coke]: only those we're supposed to pass, for some values of "supposed"

[19:54] <TimToady> before they knew they wanted gitsts

[19:54] <TimToady> *gists even

[19:54] <[Coke]> moritz: not even at the bottom undernearth all the ones we do run? ;)

[19:54] <[Coke]> moritz: we're supposed to pass all of them. ;)

[19:55] <moritz> [Coke]: for some other value of "supposed" :-)

[19:55] *** sunnavy left
[19:55] *** athomason_ left
[19:55] <masak> TimToady: I'm not advocating adding more ways to print stuff, just consistency between the ways we already have.

[19:56] *** sunnavy joined
[19:57] <TimToady> I see little use for consistency here, and more use from differentiating features that are "too close"

[19:57] <TimToady> much as we made -M very different from mtime in p5

[19:57] <diakopter> maybe TimToady was suggesting "you" "define" "println" in CORE.setting ;)

[19:57] <[Coke]> moritz: some of the stuff in rakudo/tools could move to roast. (like test_summary.pl, autounfudge). easier to share between projects, then. (which would be helpful for niecza)

[19:57] <PerlJam> heh

[19:57] *** ingy joined
[19:57] <moritz> [Coke]: +1

[19:57] <moritz> [Coke]: though you should talk to mberends++ about test_summary.pl

[19:57] <[Coke]> moritz: k. I'll look at that later.

[19:58] <moritz> update_passing_test_files.pl could also move

[19:58] <[Coke]> he was happy to see it being used on niecza. I think that's a +1. ;)

[19:58] <TimToady> and "println" would suggest much more consistency with "print" than "say" would :P

[19:58] <PerlJam> We could use "p" like Data::Printer does ;)

[19:59] <diakopter> perl6: say list 1..6

[19:59] <p6eval> rakudo db05a4: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[19:59] <p6eval> ..pugs: OUTPUT¬´123456‚ê§¬ª

[19:59] <p6eval> ..niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'list' used at line 1‚ê§‚ê§‚ê§Unhandled Exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ‚ê§‚Ä¶

[19:59] <diakopter> perl6: print list 1..6

[19:59] <p6eval> pugs, rakudo db05a4: OUTPUT¬´123456¬ª

[19:59] <p6eval> ..niecza v10-17-g8fdba33: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'list' used at line 1‚ê§‚ê§‚ê§Unhandled Exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ‚ê§‚Ä¶

[20:00] <masak> I dislike the splitting up of semantics into a thousand different little aspects. we shouldn't have three methods for getting truth values. we shouldn't have four and a half types representing lists. we shouldn't have print and say going off to different stringification routines. I shouldn't have to stress this. :(

[20:00] *** athomason joined
[20:01] *** kaare_ left
[20:01] <masak> I know that the world contains lots of essential complexity, but most of the above feels like putting accidental complexity into the design.

[20:01] <masak> I'm against that.

[20:01] <diakopter> some kitchen sinks are very complex, and people pay for them

[20:02] <tadzik> masak: do you have the 'slides' file which LAF was generated from?

[20:02] <PerlJam> masak: I don't think it's accidental complexity at all, but I also don't necessarily disagree with you either.

[20:02] <masak> tadzik: https://github.com/masak/talks/blob/master/yapc-eu-2011-little-animal-farm/slides

[20:02] <tadzik> thanks

[20:03] *** mj41 left
[20:03] <PerlJam> masak: I also have no good answers, so I punt to TimToady and hope his brain can sort it out better than mine.

[20:03] <masak> PerlJam: here's why it *is* accidental complexity. Perl 6 class, explain 'print' and 'say'. teacher goes 'say = print + \n'. done. everything else is overly complex.

[20:03] <TimToady> so everything should be one different from everything else, eh?

[20:04] <masak> I don't think that's what I'm saying.

[20:04] <PerlJam> masak: That sounds like "we had a simple rule and now it's not, ergo accidental complexity"

[20:04] <masak> I'm saying I thought it was beautiful and easy when print and say were one different.

[20:04] <masak> PerlJam: yes!

[20:04] <PerlJam> masak: I don't buy that.

[20:04] <masak> because the simple rule was obviously the right one.

[20:05] * jnthn struggles to see why what masak's saying isn't obvious too, fwiw.

[20:05] <masak> and the current rule... I would say it sucks, but I can't even *explain* the difference yet. :(

[20:05] <masak> this just makes me a bit sad and angry. :(

[20:05] <jnthn> Violates the principle of least surprise too.

[20:05] <PerlJam> masak: that it sucks ... *that* I can agree with entirely.

[20:05] *** athomason left
[20:05] <jnthn> It surprised me to the degree that I almost just went and fixed print in Rakudo, assuming it was a bug.

[20:06] <[Coke]> anyone have a link to spec explaining how they differ?

[20:06] <masak> apparently jnthn and I were the only two not affected by the Reality Distortion Field, being too busy with NPW...

[20:06] <moritz> ack for gist

[20:06] *** sunnavy left
[20:07] <[Coke]> http://perlcabal.org/syn/Differences.html#say() is wrong.

[20:07] <jnthn> I like that we differentiate .gist and .Str. That's solved problems. But making say call .gist and print call .Str is creating a new problem.

[20:07] <masak> [Coke]: looks good to me.

[20:07] *** sunnavy joined
[20:07] <masak> jnthn: exactly.

[20:08] <jnthn> Plus you can get the other (Str) meaning with one char.

[20:08] <jnthn> say ~$thing; print ~$thing;

[20:08] <masak> +1

[20:08] <jnthn> If you happen to really want it.

[20:08] *** ingy left
[20:08] *** ingy joined
[20:08] *** athomason joined
[20:08] <masak> please make it so.

[20:09] <[Coke]> .gist says that say calls .gist (say should say that say calls .gist), but doesn't say what print calls in place of .gist

[20:09] <TimToady> so make print call .gist like say, and then add a "print-yes-I'm-really-printing-to-a-device-not-a-human" function

[20:10] <jnthn> TimToady: +1

[20:10] <TimToady> output 1..6

[20:11] <PerlJam> TimToady: that sounds good to me 

[20:11] <masak> write :)

[20:12] <TimToady> write would be okay

[20:12] *** sunnavy left
[20:12] <masak> IO already has .write

[20:12] <TimToady> but does it take a list?

[20:12] <masak> dunno.

[20:12] <TimToady> is probably a STDIO-alike

[20:12] *** sunnavy joined
[20:13] <PerlJam> normally "write" is the opposite of "read", what's the opposite of "print" or "say"  ?

[20:13] <PerlJam> (do they have an input counter part?)

[20:13] <TimToady> prompt

[20:13] <masak> PerlJam: "subscribe" or "listen" :P

[20:15] <PerlJam> There's no separate newline-preserving and newline-removing routines?

[20:16] <masak> ISTR lines() has a named controlling newline strippage.

[20:16] <TimToady> there are no nl-preserving defaults

[20:17] *** ilogger2 joined
[20:17] *** ChanServ sets mode: +v ilogger2

[20:17] <masak> and it was only ever on the callee side anyway.

[20:18] <flussence> yeah, that's what I was trying to get it from...

[20:18] <PerlJam> TimToady: so ... why have print at all?  why not something like  say :raw "lah"   ?

[20:18] <masak> (TTIAR)

[20:19] *** bbkr joined
[20:19] <PerlJam> (:raw is a bad name, but aside from that...)

[20:19] <TimToady> primitives should not be modified forms of complex operators

[20:23] <flussence> rakudo: sub infix:<@@>($a, $b) { say "$a $b" }; 1 @@ 2;

[20:23] <p6eval> rakudo db05a4: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "1 @@ 2;"‚ê§¬ª

[20:23] <flussence> b: sub infix:<@@>($a, $b) { say "$a $b" }; 1 @@ 2;

[20:23] <p6eval> b 1b7dd1: OUTPUT¬´1 2‚ê§¬ª

[20:23] <flussence> something broke...

[20:23] <flussence> recently, too

[20:24] <moritz> flussence: yep, operator overloading is NYIA in nom

[20:24] <flussence> hm, oh well

[20:25] <flussence> b: sub infix:<as>($value, $type) { $value.$type }; print False as Int

[20:25] <p6eval> b 1b7dd1: OUTPUT¬´invoke() not implemented in class 'Integer'‚ê§  in 'infix:<as>' at line 22:/tmp/ZZaCQZn9tT‚ê§  in main program body at line 22:/tmp/ZZaCQZn9tT‚ê§¬ª

[20:26] <moritz> b: sub infix:<as>($value, $type) { $value."$type"() }; print False as Int

[20:26] <TimToady> but I'm more inclined to leave print as primitive, since that's how it is in Perl 5, and introduce something that indicates "presay" or something that means what you say before you're going to say what you're going to say

[20:26] <p6eval> b 1b7dd1: OUTPUT¬´Method 'Int()' not found for invocant of class 'Bool'‚ê§  in 'infix:<as>' at line 22:/tmp/2pHlJB38e2‚ê§  in main program body at line 22:/tmp/2pHlJB38e2‚ê§¬ª

[20:27] <mauke> so I was reading about smart match and I'm not sure it's better than the perl5 version

[20:27] *** tokuhiro_ joined
[20:27] <mauke> from the description it looks like I still don't know what 'given ($foo) { when $bar {} }' will do

[20:28] <TimToady> and you'll almost never see such a when statement

[20:28] <moritz> mauke: about the same as if $foo ~~ $bar { }

[20:29] <mauke> yeah, same problem

[20:29] <TimToady> which you wouldn't write unless you knew $bar made sense as a pattern

[20:29] <mauke> if I knew what $bar was, I could use a more specific operator

[20:29] <moritz> mauke: if you don't know what your variables contain, and they have as descriptive names as $foo and $bar, you do have a problem

[20:29] <TimToady> you can't just use ~~ as a synonym for == or eq or === or eqv and expect to get away with it

[20:30] <TimToady> "Doctor, it hurst when I do this..."

[20:30] <flussence> rakudo: my $foo = 'abc'; my $bar = rx/a/; $bar.ACCEPTS($foo).perl.say

[20:30] <p6eval> rakudo db05a4: OUTPUT¬´Match.perl(orig => "abc", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new())‚ê§¬ª

[20:30] <TimToady> "Well, obviously you need to drink less, since you can't pronounce 'hurts'"  :)

[20:30] <mauke> perl6 is all about making it harder for users to hurt themselves

[20:31] <TimToady> but not impossible

[20:31] <mauke> that's why ?? !! has weird parsing rules :-)

[20:31] <TimToady> it's a balancing act

[20:31] <mauke> I accidentally read about loop constructs as well

[20:31] <jnthn> The whole of loop constructs?

[20:31] <mauke> is there a way to do something like: repeat { my $x = foo(); } until $x; ?

[20:32] <jnthn> TimToady: While you're about...what does ::Foo::Bar actually mean in a term context?

[20:32] <TimToady> yes

[20:32] <TimToady> repeat until my $x { $x = foo() }

[20:32] <jnthn> TimToady: Does it mean "try to look this think up at runtime, and assume it's a type"?

[20:32] <mauke> haha, ouch

[20:32] <TimToady> works fine

[20:32] <jnthn> s/think/thing/

[20:33] <mauke> that is deliciously evil

[20:33] <jnthn> TimToady: And if it's something we need to know at compile time we whine "can't do"?

[20:33] <diakopter> niecza: repeat until my $x { $x = say 3 }

[20:33] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´3‚ê§¬ª

[20:34] <mauke> (also, I think I understand the objections to Data.Default (Haskell) now)

[20:36] <mauke> thanks for the discussion, btw

[20:39] <moritz> jnthn: fwiw it seems I don't understand constants code generation well enough to fix the Inf thing in optimizer

[20:40] <moritz> jnthn: I think it might need fixing in SymbolTable.add_numeric_constant or so, but I'm far from sure

[20:45] <TimToady> jnthn: yes, that's about all :: does, not much more than the stubbing you get on Foo::Bar::baz

[20:51] <jnthn> moritz: I'm just building it now to see what the test fallout is and ahve a look.

[20:51] <jnthn> TimToady: OK, thanks.

[20:54] <dalek> roast: bc6a795 | moritz++ | S03-operators/lcm.t:

[20:54] <dalek> roast: test for [lcm] Range

[20:54] <dalek> roast: review: https://github.com/perl6/roast/commit/bc6a7957ea

[20:54] <dalek> roast: e20ead4 | moritz++ | S05-grammar/inheritance.t:

[20:54] <dalek> roast: fudge a grammar test

[20:54] <dalek> roast: review: https://github.com/perl6/roast/commit/e20ead4b26

[20:57] <dalek> roast: b5503f3 | moritz++ | S14-roles/mixin.t:

[20:57] <dalek> roast: test for mixing into a Rat, RT #99986

[20:57] <dalek> roast: review: https://github.com/perl6/roast/commit/b5503f3391

[20:58] <jnthn> moritz++ # knocking down the testneeded queue a bit

[20:58] <jnthn> btw, I think there is plenty more "fixed in nom" to go in the queue.

[21:00] <sjohnson> internet

[21:00] <masak> that's us. hi.

[21:00] <dalek> roast: f7a7b76 | moritz++ | S03-operators/buf.t:

[21:00] <dalek> roast: test Buf concatenation

[21:00] <dalek> roast: review: https://github.com/perl6/roast/commit/f7a7b76da2

[21:01] <sjohnson> masak++

[21:01] <jnthn> Apart from in Latvia, and then we're "internets"

[21:01] <diakopter> who says interwebs

[21:02] <diakopter> or intertubes

[21:02] <moritz> nom: my @a = a => 1, b => 2; say @a.perl; say @a.hash.perl; say @a.perl;

[21:02] <p6eval> nom db05a4: OUTPUT¬´Array.new("a" => 1, "b" => 2)‚ê§("a" => 1, "b" => 2).hash‚ê§Array.new("a" => 1, "b" => 2)‚ê§¬ª

[21:02] <moritz> diakopter: for me it's the "interblah"

[21:02] <jnthn> So long as you don't mistake it for a truck, it's all good.

[21:04] <dalek> roast: 8791b90 | moritz++ | S02-types/array.t:

[21:04] <dalek> roast: tests "for Array.hash eats itsef" bug, RT #95850

[21:04] <dalek> roast: review: https://github.com/perl6/roast/commit/8791b90a45

[21:06] <jnthn> moritz: wow, it does rather decimate the spectest suite, doesn't it... :) Working on a fix. :)

[21:07] <moritz> jnthn: that's what I meant with "havoc", even though I spelled the verb wrongly :-)

[21:08] <dalek> roast: 5fb50bc | moritz++ | S03-operators/range.t:

[21:08] <dalek> roast: test "a".."z", RT #95692

[21:08] <dalek> roast: review: https://github.com/perl6/roast/commit/5fb50bc92d

[21:11] <dalek> roast: 391661a | moritz++ | S02-types/subset.t:

[21:11] <dalek> roast: test for subse type with any(), RT #95500

[21:11] <dalek> roast: review: https://github.com/perl6/roast/commit/391661a675

[21:11] <moritz> down to 843 open perl6 tickets. masak, that's a challenge :-)

[21:11] <masak> challenge ACCEPTED.

[21:12] <jnthn> oh my, I really wanted to get sub-800 :P

[21:12] <jnthn> .oO( mwaha...I can file tickets about macros soon! ;) )

[21:12] <moritz> rakudo: my $a = 1, 2, 3; $a = $a.grep({1}); say $a.perl

[21:12] <p6eval> rakudo db05a4: OUTPUT¬´(1,).list.item‚ê§¬ª

[21:12] <moritz> that's wrong, isn't it?

[21:12] <moritz> {1} always returns a True value

[21:13] * moritz -> sleep

[21:13] <jnthn> rakudo: my $a = 1, 2, 3; $a = $a.grep({say 'waz ere'; 1}); say $a.perl

[21:13] <p6eval> rakudo db05a4: OUTPUT¬´waz ere‚ê§(1,).list.item‚ê§¬ª

[21:13] <jnthn> er...hm.

[21:13] <jnthn> moritz: er

[21:13] <jnthn> moritz: item assignment :)

[21:13] <moritz> oh

[21:13] <moritz> right

[21:13] <moritz> https://rt.perl.org/rt3/Ticket/Display.html?id=93972 jsut needs a test then :-)

[21:13] <moritz> rakudo: my $a = (1, 2, 3); $a = $a.grep({1}); say $a.perl

[21:13] <p6eval> rakudo db05a4: OUTPUT¬´(1, 2, 3).list.item‚ê§¬ª

[21:14] <jnthn> moritz: And before you sleep, other good news

[21:14] <jnthn> moritz: I have a patch that fixes the spectets for Inf/NaN issues :)

[21:14] <jnthn> I guess we're not allowed a +/- in features for "native operators" until the branch merges though :)

[21:16] <dalek> rakudo/optimizer: 7bc5ce7 | jnthn++ | src/Perl6/SymbolTable.pm:

[21:16] <dalek> rakudo/optimizer: Fix Inf/NaN in native num contexts.

[21:16] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/7bc5ce71c2

[21:20] * jnthn wonders what next for optimizer...

[21:20] <jnthn> Though I should probably worry about other things too :)

[21:27] <jnthn> nom: sub foo() returns(int) { }

[21:27] <jnthn> rakudo: sub foo() returns(int) { }

[21:27] <jnthn> rakudo: say "alive"

[21:28] <jnthn> ...

[21:28] <jnthn> niecza: say 42

[21:28] *** mkramer joined
[21:28] <jnthn> oh, no parens...

[21:29] *** diakopter left
[21:29] *** diakopter joined
[21:29] <p6eval> nom db05a4: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "returns(in"‚ê§¬ª

[21:29] <p6eval> rakudo db05a4: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "returns(in"‚ê§¬ª

[21:29] <p6eval> rakudo db05a4: OUTPUT¬´alive‚ê§¬ª

[21:29] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´42‚ê§¬ª

[21:30] *** sorear joined
[21:30] *** mkramer left
[21:32] <diakopter> hunh; big delay from p6eval

[21:33] <jnthn> yeah, my build finished and I could do it locally before p6eval got back to me :P

[21:35] * masak .oO( p6eventually )

[21:36] <diakopter> cpu/mem on host04 are fine; seems like network problems at the hostring providrer

[21:36] <diakopter> better now

[21:37] <masak> nom: say "better now?"

[21:37] <p6eval> nom db05a4: OUTPUT¬´better now?‚ê§¬ª

[21:37] <masak> aye.

[21:40] <im2ee> Time to go! Good night o/ :)

[21:41] *** y3llow joined
[21:41] *** pothos_ joined
[21:42] *** pothos_ is now known as pothos

[21:43] *** y3llow left
[21:43] *** y3llow joined
[21:44] *** pothos left
[21:44] *** pothos_ joined
[21:45] *** y3llow left
[21:46] *** pothos_ is now known as pothos

[21:46] *** y3llow joined
[21:49] *** ab5tract joined
[21:55] <masak> 'night, #perl6.

[22:00] *** [Coke] joined
[22:05] *** gfldex left
[22:07] <diakopter> niecza: sub postfix:<!> { [*] 1..$^n }; say 78!

[22:07] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000‚ê§¬ª

[22:08] *** ab5tract left
[22:11] <diakopter> niecza: sub postfix:<!> { [*] 1..$^n }; say 1000!

[22:11] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´4023872600770937735437024339230039857193748642107146325437999104299385123986290205920442084869694048004799886101971960586316668729948085589013238296699445909974245040870737599188236277271887325197795059509952761208749754624970436014182780946464962910563938‚Ä¶

[22:12] <diakopter> niecza: sub postfix:<!> { [*] 1..$^n }; say (~1000!).chars

[22:12] <p6eval> niecza v10-17-g8fdba33: OUTPUT¬´2568‚ê§¬ª

[22:18] *** Fuad joined
[22:18] <dalek> rakudo/optimizer: 2cf8944 | jnthn++ | src/core/Int.pm:

[22:18] <dalek> rakudo/optimizer: Start to add some returns traits to various ops. Also a couple more native int ops.

[22:18] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/2cf89446a4

[22:18] <dalek> rakudo/optimizer: c085ef9 | jnthn++ | src/Perl6/ (3 files):

[22:18] <dalek> rakudo/optimizer: If we know what we're going to call, add its return type into the tree, so things a level up can use that type in their analysis. This means that given ($a, $b, $c) are all int, $a + $b * $c will be able to inline both operations; before it would not inline the +.

[22:18] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/c085ef9eac

[22:19] <Fuad> hello

[22:19] <diakopter> hello

[22:21] <diakopter> jnthn: in perlesque I had to add a non-spec facility so closures could be passed around *strongly-typed*, so their type signatures could appear in a function's signature... is there a spec'd way to strongly-type such closure arguments to Perl 6 functions?

[22:22] <diakopter> ... and will your optimizer know what to do with such things? :)

[22:23] <jnthn> I thought your work in that area led to something getting spec'd in S06 along those lines?

[22:23] <jnthn> &foo:(sig goes here) or some such.

[22:24] <jnthn> I don't have that in place yet, anyway.

[22:24] <jnthn> When I do, yes, it'll be there for the optimizer to consider.

[22:26] <diakopter> jnthn: istr something like that, I'd forgotten. :)

[22:26] <jnthn> I guess you were annotating the closures too?

[22:26] <jnthn> -> Int $a --> Int { ... } or some such?

[22:26] <diakopter> frankly I've forgotten

[22:27] <jnthn> ok :)

[22:27] <diakopter> my memory is abysmal

[22:28] <diakopter> oh yeah; I set up a parsetime macro-ish typedef

[22:29] <diakopter> the argument types directly corresponded to .Net routine signatures

[22:37] <diakopter> jnthn: any idea where that was in S06; I'm failing

[22:38] <jnthn> 314

[22:38] <diakopter> oh hm there it is

[22:50] * jnthn realizes that if you know you have a junction, you can probably figure out a lot of junction dispatcher failovers at optimize time, and not have to fail over.

[22:51] <jnthn> (Just go straight to the junction dispatcher.)

[22:55] *** Chat8299 joined
[22:55] <Chat8299> hola

[22:57] <tadzik> hello, fellow chatmosphere user

[22:58] *** Chat8299 left
[22:59] <jnthn> Well, thankfully that was less eventful than usual. :)

[22:59] <tadzik> yep :)

[23:00] *** Fuad left
[23:01] *** bbkr left
[23:02] *** bbkr joined
[23:08] *** bluescreen10 joined
[23:11] *** szbalint joined
[23:14] *** stepnem left
[23:14] <dalek> rakudo/optimizer: f7344b1 | jnthn++ | src/Perl6/Optimizer.pm:

[23:14] <dalek> rakudo/optimizer: Little refactor in preparation for analyzing only calls further.

[23:14] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/f7344b1444

[23:14] <dalek> rakudo/optimizer: ea3e344 | jnthn++ | src/ (3 files):

[23:14] <dalek> rakudo/optimizer: Some initial infrastructure for trial-binding calls to only subs.

[23:14] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/ea3e344bfc

[23:14] <dalek> rakudo/optimizer: 8c0c759 | jnthn++ | src/Perl6/Optimizer.pm:

[23:14] <dalek> rakudo/optimizer: Update optimizer so that it can start making some use of the only-sub trial bind analysis, once it's implemented (at the moment, it always gets 'not sure' though, and does no transformation).

[23:14] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/8c0c759c4a

[23:15] <felher> moritz++, jnthn++ for all that hacking on optimizer and nom lately, pmichaud++ for action methods <3. And ++ to all the ones i don't remember just now :/

[23:15] * felher -> sleep

[23:18] *** ranguard joined
[23:18] *** Tene joined
[23:18] *** Exodist joined
[23:20] *** whiteknight joined
[23:22] *** espadrine joined
[23:23] *** [Coke] left
[23:24] *** [Coke] joined
[23:29] *** buubot_backup left
[23:47] *** soh_cah_toa joined
[23:49] *** buubot_backup joined
[23:51] *** benabik joined
[23:54] *** stepnem_ joined
[23:56] *** molaf_ joined
