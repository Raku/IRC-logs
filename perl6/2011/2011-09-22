[00:01] *** Trashlord left
[00:04] *** replore joined
[00:05] *** replore left
[00:06] <jnthn> japhb_: https://gist.github.com/1233689

[00:06] <jnthn> Will push in a moment.

[00:06] <jnthn> japhb_: It gives you back a list of matches. If it's empty, you know that you need to show usage info. Otherwise, go ahead and do the dispatch for real.

[00:07] *** replore_ joined
[00:08] <dalek> rakudo/nom: 8453ed1 | jnthn++ | src/core/Routine.pm:

[00:08] <dalek> rakudo/nom: Add a way to get a set of matching candidates for a multi.

[00:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8453ed1c07

[00:09] <jnthn> japhb_: With ^^, it should be relatively straightforward now. :)

[00:11] *** uasi joined
[00:17] *** maguro left
[00:24] <jnthn> sleep; more Perl 6 hacking tomorrow :)

[00:26] *** japhb_ left
[00:35] *** wolfman2000 joined
[00:39] *** thou left
[00:41] * [Coke] was just going to give jnthn a hard time for still being awake!

[00:56] *** uasi left
[00:57] *** uasi joined
[00:58] *** benabik joined
[00:58] *** uasi left
[01:00] *** woosley joined
[01:01] *** woosley left
[01:02] *** colomon left
[01:02] *** colomon joined
[01:03] <sorear> good * #perl6

[01:03] *** woosley joined
[01:04] <colomon> \o

[01:06] *** uasi joined
[01:07] *** REPLeffect left
[01:11] <benabik> o/

[01:19] *** uasi left
[01:20] *** REPLeffect joined
[01:21] *** Chillance left
[01:22] *** whiteknight left
[01:23] *** cottoo joined
[01:24] *** cotto left
[01:27] *** risou_awy is now known as risou

[01:35] *** cottoo is now known as cotto

[01:38] <japhb> Can someone kick whatever updates http://perl6.org/compilers/features ?  It doesn't appear to have picked up jnthn++'s changes, and it's been a couple hours

[01:38] <japhb> I guess for this channel s/kick/hug/

[01:40] <japhb> jnthn: Thank you, I'll take a look when I'm not chasing young'ns

[01:44] *** wolfman2000 left
[01:46] *** risou is now known as risou_awy

[01:57] *** frhodes left
[01:57] *** frhodes joined
[02:01] *** mykhal left
[02:07] *** REPLeffect left
[02:07] *** REPLeffect joined
[02:11] *** REPLeffect left
[02:16] *** shinobicl_ joined
[02:21] *** mkramer joined
[02:23] *** REPLeffect joined
[02:24] *** mkramer1 left
[02:32] *** Vlavv` joined
[02:33] <benabik> HW assignment: "Read an e-mail file, print the From, To, Subject, and Cc headers"  Bonus points for brevity.  My answer: perl -ne 'exit if/^$/;print if/^(From|To|Subject|Cc):/'

[02:33] <benabik> I'd take suggestions on shortening it, but that would be cheating.  :-D

[02:33] <benabik> TimToady++ # Creating expressive languages

[02:35] *** REPLeffect left
[02:36] *** Vlavv left
[02:36] *** REPLeffect joined
[02:38] <sorear> benabik: egrep '^(From|To|Subject|Cc)'

[02:38] <benabik> sorear: Will print non-header lines that start with those.  :-D

[02:38] <sorear> egrep is officially deprecated in favor of grep -E, but, well, brevity

[02:38] <benabik> I suppose I could use see first.

[02:38] <benabik> *sed

[02:39] <sorear> hmm

[02:39] *** packetknife joined
[02:39] <benabik> Although I don't need the : if I know I'm in headers.

[02:39] <sorear> something like sed '/^$/q;/^\(From\|To\|Subject\|Cc\)/p' then

[02:39] <benabik> Bluh, but yes.

[02:40] <sorear> or perl -ne 'print if 1../^$/&&/.../'

[02:40] <sorear> the flip-flop operator is under-appreciated

[02:40] *** REPLeffect left
[02:40] <sorear> pity this is a text task, I'd love to show off a J solution but J is not strong with text :D

[02:41] <benabik> I don't quite get flipflop sadly.

[02:42] *** packetknife left
[02:45] *** uasi joined
[02:57] *** jaldhar joined
[02:59] *** Exodist left
[03:00] *** REPLeffect joined
[03:09] *** REPLeffect left
[03:10] *** uasi left
[03:10] *** REPLeffect joined
[03:13] <Tene> sorear: use sed -r instead of all those extra escapes

[03:14] <Tene> sorear: also, you need -n to surpress unwanted output

[03:15] <felher> Is there a neat way to do function composition in perl6? Something neater than: sub compose($f, $g) { return anon sub ($x) { return $f($g($x)); } } # <---- is that the way one would write a compose function?

[03:17] *** shinobicl_ left
[03:17] *** perlygatekeeper left
[03:18] *** shinobicl_ joined
[03:18] <sorear> felher: yes, although anon is redundant there

[03:19] <felher> sorear: k, thnx :)

[03:20] <sorear> felher: as for "something neater", I propose s/compose/infix:<o>/

[03:20] <japhb> A real compose should be agnostic to the signature of $g, right?

[03:21] <felher> sorear++: yeah, sounds good :). 'Neat' was the wrong word in the first place, i guess. I should have used 'builtin'. :)

[03:22] <felher> japhb: yeah, i guess it should :)

[03:22] *** odoacre left
[03:23] <Tene> yeah, you want to capture/flatten the arg list

[03:24] <Tene> .u ∘

[03:24] <phenny> U+2218 RING OPERATOR (∘)

[03:24] <sorear> .u ⎄

[03:24] <phenny> U+2384 COMPOSITION SYMBOL (⎄)

[03:24] *** odoacre joined
[03:24] <sorear> I wonder what that is

[03:25] <sorear> oh, Keyboard symbols

[03:26] *** uasi joined
[03:28] <felher> sub compose($f, $g) { return anon sub (|$x) { return $f($g(|$x)); } } # <--- would one use |$x for that?

[03:31] *** REPLeffect left
[03:32] *** shinobicl_ left
[03:36] *** shinobicl_ joined
[03:40] <sorear> felher: yes

[03:49] <felher> sorear: nice :)

[03:49] <felher> sorear: thnx a lot :)

[03:49] *** perlygatekeeper joined
[03:51] <japhb> sorear: Would this be correct:

[03:51] <japhb> gah, unicode pasting hell

[03:52] *** japhb_ joined
[03:52] <japhb_> multi infix:<∘>(&f, &g) { -> |$args { f(|(g(|$args))) } }; sub f($a, $b) { "$a - $b" }; sub g($a, $b, $c) { return $a, $c }; my &h := &f ∘ &g; h(7, 8, 9);

[03:53] <japhb> That doesn't work in Rakudo ATM

[03:53] <japhb> sorear: ^^

[03:57] *** shinobicl_ left
[04:02] *** geekosaur left
[04:03] *** geekosaur joined
[04:04] <sorear> japhb: you shouldn't use | between f and g

[04:05] <sorear> japhb: what you're doing isn't quite valid, because of a fundamental asymmetry between arguments (plural) and return values (singular, but return makes a parcel)

[04:12] *** envi_laptop joined
[04:16] *** envi_laptop left
[04:18] <japhb_> rakudo: sub compose(&f, &g) { -> |$args { f(|(g(|$args))) } }; sub f($a, $b) { "$a - $b" }; sub g($a, $b, $c) { return $a, $c }; my &h := compose(&f, &g); say h(7, 8, 9);

[04:18] <p6eval> rakudo 8453ed: OUTPUT«7 - 9␤»

[04:18] <japhb_> rakudo: sub compose(&f, &g) { -> |$args { f(g(|$args)) } }; sub f($a, $b) { "$a - $b" }; sub g($a, $b, $c) { return $a, $c }; my &h := compose(&f, &g); say h(7, 8, 9);

[04:18] <p6eval> rakudo 8453ed: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in sub f at /tmp/92oZ812Xe_:1␤  in block <anon> at /tmp/92oZ812Xe_:1␤  in <anon> at /tmp/92oZ812Xe_:1␤  in <anon> at /tmp/92oZ812Xe_:1␤␤»

[04:19] *** araujo left
[04:19] <japhb_> sorear: that ^^ was from an earlier version, before I tried the operator form.  Note that without the extra |() between f and g, it fails.

[04:19] *** birdwindupbird joined
[04:20] <japhb_> rakudobug or pebcak?

[04:29] *** soh_cah_toa left
[04:32] *** envi_laptop joined
[04:35] *** uasi left
[04:44] <sorear> japhb_: latent pebcak maybe.  |() will work in the simple case of a list of scalar variables, but in general the return ,,, / |() pair discards information

[04:44] *** araujo joined
[04:44] *** araujo left
[04:44] *** araujo joined
[04:45] *** mikemol joined
[04:45] *** frhodes left
[04:45] <sorear> japhb_: in particular, return(1,2,3) and return((1,2,3)) are the same, but f(1,2,3) and f((1,2,3)) are not

[04:47] *** am0c joined
[04:48] *** uasi joined
[04:51] *** araujo left
[04:52] *** araujo joined
[04:53] *** daniel-s joined
[04:57] *** JimmyZ joined
[05:03] *** mberends left
[05:04] <moritz> good morning

[05:09] <masak> good morning

[05:10] <moritz> masak: any thoughts on https://gist.github.com/1233070 ?

[05:12] * masak looks

[05:12] *** bakedb__ joined
[05:13] <masak> looks nice and clean.

[05:13] <masak> I assume .set_codes is a temporary workaround for lack of .STORE or similar.

[05:14] <sorear> o/ MASAK

[05:14] <masak> oh hai SOREAR

[05:15] * masak commutes

[05:15] *** masak left
[05:21] *** SHODAN joined
[05:21] *** araujo left
[05:22] *** araujo joined
[05:22] *** zby_home left
[05:25] *** MayDaniel joined
[05:30] <moritz> nqp: nqp::say(pir::typeof__SP($*OUT))

[05:30] <p6eval> nqp: OUTPUT«Contextual $*OUT not found␤current instr.: '_block1000' pc 43 ((file unknown):40) (/tmp/R0MGHzx5AX:1)␤»

[05:30] <moritz> nom: nqp::say(pir::typeof__SP($*OUT))

[05:30] <p6eval> nom 8453ed: OUTPUT«IO␤»

[05:37] *** satyavvd joined
[05:38] *** kaleem joined
[05:40] *** MayDaniel left
[05:44] <sorear> jnthn: ping

[05:45] *** araujo left
[05:46] *** araujo joined
[05:46] *** wtw joined
[05:48] <japhb> sorear: so what's the solution for a third-party routine to transparently pass the return from one routine in as the arguments to another without any modification at all?  In other words, how do you compose "properly"?

[05:48] *** cougnut left
[05:50] <sorear> japhb: you're trying to compose an octagonal peg with a round hole.

[05:50] <sorear> return values and argument lists are not quite the same thing in Perl 6; in general it doesn't make sense to "pass the return from one routine in as the argumentS to another without any modification at all"

[05:50] <japhb> sorear, nevermind how I attempted to do it.  Is it *possible* within the confines of spec'ed Perl 6?  And if so, how do you do it?

[05:51] <japhb> hmmm.  That is too bad.

[05:51] <japhb> A very subtle loss from the Perl 5 world that I would not have expected.

[05:52] <sorear> japhb: in perl 6, functions return exactly one value

[05:52] <sorear> it makes total sense to write sub compose(&f,&g) { -> |$args { f(g(|$args)) } }

[05:52] <sorear> passing the return value of g as the argument (note lack of s) to f

[05:53] <sorear> you could argue that Perl 6 is actually working better here, because you can't write a wantarray-transparent composition in perl 5

[05:53] <sorear> try not to think of return $f, $g as returning two values, because it's not.  it's sugar for list construction

[05:56] <japhb> But if g() can only ever return one thing, but f() can take an arbitrary number of things, then the only general composition would be to always flatten the return of g(), I would think

[05:56] <japhb> And if f() wanted to not have that happen, then it would declare :(|$args) as its signature

[05:56] <sorear> japhb: that fails to be a general composition, for reasons I have already tried to explain.

[05:57] *** cougnut joined
[05:58] <sorear> flattenning is a lossy operation, because it tries to DWIM

[05:59] <japhb> sorear, then essentially there is no general composition, right?  Because you cannot have an external composer that will arbitrarily compose any two Perl 6 subs that *do not know they might be composed*, and thus do not follow a special protocol to make it possible.

[06:00] *** cougnut left
[06:00] *** cougnut joined
[06:01] <sorear> japhb: how would you write a "general composer" in Pytoh?

[06:02] <japhb> Hmmm, come to think of it, you've actually said that it doesn't make sense to even ask, because if a routine can only ever return one thing, there is no sensical way in which one can losslessly pretend it returns an arbitrary number of things.

[06:05] <TimToady> that depends entirely on how g binds it

[06:05] <japhb> sorear, I wouldn't, since I don't speak Python (I only read it).  In a stack language, however, it's trivial.

[06:05] <TimToady> if g binds it as a slurpy, if flattens again

[06:05] *** orafu left
[06:05] *** orafu joined
[06:06] <sorear> it's a fairly common pattern in expressionist languages like Perl that a function call is an expression, so a function needs to return values from the same semantic universe as single terms

[06:07] <japhb> TimToady, I'm confused.  Did you mean g or f?

[06:07] *** koban` joined
[06:07] <TimToady> oh, f is on the outside, so f

[06:07] <sorear> there has been some speculation that Perl 6 should allow returning general Captures, with special binding support; but this would not count as "without any modification at all"

[06:08] <japhb> TimToady, ah, OK, yes, I follow you there.

[06:08] <sorear> personally I lean towards forcing the user to explicitly return a Capture object if ey wants a Capture-style return

[06:09] <japhb> sorear, as opposed to letting the caller specify "I want to get a capture back from you"?

[06:09] <sorear> japhb: wantarray is long dead.

[06:10] <japhb> sorear, I spoke poorly.

[06:11] <sorear> (there has been some speculation about reviving wantarray to support sink contexts, but everything about sink context is currently well into speculation)

[06:11] <worr> sorear: what's the perl6 replacement for wantarray()?

[06:12] <japhb> I meant, as opposed to letting the caller specify: "Perl, instead of handing me back whatever the callee thought it was going to send, I want you to build and return a raw Capture instead"?  I was asking if that was the opposing position to the "lean towards forcing the user to explicitly return a Capture object if ey wants a Capture-style return".  I wasn't sure what the opposing viewpoint to yours actually was.

[06:12] <sorear> japhb: oh!  sorry, I'm half asleep.

[06:12] <japhb> sorear, np!

[06:13] <sorear> japhb: the opposing viewpoint was to consider &return as (notionally) creating a Capture object in all cases

[06:13] <japhb> ah, ok

[06:14] * sorear starts to observe that most languages have the octagonal-returns circular-arguments problem in practice, even where the theory is symmetrical

[06:15] <TimToady> b: sub infix:<∘> (&f, &g --> Block) { -> \$args { f g |$args } }; say ~(&reverse ∘ &ords)("abc")

[06:15] <p6eval> b 1b7dd1: OUTPUT«99 98 97␤»

[06:15] <TimToady> note the passing of a list from ords to reverse

[06:15] <sorear> Haskell culture dictates functions that accept multiple arguments curried but return tuples, so composing stuff often requires liberal application of uncurry and other combinators

[06:16] <sorear> Scheme allows return lists with (values), but it isn't used all that much, and there is a strong bias towards designing functions to return exactly one value

[06:17] <japhb> b: say (ords("abc")).WHAT

[06:17] <p6eval> b 1b7dd1: OUTPUT«List()␤»

[06:17] *** araujo left
[06:17] <japhb> nom: say (ords("abc")).WHAT

[06:17] <p6eval> nom 8453ed: OUTPUT«List()␤»

[06:18] <sorear> when I say "list" I mean something that can be put on the right side of my @foo = ... and have it DWIM

[06:18] <sorear> this is simultaneously more and less general than simply "object that ~~ List"

[06:18] <japhb> b: say &reverse.signature.perl

[06:18] <p6eval> b 1b7dd1: OUTPUT«get_attr_str() not implemented in class 'Perl6MultiSub'␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[06:18] <sorear> japhb: (*@items)

[06:19] <japhb> heh, p6eval.sorear FTW

[06:19] <TimToady> context is applied lazily in Perl 6 at binding time

[06:19] *** araujo joined
[06:19] <TimToady> so you can't know whether your return value will be in scalar or list context, because it would require time travel

[06:20] <TimToady> well, in the general case; specific cases may be analyzable

[06:20] <sorear> all contexts in P6 work approximately like string/numeric/boolean context does in Perl 5

[06:20] <sorear> dictated by the consumer, using type-sensitive overloadable methods

[06:21] <sorear> although p6 doesn't have any of the syntactic boolean oddities that p5 does (yet?)

[06:21] <japhb> TimToady: so your composition example is working because &reverse has a flattening single argument signature, rather than a more general multiple scalar signature, for example.

[06:22] <TimToady> the slurpy signature doesn't care how many arguments there are

[06:22] <TimToady> it has one formal parameter, if that's what you mean

[06:22] <japhb> TimToady, yes, that's what I meant, and said badly (I'm pretty tired myself. :/) 

[06:23] <sorear> TimToady is on my time zone fwiw

[06:23] <sorear> though I guess he could still be on German Perl Workshop sleepphase, if he went

[06:23] <japhb> As am I, IIRC.  I just have had crappy sleep several days running, so I'm bleary.

[06:24] <TimToady> with me, it's usually just brane damaje :)

[06:24] <japhb> And yet, the Pun Center of the brain seems to still work fine ...

[06:24] <TimToady> -Opun

[06:25] <sorear> japhb: f g ... works for f=reverse because (*@items) knows what to do with a single argument

[06:25] <japhb> sorear, right.

[06:25] <sorear> japhb: a signature like ($f,$g,$h) would work well with f |g ... instead

[06:26] <japhb> sorear, that makes me wonder if the general composer is actually just two forks that introspects f: if it has only one argument, pass it without flattening.  Otherwise, flatten in passing.

[06:26] <japhb> sorry, only one *parameter

[06:27] <japhb> wow, my English really is a mess right now

[06:27] <TimToady> a general composer would probably do currying like Haskell, and require geniuses to program it

[06:27] <sorear> japhb: that might be a useful approximation.  I doubt it would DWIM in all cases, and I lack the creativity ATM to decide

[06:28] * TimToady would like to make a withdrawal from the creativity ATM

[06:28] <japhb> My mental block is that when I went off to "learn a language from another paradigm", I chose Forth.  And if you asked a Forth guy how to do proper composition, he'd look at you as if you asked how you ensured that gravity was working tomorrow.

[06:29] <TimToady> well, note that the reverser ords case would still work with a | composer

[06:30] <TimToady> b: sub infix:<∘> (&f, &g --> Block) { -> \$args { f |g |$args } }; say ~(&reverse ∘ &ords)("abc")

[06:30] <p6eval> b 1b7dd1: OUTPUT«99 98 97␤»

[06:30] <TimToady> whew! :)

[06:31] <TimToady> that would be a more p5ish composer

[06:31] <japhb> I guess I kinda came at it from a P5 angle, didn't I?

[06:32] <TimToady> so did I, so did I... :)

[06:32] <TimToady> but the angle has changed a few times since then...

[06:32] <japhb> Not surprising I suppose, since I do it all day ...  :-)

[06:32] <japhb> heh

[06:33] <sorear> japhb: you might think of forth as having a one-dimensional mindset here

[06:34] <sorear> in forth, it's not so easy to write something like f(g(x), h(x)), especially when x is a multi-cell object

[06:34] <sorear> Perl is much more tree-concious

[06:35] <sorear> (all user-level languages without built-in garbage collection need to be forgotten ASAP)

[06:37] <japhb> .oO( : i dup h swap g f ; )  # Which of course only works if x is a single cell, as you point out

[06:37] <sorear> well, 2dup and 2swap exist.

[06:38] <sorear> but the lack of type encapsulation makes that not extend very well

[06:38] <japhb> sorear, sure, but the underlying assumption is a fixed size of x.

[06:38] <japhb> right

[06:38] <japhb> You pretty much have to assume x is an address to the thing you really want, and g and h both want addresses.

[06:39] <japhb> Oh, hum, and I assumed that h *returns* only 1 cell.  Heh, silly me.

[06:40] <japhb> Oh dear, if I keep down this path, I'll end up porting my Perl 5 Forth interpreter to Perl 6 ....  I'm not so sure that could be strictly classified as sane.

[06:40] <sorear> it's funny, I can remember *writing* at least two forths but I can't remember actually using one

[06:41] * japhb resembles that remark

[06:41] <TimToady> .oO(go forth and multiply...)

[06:42] <japhb> I will say that I understood a *LOT* more of what VM people discuss after writing a Forth.  And also got somewhat depressed when reading about some VM or other finally moving forward to the Forth state of the art circa when I was born.

[06:44] <japhb> Anyway, thank you sorear++ and TimToady++ for a damn fine conversation.

[06:44] <japhb> On that note, I think I shall retire for the night.

[06:46] <sorear> if Forth were designed today, I would insist on it having strong(er) typing, garbage collection, and higher-order functions

[06:46] <sorear> sleep well

[06:48] *** araujo left
[06:48] *** bakedb__ left
[06:49] *** araujo joined
[06:50] *** bakedb__ joined
[06:51] *** ZapZ_ left
[06:55] *** bakedb__ left
[07:00] *** mj41 joined
[07:01] *** araujo left
[07:02] *** envi_laptop left
[07:06] *** araujo joined
[07:07] *** bakedb__ joined
[07:16] *** araujo left
[07:17] *** araujo joined
[07:24] * sorear out

[07:31] *** uasi left
[07:35] *** woosley left
[07:47] *** araujo left
[07:48] *** araujo joined
[07:56] *** toebu joined
[08:02] *** stu joined
[08:06] *** stu left
[08:06] *** uasi joined
[08:06] *** bakedb__ left
[08:07] *** ountscu joined
[08:07] <ountscu> o/;\o

[08:10] <ountscu> hi monks!a problems~~ how to fix this when compile nqp,I got an error :get_pointer() not implemented in class 'GLOBALish'

[08:13] *** araujo left
[08:14] *** araujo joined
[08:15] *** birdwindupbird left
[08:16] *** birdwindupbird joined
[08:17] <moritz> ountscu: hi. Which parrot revision are you using?

[08:19] <ountscu>  Parrot version 3.8.0-devel built for amd64-linux

[08:20] <moritz> ountscu: nqp currently requires 3.8.0 (released version). For newer parrots you need to use the kill-useless-defaults branch of nqp

[08:23] <ountscu> a new nqp branch? I never notice it before. thanks!!

[08:23] <moritz> it's only a day or two old

[08:23] <moritz> and will be merged into master after the rakudo release

[08:26] <ountscu> looks like a newborn baby? when will  release the new  rakudo?

[08:26] <moritz> tomorrow, probably

[08:27] <ountscu> what's new about the new release? 

[08:27] <moritz> lots of things :-)

[08:27] <moritz> a new meta object model

[08:27] <moritz> improved speed

[08:27] <moritz> better enums, better parameterized roles, ...

[08:28] <moritz> see the top of https://github.com/rakudo/rakudo/blob/nom/docs/ChangeLog

[08:32] <ountscu> excellent!I can't wait to try it.thanks !moritz!

[08:36] *** araujo left
[08:37] *** ountscu left
[08:42] <jnthn> morning, #perl6

[08:43] <moritz> morning jnthn 

[08:44] *** dakkar joined
[08:48] *** daxim joined
[08:48] <jnthn> pir::find_encoding__is(nqp::unbox_s(pir::perl6_decontainerize__PP($encoding)))

[08:49] <jnthn> hmm...I thought nqp::unbox_s would already decontainerize...maybe not

[08:49] <moritz> if it does, I can simplify some of my code quite a bit :-)

[08:49] <jnthn> inline op repr_unbox_str(out STR, in PMC) :base_core { PMC *var = decontainerize(interp, $2);

[08:49] <jnthn> Yes, looks like it does.

[08:49] <moritz> \o/

[08:49] <jnthn> getattr does not.

[08:50] <moritz> ah right, you sometimes want to access the attribute of a container, but you never want to unbox it :-)

[08:50] <jnthn> Aye

[08:52] *** araujo joined
[09:01] <mls_> morning perl6!

[09:03] <Woodi> moritz: :) help

[09:04] <moritz> Woodi: what can I do you for?

[09:04] <Woodi> i just tried test why IO::Socket::INET hangs for me and stuck on .new...

[09:04] <moritz> waitwaitwait

[09:04] <moritz> start from the beginning

[09:04] <moritz> which version of rakudo are you using?

[09:04] <Woodi> k

[09:05] <Woodi> how to write: my $s = IO::Socket::INET.new( $host, $port);

[09:05] <moritz> my $s = IO::Socket::INET.new( :$host, :$port);

[09:05] <Woodi> :$host, :$port was working yesterday for me :) Star here

[09:06] <mls_> (strace is your friend ;) )

[09:06] <moritz> which star?

[09:06] <moritz> perl6 --version

[09:07] <Woodi> This is Rakudo Perl 6, version  built on parrot 3.6.0 0

[09:08] <Woodi> problem is i have module where it works but new file test-recv.pl do not :)

[09:10] <Woodi> http://pastebin.com/D3aUM9q0

[09:10] <moritz> I think somebody reported that recv hangs

[09:12] *** araujo left
[09:12] <Woodi> i have problem before recv and send... .new fails. and something listens on the port

[09:12] <Woodi> i use 'get' line by line for now

[09:13] <moritz> how does it fail?

[09:13] *** araujo joined
[09:13] <Woodi> .send not def on Failure

[09:14] <Woodi> possible I::S::I need to be instantiated in class ?

[09:14] <moritz> my  $s = IO::Socket::INET.new( :$h, :$p ) or die();

[09:14] <moritz> that's wrong

[09:15] <moritz> the names of parameters are 'host' and 'port', not 'h' and 'p'

[09:15] <moritz> so use

[09:15] <moritz> .new(host => $h, port => $p)  or so

[09:15] <tadzik> jnthn: why in candidates-matching checker() is a sub, and not just inlined there?

[09:15] <tadzik> good morning channel

[09:16] <Woodi> damn

[09:17] <Woodi> ok, recv (without buf) hangs...

[09:17] *** robinsmidsrod left
[09:18] <Woodi> thanx, cannot grasp params for %args...

[09:20] <moritz> $ echo "foo"| ./perl6 -e 'say $*IN.read(2).list.perl'

[09:20] <moritz> Array.new(102, 111)

[09:20] <Woodi> btw. in perl5 using hash as param was much slower (if i understund correct), and thats AnyEvent autor wroted additional API without %. how in perl6 ?

[09:20] <moritz> \o/

[09:21] <tadzik> \o/

[09:21] <moritz> Woodi: the problem in perl 5 was that hashes were flattened into argument lists, and later needed to be reconstructed

[09:21] <moritz> Woodi: that problem doesn't exist in Perl 6 anymore

[09:21] <Woodi> ah, k :)

[09:22] <moritz> if you declare a hash, and pass in a hash, it's pass-by-reference

[09:22] <moritz> (but write protected)

[09:22] <Woodi> just by-pointer-access

[09:22] <Woodi> in C terms

[09:22] <moritz> yes

[09:23] <jnthn> tadzik: To want a context without the invocant.

[09:23] <jnthn> s/want/get/

[09:24] *** uasi left
[09:24] <dalek> rakudo/nom: 5a5f068 | moritz++ | / (4 files):

[09:24] <dalek> rakudo/nom: implement basic, cheating Buf

[09:24] <dalek> rakudo/nom: 

[09:24] <dalek> rakudo/nom: The "cheat" part is that it is actually a Buf8, not something

[09:24] <dalek> rakudo/nom: that can store arbitrary integers

[09:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a5f068f09

[09:24] <dalek> rakudo/nom: f516563 | moritz++ | src/core/IO.pm:

[09:24] <dalek> rakudo/nom: IO.read

[09:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f516563aad

[09:24] <dalek> rakudo/nom: 1186484 | moritz++ | src/core/Buf.pm:

[09:24] <dalek> rakudo/nom: simplify some Buf code, jnthn++

[09:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1186484e13

[09:33] *** replore_ left
[09:34] *** cotto left
[09:36] <moritz> $ ./perl6 -e '$*OUT.write(Buf.new(1, 2))'|hexdump -C

[09:36] <moritz> 00000000  01 02                                             |..|

[09:36] *** replore_ joined
[09:36] <jnthn> nice :)

[09:36] <jnthn> moritz++

[09:37] <moritz> hacking on Buf is fun!

[09:37] <moritz> I know the tools for interfacing with parrot PMCs well enough these days

[09:37] <dalek> rakudo/nom: be999e7 | moritz++ | src/core/IO.pm:

[09:37] <dalek> rakudo/nom: IO.write(Buf)

[09:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/be999e79d0

[09:37] <moritz> and I get good encapsulation between rakudo and parrot

[09:38] <moritz> evalbot rebuild nom

[09:38] <p6eval> OK (started asynchronously)

[09:38] *** uasi joined
[09:38] <moritz> nom: say (23, 56, 8).fmt('%02x', ' '(

[09:38] <p6eval> nom 8453ed: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[09:38] <moritz> nom: say (23, 56, 8).fmt('%02x', ' ')

[09:39] <p6eval> nom 8453ed: OUTPUT«17 38 08␤»

[09:39] <jnthn> For the nom version of Zavolaj, I'm thinking about switching over to the lowercase types.

[09:39] <jnthn> So that we can do sized types also.

[09:40] * moritz wonders how to best .gist a Buf

[09:40] <moritz> I though of Buf:0x<a0 f3 08>

[09:40] <moritz> or maybe something more like hexdump output

[09:41] <moritz> Buf:<Stra.e>   and then some form of hex representation afterwards

[09:41] *** araujo left
[09:43] *** araujo joined
[09:43] *** araujo left
[09:43] *** araujo joined
[09:43] <jnthn> Some kind of hex dump is perhaps most useful.

[09:44] <moritz> I'll go with hex only for now, and think about cleverer solutions later

[09:47] *** jferrero left
[09:54] <dalek> rakudo/nom: 56df3d9 | moritz++ | src/core/Buf.pm:

[09:54] <dalek> rakudo/nom: Buf.gist, eqv for Buf

[09:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/56df3d93eb

[09:56] <dalek> rakudo/nom: 5a7752c | moritz++ | NOMMAP.markdown:

[09:56] <dalek> rakudo/nom: update NOMMAP

[09:56] <dalek> rakudo/nom: 

[09:56] <dalek> rakudo/nom: Buf is now "good enough" (I hope) to be removed from the punch list,

[09:56] <dalek> rakudo/nom: and the segfault in mandelbrot-color is long gone

[09:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a7752cb23

[09:56] <moritz> jnthn: are WhateverCode closures cheaper than ordinary blocks in any way?

[09:56] <moritz> (I suspect they might not need $_)

[09:59] <moritz> nom: say (1, 1, 2) <<+>> (1, 2)

[09:59] <p6eval> nom be999e: OUTPUT«2 3 3␤»

[09:59] <moritz> nom: say (1, 1, 0, 0) <<+>> (1, 2)

[09:59] <p6eval> nom be999e: OUTPUT«2 3 1 2␤»

[10:00] *** SHODAN left
[10:05] <moritz> nom: say (1 xx -2).perl

[10:05] <p6eval> nom be999e: OUTPUT«().list␤»

[10:05] *** araujo left
[10:06] *** araujo joined
[10:09] <jnthn> moritz: Yes, they are a bit cheaper.

[10:09] <jnthn> moritz: They don't get the $_.

[10:11] <moritz> rakudo: say ~^5

[10:11] <p6eval> rakudo be999e: OUTPUT«0 1 2 3 4␤»

[10:11] <moritz> uhm, what's bitwise negation?

[10:11] <flussence> +~ ?

[10:11] <moritz> I meant stringy bitwise negation, sorry

[10:12] <flussence> rakudo: say ~^ 5

[10:12] <p6eval> rakudo be999e: OUTPUT«0 1 2 3 4␤»

[10:12] <flussence> hm, it's not that...

[10:13] <moritz> S03:687 says it should be ~^

[10:13] <flussence> rakudo: say ~^ "5"

[10:13] <p6eval> rakudo be999e: OUTPUT«0 1 2 3 4␤»

[10:13] <flussence> argh

[10:13] <Woodi> which nom branch i need for 'rakudo-dev' atm ?

[10:13] <moritz> ah, but the grammar knows only of infix:<~^>, not of prefix

[10:13] <moritz> Woodi: nom

[10:14] <Woodi> thanx

[10:17] <moritz> b: say ~^'foo'

[10:17] <p6eval> b 1b7dd1: OUTPUT«No applicable candidates found to dispatch to for 'prefix:<~^>'. Available candidates are:␤:(Buf $a)␤␤  in main program body at line 22:/tmp/dNcMTW4qAg␤»

[10:17] <snarkyboojum> how does stringy bitwise negation work?

[10:18] <moritz> 1) assume a bit width   2) negate

[10:19] <snarkyboojum> doesn't seem like a very clear concept, considering we don't know the bits which constitute a string

[10:19] <snarkyboojum> assume a bit width?

[10:19] <moritz> well, if you only have Latin-1, you can just subtract each codepoint from 255

[10:19] <moritz> that would be 8 bit width

[10:19] <snarkyboojum> so depends on the current char encoding eh?

[10:20] <moritz> S03:687 has a bit on that

[10:21] <moritz> "The use of coercion probably indicates a design error" :-)

[10:21] <snarkyboojum> seems dodgy to me ;)

[10:22] <moritz> also note that it returns a Buf, not a Str

[10:22] <moritz> so it doesn't round-trip

[10:22] * moritz proposes an alternative algorithm

[10:23] <moritz> chose a random number at least as high as the highest assigned codepoint

[10:23] <moritz> subtract the codepoints from that

[10:23] <moritz> and... have fun!

[10:23] * moritz -> lunch, or so

[10:24] *** cotto joined
[10:24] *** koban` left
[10:28] <Woodi> but how actualy to get nom branch of https://github.com/perl6/nqp.git ? only match-nom and it seems to be old. or other repo ?

[10:28] <dalek> rakudo/nom: 909cc3c | moritz++ | src/ (2 files):

[10:28] <dalek> rakudo/nom: parse prefix:<~^>, and implement it for Buf

[10:28] <dalek> rakudo/nom: 

[10:28] <dalek> rakudo/nom: also add Buf.elems

[10:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/909cc3c689

[10:28] <bbkr> Buf and Str.encode in NOM! santa clause has come early this year :)

[10:28] <moritz> Woodi: use master

[10:29] <moritz> (my fellow lunch nommers aren't ready yet...)

[10:29] <Woodi> oki

[10:30] *** espadrine joined
[10:30] <Woodi> compilation fails with called from Sub '_block1000' pc 196 (src/stage0/NQP-s0.pir:102) (src\stage2\gen\NQP.pm:1) in src/stage1/nqpmo.pbc

[10:31] <moritz> Woodi: which parrot do you have?]

[10:31] <moritz> Woodi: and what's the error before the one you just pasted?

[10:32] <Woodi> i use perl Configure.pl --with-parrot=/opt/perl6/bin/parrot (just compiled parrot 3.8.0)...

[10:32] <moritz> the best way to build rakudo/nom is to 'git checkout 'nom' in the parrot branch, and then do   perl Configure --gen-parrot && make

[10:32] <moritz> hm, 3.8.0 should be fine

[10:32] <Woodi> i hate --gen-*...

[10:32] <moritz> (later development versions are not good)

[10:33] <Woodi> so i need 'nom' branch in parrot not github-nqp-master ?

[10:34] *** im2ee joined
[10:34] <Woodi> lunch is good idea...

[10:34] <im2ee> Hello! :)

[10:40] <tadzik> hello

[10:41] *** araujo left
[10:42] *** araujo joined
[10:42] *** araujo left
[10:42] *** araujo joined
[10:45] *** envi joined
[10:49] <bbkr> https://rt.perl.org/rt3/Ticket/Display.html?id=96430 (worth quick-implementing if Buf is already today's topic)

[10:52] <dalek> rakudo/nom: 9a2f7fc | jnthn++ | src/Perl6/Metamodel/NativeHOW.pm:

[10:52] <dalek> rakudo/nom: Make Int ~~ int and various other things on native type objects not explode.

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a2f7fcac7

[10:52] <dalek> rakudo/nom: 1e27868 | jnthn++ | src/Perl6/Metamodel/NativeHOW.pm:

[10:52] <dalek> rakudo/nom: NativeHOW should just compose MROBasedTypeChecking, not do its own thing.

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e27868704

[10:52] <dalek> rakudo/nom: 6a20116 | jnthn++ | src/Perl6/Actions.pm:

[10:52] <dalek> rakudo/nom: Basic support for an argument with trait_mod:<is>.

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6a20116466

[10:52] <dalek> rakudo/nom: 6eee0ca | jnthn++ | src/ (3 files):

[10:52] <dalek> rakudo/nom: Stub in a few sized natives. No associated functionality yet.

[10:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6eee0caab4

[10:54] *** benabik left
[11:02] <JimmyZ> does num32 is Int  right ?

[11:04] *** uasi left
[11:05] *** araujo left
[11:05] *** araujo joined
[11:06] <snarkyboojum> JimmyZ: does that depend on the machine word size

[11:06] *** masak joined
[11:06] <Woodi> is it possible to 'tie' scalar like in p5 to increment on access ? eg: my $i=0; v6tie( $i) {...}; say "0: $i"; say "1: $i";

[11:06] <masak> im2ee: I have an even shorter solution to the problem from yesterday :)

[11:07] <flussence> I'm at a complete loss what's wrong here... the method on line 7 never gets called: https://github.com/flussence/Pod-Tree-Walker/blob/master/lib/Pod/Tree/Walker.pm

[11:07] <flussence> (and no error)

[11:07] <masak> im2ee: namely, just generate all possible strings from the regex /<[abc]> ** 1..4/ -- a kind of "reverse regex matching", as it were.

[11:08] <masak> im2ee: there's no mechanism to do that in Perl 6 itself, but it can easily be provided through a module.

[11:08] <JimmyZ> jnthn: there may be some typo in 6eee0ca 

[11:09] <im2ee> masak, could You show me this?

[11:11] <dalek> rakudo/nom: 60e9ad7 | jnthn++ | src/core/natives.pm:

[11:11] <dalek> rakudo/nom: Fix copy-paste fail noticed by JimmyZ++.

[11:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/60e9ad7b4d

[11:13] <Woodi> flussence: you try without declare recurse-node without Pod::Block type ?

[11:13] <Woodi> s/wihout//

[11:13] <Woodi> whatever :)

[11:14] <tadzik> flussence: I get a PASS

[11:15] <flussence> tadzik: does it at least print out that "In recurse" bit?

[11:16] <tadzik> flussence: nah, doesn't seem so :/

[11:16] <flussence> I think I figured it out...

[11:17] <flussence> yep, it's that multi bug from yesterday...

[11:17] <jnthn> flussence: Got a link to the nopaste handy?

[11:18] <flussence> the one from yesterday?

[11:18] <jnthn> yes

[11:18] <flussence> https://gist.github.com/1232212

[11:21] *** uasi joined
[11:21] *** replore_ left
[11:22] <masak> im2ee: only an earlier example of the same that I made a few months back: https://gist.github.com/908829

[11:22] <masak> but the principle is the same.

[11:23] <masak> that script prints 36 different strings on the form 'henning', 'manall', 'menkell', etc.

[11:25] <jnthn> flussence: Did you file an RT ticket?

[11:26] <im2ee> ok :)

[11:29] <masak> im2ee: so a solution could be as simple as `use GGE; .say for generate GGE::Perl6Regex.new('<[abc]> ** 1..4').exp`

[11:29] <flussence> I've been trying to avoid making Yet Another Website Account, but if you really want me to... :)

[11:29] <jnthn> flussence: You don't have to

[11:29] <jnthn> You just send an email.

[11:29] <jnthn> flussence: I have a patch, I just want a ticket to make sure it gets tests.

[11:29] <flussence> whoa, didn't know that

[11:29] <im2ee> masak++, thanks. :)

[11:29] <flussence> will do

[11:30] <jnthn> masak++ probably knows the address off by heart too :P

[11:32] <flussence> ooh, will this "perlbug" program work for perl6 bugs?

[11:32] <jnthn> not afaik

[11:32] <flussence> aww

[11:32] <dalek> rakudo/nom: e5fab7f | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[11:32] <dalek> rakudo/nom: Fix generic instantiation bug that led to over-sharing of dispatchee lists.

[11:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5fab7fdf6

[11:33] <jnthn> flussence: e5fab7f should fix your issue

[11:33] <flussence> \o/

[11:33] * moritz comes back from lunch and sees patches. o/

[11:33] <flussence> (hm, I *could* add the test myself...

[11:34] <jnthn> flussence: That also works :)

[11:34] <JimmyZ> nom: say int

[11:34] <p6eval> nom 909cc3: OUTPUT«No method cache and no find_method method in meta-object␤  in sub say at src/gen/CORE.setting:4811␤  in <anon> at /tmp/uGMdrkqv8l:1␤  in <anon> at /tmp/uGMdrkqv8l:1␤␤»

[11:35] <jnthn> JimmyZ: Fixed that one earlier today, but p6eval didn't rebuild yet. :)

[11:35] <JimmyZ> loop {  jnthn++; sleep 1; }

[11:36] *** Psyche^ joined
[11:36] <jnthn> flussence: Long story short, it was a bug in proto auto-generation, but the underlying issue was actually in the mechanism I built the auto-gen on.

[11:38] <flussence> looks a bit more involved than I'd imagined it... I thought it was just forgetting to check the multi name :)

[11:39] <jnthn> No, it was quite deep.

[11:40] *** Patterner left
[11:40] *** Psyche^ is now known as Patterner

[11:45] *** JimmyZ left
[11:45] <masak> jnthn: what [email@hidden.address] ? :)

[11:45] <jnthn> :)

[11:45] <masak> I do, but I usually rely on tab completion.

[11:46] <jnthn> see! :)

[11:46] <masak> 'r' <Tab>

[11:51] <masak> perl6: try { die "OH NOES"; CATCH { say $! } }

[11:51] <p6eval> pugs:  ( no output )

[11:51] <p6eval> ..rakudo 909cc3, niecza v9-32-g380d891: OUTPUT«Any()␤»

[11:51] <masak> b: try { die "OH NOES"; CATCH { say $! } }

[11:51] <flussence> t/spec/S12-methods/multi.rakudo dies at test 5 for me, anyone else seeing that?

[11:51] <p6eval> b 1b7dd1: OUTPUT«OH NOES␤»

[11:51] <masak> sorear: I think b is correct here.

[11:52] <masak> sorear: want me to submit a nieczabug?

[11:52] <moritz> the spec on exceptions is still very vague

[11:52] <jnthn> masak: TimToady said the other day that $! doesn't contain the current exception in CATCH

[11:52] <jnthn> masak: At lesat, afaik

[11:53] <jnthn> masak: So, nom and niecza are probably right.

[11:53] <jnthn> masak: Look in $_

[11:53] *** pernatiy left
[11:53] <jnthn> masak: Rationale is that the body of CATCH is implicitly a loop, iiuc.

[11:54] <masak> ok.

[11:54] <masak> makes some sense, yes.

[11:54] <masak> perl6: try { die "OH NOES"; CATCH { .say } }

[11:55] <p6eval> niecza v9-32-g380d891: OUTPUT«OH NOES␤»

[11:55] <p6eval> ..pugs:  ( no output )

[11:55] <p6eval> ..rakudo 909cc3: OUTPUT«Any()␤»

[11:55] <masak> niecza++

[11:55] <jnthn> Hopefully the in-development mls++ patch will help nom there.

[11:55] <masak> though if we're talking about Least Surprise, $! is definitely where it should be. I don't think it's just me.

[11:55] <tadzik> I'd expect $! too

[11:56] <tadzik> why wouldn't it be there?

[11:56] <jnthn> Note that

[11:56] *** donri joined
[11:56] <jnthn> try { die "OH NOES" }; say $! # should be OH NOES

[11:56] <tadzik> yes

[11:56] <moritz> flussence: multi.rakudo dies after test 16 here, and has a few failures before

[11:57] *** woosley joined
[11:57] <jnthn> huh, I got a clean spectest run...

[11:58] <jnthn> oh, no wonder, it's commented out in spectest.data.

[11:58] <moritz> ah :-)

[11:59] <jnthn> It's correct that it does

[11:59] <jnthn> *dies

[11:59] <jnthn> The test file is wrong with regard to the new proto spec.

[11:59] <masak> perl6: say sprintf "<%10s>", "foo"

[11:59] <p6eval> niecza v9-32-g380d891: OUTPUT«<foo>␤»

[11:59] <p6eval> ..pugs, rakudo e5fab7: OUTPUT«<       foo>␤»

[11:59] * masak submits nieczabug

[12:03] <jnthn> hmm...this test file is kinda crufty.

[12:03] <moritz> bbkr: this commit should make you happy....

[12:04] <dalek> rakudo/nom: 2466044 | moritz++ | src/core/IO/Socket.pm:

[12:04] <dalek> rakudo/nom: IO::Socket.read (returns Buf)

[12:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2466044f25

[12:05] <bbkr> moritz++ !

[12:05] <moritz> bbkr: it would be nice if you could test it with non-ASCII chars

[12:06] <masak> moritz++

[12:06] <jnthn> moritz++

[12:07] *** satyavvd left
[12:08] *** bakedb joined
[12:08] *** am0c left
[12:09] <dalek> roast: a28816d | jnthn++ | S12-methods/multi.t:

[12:09] <dalek> roast: Fix one of the many issues in S12-methods/multi.t; needs a good going over due to new dispatch semantics.

[12:09] <dalek> roast: review: https://github.com/perl6/roast/commit/a28816db93

[12:11] *** robinsmidsrod joined
[12:11] <bbkr> moritz: building patched rakudo right now...

[12:11] *** araujo left
[12:11] <moritz> bbkr: no hurry (but of course I don't object to quick feedback :-) )

[12:12] *** araujo joined
[12:13] <dalek> roast: e17926a | jnthn++ | S12-methods/multi.t:

[12:13] <dalek> roast: Toss some incorrect deferral tests; we test that properly in more appropriate test files.

[12:13] <dalek> roast: review: https://github.com/perl6/roast/commit/e17926a837

[12:13] <flussence> I've golfed down the paste to a pretty small test file - is there a good place to stick that or should I hold off until the rest of multi.t works?

[12:15] <dalek> roast: 42b0117 | jnthn++ | S12-methods/multi.t:

[12:15] <dalek> roast: Fudge a few tests; now this runs on nom.

[12:15] <dalek> roast: review: https://github.com/perl6/roast/commit/42b0117cad

[12:15] <flussence> there's my answer :)

[12:15] <jnthn> :)

[12:17] <Woodi> my $resp = $!sock.get(); my $len = substr( $resp, 1, $resp.bytes - 2 ); $resp = $!sock.recv( $len ); # expected Int but got Str instead

[12:18] <Woodi> no Str -> Int conversion ? 

[12:18] <Woodi> automagic one...

[12:18] <moritz> Woodi: we probably should have. Use $len.Int for now

[12:18] <Woodi> oki

[12:19] <jnthn> not Cool

[12:19] <jnthn> :P

[12:20] * [Coke] stares at you over his coffee.

[12:20] <dalek> rakudo/nom: 42abf87 | jnthn++ | t/spectest.data:

[12:20] <dalek> rakudo/nom: Run S12-methods/multi.t.

[12:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/42abf8785b

[12:21] <moritz> nom: sub f(Cool $x as Int = 3) { say $x }; f

[12:21] <p6eval> nom e5fab7: OUTPUT«3␤»

[12:22] <dalek> roast: d7c5956 | jnthn++ | S12-methods/multi.t:

[12:22] <dalek> roast: Unfudge 3 tests that nom passes that master did not.

[12:22] <dalek> roast: review: https://github.com/perl6/roast/commit/d7c595615b

[12:22] <moritz> bbkr: would you be fine with changing $.liste in IO::Socket::INET from Int to Bool?

[12:23] <dalek> roast: d218bab | flussence++ | S12-methods/multi.t:

[12:23] <dalek> roast: Add a test for the fix in rakudo e5fab7f

[12:23] <dalek> roast: review: https://github.com/perl6/roast/commit/d218bab85d

[12:24] <flussence> ooh, I just figured out a neat trick - "git rebase origin/master" gets rid of noise from trivial merge commits

[12:25] <moritz> flussence: that's what git pull --rebase  does

[12:25] <jnthn> I use...what moritz said :)

[12:25] <moritz> you can even alias  pr = pull --rebase   or so

[12:25] * flussence goes and does that right away since I'll probably forget it later :)

[12:26] <bbkr> moritz: Bool $.listen seems more correct

[12:26] *** JimmyZ joined
[12:28] *** benabik joined
[12:31] *** koban` joined
[12:33] <moritz> bbkr: I've made it a Bool, but the constructor coerces to Bool, so that old code with :listen(1) will continue to work

[12:33] <dalek> rakudo/nom: 8ba1a33 | moritz++ | src/core/IO/Socket (2 files):

[12:33] <dalek> rakudo/nom: [IO] accept Cool args; $.listen is now Bool

[12:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ba1a3375c

[12:33] <moritz> Woodi: there you have the automagic Str -> Int conversion :-)

[12:35] *** araujo left
[12:36] <JimmyZ> rakudo:  multi trait_mod:<is>($t,  :$ne!) { say $ne; } ;  my native f is ne { }

[12:36] <p6eval> rakudo e5fab7: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $type, Any $size, Any $nativesize)␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Par…

[12:37] <jnthn> JimmyZ: Need a Mu on that $t

[12:37] *** araujo joined
[12:37] <JimmyZ> oh yes, thanks

[12:39] * JimmyZ wonders how to use  multi trait_mod:<is>(Mu $t, $b, $d,  :$ne!) { say $b; } ;

[12:39] <jnthn> You don't.

[12:39] <jnthn> Different trait mods need you to write the appropraite signature.

[12:41] *** bluescreen10 joined
[12:41] <JimmyZ> I can't pass a value to :$ne ?

[12:41] <jnthn> Yes, one

[12:42] <jnthn> is my_trait(42)

[12:42] <moritz> what about my_trait(1, 2, :foo) ?

[12:42] <JimmyZ> rakudo: multi trait_mod:<is>(Mu $t, :$ne!) { say $ne; } ; my native f is ne(45) { }

[12:42] <p6eval> rakudo e5fab7: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $type, Any $size, Any $nativesize)␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Par…

[12:42] <moritz> is that supposed to work?

[12:43] <jnthn> Probably passes a parcel

[12:43] <moritz> makes sense

[12:43] <jnthn> JimmyZ: No, you need an argument

[12:43] <jnthn> Mu $t, $arg, :$ne!

[12:44] * jnthn tries to figure out how NativeCall should look in nom.

[12:44] <JimmyZ> so I can't pass a vlue to ne directly?

[12:44] <JimmyZ> *value 

[12:45] <jnthn> no

[12:46] <jnthn> It's only role is to disambiguate the dispatch.

[12:46] <jnthn> *its

[12:46] <jnthn> Note that originally we used to require you to declare a type with the role name.

[12:46] <jnthn> grr

[12:46] <jnthn> with the trait name

[12:51] <dalek> rakudo/nom: 4152d21 | moritz++ | LHF.markdown:

[12:51] <dalek> rakudo/nom: update NOMMAP

[12:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4152d21cf5

[12:51] *** espadrine left
[12:51] <JimmyZ> rakudo: multi trait_mod:<is>(Mu $t, $size, Mu $r) { say $ne; } ; Role A { ... }; my native f is A(45) { }

[12:51] <p6eval> rakudo e5fab7: OUTPUT«===SORRY!===␤No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Mu $type, Any $size, Any $nativesize)␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Routine $r, Any $default)␤:(Par…

[12:52] <Woodi> thank you moritz++ :)

[12:52] <JimmyZ> rakudo: multi trait_mod:<does>(Mu $t, $size, Mu $r) { say $ne; } ; Role A { ... }; my native f does A(45) { }

[12:52] <p6eval> rakudo e5fab7: OUTPUT«===SORRY!===␤Unable to parse $*PKGDECL definition at line 1, near "does A(45)"␤»

[12:53] <jnthn> role, not Role

[12:53] <moritz> rakudo: multi trait_mod:<is>(Mu $t, $size, :$r!) { say $size }; my $x is r(42);

[12:53] <p6eval> rakudo e5fab7:  ( no output )

[12:53] <jnthn> And we don't do variable traits just yet.

[12:53] <JimmyZ> rakudo: multi trait_mod:<does>(Mu $t, $size, Mu $r) { say $ne; } ; role A { ... }; my native f does A(45) { }

[12:53] <p6eval> rakudo e5fab7: OUTPUT«===SORRY!===␤Method 'add_role' not found for invocant of class 'Perl6::Metamodel::NativeHOW'␤»

[12:54] <moritz> and adventurous soul could backport Buf.unpack from b

[12:56] <masak> sounds like fun :)

[12:56] <masak> I might have a look at it after $dayjob

[12:58] *** ggoebel left
[13:00] *** araujo left
[13:00] *** araujo joined
[13:09] * moritz wonders if IO::Socket.recv makes sense in its current form

[13:09] *** sayu joined
[13:15] <flussence> "Looks like you failed 164 tests of 47598" # whee, database-driven tests!

[13:17] *** Holy_Cow joined
[13:17] *** Holy_Cow left
[13:19] <colomon> woah, nom is actually faster than niecza at running sin.t now!  jnthn++ mls++

[13:20] <bbkr> moritz: I've checked read on non-ascii. works superfine. except one issue - if you chop multibyte char in half you cannot extend received Buf like in previous release ($buf.contents.push(next_chunk)) as current $buf.list is a copy. This is not read() issue itself, and proper Buf ~ and ~= operators hopefully will resolve the issue in the future.

[13:20] <Woodi> moritz: do better thing, atm +- hour or two every network module is broken anyway, imo :)

[13:20] <jnthn> colomon: whoa.

[13:20] <JimmyZ> nom: say int.HOW

[13:20] <p6eval> nom 8ba1a3: OUTPUT«Method 'gist' not found for invocant of class 'Perl6::Metamodel::NativeHOW'␤  in sub say at src/gen/CORE.setting:4824␤  in <anon> at /tmp/ngVV9ELux6:1␤  in <anon> at /tmp/ngVV9ELux6:1␤␤»

[13:21] <moritz> bbkr: Buf.new($b1.list, $b2.list) should work for concatenation

[13:21] <moritz> "work"

[13:21] <moritz> as in, work around

[13:21] * moritz wonders how much list-ish and how much str-ish interface Buf should have

[13:21] <colomon> jnthn: to be far, that's including niezca's pig-like startup speed.  but still, sin.t working in 2.5 seconds on nom is pretty darned great!  seems like it was about 50 seconds last time I tried timing it...

[13:21] <jnthn> colomon: That's...quite a speed up!

[13:22] <jnthn> colomon: And yes, we probably win just on startup speed.

[13:22] <jnthn> But still, progress in right direction...

[13:22] <moritz> 4.9s here for sin.t

[13:24] <bbkr> moritz: I use this hack. but it is painfully slow. if you read data in 100 chunks without ~= operator you have to rewrite 5049 x sizeof(chunk) amount of data to new bufs.

[13:24] <JimmyZ> nom: say int.^methods().perl.say;

[13:24] <p6eval> nom 8ba1a3: OUTPUT«Method 'methods' not found for invocant of class 'Perl6::Metamodel::NativeHOW'␤  in method dispatch:<.^> at src/gen/CORE.setting:702␤  in <anon> at /tmp/OehE3UPDFv:1␤  in <anon> at /tmp/OehE3UPDFv:1␤␤»

[13:24] <colomon> running all the trig tests just took me 30.6 seconds.  \o/

[13:25] <moritz> bbkr: hm, will think about it

[13:25] <jnthn> JimmyZ: I'm not sure if you can (or should be able to) put methods on a native.

[13:25] <bbkr> moritz++

[13:26] <jnthn> JimmyZ: It doesn't really make sense. You'd never be able to call them, other than on the type object.

[13:26] <mls_> perl6: succeed;

[13:26] <p6eval> pugs: OUTPUT«*** No such subroutine: "&succeed"␤    at /tmp/Gthfd3q_tZ line 1, column 1-8␤»

[13:26] <p6eval> ..niecza v9-32-g380d891:  ( no output )

[13:26] <p6eval> ..rakudo 8ba1a3: OUTPUT«Warning␤»

[13:28] <[Coke]> jnthn++

[13:29] <mls_> hmm, I think the last test in S04-statements/try.t is wrong

[13:29] <JimmyZ> nom: int.say

[13:29] <p6eval> nom 8ba1a3: OUTPUT«int()␤»

[13:30] <mls_> at the end of the CATCH block the exception will be rethrown

[13:30] <masak> if it wasn't handled.

[13:31] <mls_> how do you define "handled"?

[13:31] <moritz> set the .handled bit

[13:32] <mls_> 1) the code doesn't do that, 2) the catch lambda in S04 sets it back to false

[13:33] <jnthn> If any of the when clauses match (including default) then we never make it to setting it back to false, however.

[13:33] <mls_> yes, but the code in the try.t test doesn't have when/default.

[13:33] <mls_> That's why I think it's wrong

[13:34] <moritz> might very well be the case

[13:34] <moritz> most of the tests are from a time before automatic rethrowing

[13:34] <mls_> niecza: { die("foo") ; CATCH {} }

[13:34] <p6eval> niecza v9-32-g380d891: OUTPUT«Unhandled exception: foo␤  at /home/p6eval/niecza/lib/CORE.setting line 742 (CORE die @ 2) ␤  at /tmp/M8adcVE3Sf line 1 (MAIN C1_ANON @ 2) ␤  at /tmp/M8adcVE3Sf line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968_ANON …

[13:34] <mls_> niecza: { die("foo") ; CATCH {say 'hello'} }

[13:34] <p6eval> niecza v9-32-g380d891: OUTPUT«hello␤Unhandled exception: foo␤  at /home/p6eval/niecza/lib/CORE.setting line 742 (CORE die @ 2) ␤  at /tmp/YOJHGj35br line 1 (MAIN C1_ANON @ 2) ␤  at /tmp/YOJHGj35br line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968…

[13:35] *** araujo left
[13:36] *** araujo joined
[13:36] *** araujo left
[13:36] *** araujo joined
[13:36] <mls_> jnthn: I now to "perl6" semantics, i.e. the call chain in the exception handler includes the ones where the exception was thrown

[13:37] <mls_> (looks interesting in the sub profiler ;) )

[13:37] <mls_> (the "die/throw" op calls the catch block)

[13:38] *** bluescreen10 left
[13:40] <JimmyZ> nom: use MONKEY_TYPING; augment  class Int {  method foo() { 'hi'; }  };  say int.foo(); 

[13:40] <p6eval> nom 8ba1a3: OUTPUT«hi␤»

[13:41] * JimmyZ doesn't know whether if it's right or not :(

[13:41] <jnthn> JimmyZ: Well, tbh, most of "right" vs "wrong" in the native types implementation is "what jnthn says is right or wrong" :)

[13:42] <jnthn> JimmyZ: If you do $some_natively_typed_think.method_call() it will always box it before making the method call, because you can't make a call on a native value

[13:43] <JimmyZ> jnthn:  so is it right above code?

[13:43] <jnthn> JimmyZ: Native types "inherit" (for some value of) from a class.

[13:43] *** shinobicl joined
[13:43] <jnthn> Generally, it's the class they'll end up boxing to.

[13:43] <jnthn> JimmyZ: Yeah, it's doing what I expect it to.

[13:43] <JimmyZ> jnthn:  thanks

[13:45] *** mkramer1 joined
[13:45] <JimmyZ> anyway, perl6 is so powerful, nom++, and jnthn++

[13:46] <masak> it's doing what I expect it to too, fwiw.

[13:46] <masak> i.e. ints behave a lot like Ints.

[13:46] <jnthn> Mostly, I'm just feeling my way forward, because I'm the first to try and put the native type stuff into an otherwise quite rich Perl 6 implementation.

[13:46] <masak> the only time they don't is when you try to do something outright impossible, like rebind an int.

[13:47] <shinobicl> hi... does anyonw know how much RAM do i need to "make" the new rakudo? All I know is that 470MB are not enough and 2GB is enough

[13:47] <masak> but calling methods is no problem; just need to box it.

[13:47] <jnthn> The reason I added the sized ones is because I want to use them in NativeCall.

[13:47] *** mkramer left
[13:47] <masak> shinobicl: that sounds about right.

[13:47] <moritz> shinobicl: a bit more than 1G is necessary

[13:47] <shinobicl> thanks moritz!

[13:47] *** flatwhatson joined
[13:48] <jnthn> .oO( Too much... )

[13:49] <moritz> jnthn: now that we have exporting into lexical scopes, wouldn't it be much easier to split the setting?

[13:49] <JimmyZ> I thoght native types is some types likes  C

[13:49] <JimmyZ> *thought

[13:49] <moritz> (or nested settings, like SAFE)

[13:49] <moritz> JimmyZ: C doesn't have a bigint type :-)

[13:50] <jnthn> moritz: nested could work

[13:50] <JimmyZ> moritz: yes, rakudo augment C

[13:50] <masak> JimmyZ: they are very much like that, but they box when you try to use them like objects.

[13:50] <jnthn> moritz: PRIMITIVE -> CORE -> SAFE

[13:50] <moritz> jnthn: does that make lookups slower?

[13:50] <jnthn> moritz: Marginally.

[13:51] * moritz builds and benchmarks

[13:51] <dalek> rakudo/nom: 393309c | moritz++ | src/core/Buf.pm:

[13:51] <dalek> rakudo/nom: non-spec Buf.append_inplace hack for bbkr++

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/393309cbec

[13:51] <jnthn> moritz: As in, almost certainly not worth worrying about.

[13:51] <moritz> I could well imagine a "FAT" setting where all the things like Date, DateTime, IO::Socket etc. live in

[13:51] <jnthn> moritz: I'd guesstimate <1%

[13:51] <jnthn> moritz: Yeah, same.

[13:52] <jnthn> Of course, we should be using less memory to build the setting too :)

[13:52] <jnthn> Even at the size it's at.

[13:53] *** bluescreen10 joined
[13:55] <moritz> I wonder how hard it would be find a clear cutting point between a small inner and a big outer setting

[13:55] <moritz> one with nearly no forward references

[13:56] <jnthn> Well, things like the temporal stuff easily slip out into the outer one.

[13:56] <jnthn> Sockets probably do also.

[13:56] <jnthn> And maybe Set etc

[13:56] <moritz> a quick counting showed about 8 files that clearly belonged to the outer

[13:57] <moritz> and yes, Set, KeyMap etc. too, which are NYI

[13:57] <benabik> jnthn: PRIMITIVE?

[13:57] *** uasi left
[13:57] <bbkr> moritz: spec already defines buf concatenate behavior, so why not make it official infix:<~=> and have another part of spec implemented?

[13:57] <flussence> benabik: I guess that's everything that can't be implemented in terms of other functions :)

[13:57] <jnthn> benabik: There's probably better names.

[13:58] <benabik> jnthn: Just wondering if you mean the existing bootstrapping bit for the setting, or something else

[13:59] <jnthn> benabik: Yes, it'd be where various bootstrappy bits happened.

[13:59] <benabik> Bare minimum for the complier to make sense, so if you want your own setting, it's inside PRIM.  Fair enough.  Sounds neat.

[14:00] <moritz> bbkr: will do as a next step, yes. But it's more convenient for the implementation to live inside a method

[14:01] <moritz> nom: class A { }; multi infix:<~=>(A $, A $) { }; my $x = 'foo'; $x ~= 'bar'; say $x

[14:02] <p6eval> nom 4152d2: OUTPUT«foobar␤»

[14:03] *** araujo left
[14:03] *** replore_ joined
[14:03] *** koban` left
[14:04] *** araujo joined
[14:10] *** wtw left
[14:13] *** nightlord joined
[14:24] *** bluescreen10 left
[14:25] *** aindilis left
[14:30] <dalek> nqp: 7595e8b | jnthn++ | src/PAST/NQP.pir:

[14:30] <dalek> nqp: Add some NQP ops.

[14:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7595e8b601

[14:30] <dalek> nqp: ca60d32 | jnthn++ | src/NCI/CallBuilder.nqp:

[14:30] <dalek> nqp: Start to sketch out NQP/6model level NCI handling. Rather than do everything itself, the Perl 6 NativeCall library can be built on top of this.

[14:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca60d32a1d

[14:33] *** araujo left
[14:36] *** mkramer joined
[14:36] *** drbean left
[14:37] *** nightlord left
[14:38] *** mkramer1 left
[14:38] <mls_> Argh, a caught exception in a default/when block kills the special "succeed" semantics, as Actions.pm just adds a succeed call to the end of the block.Sigh.

[14:39] *** bluescreen10 joined
[14:39] <masak> moritz, jnthn: I'm confused by your usage "small inner" and "big outer" in terms of settings. wouldn't the big one, the one with temporal stuff etc, need the small one as a dependency? i.e. the small one must be the outer one.

[14:40] <jnthn> masak: Well, it depends if you're looking from the inside or the outside :P

[14:41] * masak 's brain asplode

[14:41] <jnthn> masak: I think we're all intending the same thing. :)

[14:41] <jnthn> masak: Yes, the one with temporal etc in would have the primitive one as its outer.

[14:42] <TimToady> I don't suppose we have to require CORE::OUTER to be undefined

[14:43] *** thou joined
[14:43] <TimToady> funny that CORE is an "inner" metaphor though, now that you mention it

[14:43] <jnthn> :)

[14:43] <TimToady> metaphors we live by...

[14:43] <mls_> Hi TimToady!

[14:44] <mls_> I've got some questions about exceptions for you

[14:44] <TimToady> oh oh :)

[14:45] <benabik> We could rename OUTER to INNER, but I think that would just cause more confusion.  :-D

[14:45] <masak> aaaugh

[14:45] <mls_> S04-exception-handlers/catch.t construct exceptions with Exception("message")

[14:45] <masak> benabik: I know you're joking, but... OUTER is *physically* outer in most code :) so yes, it would cause more confusion.

[14:46] <mls_> S02 contains that syntax

[14:47] <TimToady> it's probably better to use an explicit constructor when you know construction has to happen, but really common constructors can use coercion syntax; it's not prohibited; see S13:198

[14:48] <mls_> ah, thanks. NYI in Rakudo/Niecza, though

[14:49] *** araujo joined
[14:49] <benabik> Is it possible for a type to define how other types coerce to it?

[14:49] <benabik> Or does Exception("message") rely on String knowing how to be an Exception?

[14:49] <TimToady> that's what S13 is talking about

[14:50] *** benabik_ joined
[14:51] <TimToady> you can presumably multi the &.() to handle different incoming types

[14:51] <TimToady> but basically, type objects are specced to respond to .()

[14:52] <TimToady> that's how MyType() coercions are handled

[14:52] *** benabik left
[14:52] *** benabik_ is now known as benabik

[14:53] <mls_> Second question: S04-exception-handlers/catch.t contains a test that does die(3) and then checks $_ in the catch block

[14:53] <benabik> Not sure I'm a fan of S13's method of disambiguating that… I'd prefer $obj.Type to always have preference over Type($obj).

[14:53] <jnthn> TimToady: multi postcircumfix:<( )>(Mu:U $self: $target) { $target."$self.^name()" } # something like this?

[14:53] <bbkr> moritz: I've benchmarked both Buf approaches, '€' x 100 (300 bytes) in 100 chunks. Buf copying took 147 seconds, Buf.append_inplace took 1 second :)

[14:53] <jnthn> TimToady: er, multi method...and in Mu.

[14:54] <benabik> (I'll just have all my own Types call $obj.Type first.)

[14:54] <jnthn> benabik: I'd understood that to be the default.

[14:55] <mls_> hmm,  that multi... does that default to .new like it should?

[14:55] *** mkramer left
[14:56] <TimToady> jnthn: yes, it's best if the type knows how to convert itself to other types, but newly defined types tend to know more about the old types rather than old types knowing about new types, so we need both ways

[14:56] <jnthn> mls_: Well, what I just showed is the fallback.

[14:56] <TimToady> whyu should it default to .new?

[14:56] <mls_> S13 says something like taht

[14:56] <jnthn> mls_: Exception can override it

[14:57] <benabik> jnthn: It says one falls back to the other, but say there's an Exception(Stringy $msg).  If I do: class Foo does Stringy { method Exception {} }, I'd like my Foo $foo; Exception($foo) to call $foo.Exception.

[14:57] *** Trashlord joined
[14:57] <benabik> So new types can create more specialized versions.

[14:57] <jnthn> benabik: I *think* that's what I just described implenting.

[14:58] *** kaleem left
[14:58] <TimToady> this is all still somewhat negotiable, but I need to afk for a bit &

[14:58] <TimToady> feel free to queue questions for later though

[14:58] <mls_> ok, I'll bother you with the second question when you're back ;)

[14:59] <benabik> jnthn: You just described there being a fallback, but wouldn't `class Exception { method postcircumfix<( )> (Stringy:D $msg)` (which there probably will be for re-dispatching to Exception.new) take precedence over it?

[14:59] <benabik> *multi method

[14:59] <jnthn> benabik: Yes.

[15:00] <jnthn> benabik: Oh, I see what you're trying to do...hm.

[15:00] <benabik> :-D

[15:01] <benabik> jnthn: If my Foo should become a specific _type_ of Exception, say.  $foo.Exception would return MyPackage::Exception, but Exception($foo) would return Exception.

[15:01] <benabik> I'd like coercion to happen one way.

[15:02] <benabik> the same way, I mean

[15:02] <jnthn> benabik: Well, TimToady seems to want it both ways ;)

[15:02] <jnthn> ...but that's nothing new :P

[15:02] <jnthn> I see the concern though.

[15:02] <benabik> \o/  I communicated successfully!

[15:03] <benabik> Types could check for a .Type method on the object they're coercing, but then you'll have someone forget and bleck.

[15:03] *** birdwindupbird left
[15:03] <jnthn> At some points I've wondered if coercion is recognized syntactically and re-written to something in meta-space.

[15:03] <jnthn> .^coerce(...)

[15:03] <benabik> Deep.

[15:04] <dalek> nqp: 4c6d236 | jnthn++ | / (3 files):

[15:04] <dalek> nqp: Install NCI::CallBuilder.

[15:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4c6d236801

[15:04] <TimToady> the original intent was to recognize types syntactically

[15:05] <TimToady> that's one of the reasons types are predeclared

[15:05] <jnthn> TimToady: Well, we already do that really. :)

[15:05] <TimToady> the current S13 spec doesn't really take advantage though

[15:05] <jnthn> TimToady: It's just that if all we're doing is invocation, then the "oh it's a type!" case boils down to the same thing as a call.

[15:06] <masak> TimToady: not a question per se; just noting that I don't think Exception("message") qualifies as a coercion. the string is not so much converted into an exception as subsumed by it.

[15:06] * jnthn takes a break from native call stuff for a bit to work on something else

[15:06] <benabik> ClassHOW.coerce could check $obj for a .Type method and then fall back on Type().  Although you get to interesting questions of $obj.SuperClass being more important than SuperClass() and how to detect that...

[15:07] *** araujo left
[15:07] <benabik> Being able to define coercions both ways is important though.  New types need to know how to convert to old and convert old to them.

[15:07] <TimToady> masak: you could say the same about int to float conversion :)

[15:07] *** araujo joined
[15:09] <masak> sure, but a float is immutable, so the subsuming doesn't feel as "physical" there.

[15:09] <masak> mostly I'm just questioning providing two syntaxes for creating an Exception where one would do fine.

[15:10] *** kaleem joined
[15:12] <moritz> masak: yes, I was confusing inner and outer there

[15:12] * benabik somewhat likes Scala's implicit methods for coercion.

[15:13] <moritz> jnthn: btw I've benchmarked mandelbrot, once normal, once with --setting=SAFE

[15:13] <jnthn> moritz: OK...and? :)

[15:13] <moritz> jnthn: the difference is about 0.3s on 50s, but that is roughly the same amount as the timing noise

[15:13] <jnthn> moritz: Yeah.

[15:14] <jnthn> ooh, we're at 50s now? :)

[15:14] <masak> also, maybe I'm seeing a slippery slope there in over-applying coercions where they make little sense. "want to create a process? just coerce the string containing the executable name using .Process!"

[15:14] <tadzik> I don't like Exception(Str) either :)

[15:14] <tadzik> I imagine it as something that in 10 years people will talk of as they now do of indirect method calls in Perl 5

[15:15] <benabik> I like coercions up front, sometimes…  The .perl output of ().list takes too long for me to find out it's a list.

[15:15] <benabik> I'd much prefer List()

[15:15] <tadzik> nom: ().list.perl.say

[15:15] <p6eval> nom 393309: OUTPUT«().list␤»

[15:15] <tadzik> meh

[15:15] <tadzik> nom: List.new.perl.say

[15:15] <moritz> :-)

[15:15] <p6eval> nom 393309: OUTPUT«().list␤»

[15:15] <benabik> Although I guess an empty list would be hard to distinguish from a type object.  Hm.

[15:15] <moritz> benabik: note that .perl is meant for, well, perl. Not for humans

[15:16] <tadzik> I semi-like it as it is

[15:16] <benabik> moritz: But shouldn't perl be for humans?  ;-)

[15:16] <moritz> writing that as List.new(...) would fix that problem

[15:16] <moritz> benabik: .gist is for humans

[15:16] <masak> benabik: what makes you think an empty list isn't a type object? :P

[15:16] <masak> rakudo: say ().defined; say List.defined

[15:16] <tadzik> it's meant for perl, not humans, but it doesn't break encapsulation because no, but it's meant to produce the same object, but it doesn't...

[15:16] <p6eval> rakudo 393309: OUTPUT«Bool::True␤Bool::False␤»

[15:16] <masak> maybe that... :)

[15:16] <benabik> masak: Yes, that.

[15:16] <tadzik> rakudo: say ().defined; say List.new.defined

[15:16] <p6eval> rakudo 393309: OUTPUT«Bool::True␤Bool::True␤»

[15:18] *** alester joined
[15:28] *** kaare_ joined
[15:29] <shinobicl> nom: sub prefix:<Ask> (Str $what) {  "whats up  " ~ $what }; say Ask "Joe";

[15:29] <p6eval> nom 393309: OUTPUT«Could not find sub &Ask␤  in <anon> at /tmp/1CSt_AEv5p:1␤  in <anon> at /tmp/1CSt_AEv5p:1␤␤»

[15:30] <moritz> nom doesn't do custom operators yet

[15:30] <shinobicl> perl6: sub prefix:<Ask> (Str $what) {  "whats up  " ~ $what }; say Ask "Joe";

[15:30] <benabik> nom: sub ask { "What's up " ~ $^doc ~ "?" }; say ask "Joe"

[15:30] <p6eval> rakudo 393309: OUTPUT«Could not find sub &Ask␤  in <anon> at /tmp/nAKdnrMC56:1␤  in <anon> at /tmp/nAKdnrMC56:1␤␤»

[15:30] <p6eval> ..pugs, niecza v9-32-g380d891: OUTPUT«whats up  Joe␤»

[15:30] <p6eval> nom 393309: OUTPUT«What's up Joe?␤»

[15:31] <masak> nom: sub Ask(Str $who) { "what's up, $who?" }; say Ask "Joe"

[15:31] <p6eval> nom 393309: OUTPUT«what's up, Joe?␤»

[15:31] *** woosley left
[15:31] <benabik> nom: sub ask { "What's up $^doc?" } ; say ask "benabik"

[15:31] <p6eval> nom 393309: OUTPUT«What's up benabik?␤»

[15:31] <benabik> It finds ^params in strings.  Neat.

[15:32] <moritz> bbkr: fwiw I've tried to implement infix:<~=>(Buf, Buf), but it's not picked up in the dispatch, likely because it collides with the = meta operator on infix:<~> for Str

[15:32] <tadzik> I think it finds everything which looks like an expression

[15:32] *** kaleem left
[15:33] <jnthn> moritz: The meta will win, I think.

[15:33] <masak> jnthn: I don't.

[15:33] <jnthn> masak: Tough.

[15:33] <jnthn> :P

[15:33] <masak> then how could you override your metaoperators?

[15:33] <moritz> jnthn wins :/

[15:33] <shinobicl> moritz: that remembers me a thread i saw in a BBS some time ago... "perl6 craziness" was called...

[15:33] <jnthn> masak: I don't think you're meant to write your own derived forms.

[15:33] <masak> because in some cases, you have to.

[15:34] <masak> jnthn: I thought the spec even talked about that.

[15:34] <jnthn> I thought it said you shouldn't...I may be misremembering.

[15:34] <moritz> jnthn: I'm pretty sure you should be able to

[15:34] <shinobicl> http://pastebin.com/1GTw45J9 

[15:34] <jnthn> moritz: OK, I may be misremembering...

[15:35] <masak> jnthn: S13:143

[15:35] <masak> "...(unless you define it yourself)"

[15:35] <masak> I win! :)

[15:35] <jnthn> huh, what's with all the S13 references today...

[15:36] <jnthn> Fair enough. Patches welcome. :)

[15:36] <masak> jnthn: clearly you need to be reminded of it :P

[15:36] <jnthn> Probably means patching the meta-operator generating code to not generate things that already exist.

[15:37] <moritz> one thing I've always wanted to do is to add a prefix:<[+]>(Range) multi which optimizes summing over ranges of integers

[15:38] *** mberends joined
[15:38] <masak> moritz: ooh!

[15:38] <jnthn> moritz: oh ouch

[15:38] <dalek> rakudo/nom: aa5e9b6 | jnthn++ | src/Perl6/Actions.pm:

[15:38] <dalek> rakudo/nom: Generate lexicals of the correct primitive type for holding arguments.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa5e9b68d4

[15:38] <dalek> rakudo/nom: bd4af3e | jnthn++ | src/ (2 files):

[15:38] <dalek> rakudo/nom: Start passing nativeness info down towards the binder.

[15:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd4af3e962

[15:38] <jnthn> moritz: If you want to do that, you're going to have to manually write out the candidate that falls back to the meta-op internals too.

[15:38] <moritz> jnthn: yes, that was the problem in b

[15:39] <jnthn> Well, it's not really a problem, just more effort. :)

[15:39] *** araujo left
[15:39] <jnthn> Oh, maybe we can get away with it somehow.

[15:39] <jnthn> By just generating the extra multi

[15:39] *** araujo joined
[15:40] <moritz> maybe the autogenerate can kick in if the dispatch fails, not just when lookup fails

[15:40] <jnthn> no

[15:40] <jnthn> The auto-generation is compile time.

[15:40] <moritz> right

[15:40] <jnthn> Oh, you're thinking of type-inferring it?

[15:40] <moritz> no

[15:40] <jnthn> And doing a compile time recognition of the case?

[15:41] <jnthn> OK, then I'm not sure I follow.

[15:41] <moritz> I just didn't think of the auto-gen taking place at compile time

[15:41] <jnthn> Ah, OK

[15:41] <moritz> so I was working with RONG assumptions

[15:41] <jnthn> We could feasibly recognize the case in the optimizer.

[15:41] <jnthn> Provided we knew we had a range as the argument, of coure.

[15:42] <jnthn> *course

[15:42] <masak> could we get away with only generating those metaops that are actually used in the code?

[15:43] <masak> are there still an infinite amount of them?

[15:43] <jnthn> masak: We do.

[15:43] <masak> oh, good.

[15:43] <jnthn> masak: We've only generated the used ones since ng.

[15:43] <masak> but &eval and metaops still works?

[15:43] <jnthn> masak: There's infinitely many of them, and setting compilation already takes long enough, so I don't want to re-generate all of them... :)

[15:43] <jnthn> *pre-generate

[15:43] <moritz> masak: eval has its own compile time

[15:43] <jnthn> What moritz++ said.

[15:44] <masak> what about define-your-own, then &eval with that metaop in it? :)

[15:44] <moritz> it has its own compile time.

[15:44] <masak> I heard that bit.

[15:44] * moritz -> decommute

[15:44] <masak> I'm just wondering if that case works.

[15:44] <moritz> dunno, but it can be made to work :-)

[15:44] <jnthn> masak: The mechanism eval uses to see outer (at compile time and runtime) is *exactly* the same one we use for the setting.

[15:44] * moritz expects a new masak bug after the commute

[15:45] <masak> :)

[15:46] <masak> jnthn: yes, but I mean, since eval has its own compile time, and if compile time is when new metaops are autogenerated, isn't there a risk that a thus-far unused metaop will be generated and hide a user-defined one in the OUTER?

[15:46] *** packetknife joined
[15:47] <jnthn> masak: Sure, but it'd also mean that any that we defined in the setting were being ignored too.

[15:47] *** packetknife left
[15:47] <jnthn> masak: That is, if we fix it for the setting case, it probably fixes the eval case too.

[15:47] <masak> oh. true.

[15:47] <masak> sanity++

[15:47] <jnthn> In eval, the compiler really does just treat the scope you call eval in as a kind of setting.

[15:48] <jnthn> It actually goes a bit too far now, which is why we have the globals bug :)

[15:48] <jnthn> (it thinks you deserve a fresh GLOBAL too in eval...)

[15:48] <jnthn> (it shouldn't.)

[15:49] <jnthn> oh gee, this natives stuff is tricky...

[15:53] <mberends> jnthn: I'm very happy that you are busy with NativeCall :)

[15:53] <jnthn> mberends: Wanna help? ;)

[15:53] <jnthn> mberends: I've decided to split things up a little.

[15:54] <jnthn> mberends: Going to have an NQP level bit

[15:54] <jnthn> mberends: Then do NativeCall on top of that.

[15:54] <jnthn> mberends: The hope/dream being that we just have to re-implement the NQP level bit on other VMs...and that NativeCall gets saner. :)

[15:55] <jnthn> mberends: Thing is, I really want to use native types (int, int8, int16) etc this time

[15:55] <jnthn> mberends: Not Int, etc like we have before.

[15:56] <jnthn> mberends: So, it'll take a little migration, I suspect. But may as well do it now rather than put it off...

[15:56] <jnthn> Can also do structs.

[15:57] <mberends> jnthn: ok. I'll help wherever you think I can :)

[15:57] <mberends> jnthn: that's a Good Improvement.

[15:57] <mberends> er, good improvement ;)

[15:57] <jnthn> :)

[15:57] <jnthn> Well, some way to go yet.

[15:58] <jnthn> But started on it at least.

[15:58] * masak decommutes

[15:58] *** masak left
[15:59] <mberends> yay, SQLite will be reachable with structs :)

[16:04] *** araujo left
[16:04] *** araujo joined
[16:04] *** araujo left
[16:04] *** araujo joined
[16:05] <dalek> roast: 9b7e843 | Coke++ | S03-operators/buf.t:

[16:05] <dalek> roast: rakudo nom fudging

[16:05] <dalek> roast: review: https://github.com/perl6/roast/commit/9b7e843da2

[16:05] <bbkr> moritz: confirmed, infix:<~=> does not dispatch. "multi infix:<~> (Buf:D $a, Buf:D \$b)" however dispatches properly $buf1~$buf2 and $buf1~=$buf2, but it's useless if ~ operator does not know that it is called with '=' to decide if to do new buffer or appending

[16:06] *** MayDaniel joined
[16:07] *** yves_ left
[16:07] <dalek> rakudo/nom: a1032e0 | Coke++ | t/spectest.data:

[16:07] <dalek> rakudo/nom: run fudged test, track failures

[16:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a1032e046e

[16:07] *** pyrimidine joined
[16:10] *** mj41 left
[16:10] <[Coke]> phenny, b?

[16:11] <TimToady> b or not b, that is the question...

[16:12] <[Coke]> the answer to that is yes, of course.

[16:12] <TimToady> phenny doesn't agree :)

[16:13] *** xinming joined
[16:14] *** yves_ joined
[16:22] *** mberends left
[16:23] *** xinming left
[16:34] <sjohnson> phenny, advice

[16:36] *** xinming joined
[16:36] <sjohnson> :(

[16:39] *** araujo left
[16:41] *** araujo joined
[16:41] *** packetknife joined
[16:44] *** mj41 joined
[16:45] *** wamba joined
[16:47] *** envi left
[16:54] *** mberends joined
[16:55] *** dakkar left
[16:58] <Woodi> should i define sub a( Str $b!, $c?, $d? ); or multi sub for each case ? or multi is only for same param count with other types ?

[16:59] *** japhb_ left
[17:00] <jnthn> Woodi: Both are possible. Which is best depends, and not everyone will call it the same way. Generally, I use optionals if the behavior is mostly the same for all the cases, and multis if I want to do something quite different for each arity.

[17:01] *** frhodes joined
[17:01] <mls_> TimToady: my second question

[17:01] <Woodi> thanx jnthn 

[17:01] <mls_> catch.t contains die(3) and checks $_ in CATCH to match 3

[17:01] <mberends> fractal Sierpinski triangles for Niecza Perl 6: https://gist.github.com/1235342

[17:01] *** masak joined
[17:01] <japhb> Is there anyone around who can hug http://perl6.org/compilers/features so that it updates with jnthn++'s changes from yesterday?

[17:01] *** bbkr left
[17:02] <masak> japhb: don't you have a commit bit yourself?

[17:02] <masak> and if not, why not?

[17:02] <masak> you've already asked twice. soon it'll have been less work to JFDI. :P

[17:02] *** daxim left
[17:03] <japhb> masak, it's not updating the data that's the problem: jnthn did that.  The page is not re-rendering.  I don't know where that is, or if I have / ever had access.

[17:04] <masak> oh!

[17:05] <jnthn> Did I screw up the json somehow, I wonder...

[17:05] <mls_> jnthn: current state of exception patch: https://gist.github.com/1235351

[17:06] <mls_> jnthn: notice the new invoke_catchhandler op that does some evil call chain hackery

[17:06] <masak> jnthn: yes, I think you did. first change at https://github.com/perl6/features/commit/6a65d1d1c082a61599a87f7430a141cdb269e7d3 looks like it's not quoted enough.

[17:07] <jnthn> oh, wtf.

[17:07] <masak> also, that addition should probably have been on "status", not "code".

[17:07] <jnthn> yeah

[17:07] <jnthn> :/

[17:08] <masak> feature request: when someone screws up the JSON in that file, this channel is notified.

[17:08] <japhb> I was thinking something similar.  :-)

[17:08] <dalek> features: bde748c | jnthn++ | features.json:

[17:08] <masak> preferably each time the pagegen fails.

[17:08] <dalek> features: JSON is hard, it turns out...

[17:08] <dalek> features: review: https://github.com/perl6/features/commit/bde748c504

[17:09] <japhb> masak, where is that page hosted?

[17:09] <japhb> Some feather*?

[17:10] *** JimmyZ left
[17:10] *** mj41 left
[17:12] <mls_> afk -> home

[17:13] <japhb> commuting &

[17:13] <TimToady> mls_: not sure there was a question in that, but an exception should stringify/numify in a dwimmy way such that a when can match an errno or a message, as well as the exception type

[17:14] <TimToady> note also that an exception may not be rethrown with die, I think, since exceptions within the CATCH are considered new exceptions

[17:15] <TimToady> we'll need a different verb to put things into the unhandled list instead of the undead list

[17:16] <TimToady> maybe undead is misnamed, since it's really the old exception that is undead when it comes back :)

[17:16] *** araujo left
[17:16] <mls_> Btw, are exceptions Cool?

[17:17] *** araujo joined
[17:18] <TimToady> well, they can convert to numeric or string for matching, but I don't know if that makes them Cool

[17:18] *** kaleem joined
[17:18] <TimToady> seems they used to be Cool, and that caused problems

[17:19] <TimToady> they end up getting multi-dispatched more generally than they ought, but maybe separating the notion of Failure from the notion of Exception will clear that up

[17:19] <TimToady> a Failure contains an unthrown exception, I think, but isn't one

[17:20] *** mberends left
[17:20] <mls_> ok, thanks TimToady++

[17:20] <mls_> afk -> home (this time for real ;) )

[17:20] *** risou_awy is now known as risou

[17:23] *** packetknife left
[17:30] *** espadrine joined
[17:34] *** japhb_ joined
[17:36] <japhb_> masak, BTW: sorry if I sounded incorrectly lazy before.  I should have asked "How can I fix this?" rather than "Can anyone fix this?"

[17:37] *** pmurias joined
[17:39] *** araujo left
[17:40] <pmurias> hello

[17:40] *** araujo joined
[17:40] *** araujo left
[17:40] *** araujo joined
[17:41] *** mberends joined
[17:42] <tadzik> hello pmurias 

[17:46] *** packetknife joined
[17:47] *** packetknife left
[17:52] *** packetknife joined
[17:53] *** molaf__ left
[17:55] *** packetknife left
[18:00] <Woodi> hmm, perlisophycally asking - do in Perl6 is/will be better (performance) to use recursive function in HOP style or just while loop ? functional languages defaults to recursion, what in v6 ?

[18:01] <Woodi> whithout memoisation :)

[18:01] <jnthn> Woodi: That may well be implementation dependent.

[18:01] <jnthn> Woodi: And then probably situation dependent too ;)

[18:02] <jnthn> Woodi: In Rakudo, probably while loops are cheaper, and also probably easier on the optimizer.

[18:02] *** bakedb left
[18:02] <Woodi> ok, just asking "mayve usually while is better ?" :)

[18:02] <jnthn> If it's speed you want over all else, then yes, probably. :)

[18:03] *** packetknife joined
[18:03] *** araujo left
[18:04] *** araujo joined
[18:05] *** bluescreen10 left
[18:05] <Woodi> and do function calls will be expensive ? asking: do for performance prefer middle-size IFs over calls ?

[18:06] *** bluescreen10 joined
[18:07] *** cougnut left
[18:07] <Woodi> probably calls will not be unnoticable...

[18:07] *** espadrine left
[18:09] *** cyfi left
[18:13] * [Coke] chuckles that trunk@r1337 might be the revision of his project that goes to prod today.

[18:13] *** cyfi joined
[18:16] *** cougnut joined
[18:16] * [Coke] now has to explain LEET to the analyst. Sigh.

[18:17] <Woodi> is in perl6 something like: sub f( $a!, $b?, $b?, $d? ) { while params() { ... } } # or $p = shift $params(); ?

[18:19] <masak> Woodi: you have to slurp the variables to be able to iterate them.

[18:19] <masak> maybe you can access the siggie and iterate that, though. I dunno.

[18:19] <Woodi> i need params, not @...

[18:21] <Woodi> pls give me info, i will go read :)

[18:23] <TimToady> Woodi: note also that lazy lists are already HOP in disguise

[18:23] <TimToady> the language itself is designed to be relatively optimizable, but it will take a while for implementations to get there

[18:25] <TimToady> the most important thing is that we try to make as most external functional information available lexically, so you can know what you're dealing with at compile time most of the time

[18:25] <TimToady> ss/ as / /

[18:26] <TimToady> you can get the raw capture if you like and pull the positionals out of it

[18:28] <Woodi> i do not ask about performance now, but general hints how features will behave relative to each other. not to grainy but some things ar known to devs. i can only gues hinking about C/v5.

[18:28] <Woodi> captures, so i will study it a little

[18:29] <Woodi> thank you

[18:33] *** Chillance joined
[18:37] *** kaleem left
[18:38] <masak> can Rakudo do that already?

[18:38] *** araujo left
[18:38] <masak> hm, I guess the siggie is no good for pulling positionals out, since it's never populated with values -- only the lexpad is.

[18:38] *** araujo joined
[18:38] *** miso2217 left
[18:38] <masak> the siggie only guides the capture to the lexpad :)

[18:39] *** miso2217 joined
[18:39] *** Exodist joined
[18:39] *** miso2217 left
[18:39] *** risou is now known as risou_awy

[18:39] *** miso2217 joined
[18:44] <jnthn> masak: (raw capture) that's just |$c in the sig.

[18:45] <TimToady> we need to see a use case

[18:45] *** araujo left
[18:46] <jnthn> TimToady: Delegaty things?

[18:46] *** kcwu left
[18:46] *** araujo joined
[18:46] *** kcwu joined
[18:46] * jnthn is deep in a bunch of binder changes at the moment.

[18:50] *** Holy_Cow joined
[18:51] *** Holy_Cow left
[18:52] <TimToady> I mean a use case for what Woodi is trying to do, which looked more like XY and/or premature optimization to me

[18:54] <jnthn> TimToady: oh, ok :)

[18:54] *** pyrimidine left
[18:55] <masak> aye.

[18:55] <masak> if iterating through the parameters is that important, then maybe the parameters should consist of something iterable.

[18:56] <masak> rakudo: sub foo(*@params) { .say for @params }; foo "OH", "HAI", "WORLD"

[18:56] <p6eval> rakudo a1032e: OUTPUT«OH␤HAI␤WORLD␤»

[19:04] <Woodi> hmm, do not read yet about captures but use case:

[19:06] <Woodi> for example some db with api of very similiar functions (or protocol with similiar request/response construction for each command)

[19:08] <Woodi> so, few functions have zero params, few one param, few more, ..., few  is varg...

[19:09] <Woodi> so if function are similiar in functionality can be internal function called by all function. that internal function can use IFs for 0, 1, 2, ..., varg cases or slurp parameter list :)

[19:11] <Woodi> method !__cmd_zeroonetwothree( Str $command!, $p1?, $p2?, $p3 ) { ... }

[19:14] <Woodi> and: for <c1 c2 c3> -> name { A::B.HOW.add_method( A::B, $name, method () { return self!__zeroonetwothree( $name ) } ); }

[19:14] <Woodi> and: for <c1 c2 c3> -> name { A::B.HOW.add_method( A::B, $name, method ( $param ) { return self!__zeroonetwothree( $name, $param ) } ); }

[19:14] <Woodi> and so on :)

[19:16] <Woodi> and then IFs for each param number... so manipulation of parameters would be nice :)

[19:17] <Woodi> and that for's can be at BEGIN

[19:18] <Woodi> jnthn++ help :)

[19:18] <TimToady> sounds like zeroonetwothree wants to be a macro-ish kind of thing, really, but we don't have those yet

[19:18] <TimToady> as for your binding

[19:21] *** wamba left
[19:23] *** birdwindupbird joined
[19:23] *** birdwindupbird left
[19:24] <Woodi> for protocol construction must be macro language which can call perl6 code :)

[19:24] *** araujo left
[19:26] <dalek> rakudo/nom: 4c67ac6 | jnthn++ | src/binder/bind. (2 files):

[19:26] <dalek> rakudo/nom: Tentatively start to refactor the binder so it can work with natively typed arguments and parameters. This doesn't do much besides change the API used by a couple of low-level bits.

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4c67ac65aa

[19:26] <dalek> rakudo/nom: 78198e7 | jnthn++ | src/binder/bind.c:

[19:26] <dalek> rakudo/nom: Extensive refactor of parameter binding to work towards supporting natively typed parameters/arguments.

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78198e72a0

[19:26] <dalek> rakudo/nom: e089c70 | jnthn++ | src/binder/bind.c:

[19:26] <dalek> rakudo/nom: Get binder to handle being passed natively typed values and binding them to natively typed lexical registers. Note that the code-gen isn't really up to scratch for using this yet, but the binder part now seems to work.

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e089c70f2a

[19:26] <dalek> rakudo/nom: ff86674 | jnthn++ | src/Perl6/Actions.pm:

[19:26] <dalek> rakudo/nom: Ensure we generate correct code for natively typed parameter lookups when they're used.

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ff866742e9

[19:26] <tadzik> ho

[19:27] <mberends> exciting!

[19:27] <TimToady> sorry, got called away briefly

[19:28] *** sayu left
[19:29] <TimToady> as for your binding, you can have a signature that binds the remaining capture in the middle, so you could do something like ($name, |$rest ($p1?, $p2?, $p3?, *@more))

[19:29] <TimToady> and it would always bind name, then $rest would be the capture of the rest of the arguments, of which the first three are also given names of p1, p2, p3

[19:29] <TimToady> at least, that's specced behavior

[19:30] <jnthn> Pretty sure that's how I implemented it too.

[19:31] <jnthn> nom: sub foo($name, |$rest ($p1?, $p2?, $p3?, *@more)) { say $name; say $p1 }; foo('bar', 1, 2)

[19:31] <p6eval> nom a1032e: OUTPUT«bar␤1␤»

[19:31] <jnthn> nom: sub foo($name, |$rest ($p1?, $p2?, $p3?, *@more)) { say $name; say $rest }; foo('bar', 1, 2)

[19:31] <p6eval> nom a1032e: OUTPUT«bar␤1 2␤»

[19:31] <TimToady> sugoi!

[19:32] <Woodi> that i need i think :)

[19:32] <Woodi> any other language have such features ? :)

[19:35] <Woodi> but ppls will complain about line noise :)

[19:36] <jnthn> nom: sub foo(:$bar, |$c, :$baz) { say $c.hash }; foo(:baz(42), :bar(69))

[19:36] <p6eval> nom a1032e: OUTPUT«baz  42␤»

[19:39] *** replore_ left
[19:39] <Woodi> but about macro language maybe rich string functionality can be enough...

[19:41] <jnthn> Woodi: Perl 6 includes hygenic macros.

[19:41] <jnthn> Woodi: Rakudo doesn't implement them yet, but masak++ is working on it :)

[19:42] *** daniel-s left
[19:42] <masak> heh! good luck. :) wait, that's me o.O

[19:43] *** daniel-s joined
[19:45] <Woodi> so perl6 programs will have document-form for heavy pre-parse in the future :)

[19:48] <dalek> rakudo/nom: 8943be1 | moritz++ | src/core/Buf.pm:

[19:48] <dalek> rakudo/nom: infix:<~>(Buf, Buf)

[19:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8943be1d6c

[19:50] <dalek> nqp: c4f9df4 | jnthn++ | src/pmc/stable.pmc:

[19:50] <dalek> nqp: Give us a bit more space in the type cache IDs.

[19:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4f9df4bdd

[19:50] <dalek> nqp: 732b4f3 | jnthn++ | src/6model/ (8 files):

[19:50] <dalek> nqp: Extend storage spec support so a REPR can describe the things it can/canny box.

[19:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/732b4f37b9

[19:50] <dalek> nqp: ce48590 | jnthn++ | src/6model/reprs/P6opaque.c:

[19:50] <dalek> nqp: Eliminate an unused variable, and the warning that goes with it.

[19:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ce48590c6d

[19:52] <dalek> rakudo/nom: 943dcd1 | moritz++ | src/core/Buf.pm:

[19:52] <dalek> rakudo/nom: [Buf] remove append_inplace hack; ordinary concatenation performs nearly equally well, so this was a case of premature optimization. Go figure.

[19:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/943dcd1fce

[19:53] <jnthn> Commits! Lots of them!

[19:53] <masak> jnthn++

[19:53] <masak> moritz++

[19:57] <Woodi> here are bindings teoretically discused erlier :)  https://github.com/slunski/perl6-simple-redis

[19:57] <Woodi> realy not much funcionality as for db but get/set keys work :)

[19:58] <Woodi> Redis is rather something like Memcache but with permament storage

[19:59] <tadzik> oh, that'd be your child?

[19:59] <masak> Woodi++

[20:00] <masak> Woodi: um, if you recommend the use of ufo, why is there also a Makefile in the repository?

[20:00] <masak> it's either one or the other...

[20:01] <tadzik> it's ufo generated

[20:02] <Woodi> ufo just work on std perl distributions :)

[20:03] <masak> well, you don't need the 'ufo' step if there's already a Makefile.

[20:03] <Woodi> s/Makedile//

[20:03] <Woodi> i forget remove it

[20:04] <Woodi> anyway it's terrible coded except function autogeneration...

[20:05] <Woodi> and $socket.get line by line isn't probably good for performance

[20:06] <Woodi> and protocol is realy simple, can by used by hand over telnet

[20:12] <masak> 'night, #perl6

[20:12] *** masak left
[20:12] <tadzik> 'night

[20:12] <tadzik> ...damnit, missed it

[20:12] <colomon> he's sneaky that way

[20:14] *** gfldex left
[20:15] <tadzik> I bet he leaves, then enters irclog.perlgeek.de and looks how people missed him by seconds

[20:15] *** gfldex joined
[20:17] <dalek> rakudo/nom: 57dc7ad | jnthn++ | / (2 files):

[20:17] <dalek> rakudo/nom: Bump to latest nqp/6model.

[20:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/57dc7ad953

[20:17] <dalek> rakudo/nom: 5af26ae | jnthn++ | src/binder/bind.c:

[20:17] <dalek> rakudo/nom: Handle case where natively typed parameters are passed boxed arguments. Binding works if the thing passed knows how to unbox itself to the correct native type.

[20:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5af26ae125

[20:26] *** MayDaniel left
[20:32] *** mkramer1 joined
[20:34] *** mj41 joined
[20:37] *** soh_cah_toa joined
[20:39] *** araujo joined
[20:51] *** mkramer1 left
[20:51] *** im2ee left
[20:53] *** bbkr joined
[20:54] <bbkr> moritz++ # Buf concat & append

[20:58] <jnthn> How are we on Buf compared to b now?

[21:01] *** mj41 left
[21:10] <bbkr> hmm, I get "make: nqp: Command not found" in Configure.pl of current nom. has anything changed in build commands?

[21:10] *** dorlamm joined
[21:12] <jnthn> Don't think so

[21:12] <jnthn> Odd

[21:13] *** simcop2387 left
[21:13] <jnthn> oh

[21:13] <jnthn> it's a stupid *nix thing.

[21:14] <bbkr> ?

[21:15] <dalek> nqp: 0751cd8 | jnthn++ | tools/build/Makefile.in:

[21:15] <dalek> nqp: Fix build for various platforms.

[21:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0751cd8dac

[21:15] <bbkr> happens on line "nqp --target=pir --output=src/gen/CallBuilder.pir src/NCI/CallBuilder.pm", should it be something like "./nqp"

[21:15] <bbkr> ?

[21:15] *** pmichaud left
[21:15] *** hugme left
[21:15] *** jrockway_ left
[21:16] <bbkr> \o/

[21:16] <jnthn> bbkr: Yeah...it worked on Windows. :)

[21:16] <dalek> rakudo/nom: 33e65ba | jnthn++ | tools/build/NQP_REVISION:

[21:16] <dalek> rakudo/nom: Use a build of NQP that isn't broken on some platforms.

[21:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/33e65ba625

[21:17] <bbkr> jnthn++

[21:18] *** kaare_ left
[21:19] *** pmichaud joined
[21:19] *** hugme joined
[21:19] *** jrockway_ joined
[21:19] *** zelazny.freenode.net sets mode: +v hugme

[21:20] <tadzik> -j2 is broken for me, still

[21:22] <jnthn> tadzik: on?

[21:22] <jnthn> nqp?

[21:22] <jnthn> Or Rakudo?

[21:23] <tadzik> nqp

[21:23] <jnthn> tadzik: As of today?

[21:23] <pmurias> sorear: hi

[21:23] <tadzik> jnthn: yep

[21:23] <jnthn> tadzik: Or for a while?

[21:24] <jnthn> tadzik: ah, maybe missing dependencies

[21:24] <tadzik> jnthn: it tries to build CallBuilder before building nqp

[21:24] <jnthn> oh

[21:24] <jnthn> ok, feel free to fix now

[21:24] <jnthn> or I take it later

[21:24] <jnthn> Probably just wants a dependency on $(NQP_EXE)

[21:25] * jnthn imagines parallel make is mostly useless for a bootstrapping compiler... :)

[21:26] <pmurias> jnthn: why?

[21:26] <dalek> nqp: 76afaff | tadzik++ | tools/build/Makefile.in:

[21:26] <dalek> nqp: [Makefile.in] Fix dependencies

[21:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/76afaffa6f

[21:26] <jnthn> pmurias: Because it has the build the stages in order

[21:26] <jnthn> pmurias: And the stages have ordering requirements within them.

[21:27] <pmurias> make itself doesn't seem very usefull for building p5 programs

[21:28] *** wamba joined
[21:28] <benabik> jnthn: Depends on how complex each stage is.  Each stage must finish before moving to the next, but within a stage you may be able to compile sections freely.

[21:29] <pmurias> sorear: if i want to start working on niecza-p5 interop (my exams are over) how should i hook the interop code in?

[21:29] <pmurias> in needs to be pluggable so the embedding code will be only used when needed/avalible?

[21:30] <jnthn> benabik: It *may*. But in the case of NQP there's little freedom.

[21:31] <benabik> jnthn: Also, parallel make can point out missing dependencies, which might cause make to not rebuild something.  ;-D

[21:32] <jnthn> Yes, true ;)

[21:39] *** franek joined
[21:39] * jnthn starts fiddling with getting the multi-dispatcher to know what to do with native types.

[21:40] <diakopter> !

[21:42] *** dorlamm left
[21:44] *** bluescreen10 left
[21:46] *** REPLeffect joined
[21:51] *** shinobicl left
[21:53] *** franek left
[21:54] <Woodi> perl6: sub foo($name, |$rest ($p1?, $p2?, $p3?, *@more)) { say $name; say $rest }; foo('bar', 1, 2)

[21:54] <p6eval> rakudo 8943be: OUTPUT«bar␤1 2␤»

[21:54] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "($"␤    expecting "?", "!", trait, "=", default value, "-->" or ")"␤    at /tmp/kWf1MP6CaH line 1, column 23␤»

[21:54] <p6eval> ..niecza v9-32-g380d891: OUTPUT«===SORRY!===␤␤Action method post_constraint not yet implemented at /tmp/rslF53ahOI line 1:␤------> $name, |$rest ($p1?, $p2?, $p3?, *@more)⏏) { say $name; say $rest }; foo('bar', 1␤␤Unhandled exception: Unable to resolve…

[21:54] <Woodi> b: sub foo($name, |$rest ($p1?, $p2?, $p3?, *@more)) { say $name; say $rest }; foo('bar', 1, 2)

[21:54] <p6eval> b 1b7dd1: OUTPUT«bar␤Capture()<0x4d97e38>␤»

[21:55] <jnthn> Woodi: Seems b was a bit less useful about stringifying captures.

[21:56] <Woodi> which Rakudo b is ?

[21:56] <jnthn> Woodi: The "Beijing" release.

[21:57] <jnthn> Woodi: Which is the compiler that shipped with the current Star distribution.

[21:57] <jnthn> "rakudo:" here is the current development branch

[21:58] *** wooden left
[21:58] <Woodi> my perl --version says "This is Rakudo Perl 6, version  built on parrot 3.6.0 0" only and dpkg 2011.07-1

[21:58] *** simcop2387 joined
[21:59] <Woodi> not good

[22:01] <Woodi> next Star tomorow ?

[22:02] <jnthn> Woodi: No, that'll take us a little longer.

[22:02] <jnthn> Woodi: Don't want to cause too many regressions.

[22:03] *** dorlamm joined
[22:03] <Woodi> nqp for nom branch is in rakudo source tree ?

[22:04] <jnthn> no

[22:04] <jnthn> https://github.com/perl6/nqp

[22:04] <Woodi> not compiled earlier today... will try again

[22:06] *** daniel-s left
[22:07] *** daniel-s joined
[22:07] *** stepnem left
[22:08] <Woodi> but bad parrot :)

[22:09] <dalek> roast: 28d220d | jnthn++ | S12-methods/multi.t:

[22:09] <dalek> roast: Oops, 2 instances of class A { ... } in the same test file.

[22:09] <dalek> roast: review: https://github.com/perl6/roast/commit/28d220d216

[22:09] <jnthn> Woodi: Yeah, it has quite specific requirement.

[22:10] <dalek> rakudo/nom: 952b7bb | jnthn++ | src/binder/multidispatch. (2 files):

[22:10] <dalek> rakudo/nom: Note presence of native types in the multi-dispatcher candidate graph; not doing anything with them yet.

[22:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/952b7bb084

[22:10] <benabik> Parrot master currently won't compile NQP master, but it will compile NQP's kill-useless-defaults branch.

[22:11] <Woodi> should i use parrot branch named kill-useless-defaults too ? or how to get what rakudo needs ?

[22:12] <jnthn> Woodi: The easiest way to get bleeding edge Rakudo with compatible versions of everything is to just git clone Rakudo, then perl Configure.pl --gen-parrot --gen-nqp

[22:12] <tadzik> depends on what parrot do you have 

[22:12] <jnthn> Woodi: It'll make a completely isolated build of an appropriate Parrot and NQP for you.

[22:12] <Woodi> no eay, i refuse to use --gen-*

[22:12] <jnthn> (e.g. won't break any installed version you have)

[22:12] <jnthn> Well, then you're going to have to go through the pain of doing what they do by hand :)

[22:12] <benabik> Woodi: Then Parrot master, NQP kill-useless-defaults, and Rakudo master _should_ work.

[22:13] <jnthn> No, they won't.

[22:13] <benabik> No?

[22:13] <jnthn> Not as of a few hours ago.

[22:13] <jnthn> Rakudo now depends on stuff in NQP master that didn't get merged into kill-useless-defaults.

[22:13] <benabik> Ahhhh....

[22:13] <Woodi> i write scripts and eg: sh go.parrot ; cd ../nqp ; sh go.nqp ; cd ../rakudo ; sh go.rakudo :)

[22:14] <benabik> Hm.  We merged sub-profiler after kill-useless-defaults.  Bad us.

[22:15] <jnthn> How so?

[22:15] <benabik> It'd be nice to use sub-profiler on Rakudo master, mostly.  :-D

[22:15] <jnthn> ah, ok

[22:15] <jnthn> you can always catch the kill-useless-defaults branch up with nqp master.

[22:15] <benabik> I'll get on that, but as of right now...

[22:16] <benabik> Parrot RELEASE_3_8_0, NQP master, Rakudo master.

[22:16] <benabik> Technically Parrot fb6470c will work, but it doesn't really have much more than the release.

[22:16] <jnthn> Yes, that combination really should work.

[22:16] <benabik> s/will/should/

[22:17] <Woodi> k, will try

[22:17] *** stepnem joined
[22:19] <jnthn> Hm. Enough natives hacking for today. Will continue playing with the multi stuff tomorrow. :)

[22:20] <benabik> Hm.  I hadn't built the new parrot yet.  Sadface.

[22:20] *** packetknife left
[22:23] *** alester left
[22:24] <benabik> So I merged master into kill-useless-defaults, but since I don't have a new enough parrot I can't test it.  *sigh*  Maybe someone else will beat me to it.

[22:35] *** wamba left
[22:37] <dalek> nqp/kill-useless-defaults: 7595e8b | jnthn++ | src/PAST/NQP.pir:

[22:37] <dalek> nqp/kill-useless-defaults: Add some NQP ops.

[22:37] <dalek> nqp/kill-useless-defaults: review: https://github.com/perl6/nqp/commit/7595e8b601

[22:37] <dalek> nqp/kill-useless-defaults: ca60d32 | jnthn++ | src/NCI/CallBuilder.nqp:

[22:37] <dalek> nqp/kill-useless-defaults: Start to sketch out NQP/6model level NCI handling. Rather than do everything itself, the Perl 6 NativeCall library can be built on top of this.

[22:37] *** dalek left
[22:37] *** dalek joined
[22:37] *** ChanServ sets mode: +v dalek

[22:37] <benabik> I didn't actually test it with Rakudo, but there it is.

[22:37] *** benabik left
[22:37] <diakopter> poor dalek

[22:43] *** ZapZ joined
[22:48] <Woodi> parrot RELEASE_3_8_0-9-g0bf02d9 needed for nqp-kill* now

[22:49] <Woodi> is this parrot god for rakudo nom ?

[22:50] *** dorlamm left
[22:50] <Woodi> hmm, new House :)

[22:53] <Woodi> i will test it tomorow, to many parrot compitations today...

[22:53] <Woodi> gn #perl6 &

[22:53] <jnthn> Woodi: It should be OK

[22:54] <jnthn> Woodi: night o/

[22:59] *** whiteknight joined
[23:04] *** Maddingue left
[23:08] *** ZapZ left
[23:08] *** ZapZ joined
[23:12] <jnthn> sleep &

[23:22] *** frhodes left
[23:26] *** frhodes joined
[23:29] *** pmurias left
[23:46] *** shinobicl_ joined
[23:50] *** benabik joined
[23:54] *** maguro joined
[23:55] *** thou left
