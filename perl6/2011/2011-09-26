[00:01] *** replore joined
[00:11] *** risou_awy is now known as risou

[00:14] *** thou left
[00:20] <TimToady> sorear: no, % is not really a quantmod; it's orthogonal to the real quantmods

[00:20] <phenny> TimToady: 25 Sep 23:08Z <sorear> tell TimToady My current reading of S05 tells me that % is a quantmod, and since you may only have one quantmod, this means there is no shorter way to say [ :r x+ % ',' ].  Is that correct?

[00:21] <TimToady> std: / x+: % ',' /

[00:21] <p6eval> std c22b2ee: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter % (must be quoted to match literally) at /tmp/NfubPfK1XM line 1:␤------> / x+: %⏏ ',' /␤Unable to parse regex; couldn't find final '/' at /tmp/NfubPfK1XM line 1:␤------> / x+: %[…

[00:21] <TimToady> hasn't updated, grr

[00:22] <TimToady> anyway, STD currently calls it <separator>, not <quantmod>

[00:22] <japhb> What syntax would you use to mix in an anonymous parametric role?  $foo but role [$x]["blarg"] { method foo { $x } }  ?

[00:23] <sorear> japhb: question contains a type error

[00:23] <sorear> parametric roles, anonymous or otherwise, cannot be mixed in

[00:23] <jnthn> um.

[00:24] <jnthn> Parametric ones sure can.

[00:24] <sorear> "but" requires a curried role

[00:24] <jnthn> sorear: but or does could either see a PRG or a CR

[00:25] <sorear> well, you can use a 0-arg parametric role

[00:25] <sorear> but I think that's more of a punning thing than anything else

[00:25] <jnthn> japhb: Anonymous ones are problematic there I suspect, but note you could use a lexically scoped role

[00:25] <sorear> Foo allows itself to mean Foo[]

[00:25] <sorear> Foo(PRG) allows itself to mean Foo[](CR)

[00:25] <japhb> .oO( Is it a good thing or a bad thing that every time I ask a question, I seem to start a spec discussion? )

[00:26] <sorear> this isn't a spec discussion

[00:26] <jnthn> japhb: You haven't.

[00:26] *** aber joined
[00:26] *** orafu left
[00:27] <jnthn> nom: sub foo($s) { my role R[$x] { method x { $x } }; 42 but R[$s] }; my $x = foo('lol'); say $x; say $x.x

[00:27] <p6eval> nom 8b7a2a: OUTPUT«42␤lol␤»

[00:27] <sorear> japhb: you could write $foo buf role[$x,$y] { ... }.  However this would make no sense, because the role's arguments need to be instantiated first

[00:27] <jnthn> japhb: You could do something like the above.

[00:27] *** abercrombie left
[00:27] <jnthn> sorear: Ah, I see what you were getting at.

[00:27] *** jesk left
[00:28] <jnthn> In which case, yeah, I think I agree. :)

[00:28] <japhb> sorear, my original question was how to be an anon parametric role and instantiate it and "mix it in" all in one statement

[00:28] *** orafu joined
[00:28] <sorear> std: 1

[00:28] *** jesk joined
[00:28] <p6eval> std c22b2ee: OUTPUT«ok 00:01 117m␤»

[00:28] <jnthn> japhb: I don't think there's a way to do that.

[00:28] <japhb> jnthn, ah, OK, well at least I didn't miss it in the spec.  :-)

[00:28] <sorear> TimToady: c22b2e is the most recent version of STD you've push

[00:28] <sorear> ed

[00:29] *** risou is now known as risou_awy

[00:32] <sorear> rakudo: my $y = 42 but Metamodel::CurriedRoleHOW.new_type(role [$x] { method foo { $x } }, "foo"); say $y.foo

[00:32] <p6eval> rakudo 8b7a2a: OUTPUT«foo␤»

[00:32] <jnthn> ...wow :)

[00:32] <sorear> wow, it worked on the first try

[00:33] <jnthn> ;)

[00:33] <sorear> I'm kindof suprised it's not written .^curry("foo")

[00:33] <dalek> specs: ff11f19 | larry++ | S05-regex.pod:

[00:33] <dalek> specs: define %%; clarify that % is not quantmod

[00:33] <dalek> specs: 

[00:33] <dalek> specs: ingy++ requested a method of stopping optionally after the separator,

[00:33] <dalek> specs: so that's now %% (with some notion of "evenly divisible" in some kind

[00:33] <dalek> specs: of loose sense).  (Note, if you want to require the separator at the

[00:33] <dalek> specs: end, don't use this construct, just use [x ',']* or such.

[00:33] <dalek> specs: 

[00:33] <dalek> specs: sorear++ requested clarification: % (and %%) are not really quantifier

[00:33] <dalek> specs: modifiers; they modify a quantified atom to insert requirements

[00:33] <dalek> specs: between each iteration of that quantified atom.  Hence any quantifier

[00:33] <dalek> specs: may still take an additional control quantmod in addition to a separator.

[00:33] <dalek> specs: review: https://github.com/perl6/specs/commit/ff11f19331

[00:33] <dalek> specs: 6d7f9f1 | larry++ | S32-setting-library/ (2 files):

[00:33] <dalek> specs: Merge branch 'master' of github.com:perl6/specs

[00:33] <dalek> specs: review: https://github.com/perl6/specs/commit/6d7f9f1ad5

[00:33] <jnthn> sorear: That was somewhat deliberate.

[00:34] <jnthn> sorear: It means you can override currying of roles in a given lexical scope.

[00:34] <jnthn> sorear: Without having to override the role group etc.

[00:34] <jnthn> sorear: Seeing EXPORTHOW will probably make this a bit more concrete.

[00:37] <dalek> std: d1876cf | larry++ | STD.pm6:

[00:37] <dalek> std: Allow Foo(Bar) syntax in declarations

[00:37] <dalek> std: review: https://github.com/perl6/std/commit/d1876cf639

[00:37] <dalek> std: 9fe2e1b | larry++ | STD.pm6:

[00:37] <dalek> std: add %% form of %

[00:37] <dalek> std: review: https://github.com/perl6/std/commit/9fe2e1b0db

[00:39] <jnthn> Grr. Every time I make the optimizer smarter, I make a bunch of spectests fail as a reward.

[00:39] <jnthn> dies_ok { end() }, '... end() dies without an argument';

[00:39] <jnthn> Now fails

[00:40] <jnthn> ===SORRY!===

[00:40] <jnthn> CHECK FAILED:

[00:40] <jnthn> Dispatch to 'end' could never work with the arguments of types ()

[00:40] <jnthn> And so we never get to run the test...

[00:40] <TimToady> std: / x+: % y /

[00:40] <p6eval> std c22b2ee: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter % (must be quoted to match literally) at /tmp/ehdl1eGzWi line 1:␤------> / x+: %⏏ y /␤Unable to parse regex; couldn't find final '/' at /tmp/ehdl1eGzWi line 1:␤------> / x+: %[33…

[00:40] <jnthn> (yes, error should be improved to say it's an arity fail)

[00:40] <TimToady> sorear: it *says* it's running c22b2ee, but it's not

[00:41] <TimToady> ingy: you can now end it in either spot using %% instead of %

[00:44] *** uasi joined
[00:45] <dalek> rakudo/optimizer: fa826a0 | jnthn++ | src/binder/multidispatch.c:

[00:45] <dalek> rakudo/optimizer: Greatly weaken the 'could never work' analysis - the initial version was wrong. Add a note about how we probably can catch a bunch of obvious cases.

[00:45] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/fa826a0657

[00:45] <dalek> rakudo/optimizer: 055835c | jnthn++ | src/ (2 files):

[00:45] <dalek> rakudo/optimizer: Start to do the compile time multi-dispatch analysis. At the moment, we don't actually use the 'I identified the candidate' result, but there's a stub for doing so. We do complain about dispatches that are identified as impossible though, with the result that a bunch of spectests that checked things like '&end requires an argument' now fail to compile.

[00:45] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/055835c7e5

[00:47] <TimToady> moritz: shouldn't your <=> be cmp instead?  you're doing string comparison semantics, not numeric

[00:47] <TimToady> referring to http://irclog.perlgeek.de/perl6/2011-09-25#i_4476247

[00:47] <TimToady> <=> would convert the buffers to numbers and then compare

[00:48] <TimToady> (remember buffers are allowed to be ASCII, which includes "123")

[00:49] *** uasi left
[00:51] <jnthn> Probably should sleep...gotta try and catch up with $epicly-behind-project tomorrow... &

[00:58] <sorear> phenny: tell jnthn If the optimizer breaks a spectest, change dies_ok to eval_dies_ok.  That's why we have it.

[00:58] <phenny> sorear: I'll pass that on when jnthn is around.

[01:05] *** woosley joined
[01:11] *** thou joined
[01:12] *** wolfman2000 joined
[01:26] *** daniel-s joined
[01:28] *** whiteknight left
[01:35] *** frhodes_ joined
[01:35] *** mkramer joined
[01:36] *** aber left
[01:37] *** frhodes_ left
[01:37] *** mkramer1 left
[01:52] *** thou left
[01:57] *** abercrombie joined
[02:01] *** cotto left
[02:01] *** cotto joined
[02:10] *** saaki joined
[02:18] *** alvis left
[02:20] <PerlJam> Anyone awake?

[02:23] <colomon> for another ten minutes or so

[02:23] <PerlJam> Is there a problem building nqp or is it just me?

[02:23] <PerlJam> (I'm checking the latter condition right now)

[02:23] <soh_cah_toa_> yeah, me too

[02:24] <soh_cah_toa_> something about kill-useless-defaults i think

[02:24] * colomon turns it over to soh_cah_toa_ ...  ;)

[02:24] <soh_cah_toa_> that's about as far as my knowledge goes ;)

[02:24] <soh_cah_toa_> the kill-useless-defaults branch broke nqp

[02:25] <benabik> Parrot master needs nqp/kill-useless-defaults

[02:25] <soh_cah_toa_> moritz might be working on it i think

[02:25] *** uasi joined
[02:25] <PerlJam> aye ... I see it now.

[02:25] <benabik> NQP master will be broken on Parrot master until after Rakudo cuts a release, I think.

[02:25] <soh_cah_toa_> whenever the heck that will be :(

[02:26] <benabik> Because there's a desire to base the release on Parrot 3.8

[02:26] <benabik> soh_cah_toa_: I think it's supposed to be soon.

[02:26] <soh_cah_toa_> right, just like last month was gonna be soon ;)

[02:27] <soh_cah_toa_> nah, i'm not trying to be a crab or anything. i can understand unforseen problems

[02:28] <soh_cah_toa_> i'm just really tried of being stuck w/ all the nyi features of 2011.07

[02:29] <benabik> pmichaud said he'd land some regex updates prior to release, but real life has caught up with him, I think.

[02:30] <soh_cah_toa_> oh yeah, qregex. forgot about that

[02:30] *** drbean left
[02:30] <PerlJam> I had a weird dream about pmichaud last night.  I wonder if it was my psychic brain trying to tell me something

[02:31] *** alvis joined
[02:31] * soh_cah_toa_ will be super happy if qregex supports escape sequences in character classes

[02:32] *** drbean joined
[02:32] <woosley> perl6: say (1,2,3)  X++ (4,5,6)

[02:32] <p6eval> pugs: OUTPUT«123␤*** Can't modify constant item: VInt 4␤    at /tmp/nphDPuH7a6 line 1, column 1 - line 2, column 1␤»

[02:32] <p6eval> ..niecza v9-51-g493fbf9: OUTPUT«===SORRY!===␤␤Postfix found where infix expected (omit whitespace?) at /tmp/mcpWMqEvD2 line 1:␤------> say (1,2,3)  X⏏++ (4,5,6)␤␤Parse failed␤␤»

[02:32] <p6eval> ..rakudo 8b7a2a: OUTPUT«4 5 6␤»

[02:33] <PerlJam> woosley: there is no infix:<++>

[02:33] <PerlJam> (though rakudo's response is ... interesting)

[02:33] <woosley> PerlJam: yes, but what is rakudo doing here?

[02:34] <benabik> rakudo: say 1 ++ 4

[02:34] <p6eval> rakudo 8b7a2a: OUTPUT«5␤»

[02:34] <PerlJam> craziness!

[02:37] <benabik> rakudo: say (3,2,1) X++ (1,2,3)

[02:37] <p6eval> rakudo 8b7a2a: OUTPUT«6 5 4␤»

[02:37] <benabik> rakudo: say (3,2,1) X++ (1,2)

[02:37] <p6eval> rakudo 8b7a2a: OUTPUT«5 4 3␤»

[02:38] <benabik> Looks like it's doing LHS + size of RHS

[02:38] <woosley> rakudo: say ((1,2) Z++ (4,5)).perl

[02:38] <p6eval> rakudo 8b7a2a: OUTPUT«(3,).list␤»

[02:38] <woosley> :-(

[02:39] <PerlJam> woosley: aye, (1,2,3) X++ (4,5,6)  is parsed as (1,2,3) X+  +(4,5,6)

[02:39] <PerlJam> rakudo: say (1,2,3) X++++ (4,5,6)

[02:39] <p6eval> rakudo 8b7a2a: OUTPUT«Cannot assign to a readonly variable or a value␤  in sub prefix:<++> at src/gen/CORE.setting:2221␤  in <anon> at /tmp/AVQg9dL8mS:1␤  in <anon> at /tmp/AVQg9dL8mS:1␤␤»

[02:40] <PerlJam> rakudo: say (1,2,3) X+++ (4,5,6)

[02:40] <p6eval> rakudo 8b7a2a: OUTPUT«Method 'succ' not found for invocant of class 'Parcel'␤  in sub prefix:<++> at src/gen/CORE.setting:1044␤  in <anon> at /tmp/il70byLfo9:1␤  in <anon> at /tmp/il70byLfo9:1␤␤»

[02:40] *** wolfman2000 left
[02:40] <woosley> rakudo: say (1,2,3) X/+- (2,5,6)

[02:40] <p6eval> rakudo 8b7a2a: OUTPUT«-0.333333333333333 -0.666666666666667 -1␤»

[02:40] <soh_cah_toa_> hm, if only there was some sort of debugger you could use. then you might just be able to figure out what rakudo is doing there ;)

[02:41] <soh_cah_toa_> too bad... ;)

[02:54] *** Trashlord left
[02:55] *** wolfman2000 joined
[02:55] *** Trashlord joined
[03:03] *** packetknife joined
[03:04] *** uasi left
[03:05] *** drbean left
[03:16] *** uasi joined
[03:26] <soh_cah_toa_> why are the classes IO::Socket::INET and IO::Socket declared lexically?

[03:26] <soh_cah_toa_> s/declared/defined/

[03:28] <soh_cah_toa_> yet they have file scope

[03:29] <soh_cah_toa_> well, they do use {} brackets but they're the only thing in the file

[03:29] <soh_cah_toa_> regardless, it just seems weird

[03:31] <soh_cah_toa_> aw...lame. i can't 'use IO::Socket::INET'? it's not installed?

[03:46] *** envi_laptop joined
[03:49] *** soh_cah_toa_ left
[03:52] <abercrombie> Hi, how to set Perl5's $" in Perl6?

[03:52] <sorear> Perl6 doesn't have a $"

[03:52] <sorear> we shun global variables

[03:52] <abercrombie> I have a list but I don't want to print it with the spaces

[03:52] <sorear> say @list.join(",")

[03:53] <abercrombie> rakudo: my @list=(1,2,3); say @list.join(",").WHAT

[03:53] <p6eval> rakudo 8b7a2a: OUTPUT«Str()␤»

[03:53] <abercrombie> sorear: Thanks.

[03:56] *** donri left
[04:05] *** satyavvd joined
[04:05] *** envi_laptop left
[04:07] <sorear> ugh, p6eval is still using tryfile

[04:07] <sorear> that's the problem!

[04:08] <abercrombie> $a = ???;  say $a.WHAT;  # how to fill ??? to make the output print List() ?

[04:09] <sorear> $a = List;

[04:09] <abercrombie> Sorry, I mean is there a form like (1,2,3) or [1,2,3]

[04:10] <sorear> No.  Why do you want one?  List needs to die in a fire anyway.

[04:11] <abercrombie> Because I found if $a = $*IN.lines, then $a.WHAT is List(). I don't know what's the internal structure of $*IN.lines

[04:11] <sorear> List is basically the same as Array, but with a different type name for not much good reason

[04:12] <sorear> Array and List and Seq have exactly the same internal structure

[04:12] <sorear> it is my opinion that only one of them needs to exist

[04:13] <abercrombie> The problem is, my $str="abc"; say $str>>~^>>" "    this one works. But my $str=$*IN.lines; say $str>>~^>>" " this will give me an error

[04:14] <abercrombie> Sorry, I made a mistake. That's not what I was going to say

[04:15] <abercrombie> my $str=("a","b","c"); say $str>>~^>>" "  # this one works

[04:15] <abercrombie> my $str=$*IN.lines; say $str.WHAT; say $str>>~^>>" " #this one doesn't work

[04:15] <abercrombie> the only difference seems to me is Seq vs List

[04:16] <sorear> rakudo: say (<a b c>).WHAT

[04:16] <p6eval> rakudo 8b7a2a: OUTPUT«Parcel()␤»

[04:16] <sorear> rakudo: say (<a b c>).list.WHAT

[04:16] <p6eval> rakudo 8b7a2a: OUTPUT«List()␤»

[04:17] <sorear> I hope you only wanted that for testing

[04:19] <abercrombie> Actually I am trying to implement a uppercase to lowercase and vice versa. If I fix the string in the program, it works, like:

[04:19] <abercrombie> rakudo: my $str="aBc"; say $str.comb(/./)>>~^>>" "

[04:19] <p6eval> rakudo 8b7a2a: OUTPUT«A b C␤»

[04:20] <abercrombie> Now I want to do things like these:

[04:20] <abercrombie>  echo "aBc"|perl6 -e 'say $*IN.lines>>~^>>" "'

[04:20] <abercrombie> but this doesn't work

[04:21] <abercrombie> I don't know why. the previous one, comb gives a List, it works. In the latter one, IN.lines is also a list, but it doesn't work. 

[04:23] *** uasi left
[04:24] *** packetknife left
[04:28] <sorear> abercrombie: fwiw, I think what you're doing has been ruled illegal

[04:28] <sorear> ~^ works on Buf, not Str

[04:29] <sorear> abercrombie: obviously something is up with rakudo's hyperops

[04:30] <abercrombie> Do you mean the first one is a List of Buf, but the second one is a List of Str?

[04:31] <sorear> you're using ~^ on two Strs

[04:31] <sorear> that's illegal

[04:31] <sorear> ~^ requires two Bufsd

[04:31] <abercrombie> Rakduo: say "123" ~+ "456"

[04:31] <abercrombie> rakduo: say "123" ~+ "456"

[04:31] <abercrombie> rakudo: say "123" ~+ "456"

[04:31] <p6eval> rakudo 8b7a2a: OUTPUT«123456␤»

[04:31] <abercrombie> rakudo: say "123" ~^ "456"

[04:31] <p6eval> rakudo 8b7a2a: OUTPUT«␤»

[04:32] <abercrombie> Isn't this one correct?

[04:32] <sorear> no

[04:32] <sorear> Str values are encoding-agnostic

[04:32] <sorear> they don't have numeric values, so to XOR them makes little sense

[04:33] <abercrombie> But one article told me to do things like this:

[04:33] <abercrombie> rakudo: "b" ~| "d" 

[04:33] <p6eval> rakudo 8b7a2a:  ( no output )

[04:33] <abercrombie> rakudo: say "b" ~| "d" 

[04:33] <p6eval> rakudo 8b7a2a: OUTPUT«f␤»

[04:33] <abercrombie> this one

[04:33] <abercrombie> is incorrect too?

[04:34] <sorear> yes

[04:35] <abercrombie> http://perlgeek.de/en/article/5-to-6#post_11

[04:35] <sorear> how recent was the article, and was it written by someone who should know better?

[04:35] <abercrombie> That's the perl5 to perl6 written by moritz

[04:36] <sorear> I think that needs to be updated, once we decide what the syntax for Buf literals is.

[04:36] <sorear> anyway doing any kind of bitops on Strs is fundamentallly wrong in Perl 6's pluralistic culture

[04:37] <sorear> rakudo: say "αβΓδΕζΗ" ~^ "       "

[04:37] <p6eval> rakudo 8b7a2a: OUTPUT«string bitwise_xor (utf8/utf8) unsupported␤  in sub infix:<~^> at src/gen/CORE.setting:3182␤  in <anon> at /tmp/8lao7TVDKC:1␤  in <anon> at /tmp/8lao7TVDKC:1␤␤»

[04:37] <abercrombie> Yes, that's the error I got

[04:37] <sorear> Why didn't you say so at the beginning?

[04:37] <sorear> **This has absolutely nothing to do with Lists.**

[04:38] <abercrombie> Oh, I'm sorry. I wrongly thought it just caused by the behavior of $*IN.lines

[04:38] <abercrombie> So what should I do with ~^ ? Could you give me a simple example with Buf? I never used Buf directly

[04:39] <sorear> anyway doing any kind of bitops on Strs is fundamentallly wrong in Perl 6's pluralistic culture

[04:40] <sorear> you could use it to generate parity blocks or something like that

[04:41] <abercrombie> Is there a situation for one to write code like Buf $x = ...   ? I mean directly deal with Buf

[04:41] *** uasi joined
[04:43] <abercrombie> "anyway doing any kind of bitops on Strs is fundamentallly wrong". I'm not very clear about that. Is that just like you cannot do "char* p="abc"; p[0]='a';" in C/C++?

[04:44] <sorear> abercrombie: It's more like why you cannot do "double a = 1.5; double b = 10.1; double c = a ^ b;" in C/C++

[04:44] <abercrombie> Oh, I see.

[04:44] <sorear> http://catb.org/~esr/faqs/smart-questions.html#goal  -  this document seems to assume the target is talking about a bug.  I need something slightly different here.

[04:49] <abercrombie> If the string content can be assured to be an integer, then for ~^ this kind of operations can be allowed. Otherwsise, the operation doesn't make sense. That's why we need to prohibit it. Am I right? 

[04:51] <abercrombie> With Buf, I know what I am doing, so that's not a problem. 

[04:54] <sorear> abercrombie: it doesn't make much sense, ever, because assigning numbers to characters is the job of the IO layer

[04:55] <sorear> abercrombie: Str doesn't know whether the programmer was trained on EBCDIC or ASCII, and it only gets worse with other alphabets

[04:55] <abercrombie> So if I want to deal with the binary representation of the string, I should use buffer instead to make it clear?

[04:56] <sorear> yes

[04:56] <sorear> wait, no

[04:56] <sorear> your question is wrong

[04:56] <sorear> you said "the binary representation of the string"

[04:57] <sorear> what I've been trying to tell you for the last ten minutes... there are many possible binary representations

[04:57] <abercrombie> "the * representation of the string"

[04:58] <sorear> "the * representation of the string" isn't made of bits, so applying bit operations to it is nonsense.

[04:58] <sorear> Seriously, take 20 steps back and tell us your REAL problem.

[05:00] <abercrombie> Well, just a friend of mine asked me to implement the conversion I described before for fun, of course with perl6, and trying to make the code as smaller as possible

[05:01] <sorear> Perl 6 philosophy is to make it hard to write programs that work in the lab but fail in the field

[05:02] <sorear> Perl 6 tries hard to stop you from writing English-only programs

[05:03] <abercrombie> Yes. I just tend to relate Str() with char* or wchar_t*

[05:04] <sorear> Str is a bit more general than either of those, because a 1-'chars' Str might contain composing characters

[05:04] <sorear> like n+diaeresis

[05:04] <abercrombie> I didn't know there are numerous representation underlying Str().

[05:07] <abercrombie> Thanks a lot. I will look into the Unicode part of Syn once it's finished. Lack of O2 now.. need to go to bed. GN~

[05:08] *** abercrombie left
[05:31] *** sayu joined
[05:37] *** koban` joined
[05:38] *** koban` left
[05:39] *** cognominal joined
[05:39] *** cognominal___ left
[05:49] *** nebuchadnezzar left
[05:52] *** nebuchadnezzar joined
[05:57] *** odoacre left
[05:57] *** odoacre joined
[06:06] <sorear> evalbot control restart

[06:06] *** p6eval left
[06:06] *** orafu left
[06:06] <sorear> std: /x+%y/

[06:06] *** p6eval joined
[06:06] *** ChanServ sets mode: +v p6eval

[06:06] <sorear> std: /x+%y/

[06:06] *** orafu joined
[06:06] <p6eval> std 9fe2e1b: OUTPUT«ok 00:01 120m␤»

[06:07] *** kaleem joined
[06:07] <sorear> phenny: tell TimToady fixed!

[06:07] <phenny> sorear: I'll pass that on when TimToady is around.

[06:07] *** uasi left
[06:08] <dalek> evalbot: af9321e | sorear++ | evalbot.pl:

[06:08] <dalek> evalbot: Fix std: PERL5LIB fail

[06:08] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/af9321e6f9

[06:14] *** masak joined
[06:14] <masak> morngtn.

[06:14] <masak> <tadzik> haha, watch this

[06:14] <masak> <tadzik> GOOD MORNING MASAK!

[06:14] <masak> I love this channel. :)

[06:14] <moritz> good am, ma sak

[06:15] <masak> yo, mo.

[06:16] <masak> [backlog] I'm glad the potential problems of x ** -100..100 are getting some attention.

[06:17] <masak> if it were up to me, negative values in ranges in infix:<**> expressions in regexes would be the first ones up against the wall when the revolution comes.

[06:22] <moritz> "Perl 6 Revolution Edition: with triple impact and improved sanity!"

[06:28] *** colomon left
[06:29] <sorear> well, we're using the whirlpool model, so the revolution is continuous.  And dizzying.

[06:30] <sorear> ps, I'd like people to read my exchange with abercrombie and tell me where I went wrong.

[06:30] <sorear> I know I handled that badly.

[06:31] <sorear> niecza: any<foo bar>

[06:31] <p6eval> niecza v9-51-g493fbf9: OUTPUT«===SORRY!===␤␤The 'any' listop may not be called without arguments (please use () or whitespace to clarify) at /tmp/_DVsq0AAou line 1:␤------> any⏏<foo bar>␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/bo…

[06:32] *** packetknife joined
[06:36] <masak> sorear: ISTR TimToady recently explained that x++ is equivalent to x+:

[06:36] <masak> sorear: I can't find it in the backlog because it's hard to search for.

[06:36] <sorear> yes

[06:36] <masak> maybe I submitted an RT ticket for it.

[06:36] <masak> oh, you already know this.

[06:37] * sorear wonders why git apply thinks this patch is empty

[06:37] <sorear> it was generated by git diff, and it's clearly _not_ empty

[06:39] <sorear> there, finally got it to work

[06:45] *** fridim_ left
[06:45] <dalek> niecza: 198086c | sorear++ | src/STD.pm6:

[06:45] <dalek> niecza: Track recent grammar changes

[06:45] <dalek> niecza: 

[06:45] <dalek> niecza: Amazingly, the patch applied cleanly.

[06:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/198086c2aa

[06:50] <sorear> How are & and && ($~Regex) intended to be implemented?

[06:52] <dalek> roast: a5e45f1 | Coke++ | S32-io/IO-Socket-INET.t:

[06:52] <dalek> roast: nom fudge updates.

[06:52] <dalek> roast: 

[06:52] <dalek> roast: Test passes here on darwin; use todo instead of skip where possible.

[06:52] <dalek> roast: review: https://github.com/perl6/roast/commit/a5e45f108a

[06:52] <sorear> niecza: say substr("foo", 4, 1)

[06:53] <p6eval> niecza v9-51-g493fbf9: OUTPUT«Str()␤»

[06:53] <dalek> rakudo/nom: ca5f34b | Coke++ | t/spectest.data:

[06:53] <dalek> rakudo/nom: run fudged test!

[06:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca5f34b16b

[06:57] *** jaldhar left
[06:57] *** jaldhar joined
[07:02] <[Coke]> sorear: "make spectest" depends on t/spec existing, but is missing an explicit rule to do the checkout.

[07:04] * [Coke] forks and prepares a pull request.

[07:06] *** jaldhar left
[07:07] *** jaldhar joined
[07:10] *** jaldhar left
[07:11] <masak> sorear: IIUC, & actually falls out very naturally of any Thompson/DFA approach.

[07:11] *** jaldhar joined
[07:11] <masak> it's just the dual of |

[07:12] *** aloha left
[07:13] *** aloha joined
[07:14] *** mj41 joined
[07:15] <masak> sorear: I don't think you handled the exchange with abercrombie too badly. you sound a bit peeved through it, but that's probably fine.

[07:21] <[Coke]> question: if niecza complains about a spectest because it declares a variable it doesn't use (like, a my $x that is deliberately overriden in an inner scope to make sure the outer one isn't used), is it ok to use the variable somewhere to make it happy?

[07:21] <[Coke]> Or is that peculiar to niecza and I shouldn't encourage her?

[07:22] *** aloha left
[07:23] *** aloha joined
[07:25] <[Coke]> ah, that's not an error, it's a warning, and there's another warning. nevermind. ;)

[07:25] <[Coke]> er, another *error*

[07:30] <tadzik> good morning

[07:31] *** aloha left
[07:32] <sorear> [Coke]: if you end a line with #OK it suppresses warnings on that line.

[07:32] <sorear> [Coke]: you can also say #OK not used to be more specific, but because it's a substring test on the warning message, it strikes me as concerningly fragile, esp. wrt. l10n

[07:33] <sorear> masak: I was getting frustrated, yes.

[07:34] *** SHODAN joined
[07:34] <sorear> masak: regular expressions are constructed inductively using *NFA*s.  & falls out of *DFA* handling.  Put them together and the only algorithm I've found has time complexity that requres _tetration_ to express

[07:35] <sorear> I don't like algorithms whose time complexity cannot be bounded with a finite number of exponentials.

[07:36] *** uasi joined
[07:40] <japhb> picky, picky sorear

[07:41] <sorear> :>

[07:41] <masak> tetration, eh? :)

[07:42] <masak> also, one of these days I got to learn the difference between NFAs and DFAs. :/

[07:42] <[Coke]> sorear: I'm going to fudge some spec tests for niecza so you can start adding them to the run. Feel free to suggest improvements to things as I go. For now, since can't 'todo', will "skip 'todo'"; if it's an actual skip, will include the error I got when trying to run it.

[07:42] <sorear> [Coke]: thanks!

[07:43] <sorear> I'll look into todo after I finish %

[07:43] <sorear> Where should I add % tests?

[07:43] <japhb> sleep &

[07:44] *** uasi left
[07:46] <masak> sorear: separate file?

[07:47] <sorear> good idea

[07:49] <[Coke]> sorear: if you give me a commit bit, I can update t/spectest.data, also.

[07:49] *** wtw joined
[07:50] <[Coke]> FYI, niecza is already running S02-types/bool.t, but it's not in the spectest.data file.

[07:51] <[Coke]> ... sorry, "but it's being reported as unrun by tools/unrun*" ;)

[07:51] <[Coke]> I think you want s/8/9 in tools/unrun*

[07:52] <dalek> roast: 5bf3e6e | Coke++ | S02-types/whatever.t:

[07:52] <dalek> roast: niecza fudge

[07:52] <dalek> roast: review: https://github.com/perl6/roast/commit/5bf3e6e771

[07:52] <dalek> roast: be01201 | Coke++ | S02-types/num.t:

[07:52] <dalek> roast: niecza fudge

[07:52] <dalek> roast: review: https://github.com/perl6/roast/commit/be0120193a

[07:54] <sorear> [Coke]: on my system, 8 works correctly and 9 doesn't.  "I guess this means that processing find output with fixed templates isn't portable."

[07:54] <sorear> [Coke]: can you give me a sample line of find output?

[07:55] <sorear> find t/spec/ -name '*.t' | head

[07:56] <jnthn> mornin'

[07:56] <phenny> jnthn: 00:58Z <sorear> tell jnthn If the optimizer breaks a spectest, change dies_ok to eval_dies_ok.  That's why we have it.

[07:57] <jnthn> Yes, I know. :)

[07:57] <moritz> it's not so easy

[07:58] <moritz> eval_dies_ok eval()s in a different lexical scope

[07:58] <jnthn> ah.

[07:58] <sorear> "Clearly we need a macro version"

[07:59] <jnthn> er, I'm not sure that'd help :)

[07:59] <sorear> a macro could bind eval in the caller's lexical scope without wrecking optimization

[07:59] <[Coke]> t/spec//integration/99problems-01-to-10.t

[07:59] <[Coke]> find t/spec # not t/spec/ works here.

[07:59] <sorear> for niecza I've made the rule that all eval calls must be more or less statically obvious

[08:00] <sorear> [Coke]: oh, because you have a real t/spec checkout

[08:00] <jnthn> sorear: I'm curious how that'll work out.

[08:00] <jnthn> sorear: Of it we're really allowed to do that.

[08:00] <jnthn> my &foo = &eval; ....way later... foo('oh lol $x')

[08:01] <jnthn> *Or

[08:01] <sorear> [Coke]: for me t/spec is a symlink to roast

[08:01] <sorear> jnthn: erroneous

[08:01] <sorear> jnthn: note that Javascript has the same rule now.

[08:01] <dalek> roast: ff382f2 | Coke++ | S02-types/lists.t:

[08:01] <dalek> roast: niecza fudge

[08:01] <dalek> roast: review: https://github.com/perl6/roast/commit/ff382f215a

[08:01] <[Coke]> sorear: I'd have what you had if "make spectest" did that for me. ;)

[08:01] <jnthn> sorear: If TimToady++ is happy with such a call, then I am too...it makes a bunch of optimizations possible. :)

[08:01] <moritz> or maybe eval() should have a :lexical_env_from_caller named param

[08:01] <[Coke]> I'm proceeding fine in the meantime. no rush.

[08:02] <[Coke]> ok, there's 3 files, anyway. I really should sleep, I suppose.

[08:03] <sorear> sleep well

[08:03] <sorear> jnthn: let's badger him later?

[08:03] <jnthn> sorear: Unless he self-badgers as he backlogs ;)

[08:03] <moritz> backlog? what's that? :-)

[08:04] <jnthn> sorear: Anyway, it'd be interesting to get a ruling either way, especially given I'm doing a bunch of optimizer work at the moment.

[08:04] <moritz> but it's generally ok to just run  ok eval 'code...'

[08:05] <moritz> erm, probably   nok eval 'code..; 1'

[08:06] <dalek> niecza: 952a401 | sorear++ | src/ (2 files):

[08:06] <dalek> niecza: Wire %/%% up to regex compiler

[08:06] <dalek> niecza: 

[08:06] <dalek> niecza: Right now only the x+ % y case seems to work reliably.  I'll have to

[08:06] <dalek> niecza: debug this later, but at least you can start using non-deprecated

[08:06] <dalek> niecza: syntax right away.

[08:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/952a401f76

[08:06] <sorear> masak: does this count?

[08:07] <sorear> anyway I need to sleep now

[08:07] <jnthn> Sleep well

[08:07] <sorear> tomorrow: release v10, try to get todo working on master, try to get type definitions working on serialize

[08:08] <mls_> perl6: sub foo() returns Int {die; CATCH { default {} }}; say foo().WHAT

[08:08] <p6eval> niecza v9-52-g198086c: OUTPUT«Nil␤»

[08:08] <p6eval> ..rakudo ca5f34: OUTPUT«Can only use get_what on a SixModelObject␤  in <anon> at /tmp/4w36JNPzlk:1␤  in <anon> at /tmp/4w36JNPzlk:1␤␤»

[08:08] <p6eval> ..pugs: OUTPUT«*** Died␤    at /tmp/4xxK4FyORu line 1, column 56 - line 2, column 1␤       /tmp/4xxK4FyORu line 1, column 24-27␤»

[08:08] <masak> sorear++

[08:08] <masak> sorear: 'night.

[08:09] <mls_> fail for all three...

[08:09] <mls_> btw, morning perl6!

[08:11] <jnthn> hi mls_ 

[08:11] <jnthn> ok, time to go worry about $dayjob for a bit.

[08:12] <mls_> have fun! ;)

[08:12] <moritz> \o mls_ 

[08:12] <mls_> hi moritz!

[08:13] <mls_> still working in Buf?

[08:13] <mls_> on

[08:13] <moritz> mls_: yes, TimToady++ pointed out an error in my patch in the backlog

[08:14] <moritz> but first I want to fix a few tests that the optimizer branch by jnthn++ broke

[08:15] <mls_> jnthn++ breaks things? Ts ts...

[08:15] <moritz> well, he moves some errors from run time to compile time

[08:16] <mls_> that's probably not a bad thing ;)

[08:16] <moritz> which is great for all cases except for tests that exercise these errors

[08:16] <mls_> oh yes, true. So lots of evals?

[08:17] <moritz> right

[08:21] <ingy> TimToady++ # thanks!

[08:22] * ingy heads off to implement %

[08:22] <masak> ingy: you got your very own operator! :)

[08:22] <snarkyboojum> modingy!

[08:22] <ingy> masak: and it's ingfix!

[08:23] <masak> :P

[08:29] <ingy> masak: today I'll write a pegex receiver called Pegex::Pegex::Emitter::P6Regex

[08:29] <masak> nice!

[08:29] <ingy> think it should be trivial to do

[08:31] <ingy> although it may lead to discovering impedance mismatches between pegex and p6

[08:31] <ingy> which is cool I suppose

[08:33] *** bazqux joined
[08:35] <masak> LTM is cool, but sometimes things refuse to work until I add a :: somewhere in some rule.

[08:35] <masak> I wish I had a better intuition for when and why that is needed.

[08:39] <dalek> roast: 27d699f | moritz++ | S32- (5 files):

[08:39] <dalek> roast: move some errors into eval()

[08:39] <dalek> roast: 

[08:39] <dalek> roast: Those conditions can be caught at compile time by a smart compiler or

[08:39] <dalek> roast: optimizer (as does the rakudo/optimizer branch), so guard against that

[08:39] <dalek> roast: review: https://github.com/perl6/roast/commit/27d699f405

[08:41] <moritz> TimToady: what should Buf.Int do? since S02 says Buf is a "stringish view of an array of integers", I expected it to return .elems, not .decode.Int

[08:41] <moritz> nom: say Buf.new(130).decode('ascii')

[08:41] <p6eval> nom ca5f34: OUTPUT«Invalid character in ASCII string␤  in method decode at src/gen/CORE.setting:4804␤  in <anon> at /tmp/AY5pDlLQyW:1␤  in <anon> at /tmp/AY5pDlLQyW:1␤␤»

[08:42] <masak> moritz: I think I expect that too, fwiw.

[08:43] <moritz> though maybe I misunderstand "stringish view"

[08:43] <moritz> I understand it as "add a few methods and operators that make it look more like a Str"

[08:43] <moritz> but maybe what is meant is "hide most of the array semantics, and show more Str semantics instead"

[08:44] <moritz> the "joy" of not being a native speaker

[08:47] <jnthn> moritz: Thanks :)

[08:47] <jnthn> (for test updates)

[08:47] <dalek> roast: 1c9a698 | moritz++ | S32-io/IO-Socket-INET.t:

[08:47] <dalek> roast: avoid warnings

[08:47] <dalek> roast: review: https://github.com/perl6/roast/commit/1c9a698112

[08:47] <moritz> jnthn: you're welcome. I guess you're aware that undef.t still fails

[08:48] <jnthn> moritz: Yes.

[08:49] <moritz> jnthn: fwiw I look very much foward to the optimizer branch, not just because of speed improvements, but also because I like that it catches stuff at compile time

[08:49] <moritz> but I guess it needs improved error reporting before it can be merged

[08:50] <moritz> (line nunber and file of failure would be great :-)

[08:50] <masak> IIUC, jnthn is just getting started :)

[08:50] <moritz> I know :-)

[08:50] <moritz> oh, and extra credits for catching not just the first error, but all of them

[08:50] <masak> nod.

[08:55] <jnthn> Yeah...what I actually want is to aggregate instances of the same error

[08:55] <jnthn> And then just list the places it's a problem.

[08:55] <jnthn> Undeclared rotuine foo called (line 1,5,42)

[08:55] <jnthn> Or some such.

[08:56] <jnthn> Most of its catching stuff at compile time is just happy fallout of the analysis that it's doing anyway.

[08:57] <moritz> sounds good

[08:57] *** replore left
[08:59] *** lestrrat left
[09:03] *** uasi joined
[09:03] <masak> sounds very sane.

[09:03] <masak> "we're doing this analysis anyway; might's'well alert the user that things won't work at runtime."

[09:04] * moritz wonders if we'll ever hoist die() calls to compile time if we can prove that they'll happen eventually :-)

[09:09] <jnthn> masak: Well, there are places where we can go a step further than what the optimizer needs just for the sake of catching errors too. There's such an opportunity in the multi-dispatch analysis, for example.

[09:10] <jnthn> masak: Will just be a careful balance of not doing so much that the optimizer takes an age to run :)

[09:11] *** sayu left
[09:11] <snarkyboojum> you could have different optimisation levels depending on cli switch praps - so we can go crazy if we want to :)

[09:12] <snarkyboojum> e.g. --optimize gobonkers

[09:13] <snarkyboojum> :P

[09:14] <moritz> As someone pointed out, you could have an attribute that says "optimize

[09:14] <moritz> the heck out of this routine", and your definition of heck would be a

[09:14] <moritz> parameter to the optimizer. -- Larry Wall in [email@hidden.address]
[09:14] <moritz> fortune++

[09:17] <snarkyboojum> moritz: what's that reference - [email@hidden.address] ?

[09:18] <moritz> snarkyboojum: a usenet message ID, I think

[09:18] <snarkyboojum> oic - and what's the fortune reference? :)

[09:18] <moritz> snarkyboojum: I got that quote from  $ fortune perl -m heck\

[09:19] <moritz> erm, without that \

[09:19] <snarkyboojum> v. cool :) os x doesn't have such groovy linux doovywhatsits

[09:20] <snarkyboojum> also recorded on http://en.wikiquote.org/wiki/Larry_Wall

[09:26] *** lestrrat joined
[09:27] <jnthn> .oO( perl6 --heck ... :) )

[09:30] <arnsholt> masak: Did anyone ever compute the expected value of your match distribution?

[09:31] <moritz> arnsholt: no, but we have the PDF, so it should be rather trivial

[09:31] <arnsholt> Indeed

[09:31] <dalek> rakudo/nom: c5fc397 | moritz++ | src/core/Buf.pm:

[09:31] <dalek> rakudo/nom: [Buf] <=> should really be cmp, TimToady++

[09:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c5fc397216

[09:32] <moritz> niecza: sub f($n) { my @p; @p[0][$n] = @p[$n][0] = 1; for 0..40 -> $x { for 0..40 -> $y { @p[$x][$y] //= 0; @p[$x+1][$y] += @p[$x][$y]/2 if $y > 0; @p[$x][$y+1] += @p[$x][$y]/2 if $x > 0; } }; @p[40][40] }; my @dist = (0..40).map: { f($_) }; say [+] @dist; say ~@dist

[09:32] <p6eval> niecza v9-53-g952a401: OUTPUT«1␤0/1 0.0900535481254757 0.0900535481254757 0.0888840215264435 0.0865449683283792 0.083083169595244 0.0785921874549606 0.0732091609169496 0.0671083975072038 0.0604920766262119 0.0535786964403591 214859239356147155/4611686018427387904 0.0397386751092177 3829…

[09:32] <moritz> by jlaire++

[09:32] <jlaire> o/

[09:32] <jlaire> btw if there's something really silly about that code, I'm all ears

[09:32] <moritz> niecza: sub f($n) { my @p; @p[0][$n] = @p[$n][0] = 1; for 0..40 -> $x { for 0..40 -> $y { @p[$x][$y] //= 0; @p[$x+1][$y] += @p[$x][$y]/2 if $y > 0; @p[$x][$y+1] += @p[$x][$y]/2 if $x > 0; } }; @p[40][40] }; my @dist = (0..40).map: { f($_) }; say [+] @dist.pairs.map: *.key * *.value

[09:33] <jlaire> doesn't seem too perl6ish

[09:33] <p6eval> niecza v9-53-g952a401: OUTPUT«Unhandled exception: No value for parameter anon_16 in MAIN C7_ANON␤  at /tmp/kGqXJtEwkT line 0 (MAIN C7_ANON @ 0) ␤  at  line 0 (KERNEL map @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 112 (CORE Any.map @ 2) ␤  at /tmp/kGqXJtEwkT line 1 (MAIN mainl…

[09:33] <moritz> niecza: sub f($n) { my @p; @p[0][$n] = @p[$n][0] = 1; for 0..40 -> $x { for 0..40 -> $y { @p[$x][$y] //= 0; @p[$x+1][$y] += @p[$x][$y]/2 if $y > 0; @p[$x][$y+1] += @p[$x][$y]/2 if $x > 0; } }; @p[40][40] }; say [+] (0..40).map: { $_ * f($_) }

[09:33] <p6eval> niecza v9-53-g952a401: OUTPUT«7.11423030191258␤»

[09:34] <moritz> niecza: say sqrt(40)

[09:34] <p6eval> niecza v9-53-g952a401: OUTPUT«6.32455532033676␤»

[09:34] <moritz> seems sensible

[09:35] <moritz> (in general, the deviation from the exepectation value grows with the square root, so it seems sensible that the expected variation of one of the stacks is around sqrt(40) when the second is empty)

[09:36] *** arnsholt left
[09:36] <moritz> that's why I was all "wtf?" when I thought that masak++ had said it approached 1 (we just had a misunderstanding of what "it" was)

[09:36] <masak> "it" is what I choose it to be :P

[09:37] <masak> but it does make sense that it approaches 1 for increasing number of simulations, no?

[09:37] <masak> it feels odd that it should approach any other number.

[09:38] <moritz> what "it"?

[09:38] <masak> approaching 1 corresponds to binary strings of length 79 having 40 bits of one kind and 39 bits of the other.

[09:38] <moritz> well, it's clear that the number with the highest probability should be 1

[09:39] <moritz> but it should also be clear that the expected value should be > 1

[09:39] <moritz> at least to me, both are clear :-)

[09:39] <moritz> s/expected value/exectation value/ or whatever you call it

[09:40] <moritz> <N> == [+] N * P(N) for all N

[09:40] <masak> "expected value", I think.

[09:41] <moritz> or "first momentum" :-)

[09:41] <jlaire> 2 has the same probability as 1, so it's not "the highest" :P

[09:41] <moritz> niecza: sub f($n) { my @p; @p[0][$n] = @p[$n][0] = 1; for 0..40 -> $x { for 0..40 -> $y { @p[$x][$y] //= 0; @p[$x+1][$y] += @p[$x][$y]/2 if $y > 0; @p[$x][$y+1] += @p[$x][$y]/2 if $x > 0; } }; @p[40][40] }; say [+] (0..40).map: { $_**2 * f($_) } # second momentum

[09:41] <p6eval> niecza v9-53-g952a401: OUTPUT«72.8857696980874␤»

[09:41] <jlaire> "expected value" == "expectation", in my mind

[09:42] <moritz> rakudo: say 72.8857696980874 - 7.11423030191258 ** 2 

[09:42] <p6eval> rakudo ca5f34: OUTPUT«71.8857696980874␤»

[09:42] <moritz> this... doesn't seem right

[09:42] <moritz> niecza: say 72.8857696980874 - 7.11423030191258 ** 2 

[09:42] <p6eval> niecza v9-53-g952a401: OUTPUT«22.2734969094362␤»

[09:43] *** domidumont joined
[09:43] <moritz> so that's the variance

[09:44] <masak> jlaire: why would 2 have the same probability as 1?

[09:44] <moritz> niecza: say 22.2734969094362.sqrt # standard deviation

[09:44] <p6eval> niecza v9-53-g952a401: OUTPUT«4.71948057623254␤»

[09:44] <masak> I fail to get an intuition for that.

[09:44] <moritz> masak: consider two buckets with 38 things in each

[09:45] <moritz> masak: the probability that the next two coin flips select the same bucket is the same as the next two coin flips selecting different buckets

[09:45] <moritz> in the first case you get a difference of 2, in the second you get a difference of 1

[09:47] <moritz> hm, that doesn't tell us anything about the (37, 39) case though

[09:47] <moritz> if you don't just let the math loose on that problem, but actually stop to think about it, it's quite interesting :-)

[09:48] <masak> :)

[09:49] *** daxim joined
[09:51] *** Chat3522 joined
[09:51] *** Chat3522 left
[09:52] <moritz> to come back to the Buf discussion...

[09:52] <moritz> somehow I'm not at all happy with the notion that Bufs can act as Str as long as they are ASCII only

[09:53] <moritz> since we already have a default encoding, why not default the Str view of Buf to .decode?

[09:53] <moritz> so I'd have Buf ~ Str redispatch to Buf.decode ~ Str

[09:53] <flussence> sounds sane to me...

[09:54] <moritz> which fails if the contents of the Buf can't be decoded with $?ENCODING

[09:54] <flussence> and it'd work both ways

[09:54] <masak> jlaire, moritz: I drew it out, and I now agree that the probabilities are the same for 1 and 2, at least when the two boxes start at 2 matches each.

[09:55] <moritz> flussence: both ways?

[09:55] <moritz> the alternative is to die on Buf.{Str,Stringy}, and require explicit .decode

[09:55] <moritz> having *another* default (ASCII) for implicit conversions looks just wrong to me

[09:55] <moritz> (and very ASCII-centric :-)

[09:56] <moritz> nom: say Buf.new(0).decode('ascii')

[09:56] <p6eval> nom ca5f34: OUTPUT«␀␤»

[09:56] <flussence> moritz: i.e. Str.Buf doing .encode($?ENCODING), not necessarily round-trip safe

[09:57] <moritz> flussence: wfm

[09:57] <moritz> flussence: I just hope that there aren't any operations that require that coercion implicitly

[09:57] <moritz> well, IO does...

[09:58] <masak> moritz: +1 on disallowing implicit ASCII conversions.

[09:58] *** woosley left
[09:59] <moritz> nom is now in a state where it can do non-crawling-slow binary IO

[10:00] <moritz> so we can experiment with making .print and .say etc. go through .write(Buf)

[10:00] *** MayDaniel joined
[10:01] <snarkyboojum> what extension do people generally use for the perl6 scripts .pl?

[10:01] *** araujo left
[10:03] *** envi_laptop joined
[10:04] * moritz uses .pl

[10:04] <moritz> I've also seen .pl6 in use

[10:05] <cognominal> moritz, is it possible to use buf8 and pack/unpack so as to implement SPDY?

[10:06] <masak> snarkyboojum: when I use an extension, I use .pl

[10:06] <snarkyboojum> thanks guys

[10:06] <masak> snarkyboojum: but usually I don't. scripts are executable files, and those don't generally need an extension.

[10:07] <moritz> I guess my early exposre with Microsoft Windows has left its traces on me

[10:08] <snarkyboojum> masak: true, though extensions might make finding perl scripts more amenable to *nix find etc

[10:08] <moritz> ss/exposre with/exposure to/

[10:08] *** [particle] left
[10:08] *** [particle] joined
[10:08] * jnthn often uses .p6 fwiw

[10:09] <masak> snarkyboojum: that has never been an issue for me in practice.

[10:10] *** dakkar joined
[10:10] <snarkyboojum> masak: how else would you easily identify perl scripts across a large filesystem - other than find grepping or ack'ing or something

[10:10] *** alim joined
[10:11] *** arnsholt joined
[10:12] *** araujo joined
[10:24] *** wamba joined
[10:27] *** arnsholt left
[10:30] <snarkyboojum> how do you define a token or rule which uses the negation of another token/rule?

[10:30] <snarkyboojum> i.e. not <ws>

[10:30] <moritz> <!ws>

[10:31] <moritz> or <!before <ws>>

[10:31] <moritz> iirc the two things mean the same

[10:31] <moritz> (note that it's zero-width)

[10:31] <snarkyboojum> doh.. I tried ! on the outside ;) cheers

[10:31] <snarkyboojum> silly me

[10:32] <snarkyboojum> Mmm.. zero-width, so not possible for such a token def to capture?

[10:33] <moritz> what should it capture?

[10:33] <moritz> do you want \S+ instead?

[10:33] <moritz> in general, if you say "what comes after is not a <foo>", how do you know where that token stops?

[10:34] <snarkyboojum> when it starts matching <foo> ?

[10:34] <moritz> that would be [<!foo> .]*

[10:35] <snarkyboojum> [] is a non capturing group?

[10:35] <moritz> right

[10:36] <snarkyboojum> or (<!foo> .)* if I want to get my hands on it?

[10:37] <snarkyboojum> oops.. capturing by default right :)

[10:37] <snarkyboojum> I think I need to read S05 :)

[10:37] <moritz> ([<!foo> .]*) is better

[10:37] <moritz> unless you want to have a separate capture for each character

[10:37] <snarkyboojum> moritz: ok - thanks for your help

[10:45] <snarkyboojum> is parsing/grammars expected to be substantially faster in nom?

[10:48] <snarkyboojum> with the imminent regex rewrite/improvement?

[10:50] <jnthn> Haven't seen any benchmark results from the new engine, but in theory it should be a big improvement. For one because it can do the declarative bits with an NFA.

[10:50] <snarkyboojum> I'm parsing big chunks of text, so perhaps it's string handling etc again.. ?

[10:51] <jnthn> What encoding is the text in?

[10:52] <jnthn> The new engine will do everything with a fixed-width encoding, iiuc. Which should help.

[10:53] <snarkyboojum> jnthn: charset=us-ascii

[10:53] <snarkyboojum> whatever that means :)

[10:54] <snarkyboojum> I'm basically slurping a 2.5MB file and parsing that :)

[10:56] <masak> snarkyboojum: I simply never conduct system-wide searches for perl script files in my daily life. and if I did, that would probably indicate that I was looking for somebody *else's* perl script files -- in which case I couldn't make any assumptions about file endings anyway.

[10:56] <masak> &

[10:56] <snarkyboojum> masak: fair enough :)

[10:57] <snarkyboojum> masak: I tend do do find . -type f -name '*.someextension' quite often in my work.. perhaps there is a better way

[11:06] <snarkyboojum> anything obviously wrong with https://github.com/snarkyboojum/exploratory-parsing/blob/master/exp-parsing.pl ?

[11:06] *** jrockway left
[11:07] *** jrockway joined
[11:09] *** woosley joined
[11:13] *** arnsholt joined
[11:14] *** [particle] left
[11:15] *** [particle] joined
[11:16] <snarkyboojum> do all grammars inherit from STD by default?

[11:21] <snarkyboojum> oh geebuz - I was referencing a subrule which I'd mispelled, i.e. didn't exist, and wasn't getting any errors :(

[11:23] <snarkyboojum> rakudo: say "test"

[11:24] <snarkyboojum> is p6eval deaded?

[11:24] *** mj41_nb joined
[11:25] *** Gothmog__ joined
[11:25] *** Gothmog_ left
[11:25] *** mj41 left
[11:25] *** jesk left
[11:25] *** Gothmog__ is now known as Gothmog_

[11:25] <p6eval> rakudo c5fc39: OUTPUT«test␤»

[11:25] <snarkyboojum> just sleepy praps

[11:27] *** jesk joined
[11:31] *** jferrero joined
[11:32] *** mishin joined
[11:34] * [Coke] commutes.

[11:34] *** s1n left
[11:34] *** cognominal_ joined
[11:35] *** plobsing joined
[11:36] *** Psyche^ joined
[11:37] *** satyavvd left
[11:37] *** cognominal left
[11:38] <cognominal_> master: my $nm ='a' ;  say qq|$nm\(...|

[11:38] *** plobsing_ left
[11:38] *** cognominal_ is now known as cognominal

[11:38] <cognominal> nom: my $nm ='a' ;  say qq|$nm\(...|

[11:38] <p6eval> nom c5fc39: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[11:39] <moritz> b:  my $nm ='a' ;  say qq|$nm\(...|

[11:39] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[11:40] <moritz> nom: (1/2) but role { }

[11:40] <p6eval> nom c5fc39: OUTPUT«Not enough positional parameters passed; got 1 but expected 3␤  in method BUILD at src/gen/CORE.setting:5325␤  in method BUILD_LEAST_DERIVED at src/gen/CORE.setting:573␤  in sub infix:<but> at src/gen/CORE.setting:7176␤  in <anon> at /tmp/di90YTDhSl:1␤  in <anon> at /…

[11:40] <cognominal> what is b?

[11:40] <moritz> the old rakudo/master

[11:40] *** Patterner left
[11:40] *** Psyche^ is now known as Patterner

[11:41] <jnthn> moritz: hm, interesting.

[11:41] <jnthn> moritz: oh, it's correct

[11:41] <jnthn> moritz: Bug is that Rat declares method BUILD

[11:41] <jnthn> Not submethod.

[11:42] * moritz changes and spectests

[11:42] <moritz> jnthn: that's from the times before submethod where implemented in nom

[11:43] <cognominal> nom: my $nm ='a' ;  say qq|$nm (...|

[11:43] <p6eval> nom c5fc39: OUTPUT«a (...␤»

[11:44] <jnthn> moritz: fairy nuff

[11:52] *** arnsholt left
[11:54] *** colomon joined
[12:00] *** bluescreen10 joined
[12:00] <snarkyboojum> perl6: grammar A { token a { <typo> }; token typ0 { . } }

[12:00] <p6eval> pugs, rakudo c5fc39, niecza v9-53-g952a401:  ( no output )

[12:00] <snarkyboojum> shouldn't that complain about an undefined typo token?

[12:01] <jnthn> They're methods, not subs.

[12:01] <snarkyboojum> so it's ok to reference an undefined method?

[12:01] <moritz> snarkyboojum: <foo> type calls are more like methods, so detected at runtime

[12:01] <jnthn> snarkyboojum: Yes

[12:01] <moritz> snarkyboojum: as long as it's never called... :-)

[12:02] <jnthn> Thing is, a subclass could declare it.

[12:02] <moritz> or a role mixed into it

[12:02] <jnthn> Of course, we may be able to do something smartish

[12:02] <jnthn> But it's non-trivial.

[12:02] <jnthn> This is why any method inlining the optimizer does has to be undoable.

[12:03] <snarkyboojum> ok - must be another error with my grammar that's causing it to never finish parsing then ;)

[12:03] <moritz> snarkyboojum: have you seen jnthn++'s awesome grammar debugger?

[12:04] <snarkyboojum> moritz: nope

[12:04] <moritz> (there's a tracer too)

[12:04] <snarkyboojum> sounds good - link?

[12:04] <moritz> snarkyboojum: https://github.com/jnthn/grammar-debugger

[12:04] <snarkyboojum> moritz: ta

[12:06] <mls_> success! when blocks work again.

[12:06] *** hazhir joined
[12:06] <hazhir> hello?!

[12:08] <snarkyboojum> hazhir: hi - you sound concerned

[12:12] *** espadrine joined
[12:16] <masak> hazhir: hi.

[12:16] <masak> hazhir: welcome.

[12:19] *** hazhir left
[12:20] *** replore joined
[12:21] *** benabik left
[12:23] <dalek> rakudo/nom: bfc3a42 | moritz++ | src/core/Rat.pm:

[12:23] <dalek> rakudo/nom: BUILD should be a submethod

[12:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bfc3a42f5b

[12:23] <dalek> rakudo/nom: 00c8180 | moritz++ | src/core/Buf.pm:

[12:23] <dalek> rakudo/nom: fix Buf thinko; fixes .[] indexing into Buf

[12:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/00c8180c58

[12:27] <masak> oh -- it used to be .{} indexing?

[12:28] <moritz> nom: say Buf.new(1, 2, 3).<1>

[12:28] <p6eval> nom c5fc39: OUTPUT«Nominal type check failed for parameter '$idx'; expected Int but got Str instead␤  in method at_key at src/gen/CORE.setting:4777␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1014␤  in <anon> at /tmp/31rOK8ol8W:1␤  in <anon> at /tmp/31rOK8ol8W:1␤␤»…

[12:28] <moritz> well, if it had worked :-)

[12:29] <masak> don't use .<> which coerces to Str, duh :P

[12:29] <masak> nom: say Buf.new(1, 2, 3){1}

[12:29] <p6eval> nom c5fc39: OUTPUT«2␤»

[12:30] <moritz> schtupid me

[12:31] *** Trashlord left
[12:33] * masak ponders a blog post "We're all schtupid sometimes"

[12:33] <masak> git and tests and a general plan of action -- all of them are wonderful safety nets in face of sudden stupidity.

[12:34] <pmichaud> my tuit suppply continues to get hit badly :(

[12:34] <pmichaud> I'm only here for a few moments, should be back later today

[12:35] <masak> pmichaud: :/

[12:35] <moritz> pmichaud: if I should do a release without prior regex fixes, please tell me

[12:35] <pmichaud> I think I'll need to let you all collectively decide what's best to do here.

[12:35] <pmichaud> (more)

[12:37] <pmichaud> I may have to do some emergency travel today/tomorrow; yesterday evening my mother went into the hospital (we don't know what's wrong yet) and I may need to travel to help out

[12:37] <pmichaud> preliminary it looks like it may be nothing major, in which case I have time set aside tonight and tomorrow to definitively work on regexes

[12:38] <pmichaud> but if I have to travel (I should know in a couple of hours), then all bets are off for me for a few days

[12:38] * moritz would be +1 to waiting for a couple of hours then

[12:38] <jnthn> What moritz said.

[12:38] *** plobsing left
[12:39] <pmichaud> I know I've been horribly unreliable of late on this, and haven't been able to focus on rakudo stuff, so I'm pretty deferential to anything you all decide to do.  I'm hoping things clear up soon.

[12:39] <dalek> roast: 50cfa3b | moritz++ | S0 (3 files):

[12:39] <dalek> roast: test for RT #69518; also fix a test that relied on wrong outer scope for eval_dies_ok

[12:39] <dalek> roast: review: https://github.com/perl6/roast/commit/50cfa3b3b3

[12:40] <masak> +1 to waiting a couple hours.

[12:40] * masak hugs pmichaud 

[12:41] <masak> hope everything turns out alright.

[12:41] <pmichaud> anyway, I have to arrange a few more things -- bbiaw

[12:41] <moritz> rakudo: rakudo: my @a = a => 1, b => 2; for @a -> Pair $p ( $key, $value) { say $kez }

[12:41] <p6eval> rakudo c5fc39: OUTPUT«===SORRY!===␤Confused at line 1, near "rakudo: my"␤»

[12:42] <moritz> rakudo: my @a = a => 1, b => 2; for @a -> Pair $p ( $key, $value ) { say $key }

[12:42] <p6eval> rakudo c5fc39: OUTPUT«Not enough positional parameters passed; got 0 but expected 2 in sub-signature of parameter $p␤  in block <anon> at /tmp/R2XNEmV5GF:1␤  in method reify at src/gen/CORE.setting:3724␤  in method reify at src/gen/CORE.setting:3629␤  in method reify at src/gen/CORE.set…

[12:42] <dalek> roast: bcb1a97 | Coke++ | S02-types/ (2 files):

[12:42] <dalek> roast: niecza fudge

[12:42] <dalek> roast: review: https://github.com/perl6/roast/commit/bcb1a9786b

[12:42] <moritz> rakudo: my @a = a => 1, b => 2; for @a -> Pair $p ( :$key, :$value ) { say $key }

[12:42] <p6eval> rakudo c5fc39: OUTPUT«a␤b␤»

[12:43] *** cognominal left
[12:43] *** cognominal joined
[12:43] <[Coke]> pmichaud: best wishes.

[12:44] *** woosley left
[12:44] <[Coke]> sorear: ping me if you want a patch for t/spectest.data

[12:47] *** abercrombie joined
[12:51] *** plobsing joined
[12:53] *** cotto left
[12:55] *** alvis left
[12:57] <dalek> rakudo/nom: 530c04f | moritz++ | t/spectest.data:

[12:57] <dalek> rakudo/nom: run new S06-signature/unpack-object.t

[12:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/530c04fec3

[12:59] <[Coke]> unpack-object?

[12:59] <moritz> one can "unpack" objects in signatures

[13:00] <moritz> -> Pair $p ( :$key ) { ... } # unpacks the $.key attribute of $pair into the $key variable

[13:00] <felher> Is there an implementation (or a branch) that supports user-defined array indexing at the moment?

[13:00] <jnthn> Not afaik.

[13:00] <moritz> doesn't have anything to do with the unpack() function

[13:00] <moritz> felher: no

[13:00] <[Coke]> I just don't see the file, is all.

[13:00] <felher> moritz: k, thnx :)

[13:01] <[Coke]> only unpack-array

[13:01] <moritz> [Coke]: forgot to push, my bad

[13:01] <dalek> roast: fcfe955 | moritz++ | S06-signature/unpack-object.t:

[13:01] <dalek> roast: test for unpacking objects in signatures

[13:01] <dalek> roast: review: https://github.com/perl6/roast/commit/fcfe955562

[13:02] *** tomaw left
[13:02] <felher> jnthn: oh, thnx to you, too, of course. :)

[13:03] <[Coke]> moritz: ah, thank you. ;)

[13:03] <moritz> [Coke]: thanks for catching my errors :-)

[13:04] <dalek> roast: 37d1b61 | moritz++ | S03-metaops/zip.t:

[13:04] <dalek> roast: test [Z+] (RT #92652)

[13:04] <dalek> roast: review: https://github.com/perl6/roast/commit/37d1b61bd8

[13:05] <moritz> rakudo: .say for 1, 2, 6 ... 33.4

[13:05] <p6eval> rakudo 00c818: OUTPUT«1␤2␤6␤unable to deduce sequence␤  in sub <anon> at src/gen/CORE.setting:7259␤  in sub coro at src/gen/CORE.setting:3855␤  in method reify at src/gen/CORE.setting:3824␤  in method reify at src/gen/CORE.setting:3628␤  in method reify at src/gen/CORE.setting:3628␤  in…

[13:10] <moritz> jnthn: did your optimizer work only consider dispatches to multis?

[13:10] <moritz> jnthn: because at the end of S06-signature/arity.t there's a failing dispatch due to arity in a dies_ok

[13:10] *** alvis joined
[13:10] <moritz> which doesn't seem to be caught

[13:10] <moritz> and it's an only sub there

[13:13] <dalek> roast: afae36a | moritz++ | S06-signature/arity.t:

[13:13] <dalek> roast: .count and .arity on multis (RT #76646

[13:13] <dalek> roast: review: https://github.com/perl6/roast/commit/afae36a52e

[13:13] <dalek> roast: c2545cc | moritz++ | S06-signature/arity.t:

[13:13] <dalek> roast: move a possible compile time failure into an eval

[13:13] <dalek> roast: review: https://github.com/perl6/roast/commit/c2545ccc2e

[13:15] <jnthn> moritz: Only to multis for now.

[13:16] <jnthn> moritz: It'd make sense to do a similar analysis for onlies, because if we can prove that the types being passed will match the signature, then we can have the binder skip the type checks.

[13:16] <jnthn> moritz: I just didn't get there yet.

[13:16] *** kaleem left
[13:16] <moritz> jnthn: ok, just wondering why it didn't catch that case

[13:17] <dalek> roast: e8cf51c | moritz++ | S32-io/chdir.t:

[13:17] <dalek> roast: fix misuse of file test operator

[13:17] <dalek> roast: review: https://github.com/perl6/roast/commit/e8cf51cead

[13:17] <jnthn> moritz: For various reasons, multis are currently more interesting.

[13:18] <jnthn> Goes without saying there's an awful lot of work to do in the area of optimization.

[13:19] <moritz> could it be that we have no test file where we test type objects?

[13:20] <moritz> nom: say Any.name

[13:20] <p6eval> nom 00c818: OUTPUT«Method 'name' not found for invocant of class 'Any'␤  in <anon> at /tmp/ysMn34r6f0:1␤  in <anon> at /tmp/ysMn34r6f0:1␤␤»

[13:20] <moritz> nom: say Any.^name

[13:20] <p6eval> nom 00c818: OUTPUT«Any␤»

[13:22] <dalek> roast: dbe034b | moritz++ | S12-class/type-object.t:

[13:22] <dalek> roast: new test file for type objects

[13:22] <dalek> roast: review: https://github.com/perl6/roast/commit/dbe034b300

[13:23] <jnthn> moritz: I'm not sure we have any test file for native types either...

[13:23] <moritz> jnthn: we have some pseudo tests

[13:23] <jnthn> The work so far in nom on those is at a pretty early stage, but there's likely something testable.

[13:23] <moritz> t/spec/S02-types/int-uint.t

[13:23] <dalek> rakudo/nom: 1108715 | moritz++ | t/spectest.data:

[13:23] <dalek> rakudo/nom: run new test type-object.t

[13:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1108715d8d

[13:23] <jnthn> OK, will look over them.

[13:23] <moritz> t/spec/S02-types/compact.t mentions uint8 (and is likely wrong)

[13:25] <moritz> nom: [[]].''().perl.say

[13:25] <p6eval> nom 00c818: OUTPUT«Method '' not found for invocant of class 'Array'␤  in <anon> at /tmp/XmBb4d_lab:1␤  in <anon> at /tmp/XmBb4d_lab:1␤␤»

[13:26] *** arnsholt joined
[13:27] <moritz> down to 32 tickets that are marked as 'testneeded'

[13:27] <[Coke]> moritz++

[13:28] <[Coke]> I'll try to fill your queue later. ;)

[13:29] <moritz> mom: say Any.^roles.WHAT

[13:29] <moritz> nom: say Any.^roles.WHAT

[13:30] <p6eval> nom 00c818: OUTPUT«Parcel()␤»

[13:30] <moritz> nom: say Parcel ~~ Positional

[13:30] <p6eval> nom 00c818: OUTPUT«Bool::True␤»

[13:31] <dalek> roast: 54c3e07 | moritz++ | S12-introspection/roles.t:

[13:31] <dalek> roast: test that introspection returns Perl 6 types (RT #73134)

[13:31] <dalek> roast: review: https://github.com/perl6/roast/commit/54c3e07d42

[13:33] <jlaire> < masak> jlaire: why would 2 have the same probability as 1?

[13:33] <jlaire> late reply, but there's a very simple reason

[13:34] <dalek> roast: 7336806 | moritz++ | S12-class/type-object.t:

[13:34] <dalek> roast: test the return value of a named class declaration (RT #72690)

[13:34] <dalek> roast: review: https://github.com/perl6/roast/commit/7336806527

[13:34] <jlaire> 0/1 must go through the states 1/1 and 1/2

[13:34] <jlaire> and 0/2 must come from 1/2

[13:34] <jlaire> and when we are at 1/2, it's 50-50 chance whether we get to 0/1 or 0/2

[13:34] <moritz> jlaire++

[13:35] <moritz> I had a similar but faulty explanation

[13:35] *** mishin left
[13:36] <jlaire> I see

[13:36] <jlaire> my intuition works much better with small numbers :)

[13:37] <masak> jlaire++

[13:38] <snarkyboojum> I gave up trying to parse my 2.5MB file when rakudo hit 3.2GB of RAM usage :|

[13:38] <jnthn> snarkyboojum: nom or b?

[13:38] <snarkyboojum> nom

[13:39] <snarkyboojum> works for smaller input

[13:39] <dalek> roast: ec38923 | moritz++ | S12-methods/calling_sets.t:

[13:39] <dalek> roast: test for 1.*WHAT (which is forbidden), RT #72818

[13:39] <dalek> roast: review: https://github.com/perl6/roast/commit/ec38923abd

[13:39] *** plobsing left
[13:40] <jnthn> snarkyboojum: OK, I'd be interested to look into that at some point.

[13:40] <snarkyboojum> jnthn: great - will gist some details then

[13:41] *** espadrine left
[13:41] *** plobsing joined
[13:42] *** uasi left
[13:45] <jnthn> snarkyboojum: thanks

[13:46] <moritz> nom: 1.*sqrt

[13:46] <p6eval> nom 00c818: OUTPUT«Parameter '(null)' requires an instance, but a type object was passed␤  in method sqrt at src/gen/CORE.setting:2200␤  in method dispatch:<.*> at src/gen/CORE.setting:728␤  in <anon> at /tmp/Ur7DzA3cg4:1␤  in <anon> at /tmp/Ur7DzA3cg4:1␤␤»

[13:46] <moritz> I think I found the problem

[13:48] <jnthn> Worst compile error of the day: CS1012: Too many characters in character literal

[13:48] <jnthn> ...what?!

[13:49] <masak> jnthn: what emitted that, Pascal? :P

[13:49] <jnthn> moritz: oh...

[13:49] <jnthn> masak: C#!

[13:49] <moritz> perfectly fine and comprehensible error message

[13:49] <moritz> it's just the underlying limitation that sucks

[13:49] <jnthn> oh...I see what ti's done

[13:50] <jnthn> ...grr, it parsed JavaScript as C#.

[13:50] <jnthn> :/

[13:50] <moritz> is "character literal" a string?

[13:50] <jlaire> no, it's a single character

[13:50] <moritz> ah

[13:50] <moritz> then even the limitations makes sense :-)

[13:50] <jnthn> yeah, makes sense now

[13:50] <jlaire> "More than one character" would be more explicit than "Too many"

[13:50] <jnthn> jlaire: Yeah

[13:51] <jnthn> "Character literal should contain *a* character" woulda been better :)

[13:51] *** PacoLinux_ joined
[13:51] <jlaire> 'xx' contains a character :)

[13:52] <jlaire> so something like "must contain exactly one character"

[13:53] <dalek> rakudo/nom: 6551282 | moritz++ | src/core/Mu.pm:

[13:53] <dalek> rakudo/nom: in .* dispatch, do not turn all method calls into calls on the type object

[13:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6551282fa5

[13:55] <moritz> nom: class A { method x($) { say 'in A.x' } }; A.?x()

[13:55] <p6eval> nom 00c818: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method x at /tmp/JSaq4KnVpS:1␤  in method dispatch:<.?> at src/gen/CORE.setting:711␤  in <anon> at /tmp/JSaq4KnVpS:1␤  in <anon> at /tmp/JSaq4KnVpS:1␤␤»

[13:55] <jnthn> moritz: oh, good catch

[13:55] <moritz> I'm quite sure this one is wrong too

[13:55] <masak> having drawn a few more diagrams on the whiteboard, I now see what TimToady++ meant by "the bottom two angles trimmed off".

[13:57] <jnthn> moritz: I think it's correct.

[13:57] <jnthn> moritz: The method dispatch was successful.

[13:57] <jnthn> That's what .?/.+/.* are about.

[13:57] <moritz> does .+ really mean "dispatch to all methods, at least one" and not "dispatch to all matching candidates, at least on"?

[13:58] <jnthn> Now, yes

[13:58] <jnthn> Not in b, under the previous dispatch model.

[13:58] <moritz> then my mental model needs updating

[13:59] <jnthn> *nod*

[13:59] <jnthn> Yes, this is fallout from the new proto/multi semantics.

[14:01] <moritz> the spec is silent on that matter

[14:01] <moritz> ie reading it doesn't give me any indication which interpretation it favors

[14:02] <[Coke]> Promise me that no matter what, we won't switch to ant. ;)

[14:02] <moritz> ant? the java build system?

[14:02] <[Coke]> Aye.

[14:03] <moritz> [Coke]: promise given.

[14:03] * [Coke] breathes easy.

[14:04] <jnthn> moritz: The stuff in S06 and/or S12 on nested dispatchers is probably the closest we have, but yeah, it hints at this rather than really calls it out, it seems.

[14:07] <moritz> nom: class A { method foo { say 'in A.foo' } }; my $name = 'foo'; A."$name"

[14:07] <p6eval> nom 110871: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments at line 1, near ""␤»

[14:07] <moritz> nom: class A { method foo { say 'in A.foo' } }; my $name = 'foo'; A.?"$name"()

[14:07] <p6eval> nom 110871:  ( no output )

[14:07] <moritz> nom: class A { method foo { say 'in A.foo' } }; my $name = 'foo'; A."$name"()

[14:07] <p6eval> nom 110871: OUTPUT«in A.foo␤»

[14:07] <moritz> that's b0rked

[14:08] <moritz> nom: class A { method foo { say 'in A.foo' } }; my $name = 'foo'; A.?"foo"()

[14:08] <p6eval> nom 110871:  ( no output )

[14:09] <jnthn> hm

[14:09] <jnthn> Oddness

[14:09] <moritz> nom: class A { method foo { say 'in A.foo' } }; my $name = 'foo'; A.+"foo"()

[14:09] <p6eval> nom 110871: OUTPUT«Method 'Capture[0x40928f0]' not found for invocant of type 'A'␤  in method dispatch:<.+> at src/gen/CORE.setting:717␤  in <anon> at /tmp/juhdKSv_m7:1␤  in <anon> at /tmp/juhdKSv_m7:1␤␤»

[14:09] <jnthn> oh.

[14:09] <jnthn> ...well, there's our problem. ;)

[14:10] <moritz> the name gets messed up?

[14:10] <jnthn> Yeah

[14:10] <jnthn> name is a PAST tree but something assumes it's just a string.

[14:11] <moritz> the .* dispatcher probably

[14:12] *** wolfman2000 left
[14:13] <dalek> roast: 9d68b77 | moritz++ | S12-methods/calling_sets.t:

[14:13] <dalek> roast: fudge calling_sets.t for rakudo, and use dies_ok instead of a custom construct

[14:13] <dalek> roast: review: https://github.com/perl6/roast/commit/9d68b77abe

[14:14] *** kaleem joined
[14:14] <jnthn> moritz: It'll be one of the transforms in Actions.

[14:14] <dalek> rakudo/nom: fce1d9b | moritz++ | t/spectest.data:

[14:14] <dalek> rakudo/nom: run calling_sets.t

[14:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fce1d9bfb6

[14:17] <moritz> rakudo: class A { method foo {} }; say A.can("foo").WHAT

[14:17] <p6eval> rakudo 110871: OUTPUT«Parcel()␤»

[14:18] <jnthn> .can is one of those things where people expect it to do/be everything. So I picked one of them. :)

[14:18] <moritz> jnthn: would you be fine with a spectest that tests that it returns something Positional?

[14:19] <jnthn> moritz: The spec certainly says it should be something iterable.

[14:19] <jnthn> There's some confusion over whether you should be able to invoke it and have it invoke the first thing in the list.

[14:19] <dalek> roast: 179a3cb | moritz++ | S12-introspection/can.t:

[14:19] <dalek> roast: test that .can returns a proper Perl 6 object (RT #74386)

[14:19] <dalek> roast: review: https://github.com/perl6/roast/commit/179a3cbea6

[14:19] <jnthn> If that's the case, then it is Parcel + a role, or some other type?

[14:20] <moritz> just have Any.invoke delegate to Any.[0].invoke # SCNR

[14:20] <jnthn> I'm open to doing various things here, just don't have a strong feeling for what's best.

[14:20] <jnthn> :P

[14:20] <moritz> actually I don't have no idea, I just want to close RT #74286

[14:21] * moritz does so

[14:21] <jnthn> :)

[14:21] <moritz> down to 28 tickets that are tacked as testneeded

[14:21] <moritz> *tagged

[14:22] *** lestrrat left
[14:23] <gfldex> nom: grammar F { token TOP { { say $_ } \w } }; F.parse('a');

[14:23] <p6eval> nom 110871: OUTPUT«Null PMC access in find_method('gist')␤  in sub say at src/gen/CORE.setting:4882␤  in block <anon> at /tmp/QCHtCYyIPW:1␤  in regex TOP at /tmp/QCHtCYyIPW:1␤  in method parse at src/gen/CORE.setting:6119␤  in <anon> at /tmp/QCHtCYyIPW:1␤  in <anon> at /tmp/QCHtCYyIPW:1…

[14:23] <moritz> nom: ('a' R~ 'b') = 1

[14:23] <p6eval> nom 110871: OUTPUT«Cannot assign to a non-container␤  in <anon> at /tmp/gus0Pc72O4:1␤  in <anon> at /tmp/gus0Pc72O4:1␤␤»

[14:24] *** wtw left
[14:26] <dalek> roast: e461a48 | moritz++ | S03-metaops/reverse.t:

[14:26] <dalek> roast: return value of infix R~ is not assignable (RT #93350)

[14:26] <dalek> roast: review: https://github.com/perl6/roast/commit/e461a4850a

[14:27] *** nwc10 joined
[14:28] <masak> moritz++

[14:30] *** uasi joined
[14:30] <masak> rakudo: class Worms {}; role Can[::T] { method open { say "OH NOES you let out the {T.WHAT.perl}!" } }; Can[Worms].new.open

[14:30] <p6eval> rakudo 110871: OUTPUT«OH NOES you let out the Worms!␤»

[14:32] <moritz> jnthn: the old ruling was that a proto sub foo would make all susequent 'sub foo's in that scope a multi automatically -- is that still current spec?

[14:32] <moritz> masak: btw. I like .^name better than .perl on type objects

[14:32] <moritz> nom: say 1.^name

[14:32] <p6eval> nom 110871: OUTPUT«Int␤»

[14:32] <masak> gotcha.

[14:33] <masak> I agree.

[14:33] <moritz> .perl is always implementation dependent

[14:34] <masak> in many cases in both Rakudo and Niecza, .perl doesn't generate Perl code :(

[14:35] <dalek> roast: 85b1a79 | moritz++ | S06-multi/proto.t:

[14:35] <dalek> roast: refudge proto.t for rakudo and remove outdated semantics

[14:35] <dalek> roast: review: https://github.com/perl6/roast/commit/85b1a7932b

[14:35] <moritz> yep, but you can submit that as a bug :-)

[14:35] <masak> niecza: "foo" ~~ /foo/; say $/.perl

[14:35] *** Holy_Cow joined
[14:35] <p6eval> niecza v9-53-g952a401: OUTPUT«#<match from(0) to(3) text(foo) pos([].list) named({}.hash)>␤»

[14:35] <moritz> you can't if Any.perl turns out to be ::('Any')  or so

[14:36] <masak> std: #<match from(0) to(3) text(foo) pos([].list) named({}.hash)>

[14:36] <p6eval> std 9fe2e1b: OUTPUT«ok 00:01 117m␤»

[14:36] <masak> ok, that actually seems to be valid Perl 6 code.

[14:36] <jlaire> #<hah, nice>

[14:36] <masak> but I'm still less than impressed.

[14:37] <moritz> it's perfectly fine .gist output

[14:37] <masak> I thought it was #`<hah, nice> these days.

[14:37] <jnthn> moritz: yes, currently still spec; there's even a todo comment in Actions.pm about it :)

[14:37] <moritz> jnthn: ok, thanks

[14:38] <dalek> rakudo/nom: ef6536f | moritz++ | t/spectest.data:

[14:38] <dalek> rakudo/nom: run S06-multi/proto.t

[14:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef6536f7d8

[14:38] <moritz> down to 26

[14:38] *** mishin_ joined
[14:38] <masak> \o/

[14:38] *** lestrrat joined
[14:40] <jnthn> moritz++

[14:40] *** bazqux left
[14:40] <cognominal> where is the doc for the "type characters" for the pir:: routines like the Q in  pir::set__1Qii(..) ?

[14:41] <moritz> cognominal: parrot/compilers/pct/src/PAST/Compiler.pir

[14:41] <cognominal> thx moritz++

[14:45] <masak> Ӝ

[14:45] <masak> Cyrillic had Camelia long before UTF-8 did ;)

[14:45] <moritz> .u camelia

[14:45] <phenny> moritz: Sorry, no results for 'camelia'.

[14:45] *** cognominal_ joined
[14:45] <masak> er, Unicode. mixing up of levels.

[14:45] *** packetkn_ joined
[14:46] <moritz> .u Ӝ

[14:46] <phenny> U+04DC CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS (Ӝ)

[14:46] <TimToady> looks more like the Space Needle to me

[14:46] <phenny> TimToady: 06:07Z <sorear> tell TimToady fixed!

[14:48] *** cognominal left
[14:48] *** packetknife left
[14:48] *** japhb_ joined
[14:48] <japhb_> b: multi f("a") { "got a" }; multi f("b") { "got b" }; say f("c");

[14:49] <p6eval> b 1b7dd1: OUTPUT«No applicable candidates found to dispatch to for 'f'. Available candidates are:␤:(Str  where ("a"))␤:(Str  where ("b"))␤␤  in main program body at line 22:/tmp/m4U_aS6h8P␤»

[14:49] <japhb_> nom: multi f("a") { "got a" }; multi f("b") { "got b" }; say f("c");

[14:49] <p6eval> nom 110871: OUTPUT«No applicable candidates found to dispatch to for 'f'. Available candidates are:␤:(Str)␤:(Str)␤␤  in sub f at /tmp/Z5iAwET0CV:1␤  in <anon> at /tmp/Z5iAwET0CV:1␤  in <anon> at /tmp/Z5iAwET0CV:1␤␤»

[14:49] <moritz> Signature.perl is known to be crappy in nom

[14:49] <moritz> but it's Perl 6 code, so not hard to patch

[14:50] <moritz> indeed that'd be a very nice contribution

[14:50] <japhb_> jnthn, can nom be improved here?  My understanding of the underlying weakness is that Parameter has no .constraints method like b did.  Is that an easy fix, or did the nom changes make it hard?

[14:51] <japhb_> moritz, I would if I knew how to implement .constraints.  :-)

[14:51] <moritz> japhb_: fair point

[14:52] <jnthn> japhb_: Actually it should be easier than in b to do that stuff

[14:52] *** cognominal_ left
[14:52] <jnthn> japhb_: Oh, darn, I didn't get the thing I want meant to fix for you done at the weekend...got swallowed up playing with compile-time multi-dispatch. Sorry.

[14:52] <jnthn> s/want/was/

[14:53] *** tomaw joined
[14:53] <jnthn> Anyway, there's no "deep problem" stopping better signature introspection/.perl.

[14:53] *** cognominal joined
[14:53] <jnthn> Just not done yet

[14:55] <japhb_> jnthn, OK, cool beans

[14:57] <TimToady> std: / x+ % y /

[14:57] <p6eval> std 9fe2e1b: OUTPUT«ok 00:01 120m␤»

[14:57] <japhb_> jnthn, also, I noticed when working on the usage generator last night that Parameter.named_names is not a Perl 6 array (I'm guessing it's a view into a Parrot iterable?).  In any case, what do I need to fix to promote it to a full Perl 6 container properly?

[14:58] <TimToady> sorear++

[14:58] <moritz> nom: sub f($x) { }; say &f.signature.params

[14:58] <p6eval> nom ef6536: OUTPUT«Parameter<24687928>␤»

[14:58] <moritz> nom: sub f($x, $y) { }; say &f.signature.params

[14:58] <p6eval> nom ef6536: OUTPUT«Parameter<12983432> Parameter<12919480>␤»

[14:59] <moritz> nom: sub f($x, $y) { }; say &f.signature.params.[0].named_names

[14:59] <p6eval> nom ef6536: OUTPUT«␤»

[14:59] <moritz> nom: sub f(:$x, :$y) { }; say &f.signature.params.[0].named_names

[14:59] <p6eval> nom ef6536: OUTPUT«Method 'gist' not found for invocant of class 'String'␤  in method gist at src/gen/CORE.setting:3349␤  in sub say at src/gen/CORE.setting:4882␤  in <anon> at /tmp/INQ5vLeT8l:1␤  in <anon> at /tmp/INQ5vLeT8l:1␤␤»

[14:59] *** cotto joined
[14:59] <moritz> nom: sub f(:$x, :$y) { }; say nqp::p6box_s(&f.signature.params.[0].named_names)

[14:59] <p6eval> nom ef6536: OUTPUT«x␤»

[15:00] <japhb_> moritz, ah, looking at the array again, maybe it's just not an array of Perl 6 strings.  :-)

[15:00] <moritz> nom: sub f(:z($x), :$y) { }; say &f.signature.params.[0].named_names

[15:00] <p6eval> nom ef6536: OUTPUT«Method 'gist' not found for invocant of class 'String'␤  in method gist at src/gen/CORE.setting:3349␤  in sub say at src/gen/CORE.setting:4882␤  in <anon> at /tmp/KdSM2iroXg:1␤  in <anon> at /tmp/KdSM2iroXg:1␤␤»

[15:00] <moritz> japhb_: that should be easy-ish for me to fix

[15:00] <japhb_> moritz, ah, cool, thank you

[15:01] <moritz> nom: sub f(:z($x), :$y) { }; say nqp::p6box_s &f.signature.params.[0].named_names

[15:01] <p6eval> nom ef6536: OUTPUT«z␤»

[15:01] <jnthn> nqp::p6type can help with those things, but it only goes one level deep and this needs two.

[15:01] <moritz> nom: sub f(:z($x), :$y) { }; say nqp::p6box_s &f.signature.params.[0].named_names.[1]

[15:01] <p6eval> nom ef6536: OUTPUT«␤»

[15:01] <moritz> nom: sub f(:z($x), :$y) { }; say nqp::p6box_s &f.signature.params.[0].named_names.[0]

[15:01] <p6eval> nom ef6536: OUTPUT«z␤»

[15:02] <moritz> nom: sub f(:z($x), :$y) { }; say nqp::p6box_s &f.signature.params.[0].named_names.WHAT

[15:02] <p6eval> nom ef6536: OUTPUT«Use of uninitialized value in string context␤␤»

[15:02] <moritz> nom: sub f(:z($x), :$y) { }; say &f.signature.params.[0].named_names.WHAT

[15:02] <p6eval> nom ef6536: OUTPUT«Parcel()␤»

[15:02] *** nwc10 left
[15:03] <moritz> japhb_: btw the attributes of class Parameter are declared in src/Perl6/Metamodel/BOOTSTRAP.pm

[15:03] <moritz> japhb_: which is why src/core/Parameter.pm looks so suspiciously empty :-)

[15:04] <japhb_> moritz, ah oh.

[15:04] * moritz wonders how early in the bootstrap Parameter.named_names is called

[15:04] <jnthn> May well not be.

[15:05] <jnthn> Unless we need it to dump a signature.

[15:05] <moritz> jnthn: I'm just a bit scared that if I do fancy stuff there, I break error reporting while compiling the setting

[15:06] <jnthn> perhaps, but OTOH Str and so forth are already set up in BOOTSTRAP

[15:07] <moritz> nom: sub f(:z($x), :$y) { }; pir::say pir::typeof__SP nqp::getattr(pir::perl6_decontainerize__PP f.signature.params.[0], Parameter, '$!named_names')

[15:07] <p6eval> nom ef6536: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:The opcode 'perl6_decontainerize_p_p_p_p' (perl6_decontainerize<4>) was not found. Check the type and number of the arguments␤     in file '(file unknown)' li…

[15:07] <moritz> nom: sub f(:z($x), :$y) { }; pir::say pir::typeof__SP nqp::getattr(pir::perl6_decontainerize__PP(f.signature.params.[0]), Parameter, '$!named_names')

[15:07] <p6eval> nom ef6536: OUTPUT«Method 'signature' not found for invocant of class 'Nil'␤  in <anon> at /tmp/raOrr_crzZ:1␤  in <anon> at /tmp/raOrr_crzZ:1␤␤»

[15:07] *** jlaire left
[15:07] <moritz> nom: sub f(:z($x), :$y) { }; pir::say pir::typeof__SP nqp::getattr(pir::perl6_decontainerize__PP(&f.signature.params.[0]), Parameter, '$!named_names')

[15:08] <p6eval> nom ef6536: OUTPUT«ResizablePMCArray␤»

[15:08] *** jlaire joined
[15:09] <japhb_> ah-ha!

[15:09] *** thou joined
[15:09] <moritz> and that gets perl6ized to Parcel, but not its contents

[15:09] <moritz> which are parrot strings

[15:09] <japhb_> moritz, yep, makes sense

[15:11] <moritz> which means I can't even .map on the Parcel-ized RPA

[15:12] <moritz> but need to do a loop over the indexes and extract the items with nqp::atpos

[15:12] <jnthn> Right.

[15:13] <moritz> the setting would be cleaner in places if we had a MAP_PARROT_ARRAY(RPA, BLOCK) helper or so

[15:13] <moritz> which also deals with other parrot array types

[15:13] <moritz> hm, but the block would need strange argument handling

[15:14] <jnthn> yeah

[15:14] <jnthn> nom: nqp::for() # does it exist?

[15:14] <p6eval> nom ef6536: OUTPUT«===SORRY!===␤Unrecognized nqp:: opcode 'nqp::for' at line 1, near " # does it"␤»

[15:14] <jnthn> No. :)

[15:14] <moritz> that would be nice indeed

[15:14] <jnthn> Maybe try adding it into NQP.pir's map

[15:15] <jnthn> Same place as nqp::while

[15:15] <jnthn> (in nqp repo, src/PAST/)

[15:15] <masak> TimToady: I'd like to request a %%% operator for optional separator *before* a repetition :P

[15:15] <TimToady> gee, who would every write one of those?  <whistles>

[15:16] <moritz> jnthn: is there a PAST 'for' node already?

[15:16] <TimToady> *ever

[15:16] <jnthn> moritz: Yeah, it's a pasttype on PAST::Op, like while et al

[15:16] <jnthn> moritz: And if we're really lucky then it won't mind a Perl 6 block as its second arg...but it may...not sure.

[15:17] <moritz> well, nqp::while doesn't expect a block iirc

[15:17] *** mkramer left
[15:17] <TimToady> masak: my motivation for deciding to add %% was that I'd like to encourage languages to allow optional trailing ','

[15:17] <moritz> nqp:: nqp::while(1, say 'foo')

[15:17] <masak> TimToady: aye.

[15:17] <masak> TimToady: it's a worthy cause.

[15:17] <moritz> nqp: nqp::while(1, say('foo'))

[15:17] <jnthn> nom: nqp::while(1, say 'foo')

[15:17] <masak> TimToady: and the parallel with mainline %% is nice, too.

[15:17] <p6eval> nqp: OUTPUT«(timeout)foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤fo…

[15:17] <p6eval> nom ef6536: OUTPUT«(timeout)foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo␤foo…

[15:18] <TimToady> well, kinda

[15:18] <masak> or should I say mainlang.

[15:18] <TimToady> it's really more like % | %%

[15:18] <jnthn> moritz: yeah but while doesn't expect anything to be set :)

[15:18] <PerlJam> greetings #perl6 people

[15:18] <jnthn> o/ PerlJam 

[15:19] <TimToady> take him to our leader...oh wait...

[15:19] <masak> greetings oh Jam o' Perl.

[15:19] <PerlJam> what's new in the world today?

[15:20] *** alester joined
[15:20] <moritz> PerlJam: lots of backlog :-)

[15:21] <masak> PerlJam: there's an equal probability that there's 1 match or 2 matches in the remaining box!

[15:21] <PerlJam> masak: and you have proof?

[15:21] <masak> PerlJam: jlaire gave a good one.

[15:21] <masak> PerlJam: both (0, 1) and (0, 2) have to go through (1, 2), and they distribute from there 50%-50%.

[15:21] <moritz> http://irclog.perlgeek.de/perl6/2011-09-26#i_4482081

[15:22] <masak> without loss of generality we can assume a <= b in (a, b).

[15:23] <moritz> $ ./nqp -e 'nqp::for([1, 2], say(1))'

[15:23] <moritz> 1

[15:24] <moritz> but it doesn't seem to be good for anything else :(

[15:24] <PerlJam> #perl6 has such odd conversations sometimes :)

[15:24] <masak> you did ask :P

[15:25] <moritz> masak: ... as long as you include that factor of 2 in the absolut propabilities

[15:25] * PerlJam wonders if there's a market for #perl6-summaries ...

[15:26] <masak> moritz: nod.

[15:26] <moritz> PerlJam: fwiw I have an ilbot branch that allows colloborative summary editing

[15:27] <moritz> I think one day I'l just push it online forcibly, and flush the host of bugs that people report :-)

[15:28] <PerlJam> #perl6-summary: no, %% is not a joke; equal probabilty of 1 or 2 matches; Rakudo doesn't parse (1,2,3) X++ (1,2,3) properly; still no release;  etc.  

[15:28] *** donri joined
[15:28] <jnthn> std: (1,2,3) X++ (1,2,3)

[15:28] <p6eval> std 9fe2e1b: OUTPUT«===SORRY!===␤Postfix found where infix expected (omit whitespace?) at /tmp/xQ2hihsaN5 line 1:␤------> (1,2,3) X⏏++ (1,2,3)␤    expecting any of:␤      bracketed infix␤        infix␤  infix or meta-infix␤Parse failed␤FAILED 00:01 121m␤»…

[15:29] <jnthn> Guess Rakudo somehow parses it as X+ +(1,2,3)

[15:29] <PerlJam> jnthn: it does

[15:29] <jnthn> Gotta give it marks for effort :P

[15:29] <TimToady> it's LTA that it says to omit whitespace in STD

[15:29] <PerlJam> I even see why, but I'm not sure how to fix it.

[15:30] <moritz> proper LTM would likely help

[15:30] <TimToady> should probably say "add whitespace to disambiguate" if there's a metaop in front

[15:32] <moritz> japhb_: it seems I have a fix for that .named_names problem... will push after sucessful spectest (after commute)

[15:33] <japhb_> moritz, thank you!

[15:35] <dalek> std: 937241d | larry++ | STD.pm6:

[15:35] <dalek> std: tweak postfix where infix expected msg

[15:35] <dalek> std: review: https://github.com/perl6/std/commit/937241d51d

[15:35] <TimToady> now says "(change whitespace?)"

[15:37] <jnthn> stroll, bbs

[15:38] *** kaare_ joined
[15:38] *** Trashlord joined
[15:39] <sorear> good * #perl6

[15:40] *** packetkn_ left
[15:40] <sorear> masak: in Scheme it is traditional for objects with no source representation to be output by show as #<whatever>, like #<subr> for native subs

[15:41] <TimToady> .oO( .perl-try-harder )

[15:41] <sorear> masak: otoh, the Scheme parser knows about this and complains loudly if it sees #<

[15:41] <TimToady> std: #<subr>

[15:41] <sorear> masak: I wonder what a good analogous syntax for p6 would be

[15:41] <p6eval> std 9fe2e1b: OUTPUT«ok 00:01 117m␤»

[15:41] <TimToady> hmm

[15:42] <TimToady> did we remove that message?

[15:44] <TimToady> std: #<subr> ;

[15:44] <p6eval> std 9fe2e1b: OUTPUT«ok 00:01 117m␤»

[15:45] <masak> TimToady: I was surprised too.

[15:46] <masak> sorear: oh, so the problem is that a Match can't be created outside of a .parse call?

[15:46] *** SHODAN left
[15:47] *** Sarten-X left
[15:48] *** risou_awy is now known as risou

[15:51] *** im2ee joined
[15:51] <im2ee> Hello p6's world! :)

[15:52] *** espadrine joined
[15:52] <PerlJam> hello im2ee 

[15:54] *** Sarten-X joined
[15:55] <masak> cz im2ee!

[15:56] <masak> sorear: would I be able to make a regex match at BEGIN time and then use it in various ways at runtime?

[15:58] * masak decommutes

[15:58] *** masak left
[16:02] *** mishin_ left
[16:05] <sorear> phenny: tell masak Match objects in niecza hold references deep into the heart of the regex engine, to support things like $match.CURSOR.commit; ; I haven't tried writing Match.new yet but I doubt it will be pretty.

[16:05] <phenny> sorear: I'll pass that on when masak is around.

[16:05] <sorear> phenny: tell masak Yes.

[16:05] <phenny> sorear: I'll pass that on when masak is around.

[16:08] <sorear> niecza: my $x = 5; say '$x = \qq[$x]'

[16:08] <p6eval> niecza v9-53-g952a401: OUTPUT«$x = 5␤»

[16:09] *** simcop2387 left
[16:10] *** simcop2387 joined
[16:14] <sorear> flussence: How would you prefer to be identified in the Niecza change list?

[16:14] <sorear> phenny: tell flussence How would you prefer to be identified in the Niecza change list?

[16:14] <phenny> sorear: I'll pass that on when flussence is around.

[16:17] *** alim left
[16:18] <dalek> rakudo/nom: 16cb2b6 | moritz++ | src/core/Parameter.pm:

[16:18] <dalek> rakudo/nom: return Perl 6 strings from Parameter.named_names, japhb_++

[16:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16cb2b6e09

[16:20] <flussence> oh, hm

[16:20] <phenny> flussence: 16:14Z <sorear> tell flussence How would you prefer to be identified in the Niecza change list?

[16:20] <flussence> I dunno, by username I guess.

[16:21] <sorear> I credit people like Description of feature. (Solomon Foster)

[16:21] <sorear> so (flussence) here?

[16:22] <flussence> yeah, works for me

[16:23] *** thou left
[16:24] *** thou joined
[16:28] *** thou left
[16:31] <dalek> niecza: 82a017b | sorear++ | docs/announce.v10:

[16:31] <dalek> niecza: Add draft of announce.v10

[16:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/82a017ba49

[16:32] <sorear> looking-at appreciated

[16:34] *** kaleem left
[16:35] <sorear> [Coke]: it would probable be better to have an actual spectest.data patch from you, yes.

[16:36] *** packetknife joined
[16:37] *** kaleem joined
[16:37] * flussence looked-at, found nothing to nitpick

[16:37] <jnthn> [Breaking changes] - maybe a "None" under it

[16:39] <sorear> Oh, oops

[16:40] <sorear> I meant to delete empty subheads

[16:40] <dalek> niecza: 0faf460 | sorear++ | docs/announce.v10:

[16:40] <dalek> niecza: Delete empty subhead

[16:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0faf460149

[16:41] <jnthn> Even better.

[16:54] *** uasi left
[16:54] *** packetknife left
[16:54] *** dakkar left
[16:54] <japhb_> moritz++, thank you -- building now

[16:55] *** mj41_nb left
[16:55] <jlaire> s/etc/etc./

[16:56] <jlaire> or is it valid without the dot?

[16:56] *** PacoLinux left
[16:57] <donri> doesn't panda run on nom?

[16:57] <donri> protoregexes not yet implemented at line 10, near ";\ntoken va"

[16:58] *** PacoLinux joined
[16:58] <japhb_> S06 says: "If an attempted dispatch to MAIN fails, the USAGE routine is called. If there is no USAGE routine, a default message is printed to standard error. If the MAIN routine does not declare a named parameter :$help, and --help is passed as a command line argument to the program, the usage message is printed to standard output instead."

[16:59] <japhb_> In the face of MAIN being a multi with some having a :$help and some not, how should I decide that?

[17:00] <japhb_> (My gut feeling is that predicating the output stream based on whether or not a :$help param exists, given that if the usage message is being shown by definition no MAIN candidate matched, makes no sense.  --help should just always be recognized if the automated output kicks in at all.)

[17:00] <donri> looks like it's JSON::Tiny

[17:00] <jnthn> japhb_: Maybe you don't need to. If the dispatch failed, then at that point see if you got passed --help.

[17:00] <donri> tadzik? :)

[17:00] <jnthn> donri: No, it doesn't, for the reason stated in the error.

[17:00] <japhb_> jnthn, yeah, kinda where I was going

[17:01] <moritz> japhb_: that's probably the best way

[17:01] <jnthn> donri: This is perhaps the most major blocker to a nom-based release.

[17:01] <donri> aok

[17:01] <moritz> donri: yep, JSON::Tiny is know not to work yet on nom

[17:02] <moritz> (misses proto regexes and action methods)

[17:04] <japhb_> I've got to commute, so can't fix the spec right now, but if no one else gets to it today, I'll ask how.  :-)

[17:04] <japhb_> s/how/for a commitbit/

[17:08] *** localhost joined
[17:11] <sorear> diakopter, or anyone else who can: before I have to make an embarrasing retraction, could you make sure https://github.com/downloads/sorear/niecza/niecza-10.zip actually does run on .NET?

[17:14] <jlaire> sorear: seems to work for me (2+2 -> 4)

[17:14] <jlaire> should I run a test suite or something?

[17:15] <diakopter> sorear: ok; how shall I test it

[17:17] <diakopter> sorear: hm, that .zip failed to unzip

[17:17] <sorear> jlaire: 2+2 -> 4 was all I really wanted

[17:17] <jlaire> 7zip extracted it fine

[17:18] <jlaire> sorear: k

[17:19] *** japhb_ left
[17:20] <tadzik> donri: hm?

[17:21] <donri> nevermind :)

[17:28] *** Exodist left
[17:30] <[Coke]> sorear: (patch) it's going to be a lot of incremental changes. I can just keep my fork updated, I suppose.

[17:31] <[Coke]> (or send you lots of teeny patches)

[17:33] <sorear> [Coke]: How about I just give you a commit bit?

[17:36] *** masak joined
[17:36] <masak> \o/

[17:36] <phenny> masak: 16:05Z <sorear> tell masak Match objects in niecza hold references deep into the heart of the regex engine, to support things like $match.CURSOR.commit; ; I haven't tried writing Match.new yet but I doubt it will be pretty.

[17:36] <phenny> masak: 16:05Z <sorear> tell masak Yes.

[17:36] <masak> I see; ok :)

[17:38] <sorear> v10 announce sent.

[17:38] <im2ee> Which rakudo's branch should i have installed?

[17:39] <im2ee> And which version.

[17:40] <PerlJam> im2ee: for what purpose?

[17:41] <im2ee> For learning now, and developing i future (i hope so). :)

[17:41] <im2ee> On Rakudo Star i have some problems with IO::Select.

[17:43] <PerlJam> If your sole criteria is "fewer problems with IO::Select", I'm not sure what to tell you  :)

[17:43] <PerlJam> s/criteria/criterion/

[17:44] <PerlJam> im2ee: optimistically, I'd recommend that you use the nom branch.

[17:44] <PerlJam> im2ee: realistically, I'd recommend that you also use Bejing

[17:45] <im2ee> It's only the reason of my thoughs. I asked because i want to have something newer than Rakudo Start. :)

[17:46] <im2ee> Thanks PerlJam  :)

[17:46] <sorear> Perl 6 uses the term "module" for two related but distinct things

[17:46] <sorear> 1. objects created by the 'module' statement and represented by an instance of ModuleHOW or subclass

[17:46] <sorear> 2. .pm(6) files on the fileystem that can be loaded with 'use'

[17:47] <sorear> this is starting to cause serious confusion, and I think one or the other should be renamed

[17:47] <sorear> people see that IO::Socket::INET is a module(1) and assume it's also a module(20

[17:47] <PerlJam> sorear: which would you change and to what?

[17:48] <PerlJam> (I'd change #2 to be something like a "module distribution myself)

[17:48] <sorear> maybe #2 could become 'loadable module'

[17:48] <PerlJam> #2 may really be multiple #1 modules

[17:49] <diakopter> distro?

[17:49] <sorear> PerlJam: in p5speak, a distribution is a group of related modules

[17:49] <PerlJam> It's a good thing this is #perl6 then  :)

[17:50] <sorear> CPAN stores distributions; each distribution contains 1 or more .pm file

[17:52] <moritz> or 0

[17:53] *** aindilis joined
[17:54] <PerlJam> #2 is more like a "module file"  so we can make up our own term:  modfile  :)

[17:57] *** tomaw left
[17:58] *** benabik joined
[17:59] <masak> why is the ambiguity a problem, or causing confusion? I can point to (a) some source code, (b) a file on disk, or (c) some output, and in each case I can say "program" and mean it.

[18:01] <diakopter> niecza: module A { }; say A.WHAT

[18:01] <p6eval> niecza v9-55-g0faf460: OUTPUT«Unhandled exception: Unable to resolve method gist in class A␤  at /home/p6eval/niecza/lib/CORE.setting line 619 (CORE C341_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 620 (CORE gistcat @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 623 …

[18:01] <sorear> masak: people get confused and frustrated when we say "you can't 'use IO::Socket::INET'"

[18:03] <diakopter> niecza: module A { }; say A.WHO

[18:03] <p6eval> niecza v9-55-g0faf460: OUTPUT«Stash.new(...)␤»

[18:03] <diakopter> nom: module A { }; say A.WHO

[18:03] <p6eval> nom 16cb2b: OUTPUT«().hash␤»

[18:05] <jnthn> nom: module A { }; say A.WHO.WHAT

[18:05] <p6eval> nom 16cb2b: OUTPUT«Stash()␤»

[18:06] <diakopter> niecza: module A { class A { } }; say A::a

[18:06] <p6eval> niecza v9-55-g0faf460: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/AIowJGt4W_ line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2116 (C…

[18:06] <diakopter> ^^ error's lTA

[18:07] <sorear> impressive

[18:08] <sorear> perl6: module A { }; say A.HOW.WHAT

[18:08] <p6eval> niecza v9-55-g0faf460: OUTPUT«ClassHOW()␤»

[18:08] <p6eval> ..rakudo 16cb2b: OUTPUT«Method 'gist' not found for invocant of class 'Perl6::Metamodel::ModuleHOW'␤  in sub say at src/gen/CORE.setting:4893␤  in <anon> at /tmp/0Ba9ZS0b5W:1␤  in <anon> at /tmp/0Ba9ZS0b5W:1␤␤»

[18:08] <p6eval> ..pugs: OUTPUT«Module␤»

[18:08] <sorear> # niecza gets this one a bit wrong

[18:08] <sorear> heh, I found a hole in nom's not tying

[18:09] <jnthn> not?

[18:09] <jnthn> oh, knot

[18:09] <jnthn> Well

[18:09] <jnthn> It's kinda concious

[18:09] <diakopter> nom: module ::A { class ::A { } }; say A::A

[18:09] <p6eval> nom 16cb2b: OUTPUT«Could not find symbol 'A::&A'␤  in <anon> at /tmp/KFWbULHKVC:1␤  in <anon> at /tmp/KFWbULHKVC:1␤␤»

[18:09] <jnthn> Though I guess I'm resigned to having to tie that knot.

[18:10] <diakopter> nom: module ::A { class ::A { } }; say ::A::A

[18:10] <p6eval> nom 16cb2b: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol A::A␤»

[18:10] <jnthn> What does ::A there even mean?

[18:10] <sorear> niecza: module ::A { class ::A { } }; say ::A::A # curious

[18:10] <p6eval> niecza v9-55-g0faf460: OUTPUT«A()␤»

[18:10] <sorear> jnthn: I think diakopter is using his fuzz tester

[18:11] <jnthn> sorear: Yeah, I'm still curious though :)

[18:12] *** Chillance joined
[18:13] *** japhb_ joined
[18:13] <diakopter> "What does ::A there even mean [to diakopter]?" - no clue. to nom? no clue either

[18:13] <sorear> japhb_: Hi!

[18:14] <japhb_> sorear, o/

[18:14] <sorear> japhb_: what's your github username?

[18:14] <diakopter> nom: say ::::

[18:14] <p6eval> nom 16cb2b: OUTPUT«===SORRY!===␤Name component may not be null at line 1, near "::"␤»

[18:14] <diakopter> ah

[18:14] <japhb_> moritz++ # Fixing two bugs that I previously needed ugly hacks to work around before I got up this morning.  :-)

[18:15] <japhb_> sorear, japhb of course.  ;-)

[18:15] <sorear> japhb_: you can now push to roast and specs

[18:16] <moritz> sorear: did you add him to the 'perl6' team?

[18:16] <sorear> yes

[18:16] <japhb_> sorear, thank you

[18:16] <moritz> great, sorear++

[18:20] <diakopter> niecza: say ::.WHAT

[18:20] <p6eval> niecza v9-55-g0faf460: OUTPUT«PseudoStash()␤»

[18:20] <diakopter> niecza: PseudoStash()

[18:20] <p6eval> niecza v9-55-g0faf460: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class PseudoStash␤  at /tmp/uJSYYl3Mz1 line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line…

[18:21] * sorear out

[18:21] <sorear> niecza: say ::.{'CORE'}.WHO.{'&say'}.(52)

[18:21] <p6eval> niecza v9-55-g0faf460: OUTPUT«52␤Bool::True␤»

[18:23] <diakopter> interesting

[18:23] *** saaki left
[18:24] <diakopter> nom: say ::.{'CORE'}.WHO.{'&say'}.(52)

[18:24] <p6eval> nom 16cb2b: OUTPUT«===SORRY!===␤Cannot look up empty name␤»

[18:24] <masak> niecza: ::<CORE>.WHO<say>(52)

[18:24] <p6eval> niecza v9-55-g0faf460: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/AsrNTmEu_b line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2116 (C…

[18:24] <masak> niecza: ::.<CORE>.WHO<say>(52)

[18:24] <p6eval> niecza v9-55-g0faf460: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/QIT2DxaPBc line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2115 (CORE C1022_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2116 (C…

[18:25] <diakopter> niecza: ::.<CORE>.WHO<&say>(52)

[18:25] <p6eval> niecza v9-55-g0faf460: OUTPUT«52␤»

[18:26] <masak> oh, right.

[18:26] *** Holy_Cow left
[18:26] *** mj41 joined
[18:35] <tadzik> 'evening

[18:36] <masak> 'e

[18:36] *** kaleem left
[18:37] <diakopter> nom: module :::A { }; say A # confused

[18:37] <p6eval> nom 16cb2b: OUTPUT«Could not find sub &A␤  in <anon> at /tmp/sewiqQ3IvK:1␤  in <anon> at /tmp/sewiqQ3IvK:1␤␤»

[18:37] *** Exodist joined
[18:37] <diakopter> nom: module :::A { }; say ::A

[18:37] <p6eval> nom 16cb2b: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol A␤»

[18:37] <diakopter> nom: module :::A { }; say :::A

[18:37] <p6eval> nom 16cb2b: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol :A␤»

[18:42] *** zby_home joined
[18:42] *** dual joined
[18:51] *** aindilis left
[18:54] *** fridim_ joined
[18:54] *** mberends joined
[18:55] *** replore left
[18:57] *** im2ee left
[19:05] *** bubaflub joined
[19:08] *** daxim left
[19:14] <moritz> std: sub f($x) { my $x = $x }

[19:14] <p6eval> std 937241d: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $x (see line 1) at /tmp/3nAujHP5zv line 1:␤------> sub f($x) { my $x⏏ = $x }␤ok 00:01 124m␤»

[19:17] *** envi_laptop left
[19:23] *** wamba left
[19:24] *** packetknife joined
[19:27] *** packetknife left
[19:29] *** tomaw joined
[19:32] *** bluescreen10 left
[19:34] *** espadrine left
[19:37] *** im2ee joined
[19:38] *** PacoLinux left
[19:46] *** bluescreen10 joined
[19:52] <im2ee> good night!

[19:52] <masak> dobranoc!

[19:52] *** im2ee left
[20:04] *** pothos left
[20:04] *** y3llow left
[20:04] *** y3llow_ joined
[20:04] *** pothos_ joined
[20:05] *** pothos_ is now known as pothos

[20:06] <[Coke]> sorear: commit bit is fine with me. I'll stick with t/spectest.data for now and ping you before mucking with anything else.

[20:07] *** y3llow_ left
[20:08] *** y3llow joined
[20:08] <[Coke]> (me llamo "coke" on github)

[20:09] <masak> phenny: es en "me llamo 'coke'"?

[20:09] <phenny> masak: "I call it 'coke'" (es to en, translate.google.com)

[20:09] *** MayDaniel left
[20:12] <tadzik> it's spanish "My name is"

[20:12] <tadzik> hah, the Spanish classes showed the value, other than the idea for a Dancer port to Perl 6

[20:12] <masak> tadzik: I surmised as much.

[20:13] <masak> the -o ending is telltale of it being first person singular. that's the same as Latin, it seems.

[20:13] <[Coke]> My son is taking his second year of spanish. trying to encourage him by dredging up my long lost 7 years of study.

[20:14] *** zby_home left
[20:14] <jnthn> "Cerveza por favor!"

[20:15] <masak> [Coke]: hey, weren't you studying Mandarin just now?

[20:15] *** soh_cah_toa joined
[20:15] <PerlJam> "Donde esta el baño?"

[20:15] * masak .oO( 我的名子 llamo masak )

[20:16] <jnthn> PerlJam: Yes, that comes in useful after applying the other phrase several times :P

[20:16] <[Coke]> masak: Hai.

[20:16] <masak> that's Japanese :P

[20:17] <[Coke]> schiesse! I think I missed the deadline to sign up for the mandarin intro at continuing ed.

[20:17] <masak> :/

[20:17] <PerlJam> and that's german, looks like

[20:17] <masak> but misspelled.

[20:18] <[Coke]> masak: и?

[20:18] <masak> aarhj :)

[20:18] <masak> phenny: en de "shit!"?

[20:18] <phenny> masak: The en to de translation failed, sorry!

[20:18] <TimToady> well, it's Japanese in the sense that all those characters are used...but...

[20:19] <[Coke]> TimToady: he meant mine.

[20:19] <TimToady> ah, I see

[20:19] <[Coke]> I'm a little scattered at the moment.

[20:21] <TimToady> 'course, there are at least 14 characters that are pronounced "hai" in Mandarin...

[20:22] <masak> is there a word like "HiFi" in Japanese?

[20:22] *** supernovus joined
[20:23] <tadzik> o, coś leci

[20:23] <tadzik> ww

[20:23] <TimToady> well, Japanese doesn't have any [f] natively except at the beginning of /fu/

[20:23] <TimToady> well  /hu/, if you're being phonemic

[20:24] <TimToady> however, they do have ways to write it

[20:24] <TimToady> ハイファイ

[20:25] <TimToady> == 'hi-fi'

[20:26] <TimToady> ファ is a funny digraph, since it would presumably mean 'fua', but it really means to say 'fa' as a foreign sound

[20:27] <supernovus> An interesting nom error: "Incorrect pre-compiled version of lib/HTTP/Easy/PSGI.pm loaded" --  I've never come across this one before. If I remove the .pir file, it works fine. All the rest of the pre-compiled libraries work fine.

[20:30] <masak> TimToady: interesting.

[20:32] <diakopter> niecza: say 'abcbabcbabcba' ~~ / a: %% b: %% c /

[20:32] <p6eval> niecza v10: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[20:32] <diakopter> so it's right-associative?

[20:33] <masak> are you supposed to use it without a quantifier to modify?

[20:33] <masak> I'm not surprised at all it only matches 'a'.

[20:34] <diakopter> oh

[20:34] <diakopter> niecza: say 'abcbabcbabcba' ~~ / a+: % b+: % c /

[20:34] <p6eval> niecza v10: OUTPUT«#<match from(0) to(13) text(abcbabcbabcba) pos([].list) named({}.hash)>␤»

[20:34] <masak> \o/

[20:35] <diakopter> so it's right-associative

[20:35] <masak> :P

[20:36] <masak> niecza: say 'abcbabcbabcba' ~~ / a+: % [b+: % c] /

[20:36] <p6eval> niecza v10: OUTPUT«#<match from(0) to(13) text(abcbabcbabcba) pos([].list) named({}.hash)>␤»

[20:36] <masak> niecza: say 'abcbabcbabcba' ~~ / [a+: % b+:] % c /

[20:36] <p6eval> niecza v10: OUTPUT«===SORRY!===␤␤Unrecognized regex metacharacter % (must be quoted to match literally) at /tmp/eMQkniLhki line 1:␤------> say 'abcbabcbabcba' ~~ / [a+: % b+:] %⏏ c /␤␤Unable to parse regex; couldn't find final '/' at /tmp/eMQkniLhki …

[20:36] <masak> yeah, the left-associative way doesn't even seem to make sense.

[20:37] <diakopter> niecza: say 'abcbabcbabcba' ~~ / [a+: % b]+: % c /

[20:37] <p6eval> niecza v10: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[20:37] <masak> right, but that way of putting the brackets doesn't really make sense :)

[20:39] <dalek> std: 3f08f8f | larry++ | STD.pm6:

[20:39] <dalek> std: improve message for listop TTIAR

[20:39] <dalek> std: review: https://github.com/perl6/std/commit/3f08f8f8cf

[20:41] <dalek> ecosystem: e141914 | (Timothy Totten)++ | META.list:

[20:41] <dalek> ecosystem: Added HTTP::Easy to the ecosystem.

[20:41] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/e1419140c9

[20:44] <soh_cah_toa> are IO::Socket::INET and IO::Socket really not installed by default or is something just wrong w/ my installation?

[20:45] <supernovus> I am using them both right now, nom updated as of 2 hours ago.

[20:45] <soh_cah_toa> weird. i have 2011.07

[20:46] <jnthn> IO::Socket::INET iscore in b and nom.

[20:46] <jnthn> *is core

[20:46] <jnthn> e.g. in CORE

[20:46] <supernovus> all my stuff that uses IO::Socket::INET was tested under 2011.07 prior to updating to nom, and was working fine there. 

[20:46] <soh_cah_toa> ugh

[20:46] <soh_cah_toa> i'll just reinstall i guess

[20:51] <soh_cah_toa> alright, so what do i gotta do again to install nqp? i need to install parrot from the kill-useless-defaults branch?

[20:52] *** kaare_ left
[20:52] <supernovus> Oh, and I can confirm the issues I was having with IO::Socket::INET not auto-flushing are gone as of this week. Both the SCGI and HTTP::Easy libraries are working perfectly under nom as of today at least. Being able to load a dynamic web page generated live by Perl 6, and have it respond in less than a second is awesome.

[20:52] <soh_cah_toa> or install nqp from the kill-useless-defaults branch?

[20:52] <benabik> I don't have IO::Socket::INET either.  Hm.

[20:52] <jnthn> benabik: Don't have?

[20:52] <benabik> installed.

[20:52] <jnthn> nom: IO::Socket::INET

[20:53] <p6eval> nom 16cb2b: OUTPUT«Could not find symbol 'IO::Socket::&INET'␤  in <anon> at /tmp/Ojm4u7YtWD:1␤  in <anon> at /tmp/Ojm4u7YtWD:1␤␤»

[20:53] <jnthn> er

[20:53] <masak> jnthn: safe mode.

[20:53] <jnthn> Oh

[20:53] <jnthn> :)

[20:53] <supernovus> p6eval is SAFE setting, no sockets

[20:53] <jnthn> benabik: You won't have.

[20:53] <jnthn> benabik: It's in CORE.setting, not installed separately

[20:53] <benabik> Oh.

[20:53] <jnthn> benabik: Just like Array isn't installed. :)

[20:53] <benabik> Oh.

[20:54] <supernovus> If you compiled rakudo from source, it's in the "src/core/IO/Socket/" folder.

[20:54] <benabik> soh_cah_toa: ^^  Are you using "use IO::Socket::INET" or just trying to use IO::Socket::INET directly?

[20:55] <soh_cah_toa> benabik: 'use IO::Socket::INET'

[20:55] <supernovus> there is no need to "use IO::Socket::INET" since it is a CORE library. See the SCGI or HTTP::Easy libraries on modules.perl6.org for examples.

[20:56] <jnthn> It's not even a library. It's just a class in the setting.

[20:56] <soh_cah_toa> what does that mean? it's in CORE or setting

[20:57] <soh_cah_toa> i always see people talk about setting but don't actually know what it is

[20:57] <supernovus> What jnthn said, my terminology may be a bit out.

[20:57] <jnthn> soh_cah_toa: The setting is the outer lexical scope your program is running in.

[20:57] <supernovus> CORE is a setting.

[20:57] <jnthn> CORE is the name of the default one of those.

[20:57] <jnthn> It's where the built-ins (operators, functions, classes) come from.

[20:57] <benabik> soh_cah_toa: Standard library, of sorts.  All the functions and classes and… what jnthn just said.

[20:58] <soh_cah_toa> yeah, "standard library" would be a better word ;)

[20:58] <jnthn> Well, but the idea of it being the outer lexical scope is important at times.

[20:58] <soh_cah_toa> when i hear "setting" i think of "preferences" or "options"

[20:59] <jnthn> soh_cah_toa: That's not accidental. :)

[20:59] <supernovus> In Perl 6 it can do a lot more than a "standard library" though. It really does define what language features are available. See the SAFE setting in nom for instance, as an example of an alternative setting.

[20:59] <jnthn> soh_cah_toa: p6eval is started with --setting=SAFE

[20:59] <benabik> soh_cah_toa: I think it's because the default setting is only just that, the default.  Crazy people can define their own builtins.

[20:59] <jnthn> soh_cah_toa: Which provides a different set of preferences (e.g. no sockets) :)

[20:59] <soh_cah_toa> interesting

[20:59] <masak> soh_cah_toa: http://strangelyconsistent.org/blog/dash-n-and-dash-p-part-three

[21:00] <masak> should be relevant to this discussion.

[21:00] <soh_cah_toa> ok

[21:01] <soh_cah_toa> so that means i could also call it OUTER::IO::Socket::INET, correct?

[21:01] *** bbkr left
[21:02] <jnthn> Yes, if Rakudo implemented OUTER:: :)

[21:02] <benabik> jnthn: You and your pesky details.

[21:02] *** bbkr joined
[21:02] <supernovus> So, what's the status of the "Method 'rxtype' not found for invocant of class 'PAST;Regex'" issue? (which I believe is related to variable interpolation in regexes.)

[21:03] <jnthn> supernovus: Things are moving a little slowly there; pmichaud++ has a bit of a tuit shortage at the moment.

[21:07] <masak> guten nacht, #.

[21:07] <tadzik> g'night

[21:07] *** soh_cah_toa left
[21:08] <masak> tadzik: good night and good morning ;)

[21:08] *** masak left
[21:08] <tadzik> (:

[21:08] *** soh_cah_toa joined
[21:10] <supernovus> jnthn: Ah, okay. Once it's fixed, my Exemel library should be working under nom. I can't wait to see how much faster Exemel is under nom. :-)

[21:11] <PerlJam> supernovus: what makes you think it's going to be faster?  :)

[21:13] <jnthn> Well, given it depends on grammars, and the new grammar engine is meant to be faster, there's a decent chance. :)

[21:14] <PerlJam> I'm a "don't count your chickens" kind of person.

[21:15] <supernovus> PerlJam: Everything so far has been greatly faster! Serving web pages through SCGI is at least twice as fast now, so I'm hoping XML parsing and operations will benefit in nom too :-)

[21:15] <jnthn> I don't own any chickens. It's kinda inconvenient in an appartment.

[21:15] <PerlJam> jnthn: does that mean you don't count your no chickens?

[21:16] <jnthn> PerlJam: What no chickens? :P

[21:16] <supernovus> anyway, bbiab

[21:16] *** skangas left
[21:16] <PerlJam> jnthn: actually, I bet you have some liquid chickens in your refrigerator.

[21:17] *** cognominal_ joined
[21:18] <jnthn> PerlJam: Don't think I do at the moment actually... :)

[21:18] <jnthn> japhb_: About?

[21:18] <japhb_> Am now

[21:18] <japhb_> Have not backlogged, what's up?

[21:19] <jnthn> japhb_: Just spectesting and about to push a patch to make candidates_matching work as you want for only subs as well as multis.

[21:19] <japhb_> ooh, thanks!

[21:19] <jnthn> Was that your main "blocker"?

[21:19] <japhb_> jnthn++

[21:19] <jnthn> Or anything else I should look at while I have a moment?

[21:19] <soh_cah_toa> my $socket = IO::Socket::INET.new(:host<http://google.com>);

[21:19] <soh_cah_toa> getaddrinfo failed: http: Success

[21:19] <soh_cah_toa>   in 'IO::Socket::INET::BUILD' at line 6127:src/gen/core.pm

[21:19] <soh_cah_toa>   in 'IO::Socket::INET::new' at line 6105:src/gen/core.pm

[21:20] <soh_cah_toa> what the heck? it seems that it doesn't matter what hostname i specify

[21:20] *** cognominal left
[21:20] <jnthn> soh_cah_toa: try just google.com

[21:20] <jnthn> Not the protocol specifier

[21:20] <soh_cah_toa> oh jeez...

[21:20] <japhb_> Actually the biggest blocker ... I'm not sure if it's Rakudo or me.  Basically I haven't figured out how to parse a string using a rule from the Perl6 Grammar.  nom seems not to like :: inside subrule names ...

[21:20] * soh_cah_toa bangs his head on keyboard

[21:21] <soh_cah_toa> wow

[21:21] <soh_cah_toa> yeah, that was obvious

[21:21] <benabik> soh_cah_toa: It's always the easy stuff you miss.

[21:21] <soh_cah_toa> oh yeah. definitely

[21:21] <jnthn> japhb_: Ah...yeah, that's trickier.

[21:21] <japhb_> jnthn, and closer to your neck of the woods: being able to see Parameter.constraints was #1.5 .  :-)

[21:23] <jnthn> oh, that one I can look at.

[21:23] <japhb_> Yay!

[21:23] <dalek> rakudo/nom: 570bc95 | jnthn++ | src/core/Routine.pm:

[21:23] <dalek> rakudo/nom: Make Routine.candidates_matching work on only routines as well as multis for japhb++.

[21:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/570bc9510e

[21:23] <japhb_> That would make it a lot easier to implement val(), and handle all the variant ways that the spec wants you to be able to specify options ...

[21:23] <diakopter> std: my @a; say #$a

[21:23] <p6eval> std 3f08f8f: OUTPUT«===SORRY!===␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/ZMs3zwoZTi line 1:␤------> my @a; say⏏ #$a␤Check failed␤FAILED 00:01 120m␤»

[21:24] <japhb_> jnthn, I meant that in regards to the parsing.

[21:24] <japhb_> jnthn, the constraints thing seems necessary when specifying git-like commands where the constraint really is just a required parameter

[21:25] <japhb_> multi MAIN ('commit', ...) {}

[21:25] <japhb_> that sort of thing

[21:25] <jnthn> ah, ok

[21:26] <diakopter> hum, a better error message for #$a might be helpful

[21:27] <diakopter> on second thought, no

[21:27] <benabik> diakopter: #$a is a comment.  It gets tossed very early.

[21:27] <japhb_> The original usage-message-gen code did this odd thing where if a param did not have a name, it tried to stringify the constraint instead, and I was mystified by this choice of fallback until I had the "a-ha!" moment regarding sub-command style CLI tools.

[21:27] <jlaire> std: my @a; say $#a

[21:27] <p6eval> std 3f08f8f: OUTPUT«===SORRY!===␤Unsupported use of $#a variable; in Perl 6 please use @a.end at /tmp/FbcmocQ5RT line 1:␤------> my @a; say $#a⏏<EOL>␤Parse failed␤FAILED 00:01 121m␤»

[21:27] <diakopter> oh oops

[21:30] <japhb_> jnthn, BTW, here's an example of the current WIP output of the usage generator: https://gist.github.com/1243461

[21:30] <jnthn> oh, nice!

[21:30] <diakopter> benabik: I was aware that was a comment.

[21:31] *** Exodist left
[21:31] <benabik> diakopter: Examining comments for possible code seems poor to me.

[21:32] <diakopter> yes, I'd poorly remembered the order of $#

[21:32] <benabik> …  $#?  :-P

[21:32] <diakopter> yes, as jlaire pointed out above.

[21:33] <benabik> Never seen it before, it doesn't look nice.

[21:33] <flussence> I broke something again... https://gist.github.com/1243472

[21:33] <diakopter> and to which I reponded "oh oops"

[21:35] <jlaire> hey, $#x is a whole character shorter than @x-1 ;)

[21:36] <jnthn> > sub foo("pivo") { }; say &foo.signature.params[0].constraints.perl

[21:36] <jnthn> ("pivo",)

[21:36] <jnthn> japhb_: ^^

[21:36] *** bbkr left
[21:36] <jnthn> Spectesting.

[21:37] <japhb_> jnthn, oooh, nice

[21:38] *** bbkr joined
[21:40] *** skangas joined
[21:41] *** bluescreen10 left
[21:41] <dalek> rakudo/nom: 870306b | jnthn++ | src/Perl6/Actions.pm:

[21:41] <dalek> rakudo/nom: Don't create a thunk that does a smart match for literal value constraints; the binder simply calls .ACCEPTS anyway, so we can just use the literal. Faster, and introspects better.

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/870306bf70

[21:41] <dalek> rakudo/nom: 3e8911a | jnthn++ | src/core/Parameter.pm:

[21:41] <dalek> rakudo/nom: Implement Parameter.constraints; fix NPMCA in Parameter.named_names.

[21:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e8911a020

[21:47] * jnthn grabs himself an oak-aged beer and hacks on optimizer branch a little more before bed

[21:48] <tadzik> \o/

[21:51] <dalek> std: ad1e550 | larry++ | CORE.setting:

[21:51] <dalek> std: remove some specrot from CORE.setting

[21:51] <dalek> std: review: https://github.com/perl6/std/commit/ad1e55067b

[21:52] <jnthn> TimToady: my class Multi { }

[21:52] <jnthn> TimToady: This one makes no sense under the current multi model.

[21:52] <sorear> good * #perl6

[21:52] <jnthn> TimToady: A proto is just a Routine of some kind.

[21:52] <jnthn> o/ sorear 

[21:53] <sorear> I'm a little suprised google didn't get a better literal translation for 'Me llamo Coke'

[21:54] <sorear> it's a completely regular use of the object pronoun, should be 'I call me Coke', not 'I call it Coke'

[21:54] *** mj41 left
[21:54] <sorear> phenny: es en "llamome 'coke'"?

[21:54] <phenny> sorear: "called me 'coke'" (es to en, translate.google.com)

[21:54] <sorear> phenny: es en "llámome 'coke'"?

[21:54] <phenny> sorear: "called me 'coke'" (es to en, translate.google.com)

[21:55] <sorear> that's the other object form, I see it works a *little* better

[21:55] <jnthn> phenny: es en "me llamo Pedro"?

[21:55] <phenny> jnthn: "My name is Peter" (es to en, translate.google.com)

[21:55] <sorear> but llamome isn't the idiomatic way

[21:55] <jnthn> sorear: I'm wondering if it's seeing "coke" and thinking of the drink :)

[21:55] <jnthn> sorear: Some weird statistical misfortune.

[21:56] <dalek> std: 62fce78 | larry++ | STD.pm6:

[21:56] <dalek> std: wrongly warns on x ** {3} and such

[21:56] <dalek> std: review: https://github.com/perl6/std/commit/62fce78373

[21:57] <jnthn> sorear: A while back, asking Google translate to sk en "v peknej Bratislave" produced "in beautiful Prague" (it changed the city name while translating!)

[21:58] <dalek> std: 2da0153 | larry++ | CORE.setting:

[21:58] <dalek> std: rm Multi fossil from CORE

[21:58] <dalek> std: review: https://github.com/perl6/std/commit/2da0153344

[21:58] <sorear> jnthn: good to know my linguistic skills won't become obsolete *quite* yet

[21:58] <sorear> (living on the border helps me Spanish not rust)

[21:59] *** bluescreen10 joined
[21:59] <jnthn> Yeah, living somewhere helps a lot.

[21:59] <jnthn> Or in an area where the language is spoken.

[21:59] <jnthn> I'm really looking forward to going to Slovakia for Twin City Perl Workshop in November...can try and de-rust my Slovak a tiny bit.

[22:00] <TimToady> sorear: what needs to happen to the STD bootstrap to transition from ** to %?

[22:01] <sorear> TimToady: I think there's a make boot or make reboot rule that will copy the newly-built STD to boot/, then you can commit that and start using it

[22:02] <sorear> jnthn: how's your Swedish?

[22:02] <TimToady> well, but STD uses ** badly :)

[22:02] <jnthn> sorear: Pretty bad. :(

[22:02] <dalek> rakudo/optimizer: d34c4e3 | jnthn++ | src/pmc/mdthunk.pmc:

[22:02] <dalek> rakudo/optimizer: Set flag to make sure that inlined protos don't end up with us re-running type checks.

[22:02] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/d34c4e38f7

[22:02] <jnthn> sorear: Mostly due to lack of effort/motivation 

[22:02] <jnthn> sorear: I know enough to survive the typical trip to the supermarket/pizzeria/restaurant/bar.

[22:02] * sorear checks for interesting p6 tweets, remembers ey needs to get Japanese better

[22:03] <jnthn> sorear: I find myself increasingly able to parse/read it, but my speaking/writing/listening skills lag far behind.

[22:03] <jnthn> phenny: tell moritz nice cleanup job on the tests optimizer disliked :)

[22:03] <phenny> jnthn: I'll pass that on when moritz is around.

[22:04] <jnthn> phenny: tell moritz S04-exception-handlers/catch.t seems to legitimately fail CHECK still.

[22:04] <phenny> jnthn: I'll pass that on when moritz is around.

[22:08] <TimToady> wow, my linux kernel crashed--been a while since that happened

[22:08] <TimToady> it's probably jealous of my new android phone...

[22:09] <diakopter> what crashed it

[22:09] <TimToady> well, I was running viv STD.pm6 at the time... :)

[22:09] <TimToady> and also a snaptest

[22:10] <diakopter> #perl6. we will break your linux.

[22:15] <jnthn> .oO( perl6 never crashed my OS... )

[22:19] *** replore_ joined
[22:23] *** alester left
[22:26] *** uasi joined
[22:27] <dalek> std: 8b331d2 | larry++ | STD.pm6:

[22:27] <dalek> std: missing space char

[22:27] <dalek> std: review: https://github.com/perl6/std/commit/8b331d2ddf

[22:37] <Woodi> rakudo: class A { our %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n } }; my $a = A.new;

[22:37] <p6eval> rakudo 3e8911: OUTPUT«Method 'STORE' not found for invocant of class 'Any'␤  in <anon> at /tmp/MZY0dGvQvt:1␤  in <anon> at /tmp/MZY0dGvQvt:1␤  in <anon> at /tmp/MZY0dGvQvt:1␤␤»

[22:39] <Woodi> with list in .keys place it work... how early our varibles are build ?

[22:39] <Woodi> works on Star, no error

[22:39] <jnthn> That looks like it should work.

[22:39] *** benabik left
[22:40] <jnthn> nom: our %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n }

[22:40] <p6eval> nom 3e8911: OUTPUT«Method 'STORE' not found for invocant of class 'Any'␤  in <anon> at /tmp/axHNVa5F4B:1␤  in <anon> at /tmp/axHNVa5F4B:1␤␤»

[22:40] <jnthn> OK, the class is nothing to do with it.

[22:40] <jnthn> nom: my %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n }

[22:40] <p6eval> nom 3e8911: OUTPUT«a␤b␤»

[22:40] <TimToady> our vars are supposed to be initialized at INIT time

[22:40] <Woodi> maybe our should be in package/module space ?

[22:40] <jnthn> No, it should be fine in mainline too; that's implicitly GLOBAL package.

[22:41] *** bubaflub left
[22:41] *** replore_ left
[22:41] <Woodi> mainline means 'in class' ? :)

[22:41] <TimToady> nom: state %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n }

[22:41] <p6eval> nom 3e8911: OUTPUT«(signal SEGV)»

[22:41] <TimToady> coo!

[22:42] <Woodi> btw. i would like to make that our const - do const work in nom ?

[22:42] <TimToady> nom: constant %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n }

[22:42] <p6eval> nom 3e8911: OUTPUT«===SORRY!===␤Cannot handle constant %a with non-literal value yet at line 1, near "= { 'a' =>"␤»

[22:42] <TimToady> niecza: constant %a = { 'a' => 1, 'b' => 2 }; for %a.keys -> $n { say $n }

[22:43] <p6eval> niecza v10: OUTPUT«a␤b␤»

[22:43] <TimToady> niecza: constant %a = { 'a' => 1, 'b' => 2 }; BEGIN { for %a.keys -> $n { say $n } }

[22:43] <p6eval> niecza v10: OUTPUT«a␤b␤»

[22:43] <TimToady> niecza++ !

[22:44] <jnthn> TimToady: er

[22:44] <jnthn> TimToady: That isn't actually BEGIN time though.

[22:44] <jnthn> TimToady: Stick a syntax error after it.

[22:44] <Woodi> b: constant %a = { 'a' => 1, 'b' => 2 }; BEGIN { for %a.keys -> $n { say $n } }

[22:44] <TimToady> niecza: constant %a = { 'a' => 1, 'b' => 2 }; BEGIN { for %a.keys -> $n { say $n } }; 1 2

[22:44] <p6eval> niecza v10: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/OHkws9EsbG line 1:␤------> GIN { for %a.keys -> $n { say $n } }; 1 ⏏2␤␤Parse failed␤␤»

[22:44] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Constant type declarator not yet implemented at line 22, near "= { 'a' =>"␤»

[22:45] <jnthn> TimToady: I could kinda cheat on the constant stuff but I'd rather spend the time implementing serialization properly than doing throwaway cheats...

[22:45] <TimToady> +1

[22:45] <jnthn> Having too much -Ofun in optimizer land at the moment though :)

[22:46] <TimToady> niecza--  # take it back :)

[22:51] <supernovus> Any known workarounds for the RegEx variable interpolation? I tried the very hackish eval method from pre-alpha but it doesn't work in nom...

[22:51] <TimToady> pugs: sub foobar(NoneSuch $str) { say "$str is defined" }; foobar('qux')

[22:51] <p6eval> pugs: OUTPUT«qux is defined␤»

[22:52] <TimToady> sorear: ^^

[22:52] <sorear> TimToady: I think you wanted audreyt

[22:52] <TimToady> it ignores types on non-multis, I think

[22:52] <sorear> supernovus: could you elaborate on the issue?

[22:52] <TimToady> you were the one wondering about http://irclog.perlgeek.de/perl6/2011-09-25#i_4479168

[22:53] <sorear> ah

[22:53] *** envi_laptop joined
[22:55] <supernovus> if you have a variable $word with a string "hello" and do a:   if $somestring ~~ / ^ $word ':' / { say "somestring starts with hello." }   it currently breaks because variables don't interpolate into regexes at the moment. In pre-alpha you could do: eval("/^$word ':'/");   and it would return a compiled regex.

[22:55] <supernovus> that was meant for sorear by the way...

[22:55] *** wolfman2000 joined
[22:56] <sorear> supernovus: pre-alpha?  seriously?

[22:56] <sorear> pre-alpha ended in, like, 2006

[22:57] <supernovus> sorear: okay, better phrased, prior to variable interpolation in the alpha branch.

[22:57] <sorear> supernovus: if this was an alpha issue why are you bringing it up now

[22:57] <sorear> are you confusing alpha with nom?

[22:58] <supernovus> sorear: No. The variable interpolation issue in nom is completely separate from the one in alpha. I tried using the workaround that was used in alpha, but it doesn't work in nom. 

[22:59] <sorear> perl6: my $somestring = 'hello: world'; my $word = 'hello'; if $somestring ~~ / ^ $word ':' / {say "somestring starts with hello." }

[22:59] <p6eval> rakudo 3e8911: OUTPUT«===SORRY!===␤Method 'rxtype' not found for invocant of class 'PAST;Regex'␤»

[23:00] <p6eval> ..niecza v10: OUTPUT«somestring starts with hello.␤»

[23:00] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HANDLE>' trapped b…

[23:00] *** whiteknight joined
[23:01] <supernovus> sorear: The evil rxtype error, thus what I am working around.

[23:01] <TimToady> sorear: re http://irclog.perlgeek.de/perl6/2011-09-25#i_4479703, that's one of those "just like Perl 5" things :)

[23:02] <sorear> oops, I meant to fix that before the release

[23:02] <TimToady> eval "aaabc" ~~ / a++ abc /

[23:02] <buubot_backup> TimToady: No output.

[23:03] <TimToady> eval print "aaabc" ~~ / (a++) abc /

[23:03] <buubot_backup> TimToady: 1

[23:03] <TimToady> eval print "aaabc" ~~ / (a+) abc /

[23:03] <buubot_backup> TimToady: 1

[23:03] *** molaf__ joined
[23:04] <TimToady> eval "aaabc" ~~ / (a+) abc /; print $1

[23:04] <buubot_backup> TimToady: 1

[23:04] <TimToady> eval "aaabc" ~~ / (a+) abc /; $1

[23:04] <buubot_backup> TimToady: No output.

[23:04] <TimToady> bleah

[23:04] <TimToady> eval "aaabc" =~ / (a+) abc /; $1

[23:04] <buubot_backup> TimToady: No output.

[23:04] <TimToady> eval "aaabc" =~ / (a+) abc /; print $1

[23:04] <buubot_backup> TimToady: 1

[23:05] <TimToady> this is not your father's perl...

[23:05] <TimToady> eval "aaabc" =~ / (a+) abc /x; print $1

[23:05] <buubot_backup> TimToady: aa1

[23:05] <TimToady> eval "aaabc" =~ / (a++) abc /x; print $1

[23:05] <buubot_backup> TimToady: 1

[23:05] *** wolfman2_ joined
[23:06] * TimToady has forgotten nearly all of his P5, it would seem, except for that ++

[23:07] <TimToady> which, oddly, was added after I started working on P6 instead...go figure...

[23:07] *** molaf_ left
[23:08] <dalek> niecza: 02435c5 | sorear++ | src/NieczaActions.pm6:

[23:08] <dalek> niecza: + as a quantmod is a synonym of :

[23:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/02435c5b7c

[23:08] <dalek> rakudo/optimizer: f910191 | jnthn++ | / (3 files):

[23:08] <dalek> rakudo/optimizer: Infrastructure to support calling a multi candidate determined at compile time, and not repeating arg type checks.

[23:08] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/f910191dcc

[23:08] <dalek> rakudo/optimizer: 031a827 | jnthn++ | src/ops/perl6.ops:

[23:08] <dalek> rakudo/optimizer: Write barriers.

[23:08] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/031a827d19

[23:08] <dalek> rakudo/optimizer: f9d86d1 | jnthn++ | src/Perl6/ (2 files):

[23:08] <dalek> rakudo/optimizer: First cut of just calling straight to a multi candidate picked at compile, and skipping any bind-time type checks (since we know they aren't needed). Note that it finds barely anything at compile time yet, probably since we hardly have any type information in the tree.

[23:08] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/f9d86d1adb

[23:08] *** wolfman2000 left
[23:09] *** araujo left
[23:12] *** wolfman2000 joined
[23:14] *** wolfman__ joined
[23:14] *** wolfman__ left
[23:15] *** wolfman2_ left
[23:16] *** tokuhiro_ joined
[23:17] *** wolfman2000 left
[23:17] <ingy> hi

[23:17] <TimToady> yodood

[23:18] <ingy> does <a> % <b> mean anything TimToady ?

[23:18] <sorear> hi

[23:18] <TimToady> no

[23:18] <ingy> hmms

[23:18] <TimToady> std: <a> % <b>

[23:18] <p6eval> std 8b331d2: OUTPUT«ok 00:01 121m␤»

[23:18] <TimToady> er

[23:18] <ingy> twas afraid of that

[23:18] <TimToady> std: /<a> % <b>/

[23:18] <p6eval> std 8b331d2: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter % (must be quoted to match literally) at /tmp/B3oK8beB7g line 1:␤------> /<a> %⏏ <b>/␤Unable to parse regex; couldn't find final '/' at /tmp/B3oK8beB7g line 1:␤------> /<a> %…

[23:18] <TimToady> std: /<a>+ % <b>/

[23:18] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:18] *** jeffreykegler joined
[23:19] <TimToady> std: /<a> ** 1 % <b>/

[23:19] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:19] <TimToady> if anything, it would mean that

[23:19] <ingy> right

[23:19] <TimToady> which does make much use of the separator :)

[23:20] <ingy> doesn't?

[23:20] <TimToady> yes, my n't key is busted today

[23:20] <ingy> you fixed it

[23:21] <ingy> my jury's still out on this

[23:22] <ingy> is <a>+ % <b> roughly <a> +% <b> ?

[23:23] <ingy> sans sigspace issues

[23:23] <TimToady> depends on what you mean by that

[23:23] <TimToady> but p5 doesn't care where you put the space

[23:24] <TimToady> std: / x + % y /

[23:24] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:24] <TimToady> std: / x **5% y /

[23:24] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:24] <TimToady> er, s/p5/p6/

[23:26] <TimToady> but note

[23:26] <sorear> std: /x**y/

[23:26] <p6eval> std 8b331d2: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** y as separator; nowadays please use atom+ % y at /tmp/ZkobbqiwOB line 1:␤------> /x**y⏏/␤ok 00:01 120m␤»

[23:26] <TimToady> std: / x%y /

[23:26] <p6eval> std 8b331d2: OUTPUT«===SORRY!===␤Variable %y is not predeclared at /tmp/8zJw9UpGIB line 1:␤------> / x⏏%y /␤Check failed␤FAILED 00:01 121m␤»

[23:26] <TimToady> std: / x+%y /

[23:26] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:26] <TimToady> that one motivation for keeping the + required

[23:28] <TimToady> but also, if people get used to seeing x % y, they'll think they can say x* % y to mean [x*]+ % y

[23:28] <TimToady> and that would be bad

[23:29] <TimToady> std: / x+ %% y /

[23:29] <p6eval> std 8b331d2: OUTPUT«ok 00:01 120m␤»

[23:29] <dalek> nqp: b9715f1 | jnthn++ | src/PAST/SixModelPASTExtensions.pir:

[23:29] <dalek> nqp: Enable us to set :type(...) on any PAST node, not just PAST::Var.

[23:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b9715f103d

[23:29] <ingy> let me write something up

[23:30] <ingy> brb

[23:30] <dalek> rakudo/optimizer: ad5f98c | jnthn++ | src/Perl6/SymbolTable.pm:

[23:30] <dalek> rakudo/optimizer: Flag various literals as being able to dispatch as native types (which calls back to their boxed forms); spots a few more things. S06-multi/lexical-multis.t falls victim to a 'could never work' detected at compile time.

[23:30] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/ad5f98c4f1

[23:36] *** envi_laptop left
[23:38] <jnthn> sleep

[23:38] <jnthn> &

[23:43] *** jeffreykegler left
[23:48] <dalek> roast: 384c821 | larry++ | S05-modifier/ (2 files):

[23:48] <dalek> roast: :a and :aa changed to :m and :mm long ago

[23:48] <dalek> roast: review: https://github.com/perl6/roast/commit/384c821b4d

[23:53] <ingy> TimToady: https://gist.github.com/1243786

[23:53] <dalek> roast: 4ba1a2f | larry++ | S05-modifier/ (4 files):

[23:53] <dalek> roast: s/accent/mark/ in filenames too

[23:53] <dalek> roast: review: https://github.com/perl6/roast/commit/4ba1a2f3f8

[23:53] *** Chillance left
[23:53] <ingy> TimToady: let me know if that makes sense

[23:54] <supernovus> seems like rules have changed how they handle space in nom... 

